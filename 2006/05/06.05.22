00:08:34 <Lokadin> say there doesn't happen to be a tutorial for haxml does there?
00:10:58 <ADEpt> Lokadin: I'm afraid there doesn't
00:11:03 <ADEpt> Lokadin: i could try to help
00:11:19 <dons> you could start on a tutorial on the wiki
00:11:35 <dons> there's generally a lack of tutorials for particular libraries, in haskell, i would say
00:12:28 <ADEpt> dons: SOC assignments are finalized today, right?
00:12:50 <dons> yep, 5pm PDT, iirc.
00:13:05 <dons> 17 hours. (the deadline got moved back)
00:13:27 <ADEpt> dons: it seems that we are  not going to change anything, right?
00:14:05 <dons> the last question is the yhc project. we need malcolm to check the status of the submission we just got back from google. check the mentors ml for details.
00:14:09 <dons> otherwise, no, its all fine.
00:14:42 <ADEpt> dons: ok, thnx
00:17:51 <Lokadin> ADEpt: really? :)
00:18:21 <Lokadin> ADEpt: er i mean well i just wanted to see an example of a really simple read and write file
00:18:27 <ADEpt> Lokadin: to the extent of my limited knowledge :)
00:18:42 <dons> Lokadin: btw, I got your yi patches, and they're in the repo now. thanks!
00:19:06 <Lokadin> dons: :) 
00:19:14 <ADEpt> Lokadin: then look at the source of Canonicalise from HaXml
00:19:18 <dons> ?karma+ Lokadin -- patches
00:19:19 <lambdabot> Lokadin's karma raised to 1.
00:19:45 <Lokadin> ADEpt: kk one sec
00:27:04 <shapr> Yow, where's the SoC discussion happening?
00:31:43 <kzm> On email?
00:31:56 <dons> email
00:33:02 <shapr> ok
00:57:05 <shapr> So, anything exciting happening?
00:57:12 <shapr> All of my recent interesting stuff is off-topic.
00:58:37 <dons> did you see the Linspire/haskell announce last week?
00:58:57 <shapr> Yeah, and sent 'em my resume :-)
00:59:08 <dons> hehe cool ;) i stuck it on haskell.org's front page
00:59:25 * kzm checked the date stamp before actaully believing it.
00:59:27 <shapr> stepcut: w00! Go Linspire!
00:59:49 <dons> kzm, me too. i had to do some research before i was confident to stick it in the HWN.
01:00:09 <kzm> Yes.  It didn't really get commented a lot, but I don't think it was due to lack of interest.
01:00:09 <shapr> Over the last few years stepcut (who works at Linspire) has asked various system questions, so I suspected they were doing some stuff with Haskell.
01:00:17 <shapr> It's nice to know they've switched entirely to Haskell.
01:00:43 <shapr> There's more commercial use of Haskell than you might think.
01:00:46 <dons> its great. and only a couple of weeks after I saw some debian guys _joking_ about switching to haskell.
01:00:53 <shapr> Yeah well...
01:01:24 <shapr> My power supply just fried (don't you love the smell of burning plastic?) so I sort of have a spare box I can install freespire onto.
01:01:56 <dons> power supplies are terrible. they must be the worst feature of the pc. 
01:02:09 <shapr> btw, a 2.4GHz P4 isn't nearly as powerful as two 1.5GHz Athlon MPs.
01:02:11 * dons pats his laptop-ac fanless via box.
01:02:20 <shapr> I lost about 1500 BogoMips :-(
01:02:29 <dons> ah, very interesting
01:12:32 <thelsdj> p4's are also much slower than p3's per mhz which is kinda stupid
01:19:01 <kzm> shapr, so you're saying the Athlon can do nothing much faster than the P4?
01:19:46 <kzm> (and after all, CPUs are idle most of the time, so idle performance is *very* important :-)
01:20:42 <shapr> Truly, I agree.
01:20:59 <shapr> As for kernel compile time, the single P4 takes roughly twice as long.
01:21:06 <shapr> Even with twice the amount of ram.
01:21:34 <thelsdj> shapr: how many make threads?
01:21:58 <shapr> On the other hand, the cost of registered ECC ram for the dual Athlon MP is roughly twice the cost of DIMMs for the P4 :-(
01:22:04 <shapr> thelsdj: three threads on the Athlon MP
01:22:16 <shapr> Maybe I should be using two threads on the P4?
01:22:20 <eivuokko> Yes.
01:22:26 <thelsdj> actually, i would have suggested 5 and 3
01:22:28 <shapr> Ok, I'll try that next.
01:22:30 <shapr> Wow
01:22:37 <thelsdj> 2x proc + 1
01:22:54 <eivuokko> P4's that have hyperthreading really do not run even nearly at full power singlethreaded, ever.
01:23:11 <thelsdj> i always turn off hyperthreading
01:23:17 <eivuokko> Your loss.
01:23:40 <shapr> At the moment this P4 says "hyperthreading disabled" when it boots. Since I haven't owned/used an Intel chip in years, I don't know why or how to turn it on.
01:23:49 <eivuokko> When I tested it, I found no performance gains when ht was off.
01:24:13 <eivuokko> Usually BIOS has setting for it.  You need SMP kernel if you are in linux, I'd think.
01:24:19 <shapr> I'm using an SMP kernel.
01:24:28 <shapr> I'll check the BIOS on next reboot.
01:24:38 <thelsdj> for work these days we use dual pentium d systems, not bad, i have 2 on my desk right now
01:24:48 <thelsdj> er i mean dual core
01:24:58 <shapr> Personally, I wish I had a dualcore amd64.
01:24:58 <thelsdj> dual core pentium d 3.0ghz with 4gb ram
01:26:27 <thelsdj> i wish robot chicken was longer, 15 minutes a week is just not enough
02:43:07 <Lemmih> musasabi: ping.
02:46:28 <damg> is it possible to define types of parameters while defining a data type?
02:46:48 <damg> data Foo p1 p2 = Foo p1 p2
02:46:56 <damg> and e.g. p1 should be only [Char]
02:47:38 <amiddelk> damg: why do you want it to be a parameter then, if the type is already fixed?
02:48:48 <damg> amiddelk, how is it already fixed?
02:49:10 <amiddelk> well, you say that p1 should only be [Char], so why not get rid of the parameter and use [Char] instead?
02:49:10 <damg> i could supply to p1 an Int or a [], it would accept both
02:49:36 <damg> amiddelk, ah, didnt think of that ;) thanks :P
02:52:07 <joelk> @pl f (x:y:xys) = (x,y) : f xys
02:52:08 <lambdabot> f = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip (flip . (((.) . (:)) .) . (,)))
02:52:13 <joelk> whoa!
02:53:01 <int-e> @type flip flip
02:53:02 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
02:53:09 <shapr> hey joelk
02:53:14 <joelk> hiya
02:53:38 <shapr> I'm doing a Joel and learning Flash in a week.
02:54:20 <joelk> um... I'm assuming there's a regex coming...
02:54:36 <shapr> ?
02:54:51 <joelk> doing what with a Joel?
02:55:23 <shapr> There was this guy named Joel who learned Haskell and did a production app in a very short amount of time. You're that joel, yeah?
02:55:49 <Cale> no, that was joelr, I think
02:55:53 <joelk> no, that's joelr
02:55:54 <shapr> oh, sorry :-/
02:55:58 * shapr sighs
02:56:12 <joelk> joelr1 I believe is his IRC nick
02:56:18 <shapr> Yeah, I think so.
02:57:54 <joelk> I, on the other hand, learned Haskell and did a bunch of tiny apps over a very long period :-)
02:59:40 <shapr> That's cool too :-)
03:01:31 <araujo> Good morning!
03:04:37 <joelk> never seen this before:
03:04:40 <joelk> a.out: internal error: evacuate: strange closure type 256
03:04:59 <shapr> Trying deleting all of your .hi files and rebuilding.
03:05:04 <joelk> ok
03:05:26 <sieni> strange closure type <3
03:05:36 <shapr> That still looks like testicles to me.
03:06:20 <joelk> same thing
03:06:44 <shapr> Sounds like a bug, using ghc 6.4.2 ?
03:07:05 <joelk> 6.4.1
03:07:06 <Cale> It still looks like "less than three" to me.
03:07:28 <joelk> I thought it was a broken heart for a long time...
03:07:41 <Cale> did you also delete your .o files?
03:07:47 <joelk> tried that too
03:08:21 <Cale> If clearing temporaries doesn't help, yeah, it's likely a bug.
03:11:41 <bolrod> :]
03:12:06 <int-e> ‚ù£‚ô°‚ô•‚ù§‚ù•‚ù£
03:13:04 <bolrod> √∑¬ø¬ø¬ø
03:13:37 <joelk> found my problem. People like me shouldn't be allowed near unsafeWrite.
03:13:47 <Cale> int-e: yeah, exactly, no need for this inequality nonsense when one has UTF-8 at one's disposal :)
03:14:32 <int-e> I find gucharmap a tad hard to use though.
03:15:06 <Cale> for common things, I find that hooking up a compose key in X helps a lot
03:15:48 <nealar> where can I find history of changes from GHC 6.2 to GHC 6.4?
03:16:05 <Cale> plus, configuring a key to swap to greek layout and back is handy :)
03:16:14 <Cale> Œ±Œ≤Œ≥Œ¥Œµ :)
03:21:45 <neologism> nealar: its on the web
03:22:11 <nealar> neologism: where? what search key for goole would help?
03:22:17 <nealar> google
03:24:11 <neologism> www.haskell.org/ghc/dist/6.4/html/users_guide/release-6.4.html
03:29:54 <nealar> neologism: 404
03:31:35 <nealar> http://www.haskell.org/ghc/dist/stable/docs/users_guide/release-6-4.html
03:31:42 <nealar> ¸ÙÌËÛ Â¯˚ ¯˚ ˆÙÂ ÿ ˆÙÚÂ
03:31:49 <nealar> maybe this is what I want
03:41:23 <nealar> OMG! it can report start and end columns of an error
03:47:53 * shapr yodels cheerfully
03:50:09 <davidhouse> google speaks tomorrow, right?
03:50:21 <davidhouse> announcing the accepted SoC projects, i mean.
03:51:31 <dons> yep.
03:51:37 <dons> sometime after 5pm PDT
03:53:14 <davidhouse> @google define: PDT
03:53:15 <lambdabot> No Result Found.
03:53:28 <davidhouse> UTC -7, according to Wikipedia.
03:54:02 <dons> someone should modify the Search.hs plugin to implement google's time feature.
03:54:05 <davidhouse> great, that means people in GMT won't actually get it until wednesday.
03:54:16 <dons> and, well, people in GMT+10, hmm...
03:54:32 * dons looks back on the world from the future. its nice here.
03:54:40 * shapr grins
03:55:06 <davidhouse> heh.
03:55:10 <dons> everything is 10x smaller, and 1000x times more fun.
03:55:33 <dons> except the compiler, its 10x bigger and 100x slower
03:56:07 <davidhouse> what would be the adverb associated with "type"?
03:56:16 <shapr> huh?
03:56:26 <davidhouse> i'd think "typically", but that could get confusing. e.g. "lists are typically homogenous"
03:56:29 <shapr> He did it typely?
03:56:35 <dons> huh, instance Arbitrary Dynamic. that's cool
03:56:55 <dons> ?wiki QuickCheck_/_GADT
03:56:55 <lambdabot> http://www.haskell.org/haskellwiki/QuickCheck_/_GADT
03:57:53 <dons> oh cool, he maps numbers to types, to generate arbitrary types. 
03:58:45 <davidhouse> "compressChar x = take 7 (g ((ord x)))" -- why so many brackets?
03:59:15 <neologism> lisp habit?
03:59:39 <davidhouse> even for lisp that'd be excessive.
03:59:55 <davidhouse> take 7 (g $ ord x) is how i'd render that.
04:00:26 <nealar> > take 7 (g $ ord x)
04:00:27 <lambdabot>  Not in scope: `x'
04:10:15 <lumi> Adverb for types: typewise?
04:25:39 <ADEpt> is it possible to speed this up? http://rafb.net/paste/results/IEsbQZ69.html
04:28:45 <Lemmih> ADEpt: Compile with -threaded?
04:31:47 <ADEpt> @karma Lemmih++ -- for -threaded advice
04:31:48 <lambdabot> Lemmih++ has a karma of 0
04:31:53 <ADEpt> :)
04:32:04 <ADEpt> @karma+ Lemmih -- for -threaded advice
04:32:04 <lambdabot> Lemmih's karma raised to 18.
04:35:04 <ADEpt> Lemmih: 30 seconds, 100k threads, 250 mb VSS memory consumed
04:37:39 * vincenz whistles
04:38:26 <vincenz> > 250*1025*1025/100000
04:38:27 <lambdabot> 2626.5625
04:38:32 <vincenz> > 250*1024*1024/100000
04:38:32 <lambdabot> 2621.44
04:39:00 <ADEpt> yep
04:39:10 <ADEpt> quite decent, i'd say
04:39:51 <vincenz> posix?
04:41:18 <ADEpt> ?
04:43:07 <vincenz> they are posix threads?
04:44:20 <dons> i suppose they're ghc rts threads
04:44:23 <eivuokko> Probably ghc threads.
04:44:40 <vincenz> then 2k seems like quite a bit, no?
04:44:51 <vincenz> I mean those threads hardly contain data
04:45:23 <dons> joelr had up to 5k , iirc.
04:45:28 <eivuokko> It needs 1k+ for stack and per-thread storage.
04:45:33 <dons> not sure about the language shootout, they may go higher.
04:45:37 <dons> ?shootout
04:45:38 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
04:45:46 <eivuokko> ghc rts can't really live with thread stackspace less than 1k, I'd say
04:45:53 <eivuokko> (haskell stack)
04:46:06 <vincenz> how's that?
04:46:20 <dons> oh, maybe i came in half way. i assume you mean the number of threads.
04:46:21 <eivuokko> Well, that's just how much entries there is in stack often.
04:46:25 <dons> not the space they use.
04:46:52 <davidhouse> dons, how long until we're at the top of that table? :)
04:46:53 <vincenz> eivuokko: yes but if you look at the think Adept posted, ther was hardly any data there
04:46:56 <davidhouse> or perhaps just below C
04:47:08 <dons> davidhouse: well, we where earlier this year.
04:47:12 <dons> let me find the snapshot.
04:47:30 <eivuokko> vincenz, Yes, but if I was starting threads, I'd guess the default stacksize is atleast 1k.
04:47:32 <dons> here http://www.cse.unsw.edu.au/~dons/haskell_1.html
04:48:02 <dons> on Feb  2
04:48:02 <davidhouse> haha, nice.
04:48:16 <vincenz> hmm
04:48:17 <vincenz> alright
04:48:28 <davidhouse> still. we're quite a long way behind, say, D.
04:48:29 <dons> we may regain it once 6.6 comes out, and we use Data.ByteString for a number of overly verbose tests
04:48:48 <vincenz> ocaml is kicking our ass on k-nucleotide and regex-dna
04:49:02 <dons> nah, it actually not too  hard to pick up a lot of points for the very verbose knuc and regex tests.
04:49:12 <dons> they've got well known issues, that are fixed in 6.6
04:49:17 <dons> (i.e. no Data.ByteString)
04:49:20 <vincenz> \o/
04:49:22 <davidhouse> great :)
04:49:26 <davidhouse> when's 6.6 out then?
04:49:35 <dons> a few months, i suspect
04:49:39 <vincenz> heh... chamenoes...ghc 107 times faster than haskell
04:51:37 <vincenz> erm
04:51:37 <aleator> Hi. Any c2hs people around?  "c2hs: Error in C header file." (/usr/include/string.h:270).
04:51:37 <vincenz> ocaml
04:51:47 <dons> i've noticed in blogs and chatter that in the last few months people have come to start to assume haskell's fast. 
04:52:11 <dons> i saw a blog a couple of days ago where a guy said "i don't know what haskell's got that lisp doesn't, except its much faster"
04:52:18 <vincenz> lol
04:52:21 <vincenz> static typing
04:52:26 <Saulzar> That's great.
04:52:27 <dons> yeah, the answers are obivous.
04:52:34 <dons> but its great that that's the buzz around haskell now
04:52:42 <pejo> dons, fast compared to what btw?
04:53:17 <dons> so, interesting to see what the attitude of the uninformed towards haskell is.
04:53:17 <vincenz> pejo: anyOf ([minbound..maxbound] :: [DynamicLanguage])
04:53:33 <dons> pejo: well, anything, i think.
04:53:38 <eivuokko> pejo, fast as a general purpose language.
04:53:48 <vincenz> and that's not including java
04:53:55 <dons> that you can get C-ish speed if needed.
04:54:17 <vincenz> dons: if now we can get c-ish syntax, people will flock like mad :P
04:54:37 <dons> peek/poke for all! death to layout!
04:54:43 <eivuokko> And that's not, sort of sadly, counting the beautiful ffi system.
04:55:03 <vincenz> why do all haskell compilers by default include a mangler
04:55:10 <dons> they do?
04:55:16 <dons> i think its only ghc, isn't it?
04:55:16 <vincenz> I saw that even jhc, which I thought was a smaller project, has a mangler
04:55:22 <eivuokko> What mangler?
04:55:24 <dons> since it needs to rewrite gcc's asm output to be faster
04:55:34 <vincenz> name mangler
04:55:39 <dons> a (evil) perl script that rewrites gcc's output, to be faster. :)
04:55:41 <Lemmih> Ah.
04:55:56 <vincenz> dons: O.O
04:56:18 <dons> all could be superseded by C-- compilers. that's the ideal, anyway
04:56:24 <shapr> I can barely wait.
04:56:25 <vincenz> how's that
04:56:30 <shapr> C-- kicks butt.
04:56:33 <dons> since then we could generate the right code in the first place,
04:56:33 <vincenz> why?
04:56:42 <pejo> dons, we're lazily waiting for them. :-)
04:56:48 <Lemmih> dons: He's not talking about he EvilMangler.
04:56:59 <vincenz> why does C-- do better?
04:57:05 <dons> no, i don't know about this jhc mangler. any info?
04:57:11 <vincenz> lemme find it
04:57:12 <Lokadin> say how do i understand: ( hPutStrLn o . render . document . parse) content
04:57:18 <Lokadin> as in what goes in what order?
04:57:25 <vincenz> right to left
04:57:28 <dons> vincenz: more control over low level constructs.
04:57:33 <eivuokko> vincenz, ghc uses a perl script to take out asm generated by gcc.  IT uses that asm and puts in stuff that allows it to do jumps instead of calls and rets. C-- has native support for that.
04:57:34 <Lokadin> vincenz: kk thanks
04:57:39 <nealar> @type (.)
04:57:40 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
04:57:40 <dons> no assumption of C calls, C stacks, C data layout
04:57:42 <pejo> vincenz, the design papers of C-- are quite a good read actually. They skipped varargs, since it's a mess, for example.
04:57:49 <vincenz> neat
04:57:56 <Lemmih> vincenz: Aren't you talking about the name mangler?
04:58:00 <vincenz> Lemmih: yes
04:58:04 <vincenz> I am
04:58:13 <vincenz> grr, negating questions are ambiguous to answer
04:58:14 <Lemmih> Then forget what they said about C--.
04:58:17 <dons> ah, not _the_ mangler ;)
04:58:25 <vincenz> Lemmih: I know, but that was out of interest
04:59:09 <vincenz> dons: I saw it somewhere in the code, don't think I'll find the file again easily
04:59:31 <eivuokko> jhc generates C, so the function etc names must be C-compatible.
04:59:33 <Lemmih> vincenz: Prelude.++ isn't a valid function name in, say, C.
04:59:36 <vincenz> case x of ... "." -> "__a"
04:59:51 <vincenz> ah yep
04:59:52 <vincenz> thx
04:59:59 <vincenz> ok
05:00:06 * vincenz is off to the bank to dump his money
05:00:12 <eivuokko> Same for ghc.  Additionally linkers probably don't like funny non-C symbols.  Not all of them atleast.
05:00:37 <vincenz> @karma+ lemmih -- For reminding me of something of ovbious
05:00:37 <lambdabot> lemmih's karma raised to 1.
05:00:46 <vincenz> @karma+ Lemmih -- For reminding me of something of ovbious
05:00:46 <lambdabot> Lemmih's karma raised to 19.
05:00:49 <Lemmih> Yay. My first karma point!
05:00:56 <vincenz> karma should be case invariant
05:02:30 <pejo> vincenz, if you need somewhere else to dump your money I'm here for you man.
05:03:05 <shapr> Yeah, and karma should have some way to link foo_ to foo like with sjanssen_
05:03:23 <shapr> Of course, then I'd start linking swearwords to Java, so maybe not...
05:04:18 <aleator> This is sad. So much computing power, but can't use it since c2hs doesn't eat /usr/include/string.h..
05:05:07 <shapr> On the good side, c2hs is about to get a facelift.
05:06:23 <aleator> How so?
05:08:35 <shapr> One of the SoC projects is Language.C
05:14:04 <aleator> Is there anyone besides Chakravarty who knows c2hs?
05:15:06 <dons> i know a litte. dcoutts knows a fair bit. he rewrote the c2hs parser
05:18:10 <aleator> Is there a chance that darcs version would work where 0.14.5 fails?
05:20:53 <dons> possibly.
05:21:11 <Igloo> Is there a list of accepted projects now, then?
05:21:14 <dons> it fails on string.h ? wouldn't it have to chew string.h fairly regularly?
05:21:28 <dons> Igloo: nope, not yet. polls close in 11hrs
05:21:34 <dons> and google announces sometime after that
05:21:39 <dons> the deadline got shifted back
05:22:40 <aleator> dons: Yea. Thats whats curious. I'm moving my project to largish x86_64 and the problem appears there.
05:23:09 <dons> aleator: very interesting. perhaps ask dcoutts. he knows both the x86_64 and c2hs
05:24:25 <aleator> dons: Thank you. I guess I'll try to lurk here until he appears.. Or something.
05:25:01 <dons> well, you could mail Manuel. he actually hangs out here sometimes.
05:25:03 <dons> @seen ChilliX
05:25:04 <lambdabot> ChilliX is in #haskell. I don't know when ChilliX last spoke.
05:25:11 <dons> that's him.
05:25:41 * dons gets some sleep
05:40:58 <shapr> hi RvGaTe 
05:41:06 <RvGaTe> ello
05:48:07 * vincenz cheers as his savings account now got boosted to a nice round number
05:50:21 <mux> mmm, when I compile some code with -prof -auto-all, GHC suddenly says it can't find Sytem.Random, while the program builds fine otherwise
05:50:24 <mux> any ideas ?
05:50:46 <Saulzar> You need the profiling libs
05:51:21 <mux> my GHC should be built with suppport for profiling
05:51:23 <Saulzar> Depending on what you're using they might be a separate package 
05:55:42 <mux> Saulzar: is there a way to list the available profiling libs?
05:56:19 <Saulzar> mux, I'm not sure - but I guess you're missing all the base libraries if System.Random is missing
05:57:54 <mux> Saulzar: mmm. System.Random is found just fine without -prof
05:58:04 <eivuokko> mux, You can search for .hi files, the profiling libs should be something like .p_hi, I think
05:58:10 <Saulzar> mux, Right - there are separate versions of all libraries for profiling
05:58:18 <mux> ok, so it(s .p_hi
05:58:20 <mux> thanks
05:58:37 <mux> I don't seem to have any of these though GHC is built with profiling support
05:58:45 <eivuokko> mux, But it sure sounds like you don't have profiling lib built
05:58:58 <mux> given the GHC port has the option PROFILE to on
05:59:05 <mux> I'll see if something is broken in that port
05:59:20 <eivuokko> mux, Not sure what you mean with profiling support.  Maybe the build didn't have profiling for libs enabled.  Something called LibWays in ghc makesystem.
05:59:43 <mux> eivuokko: the GHC port under FreeBSD has a PROFILE build option
05:59:55 <mux> so it sounds likely this should get GHC built with all the profiling libs
06:00:01 <eivuokko> (The profiling and threading etc are called "ways", there are rts and library ways, and they also apply testing etc, I think)
06:00:04 <mux> it's possibly broken
06:00:37 <eivuokko> mux, Well, yeha.  It does sound like that.  But otoh, building profiling libs pretty much doubles the library build time, which can take many many more minutes or hours.
06:00:51 <mux> yeah, I'm aware of this
06:01:28 <vincenz> are class aliases going to be in haskell'?
06:01:31 <eivuokko> Unfortunately it is hard, maybe impossible to build some of the base libs separately afterwards.
06:04:03 <mux> hah, found the problem.
06:04:46 <eivuokko> What's that?
06:05:27 <mux> there was a conflict between the port's make option and a formerly system-wide make option used for building the base system
06:05:39 <nealar> is it possible to build GHC-6.4 under FreeBSD 4.11?
06:05:43 <mux> so my port was really built without the PROFILE option
06:05:47 <mux> nealar: most likely yes
06:06:07 <eivuokko> mux, Oh, what an annoyance.
06:06:24 * mux nods
06:06:52 <nealar> mux: it seems I must somehow hack $PERL_LEVEL make variable and something else
06:07:13 <nealar> Either I don't understand port system or it is deeply flawed
06:07:16 <mux> nealar: dunno; show me the error message/problem you're having
06:07:24 <mux> it's not deeply flawed :-)
06:07:39 <nealar> it says it needs new perl
06:07:49 <nealar> after installation of perl5.8
06:07:49 <mux> can you _show_ it to me?
06:07:56 <nealar> it continues saying it
06:08:08 <mux> well
06:08:17 <mux> FreeBSD 4.x has perl in the base system
06:08:18 <nealar> mux: 2 hours later, when I get home
06:08:34 <mux> so it's probably still trying to use the (old) version in the base system
06:08:42 <mux> rather than what you have installed through ports in /usr/local
06:09:51 <nealar> mux: how $PERL_LEVEL is discovered? I've found (athough maybe I was wrong) that is it hardwired to $OS_VERSION in bsd.ports.mk
06:09:54 <mux> you need to use.perl port
06:10:06 <nealar> ah
06:10:08 <nealar> thanks!
06:10:09 <mux> and that's probably all to it
06:10:13 <nealar> @karma+ mux
06:10:14 <lambdabot> mux's karma raised to 1.
06:10:15 <mux> you're welcome
06:10:37 <mux> oh yay, now I won't reincarnate as a rock :-)
06:10:48 <vincenz> can someone explain me the issue with --:
06:11:05 <davidhouse> mux, heh :)
06:11:18 <davidhouse> vincenz: comments?
06:11:24 <eivuokko> That's a valid operator token.  It looks almost a comment as well.
06:11:33 <vincenz> http://hackage.haskell.org/trac/haskell-prime/wiki/LineCommentSyntax
06:11:44 <vincenz> eivuokko: how's that?
06:11:48 <vincenz> eivuokko: what's a comment then?
06:11:55 <eivuokko> -- with space after it
06:12:01 <davidhouse> vincenz: "This unfortunately forces sequences beginning '--:' to be comments, which appears to be unintentional."
06:12:04 <davidhouse> that clear things up?
06:12:08 <eivuokko> Err, actually any other letter than allowed operators
06:12:09 <vincenz> does any<symbol> mean anything excluding symbol?
06:12:26 <vincenz> I don't get the syntax on that page
06:12:38 <davidhouse> check out the report then
06:12:41 <eivuokko> Me neither.  Prolly easier to check report
06:12:43 <vincenz> a shame that -- on it's own won't be allowed
06:12:47 <vincenz> x --
06:12:48 <vincenz> y --
06:13:10 <davidhouse> decr x; decr y ;)
06:13:12 * vincenz considers ---
06:13:27 <davidhouse> you can't have unary operators anyway.
06:13:35 <vincenz> sure you can
06:13:39 <vincenz> ++x
06:13:42 <Saulzar> Super arrow operator -->>-->>
06:13:51 * vincenz grins at Saulzar 
06:14:05 <davidhouse> and besides, what would be the purpose of decrementing nonmutable variables?
06:14:06 <vincenz> to bad with the proposed syntax we can't have the pipe operator --u
06:14:11 <vincenz> or emptyPipe --n
06:14:13 <davidhouse> vincenz: right, how do you define ++?
06:14:18 <davidhouse> as in ++x
06:14:23 <eivuokko> vincenz, Not in haskell.  Only unary operator is - and it has pretty special handling in report.
06:14:23 <nealar> spear operator >--------->>
06:14:43 <vincenz> but if you look at streams
06:14:46 <vincenz> --u fill pipe
06:14:46 <int-e> looks like brainf*ck code
06:14:49 <vincenz> --n empty pipe
06:14:50 <vincenz> are useful
06:15:17 <vincenz> :P
06:15:24 <davidhouse> you still haven't told us how to define a unary operator
06:15:40 <vincenz> davidhouse: of course not, eivuokko said it's impossible
06:15:52 <davidhouse> "<vincenz> sure you can" ;)
06:16:03 <int-e> > let (+) = succ in (+) 2
06:16:04 <lambdabot> 3
06:16:32 <vincenz> davidhouse: you like boring people into the ground, duntcha
06:16:45 <davidhouse> int-e, now use that infix ;)
06:17:21 <int-e> davidhouse: (2+) looks like it could work, but it doesn't.
06:17:45 <int-e> davidhouse: besides, what's an unary infix operator?
06:17:48 <vincenz> > let (+) = succ in +2
06:17:48 <lambdabot>  parse error on input `+'
06:17:51 <vincenz> > let (+) = succ in 2+
06:17:51 <lambdabot>  parse error on input `}'
06:17:52 <davidhouse> i guess (2+) is hard-wired into meaning (+) 2
06:18:00 <int-e> davidhouse: it's not
06:18:08 <int-e> > let (+) = succ in (2+)
06:18:09 <lambdabot>  add an instance declaration for (Num (t -> t1))
06:18:23 <int-e> davidhouse: it means \x -> (+) 2 x ...
06:18:26 <davidhouse> ah.
06:19:18 * mux moves from IO to StateT Int IO so as to compute the length of a list when building it rathen than using length, and has worse perfs :-)
06:19:51 * vincenz snickers
06:21:17 * vincenz ponders
06:21:36 <vincenz> given how we have type inference and thus needs kinds, and now they want kind inferences, will have something like "species"?
06:22:04 <nealar> =)
06:22:24 <nealar> vincenz: where did ypu find kind inference?
06:22:42 <vincenz> haskell'
06:23:05 <davidhouse> we have kind inference.
06:23:12 <davidhouse> how do you think kind errors work?
06:23:35 <mux> oh fear. I went to see who's the maintainer of the GHC port for FreeBSD and it's simonmar@microsoft.com
06:23:36 <nealar> I do not understand kinds at all :(
06:24:28 <vincenz> davidhouse: it's not inference
06:24:37 <nealar> well, there should be M$ BSD somewhere ;)
06:24:38 <davidhouse> nealer, do you grok the term "type constructor"? how about "data constructor"?
06:25:01 <nealar> davidhouse: what's difficult about them?
06:25:30 <davidhouse> nealer, well, if you understand the term "type constructor" then you've pretty much got kinds.
06:25:42 <eivuokko> vincenz, Yeah there is, http://haskell.org/onlinereport/decls.html#kindinference
06:26:05 <davidhouse> vincenz: what is it then?
06:26:10 <vincenz> well
06:26:15 <vincenz> type X a b c
06:26:22 <vincenz> => X : (* -> * -> *)
06:26:31 <davidhouse> right. the kind of X is inferred.
06:26:32 <eivuokko> haskell' maybe adds explicit kinds, which means there would be signature-like syntax to specify kinds
06:26:37 <nealar> deavidhouse: nope. I think kinds are somewhat like "types of types", but not for sure
06:26:54 <vincenz> davidhouse: I hardly call that inference, but maybe I'm throwing the terms "inference" and "unification" through each other
06:27:02 <eivuokko> vincenz, You can't do it so simply in class/instance headers
06:27:05 <vincenz> eivuokko: they also add kind eference
06:27:17 <vincenz> or at least more of it
06:27:27 <davidhouse> nealer, okay. think about Maybe. that's a type constructor. you can't have a function that returns a Maybe, though, you need a Maybe Int or a Maybe String or something.
06:27:29 <vincenz> http://hackage.haskell.org/trac/haskell-prime/wiki/KindInference
06:27:50 <davidhouse> you give Maybe a type, and it gives you a new type. i.e. Int -> Maybe Int.
06:28:47 <davidhouse> In that way, Maybe, a type constructor, has a sort of "type". we call this "type of type constructors" a kind.
06:28:50 <davidhouse> @kind Maybe
06:28:51 <lambdabot> * -> *
06:29:27 <nealar> @kind Int
06:29:28 <lambdabot> *
06:29:29 <davidhouse> the * represents the "nullary type", i.e. a type constructor with no parameters (like Int)
06:29:32 * vincenz still takes dibs on "species" if they ever need something above kind
06:29:52 <nealar> @kind Array
06:29:54 <lambdabot> * -> * -> *
06:30:12 <davidhouse> at a kind of basic level, you just take the number of parameters a type constructor has, have that many *s, then put -> in between those stars.
06:30:19 <davidhouse> @kind RWST
06:30:20 <lambdabot> Not in scope: type constructor or class `RWST'
06:30:25 <davidhouse> @kind RSWT
06:30:26 <lambdabot> Not in scope: type constructor or class `RSWT'
06:30:35 <eivuokko> vincenz, Is that issue about adding more basic kinds than * or what?
06:31:16 <vincenz> no
06:31:22 <vincenz> just allowing more than now
06:31:26 <nealar> davidhouse: do kinds meqan more than number of type constructor parameters?
06:31:27 <vincenz> at least witout kind annots
06:31:37 <eivuokko> vincenz, Yes..that's said in plain english on the page
06:31:40 <davidhouse> nealer, not really.
06:31:49 <davidhouse> @kind Control.Monad.RWS.RWST
06:31:50 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
06:31:50 <vincenz> eivuokko: then I Don't get your question
06:31:53 <davidhouse> hehe
06:32:33 <nealar> @hoogle Control.Monad.RWS.RWST
06:32:34 <lambdabot> No matches found
06:32:37 <davidhouse> nealer, they are useful, though. for example, all Monads (and indeed, all Functors) must have kind * -> *. that is, they must take one type parameter.
06:33:04 <vincenz> @type Control.Monad.StateT
06:33:05 <lambdabot> Not in scope: data constructor `Control.Monad.StateT'
06:33:11 <vincenz> @type Control.Monad.StateStateT
06:33:12 <lambdabot> Not in scope: data constructor `Control.Monad.StateStateT'
06:33:13 <vincenz> @type Control.Monad.State.StateT
06:33:14 <lambdabot> forall a (m :: * -> *) s.
06:33:14 <lambdabot>           (s -> m (a, s)) -> StateT s m a
06:33:19 <vincenz> @kind Control.Monad.State.StateT
06:33:20 <lambdabot> * -> (* -> *) -> * -> *
06:33:47 <davidhouse> vincenz: that's because StateT is the data constructor as well
06:33:53 <vincenz> yup
06:33:58 <vincenz> I know that
06:34:01 * vincenz pokes davidhouse 
06:34:11 <int-e> @kind (->)
06:34:12 <lambdabot> ?? -> ? -> *
06:34:29 <davidhouse> RWST is the monad transformer for the RWS monad, a combination of Reader, Writer and State. so it takes a type for the Reader environment, a type for the Writer log output, a type for the State state and the inner monad (which has kind * -> *).
06:34:40 <davidhouse> now, the kind of (->) i don't understand.
06:34:50 <davidhouse> why it's not * -> * -> * i don't know.
06:34:58 <vincenz> lambdabot likes joking
06:35:18 <int-e> because ghc has separate kinds for types that may be unboxed.
06:35:23 <nealar> thanks
06:35:31 <davidhouse> ah, that's it, is it?
06:35:33 <davidhouse> @kind Int
06:35:34 <lambdabot> *
06:35:36 <davidhouse> @kind Int#
06:35:37 <lambdabot> Not in scope: type constructor or class `Int#'
06:35:42 <davidhouse> @hoogle Int#
06:35:43 <lambdabot> No matches found
06:35:43 <nealar> not sure I fully understand that, but at least I have no more questions
06:38:23 <int-e> davidhouse: see http://darcs.haskell.org/ghc/compiler/types/Kind.lhs
06:38:53 <eivuokko> I don't get it, what would be the kind of Tree a on that page if there is no addition of basic kinds besides *?  Or is the extension just that kind inference is done over whole module (which only fixes some of the problems) instead of dependency group?  (that page= http://hackage.haskell.org/trac/haskell-prime/wiki/KindInference )
06:40:55 <int-e> eivuokko: you'd just have * then
06:41:39 <nealar> >Haskell 98 lacks kind polymorphism
06:41:46 <nealar> ˆÌ ˚˘„‰‚ ¯Â ÙÏÛ,
06:41:51 <nealar> why should it have?
06:42:16 <davidhouse> @kind GHC.Prim.Int#
06:42:17 <lambdabot> #
06:42:30 <davidhouse> int-e, i see.
06:42:34 <eivuokko> int-e, Eh?  Where would the extension be?  I must be understanding soemthing really wrong way here.
06:43:33 <davidhouse> so ?? is a kind except an unboxed tuple.
06:43:33 <eivuokko> int-e, or does it mean just adding "kind-variables"?
06:45:32 <int-e> > lift 0 0
06:45:33 <lambdabot> Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
06:45:45 <xerox> haha.
06:45:59 <davidhouse> @type lift
06:46:00 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
06:46:00 <lambdabot>    (MonadTrans t, Monad m) =>
06:46:00 <lambdabot>    m a -> t m a
06:46:13 <int-e> eivuokko: ignore me. I misread something in your question.
06:46:50 <eivuokko> int-e, Ok :-(  Thanks.
06:47:20 <eivuokko> Ah, anyway, I've not run in kind problems, so I can happily go not caring :)
07:15:48 <tuxplorer> @seen kzm
07:15:49 <lambdabot> kzm is in #haskell-overflow and #haskell. I last heard kzm speak 5 hours, 56 minutes and 1 second ago.
07:25:12 <vincenz> DAMN
07:25:17 <vincenz> 360MB of tracing output
07:28:53 <boegel> vincenz: I have 15G of program characteristics for 26 SPEC benchmarks, so quit whining :p
07:29:33 <vincenz> :)
07:30:07 <vincenz> well this is not including the most prolific profiling
07:33:13 <davidhouse> when using a boilerplate license, what do people use instead of the organisation name if they've developed a piece of software individually?
07:39:59 <joe_k> the individual's name?
07:41:20 <davidhouse> sometimes that sounds very weird though.
07:41:34 <davidhouse> BSD license: "* Neither the name of "David House" nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission
07:42:17 <nealar> =)
07:42:31 <vincenz> I just use a fictive name
07:42:34 <vincenz> AbstractOasis
07:42:47 <mux> davidhouse: we don't use this clause anymore :)
07:43:04 <mux> and it's supposed to be the name of the software
07:43:06 <davidhouse> mux, who's "we"? and what have you done, just deleted it?
07:43:06 <mux> not your name
07:43:13 <eivuokko> mux, It's supposed to be organisation
07:43:21 <eivuokko> mux, like where you work, study etc
07:43:24 <davidhouse> wikipedia and opensource.org both list it as the name of the organisation
07:43:26 <mux> we == FreeBSD at least, and probably other projeects
07:43:31 <mux> we use 2-clause BSD license
07:43:38 <davidhouse> alright, it's gone.
07:43:43 <mux> mmm, I'm probably wrong on that point then
07:44:00 <mux> never been fond of licenses and legal stuff :)
07:44:16 <vincenz> it's sad we live in a world that require them
08:22:05 <mux> ah, yay, now  I can build profiling code
08:56:02 <alar> mux: there is still something wrong
08:56:16 <alar> cadabra# cd /usr/ports/lang/ghc
08:56:16 <alar> cadabra# make
08:56:16 <alar> ===>  ghc-6.4.2_1 requires newer version of perl.
08:56:35 <alar> cadabra# perl --version
08:56:35 <alar> This is perl, v5.8.5 built for i386-freebsd-64int
08:57:54 <wilx> which perl
08:58:06 <alar> ?
08:58:26 <mauke> "type -a perl" if bash
08:59:05 <alar> bash2-2.05b$ type -a perl
08:59:05 <alar> perl is /bin/perl
08:59:05 <alar> perl is /usr/bin/perl
08:59:05 <alar> perl is /usr/local/bin/perl
08:59:05 <alar> b
09:00:55 <wilx> Hmm, I don't remember ever having /bin/perl
09:01:11 <alar> I made it manually
09:01:30 <mauke> are all the same version of perl?
09:01:34 <alar> for perl-5.8.5 to be in search path before old version
09:01:38 <alar> no
09:01:50 <alar> /usr/bin/perl is old version
09:01:55 <wilx> Well, maybe it needs even newer version of perl :)
09:02:02 <alar> /usr/local/bin/perl is 5.8.5
09:02:19 <wilx> Mine is 5.8.8.
09:02:36 * Lemmih thought GHC shipped with perl.
09:03:05 <wilx> Well, this perl dependence is strange.
09:03:14 <wilx> Even stranger seems to me the way it is being used.
09:03:19 <eivuokko> Only in Windows/mingw?
09:03:22 <wilx> Editing .s files, black magic.
09:03:38 <lispy> perl is ment for black magic :)
09:03:41 <alar> .if ${PERL_LEVEL} < 500600
09:03:41 <alar> IGNORE=         requires newer version of perl
09:03:41 <alar> .endif
09:03:44 <wilx> Maybe somebody should rewrite the Perl scripts into Haskell.
09:03:47 <eivuokko> It removes function prologue and epilogue and provides it's own.  So it can use jumps instead of calls/rets
09:03:56 <alar> this is from Makefile
09:04:09 <alar> does it mean perl-5.6 or higher?
09:04:19 <wilx> Sounds like good SoC project for somebody.
09:04:32 <eivuokko> Hmh
09:04:50 <eivuokko> Well, just someone needs to convince GHC HQ and code it up with Text.Regex, I think.
09:05:15 <eivuokko> It would probably speed up ghc a bit, atleast in Windows.
09:06:02 <sjanssen1> how bad are the Perl scripts?
09:06:07 <eivuokko> Wait, it isn't that simple probably....ghc uses internally packed strings?  So Text.Regex won't work directly, hmh.
09:06:20 <eivuokko> Not bad, mainly regexps style s/foo//
09:06:26 <eivuokko> (iirc)
09:06:44 <eivuokko> They just depend on gcc version and platform and stuff like that, so there's plenty
09:06:46 <sjanssen1> eivuokko: I think JRegex works with packed strings, and that's slated for inclusion in GHC
09:06:57 <wilx> sjanssen, look for ghc-split
09:07:04 <wilx> And ghc-asm.
09:07:35 <wilx> Lots and lots of regexps.
09:07:36 * vincenz KICKS c++
09:07:45 <eivuokko> sjanssen1, What's "inclusion in GHC"?  Afaict, there is a plan to drop libraries from automatic builds/distros of ghc and use them via cabal.
09:07:58 <eivuokko> *provide them
09:08:51 <alar> eivuokko: won't it break portability? Hugs is not packed with Cabal iirc
09:09:30 <eivuokko> alar, Huh?  If cabal works with ghc, and packages work with cabal+ghc, how could it break portability?
09:09:33 <sjanssen1> eivuokko: I was just going off a ML post from Simon Marlow.  After re-reading, it seems more like a notion of a plan rather than a definite one
09:10:39 <eivuokko> alar, Anyway, cabal should be fixed so that it's easy to install into existing hugs isntallation.  There apparently isn't many people caring about cabal on hugs.
09:10:50 <alar> eivuokko: if GHC gets libraries through Cabal and Hugs does it the other way, won't it result in slightly different libraries for them?
09:11:22 <alar> yes, if there will be cabal on hugs, my concerns do not matter
09:11:26 <eivuokko> alar, Default libraries, sure.  So ghc users need to get package some other way, is that huge thing?
09:11:38 <sjanssen1> eivuokko: also briefly hinted in this ticket: http://hackage.haskell.org/trac/ghc/ticket/710
09:12:20 <sjanssen1> alar: you can use Cabal to install packages for Hugs, isn't that enough?
09:12:48 <alar> sjanssen: can I?
09:13:17 <sjanssen1> alar: yeah.  Maybe there are more bugs than in GHC, but the support is there
09:13:53 <eivuokko> Well, I couldn't get cabal install into hugs last I tried (in Windows).  (Altho not with most current hugs)
09:13:55 <alar> sjanssen: I didn't know that
09:14:29 <alar> eivuokko: afaik the most current version doesn't have winhugs yet
09:15:04 <sjanssen1> eivuokko: trying to install with Hugs in Windows sounds nasty -- both platforms that don't receive much Haskell love
09:15:40 <eivuokko> sjanssen, Yeah, I use ghc in Windows myself, and that's enough pain usually.
09:15:59 <eivuokko> Getting better now.  Only should get daily ghc builds going in Windows, tho.
09:16:54 <wilx> Heh, I gues you have really strong box. It takes several hours to build GHC on this, in Windows.
09:17:04 <eivuokko> alar, Actually, I'd like to be able to build hugs myself in Windows.
09:17:26 <eivuokko> wilx, I can access machines with spare cycles.
09:17:44 <wilx> I see.
09:18:18 <eivuokko> wilx, But I meant the Galois'/Windows maintainer builds - there's some twitch in nightly scripts.
09:18:27 <wilx> Ah.
09:18:56 <eivuokko> Because those are reported in cvs-ghc ml, and it might help to catch Windows probs early.  (Like that timelib doesn't build)
09:20:15 <petekaz> Are there any Haskell videos online?  Ever since the Ruby on Rails folks put up their videos, it seems everyone has been following suit.  I'd love to watch and see how someone "works" with haskell and emacs for example.
09:22:37 <mux> alar: ping?
09:23:11 <wilx> Hmm, the perl scripts seem so old school.
09:25:25 <alar> mux:pong
09:25:51 <mux> alar: so I suppose you used use.perl ? did you check that it added some stuff in /etc/make.conf?
09:26:56 <alar> strange, but I don't have /etc/make.conf
09:27:04 <mux> touch it
09:27:05 <alar> maybe /etc/local/make.conf?
09:27:09 <mux> and run use.perl port again
09:28:26 <dcoutts> aleator, c2hs 0.14.5 parses string.h on my x86_64 linux box just fine
09:29:02 * dcoutts thinks he should add a dump/debug mode to c2hs so we can track these things down more easily
09:29:29 <vincenz> dcoutts: I'm considering writing a tool for c++ types
09:29:41 <vincenz> c++type -> g++ repr  and g++repr -> C++type
09:29:48 <vincenz> where repr = string and type is an ADT
09:30:16 <mux> alar: so?
09:30:22 <vincenz> A::B::C* -> PN1A1B1CE
09:30:27 <vincenz> dcoutts: would this interest you?
09:30:43 <dcoutts> Bobstopper, the mogule stuff in gtk2hs is not intended for anything any more. It's reprecated. Don't use it.
09:31:02 <alar> wait
09:31:34 <dcoutts> vincenz, what do you think it's for?
09:31:37 <Bobstopper> dcoutts: thanks
09:32:01 <vincenz> dcoutts: well for one I would personally use it for reading profile data and making it more readable
09:32:16 <aleator> dcoutts: Hmm. What os?
09:32:29 <alar> seems that it ignores /etc/make.conf
09:32:42 <vincenz> if we add a parser for types ... and add type combinators, it could be used to generate c++ code
09:32:50 <Philippa_> petekaz: I think workflow's fairly personal in haskell. I mean, much as I'd like something that can be sufficiently customised into an IDE-like tool, emacs isn't my thing and so I'm using a bog-standard MDI text editor under windows (OK, one with syntax highlighting) and one or more ghci sessions
09:32:53 <dcoutts> aleator, gentoo linux amd64, glibc-2.3.6
09:33:05 <vincenz> template "Foo" [TInt, TypeName]
09:33:20 <mux> alar: does it give any output?
09:33:33 <vincenz> namespace "DingDong" [template "Foo" [TInt, TYpename], class "Plop"]
09:33:34 <mux> gah, too bad I don't have a 4.x system handy
09:33:46 * araujo back from univ.
09:33:51 <araujo> hiya!
09:34:08 <alar> # -- use.perl generated deltas -- #
09:34:08 <alar> # Created: Mon May 22 20:33:47 2006
09:34:08 <alar> # Setting to use base perl from ports:
09:34:08 <alar> PERL_VER=5.8.5
09:34:08 <alar> PERL_VERSION=5.8.5
09:34:09 <alar> PERL_ARCH=mach
09:34:11 <alar> NOPERL=yo
09:34:13 <alar> NO_PERL=yo
09:34:17 * vincenz smacks alar 
09:34:17 <alar> NO_PERL_WRAPPER=yo
09:34:19 <alar> that's /etc/make.conf
09:34:26 <mux> alar: that's good then
09:34:28 <vincenz> @where paste
09:34:28 <lambdabot> http://rafb.net/paste
09:34:32 <alar> bash-2.05b# make
09:34:32 <alar> ===>  ghc-6.4.2_1 requires newer version of perl.
09:34:35 <SyntaxNinja> y0
09:34:40 <mux> but yeah, paste site better :p
09:34:42 <psnl> yo
09:34:42 <dcoutts> hia SyntaxNinja 
09:34:45 <mux> alar: I think the check is broken
09:34:50 <vincenz> hello SyntaxNinja 
09:34:52 <alar> yep
09:34:53 <mux> alar: remove those lines, and I'll see about it
09:35:03 <alar> ok
09:35:03 <mux> alar: does it succeed if you remove those?
09:35:04 <sjanssen1> @. elite quote SyntaxNinja
09:35:05 <lambdabot> i 7HiNk THat tHe Co/\/\pILEr aU7h0rs wil1 f1y heRE phROM ENG1aND Ju$+ 7O xi11 M3 iF i DID t|-|A7
09:35:11 * Igloo wonders what yo is meant to mean there
09:36:57 <alar> now trying
09:37:06 <alar> I also removed the check for OS version
09:37:32 <alar> 4.5 minutes to fetch the source
09:37:41 <mux> mmm, I hadn't see this, but I bet there's a reason for it
09:38:05 <SyntaxNinja> he
09:38:26 <vincenz> SyntaxNinja: do you believe that class aliases will make it into haskell' ?
09:39:10 <aleator> dcoutts: Well, fc4 has weird string.h then.. Any ideas on how to get this fixed?
09:39:25 <SyntaxNinja> vincenz: class aliases? not sure what those are.
09:39:35 <alar> .if ${OSVERSION} < 500000
09:39:35 <alar> DISTFILES+=     ${BOOT_DIST4}
09:39:35 <alar>  IGNORE=               unsupported at the moment
09:39:43 <SyntaxNinja> you mean making instances from "type" declarations?
09:39:45 <vincenz> SyntaxNinja: class alias (Num a) = Additive a, FromInteger a..
09:39:56 <mux> alar: actually, PERL_LEVEL is set in bsd.port.mk from PERL_VERSION so your make.conf should have worked
09:40:17 <dcoutts> aleator, we need you to send the pre-processed output so we can reprduce the bug
09:40:49 <alar> mux: can it be so that it uses /etc/local/make.conf , but not /etc/make.conf ?
09:41:22 <mux> alar: /etc/local/ is not even supposed to exist
09:42:32 <aleator> dcoutts: Ok. Whom to and what exactly?
09:42:53 <alar> => ghc-6.4.2-i386-unknown-freebsd4-boot.tar.bz2 is not in /usr/ports/lang/ghc/distinfo.
09:42:53 <alar> => Either /usr/ports/lang/ghc/distinfo is out of date, or
09:42:53 <alar> => ghc-6.4.2-i386-unknown-freebsd4-boot.tar.bz2 is spelled incorrectly.
09:43:11 <mux> not surprising
09:44:01 <petekaz> Philippa_: re: workflows, that is what I expected I suppose.  I was just looking for any videos that I could watch during lunchtime at work.  Reading gets tiresome after a bit.
09:44:30 <dcoutts> aleator, if you run: "c2hs -k string.h foo.chs", that will produce foo.i. Send that to c2hs@haskell.org with your bug report
09:45:07 <alar> oh,sorry
09:45:10 <aleator> dcoutts: Will do. Thank you. 
09:45:11 <alar> not /etc/local
09:46:06 <SyntaxNinja> vincenz: I doubt it.
09:47:06 <vincenz> pity, they would help a lot towards cleaning up the Num stuff
09:47:16 <vincenz> allowing for more decomposability without hindering ease of use
09:48:34 <SyntaxNinja> I don't remember having even seen a proposal for that. could be wrong
09:48:51 <vincenz> it's in the ticket list
09:49:03 <kep> hi 
09:49:19 <vincenz> http://hackage.haskell.org/trac/haskell-prime/ticket/101
09:50:50 <SyntaxNinja> it's miscategorized
09:51:14 * SyntaxNinja fixes
09:51:22 <lesshaste> anyone got any idea how to write this better? http://shootout.alioth.debian.org/debian/benchmark.php?test=regexdna&lang=ghc
09:51:25 <kep> davidhouse: as I see before you works with System module for your stuff, can you help me with an example of using System.Cmd.system ? I run small example, like this "module Te where"  
09:51:30 <kep> 	import System.Cmd
09:51:32 <kep> 	main = rawSystem "ls" ["-la"]
09:51:45 <kep> davidhouse: but how can I get result of commend execution  ? 
09:51:56 <davidhouse> i prefer to use System.Process.
09:52:00 <alar> mux: seems there is no "bootstrap" binary for FreeBSD 4
09:52:03 <davidhouse> import System.Process
09:52:28 <davidhouse> main = do (_, out, _, _) <- runInteractiveCommand "ls -la"; x <- hGetContents out
09:52:32 <sjanssen1> lesshaste: like the comment says, wait for packed string regexes?
09:52:44 <vincenz> SyntaxNinja: it can help with a lot of other proposals, making them nearly trivial, like splitting enum
09:52:47 <lesshaste> sjanssen, in the net ghc?
09:52:49 <lesshaste> next
09:53:29 <sjanssen1> lesshaste: a new packed string library is in the next GHC, a new regex library might be included
09:53:54 * SamB wonders what the best way to interface with XPCOM is
09:54:10 <kep> davidhouse thank you , I will try it now :) 
09:54:16 <vincenz> SyntaxNinja: any gross projection of when haskell' is expect?
09:54:19 <vincenz> SyntaxNinja: 2008? 2009?
09:55:14 <davidhouse> they have a roadmap somewhere.
09:55:30 <SyntaxNinja> vincenz: september, hopefully
09:55:39 <vincenz> I mean an implementation
09:56:04 <SyntaxNinja> vincenz: probably not long after that; depends on how hard haskell' turns out to be :)
09:56:09 <vincenz> :)
09:56:31 <davidhouse> a lot of haskell' has already been implemented, no?
09:56:33 <vincenz> i would seriously reconsider using class alias, the impact is minor, the implementation seems rather trivial, but the effects can be empowering for a lot of other design choices
09:56:56 <Philippa_> davidhouse: the intention is that nothing without an implementation goes in
09:57:05 <Philippa_> so it'll be a case of aggregating existing stuff
09:57:30 <SyntaxNinja> vincenz: I suggest you post to the mailing list w/ your point of view :)
09:57:36 <vincenz> SyntaxNinja: link?
09:57:39 <davidhouse> ooh, class aliases look good.
09:57:45 <davidhouse> Philippa_: right.
09:57:51 <SyntaxNinja> vincenz: not handy, but start from the wiki front page.
09:57:56 <vincenz> found it
09:57:59 <vincenz> thx
09:59:08 <SamB> what is a good way to parse a binary file with a lot of offsets in it?
10:00:44 <lesshaste> sjanssen, thx
10:03:36 <alar> mux: will you recommend changing OS to 6.0?
10:04:14 <mux> yes
10:04:33 <alar> do you use 6.0?
10:04:37 <mux> or rather, to 6.1
10:04:46 <alar> is there 6.1 already?
10:04:50 <mux> yes
10:04:57 <alar> hurray!
10:05:00 <mux> I don't use 6.0, I use -CURRENT for development
10:05:46 <alar> is -CURRENT stable enough for desktop use?
10:06:57 <neologism> alar: definitely :)
10:07:09 <mux> well, at the time of this writing, quite yes, but since it's a development branch it can change anytime and start being suddenly horribly broken
10:07:14 <mux> you wouldn't like that
10:08:45 <alar> on desktop one has X, languages, editors, lots of helpful applications, small furry animals, etc.
10:09:06 <alar> if half of them become broken it's a pain
10:14:20 <hyrax42> grea'
10:30:04 <petekaz> Just placed my order for Bird's Intro to FP!  Even better, it cost me nothing aside from the $75 gift cert I received from my employer for 7 years of service.
10:30:12 <petekaz> (cheap bastards)
10:30:39 <vincenz> woo! 10$ a year
10:31:07 <petekaz> considering that this was during the dot-com years, that length of service is quite rare.
10:47:57 * shapr grumbles
10:48:21 <sjanssen_> @palomer
10:48:21 <lambdabot> That's nuts!
10:49:00 <palomer> y0
10:49:14 <jethr0_> @palomer
10:49:14 <lambdabot> Brump!
10:49:17 <eivuokko> What's this palomer-command? :)
10:49:28 <palomer> it's good stuff
10:49:37 <jethr0_> all i know is that it can be quite usefull :)
10:49:40 <eivuokko> Is there other kind of stuff in lambdabot?
10:50:00 <eivuokko> @palomer
10:50:00 <lambdabot> Soylent green is people
10:50:07 <eivuokko> Right.
10:50:12 <jethr0_> \exist "stuff" \in lambdabot where "stuff" /= "@palomer"
10:50:14 <jethr0_> -> True
10:50:47 <palomer> that's a lie
10:50:53 <palomer> @palomer
10:50:53 <lambdabot> That's nuts!
10:51:02 <palomer> @palomer is everything
10:51:03 <lambdabot> Learning vim is pointless
10:51:11 <eivuokko> Heh
10:51:24 <vincenz> pointless is a good thing (TM)
10:51:29 <jethr0_> ack
10:52:56 <sjanssen_> my favorite lambdabot trick is pointless . djinn
10:53:35 <vincenz> @djinn .
10:53:35 <lambdabot> Cannot parse command
10:53:47 <sjanssen_> @. pl djinn (a -> b -> c) -> (d -> b) -> (e -> a) -> e -> d -> c
10:53:48 <lambdabot> f = flip . ((flip . ((.) .)) .) . (.)
10:53:57 <vincenz> @djinn (b -> c) -> (a -> b) -> a -> c
10:53:57 <lambdabot> f a b c = a (b c)
10:54:03 * vincenz tsks
10:54:15 <sjanssen_> vincenz: what's wrong?
10:54:16 <vincenz> @. @pl @djinn (b -> c) -> (a -> b) -> a -> c
10:54:16 <lambdabot> compose module failed: Parse error: "@pl"
10:54:22 <vincenz> sjanssen_: f = .
10:54:39 <sjanssen_> @. pl djinn (b -> c) -> (a -> b) -> a -> c
10:54:39 <lambdabot> f = (.)
10:54:51 <vincenz> \o/
10:55:18 <palomer> wow that was an awful weekend
10:56:37 <mcnster> i have a q:  how can i read a file into a var of type String while preserving utf-8 encoding?
10:57:08 <sjanssen_> mcnster: there aren't any standard solutions (this is a known problem, and people are working on it)
10:57:22 <mcnster> ahso
10:57:36 <sjanssen_> there are UTF-8 encoders/decoders floating around, I don't have any links though
10:58:19 <mcnster> so a ffi approach is necessary?
10:58:36 <msph> Could the file be read without any interpretation?  i.e., direct bytewise read into the String?
10:59:08 <sjanssen_> msph: yes, with Data.ByteString
10:59:15 * msph makes a note of that
11:00:36 <eivuokko> With binary IO and using fromIntegral and Data.Char.chr from binary buffer into list of Chars
11:00:39 <sjanssen_> mcnster: FFI isn't strictly necessary -- as I mentioned, Data.ByteString can do raw string manipulation, that might get you close enough
11:00:50 <eivuokko> But it is pretty nasty to do that.
11:00:56 <mcnster> yikes
11:00:56 <sjanssen_> eivuokko: you still have to write the logic to parse UTF-8
11:01:21 <eivuokko> I thought the idea was to preserve encoding.
11:01:33 <eivuokko> And anyway, either way, if you can, ByteString is better.
11:02:36 <mcnster> eivuokko, clarification: i want to *translate* from raw binary to utf-8 upon read
11:03:00 <eivuokko> Uhm
11:03:10 <msph> mcnster utf-8 is a binary format.
11:03:17 <eivuokko> I have no idea what that means.  Binary is what, then?
11:03:36 * mcnster wonders what isn't binary format in this world ;-)
11:03:47 <msph> Good point.
11:03:51 <norpan> hi
11:03:53 <sjanssen_> mcnster: that's still ambiguous.  do you mean that you have a bunch of bytes, you want to interpret them as UTF-8 and put them in normal Haskell strings?
11:04:01 <norpan> if you have any utf-8 questions you can ask me :)
11:04:22 <mcnster> utf-8 characters can be 1-3 bytes long.  they are translated to Char's having a value 0-(>255)
11:04:35 <msph> I thought they could expand as far as necessary.
11:04:44 <mcnster> er, oh, that's what i need to do anyway
11:04:46 <ibid> theoretically, utf-8 character can take six bytes
11:04:54 <jethr0_> what does the "8" stand for?
11:04:55 <norpan> actually, 4 bytes is the maximum
11:05:00 <ibid> jethr0_: eight bits
11:05:05 <ibid> jethr0_: ie. octet
11:05:13 <jethr0_> hmm
11:05:19 <msph> As in, 8-bits is the smallest size that any unicode code point will be stored in.
11:05:41 <ibid> jethr0_: it's the Unicode Transfer(?) Format operating with 8-bit units
11:05:54 <ibid> other UTFs are UTF-7, UTF-16 and UTF-32
11:06:01 <ibid> there may be others, but these i know
11:06:01 <jethr0_> k, thx
11:06:07 <Igloo> SyntaxNinja: Cabal isn't really going to have a file called /etc/server.list, right?
11:06:28 <ibid> (both UTF-16 and UTF-32 have LE and GE variants, and a byte-bisexual variant)
11:07:49 <ibid> norpan: four is the maximum only because unicode doesn't contain that many characters; but UTF-8 is defined up to six bytes (ie. 32-bit characters)
11:08:13 <norpan> ibid: UTF-8 _was_ defined for six bytes :)
11:08:23 <msph> norpan: has it gotten bigger?
11:08:26 <ibid> norpan: huh?
11:09:22 <norpan> no, it has gotten smaller, when unicode got smaller
11:09:29 <mcnster> does anyone know how the compiler parses utf-8?  is it magic in alex or in ghc?
11:09:53 <norpan> i would suppose the lexer does it
11:09:59 <norpan> although i have no idea
11:09:59 <ibid> norpan: uh, when did unicode get *smaller*? i've only seen it get larger
11:10:08 <norpan> unicode was originally 32 bits
11:10:14 <norpan> now it's only <21 bits
11:10:22 <ibid> norpan: how faer back is "originally"?
11:10:33 <ibid> norpan: it was 16 bits not very many years ago
11:10:46 <ibid> norpan: it was expanded to 21 bits in 2002 or so
11:11:05 <norpan> well, there are two standards, unicode and iso-10646
11:11:18 <ibid> 3.0 was the last one formulated in terms of 16-bit characters
11:11:31 <ibid> i remember because that was the current version when i learned unicode
11:11:35 <norpan> and they were merged, one was 16 bits and one was 32 bits
11:11:52 <ibid> norpan: they were merged in early 1990's
11:12:35 <norpan> they were merged in unicode 3.1
11:12:47 <ibid> norpan: that's not true. they were merged way earlier
11:12:51 <norpan> ISO-10646-2 and unicode
11:12:58 <ibid> yeah, that
11:13:14 <norpan> but anyway, that's history
11:13:20 <ibid> but ISO 10646 and Unicode were synced and merged in the early 1990's
11:13:27 <ibid> i think that's what created Unicode 2.0
11:13:32 <SyntaxNinja> Igloo: oh, it would be more like /etc/cabal/server.list
11:13:39 <jethr0_> good to see that nobody forgot to put the "uni" in unicode :)
11:13:41 <ibid> for example. a lot of characters have two names in Unicode
11:13:53 <Igloo> SyntaxNinja: OK, cool  :-)
11:13:53 <norpan> UTF¬®-8 currently caters for unicode characters and so the maximum number of bytes for UTF-8 is 4
11:13:53 <ibid> jethr0_: huh?
11:14:11 <ibid> UTF-8 also caters for ISO 10646
11:14:15 <jethr0_> ibid: unicode seems to be quite a confusing terrain
11:14:24 <msph> jethr0_: it is.
11:14:24 <ibid> jethr0_: it's not
11:14:26 <msph> Very confusing.
11:14:32 <ibid> jethr0_: it's just complicated
11:14:43 <mcnster> ok back to it.  thanks ppl.
11:15:12 <jethr0_> ibid: well at a low level of understanding, complicated and confusing are really the same thing ^_^
11:15:31 <ibid> yeah, ISO 10646-1:2000 defines UTF-8 up to six bytes
11:15:51 <ibid> jethr0_: i reserve confusing to stuff that cannot be understood even with effort
11:16:05 <ibid> jethr0_: ie badly documented stuff ;)
11:16:20 <jethr0_> ibid: how can you make that judgement before having spent arbitrarily much time? it's like the halting problem...
11:16:46 <ibid> jethr0_: you make that judgment when you've exhausted all possible avenues to understand it
11:16:55 <ibid> jethr0_: i've done that a few times
11:17:11 <ibid> jethr0_: sometimes it's even obvious without further study
11:17:42 <ibid> jethr0_: confusing is when the authors knows something and don't tell
11:18:50 <norpan> anyway, unicode is quite complicated, it may appear simple at first though :)
11:19:04 <norpan> until you confront it with the real world
11:19:07 <ibid> yeah
11:19:19 <ibid> i try to avoid the presentation side of unicode
11:19:26 <ibid> the character encoding is relatively simple
11:19:44 <ibid> fortunately, there's pango so i don't have to worry about presentation ;)
11:22:09 <damg> i dont understand the signature system ... foo (x,y) = x ++ y. Now, I want add' to only accept Strings, the sig would be then foo :: (String a) => (a, a) -> String ... What do I actually miss?
11:22:30 <norpan> foo :: (String, String) -> String
11:22:43 <norpan> (... a) => is for typeclasses, but string is a simple type
11:23:16 <damg> norpan~# ah, I think I got it, thanks :)
11:32:48 <davidhouse> damg, in general though it's good practice to make your functions as polymorphic as possible
11:32:58 <davidhouse> so restricting to strings might not be such a good idea
11:34:13 <norpan> otoh specializing functions make them slightly faster :)
11:34:41 <damg> davidhouse, I know that functions should be unifiable to as general as possible and haskell is very good at determining the allowed types, but I just was playing around and couldn't create a single proper function signature. I think I understand now how it works :)
11:34:54 <davidhouse> damg, okay then. :)
12:07:20 <palomer> hmm
12:07:23 <palomer> what to do today
12:08:41 * SamB tries to trick palomer into doing XPCOM bindings for Haskell
12:11:27 <SamB> am thinking that it might be easier to parse typelibs (http://www.mozilla.org/scriptable/typelib_file.html) than IDL files
12:13:28 <eivuokko> Maybe HaskellDirect contains useful stuff to start with.
12:13:47 <eivuokko> If you must play with IDLs
12:14:28 <SamB> well, it looks a bit, er, thick.
12:14:43 <eivuokko> What's XPCOM anyway?
12:15:15 * dcoutts notes that haskell.org has been promised $45,000 for Google SoC projects!
12:15:18 <SamB> at least, I'm not sure what to do with annotations like [scriptable, uuid(69E5DF00-7B8B-11d3-AF61-00A024FFC08C)]
12:15:26 <xerox> Yay!!
12:15:42 <dcoutts> xerox, it's amazing!
12:15:58 <SamB> XPCOM is Mozilla's cross-platform component object model
12:16:01 <dcoutts> xerox, we should write something to the haskell list when it's properly announced
12:16:01 <eivuokko> SamB, that's probably Microsoft COM specific.
12:16:11 <xerox> Yeah!
12:16:25 <dcoutts> xerox, in particular mentioning the huge number of applications we got and their generally high quality
12:16:50 * xerox scribbles over
12:16:51 <SamB> > 45000 / 5000
12:16:52 <lambdabot> 9.0
12:17:17 <dcoutts> xerox, and that we'd have taken on several more if we could have, there were several excelent project proposals that didn't quite make the top 9 cut-off
12:18:09 <xerox> Should we mention we asked for `n' ?
12:19:16 <SamB> HaskellDirect does seem to contain code for parsing CORBA IDL, which is apparantly what XPIDL is based on
12:19:32 <kosmikus> dcoutts, xerox: an update of your HCAR entry is still possible; I'm working on the report, but the list of projects would be good to have ...
12:19:56 <xerox> kosmikus - it isn't official until tomorrow, and I don't know it :-|
12:20:59 <dcoutts> kosmikus, I can give you an unofficial list I guess
12:21:14 <SamB> eivuokko: also, apparantly they had been planning to switch to an alex-generated lexer but hadn't done it yet...
12:21:17 <psi> the top 9 is established?
12:21:29 <dcoutts> kosmikus, and hopefully that will not change by tomorrow, but you'd have to understand that there is an outside chance that it could
12:21:48 <eivuokko> SamB, yeah, the project apprently died.  I'd think it was because generally ghc in Windows sort of died for a while.
12:22:33 <SamB> eivuokko: has it been changed in CVS since the last release?
12:22:50 <psi> google haven't said when they'll announce the list, have they?
12:23:03 <eivuokko> SamB, No idea.  But comlib parts have been used in visual haskell, and that repo contains modified version, I think
12:23:23 <SamB> hmm, what do you do about botswarms?
12:23:27 <sjanssen_> psi: the original plan had the 23rd, but who knows if the deadline will slip
12:23:28 <eivuokko> SamB, I have had plan to take it on, and I was going to, until I find out that directx doesn't come with proper IDL-files.
12:24:05 <psi> sjanssen_: ah. I'm counting on 23rd, I was thinking about the exact time :-)
12:24:05 <SamB> eivuokko: so? you could probably get the type viewer tool to generate some IDL for you...
12:24:16 <eivuokko> SamB, From what?
12:24:31 <SamB> let me check
12:24:31 <eivuokko> SamB, There are no typelibs, there are no IDispatch implemented on DirectX interfaces.
12:24:51 <eivuokko> SamB, And I mean DirectX 9, there are stuff for older directx.
12:25:02 <SamB_XP_> are those two logically connected?
12:25:38 <eivuokko> Logically?  Yeah, for big parts.   But no interface inheritance or anything.
12:26:00 * SamB_XP_ finds the Sega CD rom he has been looking for...
12:26:23 <SamB_XP_> I meant "no typelibs" and "no IDispatch"
12:26:44 <eivuokko> Well, it's all part of the same reason
12:27:28 <eivuokko> A lot of DirectX speed comes from rawish memorystructures in arrays (continuous memory) that aren't sensibly described in IDL or presented for VB/IDispatch targets.
12:27:36 <eivuokko> So there's only C and C++ interfaces.
12:28:10 <SamB_XP_> there isn't IDL for structs/arrays ?
12:28:48 <eivuokko> I don't really know.
12:28:57 <eivuokko> I have never used IDL to describe data, just functions.
12:29:05 <eivuokko> (and interfaces)
12:29:31 <Zarvok> Is any one else having trouble getting to haskell.org or is it just me?
12:29:53 <eivuokko> It seems a bit stuck, yeah.
12:30:07 <Zarvok> yeah
12:30:10 <Zarvok> I'm lost without hoogle
12:30:12 <Zarvok> :)
12:30:18 <eivuokko> @hoogle id
12:30:19 <lambdabot> Prelude.id :: a -> a
12:30:19 <lambdabot> Text.Html.identifier :: String -> HtmlAttr
12:30:19 <lambdabot> Text.ParserCombinators.Parsec.Language.identLetter :: LanguageDef st -> CharParser st Char
12:30:26 <davidhouse> argh. i have to 1) write a CV. 2) write it in german
12:30:47 <Zarvok> heh, true, didn't think of lambdabot
12:31:22 <eivuokko> And while mailing lists are down, #haskell can often also replace haskell@ as optimisation tool.
12:31:52 <Zarvok> heh
12:35:34 <SamB_XP_> hmm, I just dragged something into the OLE/COM Object Viewer, and apparantly it is being too literal minded...
12:36:11 <SamB_XP_> it came up with a "Drag and Drop Data Object"
12:37:53 <eivuokko> I can see DirectX 7 and 8 in typelibraries on my OLE/COM viewer, but no DirectX 9.  There's also no .idl for dx 9, on sdk or anywhere else I could see.
12:38:06 <SamB_XP_> it has no clue what CLSID it has, and says it implements IAsyncOperation, IClientSecurity, IDataObject, IMarshal, IMultiQI, IProxyManager, and IUnknown
12:38:16 <eivuokko> Hm
12:38:40 <SamB_XP_> so much for drag and drop...
12:38:47 <kosmikus> xerox, dcoutts: it has time until tomorrow
12:39:31 <dcoutts> kosmikus, so did you want a preliminary list? (in private of course)
12:40:18 <kosmikus> dcoutts: I'd be interested, but it's not necessary for the HCAR.
12:57:25 <jethr0_> davidhouse: need some help with that CV?
12:57:41 <jethr0_> davidhouse: i can at least offer some translation services...
13:05:34 <ihope> I created two types, each of which can hold anything in the RandomGen class.
13:07:07 <ihope> One of them contains the results of its class functions; that is, x contains next x, split x, and genRange x.
13:07:26 <ihope> The other is just a GADT.
13:07:38 <davidhouse> jethr0_: well i speak fairly good german
13:07:55 <davidhouse> jethr0_: it's just the german-specific details i need to know about
13:08:01 <jethr0_> k, just in case you need some support ^_^
13:08:04 <davidhouse> i.e. what format they should be. 
13:08:22 <davidhouse> thanks :)
13:08:41 <jethr0_> hmm, that's a hard question. i'm heavily into writing german cvs as well right now, but i'm a little uncertain myself in that respect
13:09:15 <davidhouse> could you send me an example, perhaps?
13:10:33 <jethr0_> yes, but i've adapted mine from a german guy's english CV, so it might not fulfill your needs. but sure
13:12:53 <ihope> Then I created a function that, when given a next, split, and genRange, as well as the generator itself, would produce something of the first type.
13:13:09 <davidhouse> jethr0_: are photos common? they're never used in england, really.
13:13:36 <jethr0_> davidhouse: i think in germany it's common to include photos. i know in the US it's prohibited by law.
13:14:42 <davidhouse> jethr0_: that'll be really helpful, thanks.
13:15:06 <jethr0_> np, and take everything i say with a few grains of salt, please
13:15:15 <davidhouse> don't worry.
13:17:41 <davidhouse> jethr0_: you speak that many languages? i'd hire you :)
13:18:22 <jethr0_> davidhouse: please do :)
13:25:02 <jethr0_> davidhouse: are you applying at a specific company with that CV you're writing?
13:31:00 <jethr0> the invention of several parallel automake versions was a really bad move. i always tend to have the wrong one installed *grumble*
13:40:44 <davidhouse> jethr0: i'm doing work experience in r√ºsselheim in a couple of months. therefore i won't be handling the application process but my german counterparts have requested a CV.
13:41:10 <jethr0> k
13:45:16 <damg__> I get parse errors at = in a local where declaration block (and local let block) as soon as I assign a second var. Looks like I miss something again =)
13:46:10 <jethr0> damg__: is it possible that you have mixed tabs and spaces?
13:46:51 <damg__> actually, not, I use tabs only since a lot of years, but ill recheck :)
13:46:58 <jethr0> the new assignment has to be indented at least 2 spaces deeper than the "where" afaik
13:47:22 <astrolabe> You know tabs in haskell are 8 spaces?
13:47:51 <astrolabe> Although I suppose if you have no spaces, that isn't relevant.
13:48:04 <damg__> actually my vim should use \t
13:48:21 <damg__> moment, maybe my ident is just wrong  (uploading the lines to a pastebin)
13:48:22 <astrolabe> Oh no, it could be relevant.
13:48:44 <davidhouse> does vim have a haskell-mode? or do vimmers just put up with the spacebar?
13:48:50 * astrolabe uses only spaces.
13:48:54 * jethr0 too
13:48:59 <davidhouse> snap.
13:49:07 <davidhouse> with emacs there's no reason not to.
13:49:17 <jethr0> i let vim introduce several spaces when i press TAB, though
13:49:24 <palomer> @palomer
13:49:25 <lambdabot> That's nuts!
13:49:32 <jethr0> ^_^
13:49:46 <jethr0> let's not get into that old flamewar again
13:50:04 <palomer> @palomer
13:50:04 <lambdabot> Learning vim is pointless
13:50:07 <palomer> yes!
13:50:11 <damg__> well, i installed a .vim and use the tab key only as i always did in python. rechecked - no spaces. I think, I just have a dumb mistake, moment :)
13:50:20 <damg__> .vim for haskell i mean
13:51:18 <jethr0> you can always paste on "http://paste.lisp.org/new/haskell" and we'll have a look at it
13:51:33 <jethr0> although that's another place where tabs can be a nuissance ;)
13:51:45 <damg__> ok, moment, pastebin is way too slow :)
13:51:56 <damg__> ah, well, here it flies
13:51:56 <damg__> http://pastebin.com/731854
13:52:07 <bolrod> just replace all the tabs with the correct amount of spaces? :P
13:52:21 <davidhouse> paste.lisp.org needs haskell syntax highlight.
13:52:25 <davidhouse> woah, it is being slow.
13:52:30 <bolrod> its waiting
13:52:33 <jethr0> is that me or is pastebin.com really slow tonight?
13:52:41 <damg__> yeah, pastebin got really slow in last days
13:52:44 <bolrod> maybe DDoS ? 
13:52:45 * astrolabe hires an army of ninjas to sneak into peoples houses and remove their tab keys.
13:52:59 <bolrod> astrolabe: take the CAPS LOCK along with it
13:53:06 <davidhouse> ooh, i heard a great idea today
13:53:13 <vincenz> @where paste
13:53:13 <davidhouse> rebind caps lock to ctrl
13:53:13 <lambdabot> http://rafb.net/paste
13:53:16 <vincenz> !
13:53:30 <davidhouse> ta-da! no more overused little finger.
13:53:36 <bolrod> ?
13:53:39 <damg__> ill replace all \ts with spaces, stay tuned ^^
13:54:00 <davidhouse> damg__: could you use paste.lisp.org?
13:54:03 <bolrod> :expandtab  could replace all right? :)
13:54:04 * jethr0 has CAPS LOCK working overtime as COMPOSE
13:54:05 <vincenz> @paste
13:54:05 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
13:54:08 <davidhouse> i'm having trouble getting anything out of pastebin.
13:54:08 <vincenz> @whe paste
13:54:09 <lambdabot> Maybe you meant: where where+ ghc what wn
13:54:11 <davidhouse> @wher paste
13:54:11 <lambdabot> Maybe you meant: where where+
13:54:11 <vincenz> @where paste
13:54:11 <lambdabot> http://rafb.net/paste
13:54:12 <damg__> ok, moment
13:54:14 <vincenz> use that one
13:54:15 <vincenz> it's fast
13:54:32 <bolrod> WOAH
13:54:39 <bolrod> the pastebin loaded
13:54:52 <bolrod> what is the error? :P
13:55:16 <bolrod> can you start a variable with a number?
13:55:18 <davidhouse> @where paste
13:55:19 <lambdabot> http://rafb.net/paste
13:55:21 <davidhouse> @where paste
13:55:21 <lambdabot> http://rafb.net/paste
13:55:24 <bolrod> subList lst start end 
13:55:25 <davidhouse> who changed that?
13:55:29 <bolrod> lst?
13:55:30 <bolrod> hm
13:55:38 <bolrod> looked like 1st :/  sorry
13:55:50 <damg__> http://paste.lisp.org/display/20281
13:55:51 <davidhouse> damg__: what's the error?
13:56:02 <damg__> util.hs:17:24: parse error on input `='
13:56:15 <damg__> the last line ;)
13:56:20 <davidhouse> delete two leading spaces
13:56:33 <jethr0> *aahhh* 
13:56:36 <davidhouse> so lstTail lines up with lstPart
13:56:43 <jethr0> davidhouse: there aren't any. he's using only tabs (sic!)
13:57:00 <damg__> btw, i should throw out a rule ;)
13:57:13 <damg__> there are tabs, moment, ill replace them with spaces :
13:57:14 <damg__> )
13:57:32 <jethr0> alternatively try indenting the first where clause with a tab also, so that they align by tabs!
13:57:47 <davidhouse> if you want to stick to tas you need to do "where NEWLINE TAB blah blah blah NEWLINE TAB blah blah blah"
13:57:48 <jethr0> hmm, maybe not such a good idea
13:57:53 <bolrod> :expandtab
13:57:54 <bolrod> :retab
13:57:55 <bolrod> done
13:58:55 <bolrod> ^.0
13:59:36 <davidhouse> night all.
13:59:51 * davidhouse has an early night in view of his german exam tomorrow
13:59:57 <damg__> ok, where \n\t blah \n\t did the trick :)
13:59:57 <bolrod> ohh
14:00:00 <jethr0> bolrod: i'm sure some smartass will tell us about emacs and it's cool features like "M-x morse-region" now
14:00:04 <damg__> thanks :E
14:00:19 <bolrod> jethr0: I had to kill it to shut it down
14:00:20 <bolrod> haha
14:00:33 <jethr0> ...././.-../.-../--- .--/---/.-./.-../-..
14:00:36 <bolrod> ?
14:00:39 <bolrod> .-- .... .- - ..--.. ! ..--.. ! 
14:00:41 <davidhouse> wow! :D
14:00:51 <bolrod> dude.. my morse doesn't decode the /'s
14:01:10 <jethr0> ups, no idea what happened there
14:01:12 <bolrod> .... . .-.. .-.. ---  .-- --- .-. .-.. -..
14:01:14 <bolrod> ah
14:01:23 <bolrod> HELLO WORLD
14:01:23 <davidhouse> jethr0's was hello world
14:01:29 <bolrod> :]
14:01:38 <jethr0> weird. must be because i'm in some weird lisp mode
14:01:42 <davidhouse> so was bolrod's.
14:01:49 <bolrod> erh
14:01:52 <bolrod> nat rly
14:01:52 <davidhouse> ..../.-/.../-.-/./.-../.-.. ../... --./.-././.-/-
14:01:56 <bolrod> >:/
14:01:58 <bolrod> I can't read that!
14:02:01 <sjanssen_> why isn't Morse code prefix free?
14:02:01 <bolrod> mpf00pmp mpmmppfmp
14:02:20 <jethr0> bolrod: what mode are you in?
14:02:31 <bolrod> have you ever heard a    '/'  in a morse code transmission ?!  get it out !
14:02:33 <bolrod> :P
14:02:36 <jethr0> i can unmorse that just fine
14:03:03 <bolrod> pfff :/  I dont know maybe old version?
14:03:08 <jethr0> but i agree that it's not very morse-like
14:03:27 <ihope__> Sigh.
14:03:33 <bolrod> pmpmppppppppffm fmmmmfpffmffpfmfmp mfffmm mmfppfppfpmfmpppff
14:03:36 <bolrod> you can read that?
14:04:01 <bolrod> jethr0: do you use mangle.pl ?
14:04:10 <jethr0> not intentionally
14:04:50 <malcolm> seen "remorse"?  haskell morse-ificator for haskell programs
14:05:08 <jethr0> yes, it was one of the obfuscation entries, right?
14:05:38 <malcolm> yes, the winner of the 0th contest
14:05:40 <astrolabe> can I use a '@' in a list comprehension?
14:05:50 <norpan> astrolabe: sure
14:05:58 <astrolabe> cool, Thanks.
14:06:19 <norpan> most answers to that kind of questions can be answered by testing it :)
14:06:22 <jethr0> astrobabe: sure you can
14:06:43 <norpan> anywhere there is a pattern binding you can tag on x@
14:06:58 <bolrod> anyway...   the pmpmpmppmfpfffpm  etc = kenny script
14:07:01 <bolrod> for those who don't know
14:07:02 <bolrod> :)
14:07:47 <astrolabe> I don't think I mean at the pattern binding.
14:08:01 <norpan> where do you mean then
14:08:13 <jethr0> M-x unke [No match]
14:08:34 <jethr0> :)
14:08:49 <astrolabe> [a@ f x | x <- xs, g a]
14:09:01 <jethr0> aahh
14:09:03 <bolrod> that looks weird
14:09:18 <norpan> astrolabe: what would that mean?
14:09:43 <jethr0> you mean like [y | x <- xs, y <- [f x], g y]
14:09:48 <jethr0> if that should magically work :)
14:09:53 <astrolabe> the set of f x  for x in xs  such that g (f x)
14:10:29 <astrolabe> jethr0: thanks, I think that will work.
14:10:43 <jethr0> not sure that's very idiomatic though
14:10:46 <ihope> Hmm...
14:11:28 <norpan> you can use let
14:11:34 <bolrod> > [ (+1) x | x<-[1..10], even]
14:11:35 <lambdabot> Couldn't match `Bool' against `t -> t1'
14:11:36 <jethr0> filter (g . f) xs
14:11:37 <astrolabe> oooh I remember let
14:11:40 <norpan> [y | x <- xs, let y = f x, g y]
14:11:41 <ihope> norpan: how?
14:12:07 <jethr0> no, sorry. filter g $ map f xs
14:12:31 <bolrod> > [ (+1) x | x<-[1..10], let test = (+1) x in even test ]
14:12:32 <lambdabot> [2,4,6,8,10]
14:12:34 <bolrod> :o
14:12:46 <jethr0> > filter even $ map (+1) [1..10]
14:12:47 <lambdabot> [2,4,6,8,10]
14:12:55 <bolrod> mine seems to work as well
14:12:58 <bolrod> :]
14:13:15 <bolrod> with the let ;)
14:13:17 <jethr0> bolrod: yours duplicates the (+1)
14:13:25 <bolrod> pff!
14:13:28 <norpan> [ y | x <- [1..10], let y = x+1, even y]
14:13:34 <norpan> > [ y | x <- [1..10], let y = x+1, even y]
14:13:35 <lambdabot> [2,4,6,8,10]
14:13:36 <bolrod> > let f = (+1) in  [ f x | x<-[1..10], let test = f x in even test ]
14:13:37 <lambdabot> [2,4,6,8,10]
14:13:39 <bolrod> there!
14:13:45 <jethr0> yup, but i like MY version best :)
14:13:52 <bolrod> with the map and filter?
14:13:56 <norpan> the point is that you can use let without the "in" in a list comprehension
14:14:07 <norpan> just like in a do-block
14:14:07 <bolrod> > let f = (+1) in  [ f x | x<-[1..10], let test = f x, even test ]
14:14:09 <jethr0> norpan: yes, i didn't know that
14:14:09 <lambdabot> [2,4,6,8,10]
14:14:20 <bolrod> well.. whats the difference ;)  
14:14:25 <jethr0> well, it really is syntactic sugar for a do-block...
14:14:25 <astrolabe> Thanks guys
14:14:33 <norpan> jethr0: exactly :)
14:14:37 <Eelis> xerox: ping (re. gtk2h install)
14:14:53 <bolrod> magically install the .debs!
14:16:38 <bolrod> anyway.. the point is.. the problem is solved :]
14:16:47 <norpan> although you can't use booleans that way in a do block
14:17:12 <jethr0> well, with "guard", "when", "unless" you almost can
14:17:23 <norpan> yeah, it translates to guard
14:17:28 <jethr0> yup
14:17:42 <norpan> but you don't need it in a list comprehension for some reason
14:17:54 <bolrod> you don't even need list comprehension!
14:17:59 <bolrod> just write it out !  read the report :P
14:18:07 <bolrod> duhhh :]
14:19:52 <Cale> > [2,4..10]
14:19:53 <lambdabot> [2,4,6,8,10]
14:20:08 <bolrod> oh come on :P
14:20:17 <bolrod> that one was too obvious
14:20:26 <bolrod> > take 5 $ iterate (+2) 2
14:20:27 <lambdabot> [2,4,6,8,10]
14:20:32 <sjanssen_> norpan: the reason you don't need guard is because the syntax of list comprehensions can figure out what the type of each term should be
14:21:00 <Cale> > scanl (+) 2 [2,2,2,2]
14:21:00 <lambdabot> [2,4,6,8,10]
14:21:08 <bolrod> :p
14:21:14 <Cale> > scanl (+) 2 (replicate 4 2)
14:21:15 <lambdabot> [2,4,6,8,10]
14:21:16 <sjanssen_> things using <- must be binds, things with let must be lets, and all other things must be boolean expressions
14:21:35 <norpan> yes, because you can't run a computation and not bind it
14:21:37 <norpan> like you can with do
14:21:41 <bolrod> > [2,4,6,8,10]
14:21:42 <lambdabot> [2,4,6,8,10]
14:21:43 <jethr0> > do {x <- [1..10]; let y = (+1) x in do {guard (even y); return y}}
14:21:43 <bolrod> w00t!
14:21:43 <lambdabot> [2,4,6,8,10]
14:21:44 <sjanssen_> exactly
14:22:01 <jethr0> annoyingly lambdabot doesn't accept isolated "let"s :(
14:22:32 <Cale> it does
14:22:41 <dieter> Hi, I have work on my Ringimplementation, and have a Problem with the sum function. I have a small example where can I paste it?
14:22:42 <jethr0> > do {x <- [1..10]; let y = (+1) x; guard (even y); return y}
14:22:43 <lambdabot>  parse error on input `;'
14:22:43 <Cale> > do {x <- [1..10]; let {y = (+1) x}; do {guard (even y); return y}}
14:22:44 <lambdabot> [2,4,6,8,10]
14:22:47 <bolrod> guard is syntactic sugar for   if then else?
14:22:55 <Cale> guard is an ordinary function
14:22:57 <sjanssen_> lisppaste2: url
14:22:57 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:23:01 <bolrod> yah
14:23:01 <jethr0> cale, but usually the inner do isn't needed...
14:23:04 <sjanssen_> dieter: that URL will work
14:23:13 <Cale> > do {x <- [1..10]; let {y = (+1) x}; guard (even y); return y}
14:23:14 <lambdabot> [2,4,6,8,10]
14:23:22 <Cale> right, associative law :)
14:23:29 <jethr0> aahh
14:23:32 <bolrod> ic
14:23:38 <Cale> guard p x = if p then x else mzero
14:23:49 <Cale> er
14:23:50 <Cale> no
14:23:50 <lisppaste2> dieter pasted "Ring implementation" at http://paste.lisp.org/display/20283
14:23:52 <jethr0> cale: i know, i just forgot braces around let clause
14:23:56 <Cale> guard p = if p then return () else mzero
14:25:00 <Cale> jethr0: yeah, there's an ambiguity when you smash everything on to one line like that -- the let wants to munch the rest of your do block without the braces there
14:25:08 <dieter> p1+p1 is right, add p1 p1 is right, but sum [p1, p1] is wrong.
14:25:14 <norpan>  > foldr (\x y -> if even x then (x:y) else y) [] [1..10]
14:25:21 <norpan> > foldr (\x y -> if even x then (x:y) else y) [] [1..10]
14:25:22 <lambdabot> [2,4,6,8,10]
14:25:35 <Cale> dieter: how is fromInteger 0 ?
14:25:47 <jethr0> norpan: how is that not "filter"? :)
14:26:07 <Cale> jethr0: it is
14:26:18 <Cale> jethr0: we're just writing that list in lots of ways :)
14:26:37 <norpan> oh, no +1
14:26:37 <bolrod> > reverse [10,8,6,4,2]
14:26:38 <lambdabot> [2,4,6,8,10]
14:26:39 <bolrod> aha!
14:26:46 <Cale> heh
14:26:49 <norpan> > [2,4..10]
14:26:51 <lambdabot> [2,4,6,8,10]
14:26:54 <bolrod> already had that one
14:27:00 <Cale> > id id id id [2,4,6,8,10]
14:27:01 <norpan> gah
14:27:01 <lambdabot> [2,4,6,8,10]
14:27:07 <sjanssen_> dieter: the definition of sum uses (fromInteger 0), is that a problem with your type?
14:27:20 <norpan> map (+1) (filter odd [1..10])
14:27:25 <norpan> > map (+1) (filter odd [1..10])
14:27:26 <lambdabot> [2,4,6,8,10]
14:27:57 <jethr0> > fst . partition even $ [1..10]
14:27:58 <lambdabot> [2,4,6,8,10]
14:28:03 <bolrod> > zipWith (+) [1..5] [1..5]
14:28:05 <lambdabot> [2,4,6,8,10]
14:28:11 <Cale> > let evens = map (+1) odds; odds = 1 : map (+1) evens in take 5 evens
14:28:12 <lambdabot> [2,4,6,8,10]
14:28:49 <dieter> sjanssen_: no if I 0::Polynom Integer gives the expected result.
14:29:10 <bolrod> how many times are we going to write a function that produces [2,4,6,8,10] ?
14:29:23 <Cale> 2? 4? 6? 8? 10?
14:29:23 <sjanssen_> dieter: with your definitions, 1 + 0 /= 1, and that's your problem
14:29:26 <norpan> > take 5 $ let f = 2:map (+2) f in f
14:29:27 <lambdabot> [2,4,6,8,10]
14:29:49 <norpan> let that be the final one
14:30:00 <bolrod> :)
14:30:53 <ihope> > map (\x -> x*2) (enumFromTo 1 5)
14:30:54 <lambdabot> [2,4,6,8,10]
14:30:55 <dieter>  (1::Polynom Integer)+(0::Polynom Integer)==(1::Polynom Integer) evaluates to True.
14:30:57 <jethr0> > map id [2,4..10]
14:30:58 <lambdabot> [2,4,6,8,10]
14:31:03 <bolrod> oh noe!
14:31:36 <vincenz> > reverse [10,8..2]
14:31:37 <lambdabot> [2,4,6,8,10]
14:31:41 <norpan> how about the obfuscated [2,4..10] contest
14:31:47 <bolrod> :D
14:31:53 <sjanssen_> dieter: actually, the problem is 0 + 1
14:32:12 <Cale> > unfoldr (\x -> if x <= 10 then Just (x, x+2) else Nothing) 2
14:32:12 <lambdabot> [2,4,6,8,10]
14:32:30 <ihope> What's this Polynom stuff?
14:32:34 <dieter> sjanssen_: you are right.
14:32:37 <ihope> @type unfoldr
14:32:38 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
14:32:57 <norpan> > take 5 $ fix ((2:) . map (2+))
14:32:58 <lambdabot> [2,4,6,8,10]
14:33:41 <vincenz> > map ((+2) . (- ord 'a') . ord) "acegi"
14:33:42 <lambdabot> Couldn't match `b -> c' against `Int'
14:33:55 <vincenz> > map ((+2) . ((-) ord 'a') . ord) "acegi"
14:33:55 <lambdabot> Couldn't match `Char -> Int' against `Char'
14:33:58 <jethr0> > scanl1 (+) $ replicate 5 2
14:33:59 <lambdabot> [2,4,6,8,10]
14:34:02 <vincenz> > map ((+2) . (subtract ord 'a') . ord) "acegi"
14:34:03 <lambdabot> Couldn't match `Char -> Int' against `Char'
14:34:07 <vincenz> > map ((+2) . (subtract . ord $ 'a') . ord) "acegi"
14:34:08 <lambdabot> [2,4,6,8,10]
14:34:42 <ihope> It's not possible to have a list of unboxed values, is it?
14:34:48 <bolrod> > take 5 $ map ((*) 2.head)$ iterate tail [1..]
14:34:49 <lambdabot> [2,4,6,8,10]
14:35:28 * vincenz is off \o/
14:35:33 <bolrod> :)
14:35:39 <ihope> map (\(I# x) -> S# x) (I# (1# *# 2#):I# (2# *# 2#):I# (3# *# 2#):I# (4# *# 2#):I# (5# *# 2#):[])
14:35:40 <vincenz> that's a waveing hand
14:35:49 <norpan> maybe that should be the obfuscated [2,4..] contest
14:35:51 <vincenz> \o.
14:35:59 <bolrod> o/
14:35:59 <vincenz> .o/
14:36:04 <bolrod> (o/
14:36:05 <jethr0> > take 5 $ map ((*) 2.head)$ tails [1..]
14:36:06 <lambdabot> [2,4,6,8,10]
14:36:07 <bolrod> \o)
14:36:10 <vincenz> bolrod: no the other way!
14:36:11 <ihope> /o \o /o \o
14:36:16 <dieter> sjanssen_: your first guess was right, there was a problem with formInteger 0, only all other cases worked.
14:36:17 <bolrod> ah sheyat!
14:36:18 <bolrod> :)
14:36:24 <bolrod> _o_   \o/
14:36:30 <vincenz> oh yah
14:36:31 <bolrod> *\o/*
14:36:32 <vincenz> that's a neat irc feature
14:36:33 <jethr0> enough
14:36:34 <vincenz> the auto underline
14:36:40 <vincenz> jethr0: how did you do bold?
14:36:46 <jethr0> ctrl-b
14:36:49 <vincenz> enough
14:36:52 <vincenz> ooh
14:36:54 <jethr0> you can do colors too
14:36:54 <bolrod> 4 fine!
14:36:54 <norpan> 3please
14:37:00 <jethr0> see
14:37:03 <vincenz> and colors?
14:37:03 * bolrod doesn't see colours though
14:37:08 <bolrod> you can do background
14:37:10 <bolrod> and make it blink
14:37:12 <vincenz> how do I do colors
14:37:13 * bolrod won't do that though
14:37:15 <jethr0> :)
14:37:18 <bolrod> ctrl+c4
14:37:21 <bolrod> for example
14:37:32 <bolrod> thats red I think
14:37:34 <jethr0> ctrl-s
14:37:37 <jethr0> ctrl-z
14:37:38 <vincenz> 3\4o3/
14:37:39 <bolrod> hahaha
14:37:47 <bolrod> ctrl+A+D
14:37:49 <vincenz> now it's a flower
14:37:49 <bolrod> ;)
14:37:55 <vincenz> bolrod: I'm about to do that
14:38:01 <vincenz> cya
14:38:04 <bolrod> cya :]
14:38:21 <norpan> > fix((2:).map(2+))
14:38:22 <lambdabot> [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,
14:38:23 <lambdabot> 126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,
14:38:23 <lambdabot> 224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,
14:38:23 <lambdabot> 322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,
14:38:25 <lambdabot> 420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,512,514,516,
14:38:26 <bolrod> NOE!
14:38:27 <norpan> wow
14:38:28 <Cale> > let getCC x0 = callCC (\c -> let f x = c (x,f) in return (x0, f)) in execWriter . (`runContT` return) $ do { (x,jump) <- getCC 2; lift (tell [x]); if x < 10 then jump (x+2) else return () }
14:38:28 <lambdabot> [6 @more lines]
14:38:29 <bolrod> YOU TWIT!
14:38:30 <lambdabot>  Not in scope: `tell'
14:38:34 <Cale> aww
14:38:36 <bolrod> :)
14:38:46 <Cale> no Writer or Cont monads
14:38:55 <ihope> Cale: ooph
14:38:57 <ihope> !index tell
14:39:00 <ihope> @index tell
14:39:00 <lambdabot> Control.Monad.Writer, Control.Monad.RWS
14:39:09 <ihope> Writer?
14:39:14 <Cale> yeah
14:39:29 <ihope> @type Control.Monad.Writer.tell
14:39:31 <lambdabot> forall (m :: * -> *) w.
14:39:31 <lambdabot>           (Control.Monad.Writer.MonadWriter w m) =>
14:39:31 <lambdabot>           w -> m ()
14:39:41 <bolrod> does haskell have binary 'or'  ? :)
14:39:51 <ihope> @type (||)
14:39:52 <lambdabot> Bool -> Bool -> Bool
14:39:57 <bolrod> binary
14:39:58 <ihope> @type or
14:39:59 <lambdabot> [Bool] -> Bool
14:40:02 <Cale> @type (.|.)
14:40:03 <ihope> Hmm.
14:40:03 <lambdabot> forall a. (Bits a) => a -> a -> a
14:40:07 <ihope> Ah!
14:40:27 <bolrod> 2'or'1 = 3
14:40:42 <bolrod> (.|.) 3 1
14:40:46 <bolrod> > (.|.) 3 1
14:40:47 <lambdabot> Add a type signature
14:40:50 <bolrod> > (.|.) 3 1 :: Int
14:40:51 <lambdabot> 3
14:40:55 <bolrod> > (.|.) 2 1 :: Int
14:40:56 <lambdabot> 3
14:40:58 <bolrod> yay!
14:41:05 <bolrod> > (.^.) 2 1 :: Int
14:41:06 <lambdabot>  Not in scope: `.^.'
14:41:12 <ihope> .^.?
14:41:15 <bolrod> xor?
14:41:28 <norpan> > xor 2 1 :: Int
14:41:29 <lambdabot> 3
14:41:33 <bolrod> bah!
14:41:43 <bolrod> > xor 3 1 :: Int
14:41:44 <lambdabot> 2
14:42:02 <bolrod> @index xor
14:42:02 <lambdabot> Data.Bits, Foreign
14:42:14 <norpan> Foreign?
14:42:16 <Cale> Of course, it doesn't have xor on Bools since that's just (/=)
14:42:32 <norpan> > xor True False
14:42:32 <lambdabot>  add an instance declaration for (Bits Bool)
14:42:33 <lambdabot>   In the definition of `mix': mix = xor True False
14:42:33 <lambdabot>   In the definition of `lip':
14:42:50 <norpan> mix? lip?
14:42:57 <sjanssen_> hmm.  Bool should be an instance of Bits
14:44:17 <bolrod> possibly.. like..   00000000 = False? or something
14:44:41 <bolrod> what kind of sick calculations do you want to perform with that ? ;)
14:45:08 <norpan> 0 = False, 1 = True
14:45:12 <bolrod> yes
14:45:12 <norpan> easy
14:45:20 <bolrod> well.. erh..   isn't there a normal xor for Bool?
14:45:27 <Cale> no
14:45:34 <bolrod> weird
14:45:36 <Cale> (and yes)
14:45:40 <Cale> > True /= False
14:45:41 <sjanssen_> I mean, it's an incredibly trivial instance, but it just seems wrong not to have one
14:45:41 <lambdabot> True
14:45:46 <Cale> > False /= False
14:45:47 <lambdabot> False
14:45:54 <Cale> > True /= True
14:45:55 <lambdabot> False
14:46:08 <Cale> You use /= :)
14:46:11 <bolrod> hehe
14:46:12 * sjanssen_ writes a note to submit a patch
14:46:15 <jethr0> > (1/0) == (-1/0)
14:46:15 <lambdabot> False
14:46:23 <bolrod> :/
14:46:27 <bolrod> that should give an error!
14:46:30 <norpan> no
14:46:33 <Cale> no
14:46:35 <bolrod> no?!
14:46:36 <Cale> > (1/0)
14:46:37 <lambdabot> Infinity
14:46:38 <norpan> Inf /= -Inf
14:46:39 <jethr0> yeah, flamewar :)
14:46:39 <Cale> > (-1/0)
14:46:40 <lambdabot> -Infinity
14:46:42 <sjanssen_> IEEE defined behavior
14:46:47 <Cale> They're IEEE floats
14:46:57 <ihope___> > (1/0) == (1/(-0))
14:46:58 <lambdabot> False
14:46:59 <jethr0> > (1/0) == (1/0)
14:47:00 <lambdabot> True
14:47:03 <bolrod> how do you know the Reals don't wrap around!?!
14:47:10 <bolrod> (ok.. that's silly)
14:47:10 <psi> > 0/0
14:47:11 <Cale> > (0/0) == (0/0)
14:47:12 <lambdabot> NaN
14:47:12 <lambdabot> False
14:47:28 <Cale> > let x = (0/0) in x == x
14:47:29 <lambdabot> False
14:47:37 <bolrod> then that should be true >_>
14:47:42 <bolrod> since
14:47:44 <bolrod> > 0==0
14:47:45 <lambdabot> True
14:47:52 <ihope> Always true: (x == x) == (x == x)
14:47:54 <jethr0> huh?
14:47:59 <Cale> heh
14:48:02 <bolrod> see 
14:48:09 <jethr0> NaN doesn't fall under that rule by design
14:48:10 <Cale> > let x = (0/0) in (x == x) == (x == x)
14:48:11 <lambdabot> True
14:48:25 <bolrod> so NaN == NaN
14:48:29 <jethr0> no
14:48:38 <bolrod> ah False == False ;)
14:48:44 <Cale> NaN is defined such that it's not equal to itself
14:48:47 <Cale> it works the same way in other languages too
14:49:04 <bolrod> ok...
14:49:10 <bolrod> but is (1/0) really infinity?
14:49:11 <bolrod> :P
14:49:14 <jethr0> yes, that's the test you can use in C to test whether sth is NaN. unless you use some library call for that :)
14:49:17 <Cale> on floats, yes
14:49:30 <bolrod> you'll never get any closer to 1 with infinity
14:49:32 <jethr0> it's a singularity
14:49:50 <Cale> on real numbers, that's meaningless, since (1/0) means 1 * x where x is a number such that x * 0 = 1
14:49:54 <bolrod> so how can you say 1/0 = infinity.. when there is actually no answer in infinity
14:49:56 <Cale> but there's no solution to that.
14:50:11 <Cale> bolrod: there's an infinity in the IEEE floating point numbers
14:50:20 <bolrod> infinity * 0 = 0   ?
14:50:30 <Cale> > (1/0) * 0
14:50:31 <lambdabot> NaN
14:50:41 <jethr0> bolrod: don't confuse "real" infinity (whatever that is) with IEEE floating point "infinity"
14:50:47 <norpan> > (1/0) * 1
14:50:48 <lambdabot> Infinity
14:50:51 <bolrod> erh :/
14:50:56 <jethr0> *coughs*
14:50:57 <Cale> > (1/0) * (-1/0)
14:50:58 <lambdabot> -Infinity
14:51:01 <Cale> > (-1/0) * (-1/0)
14:51:01 <lambdabot> Infinity
14:51:13 <Cale> > (-0)
14:51:13 <lambdabot> 0
14:51:19 <jethr0> nothing like calculating with evil numbers :)
14:51:19 <Cale> > (1/(-0))
14:51:20 <lambdabot> -Infinity
14:51:28 <bolrod> O_O
14:51:30 <bolrod> haha
14:51:32 <jethr0> > (-1/(-0))
14:51:33 <bolrod> thats just silly
14:51:33 <lambdabot> Infinity
14:51:40 <norpan> > (1/(1/0))
14:51:41 <lambdabot> 0.0
14:51:42 <Cale> > let x = (-0) in x == -x
14:51:43 <lambdabot> True
14:51:51 <jethr0> huh?
14:51:51 <Cale> > let x = (-0) in 1/x == 1/(-x)
14:51:52 <bolrod> SO!
14:51:52 <lambdabot> False
14:51:53 <norpan> allt his is ieee
14:51:56 <norpan> this
14:51:58 <bolrod> -Infinity is Infinity!
14:51:59 <bolrod> hahahaha
14:52:03 <Cale> nope
14:52:05 <jethr0> (1/(1/0)) is just EVIL!
14:52:06 <Cale> as you can see there
14:52:19 <bolrod> pff
14:52:22 <norpan> n/Inf = 0 by definition
14:52:32 <Cale> unless n is negative
14:52:37 <Cale> in which case, you get -0
14:52:46 <norpan> but 0 == -0 :)
14:52:46 <jethr0> which is pretty close to 0
14:52:47 <bolrod> which is basicaly the same
14:52:51 <bolrod> > 0 == -1
14:52:52 <lambdabot> False
14:52:53 <bolrod> > 0 == -0
14:52:54 <lambdabot> True
14:52:56 <jethr0> > 0 == (-0)
14:52:57 <lambdabot> True
14:52:57 <ihope> > 1/(1/0)
14:52:58 <lambdabot> 0.0
14:52:59 <Cale> norpan: but they're inequivalence
14:53:05 <Cale> inequivalent*
14:53:16 <jethr0> afair there are two representations for 0 in IEEE
14:53:20 <Cale> > 1/(-0) == 1/0
14:53:20 <lambdabot> False
14:53:30 <norpan> yes there are two, but they are equal
14:53:32 <Cale> > -0 == 0
14:53:33 <lambdabot> True
14:53:35 <ihope> IEEE is broken!
14:53:38 <bolrod> :)
14:53:38 <norpan> > (0/(1/0))
14:53:40 <lambdabot> 0.0
14:53:43 <norpan> > (-0/(1/0))
14:53:44 <lambdabot> -0.0
14:53:45 <dieter> real infinity is defined as follow: if how have a set N and there is an subset M of N, s. t. #M=#N, then #N is infinity 8-)
14:53:58 <bolrod> > (0/(1/0)) == (0/(1/0))
14:54:00 <Cale> they compare equal, but are not actually equal
14:54:00 <lambdabot> True
14:54:03 <bolrod> > (0/(1/0)) == (-0/(1/0))
14:54:05 <lambdabot> True
14:54:17 <jethr0> dieter: there is no "one" infinity
14:54:31 <dieter> jethr0: yes.
14:54:38 <bolrod> correct
14:54:41 <Cale> dieter: then #N is a cardinal infinity
14:54:52 <Cale> there are lots of other sorts of uses of the term
14:54:56 <bolrod> there's always a bigger fish
14:55:04 <dieter> Cale: given an example.
14:55:11 <Cale> like projective infinity
14:55:15 <norpan> dieter: that's meaningless unless you define #
14:55:25 <Cale> anyway, I'm off
14:55:30 <Cale> norpan: cardinality
14:55:39 <dieter> with # I mean the cardinality. 
14:55:52 <bolrod> > True == True
14:55:54 <lambdabot> True
14:55:57 <bolrod> > False == False
14:55:58 <lambdabot> True
14:56:02 <bolrod> good lord.. they still hold
14:56:05 <norpan> yes but how do you define #
14:56:33 <norpan> and more interesting, how do you define = on it
14:56:36 <dieter> Cale: what is projective infinity?
14:56:46 <tessier> I just read in Haskell Weekly News that Linspire has announced that they will do all of their core OS programming in Haskell.
14:56:54 <tessier> Anyone know anything more about this?
14:57:11 <norpan> tessier: yeah, and it's not even april 1:st
14:57:21 <tessier> norpan: I read that and thought "wtf?"
14:57:30 <tessier> That is definitely not something I would expect of Linspire
14:57:43 <bolrod> maybe they'll hold it for next years 1st april
14:58:21 <palomer> my dad's in a really happy mood
14:58:25 <palomer> I want to kill him
14:58:28 <bolrod> why?
14:58:33 <palomer> because I'm not
14:58:41 <bolrod> why are you not? and why is he?
14:58:45 <palomer> I'm tired
14:58:48 <bolrod> is this linked in some way?
14:58:49 <palomer> he hasn't seen me this weekend
14:59:14 <bolrod> I don't see the connection
14:59:15 <norpan> will killing him make you happier?
14:59:38 <bolrod> norpan: I guess you just have to 'test' it
14:59:43 <bolrod> just like codin
14:59:43 <bolrod> g
14:59:51 <norpan> yeah
15:00:07 <palomer> maybe
15:00:11 <norpan> using non-destructive updates
15:00:20 <bolrod> versioning system
15:00:27 <bolrod> you can revert to the best dad
15:00:31 <bolrod> well.. locally best
15:02:16 <bolrod> either way... maybe you should have a sleep then palomer ?
15:02:31 <bolrod> that sounds not correct...  have a rest?
15:03:12 <palomer> I rather have green tea ice cream
15:03:27 <bolrod> I'd rather have 10 million dollars
15:03:28 <bolrod> :/
15:03:39 <bolrod> make that euro's
15:04:04 <norpan> euros
15:04:12 <norpan> ‚Ç¨
15:04:22 <bolrod> stupid grammar's 
15:04:22 <bolrod> ;)
15:05:48 <jethr0> ‚Ç¨
15:05:55 <ihope> Uh oh.
15:06:02 <jethr0> sry
15:06:10 <ihope> > '\0x1c'
15:06:10 <lambdabot>  lexical error in string/character literal
15:06:24 <ihope> > 0x1c
15:06:25 <lambdabot> 28
15:06:30 <ihope> > '\28'
15:06:31 <lambdabot> '\FS'
15:06:44 <jethr0> > '\a'
15:06:44 <lambdabot> '\a'
15:07:18 <bolrod> > ['2','4']
15:07:19 <lambdabot> "24"
15:07:38 <bolrod> > chr 3
15:07:39 <lambdabot> '\ETX'
15:08:02 <bolrod> map chr [1..]
15:08:10 <bolrod> ok.. you say stop when you see the euro sign  ok?
15:08:17 <bolrod> ;)
15:08:21 <ihope> > map (map ord) ["Hello", "World!"]
15:08:22 <lambdabot> [[72,101,108,108,111],[87,111,114,108,100,33]]
15:09:50 <jethr0> > zipWith (\x y -> chr $ xor (ord x) (ord y)) "\CAN\DC2\b\FS\CAND\a\CAN\SYN\FS\DC3" $ cycle "pwd"
15:09:50 <lambdabot> "hello world"
15:10:05 <bolrod> omg
15:10:23 <jethr0> good old vigenere cipher
15:10:41 <jethr0> well, modulo xor :)
15:10:52 <bolrod> > mod 'a' 'b'
15:10:53 <lambdabot>  add an instance declaration for (Integral Char)
15:10:54 <lambdabot>   In the definition of `zsb': zsb = mod 'a' 'b'
15:10:54 <lambdabot>   In the definition of `ohb': ohb = let zsb = mod 'a' 'b' in take 2048 (show zsb)
15:10:55 <bolrod> > zor 'a' 'b'
15:10:56 <lambdabot>  Not in scope: `zor'
15:10:58 <bolrod> >xor 'a' 'b'
15:11:02 <bolrod> -.-
15:11:06 <bolrod> > xor 'a' 'b'
15:11:07 <lambdabot>  add an instance declaration for (Bits Char)
15:11:07 <lambdabot>   In the definition of `kjb': kjb = xor 'a' 'b'
15:11:07 <lambdabot>   In the definition of `bsw': bsw = let kjb = xor 'a' 'b' in take 2048 (show kjb)
15:11:15 <jethr0> > xor (ord 'a') (ord 'b')
15:11:15 <lambdabot> 3
15:11:21 <ihope> @help v
15:11:22 <lambdabot> let v = show v in v
15:11:39 <bolrod> :)
15:11:40 <bolrod> wheeee
15:11:43 <ihope> @v take 1 v
15:11:44 <lambdabot> "\""
15:11:50 <ihope> @v take 2 v
15:11:51 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:12:02 <ihope> That's more than two characters.
15:12:19 <bolrod> you sure? :)
15:12:37 <jethr0> > length "\"\\\"\\\\\\\"\\\\\\"
15:12:38 <lambdabot> 10
15:12:55 <bolrod> @v length $ take 2 v
15:12:56 <lambdabot> "\""
15:12:59 <bolrod> :p
15:13:05 <bolrod> v has many mysterious ways
15:13:26 <ihope> @v length
15:13:27 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:13:35 <ihope> ...?
15:13:47 <ihope> > length "\"\\\"\\\\\\\"\\\\\\"
15:13:47 <lambdabot> 10
15:13:52 <ihope> @v
15:13:52 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:14:06 <ihope> @v map succ v
15:14:06 <lambdabot> "\""
15:14:12 <bolrod> @v (+1)
15:14:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
15:14:16 <bolrod> @v (+5)
15:14:17 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:14:17 <jethr0> i generally don't question the wisdom of fixpoints
15:14:28 <jethr0> @v hello
15:14:28 <lambdabot> "\""
15:14:36 <jethr0> @v helloworld
15:14:36 <lambdabot> Exception: <<loop>>
15:14:43 <ihope> !
15:14:47 <ihope> !v hello world
15:15:02 <ihope> @v hello world
15:15:02 <lambdabot> Just 'J'
15:15:10 * jethr0 laughs
15:15:15 <bolrod> O_o
15:15:23 <ihope> @v hello world
15:15:23 <lambdabot> Just 'J'
15:15:31 <bolrod> @v
15:15:32 <lambdabot> "\""
15:15:36 <bolrod> its weird
15:15:45 <bolrod> it did different things before
15:15:49 <jethr0> @v explain your wicked ways
15:15:49 <lambdabot> Just 'J'
15:15:53 <bolrod> > let v = show v in v
15:15:54 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:15:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:15:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:15:54 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:15:56 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
15:15:58 <ihope> Maybe @v doesn't actually pay much attention to its arguments.
15:15:59 <bolrod> things like that
15:15:59 <lambdabot> [6 @more lines]
15:16:11 <jethr0> @v
15:16:11 <lambdabot> "\"#$%&'()*+,\""
15:16:18 <jethr0> you might have a point there
15:16:39 <bolrod> hehe :)
15:16:51 <bolrod> maybe they just grabbed all the outputs it generated
15:16:55 <bolrod> and choose a random one
15:17:01 <bolrod> (from the countless ones tried)
15:17:11 <ihope> @listcommands quote
15:17:11 <lambdabot> Unknown command, try @list
15:17:15 <ihope> @list quote
15:17:16 <lambdabot> quote provides: quote ghc fortune yow arr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw
15:17:21 <ihope> Yep, v's one.
15:17:30 <jethr0> @palomer
15:17:30 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
15:17:30 <bolrod> @fortune
15:17:31 <lambdabot> Ogden's Law:
15:17:31 <lambdabot> 	The sooner you fall behind, the more time you have to catch up.
15:17:34 <ihope> @yhjulwwiefzojcbxybbruweejw
15:17:34 <lambdabot> "\"#$%&'()*+,\""
15:17:40 <ihope> @brain
15:17:40 <lambdabot> It is here that my cheap workforce of trained iguanas will work
15:17:40 <lambdabot> night and day to make our shoes to my exacting specifications!
15:18:01 <jethr0> @brain
15:18:01 <lambdabot> But where will we find an open tattoo parlor at this time of night?
15:18:26 <bolrod> lynx -head -dump http://slashdot.org|grep X
15:18:29 <bolrod> is also funny ;)
15:20:35 <Taral> Setup.lhs: MissingH.cabal:82: Parse of field 'extensions' failed:
15:20:39 <Taral> That's not good.
15:24:01 <Taral> what's wrong with haskell.org?
15:24:52 <bolrod> nothing
15:24:56 <bolrod> its perfect
15:25:01 <palomer> it's down for me
15:25:24 <Taral> % nc -v www.haskell.org 80
15:25:28 <Taral> bugs.haskell.org [128.36.229.215] 80 (www) open
15:25:28 <Taral> GET / HTTP/1.0
15:25:28 <Taral> Host: www.haskell.org
15:25:31 <Taral> and no response
15:25:43 <bolrod> yap
15:26:11 <bolrod> its just a tad slow
15:30:25 <hyrax42> down here
15:30:26 <hyrax42> or was
15:30:34 <hyrax42> I gave up and went with google cache
15:40:35 <SamB> maybe someone is trying to compile JHC's libraries on it :-)
15:41:56 <binary42> I'm having haskell.org issues also. Just pointed a few people there and got a bunch of complaints.
15:46:52 * dcoutts tries to restart apache on haskell.org
15:54:48 * dcoutts restarts apache on haskell.org
15:56:23 <dcoutts> we often get this propblem with hanging connections titing up all the 150 httpd processes
15:56:37 <dcoutts> so no new connections are possible once we hit that limit
15:56:52 <binary42> dcoutts: thanks for the quick work!
15:56:54 <SamB> eivuokko: looks like they switched over to .NET
15:56:58 <dcoutts> I don't know why the connections are all being tied up
15:57:13 <dcoutts> I've seen it happen before
15:57:28 <jethr0> shouldn't there be a timeout for connections?
15:57:35 <dcoutts> should be
15:57:36 <jethr0> especially since http is stateless
15:58:08 <dcoutts> "Timeout 300" apparently
15:58:11 <bdash> dcoutts: if the client uses HTTP keepalives, there is a relatively high timeout (20 seconds or so by default)
15:58:15 <dcoutts> I'm not sure I believe it
15:58:34 <dcoutts> KeepAlive Off
15:58:40 <dcoutts> that's the current setting
15:58:42 <SamB> oh, that sounds bad!
15:58:48 <SamB> why don't you make them timeout sooner?
15:58:56 <bdash> dcoutts: if you enable the Apache server-status page it should give you an idea of what each handler is doing while hung
15:59:00 <dcoutts> perhaps we should
15:59:17 * dcoutts is not actually http admin on haskell.org, he merely has sudo access
15:59:20 <SamB> 300 whats?
15:59:53 <SamB> dcoutts: well, give the HTTP admin a good whack, then ;-)
15:59:54 <dcoutts> bdash, yes I've done that, but when we've got 150 http processes running then I can't get to http://localhost/server-stauts !
16:00:02 <dcoutts> SamB, seconds
16:00:10 <bdash> dcoutts: hah, good point :)
16:00:21 <dcoutts> bdash, as I recall it was an errant web bot
16:01:10 <SamB> 300 is awfully long
16:01:14 <dcoutts> mmm
16:01:29 <SamB> > 300/60 
16:01:30 <lambdabot> 5.0
16:04:27 <bdash> SamB: it's set to 300  by default because "there may still be odd places in the code where the timer is not reset when a packet is sent." (from Apache docs)
16:04:57 <SamB> hmm. shouldn't be sending, then!
16:05:00 <SamB> should be wrapped!
16:13:45 * ihope____ is an underscore collector
16:33:03 <ihope> data RandomGenT = RandomGenT {tNext :: (Int, RandomGenT), tSplit :: (RandomGenT, RandomGenT), tGenRange :: (Int, Int)}
16:33:16 <ihope> Is that a good "universal generator"?
16:38:30 <ihope> My other one is data RandomGenM where RandomGenM :: RandomGen g => g -> RandomGenM
16:38:51 <ihope> There's also RandomGenI, but that didn't really "make it".
16:54:26 <ihope> data RandomGenI g = {iNext :: g -> (Int, g), iSplit :: g -> (g, g), iGenRange :: g -> (Int, Int), iGen :: g}
16:59:48 <ihope> instance RandomGen (RandomGenI g) where next g = (r, ni) where (r, ng) = iNext g (iGen g); ni = g {iGen = ng}; split g = (g {iGen = ng1}, g {iGen = ng2}) where (ng1, ng2) = iSplit g (iGen g); genRange g = iGenRange g (iGen g)
17:00:44 <palomer> @palomer
17:00:45 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
17:00:56 <palomer> classic.
17:05:31 <Cale> @palomer
17:05:32 <lambdabot> Hrmph, looks like I killed the channel
17:05:33 <ihope> Wow, I got it right on the second try, and the first try didn't count.
17:05:37 <Cale> @palomer
17:05:37 <lambdabot> Pfft
17:05:39 <Cale> @palomer
17:05:39 <ihope> @palomer
17:05:39 <lambdabot> Soylent green is people
17:05:39 <lambdabot> Soylent green is people
17:05:44 <Cale> @palomer
17:05:44 <lambdabot> Category theory is the Paris Hilton of mathematics
17:05:56 <ihope> Soylent green... is PEOPLE?
17:06:04 <palomer> sad, but true
17:06:19 * palomer doesn't know why he keeps checking the summer of code website since he knows he's not going to get it
17:06:42 <hyrax42> when are answers
17:08:27 <palomer> today
17:08:29 <palomer> sometime
17:08:42 <hyrax42> well good luck :)
17:08:45 <hyrax42> what is your project
17:10:46 <hyrax42> palomer: in montreal, right?
17:10:59 <palomer> yeah
17:11:02 * hyrax42 whoises
17:11:11 <palomer> graphical type analysis
17:11:41 <hyrax42> hrmm I need to learn a lot
17:12:06 <hyrax42> for inference?
17:12:15 <palomer> yeah
17:17:24 <psnl> palomer: graphical?
17:23:15 <ihope> I think RandomGenI is faster than RandomGenT.
17:24:01 * psnl wonders what cabal means when it talks about "plugins"
17:25:02 <mlh> is anyone running the latest winhugs?  i get a error opening Types.dll when trying any demo code
17:26:09 <palomer> psnl: you'd be able to see the types of subexpressions graphically
17:26:18 <dcoutts> psnl, the hs-plugins package probably
17:27:27 <Cale> palomer: would you render the expressions and types as graphs, and then put arrows between them to show which parts of the graph mapped to which parts of the type?
17:28:38 <palomer> http://www.magnesium.net/~palomer/graphical/ <--this is what I would do
17:30:08 <Cale> ah, cool
17:30:24 <palomer> the cursor should be on (Int -> Int) -> (Int -> Int)
17:30:34 <palomer> (and the corresponding subexpression is highlighted)
17:30:43 <palomer> but doing that with ksnapshot would have been impossible
17:34:43 <psnl> dcoutts: ta
17:43:22 <sjanssen> @yow
17:43:23 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
17:43:23 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
17:52:30 <araujo> Hello
17:52:42 * araujo back from dinner
17:55:24 * araujo happy because his teacher let him to use Haskell
17:56:55 <Cale> @yow
17:56:56 <lambdabot> Now I'm having INSIPID THOUGHTS about the beautiful, round wives of
17:56:56 <lambdabot> HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS and being approached
17:56:56 <lambdabot> by SMALL BOYS selling FRUIT ...
17:57:37 <sjanssen> bah, entirely too bizarre
17:58:32 * araujo will try to do an algorithm for determinists automata optimization
17:59:04 <araujo> @keal
17:59:04 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
17:59:18 <ihope> Heh.
17:59:25 <araujo> :-)
18:02:07 <sjanssen> evaluating expressions is ALL haskell does????? -- a favorite keal-ism
18:02:17 <araujo> haha
18:02:31 <araujo> i think i remenber him saying something like that indeed.
18:02:39 <dons> yeah, that's one of the best.
18:02:46 <araujo> dons!!!
18:02:51 <sjanssen> because it's true, and it's a good thing.  But the disbelieving tone is awesome
18:03:06 * araujo wonders if dons added that one to lambdabot db
18:03:12 <dons> and its hard to work out what he thinks its supposed to do instead.
18:03:17 <sjanssen> araujo: it's in there
18:03:26 <araujo> sjanssen, :-)
18:03:51 <dons> araujo: yeah, all the keal gold is in lambdabot/Plugin/Quote/Text.hs, iirc.
18:04:46 * araujo checks for fun
18:07:36 <mux> any FreeBSD users that'd like a port for Data.ByteString ?
18:14:02 <mux> bleh, you all suck then! :-)
18:14:34 <sjanssen> mux: if I used FreeBSD, I would be interested.  Does that make you feel better?
18:14:42 <araujo> :-)
18:14:58 <mux> sjanssen: much better, thanks :D
18:15:05 <araujo> I don't use FreeBSD, though i still support the idea mux 
18:15:38 <araujo> The more Haskell, The better :-)
18:15:56 <mux> well, in case someone will read this in his log and will need it: 
18:16:00 <mux> http://mu.org/~mux/hs-fps.tar.gz
18:16:07 <mux> I'll commit it tomorrow, most likely
18:16:38 <mux> dons: would be nice if you could release 0.7 with hGetLines
18:16:48 <mux> and the lazy stuff
18:17:30 <dons> it'll be soon. a couple of weeks.
18:17:35 <mux> cool
18:17:41 <dons> and we will push it into fptools too, hopefully
18:18:13 <mux> I love the idea of a short-term port, as soon as GHC 6.6 is out, I'll be glad to kill it
18:18:24 <mux> one less thing to care about
18:18:50 <dcoutts> do we need hGetLines? shouldln't one just use the .lazy module: liftM lines . hGetContents
18:19:04 <mux> dons said it's faster
18:19:21 <dons> dcoutts: even lazy will have to refragment the chunks into line pieces
18:19:38 <dcoutts> dons, sure, so we do the same work either way
18:19:39 <dons> so better to read line-sized chunks to start with.
18:20:00 <dons> also, we want to avoid hGetContents, since it needs to realloc
18:20:01 <dcoutts> na, that's just doing the work in the buffer rather than in the bytestring
18:20:25 <dcoutts> I mean the .Lazy module gives you effecient hGetLines
18:21:02 <dcoutts> I know it's not effecient to implement in ByteString in terms of hGetContents & lines
18:21:10 <dcoutts> but with .Lazy it is
18:21:13 <dons> oh, that's right. we don't have a lines in .Lazy yet.
18:21:19 <dons> hang on, we do now. in Char8
18:21:31 <mux> yeah I'm using this one
18:21:42 <dcoutts> right, so I'm suggesting that we don't need hGetLines in the ByteString module
18:21:53 <dons> hmm. let me ponder the code...
18:21:54 <dcoutts> that people who want that can use .Lazy
18:22:22 <dons> indeed. i added it for a particular problem people were having with strict hGetContents (i.e. the realloc conks out at around 1/2 ram size)
18:23:11 <dcoutts> that makes sense
18:23:21 <dons> yeah, lines . hGetContents in .Lazy seems about the same. maybe a little more work recalculating the chunk sizes.
18:23:28 <dcoutts> so do you think we still want that special case?
18:23:37 <dons> the strict hGetLines is equivalent to a fused lazy lines =<< hGetContents, I think.
18:23:38 <dcoutts> I don't think there's any more work
18:23:50 <dcoutts> you've got to scan for '\n' either way
18:23:57 <dcoutts> slicing is cheep
18:24:06 <dcoutts> and it means fewer MVar locing ops on the Handle
18:24:09 <dons> right. that's the extra work. it may be minimarl
18:24:13 <dons> ah, good point!
18:24:23 <dcoutts> one per 64k rather than per line
18:25:03 * dcoutts really goes to bed
18:25:05 <dcoutts> ;-)
18:25:05 * mux nods, using hGetContents instead of reading line by line tremendeously helped performance
18:25:09 <dons> well, its a way to do lazy io while keeping the strict, flat representation, which seems useful. hGetLines pieces can be passed to C still.
18:25:30 <mux> dcoutts: nite
18:25:48 <dons> ok. more stuff on the todo lsit
18:26:06 <dcoutts> dons, perhaps you want an unchunk op: Lazy.ByteString -> ByteString
18:26:10 <dcoutts> er
18:26:16 <dcoutts> Lazy.ByteString -> [ByteString]
18:26:52 <dcoutts> if you want the strict flat representation
18:27:18 <dcoutts> and that'd work for any Lazy.ByteString, not just hGetContents >>= lines
18:27:27 * dcoutts really really goes to bed
18:27:29 <dons> yeah, it may be needed, if you want to mix lazy bytestrings with C or other games.
18:27:39 <dons> good idea.
18:30:55 * mux is glad that this discussion happened
18:31:52 <mux> dons: oh, btw, if you'd like to maintain that port yourself, I'll be happy to pass the maintainership to you
18:33:24 <SamB_XP_> C is a game?
18:33:36 * SamB_XP_ looks for the cheat codes
18:34:18 <dons> mux, oh, probably better you do, since I don't use FreeBSD these days.
18:34:31 <mux> as you wish
18:34:40 <dons> when its comitted, let me know, and i'll put a note on the fps home page
18:35:19 * monochrom sends SamB_XP_ "Numerical Cheat Code in C"
18:35:30 <mux> dons: sure
18:40:37 <adu> lol
18:41:54 <ihope> C has cheat codes?
18:42:11 <SamB> ihope: don't all games?
18:42:26 <ihope> Haskell doesn
18:42:31 <ihope> 't have cheat codes.
18:42:37 <ihope> It's in godmode all the time ;-)
18:42:46 <monochrom> Perhaps Haskell isn't a game.
18:43:06 <SamB> what do you think unsafePerformIO is, if not a cheat?
18:43:12 <ihope> Hmm...
18:43:18 <ihope> Good point.
18:43:37 <monochrom> Perhaps Haskell is a productivity application, like Firefox, not a game.  Ever heard Firefox had cheat codes? :)
18:44:59 <SamB> what about them about: things?
18:45:03 <dons> so Haskell has easter eggs then?
18:45:15 <SamB> hmm. I dunno.
18:45:25 <SamB> @hoogle egg
18:45:25 <lambdabot> No matches found
18:45:27 <monochrom> "My brain has exploded" is easter egg.
18:45:32 <dons> do big programs still have easter eggs? or was that a 90s/macintosh thing.
18:45:34 <SamB> hehe
18:45:34 <dons> ah, yes!
18:45:56 <SamB> big programs tend to have them, I think
18:46:02 <SamB> at least, occasionally
18:46:13 <SamB> but maybe well hidden
18:46:29 <dons> i remember my 68k mac would display funny faces in the monitor control panel if you held down some funny combination of keys
18:46:32 <SamB> excel did at least have a flightsim
18:46:50 <dons> ah yes, that's probably the most famous.
18:47:19 <mux> another version of excel had a doom-like thing
18:47:22 <mux> without enemies
18:47:26 <SamB> I wouldn't be surprised if Winamp had something
18:50:02 <SamB> without enemies?
18:50:11 <SamB> isn't doom an FPS?
19:15:33 <sjanssen> dons: you've got "do we need elems" in TODO -- what do you mean by this?
19:16:42 <dons> dcoutts: wondered if elems had any meaningful use  in the ByteString context.
19:16:59 <dons> we'd probably just write a map instead
19:17:31 <dons> he's looking to normalise the api.
19:17:32 <sjanssen> still don't know what you mean by elems, is it some prelude function I don't know?
19:17:37 <sjanssen> @hoogle elems
19:17:38 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
19:17:38 <lambdabot> Data.Array.elems :: Ix i => Array i e -> [e]
19:17:38 <lambdabot> Data.IntMap.elems :: IntMap a -> [a]
19:17:55 <sjanssen> okay, so elements in order
19:17:55 <dons> its really elems from Data.PackedString, isn't it?
19:18:07 <dons> yeah, but its not unpack.
19:18:13 <dons> making it kind of silly.
19:18:33 <dons> you'd either use unpack, or do a map, to get at the elements of the string, i think.
19:19:03 <dons> unpack is really our elems, I'd think. going by the type of Data.Array.elems
19:20:10 <dons> yeah, i'm going to remove elems.
19:21:50 <sjanssen> I agree that we ought to have unfoldr
19:21:56 <sjanssen> has anyone tried to write it?
19:21:59 <dons> yes. me :)
19:22:08 <dons> its O(n^2), but we should have it nonetheless
19:22:27 <dons> you can adapt unfoldrN, to get back the unbounded form. it needs to do a realloc (i.e. uses generate)
19:23:12 <dons> feel free to hack on anything you see in the todo list, btw.
19:23:17 <palomer> dons: any word as to when the results are going to be released?
19:23:19 <sjanssen> I think with the correct growth heuristic, it shouldn't be O(n^2(
19:23:20 <dons> or suggest api clean ups too.
19:23:34 <dons> palomer: SoC results. on the 23rd, PDT. 
19:23:43 <dons> we won't announce till google posts them on code.google.com/sco
19:23:50 <dons>  /soc i mean
19:24:07 <dons> sjanssen: ah, ok. maybe maybe.
19:24:15 <dons> do it like hGetContents, you mean?
19:24:50 <sjanssen> I'm not exactly familiar, it doubles the size each time?
19:24:55 <dons> yeah.
19:25:20 <dons> i'd liek someone to adapt the Search.hs plugin in lambdabot to return the time for cities you get if you type "time in <city>" into google.
19:25:25 <dons> any takers? its about 10 lines or so.
19:26:55 <dons> palomer: so in about 15-20 hours.
19:27:12 <dons> depending on how long google takes to colate its list
19:28:56 <palomer> the suspense is killing me!
19:31:06 <sjanssen> dons: yeah, with doubling the complexity is linear (if I've done the math in my head correctly)
19:32:54 <dons> yeah, that seems right. when i wrote this i didn't consider a non-cons'ing version.
19:33:32 <dons> in which case we can ditch unfoldrN all together.
19:40:52 <dons> make sure to stick a    test in Properties.hs too.
19:43:36 <sjanssen> how should one test higher order functions?  Can QuickCheck generate these?
19:43:55 <dons> yes . its really cool
19:44:10 <sjanssen> that is impressive
19:44:12 <dons> it uses the coarbitrary instance to generate random functions for your type.
19:44:27 <dons> there's a big chunk of the QC paper devoted to this problem
19:44:35 <dons> anyway, just check the 'map' property for the idea.
19:46:44 <ihope> No #haskell-es, eh?
19:46:53 * ihope claims ##haskell-es
19:47:37 <dons> oh, we do don't we?
19:47:40 <dons> ?seen lambdabot
19:47:40 <lambdabot> Yes, I'm here. I'm in #osflash, #scannedinavian, #haskell.es, #haskell.it, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #ScannedInAvian
19:47:46 <dons>  #haskell.es
19:48:02 <ihope> Oh.
19:48:59 <dons> oh, looks like i've forgotten #haskell.se
19:49:30 <ihope> Is that Swedish?
19:49:32 <dons> @join #haskell.se
19:49:34 <dons> yeah
19:49:46 <ihope> I know exactly one word of Swedish.
19:50:06 <mlh> smorgasbord?
19:50:17 <ihope> Is that Swedish?
19:50:25 <mlh> think so
19:50:35 <ihope> Well, I didn't know it was Swedish, so it doesn't count :-)
19:50:39 <dons> skul, skul, skul. is that swedish, or norwegian?
19:50:45 <ihope> The one word I know is "lagom".
19:51:09 <mlh> heh modulo umlauts and whatnot of course
19:52:26 <ihope> My wild guess puts it at "smorg√•sb√∂rd".
19:52:34 <ihope> How far off was I?
19:53:19 <ihope> Hmm... it seems I was pretty close, actually. The umlaut thingy is over the wrong o.
19:55:06 <sjanssen> GHC does the worker wrapper transformation when it sees that a recursive function's argument doesn't change -- does it matter whether an unchanging argument is after a changing one?
19:56:59 <skew> what's that about the argument not changing?
19:58:12 <skew> when it's recursing at the same type?
19:58:40 <sjanssen> take map for example. map f (x:xs) = f x : map f xs.  GHC will turn that into "map f z = map' z where map' (x:xs) = f x : map' xs"
19:59:02 <dons> sjanssen: not sure about the ordering. but you can always unfold yourself.
19:59:09 <dons> check the Core?
19:59:30 <sjanssen> dons: I'll probably do that
19:59:47 <sjanssen> I bet the core for Data.ByteString is huge
20:00:12 <skew> I think GHC does that anyway
20:00:14 <dons> its worth timing a couple of variations, if this is an fps function, some seemingly good worker/wrapper splits aren't as fast as others.
20:00:16 <skew> at least with numeric functions
20:00:33 <dons> sjanssen: yeah it is. but you can see how its inlined in a user's module.
20:00:52 <dons> if you're inlining the function (which seems to be a good idea in fps)
20:10:18 <lks> alguem aew tem scan pra explora o php injectiOn
20:10:19 <lks> =x
20:12:04 * ihope no entiende
20:41:26 <sjanssen> dons: in my Properties.hs I wrote unfoldr   :: (W -> Maybe (Word8, W)) -> W -> [Word8]
20:42:48 <sjanssen> however, I get errors about no instance for (ModeledBy (a2 -> Maybe (Word8, a2)) (W -> Maybe (Word8, W)), ModeledBy a2 W).  I'm lost
21:32:51 <dons> sjanssen: you'll need an instance for Maybe, I think.
21:33:11 <dons> just pushed a bunch of patches.
21:34:11 <dons> my life's become so much easier since i aliased cabal build commands to c, b and i :)
21:36:43 <sjanssen> I think automatically deriving functions for unfoldr is dangerous anyway
21:36:56 <sjanssen> what if the function generated always returns Just?
21:37:01 <dons> possibly, yeah.
21:37:19 <dons> a couple of reasonable functions would be ok. and testing null generators
21:37:49 <sjanssen> also, I suggest we leave unfoldrN in, it will be useful when we write Lazy.unfoldr
21:37:58 <dons> for chunks. ok.
21:38:13 <dons> if it has a valid use, then we can certainly keep it
21:38:38 <sjanssen> and I want to change unfoldrN's type to Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
21:38:49 <sjanssen> that's also necessary to reuse it for .Lazy
21:38:51 <dons> ?type Data.ByteString.unfoldrN
21:38:52 <lambdabot> forall a.
21:38:52 <lambdabot>           Int -> (a -> Maybe (Word8, a)) -> a -> Data.ByteString.ByteString
21:39:06 <dons> @type unfoldr
21:39:07 <sjanssen> if there is more "seed" left, return it also
21:39:07 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
21:39:15 <dons> yeah, duncan mentioned this. 
21:39:26 <dons> so go for it.
21:40:18 <dons> i should set the bytestring-commits mailing list up again.
