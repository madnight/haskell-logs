00:17:19 <dons> oh, /me discovers a strange new world of type errors when accidently building with hugs by mistake.
00:17:27 <dons> ERROR "dist/build/Data/ByteString.hs":1048 - Type error in conditional
00:17:27 <dons> *** Expression     : if q == nullPtr then [PS x (s + n) (l - n)] else do {...}
00:17:28 <dons> *** Term           : do {...}
00:17:35 <dons> I got scared that ghc had gone crazy!
00:20:44 <sjanssen> is the behavior for getChar/putChar for characters greater than 255 defined anywhere?
00:21:50 <norpan> no
00:29:50 <ibid> sjanssen: i believe the behaviour of both with respect to character encodings is implementation defined
00:30:05 <dons> sjanssen: hmm. yes. impl. defined. if you follow the ghc src you end up with:
00:30:06 <dons> primop  ReadByteArrayOp_Char "readCharArray#" GenPrimOp 
00:30:06 <dons>    MutByteArr# s -> Int# -> State# s -> (# State# s, Char# #)
00:30:07 <dons>    {Read 8-bit character; offset in bytes.}
00:30:13 <dons> which gives you your info
00:30:36 <audreyt> "implementation defined" is another name for "underspecified", which is another name for "broken" :)
00:30:43 <norpan> ghc will just strip the lower 8 bits
00:30:58 <norpan> for putChar
00:31:09 <sjanssen> and getChar assumes 8 bits characters
00:31:13 <norpan> indeed
00:32:12 <norpan> which is a sad state of affairs
00:33:24 <norpan> reminds me of a haskell program we had at work that worked much slower when we went to ghc 5
00:33:46 <flux__> haskell has such a great state of matters, being very closely full specified (?), so it is sort of sad if something is unspecified :)
00:33:58 <flux__> s/full/&y/
00:34:01 <Cale> Well, with UTF-8, things work okay, at least.
00:34:03 <sjanssen> norpan: from GHC 4?
00:34:12 <dons> well, its supposed to read unicode
00:34:21 <norpan> it turned out that someone had made an array (minBound, maxBound) indexed with chars
00:34:24 <dons> since its a Char
00:34:52 <norpan> the problem is, what is unicode when dealing with bytes
00:35:00 <Cale> I can enter Linear B characters, and read them back, but applying show to the string results in control codes.
00:36:13 <ibid> audreyt: there are perfectly good and valid reasons for underspecification
00:36:50 * Cale doubts anyone will be able to read this: 𐃞𐃮𐃶𐃌
00:36:56 <shapr> How come slashdot never talks about type theory?
00:37:13 <audreyt> ibid: I doubt those reasons apply to this specific case
00:37:43 <dons> i love squashing leaks of all kinds
00:38:15 <norpan> Cale: four unknown characters :)
00:38:26 <Korollary> shapr: how come anybody ever talks about type theory?
00:38:37 <audreyt> what is this type theory thing you are talking about?
00:38:39 <Cale> norpan: You'd need a font for Linear B.
00:38:40 <audreyt> it's all Greek to me.
00:38:52 <norpan> linear b, it's all coptic to me
00:39:11 <dons> hehe audreyt
00:39:13 <Cale> hehe
00:40:04 <norpan> oh, linear b is not in the base plane
00:40:25 <norpan> plane 1
00:41:33 <Cale> heh, I should do a newtype of Integer with a show instance that outputs in Aegean numbers
00:42:46 <norpan> 𐄉𐄌𐄏
00:43:11 <Cale> 3 6 9
00:43:16 <norpan> good!
00:43:25 <norpan> that was my visa pin code
00:44:00 <norpan> well, i need to work now
00:44:34 <kzm> norpan, what's that?
00:44:52 <norpan> kzm: aegean numbers
00:45:02 <norpan> in UTF-8
00:45:10 * kzm just got char codes 0x0109 etc
00:45:15 <Cale> 𝐇𝐞𝐥𝐥𝐨. 𝐂𝐚𝐧 𝐲𝐨𝐮 𝐫𝐞𝐚𝐝 𝐭𝐡𝐢𝐬?
00:45:19 <kzm> I guess I must get a better font.
00:47:11 <norpan> Cale: yes i can
00:47:21 <ibid> audreyt: agreed, but your statement was universal :)
00:47:48 <norpan> anyway, back to work
00:48:03 <norpan> kzm: i recorded a lot of changes to the UTF-8 stuff btw
00:49:43 <audreyt> ibid: well, I meant exists where I meant forall
00:49:52 <audreyt> sorry about that. :)
00:50:13 <kzm> Great, norpan!  I'm currently pulling in dons's 0.6 changes, and will merge yours later.
00:55:10 <norpan> wlil need a lot of cleanup of course
00:55:15 <norpan> streamlining
00:56:47 <kowey> hey all, anyone have an idea yet where Haskell Workshop 2007 (i.e. next year) might be?
00:59:12 <wolverian> what, it's 2006 already?
01:00:01 <dons> sjanssen, dcoutts: the ++ and concat issues seem to have gone. I think it may have been hiding a space leak in split that I was worried about. now its all good.
01:01:18 <dcoutts> dons, you saw what my real bug was? :-)
01:01:42 <dons> yeah
01:01:44 <dons> fixed that too
01:01:45 <dcoutts> dons, but if it made you find a cunning optimser problem then it's worth it. ;-)
01:01:54 <dons> that's true.
01:01:58 <dons> very good actually
01:02:08 <dcoutts> dons, you you fixed the x86_64 native code generator?
01:02:20 <dons> you could try the current darcs fps to make sure all the new ffi types go through on your amd64 thingy.
01:02:29 <dons> well, I'm using CInt everywhere
01:02:36 <dcoutts> oh right
01:02:37 <dons> no assumptions about Int -> int
01:03:07 * dons happily watches the entire fps benchmark suite churn through 250M arrays
01:03:15 <dcoutts> :-)
01:03:52 * dcoutts wants to try it with lazy streams of chunks
01:04:41 <dons> making things tail recursive is good for you stack :) (too space leaks I spotted)
01:04:48 <dons> two
01:05:52 <dcoutts> yes I guess you'd notice if there were space leaks when using 250M ByteStrings
01:06:09 <dons> that's right.
01:06:43 <dons> split and elemIndices. the first conked out at 60M, the second at 120M. but tail recursion and they both run fine now.
01:06:49 * dons is a big fan of stress testing
01:06:52 <dcoutts> great
01:07:03 <dons> now we try 0.5G
01:07:19 * dcoutts is a big fan of dons being a big fan of stress testing
01:07:58 <dons> I think an evil QC that generated enormous data quantities might be useful
01:08:00 * norpan is a big fan of curling
01:08:19 <norpan> oh and stress testing
01:08:43 <dcoutts> QC?
01:08:56 <dons> QuickCheck
01:09:04 <dons> random, massive data amounts.
01:09:11 <dons> instead of little strings
01:09:12 <norpan> in industry, qc means quality control
01:09:41 <boegel> norpan: but that doesn't happen anymore, most of the time
01:09:57 <boegel> it's cheaper to replace non-working units than to check every outgoing unit
01:09:58 <norpan> so if you have good qc you don't need good qa
01:10:16 <eivuokko> Hehe
01:10:19 <boegel> that's why my parents are testing their 4th dvd-recorder in a year time
01:11:46 <dons> i guess there's a point of intersection where evenutally the quality gets so poor that checking becomes a better option.
01:11:55 <dons> so the idea would be to keep the quality reasonable
01:12:29 <norpan> the problem with working in industry is all the customers
01:12:41 <norpan> without them it would be no problem to have good quality
01:12:55 <dons> hmm, now we write a QuickCheck that sends random patches to people's project, and have them complain when it doesn't work (then QC sends out another random patch). the cost of replacing the broken code would be a lot cheaper than hiring a clever person to verify the code in the first place
01:13:13 <dons> since you move the cost of checking onto the end user
01:13:28 <dons> which sucks for them
01:14:03 <dcoutts> dons, did you get a chance to see the patch I sent?
01:14:13 <dons> yeah, I walked through it.
01:14:19 <dons> i like very much where you're headed   with it
01:14:35 <dcoutts> oh good (I hope I have enough time to work more on it)
01:14:37 <norpan> wow, groupBy was really slow on my UTF-8, next target for optimization
01:14:58 <dons> groupBy is one of the poorest in ByteString too
01:16:16 <dons> words is the worst though
01:16:30 <dons> since it uses a higher-order pure haskell tokens to break things up
01:16:42 <dons> hmm. I could make it first order, that'd halve the running time. 
01:16:45 * dons ponders
01:18:25 <norpan> implementation of groupBy was by far worse than (map pack . groupBy c . unpack) :)
01:18:32 <norpan> at least time-wise
01:19:22 <dons> oh, that's not good. yes.
01:19:31 <norpan> spacewise it should be ok :)
01:20:12 <norpan> i think i have a strictness problem
01:20:22 <dons> you need a spanking?
01:20:44 <norpan> mmmm
01:20:48 <dons> (too much or too little strictness?)
01:20:54 <norpan> too much
01:21:04 <dons> it happens sometimes
01:21:09 <dons> but not too often, I guess.
01:21:11 <norpan> easy to get too much when dealing with pointers and IO
01:21:31 <norpan> a <- ...; as <- ...; return a:as
01:21:36 <dons> oh, no good.
01:21:40 <dons> need to make it tail recursive
01:21:42 <norpan> when the two actions are independant
01:21:59 <dons> i had just that problem with the two functions that were overflowing for me
01:22:12 <dons> then I realised theyw were pure, and that a : foo was ok.
01:22:31 <norpan> well, they are pure, sort-of, they only do peek
01:22:46 <Cale> unsafeInterleaveIO
01:23:06 <norpan> that's one alternative
01:23:11 <dons> a nice, scary idea
01:23:23 <Cale> well, it'll give you back laziness :)
01:23:27 <norpan> another is to make them pure using unsafePerformIO
01:23:39 <Cale> that's probably scarier :)
01:23:43 <dons> ?karma+ sjanssen -- sort of 0.5G = 4.3s
01:23:44 <lambdabot> sjanssen's karma raised to 7.
01:23:53 <norpan> i don't know what else to do
01:24:14 <dons> a pure peek, is that an option I wonder?
01:24:21 <dons> a la unsafeIndex
01:25:22 <eivuokko> A lot of stuff could be made pure if one used type tricks like Oleg's IO regions.
01:25:25 <Cale> unsafeInterleaveIO sounds like it ought to be reasonably safe here, though I don't really know the context too wekk
01:25:27 <Cale> well*
01:25:52 <norpan> the context here is 10:13 < ale_> hi
01:25:55 <norpan> huu
01:26:02 <dons> on immutable strings, peek should be pure, right?
01:26:03 <norpan> http://norpan.org/~martin/fps-i18n/Data/ByteString/UTF8.hs
01:26:04 <norpan> i mean
01:26:18 <norpan> dons: right up to the point where they are garbage collected :)
01:26:21 <dons> it just that the guarantee that you're not also using poke is something you have to check
01:27:10 <dons> well, anyway, that's what index is for, to hold that ForeignPtr
01:27:20 <dons> interesting probelm
01:27:45 <dons> ok. so now we try 1G
01:27:55 <eivuokko> Hmm.
01:28:16 <norpan> if i do something like unpack and it unpacks lazily, then the bytestring is garbage collected (can it be)?
01:29:19 <eivuokko> Don't you also need to check that two peek's can't get same Ptr (or whatever is left after optimisations) don't get merged from two bytestrings (in case first is deallocated and second allocated) via inlining allocator.
01:29:40 <eivuokko> Well, in theory.
01:30:37 <eivuokko> That sort of stuff is always a bit hazy to me.  Haskell spec doesn't really mention how far transparency goes, I think.
01:32:14 <Cale> norpan: it would probably get GC'd once you're done, so long as nothing else was using it.
01:32:22 <dons> once you've done, right.
01:32:54 <dons> eivuokko: yeah, I think with the wrong inlining (some key functions using unsafePerofmrIO have to be NOINLINE) otherwise you can get into trouble
01:33:01 <Cale> whereas a String will get GC'd incrementally as you're finished with each Char
01:36:48 <Cale> Something you could add to Data.ByteString is an unfoldr which uses Fibonacci growth and doesn't require a maximum length.
01:37:15 <dons> hmm.
01:37:25 <dons> more info please?
01:37:26 <dons> :)
01:37:40 <eivuokko> info==patch ?
01:37:48 <dons> I'm trying to imagine how I can do anything infinite with a ByteString.
01:38:34 <dons> we don't have infinite unboxed arrays for a reason, right?
01:38:45 <Cale> well, when you'd otherwise run off the end of the ByteString, you reallocate
01:39:04 <dons> hmm. hGetContents style.
01:39:14 <eivuokko> Yeah.
01:39:24 <Cale> but don't do it one byte at a time
01:39:35 <dcoutts> dons, with a ByteString.Lazy !
01:39:47 <dons> a lazy bytestring could do it, yep
01:40:10 * dcoutts goes to a supervision
01:40:20 <sjanssen> what would a lazy bytestring be?  [ByteString] ?
01:40:33 <norpan> i suppose
01:40:44 <dons> still not sure I can work out when I'm about to run off the end of the ByteString
01:41:01 <dons> I have to know the length of the ByteString to return it to the user. 
01:41:21 <dons> its not like I can return a unevaluated bytestring that will get forced by a later poke
01:41:25 <dons> s/peek/
01:42:52 <dons> hehe 22115 dons      18   0 1976m 1.6g  752 D  4.0 82.5   0:44.67 bench
01:43:29 <Cale> :)
01:50:32 <norpan> re UTF8, how would you fix for instance the rawIndices function
01:59:46 <dcoutts_> sjanssen, norpan. Yes LazyByteString = [ByteString] (or in a newtype wrapper)
02:00:32 <dcoutts_> a lazy list of big chunks, say 4k 16k something like that
02:00:57 <dcoutts_> so we get the speed advantages of the packed arrays
02:01:25 <dcoutts_> and the lazyness advantage of not having to have the entire string in memory at once
02:01:34 <dcoutts_> just a few largeish chunks at a time
02:02:10 <dcoutts_> that's what block based / streaming things do
02:02:21 <dcoutts_> but with much more explicit buffer control
02:02:37 <dcoutts_> ie it's harder to do it that way
02:05:04 <pesco> Do I smell vlists? ;)
02:05:18 <dcoutts_> pesco, no, that's a little different
02:05:31 <dcoutts_> that's more of an alternative to []
02:05:34 <ADEpt> xerox__: here?
02:05:56 <pesco> dcoutts_: Yes, but isn't LazyByteString an alternative to [Char]?
02:05:57 * shapr swears at migrationsverket
02:06:06 <pesco> shapr: Hoi!
02:06:12 <dcoutts_> this just has blocks all of roughly the same size, not a logarithmic size scheme
02:06:25 <pesco> dcoutts_: Ah, roight.
02:06:45 <dcoutts_> pesco, well, more of an alternativekell
06:44:18 <valez> its the same if i have:
06:44:28 <valez> let text1 = f src
06:44:37 <valez> let text2 = g src
06:44:40 <valez> right?
06:44:55 <valez> cause cant get it to work with indenting
06:44:58 <eivuokko> lisppaste2: help
06:44:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:45:24 <eivuokko> Maybe you can paste your code in web, would be easier to help.
06:46:33 <valez> k thanx
06:50:38 <shapr> How's this for Haskellnet - http://rafb.net/paste/results/fnzOOq97.html ?
06:50:41 <shapr> Any comments?
06:51:40 <xerox> Good list.
06:52:00 <lisppaste2> valez pasted "io problem" at http://paste.lisp.org/display/19799
06:52:03 <shapr> It ends up being IMAP plus testing & packaging.
06:52:30 <shapr> It sounds just right for three months work to me, does that mean it's way too large?
06:54:52 <xerox> I think it is okay.
06:54:57 <shapr> Ok, thanks.
06:58:13 <shapr> In that case, I'll send it!
06:58:31 <xerox> shapr - http://en.wikibooks.org/wiki/The_Unicyclopedia:Resources |
06:58:33 <xerox> !
07:04:48 <shapr> xerox: Yeah, I've added the info on rims there.
07:07:51 * shapr wants to go unicyling with xerox sometime..
07:08:15 <xerox> Yeah me too.  I have to learn sometime! (-:
07:14:50 <shapr> Oh hey, I understand this STM microthreads application!
07:15:07 <shapr> He wants to reimplement Peng Li's unified thread and event framework with STM!
07:16:02 * shapr has a lightbulb over his head
07:16:34 * shapr thinks about that
07:16:49 <shapr> Why the heck didn't he just say that?
07:19:48 * shapr thinks about that.
07:21:11 <shapr> musasabi: Awake? Got a moment to talk about whether OS threads with -threaded can use multiple CPUs?
07:21:16 <xerox> O_o
07:21:30 <shapr> Well, now I understand the project.
07:21:51 <shapr> And I'm trying to figure out how it will differ from standard STM.
07:24:19 <musasabi> shapr: pong
07:24:31 <shapr> hi!
07:24:38 * shapr is trying to phrase the question...
07:24:56 <shapr> STM is bound to the RTS right now, yes?
07:25:36 <musasabi> yes
07:25:43 <shapr> Peng Li and Steve Zdancewic's reimplementation is a totally userspace implementation.
07:26:03 <shapr> So this project is to add STM to that completely userspace implementation of Control.Concurrent
07:26:15 <musasabi> But doesn't real STM code mix IO into things?
07:26:50 <shapr> I don't know.
07:27:44 <shapr> What would be the difference?
07:28:33 <shapr> Userspace STM would be really fast.
07:28:58 * musasabi does not understand how that proposal tries to do it.
07:29:35 <shapr> Did you look at http://wellsed.googlepages.com/soc2006suplimentalinformation & http://wellsed.googlepages.com/softwaretransactionalmemoryforuser-spacemicro-threads ?
07:29:50 <musasabi> shapr: think of the code "do x <- atomically (newTVar 0); forkIO (atomically $ writeTVar x 1); forkIO (atomically $ writeTVar x 2)
07:30:27 <musasabi> shapr: CPS is a gamble.
07:31:10 <musasabi> Basically it means that there will be more allocation but finer control of things.
07:32:30 <shapr> The guy sounds like he knows what he's doing at least.
07:33:07 <musasabi> yes, it is mostly the same approach as the event queues / threading concurrency paper a few weeks ago.
07:33:37 <shapr> Yeah, he wants to add STM support to that codebase.
07:34:08 <musasabi> The paper at least had STM support, don't know of the implementation.
07:34:38 <musasabi> hmm, native STM for that.
07:35:07 <musasabi> I can see how that makes sense if one decides that that is the correct way to handle concurrency in general.
07:35:39 <musasabi> It will be an interesting project at least.
07:36:16 <musasabi> For JHC things are much simpler since threading is co-operative it already has the good sides that would result from that implementation.
07:39:19 <shapr> You know anything about resumption monad transfomers? Ever heard of 'em?
07:46:14 <swiert> shapr: is that in the paper by Bill Harrison?
07:46:37 <shapr> yup, that's it.
07:46:38 <swiert> I think I was just looking at that.
07:47:10 <swiert> I haven't grokked it completely in all honesty.
07:49:49 * shapr reads that paper...
07:52:19 <shapr> swiert: Any other good papers you recommend?
07:52:37 <swiert> shapr: the one I'm trying to write :)
07:52:45 <shapr> heh, send me a draft!
07:53:12 <swiert> shapr: in all honesty, it cites an old paper by Koen Claessen which looks kind of cool.
07:53:17 <kosmikus> swiert: for the HW, I hope ...
07:53:25 <shapr> Which, yours or Harrison's?
07:53:33 <swiert> kosmikus: alas, for PLPV06...
07:54:32 <kosmikus> deadline is may 19, so you still have a few days after that to submit something to HW :)
07:55:01 <swiert> kosmikus: I will be attending HW though. Did I mention I'll be visiting Daan over the summer?
07:55:54 <kosmikus> swiert: you didn't, but Daan did :)
07:56:26 <kosmikus> swiert: when do you go?
07:56:46 <swiert> kosmikus: Mid June. Microsoft will book my ticket once my visa comes through.
07:57:15 <swiert> kosmikus: it should be good fun though.
07:58:51 <swiert> kosmikus: How was Japan?
08:00:32 * shapr hopes to go to ICFP2006
08:01:57 <xerox> How would you describe cabal-get in few words?
08:02:03 <xerox> shapr: me too!
08:03:09 <shapr> swiert: What do you think about adding userspace STM to Peng Li's and Steve Zdancewic's userspace Control.Concurrent implementation?
08:03:45 <swiert> shapr: I have no idea. Any pointers?
08:04:06 <swiert> shapr: I wasn't paying enough attention to the conversation you were having a minute ago.
08:05:25 <shapr> I guess I'm just trying to really understand how userspace STM will affect me.
08:10:17 <ADEpt> xerox: "cabal-get == haskell equivalent of ruby's gems, perl's CPAN.pm, debian's apt-get"
08:11:05 <xerox> Danke.
08:16:29 <xerox> @where FilePath
08:16:30 <lambdabot> http://scannedinavian.org/~lemmih/FilePath
08:18:50 <xerox> @where NewBinary
08:18:50 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
08:19:07 <xerox> @where xmlrpc
08:19:07 <lambdabot> I know nothing about xmlrpc.
08:20:34 <xerox> @where xml-rpc
08:20:35 <lambdabot> I know nothing about xml-rpc.
08:26:17 <Lokadin> hey
08:26:57 <Lokadin> say i have a problem, hReady and hWaitForInput seems to give me a true result for EOF
08:27:50 <Lokadin> and i need a char reading program to go to the end of the program that doesn't read EOF because well it quits
08:28:24 <Lokadin> anyone?
08:29:57 <Dendio> hi all
08:30:00 <Lokadin> hey
08:30:02 <Lokadin> what's up?
08:30:09 <Dendio> is there anyone who can help me about haskell please ?
08:30:16 <Lokadin> what do you need?
08:30:34 <Dendio> can you correct something please*
08:30:43 <Lokadin> i dono
08:30:48 <Lokadin> until you tell me what
08:30:49 <ndm> Dendio: give us something to correct and we'll see :)
08:30:54 <ndm> lisppaste2: url
08:30:54 <Dendio> ok wait please
08:30:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:31:11 <ndm> use that paste bot if you have some chunk of code 
08:31:26 <Dendio> I will write the question ok ?
08:31:47 <ndm> just write it :)
08:31:55 <Dendio> do you know the Haskell book ? Simon Thompson's
08:32:07 <ndm> i have heard of it
08:32:08 <Dendio> ok , it is in it
08:32:20 <Dendio> Given a number of pence ....
08:32:28 <Dendio> is there any one who knows this question?
08:32:53 <ndm> not me...
08:32:57 <Lokadin> me niether
08:32:58 <Lokadin> :|
08:33:06 <Lokadin> dono how you'd expect us to know either lol
08:33:23 <Dendio> Given a number of pence , 1023 say , the pounds and pence parts are given by 1023 'div' 100 and 1023 'mod' 100.
08:33:28 <Dendio> Using this fact ,
08:33:34 <Dendio> and the show functin
08:33:38 <Dendio> function
08:33:40 <Dendio> ,
08:33:48 <Dendio> define a function :
08:34:01 <Dendio> formatpence :: price -> string
08:34:03 <Dendio> so that
08:34:07 <Dendio> for example
08:34:19 <Dendio> formatpence 1023 = "10.23"
08:34:26 <ndm> Dendio: i bet it says :: Price -> String -- case sensitive in haskell
08:34:30 <Dendio> but be careful to cases like "12.02"
08:34:43 <ndm> Dendio: ok, what bit are you stuck at?
08:34:54 <Dendio> i will write my answer ok ? be patient
08:35:02 <Dendio> i want you to tell me if it is correct
08:35:03 <Lokadin> lol
08:35:09 <Dendio> ok?
08:35:15 <ndm> sure
08:35:21 <Dendio> -- Int to Float function
08:35:31 <Dendio> fromint :: int->float
08:35:39 <Dendio> type price =int
08:35:48 <Dendio> formatpence ::price->string
08:35:49 <ndm> Dendio: thats wrong already, no need to convert to a float at any stage
08:36:07 <Dendio> but there is a function called fromint
08:36:28 <ndm> there isn't, there used to be a very long time ago
08:36:32 <ndm> but no longer
08:36:36 <ndm> anyway, its not required
08:36:45 <ndm> use the hint given - about mod and div
08:36:45 <Dendio> so tell me the answer please
08:37:21 <ndm> think about the question
08:37:27 <Dendio> formatpence n = show ( ( n'div'100 ) + ( fromint ( n 'mod'100 )) /100.0 )
08:37:30 <Dendio> this is my answer
08:37:42 <ndm> ok, thats not a bad answer
08:37:48 <ndm> its got some good bits in it
08:37:56 <ndm> but i don't think its what they were after
08:37:59 <ndm> think:
08:38:05 <ndm> pounds ++ "." ++ pence
08:38:12 <ndm> now figure out an expression for pounds and pence
08:38:24 <Dendio> i am sorry but i am very new to Haskell
08:38:27 <ndm> thats fine
08:38:30 <Dendio> and this is our homework
08:38:44 <ndm> your approach was to come up with a number, which when shown is the right answer
08:38:57 <ndm> the thing they are after is coming up with the strign part by part, and joining it yourself
08:39:25 <Dendio> but they give numbers
08:39:30 <Dendio> so price is int
08:39:35 <ndm> yes, price is int
08:39:43 <ndm> can you come up with an expression for the pounds, as a string?
08:39:53 <ndm> so 1023 gives "10"
08:40:11 <xerox> @type splitAt
08:40:12 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:40:43 <xerox>   where (pounds,pence) = splitAt ... -- (-:
08:41:23 <Dendio> did you understand the question please?
08:41:40 <Dendio> they want the div result and mod result combined in string in the final result
08:41:47 <ndm> Dendio: can you come up with an expression for the pounds, as a string
08:41:52 <ndm> i really did understand the question :)
08:42:10 <Dendio> i am sorry but i did not understand your question
08:42:10 <ndm> you are taking an alternative approach to the question, which isn't quite intended for this one
08:42:16 <xerox> Dendio: isn't it just like 1213 -> "12.13" ?
08:42:21 <Dendio> yes
08:42:34 <ndm> xerox, yes, but the question hints at div and mod, so doesn't want the nicer splitAt solution
08:42:48 <xerox> I see.  Then use those.
08:43:00 <Dendio> our book doesn't have those for now i think in this chapter
08:43:08 <ndm> Dendio: given 1023, can you figure out what the pounds are
08:43:10 <ndm> as a number
08:43:13 <Dendio> yes
08:43:15 <xerox> Dendio: what's wrong with your answer?
08:43:16 <ndm> (the hint will help you here)
08:43:28 <ndm> Dendio: go on then, show me :)
08:43:32 <Dendio> i think my answer is correct
08:43:35 <Dendio> look
08:43:38 <xerox> Dendio: ...but?
08:43:40 <Dendio> formatpence n = show ( ( n'div'100 ) + ( fromint ( n 'mod'100 )) /100.0 )
08:43:58 <ndm> > let formatpence n = show ( ( n'div'100 ) + ( fromint ( n 'mod'100 )) /100.0 ) in formatpence 1023
08:43:59 <lambdabot>  Not in scope: `mod'100'
08:44:13 <ndm> > let formatpence n = show ( ( n `div` 100 ) + ( fromint ( n `mod` 100 )) /100.0 ) in formatpence 1023
08:44:13 <lambdabot>  Not in scope: `fromint'
08:44:28 <xerox> > let f n = show ((n `div` 100) + fromInteger (n `mod` 100)) in f 1023
08:44:28 <Dendio> ooo , this room is nice :)
08:44:29 <lambdabot> "33"
08:44:32 <ndm> > let formatpence n = show ( ( n `div` 100 ) + ( fromInteger (toInteger ( n `mod` 100 ))) /100.0 ) in formatpence 1023
08:44:32 <lambdabot> Add a type signature
08:44:34 <xerox> No, it isn't.
08:44:48 <Dendio> there is a bot for this
08:44:48 <Dendio> :)
08:45:10 <xerox> > let f n = concat [show (n `div` 100),".",show (n `mod` 100)] in f 1023
08:45:11 <lambdabot> "10.23"
08:45:16 <ndm> Dendio: there are three approaches to your answer
08:45:17 <shapr> Could resumption monads be used to do lazy file reading without requiring unsafe{Perform,Interleave}IO ?
08:45:21 <Dendio> > let formatpence n = show ( ( n'div'100 ) + ( fromint ( n 'mod'100 )) /100.0 )
08:45:22 <lambdabot>  parse error on input `}'
08:45:28 <ndm> yours, xerox's, the one the book is after
08:45:49 <xerox> Dendio: there is no fromint function, it is called fromInteger.
08:45:59 <xerox> Dendio: and moreover, the quotes arent ' but `.
08:46:01 <Dendio> there is xerox
08:46:10 <xerox> ?type fromInt
08:46:11 <lambdabot> Not in scope: `fromInt'
08:46:14 <xerox> ?type fromInteger
08:46:15 <lambdabot> forall a. (Num a) => Integer -> a
08:46:19 <Igloo> Dendio: That's an error in Bird's IFP
08:46:21 <xerox> ?type fromIntegral
08:46:22 <lambdabot> forall b a. (Num b, Integral a) => a -> b
08:46:31 <Igloo> Dendio: fromIntegral is what you want
08:46:32 <Dendio> so tell me please , is the book wrong ?
08:46:45 <ndm> the book was right at the time, but not anymore
08:46:48 <Dendio> The Craft of Functional Pr.
08:47:02 <Dendio> this homework is about that
08:47:11 <xerox> Dendio: did you see my solution?
08:47:16 <Dendio> so i think doing in book's way is wanted
08:47:22 <Dendio> where xerox?
08:47:27 <xerox> > let f n = concat [show (n `div` 100),".",show (n `mod` 100)] in f 1023
08:47:28 <lambdabot> "10.23"
08:47:35 <Dendio> wait please
08:48:00 <Dendio> it is possible and logical
08:48:14 <Dendio> is my answer right?
08:48:20 <Dendio> formatpence n = show ( ( n'div'100 ) + ( fromint ( n 'mod'100 )) /100.0 )
08:48:44 <xerox> Dendio: what would the '+' do there for you?
08:48:52 <xerox> I show you what your function gives as result.
08:48:57 <xerox> > let f n = show ((n `div` 100) + fromInteger (n `mod` 100)) in f 1023
08:48:58 <lambdabot> "33"
08:48:59 <Dendio> let me explain
08:49:07 <xerox> It doesn't seem right to me.
08:49:17 <Dendio> n'div'100 = integer
08:49:27 <Dendio> n'mod'100 = integer
08:49:34 <Dendio> fromint n mod ... = float
08:49:40 <Dendio> float / 100.0 = float
08:49:53 <Dendio> float + int
08:50:02 <Dendio> show ( float + int )
08:50:18 <Dendio> maybe the problem is not doing n div 100 to float
08:51:02 <xerox> > let f n = showFFloat (Just 2) (fromIntegral (n `div` 100) + (fromIntegral $ n `mod` 100) / 100 :: Float) "" in f 1023
08:51:03 <ndm> its a ossible solution
08:51:03 <lambdabot> "10.23"
08:51:11 <ndm> although consider 1010
08:51:16 <ndm> you'd end up with "10.1"
08:51:22 <xerox> > let f n = show (fromIntegral (n `div` 100) + (fromIntegral $ n `mod` 100) / 100 :: Float) in f 1023
08:51:23 <lambdabot> "10.23"
08:51:24 <ndm> and because you go via floats its not as good - floats suck
08:51:25 <xerox> More simply.
08:51:32 <Dendio> 12.02 is interesting
08:51:39 <ndm> > let f n = show (fromIntegral (n `div` 100) + (fromIntegral $ n `mod` 100) / 100 :: Float) in f 1010
08:51:42 <moonlite1> Dendio: your implementation is wrong. that's the problem. Your function will evaluate like this: f 1023 = 10+23 = 33
08:51:42 <lambdabot> "10.1"
08:51:54 <xerox> ndm: that's why I used showFFloat in first place.
08:52:15 <xerox> > let f n = showFFloat (Just 2) (fromIntegral (n `div` 100) + (fromIntegral $ n `mod` 100) / 100 :: Float) "" in f 1001
08:52:16 <lambdabot> "10.01"
08:52:20 <xerox> Okay, Dendio?
08:52:29 <Dendio> you are fast , i told you i am  new
08:52:38 <Dendio> i don't those commands
08:52:41 <Dendio> sorry know
08:52:56 <xerox> Do you want me to go in an explanation of that code?
08:53:00 <ndm> you should be able to do it with mod, div, show, ++, length
08:53:15 <Dendio> thanks but i think it will be mixed i think
08:53:21 <ndm> or probably > instead of length
08:53:22 <xerox> (-:
08:53:56 <Dendio> can you do this please ?
08:54:01 <Dendio> n 'mod' 100
08:54:11 <xerox> n `mod` 100
08:54:21 <Dendio> fromint ( n'mod'100 ) / 100.0
08:54:26 <xerox> If you're using windows the quote is Alt+96, IIRC.
08:54:52 <ndm> its usually top left of the keyboard
08:54:54 <xerox> (fromIntegral (n `mod` 100)) / 100
08:54:58 <ndm> Dendio: are you using the new WinHugs?
08:55:09 <Dendio> i am using no programme
08:55:17 <Dendio> only the book and lessons
08:55:18 <xerox> Nice.
08:55:18 <ndm> it will be easier with a Haskell compiler
08:55:22 <ndm> @where WinHugs
08:55:23 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
08:55:28 <ndm> go and download and install that
08:55:28 <xerox> It's okay nevertheless.
08:55:33 <ndm> it should help you test things
08:55:51 <Dendio> ok
08:55:53 <Dendio> thank
08:55:54 <Dendio> s
08:55:57 <Dendio> which one ?
08:56:12 <ndm> Dendio: either, do you have lots of disk space or not?
08:56:19 <ndm> MinHugs is probably plenty for your use
08:56:32 <ndm> but if you have the disk space, WinHugs has more libraries, which might come in handy in the future
08:56:34 <Dendio> now i am installing win
08:56:37 <ndm> actually, WinHugs
08:56:44 <ndm> it has all the compatability libraries for that book
08:56:49 <Dendio> ok
08:56:50 <Dendio> thanks
08:57:00 <Dendio> but i don't think that i will use it tonight
08:57:02 <Dendio> maybe
08:57:13 <Dendio> it is better to do with you if it is possible with you :)
08:57:23 <xerox> Right (-:
08:58:05 <Dendio> ok xerox can you tell me how we can correct our codes with lambda bot ?
08:58:16 <xerox> Yes, sure.
08:58:19 <DendadS a = String -> [(a, String)]
11:30:42 <vincenz> i have similar issues with fromJust
11:30:46 <vincenz> I have a map
11:30:52 <vincenz> and using fromJust . lookup
11:30:55 <vincenz> is it possible to break computation
11:30:57 <davidhouse> use maybe instead.
11:30:58 <vincenz> and then just give an error?
11:31:21 <vincenz> problem is that the Maybe monad does not allow for a string being returned
11:31:33 <davidhouse> > maybe (error "aargh") id $ lookup 'a' [('a', "hello")]
11:31:35 <lambdabot> "hello"
11:31:39 <davidhouse> > maybe (error "aargh") id $ lookup 'b' [('a', "hello")]
11:31:40 <lambdabot> Exception: aargh
11:31:49 <vincenz> hmm
11:32:01 <vincenz> @type maybe
11:32:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:32:27 * vincenz nods
11:32:37 <vincenz> why id
11:32:41 <davidhouse> > maybe "sorry" (++" world") $ Just "hello"
11:32:42 <lambdabot> "hello world"
11:32:47 <davidhouse> > maybe "sorry" (++" world") Nothing
11:32:48 <lambdabot> "sorry"
11:32:56 <vincenz> ah k
11:32:57 <vincenz> thx
11:33:13 <davidhouse> maybe's got an annoying structure whereby you have to pass a function to do something with it if it's a Just.
11:33:36 <davidhouse> maybe' fallback value = maybe fallback id value -- much more useful
11:34:04 <vincenz> will error be a Left str
11:34:53 <davidhouse> where?
11:35:07 * vincenz needs to look at it a bit more
11:35:23 <davidhouse> vincenz: error in what place?
11:36:12 <vincenz> http://rafb.net/paste/results/mEScde65.html
11:36:19 <vincenz> basically... the fromJust's are in let's
11:36:26 <vincenz> cause Either String is not a monad
11:36:57 <vincenz> and I would like to get some sort of error message into a Left
11:37:00 <vincenz> if any of those fromJust's fail
11:37:10 <vincenz> basically parse returns a Map String (SomeMonad ())
11:37:15 <vincenz> a map of function names to monad actions
11:37:16 <davidhouse> what monad is action in?
11:37:25 <vincenz> my custom monad
11:37:29 <vincenz> but that is not being executed
11:37:31 <vincenz> but returned as value
11:37:42 <davidhouse> by the way:
11:38:04 <vincenz> dcoutts: is it possible to flash a message somehow?
11:38:07 <vincenz> in gtk2hs
11:38:14 <davidhouse> do b <- isendAction; guard b; restOfTheStuff
11:38:22 <davidhouse> try that instead of your if construct
11:38:25 <dcoutts> vincenz, flash? what do you mean?
11:38:33 <vincenz> dcoutts: ok for the read stuff
11:38:35 <vincenz> I have a textbox
11:38:37 <vincenz> type in a number
11:38:38 <vincenz> click a button
11:38:44 <vincenz> it checks whether it's a number before actually reading it
11:38:52 <vincenz> (cause otherwise it crashed the app)
11:38:58 <vincenz> obviously I would like to flash the mistake somehow
11:39:10 <davidhouse> vincenz: if you want to use Either instead of Maybe, i suggest doing something like this:
11:39:23 <dcoutts> vincenz, that or case read s of [] -> ... [(n,_)] -> ...
11:39:29 <vincenz> dcoutts: right
11:39:40 <vincenz> dcoutts: but the actual flashing now
11:39:47 <davidhouse> maybeToEither err = maybe (Left err) Right
11:40:09 <vincenz> davidhouse: the problem is that it's not a do
11:40:22 <davidhouse> Either is a monad.
11:40:33 <davidhouse> you could make it a do.
11:40:40 <dcoutts> vincenz, so what do you want to do exactly?
11:40:50 <vincenz> dcoutts: somehow flash a message "that is not a number"
11:41:10 <dcoutts> in a new window, or in the same one?
11:41:16 <vincenz> I guess the sameone
11:41:27 <dcoutts> just set the text on a label and then set it blank again later
11:41:32 <vincenz> eah
11:41:35 <dcoutts> or use a status bar at the bottom
11:41:43 * vincenz hmms
11:41:44 <vincenz> ok
11:41:46 <dcoutts> and add a mesage to that
11:42:10 <dcoutts> I think we've got a demo of that
11:42:12 * dcoutts checks
11:42:13 <vincenz> then regarding the paste I put here
11:42:15 <vincenz> there's two issues with it
11:42:22 <vincenz> a) the fromJust, b) the matching of data-constructors
11:43:30 <davidhouse> vincenz: (IsEnd isendAction) = maybeToEither "No isendAction" $ Map.lookup "isend" ruleSet
11:43:37 <dcoutts> vincenz, http://darcs.haskell.org/gtk2hs/demo/noughty/NoughtyGlade.hs
11:44:16 <davidhouse> apart from they then won't have the correct type.
11:44:18 <davidhouse> hm.
11:44:22 <vincenz> dcoutts: thx
11:44:26 <shapr> I can't believe it's not butter!
11:44:33 <vincenz> I think I should probably use some sort of monad
11:44:37 <davidhouse> yep.
11:44:49 <davidhouse> @where paste
11:44:50 <lambdabot> http://paste.lisp.org/new/haskell
11:45:12 <vincenz> I guess the Error monad
11:45:56 <davidhouse> vincenz: how about ErrorT String YourMonad
11:46:24 <vincenz> perhaps
11:46:29 <shapr> Dang, I missed ktne...
11:47:37 <shapr> ndm: I'm convinced there's a simple, efficient, well known algorithm for simplifying predicates, but I can't for the life of me remember what it's called.
11:47:49 <vincenz> pisses me off that Parsec returns either and not a real monad
11:49:11 <lisppaste2> davidhouse pasted "vincenz: something like this" at http://paste.lisp.org/display/19811
11:49:32 <vincenz> davidhouse: erm... 
11:49:38 <vincenz> davidhouse: YourMonad is not the monad of hte action
11:49:42 <vincenz> the action has to be returned to be used later
11:49:55 * davidhouse can't remember exactly how errors are propogated in Either
11:50:05 <davidhouse> vincenz: huh? you said action was in your monad.
11:50:41 <vincenz> ye
11:50:48 <vincenz> but that is being returned as value
11:51:17 <vincenz> still pisses me off I have to check Left or Right of runPasre
11:51:21 <vincenz> instead of just using it in a monad
11:51:24 <vincenz> value <- ...
11:51:30 <davidhouse> Either is a monad.
11:51:34 <vincenz> no it's not
11:53:25 <davidhouse> @type parse
11:53:27 <lambdabot> Not in scope: `parse'
11:53:33 <davidhouse> @hoogle parse
11:53:36 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
11:53:36 <lambdabot> Data.Version.parseVersion :: ReadP Version
11:53:36 <lambdabot> Distribution.InstalledPackageInfo.parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
11:54:28 <vincenz> davidhouse: that's my parser
11:55:59 <davidhouse> > do p <- parse (string "hello") "" "hello"; return $ map toUpper p;
11:56:00 <lambdabot>  Not in scope: `string'
11:56:05 <davidhouse> grr
11:56:43 <xerox> Right, it would be fun to have Parsec there :-)
11:57:26 <davidhouse> @hoogle MonadError
11:57:26 <lambdabot> Control.Monad.Error.MonadError :: class Monad m => MonadError e m
11:57:56 <davidhouse> ah.
11:58:06 <davidhouse> it seems Either String is a monad, but not Either ParseError.
11:58:43 <vincenz> how do you wrap a `catchError` around a x <- action
11:58:47 <davidhouse> > p <- Left 
11:58:48 <lambdabot>  parse error on input `<-'
11:59:09 <davidhouse> > p <- Left "error"; return $ map toUpper p;
11:59:10 <lambdabot>  parse error on input `<-'
11:59:11 <xerox> Proposal sent in!
11:59:15 <davidhouse> > do p <- Left "error"; return $ map toUpper p;
11:59:16 <lambdabot>  add an instance declaration for (Monad (Either [Char]))
11:59:16 <lambdabot>   In the definition of `gue':
11:59:16 <lambdabot>    gue = do
11:59:17 <vincenz>  nope
11:59:18 <xerox> Yahooo.
11:59:32 <davidhouse> it would work if imported the correct modules.
12:00:18 <vincenz> this is UGGGLY
12:00:39 <davidhouse> import Control.Monad to get the instance declaration for Monad String
12:00:43 <vincenz> http://rafb.net/paste/results/DXKJEM72.html
12:00:44 <davidhouse> err, Monad (Either String)
12:00:45 <vincenz> check that out
12:01:28 * vincenz does something
12:01:56 <davidhouse> @type catchError
12:01:57 <lambdabot> Not in scope: `catchError'
12:02:02 <davidhouse> @hoogle catchError
12:02:03 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
12:02:36 <psi> xerox: what did you propose?
12:02:54 <psi> (I thought you were a mentor)
12:03:18 <vincenz> \o/
12:03:19 <davidhouse> vincenz: http://rafb.net/paste/results/Go8YIg20.html perhaps
12:03:43 <vincenz> davidhouse: that is wrong
12:03:51 <vincenz> davidhouse: the first one is the one that it tries to catch from
12:04:05 <vincenz> this is a bit cleaner
12:04:06 <vincenz> http://rafb.net/paste/results/0v8yMA51.html
12:04:20 <davidhouse> oh, okay.
12:04:23 <vincenz> the return x just pisses me off
12:04:27 <vincenz> inside te (...)
12:04:32 <vincenz> erm...inside the inner do action
12:04:40 <davidhouse> hmm.
12:04:45 <davidhouse> is Maybe an instance of MonadError?
12:04:46 <vincenz> too bad patterns are not firstclass
12:05:01 <davidhouse> becuse Map.lookup is in Maybe, not Either.
12:05:14 <vincenz> no it's not
12:05:17 <vincenz> @hoogle lookup
12:05:17 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:05:17 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
12:05:17 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
12:05:27 <vincenz> @type Data.Map.lookup
12:05:28 <lambdabot> forall a (m :: * -> *) k.
12:05:28 <lambdabot>        (Ord k, Monad m) =>
12:05:28 <lambdabot>        k -> Data.Map.Map k a -> m a
12:05:36 <davidhouse> oh?
12:05:38 <davidhouse> that's cool.
12:05:39 <vincenz> yeah
12:05:44 <davidhouse> hmm.
12:05:45 <vincenz> don't know why list and IntMap and HashTable aren't
12:05:50 <Cale> What do people think of the idea that class contexts in data declarations would ensure that a pointer to a class dictionary was stored for each value of the type?
12:05:51 <vincenz> seems like an oversight
12:06:07 <vincenz> Cale: come again
12:06:11 <Cale> (somewhat like an existential)
12:06:36 <davidhouse> > Data.Map.lookup 'a' (Data.Map.fromList [('a', "hello")]) :: [String]
12:06:37 <lambdabot>  Not in scope: `Data.Map.fromList'
12:06:40 <Cale> So, say we have data Ord a => Set a = Empty | Cons a (Set a)
12:07:25 <Cale> Currently, all that happens is that the same class constraint is added to the type of Cons
12:07:49 <Cale> Cons :: (Ord a) => a -> Set a -> Set a
12:08:06 <Cale> however, Empty :: Set a
12:08:49 <Cale> Now, let's say we want to write an instance of Monad for Set.
12:09:07 <Cale> We won't be able to make use of that Ord constraint
12:09:53 <Cale> since if we did, we'd end up with  (>>=) :: (Ord a, Ord b) => Set a -> (a -> Set b) -> Set b
12:10:01 <Cale> but it's not allowed to have that type
12:10:51 <Cale> however, we know that for all interesting cases, that an Ord dictionary will be available, it's just that it's not going to be passed to (>>=)
12:12:02 <Cale> If a pointer to this dictionary was placed in the Set values themselves, it would be ensured that any function which took a Set as a parameter would have a copy of the dictionary, and thus could avoid having that additional class constraint added to its type
12:12:07 <eivuokko> Do you know if there was a reason why that was omitted in first place?
12:12:45 <Cale> I'm not sure -- probably just for simplicity's sake.
12:12:51 <eivuokko> It'd be more intuitive that way, sure.
12:13:25 <eivuokko> Class context in data decl are very unintuitive at the moment.
12:13:49 <Cale> It does make type inference a little strange.
12:14:23 <eivuokko> I was actually trying to find out exact rules how instance environment is built the other day, so maybe there's a blackhole that eats it.
12:14:36 <eivuokko> It seemed underspecified to me
12:15:41 <sidewinder> vim 7 is out.  And since Visual Haskell doesn't work with VS2005 I guess I should start hacking or modifying an existing plugin
12:15:42 <Cale> This would mean that functions could be made to use (>) for example, without getting an Ord context themselves, so long as they took a Set as a parameter.
12:16:57 <vincenz> dcoutts: ping
12:17:00 <eivuokko> I don't actually see where it'd make type inference wierd.  When trying to instantiate Set with type that has no Ord?
12:18:07 <Cale> Well, you could do things like, f x y s = x < y
12:18:22 <Cale> this could have type (Ord a) => a -> a -> b -> Bool
12:18:31 <Cale> or a -> a -> Set a -> Bool
12:18:38 <eivuokko> Ah.
12:19:27 <Cale> so you lose principal types, though they've already been lost with all the extensions anyway
12:22:54 <eivuokko> Are instances (or can they be) searched like that, anyway?  I mean digging them up from b might be dangerous (it could be undefined), so it would break laziness if it assumed latter.
12:23:19 <davidhouse> anyone know of a debian (i'm on ubuntu) package repo with a GHC > 6.4.0?
12:23:54 <eivuokko> testing?
12:24:00 <Cale> eivuokko: hmm
12:24:11 <Cale> eivuokko: well, it could be made safe
12:24:21 <bringert> davidhouse: http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
12:24:32 <Cale> eivuokko: at the cost of an extra box
12:25:53 <davidhouse> thanks, bringert.
12:26:01 <Cale> a value of type Set a would always be a pair of pointers, one to a class dictionary, and one to a (Set a) as we know them today
12:26:10 <eivuokko> Cale, all problems can be solved by indirection...heh.
12:30:53 <vincenz> c-pointers
12:32:00 <vincenz> woot
12:32:05 <vincenz> vim 7.0 is out
12:32:59 <shapr> hej bringert 
12:33:02 <shapr> wassup?
12:33:56 <shapr> Wow, 218 clients today.
12:34:23 <vincenz> crappy yahoo groups: The message you requested is temporarily unavailable because this group has exceeded its download limit. Please try again later.
12:34:41 <vincenz> (got slashdotte)
12:34:43 <vincenz> +d
12:36:05 <Cale> vincenz: yeah, I was annoyed by that too
12:36:21 <vincenz> I tried to google it
12:36:27 <vincenz> in the hope it got cached by google, but I guess it's too new
12:36:43 <shapr> hoi franka 
12:36:49 <vincenz> I also wonder why the announcement isn't directly placed on vim.org, instead of linking to yahoo groups
12:36:59 <franka> Hi, shapr.
12:37:01 <Cale> yeah, that's pretty stupid
12:40:31 <vincenz> Cale: btw, 16th of july, if you haven't read the wiki lately, we're trying to round everyone up
12:40:50 <vincenz> 16 gmt
12:40:52 <vincenz> it's a sunday
12:41:47 <Cale> hmm, two months away
12:41:50 <vincenz> yeah
12:42:03 <vincenz> just an fyi
12:42:53 <bringert> hej shapr
12:42:55 <Cale> okay, I'll try to remember :)
12:42:58 <bringert> I'm in Seattle
12:44:05 <sidewinder> vincenz: does anybody work on the vim plugin for haskell anymore?
12:44:30 <sidewinder> vincenz: there's syntax highlighting and I found one plugin that seemed to be about 4 years old
12:45:28 <vincenz> sidewinder: dunno
12:46:48 * davidhouse once again finds himself needing a function to get the first Just in a [Maybe a]
12:47:15 <davidhouse> there really should be a function collapse = foldl mzero mplus
12:47:24 <davidhouse> like msum, but that is a foldr
12:47:29 <sethk> davidhouse, you coded one the other day, didn't you?  in any event it's a simple function
12:47:41 <vincenz> @type msum
12:47:42 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
12:47:57 <vincenz> > msum [Nothing, Just 1, Just 2]
12:47:58 <lambdabot> Just 1
12:48:09 <vincenz> davidhouse: erm?
12:48:40 <davidhouse> hm?
12:48:49 <davidhouse> @fptools Control.Monad
12:48:49 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
12:48:56 <vincenz> davidhouse: did you just miss that?
12:48:58 <vincenz> > msum [Nothing, Just 1, Just 2]
12:48:59 <lambdabot> Just 1
12:49:52 <davidhouse> i thought for Maybe, Just x `mplus` Just y = Just x, but it appears i'm mistaken.
12:50:05 <vincenz> davidhouse: msum does exactly what you want
12:50:10 <davidhouse> > Just 5 `mplus` Just 7
12:50:11 <lambdabot> Just 5
12:50:15 <davidhouse> vincenz: so i see
12:50:18 <davidhouse> oh.
12:50:31 <jyp> Hey guys.
12:50:35 <vincenz> jyp: hiya
12:50:57 <davidhouse> oh, of course :)
12:51:07 <davidhouse> wait, no.
12:51:10 <davidhouse> surely msum [ Nothing, Just 1, Just 2 ] = Nothing `mplus` Just 2 `mplus` Just 1 `mplus` Nothing = Just 2
12:51:14 <vincenz> btw
12:51:18 <davidhouse> > Nothing `mplus` Just 2 `mplus` Just 1 `mplus` Nothing
12:51:19 <lambdabot> Just 2
12:51:21 <vincenz> fail == throwError in Monad Error?
12:51:51 * davidhouse is confused
12:51:55 <vincenz> davidhouse: no...it's foldr, but the arguments are still in the correct order, and because mplus is commutattive...
12:51:59 <vincenz> erm...foldl
12:52:04 <vincenz> it's
12:52:07 <davidhouse> mplus isn't commutative.
12:52:14 <vincenz> a mplus (b mplus c)
12:52:18 <vincenz> erm ... I mean associative
12:52:20 <vincenz> instead of
12:52:25 <vincenz> (a mplus b) mplus c
12:52:58 <vincenz> foldr and foldl keep the individual arguments in the same order... it's just the () that are placed differently
12:53:08 <vincenz> I think
12:53:12 <vincenz> @type foldr
12:53:13 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:53:14 <vincenz> @type foldl
12:53:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:53:18 <davidhouse> duh. of course.
12:53:33 <davidhouse> @fptools GHC.List
12:53:33 <lambdabot> GHC.List not available
12:53:38 <davidhouse> @fptools Data.List
12:53:39 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:53:55 <vincenz> is fail == throwError in ErrorT?
12:54:01 <davidhouse> look it up.
12:54:10 <vincenz> @fptools Control.Monad.Error
12:54:10 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
12:54:56 <vincenz> seems so
12:57:05 <davidhouse> @fptools Data.Maybe
12:57:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
12:58:23 <ndm> shapr, any remembering of the predicate algorithm?
13:01:44 <davidhouse> @hoogle </>
13:01:44 <lambdabot> Text.Html.(</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
13:02:03 <davidhouse> huh. is there no FilePath combinator library?
13:02:30 <ndm> davidhouse: no, but I tend to use the one out of Yhc, since thats Unix and Win32 happy
13:02:35 <ndm> and has no cpp in it
13:02:42 <davidhouse> ndm, got a URL?
13:02:46 <ndm> @where Yhc
13:02:46 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
13:03:16 <ndm> davidhouse: http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=yhc-devel;a=headblob;f=/src/compiler98/Util/FilePath.hs
13:03:32 <ndm> i beleive darcs also has one, and that uses /// as the filepath operator, i think
13:04:16 <davidhouse> ndm, can i just drop that into my app?
13:04:30 <davidhouse> (if, say, i'm using GHC)
13:04:32 <ndm> davidhouse: the Yhc one, yes, easy
13:04:44 <ndm> just put that file where appropriate
13:05:05 <davidhouse> hm. what's this SysDeps module it imports?
13:05:44 <ndm> http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=yhc-devel;a=headblob;f=/src/compiler98/SysDeps.hs
13:06:05 <ndm> osName :: String
13:06:06 <davidhouse> right, so it's not that easy to drop into my app :)
13:06:06 <ndm> osName = if compilerName == "yhc" || os /= "mingw32" then os else "windows"
13:06:15 <ndm> remove import SysDeps
13:06:21 <ndm> and replace it with those two lines above
13:06:26 <ndm> I forgot it depended on SysDeps
13:06:32 <ndm> we're slowly working to remove SysDeps
13:06:41 <davidhouse> and os? what's that?
13:07:02 <ndm> import System.Info
13:07:12 <ndm> its just the name of the os that the program is running on
13:07:18 <davidhouse> ah yes.
13:07:22 <ndm> this way you get a portable unix/windows filepath implementation
13:07:35 <ndm> and a static compiler, like GHC, will optimise it all out
13:07:50 <ndm> but a portable one, like Yhc, will still have a portable file, with no cpp
13:08:07 <davidhouse> and presumably i need to change the imports like Directory to System.Directory, and so on.
13:08:25 <ndm> you can, depends if you want to or not
13:08:35 <ndm> it still works in GHC with that
13:08:43 <ndm> its just hte old module layout
13:09:46 <osqulda> What does this mean: class Monad m => MonadState s m | m -> s where    
13:09:49 <osqulda> the bar here.
13:09:59 <ndm> osqulda: functional dependancies
13:10:07 <osqulda> aha, and what is that?
13:10:12 <osqulda> s depends on m?
13:10:17 <ndm> yes, kind of
13:10:23 <ndm> i don't really understand them totally
13:10:23 <osqulda> dependent type?
13:10:29 <ndm> @google haskell functional dependancies
13:10:30 <lambdabot> http://lambda-the-ultimate.org/node/1111
13:10:35 <osqulda> cheers
13:10:41 <eivuokko> I think they are often read: m uniquely identifies s
13:10:42 <osqulda> g'night
13:10:43 <ndm> not dependant type, that means something else
13:12:55 <bringert> hmm, with ghc 6.4.1, System.Info.compilerVersion is 6.4
13:16:30 <monochrom> "class XXX a b | b -> a where ..."  "instance XXX Int Bool where..."  if you have these, then ...
13:16:49 <monochrom> you can't have "instance XXX Double Bool where..."
13:16:54 <eivuokko> bringert, I think ghc's version handling in diffrent places is a bit hazy.  ghc 6.4.2 has -D__GLASGOW_HASKELL__=604 at least for c files.
13:17:05 <monochrom> That is what "b->a" does.
13:18:17 <monochrom> It disallows more than one instances "instance XXX ___ Bool".
13:18:54 <xerox> Right, you read it like ``b chooses a''. 
13:19:30 <monochrom> However, you are still allowed to have many instances of the form "instance XXX Int ___".
13:19:40 <shapr> type indexed types, iirc
13:20:09 <monochrom> Thus it's called functional dependency because b->a expresses more or less "(partial) function from b to a"
13:20:51 <monochrom> The MArray class is a very good usage of functional dependencies.
13:21:15 <xerox> shapr: I think you're right.
13:28:23 <MarcWeber> Which monad is expected here? http://rafb.net/paste/results/zxkbww52.html   m2 works, m3 not
13:29:01 <davidhouse> MarcWeber: is it currently in Reader?
13:29:08 <xerox> MarcWeber: ReaderT IO a
13:29:11 <davidhouse> if so, you need to use ReaderT if you want do IO.
13:29:23 <davidhouse> try putting it in ReaderT IO a, like xerox said, then use:
13:29:38 <davidhouse>  do { env <- ask; liftIO $ hGetChar env }
13:32:05 <MarcWeber> Control.Monad.Trans.liftIO or GHC.IOBase.liftIO?
13:32:21 <sjanssen> MarcWeber: Trans
13:32:25 <vincenz> anyone ever try a bittorrent style approach for multi-person collaboration with darcs?
13:32:55 <sjanssen> vincenz: what exactly do you mean?
13:33:18 <vincenz> well...basically wehenver you push to your local repo... it will notify other darcs...by checking who is alive and active
13:33:27 <vincenz> whenever you pull... it will check who is active to pull from the
13:33:37 <vincenz> distributed with some way of enabling people to notify that they're up
13:33:54 <vincenz> (probably using pub/priv keys to ensure that no infiltrator enters the system)
13:34:34 <akemp> @seen dons
13:34:34 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 6 hours, 57 minutes and 19 seconds ago.
13:35:04 <vincenz> let me make a drawing
13:35:07 <davidhouse> @hoogle IO String
13:35:07 <lambdabot> Prelude.getContents :: IO String
13:35:08 <lambdabot> Prelude.getLine :: IO String
13:35:08 <lambdabot> System.getProgName :: IO String
13:35:40 <davidhouse> what's the function to get the current directory?
13:35:45 <vincenz> @hoogle curDir
13:35:46 <lambdabot> No matches found
13:35:49 <vincenz> @hoogle currentDir
13:35:50 <lambdabot> Distribution.Simple.Utils.currentDir :: FilePath
13:35:50 <lambdabot> Directory.getCurrentDirectory :: IO FilePath
13:35:50 <lambdabot> Directory.setCurrentDirectory :: FilePath -> IO ()
13:36:00 <davidhouse> thanks.
13:38:29 <sjanssen> vincenz: for small groups, you could skip the activity checking and just attempt a pull from every repo
13:38:47 <vincenz> correct
13:38:52 <vincenz> but it would have to be cron'd
13:38:56 <vincenz> or possibly when you pull
13:39:51 <vincenz> however with dhcp
13:39:55 <vincenz> notifying would be useful
13:39:56 <sjanssen> instead of using darcs directly, just have a little script: for i in repos darcs pull from i
13:40:14 <MarcWeber> xerox, sjanssen, davidhouse Which literature would you propose to learn this advanced stuff? GHC library source? ;) 
13:40:34 <xerox> @google All About Monads
13:40:36 <lambdabot> http://www.nomaware.com/monads/html/
13:40:40 <davidhouse> that.
13:40:44 <sjanssen> polling every time you pull won't scale to large groups, but should work fine for a dozen people or so
13:40:48 <xerox> It explains the Transformer theory thoughtfully.
13:40:49 <MarcWeber> putting it in ReaderT means something like this? m3= do { env <- ask; Control.Monad.Trans.liftIO $ hGetChar env } :: ReaderT Handle IO Char
13:41:02 <davidhouse> liftIO is preluded.
13:41:03 <xerox> Yes.
13:41:20 <davidhouse> @index liftIO
13:41:20 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:41:42 <MarcWeber> davidhouse: That will take will take a lot of time.. ;) I had to learn parts of Parsec first..
13:42:01 <davidhouse> AAM should be read before you try to learn any specific monad.
13:42:27 <xerox> Come back with questions anytime.
13:42:47 <xerox> davidhouse, psi, the proposal is about Cabal.
13:42:53 <MarcWeber> xerox: sure.. My proposal didn't work, why?
13:43:03 <xerox> MarcWeber: err... ?
13:43:24 <davidhouse> xerox, sorry? which proposal? why am i being told?
13:43:35 <xerox> davidhouse: you asked me some time ago today (-:
13:43:38 <MarcWeber> Ah.. Thought your Yes was a reply on my satement.. 
13:44:23 <davidhouse> xerox, ah, your proposal.
13:45:06 <MarcWeber> I just wont use the Reader(T) monad right now.. ;)
13:45:11 <vincenz> sjanssen: http://oasis.yi.org:8080/Darcs.png
13:45:20 <vincenz> sjanssen: notice how the links on the right are --- because of dhcp
13:45:26 <xerox> MarcWeber: why?
13:45:32 <vincenz> blue = working copy, red = server copy
13:45:57 <vincenz> by making it an active process... servers could pull frequently...such that even when you don't continually pull, a cache copy is ready in case others go offline
13:46:14 <vincenz> basically you have a mirrored server
13:46:50 <vincenz> that is not susceptible to people going offline or changing ip
13:47:16 <vincenz> (and obviously each blue communicates with their own red
13:47:17 <davidhouse> @type msum
13:47:18 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
13:48:53 <vincenz> sjanssen: ideally the interface would be such that each blue person only sees their red which represents the whole of the mirrored server
13:49:20 <vincenz> (aka, you can draw a big red abstract circle around all the smaller red ones)
13:49:59 <sjanssen> such a system would be interesting
13:50:02 <Ulfalizer> neat.. vim7 is out
13:50:03 <xerox> vincenz: what about using the dns system for that?
13:50:19 <vincenz> xerox: there's more to it
13:50:25 <vincenz> authentication and authorization for instance
13:50:30 <vincenz> you don't want a fake red circle entering the system
13:50:48 <xerox> How do you authenticate?
13:51:09 <vincenz> most likely pub/priv key
13:51:14 <vincenz> seems the most straightforward
13:51:18 <vincenz> right now we have the left setup
13:51:22 <vincenz> with the server on my comp
13:51:30 <vincenz> and one common ssh account with no pw but many pubkeys
13:51:32 <bofh> lag.
13:51:44 <MarcWeber> xerox: Because I don't know how to use liftIO and ReaderT correctly yet.
13:51:44 <vincenz> but since I'm moving end of june.... we need to either find another server, or switch technique
13:51:55 <xerox> MarcWeber: it's simple.
13:51:58 <xerox> @type liftIO
13:52:01 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
13:52:10 <xerox> It lifts an IO action in your Monad m.
13:52:36 <sjanssen> vincenz: broadcast messages via email?
13:52:55 <davidhouse> MarcWeber: if you need to do IO whilst working in ReaderT _ IO, then just wrap it in liftIO.
13:53:07 <sjanssen> patches, rather than message
13:53:31 <davidhouse> indeed, when you learn about monad transformers, liftIO is just a version of lift which is optimised for lifting IO actions.
13:54:17 <vincenz> sjanssen: not certain
13:54:29 <vincenz> sjanssen: problem with email is that not everyone has a personal email app that works in console
13:54:34 * vincenz uses thunderbird and gmail
13:54:34 <Cale> it'll just save you from applying lift multiple times when you have a stack of transformers, in the special case of IO, since IO is always at the bottom.
13:54:39 <vincenz> they'd need a sendmail installed
13:55:01 <vincenz> sjanssen: I do think it would be an interesting system for multi-user distributed collaboration
13:55:07 <Beelsebob__> > let primes = sieve [2..]; sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p > 0] in take 10 primes
13:55:08 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:55:14 <vincenz> and darcs is ideal cause it can handle desynched patches
13:55:35 <davidhouse> Beelsebob, nice. my attempt when i was learning was:
13:56:14 <Beelsebob__> davidhouse: nothing to do with learning... just wanted to know the first few primes and lambdabot was the easiest way
13:57:01 <davidhouse> > let isPrime p = all (\y -> x `mod` y /= 0) $ takeWhile (\z -> z^2 < x) [2..] in take 10 [ p | p <- [2..] isPrime p ]
13:57:02 <lambdabot>  Not in scope: `p'
13:57:17 <davidhouse> > let isPrime p = all (\y -> p `mod` y /= 0) $ takeWhile (\z -> z^2 < p) [2..] in take 10 [ p | p <- [2..] isPrime p ]
13:57:17 <lambdabot>  Not in scope: `p'
13:57:19 <Beelsebob__> that looks sensible
13:57:31 <Beelsebob__> take a list of integers and test each for primality
13:57:34 <davidhouse> > let isPrime p = all (\y -> p `mod` y /= 0) $ takeWhile (\z -> z^2 < p) [2..] in take 10 [ p | p <- [2..], isPrime p ]
13:57:35 <lambdabot> [2,3,4,5,7,9,11,13,17,19]
13:57:49 <Beelsebob__> but it's buggered somewhere
13:58:02 <davidhouse> hmm. 9 is not prime.
13:58:06 <Beelsebob__> nor is 4
13:58:08 <davidhouse> > let isPrime p = all (\y -> p `mod` y /= 0) $ takeWhile (\z -> z^2 <= p) [2..] in take 10 [ p | p <- [2..], isPrime p ]
13:58:09 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:58:10 <Beelsebob__> you need <=
13:58:14 <davidhouse> ta-da :)
13:58:17 <Beelsebob__> indeed
13:58:19 <Beelsebob__> :)
13:58:33 <Cale> I like the sieve definition.
13:58:48 * xerox too
13:59:00 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in take 10 (sieve [2..])
13:59:01 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:59:40 <davidhouse> yes, i always under-use list comprehensions.
14:00:15 <Beelsebob__> I don't know
14:00:23 <Beelsebob__> I think for the most part map and filter are nicer
14:00:36 <xerox> That's a cool way to write it.  I always hard code values.
14:00:45 <Cale> > let sieve (x:xs) = x : sieve (filter ((/= 0) . (`mod` x)) xs) in take 10 (sieve [2..])
14:00:46 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
14:00:50 <davidhouse> hmm... hang on a minute. that sieve is clever than i thought.
14:00:58 <MarcWeber> davidhouse: I don't understand this yet : http://rafb.net/paste/results/pkfIi795.html
14:01:40 <xerox> davidhouse: right :-)
14:02:29 * davidhouse wonders which is the more efficient
14:02:43 <Beelsebob__> > let sieve (x:xs) = x : sieve (filter (\y -> y `mod` x /= 0) xs) in take 10 (sieve [2..])
14:02:44 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
14:03:08 <Beelsebob__> I would imagine that the list comprehension is rewritten to the filter in the compiler
14:03:22 <davidhouse> MarcWeber: firstly, you don't need the Control.Monad.MonadTrans.liftIO, it should be in scope anyway.
14:03:28 <Cale> MarcWeber: You probably mean to be working in ReaderT Handle IO, but you're just in (->) Handle
14:03:30 <Revision17> @hoogle forall
14:03:30 <lambdabot> Prelude.forall :: keyword
14:03:31 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
14:03:31 <lambdabot> Language.Haskell.TH.forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
14:03:54 <davidhouse> Beelsebob__: i meant my sieve versus the list comp sieve
14:04:27 <Beelsebob__> davidhouse: your sieve... as in testing each one in turn?
14:04:33 <Beelsebob__> I would imagine the list comp by far
14:04:40 <Beelsebob__> but I'll do both and time profile them
14:04:40 <xerox> > let primes = 2 : 3 : [ n | n <- [5,7..], not $ any ((==0). (`mod` n)) (takeWhile (\p -> p*p <= n) primes] in take 20 primes
14:04:41 <lambdabot>  parse error on input `]'
14:04:51 <xerox> > let primes = 2 : 3 : [ n | n <- [5,7..], not $ any ((==0). (`mod` n)) (takeWhile (\p -> p*p <= n) primes)] in take 20 primes
14:04:52 <lambdabot> [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]
14:05:00 <davidhouse> 9 n'est pas prime.
14:05:03 <xerox> o_O
14:05:25 <Sebo> hi
14:05:29 <davidhouse> MarcWeber: also, you'll need runReaderT somewhere if you want to work in ReaderT.
14:06:02 <davidhouse> i think you're trying to be very clever but not understanding what you're doing.
14:06:38 <Sebo> is there a possibility using pattern matching that the list parameter in that function has only one element : blob :: [Integer] -> Integer
14:07:08 <Sebo> e.g. blob x = ...
14:07:20 <davidhouse> you want to match a list with just one element?
14:07:25 <davidhouse> (x:[]) or [x]
14:07:26 <Sebo> yes
14:07:43 <xerox> [x] is cuter :-)
14:08:01 <davidhouse> MarcWeber: my reccomendation is to go and read All About Monads. it'll help a lot.
14:08:55 <Sebo> thanks
14:09:06 <MarcWeber> davidhouse: ;)) I haven't finished yet.. There are some points missing for non genious people .. (IMHO)
14:10:00 <work_metaperl> I'm not sure why my function to calculate the number of roots of an equation did not return 1 root when I thought it should have: M
14:10:12 <work_metaperl> any help is appreciated: http://rafb.net/paste/results/xkWdPy33.html
14:10:49 <davidhouse> MarcWeber: you don't need to be a genius to understand monads. you just need time, lots of reading, and to write and read lots of code.
14:11:05 <vincenz> davidhouse: that applies to all coding concepts
14:11:05 <work_metaperl> Monads as Containers by Cale is a great start
14:11:11 <vincenz> writing > reading
14:11:14 <vincenz> in terms of learning
14:11:16 <work_metaperl> plus the author is write here online
14:11:28 <work_metaperl> could someone please help with my small coding issue: http://rafb.net/paste/results/xkWdPy33.html
14:11:50 <Beelsebob__> davidhouse: your one appears to be faster by about a factor 2
14:12:05 <davidhouse> really? how odd.
14:12:31 <Cale> work_metaperl: b^2 = 16^2
14:12:40 <Beelsebob__> primes2 +RTS -p -RTS - total time  =        2.08 secs
14:12:40 <Beelsebob__> primes1 +RTS -p -RTS - total time  =        5.32 secs
14:12:42 <work_metaperl> oh thanks
14:12:47 <jlhamilton> did you mean to call numberNDroots 1 16 4 instead?
14:12:47 <Beelsebob__> (computing the first 3000 primes)
14:12:55 <jlhamilton> did you mean to call numberNDroots 1 4 4 instead?
14:13:08 <work_metaperl> jlhamilton: yes, thanks
14:15:24 <tromp> C is a bit faster for finding primes it seems...
14:15:58 <monochrom> heh
14:16:54 <tromp> finding the first million primes in 0.024s
14:17:20 <davidhouse> well, this is without _any_ optimisation, tromp.
14:17:53 <xerox> What are you using for benchmarking?
14:17:56 <tromp> i admit the C version is not that pretty:(
14:18:01 <xerox> I want to benchmark my two core beast here.
14:18:29 <davidhouse> tromp, where is it?
14:18:54 <davidhouse> i bet unboxed types and suchlike would improve haskell's performance.
14:19:02 <tromp> http://homepages.cwi.nl/~tromp/pearls.html#sieve
14:20:05 <davidhouse> woah.
14:21:54 <Beelsebob__> tromp: also bear in mind that you have no idea what hardware I just ran that on
14:23:06 <tromp> true; while i ran on a nice opteron box...
14:23:49 * dcoutts notes that we're up to 81 SoC applications as the submission deadline approaches...
14:24:07 <tromp> for a sinclair zx81, your program is pretty fast!
14:24:28 <Cale> 81?
14:24:50 <Beelsebob__> tromp: 0.024 seconds here too
14:24:56 <Cale> where are they all? I don't think I saw anywhere close to that many on the mentor home page
14:25:05 <Beelsebob__> tromp: did my single processor 1Ghz mac just level your shiny opteron?
14:25:20 <Cale> oh, I see
14:25:27 <xerox> Cale: musasabi was reporting that the first arrival are in a better position than the last ones
14:25:28 <tromp> what argument did you use?
14:25:37 <Cale> xerox: yeah
14:25:41 <Beelsebob__> oh... no, you did first million didn't you
14:25:50 <Beelsebob__> what arg did you use and I'll see what mine does
14:25:59 <davidhouse> xerox, how many SoC applications do you expect to be accepted?
14:26:08 <xerox> davidhouse: it is an unknown as now
14:26:16 <davidhouse> roughly?
14:26:28 <xerox> The most? :-)
14:26:35 <davidhouse> :) all right.
14:26:39 <davidhouse> i suppose we'll see.
14:26:39 <tromp> time ./prime -15485900
14:27:06 <Cale> we need to find mentors for most of them it seems
14:27:30 <tromp> i threw in one extra prime for free:)
14:28:11 <Cale> there seems to be a lot of interest in a Haskell shell
14:28:31 <Beelsebob__> tromp: I just discovered a bug in his code... somewhere
14:28:34 <Cale> at least amongst applicants
14:28:37 <davidhouse> well, i'd like to see a shell with lambda.
14:28:55 <sethk> Cale, won't ghci do more or less what a shell could do?
14:28:57 <davidhouse> replacing xargs with something more powerful.
14:29:03 <tromp> what's the bug?
14:29:14 <Beelsebob__> ./primes3 -15485850 produces 999998 primes, while ./primes3 -15485849 produces 1000001
14:29:36 <Beelsebob__> how are there three primes in that one number difference
14:29:56 <Cale> there are 5 applications to write a Haskell shell
14:30:05 <Cale> I wonder if those students could work together.
14:30:05 <tromp> ./prime  -15485850 also gives 1000001 primes found here
14:30:22 <Cale> sethk: ghci isn't really convenient as a system shell
14:30:39 <tromp> oh, that's because it uses one more byte
14:30:48 <tromp> which can result in 8 more primes
14:30:57 <sethk> Cale, no, but with a thin layer it would be
14:31:07 <Beelsebob__> no... that specifies the max prime not the max ram usage
14:31:12 <dcoutts> Cale, but arn't shells dead? Are we really going to change the world with a Haskell shell?
14:31:13 <tromp> so the bound you give gets rounded up to the next multiple of 30
14:31:16 <Beelsebob__> it's max ramusage if you don't put the minus in
14:31:17 <dcoutts> who does it benefit?
14:31:22 <Beelsebob__> ah, I see
14:31:27 * dcoutts doesn't get it
14:31:52 <musasabi> A typed shell with innovative features would be very nice.
14:31:53 * Beelsebob__ will always trade in speed for the program doing what you say it does
14:31:57 <musasabi> Yet another bash not so nice.
14:31:59 <xerox> Cale: they can't for programme contraints
14:32:18 <Cale> sethk: possibly
14:32:49 <xerox> Cale: I mean to reply about working groups of students
14:33:06 <Philippa> Beelsebob: clearly you were never on the demo scene :-)
14:33:12 <Cale> dcoutts: I think there's room for progress there, but as a summer project, it would be hard to do what I'm thinking :)
14:33:27 <kombinator> dcoutts: unix shells are awful
14:33:39 <Cale> dcoutts: It would be nice to have a typed interface between system applications.
14:34:04 <dcoutts> kombinator, true, but who is actually going to use an alternative?
14:34:05 <kombinator> dcoutts: as soon as you want to write a non-trivial script you face grotesque problems
14:34:34 <Cale> dcoutts: the problem is mostly in making it actually convenient for everyday use
14:34:41 <Cale> which involves a lot of effort
14:34:53 <tromp> i found bash useful for a non-trivial script
14:35:00 <dcoutts> I can see some benefit in a library for handling shell-like tasks, but yet another interactive shell? I can't see anyone using it.
14:35:05 <Cale> I've written an IRC bot in bash before.
14:35:23 <Cale> After a certain point, it becomes really hard to maintain :)
14:35:31 <dcoutts> bash isn't that bad so long as one is aware of it's limitations
14:35:39 <dcoutts> and one doesn't try to do anything too complex
14:35:51 <tromp> let's say it's ok for scripts upto 2 pages long:)
14:35:53 <dcoutts> but Id say, that's not what a shell is for anyway
14:35:59 <jethr0> Cale: i've got a recurring problem. i want to "hide" a datatype's constructor but still be able to use the deconstructor. is that possible?
14:36:14 <xerox> jethr0: define a function which destructs and export it
14:36:26 <Cale> jethr0: nope -- you can provide functions to extract the components though
14:36:44 <jethr0> xerox: i mean for pattern matching... is it possible to define a pattern matchable deconstructor function?
14:36:50 <Cale> no
14:36:54 <xerox> No.
14:37:04 <jethr0> hmm, that's a real problem then. i might even say a drawback
14:37:10 <Cale> (but things like this have been talked about)
14:37:33 <jlenor1_> hullo
14:37:39 <Cale> hi
14:37:44 <jethr0> i have repeatedly had the wish to restrict the constructor but still be able to pattern match
14:37:54 <laurence> The problem with shells is that too much of the *OS* is written in sh.  Sure, there are *lots* improved shells, for various figures-of-merit.  Guess what?  The people who really write a lot of shell scripts write to the lowest common denominator, sh.
14:38:25 <Cale> laurence: yeah -- I'd like to see an OS which enforces a type system
14:38:38 <jethr0> i love bash for one liners and scripts that came from one liners. but i'd never even think about writing an "application" in shell
14:38:46 <palomer_> is it possible to parse a cabal file to find all the source files which contain the sources to the modules you've imported?
14:39:19 <norpan> hey what's up
14:40:01 <mrchebas> jethr0: could you just define an extra data type to do pattern matching on it? Sort of fake views
14:40:12 <jethr0> mrchebas: hmm, interesting
14:40:37 <jethr0> mrchebas: but how would they interact? i have no idea how you propose to implement this
14:40:45 <dcoutts> dons, if we're clever we ought to be able to get list and array fusion on ByteString.Lazy
14:41:03 <palomer_> what kind of deliverables would be needed for the SoC? isn't it just the source and documentation?
14:41:15 <kolmodin> g'night
14:41:24 <work_metaperl> kolmodin: good night
14:41:37 <laurence> Cale: Fine, there is no question that sh is hideous (I believe that no formal grammar even exists).  But to replace it, you don't only have to write a shell: you then must re-write the entire unix init system, and give it a million hours or so of production torture-testing so *real* unix admins (who don't generally give a fig about languages per se) believe it's as reliable as, or at least that it's infelicities are at least as 
14:41:37 <laurence> well understood as, that of unix.
14:41:50 <Beelsebob__> anyone got any relatively small code that uses lambda expressions for something more than just simple calculations?
14:41:54 * laurence fears that that small project might not be enough.
14:42:15 <mrchebas> jethr0: data A; data A' = C1 Int | C2 Bool; matchA :: A -> A'
14:42:29 <jethr0> hmm
14:42:30 <laurence> jethr0: Here's your new web server: http://lug.umbc.edu/%7Emabzug1/bash-httpd.html
14:42:32 <mrchebas> jethr0: case matchA (x::A) of ...
14:42:46 <Cale> laurence: yeah, I was discussing the design of an init replacement with a friend of mine about a year ago
14:43:33 <dcoutts> palomer_, pretty much yes.
14:43:59 <laurence> Cale: I also fear in the end the real discovery would be that some of sh's worst infelicities, including lack of typing, turn out to be precisely the reason it works for it's job. :-(
14:44:50 <vincenz> laurence: o.O
14:45:19 <tromp> what for, beelsebob?
14:45:21 <Cale> laurence: It would be nice to have a system which understood component dependencies and did a topological sort of the items automatically, rather than relying on the user to sort them correctly. It would also let you start multiple tasks at the same time.
14:45:22 <work_metaperl> have you seen the paper Unix as a 4th Generation Language?
14:45:34 <Cale> (as a replacement init)
14:45:36 <vincenz> Cale: dependencies of what
14:45:44 <Cale> vincenz: system services
14:45:44 <work_metaperl> http://www.rdb.com/lib/4gl.pdf
14:45:53 <vincenz> shouldn't be difficult should it?
14:45:59 <Beelsebob__> tromp: examples to run through on paper for how to make a debuger work on them
14:46:07 <vincenz> there are algos that linearize DAG
14:46:22 <Beelsebob__> it's hard to see what will work with really really simple examples because everything works
14:46:51 <laurence> Cale: Yeah, dependencies are probably the worst flaw of both SysV and BSD inits.  But it's getting solved without changing languages, for better for worse.  Gentoo and NetBSD both have dependency-based init scripts, at least.
14:46:57 <tromp> you want lambda expressions that do complicated computations?
14:47:13 <vincenz> laurence: is there a possibility of creating a DAG of the dependnecies?
14:47:20 <Beelsebob__> OS X's init system (launchd) computes the dependancy graph automatically
14:47:29 <Cale> laurence: well yeah, for init, I'd almost want something with configuration files that look somewhat like cabal files :)
14:47:32 <Beelsebob__> tromp: relatively so... CPS or some such
14:47:34 <vincenz> Beelsebob__: and then linearizes it
14:47:36 <laurence> Cale: cabal?
14:47:41 <vincenz> Beelsebob__: ?
14:47:56 <Beelsebob__> vincenz: depends on the computer - it paralelises as much as is efficient and possible
14:48:02 <tromp> you cld try the lambda calculus interpreter i wrote in lambda calculus
14:48:08 <Cale> well, you might not be familiar with their syntax -- it's just a small declarative language
14:48:13 <vincenz> Beelsebob__: ah, right
14:48:14 <Beelsebob__> tromp: that would be useful
14:48:17 <vincenz> Beelsebob__: I assume it does DAG only
14:48:38 <Beelsebob__> vincenz: I assume so - I've never tried a cyclic dependancy in it
14:48:46 <Cale> which isn't anything close to Turing complete, but it's enough to specify what is needed
14:49:40 <tromp> it's at the end of my paper at http://homepages.cwi.nl/~tromp/cl/LC.pdf
14:50:14 <Beelsebob__> OUCH!
14:50:19 <Beelsebob__> that's quite cool
14:50:24 <Beelsebob__> and very shiny
14:50:49 <laurence> vincenz: I believe Gentoo claims to have mostly cracked the problem of parallelizing their init services.  But they admit they had it wrong for some time, so apparently there are hidden beartraps.
14:51:39 <vincenz> laurence: tbh, it doesn't seem THAT complex
14:51:56 <vincenz> laurence: linearize and then run a parallelizing algo on it using as constraints the depndencies
14:52:48 <laurence> vincenz: The basic algorithm wasn't the problem: I gather it was in identifying what the true dependencies really are.  Probably made much, much worse by Gentoo's excessive configurability. :-)
14:52:56 <vincenz> ah :)
14:53:27 <palomer_> what's that application to annotate haskell code?
14:54:04 <laurence> vincenz: NetBSD controls their own core OS, so I imagine it was better for them.  But still it wouldn't surprise me if it just turned out that unix has grown some wierd assumptions that nobody ever had to make explicit.
14:55:27 <vincenz> laurence: yeah OS's are messy by definition
14:55:54 <isaacd> palomer: haddock?
14:56:04 <sjanssen> vincenz: Gentoo has a few odd things that aren't dependencies, but do impact ordering.  For example, automatically loading device drivers is not a dependency of starting networking per se, the network module may be compiled into the kernel.  However, if it isn't you want auto loading to happen before networking
14:56:07 <laurence> vincenz: Mature production quality ones most of all. :-)  It's real easy for hobby, research, and specialty OS's to be clean.
14:56:56 <vincenz> laurence: Anything can be made that is clean, easy, and basically wrong
14:56:59 <psi> am I misunderstanding something? in the following, runGst receives null as its argument:
14:57:00 <psi> foreign import ccall "gst_ffi" runGst :: CString -> IO CInt
14:57:00 <psi> main = withCString "file:///home/simon/gst/op66.mp3" runGst
14:57:28 <laurence> sjanssen: Hah, someone who understands Gentoo init scripts.  'Fess up to the gory details. :-)
14:57:28 <eivuokko> Is there a standard flag on gnu software to print out easily parseable version?  I sort of need that for Cabal.
14:57:41 <vincenz> eivuokko: --version?
14:57:53 <eivuokko> vincenz, Not easily parseable atleast for binutils
14:58:07 <Zarvok> Anyone know if there are haskell IRC libraries?
14:58:28 <eivuokko> Zarvok, check out lambdabot source and there was some irc client written too.
14:58:30 <musasabi> Zarvok: lambdabot has irc parsing code.
14:58:36 <eivuokko> @where lambdabot
14:58:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:58:42 <Zarvok> thanks
14:59:02 <Cale> @version
14:59:03 <lambdabot> lambdabot 3p427, GHC 6.4.1 (Linux i686 3.20GHz)
14:59:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:59:05 <laurence> eivuokko: $(FOO) --version | egrep/sed/awk/whatever :-)
14:59:08 <sethk> eivuokko, there is --version, but I'm not sure how consistent the output is
14:59:08 <notanotheridiot> just submitted a revised version of my SOC application
14:59:24 <vincenz> eivuokko: you could make a file containing different version formats
14:59:32 <vincenz> eivuokko: and have the program read these in and generate parsers out of em
14:59:37 <dcoutts> notanotheridiot, good good
14:59:40 <eivuokko> Zarvok, When searching libraries it is a good idea to check haskell and haskell-cafe mailing list archives for announcements
15:00:00 <vincenz> notanotheridiot: you're -the-? :P
15:00:06 <Zarvok> thanks, I'll check that out
15:00:23 <eivuokko> vincenz, laurence, sethk, Thanks.  Version indeed requires program-related knowledge to parse.
15:00:30 <notanotheridiot> vincenz, I'm Johannes woolard, submitted gstreamer bindings
15:00:45 <sjanssen> Zarvok: there are also archived announcements on the wiki, they go all the way back to the early 90s
15:00:50 <vincenz> notanotheridiot: No I was just joking regarding your nick "notanother", so maybe you were the original
15:01:28 <eivuokko> Ah, so, again simple fix of adding ld/ar @file-support to Cabal turns into many-hours into deep Cabal.
15:01:37 <vincenz> notanotherxxx is ambiguous
15:02:03 <vincenz> depending on whether you stress 'not' or 'another'
15:02:15 <sethk> should be yetanotheridiot, not yesanotheridiot, you idiot  :)
15:02:28 <yesanotheridiot> tis on another - lol
15:02:39 <vincenz> yesanotheridiot: so you are the original idiot
15:02:46 <sjanssen> how about theplatonicidealofanidiot?
15:02:55 <vincenz> sjanssen: only if you buy into platonics
15:03:20 <vincenz> sjanssen: he could be the instantation of the original idiot, which would then not be platonic but the first socratic example (socrates or aristotle?  keep forgetting)
15:03:24 <vincenz> aristotlian
15:03:44 * vincenz whistles
15:04:19 * justanotheconfus wonders why irc nicks cant't be over 30 characters
15:04:41 <rashakil> you have to have some limit
15:04:56 <sjanssen> vincenz: I'm not an actual philosopher, I just play one on TV ;-)
15:04:58 * a wonders why nicks can be a single letter
15:05:20 <a> especially with _ (which is currently taken) that gets annoying
15:05:27 * I can't believe it either.
15:05:34 * a )
15:06:03 * _-_
15:06:25 <sethk> cale you isn't I
15:07:37 * vincenz hmms
15:08:34 <vincenz> hey...if a monad fails in a lower monad
15:08:37 <vincenz> is the computation halted?
15:08:49 <vincenz> lift . fail $ "BLABLA"
15:09:27 <sjanssen> vincenz: depends on the inner monad
15:09:34 <vincenz> alright
15:09:43 <isaacd> > fromJust $ lift . fail $ "BLABLA"
15:09:44 <lambdabot> Couldn't match `Maybe' against `t m'
15:09:54 <isaacd> @type lift
15:09:55 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *).
15:09:55 <lambdabot>    (MonadTrans t, Monad m) =>
15:09:55 <lambdabot>    m a -> t m a
15:09:58 <vincenz> isaacd: you'll need a monad transformer
15:10:02 <isaacd> oh
15:10:15 <psi> heh! I had a main in both my .c and .hs file. no wonder it didn't work.
15:10:17 <mgoetze> uh, so i have a file which says on line 5: "data Turn		=  Btp | Wtp"
15:10:25 <vincenz> > fromJust $ evalState (lift . fail $ "BLABLA")
15:10:26 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
15:10:29 <mgoetze> then i try to load it in ghci and it says: alphabeta.hs:5: Illegal data/newtype declaration
15:10:30 <vincenz> > fromJust $ evalState (lift . fail $ "BLABLA") ()
15:10:31 <lambdabot> Couldn't match kind `* -> * -> *' against `(* -> *) -> * -> *'
15:10:38 <vincenz> @type evalStateT
15:10:39 <lambdabot> forall a (m :: * -> *) s.
15:10:40 <lambdabot>      (Monad m) =>
15:10:40 <lambdabot>      StateT s m a -> s -> m a
15:10:44 <vincenz> > fromJust $ evalStateT (lift . fail $ "BLABLA") ()
15:10:45 <lambdabot> Add a type signature
15:10:46 <mgoetze> what did i do wrong?
15:10:52 <vincenz> > fromJust $ evalStateT (lift . fail $ "BLABLA") () :: Int
15:10:53 <lambdabot> Exception: Maybe.fromJust: Nothing
15:10:57 <vincenz> \o/
15:11:25 <sjanssen> mgoetze: that looks okay.  what are the lines immediately before and after?
15:11:26 <vincenz> mgoetze: Mind putting the source code onto a paste site?
15:12:36 <mgoetze> http://www.mgoetze.net/~mgoetze/alphabeta.hs
15:12:58 <vincenz> data Board=  [[Intersection]]
15:13:02 <vincenz> that should be type Board = 
15:13:08 <vincenz> or you should add a data constructor
15:13:11 <mgoetze> oh, ok
15:13:48 <mgoetze> thanks
15:14:37 <mgoetze> now i get: alphabeta.hs:13: parse error on input `)'
15:15:29 <mgoetze> maybe it doesn't like the (++ " " ++) construct
15:15:55 <vincenz> btw
15:16:01 <vincenz> no need to add () around the outer most calls
15:16:05 <vincenz> func apps bind more tightly
15:16:24 <Cale> mgoetze: yeah, you can't do a section on two sides
15:16:32 <vincenz> > (++ " " ++)
15:16:32 <lambdabot>  parse error on input `)'
15:16:37 <mgoetze> ok :) i generally prefer to add the () before the compiler complains
15:16:38 <vincenz> > (flip (++) " " ++)
15:16:39 <lambdabot> Couldn't match `[a]' against `t -> t1'
15:16:52 <vincenz> @pl \a b -> a ++ "x" ++ 
15:16:53 <lambdabot> (line 1, column 21):
15:16:53 <lambdabot> unexpected end of input
15:16:53 <lambdabot> expecting space or simple term
15:16:53 <vincenz> @pl \a b -> a ++ "x" ++ b
15:16:54 <lambdabot> (. ('x' :)) . (++)
15:17:25 <mgoetze> ok, got that one sorted out
15:18:04 <vincenz> btw
15:18:17 <vincenz> foldr (++ " " ++) should be unwords
15:18:23 <vincenz> > unwords ["x", "y", "z"]
15:18:24 <lambdabot> "x y z"
15:18:37 <mgoetze> now i get errors for defining show on those synonyms, so i guess i'll have to add a constructor?
15:18:47 <vincenz> mgoetze: make a data constructor 
15:18:49 <norpan> weee vim 7
15:18:52 <Cale> mgoetze: yeah, use newtype
15:19:03 <vincenz> norpan: yeah.. .sadly yahoo sucks so we can't read the announce
15:19:17 <Cale> newtype MyType = Tag OldType
15:19:37 <vincenz> data Board= Board [[Intersection]]
15:20:06 <mgoetze> uh, what's the difference between newtype and data again?
15:20:06 <Cale> newtype Board = Board [[Intersection]]
15:20:17 <vincenz> is [] the only contra-infix data constructor around?
15:20:29 <Cale> newtype is somewhat more efficient, and you can use deriving to derive any class for it which was supported on the old type
15:20:38 <xerox> Circumfix :-)
15:20:42 <vincenz> xerox: thx
15:21:00 <Cale> vincenz: not quite
15:21:04 <norpan> vincenz: how about (,)
15:21:05 <vincenz> Cale: oh?
15:21:06 <Cale> > (,) 5 6
15:21:07 <lambdabot> (5,6)
15:21:08 <vincenz> hmm
15:21:15 <vincenz> how about user-definable ones?
15:21:18 <xerox> > [] 1
15:21:18 <lambdabot> Couldn't match `[a]' against `t -> t1'
15:21:21 <xerox> heh.
15:21:24 <Cale> nope, you can't define your own
15:21:28 <vincenz> only infix ones
15:21:29 <mgoetze> ok, and now: alphabeta.hs:16: parse error (possibly incorrect indentation)
15:21:33 <jethr0> > ([]) 1
15:21:33 <lambdabot> Couldn't match `[a]' against `t -> t1'
15:21:39 <vincenz> data Plop = a :> b
15:21:48 <vincenz> how about symbolic typecons?
15:21:54 <xerox> If anybody knows the TH hackery useful to define a circumfix operator it can be done in lambdabot now.
15:22:03 <Cale> vincenz: in newer GHCs
15:22:14 <vincenz> Cale: 6.5?
15:22:22 <vincenz> so
15:22:25 <Cale> 6.5 and maybe some support in 6.4
15:22:26 <vincenz> data a :> b = a :> b
15:22:34 <work_metaperl> what do I import to sort a list numerically? how would I research this for myself?
15:22:49 <jethr0> @index sort
15:22:50 <lambdabot> Data.List
15:23:00 <work_metaperl> jethr0: thanks
15:23:01 <jethr0> @index sortBy
15:23:02 <lambdabot> Data.List
15:23:03 <Cale> @hoogle (Ord a) => [a] -> [a]
15:23:03 <lambdabot> List.sort :: Ord a => [a] -> [a]
15:23:04 <lambdabot> Data.Graph.Inductive.Internal.Heap.heapsort :: Ord a => [a] -> [a]
15:23:04 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
15:23:30 <work_metaperl> wow, the help keeps coming :)
15:23:33 <vincenz> Cale: so something like
15:23:34 <vincenz> data a :> b = a :> b
15:23:48 <Cale> vincenz: yeah, you can do that
15:23:51 <vincenz> kewl
15:23:59 <vincenz> what if one param is defined already
15:24:05 <vincenz> data :> b = Foo :> b
15:24:16 <norpan> nope
15:24:19 <Cale> then you wouldn't use an infix symbol
15:24:23 * vincenz hmms
15:24:24 <Cale> for the type name
15:24:31 <Cale> you could still use it for the data constructor
15:24:32 <vincenz> well I find it useful to match tycon and datacon for single datacon types
15:24:53 <vincenz> is it then possible to define the fixity of the tycon?
15:24:57 <Cale> yep
15:25:02 <vincenz> even the tycon?
15:25:04 <Cale> same way as for anything
15:25:04 <vincenz> neat :)
15:25:21 <Cale> I haven't tried it, but it should work
15:25:39 <vincenz> plop (a :> b :> c) = "ChooChoo"
15:25:49 <norpan> he has gone bananas
15:25:56 <vincenz> no it's a train, silly
15:26:29 <Cale> I've gone barbed-wire
15:26:34 <mgoetze> so now i get errors such as "    Couldn't match `[[a]]' against `Board'" when trying to use functions like head
15:26:47 <vincenz> Cale: you mean the show with Pamela Anderson?
15:26:49 <mgoetze> is there something i can derive, or do i need to put a constructor somewhere?
15:27:04 <Cale> vincenz: I was making an allusion to a particular paper
15:27:17 <vincenz> yeah I heard something about that, haven't read it to
15:27:20 <Cale> mgoetze: you need to pattern match away your constructor
15:27:25 <vincenz> mgoetze: make sure to match the con
15:27:35 <vincenz> show (Board x) = ...stuff with x
15:28:38 <mgoetze> ok, thanks... now i need to get my parens straight...
15:28:44 <vincenz> any solution for cleaning up this mess: http://rafb.net/paste/results/z5o6Ej90.html
15:29:06 * vincenz wishes patterns were first class
15:29:53 <mgoetze>     Couldn't match `[Char] -> [Char]' against `String'
15:29:53 <mgoetze>     In the first argument of `foldr', namely `unwords'
15:30:11 <mgoetze> hm hm hm
15:30:17 <Cale> mgoetze: what are you passing to foldr?
15:30:20 <musasabi> A
15:31:22 <mgoetze> i uploaded the version with this error: http://www.mgoetze.net/~mgoetze/alphabeta.hs
15:31:46 <vincenz> mgoetze: don't foldr unwords
15:32:28 <mgoetze> ah, so just unwords ((map show y) ++ "|\n"), right?
15:33:09 <vincenz> mauke: ++ (map (\y -> "| " ++ (unwords "|\n" (map show y)) ++ "|\n") x)
15:33:18 <vincenz> whoops
15:33:24 <vincenz> remove the first "|\n"
15:34:23 <mgoetze> vincenz: thanks
15:34:35 <work_metaperl> unwords should take an optional argument for what to join the words with
15:34:47 <vincenz> mgoetze: http://rafb.net/paste/results/Zh86HW17.html
15:35:05 <norpan> we don't do optional arguments
15:35:21 <norpan> for that we have concat . intersperse
15:35:37 <vincenz> http://rafb.net/paste/results/hTDIQ747.html
15:35:56 <norpan> i mean intersperse
15:36:17 <Cale> work_metaperl: what would the type of unwords be in that case?
15:37:01 <norpan> huh, i wrote intersperse right the first time and then read it wrong :)
15:37:23 <vincenz> @type unwords
15:37:24 <lambdabot> [String] -> String
15:37:42 <vincenz> mgoetze: seen the latest one?
15:37:43 <Cale> vincenz: I'm talking about if it took an optional parameter
15:37:45 <work_metaperl> @type intersperse
15:37:47 <lambdabot> forall a. a -> [a] -> [a]
15:37:55 <mgoetze> vincenz: yup, copying it now, thanks :)
15:38:10 <work_metaperl> Cale: I dont know how it would look, but you agree I'm making sense?
15:38:13 <vincenz> Cale: wrong person?
15:38:37 <norpan> £
15:38:51 <Cale> vincenz: thought you were responding to me
15:39:00 <vincenz> Cale: nope
15:39:11 <vincenz> was checking if unwords was
15:39:13 <vincenz> [String] -> String
15:39:20 <vincenz> or (Show a) => [a] -> String
15:39:25 <Cale> work_metaperl: I'm just pointing out how it would be awkward to have optional parameters
15:39:37 <work_metaperl> http://www.zvon.org/other/haskell/Outputprelude/unwords_f.html
15:39:48 <vincenz> mgoetze: there's an even cleaner solution
15:40:03 <Cale> work_metaperl: things like optional parameters would make type inference really hard and could even cause it to miss some things which are actually bugs
15:40:09 <norpan> @type (join .) . intersperse
15:40:10 <lambdabot> forall a. [a] -> [[a]] -> [a]
15:40:19 <norpan> there you go
15:41:01 <Cale> @type let f Nothing xs = unwords xs; f (Just x) xs = concat (intersperse x xs) in f
15:41:03 <lambdabot> Maybe [Char]
15:41:03 <lambdabot>                            -> [String]
15:41:03 <lambdabot>                            -> String
15:41:11 <mgoetze> whee, it works! but please, do tell, vincenz 
15:41:37 <Cale> there's a sort of 'optional parameter', but it's clunkier to use than just having two separate functions
15:43:32 <Cale> someone should write a Go program in Haskell with Gtk2Hs in which one can play go on an arbitrary graph :)
15:44:07 <xerox> Yesh!!
15:44:13 <xerox> Cale: we have some code/ideas!
15:44:26 <norpan> go on an arbitrary graph?
15:44:36 <norpan> that would be mind boggling
15:44:45 <xerox> Like toroidal Go, Pyramid Go, Klein's bottle Go.
15:45:08 <Cale> I've played toroidal and Klein bottle go before.
15:45:19 <Cale> ladders are really odd on the Klein bottle
15:45:24 <xerox> hehe
15:45:30 <xerox> (Quote that)
15:45:33 <mgoetze> i'd rather have an open source go server written in haskell ;)
15:45:44 <xerox> Well, such a modular client would allow everything
15:46:20 <xerox> In fact I was thinking about making a GUI completely discerned from the backends; which will talk to them via GTP or soemthing (astrolabe implemented that protocol!)
15:46:48 <vincenz> mgoetze: working on it
15:48:20 <mgoetze> then again, i don't have enough time for go servers in my life presently, i even wonder that i'm still an assistant on kgs
15:49:34 <vincenz> mgoetze: http://rafb.net/paste/results/FwFFQ744.html
15:49:40 <vincenz> ;)
15:50:14 <vincenz> and I tested, it should be +2
15:50:22 <vincenz> mgoetze: fits on one line now :D
15:51:13 <mgoetze> yeah but GTP doesn't support toroidal go, or a lot of other things for that matter
15:51:52 * laurence wakes up and notices a non-Euclidean geometry discussion.
15:51:54 <mgoetze> we need a good standard go client<-->server protocol, one which supports stuff like kgs (live reviews, etc.)
15:52:03 <vincenz> mgoetze: looked?
15:52:09 <mgoetze> vincenz: looking
15:52:12 <vincenz> :)
15:52:14 <vincenz> the key is showList
15:52:23 <mgoetze> vincenz: it's not a legal board position though :P
15:52:27 <vincenz> which then allows you to do (show x) where x is a list of elements
15:52:48 <vincenz> exceptt that showList is of type [a] -> ShowS
15:53:17 <laurence> Cale: Will you allow arbitrary dimensions and non-well behaved spaces as well?  I see you've already allowed non-orientable spaces....
15:54:05 * mgoetze doesn't even want to think about go in that sort of space... difficult enough on a normal square
15:54:06 <xerox> laurence: what is a non-well behaved space?
15:54:11 <shapr> mgoetze: I thought someone already wrote one? astrolabe maybe?
15:54:32 <vincenz> slightly cleaner: http://rafb.net/paste/results/VYihxC68.html
15:54:38 <vincenz> shapr: yeah astrolabe
15:55:01 <vincenz> laurence: we should allow those funny spaces, forgot the name, where several dimensions are collapsed
15:55:05 <mgoetze> shapr: if it's the GTP implementation referred to earlier, that's meant to be a go client<-->engine protocol, not client<-->server
15:55:21 <vincenz> mgoetze: what server are you targetting?
15:55:29 <laurence> xerox: Depends on your notions of good behavior.  I'm not a Go player but since it knows about ajacency, it has some notion of metric.  But some spaces don't admit a metric....
15:55:44 <vincenz> laurence: adjacency is not metric
15:55:45 <xerox> laurence: that is interesting.
15:55:49 <mgoetze> vincenz: one which doesn't exist yet, i'm afraid :( but a good protocol would help if someone ever wrote one
15:55:51 <vincenz> laurence: any bidigraph will do
15:56:12 <laurence> vincenz: No, but it's a crude notion of distance.  We might be able to get it into trouble. :-)
15:56:12 <shapr> Cale: I think there was an arbitrary shaped Go game client/server written by one of Lunar^'s friends.
15:56:21 <vincenz> laurence: you don't need distance, just adjancency
15:56:23 <shapr> We played it once, it was cool.
15:56:30 <shapr> We played on a torus.
15:56:33 <vincenz> laurence: so any graph world will suffice, granted, bidirectionality makes it cleaner
15:56:46 <vincenz> but even that is not a requisite
15:56:57 <mahogny> well, someone write a Go networking library! very simple protocol (don't like it really). nice game though :)
15:57:36 <laurence> vincenz: Hmm.  I suppose--keep in mind that I regard discrete math as an approximation of reality. :-)  So I always think in terms of differential geometry even when it isn't really the right tool.  Now that you point it out, Go is indeed a game on a graph and not a manifold.
15:57:36 <xerox> shapr: yes, I remember it too.
15:57:40 <xerox> hGo or something
15:57:41 <vincenz> laurence: in fact I think that any graph suffices, then to determine area, just start at all empty spots and see if you meet a unilateral world
15:57:43 <xerox> It was 3D.
15:57:54 <vincenz> wall even, not world
15:58:24 <vincenz> s/unilateral/unicolor
15:58:38 * vincenz sighs
15:58:55 <vincenz> that would be cool, just take a 2d board, and remove some links to make em unidirectional
15:59:07 <vincenz> and add some crossboard links ala smallworlds
15:59:26 <mgoetze> laurence is reminding me that i should be doing analysis homework instead of writing haskell... or better yet, sleeping... argh
15:59:30 * mahogny thinks someone is wrecking the game here :(
15:59:45 <vincenz> assuming you're using a digraph
15:59:57 <vincenz> if not, just add some links to make it a smallworlds
16:00:15 <vincenz> :D
16:00:56 <laurence> vincenz: Yes, but I don't see the need for a concept of area.  Don't you just define a set S of spaces/intersections and a set of ajacency sets {A} over S with an injection S -> {A}?  What additional constraints are needed?
16:01:07 <vincenz> laurence: I never said there is a need for a concept
16:01:30 <vincenz> laurence: except for scoring, at which point you take all empty nodes {N} and apply sub*
16:01:34 <vincenz> err suc
16:01:43 <vincenz> and see if the edge you meet is unicolor if it exists at all
16:02:25 <mahogny> take the chromatic number instead of the area. let the player think a bit ;)
16:02:34 <vincenz> chromatic number?
16:02:42 <mahogny> related to graph coloring
16:03:03 <mahogny> bbl
16:03:14 <laurence> vincenz: Ah, I hardly remember the rules.  Let's see, you win based on *enclosed* area, right?  OK, then your definition seems sufficient if I follow it, but my discrete math is much rustier than my continuous.
16:03:23 <vincenz> let allofarea = untilNotChanging $ map (ifIsEmptynext) nodes.... if sum color of allarea = unicolor, then that color owns those dots
16:03:43 <laurence> Hey, if you play on a torus how do you determine which is the part you're "enclosing"?
16:03:53 <vincenz> laurence: same as the center of the board I assume
16:04:04 <vincenz> the concept is the same, expand until you can't move or hit a color
16:04:19 <vincenz> (floodfill on empties)
16:04:52 <mgoetze> vincenz: thanks for your help, i hope to learn more by studying the code you gave me :)
16:04:55 <laurence> I play on a sphere and enclose a circle.  Do I get to claim the smaller or the larger (in general) region which my pieces bound?
16:04:58 <vincenz> mgoetze: welcome
16:05:09 <vincenz> laurence: well both if there's no other color on either side
16:05:38 <laurence> Maybe both...yeah, I was thinking that way.  It probably works OK.
16:05:41 <vincenz> you're assuming there's no opponent pieces, otherwise any areas touching both are owned by none
16:06:08 <vincenz> same goes for a rectangular board
16:06:14 <vincenz> put one black piece on the board and end the game
16:06:15 <vincenz> black owns all
16:06:21 <mgoetze> now for the hard part, generating a list of all possible moves
16:06:23 <laurence> Now I play on a torus and make a closed ring around the doughnut.  Did I enclose anything?  Does the answer depend on which way I went "around"? :-)
16:06:47 <vincenz> mgoetze: easy...:  filter notKo . filter notSuicide . filter Empty $ board
16:07:03 <laurence> vincenz: No, I'm trying to figure out if the rules remain consistent with ideal cases.
16:07:16 <mgoetze> vincenz: i'm more worried about removing captured pieces ;)
16:07:29 <vincenz> laurence: the concept of enclosure is only necessary when there are opponent pieces at play... otherwise all empties touching your color are yours
16:07:30 <int-e> laurence: if you have a connected board and place a single stone on it, and your opponent passes, you've 'enclosed' all remaining intersections of the board
16:08:04 <vincenz> what int-e said
16:08:15 <vincenz> however it gets more tricky on digraphs
16:08:18 <laurence> I play on a non-orientable surface, something simple like a mobius strip.  It has only one side, so I can play anywhere on it...that board is going to be hard to construct.  Maybe with magnetic pieces.
16:08:33 <eivuokko> Again a bit off-topic question, trying to find a way for a simple Cabal fix...is there a way to split "ld -r -x -o foo bar1 bar2 .. barN" into multiple commands but still outputting same foo?
16:08:54 <vincenz> cause on digraph, the empty maybe touching you, but you may not be touching the empty :P
16:09:42 <laurence> int-e: The question was meant to get at what portions I have to check for opposing pieces.  Apparently all of them on most surfaces.
16:09:46 <vincenz> B -> . -> W   who owns .?
16:10:19 <laurence> vincenz: Yes, I hadn't even gotten as far as asking if there is a unique or preferred extension to digraphs. :-)
16:10:20 <int-e> vincenz: using directed graphs makes the game too much unlike go for my taste
16:10:20 <vincenz> or on a two node board:   B -> .      does B own .?
16:10:22 <mgoetze> i suppose you could play on non-discrete topologies as well, as long as you have a metric with values in {0, 1, infty}
16:10:31 <vincenz> int-e: well it's easy for surrounding
16:10:40 <vincenz> int-e: the enemy doesn't need to touch you, if you're out of liberties, you're out
16:10:54 <vincenz> . -> B -> W   B is dead
16:11:03 <vincenz> erm so is W
16:11:06 <vincenz> . -> B -> W -> .  B is dead
16:11:38 <vincenz> (it can't 'flow' anywhere)
16:11:55 <vincenz> but enough of my ot blabbering
16:12:00 <xerox> If you identify the side of a moebius strip, you get.... ?
16:12:14 <vincenz> I fail to see the difficulty with a moebius strip
16:12:18 <vincenz> it's just a board
16:12:26 <int-e> vincenz: even the direction of arrows is arbitrary. I could say 'B can still breathe, W can't'
16:12:38 <vincenz> int-e: yeah, I guess the same as who owns what
16:12:50 <xerox> Have fun.  Goodnight.
16:12:52 <vincenz> you'd need an extra rule
16:13:39 <mgoetze> basically, there are two variants: one where the direction of liberties is the same as the direction of control, and one where they are opposite
16:13:45 <vincenz> int-e: it would be cool tho, cause on digraph you can make structures with one eye that live
16:13:52 <mgoetze> then you need to figure out which of them, if either, is consistent
16:14:01 <vincenz> I think
16:15:01 <vincenz> for instance
16:15:16 <vincenz> hmm
16:15:19 <vincenz> can't think of anything
16:15:22 * vincenz is off
16:15:55 <vincenz> oh yeah
16:15:59 <vincenz> . <- B
16:16:11 <vincenz> int-e: assuming my definition, W can't move in to kill B, cause even if B is gone it won't have liberties
16:17:11 <work_metaperl> given howManyEqual a b c =  fromEnum(a == b) + fromEnum(b == c) + fromEnum(a == c)    -- how would I right howManyEqual a b c d
16:17:20 <Cale> you can play go on an arbitrary topological space even
16:17:38 <vincenz> Cale: yeah we were discussing that, the fundamental requirement is a graph
16:17:45 <vincenz> Cale: tho you'd need an extra rule for digraphs
16:18:04 <vincenz> work_metaperl: can't overload functions
16:18:11 <Cale> http://www.nrinstruments.demon.co.uk/topologo/topologo.html
16:18:31 <vincenz> Cale: what's a topological space? an undirected graph?
16:18:36 <mgoetze> vincenz: according to new zealand rules (which i consider to be the best), white could move in and then you end up with . <- .
16:18:42 <work_metaperl> vincenz: what If I name it howManyEqual 
16:18:46 <work_metaperl> vincenz: what If I name it howManyEqualFour
16:18:58 <vincenz> mgoetze: you can play a suicide move?
16:18:59 <Cale> no, it's just a set with a collection of subsets which are called 'open', which have to satisfy a couple of properties
16:19:06 <mgoetze> vincenz: aye
16:19:19 <vincenz> mgoetze: how does that ever manifest itself in real go?
16:19:31 <Cale> http://en.wikipedia.org/wiki/Topological_space
16:19:37 <Cale> A topological space is a set X together with a collection T of subsets of X satisfying the following axioms:
16:19:37 <Cale>    1. The empty set and X are in T.
16:19:37 <Cale>    2. The union of any collection of sets in T is also in T.
16:19:37 <Cale>    3. The intersection of any pair of sets in T is also in T.
16:20:00 <mgoetze> vincenz: there are some pathological positions in which it changes L&D, or just adds a ko threat
16:20:01 <vincenz> Cale: topo > graph?
16:20:02 <franka> Thank you.
16:20:25 <ndm> shapr, did you remember the predicate solver thing you were thinking of earlier?
16:20:30 <Cale> vincenz: yeah, go on a graph is a special case of go on a topological space
16:20:38 <vincenz> Cale: thx
16:20:56 <mgoetze> consider the corner [[W,E,W,B,...],[B,B,B,B,...],...]
16:21:12 <mgoetze> white has an extra ko threat if suicide is allowed
16:21:13 <vincenz> mgoetze: erm...if B plays at E it's not suicide
16:21:25 <Cale> vincenz: lower down on the topological go page, you'll see exactly how that is
16:21:42 <mgoetze> yes, but if white plays there he removes his own stones, creating a nakade form
16:21:47 <vincenz> mgoetze: that makes no sense... so when are the pieces removed?
16:21:58 <vincenz> mgoetze: I think you're not on the same page
16:22:21 <mgoetze> 1. place stone, 2. remove enemy stones with no liberties, 3. remove own stones with no liberties
16:22:34 <vincenz> that's against the fundamental laws of go
16:22:49 <mgoetze> that depends on your definition of the fundamental laws of go
16:22:51 <vincenz> cause if your stone rmeoves enemy liberties, then it adds liberties to you
16:22:59 <franka> Hm, Go is a popular topic.  astrolabe is also writing some Go thingy.
16:23:03 <vincenz> so... in the case we describe it would just be 1, 3
16:23:06 <vincenz> which is illegal
16:23:15 <vincenz> cause the case only manifests itself on digraphs
16:23:19 <vincenz> where 1,2,3 happens
16:23:22 <franka> And kosmikus is a Go lover.
16:23:46 <vincenz> anyways
16:23:47 <vincenz> I'm off
16:23:51 * vincenz waves
16:23:58 <mgoetze> it's illegal under japanese rules, but those cause so many problems and inconsistencies even on a regular square board that i wouldn't dare suggest them for arbitrary digraphs ;)
16:24:28 <mgoetze> it's not illegal under new zealand, tromp-taylor, etc. rules
16:25:02 <vincenz> mgoetze: my point is that it's conceptually impossible to have all three steps happen
16:25:24 <mgoetze> vincenz: not on a digraph, cf. your example
16:25:29 <vincenz> no, not on a digraph
16:25:37 <vincenz> but I assume people inventing go were not thinking digraph
16:25:51 <mgoetze> but anyway, there's no problem with removing an empty set of stones
16:26:05 <mgoetze> so, you can go through all three steps each move
16:26:11 <vincenz> so what's the use of playing a complete suicide?
16:26:15 <mgoetze> it's much much cleaner mathematically
16:26:15 <vincenz> that only gives your opponent more liberties
16:26:26 <mgoetze> see my example above, a ko threat
16:26:37 <vincenz> how is giving liberties a kothreat?
16:26:38 <mgoetze> you can google for examples where suicide kills the enemy outright
16:26:42 <Cale> hehe, I was about to say ko-threats too
16:26:49 <Cale> mgoetze: hm?
16:27:00 <Cale> mgoetze: via a ko?
16:27:05 <int-e> vincenz: see the example above
16:27:06 <mgoetze> Cale: nope
16:27:12 <vincenz> dosn't make sense
16:27:14 <vincenz> if W plays at E
16:27:18 <vincenz> Black ahs 2 liberties more
16:27:26 <int-e> yes, but no safe eyes.
16:27:27 <vincenz> ko threats are won by removing opponent liberties, not giving em
16:27:32 <Cale> vincenz: suppose that W plays at E as a ko threat
16:27:34 <vincenz> int-e: wrong
16:27:38 <int-e> 3 in a row is an unsettled shape
16:27:45 <vincenz> int-e: yeah but W plays the death
16:27:49 <mgoetze> vincenz: yes, but if black then passes and white plays at the same spot, black has only one eye (locally)
16:27:52 <vincenz> int-e: W plays E, W dies, B plays E
16:27:54 <Cale> if the black group is completely surrounded, B will have to play where E was in order to save the group
16:28:01 <int-e> vincenz: that's a ko-threat
16:28:01 <vincenz> mgoetze: then black would have to be completely stupid
16:28:05 <int-e> vincenz: black has to answer
16:28:09 <vincenz> int-e: no it's not!
16:28:14 <vincenz> int-e: there is no sente exchange
16:28:17 <mgoetze> vincenz: either black is completely stupid, or the ko is bigger
16:28:24 <vincenz> W was at play before and is at play again
16:28:25 <Cale> vincenz: if B takes the ko, then W kills
16:28:31 * vincenz sighs
16:28:32 <mgoetze> w plays E, b answers, w retakes ko
16:28:36 <Cale> KGS?
16:28:38 <int-e> vincenz: if black doesn't answer immediately, white kills by playing E.
16:28:42 <vincenz> mgoetze: nope
16:28:44 <Cale> This would be easier to see graphically
16:28:49 * vincenz grrs
16:28:53 <vincenz> Look
16:28:55 <vincenz> we start, W has sente
16:29:09 <vincenz> W plays A2, W dies, B plays A2, B has two eyes, W has sente as before and won nothing
16:29:14 <mgoetze> vincenz: well, i'm 1kyu and have studied various go rules in detail, but feel free not to believe me ;)
16:29:16 <Cale> suppose that B and W are in a ko, and W needs to play a threat
16:29:27 <mgoetze> vincenz: W has won the right to retake the ko
16:29:35 <vincenz> Cale: I fail to see how a suicide threatens
16:29:41 <vincenz> mgoetze: there is no KO left
16:29:46 <vincenz> oh wait
16:29:47 <vincenz> hmm
16:29:50 <int-e> vincenz: but still you insist that B plays A2?
16:29:50 * vincenz sees now
16:29:50 <mgoetze> vincenz: the ko is somewhere else entirely
16:29:52 <Cale> vincenz: somewhere else on the board!
16:30:06 <vincenz> subtle
16:30:34 * vincenz 's only a 30 kyu or so :D
16:30:44 <vincenz> but I argue until something's clear
16:30:54 <mgoetze> well, i'm glad we cleared that up :)
16:31:19 <vincenz> :)
16:31:39 <mgoetze> thanks again for the haskell help, vincenz 
16:31:42 <vincenz> the twophased nature of time 
16:31:44 <vincenz> in go
16:32:00 <vincenz> mgoetze: thanks for the go help
16:32:12 <mgoetze> hehe, anytime
16:32:25 <Cale> hehe, xerox is watching the same game as me :)
16:32:35 <xerox> haha you got me.
16:32:46 <xerox> You made me want watching Go.
16:32:49 <vincenz> Cale: what is a collection?
16:32:58 <xerox> I'll be reading from the bed, anyways.  Goodnight :-)
16:33:05 <dons> moin
16:33:27 <vincenz> Cale: is that the same as a 'class'?
16:33:39 <vincenz> aka usually a set but not always so strictly defined?
16:34:13 <mgoetze> hm... /me logs on to kgs
16:34:34 * vincenz does as well
16:35:23 <vincenz> mgoetze: small game?
16:35:29 <vincenz> Cale: who are you on kgs?/
16:35:46 <Cale> vincenz: Cale
16:35:55 <mgoetze> kgsNick "mgoetze" = "mgoetze"
16:36:01 <Cale> vincenz: in this case, I just meant 'set'
16:36:08 <mgoetze> or should that be "fromIrc"?
16:36:24 <vincenz> Cale: not you but the site
16:36:42 <mgoetze> vincenz: hm... hm... kinda late...
16:36:50 <vincenz> mgoetze: 9x9
16:37:02 <vincenz> mgoetze: and it's kgsNick = id
16:38:08 <vincenz> we should get our own Haskell channel on kgs
16:38:15 <drakioned> kgs?
16:38:32 <int-e> kiseido go server, kgs.kiseido.com
16:38:32 <Cale> vincenz: oh, then the site means set too :)
16:40:18 * franka is also watching the game, though me has no idea how to play.
16:40:38 <franka> "/me", rather.
16:42:28 * vincenz blinks
16:42:35 <vincenz> WOW
16:42:42 <dons> Igloo: I've a guy hear who wants to put a kernel project about the size of linux into darcs. Is that doable these days?
16:42:45 <dons> here.
16:43:00 <vincenz> H.E. Mr. Vladimir NOROV, Ambassador of the Republic of Uzbekistan to the Kingdom of Belgium,Head of Missions of Uzbekistan to the European Union and NATO have the honour to invite Dear Christophe Poucet
16:43:54 <vincenz> in a large letter
16:46:07 <dons> anyone had any experience with a project the size of linux kernel in darcs?
16:48:13 <work_metaperl> given howManyEqual a b c =  fromEnum(a == b) + fromEnum(b == c) + fromEnum(a == c)    -- how would I right howManyEqualFour a b c d
16:48:15 <Igloo> dons: You might need to do the initial commit in multiple patches, and the initial get might have to be done with a copy, but other than that the size shouldn't present a big issue
16:48:40 <dons> Igloo: and if he doesn't care about history?
16:48:57 <Igloo> huh?
16:49:28 <dons> oh, you mean already that he's not trying to preserve history, that's a whole 'nother story. sorry
16:49:49 <Igloo> What history?
16:49:57 <vincenz> one thing that bothers me is that there's no permadelete in darcs
16:50:03 <dons> oh, like cvs hisotry
16:50:14 <Igloo> YM he wants to convert an existing repo into a darcs repo?
16:50:16 <dons> but that's a problem for the cvs translate tool thingy
16:50:45 <dons> he's a kernel hacker. on linux. he wants to use darcs though. and he doesn't care about history from cvs.
16:51:07 <dons> ie.. he has a local copy of the kernel. he wants to stick that in darcs. seems very doable, right?
16:51:28 <Igloo> I think it should be possible, yes
16:51:48 <dons> sorry for confusing the issue with talk of conversion. I'm trying to get the spec clear from the guy in another channel :)
16:51:50 <Igloo> I've never used the translation tools, but I think they should be scalable
16:52:01 <dons> they worked for ghc history, so I guess so.
16:55:59 <mwc> Anybody ever tried writing a main lexer and then several "sublexers" using Alex?
16:56:14 <mwc> I'm trying to figure out how to get the wrapper code not to combust when I do this
17:11:02 <vincenz> mwc: wrapper code?
17:11:48 <vincenz> mwc: you can define your own
17:13:45 * vincenz ponders how come it is that he got personally invited ( I checkked, I'm the only one in the to address) to the presentation of uzbekistan by the NATO representative
17:13:56 <vincenz> I guess he got me confused with my father o.O
17:25:02 <mwc> vincenz, yeah, I'm doing surgery on the wrapper code from the alex source
17:25:41 <vincenz> mwc: I used that to tightly integrate the alex and happy monad
18:00:22 <dons> ?uptime
18:00:22 <lambdabot> uptime: 5 days, 20 hours, 29 minutes and 1 second
18:01:04 <eivuokko> Hmh.  What could be wrong if split-objs don't seem to affect executable size when used in libs?
18:01:37 <Igloo> You use everything in the library? You are linking againt the wrong version?
18:02:03 <eivuokko> No and no.
18:02:05 <dons> split objs isn't really on?
18:02:22 <eivuokko> It is, I just fixed Cabal so I could get the library to link in Windows.
18:02:37 <eivuokko> Slight problems with commandline lengths.
18:03:45 <eivuokko> I don't get it.  Maybe I can get ld to spit out graph
18:10:21 <eivuokko> Ehm.  It's not fair comparison, my ghc's base and Win32 are't compiled with split-objs.
18:10:34 <eivuokko> (I compared to 6.4.2)
18:45:09 <mux> blah, monad transformers are killing me
18:45:15 <mux> given this function:
18:45:20 <mux> readLines               :: Handle -> IO [String]
18:45:20 <mux> readLines               = liftM lines . hGetContents
18:45:53 <mux> how could I use the List monad to transform this into a function of type [Handle] -> IO [String] ?
18:45:59 <mux> the closest I could get is :
18:46:03 <mux> readLines2 hs           = runListT (ListT (return hs) >>= lift . readLines)
18:46:25 <mux> but that has not the correct type:
18:46:26 <mux> readLines2 :: [Handle] -> IO [[String]]
18:47:06 <Cale> what's it supposed to do?
18:47:15 <musasabi> readLines2 = mapM readLines
18:47:40 <Cale> yeah
18:47:54 <Cale> do you want to liftM concat that or something?
18:48:17 <mux> mmm.
18:49:12 <Cale> btw, the ListT in the GHC libraries is kind of broken
18:49:23 <Cale> most of the time it doesn't even give you a monad
18:49:37 <Cale> there's a better one on the old wiki
18:49:56 <mux> I wanted to write something like [handle1,handle2] >>= readLines
18:50:23 <mux> but that's not possible because readLines is in the IO monad
18:50:34 <mux> that's why I went to look about monad transformers
18:50:55 <Cale> I think maybe you're just looking for mapM
18:50:59 <Cale> @type mapM
18:51:00 <lambdabot> forall b (m :: * -> *) a.
18:51:00 <lambdabot>    (Monad m) =>
18:51:00 <lambdabot>    (a -> m b) -> [a] -> m [b]
18:51:11 <mux> mapM gives me [[String]], and I'd like this concatenated
18:51:25 <Cale> @type liftM concat . mapM
18:51:26 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:51:28 <mux> yeah
18:51:30 <Cale> er
18:51:41 <Cale> @type (liftM concat .) . mapM
18:51:42 <lambdabot> forall a a1 (m :: * -> *).
18:51:42 <lambdabot>          (Monad m) =>
18:51:42 <lambdabot>          (a1 -> m [a]) -> [a1] -> m [a]
18:51:43 <mux> but it looked like the bind operator in the list monad already has the semantics I'm looking for
18:51:58 <mux> and that it just needed to be adapted to deal with IO
18:52:06 <Cale> perhaps 
18:54:27 <mux> blah
18:54:49 <Cale> maybe there is some sort of combined monad, but I'm not entirely sure about that
19:07:25 <bmedwar> is the ghc-cvs debian package ghc 6.5?
19:08:14 <dons> 6.5 is the head, which is in darcs now, not cvs. :)
19:08:32 <dons> so maybe ghc-cvs in debian means the head, I suppose it does.
19:09:03 <dons> I guess it would be better named ghc-head
19:10:03 <bmedwar> looks like it was last updated 2005 3/31
19:10:18 <dons> oh hmm.
19:10:39 <bmedwar> so i guess i would have to build ghc from source
19:10:59 <bmedwar> i'm trying to install haspr
19:11:19 <dons> or just grab a nightly snapshot
19:11:29 <dons> easier than building from siource if you're on linux/x86
19:11:32 <dons> or amd64
19:13:00 <bmedwar> configure on haspr says cannot satisfy dependency ghc-any i believe this is part of 6.5
19:13:12 <dons> ghc package is part of 6.5, yep
19:13:23 <bmedwar> cool thanks
19:14:42 <Lemmih> HASP has bitrotted a tiny bit.
19:15:14 <bmedwar> ahh.. so save the trouble of going to 6.5
19:15:51 <bmedwar> what is HASPR vs. HASP btw?
19:17:14 <Lemmih> There is no HASPR.
19:17:40 <dons> HASPwpM_' you mean
19:17:42 <dons> ;)
19:17:58 <dons> oh sorry, Visual HASPwpM_'
19:18:05 <dons> on Rails
19:18:29 <Lemmih> bmedwar: You can fix it with minor changes it the source.
19:18:40 <Lemmih> s/it the/to the/
19:23:34 <bmedwar> does this mean success? -- ghc-pkg list hasp... ghc-6.4.1/package.conf: hasp-0.4.0
19:25:12 <bmedwar> what is HASPR? it is referenced in http://darcs.haskell.org/~lemmih/hasp/INSTALL
19:28:10 <Lemmih> Oh, right. There /is/ a HASPR.
19:29:38 <Lemmih> HASPR is the cgi program that will serve your Haskell webpages.
19:31:46 <bmedwar> ok, so I'll get a head snapshot and give it a go
19:32:25 <araujo> Hello!
19:35:01 <palomer> hullo!
20:03:24 <dons> hmm, compiling Data.Generics, ghc needs 24 GCs, Data.ByteString 1982 GCs
20:03:45 <dons> ah, better, IntMap 1083 GCs
20:03:55 <dons> and Map 1303
20:03:57 <dons> good good.
20:13:54 <palomer> the only thing haskell is lacking is const_cast
20:15:02 <dons> oh, that reminds me, I have some more palomerisms
20:16:35 <dons> ?palomer
20:16:54 <lambdabot> Brump!
20:17:03 <dons> ?palomer
20:17:06 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
20:17:10 <dons> ?palomer
20:17:10 <lambdabot> They're telling you lies!
20:17:16 <dons> i like that one.
20:17:17 <dons> ?palomer
20:17:18 <lambdabot> Soylent green is people
20:17:21 <dons> ?palomer
20:17:21 <lambdabot> Scalliwags!
20:17:29 <dons> its all SOLID GOLD
20:18:01 <palomer> my mouth wouldn't spew anything else
20:18:06 * palomer crosses his fingers for the SoC
20:18:26 <palomer> if I don't get it, I might be forced to find a real job
20:18:29 <dons> we got 72 applications, I think. or 77.
20:18:32 <palomer> and that'll be the end of my creativity :/
20:18:45 <palomer> whoa, that's a lot
20:18:55 <palomer> well, 3 of those are from me
20:19:00 <palomer> 2 of which are the same
20:19:05 <palomer> (one being more elaborate then the other)
20:19:22 <palomer> should I email paolo to tell him to remove one of my proposals?
20:19:43 <dons> oh, we'll get to that I guess by the 22nd, probably wouldn't hurt to tell him though
20:21:37 <dons> I just hope we have enough mentors to pick up, say, 1/2 the projects
20:23:10 <palomer> I just hope google will know enough information to know what the heck I'm talking about
20:23:34 <dons> yeah. that too.
20:23:46 <dons> I suspect they must take mentor interest into hand quite a bit.
20:24:46 * dons ~> sushi time!
20:34:13 <akemp> @hoogle fail
20:34:13 <lambdabot> Prelude.fail :: Monad m => String -> m a
20:34:14 <lambdabot> System.Win32.Types.failIf :: (a -> Bool) -> String -> IO a -> IO a
20:34:14 <lambdabot> System.Win32.Types.failIfFalse_ :: String -> IO Bool -> IO ()
20:39:27 --- topic: '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]'
20:39:27 --- topic: set by xerox on [Tue Apr 25 18:17:10 2006]
20:39:27 --- names: list (clog int-e lambdabot akemp khaladan bsp chessguy bmedwar magnus-- jethr0_ mwc lumi est_ Dark-Side hagabaka tennin SamB audreyt wolverian Khisanth GeniXPro Paltas bpederse aasmith eivuokko bofh morans Magical1 Nioate Plareplane slipstream-- Philippa araujo blackdog Nomius drbean Poeir_ work_metaperl rashakil Daveman Bobstopper sidewinder turok`` laurence kpreid_ mgoetze Twigathy Mr_Krinkle Trix Revision17 falconair lisppaste2 bolrod kosmikus)
20:39:27 --- names: list (mauke user317 piggybox noclouds nothingmuch moonlite1 ski greenrd ADEpt mahogny bdash xinming ramkrsna astrolabe Hmm_| sethk integral pesco dons metaperl dcoutts ruffneck ex_nor ralejs dvekravy genneth sieni JohnMeacham lome iturk Lokadin SubStack zamez capiCrimm insheerdread ulfdoz ksandstr ChilliX cbus Beelsebob norpan sellout mathrick|sleep kzm_ wilx johs Wallbraker eyck shitlog ibid isydor nomeata msph cpatrick Oejet seafood newsham)
20:39:27 --- names: list (arguile Cale palomer rasfar cmeme mattam psnl vincenz @Igloo mux eno-away SimonRC shrimpx danly CLxyz petekaz tessier emu kolmodin Narrenschiff LoganH mokus ozone mlh NameTab kzm joe_k xerox__ gzl Cale_ mornfall orbitz Korollary thedward pirroH gripe swoolley shapr yaarg Si\Uni _shawn Lemmih lispy JKnecht tromp earthy liyang Lor rey_ juhp nattfodd reppie svens borism gdsx neologism edwinb magagr scw cods resiak Spark musasabi gn WillKW)
20:39:27 --- names: list (ohub noj ValarQ kpk pejo dany2k rkeene Lunar^ flux__ djw wli dcoutts_ Maddas)
20:56:54 <akemp> dons: you around?
21:08:23 <Captain_Fourier> howdy
21:27:43 <machack666> @pl unfoldr ((liftM (splitAt 2) . find (not . null)) . (:[])) 
21:27:44 <lambdabot> unfoldr (fmap (splitAt 2) . find (not . null) . return)
21:29:09 <Cale> @type unfoldr (fmap (splitAt 2) . find (not . null) . return)
21:29:11 <lambdabot> forall a.
21:29:11 <lambdabot>                     [a] -> [[a]]
21:29:47 <Cale> (unfoldr (fmap (splitAt 2) . find (not . null) . return)) [1..10]
21:29:48 <Cale> >(unfoldr (fmap (splitAt 2) . find (not . null) . return)) [1..10]
21:29:51 <Cale> > (unfoldr (fmap (splitAt 2) . find (not . null) . return)) [1..10]
21:29:52 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10]]
21:30:49 <machack666> fancy way of partitioning a list into a fixed-size sublist
21:31:06 <Cale> yeah
21:31:32 <machack666> probably an easier way to do that...but what do you do? :)
21:31:49 <dons> akemp?
21:31:57 <int-e> > takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1..10]
21:31:58 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10]]
21:32:23 <machack666> > take 10 $ (unfoldr (fmap (splitAt 2) . find (not . null) . return)) [1..]
21:32:24 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
21:32:55 <machack666> > takeWhile (not . null) $ unfoldr (Just . splitAt 2) []
21:32:56 <lambdabot> Add a type signature
21:33:16 <int-e> > takeWhile (not . null) $ unfoldr (Just . splitAt 2) [] :: [[Int]]
21:33:17 <lambdabot> []
21:33:27 <int-e> > takeWhile (not . null) $ unfoldr (Just . splitAt 2) [1]
21:33:28 <lambdabot> [[1]]
21:33:40 <machack666> cool; thanks!
21:37:05 <Cale> > takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..10]
21:37:06 <lambdabot> [[1,2],[3,4],[5,6],[7,8],[9,10]]
21:37:20 <Cale> there's another straightforward approach :)
21:39:08 <Captain_Fourier> hello
21:39:12 <Cale> hi
21:39:17 <Captain_Fourier> im having an error building Yi
21:39:24 <Captain_Fourier> Could not find module `Data.FastPackedString'
21:39:27 <int-e> Cale: nice. you can also swap the map and the takeWhile
21:39:35 <dons> Captain_Fourier: you'll need an early version of fps
21:39:39 <dons> try fps 0.2 
21:39:45 <Captain_Fourier> oh ok
21:39:54 <Captain_Fourier> dons dont you build both ;)
21:39:57 <dons> i've not yet ported it to the new Data.ByteString edition of fps
21:40:14 <Captain_Fourier> mind if i do?
21:40:19 <dons> i don't build them in parallel, its more a cooperative scheduling thing
21:40:25 <dons> sure, go for it.
21:41:23 <dons> all my projects are running threads. some are deadlocked, some are blocked. when i can't do any more work on one, that project decides to yield to something else that's ready to run.
21:41:39 <Cale> hehe
21:44:10 <Captain_Fourier> how do i uninstall these libraries btw
21:44:25 <Captain_Fourier> ./Setup.hs uninstall is not available ;)
21:45:06 <eivuokko> ./Setup unregister and remove the files.
21:45:14 <Captain_Fourier> where are the files
21:45:34 <eivuokko> see .installed-pkg-config
21:45:55 <Captain_Fourier> ok
21:46:20 <eivuokko> Yeah, it's not really uninstall friendly.
21:46:29 <Captain_Fourier> shame
21:46:51 <Captain_Fourier> hmm hold on let me tweak this
21:48:06 <Captain_Fourier> mind if i darcs send this tweak dons
21:50:05 <dons> Captain_Fourier: no, of course not.
21:50:11 <Captain_Fourier> ok cool
21:50:45 <dons> you working on ~dons/code/yi ?
21:51:07 <Captain_Fourier> um that and tweaking Setup.hs
21:51:09 <Cale> > let f ns xs = zipWith take ns (scanl (flip drop) xs ns) in f [1,2,3,4,5] [1..10]
21:51:10 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10],[]]
21:51:28 <Cale> generalisation :)
21:51:43 <Cale> I suppose you'd also want to takeWhile (not . null) that
21:52:18 <Cale> > let f ns xs = takeWhile (not . null) $ zipWith take ns (scanl (flip drop) xs ns) in f [1,2,3,4,5] [1..10]
21:52:19 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10]]
21:52:28 <Cale> > let f ns xs = takeWhile (not . null) $ zipWith take ns (scanl (flip drop) xs ns) in f [1,2,3,4,5] [1..20]
21:52:29 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15]]
21:52:42 <Cale> > let f ns xs = takeWhile (not . null) $ zipWith take ns (scanl (flip drop) xs ns) in f [1..] [1..]
21:52:43 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15],[16,17,18,19,20,21],[22,23,24,25,26,27,28],[29,30,31,32,33,34,35,36],[37,38,39,40,41,42,43,44,45],[46,47,48,49,50,51,52,53,54,55],[56,57,58,59,60,61,62,
21:52:43 <lambdabot> 63,64,65,66],[67,68,69,70,71,72,73,74,75,76,77,78],[79,80,81,82,83,84,85,86,87,88,89,90,91],[92,93,94,95,96,97,98,99,100,101,102,103,104,105],[106,107,108,109,110,111,112,113,114,115,116,117,118,119,
21:52:43 <lambdabot> 120],[121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136],[137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153],[154,155,156,157,158,159,160,161,162,163,164,165,166,167,
21:52:43 <lambdabot> 168,169,170,171],[172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190],[191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210],[211,212,213,214,215,
21:52:45 <lambdabot> 216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231],[232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253],[254,255,256,257,258,259,260,261,262,263,
21:52:48 <lambdabot> [6 @more lines]
21:52:54 <Captain_Fourier> good dear
21:53:09 <machack666> @pl f a b = 16 * a + b
21:53:09 <lambdabot> f = (+) . (16 *)
21:54:42 <Cale> scanl is a nice function, I should think of it more often :)
21:54:58 <int-e> > take 10 $ map sum $ fix $ ([]:) . scanl (++) [1]
21:54:59 <lambdabot> [0,1,1,2,3,5,8,13,21,34]
21:54:59 <akemp> dons: you still around?
21:55:01 <int-e> scnr
21:55:28 <dons> sure
21:55:49 <akemp> dons: two questions
21:55:59 <Cale> sort of interesting how foldr and scanl are the more natural ones, when they're conceptually going in opposite directions.
21:56:04 <dons> (btw, you should just ask, then you can lazily get the response :)
21:56:42 <akemp> dons: yi - i'm trying to build it.  It appears to be built with the old version of FPString.  Do you have functions in the new ByteString to get back and forth from String?
21:57:11 <dons> akemp: nope. use fps 0.1 or 0.2
21:57:12 <akemp> dons: to String -> show
21:57:24 <dons> ?
21:57:37 <dons> oh, conversion between String, of course!
21:57:38 <Captain_Fourier> cc: dist/build/./yi-tmp/cbits/YiUtils.o: No such file or directory
21:57:46 <dons> Data.ByteString.Char8.pack/unpack
21:57:54 <machack666> anyone have a quick recipe for turning a string of hex characters into a list of Octets?  i.e., "0x12345678" -> [0x12,0x34,0x56,0x78] ?
21:58:02 <dons> Captain_Fourier: cabal bug, i think. copy the .o files into the write dir manually
21:58:09 <dons> should report that at some time.
21:58:10 <akemp> dons: ahhhhhhhhhhhhhh.  
21:58:24 <akemp> dons: yes.
21:58:31 <dons> stuff to do with Char/Strings are in Char8.hs :)
21:58:33 <akemp> dons: I was just testing you.
21:58:39 <dons> ah, ok. i see.
21:58:42 <akemp> dons: you did quite well I might say.
21:58:49 <akemp> ;)
21:58:57 <dons> that's good to know.
21:59:43 <akemp> dons: and I was going to ask you a question on your "Plugging Haskell In" paper, but I don't have a copy nearby, so the question will be vague.
21:59:47 <Captain_Fourier> thank you dons
22:00:06 <int-e> > readHex "23"
22:00:08 <lambdabot> [(35,"")]
22:00:26 <machack666> > readHex "00112233"
22:00:27 <lambdabot> [(1122867,"")]
22:00:44 <dons> hehe :)
22:00:44 <dons> what's all this yi activity all of the sudden, I wonder?
22:00:58 <machack666> > map readHex ["00","11","22","33"]
22:00:59 <lambdabot> [[(0,"")],[(17,"")],[(34,"")],[(51,"")]]
22:01:11 <Cale> @type showsHex
22:01:12 <lambdabot> Not in scope: `showsHex'
22:01:15 <Cale> @type showHex
22:01:17 <lambdabot> forall a. (Integral a) => a -> ShowS
22:01:23 <int-e> > map (fst . head . readHex)  ["00","11","22","33"]
22:01:24 <lambdabot> [0,17,34,51]
22:01:28 <machack666> > map (fst . readHex) ["00","11","22","33"]
22:01:29 <lambdabot> Couldn't match `(a, b)' against `[(a1, String)]'
22:01:30 <Cale> > showHex 15 ""
22:01:31 <lambdabot> "f"
22:02:08 <int-e> readHex is in the Numeric module btw.
22:02:14 <machack666> > map (fst . head . readHex) $ takeWhile (not . null) $ unfoldr (Just . splitAt 2) ["abcd1234"]
22:02:15 <lambdabot> Couldn't match `Char' against `[Char]'
22:02:21 <Cale> machack666: wait, you want the strings, or the actual bytes?
22:02:26 <machack666> actual bytes
22:02:39 <Cale> oh, then that should be easy with Data.Bits
22:02:41 <machack666> starts with a string, turning into the actual bytes
22:02:47 <Cale> yeah
22:02:57 <Cale> > read "0x41278af"
22:02:58 <lambdabot> Add a type signature
22:03:01 <Cale> > read "0x41278af" :: Integer
22:03:02 <lambdabot> 68319407
22:03:04 <Cale> > read "0x41278af" :: Int
22:03:05 <lambdabot> 68319407
22:03:32 <machack666> read "0x1234123412341234" :: Integer
22:03:40 <machack666> > read "0x1234123412341234" :: Integer
22:03:41 <lambdabot> 1311693406324658740
22:03:43 <dons> well, also:
22:03:44 <dons> Prelude Data.ByteString> unpack (Data.ByteString.Char8.pack "abcde12345")
22:03:44 <dons> [97,98,99,100,101,49,50,51,52,53]
22:03:48 <dons> perhaps?
22:04:03 <dons> oh, maybe you're doing something else.
22:04:12 <machack666> actually, the final value needed is the Integer, so the read :: Integer makes the most sense.  :)
22:04:20 <machack666> that'd be too easy.
22:04:21 <int-e> > map ord "abcde12345"
22:04:22 <lambdabot> [97,98,99,100,101,49,50,51,52,53]
22:04:24 <dons> right
22:04:25 <Cale> > map (.&. 0xff) . iterate (`shift` 8) $ (read "0x12345678" :: Int)
22:04:26 <lambdabot> [120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
22:04:27 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
22:04:27 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
22:04:27 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
22:04:29 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
22:04:32 <Cale> oops
22:04:32 <lambdabot> [6 @more lines]
22:04:44 <int-e> unfoldr :)
22:04:49 <Cale> > takeWhile (/= 0) . map (.&. 0xff) . iterate (`shift` (-8)) $ (read "0x12345678" :: Int)
22:04:50 <lambdabot> [120,86,52,18]
22:04:56 <int-e> (takeWhile won't cut it)
22:04:57 <dons> unfoldr is usually the answer
22:05:08 <Cale> hm?
22:05:10 <int-e> hmm. well, actually it could do it.
22:05:18 <Cale> does just fine
22:05:26 <machack666> I'm parsing an md5 hash in 0xABCD format.
22:05:27 <int-e> no, that has a bug
22:05:34 <int-e> you need to swap the takeWhile and map :)
22:05:54 <Cale> oh, I suppose I do
22:06:26 <Cale> > reverse . map (.&. 0xff) . takeWhile (/= 0) . iterate (`shift` (-8)) $ (read "0x12345678" :: Int)
22:06:27 <lambdabot> [18,52,86,120]
22:06:48 <Cale> > [0x12,0x34,0x56,0x78]
22:06:49 <lambdabot> [18,52,86,120]
22:07:39 <Cale> or
22:07:48 <Cale> > reverse . map (.&. 0xff) . takeWhile (/= 0) . iterate (`shiftR` 8) $ (read "0x12345678" :: Int)
22:07:49 <lambdabot> [18,52,86,120]
22:08:20 <akemp> dons: the question was actually from the Dyn Applications paper.
22:08:39 <Cale> > reverse . map (.&. 0xff) . takeWhile (/= 0) . iterate (`div` 0x100) $ (read "0x12345678" :: Int)
22:08:40 <lambdabot> [18,52,86,120]
22:09:12 <Cale> > reverse . map (`mod` 0x100) . takeWhile (/= 0) . iterate (`div` 0x100) $ (read "0x12345678" :: Int)
22:09:13 <lambdabot> [18,52,86,120]
22:09:41 <Cale> could also unfoldr using divMod
22:09:49 <Cale> @type divMod
22:09:50 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
22:10:08 <int-e> @hoogle (a,b) -> (b,a)
22:10:09 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
22:10:19 <akemp> dons: remain :: a -> IO () and you explain that remain never really returns.  However, "remain" takes state and, upon failure, does not return that state (or any modified version of it).
22:10:25 <Cale> @type uncurry flip
22:10:26 <lambdabot> forall a c b. (a -> b -> c, b) -> a -> c
22:10:35 <Cale> @type uncurry flip (,)
22:10:36 <lambdabot>   Couldn't match `(a -> b -> c, b)' against `t -> t1'
22:10:36 <lambdabot>   Expected type: (a -> b -> c, b)
22:10:37 <int-e> @type uncurry $ flop (,)
22:10:39 <lambdabot> Not in scope: `flop'
22:10:41 <Cale> @type uncurry (flip (,))
22:10:42 <lambdabot> forall a b. (a, b) -> (b, a)
22:11:13 <akemp> dons: would it be better to return the state so that the applications could save state in the case of an error?
22:11:23 <Cale> makes perfect sense, when you stop and think about it
22:11:28 <dons> hmm, in case of error to reload, eh?
22:11:32 <Cale> uncurry should have a prettier name
22:11:53 <int-e> yrruc?
22:12:09 <Cale> heh
22:12:20 <Cale> maybe something like 'pair'
22:12:28 <Cale> if Maybe gets maybe
22:13:10 <Cale> then again, by that reasoning, we should be calling foldr "list"
22:13:50 <akemp> dons: and I guess the calling function would see the IO () return, could deduce that the reload failed and decide to write out the state to disk.
22:14:48 <akemp> dons: the concern was that the remain function is going to attempt a load and perhaps fail-and-drop the app state.
22:18:13 <akemp> dons: this is what seems to happen in Boot.remain.  Upon a LoadFailure, remain calls exitFailure and "st" evaporates.
22:18:21 <int-e> @index swap
22:18:21 <lambdabot> bzzt
22:23:09 <int-e> @hoogle Either a b -> Either b a
22:23:10 <lambdabot> No matches, try a more general search
22:24:03 <araujo> hello all
22:46:25 <hyrax42> @pl \f -> foldr ((:) . f) []
22:46:25 <lambdabot> flip foldr [] . ((:) .)
22:47:28 --- topic: set to '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: "]' by Captain_Fourier
22:47:32 <Captain_Fourier> oops
22:47:47 <Captain_Fourier> um i was trying to get the poll url
22:51:57 --- topic: set to '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]' by Captain_Fourier
22:55:29 * palomer might write up a paper for the haskell-workshop
22:56:34 <Cale> hyrax42: hmm, it's not smart enough to give map
22:56:58 <hyrax42> oh I didn't really want it to
22:57:00 <hyrax42> heh
22:57:04 <hyrax42> I just wanted to see where the flip went
22:57:16 <hyrax42> flip with multi-argument makes my head hurt
22:57:45 <Oeje1> Hi all!
22:57:58 <Captain_Fourier> hi
22:58:23 <Oeje1> Captain_Fourier: I haven't seen you before, are you new here?
22:58:30 <Captain_Fourier> yes i am
22:58:39 <Oeje1> New to Haskell too?
22:58:49 <Captain_Fourier> now very new
22:59:01 <Captain_Fourier> but for the most part
22:59:19 <Oeje1> Welcome!  You have come to the right place then :-)
22:59:29 <Captain_Fourier> sweet
23:01:13 <Cale> hmm, is there a Haskell Newbie section on the new wiki yet?
23:01:57 <Oeje1> Captain_Fourier: By the way, by "now very new" did you mean "not very new"?
23:02:08 <Captain_Fourier> yes
23:02:18 <Captain_Fourier> i have some resources
23:02:33 <Captain_Fourier> and i have managed to make some glue apps in haskell
23:02:53 <Captain_Fourier> i have found i learn best by doing, so for now im just going to hang back
23:02:57 <Captain_Fourier> and hack
23:03:26 <Cale> Captain_Fourier: I found it quite constructive to hang around here and silently steal people's homework problems for myself :)
23:03:40 <Captain_Fourier> sounds fine
23:04:00 <Captain_Fourier> i was thinking of making yi work with fps-0.7
23:04:28 <Captain_Fourier> and allowing Setup.hs uninstall
23:05:19 <Cale> sounds good :)
23:05:47 <Captain_Fourier> yeah
23:06:06 * Cale considers transplanting the HaskellNewbie page from the old wiki to the new one.
23:06:24 <Cale> hmm, there's some issues with licensing that I'm not sure I should completely ignore
23:06:58 <Cale> this wiki split is beginning to annoy me though
23:07:15 <Cale> I should probably start by transplanting my own content
23:07:32 <palomer> yes, but the new wiki has stateful nondeterminism!
23:08:09 <hyrax42> why is the new wiki under different licensing?
23:08:54 <Cale> hyrax42: the old wiki is under unspecified licensing
23:09:03 <hyrax42> ah
23:09:09 <hyrax42> so different by virtue of definition
23:09:27 <Cale> It wasn't something that was thought about until it was too late.
23:10:13 <Cale> MonadsAsContainers should definitely be moved though. Do we have versions in different languages like Wikipedia?
23:10:31 <Cale> (someone kindly translated it into Russian)
23:15:40 <sethk> dons, are you about?
23:27:53 <hyrax42> @pl \x y -> if x >= y then x else y
23:27:53 <lambdabot> join . (flip =<< (if' .) . (>=))
23:28:04 <hyrax42> oww
23:28:05 <hyrax42> :(
23:28:14 <hyrax42> @type if'
23:28:15 <lambdabot> Not in scope: `if''
23:28:21 <hyrax42> oh right
23:28:28 <hyrax42> what is if'
23:29:26 <Korollary> it's the function version of if then else.
23:29:32 <hyrax42> @index if'
23:29:32 <lambdabot> bzzt
23:29:38 <hyrax42> @hoogle if'
23:29:38 <lambdabot> No matches found
23:29:44 <hyrax42> where does it live?
23:30:06 <Korollary> @hoogle Bool -> a -> a -> a
23:30:07 <lambdabot> No matches, try a more general search
23:30:34 <Korollary> @hoogle if
23:30:35 <lambdabot> Prelude.if :: keyword
23:30:35 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
23:30:35 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
23:30:48 <Korollary> no clue
23:30:51 <hyrax42> hm
23:31:24 <mgoetze> anyone know of vim compiler plugins or indent files for haskell?
23:34:41 <sethk> mgoetze, part of the vim distribution
23:34:58 <sethk> mgoetze, I installed vim from source and it does syntax highlighting and indentation for .hs files.
23:36:09 <mgoetze> sethk: neither of those are on par with what has been done for other filetypes, though
23:36:47 <sethk> mgoetze, I've never missed any features.  what do you think is missing?
23:37:38 <hyrax42> @pl \x -> x*x
23:37:39 <lambdabot> join (*)
23:38:51 <hyrax42> huh?
23:38:59 <mgoetze> sethk: could at least highlight builtin types, among other things, and if i write a line like "main = do a<-foo" and hit enter i'll end up at *gasp* column 1
23:39:00 <hyrax42> where is the monad
23:39:19 <hyrax42> @type join (*)
23:39:21 <lambdabot> forall a. (Num a) => a -> a
23:40:43 <mgoetze> sethk: or, for that matter, "foo = (bar", the unclosed paren making it clear that the statement will be continued
23:41:17 <hyrax42> > join (*) $ 10
23:41:18 <lambdabot> 100
23:41:50 <sethk> mgoetze, I suppose.  I use it with haskell and with C++, and I don't even notice it is missing.  Wouldn't hurt to have it, I suppose.
23:41:51 <hyrax42> ah well, bed time
23:42:14 <Cale> Is there a standard place for discussion pages on the new wiki?
23:42:53 <mgoetze> sethk: in C++, it should autoindent when you write a {, and autounindent if you write a }, etc. - if not, work on your .vimrc ;)
23:43:10 <mgoetze> sethk: and then you will start to notice that there are no corresponding features for haskell
23:43:22 <sethk> mgoetze, of course it does, and no, I don't notice it
23:43:36 <sethk> mgoetze, it does auto indent out of the box, you don't need anything in .vimrc
23:44:09 <mgoetze> sethk: i've seen some pretty weird "out of the box" vim setups, so... ;)
23:44:43 <sethk> mgoetze, download the tarball from the vim site, configure, make, make install.  If the distros do something to break it, you can't blame that on vim.  :)
23:45:36 <mgoetze> sethk: thanks, i'm quite happy with mine. and the standard vim distribution just doesn't come with any good haskell stuff, that's why i asked
23:46:27 <sethk> mgoetze, I know.  I don't know of other support.  I haven't looked particularly, but I've come across the stuff for emacs and I imagine I would have seen stuff for vim if it exists.
23:46:30 <Cale> oh, of course there is, I just didn't see the link :)
