00:00:08 <neologism> dons: from 30 seconds (the fps version) or 45 seconds (String version) to 9 seconds :)
00:00:08 <laurence> Cale: Except for the "depends on context" part.  The Gamma function is "context free"!!!
00:00:20 * laurence is just being unreasonable now.
00:00:35 <Korollary> laurence: You should talk to mwc, who is another physicist.
00:00:44 <Cale> laurence: well, all notation depends on context, I suppose
00:00:59 <palomer> Cale is a physicist?
00:00:59 <palomer> yuck
00:01:08 <Cale> I'm not a physicist
00:01:14 <palomer> good
00:01:49 <Cale> I know just enough about QM to know that it's got tons of mathematical problems and infelicities.
00:01:53 <laurence> Interestingly, if Currying is confusing to people, then perhaps the physics helps more than I think.  I don't know why it isn't obvious.
00:02:10 <laurence> Cale: No, QM is fine.  Math has problems. =8-O
00:02:19 <metaperl> lol
00:02:44 * laurence beats a Hilbert space until it accepts a non-normalizable basis.
00:02:49 <Korollary> I reject the reality and substitute my own.
00:03:34 <palomer> soylent green is people
00:03:46 <laurence> Cale: Oddly enough, the the professor of the class that treated QM's little mathematical "issues" advocated using units where pi = i = 1 to make contour integration simpler.  I'm sure you'll like that....
00:03:50 <Korollary> His name is Robert Paulson.
00:04:27 <dons> neologism: good :)
00:04:43 <palomer> hrmph
00:04:44 <goltrpoat> was.. robert paulsen
00:04:52 <neologism> dons: it really is :)
00:04:53 <Korollary> laurence: Conventions again. In my circles j stands for sqrt(-1)
00:04:53 * laurence waits for Cale's outburst of justified rage....
00:05:11 <laurence> Korollary: So how *are* things in the EE department these days, anyway?
00:05:13 <neologism> dons: has fps been commited to ghc?
00:05:35 <Cale> laurence: Well, I know that they do funny things like that all the time
00:05:35 <Korollary> goltrpoat: http://en.wikiquote.org/wiki/Fight_Club (*is*)
00:05:57 <goltrpoat> dammit.  clearly i should watch it again :)
00:05:58 <Korollary> laurence: I haven't been there since 2000. I am a cs person now.
00:06:02 <laurence> Cale: You're not thinking hard enough about it then. :-)
00:06:05 <Cale> laurence: Basically, physics seems to treat mathematics as string rewriting.
00:06:13 <palomer> can I submit a project that hasn't been posted on the haskell SoC site?
00:06:29 <laurence> Korollary: Then s/j/i/g, you're not in the sticks anymore. :-)
00:06:33 <palomer> (when I submit to google)
00:06:48 <Cale> I've seen some really brutal computations carried out with no concern for whether any of it makes any sense at all.
00:07:02 * laurence hoped Cale, at least, would get one of the geekiest jokes he'd ever heard.
00:07:15 <dons> neologism: its been sent in. I'm waiting on SimonM to commit it.
00:07:21 <Korollary> palomer: I think individuals can propose anything they want, but finding a mentor could be another problem.
00:07:36 <Cale> laurence: well, if you modded out by that, you'd be working in the trivial ring
00:07:39 <laurence> Cale: Unless a misfeasance was being committed, it's more that we don't usually explain to mathematicians what we're really doing because we like to see them turn purple.
00:07:45 <palomer> dons: want to be my mentor?
00:08:21 <Cale> laurence: Sometimes it really isn't defined though.
00:08:57 * palomer slaps dons until he says yes
00:09:07 <laurence> Cale: It was one of the dryest lectures I've ever heard, and every once in a while he'd drop stuff like that just to see if anyone was paying attention.  IIRC people were so dazed that there were several seconds of silence before it sank in.  (I trust it is obvious that no one actually does that....)
00:09:16 <laurence> Cale: What isn't defined?
00:10:18 <Cale> some operation being performed -- it's especially annoying when the end result is something which makes physical sense, but which is mathematically bankrupt
00:10:36 <JohnMeacham> doublec: until jhc's strictness analyzer is back in action, don't expect to great of results from it.
00:11:31 <laurence> Cale: Mathematicians feel that way most often because they have no physical sense at all, and therefore the justification is invisible to them.  That's why they are different fields. :-)
00:11:58 <Cale> laurence: Yeah, but it really goes against the way I'd like to think about science.
00:12:00 <Korollary> JohnMeacham: I was pretty surprised to hear "Jon Meacham" (author) announced as a guest on the Colbert Report last night.
00:12:29 <Cale> It would be nice if the model was some well-defined thing (at least at any point in time)
00:12:40 <Cale> You have some formal system
00:12:43 <laurence> Cale: The fact that a fairly large chunk of continuous mathematics was developed post hoc to understand the physics, and this nearly always puts the physics on a firm foundation rather than invalidating it, should at least suggest that something useful happened. :-)
00:13:01 <Cale> and a mapping which maps observations to statements in that system
00:13:10 <laurence> Cale: The problem is precisely that it is impossible to do natural science starting from the formal system.
00:13:29 <Cale> Sure it is.
00:13:57 <Korollary> Cale: I am not sure if that is a general case or an exception. I'd expect most physics theories to have very solid math because checking the math is much easier than performing experiments.
00:14:05 <laurence> Only after we tell you what it is. :-)  There is no a priori model written on stone tablets.
00:14:22 <Cale> Korollary: I'd expect that too, but it seems to be false.
00:14:54 <laurence> Korollary: It's more complex than that, Cale is talking about something real, but doesn't know enough physics to understand the complete game.
00:14:56 <Cale> laurence: See, this goes against the idea that you should have a hypothesis which you are testing when you do an experiment.
00:14:56 <dons> palomer: yeah . sure.
00:15:06 <dons> i wonder do i get 5 tshirts from google if i mentor 5 people?
00:15:17 <dons> that would make it all worthwhile
00:15:28 <Korollary> dons: I'll bug people I know at goog to hire you.
00:15:31 <Cale> You hypothesize a particular formal system.
00:15:32 <laurence> Cale: First, I've never though the grade-school picture of science has that much relevance to what scientists actually do.
00:16:11 <dons> ?karma+ Korollary :)
00:16:12 <lambdabot> Korollary's karma raised to 3.
00:16:21 <laurence> Cale: No, only sometimes.  If you insisted on always doing that, you would be so handicapped you would be unable to make progress.
00:16:43 <Cale> laurence: not true at all
00:16:59 <Cale> (why would you say that?)
00:17:01 <laurence> The best book to explain the physical game is Feynman's _The Character Of Physical Law_.
00:17:43 <Cale> I see it as perfectly valid to define a formal system just large enough to contain the details of a single experimental setting.
00:17:43 <laurence> Cale: Because, for example, that method would define huge swaths of productive science as non-science.  All phenomenological work, for example.
00:18:13 <Cale> How do you define science?
00:18:35 <laurence> By the time one can start proposing formal systems, the game is very far along and you've learned a *lot*.
00:18:36 <tuxplorer> what is the use of $ ? Prelude.($) :: (a -> b) -> a -> b . This may be acheived just by a function of type a->b right?
00:18:40 <Korollary> I wonder if this is #haskell-blah kind of traffic
00:19:02 <laurence> Pray tell me what formal system you would use to study circadian rhythms?
00:19:02 <Cale> tuxplorer: $ has really low precedence
00:19:05 <Korollary> tuxplorer: it's just convenient syntax to reduce the numbers of parens you would type otherwise.
00:19:23 <Korollary> I mean it's not syntax. It;s an actual function.
00:19:45 <workbean> thanks goltr, I got your answer in the logs 
00:19:56 <Korollary> wow, I was right.
00:19:59 <Cale> laurence: there are any number of such systems available
00:20:03 <goltrpoat> i answered something?
00:20:25 <Korollary> goltrpoat: Yes. the school of expr vs craft of regarding newbie with C background.
00:20:26 <tuxplorer> thanx Korollary and Cale
00:20:30 <laurence> Cale: Mmm, not getting the point across.
00:20:34 <goltrpoat> oh oh.  right
00:20:37 <workbean> yeah, I had to shutdown my chat client after asking a question regarding haskell books (sorry guys)
00:20:56 <goltrpoat> np
00:21:10 <Cale> but probably something relational, with a notion of time, as well as various measurements taken in the body of a generic animal
00:21:23 <Korollary> that is quotable
00:21:54 <Cale> Korollary: what is?
00:21:59 <Korollary> your last sentence
00:22:03 <Cale> heh
00:22:21 <skew> Korollary: need sleep?
00:22:43 <Cale> Basically, the idea is that you write down, in precise terms, what it is that you expect. Your prediction.
00:22:46 <tuxplorer> and what is runFilter finction for? ?all-dicts runFilter gives no matches found
00:22:48 <laurence> There are few good formal systems in biology, but it is valid science.  Physics has more than any other science, but we don't start with them because God doesn't answer his telephone much when we call to ask.
00:22:53 <Cale> The content of science is a machine for predictions.
00:23:03 <skew> goltrpoat: do you expect to use that C background for much?
00:23:09 <Cale> and I'd claim that's all there is to science
00:23:10 <skew> workbean: you, rather
00:23:17 <Korollary> @index runFilter
00:23:17 <lambdabot> bzzt
00:23:22 <goltrpoat> skew:  in FP?
00:23:22 <laurence> Cale: You have no idea how little that has to do with real, working science.  At least if you think that there is a formal system nearby.
00:23:25 <Cale> it's simply a great big tool for making predictions, and nothing more
00:23:26 <workbean> skew, no, I know that FP is very different
00:23:26 <Korollary> tuxplorer: I don't know of a runFilter function
00:23:31 <skew> Cale: basysian inference with a solomonoff prior?
00:23:44 <Lokadin> @hoogle take
00:23:44 <lambdabot> Prelude.take :: Int -> [a] -> [a]
00:23:45 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
00:23:45 <lambdabot> Data.PackedString.takePS :: Int -> PackedString -> PackedString
00:24:10 <skew> workbean: ok, then whatever people say should be pretty good.
00:24:28 <Cale> skew: something like that. I wouldn't quite reduce it to computation per-se, but basically.
00:24:29 <Korollary> Cale: It's mostly reverse engineering where you try to fit the reality to a model that you didn't know a priori
00:24:40 * laurence is sorry for hijacking the channel and promises to think about Haskell again.
00:24:43 <workbean> skew, I just didn't want of those programming books that starts out with an introduction to the computer's components 
00:24:43 <Cale> Korollary: yes
00:24:49 <workbean> one of^
00:24:58 <Cale> Korollary: but that doesn't mean that you shouldn't have a formal system until the very end
00:25:09 <Korollary> laurence: we have #haskell-blah (serious) for this stuff.
00:25:21 <Cale> You should begin to put something together straight away. It doesn't have to be in the language of mathematics either.
00:25:49 <laurence> But then why call it a formal system?  Oh, never mind, I'm not doing that anymore.
00:25:51 <ADEpt> dons: is it ok to update descriptions of proposed SoC projects at this time?
00:25:55 <Cale> But sticking to logic would be a good idea.
00:26:22 * goltrpoat wonders if it's too late to mention that he works in computational mechanics
00:26:24 <laurence> Cale: Logic is separate and not negotiable for any of the sciences.
00:27:38 <dons> ADEpt: I see no harm.
00:27:38 * laurence hopes that makes Cale feel better.
00:27:38 <Korollary> I say #haskell-blah
00:27:38 <laurence> So, how about that Haskell?  I hear it's an interesting language....
00:27:38 * dons -> cooks dinner
00:27:38 * Korollary refuses to sleep
00:27:39 <Cale> laurence: because you can, in some obvious way, put in one of some class of situations, and get a prediction.
00:27:43 <skew> workbean: Simon Peyton-Jones has some interesting papers on the implmentaiton of GHC
00:28:41 <skew> workbean: His page is at http://research.microsoft.com/~simonpj/
00:28:44 <Korollary> workbean: I've read school of expr, and it assumes no particular background, nor does it assume that you are a six year old. It's a good book, albeit a bit boring imho.
00:28:59 <Cale> laurence: I suppose that I'm happy so long as one could take the thing and, without so much thought, turn it into a formal system.
00:29:13 <Cale> Like, most of biology could.
00:29:33 <norpan> does anyone know of a unicode version of ByteString?
00:29:52 <Cale> norpan: if you're just working with UTF-8, ByteString is often good enough
00:30:19 <Cale> norpan: but there's not much yet in the way of exotic encodings
00:30:22 <norpan> Cale: i realize that but i'm thinking word16
00:30:24 <workbean> alright, thanks guys..
00:30:28 <laurence> Cale: I think that's completely wrong for biology, but I'm trying not to say "we've heard this before, and our way is the one that worked." :-)
00:30:32 <metaperl> is it true that a function can always be modelled as a box with some inputs and a single output?
00:30:34 <Korollary> Cale: How? Are bytestring operations aware of multichar symbols?
00:30:49 <goltrpoat> "we" = biologists?
00:31:12 <norpan> Korollary: no you have to be careful when using take and such
00:31:24 <Cale> Korollary: they're not, but if you don't do too much, it won't break anything.
00:31:37 <laurence> goltrpoat: "we" = scientists, not mathematicians.  Not that we aren't grateful that they polish the formal systems so well once we figure out ones that work.
00:32:16 <norpan> maybe i should extend bytestring with takeUTF, headUTF etc
00:32:17 <skew> still getting syntax errors trying to include linux/aio.h, even trying the version from kernel sources
00:32:21 <norpan> takeUTF8
00:33:10 <norpan> i'm working with UTF-8 files, so mmapFile is really good for me
00:33:18 <JohnMeacham> Korollary: I keep getting mail for him. I have a good idea of how controversial an issue is by how many people send him an email without bothering to check how to spell his name.
00:33:54 <palomer> ok, when I send off my proposals to haskell.org, who gets to read it?
00:33:55 <goltrpoat> laurence:  i'm just curious why you're talking on behalf of biology.
00:33:55 <Cale> laurence: I just think that it should be obvious just what it is that you claim to be predicting. Certainly if you *claim* to use some formal system, you should abide by its rules.
00:34:15 <JohnMeacham> Korollary: He (Jon Meacham) said my web page is a good contrast to his.
00:34:45 * palomer is off to bed
00:34:56 <laurence> goltrpoat: Because unlike physics, they have very few good mathematical models, but certainly do good science.  Same method, clearer example.
00:34:56 <Korollary> JohnMeacham: Wow. He writes on American history, right?
00:35:33 <JohnMeacham> Korollary: yeah, and for newsweek, he is the head editor there.
00:35:47 <laurence> Cale: It's always nice when you get to the stage where you have enough of a clue to start predicting.  Sometimes, you just gather enough data to think about.
00:35:55 <goltrpoat> laurence:  are we talking molecular biology?  biochemistry?  microbiology?  what exactly?  because each has quite a set of mathematical models.
00:36:10 <Cale> laurence: It would be easy to construct many good mathematical models for biology, it's just that not too much would be gained by it. The systems are formalisable, but the formal versions are no easier to work with.
00:37:02 <laurence> goltrpoat: Most of the biologists I knew were pretty classical biologists, not the harder versions.  They're getting enough insight to start getting decent mathematical models, which after all is what I said.
00:37:17 <laurence> Darwin didn't have a useful one, but he was doing science.
00:37:57 <goltrpoat> i didn't say mathematics is a prerequisite to science, i was just pointing out that your statement was odd at best.
00:38:07 <laurence> Cale: Generally, people who try to formalize for the sake of formalizing don't do anything useful.
00:38:12 <Korollary> I don't think the issue here is the absence or presence of a formal model. I think what bugs Cale is to have a model that is confirmed by experiments but is also mathematically broken.
00:38:24 <Cale> Yes
00:39:20 <skew> then translate the brokenness to an experiment
00:39:26 <laurence> Korollary: This is the oldest argument in the book, so I know how it goes. :-)  Cale's issue is that he doesn't realize that the physics is sometimes being guided by something outside of his field, or at least outside of his comfort zone.
00:39:31 <Cale> Also, it annoys me when you have to say "oh, don't look at those predictions over there"
00:39:54 <Cale> laurence: hm?
00:40:22 <Cale> It's being guided by observation.
00:40:30 <Korollary> laurence: That is ok, but if the model is indeed correct, then that invalidates part of mathematics, which is ok (since it happened before).
00:40:45 <laurence> Korollary: It often works the other way anyway--the formal system is constructed by a mathematician irritated by the sloppy physicist's math.  That's fine--the point is we already knew the answers, but sometimes it takes a mathematician to help fix it up. :-)
00:41:16 <Korollary> happily ever after
00:41:31 <laurence> Cale: Yes, and also deep physical principles.  Again, read _The Character of Physical Law_.  You'll like it, I think.
00:41:43 <Korollary> I should read it. I like Feynman.
00:42:21 <laurence> I actually was intentionally referring to a specific case earlier when I made some crack about abusing a Hilbert space until it accepts a non-normalizable basis.
00:43:00 <laurence> If you annoy mathematicians enough that way, sometimes they do really good work for you by generalizing their Hilbert spaces until they do the job. :-)
00:43:08 <Korollary> aha!
00:43:20 <goltrpoat> this sort of feels like a fan of a visiting football team visiting a pub right next to the venue, being extremely vocal about how his team is going to kick ass, and the regulars are just sort of sitting there going, yes, good point.
00:43:23 <laurence> It beats working for a living, anyway. :-)
00:43:26 <Korollary> Cale, you were being set up, pal.
02:54:16 --- topic: '["Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:","http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion","Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]'
02:54:16 --- topic: set by xerox on [Tue Apr 25 18:17:10 2006]
02:54:16 --- names: list (clog nnunley falconair rfsu kombinator mikezs doublec pesco _roconnor revision17_ eivuokko joelr1 nixcsd86 Muad_Dibber _julian_ arguile Cale palomer dblhelix rasfar cmeme spamsch mattam isydor psnl vincenz Igloo mux integral audreyt |metaper| eno wolverian psi olliej_ JaffaCake xerox jethr0_ ProfTeggy drrho beelsebob_ boegel Itkovian amiddelk iblechbot Nomius Nshag ADEpt tuxplorer SimonRC dons shrimpx danly CLxyz petekaz tessier emu)
02:54:16 --- names: list (kolmodin Narrenschiff cpatrick LoganH mokus ozone mlh NameTab kzm eyck mathrick joe_k sellout xerox__ gzl sieni ksandstr Cale_ mornfall orbitz genneth morans Bo Korollary JohnMeacham lumi aasmith Oejet sjanssen ex_nor ayrnieu tessier_ msph ramkrsna ewsu kpreid_ wilx triplah ski mnislaih thedward d0c perspectival zamez Khisanth SamB Hmm_| sethk turok` Philippa khaladan Plareplane M3wkuskerekHarc tizoc Nioate_ goltrpoat araujo Adamant)
02:54:16 --- names: list (lambdabot metaperl shawn ofelt pirroH gripe swoolley-voted shapr jip takuan yaarg cbus_ lesshaste profmakx Guest49764 ChilliX slipstream bolrod xinming kzm_ Si\Uni drbean_ SubStack Trixsey astrolabe dcoutts Dark-Side _shawn kisu arjanb Beelsebob Lokadin Lemmih piggybox lispy mahogny JKnecht greenrd Poeir nothingmuch tromp earthy ulfdoz moonlite liyang Lor rey_ juhp KydoC nattfodd reppie svens borism kosmikus Wallbraker sowhat rashakil)
02:54:16 --- names: list (gdsx neologism ricebowl edwinb magagr scw cods Magical1_away resiak Spark musasabi bdash bobwhoops johs gn WillKW ohub noj ValarQ kpk Yhtagiwt pejo qwr ibid dfhaii norpan dany2k rkeene Lunar^ flux__ djw wli dcoutts_ Maddas)
02:54:45 <xerox> Just a question, what is the reason why trac can't do some of the darcs related things?  Is it due to the design, the interface, or what else?
02:55:28 <rfsu> mainly due to the design decitions
02:56:53 <rfsu> xerox: it would not be a direct trac clone either, just an application trying to solve problems in the same domain, hopefully in a better way for darcs users
03:06:18 <joelr1> dons: did you remove readInt from fps?
03:08:09 <vincenz> dons: did lambdabot crash?
03:12:02 <vincenz> anyone?
03:12:08 <vincenz> did lambdabot crash too when the servers reset?
03:13:11 <jip> is there a way to check if an ELF executable was created with ghc?
03:14:56 <JaffaCake> has anyone heard from Wolfgang Thaller recently?
03:15:04 <rfsu> xerox: http://hackage.haskell.org/trac/summer-of-code/ticket/76 will this do?
03:16:01 <joelr1> > ord '0'
03:16:03 <lambdabot> 48
03:16:06 <joelr1> hmm
03:16:11 <joelr1> hoogle ord
03:16:29 <xerox> rfsu: yeah I think so.
03:16:33 <joelr1> Hoogle ord
03:16:43 <joelr1> where does ord live?
03:17:00 <xerox> rfsu: add yourself to the People page too.
03:17:52 <goltrpoat> Data.Char
03:18:02 <joelr1> ah!
03:19:35 <jip> JaffaCake: is it possible that 6.5 snapshot installation is broken? it install stuff to /usr/local/lib/-6.5.20060502/
03:19:57 <JaffaCake> jip: hmm, it shouldn't do that
03:20:16 <JaffaCake> possible though, I haven't tested installation of binary dists since the source tree reorg
03:20:20 <jip> maybe it renames this directory at the end of installation? i cancelled it once i saw it doing this
03:24:55 <JaffaCake> jip: should be fixed from tomorrow
03:25:57 <shapr> palomer: You called?
03:28:25 <JaffaCake> dons: oops, I pushed the wrong patch
03:28:45 <JaffaCake> I didn't notice that your later version was a replacement, not a delta
03:29:28 <vincenz> shapr: hiya
03:29:32 <JaffaCake> dons: can you resubmit a delta for the hGetLine fix?
03:29:56 <vincenz> JaffaCake: why do you keep talking to dons, afaict, he hasn't spoken in a while
03:29:58 <vincenz> @seen dons
03:29:59 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 3 hours, 2 minutes and 54 seconds ago.
03:30:41 <jip> JaffaCake: hm... cool thanks :)
03:33:46 <vincenz> shapr: can I trouble you for a sec?
03:36:43 <JaffaCake> dons: if you're listening, never mind, I applied the patch manually
03:37:09 <xerox> Is it "I have already got" or "I already have got"?  I think it's the former.
03:39:00 <dons> JaffaCake: all good? patches applied ok?
03:39:09 <JaffaCake> yep, no problems
03:39:32 <JaffaCake> except the hGetLine patch, because it included the original Data.ByteString patch too
03:39:38 <JaffaCake> so I patched it in by hand
03:39:42 <dons> ah. but darcs should handle that?
03:39:53 <dons> (at least it did in testing. hmm)
03:39:55 <JaffaCake> well, it said "bad patch bundle" for me
03:40:02 <dons> hmm. ok
03:40:40 <tromp> the former
03:41:50 <xerox> tromp: thanks.
03:41:51 <JaffaCake> dons: hmm, think it might have been a \r\n issue
03:42:17 <JaffaCake> thunderbird saved the patches with \r\n line endings
03:42:29 <vincenz> dons: small question, did lambdabot stall when the servers reset?
03:42:33 <JaffaCake> strange that the patches applied cleanly, though
03:42:57 <JaffaCake> and I don't have a Data.ByteString with \r\n's in it
03:43:08 <vincenz> tromp: hello!
03:43:19 <dons> yeah. oh well. the patches see to be ok.
03:43:24 <dons> seem
03:43:28 <tromp> g'afternoon
03:48:14 <falconair> does anyone know when the intel version of os x will get a ghc release (for darwinports) ?
03:49:44 <tromp> how is ghc architecture dependent?
03:50:03 <tromp> in the precompiled libraries?
03:50:13 <tromp> or in other ways too?
03:51:33 <falconair> tromp: all i know is that when i do "sudo port install ghc" I get an error telling me that intel version is not yet available
03:56:34 <tromp> i see
03:57:09 <tromp> sometimes it doesn't pay to be an early adopter:)
03:57:26 <falconair> i'm learning that :)
04:01:20 <vincenz> tromp: I have found that it almost never does
04:01:30 <vincenz> tromp: prices are usually higher, product is usually less stable
04:01:50 * vincenz has a BUNCH of books on c++ at home where his parents live that are completely worthless
04:03:52 <vincenz> dons: ping
04:04:23 <dons> vincenz: ?
04:04:31 <vincenz> dons: lambdabot: No connection
04:04:36 <dons> ?bot
04:04:36 <lambdabot> :)
04:04:43 <vincenz> I meant oasisbot
04:05:13 <vincenz> must be the freenode network that's upping
04:05:16 * vincenz grumbles
04:05:34 <dons> hmm
04:05:37 <vincenz> can't I just give it the general irc.freenode.net server and it will autoconnect?
04:05:56 <dons> is the old bot still online by chance? i.e. ghosted?
04:06:00 <vincenz> no
04:06:05 <vincenz> I got dc'd too
04:06:08 <vincenz> but irrsi reconnects
04:06:11 <vincenz> and I was connected to the main server
04:06:20 <vincenz> my whois shows me I'm currently using a US server
04:07:13 <dons> sorry, no idea.
04:07:20 <vincenz> okies
04:07:45 <vincenz> thx
04:09:07 <vincenz> dons: btw if you change one of the plugns and don't make clean, the plugins are not recompiled
04:10:15 <dons> hmm. no that shouldn't be the case.
04:10:21 <dons> the dependency chaser should handle all that.
04:10:28 <dons> (at least it does at this end)
04:10:39 <vincenz> see I had updated DarcsWatchPatch
04:10:41 <vincenz> to use another chan
04:10:44 <vincenz> it kept using the sae chane
04:10:47 <vincenz> until I did make clean and
04:11:07 <dons> ok
04:11:50 <vincenz> but I think this might be a thing with ghc I noticed similar behaviour with other progs
04:11:59 <vincenz> dependent files that are changed do not cause recompile
04:13:18 <vincenz> last item... 
04:13:42 <vincenz> DarccsPatchWatch gives you the latest update when you do a @repos... this lastest update is basically the time you actually call @repos and not the time something changed in darcs
04:14:36 <dons> ? more info. (note that i'm not the author of DarcsPAtchWatch..)
04:15:46 <vincenz> dons: the plugin gives three commands: @repo-add, @repo-dell, and @repos... the last gives a status quo... it tells oyu of the latest update, however it gives basically the timestamp that you call @repos, meaning that whenever you call it, it tells you the latest updatei s righht now
04:17:16 <dons> ok. I thought repos was just supposed to list the registered repos
04:17:22 <vincenz> it does
04:17:26 <vincenz> but it also tells you the latest change
04:17:33 <vincenz> err
04:17:34 <vincenz> last announcement
04:17:40 <vincenz> which is basically at the moment you call @repos
04:17:42 <vincenz> 13:10 < oasisbot> {{Repository "/home/icfp/icfp", last announcement: Wed May  3 12:07:32 CEST 2006}}
04:17:50 <dons> ah right. yes. i remember
04:18:09 <vincenz> I would think that that timestamp should only be updated when it checks and finds something new
04:18:13 <vincenz> not when you query
04:18:16 <vincenz> I'll look into it
04:18:22 <dcoutts_> JaffaCake, how many gcc version-specific tests do we have for ghc? I've been having problems from gentoo users who upgrade gcc after installing ghc. Perhaps we need some mechanism to configure ghc after chainging gcc.
04:18:38 <dons> that seems reasonable, vincenz
04:18:57 <dcoutts_> JaffaCake, eg you've got this -fno-unit-at-a-time thing and I get problems with disabling hardened-gcc fearures
04:19:04 <dons> feel free to submit a patch. i think you're the only person using the darcs watcher atm.
04:19:21 <JaffaCake> dcoutts_: yes, these configuration things are baked in to GHC, and that's not good
04:19:24 <dcoutts_> JaffaCake, the main example is people upgrading to gcc4 after installing ghc
04:19:39 <vincenz> dons: how does one submit patch?
04:19:41 <JaffaCake> I wonder if we can enumerate them all, for a start
04:19:58 <dons> JaffaCake: couple of ByteString patches just sent. brings fps and fptools/ByteString into sync (and removes some cbits :)
04:20:11 <dcoutts_> JaffaCake, do you have any suggestion how we might make it more dynamic so it can be reconfigured later?
04:20:13 <dons> vincenz: darcs send.
04:20:14 <JaffaCake> dons: greast
04:20:35 <JaffaCake> dcoutts_: I'm not sure, it would mean GHC figuring out the gcc version on the flu
04:20:39 <JaffaCake> er, fly
04:20:56 <dcoutts_> JaffaCake, that or providing ghc-config, like gcc-config
04:20:58 <JaffaCake> what goes wrong when you upgrade to gcc4?
04:21:55 <dcoutts_> JaffaCake, we're using -fnopie -fno-stack-protector to disable the hardened gcc features in gcc 3.x. However gcc 4 does the hardened stuff differently and so has different flags to disable that stuff.
04:22:12 <JaffaCake> oh, we could put these flags in the RTS package config, that way they would be tweakable without rebuilding GHC
04:22:18 <dcoutts_> the old gcc-3.x hardened gcc patches are gentoo specific, the gcc-4 ones are in upstream I think
04:22:20 <dons> dcoutts_: ah, that's interesting. i just noticed a few days ago I know need -fno-stack-protector on the head.
04:22:53 <dcoutts_> dons, right, but be careful because not all gcc's support that flag. I presume you're doing that just for OpenBSD right?
04:23:03 <dcoutts_> JaffaCake, that's a good idea!
04:23:53 <kosmikus> JaffaCake: yes, sounds nice. dcoutts: then we might even make eselect update the flags for us on a gcc change
04:24:22 <dcoutts_> JaffaCake, so we might make a tool that changes the rts flags and you could run that during the ghc install and we could run it again later if gcc changes.
04:24:40 <JaffaCake> dcoutts_ yes
04:24:50 <dons> dcoutts_: yup.
04:25:16 <dcoutts_> JaffaCake, /usr/lib/ghc-x.y/gcc-conf or something
04:25:24 <joelr1> dons: hi! where did readInt go?
04:26:43 <JaffaCake> dcoutts_: sounds like a plan... I don't suppose you'd care to... :)
04:26:48 <dcoutts_> JaffaCake, and hopefully such a prog could be sufficiently easily extensable that it could be patched by distros for distro-specific gcc things (like the hardened gcc patches in Gentoo & OpenBSD)
04:27:00 <dcoutts_> JaffaCake, I'll see if I can find a minion...
04:27:08 <JaffaCake> great :)
04:27:19 * dcoutts_ notes that the Gentoo Haskell team is up to 5 members
04:29:10 <vincenz> dcoutts_: icfp team?
04:29:40 <dcoutts_> vincenz, heh, but kosmikus & I already have an ICFP team
04:31:00 <musasabi> One solution would be to have a GCC option prefix for -fif-supported-<option>
04:31:16 <musasabi> (because Gentoo etc already have a GCC wrapper)
04:33:18 <dcoutts_> JaffaCake, so the rts package currently has some ld-options and no cc-options. We'd either need some way of preserving the existing options or some way of generating them.
04:33:26 <dcoutts_> ie all the -u GHCblag_blah things
04:33:43 <vincenz> dcoutts_: just the two of you?
04:34:19 <dcoutts_> vincenz, well the year we won it was kosmikus, Igloo, Heffalump and me.
04:34:24 <falconair_> I have a theory question: does denotational semantics means that a program is reduced to the simplest lambda calculus?
04:35:07 <_roconnor> falconair_: not really, it is reduced to mathematics
04:35:17 <JaffaCake> dcoutts_: I suppose you just regenerate them each time, based on the prevailing configuration
04:35:21 <_roconnor> the lambda calculus still has operational semantics
04:35:43 <_roconnor> but evalution is totaly gone in denotational semants IIRC
04:35:45 <JaffaCake> dcoutts_: i.e. the script would contain a recipe to generate ld-options and cc-options for the RTS package
04:35:58 <dcoutts_> JaffaCake, right
04:36:41 <dcoutts_> JaffaCake, and how do we generate the "-u GHCziBase_foo ..." bits?
04:36:44 <falconair_> _roconnor: what kind of mathematics?  isn't lambda calculus math?
04:36:51 <JaffaCake> maybe the script could generate the whole of the RTS package config, there's a lot of #ifdefery in there
04:37:23 <dcoutts_> JaffaCake, where is it currently generated in the build system? ie where do I start looking?
04:37:42 <JaffaCake> rts/package.conf.in
04:37:48 <dcoutts_> ok ta
04:38:12 <falconair_> _roconnor: so is it possible for me to build up haskell only from lambda calculus? 
04:38:31 <xerox> falconair_: adding a typing system, yes :-)
04:38:47 <_roconnor> falconair_: what do you mean by ``build up''?
04:38:54 <falconair_> including the monadic parts?
04:38:58 <xerox> Yes.
04:39:01 <vincenz> dcoutts_: impressive
04:39:08 <vincenz> dcoutts_: what year?
04:39:12 <dcoutts_> 2004
04:39:17 <vincenz> ants?
04:39:19 <vincenz> or no
04:39:24 <vincenz> yeah, ants
04:39:24 <dcoutts_> yep, ants
04:39:29 <vincenz> racecars was the year b4
04:39:30 <_roconnor> falconair_: Yes lambda calculus is mathematics, but denataional semantics ususal converts programs into set-theoretical functions.
04:40:20 <_roconnor> falconair_: If you want to give precice semantics to I/O, you will likely need a bit more than lambda calculus
04:40:21 <falconair_> 'build up' means that if i could program with lambda calculus (no numbers, not strings/cars, etc.)i could write an interpreter which would process (interpret?) haskell programs
04:41:29 <_roconnor> since lambda calculus is turing complete, you can interpret most of haskell.
04:41:46 <dons> joelr: $ grep -l readInt Data/* Data/*/*
04:41:46 <_roconnor> just like you can interpet haskell in C
04:41:47 <dons> Data/ByteString/Char8.hs
04:41:56 <_roconnor> just like you can interpet haskell in C, C++, perl, or even haskell
04:42:34 <falconair_> what I am getting at is this: if programming langauages as powerful as haskell can be built out of such basic formalisms...they how come relational databases are so limited in the capabilities (the basis of relational databases is, as many are at pains to point out, are logic and set theory)
04:42:56 <falconair_> actually, is there a channel here that discusses theory, rather than actual technologies?
04:44:16 <yaarg> relational databases come form basic formalisms too
04:44:21 <yaarg> i'm not sure what you're getting at
04:44:24 <_roconnor> falconair_: Sorry, relational databases are beyond my knowledge; I can't answer that question.
04:50:21 <vincenz> is John Meacham on irc?
04:51:32 <ADEpt> he was
04:51:50 <vincenz> what's his nick
04:52:08 <ADEpt> Are there lone souls (besides me) looking for ICFP 2006 team to join/collect?
04:52:46 <dcoutts_> JaffaCake, so we'd want to generate the flags by having arch, os & gcc-version specific additions. They'd correspond to the current #ifdefs in rts/package.conf.in and in DynFlags:machdepCCOpts
04:52:53 <ADEpt> vincenz: i dont remember :(
04:53:26 <vincenz> ADEpt: we have quite a team for ICFP
04:53:46 <dcoutts_> JaffaCake, or at lest pull out gcc-version specific bits from Dynflags, perhaps leaving arch/os specific stuff there
04:53:47 <ADEpt> vincenz: well. are you guys hiring? :)
04:53:59 <vincenz> ADEpt: http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Team
04:54:09 <falconair_> yaarg: (sorry my connection is not stable) relational databases come from set theory and logic, introductory functional books mention lambda calculus which is also basically logic (as i understand it), i'm trying to figure out what benefits there are if the two are combined
04:54:18 <dcoutts_> JaffaCake, and of course some of it is dynamic, depending on dflags
04:54:42 <ADEpt> vincenz: i did a quick google search and seems like i'm mistaken about John Meacham :(
04:54:49 <vincenz> ADEpt: okies
04:55:05 <vincenz> ADEpt: you know alar?
04:55:12 <vincenz> given how you're both from .ru
04:55:42 <ADEpt> vincenz: not in RL. But we also meet in other channel occasionnaly :)
04:55:47 <vincenz> seen him around?
04:55:59 <vincenz> @seen alar
04:55:59 <lambdabot> I saw alar leaving #haskell 1 month, 1 day, 18 hours and 54 minutes ago, and .
04:56:02 <ADEpt> vincenz: I try to round some people from ru_lambda and ru_declarative right now.
04:56:17 <ADEpt> vincenz: correction. I'm from .ua, but that's a close thing
04:57:17 <vincenz> where is .ua?
04:57:28 <vincenz>  ADEpt [n=ADEpt@jabber.hst.ru
04:58:00 <Muad_Dibber> vincenz: http://www.cia.gov/cia/publications/factbook/geos/up.html
04:58:04 <vincenz> ADEpt: ukraine?
04:58:09 <ADEpt> vincenz: ua == Ukraine. I'm from Kiev. It's on google map :)
04:58:17 <vincenz> ok
04:58:22 <vincenz> just wasn't familiar with the .ua
04:58:25 <ADEpt> hst.ru is XMPP<->IRC gateway i'm using
04:58:31 <vincenz> not quite russia really
04:58:56 <vincenz> Muad_Dibber: gotta love how you use cia.gov for that
05:00:10 <vincenz> holy cow texas is big
05:00:11 <shapr> falconair_: Seen the Functional Relational Programming article on LtU?
05:00:18 <shapr> vincenz: But California is bigger.
05:00:22 <vincenz> ukraine: slightly smaller than texas
05:00:30 <vincenz> ukraine: 600K km^2
05:00:34 <vincenz> belgium: 30K km^2
05:00:37 <Muad_Dibber> vincenz, the CIA geo factbook is quite a valuable source when looking up country information :)
05:00:43 <vincenz> Muad_Dibber: I agree
05:00:47 <vincenz> Muad_Dibber: lots of interesting tidbits
05:00:50 <wchogg> Texas is large, but a rather unpleasant place to live.  Only thing I miss about it is the food.
05:00:50 <shapr> shapr: 0.5m^2
05:00:56 <vincenz> shapr: that's a lot
05:01:04 <shapr> Hey, I'm sitting down.
05:01:14 <vincenz> you're 0.5 meter thick from shoulder to shoulder and you're a METER wide???
05:01:18 <falconair_> shapr: no, i haven't read it yet (it is probably over my head...as are mot LtU articles) ... i've been wondering this for a while :)
05:01:37 <ADEpt> vincenz: so. how to enroll as definite/possible member?
05:01:49 <vincenz> ADEpt: talk with me
05:01:55 <vincenz> join #oasis
05:01:58 <norpan> ah, now i found http://hackage.haskell.org/trac/summer-of-code/ticket/12
05:02:21 <vincenz> Muad_Dibber: does that site also mention "# nuclear weapons"?
05:02:26 <shapr> vincenz: Have you tried talking to JohnMeacham? ;-)
05:02:37 <vincenz> shapr: ooh...hmm...good point :O
05:04:24 <vincenz> shapr: btw... I've been thinking about structure
05:05:32 <shapr> Me too, I've been reading Luca Cardelli's polymorphism paper.
05:07:55 <vincenz> I mean
05:08:29 <vincenz> shapr: for the contest... miniteams work on different Modules, different Modules in ModuleA/ ModuleB/ ModuleC/ directories... with the lead making ModuleA.hs in the root dir to set up the interface
05:46:18 <vincenz> dcoutts_: how do I cancel my gtk2hs ml subscription?
05:46:41 <dcoutts_> vincenz, it should have a link in the mail headers
05:47:01 <dcoutts_> or go to the mailing list sign-up page on the gtk2hs website
05:47:06 <vincenz> okies
05:47:19 <dcoutts_> you're leaving us? :-(
05:47:28 <joelr1> suppose i have a huge text file to read in, a few Gb. i also need to filter the lines and maybe join some but not others. so as part of my filtering i build a new list of lines and when i'm done i reverse it since it's more efficient to build up the list by pushing to the front
05:47:34 <vincenz> well it's pretty lowvolume, and mostly 'how do I instlal'
05:47:52 <dcoutts_> vincenz, subscribe to the -devel list :-) it's more interesting
05:47:55 <joelr1> at no point in time will haskell try to load a few gb into memory, right? the whole thing will still be done lazily, right?
05:48:07 <vincenz> dcoutts_: hmm... there is no unsubscribe on that page
05:48:21 <vincenz> nm
05:48:34 <norpan> joelr1: at some point you will probably have most of the file in memory yes
05:48:59 <joelr1> norpan: how do i avoid that?
05:49:04 <dcoutts_> vincenz, there is. https://lists.sourceforge.net/lists/listinfo/gtk2hs-users
05:49:11 <vincenz> yeah I went there
05:49:28 <vincenz> listinfo... have to go to getoptions...
05:49:36 <norpan> joelr1: try it and if it doesn't work you have to resort to low-level file I/O
05:50:01 <joelr1> norpan: this sounds rather silly
05:50:29 <norpan> currently haskell is not fit to handle gigabytes of data efficiently in my experience
05:50:41 <joelr1> i could of course fire off a thread and give it each line of the file instead of building a new list and reversing it but there's gotta be an easier way
05:50:50 <vincenz> use FPS
05:50:53 <norpan> yes
05:50:56 <joelr1> i _am_ using fps
05:50:57 <norpan> mmapFile is good
05:51:03 <vincenz> joelr1: ok good :)
05:51:19 <joelr1> so i do a getContents then split on that and then i process a list of byte strings
05:52:11 <joelr1> my issue is that as soon as i read a line from disk and process it i really have no use for it anymore
05:52:26 <vincenz> joelr1: ah and the entire list is stored in mem?
05:52:49 <vincenz> joelr1: doesn't the GC notice you're past a line?
05:52:51 <norpan> i suggest using mmapFile if you can and process it using bytestring operations only
05:52:57 <joelr1> vincenz: i don't store anything, really, each line is an event
05:53:08 <vincenz> joelr1: yeah I had to do something similar, haven't' done it yet
05:53:09 <joelr1> allright
05:53:13 <joelr1> let me try that
05:53:13 <vincenz> plural-GB binary data files
05:53:20 <vincenz> each even is a 20 or so byte packet
05:53:34 <vincenz> so I'm very interested in your findings
05:53:42 <vincenz> joelr1: ascii or binary data?
05:53:50 <joelr1> ascii
05:53:56 <vincenz> ah
05:53:57 <vincenz> hmm
05:53:58 <norpan> if you use something like hGetLine you should probably be ok
05:54:03 <vincenz> yeah I changed my format to binary
05:54:07 <vincenz> which is more tricky with haskell
05:54:15 <joelr1> it's a dump from oracle but the problem is that it's cut into 80 characters per line
05:54:22 <vincenz> (my current analysis tool is in ocaml but I'd like to rewrite it in haskell to clean it up a bit)
05:54:29 <norpan> but if you use getContents you will be in some trouble I think
05:54:34 <vincenz> norpan: why's that?
05:54:36 <vincenz> norpan: it's lazy
05:54:41 <joelr1> whereas the lines themselves can be longer. so i need to join the lines
05:54:55 <norpan> it's lazy, but in my experience not lazy enough
05:55:00 <vincenz> joelr1: just parse the string then
05:55:04 <joelr1> i count the # of commas in the line and if i get less than needed i try to join with the next line
05:55:23 <joelr1> once i get the commas i push the line into another list and when i'm done i reverse and return the new list
05:55:34 <vincenz> ouch
05:55:37 <vincenz> reverse is a bad idea
05:55:39 <joelr1> why?
05:55:46 <vincenz> cause then you're forcing the entire thing into memory
05:55:46 <joelr1> it's idiomatic i thought
05:55:54 <joelr1> you push to the front of the list and reverse at the end
05:55:55 <vincenz> I wouldn't go that way
05:56:01 <vincenz> nono
05:56:03 <vincenz> not with haskell
05:56:10 <vincenz> you better use a lazy approach
05:56:14 <joelr1> which is?
05:56:15 <vincenz> generate the new list lazily
05:56:18 <joelr1> pushing to the end?
05:56:21 <vincenz> yep
05:56:27 <joelr1> interesting
05:56:34 <vincenz> let parsedlines = parse first:(parse remainder)
05:56:40 <vincenz> that way you're not forcing it all into memory
05:56:49 <vincenz> due to laziness
05:56:54 <vincenz> it will only force the thunks when necessary
05:56:54 <joelr1> true, i thought of that but ... you are absolutely right
05:56:56 <vincenz> and you won't get a stack blowup
05:57:05 <vincenz> I used to use ocaml
05:57:10 <vincenz> and I would've taken your approach
05:57:14 <vincenz> run through and reverse
05:57:20 <vincenz> but with laziness you can forego the memory overhead
05:57:22 <joelr1> vincenz: i do it that way all the time with erlang :D
05:57:33 <vincenz> kewl
05:57:43 <jip> f x y = let z = x+1 in      | y <0 = ...      | y == 0 = ...       | y == 1 = ...
05:57:48 <jip> how do i do that kind of guarding?
05:57:59 <ihope> Case statements?
05:58:11 <jip> how exactly does that work?
05:58:25 <mauke> case () of _ | ->
05:58:26 <ihope> Well, why not guard the function directly and use where instead of let?
05:58:27 <vincenz> ihope: no guards
05:58:33 <eivuokko> Doesn't where statement scope over guards.
05:58:43 <jip> ihope: hm... that sounds good
05:59:03 <ihope> I think pattern matching might work better...
05:59:30 <vincenz> guards are evil imo
05:59:34 <vincenz> very evil
05:59:38 <ihope> f x 0 = ...; f x 1 = ...; f x y = ... where z = x+1
05:59:41 <vincenz> they're not compile-checkable for completeneess
05:59:42 <ihope> Would that work?
06:00:37 <norpan> if y < 0 then ... else if y == 0 then ... else if y == 1 then else ---
06:00:40 <jip> vincenz: what should i do to check for certain ranges of values?
06:00:52 <vincenz> jip: if?
06:00:57 <ihope> ?? giant beetle
06:00:57 <lambdabot> Maybe you meant: . v
06:01:01 <vincenz> > 
06:01:02 <lambdabot> <stdin>: hGetLine: end of file
06:01:02 <ihope> Whhops.
06:01:04 <jip> if is ugly i think
06:01:05 <vincenz> @v
06:01:06 <lambdabot> Just 'J'
06:01:08 <vincenz> @v
06:01:09 <lambdabot> Just 'J'
06:01:13 * vincenz scratches his hed
06:01:19 <vincenz> > v
06:01:19 <lambdabot>  Not in scope: `v'
06:01:22 <vincenz> @v
06:01:23 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
06:01:23 <ihope> @.
06:01:23 <lambdabot> Not enough arguments to @.
06:01:29 <vincenz> wtf is v
06:01:35 <vincenz> > 10
06:01:36 <lambdabot> 10
06:01:36 <vincenz> @v
06:01:37 <lambdabot> "\"#$%&'()*+,\""
06:01:37 <norpan> some internal lambdabot shit
06:01:41 <ihope> @v
06:01:42 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
06:01:42 <vincenz> nope
06:01:44 <vincenz> that was 'v'
06:01:47 <vincenz> in the actual >
06:01:55 <ihope> @v 63
06:01:55 <lambdabot> "\"#$%&'()*+,\""
06:04:27 <bolrod> nata gain!
06:07:01 <ihope> @help v
06:07:01 <lambdabot> let v = show v in v
06:07:06 <ihope> :-)
06:07:40 <ihope> @v f(oo|u)bar
06:07:40 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
06:07:49 <ihope> @v I don't get it
06:07:49 <lambdabot> "\"#$%&'()*+,\""
06:08:01 <ihope> @v take 10 v
06:08:01 <lambdabot> Just 'J'
06:08:11 <ihope> Wuh...
06:08:42 <ihope> > let v = show (Just (head v)) in v
06:08:43 <lambdabot> "Just 'J'"
06:08:49 <ihope> Well... hmm...
06:09:52 <dozer> ihope: learned anything?
06:10:12 <ihope> About what?
06:10:26 <vincenz> ihope: life
06:11:19 <ihope> I guess I've been in it for a while.
06:11:48 <norpan> let life = work:life in life
06:11:50 <vincenz> it's not quanity but quality
06:12:17 <norpan> ok, penalty for me
06:12:18 <vincenz> norpan: or simply
06:12:21 <vincenz> > repeat "work"
06:12:22 <lambdabot> ["work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","
06:12:23 <lambdabot> work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","
06:12:23 <lambdabot> work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","
06:12:23 <lambdabot> work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","
06:12:24 <lambdabot> work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","work","
06:12:27 <lambdabot> [6 @more lines]
06:12:30 <norpan> to obvious
06:12:45 <vincenz> hmm
06:13:05 <ValarQ> makes vincenz a dull boy... :P
06:13:20 <vincenz> norpan: what about
06:13:34 <vincenz> > sequence . repeat $ if awake then work else fail
06:13:35 <lambdabot>  Not in scope: `work'
06:13:51 <vincenz> lambdabot: lucky you
06:14:04 <sjanssen_> haha
06:14:24 <norpan> Not in scope: `awake'
06:14:39 <ihope> @index fail
06:14:40 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:14:51 <ihope> Um...
06:14:59 <vincenz> ihope: it's part of any mona
06:15:15 <vincenz> class Monad where return :: a -> m a     fail :: String -> m a
06:16:04 <norpan> it's used when Pat <- m fails, right=
06:16:15 <norpan> ?
06:16:51 <vincenz> > fail "Couldn't find anything :: Maybe Int
06:16:52 <lambdabot>  lexical error in string/character literal
06:16:56 <vincenz> > fail "Couldn't find anything" :: Maybe Int
06:16:57 <lambdabot> Nothing
06:17:01 <vincenz> > fail "Couldn't find anything" :: [Int]
06:17:02 <lambdabot> []
06:17:16 <vincenz> norpan: amongst other things
06:18:02 <norpan> > do True <- return (Just False) :: Maybe Bool
06:18:03 <lambdabot>  The last statement in a 'do' construct must be an expression
06:18:12 <norpan> > do True <- return (Just False); return True :: Maybe Bool
06:18:12 <lambdabot> Couldn't match `Maybe Bool' against `Bool'
06:18:28 <norpan> > do True <- Just False; return True :: Maybe Bool
06:18:29 <lambdabot> Nothing
06:18:51 <norpan> indeed
06:19:12 <norpan> > do True <- Just False; return True :: [Bool]
06:19:13 <lambdabot> Couldn't match `Maybe' against `[]'
06:19:19 <norpan> > do True <- return False; return True :: [Bool]
06:19:20 <lambdabot> []
06:19:29 <norpan> > do True <- return False; return True :: IO Bool
06:19:30 <lambdabot> No IO allowed
06:19:38 <vincenz> > do true <- return False; return True :: [Bool]
06:19:39 <lambdabot> [True]
06:19:48 <norpan> subtle
06:19:58 <vincenz> norpan: there is worse around
06:20:08 <vincenz> > let 1 + 1 = 0 + 0 in 1 + 1
06:20:09 <lambdabot> Add a type signature
06:20:12 <vincenz> > let 1 + 1 = 0 + 0 in 1 + 1 :: Int
06:20:13 <lambdabot>  Non-exhaustive patterns in function +
06:20:23 <vincenz> > let x + y = x * y in 1 + 1 :: Int
06:20:24 <lambdabot> 1
06:20:41 <norpan> let (+) = (*) in 7+7
06:20:50 <norpan> i like that one
06:20:51 <vincenz> norpan: it's less subtle
06:20:57 <mauke> > let 6 * 9 = 42 in 6 * 9
06:20:58 <lambdabot> 42
06:21:04 <vincenz> :D
06:21:16 <vincenz> why does that one work
06:21:20 <vincenz> and not the multiply one
06:21:29 <vincenz> > let 2 + 2 = 2 * 2 in 2 + 2
06:21:30 <lambdabot> 4
06:21:32 <vincenz> > let 2 + 2 = 2 * 2 in 3 + 2
06:21:33 <lambdabot>  Non-exhaustive patterns in function +
06:21:38 <vincenz> >D
06:21:38 <norpan> > let x * y = 42 in zipWith (*) [1..10] [1..10]
06:21:39 <lambdabot> [42,42,42,42,42,42,42,42,42,42]
06:21:45 <mauke> vincenz: because 3 doesn't match 2
06:21:51 <vincenz> mauke: yeah I know
06:21:57 <sjanssen_> > let y * (x + 1) = x * y in 3 * 4 :: Integer
06:21:58 <lambdabot>  Non-exhaustive patterns in function *
06:21:58 <vincenz>  > let 1 + 1 = 0 + 0 in 1 + 1 :: Int
06:22:22 <norpan> it doesn't work because you use it recursively
06:22:27 <sjanssen_> > let y * (x + 1) = x Prelude.* y in 3 * 4 :: Integer
06:22:28 <lambdabot> 9
06:22:30 <vincenz> norpan: good point
06:22:35 <sjanssen_> woo! n+k!
06:22:37 <norpan> is there a non-recursive let?
06:22:51 <vincenz> norpan: that's impossible
06:23:11 <mauke> yes, lambda
06:23:15 <sjanssen_> norpan: you could simulate one with a lambda expression'
06:25:25 <dblhelix> sjanssen_: but then the let will also be monomorphic
06:25:49 <norpan> vincenz: what do you mean by impossible? i remember let and letrec
06:25:57 <vincenz> norpan: you remember ocaml
06:26:01 <vincenz> and scheme
06:26:04 <vincenz> and other nonlazy langs
06:26:18 <norpan> so why is non-recursive let impossible with non-strict evaluation?
06:26:21 <vincenz> norpan: you remember your own horrific past!
06:26:25 <norpan> hehe
06:26:34 <vincenz> norpan: nm it's not.. it's just a different mindset
06:26:41 <norpan> ah
06:26:52 <norpan> let impossible = possible in say vincenz impossible
06:27:07 <vincenz> unpossible
06:29:29 <Saulzar> Hello.
06:29:35 <norpan> hola
06:29:51 <ihope> Cmo ests?
06:30:57 <ihope> :-)
06:32:54 <vincenz> muy bien, cabron
06:35:10 <ihope> !
06:35:29 <ihope> Or, rather, !
06:39:16 <petekaz> vincenz: I'm new to haskell, could you explain why you don't get stack blowup with the non-tail recursive parsed lines example you shared with joelr1?
06:39:54 <petekaz> I'm also used to scheme/CL/erlang where you cons to the front, then reverse at the end.
06:40:00 <joelr1> Saulzar: where are you geographically?
06:40:21 <Saulzar> New Zealand
06:40:24 <joelr1> wow
06:40:30 <joelr1> Tenerife in da house
06:41:28 <vincenz> petekaz: be around in an hour or two?
06:41:33 <vincenz> petekaz: I have some urgent matters to attend to
06:41:48 <Saulzar> Yeah, I knew you were in a fairly exotic place. Here is much more ordinary :)
06:41:57 <doublec> Saulzar, where abouts in NZ? I'm in Wellington.
06:42:11 <Saulzar> Christchurch here
06:42:19 <petekaz> vincenz: yes
06:42:45 <joelr1> i think new zealand is quite exotic!
06:42:50 <joelr1> canaries are boring
06:44:28 <Saulzar> doublec, Interested in Haskell for long? Haven't seen many NZ-ers about, quite a few aussies though.
06:44:54 <doublec> Saulzar, I've been a long time 'watcher' of Haskell but only started actually using it in the last week or so. 
06:45:22 <doublec> I've had 'Haskell: Craft of Functional Programmnig' on the bookshelf for quite a few years without actually doing much with it.
06:45:36 <joelr1> @paste
06:45:36 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:45:45 <doublec> All the neat concurrency stuff coming out has got me interested :)
06:46:10 <sjanssen_> petekaz: I think I can answer your question.  It's laziness
06:47:57 <joelr1> @paste2
06:47:57 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:48:00 <joelr1> hmm
06:48:08 <sjanssen_> @yhjulwwiefzojcbxybbruweejw
06:48:08 <lambdabot> Just 'J'
06:48:50 <Saulzar> doublec, Ah. Cool. I'm enjoying it, refreshing change.
06:49:01 <norpan> @pasting
06:49:02 <lambdabot> Unknown command, try @list
06:49:22 <petekaz> sjanssen_: so instead of actually computing anything, nothing happens until you use the list?
06:49:40 <joelr1> i much prefer lisppaste to the haskell wiki, dunno why
06:49:52 <joelr1> vincenz: could you take a look at my paste? is that lazy enough?
06:50:11 <doublec> Just read the logs about the lazy approach to building lists in Haskell vs the Lisp approach of cons and reverse. Interesting!
06:50:19 <sjanssen_> petekaz: usually.  I didn't see the code.  I just guessed at what you were referring to ;)
06:50:45 <sjanssen_> petekaz: do you still have the URL?
06:50:54 <petekaz> well, it's the paste that joelr1 just posted
06:51:19 <norpan> if you want tail recursion (which is always good) then you can use an accumulator argument like this build (x:xs) acc = build xs (f x acc)
06:51:36 <joelr1> norpan: could you take a look at my paste please?
06:51:51 <petekaz> I was asking about a conversation between joelr1 and vincenz where he was explaining the common idiom of building a list in reverse, then reversing it, is a bad idea in haskell.
06:52:59 <petekaz> So now I'm confused, norpan is suggesting tail recursion, but vincenz indicated that stack blowup is not an issue in this specific instance of constructing a list.
06:53:31 <sjanssen_> petekaz: how do you feel about this: "map f (x:xs) = f x : map f xs; map f [] = []"?
06:53:46 <norpan> i'm just saying that tail recursion is always good :)
06:53:46 <vincenz> briefly re
06:53:54 <joelr1> petekaz: take a look at my paste, it's properly tail-recursive i think
06:53:55 <vincenz> ok
06:53:57 <vincenz> very quickly
06:53:58 <joelr1> and it should be lazy too
06:53:59 <vincenz> a tail
06:54:05 <vincenz> a list even
06:54:06 <vincenz> is head:tail
06:54:09 <vincenz> if you construct a list as
06:54:17 <vincenz> somhead:(somefunction returning list)
06:54:22 <vincenz> then that tail is stored in a thunk
06:54:25 <vincenz> it's not evalled
06:54:30 <vincenz> only when the tail is asked is it evalled
06:54:47 <vincenz> somehead:(recursive function)
06:54:52 <tromp> > head (0:undefined)
06:54:53 <vincenz> tail ->
06:54:53 <lambdabot> 0
06:54:56 <vincenz> eval recurisve function once
06:55:02 <vincenz> newhead:(recurisve function)
06:55:04 <vincenz> tail->
06:55:09 <vincenz> newhead2:(recursive function)
06:55:25 <vincenz> the memory reuqired is the already evalled list
06:55:29 <vincenz> and just the thunk for the tail
06:55:38 <petekaz> so writing a tail recursive version is not needed.
06:55:43 <vincenz> not for lists
06:55:46 <vincenz> if they generate a tail
06:55:51 <petekaz> got it.
06:55:51 <vincenz> now if you'll excuse me
06:55:53 <vincenz> I really have to run
06:56:04 <sjanssen_> not only is tail recursive not needed, it's less efficient!
06:56:08 <vincenz> yeah
06:56:12 <vincenz> cause you're forcing the entire storage
06:56:16 <vincenz> if you use the list incrementally
06:56:23 <vincenz> the gc will garbage collect as fast as you consume
06:56:31 <vincenz> thereby making memory req = one element + one thnk
06:56:42 * vincenz is off
06:56:50 <vincenz> bb
06:56:51 <vincenz> bbl
06:56:58 <petekaz> so joelr1, why did you write a tail-recursive verision?
06:57:14 <petekaz> you are working with lists no?
06:57:16 <joelr1> petekaz: as a matter of habit i guess. i'm now looking at it again
06:57:37 <norpan> gah unsafePerformIO
06:57:39 * petekaz wonders if he'll ever "get" haskell
06:57:42 <joelr1> it works but i guess it's not lazy enough
06:57:45 * Saulzar always thought it was usually good practice anyway
06:57:51 <sjanssen_> also, when you do certain things like "map f . filter p" GHC will optimize out the intermediate list, and turn it into a loop!
06:59:05 <norpan> there is a reason why IO is IO and still people use unsafePerformIO
06:59:16 <norpan> tired
06:59:35 <petekaz> sjanssen_: I learned that tidbit yesterday (I think from you).  It's done via the RULES stuff right?
06:59:52 <sjanssen_> petekaz: yes
07:00:46 <norpan> using an acc is not less lazy
07:00:57 <norpan> only slightly more memory inefficient
07:01:18 <sjanssen_> norpan: with a list it is.  Every cons in the list has to be touched before any answer is returned
07:01:20 <Saulzar> norpan, Interfacing with FFI stuff, I think it's meant for. But some other uses are possible, and mostly safe provided the programmer knows what they're up to perhaps.
07:02:29 <norpan> just looked at the paste below joel's and there its use is up the wall
07:02:41 <sjanssen_> > take 10 $ map (+1) [1..] {- lazy version -}
07:02:42 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
07:02:52 <MAHRAJA0> hi
07:03:06 <MAHRAJA0> i like to learn ...
07:03:14 <norpan> sjanssen_: hmmm, you're right
07:03:17 <MAHRAJA0> are some one help me
07:03:28 <sjanssen_> > let map f [] acc = reverse acc; map f (x:xs) acc = map f xs (f x : acc) in take 10 $ map (+1) [1..]
07:03:29 <lambdabot> Couldn't match `[a]' against `t -> t1'
07:03:32 <dcoutts_> xerox, I just got an email from a student asking about GStreamer bindings as a SoC project.
07:03:42 <sjanssen_> > let map f [] acc = reverse acc; map f (x:xs) acc = map f xs (f x : acc) in take 10 $ map (+1) [1..] []
07:03:47 <lambdabot> Terminated
07:04:19 <MAHRAJA0> what do u talk about?
07:04:27 <Saulzar> MAHRAJA0, Sure - ask away.
07:04:40 <MAHRAJA0> ok sorry
07:04:58 <MAHRAJA0> but i like to know
07:11:40 <petekaz> That was interesting
07:17:13 <joelr1> what's the easiest way to index a map or a hash on 3-4 integers? make a bignum?
07:17:40 <joelr1> i.e. make a "composite key" out of the integers by shifting them left and adding
07:18:11 <_roconnor> make a data structure
07:18:31 <joelr1> i already have but i still need a hash function for Data.Hashtable
07:18:31 <norpan> or use tuples
07:18:32 <_roconnor> then use it as a key in Data.Map
07:18:37 <sjanssen_> joelr1: either that or IntMap (IntMap (IntMap a))
07:18:38 <joelr1> ah
07:18:39 <joelr1> me stupid
07:18:51 <joelr1> a tuple would work for me
07:19:00 <sjanssen_> recursive intmaps are likely to be the most efficient
07:19:18 <joelr1> sjanssen_: IntMap keyed on a bignum?
07:19:35 <sjanssen_> joelr1: IntMap only works on Int, so you'd have to nest them
07:19:46 <sjanssen_> joelr1: but that's probably not worth it.  Tuple makes the most sense
07:19:47 <joelr1> hmm
07:19:51 <joelr1> yeah
07:19:58 <_roconnor> I beleive the request was for the *easiest* way ;)
07:20:15 <joelr1> tuples = easy enough! thanks
07:21:05 <norpan> but you'd still need a hash function for them
07:21:17 <joelr1> norpan: for tuples?
07:21:27 <norpan> if you want to use them as keys
07:21:46 <joelr1> so then i'm back to bignums as keys. is that fine?
07:23:20 <musasabi> joelr1: how many bits are those Ints?
07:23:21 <joelr1> or is there another way to hash 3-4 integers?
07:23:27 <joelr1> well, i assume 32
07:23:39 <norpan> well the easiest is something like hashInt (i1+i2+i3+i4) but that's not a very good hash function :)
07:23:55 <musasabi> and Data.HashTable is slow.
07:24:11 <joelr1> actually, sometimes i have 2-3 integers and sometimes i have an integer and a ByteString
07:24:31 <joelr1> musasabi: IntMap then?
07:25:10 <tromp> what range are you trying to hash to?
07:25:17 <musasabi> joelr1: what keys do you have and what queries do you make?
07:25:17 <joelr1> beats me
07:25:39 <norpan> if you just want a map, use Data.Map (Int,Int,Int) value
07:25:48 <joelr1> mostly i have player pairs, so two player ids. sometimes i have 4 ints like table id, hand id, player id, player id
07:25:49 <norpan> at least it's easy
07:26:01 <joelr1> and i also have player id, session id which is a byte string
07:26:11 <joelr1> i'm doing exact lookups
07:26:43 <norpan> make a datatype, derive Eq and Ord and use Data.Map
07:27:22 <norpan> can't think of an *easier* way
07:27:33 <musasabi> and you want a mutable data structure? which is very fast? Usually Judy >> IntMap > Map > Data.HashTable > [(k,v)]
07:28:03 <joelr1> musasabi: you keep mentioning judy. is that some cabalized module?
07:28:23 <joelr1> i  mean i know about judy arrays but i didn't know you had them for haskell
07:28:34 <norpan> Judy Haskell is director of the Hampton Falls Free Library
07:28:41 <joelr1> haha
07:30:01 <norpan> data YourKey = TwoInts Int Int | FourInts Int Int Int Int | IntAndByteString Int ByteString deriving (Eq, Ord); type YourMap = Map YourKey YourValue
07:30:07 <sjanssen_> do we really have a Judy binding?
07:30:26 <musasabi> joelr1: http://judy.sourceforge.net/ + some FFI code. JohnMeacham has wrapped the bitset part, but the other parts maps neatly with FFI. (I don't have a releasable binding at the moment)
07:30:58 <joelr1> musasabi: cool. i'll stick to map for now. i suspect i'll have far more trouble fitting things into memory :)
07:31:43 <notanotheridiot> hi, i'm writing a google SOC application for gstreamer bindings -any suggestions as to what I should put in
07:32:02 <lightstep> why is HashTable slower than Map? doesn't it require more of its key type?
07:32:10 <shapr> Igloo wrote a minimal gstreamer binding long ago. I think the source is still around.
07:34:16 <norpan> lightstep: it requires a hash function but not an ord function
07:34:33 <sjanssen_> lightstep: as I understand it, Data.HashTable just sucks right now
07:34:49 <lightstep> but when you write a hash function you can usually write a complete godel numbering for the type
07:35:12 <norpan> also updating a hash table seems like tricky business in a pure language
07:36:08 <norpan> never used Data.HashTable though
07:36:18 <norpan> but it seems like it has an IO type
07:36:19 <sjanssen_> norpan: updating *anything* in a pure language is tricky
07:36:34 <sjanssen_> unless you go IO
07:36:42 <norpan> well
07:37:07 <lightstep> you can go ST
07:37:12 <norpan> that's why hashtable has that IO type
07:37:22 <norpan> but a map backed by a tree is easier to handle
07:38:16 <joelr1> how do  i tell if my ghc was build with smp?
07:39:44 <dcoutts_> if ghc --version says 6.5
07:40:02 <dcoutts_> actually, I'm not really sure
07:40:28 <joelr1> yes, i just build myself a 6.5 on a smp machine
07:40:44 <dcoutts_> I think it's enabled by default in recent 6.5
07:41:41 <joelr1> ok, thanks
07:47:41 <dozer> > allChildren vs ns = [v:ns | v <- vs]
07:47:41 <lambdabot>  parse error on input `='
07:48:42 <norpan> map (:ns) vs
07:51:05 <sjanssen_> @pl allChildren vs ns = map (:ns) vs
07:51:05 <lambdabot> allChildren = flip (map . flip (:))
07:55:22 <jip> yikes, i got a scary ghc error message: "Expecting a function type, but found `t_a31B'
07:57:40 <dozer> appart from what I wrote being verbose, what is wrong with the syntax?
07:59:28 <lispy> dozer: lambdabot can't handle the full syntax of haskell.  I don't immediately see a problem
07:59:35 <lispy> > foo x = 1
07:59:35 <lambdabot>  parse error on input `='
07:59:43 <dozer> it's just that hugs was complaing as well
07:59:45 <dozer> :(
07:59:54 <lispy> as you can see, lambdabot in't so good with = less you strt with a let
07:59:55 <resiak> > let allChildren vs ns = [v:ns | v <- vs] in allChildren [1..5] [10..12]
07:59:57 <lambdabot> [[1,10,11,12],[2,10,11,12],[3,10,11,12],[4,10,11,12],[5,10,11,12]]
08:00:34 <lispy> dozer: you might want to get into the habbit of writting your functions down in a file anyway
08:00:51 <dozer> lispy: yeah - I was trying to test some stuff out ready to put in a file :)
08:00:57 <lispy> dozer: then you can just reload it in ghci with :r (not sure the hugs command)
08:01:35 * lispy recommends ghci over hugs because of the error reporting
08:01:44 <reppie> http://www.ecm-co.com/jetbeetle/
08:04:48 <petekaz> sjanssen_: just realized that your earlier definition of map is the same as the one in the prelude.
08:05:04 <Igloo> notanotheridiot, shapr: http://urchin.earth.li/darcs/ian/hgstreamer/ (ISTR I'm not entirely satisfied with the design)
08:05:15 <LordBrain> Is this channel logged?
08:05:54 <LordBrain> i mean, 24/7 by a bot, which posts the logs somewhere...
08:06:09 <lightstep> meme.b9.com
08:07:14 <LordBrain> thanks lightstep 
08:07:55 <dcoutts_> @seen notanotheridiot
08:07:55 <lambdabot> notanotheridiot is in #haskell. I last heard notanotheridiot speak 36 minutes and 11 seconds ago.
08:09:01 <dcoutts_> notanotheridiot, hia Johannes, so you found Igloo's previous go at gstreamer stuff.
08:09:29 <dcoutts_> Igloo, so what was the state of your GStreamer bindings? 
08:10:14 <Igloo> dcoutts_: They are not complete, and like I said there is a design issue or two I'm not entirely satisfied, but they worked last I tried them
08:10:36 <dcoutts_> notanotheridiot, btw, just because Igloo has worked on it before doesn't mean it's not a good idea for a SoC project. xerox's Cairo bindings last year were based on an initial implementation by someone else.
08:11:27 <dcoutts_> there is certainly value in doing a good polished implementation
08:11:33 <psi> is anyone willing to mentor the gstreamer bindings?
08:11:44 <dcoutts_> I would probably
08:11:48 <psi> ok
08:12:00 <dcoutts_> Igloo, you're rather busy right?
08:12:14 <Igloo> Right
08:12:26 <psi> I'm thinking about that or dbus. I'm investigating dbus currently.
08:12:45 <dcoutts_> psi, I'd be happy with either projects
08:12:49 <dcoutts_> apply for both!
08:12:49 <Igloo> Was this a listed project?
08:13:00 <audreyt> yay, I ported GHC on AIX 4.3.
08:13:01 <dcoutts_> Igloo, GStreamer? no it wasn't listed
08:13:03 <notanotheridiot> hi, soz, was eatiuing
08:13:11 <Igloo> OK; just curious about all the attention it's getting  :-)
08:13:26 <dcoutts_> Igloo, it was notanotheridiot's SoC idea
08:13:34 <psi> I added it yesterday to trac
08:13:40 <dcoutts_> oh ok, good
08:13:53 <dcoutts_> so it's several people's idea :-)
08:13:54 <notanotheridiot> i nicked the idea - sounded interesting
08:14:19 <notanotheridiot> but dbus would also be fun
08:14:28 <dcoutts_> remember it's ok to make more than one application, for different projects
08:14:35 <psi> *nod*
08:14:56 <dcoutts_> psi, notanotheridiot, so don't worry about several people applying for one project idea
08:15:00 <liyang> dcoutts_: *poke* How goes the high-level graphics layer on top of Cairo?
08:15:17 <dcoutts_> liyang, slowly. xerox is a busy man.
08:15:33 <liyang> Just wondering whether to suggest that to a keen students here.
08:15:43 <dcoutts_> liyang, suggest away!
08:15:53 <liyang> ah, okay. So am I. -_-;;
08:16:02 <dcoutts_> xerox, actually we need to update cairo to the 1.2 API
08:16:32 <dcoutts_> liyang, do you mean as a university project or a SoC project?
08:16:39 <liyang> dcoutts_: SoC
08:16:41 <dcoutts_> either would be nice
08:16:44 <dcoutts_> right, ok
08:16:52 <dcoutts_> liyang, you want to mentor?
08:17:39 <liyang> Not particularly, but given the student is located in the same city it might be of more helpful for him if I helped with any mentoring. >_>
08:17:50 <liyang> (What am I letting myself in for...)
08:18:22 <dcoutts_> liyang, it's easy to sign up... :-)
08:18:59 <liyang> yeah, too easy. I still have to tidy up those Gtk2Hs Debian packages. XD
08:19:08 <psi> jip: how's the gameboy emulator coming along?
08:19:35 <dcoutts_> liyang, how close are they to going into the main debian .deb archive?
08:19:42 <joelr1> jip: oh, you are the guy!
08:20:11 <liyang> dcoutts_: ask Igloo :)
08:20:25 <liyang> dcoutts_: Arjan made a bunch of suggestions which I've yet to follow up on.
08:20:35 <dcoutts_> ok
08:20:45 <liyang> Will get there... eventually.
08:20:58 <Igloo> Quite a way if I'm in the pipeline. You'd be better off asking CosmicRay  :-)
08:21:17 <jip> psi: haven't had time to work on it much
08:21:22 <liyang> lol
08:21:26 <jip> psi: devlog update coming later today though
08:22:01 <psi> cool! I have been wanting to create a NES emulator for some time now, and I was encouraged by your weblog.
08:22:35 <psi> have you been working on the performance?
08:23:14 <jip> psi:yeah,  i am working sort of right now on hacking a prototype for a design i have to see if it will have satifactory performance
08:23:17 <joelr1> jip: why did you go for gameboy as opposed to ds?
08:23:41 <jip> joelr1: nintendo ds? much much *much* more complicated to emulate then the original nintendo gameboy :)
08:23:51 <joelr1> jip: i see
08:23:56 <joelr1> due to 2 processors?
08:24:40 <jip> joelr1: not just that. even the gameboy advance is quite difficult to emulate. gameboy is probably the easiest console to emulate that has good classic games :)
08:25:01 <joelr1> cool
08:26:02 <Igloo> jip: Are you claiming pong isn't a good classic game?!
08:26:03 <jip> i also have doubts that haskell is fast enough to emulate even the super nintendo, without wizard-like optimization tricks
08:26:09 <jip> Igloo: yeah :D
08:26:22 <joelr1> jip: haskell compiles to machine code ;)
08:26:27 <Igloo> And there was me thinking we might be friends  :-(
08:27:30 <jip> joelr1: most of the popular snes emulators use some asm to get acceptable speed on low-end machines
08:28:49 <joelr1> what would be really cool is a haskell-based devkit for the nintendo ds. that compiled, say, scheme code
08:28:58 <joelr1> sort of like mini-GOAL for the ds
08:29:42 <psi> xerox__: last year, were you very familiar with cairo and the process of creating bindings when you started your project? or did you have time to include research?
08:30:31 <dcoutts_> xerox__, if I recall I we talked about bindings and how to use c2hs for quite some time.
08:31:40 <jip> how do i do like a "while" loop with monad?
08:31:46 <musasabi> dons: ping
08:32:00 <jip> recursive function?
08:32:50 <Igloo> Yes
08:33:12 <jip> Igloo: is there some sort of combinator function that can help me with this?
08:33:14 <musasabi> jip: you can do the inner loop in asm with Haskell too. Or better yet use JIT on your platform of choice.
08:33:18 <langdon> why
08:33:45 <jip> musasabi: what do you mean by JIT?
08:33:46 <joelr1> musasabi: what do you mean by jit on the platform of choice?
08:33:50 <joelr1> he
08:34:17 <langdon> why
08:38:25 <joelr1> jip: compiling the gameboy code to native code i think
08:38:28 <joelr1> clearly
08:38:30 <musasabi> jip: emit native code from the Gameboy code and execute that.
08:38:48 <dcoutts_> we need a jit library written in Haskell
08:39:05 <joelr1> dcoutts: for? 
08:39:05 <langdon> why
08:39:16 <dcoutts_> for use in ghc, yhc & things like your gameboy sim
08:39:48 <joelr1> ah, cool
08:39:59 <langdon> why
08:40:00 <norpan> what would a jit library entail?
08:40:09 <dcoutts_> writing an assembler
08:40:13 <langdon> entail
08:40:15 <joelr1> and what would it do within the context of ghc?
08:40:22 <langdon> ghc
08:40:33 <dcoutts_> joelr1, ghci currently uses bytecode
08:40:38 <langdon> bytecode
08:40:39 <joelr1> ah, ok
08:40:55 <jip> joelr1, musasabi: that kind of JITing is quite difficult
08:40:57 <dcoutts_> imagine a mod_ghc, the can compile your .hs server pages
08:41:00 <joelr1> whose bot is langdon 
08:42:39 <davidhouse> joelr1: i'm not convinced he is a bot. he said "why" earlier which no-one else seemed to have done.
08:43:13 <langdon> indeed
08:43:25 <sjanssen_> langdon: why ;)
08:43:35 <davidhouse> so, langdon, what's with the mindless repetition of words?
08:43:39 <langdon> because life is short
08:44:27 <Saulzar> Therefore, waste it? :)
08:44:32 <sjanssen_> does langdon need to take the Turing test?
08:44:42 <norpan> i took that test, but i flunked it
08:45:00 <langdon> whats a turing test?
08:45:18 <norpan> if you know what it is then you don't need to take it
08:45:29 <sjanssen_> @google turing test
08:45:31 <lambdabot> http://cogsci.ucsd.edu/~asaygin/tt/ttest.html
08:45:42 <norpan> @google big boobs
08:45:44 <lambdabot> http://www.lanasbigboobs.com/main.php
08:48:43 <langdon> thats nice
08:55:04 <jethr0> @google 3 miles in meters
08:55:05 <lambdabot> 3 miles = 4,828.032 meters
08:55:34 <psi> oh, nice
08:55:39 <langdon> why
08:56:49 <neologism> @google the best programming language
08:56:51 <lambdabot> http://www.ruby-lang.org/
08:56:56 <neologism> hehe
08:56:58 * Igloo is a great fan of
08:56:59 <Igloo> cubic acre in square gallons
08:57:01 <Igloo> Ooops
08:57:05 <Igloo> @google cubic acre in square gallons
08:57:06 <lambdabot> 1 cubic acre = 4.62516389 x 10^15 square US gallons
08:57:07 <langdon> SKIMO
08:57:11 <psi> @google least broken programming language
08:57:13 <lambdabot> http://www106.pair.com/rhp/books.html
08:57:33 <LordBrain> @google worst programming language
08:57:34 <lambdabot> http://www.pbm.com/~lindahl/real.programmers.html
08:57:38 <langdon> why
08:57:46 <joelr1> @google slowest programming language
08:57:47 <lambdabot> http://www.softwarereality.com/programming/language_lifecycles.jsp
08:57:53 <langdon> why
08:58:10 <LordBrain> @google why
08:58:12 <lambdabot> http://whyfiles.org/
08:58:52 <neologism> @google haskell is
08:58:53 <lambdabot> http://www.haskell.org/haskellwiki/Haskell
08:59:07 <lesshaste> hi.. what would "Ix is the class of indices" mean? I know this is a dumb question but any tips appreciated
08:59:15 <lesshaste> if is in the context of graph algorithms in haskell
08:59:15 <vincenz> re
08:59:50 <langdon> why
08:59:57 <norpan> anything that is an instance of class Ix can be used as index in an array
09:00:20 <langdon> why
09:00:37 <norpan> why not
09:00:43 <lesshaste> norpan, how is that different from "Num is the class of numbers"?
09:00:44 <ValarQ> that language_lifecycles link was quite interesting
09:00:48 <langdon> why
09:00:56 <lesshaste> ah.. non-numbers can index arrays?
09:00:59 <norpan> lesshaste: because you don't have to be a number to be an index in an array
09:01:07 <langdon> why
09:01:15 <sjanssen_> langdon: you gotta stop that
09:01:18 <ValarQ> the author seem to think that C++ killed C and Java replaced C++
09:01:22 <Igloo> langdon: Yes, please stop it
09:01:24 <lesshaste> norpan, thanks very much
09:01:31 * lesshaste loves the replies you get at #haskell :)
09:01:38 <langdon> okay
09:02:29 <sjanssen_> @google speed of light in cubits per fortnight
09:02:30 <lambdabot> the speed of light = 7.931517 x 10^14 cubits per fortnight
09:02:33 <ValarQ> "it is the application market that drives language evolution. This is because the application market is where the profitable adoption is most significant."
09:02:36 <sjanssen_> Igloo: that's my favorite
09:02:44 <vincenz> sjanssen_: what's a cubit?
09:02:46 <langdon> because
09:02:59 <davidhouse> @google the answer to life, the universe and everything
09:03:01 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
09:03:02 <sjanssen_> @google 1 cubit in centimeters
09:03:03 <lambdabot> 1 cubit = 45.72 centimeters
09:03:03 <Igloo> sjanssen_: Not even per microfortnight?
09:03:06 <davidhouse> aww.
09:03:08 <langdon> aww
09:03:12 <notanotheridiot> @google define cubit
09:03:13 <lambdabot> http://www.answers.com/topic/cubit
09:03:14 <davidhouse> that used to work.
09:03:26 <langdon> work
09:03:32 --- mode: ChanServ set +o Igloo
09:03:43 <vincenz> davidhouse: I refactored your stuff a bit
09:03:45 * dcoutts_ sees Igloo glow
09:03:48 <langdon> why?
09:03:55 <davidhouse> heh. it does. :) http://www.google.co.uk/search?q=the%20answer%20to%20life%2C%20the%20universe%20and%20everything
09:03:59 <davidhouse> vincenz: so i see
09:04:03 <langdon> why does it?
09:04:09 <dcoutts_> langdon, because he's about to kick you
09:04:10 <davidhouse> vincenz: i'm making good progress HTMLing the rest of it
09:04:12 <Igloo> langdon: Please stop it.
09:04:27 <vincenz> davidhouse: cool, yeah I saw some strings in TestDriver that will need to be factored out to the outputter
09:04:28 <psi> it's a bot
09:04:34 <langdon> for those about to rock
09:04:39 <davidhouse> psi, it's not.
09:04:45 <joelr1> it's a bot with human input
09:04:49 <davidhouse> psi, it's just a bored spammer.
09:04:58 <joelr1> i'm in the process of making one :-)
09:05:10 <joelr1> you let it answer what it can and help out when it cannot
09:05:11 <joelr1> hhe
09:05:22 <langdon> joelrl
09:05:29 <dcoutts_> hah
09:05:36 <langdon> funny
09:05:40 --- mode: Igloo set +b *!*@84-73-113-239.dclient.hispeed.ch
09:05:43 --- kick: langdon was kicked by Igloo (Igloo)
09:05:50 <davidhouse> merci.
09:05:51 <jip> we have MArray that is a general interface to IOArray and STArray, how come there is no general interface for IORef and STRef?
09:07:55 <joelr1> hmm
09:08:03 <joelr1> i just realized that Data.Map is not mutable
09:08:15 <joelr1> is there a map-like datastructure that's mutable in-place?
09:09:00 <psi> hm, the hashtable?
09:09:01 <Saulzar> There is an IO Hashtable
09:09:13 <joelr1> looking
09:10:09 <joelr1> hmm, can't find it. looking further
09:10:19 <sjanssen_> word on the street is that Data.HashTable is slow
09:11:29 <jip> joelr1: http://hackage.haskell.org/trac/summer-of-code/ticket/61
09:11:33 <joelr1> well, i don't want to create bindings, etc. and it's gonna be a set of huge tables
09:12:25 <vincenz> joelr1: you had a paste you wanted me to look at?
09:12:43 <joelr1> i sent it to haskell-cafe but it's probably still at the top of the paste
09:13:17 <Saulzar> "However, these data structures have to be reconstructed almost from scratch for each insertion/deletions, resulting in low performance."
09:13:35 <vincenz> Saulzar: lol
09:13:40 <jip> Saulzar: hello!
09:13:47 <Saulzar> Hmm, that's not quite true. It only updates the parts which change.
09:13:49 <sjanssen_> that statement is incorrect
09:13:56 <norpan> why do you want a mutable data structure
09:13:58 <Saulzar> jip, Hi :)
09:14:04 <sjanssen_> it only updates a small fraction of the cells
09:14:27 <Saulzar> jip, How goes the GB?
09:15:13 <vincenz> joelr1: messy :/
09:15:17 <vincenz> joelr1: I'll try to clean it up later
09:15:21 * vincenz has had a hectic day
09:15:28 <jip> Saulzar: i only just now have some time to work on it a bit
09:15:50 <joelr1> norpan: because i want to... mutate it? :-)
09:16:08 <norpan> that's evil
09:16:18 <norpan> only evil people do stuff like that
09:16:45 <joelr1> norpan: imagine i'm counting how many times players shared a table. i analyze things game by game. i also need to assign a score to each game, a fraud score. lets say it's the # of standard deviations that your counter is away 
09:16:46 <norpan> perl6 in haskell *shrugs*
09:17:43 <joelr1> so after every game i need to update the # of times every player in this game shared the table with every other player, recalculate the stddev (i can do this incrementally), etc. this requires mutable data structures i think
09:17:49 <norpan> but you don't really _need_ a mutable data structure, you only think you need one due to efficiency
09:18:01 * dcoutts_ agrees with norpan 
09:18:14 <joelr1> norpan: that's true. my events file is 4Gb big, though, and has 60mm events
09:18:21 <joelr1> and i have around 1mm games
09:18:31 <norpan> what is a mm?
09:18:40 <sjanssen_> joelr1: is this realtime, or batch processing?
09:18:43 <joelr1> i hate to think of all the trashing that's gonna go on as i'm recreating the data structures
09:18:45 <dcoutts_> > let mm = 10^6 in mm
09:18:46 <lambdabot> 1000000
09:18:47 <joelr1> batch processing
09:19:07 <norpan> never heard the abbrev. mm before, to me it means millimeter
09:19:16 <joelr1> plus, the only point of doing this all in memory as opposed to oracle is speed
09:19:17 <dcoutts_> me too
09:19:24 <jip> Saulzar: i'm converting everything to use IORefs and IOUArrays now to see how the performance is. i'm just hacking it together real messy. if it works fast then i'll later convert to using a general interface to IORef/STRef that should make it possible to either do the emulation purely via ST or optionally within the IO monad for increased performance
09:19:33 <joelr1> m = thousand, mm = million, financial-speak i think
09:19:42 <norpan> i've seen mn
09:19:49 <norpan> and bn
09:19:54 <dcoutts_> joelr1, rebuilding an in-memory tree is going to be much wuicker than an Oracle on-disk tree.
09:19:59 <jip> Saulzar: i am also thinking about another idea of using customized monads
09:20:04 <joelr1> so anyway, oracle starts at, say, 100 games per second and drops to one game per 5-6 seconds 
09:20:11 <jip> Saulzar: and i'm also reading a bit about template haskell, maybe it can be useful
09:20:16 <jip> Saulzar: anyway i'll bbl i gotta eat!
09:20:16 <dcoutts_> so you've not deponstrated that you need to go even lower level
09:20:20 <Saulzar> jip, Hmm, I think ST should be roughly the same as IO - maybe slightly faster. 
09:20:28 <Saulzar> jip, Unless you need to do IO of course :)
09:20:29 <joelr1> it's chugging along right now and will finish in a few weeks
09:20:45 <norpan> premature optimization is the root of all evil
09:20:55 <joelr1> the client won't accept the project (and pay me) until i process the million games, though, and i don't have a few weeks to wait
09:20:59 <sjanssen_> jip: IO is ST
09:21:41 <joelr1> i would like to keep all the counters in memory and have a go at it on this 16gb 2-CPU 64-bit AMD box 
09:22:12 <dcoutts_> joelr1, but each game is not independent right?
09:22:16 <joelr1> but i think copying the huge data structures is gonna be slow
09:22:25 <norpan> but you don't know, do you
09:22:31 <joelr1> dcoutts_: no, since stats for game 2 depend on stats for game 1 they are dependent
09:22:34 <lesshaste>  I am now trying to work how what the listings package in latex things a comment in haskell is by default. Any ideas?
09:23:02 <Saulzar> joelr1, When updating a tree structure the whole thing is not copied - only some paths from root -> the item are ever touched
09:23:08 <joelr1> dcoutts_: i mean, i can calculate the million games at once, i.e. figure out the deltas but i would still need to bump counters and score one game at a time
09:23:27 <joelr1> Saulzar: are you serious?
09:23:30 <Saulzar> Yeah
09:23:32 <norpan> one million copies are not that much
09:23:41 <dcoutts_> joelr1, remember that with a tree you're only changing log n nodes. so that's about 13 or 14 nodes.
09:23:43 <joelr1> i'm trying to imagine how this will work in practice
09:23:58 <dcoutts_> joelr1, and adding up the counters is not associative?
09:24:02 <joelr1> i should probably look at the implementation
09:24:05 <joelr1> of Data.Map
09:24:09 <joelr1> dcoutts_: what do you mean?
09:24:17 <sjanssen_> joelr1: size balanced tree
09:24:29 <norpan> in my experience: measure before optimizing
09:24:31 <dcoutts_> joelr1, no, don't look at the implemenation, benchmark it with a million entries
09:24:43 <joelr1> dcoutts_: i.e. just do it?
09:24:46 <dcoutts_> joelr1, and if your idexes are Int, then use Data.IntMap
09:24:50 <vincenz> 1mm != 10^ 6
09:25:04 <dcoutts_> joelr1, what do you expect to learn from reading the implementation?
09:25:19 <dcoutts_> just find out if it's fast enough
09:25:32 <dcoutts_> for your actual problem using a real size data-set
09:25:33 <joelr1> dcoutts_: i want to know how the tree is copied. i naively imagined that a new tree is created and the old nodes are added to it
09:25:59 <sjanssen_> > Data.Set.size $ Data.Set.fromList [1..1000000]
09:26:00 <lambdabot>  Not in scope: `Data.Set.fromList'
09:26:04 <sjanssen_> bah
09:26:05 <norpan> that's not how it works, precisely because the data structure is unmutable
09:26:13 <dcoutts_> joelr1, suppose I have a tree with 10^6 elements in it. I add a new element. That involves creating 13 new nodes. That's all.
09:26:20 <norpan> that means that the new tree can use existing subtrees from the old tree
09:26:28 <dcoutts_> > log (10**6)
09:26:29 <lambdabot> 13.815510557964274
09:26:35 <dcoutts_> ok 14 nodes
09:26:48 <joelr1> fair enough, this should be a great blog post in favor of haskell :D
09:26:49 <Cale> > S.size $ S.fromList [1..1000000]
09:26:50 <joelr1> i hope
09:26:53 <lambdabot> Terminated
09:27:04 <vincenz> Cale: ouchy
09:27:06 <Cale> (only get 3 seconds :)
09:27:18 <vincenz> > S.size $ S.fromList [1..100000]
09:27:20 <lambdabot> 100000
09:27:26 <vincenz> hmm
09:27:38 <sjanssen_> takes 5 seconds on my machine, without -O
09:27:39 <vincenz> > S.size . S.fromList . enumFromTo 1     == id
09:27:40 <lambdabot>  add an instance declaration for (Eq (Int -> Int))
09:27:40 <lambdabot>   In the definition of `avg':
09:27:40 <lambdabot>    avg = (Data.Set.size . (Data.Set.fromList . (enumFromTo 1))) == id
09:28:08 <araujo> Hello!
09:28:10 * araujo back
09:30:45 <davidhouse> @hoogle TestOk
09:30:45 <lambdabot> Test.QuickCheck.Batch.TestOk :: String -> Int -> [[String]] -> TestResult
09:31:29 <vincenz> hmm
09:31:33 <joelr1> i gotta say this, there's a huge difference between the ambience on #lisp and #haskell. i wonder why that is
09:31:34 <vincenz> why isn't oasisbot responding
09:32:07 <dcoutts_> joelr1, on my old 500MHz sparc I can insert 100,000 new elements into a set that's already 100,000 big in 1.25 seconds.
09:32:13 <joelr1> on #lisp people get pissed pretty quickly (say you mention you are not an sbcl fan or are using a commercial lisp) whereas on #haskell people go out of the way to help you
09:32:24 <dcoutts_> joelr1, is that quick enough?
09:32:31 <joelr1> dcoutts_: cool, any suggestions on how i can make use of the 2 processors?
09:32:32 <davidhouse> @type concatMap concat
09:32:33 <lambdabot> forall a. [[[a]]] -> [a]
09:32:39 <davidhouse> crazy.
09:32:40 <joelr1> dcoutts_:  i think that's quick 
09:32:47 <sjanssen_> joelr1: all those parentheses make them grumpy ;)
09:33:06 <palomer> @type concatMap concatMap
09:33:07 <lambdabot>   Couldn't match `[b]' against `t -> t1'
09:33:07 <lambdabot>   Expected type: [b]
09:33:08 <joelr1> i figured i would rather read events from a file than from oracle since i can then test on my powerbook
09:33:22 <palomer> @type concatMap $ concatMap concat
09:33:24 <lambdabot> forall a. [[[[a]]]] -> [a]
09:33:33 <davidhouse> heh
09:33:40 <dcoutts_> joelr1, how much work is there per game/event? how can you split the problem
09:33:42 <joelr1> the full event file is over 4gb, though. i'm using byte strings so i'm hoping reading is gonna be fast enough. 
09:33:57 <joelr1> i'm using the code that i posted to haskell-cafe, asking how i can make it lazier
09:34:17 <dcoutts_> joelr1, eg if there's quite a bit of work per game then have two threads and process in both an lock the tree for updates
09:34:23 <joelr1> well, i need to run the event through a set of rules
09:34:45 <dcoutts_> joelr1, how much is reads from the map and how much is writes?
09:34:45 <joelr1> hypothetically, i could just fire a thread for each event 
09:34:51 <joelr1> and read from the file as quickly as i can
09:35:15 <dcoutts_> why do you want lots of threads?
09:35:21 <dcoutts_> this is a batch job right?
09:35:23 <joelr1> dcoutts_: probably even. i won't read from the map unless i want to update it
09:35:26 <joelr1> batch job, yes
09:35:32 <joelr1> i.e. i got a player joined event
09:35:43 <joelr1> i need to look up the game that it belongs to
09:35:59 <joelr1> that was created when i got a game started event and will go away upon "game ended"
09:36:03 <dcoutts_> joelr1, sure, but would you read say 100 times from the tree for each write? or is it more like one lookup and one change?
09:36:13 <joelr1> so i'll look up the game and add the player to it
09:36:14 <davidhouse> @hoogle run
09:36:15 <lambdabot> Test.QuickCheck.Batch.run :: Testable a => a -> TestOptions -> IO TestResult
09:36:15 <lambdabot> Data.Graph.Inductive.NodeMap.run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
09:36:15 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
09:36:33 <joelr1> and bump the hand shared counter for every player already at the table 
09:36:49 <joelr1> dcoutts_: the latter
09:37:06 <Cale> joelr1: does your fixLines work on an infinite string?
09:37:11 <dcoutts_> joelr1, it's not clear how your problem parallelises
09:37:25 <joelr1> Cale: beats me, i wanted to find out
09:37:32 <joelr1> i was hoping that ++ is lazy
09:37:32 <dcoutts_> joelr1, if there's potential dependency between each event
09:37:38 <Cale> okay, I'll try it
09:37:41 <Cale> yes, it is
09:37:46 <dcoutts_> joelr1, ++ is lazy
09:38:02 <joelr1> Cale: but there was a discussion about whether you needed to be properly tail-recursive while being lazy
09:38:20 <joelr1> so i was wondering if my code is as lazy as it can be given that (i think) it's tail-recursive
09:38:31 <joelr1> dcoutts_: the dependency is at scoring time
09:38:40 <Cale> hmm, tail recursion is usually bad for laziness
09:38:45 <dcoutts_> joelr1, perhaps STM might help because if there typiclaly is low contention then it should parallelise and it'll only rollback if there was contention.
09:38:47 <joelr1> dcoutts_: well, no, you are right, they are dependent 
09:38:57 <joelr1> dcoutts_: that's what i wanted to do
09:39:04 <Cale> oh, these are Char8's
09:39:12 <joelr1> dcoutts_: but then people popoed the idea :-)
09:39:13 <dcoutts_> joelr1, but that's no good if you will get high contention
09:39:44 <joelr1> dcoutts_: i'll probably end up trying it several ways. basically, not all events trigger updates to all data structures
09:39:53 <joelr1> Cale: does that make a difference?
09:40:09 <sjanssen_> joelr1: you can't build an infinite ByteString
09:40:22 <dcoutts_> joelr1, one possability is instead of having a TVar with the map in it, instead to have a map containing TVars
09:40:37 <dcoutts_> since there's probably lower contention on idividual counters
09:40:54 <dcoutts_> so long as you're processing mostly independent games in different threads
09:41:15 <Cale> joelr1: well, possibly a bit
09:41:17 <dcoutts_> joelr1, do you know when reading an event just which counters you will need?
09:42:01 <joelr1> dcoutts_: well, sure, i will run it through a set of rules and the rules determine the counters. if the rule is triggered then the counters need to be updated
09:42:29 <joelr1> someone suggested yesterday (was that you duncan?) that i can generate a stream of updates from the games and have another thread process that stream and update the counters
09:42:50 <dcoutts_> joelr1, it wasn't my idea but it seems reasonable
09:42:59 <dcoutts_> that gives you 2 threads
09:43:04 <Cale> you seem to be doing a lot of ++'s where the right hand list is small, which is inefficient
09:43:22 <joelr1> could  the disk-reading and event-firing thread could fire a bunch of threads then to run the rules i wonder?
09:43:28 <dcoutts_> joelr1, but it's not a symetric solution.
09:43:33 <joelr1> and calculate an update
09:43:57 <dcoutts_> joelr1, actually calculating the updates does parallelise nicely
09:44:01 <joelr1> Cale: my first idea was pushing to the front and reversing but that's not lazy i think
09:44:05 <dcoutts_> joelr1, it's the updating which is basically serial
09:44:25 <joelr1> dcoutts_: yes, fire a thread per event, have the threads queue up the update, have another thread run a loop pulling from the queue
09:44:26 <Cale> joelr1: I think it should be possible to do this without any accumulation at all
09:44:29 <joelr1> dcoutts_: like that?
09:44:52 <joelr1> Cale: the complication is joining the lines but if you can suggest a different approach it would be great
09:44:53 <dcoutts_> joelr1, no, no need to fire a thread per event. Just use 2 or 3 threads processing event queues.
09:45:11 <joelr1> Cale: the file is huge, though, over 4Gb so i don't want to load it all into memory, thus /i think i need/ the laziness
09:45:17 <dcoutts_> joelr1, otherwise you'll get the same swamping effect you got last time
09:45:28 <dcoutts_> you'll have too many producers and not enough consumers
09:45:47 <dcoutts_> so you'll end up with a huge queue of unprocessed updates
09:45:52 <vincenz> @hoogle mapMaybeMap
09:45:52 <sjanssen_> joelr1: if you're using Data.ByteString, the entire file *must* be loaded into memory
09:45:52 <lambdabot> No matches found
09:46:02 <davidhouse> if you had to choose one function to be Preluded (that currently isn't), what would it be?
09:46:05 <joelr1> dcoutts_: are you sure? because the producing thread would be disk-bound
09:46:08 <davidhouse> i think i'd go with liftM.
09:46:09 <vincenz> davidhouse: removeAt
09:46:17 <vincenz> err
09:46:19 <vincenz> replaceAt
09:46:25 <vincenz> for []
09:46:30 <joelr1> sjanssen_: is that right?
09:46:38 <joelr1> ByteString is not lazy?!
09:46:48 <sjanssen_> joelr1: no, it's just an array of bytes
09:46:49 <joelr1> err, ByteString.getContents is not lazy?
09:46:52 <dcoutts_> joelr1, hmm, maybe. Anyway, the point is that there is nothing to be gained from useing 1000 event processing threads rather than 2 or 3.
09:46:58 <sjanssen_> joelr1: that's the entire point
09:47:02 <dcoutts_> except for more overhead
09:47:16 <joelr1> sjanssen_: so much for my good intentions
09:47:40 <vincenz> http://oasis.yi.org:8080/repos/haskell/RandomPerm.hs
09:48:06 <joelr1> dcoutts_: so 2 threads then, one reading the file and evaluating rules and posting updates and another thread actually making updates themselves
09:48:08 <dcoutts_> joelr1, so how about 1 event reader, 2 event processors, 1 update processor.
09:48:08 <sjanssen_> joelr1: try getting an old copy with mmap support, then you can do mmapFile which uses OS support for laziness
09:48:33 <joelr1> sjanssen_: i think i'll just go with regular haskell IO then
09:48:48 <joelr1> sjanssen_: although this copy has mmap support too /0.6/
09:48:49 <sjanssen_> 4 gigabytes sounds like a no go for [Char]
09:48:50 <joelr1> no?
09:48:59 <joelr1> sjanssen_: but it would be read lazily
09:49:09 <joelr1> and the strings are discarded after each read
09:49:13 <sjanssen_> ah, true
09:49:21 <sjanssen_> it's hard to say then
09:49:44 <dcoutts_> joelr1, or just 2 threads, but there may be a big imbalance in the workload generated by just 2 threads.
09:50:07 <dcoutts_> joelr1, so I'd worry that you might end up with 100% load on one cpu and like 20% on the other.
09:50:08 <Cale> joelr1: yeah, testing it, fixLines is completely strict
09:50:10 <joelr1> dcoutts_: well, i think the producer is gonna be way slower than the consumer
09:50:16 <dcoutts_> joelr1, exactly.
09:50:52 <joelr1> dcoutts_: hmm... maybe it's worth pulling from oracle directly because i can then split the game list into several chunks
09:51:02 <joelr1> Cale: ouch! 
09:51:13 <dcoutts_> joelr1, can you? I thought you said they were interdependent.
09:51:18 <joelr1> Cale: so i need to go back to IO.getContents
09:51:36 <joelr1> dcoutts_: well, i don't care about the order in which they are processed
09:51:47 <joelr1> dcoutts_: but statistics need to be updated after every game
09:52:05 <Cale> joelr1: no, it's that pure function which is strict
09:52:06 <joelr1> dcoutts_: and the score of every game depends on the stats of games before it
09:52:27 <joelr1> Cale: what does that mean? good/bad?
09:52:28 <dcoutts_> joelr1, right, so the order does matter
09:52:34 <joelr1> Cale: what does that imply rather
09:52:41 <Cale> joelr1: We need to write it so as to be generative -- it has to know the start of its output before reading all of its input.
09:52:57 <joelr1> dcoutts_: no, the order does not matter. i can score game 1 and then game 2 or i can score 2 and then 1
09:52:58 <dcoutts_> I can't square your two statements "i don't care about the order in which they are processed" & "the score of every game depends on the stats of games before it"
09:53:13 <Cale> currently, it processes the entire input list before returning any actual datastructures
09:53:17 <joelr1> dcoutts_: let me explain
09:53:24 <Cale> (on all other cases, it's calling itself)
09:53:32 <joelr1> say my only fraud rule was how many times people play together
09:54:25 <joelr1> i want to know how many times everyone played with everyone else and i want to update that counter after every game. i would be keeping a running standard deviation so the fraud score would be the number of times you played with someone else divided by the stddev
09:54:32 <joelr1> i.e. how much of an outlier you are
09:54:56 <joelr1> if you are 2 or 3 devs away from the mean than you are suspect
09:55:25 <joelr1> Cale: but i would need it to be lazy to process 4gb without loading everything into memory, right?
09:55:30 <Cale> yes
09:55:54 <Cale> suppose that the input is infinite
09:55:57 <joelr1> dcoutts_: so basically, i don't care if i score game 1 and then game 2, what i care is updating the standard deviation and mean after every game and use the new numbers when scoring another game
09:56:12 <Cale> it still seems quite possible to know what the first element of the output is without reading it all :)
09:56:17 <joelr1> i can go 1, 2, 3, 4, 5 or 3, 4, 5, 2, 1, etc
09:56:49 <joelr1> Cale: yes, of course. i just need to see if i want to join a couple of lines, if i have enough commas
09:57:00 <joelr1> if i do then that's the first element of the output
09:57:05 <joelr1> and so on
09:57:08 <dcoutts_> joelr1, what does "use the new numbers when scoring another game" mean? I thought you were just counting things?
09:57:35 <joelr1> dcoutts_: what that means is that i updated the mean and deviation after game 2 
09:57:50 <Cale> joelr1: right, that's the correct way to design it
09:58:05 <joelr1> then i need to divide the # of times people shared the table in game 1 by the numbers calculated in game 2
09:58:17 <joelr1> f i was processing game 2 and then 1
09:58:19 <dcoutts_> joelr1, so you don't need to know the updated scores, you just need to add them up at the end. no?
09:58:32 <joelr1> no
09:58:55 <dcoutts_> suppose you process two games
09:59:10 <dcoutts_> you don't need to know the counts for either when processing the other one
09:59:21 <dcoutts_> we can just add the counts up after processing both
09:59:24 <dcoutts_> am I wrong?
09:59:28 <joelr1> dcoutts_: suppose it's game 1, you and i shared the table 10 times. i assign the fraud score depending on where that number is compared to the standard deviation. then i recalculate the stddev and mean 
09:59:47 <joelr1> dcoutts_: so the next game will have a different mean and stddev to work with
09:59:53 <dcoutts_> joelr1, but that *does* depend on the order
10:00:00 <dcoutts_> because the order affects the stddev and mean
10:00:05 <joelr1> dcoutts_: no
10:00:22 <joelr1> dcoutts_: if i go 2 and then 1 or go 1 and then 2 the stats will still be bumped by 1
10:00:30 <joelr1> we would still have shared the table just 1 more time
10:00:43 <davidhouse> @hoogle Property
10:00:43 <lambdabot> Test.QuickCheck.Property :: data Property
10:00:43 <lambdabot> Test.QuickCheck.property :: Testable a => a -> Property
10:01:19 <joelr1> Cale: so how do i change the code to make it lazy? not use ByteStrings, i understood that. use getContents which is lazy (not the ByteString one), right?
10:01:21 <palomer> skinnermarink a dink a dink, skinnermarink a do
10:02:19 <Cale> joelr1: actually, this way of using bytestrings is fine
10:02:30 <joelr1> dcoutts_: order does not matter. what matters is updating the stats after every game. because i could run 1 million games at once, for example, but if all counters were 0 then the scores are gonna be all 0
10:02:50 <Cale> joelr1: if you had your whole file as a bytestring and you were trying to manipulate that, then it would likely be completely strict
10:02:52 <joelr1> Cale: but you said it's strict and thus /i think/ it will load 4Gb into memory
10:02:57 <Cale> yeah
10:03:00 <Cale> it will
10:03:11 <joelr1> Cale: and that's completely uncesessary
10:03:30 <joelr1> Cale: because all that data is gonna be thrown away very quickly
10:03:41 <joelr1> and i really need it just one-two lines at a time
10:04:22 <dcoutts_> joelr1, I dont see that. If you process one game and it affects the mean/stddev and that is used in processing the next game, then the order of processing can affect the results.
10:04:38 <dcoutts_> because you might do high ones first and then low ones later
10:04:44 <joelr1> dcoutts_: no, say it's game 1 and we played just one time
10:04:48 <dcoutts_> and doing that the other way around will be different
10:04:55 <joelr1> dcoutts_: if it's game 2 we would still have played just 1 time
10:05:20 <xerox> dcoutts_: ah, what about the GStreamer guy?
10:05:34 <dcoutts_> xerox, two people are interested!
10:05:45 <joelr1> dcoutts_: the counters are incremented per game, see, they always increment by 1 for sharing a table because you can only share the table once per game
10:06:48 <RyanT5000> mahogny, you there?
10:06:53 <dcoutts_> so if you need the results of previous games when processing the rules then you've got a mostly single threaded problem.
10:06:54 <joelr1> dcoutts_: there's no order to the games, period. it's just a stream of game events or a stream of games if you will. the stream can be shuffled 
10:07:05 <RyanT5000> i just posted my SoC ticket
10:07:12 <xerox> dcoutts_: how would it work? Python->c->Haskell?
10:07:30 <dcoutts_> xerox, what's python got to do with it?
10:07:49 <xerox> Ah-uhm, I thought....
10:08:11 <RyanT5000> http://hackage.haskell.org/trac/summer-of-code/ticket/77
10:08:12 <joelr1> dcoutts_: right. so what if i were to run "map" on that stream of game events and produce a stream of game updates i could have one thread produce and one thread consume, right?
10:08:27 <RyanT5000> anyone interested in mentoring my 3D GUI framework?
10:08:37 <joelr1> one thread to read the file and produce game events, another thread to run the rules and update scores
10:08:38 <dcoutts_> joelr1, only if your decisions are independent of the current values of counters / stats
10:08:39 * RyanT5000 stares at mahogny
10:08:55 <dcoutts_> joelr1, because you don't know the current stats until previous updates have been processed.
10:08:58 <joelr1> that's two threads, one produce, one consumer. and 2 processors
10:09:28 <dcoutts_> joelr1, but it sounds like you need to know the current stats when updating counters
10:09:39 <joelr1> dcoutts_: right. but reading from disk is slow, right? so i could read an event, hand it off to another thread on a different processor, go back to reading another event
10:09:40 <RyanT5000> joelr1: isn't that inefficient if the items being produced are small?
10:09:53 <Cale> fixLines' n xs = B.concat first : fixLines' n rest
10:09:54 <Cale>     where (first, rest) = splitAt (k-1) xs
10:09:54 <Cale>           k = length . takeWhile (<= n) . scanl (+) 0 . map (B.count ',') $ xs
10:10:00 <RyanT5000> i think a single cpu can outperform 2 if the caching works out in its favor
10:10:16 <dcoutts_> joelr1, yeah, perhaps. So you could have 2 reader threads and one processor thread.
10:10:34 <joelr1> dcoutts_: how can i have two reader threads with a single file?
10:10:35 <dcoutts_> joelr1, so use 2 cpus for IO reading events and a single processing thread
10:10:43 <Cale> joelr1: there's a nice lazy version
10:10:44 <dcoutts_> joelr1, the DB would make that easier
10:10:46 <psi> xerox: did you see my question?
10:10:55 <joelr1> Cale: reading
10:10:58 <xerox> psi: nope, sorry, may you repeat it?
10:11:06 <psi> xerox__: last year, were you very familiar with cairo and the process of creating bindings when you started your project? or did you have time to include research?
10:11:07 <vincenz> xerox: no he may not
10:11:07 <dcoutts_> joelr1, or split your events into 2
10:11:36 <joelr1> dcoutts_: right
10:11:47 <Cale> strings = repeat (B.pack "a,a,a,a,a,")
10:11:48 <vincenz> @type concatMap $ concatMap concat
10:11:49 <lambdabot> forall a. [[[[a]]]] -> [a]
10:11:49 <xerox> psi: I wasn't familiar with anything else than coding in Haskell.  I spent the first of the two months reading papers and documentation.
10:11:53 <dcoutts_> joelr1, to be honnest, I'd start with a single threaded version
10:11:56 <joelr1> Cale: it's still using byte strings, no?
10:11:57 <vincenz> Cale: what's B
10:12:06 <Cale> joelr1: try it with that as a test, and compare the result with your old version
10:12:10 <vincenz> @type concatMap $ concatMap $ concatMap concat
10:12:11 <lambdabot> forall a.
10:12:11 <lambdabot>                [[[[[a]]]]] -> [a]
10:12:14 <palomer> vincenz: stop stealin' my combinators, brotha
10:12:14 <Cale> vincenz: Data.ByteString.Char8
10:12:17 <xerox> vincenz: I have got a deep'join :: m (m (m ... a ...)) -> m a !
10:12:27 <vincenz> xerox: how deep?
10:12:31 <psi> xerox: cool, makes me more confident
10:12:31 <xerox> Infinitely.
10:12:33 <mahogny> RyanT5000, here
10:12:33 <dcoutts_> joelr1, if you find you are within a factor of 2 of the desired performance or are IO bound then look at parallelising
10:12:38 <vincenz> xerox: how is that typeable!!!!
10:12:41 <RyanT5000> mahogny: http://hackage.haskell.org/trac/summer-of-code/ticket/77
10:12:52 <xerox> psi: yeah, go for what you like best (-:
10:12:56 <joelr1> dcoutts_: right. but i would not be using that second processor :D
10:12:57 <dcoutts_> joelr1, but you might find you're quick enough with one thread or you might find you're too slow by 10x
10:13:01 <xerox> vincenz: one word - Oleg.
10:13:02 <RyanT5000> please add your name, right there at the bottom ;)
10:13:12 <dcoutts_> joelr1, there's a lot of extra effort to use the other cpu
10:13:15 <RyanT5000> or tell me what  i need to do to make that happen
10:13:17 <vincenz> xerox: hehehe
10:13:18 <joelr1> dcoutts_: true
10:13:22 <Cale> xerox: how many experimental features in GHC does it require you to turn on?
10:13:24 <vincenz> xerox: link?
10:13:25 <dcoutts_> joelr1, consider it as a late-stage optimisation
10:13:38 <vincenz> Cale: pugs :)
10:13:39 <xerox> 3D GUI System and widget library?!  Crazy!
10:13:48 <mahogny> RyanT5000, right
10:13:50 <dcoutts_> joelr1, if you find you're 10x too slow then the parallelisation would be a waste anyway right?
10:13:51 <palomer> @type join . join . join
10:13:51 <vincenz> xerox: oh yeah I read about that
10:13:52 <lambdabot> forall a (m :: * -> *).
10:13:52 <lambdabot>         (Monad m) =>
10:13:52 <lambdabot>         m (m (m (m a))) -> m a
10:14:01 <mahogny> xerox, three months. gotta use them all? ;)
10:14:02 <joelr1> dcoutts_: true
10:14:03 <vincenz> @type let x = join . x
10:14:04 <lambdabot> not an expression: `let x = join . x'
10:14:07 <vincenz> @type let x = join . x in x
10:14:08 <xerox> mahogny: indeed (-:
10:14:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
10:14:09 <lambdabot>   Expected type: a1 -> m (m a)
10:14:14 <vincenz> xerox: see
10:14:15 <RyanT5000> lol is the project too big?
10:14:15 <xerox> vincenz: you can't do it in lambdabot.
10:14:22 <vincenz> xerox: then it can't be done ;)
10:14:22 <RyanT5000> that's usually my problem
10:14:26 <xerox> RyanT5000: no, it's cool (-:
10:14:26 <dcoutts_> joelr1, do the development as fast as possible to see if you're near to the perofrmance bounds and then you'll know what level of optimisations to look for.
10:14:30 <RyanT5000> k :)
10:14:32 <mahogny> xerox, heck. one of my students has already started on their project, with some progress o_O
10:14:33 <Cale> vincenz: It's typeclass swindling
10:14:40 <vincenz> Cale: hmm
10:14:41 <xerox> mahogny: that's very good.
10:14:49 <vincenz> Cale: got a link?
10:15:03 <vincenz> and is it useful?
10:15:03 <Cale> vincenz: I was hoping xerox would
10:15:04 * palomer is still puzzled as to who's going to read tho proposal I sent through google to haskell.org
10:15:07 <vincenz> I mean nothing is infinitely m..
10:15:10 <palomer> s/tho/the
10:15:11 <xerox> @google Haskell build variadic function
10:15:13 <lambdabot> http://okmij.org/ftp/Haskell/vararg-fn.lhs
10:15:17 <xerox> There you go.
10:15:18 <joelr1> Cale: so this version is lazy but if i use B.getContents then it would still read the whole file into memory, no?
10:15:55 <RyanT5000> also, i wouldn't mind if there were more students working on this project either; i'm not going to be possessive or anything
10:16:01 <xerox> deep'join is left as an exercise to the reader.
10:16:04 <Cale> joelr1: have to ask dons about that one -- I suppose I could go download the fps source and have a look though
10:16:11 <palomer> RyanT5000: what's the project?
10:16:20 <mahogny> RyanT5000, there. added. if you want more people, then I leave it to you to find someone you'd like to work with :)
10:16:23 <RyanT5000> a 3D GUI framework
10:16:40 <vincenz> hmm
10:16:54 <mahogny> RyanT5000, considering what you have here is so similar to a normal gui, have you considered porting some already existing gui?
10:16:56 <vincenz> xerox, Cale: how is that typeable... I mean how can it know what type it is when you pass around a polyvariadic func
10:17:22 <joelr1> Cale: it's a big bummer :)
10:17:29 <xerox> vincenz: it exploits typeclasses and their functionalities to achieve a limited kind of class (in)equality.
10:17:32 <RyanT5000> mahogny: i plan to delve into other windowing systems' designs first thing
10:17:38 <RyanT5000> and figure out if any mesh with what i want to do
10:17:39 <joelr1> -- | Read an entire file directly into a 'ByteString'.  This is far more efficient than reading the characters into a 'String' and then using 'pack'.  It also may be more efficient than opening the file and reading it using hGet.
10:17:49 <mahogny> RyanT5000, did you see the urls with advice on writing the application?
10:18:00 <RyanT5000> no
10:18:07 <joelr1> but then i can use the regular hGetContents and get my laziness
10:18:15 <Cale> joelr1: yeah
10:18:24 <Cale> and build ByteStrings as you go
10:18:29 <vincenz> xerox: I figured that, but it's not hindleymilnerable
10:18:51 <palomer> when I add a project on the SoC page, there's a mentor box, do I put the mentor who I think most fit for this project?
10:19:03 <joelr1> Cale: i don't even need to build bytestrings i think. i convert things to numbers right away
10:19:19 <xerox> palomer: nope.  You talk with him, and he puts himself if he think he can.
10:20:12 <xerox> thinks, even.
10:22:12 <Cale> joelr1: that's quite possible
10:22:33 <mahogny> RyanT5000, but as I said before, I think you should consider flexibility in changing the graphics a high priority. that would make it useful for less complex menus as well (such as simple main menus and config)
10:22:39 <vincenz> xerox: freaky
10:24:22 <joelr1> is there a standard "count how many times this element appears in the list" function? or do you roll your own with filter/length or something like that?
10:24:55 <mahogny> the latter I'd say
10:25:00 <xerox> ByteString has count
10:25:18 <mahogny> aha. bytestring. n/m
10:25:24 <joelr1> no, not bytestring
10:25:26 <xerox> (length .) . filter . (==) -- would work too.
10:25:30 <joelr1> there
10:25:57 <davidhouse> xerox <3 sections of compositions
10:26:10 <xerox> Indeed (-;
10:26:19 <RyanT5000> mahogny: you're right
10:26:59 <RyanT5000> also, that's one of my primary design goals, but i didn't state it in the description as strongly as i should have
10:27:00 <LordBrain> hmmm theres a function which gives a list of indecies for the element
10:27:05 * xerox wants students for the HOC project (-:
10:27:05 <RyanT5000> the entire thing will be fully skinnable
10:27:15 <xerox> LordBrain: yup.  elemIndex IIRC.
10:27:22 <xerox> ?type elemIndex
10:27:24 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
10:27:31 <joelr1> xerox: what does that dot after length do?
10:27:32 <xerox> A *list*, oops.
10:27:42 <xerox> joelr1: it composes a binary function with a unary one.
10:28:29 <RyanT5000> and hopefully gracefully skinnable; the default skins will have all their models and textures in a directory, and you can just replace them, or you could go in and specialize the widgets themselves in code
10:28:39 <LordBrain> you were close xerox .. its elemIndices plural
10:28:40 <davidhouse> joelr1: it's a section of composition. if you know about sections and you know about composition, think about it for a while and it makes sense
10:28:49 <xerox> joelr1: (f .) . g = \x -> (f .) (g x) = \x -> f . (g x) = \x y -> f (g x y)
10:29:07 <joelr1> i guess i don't know about sections. i knew about composition
10:29:24 <joelr1> xerox: i'll save that 
10:29:30 <davidhouse> e.g. \x -> 4 + x = (4+). in the same way, \f -> x . f = (x .)
10:29:30 <xerox> (.) . (.) composes a binary function with a unary one.
10:29:41 <xerox> (.) . (.) . (.) composes a ternary function with a unary one.
10:29:46 <xerox> You see the pattern? (-:
10:29:53 <joelr1> yes
10:32:19 <xerox> davidhouse: nice way too look at it. \g -> f . g = (f .)
10:34:53 <LordBrain> hmmm... davidhouse's way of looking at it just followed from the rules on infix operators in haskell...  
10:36:05 <LordBrain> i dont yet grasp xerox's way, but it sounds like it might be helpful
10:36:11 <joelr1> haskell makes me feel stupid but it's not a bad feeling. it drives to learn more and makes me humble
10:37:29 <xerox> LordBrain: I just used the definition of (.), namely f . g = \x -> f (g x)
10:37:35 <LordBrain> ok its slowly forming in my head now
10:37:48 <xerox> Try it yourself.
10:40:51 <RyanT5000> what percent of projects got through the summer-of-code admissions process last year?
10:40:54 <RyanT5000> (for  haskell.org)
10:41:04 <RyanT5000> (that ended up with mentors, etc.)
10:41:05 <xerox> There was no Haskell.org mentoring organization!!!
10:41:08 <RyanT5000> oh
10:41:09 <RyanT5000> :(
10:41:12 <xerox> Did you see my mails?
10:41:28 <RyanT5000> no
10:41:33 <RyanT5000> do i need to sign up for a list?
10:41:46 <xerox> I did some evil crossposting (-;
10:41:49 <neologism> RyanT5000: I dont know about haskell but fbsd rated all the sumbission 1-5 and google accepted all the 4 and 5 rated
10:41:59 <RyanT5000> ah ok
10:42:19 <LordBrain> google uses haskell?
10:42:23 <xerox> RyanT5000: i.e. you can find them on haskell@ haskell-cafe@ and a bunch of others.
10:42:38 <xerox> LordBrain: Chris DiBona seem to like it at least (-;
10:43:00 <RyanT5000> is there a place on haskell.org i can put up my resume? like a personal page on the wiki or something?
10:43:50 <enotanothridiot> for soc, would it be a major problem that I have exams around the 20th june?
10:44:53 <xerox> enotanothridiot: for such amministrative questions you could try asking them via the support email, or on the #summer-discuss channel on SlashNET.
10:45:03 <dcoutts_> enotanothridiot, xerox was on holiday for a whole month last year!
10:45:17 <xerox> Ah, dang, I misread!
10:45:22 <xerox> Yeah (-:
10:45:35 <xerox> "would I be a Major .." silly me.
10:48:02 <enotanothridiot> thanks - makes me feel more confident, i'll go write simething up
10:48:21 <dcoutts_> great
10:49:54 <LordBrain> is there a way to use linebuffered io reading from a text file?
10:50:03 <LordBrain> with ghc
10:50:23 <LordBrain> i know this must be a really newbie type question...
10:50:27 <LordBrain> :D
10:50:40 <dcoutts_> @type getLine
10:50:41 <lambdabot> IO String
10:50:53 <dcoutts_> @type hGetLine
10:50:55 <lambdabot> Not in scope: `hGetLine'
10:51:06 <dcoutts_> @type System.IO.hGetLine
10:51:07 <lambdabot> GHC.IOBase.Handle -> IO String
10:51:19 <xerox> I'm so happy about receiving students' emails.
10:51:26 <dcoutts_> LordBrain, does that answer the question
10:51:28 <LordBrain> hGetLine gives you a single line.... out of the buffer, but it doesnt control the fact that the buffer is the whole file
10:51:44 <xerox> ``I've been working on a project which is also the theme of my graduation project, that consists of creating a BSP based library for parallel programming, which is much like BSML.''
10:52:16 <joelr1> am i doing something visibly wrong here?
10:52:23 <LordBrain> at least thats my experience
10:52:28 <joelr1> count = (length .) . filter . (==)
10:52:28 <joelr1> fixLines n xs = concat first : fixLines n rest
10:52:28 <joelr1>     where (first, rest) = splitAt (k - 1) xs
10:52:28 <joelr1>           k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
10:52:35 <joelr1> this loops forever
10:52:46 <LordBrain> and i cant use hSetBuffering because that operates on a handle.. and i have an IO handle
10:53:24 <dcoutts_> LordBrain, if you've got an IO Handle then you can use >>= hSetBuffering
10:53:34 <LordBrain> oh
10:53:38 <LordBrain> hmmm
10:53:52 <dcoutts_> I don't quite understand what you say about the buffering.
10:54:35 <dcoutts_> do { hnd <- openFile "foo"; hSetBuffering hnd; line <- hGetLine; ... }
10:54:51 <xerox> (It needs a 'buffering type' parameter.)
10:55:02 <dcoutts_> oh yeah
10:55:11 <dcoutts_> but I don't think it's necessary really
10:55:20 <dcoutts_> I mean, using hSetBuffering
10:55:28 <LordBrain> well.. in ghc, by default, it reads files in chunks, that are bigger than lines... and when i use bracket i assume it does the inside repeatedly for the chunks.. if memory serves me.. i may be showing a lot of ignorance here
10:55:56 <dcoutts_> yes, by default it'll use big chunks. that's good no?
10:56:01 <xerox> http://hackage.haskell.org/trac/summer-of-code/wiki/People
10:56:05 <xerox> Man, count how many....
10:56:07 <LordBrain> so i'm inside that lambda expression which is the last parameter on my bracket
10:56:09 <notanotheridiot> in my soc application, should I go into detail about implementation? or just say what it is I'm doing
10:56:09 <dcoutts_> bigger chunks gives better performance
10:56:27 <dcoutts_> notanotheridiot, go into as much detail as you like
10:56:35 <LordBrain> and i say line <- hGetLine .. etc
10:56:48 <dcoutts_> notanotheridiot, if it gives us the impression that you know what you're talking about then that's good!
10:57:00 <joelr1> Cale: what's purpose of scanl (+) 0
10:57:00 <xerox> dcoutts_: I'll re-use your answer, dunno about what to answer to that most of the time (-:
10:57:17 <dcoutts_> heh
10:57:40 <xerox> joelr1: progressions?
10:58:12 <LordBrain> because it was inside the bracket.. and it got the file in one chunk, i end up only dealing with the first line.. when i had intended to deal with them all
10:58:34 <dcoutts_> LordBrain, that's got nothing to do with buffering.
10:59:24 <dcoutts_> you'll need to use hGetLine in a loop
10:59:34 <dcoutts_> eg a recursive function
10:59:36 <joelr1> xerox: i can't understand this line:  k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
11:00:41 <LordBrain> dcoutts: is my understanding of bracket wrong? i thought it would keep doing the final thing... i guess i thought the loop was built in
11:00:44 <mauke> k = length (takeWhile (<= n) (scanl (+) 0 (map (count ',') xs)))
11:00:46 <ValarQ> joelr1: thats an interesting line
11:01:09 <dcoutts_> LordBrain, bracket? what code are you using exactly?
11:01:23 <LordBrain> well.. i actually already scrapped it...
11:01:32 <LordBrain> i redid it differently
11:01:36 <Cale> joelr1: break it down into small pieces -- it first applies count ',' to all the strings
11:01:37 <dcoutts_> LordBrain, another alternative if you just want the lines is: liftM lines (readfile "foo.txt")
11:01:44 <LordBrain> using getContents, and lines, and unlines
11:01:46 <joelr1> so map (count ',') xs produces the # of commas in each line 
11:02:00 <Cale> right
11:02:10 <Cale> and then it does scanl (+) 0 on that
11:02:14 <dcoutts_> LordBrain, using getContents, lines etc sounds perfectly reasonable
11:02:17 <Cale> which produces the list of partial sums
11:02:24 <Cale> scanl (+) 0 [1,2,3,4,5]
11:02:27 <Cale> > scanl (+) 0 [1,2,3,4,5]
11:02:28 <lambdabot> [0,1,3,6,10,15]
11:02:43 <joelr1> Cale: why do you need that?
11:02:44 <LordBrain> yeah.. it worked, i was just wondering if there was a way to express my original intent
11:02:53 <dcoutts_> which was?
11:03:00 <LordBrain> but from talking with you, i think i misunderstood the bracket command
11:03:06 <LordBrain> i should review it
11:03:17 <joelr1> Cale: this is clearly some sort of a trick but i can't grasp its significance
11:03:21 <Cale> joelr1: because we're looking for the last point at which that's less or equal to n
11:03:46 <xerox> scanl (+) 0 [1..] are called Triangolar numbers.
11:03:56 <Cale> i.e. how many lines can we take before we're over n commas
11:04:04 <Cale> Triangular
11:04:20 <joelr1> Cale: ah! you are basically looking for a list of strings that together make the requisite # of commas, right?
11:04:26 <Cale> right
11:05:02 <Cale> I suppose length . takeWhile is a bit inefficient. There are things in Data.List which are better
11:05:05 <jip> sjanssen: IO is ST, but problem is that with ST i need to extract the mutable state into a pure value and then inject it back into STRefs all the time, while i do IO.
11:05:18 <xerox> Oops, trangular.
11:05:26 <Cale> like elemIndex
11:05:29 <xerox> ....triangular.
11:05:36 <Cale> er, or findIndex
11:05:54 <Cale> > findIndex (>= 4) [1..10]
11:05:55 <lambdabot> Just 3
11:05:56 <joelr1> Cale: so k is the number of strings that you want to take 
11:06:02 <Cale> yeah
11:06:29 <joelr1> and concat puts them together into a single line. cool
11:06:51 <joelr1> Cale: it does not seem to work, though
11:06:55 <joelr1> it loops forever
11:07:04 <Cale> hmm
11:07:13 <Cale> not here
11:07:36 <joelr1> try these 3 lines
11:07:37 <joelr1> 4914834,HST,The Haunting,$0.02/$0.04,0,0.33,0.40,-1,0.40,-1,9,1,REAL,-1,empty,2005-10-08 08:39:18,2006-01-31 00:31:23,0,0,0,1
11:07:53 <jfoutz> @pl \x y -> (show x) ++ (show y)
11:07:53 <lambdabot> (. show) . (++) . show
11:07:54 <joelr1> well, no, here
11:08:03 <joelr1> 4914834,HST,The Haunting,$0.02/$0.04,0,0.33,0.40,-1,0.40,-1,9,1,REAL,-1,empty,20
11:08:07 <joelr1> line 1
11:08:13 <joelr1> 05-10-08 08:39:18,2006-01-31 00:31:23,0,0,0,1
11:08:15 <joelr1> line 2
11:08:23 <joelr1> and an empty line 3, just a single newline 
11:08:41 <joelr1> i'm using xerox's count = (length .) . filter . (==)
11:09:16 <psi> looks like poker :)
11:09:45 <joelr1> indeed
11:10:09 <Cale> joelr1: well, it needs a base case, but it works for me
11:10:11 <Cale> otherwise
11:10:28 <joelr1> Cale: base case?
11:10:37 <joelr1> i just make a list of these 3 strings
11:10:40 <joelr1> let me try that in fact
11:10:50 <joelr1> instead of loading from file
11:11:35 <Cale> which k are you using?
11:11:45 <Cale> perhaps I am missing something
11:12:27 <joelr1> k?
11:12:34 <Cale> er, which n
11:12:37 <joelr1> 20
11:12:40 <Cale> okay
11:13:06 <LordBrain> what are you guys working on?
11:13:50 <joelr1> LordBrain: an excercise in joining lines :D
11:13:52 <kzm_> how does putStr and friends work on chars > 255?
11:14:37 <RyanT5000> if i apply a constant function to a constant value, will it get evaluated at compile-time
11:14:43 <LordBrain> are you doing a tutorial?
11:14:50 <Cale> RyanT5000: not too likely
11:14:56 <RyanT5000> why not?
11:15:10 <Cale> RyanT5000: because there's no way of knowing that the evaluation terminates
11:15:18 <RyanT5000> hm
11:15:25 <joelr1> Cale: that function, does it map once? or does it map on every iteration?
11:15:28 <Cale> and even if it does, it might take a very long time
11:15:46 <RyanT5000> that seems like it would be a good optimization, though, if you could avoid that problem
11:15:52 <kzm_> Cale, I still think GHC if pretty decent at evaluating constants like that, though.
11:15:54 <joelr1> Cale: i think it does on every iteration. so is the idea that it only maps on enough lines to produce the result?
11:15:55 <Cale> joelr1: it does a separate map on every iteration, though that could be fixed
11:16:21 <RyanT5000> especially if you have a function like map
11:16:24 <Cale> joelr1: well, only the values which are used are computed
11:16:38 <kzm_> > map Char.chr [400..450]
11:16:39 <lambdabot> "\400\401\402\403\404\405\406\407\408\409\410\411\412\413\414\415\416\417\418\419\420\421\422\423\424\425\426\427\428\429\430\431\432\433\434\435\436\437\438\439\440\441\442\443\444\445\446\447\448\
11:16:40 <lambdabot> 449\450"
11:16:44 <RyanT5000> where essentially you're creating a constant closure
11:16:46 <joelr1> Cale: i don't think it needs to be fixed because if a line has 20 commas it will only run count on that line it seems
11:16:48 <kzm_> :-)
11:16:59 <joelr1> so then there's nothing to fix in that regard
11:17:18 <bolrod> > last $ map Char.chr [1..]
11:17:20 <RyanT5000> then you'd be guaranteed that foldl (+) 0 would be just as fast as sum (that is, if sum didn't have any other optimizations)
11:17:22 <lambdabot> Terminated
11:18:11 <kzm_> but putStrLn seems to just wrap this (i.e. mod 256 it)
11:18:33 <kzm_> (or at least, writeFile does, I can't easily test it from within GHCi)
11:18:50 <RyanT5000> Cale: what about if it just did the first part of evaluation, i.e.: do the lambda substitutions
11:18:55 <Cale> joelr1: the code works here with n = 20
11:19:12 <Cale> joelr1: though the behaviour with n = 10 is less than desirable :)
11:19:19 <joelr1> cale, this is the code, right?
11:19:20 <joelr1> count = (length .) . filter . (==)
11:19:21 <joelr1> fixLines n xs = concat first : fixLines n rest
11:19:21 <joelr1>     where (first, rest) = splitAt (k - 1) xs
11:19:21 <joelr1>           k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
11:19:50 <joelr1> and your test lines are these, right?
11:19:50 <joelr1> myLines = ["4914834,HST,The Haunting,$0.02/$0.04,0,0.33,0.40,-1,0.40,-1,9,1,REAL,-1,empty,20", "05-10-08 08:39:18,2006-01-31 00:31:23,0,0,0,1", ['\n']]
11:20:06 <Cale> fixLines' n [] = []
11:21:07 <Cale> oh, I see the problem
11:21:54 <joelr1> ?
11:22:17 <psi> xerox: you mentioned a link with tips for writing applications?
11:22:34 <joelr1> one thing is that it wants more lines than needed
11:22:47 <Cale> fixLines' n [] = []
11:22:48 <Cale> fixLines' n xs = concat first : fixLines' n rest
11:22:48 <Cale>     where (first, rest) = splitAt (max 1 k) xs
11:22:48 <Cale>           k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
11:22:48 <Cale>           count = (length .) . filter . (==)
11:22:52 <joelr1> length gives me 4 for 3 lines
11:23:25 <Cale> actually, that max 1 k might not be needed
11:23:46 <Cale> since takeWhile will always take at least one element
11:23:55 <Cale> (unless n is negative)
11:25:12 <joelr1> Cale: check this out:  length . takeWhile (<= 20) . scanl (+) 0 . map (count ',') $ myLines => 4
11:25:15 <xerox> psi: I remember there was one... can't find it now.
11:25:23 <joelr1>  length myLines => 2
11:25:27 <joelr1> err,  length myLines = 3
11:26:00 <Cale> ah, right, I had it subtracting 1 for that reason
11:26:09 <Cale> fixLines' n [] = []
11:26:09 <Cale> fixLines' n xs = concat first : fixLines' n rest
11:26:09 <Cale>     where (first, rest) = splitAt (max 1 (k-1)) xs
11:26:09 <Cale>           k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
11:26:09 <Cale>           count = (length .) . filter . (==)
11:26:14 <Cale> I think this is correct
11:26:29 <joelr1> map (count ',') $ myLines => [15,5,0] so that's proper
11:27:29 <psi> xerox: was it written by a mentor organisation from last year? I recall something like that.
11:27:34 <Cale> try that version
11:27:40 <xerox> psi: Google it <grin>
11:27:51 <joelr1> Cale: trying... works fine from strings, problem with file. looking into that
11:27:56 <psi> :)
11:28:33 <Cale> joelr1: the problem was that sometimes k-1 was 0, in which case it could make no progress.
11:28:52 <joelr1> Cale: right
11:30:50 <Cale> (if the first line had more than the required number of commas per line)
11:33:23 <joelr1> Cale: it's wierd but reading from a file does not work 
11:33:30 <joelr1> returns an empty list
11:33:42 <joelr1>           (\h -> do
11:33:42 <joelr1>              c <- hGetContents h
11:33:42 <joelr1>              return $ fixLines 20 $ lines c)
11:34:00 <Cale> are you doing anything else with the handle h?
11:34:17 <Cale> You're not supposed to hClose a handle which you pass to hGetContents
11:34:28 <joelr1> wc -l game_info_tbl.csv
11:34:28 <joelr1>        3 game_info_tbl.csv
11:34:40 <joelr1> Cale: that must be it!
11:34:53 <joelr1> i have it like this 
11:34:54 <joelr1> loadTableInfo = do
11:34:54 <joelr1>   bracket (openFile "game_info_tbl.csv" ReadMode)
11:34:55 <joelr1>           (hClose)
11:34:55 <joelr1>           (\h -> do
11:35:03 <Cale> yeah, that's wrong
11:35:44 <Cale> all you have to do is open the file and pass the handle to hGetContents, it'll be closed either when the string is GC'd or when the nil at the end is forced
11:36:01 <joelr1> ok
11:38:01 <LordBrain> hmmm i did that too
11:38:17 <LordBrain> havent had a problem yet
11:38:26 <Cale> okay, so you're going to build a big lazy list of records, I take it
11:39:13 <Cale> LordBrain: if the hClose happens before you've finished forcing the string's evaluation, the string will be truncated at whatever point it had reached before then
11:39:18 <joelr1> Cale: yes
11:39:35 <Cale> joelr1: what sort of computation are you performing on them?
11:39:35 <LordBrain> hmm
11:39:50 <joelr1> Cale: i'm gonna create events from them and process those events
11:41:14 <dcoutts_> joelr1, you're reading these events from a file? a 4GB file right?
11:41:15 <Cale> LordBrain: if you were to, say print the entire string to the screen before calling hClose, it would be fine, but the hClose would be unnecessary, as the handle would have been closed by the end of the string getting evaluated
11:41:22 <joelr1> dcoutts_: right
11:41:26 <joelr1> how do you get around this again?
11:41:27 <joelr1> Main.hs:32:2: The last statement in a 'do' construct must be an expression
11:41:37 <dcoutts_> joelr1, that's going to be your bottleneck
11:41:51 <joelr1> dcoutts_: what exactly?
11:42:00 <dcoutts_> the IO & parsing
11:42:07 <dcoutts_> benchmark that first
11:42:12 <Cale> joelr1: don't make the last thing in a do-block be a variable binding
11:42:13 <joelr1> dcoutts_: right, that's what i was saying before
11:42:20 <dcoutts_> try just reading and discarding every event
11:42:22 <dcoutts_> benchmark that
11:42:41 <joelr1> i just have this
11:42:42 <joelr1> loadTableInfo = do
11:42:42 <joelr1>   h <- openFile "game_info_tbl.csv" ReadMode)
11:42:42 <joelr1>   c <- hGetContents h
11:42:42 <joelr1>   return $ fixLines 20 $ lines c
11:42:45 <dcoutts_> then if it's too slow (it probably will be) then make it use ByteStrings instead
11:43:04 <dcoutts_> joelr1, that's the same as readFile
11:43:09 <joelr1> dcoutts_: ugh, i've got a nice lazy list built up
11:43:13 <Cale> joelr1: hmm, get rid of the stray )
11:43:24 <dcoutts_> what's fixLines?
11:43:48 <joelr1> ok, cale is right
11:43:54 <joelr1> i need to pay  more attention :D
11:43:56 <joelr1> the stray )
11:44:00 <joelr1> dcoutts_: fixlines?
11:44:12 <joelr1> fixLines _ [] = []
11:44:12 <joelr1> fixLines n xs = concat first : fixLines n rest
11:44:12 <joelr1>     where (first, rest) = splitAt (max 1 (k - 1)) xs
11:44:12 <joelr1>           k = length . takeWhile (<= n) . scanl (+) 0 . map (count ',') $ xs
11:44:17 <joelr1> dcoutts_: courtesy of cale
11:44:20 <dcoutts_> joelr1, aye, what does it do?
11:44:43 <Cale> dcoutts: the function that we've been discussing -- it simply concatenates adjacent groups of lines under the restriction that lines should have less than or equal to n commas
11:44:48 <joelr1> dcoutts_: oh, it joins lines until there are 20 commas
11:45:02 <Cale> (and if one has more than n, it just leaves it alone)
11:45:08 <dcoutts_> because 20 commas is your event boundary?
11:45:15 <joelr1> dcoutts_: right
11:45:21 <dcoutts_> odd format :-)
11:45:24 <joelr1> there should be 20 fields in a record. or 21
11:45:33 <joelr1> dcoutts_: it's a csv dump from oracle
11:45:35 <araujo> hiya
11:45:40 <joelr1> of an oracle table
11:45:44 <joelr1> hey
11:45:53 <Cale> joelr1: and you're certain that you'll never have to split a line in order to get that number?
11:45:59 <dcoutts_> joelr1, and it's split records across multiple lines
11:46:28 <joelr1> Cale: yes
11:46:36 <RyanT5000> anyone know what the word limit is on the google soc application?
11:46:41 <joelr1> because oracle basically dumps things in 80 characters, they way i have it
11:46:49 <RyanT5000> it says (in the faq) that there is one, but the entry form doesn't say what it is
11:46:53 <dcoutts_> RyanT5000, no idea, try it and see
11:47:24 <RyanT5000> i will, i just didn't want to start typing something long, get cut off, and have to rewrite the whole thing :)
11:47:35 <dcoutts_> joelr1, when you find that lazy String IO is too slow, try with ByteString and reading in chunks.
11:47:43 <joelr1> dcoutts_: i should probably read directly from oracle but i want to start with a file first
11:47:58 <sowha1> anyone aware of a scheme parser in haskell?
11:48:20 <joelr1> sowha1: google for scheme in 48 hours
11:48:52 <ValarQ> thats only a tutorial thought
11:49:13 <joelr1> dcoutts_: i suppose it would work, so long as there was a lazy function producing chunks 
11:49:22 <sowha1> yep, i found that one, but a complete one would be nice :)
11:49:25 <dcoutts_> joelr1, it's easy to write one
11:49:48 <joelr1> dcoutts_: but the complication then would be chunks that would be partially used
11:49:54 <dcoutts_> joelr1, it could give you a lazy list of say 16k bytestring.
11:49:58 <dcoutts_> that's true
11:49:59 <joelr1> i.e. some strings could call on chunk boundaries
11:50:17 <dcoutts_> joelr1, or instead mmap the whole file.
11:50:31 <dcoutts_> joelr1, you're on a 64bit machine right?
11:50:54 <dcoutts_> the OS will take care of read-ahead and discarding
11:51:08 <dcoutts_> you could do the parsing all in one big ByteString
11:51:34 <joelr1> dcoutts_: yep, 64-bit target but my mac is only 32-bit and i would be testing on the mac. 
11:51:55 <joelr1> dcoutts_: let me check for mmap in fps 0.6
11:51:59 <joelr1> i think it's there
11:52:02 <shapr> musasabi: Want info on a failing jhc --selftest?
11:52:04 <dcoutts_> it is there
11:52:38 <dcoutts_> joelr1, ByteString has functions for scanning for chars, so you could do that to get the 20th ','
11:52:38 <joelr1> dcoutts_: so with mmap i would just be getting lines from the handle and that would be lazy by nature, right?
11:52:50 <dcoutts_> the OS will lazily map in pages
11:53:05 <dcoutts_> it'd appear as one massive ByteString
11:53:12 <Cale> sowha1: I wonder what exactly is missing from listing10.hs in that tutorial. It seems like a good start at least.
11:53:16 <joelr1> i wonder if cale's version will work with bytestrings mmapped from a file
11:53:49 * shapr admires Igloo's boots of kicking.
11:53:57 <dcoutts_> and so long as you're not still looking at bits of the file from the beginning when you're reading then end it should be ok
11:54:12 * palomer really really really hopes his SoC proposal will be accepted
11:54:21 <dcoutts_> joelr1, but if you're more paranoid about memory use then use a list of chunks instead
11:54:22 <joelr1> dcoutts_: what's that about bits from the beginning?
11:54:23 <Cale> palomer: what's your proposal?
11:54:47 <palomer> http://hackage.haskell.org/trac/summer-of-code/ticket/78
11:55:00 <palomer> I even have a prototype: www.magnesium.net/~palomer/graphical
11:55:01 <dcoutts_> joelr1, the OS will only be able to discard pages from the beginning of the file by the time you're looking at the end of the file if you're not still using those strings from the beginning
11:55:19 <dcoutts_> joelr1, so you've got to make sure you don't hold on to strings from the file for too long
11:55:23 <shapr> JohnMeacham: ./E/SSimplify.hs:508:86: Not in scope: `isIsBoundTo' (and more errors) after darcs pull
11:55:29 <dcoutts_> or your memory use will not be constant
11:55:41 <Cale> palomer: I wonder if you could use the ghc-api for that
11:55:48 <joelr1> dcoutts_: just as i understood cale's lazy fixLines.... :-) i think i'll move on with it for now... unless i't easy to do getlines from a mmapped file... need to investigate
11:55:50 <Cale> sounds like a cool idea
11:56:00 <dcoutts_> joelr1, if you need to keep some strings then you need to use copy to unshare them.
11:56:41 <palomer> what exactly is ghc-api?
11:56:50 <dcoutts_> palomer, yeah, it's an interesting idea.
11:56:56 <araujo> hello!
11:57:07 <dcoutts_> palomer, you know my research is in type systems and inference algorithms.
11:57:10 <Cale> palomer: basically, a library version of large chunks of GHC, including the typechecker
11:57:15 <joelr1> dcoutts_: how would i generate a lazy list of getLines? list comprehension?
11:57:38 <dcoutts_> joelr1, probably fold.
11:57:46 <Cale> hm?
11:57:51 <Cale> @type lines
11:57:52 <lambdabot> String -> [String]
11:58:13 <dcoutts_> oh do you mean fixLines or something else?
11:58:17 <joelr1> Cale: dcoutts_ is suggesting reading lines from a mmap-ed file
11:58:32 <joelr1> Cale: i think that would require passing fixLines a lazy list of lines
11:58:41 <dcoutts_> well really i'm suggesting ByteStrings for performance
11:58:57 <joelr1> Cale: so i'm thinking how i would use ByteString's hGetLine to build a lazy list of byte strings
11:59:26 <Cale> that would be unsafeInterleaveIO, probably
12:00:04 <dcoutts_> joelr1, are you sure you're parsing the cvs file right? it's not as simple as counting ',' chars. You can get embeded ','s in other string fields.
12:00:14 * dcoutts_ has to go
12:00:17 <Cale> @type System.IO.Unsafe.unsafeInterleaveIO
12:00:18 <lambdabot> forall a. IO a -> IO a
12:01:05 <joelr1> dcoutts_: thanks for your help. i don't think i'll have commas in the file apart from field separators
12:01:15 <joelr1> Cale: is that the only way?
12:01:43 <dcoutts_> joelr1, hGetContents is implemented using unsafeInterleaveIO
12:01:43 <Cale> unsafeInterleaveIO takes an IO action with some possible side effects and gives an IO action which returns immediately, deferring those side effects until the value returned is evaluated.
12:01:53 <dcoutts_> unsafeInterleaveIO isn't as unsafe as other "unsafe" things
12:02:17 <dcoutts_> it gives you lazy IO which can be really handy.
12:02:19 <Cale> It can still get you into a confusing mess though :)
12:02:24 <dcoutts_> it can :-)
12:02:49 <joelr1> ok, so basically it's unsafeInterleaveIO . B.hGetLine, 
12:03:12 <Philippa> the unsafety is the 'magic' piping of the world-at-demand-time into the action, but at least it started off with a world at all. Depending on how you define your world it's theoretically even pure
12:03:40 <Cale> Philippa: it can cause problems with order of evaluation though
12:03:48 <Philippa> yep
12:04:00 <joelr1> Cale: i could use your function unchanged, right? so long as I use B.concat, B.count and give it a lazy list of strings
12:04:00 <Philippa> you'd have to define your world in a rather recursive manner...
12:04:13 <Philippa> ("from my world view I can see the computation and keep going 'til there's demand - cool!")
12:04:13 <Cale> yes
12:04:26 <palomer> dcoutts: what inference algorithms are you working on?
12:04:51 <xerox> @yow!
12:04:52 <lambdabot> I'd like MY data-base JULIENNED and stir-fried!
12:05:00 <dcoutts_> palomer, subtyping for binding time analysis
12:05:03 <xerox> yow?
12:05:18 <vincenz> xerox: hola
12:05:22 <dcoutts_> palomer, it's an extension of simple HM typecheking
12:05:23 <vincenz> @bot
12:05:24 <lambdabot> :)
12:05:28 <palomer> dcoutts: decidable?
12:05:38 <dcoutts_> palomer, yep
12:05:48 <palomer> what kind of subtyping?
12:06:06 <dcoutts_> palomer, it's for binding times
12:06:16 <dcoutts_> static < dynamic
12:06:36 <palomer> binding times?
12:06:44 <dcoutts_> palomer, have you seen helium?
12:06:57 <palomer> not really
12:06:59 <dcoutts_> it's for students learning Haskell
12:07:02 <palomer> from what I heard it's haskell98 without typeclasses
12:07:05 <dcoutts_> it gives excelent error messages
12:07:21 <dcoutts_> sounds like it should be right up your street
12:07:30 <dcoutts_> you could do the GUI for that rather than ghc
12:07:53 <dcoutts_> I think it does now support at least the built-in typeclasses
12:08:01 <dcoutts_> so it's ok for teaching Haskell
12:08:17 <palomer> my plugin would be independent of the compiler
12:08:40 <vincenz> palomer: plugin for?
12:08:41 <palomer> it would depend on the typesystem, and would work for any weaker type systems
12:08:49 <dcoutts_> well it's more the fact that helium has a nice system for doing the type inference
12:08:51 <palomer> vincenz: http://hackage.haskell.org/trac/summer-of-code/ticket/78
12:09:01 <dcoutts_> it uses a scriptable constraint solving system
12:09:13 <palomer> dcoutts: meaning?
12:09:30 <dcoutts_> you can write rules for directing where to look for the type errors
12:09:41 <dcoutts_> so you can customise the type error messages
12:09:54 <dcoutts_> to produce excelent and really helpful ones
12:10:28 <LordBrain> ok, newb here.. i keep thinking of for-each situations.. and end up translating that into map... I'm wondering if i really ought to be translating that differently?
12:10:34 <dcoutts_> it'd be a good basis on which to build a gui for showing the types of each bit of an expression
12:10:36 <flux__> I read, some time ago, a paper on how to generate better error messages for type inference.. it would be nice if we were to see such research in action.
12:10:48 <joelr1> -- Tsunami warnings issued for Fiji and New Zealand after earthquake measuring a magnitude of about 8.0 shakes southern Pacific Ocean.
12:10:49 <palomer> dcoutts: I was thinking of simply annotating the abstract syntax tree
12:10:51 <LordBrain> or if i should be thinking differently
12:11:07 <joelr1> salazar left 
12:11:11 <flux__> dcoutts_, btw, ocaml has that with emacs' tuareg mode, it generates type annotations during compile time
12:11:13 <joelr1> hopefully he knows
12:11:13 <monochrom> map is fine. sometimes you need foldr or foldl.  sometimes you will also find list comprehension handy.  (python has list comprehension too)
12:11:14 <dcoutts_> flux__, download helium. it really is used for teaching.
12:11:17 <Cale> LordBrain: no, that's exactly right
12:11:19 <flux__> and it really is a nice feature
12:11:21 <LordBrain> thinking more recursively maybe
12:11:26 <Cale> LordBrain: either map or mapM
12:11:46 <Cale> I often define forM = flip mapM
12:11:56 * dcoutts_ really has to go
12:11:58 <flux__> debian doesn't have helium.. ;)
12:12:49 <Muad_Dibber> flux__: http://www.cs.uu.nl/helium/
12:13:22 <Philippa> LordBrain: what Cale said, or more generally fmap or various *map-style functions ('for each item in this non-list structure')
12:13:45 <LordBrain> ok
12:14:48 <Cale> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Traversable.html
12:14:56 <Cale> That's in the CVS ghc, iirc.
12:15:14 <wolverian> Cale, not forM_? 
12:15:43 <sowha1> Cale: the tutorial certainly is a good start, but i wonder if i'll be able to add things like classes and other haskell unlike features
12:15:46 <Cale> wolverian: that too, though it doesn't make too much difference
12:16:00 <wolverian> Cale, yeah. I'm just uncomfortable with a 'for' that returns a list. :)
12:17:42 <araujo> @type repeat
12:17:43 <lambdabot> forall a. a -> [a]
12:17:59 <Cale> @type replicate
12:18:00 <lambdabot> forall a. Int -> a -> [a]
12:18:03 <araujo> > take 5 $ repeat 2
12:18:04 <lambdabot> [2,2,2,2,2]
12:18:10 <Cale> > replicate 5 2
12:18:11 <lambdabot> [2,2,2,2,2]
12:18:26 <joelr1> ByteString.mmapFile maps the whole file onto a single huge ByteString
12:18:45 <joelr1> how would I split it on '\n' lazily?
12:18:57 <Cale> joelr1: how much memory do you have?
12:19:25 <joelr1> 1Gb on the test machine (my powerbook) and 16Gb on the production box although a few Gb of that are taken by oracle
12:19:46 <wolverian> I hope that's GB 
12:19:58 <Cale> okay, so you probably don't want to be mmap'ing a 4GB file on your powerbook
12:20:01 <joelr1> Cale: plus i can't read a lot of stuff into memory /don't want to/ because i'm gonna be keeping a lot of stuff in memory. huge datastructures
12:20:09 <joelr1> Cale: no, i'll map a smaller file 
12:20:19 <joelr1> wolverian: GB, right
12:20:36 <joelr1> Cale: the question is how to split lazily. because the split code in FPS has strict annotations
12:20:47 <LordBrain> hmm
12:21:25 <Cale> If you're really going to use the file lazily, there should be no problems with just using lists.
12:21:54 <LordBrain> i know i just used this lines command a while ago to split on \n... i guess thats probably not lazy?
12:21:59 <joelr1> Cale: well, i need to process the whole fle as quickly as possible and dcoutts_ suggested that byte strings will be much faster
12:22:05 <Cale> LordBrain: no, it's lazy
12:22:15 <LordBrain> hmm i thought so
12:22:35 <Cale> joelr1: hmm, if you can afford the memory consumption
12:22:49 <palomer> weeeeeeeeeeeeeeeeeeeeee! it works!
12:22:52 <palomer> halleluiah!
12:22:52 <Cale> most operations on ByteStrings are strict, afaik
12:22:56 <LordBrain> :)
12:22:58 <Cale> palomer: what works?
12:23:18 <shapr> Yay, I got Dance source!
12:23:19 <joelr1> Cale: maybe i can search forward until the next \n, starting from a given position
12:23:34 <palomer> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype 
12:23:39 <Cale> do you just want to form ByteStrings of each line?
12:23:44 <palomer> my type inference algorithm can infer the first type
12:24:00 <palomer> err, the type of the eval function in the first example
12:24:10 <joelr1> Cale: i think the point is to memory-map the whole huge file and, apparently, if no references are kept to prior pages then they will be dropped out of memory
12:25:14 <shapr> In his PhD thesis, Wouter van Oortmerssen says that he doesn't think the average programmer would be able to create their own monad instances. I'm not sure I agree, but I don't have any data one way or the other.
12:25:17 <shapr> Any thoughts?
12:25:25 <Cale> joelr1: hmm, I'd have to know more about the details of ByteString to know if that's true, but it's somewhat plausible
12:25:42 <Cale> shapr: I don't see any reason why not
12:26:14 <palomer> shapr: I created my own monad instance!
12:26:17 <palomer> it rocks too
12:26:30 <Philippa> shapr: you know the interpreter-based ones I've got up on the TMR wiki?
12:26:36 <joelr1> Cale: so i'm looking for a function to find the position of a character given a position. then i guess i could copy the string out
12:26:39 <Philippa> I'd hope like hell an average programmer can implement those
12:26:52 <Philippa> and if not, I'm scared by the average
12:26:56 <xerox> Howdy Philippa
12:27:00 <Philippa> evenin'
12:27:09 <xerox> shapr: I'm with Cale.
12:27:27 <Philippa> Cale: I think the typical fused implementations're pretty scary, FWIW
12:27:42 <Cale> shapr: I'd be willing to claim that if you have enough ability to learn to implement, say, a tree datastructure in C, then you should be able to learn how to write your own monad instance.
12:27:50 <shapr> I like that claim :-)
12:27:51 <Philippa> (I also think separating AST from interpreter/semantics is useful, but hey)
12:28:04 <Philippa> Cale: that and some useful walks thereof. But yeah, with you
12:28:13 <Philippa> shapr: you seen the code I mentioned?
12:28:16 <Philippa> if not, want a link?
12:28:20 <shapr> sure
12:29:18 <xerox> shapr: any news from TheHunter?
12:29:51 <shapr> No, haven't heard from him in a long time.
12:29:56 * xerox misses him
12:30:05 <shapr> I think I have his email address around here somewhere...
12:30:07 <jip> > ((-) 5) 10
12:30:08 <lambdabot> -5
12:30:12 <xerox> jip: subtract
12:30:20 <jip> > (subtract 5) 10
12:30:21 <lambdabot> 5
12:30:28 <jip> xerox: :D
12:30:30 <xerox> subtract = flip (-)
12:30:34 <Cale> There are basically two kinds of pictures you should understand in order to be able to come up with new monads. The container view (and container-like monads are generally pretty easy to think up and construct), and the computation view, which is a little harder to get into at first, but still, not terribly difficult once you get it.
12:31:01 <jip> Cale: if i understand only the computation view, is that enough?
12:31:03 <xerox> Also known as Cale's waves and particles views of monads.
12:31:22 <Cale> jip: well, it's enough to get most of the more useful-for-programming monads.
12:31:22 <monochrom> haha
12:31:33 <wolverian> xerox, haha :)
12:31:36 <xerox> Yay (-:
12:32:00 <Cale> jip: though I'd still recommend trying to see the container picture, as it's rather nice.
12:32:39 <_roconnor> Isn't a computation a box that you open up to see what the result is?
12:32:43 <Cale> Nondeterminism and exception monads are usually easier to see from a container perspective.
12:33:19 <xerox> And _roconnor found a particles theory of Monad Gravitation!!!  Nobel price.
12:33:27 <Cale> _roconnor: sometimes the boxes get rather large, but yeah
12:33:40 <monochrom> A problem with the "computation view" is that "computation" is even less meaningful than "monad".  With "monad" at least you get three axioms; with "computation" you get none.  Everyone has a different subconscious idea of "computation" and when two or more people start throwing around "computation" it's a mess.
12:33:45 <Cale> Like in the state monad, the box is a container indexed by initial states
12:34:38 <Cale> monochrom: yeah, most people's idea of 'container' is closer to 'monad' than most people's idea of 'computation'
12:35:17 <monochrom> The situation is quite like OOP.
12:35:47 <_roconnor> still, I suppose it is important not to put two boxes into one box. ;)
12:35:51 <monochrom> And for the same reason, the "computation view" is more popular than the container view.
12:36:23 <monochrom> People don't like it when their terms are unambiguous.
12:36:27 <xerox> I think it depends wether you first learned them throught Cale's article or not :-)
12:36:33 <LordBrain> lol
12:36:52 <monochrom> I first learned monads through Wadler papers.
12:37:06 <glauber_sp> Hi ppl =)
12:37:18 <Cale> Well, the computation view has the advantage that it's closer to how one actually uses monads -- this is programming after all.
12:37:31 <Cale> glauber_sp: hello
12:37:32 <Philippa> monochrom: the "computation view" when properly defined still comes with the monad laws
12:37:37 <glauber_sp> Cale, hi =)
12:37:42 <xerox> I just say that not everybody got into this channel via hardcore maths, monochrom.
12:37:56 <Philippa> otherwise you may as well complain there're no laws on "containers" either
12:38:36 <monochrom> xerox: right, via fuzzy things like "objects" instead.  Totally predictable.
12:40:04 <Philippa> objects're generally well-defined within an individual language, in fairness
12:40:14 <Philippa> and function isn't exactly well-defined when taken across all programming languages either
12:40:29 <xerox> I'm still not sure about which view is more popular.
12:40:36 <LordBrain> not all objects are fuzzy, tho i certainly concede that many are... my mother's poodle likes to chew on them... its a comfort thing i guess.
12:42:12 <joelr1> how do you split a list on an element?
12:42:38 <joelr1> you know, in this cool haskell way that takes a while to grasp to the uninitiated
12:42:42 <Philippa> depends exactly how you want to do it. There's a bunch of split* functions in Data.List that might be a good starting point?
12:42:47 <glauber_sp> Guys, I have to write (I've almost finished) an L-system interpreter in C using flex/bison. I read a syllabus at Oxford asked the same work, but in Haskell. As I want to start writting Haskell code, I thought about doing that program. I've searched for tools and I found Happy. I wanted to know if I need to search for a Lexer, or if the Lexers Happy describes in its manual is enougth. I'd like to know if it's better to do this with 
12:42:47 <glauber_sp> Monads ow if it's too dificult to start with.
12:42:49 <Cale> Of course, what a monad *is* isn't really up for debate (grr, remove 'fail', mutter mutter), but this is about what one pictures when thinking about monads in general. I think it's unlikely we have all the relevant pictures yet, but having more perspectives is always good.
12:42:55 <joelr1> i just want to split a string on a comma
12:43:04 <Philippa> joelr1: the bit where you RTFM for the obvious module and grep for "split"? :-)
12:43:09 <mahogny> joelr1, I ended up writing my own function for that. but you can always try dropWhile, takeWhile
12:43:09 <LordBrain> hmm i find mastering haskell much slower going than other languages i've messed with.. is there a hump that once i get over, my ineptness will no longer be such the obstacle it is now?
12:43:35 <Cale> glauber_sp: look at Parsec, it's a pretty decent parser combinator library
12:43:41 <joelr1> Philippa: there's no split in Data.List ;-)
12:43:44 <Philippa> Cale: most people aren't interested in "monads in general", they're interested in "monads as used in my field". Got into an argument with earthy a week or two back that was essentially FPer vs denotational semanticist :-)
12:44:07 <Cale> glauber_sp: you should also look at Nymphaea, which is a (nondeterministic) L-system generator which xerox and I wrote.
12:44:15 <Philippa> joelr1: did I include an end-of-identifier? :-) There's a splitAt
12:44:16 <joelr1> mahogny: that's called span and there's also break but those return ([a], [a])
12:44:22 <sjanssen> @hoogle unsafeInterleaveIO
12:44:22 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
12:44:29 <mahogny> LordBrain, my very high threshold was connecting all the functional stuff to the abstraction I use in imperative programming. then I "mastered" it over night (but there are lots of FP-specific things left to master)
12:44:34 <xerox> glauber_sp - <http://haskell.galois.com/~paolo/nymphaea>
12:44:40 <Cale> Philippa: I think it's dangerous to be closed-minded in that regard
12:44:40 <glauber_sp> Cale, ok, I'll take a look so =) thanks
12:44:44 <glauber_sp> xerox, thanks =)
12:44:46 <joelr1> Philippa: i need to split the _whole_ string on comma and get the list of "fields"
12:44:59 <Philippa> Cale: I agree, but I don't see either container or computation working from a denotational semantics POV
12:45:23 <LordBrain> yeah
12:45:27 <Cale> Philippa: especially as, not so long ago, the answer to "How is category theory used in the field of CS" was most likely "Not at all"
12:45:51 <Philippa> Cale: the interpretation will *always* depend on the categories you start out with
12:46:02 <LordBrain> the connections between imperative adts... the translations.. getting all that down would be good for me
12:46:07 <_roconnor> I keep seeing monads everywhere: terms with variables, completion of a metric space.  The wierd thing is that all these structures seem so different.
12:46:29 <Philippa> joelr1: sounds like an unfold?
12:46:40 <Philippa> "keep doing splitAt 'til it don't split no more"
12:46:52 <joelr1> Philippa: right, i'm just looking at fold for that
12:46:58 <palomer> is there a function returning the index of the first element satisfying a predicate in a list?
12:47:08 <palomer> of type (a -> Bool) -> [a] -> Int
12:47:29 <norpan> @hoogle (a -> Bool) -> [a] -> Int
12:47:30 <lambdabot> No matches, try a more general search
12:47:34 <norpan> @hoogle (a -> Bool) -> [a] -> b
12:47:34 <lambdabot> No matches, try a more general search
12:47:49 <norpan> @hoogle [a] -> (a -> Bool) -> b
12:47:50 <lambdabot> No matches, try a more general search
12:47:57 <monochrom> List.findIndex, palomer 
12:48:08 <LordBrain> does anyone actually think in FP, or does everyone just think it up imperatively and then figure out how it codes in a purely functional language?
12:48:11 <norpan> @type findIndex
12:48:12 <Cale> _roconnor: I'd never noticed the completion of a metric space one before, thanks -- though it's sort of a trivial monad, in that join is a conceptual no-op.
12:48:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:48:19 <CosmicRay> LordBrain: I think in FP
12:48:20 <monochrom> As a bonus there is also findIndices
12:48:25 <Philippa> joelr1: unfold, not fold. You're building a list, not deconstructing one (yeah yeah, I know you're starting with one, but it doesn't have relevant structure looking at the constructors)
12:48:25 <LordBrain> thats good
12:48:25 <Cale> LordBrain: I think in FP.
12:48:33 <norpan> @type findIndices
12:48:33 <LordBrain> did you guys learn FP first?
12:48:34 <CosmicRay> LordBrain: I find, in fact, that FP is much more natural than imperative
12:48:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
12:48:44 <LordBrain> oh its definitely more natural to read....
12:48:53 * Philippa pretty much always thought in FP-as-metalanguage
12:48:57 <LordBrain> but when i try to think it up.. its less natural.. probably just my inexperience
12:48:58 <norpan> so findIndex should be Functor f => (a -> Bool) -> [a] -> f Int
12:48:59 <xerox> monochrom: just to make sure - I have nothing agains hardcore maths, just thinking out loud (-:
12:49:00 <Philippa> probably why I got comfortable with monads so fast
12:49:02 <Cale> LordBrain: It's a lot easier to think in terms of higher order functions than it is to think in terms of loops.
12:49:15 <Philippa> loops are just clumsy HOFs
12:49:25 <LordBrain> yeah... but i grew up with loops
12:49:26 <xerox> *against
12:49:32 <LordBrain> i'm wondering if there is hope for me
12:49:34 <LordBrain> hehe
12:49:56 <Philippa> yeah, it took me a while to learn to do FP-in-the-small
12:50:11 <Cale> LordBrain: Sure, I did too. But probably when you were doing the dishes, you didn't number the dishes and increment a counter every time you washed one either.
12:50:36 <Philippa> if you can use for_each in imperative languages when you have it, you can use map and mapM
12:51:18 <monochrom> Remember my BBQ "put all sausages on the grill" analogy!
12:52:40 <Cale> lists are about as natural as loops, in fact, they're basically the same thing
12:52:48 <LordBrain> i really like reading haskell.. its clear how we have a bunch of transformations, and what they are
12:53:01 <Philippa> Cale: *Lazy* lists... :-)
12:53:02 <monochrom> It proves that no one is a hardcore imperative programmer.  (Who would bark a for-loop to another human?)  It is human nature to be declarative.
12:53:07 <Cale> Philippa: of course
12:53:27 <Philippa> and yes. Although so far it's easier to analyse space usage on the loop, stuff like that
12:53:48 <_roconnor> Cale: It's non trivial because you need to take the cauchy sequence definiton of completion.  It just seems trivial because we are used to identifying rational numbers with their injective counterparts in the reals.
12:53:51 <SamB> well, humans just vectorize ;-)
12:54:09 <laurence> Hmm.  OK, what do I use instead of putStrLn if I don't want the newline?  I think I tried the obvious putStr last night and it didn't work.
12:54:28 <monochrom> putStr
12:54:37 <LordBrain> it should work...
12:54:39 <Cale> Philippa: well, what you lose there, you sort of make up for with some list definitions that don't correspond to loops in any obvious way
12:54:47 <monochrom> If it "didn't work" it's probably just because of buffering.
12:54:54 * Philippa nods
12:54:56 <Cale> _roconnor: I'm talking about join
12:54:58 <Philippa> there're certainly some fun ones
12:54:58 <astrolabe>  I think both functional and imperitive are natural in their own contexts.
12:55:03 <laurence> OK, then I screwed up somehow.  Hmm, maybe the buffer didn't flush--yeah, you said it too.
12:55:03 <palomer> monochrom: thx
12:55:12 <Cale> _roconnor: applying the completion again will result in an isomorphic space
12:55:12 <astrolabe> But thinking in fp is something good to aim at.
12:55:22 <laurence> OK, how do I flush stdout?
12:55:27 <Cale> _roconnor: when the join maps are all isomorphisms, it's not so interesting
12:55:34 <wolverian> yay, Data.Generics rocks
12:55:43 <_roconnor> Cale: Yep, but you gotta find the isomorphism.
12:55:47 <SamB> so how are the SoC apps coming?
12:55:47 <Cale> laurence: fFlush stdout
12:55:49 <xerox> wolverian: does it?
12:56:03 <laurence> Cale: Ah, thanks.  That makes some kind of sense.
12:56:05 <wolverian> xerox, yes. it does. :)
12:56:06 <Cale> laurence: or hSetBuffering stdout NoBuffering
12:56:10 <Fromage> Good evening
12:56:14 <Cale> laurence: hFlush, rather
12:56:30 * laurence is stunned to see a unix/C-ism in Haskell. :-)
12:56:32 <Fromage> I was wondering ... does Haskell have a predefined function to erase the duplicated items of a list ?
12:56:35 <monochrom> remember to "import IO(hFlush,stdout)"
12:56:49 <LordBrain> there is nub.. if the duplicates are adjacent
12:56:49 <Cale> Fromage: nub
12:56:54 * laurence was stunned this morning to find that ghc supports CPP.  Took a really stiff belt of coffee to recover.
12:56:59 <Fromage> What, Cale ?
12:57:07 <Fromage> Is nub an operator ?
12:57:09 <Cale> > nub [1,1,1,2,2,2,3,3,1,1,1]
12:57:10 <lambdabot> [1,2,3]
12:57:12 <Fromage> Let me check
12:57:14 <laurence> Thanks all.
12:57:20 <Cale> Fromage: it's in Data.List
12:57:27 <Fromage> > nub [1,1,1,1,3,3,3,4,5,5,6,6,5,4,4,4,1,1,1]
12:57:28 <lambdabot> [1,3,4,5,6]
12:57:31 <Cale> > (map head . group . sort) [1,1,1,2,2,2,3,3,1,1,1]
12:57:32 <lambdabot> [1,2,3]
12:57:35 <SamB> laurence: of course, never use it unless you have no other choice
12:57:37 <Fromage> Cale: 
12:57:38 <SamB> CPP, that is
12:57:41 <Fromage> Is in the prelude package ?
12:57:49 <Cale> Fromage: no, Data.List
12:57:50 <LordBrain> its in the List 
12:57:54 <Fromage> Damn ...
12:57:57 <LordBrain> import List
12:58:02 <Cale> or import Data.List
12:58:05 <Fromage> I can't use any other package than the standar prelude one
12:58:08 <Cale> if you want to be modern :)
12:58:12 <LordBrain> oh
12:58:13 <SamB> Fromage: use List, then
12:58:21 <Cale> Fromage: it's easy enough to write
12:58:23 <LordBrain> i didnt know i was un-modern
12:58:24 <SamB> that is standard
12:58:29 <monochrom> laurence: there is one unix/C-ism missing in Haskell, and that's buffer overrun.
12:58:41 <SamB> monochrom: really?
12:58:50 <SamB> monochrom: cause I thought you could do that easily
12:58:58 <laurence> SamB: Of course, I'd use something with understandable syntax and safe semantics, like m4.
12:58:59 <SamB> if you really wanted to ;-)
12:59:16 <SamB> laurence: m4?
12:59:16 <Fromage> SamB: 
12:59:16 <SamB> that is better?
12:59:17 <Fromage> Where is Data.List on my system ?
12:59:18 * SamB is sceptical
12:59:28 <Fromage> I think I'm gonna copy nub source code to my program directly
12:59:35 <Cale> LordBrain: The List module is in Haskell 98, but since hierarchical modules were introduced later, it was moved to Data.List
12:59:37 <monochrom> For example, if you go "getLine", you probably worry about poor performance or out-of-memory, but you just don't need to worry about being rooted.
12:59:38 <Fromage> To avoid the usage of external packages
12:59:45 <LordBrain> oh
12:59:46 <laurence> SamB: Yes.  Everyone agrees that autoconf rules are just a snap to write.
12:59:55 <SamB> anyway, if we use CPP we rarely use it for anything but the conditionals
12:59:56 <LordBrain> i'm still living in 1998
13:00:01 <Cale> LordBrain: It's still there in the implementations for compatibility, but probably won't be in Haskell'
13:00:11 <SamB> laurence: I do not believe you.
13:00:14 <LordBrain> i see... so its like deprecated?
13:00:39 <laurence> monochrom: I regard buffer overruns as my natural, Constitutionally protected right.  Fortunately, I believe I can exercise it through the FFI. :-)
13:00:54 * laurence quits yanking SamB's chain.
13:00:58 <Cale> LordBrain: slightly
13:01:13 <LordBrain> its like... to-be deprecated later potentially
13:01:16 <LordBrain> hehe
13:01:45 <Cale> yeah
13:01:55 <sjanssen> joelr1: I've replied to you on haskell-cafe
13:01:58 <laurence> SamB: I was kidding.  Of course the right way is to call 'ed' scripts in your makefile.
13:02:13 <SamB> laurence: heh
13:02:19 <monochrom> SamB: Yes, if one really wants to, one can write a water-tight program in unix/C-ism.  (Like, haskell can be translated into C too.)  But as to easiness, I refer you to the fact that buffer overruns have been plaguing us for more than two decades, and it is only until recently that they seem to have subsided.
13:02:23 <SamB> at very least, you need sed scripts ;-)
13:02:44 <Fromage> Cale: 
13:02:45 <laurence> SamB: I don't know, I find sed too clear. :-)
13:03:04 <Fromage> Where can I see Data.List source code, so that I'm able to directly copy it to my program =
13:03:12 <xerox> ?libsrc Data.List
13:03:12 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
13:03:14 <SamB> anyway, the best approach is to entirely avoid the need for any conditionals
13:03:16 <xerox> No...
13:03:17 <joelr1> sjanssen: thanks!
13:03:26 * laurence really tried to quit teasing SamB, honest.
13:03:30 <Cale> Fromage: you should probably write nub as an exercise
13:03:39 <Fromage> And ?
13:03:43 <Cale> Fromage: it's really pretty easy to do using filter
13:03:57 <Fromage> It's considered to be as a subset of the main exercise
13:03:58 <monochrom> Fromage: "import List(nub)" will get you nub.  It is standardized.
13:04:04 <SamB> Cale: filter?
13:04:09 <Fromage> I can't import anything within my program, monochrom 
13:04:10 <Cale> SamB: sure
13:04:14 <Fromage> It's a practical exercise for University
13:04:18 <SamB> > nub [1,2,1]
13:04:19 <lambdabot> [1,2]
13:04:21 <monochrom> INTERESTING!
13:04:30 <SamB> > nub [1,2,1,2]
13:04:31 <lambdabot> [1,2]
13:04:33 <xerox> Fromage: http://darcs.haskell.org/packages/base/Data/List.hs
13:04:34 <SamB> > nub [1,2,1,3]
13:04:35 <lambdabot> [1,2,3]
13:04:37 <Fromage> Thanks, xerox 
13:04:43 <monochrom> Heh, copy the code then :)
13:04:53 <Cale> let {nub [] = []; nub (x:xs) = x : nub (filter (/= x) xs)} in nub [1,2,1,3]
13:04:56 <SamB> doesn't filter give bad time complexity?
13:04:59 <Cale> > let {nub [] = []; nub (x:xs) = x : nub (filter (/= x) xs)} in nub [1,2,1,3]
13:05:00 <lambdabot> [1,2,3]
13:05:08 <norpan> SamB: there is no better way
13:05:10 <Cale> not any worse than nub already gives you
13:05:12 <monochrom> No, filter is fast enough.
13:05:17 <SamB> > nub [2,1,3]
13:05:18 <lambdabot> [2,1,3]
13:05:22 <SamB> oh
13:05:35 <SamB> I see
13:05:36 <norpan> unless you are allowed to sort the list or something else
13:06:01 <norpan> given only an Eq relation you really need O(n^2)
13:06:04 <SamB> remind me not to use nub
13:06:15 <monochrom> don't use nub!
13:06:36 <sjanssen> ah, nub will be fine for small lists
13:06:36 <SamB> or better, don't remind me that it is actually a function
13:06:44 <Cale> (map head . group . sort) is better when you have an ordering, and don't care about the order of your list
13:06:58 <int-e> > take 10 $ nub [1..]
13:06:59 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
13:07:04 <SamB> shouldn't there be a name for that, Cale?
13:07:13 <Cale> SamB: yes, but there isn't
13:07:14 <int-e> at least it's lazy.
13:07:26 <monochrom> If you know your list is sorted, don't use nub, too slow.
13:07:37 <Cale> > take 10 $ (map head . group . sort) [1..]
13:07:41 <lambdabot> Terminated
13:07:47 <Cale> :)
13:07:53 <SamB> we could at least say
13:07:55 <monochrom> sort is strict!
13:08:02 <palomer> @hoogle inf
13:08:03 <lambdabot> Prelude.infix :: keyword
13:08:03 <lambdabot> Prelude.infixl :: keyword
13:08:03 <lambdabot> Prelude.infixr :: keyword
13:08:05 <SamB> uniq = (map head . group)
13:08:13 <palomer> is there a typeclass with infinity?
13:08:14 <Cale> heh :: keyword
13:08:24 <monochrom> palomer you want an IEEE-754 infinity?  1/0
13:08:24 <LordBrain> hmmmm
13:08:29 <norpan> RealFloat
13:08:37 <SamB> @hoogle keyword
13:08:38 <lambdabot> No matches found
13:08:42 <SamB> aww!
13:08:56 <LordBrain> maybe haskell would benefit to have more ornaments in its naming convention
13:08:56 <norpan> at least it has isInfinite
13:08:57 <SamB> @hoogle Keyword
13:08:57 <lambdabot> No matches found
13:09:09 <monochrom> > isInfinite 1
13:09:10 <kosmikus> why would hoogle associate these keywords with the Prelude?
13:09:10 <lambdabot> False
13:09:14 <monochrom> > isInfinite (1/0)
13:09:15 <lambdabot> True
13:09:19 * monochrom dances
13:09:19 <SamB> LordBrain: such as gemstones?
13:09:22 <LordBrain> like null? instead of null for example...  and you could have an ornament for strict
13:09:31 <LordBrain> verses lazy
13:09:44 <norpan> what is an ornament?
13:09:47 <LordBrain> i dont know
13:09:49 <SamB> we have '
13:09:53 <Cale> LordBrain: it would steal away precious operator symbols though
13:09:54 <SamB> you can put ' at the end
13:10:08 <monochrom> It's hard to disambiguate "null? x" and "null ? x", LordBrain 
13:10:20 <LordBrain> good point
13:10:32 <monochrom> > let (?) f x = f x in null ? []
13:10:33 <lambdabot> True
13:10:35 <Cale> > let x ? y = x y in null? []
13:10:36 <lambdabot> True
13:10:39 <Cale> heh
13:10:44 <xerox> haha
13:10:45 <monochrom> But hey, it still works!
13:10:58 <sjanssen> > let nub s (x:xs) = if S.member x s then nub s xs else x : nub (S.insert x s) xs; nub s []  = [] in take 10 $ nub S.empty [1..]
13:10:59 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
13:11:10 <joelr1> is there a way to combine splitAt :: Int -> [a] -> ([a], [a]), unfoldr :: (b -> Maybe (a, b)) -> b -> [a] and elemIndex :: Eq a => a -> [a] -> Maybe Int into a cute one-liner to produce split?
13:11:24 <norpan> let nub = id in take 10 $ nub [1..]
13:11:29 <norpan> > let nub = id in take 10 $ nub [1..]
13:11:30 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
13:11:37 <Cale> > let nub = S.toList . S.fromList in nub [1,1,1,3,2,4,1,2,3,4,6,7,2,1,2,3]
13:11:38 <lambdabot> [1,2,3,4,6,7]
13:12:47 <SamB> Cale: is there anything I could be doing to increase my chances of getting picked for SoC? Like, anything I should have mentioned in my app?
13:13:00 <Cale> SamB: I really have no idea
13:13:13 <SamB> how honest ;-)
13:14:20 <monochrom> I forgot who wanted to split a string at comma points.
13:14:29 <joelr1> monochrom: here
13:14:37 <xerox> Oh, I had a splitBy.
13:15:17 <monochrom> break (== ',') "xxxx,yyyy,zzzz"  will do something for you.
13:15:30 <joelr1> no, that doesn't do it
13:15:42 <joelr1> i want a list of chunks ["xxx", "yyyy", "zzzz"]
13:15:51 <joelr1> this should probably be in a wiki somewhere
13:15:55 <xerox> splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:)
13:15:57 <monochrom> > break (== ',') "xxxx,yyyy,zzzz"
13:15:58 <xerox> There you go.
13:15:59 <lambdabot> ("xxxx",",yyyy,zzzz")
13:16:12 <monochrom> You can loop/recurse over break.
13:16:26 <int-e> > let nub = nub' S.empty; nub' _ [] = []; nub' s (a:as) = if a `S.member` s then nub' s as else a:nub' (S.insert a s) as in take 10 $ nub (2:[1..])
13:16:27 <lambdabot> [2,1,3,4,5,6,7,8,9,10]
13:16:29 <SamB> @wiki LicensedPreludeExts
13:16:29 <lambdabot> http://www.haskell.org/haskellwiki/LicensedPreludeExts
13:16:48 <monochrom> Unfortunately I'm pretty sure you have to do that yourself and the standard library doesn't have it.
13:16:58 <SamB> oh, wrong wiki!
13:17:09 <SamB> http://www.haskell.org/hawiki/LicensedPreludeExts
13:17:27 <int-e> SamB: @oldwiki does that :)
13:17:58 <SamB> anyway, splitBy is on there
13:18:16 <joelr1> that but does not split on a character 
13:18:28 <joelr1> and it looks big and not particularly elegant
13:18:31 <xerox> I like mine ^_^
13:18:35 <monochrom> use (== ',') as your predicate
13:18:42 <joelr1> xerox: what's yours?
13:18:48 <monochrom> or (/= ',')
13:18:51 <joelr1> xerox: i liked your count
13:18:53 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in ',' "mine,is,this,one"
13:18:53 <lambdabot> Couldn't match `Char' against `t -> t1'
13:18:56 <xerox> Ops.
13:19:02 <ChilliX> convert
13:19:07 <monochrom> Do you really need (c:) ?
13:19:08 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy ',' "mine,is,this,one"
13:19:09 <lambdabot> ["mine","is","this","one"]
13:19:14 <xerox> monochrom: yes.
13:19:34 <SamB> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy ',' "mine,is,this,one"
13:19:35 <lambdabot> ["mine","is","this","one"]
13:19:35 <joelr1> what is the meaning of (c:)
13:19:40 <joelr1> i learned to things today
13:19:48 <kosmikus> hi ChilliX 
13:19:48 <monochrom> It means the C drive.
13:19:52 <xerox> hahahaha.
13:20:17 <ChilliX> Hi kosmikus!
13:20:20 <Philippa> 'lo ChilliX, hope the stuff I spammed you last night wasn't too insane/sleep-deprived
13:20:21 * SamB is lagged
13:20:30 <monochrom> > ( 'x' : )  "abcde"
13:20:31 <lambdabot> "xabcde"
13:20:33 <ChilliX> Ooops, the above should have gone to another keyboard...
13:20:39 <monochrom> that's what (c:) does
13:20:43 * SamB closes Google Maps
13:20:57 <joelr1> that's the point notation again
13:21:11 <monochrom> No, it's the section notation.
13:21:22 <Philippa> joelr1: much like (1+)
13:21:31 <joelr1> xerox: how long did it take you to learn haskell? to do stuff like this?
13:21:35 <Philippa> "prepend c to something"
13:21:38 <ChilliX> Philippa: Hi! Not insane, but I didn't get it either ... ;)
13:21:39 <SamB> so what does (+1) mean?
13:21:45 <xerox> joelr1: can't say really...
13:22:00 <joelr1> in terms of years and months 
13:22:02 <joelr1> or just years
13:22:03 <xerox> joelr1: I worked on my SoC project last year after some months of hackery, but not too many.
13:22:03 <monochrom> (+1) y = y+1
13:22:14 <SamB> doesn't it increase the chance of a hit or something?
13:22:22 <int-e> > unfoldr (\l -> if null l then Nothing else Just $ break (==' ') $ tail l) " abc def ghi"
13:22:23 <lambdabot> ["abc","def","ghi"]
13:23:03 <Philippa> joelr1: it took me a few months (and my time's generally less productive than most people's) to have the general thought patterns, the rest's just picking up more specific idioms (knowing your way around particular data structures, say)
13:23:19 <monochrom> int-e is a master of unfold!
13:23:24 <int-e> (note that the first character is silently dropped. be careful.)
13:23:35 <xerox> @karma+ int-e -- Unfold-fu
13:23:35 <lambdabot> int-e's karma raised to 5.
13:23:48 <Philippa> SamB: (+1) is the same, because + doesn't care which way round its arguments are
13:24:23 <joelr1> Philippa: very interesting
13:24:30 <JohnMeacham> shapr: upgrade DrIFT to 2.2.0
13:24:56 <Philippa> joelr1: I learn fast but get code done slow, if that's relevant. I have fewer productive hours in a given period of time than most people
13:25:36 <franka> Hi, shapr.
13:25:54 <franka> And John and Philippa, of course.
13:25:56 <Philippa> and in fairness it took longer to be able to express why this problem's an unfold rather than a fold the way I did to you in PM. That kinda stuff you get from talking more than doing
13:25:59 <Philippa> 'lo franka
13:26:09 <orbitz> dons: there?
13:26:55 <joelr1> howdy
13:26:58 <SamB> oh, I figured out why the code to initialise the tape in my BF interpreter was so ugly -- I didn't write that!
13:27:21 <joelr1> SamB: BF?
13:27:21 <ChilliX> kosmikus: What are you up to?
13:27:44 <kosmikus> ChilliX: reviewing ...
13:27:45 <SamB> joelr1: http://www.haskell.org/hawiki/ShortExamples_2fBFInterpreter
13:28:05 <monochrom> boyfriend?  you need a boyfriend interpreter?
13:28:41 <Philippa> interpretBF _ = "I'm stupid"? ;-)
13:28:47 <LordBrain> is joelr1 still here, my tab complete isnt working
13:28:50 <monochrom> boyfriend: "I'm so tired!"  interpreter: "he means he is tired of the day job.  he does NOT mean he's tired of you!"
13:29:05 <kosmikus> ChilliX: I've only a few days ago returned from a 3-week trip to Japan (including the visit to FLOPS), and now there's not much time left to do all the MSFP and ICFP papers.
13:29:07 <joelr1> LordBrain: yes, hi
13:29:12 <LordBrain> hmm strange
13:29:18 <RyanT5000> my gf needs a bf interpreter when i start talking about haskell (she's learning C++ :-/)
13:29:32 <RyanT5000> <-- nerd
13:29:33 <monochrom> oh hahahaha now that's fun!
13:30:09 <SamB> wouldn't a Haskell interpreter be more appropriate?
13:30:10 <ChilliX> kosmikus: oh, ic
13:30:14 <ChilliX> How was FLOPS?
13:30:21 <RyanT5000> SamB: possibly
13:30:23 <LordBrain> joelr1: any time you have an infix operator, like +, for example, you can do partial applications with things like (1 +) and (+ 1)... that goes for : and . too
13:30:38 <RyanT5000> otoh maybe "Haskell" is just a type parameter of the bf interpreter
13:30:44 <joelr1> LordBrain: yeah, that . and : took me a while to grasp
13:30:54 <kosmikus> ChilliX: quite interesting, but a bit short.
13:30:57 <monochrom> girl: "the assignment says sum up the list, but don't write a for-loop"   boy: "wth, foldr (+) 0"   girl: "what did you say?"  boy: "nothing!"
13:30:59 <LordBrain> oh.. yeah i can understand that
13:31:02 <joelr1> this is almost silly
13:31:14 <RyanT5000> monochrom: lol exactly
13:31:18 <SamB> while loop!
13:31:31 <joelr1> i spent the whole day today trying to write half a page of code to read an file and join some lines and convert the whole thing into a map
13:31:35 <joelr1> arghh
13:31:37 <SamB> or, for extra bad performance, goto loop!
13:31:37 <RyanT5000> she finishes an assignment, and i'm usually like "look: i just wrote that whole thing in 1 line of haskell"
13:31:39 <ChilliX> kosmikus: It was close to Fujsi-san, right?
13:31:40 <kosmikus> ChilliX: and I talked to Martin about FDs and ATs ...
13:31:40 <RyanT5000> "and it's point-free"
13:31:43 <int-e> we usually prefer foldl' (+) 0 though :)
13:31:47 <ChilliX> Although a bit too late for cherry blosoms, I guess
13:31:48 <RyanT5000> at which point she says "what's point-free?"
13:31:50 <monochrom> Actually I mean don't write any loop, and the idea is to use accum in STL
13:31:51 <joelr1> i would have had it done in lisp early this morning
13:32:00 <joelr1> why do i persist?
13:32:14 <SamB> point-free means you didn't have to name any variables ;-)
13:32:19 <kosmikus> ChilliX: yes, it was very close. and we picked the only day with good view for an excursion to the mountain. really nice planning ;)
13:32:24 <RyanT5000> SamB: i know that :P
13:32:32 <Fromage> Hello
13:32:43 <Philippa> joelr1: the feeling that when you've got enough practice it'll all suddenly turn into something really cool?
13:32:43 <RyanT5000> but they don't exactly teach that in first-semester CS
13:32:55 <SamB> hehe
13:33:06 <LordBrain> a working haskell program is really cool
13:33:07 <kosmikus> ChilliX: well, the conference was too late. but when Clara and I arrived, there still was cherry blossom in Tokyo, and when we went to Kyoto one week later, we had cherry blossom, too; so we were actually quite lucky
13:33:14 <Fromage> I'm trying to build a function which is able to evaluate wheter a group of given lists have all the same length
13:33:17 <LordBrain> satisfying
13:33:29 <monochrom> joelr1: because you are learning. everyone goes through that.
13:33:32 <ChilliX> kosmikus: Cherry blosoms in Kyoto ist the best!
13:33:33 <LordBrain> kinda like math
13:33:42 <ChilliX> Did you go to one of the temples at night?
13:33:44 <joelr1> i guess so
13:33:54 <joelr1> and i used to be ok at this just three months ago
13:34:04 <LordBrain> i'm in the same boat joelr1.. and why does my tab complete not see you
13:34:06 <joelr1> well, allright 4 months
13:34:16 * joelr1 is invisible
13:34:21 <Philippa> you do kinda have to do it more regularly at a time for it to stick in, sadly
13:34:25 <kosmikus> ChilliX: no, on our main day in Kyoto we had lots of rain
13:34:27 <LordBrain> oh because of your irc mode?
13:34:41 <joelr1> LordBrain: no, i was kidding
13:34:50 <monochrom> lisp does not exactly encourage higher-order functions and all that, so knowing lisp doesn't buy you much with haskell.  probably the only leg up is lists.
13:34:54 <Philippa> there's almost a storage hierarchy in memory, except the checks aren't whether to cache, they're whether to store longer-term or throw out
13:34:56 <LordBrain> it just worked.. for the first time.. i dont get it.. did you change something?
13:35:23 <Philippa> monochrom: mind if I quote that next time I see someone I got into an argument with about whether lisp's a functional language?
13:35:40 <monochrom> My own path of FP learning was lisp-sml-haskell, so mine was smoother but also took twice as long.
13:35:47 <monochrom> Please quote me!
13:35:57 <kosmikus> ChilliX: I heard you're in NY currently?
13:35:58 <LordBrain> mine was ocaml-scheme-haskell
13:36:04 <ChilliX> kosmikus: What a pity.  Some temples are open at night during cherry blossoms and some of the gardens are spectacular
13:36:06 <joelr1> well, i'm ok with both lisp and erlang and erlang is positively functional but haskell is way hard
13:36:10 <SamB> so how many people have applied for SoC so far?
13:36:14 <ChilliX> kosmikus: Yep :)
13:36:15 <sjanssen> @remember monochrom  Please quote me!
13:36:15 <lambdabot> Unknown command, try @list
13:36:23 <xerox> I came from lisp too, Scheme in particular.  No sml fortunately.
13:36:25 <norpan> haskell is not hard
13:36:30 <norpan> haskell is cool
13:36:39 <LordBrain> i find scheme is easy to type... not as pleasant to read.. and of course it lacks a lot of goodies
13:36:52 <kosmikus> ChilliX: yes, people told us (about the temples); maybe next time :)
13:37:06 <norpan> it's just that people that have used other languages try to use their knowledge of them
13:37:20 <norpan> and that makes it often harder than it really is
13:37:24 <ChilliX> kosmikus: Going to be in NY for the rest of teh year.
13:37:34 <LordBrain> i think scheme is a much lower hurdle tho.. an easier language... 
13:37:46 <SamB> yeah, scheme is quite easy to type ;-)
13:37:48 <monochrom> scheme is much better
13:37:59 <SamB> everything is of type Scheme
13:38:03 <SamB> or something like that
13:38:06 <kosmikus> ChilliX: oh, that's quite a long time. do you have a sabbatical?
13:38:44 <ChilliX> Yeah, kind of.
13:38:45 <joelr1> i just wrote a whole paragraph of comments to remind myself how Cale's fixLines works :D
13:38:45 <monochrom> norpan: I agree.  My learning habit includes forgetting what I already know, so I learn faster.
13:38:47 * laurence mangles Haskell until it obeys.
13:38:51 <joelr1> just in case, you know
13:39:08 <monochrom> well, not forgetting, but rather, putting aside and not assuming.
13:39:09 <ChilliX> kosmikus: Gabi is working for Credit Suisse for a year - hacking Haskell!
13:39:24 <joelr1> who's Gabi?
13:39:25 <LordBrain> well some of the same qualities which  make it nicer on my typing fingers, the use of just one kind of brace in particular ().. also make it less readable in my view
13:39:31 <kosmikus> ChilliX: that's great
13:39:34 <norpan> and people want mutable objects because they think it's faster and they want global variables and stuff like that
13:39:37 <joelr1> and i didn't know they hacked haskell at CS
13:39:46 <Philippa> norpan: if you don't need the history, it *is* faster
13:39:57 <joelr1> my daughter's name is gaby
13:40:13 <Cale> All the projects I've seen you use Haskell for have been either performance-critical, or working with huge amounts of data. Have you attempted anything which was perhaps algorithmically complicated, but smaller in terms of resource requirements?
13:40:19 <joelr1> i wonder if she'll grow up liking haskell 
13:40:20 <joelr1> hehe
13:40:21 <Philippa> people use the ST monad even when a monomorphic heap'd do, there's a reason for that
13:40:22 <kosmikus> ChilliX: couldn't you have arranged this to take place in .ch, though?
13:40:27 <ChilliX> joelr1: Lennart Augustsson hacks Haskell here at CS in NY atm, too.
13:40:32 <norpan> Philippa: it doesn't matter if it *is* faster or not, what matters is that they want them because they *think* they are faster :)
13:40:39 <SamB> joelr1: you know, like, hobby programming?
13:40:50 <joelr1> Cale: this is excellent advice :-) akin to saying that i'm setting myself up for failure :D
13:40:51 <Philippa> norpan: it's relevant that they think so correctly though
13:40:55 <lesshaste> is it possible to implement dijkstra's shortest path algorithm in haskell without using arrays and still get the right time complecity?
13:40:57 <lesshaste> complexity
13:40:58 <ChilliX> gabi: http://www.cse.unsw.edu.au/~keller/
13:41:10 <sjanssen> lesshaste: nope
13:41:15 <norpan> Philippa: even if the conclusion is correct, which it not always is, the reasoning may be incorrect
13:41:36 <joelr1> so credit suisse is like the hotbed of haskell programming at the moment
13:41:41 <lesshaste> sjanssen, can you tell me more :)
13:41:47 <sjanssen> lesshaste: actually, what do you mean by correct time complexity?
13:41:53 <Philippa> norpan: it's not as often as you might expect though. Tail-recursive stuff doesn't usually end up implemented by destructive update in haskell
13:41:57 <joelr1> Cale: i'm waiting to do something like that but haven't got a project for it yet
13:42:01 <ChilliX> kosmikus: the people who work on this software system are in NY
13:42:04 <Cale> joelr1: it's just that heavy resource management is a bit tougher in Haskell than it might be in something lower level, at least for a beginner
13:42:19 <sjanssen> lesshaste: the optimal (with a Fibonacci heap) Dijkstra's requires pointers into the heap
13:42:24 <palomer> what latex packages do you guys use for your proof trees?
13:42:26 <Cale> dons might have an easy time of it, but...
13:42:28 <Cale> :)
13:42:31 <ChilliX> joelr1: you got anything to do with them?
13:42:36 <Philippa> joelr1: if you get an interpreter style project, haskell is very much your friend :-)
13:42:39 <norpan> Philippa: are you trying to teach me something here, because that's not the point of my comment, the point is that people apply faulty reasoning because they are used to other paradigms
13:42:43 <joelr1> ChilliX: no, i worked everywhere _but_ CS
13:42:51 <joelr1> i did interview at CS once, though
13:43:03 <Philippa> norpan: my point is that while that's true, many of the counterarguments to that are as misleading in the other direction
13:43:13 <lesshaste> sjanssen, ok.. and also with binary heaps too?
13:43:14 <sjanssen> lesshaste: using Data.Map as a priority queue, and Array Int [Int] as your graph datastructure should be fairly quick, and pretty simple to write
13:43:19 <joelr1> i was thinking of producing a scheme to program a nintendo ds or something like that
13:43:23 <joelr1> in haskell
13:43:35 <Philippa> ooh, that could be fun
13:43:43 <RyanT5000> i also have that idea :)
13:43:56 <RyanT5000> my game + ds + wifi = awesome :)
13:43:57 * joelr1 worked at Bear, UBS, Merrill, DB, Morgan ... that's about it
13:44:00 <SamB> Cale: can you think of anything I *might* be able to improve about my app?
13:44:19 <lesshaste> sjanssen, thanks... seems it's a little tricky to do without mutability
13:44:20 <SamB> oh, do we Haskell on NXT yet?
13:44:21 <joelr1> RyanT5000: you can do that now, just in c/c++
13:44:35 <assassin> Is there a modulo operator in haskell?
13:44:40 <RyanT5000> yeah except the game isn't written, and i'm only going to try for DS once i have a profitable game
13:44:46 <norpan> assassin: yes, it's called mod
13:44:46 <psi> assassin: mod
13:44:47 <Cale> assassin: `mod`
13:44:47 <RyanT5000> assassin: `mod`
13:44:50 <norpan> hehe
13:44:52 <Cale> heh
13:44:53 <RyanT5000> wow :)
13:44:54 <SamB> +have
13:44:54 <assassin> hehe... thanks all
13:44:55 <ChilliX> kosmikus: so, I don't have to teach this year, but concentrate on research :)
13:45:00 <lesshaste> sjanssen, there is a method here :) http://www.informatik.uni-bonn.de/~ralf/publications/ICFP01.pdf
13:45:01 <monochrom> `mod` and `rem`.  `rem` is prefered.  5 `rem` 3  try that.
13:45:07 <sjanssen> lesshaste: optimal is impossible, but O(E log E) or something like that isn't too hard purely functionally
13:45:10 <norpan> but rem is not mod
13:45:14 <monochrom> 5 `rem` 3 = rem 5 3
13:45:21 <Cale> monochrom: rem is preferred?
13:45:24 <RyanT5000> > rem 5 3
13:45:25 <lambdabot> 2
13:45:26 <norpan> so if he wants modulo, mod is prefered
13:45:28 <palomer> > -5 mod 2
13:45:29 <lambdabot>  add an instance declaration for (Num ((a1 -> a1 -> a1) -> t -> a))
13:45:30 <Cale> > rem (-5) 3
13:45:31 <lambdabot> -2
13:45:32 <palomer> > -5 `mod` 2
13:45:33 <lambdabot> -1
13:45:37 <RyanT5000> ah
13:45:37 <LordBrain> why is rem preferred?
13:45:37 <SamB> > map (`mod` 3) [-10..10]
13:45:39 <lambdabot> [2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]
13:45:40 <Cale> > mod (-5) 3
13:45:41 <lambdabot> 1
13:45:43 <monochrom> Right, they are different, but it turns out the semantics of rem is the one people want when they say "mod".
13:45:45 <lesshaste> sjanssen, ok... that's very interesting O(ElogE) is fine especially if the code is nice
13:45:52 <kosmikus> ChilliX: very good. I expect at least two submissions for the HW then ;)
13:45:53 <SamB> > map (`mod` 3) [-10..10]
13:45:54 <lambdabot> [2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]
13:46:00 <SamB> oops.
13:46:03 * palomer prefers `med`
13:46:07 <lesshaste> sjanssen, do you have any tips on how to achieve that?
13:46:07 <SamB> I said the same again!
13:46:10 <palomer> or `rod`
13:46:11 <SamB> > map (`rem` 3) [-10..10]
13:46:12 <lambdabot> [-1,0,-2,-1,0,-2,-1,0,-2,-1,0,1,2,0,1,2,0,1,2,0,1]
13:46:13 <Cale> > map (`rem` 3) [-10..10]
13:46:14 <lambdabot> [-1,0,-2,-1,0,-2,-1,0,-2,-1,0,1,2,0,1,2,0,1,2,0,1]
13:46:25 <monochrom> Alright, I hang my head in shame!
13:46:38 <Cale> hehe
13:46:44 <kosmikus> ChilliX: and tell Lennart to write something, too :)
13:47:06 <SamB> I'm pretty sure most people who say "mod" want mod ;-)
13:47:14 <SamB> or aren't thinking about negatives at all
13:47:23 <monochrom> But I miss the Pascal one which yields [-1,0,1,-1,0,1,...]
13:47:24 <LordBrain> yeah
13:47:26 <ChilliX> kosmikus: so far, we have only got one thing lined up
13:47:42 <sjanssen> lesshaste: perhaps start with yanking the data structure from that paper
13:47:44 <ChilliX> and dons has to do some more hacking before we can write
13:47:56 <lesshaste> sjanssen, ok thanks
13:48:22 <sieni> > map (`mod` 3) $ map (`rem` 3) [-10..10]
13:48:23 <lambdabot> [2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1]
13:48:40 <ChilliX> kosmikus: so kick him, when you see him ;)
13:50:20 <norpan> maybe i should finish that ByteString.UTF8
13:50:34 <kosmikus> ChilliX: yes, I will ...
13:50:36 <norpan> i'm only using a few functions, but perhaps it's of interest to others
13:51:10 <norpan> the question is, should I add to the datatype to make length O(1)
13:51:46 <musasabi> shapr: yes, want info. Can you mail me 1) jhc --self-test, --version and --version-context outputs.
13:51:54 <musasabi> shapr: ekarttun at cs helsinki fi
13:51:59 <musasabi> -> away
13:52:38 <ChilliX> kosmikus: Our aim is to produce the world's fastest polymere formation simulator using generative programming in Haskell.
13:52:53 <norpan> that sounds like a daunting task
13:54:39 <RyanT5000> is there any reasonable way to emulate C++'s typedefs-within-template-classes in haskell?
13:54:53 <RyanT5000> or would that even be reasonable to do if you could
13:55:15 <mahogny> RyanT5000, dependent types?
13:55:19 <palomer> > map ((`mod` 3) *** ((`mod` 3) . (`rem` 3))) (zip [-10..10] [-10..10])
13:55:20 <lambdabot> [(2,2),(0,0),(1,1),(2,2),(0,0),(1,1),(2,2),(0,0),(1,1),(2,2),(0,0),(1,1),(2,2),(0,0),(1,1),(2,2),(0,0),(1,1),(2,2),(0,0),(1,1)]
13:55:30 <mahogny> RyanT5000, data Foo a = -- use datatype a here
13:55:42 <ChilliX> RyanT5000: That's be associated types
13:55:53 <monochrom> ChilliX beats me to it.
13:55:53 <RyanT5000> ah ok
13:56:02 <RyanT5000> i think that's more like it
13:56:22 <monochrom> I had to attend to the door, but otherwise I would have been able to say "ChilliX would tell you about associated types"  XD
13:56:31 <RyanT5000> :P
13:56:33 <ChilliX> hehe
13:57:09 <RyanT5000> well i'll have to learn about them some time,  but that time is not right now (despite the fact that i just asked :P)
13:57:14 <ChilliX> Only problem is that we haven't implemented them in GHC yet.  (It will happen, but before that the plan is to revise the GHC's intermediate language somewhat.)
13:57:31 <RyanT5000> ah
13:59:29 <Cale> Associated types are equivalent to functional dependencies
13:59:32 <Cale> and those are in GHC
13:59:49 <RyanT5000> oh god; i've seen this argument before :)
13:59:56 <franka> Is ChilliX Manuel Chakravarty?
14:00:28 * ChilliX hides in anonimity.
14:00:48 <ChilliX> modulo spelling
14:00:58 <franka> My apologies.
14:01:03 <franka> It is nice to see you here.
14:01:16 <ChilliX> Just joking
14:01:27 * mahogny finally realises whos paper he is currently reading ;)
14:01:28 <ChilliX> :)
14:01:39 <ChilliX> I have been here on and off.
14:02:04 <SamB> RyanT5000: I think this is not the same argument
14:03:23 <Cale> argument?
14:03:32 <franka> I think I added you as a friend or something on Freshmet quite a long time ago.
14:03:41 <franka> Freshmeat
14:04:49 <ChilliX> Somehow I got out of the habit of vising freshmeat much.
14:04:56 <ChilliX> visiting
14:05:17 <franka> Indeed, me too.  I have mostly cured myself of that habit, though.
14:06:00 <franka> Oh, I read "out" as "in".
14:06:25 <franka> And mentally added a "too".  Nevermind.
14:06:51 <RyanT5000> SamB: true, but it could have become that argument if the right people had seen Cale's assertion :P
14:07:08 <SamB> RyanT5000: what would they have argued?
14:07:23 <ChilliX> franka: So. what are you up to these days?
14:07:34 <RyanT5000> that while, from a theory perspective, the two are equivalent, they do not express equivalent concepts, and therefore are not equivalent wrt the programmer
14:07:58 <franka> ChilliX: I work at CWI on something completely different.
14:08:23 <Cale> RyanT5000: sure, I agree with that. But then the original point was to find a Haskell equivalent to a C++ feature, so that's sort of another thing altogether
14:08:36 <ChilliX> oh, ic - what is it that you do at cwi?
14:08:54 <SamB> ChilliX: do you use AIM a lot?
14:09:08 <franka> It is a project called Trust4All, to do with trusted computing and embedded systems.
14:09:28 <franka> Unfortunately, they will do anything to avoid program analysis.
14:09:33 <RyanT5000> Cale: yeah, i'm not disagreeing with you
14:10:44 <franka> So "trusted" means mostly: here is some software, and here is some specs, and I promise that the software obeys this spec, but I will not prove it to you.
14:10:46 <ChilliX> So, what drew you to the project?
14:11:05 <franka> ChilliX: My ex-colleague Dave Clarke is in the same group.
14:11:17 <Philippa> franka: "I trust you, therefore I won't insist on verifying what you say"?
14:11:19 <SamB> that sounds like Code&Pray to me
14:11:23 <franka> Also, I needed a source of income to finish my Ph.D. :)
14:12:13 <franka> Philippa: Yes.  It is somewhat mitigated by the fact that the user can say what he means by "trust".  Imagine a slider denoting a threshold.
14:12:18 <ChilliX> franka: :)
14:13:08 <ChilliX> franka: say hi to Dave.  (His desk used to be right in front of my office door at UNSW.)
14:13:13 <RyanT5000> doveryay, no proveryay
14:13:15 <franka> It has it's good points, though.  You get to see how people in the industry think about things.  We work with Philips and Nokia.
14:13:45 <franka> ChilliX: I will give him your regards.  Indeed, I thought you might know him.
14:14:39 <franka> I will say that what CWI is doing is a cut above what I think the rest imagine.
14:15:00 <franka> We are using model checking to build test traces to refute models.
14:15:50 <franka> So, given a spec, we plan to generate a program which can be used to test whether the model actually models the what it claims.
14:16:09 <ChilliX> ok, ic
14:16:09 <mahogny> you mean an observer?
14:16:47 <franka> I don't know what you mean by "observer".
14:17:08 <franka> There is a library, and a spec for it.  The generated program uses the library, and you can observe the results to see if they match the spec.
14:17:28 <franka> In that sense you could say an observer is involved.
14:17:37 <mahogny> well. that's it been called in my courses on theorem proving. if the property you want to check spans over time, you need to build something that can observe it over time to check the property
14:18:09 <RyanT5000> franka: could you generate an intermediate library that  checks the spec while the library's running in a real app? sort of like debug asserts
14:18:28 <ChilliX> mahogny: Do you mean a reference monitor?
14:18:40 <mahogny> ChilliX, heard that name too
14:18:54 <franka> mahogny: Given a model, you supply a property, and the model checker checks if the property holds of the model.  If not, it spits out an error trace.  The trace is converted to a program. The program is run to see if it matches the model.
14:19:27 <mahogny> franka, which language do you guys write your programs in?
14:19:52 <franka> RyanT5000: Um... I dunno.  Possibly.
14:20:14 <franka> mahogny: We mostly do not write programs.  :)
14:20:15 <RyanT5000> maybe that's not as useful as what you're describing
14:20:20 <mahogny> franka, aha :)
14:20:43 <franka> mahogny: However, the middleware is in C, and most of the programs that run on it will be in C.
14:21:17 <mahogny> RyanT5000, when you write these kind of programs (reference monitors), it is half because writing the condition for the assert is hell
14:21:39 <mahogny> RyanT5000, some languages make it easy though
14:21:48 <franka> I guess the interesting part for our group is that the programs are concurrent processes that commuicate via channels, and run on heterogeneous multiprocessors.
14:21:57 <RyanT5000> mahogny: that's why i was thinking that if you could automatically generate an assert library, it'd be kind of cool
14:22:35 <mahogny> RyanT5000, I don't think it would be much less work though
14:23:04 <franka> The mathematical machinery for concurrency is fairly well-adapted to imperative programs, so it being in C is not a major headache (given the low expectations for what is provable of such things).
14:24:17 <mahogny> hm. several processes... I've never tried reference monitors for such a beast. I can imagine the monitor itself is complex enough to have bugs
14:24:33 <franka> RyanT5000: The properties we have in mind are global properties of the system.  I would have to think about whether they can be adapted to local properties of individual procedures.
14:25:09 <mahogny> franka, have you tried sequential programming?
14:25:31 <franka> What do you mean by sequential programming?
14:26:13 <mahogny> well, Lustre is the language I have tried for it. your variables are infinite sequences built by induction. so you can prove properties quite easily with simple induction, even though the code is extremely imperative
14:26:38 <franka> Oh, I understand that as dataflow programming.
14:26:46 <franka> I would think you would use coinduction not induction there.
14:26:57 <mahogny> same thing for me :)
14:27:19 <mahogny> it was really nice to write temporal property checks with it. with some notable exceptions when I ended up verifying the reference monitor using the implementation :P
14:27:21 <franka> Actually at one point I tried to come up with a dataflow language for channels.
14:27:28 <franka> But it is not a priority right now.
14:27:49 <franka> The sorts of properties we are most interested in actually are quality-of-service ones.
14:27:54 <mahogny> ah
14:28:09 <franka> We get them by assigning "costs" to transitions in the automata associated to components.
14:28:10 <mahogny> hard QoS or just benchmarks?
14:28:12 <franka> In the models.
14:28:44 <franka> Well, hard QoS, if I understand you correcly.
14:28:51 <mahogny> ok
14:28:54 <LordBrain> ok.. when using a map to do something like a for-each, i came to an error having to do with the inferred type not matching the expected one... i'm inside a do... and i need to do IO inside this loop
14:29:32 <mahogny> LordBrain, mapM or similar allows you to send in IO
14:29:46 <palomer> LordBrain: paste the code and the error in a pastebin
14:30:24 <Cale> @type mapM
14:30:25 <LordBrain> ok... give me a sec... let me see if i can figure it out by switching to mapM
14:30:25 <lambdabot> forall b (m :: * -> *) a.
14:30:25 <lambdabot>    (Monad m) =>
14:30:25 <lambdabot>    (a -> m b) -> [a] -> m [b]
14:30:28 <palomer> how would liftM look like when written from scratch?
14:30:44 <davidhouse_> palomer: liftM f m = m >>= return . f
14:30:49 <Cale> liftM f x = do v <- x; return (f v)
14:31:07 <palomer> righto
14:31:20 <davidhouse_> whenever you find yourself writing a "return" on the RHS of a >>=, think liftM.
14:31:33 * davidhouse_ wishes liftM was preluded
14:31:42 <Cale> davidhouse_: it i
14:31:42 <Cale> s
14:31:45 <palomer> isn't anyone puzzled that there is no function (MonadTrans t, Monad m) => (m a -> m b) -> t m a -> t m b?
14:31:48 <Cale> It's called fmap :)
14:31:50 <franka> Isn't that just fmap for a functor which is a monad?
14:31:55 <davidhouse_> yes, well.
14:32:01 <davidhouse_> franka: all monads are functors
14:32:02 <franka> OK.
14:32:15 <davidhouse_> liftM = fmap for monads, but functors are more general
14:32:18 <franka> My condition was the reverse.
14:32:41 <davidhouse_> palomer: you could make it quite easily with lift
14:32:49 <Cale> davidhouse: you could?
14:32:51 <palomer> davidhouse_: how?
14:32:56 <davidhouse_> could you not?
14:33:01 <mwc> I wish that Haskell's where was more like sml's local ... in ... end
14:33:08 <davidhouse_> (is a MonadTrans something like ReaderT?)
14:33:16 <palomer> sure
14:33:20 <Cale> mwc: in what way?
14:33:34 <mwc> Cale, in being able to use the bindings introduced in where in all the cases of a pattern match
14:33:46 <davidhouse_> @hoogle lift
14:33:46 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
14:33:47 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
14:33:47 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
14:34:08 <Cale> mwc: ah, it does happen to scope over guards though
14:34:17 <mwc> Yeah
14:34:21 <mwc> that's how I'm faking it right now
14:34:29 <davidhouse_> palomer, how about m >>= lift . f
14:34:41 <Cale> mwc: you could also just use case
14:34:44 * davidhouse_ can't remember of the top of his head how <- works with transformers)
14:34:44 <mwc> well, actually, I'm using cases instead of pattern matching in the function itself
14:34:45 <mwc> but still
14:34:47 <franka> As I recall, not making Monad a superclass of Functor was an omission in the Report.
14:34:50 <davidhouse_> i don't think that would work, actually.
14:34:58 <davidhouse_> franka, subclass.
14:35:03 <Cale> franka: It was intentional
14:35:13 <franka> Er, subclass.
14:35:14 <palomer> davidhouse: MonadTrans m is a monad
14:35:36 <Cale> palomer: ?
14:35:57 <davidhouse_> Cale, happen to know if the Eq and Show constrictions are being lifted in Haskell'?
14:36:05 <davidhouse_> sorry, the Eq and Show limitations on Num
14:36:09 <franka> Cale: Perhaps it was intentional for some, and not noticed by others.  I recall someone saying they overlooked it on the list.
14:36:13 <Cale> davidhouse: I don't know, but I hope so
14:36:22 <palomer> Cale: he was asking how <- works with monad transformers
14:37:11 <Cale> franka: Without some mechanism for defining ways to automatically derive superclass instances, I can see how it might be wise to leave them separate.
14:37:16 <davidhouse_> @type lift return
14:37:17 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a.
14:37:17 <lambdabot>      (MonadTrans t, Monad m) =>
14:37:17 <lambdabot>      t ((->) a) (m a)
14:37:29 <davidhouse_> @type lift . return
14:37:30 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a.
14:37:31 <lambdabot>       (MonadTrans t, Monad m) =>
14:37:31 <lambdabot>       a -> t m a
14:38:44 <franka> Cale: I can imagine coming up with some mechanism as arbitrary as the ones for Ord, etc. for Functor.
14:38:47 <davidhouse_> palomer: perhaps this is why there is no such function ;)
14:38:58 <palomer> but, erm, it should exist!
14:39:05 <franka> And similarly for Monad, even, for parametric types, at least.
14:39:12 <palomer> I mean, its non
14:39:17 <palomer> non-existence is troubling
14:39:30 <franka> The derived instances of Eq, Ord and so on are certainly not the only ones you can imagine.
14:40:50 * palomer leaves
14:42:16 <franka> OTOH, it would be more natural to derive Functor and Monad if datatype declarations were given in terms of explicit recursion and "pattern functors".
14:43:03 <Cale> palomer: ([a] -> [b]) -> (ContT [] a -> ContT [] b)
14:43:18 <Cale> I somehow doubt that's doable.
14:44:45 <Cale> franka: Oh, I'm not proposing to derive Monad, I'm proposing to derive an instance of Functor given an instance of Monad
14:45:19 <Cale> i.e. just the trivial  fmap = liftM
14:45:40 <jip> i have a question about monads. "IO ()" seems kind of a hack to me for describing 'actions' that only perform side effects without producing a result. would it be possible to use GADT for the IO monad type so that there is a seperate constructor for 'actions' that don't produce a result?
14:46:15 <franka> Cale: That sounds backward to me.
14:46:20 <SamB> jip: not really
14:46:22 <Cale> jip: GADT's don't remove the issue of kinds.
14:46:49 <jip> hm... so what kind of type system is needed then?
14:46:55 <Cale> franka: but sometimes it's what you want. After all, if you can define return and >>=, you get fmap for free.
14:47:02 <franka> Cale: Though reasonable.
14:47:17 <franka> Yes, it is what you want.
14:47:27 <Cale> It's just nice to have that option
14:47:41 <Cale> It would also be nice to have the option to only define fmap, return and join
14:47:41 <franka> But that is not what I would call "deriving".
14:48:06 <Cale> franka: sure, it's really weak, but it would be enough to get rid of that problem
14:48:19 <franka> To me, "deriving" classes is some kind of introspection.
14:48:26 <Cale> jip: why does it seem like a hack?
14:48:53 <franka> Cale: Yes, it would address that problem, I agree.
14:49:04 <jfoutz> @pl \x y -> x + (abs y)
14:49:05 <lambdabot> (. abs) . (+)
14:49:16 <jip> Cale: for some reason any use of () gives me the jeebies. i get the feeling that a useless type shouldn't be used
14:49:31 <Cale> jip: it's not useless if it has a use
14:49:38 <jfoutz> @pl \x y -> (abs x) + y
14:49:39 <lambdabot> (+) . abs
14:50:07 <Cale> jip: It's sort of like the identity function
14:50:11 <kosmikus> () isn't useless; that's like saying that 1 is a useless number.
14:50:19 <jfoutz> @pl \x y -> (abs x) + (abs y)
14:50:20 <lambdabot> (. abs) . (+) . abs
14:50:28 <franka> Uselessness is useful.
14:50:31 <Cale> hehe
14:50:38 <mahogny> kosmikus, I think 0 is a better comparison :)
14:50:40 <franka> It is called weakening in logic.  It is essential.
14:50:49 <Cale> Or the identity monad -- it gets used with monad transformers to construct useful monads.
14:50:57 <mahogny> it took a long time to come with 0. I dunno if it took equally long time to invent () :)
14:51:09 <kosmikus> mahogny: I was thinking about using 0, but () is the unit type after all ...
14:51:18 <jip> i just think that "IO ()" isn't really semantically correct... whatever that is supposed to mean i suppose
14:51:43 <Cale> Well, it's exactly what it is
14:51:49 <Philippa> it yields a return value of type (), which effectively indicates success or not-being-_|_
14:52:11 <Cale> return undefined :: IO ()
14:52:16 <SamB> its like "void" in C.
14:52:17 <Philippa> (or to put it another way, "yay, managed to evaluate without invoking undefined behaviour!")
14:52:22 <Philippa> no, it's not like void in C
14:52:24 <franka> Side effects are politically incorrect.  So something which does only a side effect is politically inexcusable.  Is that what you are saying?
14:52:27 <Philippa> you can't do /anything/ with void in C
14:52:30 <mahogny> void is very different
14:52:37 <Cale> void in C has no values in it
14:52:38 <SamB> well, only you can pass it around
14:52:47 <Cale> () has one non-bottom value
14:52:50 <kosmikus> and () has two values in it
14:52:57 <jip> franka: no, i think that the use of "IO ()" is fine, i just think it should have some other sort of name
14:53:18 <Cale> jip: you could use a type synonym if it really bothers you
14:53:18 <franka> A rose by any other name would smell as sweet.
14:53:24 <franka> And the same goes for garbage. :)
14:53:32 <mahogny> jip, either you live with () or you have to extend the syntax, language and lots of evilness. you prefer () really
14:53:40 <Cale> type IOWhichReturnsNothing = IO ()
14:53:44 <mahogny> omg
14:53:45 <mahogny> lol
14:53:45 <jip> here's a more practical question though: we have readIORef, writeIORef and modifyIORef. we have readArray and writeArray. how come we don't have modifyArray?
14:53:47 <SamB> well, if you call a function that returns void, it either crashes (which is like _|_) or doesn't (which is like ())
14:54:06 <monochrom> f :: IO ()   I would call f a "procedure" as in procedures in imperative programs.
14:54:11 <jip> Cale: yeah, that's a little better, but it only hides the underlying problem, it doesn't solve it
14:54:21 <Cale> jip: I don't see the problem
14:54:26 <sieni> there is no underlying problem
14:54:44 <jip> right, there's no problem, i'm just wondering if it's possible to do things another way
14:54:51 <SamB> jip: our programs work -- I fail to see a problem
14:54:52 <jip> maybe arrows are what i am thinking of?
14:54:52 <Cale> jip: we have mapArray
14:54:59 <franka> type Action = IO ()
14:55:11 <franka> Does that solve your problem?
14:55:23 <Cale> franka: I proposed that, he didn't like it :)
14:55:32 <jip> Cale: i'm actually interested in modifying the value of one element in one shot, without having to do readArray + writeArray
14:55:48 <monochrom> I am glad I grew up in an era of Pascal.  We had different, appropriate names for different things.  Unlike today's culture in which "everything is a function (C)" or "everything is a class/object (Java)".
14:56:08 <SamB> jip: I don't think that that is possible with modern hardware
14:56:13 <jip> monochrom: in basic we call those "statements" :D
14:56:30 <Cale> SamB: he just means in code, not in implementation
14:56:31 <mahogny> monochrom, assembler, everything is bytes!
14:56:31 <SamB> or at least, wise...
14:56:36 <Cale> it's easy enough to write one
14:56:54 <monochrom> that's good too.  (until you want compound statements *and* your version of basic doesn't actually treat that well)
14:56:56 <jip> Cale: yeah, but it seems like it's missing in the MArray module
14:57:22 <Cale> jip: send mail to the libraries list and it'll probably show up in the next GHC
14:57:31 <kosmikus> monochrom: Unix's "everything is a file" predates Pascal, I think
14:57:41 <franka> This argument can be reduced to, "Let's reduce classical logic to NAND."
14:57:50 <monochrom> Fortunately Unix was obscure until Pascal died.
14:58:14 <jip> Cale: cool, but maybe they intentionally left it out cause they couldn't think of a good name for it? modifyArray might be confusing since you might think that it is supposed to modify the entire array or something
14:58:17 <monochrom> hahaha franka I love that.
14:58:20 <franka> Or its opposite, rather.
14:58:37 <Cale> jip: perhaps mapArrayAt
14:58:42 <monochrom> The TTL people used nand, the CMOS people used nor.
14:58:58 <psi> regarding SOC: does anyone know what this means: "Please note that your application won't be considered complete until google has received your *W9 or Foreign Certification form.*" what information will you need to fill out that form?
14:59:00 <franka> Which just goes to show how arbitrary bases are, monochrom.
14:59:19 <jip> my problem with "IO ()" is that it's like: "ok this code doesn't need to return any value, but i am forced to return a value! oh well, i'll just return some dummy value ()". what i think would be the appropriate thing is to have it absolutely explicit that no value is returned
14:59:30 <mahogny> psi, payment info or something. xerox might know more
14:59:43 <franka> Though, granted, for particular models, one may have an advantage.
14:59:47 <psi> mahogny: ok
15:00:07 <mahogny> jip, unlike C, it does return a value though
15:00:09 <franka> type NoValue = ()
15:00:21 <mahogny> jip, a very boring value, but still a value
15:00:24 <monochrom> Oh yes.  But even then, I think the EE people are more aware of their arbitraryness than mathematicians.  How many times have you not heard a mathematician say "a function *is* a subset of XxY..."?
15:00:25 <kosmikus> jip: you're in a functional language. everything returns a value.
15:00:28 <franka> It is wrong, though. () is a value.
15:00:36 <jfoutz> psi W9 is for taxes. you need your address and ssn. if you need a foreign certification form, you probably need passport and visa info.
15:01:02 <franka> monochrom: Yes.  But that attitude is less prevalent in categorical algebra.
15:01:37 <Cale> You could declare data Void, an empty type, and then have IO Void
15:01:50 <franka> Algebraic circles in general.
15:02:02 <jfoutz> monochrom: i constantly not hear mathematicians say all sorts of crazy stuff.
15:02:08 <kosmikus> Cale: what would be an element of IO Void though?
15:02:15 <Cale> kosmikus: bottom
15:02:22 <franka> Just don't observe it.
15:02:32 <Cale> kosmikus: as well as tons of other things
15:02:43 <Cale> IO Void has plenty of elements
15:02:52 <monochrom> (putStrLn "hello world"; return undefined) :: IO Void   is that what you want?
15:03:00 <kosmikus> so you'd have to write "return undefined" at the end of many statements ... now that would be an improvement
15:03:04 <franka> I propose: data IAmNotInterestedInThisValuePleaseDontLookAtMe
15:03:10 <monochrom> err s/;/>>/
15:03:29 <Cale> kosmikus: well, not if it was the convention to return undefined from primitives which don't return interesting values
15:03:40 <monochrom> interesting!
15:03:54 <franka> This is an abuse of non-strictness.
15:04:03 <Cale> however, this just adds a little extra danger for no real gain
15:04:04 <kosmikus> I don't like it
15:04:05 <jip> Cale: wouldn't it be possible to use 2 types, "IOwithresult a" and "IOnoresult", and then just have the composition functions work properly with these types?
15:04:12 <Cale> kosmikus: neither do I
15:04:21 <psi> jfoutz: ok. thanks. a visa is not applicable for me I guess, I live in Sweden.
15:04:22 <franka> Well I LOVE it, so there!
15:04:23 <Cale> kosmikus: I'm just saying that it would be possible.
15:04:32 <kosmikus> jip: you can always de-simplify things for no reason
15:04:42 <Cale> jip: not without breaking everything
15:04:54 <jip> kosmikus: i'm just asking if it's possible :)
15:04:56 <doublec> jip, how's the emulator going?
15:05:06 <Cale> jip: I'm pretty sure that changes like that would kill type inference.
15:05:09 <franka> Everyone will immediately adopt this new coding style, or we will be looking up their bottoms.
15:05:10 <jip> Cale: yeah, but you could design an alternative IO system with this strategy?
15:05:24 <jip> doublec: i'm trying something now
15:05:30 <Cale> jip: either that, or you'd need a whole slew of extra combinators
15:05:33 <jip> doublec: should have some important results soon
15:05:46 <psi> devlog update! ;)
15:05:48 <jip> Cale: yep
15:05:51 <doublec> cool
15:05:57 <Cale> like (.>>) :: IONoResult -> IOResult a -> IOResult a
15:06:06 <doublec> I've been working on a space invaders arcade machine emulator in haskell. 
15:06:09 <jip> psi: i think the devlog update might unfortunately have to wait until end of next week
15:06:15 <jip> Cale: yep
15:06:21 <jip> doublec: whoah, sweet
15:06:37 <psi> jip: that's cool.
15:06:38 <doublec> I wrote one in Factor awhile back. Your devlog inspired me to try doing it in haskell.
15:06:47 <Cale> jip: and in the end, you'll have gained absolutely nothing in terms of expressiveness, for a lot of extra complexity
15:06:58 <kosmikus> jip: even if you have such a system, the fact remains that "IOResult ()" is still a valid type, and a type you could use for things that do not have any information to return.
15:07:02 <franka> I am very disappointed that no one laughed at my very funny joke.
15:07:03 <franka> Above.
15:07:06 <franka> There, see it?
15:07:10 <doublec> I have the cpu emulation mostly working. Need to do the interrupt emulation (vblank, etc) and the graphics now.
15:07:13 <kosmikus> jip: so you'd have a system with two ways to express the same concept ...
15:07:30 <monochrom> I suppose the debate started with someone asking "why return ()? you should return nothing whatsoever".  And now the answer is of course clear: "that is not true. you return successfully or exceptionally, so you do need a return type with one value plus bottom, which is ()."
15:07:31 * kosmikus laughed, but irssi couldn't hear me
15:07:40 <Cale> franka: We are all humourless blobs. Join us.
15:07:53 <franka> In the future, i will reserve my jokes for people who know the value of a well-defined bottom.
15:08:24 <psi> I like how people are doing emulators. I will probably join in soon with a NES emulator :-)
15:08:41 <jip> doublec: what kind of cpu does that bugger have?
15:08:51 <Cale> In the past, I reserved my insults for people who didn't know the value of an undefined top.
15:08:54 <doublec> jip, similar to the gameboy. An 8080.
15:08:55 <monochrom> The bottom that can be defined is not the True Bottom.  *duck*
15:09:18 <doublec> psi, emulators are fun to code because they have a well defined spec (usually) and you get cool stuff at the end of it.
15:09:39 <franka> I am dumbstruck at your poor taste in humor.
15:09:49 <franka> That is disgusting.
15:09:49 <doublec> jip, I posted about it here: http://www.bluishcoder.co.nz/2006/05/space-invaders-emulator-in-haskell.html
15:10:05 <Cale> monochrom: duck, goose
15:10:10 <psi> doublec: yeah! I really want to get started, but there's so much else I have to do :)
15:10:26 <kosmikus> monochrom: clearly, because (True) Bottom is a constructor or datatype, whereas bottom is a value ... ;)
15:10:27 <psi> I'm currently mining 6502 documents.
15:10:33 <doublec> I'm pretty new to haskell so it's a learning experience.
15:10:38 <doublec> Is the NES a 6502?
15:10:42 <psi> yeah
15:11:21 <monochrom> I have a 6502 chip in my cupboard.  It was never used.
15:11:52 <monochrom> Brand new mint condition 6502!  Asking for $2000000!
15:11:56 <jethr0> doublec: btw, glancing at your blog entry, array content is shared, not copied (at least AFAIK)
15:12:34 <doublec> jethr0, If I update the array it's copied though, right?
15:13:02 <psi> 6502s sold for $25 when they were released
15:13:18 <psi> 8080 cost $179 at that time
15:13:50 <int-e> monochrom: I doubt anyone is desperate enough to pay that price.
15:13:59 <wchogg> You can msg lambdabot, right?
15:14:01 <monochrom> heh
15:14:04 <jethr0> doublec: that's pretty internal stuff. but usually in the pure parts of haskell thinking of it as sharing instead of copying is better
15:14:07 <monochrom> Yes wchogg 
15:14:29 <psi> I already have one in my NES :)
15:14:32 <doublec> jethr0, cool, thanks.
15:14:45 <wchogg> monochrom:  Thanks.  I don't like spamming the channel.
15:15:10 <psi> I seem to have lost my smb cartridge :(
15:16:07 <jip> doublec: i have come to the conclusion that if you use UArray then the whole array will be copied with every (//) operation. you can try using DiffUArray though, which is supposed to modify the array "in place" without copying it
15:16:32 <doublec> jip, I tried swapping in DiffArray but it came out twice as slow as UArray which I thought weird.
15:16:47 <jip> doublec: you were sure to use DiffUArray and not DiffArray?
15:17:04 <jethr0> doublec: nice blog entry. thumbs up for that pretty advanced first project
15:17:15 <doublec> Thanks jethr0 
15:17:32 <doublec> jip, Hmm, good point. I probably used DiffArray. I'll try DiffUArray and see what happens.
15:18:24 <jip> doublec: for some reason though, i experienced a 5 times slowdown with DiffUArray over UArray, so it may not be so great afterall
15:18:26 <jethr0> doublec: oh sorry, i was a bit imprecise earlier on. when dealing with unboxed values all bets (in respect to sharing/copying/lazyness) are off :)
15:18:28 <doublec> Although it looks like UArray will be fast enough for the emulation.
15:19:12 <doublec> Doing the GUI updates will be the interesting part. Needing to update the screen 60 times a second could be a slowdown.
15:19:15 <jip> doublec: also, i am thinking of getting rid of my "Instruction" type, and directly executing instructions from the opcode value, instead of converting to the intermediate "Instruction" type
15:19:47 <jip> doublec: what resolution does the space invaders have?
15:20:03 <doublec> jip, I thought about doing that as I was writing it too. But the instruction type could be neat if I wanted to write 8080 code in Haskell to run. Maybe as part of an assembler or something.
15:20:07 <jethr0> yes, but i don't think that space invaders had an fps of 60. more like 5 i'd think
15:20:07 <nothingmuch> shapr: ping
15:20:34 <doublec> Space invaders is 224x256
15:20:43 <jip> doublec: yeah, that was my thinking for writing it in the first place :D
15:20:51 <xerox> jethr0: which blog?
15:21:00 <doublec> It was actually 60 believe it or not. The vblank fires 60 times a second.
15:21:02 <jethr0> http://www.bluishcoder.co.nz/2006/05/space-invaders-emulator-in-haskell.html
15:21:38 <doublec> In the Factor version I update an opengl bitmap on each video memory write. Every vblank interrupt I used glDrawPixels to display it.
15:22:00 <doublec> I found it too slow to copy the contents of the cpu's video memory to the display every interrupt.
15:22:01 <jethr0> yes, but there could have easily have been some kind of hardware to hold the last signal until a new one came. but i really have no idea of the hardware used at the time
15:22:09 <doublec> true
15:22:57 <jethr0> glDrawPixels is considered slow if you intend to fill the whole screen
15:23:16 <jethr0> afair
15:26:07 <doublec> I may just draw directly to the screen as video memory is updated instead of refreshing on the vblank interupt. I do this in my Nintendo DS space invaders emulator and it ran fine.
15:28:04 <jethr0> ah, so you're not filling the whole screen every frame. that was what i was referring to. looking forward to the 100% compliant version. can't wait to play a little haskell space invaders :)
15:28:08 <araujo> hi!
15:28:31 <jip> doublec: ah, you're the guy working on that c ds emulator!
15:28:37 <doublec> jip, yep
15:30:30 <doublec> The DS interests me as a fun two cpu device to program. Complete with 3d graphics, wifi, microphone and touch screen. 
15:30:37 <xerox> doublec: wow, that scheme-over-js thing looks quite nice!
15:31:02 <doublec> xerox, It's pretty nifty alright. 
15:33:39 <jfoutz> @pl \x y -> abs x + floor y
15:33:39 <lambdabot> (. floor) . (+) . abs
15:41:36 <sjanssen_> @quote
15:41:37 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
15:41:37 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
15:41:37 <lambdabot> he was one of the pugs de
15:42:06 <sjanssen_> @quote
15:42:07 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
15:48:06 <int-e> @hoogle Ordering -> Ordering -> Ordering
15:48:07 <lambdabot> No matches, try a more general search
15:49:18 <Lemmih> compare?
15:50:21 <int-e> hmm. No. \a b -> compare (a, b) (EQ, EQ)  does what I want I think.
15:50:24 <jethr0> @type compare
15:50:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:50:40 <Fromage> Hello
15:50:44 <Fromage> Good evening everybody
15:50:52 <Fromage> I get a syntax error in a line occupied by a guard
15:50:58 <Fromage> | fPertenece x prim = 1 + fApariciones x res
15:51:02 <Fromage> It's that one
15:51:11 <Fromage> What's wrong with it ?
15:51:50 <lscd> what does the error say?
15:51:52 <sethk> Fromage, I'd guess that the error is before that line
15:52:07 <sethk> Fromage, may need 1 + (fApar...     res)
15:52:18 <Fromage> ERROR "/home/adrian/quorums.hs":124 - Syntax error in expression (unexpected `|')
15:52:32 <sethk> Fromage, you have an = ending the preceding line
15:52:40 <Fromage> Yes
15:52:43 <Fromage> Opssss, I forgot
15:52:52 <Fromage>  I cannot put the = when using guards
15:53:03 <sethk> Fromage, right.  I saw that because I do the same thing all the time.  :)
15:53:16 <Fromage> Thank you very much, sethk 
15:53:45 <xerox> Did 01:02:03 04/05/06 pass in your timezone yet?
15:53:59 <sethk> xerox, yes, and you didn't say anything until now
15:54:16 <sethk> xerox, no, wait
15:54:20 <sethk> xerox, that's tomorrow  :)
15:54:38 <Fromage> Here it is 00:54:34 04/05:06
15:54:40 <xerox> It's going to happen in 8 mins there :-)
15:54:56 <xerox> Same here :-)
15:55:02 <Fromage> Where do you live, xerox ?
15:55:03 <lscd> xerox: it's the 4th here
15:55:09 <xerox> Turin, Italy
15:55:15 * araujo looks around 
15:55:17 <xerox> lscd: here too.
15:55:19 <jethr0> *yeah*, i guess i'll wait that out then
15:55:20 <sethk> xerox, I still have eight hours
15:55:39 <lscd> xerox: makes sense; last time i checked, switzerland and italy were in the same timezone ^-^
15:55:39 * xerox is proud of his 111...111 UNIX time shot :-)
15:56:03 <xerox> (-:
15:56:43 * xerox excites
15:56:56 <Fromage> I'm proud of my ... errr ....
15:57:06 <Fromage> The way I breath, for instance
15:57:17 <xerox> 6 mins left.
15:58:22 <SamB> ???
15:58:22 <lambdabot> Maybe you meant: . id pl v wn
15:58:24 <SamB> 6 mins?
15:58:31 <xerox> Yup.
15:58:34 <SamB> lambdabot: indeed, I did not!
15:58:38 <xerox> @localtime xerox
15:58:40 <lambdabot> Local time for xerox is 2006-05-04 00:58:19 +0200
15:58:49 <Lemmih> @timein Lemmih
15:58:53 <lambdabot> Local time for Lemmih is Thu May  4 01:02:49 2006
15:58:57 <SamB> lambdabot should ignore things containing only ? and !
15:59:05 <xerox> Yay!  Party for Lemmih!
15:59:23 <Lemmih> Yay!
15:59:27 <jethr0> in the channel we can also wait for 03:02:01, he :)
15:59:36 <xerox> I'll be sleeping :-P
15:59:45 <xerox> @timein xerox
15:59:46 <lambdabot> Local time for xerox is 2006-05-04 00:59:26 +0200
15:59:57 <SamB> what is being celebrated?
16:00:05 <jethr0> [1..6]
16:00:07 <monochrom> straight flush
16:00:26 <xerox> SamB: 01:02:03 04/05/06
16:00:33 <xerox> 2 mins!
16:00:39 <SamB> oh, right
16:01:20 <SamB> I would have to celebrate that last month :-(
16:01:22 <xerox> 1 min 2 secs!
16:01:31 <jethr0> hehe
16:02:13 <jethr0> i could never get quite over MM/DD/YY
16:02:31 <xerox> Aaaaaaaaaaaargh!
16:03:07 <SamB> or, I could maybe celebrate 2006-05-04 03:02:01, except I would be asleep...
16:03:50 <xerox> 1 second off
16:03:51 <xerox> Sigh.
16:04:10 <xerox> Well, good [1..6] to everybody.
16:04:27 <jethr0> auguri
16:05:30 <SamB> anyway, strange times of one kind or another happen a lot...
16:10:18 <dons> moin
16:10:25 <dcoutts> g'night
16:10:59 <xerox> Goodnight!
16:12:19 <sjanssen_> dons: I wrote sortBy (sjanssen is trying desperately to keep up his one ByteString patch per day)
16:14:19 * vincenz tickles dons 
16:14:32 <dcoutts> oooh! how rude!
16:17:48 <wchogg> dons:  Would you mind me msg'ing you about something?
16:20:35 <sjanssen_> @yhjulwwiefzojcbxybbruweejw
16:20:35 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:21:18 <RyanT5000> wtf?
16:21:27 <sjanssen_> @v
16:21:28 <lambdabot> Exception: <<loop>>
16:21:39 <sjanssen_> @help v
16:21:40 <lambdabot> let v = show v in v
16:24:29 <jethr0> g'nite @ all
16:26:54 <dons> sjanssen_: excellent! :)
16:27:08 <dons> wchogg: no, sure. msg away
16:27:23 <sjanssen_> it really sucks for small strings right now -- worse that pack . List.sort . unpack
16:27:23 <dons> sjanssen_: how's you do it?
16:27:31 <dons> oh, hehe
16:27:39 <dons> we can always switch on the string length
16:29:15 <sjanssen_> I count the occurences of each character, List.sortBy each character that appears at least once, then fill with mset
16:31:18 <sjanssen_> I think doing a switch on size for both sorts is a good idea.  Allocating 1 KB just to sort a 10 character string is a bit obscene
16:34:11 <jip> well, the results are in, gameboy emulator is gained a 3x speed boost
16:34:18 <wchogg> cool, jip
16:34:21 <doublec> jip, nice!
16:34:41 <sjanssen_> jip: what's your secret?  steroids?
16:34:53 <Adamant> HGH, imo
16:34:54 <jip> sjanssen: mutables :)
16:36:22 * vincenz shoots jip in the gonads
16:36:22 <vincenz> erm
16:36:24 <vincenz> monads
16:36:57 <jip> i was hoping for a bigger improvement, but hopefully with some more tweaks, it should be ok
16:37:23 <vincenz> is it playable speed?
16:37:44 <jip> vincenz: no, it now runs at about 30% of realtime speed
16:37:45 <sjanssen_> jip: are you using unsafeRead/unsafeWrite for your arrays?
16:37:53 <jip> sjanssen_: no
16:38:13 <jip> @where unsafeRead
16:38:14 <lambdabot> I know nothing about unsaferead.
16:38:20 <jip> @hoogle unsafeRead
16:38:20 <lambdabot> No matches found
16:38:28 <sjanssen_> well, if there's a way you can statically be sure that you won't write out of bounds, you can try that
16:38:48 <dons> jip, they're in Data.Array.Base
16:38:51 <dons> @index unsafeReaed
16:38:52 <lambdabot> bzzt
16:38:58 <dons> blah
16:39:27 <jip> sjanssen_: well, i am convinced that write out of bounds will never happen. but it seems that Data.Array.Base is a secret module or something
16:40:09 <sjanssen_> jip: it is, kindof
16:40:43 <sjanssen_> the best way to peek in there is to do a ":browse Data.Array.Base" from ghci
16:42:42 <dons> jip, not really secret. but unsafeRead/Write are critical often. esp. when you already have some other kind of proof of bounds safety
16:43:41 <jip> hm... they work with Int as the index
16:44:10 <dons> really?
16:44:18 <jip> yep
16:44:33 <dons> no. they're paramaterised on Ix
16:44:40 <dons> @type Data.Array.Base.unsafeRead
16:44:41 <lambdabot> forall e
16:44:41 <lambdabot>              (a :: * -> * -> *)
16:44:41 <lambdabot>              (m :: * -> *)
16:44:41 <lambdabot>              i.
16:44:41 <lambdabot>           (Data.Array.Base.MArray a e m, Ix i) =>
16:44:43 <lambdabot>           a i e -> Int -> m e
16:44:52 <dons> hmm.
16:45:08 <RyanT5000> well class Ix defines a function Ix i => i -> Int
16:45:11 <dons>     unsafeRead  :: Ix i => a i e -> Int -> m e
16:45:12 <dons>     unsafeWrite :: Ix i => a i e -> Int -> e -> m ()
16:45:22 <dons> yeah, right. that's why its not an issue
16:45:27 <sjanssen_> so it assumes zero indexed?
16:45:36 <dons> sjanssen_: i hope so.
16:46:02 <dons> jip, just read the Data.Array.Base src, its full of lots of examples
16:46:16 <dons> i..e for bools:
16:46:29 <dons>     unsafeRead (STUArray _ _ marr#) (I# i#) = ST $ \s1# ->
16:46:29 <dons>         case readWordArray# marr# (bOOL_INDEX i#) s1# of { (# s2#, e# #) ->
16:46:29 <dons>         (# s2#, (e# `and#` bOOL_BIT i#) `neWord#` int2Word# 0# #) }
16:46:44 <dons> enjoy :)
16:47:13 <RyanT5000> what does # mean?
16:47:24 <jip> hm... i seem to be getting almost the exact same performance with unsafe
16:47:30 <dons> nothing here. its a convention only to indicate primop or unboxed.
16:47:35 <RyanT5000> ah
16:47:39 <RyanT5000> so it's just an uglifier
16:47:47 <RyanT5000> :)
16:47:50 <dons> yeah, like 'unsafe'
17:43:15 <dons> more coffeeeee!
17:44:06 <monochrom> > repeat "coffee"
17:44:06 <lambdabot> ["coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee",
17:44:07 <lambdabot> "coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","
17:44:07 <lambdabot> coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","
17:44:07 <lambdabot> coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","
17:44:09 <lambdabot> coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","coffee","
17:44:12 <lambdabot> [6 @more lines]
17:52:29 <RyanT5000> hm does freenet autokick for flooding?
17:52:54 <Cale> RyanT5000: yes
17:53:08 <RyanT5000> > putStrLn "> 1"
17:53:08 <lambdabot> No IO allowed
17:53:33 <Cale> RyanT5000: but the bot is set up such that it ought not to ever flood. However, I think the line limit should probably be decreased
17:53:55 <Lemmih> dons: SoC project for redesigning GHC as a library?
17:54:20 <Lemmih> ?id > 1
17:54:20 <lambdabot> > 1
17:54:44 <monochrom> > putStrLn "No IO allowed"
17:54:45 <lambdabot> No IO allowed
17:54:49 <Cale> dons: It would be nice to make it so that the lambdabot modules are able to configure any extra parsing of the commandline themselves. (i.e. rather than having special cases in Base for "> ")
17:54:54 * Lemmih grins.
17:55:04 <monochrom> You have to do IO in my style.
17:55:52 <RyanT5000> > "______________________________________________________________________________________________________________________________________________________________________________________________________> 1"
17:55:53 <lambdabot> "______________________________________________________________________________________________________________________________________________________________________________________________________
17:55:53 <lambdabot> > 1"
17:55:57 <dons> Lemmih, yeah, for a nice ML-ish 'top' interface 
17:56:09 <dons> we might pick up some ML hackers.
17:56:11 <RyanT5000> so lambdabot won't respond to itself?
17:56:33 <RyanT5000> lol we should get two lambdabots in here
17:56:39 <RyanT5000> we could totally set up the chinese takeout scenario
17:56:41 <Cale> RyanT5000: no, but two lambdabots will respond to each other
17:56:49 <Cale> It's been done :)
17:56:52 <RyanT5000> :)
17:56:57 <dons> only in certain weird cases though.
17:57:06 <dons> by default, no. they don't
17:57:12 <dons> but there's a couple of holes
17:57:20 <dons> findign them is the game.
17:57:24 <RyanT5000> well how do they know the other one is a lambdabot?
17:57:41 <dons> they don't need to
17:57:47 <RyanT5000> ?
17:57:50 <Lemmih> dons: What libdir should GHC.Top.init use?
17:58:01 <dons> whatever the ghci uses by default
17:58:04 <RyanT5000> what if you write a program that outputs itself with "> " before it
17:58:05 <Cale> RyanT5000: it's just that lambdabot usually won't produce output which is readable as a command by another lambdabot
17:58:12 <Lemmih> dons: It don't use anything by default.
17:58:15 <Lemmih> *doesn't
17:58:28 <dons> Lemmih: should it not just behave like ghci by default, and then there are hooks of course to add extra stuff
17:58:46 <Cale> > "______________________________________________________________________________________________________________________________________________________________________________________________________> 1 --"
17:58:47 <lambdabot> "______________________________________________________________________________________________________________________________________________________________________________________________________
17:58:47 <lambdabot> > 1 --"
17:58:53 <dons> so, basically, :m + and so on
17:58:56 <Cale> that might work
17:59:01 <RyanT5000> yeah, or
17:59:07 <RyanT5000> > "______________________________________________________________________________________________________________________________________________________________________________________________________> \"1"
17:59:08 <lambdabot> "______________________________________________________________________________________________________________________________________________________________________________________________________
17:59:09 <lambdabot> > \"1"
17:59:14 <RyanT5000> huh?
17:59:20 <RyanT5000> oh
17:59:20 <Lemmih> dons: ghc points to a script which calls the real ghc with an appropriate libdir.
17:59:21 <RyanT5000> right
17:59:41 <RyanT5000> well in any case i'm convinced it can be done
17:59:45 <dons> Lemmih: ah right. 
17:59:50 <dons> hmm
17:59:58 <Cale> > "______________________________________________________________________________________________________________________________________________________________________________________________________> 1 --"
17:59:59 <dons> a hack, eh.
17:59:59 <lambdabot> "______________________________________________________________________________________________________________________________________________________________________________________________________
18:00:00 <lambdabot> > 1 --"
18:00:00 <mbot> "______________________________________________________________________________________________________________________________________________________________________________________________________
18:00:00 <mbot> > 1 --"
18:00:01 <lambdabot> 1
18:00:01 <mbot> 1
18:00:54 <Cale> mbot: @part #haskell
18:01:41 <Lemmih> dons: Know what OCaml does?
18:02:28 <dons> I'll look into it. I've only used SMLs (via the twelf theorem prover)
18:02:40 <dons> I'm sure there are papers on this topic
18:02:50 <RyanT5000> > printf "hello" asdf
18:02:50 <lambdabot>  Not in scope: `asdf'
18:02:55 <RyanT5000> > printf "hello" ""
18:02:56 <lambdabot> Add a type signature
18:03:42 <Lemmih> dons: Papers on finding where a set of libraries are installed?
18:04:47 <dons> on top-levels in functional langauges
18:04:56 <dons> and the intricky-cies
18:05:23 <araujo> Hello!
18:05:29 <Lemmih> araujo: Hallo!
18:06:07 <RyanT5000> > printf "%s" "hello"
18:06:08 <lambdabot> Add a type signature
18:06:11 <RyanT5000> what's wrong with that?
18:06:31 <Lemmih> > printf "%s" "hello" :: String
18:06:32 <lambdabot> "hello"
18:06:47 <RyanT5000> ah
18:07:03 <Cale> printf can result in a String or an IO () depending on context
18:07:16 <Lemmih> RyanT5000: You needed to add a type signature. I know, the error message is a bit confusing d-:
18:07:27 <dons> hehe
18:07:28 <RyanT5000> i didn't know for what i needed to add a type signature :)
18:07:48 <RyanT5000> i thought it was for the second string, but that didn't work in ghci
18:08:28 <monochrom> I am coining a new term. "contextual typing"
18:14:54 <dons> Lemmih, currently the libdir is written into a shell file by the build system, right? I'm thinking it should also go into a generated .hs file, so its available to anything that calls the ghc api, which then can just inspect this string.
18:15:50 <Lemmih> /-:
18:16:10 <Lemmih> How will that affect binary distributions?
18:19:41 <dons> yeah. hard. ./configure would have to regenerate a .o file
18:20:10 <dons> but currently, this libdir thing makes it more cumbersome than it should be, i think.
18:21:43 <Lemmih> A bit harder.
18:22:16 <Lemmih> Setup.lhs in hIDE defined GHC_LIBDIR to the libdir of the ghc used.
18:22:28 <Lemmih> *defines
18:22:33 <dons> right. so does hs-plugins
18:23:16 <Lemmih> But hs-plugins doesn't know about --with-compiler (:
18:23:29 <dons> it knows about --with-ghc :)
18:23:38 <dons> but that's disabled for now.
18:23:41 <dons> hehe
18:31:14 * Lemmih wonders if he could get someone to rewrite GHC in a functional language for SoC.
18:32:01 <dons> hehe
18:32:06 <dons> yeah, it would be a worthy goal
18:32:11 <dons> death to dyn flags
18:32:31 <sjanssen_> dyn flags?
18:33:01 <dons> these mutable global vars ghc uses for many flags
18:35:52 <araujo> Lemmih, hallo hallo!
18:54:14 <sjanssen_> dons: is Data.ByteString the official name of your library?  I'm wondering what to call it in my SoC proposal
18:54:27 <dons> yep. that's the name now its in ghc
18:54:58 <dons> i've been referring to it as ByteString/FPS where its ambiguous. Otherwise Data.ByteString.
18:54:59 <Cale> dons: oh, cool, it's in the libraries?
18:55:06 <Cale> That should help on the shootout
18:55:14 <dons> yes!
18:55:33 <dons> yeah, i wonderwhen we can get a 6.5/6 installed on the shootout boxes :)
18:55:54 <Cale> When is 6.6 due out?
18:56:17 <dons> not sure. its pretty stable, but there's still some things to do (JRegex for one.)
18:56:26 <dons> and probably not before icfp in september.
18:56:54 <RyanT5000> is there a zip or gzip algorithm in the standard library?
18:57:11 <dons> there's a zip ;)
18:57:15 <RyanT5000> where?
18:57:16 <Korollary> RyanT5000: No, but there's one in MissingH
18:57:22 <sethk> dons, I've had something strange happen here, and I wanted to run it past you.  I coded around the problem, but I'm curious about it.
18:57:30 <RyanT5000> crap, it needs to be accessible from lambdabot ;)
18:57:31 <dons> @type zip --sorry. couldn't resist
18:57:32 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
18:57:53 <dons> sethk: ok. sure.
18:57:54 <RyanT5000> i have a self-printing program.... but it's 244 characters
18:58:09 <RyanT5000> it needs to be 199
18:58:12 <sethk> dons, If I call runCommand, which returns a ProcessHandle, I can use waitForProcess on the handle
18:58:13 <RyanT5000> :(
18:58:41 <sethk> dons, however, if I return the ProcessHandle, and then call another function, and call waitForProcess in that function, it returns immediately with "no child process"
18:59:04 <sethk> dons, same thing happens with the other function, I think getProcessReturnCode (I'll check the exact name)
18:59:11 <dons> hmm.
18:59:32 <sethk> getProcessExitCode
18:59:44 <sethk> It's repeatable
19:00:19 <dons> time for a bug report then?
19:00:21 <sethk> what I did to code around it, I passed an MVar as an argument, and wrote the ProcessHandle value into the MVar, and did waitForProcess immediately after, avoiding the return
19:00:25 <dons> or try the behaviour under the 6.5 compiler.
19:00:36 <sethk> dons, ok, I haven't really tried the 6.5 compiler yet.
19:00:38 <dons> that sounds like a reasonable solution
19:00:49 <Fromage> Hello
19:00:52 <sethk> dons, that's not normal behavior, though?
19:01:00 <Fromage> Does Haskell prelude provide any function to sort a list of integers ?
19:01:02 <skew> I'm looking for help - does anybody have ideas how to do a functional implementation of one-shot continuations?
19:01:05 <dons> sethk, doesn't sound like it
19:01:06 <sethk> dons, didn't seem normal, but ...
19:01:09 <sjanssen_> Fromage: Data.List.sort
19:01:10 <Fromage> I could create one myself, but I lack enough time to think about the correct algorithm
19:01:11 <dons> Fromage, sort would do it.
19:01:16 <Fromage> OK
19:01:19 <sjanssen_> > sort [4, 3, 5, 1]
19:01:20 <dons> @hoogle [a] -> [a]
19:01:20 <lambdabot> [1,3,4,5]
19:01:20 <lambdabot> Prelude.cycle :: [a] -> [a]
19:01:21 <lambdabot> Prelude.init :: [a] -> [a]
19:01:21 <lambdabot> Prelude.reverse :: [a] -> [a]
19:01:21 <Fromage> Remember I cannot load any external module
19:01:30 <dons> @index sort
19:01:30 <lambdabot> Data.List
19:01:41 <dons> well, if you can't use Data.List, you'll have to write your own sort.
19:01:52 <dons> but why would you not be able to use the base libraries?
19:02:04 <sjanssen_> @index insert
19:02:05 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
19:02:07 <dons> surely you can 'import List' ?
19:02:07 <skew> @where hoogle
19:02:08 <lambdabot> http://www.haskell.org/hoogle
19:02:13 <Fromage> Because it's a practical work for University, and I'm not allowed to use external libraries
19:02:31 <RyanT5000> dons: other possibility: working on an embedded system
19:02:32 <Fromage> I'm supposed to create everything I need myself
19:02:35 <dons> no external libs. but what about haskell base libs.
19:02:42 <dons> ie. List is much like Prelude
19:02:45 <dons> and it comes standard.
19:02:46 <Fromage> Neither them, dons 
19:02:52 <dons> sigh. ok.
19:02:56 <skew> what about prelude functions then?
19:02:58 <dons> just copy and paste from List.hs then
19:02:58 <RyanT5000> bubble sort ftw
19:03:01 <Fromage> Could I copy source code from sort function in Data.List ?
19:03:07 <dons> its a bizarre restriction
19:03:14 <Fromage> It's ridiculous, dons 
19:03:21 <RyanT5000> you're probably not allowed to copy and paste code, if that's the restriction
19:03:21 <dons> even in my haskell 101 days we could import List :)
19:03:22 <Fromage> This practice is not about algorithm implementation
19:03:27 <Fromage> It's just basic Haskell usage
19:03:31 <RyanT5000> hm
19:03:34 <dons> so import List then
19:03:40 <skew> Fromage: where is this?
19:03:41 <Fromage> I can't ..
19:03:48 <dons> that's basic haskell usage. you don't need to install anything.
19:03:49 <Fromage> My university, skew 
19:04:01 <Fromage> Erm ..
19:04:04 <Fromage> I'll stand it again ..
19:04:15 <Fromage> I'm NOT allowed to import anything within my single source code file
19:04:37 <dons> your optoins are a) import List. b) copy sort from List c) write your own sort b) avoid sort.
19:04:47 <Fromage> I cannot avoid sort
19:04:49 <monochrom> Do you really need to sort?
19:04:53 <Fromage> Yeah
19:04:56 <Fromage> I cannot import it
19:05:02 <dons> and apparently a) is nnot allowed. d) is not allowed.
19:05:03 <Fromage> I lack enough time to write one myself
19:05:09 <dons> so either write a qsort (3 lines) or copy one
19:05:12 <sethk> Fromage, well, if you have to code a sort, then I guess you have to code a short
19:05:32 <Fromage> OK
19:05:33 <monochrom> I suppose my question is "what is your real question"
19:05:37 <Fromage> I'l try to write one on my own ..
19:05:41 <sethk> it would be extremely strange to be allowed to use code someone else has written, but not be allowed to import a library function
19:05:55 <Fromage> sethk: My University works in a bizarre way
19:06:07 <sjanssen_> Fromage: insertion sort is real easy to write in Haskell
19:06:08 <Fromage> Professors are not interested in how you get or write the code
19:06:10 <dons> qsort in haskell is 3 lines, btw. so you could code it up.
19:06:18 <Fromage> It's just a matter of successing in the automatic test performed in their main computer
19:06:36 <cmarcelo> Fromage: maybe this example is helpful http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell .. but uses filter..
19:06:56 <dons> @index filter
19:06:56 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
19:06:57 <Fromage> filter comes with Haskell prelude
19:07:04 <SamB> Fromage: so sad...
19:07:22 <Fromage> At least, my teachers haven't argued against Prelude yet
19:07:26 <Fromage> But ... who knows
19:07:27 <dons> here, I can't stand it any more:
19:07:29 <SamB> Fromage: but you get that a lot of places
19:07:31 <dons>  qsort []     = []
19:07:31 <dons>  qsort (x:xs) = qsort less ++ [x] ++ qsort more
19:07:31 <dons>      where less = filter (<x)  xs
19:07:31 <dons>            more = filter (>=x) xs
19:08:05 <dons> use the src wisely.
19:08:12 <Fromage> Sorry, I know I'm not showing a proper attitude towards my exercise
19:08:13 <monochrom> I wonder how much effort needs to be put into defeating "import List" in an automatic test system.  (I have done automatic test systems.)
19:08:16 <SamB> isn't that slow?
19:08:23 <Fromage> But it's extremly late here, and I have to deliver this practice tomorrow morning
19:08:29 <Fromage> And that's the last task that needs to be performed
19:08:33 <dons> sure. but you think this is going to be a high performance test, SamB?
19:08:38 <monochrom> What is the real question?
19:08:44 <SamB> monochrom: grep for \bList\b ?
19:09:01 <SamB> dons: well, no
19:09:03 <monochrom> That would also forbid "data List a = ..."
19:09:12 <SamB> true!
19:09:14 <SamB> um...
19:09:18 <Fromage> I hate university
19:09:22 <SamB> get GHC to tell all the imports?
19:09:23 <RyanT5000> is there any way other than "" to make a string?
19:09:25 <skew> Fromage: which university? Probably we have somebody else from there.
19:09:30 <Fromage> I can't understand why they establish suck a stupid restriction
19:09:31 <RyanT5000> i need a way that doesn't use "
19:09:37 <RyanT5000> and isn't really, really long like a list of chars
19:09:40 <Fromage> skew:  Politechnical University of Madrid
19:09:47 <Fromage> Never hire a Spanish programmer, we are a bunch of apes
19:09:51 <monochrom> What is the real question?
19:10:00 <RyanT5000> monochrom: me?
19:10:04 <monochrom> Fromage.
19:10:05 <Fromage> The real question ... actually there wasn't a real question
19:10:08 <sethk> Fromage, I always let spanish companies hire me.
19:10:09 <RyanT5000> k
19:10:10 <SamB> well, here in US, they use C++ instead of Haskell, generally...
19:10:22 <sethk> Fromage, any time someone will pay for me to go to Barcelona, I'm going  :)
19:10:29 <sh10151> who is they?
19:10:34 <Fromage> Barcelona is not Spain
19:10:39 <SamB> > [] :: String
19:10:40 <lambdabot> ""
19:10:46 <sethk> Fromage, yes, that's what they say in Barcelona also  :)
19:10:47 <monochrom> If there isn't a real question, then there is no need for a real answer.
19:10:50 <SamB> > [chr 0x40] :: String
19:10:51 <lambdabot> "@"
19:10:58 <SamB> > [chr 40]
19:10:59 <lambdabot> "("
19:11:03 <skew> SamB: what are you trying to do?
19:11:03 <RyanT5000> SamB: i'm trying to make a really short program that doesn't use any escaped characters, and prints itself
19:11:12 <RyanT5000> ;)
19:11:19 <SamB> > ord '"'
19:11:20 <RyanT5000> for lambdabot pong
19:11:20 <lambdabot> 34
19:11:20 <Fromage> You are subestimating my skills to generate a stupid conversation from an actual topicless initial statement
19:11:36 <skew> Fromage: sounds like you have work you should be doing
19:11:37 <sethk> Fromage, underestimating, not subestimating
19:11:42 <SamB> oh, wait...
19:11:44 <Fromage> OK, sethk , so if you finally decide to go to Barcelona ...
19:11:52 <sjanssen_> sethk: misunderestimating
19:11:54 <Fromage> Remember Spain is still a Third-world country
19:11:57 <SamB> anyway, it isn't hard in C with printf...
19:12:00 <sethk> Fromage, unfortunately it's been several years since I've been there
19:12:06 <RyanT5000> SamB: also it can't use IO
19:12:06 <Fromage> OK, sethk , thanks
19:12:11 <RyanT5000> so it can't technically "print" itself
19:12:14 <skew> Fromage: not that we are not happy to talk, but perhaps you should send this thing in first.
19:12:17 <RyanT5000> it needs to return a string that contains itself
19:12:26 <sethk> Fromage, best third world country I've ever seen   :)
19:12:29 <skew> RyanT5000: I've seen such a beast in fortran
19:12:30 <SamB> oh
19:12:33 <Fromage> It's almost done, skew 
19:12:34 <sh10151> Generalissimo Francisco Franco is still dead.
19:12:37 <monochrom> I am reminded of the word "trolling"
19:12:43 <Fromage> Generalissimo ?
19:12:48 <RyanT5000> and that string, when printed, needs to not contain any escaped characters
19:12:57 <SamB> RyanT5000: can't our printf do that anyway
19:12:57 <Fromage> I love those doble 's', but we are not that Italian, sh10151 
19:12:59 <SamB> oh.
19:13:02 <RyanT5000> :)
19:13:05 <SamB> hmm.
19:13:06 <jfoutz> @pl \x -> liftM (x :) readFile
19:13:06 <lambdabot> flip fmap readFile . (:)
19:13:07 <RyanT5000> that's why it's challenging
19:13:08 <sh10151> http://en.wikipedia.org/wiki/Generalissimo_Francisco_Franco_is_still_dead
19:13:08 <RyanT5000> i h ave one
19:13:11 <RyanT5000> but it's too long
19:13:11 <dons> sometimess #haskell is a weird place
19:13:17 <SamB> well, they could easily not be escaped if you print it right.
19:13:30 <RyanT5000> > let s=map(chr.(32+))[76,69,84,0,83,29,77,65,80,8,67,72,82,14,8,19,18,11,9,9,5,83,73,78,0,80,82,73,78,84,70,0,83,8,83,72,79,87,4,0,77,65,80,8,8,13,19,18,11,9,14,79,82,68,9,83,9,26,26,51,84,82,73,78,71]in printf s(show$ map((-32+).ord)s)::String
19:13:31 <lambdabot> "let s=map(chr.(32+))[76,69,84,0,83,29,77,65,80,8,67,72,82,14,8,19,18,11,9,9,5,83,73,78,0,80,82,73,78,84,70,0,83,8,83,72,79,87,4,0,77,65,80,8,8,13,19,18,11,9,14,79,82,68,9,83,9,26,26,51,84,82,73,78,
19:13:32 <lambdabot> 71]in printf s(show$ map((-32+).ord)s)::String"
19:13:36 <sethk> damn, I can't ping the machine in Taiwan.  ugh.
19:13:44 <RyanT5000> see, that's the right thing, only it needs to  not break across lines
19:13:58 <sjanssen_> @id LOUD NOISES!
19:13:59 <lambdabot> LOUD NOISES!
19:14:14 <RyanT5000> the (32+) (-32+) are to shorten the overall length by about 6 characters
19:14:27 <RyanT5000> because it makes all the numbers be 2 or 1 digits instead of 3
19:14:30 <Fromage> anyway, dons 
19:14:33 <Fromage> Thanks for the quicksort code
19:15:22 <Fromage> Emm ... now I realize ...
19:15:22 <dons> less talk, more code!
19:15:25 <RyanT5000> SamB: do you see where i'm going with that?
19:15:32 <Fromage> I must compare two different lists
19:15:53 <SamB> > let s = "let s = %c%s%c; q = '%c' in printf s q s q q :: String"; q = '%c' in printf s q s q q :: String
19:15:53 <lambdabot>  parse error on input `%'
19:16:04 <Fromage> I mean, is there any function to check if two lists have the same elements, not necessarily in the same order ?
19:16:05 <SamB> er.
19:16:06 <RyanT5000> yeah i did that too, but it has quotation marks in it
19:16:08 <SamB> > let s = "let s = %c%s%c; q = '%c' in printf s q s q q :: String"; q = '"' in printf s q s q q :: String
19:16:09 <lambdabot> "let s = \"let s = %c%s%c; q = '%c' in printf s q s q q :: String\"; q = '\"' in printf s q s q q :: String"
19:16:18 <RyanT5000> which means it can't return itself as a string without resulting in escaped "
19:16:22 <SamB> well, if you print the answer correctly ;-)
19:16:26 <RyanT5000> but you can't
19:16:35 <RyanT5000> because it's lambdabot :)
19:16:47 <SamB> well, sure, it doesn't look right with lambdabot...
19:17:03 <RyanT5000> well the point is to make the lambdabots get in an infinite loop with each other :)
19:17:08 <sjanssen_> RyanT5000: there is a much simpler way to get a lambdabot loop
19:17:13 <SamB> oh, I don't think you can do that
19:17:16 <Fromage> Hey, it seems nobody could hear me
19:17:18 <RyanT5000> sjanssen_: really?
19:17:20 <Fromage> I mean, is there any function to check if two lists have the same elements, not necessarily in the same order ?
19:17:20 <SamB> "???
19:17:30 <RyanT5000> Fromage: sort then compare
19:17:33 <Korollary> Fromage: you can sort and compare
19:17:45 <araujo> hi!
19:17:52 <Fromage> Something that would return True with ([3,2,1],[1,2,3])
19:18:00 <sethk> Fromage, you can do a union and see if the # elements is higher than the number of elements in the larger set
19:18:04 <Fromage> It'd be better to avoid any kind of sorting in this exercise
19:18:07 <SamB> alternatively you could convert them to Sets, but that comes out to pretty much the same thing...
19:18:12 <skew> Fromage: or, you could build something quadradic out of all and elem and map and such
19:18:46 <Fromage> Converting them to sets would requiere the usage of another library
19:18:51 <RyanT5000> i think you have to do something that boils down to a sort
19:18:52 <Korollary> Fromage: Would it return True for ([1,1,1], [1,1]) as well?
19:18:55 <SamB> oh yeah
19:19:01 <RyanT5000> write yourself a nice little insertion sort
19:19:09 <Fromage> And ... we again come across the same reality ... i was not given permission to do so
19:19:18 <RyanT5000> huh?
19:19:22 <Fromage> Erm ... I do not care, Korollary 
19:19:22 <RyanT5000> you can't write your own sort?
19:19:41 <Fromage> No, I can't use libraries
19:19:49 <RyanT5000> ok so write your own sort and then use it
19:19:54 <SamB> well, just steal the source code from the libraries ;-)
19:20:05 <skew> so, does anybody have ideas about one-shot continuations?
19:20:08 <RyanT5000> writing your own O(n^2) sort isn't hard
19:20:09 <Fromage> Korollary: That function will always deal with lists of the same length
19:20:14 <RyanT5000> skew: define pls
19:20:16 <sethk> Fromage, you are using libraries.  The fact that the import is implicit does not make it any less of an import
19:20:25 <SamB> skew: are they important in Haskell?
19:20:31 <Fromage> sethk:  My file must be self-contained
19:20:33 <sethk> Fromage, I would expect that you have to turn off the implicit import
19:20:45 <skew> no, I'm trying to write an interpreter for a language with them
19:20:45 <sethk> Fromage, import of a library does not mean your file is not self-contained
19:20:48 <RyanT5000> Fromage: it can't be self-contained; it needs to be compiled
19:20:52 <RyanT5000> skew: what are they?
19:20:59 <skew> RyanT5000: like normal continuations, but you can only use them once
19:21:02 <sethk> Fromage, is the requirement that you have only one file?  That has nothing whatsoever to do with using libraries
19:21:10 <Korollary> @and $ map (flip elem [1,2]) [1,2,3]
19:21:10 <lambdabot> Maybe you meant: arr id kind wn
19:21:11 <Fromage> Yeah, sethk 
19:21:15 <RyanT5000> is it an optimization?
19:21:17 <Korollary> > and $ map (flip elem [1,2]) [1,2,3]
19:21:18 <lambdabot> False
19:21:20 <skew> actually, I just need dynamic extent
19:21:26 <skew> like setjmp/longjump
19:21:27 <Fromage> Well, I could always dive into the source code of a certain library and pick up the code I need
19:21:28 <sethk> Fromage, so import what you need.  It's equivalent to an #include in C
19:21:31 <SamB> skew: if you are only allowed to use them once, it doesn't matter what happens if they get used twice does it?
19:21:34 <Fromage> And paste it on my personal source code file
19:21:49 <Fromage> I know, sethk 
19:21:52 <Fromage> But I can't do that
19:22:00 <Fromage> I'm not allowed to import anything
19:22:04 <SamB> sethk: nasty profs!
19:22:08 <RyanT5000> Fromage: just write the code; how hard could it be?
19:22:09 <skew> Fromage: is there some program that grades your program and doesn't take imports?
19:22:22 <sethk> Fromage, then you have to tell it to not import prelude implicitly
19:22:27 <RyanT5000> skew: they could have GHC with all the packages removed, including Base
19:22:37 <RyanT5000> and like a custom prelude or something
19:22:39 <SamB> Fromage: are you able to access the testing harness?
19:22:40 <Fromage> I think that, with the time I've already wasted here, I could had writen two or three useful functions
19:22:43 <Fromage> lol
19:22:44 <SamB> that is, to see what it does
19:23:01 <Fromage> No, SamB 
19:23:07 <skew> SamB: actually, they should raise some exception
19:23:08 <jfoutz> Fromage: write member.
19:23:14 <jfoutz> map member a b
19:23:15 <SamB> you cannot login to the machine it is on?
19:23:22 <Fromage> I can't SamB 
19:23:32 <SamB> that sucks!
19:23:37 <Fromage> I'm just allowed to send my source code file in order to let the program test it
19:23:37 <RyanT5000> Fromage presumably it could just be a teaching assistant who looks at the top and says "are there any imports?"
19:23:43 <Fromage> And return me the result of the general evaluation
19:24:00 <skew> I'm looking for something very close to exceptions, except it should jump outward to one exact handler, or raise a different exception from the place where you invoked it if you've already passed that point
19:24:02 <RyanT5000> either way there's probably no way around it
19:24:23 <SamB> well, you could still paste the functions from sources ;-)
19:24:27 <jfoutz> Fromage:  no, really. for each element of the first list just call member on the second list
19:24:29 <skew> foreign import ccal "qsort" ....
19:24:43 <Fromage> jfoutz: !!!!!!!!
19:24:45 <Fromage> YEAH !!!
19:24:49 <SamB> skew: that won't work -- no Foreign.Ptr!
19:24:59 <skew> Fromage: doesn't quite work for [1,1,1] [1,1]
19:25:13 <jfoutz> is 1 a member of [1,1] ?
19:25:15 <jfoutz> yes
19:25:21 <jfoutz> ... 2 more times
19:25:26 <skew> yeah, but those lists are not permutations of each other
19:25:27 <Fromage> Would it be less complex than a quicksort ?
19:25:35 <skew> depends if you are looking for sets or bags
19:25:36 <jfoutz> i suppose you have to and the answers together
19:25:47 <RyanT5000> Fromage: didn't dons give you the source of quicksort verbatim?
19:25:57 <Fromage> Yeah, he did, RyanT5000 
19:26:05 <RyanT5000> sooo.... you're not using it why?
19:26:16 <Fromage> But now I'm wondering if writing a memeber function would result in a higher performance
19:26:23 <skew> Fromage: do you care?
19:26:30 <Fromage> Er ....
19:26:33 <Fromage> Not at all, really
19:26:37 <skew> ok then
19:26:40 <Korollary> btw, sorting beats member
19:26:46 <Fromage> Because the test will be performed not in extreme situations of CPU usage
19:26:48 <jfoutz> yes, repeated member i slow
19:27:04 <jfoutz> but really really easy
19:27:19 <Fromage> I started to program in Haskel two weeks ago
19:27:21 <skew> if I don't mind using IO to draw uniques I can mark the stack with special exception handlers with those uniques
19:27:35 <Fromage> And ... since that, I've got a different point of view regarding everything in the world
19:27:43 <monochrom> I thought Fromage has already admitted that the whole question is made up?
19:28:17 <Fromage> monochrom: The intial question was ... "Is there any function within the Prelude packae to perform sorting on a list?"
19:28:23 <Fromage> The answer was: NO
19:28:34 <skew> and then walk the stack once to make sure we haven't left the dynamic extent once, before walking again to execute the side effects from try/finally statements
19:28:47 <skew> or, stick an IORef in the continuation and disable it on the way out
19:28:48 <monochrom> But my question is, are you given a practice question that prescribes sorting?
19:29:56 <skew> it seems to me that these dynamic-extent continuations are actually a bit less natural than what you get from CPS
19:29:59 <skew> if they require IO
19:30:01 <RyanT5000> are list comprehensions bad producers?
19:30:16 <skew> they should be good producers - the user's guide says for sure
19:30:16 <sjanssen_> RyanT5000: good producers
19:30:30 <dons> no, I think they're fine. check the RULLES pragma part of the user guide.
19:30:46 <RyanT5000> ok so i'm trying to manipulate a bitmap
19:30:49 <RyanT5000> about 64KB
19:31:07 <RyanT5000> i need to flip it and resize it (not stretch, just add a filled region)
19:31:24 <RyanT5000> is it reasonable to convert it to an associative list and then operate on the associations?
19:31:51 <RyanT5000> or, alternatively, could someone suggest a really good way to do it?
19:32:17 <monochrom> what does flip mean?
19:32:28 <RyanT5000> like, it's upside-down
19:32:31 <RyanT5000> i need to make it right-side-up
19:32:37 <sjanssen_> RyanT5000: the bitmap is an array?
19:32:56 <RyanT5000> well, it starts off as a foreign array
19:33:04 <RyanT5000> and ends up as a foreign array as well
19:33:27 <RyanT5000> but i'd like to see if i can manipulate it in a haskell-friendly way
19:33:36 <monochrom> associative list as in [ (x, y, pixel value), ... ] ?
19:33:42 <RyanT5000> yeah
19:33:47 <jfoutz> i think an a-list would be painfully slow. 
19:33:52 <RyanT5000> you're right :)
19:33:58 <jfoutz> heh
19:34:10 <sjanssen_> jfoutz: not necessarily, with deforestation
19:34:12 <RyanT5000> although i'm not exactly sure why
19:34:29 <jfoutz> i'm not aware of this deforestation of which you speak.
19:34:36 <jfoutz> do you have a link?
19:34:42 <monochrom> [ (x, height - y, p) | (x,y,p) <- original_image ]
19:34:43 <RyanT5000> do i have to turn it on?
19:34:51 <RyanT5000> yeah, that's my flip routine
19:35:05 <sjanssen_> @google site:haskell.org ghc deforestation rules build
19:35:07 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
19:35:12 <RyanT5000> well it's actually height - y - 1
19:35:14 <monochrom> A problem is that a lot of memory is used for each pixel.
19:35:17 <sjanssen_> jfoutz: there you go
19:35:19 <jfoutz> thank you
19:35:21 <jfoutz> :)
19:35:56 <RyanT5000> i figured with lazy evaluation it should be able to completely eliminate the use of the list
19:36:42 <monochrom> Ah, yes, if  the deforestation algorithm is aggressive enough, the generated code is a tight loop over coordinates.
19:36:47 <skew> with lazy evaluation alone it should be able to only have one cell of the list actually exist at a time
19:36:59 <jfoutz> oh, that's slick
19:36:59 <RyanT5000> but it's taking like 10 seconds to copy 64 kbyte
19:37:03 <skew> you need to stack on more optimizations to totally eliminate the list
19:37:21 <RyanT5000> do i need to enable any compiler stuff to make any of that work?
19:37:35 <sjanssen_> RyanT5000: -O
19:37:58 <RyanT5000> http://rafb.net/paste/results/NQYYR356.html
19:38:04 <dons> sjanssen_: btw, i'm peeping at some array fusion stuff as we speak. so hopefully we can use this to remove the intermediate arrays in ByteString code.
19:38:07 <RyanT5000> sjanssen: thanks, i'll try it
19:38:13 <jfoutz> sjanssen: that's freakn' cool.
19:38:28 <RyanT5000> because rendering 150-pixel-high text should not take 10 seconds
19:38:34 <dons> sjanssen_: hmm. functional array fusion for bytestrings would be a good SoC project too :)
19:38:38 <sjanssen_> dons: that is way freaking cool
19:38:57 <sjanssen_> let's see C do that!
19:39:36 <skew> dons: is this related to the Parr code?
19:40:32 <Fromage> dons: Thank you very much again
19:40:40 <Fromage> Quicksort seems to suit very well in my program
19:40:42 <SamB> wouldn't the proper a-list be ((x, y), pixel) ?
19:41:32 <RyanT5000> SamB: yeah that's what i'm using
19:41:50 <SamB> and this is why a high-level language *can* be faster than a low-level language ;-)
19:42:00 <RyanT5000> oh, i expected it to be slow
19:42:01 <dons> skew, my supervisors' yes. http://www.cse.unsw.edu.au/~chak/papers/CK01.html
19:42:08 <RyanT5000> i also expected to be able to use a profiler >:-/
19:42:18 <RyanT5000> but alas, my program crashes on exit
19:42:40 <SamB> I don't see how crashing on exit would inhibit profiling...
19:42:47 <dons> sjanssen_: right. I really wonder if we can beat C now. since we're about the same without fusion... hooray for rewrite rules.
19:43:07 <RyanT5000> SamB: the profiler outputs its data on exit
19:43:13 <RyanT5000> if you know how to get around that, please tell me :)
19:43:19 <SamB> which profiler?
19:43:31 <RyanT5000> -p
19:43:38 <RyanT5000> +RTS -p -RTS
19:43:55 * SamB thought it output continuously
19:44:00 <RyanT5000> nope
19:44:15 <RyanT5000> i hit exit, my program crashes, and i have a nice little 0kb file
19:44:21 <RyanT5000> now, maybe it's related to the fact that i'm on windows
19:44:22 <SamB> ouch!
19:44:27 <SamB> oh, yes, maybe!
19:44:35 <SamB> MSVCRT bug, perhaps?
19:44:42 <RyanT5000> ;)
19:44:48 <RyanT5000> that's the code it's in when it crashes
19:44:52 <RyanT5000> it's deep, deep in that code
19:44:54 <RyanT5000> but it's in that code
19:44:57 <RyanT5000> heapinit.c
19:45:10 <RyanT5000> (by "deep, deep" i mean like 45 stack frames)
19:45:18 <SamB> I meant, the lack of flushing, not the crash...
19:45:24 <RyanT5000> oh
19:45:25 <RyanT5000> welll
19:45:26 <RyanT5000> that too
19:45:30 <RyanT5000> lol
19:45:44 <SamB> or maybe it is a GHC bug.
19:46:00 <RyanT5000> i'm trying to get a linux machine set up, but i'm having trouble with the 3d graphics drivers
19:46:17 * SamB gave up on 3d long ago
19:46:18 <skew> dons: ah, you work with Manuel. I've wondered how you control data distribution in that data parallel model
19:46:27 <sethk> RyanT5000, 3d's not worth the effort
19:46:45 <RyanT5000> sethk: i'm writing a 3d game...
19:46:51 <SamB> about when X decided I couldn't have 3d at this resolution on a Voodoo 3 with only 16 MiB of VRAM, actually...
19:46:55 <sethk> RyanT5000, don't confuse me with details   :)
19:47:08 <RyanT5000> hm i guess i won't try then
19:47:17 <RyanT5000> i'll add that to my pile of reasons to hate linux
19:47:33 <RyanT5000> which is still much smaller than my pile of reasons to hate windows, mind you
19:47:35 <SamB> well, it can work nicely enough
19:47:38 <RyanT5000> but large nonetheless
19:47:50 <skew> dons: like, if you want to distribute a sparse vector and a data set referencing it, so bits of the data set are always with the part of the sparse vector it references
19:47:53 <SamB> its just that the 3d card makers aren't being too nice....
19:48:21 <sethk> RyanT5000, an o/s that is good at 3d would not be good for many other purposes.  It may not be good for your current requirements, but it's foolish to hate it for that reason.
19:48:31 <RyanT5000> sethk: what do you mean?
19:48:40 <RyanT5000> i'm not even asking for "good at 3d"
19:48:48 <SamB> you could look at OS X
19:48:50 <jfoutz> RyanT5000: mac is awesome. bsd goodness plus gl support.
19:48:55 <SamB> it has good 3d drivers ;-)
19:48:59 <sethk> RyanT5000, you said "another reason to hate linux".  That's foolish.  Perhaps 3d is not one of it's target environments
19:49:03 <RyanT5000> i'm asking for "put one goddamn triangle over the AGP bus"
19:49:18 <dons> skew, i think there's variosu ways to pack and distribute things. but i don't do much data parallel stuff. better to check the ndp papers.
19:49:22 <SamB> it has a pile of reasons to be disgruntled as well, of course...
19:49:27 <RyanT5000> sethk: imo, that rules it out as a desktop os
19:49:36 <RyanT5000> SamB: what's the deal with mouse acceleration?
19:49:51 <SamB> RyanT5000: you don't "put one triangle over the AGP bus" afaik...
19:49:53 <sethk> RyanT5000, so, maybe it's a good server o/s.  the point is, there is no justification for an emotional reaction.
19:49:59 <SamB> I think you are supposed to buffer them or something
19:50:07 <RyanT5000> SamB: i was being silly :P
19:50:19 <sethk> SamB, tends to short out the metal things on the mobo   ...
19:50:45 <RyanT5000> sethk: yah fine, but i want to use linux as my desktop OS
19:50:46 <SamB> mouse acceleration?
19:50:49 <RyanT5000> yeah
19:50:50 <jfoutz> linux is awesome. somebody needs to get paid to clean up some of the not fun or academically interesting rough edges.
19:50:54 <RyanT5000> it's totally unusable
19:51:02 <SamB> what do you mean?
19:51:17 <SamB> I don't notice it much
19:51:18 <RyanT5000> the slowdown/speedup is ridiculous
19:51:21 <skew> I'm reading Filinski's masters thesis on continuations and stuff now - maybe it will help
19:51:26 <RyanT5000> i'm used to no acceleration at all
19:51:28 <SamB> maybe you need to adjust it
19:51:38 <RyanT5000> i'm pretty sure you can't turn it off
19:51:42 <RyanT5000> you can change the speed
19:51:45 <sethk> RyanT5000, that's a driver issue anyway, not an o/s issue
19:51:46 <RyanT5000> but not the acceleration
19:51:47 <SamB> you can probably turn it all the way down to 0
19:51:56 <sethk> RyanT5000, and, for goodness sake, you have the source code.  Of course you can turn it off.
19:52:04 <SamB> hahaha
19:52:08 <RyanT5000> :P
19:52:13 <SamB> but he isn't going to compile X, sethk ;-P
19:52:24 <skew> or just give up that crappy OS and start running House
19:52:30 <SamB> especially not with that new modular tree
19:52:36 <sethk> SamB, I've compiled X, it isn't a big deal
19:52:45 <RyanT5000> i was referring to Mac OS X as far as the accel was concerned anyway
19:52:45 <SamB> skew: does it have an FS driver yet?
19:52:50 <SamB> oh.
19:53:12 <SamB> I don't use OS X yet, I am a wannabe user. Or so I think.
19:53:37 <RyanT5000> download it and stick it on one of your intel boxes :)
19:53:43 <RyanT5000> it's really easy to do
19:53:44 <SamB> download it ?
19:53:46 <RyanT5000> er
19:53:50 <RyanT5000> "magically obtain"
19:53:55 <SamB> I have 56k!
19:53:58 <RyanT5000> oic
19:54:00 <RyanT5000> :(
19:54:17 <RyanT5000> i guess you'll need really strong magic
19:54:22 <sethk> damn, I hate having to code in C, even for a little bit.  I'm spoiled.
19:54:23 <RyanT5000> it's like 1.3 GB
19:54:27 <SamB> anyway, I have no free boxes to install it on
19:54:31 <jfoutz> RyanT5000: you can turn acceleration down to 0
19:54:34 <jfoutz> on a mac.
19:54:37 <RyanT5000> how?
19:54:44 <RyanT5000> (i want to know, so i can fix it next time)
19:54:51 <skew> SamB: halfs?
19:54:56 <jfoutz> system prefs->keyboard mouse-> speed slider
19:55:06 <RyanT5000> no that's not accel
19:55:06 <SamB> skew: you mean it is only half of an FS?
19:55:08 <RyanT5000> that's speed
19:55:13 <jfoutz> turn it to 0
19:55:16 <jfoutz> you'll see
19:55:20 <RyanT5000> then my mouse is always slow
19:55:24 <RyanT5000> i want it always medium
19:55:27 <jfoutz> oh
19:55:32 <RyanT5000> i don't want it to change speeds
19:56:23 <RyanT5000> i'm used to having to move 1 inch to get all the way across my screen
19:56:37 <RyanT5000> with no accel
19:56:47 * SamB thinks he has to move two inches, maybe, in X
19:56:50 <jfoutz> yeah. i can see that.
19:57:07 <RyanT5000> what's the word for "picking up your mouse and recentering it on the pad"?
19:57:18 <RyanT5000> there's an actual word for that, but i forget what it is
19:57:21 <skew> @where halfs
19:57:21 <lambdabot> I know nothing about halfs.
19:57:28 <SamB> RyanT5000: I don't know!
19:57:33 <skew> @where+ halfs http://www.haskell.org/halfs
19:57:34 <lambdabot> Done.
19:57:56 <skew> SamB: something Galois made
19:58:14 <jfoutz> i got a mac last summer. i don't notice the accel anymore. OTOH i have accelerators for everything but websurfing.
19:58:48 <RyanT5000> yeah i try to use the keyboard as much as possible, but for things like switching windows the mouse isn't so bad
19:59:11 <RyanT5000> also, dragging and dropping code is way faster than navigating with arrow keys, when you have to do certain things
19:59:23 <jfoutz> command - tab. 
19:59:38 <RyanT5000> yah, alt-tab in windows
19:59:42 <RyanT5000> but when i have like 40 windows open
19:59:45 <RyanT5000> it gets dicey
19:59:56 <RyanT5000> especially when 25 of them are firefox, with the same icon
19:59:57 <SamB> I'm told that sawfish or somesuch has a nice keyboard-based window switching feature, but I really doubt it would help me navigate my dozen xterms and (typically) half-dozen emacs windows...
20:00:17 <SamB> 25 firefox windows?
20:00:21 <SamB> dude!
20:00:33 <SamB> that is what tabs are for, is it not?
20:01:00 <Korollary> SamB: Why do you have a half dozen emacs windows anyway? 
20:01:11 <RyanT5000> well
20:01:11 <jfoutz> ryan, several things. first i have a alt-tab replacement that let's you tab around by group. it pops up the list of icons like windows, but arranged verticaly with names next to them.
20:01:22 <SamB> Korollary: well, not always
20:01:25 <RyanT5000> SamB: i use tabs too
20:01:31 <cmarcelo> hey guys. to get some feedback about my SoC application is it ok to send to the interested mentor?
20:01:38 <SamB> RyanT5000: you must have an awful lot of RAM
20:01:38 <RyanT5000> i usually make a new window for a new search, and then use tabs for all the stuff i look at related to that
20:01:41 <RyanT5000> 1 GB
20:01:53 <SamB> cmarcelo: you should bug the mentor to go look at it on the SoC site
20:01:56 <Korollary> SamB: I recently broke my personal record at work with 200 buffers in one emacs :)
20:01:56 <RyanT5000> that's as much as my laptop can take
20:02:01 <SamB> cmarcelo: that is what I did!
20:02:28 <SamB> Korollary: well, I for some reason tend to start new instances
20:02:56 <cmarcelo> SamB: all mentors have access to it?
20:03:07 <SamB> apparantly!
20:03:35 <Fromage> Hey
20:03:40 <Fromage> I want to propose you an interesting problem
20:04:17 <Fromage> It's about creating a function that, given a set of elements from 1 to n [1..n] it returns a list of sublists following this pattern :
20:04:43 <Fromage> [[1],[2,3],[4,5,6],[7,8,9,10],[11,12,13,14,15] ... ]
20:07:35 <mux> > [ [1..x] | x <- [1..5] ]
20:07:36 <lambdabot> [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
20:07:46 <RyanT5000> let { f n l = take n l : f (n+1) $ drop n l ; f _ [] = [] } in f [3, 2, 5]
20:07:46 <mux> oh, duh
20:07:50 <RyanT5000> > let { f n l = take n l : f (n+1) $ drop n l ; f _ [] = [] } in f [3, 2, 5]
20:07:51 <lambdabot> Couldn't match `[[a]]' against `t -> t1'
20:07:51 <mux> badly read what you wrote :-)
20:07:56 <RyanT5000> gah
20:08:17 <RyanT5000> > let { f n l = (take n l) : (f (n+1) (drop n l)) ; f _ [] = [] } in f [3, 2, 5]
20:08:17 <lambdabot> Couldn't match `Int' against `[a]'
20:08:19 <jfoutz> RyanT5000: if you're stuck on a mac again : http://lavacat.com/iMouseFix/
20:08:28 <RyanT5000> cool, thanks :)
20:08:49 <Fromage> RyanT5000: 
20:08:53 <RyanT5000> oh well, i took a stab at it :P
20:09:05 <Fromage> The function should work only on sorted lists
20:09:10 <Fromage> That always start with a 1
20:09:10 <RyanT5000> i can't be bothered to actually debug that, but it's the basic idea
20:13:44 <RyanT5000> heh i think i know what the problem is with my program crashing on exit
20:13:50 <RyanT5000> :)
20:13:58 <RyanT5000> SDL is built with visual studio
20:14:08 <RyanT5000> gcc is built with msys
20:14:16 <RyanT5000> i think the libraries don't like each other
20:23:43 <Lemmih> ah.
20:24:12 <RyanT5000> also, i actually meant ghc
20:24:19 <RyanT5000> the RTS in particular
20:24:54 <RyanT5000> wow... compiling sdl takes a long time in msys
20:25:00 <RyanT5000> configuring, rather
20:25:57 <Cale> > let chop xs = chop' 0 xs where chop' n xs = take n xs : chop' (n+1) (drop n xs) in chop [1..10]
20:25:59 <lambdabot> [[],[1],[2,3],[4,5,6],[7,8,9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[
20:25:59 <lambdabot> ],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]
20:25:59 <lambdabot> ,[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],
20:25:59 <lambdabot> [],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[
20:26:01 <lambdabot> ],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]
20:26:02 <Cale> oops :)
20:26:04 <lambdabot> [6 @more lines]
20:26:20 <Cale> well, add a base case to that, and we're good
20:26:59 <Cale> > let {chop xs = chop' 0 xs where chop' n [] = []; chop' n xs = take n xs : chop' (n+1) (drop n xs)} in chop [1..10]
20:27:00 <lambdabot> [[],[1],[2,3],[4,5,6],[7,8,9,10]]
20:27:15 <Cale> > let {chop xs = chop' 1 xs where chop' n [] = []; chop' n xs = take n xs : chop' (n+1) (drop n xs)} in chop [1..10]
20:27:16 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10]]
20:27:35 <Cale> Fromage: I think that was the behaviour you wanted?
20:27:57 <Cale> could also use splitAt
20:28:43 <Cale> > let {chop xs = chop' 1 xs where chop' n [] = []; chop' n xs = let (a,b) = splitAt n xs in a : chop' (n+1) b} in chop [1..10]
20:28:44 <lambdabot> [[1],[2,3],[4,5,6],[7,8,9,10]]
20:31:00 <RyanT5000> Lemmih: what is libSDL.la?
20:32:05 <Lemmih> RyanT5000: A libtool file.
20:32:51 <RyanT5000> alright, thanks
20:32:52 <Fromage> Yeah, Cale 
20:32:55 <Fromage> Thank you very much
20:33:08 <Fromage> But I've already writen my own version
20:33:15 <Fromage> It'a bit more complex, though :(
20:34:14 <RyanT5000> does anyone know how to use a .dll.a?
20:34:24 <RyanT5000> ooooh that must be the import lib
20:34:49 <RyanT5000> 100k+?
20:34:54 <RyanT5000> that most certainly can be wrong
20:35:04 <RyanT5000> not saying it is
20:35:09 <RyanT5000> just that it can be
20:35:39 <RyanT5000> trillian has how many millions of downloads and still isn't so great at IRC?
20:35:46 <jfoutz> hey now. bonsai buddy has like 1000,000 how could that be wrong?
20:36:33 <RyanT5000> lol yeah
20:40:58 <jfoutz> what the heck does fmap do?
20:41:10 <RyanT5000> @hoogle fmap
20:41:11 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
20:41:11 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
20:41:11 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
20:41:20 <RyanT5000> maps a function across a functor
20:41:28 <araujo> it's a mapping for data constructors.
20:41:30 <RyanT5000> a functor being some kind of container, usually
20:41:57 <jfoutz> so... i have some scheme and some lisp background. i *get* map
20:42:06 <jfoutz> but you don't fmap over lists...
20:42:23 <sjanssen_> jfoutz: for lists, fmap == map
20:42:38 <monochrom> what, FunctorAsContainer?!  Cale!  XD
20:42:56 <jfoutz> > fmap id [1,2,3]
20:42:57 <lambdabot> [1,2,3]
20:43:01 <Cale> monochrom: well, yes
20:43:09 <jfoutz> hmm.
20:43:12 <sjanssen_> > fmap (+2) (Just 1)
20:43:13 <lambdabot> Just 3
20:43:18 <sjanssen_> > fmap (+2) Nothing
20:43:19 <Cale> monochrom: it's just a container with fewer assumptions made about it :)
20:43:19 <lambdabot> Nothing
20:43:25 <Cale> (at least in Haskell)
20:43:43 <monochrom> Yes of course.
20:43:51 <jfoutz> ok. so it's more like lisp's map. 
20:44:08 <jfoutz> i haven't used arrays but presumably you can fmap across them?
20:44:29 <sjanssen_> jfoutz: I believe
20:45:02 <jfoutz> i'm finding myself writing code like this : 
20:45:35 <jfoutz> ... cut n paste problem... one sec
20:45:36 <sjanssen_> > fmap sin $ array (0, 1) [(0, pi), (1, 2 * pi)]
20:45:37 <lambdabot> array (0,1) [(0,1.2246063538223773e-16),(1,-2.4492127076447545e-16)]
20:45:42 <sjanssen_> jfoutz: there you go
20:45:53 <jfoutz> boolean = char '#' >>= flip fmap (string "t" <|> string "f") . (:)
20:46:13 <jfoutz> and i think i understand everything but the fmap
20:46:17 <monochrom> The array module has "instance Functor (Array a)" too
20:47:18 <jfoutz> so a parser is another fmappable thing. presumably that has a single element that's getting called.
20:47:39 <jfoutz> haskell is so different.
20:47:45 <Korollary> jfoutz: fmap gives for a function (a->b) a function (f a -> f b) for any f that is an instance of Functor (eg, Array, list, Maybe, etc.)
20:48:03 <Lemmih> jfoutz: That's the same as 'liftM2 (:) (char '#') (string "t" <|> string "f")', btw.
20:48:39 <Cale> jfoutz: my guess is that you're on the scheme in 48 hours tutorial?
20:48:44 <jfoutz> Lemmih: that makes more sense to me. lambdabot converted my lift attempt to an fmap. that's what i get for listening to a bot
20:48:53 <jfoutz> Cale: yea
20:48:54 <jfoutz> y
20:49:00 <jfoutz> stupid fingers
20:49:05 <jfoutz> Cale: , yes.
20:49:06 <Cale> jfoutz: that seems to be a weak point of that tutorial, I should let the author know :)
20:49:24 <jfoutz> also, his booleans are broken.
20:49:27 * Korollary finally has  time to read some more TaPL.
20:49:29 <Cale> Does it explain what a type constructor is at some point?
20:50:08 <jfoutz> yeah there's a bit at the start about data
20:50:08 <Cale> (I haven't actually read it myself)
20:50:11 <Cale> okay
20:50:21 <jfoutz> i'm jumping around a lot.
20:51:05 <Cale> Let's write a nice instance of Functor ourselves, perhaps it will make more sense after that.
20:51:14 <jfoutz> but there is an honest to goodness bug in the tutorial
20:51:28 <monochrom> If you use fmap for parsers, i.e., fmap :: (a->b) -> Parser a -> Parser b ...  then "fmap f p" = do {x <- p; return (f x)}
20:51:35 <jfoutz> telll the author to add "#" to the list of symbols
20:52:44 <jfoutz> monochrom: that is good. the effect i'm looking for.
20:52:46 <monochrom> "Scheme in 48 hours" = let's write a Scheme interpreter using Haskell in 48 hours?  Sounds like some kind of Galois.com code jam...
20:53:11 <jfoutz> it's not a real scheme interpreter. just the easy bits.
20:53:26 <jfoutz> for example no #i3/4@5/9 support
20:53:32 <jfoutz> cause that's insane.
20:53:43 <jfoutz> also no let syntax
20:54:09 <jfoutz> but it's a good meaty project. longer than hello world and vaguely useful.
20:55:12 <jfoutz> cale, so to be a functor, i need fmap
20:55:34 <jfoutz> where fmap id == id
20:55:39 <Cale> yep
20:55:51 <Cale> and fmap f . fmap g = fmap (f . g)
20:55:54 <jfoutz> and fmap (f . g) = fmap f . fmap g
20:56:02 <jfoutz> you type more faster. :)
20:56:02 <Cale> right
20:56:39 <jfoutz> so... for list id = [] ?
20:57:00 <Cale> fmap f [] = []
20:57:14 <Cale> fmap f (x:xs) = f x : fmap f xs
20:57:44 <Cale> brb
20:59:27 <jfoutz> > fmap id Nothing
20:59:28 <lambdabot> Add a type signature
21:00:19 <jfoutz> > fmap id Nothing :: Maybe
21:00:20 <lambdabot>   Kind error: `Maybe' is not applied to enough type arguments
21:00:20 <lambdabot>   In an expression type signature: Maybe
21:00:20 <lambdabot>   In the expression: fmap id Nothing :: Maybe
21:01:41 <jfoutz> fmap id Nothing :: Maybe a
21:01:54 <jfoutz> > fmap id Nothing :: Maybe a
21:01:55 <lambdabot> Add a type signature
21:02:18 <monochrom> Maybe Bool  (for example)
21:02:37 <jfoutz> fmap id Just 1
21:02:41 <jfoutz> doh
21:02:46 <jfoutz> > fmap id Just 1
21:02:47 <lambdabot> Just 1
21:03:58 <stepcut> whee! I appear to have an unregistered version of GHC working on the ARM9
21:04:08 <jfoutz> > fmap (1 ==) Just 1
21:04:09 <lambdabot>  add an instance declaration for (Num (Maybe a))
21:04:26 <jfoutz> meh. i'll figure it out eventualy.
21:04:34 <jfoutz> thanks, everybody. g'night.
21:04:38 <monochrom> you mean unregisterised!  there is no need to register (ghc is not shareware! XD )
21:06:06 <stepcut> monochrom: yeah, I made that same mistake earlier --enable-bc-boot-unregistered does not work as well as --enable-bc-boot-unregisterised ;)
21:07:02 <stepcut> what is the disadvantages of being unregisterised ? Is it just slower? Or are there things that do not work? (threading? some ffi stuff ?)
21:07:17 <monochrom> I think it is slower.
21:07:58 <rhzi151> ?
21:07:59 <stepcut> It looks like it is pretty easy to registerise the build -- *if* you know what you are doing :)
21:08:21 <rhzi151> no
21:10:09 <rubenz> rhzi151@oboe19:/tmp_amd/eno/import/2/rhzi151/HOpenGL-1.05$
21:10:38 <rubenz> is it posible to install HOpenGL after GHC has been installed?
21:11:34 <Cale> back
21:11:43 <RyanT5000> yes, you want to use Cabal (using Setup.lhs) or ghc-pkg
21:14:27 <rubenz> what if I don't have system access priviledges? I.e. just ordinary users priviledges?
21:16:55 <RyanT5000> there's a flag for that using Cabal
21:17:04 <RyanT5000> i've never used it though
21:17:15 <RyanT5000> i think it's install --user, but i'm not sure
21:18:24 <rubenz> When I type "ghc-pkg describe HOpenGL" it says "ghc-pkg: cannot find package HOpenGL"
21:18:48 <RyanT5000> yeah, that means it isn't in your package configuration file
21:19:01 <RyanT5000> i don't think you can add it to that if you don't have root
21:19:14 <RyanT5000> although you might be able to make a user package config file
21:19:15 <rubenz> ok..
21:19:27 <RyanT5000> (i run on windows.... we don't have security)
21:20:31 <rubenz> I tried "ghc-pkg register HOpenGL --user" but it didn't work either.
21:20:48 <rubenz> I got this "Reading package info from "HOpenGL" ghc-pkg.bin: HOpenGL: openFile: does not exist (No such file or directory)"
21:23:33 <carp> evening
21:25:45 <Cale> hello
21:27:52 <carp> Cale: are you in the states? it's terribly late/early in the uk
21:30:16 <edwinb> morning carp
21:30:32 <carp> morning, what are you doing up?
21:30:35 <carp> i've just come home
21:30:43 <edwinb> I'm in the states ;)
21:30:51 <carp> fair ;)
21:31:24 <edwinb> come home from where?
21:31:32 <carp> we had an epigram meeting today
21:31:41 <edwinb> it clearly ran late...
21:31:46 <carp> dodgy nightclub in nottingham 
21:31:51 <edwinb> aha
21:32:18 <carp> wouter was going to blog it, doesn't seem to have appeared so far
21:32:30 <edwinb> I look forward to catching up tomorrow then...
21:32:43 <carp> we were trying to work out where we got to before we got conferenced
21:33:33 <edwinb> it's been a while ;)
21:33:46 <carp> peter is looking at datatypes, conor and i are going to look at proof state, and then we'll take it from there
21:33:58 <carp> :)
21:34:01 <Cale> carp: Ontario, Canada
21:34:06 <carp> it has been a bit mental
21:34:09 <edwinb> cool
21:34:15 <carp> Cale: :)
21:34:26 <carp> I should really be asleep
21:34:33 <edwinb> probably ;)
21:34:50 <carp> i'm going to the isle of wight tomorrow
21:34:57 <carp> long weekend
21:35:10 <edwinb> I hope you're not leaving too early!
21:35:27 <carp> those of us how don't have proper jobs are going early :)
21:35:37 <edwinb> heh
21:35:48 <edwinb> hooray for improper jobs!
21:35:54 <carp> :)
21:37:10 <carp> so it's me a jounalist, a professional rugby player, an entrepreneur, and some other wasters...
21:37:31 <carp> why are you state side?
21:37:45 <edwinb> I'm visiting the meta-programming gang at Rice
21:37:51 <carp> fair
21:38:19 <edwinb> working on a paper for GPCE on dependent types and multi stage programming.
21:38:29 <edwinb> and generally suffering from the heat ;)
21:38:37 <carp> gpce? i suppose i could google it
21:38:51 <edwinb> generative programming and component engineering
21:38:56 <carp> oh
21:41:00 <carp> not hongwei and aaron's workshop then
21:41:10 <edwinb> which one is that?
21:41:15 <carp> we should send some stuff  that
21:41:34 <edwinb> oh, that one
21:42:11 <carp> http://cl.cse.wustl.edu/plpv06/
21:42:17 <carp> yeah
21:42:20 <edwinb> yes, I remember now
21:42:27 <carp> floc is a bit mental!
21:43:00 <carp> you know of the ghc hackers's meeting i presume?
21:43:12 <edwinb> no...?
21:43:30 <carp> oh, (looks for email link)
21:44:29 <carp> i suppose hackathon is the operative work
21:44:48 <edwinb> ah, I see it
21:45:11 <carp> http://cvs.haskell.org/trac/ghc/wiki/Hackathon
21:45:39 <carp> i'd like to go, not sure if i'm gonna head to america this summer though
21:45:46 <edwinb> Yes, that sounds interesting.
21:46:08 <edwinb> I will have to get a paper accepted for the Haskell workshop if I want someone else to pay my way though ;)
21:46:14 <carp> :)
21:46:44 <carp> what's you plan in that respect? (if this isn't to public)
21:47:10 <carp> conor and joel (and potentially duncan) are planning on writing something
21:47:13 <edwinb> I was going to write something about this theorem proving api
21:47:21 <carp> fair
21:47:30 <edwinb> But I've a feeling I'm going to leave it until the last minute and do a shoddy job as usual...
21:47:58 <carp> it's difficult to do otherwise if you have other pressing things to do
21:48:13 <edwinb> I'll hope the other submissions are the same then ;)
21:49:08 <carp> we're planning to get back to some hacking this summer by the way, you should come and visit us again
21:49:50 <carp> there is still talk of some kind of retreat...
21:49:56 <carp> maybe for a week
21:50:02 <edwinb> come up to Scotland then!
21:50:20 <carp> sounds like a sensible plan
21:50:45 <edwinb> an epigram hackathon sounds fun too...
21:52:47 <edwinb> right, I'm going to bed. You should too ;)
21:52:50 <carp> i've been touting a place in norfolk that i might be able to sort out
21:53:08 <edwinb> nice
21:53:21 <carp> i might just push on through, 'til dawn, oh it's morning alreay
21:55:01 <edwinb> night night
21:56:04 <carp> goodnight
22:04:49 * carp wonders if anyone else is still awake
22:05:03 <musasabi> morning
22:05:10 <carp> morning
22:06:19 <carp> musasabi: are you a hide hacker?
22:07:11 <Philippa> 'mhere
22:07:49 <carp> musasabi: just wondering...
22:08:16 <musasabi> carp: no, too many projects already.
22:08:21 <carp> fair
22:09:50 <carp> i was wondering if hsplugins is going to be subsumed by the ghc-api
22:10:46 <carp> there was some talk yesterday afternoon about using hsplugins in for epigram, i was wondering if we were a bit out of date
22:11:52 <musasabi> hs-plugins is going to use GHC-API internally I think. dons would know better.
22:12:22 <carp> ok
22:12:24 <musasabi> So using hs-plugins will offer a more stable and well known API.
22:13:12 <carp> it's quite a way off for us i suppose so it's just idle curiosity
22:13:52 <Philippa> I'd imagine that the part that uses hs-plugins directly'd be fairly small anyway?
22:14:26 <carp> it would be compiling stuff using edwin's compiler and the loading it in
22:14:51 <carp> just wondering
22:16:23 <carp> Phillipa: are you finishing this year?
22:16:50 <carp> Philippa
22:16:55 <Philippa> nope, still wasn't in a happy state back in january. Plus I seem to've ended up acting as my new housemate's carer
22:17:22 <carp> you should probably knock it on the head, i reckon
22:17:40 <carp> it's only an ungrad after all
22:18:05 <Philippa> it doesn't really work like that. I've barely enough 'good' time to keep myself intact and keep up with all my relationships
22:19:05 <Philippa> (well, all two plus the carer thing - and looking after Marianne's a lot like looking after myself, it's not as much work as if I were acting as a carer for someone less like myself)
22:19:50 <RyanT5000> hm so i got really pissed of at windows
22:20:01 <RyanT5000> i'm now on my ubuntu box
22:20:33 <RyanT5000> in any case, i presume .p_hi files are "with profiling"
22:20:38 <musasabi> yes
22:20:55 <RyanT5000> is there an argument to Setup.lhs i can give to make it do a profiling build?
22:21:35 <musasabi> -p
22:21:45 <musasabi> for the configure phase.
22:22:17 <RyanT5000> huh, i thought i tried that
22:22:47 <RyanT5000> yeah, unrecognized
22:23:00 <RyanT5000> do i need something else before it?
22:23:12 <skew> the symmetric lambda calculus might finish teaching me duality. If only I could figure out this bit about cocurrying coproduct-returning functions
22:23:46 <musasabi> RyanT5000: try runghc Setup.lhs configure --help
22:23:58 <RyanT5000> yeah i'm looking in that
22:24:02 <musasabi> RyanT5000: what version of Cabal do you have?
22:24:12 <RyanT5000> the one that apt-get got me along with ghc6
22:24:14 <RyanT5000> :P
22:24:22 <RyanT5000> 1.0
22:24:38 <RyanT5000> i am a complete linux n00b
22:25:59 <musasabi> RyanT5000: you need a newer version of Cabal
22:26:10 <RyanT5000> @where cabal
22:26:11 <lambdabot> http://www.haskell.org/cabal
22:26:18 <musasabi> either install a standalone version or get GHC 6.4.2
22:26:34 <RyanT5000> how about ghc 6.5?
22:26:59 <RyanT5000> although installing on linux is still scary to me :P
22:30:45 <RyanT5000> @where ghc
22:30:46 <lambdabot> http://haskell.org/ghc
22:31:03 <RyanT5000> is there a @where for darcs repositories?
22:31:19 <carp> is ghc 6.4.3 going to be along shortly do you think?
22:31:43 <carp> 6.4.2 doesn't work very well for me via darwinports
22:32:06 <carp> the darcs repo is at http://darcs.haskell.org/ghc
22:32:44 <carp> and then you do ./darcs-all get to get the rest of the stuff
22:42:38 <sethk> Pity me, I've been hacking on my device driver tonight.
22:44:34 <monochrom> At least it is yours, not someone else's.
22:45:08 <sethk> monochrom, quite true.  I had to repair the ICH smbus driver in the linux kernel a few weeks ago, and I was not in a good mood.  :)
22:46:39 <sethk> monochrom, actually it wasn't that bad, once I realized that it was totally broken and could never have worked even a little.
22:46:51 <sethk> but who looks for that in a driver for common intel hardware?
22:50:10 <RyanT5000> i'm so confused; glxgears runs *really fast* for like 3 seconds, then chugs
22:50:23 <RyanT5000> does that mean i have 3d graphics working?
22:50:36 <swoolley-voted> for 3 seconds
22:50:43 <RyanT5000> lol
22:50:53 <skew> RyanT5000: are you sure it's not running really fast for a while, and then going even faster to hit some multiple of your refresh rate?
22:51:00 <swoolley-voted> try glxinfo
22:51:29 <RyanT5000> what am i looking for?
22:51:39 <RyanT5000> oh
22:51:45 <RyanT5000> it says "direct rendering: No"
22:51:58 <swoolley-voted> then there's no direct rendering
22:52:05 <RyanT5000> how do i enable it?
22:52:23 <RyanT5000> sorry about being off-topic, but i'll take it elsewhere if it takes much effort
22:52:47 <skew> when I got 3d acceleration working I was like "oh no, glxgears is running so slow", until I realized it was actually spinning ~207+1e-4 times in each refresh interval.
22:53:05 <RyanT5000> lol
22:54:39 <RyanT5000> skew: no i'm not really sure that isn't what's happening
22:54:46 <RyanT5000> but i need direct rendering, i think
22:57:56 <skew> glxgears prints out a frame rate as it runs. Are you specifying modules like "DRI" in the X config?
22:58:57 <RyanT5000> skew: would that be /etc/X11/config?
22:59:20 <RyanT5000> ah i guess xorg.config
22:59:22 <RyanT5000> .conf
22:59:42 <RyanT5000> well it says Section "DRI" Mode 0666
23:22:26 <bmp> Is this channel newbie-friendly or should I go ask questions somewhere else?
23:22:35 <Korollary> very newbie friendly
23:22:48 <Korollary> except for homework questions
23:23:17 <bmp> I graduate in a week, and the only "homework" I've got is an in-class algorithms exam. You're safe. :)
23:23:25 <Korollary> congrats then
23:23:34 <bmp> Thanks.
23:24:03 <bmp> So I'm completely new to statically typed functional languages. I saw the "Scheme in 48" hours tutorial, and started following it, but got very frustrated that I can't do one of their really basic exercises.
23:24:17 <Korollary> damn that tutorial is popular
23:24:25 <bmp> They propose reading in a couple of args from the command line, turning them to numbers, adding them, and then spitting out the sum.
23:24:32 <bmp> Well, it's a cool tutorial. :)
23:24:54 <bmp> And I suspect that part of its appeal is that there are a lot of Schemers who have implemented Scheme in Scheme, so this is an interesting introduction to Haskell.
23:25:08 <RyanT5000> how do i strip ^Ms out of a file easily?
23:25:11 <bmp> Anyway, I'm missing something really simple about how the typing works.
23:25:16 <RyanT5000> (sorry for so much off-topic stuff lately)
23:25:27 <Korollary> RyanT5000: with filter?
23:25:37 <RyanT5000> thanks
23:25:42 <monochrom> Can you already read in args?
23:25:55 <bmp> Yes, as strings.
23:26:17 <monochrom> You will get a list of strings.  The type is [String].
23:26:35 <bmp> putStrLn $ "Sum is " ++ (args !! 0)
23:26:39 <bmp> That works fine.
23:26:44 <monochrom> For each of them, you can do ...
23:26:52 <bmp> I'm getting a type error on read.
23:26:54 <monochrom> > read "143" :: Int
23:26:55 <lambdabot> 143
23:27:16 <Korollary> Well, from what I see, that tutorial uses words like "monad, action, lift" on page 2. I'd have a problem with that if I was a beginner.
23:27:28 <bmp> Huh. I just got it working.
23:27:33 <bmp> putStrLn $ "Sum is " ++ show (read (args !! 0) :: Int)
23:27:40 <monochrom> read is polymorphic.  too polymorphic sometimes.  You want to give a type.
23:27:56 <bmp> monochrom: Thanks. I knew I needed to give it a type, but I couldnt' find an example of *how*
23:28:02 <bmp> Your suggestion worked
23:29:01 <bmp> This is a very different mindset than Lisp/Smalltalk/Ruby...
23:29:54 <monochrom> Yes, quite.
23:31:14 <monochrom> But not quite, in most cases.  When I write in Lisp or Perl, I find myself assigningtypes in my mind.
23:31:33 <Korollary> monochrom: perl is quite typed imho
23:36:55 <skew> the big difference is that Lisp/Smalltalk/Ruby doesn't dispatch based on those types
23:37:01 <monochrom> Perl lacks type expressions.  It becomes a visible difference when you have to write in comments "x is a hash of lists of hashes of ints" and cannot write x::{[{Int}]} in code.
23:39:15 <skew> inference to deduce types from code and  classes to deduce behaviour from types make a nice team
23:43:01 <Korollary> monochrom: because Int is not one of perl's types. The scalar ($) type has values like ints, floats, strings, etc. (but not arrays or hashes).
23:44:24 <monochrom> I still cannot write x::{[{Scalar}]} in code, can I?
23:44:46 <Korollary> You already wrote as much as you could.
23:45:18 <monochrom> How do you write x::{[{Scalar}]} in Perl?
23:45:35 <Korollary> It's similar to our not being able to say x :: prime int -> prime int. There's no prime int type. There's int, which encompasses it.
23:46:58 <musasabi> one can say (x :: PrimeInt -> PrimeInt)
23:47:25 <musasabi> where the type PrimeInt carries the proof of the associated Int being prime.
23:47:59 <Muad_Dibber> got an example musasabi?
23:48:05 <Korollary> musasabi: not in H98
23:48:38 <Korollary> maybe with dependent types kind of stuff can carry such a proof
23:48:46 <musasabi> In GHC-Haskell
23:48:56 <skew> you can just make an ADT that only admits primes
23:49:44 <Korollary> skew: do you mean gadt?
23:50:04 <musasabi> example for even numbers, primes would take lots of code and type level comptation
23:50:42 <skew> for this point, it's not important to do it totally in the type system
23:51:26 <skew> like, Map a b corresponds to binary search trees with some balancing constraints, even though it's not completely expressed in the type system
23:51:29 <Korollary> skew: right. but my example was about types.
23:52:12 <skew> so, can you make and annotate with more specific types in perl?
23:52:57 <Korollary> skew: no, it's as specific as it gets. Even "yadda" + 5.0 is defined to yield another scalar.
23:53:20 <skew> then musasabi's point stands - he can't get any more specific that the types built into the language
23:53:30 <kzm> With GHCi, is there a way to use :m in a qualfied way?
23:53:35 <skew> he - she - it - ?
23:53:56 <kzm> :m + ??? => import qualified Foo.Bar.Zot as Z?
23:54:04 <skew> expressing everything in the type system is a bonus
23:54:25 <Korollary> no, musasabi said that there were no types at all. They are there, but they are more general than we're used to.
23:55:32 <skew> using the module system and the type system together to limit the code that must be verified to single module is pretty good
23:56:57 <skew> actually, if your encoding of properties into the type system is sufficiently abusive, it might not be any easier to argue that the type means what you want it to mean than it would be to argue that the code behaves properly
23:57:06 <skew> like, things you see built out of MPTC
23:57:22 <skew> and fundeps and existentials and gadts, all rolled together
23:57:31 <Korollary> I dont follow
23:58:10 <Korollary> ok I read that again
23:58:42 <Korollary> yeah, I am not sure if the code is always clearer when proved by the type system.
23:58:54 <skew> I read musasabi as talking about user-defined types
23:59:03 <RyanT5000> now, with cost centers, does that take into account lazy evaluation?
23:59:07 <skew> which do seem to be lacking from perl, or at least second-class
23:59:27 <musasabi> data Z; data S a; class Even a; instance Even Z; instance Even a => Even (S (S a)); data EvenInt where EvenInt :: (ToNum a, Even a) => a -> EvenInt; class ToNum a where toNum :: a -> Int; instance ToNum Z where toNum = 0; instance ToNum a => ToNum (S a) where toNum x = 1 + toNum (w x) where w :: S a -> a; w _ = undefined
23:59:30 <RyanT5000> so if f x gets lazily evaluated in g, does that get charged to f or g?
23:59:32 <skew> you seemed to be talking about doing things entirely in the type system, which is a bit different
23:59:43 <skew> RyanT5000: I think that all works out
