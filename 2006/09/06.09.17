01:07:20 <bourbaki> bk
01:46:59 <Sal> #join
01:48:02 <dons> why do you always type #join, Sal? :)
01:48:18 <dons> it remains a mystery
01:50:13 <Patterner> it's not for us mortals to know...
02:04:02 <bartw> moi
02:04:25 <dons> moin bartw
02:04:43 <bartw> +n
02:04:46 <bartw> hi dons
02:09:08 <bartw> yes i think i actually like monads
02:11:47 <bartw> does haskell add anything besides sugar tpo allow monads or could you use them in any functional language ?
02:12:31 <integral> there's papers showing scheme impls :)
02:12:32 <dons> well, it helps to have lazy evaluation, an expressive type system and syntactic support. also type classes
02:12:44 <dons> but you can certainly do it. even C++ has monads -- theyre just nasty and unusable
02:13:33 <bartw> let me see if i understand the io monad
02:13:35 <dons> so, whether you can do it, and whether its convenient enough to do significant design with, are two separate issues
02:13:47 <bartw> you start with a monad that describes the initial state
02:14:08 <bartw> you do a read that yield the monad value of having read something
02:14:49 <bartw> so in the end you have a chain of monad values from the start
02:15:03 <dons> yep, that's a fair description
02:15:29 <dons> so, a chain of monadic "actions" is isomorphic to a sequence of imperative statements, threading the global state of the program
02:16:00 <bartw> except that the 'flow' is in the evaluation order, not in the statment order
02:17:08 <bartw> hmz, i guess that really reduces the options for threaded evaluation
02:18:05 <bartw> cool stuff ;)
02:20:13 <dons> well, you can run separate chains of monadic actions is separate threads. but you're write: imperative == hard to parallelise
02:20:23 <integral> newtype Par a = Par a; instance Monad Par where { return x = Par x; (Par x) >>= f = Par (par x (f x)) -- hmm, like this?
02:21:04 <dons> or you can have parallel statements in a Parallel monad :)
02:21:17 <dons> it's all up for grabs when you can abstract over the order of evaluation
02:21:45 <integral> probably want a par in return too I guess
02:22:19 <bartw> i have to read some more tutorials before i can grok that line :)
02:32:24 <sieni> dcoutts: awake?
02:40:14 <dons> could people knowledgible in particular haskell problem areas make some recommendations on libraries to use, here? http://haskell.org/haskellwiki/Recommendations
02:40:17 <lambdabot> Title: Recommendations - HaskellWiki, http://tinyurl.com/jpl7v
02:40:36 <dons> (a stop-gap measure until we have hackagedb tracking popularity)
02:50:23 <yacstud> hi
02:52:18 <xerox> ?yow
02:52:19 <lambdabot> It's a lot of fun being alive ... I wonder if my bed is made?!?
02:53:44 <dons> glguy: can you add the math challenge (and any others ?) to http://haskell.org/haskellwiki/Programming_contests
02:53:47 <lambdabot> Title: Programming contests - HaskellWiki, http://tinyurl.com/hs57e
02:57:46 <bartw> do you need to be an acm member for icfp and such ?
02:59:07 <dons> nope
02:59:23 <dons> open to anyone, anywhere, in any language
02:59:28 <ValarQ> @users
02:59:30 <lambdabot> Maximum users seen in #haskell: 236, currently: 211 (89.4%), active: 14 (6.6%)
02:59:36 <bartw> sorry i meant the conference
03:00:15 <bartw> i've been saying for years that i would join the icfp contest in a self written language but still haven't ;)
03:00:34 <ValarQ> dons: how does lambdabot handle the 'Maximum users' value?
03:01:09 <dons> it keeps track of users, and stores the result to disk. sometimes i forget to save that file though, when updating lambdabot (i.e. its been wiped twice by accident)
03:01:22 <ValarQ> ok
03:01:26 <dons> bartw: no, I don't think you have to be in acm or any other org.
03:01:42 <ValarQ> i was thinking of doing a top5 botusers plugin...
03:02:01 <dons> oh, interesting. so keep track of who is typing the most commands to the bot?
03:02:09 <ValarQ> yeah
03:02:27 <dons> would be a little tricky. since you'd need to modify the base plugin to intercept all commands, and check the nick.
03:02:42 <dons> it would be easiest as part of Plugin/Base.hs I think
03:02:53 <ValarQ> ok...
03:03:07 <ValarQ> does all commands go through Base?
03:03:10 <dons> add a Map Nick Int state to Base.hs, and update that tree on each command invocation
03:03:14 <dons> yes
03:03:23 <dons> it takes all commands, and then dispatches calls to the other plugins
03:03:49 <dons> other plugins only see what they've given. Base.hs sees all -- and can thus produce statistics on all commands
03:04:14 <ValarQ> ok, there is no way to match on all commands?
03:04:32 <ValarQ> or can only one plugin get triggered?
03:04:55 <dons> only one. except for'contextual' data (i.e. non-command data)
03:05:04 <ValarQ> ok
03:06:00 <dons> freaky, http://www.cs.uu.nl/wiki/Swierstra/HaskellAdvertisement|
03:06:00 <lambdabot> http://www.cs.uu.nl/wiki/Swierstra/HaskellAdvertisement|
03:06:39 <dons> that even looks like the "haskell" font from the front of the craft of func. prog. text book.
03:09:04 <bartw> some parts of the syntax are confusing
03:09:31 <dons> do you have an example?
03:09:33 <bartw> data Tree a = Null | Node a (Tree a) (Tree a)
03:09:51 <bartw> Tree a is a typ by Node a is a constructor with value
03:10:21 <dons> yes. 'Tree a' is the type of a tree whose nodes are of some type 'a'
03:10:36 <dons> the Tree has two constructors, Null, which builds an empty Tree
03:10:49 <dons> and 'Node', which takes a node element, and two subtrees of the same type
03:10:50 <bartw> so how do you recognize a constructor with value vs type with subtype ?
03:10:51 <dons> and combines them
03:10:54 <bourbaki> moin dons
03:10:58 <dons> by context, bartw.
03:11:11 <dons> types appear where types should be. and constructors appear in expressions
03:11:20 <dons> i.e. Node 1 Null Null :: Tree Int
03:11:25 <dons> hey bourbaki
03:11:39 <bartw> ok, i just need to parse the wider context to know, ok
03:11:43 <dons> yep
03:11:59 <bourbaki> dons did you have a look at the esap.txt? or did you at least receive the mail?
03:12:05 <dons> constructors, types and modules are upper case, and you distinguish them by context
03:12:13 <dons> bourbaki: yes, i haven't had time to look at it yet, sorry.
03:12:26 <dons> been rather busy with haskell' stuff and paper reviewing
03:12:36 <bourbaki> np just wanted to know i the mail was sent propperly
03:12:58 <dons> yep. i have it. i'll try to give you a considered reply in the next couple of days
03:13:03 <bourbaki> yep i noticed that :) lambdabot web stuff and such. the conf is in 2008 anyway
03:13:13 <dons> ah heh. ok.
03:13:23 <dons> yeah, also the lambdaweb, yep
03:13:28 <bourbaki> but its never a bad idea to give it a long run i guess
03:13:42 <bourbaki> but i think that it might be interesteing to apply the stuff to lambda bot maybe
03:13:55 <bourbaki> i have designed that stuff initially for ai agentes specifically
03:13:57 <dons> ah yes. perhaps!
03:14:05 <dons> hmm. that would be interesting
03:14:46 <bourbaki> so you have input nodes for all kind of stuff like the hearing channel the smell channel and such
03:15:47 <bourbaki> how hard is it to extend lambda bot anyway?
03:16:02 <bourbaki> i wrote a i ging and would like to maybe reimplement my nl semantics stuff for it
03:17:51 <dons> pretty easy to add new plugins
03:18:06 <dons> you just provide a String -> IO String function, essentially.
03:18:14 <bourbaki> i found it not that easy last time i think ... ah ok
03:18:32 <bourbaki> so if i have a "wrapper" function for my string output thingy im done?
03:18:39 <bourbaki> let me have a look for the code sec
03:19:07 <mux> dons: hello
03:20:31 <dons> bourbaki: yeah, just develop an external application, with a String -> String, or String -> IO String interface
03:20:45 <dons> and then the plugin can be written by me (or you) in a few mintues, to call the external application
03:21:04 <dons> if you need to maintain state, you can, but you would develop it inside the bot, rather than as an external ap
03:21:14 <dons> hey mux. reminds me I should apply your bot patches
03:21:40 <mux> the second one is really questionable :-) I'm all ears if you have better ideas for it
03:21:49 <mux> at least it does the job though
03:23:02 <mux> did you got the patches without any problem? I had to resort to darcs send -o somefile and then mail you the file by hand, because delivery through sendmail onmy box doesn't work yet
03:24:37 <dons> all the patches are here I think.
03:24:43 <dons> i just have to think about them a bit, and apply them
03:24:48 <mux> cool
03:31:31 <bourbaki> http://paste.lisp.org/display/26189
03:42:41 <bourbaki> so how can i redo that code such that lambdabot can use it?
03:50:55 <dons> ok, if you can write a function that takes a String and returns a String, then we can add a plugin in 3 minutes
03:51:44 <AstralStorm> Ok, I'm 66% done with the indentalyzer ;-)
03:52:33 <bourbaki> dons ok let me see if i can do that
03:52:55 <bourbaki> oh sec im not sure if thats possible because i have to use the IO stuff due to the random thingy
03:53:43 <AstralStorm> bourbaki: reading from random will work.
03:53:59 <AstralStorm> @random
03:53:59 <lambdabot> Unknown command, try @list
03:55:53 <AstralStorm> @dice 2d10
03:55:53 <lambdabot> 2d10 => 11
03:55:56 <AstralStorm> @dice 2d10
03:55:56 <lambdabot> 2d10 => 13
03:56:00 <AstralStorm> :>
03:56:07 <AstralStorm> :>
03:56:11 <dons> AstralStorm: the vim indenter?
03:56:17 <dons> let me know if you want me to try it out?
03:56:25 <dons> bourbaki: IO is ok
03:56:30 <AstralStorm> It's in Haskell, not in Vim.
03:56:39 <bourbaki> dons then wouldnt it work out how it already is?
03:56:50 <AstralStorm> Designed to be a filter returning Vim modeline.
03:57:06 <AstralStorm> (w/o the prefix and suffic)
03:57:10 <AstralStorm> *suffix
03:57:30 <dons> bourbaki: oh, via main = do hex <- hexagramm 0
03:57:31 <dons>           printHexagrammReal hex
03:57:38 <dons> what's the program input?
03:57:41 <AstralStorm> So that I can eval the command.
03:57:46 <dons> AstralStorm: ah ok.
03:57:56 <dons> so an external tool ?
03:58:09 <AstralStorm> Yep. For all file formats.
03:58:15 <dons> document it here http://haskell.org/haskellwiki/Indent perhaps?
03:58:16 <lambdabot> Title: Indent - HaskellWiki
03:58:18 <dons> once its done
03:58:21 <bourbaki> dons i wanted it to be a closure that is there is no real input i just input 0 because i have to input something
03:58:22 <AstralStorm> Probabilistic indent detector :>
03:58:33 <AstralStorm> Though I don't know whether it'd work with Haskell well.
03:59:06 <AstralStorm> Its heuristics will most likely set you to expandtabs sw=2
03:59:53 <AstralStorm> Except for \t indented Haskell file (unlikely)
04:00:00 <dons> bourbaki: well, you should be able to write a little plugin for lambdabot then, and test it on the lambdabot command line, using the code you posted to start with
04:01:51 <bourbaki> ok ill try it :) but i didnt do anything in haskell for a while
04:03:11 <AstralStorm> @djinn Maybe x -> x
04:03:11 <lambdabot> -- f cannot be realized.
04:03:19 <AstralStorm> @djinn (Maybe x) -> x
04:03:19 <lambdabot> -- f cannot be realized.
04:03:26 <mux> AstralStorm: fromMaybe
04:03:34 <AstralStorm> Uh right, thanks.
04:03:46 <dons> ?djinn x -> Maybe x
04:03:46 <lambdabot> f = Just
04:03:46 <AstralStorm> @type fromMaybe
04:03:48 <lambdabot> forall a. a -> Maybe a -> a
04:03:52 <dons> isn't that interesting
04:04:04 <mux> > fromMaybe "foo" Nothing
04:04:05 <lambdabot>  "foo"
04:04:11 <dons>  ?djinn Maybe x -> Maybe (Maybe x)
04:04:11 <mux> > fromMaybe "foo" (Just "bar")
04:04:12 <lambdabot>  "bar"
04:04:18 <dons> ?djinn Maybe x -> Maybe (Maybe x)
04:04:18 <lambdabot> f a =
04:04:18 <lambdabot>   case a of
04:04:18 <lambdabot>   Nothing -> Nothing
04:04:18 <lambdabot>   Just b -> Just (Just b)
04:04:27 <dons> ?djinn Maybe x -> x
04:04:27 <lambdabot> -- f cannot be realized.
04:04:57 <AstralStorm> Seems it's not smart enough.
04:05:12 <ezraburgh> ?djinn x -> Maybe x -> x
04:05:12 <lambdabot> f a b =
04:05:12 <lambdabot>   case b of
04:05:12 <lambdabot>   Nothing -> a
04:05:12 <lambdabot>   Just c -> c
04:05:21 <ezraburgh> not bad.
04:05:45 <ezraburgh> how does it know not to just give f a b = a?
04:05:45 <AstralStorm> Any fromMaybe variant when Nothing can't happen?
04:05:51 <mux> AstralStorm: fromJust
04:05:59 <AstralStorm> Ah. Logical.
04:06:06 <mux> but of course that raises an error if you have Nothing
04:06:19 <dons> ezraburgh: it just tries harder :)
04:06:21 <AstralStorm> Which module?
04:06:26 <mux> Data.Maybe
04:06:28 <dons> ?type maybe
04:06:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:06:29 <AstralStorm> Hm.
04:06:34 <ezraburgh> it's impressive--djinn.
04:06:40 <dons> ?djinn b -> (a -> b) -> Maybe a -> b
04:06:40 <lambdabot> f a b c =
04:06:40 <lambdabot>   case c of
04:06:40 <lambdabot>   Nothing -> a
04:06:40 <lambdabot>   Just d -> b d
04:06:46 <dons> djinn++
04:06:50 <mux> :-)
04:07:49 <mux> ?djinn Maybe a -> (a -> Maybe b) -> Maybe b
04:07:49 <lambdabot> f a b =
04:07:49 <lambdabot>   case a of
04:07:49 <lambdabot>   Nothing -> Nothing
04:07:49 <lambdabot>   Just c -> b c
04:09:26 <AstralStorm> Hmm, currently my filter prints out statistics about the file.
04:09:38 <AstralStorm> I have to add indentation inference and probability mangling :>
04:09:38 <AstralStorm> 73.1
04:09:39 <AstralStorm> [(47.599999999999994,[(' ',4)]),(27.500000000000004,[(' ',8)]),(11.200000000000001,[(' ',12)])]
04:09:39 <AstralStorm> False
04:09:48 <AstralStorm> (for some space-indented file)
04:13:53 <AstralStorm> [(53.0,[('\t',1)]),(21.7,[('\t',1),(' ',1)]),(8.4,[('\t',4),(' ',3)]),(7.199999999999999,[('\t',5),(' ',1)])]
04:13:58 <AstralStorm> For some tab-indented file.
04:14:43 <AstralStorm> Some more simple operations and I'll be donw :>
04:14:46 <AstralStorm> *done
04:20:28 <AstralStorm> Ever heard of anybody doing 1-space indents?
04:23:25 <bartw> all our xml is 1 space indented
04:25:12 <profmakx> meh xml
04:25:14 <profmakx> *shudder*
04:26:07 <bartw> pfft whats wrong with a good subset of xml anyways ?
04:49:11 <bartw> funny, been reading a few haskell tutorials but no mention of currying yet
04:49:51 <profmakx> bartw, its much too verbose IMHO.
04:49:55 <profmakx> though i admit
04:49:55 <bourbaki> wouldnt you find that in a cookiung tutorial rather?
04:50:02 <profmakx> for data exchange
04:50:09 <profmakx> platform independent
04:50:24 <profmakx> bourbaki, brahaha
04:51:00 <bartw> right.
04:51:37 <bartw> i believe that curry-ing was returning a function with only a few of its parameters assigned as a value
04:52:03 <bartw> map (1 +) n would be currying (+) with
04:54:36 <bartw> hehe, apparently it also sometimes called 'SchOnfinkelisation' :)
05:12:24 <AstralStorm> bartw: it's not all that widely used. And you can do it with lambdas simply.
05:12:42 <AstralStorm> Other than that: curry and uncurry functions
05:13:00 <AstralStorm> (more spice in your life ;) )
05:13:37 <bartw> perosnally i dislike hot food so ill call it 'SchOnfinkelisation'
05:14:32 <AstralStorm> > map (\x -> (+ 1 x)) [1..10]
05:14:32 <lambdabot>  add an instance declaration for (Num (a -> a1))
05:14:37 <AstralStorm> Huh? :>
05:15:12 <AstralStorm> > map (\x -> (+ $ 1 x)) [1..10]
05:15:13 <lambdabot>  Parse error
05:15:18 <AstralStorm> Hmm.
05:15:21 <AstralStorm> > map (\x -> (+ . 1 x)) [1..10]
05:15:21 <lambdabot>  Parse error
05:15:25 <ibid> AstralStorm: (+), not + for prefix
05:15:27 <ski> '(1 +)' is called a "section" of the operator '+'
05:15:38 <AstralStorm> Ah.
05:15:54 <AstralStorm> > map (\x -> (1 + x)) [1..10]
05:15:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:16:12 <ski> > map (\x -> 1 + x) [1..10]
05:16:13 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:16:14 <bartw> > map ((+) 1) [1..10]
05:16:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:16:22 <ski> > map (\x -> (1 +) x) [1..10]
05:16:23 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:16:32 <ski> > map (\x -> (+) 1 x) [1..10]
05:16:33 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:16:35 <AstralStorm> :>
05:16:40 <bartw> te currying one is very short
05:17:52 <ski> "currying" is making a function take some argument(s) and return a new function that takes some argument(s)
05:17:59 <AstralStorm> Yes.
05:18:25 <ski> "partial application" is when you apply a function to some of its arguments
05:18:26 <AstralStorm> But it's quite unpredictable when applied to non-<whatitscalled> function. (non-transferable? )
05:19:10 * ski doesn't know what AstralStorm is after
05:19:17 <bartw> ski: so which of those two does haskell actually do in the map case i have, to me it seems like currying because map wnats a function
05:19:21 <AstralStorm> Actually, nothing :>
05:19:30 <AstralStorm> partial application
05:20:13 <ski> bartw : could you say which of the 'map' cases you mean ?
05:20:16 <bartw> it looks like those are semanticly interchangeable
05:20:20 <bartw> > map ((+) 1) [1..10]
05:20:21 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:21:03 <ski> there, the (curried) function '(+)' is partially applied (given only some of its arguments)
05:21:14 <ski> 'map', otoh is fully applied
05:21:41 <bartw> ah, i'm confusing the value with the action i guess
05:22:11 <ski> (of course, 'map' itself will call the resulting function '(+) 1' on each member of list, and each such application will be a full application)
05:22:50 <bartw> so a partial application yields a curried function
05:23:22 <ski> a partial application is an application of a function, in which not all arguments are given (so that what is returned is a function that wants the remaining arguments before yielding the final result)
05:24:00 <ski> a curried function is just a function that not "takes all arguments at the same time"
05:24:27 <ski> non_curried :: (A,B,C) -> D
05:24:51 <ski> curried :: A -> (B -> (C -> D))
05:24:56 <AstralStorm> @type curry
05:24:57 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
05:25:12 <bartw> isn't -> right associative anyways ?
05:25:13 <ski> also_curried :: (A,D) -> ((B,C) -> D)
05:25:17 <ski> yes
05:25:25 <bartw> so A -> B -> C
05:25:27 <ski> (i just wrote like that for emphasis)
05:25:45 <bartw> could be curriedto B -> C
05:25:53 <ski> no
05:25:54 <bartw> k that clears up that
05:25:55 <AstralStorm> @type uncurry
05:25:56 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
05:25:58 <bartw> ehmz
05:26:08 <ski> a function can be curried, or not curried
05:26:30 <ski> an *application* of a function, can be a partial application, or not be a such
05:26:32 <AstralStorm> No, it can be partially curried :>
05:26:35 <AstralStorm> :P
05:26:50 <AstralStorm> Currying is a recursive operation.
05:26:52 <ski> 'curried' is a property of functions
05:27:09 <ski> 'partial' (here) is a property of applications of functions
05:27:09 <AstralStorm> Any colour you like :>
05:27:29 <bartw> yes but no
05:28:43 <ski> so, if you have 'f :: A -> B -> C', then that (curried) function can be partially applied to get another (non-curried, in this case) function 'g :: B -> C' (e.g. by defining 'g = f a' if 'a :: A')
05:29:20 <bartw> right ok
05:30:02 <bartw> i mis understood that the value B -> C from  applying x 1 to x :: A -> B -> C was called a curried function
05:30:53 <AstralStorm> Internally, the compiler will curry the function when partially applying :P
05:31:20 <AstralStorm> (as much as possible, of course)
05:31:30 <ski> <ski> non_curried :: (A,B,C) -> D
05:31:37 <ski> <ski> curried :: A -> (B -> (C -> D))
05:31:56 <ski> 'curried' there is a curried variant of 'non_curied'
05:32:43 <ski> so, to 'curry' a function means to make a variant of it that takes some arguments first and some argument later (and possibly some arguments still later)
05:32:58 <bartw> some other little aspect i'm suprised about: a = (a)
05:33:15 <ski> why are you surprised ?
05:33:22 <AstralStorm> Well, parentheses :>
05:33:32 <bartw> that a tuple of something is the same as something
05:33:36 <AstralStorm> Not tuple.
05:33:41 <AstralStorm> Tuple is (a,b,...)
05:33:51 <AstralStorm> Or (a,a) for instance
05:33:54 <bartw> how is it different form a 1-tuple ?
05:33:55 <ski> there's no unituples in haskell
05:33:55 <AstralStorm> More than one value.
05:34:19 <bartw> ah then it is simply a parser hint, ok
05:34:25 <ski> right
05:34:31 <ski> just grouping
05:34:43 <ski> arguably, if you have 'f :: (A,B) -> C', then you could still say that you could partially apply that .. e.g. by doing '\b -> f (a,b)' (given 'a :: A' as before)
05:34:47 <bartw> geh and here i was admiring the clean ness of the way 1-uples were handled
05:35:39 <AstralStorm> Singletons?
05:35:47 <AstralStorm> That's an entirely separate type.
05:36:06 <ski> (of course, if you want, you could probably think of it like an unituple of a value happens to be the same as just that value, in haskell)
05:36:34 <bartw> not really the type implications hurt
05:37:13 <ski> ?
05:37:43 <AstralStorm> What? Hurt? :P
05:38:30 <AstralStorm> It's _the best_ feature of Haskell's typing system - so that you don't have to annotate everything.
05:39:06 * ski wonders what 'it' could be, here
05:39:16 <Philippa_> there aren't any type implications. There just aren't any 1-tuples, if you try to write the term for one you just get a value
05:39:51 <bartw> i remeber doing something in a c dialect compiler with tuples, 1-tuples were a distinct type, that realy went badly, altough the 0-tuple instead of void was pretty nice
05:39:57 <Philippa_> basically, the parser matches it against the usual parentheses-for-precedance rule instead of the tuple one
05:40:11 <Philippa_> a 0-tuple's a different type from void, though
05:40:17 <Philippa_> () is a value, void doesn't have /any/ values
05:40:21 <ski> bah
05:40:36 <ski> 'void' has a value, it's just not visible
05:40:45 <AstralStorm> Yes, value of no return :>
05:41:08 <Philippa_> ski: show me a value of type void in C, then
05:41:23 <ski> i just said it's not visible
05:41:30 <Philippa_> then it's not a value, is it?
05:41:32 <AstralStorm> It's internal to the compiler.
05:41:35 <ski> yes it is
05:42:06 <ski> if 'void' didn't have a value, then no function with return type 'void' could actually return
05:42:08 <vincenz> no, void doens't have a value
05:42:15 <vincenz> void is the lack of values
05:42:15 <Philippa_> ski: you're talking denotational semantics, not C
05:42:21 * vincenz nods at Philippa_ 
05:42:27 <AstralStorm> vincenz: lack of values is a value :P
05:42:45 <AstralStorm> On lower level of course.
05:42:45 <ski> of course i'm talking about semantics .. 'value' is a sematical concept
05:42:48 <Philippa_> AstralStorm: no it isn't, or you'd be able to assign it to a variable
05:42:55 <bartw> meh data Void = Void
05:43:01 <AstralStorm> Nope, because the compiler forbids that.
05:43:03 <Philippa_> ski: I repeat - you're talking *denotational* semantics. C has its own well-defined concept of value
05:43:08 <AstralStorm> Strict type check.
05:43:18 <Philippa_> bartw: wrong. That's unit, not void
05:43:31 <ski> Philippa_ : i agree, i am talking about semantics
05:43:34 <Philippa_> GHC does actually support void types as an extension, though
05:44:04 <Philippa_> ski: now you're being arsey. The distinction between denotational semantics and the language used to describe C in its definition is important
05:44:05 <AstralStorm> Monads?
05:44:30 <bartw> owwell, it was just toying with not much theorectical backgroup, maybe 1 and 0 tuples might be elegant someway i did no fathom
05:44:33 <Philippa_> per the C standard, void doesn't have any values. Any values you ascribe to it aren't part of C, they're part of your model of C
05:44:44 <AstralStorm> bartw: not really :>
05:45:11 <sieni> Philippa_: isn't void == unit?
05:45:21 <Philippa_> sieni: no
05:45:29 <sieni> Philippa_: why?
05:45:39 <Philippa_> you can find values of unit type trivially in most languages that have one
05:45:44 <Philippa_> because they're just plain old ordinary values
05:46:01 <AstralStorm> C has no unit values.
05:46:11 <vincenz> unit has 1 value, void has 0 values
05:46:12 <ski> (Philippa_ : i'm sorry that i wasn't clear that i wasn't talking about whatever definition of 'value' is used in the C standard)
05:46:34 <vincenz> probably explains the name 'unit'
05:46:37 <vincenz> :)
05:46:42 <bartw> sorry for startign such a flame, i was just musing on the nature of 1-tuples
05:47:10 <sieni> vincenz: yes, syntactically a void foo() does not seem to return a value, but it does, since it's a function and returns
05:47:30 <sieni> gotta go to pub ->
05:47:33 <Philippa_> sieni: *no*. You're assigning the properties of mathematical functions to C functions
05:47:40 <vincenz> sieni: wrong, you use your definition of functon
05:47:45 <AstralStorm> sieni: it's a procedure
05:47:48 <AstralStorm> Not a function.
05:47:51 <vincenz> in C functions are both functions and procedures (pascal anyone?)
05:47:52 <AstralStorm> Separate "type"
05:48:00 <AstralStorm> vincenz: some time ago
05:48:03 <sieni> Philippa_: yes
05:48:20 <SamB> vincenz: I argue that C functions aren't usually functions
05:48:38 <vincenz> SamB: yeah, they're not referentially transparent :D
05:48:39 <AstralStorm> In the mathematic sense, they aren't sometimes.
05:48:41 <sieni> not returning a value is literally that: the function does not return
05:48:46 <Philippa_> heck, "return" is often a machine-code concept, but many machine languages don't have any concept of "returning a value" - just of returning control to the caller
05:48:56 <vincenz> sieni: no, it returns, without a value
05:49:24 * ski smiles
05:49:26 <sieni> vincenz: no, it returns void
05:49:32 <vincenz> void is not a value
05:49:39 <vincenz> you can not do
05:49:44 <vincenz> a = fucntionthatereturnsvoid()
05:49:50 <AstralStorm> sieni: "doesn't return" means executes infinitely.
05:50:00 <sieni> AstralStorm: yes
05:50:08 <sieni> AstralStorm: like bottom in haskell
05:50:08 <AstralStorm> Which the void foo() doesn't necessarily do.
05:50:25 <Philippa_> except bottom is actually part of haskell
05:50:32 <Philippa_> there's no equivalent concept in C
05:50:36 <sieni> gotta go
05:50:37 <Philippa_> there's just "it hasn't returned yet"
05:50:43 <AstralStorm> In C++ you have exceptions.
05:50:44 <vincenz> Philippa_: well there is arse
05:50:58 <AstralStorm> Which are fancy flow control mechanism :P
05:51:08 <ski> longjmp
05:51:16 <vincenz> break
05:51:26 <ski> 'break' is local
05:51:34 <vincenz> and?
05:51:52 <AstralStorm> Yes, longjmp/setjmp. That's how C++ exceptions are implemented in C
05:52:10 <SamB> AstralStorm: um
05:52:12 <ski> (vincenz : just that you can't stop execution of a function with it)
05:52:19 <SamB> C++ exceptions aren't implemented in C!
05:52:27 <Philippa_> AstralStorm: that's woefully insufficient. Destructors matter
05:53:03 <AstralStorm> Yes, unfortunately :P
05:53:13 <AstralStorm> C++ is such a complex beast...
05:53:15 <Philippa_> heck, destructors are one of the things I like about C++
05:53:40 <SamB> destructors are definately a good idea for a language with no GC
05:54:00 <AstralStorm> Well, not only
05:54:16 <SamB> you call them finalizers if there is GC
05:54:23 <AstralStorm> Exactly.
05:54:31 <AstralStorm> And you can do finalisers in Haskell too :>
05:54:37 <SamB> I know this ;-)
05:54:42 <vincenz> yeah, but you're not guaranteed finalizers run
05:55:00 <SamB> that is rather unfortunate...
05:55:08 <AstralStorm> Is there some "destroy me" syntax in Haskell, like "del x" in Python?
05:55:11 <SamB> there ought to be a way to get them to be guarenteed...
05:55:20 <AstralStorm> That'd run the finaliser and mark the value as unused...
05:55:25 <SamB> "del x" isnt "destroy me"
05:55:26 <AstralStorm> explicitly.
05:55:29 <vincenz> AstralStorm: doubt that'd be possible
05:55:42 <AstralStorm> Yes, it's "run the finaliser and mark me for GC destruction)
05:55:42 <SamB> it is "remove my variable from the namespace", or something like that
05:55:59 <AstralStorm> Oh, that too.
05:56:09 <AstralStorm> run the finaliser and remove me from namespace
05:56:15 <bdash> AstralStorm: "del x" in Python decrements a reference count, which may or may not destroy the object
05:56:22 * vincenz wrinkles hsi nose
05:56:22 <Philippa_> and you can't really remove from the namespace like that in Haskell
05:56:24 <vincenz> reference counting?
05:56:26 <AstralStorm> But it runs the finaliser, always.
05:56:27 <AstralStorm> :P
05:56:36 <AstralStorm> vincenz: not only that.
05:56:39 <vincenz> AstralStorm: obviously, reference counting gives you a direct view if something is dead or not
05:56:46 <SamB> and "if, as a result, my refcount drops to zero, do whatever thing it is that is done to Python objects who's refcount reaches zero"
05:57:00 <bdash> it runs the finalizer eventually, yes.  but not necessarily at the time that 'del x' is executed
05:57:08 * vincenz shivers at the mention of refcounting, the bane of leakge
05:57:11 <SamB> of course, if there are cycles they complicate things considerably
05:57:19 <vincenz> leakage
05:57:22 <bdash> Python implements GC for cyclic references
05:57:23 <AstralStorm> So how does Boehm work? :>
05:57:34 <bdash> but this is all besides the point
05:57:41 <SamB> I forget what happens if you have a cycle with finalizers in it...
05:57:49 <vincenz> they finalize :)
05:58:00 <AstralStorm> The cycle is broken in some arbitrary way.
05:58:04 <vincenz> I wonder what happens if your finalizer reinstates your data by storing it in some global variable
05:58:11 <bdash> vincenz: bad things happen
05:58:14 <vincenz> AND!
05:58:15 <AstralStorm> You can't do that in the finaliser :P
05:58:15 <vincenz> if it's a cycle
05:58:19 <AstralStorm> Forbidden in Python.
05:58:23 <vincenz> and gets called after the other finializer in the cycle
05:58:30 * vincenz BWAHAHAss
05:58:38 * vincenz coughs
05:58:41 <bdash> Python in specific has had lots of bugs related to finalizers and cycles
05:58:51 <AstralStorm> Past tense, yes.
05:58:52 <AstralStorm> :>
05:59:05 <bdash> AstralStorm: ummm... it's completely possible to reinstate an object from its finalizer in Python
05:59:12 <vincenz> ok
05:59:19 <vincenz> since we're all flaming happily
05:59:21 <AstralStorm> Not in Python. Maybe in C finaliser.
05:59:22 <vincenz> scheme or CL?
05:59:27 <AstralStorm> Both! :P
05:59:35 <bdash> AstralStorm: I think you know not of what you speak... but meh, whatever
05:59:55 <AstralStorm> You can't do that on Python level. Maybe with Python C API though.
06:00:08 <SamB> AstralStorm: have you tried?
06:00:12 <AstralStorm> Yep.
06:00:13 <AstralStorm> :P
06:00:20 <AstralStorm> Will crash your program.
06:00:20 <SamB> what happened?
06:00:26 <AstralStorm> With an exception.
06:00:36 <SamB> oh, yeah, well, nobody ever said it would actually work did they?
06:00:38 <AstralStorm> It's explicitly checked for at runtime.
06:01:16 <AstralStorm> And you could catch the exception of course, but the variable won't be reinstated.
06:01:42 <AstralStorm> s/variable/object/
06:01:50 <bartw> :) i intend to use refcouting for my next language
06:01:51 <bdash> AstralStorm: what is the "it" that is checked for at runtime?
06:02:31 <bartw> i'm more worried about the interlockedinc/dec effect on the cache then memoryleak from cyclic loops
06:02:46 <AstralStorm> The global variable name access.
06:03:03 <AstralStorm> Because no object exists, you'd get an invalid reference.
06:03:09 <AstralStorm> Access to that will raise an exception.
06:03:51 <bartw> AstralStorm : the object being cleaned might have a field to a life object and add itself to that ?
06:03:54 <bdash> AstralStorm: can you provide a quick example?  based on what you've said, I must be misunderstanding you.
06:04:09 <AstralStorm> Assume yourobj has a __del__
06:04:21 <AstralStorm> def __del__(self):
06:04:27 <AstralStorm>    global something
06:04:32 <AstralStorm>     something = self
06:05:00 <AstralStorm> After this finishes, something will hold an invalid reference.
06:05:11 <bdash> bzzzzt
06:05:45 <bdash> http://rafb.net/paste/results/1X27ga90.html <-- exactly what you said
06:05:46 <bdash> try it.
06:06:02 <AstralStorm> Uh, right, blah @ me :P
06:06:09 <AstralStorm> The object won't get destroyed.
06:07:07 <AstralStorm> And if there are some non-reproducible operations, they'll fail on "del something"
06:07:16 <bdash> the weird corner cases that are left all involve weak references, cycles, and __del__... i think most have been resolved in recent Python versions
06:07:37 <AstralStorm> All known...
06:07:57 <AstralStorm> Hmm... hPython :>
06:07:59 <bdash> eh, non-reproducible operations?
06:08:08 <AstralStorm> E.g. thread.finish()
06:08:17 <AstralStorm> That'd raise an exception :>
06:08:26 <AstralStorm> Or del self.something
06:08:27 <bdash> having that inside __del__ you mean?
06:08:35 <AstralStorm> And that something got garbage collected.
06:08:36 <AstralStorm> Yes.
06:08:53 <bdash> something can't get garbage collected - self has a referenc e to it....
06:09:04 <bdash> exceptions inside __del__ are ignored anyway
06:09:11 <bartw> bdash : was that unicode ?
06:09:13 <AstralStorm> Yes :>
06:09:15 <bdash> anywho, this is completely off-topic
06:09:24 <bdash> bartw: nah, that was a mis-typed control character :-/
06:09:25 <AstralStorm> That's for #python
06:09:42 <AstralStorm> Is there a Python interpreter implementation in Haskell? :P
06:10:29 <SimonRC> there's a Perl impl
06:10:39 <AstralStorm> That I know of.
06:10:48 <SimonRC> or rather *the* perl6 implementation
06:10:57 <SimonRC> ah, ok
06:11:24 <AstralStorm> Probably someone could write an RPython -> Haskell compiler and have PyPy generate the interpreter.
06:12:48 <AstralStorm> It'd be funny if that turned out to be faster PyPy in C :P
06:12:54 <AstralStorm> *faster than
06:13:52 <bartw> doubtfull
06:13:55 <AstralStorm> It's possible because RPython -> C compiler still has weak optimisations.
06:15:00 <AstralStorm> I mean with compiled Haskell of course.
06:17:50 <Philippa_> yeah, Haskell is bad at VMs and the like though
06:18:38 <AstralStorm> Really? Bummer :-(
06:18:50 <basti_> for writing one you mean?
06:18:58 <Philippa_> for writing a fast one
06:19:19 <basti_> i don't really know... recently we achieved c++ speed with a numerics program
06:19:29 <Philippa_> cool
06:19:34 <Philippa_> numerics doesn't branch so much though, no?
06:19:37 <bartw> 'c++ speed' in bogomips ? ;p
06:19:49 <Philippa_> I suspect the frequent branches're what kill it for VMs
06:19:50 <basti_> the program was as quick as the c++ equivalent
06:19:52 <AstralStorm> You could directly map some base RPython object -> Haskell.
06:20:03 <bourbaki> isnt ocaml best in numerics?
06:20:07 <basti_> well there was some rather unpredictable looping
06:20:13 <bourbaki> at least i remember something like that from the shootouts
06:20:22 <basti_> it was something about taking the sum of all prime factors
06:20:50 <AstralStorm> Does Haskell have fast memory alloc? :>
06:21:14 <basti_> sufficiently fast, yes
06:21:15 <basti_> ;)
06:21:25 <basti_> what are you trying to do?
06:21:45 <AstralStorm> Because that's the most problematic part of the CPyPy interpreter.
06:21:52 <AstralStorm> It cheats by using Boehm GC
06:22:48 <AstralStorm> Just considering some funky projects :P
06:23:05 <dcoutts__> @arr
06:23:06 <lambdabot> Smartly me lass
06:23:14 * dcoutts__ has zlib bindings working
06:23:20 <AstralStorm> dcoutts++
06:23:41 <AstralStorm> If you have the time, could you bind libcap for me? :>
06:23:55 <dcoutts__> Codec.Compression.GZip.(de)compress :: Lazy.ByteString -> Lazy.ByteString
06:23:56 <AstralStorm> Shouldn't be all that hard.
06:23:59 <dcoutts__> ha ha
06:24:12 <bartw> Boehm gc is pretty fast with the right hints
06:24:26 <dcoutts__> AstralStorm: you can see what I did for the zlib state object
06:24:28 <AstralStorm> bartw: I don't know the quality of their hints
06:24:39 <bartw> or horribly without
06:24:51 <AstralStorm> dcoutts: I shall see - though I have another project to finish first.
06:24:56 <AstralStorm> Funny one too.
06:25:33 <AstralStorm> The funny part will be making high-level wrapper.
06:25:38 <xerox> dcoutts__: yarrr!  Nice type indeed.
06:26:04 <AstralStorm> E.g. three types Inheritable, Permitted, Effective
06:26:32 <bartw> dcouts: why limited to bytestrings and not normal string ?
06:26:39 <AstralStorm> Providing bit operations.
06:26:55 <AstralStorm> bartw: ah, simple - because it is faster :P
06:27:18 <dons> bartw: speed.
06:27:43 <AstralStorm> BTW, in which module is that ByteString?
06:28:05 <dons> Data.ByteString (which is an external package with ghc < 6.6)
06:28:09 <bartw> you're going to make some chinese person cry himself to sleep because he can't use haskell
06:28:10 <dons> ?where fps
06:28:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
06:28:23 <AstralStorm> Ok, FPS.
06:29:43 <bartw> meh, i wish they would make a laptop that would just run putty a browser and wifi, and abtteries that last 24h
06:30:06 <dcoutts__> bartw: you can unpack and pack to use normal strings
06:30:27 <dcoutts__> and why not: because the performance will be terrible :-)
06:30:28 <ValarQ> bartw: why putty?
06:30:42 <MarcWeber> Do you know where I can find the reconf script from the DrIft package?
06:30:50 <int-e> s/putty/ssh client/
06:31:10 <dcoutts__> zlib compression naturally works on big chunks of data
06:31:15 <bartw> ValarQ : with wifi, putty and a good browser i could have such a sweet thin client
06:31:36 <ValarQ> bartw: doesn't putty have enourmous dependencies?
06:32:22 <AstralStorm> Fun, not that is _fast_!
06:32:32 <bartw> ValarQ : not really no
06:32:33 <AstralStorm> dcoutts: is it also fast to create?
06:32:43 <dcoutts__> is what fast to create?
06:32:51 <AstralStorm> ByteString
06:33:03 <ValarQ> bartw: ok then
06:33:11 <AstralStorm> Are there proper IO operations using bytestrings?
06:33:31 <dcoutts__> ah, you mean IO, right. Yes IO is fast.
06:34:00 <dcoutts__> it does large block read/writes
06:34:02 <AstralStorm> I mean do you provide something like e.g. getLine
06:34:12 <AstralStorm> (with readahead, maybe)
06:34:13 <dcoutts__> that too, yes
06:34:22 <AstralStorm> Very good.
06:34:24 <AstralStorm> dcoutts++
06:36:44 <dcoutts__> but getLine is probably the slowest
06:36:44 <dcoutts__> since it needs complicated buffering
06:36:44 <dcoutts__> using a lazy bytestring and then using lines will be faster
06:36:49 <dcoutts__> getLine necessarily does IO in small chunks or via an extra buffer.
06:38:05 <dcoutts__> bah, my wireless keeps cutting out. :-(
06:41:46 <yacstud> would it be possible to add a haskell front-end to GCC ? (theorical question)
06:42:00 <dcoutts__> theoretically yes
06:42:37 <dcoutts__> what might be more useful is adding a C-- frontend
06:44:25 <bartw> why ?
06:45:17 <bartw> a roundabout way of letting gcc play backend to other compilers ?
06:45:41 <bartw> would be fun to have a c-- backend to gcc ;)
06:46:09 <yacstud> or a llvm - gcc integration (it was planned btw)
06:51:00 <bartw> hmz
06:55:06 <bartw> llvm wants the kind of abstractions a c frontend won't give you it seems
06:56:57 <Philippa_> the less roundabout ways are still pretty messy, no?
06:57:14 <Philippa_> not to mention very GCC-specific
06:58:29 <yacstud> bartw, i don't understand. there is an official C frontend for llvm
07:00:12 <bartw> yacstud : i was just reflecting the point that the c language is very hostile to many optimizations
07:00:40 <Philippa_> assuming I've got you right, the C frontend when used as a backend for something else doesn't offer the right kind of abstractions
07:01:12 <bartw> thats what i implied yes
07:01:22 <Thomas2_> and it gives you too much structure, really
07:01:34 <Thomas2_> when you're using something as a backend, it doesn't really need a type checker
07:01:40 <bartw> the actual aliasing and bindings are usually much more strict then c must allow for
07:02:08 <Philippa_> you'd be surprised - GHC's Core intermediate language has a typechecker and it regularly catches bugs
07:02:24 <pejo> Thomas2_, preserving type information through passes might aid finding bugs though.
07:02:45 * pejo gives Philippa a high five to put in the fridge.
07:04:03 <Thomas2_> pejo: it might, but there are other ways to architect that kind of thing .. having some sanity checks you can do on any intermediate point could be handy
07:05:54 <yacstud> bartw, ok
07:06:04 <musasabi> Has anyone got fundep typeclasses for automatic N-ary constructor wrapping+unwraping? That is given a hlist like structure (data a :*: b = a :*: b, data End = End;) of functions apply those functions for the constructor arguments (either wrapping when constructing or unwrapping if destructing it).
07:11:14 <Baughn> Does Haskell not have closures? I'm returning a function that's defined in a where-clause just below, and it doesn't seem to see variable bound (with <-, mind) just above the return. Or is that just a 'feature' of <- ?
07:11:57 <int-e> the scope of variables bound by <- in do just extends until the end of the do block.
07:12:37 <int-e> intuitively, the value doesn't exist before that point in the computatation and therefore cannot be used.
07:12:55 <int-e> semantically, look at how do blocks are desugared.
07:13:06 <int-e> @undo do a <- []; b <- []; return (a,b)
07:13:06 <lambdabot> [] >>= \ a -> [] >>= \ b -> return (a, b)
07:13:17 <int-e> each <- becomes a lambda.
07:14:05 <int-e> > do a <- [1,2,3]; let b = a*a; return a
07:14:06 <lambdabot>  Parse error
07:14:14 <int-e> > do a <- [1,2,3]; let { b = a*a }; return a
07:14:15 <lambdabot>  [1,2,3]
07:14:26 <Baughn> So, if I try..
07:14:50 <int-e> maybe a local let binding like this helps you. (the { } are only necessary if you put it all on the same line; layout does the right thing for normal code)
07:14:56 <Baughn> @undo do a <- word; return foo where foo = a
07:14:56 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
07:15:17 <Baughn> @undo do a <- word; return foo where { foo = a }
07:15:17 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
07:15:28 <xerox> @undo do { a <- word; let foo = a in return foo }
07:15:28 <lambdabot> word >>= \ a -> let { foo = a} in return foo
07:15:31 <Baughn> ..you get the idea. That isn't supposed to work, then?
07:15:31 <astrolabe> If you have  do X where y = z, the X can see y, but not the other way around
07:15:32 <int-e> that's equivalent to (word >>= \a -> return foo) where foo = a
07:15:41 <int-e> right.
07:16:23 <Baughn> Then currying comes in handy, but the code looks rather less pretty this way
07:16:41 <int-e> xerox: that let ... in ... is different though.
07:17:15 <xerox> Unfortunately :(
07:26:36 <Cale> dons: is dynamic broken?
07:27:09 <Cale> dons: I'm getting type errors when compiliing iit
07:27:11 <Cale> it*
07:36:22 <profmakx> Cale, hs-plugins?
07:36:59 <Cale> profmakx: nope, I just needed to throw in a few lifts
07:37:24 <profmakx> ah
07:37:32 <profmakx> much to learn i have
07:38:13 <Cale> hmm, it seems to be building all the modules statically anyway
07:38:18 <Cale> grumble :)
07:40:36 <mux> @seen dons
07:40:36 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 12m 27s ago.
07:40:39 <mux> @localtime dons
07:40:41 <lambdabot> Local time for dons is Mon Sep 18 00:40:18 2006
07:41:14 <Lunar^> dons: ?
07:46:45 <Thomas2_> quarter to 1 = good time for anyone to be in bed
07:46:47 * Thomas2_ -> bed
07:54:37 <dwm> ?help fptools
07:54:38 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
07:55:01 <dwm> ?fptools Control.Monad.State
07:55:01 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
08:01:20 <boegel> anybody familiar with Seattle in here?
08:02:01 <dwm> Never been. I live in NC. Before that, CT.
08:02:34 <basti_> i heard its a cold town with bad weather
08:05:01 <dwm> Maybe someone can help.. I have this function (form All About Monads) with type: getAny :: (Random a) => State StdGen a
08:05:13 <dwm> Looks like this: getAny = { do g <- get ; (x,g') <- return $ random g ; put g' ; return x }
08:05:37 <dwm> I'm trying to replace the get and put expressions with what those really are, the implementation of the get and put in State.
08:06:51 <basti_> ...?
08:06:53 <dwm> So, for that first action: g <- State (\s -> (s,s)
08:07:00 <basti_> ah
08:07:01 <bartw> geh if i write something in delphi in haskell style  have to think deep to make it more inefficient :)
08:07:13 <dwm> And then the next action: (x,g') <- return $ random g
08:07:28 <dwm> I don't get how the g here becomes something that random can accept.
08:07:57 <dwm> (this is System.Random.random)
08:08:04 <xerox> Because of the definition of >>= for State, dwm.
08:08:19 <int-e> g <- State (\s -> (s,s)) is awful.
08:08:34 <xerox> @undo do { g <- get; (x,g') <- return (random g) }
08:08:34 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 44}) "Parse error"
08:08:41 <xerox> Yuck?
08:08:43 <int-e> g <- get  is much clearer.
08:08:53 <int-e> because that's what it does - get the current state.
08:08:57 <xerox> int-e: I think he's just trying to understand.
08:09:00 <int-e> in the state monad
08:09:03 <dwm> Yes, but someone was helping me a few days ago and advised expanding all these things to see how it works.
08:09:24 <xerox> The trick is that <- really goes through >>=, which does something specific in the State Monad.
08:09:36 <xerox> But since lambdabot isn't cooperating..
08:09:38 <int-e> okay. then you need to desugar the 'do' and expand the >>=, too.
08:09:44 <int-e> otherwise it'll make little sense.
08:09:54 <dwm> So, the State (blahblah) is going into >>= as the first arg, and the contents getting ripped out for passing?
08:09:55 <xerox> do { g <- get; (x,g') <- return (random g) }  =  get >>= \g -> return (random g).
08:10:07 <int-e> @undo do { g <- get; (x,g') <- return (random g) }
08:10:07 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 44}) "Parse error"
08:10:12 <xerox> In general, the do-desugaring rules are, in order:
08:10:13 <int-e> aww.
08:10:20 <int-e> @undo do g <- get; (x,g') <- return (random g)
08:10:21 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 41}) "Parse error"
08:10:35 <int-e> @undo do g <- get; (x,g') <- return (random g); put g'; return x
08:10:35 <lambdabot> get >>= \ g -> return (random g) >>= \ (x, g') -> put g' >> return x
08:11:20 <xerox> do { let amb; ... } = let amb in do ...
08:11:20 <xerox> do { x <- amb; ... } = amb >>= \x -> do ...
08:11:20 <xerox> do { amb; ... } = amb >> do ...
08:11:20 <xerox> do amb = amb
08:12:23 <xerox> The first is more like "let bindings" where bindings is in fact possibly a list of bindings divided by `;', I am not sure if you need braces there, but you probably do.
08:12:39 <int-e> xerox: you do.
08:12:45 <dwm> ok
08:12:46 <xerox> Right.
08:18:24 <dwm> Just curious, does the identifier name 'amb' stand for anything specific?
08:18:56 <dwm> Also, I remember reading these rules over and over in various places and them just not sticking with me. :/
08:19:48 <xerox> I believe that historically it is McCarthy's non-deterministic operator.
08:20:09 <xerox> http://mitpress.mit.edu/sicp/full-text/sicp/book/node88.html
08:20:11 <lambdabot> Title: Variations on a Scheme--Nondeterministic Computing, http://tinyurl.com/zqdom
08:21:06 <dwm> ah
08:21:33 <dwm> Now, as a basic level, >>= is: m a -> (m a -> m b) -> m b  ...
08:21:43 <xerox> Nope.
08:21:47 <xerox> ?type (>>=)
08:21:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
08:21:51 <dwm> But it looks kind of a lot more complicated in the source for Control.Monad.State
08:22:16 <dwm> Ok, (_a_ -> m b)
08:22:21 <xerox> Yep.
08:23:17 <xerox> So the first argument is of type State s a.
08:23:18 <dwm> But in State.hs:  (in instance Monad (State s)) m >>= k = State $ \s -> let (a, s') = runState m s in runState (k a) s'
08:23:30 <xerox> ?type runState
08:23:32 <lambdabot> forall s a. State s a -> s -> (a, s)
08:23:48 <xerox> runState just unpacks the (State s) returning the s.
08:24:37 <xerox> data State s a = State { runState :: s -> (s,a) }
08:24:59 <xerox> OK, in fact, what is your question?
08:25:10 <dwm> Ah, that guy I have a lot of goofy trouble with. That { runState :: ... }
08:25:23 <xerox> It's a record.
08:25:29 <xerox> @oldwiki UsingRecords
08:25:29 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
08:25:30 <dwm> When you construct a State, what does it really expand to?
08:25:31 <xerox> Check that out.
08:26:08 <xerox> (In brief, you're just giving the tag 'State s a' to a function 's -> (s,a)', those two things are the same.)
08:27:26 <shapr> Hej!
08:27:43 <dwm> I guess part of my question from above is, given that definition of >>= in Control.Monad.State, it's very confusing to try to expand what's happening in the code I have here using the >>=
08:27:44 <xerox> (...and runState :: State s a -> (s -> (s,a)) just takes the value of type `State s a' and give you back the function `s -> (s,a)' contained in it. (the parens around the returned function are for ease of understanding, but unuseful otherwise))
08:28:18 <dwm> ok
08:28:23 <xerox> m >>= k = State $ \s -> let (a, s') = runState m s in runState (k a) s'
08:28:50 <xerox> = State (\s -> let (a,s') = runState m s in runState (k a))
08:30:10 <shapr> @Yow
08:30:11 <lambdabot> LBJ, LBJ, how many JOKES did you tell today??!
08:30:21 <nomeata> @time lambdabot
08:30:21 <lambdabot> I live on the internet, do you expect me to have a local time?
08:30:31 <nomeata> thanks dons :-)
08:30:34 <dwm> What just happened there to the end s' ?
08:30:49 <dwm> That whole (second) thing is a function now expecting the s' ?
08:30:59 <xerox> It should be `runState s' (k a)' ...
08:31:05 <xerox> ?fptools Control.Monad.State
08:31:05 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
08:31:09 <shapr> Who else is at Haskell Workshop right now?
08:31:23 <xerox> Err, `runState (k a) s''
08:31:37 <xerox> Right, as it is.
08:34:21 <xerox> shapr: yow!
08:34:28 <xerox> shapr: how's ICFP? :)
08:35:00 <dwm> Having trouble even finding where runState is defined in State.hs
08:35:14 <xerox> newtype State s a = State { runState :: s -> (a, s) }
08:35:28 <xerox> It's the name of the only field of the State newtype.
08:35:31 <dwm> Maybe coming from something imported.
08:36:00 <xerox> Did you read UsingRecords?
08:36:32 <dwm> I did not yet thoroughly, but I have it up. These are all types with ::
08:37:08 <dwm> I was looking for something that says runState s = {- implementation here -}
08:37:19 <xerox> Okay...
08:37:35 <dwm> Maybe that's not useful here. I just don't know.
08:37:49 <nomeata> From the quotes page on the wiki: "after a long pointless discussion with a fanatically loyal C programmer on comp.lang.functional <a40a15cb.0304160038.585f3e8@posting.google.com>:"
08:37:52 <xerox> If you have data Person = Person String String String, which is not quite informative, you have the option of naming the fields, using records, to make it more informative.
08:38:02 <nomeata> I assume that a C programmer will have a bad stand in a point less discussion
08:38:26 <shapr> nomeata, hah
08:38:27 <xerox> You do it this way: data Person = Person { name :: String, surname :: String, age :: Int } (Yes sorry I said String previously.)
08:38:39 <shapr> xerox, it's fun!
08:38:45 <xerox> This will have the effect of defining three functions as well, automagically.
08:38:57 <xerox> Those three functions are named exactly like the fields.  That is:
08:39:02 <dwm> accessors
08:39:17 <xerox> name :: Person -> String, surname :: Person -> String, age :: Person -> Int.
08:39:48 <xerox> Haskell creates them for you as you spell out the name of the fields.
08:40:07 <xerox> In the case of the State Monad, the definition is: newtype State s a = State { runState :: s -> (s,a) }.
08:40:29 <xerox> Hence Haskell will define a function `runState :: State s a -> s -> (s,a)'.
08:40:37 <dwm> That's really runState :: State s a -> (s -> (s, a)) ?
08:40:43 <xerox> Yes.
08:41:18 <xerox> The function type constructor is right associative (correct me on that if I'm wrong, I usually get associativities wrong.)
08:41:30 <xerox> (Is associativities a word? O_o)
08:41:45 <dwm> It's a cool word, regardless.
08:42:06 <xerox> That means that `a -> b -> ... -> z' is the same as `a -> (b -> (... -> z))'
08:42:08 <dwm> So, we don't really need to see some kind of explicit implementation for runState?
08:42:13 <dwm> It's being done by the compiler.
08:42:17 <xerox> Right.
08:43:00 <xerox> If you define: newtype State = State (s -> (s,a)), you can then define: runState (State s) = s, yourself.
08:43:08 <dwm> Or, it's just being expanded wherever someone puts runState.
08:45:23 <dwm> That definition there with newtype, that doesn't need type args on the left? newtype State s a = ...  ?
08:45:41 <xerox> Yes it does.
08:46:46 <shapr> lennart, are you at HW?
08:48:22 <dwm> Ok, I think this helps. I need to think about it more. And read.
08:48:31 <dwm> Thank you.
08:48:51 <xerox> You're welcome.
08:48:52 <dwm> I know that you, xerox, have already talked to me about State stuff a month or two ago. I have logs.
08:49:09 <dwm> You people are very patient as I gnaw around the edges of monads for months.
08:49:29 <xerox> The Haskell community rocks!
08:49:42 <shapr> Yes!
08:49:56 <shapr> #Haskell is nice too
08:50:45 * xerox nods ~ instant feedback!
08:50:58 * edwinb notes that xerox was trying to wake him up two days ago
08:51:04 <edwinb> how's that for instant feedback ;)
08:51:29 <xerox> How's types, edwinb?
08:51:47 <edwinb> mostly correct :)
08:51:58 <xerox> (ah -> ah) -> ah !
08:52:04 <edwinb> I've been busy travelling and moving house and stuff.
08:52:13 <basti_> types are written with a capital letter in front.
08:52:20 <edwinb> Now I've run out of excuses and neet to start working again...
08:52:22 <basti_> but that could be a variable.
08:52:26 <edwinb> basti_: Maybe he's being polymorphic
08:52:30 * basti_ nods
08:52:33 <xerox> I am!
08:52:42 <basti_> is there a function of type (a->a)->a?
08:52:42 <xerox> ?type fix
08:52:47 <lambdabot> forall a. (a -> a) -> a
08:52:49 <xerox> That was the point of the joke :)
08:52:50 <basti_> oh
08:53:10 * basti_ nods
08:59:36 <xerox> edwinb: I think many people were worshipping Epigram... in the hope of some new release, when I tried to wake you up.
09:00:07 <basti_> whats so cool about epigram when you got coq?
09:05:05 <araujo> hello
09:05:28 <edwinb> xerox: ah, I see ;)
09:05:40 <edwinb> looks like good progress is being made...
09:06:41 <shapr> Hiya edwinb
09:06:50 <edwinb> basti_: Coq is a theorem prover, not really designed as a dependently typed programming language - although you can use it that way
09:06:54 <edwinb> he shapr
09:06:54 <edwinb> er, hi
09:07:09 <edwinb> epigram has more tactics to support dependently typed programming
09:07:12 <shapr> I guess you're not at hw?
09:07:21 <edwinb> You guess right
09:07:25 <basti_> hmm
09:07:40 <edwinb> I didn't send a paper there so I'd never have got the trip funded...
09:08:00 <shapr> I'm here, it's fun!
09:08:33 <Lemmih> shapr: I have pictures of my uni(24-29): http://darcs.haskell.org/~lemmih/photos/
09:08:34 <lambdabot> Title: Index of /~lemmih/photos
09:08:37 <edwinb> are there many there?
09:08:45 <shapr> Cool!
09:09:03 <shapr> edwinb, more than 100 ppl
09:09:21 <edwinb> good talks?
09:09:53 <shapr> They're nice.
09:10:58 <shapr> Nothing has me jumping with joy yet, maybe I need more coffee
09:11:54 <edwinb> heh
09:12:03 <shapr> Strongly typed memory areas might be spiffy
09:12:47 <edwinb> ooh, yes, that sounds interesting
09:13:26 <nomeata> just curious: has anyone used this, maybe even for something useful? http://www.joachim-breitner.de/blog/archives/156-Haskell-on-the-Command-Line.html
09:13:29 <lambdabot> Title: Haskell on the Command Line - nomeata's mind shares, http://tinyurl.com/jf8xt
09:13:35 <shapr> High-assurance microkernel might be spiffy also
09:14:07 <edwinb> "Introducing the Haskell Equational Reasoning Assistant
09:14:11 <edwinb> sounds interesting
09:14:18 <edwinb> I wish I'd gone now ;)
09:14:42 <shapr> Dana N. Xu's ESC/Haskell is neat, but we saw it at AngloHaskell
09:15:12 <xerox> Yes!
09:15:38 <shapr> Eq reasoning is Galois, I think I'll enjoy that one.
09:16:42 <shapr> Right now it's Ren & Erwig 'Generic Recursion Toolbox'
09:17:17 * edwardk waves hello.
09:17:27 <shapr> Yo edwardk
09:17:31 <edwardk> =)
09:18:01 <shapr> Any thoughts on this talk?
09:18:27 <shapr> It reminds me of the previous talk
09:18:34 <edwardk> yeah
09:19:04 <edwardk> much lower pace though, was inda pumped by stephanie's nervous energy, comparatively i'm falling asleep
09:19:14 <edwardk> er kinda
09:19:59 --- mode: ChanServ set +o shapr
09:20:08 <edwardk> they've obviously given lots of thought to the problem, just the solution is everything I don't like in haskell, huge umpteen parameter type classes, etc.
09:20:25 <shapr> Yeah stephanie hs energy
09:20:33 <shapr> Has*
09:20:49 <edwardk> i really wanted to just tell her to stop and breath ;)
09:21:14 <edwardk> but I really liked her system
09:21:18 <shapr> :-) i like her talk style
09:21:31 <shapr> Yeah her system is nice
09:21:56 <shapr> Hiya ndm
09:22:13 <ndm> hi shapr
09:22:14 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
09:22:15 <ndm> you in portland right now?
09:22:18 <edwardk> yeah
09:22:33 <edwardk> he's sitting in the haskell workshop right behind me
09:22:42 <ndm> is the HW going on right now?
09:22:51 <edwardk> slowly trying to scratch outa response on that little toy he carries around =)
09:22:53 <shapr> Yup, 2nd talk
09:22:55 <edwardk> going well
09:23:03 <ndm> neat
09:23:09 <ndm> is anyone recording it or anything?
09:23:11 <shapr> Hey, it's a nice toy
09:23:24 <pejo> shapr, is the high assurance microkernel osker, or something else?
09:23:26 <ndm> i'd like to see Dana's talk
09:23:29 <shapr> I agree, I need a bluetooth keyboard for it
09:23:39 <xerox> shapr: you're on irc on your 770?
09:23:55 <shapr> Yup
09:23:56 <ndm> @seen SamB
09:23:57 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 3h 23m 21s ago.
09:24:02 <edwardk> i wouldn't mind using something like that with a little bluetooth keyboard, hrmm.
09:24:14 <ndm> @tell SamB seems like tailcall should work just fine and dandy
09:24:15 <lambdabot> Consider it noted.
09:24:40 <ndm> if anyone wants a question for the ESC/Haskell talk, i have one
09:24:42 <shapr> pejo, microkernel is derrin, elphintone, chillix, etc
09:24:58 <shapr> It's from unsw.edu.au
09:25:11 <shapr> ndm, tell me!
09:26:02 <ndm> shapr: question is what about higher order functions, specificially those introduced by the dictionary transformation, and in particular the IO Monad that passes a guaranteed failing higher order function (fail) in
09:26:15 <ndm> i.e. what does she hope to do about them
09:26:15 <edwardk> ok, this part is slick =)
09:26:36 <shapr> Hm, I think she addressed that in her talk
09:26:47 <ndm> not in her paper
09:26:53 <ndm> (which is all i'#ve seen)
09:27:06 <shapr> You had a wedding, right?
09:27:37 <ndm> oh, for Anglo Haskell, yep
09:27:43 <ndm> for this one i'm just poor :)
09:28:11 <ndm> and i prefer to refer to it as a friends wedding, to make it absolutely clear :)
09:28:16 <shapr> I can empathize
09:28:30 <shapr> Right, good point
09:38:35 <ndm> the demo';s this year look really cool
09:46:32 <shapr> Too bad Lemmih got sick.
09:46:46 <shapr> Hej sylvan
09:48:11 <shapr> Wups
09:48:36 <mnislaih> woo, Lemmih was going to be demoing the ghci debugger
09:48:46 <mnislaih> shapr: does that mean that there will be no debugger demo ?
09:49:18 <Lemmih> Yeah, no debugger demo. It really sucks /-:
09:49:25 <shapr> JaffaCake said he might be able to do it
09:49:30 <Lemmih> Really?
09:49:34 <mnislaih> hiya Lem
09:49:44 <shapr> If he can build it.
09:50:07 <mnislaih> it shouldnt' be that difficult hopefully
09:50:16 <mnislaih> did you go to the hackathon Lemmih ?
09:51:06 <Lemmih> Nope.
09:51:33 <shapr> stepcut, are you here?
09:51:58 <shapr> I heard stepcut was at the hackathon.
09:52:05 <araujo> takeWhile not.null.words fromlist
09:52:37 <araujo> geez, even a baby could understand that sentence
09:53:23 <araujo> somebody should write a paper about haskell expressiveness ...
09:55:26 <Syzygy-> Hmmmm.
09:55:50 <Syzygy-> Before I actually sit down and write a function for it, is there anything present in the haskell libraries for conversion between different color spaces?
09:55:59 <Syzygy-> @hoogle hsl
09:56:00 <lambdabot> Distribution.InstalledPackageInfo.hsLibraries :: InstalledPackageInfo -> [String]
09:56:00 <lambdabot> Language.Haskell.Syntax.HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
09:56:00 <lambdabot> Language.Haskell.Syntax.HsLeftSection :: HsExp -> HsQOp -> HsExp
09:56:07 <Syzygy-> @hoogle rgb
09:56:08 <lambdabot> No matches found
09:56:08 <ndm> @hoogle color
09:56:08 <lambdabot> Text.Html.color :: String -> HtmlAttr
09:56:08 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
09:56:08 <lambdabot> System.Win32.Info.cOLOR_ACTIVECAPTION :: SystemColor
09:56:27 <Syzygy-> @hoogle hue
09:56:27 <lambdabot> No matches found
09:56:30 <mauke> augh, cOLOR
09:56:30 <ndm> Syzygy-: there isn't even a color type in the haskell libraries
09:58:23 <araujo> some people say haskell is "obscure" or hard-to-read
09:58:58 <araujo> mmm.. i think such a paper could prove the other way around...
09:59:02 <ndm> araujo: look at Cabal, and tell me Haskell is easier to read :)
09:59:04 <edwardk> break time!
09:59:14 <waern> aruja, I think haskell code often is
09:59:28 <waern> :)
09:59:53 <Syzygy-> How do case expressions work? Any good example anywhere?
09:59:55 <ndm> araujo: and i think one line of haskell does so much more, which means you need longer to read a single Haskell line than a single C line
10:00:19 <dolio> Bah. Who couldn't understand: "isPalindrome = ap (==) reverse" ?
10:00:29 <ndm> Syzygy-: very simple - case x of {[] -> error "no tail" ; (a:as) -> as}
10:00:29 <araujo> ndm, Cabal is _one_ of many programs.
10:00:39 <ndm> araujo: now lets pick Yhc
10:00:51 <ndm> just try _finding_ the type checker!
10:00:53 <Syzygy-> ndm: Huh? What is x?
10:01:00 <araujo> ndm, you just can't judge the expressiveness of a language because of a program
10:01:02 <ndm> Syzygy-: any variable
10:01:14 <Syzygy-> Which gets matched against the bits before the ->?
10:01:20 <ndm> araujo: Haskell gives you more rope - that means more rope bridges, and more nooses
10:01:31 <ndm> Syzygy-: x
10:01:36 <araujo> But because of the abstractions it offers you to make the code as clear as possible, which i think it does, more than other languages.
10:01:48 <ndm> well written haskell is very beautiful
10:01:57 <araujo> Anybody can write ugly/hard-to-read code in any language, that wasn't my point actually.
10:01:58 <ndm> and you can write nice looking haskell, definately
10:02:06 <mauke> damn, I have to remember that ap @ @ is liftM2 @ id @
10:02:47 <xerox> ap f g x = x `f` (g x)
10:02:57 <ndm> see now: isPalindrome x = x == reverse x is perfectly clear
10:02:59 <araujo> For example, ive been reading the Pugs code in my free time
10:03:07 <ndm> as soon as you use ap, it gets a lot harder
10:03:08 <araujo> very easy to follow
10:03:14 <mauke> yeah, and liftM2 c f g x = f x `c` g x
10:03:15 <araujo> considering that i got no clue about perl
10:03:15 <xerox> ap is okay :D
10:03:26 <dolio> ndm: That's no fun though. :)
10:03:28 <xerox> mauke: ah-ha.
10:07:06 <nomeata> @type Monad.ap (==) reverse
10:07:08 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
10:07:13 <nomeata> @type  \x -> x == reverse x
10:07:14 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
10:07:23 <mauke> @pl \x -> x == reverse x
10:07:24 <lambdabot> ap (==) reverse
10:07:24 <nomeata> strange, ghci gives different types
10:07:32 <nomeata> Monad.ap (==) :: (Monad ((->) a), Eq a) => (a -> a) -> a -> Bool
10:07:39 <nomeata> padon
10:07:41 <nomeata> Monad.ap (==) reverse :: (Monad ((->) [a]), Eq [a]) => [a] -> Bool
10:07:44 <nomeata> \x -> x == reverse x :: (Eq [a]) => [a] -> Bool
10:07:48 <nomeata> what's the difference?
10:09:13 <Lemmih> One is pointfree?
10:09:31 <nomeata> and what exactly is Monad ((->) a) supposed to mean? is there an instance Monad ((->) a) defined somewhere?
10:09:45 <xerox> Yep.
10:09:52 <xerox> ?fptools Control.Monad.Reader
10:09:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
10:19:21 <bublle-war> hi pople
10:21:45 <araujo> @hoogle split
10:21:46 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
10:21:46 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
10:21:46 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
10:21:50 <araujo> @hoogle splitAt
10:21:51 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
10:21:51 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
10:21:51 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
10:27:54 <AstralStorm> fps++
10:30:54 * lispy waves to everyone from haskell-workshop
10:31:32 <shapr> lispy, hiya!
10:35:23 * shapr boings to stay warm
10:36:34 <shapr> nanavati_ravi, hi
10:37:36 <lispy> heh
10:37:54 <lispy> ?users
10:37:55 <lambdabot> Maximum users seen in #haskell: 236, currently: 225 (95.3%), active: 35 (15.6%)
10:38:02 <lispy> 35 active??
10:38:18 * lispy looks around for active peeps
10:38:18 <glguy> Hi or low?
10:38:26 <shapr> I wish I'd thought of bringing a sweater. It's cold in here.
10:38:41 <lispy> yes, tis a bit chilly
10:38:46 <kowey> i've got two... could pass you one
10:39:02 <shapr> And you have sweater & long sleeves
10:39:13 <shapr> Hi malcolm
10:39:27 <malcolm> hi shapr, I'm sitting behind you
10:39:44 <lispy> shapr: that's because i know the secret to surviving in oregon, layers
10:39:52 <shapr> Do you see me shivering? :-)
10:40:52 <shapr> So, what do you guys think of this talk?
10:41:30 <lispy> he mentioned the "expression problem" which caught my attention, but he didn't seem to takl about it anymore
10:42:31 <shapr> What are variants anyway? Something to do with record types?
10:42:40 <lispy> http://www.daimi.au.dk/~madst/tool/papers/expression.txt
10:42:42 <lambdabot> http://tinyurl.com/oe2bk
10:42:51 <lispy> ^^^ expression problem
10:43:03 <mauke> I thought variants are the things separated by |
10:44:52 <lispy> the expression problem is neat because the solution will most likely be the next foozle
10:45:27 <shapr> Ha
10:45:28 <lispy> actually, i already heard about one haskell extension to solveit
10:46:17 <yacstud>  variants, like in ocaml http://cristal.inria.fr/~remy/cours/appsem/ocaml052.html#toc22 ?
10:46:24 <lambdabot> Title: Variant and labeled arguments, http://tinyurl.com/gvtyq
10:47:08 <shapr> Variant in VB means something like polymorphic
10:47:59 <lispy> heh
10:48:16 <lispy> Dim x as Varient = 1 ?
10:48:27 <lispy> x = "One" ' still valid!?!
10:48:58 <shapr> Something close to that.
10:49:12 <glguy> variant is an anything
10:49:38 <shapr> Sort of polymorphic then.
10:49:58 <glguy> It's like a C# object that doesn't need to be dynamically casted
10:50:13 <glguy> but it's a value-type
10:50:18 <lispy> well, i think vb.net variant may hold any basic type but you need object to hold non-primitive... ( i could be wrong)
10:51:37 <glguy> I don't think that Variant survived into VB.NET
10:51:44 <glguy> but I could be wrong... I don't use VB
10:52:02 <lispy> i used it once a few months ago...but my memory is bad
10:52:32 <lispy> the slides don't mentally parse for me
10:52:33 <glguy> I was playing with the CleanIDE last night
10:52:55 <glguy> I think that they have managed to beat Notepad.exe for least featureful text editor
10:52:57 <lispy> record x `elem` EqL a where -- how to read that?
10:53:04 <lispy> glguy: hah
10:53:16 <shapr> I'm bouncing off the paper and the slides
10:53:41 <glguy> elem (record x) (EqL a) -- where EqL is a constructor
10:54:03 <shapr> Hej sris
10:54:04 <lispy> glguy: i think record is a new part of the syntax like 'instance'
10:54:32 <glguy> ??
10:54:35 <shapr> Hi again malcolm
10:54:37 <glguy> Is this Haskell'?
10:54:45 <malcolm> shapr?
10:54:54 <shapr> glguy, HW paper
10:55:01 <glguy> link?
10:55:11 <shapr> malcolm, you've popping in and out
10:55:17 <shapr> Beem*
10:55:22 <shapr> Argh
10:55:24 <malcolm> oh, so I see
10:55:30 <malcolm> flaky wifi I think
10:55:46 <shapr> Touchscreen == bad typing
10:56:36 <lispy> shapr: i'm amazed at how well  you're doing
10:56:39 <glguy> lispy: Does Ruby solve that problem listed as expresssion.txt
10:56:45 <shapr> glguy,  google for haskell workshop and 'polymorphic variants in haskell' by koji kagawa
10:56:47 <lispy> shapr: i think you have less typos per line than I :)
10:57:03 <lispy> glguy: not sure, i don't entirely understand expresssion problem
10:57:14 <lispy> glguy: or ruby
10:57:28 <glguy> oops, nope
10:57:33 <shapr> lispy, you sound much more productive with that keyboard :-)
10:57:34 <glguy> ruby doesn't have static type safety
10:57:43 <lispy> heh
10:57:49 <lispy> "just taking notes" ;)
10:58:53 <sris> Hi shapr
10:59:41 <shapr> Seriously?
11:00:19 <sris> Im very serious...
11:00:28 <shapr> :-)
11:00:36 <shapr> How's code?
11:00:47 <sris> im learing about infix constructors atm.
11:00:51 <sris> i think
11:01:32 <sris> do you say "the government are ..." or government is ?
11:01:39 <glguy> is
11:01:47 <sris> thanks ;)
11:01:58 <kowey> doesn't that depend on dialect?
11:02:06 <glguy> I believe it's the British who say things like "Parliment are debating"
11:02:06 <kowey> uk == are?
11:02:31 <glguy> I figured he was taking a survey :)
11:03:08 <fasta> I have two cases on which I currently pattern match. To compute one case I need quite some code which I have put in a where clause. I already found out that I can use guards to get the effect that I can share code between two alternatives, but I am not really happy with it. Any alternatives besides "putting the common code in functions" (which is not applicable).
11:03:30 <lispy> shapr: power corrupts, so thanks for the corruption :)
11:03:35 <xerox> ?yow!
11:03:35 <lambdabot> Yow!  Is this sexual intercourse yet??  Is it, huh, is it??
11:04:05 <shapr> Vien only wishes
11:04:22 <int-e> fasta: f = f' where f' = ... + a lot of local functions
11:05:19 <int-e> fasta: that elegantly solves the problem of namespace pollution
11:06:09 <fasta> int-e: The problem is that I want to use pattern matching, and share code, and have nested code (to get identifiers from surrounding lexical levels)
11:07:07 <glguy> fasta: int-e's solution does that
11:07:23 <glguy> f x y = f' x s
11:07:32 <glguy>  where f' _ [a] = something
11:07:39 <glguy>      f' [b] _ = something
11:07:39 <int-e> fasta: pass the variables that are local to an alternative on in function arguments then.
11:08:39 <lispy> ?pretty f x y = f' x s; where { f' _ [a] = something; f'[b] _ = something}
11:08:40 <lambdabot> "Parse error" at column 17
11:08:49 <xerox> pretty?!
11:08:55 <lispy> ?help pretty
11:08:56 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
11:09:08 <glguy> is that new??
11:09:17 <xerox> It might be very old in fact :)
11:09:21 <int-e> ?pretty f x y = f' x s where { f' _ [a] = something; f'[b] _ = something}
11:09:21 <lambdabot>  f x y = f' x s
11:09:21 <lambdabot>   where f' _ [a] = something
11:09:21 <lambdabot>      f' [b] _ = something
11:09:51 <glguy> mine was one character closer to being pretty ;)
11:09:58 <int-e> ?. pretty pl \x y z -> y x z
11:09:58 <lambdabot> "Parse error" at column -17
11:10:13 <lispy> -17?
11:10:15 <lispy> that's awesome
11:10:19 <int-e> yes :)
11:10:28 <monochrom> Wow Godawesome
11:10:43 <glguy> I can see why there was a parse error
11:10:53 <monochrom> ?pretty do { fun; fun; x<-fun; fun }
11:10:53 <lambdabot> "Parse error" at column 29
11:10:59 * monochrom cries
11:11:09 * shapr yowls
11:11:18 * xerox yodels
11:11:28 <glguy> pretty is the suxor )-:
11:11:37 <monochrom> ?pretty fun >> fun >> fun >>= \x -> fun
11:11:37 <lambdabot> "Parse error" at column 23
11:11:41 <lispy> ?pretty f x = x
11:11:41 <lambdabot>  f x = x
11:11:48 --- mode: ChanServ set +o lispy
11:11:52 * monochrom cries and stumps on the floor
11:11:54 <glguy> ?. pretty undo do {fun ; fun ; x <- fun; fun }
11:11:55 <lambdabot> "Parse error" at column 23
11:12:07 <shapr> lispy, more corruption!
11:12:24 * xerox hugs monochrom 
11:12:24 <fasta> glguy: thank you for clarifying
11:12:30 * glguy what happens when one stumps on the floor... a combination of stomping and dumping?
11:13:13 <monochrom> perhaps :)
11:13:28 <glguy> sounds stinky!
11:13:32 <xerox> ?users
11:13:33 <lambdabot> Maximum users seen in #haskell: 236, currently: 229 (97.0%), active: 37 (16.2%)
11:13:53 <shapr> Wasn't the max 240+ ?
11:15:00 <AstralStorm> Why doesn't lambda bot answer to me?
11:15:07 <bublle-war> hm
11:15:08 <AstralStorm> Oh, lag = 90s :P
11:15:10 <bublle-war> on break?
11:15:14 <AstralStorm> My bad.
11:19:54 <lispy> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
11:19:56 <lambdabot> http://tinyurl.com/eme3z
11:20:02 <lispy> this is good stuff
11:22:24 <lispy> flaky wifi :)
11:22:53 <shapr> Truly
11:23:10 <shapr> Wifi drops me regularly
11:28:51 <glguy> What's a good tutorial for someone who wants to learn Haskell and doesn't know any programming languages yet? (I want to teach my little brother some stuff)
11:29:08 <lispy> glguy: what age?
11:29:09 <ndm> lispy: but no publically available implementation :(
11:29:34 <malcolm> hi ndm
11:29:39 <fasta> glguy: is he motivated?
11:29:41 <lispy> ndm: right, it's just a research prototype at the moment, but the conclusion says they would love to see it in ghc
11:29:51 <ndm> hi malcolm
11:30:15 <ndm> lispy: thats probably a very heavy weight way to do it, would be much much easier to integrate with Yhc (but don't see that happening...)
11:30:19 <glguy> fasta: I'm not forcing him to learn it (-:
11:30:35 <fasta> glguy: ok, than you have some non-zero chance.
11:30:40 <fasta> then, even
11:30:59 <ndm> glguy: teach him maths first, but in a haskell style way - then show that haskell = maths
11:31:10 <lispy> glguy: but when your advisor is SPJ getting into ghc might be easier :)
11:31:11 <glguy> I want to inspire enough interest to keep him going on his own
11:31:43 <glguy> in Haskell that is
11:31:55 <ndm> lispy: i know :) - but when you use Yhc, you can keep your project outside, and still have all the nice warm and fuzziness that Yhc gives you
11:32:50 <glguy> Isn't the problem with YHC that it isn't "ready" yet?
11:32:51 <fasta> glguy: if your nickname comes from OpenGL, you could start there.
11:33:18 <bourbaki> moin
11:33:23 <ndm> glguy: yes, but its getting quite close, quite quickly
11:33:43 <ndm> glguy: and the front end stuff, which ESC/Haskell would want, is finished, stable, useful and quick
11:34:36 <shapr> glguy, what about 'the haskell road to math & logic' ?
11:34:56 <bublle-war> http://video.google.com/videoplay?docid=-5754346234493385767&q=orgy
11:34:59 <lambdabot> Title: Orgy the reality show - Google Video, http://tinyurl.com/kz67k
11:35:07 * lispy wonders about school of expression
11:35:23 <lispy> i haven't read it, but i guess it helps by having fun examples
11:35:32 <ndm> bublle-war: #haskell-blah is for that sort of thing
11:35:47 <glguy> ndm: you know that graph you have on your website that shows compiling a program to find the nth prime?
11:36:08 <ndm> glguy: yep
11:36:42 <glguy> what's the point of htat graph, it seems to show that GHC produces dramatically better results than yhc and hugs with a longer compile time
11:36:46 <ndm> with binary .hi files, that graph would drop Yhc down to quite a bit lower, giving a much better performance
11:36:49 <lispy> ndm: are you at the workshop?  if so i don't think we bumped into each other yet
11:36:54 <ndm> lispy: no
11:37:04 <lispy> ah
11:37:09 <ndm> glguy: GHC takes longer to compile, produces faster code
11:37:45 <ndm> glguy: which means, if you do a lot of compiling, for faster running programs, Yhc might be a better choice
11:38:01 <ndm> of course, we are working on faster at runtime, and faster at compile time :)
11:38:31 <glguy> ndm: when just doing development, wouldn't GHC be speed competitive when from with ghci and using :r to reload files
11:38:34 <glguy> or :l
11:38:50 <glguy> if that was the primary concern
11:38:59 <ndm> no, its faster than :r
11:39:02 <glguy> ah
11:39:06 <ndm> should really have put runhaskell benchmarks up as well, i guess
11:39:25 <glguy> so you are suggesting that yhc is good for the development cycle, but GHC is better for the release version?
11:39:32 <ndm> perhaps, yes
11:39:46 <ndm> although once yhc produces stand alone executables, which are faster than GHC, then...
11:39:58 <ndm> and Yhc has integrated debugging stuff, making it perfect for development
11:40:08 <glguy> I wonder how much time GHC loses because of the linker
11:40:14 <shapr> Ghc may never run well on 225MHz cpus
11:40:15 <ndm> and is entirely cross platform output, so if you want just one binary download, Yhc is the right choice
11:40:21 <fasta> Emacs can't indent multiple lines at once, right?
11:40:41 <fasta> (when editing Haskell)
11:40:48 <lispy> shapr: it only takes 6+ hours to compile ghc on my ibook (g4 1.2ghz, 768megs ram) so how long could it really take on there? ;)
11:40:49 <shapr> fasta, it can, but not in haskell-mode
11:41:15 <shapr> stepcut said 8 hours on the 770
11:41:34 <shapr> Might have been stage1 though
11:41:35 <lispy> shapr: joking aside, what about cross compiling?
11:41:42 <fasta> shapr: which one can indent on a space basis?
11:41:57 <shapr> Space basis? Huh?
11:42:05 <glguy> ndm: if YHC produces cross-platform binaries... what do you have to have installed to run them?
11:42:21 <fasta> shapr: Or a tab of width 1
11:42:36 <ndm> glguy: yhi, the york haskell interpretter
11:42:47 <ndm> glguy: but thats a small and really cross platform C program
11:42:56 <shapr> fasta, ik begrijp het niet
11:43:08 <ndm> i.e. much easier to provide everywhere than a full haskell compiler, or generated haskell code
11:43:30 <glguy> so it's a standalone interpreter?
11:43:45 <fasta> shapr: Ok, I want to indent existing code to a location 3 spaces back.
11:43:58 <ndm> yep, basically
11:45:40 <shapr> fasta, regexp-replace or record a macro?
11:46:27 <fasta> shapr: map indent-to per line of a region would work better
11:47:00 <shapr> Haskell-mode's indentation is weird
11:47:15 <fasta> shapr: never mind if it doesn't exists.
11:47:45 <shapr> Hej lennart
11:48:02 <shapr> fasta, sorry I can't help more
11:48:30 <boegel> shapr: hey (check pm)
11:48:31 <fasta> shapr: yeah, I should fix Emacs Haskell mode once and for all sometime.
11:48:54 <lispy> fundamentally, emacs is not built to understand haskell syntax
11:49:36 <lispy> emacs wants to do cheap and approximate syntax analysis (eg, regexps)
11:50:01 <fasta> lispy: Emacs is a piece of software, Emacs doesn't want anything.
11:50:16 <lispy> fasta: blasphemy
11:50:24 <lispy> fasta: emacs heard you!
11:50:33 <dolio> I'm sure there's some plugin that adds sentience.
11:50:44 <bublle-war> why snt there  a  web browser in haskell?
11:50:45 <fasta> lispy: Fundamentally emacs can be extended until eternity (meaning until it becomes to slow)
11:50:51 <dottedmag> bublle-war: w3c-el
11:50:58 <bublle-war> oh yeah
11:51:01 <dottedmag> bublle-war: mmm. w3m-el
11:51:06 <bublle-war> can i log into yahoo email with that fucker
11:51:07 <bublle-war> ?
11:51:13 <lispy> fasta: yes, true
11:51:38 <lispy> fasta: most mode authors don't want to rearchitect the syntax highlighting and such though :)
11:51:47 <fasta> lispy: but nobody seems to have the intention of building proper tools. (which was concluded the last time this came up)
11:52:54 <lispy> fasta: if you write it and it's good, i *will* use it.  so i welcome you to work on it :)
11:53:00 <fasta> I wonder how many _daily_ users Haskell has.
11:54:53 <fasta> There are bounty projects. Maybe this project would be a good candidate (or otherwise some group of people with similar interest should come together).
11:55:28 <dottedmag> fasta: I think proper tools may be easily built by the means of communicating Emacs with external haskell process, as, say, pymacs does.
11:55:37 <fasta> int-e: your solution worked very good
11:55:50 <shapr> bublle-war, I think you can get yahoo mail in two ways from emacs
11:56:19 <fasta> dottedmag: yes, I agree (I was thinking along the lines of an incremental parser for that). Not that I care about incremental parsing for Haskell that much.
11:56:45 <fasta> w3c-el does a similar thing
12:01:34 <fasta> Do you also tend to create larger functions, the more you program in Haskell?
12:02:31 <bartw> is there a kind of OO with functional programming ?
12:02:39 <Philippa_> fasta: not if you can avoid it, generally
12:02:53 <araujo> fasta, The tendency is usually the opposite.
12:02:55 <Philippa_> good factoring's valued
12:03:22 <fasta> Philippa_: ok, then it must be I am doing more complicated things. I factor like an insane :)
12:04:24 <lispy> fasta: i'dsay i create smaller functions the more i program in haskell, just lots of them and glue them together as needed
12:04:30 <RyanT5000> i just installed ghc 6.5 on ubuntu manually (not using a .deb); when i try to run ghci, it says it can't find libreadline.so.4; there's a libreadline.so in /usr/lib
12:04:36 <RyanT5000> how do i fix this?
12:04:43 <RyanT5000> (i'm pretty new to linux)
12:05:15 <fasta> Artificial examples in Haskell use very short names for identifiers, I now more use the Lisp tradition of using complete words to describe things.
12:05:20 <lispy> RyanT5000: 'ls -l /usr/lib/libreadline.so' where doesit point?
12:06:06 <RyanT5000>  /lib/libreadline.so.5
12:06:59 <lispy> RyanT5000: hmm...so you maybe don't have the right readline
12:07:22 <lispy> RyanT5000: try installing libreadline4
12:07:32 <lispy> (sudo apt-get install libreadline4)
12:07:57 <RyanT5000> ah cool, thanks
12:08:26 <lispy> np
12:08:27 <RyanT5000> apt-get is very nice for users who know relatively little about linux
12:08:48 <RyanT5000> i tried gentoo a while back and 8 hours later i was still fooling with USE flags
12:09:28 <lispy> yes
12:09:46 <RyanT5000> lispy: while i'm asking linux questions (the ##linux people are very unhelpful), do you know how to change the default media player? i'm stuck with totem right now, and i'd rather use mplayer or vlc (they're both installed)
12:10:12 <weitzman> Oh man, I have bad memories of media players on Ubuntu
12:10:21 <RyanT5000> lol yeah
12:10:28 <RyanT5000> it's nearly impossible to get anything working
12:10:36 <lispy> RyanT5000: 1) maybe ask in #debian 2) i dunno...
12:10:50 <RyanT5000> lispy: alright, thanks, i didn't even think of that one
12:11:09 <dolio> Totem isn't working?
12:11:10 <lispy> RyanT5000: maybe try #gnome too or something like that
12:11:13 <fasta> RyanT5000: do _not_ ask ubuntu questions in #debian, they don't like that.
12:11:22 <RyanT5000> fasta: thanks for the heads-up :)
12:11:36 <RyanT5000> Totem has almost no codecs
12:11:43 <lispy> oh, i thought he was running debian :)
12:11:44 <dolio> Oh, well you can fix that.
12:11:46 <RyanT5000> i installed every gstreamer thing in synaptic
12:12:10 <RyanT5000> mplayer seems to work though
12:12:13 <weitzman> My favorite thing about totem was that every time moved forward or backward in a currently-playing file, it would emit a horrible screeching noise
12:12:19 <RyanT5000> lol
12:15:54 <RyanT5000> what's the deal with ghc 6.6? i keep hearing about it
12:16:08 <RyanT5000> when's it coming out?
12:16:21 <ndm> RyanT5000: soonish, its got RC versions out
12:16:30 <RyanT5000> awesome
12:16:56 <ndm> although i'm not sure what you're looking forward to, other than loosing FiniteMap :)
12:17:07 <dolio> FPS?
12:17:14 <ndm> ah, yes, thats worth it
12:17:35 <ndm> but its been in Hugs for sometime, so thats not that big, and it can be installed separately
12:17:55 <RyanT5000> it's the first stable release since i've been using haskell, so it's exciting to me :P
12:18:00 <RyanT5000> kind of like when windows 95 came out
12:18:17 <dolio> There have been vague references to better optimization, too, but I suppose that's a bit vague.
12:18:27 <ndm> it does have better optimisation
12:18:29 <ndm> in some cases
12:18:39 <RyanT5000> well just having 6.5's features in a "stable" release is nice
12:18:52 <ndm> but given i use WinHugs, performance doesn't both me too much
12:19:19 <ndm> nah, its useful to have a new GHC
12:19:54 <ndm> but it would be nice to move to a model where there are no released version, just a continually evolving program
12:20:26 <RyanT5000> @where posix
12:20:27 <lambdabot> I know nothing about posix.
12:20:37 <nanavati_ravi> 6.6 will be nice because IORefs will scale much better
12:20:41 <RyanT5000> where can i get the posix package?
12:20:53 <ndm> RyanT5000: 6.4 or 6.6?
12:20:58 <RyanT5000> 6.5
12:21:08 <ndm> not included by default :)
12:21:17 <RyanT5000> yeah, i realize that
12:21:25 <RyanT5000> i wanted to diverge from the default :P
12:21:32 <ndm> http://darcs.haskell.org
12:21:34 <lambdabot> Title: Index of /
12:21:46 <lispy> darcs++
12:21:55 <RyanT5000> hm?
12:22:00 <xerox> <lambdabot> Maximum users seen in #haskell.it: 5, currently: 5 (100.0%), active: 1 (20.0%)
12:22:03 <xerox> Yay!
12:22:06 <RyanT5000> i'm looking there
12:22:12 <RyanT5000> there's no /posix/
12:22:13 <ndm> RyanT5000: http://darcs.haskell.org/packages/unix/
12:22:14 <lambdabot> Title: Index of /packages/unix
12:22:17 <RyanT5000> ah ok thanks
12:22:22 <fasta> Why do Data.HashTable operations live in the IO monad?
12:22:45 <ndm> fasta: try implementing a hash table without the IO monad
12:23:00 <xerox> ST?
12:23:12 <fasta> ndm: is it impossible to provide a safe interface?
12:23:14 <int-e> ST would make sense, I think
12:23:29 <ndm> fasta: use Data.Map, thats pure, but less performance
12:23:30 <xerox> fasta: it's a trade-off.
12:23:32 <int-e> fasta: it'd be slow because you'd have to copy the hashtable for every update
12:23:54 <RyanT5000> it seems to me that haskell would be greatly improved by partitioning IO into various domains with well-defined semantics for moving state across domains
12:23:59 <xerox> Except if you cheat...
12:24:00 <RyanT5000> not that that would be *easy*
12:24:03 <sjanssen> a read only hash table might be interesting
12:24:19 <int-e> RyanT5000: what do you have in mind, beyond ST?
12:24:39 <xerox> I/O :D
12:24:48 <fasta> Don't we already have constant time updates for arrays using a functional interface?
12:25:05 <sjanssen> fasta: yeah, there is DiffArray
12:25:13 <RyanT5000> int-e: i'm not exactly sure, but even hardware state might be partitionable
12:25:18 <fasta> sjanssen: I mean based on STRefs
12:25:49 <sjanssen> yeah, there is the ST monad too
12:25:58 <fasta> sjanssen: (it was a rhetorical question)
12:26:00 <RyanT5000> e.g.: if haskell was closer to the bare metal, you might separate different IO ports, and something in the monad of one of them could still only access the other ones functionally
12:26:11 <RyanT5000> you'd need really heavy-duty monad combinator support
12:26:21 <RyanT5000> oh; here's an example
12:26:29 <sjanssen> in an ideal world Data.HashTable would work in several monads: IO, ST and STM (probably more)
12:26:33 <RyanT5000> let's say i have an IORef
12:26:41 <RyanT5000> and i want to spawn a thread with access to it
12:26:46 <sjanssen> but such general libraries can become cumbersome
12:26:52 <RyanT5000> that thread doesn't need to also get access to *everything else*
12:27:01 <RyanT5000> just that one IORef
12:29:00 <RyanT5000> i bet House could make use of the ability to partition up IO for safety in kernel drivers
12:34:14 <SamB> sjanssen: well... its easy if you cheat ;-)
12:34:14 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
12:35:05 <RyanT5000> i'm trying to install posix, and it says it can't find HsUnixConfig.h; i know where HsUnixConfig.h is - how do i tell it?
12:35:11 <sjanssen> SamB: cheat in what way?  use unsafeIOtoSTM and the like?
12:35:20 <int-e> RyanT5000: but you can do that on top of IO - newtype it, provide the operations you deem safe ...
12:35:20 <SamB> sjanssen: well, maybe not STM...
12:35:24 <SamB> STM is complicated
12:35:32 <sjanssen> right
12:35:32 <RyanT5000> int-e: good point
12:35:59 <SamB> I say a datastructure for STM should be designed explicitly for STM
12:36:04 <ihope> What are ST and such?
12:36:11 <sjanssen> the associated types stuff going on in GHC should make a generic hash table module easier
12:36:14 <SamB> ST is IO without the I/O
12:36:19 <SamB> and with annoying types
12:36:36 <lisppaste2> AstralStorm pasted "String conversion" at http://paste.lisp.org/display/26209
12:36:59 <AstralStorm> Is that the best way to pretty print as I like?
12:37:08 <SamB> so when will there be an MTL replacement using Associated Types?
12:37:08 <AstralStorm> s/like/want/
12:37:36 <AstralStorm> Any better?
12:39:14 <sjanssen> SamB: probably shortly after there is a GHC with working associated types
12:39:15 <SamB> AstralStorm: if it does what you want thats probably a good way ;-)
12:39:34 <AstralStorm> But any optimisations? Pointers? :>
12:39:42 <ndm> AstralStorm: isTab x = fst x == '\t'
12:39:44 <AstralStorm> Cleanups maybe? :>
12:39:44 <SamB> AstralStorm: is it too slow for you?
12:39:59 <AstralStorm> ndm: I know :P
12:40:01 <ndm> AstralStorm: ditto isSpace
12:40:34 <ndm> AstralStorm: foldl1 (++) and not concat ?
12:40:47 <AstralStorm> Ugh, forgot :P
12:41:10 <AstralStorm> I knew I forgot about something :P
12:41:35 <ndm> "*ERROR*":[] -> ["*ERROR*"]
12:41:38 <sjanssen> foldl is a particularly bad fold to express concat
12:41:39 <ndm> ditto for the line above that
12:41:54 <AstralStorm> That'll work?
12:41:57 <ndm> ("Tab") -> "Tab"
12:42:06 <ndm> AstralStorm: the :[] -> [x] ?
12:42:22 <AstralStorm> Mhm.
12:42:34 <ndm> that one is a syntactic transform, so yep, should work fine
12:43:16 * AstralStorm can't read Haskell error messages :P
12:43:43 <AstralStorm> Any better way than doing 2 concats with intersperse?
12:44:03 <xerox> > unwords ["foo","bar","baz"]
12:44:04 <lambdabot>  "foo bar baz"
12:44:16 <ndm> AstralStorm: concatMap gets rid of the first one
12:44:17 <AstralStorm> Hehe, thanks.
12:44:25 <Syzygy-> > unwords [1, 2, 25]
12:44:26 <lambdabot>  add an instance declaration for (Num String)
12:44:26 <lambdabot>   In the list element: 25
12:44:52 <weitzman> > words "This 'has' punctuation! What happens?"
12:44:53 <lambdabot>  ["This","'has'","punctuation!","What","happens?"]
12:44:55 <AstralStorm> Syzygy-: it's for strings anyway :>
12:45:03 <emu> words is defined in the report
12:45:07 <xerox> The Hoogle author should have mentioned Hoogle at this point...
12:45:11 <weitzman> > words "Two  spaces"
12:45:12 <lambdabot>  ["Two","spaces"]
12:45:21 <emu> it uses span and takeWhile
12:45:28 <emu> i believe
12:45:40 <xerox> > words "\nCan't be\t\rbeaten\v !"
12:45:41 <lambdabot>  ["Can't","be","beaten","!"]
12:45:57 <ndm> hehe, i actually think DrHaskell would be better for this case - but its not finished yet
12:46:04 <weitzman> > words "\b\b\b"
12:46:05 <lambdabot>  ["\b\b\b"]
12:46:19 <xerox> No, I mean:
12:46:19 <xerox> ?hoogle [String] -> String
12:46:20 <lambdabot> Prelude.unlines :: [String] -> String
12:46:20 <lambdabot> Prelude.unwords :: [String] -> String
12:46:20 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
12:46:41 <emu> ?hoogle String -> [String]
12:46:42 <lambdabot> Prelude.lines :: String -> [String]
12:46:42 <lambdabot> Prelude.words :: String -> [String]
12:46:42 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
12:47:07 <ndm> DrHaskell would spot intersperse " " and auto suggest unwords
12:47:19 <ndm> concat (intersperse " " - at least
12:47:20 <emu> DrHaskellBCurry?
12:47:29 <xerox> ?pl concat . intersperse ' '
12:47:29 <lambdabot> join . intersperse ' '
12:47:31 <ndm> DrHaskell, my program :)
12:47:39 <ndm> it gives you suggestions about your code
12:47:47 <emu> jk
12:47:47 <ndm> @where drhaskell
12:47:47 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
12:47:53 <xerox> Yuck.
12:48:51 <emu> is that hackathon going on now
12:49:06 <RyanT5000> ok so i installed unix, but now i need to install posix
12:49:13 <emu> lol
12:49:14 <RyanT5000> hfuse has a dependency on "posix-any"
12:49:18 <ndm> emu: no, finished now
12:49:28 <emu> that's quotable
12:49:47 <RyanT5000> emu: i'm referring to the haskell packages by those names ;)
12:50:00 <emu> hehe
12:50:08 <RyanT5000> though it does seem quotable out-of-context :P
12:50:27 <ndm> @remember RyanT5000 ok so i installed unix, but now i need to install posix
12:50:27 <lambdabot> Not enough privileges
12:50:32 <AstralStorm> Removed spurious concat and added unwords to the now indentToStr :>
12:50:42 <ndm> @slap lambdabot
12:50:42 * lambdabot beats up lambdabot
12:50:48 <RyanT5000> lol
12:50:52 <ndm> @karma- lambdabot
12:50:53 <lambdabot> lambdabot's karma lowered to 25.
12:50:59 <xerox> No :(
12:51:05 <emu> any news on ghc status
12:51:06 <xerox> Don't you ever smack yourself?
12:51:11 <RyanT5000> so, anyone know how i get this to work?
12:51:11 <ndm> @tell dons I don't have enough priviliges to do a remember?
12:51:11 <lambdabot> Consider it noted.
12:51:15 <ndm> xerox: all the time
12:51:17 <RyanT5000> is hfuse out of date or something?
12:52:34 <emu> is 6.6 due out this week?
12:52:38 <SamB> @quote RyanT5000
12:52:39 <lambdabot>  i wish i had been programming in haskell for 7 years rather than C++
12:52:42 <ndm> no chance
12:52:52 <RyanT5000> :)
12:52:54 <ndm> since everyone is at ICFP
12:52:55 <emu> darn
12:52:59 <emu> oh right, still ICFP
12:53:03 <lisppaste2> AstralStorm annotated #26209 with "Cleaned up string conversion" at http://paste.lisp.org/display/26209#1
12:53:05 <emu> it's next week then
12:53:07 <SamB> how long is ICFP?
12:53:23 <RyanT5000> is the posix package deprecated?
12:53:25 <ndm> 2/3 days, i think
12:53:26 <AstralStorm> Looks much better now, right?
12:53:30 <SamB> RyanT5000: huh?
12:53:36 <RyanT5000> well i can't find it
12:53:44 <RyanT5000> hfuse depends on posix-any
12:53:46 <SamB> hmm
12:53:46 <ndm> @remember RyanT5000 ok so i installed unix, but now i need to install posix
12:53:47 <lambdabot> Not enough privileges
12:53:50 <SamB> hold on
12:54:27 <emu> oh wow it's been 4 years since it was in pittsburgh
12:54:29 <emu> time flies
12:55:22 <SamB> RyanT5000: are you using a distribution or darcs?
12:55:30 <RyanT5000> SamB: darcs
12:55:40 <RyanT5000> i got a snapshot of 6.5
12:55:42 <SamB> ah, okay. well.
12:55:49 <SamB> oh. that isn't darcs!
12:55:53 <SamB> that is a snapshot!
12:55:57 <RyanT5000> i thought you meant for the other stuff
12:56:13 <SamB> oh, you are using the unix package from darcs?
12:56:16 <RyanT5000> yes
12:56:23 <RyanT5000> that's all i have installed right now
12:56:29 <RyanT5000> 6.5 snapshot + unix darcs
12:56:36 <RyanT5000> and i'm trying to install hfuse darcs
12:57:01 <SamB> huh
12:57:38 <SamB> doesn't seem to be listed in extra-packages or anything like that...
12:57:46 <SamB> @where posix
12:57:46 <lambdabot> I know nothing about posix.
12:58:05 <AstralStorm> ?hoogle Posix
12:58:06 <lambdabot> Text.Regex.Posix :: module
12:58:06 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
12:58:06 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
12:58:34 <AstralStorm> That should be System.Posix, heh?
12:58:43 <RyanT5000> in the version i have, it says "Build-Depends: base, posix"
12:59:00 <AstralStorm> In Unix package.
12:59:31 <AstralStorm> RyanT5000: probably in older version it was in a separate package?
12:59:39 <AstralStorm> I'd drop the dep.
12:59:43 <RyanT5000> alright
13:00:31 <AstralStorm> @where relnotes 6.6
13:00:31 <lambdabot> I know nothing about relnotes.
13:01:58 <RyanT5000> hm, can't find System.Posix.IO
13:02:10 <SamB> @hoogle System.Posix.IO
13:02:10 <lambdabot> No matches, try a more general search
13:02:13 <SamB> hmm
13:02:17 <RyanT5000> maybe i need to add unix
13:02:30 <SamB> RyanT5000: yeah, I have that in unix
13:02:54 <SamB> so is this hoogle database from win32?
13:02:58 <RyanT5000> btw, has anyone here used hfuse?
13:03:08 <RyanT5000> SamB: it's very incomplete regardless
13:03:13 <RyanT5000> doesn't have many optional libs at all
13:03:22 <RyanT5000> like OpenGL
13:03:35 <RyanT5000> which would be *really* nice to have
13:04:18 <AstralStorm> ?hoogle Release Notes 6.6
13:04:18 <lambdabot> Hoogle Error: Parse Error: Unexpected character '6.6'
13:04:23 <AstralStorm> Blah.
13:04:33 <AstralStorm> ?google GHC Release Notes 6.6
13:04:35 <lambdabot> http://www.mail-archive.com/cvs-all@haskell.org/msg26637.html
13:04:35 <lambdabot> Title: patch applied (ghc-6.6/ghc): Release notes should mention better newtype
13:04:43 <AstralStorm> Wtf...
13:04:52 <AstralStorm> ?google GHC 6.6 Release Notes
13:04:52 <lambdabot> http://www.mail-archive.com/cvs-all@haskell.org/msg26637.html
13:04:53 <lambdabot> Title: patch applied (ghc-6.6/ghc): Release notes should mention better newtype
13:05:07 <AstralStorm> Except they exist.
13:05:34 <AstralStorm> http://www.haskell.org/ghc/dist/current/docs/users_guide/release-6-6.html
13:05:36 <lambdabot> Title: 1.4. Release notes for version 6.6, http://tinyurl.com/h2hdm
13:06:27 <SamB> RyanT5000: it would be nice if hoogle databases could be easily cross-compiled...
13:06:34 <AstralStorm> Somebody should write a ?relnotes plugin :>
13:06:43 <AstralStorm> Like ?docs
13:06:44 <SamB> you mean like
13:06:52 <SamB> @relnotes ghc 6.4.2
13:06:52 <lambdabot> Unknown command, try @list
13:06:59 <AstralStorm> Mhm.
13:07:15 <weitzman> @relschedule Duke Nukem
13:07:15 <lambdabot> Unknown command, try @list
13:07:24 <SamB> there being, you know, multiple haskell compilers and such ;-)
13:07:40 <AstralStorm> SamB: what about just extending ?docs
13:07:46 <weitzman> @bufinfo Why is darcs so hard to set up on windows?
13:07:46 <lambdabot> Unknown command, try @list
13:07:49 <AstralStorm> E.g. ?docs ghc 6.6
13:07:53 <weitzman> s/buf/bug
13:08:00 <AstralStorm> That'd give user-guide
13:08:04 <SamB> weitzman: you mean
13:08:17 <SamB> @relschedule Duke Nukem Forever
13:08:17 <lambdabot> Unknown command, try @list
13:08:18 <SamB> right?
13:08:25 <weitzman> SamB: Yeah
13:08:59 <profmakx> well with haskell there is a way to express the release schedule for duke nukem forever
13:09:07 <profmakx> weve ggot infinite lists -.-
13:09:36 <SamB> profmakx: I prefer _|_
13:09:40 <weitzman> > let schedule = foldl1 (+ 1) schedule in schedule
13:09:41 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
13:09:41 <lambdabot>    Expe...
13:09:46 <SamB> hah
13:09:55 <profmakx> yeah or that ^^
13:10:31 <SamB> how about just listing the time-to-release as forever and a day?
13:10:37 <weitzman> > let schedule = (fix id)
13:10:37 <lambdabot>  Parse error
13:10:42 <weitzman> > (fix id)
13:10:43 <lambdabot>  Add a type signature
13:10:51 <weitzman> > (fix id) :: Int
13:10:52 <lambdabot>  Exception: <<loop>>
13:10:57 <glguy> Hurray for: f (!x, y) = [x,y]
13:11:20 <weitzman> @hoogle (a, a) -> [a]
13:11:21 <lambdabot> No matches, try a more general search
13:11:21 <dolio> Oh yeah, that's another reason to want 6.6.
13:11:56 <dolio> No more "f x y z | x `seq` y `seq` z `seq` False = undefined ..."
13:12:07 <glguy> ^ === dirty hack
13:13:37 <RyanT5000> lol irc for emacs
13:13:50 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
13:14:30 <dolio> Can emacs organize and play my mp3s yet?
13:14:37 <xerox> Yep.
13:14:44 <dolio> Heh.
13:14:48 <RyanT5000> i think someone should port linux to  emacs
13:14:53 <xerox> http://www.gnu.org/software/emms/
13:15:15 <dolio> Wow, it even does album art.
13:15:15 <int-e> why would you run a bootloader on emacs?
13:15:20 <glguy> emacs is a great operating system buy I prefer openbsd
13:15:28 <xerox> dolio: yeah :)
13:15:43 <SamB> openbsd is a lousy editor though
13:15:47 <xerox> dolio: want to see the craziest thing I found lately for emacs... ?
13:15:53 <RyanT5000> int-e: why would you ever run x on emacs?
13:15:54 <dolio> I was about to ask sarcastically if it did, but I figured I should play it safe and keep my mouth shut.
13:16:04 <RyanT5000> for any given x, someone's done it
13:16:15 <RyanT5000> or, for many given x
13:16:22 <dolio> xerox: Sure.
13:16:27 <SamB> RyanT5000: you mean people have done it for X1 through X11?
13:16:32 <int-e> RyanT5000: I don't know. But it's a comfortable editor if you're used to it.
13:16:37 <xerox> ``MTorus is the image of the canonical homomorphism from prefix maps to a subset of the powerset of the set of all buffers within an emacs session.'' <http://mtorus.berlios.de/>
13:16:41 <RyanT5000> SamB: no, i mean to use x as a variable
13:16:56 <weitzman> Sometimes I start to feel a little sad that I can't play music from within VIM.
13:16:58 <weitzman> Then I get over it
13:16:58 <RyanT5000> (i realized after i said it i could be mistook as having meant X)
13:17:18 * xerox awaits the more mathematically-inclined Haskellers to notice what he just wrote...
13:17:41 <profmakx> o.O
13:17:51 <profmakx> i had to read it at least three times -.-
13:17:57 <AstralStorm> Hehe, you can even make emacs your WM :>
13:18:01 <SamB> hah
13:18:06 * xerox grins
13:18:11 <AstralStorm> ?google Emacs Window Manager
13:18:20 * SamB prefers a more stable WM
13:18:35 <profmakx> whats about the kitchen sink thing then?
13:18:46 <SamB> hmm?
13:18:49 <AstralStorm> There is one, called "doctor"
13:18:57 <SamB> emacs *IS* the kitchen sink
13:18:59 <glguy> Emacs: A jack of all trades is a master of none!
13:19:09 <sris> is there a function "line" in the standard prelude?
13:19:17 <SamB> glguy: well, emacs does actually do some things pretty well
13:19:49 <SamB> especially considering it isn't emacs that does most of the work
13:19:58 <SamB> but rather programs that run on the emacs platform ;-)
13:20:20 <RyanT5000> what's the argument for emacs being the platform of all these programs?
13:20:25 <RyanT5000> what does it provide?
13:20:26 <weitzman> Lambdabot stopped talking to me
13:20:28 <weitzman> > 1
13:20:34 <SamB> basic text-editing features
13:20:45 <SamB> a LISP system
13:20:54 <SamB> not a very good one, but it works...
13:21:06 <AstralStorm> ?ping
13:21:12 <SamB> oh, and a large userbase ;-)
13:21:20 <RyanT5000> ah, that's the real issue :)
13:21:23 <AstralStorm> SamB: not really "basic" editor features.
13:21:26 <weitzman> @version
13:21:28 <AstralStorm> Some are really good.
13:21:30 <weitzman> @tell dons Lambdabot has gone into lurking-only mode
13:21:45 <SamB> AstralStorm: Well, it does provide the basics though ;-)
13:21:47 <AstralStorm> weitzman: who will tell if Lambdabot is lurking?
13:21:49 <weitzman> That's not going to work
13:21:53 <weitzman> Yeah
13:21:55 <weitzman> I just realized
13:22:03 <SamB> hah
13:22:04 <weitzman> Well that's a bit of a problem
13:22:23 <AstralStorm> Who crashed it?
13:22:27 <SamB> hmm, what is that *serv that you use for leaving notes?
13:22:28 <SamB> memoserv?
13:23:02 <SamB> does anyone want to start a replacement?
13:23:14 <AstralStorm> Yes, memoserv.
13:23:38 <SamB> if the lambdabot services are being provided by a bot with some other nick, dons will notice ;-)
13:23:39 <AstralStorm> Kick it and maybe it'll return...
13:25:08 <RyanT5000> where am i supposed to get HsOpenGLConfig.h?
13:25:14 <coldasice> anyone got any papers on how to define datatypes and how to use them?
13:25:48 <SamB> RyanT5000: well... have you read any text files named in all caps in that directory?
13:25:58 <RyanT5000> :) good point
13:26:48 <AstralStorm> coldasice: some tutorials? :>
13:27:38 <AstralStorm> Unfortunately lambdabot is out, so: www.haskell.org
13:27:46 <AstralStorm> Check "Learning Haskell" part.
13:28:29 <coldasice> AstralStorm, thanks ill check it out
13:30:54 <glguy> without a lambdabot I guess I might as well just switch to Clean
13:31:22 <SamB> glguy: come on!
13:31:26 <RyanT5000> lol
13:31:38 <SamB> it would take you longer to learn clean than it will take dons to wake up and restart lambdabot!
13:31:48 <weitzman> I'm curious about Clean, but it doesn't seem to have a community
13:31:53 <SamB> why, it might even take longer for you to *INSTALL* clean!
13:32:01 <weitzman> And with no information, software, or people to talk to
13:32:02 <weitzman> ...
13:32:03 <glguy> LOL
13:32:14 <glguy> installing clean is definitely not a challenge
13:32:17 <glguy> you download the zip file
13:32:20 <glguy> and it's done
13:32:23 <weitzman> Cool
13:32:30 <weitzman> Does well in the great shootout
13:32:57 <glguy> I downloaded it to see what it's IDE was like
13:33:32 <weitzman> I'm not entirely sold on Monads. Seems like things get really awkward when you want to use two or more monads at the same time
13:33:45 <araujo> glguy, how good is it?
13:33:59 <glguy> The IDE appears terrible
13:34:01 <araujo> weitzman, how come?
13:34:14 <araujo> glguy, well, the language
13:34:28 <glguy> I haven't learned enough to make a judgement
13:34:33 <weitzman> Example: http://sigfpe.blogspot.com/2006/09/local-and-global-side-effects-with.html
13:34:34 * araujo usually doesn't like IDEs anyway
13:34:39 <glguy> a lot of things feel more awkward in Clean
13:34:51 <glguy> but that could be because I haven't gotten far enough
13:34:57 <araujo> yes, Haskell has corrupted all of us by now
13:36:13 * SamB wouldn't know that he wrote part of lambdabot's README if he had forgotten ;-)
13:37:10 <SamB> weitzman: it is true
13:37:33 <SamB> things do get awkward if you want to use two monads at the same time
13:38:02 <glguy> two is easy
13:38:13 <glguy> I imagine that it gets harder with more
13:38:18 <SamB> which is why we have monad transformers...
13:40:18 <SamB> hmm
13:40:27 <SamB> I must be doing something wrong...
13:40:59 <arjanoosting> @seen CosmicRay
13:41:26 <glguy> you aren't on the lambdabot approved list
13:41:27 <glguy> sorry
13:41:38 <arjanoosting> :-D
13:41:47 <SamB> what!
13:42:31 <SamB> okay, isn't lambdabot supposed to load modules dynamically?
13:45:04 <hyrax42> is ghc 6.6 relese iminent?
13:45:08 <hyrax42> release
13:49:04 <glguy> Anyone here used Control.Applicative?
13:49:47 <Igloo> hyrax42: It's at least a week or so away
13:52:32 <SamB> someone said that it isn't comeing out next week because of ICFP
13:58:30 <RyanT5000> has anyone here used any of these haskell-based shells?
13:58:43 <RyanT5000> followup question: are any of them any good?
13:59:24 <SamB> someone must have at least tried them!
13:59:29 <SamB> I do not know how useful they are.
14:00:04 <RyanT5000> the main thing that makes a shell useful is the massive amount of code that's been written against it
14:00:19 <dylan> Err
14:00:19 <RyanT5000> so i'd be very interested to see how they dealt with that
14:00:34 <dylan> the main thing that makes my shell useful is the amount of shortcuts it has
14:00:46 <RyanT5000> what's the difference?
14:01:09 <dylan> I'd say the code isn't written against it, but written for it.
14:01:18 <dylan> "against it" assume == shell scripts
14:01:28 <RyanT5000> yeah, that's what i meant
14:01:35 <dylan> and the shell I use is a not very popular for shell scripts
14:01:45 <AstralStorm> Well, the only thing working for shell is the ubiquity of Bash or Ksh
14:01:45 <RyanT5000> yeah, you have a point
14:01:47 <RyanT5000> what shell is that?
14:01:54 <AstralStorm> Fish?
14:01:55 <dylan> zsh
14:02:15 <dylan> it's a bourne shell still, but it has more features than some text editors.
14:02:33 <AstralStorm> So use a text editor instead... and EShell.
14:02:37 <dylan> I never write shell scripts, unless you consider an interactive session a shell script
14:02:58 * edwardk waves hello.
14:03:04 <dylan> Heh, no thanks, I like my superglob, and my pattern specifiers.
14:03:24 <AstralStorm> Implement that in Haskell and move to hash ;-)
14:03:26 <dylan> and the builtin ftp client.
14:03:30 <AstralStorm> Good codename, right?
14:03:35 <AstralStorm> HaSH
14:03:47 <dylan> I'd have to make sure there is completion for everything I use.
14:04:07 <dylan> e.g. for apti<tab> in<tab> ghc-<tab>
14:04:38 <AstralStorm> Which rules of completions would you want?
14:04:56 <dylan> as many as I have now
14:05:17 <AstralStorm> Hehe, what about DWIM?
14:05:37 <AstralStorm> Or mind-reading?
14:05:44 <dylan> Oh, and there is the autocd feature
14:05:51 <dolio> I quite enjoy zsh for being able to do: /e/a/sou<tab> --> /etc/apt/sources.list
14:06:09 <dylan> e.g. /etc/apt -> cd /etc/apt
14:06:13 <dmwit> Also, using the '=' search can come in handy...
14:06:16 <AstralStorm> With a single tab-press? Possible to do.
14:06:20 <AstralStorm> dylan: simple too :>
14:06:31 <dylan> anyway:
14:06:38 <dylan> % ls /usr/share/zsh/4.3.2/functions/Completion/**/*(.) | wc -l
14:06:38 <dylan> 510
14:06:56 <AstralStorm> Writing proper completions in Haskell could be even easier.
14:06:59 <dylan> zsh only comes with completion for a few commands.
14:07:18 <dylan> AstralStorm: even when you have to parse the output of wayward programs?
14:07:27 <AstralStorm> Which wayward? :P
14:07:33 <dmwit> Also, zsh has a LOT of options -- I don't think it's practical to rebuild them all.  For example...
14:07:38 <dylan> one with a non-standard --helo output
14:07:49 <dmwit> ~% grep setopt .zshrc
14:07:49 <dmwit> setopt autocd autopushd nocheckjobs nohup completeinword alwaystoend printexitvalue multios correct no_nomatch
14:07:54 <AstralStorm> dylan: then you hardcode the completion? :P
14:08:17 <dylan> AstralStorm: that's an eew situation. :P
14:08:24 <AstralStorm> zsh does that too :P
14:08:44 <AstralStorm> (for really backward programs)
14:08:56 <AstralStorm> You could also parse manpages where available.
14:09:10 <dylan> I'd rather write something that makes program use uniform dash options.
14:09:35 <AstralStorm> dylan: hehehe :>
14:09:41 <AstralStorm> Backcompletion
14:09:47 <dylan> I have wrappers for cdrecord, find, and some other things
14:10:07 <dylan> as I always type find --name "foo" dir
14:10:08 <AstralStorm> Now find is a special case.
14:10:12 <SamB> @tell dons that it takes WAAAY to long to link lambdabot statically, and that he must figure out how to make it easy to build dynamically
14:10:12 <AstralStorm> Options are positional.
14:10:23 <_SamB_bot> Consider it noted.
14:10:24 <AstralStorm> SamB: lambdabot is dead :P
14:10:31 <AstralStorm> what? :P
14:10:34 <SamB> AstralStorm: I am aware ;-)
14:10:52 <AstralStorm> Huh, another bot. Let's see...
14:11:08 <dmwit> dylan: I think you've just nailed the problem.  People already have a warehouse full of tricks for whatever shell they use, making it a real pain to switch to any new shell...
14:11:34 <dylan> dmwit: my find and cdrecord wrappers are perl scripts, but yes. my .zsh dir is huge
14:11:47 <AstralStorm> SamB: what does your bot support?
14:11:48 <dylan> it's not as big as my .vimrc and .vim config, but it's still huge.
14:11:59 <weitzman> > 1
14:12:01 <SamB> AstralStorm: it is lambdabot, but named differently
14:12:05 <_SamB_bot>  1
14:12:10 <weitzman> And slower...?
14:12:11 <AstralStorm> I know it is.
14:12:17 <dylan> @let foo = 1.2
14:12:24 <_SamB_bot> Defined.
14:12:25 <SamB> yes, running it on a PII 450 MHz has a way of making it slower
14:12:27 <dmwit> dylan: Both vim and zsh?  How can one man have such good taste? ;-)
14:12:31 <AstralStorm> @djinn a -> b -> c -> (a, b, c)
14:12:31 <_SamB_bot> f a b c = (a, b, c)
14:12:31 <SamB> I asked if anyone else wanted to
14:12:42 <SamB> noone volunteered
14:12:42 <AstralStorm> @djinn a -> b -> c -> (a, (b, c))
14:12:42 <_SamB_bot> f a b c = (a, (b, c))
14:12:43 <dylan> dmwit: I use mutt, abook, ncmpc, and w3m too.
14:12:52 <AstralStorm> :>
14:12:53 <dylan> though, hmp3 looks quite nice
14:12:58 <weitzman> I'm all for vim and zsh, but you gotta use pine too
14:13:05 <SamB> @hoogle map
14:13:07 <_SamB_bot> Prelude.map :: (a -> b) -> [a] -> [b]
14:13:07 <_SamB_bot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
14:13:07 <_SamB_bot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
14:13:11 <SamB> whoa
14:13:12 <dmwit> Ah, I've been meaning to look at mutt.
14:13:12 <SamB> that worked
14:13:13 <AstralStorm> I prefer proper bash to zsh
14:13:18 <SamB> I was not expecting that to work!
14:13:31 <SamB> @hoogle posix
14:13:34 <_SamB_bot> Text.Regex.Posix :: module
14:13:34 <_SamB_bot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
14:13:34 <_SamB_bot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
14:13:42 <dylan> I hate bash, only because it doesn't let me warp its behavior like zsh does
14:13:43 <AstralStorm> It has 75% the functionality at 10% the cost :P
14:13:54 <SamB> @hoogle System.Posix.IO
14:13:58 <_SamB_bot> No matches, try a more general search
14:14:03 <dmwit> AstralStorm: What cost?
14:14:15 * AstralStorm puts dylan in front of a box with bash and no compiler
14:14:17 <dylan> AstralStorm: I make up for using zsh by running rxvt rather than xterm, and not running a big window manager.
14:14:21 <AstralStorm> :>
14:14:46 <SamB> dylan: hmm?
14:14:47 <AstralStorm> And no write rights, too :P
14:14:51 <SamB> zsh is expensive?
14:14:54 <mauke> @let whatever = return ()
14:14:57 <_SamB_bot> <local>:2:11:     Ambiguous type variable `m' in the constraint:       `Monad...
14:14:58 <shapr> I thought zsh was faster and smaller than bash?
14:15:02 <AstralStorm> Nope.
14:15:17 <dylan> zsh has faster completion
14:15:20 <dylan> in my experience.
14:15:28 <weitzman> Bash can probably do this too, but I was very satisfied when I got zsh to tab-complete remote filenames for scp commands using kerberos authentication
14:15:31 <AstralStorm> Better written maybe - but not faster :>
14:15:35 <dylan> bash's enhanced completion is very slow
14:15:44 <SamB> zsh is way down in the top M list...
14:15:56 <shapr> What does bash do faster?
14:15:58 <Syzygy-> weitzman: That's neat.
14:16:30 <dmwit> weitzman: Ah, I'm a spoiled Ubuntu brat; it comes standard... =P
14:16:30 <AstralStorm> shapr: POSIX
14:16:35 <SamB> @let x = ()
14:16:39 <_SamB_bot> Defined.
14:16:48 <weitzman> dmwit: I was using ubuntu... maybe it's standard now?...
14:16:50 <AstralStorm> > die with x
14:16:53 <_SamB_bot>  Not in scope: `x'
14:16:59 <dmwit> > L.x
14:16:59 <AstralStorm> > L.x
14:17:02 <_SamB_bot>  Not in scope: `L.x'
14:17:05 <_SamB_bot>  Not in scope: `L.x'
14:17:19 <AstralStorm> Let's DoS SamB through his bot :P
14:17:27 <dmwit> =D
14:17:29 <SamB> heh
14:17:30 <shapr> AstralStorm, huh?
14:17:40 <AstralStorm> shapr: zsh isn't POSIX-compatible :/
14:17:42 <SamB> I do have ^C you know
14:17:44 <int-e> @botsnack
14:17:45 <_SamB_bot> :)
14:17:49 <AstralStorm> SamB: hehe
14:17:56 <dylan> is haskell POSIX-compatible?
14:17:59 <weitzman> dmwit: I had to do some futzing actually, because I need to install a package that would replace a dependency for the umbrella ubuntu package
14:18:01 <AstralStorm> dylan: no.
14:18:04 <SamB> dylan: nope!
14:18:17 <SamB> POSIX doesn't say anything about Haskell at all
14:18:25 <dmwit> weitzman: Huh.  All I can say is, I didn't have to do anything for it...
14:18:29 <weitzman> dmwit: I think that was just to get scp to speak kerberos
14:18:29 <AstralStorm> There is only Haskell 98 "standard"
14:18:42 <SamB> and vice versa
14:18:51 <SamB> Haskell doesn't say anything about POSIX
14:18:58 <lispy> ?uptime
14:18:58 <_SamB_bot> uptime: 9m 40s, longest uptime: 8h 27m 8s
14:19:03 <SamB> now, implementations tend to like POSIXy systems
14:19:05 <lispy> hmm...
14:19:06 <shapr> How is zsh not posix? Also,why hasn't that ever affected me?
14:19:25 <SamB> shapr: in terms of being a shell, not in terms of running, I assume
14:19:32 <dmwit> shapr: zsh is 100% bash compatible, so...
14:19:33 <AstralStorm> SamB: the bot doesn't respond to /msg
14:19:38 <lispy> > let facts = 1 : zipWith (*) facts (tail facts) in facts
14:19:42 <_SamB_bot>  Terminated
14:19:43 <SamB> that is, it would not be appropriate for #!/bin/sh on a POSIX system
14:19:55 <lispy> > let facts = 1 : zipWith (*) facts (tail facts) in take 4 facts
14:20:06 <dmwit> > let facts = scanl (*) [1..]
14:20:07 <_SamB_bot>  Exception: <<loop>>
14:20:07 <_SamB_bot>  Parse error
14:20:21 <lispy> oh
14:20:23 <SamB> > x
14:20:26 <int-e> lispy: what are you doing?
14:20:26 <_SamB_bot>  Not in scope: `x'
14:20:28 <dmwit> > let facts = scanl1 (*) [1..]
14:20:29 <_SamB_bot>  Parse error
14:20:33 <lispy> > let facts = 1 : 1 : zipWith (*) facts (tail facts) in take 4 facts
14:20:36 <int-e> > scanl1 (*) [1..]
14:20:37 <_SamB_bot>  [1,1,1,1]
14:20:38 <SamB> @help let
14:20:41 <_SamB_bot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
14:20:41 <_SamB_bot> let <x> = <e>. Add a binding
14:20:45 <weitzman> I think lispy is trying to accidentally kill sam's machine
14:20:50 <lispy> :)
14:20:54 <SamB> come now
14:21:03 <lispy> no, i was trying to do factorial like the fibs, but i see i'm being silly
14:21:07 <dmwit> > let facts = scanl (*) 1 [1..] in take 4 facts
14:21:07 <SamB> linking lambdabot is more likely to kill my machine
14:21:11 <_SamB_bot>  [1,1,2,6]
14:21:16 <int-e> > [p|p<-[1..2]]
14:21:17 <_SamB_bot>  parse error on input `<-'
14:21:19 <SamB> it isn't even swapping
14:21:37 <SamB> well, I mean, not more than a tiny bit here and there
14:22:32 <AstralStorm> > [1..]
14:22:36 <_SamB_bot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:23:03 <AstralStorm> > length [1..]
14:23:08 <dmwit> Terminated.
14:23:18 <_SamB_bot> Terminated
14:23:23 <AstralStorm> Hehehe :P
14:23:24 <dmwit> Argh, no '.'.
14:23:44 <AstralStorm> > reverse [1..]
14:23:52 <_SamB_bot> Terminated
14:23:52 <dmwit> Come on...
14:23:53 <AstralStorm> Also :P
14:23:58 <ValarQ> AstralStorm: killing SamBs machine? :)
14:24:04 <AstralStorm> Trying to :>
14:24:09 <SamB> hah
14:24:11 <ValarQ> heh
14:24:14 <dmwit> =)
14:24:16 <AstralStorm> @yarr!
14:24:17 <_SamB_bot> What be a priate's favourite cheese?
14:24:17 <_SamB_bot> Yarrlsburg!
14:24:22 <dmwit> @yow!
14:24:22 <_SamB_bot> Couldn't find fortune file
14:24:27 <SamB> don't you know runplugs is proof against that?
14:24:30 <AstralStorm> @buggybot
14:24:30 <_SamB_bot> Unknown command, try @list
14:24:31 <SamB> well, if it isn't...
14:24:36 <SamB> we'll need to fix it.
14:24:48 <AstralStorm> SamB: throttling?
14:25:00 <SamB> it has a time limit at the very least
14:25:03 <SamB> it might do more
14:25:09 <int-e> @index head
14:25:09 <AstralStorm> ^
14:25:09 <_SamB_bot> Data.List, Prelude
14:25:22 <int-e> @hoogle a -> a
14:25:31 <_SamB_bot> Prelude.id :: a -> a
14:25:31 <_SamB_bot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
14:25:31 <_SamB_bot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:25:35 <glguy> ?nick haskellbot
14:25:35 <_SamB_bot> Maybe you meant: dice dict
14:25:56 <AstralStorm> @dice [1..]d[1..]
14:25:56 <_SamB_bot> unexpected "[": expecting number
14:25:57 <emu> > let a 0 n = n + 1; a m 0 = a (m - 1) 1; a m n = a (m - 1) (a m (n - 1)) in a 4 3
14:26:04 <_SamB_bot> Terminated
14:26:09 <AstralStorm> @dice 987654321d987654321
14:26:09 <_SamB_bot> 987654321d987654321 => 487738079806734631
14:26:24 <AstralStorm> Huh, it's even correct :>
14:26:30 <emu> > let a 0 n = n + 1; a m 0 = a (m - 1) 1; a m n = a (m - 1) (a m (n - 1)) in a 3 4
14:26:34 <_SamB_bot>  125
14:26:49 <AstralStorm> emu: explain and simplify :P
14:26:54 <emu> Ackermann
14:27:09 <AstralStorm> Ah right.
14:27:13 <profmakx> that was the first thing i tried on my lambdabot ^^
14:27:14 <AstralStorm> Distance in a nice form.
14:29:27 <AstralStorm> > let fact x = x * fact (x-1); fact 0 = 1
14:29:27 <_SamB_bot>  Parse error
14:29:38 <AstralStorm> > fact x = x * fact (x-1); fact 0 = 1
14:29:38 <_SamB_bot>  Parse error
14:29:46 <AstralStorm> What the...
14:29:49 <dmwit> > let fact x = product [1..x] in fact 5
14:29:53 <_SamB_bot>  120
14:29:55 <AstralStorm> Blah blah :P
14:29:56 <mauke> > let fact x = x * fact (x-1); fact 0 = 1 in fact 5
14:29:57 <dmwit> (Forgot the "in"...)
14:29:59 <_SamB_bot>    Warning: Pattern match(es) are overlapped
14:29:59 <_SamB_bot>        In the definition...
14:30:07 <AstralStorm> I know, I'm just trying to kill his machine :>
14:30:26 <SamB> heh
14:30:31 <AstralStorm> > let fact 0 = 1; fact x = x * fact (x-1) in fact 10
14:30:35 <_SamB_bot>  3628800
14:30:39 <AstralStorm> > let fact 0 = 1; fact x = x * fact (x-1) in fact 1024
14:30:43 <_SamB_bot>  5418528796058857283076921944683854738001553963538013444482870270683210612073...
14:30:46 <SamB> if you come remotely close, I will hear it thrashing and consider killing lambdabot...
14:30:56 <AstralStorm> Huh, even fits in the timelimit.
14:31:03 <dmwit> > let fact n = product [1..n] in fact 1024
14:31:03 <SamB> as it is I have 100MB of RAM free
14:31:07 <_SamB_bot>  5418528796058857283076921944683854738001553963538013444482870270683210612073...
14:31:16 <SamB> though I do have onl7 78 MB of swap free...
14:31:17 <mauke> @let (whatever :: (Monad m) => m ()) = return ()
14:31:18 <_SamB_bot>  Parse error in pattern
14:31:35 <glguy> lambdabot has survived many attempted murders
14:31:44 <glguy> why would _SamB_bot suddenly be vulnerable?
14:32:10 <emu> > let a 0 n = n + 1; a m 0 = a (m - 1) 1; a m n = a (m - 1) (a m (n - 1)) in a 3 30
14:32:16 <_SamB_bot> Terminated
14:32:19 <SamB> glguy: well, I do have a PII 450 MHz with 256 MB of RAM, 1 GB of swap, and firefox leaking away
14:32:19 <emu> darn
14:32:24 <AstralStorm> > let fact 0 = 1; fact x = x * fact (x-1); map fact [1..100]
14:32:25 <_SamB_bot>  Parse error
14:32:32 <AstralStorm> > let fact 0 = 1; fact x = x * fact (x-1) in fact [1..100]
14:32:34 <dmwit> glguy: no "lambda" in "_SamB_bot"... ;-)
14:32:35 <_SamB_bot>  add an instance declaration for (Num [a])
14:32:35 <_SamB_bot>   In the definition of `uiu':
14:32:35 <_SamB_bot>  ...
14:32:40 <AstralStorm> Blah.
14:32:50 <glguy> > length $ show $ 2^35000
14:32:53 <SamB> @version
14:32:55 <_SamB_bot>  10537
14:32:55 <_SamB_bot> lambdabot 4p218, GHC 6.4.1 (Linux i686 (Deschutes))
14:32:55 <_SamB_bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
14:33:07 <AstralStorm> Ouch, PII.
14:33:27 <SamB> AstralStorm: its the 256 MB of RAM that really hurts
14:33:58 <AstralStorm> YOu know you're a geek when... you remember which core codenames match which processor
14:34:20 <dmwit> My dad doesn't believe me that his fabulous PIV is slow because he has only 256MB of RAM...
14:34:24 <SamB> also I did just say I have a PII 450 MHz with 256 MB of RAM and 1 GB of swap...
14:34:32 <SamB> dmwit: hah!
14:34:38 <glguy> dmwit: when you say dad I assume Windows XP
14:34:38 <AstralStorm> dmwit: because it's logically untrue.
14:34:47 <SamB> AstralStorm: it isn't untrue
14:34:49 <AstralStorm> The processor isn't any slower by the machine having less ram :P
14:34:52 <glguy> dmwit: and 256mb + windows xp === slow
14:34:53 <dmwit> glguy: True...
14:34:57 <dylan> You know you're insane when... http://hardison.net/~spoony/img.jpg
14:34:58 <glguy> :)
14:35:00 <glguy> so I agree
14:35:09 <SamB> well, the processor is not effectively fast if it is stalled waiting for disks all the time
14:35:24 <AstralStorm> dylan: wtf?
14:35:41 <dylan> AstralStorm: that's Software Freedom Day Man
14:35:49 <AstralStorm> Ohmy.
14:35:49 <dylan> and also possibly me.
14:36:01 <SamB> dylan: you said the other day that you were him!
14:36:02 <AstralStorm> That's really insane ;-)
14:36:09 <SamB> you stole an orphanage tablecloth for a cape!
14:36:10 <glguy> This is why IRC is not video-conference capable
14:36:16 <dmwit> =D
14:36:21 <SamB> and someone asked you if you were insane enough to try Haskell yet!
14:36:21 <dylan> http://hardison.net/~spoony/img2.jpg
14:36:28 <dylan> SamB: Yep!
14:36:42 <dylan> the person in the green shirt is the one that asked me if I was insane enough for haskell.
14:37:04 <AstralStorm> Huh, you guys don't really look worse than me. I'm impressed! :P
14:37:27 <AstralStorm> Blah.
14:37:34 <AstralStorm> s/worse/better/ if you wish
14:38:09 <dylan> I'm told I resemble either a) a college student, or b) richard stallman.
14:38:09 <basti_> I'm looking good.
14:38:30 <basti_> whats up with the sticks?
14:38:40 <AstralStorm> dylan: uh.
14:38:41 <dylan> basti_: they have penguins on them
14:38:48 <basti_> ok
14:38:55 <AstralStorm> I'm told I resemble a computer scientist.
14:39:25 <SamB> AstralStorm: people know what those look like?
14:39:32 <AstralStorm> Around here, yes.
14:39:32 <AstralStorm> :P
14:39:34 <dylan> Ah, good. I hope to be a computer  scientist eventually. If my college would cooperate more. :P
14:39:35 <ihope> What do computer scientists look like?
14:39:51 <basti_> I'm usually told I look like a) a physicist b) a social scientist c) a musican
14:39:58 <AstralStorm> Beards, unkempt hair, altmodisch :P
14:40:06 <basti_> I don't know if that's a sign of my uni or a sign of my appearance
14:40:17 <dylan> basti_: never a psycopath?
14:40:18 <SamB> AstralStorm: oooh
14:40:18 <AstralStorm> not necessarily oldfashioned :>
14:40:25 <SamB> what was that last thing?
14:40:26 <basti_> no
14:40:36 <shapr> Modisch? Are you from .de?
14:40:39 <Tela> ihope: unkept hair/ponytail, bleary eyes, glasses, pale skin ... these are the markings of CS divinity.
14:40:42 <ihope> AstralStorm: ah, so like that one friend I have?
14:40:43 <AstralStorm> shapr: no, /whois
14:40:58 <AstralStorm> Tela: right on spot
14:41:01 <dolio> http://homepages.inf.ed.ac.uk/wadler/Pics/philtie.gif ?
14:41:02 <_SamB_bot> http://tinyurl.com/kps5p
14:41:04 <ihope> Who needs /whois when you have prefixes?
14:41:11 <AstralStorm> Especially bleary eyes with rings and pale skin
14:41:12 <SamB> I need to wear my glasses more then ;-)
14:41:17 <AstralStorm> ihope: .pl
14:41:17 <ihope> And why *do* we have prefixes?
14:41:22 <emu> lots of those around here
14:41:47 <Tela> Contacts are for closet CS priests. They let them infiltrate the masses.
14:41:48 <xerox> ?quote sieni
14:41:48 <_SamB_bot>  C provides people with the expressiveness of fortran combined with the portability of assembler
14:41:48 <shapr> AstralStorm, I'm from Alabama, but my hostname has said .se or .fi the last seven years.
14:41:50 <dmwit> Fashion sense is a definite no if you want to look CS-y.
14:41:50 <xerox> ?quote sieni
14:41:51 <_SamB_bot>  C provides people with the expressiveness of fortran combined with the portability of assembler
14:41:54 <xerox> Pfft.
14:42:06 <AstralStorm> Hehe.
14:42:20 <SamB> I haven't got fashion sense!
14:42:22 <AstralStorm> Actually, that guy looks like a proffessor.
14:42:27 <emu> personal hygiene too
14:42:27 <ihope> AstralStorm: ...what about .pl?
14:42:29 <emu> or lack thereof
14:42:44 <SamB> Tela: I don't wear contacts
14:43:04 <dmwit> On the other hand, it is for some reason considered acceptable to have a sense of humor.
14:43:06 <SamB> its just that I only have trouble seeing distant things
14:43:12 <AstralStorm> There's a small difference. You see, no bleary eyes with rings...
14:43:13 <SamB> so I usually don't bother with my glasses
14:43:21 <AstralStorm> Maybe a CS proffessor? :P
14:43:22 <SamB> unless I have trouble seeing the board at school
14:43:28 <Tela> SamB: Same here. My glasses only are necessary when I read a tonne.
14:43:52 <SamB> huh?
14:44:02 <AstralStorm> Unfortunately, I must have my glasses on always :/
14:44:05 <SamB> I don't wear glasses for reading unless I need to read far-away things
14:44:36 <SamB> dmwit: a very bad sense of humour!
14:44:56 <Tela> My optomitrists get confused. My eyes can apparently strain themselves and be A OK, but then they wear out quickly and I get headaches
14:45:13 <dmwit> Sorry, my doctor says it's on the up-and-up: just a few more weeks and it will be fully recovered. =)
14:45:27 <AstralStorm> SamB: no, an English sense of humour
14:45:38 <AstralStorm> Monthy Python kind
14:45:40 <SamB> AstralStorm: I might have one
14:45:50 <Tela> My CS teacher is english. It rocks my world
14:46:16 <SamB> don't imagine where it came from, though, if I do...
14:46:44 <dolio> My data structures professor sent everyone in the class an mp3 about data structures entitled "Find the Longest Path," to the tune of "For the Longest Time."
14:46:57 <SamB> hah
14:47:01 <dmwit> Oooh oh oh, ...
14:47:02 <dolio> Now that's a CS sense of humor.
14:47:02 <dmwit> =D
14:47:11 <AstralStorm> Well, I have myopsis of -6 D. Sucks really.
14:47:26 <ihope> Imaginary numbers / They're easy if you try
14:47:48 <AstralStorm> :D
14:47:56 <dmwit> As one prof. once told me: life is complex; it has real and imaginary parts.
14:48:05 <AstralStorm> That's old.
14:48:10 <ihope> When a negative's under the radical / You just remove the 'i'
14:48:11 <dmwit> I like it.
14:48:36 <AstralStorm> The problem is that it's discontiguous.
14:48:52 <dylan> I think I'd like to teach CS some day. it'd be a good excuse to be insane.
14:48:56 <ihope> What's discontiguous?
14:49:22 <Tela> If you need an excuse like that, I think mathematics is actually even better for it
14:49:26 <AstralStorm> ?dict contiguous
14:49:26 <_SamB_bot> Supported dictionary-lookup commands:
14:49:26 <_SamB_bot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
14:49:26 <_SamB_bot> Use "dict-help [cmd...]" for more.
14:49:34 <SamB> @devils contiguous
14:49:35 <_SamB_bot> No match for "contiguous".
14:49:42 <SamB> @easton contiguous
14:49:42 <_SamB_bot> No match for "contiguous".
14:49:44 <AstralStorm> ?onelook :P
14:49:44 <_SamB_bot> Unknown command, try @list
14:49:52 * SamB looks in the wrong dictionaries on purpose ;-)
14:50:03 <dylan> hehe, math professors are the best!
14:50:10 <AstralStorm> http://www.onelook.com/?w=contiguous&ls=a
14:50:10 <_SamB_bot> Title: a contiguous 25 - OneLook Dictionary Search
14:50:34 <Tela> I love my Math Prof. He's a crazy mathematician/physicist/french nationalist
14:51:12 <dylan> "I grew up on a farm on Louisiana. I would count the cows. Eventually, I counted an imaginary number of cows... That's how I knew I would be a math teacher"
14:51:22 <ihope> @all-dicts contiguous
14:51:23 <_SamB_bot> *** "Contiguous" gcide "The Collaborative International Dictionary of English v.0.48"
14:51:23 <_SamB_bot> Contiguous \Con*tig"u*ous\, a. [L. contiguus; akin to contigere
14:51:23 <_SamB_bot>   to touch on all sides. See {Contingent}.]
14:51:23 <_SamB_bot>   In actual contact; touching; also, adjacent; near;
14:51:23 <_SamB_bot>   neighboring; adjoining.
14:51:25 <_SamB_bot> [40 @more lines]
14:52:07 <ihope> Ooh! @more @more @more @more @more!
14:52:10 <AstralStorm> Huh.
14:52:27 <AstralStorm> Onelook.com has a better answer.
14:52:32 <AstralStorm> Link above.
14:52:35 <SamB> @foldoc contiguous
14:52:36 <_SamB_bot> No match for "contiguous".
14:52:52 <AstralStorm> adjective:   connecting without a break; within a common boundary
14:54:15 --- topic: '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]'
14:54:15 --- topic: set by ChanServ on [Wed Sep 06 22:32:40 2006]
14:54:16 <Deformative-II> Could haskell be used to make a new tool kit?
14:54:21 <ihope> @help let
14:54:21 <_SamB_bot> let <x> = <e>. Add a binding
14:54:26 <ihope> Hmm.
14:54:32 <SamB> @help vote
14:54:32 <_SamB_bot> vote <poll> <choice>        Vote for <choice> in <poll>
14:54:37 <AstralStorm> docs lets vote? Was that some kind of message? :P
14:54:37 <SamB> @help poll
14:54:38 <_SamB_bot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
14:54:42 <glguy> ?let example = concat
14:54:43 <SamB> @poll-list
14:54:49 <mauke> @let whatever = (return () :: (Monad m) => m ())
14:54:52 <_SamB_bot> Defined.
14:54:52 <_SamB_bot> []
14:54:55 <_SamB_bot> <local>:4:12:     Ambiguous type variable `m' in the constraint:       `Monad...
14:55:00 <glguy> > L.example [[1]]
14:55:03 <_SamB_bot>  Not in scope: `L.example'
14:55:11 <glguy> > example [[1]]
14:55:14 <_SamB_bot>  Not in scope: `example'
14:55:22 <glguy> hmm, the first version is how it is supposed to be used I thought
14:55:37 <ihope> @let v = 3 in v
14:55:38 <_SamB_bot>  Parse error
14:55:42 <ihope> @let v = 3
14:55:46 <SamB> glguy: I haven't the fogiest idea how it should work
14:55:46 <_SamB_bot> Defined.
14:55:47 <ihope> > v
14:55:49 <_SamB_bot>  Not in scope: `v'
14:55:55 <AstralStorm> > L.v
14:55:56 * ihope head scratches
14:55:57 <_SamB_bot>  Not in scope: `L.v'
14:56:08 <Tela> @let example = join
14:56:10 <_SamB_bot> <local>:5:0:     Multiple declarations of `L.example'     Declared at: <local...
14:56:20 <AstralStorm> What the...
14:56:21 <ihope> Whee.
14:56:30 <ihope> @run L.v
14:56:31 <AstralStorm> _SamB_bot: you're buggy!
14:56:32 <_SamB_bot>  Not in scope: `L.v'
14:56:45 <ihope> @help list
14:56:45 <_SamB_bot> list [module|command]
14:56:46 <_SamB_bot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:56:54 <AstralStorm> @info L.v
14:56:54 <_SamB_bot> L.v
14:57:02 <AstralStorm> @djinn L.v
14:57:02 <_SamB_bot> -- f cannot be realized.
14:57:06 <AstralStorm> @type L.v
14:57:34 * ihope gives _SamB_bot some boots of speed
14:57:40 <ihope> (Don't tell anyone, but they're cursed.)
14:57:43 <Tela> @botsnack
14:57:57 <AstralStorm> Now it's dead too.
14:58:03 * SamB gives _SamB_bot a spellbook of remove curse
14:58:10 <ihope> Let's kill mbot next!
14:58:13 * SamB also gives _SamB_bot more INT points
14:58:16 <AstralStorm> :>
14:58:18 <AstralStorm> Ah.
14:58:20 <Tela> _SamB_bot is dead! Long live _SamB_bot!
14:58:31 <AstralStorm> @type 3
14:58:31 <SamB> hmm
14:59:38 <AstralStorm> What is with those lambdabots that they crash so often? :P
14:59:54 <SamB> this one is waiting on a GHCi invocation...
15:00:01 <Tela> They should really be rewritten in a good language like C++ or something. Geeze.
15:00:09 <SamB> naesten@hydrogen:~% strace -p $(pidof a.out)
15:00:09 <SamB> Process 12708 attached - interrupt to quit
15:00:09 <SamB> waitpid(13654,
15:00:22 <SamB> naesten@hydrogen:~/hacking/haskell/ghc% ps 13654 | cat
15:00:22 <SamB>   PID TTY      STAT   TIME COMMAND
15:00:22 <SamB> 13654 pts/5    SN+    0:02 /usr/lib/ghc-6.4.1/ghc-6.4.1 -B/usr/lib/ghc-6.4.1 --interactive -fglasgow-exts -fno-th
15:00:33 <ihope> | cat?
15:00:33 * SamB kills it
15:00:44 <Deformative-II> Does anyone know of a project that is trying to make a gtk substitute other than etk, or qt?
15:00:45 <SamB> ihope: so it doesn't get cut off at the right margin...
15:00:56 * ihope almost nods
15:01:16 <russo> hi all
15:01:18 <russo> :)
15:01:22 <SamB> @bot
15:01:34 <_SamB_bot> :)
15:02:02 * SamB had to kill two processes...
15:02:33 <_SamB_bot> :)
15:02:47 <Tela> @botsnack
15:02:47 <_SamB_bot> :)
15:03:15 * shapr boings
15:03:22 <ihope> Boing?
15:04:21 <lynxorgd> http://www.cyber-wars.com/?ref=100628
15:04:22 <lynxorgd> http://www.cyber-wars.com/?ref=100628
15:04:22 <_SamB_bot> Title: New Cyber-Wars
15:04:22 <_SamB_bot> Title: New Cyber-Wars
15:04:24 <lynxorgd> http://www.cyber-wars.com/?ref=100628
15:04:25 <_SamB_bot> Title: New Cyber-Wars
15:04:26 <lynxorgd> http://www.cyber-wars.com/?ref=100628
15:04:27 <_SamB_bot> Title: New Cyber-Wars
15:04:28 <lynxorgd> http://www.cyber-wars.com/?ref=100628
15:04:29 <_SamB_bot> Title: New Cyber-Wars
15:04:52 <AstralStorm> Spammer!
15:04:55 <ihope> Can we get lynxorgd klined for that?
15:05:08 <ihope> That'd be cool :-)
15:07:09 <shapr> D00d!
15:07:16 <shapr> @Users
15:07:32 <_SamB_bot> seen module failed: IRCRaised thread killed
15:07:57 <AstralStorm> Huh?
15:07:58 <AstralStorm> @users
15:08:02 <_SamB_bot> Maximum users seen in #haskell: 237, currently: 230 (97.0%), active: 25 (10.9%)
15:08:26 <shapr> It doesn't like me.
15:08:32 <AstralStorm> @Users
15:08:33 <_SamB_bot> Maximum users seen in #haskell: 237, currently: 230 (97.0%), active: 25 (10.9%)
15:08:38 <AstralStorm> Seems to work ok.
15:08:44 <AstralStorm> @seen _SamB_bot
15:08:45 <_SamB_bot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
15:08:50 <shapr> That's what I get for hosting lambdabot for years....
15:08:51 <AstralStorm> Huh.
15:09:34 <AstralStorm> Some channels are really unexpected :P
15:09:43 <Syzygy-> Ummm. What's the difference between _SamB_bot and lambdabot ?
15:09:52 <SamB> Syzygy-: dons is asleep!
15:09:53 <AstralStorm> @kind _SamB_bot
15:10:02 <AstralStorm> :/
15:10:04 <AstralStorm> @version
15:10:11 <SamB> AstralStorm: stop doing that!
15:10:12 <AstralStorm> Died again?
15:10:18 <SamB>  @type and @kind are broken
15:10:32 <AstralStorm> Fun.
15:10:38 <shapr> @Seen shapr
15:10:45 <_SamB_bot> type module failed: IRCRaised thread killed
15:10:47 <_SamB_bot> lambdabot 4p218, GHC 6.4.1 (Linux i686 (Deschutes))
15:10:49 <Syzygy-> @seen shapr
15:10:49 <_SamB_bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:10:58 <_SamB_bot> You are in #ScannedInAvian and #haskell. I last heard you speak just now.
15:10:59 <_SamB_bot> shapr is in #ScannedInAvian and #haskell. I last heard shapr speak 4s ago.
15:11:04 <AstralStorm> shapr: _SamB_bot is SamB lambdabot
15:11:06 <Syzygy-> @seen Syzygy-
15:11:06 <_SamB_bot> You are in #haskell. I last heard you speak just now.
15:11:26 <shapr> AstralStorm, I know
15:11:41 <ihope> -->| lynxorgd (n=lyucnxt@ACCB9D15.ipt.aol.com) has joined #freenode-social
15:11:42 <AstralStorm> Other than that, it's there only because official lambdabot is dead
15:11:50 <ihope> This should be fun.
15:11:50 <AstralStorm> :>
15:12:03 <AstralStorm> Hehe, hehe, hehe :>
15:12:18 <shapr> AstralStorm, yes, I know
15:12:19 <ihope> Actually, this would be better: -->| lynxorgd (n=lyucnxt@ACCB9D15.ipt.aol.com) has joined #tapthru
15:12:54 <shapr> AstralStorm, I've been on #haskell before :-)
15:13:04 <AstralStorm> Huh.
15:13:15 <AstralStorm> Right.
15:13:20 <AstralStorm> So why would you ask?
15:13:47 <shapr> What did I ask?
15:13:53 <SamB> ah
15:14:28 <ihope> What if I just sort of pointed the spammer at #tapthru?
15:14:40 <SamB> might be something related to -threaded...
15:14:47 <AstralStorm> shapr: uh, Syzygy- was asking, not you :P
15:14:50 <AstralStorm> My mistake.
15:16:07 <shapr> AstralStorm, I was here first.
15:16:19 <araujo> now he is on #perl6
15:16:30 <AstralStorm> shapr: hehe.
15:16:57 <SamB> @hoogle GHC.Conc.ThreadId -> IO ()
15:17:01 <_SamB_bot> No matches, try a more general search
15:17:11 <SamB> @hoogle ThreadId
15:17:13 <_SamB_bot> Control.Concurrent.ThreadId :: data ThreadId
15:17:13 <_SamB_bot> GHC.Conc.ThreadId :: ThreadId# -> ThreadId
15:17:13 <_SamB_bot> Control.Concurrent.myThreadId :: IO ThreadId
15:17:32 <SamB> @hoogle Control.Concurrent.ThreadId -> IO ()
15:17:36 <_SamB_bot> No matches, try a more general search
15:17:43 <SamB> @hoogle ThreadId -> IO ()
15:17:46 <_SamB_bot> Control.Concurrent.killThread :: ThreadId -> IO ()
15:17:46 <_SamB_bot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
15:17:46 <_SamB_bot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
15:17:54 <SonicChao> Hoogle? o.o;
15:18:02 * SamB wants a way to wait on a thread...
15:18:14 <AstralStorm> Yes, a better search engine.
15:18:18 <ihope> SamB: mvars?
15:18:48 <AstralStorm> join yourthread?
15:19:20 <AstralStorm> @hoogle join
15:19:22 <_SamB_bot> Monad.join :: Monad a => a (a b) -> a b
15:19:23 <_SamB_bot> Control.Monad.join :: Monad m => m (m a) -> m a
15:19:23 <_SamB_bot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
15:19:28 <AstralStorm> Blah.
15:20:34 <SamB> @hoogle unsafeInterleaveIO
15:20:36 <_SamB_bot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
15:20:53 <SamB> nah...
15:24:57 <Tela> Ok. Newbie inquiry time! :)
15:25:37 <Tela> If I'm trying to use the IO monad to effectively create a rudimentary UI
15:26:27 <Tela> What's a good way to use it... I'll need to write strings, read strings, open files, close files. It feels almost like I should pretend it's another process and just used messages to send things back and forth
15:27:16 <AstralStorm> Huh? A message per line? You can wait for IO, you know.
15:27:23 <AstralStorm> @hoogle waitForIO
15:27:26 <SamB> Tela: go ahead and do that if it makes you feel better
15:27:26 <_SamB_bot> No matches found
15:27:30 <AstralStorm> Almost :P
15:27:39 <AstralStorm> What's the proper name?
15:27:56 <Tela> Well, in imperative languages, you just mix the two and don't worry about it. But I keep hearing to minimize the IO monad
15:28:24 <AstralStorm> You mean minimise reading anyway :>
15:28:42 <astrolabe> I like to have as much as possible in pure functions
15:28:54 <AstralStorm> Who doesn't...
15:29:28 <SamB> @list base
15:29:31 <_SamB_bot> base has no visible commands
15:29:42 <AstralStorm> @hoogle base
15:29:45 <_SamB_bot> Text.Html.base :: String -> HtmlAttr
15:29:45 <_SamB_bot> Test.HUnit.Base :: module
15:29:45 <_SamB_bot> Text.Html.basefont :: Html
15:29:47 <AstralStorm> :/
15:30:06 <SamB> @list dynamic
15:30:06 <_SamB_bot> No module "dynamic" loaded
15:30:34 <SamB> @dynamic-reload type
15:30:35 <_SamB_bot> Unknown command, try @list
15:30:54 <SamB> hmm
15:33:21 <vsingh> @pl \(a,b) -> a:b:[]
15:33:22 <_SamB_bot> uncurry ((. return) . (:))
15:41:27 <SamB> @quit
15:41:56 <AstralStorm> @version
15:42:02 <AstralStorm> @version
15:42:24 <_SamB_bot> lambdabot 4p218, GHC 6.4.1 (Linux i686 (Deschutes))
15:42:26 <_SamB_bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:42:36 <_SamB_bot> lambdabot 4p218, GHC 6.4.1 (Linux i686 (Deschutes))
15:42:38 <_SamB_bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:42:41 <SamB> @type 1
15:42:52 <_SamB_bot> forall t. (Num t) => t
15:43:03 <SamB> sweet
15:43:03 <AstralStorm> @type _SamB_bot
15:43:08 <_SamB_bot> Not in scope: `_SamB_bot'
15:43:11 <AstralStorm> @kind _SamB_bot
15:43:14 <xerox> SamB++
15:43:14 <_SamB_bot> Not in scope: type variable `_SamB_bot'
15:43:23 <AstralStorm> Now works correctly.
15:43:25 <AstralStorm> @kind 1
15:43:36 <_SamB_bot> *
15:43:53 <SamB> I still want a fully-dynamic lambdabot...
15:44:10 <stepcut> xb
15:44:15 <AstralStorm> :
15:44:27 <SamB> without massive hacks to the cabal file
15:44:29 <stepcut> ack, missed the C- part
15:44:31 <AstralStorm> @type :
15:44:37 <_SamB_bot> parse error on input `:'
15:44:44 <AstralStorm> @type 
15:44:44 <SamB> heh
15:44:48 <_SamB_bot> lexical error
15:44:54 <SamB> @type (:)
15:45:03 <_SamB_bot> lexical error
15:45:07 <AstralStorm> @type ""
15:45:12 <_SamB_bot> [Char]
15:45:16 <xerox> stepcut: hahaha
15:45:25 <stepcut> xerox: :p
15:45:31 <vsingh> @pl \f l -> l ++ map f l
15:45:32 <_SamB_bot> ap (++) . map
15:45:35 <xerox> stepcut: Circe > ERC! :D
15:46:18 <RyanT5000> @type ap
15:46:21 <AstralStorm> @pl concat (intersperse " " (concat (map f x)))
15:46:21 <_SamB_bot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:46:21 <_SamB_bot> join (intersperse " " (f =<< x))
15:46:38 <stepcut> xerox: oh ?
15:46:41 <AstralStorm> Niceness :>
15:46:50 * SamB sends patch to dons
15:47:14 <xerox> stepcut: well, ERC is nice, but Circe is more lightweight... you might like it, if you find ERC "too crufty"
15:47:56 <AstralStorm> @pl unwords
15:47:57 <_SamB_bot> unwords
15:47:57 <stepcut> xerox: i'll check it out sometime -- looks like it has on-the-fly spell checking?
15:48:02 <AstralStorm> @help pl
15:48:02 <_SamB_bot> pointless <expr>. Play with pointfree code.
15:48:04 <xerox> stepcut: yep!
15:48:11 <vsingh> Is there a way to force the bot to avoid Monad stuff with @pl?
15:48:26 <SamB> vsingh: no!
15:48:30 <xerox> stepcut: it also has a more sane codebase, it's pretty new, clean, and meant to be maintainable :)
15:48:31 <SamB> vsingh: feel free to add one!
15:48:36 <stepcut> xerox: cool
15:48:39 <SamB> @version
15:48:39 <_SamB_bot> lambdabot 4p218, GHC 6.4.1 (Linux i686 (Deschutes))
15:48:39 <_SamB_bot> darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
15:49:18 <vsingh> SamB: cool, i'll try working on that when i have more experience. just started haskell yesterday :)
15:49:45 <SamB> vsingh: take your time, and don't take @pl too seriously ;-)
15:49:53 <SamB> it is called "pointless" after all
15:50:25 <AstralStorm> vsingh: cheers :>
15:50:28 <vsingh> indeed :) I went on a frenzy of converting things to pointless for a while, but I hope i'm over it now :)
15:50:39 <AstralStorm> The best language all around (probably :P )
15:51:49 <SamB> pointless code is all well and good
15:51:57 <SamB> but @pl overdoes it
15:52:56 <SamB> and note that I am not the author of that bot, it is just called that so people know who to blame for its killing sprees
15:53:21 <SamB> (as that instance is running on my machine)
15:58:36 <vsingh> i'll have to look into the bot codebase, it looks educational
15:58:40 <vsingh> @pl (\self x -> self (x - 1)) (\self x -> self (x - 1))
15:58:41 <_SamB_bot> (. subtract 1) . subtract 1
15:58:58 <SamB> vsingh: just don't look too closely at the cabal file...
15:59:11 <SamB> and I hope you have a lot of RAM
15:59:15 <SamB> to link it with
16:00:01 <xerox> Do it! lambdabot is a great learning experience.
16:00:49 <SamB> I had to cancel linking and build Boot.hs by hand and run that...
16:03:42 <vsingh> @pl (\self x -> self self (x - 1)) (\self x -> self self (x - 1))
16:03:46 <_SamB_bot> flip ((.) . ap id id) (subtract 1) (flip ((.) . ap id id) (subtract 1))
16:03:46 <_SamB_bot> optimization suspended, use @pl-resume to continue.
16:05:31 <vsingh> @pl (\self -> self self) (\self -> self self)
16:05:34 <_SamB_bot> ap id id (ap id id)
16:05:34 <_SamB_bot> optimization suspended, use @pl-resume to continue.
16:06:03 <vsingh> @pl-resume
16:06:10 <_SamB_bot> ap id id (ap id id)
16:06:10 <_SamB_bot> optimization suspended, use @pl-resume to continue.
16:06:21 <dibblego> ?index readFile
16:06:21 <_SamB_bot> System.IO, Prelude
16:07:19 <dibblego> why are there 2?
16:07:26 <dibblego> they appear to be the same thing
16:08:55 <vsingh> @pl join id (join id)
16:08:55 <_SamB_bot> join id (join id)
16:09:16 <vsingh> well, that was dumb of me.
16:09:30 * kowey whimpers
16:09:57 <vsingh> @pl join id (\f -> f f)
16:09:58 <_SamB_bot> join id (join id)
16:10:14 <vsingh> @pl (\f -> f f) (\f -> f f)
16:10:17 <_SamB_bot> ap id id (ap id id)
16:10:17 <_SamB_bot> optimization suspended, use @pl-resume to continue.
16:12:55 <dibblego> anyone know where there are 2 apparently equivalent readFile functions (System.IO, Prelude)?
16:13:55 <vsingh> Hoogle only gives the Prelude one: http://www.haskell.org/hoogle/?q=readFile
16:13:55 <_SamB_bot> Title: readFile - Hoogle
16:15:34 <dibblego> ?index readLine
16:15:34 <_SamB_bot> bzzt
16:15:43 <dibblego> ?index getLine
16:15:43 <_SamB_bot> System.IO, Prelude
16:20:35 <shapr> SHAZAM!
16:20:52 * shapr hops without moving
16:20:58 <xerox> Quantum hopping?
16:21:36 <shapr> Yes!
16:22:50 <dibblego> s <- readFile "file" makes s of type String right?
16:23:04 <xerox> Yep.
16:23:18 <dibblego> s = readFile "file" makes s of type IO String?
16:23:25 <xerox> Yep.
16:23:29 <dibblego> ok ta
16:23:32 <xerox> Yep.
16:23:37 <dibblego> yep
16:23:40 * xerox got stuck in a Yep. loop
16:23:58 <xerox> > fix ("Yep. "++)
16:24:08 <_SamB_bot>  "Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. Yep. ...
16:24:36 * shapr boings very quietly
16:25:41 <nothingmuch> shapr: !
16:26:03 <shapr> Hiya!
16:26:06 <nothingmuch> shapr: ?
16:26:13 <shapr> I'm in portland!
16:26:17 <nothingmuch> shapr: !
16:26:29 <shapr> haskell workshop!
16:26:34 <nothingmuch> ooh shiny
16:26:37 <nothingmuch> how was the move?
16:26:43 <shapr> Vry shiny
16:26:58 <shapr> Move was ok
16:27:56 <shapr> ?Users
16:28:00 <_SamB_bot> Maximum users seen in #haskell: 237, currently: 224 (94.5%), active: 13 (5.8%)
16:28:19 <nothingmuch> zzzz
16:28:34 <nothingmuch> i'll catch you for more interrogation later ;-)
16:31:53 <shapr> Hello Haskell Workshop!
16:33:38 <edwardk> Neat, we can talk to the crowd.
16:37:27 <dibblego> is there a function that will turn "a,b,c" into ["a","b","c"] ?
16:37:37 <dibblego> ?index split
16:37:37 <_SamB_bot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
16:37:48 <edwardk> > split ',' "a,b,c"
16:37:51 <_SamB_bot>  Couldn't match `(g, g)' against `t -> t1'
16:37:52 <edwardk> @type split
16:37:57 <_SamB_bot> forall g. (RandomGen g) => g -> (g, g)
16:38:01 <edwardk> woops
16:38:05 <arjanb> @type splitAt
16:38:07 <dibblego> I was just guessing
16:38:09 <_SamB_bot> forall a. Int -> [a] -> ([a], [a])
16:39:00 <dibblego> > splitAt 1 "a,b,c"
16:39:04 <_SamB_bot>  ("a",",b,c")
16:39:49 <dibblego> can it be done with splitAt?
16:39:50 <lispy> kowey: nice talk
16:40:00 <kowey> lispy: :-) thanks
16:40:18 <lispy> kowey: can we have a lambdabot plugin now for generating sentences? ;)
16:40:41 <kowey> well, they would be non-inflected sentences
16:40:57 <kowey> eh, John talk to Mary, instead of John talks to Mary
16:41:46 <emu> you could take a look at the definition of words in  the Report, and adapt that, it's only a few lines
16:41:56 <emu> it uses span and takeWhile I believe
16:42:37 <arjanb> @hoogle (a -> Bool) -> [a] -> [[a]]
16:42:41 <_SamB_bot> No matches, try a more general search
16:42:45 <edwardk> i did one with unfoldr and splitAt i'm just trying to find it
16:42:51 <glguy> ?type span
16:42:53 <edwardk> this cameup before
16:42:55 <_SamB_bot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:42:57 <edwardk> @type unfoldr
16:43:01 <_SamB_bot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:43:02 <edwardk> @type splitAt
16:43:06 <_SamB_bot> forall a. Int -> [a] -> ([a], [a])
16:43:25 <arjanb> odd that there's no standard function for this
16:43:28 <shapr> kowey, nice talk!
16:43:48 <edwardk> yeah, definitely
16:44:06 <kowey> thanks, shapr and edwardk! now I can spend the rest of week not being nervous
16:45:21 <dibblego> t :: String -> Maybe (Bool, Int, Int) -- is that wrong?
16:45:46 <edwardk> er break
16:46:00 <dibblego> given "True,3,4" I want to return (True,3,4) but given "something else", I want to return nothing
16:46:26 <edwardk> > read "(True,3,4)"
16:46:29 <_SamB_bot>  Add a type signature
16:46:33 <edwardk> hrmm
16:46:47 <emu> > read "(True,3,4)" :: (Bool,Int,Int)
16:46:50 <_SamB_bot>  (True,3,4)
16:46:54 <edwardk> yeah
16:47:01 <emu> > read "(True,3)" :: (Bool,Int,Int)
16:47:01 <dibblego> > read "True,3,4" :: (Bool,Int,Int)
16:47:05 <_SamB_bot>  Exception: Prelude.read: no parse
16:47:05 <battery> #energy forum
16:47:08 <_SamB_bot>  Exception: Prelude.read: no parse
16:47:21 <dibblego> so I will have to prepend and append parantheses?
16:47:36 <glguy> > span (<3) [1..5]
16:47:40 <_SamB_bot>  ([1,2],[3,4,5])
16:47:47 <dibblego> *parentheses
16:47:51 <emu> > read "True,3,4"::Bool
16:47:55 <_SamB_bot>  Exception: Prelude.read: no parse
16:47:58 <shapr> Weird spam
16:48:05 <emu> ?type readS
16:48:08 <_SamB_bot> Not in scope: `readS'
16:48:22 <glguy> > break (<3) [1..5]
16:48:26 <_SamB_bot>  ([],[1,2,3,4,5])
16:48:34 <arjanb> what were the most interesting things at HW?
16:48:59 <glguy> ah, break is (span .) . not
16:49:37 <dibblego> @pl print $ (read "(True,3,4)" :: (Bool, Int, Int)))
16:49:37 <_SamB_bot> (line 1, column 48):
16:49:37 <_SamB_bot> unexpected ")"
16:49:37 <_SamB_bot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
16:49:44 <AstralStorm> Hey people.
16:49:47 <dibblego> @pl print $ (read "(True,3,4)" :: (Bool, Int, Int))
16:49:47 <_SamB_bot> print (read "(True,3,4)" :: (Bool, Int, Int))
16:49:57 <AstralStorm> I need some 1-Space indented file for testing.
16:50:07 <AstralStorm> Real one.
16:50:46 <AstralStorm> 2 or 3 would be better.
16:52:04 <AstralStorm> Also something GNU-style indented, I mean with something like:
16:52:18 <AstralStorm> \tif (bleh)
16:52:22 <AstralStorm> \t  {
16:52:29 <AstralStorm> \t    something
16:52:30 <xerox> dibblego: print . (read :: String -> (Bool, Int, Int).
16:52:34 <AstralStorm> \t  };
16:52:39 <AstralStorm> This stupid style.
16:53:17 <AstralStorm> Or maybe that was \t\t before something...
16:54:20 <mux> ?index hsx
16:54:20 <_SamB_bot> bzzt
16:54:28 <mux> ?where hsx
16:54:28 <_SamB_bot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
16:54:49 <shapr> ?Where hpc
16:54:49 <_SamB_bot> http://www.galois.com/~andy/hpc-intro.html
16:55:14 <dibblego> why doesn't this compile? http://rafb.net/paste/results/9CXhki17.html
16:55:25 <AstralStorm> I'd love some large samples of these, especially less common styles:
16:55:26 <AstralStorm> http://en.wikipedia.org/wiki/Indent_style
16:55:44 <dibblego> oh never mind
16:57:35 <AstralStorm> Real code - indented with tabs, spaces or a combination thereof.
16:57:59 <AstralStorm> Maybe even some messy indentation too :>
16:58:02 <dibblego> it is easier for the naive mind to learn application of a FP language than a mind with deeply in-grained understandings of imperative stytles
16:58:22 <AstralStorm> dibblego: return to math to really grasp FP
16:58:34 <dibblego> AstralStorm, I agree
16:58:54 <shapr> dibblego, amnesia helps too
16:59:03 <monochrom> I have a naive mind.
16:59:05 <dibblego> shapr, my point exactly
16:59:05 <AstralStorm> shapr, hahaha.
16:59:29 <AstralStorm> dibblego: so go like this - take a large hammer...
17:02:16 <AstralStorm> Apply repeatedly to your cranium.
17:02:23 <AstralStorm> Should be enough :P
17:03:11 <dibblego> I agree, I have spent more time unlearning than learning
17:05:23 <dibblego> I got hit by a squassh racket on Saturday - I have a large bruise under my eye
17:05:38 <dibblego> I didn't see any for loops fly out of my ear or anything though
17:05:52 <xerox> G'night.
17:05:58 <dibblego> seeya, thanks for the tips
17:06:32 <AstralStorm> dibblego: http://en.wikipedia.org/wiki/Hrair_limit
17:06:38 <AstralStorm> So practice...
17:07:26 <dibblego> I have been finding it difficult to set short term goals to contribute to learning this stuff - uni assignments from google aren't really any good - they require some knowledge of the class
17:17:37 <dibblego> http://rafb.net/paste/results/LrBD9P52.html that won't parse because it needs parentheses before and after - what's the correct way to do it?
17:18:53 <glguy> You should not need to specify the type of the read function since you specify the type of f
17:19:13 <dibblego> f (x:xs) = read x : f xs
17:19:36 <glguy> are you intentionally recreating map?
17:19:45 <dibblego> probably
17:20:06 <glguy> f :: [String] -> [(Bool, Int, Int)]
17:20:09 <glguy> f = map read
17:21:20 <glguy> ?ver
17:21:20 <_SamB_bot> Maybe you meant: vera version
17:21:41 <glguy> > (map read ["(True, 1)"]) :: [(Bool, Int)]
17:21:46 <_SamB_bot>  [(True,1)]
17:23:40 <sek> > (map read [("(True, 1)"])
17:23:40 <_SamB_bot>  Parse error
17:23:56 <sek> > (map read ["(True, 1)"]
17:23:57 <_SamB_bot>  Parse error
17:24:00 <glguy> sek: ( after [
17:24:01 <sek> > (map read ["(True, 1)"])
17:24:07 <_SamB_bot>  Add a type signature
17:24:20 <sek> hmm, i was just wondering what that would return
17:24:51 <sek> interesting example, thanks
17:25:03 <sek> heh, interesting for the clueless such as myself
17:26:51 <dibblego> given a file, "True,1,2\n,False,3,7\n" etc. I want to return a Num a => [a] where each element represents a line unless that line starts with False, but if it starts with True, return the third split value minus the second split value, so in this case: [1,4]
17:27:36 <glguy> dibblego: when first is true return second, otherwise return the difference of the third and second?
17:27:47 <dibblego> no
17:27:52 <dibblego> when the first is True, return the third minus the second
17:27:58 <dibblego> otherwise, ignore
17:28:01 <glguy> oh
17:28:07 <AstralStorm> Simple :>
17:28:13 <glguy> you'll use a filter
17:28:19 <dibblego> so [1,4] is [3-1,7-2]
17:28:22 <dibblego> er, [1,5]
17:28:35 <dibblego> ok
17:28:48 <AstralStorm> e.g. [(False, 1, 2), (True, 3, 2), ...]
17:28:49 <dibblego> ?type filter
17:28:55 <AstralStorm> Get that output :>
17:28:59 <_SamB_bot> forall a. (a -> Bool) -> [a] -> [a]
17:29:15 <dibblego> AstralStorm, I was trying to do that with map read, but it requires parentheses surround each line
17:29:39 <AstralStorm> Parse the strings first.
17:29:43 <AstralStorm> Split on ,
17:29:46 <glguy> > [c - b | (a,b,c) <- ((map read $ lines "True,1,2\n,False,3,7) :: [(Bool, Int, Int)]), a]
17:29:47 <_SamB_bot>  Improperly terminated string
17:29:55 <AstralStorm> To get an array :>
17:29:57 <glguy> > [c - b | (a,b,c) <- ((map read $ lines "True,1,2\n,False,3,7") :: [(Bool, Int, Int)]), a]
17:30:05 <_SamB_bot>  Exception: Prelude.read: no parse
17:30:14 <AstralStorm> Haha, no parens :P
17:30:19 <glguy> > [c - b | (a,b,c) <- ((map read $ lines "True,1,2\nFalse,3,7") :: [(Bool, Int, Int)]), a]
17:30:23 <_SamB_bot>  Exception: Prelude.read: no parse
17:30:29 <AstralStorm> You have to parse that into some table first, then map with read.
17:30:43 <AstralStorm> E.g. ["True", "1", "2"]
17:30:49 <AstralStorm> Something like that.
17:30:53 <dibblego> AstralStorm> Split on , <-- with splitAt?
17:31:05 <AstralStorm> ?type splitAt
17:31:12 <_SamB_bot> forall a. Int -> [a] -> ([a], [a])
17:31:20 <AstralStorm> As you can see, no.
17:31:20 <dibblego> yes I was thinking of somehow getting it to [["True", "1", "2"],["False","3","7"]]
17:31:20 <AstralStorm> :>
17:31:25 <glguy> > [c - b | (a,b,c) <- ((map read $ lines ["(True,1,2)\n(False,3,7)"] :: [(Bool, Int, Int)]), a]
17:31:25 <_SamB_bot>  Parse error
17:31:36 <glguy> > lines "a\nb"
17:31:40 <_SamB_bot>  ["a","b"]
17:32:02 <dibblego> lines and words do the same thing except for the delimiter
17:32:03 <AstralStorm> dibblego: as you can see, you want something other :>
17:32:16 <AstralStorm> dibblego: I think these use span
17:32:18 <glguy> > [c - b | (a,b,c) <- ((map read $ lines "(True,1,2)\n(False,3,7)" :: [(Bool, Int, Int)]), a]
17:32:19 <_SamB_bot>  Parse error
17:32:30 <dons> _SamB_bot: @quit
17:32:31 <AstralStorm> glguy: bot hates yuo :P
17:32:32 <dibblego> ?type span
17:32:34 <glguy> > [c - b | (a,b,c) <- (map read $ lines "(True,1,2)\n(False,3,7)" :: [(Bool, Int, Int)]), a]
17:32:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:33:03 <lambdabot>  [1]
17:33:28 <glguy> heh, it ran :)
17:33:45 <AstralStorm> glguy: but requires a major transformation of input.
17:33:54 <SamB> naesten@hydrogen:~/hacking/haskell/lambdabot/work% cat State/tell
17:33:54 <SamB> ("dons",(Nothing,[Note {noteSender = "SamB", noteContents = "that it takes WAAAY to long to link lambdabot statically, and that he must figure out how to make it easy to build dynamically", noteTime = (1158527393,376020000000), noteType = Tell}]))
17:34:00 <glguy> AstralStorm: hardly, all you'd have to do is lines, and then add a ( and ) to each with map
17:34:06 <SamB> dons: read your messages *before* killing the bot!
17:35:06 <AstralStorm> glguy: bwah, hacky :>
17:35:09 <dibblego> > span (\x -> x == 7) [1,2,3,4,5,6,7,8]
17:35:10 <lambdabot>  ([],[1,2,3,4,5,6,7,8])
17:35:19 <SamB> dons: also, did you figure out what lambdabot was stuck on?
17:35:33 <dons> no, can't find anything in the logs. I suspect network issues
17:35:35 <dibblego> what did that do?
17:35:36 <AstralStorm> dibblego: you want splitAt and find :>
17:35:36 <glguy> AstralStorm: it's hacky to assume that the input uses the same read values for True and False that haskell does
17:35:42 <dons> it wasn't any weird command or anything like that
17:35:43 <glguy> if you can't do what I'm saying
17:35:43 <dibblego> AstralStorm, and span?
17:35:45 <SamB> dons: did you strace it?
17:35:55 <SamB> next time, do!
17:35:55 <dons> nope
17:35:56 <AstralStorm> dibblego: span is something else :>
17:36:10 <glguy> break p is span (not . p)
17:36:13 <dons> SamB: no, reg. messages. you just wanted to complain about linking time?
17:36:17 <dons> s/now/
17:36:17 <dibblego> AstralStorm, why doesn't glguy's expression use either of those?
17:36:32 <AstralStorm> Because he dodges the issue with a list comprehension :>
17:36:34 <SamB> it hung on me and when I straced it I found it was having trouble with waitpid()
17:36:36 <dibblego> > break (\x -> x == 7) [1,2,3,4,5,6,7,8]
17:36:37 <lambdabot>  ([1,2,3,4,5,6],[7,8])
17:36:41 <AstralStorm> And uses read more properly.
17:36:45 <dons> SamB: ah right. I see your patch
17:36:48 <dons> very interesting
17:37:02 <AstralStorm> > break (\x -> x == ',') "abc,def,ghi"
17:37:03 <lambdabot>  ("abc",",def,ghi")
17:37:05 <SamB> it should be fairly foolproof no matter what goes on with threading...
17:37:09 <dibblego> > break (\x -> x == ',') "x,y,x"
17:37:10 <lambdabot>  ("x",",y,x")
17:37:10 <dons> yeah, i like it.
17:37:16 <AstralStorm> Unfortunately it keeps the pivot :P
17:37:27 <dons> SamB: any other issues raised?
17:37:36 <AstralStorm> > span (\x -> x /= ',') "abc,def,ghi"
17:37:37 <lambdabot>  ("abc",",def,ghi")
17:38:04 <dibblego> > break (\x -> x == ',') "abc,def,ghi"
17:38:05 <lambdabot>  ("abc",",def,ghi")
17:38:07 <SamB> dunno if that had anything to do with your hang or not
17:38:20 <AstralStorm> Maybe:
17:38:21 <dibblego> > break (\x -> x == ',') (break "abc,def,ghi")
17:38:22 <lambdabot>    Expecting a function type, but found `[a]'
17:38:22 <lambdabot>    Expected type: [Char]
17:38:22 <lambdabot>  ...
17:38:28 <AstralStorm> > partition (\x -> x == ',') "abc,def,ghi"
17:38:29 <lambdabot>  (",,","abcdefghi")
17:38:33 <SamB> dons: I haven't seen any
17:38:33 <dibblego> > break (\x -> x == ',') snd "abc,def,ghi"
17:38:33 <lambdabot>    The function `break' is applied to three arguments,
17:38:34 <lambdabot>   but its type `(a...
17:38:40 <AstralStorm> Huh, noes :P
17:38:52 <dibblego> > break (\x -> x == ',') . snd "abc,def,ghi"
17:38:53 <lambdabot>  Couldn't match `(a1, a -> [Char])' against `[Char]'
17:38:55 <AstralStorm> dibblego: snd goes before :P
17:39:11 <AstralStorm> > snd $ break (\x -> x == ',') "abc,def,ghi"
17:39:13 <lambdabot>  ",def,ghi"
17:39:20 <dibblego> ah yeah
17:39:39 <SamB> people were trying to DoS @run, but runplugs did its job well
17:40:02 <SamB> oh, well, @let doesn't seem to work right, actually...
17:40:03 <dibblego> > break (\x -> x == ',') . snd break "abc,def,ghi"
17:40:03 <lambdabot>    Expecting a function type, but found `(a, b)'
17:40:03 <lambdabot>    Expected type: (a1, ...
17:40:09 <AstralStorm> What about this?
17:40:11 <SamB> dons: ^
17:40:29 <dons> oh, can you clarify?
17:40:33 <AstralStorm> > elemIndices ',' "abc,cde,def"
17:40:35 <lambdabot>  [3,7]
17:40:35 <dons> the DoS was in the logs?
17:40:41 <AstralStorm> And break using that :>
17:40:43 <dons> but failed?
17:40:59 <SamB> dons: peole were just trying to kill my computer or something ;-)
17:41:02 <SamB> er, people
17:41:09 <dibblego> AstralStorm, that seems to be what splitAt is for
17:41:09 <SamB> just ordinary in-channel usage
17:41:14 <dons> ah ok
17:41:36 <SamB> I wouldn't have known they were trying anything if they didn't say so
17:41:55 <dons> well, you can always read State/log ...
17:42:01 <AstralStorm> > map splitAt elemIndices ',' "abc,cde,def"
17:42:02 <lambdabot>    The function `map' is applied to four arguments,
17:42:03 <lambdabot>   but its type `(a ->...
17:42:11 <dibblego> > break [] = [];break a = (\x -> x == ',') . snd break a in break "abc,def,ghi"
17:42:11 <lambdabot>  Parse error
17:42:15 <AstralStorm> > map splitAt (elemIndices ',' "abc,cde,def") "abc,cde,def"
17:42:16 <lambdabot>    The function `map' is applied to three arguments,
17:42:16 <lambdabot>   but its type `(a -...
17:42:29 <AstralStorm> > map (splitAt (elemIndices ',' "abc,cde,def")) "abc,cde,def"
17:42:30 <lambdabot>  Couldn't match `Int' against `[Int]'
17:42:31 <SamB> 21:17:00 <AstralStorm !n=astralst@host-81-190-180-220.gorzow.mm.pl ##haskell> Le
17:42:31 <SamB> t's DoS SamB through his bot :P
17:42:31 <SamB> 21:17:09 <dmwit !n=wagnerd@cpe-24-24-70-7.stny.res.rr.com ##haskell> =D
17:42:31 <SamB> 21:17:11 <shapr !n=shae@65.121.84.51 ##haskell> AstralStorm, huh?
17:42:31 <SamB> 21:17:11 <SamB !i=naesten@216-15-104-38.c3-0.upd-ubr7.trpr-upd.pa.cable.rcn.com
17:42:31 <SamB> ##haskell> heh
17:42:31 <dons> SamB: can you check that things _were_ in fact logged to State/log as well as State/Log/*
17:42:58 <dons> hmm?
17:43:23 <SamB> what is with the ^As
17:43:23 <AstralStorm> > map (map splitAt (elemIndices ',' "abc,cde,def")) "abc,cde,def"
17:43:24 <lambdabot>    Expecting a function type, but found `[b]'
17:43:24 <lambdabot>    Expected type: a -> b
17:43:24 <lambdabot>  ...
17:43:30 <SamB> dons: that was just a sample from State/log
17:43:34 <AstralStorm> Blah.
17:43:43 <dibblego> > break [] = [];break a = (\x -> x == ',') . snd break a in break "abc,def,ghi" -- is this almost right?
17:43:43 <lambdabot>  Parse error
17:44:04 <dibblego> > f [] = [];f a = (\x -> x == ',') . snd break a in f "abc,def,ghi" -- is this almost right?
17:44:05 <lambdabot>  Parse error
17:44:06 <SamB> where AstralStorm stated his intention to attempt to DoS me ;-)
17:44:18 <dibblego> > f [] = [];f a = (\x -> x == ',') . snd (break a) in f "abc,def,ghi"
17:44:18 <lambdabot>  Parse error
17:44:19 <dons> SamB: ok. does that tell you what you need to know though? or are the commands missing?
17:44:43 <sjanssen> > let f [] = [];f a = (\x -> x == ',') . snd (break a) in f "abc,def,ghi"
17:44:44 <lambdabot>    Expecting a function type, but found `(a, b)'
17:44:44 <lambdabot>    Expected type: (a1, ...
17:45:11 <SamB> dons: the commands seem to be there
17:45:20 <dons> @bot
17:45:20 <lambdabot> :)
17:45:22 <dons> yes
17:45:30 <shapr> dons, too bad you're not at HW
17:45:31 <dons> so you can find out about the DoS if you want.
17:45:37 <dons> shapr: yes!
17:45:56 <dons> shapr: you there, having fun?
17:46:17 <SamB> oh, btw, if I just type ^C while lambdabot is linking and use a hand-built Boot.hs executable, it works fine
17:46:31 <SamB> except the part where the dynamic module is missing
17:46:44 <dons> yeah sure. its just that i haven't worked out how to get cabal to build a dyamic bot yet
17:46:49 <SamB> and the part where everything is loaded as if statically
17:46:58 <dibblego> let f [] = [];f a = (\x -> x == ',') . snd (break a) in f "abc,def,ghi" -- what is wrong with it?
17:47:44 <SamB> you could probably figure out how to get Cabal to build the modules and Boot.hs, so as to avoid GNU LD's massive waste of resources...
17:48:04 <dons> SamB: ok. since you make the case so eloquently
17:48:09 <SamB> hehe
17:48:09 <dibblego> > f [] = [];f a = (\x -> x == ',') . snd (break f a) in f "abc,def,ghi"
17:48:09 <lambdabot>  Parse error
17:48:37 <SamB> it was thrashing so bad, I could hardly talk on the channel!
17:48:47 <dibblego> > f [] = [];f a = (\x -> x == ',') . snd (break (\x -> x == ',') a) in f "abc,def,ghi"
17:48:48 <lambdabot>  Parse error
17:48:57 <mauke> missing let
17:49:02 <dibblego> > let f [] = [];f a = (\x -> x == ',') . snd (break (\x -> x == ',') a) in f "abc,def,ghi"
17:49:03 <lambdabot>  Couldn't match `a -> Char' against `[a1]'
17:49:03 <SamB> 'course, you could blame that on firefox having leaked so much of my RAM already...
17:49:26 <sjanssen> dibblego: let, and you probably want $ instead of . there
17:49:38 <mauke> dibblego: incompatible return types for f
17:49:39 <dibblego> I always get $ and . confused
17:49:44 <dibblego> > let f [] = [];f a = (\x -> x == ',') $ snd (break (\x -> x == ',') a) in f "abc,def,ghi"
17:49:45 <lambdabot>  Couldn't match `Char' against `[a]'
17:50:14 <mauke> can't compare string against ','
17:50:24 <dibblego> snd (break (\x -> x == ',') "abc,def,ghi")
17:50:26 <dibblego> > snd (break (\x -> x == ',') "abc,def,ghi")
17:50:28 <lambdabot>  ",def,ghi"
17:51:17 <sjanssen> > let f [] = [];f a = (\(x:xs) -> if x == ',' then xs else x:xs) $ snd (break (\x -> x == ',') a) in f "abc,def,ghi"
17:51:19 <lambdabot>  "def,ghi"
17:51:56 <mauke> (\x -> x == ',') better written as (== ',')
17:52:37 <mauke> > break (',' ==) "foo"
17:52:38 <lambdabot>  ("foo","")
17:52:42 <dibblego> I just want f "abc,def,ghi" to be ["abc","def","ghi"]
17:52:51 <mauke> @hoogle split
17:52:52 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
17:52:52 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
17:52:52 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
17:52:52 <SamB> @help let
17:52:52 <lambdabot> let <x> = <e>. Add a binding
17:52:59 <SamB> @let x = ()
17:53:01 <lambdabot> Defined.
17:53:05 <SamB> > L.x
17:53:06 <lambdabot>  ()
17:53:20 <SamB> okay, so @let works on this lambdabot but not on mine?
17:54:13 <mauke> I don't remember how to split a string
17:54:20 <dibblego> I'ma figure it out
17:55:09 <SamB> oh, but...
17:55:12 <SamB> @let x = ()
17:55:13 <lambdabot> <local>:3:0:     Multiple declarations of `L.x'     Declared at: <local>:2:0 ...
17:55:19 <SamB> dons: see that?
17:56:05 <sjanssen> SamB: lambdabot doesn't let you have multiple defns of the same variable, what's surprising about that?
17:56:27 <SamB> sjanssen: well. I'd think it could be more friendly about it.
17:56:40 <SamB> also if it is trying to resemble the monadic-style let in GHCi...
17:56:44 <SamB> it is doing a bad job!
17:56:45 <dibblego> let f [] = [];f a = fst (break (== ',') a) : f (snd (break (== ',') a)) -- why does that go forever?
17:57:21 <dibblego> oh I kind of see why
17:57:33 <sjanssen> > head (do let {x = 4}; let {x = 5}; return x)
17:57:34 <lambdabot>  5
17:57:41 <dibblego> > break (== ',') ""
17:57:42 <lambdabot>  ("","")
17:58:23 <sjanssen> hmm, didn't know you can do that.  makes sense though
18:08:13 <dons> shapr: around?
18:08:35 <dons> I wonder if I can get someone at the HW to send a report on how it went...
18:08:43 <dons> for today's HWN..
18:10:46 <AstralStorm> @type drop begin $ take (begin+end) x
18:10:47 <lambdabot> Not in scope: `begin'
18:10:47 <lambdabot>  
18:10:47 <lambdabot> <interactive>:1:19: Not in scope: `begin'
18:11:26 <AstralStorm> @type getRange a b x -> drop a $ take (a+b) x
18:11:28 <lambdabot> Parse error in pattern
18:11:30 <dons> sjanssen (and otherS) http://www.linux.com/article.pl?sid=06/09/16/1232250
18:11:35 <AstralStorm> Blah :P
18:11:39 <lambdabot> Title: Linux.com | Growing pains for Google's Summer of Code, http://tinyurl.com/prare
18:11:39 <AstralStorm> @type getRange a b x = drop a $ take (a+b) x
18:11:40 <lambdabot> parse error on input `='
18:12:05 <dons> ?type let getRange a b x = drop a $ take (a+b) x in getRange
18:12:07 <lambdabot> forall a. Int -> Int -> [a] -> [a]
18:12:17 <dons> ?pl getRange a b x = drop a $ take (a+b) x
18:12:18 <lambdabot> getRange = ap ((.) . (.) . drop) ((take .) . (+))
18:12:21 <dons> ;)
18:12:59 <AstralStorm> dons: right :>
18:14:38 <AstralStorm> Now, how to generate from [3, 7, 9] something like [(0,3), (4,7), (8,9)]
18:15:28 <dons> > [0,4,..]
18:15:28 <lambdabot>  Parse error
18:15:32 <dons> > [0,4..]
18:15:33 <lambdabot>  [0,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100...
18:15:36 <AstralStorm> No no.
18:15:43 <dons> > zip [3, 7, 9] [0,4..]
18:15:43 <dibblego> !paste
18:15:44 <lambdabot>  [(3,0),(7,4),(9,8)]
18:15:50 <dibblego> @paste
18:15:51 <lambdabot> http://paste.lisp.org/new/haskell
18:15:53 <AstralStorm> Not too :>
18:16:11 <lisppaste2> dibblego pasted "Why doesn't this compile?" at http://paste.lisp.org/display/26216
18:16:22 <AstralStorm> I mean like [a, b, c] -> [(0, a), (a+1, b), (b+1, c)]
18:16:51 <Deformative-II> Hmm,  can anyone give me examples of logical and efficiant languages?  (Resource light = my defenition of efficiant)
18:17:02 <dons> logical?
18:17:12 <dons> you mean logic programming, or logical design?
18:17:39 <dons> for the later, see Clean or nhc98-compiled haskell
18:17:40 <AstralStorm> dibblego: that's not haskell
18:17:48 <dibblego> AstralStorm, I figured that much
18:18:01 <AstralStorm> On the left side of = you give symbolic names of parameters
18:18:10 <dons> AstralStorm: ah, that looks like a scanl or a mapAccum
18:18:12 <AstralStorm> On the right side, you do something with them.
18:18:27 <dons> ?type mapAccumL
18:18:28 <Deformative-II> dons,  I dunno, I just heard someone say it and it reminded me of the thinking style test they made me take at school that said I was a logical thinker.
18:18:28 <dibblego> AstralStorm, I thought you could do pattern matching with specific values
18:18:28 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:18:30 * Deformative-II shrugs.
18:18:35 <AstralStorm> Nope.
18:18:49 <AstralStorm> Not that, because it accumulates the counter one by one.
18:19:21 <dibblego> AstralStorm, why does this compile: d :: Int -> Int
18:19:21 <dibblego> d 7 = 5
18:19:34 <dibblego> yet my previous example doesn't
18:19:35 <dons> > mapAccumL (\acc -> x -> (x,(x,acc+1))) (-1) [3, 7, 9]
18:19:36 <lambdabot>  Parse error
18:19:40 <AstralStorm> :/
18:20:02 <dons> > mapAccumL (\acc -> x -> (x, (x,acc+1))) (-1) [3, 7, 9]
18:20:03 <lambdabot>  Parse error
18:20:10 <mauke> dibblego: probably because "foo" has the type [Char], not (Eq a) => [a]
18:20:15 <AstralStorm> dibblego: because haskell can't read minds :>
18:20:28 <dons> > mapAccumL (\acc x -> (x, (x,acc+1))) (-1) [3, 7, 9]
18:20:29 <lambdabot>  (9,[(3,0),(7,4),(9,8)])
18:20:31 <araujo> AstralStorm, working towards it
18:20:35 <AstralStorm> d 7 = 5 is simple
18:20:43 <dons> > snd $ mapAccumL (\acc x -> (x, (x,acc+1))) (-1) [3, 7, 9]
18:20:44 <lambdabot>  [(3,0),(7,4),(9,8)]
18:20:45 <AstralStorm> It will take any integer and give you 5
18:20:47 <dons> :)
18:20:52 * araujo was discussing something called mindware with his professor last week
18:20:59 <AstralStorm> Backwards, but damn nice!
18:21:13 <AstralStorm> Now explain :>
18:21:14 <dons> > snd $ mapAccumL (\acc x -> (x, (acc+1, x))) (-1) [3, 7, 9]
18:21:15 <lambdabot>  [(0,3),(4,7),(8,9)]
18:21:26 <mauke> AstralStorm: no, it will take 7 and give you 5
18:21:32 <dons> mapAccum lets you map over a list, passing an accumulating value
18:21:38 <AstralStorm> mauke: ah right.
18:21:40 <dons> so we do: \acc x -> (x, (acc+1, x))
18:21:51 <AstralStorm> So you can call it only with 7 as a parameter? Funny function :>
18:22:08 <dibblego> no you don't pass any parameters - it is a constant function
18:22:10 <AstralStorm> @type mapAccumL
18:22:11 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:22:22 <dibblego> > let d 5 = 7 in d 5
18:22:23 <lambdabot>  7
18:22:53 <dons> so, its takes an accumulator, and the current list element, and then sets the current element as the new accumulator, while returning a pair of the prev value +1, : (x, (acc+1, x))
18:23:08 <dons> mapAccumL++
18:23:12 <dons> under appreciated function
18:23:16 <AstralStorm> Hehe :>
18:23:23 <AstralStorm> Disused one too :>
18:23:54 <AstralStorm> I've tried to achieve something like that with map, but to no avail :>
18:24:21 <dons> because you need to do both a map and a fold simultaneously
18:24:51 <AstralStorm> Unfortunately.
18:25:07 <AstralStorm> Maybe I could build two lists then zip them.
18:25:45 <AstralStorm> Might be cleaner.
18:26:27 <dons> ?let build acc x = (x, (acc+1, x))
18:26:28 <lambdabot> Defined.
18:26:38 <dons> > snd $ mapAccumL build (-1) [3, 7, 9]
18:26:39 <lambdabot>  Not in scope: `build'
18:26:42 <dons> > snd $ mapAccumL L.build (-1) [3, 7, 9]
18:26:44 <lambdabot>  [(0,3),(4,7),(8,9)]
18:26:48 <AstralStorm> :>
18:27:15 <dons> I can't see how it could be any cleaner. the essence of the computation is clear now
18:27:48 <AstralStorm> Yes, it can't be.
18:28:05 * dibblego wipes a speck of dust from the expression
18:29:04 <AstralStorm> So in the mapAccumL which arguments of the function change? Only acc?
18:29:25 <dons> acc, right.
18:29:40 <dons> build threads its acc value around
18:31:25 <lisppaste2> dibblego pasted "is there a cleaner way?" at http://paste.lisp.org/display/26218
18:31:27 <AstralStorm> Ahh, so mapAccumL uses the fst (x, (acc+1, x)) as the value for the next run, right?
18:31:53 <AstralStorm> and snd as the item to be put in the list?
18:33:04 <AstralStorm> I mean the fst will end up as the acc in the next recursion, right?
18:33:44 <AstralStorm> (where the x is the next value of the processed list)
18:33:48 <AstralStorm> Nice functionality.
18:33:58 <dons> yes.
18:34:12 <dons> the type says it all, in fact:
18:34:16 <dons> ?type mapAccumL
18:34:18 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:35:20 <dons> dibblego: what's the code going? 'words'?
18:35:21 <AstralStorm> It's funny that the acc is retained in the end - though that will be immensely useful in my case :>
18:35:28 <dons> > words "xyz abc def   ghi "
18:35:29 <lambdabot>  ["xyz","abc","def","ghi"]
18:35:55 <AstralStorm> Something like words but with your chosen separator :>
18:35:55 <dibblego> dons, words, but without the "hard-coded" space as the delimiter
18:36:10 <dons> ah ok
18:36:32 <vagina> what up
18:36:40 <dons> can you change your nick please.
18:36:56 <busted> anytime
18:36:58 <dons> thanks.
18:37:18 <araujo> :-P
18:38:06 <AstralStorm> Any good idea for list flattening?
18:38:17 <dons> concat?
18:38:27 <mauke> join?
18:38:28 <AstralStorm> I mean I have [a, [b, [c, d]]]
18:38:34 <SamB> concat . concat . concat
18:38:40 <Pseudonym> Yup.
18:38:42 <AstralStorm> And want [a, b, c, d]
18:38:47 <Pseudonym> Errr...
18:38:50 <SamB> you can't have that in Haskell
18:38:52 <AstralStorm> So I should recursively concat? :P
18:38:55 <dons> ?kind  forall a b c d .[a, [b, [c, d]]]
18:38:56 <SamB> thats Python or PERL
18:38:56 <lambdabot> parse error on input `,'
18:39:00 <Pseudonym> > ['a', ['b', ['c', 'd']]]
18:39:01 <lambdabot>  Couldn't match `Char' against `[a]'
18:39:06 <Pseudonym> See?
18:39:17 <dons> AstralStorm: you mean tuples?
18:39:26 <AstralStorm> Not really :P
18:39:37 <dons> > (1, (2, (3,4)))
18:39:38 <AstralStorm> Wait a bit :P
18:39:39 <lambdabot>  (1,(2,(3,4)))
18:39:39 <Pseudonym> AstralStorm: If you want S-expressions, you have to make them yourself.
18:39:40 <SamB> AstralStorm: how do you propose to get such a lust?
18:39:45 <SamB> er, list
18:39:47 <Pseudonym> Which can be done.
18:39:51 <AstralStorm> Huh :P
18:40:05 <Pseudonym> SamB: Oooh, Freudian penis.
18:40:06 <SamB> typechecking is nice! really it is!
18:40:08 <Pseudonym> Damn, sorry.
18:40:22 <SamB> Pseudonym: its called a typo doofus!
18:40:44 <SamB> I had my keyboard too far in
18:40:45 <araujo> > [1, [2, [3, 4]]]
18:40:46 <lambdabot>  add an instance declaration for (Num [a])
18:40:47 <lambdabot>   In the list element: 2
18:40:50 <lambdabot>   In...
18:41:26 <Pseudonym> I've just worked out that I have no idea how to use KDE without a mouse.
18:41:48 <dons> you should use wmii or ion :)
18:41:56 <Pseudonym> Yeah, probably.
18:42:09 <Pseudonym> The USB connector seems to have died on this machine.
18:42:22 <SamB> quick!
18:42:32 <SamB> find the PS2 adapter thingy that came with your mouse!
18:42:49 <Pseudonym> Strangely enough, I saw it on Friday.
18:42:56 * Pseudonym has just moved offices
18:43:02 <Pseudonym> And I discovered it during the cleanup.
18:43:54 <Pseudonym> What I really need is a KVM switch which handles USB keyboards and dual-head monitors.
18:44:09 <Pseudonym> Err... dual-head displays./
18:44:40 <Pseudonym> On the plus side, I found the cool 3D glasses.
18:44:53 <Pseudonym> Two LCD lenses which beat in sync with the display.
18:45:29 <dibblego> I have a function a -> b -> c but I want it to be function b -> a -> c sometimes
18:45:38 <Pseudonym> ?type flip
18:45:40 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
18:45:44 <dibblego> lol thanks
18:46:22 <Pseudonym> Incidentally, here's another way to work that out:
18:46:30 <Pseudonym> ?djinn (a -> b -> c) -> (b -> a -> c)
18:46:31 <lambdabot> f a b c = a c b
18:46:40 <Pseudonym> ?pl \a b c -> a c b
18:46:40 <lambdabot> flip
18:46:43 <Pseudonym> :-)
18:47:04 <dibblego> what is djinn?
18:47:16 <Pseudonym> It comes up with a function which populates a type.
18:47:37 <Pseudonym> Or, to think of it another way, it proves theorems in intuitionistic logic.
18:48:06 <mauke> dibblego: you give it a type, it shows you the function definition
18:48:19 <dibblego> ok ta
18:48:21 <Pseudonym> ?djinn (a,b) -> (b,a)
18:48:21 <lambdabot> f (a, b) = (b, a)
18:48:42 <mauke> ?. pl djinn (a -> b -> c) -> (b -> a -> c)
18:48:43 <lambdabot> f = flip
18:48:46 <dolio> ?djinn [[a]] -> [a]
18:48:46 <lambdabot> -- f cannot be realized.
18:49:01 <Pseudonym> I don't think it handles lists.
18:49:03 <Pseudonym> However:
18:49:05 <Pseudonym> ?free concat
18:49:06 <lambdabot> $map f . concat = concat . $map ($map f)
18:49:30 <araujo> For using (++) with Data.ByteString , i need to keep packing/unpacking String?
18:49:53 <dons> no. use append
18:49:54 <dibblego> @pl print $ map ((flip tokenise) ',') (lines s)
18:49:54 <lambdabot> print (map (flip tokenise (',')) (lines s))
18:50:04 <araujo> ok dolio
18:50:06 <araujo> argh
18:50:07 <dons> ?type Data.ByteString.append
18:50:08 <lambdabot> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
18:50:09 <araujo> dons
18:50:17 <Pseudonym> ?pl \s -> print (map ((flip tokenise ',') (lines s))
18:50:17 <lambdabot> (line 1, column 49):
18:50:17 <lambdabot> unexpected end of input
18:50:17 <lambdabot> expecting variable, "(", operator or ")"
18:50:21 <dons> or if there are more than 2 to join, use concat
18:50:36 <Pseudonym> ?pl \s -> print (map ((flip tokenise) ',') (lines s))
18:50:36 <lambdabot> print . map (flip tokenise (',')) . lines
18:50:43 <dons> but remember that you're copying arrays around, so try not to append or concat too often :)
18:50:49 <araujo> @type Data.ByteString.Char8.concat
18:50:50 <lambdabot> [Data.ByteString.Base.ByteString] -> Data.ByteString.Base.ByteString
18:51:08 <araujo> dons, ok, i'll keep it on mind
18:52:25 <dibblego> > read "True"
18:52:26 <lambdabot>  Add a type signature
18:52:30 <dons> mmm lambdabot:: uptime: 15d, 5m  48s, longest uptime: 15d, 5m  48s
18:52:31 <dibblego> > read "True" :: Bool
18:52:32 <lambdabot>  True
18:52:50 <dibblego> > read 7
18:52:50 <lambdabot>  add an instance declaration for (Num String)
18:52:54 <dibblego> > read 7 :: Int
18:52:55 <lambdabot>  add an instance declaration for (Num String)
18:53:05 <dibblego> > read "7" :: Int
18:53:06 <lambdabot>  7
18:53:20 <dibblego> > read "7"
18:53:20 <lambdabot>  Add a type signature
18:54:38 <dibblego> ?pl \s -> map ((flip tokenise) ',') (lines s)
18:54:38 <lambdabot> map (flip tokenise (',')) . lines
18:59:21 <dibblego> f(g) is equivalent to f . g correct?
18:59:54 <dibblego> if so, can a similar statement be made for f $ g ?
19:00:20 <dons> if the types are correct, yes.
19:00:56 <SamB> er...
19:01:20 <dons> ?check \f g x -> f (g x) == (f . g) x :: (I -> I) -> (I -> I) -> I -> Bool
19:01:20 <SamB> f(g) is the same as f $ g...
19:01:21 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: (I -> I...
19:01:34 <dons> ?check (\f g x -> f (g x) == (f . g) x) :: (I -> I) -> (I -> I) -> I -> Bool
19:01:34 <AstralStorm> ?type let getRange (begin,end) x = take (end-begin) $ drop begin $ take (begin+end) x
19:01:35 <lambdabot>  OK, passed 500 tests.
19:01:36 <lambdabot> not an expression: `let getRange (begin,end) x = take (end-begin) $ drop begin $ take (begin+end) x'
19:01:49 <SamB> @info I
19:01:50 <lambdabot> I
19:01:53 <dons> AstralStorm: let's with out 'in' aren't expressions
19:01:54 <SamB> hmm
19:01:57 <dons> SamB: short cut for Int
19:02:00 <AstralStorm> Aha.
19:02:01 <SamB> ah
19:02:04 <skyde> some one can help me
19:02:13 <AstralStorm> ?type getRange (begin,end) x = take (end-begin) $ drop begin $ take (begin+end) x
19:02:15 <lambdabot> parse error on input `='
19:02:27 <dons> skyde: you have a haskell question?
19:02:29 <AstralStorm> So how would I check the type of a function?
19:02:31 <skyde> is the structural typing system = typing inference + generic programmging  or is it something else
19:02:36 <AstralStorm> (with lambdabot)
19:02:55 <SamB> @type let getRange (begin,end) x = take (end-begin) $ drop begin $ take (begin+end) x in getRange
19:02:57 <lambdabot> forall a. (Int, Int) -> [a] -> [a]
19:03:05 <AstralStorm> Ah :>
19:03:05 <dons> ?type let f x = x in f -- use an expresion
19:03:07 <lambdabot> forall t. t -> t
19:03:07 <AstralStorm> Thanks.
19:03:18 <dons> > let f x = x in f :: T -> T
19:03:20 <lambdabot>  <[Int] -> [Int]>
19:03:29 <dons> > let f x = x in f :: I -> I
19:03:30 <lambdabot>  <Int -> Int>
19:03:42 <AstralStorm> Any better way of doing that getRange?
19:04:03 <ndm> dons, why can't i @remember things!
19:04:04 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
19:04:11 <dons> ndm, ah my bug. let me fix that...
19:04:23 <SamB> oh, yeah, I forgot about that one...
19:04:37 <SamB> I hadn't got my lambdabot built yet, you see...
19:04:37 <mauke> AstralStorm: yeah, remove the take (begin+end) part
19:04:45 <ndm> dons, and i've seen that point about hoogle keyword wiki links 3 times now - either you keep @tell, or lambdabot keeps sending it!
19:04:50 <AstralStorm> That makes it fail in certain cases :P
19:04:53 <AstralStorm> Which is weird.
19:05:00 <AstralStorm> E.g.
19:05:07 <AstralStorm> "a bcd efgh"
19:05:11 <dons> ?quit reenable remember
19:05:18 <SamB> ndm: maybe lambdabot keeps crashing?
19:05:24 <SamB> anyway this time it will be fine
19:05:24 <dons> mm. weird
19:05:32 <SamB> assuming that was the problem
19:05:32 <dons> ndm, can you send me a msg?
19:05:35 <skyde> some one can answer me ?
19:05:37 <AstralStorm> With range of (3,5)
19:06:13 <dons> skyde: i'm not sure. you need to check the research papers I think, on the topic
19:06:16 <AstralStorm> > let getRange1 (begin,end) x = drop begin $ take (begin+end) x
19:06:21 <ndm> @tell dons yes, i can
19:06:37 <lambdabot>  Parse error
19:06:37 <dons> ping bot
19:06:41 <lambdabot> Consider it noted.
19:06:45 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:06:55 <Itkovian> @seen BCoppens
19:06:55 <lambdabot> I saw BCoppens leaving #haskell-blah and #haskell 13m 52s ago, and .
19:06:58 <AstralStorm> Uh parse error?
19:07:07 <dons> AstralStorm: let without 'in'
19:07:13 <AstralStorm> Blah
19:07:18 <AstralStorm> > let getRange1 (begin,end) x = drop begin $ take (begin+end) x in getRange1
19:07:19 <lambdabot>  Add a type signature
19:07:31 <dons> ndm, so lambdabot seems to have realised i don't need to read the msg again
19:07:34 <SamB> > let getRange1 (begin,end) x = drop begin $ take (begin+end) x in getRange1 (1,2)
19:07:35 <lambdabot>  Add a type signature
19:07:44 <AstralStorm> > let getRange1 (begin,end) x = drop begin $ take (begin+end) x in getRange1 :: (Int,Int) -> [a] -> [a]
19:07:46 <lambdabot>  Add a type signature
19:08:10 <AstralStorm> > let (getRange1 (begin,end) x = drop begin $ take (begin+end) x :: (Int,Int) -> [a] -> [a]) in getRange1
19:08:10 <lambdabot>  Parse error
19:08:20 <SamB> oops
19:08:20 <skyde> dons : i would like to but i dont find anything about the structural typing vs generic programming
19:08:27 <AstralStorm> Hmm
19:08:35 <ndm> dons: it pops up every day, but no more than that
19:08:50 <dons> ndm, hmm. do you reconnect, and then it asks you?
19:08:54 <AstralStorm> > let getRange1 (begin,end) x = drop begin $ take (begin+end) x in (getRange1 :: (Int,Int) -> [a] -> [a])
19:08:55 <lambdabot>  Add a type signature
19:08:56 <SamB> oh wait, that is just x-chats lousy word-wrapping...
19:08:59 <mauke> AstralStorm: why did you remove take (end-begin)?
19:09:10 <AstralStorm> Yes, for a while
19:09:14 <AstralStorm> So that you see it fails.
19:09:20 <mauke> WHY
19:09:26 <ndm> dons: i was connected for at least 6 hours, then just now it prompted me again
19:09:37 <ndm> @remember RyanT5000 ok so i installed unix, but now i need to install posix
19:09:37 <AstralStorm> But can't get that dam^Wuseful lambdabot to remember the name
19:09:52 <mauke> of course it fails if you break the code
19:09:59 <SamB> @quote RyanT5000
19:09:59 <lambdabot>  i wish i had been programming in haskell for 7 years rather than C++
19:10:04 <dons> hmm. ah i think that means when lambdabot got sighupped, it forgot to flush the seen state, so it thinks it still needs to tell you that msg
19:10:16 <dons> i _think_ it should be ok now, since its rebooted since you read that msg, safely
19:10:17 <SamB> dons: sighupped?
19:10:29 <AstralStorm> mauke: who said that the take (end-begin) part was superfluous? :P
19:10:29 <dons> ok. i lie. sigkill'd
19:10:36 <mauke> AstralStorm: no one
19:10:44 * SamB SIGINTs
19:10:45 <AstralStorm> Ah, + != - :P
19:10:54 <ndm> dons: ah well, i'll let you know if it happens again
19:11:07 * ndm sleeps, perchance to dream
19:11:11 <dons> yes, please do. @remember should also work now
19:11:20 <SamB> @quote RyanT5000
19:11:20 <lambdabot>  ok so i installed unix, but now i need to install posix
19:11:27 <SamB> dons: yes, it does
19:11:30 <mauke> it's either drop begin . take end or take (end - begin) . drop begin
19:11:36 <SamB> isn't that a nice quote?
19:12:00 <dons> I like that one , yes.
19:12:07 <weitzman> > let getRange (s,e) = take (e-s) . drop s in getRange (1, 3) [1, 2, 3, 4, 5, 6, 7]
19:12:09 <lambdabot>  [2,3]
19:12:18 <SamB> waren't true, but it seemsed to be ;-)
19:13:22 <AstralStorm> Ok, got some code to clean up :>
19:13:24 <weitzman> > let getRange (s,e) = drop s >>> take (e-s) in getRange (1, 3) [1, 2, 3, 4, 5, 6, 7]
19:13:25 <lambdabot>  [2,3]
19:14:22 <dmwit> @hoogle a -> [a] -> Int
19:14:23 <lambdabot> No matches, try a more general search
19:14:29 <dmwit> @hoogle [a] -> a -> Int
19:14:29 <lambdabot> No matches, try a more general search
19:15:01 <dmwit> @hoogle Eq a => a -> [a] -> Int
19:15:02 <lambdabot> No matches, try a more general search
19:15:16 <lisppaste2> AstralStorm pasted "Generic string splitting" at http://paste.lisp.org/display/26221
19:15:27 <dolio> ?hoogle (a -> Bool) -> [a] -> Int
19:15:28 <lambdabot> No matches, try a more general search
19:15:33 <AstralStorm> Any hints?
19:17:38 <AstralStorm> (except maybe cleaning up last line - will do)
19:18:22 <AstralStorm> Except it's slow :P
19:20:11 * dons listens to cicadas and realises its spring! yay!
19:20:44 <AstralStorm> Spring where? :P
19:20:57 <dons> half the planet
19:21:12 <AstralStorm> Not here :P
19:21:30 <dolio> Ooo, paste highlights the parentheses enclosing the area your cursor is over.
19:21:32 <dolio> Sexy.
19:21:34 <wkh> in the land where men make sweet love to dingos it is
19:22:18 <dons> crocodiles, I think you mean
19:22:33 <wkh> i stand corrected
19:22:33 <dons> the dingos just take the babies
19:22:44 <wkh> crikey
19:24:00 <AstralStorm> Which would be faster:
19:24:04 <AstralStorm> tail on some list
19:24:12 <AstralStorm> or getting the fst of a tuple?
19:25:04 <dibblego> they would both be O(1) I would hope
19:26:18 <sjanssen> AstralStorm: they should be exactly the same
19:26:28 <AstralStorm> Great then :>
19:27:29 <dons> data (,) a b = (a,b) ; fst (a,b) = a; data [] a = (:) a [a] | [] ; tail (a:b) = b
19:28:12 <dons> the tail version has to check for both constructors though. so that's O(2*1) :)
19:29:21 <sjanssen> tail will likely check the cons constructor first, right?
19:29:29 <dons> ah no, it checks the (_:b) case first. so they're both O(1)
19:29:32 <dons> tail (_:xs)             =  xs
19:29:33 <dons> tail []                 =  errorEmptyList "tail"
19:29:57 <SamB> dons: O(2*1) = O(1), you know...
19:30:05 <dons> yes, hence ":)"
19:30:42 <SamB> and doesn't the generated code do a "switch" over constructors anyway?
19:31:01 <sjanssen> next time I want an algorithm to seem fast, I'm going to call it O(1/2)
19:31:13 <dibblego> O(asymptote 0)
19:31:13 <dons> yep. it'll be byte tags in a switch. which might end up in a vector jump anyway
19:31:32 <SamB> dons: that is the expected implementation for a dense switch...
19:31:33 <dons> ?remember sjanssen next time I want an algorithm to seem fast, I'm going to call it O(1/2)
19:31:57 <dons> SamB: right. it doesn't always happen with ghc's switches, but it does fairly often, I think
19:32:07 <dons> there's some careful interaction between Cmm and gcc
19:32:36 <SamB> I'd assume that if it didn't happen, that would be becuase GCC decided another way would be better?
19:32:37 <dons> I remember triggering a gcc segfault with some funny switches produced by ghc after the C-- rewrite
19:32:49 <dons> or gcc was too dumb to spot the patterns
19:32:57 <SamB> patterns?
19:33:12 <dons> i.e. some case-of-case-of switches aren't handled nicely, and reorder in strange ways
19:33:19 <SamB> oh, okay.
19:33:24 <SamB> that is wierd...
19:33:26 <dons> gcc isn't optimised (or tested!) on the kind of C ghc produces
19:33:53 <SamB> dunno why they'd be reordered at all
19:34:15 <dons> (what we do is a bit like generating unboxed, strict haskell as a target for some other language -- definitely going to stress ghc)
19:34:24 <SamB> they ought to add GHC to their tests...
19:34:27 <SamB> somehow or other.
19:34:38 <lisppaste2> AstralStorm annotated #26221 with "Is this version cleaner?" at http://paste.lisp.org/display/26221#1
19:35:08 <dibblego> you think that's cleaner?
19:35:11 <weitzman> > let splitOn c list = if null list then [] else if null b then [a] else [a]++(splitOn c (tail b)) where (a, b) = span (/= c) list in splitOn ',' "123,456,7890,,123"
19:35:12 <lambdabot>  ["123","456","7890","","123"]
19:35:25 <AstralStorm> weitzman: hehehe.
19:35:28 * SamB to bed
19:35:38 <AstralStorm> Now unwrap that :P
19:36:01 <AstralStorm> I mean write it in some human-edible form :>
19:36:09 <SamB> you want to eat code?
19:36:15 * SamB is bad at going to bed
19:36:16 <weitzman> @pretty let splitOn c list = if null list then [] else if null b then [a] else [a]++(splitOn c (tail b)) where (a, b) = span (/= c) list in splitOn ',' "123,456,7890,,123"
19:36:16 <weitzman> (22:34:40) lambdabot:  ["123","456","7890","","123"]
19:36:17 <lambdabot>  i = let splitOn c list
19:36:17 <lambdabot>       = if null list then [] else
19:36:17 <lambdabot>         if null b then [a] else [a] ++ (splitOn c (tail b))
19:36:17 <lambdabot>       where (a, b) = span (/= c) list
19:36:17 <lambdabot>     in splitOn ',' "123,456,7890,,123"
19:36:28 <dons> @seen glguy
19:36:28 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
19:36:54 <AstralStorm> Recursive version, hehehe.
19:37:10 <weitzman> As much as I wanted to use some kind of mapping function...
19:37:11 <weitzman> I failed
19:37:13 <AstralStorm> I was wondering for a long time how to do that.
19:37:22 <dmwit> @pl count elem = length . filter (== elem)
19:37:22 <lambdabot> count = (length .) . filter . (==)
19:37:47 <dmwit> Not better, I think...
19:37:58 <AstralStorm> We can protect against null list with 2 defs :>
19:38:13 <weitzman> @hoogle ([a] -> ([a], [a])) -> [a] -> [[a]]
19:38:14 <lambdabot> No matches, try a more general search
19:38:28 <weitzman> That's the function I wanted
19:39:07 <AstralStorm> I didn't know where can act like that...
19:39:11 <Cale> lispy: why are you opped?
19:39:16 <AstralStorm> Is that some nice pattern matching?
19:39:25 <Cale> Was there a problem earlier?
19:39:32 <dons> hmm
19:39:39 * dons checks logs
19:39:41 <weitzman> Yeah, pattern matching on the result of span
19:39:53 <AstralStorm> :D
19:40:22 <AstralStorm> Only with where and case, right?
19:40:31 <AstralStorm> (except function parameter lists)
19:40:43 --- mode: ChanServ set -o lispy
19:40:55 <weitzman> Function parameters, where, case, let
19:41:09 <weitzman> > (\(a, b) -> b) (1, 2
19:41:09 <lambdabot>  Parse error
19:41:10 <AstralStorm> let too? Now that sounds even nicer.
19:41:24 <weitzman> > (\(Just x) -> x) (Just 3)
19:41:26 <lambdabot>  3
19:41:29 <weitzman> Hmm
19:41:30 <weitzman> Oh
19:41:36 <dons> Cale: 11:11:48 --- mode: ChanServ set +o lispy
19:41:39 <weitzman> > (\(a, b) -> b) (1, 2
19:41:39 <lambdabot>  Parse error
19:41:43 <weitzman> Same typo
19:41:47 <weitzman> > (\(a, b) -> b) (1, 2)
19:41:48 <lambdabot>  2
19:41:49 <AstralStorm> ;-)
19:42:04 <weitzman> > (\1 -> 2) 3
19:42:06 <lambdabot>  Non-exhaustive patterns in lambda
19:42:12 <dmwit> > snd (1, 2)
19:42:13 <lambdabot>  2
19:42:40 <AstralStorm> I _have_ to remember that this works in most places.
19:42:47 <dmwit> > (\1 -> 2) 1
19:42:49 <lambdabot>  2
19:42:52 <dmwit> Interesting...
19:43:00 <AstralStorm> Convertible number :>
19:43:12 <AstralStorm> Actually, it's a function returning a 2
19:43:20 <AstralStorm> Always.
19:43:28 <dmwit> No: only on an input of 1.
19:43:38 <AstralStorm> You give it one, hehe.
19:43:41 <dmwit> For everything else, it's undefined.
19:43:47 <wkh> > (\1 -> 2) 42
19:43:48 <AstralStorm> Hmm... One-checker.
19:43:49 <lambdabot>  Non-exhaustive patterns in lambda
19:44:06 <AstralStorm> And with a broken message too :>
19:44:22 <dmwit> > (\1 -> "You are the One.") 1
19:44:23 <lambdabot>  "You are the One."
19:44:37 <dmwit> =)
19:45:03 <AstralStorm> > 1 = 5
19:45:04 <lambdabot>  Parse error
19:45:10 <AstralStorm> > newtype 1 = 5
19:45:10 <lambdabot>  Parse error
19:45:15 <AstralStorm> Blah.
19:45:22 <AstralStorm> Can't define a type called 1? :P
19:45:31 <dons> > undefined :: 1
19:45:32 <lambdabot>  Parse error
19:45:39 <dons> ?kind undefined :: 1
19:45:40 <lambdabot> parse error on input `::'
19:45:47 <dons> ?type undefined :: 1
19:45:49 <lambdabot> 1 :: GHC.Base.Unit
19:46:10 <AstralStorm> Mhm... so it even does work.
19:46:30 <mauke> ?type undefined :: '1'
19:46:31 <lambdabot> parse error on input `''
19:46:38 <dons> ?kind 1
19:46:40 <lambdabot> *
19:46:45 <dons> ?type 1
19:46:46 <lambdabot> forall t. (Num t) => t
19:46:48 <dons> > 11
19:46:50 <lambdabot>  11
19:46:53 <AstralStorm> ?type undefined :: C1
19:46:54 <weitzman> ?kind Num
19:46:55 <lambdabot> Not in scope: type constructor or class `C1'
19:46:56 <lambdabot> Class `Num' used as a type
19:47:00 <dmwit> ?type `'
19:47:02 <lambdabot> parse error on input ``'
19:47:04 <dons> classes don't have kinds.
19:47:20 <dons> > '' -- not a char
19:47:20 <lambdabot>  Improperly terminated character constant
19:47:24 <weitzman> @type Num
19:47:26 <lambdabot> Not in scope: data constructor `Num'
19:47:34 <dmwit> ?kind Num a => a
19:47:35 <weitzman> Classes don't have anything
19:47:35 <lambdabot> *
19:47:41 <dons> right.
19:47:45 <dons> they're just sugar
19:47:56 <AstralStorm> But useful one.
19:47:59 <dons> for explicit method dictionaries
19:48:05 <dons> ?type sort -- implicit
19:48:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:48:10 <dons> ?type sortBy --explicit
19:48:12 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
19:48:31 <dmwit> Ah!
19:48:33 <dmwit> Interesting.
19:48:34 <AstralStorm> For preconditions mostly?
19:48:42 <AstralStorm> Any other use of classes?
19:48:53 <AstralStorm> *for
19:48:54 <dons> for bounded polymorphism
19:48:59 <dons> and about a zillion other things
19:49:00 <weitzman> Classes seem to act like objects from OO languages
19:49:01 <weitzman> Somewhat
19:49:08 <AstralStorm> Mhm.
19:49:16 <weitzman> And by objects, I mean classes
19:49:30 <AstralStorm> :>
19:49:32 <dons> AstralStorm: check haskell.org's research page, under 'type systems/applications of type classes'
19:49:38 <weitzman> I would think a type class would be a type, though
19:49:44 <Pseudonym> Unfortunately, an OO "class" actually conflates two ideas.
19:49:51 <dons> its a constraint on a type though, weitzman
19:49:58 <dons> ?kind Num a => a
19:50:00 <lambdabot> *
19:50:01 <weitzman> A product type. A tuple of method signatures
19:50:06 <Pseudonym> A "class" in C++ or Java is three things:
19:50:27 <Pseudonym> Say: class Foo { ... }
19:50:40 <Pseudonym> 1. That's a _set_ of types, namely, the subclasses of Foo.
19:50:48 <dons> wilx: I suppose you could treat  class as a type whose type is the parametrised method signature of the class
19:50:48 <Pseudonym> 2. It's a concrete type called Foo.
19:51:02 <Pseudonym> 3. It's a declaration that the concrete type Foo is a member of the class Foo.
19:51:10 <Pseudonym> In haskell, you do those three things separately.
19:51:15 <dons> s/wilx/weitzman, a product type, as you say
19:51:31 <AstralStorm> Python objects are much closer to Haskell's definition of class.
19:52:17 <AstralStorm> There, 3 is separate (it's called an instance)
19:52:42 <AstralStorm> Types still aren't.
19:53:11 <weitzman> Now I'm starting to feel like typeclasses are dependent functions on types, and type functions should have a kind
19:53:29 <dibblego> in Java, an array, a java.util.List and a Map<Integer, ?> are all the same thing, yet they are not assignable to each other - most methods of each are functions of some others
19:53:30 <weitzman> An arrow kind
19:53:42 <weitzman> Or a pi kind, if they're dependent
19:54:12 <AstralStorm> dibblego: in Python they are assignable, unless you block that explicitly
19:54:31 <dibblego> AstralStorm, dynamic typing is a hacked solution to the problem
19:54:36 <AstralStorm> actually, blah :P
19:54:42 <dons> weitzman: right, like the new System Fc, where type functions are more first class
19:54:48 <dons> let me find the link
19:55:01 <dibblego> OO gives you a higher-order construct *at the expense of software*
19:55:08 <AstralStorm> dibblego: yes, the proper solution is the typeful language
19:55:11 <weitzman> Num a = a -> (add :: a -> a -> a, ...)
19:55:42 <weitzman> Has type Pi c:T . (c->c->c, ...)
19:55:45 <AstralStorm> OO can be done in Haskell too, bwhaha.
19:55:57 <AstralStorm> But that'd be awkward.
19:56:05 <dons> weitzman: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
19:56:09 <lambdabot> Title: TypeFunctions - GHC - Trac, http://tinyurl.com/gdb8n
19:56:16 <dibblego> if I write some function/method that accepts a type array: T m(A[] a) and within the implementation I say a[i], then I should also be able to pass a List or anything that satisfies the requirements for that operation on the array
19:56:21 <Pseudonym> It depends what you want to do.
19:56:36 <dons> weitzman: all the twelf-ish goodness you could want :)
19:56:37 <Pseudonym> The main thing that's hard to do in Haskell is what C++ calls dynamic_cast.
19:56:42 <AstralStorm> dibblego: an interface, so to say
19:56:50 <Pseudonym> Downcasting, basically.
19:56:52 <dibblego> AstralStorm, an interface does not solve it
19:57:22 <AstralStorm> Ah, right.
19:57:28 <AstralStorm> Contract.
19:57:30 <dibblego> that array, List and Map<Integer, ?> have some other irrelevant operations defined is important (requirement leak costs) but not the core problem
19:57:36 <Pseudonym> A lot of OO purists say to avoid downcasting, though.
19:57:52 <dibblego> Pseudonym, yes, I haven't downcasted in Java since school 10 or so years ago
19:58:07 <dibblego> but that's not "purist", that's just the best workaround
19:58:19 <Pseudonym> Right.
19:58:45 <Pseudonym> A lot of the time, though, when people say they want downcasting, they actually want algebraic data types.
19:58:59 <AstralStorm> dibblego: so you'd want the function to check for a subset of these methods - an interface
19:59:10 <dibblego> I also argue that the separation of type contract (interface) from implementation (class) is only suitable because of the lack of proof of referential transparency - but that's a veyr long argument that I've had with many people who all arrived at the same conclusion (given my bias of course)
19:59:21 <dibblego> AstralStorm, yes, but the problem is, what is "that method"?
19:59:31 <dibblego> AstralStorm, it should be a formal expression of the requirement for that method
19:59:40 <dibblego> then all methods whose expression is equivalent are equally assignable
19:59:47 <AstralStorm> It is, but it's not derived automatically.
19:59:48 <weitzman> dons: I'm going to muse this type function business and proclaim something profound about it later
19:59:51 <dibblego> and also, any higher order methods are also assignable
19:59:57 <AstralStorm> Unlike Haskell.
20:00:46 <dibblego> AstralStorm, right, but that's not the case in the language, which is a huge pitfall
20:01:05 <dibblego> I *should* be use an array, List and Map<Integer, ?> interchangable
20:01:10 <dibblego> *interchangably
20:01:24 <dibblego> since there is no difference (extra methods don't belong there in fact)
20:01:40 <dibblego> the ultimate conclusion is: "any method that access 'this' is defective"
20:01:48 <dibblego> which means OO and software are mutually exclusive
20:01:51 <dmwit> > \(a, b) -> a ++ tail b . \x -> ("hi", "  there")
20:01:52 <lambdabot>    Expecting a function type, but found `[a]'
20:01:52 <lambdabot>    Expected type: b -> c
20:01:52 <lambdabot>  ...
20:01:55 <dibblego> haven't I said I'm writing a book on this before?
20:02:12 <dmwit> > (\(a, b) -> a ++ tail b) ("hi", "  there")
20:02:13 <lambdabot>  "hi there"
20:02:21 <dibblego> in between figuring out this Haskell business that is
20:03:08 <AstralStorm> The conclusion is wrong :>
20:03:31 <AstralStorm> The "classes" are mostly containers for some state and functions working on that state.
20:03:32 <dibblego> I have spent  *thousands* of hours looking for a hole in the proof
20:03:39 <dibblego> that's very simplistic
20:03:53 <AstralStorm> In haskell, you'd keep state and functions separate.
20:04:01 <dibblego> I have argued my case with many people, hoping they'd find a hole - but they now all hold the same belief as myself
20:04:05 <AstralStorm> And "interface" separate too.
20:04:11 <dibblego> that's wrong
20:04:17 <dibblego> there is a paper that points that out
20:04:20 <dibblego> I will find it
20:04:22 <AstralStorm> Because Java class is an interface contract too.
20:04:38 <AstralStorm> That is unfortunate.
20:04:52 <dibblego> you are just reiterating the marketing guff that I hope to burn one day
20:05:40 <dibblego> <title>
20:05:40 <dibblego>       Simple Type-Theoretic Foundations for Object-Oriented Programming
20:06:00 <dibblego> in short, OO is just functional programming in disguise, with some inherent defects
20:06:13 <dibblego> or "digressions away from software" if you will
20:06:17 <AstralStorm> Which marketing guff? Not having separate classes, types, state and functions disallows proper singletons.
20:06:31 <dibblego> "The "classes" are mostly containers for some state and functions working on that state." -- that
20:06:32 <AstralStorm> The most important defect.
20:06:38 <dons> SamB: if we're going to use MVars, then we may as well ditch the threading all together ?
20:06:39 <AstralStorm> Mostly
20:06:46 <AstralStorm> Also an interface contract :/
20:06:54 <dibblego> the singleton pattern itself is a requirement defect
20:06:59 <dibblego> I'm tired of that euphemism
20:07:05 <dibblego> I wish it would die
20:07:09 <AstralStorm> Not "pattern"
20:07:09 * dibblego burns a copy of GoF
20:07:14 <AstralStorm> I mean the true singleton :P
20:07:18 <dibblego> there is no such thing
20:07:24 <dibblego> until you prove a finite size universe
20:07:26 <AstralStorm> @type Unit
20:07:28 <lambdabot> Not in scope: data constructor `Unit'
20:07:40 <AstralStorm> Not in OO, yes.
20:07:42 <dibblego> a singleton requires a context to exist legitimately
20:07:45 <dibblego> not in anything
20:07:45 <weitzman> A lot of people using fancy-schmancy languages start dissing patterns, but I think they're missing the point of design patterns as an idea
20:07:48 <AstralStorm> @hoogle Unit
20:07:49 <lambdabot> Data.Graph.Inductive.Internal.Heap.unit :: Ord a => a -> b -> Heap a b
20:07:50 <lambdabot> Data.FiniteMap.unitFM :: key -> elt -> FiniteMap key elt
20:07:50 <lambdabot> Data.Set.unitSet :: a -> Set a
20:08:01 <AstralStorm> Nope, blah.
20:08:03 <weitzman> No matter what language you're using, you still have data, you still have state, and you still want to extend existing code without changing it
20:08:07 <AstralStorm> > data Unit = Unit
20:08:08 <lambdabot>  Parse error
20:08:16 <dibblego> weitzman, no they aren't - they try to define them beyond the marketing trash only to find they have no tangible existence
20:08:30 <dibblego> weitzman, that statement is not necessarily true
20:08:34 <weitzman> Patterns are ways to partition your code and data
20:08:36 <dibblego> weitzman, if it is, it is a consequence of something else
20:08:45 <Cale> I tend to look at OO programming as being fundamentally based on the idea that we'd call existential typing.
20:08:45 <weitzman> To acheive whatever goal you may have
20:09:09 <dibblego> weitzman, there are few that actually achieve a goal - they only appear to as a result of selective learning/teaching (marketing)
20:09:21 <AstralStorm> The only problem is when the language forces some patterns on you.
20:09:44 <dibblego> I'll keep writing a book - hopefully provoke some deeper thought
20:09:55 <dibblego> I can't argue at this level very well - I get frustrated
20:10:16 <wkh> OO is a lot more important to have when you can't pass functions as parameters or return them
20:10:26 <AstralStorm> Exactly.
20:10:38 <dibblego> gah
20:10:57 <weitzman> Well, I'll say this: The idea of design patterns is definitely useful in OO languages, as I think most would agree. Not everyone will agree with my second claim, which is that patterns are a universal idea which apply to all programming languages
20:10:58 <dibblego> this stuff makes me want to stab my former employer's CEO in the eye
20:10:59 <AstralStorm> But function is not an instance of anything really.
20:11:08 <dibblego> they are the ones propagating this nonsense
20:11:25 <AstralStorm> That's why making function an object is theoretically suicidal.
20:11:32 <Cale> Basically, OO is about having values whose type indicates only their interface. (Even in the typeless OO languages, there are still types in some sense, in the programmer's head)
20:11:55 <zapilla> typeless OO languages?
20:12:03 <zapilla> i can't think of any
20:12:03 <Cale> yeah
20:12:13 <dibblego> I offer a definition of OO that is much broder than that, then point out how that and software cannot co-exist
20:12:24 <weitzman> zapilla: Well, depends on what you mean by typeless. I might call Ruby typeless
20:12:25 <dibblego> since there are some underlying contradictions (reductio ad absurdum)
20:12:29 <AstralStorm> You mean the real world? :P
20:12:30 <dibblego> 8broader
20:12:32 <zapilla> weitzman: but it's not
20:12:33 <dibblego> *broader
20:12:38 <zapilla> it's just dynamically typed
20:12:43 <weitzman> zapilla: You can add methods which are particular to a given object
20:12:45 <AstralStorm> So write a paper/book and publish it :>
20:12:49 <sjanssen> is any language really typeless?
20:12:52 <dibblego> I must go before I get frustrabated by the gumph that I detest
20:12:55 <weitzman> So every object can have a unique type, which isn't predefined
20:13:05 <weitzman> Which strike me as a strange system of typing
20:13:07 <AstralStorm> sjanssen: pure untyped lambda calculus?
20:13:08 <clanehin> OO is based on the idea that, using encapsulation, we can let hundreds of second-rate programmers hack it out, and somehow assemble the pieces based on the exposed intefaces (hyperbole)
20:13:17 <zapilla> weitzman: that's no different from any other language type system
20:13:20 <Cale> Okay, I don't really mean typeless, I mean statically typeless :)
20:13:22 <Cale> hehe
20:13:23 <zapilla> as far as i can see
20:13:25 <dibblego> OO an encapsulation are mutually exclusive
20:13:35 <Cale> I should say dynamically typed
20:13:42 <dibblego> (refer to my previous remark about requirement leak which is the opposite of encapsulation)
20:13:51 <Cale> (I'm a little tired :)
20:13:57 <dibblego> OO implies requirement leak by its very definition - the opposite of encapsulation
20:14:00 <zapilla> in fact, I can't think of a typeless language
20:14:04 <dibblego> requirement leak has a *huge* cost
20:14:10 <AstralStorm> Isn't encapsulation about enforcing the use of some interface?
20:14:15 <Cale> zapilla: Basic?
20:14:20 <zapilla> Cale: that's not typeless
20:14:26 <zapilla> it's just not strongly typed
20:14:38 <dibblego> AstralStorm, I challenge you to define encapsulation formally - it is 4 unedited pages for me so far
20:14:43 <weitzman> I'm gong to second AstralStorm's "pure untyped lambda calculus"
20:14:47 <weitzman> But it's not OO, which was the original question
20:14:48 <dibblego> I expect it to be around 25-30
20:14:57 <Cale> Well, weakly typed languages might as well be untyped.
20:15:08 <zapilla> Cale: why do you say that?
20:15:11 <weitzman> Perl also has some very...interesting typing
20:15:14 <AstralStorm> Cale: can't!
20:15:30 <zapilla> even pure maths is typed, in a way
20:15:31 <AstralStorm> dibblego: there's no definition and that's the problem.
20:15:38 <Cale> The types basically give you no ability to constrain anything.
20:15:39 <dolio> Ruby can be programmed in such a style that they type of any object is "the type that responds to all the methods that this object responds to."
20:15:47 <dolio> But that's not exactly typeless.
20:15:53 <zapilla> i think you're confusing the language with the runtime/compiler
20:15:55 <dibblego> AstralStorm, exactly - I offer a broad definition that I expect most (all?) will accept - then refute its co-existence with OO
20:16:12 <dibblego> AstralStorm, in fact, there is no definition of *many* things - it's all hyperbole
20:16:14 <AstralStorm> It should be a method of controlling what kinds of accesses to the given instance are permitted, and what aren't
20:16:18 <Cale> I'm not even considering the runtime/compiler here
20:16:18 <dibblego> even OO itself is nothing more than that
20:16:27 <Cale> Just what guarantees you have.
20:16:28 <dibblego> AstralStorm, requirement restriction in other words
20:16:37 <AstralStorm> Hmm... right.
20:16:40 <dibblego> when you go to the shop to buy a chocolate, you are not handed the universe
20:16:52 <dibblego> if you go to a supermarket, you are handed a lot - but the chocolate is cheaper
20:17:02 <weitzman> I'm sure I don't have permission for this, but...
20:17:04 <dibblego> if you go to a chocolate shop, you are handed a few chocolates, and it is more expensive
20:17:12 <weitzman> @remember dibblego when you go to the shop to buy a chocolate, you are not handed the universe
20:17:28 <dibblego> the point is, requirement leak *costs*
20:17:31 <AstralStorm> Now define the class shop while not breaking encapsulation? :>
20:17:52 <dibblego> AstralStorm, that's my point - you cannot - OO and encapsulation are in contradiction
20:18:05 <dibblego> AstralStorm, write *any* OO system and it *will* contain requirement leak
20:18:14 <dibblego> this is provable (I believe at least)
20:18:23 <AstralStorm> Good god. I've been using it broken! Good I turned to Haskell :>
20:18:26 <Cale> In a weakly typed language, I can't really ensure anything about the behaviour of a function from its type.
20:18:38 <weitzman> There is no programming language in use today which doesn't have a mismatch between programming language datatypes and programmer-intended datatypes
20:18:42 <weitzman> OO is no exception
20:18:42 <Cale> Or at least, I can ensure very little.
20:18:46 <weitzman> Nor is Haskell
20:18:47 <dibblego> AstralStorm, I have spent 230 hours with my boss on this very topic - he can no longer use OO
20:18:50 <zapilla> Cale: but that's different from it having no types!
20:19:05 <dibblego> AstralStorm, I work for a J2EE company (I used to work on the Java implementation for IBM)
20:19:07 <clanehin> I'm trying to grep the last few hours of conversation, but I'm unclear about the definition of requirement leak
20:19:38 <dibblego> AstralStorm, we are in trouble - the guy that runs the J2EE company can see a massive cost associated with OO after I spent countless hours showing it to him
20:19:40 <Cale> zapilla: almost the same. Types are theorems which are supposed to be machine checked at some point.
20:19:41 <AstralStorm> You can't be handed chocolate w/o knowing the price :>
20:20:05 <AstralStorm> And it really isn't necessary for chocolate itself to have such a "state"
20:20:11 <dibblego> I don't have a solution - I can only see the problem
20:20:50 <AstralStorm> The chocolate has no inherent price.
20:20:50 <Cale> zapilla: Dynamically typed means that they're checked at the last minute, while the program is running, statically means that they're proved at compile time.
20:20:52 <dibblego> I have been looking at FP languages for years thinking they solve some of these inherent problems, then dynamic typing came along (Ruby, Python) and I thought it was a nightmare
20:21:03 <zapilla> Cale: I'm aware of the difference
20:21:12 <zapilla> i don't know what that has to do with your assertion
20:21:15 <Cale> zapilla: Weakly typed means that you're allowed to bypass the theorems altogether
20:21:18 <dibblego> anyway, I was actually thinking of going to get some chocolate
20:21:25 <weitzman> You can't be handed chocolate without oxygen. It would be a shame to develop a store typing system and leave out the oxygen, such that all your program does is asphyxiate when you run it
20:21:25 * dibblego gone to get chocolate
20:21:35 <AstralStorm> Cale: only some of them - and you get no encapsulation whatsoever
20:21:38 <zapilla> Cale: yes, but that doesn't mean there is no types, it just refers to a lack of type checking
20:21:38 <Cale> So they don't even really mean anything anymore.
20:21:39 <AstralStorm> E.g. Python
20:21:48 <weitzman> Leaving out information without prohibitting it's use isn't necessarily a bad idea
20:21:59 <weitzman> s/it's/its/
20:22:03 <dibblego> there is one conclusion that makes OO legitimate - it must be observed from within a black hole (or where time cannot mutate)
20:22:10 <dibblego> pretty absurd really
20:22:35 <Cale> zapilla: I know that the implementation may need some concept of types, but the language itself might be able to get away with having none.
20:23:19 <Cale> If you're not enforcing the theorems anyway, why bother to state them at all?
20:23:33 <zapilla> because it makes it a helluva lot easier to write code
20:23:43 <Cale> They become at best a handy sort of comment.
20:23:47 <zapilla> in C, you can tell the compiler to shut up and basically let you do anything
20:23:53 <AstralStorm> Properly and provably working.
20:23:58 <zapilla> but, do you want to? probably not
20:24:14 <Cale> Oh, you mean weak in the sense of having to ask.
20:24:19 <zapilla> no
20:24:23 <zapilla> C is weakly typed
20:24:27 <zapilla> you can do casting
20:24:45 <Cale> Well, it's somewhere in between.
20:24:50 <zapilla> but that doesn't preclude it from having type checking (it's also statically typed)
20:24:56 <AstralStorm> But it's statically typed.
20:25:04 <zapilla> it's just that you can bypass the type checking if you want
20:25:11 <zapilla> you just shouldn't want, most of the time
20:25:14 <weitzman> Not that I want to start a debate about what, "weak," means, but... Well, yeah, I was about to start that debate actually
20:25:21 <AstralStorm> Mhm, void* casts and other.
20:25:40 <Cale> There are languages which don't even bother allowing you to specify the types in the first place though.
20:25:42 <zapilla> basically, if you can cast
20:25:43 <zapilla> it's weak
20:25:50 <Cale> and do all casting automatically
20:25:58 <weitzman> So I could write a static an operational semantics for C which describes how casting in C works
20:25:59 <AstralStorm> casting != conversion
20:25:59 <zapilla> no, there's a difference
20:26:05 <weitzman> And the language would be consistent with the semantics
20:26:05 <Cale> or conversion
20:26:07 <zapilla> python has no type annotation
20:26:08 <weitzman> And it's well typed
20:26:10 <zapilla> but it's strongly typed
20:26:12 <weitzman> And what's the problem?
20:26:23 <zapilla> with haskell, you can have no type annotation
20:26:28 <zapilla> and that's strongly typed and statically typed
20:26:47 <dmwit> > 51 * 51 + 68 * 68 == 85 * 85
20:26:48 <lambdabot>  True
20:26:52 <weitzman> Even statically-typed languages we use today aren't "good enough" to do all checking at compile time
20:27:01 <AstralStorm> _can_ - because of strong and static typing you can infer the type
20:27:08 <Cale> zapilla: I'm familiar with these examples :)
20:27:31 <AstralStorm> Should they be good enough, we'd have a Turing's oracle
20:27:52 <AstralStorm> A method for checking if an algorithm finishes or not
20:27:57 <weitzman> You could implement python in Haskell and evaluate a python expression safely
20:28:07 <weitzman> And then is your haskell suddenly not statically typed?
20:28:31 <zapilla> weitzman: eh, what?
20:28:33 <weitzman> To me, it's a fruitless debate
20:28:44 <AstralStorm> You can't implement Python in Haskell... only a Python interpreter :P
20:29:04 <weitzman> If I implement a dynamically-typed language in Haskell and use haskell expressions to construct a dynamically-typed statement, then run it
20:29:11 <weitzman> Is haskell no longer statically typed?
20:29:28 <weitzman> And if it is, then isn't python statically typed? Since it would do the same thing as my code
20:29:32 <AstralStorm> How bounded is the dynamicism?
20:29:48 <AstralStorm> No, there's no such thing as full dynamism.
20:30:03 <zapilla> weitzman: sure, you can have statically typed python
20:30:09 <zapilla> if you implement a static checker for it
20:30:12 <AstralStorm> RPython? :>
20:30:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
20:30:15 <weitzman> I don't need a static checker
20:30:18 <lambdabot> http://tinyurl.com/fmmvy
20:30:19 <weitzman> I'm implementing pythong
20:30:20 <zapilla> you can do this by implement it in haskell
20:30:31 <weitzman> Are you saying that python can't be implemented in Haskell?
20:30:32 <Cale> Why not just implement a Dynamic type?
20:30:39 <AstralStorm> It can.
20:30:44 <Cale> Why a whole sublanguage?
20:30:47 <dibblego> are types intrinsic to software?
20:31:06 <zapilla> weitzman: hell no
20:31:07 <AstralStorm> dibblego: in RL they're called kinds
20:31:08 <weitzman> The whole sublanguage is just an extreme way to make the point that statically-typed does not mean easy to reason about
20:31:24 <weitzman> Nor does dynamically typed necessarily mean hard to reason about
20:31:32 <weitzman> Nor does OO necessarily mean broken
20:31:51 <AstralStorm> dibblego: arbitrary distinctions between items
20:31:54 <dibblego> types cannot be unlinked from software; the problem is it is not easy to compose a formal expression of the requirement for software - so instead we replace that with "types" (or contracts)
20:31:54 <Cale> statically typed means that the compiler proves some theorems about your program before it is run
20:31:55 <weitzman> It's not the size of the thing, it's how you use it
20:32:03 <Cale> Those theorems might not say much :)
20:32:16 <dibblego> I use "type" to mean "formal expression of requirement" - which is an axiom of software
20:32:24 <weitzman> So the problem is that you want the *right* theorems
20:32:25 <dibblego> remove "type" and you remove "software"
20:32:55 <AstralStorm> You mean the "OO type", that's right
20:32:55 <weitzman> And we don't have languages that make any guarantees about how useful their compilers are at proving valuable theorem
20:33:14 <dibblego> I mean any type actually
20:33:31 <dibblego> (or contracts, or function definitions or classes or dynamicity)
20:33:44 <weitzman> Part of the problem with any proof-based system is that you have to be sure that you're proving the right thing
20:33:46 <Cale> Well, you can't or at least don't want all of the theorems. Just as much as possible without making it impossible to write a compiler :)
20:33:50 <AstralStorm> Well, there are real-life contracts :P
20:34:07 <AstralStorm> These are all models designed by buisness-minded mathematicians :P
20:34:27 <dibblego> they are rarely (ever?) expressed formally
20:34:35 <dibblego> always using a horrible ambiguous language called English
20:34:35 <Cale> and I suppose there are some constraints about how easy it is for the programmer to give the compiler enough information to compile the program
20:34:58 <AstralStorm> dibblego: do you have a formal definition of a real contract? (I mean non-software)
20:34:58 <dibblego> there are people working on the English -> Z (or whatever) compiler
20:35:15 <dibblego> AstralStorm, yes, in fact, it includes what you referred to earlier (Turing's Oracle)
20:35:23 <weitzman> I'm willing to assume we have a hypothetical compiler that will infer any property you can express clearly in English to a CS professor
20:35:32 <AstralStorm> dibblego: uhh... bad :/
20:35:48 <dibblego> AstralStorm, it is required unless you fix time
20:35:58 <dibblego> Turing said so, not me
20:36:12 <AstralStorm> I know.
20:36:22 <dibblego> is algorithmic complexity part of a contract?
20:36:39 <dibblego> "that it returns some value before the collapse of space/time itself"?
20:36:43 <AstralStorm> The real one? sometimes - I mean the time of execution
20:36:49 <dibblego> or "that it returns some value before tomorrow"?
20:36:53 <weitzman> I feel like there are some problems with uncomputability
20:36:58 <AstralStorm> Might be...
20:37:08 <dibblego> AstralStorm, now prove you have met the contract
20:37:24 <dibblego> AstralStorm, better still, meet the contract first
20:37:27 <AstralStorm> I have done x before the stated time
20:37:47 <AstralStorm> You can't know whether something will meet the contract :>
20:37:50 <dibblego> yes, but that only holds for one point in relative time
20:38:00 <AstralStorm> That's a runtime error - and then comes the vindicator :P
20:38:01 <dibblego> sure you can - a compiler verifies this
20:38:15 <weitzman> If you're going to start making propositions about runtime, you need to take into account the whole operating system and all software running on it
20:38:17 <dibblego> the runtime assumes mutable time - it cannot even fail it
20:38:26 <dibblego> why are "endless loops" endless?
20:38:34 <dibblego> weitzman, yes, another axiom of software
20:38:42 <AstralStorm> Because there are no inherent time constraints.
20:38:48 <dibblego> software assumes some contracts are provided by hardware, etc.
20:38:51 <AstralStorm> There should be.
20:39:02 <dibblego> AstralStorm, so you suggest timing it out?
20:39:15 <AstralStorm> More or less.
20:39:34 <dibblego> AstralStorm, what if there are infinite inputs, and I just happen to pass a large one that takes longer than your timeout?
20:39:54 <AstralStorm> I know it's impossible :P
20:39:55 <dibblego> or should infinite inputs not be possible? (which means Haskell's list is broken)
20:40:25 <AstralStorm> The algorithm can "know" its complexity
20:40:28 <weitzman> Infinite inputs are useful for network services
20:40:31 <dibblego> AstralStorm, hence, we need to mention Turing's Oracle to define a contract :)
20:40:42 <AstralStorm> Unfortunately :>
20:41:10 <dibblego> AstralStorm, like I said, I am writing a book that I hope to put all this stuff to rest - for a layperson audience :)
20:41:29 <weitzman> And some algorithms don't have complexity, at least as we traditionally measure it
20:41:30 <AstralStorm> Well, how can you know the complexity of an algorithm before launching it? At least for some it's impossible :P
20:41:56 <AstralStorm> That's why Turing's Oracle is so tightly bound to NP complexity class
20:42:18 <dibblego> weitzman, computational progression demands that a contract is invoked at some point in time then returns at some other point in time after time of invocation and before (we hope) the collapse of space/time
20:42:43 <monochrom> If your program produces 1 output, you will not only specify how much time, but also how much of the input is used.
20:43:02 <dibblego> if you do not use all of the input, you have leaked
20:43:05 <weitzman> So you could write an assumption in your proof: "There's no way this server is going to be able to stay up for longer than, say, 100 years"
20:43:12 <weitzman> But that seems silly to me. What if you're wrong?
20:43:17 <AstralStorm> Also the exact input :P
20:43:22 <dibblego> <title>Object-Oriented Programming</title>
20:43:23 <dibblego>   <subtitle>A critical analysis using the Java programming language</subtitle>
20:43:28 <AstralStorm> E.g. factorial 1 is shorter than factorial 1024
20:43:39 <AstralStorm> shorter = less complex
20:43:43 <monochrom> If your program produces infinitely many outputs, like a network service, you will specify those per output.
20:43:46 <AstralStorm> Even though unit runtime is same
20:44:39 <AstralStorm> monochrom: so an infinite loop is still possible, but harder to achieve :>
20:44:46 <weitzman> And then there are algorithms were we don't know how many outputs they may have
20:44:50 <AstralStorm> A combination of proper sender/receiver
20:45:13 <weitzman> We might want to run a batch job trying the collatz function to see if it ever doesn't halt
20:45:16 <monochrom> For example, lambdabot is intended to run forever and take infinitely many inputs from this channel.  But that does not mean after you have issued "@pl \x->x" you allow it infinite time.
20:45:19 <weitzman> And if it turns out it does, then, well, it won't
20:45:26 <weitzman> *s/does/doesn't/
20:45:41 <monochrom> Nor do you allow it to wait for more input.
20:45:45 <weitzman> Plus, even if it does, you never stop
20:45:55 <AstralStorm> monochrom: but you can't parse infinite data with it :P
20:46:09 <AstralStorm> It returns no result.
20:46:12 <weitzman> So you just have some infinitely running job, you don't know if it will ever have output
20:46:32 <AstralStorm> > map (\x -> x+1) [1..]
20:46:34 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:46:57 <AstralStorm> It only knows about simple cases.
20:47:02 <AstralStorm> > even [1..]
20:47:03 <lambdabot>  add an instance declaration for (Integral [a])
20:47:03 <lambdabot>   In the definition of `ww...
20:47:05 <monochrom> So here is a likely contract for lambabot: for each input, produce output in 1 unit of time.
20:47:11 <AstralStorm> > map even [1..]
20:47:12 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
20:47:23 <AstralStorm> Hmm, give it something harder.
20:47:38 <AstralStorm> monochrom: it disallows long computations.
20:47:43 <weitzman> What would be the contract for a program the check if it's input is a halting Turing machine?
20:47:51 <weitzman> */it's/its
20:48:13 <AstralStorm> > let fact x = x * (x - 1) in fact; fact 0 = 1
20:48:14 <lambdabot>  Parse error
20:48:25 <AstralStorm> > let fact x = x * (x - 1); fact 0 = 1 in fact
20:48:26 <lambdabot>  Add a type signature
20:48:52 <monochrom> You can write down any contract.  Whether you can find a vendor is another story.
20:49:01 <AstralStorm> > let fact x = x * (x - 1); fact 0 = 1; map fact [1024..]
20:49:01 <lambdabot>  Parse error
20:49:05 <AstralStorm> Blah.
20:49:33 <weitzman> Well, bad contract comes right back to the original problem. Contracts are written by programmers, and they might not be correct
20:49:42 <weitzman> Static typing or not
20:49:59 <AstralStorm> Incorrect contracts allow infinite algorithms.
20:50:11 <AstralStorm> *infinite-runtime
20:50:17 <weitzman> Why is an infinite algorithm necessarily wrong?
20:50:21 <AstralStorm> And/or infinite-output
20:50:28 <AstralStorm> It isn't :>
20:50:42 <weitzman> Well then why disallow them?
20:50:43 <AstralStorm> Algorithm is ok, but we don't know whether it finishes.
20:50:53 <AstralStorm> And when, if so.
20:51:11 <weitzman> The are other problems we have. We don't know how long a disk read takes
20:51:16 <weitzman> Depends on physics
20:51:20 <weitzman> Are we on a plane?
20:51:22 <AstralStorm> That too.
20:51:23 <weitzman> Are we shaking the machine?
20:51:34 <AstralStorm> Are we having a disc really? :P
20:51:41 <Pseudonym> How strong is the gravitational field?
20:51:47 <monochrom> A contract is less likely to cause information overload.  If it has a problem, it's easier to find out.  Code is too spaghetti.
20:52:07 <AstralStorm> Define what does "a contract" mean.
20:52:17 <weitzman> Can a contract be probabilistic?
20:52:23 <AstralStorm> Define a contract for defining contracts.
20:52:24 <AstralStorm> :>
20:52:47 <monochrom> A contract can be probabilistic, if you know the right math for that.
20:53:00 <AstralStorm> ^
20:53:32 <monochrom> Probabilistic contracts are still under research.
20:53:39 <weitzman> So for example, "If you run this program infinitely many times, 9 out of every 10 it will do what it's supposed to"
20:53:41 <AstralStorm> I mean "define a contract for defining contacts which define contracts"
20:53:45 <weitzman> That's a nice contract
20:54:09 <AstralStorm> But how do you check if it's real? :P
20:54:24 <monochrom> But you end up never running the program infinitely many times.
20:54:24 <weitzman> Well, the program will have to take a random data source as input
20:54:31 <AstralStorm> When you hit the infinite case, you're screwed :P
20:54:37 <weitzman> And it must probably use the random data source
20:54:55 <weitzman> *provably
20:55:08 <monochrom> If the program relies on the disk, and the disk has a known probability of success, you're game.
20:55:24 <AstralStorm> How do you measure it?
20:55:25 <AstralStorm> :P
20:55:32 <AstralStorm> Huh?
20:55:44 <AstralStorm> With which algorithm?
20:55:45 <weitzman> Well, I don't think probability will scale well to hardware
20:55:52 <weitzman> But it would be useful for randomized quicksort, for example
20:56:04 <weitzman> Or primality testing
20:56:42 <AstralStorm> You can't know when a disc will fail until it does.
20:56:44 <AstralStorm> :P
20:56:59 <AstralStorm> You can only predict it, sometimes.
20:57:04 <weitzman> AstralStorm: Well, you contract could include a model of real-world physics
20:57:12 <weitzman> AstralStorm: And a proof that the model is correct...
20:57:27 <weitzman> Assuming determinism
20:57:33 <AstralStorm> Yes, prove that current physics is equivalent to the real world.
20:57:41 <AstralStorm> :>
20:57:48 <monochrom> Suppose the disk has a success probability of 50% for reading.  Here is a program that has a success probability of <=10% for reading the disk: read 4 times.
20:57:49 <AstralStorm> And that we know everything.
20:58:22 <AstralStorm> And limes 0%
20:58:25 <weitzman> The probability of the disk read succeeding depends on whether or not the computer has been knocked over
20:58:39 <AstralStorm> But when do you hit 0% actually?
20:58:40 <weitzman> We can't know in advance
20:58:41 <AstralStorm> :P
20:58:49 <monochrom> OK, yes of course you always need working assumptions.
20:59:04 <AstralStorm> Every disc has 0% success probability in a long term.
20:59:18 <AstralStorm> And you can't exactly know how long one :>
20:59:39 <AstralStorm> <tongue in cheek> unless you're psychic
20:59:56 <monochrom> So here is the way you write your contract to cover your butt:  IF the disk's probability is >=50%, THEN my program's probability is >=90%; no guarantee otherwise.
21:00:13 <AstralStorm> But it's a condition.
21:00:22 <AstralStorm> What does "no guarantee" mean?
21:00:27 <AstralStorm> Infinite working time?
21:00:28 <weitzman> That amounts to a self-referential contract. "If this contract is the appropriate one, we're all set"
21:00:35 <monochrom> You can always write conditional contracts, and your lawyers will wisely advice you to always do so.
21:00:51 <AstralStorm> What does "no guarantee" mean in software?
21:01:00 <monochrom> No lawsuit.
21:01:05 <AstralStorm> Does it mean "format my disc"?
21:01:06 <AstralStorm> :P
21:01:27 <AstralStorm> Or maybe just a crash...
21:03:24 <monochrom> Whether a contract is reasonable or not is still up to the stakeholders.  "if the hardware works (not my duty) then my program works (my duty)" is widely accepted as reasonable.  "if my program works then my program works" is widely regarded as unreasonable.  There is grey area but there is also unanimous consensus in most cases.  In the end it is a judgement call, and you ask the stakeholders for the call.
21:03:29 <AstralStorm> It doesn't even mean "something will happen"
21:03:47 <AstralStorm> How then you know that the disc probability is >=50%?
21:04:12 <monochrom> Some disk engineer will have to determine that.
21:04:22 <AstralStorm> You mean "guess and vouch"
21:04:53 <monochrom> You can elaborate and specify which model you assume when estimating disk probability.
21:05:19 <AstralStorm> You design a contract knowing it'll be broken.
21:05:20 <AstralStorm> :>
21:05:34 <monochrom> There must be domain-specific knowledge that a software engineer lacks and must rely on other experts.
21:05:34 <AstralStorm> Given enough discs.
21:06:23 <newsham> hi
21:07:07 <AstralStorm> The logical conclusion is then: all contracts are broken in spe
21:07:08 <monochrom> If you write software for a nuclear power station, you must believe the nuclear physicists when they say "xxx grams is the critical mass".  How do they know it's xxx not xxx-1?  Well that's their expertise.
21:07:20 <AstralStorm> Unless finalised.
21:08:43 <AstralStorm> People tend to write things wrong.
21:09:20 <AstralStorm> An elevator for 0.4t can be written as 4t
21:09:30 <AstralStorm> Guess what will happen :P
21:09:36 <AstralStorm> Design a contract to prevent that :P
21:10:14 <AstralStorm> The problem with software definition of contract is it's assumed to be unbreakable.
21:10:15 <monochrom> People tend to write things wrong.  But that's misleading because you are not comparing it with the alternative: not writing the contract.
21:10:50 <monochrom> If you write down 4t, there is 5% probability someone else will notice it.
21:11:05 <AstralStorm> 0.00005%
21:11:06 <monochrom> If you don't even write it down, the probability is zilch.
21:11:13 <AstralStorm> Because it's not their area of expertise
21:11:18 <AstralStorm> :P
21:11:35 <AstralStorm> Ok, I'm away for now :>
21:11:41 <monochrom> Well get a peer with similar expertise to go over.
21:12:05 <monochrom> But even 0.00005% is better than zilch.
21:12:57 <AstralStorm> The probability of somebody falling down with 0.75t before anyone notices the mistake is much higher.
21:14:02 <monochrom> For life-critical contracts you get a lot of experts to cross-check each other.
21:14:45 <glguy> What philosophical discussion are you  two having?
21:14:52 <AstralStorm> None. :>
21:15:00 <monochrom> "Should we write down contracts?"
21:15:13 <AstralStorm> The original idea is
21:15:20 <AstralStorm> "... in software"
21:15:41 <glguy> > ()
21:15:42 <lambdabot>  ()
21:16:15 <glguy> Do you mean legal contracts, or software interfaces?
21:16:37 <monochrom> How about unifying the two?
21:17:26 <glguy> I suppose that would be the ultimate in dynamic typing
21:18:19 <glguy> Contracts are important if you want to refuse payment when someone doesn't do what they said they would tho
21:18:33 <glguy> oh well, looks like I got in late
21:18:36 <glguy> I'll let it go
21:19:42 <glguy> What makes parsec more efficient than read?
21:20:00 <monochrom> parsec throws away ambiguous parses.
21:20:02 <dons> its more efficient
21:20:10 <glguy> dons: stfu :)
21:21:09 <glguy> Also, are there reasons other than historic ones that Haskell doesn't use parsec for "read" then?
21:21:16 <dons> glguy: oh, I have a job for you...
21:21:27 <dons> could you add an entry to http://haskell.org/haskellwiki/Programming_contests
21:21:30 <dons> please ? :)
21:21:31 <lambdabot> Title: Programming contests - HaskellWiki, http://tinyurl.com/hs57e
21:21:52 <dons> no, its just historical
21:21:57 <dons> there's a plan to replace read for Haskell'
21:22:55 <glguy> dons: I'll add the entry
21:26:06 <newsham> dons: I dont think you could quickcheck a PRNG for bias easily..
21:27:15 <glguy> How do I markup a quote from mathschallenge.net describing what project euler is?
21:30:09 <glguy> dons: also, do you think that it makes sense for SPOJ to have a separate wiki entry?
21:31:12 <dons> newsham: yeah I'm pondering.
21:31:33 <dons> glguy: i'm not sure. it was already there, so i just linked to it. but that page coudl well disappear
21:31:52 <newsham> though this seems like something you could formally prove pretty easily.
21:31:57 <newsham> if you wanted higher assurances.
21:32:29 <glguy> dons: either way, I have added Project Euler to the list for you (any luck on GHCI on OpenBSD? (c: )
21:33:10 <dons> i'll get to it soon enough
21:33:37 <newsham> ghci dont work in openbsd?
21:34:30 <dons> in a recent kernel some symbol has been introduced that breaks the runtime linker. should be easy to fix
21:34:41 <dons> just need to get hold of a 4.0 machine
21:34:57 <glguy> I'd give you an account on one of mine :)
21:35:03 <AI_coder> Where do haskell programmers share code at?
21:35:09 <newsham> vmware > *
21:35:11 <AI_coder> C programmers shouldn't have all the fun.
21:35:28 * glguy is creating a virtual pc image as we speak as well to verify that it fails on new installs
21:35:35 <dons> AI_coder: share code?
21:35:52 <dons> you mean, like via darcs? you could start at http://haskell.org -- lots of code there
21:35:55 <lambdabot> Title: Haskell - HaskellWiki
21:37:30 <AI_coder> somewhere haskell projects are talked about and worked on.
21:37:50 <newsham> irc?  wiki?
21:38:02 <glguy> projects?
21:38:12 <dons> start on haskell.org 'libraries and tools' to find them. most dev work is done on haskell-cafe@haskell.org mailing list, here in irc, and on the haskell.org wiki
21:38:43 <dons> AI_coder: http://haskell.org/haskellwiki/Libraries_and_tools
21:38:46 <lambdabot> Title: Libraries and tools - HaskellWiki, http://tinyurl.com/j6sf3
21:41:17 <newsham> dons: would TH be a good solution to do "map C.pack" at compile-time to ensure optimized packed storage?
21:41:36 <glguy> I want to install OpenBSD on a PowerMac so I can call it "openapple" (like they old apple IIe key)
21:42:03 <dons> hmm. TH is too heavy
21:42:33 <dons> generally, you don't have big lists of strings anyway, so its probably not too much of an issue
21:43:37 <glguy> What sort of problems exactly is TH designed to address?
21:44:29 <newsham> seems like the kind of thing you'd do with a lisp macro (which is analogous to th, right?)
21:44:33 <dons> compile time code generation
21:44:42 <newsham> printf is dne using TH, right?
21:44:53 <dons> newsham: yeah, or a special mapPack HOF, perhaps?
21:45:04 <dons> yep, you _can_ do it that way
21:45:19 <newsham> or more generally a compile-time map?
21:45:20 <dons> the library printf uses an interpreter embedded in the class system, though
21:45:42 <dons> right. you certainly could use TH, but its a heavy dep to haul in
21:45:47 <dons> for this problem
21:46:14 <newsham> *nod*
21:47:00 <glguy> dons: is the openbsd issue something that you could just tell me where to look and I could address it? or is ist something that you are going to have ot  figure out first?
21:48:29 <dons> yes, I suspect you just have to add the missing symbol to the Linker.c file in ghc's rts/ dir
21:48:39 <dons> there's a list of other C symbols that are expected to be in scope there
21:49:06 <dons> you'd have to add the symbol, rebuild the rts, and relink the compiler stage2, then try ghci again
21:49:29 <dons> possibly itwould have to be in a openbsd #ifdef
21:49:33 <dons> (examples in that file elsewhere)
21:49:38 <glguy> ok
21:50:09 <glguy> so something like Sym(__errno) in the correct place?
21:50:28 <glguy> or maybe SymX(__errno)
21:50:37 <dons> right
21:50:52 <dons> there's some different, check the defns of the two macros for which one is which
21:51:02 <glguy> ok
21:51:10 <dons> I think one adds leading __ ?
21:51:21 <glguy> I'll look for the definition
21:52:01 <glguy> #define Sym(vvv) { MAYBE_LEADING_UNDERSCORE_STR(#vvv), \ (void*)(&(vvv)) },
21:52:01 <glguy> #define SymX(vvv) Sym(vvv)
21:52:16 <dons> oh
21:55:30 <glguy> would __errno be in RTS_POSIX_ONLY_SYMBOLS?
21:56:25 <dons> well, its no a windows sym, so yes. and even then I think an openbsd ifdef would be a good idea
21:56:33 <glguy> kk
21:56:48 <dons> the defined(openbsd_HOST_OS)
21:56:54 <glguy> right
21:57:43 <glguy> which sym line would you suggest I try?
21:58:08 <glguy> SymX(__errno) like cygwin has?
21:59:58 <dons> yep, that'd be a good start
22:00:44 <glguy> I changed it and went back to the root soruce directory and did a `gmake`
22:02:07 <glguy> I might need to gmake clean first
22:02:36 <dons> you'll need to remove the stage2/ghc-* binaries
22:02:45 <dons> which will force them to be relinked, after you've rebuilt the rts
22:02:53 <dons> (no need to gmake clean -- too much effort)
22:05:09 <glguy> huzzah, new error: unknown symbol sigemptyset
22:05:37 <glguy> but I remember that somewhere else there is a special case for openbsd's sigemptyset
22:06:37 <dons> right. now that might either not exist or be in some other place?
22:06:42 <dons> possibly you'll just have to add it
22:06:55 <dons> but good work! see, ghc's not so hard :)
22:06:59 <dons> glguy++
22:07:21 <glguy> and the VirtualPC install i just did failed too
22:07:28 <glguy> ghci doesn't work on a fresh snapshot install
22:07:49 <dons> no, it would be broken in ports, I presume. but at least ghc's there (and hugs)
22:08:05 <dons> but too late now, anyway. 4.0 is done.
22:08:08 <glguy> I just wanted to prove that I didn't screw up my machine
22:08:21 <dons> we can just make sure that when I put up a 6.6 snapshot on haskell.org/ghc, it'll run
22:08:50 <glguy> How does 6.6's strict argument notation relate to Clean?
22:09:05 <newsham> you could just install an OS that works, like freebsd ;-)
22:09:06 <dons> its has simlar notation, but for different effect
22:09:15 <dons> newsham: the OS works fine.
22:09:21 <newsham> debatable.
22:09:36 <glguy> huzzah, new error!
22:09:43 <dons> where works = does everything you need, then I don't even think its debatable :)
22:09:49 <dons> good.
22:09:58 <dons> I'd expect a bunch of syms to need to be fixed
22:10:14 <dons> but they'll drip out one at a time.
22:10:20 <glguy> right
22:10:30 <glguy> sigfillset was also special cased for openbsd somewhere else
22:10:53 <dons> ah right
22:11:14 <glguy> I'll have to track that down again
22:11:44 <dons> maybe in the signals library?
22:11:55 <dons> package unix
22:11:58 <glguy> memcpy now
22:12:17 <glguy> i wonder if this is going ot go through all of the symbols
22:12:19 <newsham> find . -type f -print0 |xargs -0 grep -i "$@"   is your friend
22:12:20 <dons> hmm
22:12:40 <dons> could be that we need to load the libc differently
22:12:54 <dons> (see there's some special code for getting this stuff in scope, maybe that's what changed)
22:12:58 <glguy> That's what I'm thiking, because otherwise this is going to look like CYGWIN's special case
22:13:00 <dons> look for openbsd further in Linker.c
22:13:15 <wkh> i know a smart kid who graduated high school
22:13:25 <wkh> he took a programming class where all they used was java
22:13:28 <dons> there's some stuff that was a work around to get libc loaded. maybe the semantics have changed
22:13:29 <wkh> now he hates programming :/
22:13:30 <glguy> openBSD is special cased in lookupSymbol
22:14:01 <glguy> everyone else uses dlsym(dl_prog_handle,lbl);
22:14:17 <dons> yep. I added that to get ghci working in the first place.
22:14:20 <glguy> while openbsd does a test for NULL
22:14:24 <glguy> k
22:14:25 <dons> but maybe our dyn linker is better now?
22:14:59 <glguy> well... the special case seems to only use dl_libc_handle instead of dl_prog_handle for dlsym in the NULL case
22:15:05 <dons> you might want to peek around there, and the stuff that explicit gets at libc:
22:15:07 <dons> #if defined(openbsd_HOST_OS)
22:15:07 <dons> static void *dl_libc_handle;
22:15:07 <dons> #endif
22:15:16 <glguy> OK, that sounds familiar
22:15:27 <dons> #   if defined(openbsd_HOST_OS)
22:15:27 <dons>     dl_libc_handle = dlopen("libc.so", RTLD_LAZY);
22:15:27 <dons> #   endif
22:15:33 <glguy>     dl_libc_handle = dlopen("libc.so", RTLD_LAZY);
22:15:36 <dons> maybe that's changed somehow in 4.0
22:15:48 <dons> since it was rather odd to have to do it previously
22:16:10 <dons> so maybe it doesn't work anymore...
22:17:41 <glguy>      dlctl() provides an interface similar to ioctl(2) to control several as-
22:17:41 <glguy>      pects of the run-time linker's operation.  This interface is currently
22:17:41 <glguy>      under development.
23:01:52 * edwardk waves hello.
23:02:30 <edwardk> Anyone out here in ICFP-land awake and bored?
23:02:30 * boegel waves goodbye and leaves for bed
23:02:49 <boegel> edwardk: I'm bloody tired, that's what I am :)
23:02:50 <boegel> so bye !
23:02:53 <edwardk> heh
23:02:57 <edwardk> not a problem
23:02:59 <edwardk> =)
23:04:05 <dons> i'd love a small report on how the HW went... for the HWN today...
23:04:08 <dons> edwardk: up for it/
23:04:11 <dons> ?
23:04:35 <dons> i.e. 10 papers, 1 or 2 sentences each. and a smaller paragraph on the discussion?
23:04:43 <edwardk> hrmm
23:05:28 <edwardk> Trying to think. I've been out of haskell mode and in substructural mode for a few hours, trying to revert my thinking =)
23:05:56 <dons> basically just take the schedule, http://article.gmane.org/gmane.comp.lang.haskell.general/14104
23:06:01 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/nb4yx
23:06:07 <dons> and write 1 or 2 sentences on each item? :)
23:06:23 <edwardk> heh. sadist
23:06:37 <dons> well, i can't very well write it. -- i'm not there!
23:08:05 <edwardk> Stephanie Weirich presented a neat library for generic traversals, and may have even stopped to take a breath at one point during her talk.
23:08:46 <dons> heh
23:09:33 <dons> edwardk: can you think of any papers that might very well go in http://haskell.org/haskellwiki/Research_papers/Top_10
23:09:35 <edwardk> It covered just about everything except GADTs, existentials universals, and kigher-kinded parameters, and seemed pretty painless to use.
23:09:37 <lambdabot> Title: Research papers/Top 10 - HaskellWiki, http://tinyurl.com/l2blg
23:09:39 <dons> i'm wondering if i've though of everything
23:09:47 <dons> oh cool.
23:10:02 <dons> maybe i can get someone to summarise the workshop for next week's HWN then...
23:10:28 <edwardk> deling ren talked about another generics library, but went kind of the opposite direction on the usability front, parameterizing everything you could possibly want to do with a traversal..
23:10:59 <dons> how was Phil's kernel talk?
23:11:06 <smug> http://galleries.babes.tv/hg/content/stacysilveranal/pics/02.jpg
23:11:07 <edwardk> had a neat core 'mother traversal' that abstracted over different data structure traversals
23:11:09 <lambdabot> http://tinyurl.com/kvn9k
23:11:20 <edwardk> really good actually.
23:11:24 --- mode: ChanServ set +o dons
23:11:28 --- kick: smug was kicked by dons (dons)
23:11:32 --- mode: ChanServ set -o dons
23:11:39 <dons> oh good
23:12:48 <edwardk> alexandra silva presented 'yet-another-haskell-database' paper. not sure I would commit those words to print, but basically it was using the type system to encode not only the types of fields it was joining, but a bit more about their meaning and role in the key.
23:14:59 <edwardk> koji kagawa did a paper on polymorphic variants, that oleg more or less ripped apart. The resulting type system extensions had a somewhat confusing syntax that didn't do anything for me, and I'm not sure it introduced anything that couldn't be done in OOHaskell. Again not words I'd probably commit to print ;)
23:15:31 <dons> he ok. i might wait for a prepared summary then for next week's HWN :)
23:16:51 <edwardk> Dana Xu gave a great talk on ESC/Haskell, and proving the partial correctness of programs with compile time checks for pre/postcondition violations, using an external theorem prover to prove bits about arithmetic expressions, and unfolding loops a few times to see if you could prove that the invariants hold
23:17:25 <edwardk> it even had stuff for providing a trace of how you might reach the invariant violation, etc.
23:17:28 <edwardk> very practical stuff
23:17:41 <dons> excellent
23:17:55 <dons> edwardk: would you like me to use these comments for today's HWN?
23:18:35 <aleator> Hello. Are there any known floating point bugs in semirecent cvs versions of ghc? (where do I find this out)?
23:18:47 <edwardk> you can. I'll provide more diplomatically worded ones for the other papers I said not to quote me on ;)
23:18:57 <dons> ok.
23:19:05 <alar> @type ($)
23:19:06 <lambdabot> forall b a. (a -> b) -> a -> b
23:19:33 <alar> @hoogle a -> (a->b) -> b
23:19:35 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
23:19:35 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:19:35 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
23:19:37 <dons> aleator: there are known issues with floating point, in general, in computer science. ghc does have particular flags to deal with this, -fexcess-precision, and there's some docs about C versus asm backends, and their floating code
23:19:39 <edwardk> The microkernel paper was really good. Before I saw the talk I really questioned the judgement of prototyping a microkernel in Haskell. Now I want to go prototype one myself. =)
23:21:23 <dons> heh
23:21:26 <edwardk> Iavor did a presentation on how you could extend the type system to incude an extra kid for physical memory regions and data representations in memory, with endianness, etc. He implemented it in a kind of strict pseudo-haskell, but the general notation was pretty clean and would be usable for system level programming in Haskell.
23:21:33 <edwardk> er extra kind
23:23:32 <dons> ok. that gets us to lunch
23:23:35 <dons> what about after lunch? :)
23:23:35 <edwardk> Peter Thiemann wrote on generalizing the interface for STM to other kinds of database and user-interface transactions, where he gave up the ability to automatically retry blocking on a changeset of TVars to get a kind of transaction that could actually fail and be manually retried. He ran out of time before he got to the user-level transaction stuff.
23:23:45 <aleator> dons: Yeah, but anything unexpectantly explosive and ghc specific?
23:24:00 <dons> ok.
23:24:08 <dons> aleator: not that i'm aware of
23:24:44 <aleator> dons: thanks. What does using realToFrac to go between cdouble and double cost me?
23:26:13 <dons> aleator: it's 'id' I think.
23:26:24 <aleator> I have a code that just sums up pixels of an image.. And it mostly gives a correct result, but when launching many instances of the program at the same time, it sometimes goes off by order of a magnitude. (No io. but some ffi code..)
23:26:26 <edwardk> Simon Marlow presented an extensible exception hierarchy using type classes. Oleg, of course mentioned a way that his 'devils advocate' approach could actually be used instead. I slapped together a version with a little less boilerplate, that I'm going to hand back to him when I see him next. (You can omit the I slapped together comment) =)
23:26:49 <dons> ok
23:27:02 <dons> so now the demos.
23:27:13 <dons> Lemmih was sick, I think? so did we see the debugger demo?
23:27:15 <edwardk> David Himmelstrup wasn't there. The schedule got shifted around a bit at that point
23:27:16 <edwardk> yeah
23:27:18 <edwardk> no demo
23:28:03 <dons> ok, Andy Gill did the reasoning assistant?
23:28:36 <edwardk> Andy Gill came in and did a really neat, high energy, demo of an interactive equational reasoning/code refactoring tool. I would hire him as a motivational speaker in a second. He actually loaded up the application and showed it refactoring some list code, etc.
23:28:54 <dons> ok nice.
23:29:15 <dons> And then kowey talked about natural languages?
23:29:29 <Pseudonym> I've never met Andy Gill, but I really like his code style.
23:29:39 <dons> Pseudonym: example?
23:29:54 <Pseudonym> Uhm... MTL?
23:30:01 <dons> ah :)
23:30:16 <Pseudonym> Very clean.
23:30:35 <edwardk> kowey covered genI and gave a user's level overview of the features in haskell that are useful in real code. I pretty much agreed with everything he had to say, nothing too surprising. Though the natural language generation stuff there was pretty nifty in its own right.
23:31:36 <dons> then frederik gave a demo?
23:32:34 * lispy waves
23:32:37 <lispy> ya
23:32:46 <dons> hey lispy.
23:32:54 <edwardk> _frederik_ covered a linear algebra library with ATLAS and LAPACK bindings in haskell that uses type level enumerable values to provide its bounds. Neat stuff.
23:32:54 <lispy> when i hear the name of GenI i think of forrest gump
23:33:26 <dons> ok. then was it SyntaxNinja's Haskell' report?
23:34:53 * lispy can't remember the exact order anymore, but SyntaxNinja gave such a talk
23:35:04 <edwardk> Isaac gave the state of Haskell', nothing too surprising there. Some guy from a credit suisse (I think) came up and asked about the impact of thing like Haskell' on commercial users and how they had troublejustifying using a language that had so much active research going on for production code.
23:35:21 <dons> ah interesting.
23:35:32 <dons> yes, the credit suisse people are giving a talk at CUFP
23:36:04 <dons> and any points raised in the future of hsakell discussion?
23:36:09 <edwardk> I basically popped in to say that it would seem they would want more standardization efforts like Haskell', because it would help lend stability to thepost-haskell 98 features that people need to use.
23:36:33 <edwardk> that seemed to go over well.
23:36:41 <dons> nice
23:36:54 <lispy> dons: um, people agreed that someone should look for things to remove, but no one could really think of anything besides n+k patterns
23:37:03 <edwardk> since haskell' doesn't sound like its going to remove anything.
23:37:16 <dons> sure. linear implicit params :)
23:37:18 <edwardk> yeah, and apparently simon peyton jones was even joking about that part ;)
23:37:21 <lispy> oh, and someone thought that Read/Show should become a real parser/something pain
23:37:24 <lispy> er pair
23:37:31 <edwardk> heh they were never in, so they aren't there to remove =)
23:37:38 <dons> hehe true
23:37:57 <lispy> oh, right someone wanted to remove local fixity?  is that right?
23:38:01 <lispy> but it's not in...
23:38:07 <dolio> So we're not getting rid of type classes? :)
23:38:08 <edwardk> someone stood up and talked about the galois haskell program coverage tool
23:38:19 <edwardk> I don't know everyone's name yet
23:38:23 <dons> was that Andy Gill?
23:38:29 <lispy> oh, right, HPC will become part of ghc
23:38:31 <lispy> dons: yes
23:38:31 <dons> or was this another demo to fill in?
23:38:40 <edwardk> no, it was someone else
23:38:44 <dons> oh. really? part of ghc. that sounds interesting
23:38:46 <edwardk> another demo to fill in
23:38:58 <lispy> dons: i told kowey that we should try to give lambdabot a wrapper for GenI
23:39:07 <dons> yeah would be nice.
23:39:17 <dons> any other info on the HPC demo?
23:39:47 <lispy> not much, Andy Gill will be gaining a new family member soon so he may disappear for a while
23:39:55 <lispy> and aparantly, VERY soon at taht
23:40:33 <dons> edwardk: did you want to say something different about Silva's Strong Types for Relational Databases?
23:40:40 <edwardk> well, it went smoothly, there was some question about the fact that 'green' code could be good in some cases, and bad in others. (good when it occurs on, say, your list pattern guard, bad when it indicates possibly impossible to fail conditions.
23:40:46 <edwardk> yeah =)
23:40:57 <dons> and also Polymorphic Variants in Haskell
23:41:14 <dons> and finally, anything else that came out of the future of haskell discussion (or was it mostly Haskell' talk?)
23:41:16 <edwardk> yay my judgemental self will get me in trouble with people i've never met before, yay ;)
23:41:24 <dons> :)
23:41:27 <lispy> the professor i came with was surprised by the way so many of us knew each other already and seemed to be very connected :)
23:41:38 <edwardk> heh
23:41:41 <dons> that's interesting.
23:41:45 <edwardk> who was that, lispy?
23:41:52 <lispy> Martin Erwip
23:41:54 <lispy> er
23:41:56 <edwardk> ahh
23:41:57 <lispy> Erwig
23:42:03 * lispy can't spell
23:42:08 <dons> oh, I'd have though he'd know this? strange.
23:42:20 <dons> author of fgl and so on..
23:42:34 <lispy> he admitted to never using irc before
23:42:39 <edwardk> I'll let lispy review Silva's talk. I can't figure out anything to really say about it =)
23:42:46 <dons> ok.
23:42:51 <lispy> oh, well...
23:42:54 <lispy> um, it was good
23:43:00 <lispy> that was the ESC talk?
23:43:03 <dons> lispy, do you have a sentence or two on Strong Types for Relational Databases
23:43:04 <edwardk> no
23:43:08 <lispy> oh
23:43:11 <lispy> hmm...
23:43:12 <edwardk> silva was the first relational database thing
23:43:13 <dons> edwardk: says,  basically it was using the type system to encode not only the types of
23:43:15 <lispy> relation databaseses....
23:43:16 <dons>     fields it was joining, but a bit more about their meaning and role in the key
23:43:26 <dons> something I can use for the HWN today..
23:43:32 <lispy> ah
23:43:45 <lispy> man, i don't remember that talk very well
23:43:49 <dons> i'll probably cross check against the abstracts anyway
23:44:05 <edwardk> Yeah, and please feel free to edit my words mercilessly.
23:44:12 <dons> edwardk: and also Kagawa's polymorphic variants talk?
23:44:24 <dons> you say "The resulting type system extensions had a somewhat confusing syntax
23:44:25 <lispy> polymorphic variants went well over my head
23:44:25 <dons>     that didn't do anything for me," :)
23:44:44 <lispy> yeah, the notation in the paper doesn't parse for me
23:44:48 <edwardk> Heh
23:44:49 <lispy> (mentally)
23:44:54 <edwardk> that seems to be the universal consensus
23:45:12 <lispy> ah, then they have definitely got the syntax right :)
23:45:19 <dons> ok, i might just extract something from the abstract then.
23:45:31 <lispy> good choice :)
23:45:33 <edwardk> I can parse the syntax, and the intent, and can appreciate its symmetry, but its hard to see how it could lead to an implementable language feature
23:45:45 <dons> ok, thanks edwardk for the text.
23:45:51 * dons tries to get an issue out
23:46:59 <lispy> @localtime dons
23:47:01 <lambdabot> Local time for dons is Mon Sep 18 16:46:38 2006
23:47:15 <lispy> the time difference is hard to get used to
23:47:30 <lispy> i'm thinking, "Geez, you'll have that out before Monday"
23:47:41 <lispy> and you must be thinking, "Nice, i'll finish this up and call it a day."
23:48:05 <dons> yep :)
23:48:19 <dons> its good though, it gets delivered in time for morning coffee in europe and the us
23:48:35 <edwardk> basically spent the time since the workshop talking to ml people. spent my lunch talking to cc shan about substructural types
23:48:38 <dons> (also good timezone to live in when deadlines are due)
23:48:38 <edwardk> all good.
23:48:47 * ValarQ just finished his european morning coffee
23:48:56 <dons> ah nice. yes, I had lunch with him a couple of times last year. very interesting guy
23:49:04 <edwardk> yeah
23:49:09 <dons> yikes, ValarQ, I better hurry then.
23:49:29 * ValarQ starts on his second breakfast
23:49:38 <edwardk> he was the first person I ran into in person that I could talk to in person that grokked the whole substructural type lattice extension thing =)
23:50:24 <edwardk> Then through a guy I met on #coq, I tracked down Matthew Fluet later on and went off to talk to him, since my work is currently extending a bunch of his.
23:51:23 <edwardk> Ambushed simonpj about the Haskell is Not Not ML paper, and it seems that the general consensus is that everyone but Ben Rudiak-Gould that signed their name to it, didn't really understand it ;)
23:52:20 * wkh reads up
23:52:27 <wkh> someone used ATLAS/LAPACK with Haskell?
23:52:41 <edwardk> _frederik_
23:52:57 <wkh> is there any place i can see code samples to play with?
23:53:11 <edwardk> that actually grabbed my attention too, since I'm a big fan of getting a BLAS to do my work for me too
23:53:16 <edwardk> hrmm, checking the paper
23:53:23 <wkh> or is it typical research stuff where if someone writes cool code and you want what they did you're signing up for 3 months of hacking :(
23:53:59 <lispy> dons: one comment i have about the extended static checking is that it's beautiful in that it opens up a whole new arena in haskell for machine checkable documentation
23:54:01 <wkh> where's the paper at?
23:54:10 <edwardk> he gave a url during the presentation I think, but I don't see it in the paper
23:54:16 <edwardk> in the proceedings they handed out =)
23:54:33 <wkh> can i get the PDF hookup?
23:54:43 <edwardk> You can ambush him about it when he pops up on channel.
23:54:47 <edwardk> I don't have a scanner.
23:55:07 <wkh> i bet you just "don't have" a scanner because i'm black
23:55:13 <edwardk> yep
23:55:14 <edwardk> =)
23:55:15 <wkh> if i was white it'd be a different story
23:55:18 <wkh> >:/
23:55:20 * wkh fights the power
23:57:04 <lispy> \m/
23:57:20 <edwardk> is that the excited two headed man?
23:57:45 <lispy> edwardk: it's a raised fist with index and pinky extended :)
23:57:51 <edwardk> ahh
23:58:01 <wkh> it's for when you're listening to uber nekro grim choonz
23:58:07 <Maddas> I thought it was someone headbanging.
23:58:16 <edwardk> am not up on my modern irc semiotics/iconography ;)
23:58:30 <wkh> and you feel the frostbitten unholy nekro grim true melodies deep inside
23:58:32 <edwardk> I stop with ;)
23:58:55 <lispy> edwardk: substructal types can do that to your 'hipness'
23:59:06 <lispy> substructural*
23:59:17 <wkh> yeah, you and your so-called "research" and "learning"
23:59:32 <wkh> unquote.
23:59:43 <dons> lispy: ah nice
23:59:44 <edwardk> yeah
23:59:53 <edwardk> i'm boring like that
23:59:56 <dons> I'd like to start playing with ESC, can we hook it in to the compiler with ease?
