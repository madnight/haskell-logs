00:08:20 <glguy> > [id] <*> [()]
00:08:21 <lambdabot>  Not in scope: `<*>'
00:08:43 <dons> what's this <*> ?
00:08:49 <dons> is it an arrow combinator?
00:08:49 <glguy> Control.Applicative
00:08:55 <dons> ah , I'll bring it in
00:09:05 <glguy> <*> is Monad's ap
00:09:42 <dons> ah, its too new. i'll need to install a 6.6 snapshot first
00:10:03 <glguy> ahh
00:10:14 <glguy> are the 6.6 snapshots different than the 6.5 ones?
00:10:28 <dons> no, a 6.5 snapshot is what I mean :)
00:10:31 <dons> what is to become 6.6
00:10:43 <glguy> I was about to hit the download button ;)
00:12:22 * glguy is watching youtube videos of Efren Reyes kick serious serious ass in 9-ball
00:13:56 <glguy> when he's done with people in these finals and semi-finals matches, they look like are grateful to have been schooled so thoroughly
00:14:04 <glguy> they*
00:14:32 <dibblego> many sports are like that - I just got back from squash training - sometimes I play Brett Marti
00:14:34 <dibblego> *Martin
00:14:45 <dibblego> or Craig Rowland
00:15:20 <glguy> to be honest, I don't know what squash is, or who those people are
00:15:35 <dibblego> former world #2 and #7 respectively
00:15:45 <dibblego> squash is a sport that is unfortunately not popular in the US
00:16:05 <dons> sadly :(
00:16:13 * dons chooses squash too
00:16:16 <dibblego> indeed
00:16:23 <glguy> how similar is it to racketball?
00:16:29 <dons> yes, similar.
00:16:38 <dibblego> glguy, racquetball is a spawn of squash - the court is a tad larger, otherwise it's the same
00:17:00 <glguy> I've played racquetball at least
00:17:04 <dibblego> different racquet and ball
00:17:13 <dons> dibblego: oh, btw, in response to your feedback yesterday, i put up, http://www.cse.unsw.edu.au/~dons/data/Basics.html
00:17:15 <lambdabot> Title: Haskell Unix Tools, http://tinyurl.com/zq2lk
00:17:18 <dons> extended version
00:17:20 <dibblego> dons, cool thanks
00:17:47 <dons> got a lot of interest out there in blog land, before haskell.org went down this morning. so thanks for the inspiration!
00:18:08 <dibblego> no problem - I'm going to write an article soon and make mention of the Maybe monad
00:18:23 <dons> mmm. tasty.
00:18:29 <dons> let me know if you want some proof reading or feedback
00:18:32 <dibblego> it will be on Java though
00:18:35 <dibblego> I will thanks
00:19:55 <foxy> > (\w -> foldl (\r b -> if testBit w b then setBit r (8-b) else r) 0 [0..7]) (1 :: Word8) :: Word8
00:19:57 <lambdabot>  0
00:21:04 <dons> Itkovian: can you bring haskell.org back up with magic tele-computational powers?
00:27:25 <dibblego> Australian squash players are far more successful than our tennis players, soccer team and all those popular sports
00:29:20 <dibblego> I remember a couple of months back when Palmer won one of the big touraments while he was #1, it got a mention on the radio
00:29:26 <dibblego> *tournaments
00:31:26 <goltrpoat> has haskell.org been down all day?
00:31:32 <goltrpoat> oh.. nm, just saw the topic
00:32:43 <goltrpoat> i heard there's GADT-style record syntax in 6.5, and with the site being down, it takes an inordinate amount of time to figure out what that syntax could possibly be.
00:33:17 <foxy> > (\w -> foldr (\b r -> if not $ testBit w b then setBit r (8-b) else r) 0 [0..7]) (0 :: Word8) :: Word8
00:33:18 <lambdabot>  254
00:33:47 <foxy> what is wrong with this ^^^ code?  (It's supposed to reverse the bits in a Word8)
00:34:18 <foxy> @arr
00:34:18 <lambdabot> Yo ho ho, and a bottle of rum!
00:34:52 <foxy> > (\w -> foldr (\b r -> if not $ testBit w b then setBit r (7-b) else r) 0 [0..7]) (0 :: Word8) :: Word8
00:34:54 <lambdabot>  255
00:34:58 <foxy> :)
00:40:32 <glguy> I'm reading a l-t-u thread... and someone really needs to announce that Haskell has a printf function
00:42:24 <dons> url?
00:42:31 <glguy> http://lambda-the-ultimate.org/node/186
00:42:33 <lambdabot> Title: New Paul Graham thing... | Lambda the Ultimate
00:43:03 <glguy> there's a sub-thread (if you will) where people go on and on about how having a printf function allows idiots to debug C programs or something
00:43:10 <goltrpoat> LtU is weird.  there are some remarkably intelligent people posting here and there, and then there are entire threads that just make you cringe
00:45:35 <dibblego> printf is a laborious and quite flawed method of problem resolution
00:46:24 <dibblego> it's something they do at IBM and if you don't, then you're not very clever
00:46:49 <dibblego> (seriously)
00:47:08 <glguy> I've witnessed some amazing use of the debugger at work
00:47:13 <glguy> the win32 debugger
00:47:34 <glguy> printf has nothing to do with it
00:47:41 <dons> goltrpoat: yes.I agree
00:48:00 <dons> the internet is full of people with 5s attention spans
00:48:16 <glguy> what are you talking about?
00:48:22 * glguy kids, of course
00:48:29 <dons> heh
00:49:17 <goltrpoat> dons:  btw, been meaning to ask you this..  how well does hsplugins work under windows?
00:49:29 <dons> n.b. we have a GHCi.Debugger now too
00:49:39 <dons> I guess people on LtU don't read the HWN
00:49:44 <dons> goltrpoat: seems to work fine, afaik.
00:49:48 <dons> it's in use by a number of people
00:50:02 <dons> but you'll want ghc 6.4.2 or earlier. hs-plugins hasn't been ported to 6.6 yet
00:50:11 <goltrpoat> yah, ive noticed it's in use by a number of people, just wasn't sure what platform those people were on
00:50:19 <goltrpoat> i'm in a bit of an interop bind
00:50:36 <dons> no, I mean i know its used on windows by a number of people
00:50:37 <glguy> dons: is the debugger work in my snapshot build from the 19th?
00:50:43 <goltrpoat> ah cool.
00:50:55 <dons> hmm, glguy not sure. might have to be enabled?
00:51:02 <goltrpoat> what are the issues with 6.6?
00:51:10 <glguy> it's too good
00:51:15 * glguy doesn't know
00:51:24 <dons> small change to the .hi file format, and Typeable has been fixed, meaning I can toss out some code in hs-plugins
00:52:24 <goltrpoat> basically -- long story short, i have a compiler for a DSL, a relative large project, in C++.  it's about 75% done, but ive written a few DSLs in haskell, and i figure it'll take less time to port the whole thing to haskell and finish up the remaining 25%, than it would to finish it up in c++
00:52:52 <goltrpoat> trouble is, we can't include gcc in the toolchain, and this requires a fairly stupid amount of rather intricate interop with C++
00:54:13 <goltrpoat> i should be able to handle it all through discovering exports in dlls, but ive been rather reticent to get too deep into that.
00:54:28 <goltrpoat> since win32-specific stuff seems to be rather poorly handled, in general.
00:54:50 <glguy> goltrpoat: "discovering exports in dlls" you just mean dynamic linking? (like POSIX's dlopen, dlsym?)
00:55:06 <gour> dons: Lemmih was hacking with ghc-api instead of hs-plugins for hIDE. will (some) functionality of hs-plugins go into ghc itself?
00:56:09 <goltrpoat> glguy:  there is a reflection system on the C++ side, that exports type information.  our other interop mechanisms tend to go both ways -- so the satellite language can muck around with C++ types based on the metadata, and the native side can muck with the satellite language types.
00:56:24 <goltrpoat> component dlls export their reflected typeinfo.
00:56:24 <glguy> ah
00:56:46 <glguy> Anything I've done with reflection has been in a .NET environment
00:57:01 <goltrpoat> yah, it's basically very much along the lines of .NET reflection
00:57:44 <goltrpoat> we actually have a bridge that takes native reflected types to .NET reflected types and back.
00:58:23 <goltrpoat> i don't need to construct haskell types from metadata, but i do need to get hold of the metadata in order for the compiler to validate the syntax.
00:59:19 <goltrpoat> anyway, the point was that i either have to write a static lib in c, have it load up the component dlls and export the kit and kaboodle to the haskell-side compiler via FFI, or load stuff up dynamically, or have the compiler itself loaded up dynamically.
00:59:29 <goltrpoat> hence the question.  pardon the long-winded explanation.
01:02:31 <goltrpoat> (oh and we're trying to use visual haskell, so rolling back to 6.4.2 would be a bitch in quite a number of ways)
01:02:52 <glguy> well, I haven't done any FFI stuff, so I can't help you there, though I find your problem interesting
01:03:01 <glguy> and I also enjoy using visual haskell
01:03:24 <goltrpoat> yah i hope someone's doing the 2005 version
01:03:32 <araujo> "Haskell, for example, seems to me a language that's designed more to write papers about than to hack in"
01:03:34 <araujo> hahaha
01:03:42 * gour hopes we'll get hiDE someday
01:06:02 <goltrpoat> glguy:  do you know if there's a way to like.. regain mouseover type info and such with -fglasgow-exts?
01:06:44 <glguy> goltrpoat: I add {-# GHC_OPTIONS -fglasgow-exts #-} to the top of my source file
01:06:51 <goltrpoat> i mean, i'd understand if it disappeared on instances of multiparameter typeclasses and whatnot, but it just disappears on the whole thing
01:06:52 <glguy> instead of changing the compiler flags
01:06:53 <goltrpoat> yeah, same here
01:06:56 <glguy> ok
01:07:12 <goltrpoat> you mean OPTIONS_GHC
01:07:14 <goltrpoat> ?
01:07:31 <glguy> I don't think so...
01:07:52 <goltrpoat> well then.
01:07:55 <goltrpoat> that works.
01:07:56 <goltrpoat> thanks :)
01:08:09 <glguy> glad to help with at least one thing ;)
01:08:19 <glguy> and now it's my bed time
01:08:20 <glguy> ..
01:08:23 <glguy> + 3 hours
01:08:27 * glguy &
01:08:30 <goltrpoat> later
01:15:11 <bartw> moin
01:24:19 <goltrpoat> don't suppose anyone's compiled a list of proposed extensions to the kind system that actually leave type inference decidable
01:29:38 <foxy> I thought that typing was no longer decidable? (With extensions)
01:29:58 <goltrpoat> sorry, minus extensions
01:31:01 <goltrpoat> i'm trying to wrap my head around what makes it decidable actually.  can the kind system be context free?
01:31:10 <Bourbaki> moin
01:31:13 <goltrpoat> as a language in itself i mean
01:50:02 <foxy> dons, is dcoutts in transit from ICFP?
02:00:12 <dcoutts__> foxy, no
02:01:48 <dcoutts__> foxy, have you got the latest c2hs darcs version? I thought we'd updated it.
02:05:39 <foxy> dcoutts__, there's a problem with patch 107 in the c2hs darcs repo which prevents windows darcs from applying
02:07:01 <dcoutts__> hmm
02:07:35 <foxy> dcoutts__, I worked around that by going via linux
02:08:24 <foxy> dcoutts__: but I still have the same problem /using/ c2hs
02:08:48 <dcoutts__> you mean building it?
02:08:54 <dcoutts__> with 6.5
02:09:16 <foxy> dcoutts__, It built fine with 6.5, but the install step doesn't work, so I did that by hand
02:09:50 <foxy> dcoutt__, my problem is that I get:
02:09:51 <foxy> c2hs.exe: Errors during expansion of binding hooks:
02:09:53 <foxy> MxMatrix.chs:5: (column 8) [ERROR]
02:09:54 <foxy>   >>> Unknown identifier!
02:09:56 <foxy>   Cannot find a definition for `mxClassID' in the header file.
02:10:12 <foxy> but `mxClassID' is definitely in the header file I'm trying to bind to
02:10:33 <dcoutts__> perhaps you could send a bug report with the details to the c2hs list
02:11:07 <musasabi> darcs + windows seems quite buggy (there is also a problem with the fps repo on windows darcs)
02:13:47 <foxy> dcoutts__, where is the c2hs list and what should I include in the bug report?
02:14:10 <dcoutts__> c2hs@haskell.org
02:14:53 <dcoutts__> say the problems with 6.5, with darcs/windows and your binding error
02:15:17 <dcoutts__> including a reference to the header file and .chs you were using
02:16:23 <foxy> ok, thanks
02:21:13 <foxy> dcoutts__, do I need to join the mailing list to send to it?
02:22:09 <dcoutts__> I don't think so
02:22:28 <musasabi> I think it required that. But you could post through gmane without joining
02:23:13 <musasabi> (most of the haskell.org lists do to avoid too many spam problems)
02:24:24 <foxy> dcoutts__, you told me a few weeks ago how to check what the preprocessor was reading when invoking c2hs, could you refresh my memory?
02:25:39 <dcoutts__> foxy you can override the cpp that's used
02:25:39 <dcoutts__> eg with echo
02:25:39 <dcoutts__> that shows what it's being called with
02:25:57 <damkor> hi there, I've got a question about haskell packages
02:26:05 <foxy> dcoutts__, I want to check that the .h file I'm including gets read
02:26:21 <damkor> is there any way to include a compiled package with my sources
02:26:46 <damkor> so that the sources can be compiled using the binary package files?
02:27:06 <damkor> it tried several ways (primarily using -L option to ghc)
02:27:20 <damkor> but it seems to expect the sources anyway
02:27:32 <damkor> (i mean the library's sources)
02:30:21 <roconnor> @seen shapr
02:30:22 <lambdabot> I saw shapr leaving #haskell 10h 3m 37s ago, and .
02:33:55 <dcoutts__> @seen ndm
02:33:55 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 14h 15m 51s ago, and .
02:33:58 <dcoutts__> @tell ndm this gtk+ windows patch got applied in gtk+ 2.10.4: http://bugzilla.gnome.org/show_bug.cgi?id=340201
02:33:59 <lambdabot> Consider it noted.
02:40:15 <foxy> dcoutts__, I now get an error that "the symbol '__attribute__' does not fit here" the file in which this occurs is 'float.h' which is a standard gnu header...
02:41:23 <foxy> should I report that to the mailing list as well?
02:56:49 <glauber_sp> hi guys. goo morning =) (at least here hehe) Does anyone have this paper: http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/par-intro.html
02:56:53 <lambdabot> Title: Parallel Functional Programming: An Introduction, http://tinyurl.com/mj4zo
02:57:08 <glauber_sp> the downloaded file doesn't open
02:58:36 <foxy> It works for me...
02:59:34 <glauber_sp> foxy, with which program do you open?
02:59:53 <glauber_sp> both the ps and the ps.gz open here and don' t show nothing
02:59:54 <foxy> ghostscript (the .ps not .ps.gz file)
03:00:26 <foxy> I get all 19 pages
03:00:41 <glauber_sp> hum. I'll try again. kpdf and evince didn' t show nothing, only 19 blank pages =/
03:00:43 <foxy> have you tried again?  Maybe the download terminated incorrectly?
03:00:57 <foxy> does kpdf read ps files?
03:01:14 <glauber_sp> I've downloaded 4 times already. and not only today. I'm downloading again
03:01:28 <glauber_sp> foxy, kghostview =)
03:03:56 <glauber_sp> foxy, gv gives a stack underflow error. I guess I need to recompile it
03:04:17 <dcoutts__> foxy, is that glibc 2.4 ?
03:05:10 <glauber_sp> dcoutts, I use glibc 2.4, why?
03:05:19 <glauber_sp> any known error?
03:05:29 <dcoutts__> c2hs can't parse some of the 2.4 headers yet
03:06:05 <glauber_sp> dcoutts, hum, I'm not using c2hs eheh
03:06:27 <glauber_sp> I' m trying to open a ps file only =)
03:13:31 <foxy> dcoutts__, it's mingw 3.4.2, how do I find what version of glibc?
03:13:42 <dcoutts__> ah, no glibc
03:14:01 <dcoutts__> well just find the header and send it in
03:14:15 <foxy> done
03:14:59 <foxy> the file was _mingw.h, and it is related to dll importing
03:17:40 <musasabi> Why does ReadP not define greedy operators?
03:18:25 <musasabi> like: gmany1 p = liftM2 (:) p (gmany1 p <++ return [])
03:22:54 <mux> someone needs to fix www.haskell.org
03:28:07 <roconnor> @slap haskell.org
03:28:07 * lambdabot beats up haskell.org
03:33:02 <poltrgoat> someone should write a book on optimizing haskell programs
03:34:44 <sieni> poltrgoat: yes, or any advanced level textbook would be nice
03:35:00 <sieni> dons: why don't you write a couple of haskell books
03:35:15 <poltrgoat> i was actually thinking that
03:35:15 <poltrgoat> heh
03:35:18 <poltrgoat> (re dons i mean)
03:36:12 <sieni> I think there's a dire need for some
03:36:19 <kosmikus> I guess dons should write a thesis first ;)
03:37:01 <Syzygy-> Thesis writing is good for you.
03:37:11 <Syzygy-> At some point I'll get around to it asd well. :)
03:39:00 <sieni> something like "Practical Haskell" would be nice (similar to "Practical Common Lisp") and also "Monads and Arrows in Haskell" and "Design and Implementation of the Glasgow Haskell Compiler"
03:39:57 * Syzygy- would like a comprehensive reference of Haskell that assumes the reader is familiar with category theory to a large extent... :)
03:40:08 * sieni doesn't
03:42:01 <roconnor> Syzygy-: Haskell programs are points in a topological space
03:42:10 <Syzygy-> Oh, really? Which one?
03:42:19 <roconnor> The program types are the open sets
03:42:29 <Syzygy-> Program type?
03:42:39 <roconnor> well, function types
03:42:41 <Syzygy-> Ah.
03:42:52 <Syzygy-> Is there anything decent to be said about the space?
03:42:53 <roconnor> Haskell functions are points in a topological space
03:42:59 <Syzygy-> Is it haussdorff, for instance?
03:43:19 <roconnor> hmm
03:43:27 <sieni> And I don't believe that anybody that claims that he understands category theory before understanding everything in that book: http://www.amazon.co.uk/Introduction-Homological-Cambridge-Advanced-Mathematics/dp/0521559871/sr=8-1/qid=1159008120/ref=sr_1_1/026-8508330-1641259?ie=UTF8&s=books
03:43:31 <lambdabot> http://tinyurl.com/hxnpm
03:43:46 <roconnor> Syzygy-: oh wait, forget what I said.  I forgot Haskell isn't consistent
03:43:52 <roconnor> so it is the one point space :P
03:43:56 <Syzygy-> Ah.
03:44:14 <roconnor> perhaps it is the 0 point space
03:44:22 <Syzygy-> sieni: Oh the dear old Weibel. :)
03:44:24 * roconnor kicks (fix id)
03:44:55 <Syzygy-> sieni: I'm doing a PhD in group cohomology right now. I use Weibel as a stepping stone to wrap my head around my other references
03:46:23 <sieni> I got my Ph.D. in Analysis and have tried to read Weibel's book a few times with quite a bad success :-)
03:46:44 <Syzygy-> Ewwww, analysis. ;)
03:46:50 <sieni> analysis <3
03:46:54 <roconnor> does everyone here have a phd?
03:46:57 * Syzygy- took my masters in homological algebra as well...
03:47:00 <Syzygy-> roconnor: Not yet.
03:47:00 <roconnor> except me
03:47:21 <sieni> roconnor: many are probably in the process of getting one :-)
03:47:38 <roconnor> maybe my friend is right.  You need a phd to use Haskell.
03:49:32 <Syzygy-> sieni: What, more specifically, did you do?
03:50:07 <sieni> Syzygy-: there are links: http://www.hurmio.org/~ville/
03:50:12 <lambdabot> Title: Ville Hakulinen, Ph.D., kauppat.yo.
03:50:32 <Syzygy-> Btw, sieni: If you want something really obnoxious in homological algebra, take a look at Dave Benson's books on representations and cohomology.
03:50:50 <sieni> heh
03:50:59 <sieni> I haven't been reading much math lately
04:05:32 <mux> how would guys write code to apply some function exactly N times to an initial value?
04:06:39 <mux> I have a version using n-k patterns and another taking the Nth element of the list returned by iterate
04:06:46 <mux> I'm looking for a more elegant way of expressing it
04:08:15 <sieni> ?
04:08:16 <dons> unfoldr?
04:08:26 <sieni> isn't iterate just what you need?
04:08:34 <dons> ?type iterate
04:08:36 <lambdabot> forall a. (a -> a) -> a -> [a]
04:08:41 <dons> or do you need to fold it?
04:08:44 <sieni> take N $ iterate f element
04:08:48 <sieni> oops
04:09:14 <mux> I have a version using iterate
04:09:24 <mux> ?type unfoldr
04:09:25 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:09:33 <dons> > take 10 $ scanl (\a b -> a+b) 0 [1..]
04:09:34 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
04:09:42 <mux> that would be
04:09:54 <sieni> > iterate (+1) 8 !! 5
04:09:56 <lambdabot>  13
04:10:02 <mux> ?let applicate n f x = iterate f x !! n
04:10:03 <lambdabot> Defined.
04:10:09 <mux> yes that's what I have already :-P
04:10:11 <mux> I want something else.
04:10:16 <sieni> why?
04:10:46 <mux> something more function-level oriented, where I would construct the function application n times
04:10:57 <mux> like with some replicate/fold ($) thing
04:11:41 <mux> but I can't figure out how to write it this way
04:11:53 <sieni> @pl \x y z -> iterate x y !! z
04:11:53 <lambdabot> ((!!) .) . iterate
04:14:32 <mux> any ideas?
04:17:56 <mux> it's only as an exercise I gave to myself, I don't expect this other way to be prettier or more efficient or anything
04:22:59 <wilx> (foldl1 (.) .) . replicate? :)
04:23:43 <mux> ahh, thanks
04:23:54 <mux> I was battling with foldl1 and replicate since 10 minutes
04:24:06 <mux> could you give a non-pointfree version?
04:24:13 <sieni> wilx: that's completely unreadable ;-)
04:24:40 <wilx> \n f -> foldl1 (.) (replicate n f)
04:25:11 <mux> damn, I was only doing foldl1 ($) instead of foldl1 (.)
04:25:15 <mux> I was near
04:25:16 <mux> thanks.
04:26:31 <sieni> well, isn't ($) like id or something?
04:27:03 <sieni> @pl \x ->
04:27:04 <lambdabot> (line 1, column 6):
04:27:04 <lambdabot> unexpected end of input
04:27:04 <lambdabot> expecting lambda abstraction or expression
04:27:09 <sieni> @pl \x -> ($) x
04:27:10 <lambdabot> id
04:27:14 <sieni> ^_^
04:27:38 <mux> @type ($)
04:27:39 <lambdabot> forall b a. (a -> b) -> a -> b
04:27:44 <mux> I'd call that function application
04:28:22 <mux> I was expecting the fold to produce something like
04:28:27 <mux> f $ f $ f $ f $ f x
04:28:33 <Syzygy-> > (+2) . 3
04:28:35 <lambdabot>  add an instance declaration for (Num (a -> b))
04:28:36 <mux> which would be valid
04:28:42 <Syzygy-> > (+2) $ 3
04:28:44 <lambdabot>  5
04:28:54 <Syzygy-> @type (.)
04:28:56 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
04:29:19 <Syzygy-> > (+2) . (+3)
04:29:21 <lambdabot>  Add a type signature
04:29:52 <Syzygy-> @pl (+2) . (+3)
04:29:53 <lambdabot> (5 +)
04:40:20 <roconnor> @pl (+2) . (3+)
04:40:21 <lambdabot> (5 +)
04:54:08 <roconnor> what's the diff between uncheckedShiftRL# and shift?
04:54:17 <roconnor> @hoogle uncheckedShiftRL
04:54:18 <lambdabot> No matches found
04:54:32 <roconnor> ?fptools GHC.Word
04:54:32 <lambdabot> GHC.Word not available
04:55:37 <roconnor> Shift right logical. Result undefined if shift amount is not in the range 0 to word size - 1 inclusive.
04:55:42 <roconnor> ah thanks roconnor
04:55:48 <roconnor> ?karma+ roconnor
04:55:49 <lambdabot> You can't change your own karma, silly.
04:57:17 <roconnor> @hoogle rotate
04:57:18 <lambdabot> Data.Bits.rotate :: Bits a => a -> Int -> a
04:57:18 <lambdabot> Data.Bits.rotateL :: Bits a => a -> Int -> a
04:57:18 <lambdabot> Data.Bits.rotateR :: Bits a => a -> Int -> a
04:57:26 <roconnor> @fptools Data.Bists
04:57:26 <lambdabot> Data.Bists not available
04:57:29 <roconnor> @fptools Data.Bits
04:57:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
04:57:40 <Syzygy-> ?karma+ lambdabot
04:57:41 <lambdabot> lambdabot's karma raised to 28.
05:05:50 <roconnor> Is there an unchecked rotate for George?
05:13:36 <roconnor> where do I find the implementation of GHC primitives such as stg_shiftL32
05:27:01 <xerox> ?quote
05:27:01 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
05:27:08 <xerox> ?quote
05:27:08 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
05:27:15 <xerox> ?quote
05:27:15 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
05:27:36 <xerox> ?quote
05:27:36 <lambdabot> dylan says: I run emacs for the games
05:27:45 <bartw> :)
05:28:03 <roconnor> I can't find stg_shiftL32 in the ghc sources ...
05:28:41 <roconnor> is it part of extras?
05:31:38 <Heffalump> any c2hs people around?
06:00:37 <mux> dons: your last change in Plugin/Seen.hs broke lambdabot's build for me
06:00:39 <mux> ./Plugin/Seen.hs:323:75: parse error on input `)'
06:10:33 <dons> yeah, gotta fix it. just unpull that patch for now
06:10:42 <mux> ok
06:11:42 <dons> hmm. mailing list is back up.
06:11:51 <dons> hopefully the web site soon...
06:17:01 <ndm> is haskell.org back yet? i have got some emails through, but cna't get in via http
06:17:01 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:18:35 <ndm> @tell dcoutts__ cool, i guess they aren't going to fix the "file chooser is wrong" bug though, but its good to see they are pushing forward
06:18:36 <lambdabot> Consider it noted.
06:40:54 <ndm> woohoo! haskell.org returns!!!!!
06:41:41 <Syzygy-> WOOOOOOT!
06:41:57 * ndm prepares a release, only a day late...
06:45:26 <yip> sup haskell
06:47:21 <deadbeef> hi yip
06:47:40 <yip> how's it hanging beef?
06:47:46 <deadbeef> on the left
06:49:21 <yip> let's make sure to keep it that way
07:08:51 <dons> yay, its back up
07:09:05 <astrolabe> yeah
07:10:21 <dons> i wonder if it was really a reddit effect?
07:10:40 <dons> "   The web server had over 150 client connections which exceeded
07:10:40 <dons>    its limit. I restarted the web server and all is well."
07:11:13 <ndm> dons: 150 doesn't sound that much....
07:11:38 <dons> no. when I went to bed the 'unix tools' page was getting 20 hits a minute, and in the next hour receieve 1000 more
07:11:42 <dons> but that's not enough
07:11:57 <dons> musta been a dos.
07:11:59 <ndm> i'm wondering how many people use  hoogle - i suspect that causes more people to hit the web server, even when they don't need info
07:12:28 <ndm> i'm kinda surprised that the website doesn't get killed by hoogle, since its about 3 secs per query on my machine...
07:12:53 <dons> mmm
07:13:50 * ndm is rewriting it to be faster, it currently parses about 1Mb of haskell per request...
07:14:43 <dons> urgh
07:15:05 <dons> congrats on getting Dr Haskell out!
07:15:07 <dons> ndm++
07:15:17 <ndm> yep, would have had it out last night, but haskell.org died on me...
07:15:23 <Igloo> Haskell meaning the result of a show?
07:15:38 <dons> or source?
07:15:54 <dons> heya Igloo , back home?
07:15:59 <Igloo> Yup
07:16:02 <ndm> Igloo: nope, haskell as in: http://haskell.org/hoogle/res/hoogle.txt
07:16:12 <ndm> kind of source
07:16:21 <ndm> turns out its 250Kb, i thought it was more
07:16:22 <Igloo> I leave Oxford for 1 week, and when I get back the pavements have become playgrounds for little frogs!
07:16:32 <ndm> but its a bad parser, so that probably doesn't help :)
07:16:37 <Igloo> Ah, right
07:17:13 <ndm> the new version has to do about 4Kb of binary read to do a name search, so much much faster
07:17:28 <lennart> is haskell.org down again?
07:17:52 <ndm> lennart: it came back about 5 mins ago
07:17:57 <dons> works here.
07:18:09 <dons> it's been down for about 15 hours though
07:18:11 <lennart> yep it work again for me too
07:18:18 <dons> more, 21 hours, I think.
07:18:33 <_JusSx_> hi hasell ppl
07:18:37 <_JusSx_> hi haskell ppl
07:18:42 <ndm> yeah, i tried to release Dr Haskell at 6pm last night, so must be 21 hours
07:19:54 <ndm> hi _JusSx_
07:20:26 <dons> yeah, the logs say the last commit was 01:23, until ndm's at 23:27.
07:20:51 <ndm> my commit?
07:21:22 <dons> "Yhc; 23:27 . . NeilMitchell"
07:21:40 <ndm> Yhc isn't on haskell.org
07:21:48 <ndm> oh, you mean the wiki commits :)
07:22:19 <dons> yup
07:23:06 <ndm> although i was able to get  in via SSH to haskell.org during the downtime
07:23:28 <phas> hi
07:23:28 <ndm> i ran top, to check hoogle hadn't gone nuclear on haskell.org (that would be embarassing)
07:23:36 <phas> we're trying to do a haskell shell
07:24:02 <phas> i'm trying to figure how sintax can be
07:24:25 <dons> haskell syntax? :)
07:24:34 <phas> yeah dons but
07:24:51 <phas> i've to use also "programs"
07:25:00 <dons> ?remember Bulat there is new Time library, which is supposed to replace old System.Time. we hope that it will happen before 2038
07:25:19 <dons> phas, have you looked at the existing work on haskell shells?
07:25:24 <phas> yes
07:25:27 <phas> mainly hashell
07:25:45 <phas> wich uses "special parentesis"
07:26:04 <phas> like (program) {haskell code} (programs)
07:26:16 <phas> but i wonder if there's a better solution
07:26:29 <ulfdoz> In 2038 I'm too old for work, so what do I care. ;)
07:26:32 <dons> right, there's a couple of others, there,
07:26:35 <dons> ?wiki Libraries_and_tools/Operating_system#Shell
07:26:35 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Shell
07:26:51 <dons> ulfdoz: heh
07:27:38 <dons> newsham++ -- releasing the file fuzzer
07:28:51 --- mode: ChanServ set +o dons
07:29:26 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/", "Haskell - The language of choice for discriminating hackers"]' by dons
07:29:29 --- mode: ChanServ set -o dons
07:29:53 <dons> I figure that since the winning team this year did use haskell, we can keep the title :)
07:30:19 <ndm> what did the winning team use?
07:30:39 <ulfdoz> lol
07:30:43 <dons> Our friends at CMU say C++, Haskell, Python.
07:30:53 <ndm> oh, and is there any massive need for the ["   "," "] list syntax in the topic?
07:31:02 <dons> not unless we use the lambdabot.
07:31:03 <ndm> (or is that just my irc reader?)
07:31:07 <dons> maybe not, I suppose.
07:31:08 <ulfdoz> religion, i think.
07:31:13 <dons> (it's supposed to be Read/Showable :)
07:31:26 <ndm> it seems lambdabot is so massively clever, that a little title parsing isn't that hard :)
07:31:31 <dons> hehe
07:31:33 <ndm> yeah, i guessed the read/show aspect
07:31:54 <yip> "we put the funk in funktion"
07:32:33 <norpan> i wonder who puts the tion in it
07:32:50 <ndm> dons supplies half
07:33:08 <ndm> i guess tic supplies the other half...
07:34:52 <ndm> if you have previously written an academic paper, how much can you plagerise from the old one to the new one?
07:35:06 <phas> dons: well the only other work that says something on my problem is HSH
07:35:35 <phas> dons: wich proposes a "command >>= command>>= haskell script >>= command ..."
07:35:37 <phas> sintax
07:36:02 <phas> but the problem here is that functions are limited to arity 1
07:36:18 <phas> i mean that i cannot express what in hashell i express with
07:36:28 <phas> foo {command} {command}
07:37:31 <Syzygy-> phas: So curry (or if it is uncurry)
07:38:03 <Syzygy-> ndm: There tends to be a lot of carry-over from paper to paper if you look into academic publications and track authors.
07:38:40 <Syzygy-> At least in mathematics, the consensus seems to be that there should be some substantial reason for a new paper; where substantial has been taken to mean "I got admitted to a cooler journal" among some famous mathematicians.
07:38:59 <phas> Syzygy: you mean something like command >>= (command >>= foo)
07:39:02 <phas> ?
07:39:11 <ndm> oh, there is a substantial reason, but the motivation etc is still the same, which is what i was going to pinch
07:39:15 <phas> sound like abyguos
07:39:24 <phas> ambiguos
07:59:05 <yip> are there any people who are seriously into haskell who are not interested in mathematics?
07:59:29 <Syzygy-> I'd be surprised, personally.
07:59:40 <dons> me :)
07:59:51 <phas> :)
08:00:17 <dons> though maybe PL research is maths, in this crowd.
08:00:42 <Syzygy-> What, exactly, is pl research?
08:00:58 <dons> either a) you're into programming language research, b) maths c) you're learning it in uni. perhaps
08:01:32 <dons> though there's lots of other haskellers these days, commerical users, people using it in back rooms without their boss knowing and more..
08:04:12 <Limbic_Region> yip - those seriously interested in Perl 6 are seriously interested in Haskell
08:04:19 <Limbic_Region> and most of those people are pretty poor at math
08:04:38 * Limbic_Region fits all categories mentioned
08:04:49 <Limbic_Region> hrm - actually, that is a bit of set theory ;-)
08:13:07 <kolmodin> is there a parser library that works on bytestring yet?
08:15:19 <xerox> kolmodin: yeah
08:15:32 <xerox> kolmodin: http://darcs.haskell.org/~paolo/darcs/ByteStringParser
08:15:35 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser, http://tinyurl.com/o6p8o
08:16:24 <kolmodin> xerox: thanks
08:19:40 <fasta> Why doesn't a k = k <binary operator> work?
08:20:23 <ndm> a k = (k <binary operator>)
08:20:33 <ndm> its a section, so needs to be in brackets
08:20:46 <fasta> a k = (<binary operator>) k does also work
08:20:51 <fasta> thanks
08:21:05 <ndm> if you undersaturate a binary operator, put it in brackets is the basic rule
08:21:21 <ndm> the second variant is using a binary operator as a prefix function
08:21:27 <ndm> hence its ok
08:25:01 <lispy> > 1 `(+)` `
08:25:02 <lambdabot>  Parse error
08:25:05 <lispy> > 1 `(+)` 1
08:25:06 <lambdabot>  Parse error
08:25:13 <lispy> too bad that doesn't parse
08:26:15 <twanvl> > 1 `(`(`(+)`)`)` 1
08:26:16 <lambdabot>  Parse error
08:26:25 <lispy> :)
08:27:08 <Heffalump> allowing nested use of ` ` would be silly
08:27:42 <dons> but a `flip f` b might be nice ...
08:27:54 <twanvl> why not write b `f` a?
08:28:13 <dons> imagine something more complex
08:28:26 <twanvl> yes, liftM would work pretty well there
08:28:31 <fasta> ndm: In my case only the prefix version works. I want to return a function. I get syntax errors when using the other notation.
08:29:23 <ndm> > let f a = (+ a) in 1
08:29:25 <lambdabot>  1
08:29:34 <ndm> fasta: works fine there...
08:29:41 <ndm> @type (+ 1)
08:29:43 <lambdabot> forall a. (Num a) => a -> a
08:30:32 <vincenz> ndm: that's odd
08:30:41 <vincenz> oh no
08:30:41 <lispy> > let f a = (+ 1) in f 1 1
08:30:48 <vincenz> > let f a = (+ a) in  f 1
08:30:54 <ndm> vincenz: only if the input is even :)
08:30:55 <lispy> vincenz: you were right, 1 is odd :)
08:31:04 <lambdabot>  2
08:31:06 <vincenz> ndm: I thought you had typed f 1, and was showing a function as a number
08:31:07 <lambdabot>  Add a type signature
08:31:14 <vincenz> lambdabot: you're slow today!
08:31:28 <ndm> lispy: i talked to Colin about smallCheck, he says he might put up a darcs repo
08:31:35 <dons> yay!
08:31:37 * lispy cheers!
08:31:41 <ndm> but its hard convincing him that a tarball isn't perfect...
08:31:42 <lispy> \o/
08:31:43 <fasta> ndm: nm, I am confusing something.
08:32:02 <dons> ndm, you'll have to introduce him to web browsers ;) sometimes its nice to be able to read things online
08:32:06 <lispy> ndm: well, 'darcs dist' creates tarballs....(pre zipped but that's easy to fix iirc)
08:32:22 <ndm> dons: yep, i know, he still won't use hoogle web interface, only a command line version
08:32:35 <lispy> heh
08:32:37 <ndm> lispy: i'll talk him through it, he'd probably want pre zipped
08:33:00 <ndm> and he still searches the haskell 98 report by hand before googling or hoogling something
08:33:15 <lispy> old people.... ;)
08:33:46 <lispy> (i have no idea how old colin is, but he sounds like he prefers the 'old' ways of doing things)
08:33:50 <dons> hehe. cool. the report as first source.
08:34:17 <lispy> ndm: does he make interesting arguments why that's a good way to operate?
08:34:38 <ndm> lispy: easier for everyone is his argument, although thats based on what was easiest quite a while usually
08:34:39 <lispy> maybe there is a subtlty others have missed building these tools
08:34:46 <ndm> he does prefer the old way of doing things
08:34:59 <ndm> he's not that old, i don't think, he's still quite fit and active
08:35:07 <ndm> maybe 50ish
08:35:31 <lispy> i wonder if the amish would allow programmers as long as they didn't use electric computers
08:35:43 <ndm> do the amish not like electricity?
08:35:59 <fasta> Why do you think darcs is so "awesome"? It still contains one very easy to reproduce bug, which to me means that nobody is looking after it.
08:36:00 <lispy> the amish are the classical definition of neo-luddite :)
08:36:27 <Heffalump> mainly because it's so easy to use
08:36:35 <lispy> fasta: the darcs focus right now is fixing the theoretical problems
08:36:44 <lispy> fasta: but, what bug are you referring to?
08:37:12 <lispy> fasta: if it's easy to fix then, yeah we should probably just fix it
08:37:25 <fasta> lispy: hold y when "darcs pull" when there are about >10 patches.
08:37:28 <ndm> lispy: i got a fromJust Nothing the other day out of darcs
08:37:36 <ndm> i often get non termination
08:37:41 <ndm> and quite often get into the situation where
08:38:03 <lispy> fasta: hmm...i looked at that bug but i couldn't reproduceit
08:38:11 <ndm> darcs record, with 1 change in there: a works fine, y freezes and doesn't terminate
08:38:19 <Heffalump> oh, I can reproduce that bug too
08:38:20 <ndm> while a is instant
08:38:25 <Heffalump> you just need a slightly slow computer
08:38:37 <ndm> a 3Ghz dual core pentium?
08:38:38 <Heffalump> or some hard to process patches
08:38:42 <fasta> Heffalump: what's "slow"?
08:38:46 <dons> fasta: never seen that
08:38:47 <Heffalump> oh, not very.
08:38:53 <dons> and i pull 100s of patches from ghc sometimes
08:38:56 <Heffalump> shall we take this to #darcs?
08:39:00 <fasta> sure
08:39:06 <Heffalump> ndm: I was referring to fasta's problem, not yours
08:39:23 <lispy> fasta: maybe hit 'a' next time? ;)
08:39:32 <ndm> Heffalump: fair enough, i can usually get round my problem with d/a/rev and combinations
08:39:33 <lispy> fasta: would be nice to fix it though...
08:39:36 <fasta> lispy: that's beside the point, right..
08:39:42 <lispy> fasta: yes
08:39:45 <dons> fixing bugs is better than introducing new ones
09:07:13 <TaPiOn> hello any one can help me for c programming (win32) ?
09:07:24 <TaPiOn> i search an other cmd like system()
09:18:53 <magnus-> TaPiOn: have a look at the exec* family of functions
09:19:22 <TaPiOn> k
09:19:39 <TaPiOn> tanks
09:25:05 <ndm> TaPiOn: ShellExecute and ShellExecuteEx are the better ways of doing it in Win32
09:25:25 <TaPiOn> ohhh thank you :)
09:25:31 <TaPiOn> API ?
09:26:32 <ndm> TaPiOn: its in the Win32 API
09:26:40 <ndm> @google msdn ShellExecute
09:26:43 <lambdabot> http://forums.microsoft.com/MSDN/ShowPost.aspx?PostID=124382&SiteID=1
09:26:43 <lambdabot> Title: help with Shellexecute - MSDN Forums
09:26:51 <ndm> @google msdn ShellExecuteEx
09:26:54 <lambdabot> http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/reference/functions/shellexecuteex.asp?frame=true
09:27:01 <TaPiOn> thanks
09:27:02 <ndm> the second one is the one to hit
09:27:24 <ndm> dons: i hear its entirely your fault that haskell went down...
09:27:38 <araujo> morning!
09:27:45 <araujo> yay!, haskell.org is back!
09:28:56 <abc> is there a function from Int -> [Int]
09:29:12 <abc> that will change 123 into [1,2,3]
09:29:22 <abc> thanks
09:29:59 <ndm> > let f = map (read . (:[])) . show in (f 123) :: [Int]
09:30:06 <lambdabot>  [1,2,3]
09:30:22 <ndm> abc ^^^
09:30:50 <ndm> @hoogle digitTo
09:30:51 <lambdabot> Char.digitToInt :: Char -> Int
09:31:06 <ndm> > let f = map digitToInt . show in f 123
09:31:07 <lambdabot>  [1,2,3]
09:31:14 <ndm> abc, much nicer version ^^^
09:31:51 <abc> thanks for your help
09:32:05 <abc> i am newbie to haskell
09:32:25 <abc> :-)
09:32:26 <ndm> why are you learning? what motivated you to start it?
09:32:34 <abc> elegance
09:32:56 <ndm> cool, well it is elegant, as that above example shows hopefully :)
09:33:42 <ndm> have you got something you're trying to write in particular? or just play hacking for now?
09:33:59 <abc> I am trying to implement Luhn function
09:34:16 <abc> actually I am playing for the fun this language gives
09:34:44 <abc> you know what Luhn function does?
09:34:55 <abc> given an Int -> Bool
09:35:11 <abc> credit card validation number
09:35:24 <ndm> ah, thats cool
09:35:31 <ndm> hence the need for digits, i see :)
09:35:53 <abc> i am not sure if I am not sure if I am going in the right direction but I think its the smartest way
09:36:09 <ndm> seems sensible, its a long time since i did a credit card validator
09:36:10 <abc> change the Int to [Int] then do the stuff using cool list functions
09:36:22 <ndm> @wikipedia Luhn
09:36:25 <lambdabot> No Result Found.
09:36:31 <abc> not difficult
09:36:58 <abc> http://en.wikipedia.org/wiki/Luhn_algorithm
09:37:06 <abc> if you are interested
09:37:07 <abc> ;-)
09:37:35 <ndm> yeah, i found that easily, just wiki'd it
09:37:53 <ndm> looks like you need a function that does the double repeatedly until you get a single digit
09:38:00 <ndm> and a function to apply to alternate digits
09:38:29 <abc> double is easy
09:38:37 <abc> and even counting
09:39:14 <ndm> yeah, looks quite doable
09:39:15 <abc> actually for you it seems that from start to end is easy hehe ;-)
09:39:26 <abc> for me the first part was challenging
09:39:33 <ndm> hehe, practice makes perfect
09:39:41 <ndm> thats exactly the sort of thing hsakell is great at
09:40:03 <abc> in a couple of days time I will be helping people ;-)
09:40:08 <ndm> hehe, good good
09:40:10 <abc> I think its a nice place to hang here
09:40:17 <abc> people seems to be nice
09:40:18 <ndm> well once you've done it, blog it, and link to the wikipedia article
09:40:38 <abc> that's exaactly what I am going...it seems that you read my mind ;-)
09:40:43 <abc> www.gaetanocaruana.com
09:40:46 <abc> it will be up soon
09:40:53 <abc> I will mention you
09:41:19 <ndm> thanks :)
09:41:45 <ndm> if your blog is haskell related, add it to planet.haskell.org
09:41:57 <abc> do you hang often here?
09:42:03 <abc> oh thanks I will ;-)
09:42:18 <ndm> yeah, usually
09:42:34 <abc> fine :-)
09:42:35 <ndm> its nice, people are friendly, and can solve very difficult problems
09:42:42 <ndm> plus lambdabot is wonderful :)
09:43:22 <abc> yea infact I am noting what commands are you giving to her
09:44:36 <emu> i got a spam with a subject drawn from Asimov's "Foundation"..yow
09:44:52 <ndm> @list
09:44:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:44:58 <ndm> thats a list of all the commands
09:45:14 <ndm> you'll see @hoogle, @index, @type, > (evaluation) and @pl quite a bit in here
09:45:47 <abc> ic :-)
09:45:51 <emu> @pl \a b c d e -> a (b c) (d e)
09:45:52 <lambdabot> (((.) .) .) . (.)
09:45:55 <abc> i will have a look at them
09:46:02 <mux> ?version
09:46:02 <lambdabot> lambdabot 4p227, GHC 6.5 (OpenBSD i386)
09:46:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:58:00 <lennart> ?users
09:58:00 <lambdabot> Maximum users seen in #haskell: 238, currently: 230 (96.6%), active: 27 (11.7%)
09:58:40 <lennart> ?pl \ f x -> f x x x x x x x x x x x x
09:58:42 <lambdabot> join . join . join . join . join . join . join . join . join . join . join
09:59:28 <roconnor> ?pl \f x y -> f x y y x y y y x x y x
09:59:32 <ibid> ?pl \f x y -> f x y x y x y x y x y x y x
09:59:33 <lambdabot> join . (flip .) . flip flip id . (ap .) . join . (flip .) . join . (flip .) . flip flip id . (ap .) . flip flip id . (ap .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .)
09:59:33 <lambdabot> optimization suspended, use @pl-resume to continue.
09:59:44 <lambdabot> join . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id
09:59:44 <lambdabot> . (ap .) . (flip =<<)
09:59:44 <lambdabot> optimization suspended, use @pl-resume to continue.
10:00:07 <ibid> ?pl \f x y z -> f x y z z y
10:00:08 <lambdabot> flip flip id . (liftM2 flip .) . flip flip id . ((flip . (ap .)) .)
10:00:23 <ibid> ?type \f x y z -> f x y z z y
10:00:25 <lambdabot> forall t t1 t2 t3. (t -> t2 -> t1 -> t1 -> t2 -> t3) -> t -> t2 -> t1 -> t3
10:00:32 <abcde`> flippin' 'eck
10:00:35 <abcde`> (pun intended)
10:01:08 <lennart> @djinn  (t -> t2 -> t1 -> t1 -> t2 -> t3) -> t -> t2 -> t1 -> t3
10:01:09 <lambdabot> f a b c d = a b c d d c
10:01:42 <roconnor> ?. djinn type \f x y z -> f x y z z y
10:01:44 <lambdabot> f a b c d = a b c d d c
10:01:57 <roconnor> ?. pl . djinn type \f x y z -> f x y z z y
10:01:59 <lambdabot> f = flip flip id . (liftM2 flip .) . flip flip id . ((flip . (ap .)) .)
10:02:17 <lennart> ?pl \ a b c d e f g h i j k l m n o p q r s t u v w x y z -> h e l l o w o r l d
10:02:32 <lambdabot> const (const (const (((const . const . (const .)) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .
10:02:33 <lambdabot> ) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . flip (flip . (
10:02:33 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((ap .
10:02:33 <lambdabot> ) .) . (((flip .) .) .) . flip flip id . (ap .) . flip id))))
10:02:34 <lambdabot> optimization suspended, use @pl-resume to continue.
10:02:45 <ibid> @pl-resume
10:03:15 <ibid> hrm
10:03:16 <lambdabot> const (const (const (((const . const . ((const . const . const . ((const . const) .) . ((const .) .)) .)) .) . ((((const .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((
10:03:16 <lambdabot> const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .)
10:03:16 <lambdabot>  .) . ((((flip .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . flip flip
10:03:16 <lambdabot> id . (ap .) . flip id))))
10:03:18 <lambdabot> optimization suspended, use @pl-resume to continue.
10:03:30 <roconnor> poor pl
10:03:36 <lennart> yes
10:03:42 <ibid> ?pl \x y z -> x y z z y
10:03:43 <lambdabot> join . (flip .) . flip flip id . (ap .)
10:04:33 <emu> ?pl \f x -> f x x
10:04:33 <lambdabot> join
10:04:46 <lennart> ?pl \ f g h x -> f (g x) (h x)
10:04:46 <lambdabot> liftM2
10:05:02 <ibid> ?pl \x -> x xx
10:05:03 <lambdabot> ($ xx)
10:05:04 <ibid> ?pl \x -> x x
10:05:05 <lambdabot> join id
10:05:06 <lennart> ?pl \ f g h x -> f (g x) h
10:05:06 <lambdabot> (flip .) . (.)
10:05:25 <ibid> ?pl \x -> x x x
10:05:25 <lennart> ?pl \ f g h x -> f g (h x)
10:05:25 <lambdabot> ((.) .)
10:05:26 <lambdabot> join (join id)
10:05:34 <ibid> ?pl \x -> x x x x
10:05:35 <lambdabot> join (join (join id))
10:05:41 <ibid> ?pl \x -> x x x
10:05:42 <lambdabot> join (join id)
10:06:06 <ibid> ?pl \f x -> x x x
10:06:07 <lambdabot> const (join (join id))
10:07:10 <emu> i call this one the Haskowl:
10:07:12 <emu> ?type  ((.)$(.))
10:07:13 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
10:07:38 <lennart> ?. djinn type ((.)$(.))
10:07:40 <lambdabot> f a b c d = a b (c d)
10:07:59 <emu> >  ((.)$(.)) (==) 1 (1+) 0
10:08:00 <lambdabot>  True
10:09:17 <lennart> aha, the owl is B'
10:17:37 <abc> cya guys...thanks again ndm_
10:17:40 <dons> just before I fall asleep, I've made a little section for fun combinators we find with @pl here, like the owl. http://haskell.org/haskellwiki/Pointfree#Combinator_discoveries
10:17:45 <lambdabot> Title: Pointfree - HaskellWiki, http://tinyurl.com/fwu37
10:17:47 <dons> and swing.
10:17:55 <ndm_> abc: no probs
10:17:58 <dons> so in future if you find something fun, add it and give it a name :)
10:17:59 <abc> :-)
10:18:02 <abc> \quit
10:18:28 <mauke> dons: unbalanced ')' in owl
10:18:37 <dons> fixied
10:18:49 <psi> ?type \x -> x x
10:18:50 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:18:50 <lambdabot>    Expected type: t
10:21:44 <psi> you can't construct the Y combinator in haskell, can you?
10:21:53 <mauke> ?type fix
10:21:54 <lambdabot> forall a. (a -> a) -> a
10:22:15 <xerox> psi: yup, either using language recursion, or by writing a datatype encapsulating it.
10:22:37 <psi> what does language recursion mean?
10:24:56 <psi> what does fix do?
10:26:57 <mauke> > fix (\f n -> if n < 2 then 1 else n * f (n - 1)) $ 5
10:26:59 <lambdabot>  120
10:27:57 <psi> cool
10:29:26 <roconnor> psi: http://r6.livejournal.com/95963.html
10:29:29 <lambdabot> Title: r6: Y Combinator in Haskell
10:29:42 <psi> thanks
10:35:32 <fasta> How can I take the logarithm of a value of type Integer?
10:35:45 <mauke> ?type log
10:35:46 <lambdabot> forall a. (Floating a) => a -> a
10:36:02 <xerox> ?type log . fromInteger
10:36:02 <mauke> > log (fromInteger 42)
10:36:04 <lambdabot> forall a. (Floating a) => Integer -> a
10:36:04 <lambdabot>  3.7376696182833684
10:36:13 <xerox> ?type log . fromIntegral
10:36:14 <lambdabot> forall a b. (Floating b, Integral a) => a -> b
10:36:18 <fasta> fromInteger, thanks
10:36:57 <psi> can't quite wrap my head around that fix2
10:37:15 <mauke> fix2 is just fix with a restricted type
10:37:32 <mauke> or not even that
10:37:38 <roconnor> mauke: fix2 f = f (fix2 f)
10:37:50 <mauke> ?type let fix2 f = f (fix2 f) in fix2
10:37:52 <lambdabot> forall t. (t -> t) -> t
10:38:02 <mauke> yeah, plain fix
10:38:10 <roconnor> psi: but you understand fix?
10:38:41 <psi> no, I just know how it's used
10:39:18 <roconnor> As you start unfolding fix and fix2 you end up getting f (f (f (f (f (f (f (fix2 f)...)
10:39:35 <roconnor> basically you have as many fs as you need
10:39:57 <roconnor> hopefully you will only need a finite number of unrollings (this is possible thanks to laziness)
10:40:19 <roconnor> so f will do something before looking at its argument
10:40:35 <xerox> > fix ((2:) . scanl1 (const ((/2) . ap (+) (2/)))) !! 1000
10:40:36 <lambdabot>  1.414213562373095
10:41:03 <psi> Ah, I think I see it
10:41:25 <roconnor> so only in some case will f's argument actually be used
10:41:46 <roconnor> and in the other cases the argument will be discarded
10:41:58 <roconnor> stoping the potentially infinite unfolding
10:43:05 <psi> it is a bit mind twisting
10:43:12 <emu> > take 10 $ fix (\f -> 1 : 1 : zipWith (+) f (tail f))
10:43:13 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
10:43:27 <roconnor> psi: yes.
10:43:38 <roconnor> psi: you should try circular programming
10:43:50 <emu> ?pl \f -> 1 : 1 : zipWith (+) f (tail f)
10:43:51 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
10:44:15 <emu> > take 10 . fix $ (1:) . (1:) . ap (zipWith (+)) tail
10:44:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
10:46:58 <psi> do people use fix in real programs?
10:47:54 <musasabi> psi: at least mfix is used in real programs.
10:48:45 <psi> ?type mfix
10:48:47 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
10:50:26 <psi> I just know that Y is a cool thing in lambda calculus, because you can't name things there, but that's not an issue in haskell.
10:50:59 <psi> name functions
10:51:55 <psi> brb.
10:52:00 <emu> the creation of artificial intelligence will probably require extensive understanding of fixed-points oO'
10:53:05 <vincenz> is it just me or is the new yahoo even worse than the previous one
10:53:11 <vincenz> (yahoo-mail)
10:55:58 <dolio> ?hoogle curry
10:55:59 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
10:55:59 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
10:56:34 <emu> ?type chr
10:56:35 <lambdabot> Int -> Char
10:56:52 <emu> > ap zip . map chr $ [65..75]
10:56:52 <lambdabot>  Couldn't match `(->) [a]' against `[]'
10:56:59 <emu> > ap zip (map chr) $ [65..75]
10:57:01 <lambdabot>  [(65,'A'),(66,'B'),(67,'C'),(68,'D'),(69,'E'),(70,'F'),(71,'G'),(72,'H'),(73...
10:57:21 <Syzygy-> @hoogle ap
10:57:23 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
10:57:23 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
10:57:23 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
10:57:38 <Syzygy-> ap is monadic (.), is it?
10:58:24 <emu> or monadic ($)
10:58:45 <emu> ?type ($)
10:58:46 <lambdabot> forall b a. (a -> b) -> a -> b
10:58:47 <Syzygy-> Ah.
10:58:51 <Syzygy-> Right.
10:58:57 <Syzygy-> Yeah, it wouldn't be (.), doh.
11:00:20 <glguy> (.) is a special case of fmap :)
11:03:13 <dolio> ?. pl undo \m n -> do { f <- m ; a <- n ; return (f a) }
11:03:14 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
11:03:20 <dolio> Whoa.
11:04:08 <psi> I'm a bit confused as to how the type of fix is determined by the compiler
11:04:16 <emu> ?type fix
11:04:17 <lambdabot> forall a. (a -> a) -> a
11:05:19 <psi> where fix f = f (fix f)
11:05:25 <dolio> fix f = let x = f x in x
11:05:50 <dolio> So, f is a function that when applied to a value, gives a value of the same type.
11:06:03 <dolio> Otherwise you couldn't re-feed it into f.
11:06:13 <dolio> And fix returns a value of that type.
11:07:45 <monochrom> Using dolio's equation.  Let's give x a type; since we don't know what it should be yet, no harm to use a variable, let's say "a".  Then from "x = f x", f :: a->a.
11:08:33 <monochrom> Type inference is a special case of logic deduction.  How do you do it?  Logically, carefully, patiently.
11:09:07 <psi> hm, I see. his definition was a bit different from mine, let me wrap my head around it
11:10:19 <dolio> That's the way it's actually defined in the libraries, although they're equivalent in effect.
11:10:27 <dolio> Both lead to f (f (f...
11:10:42 <psi> right
11:11:16 <monochrom> Using psi's equation.  Let's give "fix f" a type; again use a variable like "a" for the moment and see what happens.  Then from "f (fix f)", f::a->a.  Then from "fix (f :: a->a)  :: a", fix :: (a->a)->a.
11:11:28 <dolio> Although, for a while, I didn't realize that the let... version was the same as the Y combinator.
11:13:49 <dolio> Using a combinator for recursion can let you do cute things, though, like this:
11:13:55 <dolio> http://www.haskell.org/hawiki/MemoizingRecursion
11:13:59 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki, http://tinyurl.com/gjxoc
11:14:36 <psi> monochrom: how do you know f::a->a?
11:14:44 <dolio> That has a variant of the Y combinator that automatically memoizes its results.
11:15:06 <weitzman> x :: a
11:15:18 <weitzman> f x -> f :: a -> ...
11:15:27 <weitzman> And x :: a -> f :: a -> a
11:15:54 <weitzman> Since f x :: a
11:16:10 <monochrom> We assigned "fix f" to be of type "a".  That means "(fix f :: a) = f (fix f :: a)".  f takes a parameter of type a and returns something of type a.
11:16:12 <weitzman> Since f x = x
11:16:17 <psi> weitzman: there was no x there
11:17:00 <weitzman> As long as (f x) and x have the same type, a
11:17:10 <weitzman> And f must have type a -> ???
11:17:15 <weitzman> Bam
11:17:22 <glguy> > take 10  $ fix ((1:) . scanl (+) 1)
11:17:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
11:18:03 <psi> monochrom: ah! I didn't look on the left side.
11:20:14 <dolio> Let's see, what was the one xerox did the other day...
11:20:51 <monochrom> He photocopied the Haskell manuals? :)
11:21:51 <glguy> > let factorial = fix (\f x -> if x > 1 then x * f (x-1) else 1) in factorial 5
11:21:52 <lambdabot>  120
11:21:54 <dolio> It was a fixed point for generating successive approximations to sqrt 2.
11:22:07 <glguy> based on the continued fraction?
11:22:12 <glguy> [1,2,2,2...]?
11:22:27 <dolio> No. It used the averaging method.
11:22:32 <glguy> ah
11:23:37 <weitzman> > take 30 $  fix ((1 :) . (1 :) . intersperse 1 . map (+ 1))
11:23:38 <lambdabot>  [1,1,2,1,2,1,3,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
11:24:13 <int-e> > take 30 $  fix (intersperse 1 . (1 :) . map (+ 1))
11:24:14 <lambdabot>  Exception: <<loop>>
11:24:18 <int-e> hmm :(
11:24:59 <dolio> > (fix $ scanl (const ((/2) . ap (+) (2/))) 1) !! 1000
11:25:00 <glguy> > take 4 $ map (foldr1 (\x y -> x + 1/y) . (1:)) $ inits [2,2..]
11:25:01 <lambdabot>  1.414213562373095
11:25:02 <lambdabot>  [1.0,1.5,1.4,1.4166666666666667]
11:25:12 <glguy> (using the continued fraction)
11:25:55 <int-e> > fix ((\ ~(a:b) -> a:b)  . intersperse 1 . (1 :) . map (+ 1))
11:25:57 <lambdabot>  [1,1,2,1,2,1,3,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1...
11:26:56 <int-e> Nextgens_: very funny
11:26:56 <mauke> Nextgens_: you still fail at hax0ring
11:26:58 <weitzman> I seem to have generated http://www.research.att.com/~njas/sequences/A091090 possibly
11:27:00 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences, http://tinyurl.com/gu6le
11:27:31 <lispy> would it be possible to modify haskell so that it's lazy enough for things like (length infiniteList) > 10, work?
11:27:50 <mauke> only if you make numbers non-atomic or something
11:28:18 <lispy> mmmm...but the length computation is non-atomic
11:28:35 <lispy> i guess it's probably pretty expensive to keep checkining if the length is > 10 though
11:28:50 <glguy> block Nextgens_ please, he is phish for nickservpasswords
11:29:34 <roconnor> lispy: typedef Integer = [Int]
11:29:46 <glguy> I've already reported this to nalioth
11:29:58 <lispy> glguy: tanks!
11:30:20 <weitzman> lispy: surface-to-air missles!
11:30:58 <lispy> 11:29 *** Undefined CTCP query received. Silently ignored
11:31:00 <Igloo> The above would work with genericLength and Nat = Succ Nat | Zero
11:31:11 <lispy> i wish it told me who sent that
11:31:19 <Syzygy-> lispy: Lucky you. My client dumped out the entire contents.
11:31:26 <glguy> "silently ignored"?
11:31:26 <weitzman> It would depend on how you implemented the length function
11:31:28 <Igloo> More reasonable is to write a lengthAtLeast, though
11:31:29 <glguy> it told you tho
11:31:51 <int-e> "--- Received a CTCP THIS nickname is owned by someone else from Nextgens_ (to #haskell)"
11:31:52 <weitzman> length = Succ (length rest) or length = length rest .... Stick Succ() way inside
11:32:03 <glguy> 13:29 Nextgens_ [i=xterm@gateway/tor/x-a9ff32413fc71714] requested unknown CTCP  SOMEBODY from #haskell: has sent you a message, to read it type:  /server read 1
11:32:11 <glguy> that's what I get
11:32:38 <lispy> Igloo: ah
11:32:53 <int-e> and I wonder how stupid a client must be for that to work.
11:32:57 <lispy> i don't actually have a use for this, just wondreing
11:35:34 <glguy> int-e: stupid enough to actualy type "/msg nextgens_ identify..."
11:36:05 <glguy> heh, it's not even like a query window would pop up, you'd actually have to type in the guy's name :)
11:36:44 <int-e> glguy: first the client would have to display it in some convincing way.
11:36:54 <int-e> (or so I hope)
11:37:45 <glguy> I was at the post office today... there were 3 desk clerks. one was imcompetent and took forever to do simple things. one had a crashed computer and could not process customers, and one was looking up regulations in a reference for a customer and filling out 3 passport applications
11:37:56 <glguy> I was at the clerk with the crashed computer
11:38:03 <glguy> the line just kept getting longer and longer
11:38:09 <glguy> people were getting *mad*
11:38:34 <SamB> the first two should have swapped computers
11:38:49 <glguy> and also, before we were helped, the lady in front of us took a call on her cell phone *while* the clerk was asking her questions to complete her transaction
11:39:01 <SamB> eek
11:39:03 <glguy> and stopped asking questions and seemed to assume the default answers
11:39:10 <glguy> what a whore
11:39:23 <glguy> that is probably why postal workers kill people
11:39:29 <Stinger_> heh
11:39:40 <glguy> I'd have shipped her package to "City Dump"
11:39:46 <akemp> Anyone here knowledgeable in the cgi-compat library?
11:39:50 <glguy> or rerouted it through under my feet
11:39:56 <SamB> haha
11:40:04 <SamB> I think there must surely be rules against that
11:40:07 <Lemmih> akemp: Kinda.
11:40:10 <glguy> oh , there are
11:40:11 <SamB> the latter, I mean
11:40:11 <lispy> akemp: kinda
11:40:12 <SamB> not the former
11:40:20 <glguy> posted in THREE places in the post office
11:40:22 <glguy> huge signs
11:40:33 <lispy> akemp: i used the fastcgi library which is on top of it recently
11:40:34 <glguy> out of curtesy to the other custumers
11:40:44 <glguy> please do not talk on your cell phone when approaching the counter
11:40:53 <glguy> but they dont' say "Don't take any calls at the counter"
11:40:57 <glguy> that one was assumed
11:41:13 <akemp> Silly question, but I've gotten busy and haven't coded in a while.  Trying to rub off the rust.  Question: I'm using cgi-compat to do service a request, but then I need to do some IO actions.  How do I do IO in the middle of the CGI monad?
11:41:45 <Lemmih> akemp: Use liftIO.
11:41:58 <lispy> do a <- liftIO $ ....
11:41:59 <glguy> does CGI transform the IO monad then?
11:42:07 <SamB> glguy: must surely wrap it
11:42:07 <lispy> CGI is a transformer, yes
11:42:26 <Lemmih> CGIT is a transformer. CGI = CGIT IO.
11:42:29 <Stinger_> http://en.wikipedia.org/wiki/Going_postal wikipedia has an entry for everything!
11:42:47 * SamB points out that you can have a MonadIO that isn't a monad transformer
11:42:51 <SamB> @type lift
11:42:53 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:43:15 <akemp> That's what I thought, but I'm getting one of those Haskell uber-errors about overlapping instances created by my use of liftIO.
11:43:22 <glguy> ?type liftIO
11:43:23 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
11:43:23 <lispy> ah, so CGI isn't a transformer it's just a wraper?
11:43:29 <SamB> akemp: huh?
11:43:31 <glguy> ?instances MonadIO
11:43:32 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
11:43:33 <SamB> paste something!
11:43:40 <akemp> Will do
11:43:44 <SamB> @paste
11:43:45 <lambdabot> http://paste.lisp.org/new/haskell
11:44:02 <lispy> akemp: i noticed he helloworld example in fastcgi required -fallow-overlapping-instances
11:44:11 <SamB> lispy: eek!
11:44:29 <SamB> okay, so -fallow-overlapping-instances must be needed for most anything fastcgi!
11:44:37 <SamB> @where fastcgi
11:44:38 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/
11:45:00 <lispy> but, i didn't worry about it...i did wonder if it's so you can do both fastcgi or normal cgi with pretty much teh same code
11:45:03 <lisppaste2> akemp pasted "CGI probs" at http://paste.lisp.org/display/26587
11:45:16 <akemp> paste is tasty
11:46:07 <SamB> @where+ fastcgi http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/doc/
11:46:08 <lambdabot> Done.
11:46:10 <SamB> @where fastcgi
11:46:12 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/doc/
11:46:33 <akemp> The upshot is that I'm using CGI to grab a URI from the CGI call, then using HTTP to retrieve the url.  CGI uses the CGI monad; HTTP uses the IO monad.
11:47:34 <lispy> akemp: i'm not sure what to make of that
11:47:45 <lispy> akemp: if you allow overlapping instances does the code work?
11:48:07 <magnus-> Hi.. is there any haskell option to never allow ignoring return values inside do constructs?
11:48:16 <magnus-> ghc option
11:48:21 <SamB> magnus-: it would be silly!
11:48:55 <magnus-> SamB: why?
11:49:24 <mauke> hmm, you'd have to override >> somehow
11:49:32 <SamB> because half the times things return ()?
11:49:38 <SamB> er, *time.
11:49:54 <lispy> magnus-: i think it's better to wrap up that exec function take advantage of the definition of (>>=)
11:50:14 <akemp> lispy: -fallow-overlapping-instances worked, though I'm not too happy with it.  Don't really know how the solution solved the problems (aside from allowing overlapping instances...).
11:50:49 <magnus-> SamB: We can then make an exception for (). It is fine to ignore ()
11:50:50 <dolio> You'd be unable to write anything with do notation, then, since the last expression in a do has to not be a pattern match.
11:50:51 <lispy> akemp: then you might want to talk to bringert...he could probably explain why it's needed
11:51:05 <SamB> lispy: I was about to look at that myself...
11:51:22 <dolio> Or, unable to write anything that doesn't return () itself, then.
11:51:32 <magnus-> dolio: the last expression can of course return whatever it wants
11:52:00 <lispy> magnus-: i could see this as useful
11:52:23 <lispy> magnus-: with the provisions of not caring about () and not caring about the last statement in the do
11:52:51 <mauke> hmm, would redefining >> with a restricted type work?
11:52:53 <lispy> i wonder how hard it would be to get that into ghc
11:53:17 <chessguy> can denotational semantics be used to describe the semantics of functional programming languages?
11:53:46 <lispy> chessguy: that's how denotational sematics are often use, from what i understand
11:54:19 <chessguy> anybody know of such a description for, say, haskell?
11:54:45 <dolio> I don't think any exist.
11:54:56 <chessguy> boo, hiss!
11:54:57 <lispy> chessguy: iirc, haskell does not have a denotational semantics written down...i seem to recall mention of this in the history of haskell paper
11:55:08 <dolio> They were originally planned, but got left by the wayside.
11:55:10 <chessguy> bad form!
11:55:15 <dolio> Yeah, the history paper talks about it.
11:55:19 <lispy> chessguy: check tackling the awkward squad for some semantics of haskell IO
11:55:20 <akemp> lispy: the problem is working fine, so that looks like a complete solution
11:55:29 <akemp> lispy: s/problem/program
11:55:52 <lispy> akemp: yeah, i'd like to understand this better as well
11:56:00 <chessguy> mmmm, isn't IO done using monads in haskell?
11:56:45 <lispy> yup
11:57:04 <chessguy> then it's over my head at the moment
11:57:11 <lispy> chessguy: tackling the awkward squad would be a good read for you :)
11:57:16 <lispy> it starts very simple
11:58:10 <dolio> Awkward squad covers some of the more interesting areas that would be in such a denotational semantics.
11:58:25 * SamB tried to make WindowMaker think it had segfaulted, but it just died!
11:58:55 <lispy> SamB: you sent it a segfault signal?
11:59:01 <SamB> yes!
11:59:10 <chessguy> wouldn't it be safe to say that using denotational semantics for FP should be much easier than imperative languages?
11:59:15 <SamB> usually when it segfaults it pops up a friendly dialog box offereing to restart it!
11:59:20 <chessguy> since there's no state ?
11:59:23 <SamB> er. spelled better.
12:00:34 <dolio> That's probably a safe thing to say.
12:01:23 <chessguy> seems to me, that's the crux of why FP is less likely to have mistakes
12:01:31 <dolio> C is, essentially, always in the IO monad.
12:01:32 <SamB> or at least the state is kept well away from ordinary functions
12:01:58 <dolio> So if it's harder to give semantics to something like IO, then giving semantics to C would probably be harder than giving semantics to something where only a small part is IO.
12:02:07 <SamB> yeah
12:02:59 <SamB> @where cgi-compat
12:03:00 <dottedmag> \
12:03:00 <lambdabot> I know nothing about cgi-compat.
12:03:06 <dottedmag> sorry
12:03:41 <SamB> @google "cgi-compat" haskell
12:03:47 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/doc/
12:05:59 <chessguy> @hoogle cgi-compat
12:06:00 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-compat'
12:06:37 <SamB> @where cabal-get
12:06:38 <lambdabot> http://hackage.haskell.org/darcs/cabal-get-bootstrap/
12:07:27 <chessguy> "In short, Haskell is the worlds finest imperative
12:07:27 <chessguy> programming language.
12:07:28 <chessguy> "
12:08:29 <Tobsan> ?
12:08:54 <Lemmih> !
12:09:02 <chessguy> a quote from that awkward squad paper
12:09:14 <SamB> Lemmih: do you know where I can get cabal-get?
12:09:22 <Lemmih> chessguy: I don't think Tobsan saw that quote.
12:09:26 <SamB> without needing to have it first in order to compile it?
12:09:41 <chessguy> oh, whoops
12:09:42 <Lemmih> SamB: It's distributed with Cabal.
12:09:54 <SamB> Lemmih: ah
12:11:01 <SamB> @where+ cabal-get Same place as Cabal!
12:11:02 <lambdabot> Done.
12:11:48 <Lemmih> (cabal-get is now cabal-install, btw)
12:12:26 <dolio> So, what has Haskell been optimized for that makes it deficient compared to Lisp? :)
12:13:19 <SamB> @where+ cabal-get cabal-get is now cabal-install, and is in Cabal's source tree
12:13:20 <lambdabot> Done.
12:16:42 <integral> dolio: readability?
12:17:18 <SamB> Lemmih: how do I build it?
12:17:25 <dolio> Heh.
12:20:40 <Lemmih> SamB: With cabal.
12:21:33 <SamB> Lemmih: how come there isn't anything in dependencies/
12:22:43 <Lemmih> I don't even see a dependencies/ directory.
12:23:43 <Lemmih> Ah, now I see it.
12:23:47 <SamB> the Cabal/dependencies one ?
12:25:34 <Lemmih> xerox: What's up with cabal-install?
12:28:25 <SamB> it will be really nice when it comes with GHC...
12:29:20 <SamB> @seen xerox
12:29:21 <lambdabot> xerox is in #perl6, #haskell.it, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 1h 48m 46s ago.
12:29:35 <SamB> @whensleeps xerox
12:29:36 <lambdabot> Unknown command, try @list
12:30:02 <SamB> @version
12:30:03 <lambdabot> lambdabot 4p227, GHC 6.5 (OpenBSD i386)
12:30:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:30:25 * SamB is using that URL to get to dons's webpage
12:34:55 * SamB wonders what http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html indicates about xerox's bed time
12:34:57 <lambdabot> Title: #haskell @ freenode.org stats by dons, http://tinyurl.com/kpre5
12:38:01 <Igloo> What timezone are the stats in?
12:39:04 <dolio> Heh, 7th most used word is monad.
12:40:39 <chessguy> hehe. "lambdabot is a very aggressive person. He/She attacked others 87 times."
12:40:53 <chessguy> Poor lambdabot, nobody likes him/her. He/She was attacked 37 times.
12:40:53 <chessguy> For example, like this:
12:40:53 <chessguy>      * lambdabot beats up lambdabot
12:40:56 <SamB> hmm. We use think less often than Haskell?
12:41:10 <Cale> Poor lambdabot, nobody likes him/her. He/She was attacked 37 times.
12:41:10 <Cale> For example, like this:
12:41:10 <Cale>      * lambdabot beats up lambdabot
12:41:15 <dolio> I also like dcoutts_'s place using the most foul language at 0.0%.
12:42:03 <chessguy> vincenz talks to him/herself a lot. He/She wrote over 5 lines in a row 529 times!
12:42:16 <Cale> tibbe also makes sailors blush, 0.0% of the time.
12:42:22 <vincenz> yeah yeah
12:42:31 <vincenz> I'm also second after dons
12:42:32 <SamB> hmm, it doesn't collect statistics on how many "boings" someone makes!
12:42:36 <vincenz> and I've been away from IRC for quite a bit!
12:42:43 <Cale> Great, my current quote has a typo.
12:42:54 <vincenz> Cale: like my even spread?
12:43:03 <Cale> hehe
12:43:26 <Cale> vincenz: more even than lambdabot
12:43:49 <SamB> Cale: lambdabot dies randomly and is restarted when dons gets up ;-)
12:44:02 <vincenz> but I've been away from irc quite a bit
12:44:02 <vincenz> log into less, idle more
12:44:02 <vincenz> and still third
12:44:02 <vincenz> o.O
12:44:27 <SamB> vincenz: this is for the year so far
12:45:01 <vincenz> yeah
12:45:05 <vincenz> and I've been gone quite a bit
12:48:29 <dolio> Heh. "Python browser in 25 lines."
12:48:41 <Syzygy-> Oh?
12:48:41 <dolio> All you need is a library that does all the work for you. :)
12:48:44 <Syzygy-> Hehe
12:49:05 <Syzygy-> 25 lines, out of which three are "Import HTTP; import Socket; import Browsing;" ?
12:49:41 <lispy> it's even easier than that
12:49:42 * vincenz snickers
12:49:47 <dolio> I didn't look at the code. That seems pretty low level, though.
12:49:48 <lispy> import win32client.com;
12:49:49 <vincenz> I could write one in haskell in three lines then
12:49:52 <vincenz> module balbla where
12:49:55 <vincenz> import Maincode
12:49:55 <lispy> then just use IE
12:49:59 <vincenz> main = callmaincode
12:50:07 <SamB> lispy: cheating!
12:50:31 <SamB> more to the point, it only works on windows!
12:50:54 <lispy> SamB: what eles is there?
12:51:15 <lispy> SamB: oh
12:51:22 <lispy> SamB: why would you use the internet from dos anyway?
12:51:27 <SamB> um.
12:51:31 <Syzygy-> ...
12:51:35 <SamB> I could never figure that out either, actually!
12:51:53 <SamB> but, there is this thing called Lunix that some people are liking to use
12:52:02 <dolio> Essentially, it's "make a button, make an html window, make a text box..."
12:52:03 <lispy> it would be hard to write a browser as a TSR program
12:52:16 <dolio> "On click, get url contents, feed into html window."
12:53:57 <SamB> okay, I think dcoutts broke it!
12:54:08 <dcoutts__> !?
12:54:08 <lambdabot> dcoutts__: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:23 <SamB> dcoutts: you took out the dependencies for cabal-install!
12:55:03 <dcoutts__> SamB: yes. they were well out of date
12:55:18 <dcoutts__> none of them were being used
12:55:38 <dcoutts__> was I wrong?
12:56:30 <SamB> well, there were a lot of references in the cabal file for cabal-install to things in ../dependencies
12:56:31 <ndm_> dcoutts__, thanks on your GTK + Windows stuff, how long before it ends up in the latest releases of the GTK package and Gtk2Hs?
12:56:36 <dcoutts__> dolio: I've got a browser in 25 lines too, in Haskell with Gtk2Hs and Mozembed
12:56:41 <SamB> however, its possible those were stale too...
12:57:06 <SamB> however, the cabal-install in head does not build!
12:57:19 <SamB> at least, not in any obvious way
12:57:25 <dcoutts__> indeed, we're waiting for xerox's code
12:57:31 <dcoutts__> SamB: I think the only one it needs now is a http backage
12:57:34 <ndm_> dcoutts__, if i use windows do i get mozembed for free? or does it require firefox/extra libs etc?
12:57:41 <dolio> Yeah, I figured it's pretty easy in any decent language that includes an html rendering widget in one of its libraries.
12:58:16 <dcoutts__> ndm_: mozembed for windows is a bit tricky last I looked because they don't normally build gtk+ builds of firefox for windows
12:58:24 * ndm_ imagines an hs-plugins based extension system to the browser
12:58:43 <dcoutts__> ndm_: I've seen some stuff about it though because novel's ports of some gtk/mono stuff uses an embeded browser
12:59:14 <dcoutts__> ndm: as for gtk+ 2.10.x, I'm still waiting for a win32 installer
12:59:42 <SamB> dcoutts: so, are you telling me that some code that is not yet in the repository does not need all these things, but the code there now does?
12:59:42 <dcoutts__> the people who were doing the 2.8.x ones have been a bit quiet
12:59:57 <dcoutts__> SamB: right
13:00:13 <ndm> dcoutts__, what about the threading thing, any updates on that? its holding back GuiHaskell, which has the potential to become quite useful...
13:00:23 <SamB> so... why did you remove the dependencies *before* this code was added to the repo?
13:00:23 <ndm> and will certainly kill WinHugs stone dead
13:00:23 <dcoutts__> SamB: and we don't build the version currently in the repo
13:00:46 <dcoutts__> ndm: we have to talk to JaffaCake about that
13:01:09 <dcoutts__> ndm: he said he'd think about it, after 6.6 is released we can talk to him
13:01:35 <ndm> dcoutts__, cool, thats nice to know
13:01:44 <ndm> in the meantime Yhc is marching onwards
13:01:51 <dcoutts__> good!
13:01:54 <ndm> a port might get to the point of possible soonish
13:02:02 <dcoutts__> cool
13:02:23 <dcoutts__> ndm: I talked with him about it at the msr thing in cambridge, the day before you arrived
13:02:39 <ndm> dcoutts__, yep, you said
13:02:57 <ndm> dcoutts__, oh, we might have a gentoo ebuild at some point soon, turns out of build master is a gentoo guy
13:03:11 <dcoutts__> cool
13:03:22 <dcoutts__> ndm: a gentoo dev or user?
13:03:24 <ndm> any thoughts on that? would the gentoo haskell team rather it was turned over to you?
13:03:40 <ndm> dcoutts__, on linux dev = user (but i think he's more a user than a dev officially)
13:03:47 <dcoutts__> ndm: well you can darcs send it to get it into our repo
13:03:59 <dcoutts__> we can jointly maintain it
13:04:00 <SamB> ndm: not when it comes to packages!
13:04:24 <ndm> sounds best, since you're the more gentoo style people, i think
13:04:38 <dcoutts__> ndm: we have 5 official gentoo haskell devs, these are people who have passed a test and have commit access to the portage tree.
13:04:43 <ndm> he seemed to talk like it was a 10 minute job
13:04:51 <ndm> we now have windows snapshot builds
13:04:51 <SamB> dcoutts: a test?
13:04:52 <dcoutts__> probably is
13:05:01 <lispy> certification
13:05:18 * lispy wants to become a debian dev but never put in the effort to get it
13:05:37 <dcoutts__> ndm: so yes, he and us can maintain it in our darcs repo of haskell ebuilds, that'd work well
13:05:49 <SamB> lispy: do you at least have a properly-signed GPG key?
13:05:51 <ndm> @where gentoo-haskell
13:05:51 <lambdabot> I know nothing about gentoo-haskell.
13:05:58 <ndm> @where gentoo
13:05:59 <lambdabot> I know nothing about gentoo.
13:05:59 <lispy> SamB: nope
13:06:05 <dcoutts__> ndm: see #gentoo-haskell
13:06:20 <dcoutts__> ndm: and then we can take responsability for getting it into portage once it's been tested in our overlay
13:06:33 <ndm> dcoutts__, i was just looking for a darcs repo he can prod it in the direction of
13:06:42 <ndm> ok, thats cool, probably save us some work
13:07:00 <dcoutts__> ndm: darcs get http://haskell.org/~gentoo/gentoo-haskell/
13:07:01 <lambdabot> Title: Index of /~gentoo/gentoo-haskell
13:07:17 <dcoutts__> use --partial I think
13:07:25 <dcoutts__> it's got a lot of change history
13:09:08 <ndm> http://code.google.com/p/yhc/issues/detail?id=34
13:09:11 <lambdabot> Title: yhc - Google Code, http://tinyurl.com/l28z6
13:09:21 <ndm> i've filed a bug and assigned it to someone else, so they'll get round to it sometime
13:10:03 * SamB just tried to cat a URL ;-)
13:10:13 * ndm enjoys opening bugs and assigning them to other people
13:10:17 <dolio> You should switch to Plan9, then.
13:10:41 <SamB> does that actually work on plan9?
13:10:50 <SamB> I thought plumbing was only for mousey things!
13:11:05 <SamB> anyway...
13:11:19 <dolio> Probably not. But you'd no longer think in terms of URLs, but think of URLs as a special case of filesystem paths. :)
13:11:20 <SamB> http://hackage.haskell.org/ModHackage/Hackage.hs?action=xmlrpc is giving me errors, and worse, they are in HTML!
13:11:25 <lambdabot> http://tinyurl.com/kryof
13:11:36 <SamB> well, wait.
13:11:42 <dolio> And maybe then it's possible. :)
13:11:45 <SamB> that might not be what cabal-install sees...
13:13:07 <SamB> hmm, it certainly *LOOKS* like HTML when I strace it...
13:16:26 <SamB> isn't that supposed to give you something in XML-RPC back, now?
13:17:57 <SamB> this is the full URL it was requesting: http://hackage.haskell.org/ModHackage/Hackage.hs?action=xmlrpc/00-latest.txt
13:18:00 <lambdabot> http://tinyurl.com/mzvfy
13:22:02 <SamB> @where HackageDB
13:22:03 <lambdabot> http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
13:26:00 <SamB> @where HaskellDB
13:26:01 <lambdabot> http://haskelldb.sourceforge.net/
13:33:58 <glguy> does anyone remember my rant about how linux will only be adopted by linux devotees girlfriends and friend?
13:34:40 <glguy> well, I found this link on digg, and thought it was funny and relevent http://www.bunchos.com/_wp/?page_id=3
13:34:42 <lambdabot> Title: Bunchos dot Com  Quick guide to get a girlfriend using Linux
13:34:50 <SamB> glguy: what about programmers and tech people?
13:35:17 <Syzygy-> SamB: I'd suppose that anyone being techy enough to end up liking linux is classified as a devotee anyway.
13:35:24 <SamB> heh
13:37:37 <glguy> "Well, it might help if dont call her bitch or diminish her cool Mac laptop."
13:37:44 <SamB> heh
13:39:48 <SamB> why would you have to fake having power...
13:41:33 <glguy> ?
13:41:44 <glguy> are you reading that whole thing on how to get a girlfirend?
13:43:12 <SamB> I think he left out a step...
13:43:17 <SamB> a rather large one!
13:44:31 <glguy> and which step is that?
13:44:33 <Tobsan> hmm, you know how "where" works?
13:44:46 <glguy> yes
13:44:51 <Tobsan> http://paste.lisp.org/display/26591
13:44:57 <Tobsan> what's wrong then`?
13:45:07 <Tobsan> exept me having big tabs
13:45:51 <SamB> Tobsan: I think that *is* the problem
13:46:10 <SamB>                                                                                         where (theCard, newDeck) = getCard indx (Add c h)
13:46:10 <SamB>                                                                                                                 newIndx = randomR (0, sizeH hand)
13:46:21 <SamB> notice how those two bindings aren't lined up?
13:46:42 <Tobsan> SamB i'm afraid i don't really understand
13:47:02 <Tobsan> am i supposed to do two "where"s?
13:47:46 <int-e> Tobsan: no, the first ( and the newIndx should line up.
13:47:50 <SamB> Tobsan: you are supposed to use tabs with width 8
13:48:01 <SamB> or not use any tabs
13:48:05 <Tobsan> SamB i know that x)
13:48:14 <SamB> Tobsan: so *do* that
13:48:15 <Tobsan> int-e ok, i'll check it out
13:48:25 <glguy> http://paste.lisp.org/display/26591#1
13:49:19 <int-e> Add( theCard (shuffle' newIndx newDeck gen) ) is also wrong.
13:49:35 <int-e> Add theCard (shuffle' newIndx newDeck gen)  is what you probably mean
13:49:55 <Tobsan> int-e perhaps...but that doesn't matter i guess
13:50:05 <int-e> no it does matter
13:50:16 <int-e> the two expressions have different meanings
13:50:38 <int-e> Add (a b) applies Add to one argument; Add a b applies Add to two arguments.
13:50:47 <Tobsan> int-e not in this case
13:50:55 <int-e> and Add( a b ) is misleading but means Add (a b)
13:50:58 <Tobsan> i'm positive
13:51:27 <int-e> (Add a b) would be Add a b again.
13:51:58 <Tobsan> int-e ok, well i've changed it, but i'm still getting the same error
13:52:10 <Tobsan> unexpected "="
13:52:34 <int-e> did you look at glguy's annotation?
13:53:16 <int-e> the cause of that error is the indentation problem I think.
13:53:23 <Tobsan> int-e yes, but he didn't change anything, did he?
13:53:34 <int-e> sure, he changed the indentation
13:53:37 <int-e> that's significant
13:54:22 <SamB> yes. seriously. if you switch to width-8 tabs, your program will work (as soon as it lines up)
13:54:29 <glguy> lol, why would I paste it if I didn't change anything??
13:54:30 <int-e> your where clause is equivalent to   where (theCard, newDeck) = getCard indx (Add c h) newIndx = randomR (0, sizeH)    all on the same line, because of the way you indented it.
13:54:31 <Tobsan> int-e ok, i changed my indentation, but now it's complaining about newIndx
13:55:11 <Tobsan> glguy sry, didn't know that indentation mattered
13:55:17 <int-e> then you probably didn't indent it far enough.
13:55:36 <SamB> Tobsan: seriously!
13:55:46 <SamB> set your editor to 8 spaces per tab!
13:55:56 <Tobsan> SamB ok, trtying
13:55:59 <Tobsan> trying*
13:56:34 <Tobsan> SamB you know how to do that in TextPad?
13:56:58 * glguy wonders if textpad has bindings to launch vim...
13:56:58 <Tobsan> nvm, found it
13:59:22 * SamB doesn't know how to get *out* of sane-tab-mode
14:01:04 <SamB> oh, and I use emacs
14:01:39 <ndm> Tobsan: TextPad is great, but set it to convert Tabs to Spaces on both creation and saving. Saves you all this hassle, and you can still use 4 spaces for a tab (which is much nicer in my opinion)
14:01:56 <Tobsan> ndm ok, thanks
14:01:58 <ndm> Tobsan: and use WinHugs, which nicely integrates with TextPad :)
14:02:08 <Tobsan> ndm i do
14:02:22 <ndm> good good :)
14:02:38 <Tobsan> bnut about my code...it complaines again
14:02:43 <ndm> SamB: sane-tab-mode == ugly-tab-mode
14:02:44 <Tobsan> (unexpected symbol "newIndx")
14:02:45 <SamB> Yeah, I don't think the tab key should get you a tab char either ;-)
14:03:06 <SamB> by sane-tab-mode, I mean the tabstops are 8 characters apart
14:03:22 <ndm> in textpad, convert tabs to spaces on creation gives you "never put a tab in my document" mode, which is what everyone should use
14:03:22 <SamB> nothing to do with the tab key!
14:03:34 <ndm> no one should ever use tabs, then we'd have no issues
14:03:43 <Tobsan> i don't really care about the tabs...'
14:03:45 <ndm> Tobsan: newIndex?
14:03:46 <SamB> this is true
14:03:50 <Tobsan> ndm yes
14:03:58 <ndm> Tobsan: paste your code, and the error message
14:04:00 <ndm> @paste
14:04:00 <lambdabot> http://paste.lisp.org/new/haskell
14:04:09 <Tobsan> ndm, http://paste.lisp.org/display/26591
14:04:27 <SamB> but, by the same token, there would be no need to set tabs to display at different widths ;-)
14:04:28 <Tobsan> Syntax error in input (unexpected symbol "newIndx")
14:05:25 <ndm> Tobsan: paste edited with my version, which should fix that
14:05:31 <ndm> its the indentation again, i think
14:05:31 <int-e> Tobsan: that's the old code.
14:06:06 <int-e> Tobsan: and you're not indenting newIndx far enough now I think. The 'n' has to line up with the first ( on the previous line.
14:06:09 <Tobsan> are you saying all my errors are indent-problems?
14:06:23 <int-e> no, but all your syntax errors are.
14:06:35 <int-e> or so I think right now.
14:07:31 <mauke> rule of thumb: put a linebreak after each "do" and "where"
14:07:56 <Tobsan> lol, i had no idea that the indentation mattered that much
14:08:03 <Tobsan> but now that part works
14:10:50 <Tobsan> thanks guys, i think i cleared most of it there
14:16:25 <glguy> I'm tired of "news headlines" with question marks in them (especially after watching jon stewart rip into them)
14:17:55 <Cale> glguy: indeed
14:18:12 <Cale> glguy: I even hate them on Slashdot, when I bother to read Slashdot.
14:19:20 <glguy> I wish more people reacted to media garbage like I do, it might slow down
14:19:31 <glguy> when I hear "are you getting jewed? find out more at 10"
14:19:36 <glguy> I immediately change the channel
14:19:50 <Cale> Jewed? They can say that on TV?
14:19:53 <ndm> "jewed?"
14:20:03 <ndm> i can't beleive they can!
14:20:25 <ihope> Can they?
14:20:26 <glguy> yeah... i guess they don't say that
14:21:08 <Cale> All this crap about terrorism though
14:21:36 <ndm> but i agree with the point, ITV news in the UK is now a succession of adverts for upcoming ITV programs - "Has a cure to the superbug been found?" - answer, watch a program on tomorrow to find out
14:23:40 <Cale> There has never been a significant terror threat. Each year, more people die in Canada from automobile accidents than all the people killed by terrorism around the world.
14:24:21 <glguy> Cale: you're never going to make money with an honest attitude like that
14:24:51 <glguy> the trick is to be a piece of shit marketing person
14:25:56 <glguy> hmm, I'm a very angry person
14:26:16 <ndm> what scares me is that you can't bring water on a flight, but semtex is ok
14:26:27 <glguy> semtex?
14:26:39 <ndm> @wikipedia Semtex
14:26:42 <lambdabot> No Result Found.
14:26:57 <glguy> I'm not the only one that doesn't know what it is then :)
14:27:09 <mauke> Semtex is a brand of energy drink manufactured in the Czech Republic.
14:27:12 <ndm> @tell dons @wikipedia is just totally broken...
14:27:12 <lambdabot> Consider it noted.
14:27:17 <mauke> http://en.wikipedia.org/wiki/Semtex_%28drink%29
14:27:19 <lambdabot> http://tinyurl.com/r7rag
14:27:22 <ndm> Semtex is a general-purpose plastic explosive
14:27:37 <ndm> a bomb thats really powerful, light, and plasticy
14:28:07 <ndm> As little as 250g can down an airliner
14:28:13 <ndm> thats a nice statistic :)
14:29:26 * ndm adds to his Christmas list
14:31:17 <glguy> ?localtime ndm
14:31:18 <lambdabot> Local time for ndm is 23 September 2006 10:30 pm
14:31:27 <glguy> good... you don't live anywhere near me
14:32:36 <Tobsan> haha
14:32:45 <Tobsan> ndm you live in UK?
14:32:57 <ndm> Tobsan: yep
14:33:08 <ndm> off to watch tv now (the shining), bye
14:33:17 <Tobsan> :o Jack nicholson
14:34:43 <Patterner> ?localtime glguy
14:34:44 <lambdabot> Local time for glguy is Sat Sep 23 16:34:22 2006
14:45:47 <glguy> This just in on digg... "Is Debian dying?"
14:47:18 <vincenz> digg?
14:47:37 <Adamant> heh, that's a change of pace over BSD dying
14:49:01 <glguy> I think that most people that know what the *BSDs are have realized that it's not going away
14:50:31 <Adamant> glguy, I'm being a smartass.
14:50:53 <glguy> me too
14:51:26 <weitzman> BSD might not be going away, but having used FreeBSD a few years ago, I can say it's not going to lose any ground to Linux in the desktop market anytime soon
14:51:36 <weitzman> I mean
14:51:39 <weitzman> The opposite of that
14:52:08 <weitzman> What I'm trying to say, is that it sucked on the desktop compared to linux
14:52:15 <weitzman> There, that wasn't so hard to say
14:52:54 <glguy> but that argument works easily against Linux vs OS X and Windows, but that doesn't stop people from adopting linux
14:53:06 <glguy> but also i don't see BSD and the answer to the desktop anyway
14:53:16 <weitzman> Well, there are certain things Linux has that are very useful
14:53:22 <weitzman> Like a giant community
14:53:37 <weitzman> And I prefer the debian/ubuntu package repository to ports
14:53:43 <weitzman> I had some problems with ports
14:53:50 <weitzman> It's nice when an army of geeks maintain your packages
14:54:45 <weitzman> Actually I went with FreeBSD in 2003 after a failed attempt at a Debian install
14:55:04 <weitzman> At the time I was happy, but I switched to Ubuntu and haven't missed BSD
14:55:32 <fwd> ;)
14:55:34 * weitzman disappears
14:57:02 <fwd> <weitzman> It's nice when an army of geeks maintain your packages ;) sounds cool
15:16:51 <araujo> What is the best option for mutable variables? The StateMonad or IORef?
15:23:53 <Lemmih> araujo: What do you need?
15:26:20 <araujo> Lemmih, I need to have some kind of destructive-updating
15:26:22 <Cale> araujo: The State monad is decent when you just want a simple piece of state which is carried through an otherwise pure computation.
15:26:27 <araujo> For a variable.
15:26:41 <Cale> For more complex kinds of state in a pure computation you can use the ST monad
15:27:08 <Cale> IORefs are more for carrying around state in a computation which already involves IO in some way
15:27:46 <araujo> yeah, that is it.
15:28:03 <Cale> and for very simple thread communication (for anything serious in the way of thread communication, you should use MVars or Chans or soomething like that)
15:28:38 <araujo> Well, the variable needs to be accessed by a single thread.
15:28:42 <Cale> okay
15:28:56 <araujo> Is it worthy to use MVars?
15:28:58 <Cale> Then it's probably an IORef, if you're already in IO
15:29:11 <araujo> Yes, i am in there ....
15:29:17 <Cale> If you're in a single threaded program, an MVar is probably inappropriate
15:29:35 <Cale> since attempting to read from an empty MVar will cause your thread to block
15:29:45 <araujo> Yes, i noticed that :-)
15:31:33 <araujo> Cale, OK, so, considering the IO, the IORef would be the way to go , do you know any good paper to read about it?
15:32:06 <Cale> There's not much to IORefs
15:32:15 <araujo> :-(
15:32:35 <Cale> you create a new IORef using newIORef
15:32:43 <Cale> (and giving an initial value)
15:32:58 <Cale> and then you can read or write to that IORef with readIORef and writeIORef
15:33:11 <Cale> there's also modifyIORef which will apply a function to the value in the IORef
15:33:17 <araujo> yeah, i can see the library is pretty straightforward to use, i just wanted some theoretical background.
15:33:32 <Cale> Well, it's just a pointer, really :)
15:33:41 <araujo> I see.
15:34:04 <Cale> Note that since it points at a Haskell value, the value contained by an IORef might not be evaluated yet.
15:34:08 <Cale> It could even be undefined
15:34:40 <astrolabe> IORef is mentioned here http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
15:34:41 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/jl2rm
15:34:50 <araujo> So they are lazy ....
15:35:01 <Cale> right
15:35:13 <araujo> Nice, lazy references .. mm
15:35:24 <Cale> well, writeIORef will cause the pointer to be updated immediately, of course
15:35:33 <araujo> yeah, makes sense
15:35:36 <Cale> but the value it points to is not evaluated at all by this
15:35:44 <araujo> i guess the modify function too right?
15:36:01 <Cale> right
15:36:02 <araujo> Ok, that's the nice part.
15:36:25 <araujo> It updates only the reference.
15:36:29 <Cale> So you should be a little careful about it though, since it's easy to build up stack overflows waiting to happen
15:37:08 <araujo> I am not used to work with this kind of computation (and probably i wouldn't like to get used to), i hope to use only a single variable for now.
15:37:22 <Cale> > foldl (+1) 0 [1..1000000]
15:37:23 <lambdabot>    Occurs check: cannot construct the infinite type: t = b -> t
15:37:23 <lambdabot>    Expec...
15:37:30 <Cale> > foldl (+) 0 [1..1000000]
15:37:32 <lambdabot>  Exception: stack overflow
15:37:35 <Cale> like that
15:37:38 <araujo> :-(
15:37:39 <Cale> (only with IORefs :)
15:37:50 <araujo> I see ...
15:37:50 <Cale> So you might want to force some evaluation from time to time
15:38:20 <araujo> Ok, i see it brings pretty much the annoyance of pointers in other languages ....
15:38:21 <Cale> depending on what you're doing
15:38:35 <araujo> well, at some degree ....
15:38:46 <araujo> Cale, now you scared me :-P
15:39:16 <Cale> So if you're doing something like an accumulator, force the computation to occur when you make the update.
15:39:25 <araujo> Good good.
15:39:32 <Cale> That's all there is to that :)
15:39:39 <araujo> Ok, Thanks Cale !
15:39:42 <araujo> Thanks astrolabe !
15:40:04 <astrolabe> Ah.  I thought you'd missed it :)
15:40:04 <araujo> I will get some food first and then i'll try this :-)
15:40:14 * araujo off 
15:49:46 * vincenz is off
15:49:47 <vincenz> night!
16:32:18 <glguy> http://www.codinghorror.com/blog/archives/000684.html
16:32:20 <lambdabot> Title: Coding Horror: When Understanding means Rewriting, http://tinyurl.com/evfed
16:32:33 <glguy> this article claims that programmers spend tons of time understanding old code
16:32:39 <glguy> lots of time rewriting code
16:32:44 <glguy> and a little time writing new code
16:32:56 <glguy> that doesn't jibe with what I've seen
16:33:09 <glguy> people don't bother to "understand" what they are modifying
16:33:14 <glguy> they just dive in and break stuff!
16:36:20 <kpreid> which works fine *if* breakage is easily detected...
17:12:21 <x3m> can you compile stuff(to exe) through ghci?
17:14:54 <br1> x3m: I don't know.  Why don't you use ghc proper?
17:15:33 <x3m> who says i dont?
17:15:47 <br1> What do you mean by ghci then?
17:16:06 <x3m> the interpreter prompt or whatever it is
17:16:36 <br1> Ah, OK.  So you have been compiling through ghc but you want to use ghci now?
17:16:48 <x3m> i just wonder if its doable
17:17:40 <br1> Well.  You can escape to the prompt with "!:" so that's a way.
17:18:17 <br1> It's the other way:  ":!"
17:19:13 <x3m> *** Exception: system: invalid argument (null command)
17:19:21 <x3m> when trying :!
17:19:53 <br1> You have to put something after that:  ":! ghc mimod.hs"
17:21:06 <x3m> ah okay
17:27:36 <x3m> hmm
17:30:41 <x3m> how is a hello world app supposed to look like
17:30:59 <x3m> main = putStrLn "Hello World" this seems to work
17:31:33 <x3m> but the tutorial mentions: module Main on a line above, i tried that and then it didnt compile
17:31:47 <kpreid> it should be "module Main where"
17:32:42 <kpreid> and yes, that is the usual structure
17:33:29 <x3m> with module Main where it doesnt compile
17:33:53 <x3m> then i get: test2.hs:2:0: parse error on input 'main'
17:34:04 * araujo back
17:34:13 <araujo> :-)
17:34:19 <dolio> "lisp never had type-safe compile-time lambdas."
17:38:20 <x3m> this module stuff dont work
17:40:17 <dolio> ?where paste
17:40:17 <lambdabot> http://paste.lisp.org/new/haskell
17:40:28 <dolio> Perhaps you should paste what you're trying to compile there.
17:42:12 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26604
17:43:03 <x3m> thats it, pretty much what i've allready said
17:45:06 <dolio> Hmm. Odd.
17:45:34 <br1> x3m: What line do you use tom compile?
17:45:40 <x3m> its in ghc in win btw
17:46:15 <x3m> ghc --make test.hs -o test
17:47:21 <kpreid> line endings? junk characters?
17:47:29 <br1> The file must be named main
17:47:41 <x3m> oh, trying that
17:47:53 <x3m> no, no junk and line endings exactly as i did in the paste
17:48:19 <chessguy> lol, i like the contrast between quicksorts in C and Haskell in http://www.haskell.org/haskellwiki/Introduction
17:48:22 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/eogyw
17:49:11 <chessguy> 2 lines versus 25ish
17:49:18 <br1> :)
17:49:18 <kpreid> x3m: try putting it on one line. module Main where main = putStrLn "hello"
17:49:20 <x3m> got it to work now
17:49:37 <br1> x3m: Great
17:51:13 <dolio> I wonder how bad in-place qsort would be in the ST monad.
17:51:36 <chessguy> ST?
17:52:12 <dolio> ST is a monad that lets you do imperative programming minus IO, essentially.
17:53:45 <chessguy> "An incestuous example: the Glasgow Haskell compiler is written in Haskell: a 30,000-line application"
17:58:24 <br1> dolio: I'm more interested in cool uses of the accum constructor funciton for arrays
17:59:02 <dons> oh, it's more like 60k now
17:59:03 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:59:05 <dons> i should update that
18:01:46 <chessguy> i assume the 30k is for Haskell 90
18:01:47 <chessguy> 98
18:03:34 <chessguy> let fac n = if n == 0 then 1 else n * fac (n-1) in fac 3
18:03:37 <chessguy> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 3
18:03:38 <lambdabot>  6
18:03:44 <chessguy> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 0
18:03:45 <lambdabot>  1
18:03:54 <chessguy> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac -1
18:03:54 <lambdabot>  add an instance declaration for (Num (a -> a))
18:04:17 <chessguy> strange error
18:04:41 <araujo> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac (-1)
18:04:43 <lambdabot>  Exception: stack overflow
18:04:43 <dolio> fac - 1 parses as (-) fac 1, not fac (-1)
18:04:58 <chessguy> aha
18:04:59 <dolio> Or, fac -1, even.
18:11:32 <lisppaste2> br1 pasted "monomorphism" at http://paste.lisp.org/display/26606
18:12:03 <br1> Could anyone look into my problem there, please?
18:16:29 <chessguy> A :: B -> C -> D means that A is a function which taeks an argument of type B and an argument of type C and returns something of type D, right?
18:16:39 <br1> yes
18:16:52 <br1> but A should be lower case
18:17:20 <chessguy> well, ok, it was just an example
18:17:49 <chessguy> so if it was A :: B -> C -> D -> E, then there are three arguments?
18:18:43 <Igloo> One way of looking at it is that A takes an argument of type B and returns a value of type C -> D -> E
18:19:07 <chessguy> hmmm
18:19:30 <chessguy> but the easier way to look at it is what i said, right?
18:20:06 <Igloo> Possibly, but your way might confuse you if E = Int -> Char
18:20:20 <Igloo> In which case there are 4 arguments
18:20:44 <chessguy> aha. so i was assuming primitive types naively
18:22:10 <br1> Is there defaulting to the IO monad or someting like that?
18:22:25 <Igloo> No
18:22:55 <br1> What could be happening in my case, then?
18:23:52 <Igloo> That's the monomorphism restriction. If you want it to have the polymorphic type you need to give it explicitly
18:24:10 <Igloo> Or rewrite it to look like a function
18:24:44 <br1> But why does it matter if I use the function or not?
18:25:46 <Igloo> If you use it then it knows what monomorphic type to give it
18:26:21 <Cale> You can also use -fno-monomorphism-restriction
18:26:41 <Cale> The MR is mostly silly.
18:27:04 <br1> mmh
18:27:11 <br1> that's strange
18:27:20 <Cale> There are some somewhat obscure cases where programs will run exponentially slower without it though.
18:27:54 <Cale> These problems can always be alleviated by assigning monomorphic types explicitly.
18:28:54 <br1> Yes, I more or less understand the reasons for the restriction.  What I didn't know was that ghc considered other functions at file scope to determine the type
18:28:55 <emu> any news on 6.6
18:29:23 <br1> Is that an extension to what the standard requieres in for the monomorphic restriction?
18:32:29 <Igloo> br1: No
18:32:48 <Igloo> emu: We probably need another round of RCs
18:33:10 <dons> seems like a good idea
18:33:27 * Igloo needs to do lots of patch merging tomorrow
18:36:11 <dons> the "Implementation of aton and ntoa outside the IO monad" looks useful too, Igloo
18:39:12 <dons> well, all very interesting. when the 'unix tools' article went up, it sat at the top of the reddit list, and we got 3k hits in 3 hours. then haskell.org went down, 21 hours later it came back up, and we got 300 hits in the next 12 hours :/
18:39:21 <lennart> @pl \ f g x -> f x (g x)
18:39:22 <lambdabot> ap
18:39:26 <dons> oh well, we missed a bit of an opportunity there
18:39:50 <lennart> @pl \ f g x -> f x g
18:39:51 <lambdabot> flip
18:40:38 <lennart> @pl \ x y -> y x
18:40:39 <lambdabot> flip id
18:41:05 <sris> lennart, you don't happen to be a lector at lth?
18:41:14 <lennart> @pl \ f x -> f x x
18:41:14 <lambdabot> join
18:41:16 <araujo> dons, argh
18:41:28 <lennart> no, i'm an ex-lektor at cth
18:41:33 <lispy> haskell missed its chance at the limelight
18:42:03 <lispy> stupid /. effect
18:42:27 <lennart> @pl \ k f g x -> k (f x) (g x)
18:42:28 <lambdabot> liftM2
18:42:51 <lennart> @pl \ k f g x -> k (f x) g
18:42:52 <lambdabot> (flip .) . (.)
18:43:07 <lennart> @pl \ k f g x -> k f (g x)
18:43:08 <lambdabot> ((.) .)
18:44:04 <br1> http://www.haskell.org/ghc/docs/6.4.2/html/libraries/base/Control-Monad-ST.html mentions the paper "Lazy State Threads".  I think it should say "Lazy Functional State Threads"
18:44:06 <lambdabot> http://tinyurl.com/rafpa
18:44:10 <lennart> sris: why?
18:45:02 <sris> lennart, just curious because im taking a haskell course at lth, sweden this fall and our lecturer is named lennart too ;)
18:45:21 <lennart> hmmmm, not me as far as i know
18:45:40 <sris> i guess not
18:47:07 <lennart> dons: the Linspire guys were promising a bunch of unix-like tools in haskell,  any relation to yours?
18:47:39 <dons> mmm. interesting. no, i've not heard that.
18:48:03 <dons> mine i just hacked up on friday after a query from a user here.
18:49:34 <lennart> @pl \ x y z -> x y
18:49:34 <lambdabot> (const .)
18:49:51 <dons> i think my favourite is this one: io $ zipWith (printf "%3d %s") [(1::Int)..]
18:50:06 <lennart> cat -n
18:50:20 <dons> there's a bit of magic happening there, with printf.
18:50:22 <dons> yep
18:50:55 <lennart> hmmm, yes, i'm surprised it type checks
18:51:00 <dons> heh
18:51:05 <lennart> no type signature?
18:51:26 <dons> the 'io' constraints it to String
18:51:36 <lennart> oh, ok
18:51:56 <lennart> printf is a beast :)
18:52:37 <lennart> it also needs freshening up.  i think it's still my ancient code
18:52:48 <jcreigh> printf in Haskell has to be implemented in Template Haskell or something, right?
18:52:54 <lennart> no
18:53:02 <dons> ?type printf
18:53:04 <lambdabot> forall r. (PrintfType r) => String -> r
18:53:04 <lennart> H98 suffices
18:53:45 <jcreigh> Oh...how does the variable number of arguments thing work?
18:53:53 <lennart> > print "%d %s" 99 "bottles" :: String
18:53:53 <lambdabot>    The function `print' is applied to three arguments,
18:53:54 <lambdabot>   but its type `a ...
18:54:13 <lennart> > printf "%d %s" 99 "bottles" :: String
18:54:13 <lambdabot>  Add a type signature
18:54:16 <dons> > printf "%3d %4s %6f\n" (42 :: Int) "h98 forever!" (pi::Double) :: String
18:54:17 <lennart> bah
18:54:17 <lambdabot>  " 42 h98 forever! 3.141592653589793\n"
18:54:31 <lennart> stupid defaulting never works as i like
18:54:40 <dons> yeah
18:55:06 <lennart> jcreigh: it works by type class magic
18:57:31 <jcreigh> > printf "%s" (42 :: Int) :: String
18:57:33 <lambdabot>  Exception: Printf.printf: bad argument
18:57:42 <jcreigh> So the type-checking fails at runtime, then.
18:59:01 <dons> yeah, the format string isn't analysed at compile time
18:59:18 <dons> but the arguments must be known to be printf-able
18:59:32 <lennart> and they can vary in number
18:59:49 <dons> ?type printf "%s" "abc"
18:59:50 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
18:59:53 <dons> ?type printf "%s" "abc" "def" ghci"
18:59:55 <lambdabot> lexical error in string/character literal
19:00:09 <dons> ?type printf "%s" "abc" "def" "ghc"
19:00:11 <lambdabot> forall t. (PrintfType ([Char] -> [Char] -> [Char] -> t)) => t
19:00:18 <dons> ?type printf "%s" "abc" "def" "ghc" :: String
19:00:19 <lambdabot> String :: String
19:01:36 <dons> ?instances-importing Text.Printf PrintfType
19:01:37 <lambdabot> (a -> r), IO a, [c]
19:01:46 <dons> mmm. tasty
19:01:53 <dons> there's the variable argument trick
19:02:32 <dons> ?instances-importing Text.Printf PrintfArg
19:02:33 <lambdabot> Char, Double, Float, Int, Integer, [c]
19:03:07 <dons> seems like an: instance Show  => PrintfArg a where ... for the rest would be useful
19:03:18 <dons> though i've not actually ran into that as a problem yet
19:04:58 <dons> http://www.smh.com.au/news/web/new-browser-offers-stealth-mode-surfing/2006/09/21/1158431835805.html
19:04:59 <lambdabot> Title: New browser offers stealth mode surfing - web - Technology - smh.com.au, http://tinyurl.com/lcrha
19:05:04 <dons> firefox-over-tor, on a usb stick
19:07:18 <_dolio> Hmm... My ugly in-place quicksort is slower than the beautiful Haskell quicksort.
19:07:41 <dons> heh
19:07:52 <dons> how's it compare to List.sort ?
19:08:13 <_dolio> List.sort is a bit faster, I think.
19:08:25 <_dolio> But the Haskell idiomatic qsort is faster than List.sort.
19:08:34 <dons> mm. makes me think a @time <expr> would be a useful plugin
19:09:37 <br1> _dolio: With optimization?
19:10:02 <_dolio> I'm fairly inexperienced with MArray algorithms, though, so maybe I missed something obvious.
19:10:18 <dons> ah
19:10:33 <dons> you wrote a mutable, inplace array-based qsort?
19:10:34 <_dolio> Translating C loops into recursive functions can be awkward.
19:10:41 <_dolio> Yeah.
19:13:22 <dolio> br1: What kind of optimization?
19:16:17 <dolio> If I use unboxed arrays, I can get performance comparable to the idiomatic qsort. :)
19:20:27 <dons> hmmm..... is haskell.org down?
19:21:23 <weitzman> Apparently it is
19:21:27 <weitzman> ...again
19:21:31 <weitzman> It was up earlier
19:21:55 <dons> yes, it's been up for 12 hours or so.
19:21:58 <dons> *sigh*
19:23:07 <lispy> are they running apache?
19:23:21 <lispy> is it a recent version? using any 'weird' features?
19:23:36 <weitzman> Did whoever brought it up release any explanation?
19:24:02 <lispy> are the default Read/Show implementations any good for serializing/unserializing data?
19:24:19 <dons> yes, there were 150 simultaneous connections, and it went down. they're investigating whether it was a /. effect, or a DOS
19:24:20 <lispy> weitzman: just that there were 150 client connections and they restarted the server
19:24:52 <weitzman> 150 connections doesn't seem like a good reason for a server to drop dead
19:25:00 <dons> i can't imagine that there is any slashdot effect right now though.
19:25:02 <weitzman> Unless they opened connections and didn't accept any data
19:25:37 <weitzman> Even then, timeout would deal with it unless it were a DoS
19:25:51 <lispy> it's sort of like whatever thing they were supposed to do went to sleep and never timed out...that was how it sounded (but i don't have much info)
19:26:09 <dons> maybe its time we had a bit of a more robust setup for haskell.org
19:26:33 <weitzman> Written in...
19:26:36 <weitzman> Erlang!
19:27:51 <Patterner> Hapache 3.0
19:28:19 <dons> what's annoying is that the mail server seems to be run from the same box?
19:28:20 <weitzman> That paper lispy mentioned yesterday said something about implementing an HTTP server in Haskell, although it didn't point to any code
19:28:25 <dons> and hackage?
19:28:31 <dolio> Ooo, now I'm faster. I needed to strictify, I guess.
19:28:34 <dons> weitzman: yeah, there's HWS and HAppS
19:29:08 <weitzman> Although in terms of robustness, I don't think will come down to language choice
19:29:13 <dolio> Or, perhaps not. Sorting random numbers as a benchmark is tricky business.
19:29:15 <dons> how hard would it be to set up a mirror of just the website?
19:29:22 <dons> anyone had experience doing that kind of thing?
19:29:26 <lispy> dons: sort a sorted list :)
19:29:28 <lispy> er
19:29:32 <lispy> dolio: sort a sorted list
19:29:35 <weitzman> Bandwidth, redundancy, policies for high-load
19:29:50 <lispy> dolio: isn't that the way to get qsort to behave poorly (not worst but poorly)
19:30:19 <dons> if only the wiki had a darcs backend...
19:30:34 <dons> we could trivially mirror and distribute it
19:30:49 <lispy> dons: syncing databaseses must be a solved problem though...
19:31:06 <dons> sure
19:31:11 <lispy> (the extra eseseses help solve the problem)
19:31:16 <dons> darcs pull haskell.org just sounds nice though ;)
19:31:22 <lispy> heh
19:31:22 <dolio> lispy: Yeah, but would that be good for benchmarking two qsort implementations?
19:31:24 <weitzman> Might be a little more complicated if the wiki has any concept of users with more permissions than others
19:31:39 <weitzman> In terms of not sending around their password hashes
19:31:44 <dons> yeah
19:31:55 <dons> a simple option would be for mirrors to be ro
19:32:13 <dons> ok, mailing list still works. good
19:32:18 <dons> though that was a bit of a delay
19:32:52 <hyrax42> how long does a hugs build take compared to ghc
19:33:04 <lispy> well, ghc takes 6+ hours to build on my ibook
19:33:12 <lispy> i bet hugs is much faster
19:33:19 <dons> must be super high quality then.
19:33:58 * dons principle of fun and software: the longer it takes to build, the more goodies you get
19:34:07 <hyrax42> yea 6+ hours for ghc on my ibook too
19:34:14 <hyrax42> problem is I think I hosed my darwinports
19:34:19 * lispy stamps his foot to signify his annoyance with the darwinports version of emacs failing to run
19:34:20 <hyrax42> and may need to start from scratch
19:34:26 <weitzman> Even dons principle can't convince me to install gentoo
19:34:38 <dons> heh
19:34:50 * Patterner uses gentoo too
19:35:10 <dons> ?users #gentoo-haskell
19:35:15 <lambdabot> Maximum users seen in #gentoo-haskell: 18, currently: 13 (72.2%), active: 1 (7.7%)
19:35:46 <weitzman> I have a crazy gentoo-using friend who will occasionally mention things like, "My computer was compiling XXX" all night. XXX might be something like X, or gcc, or something of that nature
19:35:55 <hyrax42> there is no aqua/carbon variant for the emacs port?
19:36:25 <lispy> hyrax42: yes
19:36:31 <lispy> hyrax42: called, carbon emacs
19:36:38 <Patterner> i gave up on #gentoo-* channels
19:36:42 <hyrax42> oh I didnt' see it
19:36:46 <lispy> but i can't get it to run on the command line :(
19:36:47 <dons> weitzman: similar on the bsd's, where we build out packages from source as well
19:36:55 <lispy> hyrax42: so it's not very useful to me
19:36:58 <Patterner> XXX = KDE :)
19:37:06 <hyrax42> oh it's on emacs-devel
19:37:08 <dons> though ghc takes about 30 mins, since it's built from C source on openbsd
19:37:09 <weitzman> At one point this summer I told my computer to do a full build of the window Vista core components, but I left the virus checker on and it didn't finish overnight
19:37:28 <weitzman> Although my dev box was pretty powerful
19:37:34 <hyrax42> well darwinports is meant to be similar to bsd ports
19:37:46 <hyrax42> not sure wy ghc takes 6-8 hours
19:38:05 <araujo> haskell.org down again?
19:38:11 <dons> yes.
19:38:13 <araujo> :-(
19:38:14 <dons> about 10 mins ago.
19:38:18 <hyrax42> :/
19:38:23 <hyrax42> good thing I hav a billion wiki pages open
19:38:34 <hyrax42> if only I could get my inferior-haskell to work in emacs
19:38:58 <lispy> my emacs crashes on startup for some reason :(
19:39:14 <lispy> and i'm sick of using carbon emacs...so time to fix it
19:39:53 <dons> that's been enough to chuck 'unix tools' off the reddit front page :/ah well, the fickle blogosphere
19:40:04 <araujo> argh
19:41:03 <hyrax42> what's bad about carbon emac
19:41:04 <hyrax42> s
19:41:04 <araujo> But what is the problem? , this would be the third day down?
19:41:17 <dons> it was down for 21 hours, up for 12, and now down for 20 mins or so
19:41:36 <weitzman> Maybe it will come up after 21 minutes down
19:41:41 <weitzman> Then go down in 12 seconds
19:41:52 <araujo> :-P
19:42:36 <dons> I want a @get-haskell-org-admins-on-the-hot-line plugin
19:42:43 <dons> so we can set off their pagers from irc
19:42:45 <weitzman> @help!!!
19:42:45 <lambdabot> Unknown command, try @list
19:43:00 <araujo> yeah
19:43:18 <lispy> hyrax42: it requires a window and does really odd things to the control keys :(
19:43:27 <hyrax42> oh?
19:43:34 <hyrax42> my keys seem fine
19:43:52 <araujo> we need mirrors
19:43:56 <araujo> oh well ....
19:44:33 <lispy> hyrax42: your apple keys still works when carbon emacs has focus?
19:44:33 <stepcut> dons: maybe you can port @getshapr :)
19:44:45 <dons> yeah :)
19:44:59 <hyrax42> lispy: yeah
19:45:06 <hyrax42> works as meta
19:45:12 <dons> hook up lambdabot to the mobile phone network, and it can send out some text messages to the admins
19:45:14 <hyrax42> but I can command-tab as well
19:45:27 <stepcut> dons: I have some haskell code for that
19:45:39 <hyrax42> just some things annoying like M-tab being autocomplete in some modes
19:45:55 <lispy> hyrax42: that's what i mean, they take over the apple key so it makes osx funny :(
19:45:59 <stepcut> dons:  could alsa have an asterisk box call them and report errors
19:46:40 <dons> yeah, an undergrad at my uni used to have a website for sending text msgs to sydney numbers
19:47:02 <hyrax42> he could do it for free?
19:47:05 <hyrax42> send the sms?
19:48:13 <stepcut> actually, most cell provides provide email->sms gateways if you just email, <phonenumber>@something.cellprovider.com
19:48:34 <dons> for free though?
19:48:38 <stepcut> yeah
19:48:49 <dons> mmm. /me tries this
19:48:53 <stepcut> well, free to the sender, depends
19:49:08 <araujo> That depends upon the provider.
19:49:35 <stepcut> probably, I only have experience with 2 of them ;)
19:49:37 <dons> or the country? I think receiving is free here.
19:51:29 <stepcut> in the US, most carriers charge you for receiving -- but many subscribers have various bundles that include a few hundred or few thousand 'free' txt messages per month
19:51:54 <lispy> yeah, i think they charge you to send and receive in the US righT?
19:51:57 <dons> considering the actual data must be several 100s of dollars a gigabyte..
19:52:05 <stepcut> lispy: yeah
19:52:15 <araujo> Here, one provider is paid, the other one is for free.
19:53:23 <araujo> You can send from and receive from internet for free.
19:53:27 <stepcut> in the US there is also an option for send pays double, receiver pays nothing
19:53:59 <araujo> You are only charged if you send from the phone.
19:54:27 <araujo> That's one provider, the other charge you for both service.
19:54:47 * araujo is with the free one of course :-)
19:55:04 <araujo> Though i just use it for sending messages to my sister
19:55:10 <dons> doh, my provider has a web interface, but  EmailSMS costs $0.25 per sent SMS and $5.00 per month
19:55:27 <stepcut> dons: that sucks
19:55:32 <araujo> yeah
19:55:53 <dons> there's even a command line tool to hook into it, you just have to pay
19:56:14 <stepcut> dons: you might check and see if clickatell has cheaper rates: http://www.clickatell.com/
19:56:16 <lambdabot> Title: Clickatell Bulk SMS Gateway
19:56:22 <akemp> Anyone know what's up with haskell.org right now?
19:56:26 <araujo> down
19:56:44 <stepcut> as a bonus, you can then send sms to any network
19:56:48 <dons> mmm..
19:56:59 <mathewm> yeah, I noted that hoogle is hanging :(
19:57:22 <akemp> It was down last night, too, but was up today.  ??
19:57:26 <araujo> yes
19:57:32 <araujo> For several hours.
19:57:38 <mathewm> just went down again...
19:57:44 * araujo could open a few pages
19:57:56 <stepcut> dons: clickatell has several APIs ranging from simple to complex, I have haskell binding for one of them.
19:58:11 <araujo> Let's hope it gets back soon
19:58:24 <araujo> I don't want to spend other night like this
19:58:32 <dons> stepcut: yeah, looks nice.
19:59:18 <mathewm> anyone here familiar with GHC internals and the GHC API?
19:59:21 <stepcut> now I just need to figure out why people would want to pay me to send them text messages ;)
19:59:28 <dons> heh
19:59:53 <dons> we could start up a haskell homework answers servvice
19:59:59 <stepcut> hehe
20:00:04 <dons> $5 per answer, delivered o your phone
20:00:11 <dons> and send from lambdabot, via irc :)
20:00:23 <stepcut> maybe a sms interface to Dr Haskell ;)
20:00:34 <dons> yeah, to lambdabot even
20:00:37 <hyrax42> anyone have any links on suitability of haskell to ai applications?
20:00:41 <dons> pointfree refactoring from your mobile
20:00:56 <hyrax42> or is it suitable?
20:01:03 <dons> for when you just need to use Monad (->) a_
20:01:30 <stepcut> hyrax42: do you have any AI experience ?
20:01:41 <hyrax42> stepcut: well I'm doing an AI class
20:01:59 <hyrax42> and the project is playing a sort of chess variant
20:02:05 <hyrax42> there's a competition :)
20:02:23 <hyrax42> and I wanted to use Haskell if it's be suitable to it
20:02:24 <stepcut> hyrax42: I have no real experience, but I think a lot of AI comes down to things like the A* algorithm in the end -- and those types of algorithms are very well suited to haskell
20:02:42 <chessguy> what variant?
20:02:47 <hyrax42> I remember the ICFP cops and robbers was won by a haskell team
20:02:58 <hyrax42> chessguy: more like a distant cousin
20:03:05 <chessguy> what is it?
20:03:09 <hyrax42> called "all the king's men" or "smess"
20:03:42 <hyrax42> 7x7 board, 7 "pawns", 4 "queens", 1 "king"
20:03:51 <chessguy> well, if it's got a large branching factor, and you're planning on doing alphabeta....you might be better off with a more low-level language
20:03:58 <hyrax42> the "queens" are restricted in movement by arrows on the board
20:04:08 <hyrax42> chessguy: that's what I was worried about
20:04:19 <hyrax42> what is it about alpha/beta that makes haskell nto so suitable
20:04:43 <chessguy> it's not so much alpha-beta, but the idea behind it, which is to search as deeply as possible
20:04:51 <glguy> chessguy: Have you seen the implementation of alpha-beta pruning in "Why Functional Programming Matters"?
20:05:00 <dons> yeah, i helped write a nice AB search in a couple of hourse for last year's icfp contest
20:05:20 <hyrax42> cops and robbers?
20:05:30 <dons> short, sweet, hooked in to our existing heuristics nicely
20:05:43 <chessguy> the classical chess engine is all about optimization. for example, crafty (one of the best open-source programs) actually has parts of it written in assembler
20:05:44 <glguy> I've written an alpha-beta search, and I didn't notice anything that would make it particularly unsuited for Haskell
20:05:45 <hyrax42> glguy: the john hughes paper?
20:05:54 <chessguy> glguy: link?
20:06:06 <glguy> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
20:06:09 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/e4jve
20:06:19 <glguy> hyrax42: yes, the John Hughes paper.
20:06:27 <hyrax42> hm I dont' remember that part
20:06:39 <hyrax42> probably I didn't read it because I wasn't familiar with AI at the time
20:06:40 <chessguy> it's not that it's unsuited, but if you're looking for a high performance, optimization-driven program, lower-level is better
20:07:22 <dons> or a mixture of high level code for the non-core parts, and low level stuff for the critical path. that's often cheaper than writing the whole thing in C
20:07:48 <foxy> what is _casm_ ``...'' for?
20:07:48 <chessguy> yes
20:08:27 <chessguy> now, i'm not saying that AB is the best approach, but most chess engine writers would :)
20:09:19 <stepcut> hyrax42: this is a nice paper on solving the queens problem using haskell http://www.cse.ogi.edu/PacSoft/publications/2001/modular_lazy_search_jfp.pdf#search=%22modular_lazy_search_jfp%22
20:09:21 <lambdabot> http://tinyurl.com/sxtn7
20:09:59 <stepcut> It's actually a nice general purpose constraint solver, which they apply to queens, and a few other standard problems
20:10:02 <hyrax42> haha my irc client tells me it downloaded that file at 4.000 GB/s
20:10:22 <hyrax42> I really need to organise all the papers I've downloaded
20:10:34 <hyrax42> ~/downloads/new/web is pretty messy these days
20:11:39 <hyrax42> well anyway, I'll try my best with haskell
20:11:52 <hyrax42> see where I can get
20:12:04 <hyrax42> I think the prof is a very C-all-the-way type
20:12:50 <chessguy> are you in fact planning on using AB?
20:13:12 <hyrax42> not sure
20:13:21 <hyrax42> we only just started on adversarial search
20:13:43 <chessguy> adversarial?
20:13:51 <hyrax42> but it seems like it's more or less necessary to keep from searching too many useless things
20:13:59 <hyrax42> as opposed to like A*
20:14:09 <chessguy> ah, min-ma
20:14:11 <chessguy> x
20:14:14 <hyrax42> where there's no "opponent" in the problem
20:14:17 <hyrax42> yea
20:14:32 <chessguy> ok
20:14:58 <dylan> @version
20:14:59 <lambdabot> lambdabot 4p227, GHC 6.5 (OpenBSD i386)
20:14:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:15:00 <hyrax42> but do such algorithms require especialy much mutaability or other non-haskell-friendly things?
20:15:09 <glguy> > [id] <*> [()]
20:15:09 <lambdabot>  Not in scope: `<*>'
20:15:20 <hyrax42> laziness sounds like it'd be a pretty n ifty thing to have
20:15:23 <hyrax42> on your side
20:15:27 <hyrax42> for stuff like that
20:15:37 <chessguy> hmm, quite possibly
20:15:44 <hyrax42> but maybe you're saying overhead will have it beaten out by other approaches?
20:15:54 <chessguy> for example, in chess, you often generate all the moves, but then only search a few
20:16:25 <chessguy> i don't know, it would be interesting to see
20:17:08 <hyrax42> yay experiments
20:17:29 <hyrax42> well anyway, I rather not do it in java or c
20:17:42 <hyrax42> python etc. will perform abysmally
20:17:48 <hyrax42> *I assume
20:17:57 <glguy> we had to write our single player, and adversarial game tree searches in C++
20:18:05 <hyrax42> I guess I could try it in lisp or scheme, but I'd rather try haskell
20:18:13 <hyrax42> we can use any language
20:18:22 <hyrax42> that runs on the comp lab systems
20:18:27 <hyrax42> I checked; they have ghc 6.4.2
20:18:29 <chessguy> do you know what the branching factor is?
20:18:38 <hyrax42> no not really
20:18:57 <hyrax42> chess is what 30-40?
20:19:00 <hyrax42> this should be a fair deal less
20:19:21 <chessguy> yes, about that
20:19:30 <emu> damn i was off by 6 min on my sys clock
20:19:37 <chessguy> is this it? http://www.chessvariants.com/other.dir/smess.html
20:19:41 <lambdabot> Title: Smess, http://tinyurl.com/gb6ly
20:19:47 <stepcut> hyrax42: I would definately recommend skimming that modular lazy search paper -- I think it might answer some of your questions
20:19:55 <hyrax42> yeah that's the one
20:19:57 <hyrax42> stepcut: it's open
20:19:59 <hyrax42> :)
20:20:02 <chessguy> what a strange board
20:20:08 <hyrax42> yeah it's a bit weird
20:20:18 <hyrax42> those arrows restrict the directions a "queen" can move in from them
20:20:33 <hyrax42> oh the "pawns" are more like kings... can move any direction, unrestricted by arrow
20:20:35 <hyrax42> s
20:21:25 <chessguy> you mean the ninnies? that site says they are restricted by the arrows
20:22:34 <glguy> whoa, my initial impression to those arrows is that that is a game that only a computer AI could enjoy
20:22:53 <chessguy> lol
20:22:55 <hyrax42> haha
20:22:58 <hyrax42> chessguy: hmmm
20:23:06 <hyrax42> if you scroll down tot he "all the king's men" rules
20:23:12 <hyrax42> and try to read that horrible scan
20:23:41 <hyrax42> it sounds like only the knights (aka numskulls) are limited by the arrows
20:23:46 <hyrax42> I'll have to email prof for clarification
20:25:15 <chessguy> it does sound like your branching factor will be reduced somewhat
20:26:30 <hyrax42> probably 20 or less
20:26:34 <hyrax42> but I'd have to mess around to see
20:27:00 <hyrax42> I was meant to start coding today
20:27:05 <hyrax42> but well now it's 11.30
20:33:55 * vincenz sighs
20:34:51 <dylan> hmm, I'm having trouble getting lambdabot to build on debian. I've got hs-plugins 1.0
20:35:16 <dylan> and fps 0.8, but it seems to want Data.ByteString.Char8.breakChar, which is commented out.
20:35:31 <dons> hmm. try the darcs repo.
20:35:39 <dons> but i'm just about to commit a patch, if you can hang on for 10 minutes
20:35:49 <vincenz> dons: you know, I must admit I'm surprised.  Your page about the unix-like one-liners is definitely useful.  But it is hardly novel, it's not like interact is a new thing.  Well it is novel in putting them all together, just that it's curious it was only done now.
20:35:51 <dons> breakChar is in fps 0.7
20:35:52 <dylan> for which? lambdabot?
20:36:12 <dons> vincenz: yeah, its not new at all, it was just a 20 minutes hack. weird huh?
20:36:24 <dons> most of the stuff comes from h4sh  anyway
20:36:41 <vincenz> dons: the weirdness is just that it's getting such interest. I should think of these little things :P
20:36:51 <vincenz> I mean I read about interact in yaht, the first haskell tutorial I ever read
20:36:57 <dons> dylan: yeap about to push a patch.
20:37:08 <vincenz> dons: I guess what is weird is what people will find interesting
20:37:13 <dylan> woot, lemme know when to darcs get
20:37:17 <dons> vincenz: simple easy things are good for outsiders. don't mention monads or anything strange
20:37:22 <vincenz> true :)
20:37:27 <dons> just solve the problem
20:37:35 <dons> i'm thinking of something like a little html parser or similar
20:37:41 <dons> it has to be a domain that people already understand
20:37:54 <dons> and written without dumping too much PL theory on the user
20:37:58 <vincenz> yep
20:40:03 <dons> I've a little evil plan to watch what tutorials are hot in ruby and python, and then write similar haskell versions...
20:40:17 * vincenz grins
20:42:02 <dylan> I like that haskell IO is similar to IO::All (perl)
20:42:15 <dolio> :) Perhaps you should post dcoutts' Haskell browser in 25- lines.
20:42:26 <dons> mm. maybe!
20:42:26 <vincenz> ah yeah, I heard about that one
20:43:07 <dfranke> What threading library does forkOS use?
20:43:23 * vincenz doesn't know but is guessing pthreads
20:43:26 <dfranke> I assumed it was pthread but ldd doesn't list it.
20:43:43 <dons> pthreads, yep
20:44:04 <dfranke> Alright, thanks.
20:44:22 <dfranke> I'm working on libgcrypt bindings and I need to tell it what threading library to use if I want it to be thread-safe.
20:44:23 <Adamant> is it fair to say monads are the Pons Asinorum of Haskell?
20:44:49 <dfranke> Adamant: it's not fair to say that to people who don't speak Latin.
20:45:05 <Adamant> :)
20:45:29 <Adamant> it's a math phrase, I figured the Haskellers would know it.
20:46:02 <dfranke> Well I'm a math major and I have no idea what it means.
20:46:16 * lispy me too and same here
20:46:38 <dons> ?google Pons Asinorum
20:46:40 <lambdabot> http://www.bartleby.com/61/78/P0437800.html
20:46:40 <lambdabot> Title: pons asinorum. The American Heritage&#174; Dictionary of the English Language: F ...
20:46:44 <Adamant> Pons Asinorum = Bridge of Asses. it comes from a problem by Euclid that seperated people doing more advanced study in math from those who wouldn't in medivial times.
20:46:54 <lispy> ?all-dicts Pons Asinorum
20:46:57 <lambdabot> *** "Pons" gcide "The Collaborative International Dictionary of English v.0.48"
20:46:57 <lambdabot> Pons \Pons\, n.; pl. {Pontes}. [L., a bridge.] (Anat.)
20:46:57 <lambdabot>   A bridge; -- applied to several parts which connect others,
20:46:57 <lambdabot>   but especially to the pons Varolii, a prominent band of
20:46:57 <lambdabot>   nervous tissue situated on the ventral side of the medulla
20:46:59 <lambdabot> [14 @more lines]
20:47:10 <vincenz> pons asinorum is pons asinorum if you ask me
20:47:21 <dons> heh
20:47:24 <dons> ?more
20:47:25 <lambdabot>   oblongata and connected at each side with the hemispheres of
20:47:25 <lambdabot>   the cerebellum; the mesocephalon. See {Brain}.
20:47:25 <lambdabot>   [1913 Webster]
20:47:25 <lambdabot>  
20:47:25 <lambdabot>   {Pons asinorum}. [L., literally, bridge of asses.] See
20:47:25 <dfranke> Well, I guess that just makes a jackass out of me then.
20:47:27 <lambdabot> [9 @more lines]
20:47:35 <vincenz> from the first link
20:47:36 <vincenz> A problem that severely tests the ability of an inexperienced person.
20:47:47 <vincenz> dfranke: no I didn't know it either, I had to look it up
20:47:53 <vincenz> the first link
20:50:39 <dons> ?more
20:50:39 <lambdabot>    {Asses' bridge}, under {Ass}.
20:50:39 <lambdabot>    [1913 Webster]
20:50:39 <lambdabot>  
20:50:39 <lambdabot> *** "pons" wn "WordNet (r) 2.0"
20:50:39 <lambdabot> pons
20:50:41 <lambdabot> [4 @more lines]
20:50:54 <dylan> dons: it compiles now, except a syntax error in the Seen plugin
20:52:20 <lispy> bleh
20:52:31 <lispy> when i fixed my darwin ports problem i blew away my ghc install
20:52:34 <dons> dylan: yes, that's what i'm fixing :)
20:52:34 <lispy> grrr
20:52:50 <lispy> now i'm waiting for perl to compile so ghc will begin
20:53:20 <dons> dylan: ok, try darcs pull now
20:54:11 <dylan> dons: appears to be working. Thanks!
20:54:19 <lispy> by the time this compiles i'll be too sleepying to hack the code i wanted to write :)
20:54:35 <dylan> lispy: gentoo, eh?
20:54:55 <lispy> dylan: oh no...i'm a debian guy, but this is on my mac where i have to use a gentoo-ish solution called darwinports
20:55:14 <dylan> Ah
20:55:41 <lispy> darwinports can be nice, but if you ever have a problem with it, which you will, it's a real bear
20:56:15 * lispy shells into his remote debian box hoping to hack there
20:56:26 <lispy> i wanted to write opengl code so hacking remotely isn't so attractive :)
20:56:32 <dons> ?quit weekly sync
20:57:57 <dons> ?version
20:57:59 <lambdabot> lambdabot 4p231, GHC 6.5 (OpenBSD i386)
20:57:59 <dylan> % ./lambdabot
20:57:59 <dylan> Initialising plugins .................................lambdabot: out of memory (requested 2479072304855777280 bytes)
20:58:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:58:02 <dylan> zsh: exit 1     ./lambdabot
20:58:06 <dons> rm State/seen
20:58:08 <dylan> out of memory?
20:58:31 <dons> an artifact when changing the state type
20:58:39 <dons> interacts a bit badly with the binary parser
20:58:50 <dons> simply rm State/seen :)
20:58:55 <lispy> p231? hmm...sounds like i'm behind, i think i'm on 220 or 222 or so
20:59:24 <dons> lots of new quotes for HWN: M ./State/quote +94
20:59:47 <lispy> ah
20:59:57 <lispy> well, i'm not too worried about keepin the quote db in sync
21:00:09 <dylan> ./lambdabot --online fails to go online.
21:00:17 <dons> dylan: better check Config.hs
21:00:23 <dylan> it exits with 1, and I did edit Config.hs to point to my irc server
21:00:35 <dylan> port = 6666, too.
21:00:53 <dons> are you connecting to freenode? sometimes it won't let multiple 'lambdabot' nicks connect
21:01:06 <dylan> No, not freenode
21:01:17 <dylan> private irc server.
21:01:22 <dons> i'm not aware of any other issues.
21:01:31 <dylan> changing port works, right?
21:01:37 <dons> should do.
21:01:47 <lispy> i found that the non-plugin version doesn't connect reliably from my machine
21:01:48 <dylan> it's not even attempting to connect.
21:02:07 <lispy> it's about 1/8 times that i get a connect
21:02:14 <dons> time outs maybe?
21:02:36 <dylan> time outs to localhost?
21:02:48 <vincenz> dons: when does 6.6 release, do you happen to know?
21:02:54 <dons> next week?
21:03:05 <dylan> it'd dying with SIGALRM
21:03:30 <dons> dylan: not sure. you can debug it with a carefully placed (io $ print msg) in Plugin/Base.hs
21:03:48 <dons> i've never seen a SIGALRM thrown
21:03:54 <lispy> vincenz: last i heard from SimonM they wanted to do a new RC about a week after ICFP
21:04:15 * vincenz nods at lispy 
21:04:22 <vincenz> it'll be good to have fps in the std libs
21:04:28 <lispy> very good
21:04:37 <lispy> next is to get a version of parsec that uses it :)
21:05:43 <emu> mmm
21:06:21 <dylan> dons: even, it's a segfault now
21:06:27 <dylan> only under strace, though
21:07:07 <dylan> some improvement!
21:07:10 <dylan> it connects now
21:07:23 <dons> hmm. sounds like something is amiss
21:07:36 * lispy checks the walltime, ghc tarball downloading now at 21:07
21:07:38 <dons> more info please
21:07:59 <lispy> dylan: are you building the plugin version or non-plugin?
21:08:12 <emu> do you think fps would significantly speed up parsec?
21:08:32 <lispy> emu: i was thinking it would reduce the memory consumed
21:08:36 <dylan> lispy: the one with 'sh ghci' works, the other one doesn't
21:08:37 <dons> yes, it does. the linspire guys found some 10x speed up for a particular task
21:08:42 <lispy> emu: fps seems to be more memory efficient
21:09:04 <emu> yea i'd imagine.  but i'd think parsec was losing lots of time in other processing steps..
21:09:04 <dons> dylan: so it runs ok in ghci? but the static binary doesn't?
21:09:35 <dylan> ah, it does now, the plugin version
21:09:52 <dylan> the compiled binary runs when I copy the plugins cabal file.
21:10:02 <dons> and rebuild?
21:10:14 <vincenz> dons: yes it does?...erm
21:10:17 <dons> sounds like the binary got a bit mixed up somehow?
21:10:26 <vincenz> dons: that's generic about fps, that's not certain to be so for a parser lib built on top of it
21:10:54 <dons> vincenz: the linspire guys found this using the ByteStringParsec lib. talk to stepcut.
21:11:08 <dons> one clear improvement is that you can extrac tokens without copying
21:11:10 <dons> using drop/take
21:11:12 <emu> @hoogle ByteStringParsec
21:11:13 <lambdabot> No matches found
21:11:20 <dons> and then in general its what 12x less space per char
21:11:29 <dons> ?where ByteStringParsec
21:11:30 <lambdabot> I know nothing about bytestringparsec.
21:11:38 <dons> hmm, what's the name?
21:11:39 <emu> @google ByteStringParsec
21:11:41 <lambdabot> http://tunes.org/~nef/logs/haskell/06.08.20
21:12:03 <emu> if google was always indexing, you could make a fixed-point google search
21:12:06 <dons> ?where bytestringparser
21:12:07 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
21:12:10 <lispy> heh, that would be awesome in google index so often that the link pointed to our conversation :)
21:13:20 <dons> ?uptime
21:13:20 <lambdabot> uptime: 16m 43s, longest uptime: 2d 8h 20m 7s
21:13:34 <emu> interesting short implementation
21:14:00 <emu> no infinite-lookahead operator
21:14:20 <vincenz> dons: explain the token bit?
21:14:43 <dons> you can extra tokens from a bytestring by doing a zero-copy substring build.
21:15:44 <dons> s/extract/
21:16:17 <lispy> crap
21:16:26 <lispy> haskell.org is down so i can't install ghc
21:16:58 <dons> :/
21:17:26 <Patterner> what files do you need?
21:17:49 <lispy> Patterner: Attempting to fetch ghc-6.4.2-src.tar.bz2 from http://www.haskell.org/ghc//dist/6.4.2/
21:18:44 <Patterner> http://mirror.switch.ch/ftp/mirror/gentoo/distfiles/ghc-6.4.2-src.tar.bz2
21:19:22 <lispy> i don't know how to make darwin port use that file instead :(
21:19:36 <dons> edit the makefile?
21:19:38 <dons> (or whatever script they use)
21:19:58 <Patterner> can't you just download and move it to the right place?
21:19:58 <dons> but probably there's an env var
21:20:01 <lambdabot> http://tinyurl.com/rrsbq
21:20:40 <lispy> hm...wget is not installed :)
21:20:58 <lispy> Patterner: maybe that will work..worth a try
21:21:13 <Patterner> but don't ask me what the right place is :)
21:21:31 <lispy> looks to be /opt/local/var/db/dports/distfiles/ghc
21:21:59 <lispy> i just hope the tarballs are the same
21:22:12 <Patterner> they are
21:22:23 * Patterner underlines the "mirror" parts of the url
21:22:47 <lispy> right, but not knowing anything about gentoo that could just be a gentoo mirror of a gentoo custom tarball :)
21:23:16 <Patterner> http://mirror.switch.ch/ftp/mirror/gentoo/distfiles/ghc-6.4.2-alut.patch.gz <- that's gentoo :)
21:23:19 <lambdabot> http://tinyurl.com/zmryj
21:23:45 <Patterner> all the tarballs are vintage. patches are distributed seperately.
21:24:09 <lispy> ah, i think debian does it that way too
21:24:37 <Patterner> yes
21:25:04 <Patterner> i think they label the tarballs "$NAME_orig.tar.gz" :)
21:25:55 <bran_> does ghc 6.4.2 run on macosx intel?
21:26:31 <Patterner> give me one and i'll test it for you
21:26:32 <lispy> bran_: i've heard that all the G4/G5 still can be emulated...so does it run natively?  I dunno...
21:28:08 <lispy> man, wget is much harder to compile than i realized...
21:28:39 <Patterner> port install wget    # where is the problem?
21:28:54 <Eidolos> Funny, my sysadmin mentioned yesterday that he compiled and installed wget (on FreeBSD) in like 15 seconds. :)
21:29:12 <lispy> Patterner: the problem is that it's still downloading and installing the dependencies
21:29:22 <bran_> port install ghc reveals that "ghc is not available on mac x86"
21:30:00 <lispy> i've needed expat, libiconv and gettext so far
21:30:19 <Patterner> waiting is not a hardship :)
21:30:56 <lispy> i just exected one fetch and compile...but it's doing a lot of work...(which is what i meant by hard)
21:31:15 <vincenz> dons: ever tried ruby/
21:31:20 <Patterner> Eidolos: 15 seconds is not possible. wget uses autoconf's configure :)
21:32:27 <glguy> can't a log of the autoconf stuff be cached?
21:32:29 <glguy> lot*
21:32:40 <Patterner> but that's cheating :)
21:32:57 <Eidolos> shrug, I'm just going on what he's saying.
21:34:52 <dons> vincenz: nope. i like their logo though... we need a better logo on haskell.org
21:35:13 <glguy> we need h.o to be online
21:35:17 * araujo wants h.o back!
21:35:18 <glguy> before we need to worry about it's logo ;)
21:35:26 <dons> that too
21:35:49 <dons> it's just conincided with the weekend, and everyone away due to ICFP. unfortunate timing
21:37:19 * lispy needs to learn an OO language next term for a class
21:37:29 <lispy> any suggestions?  looks like O'Haskell is pretty dead
21:37:41 <dolio> Smalltalk?
21:38:01 <lispy> dolio: yeah, that's probably in the top three at the moment
21:38:06 <lispy> i've heard it's OO done right
21:38:34 <lispy> but it's dynamic right?
21:38:43 <dolio> It's a nice example of what you can do with "everything's an object' taken to the extreme.
21:38:46 <Eidolos> I'd suggest Ruby.
21:38:47 <lispy> which makes me want to put ocaml before it
21:38:51 <dolio> Yeah, it's dynamically typed.
21:38:55 <Patterner> hmm.... i need 33 seconds...
21:39:20 <lispy> oh, actually i think i'll do scala
21:39:26 <lispy> i've been meaning to learn scala and it's OO
21:39:52 <glguy> does anyone here live in a country where they pronounce processor with a long O?
21:40:19 <bran_> the way ruby's class vars are static across subclasses is ugly
21:40:20 <lispy> it's pracess-or where i comefrom
21:40:46 <lispy> ?vixen pr0n
21:40:46 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
21:40:56 <lispy> omg...
21:40:57 <Eidolos> ha!
21:41:17 <glguy> who typed that one in?
21:43:35 <dons> its all from the original vixenlove file, which contains various sexist and racist lines like that, which are somtimes injected randomly. (vixenlove has been around a long time before lambdabot got a vixen plugin)
21:43:59 <glguy> ahh
21:44:24 <glguy> Politically incorrect comments don't bother me, I was just surprised :)
21:44:33 <dons> glguy: I think I'd say it "pro (long) cessor"
21:44:44 <Eidolos> prawcessor!
21:45:51 <dons> ?. vixen dice 1d2
21:45:52 <lambdabot> what is pron?
21:45:55 <dons> ?. vixen dice 1d2
21:45:55 <lambdabot> *giggles*
21:46:04 <dons> just random things when there's no match
21:46:07 <dons> ?. vixen dice 1d2
21:46:08 <lambdabot> I can't of anything nice to say about myself
21:46:41 <glguy> the dictionary shows that there are 3 ways to say it
21:46:43 <dons> somewhat disturbing things, on occasion
21:46:59 <lispy> dons: i had a thought that whenever a module had an error it should default to calling vixen and giving that for output :)
21:47:07 <lispy> dons: it could be lambdabot --sassy
21:47:25 <dons> that was true at one time . hehe
21:47:26 <glguy> prahcessre, prah-cessre, and pro-cessre
21:47:34 <dons> ?vixen prahcessre, prah-cessre, and pro-cessre
21:47:34 <lambdabot> what type of music do you like?
21:47:37 <glguy> where re is that weird upsidedown e-r
21:47:48 <dons> ?vixen sex
21:47:48 <lambdabot> Shouldn't we get to know each other before we talk about sex?
21:48:01 <weitzman> ?vixen haskell
21:48:01 <lambdabot> church is my favourite computer scientist.
21:48:03 <glguy> ?vixen haskell
21:48:04 <lambdabot> church is my favourite computer scientist.
21:48:07 <weitzman> I win
21:48:11 <dons> not enough regexes for that :)
21:48:17 <weitzman> ?vixen Java
21:48:17 <lambdabot> where can I a see a picture of you?? URL??
21:48:19 <dons> should add some more phrases too
21:48:21 <glguy> ?vixen win
21:48:21 <lambdabot> so, what do you think of me?
21:48:31 <weitzman> ?vixen basic
21:48:31 <lambdabot> what were you saying?
21:48:39 <lispy> ?vixen nude
21:48:39 <lambdabot> I'm sorry, I'm confused.
21:48:55 <lispy> heh, now i need zlib and openssl for wget
21:48:57 <lispy> geez...
21:52:03 <glguy> what operating system are you one that is making you do all of this?
21:52:12 <lispy> osx
21:52:25 <lispy> ah, finally wget is configuring
21:52:34 <glguy> macports is handling all of it for you, right?
21:52:38 <lispy> right
21:53:01 <dons> hehe, someone suggests porting fps to erlang ... :}
21:53:04 <dons> "Erlang can have its syntax cleaned. It can be sped up. It can get a port of Haskell's fast packed strings."
21:53:22 <lispy> hehe
21:53:43 <lispy> when i find myself programming in X and wishing it was Y, i just switch to Y....sounds like they need to do the same :)
21:54:00 <lispy> where X = Erling and Y = Haskell ;)
21:54:25 <lispy> arg
21:54:34 <lispy> now it needs to fetch happy from haskell.org
21:54:38 <vincenz> dons: what is their logo?
21:54:52 <vincenz> dons: ever tried smalltalk/squeak?
21:54:57 <glguy> Erlang's logo appears to be an "e"
21:55:20 <vincenz> oh, a ruby
21:55:21 <vincenz> duh
21:55:31 <vincenz> dons: I could ask a friend of mine?
21:55:37 <vincenz> dons: he's good at designing those kind of things
21:55:44 <vincenz> hmm, haskell.org is down
21:55:54 <lispy> sigh
21:55:56 <lispy> this won't work
21:56:01 <vincenz> still down from when someone (lispy?) mentioned it yesterday?
21:56:30 <lispy> the gentoo mirror doesn't happen to have this file does it?
21:56:30 <lispy> Attempting to fetch ghc-6.4-darwin-bootstrap-tiger.tar.bz2 from http://www.haskell.org/ghc//dist/6.4/MacOSX/
21:56:31 <Bobstopper> How can I print a WordX in binary? eg printing out something like 24930::Word16 should give something like "ab"?
21:57:18 <vincenz> Bobstopper: you mean hexa?
21:57:33 <vincenz> > 10*16+12
21:57:46 * vincenz pokes lambdabot 
21:58:09 <Bobstopper> hexa? I'll have a look
21:58:41 <vincenz> nono
21:58:42 <vincenz> I mean
21:58:46 <vincenz> waht format do you intend with "binary"
21:59:08 * lispy manages to find the bootstrap tar on google
21:59:38 <Cale> @hoogle showHex
21:59:45 <vincenz> @hoogle hex
21:59:48 <vincenz> Cale: it's not hex tho
21:59:53 <vincenz> Cale: I thought it was hex cause of the 'a' and 'b'
21:59:59 <vincenz> Cale: but it relates not at all with the nubmer
22:00:08 <vincenz> Bobstopper: please answer?
22:00:08 <Cale> yeah, that's rather odd :)
22:00:32 <vincenz> Cale: perhaps he means like 8-bit...which would be dependent on: character encoding, endianness...
22:01:25 <Bobstopper> Yeah, I mean that
22:01:36 <lispy> w00t, ghc is compiling
22:01:40 <Bobstopper> Basically I want to print an actual Byte, rather than an integer representation of the byte like show might
22:02:01 <lispy> what does an actual byte look like?
22:02:09 <Cale> > map (chr . (`mod` 2^8)) . iterate (`div` 2^8) $ 24930
22:02:14 <vincenz> Bobstopper: the problem is that a byte is undefined
22:02:21 <vincenz> Bobstopper:  I mean how it's printed
22:02:30 <vincenz> Bobstopper: it depends on encoding, as well as endianness
22:02:35 <Cale> > map (chr . (`mod` 2^8)) . iterate (`div` 2^8) $ 24930
22:02:38 <mbot>  "ba\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\...
22:02:43 <vincenz> Cale: lambdabot is do...
22:02:43 <vincenz> oh!
22:02:53 <Cale> > map (chr . (`mod` 2^8)) . takeWhile (/= 0) . iterate (`div` 2^8) $ 24930
22:02:54 <mbot>  "ba"
22:02:59 <Cale> hehe
22:03:19 <Cale> > reverse .map (chr . (`mod` 2^8)) . takeWhile (/= 0) . iterate (`div` 2^8) $ 24930
22:03:20 <mbot>  "ab"
22:03:25 <Cale> oops, space :)
22:03:51 <Cale> There's a somewhat roundabout way to do it.
22:04:23 <Bobstopper> Ok. I thought there might be something like that already existing in the libraries. Thanks.
22:04:48 <vincenz> Bobstopper: not really, because it's not very well defined
22:04:59 <vincenz> Bobstopper: like I said, it depends on what order you want your bytes in, how bytes are encoded and such
22:05:04 <vincenz> Cale: what about
22:05:07 <vincenz> > chr 24930
22:05:09 <mbot>  '\24930'
22:05:11 <dons> mayybe we could have a contest to design a logo, like netbsd did
22:05:12 <vincenz> heh
22:05:38 <Bobstopper> Well, of course it does. So it's just a case of defining a function for each appropriate endianness or having it default to the OS' expectations, right?
22:06:38 <Bobstopper> like aton handles endianness and everything, but there's no way to actually print the Word32 once it's returned it for you.
22:06:42 <vincenz> Bobstopper: might I be a bit hmm... philosophical ... and question what you're using this for?
22:07:04 <Bobstopper> s/aton/inet_addr/
22:07:22 <glguy> This informercial has it figured out
22:07:35 <glguy> I'll watch this womans breasts and let them tell me whatever they want
22:07:54 <Bobstopper> I figure if you've packed the WordX already, you've probably already sorted out the endianness. So something to just print it out afterwards would probably be nice.
22:07:58 <dolio> Is it the one where you can make lots of $1,000 checks doing unspecified things?
22:08:07 <glguy> dolio: are you watching it too??
22:08:14 <dolio> No, but I've seen it.
22:08:23 <vincenz> Bobstopper: what do you need this for?  Perhaps there's a better way of doing what you're trying to do by employing printing out numbers
22:08:24 <glguy> she's so hot... I almost believe her
22:08:31 <glguy> I could earn 5000$ each month
22:08:32 <dolio> Hehehe.
22:08:42 <glguy> millions are being paid out!
22:09:04 <glguy> her bet is that in 7 minutes they will have convinced me that I want to do it!
22:09:11 <Bobstopper> Basically I want to print the source HostAddress in a networking protocol using only the 4 bytes such an address should need
22:09:41 <Bobstopper> as well as a host of other WordXs
22:09:43 * glguy owes it to himself..
22:10:18 <dgoldsmith> re: running ghc 6.4 on Intel Macs, I've tried it. Only ghci works. If you try to compile something, the compiler generates PPC assembler and feeds it to the Intel assembler. Chaos ensues.
22:10:38 <glguy> the compiler generates assembly?
22:10:45 <glguy> the haskell one?
22:11:17 <dgoldsmith> It must, because it died trying to feed PPC assembly to the Intel assembler when I tried to compile a simple Haskell app using ghc.
22:11:23 <dons> dgoldsmith: you can specify the gnu assembler
22:11:25 <dgoldsmith> ghci works fine since it's doing bytecode.
22:11:31 <dons> with -pgml-ld I think
22:11:32 <lambdabot>  172
22:12:05 <vincenz> dons: ever tried an oo-based lang?
22:12:05 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
22:12:07 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
22:12:09 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
22:12:11 <dgoldsmith> It is the gnu assembler. But the gnu assembler on Mac OS X Intel expects Intel instructions, unless you tell it you're cross-assembling.
22:12:11 <lambdabot> Numeric.readHex :: Integral a => ReadS a
22:12:13 <lambdabot>  "ba\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\...
22:12:16 <dons> vincenz: used to teach java :)
22:12:21 <vincenz> dons: ah, right
22:12:23 <lambdabot>  "ba\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\...
22:12:33 <dgoldsmith> Not a problem for me, I'm running the 6.5-based Intel-native build.
22:12:35 <lambdabot>  "ba"
22:12:38 <lispy> so, then the next questions after what language, is what project will i do....i'm trying to think of something cool for darcs...
22:12:40 <vincenz> WOAH
22:12:43 <lambdabot>  "ab"
22:12:46 <vincenz> lambdabot suffered congestion?
22:12:58 <dgoldsmith> That's what I'd recommend over trying to get 6.4.1 to run under Rosetta.
22:13:02 <glguy> wtf is lambdabot doing?
22:13:02 <vincenz> lispy: ?
22:13:05 <vincenz> lispy: what are you trying to do?
22:13:05 <lambdabot>  '\24930'
22:13:16 <vincenz> glguy: he's rsponding with a SEVERE lag to previous requrest
22:13:18 <vincenz> requests
22:13:30 <lispy> vincenz: i'm taking a glass this term where we have to learn an OO language and do a project in it
22:13:34 <dons> ?bot
22:13:34 <mbot> :)
22:13:45 <vincenz> dons: he seems to be lagged by minutes
22:13:48 <vincenz> dons: odd ain't it?
22:13:51 <vincenz> erm
22:13:51 <dons> weird.
22:13:52 <vincenz> she
22:14:06 <vincenz> you'd think that either you'd get an answer lagged by seconds, or it would just not answer
22:14:11 <lispy> vincenz: obviously i'd rather cite oleg's oohaskell and just use haskell...but i don't think that will fly
22:14:16 <lispy> (but i could try asking)
22:14:29 <vincenz> lispy: what language have you decided upon?
22:14:44 <glguy> scala!
22:14:46 <lambdabot> :)
22:14:47 <glguy> it's OO and FP
22:14:48 <vincenz> and I'm not certain oohaskell would be a good idea
22:14:52 * dons investigates
22:15:17 <lispy> vincenz: scala is currently #1 on the list
22:15:27 <lispy> vincenz: ocaml and smalltalk are #2
22:15:30 <lispy> (tied)
22:15:45 <dons> what list?
22:15:45 <lennart> scala is pretty cool
22:15:52 <vincenz> lispy: mind mentioning why scala is first? not familiar with scala
22:16:11 <lispy> vincenz: because it's like ocaml, but nicer :)
22:16:26 <dolio> Does scala run on the JVM?
22:16:31 <lennart> yes
22:16:42 <vincenz> dons: have to admit, the ruby-lang.org site is sexy
22:16:47 <vincenz> lispy: no seriously
22:17:01 <lispy> vincenz: seriously
22:17:03 <dons> ?bot
22:17:03 <mbot> :)
22:17:03 <lambdabot> :)
22:17:11 <vincenz> lispy: I mean can you give me some more objective and meaningful reasons?
22:17:21 <vincenz> lispy: "like ocaml but nicer" is hardly informative
22:17:25 <lispy> vincenz: scala runs on the jvm (is binary compatibile with java) but it's an FP + OO language with static checking
22:17:38 * Patterner has visions of nude matz now...
22:17:45 <vincenz> lispy: right but not much moreso than say, java?
22:17:46 <lispy> vincenz: supposedly solves the expression problem
22:17:48 <vincenz> lispy: the static checking that is
22:17:55 <vincenz> lispy: define "expression problem"?
22:18:04 <lispy> vincenz: no, it's like haskell static checked
22:18:09 <lispy> vincenz: even has pattern matching
22:18:13 <dons> ?uptime
22:18:13 <mbot> uptime: 8h 17m 5s, longest uptime: 8h 17m 5s
22:18:13 <lambdabot> uptime: 1h 21m 36s, longest uptime: 2d 8h 20m 7s
22:18:20 <lispy> ?google wadler expression problem
22:18:20 <mbot> http://www.daimi.au.dk/~madst/tool/papers/expression.txt
22:18:22 <lambdabot> http://www.daimi.au.dk/~madst/tool/papers/expression.txt
22:18:23 <mbot> http://tinyurl.com/oe2bk
22:18:24 <lambdabot> http://tinyurl.com/oe2bk
22:18:27 <dons> mbot: @part
22:18:46 <Cale> mbot: @part #haskell
22:18:56 <vincenz> lispy: oh, seems much like ocaml's special sumtypes, forgot the name
22:19:02 <vincenz> lispy: the `A ones
22:19:08 <dons> ah yes.
22:19:21 * lispy doesn't actually know ocaml other than a few simplistic programs
22:19:45 <lispy> ?google scala expression problem
22:19:48 <lambdabot> http://lampwww.epfl.ch/papers/IC_TECH_REPORT_200433.pdf
22:20:21 <vincenz> lispy: http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html
22:20:24 <vincenz> section 4.2
22:20:24 <lambdabot> Title: Labels and variants, http://tinyurl.com/rjfec
22:20:25 <vincenz> "variants"
22:20:35 <vincenz> polymorphic variants
22:21:58 <lispy> vincenz: i don't know the expression problem real well, but i guess being able to solve it is useful...
22:22:07 * lispy needs to read up on it more
22:22:18 <vincenz> lispy: just check the link
22:23:21 <dolio> Well, once somebody goes ahead and implements open datatypes, haskell will solve it, too, right? :)
22:23:25 <lispy> vincenz: the variants?  i did...ocaml confuses me :)
22:23:55 <lispy> vincenz: for instance, what does this say:
22:23:55 <lispy> #[`On; `Off];;
22:23:56 <lispy> - : [> `Off | `On ] list = [`On; `Off]
22:24:09 <lispy> i have no clue...
22:24:23 <vincenz> it means that you havea list
22:24:26 <vincenz> of a data type
22:24:34 <vincenz> that has AT LEAST `Off and `On
22:24:48 <vincenz> and a list of those
22:25:04 <vincenz> kinda like
22:25:09 <vincenz> data A  = On | Off
22:25:12 <vincenz> but having it be open
22:25:36 <lispy> ah
22:25:49 <lispy> there is more to the expression problem than that though right?
22:25:54 <vincenz> dunno
22:25:59 <vincenz> as I read it, I don't think so
22:26:25 <lispy> like if you right a function when all you know about is On and Off then it better keep working the same when someone adds KindaOn
22:26:33 <lispy> s/right/write/
22:27:25 <vincenz> well it does
22:27:37 <vincenz> if I remember correctly
22:27:42 <vincenz> in haskellish syntax to make it clearer
22:27:49 <dylan> `Foo | `Bar is polymorphic variants
22:28:03 <vincenz> foo x = case x of `Off -> ... | `On -> ...
22:28:07 <vincenz> this will require a data type
22:28:13 <vincenz> [`Off | `On]
22:28:20 <vincenz> foo x = case x of `Off -> ... | `On -> ... | _ -> ...
22:28:23 <vincenz> this will require a data type
22:28:26 <vincenz> [> `Off | `On]
22:29:02 <dylan> aah, yes, the infamous feature that smerdy never understood what was good for...
22:29:24 <vincenz> dylan: smerdy is a troll
22:29:34 <dylan> vincenz: a troll with chanserv privledges.
22:29:36 <lispy> smerdy?
22:29:41 <vincenz> dylan: so?
22:29:45 <vincenz> dylan: he's an elitist troll
22:29:48 <dylan> vincenz: *shrugs*
22:29:51 <vincenz> he ruins the channel for all newbs
22:30:02 <lispy> Oh
22:30:06 <lispy> is he the dick in #ocaml?
22:30:27 <dylan> his name means "he who reeks" in russian, which sums it up nicely.
22:31:14 <vincenz> lispy: yes
22:32:04 <vincenz> I do believe that in early days shapr even asked him to leave #haskell, if my memory serves me well
22:32:25 <dylan> I rather enjoyed my time in #ocaml... a newbie would join, ask a question. Smerdy would tell them to Read That Fine Paper, and I'd just spit out ocaml code at them.
22:32:41 <vincenz> dylan: yes, and notice how big the channel was
22:33:10 <dylan> I noticed how big the entire ocaml community was.
22:33:16 <lispy> i find most language channels on irc to be hostile
22:33:24 <dylan> he's not an isolated troll...
22:33:26 <lispy> #java, ##c, #lisp, #ocaml
22:33:32 <vincenz> lispy: #haskell is an exception
22:33:35 <glguy> #haskell is the *worst*
22:33:35 <dons> yes, [#haskell ban Smerdyakov!*@* [by sagan.freenode.net, 2352045 secs ago]
22:33:37 <vincenz> dylan: how do you mean?
22:33:37 <lispy> yes
22:33:50 <lispy> heh
22:33:54 <dylan> vincenz: I've read similar elitism on the ocaml mailing lists, too
22:33:58 <vincenz> oh
22:34:01 <vincenz> it's a shame
22:34:09 <Adamant> #scheme is pretty nice
22:34:10 <vincenz> besides, elitism doesn't imply correctness
22:34:15 * vincenz is against any language zealot
22:34:15 <glguy> What are you guys trying to say? that #haskell doesn't have any 31337 users??
22:34:27 <dons> bring on the newbies! lambdas for all!
22:34:38 <vincenz> which is rather annoying, cause when you ask a channel about the features and flaws of a language, you get only the features, and that languages does EVERYTHING (tm)
22:34:42 <vincenz> @users
22:34:44 <lambdabot> Maximum users seen in #haskell: 238, currently: 203 (85.3%), active: 17 (8.4%)
22:34:44 <dons> > map (+1) [1..10] -- for anyone silenty lurking. get hacking with the bot
22:34:46 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:34:46 <dylan> @elite of course haskell is elite. ;)
22:34:46 <lambdabot> oF (Our$e hAskE|1 I5 1337. ;)
22:34:50 <vincenz> > replicate 203 "lambda-cookies"
22:34:51 <lambdabot>  ["lambda-cookies","lambda-cookies","lambda-cookies","lambda-cookies","lambda...
22:35:16 <glguy> > [id] <*> [()]
22:35:16 <lambdabot>  Not in scope: `<*>'
22:35:20 <dons> glguy: no no no.
22:35:34 * glguy does the anime airpuff sigh
22:35:41 <dylan> #haskell and related community resources reminds me of perl and debian communities. :)
22:35:45 <dons> I need to a) port hs-plugins to ghc 6.6, b) install 6.6 on lambdabot's box. c) do a nad b.
22:36:03 <glguy> dons: and until them I'm probably going to get errors every day ;)
22:36:07 <glguy> s/them/then
22:36:11 <dons> :P
22:36:22 <lispy> > (`map` [1..10]) $ ((*) `join`)
22:36:23 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
22:36:31 <lispy> there is a challenge for all the newbs
22:36:38 <glguy> ?
22:36:38 <lispy> why does that print the first 10 squares!
22:36:38 <dons> nice :)
22:36:42 <glguy> heh
22:37:07 <dons> we need a little collection of "Lispy's Puzzles" for beginners
22:37:09 <vincenz> lispy: that's nasty
22:37:12 <vincenz> lispy: for newbs
22:37:15 <glguy> > take 10 $ fix $ (1:) . scanl (+) 1
22:37:16 <vincenz> lispy: they'd need to know monads
22:37:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
22:37:18 <vincenz> @type join
22:37:20 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
22:37:26 * glguy challenges to newbs to explain that one
22:37:28 <dons> lispy: want to make a wiki page...  :)
22:37:28 <lispy> dons: i was just thinking of registering newbchallenge.org
22:37:29 <dons> or blog it?
22:37:44 <dons> nice idea
22:37:58 <lispy> or should it be n00b
22:38:04 <glguy> > (*2) `fmap` (+1) 7
22:38:05 <lambdabot>  add an instance declaration for (Num (f a))
22:38:15 <glguy> > ((*2) `fmap` (+1)) 7
22:38:16 <lambdabot>  16
22:38:20 <mlh> @hoogle join
22:38:21 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
22:38:21 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
22:38:21 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
22:38:29 <lispy> glguy: i admit, i need to master scanl still
22:38:34 <lispy> ?type scanl
22:38:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:39:11 <lispy> > scanl (+) 0 [1..10]
22:39:12 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
22:39:14 * glguy would like to see (.) generalized to fmap
22:39:37 <lispy> glguy: hmm...
22:39:46 <lispy> [1..3] . [4..5] == ??
22:40:07 <glguy> lispy: [1..3] `fmap` [4..5] ==??
22:40:14 <glguy> I don't think that means anything
22:40:20 <lispy> oh, i think i didn't understand you before
22:40:31 <lispy> i read fmap as Functor
22:40:35 <glguy> > fmap (^2) [1..10
22:40:35 <lambdabot>  Parse error
22:40:36 <glguy> > fmap (^2) [1..10]
22:40:38 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
22:40:48 <glguy> > (^2) . [1..10]
22:40:49 <lambdabot>  Couldn't match `a -> b' against `[a1]'
22:41:05 <mlh> in ghci, join wasn't found; can't I just make that `Monad.join` instead?
22:41:14 <lispy> ?type scanr
22:41:15 <glguy> :m Control.Monad.Reader
22:41:16 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
22:41:20 <glguy> mlh: type that ^^
22:41:22 <dons> hey thetallguy
22:41:28 <lispy> ?type scanl
22:41:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:41:49 <glguy> lispy: scan is just a fold that also returns intermediate results
22:42:03 <lispy> where does the name come from?
22:42:35 <glguy> > let maximum = foldl1 max in [1,5,2,7,3,5,10]
22:42:36 <lambdabot>  Add a type signature
22:42:37 <mlh> glguy: ?
22:42:42 <glguy> > let maximum = foldl1 max in maximum [1,5,2,7,3,5,10]
22:42:43 <lambdabot>  10
22:42:52 <glguy> > let maximum = scanl1 max in maximum [1,5,2,7,3,5,10]
22:42:53 <lambdabot>  [1,5,5,7,7,7,10]
22:43:19 <glguy> mlh: when join is used in that way, you need to load Control.Monad.Reader
22:43:32 <lispy> glguy: interesting
22:43:53 <lispy> > scanl (+) 0 [1..10]
22:43:55 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
22:43:58 <lispy> ah
22:44:00 <glguy> > let sum = foldl (+) 0 in sum [1..10]
22:44:02 <lambdabot>  55
22:44:06 <glguy> > let sum =scanl (+) 0 in sum [1..10]
22:44:07 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
22:44:30 <lispy> so in one sense scan is like a generalized fold
22:44:47 <glguy> kind of.. but you can do what scan does iwth a fold
22:44:51 <glguy> you cann't do what fold does with a scan
22:45:10 <dons> no?
22:45:16 <lispy> ?type foldl
22:45:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:45:18 <lispy> ?type scanl
22:45:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:45:21 <mlh> glguy: ta. still baffled, but ta :-)
22:45:25 <dons> isn't it the other way around?
22:45:28 <glguy> fold can be made to return a list
22:45:35 <glguy> scan can not be made to not return a list
22:45:41 <glguy> (unless you just call last on the result)
22:46:01 <lispy> any idea where the name came from though?
22:46:37 <glguy> I don't know anything concrete
22:46:56 <dons> exactly, it returns fold, plus all prefixes
22:47:18 <glguy> making it a special case of fold :-p
22:47:26 <dons> ?scheck \f z xs -> head (scanr f z xs) == foldr (f :: Bool -> Bool -> Bool) z xs
22:47:28 <lambdabot>  Completed 16352 test(s) without failure.
22:47:34 <dons> making fold a special case of scanl :)
22:47:37 <lispy> dons: what would be cooler than a random newbchallenge would be a tutorial where you write your code in haskell on the website and as long as it computes the predefined answer then you get the question right and move forward to the next exercise (and we can do this now)
22:48:00 <dons> mmm nice idea.
22:48:12 <lispy> dons: not my idea, it's how i learned lisp :)
22:48:46 <lispy> dons: if we had user accounts + multiline input in lambdabot then we'd just need to write the thing
22:49:02 <dons> yeah
22:49:10 <lispy> so, let's get hacking :)
22:49:13 <lispy> i'm sold
22:49:38 <lispy> the user accounts thingy we can solve by allowing people to use openid
22:49:42 <glguy> > let f = foldl (\y x -> head y + x : y) [0] in f [1..10]
22:49:44 <lambdabot>  [55,45,36,28,21,15,10,6,3,1,0]
22:49:48 <lispy> then we just need some logic and maybe a db to store data in
22:49:51 <glguy> there's fold doing scan's job
22:50:05 <glguy> now show me scan doing a sum
22:50:44 <lispy> dons: i'm trying to solve the open id thing but the guy who has a partial haskell implementation isn't getting back to me
22:51:34 <lispy> glguy: just call last
22:51:48 <glguy> lispy: exactly, it doesn't stand on its own ;)
22:51:53 <lispy> glguy: it gave you all the sums, it was just that you only needed the last :)
22:52:11 <glguy> right, its the special case where you get all of the results
22:52:17 <glguy> (c:
22:52:23 <dons> isn't more results == more general...
22:52:32 <glguy> no, more general is more general
22:52:38 <glguy> more types of results
22:52:39 <lispy> > let f = scanl (\y x -> head y + x : y) [0] in f [1..10]
22:52:41 <lambdabot>  [[0],[1,0],[3,1,0],[6,3,1,0],[10,6,3,1,0],[15,10,6,3,1,0],[21,15,10,6,3,1,0]...
22:52:46 <glguy> and the ability to encapsulate the fuunctionality
22:53:11 <glguy> it doesn't matter
22:53:15 <glguy> I'm just being argumentative
22:53:15 <lispy> there is more than one way to generalize
22:54:38 <glguy> "Nationally recognized as the best in the state"
22:54:40 <glguy> wtf is that?
22:55:05 <glguy> hmm, now I'm arguing with the TV
22:55:09 <glguy> might be time for bed
22:55:20 <dons> ?scheck \xs -> last (scanl (\a b -> a + b) (0::Int) xs) == sum xs
22:55:24 <lambdabot>  Completed 623530 test(s) without failure.
22:55:43 <glguy> scan's functionality is subsumed by fold!
22:55:56 <dons> folds functionality is subsumed by scan!
22:56:02 <glguy> lies
22:56:04 <vincenz> GRrr
22:56:26 <dons> scan + last == fold, fold + random stuff = scan
22:56:33 <glguy> exactly
22:56:37 <glguy> subsumed ;)
22:56:46 <dons> and since scan+last is easier to remember, scan wins
22:56:49 <lispy> fold + random stuff + last = fold :)
22:57:16 <glguy> you should write a paper on that ;)
22:59:48 <glguy> did you make any progress picking scala
23:00:00 <glguy> I want you to learn more about it and tell us more :)
23:00:02 <lispy> what do you mean?
23:00:02 <lispy>            
23:00:28 <lispy> the class doesn't start till tuesday
23:00:36 <lispy> so, i don't need to pick it anytime soon :)
23:00:40 <lispy> but scala seems good
23:00:47 <lispy> but what project to do?
23:01:22 <lispy> i can think of lots of things i want to do but when i constrain it to this, i'm less ideaful
23:03:12 <lispy> whoa, you can have varadic functions in haskell? does that mean the arity varies?
23:03:37 <dolio> Yeah.
23:03:56 <glguy> example?
23:04:19 <dolio> http://okmij.org/ftp/Haskell/types.html
23:04:21 <lambdabot> Title: Haskell Programming: Types
23:04:40 <dons> ?type printf [] 'x'
23:04:41 <lambdabot> forall t. (PrintfType (Char -> t)) => t
23:04:48 <dons> ?type printf [] 'x' 'y' 'z' (1::Int)
23:04:50 <lambdabot> forall t. (PrintfType (Char -> Char -> Char -> Int -> t)) => t
23:05:31 <dons> ?type printf [] 'x' 'y' 'z' (1::Int) :: String
23:05:32 <lambdabot> String :: String
23:10:08 <lispy> dolio: that link is pretty cool
23:10:34 <dolio> Yeah. There's lots of stuff there I only kind of understand. :)
23:16:01 <falconair> haskell.org is down?  i can't get any news on the status of GHC 6.6 (among other haskell news)
23:16:30 <dons> yes, it's down.
23:16:59 <dons> ghc 6.6 may have another RC this week
23:17:14 <emertens> hmm... h.o is down
23:17:21 <Patterner> all the people who can put that in the /topic are sleeping at the moment...
23:17:42 <falconair> btw, is there one location where one can read all research papers related to haskell?
23:17:46 <dons> you really want it in the topic?
23:17:54 <dons> falconair: yes, haskell.org/ :)
23:18:00 <dons> under the 'Research papers' link
23:18:12 --- mode: ChanServ set +o dons
23:18:13 <ThreeQ> is there a short one-liner that would do this? [[1,2],[3],[4,5,6]] -> [[1,3,4],[2,3,4],[1,3,5],[2,3,5],[1,3,6],[2,3,6]]
23:18:31 <glguy> sequence?
23:18:35 <falconair> heh, i meant new papers, as they are released...so i can keep up
23:18:50 <glguy> > sequence [[1,2],[3],[4,5,6]]
23:18:51 <lambdabot>  [[1,3,4],[1,3,5],[1,3,6],[2,3,4],[2,3,5],[2,3,6]]
23:18:52 --- topic: set to '["Haskell.org is temporarily down", "Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/", "Haskell - The language of choice for discriminating hackers"]' by dons
23:18:56 --- mode: ChanServ set -o dons
23:18:56 <ThreeQ> holy crap
23:19:04 <ThreeQ> how did I not see sequence
23:19:09 <dons> falconair: yes, new papers go up there
23:19:10 <ThreeQ> thanks, glguy :)
23:19:19 <dons> but maybe we should keep a list of them ordered by when they appear.
23:19:22 <glguy> ThreeQ: because that's not what sequence is "for" specifically
23:19:26 <dons> so people know what is new
23:19:49 <dons> falconair: check sequence.complete.org for new papers from the haskell workshop
23:20:20 <falconair> thanks dons
23:23:30 <lennart> ThreeQ: even if you have been doing haskell for 15 years you can miss using sequence like that :)
23:23:53 <ThreeQ> lennart: yes, but it makes perfect sense when you think about it that way
23:24:04 <lennart> yes, it does
23:25:04 <lennart> but the list monad is a bit strange (and so is the (a->) monad)
23:25:31 * glguy thrives on finding uses for Monadic functions
23:25:55 <ThreeQ> what would be an example of using the (a->) monad?
23:26:07 <glguy> > join (+) 2
23:26:09 <lambdabot>  4
23:26:14 <lennart> > join (*) 5
23:26:15 <lambdabot>  25
23:26:15 <glguy> > join (,) 3
23:26:17 <lambdabot>  (3,3)
23:26:33 <ThreeQ> oh!
23:26:50 <glguy> > liftM2 (/) sum genericLength [1,3,7,20]
23:26:51 <lambdabot>  7.75
23:27:00 <glguy> arithmetic mean ^^
23:27:19 <ThreeQ> wow
23:27:34 <ThreeQ> haskell is pretty neat
23:28:00 <lennart> > sequence [sin, cos, exp] (pi/2)
23:28:01 <lambdabot>  [1.0,6.123031769111886e-17,4.810477380965351]
23:29:14 <glguy> > ap (,) (+1) 4
23:29:16 <lambdabot>  (4,5)
23:30:11 <lispy> > ap (,) (+1) (snd ((ap (,) (+1) 4)))
23:30:13 <lambdabot>  (5,6)
23:30:16 <dolio> > ap (+) (2/) 1
23:30:18 <lambdabot>  3.0
23:30:38 <dolio> > ((/2) . ap (+) (2/)) 1
23:30:40 <lambdabot>  1.5
23:31:02 <glguy> > (  (+1) `fmap` (*2) ) 3
23:31:03 <lambdabot>  7
23:31:21 <dolio> >  fix $ scanl (const (/2) . ap (+) (2/)) 1
23:31:22 <lambdabot>  [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.953125...
23:31:34 <dolio> Oops.
23:31:44 <glguy> looking for radical 2 approximations?
23:31:49 <dolio> >  fix $ scanl (const ((/2) . ap (+) (2/))) 1
23:31:51 <lambdabot>  [1.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.41421356...
23:32:15 <glguy> uses the continued fraction approximation ^^
23:32:23 <lennart> hey, that's a cool one
23:32:24 <lispy> > scanl (const ((/2) . ap (+) (2/))) 1
23:32:25 <lambdabot>  Add a type signature
23:32:28 <dolio> Turning that into radical n makes it a lot more cryptic.
23:32:34 <lispy> > scanl (const ((/2) . ap (+) (2/))) 1 :: [Double]
23:32:35 <lambdabot>    Expecting a function type, but found `[Double]'
23:32:36 <lambdabot>    Expected type: [Do...
23:32:38 <lispy> hmm...
23:33:00 <dolio> lennart: xerox came up with it, not me.
23:33:04 <lispy> what are you feeding to fix?
23:33:33 <glguy> > take 5 $ map (foldr1 (\x y -> x + 1 / y) . (1:)) $ inits [2,2..]
23:33:34 <lambdabot>  [1.0,1.5,1.4,1.4166666666666667,1.4137931034482758]
23:34:20 <lispy> ?type scanl
23:34:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:34:27 <ThreeQ> scanl hasn't been fully applied there
23:34:31 <lispy> right
23:34:33 <lennart> ?pl \x y -> x + 1 / y
23:34:33 <lambdabot> (. (1 /)) . (+)
23:34:37 <lispy> ?type fix
23:34:38 <lambdabot> forall a. (a -> a) -> a
23:34:43 <dolio> lispy: (/2) . ap (+) (2/)  takes a value x and computes (x + 2/x)/2
23:34:58 <dolio> const f extends that to two parameters.
23:35:20 <glguy> > take 5 $ map (foldr1 (\_ y -> 2 + 1 / y) . (1:))  [2,2..]
23:35:20 <lambdabot>  add an instance declaration for (Num [a])
23:35:21 <lambdabot>   In an arithmetic sequence: [2...
23:35:33 <dolio> fix (scanl (const f) 1) computes successive iterations of that, starting with 1.
23:35:50 <lennart> hey, pl didn't spot (1/) being recip :)
23:36:15 <dolio> The accumulator and parameter will be the same in this case, so you use const to just throw one away.
23:37:05 * lispy still struggles with fix
23:37:46 <lispy> > fix id
23:37:47 <lambdabot>  Add a type signature
23:37:55 <lennart> fix takes a function, f, and returns a value, x, such that (f x)==x
23:37:58 <lispy> > fix (+1)
23:38:00 <lambdabot>  Exception: <<loop>>
23:38:03 <lispy> oh
23:38:25 <lispy> how does it find x?
23:38:48 <lennart> well, it returns the smallest one in a particular ordering
23:38:50 <lispy> by calling fix (f.f) ?
23:39:19 <glguy> > take 10 $ map (subtract 1) $ iterate ((2+).recip) 2
23:39:20 <lambdabot>  [1.0,1.5,1.4,1.4166666666666665,1.4137931034482758,1.4142857142857141,1.4142...
23:39:22 <lennart> it's found by iteration (recursion)
23:39:29 <ThreeQ> lennart: how can it do that for all types?
23:39:36 <ThreeQ> wouldn't it have to be an instance of Ord?
23:39:47 <lennart> the ordering is not that ordering
23:40:00 <lennart> it's the information ordering in a CPO
23:40:01 <lispy> haha
23:40:06 <lispy> ?google prelude fix
23:40:09 <lambdabot> http://www.10w40.com/individual/100508.asp
23:40:09 <lambdabot> Title: 1984 - 1991 Honda Accord and Prelude Repair Manual at 10W40.com
23:40:13 <lispy> not at all, what i wanted :)
23:40:15 <lennart> the least element is _|_ (undefiend)
23:40:54 <vincenz> Ok this is whakced
23:40:56 <ThreeQ> what's a CPO?
23:40:56 <lispy> ?index fix
23:40:57 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
23:40:58 <lennart> operationally, fix really just does recursion
23:41:17 <lennart> CPO = Complete Partial Order
23:42:01 <ThreeQ> ?google complete partial order
23:42:03 <lambdabot> http://en.wikipedia.org/wiki/Complete_partial_order
23:42:04 <lispy> lennart: i wanted to read the haskell definition, do you happen to know it?
23:42:05 <lennart> denotationally (fix f) gives you LUB(f^n(_|_))
23:42:23 <lennart> let fix f = f (fix f)
23:42:25 <lispy> what does f^n mean?
23:42:32 <lennart> f iterated n times
23:42:33 <dolio> You can expand fix f = f (fix f), and then when you apply it to arguments, you expand like that as many times as you need to get a value.
23:42:34 <vincenz> fuck
23:42:35 <ThreeQ> f applied n times, I'd imagine
23:42:36 <ThreeQ> yeah
23:42:39 <vincenz> anyone here use pmwiki?
23:43:15 <lennart> so you get the smallet value of _|_ f(_|_) f(f(_|_)) ...
23:43:42 <lispy> okay, so fix f searches for an x so such that f x == x, but it's just implemented as fix f = f (fix f)...so what am i missing?
23:43:49 <lennart> nothing
23:44:06 <lispy> how does the recursion stop
23:44:20 <lennart> sometimes it doesn't
23:44:30 <lispy> oh, when fix f = x
23:44:34 <lispy> ah i think i get it
23:45:04 <lennart> looping (i.e., bottom) might be the smallest value fulfilling f x = x
23:45:08 <glguy> > take 10 $ map(+(-1)) $ fix ((2:).map((2+).recip))
23:45:10 <lambdabot>  [1.0,1.5,1.4,1.4166666666666665,1.4137931034482758,1.4142857142857141,1.4142...
23:45:12 <Cale> lispy: The way to think of it is that f might return something usable right away
23:45:22 <Cale> even without knowing the value of its parameter
23:45:37 <Cale> > fix ((:0) . map (+1))
23:45:38 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
23:45:39 <lennart> > fix (const 1)
23:45:39 <lambdabot>    Expected...
23:45:40 <lambdabot>  1
23:45:42 <Cale> > fix ((0:) . map (+1))
23:45:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:46:06 <Cale> > fix ((0:) . scanl (+) 1)
23:46:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:46:16 <lispy> fix (const 1) == const 1 (fix (const 1)) == 1
23:46:25 <Cale> right
23:46:27 <lispy> that makes sense
23:46:31 <glguy> iterate f x = fix ((x:).map f)
23:46:52 <lispy> is that how the prelude defines it?
23:47:05 <Cale> not quite
23:47:16 <Cale> (it just defines it with implicit recursion)
23:47:32 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
23:47:33 <lambdabot>  120
23:47:37 <dolio> It uses the let x = f x... version.
23:47:40 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 20
23:47:42 <lambdabot>  2432902008176640000
23:47:51 <Cale> there's factorial :)
23:48:23 <lispy> slick
23:48:37 <lennart> fix has type (a->a)->a, but the type a is almost always a function when you use fix
23:48:42 <lispy> > (\n -> product [1..n]) 20
23:48:43 <lambdabot>  2432902008176640000
23:49:18 <glguy> I remember what class I was in when I was reading Hudak's book and discovered fix
23:49:25 <glguy> life altering...
23:49:26 <glguy> ;)
23:49:30 <ThreeQ> is there anything else that fix will really work on?
23:49:31 <lennart> heh
23:49:39 <glguy> it was a cognitive psych course
23:49:42 <glguy> night class
23:49:52 <glguy> just as the quizes were being handed out
23:50:06 <lennart> > fix (1:)
23:50:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:50:21 <ThreeQ> other than functions, I mean
23:50:28 <dolio> I just watched the SICP lecture where Sussman explained the Y combinator earlier tonight.
23:50:35 <dolio> He put on a cape.
23:50:40 <lennart> ThreeQ: I just gave you one
23:50:41 <dolio> And a suit jacket.
23:50:42 <glguy> > take 10 $ fix ((1:). scanl1 (+))
23:50:44 <lambdabot>  [1,1,2,4,8,16,32,64,128,256]
23:50:57 <lispy> is fix = Y?
23:51:02 <ThreeQ> oh
23:51:03 <lennart> the infinite list of 1s is the fixpoint of 1:
23:51:03 <dolio> Yeah.
23:51:13 <ThreeQ> (:) isn't a function, that's right
23:51:23 <lispy> ?type (:)
23:51:25 <lambdabot> forall a. a -> [a] -> [a]
23:51:25 <lennart> (:) is a function
23:51:41 <glguy> > take 10 $ fix ((1:).scanl (+) 1)
23:51:42 <lennart> but the 'a' type in fix is [Int] in this case
23:51:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
23:51:58 <ThreeQ> oh
23:52:00 <lennart> ?type (1:)
23:52:02 <lambdabot> forall a. (Num a) => [a] -> [a]
23:52:04 <dolio> The infinite list of 1s is the value such that when you cons a 1 onto the front, you get the same thing.
23:52:10 <ThreeQ> got it
23:52:31 <lispy> > scanl (+) 1 [1..10]
23:52:33 <lambdabot>  [1,2,4,7,11,16,22,29,37,46,56]
23:53:14 <lispy> ?type ((1:).scanl (+) 1)
23:53:16 <lambdabot> forall b. (Num b) => [b] -> [b]
23:53:41 <lispy> > ((1:).scanl(+)1) [1..10]
23:53:43 <lambdabot>  [1,1,2,4,7,11,16,22,29,37,46,56]
23:54:04 <lispy> so why is it off by one compared to the fix version?
23:54:12 <lispy> > ((1:).scanl(+)1) [1,1,2..10]
23:54:13 <lambdabot>  Parse error
23:54:40 <lispy> er, no it's not off by one
23:54:41 <lennart> lispy: huh?
23:54:44 <lispy> it's just differente
23:55:00 <lispy> > take 10 $ fix ((1:).scanl (+) 1)
23:55:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
23:55:06 <lispy> > ((1:).scanl(+)1) [1..10]
23:55:07 <lambdabot>  [1,1,2,4,7,11,16,22,29,37,46,56]
23:55:16 <lennart> very different
23:55:32 <lennart> one is fibonacci numbers, one is partial sums
23:55:53 * lispy has to think about these
23:56:00 <ThreeQ> > take 10 $ fix (scanl (+) 1)
23:56:02 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
23:56:17 <foxy> > fix (+ 1)
23:56:18 <lambdabot>  Exception: <<loop>>
23:56:35 <foxy> fix (scanl (+) 1)
23:56:47 <foxy> > fix (scanl (+) 1)
23:56:49 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
23:57:20 <foxy> > fix (foldl (+) 1)
23:57:21 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]
23:57:21 <lambdabot>    Expected...
23:57:23 <lispy> > scanl (+) 1 []
23:57:24 <lambdabot>  [1]
23:57:27 <lispy> Ah
23:57:57 <lennart> > scanl (+) 1 undefined
23:57:58 <lambdabot>  Undefined
23:58:05 <lennart> bah!
23:58:10 <lispy> so that's doing scanl (+) 1 [] = [1], then scanl (+) 1 [1] = [1,2], then scanl (+) 1 [1,2] = [1,2,4] and so on right?
23:58:27 <lennart> almost
23:58:28 <Cale> > head $ scanl (+) 1 undefined
23:58:30 <lambdabot>  1
23:58:39 <lennart> except that it starts with _|_
23:58:40 <Cale> > take 1 $ scanl (+) 1 undefined
23:58:40 <lispy> > scanl (+) 1 [1]
23:58:41 <lambdabot>  [1]
23:58:42 <lambdabot>  [1,2]
23:58:48 <lispy> > scanl (+) 1 [1,2]
23:58:49 <lambdabot>  [1,2,4]
23:58:57 <lispy> hrm
23:59:47 <ThreeQ> > fix $ scanl (*) 2
23:59:48 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
23:59:53 <dolio> Operationally, scanl f b always produces b as a first element, so it provides a starting point.
