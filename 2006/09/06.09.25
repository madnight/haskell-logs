00:00:00 <dons> $ ./setup configure --prefix=/tmp --with-compiler=/home/dons/bin/ghc-6.4.2
00:00:22 <dons> you could also specify the path to the compiler with the: --with-compiler=c:\...\...
00:00:23 <newsham> (or add it in My Computer->Properties->Advanced->Environment Variables)
00:00:46 <x3m> alright, that wasnt in the readme
00:01:12 <dons> it's a general programming thing. you need to ensure your ghc is in scope if you're going to use it.
00:01:20 <dons> same with g++ or gcc or perl or whatever
00:05:05 <x3m> i might have made it
00:05:18 <x3m> configure: .... alot of text
00:05:26 <dons> yes?
00:05:33 <dons> and you've run setup build and then setup install ?
00:05:57 <x3m> then at the botton: configure: No happy found... and so on, alot No xxxxx found and last also: setup: Cannot find: sh
00:06:11 <dons> ah.
00:06:19 <dons> the missing happy and so on is ok.
00:06:21 <newsham> sh not often found on windows :)
00:06:39 <dons> right. there's a 'configure' sh script
00:06:42 <x3m> other than that i guess its installed
00:06:52 <dons> x3m, nope, you haven't built it yet, have you?
00:06:57 <dons> did you run: setup build
00:06:59 <x3m> umm no
00:07:06 <dons> newsham: any ideas on how to run the configure script?
00:07:48 <newsham> cygwin?  dunno...
00:07:59 <dons> hmm, we might be able to work around it.
00:08:00 <newsham> what's being built?
00:08:04 <dons> hs-plugins
00:08:19 <goltrpoat> there's also sh-utils for windows
00:08:20 <dons> (which is known to build under mingw at least)
00:08:23 <goltrpoat> i don't know how well it works
00:08:31 <newsham> you could preconfigure it for windows using cygwin (or by hand)
00:08:45 <newsham> and have it skip the config if its windows
00:09:09 <x3m> Building plugins-1.0... Chasing modiles from: .....................  src/Language/Hi/Parser.hs:51: ../../../config.h: No such file or directory
00:09:18 <dons> right. because config.h is built by the configure script
00:09:22 <dons> so you'll have to do that by hand.
00:09:32 <dons> let me create a stub for you to fill out
00:09:37 <newsham> i have windows an d6.4.2,  i can try configure here and give you config.h
00:09:38 <x3m> ok
00:09:45 <dons> or try that, yes.
00:09:59 <x3m> its 9 am here now, im running high on coffee :)
00:10:03 <dons> here's one for openbsd, http://www.cse.unsw.edu.au/~dons/tmp/config.h
00:10:05 <newsham> which version?  0.9.10?
00:10:19 <dons> newsham: 1.0rc0
00:10:40 <dons> x3m, you'll need to change the values of: GHC_LIB_PATH, HAVE_ARC4RANDOM, and TOP
00:10:51 <vincenz> dcoutts: ping
00:10:55 <dons> and maybe __MINGW32__ too
00:10:57 <newsham> hmm.. i wonder if this is going to make it try to link in cygwin libs.
00:11:08 <newsham> probably would be better using mingwin (which I dont have installed on this machine)
00:11:10 <dons> well, its certainly built on windows before without cygwin
00:11:13 <dons> yes.
00:11:21 <dons> mingw is better, (and the result is faster too)
00:11:26 <vincenz> @tell dcoutts I'm afraid that I'm going to have to remove my wiki website, the one that you refer to for the RBtree.hs for gtk2hs.  I upgraded to the latest pmwiki, and still someone keeps hacking it :/
00:11:27 <lambdabot> Consider it noted.
00:11:40 <dons> x3m, so buliding hs-plugins on windows without mingw is _untested_
00:11:49 <dons> so depends on how bad you want this eval bot :)
00:12:10 <x3m> what do i have to do
00:12:13 <x3m> install mighw?
00:12:27 <x3m> im not installing cygwin at least
00:12:53 <dons> mingw, that would be the easiest way. or you could try grabbing http://www.cse.unsw.edu.au/~dons/tmp/config.h and manually adjusting the variables to match your system
00:13:07 <x3m> i'll try the later
00:13:18 <dons> yeah, maybe that will work. let's see...
00:13:48 <newsham> http://www.thenewsh.com/%7Enewsham/x/hs-plugins/ has config.h and config.mk
00:13:53 <lambdabot> Title: Directory /~newsham/x/hs-plugins/, http://tinyurl.com/zfk8q
00:14:07 <dons> ah even better
00:14:09 <newsham> configs needed for the test cases too?
00:14:31 <dons> no, let's ignore the test cases...
00:14:44 <dons> x3m, so grab http://www.thenewsh.com/%7Enewsham/x/hs-plugins/config.h
00:14:46 <lambdabot> http://tinyurl.com/f3c9g
00:15:10 <dons> and adjust the value of: TOP, GHC_LIB_PATH, and I think CYGWIN
00:15:26 <dons> newsham++
00:16:33 <goltrpoat> are predicates commonly called 'judgement forms', or is this book just making up its own terminology
00:17:07 <dons> no, that's a common use
00:17:07 <JKnecht> what book is that?
00:17:16 <dons> particularly in PL books
00:17:27 <dons> particularly, particularly those about FP languages :)
00:17:48 <goltrpoat> jknecht - "practical foundations for programming languages", harper
00:18:03 <dons> ?where plbook
00:18:04 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
00:18:05 <goltrpoat> dons:  ah ok.  weird that ive never seen it before
00:18:08 <dons> for example
00:18:13 <dons> ah, that is the book :)
00:18:26 <goltrpoat> hehe
00:18:39 <dons> i thought i recognised the terminology ;)
00:19:10 <dons> (was even going to say, particularly, particularly, particularly text books from CMU)
00:19:18 <goltrpoat> ah
00:19:31 <dons> ?google judgements as types
00:19:33 <lambdabot> http://en.wikipedia.org/wiki/LF_(logical_framework)
00:20:14 <x3m> /* #undef DEBUG */ should this be comment?
00:20:22 <x3m> doh wrong one
00:20:29 <x3m> /* #undef CYGWIN */
00:20:38 <dons> i think that sould be undef'd yes.
00:21:25 <x3m> http://www.tomsvensson.com/dread/files/config.h
00:21:28 <lambdabot> http://tinyurl.com/qmdwq
00:21:58 <x3m> looks ok?
00:23:01 <dons> you could leave the CYGWIN thing in /* */
00:23:16 <dons> better look at newsham's example though
00:23:34 <dons> since some other things are wrong, http://www.thenewsh.com/%7Enewsham/x/hs-plugins/config.h
00:23:36 <lambdabot> http://tinyurl.com/f3c9g
00:23:40 <dons> i.e. HAVE_ARC4RANDOM
00:24:50 <zarvok> vincenz: ping
00:25:44 <zarvok> @tell vincenz You should watch the ICFP video, if you haven't lazy bottoms are featured several times
00:25:44 <lambdabot> Consider it noted.
00:27:11 <dcoutts__> vincenz: ok, that's a shame.
00:27:13 <Bourbaki> moin
00:27:29 <x3m> whats better in newsham's example?
00:28:25 <x3m> dons: his file is the same? except they dont have cygwin commented
00:28:41 <dons> and a couple of the other #defines are correct?
00:28:56 <dons> i.e. HAVE_ARC4RANDOM should not be defined
00:29:01 <dons> since you  don't have it
00:29:08 <Bourbaki> dons did you have a look at the files?
00:29:21 <x3m> alright
00:29:26 <dons> not yet. /me is snowed under.
00:29:49 <Bourbaki> uh?:) arent you in .au? :)
00:31:57 <x3m> ok now i have the .h file done, where do i put it and do?
00:33:43 <dons> it should be in the same directory as the hs-plugins source
00:33:46 <dons> next to config.h.in
00:33:51 <dons> then try to run: setup build
00:35:33 <musasabi> Any idea when will GHC 6.6 be released?
00:35:53 <dons> I think Igloo wants to put out a new RC first
00:36:17 <x3m> it compiled pretty much ended with: Compiling System.Plugins (src/System/Plugins.hs, dist\build\System\Plugins.o) setup: Cannout find: ar
00:36:52 <dons> newsham: do we know if Cabal run on windows without 'ar' or other linker tools?
00:37:01 <dons> or does Cabal itself require mingw?
00:39:24 <dons> x3m, so I suspect (only suspect mind you) that you need mingw to use cabal-based build systems
00:39:33 <dons> x3m, you can confirm this with ndm
00:39:44 <dons> (it makes sense, if you're going to be doing more haskell dev, btw)
00:40:17 <x3m> i dont get why you have made so it need mingw at all
00:40:46 <dons> Cabal, the build system used by haskell libraries, seems to need 'ar' to build library archives (I think).
00:40:48 <goltrpoat> visual haskell does some sort of VS integration magic to keep cabal files in sync with visual studio solution files
00:40:55 <dons> ah right
00:41:08 <newsham> gjc comes with ar in windows
00:41:26 <dons> x3m, so perhaps then check if there's an 'ar' on your system some where
00:41:31 <newsham> ar.exe       ghc.exe   ghcii.sh     hasktags.exe  hsc2hs.exe  runhaskell.exe
00:41:33 <newsham> ghc-pkg.exe  ghci.exe  ghcprof.prl  hp2ps.exe     runghc.exe  stat2resid
00:41:35 <x3m> is it a program?
00:41:36 <dons> how do you build C++ library arhicves without 'ar'?
00:41:55 <x3m> dons: i got ar.exe in my /bin
00:42:01 <dons> ok. so that's what we need.
00:42:11 <x3m> maybe i should copy it somewhere?
00:42:19 <dons> or ensure it's in your path variable?
00:42:25 <newsham> you should have the c:\ghc\ghc-6.4.2\bin dir in your path
00:43:08 <dons> also, I see a flag to configure you could use:
00:43:09 <dons> --with-ar=PATH
00:43:35 <dons> so try that, setup configure --prefix=c:\your\path --with-ar=c:\bin\my\path\to\ar.exe
00:43:38 <dons> ?
00:43:49 <x3m> k
00:46:13 <goltrpoat> somewhat tangentially, what on earth happened to the haskell .Net project anyway?  looks like it's been dead for three years now, but the site is still around
00:46:44 <goltrpoat> i remember don syme was having some serious problems incorporating typeclass-style constructs into F#, maybe that's why
00:47:17 <x3m> gah i sitll get Cannot find: ar
00:47:32 <goltrpoat> (dictionaries carried around appdomain boundaries making no sense in the context, or some such)
00:47:52 <newsham> x3m: did you put ghc's bin dir in your path?
00:48:36 <dons> x3m can you add the build -v4 flag?
00:48:48 <dons> then you should be able to see exactly what command the system ran.
00:48:54 <dons> i.e.
00:48:54 <dons> /usr/bin/ar: creating dist/build/libHSplugins-1.0.a
00:48:55 <dons> /usr/bin/ld -r -x -o dist/build/HSplugins-1.0.o dist/build/AltData/Dynamic.o ...
00:49:02 <dons> /usr/bin/ar q dist/build/libHSplugins-1.0.a  ...
00:49:08 <x3m> newsham: i havent touched my path, my system variable path contains path to MS D3D SDK and nvidia CG
00:49:23 <Bourbaki> does anyone of you know a good site for self refferential machines and the notion?
00:49:42 <newsham> you should put ghc's bin dir in your path
00:49:56 <x3m> dons: setup build -v4?
00:50:05 <dons> yep. but you should listen to newsham :)
00:50:13 <dons> you'll need ghc's bin dir in your path
00:50:23 <x3m> oh
00:50:34 <x3m> cant i just copy ar somewhere
00:50:52 <dons> setting the path variable would be easier, surely? and less error prone.
00:51:38 <x3m> maybe
00:51:56 <JKnecht> Bourbaki: you mean meta-interpretation?
00:52:08 <newsham> set path=%path%;c:\ghc\ghc-6.4.2\bin
00:52:18 <newsham> from cmd prompt (for temporary add)
00:52:22 <Bourbaki> JKnecht think of a program as a graph that modify itself
00:52:36 <x3m> newsham: temporary.. when is it removed?
00:52:52 <newsham> when the window goes away
00:53:20 <newsham> or for more permanent, right click "My Computer", properties, advanced, environmetn variables, edit the path
00:53:31 <newsham> then open a new cmd window after thats done
00:54:06 <goltrpoat> bourbaki:  there are some links at http://www.self-programming-machines.org/
00:54:18 <Bourbaki> thx
00:54:38 <x3m> newsham i got it in C:/Program Files/ghc/ghc-6.4.2/bin though
00:54:48 <x3m> that space causes problems i guess
00:55:03 <newsham> you can use  progra~1 instead of program files
00:55:06 <x3m> set path=%path%;"C:/Program Files/ghc/ghc-6.4.2/bin" or should i do like that
00:55:11 <x3m> alright
00:55:33 <newsham> the quotes might work, not sure..  cmd is not my strong point.
00:56:13 <goltrpoat> the quotes are fine
00:56:14 <x3m> hah yikes
00:56:41 <x3m> now it says Skipping System.Eval.... and so on, instead of compiling
00:56:47 <dons> that's good!
00:57:13 <dons> it's already compiled those things, you're waiting to see if it will _link_ them at the end.
00:57:31 <x3m> last line says: c:\progra~1\ghc\ghc-6.4.2bin\ar.exe: creating dist\build\libHSplugins-1.0.a
00:57:45 <dons> ok. good.... i think
00:57:56 <x3m> what now, setup install or something?
00:58:05 <dons> the last line I have is:
00:58:06 <dons>  /usr/bin/ar: creating dist/build/libHSplugins-1.0.a
00:58:07 <dons> /usr/bin/ld -r -x -o dist/build/HSplugins-1.0.o
00:58:08 <dons> ...
00:58:13 <dons> did ld run?
00:58:27 <x3m> ld?
00:58:29 <dons> and create dist\build\HSplugins-1.0.o
00:58:35 <x3m> umm no
00:58:39 <vincenz> zarvok: I noticed :)
00:58:40 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
00:58:53 <dons> newsham: does ld.exe come with ghc too?
00:59:09 <vincenz> dcoutts__: yeah, I don't get it :/
00:59:15 <dons> x3m, do you have an ld.exe somewhere? in bin?
00:59:16 <x3m> dons: dont look like it
00:59:25 <dons> how do you link your C and C++ programs then?
00:59:36 <x3m> VS handles all of that
00:59:36 <newsham> yah, it comes with full gcc, dons.
00:59:42 <vincenz> dons: just read someone completely bashing haskell :/
00:59:44 <newsham> ghc/ghc-6.4.2/gcc-lib/ld.exe
00:59:48 <dons> ok. good.
00:59:52 <dons> x3m ^^^
01:00:03 <x3m> ah yep, in there it was
01:00:03 <dons> maybe you need to add ghc/ghc-6.4.2/gcc-lib/ to the path too?
01:00:20 <dons> vincenz: *shrug* :) the blogosphere is full of weirdos
01:00:29 <x3m> it doesnt say .../ld is missing or anything, the program/setup just ends
01:00:30 <vincenz> dons: true
01:00:41 <newsham> ghc/cabal can usually build stuff fine without adding other items to paths.
01:00:49 <newsham> dunno if you need special access to do your hs-plugins stuff
01:00:54 <dons> nope
01:00:56 <dons> it's just cabal
01:01:05 <dons> i'm not sure, other than setting the path, why this is proving difficult
01:01:07 <newsham> yah, so Setup.lhs install should work
01:01:19 <vincenz> Anyone know a more secure blogging engine that can be installed by ftp only?
01:01:24 <dons> he's got to get HSplugins-1.0.o linked first
01:01:33 <dons> vincenz: blosxom ? :)
01:01:54 <x3m> should i try install?
01:01:54 <newsham> Installing: C:\Program Files\Haskell\plugins-1.0\ghc-6.4.2 & C:\Program Files\pl
01:01:54 <newsham> ugins-1.0 plugins-1.0...
01:01:58 <vincenz> dons: whoops... I meant wiki
01:02:08 <vincenz> dons: I have a blog :), blogspot.com
01:02:17 <newsham> x3m: i think you should give it a shot.
01:02:18 <dons> x3m, you can always try, yes.
01:02:25 <vincenz> dcoutts__: I'll put the software on my univ-website, it's faster and non-wiki-based
01:02:28 <dons> then check, $ ghc-pkg list
01:02:35 <x3m> looks like it worked
01:02:38 <dons> which should show "plugins-1.0"
01:02:40 <dcoutts__> vincenz: ok, just give me a new url
01:02:47 <newsham> newsham@lenoxp$ ls dist/build/HSplugins-1.0.o
01:02:47 <newsham> dist/build/HSplugins-1.0.o*
01:03:32 <x3m> how do i check ghc-pkg list
01:03:45 <newsham> run "ghc-pkg -list"
01:03:46 <dons> run the ghc-pkg program. is it called ghc-pkg.exe ?
01:03:52 <newsham> its in the same path
01:03:53 <goltrpoat> vincenz:  bashing how?
01:05:01 <x3m> and what should i look for in it?
01:05:09 <x3m> ah yep
01:05:14 <x3m> it shows plugins-1.0
01:05:15 <newsham> "plugins-1.0"
01:05:17 <newsham> yup
01:05:31 <dons> x3m yay!
01:05:34 <newsham> i need sleep..  g'nite
01:05:38 <dons> that's a good sign, I think
01:05:42 <dons> thanks newsham
01:05:44 <x3m> dons: how much have we done now, 1/10?
01:05:49 <dons> no that's about it
01:05:51 <x3m> ^^
01:05:58 <dons> so hopefully know you can build RunPlugs.hs
01:06:12 <dons> $ ghc --make -O RunPlugs.hs -o runplugs
01:06:25 <dons> i just hope that you did in fact manage to get HSplugins-1.0.o created
01:06:53 <x3m> should i download runplugs from somewhere
01:07:13 <dons> yes, the link I posted earlier. http://www.cse.unsw.edu.au/~dons/tmp/RunPlugs.hs
01:07:14 <lambdabot> http://tinyurl.com/zfekk
01:07:45 <dons> then, if you can build it, check that it runs: $ runplugs
01:07:46 <dons> map (+1) [1..10]
01:07:47 <dons> [2,3,4,5,6,7,8,9,10,11]
01:07:56 <dons> and then if that works, your bot should be able to eval haskell :)
01:08:06 <Bourbaki> has anyone of you access to these papers? http://www.self-programming-machines.org/
01:09:08 <x3m> Could not find module 'System.Posix.Resource':
01:09:12 <goltrpoat> i know the anthony/biggs paper is on citeseer somewhere
01:09:34 <goltrpoat> actually, most of them are, probably.
01:09:46 <Bourbaki> hm ok lets see
01:10:17 <vincenz> dons: I like your new color scheme :)
01:10:18 <goltrpoat> the reference section in "self-programming-machines I" is probably a better place to look than the paper itself
01:10:36 <x3m> Chasing modules from: dhs/RunPlugs.hs Could not find module 'System.Posix.Resource':
01:11:03 <dons> x3m, ok good. we can fix that...
01:11:16 <x3m> sounds good
01:11:18 <user317> how do i get show to work on (IO [[Integer]]), liftM?  sorry, i dont really understand monads yet
01:11:44 <Bourbaki> goltrpoat do you know a propper definition for these machines? is ther a machine that can modify itself at all? without an interpreter that is
01:12:01 <dons> x3m, here, try again with this: http://www.cse.unsw.edu.au/~dons/tmp/RunPlugs.hs
01:12:03 <lambdabot> http://tinyurl.com/zfekk
01:12:19 <dons> x3m, i've commented out the posix code that forces the program to timeout after 3 seconds
01:12:33 <x3m> dons: done
01:12:38 <dons> so the result is that it will be possible to write a nonterminating expression
01:12:49 <x3m> and that is?
01:12:51 <dons> but you can probably fix that later using some win32 specific code
01:13:06 <dons> oh, a user could write an infinite loop
01:13:11 <dons> and it will just run
01:13:24 <x3m> ooh okay, that's pretty serious though
01:13:25 <dons> but you can sort that out later
01:13:31 <dons> > last [1..]
01:13:34 <x3m> but i guess i can put in a time limit or something
01:13:35 <lambdabot> Terminated
01:13:36 <goltrpoat> bourbaki:  don't see why not.  say i write a VM, put it in a program equipped with some startup bytecode, and the facility to modify the bytecode.
01:13:37 <dons> for example, won't happen
01:13:45 <dons> yes, you need to work out how to time limit a binary on windows
01:13:56 <dons> x3m, anyway, let's see if that builds/
01:13:59 <x3m> dont haskell got timers?
01:14:00 <x3m> sure
01:14:06 <x3m> what do i do..
01:14:17 <x3m> the runplugs built
01:14:21 <dons> it did?
01:14:23 <x3m> yeah
01:14:25 <dons> ok, let's run it then
01:14:28 <Bourbaki> goltrpoat but the vm is an interpreter i think that you cant build a FSM that modifyies itself without something outside of the machine
01:14:31 <dons> $ ./runplugs
01:14:31 <dons> 1+2
01:14:31 <dons> 3
01:14:53 <goltrpoat> bourbaki:  oh right.  i thought you were saying it'd need an interpreter for the source language.
01:14:55 <dons> so just run the 'runplugs' program, and type in: 1+2
01:14:57 <vincenz> dcoutts__: http://homes.esat.kuleuven.be/~cpoucet/code/rbtree/tree.hs
01:15:00 <user317> so, why do i get a type error, "No instance for (Show (IO [[Integer]]))", why cant it just show the dumb array
01:15:00 <lambdabot> http://tinyurl.com/jp47x
01:15:25 <Bourbaki> goltrpoat nope :)
01:15:32 <x3m> runplugs: user error (LoadShared: couldn't load 'libwsock32.so' bacause addDLL: unknown error)
01:15:40 <dons> oh fun
01:15:46 <matthew-_> user317: because it's not an array at that point
01:15:46 <x3m> is it? :/
01:15:51 <vincenz> dons: I copied your colors for links )
01:16:03 <dons> I don't know how to solve that, x3m. so close...
01:16:09 <dons> short of installing mingw.
01:16:36 <matthew-_> user317: a monad is a function which takes the realworld, transforms to a new realworld and also returns a value
01:16:50 <dons> > show [[1,2,3],[4,5,6]]
01:16:52 <lambdabot>  "[[1,2,3],[4,5,6]]"
01:16:53 <x3m> if i install mingw and compile this stuff i can uninstall it after and still use this, right?
01:17:12 <matthew-_> user317: so what your program is, is an expression that ultimately just transforms the realworld
01:17:16 <goltrpoat> bourbaki:  it's an NFA, right.  these can be converted to equivalent DFAs, although the latter may be inordinately large
01:17:40 <dons> x3m, not sure. if you want to pursue this, you'll probably need to work out why libwsock32.so didn't load
01:17:43 <user317> matthew-_, hmm, this is odd, so if i do foo <- readFile (head args)) and pass that into my function the result is a normal array, but if i do, putStrLn $ show $ (liftM solutions) $ (readFile (head args)), i get an IO array
01:17:47 <dons> which might take a bit of hacking.
01:18:21 <bartw> moin
01:18:22 <dons> user317: you can't show a monadic value.
01:18:29 <Bourbaki> goltrpoat ok but try to paint an NFA that adds an edge or a node to itself :)
01:18:36 <dons> try, readFile (head argS) >>= print . solutions
01:18:48 <x3m> dons: i got no clue how to do that
01:19:06 <dons> x3m, get some sleep. we can try to chase it down tommorrow, if you want :)
01:19:15 <user317> dons, so whats the difference between junk <- readFile (head (args)) and passing that into another function
01:19:22 <dons> x3m, you've just gone further with hs-plugins on pure windows than has been done before :)
01:19:30 <dons> x3m++ -- persistence!
01:19:31 <x3m> dons: sure thing
01:19:40 <matthew-_> user317: yep. that's right
01:20:00 <skew> hi. I'm looking for a (La)TeX package for formatting typing rules. Can any of you recommend one?
01:20:14 <matthew-_> user317: foo <- func is the same as func >>= \foo -> rest
01:20:19 <dons> skew: yeah, let me find the ref.
01:20:23 <user317> what is the type of junk after <- readFile "blah"
01:20:23 <goltrpoat> bourbaki:  i guess my point is that i'm not sure how those edges or nodes would be pulled out of thin air -- if they can, then that's a whole different story.  if they can't, then they're a state in some (other) NFA, and we can join them kit and kaboodle.
01:20:25 <vincenz> dcoutts__: submitted comment, all it requires is moderation
01:20:40 <kosmikus> skew: there are thousands, but I find them all somewhat unconvincing
01:21:24 <dons> mostly people just code up their own newcommands, I find.
01:21:29 <dons> over the top of \usepackage{amsmath}
01:21:29 <dons> \usepackage{amsfonts,amssymb}
01:21:52 <Bourbaki> goltrpoat lets say that theres a specific state in the machine that will trigger it do add some edge or node in a specific place then the machine would need an interpreter right?
01:21:58 <kosmikus> dons: yes, I'm using my own commands as well
01:22:47 <matthew-_> user317: that's unanswerable
01:23:09 <matthew-_> user317: after will have the type parameter of the monad that readFile returns
01:23:11 <user317> matthew-_, does it not have a type?
01:23:26 <dons> ?undo do x <- readFile "f" ; print (solutions x)
01:23:27 <lambdabot> readFile "f" >>= \ x -> print (solutions x)
01:23:32 <matthew-_> user317: there are many types! I'm not certain what you mean by after!
01:23:37 <dons> ?redo readFile "f" >>= \ x -> print (solutions x)
01:23:38 <lambdabot> do { x <- readFile "f"; print (solutions x)}
01:23:40 <dons> :)
01:23:42 <goltrpoat> bourbaki:  can't the edge or node exist in the machine to begin with?  then you "just" modify the transition function
01:23:55 <user317> matthew-_, hmm, yea i think i see what you are saying
01:24:07 <goltrpoat> i.e. to add a node, you make a previously unreachable node reachable, to remove it, you make a previously reachable node unreachable
01:24:17 <Bourbaki> goltrpoat if that as the case the machine needs to be infinitly big and would have to contain all programs in the beginning
01:24:29 <matthew-_> user317: I'm desparately trying to find the same wiki article that I read on monads which is great. bear with me...
01:24:40 <vincenz> dons++ -- I'm really happy with the webste :)
01:24:47 <dons> vincenz: url?
01:24:51 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/code.html
01:24:54 <Bourbaki> the problem is that a machine cant modify itself which is why i guess lisp comes with an interpreter and all dynamic languages also
01:24:54 <lambdabot> Title: software, http://tinyurl.com/zoruk
01:24:59 <user317> well, the good news is that i wrote a sudoku solver with a recursive data structure :)
01:25:05 <goltrpoat> bourbaki:  that's what i meant when i said that i'm not sure how those edges or nodes would be pulled out of thin air -- something has to define the new node we're about to add, and it's going to define it based on some finite set of rules, no?
01:25:08 <user317> and it seems to be working
01:25:13 <Bourbaki> so i could also ask is if possible to write a dynamic language without an interpreter
01:27:16 <matthew-_> user317: read http://haskell.org/haskellwiki/IO_inside
01:27:16 <goltrpoat> bourbaki:  we used self-modifying code for some time for triangle rasterizers back in the mid 90s.  you'd write over instructions in the code segment in order to, say, get rid of a memory fetch when the value in question was determined to be constant for the remainder of the runtime
01:27:17 <lambdabot> Title: IO inside - HaskellWiki
01:27:17 <user317> Bourbaki, any langauge can come with an interpeter, or be compiled, or both
01:28:11 <x3m> dons: win dont have posix
01:28:20 <x3m> dons: but i know it has been ported to win though
01:28:40 <matthew-_> x3m: I thought it did, deep down, have a posix layer - all the wins built on NT anyway?
01:29:06 <dons> x3m, or at least in the win32 haskell package there might be a way of timing out processes
01:29:13 <goltrpoat> bourbaki:  so in that sense, it was a self-modifying FSM.  in a limited manner, but still.
01:29:15 <dons> (as the unix haskell package does)
01:29:19 <Bourbaki> yes but then you have an interpreter :)
01:29:26 <goltrpoat> how so?
01:29:50 <Bourbaki> well did you write it in haskell? or some other sideeffect free language?
01:30:26 <goltrpoat> no, that was C and assembly :).  like i said, it would write over specific instructions in the code segment.  i.e. replace bits of the machine code.
01:30:29 <bartw> matthew-_ : using cygwin is a better gamble for a posix layer
01:30:42 <matthew-_> bartw: yeah, I don't doubt it!
01:30:42 <Bourbaki> if you write asm code into the memory thats accessed by your program thats not side effect free is it?
01:30:53 <goltrpoat> of course not
01:31:01 <user317> matthew-_, oh, i think i get it, i basically need to pull the data out of the monad before passing it to my pure function
01:31:12 <goltrpoat> why is side effect free a requirement though
01:31:16 <matthew-_> bartw: I haven't used win for any work for about 6 years now...
01:31:20 <dcoutts__> vincenz: ta
01:31:24 <Bourbaki> well the idea is to have a propper mathematical definition and i think that its impossible to have this without an interpreter
01:31:32 <matthew-_> user317: absolutely
01:31:37 <bartw> matthew-_ : i'm not that lucky
01:31:43 <Bourbaki> goltrpoat because i want my programs to run on graphs that dont come with an interpreter
01:31:52 <skew> dons, kosmikus: I've found a few. It seems Chung-chieh Shan worked on one of them a bit I don't know much about LaTeX, so hopefully they are acceptable
01:31:54 <matthew-_> user317: and that's what the >>= or <- syntax allows you to do
01:32:37 <dons> skew, you can always grab the complete symbols-a4.pdf file from a tex archive, and write your own
01:32:42 <x3m> dons: http://en.wikipedia.org/wiki/POSIX#List_of_POSIX-compliant_operating_systems
01:32:43 <dons> lots of fun symbols to play with :)
01:32:44 <lambdabot> http://tinyurl.com/lljce
01:33:09 <dons> x3m, we really need to get a windows/haskell expert's opinion of how to do the posixy timeout stuff
01:34:56 <skew> how about http://citeseer.ist.psu.edu/251918.html
01:35:16 <skew> "Self-Modifying Finite Automata: Power and Limitations"
01:35:50 <goltrpoat> bourbaki:  you can just decorate each transition with a new copy of the FSM, possibly with new states or transitions added.  adding some sort of a restriction along the lines that loops through strongly-connected components preserve the FSM, the whole thing is finite, no matter what the path
01:37:05 <goltrpoat> i guess it's finite for a finite length path without the restriction
01:37:16 <skew> goltrpoat, Bourbaki: I think that thesis I pointed you to goes over all that sort of stuff
01:37:22 <goltrpoat> cool, thanks
01:38:45 <x3m> dons: yeah probably :/
01:38:48 <Bourbaki> i think its still worth to invest some work in extending all these things
01:39:33 <dons> x3m, there's any chance you could run the code on a linux box?
01:39:41 <dons> since we'd get it working in no time then.
01:40:11 <matthew-_> Quick question: how would you describe the following:
01:40:12 <matthew-_> (>>) :: IO a -> IO b -> IO b
01:40:12 <matthew-_> (action1 >> action2) world0 =
01:40:22 <matthew-_> would you say that it's returning a function?
01:40:33 <dons> or, perhaps scale back your goals. instead of trying to embed a haskell interpreter in your bot, on windows. perhaps write a little mini interpreter for a small language (or some other plugin?)
01:40:37 <matthew-_> or that it's doing some sort of inverse curryinng?
01:40:46 <dons> x3m, what's your view? how do you want to proceed?
01:41:11 <x3m> dons: well i dont have any linux box here atm
01:41:27 <x3m> it would be good if it could work in win
01:41:43 <dons> yeah, I agree. it seems pretty close (and it does work under mingw)
01:42:00 <dons> but i'm hesitant to force you to be the hs-plugins_on_windows guru, when you're just learning the language :)
01:42:19 <dons> I think it would be a better experience to try to add something a bit simpler to your bot first :)
01:42:38 <x3m> tsks
01:43:07 <dons> we could try again tomrrow, when newsham's back.
01:43:11 <x3m> sure
01:43:12 <dons> he might have some ideas for the linker issue
01:43:21 <dons> and you've at least got all the code built now
01:43:23 <x3m> its no hurry
01:44:02 <dons> considering this time yesterday you'd not used the language, and 24 hours later you've got an irc bot up and running, ported hs-plugins to pure windows, and learnt cabal ... :) that's pretty good
01:44:58 <x3m> import System.IO                (getContents, putStrLn)
01:44:58 <x3m> --
01:45:28 <x3m> import System.IO                (getContents, putStrLn) does the stuff inside () do anything there or is it like a comment?
01:45:40 <vincenz> x3m: it only imports those then
01:45:45 <x3m> alright
01:46:01 <dons> yep, it imports only those functions, and not everything in System.IO
01:47:05 <goltrpoat> bourbaki:  say M_k = <S_k, T_k> is a machine with states S and transitions T.  let S_1 = {s_11, s_12}.  let elements T_k be tuples, consisting of a directed edge and a machine M_{k+1}.  say for a transition T_k with the edge (s_ki, s_kj), we create a new machine M_{k+1} = <S_k \cup {s_new}, T_k \cup { ( ((s_new, s_ki), (s_kj, s_new)), M_{k+1} ) }
01:47:15 <goltrpoat> let M_1 be a machine with two states and one transition.
01:47:37 <goltrpoat> effecting the first transition and iterating gives you a triangle mesh of a graph.
01:48:31 <goltrpoat> obviously self-modifying, since we're adding nodes with every transition.  no "interpreter", unless you consider effecting a transition to be "interpretation"
01:49:20 <goltrpoat> anyway, this is probably pretty OT
01:49:29 <Bourbaki> goltrpoat ot?
01:49:37 <goltrpoat> off topic
01:49:39 <goltrpoat> or something.
01:49:57 <Bourbaki> ah hm well if it doenst fit in this chan i dont know where else :)
01:50:01 <goltrpoat> hehe true
01:50:36 <Bourbaki> im not sure if cup of a machine can be part of a machine itself then cup would habe to be part of the machine
01:51:00 <goltrpoat> \cup being set union, pardon the latexese
01:51:23 <Bourbaki> sure but that would have to be part of the machine then
01:51:24 <vincenz> `union` and it would not be OT :)
01:51:30 <goltrpoat> hah
01:51:56 <goltrpoat> bourbaki:  well, the point is that the machine itself changes
01:52:08 <goltrpoat> i mean, it has to, in some way, right.  unless we know all the possible states that might be added or deleted.
01:52:22 <Bourbaki> i thought to make the interpreter a functor that acts on a product of the diagram and a limit of the program that is the state
01:52:57 <Bourbaki> im still sceptic if a machine can modify itself really because that smells of muenchhausen hair pulling :)
01:53:03 <goltrpoat> hehe
01:53:32 <Bourbaki> but i think with the functor its not that bad at all in the end
01:53:49 <Bourbaki> and with the arrow stuff i introduced you can omit interpretation of chains of the program
01:54:13 <goltrpoat> what do you mean by limit of the program?  maximal sequence?
01:54:15 <Bourbaki> youd just need the inperpreter atm for recursions and such
01:54:28 <Bourbaki> the limit is something like the state of the program
01:54:43 <Bourbaki> ie where the tokens are in the FSM for example
01:55:56 <goltrpoat> ah ok
01:56:15 <goltrpoat> wait, is the problem just formalizing an interpreter?
01:56:32 <goltrpoat> i assumed you just didn't want interpreters anywhere near the thing
01:56:38 <Bourbaki> not really no i just wanted to know if there might be a way without the interpreter
01:56:46 <goltrpoat> -nod-
01:56:58 <Bourbaki> but if i use an inerpreter it would be a functor on the diagram of the machine
01:57:00 <vincenz> @hoogle MonadState
01:57:01 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
01:57:54 <musasabi> Would this work for implementing generic deriving:
01:58:01 <vincenz> dons: stupid question, if I have a monadstate with the state ByteString and then repeatedly generate packets until eof, is this lazy?
01:58:28 <musasabi> class Derivable t where derive :: Proxy t -> Name -> Q [Dec]
01:58:40 <musasabi> (with data Proxy t = Proxy)
01:58:41 * vincenz nminds
01:58:45 <dcoutts__> vincenz: what is the result type?
01:59:30 <vincenz> dcoutts__: Ideally I'd have ByteString -> [LogPacket], but I'd like to do this monadically (cause it's easier to code then, imagine code like)
01:59:36 <vincenz>     30 -> return VectorConstruct  `ap` next32 `ap` next32 `ap` next32 `ap` next32
01:59:59 <dcoutts__> vincenz: if you're using a writer monad then, yes porbably it is lazy
02:00:35 <wilx> @type ap
02:00:36 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
02:00:44 <dons> vincenz, does next32 read from the bytestring, now?
02:00:44 <vincenz> actually write now I have getPacket :: m LogPacket (I used to use Handle and IO)
02:00:48 <vincenz> dons: that's the plan
02:00:52 <dons> cool
02:01:11 <vincenz> just want to make sure that doing this monadically won't force 1.4Gb into memory
02:01:32 <matthew-_> ram's cheap!
02:01:44 <vincenz> sure, and so is caching
02:01:51 <matthew-_> unless you're using a new Mac Pro Tower...
02:01:54 <dons> should be fine. there's no magic strictness in the state monad
02:02:05 <goltrpoat> "the arrow stuff i introduced" <- did i miss a joke there? :)
02:03:23 <Bourbaki> goltrpoat into the graph programming thingy
02:03:51 <goltrpoat> oh, i thought for a minute you were talking about the bourbaki group and the implication symbol
02:04:05 <Bourbaki> :)
02:04:13 <Bourbaki> who knows ;)
02:07:06 <vincenz> > let f (a:b:c:d:[]) = d in f [1..4]
02:07:08 <lambdabot>  4
02:08:10 <vincenz> @where paste
02:08:10 <lambdabot> http://paste.lisp.org/new/haskell
02:08:29 <lisppaste2> vincenz pasted "getWord32 on MonadState with ByteStrings" at http://paste.lisp.org/display/26698
02:10:19 <vincenz> @hoogle ($1)
02:10:20 <lambdabot> Hoogle Error: Parse Error: Unexpected character '$1)'
02:10:22 <vincenz> @hoogle ($!)
02:10:23 <lambdabot> Did you mean: ($!)
02:10:23 <lambdabot> Prelude.undefined :: a
02:10:23 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
02:10:31 <vincenz> @type ($!)
02:10:31 <dons> ?hoogle $!
02:10:33 <lambdabot> forall b a. (a -> b) -> a -> b
02:10:33 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:10:58 <vincenz> dons: basically I'd like packets to be returned strictly in the list
02:11:00 <vincenz>     30 -> return VectorConstruct  `ap` next32 `ap` next32 `ap` next32 `ap` next32
02:11:28 <dblhelix> @hoogle [a] -> a
02:11:29 <lambdabot> Prelude.head :: [a] -> a
02:11:29 <lambdabot> Prelude.last :: [a] -> a
02:11:29 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
02:16:35 <vincenz> @hoogle mfix
02:16:36 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
02:19:32 <goltrpoat> lemma:  three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
02:23:19 <dons> ?remember goltrpoat Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
02:23:32 <vincenz> dons: nextPacket :: (MonadState LBS.ByteString m) => m LogPacket
02:23:43 <vincenz> it doesn't like types ...
02:24:16 <dons> ?hoogle MonadState
02:24:16 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
02:24:52 <dons> can't tell from that code fragment, despite years of training as a type inference human-o-bot :)
02:25:16 <dons> or, if I apply @pl to the above sentence: more info please.
02:25:20 <vincenz> bsaically it doesn't like types (non tyvars) inside a constraint
02:26:27 <dons> can you just fix the monad?
02:26:36 <dons> i.e. newtype S = MonadState .... my monad ...
02:26:42 <dons> nextPacked :: S LogPacked
02:27:12 <dons> rather than trying to make nextPacked polymorphic over the underlying monad?
02:27:30 <dons> but not polymorphic in the state type (?)
02:27:31 <vincenz> true
02:28:12 <vincenz> or suffer -fglasgow-exts
02:28:55 <dcoutts__> dons: so when are we going to write this binary stuff? :-)
02:29:11 <dcoutts__> the basics look easy
02:29:19 <dcoutts__> (fameous last words)
02:29:42 <dons> i think it is easy. how many binary libs have be written in the last year? 4?
02:29:49 <dcoutts__> at least
02:30:19 <dons> so we just have to do it right, once and for all :)
02:30:19 <dcoutts__> the trickier stuff is things like string pools, endianness, lazy deserialisation
02:30:23 <dons> yeah
02:30:28 <dcoutts__> yep :-)
02:30:37 <dcoutts__> all this layering business
02:30:41 <dons> yes.
02:31:12 <dcoutts__> needs to be possible to do without it being too hard, but also in a way that doesn't impact users who don't need it
02:31:33 <dcoutts__> oh and bit level stuff is another layer
02:31:56 <dcoutts__> the basics is just byte level things, serialising into a lazy bytestring effeciently
02:32:07 <dons> yes, agreed. the other things I can see how to do, the endianess though, i don't have a lightweight solution there yet
02:32:10 <dcoutts__> such that the bytestring really is generated lazily
02:32:23 <dcoutts__> so it can be written out as it's generated
02:32:30 <dons> i've seen class constraints to control endianess
02:32:30 <dcoutts__> or compressed! and written out
02:32:51 <dons> but then again, most binary libs ignore endianess, (unlikes, say, Storable (?))
02:33:04 <dcoutts__> storable is always native endian
02:33:14 <dcoutts__> which is ok for its purpose
02:33:18 <dons> yeah.
02:33:33 <dcoutts__> serialisation might want to share data across platforms
02:33:45 <dons> hmm. yes.
02:34:14 <dcoutts__> then there are two major use cases, for serialising haskell data and the other use case is for genraiting/parsing specific binary formats
02:34:15 <dons> but i'd not want to burdne the programmer with specifying endian issues when all they want is a fast Read/Show
02:34:20 <dcoutts__> right
02:34:21 <dons> right
02:34:36 <musasabi> I think explicit endianess support is good.
02:35:00 <musasabi> As it is not too expensive most of the time, and not being to serialize over network is bad.
02:35:05 <dcoutts__> so at the minimum you can just have get/putWord(LE|GE|NE)
02:35:13 <dons> yes, and yes.
02:35:23 <dons> I agree it has to be faced and a solution reached
02:35:36 <dons> or we just end up with yet another not-quite-done binary lib
02:35:41 <dons> so, should we look at say, erlang?
02:35:46 <dcoutts__> for haskell serialisation de-serialisation it doesn't matter much
02:35:58 <dcoutts__> for the pre-defined formats it's important
02:35:59 <dons> there must be some good interfaces around for this kind of stuff we can think about
02:36:09 <vincenz> \o/, getting performance more at par with ocaml (well about a factor 1.5 - 2 slower, depending on user or real time)
02:36:17 <dcoutts__> but for those you probably are not going to be using the standard class instances
02:36:30 <dcoutts__> dons: yep, there's erlang
02:36:41 <musasabi> The erlang bit syntax is very very nice.
02:37:00 <musasabi> -pgmF based wrapper that translated bit syntax to Haskell would be nice.
02:37:23 <dcoutts__> dons: so perhaps we want two layers: one is the explicit low level primitives with endianness, and some combinators for doing binary format parsing/generating
02:37:38 <dcoutts__> then layer the class system on top for the BinaryRead/Show use case
02:37:48 <dcoutts__> and it might not bother with endianness stuff
02:37:54 <musasabi> another things is that there is need to add constraints to the parsing specifications.
02:38:26 <dcoutts__> musasabi: what do you mean ?
02:38:32 * dcoutts__ -> more coffee
02:38:33 <musasabi> e.g. to have a 32 bit length field but refuse to acccept anything larger than some N (otherwise too easy to DOS)
02:40:50 <musasabi> a naive solution would be like, 1) read length field, 2) create bytestring of the length, 3) read data into the bytestring. Now simply sending 4gb as the length field would be enough to crash the app without an easy way to add limitations.
02:42:18 <dons> musasabi: have you looked at the new BitSyntax library?
02:42:32 <dons> the guys who wrote that have done a bit with networking in haskell, using lazy bytestrings too
02:42:42 <dons> and plenty of erlang, i suspect
02:42:43 <musasabi> yes. It had some limitations but looked quite nice.
02:42:49 <dcoutts__> I had a breif look
02:42:57 <dons> good area to move into, i think
02:42:59 <dcoutts__> I'm sure there's stuff to learn from it
02:43:13 * musasabi looks for the link
02:43:32 <musasabi> stupid browser windows with too many tabs.
02:43:36 <dons>   http://article.gmane.org/gmane.comp.lang.haskell.general/14287/
02:43:40 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/pav5g
02:43:51 <skew> the syntax could be improved - things like [x:12,y,z:8] parse as a pattern, or the TH bit could just take a string argument
02:44:07 <dcoutts__> I'm not so sure about the TH either
02:44:13 * dons has a tool for searching gmane, 
02:44:13 <dons> $ gmane haskell '' 'BitSyntax'
02:44:14 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/14287/
02:44:15 <dons> :)
02:44:16 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/pav5g
02:44:37 <dons> so I need never visit the damn site again
02:44:38 <musasabi> hmm. Maybe I should write to the ML rather than here.
02:44:48 <dcoutts__> dons: where's the lambdabot plugin then? ;-)
02:44:53 <dons> oh hmm!
02:45:02 <dcoutts__> @gmane BitSyntax
02:45:02 <lambdabot> Unknown command, try @list
02:45:08 <dons> yep.
02:45:23 <dons> it takes 3 (optional) args, the mailing list, the author, and keywords
02:45:29 <dons> and returns the most recent hit
02:45:35 <skew> I don't know how to get splices to be parsed with extra bindings - something like [| a |] gives errors if a is not already bound
02:45:36 <dons> seems to work nicely, i'll plugin-ify it
02:46:29 <skew> I've got my typing rules written down, but arranged pretty badly: http://www.ugcs.caltech.edu/~brandon/rules.pdf
02:46:37 <lambdabot> http://tinyurl.com/j7e96
02:46:48 <dons> skew, I find it helps to find a paper with good type setting to steal from
02:46:49 <dons> perhaps
02:46:51 <dcoutts__> musasabi: do you want to limit the individual parsing ops for security, or just limit the overall length ?
02:46:54 <dons> ?where plbook
02:46:54 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
02:47:05 <dons> or the recent associated types/system Fc paper (lots of typing judgements there..)
02:47:27 <dcoutts__> musasabi: eg it'd be easy to just 'parse (take maxAllowableLength input)'
02:47:30 <musasabi> dcoutts__: I am writing a reply to haskell-cafe on that.
02:47:32 <Dread[]> Morning all
02:47:45 <musasabi> dcoutts__: that does not help. See the reply in a few minutes.
02:47:55 <dcoutts__> ok
02:47:56 <skew> dons: where do you find the source? I like the layout in those papers
02:48:09 <Dread[]> I'm having a problem (I'm a haskell newbie). Let's say I have: Swedish (c:cs) | kons c = c:' ':swedish cs
02:48:31 <Dread[]> And then later on define kons as booleans (kons 'b' = True) and so on
02:48:59 <Dread[]> The rows above ADD a ' ' if kons is true, but I want it to DELETE from the list if true?
02:49:03 <dons> skew, you could ask ChilliX for a copy of the macros he uses
02:49:12 <dons> actually, I might even have the macros somewhere
02:49:58 <Lemmih> Dread[]: | kons c = swedish cs?
02:50:03 <dcoutts__> Dread[]: you want to omit the c from the result if kons c ?
02:50:12 <ru> l
02:50:16 <dcoutts__> if so then yes, what Lemmih says
02:50:25 <Dread[]> no, not really. See, the imput might be "ror" and I want to omit or from that
02:50:33 <Dread[]> IF r is true (which it is in this case)
02:51:14 <dcoutts__> Dread[]: so it's not a simple test on each character then ?
02:51:18 <Dread[]> no.
02:51:28 <dcoutts__> you want to delete several chars depending on a test
02:51:46 <Lemmih> Dread[]: You want to remove all the characters between the r's?
02:51:56 <dcoutts__> so it depends on exactly how you recognise the bit you want to delete
02:51:57 <Dread[]> I've constructed a program that transforms "hello" to "hohelollolo" and now I want to go back from "hohelollolo" to "hello"
02:52:21 <Lemmih> Dread[]: | kons c = swedish (takeWhile (not . kons) cs)
02:52:40 <Lemmih> Err, dropWhile
02:53:39 <musasabi> sent a mail.
02:53:42 <Dread[]> "ror" returned as "r or "
02:55:09 <Dread[]> hmm
02:56:24 <Dread[]> anyone else?
02:56:31 <Lemmih> Dread[]: I have no idea what you're trying to do, I'm afraid.
02:57:10 <dcoutts__> musasabi: so why do we need a per-item limit and not just an overall limit ?
02:58:10 <Dread[]> Lemmih: hang on 2 sec and I'll try to explain
02:58:57 <dcoutts__> musasabi: I'm not claiming we don't, I'm just wondering if there are any specific compelling examples
03:08:46 <araujo> morning!
03:11:34 <musasabi> dcoutts__: see the problem with length prefix fields.
03:11:55 <musasabi> dcoutts__: unless the overall limit applies to the size of output and not the size of input.
03:12:44 <dcoutts__> musasabi: I don't follow. You'd never make a length prefixed field that was bigger than the input. And one can limit the input size.
03:13:15 <dcoutts__> so it might say 4Gb, but if there's only 1Gb of actual input then it's malformed.
03:13:33 <musasabi> dcoutts__: the storage for a length prefixed field is allocated prior to that part of input being read.
03:14:01 <musasabi> dcoutts__: and if the attacker sends 100 requests concurrently and the apps wants to allocate 400gb of memory...
03:14:59 <musasabi> 1) send the large length field, 2) send 1 byte/second, 3) random thread gets an allocation error
03:16:12 <dcoutts__> ok, I was assuming not.
03:16:12 <dcoutts__> musasabi: I was assuming we're using a lazy bytestring
03:16:47 <musasabi> a lazy bytestring is a solution, but forcing everything to use a lazy bytestring for fields that *should* be short is not nice.
03:18:42 <musasabi> BitSyntax seems to use non-lazy ByteString.
03:19:53 <aleator> How do I get ghc to make 32bit binaries on 64bit linux?
03:22:44 <ibid> which arch?
03:23:27 <dcoutts__> aleator: you can't, at least no easily.
03:23:49 <dcoutts__> aleator: you can start with a 32bit ghc of course
03:24:01 <aleator> ibid: ya know. The deps. not so quite new calculation server..
03:24:08 <dcoutts__> but the version built for 64bit will generate 64bit binaries
03:24:43 <dcoutts__> musasabi: yes, for general short length-prefixed fields where the memory gets preallocated it's a problem.
03:24:46 <aleator> dcoutts__: Ok. Suspected as much. Is there possibility of having it even link 32 bit foreign libraries instead of 64?
03:24:54 <dcoutts__> no
03:25:02 <dcoutts__> since you can't mix abis like that
03:25:36 <aleator> Hmmm.. So I'm back to compiling on one machine and running on the other :/
03:26:01 <aleator> Or installing ghc again.. Which is probably more work :)
03:26:13 <dcoutts__> musasabi: if they are parsing from a strict bytestring then there's also no problem since every length-prefixed field has an upper bound of the total input length which you already know
03:26:53 <dcoutts__> aleator: the normal solution is to use a 32bit chroot and use your 32bit apps there
03:32:43 <musasabi> dcoutts__: of course I think it should be really parsing a lazy bytestring that comes unsafeInterleaveIO:ed from a socket.
03:32:54 <musasabi> thus no upper bound there.
03:32:57 <dcoutts__> musasabi: indeed
03:33:51 <dcoutts__> musasabi: but in that case, even a per item upper bound isn't enough I think
03:34:25 <dcoutts__> perhaps it can read the length, then read the data, and if there is enough, then allocate space & copy it.
03:34:31 <dcoutts__> so it never allocates upfront
03:34:46 <dcoutts__> so it's always limited by the input stream length
03:35:19 <ibid> dcoutts__: that's not normal, that's the interim solution while we wait for multiarch :)
03:35:48 <dcoutts__> ibid: pfft, multiarch.
03:36:10 * dcoutts__ runs gentoo amd64-nomultiarch profile
03:36:46 * ibid runs debian sid amd64 (pure64)
03:37:47 <dcoutts__> ibid: so you and I don't suffer from flash or OOo then :-)
03:38:23 <musasabi> dcoutts__: why is adding a check not enough?
03:38:25 <ibid> dcoutts__: i do find the lack of OOo a bit problematic, though. no other system handles od* well
03:38:45 <ibid> dcoutts__: and youtube requires flash :/
03:39:00 <dcoutts__> musasabi: well suppose I have a sucession of fields with 4GB length prefix
03:39:16 <dcoutts__> musasabi: and an arbitrary cuttoff is always tricky to get right
03:39:52 <dcoutts__> if we can limit it to the overall stream length, then that provides some more automatic limiting doesn't it ?
03:39:58 <musasabi> dcoutts__: an arbitrary cutoff seems like the only working thing. Of course if one is sure to consume things in a lazy fashion the cutoff can be omitted...
03:40:39 <musasabi> dcoutts__: overall stream length may very well be over 4gb with the stream running for a few weeks.
03:41:50 <dcoutts__> musasabi: but it eliminates the simple DOS right ?
03:41:59 <dcoutts__> since the attacker has to do as much work as you
03:42:15 <dcoutts__> it's not like sending 4 bytes and making the victim alloc 4GB
03:42:20 <dcoutts__> the atacker has to actually send 4Gb
03:42:34 <musasabi> yes, but copying automatically does not seem like a good thing, if it can be avoided.
03:43:33 <dcoutts__> yeah, I guess so
03:44:18 <dcoutts__> checking the input is sane without doing too much work is hard :-(
04:15:22 <Bourbaki> is there anything in the haskell comunity that relates does something like algebraic topology on programs?
04:18:34 <goltrpoat> has anyone read "systematic search for lambda expressions" by katayama?  pretty insane
04:19:02 <Bourbaki> goltrpoat nope whats it about?
04:19:06 <goltrpoat> wonder if it can be improved with real search techniques
04:19:12 <dons> goltrpoat: url?
04:19:20 <goltrpoat> sec, lemme see if i can find the url
04:19:23 <dons> sounds a bit @djinn like?
04:19:41 <goltrpoat> oh i guess i came across it on LtU
04:19:46 <goltrpoat> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/14num.pdf
04:19:49 <lambdabot> http://tinyurl.com/n8cpj
04:21:04 <goltrpoat> it's djinn-like, but more concrete in the sense that you say something along the lines of \f -> f "string" == "gnirts" and it comes up with a string reversal
04:21:55 <goltrpoat> bourbaki:  just curious, is there a non-trivial topology on programs or something?
04:22:17 <goltrpoat> that's like.. the second time someone's mentioned that in the past two days
04:22:27 <Bourbaki> goltrpoat well if you are interested i can send you 4 small files with my idea
04:22:35 <goltrpoat> sure
04:22:38 <Bourbaki> addy?
04:22:43 <goltrpoat> vlad@pyramindlabs.com
04:23:20 * defcon8 wonders how many bots just saved that email
04:23:27 <Bourbaki> mails out
04:24:30 <Bourbaki> i think that the topoly of programs is quite different
04:24:44 <Bourbaki> and what i try to gain is that you can classify programs on their topology
04:24:54 <goltrpoat> k, lost me at "CW simplex"
04:25:06 <Bourbaki> hm thats not that hard though
04:25:29 <Bourbaki> its just that you can construct programs of single functions/arrows/edges
04:25:52 <Bourbaki> and decompose then as well and thus establish a quotent space on them
04:26:12 <goltrpoat> oh so it's basically a single arrow is a simplex
04:26:15 <goltrpoat> -it's
04:26:22 <Bourbaki> yes in this notion
04:26:26 <goltrpoat> k
04:26:35 <Bourbaki> and bigger programs have the same property
04:26:45 <Bourbaki> so you can if X and Y are programs to a glue
04:26:49 <Bourbaki> X + Y / ~
04:27:14 <Bourbaki> this is a topological operation on the programs which fixes a shortcoming in automaton theory imho
04:28:35 * JKnecht is ignorant of how topology could apply to categorical constructs; the other way obviously though.
04:30:08 <goltrpoat> i guess my first question still stands though.. in order to talk about X/~ we first need to define a topology on X, no?
04:30:26 <goltrpoat> or am i missing something
04:30:48 <Bourbaki> goltrpoat no you are right its the usual graph topology
04:30:48 <Cale> You could topologise X/~ separately, I suppose.
04:30:56 <goltrpoat> oh duh.  ok
04:32:32 <Bourbaki> X / A where A is a subset of X is the quotioent space i was talking aoubt
04:32:50 <Bourbaki> this would compile A useing arrows
04:33:00 <Bourbaki> to a single edge that is
04:33:31 <Bourbaki> and if the topology of X has cycles then you cant do that though without some tricks i think
04:34:07 <Bourbaki> any non cyclic graph program i can build there is compilable to a single arrow
04:34:27 <Bourbaki> thus you can again plug it in as a simple shape of these CW topologies
04:34:56 <Bourbaki> and you also can expand it again if you keep track of the folding thus you have a week coalgebra for this as well
04:35:45 <goltrpoat> about halfway through the log.. it's still breaking my head a bit, starting to click though i think
04:35:56 <Bourbaki> :)
04:36:17 <Bourbaki> one cool think is that you can not only concaternate these machines but you can glue them into each other
04:37:12 <Bourbaki> i think that maybe there is something going on there with homologies though i dont know where to i could apply them here
04:37:47 <Bourbaki> one thingy would be to identify simple foldable programs (non cyclic) and cyclic ones that have a recursion or loop
04:40:53 <goltrpoat> oddly enough, the diagram made me think of the Lava project, and then "<bourbaki> ok make some parts of the program look like black boxes" is making me think of EWB.
04:41:32 <Bourbaki> ewb :)?
04:41:37 <goltrpoat> electronics workbench
04:41:45 <Bourbaki> the thing is i want you to be able to zoom in and out of certain things propperly
04:41:59 <Bourbaki> if you want to abstract of a certain thing in the program you apply the quotient space
04:42:07 <goltrpoat> circuit simulation and design are inherently functional things
04:42:13 <Bourbaki> if you need to be precise on a thingy again you restore it with the coalgebra
04:44:27 <defcon8> what is true and what is false in haskell?
04:44:35 <defcon8> nvm
04:44:51 <sieni> > False == True
04:44:53 <lambdabot>  False
04:45:10 <defcon8> how do you do the and function in haskell?
04:45:18 <mauke> &&
04:45:31 <mauke> or and, if you have a list of values
04:46:01 <defcon8> hmm
04:46:09 <defcon8> why can't it take a tuple of values like normal?
04:46:15 <mauke> huh?
04:46:21 <mauke> what do you mean by "normal"?
04:46:43 <defcon8> f(x,y)
04:46:55 <mauke> that's not normal
04:46:56 <defcon8> isn't that a tuple? the (x,y)
04:47:11 <bortzmeyer> (x,y) is a tuple, yes
04:47:16 <Bourbaki> goltrpoat do you like the idea so far?
04:47:19 <mauke> yeah, but no haskell function takes a tuple
04:47:56 <gour> fst,snd ?
04:47:57 <defcon8> oh yeah
04:47:58 <defcon8> sorry
04:48:16 <mauke> gour: yeah, ok
04:48:24 <goltrpoat> bourbaki:  still wrapping my head around it.  it seems like a priori a powerful thing, but i'm not fully sure what falls out yet
04:48:36 <defcon8> why isn't it and (x, x, x) ?
04:48:54 <mauke> defcon8: because a three-argument and isn't very useful
04:49:09 <defcon8> why not?
04:49:11 <mauke> you either want two arguments or n arguments
04:49:23 <defcon8> oh I understand
04:49:30 * defcon8 is thinking in terms of scheme
04:49:46 <mauke> > and [True, False, True]
04:49:47 <lambdabot>  False
04:51:28 <defcon8> is there a list slicing function?
04:51:44 <dons> > drop 5 [1..10]
04:51:46 <lambdabot>  [6,7,8,9,10]
04:51:48 <dons> > take 5 [1..10]
04:51:49 <lambdabot>  [1,2,3,4,5]
04:51:54 <dons> > splitAt 5 [1..10]
04:51:56 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
04:51:58 <bartw> data Bool = True | False | NoSuchFile
04:52:18 <defcon8> okay thanks
04:52:21 <dons> NoSuchFile :: Bool ?! :)
04:52:30 <mauke> you mean FileNotFound
04:52:40 <defcon8> is there an insert function?
04:52:46 <dons> ?type insert
04:52:47 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
04:52:58 <bartw> mauke: ah right :)
04:53:00 <dons> > insert 9 [1..10]
04:53:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,9,10]
04:53:25 <bortzmeyer> defcon8: you should really try http://www.haskell.org/hoogle/ and http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
04:53:27 <lambdabot> Title: Hoogle
04:53:28 <defcon8> I want to insert an item at a certain index
04:53:51 <defcon8> bortzmeyer, I couldn't figure the name it'd be
04:54:08 <bortzmeyer> defcon8: that's the point of Hoogle. You can give it the signature, not the name
04:54:09 <Igloo> defcon8: You know that'll be a linear time operation?
04:54:13 <mauke> insertAt n x l = take n l ++ [x] ++ drop n l
04:54:18 <dons> > let ins n x xs = let (a,b) = splitAt n xs in a ++ [x] ++ b in ins 3 'X' "haskell"
04:54:19 <defcon8> Igloo, pardon me?
04:54:19 <lambdabot>  "hasXkell"
04:54:49 <mauke> @. hoogle type \n x l -> take n l ++ [x] ++ drop n l
04:54:51 <lambdabot> Did you mean: Forall A. Int -> a -> [a] -> [a]
04:54:54 <Igloo> defcon8: Inserting in the middle of a list takes time proportional to where you want to insert
04:54:59 <dons> mauke: ah close.
04:55:11 <dons> we'd need hoogle to ignore 'foralls'
04:55:11 <Igloo> defcon8: You sound like you're using an algorithm that won't work well with Haskell lists
04:55:12 <dons> ndm!!
04:55:18 <Bourbaki> can i post an idea to the haskell wiki and still release a paper on that idea later on?
04:55:27 <defcon8> :(
04:55:31 <dons> Bourbaki: sure.
04:55:33 <lohmi123> askfornumbers numlist = do
04:55:33 <lohmi123>   hSetBuffering stdin LineBuffering
04:55:33 <lohmi123>   putStrLn "enter number: (x for exit)"
04:55:33 <lohmi123>   word <- getLine
04:55:33 <lohmi123>   let int num = read word
04:55:33 <lohmi123>   return (numlist:num)
04:55:38 <defcon8> I'll just write my own insert function
04:55:44 <Bourbaki> can i also upload files to the wiki?
04:55:50 <dons> defcon8, see above for 2 versions..
04:55:55 <goltrpoat> just so you know, i'm most likely going to have nightmares involving the simplicial homology of a recursive program tonight.
04:55:58 <lohmi123> ups sorry
04:55:58 <Bourbaki> i have never used anything like that
04:56:27 <Bourbaki> goltrpoat hehe :) i know what you mean so had i and it gets even funnier with self referingness of the programs :)
04:56:54 <defcon8> dons, sorry?
04:57:05 <lohmi123> where do you upload code pieces for others to look at ?
04:57:12 <dons> ?paste
04:57:12 <lambdabot> http://paste.lisp.org/new/haskell
04:57:39 <dons> defcon8: there's 2 versions of insertAt for lists above, one by me and one by mauke.
04:58:15 <defcon8> dons, sorry. can't see
04:58:20 <lisppaste2> lohmi123 pasted "problem with IO" at http://paste.lisp.org/display/26704
04:58:21 <dons> and Igloo expressed concern that lots of inserts at particularly indicies isn't terribly efficient (i.e. O(n-i))
04:58:32 <dons> ins n x xs = let (a,b) = splitAt n xs in a ++ [x] ++ b
04:58:41 <dons> or insertAt n x l = take n l ++ [x] ++ drop n l
04:58:57 <Bourbaki> so where would be the propper place for the thingy on the wiki?
04:59:12 <defcon8> is x the first of the list?
04:59:18 <lohmi123> it says: num is not in scope.
04:59:18 <defcon8> does it automatically make x the first?
04:59:29 <defcon8> or is x the item and xs the list?
04:59:31 <dons> defcon8: no, 'x' is the element you're trying to insert
04:59:34 <dons> yes
04:59:36 <defcon8> ok
04:59:54 <mauke> lohmi123: 'let int num' is wrong
04:59:54 <dons> > let insertAt n x l = take n l ++ [x] ++ drop n l in insertAt 2 '#' "foobar"
04:59:56 <lambdabot>  "fo#obar"
05:00:10 <defcon8> is splitAt a std function?
05:00:17 <dons> ?hoogle splitAt
05:00:18 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
05:00:18 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
05:00:18 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
05:00:20 <dons> quite so.
05:00:33 <defcon8> okay thanks
05:03:12 <defcon8> how does the let (a,b) work?
05:03:15 <defcon8> is it pattern matching?
05:03:30 <dons> ?type splitAt -- returns a tuple
05:03:31 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:03:34 <defcon8> yes
05:03:35 <x3m> dons: runplugs doesnt look so big, would it be hard to write a replacement for it?
05:03:37 <dons> and then we bind the result to a and b
05:03:44 <defcon8> so it assigns to a and b, I guess
05:03:58 <dons> x3m, the key is that it uses dynamic linking. you could write an alternative that calls hugs or ghci perhaps
05:04:10 <dons> but you'd have to be very careful with what modules are in scope
05:04:18 <mauke> defcon8: yeah, it's a destructuring binding
05:04:30 <defcon8> how come (a,b) = splitAt 3 [3,6,23,2,6,2,6,8] doesn't work?
05:04:35 <x3m> no i mean, the errors do you think that is from hs-plugins or runplugs
05:04:45 <x3m> cause just the runplugs code aint that many lines
05:04:46 <dons> oh, hs-plugins
05:04:50 <x3m> ooh :/
05:04:56 <mauke> > let (a,b) = splitAt 3 [3,6,23,2,6,2,6,8] in [a,b]
05:04:58 <lambdabot>  [[3,6,23],[2,6,2,6,8]]
05:05:02 <dons> it's trying to pull in some winsock.so right? trying to dynamically load it
05:05:04 <dons> and its not found
05:05:09 <defcon8> ohj
05:05:13 <defcon8> because I'm doing this on ghci
05:05:29 <defcon8> > let (a,b,c) = splitAt 3 [3,6,23,2,6,2,6,8] in [a,b]
05:05:29 <lambdabot>  Couldn't match `(a, b, c)' against `([a1], [a1])'
05:05:32 <defcon8> nice
05:05:59 <goltrpoat> defcon:  type let (a,b) = splitAt 3 [3,6,23,2,6,2,6,8] in ghci
05:06:05 <goltrpoat> then look at a and b
05:06:10 <defcon8> is ++ the same as : ?
05:06:17 <defcon8> no
05:06:18 <dons> ?type (++) -- no
05:06:18 <defcon8> nvm
05:06:19 <lambdabot> forall a. [a] -> [a] -> [a]
05:06:21 <dons> ?type (:)
05:06:22 <lambdabot> forall a. a -> [a] -> [a]
05:06:27 <defcon8> ++ is append and : is cons?
05:06:31 <dons> yes
05:07:14 <x3m> dons: could mingw fix it?
05:07:22 <dons> I reckon so, yes.
05:07:28 <dons> since hs-plugins definitely works with mingw
05:07:50 <dons> you really want an embedded haskell interpreter in your bot?
05:07:52 <x3m> and do you need cygwin to use mingw?
05:07:59 <dons> I don't think so, no.
05:08:11 <x3m> i could think to try mingw
05:08:30 <x3m> yeah that would be pretty awesome
05:08:35 <x3m> but
05:09:05 <bartw> why the cygwin fear ?
05:09:39 <dons> x3m, personally I think you should just install a unix, if you're going to hack ;)
05:10:12 <x3m> i got gentoo on a harddrive but i dont really line linux.. that much
05:10:17 <bartw> find an old p2 or something and put debian on it, you'll be happy to have done it
05:10:25 <ValarQ> bartw: because it requires microsoft windows
05:10:32 <dons> ValarQ: heh.
05:10:56 <bartw> ValarQ: using cygwin can also teach you to keep to posix and not use linux specific stuff
05:11:11 <dons> using *bsd is also good for that ;)
05:11:27 <ValarQ> bartw: doesn't cygwin use GNU?
05:11:59 <bartw> ValarQ: parts of it are gnutools simply compiled under cygwin
05:12:23 <bartw> ValarQ: the licensing of cygwin itself can be weird at times
05:12:50 <ValarQ> bartw: i guess GNU would be a bigger problem than linux if you want to keep to the POSIX standard
05:13:27 <lisppaste2> lohmi123 pasted "problem with IO" at http://paste.lisp.org/display/26706
05:13:28 <bartw> ValarQ: i don't think i understand you, gnu is just an organisation not a platform
05:13:38 <ValarQ> very few of my programs depend on kernelcode or homemade devicedrivers
05:13:45 <ValarQ> bartw: GNU is a platform
05:13:58 <ValarQ> bartw: i run GNU
05:14:18 <defcon8> isn't it an operating system?
05:14:23 <bartw> thats hurd
05:14:27 <ValarQ> defcon8: yes, that is correct
05:14:37 <ValarQ> bartw: no, the operating system is called GNU
05:15:31 <mauke> lohmi123: get rid of numlist
05:15:36 <Philippa> hurd is the kernel
05:15:51 <Philippa> the GNU project involves building the GNU platform...
05:15:53 <ValarQ> or rather, hurd is a kernel
05:16:09 <Philippa> because emacs wasn't a good enough OS after all
05:16:10 <bartw> gnu/linux is a namegrab in my opinion but i don't want to start a flamewar here
05:16:12 <ValarQ> GNU runs very well on linux :)
05:16:26 <Philippa> bartw: most of the tools involved in a linux distribution are GNU tools
05:16:30 <dons> ?remember Philippa because emacs wasn't a good enough OS after all
05:16:33 <lohmi123> it says: possibly wrong indentation. i dont see anything. what about numlist as parameter ?
05:16:34 <Philippa> linux is just the kernel
05:16:55 <bartw> Philippa : just because its gpl'ed doesn't make it a gnu tool i hope
05:17:20 <Philippa> so GCC isn't relevant? Or the GNU binary tools?
05:17:28 <bartw> ofcourse it is
05:17:38 <pejo> bartw, pick your closest gnu mirror, step into /pub/gnu and list the stuff there.
05:18:30 <ValarQ> bartw: but the thing is that the API which you were afraid got confused with the POSIX API is found in the GNU standard C library
05:18:45 <lohmi123> hmm youre probably right, i dont need numlist, mauke.
05:19:11 <ValarQ> bartw: which is what cygwin is based on, so even if your terminology is a bit confused, cygwin still got the very same problem
05:19:16 <bartw> ValarQ : ah im ignorant apparently
05:19:57 <ValarQ> bartw: i'll just keep bashing on you then ;P
05:20:04 <bartw> i guess i based my ideas about gnu on linux centric opinions
05:21:07 <goltrpoat> bedtime.  adios
05:21:29 <Philippa> much GNU software predates linux
05:22:13 <vegai> but aren't they mostly rewrites of even older software?
05:22:26 <Philippa> much of it, yes
05:22:33 <Philippa> but they were ground-up rewrites
05:22:51 <lisppaste2> lohmi123 pasted "problem with IO" at http://paste.lisp.org/display/26707
05:22:54 <vegai> that's important for juridical reasons, not technical
05:22:59 <lisppaste2> defcon8 pasted "problem?" at http://paste.lisp.org/display/26708
05:23:12 <defcon8> says there is a problem with = at 5:11
05:23:23 <Philippa> they also often contain their own changes to the older software
05:23:37 <Philippa> GNU's Not Unix - that goes both ways
05:23:55 <Bourbaki5485> :)
05:24:14 * ValarQ keeps forgetting that gnu isn't unix :o)
05:24:36 <defcon8> anyone?
05:24:38 <mauke> lohmi123: what's the error?
05:24:40 <lohmi123> i removed the numlist var. now it says: ambiguous type variable in Read a. 14:15
05:24:55 <vegai> defcon8: what are you trying to do there? you're defining a function inside a do?
05:25:16 <defcon8> should I not use do?
05:25:35 <defcon8> still doesn't work
05:25:39 <mauke> lohmi123: ah, yeah. the easiest solution is probably to give askfornumbers an explicit type
05:25:41 <bartw> guess i should switch to bsd
05:25:47 <vegai> I think you want to move your function definitions outside of main
05:25:51 <dons> there's no reason for those functions to be defined in a monad, defcon8. just make them top level functions
05:26:12 <defcon8> do I have to define main at all?
05:26:15 <pejo> bartw, you will still be using gcc, and a bunch of other gnu things.
05:26:31 <vegai> defcon8: no, but then of course, you can use the model only through the interpreter
05:26:37 <defcon8> yeah
05:26:37 <vegai> model=>module
05:27:03 <defcon8> it says first and second aren't in scope now
05:27:08 <lisppaste2> dons annotated #26708 with "fmt" at http://paste.lisp.org/display/26708#1
05:27:12 <lohmi123> mauke: can you tell me the correct line for type ?
05:27:27 <vegai> well, they aren't :)
05:27:38 <defcon8> thanks dons
05:27:46 <mauke> import IO; askfornumbers :: IO [Integer]; askfornumbers = do ...
05:28:42 <defcon8> dons, it's still saying first and second aren't in scope
05:29:52 <dons> fst, snd
05:29:57 <dons> ?type fst
05:29:59 <lambdabot> forall a b. (a, b) -> a
05:30:00 <dons> ?type snd
05:30:01 <lambdabot> forall b a. (a, b) -> b
05:30:10 <dons> ?. djinn type fst
05:30:11 <lambdabot> f (a, _) = a
05:30:13 <dons> ?. djinn type snd
05:30:14 <lambdabot> f (_, a) = a
05:30:20 <dons> ?. pl . djinn type snd
05:30:22 <lambdabot> f = snd
05:30:25 <dons> ?. pl . djinn type fst
05:30:26 <lambdabot> f = fst
05:30:30 <dons> :D
05:31:52 <defcon8> hmm
05:31:58 <bourbaki> is this djin thingy a search in function space?
05:31:59 <defcon8> fst and snd don't seem to work fir lists
05:32:00 <lohmi123> mauke. ok thanks, works. what does it mean ?
05:32:30 <mauke> lohmi123: it means askfornumbers is an IO action that returns a list of integers
05:32:46 <defcon8> is there a nth function for lists?
05:32:51 <mauke> this tells the compiler that read word is supposed to return an integer
05:32:56 <mauke> ?type (!!)
05:32:57 <lambdabot> forall a. [a] -> Int -> a
05:36:07 <mikael-> Hey.  Do you know of any writings about using Haskell to write compilers?
05:36:17 <dcoutts__> lots
05:36:29 <dcoutts__> especially haskell compilers :-)
05:37:18 <mikael-> I'm not interested in that in particular, but I guess the general principles would be useful.  Unless it gets arcane really quick because of lazy evaluation and whatnot...  :-)
05:37:48 <Philippa> shortest answer: do the traditional stuff and revel in the power of algebraic datatypes and pattern matching
05:38:08 <Philippa> Shortest non-answer: compiler :: SourceCode -> ObjectCode :-)
05:38:16 <mikael-> :-)
05:38:34 <vincenz> Philippa: heh, or 'mix mix mix'
05:38:39 <Philippa> lazy evaluation tends not to get in your way much in a compiler. And I'm pretty sure there're times it'll let you write something nifty in little space
05:38:49 <dcoutts__> mikael-: there's a good book on compiler contruction that uses ml as the language, that applies pretty well for using Haskell too
05:38:55 <vincenz> dcoutts__: apple?
05:39:02 <vincenz> s/le/el
05:39:04 <Philippa> compilers tend to deconstruct nicely into phases, and those phases're all "obviously" functions
05:39:06 <dcoutts__> yep
05:39:17 <vincenz> yeah, it's definitely a nice book :)
05:39:20 <dcoutts__> Philippa: tell that to ghc :-)
05:39:26 <Philippa> so it works nicely at a high level, and at a low level you've got lots of good tools for AST manipulation
05:39:27 <bartw> what book ?
05:39:28 <dcoutts__> it's full of mutable state
05:39:31 * Philippa nods
05:39:33 <mikael-> oh, yeah, I meant a compiler that -compiles- haskell might be arcane due to lazy evaluation
05:40:04 <Philippa> but the mutable state tends to come about either from grabbing speed or from things like backpropagating details, right?
05:40:46 <dons> I wonder if more compilers are written in Haskell now, than any other language?
05:41:13 <bartw> Philippa : what book do you usggest about haskell compilers written in haskell ?
05:41:33 <bartw> dons: i know a few written in java
05:42:39 <dons> 'implementing functional languages: a tutorial' is online, nad useful
05:42:41 <dons> also
05:42:47 <dons> ?where plbook
05:42:47 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
05:43:19 <bartw> :) i'm starting to drown in pdfs i want to read, a good thing
05:43:51 <defcon8> how do I get the nth item of a list?
05:43:56 <defcon8> ?hoogle nth
05:43:57 <lambdabot> System.Time.ctMonth :: CalendarTime -> Month
05:43:57 <lambdabot> System.Time.Month :: data Month
05:43:57 <lambdabot> System.Time.tdMonth :: TimeDiff -> Int
05:44:00 <lennart> bartw: Peyton Jones & Lester have a book about a Haskell compiler in Haskell.
05:44:03 * defcon8 kicks lambdabot 
05:44:09 <dons> defcon8: ready was answered, !!
05:44:16 <dons> ?type (!!)
05:44:17 <lambdabot> forall a. [a] -> Int -> a
05:44:18 <defcon8> sorry, I was out
05:44:21 <dons> > "haskell" !! 3
05:44:23 <lambdabot>  'k'
05:44:44 <defcon8> > [a,b,c,d,e,f,g]
05:44:44 <lambdabot>  Not in scope: `g'
05:44:50 <defcon8> > [a,b,c,d,e,f,g] !! 3
05:44:50 <lambdabot>  Not in scope: `g'
05:44:55 <defcon8> whoops
05:45:09 <defcon8> > ['a','b','c','d','e','f','g'] !! 3
05:45:10 <lambdabot>  'd'
05:45:13 <defcon8> > ['a','b','c','d','e','f','g'] !! 0
05:45:14 <lambdabot>  'a'
05:45:25 <defcon8> dons, is there a function for it, though?
05:45:27 <dons> bartw: http://research.microsoft.com/%7Esimonpj/papers/slpj-book-1987/index.htm
05:45:30 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/jd2f6
05:45:30 <defcon8> non syntactical sugar
05:45:33 <dons> defcon8: !! is the function
05:45:37 <defcon8> it is infix
05:45:38 <dons> its not syntax
05:45:40 <defcon8> I don't like infix
05:45:48 <bartw> dons: thanks
05:45:49 <Igloo> Use (!!) then
05:45:56 <defcon8> right, thanks
05:45:57 <dons> > let index = (!!) in "haskell `index` 3
05:45:57 <lambdabot>  Improperly terminated string
05:46:03 <dons> > let index = (!!) in "haskell" `index` 3
05:46:05 <lambdabot>  'k'
05:46:10 <dons> > let index = (!!) in index "haskell"  3
05:46:11 <lambdabot>  'k'
05:46:18 <dons> > (!!) "haskell"  3
05:46:20 <lambdabot>  'k'
05:46:26 <dons> if you don't like infix...
05:46:38 <vegai> tmtowtdi!
05:46:49 <dons> bartw: also, http://research.microsoft.com/Users/simonpj/Papers/pj%2Dlester%2Dbook/
05:46:50 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/zf2d7
05:46:51 <bartw> dons: 1987 isn't it out of date by now
05:47:02 <dons> some of it is still relevant. the early bits
05:47:18 <dons> i.e. writing lexers hasn't changed that much
05:47:24 <dons> though you might use alex and parsec/happy these days
05:47:43 <dons> couple of other referecnes here, http://cgi.cse.unsw.edu.au/~cs3161/docs/references.php
05:47:44 <lambdabot> http://tinyurl.com/gj299
05:48:20 <bartw> guess i need a pocket universe to be able to read all that ;)
05:48:28 <lennart> bartw: http://research.microsoft.com/%7Esimonpj/Papers/pj%2Dlester%2Dbook/
05:48:30 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/jm7pe
05:48:45 <lennart> ah, i'm too late :)
05:49:15 <lennart> it's not really that out of date
05:49:26 <dons> the book is good, yeah.
05:49:46 <dons> the tutorial from 87 is a little, most of the libraries have changed, and you don't build everything from S and K now..
05:50:01 <dons> though that's good for you
05:50:53 <bartw> got a weekend with no inet comming up, great material for it
05:51:15 <pejo> Are there any alternatives to that book still in print?
05:51:32 <dons> the book is online, though, isn't it?
05:51:45 <lennart> it's good to build a simple compiler before you start something complicated
05:52:14 <dons> yeah, bartw, you could take the '87 tutorial and write a mini-haskell compiler over the weekend.
05:52:58 <dons> the audreyt approach to learning a haskell
05:53:01 <pejo> (And is the reason to it being out of print that nobody wants to build functional compilers nowdays?)
05:53:23 <dons> the internet made books obsolete?
05:53:39 <vegai> it would if there was a decent reader
05:53:48 <vegai> i.e. better than paper
05:53:57 <bartw> laptops and pdf are a poor book
05:54:29 <bartw> scrolling is just not easy enough
05:56:34 <edwinb> I find it okay except for two column papers...
05:57:04 <bartw> laptops don't fit a4 so it is allways either halve a page or worse
05:57:21 <bartw> it wouldn't be so bad if pdf didn't force a specific view
05:58:22 <lisppaste2> defcon8 annotated #26708 with "why index too large?" at http://paste.lisp.org/display/26708#2
05:58:29 <Philippa> Appel's book covers the basics of implementing functional languages but doesn't look into making lazy ones fast
05:58:41 <lisppaste2> lohmi123 pasted "problem with IO" at http://paste.lisp.org/display/26709
05:59:03 * defcon8 thinks it should work fine
05:59:35 <mauke> defcon8: because predo doesn't work with lists of length 1
05:59:58 <lohmi123> can anyone write me a main function which simply prints the sum of all numbers that are read by askfornumbers ?
06:00:00 <defcon8> damn :|
06:00:22 <defcon8> then I should define a function for a list with [x] ?
06:00:22 <dons> main = askfornumbers >>= print . sum
06:00:41 <mauke> lohmi123: main = do { nums <- askfornumbers; print (sum nums) }
06:00:54 <dons> ?undo main = do { nums <- askfornumbers; print (sum nums) }
06:00:54 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
06:00:55 * dcoutts__ prefers main = print . sum =<< askfornumbers
06:01:08 <dons> ?undo do { nums <- askfornumbers; print (sum nums) }
06:01:08 <lambdabot> askfornumbers >>= \ nums -> print (sum nums)
06:01:10 <mauke> lohmi123: I'd put the hSetBuffering into main, actually
06:01:14 <dons> ?. pl undo do { nums <- askfornumbers; print (sum nums) }
06:01:14 <lambdabot> print . sum =<< askfornumbers
06:01:20 <dcoutts__> hah ha!
06:01:21 <dons> ah, dcoutts__ wins
06:01:36 <dcoutts__> @arr!
06:01:36 <lambdabot> Swab the deck!
06:01:44 <bartw> @yar!
06:01:45 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
06:01:55 <mauke> fmap (fmap print sum) askfornumbers
06:02:05 <defcon8> dons, predo x [y] = | x > y !! 0 = True
06:02:06 <defcon8>               | otherwise = False is that okay?
06:02:35 <defcon8> take away the equals
06:02:38 <mikael-> what's ?. pl undo?
06:02:41 <mauke> defcon8: foo | cond = True | otherwise = False is the same as foo = cond
06:02:57 <lohmi123> i thought about using foldl (+) 0 askfornumbers. but i need to get rid of this IO type.
06:03:08 <mikael-> I know what ?pl does... is this some special thing for points-freeing do notation?
06:03:13 <mauke> ?type join . fmap (fmap print sum)
06:03:14 <lambdabot> forall a. (Num a) => IO [a] -> IO ()
06:03:35 <kpreid> mikael-: yes; it's a workaround for pl not understanding do notation
06:03:48 <mauke> mikael-: . combines two bot commands
06:03:57 <mikael-> ah :-)
06:04:15 <mikael-> ?undo do { foo <- bar; return foo }
06:04:16 <lambdabot> bar >>= \ foo -> return foo
06:04:19 <mauke> lohmi123: that's what do { nums <- askfornumbers; does
06:04:40 <mikael-> ?. pl undo do { foo <- bar; return foo }
06:04:41 <lambdabot> bar
06:04:44 <mikael-> neat :-)
06:05:20 <mauke> ?. djinn type const
06:05:22 <lambdabot> f a _ = a
06:05:47 <mikael-> :-D
06:06:06 <defcon8> predo x list | and [x > list !! 0, x > list !! 1] = True <-- what is wrong with that line?
06:06:27 <defcon8> says it expected a when I gave it [a] which I don't think I did
06:06:31 <NamelessOne> So why does (!!) count from 0 instead of 1?
06:06:41 <mikael-> ?djinn ((a -> b) -> a) -> a
06:06:41 <lambdabot> -- f cannot be realized.
06:06:47 <mikael-> :(
06:07:11 <defcon8> anyone?
06:07:51 <mauke> NamelessOne: because counting from 1 is an abomination unto the lord
06:07:59 <Lemmih> NamelessOne: Because that's the right thing to do?
06:08:05 <Philippa> because 0 is a natural number
06:08:18 <mauke> > let predo x list | and [x > list !! 0, x > list !! 1] = True in predo
06:08:19 <lambdabot>  Add a type signature
06:08:19 <bartw> isn't counting allways from one
06:08:35 <Philippa> right. But to get the first item, you /skip/ 0 items
06:08:40 <mauke> > let predo x list | and [x > list !! 0, x > list !! 1] = True in predo 'a' "bcd"
06:08:42 <lambdabot>  Non-exhaustive patterns in function predo
06:08:50 <lisppaste2> lohmi123 pasted "trying to use foldl" at http://paste.lisp.org/display/26710
06:08:51 <mauke> defcon8: works here
06:08:55 <NamelessOne> I find it unnatrual to refer the nth element as list !! (n-1)...
06:09:11 <defcon8> predo x [y] | x > y !! 0 = True
06:09:11 <defcon8>             | otherwise = False
06:09:11 <defcon8> predo x list | and [x > list !! 0, x > list !! 1] = True
06:09:11 <defcon8>              | otherwise = False
06:09:14 <dons> welcome to computer science
06:09:14 <defcon8> that's the whole function
06:09:18 <kpreid> NamelessOne: Also, in general, zero-based *indexing* works better when you're also dealing with related fractional quantities
06:09:18 <dons> we count from 0
06:09:33 <mauke> defcon8: change y !! 0 to y
06:09:36 <NamelessOne> :)
06:09:39 <Philippa> in fact, zero-based indexing turns out to be more natural, mathematically speaking
06:09:42 <mauke> defcon8: and remove that | otherwise = False crap
06:09:47 <bartw> dons: great quote :)
06:09:49 <defcon8> mauke, oh yeah
06:10:04 <dons> ;)
06:10:09 <mauke> lohmi123: ITYM return (foldl (+) 0 numlist) or return (sum numlist)
06:10:40 <mauke> predo x [y] = x > y; predo x (y1 : y2 : _) = x > y1 && x > y2
06:10:45 <defcon8> now I'm getting a non-exhaustive pattern error
06:10:46 <mikael-> heh-heh, "more natural"
06:10:57 <bartw> @quote dons Welcome to computer science, we count from 0.
06:10:58 <lambdabot> dons Welcome to computer science, we count from 0. hasn't said anything memorable
06:11:07 <dons> bartw: 'remember'
06:11:19 <Philippa> mikael-: quite :-)
06:11:21 <bartw> @remember dons Welcome to computer science, we count from 0.
06:11:25 <defcon8> mauke, what is the _ for at the end?
06:11:38 <mauke> defcon8: _ is the black-hole variable
06:11:46 <mauke> it's used in patterns when you don't need the result
06:11:47 <defcon8> I get it now, thanks
06:11:55 <sek> is there any way to define an instance declaration for a type?
06:13:07 <Lemmih> sek: For a type synonym?
06:13:13 <sek> yeah
06:13:14 <defcon8> my algorithm is borked
06:13:41 <sek> basically if i want to have a Show declaration for a [a] where a is a data declaration
06:14:01 <lohmi123> ok, it runs now. but i dont see the result of the main function ( which should have the sum of the entered numbers) .
06:14:08 <sek> id like to have like type manyAs = [a]   instance Show manyAs where ...
06:14:18 <mauke> instance Show TheData where showList = ...
06:14:25 <lisppaste2> defcon8 annotated #26708 with "what is wrong with the algorithm?" at http://paste.lisp.org/display/26708#3
06:14:27 <mauke> lohmi123: yeah, you want print instead of return
06:14:52 <mauke> hmm, predo k xs = all (k >) (take 2 xs)
06:14:58 <sek> mauke: that works for data types, i get an error for type declarations
06:15:32 <mauke> sek: yeah, you can't do that for type aliases
06:15:36 <lohmi123> nice :) if the main would be a real function, it would automatically show the resulting value, right ?
06:15:45 <mauke> huh?
06:15:56 <sek> and i cant do: data manyAs = [a]    either as i would need something like data manyAs = MANYAS [a]   which would imply many changes in my code
06:18:20 <lohmi123> ok, thanks so far for your help. my first exercise in tutorial is done :)
06:19:14 * mrchebas heard rumors that someone was going to film the GHC hackathon.
06:19:36 <mrchebas> does anyone know where to get a GHC hackathon video, if one exists?
06:19:59 <mauke> main = interact (show . sum . map read . lines)
06:28:17 <dons> sometimes I see strange things on the internets, ""Hello, Wordl" in Mozilla is six or seven files in as many different languages.
06:28:45 <mikael-> hello, foldl!
06:29:03 <integral> pity XPCOM's not easily mappable to nice haskell :-/
06:29:26 <Igloo> mrchebas: Malcolm Wallace made one; no idea where he put it, if anywhere yet
06:29:43 <mrchebas> Igloo: cool, i can't wait to see it
06:30:39 <mrchebas> dons: I guess you already read this rant too? http://steve-yegge.blogspot.com/2006/09/bloggers-block-3-dreaming-in-browser.html
06:30:42 <lambdabot> Title: Stevey's Blog Rants: Blogger's Block #3: Dreaming in Browser Swamp, http://tinyurl.com/oph9c
06:31:20 <dons> that's the one, yeah.
06:31:53 <mrchebas> dons: and to think that at some point I REALLY wanted to learn XUL programming
06:32:18 <dons> scary
06:32:37 <dons> me, I prefer the Haskell version: print "Hello, World"
06:32:38 <bourbaki> is there any haskell related space i could upload my files to? such that i can create a new haskell wiki page for my idea?
06:32:51 <dons> bourbaki: you can upload files to haskell.org's wiki
06:32:58 <bourbaki> oh cool
06:33:00 <dons> (via the 'Upload' link on the wiki)
06:33:14 <bourbaki> so i can host my textfiles and the images there?
06:34:13 <dons> yes, I think so.
06:34:41 <x3m> @paste
06:34:41 <lambdabot> http://paste.lisp.org/new/haskell
06:34:52 <bourbaki> hm how can i make a new page? or can i just edit one and attach my stuff to it?
06:35:07 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26712
06:35:45 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26713
06:36:22 <x3m> dons: cant i add extra "compares" like in that paste?
06:36:36 <dons> bourbaki: yep
06:36:42 <dons> just start a new page by typing in the desired url
06:36:58 <bourbaki> ah ok
06:37:00 <dons> then link it somewhere to the rest of the wiki, either via 'Categories' or adding a link to some related page
06:37:17 <dons> i.e. adding [[Category:Tutorial]] or what have you
06:37:19 <bourbaki> any idea what i should name the page ?
06:37:37 <dons> something reasonable, and use _ for spaces (not CamelCase)
06:37:58 <mauke> http://img.4chan.org/b/src/1159170508835.jpg
06:38:30 <bourbaki> he tells me that im not allowed to edit the page ...
06:38:36 <dons> you need to log in first
06:38:44 <dons> and register an account (just a user name and passwd)
06:38:52 <bourbaki> ah ok sry
06:40:02 <lisppaste2> dons annotated #26713 with "fmt" at http://paste.lisp.org/display/26713#1
06:40:37 <dons> x3m: ^^
06:41:14 <bourbaki> hm ok but it seems that i cant upload ... maybe you need extra access for that?
06:41:38 <dons> x3m, but you are missing a ':', privmsgs look like "PRIVMSG #haskell :some reponse"
06:41:54 <dons> bourbaki: I don't think so. should be abel to just upload once you've logged in
06:42:02 <dons> let me try..
06:42:33 <dons> seems to work. bourbaki what error do you get?
06:42:53 <bourbaki> dons i dont see any button where i could upload it
06:43:21 <dons> you've logged in? and it says you name on the page at the bottom? i.e. "            DonStewart (Talk)"
06:43:35 <bourbaki> yes im editing the page already
06:43:38 <dons> and at the bottom of the page,               Upload file | Special pages | Bug reports              My watchlist | My contributions
06:43:43 <bourbaki> sec
06:44:09 <bourbaki> do you mean if i am logged in and editing a page?
06:44:22 <bourbaki> or on my userprofile thingy?
06:44:42 <dons> if you're logged in, there should be an 'Upload file' link on every page, afaik
06:44:50 <dons> not when you're editing though.
06:45:02 <dons> you upload the file separately, then link to it from a page you're editing
06:45:11 <bourbaki> then i cant do that :(
06:45:28 <dons> so there's no 'Upload file' on, say, the front page?
06:45:34 <xerox> ?yarr
06:45:35 <lambdabot> Swab the deck!
06:45:41 <xerox> No please!
06:45:59 <bourbaki> no
06:46:03 <edwinb> pirates don't usually say 'please' ;)
06:46:08 <nisse> anyone else asked for help with black jack game this past week? :)
06:46:11 <bourbaki> or i am blind but i cant find an upload button
06:46:42 <dons> I don't see it when I'm not logged in..
06:46:44 <xerox> edwinb!
06:47:27 <dons> but if I log in... the Upload file button appears at the bottom of the page, near 'Special pages'
06:47:31 <bourbaki> well i am logged in i think because i am editing that page atm
06:47:37 <dons> yes.
06:47:49 <dons> but try opening up another window, and just logging in then viewing a page
06:47:59 <bourbaki> ok sec
06:48:48 <bourbaki> i dont see it on the fronpage
06:48:53 <bourbaki> and not on my profile either
06:49:07 <bourbaki> maybe you have another access level than me
06:49:12 <dons> hmm
06:49:20 <dons> I didn't think there were access levels
06:49:21 <shapr> Hey, I missed trurl!
06:49:41 <dons> does anyone else see an 'Upload file' link after logging in to the haskell.org wiki?
06:49:49 <dons> and viewing , say, the front page
06:50:35 <xerox> Yes I do.
06:50:37 <ndm> dons: yep
06:50:47 <xerox> Upload file | Special pages | Bug reports
06:50:55 <bourbaki> hm .,...
06:50:57 <xerox> [                    ] [ Go ] [ Search ]
06:51:21 <dons> hehe http://prince-web1.princeton.edu/archives/2006/05/08/news/15576.shtml
06:51:25 <lambdabot> Title: The Daily Princetonian - I'm a computer scientist, not your tech support, http://tinyurl.com/ke6fw
06:51:37 <dons> 'There's not even a class called "Fixing People's Email." Shocking, I know.'
06:52:26 <bourbaki> maybe i need to wait some time?
06:52:34 <bourbaki> maybe its a security featrue
06:52:44 <dons> don't think so.
06:52:56 <bourbaki> damn :(
06:52:57 <dons> are you sure you're logged in? does it print your user name when you view the front page?
06:53:07 <bourbaki> yes in the upper right
06:53:25 <dons> upper right? hmm. you're looking at the 'haskellwiki'?
06:53:28 <dons> not 'hawiki'
06:53:51 <bourbaki> aha! :)
06:53:53 <dons> i.e. http://haskell.org/haskellwiki/Haskell ?
06:53:54 <lambdabot> Title: Haskell - HaskellWiki
06:54:03 <bourbaki> ok i think thats the problem then... sry for the fuzz
06:54:07 <dons> ah :)
06:54:20 <bourbaki> i already felt a little challenged
06:54:34 <dons> hehe. 2 wikis is 1 too many
06:54:39 <bourbaki> wouldnt the hawiki be a better place for my stuff though?
06:54:57 <dons> its obsolete. all new stuff appears on the haskellwiki
06:55:05 <dons> it doesn't have to be linked from the main page though ;)
06:55:06 <bourbaki> ok ... hm
06:55:25 <dons> it doesn't have to link from anywhere, if you want to hide and bury it away so only 10 people ever view it :)
06:55:46 <Igloo> Why is hawiki still around?
06:55:57 <dons> license issues (sigh)
06:56:04 <dons> so old contest hasn't been ported
06:56:13 <dons> shapr: but do we want to at least freeze hawiki now?
06:56:20 <xerox> I think it is frozen.
06:56:46 <Igloo> Is there a list of unported content somewhere?
06:57:09 <dons> there's many pages, yes. most of the hawiki isn't ported
06:57:15 <dons> since people got cold feet about copyright
06:57:43 <dons> though I hardly think we're going to be sued if we move the contest to haskellwiki...
06:57:49 <dons> content.
06:57:56 <Igloo> We need a to-be-ported list, or we won't know what needs to be done or when we have done it
06:58:24 <dons> as pages are ported from hawiki they're supposed to be made blank. but yes, we should have a list.
06:58:28 <dons> a stack, if you will.
06:58:33 <x3m> dons: is ghci type safe?
06:58:51 <Igloo> If hawiki is frozen then how are things blanked?
06:58:55 <dons> x3m, you can't rely on ghci to be safe over the net, x3m, since users can always use qualified names to import things
06:59:00 <ndm> dons: who told everyone that ported pages were meant to go blank?
06:59:05 <dons> i didn't think it was frozen
06:59:28 <dons> ndm, oh, hmm. it was some kind of convention that you replace the content with a link to the new wiki
06:59:41 <dons> maybe in the mailing discussion at the time?
06:59:42 <x3m> dons: ooh, but dont you need the "keyword import" for that.. then just check for that before passing it to ghci?
07:00:32 <dons> x3m, nope. you could always just say: System.IO.Unafe.unsafePerformIO (readFile "passwords" >>= print)
07:00:46 <Igloo> Is there a way to get a page list from hawiki?
07:00:48 <dons> ghci isn't the same as a haskell source file
07:01:00 <ndm> Igloo: yep, just looking it up...
07:01:03 <ndm> @oldwiki Yhc
07:01:04 <lambdabot> http://www.haskell.org/hawiki/Yhc
07:01:08 <dons> yeah. localSiteMap ?
07:01:16 <dons> http://haskell.org/hawiki/FrontPage?action=LocalSiteMap
07:01:19 <lambdabot> Title: Local Site Map for "FrontPage" - The Haskell Wiki, http://tinyurl.com/rvmx7
07:01:24 <dons> ah not quite
07:01:27 <dons> there's some other way
07:01:29 <ndm> Igloo: [[PageList(*)]] on any page
07:01:45 <x3m> dons: how about check for "unsafe" then, and if it exists dont pass it to ghci?
07:01:50 <x3m> or wouldnt that work either
07:01:52 <Igloo> ndm: Eh?
07:01:54 <dons> x3m, nope.
07:02:04 <dons> there's other security issues too. that's why we wrote runplugs :)
07:02:29 <dons> x3m, it would perhaps be simpler to install mingw
07:02:35 <ndm> Igloo: create a wiki page, on that page put [[PageList(*)]] in the wiki text, then view the page
07:02:50 <x3m> dons: maybe, what does mingw do..?
07:03:13 <dons> seems to fix the dynamic linker so runplugs works, apparently
07:03:35 * dons `ap` sleep
07:03:39 <musasabi> x3m: Foreign.* is also enough to break safety.
07:03:42 <x3m> well yeah i meant why.. does i have to keep mingw installed to run the program and so on?
07:03:59 <musasabi> as are things in Data.Array.Base. But I think lambdabot gets most of things at least.
07:04:15 * Igloo is not allowed to edit this page
07:04:32 <bourbaki> ha im so proud :)
07:04:34 <bourbaki> http://haskell.org/haskellwiki/Graep
07:04:35 <lambdabot> Title: Graep - HaskellWiki
07:05:00 <Igloo> Who runs hawiki?
07:05:11 <dons> shapr, I think
07:05:18 * Igloo prods shapr
07:06:36 <bourbaki> hm why cant i click on discuss this page?
07:06:55 <xerox> bourbaki: you can, you have to create the page.
07:07:09 <bourbaki> i see the page though atm
07:07:38 <bourbaki> anyway no i dont need to send out mails all the time :)
07:08:46 <shapr> Igloo: wha?
07:08:59 <Igloo> shapr: How can I get a hawiki page list?
07:09:10 <shapr> Hawiki, not haskellwiki, right?
07:09:14 <Igloo> Right
07:09:30 <shapr> Hm, I know there's a macro to do it...
07:09:32 <Igloo> And how can we replace content with a pointer to the new wiki when appropriate?
07:09:32 * shapr looks
07:09:52 <shapr> You could define an entry in the InterWiki page.
07:09:53 <Igloo> shapr: I was told [[PageList(*)]], but then the wiki told me I couldn't edit a page to put it in
07:10:58 <Igloo> shapr: So hawiki isn't frozen?
07:11:13 <shapr> No, but it probably should be.
07:11:28 <shapr> You just need to login to change stuff.
07:11:48 <Igloo> Oh, I assumed I was as it had a UserPreferences link, but now I see that doesn't follow
07:12:10 <shapr> I wish I could remember my login...
07:12:46 <shapr> Wow, dcoutts__ has been idle on haskell.org for 33 days!
07:13:26 <bourbaki> hehe
07:14:11 <musasabi> http://haskell.org/hawiki/PageList
07:14:12 <lambdabot> Title: PageList - The Haskell Wiki
07:14:39 <Igloo> Err, there's a shedload of spam on my UserPreferences page, and I've only just created the account; perhaps spam on some template page?
07:15:03 <Igloo> Thanks musasabi
07:15:05 <shapr> Yeah, I need to remove that spam.
07:15:35 <Igloo> Hmm, is it possible to make it impossible to add new pages, but still allow changing of content?
07:15:41 * musasabi deleted it from UserPreferences.
07:17:24 <shapr> It's probably most sensible to change the header or footer and add a link to the haskellwiki page of the same name, and then lock the wiki.
07:17:30 <Igloo> Why has the toolbar disappeared now I've logged in?
07:18:04 <shapr> You can change your navigation settings to change the toolbar, maybe you did that when you created your account?
07:18:11 <Igloo> Oh, everything defaults to off. I'm glad we don't use this wiki any more
07:18:35 <shapr> Well, it was better than the previous PyWiki.
07:19:22 <Igloo> Err, it doesn't work
07:20:19 <Igloo> Oh, I see, galeon's put my password in one of the boxes which it doesn't like
07:20:27 <shapr> ?
07:21:43 <dons> shapr: oh, btw, do we have iohcc/succzeroth-2004 stored somewhere?
07:21:47 <Igloo> Actually, just locking the wiki is probably fine as we can have the migration page be on the new wiki
07:22:53 <shapr> Um
07:22:57 <Igloo> Err, how does http://haskell.org/hawiki/MahlenMorris?action=info work?
07:22:59 <lambdabot> Title: Info for "MahlenMorris" - The Haskell Wiki, http://tinyurl.com/zfd72
07:23:06 <Igloo> It was never created?
07:23:31 <shapr> dons: I left it in Stockholm with my girlfriend. I'll ask her to carry it over here in October.
07:23:41 <shapr> Igloo: What are you trying to do?
07:23:51 <Igloo> I want to see who made that page
07:23:59 <dons> shapr: carry? so its not online anywhere?
07:24:06 <Igloo> Like how http://haskell.org/hawiki/AlmostCode?action=info tells me dons made that one
07:24:08 <lambdabot> Title: Info for "AlmostCode" - The Haskell Wiki, http://tinyurl.com/j9ou5
07:24:29 <shapr> Nope, it's not online anywhere.
07:24:29 <dons> we better archive it quick smart then..
07:24:33 <Igloo> Oh, wait, that's a page associated with an account?
07:24:42 <dons> hmm. QuickSmart sounds like a good name for a QuickCheck successor..
07:24:48 * shapr agrees
07:24:58 <Igloo> Does that mean only Mahlen can edit it?
07:25:13 <shapr> Igloo: Yup, that page is probably associated with the MahlenMorris user account. No, any logged in user should be able to edit the page.
07:25:21 * dons moves the almost code page
07:25:24 <shapr> But it seems that the revision history is gone.
07:26:24 * Igloo wishes he were as productive while sleeping as dons seems to be  :-)
07:26:50 <dons> i've discovered that teling myself to go to bed doesn't work
07:27:07 <norpan> dons: go to bed!
07:27:07 * Igloo hasn't managed to convince my body it should be in UK time, not Pacific time, yet
07:27:09 <dons> now, should I edit the AlmostCode page on the old wiki?
07:27:25 <dons> what convention should we use to indicate this hawiki page is now dead
07:27:26 <Igloo> Yes. Replace the whole thing with a "Now moved to <link>"
07:27:32 <dons> ok
07:27:47 <dons> I'd forgotten all about perfunctors
07:30:07 <glguy> Perfunctors?
07:30:29 <dons> sure, like Functors
07:30:44 <dons> ?wiki Almost_Haskell
07:30:44 <lambdabot> http://www.haskell.org/haskellwiki/Almost_Haskell
07:31:14 <dons> ok.one page down. 300 to go
07:31:26 <bartw> what would functors add to haskell, isn't a curried function allready the same thing ?
07:31:56 <dons> ?type fmap
07:31:57 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:31:58 <profmakx> quasicode -.-
07:32:03 <glguy> ?instances Functor
07:32:04 <dons> ?instance Functor
07:32:04 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:32:04 <lambdabot> Maybe you meant: instances instances-importing
07:35:28 <sris> could someone give me a point in the right direction if i want to create all possible  "sub-permutations" of a list like [[a,b],[c,d],[e,f]], i.e. [a,c,e], [a,d,f] ...
07:35:53 <integral> List monad!
07:36:01 <glguy> sequence
07:36:07 <bartw> @pl \f g (a,b) -> (f a, g b)
07:36:08 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
07:36:29 <glguy> > ((+1) *** (*2)) (4,5)
07:36:30 <lambdabot>  (5,10)
07:36:38 <glguy> bartw: ^^
07:36:57 <glguy> sris: sequence [[1,2],[3],[4,5]]
07:37:12 <integral> @type let subperm (xs:xxs) = do { y <- xs; ys <- subperm xxs; return (y : ys) } in subperm
07:37:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:38:24 <sris> glguy, nice, gonna look it up
07:38:53 <glguy> sris: integral is trying to explain the why to you
07:39:11 <glguy> sris: sequence is a very useful generalized function
07:39:33 * integral hadn't seen sequence himself before
07:39:55 <glguy> integral: well, you just wrote out the definition
07:40:21 <integral> ah, I see, I *have* seen it, but my brain is wimping out on me
07:41:26 <sris> seems like magic at the time, but saves me a lot of work :D
07:41:48 <glguy> sris: it is the generalization of:
07:42:05 <glguy> > [ [a,b,c] | a <- [1,2], b <- [3], c <- [4,5]]
07:42:07 <lambdabot>  [[1,3,4],[1,3,5],[2,3,4],[2,3,5]]
07:42:51 <sris> ah, that's smart. didnt think of that.
07:51:31 <glguy> The best part about reversing emoticons is that clients that try to convert emoticons to graphics won't (c;
07:59:54 <hyrax42> @info (//)
07:59:55 <lambdabot> (//)
08:01:22 <glguy> hyrax42: trying to understand how to update an array?
08:01:29 <glguy> ?index (//)
08:01:30 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
08:01:38 <glguy> or trying to figure out what to import
08:01:39 <hyrax42> glguy: nah, just wanted it's fixity
08:01:42 <glguy> oh
08:01:50 <hyrax42> never mind, fixity waws the problem
08:01:53 <hyrax42> parens fixed it
08:01:53 <glguy> I think you have to ask ghci directly for that stuff
08:01:57 <hyrax42> yea
08:02:02 <hyrax42> I was testing in hugs though
08:02:06 <hyrax42> for quicker loading
08:02:12 <hyrax42> thanks
08:02:26 <glguy> doesn't hugs tell you on a :i (//) ?
08:02:44 <hyrax42> Types> :i (//)
08:02:44 <hyrax42> Unknown reference `(//)'
08:03:25 <glguy> :i // works tho
08:03:41 <hyrax42> oh
08:03:55 <hyrax42> well I get no info on fixity for it
08:04:03 <glguy> heh
08:04:03 <hyrax42> just the type
08:04:27 <glguy> I don't think // has a left or right fixity
08:04:44 <glguy> what did ghci say?
08:05:26 <hyrax42> oh hm
08:05:29 <hyrax42> no fixity you're right
08:05:31 <hyrax42> what's the default
08:05:35 <hyrax42> infixr 7?
08:05:44 <hyrax42> gah I asked this before
08:05:49 <hyrax42> I'll have to fidn the report
08:05:55 <hyrax42> (dont' look it up for me)
08:06:03 <glguy> you just can't do: array // updates // updates
08:06:27 <glguy> infixl 9  !, //
08:06:34 <glguy> you just need to type:    :f //
08:06:44 <glguy> and winhugs will open the source file for Array
08:06:53 <glguy> it's the 16th line
08:06:56 <hyrax42> well I was doing "array // updates ++ updates
08:07:01 <hyrax42> but that won't work for same reason
08:07:09 <glguy> actually, it's infix left
08:07:16 <glguy> so I guess you can chain them // //
08:07:52 <glguy> > listArray (0,4) [0..4] // [(1,2)] // [(2,3)]
08:07:53 <lambdabot>  array (0,4) [(0,0),(1,2),(2,3),(3,3),(4,4)]
08:08:06 <hyrax42> ah ok
08:08:10 <glguy> I wonder if ti would be slower to use the ++
08:08:10 <hyrax42> cool
08:08:27 <glguy> It probably doesn't matter in the small cases
08:08:29 <hyrax42> well I'm using DiffArray so I didn't want to clutter up the "history"
08:08:35 <glguy> ah
08:08:36 <glguy> ok
08:08:48 <hyrax42> but on the other hand... if I don't keep references around, does the history exist still?
08:08:49 <hyrax42> who knows
08:08:55 <glguy> not me
08:09:17 <hyrax42> anyway, it won't eally matter
08:09:24 <hyrax42> since this is a 8x7 array
08:09:29 <hyrax42> that is generated once
08:09:42 <glguy> but updated a lot?
08:10:06 <hyrax42> eventually yes
08:10:28 <hyrax42> the updates I was diong just now was for the initialisation of it
08:10:44 <hyrax42> (it's a board, the updates rae the initial positions of pieces)
08:10:56 <glguy> why are you updating for the initialization?
08:11:08 <hyrax42> cos I'm lazy :p
08:11:16 <hyrax42> I'll get it printed out and copy/paste it later
08:11:38 <glguy> Is something stopping you from initializing it with the starting state
08:11:51 <hyrax42> just having to write them all out
08:11:55 <hyrax42> I'm using list comps
08:12:06 <glguy> you can use list comps tho
08:12:10 <hyrax42> it's only temporary, I just want to get going
08:12:13 <glguy> ah
08:13:25 <roconnor> > 2^9 `mod` 19
08:13:26 <lambdabot>  18
08:17:42 <hyrax42> @type (.(:))
08:17:44 <lambdabot> forall a c. (([a] -> [a]) -> c) -> a -> c
09:34:43 <svref> how do I make emacs haskell-mode choose ghci instead of hugs?
09:35:11 <xerox> M-x turn-on-haskell-ghci
09:35:13 <xerox> IIRC.
09:35:20 <xerox> Or add a hook for ease of use..
09:35:36 <xerox> In fact I do this: (setq-default haskell-program-name "/usr/local/bin/ghci")
09:36:35 <svref> thanks!
09:36:59 <svref> Next emacs question: how do I make emacs recognise that the character ' (prime) is part of identifiers in haskell mode?
09:37:29 <svref> i.e. the expression-wise cursor movement commands aren't working right.
09:37:43 <xerox> I believe that (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci) will in turn toggle to active some more features than just setting the default program to be the ghci path.
09:38:18 <xerox> svref: do you have some lines of code you can paste and the chords you perform, so to understand what you mean?
09:38:47 <svref> sure, put this string in a haskell buffer: "silly'priming".
09:38:59 <svref> Then put the point after that, then hit C-M-b
09:39:17 <svref> point moves to "p", not to "s".
09:39:32 <xerox> It does not here.
09:39:40 <svref> eenteresting
09:39:52 <svref> it goes to "s" on your box?
09:40:00 <xerox> Yep.
09:40:19 <svref> hmmm....
09:40:40 <svref> what kind of emacs installation do you have?
09:40:51 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
09:42:41 <svref> my version number's the same... but I checked it out of CVS 3-2006.  I've never heard of "Circe"..
09:42:55 <xerox> 30 mins fly when you've got something to do... hrrmmmpf.
09:43:26 <svref> whats the stuff in your .emacs that tells the system about haskell?
09:43:38 <xerox> svref: oh sorry, it is just an IRC client running in Emacs.
09:44:06 <xerox> (load "~/Elisp/haskell-mode-2.1/haskell-site-file.el") (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode) (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci) (setq-default haskell-program-name "/usr/local/bin/ghci")
09:44:08 <svref> heh, hadn't heard of that before :)
09:44:16 <xerox> It's pretty nice!
09:44:27 <glguy> do ghci and winhugs not support : do { f; g} syntax?
09:44:38 <xerox> Sure they do support it.
09:44:54 <glguy> Do I have to turn it on?
09:45:06 <glguy> Main> do { let f = print 10; f ; f }
09:45:06 <glguy> ERROR - Syntax error in declaration (unexpected `;', possibly due to bad layout)
09:45:36 <xerox> Eh. That's a problem with `let.'
09:46:10 <xerox> This should work: do { let { amb = print 10 }; amb; amb }
09:46:26 <glguy> yeah
09:46:28 <glguy> that fixed it
09:46:31 <glguy> doh
09:46:35 <xerox> `let' tries to eat as much as it can.
09:46:40 <glguy> make sense now
09:46:49 <xerox> Howdy SyntaxNinja.
09:47:29 <SyntaxNinja> y0
09:47:37 <deadbeef> hi #haskell !!!11
09:50:19 <roconnor> hi d3adb33f
09:51:45 <svref> xerox: as a side effect of adding-hook turn-on-haskell-ghci, primes are suddenly part of identifiers.  Wierd.
09:53:04 <svref> haskell: so, glguy, what's your favorite "newbs guide to HOpenGL?"
09:53:26 <xerox> Syzygy-'s one!
09:53:33 <haskell> There's a good one on planet.haskell.org
09:53:45 <roconnor> >3*17+14
09:53:50 <haskell> missing space
09:53:50 <roconnor> > 3*17+14
09:53:58 <lambdabot>  65
09:54:05 <xerox> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
09:54:08 <lambdabot> Title: Michi&#8217;s blog  Blog Archive  OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
09:54:09 <haskell> that calculation took an awfully long time ;)
09:54:11 <xerox> There's a part two too, I think.
09:54:24 <haskell> xerox, he asked me :-p
09:54:25 <Stinger_> lambdabot's tired :P
09:54:35 <xerox> haskell: in public :)
09:54:46 <vincenz> hmm
09:54:53 <vincenz> oop, fp are different ...
09:55:14 <haskell> yeah, one is one 's' away from signifying a mistake
09:55:15 <xerox> Well, better get some work done!  Focus.
09:55:17 <svref> I would ask a guy named "glguy" about gl, and a guy named xerox about ... how to copy a list, I guess.
09:55:34 * haskell actually knows nothing about opengl
09:55:49 <xerox> That's not true.
09:56:03 <haskell> ok fine, i know what it is for
09:56:14 <ndm> @tell gour the latest head build of Yhc shouldn't require YHC_BASE_PATH, we fixed it up today - hopefully an install target will be coming soon, and a gentoo ebuild
09:56:15 <lambdabot> Consider it noted.
09:56:16 <xerox> Haskell has GL bindings :)
09:56:22 <haskell> unless you mean in the sense that
09:56:29 * haskell is a great general purpose language
09:56:29 <xerox> hehe.
09:56:56 <ValarQ> :)
09:57:32 <haskell> oh my, what novelty!
09:57:36 * haskell programs are staticly typed
09:57:50 <Syzygy-> Huh?
09:58:16 <Syzygy-> xerox: Yes, there is a part two up as well. :)
09:58:18 <dottedmag> me
09:58:20 <dottedmag> oops
09:58:48 <xerox> Syzygy-: do you know if it works as-is on OS X?
09:58:57 <Syzygy-> xerox: I haven't tested it, but it should...
09:59:07 <xerox> Good.
09:59:10 <roconnor> > 23*17-6*65
09:59:11 <lambdabot>  1
09:59:18 <haskell> I still can't believe that with all the dedicated users, that no oen else had registered this nick
09:59:19 <Syzygy-> xerox: If you have access to an OS X box, please try it out and tell me about it.
09:59:29 <xerox> Syzygy-: I will probably do it, yes.
09:59:50 <Syzygy-> haskell: I find it the slightest bit lame. Also, I already have a dedicated nick (with a history) on this network.
09:59:55 * xerox eats a candy and tries to disconcentrate on IRC...
10:00:12 * Syzygy- feeds xerox chocolate. :P
10:00:31 <xerox> IRC is evil.
10:00:35 <Syzygy-> Oh yes!
10:00:41 <haskell> Syzygy-: I'm not too worried about what you find lame, but I don't intend to use this as a primary nick
10:01:02 <Syzygy-> haskell: I didn't think you would - I would even be disconcerted if you cared too much about my thoughts.
10:01:21 <svref> Like a monkey, I apt-got hopengl, but when I try Syzygy-'s hello-world I get: Failed to load interface for `GLUT': Could not find interface file for `GLUT'
10:01:39 <SyntaxNinja> where's the unix utils wiki page?
10:01:41 <Syzygy-> svref: Did you make sure to compile it with -package GLUT?
10:02:34 <svref> oops, whoops, I can't tpye
10:02:37 <svref> type
10:02:43 <Syzygy-> What was the error? *curious*
10:04:37 <glguy> I recently discovered that POSIX's ^D is Windows' ^Z or F6
10:05:21 <svref> Syzygy-: I'm not sure...at first I named the file you call "HelloWorld.hs" "glut.hs".  Then I modified the command line accordingly...didn't work.  But with the filename named HelloWorld.hs, it works ... I'm not sure why, but I'm pretty sure its my fault. :)
10:05:46 <Syzygy-> svref: Does the file start with something like "module HelloWorld where" ?
10:06:00 <SyntaxNinja> nm
10:06:02 <SamB> hmm
10:06:58 <SamB> my attempt to read the manifesto has taken over 33 hours
10:07:05 <svref> Syzygy-: the program is just cut-n-pasted from your first grey box at http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
10:07:16 <xerox> I am copying my notes in a redable form, and I was unconsciously translating them in english in the meanwhile... how do you call that?  *erases*
10:07:17 <SamB> at something like 0.3% or 1% CPU
10:07:38 <SamB> and something more than 53% memory
10:08:17 * SamB wonders why not all memory
10:08:32 <SamB> or, well, more than that
10:12:36 <Syzygy-> Wait... What?
10:12:51 <Syzygy-> dcoutts: Are you @ Mittag-Leffler??
10:12:53 <svref> me?
10:13:00 <Syzygy-> svref: No, not you.
10:13:13 <Syzygy-> svref: I find it weird with the filename dependency, but I don't know what.
10:13:29 <Syzygy-> svref: It oculd be that you're not allowed to name the program the same as the library module it uses or something like that.
10:18:01 <SamB> xerox: I don't call that anything, because my notes would allegedly have been in english to start with ;-)
10:20:29 <gour> ndm: thank you for the fix. now i just set PATH and that's all !
10:20:29 <lambdabot> gour: You have 1 new message. '/msg lambdabot @messages' to read it.
10:20:59 * gour uses fish shell
10:21:07 <ndm> gour: yep, although definately has to be on your path
10:21:24 <ndm> you can still set YHC_BASE_PATH to override the default if you choose, but should rarely be necessary
10:21:50 <gour> i think so
10:22:16 * gour is looking forward to see yhc build gtk2hs
10:22:41 <glguy> Has YHC seen recent developments allowing it to do that?
10:22:53 <Igloo> http://www.haskell.org/haskellwiki/HaWikiMigration
10:22:56 <lambdabot> Title: HaWikiMigration - HaskellWiki, http://tinyurl.com/gzhlf
10:23:06 <ndm> glguy: some progress, but the base libraries are the essential one we are waiting on
10:27:49 <ski> (gour : http://fishell.sourceforge.net/ ?)
10:27:53 <glguy> HAppS seems to depend on Data.FastPackedString. That has become Data.ByteString now... right?
10:28:15 <glguy> ?index pack
10:28:15 <lambdabot> bzzt
10:28:20 <glguy> ?index unpack
10:28:20 <lambdabot> bzzt
10:28:25 <glguy> :-/
10:29:47 <musasabi> glguy: modern HAppS depends on Data.ByteString.
10:30:02 <glguy> musasabi: I just downloaded this tarball from the website
10:30:07 <glguy> do I need to use darcs?
10:30:19 <musasabi> http://happs.org/auto/HAppS-0.8.2.tar.gz
10:30:34 <musasabi> (probably released very soon)
10:31:03 <glguy> thanks
10:31:22 <glguy> looks like the fps that I just downloaded and installed is out of date also!
10:32:11 <glguy> where is fps 0.8?
10:33:46 <SamB> hmm, darcs?
10:33:56 * SamB hasn't considered tarballs
10:34:08 <musasabi> glguy: dons has not yet released a tarball out of it :-(
10:34:15 <glguy> ugh
10:34:16 <SamB> I could be using software that never ever releases and I wouldn't notice
10:34:32 <SamB> glguy: darcs get with the appropriate tag?
10:35:21 <SamB> I never saw the point of lambdabot releases before GOA
10:35:53 <SamB> (does he make tarballs for those?)
10:39:41 <musasabi> glguy: or you could use 6.6 rc which does not depend on fps (just use the .cabal.ghc66 file)
10:42:25 <glguy> where is the RC build?
10:45:19 <musasabi> good question. Are there binary snapshots of the 6.6 branch somewhere? (I tend to use HEAD, but that is very unstable at the moment)
10:46:06 <Lemmih> Is there a timetable for 6.6?
10:47:04 <Igloo> We'll probably announce another RC once caught up from ICFP, and then hopefully release shortly after that
10:50:53 <gour> ndm: do you use fishell?
10:52:55 <Philippa> is it cruel to take someone who's teaching themselves C++ slowly and show them OO ala Smalltalk?
10:53:25 <integral> extremely :)
10:53:28 <glguy> I only know C++, and not smalltalk
10:53:31 <glguy> why do you say that?
10:54:24 <Philippa> Alan Kay's comment about how he invented the term OO and C++ wasn't what he had in mind? :-)
10:54:44 * integral bets objC wasn't either
10:54:55 <Philippa> really, Smalltalk is very, very different to C++ - and in a high-level way, a lot more powerful
10:55:18 <Philippa> objC's probably a lot closer to it
10:55:22 <integral> Philippa: surely the key difference is that it's dynamic?
10:55:43 <glguy> I've used objC + Cocoa, I enjoyed it to a certain degree (didn't like the magic message names tho)
10:55:53 <Philippa> it's one of two really key differences, yes (dynamic typing not being the important part of dynamic, there)
10:56:00 <Philippa> the other is messages
10:56:29 <integral> hmm, I've never quite understood what's special about messages.  The reification?
10:56:47 <Philippa> more or less, yes. That, and I suspect messages are the de morgan dual of objects, but hey
10:57:09 <integral> o_O
10:57:38 <Philippa> think about how you'd type them
10:57:40 <glguy> passing an object a message is like calling a method on that object, but instead of callign a message you just tell the object that you want it to do something and here is the message. it decides what to do with that message
10:57:55 <integral> ah, I see
10:58:03 <glguy> it could pass the message along... call a function
10:58:08 <glguy> ignore it, throw an error
10:58:16 <Philippa> glguy: right, which is why a number of ways of looking at concurrency were OO-influenced
10:58:31 <Codex_> the object parses the message somehow?
10:58:35 <glguy> yeah
10:58:37 <Philippa> pass it along to the superclass...
10:58:47 <integral> Codex_: Have you seen Smalltalk-72?
10:58:53 <Codex_> no
10:59:01 <glguy> the default behavior for unhandled messages is to treat it as an error
10:59:05 <glguy> but you can override that behavior
10:59:30 <integral> Well, it lacks any syntax and just parses the program into a list of symbols,  the first symbol is looked up in the symbol table, and called with the rest of the "message" which it gets to parse
11:01:02 <vincenz> Philippa: you like smalltalk?
11:01:45 <glguy> my problem with objC (in particular Cocoa) was that you just had to know what special messages to handle if you wanted certain behaviors
11:02:18 <glguy> interfaces were implied it seemed
11:02:29 <glguy> (I come from a C# background)
11:02:46 <glguy> originally from a C++ background
11:02:50 <integral> sounds like C# programming is quite different from old-Win32 then :)
11:04:07 <glguy> I like how objC is almost pure C with a little bit of sugar around the message notation
11:04:16 <glguy> and all of the message magic is handled by NSObject
11:04:42 <pejo> glguy, Is it considered a feature to allow unhandled messages?
11:05:00 <glguy> pejo: what do you mean?
11:05:35 <glguy> it is a feature that you can write a proxy class by passing the unhandled messages along or whatnot
11:05:57 <Codex_> it's probably same kind of feature than in haskell you get with pattern matching...
11:06:02 <glguy> there are also messages to see if a function can handle a certain message
11:06:13 <glguy> or an object rather
11:06:46 <pejo> glguy, but the proxy class needs to be aware of the messages it will recieve?
11:06:49 <pierre-> could someone help me with emacs's haskell-mode?
11:07:15 <glguy> pejo: not if the default behavior for unhandled message si to pass them along
11:07:30 <glguy> (default being as defined by the programmer for that object)
11:08:11 <pierre-> i enabled indentation in .emacs, but i can't see any automatic indentation
11:21:19 <marcot> Hello there.
11:21:36 <marcot> I'm getting an very strange error in haskelldb with calendartime:
11:21:51 <marcot> Couldn't match `e System.Time.CalendarTime' against `System.Time.CalendarTime'
11:22:12 <marcot> What is "e System.Time.CalendarTime"?
11:22:40 <Lemmih> A CalendarTime in some kind of container?
11:23:04 * shapr hugs Lemmih 
11:23:20 <Igloo> Does haskelldb do nasty things like look at representations of types as strings?
11:24:35 <marcot> I think it does, if I get what you mean.
11:25:57 * Igloo would guess it's getting it wrong due to extra parens appearing or something then, but I'm just guessing
11:26:27 <glguy> Does anyone know of a webfacing HAppS application?
11:26:41 * Lemmih hugs shapr in return.
11:26:43 <marcot> Igloo: where can I paste?
11:26:50 <glguy> ?paste
11:26:51 <lambdabot> http://paste.lisp.org/new/haskell
11:27:43 <lisppaste2> marcot pasted "haskelldb + calendartime" at http://paste.lisp.org/display/26731
11:27:50 <Lemmih> shapr: I've been playing with the thought of au pair programming. Know of any food-for-programming initiatives? (:
11:28:33 <Igloo> Is that intentionally punning on "pair programming"?
11:29:01 * glguy figures he means au pair in the "nanny" sense
11:30:10 <Lemmih> Igloo: Completely unintentional.
11:30:21 <marcot> Igloo: what is pair programming?
11:30:40 <Igloo> 2 people, one PC, basically
11:30:45 <marcot> hum...
11:31:04 <gour> marcot: programming for the poor :-)
11:31:16 <marcot> Any ideas about the CalendarTime thing?
11:31:37 <Igloo> The idea being you'll get better code as a result of critical feedback from the person not at the keyboard
11:31:50 <Igloo> What CalendarTime thing?
11:31:57 <Igloo> Oh, that one
11:32:00 <marcot> hehehe
11:32:20 <marcot> Yeah, I've done some pair programming, it's kind of nice because you don't feel alone.
11:32:34 * Igloo mentally filtered out the bottalk  :-)
11:33:10 * Igloo has no idea about it, I've never even used haskelldb
11:33:26 <fasta> words = sepBy (parens word<|>word) (skipMany1 space)
11:33:42 <fasta>  run (do words;space) "ds dsd dsds "
11:33:49 <Igloo> I've done it ad-hocly a bit. I never know if my constant pedantry is just irritating the other person, though
11:33:52 <fasta> *** Exception: (line 1, column 13):
11:33:52 <fasta> unexpected end of input
11:33:53 <fasta> expecting space, "(" or letter or digit
11:34:12 <fasta> I can't explain this behaviour.
11:34:33 <fasta> Can you?
11:35:52 <marcot> Igloo: thanks for looking. =D
11:36:17 <musasabi> glguy: happs.org?
11:37:08 <ohub>  
11:39:37 <ski> fasta : seems like 'sepBy' commits to each separator
11:40:09 <fasta> ski: the separator is the second argument, right?
11:40:44 <fasta> ski: in that case I would expect that the last space is _not_ consumed by words
11:41:15 <ski> but that's what seems to be happening
11:41:49 <fasta> ski: right, but why? That's not according to specs. I could be wrong of course.
11:42:26 <fasta> ski: hmm, I think I understand.
11:43:01 <fasta> ski: In the special case where separator is the same as the "successor" parser, you have a problem
11:43:08 <vincenz> re
11:43:10 <fasta> ski: thanks for your input
11:43:11 <vincenz> :)
11:44:56 <ski> fasta : i'm not sure it's in accord with spec, either ..
11:45:44 <fasta> ski: ah, well, buggy software.. like we didn't have enough of that already...
11:47:24 <lightstep> what is a perfunctor?
11:47:38 <fasta> Are there any other parse libraries that have had some real-world use?
11:47:47 <vincenz> HOLY CRAP
11:47:52 <vincenz> 160 Mpixel camera
11:48:06 <glguy> why does perfunctor keep coming up today?
11:48:24 <lightstep> glguy, recent changes on hawiki
11:54:09 <therp> ok, there is a slight chance that there are readers of "the essence of functional programming" in this channel http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps . isn't the bindP definition on page 7 incorrectly chaining the error monad with the position monad? that is "k x p" should be "k p x", no?
11:54:13 <lambdabot> http://tinyurl.com/gpztv
11:58:37 <ski> therp : no
11:59:05 <ski> bindP :: P a -> (a -> P b) -> P b
11:59:35 <ski> bindP :: (Position -> E a) -> (a -> Position -> E b) -> Position -> E b
11:59:41 <ski> so
11:59:46 <ski> k :: a -> Position -> E b
11:59:52 <ski> x :: a
11:59:55 <ski> p :: Position
12:00:03 <ski> k x p :: E b
12:01:52 <ski> therp : clear ?
12:02:49 <therp> ski: yes thank you. my delayed response was because I was trying to convince my intution that your arguments are conclusive
12:03:23 <ski> (:
12:03:51 <therp> it was just unnatural to me that obviously the last term yields an E b, and not P b, but I obviously missed that the whole expression is in \p, so that makes it Position -> E b, which is exactly P b
12:04:10 <ski> indeed
12:04:30 <therp> ski: thanks for your explaination
12:04:39 <ski> yw
12:05:32 <newbcoder> I want a list of papers to read to understand monads
12:05:37 <newbcoder> not just for IO
12:05:41 <newbcoder> fbut monads in general
12:05:47 <therp> newbcoder: monads page in the haskell wiki
12:05:49 <newbcoder> I have come to the concluysion that monads rock and want to learn them
12:05:57 <shapr> http://www.nomaware.com/monads/html/index.html
12:06:00 <Philippa> for values of general that still mean "in haskell" or "in functional programming", right? :-)
12:06:03 <newbcoder> whereis the wiki?
12:06:03 <lambdabot> Title: All About Monads, http://tinyurl.com/hx34v
12:06:13 <newbcoder> Philippa, functional programming in general
12:06:41 <newbcoder> is there a way to print All About Monads as a single file?
12:07:01 <therp> newbcoder: http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows - I liked most of the wadler papers about monads
12:07:04 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
12:08:15 <therp> newbcoder: but the papers are a bit rough if you are not so experienced with haskell (that is lambda and types)
12:08:33 <therp> in fact I'm reading the essence of functional programming right now
12:09:06 <newbcoder> err. wtf are arrows?
12:09:29 <glguy> ?instances Arrow
12:09:30 <lambdabot> (->), Kleisli m
12:09:40 <integral> they're really, really complicated :-/
12:09:44 <newbcoder> that explains nothing to me
12:10:01 <glguy> it gives you examples of things that are arrows :)
12:10:09 <sjanssen> newbcoder: structures are akin to Monads, but much more obscure
12:10:24 <shapr> Hey, I don't think arrows are complicated or obscure!
12:10:27 <sjanssen> s/structures are/structures at are
12:10:31 <sjanssen> that are
12:10:40 <newbcoder> shapr explain them to me pls
12:10:58 <newbcoder> btw, is there a pdf/ps of http://www.nomaware.com/monads/html/index.html ? i wnat to print it out; not read it on the screen
12:10:59 <lambdabot> Title: All About Monads, http://tinyurl.com/hx34v
12:11:01 <shapr> Especially since the paper that swiert found that points out that arrows are closely related to monads.
12:11:20 <therp> newbcoder: I tried to htmldoc it but without much success
12:11:34 <integral> shapr: relating in what way?
12:11:35 <Igloo> What happened with http://www.haskell.org/hawiki/AlgorithmCorner ?
12:11:36 <lambdabot> Title: AlgorithmCorner - The Haskell Wiki
12:12:00 <shapr> newbcoder: I don't have time right now, I need to go to the post office. But monads are simple and arrows aren't much more.
12:12:13 <glguy> > ((*2) ^>> (+1)) 3
12:12:14 <lambdabot>  7
12:12:25 <newbcoder> 2>> is an arrow?
12:12:32 <shapr> newbcoder: Will you be on #haskell several hours from now?
12:12:39 <newbcoder> I'll be back in 5 hours
12:12:41 * Igloo prods shapr, guardian of the wikis
12:12:43 <shapr> Ok, cool.
12:12:46 <sjanssen> newbcoder: (->) is an arrow
12:12:50 <shapr> Igloo: I'm only hawiki guardian.
12:12:53 <newbcoder> shapr: cool; see you then
12:13:06 <Igloo> shapr: That's OK, I'm asking about hawiki  :-)
12:13:18 <swiert> newbcoder: arrows and monads are both monoids, only in different categories.
12:13:28 <swiert> that's the one line summary of the paper at least.
12:13:31 <zzctb> hi, im trying to convert a list to a string. any advice/hits? thanks.
12:13:44 * shapr gives swiert a golden lambda for that one line explanation.
12:13:53 <shapr> @karma+ swiert -- for finding cool papers
12:13:55 <lambdabot> swiert's karma raised to 1.
12:14:01 <shapr> @karma+ swiert -- for volunteering to help with TMR
12:14:02 <lambdabot> swiert's karma raised to 2.
12:14:08 <defcon8> who can describe what a monad is in one line?
12:14:08 <glguy> Monoids are things that can be meaningfully appended, and have an append identity
12:14:31 <swiert> shapr: good point. I was just writing Andres an e-mail to ask for his latex style files.
12:14:33 <shapr> defcon8: A monad is a way to turn the meaning of a type into a pipeline with the same meaning.
12:14:42 <glguy> for arrows, that appending is function composition (I believe) and that append identity is "id"
12:14:56 <Philippa> defcon8: a monoid object in an endofunctor category
12:15:01 * defcon8 is still nonplussed
12:15:07 <Philippa> not that that'll help you much
12:15:07 * shapr quickly plusses defcon8 
12:15:27 <defcon8> is it one of those "we'll tell you when you're older" type questions where you wouldn't understand at the time?
12:15:32 <swiert> glguy: it's a bit more complicated than that...
12:15:38 <shapr> defcon8, newbcoder: ok, I'll give you the short & sweet intro to monads if you have ten minutes
12:15:39 <glguy> swiert: go on
12:15:48 <defcon8> yes, please
12:16:08 <defcon8> can we do this in a separate channel?
12:16:08 <Philippa> swiert: know where the paper is? I could probably use reading it
12:16:09 <Bourbaki> moin
12:16:11 <defcon8> #monads
12:16:17 <defcon8> ?
12:16:30 <shapr> defcon8: It's probably easier to do it here because then others can jump in and continue when I have to go.
12:16:38 <defcon8> okay
12:16:51 <shapr> Have you already ready All About Monads?
12:17:00 <defcon8> no
12:17:07 <shapr> Well, I'm just parroting what it says mostly.
12:17:11 <defcon8> I read on wikipedia
12:17:15 <defcon8> I didn't get it
12:17:17 <shapr> But we can start with the Maybe datatype.
12:17:35 <swiert> glguy: Ok. If you look at the category of functors : C -> C (aka the endofunctors), monads are simply a monoidal structure in this category.
12:17:37 <shapr> defcon8: You know how to define the Maybe type? and do you know what it represents?
12:17:48 <defcon8> no
12:17:56 <defcon8> I'm quite new to haskell
12:17:56 <shapr> data Maybe a = Nothing | Just a
12:18:14 <swiert> Philippa: http://chris.chris-lotte.net/publications/2006/arrows/arrows.pdf
12:18:17 <lambdabot> http://tinyurl.com/jjvpp
12:18:19 <shapr> That's a way to represent a result with "Just a" or a failure with "Nothing"
12:18:27 <shapr> defcon8: Is that clear?
12:18:30 <glguy> swiert: I was under the impression that when a Monad was a Monoid, it implemented MonadPlus
12:18:41 <defcon8> okay then
12:18:47 <defcon8> is Just part of the syntax/
12:18:57 <swiert> glguy: MonadPlus doesn't have a very nice categorical counterpart.
12:19:06 <shapr> It's a constructor. You need to know basic Haskell to understand the explanation.
12:19:14 <defcon8> okay then
12:19:17 <defcon8> I'll learn a bit more first
12:19:21 <shapr> Have you written any Haskell yet?
12:19:25 <defcon8> yes
12:19:30 <defcon8> what I tried to write didn't really work
12:19:34 <shapr> Have you defined any datatypes?
12:19:37 <defcon8> though it should and I'm blaming the compiler
12:19:38 <defcon8> no
12:20:05 <swiert> glguy: Consider Id -> F <- F . F a little diagram in the category of endofunctors.
12:20:14 <shapr> @oldwiki HaskellDemo
12:20:16 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
12:20:21 <shapr> defcon8: You may want to read that page.
12:20:29 <swiert> Id is the identity functor. F some functor C -> C.
12:20:52 <swiert> If F is a monad, this looks awfully similar to return and join.
12:21:00 <kosmikus> swiert, shapr: www.iai.uni-bonn.de/~loeh/TMR/TMR.tar.gz
12:21:14 <swiert> In fact, the monad laws follow naturally from requiring that this is indeed a monoid.
12:21:20 <shapr> kosmikus: thanks!
12:21:48 <shapr> kosmikus: 404?
12:21:55 <rnz`WORK> (breaking news)(ap/reuters) - Iran has launched a nuclear missile into Tel Aviv causing widescale devastation.  Details Soon.
12:21:56 <therp> data Maybe a = Nothing | Just a   ... Maybe is a type constructor, and Nothing and Just are data constructors in this case. Maybe <type> can be used to construct types (Maybe has a kinding * -> *) and Just and Maybe are used to pass around objects that can be passed around at runtime.. (also used in pattern matching as selectors)
12:22:09 <therp> ^^ that was directed to defcon8
12:22:22 <kosmikus> shapr: oh, will fix
12:22:30 <shapr> kosmikus: Oh, I can list the directory.
12:22:36 * edwardk waves hello.
12:22:40 <defcon8> thanks
12:22:50 <shapr> hiya edwardk, how's MI?
12:23:01 <swiert> You can play the same game with arrows, but instead of using the category of endofunctors you need something more involved.
12:23:05 <therp> defcon8: I don't assume you entirely understand my explaination but it certainly help when you encounter terms like type/data constructor in haskell tutorials (that was my problem when learning that stuff, namely no idea of terminology)
12:23:06 <swiert> kosmikus: great thanks.
12:23:12 <kosmikus> shapr: now?
12:23:17 <edwardk> not bad. slowly getting back into the swing of life in non-conference-land ;)
12:23:17 <defcon8> reading the demo atm
12:23:25 <glguy> swiert: I'm still listening (if you wondered)
12:23:33 <shapr> kosmikus: Got it, thanks.
12:24:24 <edwardk> came back and slept, got a whole lot of nothing done over the weekend. Finally seem to have my feet underneath me and am ready to be productive... and discovered I apparently lost my power supply on the return trip via vegas.
12:25:23 <shapr> Yeah, you can lose your shirt in vegas :-)
12:25:27 <swiert> glguy: Anyway, the category you need to use for arrows is C x C^op -> C.
12:25:43 <bartw> edwardk: atleast the spirit is there
12:25:46 <edwardk>  made money, lost a powersupply. worked out =)
12:25:52 <glguy> "Hyghes' Arrows are monoids in categories of bifunctors C^op x C -> C"
12:26:06 <swiert> glguy: Exactly. That's it.
12:26:12 <rnz`WORK> wtf is this channel about
12:26:14 <rnz`WORK> a text based RPG?
12:26:17 <rnz`WORK> arrows and formulas
12:26:20 <rnz`WORK> for % to hit through armor?
12:26:20 <rnz`WORK> heh
12:26:31 --- mode: ChanServ set +o shapr
12:26:34 <glguy> This channel is about the programming language Haskell
12:26:46 <Bourbaki> :)
12:26:48 <rnz`WORK> I see
12:26:56 <Bourbaki> haskell the rpg :)
12:26:56 <swiert> glguy: The unit of the monoid is composition. The binary operation takes all sorts of categorical voodoo that I don't understand.
12:27:11 <rnz`WORK> swiert, it's not voodoo
12:27:15 <rnz`WORK> its real logic that you can't understand yet
12:27:17 <rnz`WORK> hit the books more :)
12:27:34 <shapr> rnz`WORK: Dude, you're not passing a turing test.
12:27:47 <edwardk> heh
12:27:55 <vincenz> shapr: what's with the @
12:27:59 <Bourbaki> i bet no human would
12:28:06 <shapr> vincenz: look at the scrollback
12:28:12 <Bourbaki> that is  ifyou take the average conversation at least
12:28:20 <rnz`WORK> swiert
12:28:22 <vincenz> shapr: I /ignore all non msg/action/pub messges
12:28:24 <rnz`WORK> you would like the writing:
12:28:27 <rnz`WORK> www.thegodtheory.com
12:28:33 <shapr> rnz`WORK: Do you want to learn about the programming language Haskell?
12:28:42 <shapr> rnz`WORK: off-topic conversation should be taken to #haskell-blah
12:28:45 <rnz`WORK> All i do is manage routers all day
12:28:47 <rnz`WORK> what would this help me
12:28:50 <vincenz> shapr: or no kick/ban has bene performed yet?
12:28:51 <rnz`WORK> Im studying for ccie in voice
12:28:55 <shapr> vincenz: That's correct.
12:29:11 <shapr> vincenz: The halo of kicking was a hint.
12:29:24 <rnz`WORK> shapr, that shows you are concerned with "epeen"
12:29:26 <rnz`WORK> lol
12:29:27 * rnz`WORK waits
12:29:32 <shapr> rnz`WORK: If you're not interested in learning Haskell, please leave.
12:29:36 <edwardk> i passed the writtens for the ccie and ccie/wan then my employer stopped paying for my certs. bastards ;)
12:29:37 <lispy> let's say i have foo :: State Int (), is there a way to get the Int value?
12:29:37 --- mode: ChanServ set +o vincenz
12:29:39 <rnz`WORK> Isn't haskell a car race
12:29:41 <vincenz> shapr: two halos?
12:29:42 <rnz`WORK> or horse race
12:29:43 <rnz`WORK> :)
12:29:47 <lispy> (I mean after the work is done)
12:29:48 <rnz`WORK> final word IMO :)
12:29:52 <edwardk> er. back in the day when there was a separate ccie/wan for their stratacom hardware
12:30:11 <glguy> man, you guys are crazy patient with assclowns
12:30:13 <shapr> He was just trying to distract people and get some free attention.
12:30:18 <shapr> glguy: It works.
12:30:33 <shapr> glguy: They want strong reactions, they want to polarize the discussion.
12:30:39 <edwardk> *nods*
12:30:47 <vincenz> besides, you never know if they're trolls or just shapr-clones
12:30:52 * vincenz coughs and flees
12:30:53 <edwardk> @photontorpedo
12:30:54 <lambdabot> why haskell over say smalltalk
12:30:56 <shapr> Being nice to them lowers the emotional temperature.
12:31:10 <glguy> I think I was there when most of phototorpedo's quotes were recorded
12:31:12 --- mode: vincenz set -o vincenz
12:31:14 <fasta> @photontorpedo
12:31:14 <lambdabot> I personally emailed paul graham the lisp guy today after reading about python in E raymonds essay he metions ruby n python is u cant use lisp
12:31:16 --- mode: shapr set -o shapr
12:31:20 * shapr hugs vincenz 
12:31:27 <vincenz> :)
12:31:40 <ventonegro> @index HasBounds
12:31:41 <vincenz> shapr++
12:31:42 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
12:32:00 <vincenz> shapr: did you often work with ajax and such for webdev
12:32:02 <vincenz> ?
12:32:03 <glguy> I was pretty impressed that no one even blinked at his Iran message
12:32:20 <shapr> glguy: That was the point, he was trying to get attention and stir up excitement.
12:32:36 <glguy> Yep, which is why I (and apparently everyone else) ignored it
12:32:54 <shapr> Once he got ignored long enough he made significantly more crude approaches to getting attention.
12:33:16 <vincenz> shapr: heh, I wonder about some people and what drives them
12:33:17 <shapr> I could have told him that it's very easy to get attention on #haskell, just write cool code.
12:33:23 <vincenz> shapr: like the guy that keeps spamming my guestbook with empty messages
12:33:54 <vincenz> shapr: anyways, did oyu ever work with ajax on your web-projects?
12:34:01 <shapr> Somewhat, why?
12:34:19 <vincenz> shapr: well for this project which I think would be useful to most #haskell'ers but requires other capabilities
12:34:29 <vincenz> shapr: let me fetch yuo a link, maybe you have some ideas
12:34:32 <shapr> ok
12:34:40 * shapr really has to go to the post office
12:34:45 <vincenz> http://notvincenz.blogspot.com/2006/09/organizing-information.html
12:34:48 <lambdabot> Title: lambda.oasis: Organizing information, http://tinyurl.com/e5hv4
12:34:50 <vincenz> well look at it later then :P
12:35:02 <glguy> is the limit of the area of serpenski's triangle as the number of iterations approaches infinity zero?
12:36:29 <lispy> ah, is execState what I want?
12:36:32 <lispy> ?hoogle execState
12:36:33 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
12:36:33 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m s
12:37:05 <glguy> lispy: it is if you want the resulting state
12:37:07 <lispy> > execState ((put 1) :: State Int ()) 0
12:37:07 <vincenz> lispy: evalstate?
12:37:08 <lambdabot>  1
12:37:18 <dolio> glguy: That sounds right, off the top of my head.
12:37:20 <lispy> execState is exactly what i want
12:37:37 <vincenz> execstate is completely subsumed by evalstate
12:37:48 <glguy> you mean runStaet?
12:37:49 <vincenz> execstate action 0 = evalstate (action >> get) 0
12:37:52 <glguy> runState?
12:37:55 <vincenz> evalState
12:38:01 <vincenz> @type evalState
12:38:01 <lispy> ?type evalState
12:38:02 <lambdabot> forall a s. State s a -> s -> a
12:38:03 <glguy> ah
12:38:03 <lambdabot> forall a s. State s a -> s -> a
12:38:09 <glguy> I see what you are saying
12:38:18 <vincenz> evalState (return 1) (0 :: Int)
12:38:22 <lispy> vincenz: but, i don't care about the a in this case, so  i might as well use execState
12:38:23 <edwardk> glguy: sounds right, its a 2d cantor's dust analog
12:38:43 <glguy> > evalState(put 1; get) 0
12:38:43 <lambdabot>  Parse error
12:38:44 <vincenz> lispy: true, but just that you can do the same with >> get
12:38:49 <glguy> > evalState (put 1>> get) 0
12:38:51 <lambdabot>  1
12:39:02 <lispy> vincenz: ah
12:39:14 <vincenz> the a of get is s
12:39:16 <vincenz> @type get
12:39:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
12:39:44 <vincenz> but yeah, I was just being annoying :)
12:39:55 <vincenz> execState states more clearly you want the final state :P
12:39:58 <glguy> vincenz: which would you suppose is better style?
12:40:08 <vincenz> the one lispy chose
12:40:28 <glguy> typically when you just want the state, what you are doing is function composition, right?
12:41:05 <vincenz> not quite
12:41:13 <vincenz> well yes, you're always doing that
12:41:18 <vincenz> just that it's easier sometimes to use a state
12:41:24 <glguy> sure
12:41:25 <vincenz> imagine something that recurses down an AST
12:41:28 <vincenz> and counts some conditions
12:41:34 <vincenz> you'd have to thread the state along your AST
12:41:48 <lispy> in my case, i have to parse a an arbitrary permutation (and arbitrary subset) of some columns.  I have a record setup that takes Maybe foo for each field.
12:42:11 <lispy> this way I can find out what subset i'm parsing, then call my parsers and keep updating the record
12:42:21 <glguy> vincenz: I was just thinking that for simple cases that the following could be better:
12:42:23 <lispy> accumulating the record in the state
12:42:33 <glguy> > sequence [ord, (+1), chr] 'a'
12:42:34 <lambdabot>  Couldn't match `Int' against `Char'
12:42:43 <glguy> > sequence [chr, (+1), ord] 'a'
12:42:44 <lambdabot>  Couldn't match `Char' against `Int'
12:42:47 <glguy> oh well
12:42:52 <glguy> i guess I'm screwing something up
12:43:15 <sjanssen> @type (chr, (+1), ord)
12:43:17 <lambdabot> forall a. (Num a) => (Int -> Char, a -> a, Char -> Int)
12:43:25 <glguy> bah, i know what I was doing
12:43:33 <glguy> > sequence [(+1),(-1)] 5
12:43:34 <lambdabot>  add an instance declaration for (Num (a -> a))
12:43:34 <lambdabot>   In the list element: (- 1)
12:43:40 <glguy> > sequence [(+1),(+(-1))] 5
12:43:41 <lambdabot>  [6,4]
12:43:48 <glguy> I think I want:
12:43:52 <vincenz> Anyone familiar with webprogramming?
12:43:59 <glguy> > foldM [(*2),(+1)] 4
12:43:59 <lambdabot>  Couldn't match `a -> b -> m a' against `[a1]'
12:44:01 <edwardk> vincenz: unfortunately, yes :)
12:44:08 <glguy> ?type foldM
12:44:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:44:18 <vincenz> edwardk: what do you use?
12:44:38 <vincenz> what framework
12:44:53 <edwardk> vincenz: I think I've written stuff for the web in just about everything. ;) Personally? I use cocoon for most of my web development stuff.
12:45:14 <vincenz> oy, java
12:45:22 <vincenz> a bit too heavyweight for my taste
12:45:24 <edwardk> For work, I use coldfusion (gag me). I use perl for some stuff
12:45:31 <edwardk> I used to use perl for everything
12:45:37 <vincenz> perl is not a framework
12:45:40 <edwardk> Well. cocoon gives you a lot of bang for your buck.
12:45:48 <edwardk> vincenz: well. sort of. CPAN is ;)
12:45:52 <vincenz> at that rate I could just code it in haskell
12:46:00 <vincenz> edwardk: no it is not a framework, it's a language with libraries
12:46:05 <edwardk> vincenz: cabal != cpan
12:46:11 <vincenz> right
12:46:17 <vincenz> but perl+cpan != seaside, continue or RoR
12:46:19 <edwardk> vincenz: sure. but most frameworks suck ass :)
12:46:23 <vincenz> ...
12:46:30 <vincenz> thank you for that objective input
12:46:41 <edwardk> heh
12:46:57 <edwardk> hey its as objective as I can be
12:47:25 <lispy> hmm..Control.Monad.State has been moved in ghc6.6+
12:47:26 <lispy> ?
12:47:29 <edwardk> cocoon is the only framework that hasn't made me want to claw my eyes out after using
12:47:30 <vincenz> look, if I'm just gonna use some random language with standard libraries, I might as well go for gtk2hs and haskell, and that's already painful enough for what I want to do.
12:47:33 <zzctb> mason and catalyst are pretty popular perl frameworks
12:47:34 <lispy> ?hoogle State
12:47:35 <lambdabot> Control.Monad.State :: module
12:47:35 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
12:47:35 <lambdabot> Control.Monad.State.State :: newtype State s a
12:47:41 <vincenz> and since it's going to be a single-user webframework on the pc, java is too slow
12:47:44 <edwardk> vincenz: well, whats the application?
12:47:51 <vincenz> the one mentioned in my blog
12:47:57 <lightstep> isn't monadLib preferred to mtl now?
12:48:00 <edwardk> vincenz: that sets a lot of the tone for what is an appropriate environment
12:48:00 <lispy> Control.Monad.State is not right for me...
12:48:08 <edwardk> www.notvincenz.com ?
12:48:11 <vincenz> the idea is responsiveness and a lot of gui
12:48:13 * glguy finally figured out what he was doing
12:48:14 <glguy> > foldl (.) id [(*2),(+1)] 4
12:48:15 <vincenz> notvincenz.blogspot.com
12:48:15 <lambdabot>  10
12:48:28 <vincenz> notvincenz.com is gonna get killed soon, someone keeps hacking it
12:48:50 <lispy> lightstep: how do i import that?
12:48:57 <edwardk> so you want to write a paper organizing tool?
12:49:06 <vincenz> paper/website/notes
12:49:07 <vincenz> yes
12:49:12 <edwardk> have you tried citeulike?
12:49:18 <vincenz> have you read why I can not use that?
12:49:24 <edwardk> checking
12:49:26 <edwardk> =)
12:49:34 <vincenz> I replied to your message concerning that
12:49:39 <vincenz> the problem is that some papers are confidential
12:49:49 <vincenz> not to mention that it's hardly portable if I'm moving around with my lappy and paper collection
12:49:56 <edwardk> *nods*
12:50:00 <lispy> oh, just adding mtl to my cabal fixed it
12:50:21 <vincenz> the only reason I'm still going for a webframework is because I have a hunch that ajax might be easier than standalone gui libs
12:50:46 <edwardk> guess i'd probably just use one of my golden hammers and throw a tiddlywiki at it. tag all the papers in the tiddly, then you can carry it around with you on a thumbdrive or what not. self contained that way
12:51:10 <edwardk> easy to use, no real maintenance issues
12:51:16 <edwardk> nothing to write really
12:51:17 * vincenz nods
12:51:49 <vincenz> I admit I was hoping for something flashier, so I can have a nice graphic overview of tags
12:51:56 <vincenz> :P
12:52:06 <edwardk> well, grab a tagcloud macro for the tiddly ;)
12:52:34 <vincenz> nono, something fancy, like what's the word for that, elastic 2d graph
12:52:42 <edwardk> it just seems like a good 80/20 rule application ;)
12:52:50 <edwardk> graphviz?
12:53:01 <vincenz> something like that yes
12:53:19 <vincenz> maybe more like some topic maps some news-sites have
12:53:29 <edwardk> heh http://dean.edwards.name/space maybe? =)
12:53:30 <vincenz> but yes, the 80% of the application is fluff
12:53:33 <lambdabot> Title: dean.edwards.name/space
12:53:43 <vincenz> there's little copelxity to it
12:53:48 <edwardk> *nods*
12:53:57 <vincenz> something like that
12:54:07 <vincenz> it's mostly a lot of fluff coding to get a nice usability
12:54:25 <vincenz> which makes it less appealing to write :/
12:54:25 * edwardk is lazy.
12:54:32 * vincenz is too
12:55:35 <edwardk> I base what I want to write based on the ratio of time saved using to time writing and how much I'll learn. Found few web apps for personal needs worth writing under that equation ;)
12:56:24 <lightstep> @where monadLib
12:56:25 <lambdabot> I know nothing about monadlib.
12:56:30 <edwardk> what is stopping you from using something like *gag* excel? =)
12:56:43 <lightstep> @where+ monadLib http://www.cse.ogi.edu/~diatchki/monadLib/
12:56:44 <lambdabot> Done.
12:57:04 <lightstep> it has cabal, iiirc
12:57:22 <vincenz> edwardk: I think you're missiing the purpose
12:57:49 <edwardk> probably, but it has all the data collection stuff built in and you can appeal to visual basic for any more robust visualization tools.
12:59:34 <lispy> lightstep: do you remember why it's prefered?
13:00:31 <edwardk> heck, access even. this is the kind of app those were made for ;)
13:01:13 * edwardk skirts dangerously close to being banned naming two microsoft products in a positive light within 5 minutes of each other
13:01:28 <lispy> o_O
13:01:32 <lispy> edwardk: better check yourself ;)
13:01:34 <fasta> > let a = id a in a
13:01:34 <edwardk> heh
13:01:35 <lambdabot>  Add a type signature
13:01:47 <edwardk> I might have a fever ;)
13:01:48 <glguy> I'll be banned after my response if you are banned for that, considering the tolerance shown to the trolls ;)
13:01:53 <lightstep> i saw some discussion about it long ago, and many people supported it. i don't remember where, though
13:01:55 <fasta> That expression works in my version of GHC.
13:01:56 <edwardk> hehehe
13:02:32 <lightstep> monadLib has more monads and combinators, and it's classes are cleaner
13:02:44 <lightstep> *its
13:02:46 <glguy> ?whre monadLib
13:02:47 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
13:02:56 <lispy> lightstep: mmm...interesting
13:03:34 <lightstep> but if you want to integrate with mtl code, this won't help you
13:04:00 <fasta> > let a=[1,2,3] in let b = nub (b++a) in b
13:04:01 <lambdabot>  Exception: <<loop>>
13:04:26 <fasta> lambdabot is more intelligent than my GHC, does it just parse Stack Overflow?
13:05:02 * fasta would like that the compiler warns against such uses.... 
13:05:03 <int-e> lambdabot compiles its code.
13:05:04 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
13:05:12 <glguy> fasta: that couldn't work because the first element of the agument of nub is it's first result
13:05:22 <ventonegro> argh
13:05:29 <ventonegro> can't build HAppS
13:05:38 * glguy just built it before lunch
13:05:38 <musasabi> ventonegro: which version?
13:05:43 <ventonegro> 0.8
13:05:48 <fasta> glguy: how do you mean it can't work? It works on my machine?
13:05:53 <musasabi> http://happs.org/auto/HAppS-0.8.2.tar.gz
13:05:55 <ventonegro> "Could not find module `Data.FastPackedString':"
13:06:02 <fasta> glguy: I made this example on purpose to show a weakness.
13:06:05 <musasabi> ventonegro: fun with fps versioning.
13:06:37 <ventonegro> musasabi, thanks :-)
13:06:43 <glguy> fasta: it is correct for the code that you pasted to fail, what are you trying to demonstrate?
13:07:16 <fasta> glguy: I demonstrate that this code should never be alowed to run in ghci.
13:07:39 <fasta> allowed, even
13:07:44 <ventonegro> heh
13:07:55 <glguy> you mean an error should display instead of running indefinitely?
13:07:55 <ventonegro> and where do I get fps 0.8? :-)
13:08:02 <glguy> ventonegro: darcs
13:08:30 <vegai> musasabi: are you tracking ghc-6.6 with HAppS?
13:08:48 <fasta> glguy: an error before running should say: "Dear user you are defining this term but it directly depends on itself. This result in bottom. So, dear user. Don't do that!"
13:08:51 <ventonegro> glguy, thanks
13:09:01 <fasta> results, even
13:09:06 <glguy> fasta: it is not always incorrect to use the result in the arguments
13:09:07 <_Stinger_> whats nub do?
13:09:16 <glguy> _Stinger_: returns a list of unique elements
13:09:28 <fasta> glguy: give an example which is similar to mine.
13:09:41 <sjanssen> fasta: I'm sure that GHC HQ would accept the patch if you implemented such a feature ;)
13:09:46 <glguy> http://www.haskell.org/hawiki/TyingTheKnot
13:09:47 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
13:09:59 <fasta> glguy: tying the knot is different
13:10:08 <glguy> fasta: go on
13:10:37 <JohnyS> hello everyone
13:10:51 <JohnyS> can someone help me fix some code
13:11:07 <JohnyS> I keep getting a Last generator in do {...} must be an expression
13:11:12 <musasabi> vegai: yes. The darcs version works nicely with HEAD>
13:11:22 <JohnyS> anyone have any idea why this might be happening
13:11:23 <int-e> > do x <- [1,2,3]
13:11:24 <lambdabot>  Parse error
13:11:28 <ventonegro> what happens if I install fps 0.8 over 0.7?
13:11:29 <int-e> > do x <- [1,2,3]; return x
13:11:31 <lambdabot>  [1,2,3]
13:11:31 <vegai> musasabi: Ok. I'll give that a shot.
13:11:40 <ventonegro> should I uninstall first?
13:11:43 <musasabi> vegai: just use cabal.ghc66
13:11:47 <lisppaste2> Johnny pasted "Partially Fixed code" at http://paste.lisp.org/display/26742
13:11:55 <vegai> mmkay.
13:12:06 <int-e> JohnyS: the last line in that do block is of the form 'var <- expression' while it should be of the form 'expression' (maybe 'return (expression)')
13:12:48 <int-e> JohnyS: in cod4, the return isn't properly indented
13:12:56 <fasta> glguy: In my example it's easy to detect a real cycle. In tying the knot such a cycle is always broken in some way.
13:13:08 <JohnyS> ahhh ty
13:13:19 <glguy> fasta: what about things like:
13:13:26 <glguy> > let ones = 1 : ones in take 10 ones
13:13:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
13:13:29 <musasabi> It would be nice to have a common cabal file, but unfortunately it is not possible with current Cabal limitations.
13:13:37 <int-e> JohnyS: actually ... the 'digit' above that isn't properly indented either. it should line up with the dde
13:14:17 <sjanssen> fasta: you do know that GHC can catch certain cases like this at runtime, right?
13:14:19 <lightstep> JohnyS, using `do' inside a `do' doesn't mean anything. you can just leave out the internal `do's
13:14:22 <glguy> > let b = b in b :: ()
13:14:23 <lambdabot>  Exception: <<loop>>
13:14:46 <fasta> sjanssen: my GHC didn't catch this one.
13:14:51 <int-e> JohnyS: and code5 just has too many 'do's
13:14:54 <fasta> sjanssen: but no, I didn't know that.
13:15:15 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in join $ transpose [odds,evens]
13:15:16 <sjanssen> fasta: if you tried it in ghci, did you try putting it in a source file and compiling it?
13:15:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:15:18 <fasta> glguy: in that case a value in being produced.
13:15:26 <int-e> JohnyS: you can leave out the 'xxx <- ' part if you're not going to use that value, btw.
13:15:29 <glguy> fasta: some cases might be the equivalent of the halting problem
13:15:39 <fasta> glguy: true
13:15:40 <glguy> fasta: you can't always know that it will not halt
13:15:50 <JohnyS> wow!!! that is a lot
13:16:07 <fasta> glguy: there are simpler things one could do. I guess it's just not that important.
13:16:33 <glguy> fasta: I don't actually know how they determine <<loop>> I'm just guessing
13:17:00 <lispy> > fix (+1) :: Integer
13:17:01 <lambdabot>  Exception: <<loop>>
13:17:37 <fasta> glguy: I think there's a whole sport for detecting those things, of which they probably use the simpler methods.
13:18:41 <glguy> fasta: my assumption was that there was a flag on each thunk and says whether evaluation of it has been attempted
13:18:59 <glguy> and if this flag is set when the value is queried again, that a loop occurs
13:19:40 <sjanssen> glguy: that is exactly how it works, if I remember correctly
13:20:47 <sjanssen> I seem to remember that you get the loop detection for free as a consequence of how GHC does heap updates in thunks
13:20:58 <glguy> > let b = sort b in b
13:20:59 <lambdabot>  Add a type signature
13:21:03 <glguy> > let b = sort b in b :: [()]
13:21:04 <lambdabot>  Exception: <<loop>>
13:21:20 <glguy> on hugs that generates a C stack overflow
13:22:20 <JohnyS> just a qick question but is there anyway to translate haskell code to an imperitive language like C?
13:22:38 <Binkley> johnys: yes, it's called GHC
13:23:01 <sjanssen> JohnyS: it isn't pretty C code though
13:23:14 <glguy> more importantly, what do you need?
13:23:23 <glguy> are you just asking if what haskell does can be expressed in C?
13:23:29 <JohnyS> C code is c code
13:23:34 <Binkley> if you want code that a human could read, though, you're not exactly in luck
13:23:37 <JohnyS> i just cant get my head round to haskell
13:23:53 <glguy> JohnyS: then you really won't understand Haskell code compiled to C code
13:23:54 <xerox> My computer science prof http://www.di.unito.it/~stefano/picture_big2006.jpg O_o
13:23:57 <lambdabot> http://tinyurl.com/jdlyy
13:23:59 <Binkley> then the answer is to forget everything you ever knew about C, not to translate haskell to C
13:24:22 <dolio> That's a lot of meat.
13:24:22 <JohnyS> lol all this to finish a game
13:24:30 <sjanssen> mmm, meat
13:25:00 <JohnyS> anyone ever played mod-x around here?
13:25:05 <sjanssen> xerox: it's good that he has a second mug next to his plate, just in case
13:25:15 <xerox> sjanssen: you know what's even better?
13:25:43 <sjanssen> do tell
13:25:44 <xerox> From his homepage http://www.di.unito.it/~stefano/ ``Interests:
13:25:45 <xerox>  * Type Theory, Lambda Calculus and Program Transformation
13:25:45 <xerox>  * Logic and Proof Theory''
13:25:47 <lambdabot> Title: Semantics and Logics of Computation group's (University of Turin) - People - Dip ...
13:25:49 <pejo> Binkley, people usually learn by relating the new stuff to things they already know.
13:26:26 <Binkley> well, I knew C before I learned Haskell, and it didn't help
13:26:29 <xerox> And he has got to teach us C :(
13:26:56 <glguy> Haskell makes you look at problems differently than you do in C
13:27:04 <_Stinger_> I knew some scheme, and it sort of helped, but then there was monads :)
13:27:05 <glguy> trying to fit Haskell into a C model will just make it harder
13:27:10 * xerox closes his hears
13:27:26 <JohnyS> ok just a general question but where you really use a functional language?
13:27:40 <Binkley> depends what you mean by "you"
13:27:53 <jajs> For example, in a compiler ?
13:27:54 <JohnyS> ok let me rephrase that
13:28:14 <JohnyS> when is a functional language better that an imperitive lang
13:28:20 <_Stinger_> tsk tsk
13:28:23 <dolio> Heh.
13:28:29 <_Stinger_> asking that in a haskell chan :)
13:28:29 <Binkley> the people on this channel would probably say "always"
13:28:33 <JohnyS> lol
13:28:36 <JohnyS> thought so
13:28:39 <astrolabe> I think whenever speed is not the crucial factor
13:28:41 <Binkley> but functional languages tend to be better whenever you need strong static guarantees about program properties
13:28:45 <Binkley> and when performance isn't crucial
13:28:48 <Binkley> though that's changing
13:28:48 <pejo> JohnyS, http://labs.google.com/papers/mapreduce.html
13:28:49 <lambdabot> Title: Google Research Publication: MapReduce
13:29:14 <vincenz> pejo: bwaha
13:29:21 <vincenz> pejo: that article has some serious type-errors
13:29:24 <JohnyS> pejo: thanks
13:29:56 <xerox> Well, goodnight.
13:29:59 <pejo> vincenz, I know, glanced through Lmmel. It's still a real world application, for real.
13:30:00 <vincenz> notte xerox
13:30:03 <astrolabe> night x
13:30:08 <vincenz> pejo: true
13:30:15 <vincenz> pejo: but the paper could've been written somewhat better
13:30:18 <pejo> vincenz, people tend to just not buy that Erlang is  used for real, or Galois Connections.
13:30:22 <astrolabe> (that's an x for 'xerox' not a kiss!)
13:30:30 <vincenz> pejo: but I noticed those type errors before lammel actually wrote about them, they were quite obvious
13:30:30 <xerox> :x
13:30:38 <vincenz> pejo: how does that tie in?
13:31:21 <pejo> vincenz, which ties to what?
13:31:51 <vincenz> pejo: I fail to see what your point is about erlang and galois :/
13:33:30 <pejo> vincenz, they're also real world examples, but people don't consider teleco stuff "real", for some reason.
13:34:24 <vincenz> pejo: I know, just came a bit out of the blue in the conversation
13:34:36 <astrolabe> Do youmean 'galois connection' in the mathematical sense?
13:35:36 <vincenz> astrolabe: it's a company
13:36:31 <glguy> the one that hosts haskell.org i believe
13:36:33 <astrolabe> called 'Galois connection'?  That's nice.
13:37:17 <Bourbaki> isnt that a ring of french crime guys?
13:37:37 <sris> is there an easy way to convert a list [a,b,c,d,e,f] to [(a,b),(c,d),(e,f)] ?
13:37:39 <Bourbaki> they deal with cigarettes :)
13:38:48 <glguy> > let f [] = [] ; f (a:b:c) = (a,b) : f c in f [1..6]
13:38:49 <lambdabot>  [(1,2),(3,4),(5,6)]
13:39:27 <dolio> > let f [] = [] ; f (a:b:c) = (a,b) : f c in f [1..5]
13:39:29 <lambdabot>  Non-exhaustive patterns in function f
13:39:44 <glguy> > let f (a:b:c) = (a,b) : f c; f _ = [] in f [1..6]
13:39:45 <glguy> fine
13:39:45 <lambdabot>  [(1,2),(3,4),(5,6)]
13:39:53 <dolio> :)
13:40:08 <sris> glguy, thanks
13:40:08 <glguy> just depends if you want it to silently truncate or nto
13:42:30 <roconnor> @hoogle Int -> [a] -> [[a]]
13:42:32 <lambdabot> No matches, try a more general search
13:42:41 <roconnor> @hoogle [a] -> [[a]]
13:42:42 <lambdabot> List.inits :: [a] -> [[a]]
13:42:42 <lambdabot> List.tails :: [a] -> [[a]]
13:42:42 <lambdabot> List.group :: Eq a => [a] -> [[a]]
13:44:56 <roconnor> > unfoldr (Just . (splitAt 2)) [1..6]
13:44:57 <lambdabot>  [[1,2],[3,4],[5,6],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
13:45:03 <roconnor> hmmm
13:45:17 <int-e> add a  takeWhile (not . null)
13:45:27 <glguy> > let f xs = let (a,b) = splitAt 2 xs in a : f b in take 10  $ f [1..]
13:45:29 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
13:45:43 <roconnor> int-e: I think we can do better maybe
13:46:15 <glguy> > let f xs | null xs = [] | otherwise = let (a,b) = splitAt 2 xs in a : f b in take 10  $ f [1..10]
13:46:16 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:48:28 <glguy> > let f xs | null xs = [] | otherwise = uncurry (:) (second f $ splitAt 2 xs)  in take 10  $ f [1..10]
13:48:29 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:49:56 <roconnor> @pl (\x y-> Just x)
13:49:56 <lambdabot> const . Just
13:50:46 <edwardk> You know you have been using ghci too long when you type in 'bc' at a shell and stop waiting for the Prelude> prompt, before 10 seconds later realizing you are in the wrong program ;)
13:50:52 <roconnor> @pl (\f (a,b) -> (a, f b))
13:50:52 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
13:50:56 <roconnor> ugh
13:51:33 <glguy> > unfoldr (\x -> guard (not . null) x >> Just (splitAt 2 x)) [1..6]
13:51:34 <lambdabot>  Couldn't match `m a' against `()'
13:51:48 <glguy> > unfoldr (\x -> guard (not . null) x >> return (splitAt 2 x)) [1..6]
13:51:49 <lambdabot>  Couldn't match `m a' against `()'
13:51:52 <glguy> hm
13:51:52 <edwardk> roconnor: second f ?
13:52:01 <glguy> > unfoldr (\x -> guard ((not . null) x) >> return (splitAt 2 x)) [1..6]
13:52:02 <lambdabot>  [[1,2],[3,4],[5,6]]
13:52:14 <roconnor> > second (+1) (0,0)
13:52:15 <lambdabot>  (0,1)
13:52:17 <glguy> roconnor: I did that in this examlpe
13:52:21 <glguy> > let f xs | null xs = [] | otherwise = uncurry (:) (second f $ splitAt 2 xs)  in take 10  $ f [1..10]
13:52:22 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:52:32 <edwardk> roconnor: that what you need?
13:52:43 <roconnor> that's what I was thinking
13:52:47 <edwardk> kk
13:52:56 <edwardk> first is defined accordingly as well
13:53:08 <glguy> > unfoldr (join $ liftM2 (>>) (guard .(not . null)) (return (splitAt 2 x))) [1..6]
13:53:09 <lambdabot>  Not in scope: `x'
13:53:13 <glguy> > unfoldr (join $ liftM2 (>>) (guard .(not . null)) (return (splitAt 2))) [1..6]
13:53:14 <lambdabot>  Couldn't match `Maybe (a1, [a])' against `([a], [a])'
13:53:20 <glguy> > unfoldr (join $ liftM2 (>>) (guard .(not . null)) (return . splitAt 2)) [1..6]
13:53:20 <lambdabot>  Couldn't match `Maybe (a1, [a])' against `([a], [a])'
13:53:25 <roconnor> > unfoldr (second (foldr (const . Just) Nothing) (splitAt 2)) [1..6]
13:53:26 <lambdabot>    Expecting a function type, but found `t_a1Po'
13:53:27 <lambdabot>    Expected type: b -> ...
13:53:57 <roconnor> > unfoldr ((second (foldr (const . Just) Nothing)) . (splitAt 2)) [1..6]
13:53:58 * shapr hugs Binkley 
13:53:58 <lambdabot>  Couldn't match `Maybe (a1, [a])' against `([a], Maybe a)'
13:54:03 <roconnor> ugh
13:54:05 <shapr> vincenz: You need Fermat's Last Margin.
13:54:12 <glguy> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 2)) [1..6]
13:54:14 <lambdabot>  [[1,2],[3,4],[5,6]]
13:54:16 <vincenz> shapr: I need more than that
13:54:26 <shapr> How so?
13:54:28 <roconnor> I'm starting ot buy this take while not null idea
13:54:54 <shapr> vincenz: I'm not convinced.
13:54:57 <vincenz> shapr: I need the ability that it will automatically take my file without me having to worry about it, so I can dum unread papers i nit, and later quickly retrieve them when I have time
13:54:59 <glguy> roconnor, why not my last example?
13:55:09 <vincenz> shapr: I want the ability to categorize them by tags, that I can easily visualize and work out in some hierarchy
13:55:15 <vincenz> shapr: I want cross-referencing
13:55:23 <roconnor> glguy: I think using something like (foldr (const . Just) Nothing) is the way to go.
13:55:29 <shapr> vincenz: I think you get all that from FLM.
13:55:30 <glguy> roconnor: but never ends
13:55:34 <vincenz> shapr: I want an easy way to find information, be it by author, conference...
13:55:37 <shapr> yup
13:55:51 <glguy> roconnor: wait... what are you trying to do
13:55:59 <vincenz> shapr: erm, I thought flm was just a wiki
13:56:16 <roconnor> stop calling splitAt when [] is encountered
13:56:21 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just . splitAt 2)) [1..6]
13:56:22 <shapr> It's a distributed multi-user wiki.
13:56:22 <lambdabot>  [[1,2],[3,4],[5,6]]
13:56:29 <glguy> roconnor: that's what that does
13:56:36 <roconnor> hang on, I can get it
13:56:38 <shapr> Plus it's really a distributed darsc-backed wiki for each paper.
13:56:51 <gaal> hey. is there a nice graph visualizer package for haskell? something gtk based say?
13:57:02 <shapr> gaal: blobs
13:57:08 <shapr> But I think it's wxhaskell maybe?
13:57:17 <gaal> that works too :)
13:57:25 <vincenz> shapr: that won't do
13:57:27 <shapr> vincenz: Thing is, I envision something like citeseer.
13:57:29 <shapr> vincenz: Why not?
13:57:30 <vincenz> shapr: it doesn't have the amount of fluff I seek
13:57:36 <shapr> I disagree.
13:57:40 <gaal> shapr: thanks, looking.
13:57:50 <shapr> Plus if it's written in Haskell and has a clear plugin API, you can fluff it up.
13:57:51 <vincenz> shapr: you can not disagree with what my subjective opinion
13:58:00 <vincenz> ...is
13:58:28 <shapr> vincenz: True, but I can disagree with what I predict to be your subjective experience after using the tool :-)
13:58:45 <shapr> I'm not trying to be difficult, I just think FLM will work a lot better than the simple description implies.
13:58:46 <vincenz> shapr: it's a wiki, I know for sure I do't need a wiki
13:58:55 <shapr> How/why do you know that?
13:59:32 <roconnor> @pl (\x -> foldr (\a b -> Just (splitAt 2 x)) Nothing x)
13:59:32 <lambdabot> flip foldr Nothing =<< const . const . Just . splitAt 2
13:59:39 <shapr> Can I persuade you to be an alpha tester for FLM? That way I can try to satisfy the most demanding users first :-)
13:59:57 <roconnor> unfoldr (flip foldr Nothing =<< const . const . Just . splitAt 2) [1..6]
14:00:02 <roconnor> > unfoldr (flip foldr Nothing =<< const . const . Just . splitAt 2) [1..6]
14:00:03 <lambdabot>  [[1,2],[3,4],[5,6]]
14:00:06 <roconnor> yay
14:00:08 <vincenz> shapr: have a link?
14:00:12 <roconnor> but that wasn't clear at all ;)
14:00:24 <roconnor> so much for nice point-free code
14:00:37 <glguy> > unfoldr (uncurry (>>) . (guard.not.null &&& Just . splitAt 2)) [1..6]
14:00:38 <lambdabot>  [[1,2],[3,4],[5,6]]
14:00:38 <roconnor> point free code doesn't work so well when you use a variable more than once.
14:00:47 <glguy> roconnor: I already gave clean point-free code :-p
14:00:47 <shapr> vincenz: The demo isn't online at the moment, but I can make it public again.
14:00:59 <roconnor> oh
14:01:00 <roconnor> wait
14:01:04 <roconnor> what is guard?
14:01:07 <roconnor> @type guard
14:01:08 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:01:15 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just . splitAt 2)) [1..6]
14:01:16 <lambdabot>  [[1,2],[3,4],[5,6]]
14:01:36 <glguy> guard causes that to return Nothing when not null is false
14:02:02 <roconnor> yes
14:02:05 <roconnor> I like it
14:02:15 <roconnor> @karma+ glguy
14:02:16 <lambdabot> glguy's karma raised to 1.
14:02:29 * glguy wonders why his karma keeps gettign reset
14:02:36 <roconnor> @karma
14:02:36 <lambdabot> You have a karma of 2
14:02:48 * glguy wonders why lambdabot is broken
14:02:54 <roconnor> @karma lambdabot
14:02:55 <lambdabot> lambdabot has a karma of 28
14:03:35 <glguy> ?tell dons Lambdabot is off by when when karma+ is confirmed
14:03:36 <lambdabot> Consider it noted.
14:03:43 <vincenz> shapr: I honestly believe it lacks what I seek
14:04:15 <int-e> @karma glguy
14:04:16 <lambdabot> glguy has a karma of 1
14:04:22 <int-e> @karma
14:04:23 <lambdabot> You have a karma of 19
14:04:29 <glguy> wtf then
14:04:48 <glguy> who has been karma-ing me
14:05:25 <int-e> Maybe dons accidently overwrote the state with old versions? I don't know.
14:05:42 <roconnor> @karma- lambdabot
14:05:43 <lambdabot> lambdabot's karma lowered to 27.
14:05:57 <glguy> ?tell dons nevermind about the off by one, lambdabot is insane or someone keeps karma- ing me
14:05:57 <lambdabot> Consider it noted.
14:07:17 <Cale> glguy: recently, all the state in the bot got reset, I think
14:07:26 <Cale> @karma dons
14:07:27 <lambdabot> dons has a karma of 71
14:07:33 <Cale> hmm, maybe not? :)
14:07:40 <vincenz> @karma Cale
14:07:40 <lambdabot> Cale has a karma of 13
14:08:03 <glguy> I think he's got me special cased (c:
14:08:03 <Cale> okay, hmm
14:08:15 <Cale> @karma+ glguy
14:08:16 <lambdabot> glguy's karma raised to 2.
14:08:20 <Cale> @karma+ glguy
14:08:21 <lambdabot> glguy's karma raised to 3.
14:08:22 <glguy> that won't last
14:08:25 <glguy> and you know ti :)
14:08:44 <Cale> who would karma- you?
14:08:51 <glguy> I have enemies
14:08:57 <Cale> interesting
14:09:05 <vincenz> @karma
14:09:06 <lambdabot> You have a karma of 8
14:09:06 <glguy> I haven't met them, but I must
14:12:04 <glguy> speaking of karma
14:12:16 <glguy> I think it would be cool if the + and - were tracked separately
14:12:24 <glguy> 0 could mean two things
14:12:34 <shapr> vincenz: You could be right, but it's at least worth trying.
14:12:46 <glguy> so that you could see if someone did lots of good and lots of bad
14:13:29 <int-e> are you still talking about karma? wow.
14:13:55 <glguy> Cale: see... enemies
14:14:42 <Cale> glguy: uh, that said 8
14:15:18 <glguy> ?
14:15:33 <Cale> eight
14:15:38 <Cale> not zero
14:15:47 <glguy> for vincenz ?
14:15:51 <Cale> oh
14:15:56 <Cale> @karma glguy
14:15:56 <lambdabot> glguy has a karma of 3
14:16:01 <Cale> still 3?
14:16:06 <glguy> for now...
14:16:12 <dolio> @karma
14:16:13 <lambdabot> You have a karma of 0
14:16:13 <gaal> Blobs wants HaXml 1.15 or newer (and the site suggests I want 1.17 for 6.6 fixes). But debian only comes with 1.13. Will uninstalling my .deb and registering a newer haxml land me in trouble?
14:16:19 <glguy> It's an uphill battle :)
14:16:26 <Cale> @karma+ glguy
14:16:26 <Cale> @karma+ glguy
14:16:26 <lambdabot> glguy's karma raised to 4.
14:16:26 <Cale> @karma+ glguy
14:16:27 <lambdabot> glguy's karma raised to 5.
14:16:27 <dolio> Mine was at 1, so you're not special cased.
14:16:27 <lambdabot> glguy's karma raised to 6.
14:17:04 <glguy> Cale: I won't be offened when you subtract those tesing karmas
14:17:24 <glguy> :-p
14:19:09 <glguy> anyway... can someone remind me what the do { x -< y } syntax was supposed to do?
14:19:13 <glguy> (proposed syntax)
14:19:27 <int-e> arrow something ;)
14:19:53 <int-e> http://www.haskell.org/arrows/syntax.html
14:19:55 <lambdabot> Title: Arrow syntax
14:20:05 <zzctb> i got a Maybe Int (ie. Just 1) and i want the Int alone. any hits? thanks.
14:20:30 <kpreid>  @type fromMaybe
14:20:34 <gaal> zzctb: fromJust, if you're sure
14:20:41 <kpreid> @type fromMaybe
14:20:42 <lambdabot> forall a. a -> Maybe a -> a
14:20:49 <kpreid> @type fromJust
14:20:50 <lambdabot> forall a. Maybe a -> a
14:20:54 <kpreid> @type maybe
14:20:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:21:23 <gaal> but that'll error if it's Nothing. default is better, as kpreid suggests; you provide a reasonable fallback.
14:22:41 <glguy> fromMaybe can also be used to annoynce a more meaningful error
14:23:07 <glguy> fromMaybe (error "oops, my function f is doing y") x
14:23:11 <Cale> or use case
14:23:21 <kpreid> glguy: ooh
14:23:22 <glguy> which is probably clearer
14:23:34 <Cale> case m of Just x -> x; Nothing -> 0
14:23:51 <glguy> yeah, I meant Cale's suggestion was clearer
14:24:11 <zzctb> ty, will look into both.
14:25:09 <gaal> zzctb: peek at http://haskell.org/hoogle/?q=maybe for other useful functions.
14:25:11 <lambdabot> Title: maybe - Hoogle
14:26:11 <zzctb> thanks gaal
14:26:23 <gaal> sure
14:27:02 <gaal> wow, I didn't realize HaXml was so big, it takes a while to build!
14:27:11 <glguy> zzctb: in Hugs and GHCi you can type :browse Data.Maybe
14:27:58 <glguy> Did anyone hear if edwardk made progress with Monad Comprehensions?
14:28:31 <dolio> I must admit that I'm skeptical that Haskell attaining a label of "5GL" will encourage people to try it instead of Java.
14:28:53 <glguy> dolio: link?
14:29:04 <dolio> glguy: haskell-cafe mailing list.
14:29:12 <dolio> ?where haskell-cafe
14:29:13 <lambdabot> I know nothing about haskell-cafe.
14:29:29 <glguy> i found the archive
14:30:09 <glguy> Visual Basic is 5GL?
14:30:17 <glguy> isn't there a language called "4GL"?
14:30:33 <dolio> Possibly...
14:30:47 <int-e> there's Forth.
14:31:41 <gaal> ugh! HaXml-1.17 isn't just slow to compile, it's looping :(
14:32:10 <gaal> (with GHC 6.5.20060907)
14:32:32 <glguy> I installed 1.13.2 for HAppS today, and that worked well enough
14:32:39 <glguy> I didn't know there was a 1.17
14:33:33 <gaal> I didn't either, but I needed >= 1.15 to try out Blobs
14:33:41 <gaal> okay, bedtime for me... good night &
14:35:16 <lispy> hmm...how do you increase the number of tests that quickcheck does?
14:36:04 <lispy> ?seen dons
14:36:05 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 5h 48m 44s ago.
14:36:12 <lispy> oh, i should just check the lambdabot sourc...
14:37:08 <musasabi> 1.13.2 is the latest stable HaXml version.
14:37:13 <dolio> http://haskell.org/haskellwiki/Introduction_to_QuickCheck
14:37:16 <musasabi> Needed for new GHC.
14:37:16 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki, http://tinyurl.com/fx5ob
14:37:33 <dolio> Under the "Coverage" heading.
14:39:08 <glguy> I aske the DBAs and 4GL is an INFORMIX reporting language
14:39:35 <x3m> is there any guide on string manipulation, or reference what function are avalable?
14:40:11 <svref> Syzygy-_: are you there?
14:40:15 <lispy> dolio: thanks, for some reason i was reading the quickcheck manual to find that :)
14:40:18 <SyntaxNinja> x3m: look in Data.List for many useful functions
14:40:27 <dolio> lispy: Heh. Silly you. :)
14:41:28 <x3m> > head "hello"
14:41:29 <lambdabot>  'h'
14:41:46 <glguy> type String = [Char]
14:42:03 <SyntaxNinja> > length "foo"
14:42:05 <lambdabot>  3
14:42:11 <lispy> heh, i should probably switch to small check...
14:42:12 <SyntaxNinja> @type split
14:42:13 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
14:42:22 <SyntaxNinja> @type splitAt
14:42:23 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:42:29 <SyntaxNinja> @type takeWhile
14:42:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:42:47 <SyntaxNinja> > takeWhile (/= 'x') "foooxfooo"
14:42:48 <lambdabot>  "fooo"
14:43:07 <x3m> take this for example: "the trees are green" how would i extract: "are" from there?
14:43:28 <glguy> based on what criteria
14:43:47 <x3m> 3rd word for example, or the word after "trees " or something
14:43:58 <glguy> > words "the trees are green"  !! 2
14:44:00 <lambdabot>  "are"
14:44:41 <x3m> ok, i've not even read about the !! operator yet or what it is
14:44:43 <_Stinger_> > words "the trees are green"
14:44:45 <lambdabot>  ["the","trees","are","green"]
14:44:53 <_Stinger_> should give you some clue
14:45:34 <SyntaxNinja> > let h:t = words "haskell rules!" in unwords (h:"Totally":t)
14:45:36 <lambdabot>  "haskell Totally rules!"
14:45:41 <x3m> > words "testing priv #oreally :and this" !! 4
14:45:42 <lambdabot>  "this"
14:46:11 <x3m> if i wanted to extract "and this" there
14:46:56 <glguy> > drop 23 "testing priv #oreally :and this"
14:46:57 <lambdabot>  "and this"
14:47:02 <x3m> words > "testing priv #oreally :and this" !! 4 ++ !! 3
14:47:17 <glguy> x3m: that's not going to work when you move the >
14:47:18 <int-e> > span (/=':') "testing priv #oreally :and this"
14:47:20 <lambdabot>  ("testing priv #oreally ",":and this")
14:47:53 <x3m> move the > ?
14:48:28 <x3m> ah
14:48:29 <glguy> lambdabot did not throw a type error because you put the > in the wrong place
14:48:39 <x3m> > words "testing priv #oreally :and this" !! 4 ++ !! 3
14:48:39 <lambdabot>  Parse error
14:48:41 <x3m> typo
14:48:53 <int-e> > let post [] = []; post ((':':b):bs) = unwords (b:bs); post (b:bs) = b:post bs in post . words $  "testing priv #oreally :and this"
14:48:54 <lambdabot>  Couldn't match `[Char]' against `Char'
14:49:00 <x3m> > words "testing priv #oreally :and this" !! 4 ++ (words "testing priv #oreally :and this" !! 3)
14:49:02 <lambdabot>  "this:and"
14:49:06 <glguy> > liftM2 (++) (!! 3) (!! 4) $ words "testing priv #oreally :and this"
14:49:07 <lambdabot>  ":andthis"
14:49:48 <glguy> or more reasonably:
14:49:50 <int-e> > let post [] = []; post ((':':b):bs) = [unwords (b:bs)]; post (b:bs) = b:post bs in post . words $  "testing priv #oreally :and this"
14:49:51 <lambdabot>  ["testing","priv","#oreally","and this"]
14:50:25 <glguy> > (\x -> x !! 3 ++ x !! 4) (words "testing priv #oreally :and this")
14:50:26 <lambdabot>  ":andthis"
14:52:45 <x3m> thats some sort of lambda function?
14:52:45 <irgs> > unwords . drop 3 . map (filter Char.isAlpha) $ words "testing priv #oreally :and this"
14:52:47 <lambdabot>  "and this"
14:53:19 <glguy> x3m: \x -> f x is a lambda expression (anonymous function)
14:53:30 <x3m> alright
14:55:15 <irgs> hmhm
15:02:51 <edwardk> wow I love haskell some times.
15:04:04 <x3m> is there an and operator? (&& in c++)
15:04:11 <edwardk> 30 lines describes the properties of a pretty wide class of x86 assembly opcodes, all register conventions, etc. deriving is a wonderful thing. now I just need to generate the actually binary code generator.
15:04:22 <edwardk> > and [true,false]
15:04:23 <lambdabot>  Not in scope: `false'
15:04:27 <edwardk> > and [True,False]
15:04:29 <lambdabot>  False
15:04:41 <x3m> ok
15:04:48 <edwardk> its not really an operator as such, it works over arbitrary lists
15:05:20 <dolio> > True && False
15:05:22 <Igloo> && is the operator corresponding to C++'s &&
15:05:22 <lambdabot>  False
15:05:52 <edwardk> heh, never even noticed it was there
15:08:39 <x3m> > ((\x -> x !! 4) (words "testing this for now")) == now
15:08:40 <lambdabot>  Not in scope: `now'
15:08:46 <x3m> > ((\x -> x !! 4) (words "testing this for now")) == "now"
15:08:48 <lambdabot>  Exception: Prelude.(!!): index too large
15:08:55 <x3m> > ((\x -> x !! 3) (words "testing this for now")) == "now"
15:08:56 <lambdabot>  True
15:11:04 <x3m> > ((\x -> x !! 3) (words "testing this for :!now")) == ":!now"
15:11:05 <lambdabot>  True
15:12:06 <Lemmih> shapr: ping.
15:12:34 <Lemmih> shapr: I miss your unicycle movies.
15:14:24 <zzctb> i got this list a = [ [1, 2], [3, 4], [5, 6] ] in hugs and i want the output to be: 12\n34\n56. i been fooling around with list comprehensions (x:xs), [f x | x <- y] and print for a while now and best i can do is to get all elements on seperate lines. any advice on how i should tackle it? thanks
15:14:46 <vincenz> zzctb: what is your code so far?
15:15:29 <zzctb> print' s = sequence_ [ print'' x | x <- s]
15:15:31 <zzctb> print'' (x:xs) = print x
15:15:37 <zzctb> which isnt right
15:15:47 <vincenz> hmm
15:15:52 <vincenz> well I wouldn't print right away
15:15:55 <vincenz> first convert to the right format
15:15:57 <vincenz> then prinit
15:16:13 <zzctb> best would be to just convert it to a string
15:16:16 <vincenz> right
15:16:33 <zzctb> but strings are lists?=) im comfused
15:16:42 <vincenz> first you need to show the values?
15:16:47 <vincenz> so how would you show all the values?
15:16:51 <vincenz> @type show
15:16:52 <lambdabot> forall a. (Show a) => a -> String
15:17:32 <zzctb> ah
15:17:40 <vincenz> that's only half the work
15:17:45 <vincenz> the second half is then appending them correctly
15:17:47 <int-e> > unlines . concatMap show $ [ [1, 2], [3, 4], [5, 6] ]
15:17:48 <lambdabot>  Couldn't match `String' against `Char'
15:17:51 <vincenz> and inserting \n at proper places
15:17:53 <vincenz> int-e: please don't do that
15:17:56 <int-e> > unlines . map (concatMap show) $ [ [1, 2], [3, 4], [5, 6] ]
15:17:58 <lambdabot>  "12\n34\n56\n"
15:17:59 <vincenz> int-e: !
15:18:03 <int-e> too laye.
15:18:06 <vincenz> int-e: you're kinda ruining the whole purpose of learning
15:18:10 <x3m> Prelude.(!!): index too large
15:18:13 * vincenz smacks int-e 
15:18:15 <x3m> grr
15:18:38 <vincenz> int-e: not to mention that this could be homework and you know homework policy
15:19:43 <glguy> If people with haskell homework aren't greatful enough to have haskell homework that they cheat an just used canned answers from IRC, they don't deserve to understand it
15:20:19 <vincenz> glguy: well a) the people that are honest prolly want the long answer, b) cheaters want the short answer
15:20:29 <zzctb> thanks vincenz
15:20:30 <vincenz> glguy: so truly, how do you benefit by giving the short answer?
15:21:17 <glguy> vincenz: I'm just saying that if he wants to learn it he'll ignore the answer and continued learning (but sure, int-e shouldn't jsut pasted it)
15:21:40 <vincenz> glguy: or he'll assume he gets it and take it as answer, there's no better learning than stepping through something oneself.
15:21:46 <zzctb> the question i asked is a general one, not specifically taken right from my problem sheet.
15:21:54 <vincenz> glguy: all the little errors, the little type-errors, etc... they help in the learning process
15:22:04 <int-e> if someone truly understands the short answer he'll benefit from that understanding. the hope is that cheaters will get to explain how their code works.
15:22:30 <int-e> because they won't be able to do that.
15:22:50 <vincenz> int-e: once you see the code you can prolly get a reasonable explanation, it's not THAT complex
15:22:54 <vincenz> int-e: so please, in the future refrain!
15:23:56 <vincenz> glguy: my point is that when you get an answer that looks reasonably intelligible, you won't investigate further assuming you fully understand it to the lowest bits, and yes you do, but you won't be able to recreate it yourself, doing it yourself has an added value
15:24:07 <svref> can anyone parse this?: ((x, y, z)->vertex$Vertex3 x y z) ... I'm thinking its a lambda but he forgot the '\'??
15:24:27 <vincenz> need a \
15:24:30 <glguy> ditto
15:24:43 <vincenz> (\(x, y, z) -> vertex $ Vertex3 x y z)
15:24:54 <vincenz> or alternatively
15:24:56 <vincenz> @pl (\(x, y, z) -> vertex $ Vertex3 x y z)
15:24:56 <lambdabot> (line 1, column 8):
15:24:56 <lambdabot> unexpected ","
15:24:56 <lambdabot> expecting letter or digit, operator or ")"
15:24:56 <lambdabot> ambiguous use of a non associative operator
15:25:23 <vincenz> @pl \(x, y, z) -> vertex $ Vertex3 x y z
15:25:23 <lambdabot> (line 1, column 7):
15:25:23 <lambdabot> unexpected ","
15:25:23 <lambdabot> expecting letter or digit, operator or ")"
15:25:23 <lambdabot> ambiguous use of a non associative operator
15:25:30 <vincenz> that's a new one
15:25:49 <svref> what is @pl for?
15:25:54 <vincenz> pointless :)
15:26:06 <vincenz> @pl \x y z -> vertex $ Vertex3 x y z
15:26:06 <lambdabot> ((vertex .) .) . Vertex3
15:26:24 <vincenz> @tell dons @pl doesn't like tuples as arguments to lambdas?  It borks on \(x,y,z) -> something
15:26:24 <lambdabot> Consider it noted.
15:26:47 <glguy> vincenz: there is no function that deals in (,,)
15:26:48 <sjanssen> vincenz: well known problem
15:27:11 <glguy> vincenz: you have to pattern match to get values out of a 3 tuple
15:28:38 <vincenz> > (\(x, y, z) -> x) (1,2,3)
15:28:40 <lambdabot>  1
15:28:53 <vincenz> sjanssen: didn't know :)
15:29:09 <vincenz> glguy: the pattern matching is trivial, if you type the function it takes a 3-tuple, only the 3-tuple matches that pattern
15:29:16 <vincenz> well except for _|_, but ok
15:29:21 <sjanssen> @pl \(x, y) -> x -- does this work?
15:29:22 <lambdabot> fst
15:29:22 <glguy> vincenz: ?pl can't do pattern matching
15:29:31 <glguy> and fst and snd are in the prelude
15:29:35 <vincenz> glguy: so?
15:29:41 <vincenz> it's taking as input patternmatching
15:29:51 <sjanssen> an expression that doesn't pattern match is by definition pointful
15:29:54 <vincenz> @pl \(x:y:z) -> z
15:29:55 <lambdabot> tail . tail
15:29:57 <sjanssen> s/doesn't/does
15:29:58 <vincenz> see
15:30:01 <int-e> glguy: but its output doesn't do pattern matching
15:30:02 <vincenz> it does pattermatching fine
15:30:06 <int-e> vincenz: you
15:30:13 <vincenz> int-e: me!
15:30:23 <int-e> vincenz: yes, you, not glguy.
15:30:27 <vincenz> int-e: it could be solved by uncurr3
15:30:27 <sjanssen> it handles patterns for very limited cases
15:30:30 <vincenz> @type uncurry3
15:30:32 <lambdabot> Not in scope: `uncurry3'
15:30:34 <vincenz> hmm
15:30:36 <glguy>  ?pl doesn't use pattern matching in it's output, so ?pl will not work on \(a,b,c) ->
15:30:44 <vincenz> glguy: oh like that
15:30:45 <sjanssen> vincenz: okay, then what about a 4 tuple?
15:30:50 <vincenz> glguy: I was thinking that there was uncurry3
15:30:52 <int-e> @pl \x -> if x then 1 else 2
15:30:53 <lambdabot> flip (flip if' 1) 2
15:31:02 <int-e> it even cheats on that.
15:31:10 <vincenz> sjanssen: yeah but what I found funny is that it seemingly borked on the input, it seemed like a parser error
15:31:16 <vincenz> @pl \(x,y,z) -> x
15:31:17 <lambdabot> (line 1, column 6):
15:31:17 <lambdabot> unexpected ","
15:31:17 <lambdabot> expecting letter or digit, operator or ")"
15:31:17 <lambdabot> ambiguous use of a non associative operator
15:31:25 <vincenz> see, seems like a parsing error
15:31:32 <sjanssen> vincenz: yeah, the parser is hand-rolled
15:31:37 <sjanssen> doesn't parse all of Haskell
15:31:38 * vincenz nods
15:31:47 <sjanssen> @pl do x <- y; x
15:31:47 <lambdabot> (line 1, column 10):
15:31:47 <lambdabot> unexpected ";"
15:31:47 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
15:31:48 <vincenz> so the limitation in this case is the parser, not the no patternmatching in output
15:31:56 <vincenz> @pl do {x <- y; x}
15:31:56 <lambdabot> (line 1, column 4):
15:31:57 <lambdabot> unexpected "{"
15:31:57 <lambdabot> expecting variable, "(", operator or end of input
15:32:04 * Cale feels dumber for having read the 5GL thread.
15:32:09 <vincenz> Cale: ?
15:32:10 <glguy> vincenz: the parser does not handle that case because it can not be point-free'ed
15:32:12 <vincenz> Cale: linky?
15:32:17 <sjanssen> the parser is just the first problem here
15:32:28 <vincenz> glguy: I'd rather have it bork for the actual reason :)
15:32:29 <dolio> Cale: :) It kind of reads like a troll, doesn't it?
15:32:34 <vincenz> dolio: link?
15:32:37 <Cale> vincenz: Haskell-cafe
15:32:41 <vincenz> o
15:32:55 <glguy> http://www.haskell.org/pipermail/haskell-cafe/2006-September/thread.html
15:32:57 * vincenz unregistered from it a while ago
15:32:57 <lambdabot> Title: The Haskell-Cafe September 2006 Archive by thread, http://tinyurl.com/ly9l3
15:32:58 <vincenz> too much spam
15:32:59 <sjanssen> Cale: the whole idea of separating languages into "generations" is tiresome
15:33:04 <Cale> dolio: It's just stupid because there are no concrete definitions, and so any classification is sort of meaningless.
15:33:31 <Cale> vincenz: spam?
15:33:33 <vincenz> Cale: besides, the dyn-commmunity would claim dyn-typing to be the next GL :)
15:33:38 <vincenz> Cale: haskell-cafe? yeah
15:33:40 <Cale> I don't get any spam from that ML
15:33:46 <vincenz> Cale: well, what I consider spam :)
15:33:59 <vincenz> meaning a lot of mails that I don't care about
15:34:05 <Cale> ah, okay
15:34:08 <dolio> Yeah. He says he wants specific arguments, but then his argument involves "Haskell is more abstract than Prolog," which is a pretty subjective statement.
15:34:22 <vincenz> Cale: what I find really funny is that it goes -> SQL -> Haskell
15:34:23 <Cale> I tend to read what I care about from my inbox and then use select all -> archive
15:34:27 <vincenz> Cale: thati s one odd progression of generations
15:34:47 <vincenz> Cale: oh I auto-archived to a folder in gmail, but found that I was wasting a lot of time for little signal return
15:35:45 <vincenz> BWAHAHA "I'm looking for an honest classification."
15:35:53 <vincenz> as if his initial classification made any sense whatsoever
15:35:54 <vincenz> :D
15:36:29 <glguy> Visual Basic is visual programming, and thus 5GL
15:36:41 <vincenz> glguy: yeah but why is SQL 4GL???
15:36:41 <sjanssen> glguy: heh
15:36:45 <vincenz> SQL isn't even turing complete, is it?
15:36:47 <Cale> glguy: that gets corrected
15:36:52 <dolio> His list is actually close to how they appear on Wikipedia, but they still don't make a lot of sense.
15:36:54 <Cale> vincenz: it can be
15:36:59 <glguy> 4GL, the actual language, is an INFORMIX reporting language
15:37:10 <vincenz> I always thought ruby/perl/python were considered the 4gl one
15:37:10 <Cale> vincenz: I think certain extensions to it allow for recursion.
15:37:14 <sjanssen> SQL is pretty good at doing what it does
15:37:27 <vincenz> sjanssen: yeah but I wouldn't classify DSL in a GL-tree
15:37:28 <glguy> sjanssen: is that the qualification for 4GL status?
15:37:31 <vincenz> DSL occur at all stages
15:37:44 <dolio> I mean, 4GL is domain specific languages, and then 5GL are general purpose languages that involve constraint satisfaction?
15:37:57 <vincenz> his layering makes no sense
15:38:08 <vincenz> besides, a few years ago it was agreed that 4GL were the scripting dynamic languages
15:38:10 <sjanssen> glguy: I think the common meaning of 4GL is domain specific stuff
15:38:34 <vincenz> at which point two really old languages, lisp and smalltalk were bumped to 4GL evne though they really are 0GL :P
15:38:48 <vincenz> sjanssen: common meaning of 4GL is dynamic
15:38:52 <vincenz> or used to be a few years ago
15:39:22 <sjanssen> vincenz: not according to wikipedia
15:39:39 <vincenz> obviously so
15:39:42 <vincenz> DSL are the new hype
15:39:48 <Cale> I don't think that a single integer ranking can really give enough information about a language to give any sense of what it is. (unless you go out of your way to encode lots more information using something like Gdel numbering)
15:39:49 <vincenz> look at at the amount of articles around them lately
15:40:09 <vincenz> Cale: I agree completely, I've always argued that pls span a multi-objective space with a pareto-curve :)
15:40:14 <vincenz> erm pareto-surface
15:40:22 <vincenz> (and some languages definitely falling UNDER the surface)
15:40:31 <glguy> is that like drowning?
15:40:37 <vincenz> pretty much :)
15:42:58 <dolio> I also like the part where he explains that this "is not a philosophic discussion."
15:43:40 <vincenz> I think that perhaps the grading system is
15:43:44 <vincenz> 1-3GL: settled
15:43:50 <vincenz> 4GL: what is hype in mainstream today
15:43:55 <vincenz> 5GL: what is difficult for mainstream
15:43:58 * vincenz shrugs
15:44:09 <sjanssen> 6GL: Haskell
15:44:11 <vincenz> the debate with sjanssen regarding what 4GL really was illustrates perhaps the point regarding 4GL
15:44:49 <vincenz> sjanssen: or (last $ iterate (+1) $ 1)GL
15:44:53 <dolio> Is 2D a 5GL? :)
15:44:59 <vincenz> dolio: :D
15:45:17 <sjanssen> dolio: no, it's a (5, 3) GL
15:46:10 <Cale> I wonder if there are any (1,1/2,1/4,...,1/2^n,...) GL's.
15:46:43 <vincenz> Cale: or 1+jGL
15:47:02 <Cale> Instead of single small natural numbers, let's index programming languages with sequences of real numbers.
15:47:39 <vincenz> Cale: oh you mean like *boggle* coordinates in a multi-objective spcae?
15:47:46 <Cale> Maybe modulo some ultrafilter on N.
15:47:52 <Cale> Yeah, hyperreals.
15:48:13 <Cale> er, nonprincipal ultrafilter
15:49:15 <dolio> That'd be harder to sell to your manager.
15:49:41 <vincenz> yeah, he wants a spreadsheet with 3 bulletpoints
15:49:45 <vincenz> two of which cover money
15:49:51 <vincenz> so you only have space for one more number
16:03:25 * vincenz pokes dolio and Cale
16:03:31 * SamB thinks he likes OpenGL better than any of those other GLs
16:04:01 <sjanssen> SamB: actually, I prefer Green Lantern
16:06:19 <vincenz> time for a martini
16:08:35 * sjanssen could go for a Rob Roy right about now
16:09:52 * SamB gives up on bartw's decensory thing terminating any time soon...
16:10:11 <SamB> it had been nearly 40 hours
16:11:44 <vincenz> damn
16:11:49 <vincenz> I think I may be making my martinis too big
16:13:06 <SamB> vincenz: what makes you think that?
16:13:13 <vincenz> well ths is the second night I'm making martinis
16:13:19 <vincenz> and my gin bottle is nearly half empty
16:13:26 <vincenz> a whiskey glass full
16:13:59 <dolio> vincenz: Eh?
16:14:24 <vincenz> dolio: you never responded to pm
16:14:37 <dolio> Oh, my bad.
16:14:39 <vincenz> but seeing that the only people active at the moment are the ones that I contacted
16:14:44 <vincenz> I might as well ask it here
16:14:56 <vincenz> I'm not trying to start a holy war, so if please refrain from turning it into that.
16:15:19 <dolio> I don't think they're any more dead/dying than they have been for quite some time.
16:15:24 <vincenz> a) are scheme or smalltalk dying, b) what would you use as a companion language to haskell for those tasks where typing gets in the way
16:15:45 <sjanssen> Data.Dynamic ;)
16:15:52 <vincenz> sjanssen: doesn't quite cut it
16:16:24 <dolio> I've never really used them outside of playing with them, though.
16:16:41 <vincenz> dolio: trying to find a good companion, but don't want to lose my work to bitrot
16:16:42 <SamB> I want to type @remember BjarneStroustrup any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
16:17:01 <SamB> is that a good way to reference it?
16:17:57 <vincenz> scheme is beautiful in the sense thtat you can make new semantics into the language without having to make af ull frontend (tho there are a few warts in the macro system).  Not at all familiar with smalltalk, just started looking at it yesterday (and it's hard to find your way in the zillion little classeS) but an environment that you can use and modify at your whim is quite nifty, and you get persistence for free
16:18:00 <dolio> People are still writing stuff in Scheme, though.
16:18:07 <dolio> Like Continue.
16:18:11 <vincenz> yeah
16:18:16 <dolio> I guess people still write Smalltalk, too.
16:18:20 <vincenz> my issue with scheme is the fragmentation of the community
16:18:24 <vincenz> smalltalk seems really dead :/
16:18:58 <SamB> smalltalk seems rather isolated from the system, anyways...
16:19:02 <vincenz> btw, I convinced all the guys I'm collaboratin with for a kluwer book to use darcs \o/
16:19:11 <vincenz> SamB: true
16:19:24 <vincenz> SamB: they don't even have stdin and stdout in squeak
16:19:26 <SamB> (it seems to have a system-of-its-own complex)
16:19:36 <vincenz> but then for some application domains that isn't too bad
16:19:44 <SamB> true.
16:19:47 <vincenz> (Either servers, where all you really care about is a socket, or standalone appS)
16:19:49 <dolio> I think a lot of the people who write Smalltalk use commercial environments, though.
16:19:53 <SamB> its not so great for scripting though
16:19:59 <vincenz> SamB: agreed
16:20:14 <vincenz> I think for scripting, except for the great work dons did lately with haskell one liners, you gotta go perl/ruby/python
16:20:26 <SamB> yeah, I can use perl too actually...
16:20:29 <vincenz> I once said in #squeak that each language had it's niche or problem domain
16:20:29 <SamB> not just Python...
16:20:34 <vincenz> they said I was wrong :/
16:20:45 <SamB> what was their counterexample?
16:20:55 <vincenz> they can do all they want in smalltalk cause it's a general purpose language
16:21:04 * vincenz rolls his eyes
16:21:04 <dolio> Shakespeare?
16:21:13 <SamB> nobody buys a general purpose language unless it is their first
16:21:16 <vincenz> I think #haskell is great in that sense, people are less zealoutous
16:21:23 <vincenz> (sp?)
16:21:32 <SamB> or their first at the same level of abstraction...
16:21:50 <vincenz> personally I think you can cluster languages
16:22:02 <vincenz> compilers etc: typed fpl like: sml, ocaml, haskell
16:22:11 <vincenz> semantics playground: untyped fpl
16:22:19 <vincenz> scripting: perl/ruby/python
16:22:30 <vincenz> web: unsure on this one, I guess 'enterprise web' whatever that is is java
16:22:40 <SamB> java?!?!??!?!?
16:22:49 * vincenz shrugs
16:22:54 <vincenz> isn't j2ee like really big?
16:23:10 <vincenz> that's about the ony niche java really fills
16:23:17 <vincenz> cause imho, java's too laggy for standalone apps
16:23:18 <SamB> ... the size of the binaries is relevant how?
16:23:26 <vincenz> SamB: I mean big in usage
16:23:36 <vincenz> erm, big in the sense of popular
16:23:47 <SamB> oh, are you not talking about practicality but about adoption? ;-)
16:23:54 <vincenz> both
16:24:04 <vincenz> I actually don't know much about web
16:24:09 <vincenz> I guess with web2.0
16:24:12 <SamB> hmm, my mom wants me to make some corn bread...
16:24:13 <ThreeQ> j2ee is really painful
16:24:19 <vincenz> you've got RoR and all those players taking over the field
16:24:24 <dolio> You could probably do web programming better than Java.
16:24:26 <SamB> anyway, Java is like beyond boredom, imo...
16:24:38 <dolio> But it has lots of libraries/frameworks for it, so it gets used.
16:24:40 <vincenz> anywho, I'm starting to wonder what niche java fills nowadays
16:24:42 <SamB> @remember BjarneStroustrup any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
16:24:47 <dolio> Plus, companies backing it up.
16:24:56 <vincenz> standalone apps: ...
16:24:59 <vincenz> c++?
16:25:11 <ThreeQ> objective-c :)
16:25:15 <ThreeQ> only on the mac though
16:25:16 <vincenz> right
16:25:23 <vincenz> the c-with-something-attached family :)
16:25:25 <ThreeQ> or C# on windows I guess
16:25:30 <vincenz> c#, C++, objective-c
16:26:02 <vincenz> what's objective-c like?
16:26:23 <ThreeQ> well, the easiest way to describe it is smalltalk + C
16:26:26 <vincenz> anyways, my point is, different domains suit different languages, sure they're all gppl, but each has expressiveness and libraries better suited for certain domains
16:27:02 <ThreeQ> it's a small syntax-transformer that changes [object message:val param2:val2] into a call to objc_msgSend
16:27:23 <ThreeQ> and a few other things
16:27:29 <vincenz> is objective-c 'cocoa'?
16:27:33 <vincenz> or is that something else?
16:27:34 <ThreeQ> cocoa is the standard library
16:27:38 * vincenz is unfamiliar with the apple world
16:27:47 * scsibug is writing obj C right now....it's nice :)
16:27:47 <vincenz> ah right
16:28:04 <vincenz> but I heard soemwhere that obj-c is so nice cause it plugs in so nicely everywhere
16:28:10 <vincenz> which in a sense is more than just the pl
16:28:13 <ThreeQ> yeah
16:28:14 <scsibug> but I also own a NeXTStation, so i'm biased
16:28:17 <ThreeQ> it has a runtime
16:28:23 <ThreeQ> so you can change things dynamically
16:28:24 <vincenz> and everyone makes sure to tie into it nicely
16:28:29 <ThreeQ> switch methods around and such
16:28:42 <ThreeQ> also dynamic dispatch
16:28:47 <vincenz> :)
16:28:52 <vincenz> anyone play with dylan?
16:29:38 * vincenz shudders at the syntax
16:29:49 <vincenz> I just googled
16:30:04 <vincenz> anyways, regarding the web stuff
16:30:29 <dolio> Hmm, "end method;"
16:30:43 <vincenz> I do think that j2ee still has some place, my friend works for accenture, used to do development for webservices for the web.  And there's more than the frontedn with nice aax, you have the whole middle business end and backend.  And I don't think the web2.0 frameworks are designed for such
16:30:48 <vincenz> erm
16:30:54 <vincenz> development for webservices for the government
16:31:02 <vincenz> like online voting and online taxes
16:31:57 <dolio> Some Java frameworks have had a lot of work put into making them distribute across many servers and such. You're unlikely to get that with Ruby right now.
16:32:25 <dolio> Separate RMI servers from app servers from database servers, and add redundancy...
16:33:24 <vincenz> another reason why I'm askinig for a dyntyped lang is cause I'd like to write a mud, but with a lot more than just the std mud functionality.  I would like the NPCs (non player characters) to evolve similarly as PCs and thus have goals of their own, meaning they'd actually form an economy in which the PCs can then partake (imagine something like the sims, but then fantasy oriented and mud-based)
16:34:27 <vincenz> for some reason I think smalltalk would do good for this, but it seems a dead world, not to mention that smalltalk has such a small syntax that EVERYThing is in the library, and in very small objects lal over the place, it's hard to get a foothold
16:35:12 <vincenz> so before spending time getting worked into the system, I'm trying to ask around first, prune some options :)
16:37:00 <wilx> The key thing is data structures, not the language.
16:37:33 <wilx> Though, if the language can give good support for data structures that you need then it is a good thing.
16:37:42 <wilx> But afaik not major.
16:37:52 <wilx> s/afaik/imo/
16:38:02 <vincenz> true and false
16:38:18 <vincenz> I've played around with coldc, which is a great system (though sadly, you can't do offline coding easily, and it's even less mainstream)
16:38:24 * qwr would take some common lisp implementation, if i'd want dynamic typeing lang for some larger project
16:38:27 <vincenz> the nice thing is that you can code while online, meaning no need for reboot
16:38:40 <vincenz> it'd take quite some strutting to get a lisp-system to do that
16:39:19 <dolio> You could write it in Erlang. Then you'd be able to easily distribute it across several servers. :)
16:39:33 <ThreeQ> yes, erlang actually sounds like a pretty good fit
16:39:47 <dolio> It has all kinds of fun stuff like hot code loading, too.
16:41:04 <ThreeQ> each npc could be its own erlang process
16:41:13 <ThreeQ> or collection of processes
16:41:30 <dolio> Heh. I was thinking about that. It depends on how many npcs there are, I guess.
16:42:03 <vincenz> prolly many
16:42:05 <dolio> Although erlang can do a lot of simultaneous processes.
16:42:49 <dolio> "Tens of millions"
16:42:54 <ThreeQ> yeah
16:43:05 <vincenz> not sure erlang would do well
16:43:12 <vincenz> sure process wise it would be good
16:43:24 <vincenz> but designwise
16:43:26 <ThreeQ> although by default it starts giving errors after 20k or so
16:44:27 <ThreeQ> vincenz: what do you mean?
16:45:03 <vincenz> don't think it'd be a good language to design a mud in
16:45:08 <vincenz> I think an oo lang wouold be better suited
16:45:54 <Lemmih> Whoa, Alexander Jacobson got hackage.org
16:47:16 <ThreeQ> hmm, maybe
16:47:20 <dolio> Muds can be pretty object-based, conceptually.
16:47:25 * vincenz nods
16:47:28 <vincenz> especially the behaviour
16:47:29 <ThreeQ> but the concurrency features would be nice for your evolving npcs
16:47:31 <dolio> Mimicing all that with tuples and such might be annoying.
16:47:45 <Igloo> Lemmih: To donate to the community?
16:48:08 <Lemmih> Igloo: I don't know.
16:48:08 <vincenz> LOOOOOL
16:48:16 <vincenz> we used to have scheme in the first year of college
16:48:23 <vincenz> I was just looking through some old backup cds
16:48:29 <vincenz> and I found this inside the code of an assignment I wrote
16:48:30 * Igloo starts to think we should just throw the old wiki away
16:48:38 <vincenz> mymacht = mypower
16:48:40 <Lemmih> Igloo: I really hope so.
16:48:43 <vincenz> (meaning x^t)
16:48:51 <vincenz> (define (mymacht s n)
16:48:51 <vincenz>   (define (fuck-you-bitch x n)
16:48:51 <vincenz>     (cond ((= n 0) x)
16:48:51 <vincenz>           ((even? n) (fuck-you-bitch (* x x) (/ n 2)))
16:48:51 <vincenz>           (else (fuck-you-bitch (* x s) (- n 1)))))
16:48:54 <vincenz>   (fuck-you-bitch s (- n 1)))
16:48:54 <Igloo> AFAICT 90% of it has no author associated, and most of what does is either spam or a reversion of spam
16:49:25 <Igloo> shapr: Are you around?
16:49:34 <dolio> Hah. Was that a graded assignment?
16:49:36 <vincenz> Igloo: prolyl not, quite late
16:49:39 <vincenz> dolio: I think so
16:49:42 <Igloo> vincenz: In the US?
16:49:43 <vincenz> dolio: it's part of a big file tho
16:49:48 <vincenz> Igloo: he's in the US now?
16:50:02 * vincenz didn't know he had moved yet
16:50:03 <Igloo> Unless he left again in the last week
16:50:45 <vincenz> heh... this is so funny
16:50:51 <vincenz> another assignment I turned in has this in the head
16:51:01 <vincenz> ;Naam: project name ...
16:51:03 <vincenz> ;Auteur:  Christophe Poucet
16:51:03 <vincenz> ;Nick:  _Marvin
16:51:21 * vincenz snickers, "I don't remember any of this :P"
16:53:17 <lispy> is there an easy way to convert between HsDecl and template haskell?
16:53:31 <glguy> guy in my house wrote on a test: printf("I'm drunk")
16:53:35 <vincenz> it's actually pretty cool, in our uni, first year engineering of all directions got scheme, they later changed to java, but even in scheme, they taught us oop through a lambda taking a symbol as message
16:53:56 <lispy> HsDecl is what i'm getting from the H98 parser, but I want to use it in some template haskell code and i don't really see a way to convert one to the other
16:54:52 <ThreeQ> vincenz: yeah, they do that here too
16:55:06 <ThreeQ> except for some reason our operating systems class is taught in java
16:55:15 <vincenz> ThreeQ: 2-3 years after my year they switched to java for first year engineers :/
16:55:24 <ThreeQ> :(
16:55:41 <sjanssen> ThreeQ: OS class in Java, that is insane
16:55:48 <Igloo> lispy: I don't think there is one. Do you really need to do the parsing yourself rather than sticking something in [d| |]?
16:56:11 <vincenz> ThreeQ: the nice thing of scheme is: A) the syntax is light allowing you to focus on the problem, b) you can easily define different semantics, meaning you can explore fp and oop
16:57:19 <ThreeQ> yeah
16:57:29 <ThreeQ> scheme is very nice for teaching/learning
16:57:30 <vincenz> if I were a teacher I'd definitely use it to teach
16:58:57 <shapr> Igloo: eh?
16:59:22 <shapr> Igloo: works for me, I can turn it off.
17:00:15 <Igloo> shapr: I was going to suggest announcing it will be disabled in 1 month or something and that people who want to migrate content they have permission for should do it before then?
17:00:26 <shapr> I like it.
17:00:34 <shapr> I'll make it immutable right now.
17:00:39 <Igloo> OK, cool
17:01:22 <Igloo> Does authorless content date from a time before logins were required, BTW?
17:01:41 <shapr> Most likely.
17:01:54 <shapr> Logins were only required when spam became a flood.
17:02:03 <Igloo> *nod*  :-(
17:02:37 <shapr> Still, I wish yale would switch to debian/unstable.
17:02:38 <lispy> Igloo: yeah, i'm doing the parsing myself because i read in my list of tests, and then generate the calls to quickcheck
17:02:49 <lispy> Igloo: i wanted to be able to do per-test configs
17:02:59 <lispy> Igloo: so, i thought i'd parse for a where config = ...
17:03:11 <shapr> lispy: ooh neat
17:03:16 <lispy> Igloo: i'm modifying my code so that I just have where numTests = n; and I pick out the integer
17:03:35 <shapr> lispy: Why not add that as a param then?
17:03:42 <shapr> configs don't hold much data.
17:03:53 <lispy> shapr: here is what i'm doing http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
17:03:55 <lambdabot> Title: dagit.o  Blog Archive  Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
17:04:04 <lispy> shapr: what do you mean param?
17:04:09 <lispy> shapr: as in modify quickcheck?
17:04:12 <shapr> yikes, haskell.org is thrashing again - 19:49:03  up 311 days,  3:38,  2 users,  load average: 13.63, 4.64, 1.82
17:04:24 <shapr> lispy: Sure, why not?
17:04:36 <lispy> shapr: i probably should...
17:04:42 <shapr> You could add a wrapper that allows a test to specify number of cases.
17:04:53 <lispy> shapr: i already had this TH infrastructure so i thought  i'd exploit  it :)
17:05:00 <shapr> quickcheck v1 is really simple.
17:05:01 <lispy> shapr: yeah that would be nice
17:05:33 <shapr> I just made a separate unitCheck that only runs one test.
17:05:37 <lispy> okay, so now given an integer, what's the easiest way to splice it in?
17:05:38 <shapr> That way I could retest failing cases.
17:05:45 <lispy> ah
17:05:52 <shapr> Use a partially applied config
17:06:24 <shapr> Or a configCases N :: Config that's just the record's field accessor?
17:07:32 <araujo> yay!
17:07:35 * araujo back from dinner
17:07:40 * araujo boings
17:07:49 * shapr hops
17:07:55 <erider> hi araujo
17:08:00 <araujo> hola erider
17:08:16 <erider> como te vaj araujo?
17:08:25 * araujo been having a haskell hacking weekend!!!
17:08:38 <araujo> erider, pretty well !
17:08:41 <araujo> yourself?
17:08:47 <erider> espero q todo salga bien pa voj
17:08:57 <araujo> Thanks :-)
17:09:05 <shapr> lispy: btw, have you seen my test driven development hack of quickcheck? Any ideas how it can be more robust?
17:09:13 * erider was C hacking 
17:09:20 <araujo> erider, how your haskell learning goes?
17:09:57 <erider> araujo: ok but I'm still on the basics
17:10:08 <araujo> yay!
17:10:25 <erider> I have been doing some C and lisp stuff lately
17:10:34 <araujo> erider, let the power of the lambda goes onto you
17:10:44 <erider> :)
17:14:02 <lispy> shapr: i think you gave me a link but i haven't seen it
17:14:15 <lispy> shapr: a did look at HFT
17:14:30 <lispy> but, HFT doesn't fit my needs because it requires Posix :(
17:14:37 <lispy> shapr: but i'm about to run now
17:14:47 <lispy> shapr: i got this code working and now i need to go help a friend
17:15:21 <edwardk_> gah, is haskell.org down or is it just that i can't get there from here?
17:15:41 <glguy> down
17:15:45 <edwardk_> bah
17:15:47 <glguy> afaik
17:15:53 <edwardk_> never realize how much you miss hoogle til its dead ;)
17:17:08 <edwardk_> any suggestions? I want to put together some sort of simple template haskell toy for taking apart bit fields (unless there is one already out there) so I could go like let (a,b,c) = $(bitvector [3,3,2]) foo in ...
17:17:38 <araujo> h.o down!!!!
17:17:38 <edwardk_> and disassemble foo starting with the lsbs.
17:17:50 <araujo> argh!
17:17:59 <edwardk_> (i'm doing a lot of bit twiddling at the moment)
17:18:07 <edwardk_> araujo: i feel your pain
17:21:20 <x3m> > qsort [5, 1, 4, 6]
17:21:21 <lambdabot>  Not in scope: `qsort'
17:21:28 <glguy> sort?
17:21:39 <x3m> > sort [5, 1, 4, 6]
17:21:40 <lambdabot>  [1,4,5,6]
17:21:48 <x3m> was thinking if there was a specific quicksort
17:21:52 <glguy> (that is implemented as a merge sort)
17:22:12 <x3m> ahh well merge is descent but there are better
17:22:16 <glguy> merge sort is better in this case than quicksort
17:22:24 <x3m> introsort owns
17:24:01 <araujo> argh, i feel so impotent ....
17:24:10 <araujo> anybody knows what the problem is?
17:25:09 <sjanssen> araujo: I don't know why you might feel impotent.  You should probably see a doctor.
17:25:35 <sjanssen> anyway, haskell.org was down over the weekend, I suppose this is more of the same
17:25:42 <ndm> haskell.org is down :(
17:26:01 <ndm> dcoutts said that previously he had "kicked the server" in some way to bring it back
17:26:10 <ndm> are there any instructions anywhere on how to do that?
17:26:39 <vincenz> ndm: walk_to server >> lift foot >> foot `ap` server
17:26:41 <araujo> sjanssen, h.o is down!!
17:26:48 <Igloo> Given it won't let me SSH in ATM I can't think what he would have done
17:26:57 <vincenz> hammer `ap` server
17:27:42 <ndm> last time haskell.org was down i could still get in via SSH
17:28:15 * araujo tries
17:28:58 <araujo> nothing ....
17:30:00 <Igloo> I don't suppose anyone has a recent head on a multi-CPU machine handy?
17:30:27 <sjanssen> Igloo: how recent is recent?
17:31:03 <Igloo> More recent than the 19th Sept would be nice, but possibly not essential
17:32:52 <x3m> are there any good haskell books?
17:32:53 <sjanssen> I have a 6.5 build from Sep 15 on a Core Duo
17:33:41 <Elendal> Grr, got my first assignment to write in haskell.
17:33:59 <sjanssen> Elendal: woo!  High five!
17:34:21 <Elendal> Yeah, but I want to sleep!
17:34:24 <araujo> x3m, The Bird one
17:34:40 <Cale> Elendal: grr? You should be happy that you're learning such a beautiful language :)
17:35:41 <Elendal> I have a very crapy techer. He doesn not know haskell, he knows fortran, and yet he teches it
17:36:56 <x3m> i dont like the indentation of haskell at all yet :/
17:38:00 <araujo> x3m, that's one of the most beautiful feature!
17:38:12 <araujo> Though you can always avoid it with { ; ... ; }
17:39:19 <araujo> > let f a b = x + y where { x = a * b ; y = a + b } in f 56 78
17:39:20 <lambdabot>  4502
17:39:38 <x3m> araujo: well i dont like it, it just causes compile errors.. i prefer the ; wat
17:39:40 <x3m> way
17:40:27 <araujo> It causes compiling errors when you begin to learn it for sure. And you actually would consider it unnecessary (i did)
17:40:33 <sjanssen> @where paste
17:40:34 <lambdabot> http://paste.lisp.org/new/haskell
17:40:39 <araujo> But then you will realize how clean makes your code.
17:41:19 <x3m> araujo: i dont really agree, i think you can use indentation to make code clean even with ;, but i prefer that to be up to the coder
17:41:20 <glguy> it will definitely cause errors if you odn't have 8-space tabs
17:41:34 <araujo> x3m, statements/expressions separators are mostly only visual noisy
17:41:46 <lisppaste2> sjanssen pasted "for Igloo" at http://paste.lisp.org/display/26755
17:41:50 <araujo> x3m, you are learning Haskell?
17:41:56 <x3m> araujo: yes
17:42:04 <araujo> x3m, Usual, you won't agree with me _yet_
17:42:05 <araujo> :-)
17:42:21 <x3m> i think c++ code is clean ;)
17:42:54 <araujo> x3m, well, get ready for re-formulate your "cleanness" conception
17:43:21 <vincenz> someone karma++ me, I got a colleague started on haskell, a guy that usually works with c and vhdl
17:43:31 <vincenz> \o/
17:44:10 <glguy> ~\o/~
17:44:23 <vincenz> @where yaht
17:44:23 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
17:48:25 <glguy> x3m: introsort would be a terrible replacement for "sort" because heapsort's performance on linked lists is abyssmal
17:48:48 <araujo> vincenz, vhdl?
17:48:58 <vincenz> araujo: verilog?
17:49:13 * araujo doesn't know it
17:49:47 <araujo> x3m, But don't worry, Haskell is a healthy addiction ....
17:49:54 <shapr> I bet I broke haskell.org
17:50:00 * shapr sighs
17:50:12 <araujo> shapr, tried to run a java appli?
17:50:13 <Igloo> What did you do?
17:50:15 <x3m> glguy: std::sort in c++ usually used introsort at least, works good
17:50:22 <Igloo> Oh, are you still logged in, shapr?
17:50:36 <araujo> mmm... ssh up?
17:50:38 <shapr> Igloo: I did cd /usr/share/moin/hawiki/data/pages && chmod u-w **/*
17:50:42 <glguy> x3m: std::sort works on random access iterators
17:51:07 <shapr> I can't ssh in a second time, but my first ssh session is still waiting for that command to return (one hour later).
17:51:16 <araujo> :-(
17:51:18 <Igloo> Oh, I assumed making it immutable meant checking a little box somewhere  :-)
17:51:32 <glguy> not taking the site offline?
17:51:39 <glguy> offline is pretty immutable
17:51:42 * Igloo doesn't think that should have killed it, though
17:51:51 <araujo> shapr, so, is it your command killing the net?
17:51:54 <shapr> I hope not.
17:52:10 <shapr> I didn't ask for verbose output, so I don't see how that could have done anything..
17:52:18 <araujo> mmm...
17:52:34 <Igloo> The networking is fine - it pings and accepts connections to ports
17:52:44 <araujo> Nah, i think the connection just hanged up
17:52:47 <Igloo> It's either swapping an awful lot or the kernel has locked up
17:53:04 <glguy> it's that darned "Lin-uks"
17:53:33 <araujo> They have done so recent updating to that box?
17:53:42 <shapr> I doubt it, it has 300+ days of uptime.
17:53:48 <araujo> I don't remember h.o having so much problem like this
17:53:49 <shapr> 311 days
17:54:09 <shapr> Last I checked it was running an ancient version of redhat that hasn't had an update since 2003
17:54:17 <araujo> I think this  is the fourth day that goes down
17:54:37 * shapr grumbles
17:55:03 <araujo> And it always goes down for around this time ... mmm
17:55:20 <araujo> I don't think it's because of you shapr
17:55:51 <glguy> outdated redhat? that's definitely not full of holes ;)
17:55:53 * araujo thinks somebody should look into this
17:56:49 <shapr> I emailed John Peterson when JaffaCake put me in charge of spam for haskell.org and he said the IT department will install a new Linux distro sometime soon.
17:57:31 <araujo> That'd be a nice idea.
17:59:20 <shapr> I think it's about time we got a real web host.
17:59:44 <shapr> Maybe we can use the SoC mentor money for that?
17:59:51 <glguy> do you think that Haskell's community is big enough for that?
17:59:55 <glguy> (c:
18:00:17 <shapr> I think so.
18:00:22 <araujo> Me too.
18:00:27 <Lemmih> So do I.
18:00:32 <glguy> I considered that a joke
18:00:36 <glguy> not a question :)
18:00:37 <araujo> It'd be nice to have a service for darcs repo too!
18:01:38 <shapr> Hm, how do I add a directory to my library lookup path?
18:01:54 * araujo would like something like ruby forge
18:02:00 * edwardk_ is sitting here wondering what type errors would look like in a language where (.) was the same operation as map/fmap/liftM/liftW
18:02:02 <scsibug> shapr: what platform are you on?
18:02:17 <shapr> scsibug: debian/unstable
18:03:26 <shapr> I know the LD_PRELOAD bit, but that's for only one lib, right?
18:03:45 <scsibug> If I had to guess for debian... LD_LIBRARY_PATH
18:03:55 <shapr> ah, probably so. Thanks!
18:04:46 <scsibug> i'm usually better at questions like those for proprietary unices ;)
18:10:53 <dons> hmm. is haskell.org down ...?
18:10:54 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
18:11:04 <dons> this is getting silly
18:11:19 <araujo> :-(
18:15:02 <dons> Lemmih, shapr: I agree. Maybe we need a real host now
18:15:14 <sjanssen> what exactly was the problem with h.o last weekend?
18:15:39 <vincenz> Lemmih: lazy....
18:15:42 <vincenz> dons: Hi!
18:16:25 <dons> we don't know yet, sjanssen.the first time it went down, it had 150 simultaneous connections .... (which doesn't sound like too many)
18:17:02 <ndm> i think its important we figure out why it keeps going down before throwing a bigger server at it
18:17:09 <dons> yes. certainly
18:17:24 <dons> so I've mailed Paul Hudak, at Yale, who can get the admins there to look into it
18:17:55 <dons> we'll just have to wait for the admins, I think.
18:18:33 <ndm> i was going to tidy up the Yhc wiki as well...
18:19:04 <dons> maybe galois should take over haskell.org, as well as darcs.haskell.org
18:19:48 <Lemmih> vincenz: lazy?
18:19:57 <dons> the mailing list seems to also go down ?
18:21:06 <lennart> perhaps haskell.org needs to be hosted on an Erlang web server :)
18:21:15 <dons> heh
18:21:50 <lennart> they seem to handle 80000 connections when apache dies at a few thousand
18:23:08 <dons> mmm. nice!
18:25:13 <vincenz> Lemmih: bottoms!
18:32:02 <dons> ?remember BillWood it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
18:32:46 <dons> oh, Haskell job on the mailing list! :)
18:33:08 <dons> ah, US citizens only.
18:33:14 <glguy> huzzah!
18:33:17 <glguy> (c;
18:35:25 <Igloo> Hmm, they're multiplying
18:35:25 <glguy> ndm: you there?
18:36:39 <dons> Igloo: seems so.
18:36:41 <dons> yay!
18:36:59 <Igloo> yay?
18:37:09 <araujo> yay!
18:37:25 <Igloo> Ar eyou looking for jobs now, dons?
18:37:30 <glguy> yay!
18:37:46 <dons> not yet :) It's good to know that there's a market though
18:38:22 <dons> i'd be quite happy for haskell to be come synonymous with high security
18:39:10 <dolio> Well, once we scientifically establish Haskell as 5GL, there will be no problems with that.
18:39:17 <dons> heh
18:39:29 <araujo> 6GL!
18:39:30 <dons> oh boy that thread is just weird
18:39:39 <araujo> ?!
18:39:40 <lambdabot> Maybe you meant: . v
18:39:45 <dolio> Prolog is so widely used, after all. :)
18:39:47 <sjanssen> 6GL?  _weak_, we gotta be 11GL
18:40:15 <araujo> 6 is a better number
18:40:24 <dons> oh, for sure, sjanssen
18:40:27 <dons> at least 11.
18:40:37 <sjanssen> Haskell: We go to 11.
18:40:45 <dons> hehe
18:40:48 <araujo> Probably, 13 ...
18:40:51 <araujo> But 11?!
18:40:51 <glguy> shouldn't haskell' be 5 or at least 7
18:41:20 <newbcoder> yo
18:41:25 <newbcoder> someone here was supposed to teach me about arrows
18:41:27 <newbcoder> who is that person
18:41:35 <sjanssen> newbcoder: shapr
18:41:55 <newbcoder> shapr: yo; teach me about arrows
18:42:26 <dons> and Ceril Schmidt is working on finanical software in haskell that needs to handle contracts running past 2038. interesting!
18:42:33 <dons> so many secret haskell apps
18:43:23 <sjanssen> I can't wait until I run some random application and I get: "Exception: <<loop>>" or something, revealing it's a
18:43:30 <sjanssen> closet Haskell program
18:43:43 <newbcoder> bah; haskell programme4s are perffect
18:43:45 <newbcoder> they make no errors
18:43:46 <sjanssen> despite the bug, I'll be thrilled
18:43:50 <newbcoder> only typos
18:43:58 <dons> sjanssen: wouldn't that be such a great day :)
18:44:01 <edwardk_> dons: well, such contracts aren't unreasonable. I have encountered half a dozen leases with first right of refusal that had 99 year terms, etc.
18:44:20 <dons> oh sure. I know. it's cool someone's writing haskell code for it.
18:44:24 <edwardk_> *nods*
18:44:38 <dons> better than perl scripts for contracts
18:44:45 <edwardk_> yeah
18:45:28 <edwardk_> dons: you know of any bit stream manipulation code in haskell? i would like to be able to read a handful of bits at a time, and keep the rest around in state somewhere.
18:46:03 <edwardk_> i started mocking something up, but something existing and clean would be good ;)
18:46:25 <dons> well, you could write a layer over Data.ByteString.Lazy and Data.Bits
18:46:30 <dons> or possibly look at the new BitSyntax library
18:46:36 <edwardk_> bitsyntax?
18:46:56 <dons> ?where+ bitsyntax http://www.imperialviolet.org/binary/bitsyntax/
18:46:56 <lambdabot> Done.
18:47:18 <edwardk_> ah nice
18:47:23 <edwardk_> thats exactly what i needed
18:49:13 <edwardk_> "At the moment it's just plain lacking support for little-endian numbers." is a little awkward since i'm using it as part of my assembly generation code for intel, but hey ;)
18:51:45 <edwardk_> um, where is the source link from there? =)
18:52:38 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/14287/
18:52:41 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/pav5g
18:53:09 <edwardk_> nice
18:59:31 <newbcoder> is it just me
18:59:34 <newbcoder> or is haskell.org down?
18:59:38 <dons> it is down, yes.
19:00:00 <newbcoder> damn I can still ping it
19:00:03 <newbcoder> but I can't download ghc
19:00:09 <newbcoder> is there somewhere else I can get it from?
19:00:50 <dons> yep :/ you can stil get ghc from various mirrors. perhaps look at your os's package cache?
19:01:13 <dolio> Gentoo will have the source mirrored in various places.
19:01:26 <dolio> Although, that might only be for 6.4.x
19:01:34 <newbcoder> i need it for windows ....
19:01:43 <newbcoder> maybe that is my problem
19:01:48 <newbcoder> perhaps thsi is a sign to not use haskell on windows
19:02:03 <edwardk_> gah, hate generating little endian data portably. always feels so icky.
19:02:50 <newbcoder> fuck this; me go study erlang instaed
19:03:18 <dons> knock yourself out.
19:03:20 <edwardk_> cheerful
19:03:23 <dolio> Heh.
19:05:27 * scsibug gives future condolences to #erlang
19:05:59 <dons> heh
19:08:10 <dolio> Finally, reddit will settle the question of whether fixing a girl's computer is a good way to get laid.
19:08:53 <glguy> it can be
19:09:02 <glguy> some girls are impressed by skillz
19:09:14 <dolio> Bow hunting is better, though.
19:09:40 <sjanssen> dolio: a friend of mine tried that once.  She proceeded to talk to her boyfriend on MSN when he was done
19:09:50 <dolio> Hehehe.
19:10:08 <glguy> fixing computers maybe not
19:10:22 <glguy> but smarts go far with many hotties
19:10:43 <glguy> esp. if they are after their MRS degree
19:19:10 <edwardk_> gl: heh
19:20:26 <Korollary> You don't fix women's computers. You install trojan horses and collect personal information. *Then*, you can really score.
19:20:35 <Korollary> Wait. Was that out loud?
19:20:52 <glguy> that didn't workfor me
19:20:52 <dons> hah!
19:21:21 <dons> ?type execStateT
19:21:22 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
19:21:34 <dons> ?pl flip execStateT
19:21:35 <lambdabot> flip execStateT
19:23:39 <dolio> ?pl \(x,y) -> (x, f y)
19:23:40 <lambdabot> second f
19:25:14 <glguy> omg, peta is protesting the eating of cockroaches at six flags frightfest (c:
19:25:51 <edwardk_> glguy: well, glad to see they seem content to continue to further marginalize themselves
19:26:41 * mlh wonders when they start defending plants from being eaten
19:26:51 <glguy> the a stands for animals
19:27:02 <glguy> :-p
19:27:16 <scsibug> glguy: do you have a cite for that?
19:27:34 <glguy> the peta story?
19:27:44 <scsibug> not that I can't see them doing something that ridiculous, it's just that often it's not actually true
19:27:45 <scsibug> ya
19:27:50 <glguy> Local TV news
19:28:01 <glguy> channel 2 in StLouis, mo
19:28:03 <glguy> FOX
19:28:10 <scsibug> k, cool, just wondering
19:28:13 <dons> ah, must be true then. ;)
19:28:29 <dons> its not like fox would make up a story about PETA ...
19:28:42 <Korollary> It's sad when aussies know about Fox.
19:28:46 <sjanssen> oh Fox
19:28:52 <dons> hey, who do you think _owns_ Fox ...
19:29:03 <edwardk_> hahaha
19:29:14 <Korollary> well, you don't watch it, though. At least I hope you don't.
19:29:34 <edwardk_> Its truly sad when the only decent news show in America is the Daily Show ;)
19:29:39 <dons> heh
19:29:44 <Cale> edwardk_: it's true
19:29:52 <Korollary> Gravitas
19:29:55 <Cale> edwardk_: I like the Colbert Report as well though
19:29:56 <scsibug> countdown with keith olbermann has become pretty enjoyable
19:30:06 <scsibug> parts of it at least
19:30:14 <dons> Korollary: we get Jim Lehrer here on free to air, though
19:30:18 <edwardk_> I liked Colbert more when he was doing the short skits, but yeah, thats also ok.
19:30:45 <glguy> Fox National news is completely absurd, the local station is just standard garbage
19:30:46 <edwardk_> Jon Stewart spends more time being funny and on-topic, and less time being amused at his own stature than Colbert.
19:31:22 <Korollary> Colbert's writing is sometimes excellent.
19:31:49 <glguy> I really like Stewart's show
19:31:54 <edwardk_> *nods*
19:32:17 <Korollary> I think the new Seat of Heat segment is nonsense, though.
19:35:35 <edwardk_> haven't seen it yet.
19:36:13 <glguy> haven't seen it either
19:37:03 <edwardk_> I watched both fairly regularly maybe a year or so back, but I kind of stopped. I catch the occasional clip via youtube these days
19:37:35 <glguy> I only watch via youtube
19:37:46 <glguy> I'm not interested in paying for cable
19:43:25 <Korollary> Then you're missing out on Scrubs reruns on Comedy Central, too.
19:44:20 <sjanssen> what does it mean when I get "ghc-pkg: invalid package identifier:" from runghc Setup.hs install ?
19:44:27 <dylan> @tell dons I have a lambdabot on AIM and MSN (using a hack). @tell is quite useful there. :-D
19:44:28 <glguy> I watched all the scrubs already
19:44:29 <lambdabot> Consider it noted.
19:44:46 * dylan sleeps
19:44:49 <dons> dylan: heh!
19:44:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:44:55 <dons> excellent news.
19:44:57 <dons> dylan++
19:45:07 <dylan> dons: it's just a hack using bitlbee
19:45:15 <dons> ah tricky. good idea
19:45:25 <dons> a little howto on doing that might be useful ... :)
19:45:34 <dons> let me know if you want to submit any patches back
19:45:38 <dylan> need to add some commands for lambdabot to add/remove contacts
19:46:04 <dons> yeah, some kind of IM plugin might be useful
19:46:09 <dylan> heh, my first patch would probably be alternative @topic formats
19:46:10 <glguy> is "eighty" online?
19:46:13 <Korollary> glguy: You just didn't get me, Nicole.
19:46:39 <glguy> Korollary: it's been a while, I'm not going to be able to prove it with quote references )-:
19:46:43 <dylan> is there a command to make lambdabot say something in a particular channel?
19:46:58 <glguy> Korollary: but that's not to say they aren't worth memorizing, I loved watching scrubs
19:47:00 <dons> yeah, @msg #chan foo
19:47:10 <dylan> ah, easy as pants then.
19:47:13 <lambdabot> like this, dylan.
19:47:15 <dylan> but now sleep.
19:47:29 <dons> but you need to be in the 'priv' list in Config.hs
19:47:43 <glguy> dolio: you there?
19:48:49 <dolio> Here.
19:49:05 <glguy> did you put project euler on the back burner?
19:49:24 <dolio> Yeah, I've been doing other stuff the past couple days.
19:49:41 <dolio> And some a lot of the problems I have left require more than 5 minute solutions. :)
19:50:49 <glguy> does anyone know any sites like spoj or mathschallenge?
19:51:08 <glguy> that support haskell
19:54:07 <Korollary> Enough toy problems. Write me a Web 2.0 weather simulator in haskell plz. I'll take care of the IPO and the dining and the bribing of the SEC.
19:57:11 <glguy> toy problems give me something to work on
19:57:20 <glguy> I haven't figure out what meaningful project I want to work on
19:57:35 <Korollary> Dammit. And I was dreaming that I was unique in that.
19:57:41 <edwardk_> heh
19:57:57 <edwardk_> i've decided on several, the problem is picking one for the moment ;)
20:13:10 <dolio> > maximum [(1,2), (7,3), (0,6)]
20:13:12 <lambdabot>  (7,3)
20:13:34 <glguy> for a tuple, the first is compared, on a tie the second is too
20:14:39 <dolio> Yeah, that's what I was hoping for.
20:17:20 <syntaxfree> what's a recursion pattern equivalent to
20:17:20 <syntaxfree> recpat [] = id; recpat (f:fs) = f . (recpat fs)
20:17:27 <syntaxfree> (d'oh. foldl1 (.))
20:17:49 <glguy> yeah... foldr (.) id
20:18:00 <dolio> All right. for your pleasure, I have solved another problem. :)
20:18:08 <syntaxfree> What's the difference between foldl and foldr again?
20:18:24 <dons> > foldl const 0 [1..10]
20:18:25 <lambdabot>  0
20:18:30 <dons> > foldr const 0 [1..10]
20:18:31 <lambdabot>  1
20:18:37 <glguy> foldr version: is more like f . (g . h) while foldl is (f . g) . h
20:18:45 <dons> > foldr (flip const) 0 [1..10]
20:18:47 <lambdabot>  0
20:18:51 <dons> > foldl (flip const) 0 [1..10]
20:18:53 <lambdabot>  10
20:19:55 <syntaxfree> hmm.
20:20:08 <syntaxfree> I might need yet another fold pattern, in a somewhat contrived example.
20:20:24 <sjanssen> syntaxfree: visit foldr.com and foldl.com ;)
20:20:28 <glguy> you mean you don't get it yte?
20:20:36 <syntaxfree> I get it, yes.
20:20:43 <glguy> oh, ok
20:21:09 <glguy> so you were being sarcastic, eh?
20:21:59 <syntaxfree> nah, I'm inside a contrived example.
20:22:02 <syntaxfree> Will paste soon.
20:22:03 <syntaxfree> @paste
20:22:03 <lambdabot> http://paste.lisp.org/new/haskell
20:37:02 <dylan> hmm, this might be a bug:
20:37:08 <dylan> @elite 
20:37:09 <lambdabot> 
20:37:20 <Kahdloc> .....
20:37:26 <dylan> (utf-8, japanese)
20:37:41 <dylan> > ""
20:37:41 <lambdabot>  lexical error in string/character literal
20:37:53 <dons> i know its not nice for my terminal anyway...
20:38:01 <dylan> sorry. :(
20:38:18 <dylan> I've recently switched to UTF-8 land because it's hard to read manpages otherwise.
20:38:32 <dylan> and a friend of mine randomly says things in japanese.
20:39:40 <dylan> dons: it *mostly* preserves the japanese.
20:39:48 <dylan> it messes up about 5 of the chars
20:43:57 * dylan works to make @elite 8-bit clean
20:49:52 <dons> I'm preparing a little tut on writing robust network code in Haskell
20:49:58 <dons> using a irc bot as an example
20:50:12 <dons> the code is here, http://www.cse.unsw.edu.au/~dons/tmp/bot.hs
20:50:18 <dons> (that's the final version)
20:50:29 <dons> the tut will start by just getting connected and running a simple command
20:50:44 <dons> then we gradually add more robustness (using bracket, threads, and a state transformer)
20:50:59 <dons> if you've got any comments on the code, on bits that are too hard, too simple, too verbose, ping me
20:51:12 <glguy> bracket?
20:51:19 <syntaxfree> @elite what does this doe?
20:51:19 <lambdabot> Wh47 doeS 7hiz D03?
20:51:31 <dons> ?type Control.Exception.bracket
20:51:32 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:51:33 <syntaxfree> @elite Tttt
20:51:34 <lambdabot> TTTt
20:52:01 <dons> the code can still be improved, but the basics are ther
20:52:13 <glguy> I'll read through the bot.hs code
20:52:17 <dons> thanks
20:52:20 <glguy> and let you know if I have any resonse
20:52:24 <glguy> response
20:52:26 <dons> feel free to send patches
20:52:39 <dons> currenty it just implements the 'uptime' command
20:52:45 <dons> maybe there's something more fun we could do though
20:53:09 <dons> and the commandline interface should be improved too (its a bit too async atm)
20:53:21 <dons> sjanssen: if you wnt to have a look too, that'd be great
20:53:39 <glguy> ?type forever -- I can guess IO ()
20:53:41 <lambdabot> Not in scope: `forever'
20:53:57 <glguy> ah, forever a = a >> forever a
20:55:07 <edwardk_> is there a built-in command that acts like a hybrid gets/modify for state?
20:55:21 <glguy> modify and store ?
20:55:40 <glguy> (not to my knowledge)
20:55:52 <edwardk_> tweak f g = do s <- get; put $ f s; return g s
20:55:58 <edwardk_> or something like that
20:55:59 <dons> modify?
20:56:01 <edwardk_> er $
20:56:06 <dons> ?hoogle modify
20:56:06 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
20:56:06 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
20:56:06 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
20:56:09 <edwardk_> modify returns ()
20:56:20 <edwardk_> i want to be able to return a result of the computation
20:56:37 <glguy> edwardk_: I'm pretty sure that Control.Monad.State doesn't define anything like that
20:56:39 <edwardk_> i can do the manual construction of s <- get;; put $ f s; return $ g s
20:56:44 <dons> ?type Control.Concurrent.MVar withMVar
20:56:45 <lambdabot> Not in scope: data constructor `Control.Concurrent.MVar'
20:56:45 <lambdabot>  
20:56:45 <lambdabot> <interactive>:1:24: Not in scope: `withMVar'
20:56:49 <edwardk_> but i was wondering if there was one around
20:56:49 <dons> ?hoogle MVar
20:56:50 <lambdabot> Control.Concurrent.MVar :: module
20:56:51 <lambdabot> GHC.Conc.MVar :: data MVar a
20:56:51 <lambdabot> Control.Concurrent.STM.TMVar :: module
20:56:51 <edwardk_> oh well
20:57:25 <edwardk_> i just wasted 20 minutes digging for a function that isn't there ;)
20:57:33 <dons> ?docs Control.Monad.State
20:57:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
20:57:51 <glguy> get >>= \s -> modify f >> return g s  is probably the best you can get
20:58:18 <dolio> ?hoogle fold
20:58:19 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
20:58:19 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
20:58:19 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
20:58:24 <edwardk_> well, that and i want to mangle the signature a bit so its not quite that, but yeah
20:59:50 <glguy> dons: so bracket has a before action, a during action, and an action that runs regardless of whether or not the body fails?
21:00:02 <edwardk_> @type runState
21:00:03 <lambdabot> forall s a. State s a -> s -> (a, s)
21:02:21 <dons> glguy: yep
21:02:32 <dons> currently we don't do anything after, but perhaps it should 'quit' there.
21:02:44 <dons> also, i'm not sure about the command line.. is it an irc client or a bot?
21:03:02 <dons> perhaps i could add a simple console interface and turn it into a client?
21:03:22 <glguy> perhaps, I do like how you demonstrate how to use it as both
21:03:40 <dons> yeah, thats good. I certainly want to show forkIO
21:04:51 <dons> here's a nice colourised version http://www.cse.unsw.edu.au/~dons/tmp/bot.html
21:04:52 <lambdabot> Title: Haskell Code by HsColour
21:05:11 <glguy> dons: do you: io=liftIO
21:05:15 <glguy> because lift sounds scary?
21:05:26 <dons> yeah, I think 'io' is just simpler, and looks incer
21:05:35 <dons> I use it in practice a lot (i.e. in lambdabot)
21:06:19 <dons> needs a better motivating example though. 'uptime' is kinda boring
21:06:26 <edwardk_> @paste
21:06:27 <lambdabot> http://paste.lisp.org/new/haskell
21:06:30 <glguy> how about a channel takeover?
21:06:30 <dons> perhaps 'localtime' would be better
21:06:37 <glguy> ;)
21:06:41 <dons> hmm....
21:07:05 <dons> i like this:      ircRun s | ping s = pong s
21:07:06 <dons> :)
21:07:29 <lisppaste2> edwardk pasted "feeling stupid for a sec. whats wrong?" at http://paste.lisp.org/display/26763
21:07:53 * glguy has never seen multple declarations with guards
21:08:00 <glguy> like in ircRun
21:08:01 <edwardk_> hehehe thats cute dons
21:09:24 <dmwit> ?type .|.
21:09:25 <lambdabot> parse error on input `.|.'
21:09:35 <dmwit> ?index .|.
21:09:35 <edwardk_> @type (.|.)
21:09:35 <lambdabot> Data.Bits, Foreign
21:09:37 <lambdabot> forall a. (Bits a) => a -> a -> a
21:09:43 <edwardk_> bitwise or
21:10:52 <glguy> dons: do you think it would be useful to introduce named records in data S? and then use them in socket and time?
21:11:08 <edwardk_> basically want to take a byte stream and read off a int in little endian order, nothing too earthshaking, just doesn't want to type check for some reason =)
21:11:10 <dons> yeah, that's a better idea
21:11:12 <glguy> so you could say gets socketField?
21:11:38 <dons> yep, 'gets socket' seems nice
21:11:42 <glguy> or maybe name the records socket and time
21:11:42 <glguy> yeah
21:11:44 <lisppaste2> syntaxfree pasted "why isn't basic pattern matching working?" at http://paste.lisp.org/display/26764
21:11:51 <glguy> and the function getSocket, so that they can see that it's an action
21:12:41 <dons> I think as a final extension I'll add a simple irssi-like curses interface
21:12:47 <dons> it'd be only a few lines of code
21:13:07 <ThreeQ> syntaxfree: I don't think you can intersperse the definition of biparse1 and biparse2
21:13:24 <glguy> dons: why do you use do-notation on msg h s = ?
21:13:24 <edwardk_> syntax: isn't there a restriction where you have to pout all multiple definitions for a function in sequence before moving on to the next function?
21:13:34 <syntaxfree> not AFAIK.
21:13:50 <syntaxfree> Pattern matching happens in sequence, so order matters. That's pretty much everything, isn't?
21:14:03 <dons> glguy: ah right. typo
21:14:08 <dons> (i refactored that line )
21:14:12 <syntaxfree> oh jesus. It was it.
21:14:20 <syntaxfree> That's not Right.
21:14:36 <edwardk_> that way it can 'seal' the function or something like that. and write the code for the otherwise case that errors
21:15:31 <edwardk_> so no thoughts on my little monadstate problem?
21:15:57 <syntaxfree> oh god. (:) is painfully different from cons.
21:16:07 <edwardk_> syn: ?
21:16:17 <syntaxfree> in particular, there's no way to cons nothing to a list.
21:16:17 * dons -> uni
21:16:34 <syntaxfree> for example, there's no "empty"  char ''.
21:16:39 <edwardk_> *nods*
21:17:10 <syntaxfree> damn statically-typed languages :P
21:17:24 <dolio> ?index foldl'
21:17:25 <lambdabot> Data.List
21:18:53 <jcreigh> syntaxfree: I don't understand. How would you cons "nothing" to a list in lisp?
21:19:17 <syntaxfree> oh true. You can't, either.
21:19:28 <glguy> its exactly the same
21:19:48 <glguy> except cons allows dotted lists
21:19:55 <syntaxfree> Dotted lists are tuples.
21:20:06 <edwardk_> ok, then I can stop combing lisp references for some obscure use of cons I never knew about ;)
21:20:24 <deadbeef> hi dear friends
21:20:24 <deadbeef> sup
21:20:38 <glguy> (1 2 3 . 4) is a tuple?
21:20:50 <monochrom> Hi. Is "deadbeef" the same as "fresh steak"? :)
21:21:05 <edwardk_> heh, was going to ask him if he'd seen cafebabe
21:21:05 <monochrom> (1 2 3 . 4) does not look like a tuple.
21:21:32 <deadbeef> monochrom: yes
21:21:35 <deadbeef> > 0xdeadbeef
21:21:37 <lambdabot>  3735928559
21:21:38 <glguy> 23:19  glguy> except cons allows dotted lists
21:21:39 <glguy> 23:19  syntaxfree> Dotted lists are tuples.23:19  glguy> except cons allows dotted lists
21:21:45 <monochrom> Hmm, going to a cafe for cafebabe is a good idea after a deadbeef dinner.
21:21:45 <dolio> What is that?  ((1 2 3) . 4)?
21:21:46 <chessguy> ?type (1 2 3 . 4)
21:21:46 <ThreeQ> (1 2 3 . 4) is (1 . (2 . (3 . 4)))
21:21:48 <lambdabot> forall c a. (Num (Integer -> Integer -> b -> c), Num (a -> b)) => a -> c
21:22:09 <ThreeQ> the last cons cell has two values rather than a value and the empty list
21:22:14 <syntaxfree> Isn't ( 1 2 3 . 4)  the same as ([1,2,3], 4 ?
21:22:31 <glguy> not really?
21:22:34 <Korollary> not really
21:22:39 <syntaxfree> ([1,2,3], 4)
21:22:47 <Korollary> the 1,2,3 bit is not a proper list either
21:22:48 <syntaxfree> oh god, I never grokked dotted lists then.
21:22:55 <ThreeQ> no, there's no list in there at all
21:22:56 <dolio> Then it's (1, (2, (3, 4)))
21:22:59 <ThreeQ> yeah
21:23:09 <jcreigh> (cons 1 (cons 2 (cons 3 4)))
21:23:14 <ThreeQ> you need an empty list somewhere in the conses for it to be a real list
21:23:27 <jcreigh> which is not a proper list.
21:25:14 <glguy> note for non-LISPers, the cons/dotted list discussion is LISP stuff, not crazy Haskell syntax you haven't heard about (c:
21:26:41 <jcreigh> heh
21:27:16 <dolio> I guess (,) is closest to cons, then.
21:27:24 <dolio> Since you can cons two different types.
21:27:32 <glguy> yeah, I'd say it's exactly the same
21:28:07 <dolio> And then lisp lists are () or (,) a <list>
21:28:09 <glguy> but haskell would not allow you do define a function that worked on those
21:28:14 <glguy> of any arbitrary list length
21:28:54 <glguy> since the length becomes part of the type
21:29:22 <glguy> (there are heterogeneous lists somewhere, but they must work differently)
21:30:51 <glguy> ?type (1,(2,(3,())))
21:30:52 <lambdabot> forall a a1 a2. (Num a, Num a1, Num a2) => (a, (a1, (a2, ())))
21:31:16 <dolio> It becomes type-level programming.
21:32:14 <dolio> You have a type for nil and a type for cons, and then lists are specified by a typeclass constraint over combinations of those two.
21:34:49 <lisppaste2> edwardk annotated #26763 with "doh. missing fromIntegral" at http://paste.lisp.org/display/26763#1
21:35:28 <edwardk_> the missing shl type annotation and fromIntegral on a combined to make it hard to find the error
21:43:38 <glguy> ?type concatMapM
21:43:40 <lambdabot> Not in scope: `concatMapM'
21:43:43 <glguy> :(
21:44:42 <monochrom> What would you like concatMapM to mean?
21:45:03 <glguy> I'll just call concat on the results :)
21:45:40 <glguy> concatMap is just (concat .) . map, so I'll just do the same
21:55:09 <glguy> ?type lookup
21:55:11 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
21:56:01 <monochrom> There is also Data.Map.lookup.
22:03:26 <syntaxfree> is this well-known?
22:03:27 <syntaxfree> http://pleac.sourceforge.net/pleac_haskell/index.html
22:03:29 <lambdabot> http://tinyurl.com/jv3us
22:06:13 <sjanssen> syntaxfree: I know of it
22:06:31 <sjanssen> I also know that the code contained there is horrible, and should not be used to learn Haskell
22:06:55 <Korollary> It seems old.
22:07:08 <syntaxfree> the helper functions seem to define a mini-Perl of sorts.
22:07:28 <sjanssen> Korollary: it calls for GHC 5.002
22:07:35 <edwardk_> gah haskell.org being fried makes it really really hard to do any template haskell ;)
22:08:02 <monochrom> Oh haskell.org is fried again?
22:08:09 <sjanssen> syntaxfree: yes, and tons of operators are redefined to totally non standard things
22:08:19 <edwardk_> seems so
22:08:31 <sjanssen> like x . f = f x, etc.
22:08:32 <syntaxfree> anyway, is there a predefined data type like a hash or a dictionary?
22:08:41 <syntaxfree> x . f = f x is horrible.
22:08:47 <sjanssen> syntaxfree: Data.Map
22:09:04 <sjanssen> I'd point you to the docs on haskell.org, but . . .
22:09:14 <syntaxfree> I can find them :)
22:09:32 <sjanssen> you can find them tomorrow, haskell.org is down for today
22:09:43 <syntaxfree> I was mid way through writing newtype  Hash a = [(String, a)], etc. etc.
22:09:50 <syntaxfree> yes, but I have a local copy of the GHC docs!
22:09:58 * syntaxfree no contaban con mi astucia!
22:10:01 <sjanssen> good plan
22:10:14 <syntaxfree> It's not a plan. They shipped with GHC.
22:10:36 <syntaxfree> When it winds hard here, I'm left without internet access for days.
22:11:51 <monochrom> Good plan to install ghc on your computer instead of relying on a "web IDE".
22:12:14 <syntaxfree> are there web IDEs for Haskell?
22:12:40 <monochrom> Well if there is going to be a "web forum" for Haskell, a "web IDE" will not be too far away.
22:12:41 <weitzman> > 1 + 1
22:12:42 <lambdabot>  2
22:12:50 <weitzman> Lambdabot is my web IDE
22:12:57 <monochrom> Heh
22:13:04 <weitzman> I used it for a while before I installed actually Haskell
22:13:07 <syntaxfree> It could prove useful. I find myself having to install GHC at random computers just to get a marginal ammount of work done.
22:13:09 <weitzman> Probably at least a week
22:13:58 <syntaxfree> Actually Haskell. New compiler?
22:14:15 <weitzman> No. I need to make a plugin for my IRC client that makes me proofread everything I try to send
22:14:29 <monochrom> I think "installed actually" is just fine.
22:14:50 <weitzman> I'm always rewriting my sentences halfway through typing them
22:15:15 <monochrom> You have the total freedom of using an adverb as a prefix, infix, or postfix operator.
22:15:42 <weitzman> I don't think adverbs are typically after the verbs they describe in english, even if some guide somewhere says it's ok
22:15:53 <weitzman> Well, it can happen
22:15:58 <weitzman> "He ran quickly"
22:16:09 <weitzman> But I'm not feeling good about "installed actually"
22:16:11 <Cale> weitzman: I was thinking of that exact sentence.
22:16:45 <weitzman> "ran" is intransitive
22:17:00 <weitzman> I think that may be the key
22:17:04 <monochrom> If you use Latin, you can reorder anything.
22:17:15 <syntaxfree> are Map and Reduce as in Google MapReduce actually map and foldr?
22:17:30 <weitzman> Propositions still belong in front of their objects in latin, but you're mostly free
22:17:39 <weitzman> *pre
22:17:42 <syntaxfree> anyway, while we're being grammar nazis, may I  note you don't install "Haskell".
22:17:54 <monochrom> Oh yeah, can't move prepositions.
22:18:47 <monochrom> That's semantics nazi, syntaxfree.
22:19:05 <syntaxfree> well,. grammar == syntax?
22:19:24 <monochrom> Yeah.  "I always install the Internet" is perfectly good grammar. :)
22:19:33 <syntaxfree> It's perfectly good syntax.
22:19:33 <weitzman> I installed two Haskell 98 (TM)-compliant applications for executing Haskell programs
22:20:10 <syntaxfree> Not perfectly good grammar.
22:20:14 <weitzman> At least I would like to believe they're compliant
22:20:57 <monochrom> What is grammar?
22:21:32 <weitzman> Is the Haskell language spec on haskell.org the most formal spec around?
22:21:43 <bringert> weitzman: yes
22:21:53 <weitzman> I'm curious because it contains a lot of English text in comparison to the SML spec
22:22:07 <bringert> I don't think that there is any totally Haskell98 compliant implementation
22:22:19 <weitzman> I was expecting something more along the lines of what you'd see in a type-theory paper
22:22:20 <bringert> but they mostly leave out stuff noone ever uses
22:22:30 <bringert> like local fixity declarations
22:25:13 <syntaxfree> Are catamorphisms and anamorphisms defined as cat theory morphisms?
22:25:42 <monochrom> yes
22:30:12 <syntaxfree> a lot of understanding some older papers is understanding the notation.
22:30:29 <syntaxfree> what's with writing foldr b f as ([b,f]) ?
22:30:48 <Korollary> Then you don't get to give your paper a cute title.
22:31:22 <syntaxfree> Economists can't give cute titles to papers.
22:31:40 <syntaxfree> Can I say one curse word?
22:31:42 <dolio> foldr was around back then, wasn't it? They talk about someone using that notation (Bird?).
22:31:47 <dolio> They just decide not to use it. :)
22:32:33 <monochrom> "foldr b f" does not generalize.
22:32:45 <dolio> Plus, they had to make use of their fancy AMS Euler typesetting.
22:33:34 <syntaxfree> that, too.
22:33:42 <syntaxfree> Though I keep using Charter.
22:33:48 <syntaxfree> Computer Modern has no character.
22:33:50 <Korollary> I cursed on your behalf.
22:33:54 <dolio> But in Bananas in space they use "cata" and "ana".
22:33:58 <dolio> Since it's written in Gopher.
22:34:16 <syntaxfree> isn't Gopher like Haskell Minus?
22:34:26 <Korollary> that's gofer.
22:34:40 <dolio> Is it gofer or gopher?
22:35:16 <dolio> Oh, it is gofer.
22:36:27 <dolio> It probably wasn't Haskell minus back in the day.
22:36:36 <dolio> It even had monad comprehensions!
22:38:04 <syntaxfree> I don't see why they did away with monad comprehensions.
22:38:21 <dolio> Bad error messages?
22:38:32 <glguy> too hard on the newbs I heard
22:38:44 <syntaxfree> Monads are too hard on the newbs.
22:38:55 <lispy> yes, too hard for newbs is the main reason
22:38:57 <glguy> take em out!
22:38:59 <syntaxfree> Actually, QWERTY keyboards are too hard for the newbs.
22:39:27 <lispy> i think H98 is mostly for teaching
22:39:29 <dolio> Going back to CPS I/O will help the newbies.
22:39:52 <syntaxfree> cps i/o?
22:39:57 <lispy> H98 + ghc extensions == real world programming
22:40:02 <glguy> continuation passing style
22:40:04 <lispy> syntaxfree: continuation passing style
22:40:06 <syntaxfree> I thought old I/O was just infinite strings.
22:40:11 <syntaxfree> yes, I know what CPS means.
22:40:19 <glguy> IO went through a few attempts
22:40:31 <dolio> There were two alternatives described in the history paper.
22:40:40 <dolio> Stream-based and CPS-based.
22:40:56 <dolio> Which you can transform into each other.
22:41:13 <monochrom> I bought a copy of Andrew Gordon's thesis on the observational equivalence of the three. :)
22:42:14 <syntaxfree> so, why is monadic I/O vastly superior to CPS I/O?
22:43:15 <dolio> do notation?
22:43:21 <lispy> it's closer to conventional i/o?
22:43:22 <lisppaste2> glguy pasted "Any obvious performance killers?" at http://paste.lisp.org/display/26767
22:43:38 <syntaxfree> so it's less haskell-like?
22:43:46 <monochrom> Perhaps CPS is a bit hard for newbies
22:43:54 <lispy> glguy: you're not using Data.ByteString?
22:44:01 <glguy> lispy: not an option
22:44:13 <monochrom> Actually CPS is a bit hard for me too, and I am not a newbie.
22:44:34 * glguy points his finger wildly
22:44:39 <glguy> monochrom's a newb!
22:44:41 <dolio> You could probably implement a CPS-based IO as a monad.
22:44:46 <dolio> Since CPS transform is a monad.
22:45:05 <lispy> there is a CPS monad so i'd bet yes
22:45:11 <monochrom> Stream would be a good choice if there were arrows back then.
22:45:23 <lispy> glguy: without profiling i'm useless for finding haskell optimizations
22:45:33 <glguy> ah, profiling... good idea (c:
22:45:51 <glguy> lispy: one problem is that i don't have a large dataset to profileon
22:45:59 <dolio> The CPS-based IO in the history paper actually looks a lot like monadic IO without the sugar, and I think they mentioned that they could probably write sugar for IO based on it.
22:46:06 <lispy> glguy: oh, well better make one :)
22:46:10 <dolio> But if you write sugar for monads, you get it for IO as a special case.
22:46:10 <glguy> lispy: what flags do I need to profile?
22:46:22 <lispy> glguy: do you know the scenario that achieves the asymptotic performance?
22:46:23 <glguy> -p -auto-all ?
22:46:35 <syntaxfree> Do notation considered harmful.
22:46:36 <lispy> glguy: i think that works, are you using cabal?
22:46:50 <glguy> lispy: visual haskell
22:46:56 <lispy> glguy: with cabal I think you can just pass -p but i don't know if that implies -auto-all
22:47:31 <lispy> glguy: ah, well open up your .cabal file and add --prof -auto-all (or check the manual for the exact number of ----'s) and then build
22:47:54 <lispy> glguy: you should be able to add a stanza for ghc options
22:48:19 <lispy> glguy: also, STUArray probably isn't very fast
22:48:27 <lispy> glguy: can you use IO or IOU array?
22:48:34 <lispy> glguy: if so, use it with unsafe read/write
22:48:43 <lispy> glguy: look at dons UM implementation for ideas
22:48:47 <glguy> lispy: I could try (never done it)
22:49:04 <dolio> STUArray isn't fast?
22:49:14 <lispy> i don't think so...is it mutable?
22:49:20 <dolio> Yeah.
22:49:23 <sjanssen> I imagine STUArray and IOUArray are the same
22:49:26 <lispy> maybe STUArray is like IOUArray
22:49:40 <glguy> I mentioned using IOArray in #haskell once
22:49:43 <glguy> they attacked me
22:49:43 <sjanssen> actually, I bet IOUArray is like STUArray
22:49:53 <lispy> okay, cool
22:50:14 <lispy> glguy: also, if you strictify things used in your 'inner loops' that generally helps
22:51:03 <lispy> glguy: as you can probably tell, i'm mostly just spewing general ideas
22:51:08 <lispy> glguy: not sure how to apply them
22:51:26 <glguy> kk
22:51:41 <lispy> glguy: can you inline anything?
22:51:41 <sjanssen> glguy: this a SPOJ problem, BLINNET or something like that?
22:51:46 <glguy> yeah
22:51:59 <syntaxfree> TMTLA.
22:52:10 <glguy> My program works, now I have ot figure out how to slam haskell into the time constraints
22:52:17 <glguy> TMTLA?
22:53:26 <sjanssen> glguy: good luck, I got a TLE with one of my C++ submissions
22:53:29 <lispy> ?google jargon file TMTLA
22:53:30 <lambdabot> No Result Found.
22:53:37 <lispy> TLE?
22:53:38 <sjanssen> not sure if I was using a dumb acronym though
22:53:46 <sjanssen> time limit exceeded
22:53:46 <glguy> time limit exceeded
22:53:50 <lispy> ah
22:54:11 <lispy> i want to try SPOJ but the server has timed out all 3 times i've tried to go to the site...i sort of gave up
22:54:40 <sjanssen> SPOJ can be really slow at times, I don't really know why
22:54:56 <lispy> sjanssen: maybe they run code on the same machine that serves web?
22:55:22 <glguy> what flags do you run main with to make prof output something? -RTS?
22:55:39 <dolio> +RTS -p
22:55:42 <lispy> +RTS -p
22:55:52 <lispy> or more pedanticly, +RTS -p -RTS
22:56:33 <lispy> glguy: i bet the line 'map read . words $ line' is pretty slow, but i'm not sure what to do about it
22:56:41 <lispy> seems like a necessary evil
22:57:19 <lispy> is kruskal the best you can do in terms of big O
22:57:24 <lispy> maybe it has a really bad constant?
22:57:54 <glguy> i could try prims
22:57:56 <sjanssen> I used Prim's algorithm, but I think they tend to be quite similar in performance
22:58:21 <lispy> also on a style not, kruskal l h es = runST $ do ... would be a bit easier to read even though it uses the evil ($) function
22:58:38 <glguy> lispy: I can't use $ there
22:58:54 <glguy> ghc complains that the exisential type variable would leak
22:58:58 <lispy> because of polymorphism?
22:59:03 <glguy> that's a known issue
22:59:04 <lispy> hmm...interesting
22:59:53 <glguy> UDG_HOME env var not set?
22:59:58 <glguy> wtf is udg
23:00:04 <lispy> glguy: do you know how to do cost center profiling?
23:00:15 <glguy> this is my first foray into profiling
23:00:15 <lispy> what gave you that error?
23:00:21 <glguy> ghcprof.prl
23:00:21 <lispy> i've never seen that
23:00:29 <lispy> ghcprof.prl?
23:00:36 <lispy> hmm...
23:00:48 <lispy> i've never done profiling with visual hasklel before
23:00:57 <glguy> that isn't from visual haskell
23:01:11 <glguy> if ($ENV{'UDG_HOME'}) { $udrawgraphhome = $ENV{'UDG_HOME'}; $udrawgraph     = $udrawgraphhome . "/bin/uDrawGraph";
23:01:42 <lispy> you place {-# SCC "name" #-} in the right places then ghc will profile more effectively...there are rules on where you can place the annotations and you get really messed up parse errors when you palce one in a bad spot
23:03:58 <glguy> lol, main.prof is plain text
23:04:02 <lispy> right
23:04:13 <glguy> and here I am trying to figure out what program reads it
23:04:17 <sjanssen> glguy: from SPOJ's logs I can see your program is eating a lot of memory, you'll probably need to solve that
23:04:21 <lispy> hehe, sorry, should have told you
23:04:29 <glguy> sjanssen: it's a large problem set problem
23:05:03 <lispy> glguy: the first step is to look at the whole program statitstics in very general manner, then focus in on one part, optimize the hell out of it and then step back again
23:05:10 <glguy> but I guess the best solution uses 1.6k
23:05:19 <glguy> but others use 20k
23:05:29 <lispy> how much does yours use?
23:05:30 <sjanssen> glguy: your program is about 6 times many other submissions
23:05:40 <sjanssen> 4,364
23:05:44 <lispy> glguy: i bet if you make things more strict you can use less memory
23:05:48 <glguy> the java submission uses 190848
23:05:49 <glguy> :)
23:06:15 <lispy> glguy: you might want to look into retainer profiling in the ghc manual
23:06:21 <glguy> ok
23:06:43 <satan> hello all
23:07:22 <satan> is it possible for the type bottom, _|_ to be of a certain type, like Bool or Char?
23:07:34 <Korollary> bottom is a value
23:07:34 <sjanssen> satan: yes
23:07:42 <glguy> readCity is doing the majority of allocation
23:07:43 <dolio> ?type undefined :: Int
23:07:45 <lambdabot> Int :: Int
23:07:45 <sjanssen> oh, I'm wrong
23:07:57 <satan> so, bottom is a value?
23:08:04 <glguy> which makes sense, but i guess I can focus attention there
23:08:14 <Korollary> yes. It belongs to every boxed type, including char and bool.
23:08:27 <sjanssen> glguy: replicateM readRoad is very bad there
23:08:37 <satan> how would i show that a certain _|_ is of type bool? or char? or int or whatever
23:08:42 <glguy> sjanssen: replacement ideas?
23:08:59 <monochrom> Perform a type inference.
23:09:29 <satan> i'm new to all this :)
23:09:41 <Korollary> satan: You don't really inspect a certain runtime value's type in haskell (a la RTTI).
23:09:57 <satan> Korollary: ah i see
23:10:14 <sjanssen> glguy: I'd probably do getContents >>= parse . lines
23:10:26 <sjanssen> for a sufficient definition of parse
23:10:34 <sjanssen> s/lines/words
23:11:03 <satan> monochrom: how would i perform a type inference as you said?
23:11:28 <lispy> glguy: readRoad = {-# SCC "readRoad" #-} do ... should help your profile
23:11:43 <lispy> glguy: that way you can see how much just readRoad is using
23:11:49 <kosmikus> satan: what do you really want to do?
23:12:24 <Cale> satan: well, you'd carry out type checking/inference on your whole program, and depending on the types assigned to places where that term was used, you'd get equations that the type would have to satisfy
23:12:47 <weitzman> @type undefined :: Bool
23:12:48 <lambdabot> Bool :: Bool
23:12:51 <weitzman> @type undefined
23:12:52 <lambdabot> forall a. a
23:12:57 <satan> i'm trying to define a function that returns different values based on different arguments, it's from the book, 'Introduction to Haskell Programming'
23:13:24 <dibblego> satan, f = (* 2)
23:13:41 <satan> so i think i have the right answer or the right approach anyway, but seem stuck on that bit
23:13:45 <Cale> > let f x = if x < 0 then 0 else 1 in map f [-10..10]
23:13:47 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1]
23:14:09 <satan> dibblego: what does that do, apart from the obvious?
23:14:15 <glguy> ok, so readRoad is doing 60% of the work
23:14:27 <Cale> satan: it's the function which multiplies by 2
23:14:35 <dibblego> satan, returns a different value based on its arguments pretty much; given 2, it returns 4, 3, returns 6, etc.
23:14:37 <satan> right
23:14:51 <monochrom> Most functions return different values based on different arguments.  Take, for example, "f x = x".  An argument of True and an argument of False lead to different return values.
23:15:04 <satan> maybe i should type this question out
23:15:09 <satan> may i?
23:15:13 <Korollary> @paste
23:15:14 <lambdabot> http://paste.lisp.org/new/haskell
23:15:19 <monochrom> As long as you don't write like "f x = 1" you're returning different values.
23:15:38 <satan> lemme just show ya, one sec
23:15:46 <weitzman> f (x :: ()) = x
23:16:28 <glguy> who had the fast int reading code?
23:16:45 <Korollary> It was in the cafe mailing list.
23:16:53 <monochrom> That one returns () or bottom depending on the argument :)
23:17:32 <lispy> glguy: dunno, check the mail list
23:18:01 <satan> ok http://nanobin.nanosouffle.net/1674
23:18:04 <lambdabot> Title: nanoPaste your Crap
23:18:08 <Korollary> lol
23:18:16 <satan> lol
23:18:38 <satan> ok so what i thought was that when its called with Left _|_, it returns bottom of type Bool
23:18:51 <satan> and when called with Right _|_, returns bottom of type Char
23:18:54 <Korollary> right
23:19:03 <satan> or am i totally wrong?
23:19:25 <weitzman> It doesn't say what the type of your function should be
23:19:26 <satan> and what type is the bottom when just called with _|_ ? is it of type _|_?
23:19:29 <Korollary> line 6,7, the functions left & right should be lowercase
23:19:32 <sjanssen> glguy: this isn't related to Haskell, but I recommend that you reread the problem description (esp. regarding limits of paramters/output) very carefully before you submit
23:19:57 <satan> the function has to be of source type Either Bool Char
23:20:03 <weitzman> True
23:20:08 <weitzman> But the result is not specified
23:20:11 <glguy> sjanssen: because 2^32 - 1 requires an unsigned int?
23:20:13 <satan> right
23:20:18 <satan> so if i declare a function, say f
23:20:29 <Korollary> satan: They are all the same type
23:20:42 <sjanssen> glguy: yeah, a Word or Word32 in Haskell
23:20:50 <satan> and it takes type, will it be f :: Either Bool Char -> Either Bool Char
23:20:58 <satan> Korollary: i see, hmm
23:21:09 <glguy> ?index Word
23:21:10 <lambdabot> Data.Word, Foreign, GHC.Exts
23:21:18 <lispy> glguy: how is ST different than State?
23:21:18 <monochrom> It is more convincing (of different behaviours) if you return, say, numbers.
23:21:22 <lispy> ?index ST
23:21:23 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
23:21:28 <glguy> lispy: nearly unrelated
23:21:33 <satan> and then i guess, the function body might be f Left _|_ = Bool _|_
23:21:36 <sjanssen> lispy: ST is like IO without input or output
23:21:47 <sjanssen> ie. mutable references and arrays
23:21:51 <satan> see, i want a way to specify that that _|_ is different from the others, thats where i'm stuck
23:21:57 <lispy> sjanssen: ah cool
23:22:07 <lispy> can we use ST with lambdabot?
23:22:10 <lispy> guess i've never tried
23:22:35 <Korollary> satan: You can match on a value that is Left _|_. The problem is meant to teach you pattern matching.
23:22:36 <sjanssen> I don't think so.  The types require -fglasgow-exts, which is shut off for safety
23:22:44 <weitzman> satan: The problem specification doesn't say that f (Left True) and (Left (_|_)) need to have different behavior
23:22:51 <dolio> > runST (return 3) :: Int
23:22:52 <lispy> sjanssen: gotcha
23:22:53 <lambdabot>  3
23:23:02 <lispy> heh, maybe not though!
23:23:26 <lispy> well, i should be off to bed
23:23:29 <lispy> night all!
23:23:32 <satan> Korollary: oh i see, so just  f Left _|_ =  _|_ would be accurate then, as would  f Right _|_ = _|_ and f _|_ = _|_
23:23:34 <dolio> Night.
23:23:39 <satan> weitzman: right
23:23:55 <satan> maybe i should be using a different book :)
23:24:14 <sjanssen> > runST (unsafeIOToST (return 2))
23:24:16 <lambdabot>  2
23:24:23 <monochrom> Or read the same book but with a different way.
23:24:26 <sjanssen> dons: you need to fix lambdabot
23:24:51 <Korollary> satan: well, you can't really use _|_ literally. If you say f (Left _) = stuff, it will match Left True as well as Left _|_.
23:25:04 <weitzman> I think the author intended that you return something of a very different type that Either. Like Bool or Int
23:25:17 <weitzman> s/that/than/
23:25:51 <satan> but if its one function that must handle all 3 arguments and return 3 diff things, what can its function declaration or return type be?
23:26:15 <Korollary> It could be Either -> Int if you like.
23:26:19 <weitzman> Technically it doesn't say "return three different things"
23:26:30 <weitzman> It says three different "behaviors"
23:26:47 <satan> hmm you're right
23:26:54 <monochrom> Don't worry about "f _|_" being different yet.  Most probably you'll have it for free.  Worry about the first two cases.
23:27:20 <satan> ok, let me try that then
23:28:18 <satan> f :: Either Bool Char -> ??something??
23:28:33 <satan> or Int, as Korollary suggested, but i don't see why
23:28:48 <satan> sorry if this is really trivial for all you guys
23:29:29 <monochrom> I am also skeptic about "_|_ of type Bool" (Gosh is it the 21st Century and may I use the Unicode code point  already?) and " of type Char" being "different".  They have different types, but I am not sure they are regarded to behave differently.
23:29:48 <weitzman> satan: I believe Korollary suggested Int because it's really easy to construct an Int (as opposed to more exotic datatypes)
23:30:10 <satan> ah i see weitzman
23:30:26 <monochrom> For the recording, "f :: Either Bool Char -> Bool" also avails three different behaviours.
23:30:33 <monochrom> s/recording/record/
23:30:47 <satan> well, how would i specify _|_ as an argument if I cant write _|_ literally? say on paper anyway
23:31:32 <glguy> > let read' = foldl' (\a x -> a * 10 + (ord x - 48)) 0 in read' "314159"
23:31:33 <lambdabot>  314159
23:32:09 <weitzman> satan: "undefined" is an easy way to get a _|_
23:32:16 <weitzman> > undefined + 1
23:32:17 <lambdabot>  Undefined
23:32:32 <satan> weitzman: thanks :)
23:32:32 <weitzman> > undefined ++ [1]
23:32:34 <lambdabot>  Undefined
23:32:36 <glguy> ?type let b = b in b
23:32:37 <lambdabot> forall t. t
23:32:43 <dolio> > undefined == 1
23:32:45 <lambdabot>  Undefined
23:32:51 <dolio> > undefined == undefined
23:32:52 <lambdabot>  Add a type signature
23:32:52 <satan> f Left undefined = undefined
23:32:57 <satan> would that work?
23:33:04 <weitzman> satan: No
23:33:11 * glguy doubts that you can pattern match undefined
23:33:11 <dolio> You can't match against undefined.
23:33:17 <satan> because its not a different behaviour from the Right?
23:33:21 <satan> oh ok
23:33:46 <satan> if it won't pattern man, how can i use it as an argument, like the question wants?
23:33:50 <monochrom> The computer cannot answer the question "does x have the value ?"
23:33:52 <satan> match*, not man
23:36:03 <glguy> > let f undefined x = undefined + x in f 3 4 -- ha!
23:36:04 <lambdabot>  7
23:36:06 <weitzman> I kinda feel like the problem satan is trying to solve can't be solved unless you already know the answer
23:36:19 <dolio> :)
23:36:27 <satan> that's rough :(
23:36:33 <monochrom> But the computer does not need such capability.  If somehow you invoke "f " and you get back  as a result, that's good enough for you.  Note that the computer still doesn't know that it's returning ; it is you who know what's going on.  Note that I say this because  may be the result of an infinite loop too, not just "undefined".
23:37:05 <foxy> how to define primes with list comprehension?
23:37:06 <weitzman> Not trying to discourage you, but I feel like there's nothing to gain from trying to figure it out
23:37:21 <weitzman> And if the others here agree,
23:37:29 <dolio> satan: What are the possible values of Bool?
23:37:29 <glguy> foxy: now that definitely soundslike homework
23:37:50 <weitzman> then you might be happier and better off with some examples of pattern matching
23:38:08 <satan> dolio: Bool is True | False
23:38:16 <foxy> glguy: it's not, I'm trying to define a filthy factorising function and I just need the primes, www.haskell.org is down
23:38:25 <satan> weitzman: ok i'll try a bit longer, then throw the towel in
23:38:27 <glguy> > let f undefined error = undefined + error in f 3 4
23:38:29 <lambdabot>  7
23:38:30 <dolio> satan: Right. So the possible values are True, False and _|_, right?
23:38:35 <satan> dolio: right
23:38:49 <glguy> foxy: ah, I just figured that you wouldn't care if it used list comprehensions otherwise
23:38:51 <satan> since haskell adds _|_ to every type automatically, i read somewhere
23:38:51 <dolio> satan: Okay. Now, you can't match against _|_, but you can match against True and False.
23:39:07 <satan> dolio: right
23:39:20 <satan> so check if true, if false, otherwise return _|_
23:39:21 <foxy> glguy: I've been trying to use sieve and I can't remember how to do it :(
23:39:36 <dolio> And you can also match against all unenumerated cases with _
23:40:06 <satan> ohh so i could just match _ and otherwise
23:40:16 <glguy> :-/
23:40:45 <Syzygy-> dcoutts: Ping?
23:41:00 <monochrom> _ will still not catch 
23:41:12 <dolio> Ah, well, damn.
23:41:34 <monochrom> "f True = whatever"  this is where  is caught.
23:41:53 <glguy> monochrom: stop using the unicode representation :-p
23:41:55 <satan> where what's caught?
23:42:02 <satan> _|_?
23:42:13 <monochrom> I think it's still most useful to think of  as an infinite loop.
23:42:13 <Korollary> unicode elitists
23:42:18 <satan> heh
23:42:49 <glguy> so late...
23:42:52 * glguy &
23:43:11 <Korollary> ps auxww | grep glguy
23:43:50 <ValarQ> @karma+ monochrom
23:43:50 <lambdabot> monochrom's karma raised to 6.
23:44:09 <satan> what about something like f Left a | a == true = true | a == False = false | otherwise = undefined
23:44:29 <monochrom> Suppose you invoke f with "f (some infinite loop)".  In order to pattern-match with "f True = whatever", the computer has to figure out "does (some infinite loop) evaluate to True?"  Well that will take the computer forever.  Thus "f (some infinite loop)" behaves as an infinite loop.  That's how you catch it.
23:44:32 <satan> where the |s are on new lines
23:45:06 <dolio> satan: That has the same problem.
23:45:08 <weitzman> satan: For starters, the "otherwise" clause won't ever be reached
23:45:10 <satan> monochrom: ok that makes sense, but how does one 'catch' it? how would i detect that
23:45:21 --- mode: ChanServ set +o lispy
23:45:30 --- topic: set to '["http://haskell.org seems to be down again...", "Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/", "Haskell - the language of ICFP winners 3 years running"]' by lispy
23:45:30 <monochrom> Does satan require everything said twice?
23:45:46 <satan> dolio: weitzman: guess i'm running in circles eh
23:45:59 <satan> nope, but i don't mind :P
23:46:06 --- mode: ChanServ set -o lispy
23:46:08 <weitzman> satan: Well, I still believe the question is flawed
23:46:51 <dolio> satan: You only need to distinguish between Left _|_ and Right _|_, not between Left True, Left False and Left _|_
23:46:53 <monochrom> If your goal is merely "f (infinite loop) behaves different from f (10)", well you make sure f(10) doesn't go into an infinite loop, and you make sure f(infinite loop) goes into an infinite loop.
23:47:03 <satan> dolio: thats right, hmm
23:47:16 <satan> monochrom: alright
23:47:26 <xerox> G'day.
23:48:18 <monochrom> The only thing impossible is "f(infinite loop) = 10, f(10) = 11".  But no one is asking you to do that.  "behave different" is a very weak requirement; don't strengthen it.
23:48:25 <xerox> ?pl \y -> it y over
23:48:26 <lambdabot> flip it over
23:48:27 <satan> dolio: i guess i don't know how to do that, maybe I should stick to C :(
23:48:44 <Korollary> C doesnt have bottom
23:49:08 <satan> monochrom: right
23:49:09 <Syzygy-> @karma
23:49:10 <lambdabot> You have a karma of 0
23:49:23 <xerox> @karma Syzygy
23:49:24 <lambdabot> Syzygy has a karma of 0
23:49:25 <monochrom> The problem with programmers is they're given very weak tasks and they make their own life hard by solving a much stronger problem.
23:49:27 <xerox> :(
23:49:44 <satan> heh you might have something there
23:49:46 <Syzygy-> xerox: Syzygy would have a karma of 0 without surprising me, since I am Syzygy- :P
23:49:50 <Korollary> the problem with generalization is <insert recursive allegation>.
23:50:05 <Syzygy-> @karma Syzygy-_
23:50:06 <lambdabot> Syzygy-_ has a karma of 0
23:50:09 <dolio> satan: If you can distinguish Left <anything> from Right <anything>, you would have successfully done so.
23:50:12 <xerox> Syzygy-++
23:50:21 <Syzygy-> Wooot! :)
23:50:23 <Syzygy-> @karma
23:50:23 <lambdabot> You have a karma of 0
23:50:27 <dolio> So how would you do that?
23:50:28 <Syzygy-> Hmmm.
23:50:29 <xerox> (Will the mighty regexp grok that?)
23:50:35 <Syzygy-> Seems not.
23:50:42 <satan> dolio: well, Left anything will be of type Bool and Right anything will be of type Char
23:50:45 <xerox> You're doomed!
23:50:53 <lispy> grr the downness of haskell.org lately
23:51:35 <dolio> Well, (Left <anything>) and (Right <anything>) are both of type Either Bool Char.
23:51:45 * xerox nods
23:52:01 <satan> dolio: ah ok
23:52:08 <monochrom> Do you accept that, as return values, "Left whatever" and "Right whatever" "behave" differently?
23:52:20 <weitzman> Another thing that can be of type Either Bool Char is <infinite loop>
23:52:25 <Korollary> lispy: go to bed
23:52:40 <vegai> haskell.org dead?
23:52:40 <weitzman> > let x = x in x :: Either Bool Char
23:52:42 <lambdabot>  Exception: <<loop>>
23:52:46 <satan> monochrom: sorry, no i don't see that
23:52:51 <lispy> Korollary: but the clowns.....oh fine...
23:53:15 <vegai> does anyone have a mirror of the ghc-6.6 snapshots?
23:53:59 <monochrom> Well it's almost the same thing as saying "1 and 2 behave differently".
23:54:08 <weitzman> > let x = x in x :: FakeTypeThatIsNotReal
23:54:09 <lambdabot>  Not in scope: type constructor or class `FakeTypeThatIsNotReal'
23:54:10 <xerox> Right, they are different things.
23:54:28 <satan> monochrom: oh ok, gotcha
23:54:29 <xerox> If they weren't what point would have been to have datatypes?
23:54:32 <hellish> vegai, darcs.haskell.org is hosted seperately from haskell.org and is up.
23:54:38 <monochrom> Then I revive my original suggestion "f x = x".
23:54:42 <xerox> (Sorry for my horrible english.)
23:55:22 <Korollary> ciao!
23:55:32 <vegai> hellish: oh, right. Thanks.
23:55:38 <xerox> @babel it en Buon giorno.
23:55:40 <lambdabot>  Good day.
23:56:03 <Syzygy-> @babel sv en God morgon
23:56:04 <lambdabot> babel module failed: IRCRaised Error: Language sv not supported
23:56:05 <weitzman> @babel en fr Hello
23:56:06 <lambdabot>  Bonjour
23:56:09 <Syzygy-> @babel se en God morgon
23:56:09 <lambdabot> babel module failed: IRCRaised Error: Language se not supported
23:56:10 <weitzman> Crazy gibberish
23:56:17 <Syzygy-> Pbtbtbt
23:56:26 * weitzman gives 10 points to anyone who recognizes the reference
23:56:27 <Korollary> @babel en en Hello
23:56:29 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
23:56:36 <satan> monochrom: so you're suggesting that f x = x would supply the infinite loop needed?
23:57:02 <weitzman> > let f x = x in f 3
23:57:04 <lambdabot>  3
23:57:14 <Bourbaki> moin
23:57:15 <weitzman> > let f x = x in f True
23:57:16 <lambdabot>  True
23:57:34 <weitzman> > let f x = x in f (Left False)
23:57:35 <lambdabot>  Add a type signature
23:57:40 <xerox> A.k.a. id True, a.k.a. True.
23:58:39 <satan> ok so it just returns the argument passed in, and since the args are different, we get different behaviours
23:58:49 <satan> is that it? omg
23:58:58 <dolio> :) That might not be what the tutorial had in mind.
23:59:11 <xerox> > let f x = x in f (Left False) :: Either Bool ()
23:59:12 <lambdabot>  Left False
23:59:14 <satan> haha i wonder what he had in mind, the author
23:59:24 <xerox> The author of.. ?
23:59:31 <satan> this stupid book
23:59:41 <weitzman> Another interesting question would be right a function with only three behaviors, taking an Either Bool Char
23:59:44 <satan> what's the () at the end of the datatype do?
23:59:51 <weitzman> s/right/write/
