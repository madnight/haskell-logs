00:01:48 <weitzman> Hmm. Ideally I would hope that one of the Haskell implementations would translate to simplified-Haskell as a first step, which could be helpful for writing a (verbose) translator
00:02:53 <weitzman> The SML interpreter is actually kind of annoying because sometimes in error messages it shows you different code from what you wrote
00:03:21 <weitzman> It might expand the if statements to case statements and similar drudgery
00:10:36 * edwardk waves hello.
00:15:17 <dons> morning edwardk
00:15:39 <edwardk> how goes?
00:16:02 <dons> hackeriffic
00:16:17 <edwardk> heh
00:16:39 <edwardk> sitting here, playing with type system stuff as usual.
00:18:50 <lokadin> quite an interesting past-time
00:19:34 <edwardk> its kept me off the streets at night ;)
00:20:07 <lokadin> .ui.u'i (happily amused)
00:20:16 <satan> anyone feel like giving me a hand? i'm trying to redefine operators like + and - for the data type Nat
00:21:00 <satan> and having limited success, i think i have it, but when i try to test it with 4 + 3, it gives me errors about "No instance for (Num Nat)" and so on
00:21:06 <edwardk> is that lojban?
00:21:07 <dons> ?paste
00:21:07 <lambdabot> http://paste.lisp.org/new/haskell
00:21:14 <dons> have you written a Num Nat instance, satan ?
00:21:30 <satan> dons: nope, should i put what i have in pastebin so far?
00:21:34 <lokadin> edwardk: yep
00:21:51 <edwardk> thought so. been a while =)
00:21:53 <dons> satan: you'll need to write an instance Num Nat for your type, to overload the Num operations
00:21:58 <dons> ?docs GHC.Num
00:21:58 <lambdabot> GHC.Num not available
00:22:11 <dons> ?instances Num
00:22:12 <lambdabot> Double, Float, Int, Integer
00:22:28 <satan> is there a cast or something to make 4 a Nat so it can be used
00:22:28 <lokadin> edwardk: well you know, .o'a it's coming back in style ;)
00:22:29 <dons> ?fptools GHC.Num
00:22:30 <lambdabot> GHC.Num not available
00:22:36 <satan> Nat 4 + Nat 3, for example
00:23:06 <edwardk> lok: not sure I'd go that far, but it always amused me.
00:23:14 <lokadin> and girls like it when you know a foreign language
00:23:21 * lokadin gose to write that one down
00:23:53 <edwardk> lokadin: most girls equate knowing lojban with knowing klingon on the creepy-geek-meter ;)
00:24:14 <edwardk> its right down there with haskell ;)
00:27:23 <lokadin> lol :P well they don't know that
00:27:52 <lokadin> you say, it's lojban, and then claim to have relatives from lojbanistan
00:28:01 <lokadin> i'm sure they wont figure it out for months
00:28:25 <edwardk> hahaha
00:28:34 <lokadin> .ui.u'isai
00:33:16 <lokadin> .o'o (patience) the time will come
00:34:21 <edwardk> bah, i have enough trouble with english ;)
01:06:34 <bourbaki> moin
01:07:40 * ibid notes that xerox's feed has been timing out for planet for some time now
01:16:29 <musasabi> Does anyone have a StringTree that supports regex-lookups?
01:18:42 <dons> musasabi: do you have any nice IO-heavy code, say in HAppS, online? something that would serve as an instructive example for what good IO/network code looks like? to go here: http://haskell.org/haskellwiki/Example_code
01:18:44 <lambdabot> Title: Example code - HaskellWiki
01:20:16 <musasabi> The HAppS code is online @ http://happs.org/
01:20:20 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
01:20:35 <dons> I know, I was wondering if you had any bits you were particuarly proud of? :)
01:21:24 <bourbaki> moin dons
01:21:37 <dons> heya bourbaki . sorry, haven't had time to reply yet.
01:21:45 <musasabi> I think there are cleaner ways to do most of the things. As e.g. HAppS uses [ByteString] because it predates .Lazy.
01:21:52 <bourbaki> dons np
01:35:35 <dcoutts__> musasabi: does HappS want optional deflate/gzip compression for http?
01:36:25 <musasabi> it would be nice to have.
01:38:02 <dons> ?remember ColinRunciman deciding to include -1 in the default Int series was a trip into an alien world.
01:39:38 <bourbaki> dons did you write an nlp parser for lambdabot?
01:42:44 <bourbaki> ?remember bourbaki
01:42:45 <lambdabot> Incorrect arguments to quote
01:43:16 <dons> nlp?
01:43:19 <dons> no.
01:43:34 <dons> that would be fun though :)
01:43:53 <bourbaki> i have written something like that in lisp once
01:44:03 <bourbaki> its pretty easy when you have a parser at hand
01:46:36 <bourbaki> isnt there an ambigios parser for english written in parsec?
01:47:09 <dons> yeah, that rings a bell.
01:47:22 <dons> Itkovian: you've a blog I see? Do you write much haskell or programming-related stuff?
01:48:01 <dons> guess not.
01:48:08 <bourbaki> if it generates a parsing tree you just can apply function associated with the verbs and such and thus get a closure for every propper sentence
01:50:49 <musasabi> Designing a good API for a trust database seems very hard. The database contains keys, userIDs and signatures on (key <-> userID, key <-> key, signatures), with M:N releationships and lots of metadata in the signatures.
01:51:16 <musasabi> Anyone know good examples/articles on something like that?
01:56:37 <musasabi> I think it should be some kind of traversal on the cyclic graph where 1) trust decisions are made (not local) and 2) interesting data is returned.
02:48:25 <araujo> morning
02:49:14 <gds> @hoogle (a -> Bool) -> [a] -> [[a]]
02:49:16 <lambdabot> No matches, try a more general search
02:49:32 <gds> @hoogle a -> [a] -> [[a]]
02:49:34 <lambdabot> No matches, try a more general search
02:49:44 * gds looks for a generalisation of "words"...
02:49:52 <dons> there's isn't one in the standard libs
02:50:01 <dons> ?google split site:haskell.org
02:50:02 <gds> How odd :)
02:50:04 <lambdabot> http://www.haskell.org/onlinereport/random.html
02:50:04 <lambdabot> Title: The Haskell 98 Library Report: Random Numbers
02:50:08 <dons> nope.
02:50:15 <dons> anyway, split is pretty easy to code up
02:50:21 <gds> Oh yeah :)
02:50:27 <dons> in fact, its so easy there are too many versions -- and we can't agree which one to put in the standard libs
02:50:39 <gds> lol - I see :)
02:58:04 <Syzygy-> @hoogle sin
02:58:06 <lambdabot> Prelude.sin :: Floating a => a -> a
02:58:06 <lambdabot> Prelude.sinh :: Floating a => a -> a
02:58:06 <lambdabot> Data.IntMap.singleton :: Key -> a -> IntMap a
02:58:33 <Syzygy-> Do the trig functions take degree or radian arguments?
02:58:39 <sieni> radian of course
02:59:27 <dons> ?remember osteele Reading Haskell is like reading poetry and writing Haskell is like writing poetry. As opposed to Python and Ruby, which are more prosaic, and Enterprise Java, which is more like a tax form.
03:00:27 <sieni> a degree is just a dimensionless constant (1 degree = 2 pi / 360)
03:02:14 <dcoutts__> dons: I do like the way researchers announce their little libs and then you integrate them into lambdabot within hours, eg smallcheck, djinn etc
03:02:36 <dcoutts__> this is the way it should work
03:03:59 <dons> I reckon so. then they don't languish, and people get to try them out.
03:07:30 <dons> ?remember maradydd If you've had other lovers, Haskell doesn't like many of the things that you may have come to enjoy doing with them. Haskell will pretend never to have heard of these things, and call you a pervert.
03:07:47 <dons> ^ that's a good one i think
03:08:13 <dcoutts__> heh, yes
03:08:33 <dons> maybe instead of:
03:08:36 <dons> > putChar 'x'
03:08:36 <lambdabot>  No IO allowed
03:08:45 <dons> it should shout: Pervert!
03:08:54 <lilboy> do you think Haskell will take over the world ?
03:09:33 <sieni> http://www.hurmio.org/~ville/wwspjd.html
03:09:43 <dcoutts__> dons: that'd be great :-)
03:10:00 <deadbeef> lilboy: Erlang will
03:10:13 * dons patches
03:10:57 <lilboy> deadbeef, maybe. and what about ocaml ?
03:11:03 <deadbeef> will too
03:11:07 <deadbeef> but not haskell
03:11:09 <gaal> is there a way in ghci to list all instances in scope for a particular typeclass?
03:11:21 <araujo> yay!
03:11:43 <araujo> gaal, no ... though it'd be sweet
03:11:46 <dons> ?instances Num
03:11:47 <lambdabot> Double, Float, Int, Integer
03:11:55 <dons> close enough, gaal?
03:11:58 <sieni> lilboy: why ocaml? why not standard ml?
03:12:00 <dons> ?instances Monad
03:12:01 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:12:10 <gaal> dons: yes, especially seeing as I have GOA :)
03:12:14 <gaal> thanks!
03:12:20 <dons> good :)
03:12:59 <gaal> hmm, though...
03:13:02 <gaal> ?instances Floating
03:13:04 <lambdabot> Double, Float
03:13:11 <gaal> huh, that doesn't work from my ghci.
03:13:30 <araujo> :-P
03:13:38 <dons> maybe there's no goa definition for the instances command yet?
03:13:39 <dons> let me see
03:13:48 <araujo> that's lambdabot magic :-P
03:13:51 <gaal> no: Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
03:14:00 <dons> nope, its there.
03:14:02 <dons> $ ghci
03:14:02 <dons> GOA> :instances Monad
03:14:02 <dons> ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:14:12 <dons> gaal: what are you searching for?
03:14:21 <gaal> Floating, to begin with.
03:14:34 <gaal> I guess I need to read that importing help.
03:14:37 <dons> ?hoogle Floating
03:14:38 <lambdabot> Prelude.Floating :: class Fractional a => Floating a
03:14:38 <lilboy> sieni, ain't ocaml more popular these days ? (i'm biaised, i'm french...)
03:14:47 <dons> ?instances Floating
03:14:48 <lambdabot> Double, Float
03:15:01 <gaal> @help instances-importing
03:15:02 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
03:15:22 <dons> I think Haskell is growing faster than OCaml now. There seems to be more research done on haskell -- by a fair margin
03:15:25 <sieni> lilboy: who cares? there's only one implementation subject to random changes by inria
03:15:53 <dons> yeah, good point, sieni
03:16:50 <gds> There's only one implementation of perl5 (that I'm aware of) subject to random changes by Larry - and it's still very poular...
03:16:50 <lilboy> right. and i think they don't care much about the industry.
03:17:03 <gds> s/poular/popular/
03:17:30 <lilboy> but maybe having a single "standart" implementation is a strength
03:17:34 <araujo> That's not a problem .. actually, to have an unique implementation might be an advantage at some degree.
03:17:49 <araujo> I think the problem with Ocaml is that they need to "open" it more
03:18:00 * gds reckons that either haskell will take over, or the likes of FunctinalJ will evolve to the point that haskell loses enough of its advantages to not need to...
03:18:19 <dons> yeah, I think that's about right. either we win, or other languages look like haskell
03:18:20 <gds> (/me counts the negatives in that sentance...)
03:18:26 <dons> something of both is happening at the moment
03:18:42 <gds> indeed - I'm not sure which outcome I'd prefer tbh ;)
03:19:09 <lilboy> maybe we'll see "monadic programming for dummies"
03:19:14 <araujo> I prefer Haskell itself evolves and establish as the language rulz :-P
03:19:16 <gds> :)
03:19:30 <araujo> lilboy, that wouldn't be _that_ hard to imagine really
03:20:00 <araujo> I think monadic theory could require as much effort as say... OOP theory
03:20:23 <araujo> (basci/necessary stuff to start working with the concepts)
03:20:29 <araujo> basic*
03:20:44 <lilboy> is "oop theory" really mainstream ?
03:20:52 <gds> http://yan.codehaus.org/api/jfun/yan/Monad.html
03:20:55 <lambdabot> Title: Monad, http://tinyurl.com/zhx22
03:21:25 <araujo> After all, it's been already around 40 years with OO, and nobody got a clue what that's all about :-P
03:21:52 <araujo> lilboy, i guess it is for "mainstream" applications
03:22:28 <araujo> and not my point really ....
03:23:17 <foxy_> given the CH isomorphism, is there a strong correspondence between pragma rewrite rules and mathematical theorems on types?
03:23:21 <xerox> ?yarr
03:23:21 <lambdabot> I'd like to drop me anchor in her lagoon
03:24:13 <xerox> G'day int-e.
03:24:19 <int-e> hello
03:26:32 <xerox> ?users
03:26:36 <lambdabot> Maximum users seen in #haskell: 242, currently: 209 (86.4%), active: 25 (12.0%)
03:29:36 <araujo> hi int-e
03:37:31 <dons> dcoutts__: do you have any code gems to add to http://haskell.org/haskellwiki/Example_code
03:37:32 <lambdabot> Title: Example code - HaskellWiki
03:41:32 <dcoutts__> dons: I expect the frown is well written
03:42:09 <dcoutts__> dons: happs?
03:43:03 <dcoutts__> dons: one of the parser libs, either parsec or the ReadP one perhaps?
03:43:49 <xerox> There also are "Haskell Idioms", which you can link as Category:Foo I think, inside the wiki.
03:44:13 <xerox> http://haskell.org/haskellwiki/Category:Idioms
03:44:15 <lambdabot> Title: Category:Idioms - HaskellWiki, http://tinyurl.com/zqbgx
03:44:18 <dons> the idioms aren't really nice though :) they're hard.
03:44:48 <dons> I wanted nice exampes for this heavily hit page
03:44:51 <xerox> But they ARE nice!
03:46:12 * xerox wanders off to lunch mumbling about how nice the Idioms are... *g*
03:47:21 <dons> you don't want to crack a newbie's head with 1kg of Olegs now, do you?
03:48:56 <int-e> not all idioms are hard.
03:49:18 <int-e> monads as containers is linked from that page, for example.
03:54:35 <foxy_> @yarr
03:54:35 <lambdabot> I'll crush ye barnacles!
03:55:10 <foxy_> I take it, then, that the alleged correspondence is actual, pfft :D
04:09:17 <nomeata> > take 40 $   (inits . repeat) ['a'..'z'] >>= sequence
04:09:18 <lambdabot>  ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r",...
04:09:29 <nomeata> > take 40 $ drop 40 $   (inits . repeat) ['a'..'z'] >>= sequence
04:09:30 <lambdabot>  ["an","ao","ap","aq","ar","as","at","au","av","aw","ax","ay","az","ba","bb",...
04:20:05 <int-e> > take 20 $ drop 40 $ fix (("":) . flip (liftM2 (flip (:))) ['a'..'z'])
04:20:07 <lambdabot>  ["na","oa","pa","qa","ra","sa","ta","ua","va","wa","xa","ya","za","ab","bb",...
04:20:37 <sieni> mittag-leffler.se?!?
04:21:31 <profmakx> wasnt that a theorem from function theory?
04:22:49 <sieni> I was just wondering, why duncan is ircing from institut mittag-leffler's wlan?
04:23:34 <sieni> wardriving around djursholm?
04:23:36 <nomeata> @scheck \x -> x `elem`  (inits . repeat) ['a'..'z'] >>= sequence
04:23:37 <lambdabot>  Couldn't match `m a' against `Bool'
04:23:47 <nomeata> @scheck \x -> x `elem` ((inits . repeat) ['a'..'z'] >>= sequence)
04:23:47 <lambdabot>  add an instance declaration for (Serial Char)
04:23:48 <lambdabot>   In the definition of `nib...
04:24:01 <nomeata> @type ((inits . repeat) ['a'..'z'] >>= sequence)
04:24:02 <lambdabot> [[Char]]
04:24:11 <nomeata> @type `elem`
04:24:13 <lambdabot> parse error on input ``'
04:24:17 <nomeata> @type (elem)
04:24:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:24:49 <nomeata> @scheck \x -> x `elem` ["hi"]
04:24:50 <lambdabot>  add an instance declaration for (Serial Char)
04:24:50 <lambdabot>   In the definition of `xsk...
04:25:45 <nomeata> @help scheck
04:25:45 <lambdabot> scheck <expr>
04:25:45 <lambdabot> You have SmallCheck and 3 seconds. Test something.
04:26:07 <nomeata> @scheck True
04:26:08 <lambdabot>  Completed 1 test(s) without failure.
04:26:37 <nomeata> @scheck (id)
04:26:37 <lambdabot>  Add a type signature
04:26:47 <nomeata> @scheck (id :: Bool -> Bool)
04:26:48 <lambdabot>   Failed test no. 2. Test values follow.: False
04:26:56 <nomeata> @type \x -> x `elem` ["hi"]
04:26:58 <lambdabot> [Char] -> Bool
04:27:12 <nomeata> @type \x -> x `elem` ((inits . repeat) ['a'..'z'] >>= sequence)
04:27:13 <lambdabot> [Char] -> Bool
04:27:52 <nomeata> why can't I use quickcheck on a [Char] -> Bool test with lambdabot?
04:28:00 <dons> sieni: he's on vacation/sabbatical i think
04:28:22 <dons> nomeata: example?
04:28:36 <dons> ?check \x -> x `elem` ["hi"]
04:28:37 <lambdabot>  Falsifiable, after 0 tests: "g"
04:28:52 <nomeata> oh, ?check, not @scheck. ok.
04:28:54 <dons> (don't use scheck yet -- needs more instances to work nicely)
04:28:59 <dons> scheck == smallCheck
04:29:02 <nomeata> ?check  \x -> x `elem` ((inits . repeat) ['a'..'z'] >>= sequence)
04:29:08 <lambdabot> Terminated
04:29:41 <nomeata> ok, that was to be expected :-)
04:31:23 <int-e> ?check \x -> all (`elem` ['a'..'z']) x == (x `elem` ((inits . repeat) ['a'..'z'] >>= sequence))
04:31:29 <lambdabot> Terminated
04:31:35 <int-e> ?scheck \x -> all (`elem` ['a'..'z']) x == (x `elem` ((inits . repeat) ['a'..'z'] >>= sequence))
04:31:36 <lambdabot>  add an instance declaration for (Serial Char)
04:31:36 <lambdabot>   In the definition of `czd...
04:31:46 <dons> no Char instance for SmallCheck yet.
04:31:57 <dons> there's Int though
04:32:17 <nomeata> @scheck \x -> x `elem` ((inits . repeat) [0..9] >>= sequence)
04:32:18 <lambdabot>  Add a type signature
04:32:21 <int-e> ?scheck \y -> let x = map chr y in all (`elem` ['a'..'z']) x == (x `elem` ((inits . repeat) ['a'..'z'] >>= sequence))
04:32:22 <lambdabot>  Exception: Prelude.chr: bad argument
04:32:28 <int-e> :P
04:32:29 <nomeata> @scheck \x -> x `elem` ((inits . repeat) [0::Int..9] >>= sequence)
04:32:30 <lambdabot>  Parse error
04:32:36 <nomeata> @scheck \x -> x `elem` ((inits . repeat) [(0::Int)..9] >>= sequence)
04:32:42 <lambdabot> Terminated
04:32:47 <nomeata> :-)
04:32:58 <nomeata> >((inits . repeat) [(0::Int)..9] >>= sequence)
04:33:02 <dons> inits . repeat isn't the nicest code fragment on the planet.
04:33:06 <int-e> is there Word8?
04:33:17 <nomeata> dons: It's from the idioms page on the wiki :-)
04:33:34 <nomeata> but it still should terminate for every x
04:33:34 <int-e> oh. should be iterate (:[0..9]) [] :)
04:33:43 <int-e> err, flip the :
04:33:50 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/SmallCheck.hs
04:33:52 <lambdabot> http://tinyurl.com/jggxk
04:34:12 <dons> the quickcheck version has Word8
04:34:21 <nomeata> > take 40 $ drop 40 $   (inits . repeat) [0..9] >>= sequence
04:34:22 <lambdabot>  [[2,9],[3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[4,0],[4,...
04:34:30 <dons> ?check \x -> x == (x :: Word8)
04:34:30 <nomeata> >  (inits . repeat) [0..9] >>= sequence
04:34:31 <lambdabot>  OK, passed 500 tests.
04:34:32 <lambdabot>  [[],[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[0,0],[0,1],[0,2],[0,3],[0,4],[0...
04:36:23 <nomeata> ?check \x -> length x /= 4
04:36:24 <lambdabot>  Add a type signature
04:36:33 <nomeata> ?check \x -> length (x::[Char]) /= 4
04:36:34 <lambdabot>  Falsifiable, after 15 tests: "myhn"
04:36:39 <nomeata> oh, we found a for letter word!
04:46:21 <nomeata> *"four letter", of course.
04:46:50 <int-e> ?check \x -> length (x::[Char]) /= 4
04:46:52 <lambdabot>  Falsifiable, after 34 tests: "ckcz"
04:47:13 <int-e> oh, there's more than one 4 letter word :)
04:48:23 <nomeata> dropWhile ((<4).length) $ takewhile ((<=4).length) $  (inits . repeat) [0..9] >>= sequence
04:48:29 <nomeata> >lenght $ dropWhile ((<4).length) $ takewhile ((<=4).length) $  (inits . repeat) [0..9] >>= sequence
04:49:52 <nomeata> > lenght $ dropWhile ((<4).length) $ takewhile ((<=4).length) $  (inits . repeat) [0..1] >>= sequence
04:49:53 <lambdabot>  Not in scope: `takewhile'
04:50:00 <nomeata> > lenght $ dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) [0..1] >>= sequence
04:50:01 <lambdabot>  Not in scope: `lenght'
04:50:10 <nomeata> > length $ dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) [0..1] >>= sequence
04:50:11 <lambdabot>  16
04:50:20 <nomeata> > length $ dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) ['a'..'z'] >>= sequence
04:50:22 <lambdabot>  456976
04:50:39 <nomeata> there are actualls 456976 four letter words, it seems :-)
04:50:44 <nomeata> > dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) ['a'..'z'] >>= sequence
04:50:45 <lambdabot>  ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaak...
04:50:55 <sehute> hi ppl
04:51:09 <sehute> How can I pattern-match a list that is one element long?
04:51:17 <nomeata> > 26^4 == length $ dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) ['a'..'z'] >>= sequence
04:51:18 <lambdabot>    Expecting a function type, but found `Bool'
04:51:18 <lambdabot>    Expected type: a -> b
04:51:18 <lambdabot> ...
04:51:25 <nomeata> > 26^4 == (length $ dropWhile ((<4).length) $ takeWhile ((<=4).length) $  (inits . repeat) ['a'..'z'] >>= sequence)
04:51:26 <lambdabot>  True
04:51:36 <sehute> like: func (x:xs) = 123
04:51:49 <sehute> only that I want only lists that contains one element
04:51:57 <nomeata> sehute: func [x] = x
04:52:03 <sehute> nomeata: thank you! :)
04:52:14 <sehute> nomeata: I tried x:[], but that didn't work
04:52:14 <nomeata> sehute: func (x:[]) = x works too :-)
04:52:22 <nomeata> not? try braces!
04:52:27 <sehute> ah, with the parenthesis! :-)
04:52:30 <sehute> you're the man
04:52:30 <sehute> thanks
04:53:22 <sehute> is there a way I can match lists that are >= 2 elements long?
04:53:22 <nomeata> > "me" == "man" where (==) = const const true
04:53:23 <lambdabot>  Parse error
04:53:27 <sehute> :D
04:53:30 <nomeata> @type const const
04:53:32 <lambdabot> forall a b b1. b1 -> a -> b -> a
04:53:46 <nomeata> > "me" == "man" where (==) = const (const True)
04:53:46 <lambdabot>  Parse error
04:53:54 <sehute> (x:x:xs) ?
04:54:01 <sehute> (x:y:xs) ?
04:54:10 <nomeata> the latter
04:54:13 <sehute> Will it work? Who knows? *trying it out*
04:54:31 <int-e> > let (==) = const (const True) in "me" == "man"
04:54:31 <nomeata> > let (==) = const (const True) in "me" == "man"
04:54:32 <lambdabot>  True
04:54:33 <lambdabot>  True
04:54:36 <nomeata> :-)
04:55:09 <hugoh> hello, i just have a simple question (i try to learn haskell at school). i want to check if an integer can derive another integer and if that quota is an integer. can i do something like:
04:55:14 <hugoh> isFactor2 n m | (n / m) == Integer
04:55:16 <hugoh> ?
04:55:17 <hugoh> :)
04:55:43 <int-e> try: n `mod` m == 0
04:55:46 <hugoh> i know that
04:55:51 <hugoh> :)
04:55:57 <hugoh> my isFactor1 is like that ;)
04:56:47 <sehute> :-)
04:56:48 <int-e> you cannot do that. you can try that with floating point math but it'll be wrong.
04:57:43 <nomeata> what's the difference between where and let, besides the order of things?
04:57:44 <hugoh> but can i somehow easy check what type (n/m) is? if it is an integer, then m could divide m right.
04:57:54 <hugoh> n*
04:58:02 <int-e> nomeata: where is allowed in fewer places.
04:58:28 <int-e> nomeata: semantically it's just a let with a different syntax.
04:58:50 <nomeata> ok
04:58:51 <int-e> the type of n/m is fixed at compile time
04:59:08 <hugoh> fixed?
04:59:35 <hugoh> welcome waern ;)
04:59:40 <int-e> to use n/m, n and m need to have the same type. that type will be the result type. furthermore, the type needs to be an instance of the Fractional type class.
04:59:41 <Cale> nomeata: A where clause is part of the function declaration, whereas let is part of expression syntax.
05:00:04 <waern> hugoh, thanks
05:00:11 <Cale> nomeata: One notable difference is that where scopes over multiple guards, which is something you just can't do with let.
05:00:25 <Cale> (well, not without using case, anyway)
05:00:54 <waern> hugoh, who are you?
05:01:04 <sehute> >read "3" :: Int
05:01:13 <sehute> > read "3" :: Int
05:01:15 <lambdabot>  3
05:01:17 <int-e> > 1/2 :: Double
05:01:18 <lambdabot>  0.5
05:01:22 <int-e> > 1/2 :: Rational
05:01:23 <lambdabot>  1%2
05:01:24 <sehute> "3" :: Int
05:01:34 <sehute> > "3" :: Int
05:01:36 <lambdabot>  Couldn't match `Int' against `[Char]'
05:01:44 <sehute> > '3' :: Int
05:01:45 <lambdabot>  Couldn't match `Int' against `Char'
05:01:50 <sehute> brilliant :)
05:02:37 <Cale> > 3 :: [Char]
05:02:38 <lambdabot>  add an instance declaration for (Num [Char])
05:02:38 <lambdabot>   In the expression: 3 :: [C...
05:03:01 <nomeata> > 3 :: Char
05:03:02 <lambdabot>  add an instance declaration for (Num Char)
05:03:02 <lambdabot>   In the expression: 3 :: Char...
05:03:33 <nomeata> > instance Num Char where fromInteger = Char.ord
05:03:34 <lambdabot>  Parse error
05:03:44 <nomeata> > instance Num Char where fromInteger = Char.chr
05:03:44 <lambdabot>  Parse error
05:03:57 <int-e> waern: one thing that probably confuses you is that the numeric literals (1, 2, ...) are actually polymorphic. 1 can be of type Int, Integer, Double, and a few others, depending on the context.
05:04:04 <int-e> @type 1
05:04:06 <lambdabot> forall t. (Num t) => t
05:04:52 <int-e> waern: and which particular type is used will be fixed by the compiler (sooner or later).
05:05:08 <int-e> waern: sorry
05:05:09 <sehute> how does one convert from int to char?
05:05:12 <int-e> hugoh: that was for you
05:05:15 <sehute> int-e: understood
05:05:23 <sehute> ok
05:05:24 <nomeata> sehute: Ord.chr
05:05:27 <sehute> int-e: it's of type Num, isn't it?
05:05:31 <nomeata> @type Ord.chr
05:05:33 <lambdabot> Couldn't find qualified module.
05:05:36 <nomeata> @type Char.chr
05:05:37 <lambdabot> Int -> Char
05:05:41 <nomeata> thats the one
05:05:50 <sehute> > Char.chr 3
05:05:51 <lambdabot>  '\ETX'
05:05:56 <int-e> sehute: no, the type is Num t => t - all types that are instances of the Num type class
05:06:37 <hugoh> int-e: ah, which one? my terminal is a bit messed up
05:06:56 <sehute> > [Char.chr 104] ++ [Char.chr 105]
05:06:57 <lambdabot>  "hi"
05:07:00 <sehute> :-]
05:07:02 <hugoh> waern: im a chalmers student, i guessed you are too?
05:07:08 <int-e> hugoh: "one thing that probably confuses you is that the numeric literals (1, 2, ...) are actually polymorphic. 1 can be of type Int, Integer, Double, and a few others, depending on the context."
05:07:16 <waern> hugoh, ah.. yep!
05:07:34 <waern> hugoh, I'm from Datateknik
05:07:37 <waern> hugoh, you too?
05:07:42 <hugoh> waern: first grade? i am!
05:07:56 <waern> hugoh, aha.. no, 4rth :)
05:08:12 <hugoh> waern: okey dave
05:08:51 <hugoh> int-e: okey, but arent there any constructor (?) or function that can check the type of a thing?
05:09:04 <hugoh> like :t but to use in code
05:09:34 <sehute> > let x = 2; [Char.chr (48 + x)]
05:09:35 <lambdabot>  Parse error
05:09:49 <int-e> hugoh: I'll say no. I believe Data.Dynamic does something like that but it really, really isn't what you want.
05:10:07 <sehute> Are there an easier way to convert between a single-digit int and a string than [Char.chr (48 + n)] ?
05:10:13 <sehute> s/Are/is/
05:10:28 <sehute> > [Char.chr (48 + 2)]
05:10:30 <lambdabot>  "2"
05:11:30 <int-e> hugoh: types in Haskell aren't dynamic, they are fixed. They may be polymorphic which muddens the otherwise clear water somewhat.
05:12:38 <sehute> "> map Char.chr [104, 105, 32, 112, 112, 108, 33]"
05:12:39 <hugoh> int-e: polymorphic, that is "they can be both"?
05:12:39 <Syzygy-> foo
05:12:59 <sehute> > map Char.chr [104, 105, 32, 112, 112, 108, 33]
05:13:01 <lambdabot>  "hi ppl!"
05:13:03 <sehute> :)
05:13:09 <sehute> my new "hi"-message
05:14:09 <hugoh> i have a function that will in one case (when i check how many divisors zero has got) will give the result "infinite". are there any special keyword use in Haskell for infinite or should i simply put an error message about it?
05:14:10 <int-e> hugoh: more like, "the type will be fixed later"
05:14:23 <nomeata> @hoogle (a -> b -> c) -> [a] -> [c]
05:14:24 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:14:25 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
05:14:41 <nomeata> @hoogle (a -> c -> c) -> [a] -> [c]
05:14:42 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:14:42 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:14:42 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
05:15:13 <nomeata> > scanr ((+)) [1,2,-10,3]
05:15:13 <lambdabot>  add an instance declaration for (Num [a])
05:15:27 <nomeata> > scanr ((+)) 0 [1,2,-10,3]
05:15:28 <lambdabot>  [-4,-5,-7,3,0]
05:15:35 <nomeata> > scanl ((+)) 0 [1,2,-10,3]
05:15:36 <lambdabot>  [0,1,3,-7,-4]
05:15:37 <xerox> nomeata: the outer () aren't needed.
05:16:03 <nomeata> > scanl (-) [104, 105, 32, 112, 112, 108, 33]
05:16:03 <lambdabot>  add an instance declaration for (Num [a])
05:16:09 <nomeata> > scanl (-) 0 [104, 105, 32, 112, 112, 108, 33]
05:16:11 <lambdabot>  [0,-104,-209,-241,-353,-465,-573,-606]
05:16:21 <nomeata> > scanl (+) $ scanl (-) 0 [104, 105, 32, 112, 112, 108, 33]
05:16:22 <lambdabot>  add an instance declaration for (Num [b])
05:16:28 <nomeata> > scanl (+) 0 $ scanl (-) 0 [104, 105, 32, 112, 112, 108, 33]
05:16:29 <lambdabot>  [0,0,-104,-313,-554,-907,-1372,-1945,-2551]
05:16:40 <nomeata> > scanr (+) 0 $ scanr (-) 0 [104, 105, 32, 112, 112, 108, 33]
05:16:42 <lambdabot>  [281,325,177,220,145,108,33,0,0]
05:16:48 <nomeata> > scanl (+) 0 $ scanr (-) 0 [104, 105, 32, 112, 112, 108, 33]
05:16:49 <lambdabot>  [0,-44,104,61,136,173,248,281,281]
05:17:04 <nomeata> > scanl (+) 0 $ scanr (-) 104 [105, 32, 112, 112, 108, 33]
05:17:05 <lambdabot>  [0,252,105,284,217,396,325,429]
05:17:49 <velco> hmm...
05:18:16 <sehute> > ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] !! 4
05:18:17 <lambdabot>  "4"
05:18:21 <sehute> An easier way to do this?
05:18:31 <hugoh> sry
05:18:33 <velco> I thought people generally had Haskell installed on their machines ...
05:18:46 <hugoh> did i get a reply?
05:19:09 <ValarQ> > map show [1..9]
05:19:10 <lambdabot>  ["1","2","3","4","5","6","7","8","9"]
05:19:13 <sehute> hugoh: between when you left and came back, "hugoh" is not mentioned, but I don't know if one of them was for you
05:19:21 <sehute> ValarQ: so...
05:19:26 <sehute> > [1..9] !! 4
05:19:28 <lambdabot>  5
05:19:34 <sehute> no
05:19:40 <sehute> > map show [1..9] !! 4
05:19:41 <lambdabot>  "5"
05:19:47 <sehute> > map show [0..9] !! 4
05:19:49 <lambdabot>  "4"
05:19:52 <int-e> hugoh: I'd use -1 in this particular case. In general you can consider Either Result Exceptional to encode exceptional results
05:19:56 <hugoh> sehute: aha, thx then.
05:19:56 <sehute> ValarQ: thanks!
05:20:26 <sehute> hugoh: I can give you a paste, if you're interested :)
05:20:33 <hugoh> int-e: you would return -1 instead of a keyword for infinte?
05:20:35 <int-e> hugoh: (Either is defined in Data.Either.  Excpeptional would be a data type that encodes your exceptional results.  Result the ordinary result type)
05:20:50 <hugoh> sehute: hehe, sure ;P msg me!
05:21:28 <hugoh> in not used to math termsm, but an "exceptional result" is in my case infinte?
05:21:29 <int-e> hugoh: if the other values are all positive, that will work.
05:21:36 <int-e> hugoh: yep
05:22:19 <hugoh> okey, so there's no "simple" keyword for infinte?
05:22:20 <hugoh> :)
05:22:26 <int-e> hugoh: right.
05:23:23 <hugoh> okey.
05:23:26 <int-e> And we could probably have a heated discussion about whether using -1 for that is abuse or a sound decision.
05:23:41 <int-e> that's a matter of taste really.
05:23:44 <hugoh> int-e: all these files, can we call them libs for Haskell? and in that case, where are they located?
05:24:07 <int-e> modules, usually. and it depends on the compiler. hugs prints file names I think.
05:25:25 <hugoh> int-e: all these files, can we call them libs for Haskell? and in that case, where are they located?
05:25:30 <hugoh> oops
05:25:56 <Cale> The inkscape export tool is so intelligent. When you export bitmaps from certain selections in your image, it remembers the filenames you used for those areas, and fills them in for you when exporting again. I also changed the path in one of them while doing a sequence of exports, and it corrected the path in the others in the same fashion.
05:27:28 <dons> hugoh: check haskel.org under 'standard libraries'
05:27:33 <dons> haskell.org
05:27:46 <xerox> Cale: nice!
05:28:21 <nomeata> I'm trying to find a function f, so that (scanl1 (+)).f == id, but it does not seem to be able with scan itself.
05:28:47 <hugoh> thx
05:29:59 <int-e> f x = zipWith (-) x (0:x)
05:30:11 <int-e> hmm
05:30:15 <ventonegro> :@type id
05:30:19 <ventonegro> @type id
05:30:21 <lambdabot> forall a. a -> a
05:30:51 <int-e> hah. luckily left inverses are right inverses, too :)
05:31:04 <Cale> > scanl1 (+) . ap (zipWith subtract) tail $ [1,2,3,4,5]
05:31:04 <xerox> ?check (\f xs -> scanl1 (+) (f xs) == xs) :: ([Int] -> [Int]) -> [Int] -> Bool
05:31:05 <lambdabot>  Falsifiable, after 2 tests: <[Int] -> [Int]>, [-1,0,0]
05:31:06 <lambdabot>  [1,2,3,4]
05:31:10 <Cale> not quite
05:31:13 <xerox> Yarrr.
05:31:23 <int-e> note the 0:
05:31:26 <int-e> you forgot that.
05:31:31 <Cale> yeah
05:32:01 <dolio> > scanl1 (+) . ap (zipWith (-)) (0:) $ [1..10]
05:32:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:32:07 <int-e> @pl \x -> zipWith (-) x (0:x)
05:32:08 <lambdabot> ap (zipWith (-)) (0 :)
05:32:16 <int-e> @pl \x -> zipWith (subtract) (0:x) x
05:32:17 <lambdabot> zipWith subtract =<< (0 :)
05:32:21 <Cale> > scanl1 (+) . ap (zipWith (-)) (0:) $ [1,2,3,4,5]
05:32:23 <lambdabot>  [1,2,3,4,5]
05:32:29 <xerox> dolio++
05:33:13 <Cale> Man, I just use the reader monad instinctively now. I must hang out here too much.
05:33:24 <dolio> Heh, yeah, me too.
05:33:27 <xerox> It's all right
05:33:31 <Cale> heh
05:34:09 <nomeata> not bad!
05:34:32 <nomeata> ?check \x -> (scanl1 (+) . ap (zipWith (-)) (0:) $ x) == x
05:34:33 <lambdabot>  Add a type signature
05:34:42 <nomeata> ?check \x -> (scanl1 (+) . ap (zipWith (-)) (0:) $ x) == x::[Int]
05:34:43 <lambdabot>  Couldn't match `[Int]' against `Bool'
05:34:48 <nomeata> ?check \x -> (scanl1 (+) . ap (zipWith (-)) (0:) $ x) == (x::[Int])
05:34:49 <lambdabot>  OK, passed 500 tests.
05:35:50 <dolio> ?scheck
05:35:51 <lambdabot>  Parse error
05:36:03 <xerox> ?help scheck
05:36:04 <lambdabot> scheck <expr>
05:36:04 <lambdabot> You have SmallCheck and 3 seconds. Test something.
05:36:13 <nomeata> @pf \x ->  (scanl1 (+) . ap (zipWith (-)) (0:) $ x)
05:36:14 <lambdabot> Maybe you meant: bf pl
05:36:14 <dolio> ?scheck \x -> (scanl1 (+) . ap (zipWith (-)) (0:) $ x) == (x::[Int])
05:36:19 <lambdabot>  Completed 623530 test(s) without failure.
05:36:22 <nomeata> @pointsfree \x ->  (scanl1 (+) . ap (zipWith (-)) (0:) $ x)
05:36:22 <lambdabot> Unknown command, try @list
05:36:42 <nomeata> @pl \x ->  (scanl1 (+) . ap (zipWith (-)) (0:) $ x)
05:36:42 <lambdabot> scanl1 (+) . ap (zipWith (-)) (0 :)
05:36:51 <dcoutts__> dons: do we expose the defaultBigChunkSize and defaultSmallChunkSize in Base? If not we should I think.
05:36:55 <dcoutts__> dons: I'm just writing the zlib binding and need to know a reasonable size for the output chunks
05:37:03 <dcoutts__> dons: and the calculation of them is a bit subtle since it takes ghc heap layout and allocation stratgey into account
05:37:06 <dcoutts__> we don't want other modules to need to know that
05:37:10 <dcoutts__> but if they all just alloc 4k then that's very innefecient for ghc's allocator
05:37:56 <dons> hmm. ok
05:38:21 <dons> I don't think Igloo would like me trying to get it into base though, before the release
05:38:43 <dons> you just want the *Size values exported?
05:54:51 <foxy_> djinn ((a -> b) -> a) -> a
05:55:22 <foxy_> @djinn ((a -> b) -> a) -> a
05:55:23 <lambdabot> -- f cannot be realized.
05:55:32 <foxy_> @slap lambdabot
05:55:32 * lambdabot beats up lambdabot
05:55:42 <xerox> ?djinn ((a -> b) -> a) -> b
05:55:42 <lambdabot> -- f cannot be realized.
05:56:07 <foxy_> ?me whispers /Pierce/
05:56:07 <lambdabot> Maybe you meant: messages messages? . bf ft id let map more msg pl time v wn
05:56:22 <foxy_> pfft
05:58:33 <Brennus> Hi.
05:58:34 <dons> ?djinn Not (Not (((a->b)->a)->a)
05:58:34 <lambdabot> Cannot parse command
05:58:38 <Brennus> Is there anyone here from Canberra, Australia, who might be interested in a job as a developer working with functional programming languages?
05:59:17 <foxy_> I can skip the ditch for Canberra
05:59:19 <dons> Brennus: nice! you're best bet would be to mail haskell@haskell.org though
05:59:27 <Brennus> oh right
06:00:28 <dons> the mailing list details are at http://haskell.org
06:00:30 <lambdabot> Title: Haskell - HaskellWiki
06:02:59 <Brennus> dons, would you by any chance be Don Syme?
06:03:27 <dons> nope :) Don Stewart
06:03:31 <Brennus> ah
06:03:36 <Brennus> Fair enough :)
06:03:58 <dons> not the first time I've been asked that :)
06:04:18 <Brennus> hehe
06:11:56 <lesshaste> hi
06:12:05 <sehute> see you
06:12:34 <ndm> dons: good point about the hoodoc keywords, thanks for doing some of it
06:12:56 <ndm> dons: will get it sorted shortly - after i have hacked up pragma support in Yhc
06:13:02 <dons> ok cool
06:15:30 <yaarg> anyone know the location of a debian package for ghci 6.4.2?-)
06:15:53 <xerox> @google ghc 6.4.2 .deb
06:15:55 <dons> ghci should come with ghc 6.4.2 for that system. i think its in unstable
06:15:55 <lambdabot> http://www.mail-archive.com/debian-haskell@lists.urchin.earth.li/msg00059.html
06:15:55 <lambdabot> Title: Re: [Debian-haskell] GHC 6.4.2
06:16:14 <yaarg> opps sorry for stable
06:16:22 <dons> otherwise,  there's binaries on haskell.org/ghc
06:16:26 <yaarg> link on website is broken
06:16:39 <yaarg> yeah i guess i'll just use that
06:17:06 <dcoutts__> dons: did you want me to send a patch against stable fps for exporting the chunk size?
06:17:28 <dons> ok.
06:17:48 <dcoutts__> dons: do you think we can't get it into base before 6.6 ?
06:18:47 <dons> hmm. maybe if we ask Igloo very nicely, very soon
06:19:14 <dons> but I'm scared to ask again :) I already promoised not to tweak the api any further..
06:20:08 <dons> it's not really critical is it? anyone who cares can work out a reasonable value from the src.
06:21:17 <dcoutts__> dons: well isn't only the private api ;-)
06:21:23 <dcoutts__> semi-private
06:21:27 <dcoutts__> and it can't break anything as it's just an addition
06:21:29 <dcoutts__> Igloo: pretty please? :-)
06:21:45 <dcoutts__> dons: only by doing this tricky overhead calculation
06:33:55 <rmz> I' ve got a question, why does this force parameter 'a' to be an integer in Hugs:
06:33:56 <rmz> compareKey:: Ord a => (a, b) -> (a, b) -> Ordering
06:33:56 <rmz> compareKey (a, b) (c, d) = (compare a c)
06:34:26 <dons> ?type \(a, b) (c, d) -> (compare a c)
06:34:28 <lambdabot> forall b a b1. (Ord a) => (a, b) -> (a, b1) -> Ordering
06:34:39 <dcoutts__> 4k - {the overhead of GHC's heap cell header + MBA# header}
06:34:45 <dcoutts__> on 32 and 64bit arches
06:34:47 <dcoutts__> and even we don't do it properly for profiling vs non-profiling builds
06:34:52 <dons> i can't see how 'a' has any integer constraint, rmz ? can you elaborate?
06:34:53 <dcoutts__> in a profiling build the heap cell header is bigger
06:35:10 <dons> hmm. tricksy. do we need some header included?
06:35:57 <rmz> dons I've got in the top a file, it's the first function being defined there, when I load it into hugs it gets the type compareKey:: Ord a => (a, b) -> (a, b) -> Ordering
06:35:57 <rmz> compareKey (a, b) (c, d) = (compare a c)
06:36:01 <rmz> (sorry)
06:36:08 <rmz> (Integer,a) -> (Integer,a) -> Ordering
06:36:12 <rmz> this is the type
06:36:36 <dons> perhaps elsewhere in your file you have a constraint on the the compareKey function?
06:37:19 <rmz> I don't.  for some reason compare has type Integer -> Integer -> Ordering
06:37:29 <dons> ?type compare
06:37:30 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:38:25 <dons> are you saying hugs won't accept the explicit type declaratoin for compareKey? Ord a => (a, b) -> (a, b) -> Ordering
06:44:37 <dons> heya CosmicRay
06:54:15 <CosmicRay> hi dons!
06:56:03 <Limbic_Region> going through YAHT using ghci and am trying to follow the example of creating a simple data type 'data Triple a b c = Triple a b' and I am getting a parse error
06:56:09 <Limbic_Region> is this something that requires extensions ?
06:56:34 <Limbic_Region> or is there a typo in the tutorial?
06:57:03 <Limbic_Region> or is it something that can't be done interactively (requiring a file)?
06:57:07 <Limbic_Region> inquiring minds want to know
06:57:15 <glguy> Limbic_Region: you can't declare data typesw in ghci
06:57:17 <dons> you have to put type declarations into src files, yes.
06:57:46 <glguy> and the line: data Triple a b c = Triple a b' would also generate an error
06:58:06 <glguy> unless that ' was just you quoting the line...
06:58:21 <dons> I think it's just quotes, glguy
06:58:43 <Limbic_Region> the quote was just to show what I was typing - not actually there
06:58:45 <dons> (see the start quote ;)
06:59:09 <dons> iblechbot: yeah, so you declare new types in a source file, and :load it into ghci to use that type
06:59:11 <Limbic_Region> ok - thanks
06:59:15 <glguy> yeah yeah yeah (c; I noticed after I said it
06:59:49 <dons> (defining new types interactively doesn't play well with existing declarations, so its not allowed)
07:01:03 <dons> e.g. what would this mean:
07:01:04 <dons> data T = A
07:01:05 <dons> let a = A :: T
07:01:05 <dons> data T = Z
07:01:05 <dons> :t a --- ??
07:01:19 <dons> imagining that we could define types interactively
07:01:24 <Limbic_Region> well, I am about as bright as a burned out lightbulb so instead of just TIASing, I ask obvious questions in the channel
07:01:35 <dons> no no, its a good question :)
07:01:42 <dons> I'm trying to explain why its a good question :)
07:02:28 <dons> static typing doesn't play well with interactive/redefinable type definitions, I'd say.
07:03:26 <dons> (short of some open data type scheme)
07:21:12 <dblhelix> @seen earthy
07:21:12 <lambdabot> I haven't seen earthy.
07:33:05 <nomeata> @seen that?
07:33:06 <lambdabot> I haven't seen that?.
07:33:11 <nomeata> thought so.
07:35:39 <Syzygy-> @seen this?
07:35:40 <lambdabot> I haven't seen this?.
07:35:45 <Syzygy-> :P
07:38:05 <nomeata> @seen the light?
07:38:06 <lambdabot> I haven't seen the.
07:38:24 <nomeata> ok, guess lambdabot does not play along every trick.
07:40:14 <AstralStorm> @seen light
07:40:14 <lambdabot> I haven't seen light.
07:40:31 <ndm> @seen the light?
07:40:32 <lambdabot> I haven't seen the.
07:41:19 <nomeata> @seen (the light)
07:41:19 <lambdabot> I haven't seen (the.
07:41:30 <nomeata> looks like he does not know haskell syntax either.
07:43:24 <twanvl> @seen the light
07:43:25 <lambdabot> I haven't seen the.
07:44:47 <lesshaste> is there an elegant haskell solution to the matrix chain multiplication problem?
07:45:14 <lesshaste> I haven't really seen any dynamic programming stuff in haskell apart from the lovely one line fibonacci number program
07:46:29 <d04mse> hello
07:47:05 <d04mse> i wonder how you could count how many characterters in a string
07:47:07 <d04mse> ??
07:48:00 <nomeata> length
07:48:06 <nomeata> > length "this is a string"
07:48:08 <lambdabot>  16
07:48:19 <nomeata> or you want only letters? try:
07:48:25 <nomeata> > length $ filter Char.isLetter "this is a string"
07:48:26 <lambdabot>  Not in scope: `Char.isLetter'
07:48:39 <nomeata> > length $ filter Char.isAlpha "this is a string"
07:48:40 <lambdabot>  13
07:48:58 <d04mse> no the first one is ok...
07:50:15 <lesshaste> I see it is at least possible to do dynamic programming in haskell http://chneukirchen.org/repos/blogcode/dynprog-haskell.pdf#search=%22dynamic%20programming%20haskell%22
07:50:18 <lambdabot> http://tinyurl.com/nhl64
07:50:30 <lesshaste> now I just need a solution to the matrix chain multiplication problem in haskell :)
07:51:06 <glguy> lesshaste: have you seen http://www.haskell.org/hawiki/MemoizingRecursion
07:51:07 <d04tl> hi, i wonder if haskell runs line after line or if it only runs the function you written when you call for it?
07:51:08 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki
07:51:38 <glguy> d04tl: Are you reading one of the tutorials now?
07:51:45 <glguy> (Haskell is call by need)
07:52:05 <nomeata> d04mse: you can also use:
07:52:21 <nomeata> > foldl1 (flip (const (+1))) "This is a nother string" -- :-)
07:52:21 <lambdabot>  add an instance declaration for (Num Char)
07:52:29 <nomeata> > foldl (flip (const (+1))) 0 "This is a nother string" -- :-)
07:52:31 <lambdabot>  23
07:52:38 <d04tl> no i have read some and now i have an assignment until tomorrow and i must say it aint an easy language too use
07:53:08 <glguy> d04tl: do you know a different language?
07:53:45 <d04tl> I know java
07:53:54 <Cale> Heh, I just had an idea for a binary determination puzzle which would be somewhat like Nurikabe, but with some cells being determined by a clue which would be a true or false question in the form of a mathematical statement.
07:54:26 <Cale> That is, the truth or falsity of the given statement would determine if the cell was white or black :)
07:58:05 <d04mse> Hello Lambadott ... i thougt you could use takeWhile Char String but you couldn't ? is there any other way?
07:58:17 <Cale> d04mse: hm?
07:58:36 <Cale> takeWhile :: (a -> Bool) -> [a] -> [a]
07:58:57 <d04mse> yes.. but is there any comparison method for takeWhile for a string ?
07:59:04 <Cale> String = [Char]
07:59:10 <d04mse> like "hello"
07:59:11 <Cale> so in that case,
07:59:21 <Cale> takeWhile :: (Char -> Bool) -> String -> String
07:59:27 <d04mse> takeWhile 'l' = "he"
07:59:38 <d04mse> something like that?
07:59:38 <dolio> > takeWhile ('l' /=) "hello"
07:59:40 <lambdabot>  "he"
07:59:41 <Cale> > takeWhile isLower "abcdABcd"
07:59:43 <lambdabot>  "abcd"
08:00:25 <d04mse> thanks ... i'll try that
08:00:45 <Cale> > span isLower "abcdABcd"
08:00:46 <lambdabot>  ("abcd","ABcd")
08:01:07 <Cale> > takeWhile (/= 'l') "hello"
08:01:09 <lambdabot>  "he"
08:01:11 <Cale> > span (/= 'l') "hello"
08:01:13 <lambdabot>  ("he","llo")
08:01:29 <Cale> > dropWhile (/= 'l') "hello"
08:01:31 <lambdabot>  "llo"
08:02:02 <basvandijk> can foo be written shorter?:
08:02:02 <basvandijk> x :: Maybe a
08:02:02 <basvandijk> y :: Maybe b
08:02:02 <basvandijk> f :: a -> b -> Maybe c
08:02:02 <basvandijk> foo :: Maybe c
08:02:03 <basvandijk> foo = do a <- x
08:02:05 <basvandijk>               b <- y
08:02:05 <deadbeef> ?type dropWhile
08:02:07 <basvandijk>               f a b
08:02:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:02:25 <Cale> basvandijk: foo = liftM2
08:02:59 <Cale> er
08:03:05 <dolio> liftM2 f x y
08:03:20 <Cale> not quite
08:03:29 <basvandijk> Cale: yes but liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r but f :: a -> b -> Maybe c
08:03:34 <Cale> right
08:03:40 <d04tl> does haskell run line after line? I mean, can i create a func where i save something in a variable and then I use that variable later in the code
08:03:42 <d04tl> ?
08:03:46 <dolio> No? I guess that'd be return $ f a b at the end.
08:03:46 <basvandijk> do I have to join something
08:03:51 <Cale> join
08:03:52 <Cale> yes
08:03:59 <integral> d04tl: there's "let x = A in E"
08:04:00 <gds> d04tl: No, I'm afraid you can't.
08:04:05 <Cale> join (liftM2 f x y)
08:04:08 <gds> and it doesn't.
08:04:17 <basvandijk> Cale: ofcourse thx!
08:04:19 <integral> d04tl: there's also a variety of things in the IO monad, let, <-, and IOVars
08:04:27 <Templar> ?lambdabot
08:04:28 <lambdabot> Unknown command, try @list
08:04:32 <Cale> IORefs
08:04:35 <d04tl> "let x = A in E" ?
08:04:36 <Templar> @list
08:04:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
08:04:45 <Cale> > let x = 5 in x + 6
08:04:47 <lambdabot>  11
08:04:52 <Cale> d04tl: like that
08:05:01 <gds> indeed - "where" is also a nice thing...
08:05:28 <Cale> > let f x = y + y where y = x * x in f 5
08:05:30 <lambdabot>  50
08:05:47 <Templar> ?version
08:05:48 <lambdabot> lambdabot 4p188, GHC 6.5 (OpenBSD i386 )
08:05:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:06:10 <d04tl> im not shore i get it?
08:06:26 <Cale> d04tl: well, your question is sort of vague :)
08:06:53 <Cale> d04tl: the answer is basically that execution isn't in order of lines in Haskell, unless you're in a suitable monad for that
08:07:13 <Cale> d04tl: Evaluation order in Haskell is based on demand
08:07:30 <Cale> things are evaluated only when their value is needed in order to produce some output
08:09:02 <Cale> We have variables in the sense of function parameters, and defined constants, but not in the sense of memory locations which can be repeatedly updated. (Actually, that's a lie, we do, but you probably don't want them as a beginner)
08:09:33 <Cale> Also, we have lists, which are basically the same thing as loops which haven't yet happened :)
08:09:38 <gds> For many of the things that you're used to using variables for, you might want to start thinking of using other functions...
08:10:11 <Cale> I can do something like:
08:10:32 <Cale> > let f 0 = 0; f n = f (n-1) in f 10
08:10:33 <lambdabot>  0
08:10:43 <Cale> and in some sense, that "counts down from 10"
08:11:08 <Cale> If I want to see the values of n while it goes, I can build a list:
08:11:18 <Cale> > let f 0 = [0]; f n = n : f (n-1) in f 10
08:11:20 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
08:12:01 <Cale> So that's a little like a loop, and a little like a variable
08:12:41 <Cale> Also, we have lots of functions for working with lists which replace things which would be loops in other languages
08:12:47 <Cale> For example, we have map
08:12:57 <Cale> > map (+10) [1,2,3,4,5]
08:12:58 <lambdabot>  [11,12,13,14,15]
08:13:06 <d04tl> ok, thx
08:13:09 <Cale> which applies a function to every element of a list
08:13:19 <Cale> > filter odd [1..10]
08:13:20 <lambdabot>  [1,3,5,7,9]
08:13:29 <Cale> and filter, which selects given elements
08:14:39 <Cale> Use higher-order functions when you can, and when there doesn't seem to be one, or you don't know, use recursion.
08:19:33 <Syzygy-> I started writing a new tutorial for HOpenGL, since the ones I found uses matrixExcursions, which aren't defined anywhere in the latest release. So far, my tutorial hasn't deviated all too far from theirs, but in the next installment, it probably will.
08:19:37 <Syzygy-> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
08:19:43 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
08:20:04 <Syzygy->  Oooooh? Automatic tinyurl-ing? Wow.
08:25:36 <sjanssen> Syzygy-: lambdabot does *everything*
08:26:02 <Syzygy-> Yup, I'm starting to realize.
08:26:34 <d04mse> ook... if i call an method say , takeTwo two text = take two text , how can i use takeTwo in other methods without having to fill in two arguments everytime... just make it a vairable... understand?
08:27:24 <Syzygy-> d04mse: Do you mean something like let takeit = (takeTwo foo)
08:27:42 <Syzygy-> which makes takeit Text be evaluated as takeTwo foo Text
08:27:45 <d04mse> ooh .. thats right! thanks!
08:28:04 <lesshaste> glguy, thanks I hadn't seen that
08:35:03 <d04mse> hmm.... not entirly clear yet... i would like to save first = takeF 2 "heello" , but i would like to in the first call to another method say main 2 "heello" make it happen so i later on could just use first as the "he"
08:35:39 <d04mse> hmm... i not beeing clear enough i think
08:36:42 <Syzygy-> Quite.
08:37:41 <d04mse> i want to call the , main arg1 arg2 arg3 , and with that somehow save up different variables that with those arguments should compute different things... but after that is done i would like to use just the variables name and not have to sen in the same arguments over and over again
08:38:03 <Syzygy-> Still not being very clear.
08:39:56 <twanvl> d04mse: What have you got so far?
08:41:42 <d04mse> ook... main wildcard f s = (second wildcard s ) (.) (first wildcard f ) , after that is done , i would like to call compare first second (something like that) and not compare first (wildcard f) second (wildcard s) ,where compare is a two arguments function....
08:43:23 <jgrimes> what kind of usage analysis is implemented in ghc?
08:44:23 <cjeris> d04mse: what you want is analogous to
08:44:24 <cjeris> > let add5 = ((+) 5) in map add5 [1..10]
08:44:25 <lambdabot>  [6,7,8,9,10,11,12,13,14,15]
08:44:28 <dons> d04mse: do you mean to ue getArgs?
08:44:35 <dons> use
08:44:49 * Igloo sees people in scrollback begging me to put something in ghc 6.6, but not what it is  :-)
08:45:42 <dons> Igloo: oh, dcoutts wants to tweak the bytestring api a litte, adding a defaultChunkSize :: Int.
08:46:07 <dons> scared him off
08:46:10 <Igloo> That's probably fine as BS is normally imported qualified
08:46:46 <dons> ok, i'll push a patch in the morning then, to export this value
08:47:32 <dons> Syzygy-: do you write much haskell/programming stuff on your blog? if so, you should ping ibid and have him add your blog to http://planet.haskell.org
08:47:34 <lambdabot> Title: Planet Haskell
08:47:54 <yip> where is Syzygy-'s blog?
08:48:30 <Syzygy-> dons: It's slowly growing in haskell content.
08:48:54 <d04mse> well in java you could, String first = first(wildcard, f) , String second = second(wildcard,s) , and then just take Compare(first, second) , so far I've understood its only possible in haskell to to do it like Compare( first(wildcard, f), second(wildcard,s) )
08:48:55 <dons> http://tinyurl.com/ea6tc
08:48:58 <Syzygy-> But I could always add the haskell category to planet.
08:49:00 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell - a tutorial ...
08:49:14 <dons> ibid: Syzygy-'s blog.
08:49:22 <dons> Syzygy-: can you hand ibid an rss url?
08:50:34 <yip> Syzygy-: cool, opengl
08:50:41 <gds> d04mse: or you can do it like: compare a b where a = wildcard f ; b = wildcard s
08:50:44 <cjeris> d04mse: if i understand correctly what you're asking for, it seems that either 'let' or 'where' is exactly what you want.
08:50:46 <Syzygy-> Sure. Gotta figure out how to get a feed url for a category in WP first...
08:51:00 <Syzygy-> ibid: feed is at http://blog.mikael.johanssons.org/archive/category/computer/programming/haskell/feed  for the haskell stuff.
08:51:05 <lambdabot> http://tinyurl.com/zexdq
08:51:20 <Syzygy-> yip: Ayup.
08:51:22 <yip> Syzygy-: if you figure out how to get VBO extension working please tell me the secret
08:51:37 * ndm just created a compiler benchmark on which I beat GHC :)
08:51:37 <Syzygy-> In the end, I want to do funky topology stuff and morse theory with visualization and triangulations...
08:51:46 <Syzygy-> VBO extension?
08:51:55 <jgrimes> ndm, :)
08:52:07 <yip> vertex buffer object, it's pretty much become the standard drawing method in opengl in the last few years
08:52:11 <dons> ndm: cool!
08:52:13 <Syzygy-> Ah.
08:52:19 <dons> ndm, more work for SimonM then :)
08:52:26 <yip> deprecates display lists and vertex arrays
08:52:42 <ndm> dons: of course :) - and my compiler doesn't yet have inlining or strictness analysis, which will should give a big boost
08:52:55 <Syzygy-> Everything relevant should be around in the HOpenGL api anyway, right?
08:53:02 * Syzygy- wouldn't dare go mess around in there quite yet.
08:53:09 <dons> ndm, its really good to get some competition in this area, I think.
08:53:30 <dons> we don't know what bits of ghc are slow unless we try to compete against other compilers (or other languages)
08:53:44 <ndm> dons: agreed - i was also going to move to ByteString for all internal string storage - then a primitive string is a bytestring by default
08:53:47 <vincenz> nickserv down/
08:53:51 <ptolomy> Today is hackathon day, yes?
08:53:52 <vincenz> nickserv down?
08:54:09 <dons> ndm, that'd be really interesting.
08:54:28 <dons> a bit like ghc's use of packed strings for literals? or more extensive?
08:54:40 <ndm> now to persuade my supervisor that writing an optimising compiler is a worthwhile phd....
08:54:45 <ndm> more extensive
08:54:46 <dons> heh
08:55:00 <yip> Syzygy-: i'm not sure. HOpenGL api only seems to support opengl 1.5, while VBO was added only to opengl 2.0
08:55:05 <ndm> have proper bytestrings for literals, which can be bytestring tweaked as normal
08:55:17 <Syzygy-> yip: Ah, in that case I'm definitely not the right person to poke.
08:55:34 <Syzygy-> Looks like the secret would be "Port HOpenGL to OpenGL 2.0"
08:55:44 <dons> ndm, any thoughts on pattern matching such things?
08:55:58 <dons> using view-ish games, perhaps?
08:56:14 <ndm> dons: my compiler does pattern matching differently :)
08:56:30 <dons> oh, its not a haskell compiler?
08:56:36 <yip> i'm still not sure if "haskellizing" the api for opengl is really such a good idea
08:56:46 <ndm> it uses advanced static analysis to prove that a value is :/[], and then skips the test and just prods about in the memory
08:56:50 <ndm> it is a haskell compiler
08:56:59 <ndm> it just compiles cases differently
08:57:05 <dons> sounds spiffy
08:57:17 <d04tl> What does !! mean in haskell in for instance "pick u xs = xs !! (floor.(u*).fromIntegral.length) xs"
08:57:23 <dons> ?type (!!)
08:57:25 <lambdabot> forall a. [a] -> Int -> a
08:57:29 <dons> > "haskelll" !! 3
08:57:31 <lambdabot>  'k'
08:57:55 <dons> d04tl: list indexing :)
08:58:00 <dons> ?users
08:58:03 <lambdabot> Maximum users seen in #haskell: 242, currently: 235 (97.1%), active: 37 (15.7%)
08:58:35 <d04mse> ook ... i have this call from ghci : matchoo 'l' "hello" "bello" ... matchoo wildcard t s = compare first second (new line) where first = takeFirst wildcard t (new line) second = takeSecond wildcard s ... is that the right way to implement?
09:01:19 <d04mse> gds  ook ... i have this call from ghci : matchoo 'l' "hello" "bello" ... matchoo wildcard t s = compare first second (new line) where first = takeFirst wildcard t (new line) second = takeSecond wildcard s ... is that the right way to implement?
09:01:59 <dons> d04tl: don't repeat questions. it's just difficcult to understand what you're trying to do.
09:02:13 <dons> d04mse: I mean.
09:02:30 <d04tl> Im not shore i follow, could you give me an easyer line of code then the one I gave you where they use !!
09:03:09 <dons> d04mse and d04tl, are you working on an assignement? :)
09:03:18 <d04mse> yeees!
09:03:26 <d04mse> hahaha
09:03:44 <glguy> Ohh, that's why people were asking for cool ways to do substitute last night
09:04:11 <d04tl> dons: yeah and I must say its really difficult
09:04:12 <glguy> Good thing I only pulled out my 9-iron after he demonstrated that he'd nearly completed the assignment
09:04:29 <glguy> dons: I'm supposed to be helpful, and not just show them fun ways to do it, right?
09:04:31 <d04tl> glguy: hehe
09:04:33 <yip> @seen dcoutts
09:04:34 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
09:04:42 <d04mse> yeah... well we managed to that on our own yesterday... but it's easy getting started with haskell
09:04:44 <dcoutts__> @arr
09:04:44 <lambdabot> Aye
09:04:47 <dons> yeah, the idea is to be helpful.
09:05:00 <dcoutts__> @localtime dons
09:05:02 <lambdabot> Local time for dons is Fri Sep 15 02:04:38 2006
09:05:22 <dons> d04tl, it's for indexing into a list:
09:05:28 <dons> > [1..5] -- a list
09:05:29 <lambdabot>  [1,2,3,4,5]
09:05:30 <d04tl> ko
09:05:30 <d04mse> lambdabot... are you from sweden?
09:05:31 <d04tl> ok
09:05:35 <dons> > [1..5] !! 2 -- the 3rd element
09:05:36 <lambdabot>  3
09:05:43 <glguy> ?vixen Are you from Sweden?
09:05:43 <lambdabot> first you tell me.
09:05:52 <d04mse> jaa
09:05:54 <ibid> Syzygy-: how can i tie your irc personality to that blog? (i like to have some evidence that the person giving me permission is the author)
09:06:09 <ibid> Syzygy-: also, the feed doesn't need to be strictly haskell
09:07:21 <dons> ?where lambdabot
09:07:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:07:35 <dons> she did live in sweden for a while, several years
09:07:57 <dons> until around May 2005, when she moved back to Australia
09:08:21 <dons> (having grown up there)
09:08:42 <bringert> so, who else is at the ghc hackathon?
09:08:44 * bringert looks around
09:12:04 <glguy> > let sub w t x=let f|w==x=t|otherwise=[x] in f in "*: says *" >>= sub '*' "glguy"
09:12:05 <lambdabot>  "glguy: says glguy"
09:15:24 <dcoutts__> dons: ugg, I'm zlib is harder that I thought :-)
09:15:25 <dcoutts__> dons: the standard example code is push oriented, but of course we need to invert that into a demand driven style
09:15:30 <dcoutts__> to make it interact nicely with lazyness
09:15:36 <dcoutts__> and I can't seem to get the various states straight in my head
09:17:46 <Igloo> dcoutts__: cabal already has register --inplace, BTW
09:17:59 <dcoutts__> Igloo: really? oh I didn;t know
09:18:39 <yip> dcoutts__: hi, any news about gtk2hs?
09:19:33 <glguy> d04tl, d04mse: why are you nick's both seemingly completely random and totally related?
09:19:54 <glguy> are you using some kind of Java irc client that assumes you won't know how to change your nick so it randomizes it?
09:20:03 <jbalint> Java?
09:20:30 <dons> glguy: school-assigned user names...
09:20:33 <glguy> ah
09:20:42 <dons> i.e. like d00nibro, iirc
09:20:49 <glguy> jbalint: you know those goofy Java-aplet irc clients
09:21:08 <jbalint> glguy: Oh, yeah. :)
09:21:26 <glguy> HAHA! my CSS layout works
09:22:09 <Syzygy-> ibid: Please do tie in my irc persona. The rest of the blog varies between "catblogging" and higherlevel algebra.
09:22:37 <Syzygy-> The global feed is at http://blog.mikael.johanssons.org/feed
09:24:46 <ibid> Syzygy-: i mean, while i don't really doubt you are the author, i like to have some evidence of that :)
09:25:05 <dons> Syzygy- == mikael == mikael.johanssons ?
09:25:21 <ibid> Syzygy-: i suppose your irc realname is weak evidence. hm, okay.
09:25:35 <mikael> I am equal to no-one but myself!
09:25:36 <dons> Syzygy-: you just logged in as mikael ?
09:25:51 <Syzygy-> dons: I'm not mikael.
09:26:09 <Syzygy-> I am however a Mikael Johansson.
09:26:15 <dons> oh, I thought I was watching evidences :)
09:26:26 <dons> mikael: sorry for thinking you were mikaelj :)
09:26:35 <Syzygy-> ibid: Oh, that's what you were talking about...
09:26:57 <Syzygy-> ibid: Give me a moment... :P
09:26:59 <ibid> Syzygy-: for example, a brief post about planet haskell has been used in other similar cases :)
09:27:23 <Syzygy-> Ah, that way. Sure... :)
09:27:44 <dons> ?users
09:27:45 <lambdabot> Maximum users seen in #haskell: 242, currently: 232 (95.9%), active: 37 (15.9%)
09:27:58 <Syzygy-> Otherwise, take a look at the about-page. :)
09:28:04 <Syzygy-> http://blog.mikael.johanssons.org/about/
09:28:06 <lambdabot> Title: Michi&#8217;s blog Â» About
09:28:08 <ibid> Syzygy-: the reason for this is that a planet is republishing your copyrighted content, and i like to have reasonable guarantees that i have the copyright holdser's permission for this
09:28:25 <ibid> Syzygy-: i did. didn't see your irc nick there
09:28:31 <Syzygy-> Do it again.
09:28:46 <ibid> ah :)
09:28:49 <ibid> that's enough :)
09:29:14 <ibid> feel free to post about planet, though.  it isn't required for this, however
09:31:53 <ibid> Syzygy-: look at planet and tell me if your listing is wrong :)
09:32:59 <Syzygy-> ibid: Coool. Looks good enough.
09:35:18 <lispy> dons: for the lambda web shell do you think it would be possible to make lambdabot accept multiline input?
09:35:35 <lispy> for things like run
09:35:38 <dons> maybe, yes
09:35:56 <dons> also, i think there was an issue with @more on the web interface
09:36:14 <lispy> i think i disabled the More module
09:36:36 <lispy> oh, no it's in there
09:36:45 <bringert> lispy: I've got a working AJAX shell for lambdabot now
09:36:50 <lispy> so let's see...what is a command taht uses @more
09:36:51 <dons> i typed 'more' and it didn't respond, and then I think it rebooted
09:36:51 <bringert> it looks like crap, but it works
09:36:54 <lispy> bringert: cool
09:36:57 <dons> hehe cool
09:37:06 <lispy> bringert: url?
09:37:12 <mnislaih> bringert: cool!
09:38:22 <lispy> dons: i'm not sure @more makes sense in terms of the apachethreading
09:38:34 <dons> no, I don't think it does
09:40:13 <dons> Syzygy-: oh, only the partial articles are syndicated to planet?
09:40:47 <Syzygy-> dons: I think the feed only drops an extract. I can dig around my wordpress and see if I can get it to change the behaviour.
09:41:04 <bringert> weird, it only works when it's a local file, not when I put it on the web server
09:41:12 <tibbe> bringert: an AJAX shell? where?
09:41:24 <bringert> I'll come back with a url once I get it working outside my machine
09:41:29 <tibbe> ok
09:41:32 <lispy> bringert: cool
09:41:37 <lispy> bringert: no hurry
09:41:46 <tibbe> perhaps I'll finally be able to get my haskell fix at work!
09:42:10 <lispy> dons: okay, i turned off @more, do you know a way to test it?
09:42:15 <Syzygy-> Does Planet resyndicate easily?
09:42:28 <lispy> well, says it's an unknown command
09:42:32 <lispy> guess that's good enough for now
09:42:39 <dons> Syzygy-: every hour, yep.
09:42:51 <ibid> Syzygy-: there are planet feeds if that's what you mean
09:43:03 <ibid> yeah, it's cron based and runs at every full hour currently
09:43:13 <Syzygy-> ibid: Nono, I just tweaked my blog software to give full posts in the rss instead of just extracts.
09:43:34 <ibid> Syzygy-: it should pick it up in 20 minutes or so
09:43:34 <dons> right, I think planet will pick that up on the next hour
09:43:36 * lispy needs to blog about his experience building the lambdabot cgi
09:43:49 <Syzygy-> On the hour? Or some weird offset?
09:44:05 <dons> lispy: some analysis of how the darcs+cabal glue all worked would be interesting
09:44:18 <lispy> dons: exactly what i was thinking
09:44:20 <d04tl> can you go throu i last backwards like [ f x|x<-list] but backwards?
09:44:22 <ibid> Syzygy-: xx:00, assuming that the machine clock isn't running early or late
09:44:22 <dons> if you're taking backseat blogging advice :)
09:44:27 <Syzygy-> Check.
09:44:34 <Syzygy-> So local xx:00
09:44:42 <Syzygy-> dons: Backseat advice on what?
09:44:50 <lispy> d04tl: [ f x | x <- reverse list ]
09:44:51 <Syzygy-> Oh, to lispy..
09:44:54 <dons> yep
09:45:18 <lispy> > [x | x <- reverse [1..5]]
09:45:19 <lambdabot>  [5,4,3,2,1]
09:45:26 <dons> > map toUpper "haskell"
09:45:27 <lambdabot>  "HASKELL"
09:45:31 <dons> > map toUpper .reverse $  "haskell"
09:45:33 <lambdabot>  "LLEKSAH"
09:45:42 <d04tl> lispy: thx
09:46:04 <Syzygy-> > [7-x|x<-reverse[1..5]]
09:46:05 <lambdabot>  [2,3,4,5,6]
09:46:28 <lispy> Syzygy-: is whitspace the enemy ;)
09:46:34 <ibid> Syzygy-: the cron setup is subject to change without notice :)
09:46:46 <Syzygy-> lispy: Something like that... :P
09:47:15 <Syzygy-> ibid: I'm mainly interested in what it's like -now- so I can observe whether my feed behaves as it should.
09:47:27 <ibid> Syzygy-: sure :)
09:47:46 <lispy> ah, Colin doesn't want to darcsify smallcheck
09:47:50 <ibid> Syzygy-: you can also grep for it in logs :)
09:47:54 <lispy> that makes it harder to send patches, IMHO
09:48:21 <ibid> Syzygy-: oh, and every time that i add feeds, it pings every feed, unfortunately
09:48:30 <Syzygy-> Ah.
09:48:51 <dons> lispy: why's that?
09:49:05 <dons> ndm. can you do anything about this ? :)
09:49:21 <ibid> here's a project for someone: rewrite planetplanet in haskell (warning: this is harder than it sounds)
09:49:35 <dons> ibid, can we start with lambdaFeed?
09:49:36 <Syzygy-> planetplanet is the part that drives planet.haskell.org?
09:49:39 <ndm> dons: i can have a try...
09:49:46 <ibid> Syzygy-: it's the software i use, yes
09:49:51 <Syzygy-> Right.
09:49:56 <ndm> dons: but he's not exactly an "internet facing" kind of guy, and i very much doubt he has ever used darcs
09:50:05 <ibid> dons: dunno. does it work as well as mark pilgrim's feedparser?
09:50:22 <dons> ndm, hehe. interesting phrase "internet facing"
09:50:41 <dons> ibid, dunno
09:51:00 <ndm> dons, lispy: if you send patches to him, you can tell him that the York FP team already has about 10 darcs repo's on the website, and its really easy to add another, and we'd give him a hand
09:51:08 <ibid> dons: because that's the curse-evoking part of rewriting planet
09:51:12 <dons> ndm, no revision control for colin?
09:51:14 <ndm> actually, he must have used darcs, since i refused to send a tarball of my work
09:51:19 <ndm> dons: probably not, no
09:51:27 <dons> wow.
09:51:31 <ibid> dons: there are n+1 feed formats, all different, and some having the same name
09:51:32 <ndm> dons: maybe CVS, but i doubt it
09:51:33 <araujo> yay!
09:51:38 <dons> old school.
09:51:44 * araujo back from univ and hungry
09:52:11 <dons> ibid: yeah, sounds like a nightmare of icky parsing
09:52:37 <ndm> dons: smallcheck is definately not in any version control system
09:52:50 <ndm> dons: although i do have read/write access to it :)
09:53:03 <dons> ah, but there you are wrong ;) it's in lambdabot's darcs repo ..
09:53:06 <SyntaxNinja> this is a good hackathon!
09:53:12 <lispy> dons: why is it harder to send patches?  well, darcs automates it :)
09:53:25 <ibid> dons: add to that the fact that planetplanet has to be liberal in what it accepts and still be strict in what it sends, and considering that many feeds that people would like to add to planets are not valid...
09:53:29 * dons sees ots of pdx.edu addresses suddenly
09:53:37 <lispy> SyntaxNinja: you'll be at the haskell-workshop?
09:53:43 <SyntaxNinja> lispy: ja
09:53:45 <lispy> SyntaxNinja: if so, i'd like to shake hands and say hi
09:54:02 <SyntaxNinja> I started a kinda "working" page here: http://hackage.haskell.org/trac/ghc/wiki/Hackathon/Hack
09:54:05 <lambdabot> Title: Hackathon/Hack - GHC - Trac, http://tinyurl.com/k5t6b
09:54:05 <lispy> is the hackathon now?
09:54:10 <SyntaxNinja> it is NOW!
09:54:14 <lispy> wow!
09:54:15 <lispy> ;)
09:54:22 * lispy wishes he could have gone
09:54:22 <ndm> SyntaxNinja: is it being web-cast in any way?
09:54:27 <SyntaxNinja> lispy: yeah
09:54:36 <dons> ndm, via irc :) as per usual
09:54:37 <SyntaxNinja> ndm: not usre. I see malcolm filming, not sure if he's webcasting
09:54:51 <ndm> ok, well as long as i can see it after
09:54:52 <lispy> well, i need to head to the office
09:54:56 <lispy> ttyl, all
09:55:01 <SyntaxNinja> l8r lisp
09:57:09 <dons> night. happy hacking! i hope to see lots of commits from the hackathon.. :)
09:57:17 * dons evaporates
09:57:58 <SyntaxNinja> l8r dons
09:58:07 <ndm> commits on Cabal would be nice too :)
10:03:27 <SyntaxNinja> ndm: comments?
10:03:57 <ndm> SyntaxNinja: ? i just meant it would be nice to see people trying to integrate GHC with Cabal more
10:04:09 <ndm> i.e. moving to the base libraries compiling with Cabal :)
10:04:17 <SyntaxNinja> ndm: you could add that to the page :)
10:04:25 <ndm> SyntaxNinja: and this is the perfect time for you to ask Malcolm about dependancy analysis in hmake for Cabal!
10:05:49 <tibbe> I started writing an uninstall for Cabal until I saw that the install doesn't work by installing to a build dir and then copying to the "live" file system
10:06:00 <tibbe> I lost motivation then :/
10:10:19 <SyntaxNinja> ndm: it would be perfect if you were here yeah :P
10:10:30 <Syzygy-> ibid: Are you using the description or the content tag in the feed to dump on the first page @ planethaskell?
10:10:42 <ndm> SyntaxNinja: yeah, never mind - maybe next year
10:10:43 <SyntaxNinja> tibbe: it could be made to work like that --copy works like that.
10:11:23 <tibbe> SyntaxNinja: I think it would be easier to add such things then
10:11:42 <tibbe> SyntaxNinja: my app basically built an uninstall list from that
10:13:00 <SyntaxNinja> tibbe: ahh.  well it wouldn't be hard to change.  just look at the way --copy works and make install do a --copy first, then copy everything over.
10:13:25 <tibbe> SyntaxNinja: I'll try
10:15:40 <ndm> SyntaxNinja: suggestion page edited to include "Setting up GHC to build the base library using Cabal (since you have the GHC team, the Cabal team and the hmake team in one place!)"
10:16:19 <tibbe> SyntaxNinja: do you see any obstacles to changing install to be like copy?
10:16:47 <ibid> Syzygy-: don't remember, and i'm now doing other stuff
10:19:01 <SyntaxNinja> ndm: thanks
10:19:21 <SyntaxNinja> tibbe: not that I know of.
10:43:49 <SyntaxNinja> glad to hear that spj also mistakenly says "gcc" when he means 'ghc' ;)
10:44:07 <dcoutts__> heh
10:44:51 <SyntaxNinja> dcoutts__: how come you aren't here?
10:45:43 <dcoutts__> SyntaxNinja: it's a long way away!
10:45:43 <dcoutts__> SyntaxNinja: well mainly it's because I'm with my gf in .se for the whole month
10:45:48 <dcoutts__> is it fun so far?
10:45:53 <dcoutts__> any interesting talks?
10:47:06 <yip> dcoutts__: is there any news about gtk2hs?
10:47:30 <dcoutts__> yip: I'm part-way through reviewing int-e's patches
10:49:30 <SyntaxNinja> dcoutts__: we're talking about compiling.
10:49:39 <yip> dcoutts__: cool
10:50:03 <dcoutts__> SyntaxNinja: well keep us posted of any interesting discussions
10:50:43 <SyntaxNinja> will do!
10:50:50 <SyntaxNinja> you should talk malcolm into live streaming ;)
10:51:04 <dcoutts__> oh yes, that'd be cool
10:53:26 <ventonegro> just tried to compile the opengl gtk2hs demo, but it complains about not finding Graphics.UI.Gtk.OpenGL
10:53:55 <ventonegro> do I need anything else besides hopengl and gtk2hs?
10:54:30 <dcoutts__> ventonegro: well you need to build gtk2hs to use OpenGL
10:54:30 <int-e> gtkglext
10:54:40 <dcoutts__> which it will do automatically if it's available
10:54:40 <dcoutts__> so you're probably missing something
10:54:52 <dcoutts__> to force it, use ./configure --enable-opengl
10:54:54 <ventonegro> dcoutts, it's debian's gtk2hs
10:54:57 <dcoutts__> and it'll tell you what's missing
10:54:59 <int-e> ventonegro: gtkglext is missing.
10:55:13 <int-e> and yes, it'll tell you that.
10:55:32 <ventonegro> i'm not building from source
10:55:50 <ventonegro> it seems the debian guys have not built it with opengl support
10:56:02 <dcoutts__> ventonegro: ok, well that's got multiple components so you just need to install the gl part of gtk2hs
10:56:08 <tibbe> haskell was mentioned on some programming language event in japan: http://telebody.net/wordpress/?p=3
10:56:09 <lambdabot> Title: Telebody::Falcon Â» Blog Archive Â» Boxing in the LLRing
10:56:49 <tibbe> s/on/at
10:57:54 <ventonegro> there are components for glade, cairo, mogul etc. but not for opengl :-(
10:57:56 <ventonegro> damn
11:01:28 <liyang> ventonegro: ah hah. Will look into that.
11:01:56 <ventonegro> liyang, cool
11:02:15 <ventonegro> i'm still learning and don't wanna bother building it
11:02:58 <dcoutts__> ventonegro: oh sorry, I forgot, the released version doesn't have opengl yet, you'll need the dev version
11:02:58 <dcoutts__> ventonegro: so you will need to build from source
11:03:35 <ventonegro> dcoutts, ok
11:03:36 <liyang> oh right. I was worried I missed something there. ;)
11:03:43 <dcoutts__> ventonegro: right, the opengl is only in the dev version at the moment
11:03:45 <dcoutts__> ventonegro: but it's fairly easy to build that from source
11:04:05 <dcoutts__> liyang: sorry, I got confused :-)
11:04:13 <liyang> dcoutts__: are we looking at a new release soon?
11:04:26 <dcoutts__> liyang: yep, a month or so perhaps
11:04:31 <ventonegro> good to know EVERYBODY hangs around here
11:04:39 <dcoutts__> liyang: we need a new release for ghc 6.6 anyway
11:04:44 <liyang> *nod*
11:04:44 <ventonegro> gotta think twice before cursing any haskell package :-)
11:04:52 <dcoutts__> heh, indeed
11:05:17 <dcoutts__> ventonegro: just mentioning the package name will make the maintainer prick up their ears :-)
11:05:37 <ventonegro> :-)
11:05:46 <liyang> Well, only if I'm looking at the channel, which isn't always.
11:06:06 <liyang> I should make my IRC client watch for it, however. =)
11:06:46 <ventonegro> just opened a hopengl tutorial
11:07:05 <ventonegro> the title: "A Small HOpenGL tutorial (draft)"
11:07:12 <ventonegro> and it has more than 100 pages
11:14:09 <ventonegro> @index renderPrimitive
11:14:09 <lambdabot> Graphics.Rendering.OpenGL.GL.BeginEnd, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
11:17:14 <ventonegro> @index vertex
11:17:14 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
11:17:28 <Igloo> Hmm, making cabal ignore GHC.Pri.hs when compiling is a pain
11:17:34 <ventonegro> @type Graphics.Rendering.OpenGL.GL.VertexSpec.vertex
11:17:35 <lambdabot> forall a. (Graphics.Rendering.OpenGL.GL.VertexSpec.Vertex a) => a -> IO ()
11:17:37 <Igloo> GHC/Prim.hs IM
11:18:08 <CosmicRay> Igloo: vorlon was asking about ghc on alpha the other day, and I forgot where you were with that
11:18:31 <linuxsux> haskell sux
11:18:33 <Igloo> My plan is to rebootstrap and see what happens
11:18:54 <CosmicRay> Igloo: do you need me to sign you back into the testing environment at some point?
11:19:07 <SyntaxNinja> linuxsux: u a bot?
11:19:09 <CosmicRay> linuxsux: maybe, but perl sux more.
11:19:13 <Igloo> I'll probably ask him if he has a faster alpha first
11:19:25 <Patterner> I like perl and haskell
11:19:28 <CosmicRay> Igloo: ah, good plan
11:19:31 <ventonegro> perl only doesn't suck more than brainfuck
11:19:51 <Igloo> The bootstrapping really ought to be done in an unstable root, anyway
11:19:54 <CosmicRay> SyntaxNinja: he's running mirc
11:20:05 <SyntaxNinja> phragmented: y0
11:20:16 <CosmicRay> Igloo: ah, well I could update that to unstable without much trouble.  just let me know if you want it.
11:20:31 <Igloo> OK, thanks
11:20:38 <linuxsux> i program in brainfuck
11:20:46 <CosmicRay> I do hope that bootstrapping ghc for alpha/linux is a lot easier that bootstrapping it for aix.  probably is.  ;-)
11:21:18 <sieni> anything is easier than anything on aix. except anything on hp/ux.
11:21:25 <sieni> and z/os.
11:23:44 <nomeata> linuxsux: I programed a brianfuck interpreter in haskell recently, thereby proving that haskell is at least as mighty as brainfuck.
11:23:51 <ventonegro> why the tutorial says that := is not allowed as a function in haskell, when gtk2hs uses it?
11:23:59 <ventonegro> hopengl uses $=
11:23:59 <nomeata> linuxsux: can you prove the reverse?
11:24:18 <yip> := is allowed as a constructor
11:24:23 <dcoutts__> ventonegro: it's a data contructor, not a function
11:24:24 <mwc> ventonegro, operators starting with : define constructors
11:24:45 <ventonegro> i see, thanks
11:24:48 <mwc> just like Foo is a constructor and foo is a function
11:24:49 <dcoutts__> to be honnest its use in gtk2hs is just trickery
11:25:08 <mwc> Pah, trickery, In haskell?
11:25:16 <dcoutts__> cunning trickery that we pinched from somewhere else
11:25:30 <dcoutts__> stolen cunning trickery, the worst kind :-)
11:25:46 <ventonegro> nomeata, as brainfuck is turing-complete, that could be done, no?
11:27:12 <nomeata> ventonegro: well, I want him to prove it by implementing haskell in brainfuck :-)
11:27:33 <ventonegro> nomeata, :-)
11:28:05 <mwc> Nah. Implement Unlambda in Brainfuck running on Befunge
11:28:12 <mwc> that would be the trifecta of awesome
11:29:38 <ventonegro> as i learn more and more of haskell i want to rewrite everything i've ever written in it
11:29:45 <ventonegro> dunno if it's good or bad
11:30:25 <ral1> ventonegro: I feel the same way about haskell.   I also feel that way about every language that I like though ... ;)
11:30:45 <int-e> mwc: do you know that there is an unlambda interpreter written in intercal?
11:31:38 <mwc> int-e, no, I didn't. Intercal kind of coddles the programmer though
11:31:50 <mwc> Malbolge is a much crueler effort
11:31:51 <int-e> it has arrays, yes.
11:32:27 <waern> SyntaxNinja, I'm hacking Cabal... I want to get hold of GHC's library dir (e.g /usr/local/lib/ghc) if GHC is installed.. how do I do that?
11:32:31 <Igloo> dcoutts__, SyntaxNinja: Am I missing a way to make cabal use -O with GHC?
11:32:44 <int-e> heh, I never liked malbolge. it's not turing complete.
11:32:47 <dcoutts__> Igloo: no, I keep wanting that
11:33:10 <SyntaxNinja> waern: if ghc is installed?  are you getting the ghc source via darcs?
11:33:10 <dcoutts__> Igloo: I want something like: ./setup [configure|build] --optimise
11:33:21 <sieni> dcoutts__: wardriving around Djursholm?
11:33:27 <SyntaxNinja> Igloo: you could always use extra-ghc-opts (or wahtever) in the .cabal file.
11:33:50 * Igloo has done that now. But really I'd expect it to be the default
11:33:54 <dcoutts__> sieni: heh, no, struggling to get WPA working
11:33:54 <waern> SyntaxNinja, I mean from inside Cabal sources.. :) how to determine the path (if the user has GHC installed)
11:34:14 <dcoutts__> SyntaxNinja: is there a reaon we don't have a --optimise flag somwehre
11:34:32 <dcoutts__> SyntaxNinja: it's the kind of thing where it's the user not developer who what's to set that
11:34:42 <waern> SyntaxNinja, I need to pass that path to the haddock-ghc program, in Simple.hs
11:34:49 <sieni> dcoutts__: what are you doing at mittag-leffler institute (I spent academic year 2001-2 there)
11:34:52 <dcoutts__> eg sometimes you want a quick build, sometimes and optimised one
11:35:11 <dcoutts__> sieni: I'm not there myself, but my gf is
11:35:41 <sieni> Actually I thought so :-)
11:36:23 <dcoutts__> aye, I'm not the mathematician
11:36:40 <SyntaxNinja> dcoutts__: yeah, no good reason not to have an --optcimze flag in confiure or whatever. (damn keyboard)
11:36:48 <SyntaxNinja> dcoutts__: should be quite easy. go for it.
11:36:50 * Igloo throws things at cabal
11:37:00 <dcoutts__> SyntaxNinja: so if I snuck one in before the final release... :-)
11:37:05 <dcoutts__> that'd be ok you think?
11:37:17 <SyntaxNinja> dcoutts__: probably
11:37:24 <Igloo> Any idea what cabal is doing when it says:
11:37:25 <Igloo> dist/build/GHC/Prim.o: getModificationTime: does not exist (No such file or directory)
11:37:26 <dcoutts__> SyntaxNinja: I think it's a bad practice to encourage people to put -O/-O2 into .cabal files
11:37:28 <Igloo> ?
11:37:36 <SyntaxNinja> dcoutts__: agreed.
11:37:44 <SyntaxNinja> (sorry ;)
11:37:49 <dcoutts__> heh
11:37:55 <Igloo> Oh, no, it must be GHC that's complaining
11:37:57 <phragmented> hackathoners: OS X (ppc) boostrapping is dying at stage 2 (ghc-6.5: unknown package: regex-compat-0.71)
11:38:17 <dcoutts__> SyntaxNinja: I keep meaning to write a cabal lint to complain about things like that :-)
11:38:22 <SyntaxNinja> waern: er, don't really know what to do there, from cabal's perspective, I'm not sure there's reawlly an "official" ghc library dir.
11:38:39 <SyntaxNinja> Igloo: do you have any idea? is that path avaiable in the ghc api?
11:40:12 <waern> SyntaxNinja, okay
11:40:22 <waern> I'll just change the haddock-ghc interface instead then
11:43:08 <mnislaih> phragmented: I'm on a leave now. Can you check that your ./configure completed without errors ?
11:43:23 <dcoutts__> SyntaxNinja, Igloo: supposing we had a -O/--optimise cabal flag, is it most appropriate to put it on the configure or build steps ?
11:43:32 <mnislaih> also, make sure that you autoreconf'ed after you did the 'darcs-all'
11:43:53 <Igloo> SyntaxNinja: What path, sorry?
11:44:26 <SyntaxNinja> gotta run. I forgot my power supply, want to save some battery. peace out
11:44:40 <SyntaxNinja> dcoutts__: er, configure IMO, I like ./setup build to have no arguments :)
11:44:44 <Igloo> dcoutts__: I think --optimise should be the default, as it should happen if people just configure/build/install things they get from the 'net
11:44:46 <dcoutts__> SyntaxNinja: ok
11:44:46 <SyntaxNinja> but I can see an argument for either.
11:44:49 <phragmented> mnislaih: yes, I did re-autoreconf, where do I check for configure errors?  (I didn't see one - that output has paged off the top)
11:44:56 <SyntaxNinja> Igloo: ask waern
11:44:58 <SyntaxNinja> sorry, bbl
11:45:16 <mnislaih> phragmented: in that case, do a ./configure again and check for errors
11:45:36 <dcoutts__> Igloo: mm, I think I might leave it off for the moment, for random users installing random stuff in future they'll probably use cabal-install
11:45:40 <dcoutts__> and it can pass -O
11:45:54 <waern> Igloo, never mind that
11:45:57 <dcoutts__> Igloo: and noone except you an me have complained yet :-)
11:46:09 <mnislaih> phragmented:  or better, just check config.log
11:46:38 <Igloo> dcoutts__: I suspect that's only because no-one has noticed, though  :-)
11:46:46 <dcoutts__> Igloo: exactly! :-)
11:46:56 <Igloo> dcoutts__: ...because cabal isn't actually used much
11:47:01 <dcoutts__> haha
11:47:10 <dcoutts__> Igloo: what I'd like to do is make cabal warn when people put -ON into the ghc-options, and tell them to use configure -ON
11:47:12 <d04mse> how do you use variables defined under where under a method outside the method?
11:47:15 <Igloo> Also, people won't necessarily no if their code is slower than it should be
11:48:37 <astrolabe> d04 you don't.  They're local to the other method
11:49:23 <astrolabe> Oh, and 'methods' are called 'functions' in haskell, for a good reason.
11:50:08 <Igloo> Hmm, I think I need some serious magic in GHC or Cabal
11:50:11 <phragmented> mnislaih: config.log says exit 0 at the end. re-running it completes without error.
11:50:39 <mnislaih> phragmented: ok. check that you have a libraries/regex-compat path
11:50:41 <dcoutts__> Igloo: for?
11:50:57 <darius__> hey shae, i was just emailing you
11:50:58 <Igloo> I need it to not build GHC.Prim, but to haddock it
11:51:15 <shapr> darius__: hiya! I just got internet at 'home'
11:51:16 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:20 <darius__> hurrah
11:51:28 <darius__> how are things at home?
11:51:45 <phragmented> A few lines earlier, in the phase 1 compile, it seems to successfully build libraries/regex-compat, so, yes - it's there in libraries.
11:51:47 <shapr> I finally have 'net and phone, still need a driver's license and new SSN card.
11:52:05 <shapr> How's life in the southwest?
11:52:17 <darius__> i didn't realize ssn cards expired
11:52:38 <darius__> life is ok, but skew left me a haskell program that's not compiling
11:52:47 <shapr> greenrd: My new snail mail address is Shae Erisson \n 3041 Cliff Road \n Birmingham, AL 35205 \n USA
11:52:58 <CosmicRay> shapr: you moved to the USA?
11:53:00 <CosmicRay> I totally missed that
11:53:17 <shapr> greenrd: oh, I left out the "Apartment G"
11:53:23 <shapr> Should be part of line two.
11:53:37 <shapr> CosmicRay: Yup, I'm back in the USA for at least a few years.
11:53:43 <darius__> it looks ok to me, but ghc complains about needing an instance of Show for a newtype -- where it ought to be automatic
11:55:23 <d04mse> how do you convert a string to char? if you know that the string is just one token
11:55:37 <darius__> d0: head string
11:56:11 <mnislaih> phragmented: check compiler/stage1/ghc-inplace -v
11:56:21 <mnislaih> does it complain about missing packages ?
11:56:56 <d04mse> darius .. didn't work... head "h" gave us Exception , empty list
11:57:09 <mnislaih> > head "h"
11:57:10 <lambdabot>  'h'
11:57:24 <shapr> darius__: I don't remember whether deriving Show should work for newtypes or not.
11:57:47 <d04mse> head "h2
11:57:49 <d04mse> head "h"
11:58:04 <d04mse> >head "h"
11:58:09 <d04mse> > head "h"
11:58:11 <lambdabot>  'h'
11:58:36 <darius__> shae - dumb question - how do i tell ghc to link to quickcheck? after i get rid of the 'deriving Show's there are a bunch of undefined references
11:59:10 <mnislaih> phragmented: gotta leave, sorry. good luck though! Check the recent mails in cvs-ghc for Andy Gill on the Mac Os PPC build
11:59:19 <phragmented> mnislaih: aha -- that says regex-compat will be ignored due to dependency on regex-posix
11:59:25 <phragmented> will do! thanks.
11:59:35 <shapr> darius__: import Debug.QuickCheck
11:59:58 <darius__> there's already an import Test.QuickCheck in there
12:00:22 <d04mse> is it possible to dropWhile a string instead of chars ?
12:00:48 <d04mse> dropWhile (string  /=) anotherString
12:00:57 <darius__> sorry to annoy you with these basic questions - i'll rtfm but meanwhile other people are held up by a broken build because of this
12:01:26 <mauke> d04mse: that doesn't make sense
12:02:26 <d04mse> mauke why... takeWhile (char /=) string works fine... so it can't be that far fetched
12:02:43 <mauke> d04mse: you can't use /= with a char and a string
12:02:43 <shapr> darius__: It's okay, I'll answer when I have spare cycles. I'm talking to my gf, w00!
12:02:54 <darius__> heh, priorities
12:03:08 <ventonegro> @index $=
12:03:08 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
12:03:44 <inferno_> A man, a plan, a canal, panama!
12:03:50 <d04mse> > takeWhile ('l' /=) "hello"
12:03:52 <lambdabot>  "he"
12:03:58 <d04mse> you see mauke?
12:04:03 <mauke> d04mse: you can't use /= with a char and a string
12:04:10 <phragmented> hackathoners: anyone build a freshly darcs-checked-out tree?
12:07:16 <d04mse> mauke???
12:08:54 <mauke> d04mse: the operands of /= must have the same type
12:09:00 <mauke> "foo" /= 'x' doesn't compile
12:09:42 <inferno_> whats the difference between [a1] and [a]?
12:10:22 <mauke> inferno_: 1
12:10:58 <inferno_> let me refraise, what does this mean: Inferred type: [a1] ?
12:11:25 <mauke> hmm, you got some types wrong
12:11:28 <mauke> what's your code?
12:13:28 <inferno_> http://paste.lisp.org/display/26041
12:14:43 <mauke> Couldn't match `Maybe [a]' against `[a1]'; Expected type: Maybe [a]; Inferred type: [a1]
12:15:15 <inferno_> indeed :)
12:16:45 <mauke> it expecteded 'Maybe [a]' because that's what your declaration says
12:17:01 <mauke> however, substitute returns a plain list, not Maybe something
12:18:36 <inferno_> ah, i see
12:22:10 <_frederik_> hello
12:22:39 <_frederik_> people
12:23:41 <ValarQ> hello
12:23:44 <ValarQ> frederik
12:24:44 <_frederik_> is it me or is this channel getting bigger
12:25:24 <arjanb> it seems like the haskell courses started again
12:25:38 <SamB> heh
12:25:39 <_frederik_> *i* never had any haskell courses
12:25:59 <_frederik_> they fed me o'caml
12:26:18 <SamB> oh really?
12:26:28 <int-e> @users
12:26:28 <_frederik_> in 2002
12:26:34 <lambdabot> Maximum users seen in #haskell: 242, currently: 237 (97.9%), active: 47 (19.8%)
12:27:16 <_frederik_> is anyone going to the haskell workshop?
12:27:31 <CosmicRay> _frederik_: yes.
12:27:35 <CosmicRay> I, however, am not.
12:27:47 <_frederik_> oh haha
12:27:56 <_frederik_> har i mean
12:28:37 <_frederik_> it's on the 17th, the day after my birthday. somehow i've ended up scheduled to give a talk
12:30:53 <shapr> Well, the 18th is my birthday
12:30:57 <shapr> And I'll hopefully listen to your talk
12:31:02 <_frederik_> cool
12:31:08 <shapr> @users
12:31:09 <lambdabot> Maximum users seen in #haskell: 242, currently: 238 (98.3%), active: 47 (19.7%)
12:31:19 <edwardk> well, happy birthday in advance if I don't catch you before then, shapr =)
12:31:22 <_frederik_> do you know how many audience members i can expect?
12:31:26 <shapr> edwardk: yay!
12:31:37 <edwardk> frederik: giving a talk?
12:31:40 * edwardk arches an eyebrow.
12:31:50 * shapr suspends an eyebrow
12:32:37 <_frederik_> i'll mostly be asking more annoying questions - sort of a continuation of my mailing list persona
12:32:39 <shapr> _frederik_: HW2003 had about 40 people in the audience.
12:34:28 <_frederik_> (by the way, it's a tool demo, if you're looking on the list of papers it won't be there)
12:37:19 <bringert> shapr: are you coming to portland?
12:40:07 <shapr> bringert: I think so.
12:40:17 <_frederik_> where are you now, anyway?
12:40:18 <bringert> great
12:40:49 * _frederik_ goes for walk
12:40:50 <edwardk> woot =)
12:40:56 <shapr> _frederik_: Birmingham, Alabama
12:41:06 <shapr> edwardk: Will you be at Haskell Workshop?
12:41:08 <edwardk> i'll be up saturday before noon
12:41:10 <edwardk> yeah
12:41:34 <phragmented> osx-ppc folks: anyone have their full build log that ends up with the regex-compat error?
12:42:25 <shapr> edwardk: What's your number? I'll call you when I get to my hotel. I think I'll be there on Saturday as well.
12:42:37 <edwardk> lemme look it up. i never call myself =)
12:43:06 <shapr> I have a new phone number 205-515-1921
12:43:30 <edwardk> k, well, if nothing else. i now have that logged on my laptop that will be with me ;)
12:43:39 <shapr> spiffy
12:43:55 <edwardk> heh can't find my phone, brb
12:44:05 <xerox> shapr-facts: shapr says "spiffy!" even in real life.
12:44:18 <shapr> Yes it's true!
12:44:35 <xerox> @quote oleg-facts
12:44:36 <lambdabot> oleg-facts hasn't said anything memorable
12:44:38 <xerox> @quote oleg-fact
12:44:39 <lambdabot> oleg-fact hasn't said anything memorable
12:44:42 <xerox> @quote olegfact
12:44:42 <lambdabot> olegfact hasn't said anything memorable
12:44:46 <xerox> Grrr.
12:45:07 <edwardk> hell, I say spiffy in real life. spiffy-keen sometimes even ;)
12:47:01 <edwardk> found it, was buried under papers...
12:48:19 <edwardk> If nothing else, this trip will either give me a break from working on my thesis or a wider audience to ramble on about it to in person ;)
12:50:41 <emu> ?doc IO
12:50:41 <lambdabot> IO not available
12:50:47 <emu> @hoogle hOpen
12:50:48 <lambdabot> No matches found
12:51:19 <emu> > ?type openFile
12:51:20 <lambdabot>  Illegal character ''\DEL''
12:51:21 <araujo> hello!
12:51:23 <araujo> yay!
12:51:25 <araujo> @yarr!
12:51:26 <lambdabot> Ahoy mateys
12:51:28 <emu> ?type openFile
12:51:29 <lambdabot> Not in scope: `openFile'
12:51:44 <araujo> @hoogle openFile
12:51:45 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
13:02:35 <newsham> ?localtime dons
13:02:37 <lambdabot> Local time for dons is Fri Sep 15 06:02:14 2006
13:02:50 <shapr> @localtime shapr
13:02:52 <lambdabot> Local time for shapr is Thu Sep 14 15:02:57 2006
13:03:24 <ValarQ> @localtime lambdabot
13:03:26 <newsham> Thu Sep 14 09:59:22 HST 2006
13:04:06 <wilx> @localtime wilx
13:04:08 <lambdabot> Local time for wilx is Thu Sep 14 22:03:46 2006
13:04:11 <newsham> *kicks ntp*
13:16:57 <SyntaxNinja> so who all is in portland now?
13:17:08 <kosmikus> me
13:17:13 * tennin is here listening to spj
13:17:26 <edwardk> gah, 2 days away =/
13:17:56 <_frederik_> is this the ghc hackathon now?
13:18:11 <edwardk> tennin: put in a word for a -fmonad-comprehensions for us ;)
13:18:25 <tennin> yes
13:18:49 <_frederik_> i've never been to a hackathon
13:19:03 <kosmikus> tennin: who are you?
13:19:19 <edwardk> i wanted to go, but had to teach through the end of the week in order to justify not being there for monday-wednesday
13:20:07 <SyntaxNinja> tennin: stand up and spin around twice.
13:20:28 <SyntaxNinja> also yell "boop! boop!" so we know when you are doing it.
13:20:36 <edwardk> hehehe
13:21:10 <ral1> shapr: Is your  name "Erisson" or am I right in asuming that you left out a c?
13:21:18 <shapr> ral1: My name is Erisson
13:21:27 <shapr> As in "Son of Eris"
13:21:35 <dylan> Hail Eris!
13:21:37 <ral1> shapr: glad I asked.
13:21:41 <shapr> All Hail Discordia!
13:21:43 <ral1> When will you be in Pdx?
13:21:45 <newsham> can we get an eris free network here?
13:21:49 <shapr> newsham: :-P
13:21:49 <SyntaxNinja> hi shapr
13:21:53 <shapr> hi SyntaxNinja!
13:21:57 <shapr> ral1: Saturday, I think.
13:22:00 <dylan> someone should say 'ddate' now
13:22:16 <darius__> hey shae, did you hear about planet Xena get renamed?
13:22:24 <shapr> No?
13:22:31 <darius__> go look up the news
13:22:36 <darius__> pleasant surprise for you
13:22:54 <newsham> erlang = eris lang?
13:23:01 <SyntaxNinja> btw, if anyone msgs me, remember, kosmikus is reading over my shoulder
13:23:07 <SyntaxNinja> so... ya know, don't knock kosmikus
13:23:10 <_frederik_> does anyone know what XYPixmap and ZPixmap refer to (in XLib)?
13:23:12 <darius__> no, there was a guy named erlang it's named after
13:23:28 <kosmikus> haha
13:23:36 <SyntaxNinja> see!  he can see what I'm typing!
13:24:05 <darius__> syntax - hey, is skew there?
13:24:09 <kosmikus> luckily, the font size on my screen is small enough for msgs to me being safe :)
13:24:16 <edwardk> heh
13:24:28 <SyntaxNinja> darius__: er, I forget who skew is
13:24:32 <darius__> brandon moore
13:24:34 <shapr> Brandon Moore
13:24:38 <newsham> isnt "oolong" pronounced  er-long (like erlang?)
13:24:47 <ral1> shapr: I'm sending you a postcard.
13:24:51 <SyntaxNinja> not sure.
13:24:54 <shapr> ral1: spiffy
13:25:10 <newsham> erlang tea
13:25:38 <darius__> syntax - ah, ok, if you run into him you might mention i said the semantics tests are broken
13:26:29 <bortzmeye1> Is there a way to have functions with default values for some parameters (like in Ada or Python)?
13:26:39 <darius__> that's an oversimplification but then this is a limited comm channel
13:26:43 <bortzmeye1> I believe that not, it is incompatible with curryfcation and partial application
13:27:00 <newsham> doesnt the wxhaskell package use some sort of attribute system to allow default values?
13:27:12 <SyntaxNinja> darius__: I'd say the chance of me remembering that is pretty slim ;) but maybe someone else will remember
13:27:20 <darius__> fair enough :-)
13:28:46 <bortzmeye1> newsham; I never used wxhaskell. Any pointer?
13:28:49 <darius__> shapr: http://news.bbc.co.uk/2/hi/science/nature/5344892.stm
13:28:51 <lambdabot> Title: BBC NEWS | Science/Nature | Astronomers name 'world of chaos', http://tinyurl.com/zwazp
13:29:37 <newsham> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/wxHaskell.html  see example there?  they made up some syntax for passing in a bunch of attributes
13:29:41 <lambdabot> Title: Advanced Functional Programming - wxHaskell, http://tinyurl.com/fhbaz
13:30:06 <newsham> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/wxHaskell/doc/Graphics.UI.WX.Attributes.html
13:30:08 <lambdabot> http://tinyurl.com/kk3sw
13:31:55 <bortzmeye1> newsham: thanks. OK, it seems it is an ad hoc system (I was thinking of a Data.Map.Map (Maybe String) to do the same) not a feature of Hskell
13:32:26 <newsham> yup.  not built into the language.
13:32:36 <mauke> hmm, what's going on here? I upgraded ghc and now I get ghc3518.hc:(.text+0x5eb): undefined reference to `__stginit_ControlziMonadziReader_'
13:33:27 <newsham> mauke: i once got a weird error like that and someone said to make clean and rebuild and that fixed my error.  not sure if it applies to you, but worrth a shot
13:34:01 <mauke> make what clean?
13:34:19 <mauke> hmm, it works with --make
13:34:21 <newsham> remove all the .o's and .hi's and make again
13:34:30 <newsham> ahh, cool
13:35:27 <SyntaxNinja> ral1: is that you, ralf
13:36:40 <mauke> what's the "challenge" in mathschallenge? the problems I've seen so far can be solved by translating the problem description into a program and running it
13:36:59 <Igloo> That's what you're meant to do
13:37:14 <Igloo> Some problems are harder than others
13:37:16 <mauke> but it's just stupid brute force
13:37:34 <Igloo> Only if you choose to solve them the brute-force way
13:37:57 <Igloo> There are some pairs of problems where one is brute-forcable and the other isn't
13:38:06 <mauke> why bother thinking about it if the brute force version takes <2s?
13:40:59 <inferno_> why isn't this working: http://paste.lisp.org/display/26047 ,i get  Variable not in scope: `r'
13:41:47 <twanvl> the where is outside the do block
13:42:05 <mauke> because f can't see r
13:42:17 <twanvl> You could make r a parameter of f: f r (x,y) = (x, pick r y)
13:42:40 <mauke> and you want return (rulesApply (map f b))
13:42:45 <mauke> or map (f r) b
13:43:35 <xerox> second (pick r)
13:43:54 <twanvl> you probably also want parentheses around the call to rulesApply, otherwise you are passing two arguments to return
13:44:27 <mauke> @index second
13:44:28 <lambdabot> Control.Arrow
13:44:30 <inferno_> thanks, works now
13:44:48 <mauke> yeah, hit the newbie with arrows :-)
13:44:55 * xerox giggles
13:45:47 <ventonegro> @hoogle pointSize
13:45:48 <lambdabot> No matches found
13:46:11 <ventonegro> @index pointSize
13:46:12 <lambdabot> Graphics.Rendering.OpenGL.GL.Points, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:49:56 <ventonegro> how do I create a Float from a Double? :-)
13:50:07 <Cale> realToFrac
13:50:17 <Cale> @type realToFrac
13:50:19 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
13:50:20 <newsham> ?hoogle Float -> Double
13:50:21 <lambdabot> No matches, try a more general search
13:50:46 <Cale> > realToFrac (pi :: Double) :: Float
13:50:47 <lambdabot>  3.1415927
13:50:58 <yip> > pi :: Double
13:51:00 <lambdabot>  3.141592653589793
13:51:09 <yip> > pi :: Float
13:51:10 <lambdabot>  3.1415927
13:51:23 <newsham> > pi :: Int
13:51:24 <lambdabot>  add an instance declaration for (Floating Int)
13:51:24 <lambdabot>   In the expression: pi ::...
13:51:38 <Cale> > exp 1 :: Double
13:51:40 <lambdabot>  2.718281828459045
13:51:41 <ventonegro> Cale, worked, thanks
13:51:44 <Cale> > exp 1 :: Fload
13:51:45 <lambdabot>  Not in scope: type constructor or class `Fload'
13:51:45 <Cale> > exp 1 :: Float
13:51:47 <lambdabot>  2.7182817
13:51:59 <yip> > (toIntegral pi) :: Int
13:52:00 <lambdabot>  Not in scope: `toIntegral'
13:52:04 <yip> > (fromIntegral pi) :: Int
13:52:05 <lambdabot>  Add a type signature
13:52:07 <Cale> > floor pi :: Int
13:52:09 <lambdabot>  3
13:52:16 <Cale> mmm... floor pi
13:52:40 <Cale> (is that a sufficiently obscure reference?)
13:53:41 <ventonegro> yep
13:54:39 <Cale> http://www.snpp.com/episodes/1F06.html
13:54:41 <lambdabot> Title: [1F06] Boy Scoutz 'N the Hood
13:54:58 <Cale> I suppose it's actually "Ooh! Floor pie!"
13:56:00 * tennin scrolls up
13:56:01 <tennin> sorry
13:56:55 <tennin> I'm the long-haired guy at the front table to the left who asked the somewhat confused question about constructor specialization
13:57:10 <Cale> tennin: what?
13:57:34 <tennin> in response to questions asked some time ago
13:57:57 <kosmikus> ok
13:58:02 <Cale> mauke: I agree, mathschallenge is silly.
13:58:31 <tennin> (13:18:40) kosmikus: tennin: who are you?
13:58:31 <tennin> (13:19:44) SyntaxNinja: tennin: stand up and spin around twice.
13:58:45 <Cale> mauke: hehe: http://cale.yi.org/index.php/Generalisation_of_Nurikabe
13:58:48 <lambdabot> http://tinyurl.com/k4f5r
13:59:23 * SyntaxNinja nods sagely
14:01:48 <Igloo> mauke: For some it takes longer, particularly in Haskell
14:04:07 <mauke> Cale: hah
14:11:11 <darius__> syntaxninja - never mind about bugging skew if you see him - i've fixed it all
14:12:01 <SyntaxNinja> yay
14:12:35 <darius__> hm, well, actually his test is failing once i actually run it, but i guess we can live with that :)
14:16:02 <_frederik_> does anyone have a version of Graphics.X11.Xlib with a 'createImage' (it's missing from the one in ghc)
14:22:05 <_frederik_> also, what do i use to display pdf slides in full-screen mode?
14:24:25 * shapr boings
14:24:35 <shapr> kosmikus: Hey, will Haskell Workshop have a live webfeed? =)
14:24:52 <kosmikus> no
14:25:10 <shapr> I was just being silly really :-)
14:25:23 <kosmikus> well, I'm not opposed to the idea, but I'll not organise it
14:30:45 <mux> ?seen dons
14:30:46 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 4h 33m 29s ago.
14:32:08 <emu> mauke: i'm looking at such a problem now: the initial one is brute forceable (prob18, triangle of numbers) but the paired one is not (much larger)
14:32:31 <mauke> emu: meh, still trivial
14:32:57 <emu> i did get locked out for solving 3 problems in a row though
14:33:00 <emu> some of them are dumb
14:33:12 <emu> especially since you probably wrote a function to solve them while doing a previous one
14:33:56 <mauke> http://www.spoj.pl/problems/SUMITR/ :-)
14:34:00 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem SUMITR
14:35:28 <emu> yea well any problem with "Large Input Output Data" in it basically means Haskell is fucked
14:35:47 <emu> until they get around to installing fps or when ghc 6.6 is out and they upgrade
14:57:11 <_frederik_> the sixth argument in XCreateImage is "char* data", what should this be in Haskell? Ptr Word8?
14:57:49 <xs> Ptr CChar?
14:59:00 <_frederik_> is that a question or an answer?
14:59:10 <_frederik_> it's a buffer for use in the image
14:59:30 <_frederik_> the caller writes to it later
14:59:31 <xs> Ptr Word8 would work, but perhaps Ptr CChar is more correct.
14:59:37 <_frederik_> ok
14:59:39 <twanvl> Maybe a ByteString?
14:59:46 <xs> since sizeof(char) is not necessarily sizeof(uint8_t)
14:59:52 <xs> (well.)
15:00:06 <mikael> xs: are you sure?
15:00:19 <mikael> sorry, nevermind
15:00:25 <twanvl> sizeof(char)==1, sizeof(uint8_t) = undefined, but on all architectures 1
15:00:52 <xs> iirc, before c99 or maybe c89, char wasn't necessarily 8 bit.
15:01:05 <mikael> not necessarily 8 bit, but 1 byte :-)
15:01:16 <_frederik_> the thing is, it's pixel data so it doesn't matter. it's just a block of storage
15:01:25 <mauke> dude, sizeof (char) == sizeof (uint8_t) because uint8_t == unsigned char
15:01:39 <mauke> if CHAR_BIT != 8, then uint8_t doesn't even exist
15:01:43 <pejo> xs, is char defined as 8 bit storage today?
15:01:55 <mauke> no
15:02:07 <mikael> what if CHAR_BIT == 4, and uint8_t == short, huh?
15:02:17 <mauke> impossible, CHAR_BIT must be at least 8
15:02:26 <mikael> oh!
15:02:45 <mauke> (because the minimum range for unsigned char is [0, 255])
15:02:46 <pejo> mauke, must uint8_t be exactly 8 bits, by the standard?
15:02:57 <mauke> if it exists, yes
15:03:16 <mauke> there's another type (uint_least8_t), which is required to exist
15:03:41 <pejo> mauke, ah, so no problem for 9 bit byte platforms then?
15:03:54 <mauke> right
15:05:18 <mauke> hah, I'm awesome. I just solved mathschallenge 24 without writing a single line of code
15:06:15 <dolio> Heh, yeah, that one's not too hard to do by hand once you figure out the trick.
15:06:53 <mauke> I didn't do it by hand either :-)
15:07:09 <dolio> :) Just a blind guess?
15:07:22 <mauke> I used a pre-existing C program from my src directory
15:07:31 <dolio> Ah, I see.
15:07:31 <mauke> written in feb 2006, it seems
15:07:56 <AstralStorm> :P
15:08:02 <dolio> I suppose most people have lexicographic permutation programs sitting around.
15:09:39 <mauke> I think I wrote it because someone with this exact problem came to EFnet/#c and asked for help :-)
15:10:03 <dolio> Ah, heh. I wonder if they were doing mathschallenge.
15:11:37 <dolio> I suppose that's the likey scenario.
15:12:31 <mux> yhjulwwiefzojcbxybbruweejw
15:12:35 <mux> @yhjulwwiefzojcbxybbruweejw
15:12:36 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:16:43 <dibblego> is there a type class for the - function?
15:17:05 <mikael> Num
15:17:20 <dibblego> ah thanks
15:17:27 <dibblego> how do you actually figure it out from the docs?
15:17:38 <dibblego> "given a function f, determine the type class"
15:18:08 <dmwit> @type (-)
15:18:10 <lambdabot> forall a. (Num a) => a -> a -> a
15:18:13 <mikael> try :t (-) in ghc or hugs
15:18:27 <dibblego> oh that easy, of course
15:20:33 <dmwit> @yow
15:20:34 <lambdabot> Now I'm concentrating on a specific tank battle toward the end of World
15:20:34 <lambdabot> War II!
15:20:39 <kpreid> not necessarily
15:20:42 <kpreid> @type fromIntegral
15:20:44 <lambdabot> forall b a. (Num b, Integral a) => a -> b
15:20:54 <lokadin> how do i change Int -> String
15:20:57 <kpreid> that's in Num, but nothing says it is
15:21:07 <dmwit> show
15:21:13 <lokadin> thanks ):
15:21:13 <dmwit> @type show
15:21:15 <lambdabot> forall a. (Show a) => a -> String
15:21:25 <lokadin> laag
15:21:33 <lokadin> ki'e (thanks)
15:21:34 <dmwit> =)
15:21:34 <mauke> @hoogle Int -> String
15:21:35 <lambdabot> Test.QuickCheck.configEvery :: Config -> Int -> [String] -> String
15:22:43 <dibblego> f :: Num a => [a] -> [a] -> [Bool] -> [a]
15:22:43 <dibblego> f = [3] -- what is wrong with this exactly?
15:22:59 <mauke> [3] is not a function
15:23:18 <dibblego> oh of course
15:23:18 <mauke> did you mean f _ _ _ = [3]?
15:23:22 <dibblego> yeah I did
15:23:45 <mikael> 3 isn't necessarily an instance of every possible Num type
15:24:00 <mauke> since when?
15:24:20 <dibblego> I'm just getting it to compile before I think about how I'm going to solve it
15:24:30 <dibblego> since [3] is not the right value
15:25:12 <dibblego> do most people use emacs for writing their code?
15:25:33 <mikael> mauke: oh, doh
15:25:34 <astrolabe> Alot do (including me)
15:26:27 <mauke> I use vim
15:27:20 <mauke> @type unfoldr
15:27:21 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
15:29:53 <lokadin> do you divide with / ?
15:30:11 <dibblego> lokadin, yes
15:30:12 <mauke> depends on the types of the numbers
15:30:23 <mauke> alternatives are div and %
15:31:25 <mauke> > (4 / 6, 4 `div` 6, 4 % 6)
15:31:27 <lambdabot>  (0.6666666666666666,0,2%3)
15:31:44 <lokadin> well i have 1 and an Int
15:32:01 <dibblego> http://rafb.net/paste/results/rubboX70.html to solve this problem, would zip3 be used?
15:32:14 <lokadin> hmm
15:32:16 <lokadin> brb
15:32:39 <Daveman> xerox :)
15:33:17 <xerox> ?type zipWith3
15:33:19 <lambdabot> forall d c b a. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
15:33:37 <lokadin> mauke: dibblego : ki'e (thanks)
15:33:45 <dibblego> is that what you'd use? I'm not sure how to initiate the solution
15:34:01 <mauke> > [ b - a | a <- [1,2,3,4] | b <- [7,11,13,19] | c <- [True,False,True,True], c ]
15:34:02 <lambdabot>  Parse error
15:34:05 <mauke> :(
15:34:14 <xerox> > zipWith3 (\a b c -> if c then b - a else 0) [1..4] [7,11,13,19] [True,False,True,False]
15:34:16 <lambdabot>  [6,0,10,0]
15:34:36 <xerox> > catMaybes $ zipWith3 (\a b c -> if c then Just (b - a) else Nothing) [1..4] [7,11,13,19] [True,False,True,False]
15:34:37 <lambdabot>  [6,10]
15:34:55 <mauke> @hoogle (a,b) -> (b,a)
15:34:56 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:35:03 <mauke> AIIRRR
15:35:10 <xerox> > (snd *** fst) (1,2)
15:35:11 <lambdabot>  add an instance declaration for (Num (a, b))
15:35:15 <xerox> Arrr.
15:35:19 <xerox> > (snd &&& fst) (1,2)
15:35:20 <lambdabot>  (2,1)
15:35:38 <dibblego> how did you reason out that solution?
15:36:01 <dibblego> ?index catMaybes
15:36:02 <lambdabot> Data.Maybe
15:36:03 <mauke> @type (uncurry . flip . curry) id
15:36:05 <lambdabot> forall a b. (b, a) -> (a, b)
15:36:28 <Daveman> xerox, I've been practicing :)
15:36:37 <xerox> dibblego: I translated your words literally.
15:36:52 <dibblego> xerox, you mean the comment "for each..."?
15:36:57 <xerox> Yep.
15:37:14 <dibblego> and how do you refine that? practice?
15:37:21 <xerox> dibblego: yup.
15:37:28 <dibblego> it is not immediately obvious to me, if at all
15:37:40 <xerox> Just try.
15:37:42 <dibblego> I will have to go through that solution to figure out why it even works
15:37:44 <xerox> zipWith3 does exactly that.
15:37:45 <dibblego> righto
15:37:54 <newsham> ?hoogle (b, a) -> (a, b)
15:37:55 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:38:11 <xerox> It uses its first functional argument to "zip" the corresponding values of the three lists.
15:38:51 <dibblego> :t (\a b c -> if c then Just (b - a) else Nothing)
15:39:17 <xerox> Use ?type
15:39:27 <xerox> ...or GHCi :)
15:39:32 <Daveman> :D
15:39:35 <Daveman> yay
15:39:36 <mauke> dibblego: (Num a) => a -> a -> Bool -> Maybe a
15:39:43 <xerox> But you'll probably need to :m + Data.Maybe for catMaybes.
15:39:46 <xerox> Daveman: ah cool!
15:39:55 <Daveman> :)
15:40:13 <Daveman> xerox, I'm still confused by some things, but I'm sure I could ask you for help here and there :D
15:40:26 <xerox> Sure, please do.
15:40:32 <Daveman> thanks :)
15:40:36 <mauke> dibblego: the steps are something like this: you want to iterate over three lists in parallel, which means zip3
15:41:07 <mauke> dibblego: then you want to do something to each triple, which means map. map + zip3 == zipWith3
15:41:39 <mauke> dibblego: each step can either return a number (b - a) or nothing, which means the Maybe type
15:42:03 <mauke> then we need to filter out the Nothings, which is what catMaybes does
15:42:35 <dibblego> brb
15:42:49 <xerox> You could even do: \xs ys zs -> [b - a | a <- xs, b <- ys, c <- zs, c]
15:42:57 <xerox> You could even do: \xs ys zs -> [b - a | a <- xs | b <- ys | c <- zs, c]
15:42:59 <xerox> Sorry.
15:43:27 <xerox> (You'll need parallel list comprehensions for that.  -fglasgow-exts.)
15:43:28 <mauke> I tried that but lambdabot gave me a parse error
15:43:35 <dibblego> you mean I could replace (\a b c -> if c then Just (b - a) else Nothing) with \xs ys zs -> [b - a | a <- xs | b <- ys | c <- zs, c] ?
15:43:42 <xerox> Yeah she doesn't parallel comprehend.
15:43:52 <xerox> Nope, the whole code.
15:43:55 <mauke> dibblego: no, the whole catMaybes zipWith3 thing
15:44:32 <dibblego> oh
15:44:38 <xerox> Prelude> let dibblego = \xs ys zs -> [b - a | a <- xs | b <- ys | c <- zs, c]
15:44:39 <xerox> Prelude> dibblego [1..4] [7,11,13,19] [True,False,True,False]
15:44:39 <xerox> [6,9]
15:45:11 <dibblego> well that looks easier to figure out - I will do both in a minute
15:45:42 <dibblego> thanks
15:45:50 <xerox> Parallel list comprehensions de-sugar to zipWith#.
15:46:08 <xerox> You're welcome.
15:47:51 <mauke> are there parallel monad comprehensions?
15:48:24 <xerox> BRB
15:53:38 <dibblego> I need -fglasgow-exts for those list comprehensions? what makes it need that particular flag?
15:54:08 <dolio> That flag enables a bunch of ghc specific language extensions.
15:54:36 <dolio> Or, if not ghc specific, at least extensions that aren't in the H98 standard.
15:54:40 <dibblego> so "parallel list comprehensions"
15:55:03 <dibblego> is there a general recommendation for or against using it?
15:56:24 <dolio> I suppose it'd be best to avoid them if you're planning on writing code that needs to be compiled by multiple different compilers.
15:56:54 <irgs> there are not that many haskell compilers out there, are they?
15:57:43 <irgs> there..
15:57:46 <dolio> Not that many, I suppose, no.
15:58:01 <dibblego> those two functions return different values
15:58:17 <xerox> ?yow
15:58:17 <lambdabot> Did an Italian CRANE OPERATOR just experience uninhibited sensations in
15:58:17 <lambdabot> a MALIBU HOT TUB?
15:59:04 <dibblego> http://rafb.net/paste/results/AW2ghb67.html
16:00:24 <xerox> Oh I see.
16:00:48 <dolio>  | c <- zs, c just filters the zs, right?
16:01:03 <xerox> \xs ys zs -> [if c then Just (b - a) else Nothing | a <- xs | b <- ys | c <- zs]
16:02:30 <dibblego> I don't want to keep milking you, but that doesn't compile
16:02:51 <xerox> What's the error?
16:03:12 <dibblego> http://rafb.net/paste/results/PWl09M40.html
16:03:31 <xerox> Oh sure, it returns [Maybe a]
16:03:38 <xerox> catMaybes it for [a].
16:03:47 <dibblego> ok
16:04:22 <xerox> G'day P.!
16:04:24 <dibblego> catMaybes $ (\xs ys zs -> [if c then Just (b - a) else Nothing | a <- xs | b <- ys | c <- zs])
16:04:28 <Pseudonym> G'day X!
16:04:35 <Pseudonym> Actually, I guess it's lower-case x.
16:05:45 <dibblego> hello Pseudonym
16:05:49 <Pseudonym> G'day.
16:06:48 <xerox> ?quote
16:06:48 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
16:07:06 <xerox> Ah-ha. Ad-hoc.
16:08:49 <mauke> ?quote
16:08:50 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
16:12:25 <vincenz> \o/
16:12:30 <vincenz> This -so- rocks
16:12:39 <vincenz> Google personalized homepage has tabs
16:16:10 <dmwit> @yow
16:16:11 <lambdabot> Mmmmmm-MMMMMM!!  A plate of STEAMING PIECES of a PIG mixed with the
16:16:11 <lambdabot> shreds of SEVERAL CHICKENS!! ... Oh BOY!!  I'm about to swallow a
16:16:11 <lambdabot> TORN-OFF section of a COW'S LEFT LEG soaked in COTTONSEED OIL and
16:16:11 <lambdabot> SUGAR!! ... Let's see ... Next, I'll have the GROUND-UP flesh of CUTE,
16:16:11 <lambdabot> BABY LAMBS fried in the MELTED, FATTY TISSUES from a warm-blooded
16:16:13 <lambdabot> [3 @more lines]
16:16:17 <dmwit> @more
16:16:18 <lambdabot> animal someone once PETTED!! ... YUM!!  That was GOOD!!  For DESSERT,
16:16:18 <lambdabot> I'll have a TOFU BURGER with BEAN SPROUTS on a stone-ground, WHOLE
16:16:19 <lambdabot> WHEAT BUN!!
16:16:31 <xerox> @slap lambdabot
16:16:31 * lambdabot beats up lambdabot
16:17:02 <dibblego> how to you pass -fglasgow-exts at ghci prompt?
16:17:16 <xerox> ghci -fglasgow-exts  or  :set -fglasgow-exts
16:17:37 <dmwit> @yarr
16:17:38 <lambdabot> Keelhaul the swabs!
16:17:39 <xerox> Thanks to Lemmih GHC 6.5 has auto-completition on :set -fglTAB.
16:17:43 <dibblego> ta
16:17:46 <Pseudonym> Coffee.  BBS
16:17:57 <dmwit> @yow
16:17:58 <lambdabot> I'm wet!  I'm wild!
16:18:09 <dmwit> @vixen I'm wet! I'm wild!
16:18:10 <lambdabot> You complete me
16:20:58 <heatsink> heh
16:21:06 <heatsink> @moo
16:21:06 <lambdabot> Maybe you meant: map more msg todo yow
16:21:11 <heatsink> aww.
16:22:08 <xerox> Map more messages to do yow!
16:22:31 <dmwit> @. yow moo
16:22:32 <lambdabot> compose module failed: IRCRaised Parse error: "moo"
16:23:36 <dmwit> ?yow
16:23:37 <lambdabot> Should I start with the time I SWITCHED personalities with a BEATNIK
16:23:37 <lambdabot> hair stylist or my failure to refer five TEENAGERS to a good OCULIST?
16:24:40 <heatsink> @yow
16:24:40 <lambdabot> I'd like some JUNK FOOD ... and then I want to be ALONE --
16:25:00 <dmwit> Yikes, I'd rather hear about the beatnik...
16:30:24 <dibblego> I decided I would work on these problems today http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-15/index.html here is my solution to 1: let begin a b = if length a > length b then False else take (length a) b == a
16:30:26 <lambdabot> Title: CSc 372 - Comparative Programming Languages 15 : Haskell -- Exercises, http://tinyurl.com/z8as7
16:32:02 <lokadin> if i do "div 1 (factorial 3)" i get 0, factorial function works, and '(/)' and '(%)' don't seem to compile
16:32:03 <heatsink> dibblego, that works, but It's probably not the expected answer.
16:32:59 <heatsink> lokadin, (/) is not the same as div
16:33:03 <heatsink> @type (/)
16:33:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:33:05 <heatsink> @type div
16:33:06 <lambdabot> forall a. (Integral a) => a -> a -> a
16:33:14 <lokadin> well i'm trying to divide
16:33:20 <lokadin> but i can't figure out how
16:33:50 <LiquidEngineer> Hello
16:34:06 <heatsink> lokadin, are you trying to do integer divide or floating-point division?  What should 2 divided by 3 be in your case?
16:34:22 <LiquidEngineer> How does one do combined conditionals in an if statement?
16:34:29 <lokadin> float
16:34:55 <LiquidEngineer> Specifically for a relationship like this: if 0  <= rr <= n * q
16:35:15 <heatsink> LiquidEngineer, if 0 <= rr && rr <= n * q then ... else ...
16:35:43 <mauke> lokadin: then you need to convert factorial 3 to a float
16:35:50 <heatsink> lokadin, there's a function to do integer-to-float conversion... fromIntegral, I think
16:36:08 <heatsink> > fromIntegral (2 :: Int) / fromIntegral (3 :: Int)
16:36:09 <lambdabot>  0.6666666666666666
16:36:16 <LiquidEngineer> that's it?  Overthinking, I was
16:36:56 <mauke> if liftM2 (&&) (0 <=) (<= n * q) rr then ... else ... :-)
16:37:06 <lokadin> kk i'll go try that
16:37:12 <heatsink> heh
16:37:41 <mauke> if all [(0 <=), (<= n * q)] rr
16:37:48 <xerox> > if all (sequence conditions)
16:37:48 <lambdabot>  Parse error
16:37:50 <xerox> Ops
16:38:04 <xerox> > all (sequence [even,(>10)] 100)
16:38:05 <lambdabot>    Expecting a function type, but found `t_a1OM'
16:38:05 <lambdabot>    Expected type: a -> ...
16:38:07 <xerox> > and (sequence [even,(>10)] 100)
16:38:09 <lambdabot>  True
16:38:17 <xerox> I always get those wrong.
16:38:50 <mauke> sequence == flip map (flip id)?
16:39:42 <xerox> @check \xs x -> sequence (xs :: [Int -> Bool]) (x :: Int) == flip map (flip id) xs x
16:39:43 <lambdabot>  Couldn't match `t -> [Bool]' against `[b]'
16:39:47 <xerox> :(
16:41:42 <xerox> ?type flip map (flip id)
16:41:43 <lambdabot>   Expecting a function type, but found `b'
16:41:43 <lambdabot>    Expected type: [a]
16:41:52 <xerox> Doesn't seem the case.
16:41:58 <mauke> oh, I'm doing it wrong
16:42:12 <mauke> ?type flip (map (flip id))
16:42:14 <lambdabot>   Expecting a function type, but found `[b]'
16:42:14 <lambdabot>    Expected type: [a] -> b -> c
16:42:15 <LiquidEngineer> What does this mean as an error?
16:42:17 <LiquidEngineer> Couldn't match `Integer' against `t -> t1 -> t2'
16:42:17 <LiquidEngineer>       Expected type: Integer
16:42:17 <LiquidEngineer>       Inferred type: t -> t1 -> t2
16:42:17 <LiquidEngineer>     Probable cause: `rr' is applied to too many arguments in the call
16:42:17 <LiquidEngineer> 	(rr div (r div 5))
16:42:33 <mauke> LiquidEngineer: should be `div`, not div
16:42:40 <LiquidEngineer> Oh.
16:42:45 <newsham> ?seen dons
16:42:45 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 6h 45m 28s ago.
16:42:50 <LiquidEngineer> Wow, I'm out of practice.
16:43:20 <dibblego> can type classes be a subtype of other type classes?
16:45:31 <Pupeno_> from what I see of how import does, sayning import Cards as C doesn't make sense, right ?
16:45:45 <mauke> dibblego: yes
16:46:09 <dibblego> mauke, am I right in saying the type class Fractional inherits the type class Num?
16:46:42 <mauke> I don't know if "inherits" is the right word, but yes
16:46:48 <mauke> ?type flip (map . flip id)
16:46:50 <lambdabot> forall c a. [a -> c] -> a -> [c]
16:47:44 <lokadin> :( it's giving me the same errors, maybe it's because my factorial :: Int -> Int ?
16:47:44 <LiquidEngineer> Hmm...
16:47:56 <LiquidEngineer> I'm still getting some wierd syntax
16:47:57 <LiquidEngineer> errors
16:48:01 <LiquidEngineer> I'll have to mess with it later
16:48:13 <lokadin> 0 fromIntegral (1 :: Int)  /  fromIntegral (factorial pa :: Int)
16:48:17 <lokadin> does not compile
16:48:30 <mauke> what is 0 fromIntegral (1 :: Int) supposed to mean?
16:48:30 <xerox> mauke: I think this is like this
16:48:41 <xerox> ?type let swing f c a = (f ($ a)) c in swing map
16:48:42 <lambdabot> forall a b. [a -> b] -> a -> [b]
16:48:44 <dibblego> if Int inherits from Num and Fractional inherits from Num and (/) is a function of Fractional, then (6::Int) / (4::Int) should fail - which it does, but why does 6/4 not fail?
16:48:52 <lokadin> fromIntegral (1 :: Int)  /  fromIntegral (factorial pa :: Int)
16:49:05 <mauke> dibblego: because the type of 6 is (Num a) => a, not Int
16:49:16 <dibblego> mauke, yes but Num does not define (/)
16:49:31 <dibblego> or does it
16:49:41 <mauke> it doesn't, but Num is not a type
16:49:53 <mauke> lokadin: 1 / fromIntegral (factorial pa)?
16:50:07 <lokadin> nope
16:50:29 <lokadin> No instance for (Fractional Int)
16:50:29 <lokadin>       arising from use of `/' at PA.lhs:16:18
16:50:29 <lokadin>     Probable fix: add an instance declaration for (Fractional Int)
16:50:43 <dmwit> > fromInteger 1 :: Double
16:50:44 <lambdabot>  1.0
16:50:54 <mauke> lokadin: what's line 16?
16:50:55 <dmwit> dibblego: Maybe there is an implicit fromInteger?
16:51:17 <dibblego> dmwit, dunno, I'm pretty confused - I'll have to untangle it
16:51:43 <mauke> > let factorial n = if (n :: Int) < 2 then 1 else n * factorial (n - 1) in 1 / fromIntegral (factorial 5)
16:51:44 <lambdabot>  8.333333333333333e-3
16:51:45 <dmwit> > 6 / 4
16:51:46 <lambdabot>  1.5
16:51:52 <dmwit> > fromInteger 6 / 4
16:51:53 <lambdabot>  1.5
16:51:59 <heatsink> lokadin, check how the overall expression is used.  Can it be a floating-point number?
16:51:59 <lokadin> mauke: the line i was showing
16:52:12 <dmwit> > 6 % 4
16:52:13 <lambdabot>  3%2
16:52:20 <mauke> lokadin: works for me
16:52:32 <lokadin> it is a floating point number, 1 divided by anything greater than one traditionally has decimls
16:52:41 <lokadin> mauke: how did you do it?
16:52:46 <lokadin> hmm
16:52:47 <lokadin> o
16:52:58 <dibblego> 1 divided by infinity is zero :)
16:53:16 <lokadin> :P kk
16:53:18 <lokadin> .ui
16:53:32 <xerox> dibblego: it's not!!!
16:53:48 <dibblego> xerox, I know :)
16:53:53 <mauke> > 1 / read "Infinity"
16:53:54 <lambdabot>  0.0
16:53:57 <mauke> it is!
16:54:05 <dibblego> oh I just made it up
16:54:08 <xerox> @slap mauke
16:54:08 * lambdabot slaps mauke
16:54:16 <mauke> ?yow
16:54:17 <lambdabot> Hey, waiter!  I want a NEW SHIRT and a PONY TAIL with lemon sauce!
16:54:17 <dibblego> if for all x/y = z then x/z=y
16:54:24 <heatsink> read "[1,2,3]"
16:54:27 <heatsink> > read "[1,2,3]"
16:54:28 <lambdabot>  Add a type signature
16:54:28 <xerox> We need @prod and @greet
16:56:02 <dmwit> > read "[1,2,3]" :: [Int]
16:56:03 <lambdabot>  [1,2,3]
16:56:43 <mauke> > 1/0
16:56:44 <lambdabot>  Infinity
16:57:06 <wkh> > 0/0
16:57:08 <lambdabot>  NaN
16:57:24 <mauke> > 0/0 == 0/0
16:57:26 <lambdabot>  False
16:58:10 <dmwit> > 1/0 == 1/0
16:58:11 <lambdabot>  True
16:58:18 <dmwit> > 1/0 == 2/0
16:58:20 <lambdabot>  True
16:58:46 <lokadin> :'( it works in my interpreter but if i put the same function inside another function in my program, it claims that it can't find factorial
16:59:23 <mauke> define "inside"
16:59:31 <lokadin> >sums pa = (let factorial n = if (n :: Int) < 2  then 1  else n * factorial (n - 1) in 1 / fromIntegral (factorial 5)) + (sums (pa-1))
17:00:00 <mauke> > let sums pa = (let factorial n = if (n :: Int) < 2  then 1  else n * factorial (n - 1) in 1 / fromIntegral (factorial 5)) + (sums (pa-1)) in sums
17:00:01 <lambdabot>  Add a type signature
17:00:25 <mauke> > let sums pa = (let factorial n = if (n :: Int) < 2  then 1  else n * factorial (n - 1) in 1 / fromIntegral (factorial pa)) + (sums (pa-1)) in sums
17:00:27 <lambdabot>  Add a type signature
17:00:29 <lokadin> i already have one
17:00:37 <lokadin> hmm
17:00:43 <mauke> > let sums pa = (let factorial n = if (n :: Int) < 2  then 1  else n * factorial (n - 1) in 1 / fromIntegral (factorial pa)) + (sums (pa-1)) in sums 42
17:00:44 <lokadin> maybe it should be different
17:00:45 <lambdabot>  Exception: stack overflow
17:00:52 <mauke> infinite loop
17:01:13 <dibblego> let begin a b = if length a > length b then False else take (length a) b == a;subsequence a [] = False;subsequence a b = if begin a b then True else subsequence a (tail b)
17:01:23 <lokadin> > let sums pa = (let factorial n = if (n :: Int) < 2  then 1  else n * factorial (n - 1) in 1 / fromIntegral (factorial pa)) + (sums (pa-1)) in sums 4
17:01:25 <lambdabot>  Exception: stack overflow
17:01:28 <dibblego> > let begin a b = if length a > length b then False else take (length a) b == a;subsequence a [] = False;subsequence a b = if begin a b then True else subsequence a (tail b)
17:01:29 <lambdabot>  Parse error
17:01:54 <dibblego> why is there a Parse error if it works in ghci?
17:02:12 <mauke> dibblego: because lambdabot wants an expression, not a definition
17:02:24 <mauke> i.e. you have to use let ... in ..., not just let ...
17:02:35 <dibblego> ah right
17:02:53 <dibblego> > let begin a b = if length a > length b then False else take (length a) b == a;subsequence a [] = False;subsequence a b = if begin a b then True else subsequence a (tail b) in subsequence [3,4] [1,2,3,4,5,6]
17:02:54 <lambdabot>  True
17:03:03 <dibblego> thanks
17:04:06 <mauke> > let subseq a b = any (a `isPrefixOf`) (tails b) in subseq [3,4] [1,2,3,4,5,6]
17:04:08 <lambdabot>  True
17:04:21 <mauke> ?pl subseq a b = any (a `isPrefixOf`) (tails b)
17:04:22 <lambdabot> subseq = (. tails) . any . isPrefixOf
17:04:55 <dibblego> ?type isPrefixOf
17:04:56 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:05:13 <dibblego> isn't that the same as my begin?
17:05:18 <mauke> yep, only better
17:05:26 <dibblego> what's better about it?
17:05:40 <dibblego> ?index tails
17:05:40 <lambdabot> Data.List
17:05:43 <mauke> > isPrefixOf [0,1] [0..]
17:05:44 <lambdabot>  True
17:05:51 <mauke> yours wouldn't terminate there
17:06:29 <dibblego> > let begin a b = if length a > length b then False else take (length a) b == a in [0,1] [0..]
17:06:30 <lambdabot>    The function `[0, 1]' is applied to one arguments,
17:06:30 <lambdabot>   but its type `[a]...
17:06:46 <mauke> missing "begin"
17:06:50 <dibblego> > let begin a b = if length a > length b then False else take (length a) b == a in begin [0,1] [0..]
17:06:54 <lambdabot> Terminated
17:07:08 <mauke> the problem is length [0 ..]
17:07:08 <dibblego> how would it be written better
17:07:24 <mauke> isPrefixOf
17:07:47 <dibblego> yeah what does it do differently so that it works?
17:08:01 <_frederik_> is there a way to get X11 to say something more specific than BadMatch?
17:08:10 <mauke> isPrefixOf [] _ = True; isPrefixOf _ [] = False; isPrefixOf (x : xs) (y : ys) = x == y && isPrefixOf xs ys
17:08:11 <xerox> > let begin _ [] = False; begin [] _ = False; begin (x:xs) (y:ys) | x == y = begin xs ys | otherwise = False in begin [1..4] [1..]
17:08:12 <lambdabot>  False
17:08:40 <xerox> Dang.
17:08:47 <dibblego> I think you messed it up a bit
17:08:58 <dibblego> > let begin _ [] = False; begin [] _ = True; begin (x:xs) (y:ys) | x == y = begin xs ys | otherwise = False in begin [1..4] [1..]
17:08:59 <lambdabot>  True
17:09:08 <dibblego> thanks
17:09:09 <mauke> still messed up
17:09:16 <mauke> begin [] [] should be True
17:09:35 <xerox> Add it to the very beginning
17:09:46 <dibblego> > let begin [] _ = True; begin _ [] = False; begin (x:xs) (y:ys) | x == y = begin xs ys | otherwise = False in begin [1..4] [1..]
17:09:47 <lambdabot>  True
17:09:51 <mauke> or just use my version :-)
17:09:54 <dibblego> > let begin [] _ = True; begin _ [] = False; begin (x:xs) (y:ys) | x == y = begin xs ys | otherwise = False in begin [] []
17:09:55 <lambdabot>  Add a type signature
17:10:15 <dibblego> how do you add a type signature?
17:10:29 <mauke> > let begin [] _ = True; begin _ [] = False; begin (x : xs) (y : ys) = x == y && begin xs ys in begin "" ""
17:10:31 <lambdabot>  True
17:10:44 <xerox> Clever.
17:11:11 <dibblego> because it is expecting a list whose elements are of type Eq?
17:11:18 <dibblego> and [] is not that but "" is?
17:12:09 <mauke> Eq is not a type
17:12:20 <dibblego> of type class Eq?
17:12:22 <dibblego> how do you say it
17:12:25 <mauke> no, the haskell compiler needs to know the type of all expressions
17:12:39 <mauke> [] has no specific type, though
17:12:55 <mauke> (its type is [a], which isn't fixed)
17:13:18 <mauke> all it knows is that "begin" requires a to be an instance of Eq, but that's it
17:13:56 <mauke> so I used "" instead, which is the same as ([] :: [Char]), only shorter
17:14:08 <xerox> The perler in mauke shows up.
17:14:22 <dibblego> ok thanks
17:14:36 <dibblego> let begin [] _ = True; begin _ [] = False; begin (x:xs) (y:ys) | x == y = begin xs ys | otherwise = False;subsequence a [] = False;subsequence a b = if begin a b then True else subsequence a (tail b)
17:14:42 <dibblego> is there any way to write subsequence better?
17:14:44 <mauke> hey, in perl I could just say begin [], [] without having to worry about types :-)
17:14:55 <xerox> See see!
17:15:15 <xerox> Yes!
17:15:16 <mauke> dibblego: > let subseq a b = any (a `isPrefixOf`) (tails b) in subseq [3,4] [1,2,3,4,5,6]
17:15:52 <xerox> Argh.
17:15:55 <xerox> @slap mauke
17:15:55 * lambdabot smacks mauke about with a large trout
17:16:14 <mauke> why?!
17:16:38 <xerox> I'm talking with a person here and you are beating me at golfing every time! :D
17:17:00 <int-e> you should slap yourself then
17:17:05 <int-e> for being slow.
17:17:13 <xerox> @slap my brother
17:17:13 <lambdabot> why on earth would I slap my brother
17:17:16 <xerox> ...
17:17:42 <dmwit> That's new.
17:19:29 <dibblego> the first argument to any is of type (forall a. [a] -> Bool) - how do you figure out that (a `isPrefixOf`) is of that type?
17:20:06 <xerox> (a `f`) = f a
17:20:10 <xerox> ?type isPrefixOf
17:20:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:20:25 <dibblego> ?type \a -> (a `Data.List.isPrefixOf`)
17:20:26 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:21:07 <dibblego> ah so given the a, it reduces to [a] -> Bool
17:21:14 <dibblego> function currying iirc
17:21:20 <mauke> yes
17:21:25 <dibblego> *given the [a]
17:21:54 <dmwit> I think it's called partial application.
17:21:57 <xerox> ?kind ((->) a)
17:21:59 <dmwit> Currying is different.
17:21:59 <lambdabot> Not in scope: type variable `a'
17:22:13 <dibblego> @pl any (a `isPrefixOf`) (tails b)
17:22:14 <lambdabot> any (a `isPrefixOf`) (tails b)
17:22:25 <xerox> No!
17:22:31 <xerox> ap (any . isPrefixOf) tails
17:22:41 <dibblego> wtf?
17:22:47 <xerox> Hmm, maybe not.
17:22:59 <mauke> ?pl \a b -> any (a `isPrefixOf`) (tails b)
17:22:59 <lambdabot> (. tails) . any . isPrefixOf
17:23:02 <xerox> (. tails) . (any . isPrefixOf)
17:23:05 <xerox> Yarrr
17:23:15 <xerox> @slap @pl
17:23:16 * lambdabot slaps @pl
17:23:20 <mauke> xerox: botsnack!
17:23:23 <dmwit> @yarrr
17:23:23 <lambdabot> Aye Aye Cap'n
17:23:26 <xerox> %-)
17:23:40 <dibblego> I don't even know what @pl does - I was just fitting in due to peer pressure :)
17:23:47 <dibblego> something about point free something
17:23:55 <mauke> pl is for "pointless"
17:24:05 <dmwit> @wiki pointfree
17:24:06 <lambdabot> http://www.haskell.org/haskellwiki/pointfree
17:24:22 <dibblego> ?index tails
17:24:22 <lambdabot> Data.List
17:25:41 <dibblego> so there is a pointfree versus pointless debate?
17:25:51 <dmwit> No, it's two names for the same thing.
17:26:05 <dibblego> oh
17:26:07 <xerox> ...
17:26:08 <dmwit> Some people think it's useful (hence point-free) and some don't (hence point-less).
17:29:21 <vincenz> dibblego: I just call it a pointless debate
17:31:25 <dibblego> ?index sets
17:31:26 <lambdabot> bzzt
17:31:49 <dmwit> @hoogle power
17:31:51 <lambdabot> No matches found
17:31:52 <dibblego> this website is making up functions? http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-15/index.html
17:31:54 <lambdabot> Title: CSc 372 - Comparative Programming Languages 15 : Haskell -- Exercises, http://tinyurl.com/z8as7
17:31:55 <dmwit> @hoogle Power
17:31:56 <lambdabot> No matches found
17:32:31 <dmwit> Nope, check out the "where" clause.
17:32:48 <dibblego> oh
17:33:37 <dibblego> can you just replace sets with mystery xs ?
17:33:54 <dmwit> Yeah, where is similar to let ... in, but reversed.
17:34:03 <dmwit> (And some other subtle differences.)
17:34:08 <edwardk> @seen shapr
17:34:09 <lambdabot> shapr is in #haskell. I last heard shapr speak 3h 8m 58s ago.
17:34:15 * edwardk pokes shapr.
17:35:19 <mauke>  I could never live in Central America because I'd miss the ocean.
17:35:31 <edwardk> If anyone from around here wants to split the cost of my room at ICFP, I'll have twin beds, and no roommate
17:35:57 <dibblego> how many people are expected to attend ICFP?
17:36:17 <dmwit> @type foldr (:) []
17:36:19 <lambdabot> forall a. [a] -> [a]
17:36:22 <dmwit> Huh.
17:36:25 <edwardk> dib: no idea
17:36:29 <dmwit> Oh.
17:36:31 <dmwit> @type foldr
17:36:33 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
17:37:06 <mauke> foldr (:) [] == id
17:38:03 <dmwit> mauke: foldr (:) [] == reverse ?
17:38:11 <mauke> why reverse?
17:38:13 <dmwit> > foldr (:) [] [1,2,3]
17:38:14 <lambdabot>  [1,2,3]
17:38:17 <dmwit> Huh.
17:38:56 <Cale> foldr f z replaces each (:) in a list with f and [] with z
17:39:17 <Cale> you're probably thinking of  foldl (flip (:)) []
17:39:21 <Cale> which is reverse
17:39:51 <dmwit> Ay, of course.
17:40:00 <dibblego> > foldr (*) 7 [1,2,3]
17:40:01 <lambdabot>  42
17:40:14 <dibblego> > foldr (/) 7 [1,2,3]
17:40:15 <dmwit> The 'r' stands for "right-associative", not "travel right"... =/
17:40:15 <lambdabot>  0.21428571428571427
17:40:42 <dmwit> > 1.5/7
17:40:43 <lambdabot>  0.21428571428571427
17:40:51 <Cale> yeah, the thing I remember is just that foldr is the natural one and foldl is the backwards one :)
17:41:54 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
17:41:56 <lambdabot> Title: Fold Diagrams - CaleWiki
17:42:37 <heatsink> cool!
17:42:52 <mauke> wait, then why does scanl feel more natural to me?
17:43:00 <dmwit> Is that you in the upper left?
17:43:03 <Cale> yes
17:43:18 <heatsink> heh, it's Calewiki
17:43:23 <dmwit> =)
17:43:42 <Cale> yeah, I decided to run MediaWiki, since I don't like wasting my time writing HTML :)
17:43:49 <dibblego> http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-15/index.html "5 shorter" can that be written so that it works with infinite lists?
17:43:51 <lambdabot> Title: CSc 372 - Comparative Programming Languages 15 : Haskell -- Exercises, http://tinyurl.com/z8as7
17:44:12 <dibblego> shorter [1,2] [1..] = [1,2]
17:44:28 <dmwit> Should be possible...
17:44:52 <dibblego> every time I think of how to do it, I think of using length
17:45:01 <dmwit> data Which = First | Second
17:45:11 <dmwit> shorter' :: [a] -> [b] -> Which
17:45:29 <dmwit> Just a hint. ;-)
17:45:38 <dibblego> that threw me right off
17:46:27 <dmwit> Maybe better to write shorter' as firstIsShorter :: [a] -> [b] -> Bool
17:46:47 <dibblego> is the single quote at the end any special meaning or just some convention?
17:46:54 <dmwit> Just a convention.
17:47:23 <dmwit> Comes from mathematics, where the prime is used to describe a different (but often related) function, i.e. f and f'
17:47:24 <dmwit> .
17:47:29 <mauke> shorter a b = if a `shorterThan` b then a else b where shorterThan [] [] = False; shorterThan [] _ = True; shorterThan _ [] = False; shorterThan (_ : xs) (_ : ys) = shorterThan xs ys
17:47:57 <Cale> How about  shorter' :: [a] -> [b] -> Either [a] [b]
17:48:08 <Cale> That should be easy enough to write :)
17:48:23 <Patterner> f x = x^2  =>  f' x = 2 x  (i would say "always" related :)
17:48:24 <dmwit> Ah, but then I would have to learn about Either... =)
17:48:36 <gmh33> dmwit: types are easy :P
17:48:36 <Cale> data Either a b = Left a | Right b
17:48:40 <dmwit> Patterner: The prime doesn't always mean differentiation.
17:49:03 <Patterner> it should
17:49:17 <Cale> Patterner: It doesn't even always mean differentiation in pure mathematics.
17:49:35 <Cale> So it's definitely not going to always mean that in programming :)
17:50:01 <Cale> shorter' [] ys = Left []
17:50:07 <Cale> shorter' xs [] = Right []
17:50:36 <Cale> shorter' (x:xs) (y:ys) = case shorter' xs ys of Left xs -> Left (x:xs); Right ys -> Right (y:ys)
17:50:38 <gmh33> yay functions :P
17:51:27 <Cale> Of course, this won't work if *both* lists are infinite, (and it couldn't)
17:52:09 <dibblego> then perhaps it should return Maybe [a] ?
17:52:24 <Cale> It can't detect when both lists are infinite
17:52:36 <Cale> To be correct, it must diverge in that case
17:52:47 <dibblego> what does that mean?
17:52:53 <Cale> (or else have a halting problem oracle)
17:52:58 <mauke> "infinite loop"
17:53:11 <dibblego> an infinite loop is a best case scenario?
17:53:16 <Cale> yeah
17:53:23 <LiquidEngineer> Is there a pastebin I can use?
17:53:28 <mauke> @paste
17:53:29 <lambdabot> http://paste.lisp.org/new/haskell
17:53:34 <dibblego> that sound a bit wrong
17:53:40 <Cale> If it managed to terminate, I think you could prove that it's incorrect, even.
17:54:05 <dmwit> dibblego: How can you tell which of two infinite lists is shorter?
17:54:17 <dibblego> dmwit, I agree you can't
17:54:40 <dibblego> is an infinite loop the correct behaviour for that case though?
17:54:50 <dmwit> I don't think you can avoid it.
17:54:51 <Cale> For the case of two infinite lists, yes
17:55:08 <dmwit> You have to know ahead of time that they are both infinite, and you can't do that...
17:55:37 <Cale> Right, unless you have some magical nonexistant oracle which tells you whether a program terminates :)
17:55:45 <dibblego> time it out perhaps?
17:55:51 <lisppaste2> liquidengineer pasted "Strange Error" at http://paste.lisp.org/display/26064
17:56:15 <Cale> Well, okay, you could do that. I don't think I'd consider that to be correct behaviour though.
17:56:31 <dibblego> ok
17:56:35 <Cale> Since it would mean that it would fail on some finite but very long inputs.
17:56:45 <dibblego> right
17:56:59 <mauke> LiquidEngineer: q = r `div` n
17:57:36 <dmwit> Cale: Some of those artworks are quite beautiful.  I especially like the Klein bottle and the one called "Fibre Light."
17:57:44 <Cale> dmwit: thanks :)
17:58:20 <LiquidEngineer> mauke: Pardon?
17:58:39 <LiquidEngineer> Oh.
18:05:21 <gmh33> Wii release info announced! :D
18:05:47 <dibblego> if == is equal comparison, how do you do not equal comparison?
18:05:59 <Cale> It's /=
18:06:07 <dibblego> ah thanks
18:06:20 <Cale> That's also how you do logical xor :)
18:10:30 <dibblego> http://rafb.net/paste/results/uL7lRP59.html why doesn't that work? I thought the type of a can be inferred to be [Char] and so [a] is [[Char]]
18:11:54 <araujo> yay!
18:12:07 <dibblego> I think I figured it out
18:12:08 <dibblego> let stripEmpty a = filter (\x -> x /= "") a
18:13:11 <araujo> you could also omit the a
18:13:27 <mauke> stripEmpty = filter (not . null)
18:14:00 <dibblego> aah pointfree
18:14:07 <araujo> yay!
18:14:39 <dibblego> mauke, that will work for any list, not just [Char] right?
18:14:44 <mauke> right
18:14:46 <edwardk> dib: *nods*
18:15:49 <araujo> @type filter (not . null)
18:15:51 <lambdabot> forall a. [[a]] -> [[a]]
18:16:10 <dibblego> @type filter (\x -> x /= "")
18:16:11 <lambdabot> [[Char]] -> [[Char]]
18:16:17 <araujo> List of list ....
18:16:27 <mauke> @type filter (/= [])
18:16:28 <araujo> @type null
18:16:28 <lambdabot> forall a. (Eq [a]) => [[a]] -> [[a]]
18:16:30 <lambdabot> forall a. [a] -> Bool
18:16:40 <araujo> @type filter
18:16:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:16:54 <araujo> so there you got it, filter+null
18:26:07 <dibblego> foldr (/) 7 [1,2,3] === 3/2/1/7 right?
18:27:16 <dibblego> > foldr (/) 7 [1,2,3]
18:27:17 <lambdabot>  0.21428571428571427
18:27:22 <dibblego> > 3/2/1/7
18:27:23 <lambdabot>  0.21428571428571427
18:27:36 <dibblego> > foldr (-) 2 [4,5,6]
18:27:37 <lambdabot>  3
18:27:43 <dibblego> > 6-5-4-2
18:27:44 <lambdabot>  -5
18:27:51 <mauke> foldr (/) 7 [1,2,3] == 1 / foldr (/) 7 [2,3] == 1 / (2 / foldr (/) 7 [3]) == 1 / (2 / (3 / foldr (/) 7 [])) == 1 / (2 / (3 / 7))
18:28:47 <dibblego> > 3/2/1/7 == 1/(2/(3/7))
18:28:48 <lambdabot>  True
18:29:35 <dibblego> 34/65/87/90 == 87/(65/(34/90))
18:30:10 <dibblego> > 34/65/87/90 == 87/(65/(34/90))
18:30:11 <lambdabot>  False
18:30:32 <dibblego> foldr (/) 7 [1,2,3] is not a good example :)
18:36:41 <dons> ?check (\a b c d -> a / b / c / d == a/(b/(c/d))) :: Float -> Float -> Float -> Float -> Bool
18:36:42 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0, 0.0, 0.0
18:36:59 <dons> ?check (\a b c d -> d > 0 ==> a / b / c / d == a/(b/(c/d))) :: Float -> Float -> Float -> Float -> Property
18:37:00 <lambdabot>  Falsifiable, after 0 tests: 1.0, -2.0, -2.5, 0.6666666
18:37:55 <dibblego> what does that do exactly?
18:38:03 <weitzman> > 1 / (1/2)
18:38:04 <lambdabot>  2.0
18:38:05 <dons> > (1.0 / -2.0 / -2.5 / 0.6666666, 1.0 / (-2.0 / (-2.5 / 0.6666666)))
18:38:06 <lambdabot>    precedence parsing error
18:38:06 <lambdabot>     cannot mix `(/)' [infixl 7] and prefix ...
18:38:08 <weitzman> > (1/1)/2
18:38:09 <lambdabot>  0.5
18:38:12 <weitzman> > 1 / 1 / 2
18:38:14 <lambdabot>  0.5
18:38:36 <dons> dibblego: It generates test cases, and tries to find ones for which the test fails
18:38:53 <dons> ?check \x -> x == (- (-x)) :: Int -> Bool
18:38:54 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Int -> ...
18:38:54 <dibblego> Falsifiable means it found it to be false? after 0 tests? wouldn't it need at least 1?
18:38:58 <newbcoder> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .) <-- what does that do?
18:39:02 <weitzman> I'm curious how functions are generated for testcases
18:39:06 <dons> ?check (\x -> x == (- (-x))) :: Int -> Bool
18:39:07 <lambdabot>  OK, passed 500 tests.
18:39:23 <newbcoder> > flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
18:39:24 <lambdabot>  Add a type signature
18:39:48 <dons> weitzman: using the coarbitrary method. given a random generator, it can be turned into a random function generator with some magic, but the full details are in the QuickCheck papers (findable from haskell.org)
18:39:57 <mauke> ?type flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
18:39:58 <lambdabot> forall a b a1 b1. (a -> b1) -> (a1 -> b) -> (a, a1) -> (b1, b)
18:40:05 <mauke> ?. djinn type flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
18:40:07 <lambdabot> f a b (c, d) = (a c, b d)
18:40:20 <weitzman> dons: I'll check it out
18:40:33 <dibblego> dons, so since 500 inputs pass, one can reasonably extrapolate that all inputs will hold?
18:41:02 <dons> it really depends on the type
18:41:18 <dons> ?check True
18:41:19 <lambdabot>  OK, passed 500 tests.
18:41:23 <dons> yes, you can assume this
18:41:35 <dons> ?check \x -> x < (10000000 :: Int)
18:41:36 <lambdabot>  OK, passed 500 tests.
18:41:47 <dons> well, does that mean that all Ints are < 10000000 ?
18:42:23 <dons> since there are more than 500 inhabitants of the Int type, only testing 500 cases is no proof :) you'd have to be smarter
18:42:30 <mauke> ?check \x -> x == x
18:42:31 <lambdabot>  Add a type signature
18:42:37 <dons> ?scheck \x -> x < (10000000 :: Int)
18:42:39 <lambdabot>  Completed 10 test(s) without failure.
18:42:54 <dons> smallCheck fails here too. (though I think with some tweaks it would work)
18:43:02 <mauke> ?check \x -> x == (x :: Double)
18:43:04 <lambdabot>  OK, passed 500 tests.
18:43:17 <dons> ?check \x -> x == (x :: Double) + 1 - 1
18:43:18 <lambdabot>  Falsifiable, after 4 tests: 0.6666666666666666
18:43:18 <mauke> > (\x -> x == (x :: Double)) (0/0)
18:43:20 <lambdabot>  False
18:43:21 <dons> floats rule
18:43:51 <mauke> floating tests should definitely try +inf, -inf and nan
18:44:18 <weitzman> I don't know the range for floating tests, but integer tests seem to only test -100 to 100
18:44:40 <weitzman> It would be nice if they always tested 0, 1, -1, int max, int min
18:45:25 <dons> its just a matter of tweaking the instances for Arbitrary and Random. check http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs and http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
18:45:27 <lambdabot> http://tinyurl.com/q2vhr
18:45:38 <dons> weitzman: yeah good idea.
18:46:07 <dons> Int looks fine
18:46:08 <dons> instance Arbitrary Int where
18:46:09 <dons>   arbitrary     = sized $ \n -> choose (-n,n)
18:46:09 <dons>   coarbitrary n = variant (if n >= 0 then 2*n else 2*(-n) + 1)
18:46:25 <dons> sized gives you the maxBound
18:46:41 <dons> instance Arbitrary Double where
18:46:41 <dons>   arbitrary     = liftM3 fraction arbitrary arbitrary arbitrary
18:46:41 <dons>   coarbitrary x = coarbitrary (decodeFloat x)
18:46:48 <weitzman> @check (< 100) :: Int -> Bool
18:46:49 <lambdabot>  Falsifiable, after 289 tests: 105
18:46:54 <dibblego> do people write unit tests for Haskell by providing function inputs and asserting a desired output?
18:46:58 <weitzman> @check (< 200) :: Int -> Bool
18:46:59 <lambdabot>  OK, passed 500 tests.
18:47:06 <dons> dibblego: more usualy we use QuickCheck as above
18:47:10 <weitzman> That's not a uniform distribution at least
18:47:15 <dons> we define properties that hold over all input
18:47:24 <dons> then perhaps use HUnit to test some specific cases
18:47:47 <weitzman> dibblego: If the haskell people are anything like the SML people, they probably assume their code is correct if it typechecks
18:47:47 <gmh33> parametric polymorphism is awesome (an aside)
18:48:02 <gmh33> weitzman: it isn't?
18:48:09 <dons> weitzman: boo. QuickCheck is really widely used
18:48:24 <dibblego> @check (< 100) :: Int -> Bool I can't figure out exactly what that does
18:48:25 <lambdabot>    Kind error: `Bool' is applied to too many type arguments     In the type...
18:48:52 <dons> dibblego: it generates random values for 'x', and applies the function to it:
18:49:08 <dons> ?check \x -> x < (3 :: Int)
18:49:09 <lambdabot>  Falsifiable, after 24 tests: 7
18:49:11 <dibblego> random values for x that are less than 100?
18:49:36 <dons> no, it just takes a while to generate the larger numbers, and we limit it to 500 cases
18:49:37 <weitzman> @check (\x y -> x - y == y - x) :: Int -> Int -> Bool
18:49:38 <lambdabot>  Falsifiable, after 6 tests: 2, -5
18:49:43 <dons> on your own box, you could let it run deeper
18:49:50 <dibblego> don't you find that when you generate the inputs, expressing the required behaviour is just the code that is under test?
18:50:05 <dons> sometimes, not usually though:
18:50:23 <dons> ?check \s -> not (null s) ==> head (sort s) == minimum (s :: [Int])
18:50:25 <lambdabot>  OK, passed 500 tests.
18:50:28 <dons> is a property.
18:50:31 <weitzman> dons: Is there some reason they don't generate ints uniformly?
18:50:42 <dons> the idea is to think in terms of invariants that should hold for the code, dibblego
18:50:55 <dons> its a higher level view of testing, perhaps
18:51:19 <dons> of course, you can also model check, by checking your actual code against some model that does the same thing
18:51:34 <dibblego> is there a paper on QuickCheck?
18:51:44 <weitzman> @where quickcheck
18:51:45 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
18:51:58 <dibblego> ta
18:52:03 <dons> yep. check haskell.org under 'Research papers'/Testing and correctness, I think, for more
18:52:22 <dons> here's some properties in QuickCheck for a large library I wrote, http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
18:52:23 <lambdabot> http://tinyurl.com/hcek8
18:52:50 <dons> it does both model checks against code in similar libraries I know to be correct, and tests internal properties, like the sort/minimum one above
18:53:12 <dons> (as an aside, coming up with properties like: head.sort == minimum, is a good way to get a nice flexible library api
18:54:56 <weitzman> Is there any software that tries to prove more rigorously that a certain property is true?
18:55:00 <weitzman> For haskell
18:55:22 <dons> yes, Isabelle, for one :) there's a lot of other niche tools
18:55:36 <dons> for exapmle, coverage testing, termination testing, and pattern non-exhausting
18:55:45 <weitzman> @where isabelle
18:55:46 <lambdabot> I know nothing about isabelle.
18:55:55 <dons> Agda and Isabelle are used most widely to prove hard properties
18:56:02 <dons> ?google isabelle theorem prover
18:56:05 <lambdabot> http://isabelle.in.tum.de/
18:56:07 <weitzman> The first hit on google for isabelle return 503 forbitten
18:56:09 <weitzman> *dden
18:56:20 <weitzman> Yeah
18:56:21 <weitzman> That's the one
18:56:23 <weitzman> Odd
18:56:48 <weitzman> ?help where
18:56:48 <lambdabot> where <key>. Return element associated with key
18:57:00 <weitzman> Can I put things into @where?
18:57:11 <dons> sure
18:57:14 <dons> with where+
18:57:18 <weitzman> Cool
18:57:32 <dons> ?where+ isabelle http://isabelle.informatik.tu-muenchen.de/
18:57:32 <lambdabot> Done.
18:57:45 <dons> doh, that's the dead link
18:57:46 <dons> hmm
18:57:49 <weitzman> http://www.cl.cam.ac.uk/Research/HVG/Isabelle/overview.html
18:57:52 <lambdabot> Title: Overview, http://tinyurl.com/km93h
18:59:23 <dons> for example, check the operating system page under the 'research papers' part of the wiki. there's a nice project to verify a kernel written in haskell, using Isabelle
18:59:41 <weitzman> I've seen that project
18:59:45 <weitzman> Thomas works on it, I believe
18:59:49 <dons> yep
18:59:55 <weitzman> But I gather there was some kind of translation from haskell into something else
19:00:57 <dons> right, haskell is translated to isabelle, which the theorem prover checks, verifying design decisions. then a micro kernel with that api is written in C. so its a prototyping approach in this case
19:01:21 <dons> there are other projects that prove things directly on the haskell code, e.g. Agda
19:01:32 <dons> (a paper at last year's ICFP talked about agda)
19:01:44 <weitzman> Yeah, I was thinking more of a proof-carrying-code kind of deal
19:02:24 <dons> there's some research in that area, but nothing in day to day use
19:03:52 <weitzman> I guess if something practical actually existed, this channel would be ablaze with people from industry trying to write provably correct software in Haskell
19:04:17 <weitzman> One day
19:04:18 <dons> there are some companies attempting to do this (e.g. galois) and they hang out here :)
19:04:33 <dibblego> there will possibly be another company one day
19:04:38 <dons> people do write proofs about haskell, its just not quite for the masses yet
19:04:41 <weitzman> I know Intel model-checks some of their stuff, but I don't think they use haskell
19:06:30 <dons> the tools are out there though, Isabelle and Agda (and maybe others), it just takes time, and thinking.
19:07:02 <emu> pshaw, even if they put fps or 6.6 up on spoj, getting all that into 256 bytes is gonna be rough
19:20:57 <LiquidEngineer> Any eclipse users here?
19:21:11 <weitzman> I used to use it, but it's been a few years
19:21:36 <LiquidEngineer> I've got a project with two files in it
19:21:40 <LiquidEngineer> one imports the other
19:22:47 <LiquidEngineer> but when I try compile/run, it doesn't seem to look in the imported module
19:23:13 <LiquidEngineer> (i.e.: I get a "<function in imported module> out of scope" error
19:25:30 <LiquidEngineer> all I have to do is put a import modulename at the top, right?
19:27:26 <weitzman> I haven't used haskell in eclipse, but that's seems logical
19:28:49 <LiquidEngineer> I would agree with you
19:28:59 <LiquidEngineer> yet I'm still getting the out of scope error
19:29:16 <weitzman> I assume the compile action just invokes GHC
19:29:23 <LiquidEngineer> yes
19:29:29 <LiquidEngineer> If I wanna use a function, say, nextrand from a module I've imported, I don't have to qualify that with anything, do I?
19:30:02 <weitzman> There are a few different importing syntaxes
19:30:02 <LiquidEngineer> like this
19:30:04 <LiquidEngineer> rr = nextRand seed
19:30:13 <LiquidEngineer> nextrand being in the module I've imported at the top
19:31:14 <weitzman> Should work, as far as I know
19:31:46 <LiquidEngineer> this is so troublesome
19:32:12 <weitzman> If it compiles from the command line
19:32:31 <weitzman> then the Eclipse environment may just be on drugs
19:32:46 <LiquidEngineer> gonna try that now
19:38:07 <LiquidEngineer> Good news
19:38:15 <LiquidEngineer> it doesn't work in command line ghc either
19:38:17 <LiquidEngineer> bad news
19:38:25 <LiquidEngineer> it doesn't work in the command line ghc either
19:38:26 <LiquidEngineer> ;)
19:40:22 <LiquidEngineer> so it's a haskell problem
19:40:54 <dolio> What are the modules named?
19:42:49 <gmh33> LiquidEngineer: It's never a haskell problem :P
19:42:51 <LiquidEngineer> Bins (in Bins.lhs) and Random (in Random.lhs)
19:43:00 <gmh33> pebkac
19:43:23 <LiquidEngineer> Obviously.
19:43:32 <LiquidEngineer> It's me that's doing something wrong
19:43:38 <gmh33> uh huh
19:44:13 <LiquidEngineer> Yes
19:44:45 <LiquidEngineer> dolio: any idea what I might be doing wrong?
19:45:10 <weitzman> @paste
19:45:10 <lambdabot> http://paste.lisp.org/new/haskell
19:45:36 <dolio> Not really. I thought perhaps if you had Foo.Bar type modules, you might be in the Foo directory, which could cause problems. But that's ruled out.
19:45:50 <LiquidEngineer> everything's in the same directory
19:45:58 <LiquidEngineer> weitzman: which module do you want me to past?
19:45:59 <LiquidEngineer> paste?
19:46:42 <weitzman> LiquidEngineer: I'm not going to be any help, actually.
19:46:53 <weitzman> LiquidEngineer: I always do haskell in interactive prompts
19:47:05 <LiquidEngineer> Hmm?
19:47:12 <LiquidEngineer> I'm running the script through GHCi
19:47:34 <gmh33> > 1:2:3:4:[]++[5]
19:47:36 <lambdabot>  [1,2,3,4,5]
19:47:36 <weitzman> I never import or declare modules.
19:47:37 <LiquidEngineer> It gives me line numbers (the first place I use a function from the imported module, with a claim that the module name is out of scope
19:47:51 <LiquidEngineer> weitzman: I don't HAVE to for this, but I'd like to be able to.
19:48:26 <LiquidEngineer> I'm building a travelling salesman solver, and I'd like to have my random number generator functions seperate so they're not in the way
19:48:45 <weitzman> LiquidEngineer: Sounds perfectly reasonable
19:48:57 <LiquidEngineer> :)
19:49:13 <LiquidEngineer> You wanna see how I have it set up, just in case?
19:49:18 <weitzman> Sure, why no
19:49:19 <weitzman> *t
19:52:07 <lisppaste2> liquidengineer pasted "Modules" at http://paste.lisp.org/display/26067
19:54:04 * wkh is watching the channel 9 videos on F#.Net
19:54:10 <weitzman> That looks pretty much like other haskell code I've seen
19:54:26 <wkh> if microsoft shipped an ML-like language in visual studio i'd be surprised and impressed
19:54:29 <weitzman> Can't see anything weird
19:54:46 <dolio> Are they shipping F#?
19:54:52 <wkh> no
19:54:53 <LiquidEngineer> F Sharp?
19:54:55 <weitzman> wkh: They ship lisp, I think. A step in the right direction
19:55:17 <wkh> they do?
19:55:22 <weitzman> I believe so.
19:55:23 <gmh33> lithp!
19:55:26 <dolio> Ah, I guess that'd be what you were talking about.
19:55:39 <dolio> Since F# is described as ML on .net.
19:55:52 <gmh33> the microsoft research center in england does some ghc research >_>;
19:56:01 <wkh> people never get tired of making jokes where they say "lithp"
19:56:07 <weitzman> C:\Program Files\Microsoft Visual Studio .NET 2003\SDK\v1.1\Tool Developers Guide\Samples\clisp
19:56:14 <LiquidEngineer> weitzman: maybe GHC has some sort of special module syntax?
19:56:15 <gmh33> wkh: how can you get tired of saying lithp?
19:56:16 <weitzman> Is apparently where you can find lisp
19:57:33 <weitzman> LiquidEngineer: Highly unlikely. The only thing I was wondering about was that whitespace is significant in Haskell. I suspect adding a blank line before "import Random" won't help, though
19:57:50 <weitzman> Other than that, I'm out of ideas
19:58:33 <SamB> I assume those modules are in different files?
19:59:18 <dolio> Oh wait...
19:59:44 <LiquidEngineer> SamB: Yes
19:59:53 <weitzman> dolio: Waiting...
19:59:56 <gmh33> export ?
19:59:56 <dolio> Query: If his module is named Random, will that be imported instead of Random from the H98 modules?
20:00:15 <weitzman> Isn't it System.Random?
20:00:33 <weitzman> Oh...wait
20:00:35 <weitzman> Yeah
20:00:37 <SamB> weitzman: there is also a Random from the haskell98 package...
20:00:41 <weitzman> Looks like there may be more than one random
20:00:48 <dons> ?hoogle Random
20:00:48 <lambdabot> Random :: module
20:00:49 <lambdabot> System.Random :: module
20:00:49 <lambdabot> System.Random.Random :: class Random a
20:00:57 <LiquidEngineer> Change the name?
20:00:57 <dolio> Try renaming to MyRandom and import MyRandom
20:01:05 <dolio> Or something like that.
20:01:40 <SamB> OO
20:01:55 <gmh33> SamB had a revolation ?
20:02:07 <SamB> I just ran ghci -hide-package haskell98, and it refused to start!
20:02:16 <SamB> it said:
20:02:24 <SamB> Loading package base-1.0 ... linking ... done.
20:02:24 <SamB> <interactive>:1:84:
20:02:24 <SamB>     Failed to load interface for `IO':
20:02:24 <SamB>         Could not find module `IO':
20:02:24 <SamB>           it is a member of package haskell98-1.0, which is hidden
20:02:24 <SamB> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1):
20:02:26 <SamB>         interactiveUI:flush
20:03:11 <gmh33> SamB: you can't very well have an interactive shell without any sort of interaction with the real world, hm?
20:03:19 <SamB> gmh33: yes!
20:03:32 <SamB> but I don't see what it needs tha haskell98 package for!
20:03:45 <gmh33> for .. IO ?
20:04:09 <SamB> but, everything in that is supposed to be in better-named modules in base!
20:04:26 <gmh33> I see
20:04:30 <SamB> so...
20:04:41 <gmh33> let them eat cake?
20:04:41 <SamB> hopefully they have fixed this by now ;-)
20:05:22 <gmh33> oh well, sleep time for me I think
20:05:39 <gmh33> I have to wake up really early for work tomorrow.. 4 deliverables still need packing :/
20:05:50 <weitzman> Is it possible to squeeze a function definition with multiple guards into a single line?
20:06:08 <gmh33> yes
20:06:14 <gmh33> blah | blah | blah | blah
20:06:27 <emu> is it possible to do that with a where clause
20:06:38 <SamB> > let f x | x == 1 = -1 | otherwise = x
20:06:39 <lambdabot>  Parse error
20:06:41 <SamB> hmm
20:06:50 <gmh33> try { }
20:06:51 <LiquidEngineer> Hmmm
20:06:55 <LiquidEngineer> well, this is different, at least
20:06:56 <SamB> > let f x | x == 1 = -1 | otherwise = x in f 1
20:06:58 <lambdabot>  -1
20:07:01 <SamB> ah ;-)
20:07:05 <weitzman> Indeed
20:07:09 <gmh33> > let {f x | x == 1 = -1} | otherwise = x in f 1
20:07:10 <lambdabot>  Parse error
20:07:15 <SamB> helps if you remember to make it a whole expression ;-)
20:07:18 <gmh33> > let {f x | x == 1 = -1} | {otherwise = x in f 1}
20:07:19 <lambdabot>  Parse error
20:07:22 <gmh33> boo lol
20:07:26 <gmh33> oh well I tried lol
20:07:30 <weitzman> What about multiple patterns being matched on?
20:07:41 <gmh33> (ignore me)
20:07:42 <dmwit> > let f x | x == 1 = myConst | otherwise = 1 where myConst = 3 in f 1
20:07:43 <lambdabot>  3
20:07:55 <SamB> > let f 1 = "Hi!"; f 2 = "Hello!" in f 2
20:07:55 <weitzman> > let f (Maybe x) = 1; f Nothing = 2 in f Nothing
20:07:56 <lambdabot>  Not in scope: data constructor `Maybe'
20:07:57 <lambdabot>  "Hello!"
20:08:12 <weitzman> > let f (Just x) = 1; f Nothing = 2 in f Nothing
20:08:13 <lambdabot>  2
20:08:23 <weitzman> I don't like the choice of the word "Just"
20:08:33 <gmh33> > putStrLn "g'night everyone"
20:08:35 <lambdabot>  No IO allowed
20:08:37 <gmh33> damn
20:08:37 <gmh33> lol
20:08:48 <dmwit> I think the Maybe monad is one of Haskell's few successful pieces of humor.
20:08:48 <weitzman> It seems to imply that you wanted more stuff, but you were only allowed to keep one
20:08:48 <SamB> heh
20:09:05 <LiquidEngineer> Now it's telling me this
20:09:06 <LiquidEngineer> Could not find module `TSRandom':
20:09:06 <LiquidEngineer>   use -v to see a list of the files searched
20:09:09 <SamB> dmwit: hmm?
20:09:20 <LiquidEngineer> I think there's a path somewhere in eclipse I can adjust
20:09:22 <dmwit> I mean really: data Maybe a = Just a | Nothing.
20:09:25 <SamB> LiquidEngineer: you called the file TSRandom.hs?
20:09:33 <LiquidEngineer> .lhs, yes
20:09:40 <SamB> oh, yeah, right ;-)
20:09:41 <weitzman> Also, I don't like the name of the maybe monad
20:09:45 <dmwit> Read it aloud: "Maybe you have something means either you have just something or you have nothing."
20:09:49 <SamB> that was a literate module...
20:09:51 <dmwit> Perfect!
20:09:55 <SamB> weitzman: heh
20:10:00 <SamB> what would you call it?
20:10:07 <LiquidEngineer> Sam: yes, all my modules are literate
20:10:25 <dolio> I'm still up for changing it to the Picard monad.
20:10:29 <weitzman> SamB: Hmmm. Optional?
20:10:32 <SamB> dolio: heh
20:10:40 <weitzman> SML uses "Option"
20:10:48 <weitzman> SOME a | NONE
20:10:53 <SamB> weitzman: that only makes sense for argument types...
20:10:58 <dmwit> Why Picard?
20:11:09 <dolio> data Picard a = MakeItSo a | BelayThat
20:11:09 <SamB> dmwit: well, look at the constructor names!
20:11:26 <weitzman> SamB: Possible?
20:11:27 <SamB> dolio: those are the constructor names?
20:11:34 <SamB> come on!
20:11:41 <SamB> there have got to be better ones than that!
20:11:50 <dolio> Hey, I didn't come up with that on my own. :)
20:12:00 <SamB> yeah, but weren't there better ones?
20:12:09 <SamB> I could have sworn the ones I saw were better than that!
20:12:10 <dolio> Those are the only ones I remember.
20:12:21 <SamB> I can't remember them though ;-)
20:12:22 <dolio> There were ones that didn't have to do with Star Trek.
20:12:25 <weitzman> I think "Possible" could work as a name
20:12:51 <SamB> Maybe makes more sense to me ;-)
20:13:20 <SamB> Maybe String is Maybe Just a String, or it could be Nothing.
20:13:24 <weitzman> And then "Just" === "Definite". Or "InstanceOf"
20:13:41 <SamB> ackackackack!
20:13:46 * SamB runs screaming to bed!
20:13:47 <weitzman> Yeah, ok. I relent
20:13:47 <dolio> Let's see... Logs...
20:14:11 <dolio> "Indeed a | Fugeddaboudit"
20:14:19 <dmwit> I prefer "NoDice"...
20:14:20 <dmwit> =)
20:14:29 <dolio> "data Maybe a = YeaVerily a | Alas"
20:14:55 <sieni> "YesItsAFscking a | NothingToSeeHereMoveAlong"
20:15:32 <Pseudonym> data Perhaps a = Probably a | Unlikely
20:15:36 <dolio> And someone suggested a "TeaEarlGreyHot" constructor.
20:15:55 <Pseudonym> No, if you're going to do adjectives, use phantom types.
20:16:03 <weitzman> data WhatTheHellIsA thinggy = YouMeanThis thinggy | Shenanigans
20:16:19 <sieni> MoreBooze a | Vomimt
20:16:20 <sieni> -m
20:16:23 <emu> $ Shenanigans
20:16:29 <Pseudonym> data Unknown a = HereBe a | Dragons
20:16:53 <sieni> Sex a | Marriage
20:17:05 <Pseudonym> Sex a | Kids
20:17:20 <dmwit> data EthnicJoke a = Stupid a | HonestLawyer
20:17:36 <jcreigh> Here's a crazy one: Mabye a = Just a | Nothing
20:17:50 <Pseudonym> That is crazy.  What the hell is a "mabye"?
20:18:00 <int-e> Maybe
20:18:06 <dfranke> data Badger a = Mushroom a | Snake
20:18:13 <weitzman> data Leaky a = New a | Oops
20:18:13 <Pseudonym> data DishonestProfession = Lawyer | Politician | SerialKiller
20:18:14 <dmwit> Maybe Mabye baby.
20:18:17 <Pseudonym> Surely.
20:18:33 <dfranke> Llama a | Duck
20:18:35 <Pseudonym> dfranke: Curse you and all your descendents.
20:18:37 <Cale> I just came up with the simplest possible nontrivial religion: "Believing in this statement will make you happier."
20:18:47 <Pseudonym> May all your code be self-modifying and may all your type systems be unsafe.
20:18:54 <dons> nice, Cale!
20:19:11 <dmwit> It's true, I just tried it!
20:19:11 <Pseudonym> Must.  Get.  Out.  Of.  Head...
20:19:16 <shapr> Yargh
20:19:19 <int-e> nontrivial religion.
20:19:26 <dons> I'm happier already!
20:19:37 <weitzman> What's a trivial religion?
20:19:40 <dmwit> =) -> =D
20:19:58 <Pseudonym> How about this one: "This statement made the universe."
20:19:58 <int-e> I'm also happy. I got that SplitSeq code to work after debugging a non-existing problem for half an hour. (My test case was flawed)
20:20:03 <jcreigh> weitzman: PHP?
20:20:17 <LiquidEngineer> Grar
20:20:21 <int-e> err. I realized that it did, in fact, work.
20:20:30 <LiquidEngineer> I just ran ghc with -v so I could see where it was searching
20:20:36 <LiquidEngineer> I thought maybe I'd get some paths
20:20:37 <LiquidEngineer> not so
20:20:38 <LiquidEngineer> I get this
20:20:41 <LiquidEngineer>  Could not find module `TSRandom':
20:20:42 <LiquidEngineer>           locations searched:
20:20:42 <LiquidEngineer>             TSRandom.hi
20:20:42 <LiquidEngineer>             TSRandom.hi-boot
20:20:49 <LiquidEngineer> I don't even know what that means
20:20:50 <sieni> Is PHP acronym for "Programmer's Hell - PHP"?
20:21:10 <Pseudonym> weitzman: A trivial religion is "Don't worry, be happy."
20:21:10 <int-e> It's a recursive acronym: People Hate PHP
20:21:13 <dolio> What command are you using to compile on the command line?
20:21:14 <dmwit> LiquidEngineer: *nix?
20:21:21 <dfranke> my research project is called TIARA.
20:21:26 <dfranke> TIARA Is A Recursive Acronym.
20:21:43 <sieni> iiiik
20:21:46 <Pseudonym> I have a piece of software on my hard drive called "Kinara".
20:21:47 <int-e> ETLA is one of my favourit acrynums.
20:21:50 <LiquidEngineer> dmwit: MacOS DX
20:21:53 <Pseudonym> "Kinara" is NOT a recursive acronym.
20:21:54 <LiquidEngineer> X, rather
20:22:10 <dmwit> I would recommend the "locate" command...
20:22:13 <Pseudonym> I believe that makes it the first self-contradictory recursive acronym.
20:22:32 <dons> Pseudonym++
20:22:43 <Pseudonym> ?karma
20:22:44 <lambdabot> You have a karma of 7
20:22:48 <int-e> It's not a recursive acronym ;)
20:22:53 <LiquidEngineer> what is .hi and .hi-boot?
20:22:57 <int-e> ?karma
20:22:57 <lambdabot> You have a karma of 19
20:23:03 <LiquidEngineer> ?karma
20:23:04 <lambdabot> You have a karma of 0
20:23:09 <dfranke> ?karma
20:23:09 <dons> LiquidEngineer: check the ghc user's guide on 'modules'
20:23:10 <lambdabot> You have a karma of 0
20:23:10 <dolio> LiquidEngineer: Are you using --make?
20:23:12 <dons> at haskell.org/ghc
20:23:18 <LiquidEngineer> dolio: no.
20:23:21 <LiquidEngineer> do I need to
20:23:23 <weitzman> Java++
20:23:27 <LiquidEngineer> I'm just rying to use ghci
20:23:31 <dmwit> @karma Java
20:23:31 <lambdabot> Java has a karma of -2
20:23:41 <dolio> Hmm, you shouldn't need it in ghci.
20:23:46 <int-e> @karma weitzman
20:23:46 <weitzman> Java++
20:23:47 <lambdabot> weitzman has a karma of -1
20:23:48 <weitzman> @karam java
20:23:49 <lambdabot> Maybe you meant: karma karma+ karma-
20:23:53 <int-e> @karma weitzman
20:23:54 <lambdabot> weitzman has a karma of -1
20:23:54 <weitzman> Ouch
20:23:58 <wkh> @karma wkh
20:23:59 <lambdabot> You have a karma of 0
20:24:00 <int-e> @karma Java
20:24:01 <lambdabot> Java has a karma of -2
20:24:02 <dons> its dangerous to play with java...
20:24:02 <int-e> hmm
20:24:18 <int-e> java--
20:24:29 <dons> danger, int-e, danger!
20:24:34 <int-e> @karma int-e
20:24:35 <lambdabot> You have a karma of 19
20:24:36 <weitzman> @karma java
20:24:37 <lambdabot> java has a karma of -8
20:24:38 <int-e> @karma java
20:24:39 <lambdabot> java has a karma of -8
20:24:47 <int-e> you fixed that, dons
20:24:47 <weitzman> @karma Java
20:24:48 <lambdabot> Java has a karma of -2
20:25:06 <dons> not normalised yet. should do that some time...
20:25:18 <dons> ?uptime
20:25:18 <lambdabot> uptime: 1d 10h 22m 10s, longest uptime: 2d 8h 20m 7s
20:25:19 <int-e> java-- is safe. java++ isn't.
20:25:25 <dons> oh good
20:25:28 <dons> ?users
20:25:30 <lambdabot> Maximum users seen in #haskell: 242, currently: 219 (90.5%), active: 29 (13.2%)
20:25:40 <dmwit> @karma java
20:25:41 <lambdabot> java has a karma of -9
20:25:43 <dmwit> Heh.
20:25:52 <dons> i have a lambdabot in another chan, 13:25  lambdabot:: uptime: 12d, 1 h, 39m  5s, longest uptime: 12d, 1 h, 39m  5s
20:25:55 <dons> :)
20:26:48 <Pseudonym> C++
20:26:50 <Pseudonym> ?karma C
20:26:51 <lambdabot> C has a karma of 2
20:27:00 <Cale> C++
20:27:04 <Cale> ?karma C
20:27:05 <lambdabot> C has a karma of 2
20:27:07 <dons> special case.
20:27:09 <Pseudonym> OK.
20:27:09 <int-e> @qutoe
20:27:10 <lambdabot> Heffalump says: CPP leads to suffering
20:27:11 <LiquidEngineer> It makes a big deal out of making sure your filenames and module names are the same
20:27:12 <LiquidEngineer> I did that
20:27:13 <dmwit> Deja vu...
20:27:15 <Pseudonym> C--
20:27:17 <Pseudonym> ?karma C
20:27:18 <lambdabot> C has a karma of 2
20:27:20 <Pseudonym> Just checking.
20:27:22 <weitzman> So the karma of C is forever 2
20:27:24 <weitzman> Good number
20:27:30 <dmwit> @karma+ C
20:27:30 <int-e> @karma+ C
20:27:30 <lambdabot> C's karma raised to 3.
20:27:31 <lambdabot> C's karma raised to 4.
20:27:32 <LiquidEngineer> The modules are int he same directory
20:27:35 <weitzman> Oh
20:27:36 <LiquidEngineer> I don't know what else to do
20:27:37 <dmwit> .... =D
20:27:41 <weitzman> I was schooled
20:27:44 <Cale> @karma- C
20:27:45 <lambdabot> C's karma lowered to 3.
20:27:45 <Pseudonym> ?karma- C  -- I sense a disturbance in the Force.
20:27:46 <lambdabot> C's karma lowered to 2.
20:27:49 <Cale> @karma- C
20:27:50 <lambdabot> C's karma lowered to 1.
20:27:57 <dmwit> Whoa, karma flood.
20:28:00 <int-e> @karma+ C
20:28:01 <lambdabot> C's karma raised to 2.
20:28:05 <int-e> I like C.
20:28:07 <dmwit> @karma* C
20:28:08 <weitzman> ?karam<< java
20:28:08 <lambdabot> Maybe you meant: karma karma+ karma-
20:28:09 <Pseudonym> OK, now NOBODY TOUCH ANYTHING!
20:28:09 <lambdabot> Unknown command, try @list
20:28:28 <dons> seemed to work, Pseudonym .
20:28:28 <sieni> @karma+ c
20:28:29 <lambdabot> c's karma raised to -1.
20:28:33 <dons> spoke too soon
20:28:35 <Pseudonym> karma karma+ karma- karma<< karma>> chameleon...
20:28:40 <dons> heh
20:28:55 <int-e> exponential karma would be evil
20:29:12 <Pseudonym> Or good, depending on your history.
20:29:36 <dmwit> History is good.
20:29:45 * Cale considers the incredible power of @dynamic-unload karma
20:29:47 <Pseudonym> History is morally neutral, surely.
20:30:00 <weitzman> Karma could be additive-increase, multiplicative-decrease
20:30:50 <dons> Cale, hmm?
20:31:13 <int-e> Apparently, Cale doesn't like spam.
20:31:28 <dons> no. fair enough
20:32:18 <newsham> dons: did a little measuring and a little tweaking, and in the end its only just as fast as the python implementation :(
20:32:39 <dons> you want me to have a look?
20:32:51 <dons> if you have a test case or two to work with?
20:32:54 <newsham> yes, please.
20:33:11 <dons> should be pretty easy to beat python, it's not been difficult to do so in the past
20:35:11 <Cale> dons: We can make the universe forget about karma altogether
20:36:27 <wkh> karma+ wkh
20:36:33 <wkh> karma wkh
20:40:46 <dons> Cale: ?
20:41:26 <dons> do you mean, we should ditch it? or am I misinterpreting your prophecies and divinations?
20:42:27 * int-e likes karma better than slap.
20:42:49 <int-e> @help hylo
20:42:50 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
20:42:51 <lambdabot> Uses the Pointless.Combinators from:
20:42:51 <lambdabot>  http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
20:42:51 <lambdabot> Mirrored:
20:42:51 <lambdabot>  http://www.cse.unsw.edu.au/~dons/Pointless/
20:45:45 <weitzman> @hylo 3
20:45:45 <lambdabot> drhylo module failed: IRCRaised user error (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 2}: Parse error)
20:46:03 <dons> ?hylo f x = x
20:46:03 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
20:46:04 <lambdabot>  where g (x) = x
20:46:04 <lambdabot>     h x = (x)
20:46:19 <dons> an alternative (verbose) @pl
20:46:59 <dons> ?hylo f x y = (f x , f y)
20:46:59 <lambdabot> f x y = (f x, f y)
20:47:06 <dons> and it gives up too easily :)
20:47:44 <int-e> ?hylo f x y = y x x
20:47:45 <lambdabot> f x y = y x x
20:48:31 <dons> ?hylo f x y z = z
20:48:31 <lambdabot> f x y z = z
20:48:41 <int-e> strange.
20:48:56 <int-e> ?hylo f x = x x
20:48:57 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
20:48:57 <lambdabot>  where g (x) = x x
20:48:57 <lambdabot>     h x = (x)
20:49:29 <dons> ?hylo fib 0 = 1 ; fib 1 = 1 ; fib x = fib (x-1) + fib (x-2)
20:49:30 <lambdabot> fib = hylo (_L :: Mu (Const () :+: (Const () :+: (Id :*: Id)))) g h
20:49:30 <lambdabot>  where g (Left (())) = 1
20:49:30 <lambdabot>     g (Right (Left (()))) = 1
20:49:30 <lambdabot>     g (Right (Right ((v2, v3)))) = v2 + v3
20:49:30 <lambdabot>     h 0 = Left (())
20:49:32 <lambdabot>     h 1 = Right (Left (()))
20:49:34 <lambdabot>     h x = Right (Right (((x - 1), (x - 2))))
20:49:43 <dons> go dr. hylo!
20:50:01 <dons> ?pl fib 0 = 1 ; fib 1 = 1 ; fib x = fib (x-1) + fib (x-2)
20:50:02 <lambdabot> (line 1, column 11):
20:50:02 <lambdabot> unexpected ";"
20:50:02 <lambdabot> expecting variable, "(", operator or end of input
20:50:04 <dons> :)
20:50:10 <dons> drhylo++
20:51:57 <dwm> I'm confused about something.
20:52:08 <dwm> Take the type of maybe for instance.
20:52:12 <dwm> @type maybe
20:52:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:52:29 <dwm> The parenthesis there, are they basically arbitrary? For our benefit?
20:52:44 <int-e> no.
20:52:49 <dons> to help parsing... :)
20:53:17 <dwm> But other times, say you write something that's foo :: a -> a -> a
20:53:23 <dons> ?djinn b -> (a -> b) -> Maybe a -> b
20:53:24 <lambdabot> f a b c =
20:53:24 <lambdabot>   case c of
20:53:24 <lambdabot>   Nothing -> a
20:53:24 <lambdabot>   Just d -> b d
20:53:27 <int-e> ((b -> (a -> b) -> Maybe a) -> b) has some superfluous parentheses.
20:53:33 <dons> ?djinn b -> a -> b -> Maybe a -> b
20:53:33 <lambdabot> f a _ b c =
20:53:34 <lambdabot>   case c of
20:53:34 <lambdabot>   Nothing -> b
20:53:34 <lambdabot>   Just _ -> a
20:53:38 <dwm> You could partial eval that with the first a and end up with a function from a -> a
20:53:40 <int-e> (a -> b) means that the corresponding argument is a function.
20:53:45 <dons> ?djinn b -> a -> (b -> Maybe (a -> b))
20:53:46 <lambdabot> f _ _ a = Just (\ _ -> a)
20:53:48 <dons> :)
20:54:06 <int-e> > maybe 1 succ (Just 0)
20:54:08 <lambdabot>  1
20:54:10 <int-e> > maybe 1 succ (Just 22)
20:54:12 <lambdabot>  23
20:54:22 <int-e> like succ in this example
20:54:24 <dons> ?djinn ((b -> a) -> b)) -> Maybe (a -> b)
20:54:24 <lambdabot> Cannot parse command
20:54:30 <dons> ?djinn ((b -> a) -> b) -> Maybe (a -> b)
20:54:31 <lambdabot> f a = Just (\ b -> a (\ _ -> b))
20:54:41 <dons> parens mean something :)
20:54:45 <dwm> But are these things the same: foo :: a -> a -> a  and  foo :: a -> (a -> a)  ?
20:54:51 <dons> yep
20:54:57 <dons> ?djinn a -> a -> a
20:54:57 <lambdabot> f _ a = a
20:55:00 <dons> ?djinn a -> (a -> a)
20:55:01 <lambdabot> f _ a = a
20:55:13 <dons> ?ft a -> (a -> a)
20:55:15 <lambdabot>  There was an error in the type: (line 1, column 7):
20:55:15 <lambdabot>  unexpected "e"
20:55:15 <lambdabot>  expecting "->" or end of input
20:55:21 <Cale> dons: I was joking :)
20:55:23 <int-e> sorry. I messed up my parentheses above. I'll pretend I was describing a different function.
20:55:29 <dons> ?free myf :: a -> (a -> a)
20:55:29 <lambdabot> f . myf x = myf (f x) . f
20:55:31 <dwm> If I define a foo like that second one, would it be an error to try to call it with two a's?
20:55:34 <jcreigh> so djinn takes a type and returns some arbitrary code that has that type?
20:55:34 <dons> ?free myf :: a -> a -> a
20:55:34 <lambdabot> f . myf x = myf (f x) . f
20:55:51 <dons> jcreigh: well, not _arbitrary_, but it does generate code for polymorphic types
20:55:59 <int-e> ? free invert :: (a -> b) -> b -> a
20:56:04 <int-e> ?free invert :: (a -> b) -> b -> a
20:56:05 <lambdabot> g . h = k . f => f . invert h = invert k . g
20:56:33 <dons> ?free invert :: a -> b -> b -> a
20:56:33 <lambdabot> f . invert x y = invert (f x) (g y) . g
20:58:19 <jcreigh> @djinn (a,b) -> a
20:58:20 <lambdabot> f (a, _) = a
20:58:57 <jcreigh> @type \(a,b) -> a*a
20:58:59 <lambdabot> forall a b. (Num a) => (a, b) -> a
20:59:29 <int-e> ?free pair :: a -> a -> a
20:59:30 <lambdabot> f . pair x = pair (f x) . f
20:59:54 <dons> ?ft pair :: a -> a -> a
20:59:55 <lambdabot>  There was an error in the type: (line 1, column 4):
20:59:56 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
21:00:03 <dons> ah
21:00:04 <dwm> It seems like sometimes I can move the parens around, like in that right there. But other times, not allowed.
21:00:18 <dons> dwm, sometimes they're semantically redundant, due to fixity
21:00:35 <dons> as with value level code, so the type level, these are the parenthesis of our times
21:01:15 <int-e> (a -> (b -> c)) and (a -> b -> c) mean the same thing, ((a -> b) -> c) means something different.
21:05:14 <dwm> hm ok
21:06:06 <dwm> thank you
21:06:25 <dons> > 1 / (2/3)
21:06:26 <lambdabot>  1.5
21:06:42 <dons> > (1 / 2)/3
21:06:44 <lambdabot>  0.16666666666666666
21:07:11 <dwm> > 1 / 2 / 3
21:07:12 <lambdabot>  0.16666666666666666
21:07:23 <dons> ?kind (a -> (b -> c))
21:07:24 <lambdabot> Not in scope: type variable `a'
21:07:24 <lambdabot>  
21:07:24 <lambdabot> <interactive>:1:7: Not in scope: type variable `b'
21:07:26 <int-e> > ([]:[]:[], ([]:[]):[])
21:07:27 <lambdabot>  Add a type signature
21:07:40 <dons> ?kind forall a b . (->) a b
21:07:42 <lambdabot> *
21:07:47 <dons> ?kind (->) a b
21:07:48 <lambdabot> Not in scope: type variable `a'
21:07:49 <lambdabot>  
21:07:49 <lambdabot> <interactive>:1:7: Not in scope: type variable `b'
21:07:53 <dons> didn't know that.
21:08:09 <int-e> > ([]:[]:[], ([]:[]):[]) :: ([[[Int]]], [[[Int]]])
21:08:11 <lambdabot>  ([[],[]],[[[]]])
21:09:56 <int-e> ([([([()])])]) is a valid type :)
21:16:08 <Cale> It's the same as [[[()]]] though
21:24:00 <newsham> segway scooters recalled due to software bug.  heh.
21:25:00 <dons> yeah, we know what they should be programming them in now ...
21:25:32 <dfranke> newsham: ever seen Trevor Blackwell's reverse-engineered Segway clone?
21:26:16 <dottedmag> dfranke: probably he found severe security bug :)
21:26:50 <dfranke> it's nicer than real Segways because he removed the safety speed inhibitor.
21:27:13 <Pseudonym> And presumably the bug that throws people off.
21:27:19 <dfranke> I was at a reception at Y Combinator HQ and got to ride it...
21:27:35 <dfranke> I discovered that Segways do not retain their stability while airborne.
21:28:25 <dfranke> I drove it off a curb in the parking lot, fell off, and then had to go chasing after it because it was still tilted forward.
21:29:02 <dfranke> three reporters got it on camera, but fortunately I checked the papers the next day and nothing was mentioned.
21:31:16 <dfranke> the software for it is written Python.  Trevor showed us the source code.
21:31:21 <newsham> dfranke: nope. havent seen that.
21:31:24 <dfranke> written in*
21:31:28 <syntaxfree> the sky is falling! sourceforge is down!
21:32:12 <newsham> must not have been hard to rev engineer if it was written in python
21:32:29 <dfranke> no, the rewritten version was in Python.
21:32:44 <dfranke> obviously whatever he reverse engineered was some sort of machine code.
21:32:44 <syntaxfree> Someone should write an Obfuscated Python Code contest, for kicks.
21:33:14 <Pseudonym> I'm not sure I'd trust my posterior to an embedded real-time control system in Python.
21:33:24 <newsham> cant get too horribly obfuscated...
21:33:28 <Pseudonym> Better that than other languages, I guess.
21:33:37 <dfranke> obfuscated anything is easy.  Just write an unlambda interpreter, then have an unlambda program as data.
21:33:45 <newsham> list comprehensions probably your best bet :)
21:34:12 <newsham> all statements must be on separate lines.. so if you want side effects you'll have to put them outside of the obfuscated expression
21:35:25 <newsham> is this obfuscated code?  http://www.thenewsh.com/~newsham/x/machine/mand3.py
21:35:29 <lambdabot> http://tinyurl.com/jtu7z
21:35:39 <dfranke> one of these years I'm going to write an IOCCC entry that is simultaneously a C program, a Whitespace program, and a Brainf*ck program.  The C program will be a Whitespace interpreter and the Whitespace program will be a Brainf*ck interpreter.
21:35:46 <newsham> (plots mandelbrot set, julia set and a moire pattern)
21:36:06 <newsham> one of the ioccc entries was a lisp interpretter that generated itself, written in C
21:36:11 <newsham> (for a subset of lisp)
21:37:07 <dfranke> I wish they'd raise their maximum code size a little bit.  I agree that it should be small, but not as small as it is.
21:37:43 <dfranke> still, my favorite IOCCC entry ever was the 0-byte program that won "smallest quine"
21:37:48 <newsham> http://www.ioccc.org/1989/jar.2.c
21:38:36 <newsham> err, thats not the self-printing one, but its a lisp interpretter
21:40:44 <newsham> hmm.. the self-printing one is 2005 and they didnt put it on their page yet (but they have the .tgz up)
21:42:43 <newsham> http://www.thenewsh.com/~newsham/x/mikeash.c  there we go
21:45:43 <newsham> http://www.thenewsh.com/~newsham/x/mikeash.html
21:45:46 <lambdabot> Title: Best use of parenthesis, http://tinyurl.com/hgjd6
21:46:58 <dfranke> ok, I don't get why compiling GHC has such a bad rap.
21:47:14 <dfranke> I just did it on Debian and it was just configure && make && make install
21:47:48 <tennin> from darcs?
21:47:56 <dfranke> from a daily snapshot.
21:48:42 <dfranke> is the darcs version missing some autoconf-bootstrapped stuff?
21:49:59 <tennin> just remember it being a pain last time
21:50:59 <tennin> actually I was just at the GHC Hackathon, but still haven't built it since I spent the whole first hour trying to get my borrowed-at-the-last-minute Windows laptop configured with Cygwin, etc.
21:51:18 <tennin> s/hour/half hour
21:51:39 <syntaxfree> THERE'S NO SOURCEFORGE! AAAGH!
21:54:13 <tennin> I think last time I tried to build it off the last stable version
21:54:44 <tennin> and a bunch of compatibility files were missing
21:56:35 <dfranke> When Haskell' comes out, how much of it will GHC have already implemented?
21:57:41 <dons> all of it?
21:57:55 <dons> (remember that the idea is to standardise already existing extensions :)
21:58:02 <newsham> ten: install ghc and vim.exe, start working while cygwin installs?
21:58:06 <syntaxfree> @google licensed prelude extensions
21:58:09 <lambdabot> https://trac.prelude-ids.org/changeset/7963
21:59:27 <dfranke> and I assume an -fhaskell-prime option will be added GHC shortly thereafter?
21:59:57 <dfranke> or a -fwhatever-the-hell-the-final-name-for-the-standard-will-be
21:59:58 <dons> I'd imagine haskell-prime would be the default, perhaps?
22:00:10 <dons> as h98 is now
22:00:20 <dons> and we'd get -fhaskell98 to enable the legacy std
22:00:31 <dons> I'm just guessing though
22:01:33 <dfranke> I'm mostly asking about timing.  Will there be a special point-release right away, or will it just show up in 6.8
22:02:25 <dons> I don't think this has been decided yet, dfranke
22:03:02 <syntaxfree> http://haskell.org/haskellwiki/Prelude_extensions
22:03:06 <lambdabot> Title: Prelude extensions - HaskellWiki, http://tinyurl.com/z5ujv
22:03:11 <syntaxfree> just added some Data.Either extensions.
22:05:23 <syntaxfree> I wrote a rather large Haskell tutorial revolving around Data.Either and those extensions, but it's all in portuguese.
22:05:52 <dons> that's good though. have you linked it on the wiki?
22:05:55 <syntaxfree> if anyone cares, anyway:: http://www.navarro.mus.br/diego/blog/2006/09/13/tutorial-dois-pesos-duas-medidas/
22:05:59 <lambdabot> Title: diego navarro Â» Tutorial: dois pesos, duas medidas, http://tinyurl.com/r4bp4
22:06:00 <syntaxfree> no, I haven't.
22:06:13 <int-e> syntaxfree: what's the point of trigger_ ?
22:06:21 <dons> maybe you could link it on the wiki, under 'Tutorials' and tag that it is in Portugese?
22:07:09 <int-e> syntaxfree: oh. ignore that. but why is it called trigger?
22:07:35 <syntaxfree> well, say you are dealing with data on the Right side.
22:07:46 <syntaxfree> My example in the tutorial was, a felon serving time.
22:07:50 <int-e> hmm. trigger f g = Left . either f g
22:08:25 <syntaxfree> So he can be on Good Behaviour (Right) or Bad Behaviour (Left) status. Well-behaved felons get out easier, and are less punished by what they do in prison.
22:09:00 <syntaxfree> But once you attempt to escape, you lose your Good Behaviour status. It's a one-time trigger.
22:09:09 <syntaxfree> Oh well, that was really confusing.
22:09:11 <dons> :)
22:09:48 <syntaxfree> In  game theory, a trigger strategy means that while the other part in a repeated prisoner's dilemma cooperates, you cooperate as well; when the other part defects once, you never cooperate again.
22:09:57 <int-e> you could have mirror :: Either a b -> Either b a
22:09:58 <int-e> :)
22:10:25 <syntaxfree> As opposed to tit-for-tat, for instance, where cooperation can be re-established.
22:10:38 <syntaxfree> int-e: ah, yes. The need didn't arise in my tutorial.
22:10:43 <int-e> syntaxfree: ah, that's the connection. I understand that actually.
22:12:30 <newsham> where do I get tat, and where can I exchange it for tit?
22:13:15 <int-e> ask tweedledum and tweedledee
22:14:11 <syntaxfree> > either "tit" "tat" (Right "newsham")
22:14:12 <lambdabot>  Couldn't match `a -> c' against `[Char]'
22:14:29 <syntaxfree> > either (const "tit") (const "tat") (Right "newsham")
22:14:30 <lambdabot>  "tat"
22:14:36 <syntaxfree> sorry, that's tat for you.
22:15:17 <newsham> 1) tat
22:15:22 <newsham> 2) ???
22:15:24 <newsham> 3) tit
22:15:57 <syntaxfree> maybe there should be an Underpants Gnome Plan data type
22:16:25 <syntaxfree> data UnderpantsPlan = { firstStep :: String, thirdStep :: String}
22:16:52 <syntaxfree> instance (Show a)=>Underpants Plan where
22:17:43 <syntaxfree> show Underpants { f, t } = "1)"++f++"\n 2) ??"++"\n 3)" ++ t ++ "!\n"
22:18:37 <newsham> isnt thirStep a constant "Profit"?
22:19:28 <syntaxfree> true.
22:19:57 <tennin> your usage above shows that there's some use for further parametization though
22:20:38 <newsham> tennin: i think i deviated from the class
22:23:16 <dons> newsham: I'm looking at newSqunch now, I think I can improve it quite a bit
22:23:31 <dibblego> newSqunch?
22:23:34 <tennin> maybe instance (UnderpantsPlan a, UnderpantsPlanStep b, MemeMutationPattern c) => UnderpantsPlanVariant c a b where...
22:26:54 <newsham> dons: cool.  btw, you mentioned something about using "where"?  I couldnt figure out how I could do that and still use the state I created in the IO monad.
22:32:22 <teh_cleric> what's the best place to learn haskell?
22:32:54 <dfranke> teh_cleric: in front of a computer :-)
22:33:43 <teh_cleric> thanks
22:33:47 <teh_cleric> like book
22:33:51 <teh_cleric> or somewhere online
22:33:53 <teh_cleric> yada yada
22:34:29 <dfranke> teh_cleric: Gentle Introduction to Haskell if you're brave (the title is a misnomer).  Yet Another Haskell Tutorial seems to be the popular one.
22:35:01 <teh_cleric> i've been programming for 15 years
22:35:07 <teh_cleric> just not functional languages
22:35:20 <dfranke> teh_cleric: I have you beat by a year, and the Gentle Introduction was still scary.
22:35:37 <teh_cleric> ahh
22:35:38 <teh_cleric> ok
22:35:41 <teh_cleric> sounds good :)
22:35:45 <teh_cleric> that a book
22:35:51 <dfranke> online tutorial
22:35:51 <teh_cleric> or website?
22:35:56 <dfranke> http://www.haskell.org/tutorial
22:35:58 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
22:37:01 <dottedmag> teh_cleric: http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell is also good one
22:37:05 <lambdabot> Title: Hitchhikers guide to Haskell - HaskellWiki, http://tinyurl.com/mg7d9
22:37:28 <teh_cleric> ahh ok
22:37:31 <teh_cleric> good deal
22:39:42 <syntaxfree> there was a Haskell tutorial that was all in the form of questions and answers.
22:39:45 <syntaxfree> in two columns.
22:39:49 <newsham> i like the chalmers haskell class slide deck and the dozen easy lessons.
22:39:59 <newsham> and the haskell.org mini intro
22:40:07 <tennin> the Gentle Intro. is intended for people with some experience in other functionally-oriented languages
22:40:46 <tennin> it's mostly gentle if that describes you
22:41:33 <syntaxfree> YAHT is great, but it's book-length.
22:41:38 <syntaxfree> Still, it's the gentlesto ne.
22:41:47 <newsham> (haskell in 5 steps, programming in haskell (course), two dozen short lessons)
22:42:17 <dfranke> Still gentler than the Haskell 98 spec though :-)
22:42:35 <dfranke> I had no problem learning Scheme from just R5RS, and that was my first functional language.
22:42:54 <newsham> one thing that intros never talk about is where to get more info (ie. hoogle, ghc library reference, etc).
22:43:08 <newsham> even in other languages (ie. python global module index, perl cpan, etc..)
22:43:12 <newsham> tis a shame..
22:43:19 <newsham> thats usually what takes me the longest time to learn
22:43:46 <tennin> hmm
22:44:38 <tennin> the only trouble I had with the Gentle Intro. was with the chapter on monads
22:44:58 <newsham> thats the first intro i read, it was horrible for a first intro :)
22:44:59 <teh_cleric> so sounds like the general theory is
22:45:04 <teh_cleric> GITH
22:45:08 <teh_cleric> but be warned
22:45:08 <newsham> dont read that one until you read all the others :)
22:45:12 <teh_cleric> it's a bitch to read
22:45:15 <tennin> was completely baffled by its presentation of them, had to supplement it with the Nomaware tutorial
22:46:03 <tennin> but other than that it wasn't hard going, thanks to my Lisp/Scheme experience
22:46:51 <newsham> i thikn most monad intros take the wrong approach.  you shouldnt introduce monads, you should tell people how to use IO monad (and not tell them its a monad), then tell people how to use Maybe, then tell people how to use list, then tell people how to use State.
22:47:03 <newsham> and after all that "hey look, they all share this Monad stuff in common"
22:47:25 <newsham> you dont have to know a thing about monads to use the IO monad effectively
22:50:25 <tennin> GITH does introduce IO first, and does it fairly smoothly
22:50:45 <tennin> but when I got to its presentation of State it was like crashing into a wall
22:51:10 <tennin> very difficult if you're used to thinking in types
22:51:18 <tennin> s/used/not used/
22:52:24 <weitzman> I have a bit of experience with simple type theory, and it still wasn't easy to get monads.
22:53:22 <syntaxfree> uhh. Are user-defined infix data constructors allowed?
22:53:31 <tennin> yes
22:53:46 <syntaxfree> cool.
22:53:57 * syntaxfree begins to think of a way to implement sigils ;)
22:54:17 <tennin> I think they must start with :
23:24:20 <dfranke> hmm, the StarAndRing and Text examples in gtk2hs/demo/cairo exit immediately when I run them.  Should this be cause for concern?
23:24:30 <dfranke> Drawing works fine
23:25:13 <dfranke> and in concurrent, the progress bar doesn't move.
