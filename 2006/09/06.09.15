00:03:25 <dons> ?yow!!
00:03:26 <lambdabot> I feel like I am sharing a ``CORN-DOG'' with NIKITA KHRUSCHEV ...
00:05:55 <vincenz> hiya dons
00:06:01 <dfranke> ?hoogle threadDelay
00:06:02 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
00:08:28 <dons> hey vincenz
00:08:38 <vincenz> dons: I know too many pls :/
00:08:46 <vincenz> dons: don't know which one to use for a specific project
00:12:11 <dons> really? you can't choose?
00:12:16 <dons> what kind of project?
00:20:28 <vincenz> several are touching my fancy
00:20:38 <vincenz> one would be the thing mentioned on my blog
00:20:53 <vincenz> http://notvincenz.blogspot.com/2006/09/organizing-information.html
00:20:57 <lambdabot> Title: lambda.oasis: Organizing information, http://tinyurl.com/e5hv4
00:23:19 <boegel> vincenz, I have a paperdb thingie set up in php using mysql
00:23:32 <boegel> it might not be exactly what you're looking for, but I find it damn handy
00:23:35 <boegel> code sucks though :)
00:25:14 <vincenz> boegel: sounds interesting
00:25:19 <vincenz> peopel have mentioned various tools
00:25:24 <vincenz> jabref looks ok too (java app)
00:25:42 <vincenz> the central reqruirement, besides getting most of the bibtex info in in a searchable manner
00:25:48 <vincenz> is a hierarchical tag organization
00:25:52 <vincenz> but with crosstagging on items
00:28:22 <vincenz> (basically like a normal tagging system, but having the ability to categorize the tags)
00:31:40 <boegel> vincenz: http://trappist.elis.ugent.be/~kehoste/paperdb_screenshot.png
00:31:44 <lambdabot> http://tinyurl.com/py49x
00:31:59 <boegel> it doesn't have tons of features, both more can be added easily
00:32:10 <vincenz> macuser!
00:32:16 <boegel> *hehe*
00:32:32 * vincenz wants a mac
00:32:38 <boegel> I added rating and read-priority stuff just yesterday
00:32:48 <vincenz> boegel: people mentioned citeulike
00:32:56 <vincenz> the issue with that is that you can't publicize everythin
00:33:08 <boegel> publicize?
00:33:13 <vincenz> boegel: does it also reorganize the files?
00:33:16 <vincenz> boegel: make public
00:33:38 <boegel> vincenz: the files are in one big directory now, but using this system, there's no need to organize them :)
00:33:46 <vincenz> true :)
00:33:49 <boegel> adding search support allows you to search on various things
00:33:59 <vincenz> perhaps I could make a different app
00:34:15 <vincenz> cause I want some more gui-ical (adjective for guiness?) featurs
00:34:18 <vincenz> features
00:34:19 <boegel> also, I added sort support: sort on rating, sort on read-priority, sort on label, author(s), title, ...
00:34:42 <boegel> well, more can be added without much trouble :)
00:34:43 <vincenz> nice :)
00:34:49 <boegel> anyway, I quite like it
00:34:50 <vincenz> someone suggested to me to use ruby
00:35:00 <vincenz> and make a RoR site, cause they have such nice ajax integration
00:35:22 <vincenz> For instance, I believe that research ideas can be orthogonalized (you've met my advisor, right>)
00:35:53 <vincenz> however papers often treat multiple topics (hence why a hierarchical directory structure doesnt work, the concepts are hierarchical the papers hwoever are multitagged)
00:36:07 <vincenz> so it'd be nice to have a visual representation of the size of the tags and how they relate
00:36:25 <vincenz> so you know when something should be split up, reorganized, etc :)
00:37:21 <vincenz> however I could reuse your db format :)
00:37:59 <vincenz> boegel: what about papers you download but haven't read yet?
00:38:15 <vincenz> that's another main issue
00:39:36 <vincenz> boegel: feel like sharing the code so I can take a look at it?
00:39:45 * vincenz doesn't know php but could probably deconstruct what it does
00:44:10 <boegel> vincenz: then I just mark them as unread :)
00:44:35 <dcoutts__> dfranke: StarAndRing and Text write out .png files, so yes they exit immediately. Perhaps they should write a message to say that they wrote the .png file :-)
00:44:49 <boegel> vincenz: the code is pretty crappy... if you would be interested in it, I could throw a sample online some time soon
00:44:59 <boegel> i.e. when I come back from Seattle
00:45:05 <dcoutts__> dfranke: as for concurrent, what platform are you using?
00:46:25 <vincenz> boegel: sure that'd be great, just to have an idea of the concepts behind, like database layout, etc...
00:46:36 <vincenz> boegel: I'd prolly rewrite it in ruby, but using the concepts would be useful
00:50:16 <vincenz> dons: anyway my comment was general, I like haskell for algorithms, but for other stuff, I prefer a dynamic language
00:50:43 <vincenz> dons: and I can't choose between: ruby,scheme,lua,io, (python?)
00:59:35 <dcoutts__> ah, Oleg proves in 6 lines that the Haskell type system (with undecidable instances) is turing complete
01:00:04 <sieni> oleg <3
01:07:09 <ibid> xerox: ping?
01:07:13 <vincenz> dcoutts__: link?
01:07:32 <dcoutts__> vincenz: today, haskell mailing list
01:07:51 * vincenz nods
01:08:00 * vincenz wonders if it's possible to rss-feed an ML to his google personalized homepage
01:08:05 <ibid> xerox: your blog is generating a lot of timeouts for planet. what gives?
01:08:58 <vincenz> dcoutts__: which one?
01:09:06 <dcoutts__> part I and II
01:09:28 <vincenz> hardly 6 lines!
01:09:56 <dcoutts__> it's all done in part I
01:11:09 <vincenz> btw, I unsubscribed from the wto MLs due to volume
01:11:10 <Syzygy-_> ibid: Is planet using the description or contents tag for the blog texts?
01:11:21 <vincenz> but what's the main diff between haskell and haskell-cafe, I mean thy seem to flow into one another
01:11:31 <vincenz> s/thy/they
01:12:27 <dons> ?seen xerox
01:12:27 <lambdabot> xerox is in #haskell.it, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 7h 46m 20s ago.
01:13:25 <yip> good morning haskell
01:14:07 <vincenz> Hi yip !
01:14:11 <vincenz> dons: pm!
01:16:14 <yip> anyone happens to know about the current status of gtk2hs and ghc 6.6?
01:16:32 <dcoutts__> yip: you asked me that yesterday :-)
01:16:51 <dcoutts__> and the answer was, yes I do know
01:17:28 <dcoutts__> and I'll tell you when it's ready
01:17:54 <yip> ok cool thanks, i won't leave this channel =]
01:18:06 * yip patiently awaits...
01:18:18 <ValarQ> :)
01:20:49 <ibid> Syzygy-: let me check
01:22:30 <ibid> dcoutts__: if i read this right, content
01:22:33 <ibid> gah
01:22:36 <ibid> Syzygy-: ^
01:22:43 <dcoutts__> :-)
01:23:47 <ibid> d is right next to s :)
01:26:21 <Syzygy-> ibid: That's weird. I still only get the extract, and when checking what my feed hands out, the content contains the entire articles...
01:27:09 <ibid> let me check
01:29:06 <ibid> Syzygy-: your feed has been noticed as updated on     updated         2006-09-14T16:29:54+00:00
01:29:11 <ibid> Syzygy-: is that right?
01:29:36 <ibid> or rather, that's the modification time your server gives
01:29:43 <ibid> according to planet's cache
01:29:58 <Syzygy-> Yeah, that sounds like around the last time I fiddled with things.
01:30:07 <Syzygy-> Only, that probably is my last post, not my last tweaks.
01:30:36 <Syzygy-> Is it feasible to flush the cache for my site?
01:31:31 <ibid> i think so
01:32:43 * therp stares at the reset/shift continuation monad without no clue.
01:33:22 <ibid> done. i'll go to lunch now, bbl
01:33:42 <therp> are there any mental tricks to understanding monads? I have found that they share a common name, and common laws, however I had to mentally restart from scratch whenever I encounter a new monad
01:34:49 <Syzygy-> therp: Use their categorical definitions?
01:36:11 <therp> syzygy: how would I use a categorical definition of a state monad? I mean I haven't tried because I thought that the analogy doesn't extend that far
01:37:44 <d04mse> what does this mean : Non-exhaustive pa tterns in function matchh
01:39:49 <Thomas2_> if you have "f 0 = 1" "f 1 = 2", and then say "f 2"
01:40:28 <Thomas2_> something I was meaning to do a while back was a dictionary somewhere on the web of explanations of common errors (particularly compiler errors)
01:40:57 <Thomas2_> and some tool which makes it easy to query
01:46:25 <d04mse> thomas2_:Im not shore if i get it
01:47:07 <Syzygy-> d04mse: If you haven't defined the function for the actual case you're using, you'll get that error, since the pattern matching methods fail.
01:47:39 <weitzman> Oh dear oh dear. I'm still awake
01:48:25 <Thomas2_> d04mse: another example. if you've defined f :: [Int] -> Int, with "f [x, y] = x + y" and "f [x] = x", and then you ask what "f []" is, none of your patterns cover that
01:48:31 <weitzman> A person shouldn't be reading the source code of lambdabot at near 5am
01:48:34 <weitzman> I'm going to bed
01:48:35 <Thomas2_> so you're probably missing a pattern in a definition of something
01:50:32 <basvandijk> Does anybody know who develops the Haskell Gentoo ebuilds?
02:20:13 <d04mse> dropFunc = drop 6 "banana" = "" , then you want to dropWhile (dropFunc /=) anotherString gives an error... how can i handle this?
02:21:58 <d04mse> because what i want is the the rest of the string when this happens
02:28:29 <therp> basvandijk: look at the ChangeLog of the respective portage directory - it usually lists developer names
02:28:58 <dcoutts__> he already found us in #gentoo-haskell
02:29:31 <therp> there is a #gentoo-haskell? wow.
02:43:21 <dcoutts__> therp: there has been for ages :-)
02:43:58 * dcoutts__ thinks gentoo has the best haskell support of any OS/distro
02:45:33 <dons> I agree
02:45:40 <dons> and I don't even use gentoo!
02:45:44 <dcoutts__> heh heh
02:47:50 <lilboy> except for haskell-mode maybe :(
02:48:04 <dcoutts__> oh yeah, true
02:48:14 <dcoutts__> I don't use emacs, little motivation
02:48:19 <dcoutts__> feel free to send in an ebuild
02:48:38 <dcoutts__> our ebuild testing overlay is hosted in darcs so it's easy to contribute
02:48:47 * therp uses xemacs and the haskell-mode installed quite ok from the net
02:52:20 <dcoutts__> therp: oh apparantly there is a haskell-mode ebuild
02:52:36 <dcoutts__> it's maintained by the gentoo emacs people
02:52:59 <dcoutts__> app-(x)emacs/haskell-mode
03:04:25 <d04mse> how do you make an Char to sting?
03:05:40 <bourbaki> moin
03:06:04 <ProfTeggy> d04mse:  'x':[] == ['x'] == "x"
03:06:44 <ProfTeggy> On the type level: String = [Char]
03:07:35 <d04mse> thanls
03:15:11 <yip> > let c = 'x' in [c]
03:15:12 <lambdabot>  "x"
03:15:37 <dons> > let box = (:[]) in box 'z' -- d04mse
03:15:38 <lambdabot>  "z"
03:18:33 * ibid just browsed through the r6rs draft
03:18:38 <ibid> interesting stuff there
03:21:46 <bourbaki> dons did you have a look at the mails?
03:25:10 <gmh33__> (dons never sleeps I think..)
03:29:20 <dblhelix> @time dons
03:29:22 <lambdabot> Local time for dons is Fri Sep 15 20:28:59 2006
03:31:12 * gds suspects that despite living in Oz, dons works on GMT...
03:31:40 <SamB> Oz doesn't exist, silly! it is an imaginary place!
03:37:01 <gds> :)
03:54:53 <nomeata> @time me
03:54:55 <lambdabot> Local time for me is Fri Sep 15 22:54:14
03:54:58 <nomeata> @time nomeata
03:55:00 <lambdabot> Local time for nomeata is Fri Sep 15 10:54:37
03:55:10 <nomeata> @time lambdabot
03:57:28 <yaarg> lambdabot exists outside time and space?
03:58:54 <SamB> lambdabot doesn't properly implement CTCP ;-)
03:59:25 <int-e> it's not unproper not to implement CTCP.
03:59:44 <yaarg> :)
04:02:36 <SamB> yes, but the way lambdabot implements it is improper ;-)
04:08:32 <wkh> i'm writing some code where i extract command line parameters with getArgs in a "do" thingie. on the next line i convert the first parameter to a number with read like: let val = read (args !! 0)
04:08:42 <wkh> that works. if i do val <- read (args !! 0) it doesn't. why?
04:09:25 <mikael> that would work if read had the type Read a => String -> IO a, I think
04:09:44 <xs> val <- blah is syntatic sugar for blah >>= \val -> ...
04:10:26 <SamB> wkh: <- is for actions
04:11:22 <wkh> args <- getArgs is an action, read (args !! 0) isn't?
04:11:29 <SamB> uh huh
04:11:42 <SamB> well, getArgs is the action really...
04:11:57 <SamB> args is just a variable you are putting the result in...
04:12:21 <wkh> oh, yeah, right
04:13:37 <wkh> in the tutorial i'm working through, converting the arguments to numbers with the "let" construct wasn't suggested
04:13:41 <Syzygy-> ibid++
04:13:49 <Syzygy-> Thanks for getting the feed up and running.
04:18:28 <fasta> Is there a standard function for splitting a list of size n which is divisible by an integer k into k lists of size n/k? Thus f [1,2,3,4] 2 => [[1,2],[3,4]]?
04:20:38 <musasabi> I don't think so.
04:20:56 <musasabi> easy to write in an recursive manner.
04:21:35 <musasabi> > let f k [] = []; f k xs = take k xs : f k (drop k xs) in f 4 [1..20]
04:21:36 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
04:22:15 <Syzygy-> > let f k [] = []; f k xs = take k xs : f k (drop k xs) in f 4 [1..21]
04:22:16 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20],[21]]
04:24:47 <ndm> @seen dons
04:24:47 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 9m 10s ago.
04:24:54 <ndm> @wiki Keywords
04:24:54 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
04:26:43 <ndm> @tell dons The Keywords wiki page has issues - i can't hyperlink to case and of, because they have no indidivudal anchors - any way to wiki-syntax fix this?
04:26:43 <lambdabot> Consider it noted.
04:28:16 <ndm> @tell dons Also ... comes out really badly in teh syntax hilighting - who do we prod about the wiki page to get that fixed?
04:28:16 <lambdabot> Consider it noted.
04:29:54 <ProfTeggy> takeWhile (not . null) $ map (take k) $ iterate (drop k)
04:34:51 <fasta> Yes, I know it was easy to write. I did write the recursive version already.
04:36:15 <fasta> ProfTeggy: heh, that's nice
04:38:10 <nomeata> musasabi:   takeWhile (not . null) . unfoldr (Just . splitAt 2)
04:38:24 <nomeata> > let f n =   takeWhile (not . null) . unfoldr (Just . splitAt n)  in f 2 [1..10]
04:38:25 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
04:38:30 <nomeata> > let f n =   takeWhile (not . null) . unfoldr (Just . splitAt n)  in f 2 [1..11]
04:38:31 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11]]
04:39:33 * musasabi does not like unfoldr
04:40:50 <nomeata> @type splitAt
04:40:50 <ProfTeggy> nomeata: nice, nice
04:40:51 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:41:04 <nomeata> ProfTeggy: not mine: http://haskell.org/haskellwiki/Blow_your_mind
04:41:06 <lambdabot> Title: Blow your mind - HaskellWiki
04:41:18 <ProfTeggy> Never seen that page, thanks for the pointer
04:41:28 <nomeata> @type unfoldr
04:41:29 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:44:57 <nomeata> @pl reverse $ List.unfoldr (\n -> if n==0 then Nothing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n `div` 10))
04:44:58 <lambdabot> reverse (List . unfoldr (ap (flip if' Nothing . (0 ==)) (Just . ap ((,) . (Char .) . chr . (Char . ord '0' +) . (`mod` 10)) (`div` 10))))
04:45:49 <nomeata> > let f =  reverse $ List.unfoldr (\n -> if n==0 then Nothing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n `div` 10)) in f (2^23)
04:45:50 <lambdabot>    Expecting a function type, but found `a'
04:45:50 <lambdabot>    Expected type: [a]
04:45:50 <lambdabot>    ...
04:46:21 <nomeata> > let f n =  reverse $ List.unfoldr (\n -> if n==0 then Nothing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n `div` 10)) n in f (2^23)
04:46:22 <lambdabot>  "8388608"
04:46:34 <nomeata> > let f n =  reverse $ List.unfoldr (\n -> if n==0 then Nothing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n `div` 10)) n in f (-10)
04:46:37 <lambdabot> Terminated
04:46:43 <nomeata> > let f n =  reverse $ List.unfoldr (\n -> if n==0 then Nothing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n `div` 10)) n in f 0
04:46:44 <lambdabot>  ""
04:48:52 <therp> I'm not sure what to do with the recent channel content, if I would like to read it or if "public evaluation" is a good idea
04:53:01 <deadbeef> hing else Just (Char.chr(Char.ord('0')+(n  `mod` 10)), n
04:53:05 <deadbeef> ops sorry
04:53:46 <araujo> morning!
04:53:53 <deadbeef> hi araujo
04:55:26 <fasta> therp: you could modify your IRC client to ignore everything starting with "> ". I think there's some peer pressure to not evaluate every single bit of code in the public channel.
04:56:16 <therp> fasta: thanks, my statement was aiming at providing that peer pressure in a gental way :)
04:57:50 <nomeata> well, the point of public evaluation is the fishing for comments, is it? I like when people evalute stuff here, it often very interesting
04:58:51 <fasta> nomeata: sometimes it is useful, sometimes it's just ego stroking.
04:59:03 <musasabi> and the uninteresting bits can be done via /msg lambdabot
05:00:23 <deadbeef> guys, it's a bit OT
05:00:28 <deadbeef> but i've a problem
05:00:34 <deadbeef> # svn co https://svn.openwrt.org/openwrt/branches/buildroot-ng      [13:52]
05:00:34 <deadbeef> svn: PROPFIND request failed on '/openwrt/branches/buildroot-ng'
05:00:34 <deadbeef> svn: PROPFIND of '/openwrt/branches/buildroot-ng': SSL negotiation failed: SSL disabled due to library version mismatch (https://svn.openwrt.org)
05:00:36 <lambdabot> http://tinyurl.com/k97qd
05:00:38 <deadbeef> any idea ?
05:00:48 <deadbeef> google doesn't say anything about that
05:01:20 <Syzygy-> deadbeef: Can you use subversion against anything with SSL?
05:01:41 <Syzygy-> Otherwise, I'd suggest you make sure your current subversion is built against your current version of SSL.
05:01:58 <Syzygy-> This may require you to reinstall one or both.
05:02:01 <profmakx> why is it https anyways -.-
05:02:03 <deadbeef> i've just built svncommand with my current openssl
05:04:30 <mikael> > let f = (map(map fst).).(.flip zip[0..]).groupBy.((uncurry(==).).).(.(,)).(.).(\f->((f.fst)&&&(f.snd))).(.snd).flip div in f 3 "abcdefghij"
05:04:31 <lambdabot>  ["abc","def","ghi","j"]
05:04:33 <mikael> :~(
05:04:57 <Syzygy-> Yikes!
05:05:57 <nomeata> mikael: what program produced that :-)
05:06:13 <mikael> you know about @pl?
05:06:27 <mikael> that, and some tinkering :-)
05:50:30 * vincenz tsks
06:18:58 <nomeata> Is there a good reason why "if" was implemented as a syntactical structure, and not just a function "if :: Bool -> t -> t -> t", besides the better readability?#
06:19:33 <sieni> nomeata: no
06:20:17 <flux__> less scary?
06:21:14 <nomeata> what about "if" in a "do" construct, would such a function work just as well?
06:21:25 <gds> @hoogle Bool -> t -> t -> t
06:21:27 <lambdabot> No matches, try a more general search
06:21:55 <nomeata> @hoogle Bool ->
06:21:56 <lambdabot> Control.Exception.assert :: Bool -> a -> a
06:21:57 <lambdabot> Foreign.Marshal.Utils.fromBool :: Num a => Bool -> a
06:21:57 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
06:22:22 <araujo> it might be because 'if' is kind of a core built-in structure.
06:22:44 <gds> is if more core than pattern mathching?
06:22:57 <gds> If not, surely it could be implemented in terms of PM..?
06:23:09 <shapr> @yow !
06:23:10 <lambdabot> Do you have exactly what I want in a plaid poindexter bar bat??
06:23:13 <araujo> probably efficiency plays an important role.
06:23:24 <araujo> gds, what if they both are?
06:23:45 <araujo> Similar to what the scheme language does with the so called core-operator iirc
06:24:25 <araujo> I am just *guessing* , probably asking on the haskell-cafe mailing list would bring a more accurate reason
06:24:36 <gds> "both are" core? I guess I was suggesting that if you have pattern matched cases you could implement if using that and possibly wouldn't "need" it to be core, for some value of "need" ;)
06:24:55 <araujo> read what i said about 'efficiency' please.
06:24:55 <gds> But yeah, I can imagine there being an efficiency argument...
06:25:19 <gds> and I can't think of a good argument to have if "not core" at the moment...
06:25:33 <gds> :)
06:26:34 * araujo should be leaving to univ now
06:26:38 <ventonegro> the DiffArray docs says they have an immutable array interface
06:26:59 <ventonegro> so why does newDiffArray put the array in the IO monad?
06:27:46 <araujo> In any case, you are always free to implement your own 'if-like' function extended (for example supporting multiple conditions?)
06:27:57 <araujo> Or monadic code
06:28:22 <waern> hmm
06:28:50 <waern> why does GHC complain about Cabal being a hidden package when it isn't?
06:29:03 <araujo> ok, now off later
06:29:04 <waern> is there something special about Cabal?
06:32:19 <waern> hi xerox, I'm trying to import Distribution.PackageDescription, but I get complaints about the Cabal package being hidden
06:32:26 <waern> but it's not!
06:32:31 <waern> xerox, ever had this problem? :)
06:33:15 <xerox> Does |ghc-pkg describe Cabal| show that the module is exported?
06:33:18 <waern> yep
06:33:50 <xerox> I am not sure, did you try --make or -package Cabal?
06:34:19 <waern> oh, maybe I forgot to add Cabal to my cabal file :)
06:34:39 <waern> but that error message is a bit strange in that case...
06:35:02 <d04mse> how do you test if an argument is a list, char ...
06:35:03 <d04mse> ?
06:35:05 <xerox> Package issues are always a bit misterious... I think :)
06:35:31 <xerox> d04mse: by making use of the awesome powers of pattern matching!
06:36:28 <d04mse> what is pattern matching? iam not a pro... newbiw
06:36:31 <waern> xerox, yep.. the problem was that I had forgot to add the dependency on Cabal to my cabal-file :)
06:36:40 <xerox> waern: alright :)
06:37:00 <xerox> d04mse: check out this page:
06:37:05 <xerox> @oldwiki HaskellDemo
06:37:05 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
06:37:58 <xerox> There's a section devoted to pattern matching if I remember correctly.
06:39:07 <d04mse> [1,3..5] ... what is that for kind of type to pattern match?
06:39:34 <xerox> [1,3,5] = 1:3:5:[]
06:40:39 <xerox> I.e. cons, written (:) is the constructor for lists. Hence the pattern (x:xs) will match x for the head of the list and xs for the tail. Also, [] matches the empty list.
06:40:57 * edwardk waves hello.
06:41:04 * xerox waves back
06:41:57 <d04mse> look.. i have different of argument types to be handled by the same function... called match.... match 'x' "2*x+3" "2*7+3" = "7" , and match 2 [1,3..5] [1,3..5] = "" .. you know what i mean?
06:42:37 <edwardk> ok
06:42:43 <xerox> I think I see.
06:43:33 <xerox> match :: (Eq a) => a -> [a] -> [a] -> [a]
06:43:37 <edwardk> guess you could make them all members of a typeclass, and use that to disassemble your arguments. doesn't sound pretty though.
06:43:55 <xerox> Eq is enough I think.
06:44:22 <xerox> @docs Data.List
06:44:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:44:44 <edwardk> ah ok, you aren't looking for doing actual computation, just skimming the list
06:45:10 <edwardk> looked like a fledgeling computer algebra system for a sec. ;)
06:45:21 <d04mse> iam doing chatterbot
06:46:09 <edwardk> for some reason that phrasing made me want to ask if your friends knew, or if you were using protection ;)
06:46:31 <d04mse> ??
06:46:37 <edwardk> nevermind
06:46:41 <xerox> > let match x xs ys = map (ys !!) (elemIndices x xs) in match 'x' "2*x+3" "2*7+3"
06:46:43 <lambdabot>  "7"
06:47:12 <xerox> > let match x xs ys = map (ys !!) (elemIndices x xs) in match 2 [1,3..5] [1,3..5]
06:47:13 <lambdabot>  []
06:47:50 <xerox> @quote Cale
06:47:51 <lambdabot>  They're using continental drift as a means of communication.
06:47:54 <xerox> @quote Cale
06:47:54 <lambdabot>  The perfect programming language is mathematics, but that only runs on mathematicians.
06:47:57 <xerox> @quote Cale
06:47:58 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
06:48:03 <xerox> ?type (!!)
06:48:04 <lambdabot> forall a. [a] -> Int -> a
06:48:07 <xerox> OK? :)
06:50:10 <d04mse> let match x xs ys = map (ys !!) (elemIndices x xs)
06:50:15 <d04mse> > let match x xs ys = map (ys !!) (elemIndices x xs)
06:50:16 <lambdabot>  Parse error
06:50:38 <edwardk> you need to let ... in something.
06:52:36 <d04mse> i point is to just by giving the command (for example)  : match 'x' "baxa" "bajsa" = "js" , and so on
06:52:51 <d04mse> how can i implement that in the code with let and alla... hehe
06:53:13 <xerox> > let match x xs ys = map (ys !!) (elemIndices x xs) in match 'x' "baxa" "bajsa"
06:53:14 <lambdabot>  "j"
06:53:19 <edwardk> well,now its gotten more complicated ;)
06:54:07 <ibid> xerox: did you see my note in the scrollback?
06:54:12 <d04mse> hehe... yeah... but thats ok... i just need to know how to implement it in my file... to make that work... what your giving me is the command for ghci... right?
06:54:21 <xerox> d04mse: here you can compute a pure expression expr saying "> expr". |let ... in ...| is an expression.
06:54:42 <xerox> ibid: yep. Hope is quite resource-consuming here, and I don't know why yet.
06:54:47 <ibid> xerox: your blog is timing out for planet, and has been doing so consistently for some time now
06:54:52 <ibid> xerox: ah, ok
06:55:04 <edwardk> d04mse: to write the function match in your file that xerox gave you'd skip the 'let' and just say 'match x xs ys = ...'
06:55:07 <xerox> ibid: take it off, I'll find some solution, and get back to you.
06:55:15 <ibid> ok
06:55:19 <xerox> ibid: thank you.
06:55:28 <ibid> (no other problem but i get a mail from cron every hour because of this :)
06:55:58 <xerox> ibid: ...and my computer slows down regularly, so I want to find some other place to host this thing :)
06:56:11 <ibid> commented out now, ping me when it's better
06:56:32 <xerox> Will do.
06:57:42 <d04mse> ook... now i understand... but elemIndices is in what package ? the standard lib+
06:57:43 <d04mse> ?
06:57:52 <xerox> Again lambdabot can help you:
06:57:56 <xerox> @index elemIndices
06:57:57 <lambdabot> Data.List
06:58:02 <xerox> @docs Data.List
06:58:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:58:16 <xerox> And she even knows the source URL if you want that:
06:58:23 <xerox> @fptools Data.List
06:58:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:58:32 <d04mse> because compiling now gives us variable not in scope for elemIndices
06:59:15 <xerox> The result of "@index <function>" is the name of the modules in which it is defined. So you need to import one of them. In this case it's just |import Data.List|.
06:59:56 <d04mse> @index Maybe
06:59:57 <lambdabot> Data.Maybe, Prelude
07:00:15 <d04mse> @docs Data.Maybe
07:00:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
07:01:21 * xerox brews some tea...
07:18:52 <Thomas2_> what always struck me as remarkable about Data.Array is that there's no function constructor
07:19:12 <edwardk> that you pass a function and it translates indexes to value through the function?
07:19:23 <Thomas2_> yeah
07:19:30 <Thomas2_> give it a function that defines the values
07:19:45 <edwardk> you can make it by building an appropriate list, it probably won't actually get physically constructed anyways coz of fusion
07:19:56 <Thomas2_> yeah, I know
07:20:08 <Thomas2_> but it would be nice to have it
07:20:12 <edwardk> *nods*
07:21:06 <Thomas2_> wait, you can get it with the functor instance
07:21:15 <edwardk> oh?
07:21:32 <Thomas2_> nm
07:21:33 <Thomas2_> i lie
07:21:50 <edwardk> let funArray (l,u) f = map f [l..u]
07:21:55 <edwardk> er
07:22:09 <Thomas2_> yeah, but think about how inefficient that is in general
07:22:23 <edwardk> let funArray b@(l,u) f = listArray b $ map f [l..u]
07:22:28 <Thomas2_> for a big range, we have to scan the actual range pushing things in the array before we can extract any element
07:22:53 <edwardk> not so bad. fusion on the args going into the map fusion on the args going from the map to the list.
07:23:06 <edwardk> so actual list need be built
07:23:11 <edwardk> er so no
07:23:32 <edwardk> er even better
07:23:36 <Thomas2_> arh, you mean there are rewrite rules which break this down to what it should be?
07:23:50 <edwardk> let funArray b f = listArray b $ map f $ range b
07:23:52 <edwardk> yeah
07:24:02 <Thomas2_> still kinda retarded
07:24:28 <edwardk> look up deforestation, foldr/build fusion, etc.
07:24:35 <Thomas2_> i'd rather not?
07:24:43 <edwardk> most uses of lists are a lot cheaper than they at first appear.
07:24:56 <Thomas2_> in principle
07:25:02 <dons> the real way to do arrays is in the ndp/dph branch, I reckon :)
07:25:02 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:25:05 <dons> stream fusion for all
07:25:15 <edwardk> dons: when will that be ready for prime time?
07:25:35 <Thomas2_> I'd have to look it up properly, but I suspect that appealing to cuteness in the background is a fragile solution to the problem of writing the wrong api to start with
07:25:37 * edwardk <<3 most of the dph ideas.
07:25:47 <dons> its geting closer. rl had it running on a 40 cpu sun box, in parallel :)
07:25:56 <edwardk> nice
07:26:22 <dons> the fusion stuff is done, now its the parallelisation. it'd be just about usable now for flat arrays on a single cpu
07:26:23 <edwardk> how bad is the multi-cpu garbage collection starting to bite you in the ass?
07:26:35 <dons> haven't heard rl complain yet
07:26:39 <edwardk> hrmm
07:26:51 <edwardk> interesting. thats usually the bottleneck for this kind of system
07:26:51 <dons> when you've got 300G of ram, maybe you don't notice such things?
07:27:02 <edwardk> for a while anyways =)
07:27:13 <edwardk> then its just that the problem has had time to exascerbate itself ;)
07:27:36 <Thomas2_> my real complaint here boils down to the fact that we formalise this array with a function anyway, and I'm going to have to write all of the rewrite rules it takes to boil it back to what it should have been to start with manually
07:28:00 <edwardk> thomas: yeah, but the rewrite rules apply to lots of things. almost any time someone maps, etc.
07:30:04 <edwardk> the short cut fusion technique is actually a lot better than the linear type techniques I've been working on lately when it applies, coz they never have to build up the structure in the first place. I just ensure that I can update it in place.
07:31:35 <dons> yeah, similar things fall out of the stream fusible bytestrings too, where we have linearity guarantees, and can mutate away, without needing Clean :)
07:31:45 <edwardk> *nods*
07:32:02 <dons> which is maybe under-apprecited
07:32:05 <edwardk> yeah
07:32:32 <edwardk> linearity, uniqueness, relevance, etc are all useful properties they are just hard to take advantage of in Haskell.
07:33:38 <dons> yeah, that's true. its nice when it appears, but that's not often.
07:33:40 <edwardk> Whenever you want to know the properties of a language, always ask what is hard to do. In haskell those restrictions are mostly on reasoning about storage or usage patterns.
07:33:56 <dons> yep
07:34:08 <edwardk> Of course, my way might be overkill
07:34:17 <edwardk> ski and I worked out the signature for (+) in my toy calculus
07:34:20 <edwardk> it hurt the head.
07:37:41 <edwardk> hrmm. is there any form of general catamorphism/anamorphism fusion in use out there?
07:38:52 <dons> in use, not they i know of. the ndp stream stuff comes close
07:38:53 <edwardk> that just matches up the maps from the bannanas and lenses?
07:39:00 <edwardk> er bananas
07:39:04 <edwardk> *nods*
07:39:22 <edwardk> coz in general cata/ana fusion should work perfectly in the absence of seq right?
07:39:42 <dons> yep, i think so. seq certainly gums up the works a bit
07:39:46 <edwardk> hrmm
07:39:58 <edwardk> ok, with a type system with relevant types, what purpose would seq serve?
07:40:09 <edwardk> once I have relevance giving me strictness information
07:40:20 <edwardk> seq would let me express something at a 'meta' level about strictness
07:40:31 <dons> yeah, possibly
07:40:33 <edwardk> but it has other bad properties
07:40:40 <dcoutts__> for adding extra strictness
07:40:40 <edwardk> that make it somewhat undesirable
07:40:43 <edwardk> yeah
07:40:52 <edwardk> just trying to see if it could be avoided =)
07:40:59 <dcoutts__> or scheduling evaluation for minimal space use
07:41:07 <dcoutts__> or maximal speed
07:41:21 <xerox> Thomas2_: what about using fromList?
07:41:21 <edwardk> either by adding another level to the lattice of substructural types that gives strict but possibly irrelevant types
07:41:27 <edwardk> then I could use that to reason about seq.
07:41:31 <vincenz> @localtime dons
07:41:33 <lambdabot> Local time for dons is Sat Sep 16 00:41:10 2006
07:41:42 <edwardk> then my fusion rules just wouldn't apply there on the lattice.
07:41:55 <ndm> dons: any idea what we can do about the wiki and anchors?
07:41:56 <dons> vincenz: I know, time for bed.
07:41:57 <dcoutts__> you want to distinguish seq in the type?
07:42:08 <dons> ndm, hmm, is there just a missing anchor for case?
07:42:12 <edwardk> dcoutts: i am already distinguishing lots of things in my types =)
07:42:18 <dons> ndm , i didn't understand what the problem was.
07:42:21 <ndm> dons: case is "case, of" - two in one, so it doesn't generate an anchor
07:42:22 <dcoutts__> well be careful not to make seq too hard to use :-)
07:42:24 <edwardk> dcoutts: adding another lattice product isn't a problem =)
07:42:46 <dons> ndm, can you manually insert an <a name=""></a> tag?
07:42:48 <ndm> dons: the wiki autogenerates links to page#where for the one with a "where" title, but not for case
07:43:04 <dcoutts__> edwardk: if adding a seq means changing type annotations everywhere then it's not very useful anymore
07:43:05 <edwardk> dcoutts: currently i've got minimal/principal type inference for my substructural annotations.
07:43:06 <dons> i think you can insert any html you want, besides. so you can manually tag it.
07:43:07 <ndm> dons: yes, and it comes up as &gt;a name=""&lt;
07:43:18 <ndm> dons: any HTML, but i don't think anchors :(
07:43:20 <edwardk> dcoutts: so you wouldn't have to change annotations if you used the inferred ones.
07:43:33 <dcoutts__> hmm, the same is true in haskell of course
07:43:36 <dons> well, just rename it to 'case', and add a new one for 'in' which points to 'case'/
07:43:42 <dcoutts__> when seq used a class context
07:43:48 <edwardk> if you explicitly state that you want unrestricted though, then you can get it, and then fusion rules would be sound
07:44:01 <dcoutts__> but of course people like to add type annotations in some places (like top level functions)
07:44:19 <ventonegro> @index draw
07:44:20 <lambdabot> bzzt
07:44:26 <ventonegro> @hoogle draw
07:44:26 <edwardk> yeah, my type annotations are presently horrific, but i'm toying with an intermediate language, not a surface rep
07:44:27 <lambdabot> Data.Tree.drawForest :: Forest String -> String
07:44:27 <lambdabot> Data.Tree.drawTree :: Tree String -> String
07:44:36 <dcoutts__> right
07:44:48 <ventonegro> @hoogle Drawable
07:44:49 <lambdabot> No matches found
07:44:54 <edwardk> i'm just trying to see what it would take to bring generalized cata/ana fusion down to this level where I have all of the informaton needed to use it
07:45:03 <dcoutts__> I have a similar issue, my type annotations include a whole graph :-)
07:45:10 <edwardk> that would seem to necessitate tracking seq
07:45:20 <dcoutts__> right
07:45:39 <dcoutts__> that'd also tell you when eta-expansion is valid
07:45:43 <edwardk> I have a lattice of qualifiers that i'm trying to keep generalized.
07:46:01 <edwardk> so i can view the system as a generalized form of subtyping pure type system
07:46:38 <edwardk> but adding the ability to seq a point on the lattice before i ensure lack of weakening doesn't seem to break my logic's properties.
07:47:02 <edwardk> just blows me up to about 16 different qualifiers though.
07:47:22 <edwardk> for different combinations of relevance properties and 'affinity' properties.
07:47:53 <edwardk> at least I have a general proof of cut elimination and strong normalization that avoids my needing to compute for each of those. =)
07:48:10 <dcoutts__> sounds scary :-)
07:48:28 <edwardk> well, the lambda^refURAL folks used 4 of them and their proof weighed in at 200 pages.
07:48:45 <edwardk> mines about a page and handles a broader class
07:49:00 <edwardk> so something is going right
07:49:06 <dcoutts__> nice
07:49:43 <edwardk> so don't make seq too hard to use, don't make linear types too hard to use, any other constraints? =)
07:50:04 <dcoutts__> heh
07:50:14 <edwardk> the presence of seq will prevent lots of cata/ana stuff though, so it should be a non-win in the language as designed
07:50:45 <dcoutts__> the streams stuff doesn't break in the presense of seq I think
07:50:49 <Thomas2_> can I give where clauses to lambdabot?
07:50:57 <edwardk> ?
07:51:04 <dcoutts__> though I'm not sure of the reasons exactly
07:51:04 <Thomas2_> I want to prove something to you
07:51:15 <vincenz> Thomas2_: use let clauses
07:51:19 <edwardk> where can i get more info?
07:51:19 <Thomas2_> basically any implementation involving listArray sucks
07:51:32 <dcoutts__> edwardk: in our bytestring paper
07:51:47 <vincenz> dcoutts__: that submitted yet?
07:51:51 <dcoutts__> yep
07:51:57 <vincenz> accepted?
07:51:59 <edwardk> url?
07:52:02 <Thomas2_> lambdabot: > let funArray b f = listArray b $ map f $ range b in (funArray (0, 1000000) (\x -> x * 2)) ! 500000
07:52:04 <dcoutts__> we're awaiting a decision
07:52:09 <dcoutts__> @where fps
07:52:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:52:10 * vincenz nods
07:52:15 <dcoutts__> edwardk: it's linked from there
07:52:32 <vincenz> > let funArray b f = listArray b $ map f $ range b in (funArray (0, 1000000) (\x -> x * 2)) ! 500000
07:52:36 <lambdabot>  1000000
07:52:39 <edwardk> rewriting haskell strings?
07:52:42 <Thomas2_> right. note that was slow?
07:52:49 <dcoutts__> edwardk: yep
07:53:27 <edwardk> thomas: lambdabot probably doesn't optimize a whole heck of a lot ;)
07:53:29 <dcoutts__> edwardk: I think it's because we represent the tail of the sequence by a function call rather than a suspended value, so there's nothing to use seq on naughtily
07:53:55 <Thomas2_> edwardk: ok, but when I compile a function for that with ghc I get the same performance
07:54:05 <dcoutts__> Thomas2_: are you using -O ?
07:54:14 <vincenz> > let funArray b f = listArray b $ map f $ range b in (funArray (0, 1000000) (\x -> x * 2)) ! 500000
07:54:17 <lambdabot>  1000000
07:54:31 <vincenz> heh
07:54:37 <vincenz> obviously that's slow on the first access
07:55:09 <Thomas2_> dcoutts__: you make a good point
07:55:26 <dcoutts__> actually it could compile to fast code, the array construction can be fused with the list producer
07:56:11 <edwardk> dcoutts: thats what i was talking to him about above, he is determined to view anything that requires intermediate lists as a broken interface ;)
07:56:14 <Thomas2_> argh. my brain hurts, and for some reason ghc won't beleive in my main function.
07:56:20 <Thomas2_> i'll look at this again later
07:56:22 <dcoutts__> it'd probably be faster with an unboxed array too
07:56:48 <dons> dcoutts__: rl wants to do some proofs of this though
07:56:52 <dcoutts__> since each element there is cheap to calculate, it's probably cheaper than building a thunk
07:56:57 <dons> (the seq/tail stuff)
07:57:03 <dcoutts__> dons: I can believe it. It's a bit subtle.
07:57:13 <dons> but he's fairly sure its ok :)
07:57:23 <dons> just have to be nice to Isabelle for a while
07:57:31 <dcoutts__> heh
07:57:44 <dcoutts__> dons: the ! annotations in the Step type worry me slightly
07:57:54 <dons> oh?
07:58:04 <edwardk> ok, so foldr/build fusion is dead, long live stream fusion? =)
07:58:11 <dons> yep!
07:58:24 <edwardk> nifty keen. does it generalized to non-list like structures?
07:58:29 <dcoutts__> edwardk: we've got some cases where foldr/build is faster, like ++
07:58:37 <dons> yeah, should do, edwardk. trees for one.
07:58:51 <dcoutts__> dons: how would that work?
07:58:57 <edwardk> kk. chewing on it
07:58:57 <dcoutts__> yield two points?
07:59:04 <dcoutts__> then call next on those?
07:59:07 <dons> rl has some scheme, i'm not sure of the details
07:59:18 <edwardk> rl == who?
07:59:29 <dcoutts__> dons: well sjanssen found a case where the !s breaks things
07:59:36 <dons> roman, 3rd author on the paper/dph/ndp hacker extraordinair
07:59:40 <edwardk> ah
07:59:41 <edwardk> ok
07:59:52 <edwardk> just hadn't internalized him down to an acronym yet ;)
07:59:56 <dons> :)
08:00:11 <dons> him of the 40 cpu sparc box :)
08:00:11 <dcoutts__> dons: being strict in the state was breaking the interaction with fold/build
08:00:17 <dcoutts__> heh
08:00:19 <dons> ah right yes.
08:00:52 <dcoutts__> I could do with convincing that it's not a problem more generally
08:01:04 <dons> it makes sense for bytestrings, but whether we need ! for [a]... ?
08:01:05 <dcoutts__> or indeed that it's practically necssary for performance
08:01:11 <dons> right.
08:01:30 <dons> anyway, /me sleepifies. night!
08:01:40 <dcoutts__> g'night dons!
08:01:53 <edwardk> ok, and tossing around the Done/Yield/Skips isn't inefficient?
08:01:58 <dcoutts__> nope
08:02:00 <edwardk> hrmm
08:02:02 <dcoutts__> ghc eliminates them all
08:02:21 <edwardk> looking at it in my context trying to fit it into my model
08:02:32 <dcoutts__> they're allways immediately consumed
08:02:32 <edwardk> where I would probably have to view them as coroutines of some sort
08:02:34 <edwardk> yeah
08:02:40 <dcoutts__> so ghc can statically eliminat them
08:02:59 <dcoutts__> at least if you produce and consume them right
08:03:22 <dcoutts__> we had some code where it didn't and the performance suffered by an order of magnitude
08:04:00 <edwardk> I'm currently working in an intermediate language in which functions never return so I have to shft my perspective a little. everything is CPSed and is a tail call, so I guess it would work just fine to have separate producer and consumer continuations
08:04:10 <dcoutts__> having no more than one producer and consumer of each constructor is important I thnk
08:04:33 <edwardk> thats fine, I can ensure that with linearity unlike haskell
08:05:12 <dcoutts__> no, I think this was slightly different
08:05:16 <dcoutts__> it was code like:
08:05:55 <dcoutts__> case foo of bar -> Yield x xs; baz -> Yield y ys;
08:06:11 <dcoutts__> ie there were two sites that could produce a Yield constructor
08:06:38 <dcoutts__> I think that prevented the vital optimisation of eliminating the constructors
08:06:38 <edwardk>  so if you were walking down a tree and you wanted to produce say a path to a node as a stream to become a bytestring
08:07:24 <dcoutts__> mm, not sure
08:08:01 <dcoutts__> if you could write it so it only yielded at one site I think that'd work better
08:08:10 <edwardk> though couldn't that particular case be rewritten to use Yield only once?
08:08:12 <edwardk> yeah
08:08:25 <dcoutts__> to be sure one would have to look at the optimsation that ghc is doing that we're relying on
08:08:33 <dcoutts__> to see what it's side conditions are
08:08:40 <dcoutts__> we didn't have time to investigate
08:08:58 <edwardk> so that one would be like let (a,as) = case foo of bar -> (x,xs); baz -> (y,ys) in Yield a as
08:08:58 <dcoutts__> just optimised with intuition and profiling feedback
08:09:00 <dcoutts__> -)
08:09:02 <edwardk> *nods*
08:09:26 <dcoutts__> something like that, yes
08:11:38 <vincenz> ICPF is now, no/
08:11:40 <vincenz> ICFP even
08:11:50 <dcoutts__> aye
08:11:51 <edwardk> vincenz: it technically starts saturday i think
08:11:56 <vincenz> right
08:11:57 <edwardk> but they have the hackathon and stuff going now
08:12:08 <vincenz> well they should be in the conference now then
08:12:16 <vincenz> workshops usually precede on weekends
08:12:20 <vincenz> any news on the ICFPC?
08:12:32 <edwardk> well the workshops start saturday i should say
08:12:46 <vincenz> oh, coming saturday
08:12:47 <edwardk> scheme and stuff on saturday, haskell sunday
08:12:54 <vincenz> thought you meant this one
08:13:11 <vincenz> "this" one being the one that passed :-D
08:13:18 <edwardk> i mean 24 hours from now =)
08:13:41 <vincenz> Lol, check this out
08:13:43 <vincenz> in #scheme
08:13:45 <vincenz> 17:03 < lisppaste> easymoney annotated #12187 with "easymoney" at http://paste.lisp.org/display/12187#1
08:13:50 <vincenz> 17:12 < lisppaste> easymoney pasted "MAKE MONEY FAST REALLY WORKS" at http://paste.lisp.org/display/26095
08:14:08 <vincenz> someone is using lisp-paste to spam channels
08:14:11 <edwardk> invalid pastes
08:14:16 <edwardk> they must have nuked em
08:15:25 <edwardk> you would think that they'd have figured out that programmers typically don't fall for get rich quick schemes that don't involve a dot-com ;)
08:15:36 <lisppaste2> agfag pasted "asdga" at http://paste.lisp.org/display/26098
08:15:37 <vincenz> heh
08:15:44 <vincenz> someone used to spam my guestbook on my wiki daily
08:15:46 <vincenz> with 100 empty comments
08:15:53 <edwardk> most programmers are immune to any scam without the words 'stock options' involved :)
08:15:54 <vincenz> so... don't bother about looking for spammer motivation
08:16:00 <edwardk> then you get them for pennies on the dollar ;)
08:17:24 <hyrax42> @pl \x fs -> ap fs (return x)
08:17:24 <lambdabot> flip ap . return
08:18:04 <xerox> ?pl \y -> you y off
08:18:05 <lambdabot> flip you off
08:18:30 <hyrax42> har
08:18:56 <d04mse> how do you if you for everytime you run a function get a string make it come into a list
08:18:57 <d04mse> ?
08:19:10 <vincenz> map?
08:19:40 <Piloten> what dose "|" really mean?
08:19:48 <Piloten> that wall thing :P
08:19:51 <ndm> @wiki Keywords
08:19:52 <lambdabot> http://www.haskell.org/haskellwiki/Keywords
08:19:55 <ndm> Piloten: ^^^
08:20:24 <Piloten> ty
08:20:25 <edwardk> its a pipe symbol, usually used to mean 'or'. like in data Maybe a = Just a | Nothing
08:20:32 <Piloten> AHA!
08:20:33 <ndm> Piloten: if there is anything that isn't clear from that, then add it to the wiki
08:20:34 <d04mse> if it is a recursive function say ... match = map getAnswer + match ??
08:20:37 <Piloten> nice, thx a lit
08:20:38 <edwardk> it says that Maybe can be Just a or Nothing
08:20:40 <Piloten> *lot
08:20:56 <ndm> ah, the wiki doesn't cover that one! (/me updates)
08:21:28 <edwardk> oh, and guards
08:21:38 <edwardk> and [ | ] list comprehensions use it too
08:21:45 <vincenz> d04mse: that makes no sense
08:21:52 <vincenz> d04mse: a function always returns the same, there are no side-effects
08:22:43 <hyrax42> question: would ones = 1:ones evaluate to _|_?
08:23:01 <edwardk> > let ones = 1:ones in ones
08:23:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:23:06 <edwardk> nope
08:23:06 <ndm> edwardk: had those two already
08:23:13 <edwardk> we're not strict here
08:23:30 <int-e> > let ones = ones `seq` 1:ones in ones
08:23:32 <lambdabot>  Exception: <<loop>>
08:23:36 <hyrax42> last ones would
08:23:38 <gds> > let ones = 1:ones in ones == (1:ones)
08:23:43 <lambdabot> Terminated
08:23:47 <gds> :)
08:23:54 <edwardk> hyrax: sure, but ones itself is fine
08:23:55 <hyrax42> ok
08:24:05 <edwardk> > let ones = 1:ones in ones in take 10 $ ones
08:24:05 <lambdabot>  Parse error
08:24:09 <xerox> @check let ones = 1:ones in ones == 1:ones
08:24:09 <edwardk> er
08:24:13 <hyrax42> wasn't sure on the exactl meaning of "evaluates to _|_"
08:24:15 <lambdabot> Terminated
08:24:19 <edwardk> > let ones  = 1:ones in take 10 $ ones
08:24:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:24:32 <edwardk> never finishes computing is what _|_ means
08:24:36 <ski> > let ones = 1:ones in ones in last ones
08:24:37 <lambdabot>  Parse error
08:24:39 <d04mse> vincenz... i get a string for everythime i run match.. (different) ... i thought you could separate the different answers by just splitting the m with " " , but i rahter have them in a list ... is that possibler?
08:24:40 <int-e> the really fun thing about ones is that it evaluates to a single constructor cell (a list with element 1 and itself as tail)
08:24:45 <ski> > let ones = 1:ones in last ones
08:24:48 <xerox> Hey ski.
08:24:48 <vincenz> > take 10 $ fix (1:)
08:24:49 <lambdabot> Terminated
08:24:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:24:51 <edwardk> heya ski
08:24:52 <d04mse> and tell me in an easy way if soo
08:24:56 <ski> hiya
08:25:01 <vincenz> d04mse: how do you get a string every time you call it?  Is it a moandic action?
08:25:01 <hyrax42> what is the type of match
08:25:21 <vincenz> d04mse: what hyrax42 asked
08:25:36 <mnislaih> You can ask the AProVE termination tool
08:25:52 <d04mse> forget about that ... thats not relevant... i didnät gave you the whole function because thats not necesseary
08:25:53 <mnislaih> anybody did a lambdabot plugin for that already ?
08:25:59 <vincenz> d04mse: the TYPE
08:26:01 <vincenz> d04mse: not the code
08:26:03 * vincenz peers at d04mse 
08:26:15 <d04mse> hmm... Type is string
08:26:19 <vincenz> d04mse: that's impossible
08:26:23 <vincenz> then every call would return the same string
08:26:56 <vincenz> but ismply
08:27:01 <d04mse> no... not if you forget about how match looks like... it has arguments but i just didnät bother writing them down
08:27:12 <gds> So where do the args come from?
08:27:15 <vincenz> d04mse: then map over the arguments
08:27:16 <hyrax42> well then the type isn't string
08:27:17 <vincenz> if they'e in a list
08:27:26 <vincenz> > map match arglist
08:27:27 <lambdabot>  Not in scope: `arglist'
08:27:29 <gds> if the args are in a list, then you can map "match" over the list and get a new list...
08:27:37 <vincenz> gds: that's what I said originally
08:27:55 <gds> vincenz: So you did :)
08:28:22 <vincenz> so the type is definitely NOT string
08:28:23 <d04mse> well ... i still don't understand how to do that
08:28:32 <vincenz> could you please give us the type of "match"
08:28:36 <d04mse> map getAns ++ match ???
08:28:44 <gds> > map (+1) [1, 2, 3, 4]
08:28:45 <lambdabot>  [2,3,4,5]
08:28:57 <gds> [1, 2, 3, 4] is like the list of args.
08:28:57 <hyrax42> type :t match in ghci or hugs
08:29:01 <vincenz> > let match foo = show foo in map foo [1..10]
08:29:02 <lambdabot>  Not in scope: `foo'
08:29:06 <gds> (+1) is like your match function.
08:29:07 <vincenz> > let match foo = show foo in map match [1..10]
08:29:09 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
08:29:09 <hyrax42> assuming the file compiles so far
08:29:49 <d04mse> hmm... vincenz ... easy ... iam a newbie... :)
08:30:27 <vincenz> d04mse: simplest solution: paste what you got on @paste
08:30:28 <vincenz> @paste
08:30:29 <lambdabot> http://paste.lisp.org/new/haskell
08:30:43 <hyrax42> haskell can be a sheer vertical wall when you're a newbie
08:30:50 <hyrax42> so many interlocking concepts to get ironed out
08:30:55 <d04mse> match
08:30:55 <d04mse> 		|(length remaInSecWithW) > 0  =  getAns ++ matchh wildcard remaInFirst remaInSecond
08:30:55 <d04mse> 		|otherwise = ""
08:30:57 <vincenz> hyrax42: you forgot to mention slippery, oil-covered, smoothed wall
08:31:00 <vincenz> d04mse: @paste!
08:31:00 <gds> especially if you're used to java etc...
08:31:06 <hyrax42> but after you get used to it
08:31:21 <hyrax42> well it's still a sheer vertical (slippering, oil-covered, smoothed) wall
08:31:30 <hyrax42> you just have slightly better climbing equipment
08:31:32 <vincenz> hyrax42: and slightly backwards sloping :P
08:31:34 * gds found that the best way to get the hang of it was to do his best to forget all the previous programming he'd done, just for a little while...
08:31:48 <gds> Then to think about how functional and procedural programming relate a little later.
08:31:49 <vincenz> I was lucky
08:31:52 <vincenz> I moved in from ocaml
08:31:56 <vincenz> and idled in this channel for a year
08:32:00 <vincenz> :-D
08:32:01 <d04mse> @paste
08:32:02 <lambdabot> http://paste.lisp.org/new/haskell
08:32:03 <hyrax42> I was lucky I'd at least read part of The Little MLer
08:32:08 <hyrax42> so wasn't complete lost with types
08:32:23 <d04mse> vincenz... did you see what i pasted?
08:32:35 <vincenz> it;'s illegible and makes no sense
08:33:09 <vincenz> match doesn't have arguments
08:33:15 <hyrax42> yeah
08:33:54 <d04mse> ook... here comes the whole code
08:33:57 <d04mse> matchh wildcard t s = wildCards
08:33:57 <d04mse> 	
08:33:57 <d04mse> 	where
08:33:57 <d04mse> 	wildCards
08:33:57 <d04mse> 		|(length remaInSecWithW) > 0  =  getAns ++ matchh wildcard remaInFirst remaInSecond
08:33:58 <d04mse> 		|otherwise = ""
08:33:59 <vincenz> STOP
08:33:59 <hyrax42> @paste
08:34:02 <lambdabot> http://paste.lisp.org/new/haskell
08:34:02 <d04mse> 	first = takeWhile (wildcard /=) t
08:34:02 <vincenz> @PASTE!
08:34:04 <d04mse> 	second = take countedChars s
08:34:08 <lambdabot> Unknown command, try @list
08:34:08 <d04mse> 	compared = compareStrings first second	
08:34:10 <vincenz> grr
08:34:10 <d04mse> 	countedChars = length first
08:34:12 <d04mse> 	getCharAfterW
08:34:14 <d04mse> 			|(length remaInFirst) > 0 = head (take 1 remaInFirst)
08:34:16 <d04mse> 			|otherwise = ' '
08:34:18 <d04mse> 	remaInFirst = drop (countedChars + 1) t			-- Innehåller resten av t UTAN wildcard
08:34:18 <hyrax42> gah
08:34:20 <glguy> d04mse: that's considered extremely rude actually
08:34:20 <d04mse> 	remaInSecWithW = drop (countedChars) s			-- Innehåller resten av s MED wildcard
08:34:22 <d04mse> 	remaInSecond = drop (length getAns) remaInSecWithW	-- Innehåller resten av s UTAN wildcard
08:34:22 --- mode: ChanServ set +o vincenz
08:34:24 <d04mse> 	getAns = takeWhile (getCharAfterW /=) remaInSecWithW
08:34:24 --- kick: d04mse was kicked by vincenz (vincenz)
08:34:27 <vincenz> whew
08:34:29 --- mode: vincenz set -o vincenz
08:34:49 <vincenz> I msged him to comeb ack
08:35:30 <vincenz> oy
08:35:46 <vincenz> He left
08:35:56 * vincenz sighs
08:35:57 <int-e> he's back
08:36:02 <d04mse> thanks for kickking me...
08:36:04 <vincenz> d04mse: Welcome back
08:36:10 <vincenz> Sorry for the kicking, it was just spamming
08:36:18 <vincenz> Use the website
08:36:19 <vincenz> @paste
08:36:19 <lambdabot> http://paste.lisp.org/new/haskell
08:36:23 <vincenz> that's what it's there for
08:37:01 <lisppaste2> d04mse pasted "matchh" at http://paste.lisp.org/display/26101
08:37:04 * vincenz curses irc clients that slow down long pases
08:37:08 <vincenz> \o/
08:37:42 <d04mse> ook... you know.. it's not easy understanding everything you say guys
08:37:47 <d04mse> http://paste.lisp.org/display/26101
08:37:51 <vincenz> yep yep
08:38:06 <vincenz> oy
08:38:10 <vincenz> so you want to remove the ++ match part
08:38:34 <vincenz> hmm
08:38:36 <d04mse> yes... and then have it walked through
08:38:38 <vincenz> and make it return [Strinig]
08:38:44 <vincenz> mkkkay
08:38:46 <vincenz> shouldn't be too hard
08:38:48 <vincenz> but the way you put the code
08:38:51 <vincenz> it is now obvious map won't work
08:39:12 <lisppaste2> vincenz annotated #26101 with "fixed" at http://paste.lisp.org/display/26101#1
08:39:16 <vincenz> whoops
08:39:17 <vincenz> sorry
08:39:27 <lisppaste2> vincenz annotated #26101 with "fixed" at http://paste.lisp.org/display/26101#2
08:39:31 <vincenz> fixed
08:40:35 <vincenz> match now returns [String]
08:40:47 <d04mse> ook
08:41:07 <vincenz> see what I did?
08:41:09 <vincenz> if it's otherwise
08:41:11 <vincenz> aka, the end
08:41:13 <vincenz> I return an empty list
08:41:19 <vincenz> otherwise I add one more empty to the head of the list
08:41:24 <vincenz> element : list
08:41:25 <int-e> replacing (length s) > 0  by  not (null s)  is a good idea btw, it's faster and works for infinite lists.
08:41:37 <vincenz> yeah I didn't take time to clean the rest
08:41:57 <norpan> just make it a RULE :)
08:42:07 <vincenz> norpan: what rule?
08:42:15 <int-e> norpan: can't
08:42:23 <int-e> norpan: because it changes program's behaviours.
08:42:28 <d04mse> ook... thanks... i have this first assignment ready to be handed in today and it's so hard getting the right information... and i have plenty left... :((
08:42:29 <norpan> to the better
08:42:46 <d04mse> but now iam feeling better
08:43:07 <vincenz> good ;)
08:43:10 <shapr> I feel better too!
08:43:13 * shapr boings
08:43:13 <vincenz> at least we saw you did a lot of effort :)
08:43:16 <vincenz> it smelled like homework
08:43:19 <norpan> i always feel better
08:43:28 <vincenz> norpan: that's impossible
08:43:31 <vincenz> norpan: that's like an infinite list
08:43:41 <norpan> vincenz: hey, can haskell do it
08:43:44 <vincenz> > last $ iterate(+1) 1
08:43:47 <vincenz> no it can't
08:43:49 <vincenz> cause you need an instance
08:43:53 <lambdabot> Terminated
08:44:00 <norpan> as i only will live a finite amount of days it's possible
08:44:04 <vincenz> oh wait, you're not dead (Terminated) yet
08:44:31 <int-e> you could add such a rule to ghc and let programmers get away with bad code. but that's penalizing other compilers for no good reason.
08:44:57 <d04mse> oko... so now to go through the list i guess i could iterate maybe like this ? [f xs | xs<-stringlist] ??
08:45:30 <int-e> and it will change the behaviour for infinite lists which is undesirable, even if it's what the programmer wants 99.9% of the time.
08:45:39 <vincenz> d04mse: yep
08:46:37 <vincenz> or
08:46:41 <vincenz> map f stringlist
08:46:51 <vincenz> I think the second conveys the meaning more clearly
08:47:19 <d04mse> map to me?
08:47:23 <xerox> @compose pl undo \f xs -> xs >>= \x -> f x
08:47:23 <lambdabot> (=<<)
08:47:34 <xerox> Ops.
08:47:38 <d04mse> ook... i get it know
08:52:07 <d04mse> vincent... say i have this string "1234x567x9" and my list ["5", "8"], what i would like to do is go through the first string and where i find 'x' (the wildcard) is where i have to put in the first list object (the "5"), for next 'x' the "9" and so on til don't find more 'x'
08:54:27 <shapr> What about splitting the list on the wildcard and joining with the list of items to fill in?
08:55:27 <d04mse> true
08:57:52 <d04mse> could you show me ... my head is not working properly... been here 8 hours today...
09:00:36 <shapr> Well, how would you split the list a a certain character?
09:00:56 <d04mse> take (char /=) string
09:01:31 <d04mse> but ... i would like to continue with the rest... and iam not sure iam happy about doing it recursive
09:02:10 <shapr> You could have a function to split at that one character that would then pass the rest of the string to another function.
09:03:04 <d04mse> well... since i don't know how many occurense there is in that string of the character i would then not know how many times i would have to do that
09:04:44 <shapr> If the next function you call does the same thing, it wouldn't be a problem, right?
09:06:31 <shapr> hiya SyntaxNinja!
09:08:45 <SyntaxNinja> w00t
09:09:00 <vincenz> @slap SyntaxNinja -- get a grip
09:09:01 * lambdabot slaps SyntaxNinja -- get a grip
09:09:13 <bourbaki> SyntaxNinja did you already get your villain?:)
09:09:24 <SyntaxNinja> Oo
09:12:19 <shapr> hej bringert
09:12:20 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
09:12:42 <bringert> hej shapr
09:13:05 <vincenz> hiya bringert
09:13:12 <shapr> bringert: Finns det mÃ¥nga svenskar i Portland just nu?
09:13:14 <bringert> hi vincenz
09:13:40 <bringert> shapr: the only one I've seen is thomas hallgren
09:14:26 <shapr> ah well
09:14:49 <waern> is there a function that "lifts" Maybe a into Either e a, if you supply e?
09:15:08 <waern> in the standard libraries, I mean
09:15:09 <shapr> I'm tempted to not take my unicycle just so I won't have to roll it around.
09:16:09 <xerox> ?docs Data.Either
09:16:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
09:16:17 <dcoutts__> anyone know if there's a standard FAQ answer for this one: http://hackage.haskell.org/trac/ghc/ticket/901
09:16:20 <lambdabot> Title: #901 (I/O sequencing problem on OS X/x86) - GHC - Trac, http://tinyurl.com/fqnat
09:16:26 <dcoutts__> hia shar
09:16:38 <dcoutts__> I'm just about to head out on my unicycle :-)
09:17:03 <dcoutts__> shapr: perhaps you need a smaller unicycle that's easier to carry
09:17:17 <vincenz> how about an acycle?
09:17:20 <waern> xerox, thanks but nothing there.. such a function would be useful though
09:17:20 <vincenz> less to roll around
09:17:24 <vincenz> in fact nothing will have to roll
09:17:34 <shapr> hiya dcoutts__
09:17:38 <xerox> waern: I was investigating, yeah.
09:17:50 <xerox> ?type maybe
09:17:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:18:25 <xerox> waern err = maybe (Left err) Right
09:18:40 <dcoutts__> @type \err -> maybe (Left err) Right
09:18:41 <lambdabot> forall a a1. a1 -> Maybe a -> Either a1 a
09:19:26 <xerox> ?type flip maybe Right . Left
09:19:28 <lambdabot> forall a b. a -> Maybe b -> Either a b
09:19:30 <dcoutts__> > (\err -> maybe (Left err) Right) "no ya dufus!" Nothing
09:19:31 <lambdabot>  Add a type signature
09:19:33 <dcoutts__> bah
09:19:35 <xerox> :D
09:19:43 <waern> heh
09:19:44 <dcoutts__> > (\err -> maybe (Left err) Right) "no ya dufus!" (Nothing :: Maybe () )
09:19:45 <waern> thanks
09:19:45 <lambdabot>  Left "no ya dufus!"
09:19:54 <xerox> You're welcome.
09:24:20 <xerox> @check let f n = product [1..n]; n `c` k = f n `div` (f k * f (n-k)); p n a x = sum [(a!!i)*(x^i) | i <- [0..n]]; q n a x = sum [(x^i) * sum [(a!!j) * (i`c`j) | j <- [1..n]] | i <- [0..n]] in \(xs::[Int]) (x::Int) -> p (length xs + 1) xs x == q (length xs + 1) xs (x-1)
09:24:20 <lambdabot>  Parse error in pattern
09:28:03 <xerox> How do you say to check to not use null lists?
09:28:20 <ndm> dcoutts__: if the FAQ is a URL from hell...
09:28:48 <dcoutts__> ndm: it is a bit of a long one :-)
09:29:02 <glguy> xerox: (not . null) xs ==> ?
09:29:02 <ndm> dcoutts__, any way to add custom anchors to the wiki page?
09:29:10 <xerox> glguy: ah!
09:29:21 <dcoutts__> ndm: I'm sure there is, I just don't know it :-)
09:29:34 <ndm> dcoutts__, ditto - and i need it for hoogle :(
09:29:53 <dcoutts__> ndm: I'm sure it's in the mediawiki formatting pages
09:32:25 <bringert> dcoutts__: it's the hFlush thing right?
09:32:42 <bringert> it was answered on one of the mailing lists recently
09:34:50 <d04mse> i dont get this error message when i compile "parse error on input '|'
09:35:08 <SyntaxNinja> xerox: did you email out my dream script email?
09:35:30 <bringert> dons, lispy: you around?
09:35:45 <xerox> SyntaxNinja: not yet sorry. University is starting these days, I'll do that in the weekend, ok?
09:35:57 <d04mse> i am not using | as an input, i wont too use it as an if statement for my function
09:42:19 <d04mse> I am getting this error "parse error on input '|' " and all I do is as I have allways done, i write the name of my function and have som inputs and then this '|' and then a boolean statement
09:42:32 <d04mse> why am I getting that error?
09:42:47 <SyntaxNinja> xerox: I'll do ti.
09:42:53 <ndm> d04mse: @paste your code, so we can see
09:47:12 <dmhouse> ?where paste
09:47:13 <lambdabot> http://paste.lisp.org/new/haskell
09:47:17 <dmhouse> d04mse: paste it there.
09:54:47 <dmwit> I just want to say that "interact" is a great idea.
09:57:37 <ndm> dmwit: its not used that much anymore
09:57:58 <glguy> interact hails from before the days of Monadic IO... right?
09:58:18 <dmwit> ndm: What replaced it?
09:58:37 <glguy> Monadic IO (c;
09:58:42 <ndm> dmwit: getLine, putStrLn
09:58:49 <dmwit> Oh.
09:59:00 <ndm> dmwit: of course, its still perfectly valid - and if it works for you is exactly the right solution!
09:59:05 <ndm> its just gone out of favour, thats all
09:59:50 <dmwit> Well, it will still get a little love from me, anyway... =)
10:00:16 <shapr> The history of Haskell paper talks about the way IO used to happen in Haskell, that'll explain why interact was important.
10:00:58 <dmwit> It used to wrap a separate I/O program around the Haskell, right?
10:01:03 <ndm> i went to quite a lot of trouble to get it working in WinHugs, so people had better still use it!
10:01:08 <dmwit> It makes sense why interact would be important then.
10:01:30 <jgrimes> which papers discuss the choice of monads over uniqueness types?
10:01:57 <mikael> @type interact
10:01:59 <lambdabot> (String -> String) -> IO ()
10:02:28 <ndm> jgrimes: over continuations, and something else - but not uniqueness types
10:02:34 <jgrimes> ndm, oh, hm
10:02:50 <glguy> what is the MonadIO definition of interact?
10:02:52 <jgrimes> uniqueness types seemed somewhat nice to me
10:03:44 <ndm> glguy: fire up Hugs, :f interact
10:04:47 <xerox> ?type let interact f = let loop = loop >> putStr . fmap f . getLine in interact
10:04:48 <lambdabot> not an expression: `let interact f = let loop = loop >> putStr . fmap f . getLine in interact'
10:04:49 <glguy> interact f = getContents >>= (putStr . f)
10:04:54 <xerox> Opps.
10:06:00 <ndm> interact is not line buffered
10:06:25 * shapr boings happily
10:06:35 <shapr> whee!
10:06:49 <shapr> hiya beelsebob, coming to HW?
10:07:04 <beelsebob> shapr: no, bad timing
10:07:08 <beelsebob> I just did IFL
10:07:24 <kosmikus> shapr: will you be at HW?
10:07:37 <shapr> kosmikus: I'm about 90% sure I will be.
10:07:44 <shapr> Unless I miss my flight or do something else equally clueless.
10:07:54 <kosmikus> great
10:08:30 <shapr> kosmikus: But this time, maybe I'll be the one climbing into your hotel window.
10:08:51 <ndm> beelsebob: i wrote a C backend for Yhc :)
10:09:08 <ndm> beelsebob: which is GHC competative! (for small benchmarks, then i stack overflow...)
10:10:27 <beelsebob> ndm: ghc competative?
10:10:33 <shapr> kosmikus: How many people have signed up? Or is that privileged info?
10:10:33 <beelsebob> what does this mean?
10:10:52 <shapr> sounds like "as fast as GHC"
10:10:59 <ndm> beelsebob: i have tried it on one benchmark, i beat GHC, but suspect thats got a lot to do with startup overhead
10:11:06 <beelsebob> indeed - but yhc's backend was as fast as ghc before
10:11:08 <kosmikus> shapr: I don't have the final number. Last time I got stats it was 83.
10:11:25 <ndm> beelsebob: really? really? its 10's of times slower
10:11:27 <kosmikus> shapr: good luck with climbing through my hotel window. it's on 6th floor ...
10:11:31 <shapr> kosmikus: haha
10:11:48 <shapr> kosmikus: From what I remember of HW2003 it only had about 40 people, I'm glad HW is growing!
10:12:04 <kosmikus> shapr: I guess it was more than 40.
10:12:10 <kosmikus> let me check if I have the numbers
10:12:15 <ndm> beelsebob: anyway, my hope is to beat GHC :)
10:12:20 <beelsebob> ndm: the backend? Or the runtime?
10:12:21 <beelsebob> or what?
10:12:32 <beelsebob> I thought that yhc's compile time was much faster than ghcs
10:12:35 <shapr> ndm: I'm positive yhc can beat GHC on the Nokia 770
10:12:42 <ndm> oh, no - i'm talking about runtime!
10:12:50 <lispy> dons: did you apply bringert's patch yet or shall i?
10:12:54 <ndm> we whoop them convincingly at compile time
10:13:10 <ndm> shapr: well when you feel like starting your port, let us know!
10:13:16 <shapr> It's a real pain to build GHC in scratchbox.
10:13:19 <kosmikus> shapr: says ">80" in my statistics file
10:13:22 <ndm> shapr: or when you feel like buying me a Nokia 770...
10:13:28 <jgrimes> ndm, didn't you say the Yhc C runtime was a G-machine? you could always change it to an STG-machine like ghc :)
10:13:39 <beelsebob> ndm: oh... WOW!
10:13:43 <ndm> jgrimes: its always been an STG-machine
10:13:47 <shapr> ndm: Hey, they're only $360 on the nokia.com website, aren't you a powerful and influential PhD student?
10:13:47 <beelsebob> so yhc is now faster to build and faster to run?
10:13:52 <jgrimes> ndm, oh, ok
10:13:55 <jgrimes> ndm, :)
10:14:01 <ndm> shapr: no, i'm a normal phd student :)
10:14:15 <ndm> beelsebob: slower to build, faster to run, with my backedn
10:14:20 <shapr> Close enough, don't you have 180 pounds to spare?
10:14:23 <beelsebob> ndm: oh, okay
10:14:29 <ndm> hmm, not sure
10:14:30 <beelsebob> but... you have that thing on the yhc page
10:14:35 <beelsebob> showing that yhc is faster to build
10:14:39 <beelsebob> but slower to run
10:14:40 <SyntaxNinja> there are no plugs near me :(
10:14:44 <ndm> my computer is an Athlon 750, I think that needs love first...
10:14:46 * shapr plugs SyntaxNinja 
10:15:00 <ndm> beelsebob: Yhc, yes - Yhc + Neil's C backend = faster to run, slower to build
10:15:01 <shapr> Man, that SyntaxNinja is great. He does so much useful stuff for the Haskell community and he's a really hard worker.
10:15:15 <jgrimes> haha
10:15:21 <beelsebob> ndm: I thought that Tom's runtime was already written in C?
10:15:34 <beelsebob> ndm: oh, I see
10:15:34 <ndm> beelsebob: its a runtime in C, I generate pure C from Haskell
10:15:40 <beelsebob> oh, I see!
10:15:43 <shapr> He's the guy in charge of Cabal, Haskell' and haskell.galois.org
10:15:47 <shapr> er
10:15:52 <ndm> (pure = in the loosest sense of the word!)
10:15:57 <shapr> That hostname was totally wrong.
10:16:00 <beelsebob> so now non-portable
10:16:05 <beelsebob> but on the other hand
10:16:06 <beelsebob> uber fast
10:16:08 <ndm> yep
10:16:12 <beelsebob> shinies
10:16:16 <ndm> but now with Yhc you get both :)
10:16:23 <beelsebob> excellent :)
10:16:26 <SyntaxNinja> shapr: thanks for plugging me.
10:16:26 <ndm> and Colin has said I can move my phd into compiler optimisation
10:16:32 <beelsebob> oh, cool
10:16:34 <ndm> (since someone accidentally solved termination...)
10:16:35 <beelsebob> that's good
10:16:51 <beelsebob> someone accidentally solved what about termination?
10:17:00 <ndm> Haskell + Termination Checking
10:17:05 <shapr> SyntaxNinja: Too bad positive thoughts don't give your laptop a positive charge.
10:17:07 <beelsebob> I see?
10:17:14 <ndm> and not accidentally, more like devoted their life to termination checking
10:17:18 <shapr> Who?
10:17:24 <ndm> Jurgen Giesl
10:17:27 <norpan> solved?
10:17:32 <ndm> yep, solved
10:17:37 <ndm> (as far as i am concerned)
10:17:43 <SyntaxNinja> shapr: yeah
10:17:50 <jgrimes> that sounds fairly important.
10:17:50 <ndm> obviously its not perfect, but its pretty impressive!
10:18:06 <norpan> solved an interesting sub-problem?
10:18:24 <ndm> have a checked that does termination analysis, which is very very very good
10:18:30 <shapr> Argh, now that my flight is confirmed it's too late to register online for Haskell Workshop.
10:18:31 <shapr> foo
10:18:59 <ndm> http://aprove.informatik.rwth-aachen.de/index.asp?subform=termination_proofs.html&program_type=hs
10:19:01 <lambdabot> Title: AProVE, http://tinyurl.com/gnvv2
10:19:08 <ndm> try that, and try and make it fail, its a challenge!
10:19:23 <lispy> shapr: i'm going to try registering the morning of
10:19:47 <norpan> ok, found the article
10:20:00 <shapr> lispy: You'll be there too?
10:20:08 <shapr> The site says on-site registration will be $130
10:20:10 <lispy> shapr: if they let me register, yes :)
10:20:40 <lispy> shapr: i'll be carpooling with droundy
10:20:41 <lisppaste2> d04mse pasted "Match" at http://paste.lisp.org/display/26105
10:21:17 <shapr> Oh cool, I didn't know he'd be there.
10:21:26 <shapr> Is there a list of #haskell people who will be at HW?
10:21:28 <d04mse> help me guyz... pleeease... iam gooonnna fail this courrrssee.... pleaase... i need to get some heeeeelp! lol :P
10:21:38 <kosmikus> droundy is coming to HW, too?
10:21:39 <kosmikus> nice
10:21:42 <d04mse> http://paste.lisp.org/display/26105
10:22:01 <shapr> d04mse: When did you register for this course?
10:22:14 <ndm> d04mse: if its a course, usually its best to ask your lecturers - since they tend to know what help to give, and what not to give
10:22:16 <lispy> i'm riding with Erwig and Ren (i think the second or third presenters) and droundy
10:22:17 <d04mse> 2 weeks ago... this is the first assignment
10:22:40 <shapr> Martin Erwig the author of the Functional Graph Library?
10:22:43 <d04mse> iam getting better but i have 3 hours left to deadline and there plenty more to do
10:22:50 <bringert> d04mse: try adding type signatures to the functions, that will probably narrow down the source of the error message
10:22:59 <kosmikus> lispy: so you're at OSU?
10:23:04 <lispy> bringert: thanks for the patch, i just applied it
10:23:05 <lispy> kosmikus: yes
10:23:09 <xerox> And try to break big problems in very small simple problems.
10:23:10 <kosmikus> ok
10:23:13 <lispy> bringert: but, i some things are not working
10:23:16 <d04mse> bringert ... i wish I knew how to do that
10:23:19 <lispy> bringert: http://lambdabot.codersbase.com/lambdaweb.html
10:23:22 <lambdabot> Title: Lambabot Web Interface, http://tinyurl.com/hcdys
10:23:22 <bringert> lispy: sweet, let me know when it is online
10:23:27 <lispy> bringert: how do i evaluate an expression
10:23:51 <lispy> bringert: i've tried run 1 + 1 and > 1 + 1 but i get errors
10:23:52 <bringert> lispy: with lambdabot?
10:23:57 <bringert> eval 1 + 1
10:24:04 <bringert> @eval 1+1
10:24:19 <bringert> hmm
10:24:22 <lispy> ?help eval
10:24:22 <lambdabot> eval. Do nothing (perversely)
10:24:23 <lispy> ?help run
10:24:24 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
10:24:39 <lispy> bringert: so with the raw cgi > 1 + 1 and run 1 + 1 both work
10:24:47 <bringert> hmm
10:24:48 <lispy> bringert: but with the ajax something is broken...not sure why
10:24:53 <bringert> ah
10:25:03 <bringert> maybe it's an encoding thing
10:25:38 <lispy> maybe
10:25:56 <lispy> does javascript have an encode url function?
10:26:15 <ndm> lispy: yes, escape, i believe...
10:26:16 <d04mse> ndm ... but it's 19.30, it's pretty hard getting help from your lecture at thit time
10:26:37 <lispy> bringert: actually, i should go in to work, so i'll let you think about it and we can talk later :)
10:26:45 <xerox> Except if your lecturer hangs out on #haskell... :)
10:27:13 <bringert> lispy: I'm using escape, but it doesn't encode spaces as +
10:27:18 <lispy> ah
10:27:32 <lispy> well, i'm off for a bit
10:27:32 <ndm> bringert: does it encode them as %20?
10:27:40 <ndm> lispy: neat, but quote doesn't work
10:27:43 <bringert> yeah
10:27:53 <lispy> ndm: quote was disabled intentionally
10:28:03 <lispy> ndm: maybe...it shouldn't have been...
10:28:14 <ndm> lispy: looks uber-leet anyway!
10:28:26 <lispy> ndm: thank bringert too
10:28:29 <lispy> ndm: and dons
10:28:35 <lispy> i mostly just glued stuff together :)
10:28:45 <lispy> and the ajax is all bringert  :)
10:28:47 <lispy> bringert++
10:28:48 * ndm thanks lispy, bringert and dons
10:29:16 * ndm goes off to play with vixen in private
10:29:29 <shapr> oh my!
10:29:52 <bourbaki> ajax?
10:30:09 <ndm> would be nice if it had syntax colouring....
10:30:16 <ndm> and hoogle colouring, as per the web thingy
10:30:26 <ndm> and (more..) buttons, for when there is more output
10:30:56 <lispy> ndm: we accept patches, the cgi stuff is at http://www.cse.unsw.edu.au/~dons/code/goa/
10:30:57 <lambdabot> Title: Index of /~dons/code/goa
10:31:05 <ndm> and url hyperlinking...
10:31:07 <bringert> lispy: ok, fixed it
10:31:11 <bringert> run 1 works
10:31:11 <shapr> @users
10:31:12 <apfelmus> int-e: ping
10:31:21 <lambdabot> Maximum users seen in #haskell: 242, currently: 228 (94.2%), active: 35 (15.4%)
10:31:24 <lispy> or you can send the patch to me dagit at codersbase.com
10:32:21 <kosmikus> which users does lambdabot consider "active"?
10:32:22 <ndm> i will, once Hoogle 4 is done...
10:32:46 <xerox> @vixen which users do you consider "active"?
10:32:47 <lambdabot> maybe. do you?
10:33:11 <int-e> apfelmus: pong
10:33:13 <bringert> lispy: you've got mail
10:33:25 <apfelmus> int-e: blueprints are cool :)
10:33:33 <SyntaxNinja> wget http://hackage.haskell.org/~paolo/darcs/cabal-install/test-cabal-install && chmod 755 test-cabal-install && ./test-cabal-install
10:33:34 <int-e> thanks
10:33:35 <lambdabot> http://tinyurl.com/jemrl
10:33:37 <SyntaxNinja> please test cabal-install :)
10:33:44 <bourbaki> whats ajax?
10:34:24 <ndm> SyntaxNinja: windows compatible?
10:34:25 <lispy> bourbaki: asynchronous javascript and xml
10:34:29 <lispy> bringert: okay
10:34:33 <bourbaki> ah
10:34:41 <bourbaki> two evil words :)
10:35:36 <apfelmus> int-e: i thought that only something like Ross did would be possible. i mean you build a fixed constructor tower and defer its contents to later
10:36:58 <lispy> bringert: cool, it's back up
10:37:24 <lispy> bringert: and i symlinked index.html to lambdaweb.html so now you just go to http://lambdabot.codersbase.com/
10:37:26 <lambdabot> Title: Lambabot Web Interface
10:38:18 <lispy> (going to work for real this time)
10:38:25 <lispy> bringert++
10:38:59 <d04mse> guys.... about my earlier error ... http://paste.lisp.org/display/26105 ... if change matchh wildcard t s = reconstruct t 0  to matchh wildcard t s = wildCards .. i get no compilation errors ... but if i again change to matchh wildcard t s = "hello" .. i get the same compilation error as before... how does that come??? the function method gives [[Char] ... [Char]] but i havn't defined matchh and earlier it handled [Char] as expected
10:39:11 <bourbaki> @karma bringert
10:39:12 <lambdabot> bringert has a karma of 15
10:39:18 <xerox> Yuck.
10:40:28 <int-e> apfelmus: yes, and your observation that throwing away the future keys is fundamental to making it work is absolutely correct, I wish I had written that. :)
10:40:29 <SyntaxNinja> help us test cabal-install!
10:45:27 <norpan> @karma norpan
10:45:28 <lambdabot> You have a karma of -1
10:45:29 <apfelmus> int-e: hey, it took the evening to ponder what magic is going on until i realized from (lookup a bp' m') that bp' and m' actually contain the same alas only few keys. :)
10:45:32 <norpan> that's not good
10:46:11 <vincenz> @karma edwardk
10:46:12 <lambdabot> edwardk has a karma of -2
10:46:29 <bringert> heh, the lambdabot web interface doesn't seem to work at all in IE
10:46:34 <bringert> guess I should have tested that
10:46:48 <ndm> does anyone use IE anymore?
10:46:58 <ndm> anyone with the ability to program, i mean
10:47:08 <ndm> (of course it should be fixed in IE)
10:47:25 <ndm> bringert: you don't do Ajax the same way in IE vs the rest, which is probably what happened
10:47:51 <bringert> ndm: I thought I have taken that into account
10:48:08 <bringert> thing is, nothing is displayed, not even the stright HTML
10:48:34 <ndm> weird
10:48:48 <apfelmus> int-e: though i wonder whether the pesky inverse balancing can be avoided somehow.
10:49:24 <int-e> apfelmus: I doubt it, the deletion has to reproduce the exact structure of the blueprint.
10:49:34 <ndm> bringert: <script> </script>
10:49:43 <bringert> ah
10:49:44 <ndm> bringert: otherwise IE puts the whole page inside a script :)
10:50:12 <bringert> I hven't written plain HTML for quite a while
10:50:20 <bringert> just generate it with the xhtml lib
10:50:23 <ndm> its IE brand HTML...
10:50:53 <apfelmus> int-e: yes. but i mean it in the sense that you only have to code on direction and the other one is assembled automatically
10:51:56 <apfelmus> s/on/one
10:53:11 <int-e> apfelmus: I see. There could be an Arrow in there, of invertible computations (because basically that's what is needed).
10:54:33 <int-e> apfelmus: template haskell is an obvious idea but not a pretty one.
10:54:35 <weitzman> @type Just (fix id)
10:54:37 <lambdabot> forall a. Maybe a
10:56:28 <d04mse> how do you put for example "hello" like ["h", "e", "l", "l", "o"] ??
10:56:36 <apfelmus> int-e: no, template haskell is not pretty :) i'm still waiting for ralf hinzes generics library for such purposes. anyway, i thought that a zipper might help somehow
10:56:40 <weitzman> > ['h', 'e']
10:56:42 <lambdabot>  "he"
10:57:00 <weitzman> > concat ["h", "e"]
10:57:01 <lambdabot>  "he"
10:57:05 <ndm> > "hello"
10:57:06 <lambdabot>  "hello"
10:57:26 <d04mse> weitzman ... that wasn't what i asked for... i asked for the reversed situation
10:58:21 <apfelmus> > map return "hello" :: [String]
10:58:22 <lambdabot>  ["h","e","l","l","o"]
10:58:39 <d04mse> thanks you
10:58:48 <weitzman> Gah, I forgot the type
10:58:50 <weitzman> I tried
10:58:53 <weitzman> > map return "Hello"
10:58:54 <lambdabot>  add an instance declaration for (Show (m Char))
10:58:58 <weitzman> And lambdabot yelled at me
10:59:17 <d04mse> ööh.. i don't know how to write type's
10:59:39 <weitzman> > map (\x -> [x]) "hello"
10:59:41 <lambdabot>  ["h","e","l","l","o"]
10:59:42 <ndm> d04mse: if you haven't been taught them yet, then don't bother
10:59:55 <weitzman> > map (: []) "hello"
10:59:55 <int-e> > map (:[]) "hello"
10:59:56 <lambdabot>  ["h","e","l","l","o"]
10:59:57 <lambdabot>  ["h","e","l","l","o"]
11:03:04 <weitzman> > "hello" >>= ((:[]) . (:[]))
11:03:05 <lambdabot>  ["h","e","l","l","o"]
11:03:40 <weitzman> > [[x] | x <- "hello"]
11:03:41 <lambdabot>  ["h","e","l","l","o"]
11:04:03 <int-e> > transpose ["hello"]
11:04:05 <lambdabot>  ["h","e","l","l","o"]
11:04:12 <weitzman> @type transpose
11:04:14 <lambdabot> forall a. [[a]] -> [[a]]
11:04:26 <int-e> > transpose ["hello", "world"]
11:04:27 <lambdabot>  ["hw","eo","lr","ll","od"]
11:04:30 <weitzman> Interesting
11:04:57 <weitzman> > transpose [[1, 2], [3, 4], [5, 6]]
11:04:59 <lambdabot>  [[1,3,5],[2,4,6]]
11:05:09 <weitzman> > transpose [[1, 2], [3, 4], [5, 6, 7]]
11:05:10 <lambdabot>  [[1,3,5],[2,4,6],[7]]
11:05:29 <weitzman> > transpose [[1, 2, 8], [3, 4], [5, 6, 7]]
11:05:30 <lambdabot>  [[1,3,5],[2,4,6],[8,7]]
11:06:05 <apfelmus> int-e: isn't there simpler example? the rotation code is really brain damaging :)
11:06:54 <int-e> apfelmus: you can in principle do this with plain lists. it defeats the purpose of efficiency but maybe it's a good excercise.
11:08:00 <int-e> apfelmus: to make it interesting, you can make the list sorted by the key.
11:08:02 <weitzman> > tail . map head . inits $ "hello"
11:08:03 <lambdabot>  "hhhhh"
11:08:16 <weitzman> > tail . map head . tails $ "hello"
11:08:18 <lambdabot>  Exception: Prelude.head: empty list
11:09:07 <int-e> apfelmus: I haven't tried to find a simpler scenario where such a data structure full of holes is useful, yet.
11:10:01 <apfelmus> int-e: mh, it won't get interesting. you run along both lists until you are at the right position. but maybe for finding an arrow abstraction it could be useful.
11:12:40 <Baughn> There is no distinction between "function of no arguments" and "value", right?
11:12:49 <apfelmus> int-e: i'm not yet sure wether the holes are truly needed. maybe one can somehow tie the blueprint into a knot and it gets filled.
11:13:11 <apfelmus> Baughn: there is even no distinction between "function" and "value" ...
11:14:37 <weitzman> Baughn: The only distinction I can think of is that in a strict language, a suspended computation might be considered "function of no arguments"
11:14:46 <int-e> apfelmus: Maybe. I don't know. Right now blueprints are a practical (for me) approach, with almost mechanical translation for threading back the result. I wouldn't know where to start tying the knot.
11:16:25 <Baughn> weitzman: I was thinking in Haskell. Strict languages are an entirely different thing, though I suppose this is really a matter of haskell being purely functional
11:17:23 <weitzman> Haskell allows strict computations, I believe
11:17:32 <weitzman> if you're into that kind of thing :)
11:17:42 <Baughn> I enjoy the laziness. :P
11:18:20 <weitzman> > head [1, head []]
11:18:21 <lambdabot>  1
11:18:29 <weitzman> w00t
11:19:04 <int-e> > length [1, head []]
11:19:06 <lambdabot>  2
11:19:23 <Syzygy-> > head []
11:19:24 <lambdabot>  Add a type signature
11:19:32 <Syzygy-> > head [] :: Int
11:19:33 <lambdabot>  Exception: Prelude.head: empty list
11:19:43 <apfelmus> int-e: yes, maybe. the fact that the threading back actually throws away all of its hard-calculated results seriously hinders tying knots. one has to gather them separately.
11:19:48 <Syzygy-> > tail [1,head []]
11:19:49 <lambdabot>  Exception: Prelude.head: empty list
11:20:14 <int-e> apfelmus: if any operation can tie the knot it's insert.
11:23:20 <SyntaxNinja> xerox: what version of cabal does cabal-install need? can you fix its .cabal file?
11:23:56 <apfelmus> int-e: m = insert key m is crap because we are given m before doing anything. but if the holes could get a representation different from ()? something along  Map k (a -> b)
11:26:29 <SyntaxNinja> dcoutts dcoutts_alive?
11:26:47 <int-e> I don't see how. Right now my view is that the blueprint is a skeleton - it provides structure. The result map is a bit ethereal, it consists completely of holes. insert and update copy part of the skeleton to shape that result, leaving other parts immaterial.
11:28:47 <int-e> note that even the structure of the future (i.e. its skeleton) consists of holes.
11:29:21 <int-e> Hehe. That must sound really weird.
11:30:08 <vincenz> Anyone know hwo to surf to a password protected homepage with lynx?
11:31:18 <apfelmus> int-e: :) but the main point of the holes is to be filled in later. there must be some isomorphism between the data with contents Map a b and the structure Map a () paired with some (Stuff b).
11:32:19 <apfelmus> int-e: like [a]Â is ~ Natural -> a
11:32:38 <apfelmus> ~ [()] -> a
11:36:39 <apfelmus> mh, should be [a] ~ ([()], [()] -> a)
11:36:51 <int-e> apfelmus: well, how do you poke holes into a data structure?
11:37:27 <apfelmus> @poke hole into [a]
11:37:28 <lambdabot> Maybe you meant: more vote
11:37:35 <vincenz> Anyone familiar with lynx or links?/
11:37:41 <int-e> [a] ~ Natural -> a is wrong.
11:38:19 <apfelmus> int-e: yes, but ([()], [()] -> a) should do. it's a bit ugly though.
11:39:46 <int-e> apfelmus: not really. [()] is isomorphic to Natural. You're encoding infinte lists.
11:40:07 <int-e> i.e. streams
11:40:29 <int-e> hmm.
11:40:35 <apfelmus> int-e: mh? but if i carry the list length around? [()] x ([()] -> a)
11:40:52 <int-e> Ok, you added a length. but then it's still not isomorphic.
11:41:10 <int-e> you get an injection [a] ->  [()] x ([()] -> a)
11:41:15 <apfelmus> int-e: o.O
11:41:46 <d04mse> vincenz... are you there?
11:41:55 <vincenz> d04mse: yes
11:42:01 <d04mse> we need your help! :)
11:42:15 <d04mse> remember your solution last time?
11:42:18 <apfelmus> :t map (snd x) . tails . fst $ x
11:42:20 <weitzman> Is it possible to make this statement fail by intejecting ($!) and/or seq?
11:42:21 <weitzman> let x = map (+1) [1, head []] in head x
11:42:22 <int-e> apfelmus: anyway, if you manage to make a pair (a, b) where a is a value and b is a hole, I'd like to hear about it.
11:42:33 <apfelmus> @type map (snd x) . tails . fst $ x
11:42:34 <lambdabot> Not in scope: `x'
11:42:35 <lambdabot>  
11:42:35 <lambdabot> <interactive>:1:28: Not in scope: `x'
11:42:39 <apfelmus> @type \x -> map (snd x) . tails . fst $ x
11:42:41 <lambdabot> forall b a. ([a], [a] -> b) -> [b]
11:44:03 <apfelmus> int-e: hah, Map a b ~ (Map a ()) x (Map a () -> b) should do, shouldn't it?
11:44:24 <int-e> no.
11:44:47 <apfelmus> int-e: ah, now i see. the inverse is not injective.
11:44:52 <int-e> tree structures are trickier.
11:45:06 <d04mse> @paste
11:45:07 <lambdabot> http://paste.lisp.org/new/haskell
11:45:33 <int-e> for lists, [()] descibes both the structure of a list and a path to an element of a list. for map, the path is different (replaces products by sums)
11:50:23 <apfelmus> int-e: ah, i see. (leaving invariants of Map a b completely aside). but there is differentiation for data structures! http://www.cs.nott.ac.uk/~ctm/dfordata.ps.gz
11:51:02 <lisppaste2> d04mse pasted "match" at http://paste.lisp.org/display/26111
11:51:03 <glguy> ?hoogle (Num a, Fractional b) => a -> b
11:51:05 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
11:51:05 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
11:51:05 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
11:51:16 <glguy> anyone know what I'm looking for?
11:51:31 <d04mse> vincenz ... check what i pasted
11:51:34 <int-e> apfelmus: btw - this is a generalization of tying the knot, if done right. I can define  insert :: k -> Map k a -> a -> Map k a
11:52:03 <int-e> apfelmus: and in the base case of the splitSeq I could then just do splitSeq m [] = m.
11:52:07 <apfelmus> int-e: tree = 1 + tree x tree, thus tree' = 2 x tree and that's the paths to every element
11:52:09 <apfelmus> and tree a ~ (tree ()) x (2*tree () -> a)
11:52:13 <vincenz> d04mse: sorta busy
11:52:22 <d04mse> :(
11:52:48 <int-e> apfelmus: that's splitSeq' of course.
11:52:55 <d04mse> well... could you do it when you got some time then.. pleaase... 2 hours to go...
11:53:44 <int-e> apfelmus: and I got the signature for insert wrong. I mean k -> a -> Map k a -> Map k a -> a -> Map k a  (key, final value, blueprint, future, result value, unthreaded future)
11:54:06 <apfelmus> the second is tree' of course
11:54:28 <int-e> apfelmus: the last two are supposed to be a pair. I should type slower and think a bit more.
11:54:28 <ventonegro> it's easy to make a binary Tree : Tree a = Leaf a | Branch (Tree a) (Tree a)
11:54:37 <ventonegro> what about a n-tree?
11:55:24 <int-e> ventonegro: how about  Tree a = Node a [Tree a]
11:55:43 <apfelmus> int-e: only thinking slower allows typing slower :)
11:55:46 <int-e> ventonegro: just an idea, it's probably not exactly what you want.
11:56:46 <ventonegro> int-e, hum... could work
11:56:53 <int-e> apfelmus: the point with tying the knot is that the structure of the result is always fixed. hence the blueprint degenerates into a simple value.
11:57:11 <araujo> hi!
11:57:14 <araujo> @yarr!
11:57:14 <lambdabot> Aye
11:57:45 <int-e> apfelmus: or that's what I'm thinking right now.
11:57:51 <jbalint> you know talk like a pirate day is coming!
11:57:58 <int-e> dcoutts__: hi
11:58:08 <glguy> ?yow
11:58:09 <lambdabot> They collapsed ... like nuns in the street ... they had no teen
11:58:09 <lambdabot> appeal!
11:59:48 <vincenz> @proton
11:59:48 <lambdabot> so this java guy I know says that java is the best when things get really complex and u need your apps do do real work
12:00:22 <apfelmus> int-e: i'm puzzled?
12:04:05 <apfelmus> int-e: ah the final value should be [], that's what the blueprint contains
12:04:29 <d04mse> is it possible somhow to do what you think that i want to do with this : matchhh wildcard t s = (t1=t) . (s1=s) ??
12:05:17 <d04mse> to change a variable direct like that?
12:06:12 <int-e> apfelmus: trivial example: cycle l = let c = l ++ c.  with blueprints this becomes: c () {- trivial blueprint - our result is a list -} a {- the argument -} b {- the value to use for the future at end -} = if null a then b {- fix future -} else head a:c () (tail a) b
12:06:22 <int-e> apfelmus: which is obviously isomorphic.
12:07:27 <int-e> apfelmus: (this is what happens when all threading operations are trivial, without any pattern matches)
12:08:01 <int-e> apfelmus: hence the claim that tying a knot is a special clase of using blueprints.
12:11:41 <int-e> apfelmus: thanks for this discussion, it clarified a few things about what I've been doing there for me.
12:11:48 <apfelmus> int-e: so cycle l == let b = c () l b in b.
12:12:18 <int-e> apfelmus: yep
12:13:31 <int-e> apfelmus: hmm. that's still tying the knot, I see. I need to think about this some more.
12:13:39 <apfelmus> int-e: nothing to thank for :) i'm not doing it for your sake only ;)
12:13:39 <xerox> SyntaxNinja: I think it should build with Cabal shipped in 6.4.1.
12:14:44 <apfelmus> int-e: i'm still puzzled about this trivial blueprint. i mean b :: [a] is a very different structure than () ??
12:15:15 <int-e> apfelmus: I treat it as a simple value, i.e. as b :: a
12:16:08 <int-e> apfelmus: so there's only one possible shape that value comes in, and I used () to encode that.
12:18:13 <int-e> apfelmus: My tying the knot as a special case of blueprints idea is wrong it seems. But the two techniques can be combined. I can write a splitSeq that ties the produced lists into a cycle, with relatively little effort, now.
12:18:26 <apfelmus> int-e: you mean because it would be update that looks into the shape?
12:18:59 <int-e> apfelmus: by using Map k a instead of Map k () for the blueprint, as I proposed a short while ago.
12:20:09 <apfelmus> int-e: can you post the code? i still don't see anything :-P
12:21:08 <int-e> apfelmus: I've not coded it actually. I'm shying away from modifying the update to copy the necessary values, these rotations are a mess.
12:22:14 <int-e> Hmm, I'll just take the code without rotations and modify that.
12:23:03 <apfelmus> int-e: yeah, take the non-rotating code. rotating is possible and therefore left as an exercise to the interested reader :)
12:31:57 <lisppaste2> int-e pasted "blueprints, simplified slightly + tying knots" at http://paste.lisp.org/display/26112
12:32:26 <int-e> apfelmus: there you go
12:32:38 <int-e> apfelmus: note that `map` is gone.
12:39:42 <int-e> apfelmus: note also how the blueprint looks more and more like a real value :)
12:40:25 * apfelmus .... still think...ing .....
12:43:33 <apfelmus> int-e: when not tying knots (i.e. leaving the commented code commented), you actually muddled map (const []) into insert. but i somehow have a bad feeling when knot tying gets activated.
12:44:41 <int-e> apfelmus: muddled or not. the code is nicer this way, and insert takes a key and a value instead of just a key which feels good.
12:45:35 <shapr> edwardk: Hey, you were talking about sharing a room? I'm looking for something tomorrow night...
12:45:43 <int-e> apfelmus: we can now think about the code as threading a single value from the start to the end of the computation, where it gets reflected and threaded back again
12:46:13 <apfelmus> int-e: yes, of course (muddle was a bad word for that). and actually key and value both get into to the blueprint, that's good.
12:46:17 <int-e> apfelmus: with mismatching types viewing it that way was way harder.
12:49:14 <apfelmus> int-e: aha! the blueprint gets structured on its way down and gets filled on its way back up. that's a good picture.
12:49:37 <dcoutts__> int-e: hia
12:49:40 <dcoutts__> int-e: btw, your gtk2hs for 6.6 patch is still sitting in my to-be-reviewed box, I've not forgotten it
12:49:44 <dcoutts__> I've applied all but that last tricky one
12:49:48 <dcoutts__> I'm still thinking about the best way to do that
12:50:18 <fasta> How old is the "read" function?
12:50:24 <int-e> dcoutts__: I knew you were looking at it yesterday.
12:51:02 <shapr> @seen edwardk
12:51:03 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 4h 26m 12s ago.
12:51:55 <edwardk> heya
12:53:13 <apfelmus> int-e: though i think the knot tying code will just generate an infinite   cycle (channel-event-list)
12:53:16 <int-e> apfelmus: <dark scene, lightning flashes, ominous dark voice> "Dear Map, meet your future self." </>
12:53:17 <apfelmus> int-e: i have to go now, see you next time!
12:53:33 <int-e> apfelmus: the cycle tying code is just a silly example, not useful at all.
12:54:07 <apfelmus> int-e: hehe :)
12:55:03 <apfelmus> ok, so see you!
12:55:08 <int-e> good night to you
13:01:50 <ndm> @google ghc specialise
13:01:53 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/specialise/Rules.lhs
13:01:53 <lambdabot> Title: CVS log for fptools/ghc/compiler/specialise/Rules.lhs
13:08:14 <hyrax42> hm
13:09:06 <hyrax42> I just tried a (relatively naieve, admittedly) approach to the anagrams problem
13:09:59 <hyrax42> using a Map [(Char, Int)] [String]
13:09:59 <hyrax42> but is disgustingly slow
13:10:06 <hyrax42> are Maps not too great performance-wise?
13:10:19 <hyrax42> in the face of many insertWiths?
13:10:40 <hyrax42> @paste
13:10:40 <lambdabot> http://paste.lisp.org/new/haskell
13:11:45 <lisppaste2> hyrax42 pasted "naive anagrams" at http://paste.lisp.org/display/26117
13:12:05 <hyrax42> (if anyone cares to look)
13:14:27 <lisppaste2> hyrax42 annotated #26117 with "with imports" at http://paste.lisp.org/display/26117#1
13:22:37 <emu> is there a better way to read n lines from input besides an explicitly recursive function?
13:23:11 <shapr> Can't you pull the recursion out into a combinator?
13:23:22 <Cale> replicateM n readLn
13:24:10 <emu> @hoogle replicateM
13:24:10 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
13:24:11 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
13:28:03 <Cale> In turn, replicateM is built from replicate and sequence
13:28:25 <Cale> replicateM n = sequence . replicate n
13:31:15 <emu> cool
13:31:51 <ventonegro> the best way to implement graphs in Haskell is with a list of vertices and edges?
13:32:37 <emu> ?pl \n -> sequence . replicate n
13:32:38 <lambdabot> (sequence .) . replicate
13:33:19 <xerox> ?docs Data.Graph
13:33:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
13:33:26 <xerox> Maybe that, ventonegro? :)
13:33:30 <ventonegro> xerox, thanks!
13:33:41 <xerox> I suppose there are many implementations of graphs anyway.  Like there are for threes.
13:33:44 <ventonegro> so many things to learn, so little time
13:34:21 <shapr> Yay, I have a place to stay tomorrow night!
13:34:47 <edwardk> is that version of data.bytestring mentioned in the stream fusion paper available? or were the functions named in it just nicely named versions of the ones that are in the copy online
13:34:51 <edwardk> =)
13:36:38 <ventonegro> xerox, vertices are Int there :-(
13:36:53 <ptolomy> Oooh.  The Haskell Wiki gallery page is on programming.reddit.com.
13:43:32 <int-e> edwardk: the function names differ slightly. the stuff is in current darcs base libraries, and also in dons' fps repository, I believe.
13:43:38 <int-e> @where fps
13:43:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:43:48 <vincenz> oasis
13:44:02 <edwardk> int-e: k. i just couldn't find any reference to yielding in the copy that was on dons' repository
13:44:08 <edwardk> so it seemed a little odd
13:44:09 <vincenz> hi
13:44:10 <dfranke> so I need to learn gtk2hs...
13:44:17 <dfranke> I thought a calculator would be a bit cliche.
13:44:24 <dfranke> So I'm doing a Klein-4 calculator.
13:50:23 <xerox> @karma QuickCheck
13:50:24 <lambdabot> QuickCheck has a karma of 10
13:50:29 <xerox> @karma quickcheck
13:50:30 <lambdabot> quickcheck has a karma of 0
13:50:35 <xerox> QuickCheck++
13:51:26 <vincenz> quickcheck--
13:51:32 <vincenz> @karma quickcheck
13:51:32 <lambdabot> quickcheck has a karma of -1
13:51:37 <vincenz> @karma Quickcheck
13:51:37 <lambdabot> Quickcheck has a karma of 0
13:51:42 <vincenz> o.O
13:51:45 <vincenz> @karma QuickCheck
13:51:46 <lambdabot> QuickCheck has a karma of 11
13:51:53 <vincenz> @tell dons karma should be case insensitive
13:51:53 <lambdabot> Consider it noted.
13:52:31 <yacstud> hello, is the SoC project "HaskellNet" finished ?
13:52:57 <xerox> vincenz: known issue :)
13:53:41 * vincenz nods
13:54:28 <dmwit> yacstud: http://www.haskell.org/pipermail/haskell/2006-August/018393.html
13:54:31 <lambdabot> Title: [Haskell] status report of HaskellNet, http://tinyurl.com/rq89y
13:56:27 <yacstud> dmwit, thanks. should have googled a bit
14:02:07 <shapr> yacstud: It is
14:02:26 <shapr> yacstud: I was the mentor for that project, so it's possible I could answer questions you may have.
14:03:04 <emu> yow, managed to fit an fps version of SUMITR in 256 bytes, even with the "import qualified Data.ByteString.Char8 as B"
14:03:19 * shapr throws a 125mm crank at beelsebob 
14:04:53 <yacstud> shapr, i'm just a newbie looking for a library to deal with client http connections. but i found http://www.haskell.org/http/
14:04:54 <lambdabot> Title: Haskell HTTP package
14:05:08 <edwardk> doing the data.bytestream style fusion seems a lot less suitable for a generic [a], coz without cheap backwards traversals foldr and map don't play nice together, etc.
14:06:46 <edwardk> well, rather foldr doesn't play nice with anyone, map doesn't care
14:06:53 <emu> > (+1) . (*2) $ 3
14:06:54 <lambdabot>  7
14:06:58 <emu> > (+1).(*2) $ 3
14:06:59 <lambdabot>  7
14:07:03 <emu> > (+1).(*2)$3
14:07:04 <lambdabot>  7
14:07:10 <emu> is it legitimate to remove those spaces?
14:07:16 <edwardk> watch out when putting the $ next to something on the right
14:07:26 <edwardk> $foo and $ foo mean different things when -fth is on
14:07:39 <emu> -fth?
14:07:42 <ValarQ> whats -fth?
14:07:49 <genneth> template haskell
14:07:52 <edwardk> and that is implied by -fglasgow-exts or so it says in the template haskell docs
14:07:59 <emu> hmm
14:08:07 <emu> how about f.g where f and g are functions?
14:08:12 <edwardk> thats fine
14:08:28 <emu> i have a line with "map k.B.words" in it
14:08:33 <emu> nice and confusing heh
14:08:34 <xerox> But it's ugly.
14:08:38 <edwardk> the module stuff seems to be pretty good at disambiguating that
14:08:43 <xerox> map k . B . words
14:08:45 <edwardk> but its ugly as sin ;)
14:08:55 <emu> xerox: 256 char limit
14:09:06 <xerox> Then what are you complaining about? :)
14:09:19 <emu> oh, i wasn't sure if it was legit, since the Gentle Intro seems to say it's not
14:10:03 <genneth> actually, that's an interesting point; is haskell like C++ in the sense that parsing it is a bit of a nightmare?
14:10:28 <genneth> c++ needs semantic information to run the parser (and possibly even just the lexer)
14:10:33 <gmh33__> genneth: I'd imagine haskell is easier to parse
14:10:36 <yip> haskell is probably about as difficult to parse as c++
14:10:53 <fasta> genneth: parsing from scratch is
14:10:55 <Cale> Haskell has infix operator declarations
14:11:07 <LiquidEngineer> Hello
14:11:19 <Cale> which specify associativity and precedence
14:11:22 <LiquidEngineer> Is there a howto or guide somewhere regarding how to read/write types?
14:11:24 <LiquidEngineer> from files?
14:11:38 <LiquidEngineer> I.e.: Read a list of (int,int) tuples, write a list of ints
14:12:11 <fasta> LiquidEngineer: you are not being very clear
14:12:12 <Cale> ah, values :)
14:12:24 <LiquidEngineer> My apologies
14:12:31 <twanvl> > read "[(1,2),(3,4),(5,6)]" :: [(Int,Int)]
14:12:32 * fasta thought he wanted to use TH
14:12:33 <lambdabot>  [(1,2),(3,4),(5,6)]
14:12:33 <yip> LiquidEngineer: you can use show and read functions for simple things
14:12:49 <Cale> hPrint :: Show a => Handle -> a -> IO ()
14:12:51 <fasta> But he wants to do simple things :)
14:13:05 <LiquidEngineer> TH?
14:13:15 <fasta> LiquidEngineer: you don't want to use that.
14:13:25 <fasta> LiquidEngineer: Template Haskell
14:13:29 <Cale> hGetLine :: Handle -> IO String
14:13:38 <genneth> Cale: aha, so semantic info is definitely needed to run the syntax parser; what about lexer though?
14:13:41 <LiquidEngineer> so just getline, then?
14:13:50 <LiquidEngineer> I was hoping there was something like a tokenizer
14:13:55 <Cale> genneth: no, not the lexer, afaik
14:14:00 <yip> what about that "scrap your boilerplate"... couldn't that be used to do automatic "serialization" and "deserialization" of haskell values?
14:14:01 <fasta> LiquidEngineer: basically a broken implementation of Scheme macros with Haskell syntax.
14:14:45 <fasta> yip: nothing is "automatic" in Haskell unless you generate it. You can't express it in Haskell.
14:14:49 <Cale> genneth: in fact, basically, you just parse the operators without worrying about associativity and such and then correct it later after you've read all the infix declarations
14:15:41 <edwardk> haskell is harder to parse than c++, the operator precedence rules can vary so you have to build up the whole tree and then parse.
14:15:42 <genneth> Cale: sure; that's how C++ parsers now work: parse a superset, then use semantic info to disambiguate
14:15:43 <Cale> genneth: so it's context-sensitive, but not that ad
14:15:46 <fasta> yip: The "generic" traversals from those articles are not truly generic as Haskell is not a Lisp.
14:15:47 <Cale> *bad
14:15:49 <LiquidEngineer> yip: scrap your boiler plate?
14:16:04 <edwardk> you can have an infix rule farther down the file that affects stuff above it
14:16:13 <yip> fasta: why aren't they generic?
14:16:14 <emu> LiquidEngineer: what's wrong with read?
14:16:25 <gmh33__> ugh this new routine is rough..
14:16:36 <fasta> yip: because you need to define an instance to implement the traversal.
14:16:38 <genneth> LiquidEngineer: remember that because haskell is lazy, it will start to perform the read before the hGetLine is finished
14:16:52 <fasta> yip: and they are not transparant.
14:16:58 <LiquidEngineer> emu: Nothing's wrong with readline or read
14:17:05 <fasta> yip: you need to use something like mkT, or something like that.
14:17:06 <shapr> fasta: You could say that Template Haskell is a safe version of Scheme macros :-)
14:17:07 <genneth> fasta: surely that's just an instance of haskell requiring type annotations
14:17:23 <LiquidEngineer> I was just wondering if there was anything especially svelte like python's pickler or java's string tokenizer
14:17:28 <emu> a safe version of hygenic macros?
14:17:30 <fasta> genneth: what do you mean?
14:17:35 <fasta> shapr: I don't agree.
14:17:37 <emu> LiquidEngineer: Parsec?
14:17:44 <ndm> @where paste
14:17:44 <lambdabot> http://paste.lisp.org/new/haskell
14:17:46 <gmh33__> I've heard parsec is pretty slick
14:17:49 <emu> LiquidEngineer: i mean you can read Haskell values in pretty easily with read
14:17:50 <yip> fasta: then what exactly is "scrap your boilerplate" supposed to do, if not generic programming?
14:17:52 <genneth> LiquidEngineer: for each datatype, you can declare it to be deriving Show
14:17:53 <Cale> gmh33__: it is :)
14:17:57 <xerox> gmh33__: you've heard right!
14:17:58 <LiquidEngineer> parsec?
14:18:02 <emu> LiquidEngineer: did you see twanvl's example
14:18:03 <lispy> @where lambdaweb http://lambdabot.codersbase.com
14:18:04 <gmh33__> parser generator
14:18:04 <shapr> fasta: Well, 'broken' isn't very informative, it sounds more derisive.
14:18:04 <lambdabot> I know nothing about lambdaweb.
14:18:08 <Cale> It's a library for building parsers
14:18:11 <LiquidEngineer> emu: where?
14:18:12 <lispy> @where+ lambdaweb http://lambdabot.codersbase.com
14:18:12 <lambdabot> Done.
14:18:21 <emu> -> read "[(1,2),(3,4),(5,6)]" :: [(Int,Int)]
14:18:24 <gmh33__> @where parsec
14:18:24 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
14:18:26 <emu> > read "[(1,2),(3,4),(5,6)]" :: [(Int,Int)]
14:18:27 <lambdabot>  [(1,2),(3,4),(5,6)]
14:18:32 <fasta> yip: Basically this Ralf character looked at generic traversals in e.g. Scheme, and thought:"
14:18:33 <shapr> fasta: How do scheme macros handle type safety?
14:18:35 <emu> is that what you want?
14:18:37 <edwardk> template haskell is like the bastard child of scheme macros. they always will appear mangled, they require an explicit splicing operator, their internal syntax is far from natural, etc.
14:18:42 <fasta> let's apply that to Haskell".
14:18:42 <lispy> lambdabot's web interface needs a logo
14:18:45 <emu> shapr: dynamic types :P
14:18:55 <LiquidEngineer> emu: pretty much, yeah
14:18:55 <edwardk> shapr: type safety? you're talking scheme =)
14:19:04 <LiquidEngineer> thanks.
14:19:08 <LiquidEngineer> I'll play with this
14:19:17 <emu> LiquidEngineer: you need to add a type-cast to the output of read, and it'll choose that particular overloaded version
14:19:24 <shapr> edwardk: Yeah, just trying to make the point that 'broken' or 'safe' depends entirely on the point of reference.
14:19:35 <LiquidEngineer> I figured it'd be read/readline, but I( wanted to make sure there wasn't a more specialized way to do it
14:19:38 <LiquidEngineer> thanks.
14:19:40 <LiquidEngineer> bye
14:19:40 <fasta> yip: I think he tried to accomplish to get a paper published.
14:20:22 <yip> fasta: so his implementation is flayed.... but the idea is still good, right?
14:20:24 <fasta> shapr: Why would they need to? Scheme is dynamically typed.
14:20:44 <shapr> fasta: As I just said, broken or safe depends entirely on your point of reference.
14:21:03 <fasta> yip: no, the idea cannot really be applied in Haskell. If you start generating code it "works", but then you are not using Haskell anymore.
14:21:04 <shapr> begrijp het?
14:21:39 <fasta> shapr: yes, that's true, I think I saw too much Scheme to be impressed by it.
14:21:59 <shapr> I saw a bunch of scheme too (SICP) but I still prefer Haskell and its characteristic approach.
14:22:09 <genneth> fasta: i think we all understand that scheme metaprogramming can be a lot more concise than TH
14:22:21 <shapr> One major difference with TH is that you get type safety.
14:22:27 <shapr> At least, one level of type safety.
14:22:52 <shapr> I wonder what you would call the strong normalization equivalent in type systems.
14:23:06 <xerox> @get-oleg!
14:23:06 <lambdabot> Unknown command, try @list
14:23:24 <shapr> TH can generate illegally typed output, thus the type checking stage runs after every generate stage.
14:23:46 <cinema> bringert, ping
14:23:58 <shapr> MetaOCaml has a different approach at the type safety level though I forget the details.
14:23:59 <weitzman> Multi-staged typed compilation? That's strangely familiar
14:24:18 <bringert> cinema: yes?
14:24:27 <shapr> I particularly enjoy multi-staged typed compilation when doing Epigram.
14:24:30 <genneth> :p
14:24:37 <genneth> shapr: we all wish for epigram...
14:24:38 <cinema> bringert, I have some problems with the test program in haskell db
14:24:50 <bringert> what?
14:24:52 <weitzman> I'm currently talking a class on type-preserving compilation of higher-order typed languages
14:24:53 <xerox> edwinb: wake up
14:24:58 <shapr> I can barely contain my excitement about Epigram 2
14:25:02 <cinema> bringert, I get user error (Couldn't load Database.HaskellDB.FlatDB.driver from package haskelldb-flat-0.10)
14:25:12 <shapr> weitzman: Oh that sounds like fun! Did you cover stuff like proof carrying code?
14:25:14 <cinema> bringert, for all my drivers
14:25:23 <genneth> shapr: it would require an even more disciplined method to software construction though
14:25:25 <bringert> and they are installed?
14:25:32 <cinema> bringert, I suppose I forgot something
14:25:39 <bringert> cinema: what platform and what version of hs-plugins
14:25:48 <weitzman> shapr: Well, we're only in the 3rd week or so. I don't think that's on the agenda. We're going to compile SML, essentially. There won't be time to do typed assembly, even
14:25:59 <cinema> bringert, Linux FC5, hs-plugins from darcs
14:26:01 <weitzman> All we've talked about so far are singleton kinds
14:26:04 <bringert> hmm
14:26:09 <genneth> shapr: that's actually one thing i've been wondering about; things like epigram doesn't encourage experimentation; the cost of a program that gets past the type checker is pretty high
14:26:14 <weitzman> We're about to learn the first stage IL
14:26:16 <bringert> cinema: can you test hs-plugins?
14:26:18 <shapr> genneth: I'm not convinced that's true... look at it from the codemonkey perspective: If the IDE won't let you do it, you probably won't do it. Thus Epigram inside an IDE like the XEmacs interface won't require more discipline unless you're already able to think for yourself =)
14:26:28 <cinema> bringert, I have installed SQLite3, ODBC
14:26:42 <cinema> bringert, How do I test hs-plugins
14:26:44 <fasta> shapr: I would say that Haskell is a more practical language to program in than Scheme, but that's basically a library problem (which is caused by the fact that universities have stopped educating Lisp largely).
14:26:54 <bringert> if the haskelldb driver packages are installed, but can't be loaded, it's normally a hs-plugins problem
14:27:02 <emu> weitzman: which class#
14:27:10 <bringert> cinema: I can't remember exactly
14:27:11 <cinema> bringert, that sounds reasonable
14:27:19 <weitzman> http://www.andrew.cmu.edu/course/15-501-819/
14:27:21 <lambdabot> Title: 15-501/15-819 HOT Compilation, Fall 2006
14:27:22 <shapr> fasta: I don't know, but I know I prefer Haskell myself.
14:27:26 <bringert> try looking around in the hs-plugins dir
14:27:30 <bringert> or talk to dons
14:27:35 <cinema> bringert, I'll try yi
14:27:37 <shapr> hej sris
14:27:58 <shapr> fasta: I would have thought that Guile would make scheme more commercially popular.
14:28:00 <sris> hi, shapr?
14:28:06 <shapr> sris: god morgon!
14:28:14 <fasta> shapr: Guile is GPL, how could that ever be true?
14:28:22 <genneth> shapr: a lot of the industrial code i see (*cough* IBM *cough*) is some ungodly method to do some simple thing; the issue is usually that the code works for the usual cases, but in a completely non-trivial way; presenting this to the compiler in an acceptable format may be beyond what is expedient for that kind of situation
14:28:30 <sris> shapr, do i know you?
14:28:43 <shapr> No, but you should! Because I'm cool!
14:28:43 <emu> if guile wasn't a piece of shit maybe
14:28:44 <shapr> and modest...
14:28:48 <fasta> sris: shapr wants to know everyone
14:28:51 <shapr> sris: Jag bara skojar =)
14:29:01 <genneth> sris: it's one of his best qualities :D
14:29:02 <shapr> Oh boy, my mother is here with a birthday cake! whee!
14:29:03 <shapr> bbl!
14:29:11 <xerox> Happy birthday!
14:29:11 <sris> this is madness ;)
14:29:14 <yacstud> emu, Guile is a piece of shit ??
14:29:15 <genneth> oooh
14:29:18 <genneth> happy birthday!
14:29:42 <fasta> emu: what do you think of Scheme48?
14:30:09 <emu> admittedly i stopped caring about scheme about 5 years ago
14:31:19 <Ulfalizer> http://www.youtube.com/watch?v=br0SpQqMDPQ   best music video ever.. =)
14:31:55 <Ulfalizer> while we're being on-topic that is
14:33:40 <wkh> http://www.youtube.com/watch?v=UHTewf7oMfI mark and sweep on these nuts, bitches
14:33:41 <lambdabot> Title: YouTube - Monzy - So much drama in the PhD
14:34:30 <yacstud> Haskell lacks a good video like the famous "Erlang movie" !
14:36:31 <ptolomy> yacstud: I'm really hoping someone has a video camera on their phone for the hackathon afterparty and records a Simon doing something crazy. That would top Erlang for sure. :-P
14:38:11 <xerox> ptolomy: haha do it!
14:38:29 <ptolomy> Oh, I couldn't attend. Family commitment. :-/
14:39:08 <emu> ?hoogle rand
14:39:09 <lambdabot> Test.QuickCheck.rand :: Gen StdGen
14:39:09 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
14:39:09 <lambdabot> Random.randomIO :: Random a => IO a
14:41:47 <fasta>  // Some of this bignum code is quite mind-boggling. There is a bug in
14:41:56 <fasta>  // it that causes it not to work on mac systems (something to do with
14:42:12 <gmh33__> eep.. the erlang marketting video is scurry lol
14:42:20 <fasta>  // the fact that those machines store bytes in a different order I
14:42:30 <fasta>  // assume). I have to admit I can't quite figure it all out anymore.
14:42:37 <edwardk> hahaha
14:42:41 <fasta> In a C++ Scheme implementation.... LOL
14:42:42 <gmh33__> / big num works on macs
14:42:50 <gmh33__> lol
14:43:32 <gmh33__>  // nevermind
14:43:40 <edwardk> gotta love non-endian safe code
14:43:58 <edwardk> big, little, bah, no one needs anything but intel =)
14:44:01 <fasta> Also, his bignums seem to work only until size 400 :)
14:44:14 <fasta> Really nice having arbitrary limits :)
14:44:17 <edwardk> heh
14:44:53 <edwardk> he probably couldn't figure out how to make the bounds grow when multiplying or whatnot and just decided to cap em
14:45:18 <fasta> edwardk: "if you don't know just go the easy way"
14:45:34 <norpan> mmmm, cigar, dalmore
14:47:21 <fasta> Is GHC implemented sanely wrt arbitrary limits?
14:47:55 <gmh33__> declarative programming NOW!
14:49:35 <fasta> ++shift; => gotta get that extra performance out of it
14:52:31 <edwardk> hey, i still to this day preincrement everything =)
14:53:04 <edwardk> ghc uses gmp, its fine. you can throw just about anything at libgmp
14:53:06 <gmh33__> otherwise the order of operations nazis will bite you in teh ass!
14:53:07 <norpan> shift+1
14:56:00 <AstralStorm> Hey guys. Are there any bindings of libcap for Haskell? Also maybe chroot call and similar?
14:56:18 <AstralStorm> You know, POSIX stuff.
14:57:03 <yip> it's easy to call c functions from haskell
14:57:28 <AstralStorm> Though I'm still a new and don't know how to do it w/o dlopen :>
14:57:38 <AstralStorm> *newb
14:57:48 <AstralStorm> Any nice guide?
14:58:24 <norpan> dlopen is a possibility, or you could just specify -llibrary on the compile line
14:59:01 <AstralStorm> ghc one, right? Then how to call the functions I've linked in?
14:59:29 <edwardk> ffi
15:00:20 <AstralStorm> Foreign.C?
15:01:04 <AstralStorm> I still have to ask, exactly _how_ to call them...
15:01:17 <edwardk> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
15:01:19 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ..., http://tinyurl.com/jj62p
15:01:55 <edwardk> foreign import ccall "foo.h foo" cfoo :: Ptr CChar -> IO CSize; -- etc..
15:02:10 <AstralStorm> Aha, a special import function :>
15:02:15 <AstralStorm> Thanks.
15:02:25 <edwardk> the docs on how to use it are there in that link
15:02:56 <AstralStorm> I see. Thanks for the link.
15:03:45 <AstralStorm> Now I can rewrite a certain app in 5 minutes. Blah @ C :>
15:04:05 <edwardk> heh
15:05:05 <mauke> I think it's possible to write a garbage collector in/for C
15:05:20 <mux> there are existing ones: boehm-gc
15:05:41 <mauke> boehm's not really written in C
15:06:14 <mauke> it assumes you're running a certain kind of machine which your C compiler targets
15:06:22 <edwardk> boehm cheats =)
15:06:40 <sris> hi shapr!
15:06:41 <edwardk> and its conservative, so it still leaks
15:06:44 <sris> im back! :D
15:06:57 <LiquidEngineer> Hello
15:06:57 <mauke> I really mean "in standard C", on top of malloc/free, etc
15:07:11 <LiquidEngineer> what does the ReadList function do?
15:07:19 <edwardk> mauke: the problem is you have no access to the root set, etc.
15:07:26 <AstralStorm> mauke: yes, sure, electric fence
15:07:32 <LiquidEngineer> Does it take something like "[Int, Int, Int]" and return [Int, Int, Int]?
15:07:33 <mauke> AstralStorm: not C
15:07:33 <AstralStorm> But still, it's flawed.
15:07:55 <mauke> edwardk: yep, you'd have to use explicit register/deregister calls for non-dynamic variables
15:08:09 <edwardk> yeah, been there, done that =)
15:08:20 <mauke> wow
15:08:28 <edwardk> heh
15:08:29 <LiquidEngineer> I tried looking it up on google, but all the reference pages were blank.
15:08:34 <LiquidEngineer> at least the ones I found
15:08:36 <astrolabe> @where hat
15:08:36 <lambdabot> www.haskell.org/hat/
15:08:51 <mauke> LiquidEngineer: where did you see ReadList?
15:09:05 <edwardk> This is why I'm such a big fan of region based memory management and linearity
15:09:06 <edwardk> =)
15:09:09 <LiquidEngineer> googled for reading lists
15:09:13 <edwardk> screw gc if you can avoid it, do so ;)
15:09:24 <LiquidEngineer> e.g.: "Haskell read list"
15:09:34 <mauke> LiquidEngineer: what's wrong with read?
15:09:51 <LiquidEngineer> Read gets a string, doesn't it?
15:09:58 <LiquidEngineer> I need a list
15:10:04 <mauke> huh?
15:10:17 <mauke> that doesn't make sense (also, a string is a list)
15:10:30 <LiquidEngineer> Wait a second
15:10:42 <LiquidEngineer> I just found a type declaration for read with some examples
15:10:48 <LiquidEngineer> it would appear it does exactly what I need
15:11:14 <mauke> ReadList can't be a function, function names start with lowercase letters
15:11:16 <LiquidEngineer> mauke: e.g.: I need to read in teh string "[Int, Int]" and get [Int, Int] back
15:11:22 <LiquidEngineer> read would seem to do exactly that
15:11:37 <mauke> > map (+1) (read "[1,2,3]")
15:11:38 <lambdabot>  [2,3,4]
15:12:25 <LiquidEngineer> Neat
15:12:32 <dfranke> yay.  http://daniel.franke.name/klein4.png
15:12:38 <AstralStorm> Uh, how does one handle C Structs in Haskell with FFI? I see no provisions for that in the doc...
15:12:53 <LiquidEngineer> Now, do do file IO it'd be something like (within a do statement):
15:13:11 <xerox> AstralStorm: I'd suggest to use some tool like c2hs!
15:13:22 <edwardk> astralstorm: xerox beat me to it =)
15:13:23 <LiquidEngineer> contents <- hGetContents fileHandle
15:13:25 <LiquidEngineer> right?
15:13:31 <LiquidEngineer> so
15:13:36 <AstralStorm> xerox: for one function? :P
15:13:42 <mauke> if you want the whole file in a single string, yes
15:13:47 <AstralStorm> Uh, I mean for one structure? :P
15:13:55 <AstralStorm> Especially simple one...
15:13:55 <xerox> AstralStorm: yeah, it's handy.
15:13:57 <LiquidEngineer> contents <- read(hGetContents fileHandle)
15:14:03 <AstralStorm> Let's look then :>
15:14:05 <xerox> AstralStorm: oh well, then you just define the Storable instance yourself.
15:14:08 <edwardk> unless you want to unwrap it by hand with a little c adapter or something
15:14:12 <mauke> LiquidEngineer: no, that doesn't work
15:14:14 <LiquidEngineer> mauke: the file is just one line
15:14:28 <LiquidEngineer> It doesn't?
15:14:35 <mauke> no, the types don't fit
15:14:48 <LiquidEngineer> I'm afraid I don't understand
15:14:50 <SyntaxNinja> dcoutts dcoutts_ around
15:14:58 <mauke> do { contents <- hGetContents fileHandle; let list = read contents; ... use list ... }
15:15:05 <AstralStorm> xerox: so I have to bit-mangle the structure myself? Uh...
15:15:17 <mauke> the type of hGetContents fileHandle is IO String, not String (which is what read expects)
15:15:23 <SyntaxNinja> @seen dcoutts_
15:15:24 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I don't know when dcoutts_ last spoke.
15:15:29 <gmh33__> @bf helloWorld
15:15:30 <lambdabot> Done.
15:15:36 <AstralStorm> I'll take c2hs then :>
15:15:39 <LiquidEngineer> oh
15:15:45 <LiquidEngineer> Is there a way around that?
15:15:57 <mauke> you could of course do { list <- do { tmp <- hGetContents fileHandle; return (read tmp) }; ... } :-)
15:16:00 <gmh33__> @bf >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]>++++++++[<++++>-]<.#>+++++++++++[<+++++>-]<.>++++++++[<+++>-]<.+++.------.--------.[-]>++++++++[<++++>-]<+.[-]++++++++++.
15:16:01 <lambdabot>  HelloWorld!
15:16:24 <AstralStorm> gmh33__: har har
15:16:29 <mauke> third solution: do { list <- liftM read (hGetContents fileHandle); ... }
15:16:39 <gmh33__> thanks Astral
15:17:01 <gkr> What's the syntax for xor in Haskell?
15:17:13 <AstralStorm> gkr: de Morgan's laws? :>
15:17:19 <gkr> Haha, buu.
15:17:24 <gkr> Is not a xor operator?
15:17:25 <LiquidEngineer> mauke: thanks
15:17:32 <gkr> Woh.
15:17:38 <AstralStorm> You can write one yourself.
15:17:52 <mauke> gkr: /=
15:18:06 <gkr> Ea! Thanks.
15:18:12 <AstralStorm>  /=... even :>
15:18:12 <gkr> I was tired of not (a == b)
15:18:26 <AstralStorm> not (a == b) isn't xor :>
15:18:42 <mauke> it totally is
15:18:51 <AstralStorm> Check yourself. It's a nand.
15:19:15 <mauke> is nand x y = not (and x y)?
15:19:15 <gkr> :_/
15:19:22 <AstralStorm> Exactly.
15:19:38 <edwardk> there is one in Data.Bits
15:19:46 <AstralStorm> edwardk: of course there is :>
15:19:50 <gkr> I think that if a and b are bool, not (a == b) = a xor b.
15:19:59 <mauke> nand False False == True; not (False == False) == False
15:20:15 <mauke> therefore /= can't be nand
15:20:31 <AstralStorm>  /= is xor
15:20:53 <AstralStorm> nor (a == b) isn't a bit op really
15:21:04 <edwardk>  /= is fine for xor when applied to bools
15:21:12 <mauke> so you're saying 'not (a == b)' is different from 'a /= b'?
15:21:46 <edwardk> @check \x y -> (a /= b) == not (a == b)
15:21:46 <lambdabot>  Not in scope: `b'
15:21:49 <edwardk> er
15:21:58 <edwardk> @check \a b -> (a /= b) == not (a == b)
15:21:58 <lambdabot>  Add a type signature
15:22:02 <edwardk> bah
15:22:14 <araujo> @type not (1 == 3)
15:22:14 <AstralStorm> Bool -> Bool -> Bool :>
15:22:16 <lambdabot> Bool
15:22:22 <edwardk> @check \a::Bool b::Bool -> (a /= b) == not (a == b)
15:22:22 <lambdabot>  Parse error
15:22:24 <araujo> @type 3 /= 3
15:22:26 <lambdabot> Bool
15:22:41 <edwardk> whats the explicit annotation for lambas?
15:22:44 <edwardk> er lambdas
15:22:57 <AstralStorm> edwardk: Same as usual, but parenthesise the lambda.
15:22:59 <araujo> > (==) (not (1 == 3)) (1 /= 3)
15:23:00 <lambdabot>  True
15:23:07 <AstralStorm> Uh.
15:23:20 <AstralStorm>  /= is an xor or not... :P
15:23:34 <edwardk> @check (\x y -> (a /= b) == not (a ==b)) :: Bool -> Bool -> Bool
15:23:34 <mauke> @check \a b -> ((a :: Bool) /= b) == not (a == b)
15:23:34 <lambdabot>  Not in scope: `b'
15:23:35 <lambdabot>  OK, passed 500 tests.
15:23:54 <edwardk> there =)
15:24:06 <edwardk> those 500 should encompass all 4 cases ;)
15:24:06 <AstralStorm> Bwah, my stupid :P
15:24:31 <mauke> @check \a b -> (a :: Bool) == b
15:24:32 <lambdabot>  Falsifiable, after 1 tests: False, True
15:24:44 <AstralStorm> mauke: uhh.
15:24:57 <AstralStorm> I know I was wrong, thank you :P
15:25:01 <edwardk> hehehe
15:25:06 <norpan> @karma- c
15:25:07 <lambdabot> c's karma lowered to -1.
15:25:17 <AstralStorm> It's a de Morgan's law third expansion :P
15:25:35 <AstralStorm> not (a and b)
15:28:18 <AstralStorm> What's the syntax for implication and equivalence of Bools?
15:29:15 <LiquidEngineer> Is 4 lines too much to past in channel?
15:29:20 <gkr> Nah.
15:29:22 <mauke> equivalence is a == b, implication is not a || b
15:29:22 <kosmikus> AstralStorm: equivalence is just equality
15:29:28 <LiquidEngineer> Okay
15:29:34 <LiquidEngineer> I've got this do statement
15:29:35 <AstralStorm> kosmikus: uhh sure :P
15:29:36 <LiquidEngineer> > main = do fileHandle <- openFile "foo.txt" ReadMode
15:29:36 <LiquidEngineer> >           input   <- do temp <- hGetContents fileHandle
15:29:36 <LiquidEngineer> >                      return (read tmp)
15:29:36 <LiquidEngineer> >           sumList <- listOfPairSums input
15:29:36 <LiquidEngineer> >           putStr "Operations complete."
15:29:37 <lambdabot>  Parse error
15:29:37 <lambdabot>  Parse error
15:29:37 <lambdabot>  Not in scope: `tmp'
15:29:37 <lambdabot>  Parse error
15:29:39 <lambdabot>  No IO allowed
15:29:46 <LiquidEngineer> Uh...sorry
15:29:47 <gkr> :_(
15:29:49 <kosmikus> AstralStorm: what mauke said ...
15:29:50 <xerox> @paste
15:29:51 <lambdabot> http://paste.lisp.org/new/haskell
15:29:53 <LiquidEngineer> I didn't know it'd do that
15:29:55 <xerox> There, LiquidEngineer.
15:30:17 <AstralStorm> kosmikus: ugly implication - I'd love something like =>
15:30:33 <mauke> @type readFile
15:30:34 <lambdabot> FilePath -> IO String
15:30:36 <lennart> ?users
15:30:42 <kosmikus> AstralStorm: just define it: a ==> b = not a || b
15:30:47 <AstralStorm> Other than that, I can impement it :>
15:30:50 <AstralStorm> Yep.
15:30:51 <xerox> ?hoogle (==>)
15:30:52 <lambdabot> seen module failed: IRCRaised thread killed
15:30:53 <lambdabot> Did you mean: (==>)
15:30:53 <lambdabot> Prelude.undefined :: a
15:30:53 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:31:04 <mauke> ?hoogle ==>
15:31:05 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
15:31:11 <lisppaste2> LiquidEngineer pasted "Do" at http://paste.lisp.org/display/26124
15:31:34 <LiquidEngineer> I included the error message
15:31:46 <AstralStorm> So I'll have to implement it.
15:31:49 <lennart> LiquidEngineer: Indent "return (read ...) more
15:31:52 <AstralStorm> Not a biggie at all.
15:32:17 <mauke> main = liftM (listOfPairSums . read) readFile "foo.txt" >> putStr "Operations complete."
15:32:55 <AstralStorm> mauke: uhh... looks terse :>
15:33:22 <LiquidEngineer> Wow.
15:33:38 <LiquidEngineer> Uh.
15:33:40 <mauke> oops, should be (readFile "foo.txt")
15:33:41 <AstralStorm> mauke: now you'll have to explain it a bit :>
15:34:23 <AstralStorm> ?hoogle liftM
15:34:24 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
15:34:25 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
15:34:25 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
15:34:25 <mauke> isn't it obvious? :-)
15:34:39 <AstralStorm> mauke: still learning all those operators :>
15:34:43 <LiquidEngineer> ....No.
15:34:45 <AstralStorm> Aha, now it's obvious.
15:34:48 <weitzman> Should the "readFile 'foo.txt'" be in parens?
15:34:55 <mauke> yes
15:35:10 <AstralStorm> Else it wouldn't work :>
15:35:30 <LiquidEngineer> main = liftM (listOfPairSums . read) readFile ("foo.txt") >> putStr "Operations complete."
15:35:33 <LiquidEngineer> Like that?
15:35:37 <AstralStorm> No.
15:35:41 <mauke> <mauke> oops, should be (readFile "foo.txt")
15:35:49 <mauke> (x) is always the same as x
15:36:01 <LiquidEngineer> main = liftM (listOfPairSums . read) (readFile "foo.txt") >> putStr "Operations complete." then
15:36:17 <AstralStorm> ?hoogle >>
15:36:18 <dmwit> mauke: what if x = a, b ? ;-)
15:36:18 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
15:36:18 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
15:36:18 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
15:36:27 <mauke> wait, that doesn't work either; I got listOfPairSums's type wrong
15:36:29 <AstralStorm> Mhm, just ignorance? :>
15:37:14 <weitzman> Wait, yeah
15:37:25 <weitzman> That main function won't do anything but read a file and ignore it
15:37:34 <mauke> readFile "foo.txt" >>= (listOfPairSums . read) >> putStr "Operations complete"
15:37:54 <AstralStorm> Now that's much more readable.
15:38:00 <LiquidEngineer> I'm really confused
15:38:07 <LiquidEngineer> What do the >>= and >> do?
15:38:09 <LiquidEngineer> \in this context
15:38:10 <AstralStorm> ^
15:38:18 <weitzman> @redo readFile "foo.txt" >>= (listOfPairSums . read) >> putStr "Operations complete"
15:38:19 <lambdabot> do { (listOfPairSums . read); putStr "Operations complete"}
15:38:35 <weitzman> Doubtful
15:38:37 <weitzman> Bug?
15:38:39 <LiquidEngineer> what?
15:38:39 <AstralStorm> Uh, wrong.
15:38:39 <mauke> LiquidEngineer: >>= and >> are the operators that implement ; and <- in do {}
15:38:45 <LiquidEngineer> Oh
15:38:58 <LiquidEngineer> I kinda figured that....but I wanted to make sure
15:39:08 <LiquidEngineer> so it's a single line do statement, then?
15:39:14 <mauke> do { a; b } <=> a >> b
15:39:15 <AstralStorm> Exactly.
15:39:25 <weitzman> @redo seems to have ignored part of my input
15:39:25 <mauke> do { x <- a; f x } <=> a >>= f
15:39:26 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 28}) "Parse error"
15:39:38 <AstralStorm> Uh?
15:40:11 <AstralStorm> Possibly lacking parens.
15:40:20 <twanvl> It was trying to parse "seems to have ignored part of my input"
15:40:31 <AstralStorm> Haha.
15:40:40 <AstralStorm> Funny lambdabot.
15:40:45 <LiquidEngineer> Okay
15:40:53 <LiquidEngineer> I feel like I get it, but it's giving me a type error
15:41:09 <mauke> what's the type of listOfPairSums?
15:41:16 <LiquidEngineer> listOfPairSums takes a list of Integer
15:41:26 <weitzman> [Int] -> IO () ?
15:41:29 <AstralStorm> Ah, it's a function.
15:41:38 <mauke> I don't care what it takes, what's its type?
15:42:00 <LiquidEngineer> it looks like listOfPairSums :: [IntPair] -> [Integer]
15:42:05 <LiquidEngineer> where IntPair is just
15:42:10 <AstralStorm> (Int, Int)
15:42:11 <AstralStorm> :>
15:42:13 <mauke> ok, then your original code was wrong
15:42:14 <LiquidEngineer> type IntPair = (Integer, Integer)
15:42:33 <LiquidEngineer> mauke: I sort of figured it wasn't quite right
15:42:39 <weitzman> Are you trying to do something with the result of listOfPairSums?
15:42:41 <mauke> don't you want to print the results somewhere?
15:42:59 <LiquidEngineer> Once I get the result of the function, I need to write it out to a file oof.text
15:43:02 <LiquidEngineer> .txt
15:43:10 <mauke> ?type writeFile
15:43:12 <lambdabot> FilePath -> String -> IO ()
15:43:48 <LiquidEngineer> ah
15:43:50 <LiquidEngineer> cool
15:43:58 <mauke> main = do { c <- readFile; let l = read c; let l' = listOfPairSums l; let str = show l'; writeFile "oof.txt" str; putStrLn "done" }
15:43:58 <LiquidEngineer> I knew there had to be a write function
15:44:17 <LiquidEngineer> l prime?
15:44:33 <mauke> or whatever
15:44:36 <weitzman>  liftM (listOfPairSums . read) (readFile "foo.txt") >>= writeFile "path.txt" >> putStr "Operations complete."
15:44:40 <weitzman> Is what I'm feeling
15:45:00 <LiquidEngineer> what's the advantage of using liftM over do {...}
15:45:13 <LiquidEngineer> \I personally like the latter better because I find it easier to read
15:45:14 <weitzman> You can confuse people who don't know haskell?
15:45:17 <mauke> it can be shorter
15:45:20 <LiquidEngineer> ah
15:45:24 <LiquidEngineer> is that it?
15:45:29 <mauke> sometimes it's easier to understand
15:45:39 <LiquidEngineer> ah
15:45:58 <weitzman> My experience recently has been that terse stuff was very confusing at first, but now it starts to be more readable
15:46:09 <mauke> @undo do { c <- readFile "foo.txt"; let l = read c; let l' = listOfPairSums l; let str = show l'; writeFile "oof.txt" str; putStrLn "done" }
15:46:10 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 47}) "Parse error"
15:46:15 <mauke> what
15:47:24 <LiquidEngineer> now that's just messed up
15:47:28 <LiquidEngineer> it's giving me a parse error on the ;
15:47:33 <weitzman> @undo do { c <- readFile "foo.txt"; let l = read c; l' = listOfPairSums l;  str = show l' in writeFile "oof.txt" str; putStrLn "done" }
15:47:33 <lambdabot> readFile "foo.txt" >>= \ c -> let { l = read c; l' = listOfPairSums l; str = show l'} in writeFile "oof.txt" str >> putStrLn "done"
15:48:54 <weitzman> @pl readFile "foo.txt" >>= \ c -> let { l = read c; l' = listOfPairSums l; str = show l'} in writeFile "oof.txt" str >> putStrLn "done"
15:48:54 <lambdabot> (line 1, column 35):
15:48:55 <lambdabot> unexpected "{"
15:48:55 <lambdabot> expecting natural, identifier or "in"
15:50:19 <weitzman> >>= is kinda like >>>, and I feel like >>> is nicer than (.)
15:50:28 <weitzman> It shows the flow of things
15:50:49 <weitzman> > sort >>> head $ [5..1]
15:50:50 <lambdabot>  Exception: Prelude.head: empty list
15:50:58 <mauke> LiquidEngineer: http://rafb.net/paste/results/AbuMN318.html
15:52:07 <weitzman> >  (sort >>> head) [5, 4, 3, 2, 1]
15:52:08 <lambdabot>  1
15:52:10 <weitzman> Hmm
15:52:18 <mauke> > [5, 4 .. 1]
15:52:19 <lambdabot>  [5,4,3,2,1]
15:52:20 <weitzman> I don't see the difference between those two expressions
15:52:24 <mauke> > [5 .. 1]
15:52:25 <lambdabot>  []
15:52:30 <weitzman> Oh
15:52:33 <weitzman> Yeah
15:52:34 <mauke> default step is +1
15:52:34 <weitzman> Good call
15:52:35 <gmh33__> > [10, 8 .. 1]
15:52:36 <lambdabot>  [10,8,6,4,2]
15:52:52 <gmh33__> yay patterns :P
15:52:52 <mauke> weitzman: same as in perl :-)
15:53:36 <weitzman> > (sort >>> map (+ 1) >>> tail) [5, 1, 2, 3, 6]
15:53:37 <lambdabot>  [3,4,6,7]
15:53:53 <weitzman> That's so clear
15:54:09 <weitzman> I don't want none o' that (tail . map (+1) . sort)
15:55:03 <gmh33__> > map (+ 1) $ sort $ tail [5,1,2,3,6]
15:55:04 <lambdabot>  [2,3,4,7]
15:55:15 <gmh33__> erm.. wrong order of stuff heh
15:55:23 <int-e> weitzman: would you believe that (sort >>> map (+ 1) >>> tail) [5, 1, 2, 3, 6] looks unnatural to me?
15:55:34 <gmh33__> > sort $ map (+ 1) $ tail [5,1,2,3,6]
15:55:35 <lambdabot>  [2,3,4,7]
15:55:59 <mauke> yeah, it should be something like run $ const [5,1,2,3,6] >>> sort >>> map (+ 1) >>> tail
15:56:00 <int-e> > tail . map (+1) . sort $ [3,1,2] -- another style
15:56:02 <lambdabot>  [3,4]
15:56:06 <LiquidEngineer> Thanks, guys
15:56:07 <weitzman> int-e: I think it would look nicer if >>> wasn't so long
15:56:09 <LiquidEngineer> it works now
15:56:12 <LiquidEngineer> or at least compiles
15:56:20 <gmh33__> woo
15:56:49 <gmh33__> > map (+ 1) $ tail $ sort [5,1,2,3,6]
15:56:50 <lambdabot>  [3,4,6,7]
15:57:10 <weitzman> I read it as a list of things to do with the input: 1) sort 2) map 3) tail
15:57:23 <dmwit> > map (+ 1) . tail $ sort [5,1,2,3,6]
15:57:25 <lambdabot>  [3,4,6,7]
15:58:00 <int-e> mauke: I don't like that.
15:59:08 <mauke> map $i++ ? $_ + 1 : (), sort qw[5 1 2 3 6];
15:59:30 <mauke> I'd like to see a haskell version of that :-)
16:00:27 <LiquidEngineer> hmm...
16:00:36 <LiquidEngineer> where does GHCi look for files by default?
16:00:51 <LiquidEngineer> like, for example, when you try to do file IO
16:01:09 <dmwit> Current working directory?
16:01:12 <mauke> in your current working directory
16:01:16 <AstralStorm> Any good c2hs howto? The one on the page doesn't have any examples :/
16:01:26 <AstralStorm> The syntax is also described a bit vaguely.
16:01:59 <LiquidEngineer> I wonder how I can figure out what eclipse is using as its current working directory...
16:02:11 <int-e> @hoogle Cwd
16:02:12 <lambdabot> No matches found
16:02:15 <AstralStorm> ?google hsc2hs
16:02:17 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/hsc2hs.html
16:02:18 <lambdabot> Title: 10.3. Writing Haskell interfaces to C code: hsc2hs
16:02:23 <mauke> @hoogle cwd
16:02:24 <lambdabot> No matches found
16:02:32 <mauke> @hoogle pwd
16:02:32 <lambdabot> No matches found
16:02:42 <int-e> @hoogle gutCurr
16:02:43 <lambdabot> No matches found
16:02:48 <int-e> @hoogle getCurr
16:02:49 <lambdabot> Directory.getCurrentDirectory :: IO FilePath
16:02:53 <int-e> hah.
16:03:22 <LiquidEngineer> cool :D
16:03:23 <mauke> stupid verbose names
16:03:27 <int-e> Directory.getCurrentDirectory >>= print  on the ghci prompt tells you
16:03:33 <mauke> getcwd is much more intuitive :-)
16:03:41 <AstralStorm> Heh, hsc2hs looks much better than c2hs
16:04:21 <LiquidEngineer> nothing happened
16:04:40 <LiquidEngineer> or, wait
16:04:44 <LiquidEngineer> is the print thing part of it too?
16:04:45 <int-e> did you add the  >>= print  ?
16:04:53 <int-e> yes, otherwise it'll ignore the result
16:04:54 <AstralStorm> LiquidEngineer: for printing, yes :P
16:05:07 <LiquidEngineer> Oh
16:05:11 <LiquidEngineer> I am indeed a goober
16:05:16 <AstralStorm> getCurrentDirectory gives a String
16:05:16 <xerox> int-e: GHC 6.5's GHCi doesn't ignore!
16:05:24 <LiquidEngineer> and it's at the root level of the eclipse project
16:05:26 <LiquidEngineer> interesting
16:05:29 <LiquidEngineer> and nice
16:05:50 <AstralStorm> @type Directory.getCurrentDirectory
16:05:52 <lambdabot> IO FilePath
16:05:52 <int-e> xerox: oh, cool. ghc(i) 6.4.2 is still what I'm using by default though.
16:06:01 <mauke> @info FilePath
16:06:01 <lambdabot> FilePath
16:06:03 <AstralStorm> Hmm, not even a String :>
16:06:04 <xerox> Yeah it's cool.
16:06:11 <mauke> AstralStorm: type FilePath = String
16:06:12 <xerox> Surprising at first :D
16:06:20 <AstralStorm> @type FilePath
16:06:21 <lambdabot> Not in scope: data constructor `FilePath'
16:06:26 <shapr> SHAZAM!
16:06:26 <AstralStorm> ?!?
16:06:27 <lambdabot> Maybe you meant: . bf ft id pl v wn
16:06:39 <mauke> AstralStorm: types don't have a type
16:06:41 <int-e> xerox: ah, only () gets ignored it seems
16:06:48 <AstralStorm> mauke: huh, maybe.
16:06:48 <LiquidEngineer> Wow.
16:06:49 <int-e> xerox: nifty
16:06:49 <AstralStorm> :>
16:06:50 <LiquidEngineer> It works
16:06:57 <xerox> int-e: indeed :D
16:07:02 <LiquidEngineer> Thanks for all your help. :)
16:07:04 <mauke> @kind FilePath
16:07:05 <lambdabot> *
16:07:43 <gmh33__> anyone with os x should appreciate that command line : )
16:07:47 <gmh33__> bahhh
16:07:50 <gmh33__> it didn't paste elll
16:08:02 <gmh33__> well*
16:08:05 <xerox> int-e: at AngloHaskell I tried to explain it when we were discussing liyang's presentation, and I nearly got myself a fool impression saying "with 6.5 you don't even need >>= print!"
16:08:14 <xerox> "...ehrm, with GHCi!" :)
16:10:16 <AstralStorm> hsc2hs is a great tool, hehe
16:11:08 <xerox> I like c2hs better.
16:11:34 <AstralStorm> c2hs has no doc. If you give me some, I might consider it :>
16:11:39 <AstralStorm> Or a nice example.
16:11:56 <xerox> It has!!
16:11:59 <AstralStorm> Also hsc2hs is in the default distribution.
16:12:17 <AstralStorm> xerox: where? The .sgml have no proper definition of the .chs syntax.
16:12:25 <gmh33__> so you can simulate these weird "variable" things with IO types?
16:12:29 <xerox> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs.html
16:12:30 <AstralStorm> And _no_ examples.
16:12:31 <lambdabot> Title: The Binding Generator C->Haskell, http://tinyurl.com/gl84m
16:12:54 <AstralStorm> Oh, I've already read that. Tell me, where is the definition and where are the examples :P
16:13:27 <xerox> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-2.html
16:13:28 <lambdabot> Title: The Binding Generator C->Haskell: Implementation of Haskell Binding Modules, http://tinyurl.com/j64dt
16:13:35 <yip> gmh33__: IORef is pretty much a variable like in imperative languages
16:13:53 <gmh33__> cool beans : )
16:13:59 <yip> indeed
16:14:07 <gmh33__> to bad I don't know what a variable is >_> <_<
16:14:09 <gmh33__> :P
16:14:11 <AstralStorm> Maybe I will use c2hs, let's try again :>
16:14:28 <AstralStorm> gmh33__: it's a name for some object. In Python, at least :P
16:14:43 <yacstud> a variable is a varying constant /o\
16:14:58 <AstralStorm> yacstud: hehe
16:15:03 <gmh33__> MY BRAIN!!!
16:15:03 <gmh33__> lol
16:15:26 <yip> gmh33__: imagine it like a cell that has a value inside it, where you can change the value over time
16:15:48 <gmh33__> variables are prison?
16:16:20 <gmh33__> meh, I know C, so this IORef thing is basically a fancy pointer
16:17:13 <gmh33__> I started learning Haskell a week or so ago, and by learning I mean "breaking my brain repeatedly" so that I can learn new things : )
16:17:20 <yip> it's actually more like a regular c variable
16:17:39 <yip> well, actually it is sort of more like a pointer maybe
16:17:53 <gmh33__> it's not actually a variable it just holds a mutable thing
16:17:56 <AstralStorm> Uh, how does one import a header with c2hs?
16:18:05 <AstralStorm> I mean how does one make .chi
16:18:23 <gmh33__> you give up your "I like to program in C" ways and jump straight into haskell ?:
16:18:42 <AstralStorm> Like? I _hate_ C.
16:18:56 <gmh33__> hate monger !
16:19:03 <AstralStorm> I'd pick anything except C. Even C++.
16:19:07 <gmh33__> gew
16:19:14 <AstralStorm> (if allowed to use STL - otherwise, not)
16:19:25 <gmh33__> C++ is not my cup of tea
16:19:39 <AstralStorm> I prefer Python to it any day :P
16:19:44 <gmh33__> Ruby :P
16:19:56 <gmh33__> or IO, that's an interesting one
16:19:59 <xerox> AstralStorm: see the first link I gave you, under `using c2hs.'
16:19:59 <AstralStorm> Ruby's ok too, though I've not much experience in it.
16:20:11 <AstralStorm> xerox: uh, no example for including...
16:20:17 <gmh33__> I love how dynamically typed Ruby is : )
16:20:19 <yip> LANGUAGE BATTLE!!!!!!
16:20:35 <gmh33__> BLARHLARHLARHLARHLARHLARH!!! (battle cry)
16:20:59 <dolio> :) How about Basic. It's the perfect learning language! (as seen on slashddot)
16:21:16 * gmh33__ cough
16:21:20 <AstralStorm> gmh33__: it's be better as: LARTLARTLARTLARTLARTLARTLARTLART!!!!11
16:21:37 <xerox> AstralStorm: including?
16:21:49 <AstralStorm> xerox: uh, I see. #include on top of the file? :P
16:21:57 <AstralStorm> .chs I mean.
16:22:15 <xerox> AstralStorm: if I understand your question, that's answered where I told you to read.
16:23:06 <AstralStorm> It is, just missed it three times.
16:23:09 <AstralStorm> :P
16:23:32 <xerox> One good advice is to read the whole tutorial one time, carefully.
16:23:40 <xerox> It explains more or less everything you need to use c2hs.
16:24:13 <gmh33__> oh and for the language battle, everyone should definitely have to learn haskell as their first language :P
16:24:19 <AstralStorm> And my vim hates #include in .chs file
16:24:54 <dolio> gmh33__: But of course.
16:25:04 <dolio> Was it Cale who taught Haskell to a bunch of grade schoolers?
16:25:24 <SyntaxNinja> xerox: have you noticed that the --user-install flag doesn't work?
16:25:29 <SyntaxNinja> I'm trying to figure it out now
16:25:33 <AstralStorm> It is much simpler than stupid Pascal to teach :>
16:25:43 <gmh33__> smalltalk :P
16:25:46 <AstralStorm> Especially with that "no loops" concept.
16:25:58 <xerox> SyntaxNinja: hmmm no!
16:25:58 <SyntaxNinja> xerox: why not just use the --user flag anyway?
16:26:12 <xerox> Let me see...
16:26:21 <SyntaxNinja> xerox: you seem to have some confusion among UserFlag and UserInstFlag and such
16:26:23 <gmh33__> most people (young programmers) choke on recursion >_>;
16:26:39 <gmh33__> by most, I mean "not me"
16:26:44 <SyntaxNinja> there is no --user flag, though you refer to it, so I removed that, and worked to replace all of the configUser by configUserInst
16:26:48 <SyntaxNinja> or whatever it is
16:27:09 <xerox> Where do I refer to a --user flag?
16:27:54 <SyntaxNinja> i deleted it :) you'll have to grep
16:28:09 <xerox> I mean, in what context?
16:28:25 <dolio> I have trouble remembering what was difficult about recursion.
16:28:30 <dolio> Or if I had trouble with it initially.
16:28:32 <AstralStorm> gmh33__: actually, recursion is simple - it's taught at maths around here.
16:28:35 <SyntaxNinja> xerox: in a comment
16:28:38 <AstralStorm> Recusive function definitions :>
16:28:47 <wkh> dolio: same
16:28:55 <dolio> Recursion is really much more mathematical than loops.
16:28:58 <AstralStorm> Loops are much harder.
16:29:02 <gmh33__> I know recursion is simple, that's why I don't understand why people choke on it..
16:29:21 <dolio> You never see a mathematical definition in terms of for or while loops.
16:29:22 <AstralStorm> Most don't, unless they're bent by using loops everywhere.
16:29:24 <AstralStorm> :>
16:29:29 * bringert fixed his first bug in ghc
16:29:43 <AstralStorm> bringert: cheers!
16:29:43 <wkh> congrats
16:30:14 <dolio> I suppose you could argue sigma/pi notation is like a loop, but that's likely to be defined by recursion.
16:30:15 <AstralStorm> xerox: why doesn't this work? (file is called Caps.hs):
16:30:17 <AstralStorm> #include <sys/capability.h>
16:30:27 <AstralStorm> type Cap = {#type cap_t#}
16:30:33 <AstralStorm> And it chokes badly.
16:30:43 <AstralStorm> The type _is_ defined in that header.
16:30:53 <xerox> "<>" -> '"' ?
16:31:45 <AstralStorm> xerox: system header!
16:31:53 <AstralStorm> And it didn't work anyway :P
16:31:59 <xerox> What's the error.
16:32:10 <xerox> SyntaxNinja: hmmm I'm looking now.
16:32:12 <AstralStorm>   Cannot find a definition for `cap_t' in the header file.
16:32:23 <AstralStorm> While the header contains:
16:32:32 <xerox> Can you try: c2hs /path/to/header.h foo.hs ?
16:32:50 <AstralStorm> typedef struct _cap_struct *cap_t;
16:32:55 <AstralStorm> Ok, let's see.
16:33:38 <AstralStorm> Got a syntax error in:
16:33:50 <AstralStorm>  /usr/include/bits/pthreadtypes.h:69: (column 6) [FATAL]
16:34:19 <AstralStorm> And it works in C :P
16:34:49 <xerox> I'm too sleepy, sorry.
16:34:54 <AstralStorm> Now, the error is in a bit hairy piece of code :P
16:35:05 <AstralStorm> I'll see the #ifdef SWIG part :>
16:35:44 <xerox> @localtime xerox
16:35:45 <lambdabot> Local time for xerox is Sat Sep 16 01:35:23 2006
16:36:03 <xerox> bbl
16:40:08 <AstralStorm> @localtime AstralStorm
16:40:22 <AstralStorm> Huh?
16:40:35 <_dolio> > 1 + 1
16:40:37 <lambdabot>  2
16:40:50 <AstralStorm> ?localtime AstralStorm
16:40:59 <AstralStorm> Hm. Doesn't work.
16:41:40 <AstralStorm> Ok. Does anyone have a suggestion about writing Haskell bindings to libcap?
16:41:45 <AstralStorm> I can't get c2hs to work.
16:43:07 <AstralStorm> Other than that, I'm in the same timezone as xerox :P
16:49:32 <jcreigh> AstralStorm: Perhaps your IRC client doesn't respond to CTCP TIME requests.
16:49:38 <jcreigh> @localtime jcreigh
16:49:43 <lambdabot> Local time for jcreigh is Fri Sep 15 17:49:17 2006
16:51:01 <AstralStorm> jcreigh: most likely :>
16:51:16 <AstralStorm> Anyway. What about that libcap? Any idea?
16:55:51 <bringert> AstralStorm: hsc2hs maybe? it doesn't have as much intelligence as some of the other FFI tools, but it's easy to use
16:56:10 <SyntaxNinja> xerox: any idea why RequireOrder for the cli parser?
16:58:36 <SyntaxNinja> hm. no xerox
17:02:28 <AstralStorm> bringert: I see. Looking through the GTK bindings right now and learning how to use it.
17:02:43 <AstralStorm> The funniest thing is I can't get at the _cap_struct anywhere. :P
17:03:32 <AstralStorm> Bwahaha.
17:03:42 <AstralStorm> It's a simple combination of two structs.
17:04:22 <AstralStorm> So I'll have to implement all of them with hsc2hs.
17:06:02 <AstralStorm> I'm just wondering how to write the alignment for a struct containing two substructs.
17:09:05 <AstralStorm> Hmm, and also what type to give these two substructs.
17:09:21 <AstralStorm> First I'll tangle them.
17:17:23 <ihope> So geeks use vi and/or emacs?
17:17:36 <Cale> ihope: yeah
17:18:50 <drakioned> nedit.. with haskell colourings :P
17:19:46 <ihope> nedit?
17:23:31 <hyrax42> how is the vi mode for haskell
17:23:39 <hyrax42> compared to the emacs one
17:24:25 <dons> the vim mode? good syn hl
17:24:25 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:27:12 <dolio> Vim has good coloring, but doesn't do the fancy indenting.
17:29:14 <emu> emacs haskell-mode
17:29:40 <emu> with ghci integration woot
17:31:37 <AstralStorm> Hey people, I've a struct of two structs, which layout I know, but can't bind the subtypes. How does one bind such contraptions to Haskell?
17:32:42 <AstralStorm> I've only pointers to these structs defined directly in the file it seems (or something :P )
17:34:17 <AstralStorm> The name itself is used in a typedef though.
17:36:25 <AstralStorm> Yes, it's seen as "undeclared"
17:36:35 <AstralStorm> So how does one workaround it?
17:38:07 <AstralStorm> I have a pointer to that type - just have to convert it into something usable in Haskell.
17:39:27 <AstralStorm> Any Linux user should have the header: it's sys/capability.h
17:39:43 <AstralStorm> any FFI master around here?
17:40:51 <AstralStorm> It seems it's the wrong hour. Will try tomorrow again :>
17:41:05 <heatsink> maybe I missed something.  are you using c2hs?
17:41:23 <heatsink> erm. hsc2hs
17:42:16 <bringert> ChiliX: I'm trying to build ghc-fc2 using ghc HEAD, and it fails here and there. should I send you the patches fixing that, or should I push them? Igloo says you may already have do the fc2 -> HEAD merge locally
17:42:32 <AstralStorm> heatsink: hsc2hs
17:42:38 <bringert> that's ChilliX btw
17:42:40 <AstralStorm> c2hs didn't work at all :>
17:43:21 <AstralStorm> A struct of two structs. If I can wrap it up, then I can provide other things too.
17:43:26 <heatsink> AstralStorm, It looks like you can do #ptr to get the offset of the field, then #peek to get the member of that
17:43:58 <AstralStorm> Hmm... haven't tried that yet. A good idea :>
17:45:56 <AstralStorm> Maybe I'll check hsffig out first.
17:47:45 * araujo back
17:54:19 <AstralStorm> hsffig is bust on it too :P
17:55:17 <AstralStorm> Ok, How would I use the #ptr? I've a datatype called cap_t - contains two substructs with names head and set
17:55:39 <AstralStorm> I can't access the types of these substructs - they're anonymous mostly.
18:05:40 <dons> ?uptime
18:05:40 <lambdabot> uptime: 2d 8h 2m 32s, longest uptime: 2d 8h 20m 7s
18:07:28 <Adamant> @dons
18:07:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
18:07:33 <emu> omg almost new record
18:07:42 <lispy> dons: you could almost chart the uptimes as the time between when you apply patches :)
18:11:09 <heatsink> AstralStorm, not sure.  can you use the C operator typeof()?
18:11:17 <dons> lispy: yep, that's right.
18:11:31 <dons> 11:11  dons:: ?uptime
18:11:31 <dons> 11:11  lambdabot:: uptime: 12d, 23h, 24m  51s, longest uptime: 12d, 23h, 24m  51s
18:11:43 <dons> (in another channel, that i patch less often)
18:12:59 <lispy> dons: did you see the new web shell thingy?  we need a logo
18:13:54 <lispy> dons: i was also thinking it might be cool if we could do per user settings
18:13:55 <dons> ah, haven't got that far down my email yet
18:14:04 <dons> yeah that'd be useful
18:14:19 <lispy> ah, well skip the email and look at http://lambdabot.codersbase.com/ <-- simplified the url
18:14:20 <lambdabot> Title: Lambdabot Web Interface
18:14:36 <lispy> yeah, i thought maybe the login would be optional like the wiki
18:14:58 <lispy> if you login you get enhanced experience, otherwise you get the basic shared environment
18:15:11 <lispy> i have a buddy that does OpenID stuff for a living
18:15:19 <lispy> but they don't have a haskell library for openid yet
18:15:27 <dons> ooh nice!
18:15:36 <dons> super spfiffy :)
18:15:57 <dons> really really cool!
18:16:01 <lispy> :)
18:16:07 <lispy> thank bringert :)
18:16:10 <dons> lispy++
18:16:15 <dons> bringert++
18:17:10 <lispy> i can think of little things to make it better, but yeah i like it
18:17:22 <dons> ok, so 'a' seems to stall it still?
18:17:26 <lispy> it would be cool if it showed you a list of random other commands people have typed
18:17:32 <lispy> yeah, 'a' is bad
18:17:38 <dons>         * Error: 500 Internal Server Error
18:17:41 <dons> weird
18:17:46 <dons>  and you have the latest lambdabot patches?
18:17:59 <dons> I don't think we can go live till that's sorted
18:17:59 <lispy> when is the most recent patch?
18:18:20 <lispy> if i use lambdabot from the cli i don't think 'a' is a problem
18:18:25 <dons> so if you run lambdabot on the command line, you _dont_ get:
18:18:26 <dons> lambdabot> a
18:18:26 <dons> Maybe you meant: all-dicts arr ask . v
18:18:27 <dons> ?
18:18:28 <lispy> right and i want lambdabot  to do logging, how do we enable that?
18:18:40 <lispy> i want to log ip, command and response to a file
18:18:40 <dons> ok, it should be logging into State/Log/something
18:18:58 <dons> ok, we'll need to modify the Log plugin (or the base plugin)
18:18:59 <lispy> the ip can come from the cgip
18:19:05 * heatsink only gets server errors
18:19:14 <lispy> hmm...maybe dons broke it
18:19:24 <dons> seems to work
18:19:28 <lispy> heatsink: reload it
18:19:29 <dons> heatsink: try again?
18:19:37 <kpreid> lispy: that web interface seems to append a space to whatever i type
18:19:43 <kpreid> lispy: so the "list" command, for example, can't work
18:19:58 <lispy> kpreid: hmm..what browser?
18:20:04 <kpreid> Safari
18:20:04 <dons> hmm?
18:20:04 <dons> list
18:20:05 <dons>         * http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:20:06 <lambdabot> http://tinyurl.com/jz56b
18:20:15 <lispy> kpreid: you may be the first safari user to try it
18:20:19 <kpreid> dons: I mean the form with a module name
18:20:32 <lispy> kpreid: as a cross test can you try with firefox?
18:20:56 <dons> list base
18:20:57 <dons>         * No module "base " loaded
18:20:59 <dons> yep
18:21:00 <lispy> kpreid: oh
18:21:03 <lispy> kpreid: yeah
18:21:07 <lispy> kpreid: i see now
18:21:10 <kpreid> same in firefox
18:21:14 <lispy> right
18:21:21 <lispy> must be a bug in the javascript
18:21:43 <dons> lispy, can you just confirm that 'a' works on your command line bot?
18:21:48 <lispy> dons: i'm gonna try pulling lambdabot patches again...so if there are new ones
18:22:09 <dons> also, makes me think that we should href-ify urls that the bot prints :)
18:22:10 <lispy> dons: ah, it's broken
18:22:16 <lispy> dons: which is weird
18:22:17 <heatsink> Oh! It doesn't give me an error if I don't put an @ at the beginning of the line.
18:22:27 <dons> right. it's using goa, heatsink
18:22:35 <dons> our command line wrapper over the bot
18:22:40 <lispy> dons: yeah, ndm wants me to use a different hoogle interface that has pretty htmlified results
18:22:48 <dons> that's a good idea.
18:22:54 <lispy> we need example commands on that page
18:23:01 <lispy> that's the single most common error is using
18:23:14 <dons> yep
18:23:23 <weitzman> Do you need full cygwin for darcs to work on windows? It's not clear to me exactly what "darcs with cygwin" does
18:23:34 <lispy> dons: so, why would the version in my webfolder freak out about 'a'.  Could it be that i didn't copy over something i should have?
18:23:50 <lispy> weitzman: sadly even as a darcs contributor i can't answer that
18:24:00 <lispy> weitzman: i'd try it without cygwin
18:24:10 <emu> i've had some odd problems with darcs on windows
18:24:16 <lispy> weitzman: and i think recent windows binaries doesn't need it
18:24:18 <emu> like, it would only work within cmd.exe
18:24:20 <lispy> emu: me too
18:24:20 <dons> yeah, maybe you have rebuilt? or disabled something? or didn't install back into the directory you're using?
18:24:40 <lispy> dons: well, i am using the latest one i rebuilt...
18:24:52 <dons> lispy: you could try building another bot somewhere, from scratch
18:24:59 <dons> i'll check i pushed all patches
18:25:34 <dons> yep. all pushed
18:25:46 <lispy> i'll try building it in the lambdabot dir and see if it has the problem there
18:26:24 <dons> if wonder if the error string is going to stderr or something. hmm
18:26:37 <dons> nope.
18:26:47 <dons> you didn't disable base by accident?
18:26:52 <dons> (though nothing woudl work then)
18:27:27 <lispy> i can past the modules i use
18:27:37 <lispy> ndm wanted quote but i want to disable new quotes is that possible?
18:27:56 <lispy> MODULES Base System Dict Dummy Type Eval Babel Version Pl Help Dice Search Vixen Haddock Hoogle Where Elite Djinn Pretty Compose Lambda Unlambda Slap DrHylo Instances Fresh Url Free Undo BF FT Check Small
18:28:11 <dons> yes, just remove the 'remember' command from the moduleCmd field of the Quote plugin
18:28:23 <lispy> hm...this one diverges on 'a' too
18:28:35 <dons> you pulling from the right place?
18:28:39 <dons> what ghc version?
18:28:47 <lispy> of course, and 6.4.2
18:28:49 <dons> i'll try on linux now
18:29:01 <lispy> $ darcs pull
18:29:01 <lispy> Pulling from "http://www.cse.unsw.edu.au/~dons/lambdabot"...
18:29:01 <lispy> No remote changes to pull in!
18:29:04 <dons> ok
18:29:19 <lispy> i think it has to do with the modules
18:29:27 <lispy> i think my irc enabled lambdabot doesn't have this problem
18:29:33 <dons> hmm
18:29:40 <lispy> yup
18:29:52 <lispy> Maybe you meant: all-dicts arr ask . v
18:29:54 <dons> hmm .ok. maybe 'a' is being spell checked to a command that times out..
18:30:04 <dons> i.e. all-dicts?
18:30:05 <lispy> so i should try all those suggestions
18:30:11 <dons> which wil query the dict server, and time out.
18:30:19 <lispy> is that one enabled
18:30:24 <dons> or ask, not even sure what that does :)
18:30:48 <lispy> ?help ask
18:30:49 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
18:30:54 <dons> ah right
18:30:55 <lispy> weird
18:30:57 <lispy> i should disable that
18:31:17 <lispy> ask returns immediately and all-dict is fine too
18:31:32 <lispy> oh wait, maybe 'all-dict' isn't fine
18:31:39 <lispy> i typed 'all-dict hi'
18:31:54 <dons> it'll be rewritten just to all-dict
18:31:56 <lispy> i bet i can crash your lambdabot
18:32:00 <dons> oh :)
18:32:04 <lispy> :)
18:32:10 <lispy> want me to try :)
18:32:18 <dons> gimme a sec to set up a log file
18:32:51 <dons> ok. shoot
18:33:19 <lispy> ?all-dict
18:33:21 <lispy> ?uptime
18:33:22 <lambdabot> uptime: 2d 8h 30m 14s, longest uptime: 2d 8h 30m 14s
18:33:24 <lispy> damn
18:33:27 <dons> heh
18:33:29 <lispy> my theory is shot down
18:33:37 <lispy> i was thinking it was the empty string
18:33:38 <dons> what happens on your box?
18:33:44 <jcreigh> @bf [>+]
18:33:45 <lambdabot> Done.
18:33:56 <dons> ?all-dicts
18:33:58 <lispy> ./lambdabot -> all-dict just hangs
18:34:01 <dons> ?bot
18:34:01 <lambdabot> :)
18:34:06 <dons> yes. for me too
18:34:16 <dons> the dict plugin is definately the problem
18:34:28 <weitzman> Setting up darcs is not easy :(
18:34:48 <lispy> dons: i bet it's like the empty input problem goa had
18:34:55 <araujo> weitzman, that depends ...
18:34:59 <dons> lispy: maybe.
18:35:01 <lispy> weitzman: darcs really needs a windows dev to help it
18:35:02 <weitzman> araujo: On windows, at least
18:35:03 <araujo> a simple darcs setting is very very simple!
18:35:29 <weitzman> Well, I want to set up darcs to download any arbitrary code off the web. It's proving hard than I expected
18:36:26 <dons> lispy: you going to disable the Dict plugin?
18:36:35 <lispy> dons: i bet we can patmatch the problem out of existence in the doLookup function
18:36:39 <lispy> dons: only if i have to
18:36:47 <dons> ah ok.
18:37:09 <dons> yeah, the dict problem is probably a bit old school. maybe I don't handle the empty case properly
18:37:44 <lispy> yeah okay in DictLookup.hs
18:37:51 <lispy> queryDict
18:37:57 <lispy> i'll just have it return Right ""
18:38:02 <dons> so its a network timeout issue?
18:38:17 <lispy> i don't think so
18:38:44 <lispy> i'm wondering if it's sending nothing and then waiting for something
18:38:49 <lispy> that's what happened in the case of goa
18:39:03 <lispy> the two fixes, 1) don't wait 2) send something
18:39:37 <dons> yes, I understand that. but I can't see how it can ever return nothing. if it returns [], then base rewrites that to a Nothing, and goa should be ok.
18:39:45 <dons> there must be some error in there somewhere though
18:40:06 <lispy> yeah, my fix didn't do it :(
18:40:57 <lispy> get out that termination checker :)
18:41:17 <lispy> does parseTerms terminate
18:41:42 <dons> > words []
18:41:43 <lambdabot>  []
18:42:53 <sris> Is Maybe a monad?
18:43:08 <lispy> sris: yupper
18:43:14 <lispy> > return 1 :: Maybe Int
18:43:15 <lambdabot>  Just 1
18:43:24 * dons debugs
18:43:49 <lispy> > return 1 >>= Nothing >>= \x -> return x :: Maybe Int
18:43:50 <lambdabot>    Expecting a function type, but found `Maybe a'
18:43:50 <lambdabot>    Expected type: a ->...
18:43:57 <lispy> > return 1 >>= \x -> Nothing >>= \x -> return x :: Maybe Int
18:43:58 <lambdabot>  Nothing
18:44:18 <lispy> dons: i can't load in ghci for some reason, Shared.hs is buggy
18:44:44 <dons> Shared.hs shouldn't be used....
18:44:53 <dons> its only for the plugin version.
18:44:55 <lispy> ./Shared.hs:26:22: Not in scope: type variable `forall'
18:45:02 <dons> ah missing -fglasgow-exts
18:45:06 <lispy> well, this is the plugin version...ah
18:45:11 <lispy> but Shared.hs dosen't have a forall
18:45:25 <dons> ghc should print a better message for that
18:45:39 <lispy> but you're right on about the switch
18:48:11 <dons> I'll fix this bug, and add better logging today
18:48:33 <lispy> dons: quick question, why do i have so many problem loading lambdabot in ghci :)
18:48:42 <lispy> Plugin/Dict.hs:14:0: parse error (possibly incorrect indentation)
18:48:52 <lispy> i suspect it's baring on PLUGIN Dict
18:49:47 <dons> you're not using the 'sh ghci' script? ....
18:49:53 <lispy> oh, right thanks
18:50:03 <dons> there's a small script in the lambdabot dir, ./ghci , which sets all the nice flags
18:50:40 <lispy> well, parseTerms seems to be fine
18:50:44 * lispy digs deeper
18:51:10 <dons> I'm debugging the network code atm
18:51:22 <dons> I really suspect that the network doesn't return anything sensible :)
18:51:39 <lispy> hmm...okay
18:51:43 <lispy> well, one of us will find it soon :)
18:52:38 <dons> hmmm weird
18:54:36 <lispy> i'm adding a deriving show to some stuff in DictLookup
18:55:34 <lispy> *Plugin.Dict> fromJust $ lookup "all-dict" dictTable
18:55:35 <lispy> *** Exception: Maybe.fromJust: Nothing
18:55:45 <lispy> not sure what that means
18:55:49 <lispy> i would expect that to work
18:56:17 <lispy> ah, i see
18:56:20 <lispy> typo on my part
19:00:40 <dons> doh. it's obvious!
19:00:43 <dons> results <- mapM doLookup s
19:00:49 <dons> what happens when s == [] :)
19:01:11 <lispy> > mapM return []
19:01:12 <lambdabot>  add an instance declaration for (Show (m [a]))
19:01:17 <lispy> i dunno
19:01:19 <lispy> what happens?
19:01:28 <dons> well, it should be just [] right?
19:01:34 <lispy> right
19:01:40 <dons> so now, then, why doesn't that get turned into Nothing by Base.hs hmm
19:02:02 <dons> > [concat []]
19:02:03 <lambdabot>  Add a type signature
19:02:07 <dons> > [concat []] :: [Char]
19:02:08 <lambdabot>  Couldn't match `Char' against `[a]'
19:02:10 <lispy> > mapM return [] :: [[Int]]
19:02:11 <lambdabot>  [[]]
19:02:12 <dons> > [concat []] :: [[Char]]
19:02:13 <lambdabot>  [""]
19:02:14 <dons> ah that's why
19:02:21 <dons> so its: Just []
19:02:21 <lispy> ah
19:02:24 <dons> which is nothing
19:02:30 * dons fixes
19:02:51 <lispy> doLookup [] = return $ Right Nothing ?
19:03:06 <dons>         return $ case results of
19:03:06 <dons>             [] -> []
19:03:06 <dons>             xs -> return [concat results]
19:03:06 <dons> ?
19:03:07 <lispy> er no
19:03:09 <lispy> right
19:03:14 <lispy> um...
19:03:22 <lispy> where is that?
19:03:35 <dons> I just added it :)
19:03:37 <lispy> in base?
19:03:46 <dons> that's in Dict.hs
19:03:53 <lispy> oh i see
19:03:59 <lispy> yeah, looks good
19:04:01 <lispy> does i t work?
19:04:09 <dons> testing, but i'm sure that's it
19:04:33 <lispy> dons: next thing...how to pass the IP of the user to lambdabot  for logging?
19:04:42 <lispy> dons: should we do all the logging in the cgi?
19:04:43 <dons> yep, that's an interesting problem
19:04:53 <lispy> i don't think it would be hard
19:04:54 <dons> i'd like to fix the logging in the Log module to "just work"
19:04:58 <dons> and maybe with a wrapper for cgi
19:05:05 <lispy> okay
19:05:08 <dons> (i.e. set the user name or something)
19:05:15 <dons> if you can work out how to get hold of the ip address,
19:05:19 <dons> i'll  work on the logging system
19:05:23 <dons> and then we can combine the two
19:05:35 <lispy> sur, i think my part is easy...i saw something inthe api
19:05:44 <lispy> but i'm going to bike home real quick so i'll be afk a bit
19:05:51 <dons> yay,
19:05:52 <dons> lambdabot> all-dicts
19:05:52 <dons> lambdabot>
19:05:54 * lispy waves
19:05:55 <lispy> nice!
19:05:58 <dons> nothing was never so good
19:06:01 <lispy> hehe
19:06:14 * dons pushes
19:06:27 <dons> done
19:06:31 <dons> ok. talk later then.
19:06:37 <dons> i'll work on this logging
19:07:27 <dmwit> Can lambdabot plugins read all the messages in a room, or only the ones directed at them?
19:08:02 <weitzman> They can choose to read all messages
19:08:13 <weitzman> Hence "name++" or "> expression"
19:08:24 <dmwit> Interesting...
19:08:26 <stepcut> or url titles
19:08:51 <weitzman> Also probably used to track how many people are active
19:10:49 <dons> yep, there's a notion of 'contextual' plugins, which can filter all input, and 'process' plugins, which are explicitly called with [@?]foo
19:11:04 <dons> the contextual stuff is new, and probably underutilised
19:11:19 <dons> so if you have some ideas for new plugins, that would be interesting to hear :)
19:11:42 <dons> stepcut: http://lambdabot.codersbase.com/
19:11:43 <lambdabot> Title: Lambdabot Web Interface
19:13:23 <vincenz> woah
19:13:38 <dons> lispy: we better disable the priv commands somehow :)
19:13:56 <vincenz> dons: oh it's an eval
19:14:01 <vincenz> dons: not the commandloop of lambdabot :/
19:14:02 <dons> hmm?
19:14:06 <dons> yes it is.
19:14:11 <dons> its just goa + ajax
19:14:27 <stepcut> dons: swank!
19:14:39 <dmwit> Hmmm... "@pl \x y -> x + y
19:14:39 <dmwit> Error: 500 Internal Server Error"
19:14:49 <dmwit> I guess I don't need the @.
19:14:51 <dons> you don't have to prepend @
19:15:19 <dons> note that people are making it quit or something...
19:15:27 <vincenz> oh!
19:15:28 <dons> as i see the uptime is getting reset ..
19:15:30 <vincenz> without @
19:15:58 <dmwit> Heh, uptime is 45s right now...
19:16:08 <stepcut> dons: is the ajax stuff in haskell ?
19:16:31 <dons> bringert wrote it, so possibly. let me see his patch
19:16:58 <dons> nope just JS.
19:17:07 <lispy> dons: i had a thaught, is Just "" a problem in general in Base?
19:17:32 <dons> plugins returning [[]] will be a problem in general
19:17:34 <dons> I'll filter that now
19:17:48 <dons> lispy, you'll want to disable the System plugin, I think
19:18:00 <dons> and i'll need to tweak things to have it not run as a privledged user
19:18:27 <lispy> ?help system
19:18:28 <lambdabot> system provides: echo list listchans listmodules uptime
19:18:39 <dons> oh, the priv commands in system, I mean
19:18:47 <dons> check the Plugin/System.hs source
19:18:51 <dmwit> ?help echo
19:18:51 <lambdabot> echo <msg>. echo irc protocol string
19:18:55 <lispy> what are the priv commands?
19:18:57 <lispy> like quit?
19:19:00 <dons> yup
19:19:08 <lispy> dons: apache is free to start/restart fast cgi apps as it chooses
19:19:14 <lispy> dons: for instance, ifit times out
19:19:24 <lispy> so the uptime is unreliable
19:19:26 <dons> oh, though I noticed that it was getting around 2-5 hours uptime
19:19:35 <dons> until just now, when its getting reset a lot
19:19:41 <dons> i suppose it could be apache
19:19:54 <lispy> really need to fire a better error when people type "@foo"
19:19:54 <stepcut> hrm, the web version seems to be missing the quote module?
19:19:56 <dons> still, disabling priv commands seems like a reasonale thing to do anyway, no?
19:20:01 <lispy> stepcut: yup
19:20:20 <lispy> dons: i think we need a more general way than ad-hoc disabling of commands in source
19:20:24 <dons> yes
19:20:29 <lispy> dons: a new configuration optionL
19:20:33 <dons> since we don't want to have to fork lambdabot for the web interface
19:20:54 <dons> oh, you mean on the command line? or in Config.hs? a list of disabled commands?
19:21:21 <lispy> it's possible to enable quotes, but my concern was two fold...1) does it make sense to define quotes via the web and 2) it may not stay in sync with the real quote db
19:21:38 <dons> oh, i think there's no reason to have people set quotes
19:21:52 <lispy> dons: yeah, i'm thinking an option like "web = True" then when plugins can check and disable themelves? or maybe a list of commands to filter is best...not sure
19:22:00 <dons> ah ok.
19:22:04 <dons> yes, a bit like priv commands
19:22:09 <lispy> yeah, i think a list of commands to disable is really good actually
19:22:15 <lispy> then you don't have to mess with each plugin
19:22:16 <dmwit> Cale's dynamic-unload would  be ideal...
19:22:18 <dons> i'll do that.
19:22:26 <dons> dmwit: we have dynamic-unload
19:22:31 <dons> but the problem is more fine grained that that
19:22:40 <lispy> dons: just make sure you disable them after the spell check transformation :)
19:22:42 <dons> we want to disable a part of a plugin , not the whole plugin
19:22:43 <dmwit> Ah, okay.  I speak out of ignorance...
19:22:50 <dons> lispy: right
19:22:54 <Cale> and dynamic-unload wasn't my idea :)
19:23:03 <dmwit> Doubly ignorant.
19:23:14 <dons> so, things to work on: logging, web commands, privledgeness
19:23:23 <lispy> er wait
19:23:30 <lispy> what's the difference between the last two?
19:23:59 <dons> they overlap somewhat
19:24:13 <dons> I was thinking that the web interface should run as a non-priv user though
19:24:15 <dons> just as on irc
19:24:25 <dons> and unlike the command line
19:24:26 <lispy> yeah
19:24:29 <lispy> Ah
19:24:31 <lispy> gotcha
19:24:55 <lispy> i'll go look at cgi api
19:25:03 <lispy> let you hack lambdabot :)
19:28:37 <dons> edwardk: the stream fusion stuff is in the fps-unstable darcs repo dir
19:28:50 <dons> as indicated on the paper web page :)
19:31:01 <lispy> i really like the maybe function but i never can remember the type :)
19:32:18 <dons> I am pondering a lambdaweb log
19:32:28 <dons> some kind of lambda with network connections
19:32:44 <lispy> well, keep in mind this cgi library has a logging function
19:32:52 <dons> ah it does?
19:32:54 <lispy> yeah
19:32:56 <dons> does it solve your needs?
19:33:00 <lispy> probably goes to an apache log
19:33:04 <lispy> i think so
19:33:08 <lispy> should i just use it?
19:33:12 <dons> I'd like to fix the logging just a little, but if we can just use apache / cgi logs, that would be better
19:33:23 <dons> (less chance for error, I think )
19:33:46 <lispy> sure
19:34:38 <lispy> i'm logging the remote id/host, if the user was authenticated (thinking for the future), the user-agent (so web browser), the raw/decoded query and the response
19:35:11 <dons> ok good. are they available somewhere i can look at?
19:35:19 <lispy> the log?
19:35:31 <lispy> i could give you access to the log via shell
19:35:38 <dons> yeah, if that's ok? doesn't have to be public.
19:35:45 <lispy> yeah, no problem
19:35:47 <dons> that'd be useful.
19:35:51 <lispy> i trust you won't kill my server :)
19:36:09 <dons> no no :) i'll just be reading the logs to debug the bot
19:36:10 <lispy> okay, i'll set something up in a minute
19:36:12 <stepcut> so maybe after I finish the lambdabot/jabber stuff, I'll get started on lambdabotGL :p
19:36:19 <dons> heh
19:36:22 <lispy> stepcut: awesome
19:36:24 <lispy> :)
19:36:29 <lispy> jabber would rock
19:36:37 <lispy> i'd love to have lambdabot on my google chat
19:36:49 <stepcut> lispy: I have something rigged up at the moment
19:36:56 <lispy> sweet!
19:37:21 <stepcut> lispy: I am working on my 3rd attempt now :) But I think this one will be release quality
19:37:29 <dons> nice stepcut
19:37:36 <dons> open source: it just works
19:38:27 <stepcut> jabber is a bit tricky to deal with, because it can be extended after the fact
19:38:41 <stepcut> by defining new xml namespaces
19:39:20 <dfranke> is there a way to get emacs haskell-mode to stop treating blank lines as the end of a declaration?
19:39:35 <stepcut> so it has been tricky to define a core mechanism where people can add support for new jabber extensions by written third-party modules
19:39:39 <lispy> dfranke: not sure, that was bugging me a second ago :(
19:40:00 <stepcut> s/written/writing/
19:40:10 <lispy> stepcut: lambdabot itself has a plugin architecture you could borrow ideas from on that thought, right?
19:41:10 <stepcut> lispy: I looked at a bit, but I think the problem is different. Lambdabot plugins all have the same simple, String based interface I think
19:41:49 <dons> lispy: do you have a list of things you want disabled? or have disabled?
19:42:06 <lispy> dons: setting quotes is on the list
19:42:26 <lispy> dons: but otherwise i'm not sure
19:42:34 <lispy> dons: everything else i have disabled at the module level
19:42:38 <stepcut> anyway, I think have the core library basically working, I just need to integrate it with lambdabot properly
19:42:38 <dons> ok
19:43:16 <lispy> unlines = concat . intersperse "\n" ?
19:43:29 <dons> yep
19:43:47 <mauke> I think it's more like concat . map (++ "\n")
19:43:53 <dons> actually, unlines         =  concatMap (++ "\n")
19:44:04 <dons> i.e. _not_ an intersperse
19:44:12 <lispy> hmm..
19:44:24 <lispy> so my way is broken?
19:44:28 <lispy> oh
19:44:32 <stepcut> lispy: no trailing newline ?
19:44:35 <lispy> my way doesn't have the trailing newline
19:44:38 <stepcut> :p
19:44:45 <lispy> so, best leave it this way
19:44:53 <lispy> the ajax might look funny otherwise
19:45:39 <lispy> ?type liftM
19:45:41 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
19:47:14 <lispy> > show ("foo\n", Nothing)
19:47:15 <lambdabot>  Add a type signature
19:47:23 <lispy> > show ("foo\n", Just "hi")
19:47:24 <lambdabot>  "(\"foo\\n\",Just \"hi\")"
19:47:26 * dons chanes the lambdabot definition to read:
19:47:27 <dons> Lambdabot is a Haskell development tool, written in Haskell. It operates as
19:47:27 <dons> a command line tool, embedded in an editor, embedded in ghci, via internet
19:47:28 <dons> relay chat (IRC) and on the web.
19:47:32 <dons> :)
19:47:40 <lispy> haha
19:48:02 <dons> saying it was an irc bot seems kind of underselling it
19:48:15 * wkh signed up for a class on machine learning-based biometric authentication
19:48:25 * wkh pumps his fist and says "yessss" like napoleon dynamite
19:51:35 <lispy> ?hoogle liftM
19:51:36 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
19:51:36 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:51:36 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
19:51:43 <sieni> coffffffffeeeeeeee!!!!!
19:52:03 <wkh> cheers
19:52:28 <lispy> is there a maybe for monads?
19:52:30 <lispy> ?hoogle maybeM
19:52:31 <lambdabot> No matches found
19:52:37 <lispy> ?type maybe
19:52:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:53:14 <lispy> probably, m b -> (m a -> m b) -> Maybe (m a) -> m b
19:53:34 <lispy> so the reason is because i have m (Maybe a)
19:53:45 <lispy> how could i fix that?
19:53:56 <lispy> ?hoogle Maybe (m a) -> m (Maybe a)
19:53:57 <lambdabot> Maybe.fromJust :: Maybe a -> a
19:53:57 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
19:57:03 <lispy> ?type liftM
19:57:04 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
19:57:08 <dmwit> > 2 * 3 + 1
19:57:09 <lambdabot>  7
19:57:11 <dmwit> > 1 + 2 * 3
19:57:13 <lambdabot>  7
19:57:48 <dmwit> > id 3 - 1
19:57:49 <lambdabot>  2
19:58:22 <dmwit> > (\x -> x * 2) 3 - 1
19:58:24 <lambdabot>  5
19:58:42 <mauke> ?type maybe (return Nothing) (liftM Just)
19:58:44 <lambdabot> forall (m :: * -> *) a1. (Monad m) => Maybe (m a1) -> m (Maybe a1)
19:59:11 <thetallguy> ?seen stepcut
19:59:12 <lambdabot> stepcut is in #haskell. I last heard stepcut speak 14m 33s ago.
19:59:33 <mauke> ?type maybe (return (fail "")) (liftM return)
19:59:34 <lambdabot> forall (m :: * -> *) a1 (m1 :: * -> *). (Monad m, Monad m1) => Maybe (m a1) -> m (m1 a1)
20:08:13 <lisppaste2> dwm pasted "de-do-ifying" at http://paste.lisp.org/display/26140
20:08:35 <sieni> > (\x -> case x of {Nothing -> return Nothing; Just y -> (>>=) y (\z -> return (Just z))}) (Just [1])
20:08:36 <lambdabot>  [Just 1]
20:08:39 <dwm> I'm trying to take the do block in the code and rewrite it using binding notation. Having problems.
20:08:49 <lispy> i'm using maybeM :: Monad m => m b -> (a -> b) -> m (Maybe a) -> m b
20:08:54 <sieni> lispy: does that work with you?
20:09:00 <mauke> ?type random
20:09:01 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
20:09:04 <lispy> maybeM d f optional = do o <- optional
20:09:04 <lispy>                          case o of
20:09:05 <lispy>                            Nothing  -> d
20:09:05 <lispy>                            (Just v) -> return (f v)
20:09:11 <dons> ?undo getAny = do g      <- get ; (x,g') <- return $ random g ; put g' ;  return x
20:09:11 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 8}) "Parse error"
20:09:18 <dons> ?undo  do g      <- get ; (x,g') <- return $ random g ; put g' ;  return x
20:09:18 <lambdabot> get >>= \ g -> return $ random g >>= \ (x, g') -> put g' >> return x
20:09:21 <dons> :)
20:09:28 <dwm> Yeah, I'd like to know how to do it myself.
20:09:29 <lispy> sieni: not sure
20:09:35 <lispy> sieni: it's awfully hard to read
20:09:52 <mauke> dwm: turn <- ; into >>= and ; into >>
20:10:09 <dwm> You know, I almost tried that >> return x. But I was sure that the x wouldn't be available after the >>
20:10:23 <mauke> it's part of the same function body
20:11:06 <dwm> ? undo, I had no idea that was there. What can't that thing do.
20:11:34 <dwm> So, wait, the  (x,g') -> put g' >> return x  is all one thing?
20:11:35 <dons> sounds like we need better documentation
20:11:47 <dons> maybe i should do  series of "Learning Lambdabot" blog articles?
20:12:00 <mauke> @undo do c <- readFile "foo.txt"; let l = read c; let l' = listOfPairSums l; let str = show l'; writeFile "oof.txt" str; putStrLn "done"
20:12:01 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 45}) "Parse error"
20:12:18 <mauke> @undo do c <- readFile "foo.txt"; let l = read c; l' = listOfPairSums l; str = show l'; writeFile "oof.txt" str; putStrLn "done"
20:12:19 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 106}) "Parse error"
20:12:27 <dons> not sure . the let's maybe ?
20:13:09 <dons> ?undo do c <- readFile "foo.txt" ; putStrLn "done"
20:13:09 <lambdabot> readFile "foo.txt" >>= \ c -> putStrLn "done"
20:13:10 <mauke> dwm: yeah, \(x, g') -> put g' >> return x is a function
20:13:23 <dons> ?undo do c <- readFile "foo.txt" ;let l = read c ; putStrLn "done"
20:13:23 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 61}) "Parse error"
20:13:25 <dons> ah
20:13:32 <dons> ?undo do c <- readFile "foo.txt" ;let l = read c in putStrLn "done"
20:13:32 <lambdabot> readFile "foo.txt" >>= \ c -> let { l = read c} in putStrLn "done"
20:13:36 <dwm> I was making this (apparently all in my head) break where the >> is, like 'out of scope' or something.
20:13:45 <dons> sjanssen: @undo doesn't support let d = e; style lets?
20:13:52 <mauke> >> is just another operator/function
20:13:59 <lispy> > show ("", "", "", "", Just "", "")
20:14:00 <lambdabot>  "(\"\",\"\",\"\",\"\",Just \"\",\"\")"
20:14:12 <lispy> why would ghci say i have no instance for values of that type...
20:14:26 <dwm> Ok, think you guys.
20:17:20 <monochrom> We guys are always on your mind!
20:17:38 <dwm> Always helpful, that's for sure.
20:20:01 <dons> lispy: did you want to pull the 'a' patch?
20:20:20 <lispy> dons: i could, but i'm knee deep in cgi, do you mind if i wait?
20:20:26 <dons> ok no worries :)
20:20:34 <lispy> cool :)
20:20:39 * dons watches lispy muck around in cgi mud
20:20:45 <lispy> heh
20:22:42 <dons> ok. just pushed a patch that adds --web
20:22:52 <dons> this is just a command line mode, with priv commands disabled
20:23:07 <dons> also, in Config.hs is now 'disabledCommands' which you can use to switch off individual things
20:23:13 <SamB> ... what has that to do with the web?
20:23:21 <dons> it's for running in web mode
20:23:25 <dons> http://lambdabot.codersbase.com/
20:23:27 <lambdabot> Title: Lambdabot Web Interface
20:23:32 <SamB> ah
20:23:35 <SamB> suspected as much
20:23:54 <dons> maybe it should be --server or some such
20:24:05 <dons> or --restricted
20:24:10 <dons> yeah, that's a better name
20:25:47 <SamB> that isn't the same lambdabot is it?
20:25:54 <dons> it is.
20:25:59 <dons> why?
20:26:02 <SamB> @karma SamB
20:26:03 <lambdabot> You have a karma of 15
20:26:04 <lispy> > (return Nothing :: Maybe (Maybe Int)) >>= \x -> return x
20:26:05 <lambdabot>  Just Nothing
20:26:17 <SamB> it doesn't work when I type "karma SamB"
20:26:21 <dons> some commands are disabled
20:26:36 <dons> but its _a_ lambdabot
20:26:47 <dons> lambdabot 4p189, GHC 6.4.2 (Linux x86_64 3.20GHz)
20:26:50 <dons> ?version
20:26:50 <lambdabot> lambdabot 4p188, GHC 6.5 (OpenBSD i386 )
20:26:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:27:01 <dons> mmm 64 bit goodness
20:27:25 <SamB> not even the same OS!
20:27:30 <SamB> nevermind the same process...
20:28:15 <dons> well, your phrase: that isn't the same lambdabot, was still true, modulo 'same'
20:28:48 <dons> i'm not quite sure what defn of same I was using. with ~50 patches or #haskell's bot?
20:28:50 <SamB> yes, but same was the *key* word
20:29:19 <SamB> I meant, the same process!
20:29:31 <dons> it's not the same bot, but its the same modulo patches and some epsilon
20:29:55 <dons> it's not sarahbot
20:30:11 <SamB> ....
20:30:53 * SamB is bored
20:30:55 <SamB> I better go to bed
20:31:25 <dons> writes some code! life is too short to sleep
20:31:47 <SamB> ...
20:31:55 <SamB> dude, don't you know that you can die of not sleeping?
20:32:07 <dons> are we going to change the world this year , or next? depends on how much sleep you want to have.
20:32:19 <shrimpx> you can't die from not sleeping can you?
20:32:20 * dons doesn't sleep very well
20:32:26 <SamB> yeah, if I get enough maybe it will happen this year!
20:32:26 <dons> sure you can
20:32:30 <dons> takes 15 days or so
20:32:30 <weitzman> Don't you know that you can die if the world keeps using unsafe languages and you use a device with a bug?
20:32:31 <shrimpx> your brain just shuts down and sleeps
20:32:36 <SamB> I heard it took a month
20:32:46 <dons> maybe. i've not tried it myself
20:32:52 <SamB> shrimpx: well, ideally
20:33:05 <shrimpx> i have a friend who didn't sleep for 8 days
20:33:10 <shrimpx> and passed out while standing at work
20:33:12 <SamB> but if you manage to stay awake too long, apparantly you go crazy and die
20:33:13 <shrimpx> in front of customers
20:33:31 <dons> fun
20:34:35 <SamB> I'm sure that would never happen to me though... I'd be much too tired after two or three days to stay up longer...
20:42:18 <MarcWeber> shrimpx: You can die of not sleeping.. But you have to use some technics to preventing you from getting any rem sleep etc.. ;) But you're right that you can't die under normal conditions because your body will take some naps/sleep if it really needs it. ;)
20:47:36 <lispy> is this just a ghci bug?
20:47:36 <lispy> No instance for (Show (String, [Char], [Char], String, Maybe [String], [Char]))
20:48:26 <lispy> ?hoogle liftM
20:48:27 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
20:48:27 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
20:48:27 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
20:49:49 <Lemmih> lispy: Nope, there just isn't an instance of Show for (a,b,c,d,e,f).
20:50:02 <lispy> hmm...
20:50:11 <lispy> that come as a surprise to me :)
20:50:33 <lispy> > show ("", "", "", "", "", "")
20:50:35 <Cale> What's with these stupid RSS clients that keep hitting your webserver every 30 minutes even if the RSS feed hasn't been there in months? :)
20:50:35 <lambdabot>  "(\"\",\"\",\"\",\"\",\"\",\"\")"
20:51:23 <mauke> > show (1,2,3,4,5,6)
20:51:24 <lambdabot>  "(1,2,3,4,5,6)"
20:51:32 <mauke> > show (1,2,3,4,5,6,7,8,9,10,11,12)
20:51:33 <lambdabot>  "(1,2,3,4,5,6,7,8,9,10,11,12)"
20:51:34 <MarcWeber> > show ("string",'a':[],'a':[], "string", Just "anc", 'a':[] )
20:51:35 <lambdabot>  "(\"string\",\"a\",\"a\",\"string\",Just \"anc\",\"a\")"
20:51:45 <dons> lispy: in 6.6 there is up to tuples n = 15
20:52:08 <mauke> > show (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
20:52:09 <lambdabot>     add an instance declaration for (Show (a,
20:52:09 <lambdabot>               ...
20:52:44 <lispy> so what was the limit in 6.4?
20:52:47 <lispy> 5?
20:52:53 <dons> 7?
20:52:54 <lispy> ah, yup
20:53:00 <MarcWeber> lispy: Should be easy to try out..
20:53:15 <lispy> yeah,i just verified...it's 5
20:56:28 <lispy> now the question...where did it log to
21:01:09 <dons> ok, i've added some basic logging for offline mode.
21:01:19 <dons> logs go into State/Logs/*/offline
21:01:30 <dons> no ip though, and no output details
21:02:00 <lispy> nice
21:02:05 <lispy> i can't find the log file :)
21:02:29 <dons> hmm /var/log/www/ ?
21:02:40 <dons> /var/www ?
21:03:47 <dons> now, if in web mode, I just have lambdabot run HsColor over the output, do you think that will "just work" in the web interface?
21:03:58 <dons> i.e. if it emits <pre></pre> tags with colors
21:04:00 <lispy> no
21:04:07 <dons> ok
21:04:20 <lispy> bringert seemed to think his code deends on text/plain output
21:04:27 <dons> ah right
21:04:29 <dons> makes sense
21:04:41 <lispy> i think maybe in the future we can support this
21:04:47 <dons> maybe we should adapt it to support html then
21:04:49 <lispy> but, maybe not yet
21:04:56 <dons> since I think I can have lambdabot generate pretty html output fairly easily.
21:04:56 <lispy> i agree
21:05:15 <dons> i.e. hrefs for urls, and syntax highlighting of code
21:05:16 <lispy> i wonder why we don't get a log
21:05:25 * lispy nods-
21:05:27 <dons> surely apache is logging somewhere?
21:05:46 <lispy> dons: oh, can lambdabot actually list again instead of the url when in webmode?
21:05:49 <lispy> oh yeah
21:05:54 <lispy> i have tons of apache logs
21:06:14 <dons> ah ok. you want a brief module listing. hmm. ok
21:06:32 <lispy> yeah, i dont' think webusers would see it as spam
21:06:33 <Cale> @google ounce acres per fortnight per fortnight in kilowatt hours
21:06:35 <lambdabot> 1 ((ounce acres) per fortnight) per fortnight = 2.17809841 x 10^-17 kilowatt hours
21:07:21 <dons> ?quit new code
21:07:23 <Eidolos> Good to know.
21:10:12 <lispy> i'll ask in apache about this log problem
21:10:24 <dons> ?version
21:10:51 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
21:10:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:11:20 <dons> ?all-dicts
21:11:24 <dons> ?bot
21:11:25 <lambdabot> :)
21:12:12 * wkh feels a sudden urge to anthropomorphize an IRC bot and sighs
21:12:23 <dons> ?vixen-on
21:12:24 <lambdabot> What's this channel about?
21:12:24 <lambdabot> i am a bit of a vixen :)
21:12:54 <dons> what does  anthropomorphize mean, vixen?
21:12:55 <lambdabot> i'm not sure what i mean
21:13:24 <dons> do you think that bot anthropomorphisation is appropriate?
21:13:24 <lambdabot> why does everyone ask i'f on a bot?
21:13:44 <dons> i know. its' weird, eh?
21:13:44 <lambdabot> i thought you knew
21:13:56 <sieni> ?bitchen-off
21:13:57 <lambdabot> Unknown command, try @list
21:13:57 <lambdabot> Limited vocabulary, eh?
21:14:07 <dons> ?vixen-off
21:14:08 <lambdabot> Bye!
21:14:26 <Cale> @google (four pi radius of earth squared) ton per square fortnight in kilowatt hours
21:14:30 <lambdabot> http://futureboy.homeip.net/frinkdata/units.txt
21:14:33 <Cale> bah
21:14:47 <wkh> @google 40 rods/hogshead in miles/gallon
21:14:48 <lambdabot> 40 (rods / hogshead) = 0.00198412698 miles / US gallon
21:15:13 <lispy> dons: according to the apache docs anything on stderr will get logged
21:15:21 <dons> only stderr?
21:15:22 <lispy> dons: so i'll jus have it output on stderr
21:15:24 <Cale> ((four * pi * (radius of Earth squared)) * ton) per (square fortnight) = 0.0880444919 kilowatt hours
21:15:31 <dons> ah so it won't log all the stuff it actually returns
21:15:33 <Cale> is the result I get from google calculator
21:15:35 <dons> and all the forms and so on
21:15:39 <lispy> dons: not sure, but this other stuff isn't working :(
21:15:47 <dons> what other stuff?
21:15:57 <lispy> logCGI
21:16:00 <dons> ah
21:16:09 <dons> ideally that's what we need to get working
21:16:21 <lispy> http://www.cs.chalmers.se/~bringert/darcs/cgi-compat/doc/api/Network-NewCGI.html#v%3AlogCGI
21:16:21 <dons> since it's going to be harder at the lambdabot level
21:16:25 <lambdabot> http://tinyurl.com/zkv8q
21:17:00 <dons> I'm not sure we should be having the bot spit everything to stderr in web mode. I spose its doable
21:17:07 <dons> but getting the cgi logging working would be nicer
21:17:21 <dons> also, for the time being , you can pull the latest log patches, and get some logging
21:17:29 <lispy> cool
21:17:45 <dons> we can ask bringert about it
21:18:47 <lispy> i'll try the stderr hack real quick
21:19:56 <lispy> nothing
21:19:59 <lispy> damn
21:20:16 <mauke> ?check \bits -> (bits*76573)/254370+1 == length (show (2 ^ bits - 1))
21:20:18 <lambdabot>  add an instance declaration for (Fractional Int)
21:20:30 <mauke> ?check \bits -> (bits*76573)`div`254370+1 == length (show (2 ^ bits - 1))
21:20:31 <lambdabot>  Exception: Prelude.^: negative exponent
21:22:06 <dons> ?check \bits -> (bits > 0) ==> (bits*76573)`div`254370+1 == length (show (2 ^ bits - 1))
21:22:07 <lambdabot>  OK, passed 500 tests.
21:23:51 <lispy> i'll update lambdabot next
21:28:49 <petekaz> anyone read john goerzen's code to the Lars problem?
21:29:29 <petekaz> I have a question about laziness and sortBy.
21:30:23 <petekaz> If I have a large list, and sort it, but in the end only use the first 5 items, everything has to be evaluated right because of the sort?
21:31:03 <petekaz> i.e., there is no laziness, by time the 'take 5' is called, the full list has been evaluated.
21:32:24 <dons> yes. the sort will force the list
21:32:38 <dons> > take 5 $ sort [1..]
21:32:42 <lambdabot> Terminated
21:32:54 <dons> > take 5 [1..]
21:32:55 <lambdabot>  [1,2,3,4,5]
21:33:11 <monochrom> Even if you ask for the minimum, you need to examine everything in the list.
21:33:36 <petekaz> now if the original list is coming from getContents, does everything get loaded into momery all at once?
21:33:39 <shapr> My mother gave me a Linux for my birthday that has John Goerzen mentioned on the cover.
21:33:39 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
21:33:45 <shapr> er "Linux book"
21:33:47 <monochrom> Yes.
21:33:54 <dons> shapr: you've seen http://lambdabot.codersbase.com/ ?
21:33:54 <lambdabot> Title: Lambdabot Web Interface
21:34:08 <shapr> spiffy!
21:34:10 <petekaz> shapr: and my colleague has his Network programming in python book.
21:34:54 <shapr> petekaz: I knew about that one, but I didn't know he wrote part of a Linux book.
21:34:59 <shapr> aww, no fortune file
21:35:57 <monochrom> John Goerzen dances with wolves!  I mean python! :)
21:35:58 <shapr> plugs gives an internal server error.
21:36:05 <shapr> dons: cute!
21:36:48 <dons> shapr: try > 1+2
21:36:58 <dons> ?plugs no idea what this is anymore?
21:36:58 <lambdabot> Unknown command, try @list
21:37:07 <dons> oh, lispy's upgrading something I think
21:37:19 <lispy> ah yeah, i broke it right now
21:37:22 <lispy> sorry
21:39:55 <lispy> > 1 + 1
21:39:56 <lambdabot>  2
21:40:02 * lispy boggles
21:41:15 <thetallguy> shapr, are you in Portland?
21:42:14 <lispy> vixen is working
21:42:43 <lispy> quote is working
21:43:23 <lispy> ./runplugs is working
21:43:48 * lispy thinks this is very od
21:47:57 <weitzman> Anyone here familiar with the language called Clean?
21:50:14 <lispy> dons: i think we broke things
21:50:23 <lispy> dons: with the new web mode
21:50:33 <lispy> dons: for instance, @let now gives errors
21:50:39 <ChilliX> bringert: I am currently merging ghc-fc2 into the HEAD.  Please hold of with any patches until I am done (when ghc-fc2 will become the HEAD)
21:50:40 <lispy> dons: i wonder if it's with the fix for 'a'
21:51:00 <dons> lispy, hmm. what about in commad line mode?
21:51:02 <lispy> dons: i'm thinking the stuff with Just [] -> Nothing maybe be a problem?
21:51:10 * ChilliX is going to bed now and to Portland right when I get up tomorrow.
21:51:19 <dons> night ChilliX
21:51:23 <ChilliX> night dons
21:51:30 <lispy> dons: exactly, now let foo = \x -> x * x just gives the next prompted...didn't it used to say done?
21:52:07 <dons> hmm
21:52:15 <dons> ah yes
21:52:36 <dons> maybe I was too keen
21:53:21 <dons> ?let x = 1
21:53:23 <lambdabot> Defined.
21:53:29 <dons> hmm
21:53:51 <dons> > L.x
21:53:52 <lambdabot>  1
21:53:57 <lispy> yes, this new lambdabot truncates too much for me
21:54:04 <lispy> lambdabot> > L.foo 1
21:54:04 <lispy> lambdabot>
21:54:18 <lispy> thats' with foo = \x -> x * x
21:54:32 <dons> yeah ok. looking into it
21:54:51 <lispy> i'm reverting for now
21:54:56 <lispy> i unpulled the patch
21:57:34 <lispy> nope
21:57:37 <lispy> it wasn't that pach
21:57:55 <dons> nope. something else. maybe this logs stuff
21:57:57 <lispy> i unpulled and rebuilt and t didn't help
21:59:17 <dons> ok let me try to narrow this down
21:59:31 <lispy> yes, it was the logging patch
21:59:36 <lispy> not sure why
22:00:26 <dons> which patch?
22:00:48 <lispy> Fri Sep 15 20:59:01 PDT 2006  Don Stewart <dons@cse.unsw.edu.au>
22:00:48 <lispy>   * add logging in offline mode. Logs go into State/Logs/*/offline/
22:00:56 <lispy> oh, sorry about your email addy
22:00:57 <dons> hmm ok
22:00:58 <lispy> gah
22:01:00 <dons> no worry
22:01:03 <lispy> didn't meant to past that
22:01:09 * lispy can't type today either
22:01:47 <lispy> shapr: it's up agin
22:02:06 <dons> ah maybe i know...
22:02:07 <lispy> dons: i think i might stop working on it for tonight
22:02:10 <dons> ok
22:02:14 <lispy> dons: i have some stuff i need to work on
22:02:23 <dons> ok
22:02:33 <lispy> dons: but /msg me if you get the logging working
22:02:43 <dons> ok
22:02:49 <lispy> dons: and possible we have a bug in GoA
22:03:00 <lispy> if lambdabot says nothing but a new prompt it still needs to return
22:03:09 <dons> hmm right
22:03:10 <lispy> but in this case it isn't....
22:03:17 <dons> ok i'll look at that
22:03:25 <lispy> thanks
22:03:33 * lispy goes to get dinner
22:05:07 <lispy> dons: here's another thought
22:05:28 <lispy> dons: goa is fine, but when a cgi script outputs nothing then the cgi code things it's hanging
22:05:47 <dons> hmm ok
22:11:33 <lispy> sent you my updates to bot.hs that suppodely add logging
22:11:38 <lispy> supposedly*
22:12:01 <dons> ok
22:16:04 <lispy> this part of your patch is fissy
22:16:06 <lispy> fishy
22:16:12 <lispy> hunk ./Plugin/Base.hs 169
22:16:12 <lispy> -  -- send to all modules for contextual processing
22:16:12 <lispy> -  | otherwise = doContextualMsg text
22:16:12 <lispy> +      | otherwise = return ()
22:16:30 <lispy> you replaced contextual processing with return () ?
22:16:33 <dons> not so sure. i've reverted back about 10 patches and let still doesn't work
22:16:39 <dons> no. see further up
22:16:45 <dons> I added contextual processing to all input
22:16:49 <dons> (so commands got logged)
22:16:50 <lispy> ah
22:16:54 <lispy> hmm...
22:17:14 <lispy> okay, let is a red-herring?
22:17:16 <dons> i think let broke earlier than today, I just didn't notice it
22:17:33 <lispy> so, when i had the buggy version, > 1 + 1 didn't produce anythig but a new promopt in the cl version
22:17:42 <lispy> the only patch i'm missing is the logging patch
22:17:49 <dons> ok i'll see if I can reproduce that too
22:19:09 <lispy> i'll make sure the cgi always has output
22:26:24 <lispy> goa is buggy with the no output
22:26:30 <lispy> just confirmed
22:27:58 <dons> ok
22:28:07 <dons> how can you produce no output from lambdabot?
22:28:19 <lispy> i didn't exlpain that well
22:28:26 <lispy> i just reapplied the logging patch
22:28:30 <lispy> then tried to use lambdabot in goa
22:28:35 <lispy> it hangs
22:28:37 <dons> I think the let issue is to do with ghc 6.4.2, it doesn't reliably set exit codes, I think
22:28:44 <lispy> on lambdabot "run 1 + 1" ""
22:28:47 <dons> ok
22:29:22 <dons> i'll try to fix this let issue. then look at goa, shouldn't be too hard to fix that
22:29:37 <lispy> let is a red herring
22:29:43 <dons> yes. its a separate issue
22:30:00 <lispy> the problem is that some commands stopped producing out put with the logging patch
22:30:13 <dons> ok. such as "run 1+1" ?
22:30:21 <lispy> now, maybe that's ghc 6.4.2's problem...but that was the cause of it forme
22:30:23 <lispy> yeah
22:30:36 <dons> ok
22:30:51 <lispy> pretty weird huh?
22:31:00 <lispy> wish we knew what was going on
22:31:18 <lispy> dons: here is a thought
22:31:30 <lispy> dons: build that version of lambdabot  on my server and test it there
22:31:37 <lispy> since it's reproducible there
22:31:55 <dons> ok i'll see.
22:32:02 <lispy> anyway, i need to shop before they close, so bbiab :)
22:32:09 <lispy> (it's hard to walk away when bugs exist :)
22:32:24 <dons> heh
22:38:55 <dons> ok, I get the runplugs issue too
22:39:09 * dons should really set up some regress tests for lambdabot now
22:40:14 <dons> right. it is the log patch. now to work out why
22:44:20 <deadbeef> hi gour
22:44:26 <deadbeef> i've been in .hr this summer
22:44:30 <gour> deadbeef: hi
22:44:35 <gour> where?
22:44:41 <deadbeef> mljet
22:44:46 <deadbeef> the hotel offers free wifi access
22:44:49 <gour> ahhh.nice
22:44:54 <deadbeef> rly
22:45:08 <gour> i'm from fiumme ;)
22:56:03 <dons> lispy: ok, > 1+2 issue should be fixed now
22:56:12 <audreyt> wow, this commit log sentence really challenges my mental parser, and I've parsed a lot of commits :)
22:56:22 <audreyt> * Instantiate data constructor type variables with the type constructor type variables in constraints for derived class instances.
22:56:30 <dons> heh
22:57:09 <audreyt> it's very clear and precise and correct, but requires a good many lookbehinds
22:59:41 <stepcut> audreyt: yikes
23:01:30 <audreyt> data Foo a where
23:01:50 <audreyt>     MkFoo :: BarClass a b c => a -> b -> c -> Foo a
23:01:54 <audreyt> that commits is for something like that.
23:02:04 <audreyt> but without an example it's kinda hard to grok
23:09:16 <lispy> dons: what was it?
23:11:27 <dons> the contextual stuff forks a thread, which returns Nothing immediately, if no processing is required
23:11:35 <dons> that would get to the prompt first
23:11:53 <dons> the next command would then print the (slower) response from the eval plugin, out of order
23:12:45 <dons> i'm writing a different logging system now, to avoid contextual
23:13:08 <dons> so then, there is the outstanding goa / no output issue to handel too
23:13:31 <lispy> hmm...okay
23:15:32 <dons> so the output pipe contained: [Nothing, Just result]
23:15:50 <dons> but the offline writer loop just popped the head off the chan, printing the Nothing
23:16:04 <dons> the next command would then flush the pipe
23:16:39 <lispy> did you use Mvars to sequence the thread io then?
23:17:39 <dons> they're sequenced, but the offline loop just prints output as soon as it is available
23:17:54 <dons> so it didn't wait for a second value to appear in the chan
23:17:58 <dons> anyway, sorted now.
23:18:12 <lispy> well, that's good
23:18:26 <lispy> dons: would it be easier for your if i made my goa repo web accessible?
23:18:29 <lispy> then you could pull from it
23:19:09 <dons> yeah ok. that would be faster than mail
23:19:33 <lispy> i'm just thinking that the fcgi+ajax stuff is now starting to grow into something that should maybe be it's own repo
23:20:39 <dons> yes
23:20:55 <dons> the basic goa script should probably just come bundled with lambdabot
23:21:12 <lispy> as a library?
23:21:28 <dons> I reckon
23:21:43 <dons> anyway, feel free to create a lambdaweb repo or such like
23:22:07 <lispy> yeah, i think for now that's what i'll do
23:22:18 <lispy> /\web
23:22:28 <lispy>  /\web
23:22:36 <lispy> we need a logo
23:23:42 <lispy> i probably won't make that repo until monday
23:23:45 <dons> ok
23:24:25 <lispy> just realizing i should sleep so and i'll probably read up on patch theory all day tomorrow since i'll be hanging out with droundy most of the day sunday
23:24:32 <dons> ok
23:25:55 <newsham> lisp: lambda lambda lambda?  maybe an omega mu?
23:26:47 <dons> hehe /\/\/\ eh?
23:30:11 <lispy> i think of it as a web shell
23:30:22 <lispy> so maybe a lambda with a webshell of some sort
23:30:30 <lispy> we could work spiderman in
23:30:36 <lispy> the webslinger
23:32:54 <lispy> it would be cool if on the side of the screen the lamdbaweb interface showed recently typed commands
23:33:01 <lispy> to give people ideas for things to try
23:33:57 <therp> good morning. I think I have been dreaming of shift/reset continuations...
23:34:08 <lispy> hmm...
23:34:09 <dons> ?remember therp good morning. I think I have been dreaming of shift/reset continuations...
23:34:13 <lispy> lolo
23:34:15 <lispy> nice
23:34:20 <therp> :)
23:34:39 <lispy> @quote dons
23:34:39 <lambdabot>  -fglasgow-exts ~= -fhaskell-prime
23:34:43 <lispy> @quote dons
23:34:47 <lambdabot>  global state is just another pure value :)
23:34:51 <lispy> i want the skynet quote
23:34:54 <lispy> @quote dons
23:34:57 <lambdabot>  [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all know each
23:34:59 <lambdabot> other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
23:35:03 <dons> maybe we could patch @quote to take a regex.
23:35:06 <newsham> http://www.grudge-match.com/Images/nerds.gif
23:35:41 <lispy> heh
23:35:48 <lispy> dons: oh, the other thing to fix on lambdabot
23:35:57 <dons> yeah?
23:35:59 <lispy> dons: in non-online, could it list commands gain
23:36:07 <dons> ah right. you wanted that.
23:36:10 <dons> yeah ok
23:36:11 <glguy> It could be because Haskell is such an amazing language ;)
23:36:25 <lispy> dons: and i still need to firgue out how to run in --restricted
23:36:26 <glguy> and *most* people don't have Haskell homework (c:
23:36:53 <lispy> dons: but i think i know an easy way
23:37:02 <dons> a wrapper script perhaps?
23:37:04 <lispy> dons: setFlags :: String -> IO ()
23:37:12 <lispy> dons: works like setLambdabotHome
23:37:12 <dons> ah
23:37:40 <lispy> *maybe*, just *maybe* it should read in a .lambdabotrc file
23:38:09 <dons> more work
23:38:19 <gour_> dons: to be able to build it on gentoo with ghc-6.6
23:38:32 <dons> we need a wealthy venture capiltalist to fund lambdabot dev
23:38:59 <Adamant> what the heck is lamdabot?
23:38:59 <dons> in return for flattering @quotes
23:39:06 <dons> Adamant: serious?
23:39:09 <lispy> "Please donate to skyn^Wlambdabot today!"
23:39:12 <Adamant> well, I mean more
23:39:13 <dons> heh
23:39:18 <dons> ?where lambdabot
23:39:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:39:25 <Adamant> what is lambdabot besides a freakin' IRC bot?
23:39:35 <Adamant> it sounds like you are turning it into a dev tool.
23:39:39 <dons> it is, yes.
23:39:50 <dons> its more a dev tool than an irc bot, perhaps now
23:39:52 <lispy> has been for a while actually
23:40:09 <dons> it certainly does more dev-related things, than irc-related things
23:40:13 <ValarQ> it's the emacs of ircbots :)
23:40:14 <Adamant> msg lambdabot list, then play around?
23:40:21 <dons> and it runs on the command line, web , vim, ...
23:40:28 <dons> ?list
23:40:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
23:40:33 <lispy> and now that we're opening it up to the web even more people will be able to use it...i'm gues this will be nice for students in uni. classes
23:40:36 <dons> ValarQ: heh right.
23:40:48 <ValarQ> @karma+ lambdabot
23:40:48 <lambdabot> lambdabot's karma raised to 26.
23:40:48 <glguy> lambdabot: is actually a lousy *irc* bot, and is a much better haskell dev tool :-p
23:40:56 <ValarQ> a free karmacookie for lambdabot
23:40:58 <dons> lispy: I suspect so. it's already used in at least one uni to help teach the kiddies
23:41:22 <glguy> dons: no insult intended, I'm talking in comparison to what eggdrop is made to do
23:41:24 <dons> glguy: you think? i'd say its a pretty good irc bot too :)
23:41:37 <dons> ah such as? I'm always on the lookout for new features
23:41:37 <glguy> like a full on channel management bot
23:41:52 <dons> fair enough. it only does some small management stuff
23:41:52 <glguy> the kind that saves the ops from having to kick people
23:42:02 <dons> right. its not heading that way.
23:42:07 <glguy> lambdabot: is a wonderful haskell bot
23:42:10 <dons> its far more about haskell exploration
23:42:43 <glguy> but "botnets" aren't one of it's goals (c:
23:42:44 <dons> so yeah: Lambdabot is not an IRC bot
23:42:44 <lispy> we need more interpreters built into lambdabot
23:43:05 <dons> I should write down some goals for lambdabot's direction
23:43:14 <Adamant> botnets over IRC are ugh.
23:44:09 <Adamant> dons, what nice open/free projects are there in Haskell besides darcs and lambdabot
23:44:25 <lispy> Adamant: ghc
23:44:29 <dons> pugs? ghc? yi? about 500 other things
23:44:43 <dons> check haskell.org under 'libraries and tools'
23:44:50 <glguy> We need J support for lambdabot (I'm going ot imagine that writing an interpreter in Haskell wouldn't be very pretty)
23:44:51 <dons> or the 'Example code' page for a small list
23:44:54 <Adamant> well, ghc is a compiler/interpret suite. :)
23:45:06 <arcatan> what's J?
23:45:07 <dons> its an open/free project
23:45:21 <dons> glguy: yeah J would be nice.
23:45:26 <glguy> arcatan: J is a vector-based programming language decendent from APL
23:45:29 <Adamant> fair enough. I mean more "project built with Haskell"
23:45:31 <dons> would go well with the mathematica plugin
23:45:50 <dons> Adamant: check haskell.org :) there's too many to give a coherent list
23:46:01 <dons> its like asking: what nice open/free projects are there in C
23:46:02 <Adamant> yeah, I took the hint :)
23:46:05 <Adamant> thanks dons.
23:46:15 <lispy> Adamant: ghc is written in haskell and covered under bsd though, so i'd say it hits your criteria at least technically :)
23:46:46 <Adamant> "mean what I mean, not what I say!" - The Programmer's Lament
23:46:47 <dons> lispy: so fixes have hit the repo now.
23:46:55 <arcatan> hmm, J looks interesting
23:47:02 <lispy> dons: ah
23:47:05 <glguy> Has there ever been any effort to make a .NET compatible Haskell implementation?
23:47:07 <lispy> i'll pull and update
23:47:12 <dons> now, what's left to do. goa+no output, and @list ?
23:47:21 <lispy> dons: yeah
23:47:27 <dons> i'll do the 2nd one first.
23:47:33 <lispy> dons: maybe some other things...i wish cgi logging was working
23:47:46 <lispy> okay, i'll way to pull
23:48:16 <glguy> J makes it easy to do the implicit equivalent of ((->)r) coding
23:49:13 <dons> hmm, I'm not sure about @list yet actually. need to think about the best way to do it
23:49:38 <dons> lispy, oh, what's a good command to trigger the goa+no output issue?
23:50:13 <lispy> oh
23:50:21 <lispy> um...i did it with a broken lambdabot  :)
23:51:10 <lispy> we at least know the bug would be with getOutput
23:51:15 <dons> yep
23:52:30 <lispy> ?hoogle runInteractiveProcess
23:52:30 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
23:52:38 <dons> ?id
23:52:43 <dons> would do it, i think
23:53:01 <lispy> ?index System.Process
23:53:02 <lambdabot> bzzt
23:53:09 <lispy> ?doc System.Process
23:53:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
23:53:17 <lispy> ?. tiny-url doc System.Process
23:53:17 <lambdabot> compose module failed: IRCRaised Parse error: "doc"
23:53:33 <dons> doc is a typo
23:53:40 <lispy> ah
23:53:44 <dons> ?. tiny-url docs System.Process
23:53:45 <lambdabot> http://tinyurl.com/lw4ug
23:53:56 <dons> (no spell correction in @compose)
23:54:15 <lispy> thanks
23:54:48 <dons> ?quit new code
23:55:42 <dons> ?vers
23:55:55 <deadbeef> ?vers
23:56:06 <dons> we just wait on freenode...
23:56:09 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
23:56:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:56:15 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
23:56:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:56:20 <deadbeef> ops sry
23:56:28 <deadbeef> btw why OpenBSD ?
23:56:39 <deadbeef> it's a 386 emulator for pentium 4
23:56:41 <wolverian> more importantly - why the space before the )? :)
23:57:09 <dons> oh, there's no /proc on openbsd, so the cpu type gets turned into ""
23:57:17 <glguy> Why OpenBSD?? Does dons need a reason to use the finest POSIX operating system available to him?
23:57:19 <dons> on linux you get a Ghz count
23:57:42 <wolverian> ah. that makes sense in a way that is still buggy. :)
23:57:46 <deadbeef> glguy: lol
23:57:48 <wolverian> (but I know the pain)
23:58:18 <deadbeef> dons: are you using uname() ?
23:58:27 <dons> "GHC ", GHC_VERSION, " (", PLATFORM, " ", CPU, ")",
23:58:35 <glguy> OpenBSD has $ sysctl hw.cpuspeed
23:58:43 <glguy> (among others, I'm sure)
23:58:54 <dons> sure. I suppose I could detect that if I really cared :)
23:59:01 * dons has sysctl.hwspeed in his dwm status bar :)
23:59:12 <glguy> In case it changes?
23:59:16 <glguy> You'll know right away?
23:59:16 <dons> yep
23:59:30 <dons> thinkpad, I like to know when i'm switching between fast and slow cpu speed
23:59:30 <glguy> phew, that could avoid some potentially close calls (c:
23:59:34 <glguy> ahh
23:59:40 <glguy> fair enough
23:59:51 <dons> i.e. oh, this compile is slow cause i've clocked it down to 0.6Ghz
