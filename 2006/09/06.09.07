00:00:02 <dylan> I'm seeing if I should rewrite my chat server (currently in python) in haskell.
00:00:26 <dylan> the biggest nastiness currently is an elegant way to store user profiles and groups (groups == channels)
00:01:15 <dylan> (of course, a big reason for haskell is scaling to dual/quad/etc cores. But erlang can do that and has mnesia, and I've got a prototype of the chat server in erlang anyway)
00:01:23 <dylan> (I didn't write that though.)
00:01:49 <dons> chat server? irc?
00:01:54 <dylan> dons: my own protocol
00:02:00 <dons> ah ok
00:02:04 <dylan> doesn't require contextual parsing like IRC does.
00:02:08 <dons> i imagine you can. lambdabot seems to manage somehow :)
00:02:30 <dons> and if you're super tricky, you could probably steals some lambdabot plugins
00:02:45 <dylan> it's just map unescape $ split("\t", $s) $ getLine
00:03:03 <dylan> heck, if I get something, I'll port lambabot to haver. ;)
00:05:24 <lispy> dylan: i wanted to do unbuffered io from the clients and broadcast it to all the others...so i was thinking something like, client handling threads: read available input, buffer into lines, then read from global queue (to get messages from other clients) then wait for more input or global messages
00:05:43 <lispy> i must have hab a bad design though, because i've never really gotten it to work
00:05:44 <dylan> ah, and hopefully haskell will make commands like CHANGE-LOBBY easier...
00:06:21 <lispy> maybe arrows wouldhelp
00:06:28 <lispy> do arrows help with current programming?
00:06:33 <dylan> Probably -- it's a bit of nesting.
00:06:44 <lispy> with their abstraction about multiple production lines?
00:07:30 <lispy> my closest implementation that seemed to work had a subtle space leak
00:07:42 <lispy> it would run fine for a while but after a few hours the machine would run out of memory
00:08:02 <lispy> i should look at it sometime when i have the STM paper in hand
00:08:33 <dylan> I'd actually like to use http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Concurrent-Chan.html.
00:09:02 <lispy> why would thaat be good?
00:09:02 <dylan> but I'm sort of biased by Erlang exposure.
00:09:29 <lispy> this is a good discussion, but i need sleep :)
00:09:44 <lispy> i'll bug you about it the next time it makes sense to talk about it :)
00:09:46 <dylan> well, on initial inspection it seems writeChan == erlang's ! (send message) and readChange == receive...
00:10:16 <dylan> lispy: interestingly, your name keeps reminding me I need to learn autolisp in a month.
00:10:26 <lispy> heh
00:10:32 <lispy> never tried learning autolisp
00:10:39 <lispy> but then i don't do any drafting
00:11:05 <dylan> I don't either, I'm just the IT department of a architectural firm. :(
00:11:14 <lispy> ah
00:11:37 <falconair> has anyone here done any genetic programming work with haskell?
00:11:41 <lispy> yeah, funny thing about being a software engineer at a traffic engineering consulting firm is they want me to take classes on traffic engineering :)
00:11:50 <lispy> but i sleep now :)
00:11:52 <lispy> ttyl
00:11:53 <vincenz> Hello
00:12:02 <dylan> 'ello vincenz.
00:12:03 <vincenz> moin
00:12:10 <lispy> vincenz: hi and good night :)
00:12:17 * dylan passes out
00:12:19 <vincenz> lispy: hi and bye :)
00:15:06 <dons> ?users
00:15:09 <lambdabot> Maximum users seen in #haskell: 232, currently: 208 (89.7%), active: 33 (15.9%)
00:15:13 <dons> ?uptime
00:15:13 <lambdabot> uptime: 2d 7h 39m 8s, longest uptime: 2d 7h 39m 8s
00:15:58 <falconair> eh..no genetic programming experts here?  how about this, given a datatype which represents the terms of lambda calculus (like so many text books), is there a way I can 'generate' random lambda expressions (perhaps an expression tree), which can later be evaluated, printed to screen, combined with  other such generated lambda expressions?
00:17:07 <dons> use the Arbitrary class from QuickCheck
00:17:27 <dons> that is, write an instance Arbitrary Term where ....
00:17:34 <dons> and it'll generate randomised Terms for you
00:17:53 <dons> ?docs QuickCheck
00:17:54 <lambdabot> QuickCheck not available
00:18:09 <dons> ?fptools QuickCheck
00:18:09 <lambdabot> QuickCheck not available
00:18:13 <dons> boo
00:18:49 <falconair> dons: i i'll search for quickcheck, thanks
00:27:08 <norpan> @docs Test.QuickCheck
00:27:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
00:27:19 <norpan> @fptools Test.QuickCheck
00:27:19 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
00:33:34 <vincenz> hmm
00:33:51 * vincenz wishes that it were possible to see if a mail he got was from a standard spam or not
00:36:28 <dolio> ?pl \x y -> f 3 x 4 y
00:36:29 <lambdabot> flip (f 3) 4
00:36:40 <Baughn> vincenz: It is. Um.. razor. Yeah, that's it.
00:36:47 <vincenz> o.O
00:36:53 <vincenz> Baughn: huh?
00:37:06 * vincenz got an invitation to write for a transaction in response to a paper he presented at a conference
00:37:14 <vincenz> Now I'm curious if they masssend those or if they select whom to email
00:37:16 <Baughn> vincenz: A database of known spam emails, that also doubles as an email filter
00:37:34 <Baughn> vincenz: ..hmm. Well, if you're lucky some razor user pressed "spam". ;)
00:37:45 <vincenz> nono
00:37:52 <vincenz> it's not -real- spam
00:39:28 <dolio> A lot of spam has been getting through my (and Google's, for that matter) filter lately.
00:39:42 <dolio> It all appears to be copied from some random source.
00:39:57 <dolio> I got one that had random sentences all clearly from The Three Musketeers.
00:40:23 <vincenz> oh yeah
00:40:28 <vincenz> lately I'm getting one type of spam that isn't filtered
00:40:37 <vincenz> the type of "Hey I am at a cafe and I saw blabla...email me at .."
00:40:46 <vincenz> even though it has the word "abm" instead "am"
00:40:59 <vincenz> goes straight through gmail and my thunderbird spam filters
00:41:37 <Baughn> I've got the solution
00:41:54 <Baughn> Stop reading email!
00:41:57 * Baughn sighs
00:42:06 * vincenz actually wants to set up a proper mail system on his lappy with fetchmail, but I don't know how to use procmail
00:42:21 <Baughn> vincenz: It's easy, really. Look at the examples.
00:42:56 <vincenz> yeah but I'd rather know what I was doign instead of blindly typing in letters
00:43:14 <vincenz> that's why I never got into emacs, I like to know the software I use
00:43:22 <vincenz> and there were just too many small functions and settinsg
00:43:29 <Baughn> But emacs.. it's all elisp...
00:43:41 <vincenz> yeah I know, but it's a huge bunch of functions
00:43:44 <Baughn> Anyway, those small functions don't do anything if you don't call them
00:43:45 <vincenz> but this is a red herring
00:43:59 * Baughn produces a turqoise herring. I'm a herring specialist.
00:44:11 <vincenz> idaelly
00:44:13 <dons> SamB, I've added offline contextual support, and fixed your regex
00:44:16 <dons> lambdabot> !nick++
00:44:19 <dons> nick's karma raised to 1.
00:44:31 <vincenz> I'd have one central mbox or .mail so that I can fetchmail from differen sources
00:44:42 <vincenz> then I'd like to read em with thunderbird so I can reorganize a bit myself
00:45:01 <vincenz> and possibly even have filters like "when I get mail X from Y and Z, then keep the Z version (I forward all work email to gmail, which leads me to having doubles)
00:46:21 * vincenz has like 5 mail accounts :/
00:47:16 <Baughn> Happily, emails have a nice ID field you can use for that
00:47:51 <vincenz> so emails are uniquely id'd even when forwarded?
00:49:13 <Baughn> *nod*
00:56:10 <dons> ?quit new code
00:56:50 <dons> ?version
00:56:53 <vincenz> @bot
00:57:09 <vincenz> @bot
00:57:11 <vincenz> hmm
00:57:14 <dons> wait on freenode...
00:57:17 <lambdabot> lambdabot 4p138, GHC 6.5 (OpenBSD i386 )
00:57:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:57:25 <lambdabot> :)
00:57:33 <dons> SamB++ -- new code!
00:57:39 <lambdabot> :)
00:57:44 <lambdabot> SamB's karma raised to 14.
00:58:37 <int-e> C++ C-- C++ C--
00:58:38 <lambdabot> C's karma raised to 1.
00:58:42 <dons> SamB, so its that that will annoy #perl6? or can they live with it?
00:59:03 <vincenz> dons++
00:59:04 <lambdabot> dons's karma raised to 56.
00:59:09 <vincenz> vincenz--
00:59:09 <lambdabot> You can't change your own karma, silly.
00:59:14 * vincenz whews
00:59:18 <vincenz> @karma vincenz
00:59:19 <lambdabot> You have a karma of 7
00:59:21 <vincenz> :/
00:59:25 <int-e> @karma C
00:59:26 <lambdabot> C has a karma of 1
00:59:44 <vincenz> C--
00:59:45 <lambdabot> C's karma lowered to 0.
00:59:49 <vincenz> I liek C++
00:59:53 <vincenz> ah good :)
00:59:59 <dons> I'm inclined not to have a special case for ^C++$
01:00:02 <int-e> C++ isn't so bad
01:00:03 <lambdabot> C's karma raised to 1.
01:00:08 <int-e> ;)
01:00:12 <vincenz> C++ sucks
01:00:13 <lambdabot> C's karma raised to 2.
01:00:19 <dons> okok
01:00:23 <int-e> C--, too. And c++, c--.
01:00:27 --- mode: Cale set -o Cale
01:00:43 <Cale> yeah, fix that one, it's been annoying me in mbot for a while :)
01:00:51 <Cale> (but not enough to fix it :)
01:00:53 <dons> what's that?
01:00:59 <Cale> The C++ thing
01:01:11 <dons> hmm?
01:01:15 <dolio> C++++
01:01:20 <Cale> <vincenz> C++ sucks
01:01:20 <Cale> <lambdabot> C's karma raised to 2.
01:01:31 <dons> how could that be annoying you in mbot?
01:01:35 <dons> does mbot support this syntax/
01:01:36 <int-e> mbot is Cale's lambdabot. C-- is a possible nickname for Cmm.
01:01:38 <Cale> people talking about C++ :)
01:01:51 <vincenz> Cale: he meant the XXX++ syntax is new
01:01:52 <dons> ah, you've had SamB's patch running?
01:01:53 <Cale> yeah, it does, because you added support for it :)
01:02:02 <Cale> yeah, it's in darcs
01:02:07 <dons> yeah right. ok.
01:02:10 <dons> i'll fixify
01:05:32 <dons> ?quit wibbles
01:06:30 <dons> ?karma C
01:06:55 <lambdabot> C has a karma of 2
01:07:00 <dons> C--
01:07:04 <dons> ?karma C
01:07:04 <lambdabot> C has a karma of 2
01:07:08 <int-e> c--
01:07:09 <dons> ?karma- C
01:07:09 <lambdabot> C's karma lowered to 1.
01:07:24 <dons> the ^nic++ form is silent now too
01:07:32 <dons> c-- will work though
01:07:37 <dons> ?karma c
01:07:37 <lambdabot> c has a karma of -2
01:07:43 <dons> but I don't care :)
01:07:45 <int-e> @karma+ C C is neat for what it does.
01:07:46 <lambdabot> C's karma raised to 2.
01:08:10 <dons> lambdabot++ -- getting smarter all the time
01:08:15 <dons> ?karma lambdabot
01:08:15 <lambdabot> lambdabot has a karma of 21
01:08:32 <int-e> int-e++ is silent, too?
01:08:38 <dons> yep
01:20:23 <psnl> @seen heffalump
01:20:24 <lambdabot> heffalump is in #darcs. I last heard heffalump speak 1h 20m 15s ago.
01:23:40 <dons> ?seen dcoutts__
01:23:40 <lambdabot> dcoutts__ is in #ghc, #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I don't know when dcoutts__ last spoke.
01:23:51 <dons> ?uptime
01:23:52 <lambdabot> uptime: 18m 17s, longest uptime: 2d 8h 20m 7s
01:23:57 <dons> ?users
01:23:57 <lambdabot> Maximum users seen in #haskell: 232, currently: 210 (90.5%), active: 6 (2.9%)
01:38:41 <araujo> morning!
01:45:51 <araujo> beu, :-)
01:47:09 <beu> oi oi :>
01:56:32 <dons> hmm. we should have a Debug monad over IO, which traces evaluation. I wonder if that would be useful
01:59:41 <musasabi> not really as most code is explicitely in IO rather than generic MonadIO
02:05:50 <dons> yeah, you'd need to be able to change just one line, and it would start using a 'trace' >>=
02:05:58 <dons> ah well, hat is the tool for this anyway
02:06:08 <eivuokko> If ghc had little bit help via generating some debug info, we could do it easily enough via normal naitve debugging.
02:06:25 <eivuokko> *ghc gave
02:07:11 <roconnor> @users
02:07:11 <lambdabot> Maximum users seen in #haskell: 232, currently: 212 (91.4%), active: 15 (7.1%)
02:08:27 <musasabi> There is the new ghci debugging support.
02:08:39 <musasabi> It needs someone to write a tutorial/article.
02:21:35 <dolio> Boy, I love slashdot.
02:21:45 <falconair> is the bind operator (>>=) for Monads similar to the fold operator in lists?
02:21:59 <dolio> IronPython? "But does the world really need yet another programming language? Aren't there enough of them around already?"
02:22:50 <dolio> You're all wasting your time. C, Java and Perl are enough for everybody. :)
02:22:53 <araujo> haha
02:23:13 <dons> falconair: hmm. >>= is implemented as foldr ((++) . k) [] m for lists
02:23:30 <dons> so >>= for lists, is similar to foldr for lists :)
02:26:16 <dolio> A lot of monads don't have a structure that really makes sense to talk about folding on.
02:28:53 <falconair> dons: i've read that a list comprehension can be desugarred to a bunch of fold functions.  It seems the do notation only needs the bind operator for sequencing and 'assignment' ...
02:28:55 <falconair> I also remember reading that the list comprehension syntax was used for monads before the 'do' notation ... since fold is a very fundamental function (more than many newbies such as my self first realize ... catamorphisms and all) ... am I right to assume that the bind operator is also very important in some fundamental sense?
02:29:30 <falconair> never mind, i don't even understand what I'm asking
02:31:47 <dolio> ?type \m f -> join (fmap f m)
02:31:49 <lambdabot> forall (f :: * -> *) a a1. (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
02:32:02 <dolio> You can implement >>= that way.
02:32:10 <dolio> fmap for lists is map
02:32:17 <dolio> join for lists is concat
02:32:30 <dolio> Both of which can be written as folds.
02:34:25 <falconair> interesting, i think i can get monads into my brain more easily by linking them to lists whenever possible
02:35:09 <falconair> thanks all, need to continue reading
02:35:50 <dolio> There's a couple papers out there...
02:36:06 <dolio> Monads as Containers and Monads as Computations (or something like that).
02:36:19 <dolio> do notation is more linked to the latter...
02:36:32 <dolio> list/monad comprehensions is more like the former.
02:38:11 <dolio> Hmm, maybe I'm just imagining the second paper.
02:38:28 <falconair> there is a wiki page on monads as containers, i didn't find anything on monads as computations
02:38:30 <dolio> Anyhow, that's how a lot of intros describe the IO monad.
02:38:40 <falconair> oh, you said that already :)
02:38:46 <dolio> :)
02:39:20 <dolio> IO a is a computation that can do IO that results in a.
02:39:26 <dolio> Or, a value of type a.
02:39:50 <dolio> [a] is a non-deterministic computation the results in a value of type a.
02:40:26 <dolio> Maybe a is a computation that results in a value of type a that can fail.
02:40:34 <vincenz> Either Err a is the same but with exceptions
02:40:39 <vincenz> :D
02:40:56 <vincenz> it's a pity that fail requires strings :/
02:41:05 * vincenz mutters
02:41:44 <falconair> it seems that even languages that don't need to be referentially transparent would benefit from having a monad like interface...it seems to allow one to abstract out common functionality among surprisingly diverse areas of programming
02:41:50 <vincenz> it means it exists completly outside the exception mechanism if one wants to make a monad that works with exceptions
02:42:06 <vincenz> falconair: yep :)_
02:42:31 <dolio> :) I have a paper somewhere here about "The Java Monad."
02:42:37 <Baughn> Is there anything "special" about monads except the do macro, or is it just another class?
02:42:56 <dolio> Which, I assume, has something to do with representing the imperative programming in Java in terms of monads.
02:43:04 <vincenz> Baughn: "just another class"
02:43:13 <Baughn> vincenz: In scare quotes?
02:43:16 <araujo> Baughn, 'do' is just syntac sugar for the monadic operators.
02:43:26 <vincenz> but it's based on lots of research which has led it to this simple interfacethat is nonetheless very powerful
02:43:32 <araujo> Evidently, there is more importance behind it.
02:43:34 <vincenz> it abstracts computations
02:43:51 <Baughn> Sounds good to me. They're unexpectedly simple once you get rid of do..
02:44:28 <araujo> well, 'do' comes in handy when you need a bunch of monadic lines.
02:44:46 <Baughn> True. It's useful for programming, but maybe not so much for understanding them
02:44:46 <vincenz> do is great to write "imperative" code
02:45:53 <Baughn> I do tend to think that "Create a structure representing an imperative program and return it" is a complete cheat, though. ;)
02:46:15 <vincenz> no it is not
02:46:26 <vincenz> it's just a lack of other languages that they do not allow this powerful metaphor
02:46:51 <araujo> Well, actually, they are structure compositions Baughn
02:47:15 <vincenz> computation = data :)
02:47:20 <vincenz> until applied
02:47:37 <araujo> You can think of monads like a way of combining computations to build larger ones.
02:48:11 <Baughn> Right. It's odd how natural they seem now, when I remember being utterly confused just a few days ago...
02:48:16 <araujo> This kind of abstractions just happen to help programming imperatively in a purely functional language.
02:48:56 <vincenz> Baughn: monads reqquire a zenslap
02:48:58 <araujo> yeah, they are plain simple when you grasp the basic stuff very well :-)
02:49:21 <Baughn> vincenz: I haven't had one
02:49:27 <velco> what other languages do not allow monads ?
02:49:44 <velco> (except asm and derivatives)
02:50:06 <vincenz> velco: o.O
02:50:08 <Baughn> Asm would allow them just fine, I suspect
02:50:21 <vincenz> any turing cmoplete langauge allows em
02:50:27 <vincenz> they're just not very leniant towards it
02:50:29 <Baughn> ..Java. It doesn't have functional abstraction.
02:50:58 <vincenz> Baughn: sure it does, with a lot of syntactical crap
02:51:26 <Baughn> Right, the class-per-lambda style of programming...
02:51:31 <vincenz> yep
02:51:41 <dolio> :)
02:51:41 <velco> I guess what Haskell has is the the ``do'' syntax, but mu understanding so far was that there's no problem using mondas in ML or CL or scheme ?
02:52:11 <velco> ( I hope I don;t miss something importans)
02:52:12 <Baughn> It wouldn't be a problem implementing it in any of those, but they don't have it in the library either
02:52:34 <vincenz> velco: the first problem, is that of polymorphism through TCs
02:52:55 <vincenz> velco: for instance you could write "bind ""return" etc ni another language but only for one monad
02:53:08 <Baughn> velco: Except for the very useful typing, Haskell could be compiled to CL pretty easily
02:53:40 <Baughn> Type constraints would take a bit more work, sure. ;)
02:55:17 <musasabi> Monads are mostly a normal class. There are a few invariants they should conform to (http://www.nomaware.com/monads/html/laws.html)
02:55:18 <lambdabot> Title: The monad laws
02:55:20 <Cale> you'd need to implement dictionary passing for typeclasses
02:55:45 <Cale> Which would turn plain looking Haskell code into a mess.
02:55:46 <bourbaki> moin
02:55:47 <musasabi> (the three laws there)
02:55:56 <Baughn> Cale: Compilation tends to do that
02:56:01 <Cale> well, yeah :)
02:56:28 <Cale> But of course, you can compile between any two Turing complete languages somehow :)
02:56:37 <bourbaki> quick question can you use arrows to "crunsh" any program (deternimistic/indeterministic/concurrent) into a single arrow?
02:56:47 <Baughn> The main issue, of course, is that no other compiler than Haskell's really optimize for having a lambda per line. ;)
02:57:05 <musasabi> bourbaki: yes. But not necessary in any practical way.
02:57:33 <bourbaki> musasabi that means like crunshing an interpreter arrow thingy into it or so?
02:57:42 * mux wonders if bourbaki uses this nick in reference to the virtual maths author
02:58:00 <bourbaki> mux you wonder correctly ;)
02:58:23 * ibid has actually tried to read one of the books
02:58:29 <musasabi> yes. But e.g. monadic things have direct arrowic counterparts (via the trivial kleisli-arrow encoding)
02:58:38 <mux> no wonder you find maths geeks in #haskell :-)
02:58:56 * ibid is a former maths major
02:59:20 <mux> we should all meet together and prove the RH once and for all :-P
02:59:25 <bourbaki> musasabi is there any paper out there on arrows and petri net like programs?
02:59:53 <bourbaki> i still have a hard time to develop a propper way to "fold" recursive or cyclic structures into a single arrow
03:00:07 <bourbaki> mux RH? red hat ;)?
03:00:11 <mux> heh.
03:01:10 <dolio> Riemman Hypothesis?
03:01:26 <mux> yes
03:01:44 <mux> it's Riemann though
03:01:56 <bourbaki> ah
03:02:06 <dolio> Oops.
03:02:09 <bourbaki> i have solved that already
03:02:10 * ibid is more a logic guy
03:02:11 <musasabi> bourbaki: I am not aware of any. The only Haskell Petri net stuff I am aware of is HCPN (http://www.cs.kent.ac.uk/people/staff/cr3/publications/HCPN.html)
03:02:14 <lambdabot> Title: Publications: HCPN, http://tinyurl.com/kzvuo
03:02:18 <bourbaki> but lost the stuff in the paper pile over here
03:02:23 <mux> bourbaki: hah! too bad :-)
03:02:28 <mux> you lost $1m
03:02:33 <ibid> one of the reasons i dropped out of the analysis-heavy program :)
03:02:54 <bourbaki> differential geometry is sexy :)
03:03:18 <bourbaki> musasabi hm ok but you do not happen to know if it uses or support arrows for the edges of the petri net do you?
03:04:02 <musasabi> I don't think it uses arrows. But their first paper predates the arrow papers.
03:04:27 <bourbaki> ah i see dang maybe they arent even active then anymore
03:05:04 <bourbaki> would anyone maybe interested in writeing a coulered petri net with arrow operations on edges and some topological operations on the networks with me?
03:05:47 <musasabi> well they have published two papers - one in 1999 and one in 2004. The arrow papers started to circulate wider with the Hughes paper in 200...
03:06:30 <bourbaki> i think that this would go along quite well as long as the graph is non cyclic its quite trivial
03:09:12 <bourbaki> hm maybe i can hand in a paper on that on that conf :)
03:10:18 <apfelmus> hello int-e, i'm getting "permission denied" on http://int-e.home.tlink.de/haskell, especially haskell/readinteger
03:10:37 <int-e> I did write that browsing directly doesn't work.
03:11:19 <apfelmus> int-e: oops, sorry
03:11:28 <bourbaki> has anyone been on one of the ifl meetings ?
03:15:07 <foxy__> anyone know how to get a ceiling symbol in LaTeX?
03:15:36 <int-e> \lceil xxx \rceil I think (they're brackets)
03:16:28 <foxy__> The standard symbol for numerals in \-calculus doesn't go all the way to the floor on the sides like \lceil and \rceil
03:28:59 <pejo> foxy, if not l/rceil, ul/urcorner maybe? Think they're in the stmaryrd package.
03:31:33 <foxy__> thanks
03:32:34 <foxy__> pejo, they worked with package amsfonts :)
03:37:54 <kowey> falconair: dmhouse wrote something which might interest you - http://en.wikibooks.org/wiki/Haskell/Advanced_monads
04:09:54 <vincenz> re
04:22:56 <tibbe> @yarr
04:22:57 <lambdabot> Aye
04:23:17 <vincenz> @arr
04:23:18 <lambdabot> Yo ho ho, and a bottle of rum!
04:26:07 <psnl> @rr
04:26:08 <lambdabot> Aye
04:26:12 <psnl> @r
04:26:12 <lambdabot> Maybe you meant: read reconnect redo remember resume run . v
04:28:11 <SamB> @yarr!
04:28:12 <lambdabot> What be a priate's favourite cheese?
04:28:13 <lambdabot> Yarrlsburg!
04:28:22 <vincenz> typo
04:28:34 <SamB> vincenz: what typo?
04:28:37 <vincenz> priate
04:28:42 <SamB> oh, priate
04:28:45 <SamB> hehe
04:32:01 <tibbe> perhaps she has a lisp?
04:32:34 <SamB> you think thee hath a lithp?
04:34:13 <sieni> that boat thunk
04:34:33 <SamB> that thounds funny
04:34:54 <sieni> thoundth!
04:34:55 <vincenz> thieni thinks
04:43:10 <tibbe> I've discovered a new way to solve problems while programming. deal with them a week later, at that point I can't remember what the problem was so I don't need to fix it!
04:43:39 <SamB> hahaha
04:43:57 <SamB> tibbe: you are supposed to write tests
04:44:00 <sieni> tibbe: I do that all the time!
04:44:08 * SamB wonders if edwardk got any use out of his ZMachine
04:44:13 <tibbe> actually I'm doing that right now, I know I designed something a certain way to work around some problem but now I can't understand how the problem made the current design neccesary
04:44:38 <tibbe> SamB, I actually have some tests, not for this though
04:49:52 <tibbe> argh, I can't remember why I did this, seriously
04:50:13 <SamB> tibbe: what was the other way you could have made it?
04:50:17 <tibbe> but if I revert to the old implementation I'm sure the problem will resurface
04:50:23 <tibbe> a simpler way
04:50:27 <SamB> what are you doing anyway?
04:50:43 <tibbe> implementing a state machine for two session protocols
04:50:59 <tibbe> and the protocols are similar but not equivalent
04:51:18 <tibbe> so I did something to remedy that problem
04:51:29 <tibbe> but I can't see why that was neccesary right now
04:51:59 <tibbe> the problem was that one of the protocol didn't have enough information in its header to run the statemachine
04:52:03 <SamB> show types!
04:52:16 <tibbe> you wan't me to paste some java classes ;)
04:52:22 <SamB> oh, nevermind
04:52:23 <tibbe> State x Event -> State
04:52:30 <tibbe> would be the type
04:52:34 <SamB> didn't know you were writing in Java!
04:52:39 <tibbe> :p
04:52:42 <tibbe> work
04:52:56 <tibbe> Event is my abstraction of the protocol specific things
04:53:04 <SamB> that doesn't make sense to me as a type...
04:53:12 <tibbe> but now some of the abstraction I did seems unneccesary
04:53:13 <SamB> do you mean (State, x, Event) -> State ?
04:53:21 <tibbe> no no
04:53:24 <tibbe> a product
04:53:28 <SamB> oh.
04:53:28 <tibbe> (State, Event)
04:53:33 <SamB> (State, Event) -> State
04:53:37 <SamB> heh
04:53:43 <tibbe> State -> Event -> State if you want
04:54:00 <tibbe> state machines are the root of all evil
04:54:21 <SamB> well, I figure since Java doesn'ty have currying we can write the args as tuples ;-)
04:54:41 <tibbe> yeah
04:55:19 <SamB> so is this abstraction comprehesible?
04:55:24 <SamB> er, comprehensible?
04:55:46 <tibbe> well, yes
04:56:20 <tibbe> right now it's, isNotification, isRequest, i.e. a number of predicate that are meant to capture the relevant parts of the message headers of the two protocols
04:56:30 <tibbe> predicates*
05:03:24 <xerox> @arrr
05:03:25 <lambdabot> Keelhaul the swabs!
05:04:09 <absent-minded-co> bah, I wanted absent minded coder
05:06:21 * tibbe cries
05:09:03 <dcoutts__> @seen dons
05:09:03 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 38m 52s ago.
05:09:17 <dcoutts__> dons: toChunks/fromChunks looks fine to me
05:09:24 <dcoutts__> as does he other changes
05:09:32 <dons> ok. good
05:16:24 <xerox> ?quote adept
05:16:25 <lambdabot>  Tried to co-read and co-understand comonads, but got co-re dump
05:16:30 <xerox> ?quote adept
05:16:30 <lambdabot>  I think I need cobrain to understand coeffects
05:16:33 <xerox> haha.
05:18:05 * vincenz snickers
05:18:07 <vincenz> @quote xerox
05:18:08 <lambdabot>  I am really interested specifically in bottoms in this very moment.
05:18:15 <vincenz> LOL
05:18:18 <vincenz> @quote vincenz
05:18:20 <lambdabot>  Geek is Chique.
05:20:46 <xerox> ?quote malig
05:20:46 <lambdabot>  I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
05:20:49 <xerox> ?quote malig
05:20:49 <lambdabot>  quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
05:20:53 <xerox> That, haha.
05:54:30 <tibbe> I would like lazily generate a a stream of random strings without repetition of length 8
05:54:57 <tibbe> is that possible? could I do a random shuffle of a list of strings
05:55:08 <tibbe> ie ["aaaaa", "aaaaab", ...]
05:55:26 <tibbe> so I'm guaranteed not to have any repetitions until I reach the end?
06:03:51 <xerox> tibbe: doesn't them repeat the 'a' ?
06:05:25 <Limbic_Region> Igloo ping
06:06:05 <xerox> tibbe: @oldwiki LicensedPreludeExts has code for combinations and permutations.
06:06:11 <tibbe> xerox, let me try to be a bit more clear, I need to generate unique prefixes for a string
06:06:19 <tibbe> @oldwiki
06:06:19 <lambdabot> http://www.haskell.org/hawiki/
06:06:31 <tibbe> hmm
06:06:41 <xerox> @oldwiki LicensedPreludeExts
06:06:41 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
06:06:41 <tibbe> it's not really permutations is it
06:06:49 <tibbe> ?
06:06:58 <tibbe> or perhaps
06:07:31 <tibbe> every character should appears once in each of the 8 positions and then a list with all those combinations should be randomly reordered
06:47:38 <Baughn> I'm trying to install HAppS, but it seems to not have been updated since May. Any solutions, or alternate HTTP servers around?
06:50:58 <dcoutts__> you could try using the dev version
06:51:11 <dcoutts__> there is certainly active development going on
06:52:28 <Baughn> I tried that, but the latest patch is from may 24. Is it in a separate repository?
06:53:29 <Baughn> ..jun 2. Out of order.
06:56:48 <musasabi> test.happs.org has the more unstable code. + I have the fps patch floating around.
06:57:51 <musasabi> but yes, not much has happened during summer I was away from most stuff.
06:58:21 <Baughn> It appears to be the exact same page. It strikes me as strange, however, that fps wouldn't change its version number when it broke source compatibility
06:58:43 <AStorm> Hey guys, how to simply do: [x] -> [(index1, x1), (index2, x2), ...]
06:58:51 <AStorm> Any nice builtin?
06:59:44 <AStorm> [x] -> [(0, x1), (1, x2), ...] you know :>
06:59:54 <kowey> AStorm: zip?
07:00:16 <AStorm> No no, the index of the item of array.
07:00:21 <wilx|wrk> zip [1..] arr?
07:00:26 <AStorm> ehm, list.
07:00:35 <wilx|wrk> > zip [1..] ["a". "b"]
07:00:36 <lambdabot>  Couldn't match `b -> c' against `[Char]'
07:00:39 <AStorm> Nothing built in, ehh. :>
07:00:56 <kowey> > zip [1..] ["a", "b"]
07:00:57 <lambdabot>  [(1,"a"),(2,"b")]
07:01:12 <ProfTeggy> AStorm: make you own ''builtin'':  let number = zip [1..]
07:01:13 <wilx|wrk> Oops. Typoed.
07:01:33 <AStorm> ProfTeggy: Just hoped there's something "more standard" for that. Oh well :-)
07:01:43 <ProfTeggy> AStorm, this *IS* standard
07:01:44 <wilx|wrk> Heh. There is no need for such special function.
07:01:52 <ProfTeggy> Haskell list processing is all about combining primitives
07:08:27 <AStorm> Not a problem with that :>
07:20:53 <Baughn> I've got a package (wash) that attempts to call RTS to compile itself. Any idea what RTS is?
07:22:49 <ibid> run-time system, though i don't know if it makes sense in this context
07:25:05 <Baughn> It's supposed to be a command, yes
07:25:18 <Baughn> I suspect it's meant to be $RTS. :/
07:27:51 <vincenz> dons: ping
07:32:48 <vincenz> dcoutts__: ping
07:33:00 <dcoutts__> @yarr!
07:33:00 <lambdabot> Ahoy mateys
07:33:10 <vincenz> dcoutts__: what do you use to write your todos?
07:33:17 <vincenz> dcoutts__: like if you're working on a paper and have some ideasp lanned for future
07:33:37 <bringert> Baugh: maybe it tries to call ghc, with the +RTS ... -RTS stuff to give flags to the run-time systems, but it has an empty path instead of ghc
07:33:50 <bringert> Baughn: that way you would only see RTS as the command
07:33:58 * vincenz 's colleague uses onenote by microsoft but /me is on linux
07:34:07 <bringert> Baughn: what's the error message that you get?
07:34:12 <dcoutts__> vincenz: I use a file in the paper repo called TODO :-)
07:34:28 <vincenz> dcoutts__: just plain text?
07:34:32 <vincenz> or some sort of syntax?
07:34:41 <vincenz> and I don't mean TODO w.r.t. paper
07:34:44 <vincenz> but TODO in general of your phd
07:34:46 <Baughn> bringert: It tries to execute "RTS -M400m -RTS -O -ffi -package-name WashNGo  +RTS -M400 (...)"
07:35:07 * vincenz is trying to find a good way to organize his stuff, I switched from notebook as I hated it, now I use white loose-leafs but that is a fragile system and hard to refactor
07:35:09 <bringert> Baughn: ok, it is what I suspected
07:35:33 <bringert> it probably does $GHC +RTS -M400m -RTS -O ... somewhere, but $GHC is not set
07:36:12 <bringert> it is really trying to run ghc, but probably can't find it
07:37:11 <Baughn> bringert: I'll look at it later. Gentoo's build system seems a mite... baroque, in dev-haskell/
07:37:45 <bringert> dcoutts__: you're a gentoo guy, aren't you?
07:37:57 <dcoutts__> bringert: yep
07:38:07 <bringert> maybe you can help Baughn?
07:38:11 <bringert> (see above)
07:38:41 * Baughn notes that ve's on EMT64, and has ~amd64 in all the appropriate places in /etc/portage
07:39:04 <dcoutts__> Baughn: want to join #gentoo-haskell
07:42:40 <vincenz> dcoutts__:
07:42:40 <vincenz> ?
07:44:44 <dcoutts__> vincenz: huh?
07:45:06 <vincenz> dcoutts__: a place to note down general notes not related to current task
07:45:17 <vincenz> paper? notebook? textfile? proggy?
07:45:22 <dcoutts__> vincenz: nothing formal
07:45:31 <dcoutts__> ie in my head
07:45:45 <vincenz> oh
07:45:46 <vincenz> heh
07:45:49 <vincenz> what about meetings
07:45:59 <vincenz> and stuff like have to email X, think about Y, write about Z
07:46:24 <dcoutts__> I use evo's calendar & alarm feature
07:46:39 <dcoutts__> it's also got a TODO feature
07:46:43 <dcoutts__> though I don't use that
07:47:00 <vincenz> h
07:47:04 * vincenz hmms and nods
07:47:08 <vincenz> alright thx
07:47:13 * vincenz uses thundderbird o.O
07:47:15 <vincenz> :D
07:51:21 * johnnowak uses, er... a text file
07:52:28 <AStorm> Yet Another Newbie Question: I've written a function, for instance printing tuples. How can I make it do something else when given a tuple with second arg is a string?
07:52:58 <AStorm> Currently it's just doing a show, so that adds quotes. I would like it not to in this special case.
07:53:19 <dwm> I take a lot of notes in text files as well when I'm at a machine. And when not, on a steno pad, like meetings with no computer. Eventually I'll transcribe some of those paper notes into text files.
07:53:52 <johnnowak> AStorm: write another function. :) overloading is bad for your health.
07:54:27 * johnnowak wonders if dwm is using dwm
07:54:28 <AStorm> I know, I know :>
07:55:07 <dwm> johnnowak: Dynamic Window Manager?
07:55:13 <johnnowak> mhm
07:55:29 <dwm> Actually, no. :)  fluxbox for the past 3 years or so.
07:55:35 <johnnowak> ah, haha
07:55:41 <AStorm> I still prefer Ion3 to dwm - because of scriptability.
07:56:04 <bortzmeyer> AStorm: no, I see no quotes when doing putStr (show x)
07:56:07 <dwm> I should really 'get out of the house' as it were and try some other wm's.
07:56:08 <AStorm> If it would be scriptable in something else than Lua...
07:56:12 <johnnowak> i don't need scriptability. i just need my computer to stop hassling me. :)
07:56:18 <AStorm> bortzmeyer: uh? So why I see them?
07:56:20 <bortzmeyer> AStorm: quotes appear only when running from ghci, not from a compiled program
07:56:31 <AStorm> No, compiled one too.
07:56:38 <AStorm> I'm using putStrLn to be exact.
07:56:56 <bortzmeyer> AStorm: use putStr (show t) in a something.hs and run it with runghc or compile it, you'll see
07:57:14 <AStorm> Well, it's in a generic function if that matters.
07:57:24 <glguy> if you type :  putStrLn (show "some string")
07:57:29 <dwm> huh, I didn't know or realize that yet, about the quotes and ghci.
07:57:31 <glguy> you'll see the quotes, because you called show on a string
07:57:50 <AStorm> e.g. myprint :: (Show a, Show b) => (a,b) -> IO()
07:57:58 <bortzmeyer> glguy: yes, but not if the parameter is an array or a number or...
07:58:00 <AStorm> IO () that is :>
07:58:16 <glguy> bortzmeyer: right, in that case you must call show because arrays are not strigns
07:58:34 <Baughn> AStorm: ghci's REPL subscribes to the theory that anything it prints it should be able to read and get the same value. It's a good theory.
07:59:07 <AStorm> Good, but I'll pastebin the code and you'll find my problem :>
07:59:18 <glguy> putStrLn "Test" will not print quotes in GHCi
07:59:36 <glguy> also, as an aside, print = putStrLn . show
07:59:50 <AStorm> Yes, that doesn't, but my code is... weird.
08:00:04 <AStorm> I didn't put any quotes in explicitly. :P
08:01:43 <psi> you are calling show on a string, that's why you get the quotes (if that wasn't clear by now)
08:02:27 <AStorm> The guys above tell me that it shouldn't happen.
08:02:29 <AStorm> :P
08:02:40 <glguy> who did
08:02:40 <AStorm> http://wklej.org/id/8f7bdd433b
08:02:45 <AStorm> According to the doc, it should.
08:02:51 <psi> I think bortzmeyer misunderstood you.
08:02:54 <AStorm> bortzmeyer?
08:02:57 <AStorm> Ah, probably.
08:02:58 <AStorm> :>
08:03:12 <AStorm> That's why I wanted that o-word.
08:03:43 <CosmicRay> Igloo: it looks like you found the Alpha bug?
08:04:30 <AStorm> I mean some kind of overload.
08:05:14 <bortzmeyer> AStorm: OK, you get the quotes around strings, for reasons explained by Baughn. But not around other data.
08:05:27 <vincenz> dcoutts__: know how to inset a paragraph slightly in latex?
08:05:38 <AStorm> I know. So how to "extend" the function not to get them in that one special case? :>
08:05:41 <vincenz> dcoutts__: I'm trying to make something like itemize but without all the wasted space between the bullet points
08:05:52 <dcoutts__> vincenz: sorry, I'm not a latex expert
08:05:53 <glguy> > show "example"
08:05:55 <lambdabot>  "\"example\""
08:06:00 * vincenz nods
08:06:05 <vincenz> dcoutts__: alright, sorry for bothering :)
08:06:17 <dcoutts__> np
08:06:43 <psi> you can do overloading, but maybe it
08:06:49 <psi> it's not worth the trouble
08:07:05 <AStorm> Well, I'm still learning, so it might be :>
08:07:21 <AStorm> And I know that I should only be doing it in special cases.
08:09:24 <dwm> I have to ask: any window managers written in Haskell?
08:09:25 <psi> well, it's done via type classes, but I'm wondering a bit how you would do it in this case
08:09:46 <AStorm> Maybe it's described in YAHT, we'll see. For now it'll wait until I have some real use for that.
08:10:37 <psi> can you make the type (a, a) a member of a type class, and also (a, String)?
08:10:49 <AStorm> dwm: I don't think so, but Tuomo has been contemplating rewriting Ion3 in Haskell for quite some time... but hasn't done it as of yet :>
08:10:54 <psi> and have that work properly
08:11:17 <AStorm> (a, b) rather :>
08:11:23 <tennin> where "a" is a specific type?
08:11:34 <AStorm> No, generic.
08:11:38 <psi> yeah, a and b. no, variable.
08:11:39 <AStorm> Showable.
08:12:16 <psi> right
08:12:43 <tennin> so like instance Showable a, Showable b => ThisClass (a, b) where...
08:12:57 <tennin> and then instance Showable a => ThisClass (a, String) where...
08:13:13 * psi nods
08:14:15 <tennin> you can with GHC
08:14:37 <psi> so it's an extension?
08:14:50 <tennin> with -fallow-overlapping-instances
08:15:06 <psi> okay
08:15:09 <AStorm> Hmm, extension.
08:15:37 <AStorm> I'll keep that in mind though when I have a dire need to use it. :>
08:19:12 <AStorm> Ion really would be great if scripted in Haskell ;-)
08:19:25 <AStorm> s/scripted/scriptable/
08:20:34 <tennin> er, "Show" not "Showable"
08:21:01 <AStorm> I know.
08:21:05 <AStorm> :>
08:22:46 <AStorm> Rewriting a certain WM in Haskell would be quite an experience. Though that'll probably require much use of FFI.
08:24:14 <Philippa> yep, though that's not too painful once the bindings're written usually
08:24:24 <Philippa> ("usually" - concurrency can cause issues, admittedly)
08:24:56 <glguy> > read $ reverse $ show 34
08:24:57 <lambdabot>  Add a type signature
08:25:02 <glguy> > read $ reverse $ show 34 :: Int
08:25:03 <lambdabot>  43
08:25:10 <AStorm> That'd really be two projects. :>
08:26:11 <AStorm> Hmm, it'd be event-based mostly.
08:26:34 <psi> there are already xlib bindings: http://www.haskell.org/ghc/docs/latest/html/libraries/X11/Graphics-X11-Xlib.html. couldn't they be used to write a WM?
08:26:56 <AStorm> Might be too weak, let me see...
08:27:36 <AStorm> Seems complete.
08:27:37 <AStorm> :>
08:27:38 <xerox> This is fun, but I suggest to skip over to min 20 to get the Monad fun :) <http://channel9.msdn.com/Showpost.aspx?postid=230438>
08:27:39 <Philippa> yep. I tend to run away from projects that involve writing bindings to any real amount of C code
08:28:04 <Philippa> though I'm told it's not too bad once you get started, just a little tedious. I just don't cope well with that
08:29:13 <tennin> usually for projects like that I start thinking about how to automate it, get caught up in that and never find my way back to the original project
08:31:34 <Philippa> xerox: is there anything interesting mentioned about monoids, or just the basic definition and uninteresting examples?
08:32:44 <xerox> Philippa: still watching it, he did a nice explanation so far (which you could call basic definition) and some examples (I don't know what interests you).
08:33:47 <xerox> "I guess the main paper was from Moggi, m, o, g, g, i... and then from Wadler..."
08:34:26 <xerox> Ah, he talks about Haskell and SPJ too, yarr.
08:34:31 <xerox> Well, mention.
08:34:41 <edwardk> j #haskell-overflow
08:34:44 <edwardk> woops
08:36:15 <Philippa> xerox: mostly interesting examples are ones with additional properties, or which apply to a large class of things
08:36:41 <Philippa> oh, or ones you really really wouldn't expect which give you a pile of new and interesting properties about the thing in question
08:36:58 <Philippa> the obvious monad over strings is boring, for example
08:37:11 <xerox> I think he slippes on a number of things, but I might be wrong...
08:37:22 <Philippa> er, monoid
08:37:26 <Philippa> though yes, it's a monad too
08:37:28 <xerox> Maybe I'm just upset he calls Haskell a non-real-programming-language :P
08:37:32 <Philippa> heh
08:37:39 <Philippa> or rather, yes, there's a monad too
08:38:04 <xerox> "VB is in many ways the best of whole world of programming languages."
08:38:07 <xerox> Gulp.
08:38:07 <Philippa> however, while it's boring it's also a good "here's one to play with" example when you're first being shown them
08:38:27 <AStorm> Argh?!?
08:38:30 <Philippa> it's had the potential to be that for a long time, it's never got near it in the past though
08:38:31 <AStorm> "the best"?
08:38:38 <xerox> That's his work...
08:38:50 * Philippa nods
08:38:50 <AStorm> In creating unmaintainable code, only second to certain other language.
08:38:54 <xerox> Steal Haskell things and implement them in VB!
08:39:13 <Philippa> AStorm: Not true. I mean, as basics go VB's not half as painful as many others
08:39:16 <AStorm> Then it won't be Basic :>
08:39:34 <AStorm> Visual Bastard, rather ;-)
08:39:42 <Philippa> *shrug*
08:39:46 <Philippa> hell, I used VB1
08:39:48 <norpan> Beginners All-Purpose ...
08:39:51 <Philippa> it was a Good Thing at the time
08:40:05 <AStorm> Hell, I did too, even 2 major versions.
08:40:07 <Philippa> norpan: apparently that's a backronym
08:40:10 <AStorm> But not at this time...
08:40:19 <Philippa> oh, I've used VB3 and VB6 as well
08:40:21 <norpan> Philippa: no, actually it's not a backronym
08:40:30 <norpan> Philippa: at least it was coined with the name
08:40:58 <norpan> but obviously it was chosen for the word basic
08:41:18 <Philippa> the .net VBs have a chance of being decent languages - the changes required pissed off a lot of VB6 coders, but hey
08:41:27 <AStorm> I wouldn't recommend it to any beginner, though.
08:41:39 <AStorm> .net VB != Basic :>
08:41:56 <AStorm> It should be called Basic# :P
08:42:12 <AStorm> Basic on hash
08:42:39 <Philippa> you mean chilled out and thus less likely to take a chunk out of your foot?
08:43:47 <dottedmag> AStorm: in russian 'sharp' pronounced like 'posharpannyi' - 'scuffed'. So, C# is scuffed C :)
08:43:53 <AStorm> No, I mean like hash overdose - dead :>
08:44:23 <AStorm> Fun.
08:44:24 <Philippa> you have to go through quite a lot for that...
08:44:31 <Philippa> anyway, I've got stuff to be doing
08:44:52 <AStorm> In Polish it's "C krzyżyk", where krzyżyk is a small cross...
08:45:22 <AStorm> (although most people I know call it as in English)
08:47:10 <audreyt> Igloo: I ocassionally (1 out of 2 times) see
08:47:11 <audreyt> pugs: internal error: task 0x1b00330: main thread 1 has been GC'd (GHC version 6.5 for i386_apple_darwin) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
08:47:13 <lambdabot> Title: 1.2. Reporting bugs in GHC
08:47:21 <audreyt> where should I begin looking?
08:48:10 <Igloo> audreyt: Do you want to join #ghc and ask there?
08:48:55 <audreyt> didn't know there's #ghc
08:49:08 <Igloo> It's brand-shiny-new  :-)
08:49:26 <AStorm> Uh, Darwin. :>
08:49:28 <Igloo> And has the advantage that JaffaCake can answer all the hard questions  :-)
08:49:30 <CosmicRay> Igloo:  looks like you found the alpha bug?
08:49:46 <CosmicRay> Igloo: ahh, that's right, he can avoid all us lowly hugs-using peons ;-)
08:49:46 <Igloo> CosmicRay: I haven't fixed it if that's what you mean
08:50:02 <CosmicRay> well, either one.  looks like you got debs built tho?
08:51:49 <glguy> :i ask
08:51:52 <glguy> @type ask
08:51:57 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
08:52:08 <glguy> @index gets
08:52:09 <lambdabot> Control.Monad.State, Control.Monad.RWS
08:53:11 <Igloo> CosmicRay: Yes, but not of 6.4.2
08:53:47 <CosmicRay> ah.
08:54:00 <CosmicRay> wasn't that 901m build time great? ;-)
08:54:20 <AStorm> Well, mine builds faster :P
09:00:34 <int-e> hmmm. from haskell-cafe: "A compiler may re-write any monadic computations, for efficiency or other reasons, [...]"  Is this actually true? If yes, where in the Haskell report is that freedom given to a compiler?
09:05:10 <Lemmih> re-write in what sense?
09:06:12 <dcoutts__> int-e: I don't think any compiler does that
09:06:12 <ibid> "Instances of Monad should satisfy the following laws:" in 6.3.6 is a weak permission
09:06:20 <dcoutts__> rely on the monad laws I mean
09:06:32 <int-e> ibid: hmm. 'should' is pretty weak.
09:06:39 <int-e> ibid: oh, you said that
09:06:48 <ibid> Lemmih: apply monad laws indiscriminantly to monadic computations to simplify them
09:06:51 <ibid> int-e: :)
09:28:33 <Patterner> "Could not find module `Distribution.GetOpt': it is hidden (in package Cabal-1.1.4)"  how do i unhide it?
09:28:46 <xerox> ghc-pkg unhide Cabal
09:28:59 <xerox> expose sorry
09:29:09 <xerox> ghc-pkg help :)
09:29:10 <ndm> Patterner: can't you use just the standard GetOpt
09:29:13 <ndm> @where GetOpt
09:29:13 <lambdabot> I know nothing about getopt.
09:29:17 <ndm> @hoogle GetOpt
09:29:18 <lambdabot> Distribution.GetOpt :: module
09:29:18 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
09:29:18 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
09:29:43 <ndm> hmm, am sure there is another one...
09:30:04 <ndm> Patterner: System.Console.GetOpt
09:31:05 <Patterner> it's from pandoc
09:31:26 <Patterner> "ghc-pkg expose Cabal" does not work
09:31:35 <AStorm> Blah, Gentoo poses to be bleeding edge, and they don't even have GHC 6.6 in Portage :P
09:31:53 <AStorm> Just 6.4.2
09:32:04 <Patterner> write an ebuild
09:32:09 <Patterner> and send it to me :)
09:32:37 <AStorm> Hehe, is it compatible with 6.4, or do I have to slot it?
09:32:39 <Baughn> The existing ebuild wouldn't work?
09:32:52 <AStorm> Depends.
09:33:06 <AStorm> If it's incompatible, then we'd require a SLOT.
09:33:29 <Patterner> better slot it :)
09:33:36 <AStorm> I mean like source-incompatible, not binary-incompatible.
09:36:05 <AStorm> People - is it entirely compatible, or not?
09:36:14 <tibbe> AStorm: you know about the overlay?
09:36:22 <AStorm> If it is, no slot is warranted.
09:37:46 <AStorm> Which overlay? But there are many.
09:37:52 <AStorm> Sunrise?
09:38:48 <AStorm> I know about it.
09:39:31 <Limbic_Region> xerox - how did your cabal-put work?
09:39:57 <xerox> Limbic_Region: seems it works okay :)
09:40:26 <xerox> (Except I am doing system("cd foo; tar") which is crazy.)
09:40:40 <Limbic_Region> xerox - chdir
09:40:40 <tibbe> AStorm: the haskell overlay
09:40:55 <tibbe> AStorm: with latest ghc
09:41:02 <xerox> Limbic_Region: audreyt suggested a module, yeah, didn't try yet
09:41:03 <Limbic_Region> chdir $foo or die "Unable to change to $dir: $!";
09:41:09 <AStorm> Uhh... is it in the layman description file?
09:41:11 <Limbic_Region> no module necessary
09:41:22 <Limbic_Region> though he likely suggested Cwd;
09:41:25 <tibbe> AStorm, no you have to create yourself a local layman list
09:41:34 <tibbe> AStorm, although you could have mine ;)
09:41:36 <AStorm> Not a problem.
09:41:42 <Limbic_Region> and/or FileBasname and/or File::Spec
09:41:50 <AStorm> Ok, make it available somewhere.
09:41:51 <tibbe> AStorm: also, join #gentoo-haskell
09:42:01 <tibbe> AStorm: let me www it, sec
09:42:10 <Limbic_Region> now if only the Win32 build machine hadn't fallen over I could test the bin dist of the latest 6.6rc
09:42:17 <Limbic_Region> Igloo - ping?
09:42:26 <Igloo> Limbic_Region: pong
09:42:59 <Limbic_Region> do you know where I can get a copy of the latest Win32 bin dist in the interim?
09:43:15 <Limbic_Region> or alternatively, do you know if someone is fixing Happy so I can just build from source?
09:43:20 <Igloo> Limbic_Region: There isn't one, the machine building it broke
09:43:48 <Igloo> http://haskell.org/haddock/haddock-0.8-rc1-src.tar.gz should work, I think
09:44:20 <tibbe> AStorm: http://johantibell.com/my-list.xml
09:44:26 <Limbic_Region> Igloo - I assumed you or someone else was doing a local version
09:44:34 * Limbic_Region looks confusingly at that link
09:44:37 <xerox> Am I wrong or if I do "sudo make install", with the rule install depending on the build one, all the compilation gets done with root privileges?
09:44:39 <tibbe> AStorm: in /usr/portage/local/layman/
09:44:41 <AStorm> Thanks.
09:44:44 <Limbic_Region> haddock ne happy right?
09:44:45 <Igloo> Limbic_Region: Sorry, I misread it
09:45:08 <tibbe> AStorm: you're welcome, you have to run ebuild /path/to/ebuild digest on ebuilds before emerging them
09:45:13 <xerox> On the other hand, if I only write in the Makefile "install:\n\t./setup install", make doesn't run it.
09:45:26 <Limbic_Region> xerox - I think the answer highly depends on the Makefile
09:45:36 <AStorm> No problem.
09:45:41 <xerox> Limbic_Region: I am just wrapping up the cabal-way to compile and install things
09:45:57 <Igloo> Limbic_Region: Hang on, what's your problem with happy?
09:46:10 <Limbic_Region> xerox - if this is your local thing then just put a setuid bit on the script
09:46:12 <tibbe> AStorm, also I think that latest ghc ebuild erronously requires happy and alex
09:46:19 <Igloo> Limbic_Region: 1.15 works fine for me on Windows
09:46:25 <tibbe> AStorm, so you have to emerge them too
09:46:25 <xerox> Limbic_Region: it'll be the one people should use
09:46:32 <Limbic_Region> Igloo - the latest version of happy doesn't build with a recent ghc - "bounds" issue
09:46:40 <Limbic_Region> Igloo - latest ghc requires latest happy
09:46:49 <Limbic_Region> and 1.15 doesn't cut the mustard
09:46:52 <AStorm> tibbe: I can change the depends, thank you.
09:46:52 <AStorm> :-)
09:47:00 <Igloo> Limbic_Region: 1.15 works for me
09:47:07 <AStorm> Or does it really require them?
09:47:14 <xerox> @paste
09:47:14 <lambdabot> http://paste.lisp.org/new/haskell
09:47:29 <Limbic_Region> Igloo - I lied to Configure to get it to use 1.15 myself but it ultimately failed to build
09:47:34 <AStorm> and they are not in $DEPEND?
09:47:36 <Limbic_Region> perhaps that was because of Alex though and not happy
09:47:48 <tibbe> AStorm: no they're not ./configure fails
09:47:50 <lisppaste2> xerox pasted "Makefile attempt" at http://paste.lisp.org/display/25575
09:48:13 <xerox> (That's it, Limbic_Region)
09:48:14 <tibbe> AStorm, they removed some logic from the ./configure by misstake so it required more than it has too
09:48:22 <AStorm> tibbe: so they should be added to $DEPEND.
09:48:27 <AStorm> I can do that myself.
09:48:50 <tibbe> AStorm: well yes and now, ghc really shouldn't need them but until the configure scripts are fixed yes you can add them
09:48:52 <Igloo> Limbic_Region: Show me the configure output with happy 1.15 and an unmodified GHC tree
09:49:03 <Limbic_Region> xerox - I am sorry but I don't have enough context to know what's wrong or why
09:49:37 <AStorm> First, let my ghc 6.4.2 build finish (not -bin)
09:49:42 <AStorm> :-)
09:49:42 <Limbic_Region> Igloo - you just need to look at configure in the ghc tree and you can see that happy requires > 1.15
09:49:50 <Limbic_Region> configure bombs otherwise
09:49:57 <Limbic_Region> unless this has changed in the last 6 days
09:50:19 * Limbic_Region pulls down a source tarball to get an exact line number
09:50:33 <xerox> Limbic_Region: I was wondering wether it is correct to write the install rule as I did now, or not. In particular I think that if one does 'sudo make install' with this rule, all the compilation is carried out with root privileges. On the other hand, if I only write "install:\n\t./setup install", in the desperate aim to have people do "make" and "sudo make install", make wouldn't do anything on the latter command.
09:51:46 <Limbic_Region> xerox - you can only do what seems sane and then document your version of sanity in a readme.txt or an INSTALL file
09:51:59 <Limbic_Region> there is no correct when it comes to user side messing with elevated privs
09:52:04 <xerox> :(
09:52:27 <Limbic_Region> IOW - you can't prevent them from blowing off their foot but you can tell them how not to
09:53:10 <Limbic_Region> Igloo - finished downloading - untarring now
09:53:14 <xerox> But... when one does 'make install' in some other sofware, does make really go through the compilation again?
09:53:32 <xerox> (Even skipping everything, and not re-linking.)
09:53:47 <Limbic_Region> you can skip make and make test (normally) and just run make install which will do the make
09:53:59 <Limbic_Region> if make is already performed, it normally just tests to verify everything is finished
09:54:10 <AStorm> tibbe: I can write patches, thank you :-)
09:54:32 <AStorm> Why does that check for those two packages anyway?
09:54:33 <Limbic_Region> if OTOH, something requires elevated privs then you should just bomb out early and notify the user
09:54:40 <xerox> Limbic_Region: but if you just run "make install" without rood privileges the install itself will fail.
09:55:08 <tibbe> AStorm, I think there was a bunch of logic there somewhere that someone removed by some overzealous cleaning
09:55:31 <tibbe> AStorm: that checked if .hs files had already been generated from the alex and happy files
09:55:53 <AStorm> Ah, certainly doable.
09:56:09 <Limbic_Region> Igloo - it has changed in the last few days (probably cause I whined about it)
09:56:12 <AStorm> I'll fix it probably. Then send the patch where it should be sent.
09:56:20 * xerox has an idea.
10:06:11 <Limbic_Region> Igloo - oh wait, the problem isn't that 1.15 works - it is that the only binary dist for Win32 is 1.13
10:06:38 <Limbic_Region> so it is a problem, I can't get 1.15 to build
10:06:42 <Limbic_Region> bounds issue
10:07:19 <Igloo> Limbic_Region: 1.15 should build with 6.4.x
10:08:00 <Limbic_Region> I know - but it doesn't
10:08:08 <Limbic_Region> or rather - I don't have 6.4.x lying around
10:08:10 <Limbic_Region> duh
10:08:22 <Limbic_Region> I get an old GHC to build a new happy
10:08:30 <Limbic_Region> thanks for hitting me with the obvious stick
11:11:42 * edwardk hears a pin drop.
11:11:46 <Limbic_Region> anyone have a guestimate as to how long the latest ghc from source (with extra libs) should take to compile?
11:11:54 <edwardk> overnight? =)
11:12:18 <edwardk> i never actually stayed awake through a ghc compile
11:12:55 <Limbic_Region> that bad huh
11:13:18 <Limbic_Region> is that a bootstrapping compile or with a pre-existing ghc?
11:13:39 <tibbe> Limbic_Region: took me an evening on gentoo with a pentium-m 1.6 and 768 mb ram
11:14:23 <Limbic_Region> ok, well I was hoping very much to have the latest source compiled and building on Win32 today but I am not staying late just for that
11:14:54 <Baughn> GHC? 45 minutes on a dual-core core 2. You might be surprised.
11:16:02 <Limbic_Region> Baughn - perhaps you should tell your compatriots that it doesn't take as long as they think anymore ;-)
11:16:26 <Baughn> Limbic_Region: Nah, I don't feel like doing it twice
11:19:05 <cjeris> "Haskell: It's so hard to compile, it must be genius!"
11:21:32 <Baughn> "Haskell: EXPTIME-complete compilation"
11:23:32 <Limbic_Region> ghc make question - bombs with "ghc.exe: unknown package: regex-compat" - any advice?
11:23:57 <Baughn> Do you have regex-compat installed?
11:24:10 <Baughn> Try ghc-pkg -l
11:24:50 <Limbic_Region> ahh, I have the bin distro from 08-19 which I assumed had all the necessary packages installed
11:24:52 * Limbic_Region shouldn't assume
11:25:14 <Limbic_Region> apparently not
11:25:56 <Limbic_Region> is it part of the extra-libs src or do I need to go fetch it somewhere else
11:26:17 <Baughn> If you give me ten minutes I'll find out. Always wanted to install that...
11:26:40 * Limbic_Region is checking as well
11:26:49 <Limbic_Region> since I already have a copy lying around
11:28:14 <Baughn> ..doesn't /seem/ to be...
11:28:16 <Limbic_Region> best I can tell - the answer is no and I have to fetch it from elsewhere - links appreciated?
11:28:24 <tibbe> could someone give some examples of where GADTs can be useful?
11:29:17 <Limbic_Region> Baughn - looking at http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg10435.html now
11:29:20 <lambdabot> Title: Re: Packages in GHC 6.6, http://tinyurl.com/h66zc
11:30:17 <Limbic_Region> Additionally, I theoretically could build with 6.4.2 which has them
11:30:24 <Limbic_Region> that's the path of least resistance I think
11:32:01 * Limbic_Region would think though that ./configure would note the missing dependencies and abort early
11:32:41 <Baughn> Right. That's part of /why/ they want to debundle it.
11:39:42 <Limbic_Region> is there a standard repo for packages then?
11:40:31 <Baughn> hackage.haskell.org
11:40:47 <Baughn> (It's a bit small yet, but it's officially Standard)
11:43:38 <Limbic_Region> thanks, I might eventually be able to rewire my brain to grok Haskell
11:43:46 <Limbic_Region> and be doing more than just using it to compile pugs
11:46:41 <dylan> forkIO threads are light-weight, yes?
11:46:58 <dcoutts__> yes
11:47:03 <dylan> e.g. several (hundred) thousand of them isn't a problem?
11:47:07 <dcoutts__> indeed
11:47:10 <dwm> Limbic from Perl Monks?
11:47:12 <dylan> Ah, good.
11:47:30 * dylan was wondering that too (what dwm said)
11:47:50 <dcoutts__> dylan: though you shouldn't necessarily expect to get much done if all 100,000 are triny to do work at once :-)
11:47:53 <AStorm> Hey again.
11:48:02 <Limbic_Region> yes, dwm
11:48:06 <AStorm> Any good howtos or tutorials on using Haskell with CGI?
11:48:09 <dcoutts__> each one will get a time slice every couple hours ;-)
11:48:13 <dylan> dcoutts__: well, I'm thinking of using 2 threads per TCP/IP connection.
11:48:21 <dcoutts__> dylan: sounds reasonable
11:48:26 <Limbic_Region> dwm - and you are?
11:48:30 <dylan> a reader and a writer.
11:48:49 <AStorm> Maybe nice layout engine?
11:49:10 <Limbic_Region> dylan - you are also a PerlMonk>
11:49:16 <dwm> Limbic_Region: Hello. I'm dmorelli there. You probably don't know me, but I recognize you from many posts and whatnot.
11:49:21 <dylan> Limbic_Region: Not a prolific one, but I read it often
11:49:28 <dylan> I'm just 'Dylan' on there.
11:49:57 <dfranke> actually it would be /several/ hours between time slices.
11:50:11 <dylan> Hum.
11:50:18 <dfranke> > .020 * 100000 / 3600
11:50:18 <lambdabot>  Parse error
11:50:19 <dylan> So not like erlang processes, then?
11:50:19 <Limbic_Region> I recognize you both - but only from your homenodes
11:50:24 <dfranke> > 0.020 * 100000 / 3600
11:50:25 <lambdabot>  0.5555555555555556
11:50:36 <dfranke> err, nevermind.
11:50:40 <dcoutts__> dylan: erlang processes would have the same problem
11:50:47 <dfranke> slipped a decimal place in my head.
11:50:58 <dcoutts__> dylan: if all of them have work to do then each one doesn't get a chance to run very often
11:51:00 <dylan> err, but I have something with 5,000 processes and it seems to work fine.
11:51:00 <dwm> Limbic_Region: Huh, I didn't think anybody read it.
11:51:15 <dcoutts__> dylan: if most of them are blocked most of the time then you're fine of course
11:51:15 <Limbic_Region> Thanks Baughn btw
11:51:20 <dylan> Ah, yes, if they're busy
11:51:24 <dcoutts__> right
11:51:35 <dylan> and/or if you have a lot of CPUs/cores
11:51:39 <dcoutts__> indeed
11:51:47 <Limbic_Region> dwm - I read the homenode of anyone who shows up in Other Users - which happens even if you are only browsing
11:52:06 <dwm> BTW, I should be careful what I wish for. I am working in Perl now and the project is a ripping disaster. Super hideous stuff to rebuild as OO.
11:52:08 <dcoutts__> lightweight threads are great for when you expect most of them to be blocked much of the time
11:52:10 <dylan> erlang and haskell are the only options I'm considering, as I want the ability to scale. Even though I don't really need scaling, it's just a Nifty Thing. :)
11:52:19 <dcoutts__> OS threads are good for the opposite
11:52:50 <dylan> Does haskell  automagically switch light threads to different OS threads under load?
11:53:03 <Limbic_Region> dwm - well, I can't speel Haskell but I do know a fare amount of Perl - ping me if you need help
11:53:26 <dcoutts__> dylan: with GHC 6.6 yes it can schedule Haskell threads on multiple OS threads in parallel.
11:53:39 <dylan> dcoutts__: Awesome monkeys
11:53:40 <dcoutts__> dylan: ie it can take advantage of your mulit-core cpu
11:53:47 <dylan> so erlang and haskell are neck-a-neck with that.
11:53:56 <dcoutts__> yep
11:54:01 <dylan> (this is really hypothetical anyway, as I only have single core machines)
11:54:01 <dwm> Limbic_Region: You don't want to see this code I have to rewrite. It's something like 5000 lines in maybe 6 functions total. A 12+ level nested if statement nightmare. All global vars, no strict or warnings.
11:54:21 <dcoutts__> dylan: a.out +RTS -N 2 -RTS
11:54:23 <Limbic_Region> ok - next 6.6rc make error.  From main.hs - Failed to load interface for `Distribution.InstalledPackageInfo': Bad interface file: ../../compat/Distribution/InstalledPackageInfo.hi
11:54:39 <Limbic_Region> dwm - you're right, I don't
11:54:40 <_velco> hmm, with haskell you can writre a program which scales across networked machines ?
11:54:41 <dcoutts__> Limbic_Region: the usually means you want to make clean
11:54:51 * Limbic_Region thought he did that
11:54:56 <Limbic_Region> thanks, will try it
11:55:01 <dwm> Limbic_Region: But thank you. :)
11:56:19 <Baughn> dylan: I didn't see anyone mentioning this - Erlang, last I checked, didn't use more than one OS thread. So multiple cores helps not at all.
11:56:30 <deadbeef> hey
11:56:32 <deadbeef> sup
11:56:36 * deadbeef did an exam today
11:57:19 <dcoutts__> Baughn: really? I thought erlang was used on huge mult-cpu network switches?
11:57:22 <AStorm> Ok guys, to reiterate: any good howtos on using Haskell programs as CGI?
11:57:39 <deadbeef> AStorm: it should be immediate
11:57:45 <Baughn> dcoutts__: It is, but then by using multiple Erlang processes. Communication between them is fairly transparent, but still..
11:57:57 <deadbeef> you put the stuff in the standard output
11:57:59 <deadbeef> that'it
11:58:01 <deadbeef> *s
11:58:03 <AStorm> deadbeef: any nice templating engine? :>
11:58:07 <Baughn> dcoutts__: Of course, the advantage of that approach is that it doesn't really matter if it's the same machine or not
11:58:10 <deadbeef> make your own
11:58:13 <AStorm> deadbeef: not to mention parsing forms and such.
11:58:19 <AStorm> I'd just love a good library :>
11:58:30 <dcoutts__> Baughn: right, so 'distributed' rather than 'concurrent'
11:58:31 <AStorm> Is there none?
11:58:33 <dwm> AStorm: I don't know what it's called but I know I've read about a web development API in Haskell. And seen people talking about it here.
11:59:13 <AStorm> Hmm, I don't know if I have that in logs, being here just 2,5 days with holes. But of course there are internet ones :-)
11:59:31 <_velco> Baughn: well, what you run on two machines, you can run on one ;)
11:59:49 <dcoutts__> AStorm: there are logs elsewhere btw
11:59:54 <Baughn> dcoutts__: Quite. The obvious disadvantage there is that you can't (easily) do tricks like remapping memory to send /really huge/ messages between Erlang LWPs. Though I don't know if it does that at all.
11:59:57 <dwm> Some of the web stuff is listed here, I see:
12:00:07 <Baughn> _velco: Indeed
12:00:08 <dwm> http://www.haskell.org/haskellwiki/Libraries_and_tools/Web_programming
12:00:11 <lambdabot> Title: Libraries and tools/Web programming - HaskellWiki, http://tinyurl.com/m537m
12:00:20 <dcoutts__> Baughn: right
12:00:37 <AStorm> Hmm, how could I've missed that?
12:00:38 <dwm> Huh, I didn't realize until just now that lambdabot does the tinyurl. Neato
12:01:12 <Baughn> Hmm. Are they preprogrammed or..
12:01:14 <Baughn> http://bleb.org/random/
12:01:16 <lambdabot> Title: Random Google page
12:01:28 <Baughn> ...cached, I suppose
12:01:32 <_velco> Baughn: http://www.erlang.org/doc/doc-5.5.1/doc/highlights.html
12:01:44 <lambdabot> Title: Highlights, http://tinyurl.com/pj5cu
12:01:50 <_velco> apparently they got there
12:02:06 <Baughn> El-neato
12:02:27 <lisppaste2> emertens pasted "Why does this use tons of memory?" at http://paste.lisp.org/display/25585
12:02:38 <glguy> that was me, actually
12:02:57 <glguy> any ideas why this might be using up to 60K of memory?
12:03:02 <dwm> Aha, and "hope", I knew I had seen bringert talking about this stuff too.. http://hope.bringert.net/about
12:04:09 <dwm> Web app framework, didn't see it on that haskellwiki page.
12:04:45 <AStorm> Thanks for everything :-)
12:05:35 <dwm> I bet the bot knew some of these urls if I could remember how to ask it for things. :/
12:08:13 <Limbic_Region> anyone building regularly on OS X ?
12:08:28 <Limbic_Region> and if so, would it be possible to get a bin dist tarball?
12:09:04 * Baughn would build, if it ran on osx/intel
12:09:20 <Limbic_Region> PPC ?
12:09:35 <Baughn> Don't have one of those
12:09:42 <Cale> glguy: Can you give me an example of where that uses too much memory?
12:09:45 <gour> CosmicRay: hi, i plan to play a bit with hdbc (sqlite). is there some ability for user-defined functions, aggregates... ?
12:09:56 <vincenz> ibid: still the same issues with the RSS feed of the planet
12:09:58 <Limbic_Region> thanks anyway Baughn - you have been most helpful
12:10:01 <Limbic_Region> I am currently building with 6.4.2 btw
12:10:50 <Cale> glguy: it doesn't seem like it's leaking anything, it might do a bunch of allocation for those strings constructed by show
12:11:24 <Cale> glguy: strings are something around 12 bytes/char
12:11:55 <vincenz> \o/
12:12:07 <vincenz> Cale: or even worse...24byte on a 64 bit proc
12:12:20 * vincenz grins
12:12:40 <Cale> uh, really?
12:12:45 <dcoutts__> yes
12:12:48 <dcoutts__> really.
12:12:58 <Cale> The pointer overhead would be larger, I suppose.
12:13:02 <dcoutts__> exactly
12:13:08 <Cale> but doubled?
12:13:09 <dcoutts__> and it's mostly pointers
12:13:19 <dcoutts__> the Int's are also 64bit
12:13:34 <Cale> the Ints that are used for Chars?
12:13:35 <vincenz> Cale: of course
12:13:36 <dcoutts__> so what is a Char box...
12:13:54 <vincenz> you kinda need that for a GC system
12:14:02 <vincenz> dcoutts__: btw ... are Int's unboxed?
12:14:06 <dylan> Baughn: erlang uses multiple cores now
12:14:20 <Cale> vincenz: Int is boxed, Int# isn't.
12:14:24 <norpan> unboxed Ints are unboxed :)
12:14:30 <vincenz> dcoutts__: and how can they get the full bit range, how does that work with the GC?
12:14:37 <Baughn> dylan: Yep, I heard that earlier. Neat, isn't it?
12:14:39 <vincenz> don't they need a bit denoting it being an int and not a pointer?
12:14:46 <Baughn> dylan: Soon, my master plan of eradicating C will be complete
12:14:52 <dylan> Baughn: ah, sorry, was scrolled up
12:15:10 <dcoutts__> Cale: struct Cons { Header *header, Box *elem, Box *next }
12:15:17 <dcoutts__> Cale: it's all pointers
12:15:29 <norpan> boxed values are always pointers
12:15:29 <dcoutts__> vincenz: yes it is boxed
12:15:31 <Cale> dcoutts: yeah, I know that conses are all pointers :)
12:15:45 <dcoutts__> vincenz: data Int =I# Int#
12:15:58 <dcoutts__> Cale: and the Char cells are preallocated
12:16:07 <dcoutts__> Cale: that's why it's only 12 rather than 20
12:16:10 <vincenz> dcoutts__: right but Int# then? How do they make it work with the GC?
12:16:11 <dcoutts__> bytes per char
12:16:17 <Cale> ah, okay
12:16:30 <dcoutts__> Cale: so wether or not the Char# itself is 32 or 64 bytes doesn't really matter
12:16:44 <dcoutts__> but as it happens, I think it's 64 too
12:16:50 <sjanssen_> why would Char# be 64 bits?
12:16:53 <Cale> huh.
12:16:59 <sjanssen_> that's wasteful
12:17:02 <chessguy> is it possible to do logic programming in Haskell?
12:17:16 <Cale> chessguy: yeah, using one of various monads
12:17:17 <lament> no, haskell is completely illogical :(
12:17:19 <chessguy> or, a better question, is it too much of a stretch to do so?
12:17:31 <dcoutts__> vincenz: it's not marked as a pointer, that's how.
12:17:34 <Baughn> chessguy: Are you talking about constraint-based programming, like what prolog does?
12:17:48 <Cale> chessguy: The list monad gives you some logic-programming-like interactions right away.
12:17:56 <dcoutts__> vincenz: each heap object has a GC descriptor saying which fields are pointers.
12:17:57 <chessguy> constraint-based programming is different from logic programming, which is actually what prolog does
12:18:06 <chessguy> (to my knowledge)
12:18:16 <Cale> http://okmij.org/ftp/Computation/monads.html#LogicT
12:18:18 <lambdabot> Title: Monads, http://tinyurl.com/kdhqf
12:18:32 <dcoutts__> vincenz: so the descriptor for I#, the Int constructor, would mark it's payload as not being a pointer.
12:19:23 <chessguy> hmm, is there a programming paradigm that haskell doesn't support? :)
12:20:26 <dcoutts__> there are some it doesn't support naturally
12:20:36 <dcoutts__> like "everything is global and mutable"
12:20:48 <Limbic_Region> chessguy - let me put it to you this way, you can compile pugs (Perl 6 implementation) using Haskell which can then be used to do logic programming
12:20:51 <dylan> I wonder if a stack-based language with prefix notation is possible...
12:20:54 <dcoutts__> and variables have identity / reference semantics
12:21:09 <dcoutts__> that's unnatuaral and a pita in Haskell
12:21:15 * Limbic_Region ducks
12:21:15 <chessguy> Limbic_Region, why would i do that? it sounds like Cale's method is much more direct
12:21:16 <Limbic_Region> so in a nutshell, there isn't anything Haskell can't do since it can be used to create Perl 6
12:21:21 <dcoutts__> but that's ok, since we don't want to code that way anyway
12:21:35 <dcoutts__> well, it is turing complete...
12:21:35 <Limbic_Region> chessguy - you missed the humor -----> ;-)
12:21:48 <chessguy> dcoutts, i hoped you were going to add that
12:21:53 <dcoutts__> heh
12:21:58 <Baughn> dylan: Hmm. Push the functions first, then execute them when you push the arguments...
12:22:02 <dcoutts__> it's always the final get out :-)
12:22:04 <Baughn> dylan: Currying would be easy. ;)
12:22:27 <chessguy> Limbic_Region, perl is nice for some things, for sure
12:23:38 <Limbic_Region> chessguy - I am probably the only person in the channel that hasn't written a single line of Haskell - I am a Perl hacker (fish out of water)
12:24:09 <chessguy> Limbic_Region, i can guarantee you you're not the only one :)
12:24:24 <norpan> Limbic_Region: write 'main = putStrLn "Hello World!"'
12:24:25 <chessguy> i'm a clueless OO programmer
12:24:50 <chessguy> well, a clueless OO wannabe
12:25:02 <Limbic_Region> norpan - I might have exaggerated (sp?) a little, but thanks
12:27:29 <chessguy> i can't believe i haven't learned a lick about any other paradigm, and i'm in my last semester
12:28:22 <dwm> dcoutts__: Just caught up to this.. "everything is global and mutable" haha
12:29:09 <chessguy> hmm. does dwm always get jokes 10 minutes after they're made? :)
12:29:37 <vincenz> dcoutts__: yeah but .. if you don't have an extra pointer somewhere, whre is this inifo stored?  I mean you have 32 bit unboxed integers on a 32bit comp...these must be stored somewhere, so when the GC starts goin, how does it know what is an int and what is a pointer?
12:30:07 <dwm> 15:39 < dwm> I don't get it.
12:30:18 <dcoutts__> vincenz: because of the heap object info, which tells it.
12:30:33 <chessguy> object! gasp!
12:30:35 <vincenz> dcoutts__: ah I see... for each type there's a "Class" structure stored for the ehap to use?
12:30:46 <dcoutts__> vincenz: something like that yes
12:30:51 <vincenz> dcoutts__: so what about
12:30:54 <vincenz> [Int#]
12:30:59 <vincenz> vs
12:30:59 <dcoutts__> no such thing
12:31:02 <vincenz> [[Int]]
12:31:13 <vincenz> I mean unless you store an object for EVERY type
12:31:16 <vincenz> instead of ever tycon...
12:31:33 <dcoutts__> as I said, no such thing, so it's not a problem
12:32:10 * vincenz nods
12:32:13 <vincenz> I see
12:32:13 <dcoutts__> vincenz: each heap object contains a pointer to the info struct that describes it. it's on a per-tycon basis, not per type
12:32:19 <vincenz> fragile system tho
12:32:21 <dcoutts__> similarly for thunks etc etc
12:32:25 <dcoutts__> not fragile at all
12:32:27 <vincenz> I mean if someone braeks those assumptions
12:32:33 <vincenz> I mean you gotta be sure you know everything
12:32:42 <dcoutts__> you cannot have [Int#] for precisely that reason
12:32:45 <vincenz> yep
12:32:50 <dcoutts__> and that you wouldn't know how big it is
12:32:54 <vincenz> but basically you're combining type-checking with details of the GC
12:33:04 <vincenz> I mean it's the typechecker that would reject [Int#]
12:33:07 <vincenz> (on what basis ?)
12:33:07 <dcoutts__> yes
12:33:11 <dcoutts__> try it
12:33:17 <vincenz> > undefined :: [Int#]
12:33:17 <lambdabot>  Parse error
12:33:22 <vincenz> > undefined :: [ Int# ]
12:33:22 <lambdabot>  Parse error
12:33:24 <dcoutts__> heh
12:33:24 <vincenz> > undefined :: Int#
12:33:25 <lambdabot>  Parse error
12:33:27 <vincenz> k
12:33:33 <dcoutts__> try it in ghci -fglasgow-exts
12:33:36 <dcoutts__> it's a kind error
12:34:27 * Limbic_Region thinks he would be fascinated by the way the different haskell implementations do DOD and GC
12:34:51 <dcoutts__> vincenz: Int# has kind #
12:35:10 <dcoutts__> vincenz: where as [] has kind * -> *
12:35:25 <dcoutts__> vincenz: so [] Int# doesn't work, incompatible kinds
12:35:41 <dcoutts__> * is the ordinary kind
12:35:48 <dcoutts__> # is the kind of unboxed things
12:36:05 <dcoutts__> the really cunning bit is:
12:36:08 <dcoutts__> (->) :: ?? -> ? -> *
12:36:27 <dcoutts__> there is a sub-kind relationship between #, *, ? and ??
12:36:32 <dcoutts__> there's a paper on it
12:37:01 <dcoutts__> something by spj with a title like making unboxed types first class citizens
12:37:15 <dcoutts__> by giving a proper typing/kinding system for them
12:37:32 <dcoutts__> it formalises the practical restrictions very nicely
12:40:19 <glguy> It's hard to write an elegant solution in Haskell that meets the time-requirements of SPOJ
12:40:30 <ndm> glguy: i noticed that!
12:40:35 <sjanssen_> glguy: depends on the problem
12:40:42 <sjanssen_> glguy: which problem are you tackling?
12:40:48 <Cale> glguy: That's why I stopped trying :)
12:40:52 <ndm> glguy: if you use a faster read/show, as provided by int-e, you can get better - for example on the MUL problem
12:41:07 <glguy> the palendroms (sp) problem ran out of time
12:41:18 <glguy> and now the ambiguous permutations one did
12:42:05 <lisppaste2> glguy pasted "permutations code... can i write this any faster?" at http://paste.lisp.org/display/25592
12:42:17 <glguy> OH
12:42:17 <sjanssen_> running out of time with solutions written in C++ aren't exactly uncommon either
12:42:18 <glguy> hell
12:42:24 <glguy> I need to use arrays for the permutaions
12:42:28 <mauke> PALIN should be solved in perl :-)
12:42:31 <glguy> with all the random access I'm doing
12:42:41 <sjanssen_> sometimes the asymptotically fastest solution isn't obvious
12:43:20 <mauke> it's like 20 lines of code
12:43:33 <glguy> my haskell solution was about that long too
12:43:35 <bringert> AStorm: I have started working on a Haskell web programming tutorial
12:43:41 <glguy> but I think that using show is killing me
12:43:54 <mauke> well, the perl version is pretty fast
12:44:00 <glguy> @type (!)
12:44:01 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
12:44:04 <glguy> @index (!)
12:44:05 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
12:44:08 <AStorm> bringert: great :-)
12:44:15 <bringert> AStorm: darcs repo for the tutorial is here http://www.cs.chalmers.se/~bringert/darcs/hs-web-tut/
12:44:16 <AStorm> I will make use of that too.
12:44:18 <lambdabot> Title: Index of /~bringert/darcs/hs-web-tut, http://tinyurl.com/zveza
12:44:26 <sjanssen_> glguy: bet if you use a UArray Int Word8, the solution will be fast enough
12:44:36 <bringert> it's far from done, and any comments are welcome
12:44:54 <AStorm> Will it introduce the external Network.FastCGI?
12:45:05 <bringert> make will build a nice html file for you.
12:45:14 <bringert> AStorm: yes, it mentions FastCGI
12:45:26 <bringert> the API is the same for CGI and FastCGI with my libs
12:45:31 <AStorm> Ah, Network.NewCGI
12:45:31 <AStorm> For which Network.FastCGI is almost a drop-in replacement.
12:45:37 <bringert> right
12:45:50 <bringert> it will come as Network.CGI in GHCH 6.6
12:46:37 <bringert> eh, GHC
12:46:47 <glguy> sjanssen_: I don't know how tu use UArrays yet, so I'm submitting with a normal array. if that fails, I'll be asking for what functions to investigate
12:47:09 <glguy> time limit exceeded with normal array
12:48:53 <glguy> @index Word8
12:48:54 <lambdabot> Data.Word, Foreign
12:49:23 <vincenz> dcoutts__: ah I see
12:49:41 <vincenz> dcoutts__: it's rather fortunate it works out so nicely
12:50:10 <vincenz> and why the ? as well as the ??
12:50:19 * vincenz would think, # and * would do
12:51:07 <xerox> ?fptools Prim.Kind
12:51:08 <lambdabot> Prim.Kind not available
12:51:13 <xerox> ?fptools GHC.Kind
12:51:14 <lambdabot> GHC.Kind not available
12:51:20 <xerox> Wah. It was something like that.
12:51:36 <sjanssen_> vincenz: you have tycons that can accept either kind, like (->)
12:51:40 <sjanssen_> @kind (->)
12:51:42 <lambdabot> ?? -> ? -> *
12:51:42 <chessguy> this looks to be a very nice article on monads. i think it's even using haskell
12:51:43 <chessguy> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
12:52:05 <glguy> sjanssen_: Word8 doesn't seem to be big enough. How does it compare to an Int?
12:52:16 <sjanssen_> glguy: I was wrong, you need Int
12:52:22 <dcoutts__> vincenz: well, it was designed :-)
12:52:27 <glguy> yeah... UArray Int Int   wasn't fast enough
12:52:35 <dcoutts__> vincenz: there's more to it, see the paper.
12:52:59 <dcoutts__> it's a good paper
12:53:03 <vincenz> :)
12:53:04 <vincenz> thx
12:53:13 <glguy> what's faster than UArray? STUArray?
12:53:22 <glguy> ... I don't need it to be mutable
12:53:22 <dcoutts__> but then pretty much all of spj's papers are good and readable
12:53:27 <vincenz> @google peyton unboxed types first class citizens
12:53:30 <lambdabot> http://citeseer.ist.psu.edu/context/23515/0
12:53:31 <sjanssen_> glguy: want to paste the code again?
12:53:53 <sjanssen_> glguy: you want a UArray
12:53:55 <lisppaste2> glguy pasted "not fast enough" at http://paste.lisp.org/display/25594
12:54:54 <glguy> (20 million, no, that's not enough)
12:55:43 <glguy> and if I pasted Int#... that's wrong, I submitted just plain Int
12:56:22 <glguy> @type ($!)
12:56:23 <lambdabot> forall b a. (a -> b) -> a -> b
12:56:26 <sjanssen_> glguy: try submitting with this line added to the top: {-# OPTIONS -O2 #-}
12:56:29 <mauke> glguy: liftM read getLine == readLn
12:56:36 <glguy> k
12:56:54 <glguy> but I've got words in there
12:57:00 <glguy> oh, that
12:57:57 <mauke> spoj uses ghc -O by default
12:58:30 <glguy> exceeded
12:58:45 <sjanssen_> and as a last resort, you can (!) by unsafeAt from Data.Array.Base
12:58:53 <sjanssen_> s/can/can replace
13:00:04 <lisppaste2> glguy annotated #25594 with "current revision" at http://paste.lisp.org/display/25594#1
13:00:36 <glguy> too slow!
13:00:52 <glguy> could this be the bottleneck: liftM (listArray (0,n) . map read . words) getLine
13:01:25 <sjanssen_> that should be fairly fast
13:01:49 <glguy> could it be that I'm using too much memory due to laziness?
13:01:53 <dcoutts__> SyntaxNinja: can I ask you to review a couple Cabal patches that I've got sitting about? I'd like to get them into the next RC, but they're not strictly essential so I thought I should get them reviewed.
13:02:07 <sjanssen_> glguy: actually, I bet getLine is the bottle neck
13:02:19 <glguy> should I getContents?
13:02:31 <sjanssen_> because the entire string has to be read, and there's up to 10000 items in a line . . .
13:02:32 <mauke> sjanssen_: why, isn't it buffered?
13:02:55 <dcoutts__> SyntaxNinja: http://www.haskell.org/pipermail/cabal-devel/2006-August/000153.html
13:02:57 <lambdabot> Title: darcs patch: Be cleverer about guessing hc-pkg name a... (and 1 more), http://tinyurl.com/focnh
13:03:07 <glguy> @hoogle IO String
13:03:08 <lambdabot> Prelude.getContents :: IO String
13:03:08 <lambdabot> Prelude.getLine :: IO String
13:03:08 <lambdabot> System.getProgName :: IO String
13:03:30 <SyntaxNinja> dcoutts__: sorry, really very little chance of getting my time between now and HW :(
13:03:56 <SyntaxNinja> well, if you find me a new hire maybe ;)
13:03:59 <dcoutts__> SyntaxNinja: ok, np I'll try pouncing on another unsuspecting reviewer
13:04:04 <dcoutts__> SyntaxNinja: hah, hah. Right.
13:04:05 <glguy> all will short circuit when it hits the first False, right?
13:04:11 <sjanssen_> mauke: no, getLine has to grab the whole string before returning
13:04:14 <sjanssen_> glguy: yeah
13:04:23 <dcoutts__> SyntaxNinja: how many are you hiring btw?
13:04:36 <SyntaxNinja> one or two, I think.
13:04:48 <dcoutts__> SyntaxNinja: if you're still hiring in 2 years time, call me. :-)
13:04:53 <glguy> could I use FPS for the getLine stuff?
13:05:02 <dcoutts__> glguy: could do.
13:05:05 <SyntaxNinja> dcoutts__: why not now? I forget your current status
13:05:11 <glguy> is that available in ghc 6.4.1?
13:05:11 <dcoutts__> SyntaxNinja: PhD
13:05:18 <dcoutts__> glguy: seperately, yes.
13:05:28 * SyntaxNinja nods
13:05:30 <emu> it works with 6.4.1?
13:05:45 <glguy> more importantly: on spoj?
13:05:46 <dcoutts__> emu: I've used it a bit with 6.4.1
13:05:55 <sjanssen_> glguy: you can't use it on SPOJ
13:05:57 <Igloo> dcoutts__: I think you ought to be using ghc --print-libdir to find ghc-pkg, BTW
13:06:02 <dcoutts__> glguy: note that you're not reading before putting it into the array, so you're allocing lots of thunks.
13:06:14 <emu> i'm actually trying to get spoj to install fps
13:06:15 <dcoutts__> Igloo: oh yes, better.
13:06:31 <emu> an admin expressed interest
13:06:34 <glguy> dcoutts__: any suggestions on how to correct that?
13:06:40 <dcoutts__> Igloo: oh, wait that doesn't work. :-(
13:06:41 <ndm> emu: wait til 6.6 is out, with better performance, and prebundled with GHC
13:06:48 <sjanssen_> emu: if you succeed, you will be my hero
13:06:53 <Igloo> dcoutts__: Why not?
13:06:56 <dcoutts__> Igloo: since the ghc-pkg in the libdir isn't the wrapper script
13:07:10 <dcoutts__> Igloo: the wrapper script passes some extra args.
13:07:13 <ndm> SyntaxNinja: give me a call in 1 to 2 years as well!
13:07:15 <Igloo> Ah, hmm
13:07:33 <Igloo> So you really need --print-bindir?
13:07:41 <dcoutts__> Igloo: and it'd be a bit off to pass those too, an unreasonable chummyness with ghc
13:07:53 <SyntaxNinja> ndm: dcoutts: you call me in two years ;)
13:07:55 <dcoutts__> Igloo: perhaps
13:08:04 <dcoutts__> SyntaxNinja: right'o :)
13:08:07 <Igloo> Oh, no, that's a subdirectory
13:08:17 <Igloo> The wrappers are there
13:08:24 <dcoutts__> are where?
13:08:25 <Igloo> `ghc --print-libdir`/bin/ghc-pkg
13:08:34 <glguy> liftM (listArray (0,n) . map (\x -> read $! x) . words) getLine
13:08:35 <glguy> ?
13:09:01 <dcoutts__> Igloo: oh yes, so they are. I never noticed them there.
13:09:02 <sjanssen_> glguy: that won't fix your problem (if it is what I think it is)
13:09:18 <glguy> dcoutts__: said something of not reading before it was added to the array
13:09:25 <glguy> I thought maybe that would force the read
13:09:35 <dcoutts__> glguy: good idea
13:09:56 <glguy> but does a UArray correct for tha anyway?
13:10:03 <dcoutts__> Igloo: hmm, are you sure that's not just a debian-specific thing?
13:10:23 <glguy> oh well
13:10:24 <dcoutts__> Igloo: I've got that bin subdir for my ubunto ghhc-6.4.1, but not on any of my other systems
13:10:25 <glguy> failed again
13:10:36 <glguy> looks like mathschallenge.net is better for haskell programmer
13:10:39 <sjanssen_> > sum $ map (floor . logBase 10) $ [1.. 100000]
13:10:41 <Igloo> Oh, maybe it is
13:10:41 <lambdabot>  388894
13:10:49 <dcoutts__> Igloo: is that part of your etc-alternatives system perhaps?
13:11:17 <sjanssen_> glguy: that's the number of characters that must be read entirely before the reading/array creation happens
13:11:30 <sjanssen_> and all that data is retained in memory
13:11:33 <Igloo> So, as long as everyone uses Debian it'll all work nicely
13:11:38 <dcoutts__> hah hah
13:11:42 <sjanssen_> in a space wasting boxed linked list representation
13:11:47 <glguy> sjanssen_: so what you are trying to say is that there is nothing I can do about it?
13:11:52 <dcoutts__> Igloo: it's not a bad idea generally mind you.
13:11:54 <emu> does anyone know what's up with the "haskell-unsafe" stable deb APT source?
13:12:12 <dcoutts__> emu: is it in alioth which got temporarily shut down?
13:12:16 <sjanssen_> glguy: no, you just gotta use lazy IO.  Try interact or getContents
13:12:22 <glguy> kk
13:12:27 <emu> ugh, did it? the web page is up, but it's bare with no info
13:12:29 <glguy> getContents and lines?
13:12:57 <Igloo> What is bare?
13:13:00 <sjanssen_> that should work
13:13:07 <Igloo> http://haskell-unsafe.alioth.debian.org/ has stuff in
13:13:11 <lambdabot> Title: Index of /
13:13:16 <emu> er, was unpopulated
13:13:19 <Igloo> I'm not sure if there's anything useful in teh stable repo ATM, though
13:13:31 <emu> glguy: i was using: mapM_ (print . myFunc . read) . lines =<< getContents
13:13:48 <emu> where myFunc had an explicit signature telling read what to expect
13:13:54 <mauke> w00t, got AC with perl
13:15:30 <emu> Igloo: oh i just wanted backported debs is all
13:17:27 <dcoutts__> Igloo: so do you think that Cabal patch is ok to go in? I've tested it a bit.
13:17:44 <dcoutts__> works for the ordinary --with-compiler=ghc-6.5 sort of thing
13:17:47 <Deformative-II> Can anyone describe haskell to me?  In terms of eas to type,  length needed to get the job done,  and preformance.
13:17:50 <dcoutts__> and for absolute paths
13:18:45 <dcoutts__> Deformative-II: typically shorter and more reliable programs, typically performance better than Java/Python, not as fast a C.
13:18:56 <Deformative-II> Like compaired to lisp, C, Python, and Java.
13:19:04 <Deformative-II> Ah,  exactly what I wanted.
13:19:19 <dcoutts__> Deformative-II: similar programming style to Lisp
13:19:25 <Deformative-II> dcoutts__,  what about cross platfrom,  yes or no?
13:19:27 <dcoutts__> but nicer syntax
13:19:33 <dcoutts__> Deformative-II: all platforms
13:19:46 <Deformative-II> Is it a nice first language?
13:19:51 <dwm> From what I've read, closer in syntax to ML than Lisp. Is that accurate?
13:20:01 <ndm> dwm: yes, by miles
13:20:01 <araujo> es dwm
13:20:13 <dcoutts__> Deformative-II: I teach it to first year universty students, so for many of them it's their first language.
13:20:25 <dwm> I have not really seen ML myself but it's beenUU
13:20:28 <dwm> BAH
13:20:31 <Deformative-II> Well,  is it "different" than java?  BEcause I am in a java class right now,  and I wanna learn something other htan java.
13:20:42 <dwm> it's been described to me by the lovely Mrs. dwm
13:20:45 <dcoutts__> Deformative-II: yes, quite different to Java
13:20:48 <Deformative-II> And I don't want to get confused.
13:20:48 <dcoutts__> much nicer :-)
13:20:50 <ndm> Deformative-II: would be hard to be more different from java
13:21:07 <ndm> Deformative-II: its even _actually_ cross platform :)
13:21:29 <Deformative-II> I just don't want to get anything confused because I need to keep my gpa high.
13:21:34 <dcoutts__> Deformative-II: they're totally different styles, so you shouldn't get too confused between similar things like say with C++/Java
13:21:36 <AStorm> It's entirely different.
13:21:50 <AStorm> Different concepts.
13:21:50 <dcoutts__> or C# vs Java
13:22:00 <dcoutts__> which are 99% the same
13:22:03 <_velco> almost, but not entirely, unlike Java
13:22:08 <AStorm> You don't usually use objects, you use types.
13:22:18 <AStorm> dcoutts__: nope :>
13:22:27 <xerox> SyntaxNinja: hi, I've written the makefile
13:22:50 <AStorm> Other than that, there are no looping constructs other than recursion (of course you can emulate a for loop :P )
13:23:05 <Deformative-II> Alright.
13:23:12 <xerox> SyntaxNinja: just get http://hackage.haskell.org/~paolo/darcs/cabal-install
13:23:15 <lambdabot> Title: Index of /~paolo/darcs/cabal-install, http://tinyurl.com/mlbx5
13:23:16 <Deformative-II> So an app I make in linux,  will work in winblows,  right?
13:23:29 <AStorm> Most of the time.
13:23:48 <dcoutts__> Deformative-II: yes, mostly. So long as you code portably with things like paths etc
13:23:49 <AStorm> If it's compiled, after recompilation under Windows.
13:23:55 <ndm> Deformative-II: i only work on windows, i've yet to end up with an app  that doesn't work on linux
13:23:57 <AStorm> Oh, that too.
13:24:04 <ndm> Deformative-II: including GUI's etc.
13:24:18 <AStorm> e.g. use wxHaskell
13:24:25 <dcoutts__> or Gtk2Hs !
13:24:37 <Deformative-II> Well,  how portable is java?
13:24:48 <Limbic_Region> ndm - I could easily write one if you wanted to say you have encountered exactly one app that didn't work on linux
13:24:58 <AStorm> Very.
13:25:16 <Limbic_Region> of course it would be tied to the Win32 API and the registry and everything else that makes winders winders
13:25:17 <AStorm> Except the GUIs - the ones truly portable (e.g. SWING) suck badly.
13:25:40 <_velco> AStorm: eh?
13:25:46 <AStorm> And are very slow too.
13:25:57 <AStorm> _velco: I was talking about Java
13:26:19 <_velco> AStorm: yes. swing is rather good, way ahead swt and gtk is very simlar to swing
13:26:34 <Deformative-II> So basically java has no advantage over haskell?
13:26:42 <dcoutts__> well some
13:26:44 <glguy> a huge number of libraries?
13:26:51 <dcoutts__> more people know Java
13:27:05 <dcoutts__> so it's easier to hire Java monkeys, right SyntaxNinja :-)
13:27:07 <Deformative-II> Those are dumb luck advantages.
13:27:11 <dcoutts__> indeed
13:27:22 <ndm> you can use Java for an "enterprise e-beans thingy-ma-flip"
13:27:25 <Deformative-II> I mean the accual language,  not the people who use it and what is made for it.
13:27:41 <_velco> well ... it has side effects ;)
13:27:47 <ndm> oh, Haskell is much better than Java at the language level, thats easy to answer :)
13:27:55 <AStorm> You can program cellphones in Java :P
13:28:25 <ndm> AStorm: or Haskell (almost)
13:28:36 <Deformative-II> Cool.
13:28:38 <ndm> well actually, yes, since there is a Haskell interpetter in Java
13:28:46 <tibbe> I'm having problems building haskell-src-exts, I'm getting Ambiguous occurrence `isSymbol', anyone know wh?
13:28:49 <tibbe> why*
13:28:55 <ndm> no native JVM compiler yet, but not that far off, i hope
13:29:01 <Deformative-II> Now,  I know python has very small ammounts of typing to do a lot of things,  haskell is not this way is it?
13:29:14 <sjanssen_> glguy: you're right, this problem is tough in Haskell
13:29:28 <_velco> Deformative-II: "typing" as in "pressing keys" ?
13:29:43 <Deformative-II> Yes.
13:30:09 <Deformative-II> Like the accual lines required to do hello world in python is like one line if I remember,  and like 8 in java if I remember.
13:30:18 <mauke> one line in haskell as well
13:30:19 <_velco> haskell seems more concise to me
13:30:27 <mauke> main = putStr "Hello, world!\n"
13:30:29 <AStorm> ndm: really? Are there any supporting Haskell? I've heard about Erlang... but Haskell?
13:30:30 <emu> hello world is nothin
13:30:40 <Limbic_Region> you want concise - J
13:30:47 <AStorm> Erlang = Ericsson.
13:30:47 <AStorm> Yeah, print "Hello world!"
13:30:47 <Deformative-II> I know that.
13:30:51 <ndm> AStorm: not supporting, but you can run Yhc bytecode under Java
13:30:52 <emu> how about representing an infinite sequence in one line?  fib = 1 : 1 : zipWith (+) fib (tail fib)
13:30:58 <AStorm> The true miniproject is some media player (really basic)
13:30:59 <AStorm> Though it requires some libraries.
13:31:00 <Limbic_Region> you want variable length conciseness - Perl
13:31:06 <AStorm> ndm: now that will be slow
13:31:23 <mauke> AStorm: why slow?
13:31:24 <ndm> AStorm: we can produce native .NET bytecode, and someone was doing native JVM bytecode
13:31:29 <AStorm> emu: in Python you'd use a generator
13:31:29 <Deformative-II> Well,  I was planning on learning python,  but I think I will learn haskell instead.
13:31:29 <glguy> @hoogle [a] -> [a] -> Bool
13:31:30 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
13:31:30 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
13:31:35 <Deformative-II> Is there a good howto anywhere?
13:31:39 <AStorm> ndm: like compiling to Java bytecode, hehe :>
13:31:55 <ndm> AStorm: yes, basically
13:32:06 <AStorm> Sounds like Jython
13:32:29 <AStorm> (except Jython isn't up to the mark with other implementations of Python)
13:32:32 <_velco> jythin does not compile to bytecode AFAIK
13:32:33 <ndm> yep, basically
13:32:37 <dcoutts__> Deformative-II: on the haskell.org home page there are some links, eg:
13:32:39 <dcoutts__> http://haskell.org/haskellwiki/Haskell_in_5_steps
13:32:41 <ndm> we also have .NET, which is IronPythohn
13:32:42 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/gdrmd
13:32:58 <AStorm> Especially good book is YAHT.
13:33:05 <dcoutts__> Deformative-II: and http://haskell.org/haskellwiki/Learning_Haskell
13:33:07 <lambdabot> Title: Learning Haskell - HaskellWiki, http://tinyurl.com/fac2k
13:33:08 <AStorm> My recommendation.
13:33:28 <AStorm> Give the link to the PDF, because the main server id down :>
13:33:43 <AStorm> *is
13:34:16 <ndm> @where yaht
13:34:16 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
13:34:17 <_velco> http://pub.hal3.name/daume02yaht.pdf
13:34:27 <Deformative-II> Alright.
13:34:44 <Deformative-II> Before I leave,  what are the disadvantages of haskell at the language level?
13:34:51 <AStorm> lambdabot: you're so bad... this URL doesn't work :>
13:35:22 <ndm> Deformative-II: none :)
13:35:23 <AStorm> Deformative-II: hmm... it's very different from imperative languages.
13:35:30 <AStorm> Looks like math :P
13:35:42 <dcoutts__> Deformative-II: predicting space use can be tricky sometimes
13:36:03 <dcoutts__> it takes a while to really understand what lazy evaluation means for time and space use
13:36:04 <Deformative-II> What is haskell best used for?
13:36:10 <dcoutts__> hard problems
13:36:16 <AStorm> Parsers and new languages.
13:36:18 <dcoutts__> correct programs
13:36:22 <AStorm> (like Lisp :> )
13:36:33 <dcoutts__> short programs
13:36:40 <dcoutts__> elegant programs
13:36:41 <AStorm> most programs
13:36:45 <Deformative-II> So,  not like window managers?
13:36:47 <emu> programs-which-would-be-long-if-written-in-java
13:36:51 <AStorm> mathematical proofs
13:36:56 <AStorm> Deformative-II: can be done too :>
13:37:00 <emu> there's a common lisp window manager and a scheme one, why not haskell
13:37:03 <Deformative-II> Can be done well?
13:37:15 <AStorm> Most likely.
13:37:22 <AStorm> There are nice bindings of Xlib.
13:37:33 <Deformative-II> Like e16 level,  I know that it is VERY improbable to get anything to e17 level.
13:37:36 <emu> ugh looks like alioth is biting it again
13:37:47 <Deformative-II> I would learn C,  but coding in C takes too long.
13:38:04 <AStorm> emu: who? P
13:38:15 <emu> alioth.debian.org
13:38:19 <AStorm> Deformative-II: so true...
13:38:37 <AStorm> Ah, that machine. :-)
13:38:55 <Deformative-II> I feel dumb for buying K&R.
13:39:06 <AStorm> Deformative-II: Well, haskell is great for problems which lead to recursion.
13:39:16 <Deformative-II> I think I might learn C after I have 2-3 languages under my belt.
13:39:42 <AStorm> Deformative-II: you'll have to, sooner or later :>
13:39:53 <AStorm> It's too ubiquitous.
13:39:59 <AStorm> Much more than Java.
13:40:50 <AStorm> C is simple, but programming in C is entirely different matter.
13:40:53 <Deformative-II> Plus E17 is written in C,  and I would like to mabe be able to help on e18.  =)
13:40:56 <_velco> Deformative-II: not much point in learning C. In addition to haskell you'd better learn C++ or Java
13:41:23 <AStorm> In C you reimplement half of useful language anyway :P
13:41:25 <emu> c++ is a monster
13:41:31 <emu> at least C is simple
13:41:43 <AStorm> C++ is complex, but very useful.
13:41:49 <emu> in the way that assembler is simple
13:41:58 <emu> it's good to know how assembler works though
13:42:01 <AStorm> emu: uh, no.
13:42:18 <AStorm> THat, yes. Those are basic rules of any language or processor.
13:43:14 <SamB> well, knowing your instruction set won't help you much writing Python code...
13:43:18 <AStorm> Too simple the language gets, it starts to become an obstacle in complex problems.
13:43:30 <emu> which is why i was comparing C and asm
13:43:49 <AStorm> SamB: it won't, but the theory of programming languages can't hurt.
13:43:51 <glguy> Trying to think like a computer is one of the causes of ugly code
13:43:59 <AStorm> Hehe.
13:44:07 <glguy> that's the compiler writers job
13:44:12 <AStorm> glguy: very true
13:44:18 <_velco> I can imagine situations where one *needs* to code in C/C++. Not for python though.
13:44:26 <AStorm> Now those guys are smart :>
13:44:38 <AStorm> _velco: I can imagine for Python too :>
13:44:43 <SamB> you aren't very imaginitive if you can't!
13:44:48 <AStorm> Except there are numerous libraries.
13:44:55 <SamB> how do you think all those extensions work?
13:45:05 <_velco> what extension ?
13:45:06 <_velco> s
13:45:19 <AStorm> NumPy, SciPy, PyGame to name just a few.
13:45:21 <SamB> well, say, pygtk!
13:45:25 <glguy> I know that most of the time that I see people at work trying to help the computer out with their code... they are doing the opposite
13:45:32 <AStorm> PyGTK, wxPython...
13:45:36 <_velco> I don't get your point.
13:46:01 <AStorm> For fast code w/o programming in pure C, there's Pyrex.
13:46:06 <SamB> they all involve C or C++!
13:46:08 <_velco> I meanr I can't see a situation where one *needs* to code in python. Now clear ?
13:46:17 <Wallbraker> Theres D too
13:46:24 <SamB> oh, that!
13:46:27 <AStorm> _velco: of course
13:46:38 <SamB> well, it works better than C for most things ;-)
13:46:38 <AStorm> Wallbraker: D doesn't compile on many platforms yet.
13:46:48 <glguy> D seems to tear up on the programming language shootout
13:46:50 <emu> i would like to see a world where no one ever needed to code in C
13:47:08 <glguy> emu: look back 100 years or so :)
13:47:12 <emu> woot
13:47:12 <AStorm> emu: implement Haskell machine :>
13:47:19 <glguy> emu: this is well documented in History books
13:47:21 <Wallbraker> AStorm: true, but it is realy fast
13:47:22 <emu> babbage machine:P
13:47:24 <AStorm> glguy: 100 years? Just 40 back to the Lisp machines.
13:47:25 <_velco> emu: no problem, just invent machines with different architecture
13:47:25 <AStorm> :-)
13:47:33 <SamB> AStorm: how is it going to do stuff like ByteStrings?
13:47:40 <emu> yea Lisp Machines did exist
13:47:44 <emu> they were cool
13:48:03 <bringert> what happend to the java machines by the way? did those ever materialise?
13:48:05 <glguy> they ended up being less efficient than the general purpose machines with a decent compiler
13:48:15 <emu> glguy: well once general purpose hardware caught up
13:48:22 <glguy> which didn't take long
13:48:34 <_velco> bringert: lots of them
13:48:35 <emu> but the systems themselves were constructed from a lisp-like asm directly to the lisp machine lisp at the lowest levels
13:48:41 <SamB> I suspect that there may be architectural tweaks that could help CPUs do better with Haskell, but I don't imagine it would help much to make them dedicated Haskell machines...
13:49:07 <SamB> then you'd need to rebuild your CPU whenever dons changed Data.ByteString!
13:49:09 <_velco> bringert: if by "java machine" you mean a CPU which executes (some of) the java bytecodes
13:49:34 <AStorm> SamB: no, you write compatibility code
13:49:39 <emu> actually most CPUs execute reprogrammable microcode as it is
13:49:40 <AStorm> :P
13:49:56 <AStorm> emu: hmm, the instruction set is constant.
13:50:00 <SamB> well, I'm assuming that you would be using an FPGA...
13:50:02 <dcoutts__> SamB: we could adapt Data.ByteString to some aspects of the cache heirarchy of the target CPU
13:50:21 <SamB> dcoutts__: I'm talking about the idea of a Haskell Machine
13:50:34 <dcoutts__> mm
13:50:34 <glguy> Does Lazy.ByteSTring break into "L1 chache sized chunks"?
13:50:36 <AStorm> You wouldn't implement the class library in it.
13:50:40 <AStorm> :>
13:50:41 <SamB> I'm trying to make fun of it!
13:50:41 <sjanssen_> glguy: I managed to get PERMUT2 to run fast enough
13:50:46 <dcoutts__> glguy: something like that
13:50:48 <emu> the lisp machine hardware was more about doing things like typed-memory and parallel execution of branches
13:50:51 <glguy> sjanssen_: what did you have to do?
13:51:03 <emu> not implementing "getChar" in a circuit
13:51:06 <dcoutts__> glguy: it's rather smaller than L1 for various reasons
13:51:07 <AStorm> emu: which is what every microkernel writer dreams of.
13:51:08 <_velco> tagged registers
13:51:31 <dcoutts__> glguy: but it is tuned for normal cache sizes yes, from some profiling that we did.
13:51:35 <glguy> dcoutts__: I just saw something about that on the front page... I didn't look deeper into it
13:51:37 <emu> then "general purpose" hardware vendors decided that tagged memory was too much overhead or some crap
13:51:40 <dwm> Does the ghc (or other compiler that creates machine code) go through a C step, or compile directly for the machine?
13:51:45 <sjanssen_> glguy: I had to use int-e's fast Int reading code and interact $ process . words
13:51:46 <SamB> emu: you don't think so?
13:51:53 <dcoutts__> dwm: both!
13:52:02 <SamB> I think it is too hard to virtualize efficiently, personally
13:52:03 <AStorm> emu: and then they pushed that back to the CPU - how ironic :>
13:52:03 <dcoutts__> dwm: ghc can compile -fvia-C or -fasm
13:52:08 <emu> well, look at the crappy OSes of the last 20 years... meh
13:52:10 <glguy> sjanssen_: is the fast read stuff coming in 6.6?
13:52:12 <dwm> dcoutts__: :) I mean, if you are not asking for C output.
13:52:19 <sjanssen_> glguy: I don't think so
13:52:22 <AStorm> dcoutts: it compiles through ASM?
13:52:23 <glguy> oh
13:52:24 <emu> so instead of having tagged memory you emulate it
13:52:25 <dcoutts__> dwm: though it only has -fasm for some arches
13:52:25 <AStorm> How?
13:52:30 <emu> in order to maintain sanity
13:52:33 <AStorm> (x86 here)
13:52:33 <sjanssen_> glguy: but 6.6 brings Data.ByteString, which has some Int reading code
13:52:35 <SamB> emu: what do you mean?
13:52:36 <dwm> ok, so it wants to, by default, if it can
13:52:45 <SamB> why would you want to tag every word or two of memory?
13:52:55 <emu> to give it a type
13:52:56 <dcoutts__> AStorm: by generating assembly output, or is that not what you meant?
13:53:00 <emu> it also helps the GC
13:53:03 <glguy> SamB: to use more memory
13:53:16 <SamB> emu: but you could just tag every closure appropriately!
13:53:25 <AStorm> dcoutts: so how do you generate it? Is it gas or nasm?
13:53:28 <glguy> SamB: wouldn't use as much...
13:53:32 <dwm> Related question: Since the ghc is written in Haskell, is this how it gets ported to new system where there is no Haskell compiler? By outputting to C and then massaging that to work the first-time to bootstrap it?
13:53:35 <dcoutts__> AStorm: gas
13:53:36 <emu> you generally need to distinguish between integers and pointers
13:53:49 <dcoutts__> dwm: pretty much, yes.
13:53:50 <AStorm> dwm: simple - by writing Haskell compiler in C :P
13:53:51 <emu> i'm pretty sure even ghc includes a tag bit on integers
13:53:59 <AStorm> Small one though.
13:54:01 <SamB> emu: wouldn't it be simpler to just put a pointer at the beginning of every closure describing its layout?
13:54:05 <dcoutts__> dwm: one generates C code for the target platform and then compile that with gcc.
13:54:20 <AStorm> dcoutts: yes.
13:54:33 <_velco> SamB: it would be too expensive for base types
13:54:37 * SamB doesn't think emu will get his reference
13:54:41 <dwm> And then after I guess you're good. Prior compiler builds next one on that platform.
13:54:42 <emu> SamB: if i recall, there was a scheme in general by which tag info was stored in a table for a given page; the problem with this was caching
13:54:47 <dcoutts__> emu: ghc does not tag integers like ocaml does.
13:54:50 <SamB> _velco: "base types"?
13:54:57 <dcoutts__> dwm: exactly.
13:55:16 <_velco> SamB: pointers, bool, Ints, float, double
13:55:28 <SamB> emu: what I describe is what GHC does, actually...
13:55:29 <_velco> SamB: stuff supported directly by hw
13:55:40 <dwm> Having the compiler written in the language is so recurs-o-licious. yay
13:55:44 <SamB> hardware supports lazy evaluation?
13:55:45 <emu> SamB: i realize that you can implement a tag bit or word
13:55:59 <emu> dwm: i think it's called "metacircular" these days :)
13:56:08 <Deformative-II> Thanks for the help everyone, I am gonna go follow this tutorial now.
13:57:09 <emu> SamB: my original thoughts were directed towards the way weak typing took over the hardware and software worlds in the form of C
13:57:21 <dwm> emu: metacirc-o-licious, got it.
13:57:38 <SamB> I don't think hardware should waste effort on soon-to-be-obsolete typesystems!
13:59:22 <AStorm> dwm: Haskell promotes recursion.
13:59:27 <AStorm> It seems C does so too :P
13:59:35 <SamB> huh?
13:59:54 <AStorm> When have you last seen a C compiler written in asm or something else? :P
14:01:36 <emu> all good compilers are written in their source language =)
14:02:35 <_velco> does this precludes haskell usage if I want to write a C compiler ?
14:03:34 <dcoutts__> nope
14:03:52 <dcoutts__> a C compiler in Haskell would be a sensible thing
14:04:01 <dcoutts__> much easier to write compilers in Haskell than in C
14:04:38 <glguy> that's why everyone's doing it
14:05:08 <dcoutts__> note how the C-- compiler is not written in C or C--
14:05:17 <emu> well the basis behind that statement is because, since a compiler is a massive project, presumably the person writing it would want to work in his or her favorite language
14:05:31 <Deformative-II> The haskell compiler is written in haskell?
14:05:35 <glguy> ghc is
14:05:44 <Deformative-II> Cool.
14:05:51 <Deformative-II> I think the python compiler is in C...
14:05:58 <emu> pyrex?
14:06:05 <_velco> python
14:06:10 <norpan> hugs is in c at least
14:06:12 <glguy> ghc is more of a haskell to c translator tho.... right?
14:06:27 <_velco> C or ASM - not much difference
14:06:33 <_velco> :)
14:06:46 <norpan> ghc is a full compiler
14:07:13 <_velco> on all or on some platforms ?
14:07:27 <emu> i'm sure it has a variety of internal representations
14:07:50 <emu> C as an IR is rather meh, actually, which is why C-- was created, I think
14:08:09 <norpan> well, it can't be on all platforms of course
14:08:20 <norpan> but on some it can go directly to asm at least
14:08:36 <norpan> and the c it generates is not very high level
14:08:38 <_velco> C is not IR but final output
14:09:03 <norpan> final output is object code
14:09:14 <_velco> I serously doubt
14:09:16 <norpan> you can't very well run c coude
14:09:28 <norpan> you need to compile all the way down to object code
14:09:44 <_velco> I'm talking about the final output of ghx, nbot of the rest of the toolchain
14:09:49 <_velco> ghc
14:10:01 <norpan> well, ghc invokes gcc, so...
14:10:09 <norpan> the final output of ghc is object code
14:10:44 <_velco> I can't see the purpose of this agruing
14:10:52 <norpan> then why do you keep on arguing?
14:11:05 <_velco> because you're talking bulshit
14:11:10 <norpan> oh
14:11:20 <norpan> i told you that ghc generates asm on some platforms
14:11:30 <norpan> and goes via c on some
14:11:31 <_velco> the final output of some program is what other program spawned by it outoputs
14:11:41 <_velco> probably this is very functional pouint of view
14:12:00 <_velco> guess it;'s some fomr of manadic cimbination ...
14:12:14 <norpan> also, ghc does some magic on the asm output from the c compiler
14:12:54 <eivuokko> It removes the function pro- and epilogue.
14:13:40 <AStorm> So no debugging? :P
14:13:53 <eivuokko> Not really, no.
14:13:55 <norpan> you don't want to debug the c code generated
14:16:10 <AStorm> I know, but sometimes there's no choice ;-)
14:19:52 <Philippa> _velco: does it really matter whether GHC calls GCC via the OS or statically links it into itself?
14:20:21 <_velco> Philippa: yes
14:20:36 <Philippa> ...right
14:20:46 <tibbe> hm, I can't build haskell-src-exts, it makes ambigious use of isSymbol, anyone know where I can find a working version?
14:20:55 <_velco> Philippa: for various reasons, like creadit and licensing to name a few
14:20:58 <_velco> ^credit
14:21:58 <Philippa> okay, fine. Given that neither of those have anything to do with your line of argument, find something that does?
14:22:12 <Philippa> (binary GHC distros tend to ship with a GCC binary as well, FWIW)
14:22:33 <Deformative-II> Hmm,  is the basics of haskell fast to learn?
14:22:38 <Deformative-II> Or does it take a while?
14:22:51 <mauke> both
14:22:54 <glguy> depends on the person
14:22:57 <Philippa> the basics're fairly quick so long as you don't need to do too much unlearning
14:23:11 <Philippa> and so long as you don't hit a mental block - but that applies to the basics of anything
14:23:33 <Deformative-II> What would cause this unlearning?
14:23:44 <glguy> programming in other languages :)
14:24:02 <_velco> Philippa: you would probablt say that GCC outputs object code as well ?
14:24:05 <Philippa> yeah. Getting confused about what = means, or expecting everything to evaluate strictly
14:24:30 <Philippa> _velco: personally, I'd say every compiler outputs object code, and that this isn't (necessarily) the same as machine code
14:24:41 <Deformative-II> Ah,  well,  I was told haskell will not confuse me at my java class....
14:24:42 <emu> mmm fps version is over 4x as fast as the standard IO stuff
14:24:58 <Deformative-II> And will learning python first make me need to unlearn in order to learn haskell?
14:25:02 <_velco> Philippa: but I;'ve for gcc source right here and I can't see a single line, which outputs object code.
14:25:09 <Deformative-II> Or is learning python first a good idea since it is so easy.
14:25:25 <_velco> Philippa: aha, inventing terms, ok.
14:25:38 <Philippa> no, using terms the way they've been used in the study of compilers for decades
14:25:54 <glguy> oh yeah, well mine's bigger than yours
14:26:15 <Philippa> glguy: that's trivial, unless you let me use the collection in the room next door...
14:26:55 <glguy> OK, you can use the collection then
14:27:01 <Deformative-II> Anybody?
14:27:12 <glguy> Deformative-II: you want us to advise you on python?
14:27:18 <Philippa> Deformative-II: learning python won't teach you much useful about FP ala Haskell
14:27:22 <sjanssen_> emu: are you requesting fps on the SPOJ forums?
14:27:56 <Deformative-II> I just want to know what is the best first language,  one that I can learn at the same time as java.
14:28:51 <_velco> Deformative-II: why don't you concentrate on one language first ?
14:29:08 <Deformative-II> Because I am learning java in school,  and they are going at an uber slow rate...
14:29:15 <Deformative-II> And I hate that.
14:29:26 <glguy> so ... learn java quickly on your own?
14:29:28 <Philippa> Haskell'll have more new stuff to learn
14:29:39 <Philippa> OTOH, it'll make Java piss you off even more than learning Python will
14:30:02 <Philippa> at least Python only teaches you that Java's type system gets in the way - it won't show you that it could get you something useful for the cost ;-)
14:30:05 <AStorm> Hehe.
14:30:08 <AStorm> Fortunately, I'm unpissable by computer languages.
14:30:22 <AStorm> Had done much too many of them :P
14:30:30 <glguy> I can make up words too
14:30:47 <glguy> razamataz
14:30:50 <_velco> hehe, it's like to be pissed off by hot weather or by a thunderstorm ;)
14:31:04 <_velco> or by gravity :)
14:31:09 <Philippa> glguy: pissable might not be in the dictionary, but it's part of the english language...
14:31:16 <Deformative-II> glguy, t hen I will be even more bored in class.
14:31:25 <Philippa> by further derivation, so's unpissable
14:31:27 <Deformative-II> Plus I don't wanna know more java than I need to.
14:31:56 <jgrimes> I just work on haskell stuff in my java classes
14:32:02 <glguy> @all-dicts pissable
14:32:04 <lambdabot> No match for "pissable".
14:32:13 <tibbe> knowing things can't be bad it? although putting time into it that could be put to more better use is
14:32:14 <Philippa> you might as well learn at least Java the language properly. There's pretty good odds you're going to have to work in a language similar to it at some point
14:32:25 <tibbe> s/it/can it
14:32:53 <Philippa> @all-dicts kissable
14:32:54 <lambdabot> No match for "kissable".
14:33:10 <shapr> yow!
14:33:20 <Philippa> @all-dicts inflatable
14:33:22 <lambdabot> *** "Inflatable" gcide "The Collaborative International Dictionary of English v.0.48"
14:33:22 <lambdabot> Inflatable \In*flat"a*ble\, a.
14:33:22 <lambdabot>   That may be inflated.
14:33:22 <lambdabot>   [1913 Webster]
14:33:22 <lambdabot>  
14:33:24 <lambdabot> [4 @more lines]
14:33:24 <glguy> http://dictionary.reference.com/search?q=kissable
14:33:26 <lambdabot> Title: kissable - Definitions from Dictionary.com, http://tinyurl.com/kcfpj
14:33:35 <jgrimes> hey shapr
14:33:37 <Deformative-II> Hmm.
14:33:38 <Philippa> glguy: you can derive the definition of pissable from there...
14:33:39 <shapr> hiya jgrimes
14:33:41 <Philippa> 'lo shapr
14:33:45 <shapr> greetz Philippa
14:33:47 <Deformative-II> Can haskell be used WITH java in the same app?
14:34:01 <Philippa> I think only via JNI at the moment?
14:34:02 <shapr> Deformative-II: Has been done with Haven.
14:34:06 <glguy> Philippa: just because sufixes and prefixes exist, doesn't mean you can add them to any word you like
14:34:06 <Philippa> oh, cool
14:34:13 * shapr gets url
14:34:13 <AStorm> Add onelook.com search to lambdabot
14:34:23 <Philippa> glguy: it does, however, mean that you can add them to any appropriate word
14:34:43 <glguy> if the result is a real word
14:34:44 <Philippa> -able of a verb: That may be <verbed>
14:34:56 <Philippa> defined as "one they bothered to collate into the dictionary"?
14:35:00 <shapr> Deformative-II: The thesis mentioned here was written in Haskell, but the GUI was done in Java - http://www.apocalypse.org/~antony/work/index.html
14:35:03 <lambdabot> Title: Antony's Work Page, http://tinyurl.com/jr7w6
14:35:04 <Philippa> doesn't work like that
14:35:09 <glguy> lol
14:35:30 <emu> is there a flush operation for fps?
14:35:34 <glguy> unpissable might be a "word" but it's not an English word :)
14:35:39 <Philippa> now, consider the US English meaning of "pissed"...
14:35:42 <emu> bytestrign io
14:35:55 <emu> i guess i can just use the normal sstuff
14:36:13 <Philippa> glguy: yet it's derived in exactly the same way as "unflappable"...
14:36:18 <emu> yea nvm, wasn't thinking
14:36:24 <Philippa> albeit from an americanism
14:36:30 <glguy> Philippa: providing exampels of real words does not prove your case
14:36:41 <AStorm> IT does.
14:36:44 <Philippa> nor does repeatedly asserting that it's not a real word prove yours
14:36:50 <AStorm> It's a typical rule of building adjectives.
14:36:56 <AStorm> e.g. passable
14:37:18 <emu> does anyone here use the emacs haskell-mode package with smart indentation?
14:37:31 <_velco> mine seems a bit smart
14:37:37 <AStorm> -able and -ible :>
14:37:41 <bringert> emu: yep
14:37:59 <emu> do you notice an issue when indenting the "then" and "else" portions of an "if" within a "do" block
14:38:12 <shapr> emu: yu4p
14:38:16 <emu> ok so it's not just me
14:38:26 <shapr> I
14:38:29 <shapr> argh
14:38:49 <bringert> hi shapr
14:38:49 <shapr> I went to hack on that problem once, and discovered that the indentation uses something that I was unable to decipher at the time.
14:38:52 <shapr> hej bringert
14:39:00 <shapr> I found a Hope um, not-bug last night.
14:39:28 <bringert> so, you found the one thing that does not do the wrong thing?
14:39:39 <shapr> MSIE always brokenly uploads jpegs with the image/pjpeg mime type, even though that's not a standard and doesn't really exist.
14:39:53 <bringert> oh
14:40:00 <bringert> I thought I had tested with IE
14:40:16 <bringert> maybe I didn't
14:40:22 <bringert> anyway, easy patch
14:40:25 <shapr> So I told the MSIE user, "firefox doesn't suck like MSIE, that's not a bug in the photo album software."
14:41:31 <shapr> I'm staying with two of my friends who are both Windows users.. I had no idea it had become so much work to use Windows. What with malware of many flavors and a zillion other things...
14:42:08 * shapr shrugs
14:43:02 <vincenz> heh
14:43:10 <vincenz> and all the spamstuff against spam that slows your comp down
14:43:19 <vincenz> like twentythree zillion little icons in the tray
14:43:45 <vincenz> those little icons always pissed me off "why do I need too have all this stuff consuming my cpu1"
14:43:48 <shapr> Yeah, my friends both have alienware boxes that are both faster and have more ram than my debian/unstable box, but they aren't as responsive.
14:43:58 <Philippa> I count five in mine, including D-tools and an IM client...
14:44:10 <vincenz> Philippa: o.O
14:45:04 <Philippa> shapr: dual core boxes? What's your debian/unstable box running on?
14:45:14 <shapr> single 2.5GHz P4
14:45:27 <Philippa> ah. Was thinking of your dualie
14:45:31 <shapr> Admittedly, I've tuned it thoroughly.
14:45:34 <shapr> Nah, I gave that to Sofia
14:45:59 <Philippa> yeah, tuning windows thoroughly takes some doing
14:46:46 <shapr> Does lambdabot have an http server already?
14:46:57 * shapr is tempted to invoke Zawinski's law and add a mail client
14:48:21 <Deformative-II> So would haskell make a good window manager or no?
14:48:49 <CosmicRay> Deformative-II: if scheme does, surely haskell would.
14:49:10 <Deformative-II> Hmm,  How come everyone says make window managers in C?
14:49:29 <Philippa> because they assume only C can be fast enough, and because all the relevant interfaces're in C
14:50:08 <Deformative-II> Also I hear haskell would be too complicated to make one in.,
14:50:15 <qwr> why?
14:51:02 <Deformative-II> I dunno.
14:51:07 <Deformative-II> I am not a programmer.
14:51:48 <Philippa> you might be biting off more than you can chew, then
14:51:51 <Philippa> regardless of which language
14:52:12 <Philippa> qwr: I certainly wouldn't want to write one in Haskell 98 + FFI addendum
14:52:13 <Philippa> qwr: I certainly wouldn't want to write one in Haskell 98 + FFI addendum
14:52:18 <Philippa> er, sorry for the repeat there
14:52:46 <Deformative-II> Philippa, I don't want to make one yet,  for like at least 3 years.
14:52:49 <Deformative-II> I am just curious.
14:53:18 <shapr> I dunno, I taught my girlfriend some beginning Haskell stuff in a coupla days of after work time.
14:53:36 <shapr> She's a musician and has no prior programming experience.
14:53:38 <Philippa> I am, admittedly, assuming that from a beginner's POV a WM's non-trivial
14:53:49 <Philippa> getting started with Haskell doing at least something isn't too hard
14:53:58 <shapr> Yeah, that is definitely true.
14:54:24 <shapr> Deformative-II: I think you may want to start with something smaller to get your feet wet, but a WM won't be hard if you work up to it.
14:54:35 <astrolabe> And if you are going to learn to program, you might as well start at the top :)
14:54:40 <shapr> heck yeah
14:55:11 <Philippa> nah, start at the bottom. Everything can be done in terms of one set theory or another, encode algebras and functions... :-)
14:55:55 <Deformative-II> Well, I was planning on learning java, C, python, haskell, and MAYBE lisp.
14:56:05 <Deformative-II> Then I wanted to read the enlightenment code.
14:56:17 <Deformative-II> And make a window manager some day in the future.
14:57:01 <astrolabe> Which is the best haskell tutorial for a beginning coder?
14:57:04 <astrolabe> @learn
14:57:05 <lambdabot> http://www.haskell.org/learning.html
14:57:45 <astrolabe> hmmm where has YAHT gone?
14:58:20 * Limbic_Region has been programming in one language or another for at least a decade and still can't get haskell assimilated into his peanut of a brain
14:58:35 <Deformative-II> Well, I think I will learn python first,  just because I know I can keep up with the java class in python on my own time.
14:58:38 <Deformative-II> Since it is easy.
14:58:58 * Limbic_Region 's brain refuses to think recursively
14:59:06 <Adamant> that's a pretty decent list of languages.
14:59:21 <Adamant> minus java, but it's obligatory. :)
14:59:44 <Deformative-II> Java is not my choice.
14:59:52 <astrolabe> I've heard it said that functional programming is easier to learn if you haven't started with imperitive.  I don't know if that's true.
14:59:59 <Cale> YAHT is still up
15:00:03 <Adamant> that's what I meant by Obligatory. :)
15:00:08 <Deformative-II> I thought so.
15:00:10 <Deformative-II> Just making sure.
15:00:19 <astrolabe> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf#search=%22yet%20another%20haskell%20tutorial%22
15:00:19 <Cale> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf#search=%22Yet%20another%20haskell%20tutorial%22
15:00:24 <astrolabe> heh
15:00:24 <Cale> heh
15:00:28 <astrolabe> ha
15:00:33 <Adamant> YAHT is good.
15:00:56 <Adamant> if you want to learn Lisp concepts, but not necessarily be a full-time Lisp guy
15:01:03 <Adamant> Scheme is an excellent choice.
15:01:33 <Deformative-II> Well, I am gonna go read the python tutoral now.
15:01:37 <Deformative-II> B-bai everyone.
15:01:41 <astrolabe> It would be good to have 'the little lisper' but about haskell.
15:01:42 <Adamant> good luck!
15:01:44 <Cale> Yeah, I find scheme to be way less annoying than common lisp for the functional programming style at least.
15:02:06 <kuribas> Deformative-II: I would read the code for aewm, it small and very clear.
15:02:31 <Deformative-II> What language kuribas?  Prolly C.
15:02:38 <tibbe> does haskell 98 require that implementations have tail recursion like scheme does?
15:02:54 <kuribas> Deformative-II: C, and there is also aewm+ in C++.
15:03:11 <Deformative-II> Alright,  I need to learn C before then though.
15:03:27 <Cale> I was always frustrated about how every symbol could be bound to a function or another kind of value separately, and how you had to use Apply or Call to run functions passed as parameters, and you couldn't just pass the functions, but had to quote them in a funny way.
15:03:29 <astrolabe> tibbe: I don't think so, but I think GHC does anyway.  I'm not sure.
15:03:32 <Adamant> Cale, Common Lisp explictly supports imperative as co-equal with functional styles. Most CL'ers switch between the two equally. Scheme favors the functional style style more.
15:03:36 <Cale> (in common lisp)
15:04:21 <Adamant> ah, quoting doesn't bother me much.
15:04:24 <Cale> So basically, functional programming in CL was a massive pain for me, and it felt like the language was struggling to keep me from doing it :)
15:04:46 <Adamant> fair enough. :)
15:04:49 <Cale> (despite making it tantalisingly possible)
15:05:00 <shapr> dfranke: So, do you know of any Southeast USA Functional Programming conferences?
15:05:05 <Adamant> most CL implimentations do tail-recursion now like Scheme.
15:05:08 * shapr was in Atlanta a few days back
15:05:30 <Adamant> shapr, dfranke - if you do, tell me about them!
15:05:43 <jgrimes> I wish I knew of some southeast usa fp conferences
15:05:44 <jgrimes> :p
15:05:57 * Adamant is in southern Georgia
15:06:15 * jgrimes is in central NC
15:06:21 <tibbe> time to sleep, g'night
15:07:12 <shapr> In that case, maybe it's time to start DeepFriedFunctors or something equally cheesy.
15:07:22 <jgrimes> haha
15:14:35 <dfranke> shapr: eh, the only one I've ever heard of is ACM's and that goes all over North America.
15:15:02 <dfranke> There's the ACM Southeast conference that covers CS generally, but I'm not sure if they even still do those.
15:15:32 <jgrimes> =/
15:22:51 <Limbic_Region> out of curiosity, if I was pulling the ghc source with darcs would I have to recompile ghc in its entirety everytime or would it be smart enough to only touch those pieces that have changed?
15:23:16 <Limbic_Region> cause the thought of downloading the source everyday and spending hours recompiling doesn't appeal much to me
15:23:32 <AStorm> First option.
15:23:35 <ptolomy> I've been out of it; is new GHC still slated for release tomorrow?
15:23:44 <ptolomy> also, deep fried functors sound really good right now.
15:23:50 <AStorm> Make is smart enough to only rebuild things that had changed.
15:23:50 <sjanssen_> ptolomy: don't think so
15:23:59 <sjanssen_> after ICFP last I heard
15:24:11 <ptolomy> That's probably good.
15:24:48 <Limbic_Region> hrm - guess I need to get darcs then
15:28:36 <emu> that's easy enough
15:29:01 <Limbic_Region> downloaded already
15:29:24 <Limbic_Region> trying to figure out how to point it at the ghc repo
15:33:51 <Limbic_Region> found it on the developer's wiki
15:42:43 <shapr> hiya SyntaxNinja!
15:51:54 <vincenz> @where yaht
15:51:54 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
15:51:58 <vincenz> I had updated the link normally
15:52:04 <vincenz> the @where is up to dae
15:52:05 <SyntaxNinja> y0
16:02:19 <Lemmih> SyntaxNinja: YGM.
16:23:35 <Pseudonym> ?free sortBy
16:23:37 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
16:23:44 <Pseudonym> Excellent, new version.
16:25:06 <dons> looks good
16:25:59 <Pseudonym> Unfortunately, that is actually less interesting than the non-pointfree'd version.
16:26:24 <Pseudonym> Pointfreeing-ness has made the RHS more useful but the LHS less useful.
16:26:28 * Pseudonym hmms
16:26:34 <Pseudonym> I wonder if it's possible to detect that.
16:31:38 <glguy> who was asking about gtk2.10 on OS X and gtk2hs?
16:32:20 <dcoutts__> me possibly
16:32:31 <glguy> I just noticed that 2.10 was in macports now
16:32:52 <dcoutts__> oh cool
16:33:08 <glguy> 2.10.2_1
16:39:41 <vincenz> dcoutts__: heh, the SPJ article is springer verlag... meaning pay for access
16:39:49 <vincenz> and we only have IEEE and ACM at the office
16:39:50 <vincenz> I think
16:40:40 <dcoutts__> vincenz: see spj's home page
16:43:19 <vincenz> oies
16:46:57 * lispy waves
16:46:59 <vincenz> okies even
16:48:48 <ramserver> hey anyone here tryign happs yet?
16:48:51 <ramserver> it seems cool
16:48:58 <dons> ?seen Lemmih
16:48:58 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I last heard Lemmih speak 26m 14s ago.
16:49:01 <ramserver> java people say im crazy to learn haskell or happs
16:49:10 <dons> ramserver: musasabi's tried it. seems really nice
16:49:34 <dons> Lemmih: we still need JaffaCake and Manuel to fill out the SoC surveys
16:49:44 <emu> dons: i got a chance to download and install fps, and it's very nice =)
16:49:55 <dons> cool :)
16:51:24 <mauke> help me, I'm stupid
16:51:42 <lispy> ramserver: why do they think it's crazy?
16:51:46 <Pseudonym> BBS
16:51:46 * Limbic_Region points mauke to #perl
16:51:50 <Limbic_Region> ;-)
16:51:59 <dons> heh
16:52:02 <mauke> is there a predefined function for: foo f z (x : xs) = let (z', y) = f z x in y : foo f z' xs
16:52:23 <mauke> the type is (a -> b -> (a, c)) -> a -> [b] -> [c]
16:52:23 <lispy> mauke: @pl is a nice way to help find predefined functions
16:52:25 <dons> is that a fold?
16:52:31 <mauke> I'm not sure
16:52:58 <mauke> lispy: bar = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . liftM2 (.) (:)) .)) .) . (`ap` ((fst .) .)) . (((.) . (.)) .))
16:53:05 <lispy> haha
16:53:09 <lispy> mauke: clearly
16:53:43 <lispy> @hoogle (a -> b -> c) -> a -> [b] -> [c]
16:53:44 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:53:47 <mauke> wait, I think I pasted the wrong thing
16:53:49 <dons> so its a fold that's generating an extra element on the side
16:54:23 <monochrom> @hoogle mapAccumL
16:54:24 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
16:54:24 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:54:45 <dons> ah the under appreciated mapAccum*
16:54:50 <dons> monochrom++
16:54:53 <musasabi> ramserver: I have done HAppS stuff. (and am currently hacking on it)
16:54:56 <dons> ?karma monochrom
16:54:57 <lambdabot> monochrom has a karma of 5
16:54:59 <mauke> awesome
16:55:30 <mauke> thanks!
16:55:56 <monochrom> I looked for it and used it a couple of months ago.  Some memory was retained.
16:57:04 <ramserver> oh really
16:57:13 <ramserver> how does haskell and happs feel?
16:57:25 <dons> like hot chocolate?
16:57:26 <ramserver> I see php and mysql on apache on linux seem popular
16:57:31 <ramserver> but not sure i want to go there
16:57:36 <ramserver> happs seems really awesome
16:57:58 <dons> *shrug* popular == britney spears. no indication of quality
16:58:21 <mauke> @pl addtag f = snd . mapAccumL (\z x -> (advancePos x z, mktagg x z)) (f, 0, 0)
16:58:22 <lambdabot> addtag = (snd .) . mapAccumL (ap (ap . ((,) .) . flip advancePos) (flip mktagg)) . flip (flip (,,) 0) 0
16:59:14 <ramserver> musasabi are you the happs creator?
17:00:00 <Deformative-II> hmm.
17:00:02 <musasabi> I have written large parts of it. Alex Jacobson is the main person behind HAppS.
17:00:14 <Deformative-II> This interpereter stuff in python is retarted.
17:00:34 <Deformative-II> =/
17:01:37 <ramserver> ah
17:01:43 <emu> php + mysql = endless frustration if you try to do anything "interesting"
17:02:03 <ramserver> well i know 0 pogramming but would love to have my own biz doing websies on happs for people
17:02:12 <mauke> ph33r the synergy
17:02:37 <dons> ramserver: you better get hacking then. start with http://haskell.org
17:02:39 <lambdabot> Title: Haskell - HaskellWiki
17:03:06 <dons> oh, ramserver . I KNOW YOU.
17:03:19 <shapr> ?
17:03:25 <ramserver> please
17:03:29 <monochrom> You're better off hiring us and letting us make the choice and do the work for you.
17:03:29 <dons> ?photontorpedo
17:03:30 <lambdabot> why did someone create haskell?
17:03:35 <dons> ?photontorpedo
17:03:35 <lambdabot> how does haskell compare to j2ee?
17:03:36 <ramserver> just point me to best beginng tutorial and ill leave
17:03:45 <dons> you know it well enough already.
17:03:45 <emu> rofl
17:03:56 <ramserver> :
17:03:57 <ramserver> :(
17:04:16 <Cale> Is he the same person?
17:04:19 <dons> yep
17:04:22 <shapr> Wow
17:04:41 <dons> you can tell by the spelling/questions. but also the name: gschuett@4.38.41.141
17:04:43 <shapr> This community doesn't really need @karma, we have memories an elephant would envy.
17:04:58 <Cale> heh
17:05:02 <monochrom> "know 0 programming, love to have my own biz" = you are meant to run a business and take care of the finance and marketting, NOT programming.
17:05:13 --- mode: ChanServ set +o dons
17:05:19 <Cale> ramserver: anyway, if you're serious about it, you should read "Yet Another Haskell Tutorial"
17:05:20 --- kick: ramserver was kicked by dons (dons)
17:05:24 <shapr> ooh, is that the boots of kicking?
17:05:25 <Cale> hey!
17:05:26 <shapr> So it is!
17:05:26 <dons> same troll, same story
17:05:51 --- mode: ChanServ set -o dons
17:06:28 <vincenz> what?
17:06:28 <dons> i have zero tolerance for his trolling after 10 months of that, from 4 ip addresses and 20-odd nicks :/
17:06:32 <vincenz> dons: who did you kick?
17:06:37 * vincenz filters messages
17:06:46 <dons> photontorpedo/shemale*
17:06:58 <vincenz> ramserver?
17:07:31 <dons> yup
17:07:52 <lispy> > replicate 1 0
17:07:54 <lambdabot>  [0]
17:08:00 <lispy> > replicate 0 1
17:08:01 <lambdabot>  []
17:08:06 <vincenz> > replicate 11
17:08:07 <lambdabot>  Add a type signature
17:08:09 <vincenz> > replicate 1 1]
17:08:09 <lambdabot>  Parse error
17:08:13 * vincenz sighs
17:09:14 <Igloo> dcoutts__: ping?
17:09:15 <Deformative-II> Haskell isn't interpereted is it?
17:09:29 <dcoutts__> Igloo: pong
17:09:29 <mauke> Haskell is a language, not an implementation
17:09:38 <Deformative-II> Good.
17:09:39 <dcoutts__> Deformative-II: depends on the implementation
17:09:44 <Deformative-II> Oh..
17:09:57 <dcoutts__> Hugs is a Haskell interpreter
17:09:58 <Igloo> dcoutts__: cabal is changing my /s to \s and then complaining ghc doesn't exist
17:10:03 <Deformative-II> Like with C,  you compile something, then it is an application,  right?
17:10:07 <dcoutts__> Igloo: ?
17:10:10 <mauke> there are C interpreters
17:10:11 <dons> Deformative-II: check haskell.org, you've got a bunch of native code compilers, bytecode interpreters, and more ..
17:10:33 <monochrom> I have seen a handheld computer by Casio that interpreted C.
17:10:35 <dcoutts__> Igloo: on windows?
17:10:41 <dons> monochrom: huh!
17:10:45 <Igloo> dcoutts__: http://urchin.earth.li/~ian/cabal2.txt
17:10:46 <Igloo> Yes
17:11:00 <monochrom> It was a long time ago. circa 1990.
17:11:24 <Deformative-II> Uhh.
17:11:28 <Deformative-II> I am so confused now.
17:11:40 <dons> Deformative-II: how so?
17:11:44 <Deformative-II> Haskell can be compiled to bianary,  yes or no?
17:11:47 <dons> yes
17:11:55 <Deformative-II> Python can not, it needs to be run though an interpereter to be used.
17:12:13 <dons> generally yes. that's why haskell is faster :)
17:12:16 <dylan> there's a python compiler in the works.
17:12:22 <Deformative-II> I know.
17:12:22 <monochrom> One of us should go write a Python compiler just to confuse Deformative-II more. :)
17:12:33 <Deformative-II> You should,  then I would be happy.
17:12:33 <lispy> @google ironpython
17:12:34 <dons> Iron Python is a compiler, isn't it?
17:12:38 <lambdabot> http://www.ironpython.com/
17:12:38 <lambdabot> Title: IronPython - A fast Python implementation for .NET and ECMA CLI
17:12:41 <mauke> isn't there a python->jvm compiler?
17:13:03 <sjanssen_> @google jython
17:13:04 <dolio> Does Jython comile to the jvm?
17:13:12 <dolio> Compile, even.
17:13:30 <lispy> jython works on the jvm but it's sort of gimped because none of the libraries that use C will work in jython
17:13:35 <dcoutts__> Igloo: how long has it been doing this?
17:13:41 <dons> Deformative-II: so yes, you write haskell source files, and ghc produces nice binaries for you :) like pugs or lambdabot
17:13:44 <Igloo> dcoutts__: No idea
17:13:48 <monochrom> This series of "___ is compiled/interpretted?" questions is as misguided as "are potatoes baked or not?"
17:13:49 <dcoutts__> Igloo: why wouldn't '\' work anyway?
17:14:03 <Deformative-II> Ah.
17:14:14 <Deformative-II> Well,  how difficult is it to learn haskell?
17:14:21 <Deformative-II> I picked python because it was so easy.
17:14:26 <monochrom> Very difficult.
17:14:32 <Deformative-II> But now I find out about this no bianary nonsence.
17:14:40 <Igloo> dcoutts__: No idea
17:14:51 <sjanssen_> Deformative-II: no binary?
17:14:56 <Igloo> dcoutts__: This is in cygwin FWIW
17:14:56 <Deformative-II> Yes.
17:14:58 <Deformative-II> Sorry.
17:15:03 <Deformative-II> My spelling is very bad.
17:15:23 <sjanssen_> Deformative-II: right, but what do you mean by no binary?
17:15:25 <Deformative-II> nonsense I think it should be too.
17:15:35 <dcoutts__> Igloo: but cabal doesn't call cygwin
17:15:51 <Igloo> dcoutts__: I mean my shell is a cygwin shell
17:15:54 <Deformative-II> It can not be compiled to binary,  it is compiled to bitcode or whatever, t hen that is run through an interpereter.
17:15:59 <dcoutts__> Igloo: does that file exist normally, ouside of cygwin, eg from a cmd.exe shell?
17:16:23 <dcoutts__> or is there some funny cygwin path mapping going on?
17:16:28 <dons> Deformative-II: to start learning haskell, visit haskell.org and start on the 'learning in 5 steps' tutorial
17:16:32 <lispy> Deformative-II: learning haskell is generally considered worth the effort
17:16:44 <Deformative-II> I just need something i can follow the java class along in,  just on my free time at homw.
17:16:58 <Deformative-II> I am afraid that haskell will be too difficult and I will fall behind the class.
17:17:00 <dons> learning the basics should be pretty easy. its taught as a beginner-programmer's language
17:17:09 <Igloo> (why is it that every time I log in to Windows there are a pile of Application Error dialogs waiting for me?)
17:17:16 <dcoutts__> hah hah
17:17:19 <dons> heh
17:17:26 <Igloo> It won't even tell me which application
17:17:30 <Deformative-II> Well, I have the same thing on linux.  =(
17:17:33 <mauke> dude, your "binaries" are byte code that's interpreted by the CPU
17:17:34 <Deformative-II> Pypanel hates me.
17:17:46 <Deformative-II> mauke,  I know,  and i like that.
17:18:20 <Igloo> dcoutts__: Hang on a tick, I'm getting confused here
17:18:26 <dcoutts__> ok
17:18:34 <monochrom> I have an odd feeling that I don't want Deformative-II to learn Haskell.  God forbid one day he/she will assert " sin (x+y) + cos (x+y) must/cannot be optimized to evaluate x+y just once ".
17:18:41 <emu> am i using random correctly when i do: main = do n <- getStdRandom(randomR(1,10)); print n
17:19:13 <Igloo> OK, the problem isn't that it doesn't think it exists, it's that it's a bash script
17:19:16 <Deformative-II> I am in trig...
17:19:27 <dcoutts__> Igloo: ah, heh
17:19:52 <dcoutts__> Igloo: not my fault then? :-)
17:20:07 <dcoutts__> Igloo: are you trying to get ghc to build under cygwin again?
17:20:22 <dcoutts__> rather than mingw
17:20:32 <Deformative-II> Ehh,  I suppose I can just use python.
17:20:56 <dcoutts__> Deformative-II: try the 5 step intro, you'll see if you like it
17:21:06 <dcoutts__> it's not hard to learn
17:21:06 <Igloo> dcoutts__: I'm trying to work out if/how this is meant to work
17:21:42 <dcoutts__> Deformative-II: I teach it to people as their first ever programming language and also to people who've coded a lot before
17:22:05 <dcoutts__> Deformative-II: they're usually doing pretty well with it after a couple months
17:22:18 <Deformative-II> Hmm.
17:22:22 <dcoutts__> writing quite interesting programs
17:22:24 <Deformative-II> I hope this is worth it.
17:22:31 <Deformative-II> =)
17:22:45 <dcoutts__> it's usually worth it to know more programming languages
17:22:50 <mauke> guaranteed satisfaction or your money back
17:22:51 <Deformative-II> Then after I learn the basics of haskel,  go to python,  then to C, then maybe to lisp.
17:22:54 <StoneNote> learning is always worth it.  but you can never tell which thing you've learned is worth it at the time.
17:22:59 <dcoutts__> especially more different ones
17:23:42 <dcoutts__> Deformative-II: personally I find the combination of C and Haskell covers most things
17:23:56 <dcoutts__> C for really low level and Haskell for everything else
17:24:10 <mauke> perl for every-day tasks
17:24:18 <dcoutts__> I don't see a niche for Python inbetween the two
17:24:19 <Deformative-II> But python is fast and easy.
17:24:26 <Igloo> dcoutts__: Do you know how cabal will be trying to call GHC?
17:24:27 <Deformative-II> And lisp is uneque.
17:24:33 <Deformative-II> Or so I hear.
17:24:42 <Deformative-II> So I figured those 4 would be a good combo.
17:24:44 <mauke> C and Haskell suck for quick command line scripts
17:24:54 <monochrom> @hoogle getStdRandom
17:24:54 <lambdabot> Random.getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
17:24:55 <dcoutts__> Deformative-II: Haskell is like lisp, only with 30 extra years of research
17:25:02 <dons> I use haskell for my command line scripts, once loc > 10
17:25:04 <monochrom> emu: I think yes.
17:25:11 <dons> dcoutts__: I was going to say 40 years
17:25:23 <Deformative-II> Hmm, I dunno.
17:25:24 <mauke> dons: whoa, you have a multiline input shell thingy?
17:25:40 <Deformative-II> I know I will learn the first 3.
17:25:45 <Deformative-II> I am not sure about lisp.
17:26:38 <dons> mauke: ?
17:26:51 <dolio> Lisp is good to learn. Or, scheme at least.
17:26:59 <dolio> An exercise in minimalism.
17:27:05 <mauke> my shell uses a single-line input buffer
17:31:21 <Deformative-II> How do you exit the haskell interpereter?
17:31:46 <mauke> I signal end-of-file
17:32:09 <sjanssen_> Deformative-II: :q
17:32:35 <kfish> dons: do you have some examples of command line scripts in haskell?
17:32:51 <dons> kfish: you mean small programs to do system-ish stuff?
17:33:26 <Deformative-II> end-of-file?
17:33:33 <Deformative-II> Hmm.
17:33:40 <dons> there are some unix-shell-syntax libs, but I tend not to use them.
17:33:43 <kfish> dons: well, yeah, like you mentioned -- would make an intersting howto or wiki page ;-)
17:33:59 <monochrom> Children who grew up with Windows know not end-of-file or signal.
17:34:11 <dons> oh, it hardly needs a howto does it? you just write the code :)
17:34:28 * dons finds some programs that once were shell scripts
17:34:29 <mauke> Deformative-II: yeah, that's ctrl-d on unix and ctrl-z on windows
17:34:50 <Deformative-II> Odd... I tired control d a minute ago.
17:34:57 <Deformative-II> And it didn't work then.
17:34:58 <sjanssen_> or you could just use ctrl-z on both
17:34:59 <Deformative-II> But works now.
17:35:07 <sjanssen_> and get confused when you run out of RAM
17:35:08 <kfish> dons: heh
17:35:23 <dons> here http://www.cse.unsw.edu.au/~dons/code/progress/progress.hs , http://www.cse.unsw.edu.au/~dons/code/darcs-graph/Graph.hs and http://www.cse.unsw.edu.au/~dons/code/darcs-mail/Main.hs
17:36:04 <dons> I find that the haskell versions seem to be a lot more stable than the shell scripts used to be
17:36:20 <dons> they keep working for years, rather than breaking when some sed regex fails :)
17:36:23 <monochrom> The next confusion will be: "I wrote a program to read a file.  I made it read until it sees ctrl-d.  It didn't work."
17:38:18 <Deformative-II> Nah, I will not use that interpereter thing, I like compiling a .hs file, I can do that all the time,  correct?
17:38:29 <dcoutts__> you can
17:38:41 <dcoutts__> but ghci/hugs can be very helpful for development
17:38:49 <dcoutts__> giving you instant feedback and testing
17:39:14 <dcoutts__> ghci is not strictly an interpreter either
17:39:31 <Deformative-II> Well right now i am confertable with text files.
17:39:34 <dcoutts__> you can compile your .hs modules to .o files and then load those in ghci
17:39:36 <Deformative-II> I like vim.
17:39:51 <shapr> I like vim. And Emacs. And nano.
17:39:59 * shapr boings
17:40:05 <Deformative-II> I hardly used emacs.
17:40:10 <Deformative-II> For like a day.
17:40:24 <dcoutts__> Deformative-II: so you can test out your code at full comiled speed in ghci
17:40:27 <dons> kfish: oh here's a good one,  http://www.cse.unsw.edu.au/~dons/code/hwn/utils/wikify.lhs and also http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs
17:40:56 <dons> both were nasty shell scripts to automate publishing the weekly news - now they're not so nasty
17:42:31 <dons> hehe, /me sees         run $ "xterm -e vim -o " ++ txtfile ++ " " ++ txtfile
17:42:58 <monochrom> Is that your IDE script? :)
17:43:01 <dons> looks like haskell shell scriptery...
17:43:20 <dons> heh .no. its when publishing the HWN, it launches an editor, for me to check spelling
17:43:45 <mauke> I hope txtfile is properly escaped
17:43:48 <Deformative-II> VIm has spell check?
17:44:59 <Deformative-II> There is no step 4 or 5.
17:45:12 <Deformative-II> But it seems a whole lot better than java.
17:45:26 <dolio> Heh.
17:45:27 <dons>   * 4 Where to go from here
17:45:28 <dons>   * 5 Get help
17:45:58 <Deformative-II> Oh.
17:46:01 <dons> * 6 Can't find steps 4..5, see step 5.
17:46:12 <Deformative-II> There is no number 4.
17:46:15 <Deformative-II> Just the step.
17:46:45 <kfish> dons: cheers -- http://bother.kfish.org/wiki/HaskellShellScripts
17:46:47 <lambdabot> Title: HaskellShellScripts - kfish - Trac, http://tinyurl.com/gkye8
17:46:57 <Deformative-II> This isn't haskell version 98 is it?
17:47:15 <dmwit> It's Haskell, the 1998 version. ;-)
17:47:17 <dons> kfish: cool. should go on the haskell wiki :)
17:47:27 <dmwit> Or were you referring to the link?
17:47:29 <dons> we could keep an archvie of these. seems useful.
17:47:34 <kfish> dons: hah, now you think it's worthwhile ;-)
17:47:39 <Deformative-II> Why was a new version not released since 98?
17:47:42 <dons> since the code is usually just quickly hacked up, it never gets published
17:47:53 <dons> however, there are some useful lessons
17:47:54 <Deformative-II> Is development done?  I thought it was a new language.
17:48:03 <dmwit> There's all kinds of glasgow-extensions.
17:48:03 <dons> Deformative-II: heh.
17:48:12 * emu is amused
17:48:13 <dons> Deformative-II: http://www.haskell.org/ghc
17:48:16 <lambdabot> Title: The Glasgow Haskell Compiler
17:48:39 <dons> language definition /= implementation
17:49:04 <dons> 2006-09-08: "Haskell is Done."
17:50:03 <Deformative-II> Uhh, then why is it called haskell 98?
17:50:26 <dons> one version of the core language was standardised in 1998
17:50:26 <sjanssen_> Deformative-II: that's when the language standard was finished and published
17:50:35 <Deformative-II> And another question is why is it called haskell, is it related to paskell somehow?
17:50:42 <emu> lol i always hear that
17:50:48 <emu> "what? you are talking about PASCAL!?!"
17:50:50 <sjanssen_> @google haskell b curry
17:50:55 <lambdabot> http://www-history.mcs.st-andrews.ac.uk/Mathematicians/Curry.html
17:50:55 <lambdabot> Title: Curry summary
17:51:08 <emu> i've tried to find a pronunciation of Haskell which doesn't sound like Pascal
17:51:10 <dons> Deformative-II: go to haskell.org, click on 'Research papers' , read "The History of Haskell"
17:51:15 <sjanssen_> Deformative-II: Haskell Curry was a mathemetician
17:51:31 <Deformative-II> Oh.
17:51:34 <Deformative-II> Alright.
17:51:51 <kfish> emu: better to find a pronunciation of Pascal that doesn't sound like Haskell
17:51:52 <sjanssen_> emu: me too.  I hate it when I talk about this awesome language and people think I'm talking about Pascal
17:52:17 <dmwit> The trick is to accent the first syllable.
17:52:20 <heatsink> yea, that's happened to me.
17:52:32 <dmwit> Rhyme it with rascal. ;-)
17:52:36 <heatsink> I do that.
17:52:40 <emu> i've tried everything
17:52:49 <sjanssen_> stuttering might help
17:52:54 <sjanssen_> huh huh huh haskell
17:52:59 <emu> they still think it's pascal, even if i say "ASkell
17:53:30 <dmwit> Or you could call it Butterfly...
17:53:38 <Limbic_Region> haskell, not to be confused with the lesser pascal, is my programming language of choice
17:53:46 <monochrom> You seriously need to decouple "language" from "that thing I run to execute things written in language".
17:54:03 * Pseudonym invents a language called Askill just to confuse things
17:54:10 <Limbic_Region> just get in the habit of noting the difference before someone can make the mistake
17:54:26 <dons> Ascal
17:54:28 <Pseudonym> monochrom: -fglasgow-exts confuses the issue even further.
17:54:37 <emu> monochrom: people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference, sadly
17:55:00 <dons> ?remember emu  people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
17:55:05 <Pseudonym> Perl 6 is, thankfully, being designed by specification.
17:55:43 <Limbic_Region> emu - yes, when making that characertization of Perl - please indicate Perl 5
17:55:44 <heatsink> We can call the language "Glasgow"
17:56:03 <monochrom> Glasgell anyone? :)
17:56:05 <dons> perl6++
17:56:09 <Pseudonym> Or we can pick yet another mathematician who wouldn't have approved.
17:56:18 <Pseudonym> I vote for Schoenfinkel
17:56:28 <Pseudonym> Nobody will confuse that with Pascal.
17:56:28 <emu> i suppose; perl is forever tarnished in my mind, regardless of version :/
17:57:01 <dons> I agree, Schoenfinkel forever.
17:57:32 <Pseudonym> Jean-Yves Girard is, unfortunately, still alive.
17:57:33 * sjanssen_ /join #schoenfinkel
17:57:48 <Pseudonym> It's not unfortunate for him, obviously.
17:57:54 <dmwit> Jean-Yves 5 is alive??
17:57:56 <Limbic_Region> not sure Jean-Yves Girard thinks it is unfortunate
17:58:04 <Pseudonym> But it means we can't hame a language after him because he might complain.
17:58:07 <Pseudonym> name
17:58:22 <emu> the estate could still complain
17:58:47 <Pseudonym> emu: Have you read the history of Haskell paper?
17:58:48 <dons> shapr: oh nice, oh trolling friend was here 3 times this week, throwing the channel off as usual
17:58:56 <emu> i was just wondering about that, rofl
17:59:12 <Pseudonym> Simon PJ et al asked Haskell Curry's widow permission to use his name.
17:59:18 <Pseudonym> And she confided that he never actually liked his name.
17:59:21 <dons> shapr: 13:38:27 <ramserver> so why would one prefer haskell to say clisp or smalltalk? *sigh*
17:59:49 <dmwit> Sounds like something I've heard before...
17:59:50 <dmwit> @proton
17:59:50 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
17:59:50 --- mode: ChanServ set +o dons
18:00:03 <Pseudonym> At least he picked a couple of half-decent languages to troll about.
18:00:28 <ObviousTroll> so why would one prefer haskell to, say, ap/l or logo?
18:01:29 <sjanssen_> Haskell will be as cool as Logo as soon as we have instance Monad Turtle
18:02:03 <heatsink> Can turtles be unboxed?
18:02:13 <monochrom> We need a lambdabot plugin to detect this particular troll.
18:02:31 <Pseudonym> @keal
18:02:32 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
18:02:41 <vincenz> @proton
18:02:41 <lambdabot> why haskell over say smalltalk
18:02:44 --- mode: dons set +b *!*@4.38.41.141
18:02:49 <Pseudonym> There you go.
18:02:54 <int-e> data Turtle a = Turtle; instance Monad Turtle where _ >>= _ = Turtle; return _ = Turtle.
18:02:58 <monochrom> w00t!  Logo!
18:02:59 --- mode: ChanServ set -o dons
18:03:18 <dons> ok, so that stops his current ip address. but he seems to change every couple of weeks ..
18:03:38 <monochrom> Where can I learn Logo?
18:03:56 <Pseudonym> Logo was actually designed for AI.
18:04:02 <emu> Logo is apparently a Lisp
18:04:03 <Pseudonym> The turtle stuff is all robotics.
18:04:14 <Pseudonym> Yeah, I think the first implementations were in Lisp.
18:04:15 <emu> though I never investigated further
18:04:17 <Pseudonym> And borrowed heavily.
18:04:21 <Pseudonym> It's got lists and atoms.
18:04:49 <shapr> dons: Hey, keep up the good work.
18:05:27 <Pseudonym> 17:02:03 <ramserver> well i know 0 pogramming but would love to have my own biz doing websies on happs for people
18:05:34 <shapr> dons: Oh wait there's more:
18:05:34 <Pseudonym> I think he meant pogromming
18:05:56 <dmwit> Whoa, pogromming, how dictatorial.
18:05:58 <shapr> dons: From: "gavino" <bootiack@yahoo.com> \n To: "HAppS" <HAppS@googlegroups.com> \n I am just beginning to learn progrmaming and haskell is my frist thing after some basic bash programming. I think it has huge potential, and am ignoring java people who say Im crazy.
18:06:25 <dons> freakky
18:06:32 <monochrom> that's the same troll?
18:06:37 <shapr> I betcha 5 karma it is.
18:06:42 <dons> yep, he used 'gavino' in here
18:06:48 <dmwit> @karma shapr
18:06:48 <lambdabot> shapr has a karma of 21
18:06:49 * shapr uses the #haskell currency to bet
18:07:06 <monochrom> wow 5 karma.  I have just 5 karma.  You're asking me to be all-in. :)
18:07:10 <Pseudonym> Actually...
18:07:26 <Pseudonym> That'd be a good plugin if someone wants to have a go at learning how to write one.
18:07:32 <emu> i wonder if perhaps the various prog lang newsgroup, mailing list, and irc trolls i've seen over the years are just one or a very few people
18:07:40 <dons> Pseudonym: what's that?
18:07:45 <Pseudonym> Allow bets to be placed.
18:07:49 <dons> ah yes
18:07:51 <dons> that'd be fun
18:07:53 <Igloo> monochrom: Careful - if you run out of karma you have to leave and go join #java instead
18:08:03 * monochrom sobs
18:08:06 <emu> dire consequences
18:08:19 <monochrom> #java is just too poker-faced and not fun.
18:08:19 <Pseudonym> <shapr> ?bet dons 5 That's the same guy.
18:08:25 <shapr> hah
18:08:35 <shapr> Igloo: scary!
18:08:41 <Pseudonym> Then you can ?accept-bet or ?reject-bet
18:08:44 <shapr> That would rock
18:08:57 <dons> shapr: see the bottom of here for a list of his ips and names: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
18:08:59 <shapr> Pseudonym: But you'd have to specify an arbiter nick when you place the bet.
18:09:03 <Pseudonym> Right.
18:09:06 <vincenz> Pseudonym: how do you validate a bet?
18:09:06 <shapr> Someone who could judge the results.
18:09:18 <Pseudonym> vincenz: Like shapr says, you nominate a neutral arbiter.
18:09:27 <vincenz> roll of dice :)
18:09:30 <vincenz> karma-poker
18:09:48 <vincenz> @hoogle ranomd
18:09:48 <lambdabot> No matches found
18:09:49 <vincenz> > randomR
18:09:50 <lambdabot>  Add a type signature
18:09:52 <Pseudonym> ?roshambo scissors
18:09:52 <vincenz> > randomR :: Int
18:09:53 <lambdabot>    Expecting a function type, but found `Int'
18:09:53 <lambdabot>    Expected type: Int
18:09:53 <lambdabot>   ...
18:09:53 <lambdabot> Unknown command, try @list
18:10:06 <vincenz> > randomR 1
18:10:07 <lambdabot>  add an instance declaration for (Num (a, a))
18:10:15 <vincenz> > randomR (1,1)
18:10:16 <lambdabot>  Add a type signature
18:10:19 * vincenz smacks
18:10:22 <Pseudonym> Actually...
18:10:24 <jrmole> vincenz, it wants a RandomGen
18:10:24 <monochrom> Eh, need help with randomness?
18:10:26 <Pseudonym> ?rochambeau scissors
18:10:27 <lambdabot> Unknown command, try @list
18:10:30 <Pseudonym> Let's spell it right.
18:10:41 <jrmole> @type randomR
18:10:42 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:10:46 <dmwit> @ro
18:10:46 <lambdabot> Maybe you meant: . arr bf id pl redo run url v wn yow
18:10:54 <jrmole> @help dice
18:10:55 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
18:11:02 <emu> > do print(getStdRandom(randomR(1,6)))
18:11:03 <lambdabot>  No IO allowed
18:14:41 <dons> ?users
18:14:45 <lambdabot> Maximum users seen in #haskell: 232, currently: 205 (88.4%), active: 32 (15.6%)
18:14:52 <vincenz> @@dic 1d4
18:14:54 <vincenz> @dic 1d4
18:14:55 <lambdabot> Maybe you meant: dice dict dict-help
18:15:04 <vincenz> @dice 10000d10000
18:15:04 <lambdabot> 10000d10000 => 49568289
18:15:09 <vincenz> pretty fast
18:15:15 <vincenz> @dice 10000000d1
18:15:15 <lambdabot> 10000000d1 => 10000000
18:15:21 <vincenz> @dice 10000000000d2
18:15:22 <lambdabot> 10000000000d2 => 14999991550
18:15:40 <johnnowak> @dice 6d6
18:15:40 <lambdabot> 6d6 => 17
18:15:45 <vincenz> honestly
18:15:48 <vincenz> how can it be so fast?
18:15:56 <vincenz> I doubt it actually rolls that many times..
18:16:52 <emu> pseudorandom number generation isn't that slow
18:16:59 <vincenz> still
18:17:04 <vincenz> 10G rolls
18:17:11 <vincenz> in < 1 sec
18:17:35 <Pseudonym> I assume the RNG isn't that good.
18:18:02 <dolio> Lambdabot is actually running on a Cray.
18:18:10 <vincenz> dons: explanations?
18:18:11 <dons> its pretty good. not far from the mersenne twister, at least in one project i used
18:18:17 <dons> in terms of quality
18:18:28 <vincenz> dons: how do you calculate rolling?
18:18:32 <dons> vincenz: compiled plugins are fast?
18:18:38 <vincenz> 10G rolls???
18:18:50 <vincenz> @dice 100000000000d2
18:18:50 <lambdabot> 100000000000d2 => 149999996070
18:18:52 <vincenz> 100G rolls
18:19:08 <dons> here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Dice.hs
18:19:25 <sjanssen_> > sum $ take  randomRs (1, 2) $ mkStdGen 1
18:19:26 <lambdabot>    Expecting a function type, but found `[a]'
18:19:26 <lambdabot>    Expected type: a -> b
18:19:26 <lambdabot>  ...
18:19:30 <vincenz> ah, hehe :P
18:19:40 <vincenz> if n > 100
18:19:58 <dons> right
18:19:59 <sjanssen_> > sum $ take 100000000000 $ randomRs (1, 2) $ mkStdGen 1
18:20:03 <lambdabot> Terminated
18:20:54 <vincenz> dons: that isn't cheating?
18:21:23 <vincenz> @dice 100d100
18:21:23 <lambdabot> 100d100 => 5250
18:21:25 <vincenz> @dice 101d100
18:21:25 <lambdabot> 101d100 => 5001
18:22:15 <dons> THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''... :)
18:22:23 <vincenz> :D
18:22:26 <dons> so take it up with the regents ;)
18:22:40 <vincenz> btw, are all plugins run in the 3second box?
18:22:46 <vincenz> or only @eval?
18:23:26 <dons> only eval. others get a 15second thread, + network timeouts
18:23:38 * vincenz nods
18:24:27 <vincenz> I wonder where that algo came from
18:27:59 <dons> @tell Lemmih we need to get JaffaCake to fill out his SoC survey. so if you see him can you ask?
18:27:59 <lambdabot> Consider it noted.
18:28:01 <vincenz> http://www.sciam.com/article.cfm?chanID=sa003&articleID=00039FCD-5294-1500-929483414B7F0000&ref=rss
18:28:04 <lambdabot> Title: Science &amp; Technology at Scientific American.com: Quantum Entanglement Demons ..., http://tinyurl.com/lyodx
18:28:30 <Cale> heh "Demons"
18:29:20 <vincenz> lol
18:30:59 <dolio> Geeze. CSS popups.
18:31:45 <dons> sjanssen++ -- zip/append fusion!
18:32:27 <Cale> dolio: CSS popups?
18:32:38 <dolio> On the scientific american site.
18:32:46 <Cale> where?
18:32:49 * lispy just spent the last day or so creating a layout combinator library for spreadsheet cells and now wonders if it will be even remotely useful :)
18:33:10 <dolio> The first time I opened it, it popped up some survey.
18:33:14 <Cale> huh
18:33:22 <lispy> if nothing else my haskell-fu is improved, but...not sure if it was time well spent :)
18:33:33 <Cale> I run everything through privoxy, which tends to filter out a lot of crap like that :)
18:34:06 <dolio> It doesn't seem to be doing it anymore. It must be random or something.
18:35:12 <sjanssen_> dons: my next plan is to make pack and unpack friendly with GHC's foldr/build fusion
18:35:24 <dons> that'd be really nice, if you can work that out.
18:35:30 <dons> also, concatMap
18:35:43 <dons> if we can fuse concatMap, thta helps out streams-for-[a] fusion
18:35:54 <dons> since things like Monad [a] depend on a good concatMap
18:37:09 <dcoutts__> sjanssen, unpack can be done with build, but pack can't be done wit foldr
18:37:29 <dcoutts__> so it can only be friendly with foldr/build fusion on the unpack side
18:40:06 <Limbic_Region> yay, compile from source on Win32 took less than 2 hours
18:40:28 <Limbic_Region> that is of course after I spent all day trying to figure out how to compile it correctly
18:45:20 <Limbic_Region> except ld.exe and friends aren't found :-(
18:48:46 <Limbic_Region> oh, it just probed GccDir wrong - easily fixed
18:58:25 <Korollary> shapr back in the US?
19:01:11 <Cale> hehe: "I'm a bastard. I have absolutely no clue why people can ever think otherwise. Yet they do. People think I'm a nice guy, and the fact is that I'm a scheming, conniving bastard who doesn't care for any hurt feelings or lost hours of work, if it just results in what I consider to be a better system." - Linus Torvalds
19:01:44 <Korollary> That doesn't make you a bastard.
19:02:04 <Korollary> I can't stand wannabe bastards.
19:02:10 <Pseudonym> Linus is a meritocrat.
19:02:16 <Pseudonym> A fundamentalist one.
19:03:28 <Korollary> I went to one of his seminars.
19:03:41 <Korollary> He didn't come across a good speaker.
19:04:51 <sjanssen_> lisppaste2: url
19:04:51 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:04:59 <Pseudonym> I'm not surprised.
19:05:04 <Pseudonym> Most geeks don't make good speakers.
19:05:12 <Pseudonym> There are exceptions.  Larry Wall is brilliant.
19:05:38 <Korollary> Knuth was good.
19:05:59 <Korollary> Paul Graham is decent.
19:06:05 <Korollary> Joel Spolsky is good.
19:06:21 <vincenz> anyone know how to make parsec work on newlines specially?
19:06:22 <vincenz> for some raeson
19:06:28 <vincenz> "space" counts \n as one of it
19:06:49 <vincenz> > skipMany space "   b"
19:06:50 <lambdabot>  Not in scope: `space'
19:06:51 <lisppaste2> sjanssen_ pasted "fusible pack . . . I think" at http://paste.lisp.org/display/25623
19:06:55 <CrewdenX> Korollary: he didn't die on us did he?
19:06:56 <Pseudonym> RMS is a good speaker, but if you've seen one RMS talk you've seen them all.
19:07:34 <Pseudonym> Had Knuth died, we'd have heard about it.
19:07:57 <sjanssen_> dons, dcoutts__: what do you think of that?
19:08:34 <Korollary> CrewdenX: Oh, I didn't mean to imply that.
19:08:36 <vincenz> anyone know something like space that doesn't skip newlines?
19:09:17 <dcoutts__> sjanssen, hmm interesting. does it work?
19:09:58 <sjanssen_> don't know yet, working on that
19:10:31 <dcoutts__> use newtype
19:10:33 <Philippa> vincenz: space really means "whitespace"
19:10:40 <Philippa> build your own?
19:10:41 <dcoutts__> sjanssen, for StepStep
19:10:54 <Philippa> it's not hard
19:11:15 * vincenz whnes
19:11:17 * vincenz whines
19:11:19 <vincenz> oh well
19:11:24 <sjanssen_> dcoutts__: not using newtype is intentional.  Otherwise the strictness on the fields in Step force the whole list
19:11:25 <vincenz>   do_lex $ many $ noneOf ["\n"]
19:11:35 <dcoutts__> sjanssen_: oh, ok
19:12:19 <dcoutts__> sjanssen_: do you need the explict type on f in the rule? that's implicit from (build f) isn't is?
19:13:50 <dcoutts__> sjanssen_: I don't understand why the non-strictness is required there
19:13:59 <sjanssen_> dcoutts__: yeah, GHC says I do
19:14:06 <dcoutts__> oh ok
19:16:23 <sjanssen_> with the strictness you end up with a chain of Yields that are each tail strict
19:16:45 <dcoutts__> mm
19:17:04 <dcoutts__> pehaps Yield should not be strict in the !s, like it is now
19:17:44 <dcoutts__> ah yes
19:18:08 <dcoutts__> the function passed to g in (build g) can't be tail strict
19:18:13 <dcoutts__> we had that bug before
19:18:20 <dcoutts__> it breaks build/fold fusion
19:18:41 <dcoutts__> as in when the function is tail strict, then  build/fold fusion is actually no longer true!
19:18:55 <sjanssen_> that and it'd totally defeat the point of fusion, because the whole data structure would be forced into memory
19:19:15 <dcoutts__> right
19:19:23 <dcoutts__> but perhpas you can just suspend the s
19:19:29 <dcoutts__> not the yield too
19:19:40 <glguy> > [1..3] >> "duplicate test "
19:19:41 <lambdabot>  "duplicate test duplicate test duplicate test "
19:20:35 <vincenz> > "abc" >> "hello "
19:20:36 <lambdabot>  "hello hello hello "
19:20:37 <dcoutts__> sjanssen_: something like: (\w ~(Suspend s) ->Yield w (Suspend s))
19:20:42 * vincenz snickers
19:21:18 <sjanssen_> @pl replicate n c = enumFromTo 1 n >> return c
19:21:18 <lambdabot> replicate = (. return) . (>>) . enumFromTo 1
19:21:33 <sjanssen_> @type (. return) . (>>) . enumFromTo 1
19:21:35 <lambdabot> forall b a. (Enum a, Num a) => a -> b -> [b]
19:21:46 <vincenz> @type sjanssen_ >> insane
19:21:47 <lambdabot> Not in scope: `sjanssen_'
19:21:47 <lambdabot>  
19:21:47 <lambdabot> <interactive>:1:13: Not in scope: `insane'
19:22:04 <Cale> > "myj" >>= (:"ello ")
19:22:05 <lambdabot>  "mello yello jello "
19:22:47 <mlh> > "myjf" >>= (:"ello")
19:22:48 <lambdabot>  "melloyellojellofello"
19:22:53 <vincenz> +w
19:23:58 <vincenz> "myjfc" >>= (:"ello")
19:24:20 <glguy> is there a cleaner way to do this:
19:24:21 <glguy> setsOf 0 _ = [[]]
19:24:21 <glguy> setsOf (n+1) xs = concat [map (y:) (setsOf n ys) | (y:ys) <- tails xs]
19:24:46 <weitzman> Slightly offtopic: Anyone know of a resource on a net with a summary of the typing rules / operational semantics for F(omega)?
19:25:28 <vincenz> > tails [1,2,3]
19:25:30 <lambdabot>  [[1,2,3],[2,3],[3],[]]
19:25:33 <vincenz> erm
19:25:39 <vincenz> oh concat
19:26:28 <sjanssen_> dcoutts__: is Suspend a newtype in that case?
19:26:46 <dcoutts__> sjanssen_: no, much like your current StepStep
19:26:47 <vincenz> glguy: seems to be a strange way of doing it
19:27:20 <dcoutts__> sjanssen_: but the idea is to suspend slightly less, so it might optimise better
19:27:40 <dcoutts__> in particualr the Yield & Done could hopefully be eliminted
19:27:46 <sjanssen_> makes sense
19:28:00 <dcoutts__> which I suspect would not be possible with lazily suspened ones
19:28:04 <dcoutts__> but not 100% sure
19:28:12 <glguy> vincenz: what would be a normal way
19:29:03 <glguy> my original solution used do notations (and not concat), but I wanted to put it on one line for the channel
19:29:11 <glguy> to keep from having to use a paste page
19:29:26 <vincenz> glguy:
19:29:29 <vincenz> you're mapping (y:)
19:29:38 <vincenz> so you're adding a list as an element to the setsof?
19:29:44 <vincenz> to each element of setsof??
19:30:19 <glguy> > let setsOf 0 _ = [[]] ; setsOf (n+1) xs = concat [map (y:) (setsOf n ys) | (y:ys) <- tails xs] in setsOf 2 [1..4]
19:30:20 <lambdabot>  Parse error in pattern
19:30:35 <dolio> ?undo do { (y:ys) <- tails xs ; map (y:) (setsOf (n-1) ys) }
19:30:36 <lambdabot> tails xs >>= \ a -> case a of { (y : ys) -> map (y :) (setsOf (n - 1) ys); _ -> fail ""}
19:30:59 <emu> > [1..3] >>= (:[]) . (+1)
19:31:00 <dolio> ?pl setsOf n xs = tails xs >>= \ a -> case a of { (y : ys) -> map (y :) (setsOf (n - 1) ys); _ -> fail ""}
19:31:00 <lambdabot>  [2,3,4]
19:31:01 <lambdabot> (line 1, column 45):
19:31:01 <lambdabot> unexpected "{"
19:31:01 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
19:31:29 <glguy> > let setsOf 0 _ = [[]] ; setsOf n xs = concat [map (y:) (setsOf (n-1) ys) | (y:ys) <- tails xs] in setsOf 2 [1..4]
19:31:30 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
19:31:47 <glguy> lambdabot: doesn't like n+1 notation :)
19:32:15 <dolio> ?pl setsOf n xs = tails xs >>= \(y:ys) -> map (y:) (setsOf (n-1) ys)
19:32:16 <lambdabot> setsOf = fix ((flip ((>>=) . tails) .) . flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . map . (:))) .) . (. subtract 1))
19:32:24 <dolio> Ooo.
19:32:24 <emu> > liftM2 [1..3] [1..3]
19:32:25 <lambdabot>  Couldn't match `a1 -> a2 -> r' against `[a]'
19:32:26 <glguy> yeah... that's clearer :-p
19:32:38 <vincenz> boobies
19:32:53 <glguy> emu: looking for sequence (replicate n xs) ?
19:34:28 <vincenz> glguy: I don't see how it works tho
19:34:30 <vincenz> map (y:)
19:34:34 <glguy> > let setsOf 0 _ = [[]] ; setsOf n xs = do { (y:ys) <- tails xs; map (y:) (setsOf (n-1) ys) } in setsOf 2 [1..4]
19:34:35 <vincenz> y is [3,2,1]
19:34:36 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
19:34:38 <vincenz> if you start with three lists
19:35:26 <newsham> is there public code that transforms haskell (even some small subset of haskell) into lambda calculus?
19:36:00 <emu> hmm
19:36:02 <emu> yea
19:36:11 <emu> wonder why i keep thinking of liftM2
19:36:28 <glguy> vincenz: right, y is 1 then 2 then 3
19:36:32 <glguy> but not all at the same time
19:36:36 <vincenz> and ys?
19:36:59 <emu> oh yea
19:37:00 <glguy> ys is [2,3] then [3]
19:37:05 <emu> > liftM2 (+) [1..3] [1..3]
19:37:07 <lambdabot>  [2,3,4,3,4,5,4,5,6]
19:37:09 <vincenz> yeah it makes noe sense
19:37:26 <vincenz> for the second ys you'd expect shorter results
19:37:52 <glguy> second ys?
19:38:01 <vincenz> nm
19:38:20 <vincenz> > let setsOf 0 _ = [[]] ; setsOf n xs = do { (y:ys) <- tails xs;
19:38:20 <lambdabot>  Parse error
19:38:30 <vincenz> > let setsOf 0 _ = [[]] ; setsOf n xs = do { (y:ys) <- tails xs; map (y:) (setsOf (n-1) ys) } in setsOf 5 [1..10]
19:38:32 <lambdabot>  [[1,2,3,4,5],[1,2,3,4,6],[1,2,3,4,7],[1,2,3,4,8],[1,2,3,4,9],[1,2,3,4,10],[1...
19:38:33 <shapr`> wargh!
19:38:51 <shapr> Korollary: yup
19:39:16 <sjanssen_> dcoutts__: maybe this is better: data ListWord8 = Cons !Word8 ListWord8 | Nil
19:39:41 <glguy> > [[a,b] | a <- [1..4], b <- [a+1..4]] -- Simple case
19:39:42 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
19:39:47 <shapr> We need a programmer methodolgy movie. Let's call it Office Whitespace.
19:39:54 <dcoutts__> sjanssen_: I don't follow, where would that be used?
19:40:01 <dylan>     +K true|false
19:40:01 <shapr> Maybe that would be a movie about programmer religious issues?
19:40:01 <dylan>     Enables or disables the kernel poll functionality if the emulator has kernel poll support. By default the kernel poll; functionality is disabled. If the emulator doesn't have kernel poll support and the +K flag is passed to the emulator, a warning is issued at startup.
19:40:09 <dylan> err
19:40:10 <dylan> ignore that
19:40:15 <dylan> and blame my touch pad.
19:40:18 <newsham> shapr: The Bourne Shell Identity?
19:40:19 * shapr pretends not to see that
19:40:23 <sjanssen_> dcoutts__: I'll just write the code and it'll be obvious
19:40:24 <shapr> newsham: oh, cute!
19:40:25 <vincenz> glguy: my point is, if you select a ys that is short enough.... you might not have enough to pass to the next recursion of setsOf
19:40:29 <dcoutts__> sjanssen_: ok :-)
19:40:39 <dylan> the /bin/sh identity function?
19:40:54 <glguy> vincenz: if ys is too short, it stops
19:41:05 <newsham> C No Evil?
19:41:09 <vincenz> glguy: yeah but since you're selecting from tails, you could end up with a really short tails
19:41:15 <glguy> vincenz: that's the idea
19:41:22 <vincenz> ah
19:41:33 <glguy> the results list should contain unique combinations
19:42:10 * vincenz still thinks there should be a better way
19:42:20 <vincenz> basically you have a lot of failure cases
19:42:21 <newsham> Exit in 60 milliseconds?
19:42:23 <glguy> I think I could do this with a replicateM somehow
19:43:38 <vincenz> heh
19:43:51 <newsham> Sex Lies and Magtapes?
19:47:19 <lisppaste2> sjanssen annotated #25623 with "fusible pack try 2" at http://paste.lisp.org/display/25623#1
19:47:33 <Tela> Computer Science Theatre 101110111000
19:49:09 <sjanssen_> dcoutts__: that code builds a head strict list instead of futzing around with the Yield Suspend stuff
19:50:23 <newsham> > sum [2** (fromIntegral n) | ('1',n) <- zip "101110111000" [0..]]
19:50:25 <lambdabot>  477.0
19:50:28 <dcoutts__> sjanssen_: ok, but now there's no fusion
19:50:41 <dcoutts__> oh hmm
19:51:07 <newsham> hmm, I got it backwards
19:51:13 <glguy> @index fixM
19:51:13 <lambdabot> bzzt
19:51:17 <newsham> > sum [2** (fromIntegral n) | ('1',n) <- zip (reverse "101110111000") [0..]]
19:51:19 <lambdabot>  3000.0
19:51:33 <glguy> @type mfix
19:51:35 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
19:51:37 <Tela> :)
19:51:56 <glguy> @index mfix
19:51:56 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
19:52:09 <dcoutts__> sjanssen_: I don't see any fusion. this isn't much different from using (f (:) [])
19:52:27 <dcoutts__> sjanssen_: the Nil and Cons will still need to be allocated
19:52:53 <dcoutts__> sjanssen_: the previous approach was quite interesting, I'd never thought of that.
19:52:59 <shapr> newsham: Sex Lies and Turing Tapes?
19:53:14 <dcoutts__> I thought the best we could do was something like you've got now, where at least we do it lazily
19:53:20 <dcoutts__> but still allocate cons cells
19:53:47 <sjanssen_> dcoutts__: I guess I don't see the difference between allocating Yield cells and allocating Cons cells
19:54:21 <dcoutts__> sjanssen_: well take a look in the core and see if the Cons get eliminated
19:56:07 <Bot_Builder> hey, I'm taking a programming class in high school, but I've been programming for 8 years, so the teacher is going to let me learn a language I haven't done (the class is VB :( ).  Haskell is an obvious choice - anyway, he wants me to get a book - any reccomendations?
19:56:56 <dcoutts__> Bot_Builder: there are several reccomended on the "learning haskell" page on the haskell.org website
19:57:04 <newsham> botbuilder: I really liked the course material online here:  http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/external.html
19:57:08 <lambdabot> Title: Programming in Haskell, http://tinyurl.com/fan47
19:57:12 <Bot_Builder> alright
19:57:16 <newsham> in particular the slide decks..  they use the Simon Thompson book
19:57:34 <newsham> that might be a good choice since its a full course with excercises, slides and a book
19:58:03 <dcoutts__> Bot_Builder: or similarly on the "Haskell in 5 steps" page, linked from the haskell.org frontpage
19:58:05 <Bot_Builder> ok, thanks
19:58:39 <dons> Bot_Builder: are you related to BuildBot?
19:58:39 <dcoutts__> personally I think I'd reccomend Simon Thompson: Haskell: The Craft of Functional Programming
19:58:44 <newsham> for a simpler set of lessons there's "2 dozen short lessons" which is also nice (but less practical)
19:58:50 <Bot_Builder> Hugs is probably my first choice for a compiler right?
19:58:54 <dons> ?google BuildBot yhc
19:58:54 <newsham> http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
19:58:58 <lambdabot> Title: Two Dozen Short Lessons in Haskell, http://tinyurl.com/hl9mm
19:59:06 <lambdabot> http://www.indiegigs.co.uk:8010/
19:59:06 <lambdabot> Title: BuildBot: Yhc
19:59:11 <newsham> bbuilder: I prefer ghc, I started with hugs, but found ghc/ghci a lot nicer
19:59:37 <Bot_Builder> alright good - i want to mess with atomic transactions anyway...
19:59:38 <Pseudonym> Most people here prefer ghc, but there's nothign wrong with hugs.
19:59:39 <Bot_Builder> :)
19:59:51 <Pseudonym> BTW, are you actually building a bot?
19:59:53 <newsham> yah, hugs is definitely useable.
20:00:01 <Korollary> Hugs doesn't have the full hierarchical libs, though.
20:00:09 <Bot_Builder> Pseudonym - I have built a few robots, and irc bots
20:00:16 <Bot_Builder> don't do it much anymore though
20:00:17 <Pseudonym> ?lambdabot
20:00:18 <lambdabot> Unknown command, try @list
20:00:18 <Korollary> Bot_Builder: You'll love our lambdabot then.
20:00:24 <Pseudonym> ?botsnack
20:00:25 <lambdabot> :)
20:00:51 <Bot_Builder> Yeah, every good programming language channel has a bot written in the language :)
20:00:51 <Pseudonym> ?vixen Will Bot_Builder love you?
20:00:52 <lambdabot> me?
20:01:23 <Pseudonym> True enough, but lambdabot can do some extremely cool Haskell-related stuff.
20:02:16 <Pseudonym> Things like search-the-libraries-by-type.
20:02:28 <Bot_Builder> mm nice.  I wrote a bot that allowed a collaborative interpreter session in an irc channel
20:02:39 <Pseudonym> > 1+1
20:02:40 <lambdabot>  2
20:02:45 <dons> > map (+1) [1..10]
20:02:46 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:02:47 <dons> ?type map
20:02:49 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
20:02:50 <Bot_Builder> it was fun to get it to not own my computer when people messed around :P
20:02:52 <Bot_Builder> cool!
20:02:54 <dons> ?hoogle (a -> b) -> [a] -> [b]
20:02:54 <Tela> ?djinn a -> b -> a
20:02:54 <Pseudonym> Being pure, there's little point for collaboration.
20:02:54 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
20:02:55 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
20:02:55 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
20:02:55 <lambdabot> f a _ = a
20:03:01 <dons> lambdabot++
20:03:21 <Bot_Builder> Pseudonym: well, you can use eachothers definitions though, right?
20:03:32 <Bot_Builder> thats what I really mean
20:03:36 <dons> we have a shared state for a number of plugins, yes.
20:03:42 <Pseudonym> Yeah.
20:03:47 <Pseudonym> ?type id
20:03:48 <lambdabot> forall a. a -> a
20:03:51 <Pseudonym> ?djinn a -> a
20:03:51 <dons> the djinn-env for example
20:03:52 <lambdabot> f a = a
20:04:04 <Bot_Builder> ? a = 1
20:04:09 <Bot_Builder> ?
20:04:14 <Pseudonym> ?free f :: a -> a
20:04:15 <lambdabot> g . f = f . g
20:04:32 <Tela> the ? is a prefix for commands. > prefixes the interpreter
20:04:36 <Pseudonym> ?pl \x -> x
20:04:37 <lambdabot> id
20:04:50 <Bot_Builder> ah.  what's the diff between commands and the interpreter 0-o
20:05:00 <Pseudonym> Excellent question.
20:05:01 <dons> there's no interpreter ;)
20:05:15 <dons> interpreting's for dynamically typed wussy languages
20:05:22 <Pseudonym> Ideally, you should be able to run bot commands from within the Haskell implementation.
20:05:25 <Bot_Builder> yeah I don't like dynamic typing
20:05:39 <Pseudonym> You've definitely picked the right language, then.
20:05:40 <Tela> Ehhhhhhh, yeah *hangs his head in shame*
20:05:44 <Bot_Builder> I'm into language design though, so i figured its time I learn a functional language
20:06:33 <dcoutts__> good idea
20:07:30 <Pseudonym> Haskell is the best laboratory for testing type systems, it seems.
20:07:32 <dons> you might enjoy haskell then, its design as a language for designing languages
20:07:33 <Bot_Builder> yeah, I'm not one of those people that wants to make a C copy-cat language
20:07:33 <Bot_Builder> ugg
20:07:45 <Bot_Builder> dons - ooh, cool
20:07:59 <Pseudonym> So if you want to practice your advanced type hackery, this is definitely the one for you.
20:08:04 <Korollary> I wanna make the next Perl copycat language and be famous.
20:08:11 <vincenz> Korollary: swine?
20:08:32 <Korollary> Mine won't be named swine.
20:08:45 <vincenz> perls for the swine?
20:09:05 <Bot_Builder> I want to make something with inline DSLs
20:09:07 * Pseudonym decides to call his next language MegaBlade
20:09:14 <Bot_Builder> and easy DSL decleration
20:09:16 <vincenz> Bot_Builder: haskell allows that quite fluently
20:09:35 <Bot_Builder> vincenz - sweet - to what level?
20:09:41 <vincenz> define level
20:09:42 <Korollary> Pseudonym: Isn't that our trademark? What was the company name again?
20:09:45 <Pseudonym> To any level that doesn't break syntax.
20:09:54 <Bot_Builder> vincenz - limitations
20:10:08 <vincenz> Bot_Builder: you can do it in the language, as long as what Pseudonym said...it fits the haskell syntax
20:10:12 <Pseudonym> STM is a great example.  It's a domain-specific _imperative_ language that's perfectly safe.
20:10:14 <Bot_Builder> like could you write the following:
20:10:19 <Bot_Builder> File
20:10:25 <Bot_Builder> |Open
20:10:27 <Bot_Builder> |Save
20:10:30 <Bot_Builder> |Save As
20:10:32 <Korollary> The Foozles slides are hilarious.
20:10:32 <Bot_Builder> |Exit
20:10:36 <Bot_Builder> Edit
20:10:38 <Bot_Builder> |Copy
20:10:40 <Bot_Builder> |Paste
20:10:44 <Bot_Builder> as a menu DSL
20:10:49 <Adamant> what are the drawbacks of DSL's?
20:10:57 <Bot_Builder> (using a menu DSLs)
20:11:07 <Pseudonym> Well you can't do that specifically.
20:11:08 <vincenz> Bot_Builder: I am not certain that classifies as a DSL, but you could easily make a DSL to ease the creation of menus
20:11:10 <Tela> that looks more lispy.. You can't modify the syntax that much so far as I know
20:11:20 <Bot_Builder> Adamant - you have to learn it.  It might be better just to stick to the language symantics
20:11:20 <Pseudonym> You could do something like:
20:11:30 <Adamant> ah, about what I figured.
20:11:35 <sjanssen_> dcoutts__: is there a purpose to the strict state field in Step?
20:12:11 <Pseudonym> "File" :+ "Open" :+ "Save As" :+: "Edit" :+ "Copy"
20:12:12 <Pseudonym> Or something
20:12:18 <Pseudonym> I dunnoi.
20:12:18 <Bot_Builder> Also, writing the DSL itself will clutter the lib unless you have other DSLs to ease the writing :)
20:12:22 <Pseudonym> Pick better oeprators.
20:12:45 <vincenz> "File"
20:12:51 <vincenz> :> "Open"
20:12:53 <vincenz> :> "Save"
20:13:03 <vincenz> :+: "Edit"
20:13:07 <vincenz> :> "Copy"
20:13:09 <Bot_Builder> mm, maybe.  Well, my idea is to have basically the whole syntax of the language built up around the core language which is just enough to be able to be built up to whatever
20:13:14 <Pseudonym> That's not bad.
20:13:24 <Bot_Builder> yeah, that's nice
20:13:31 <Pseudonym> Of course you don't need to use colon operators if you use smart constructors instead.
20:13:32 <vincenz> just an example
20:13:41 <vincenz> Pseudonym: smart constructors?
20:13:43 <Bot_Builder> what about
20:13:52 <Bot_Builder> :+: "Edit
20:14:00 <Bot_Builder> :> "Set Color"
20:14:09 <Bot_Builder> :>> "Green"
20:14:11 <Bot_Builder> etc etc
20:14:15 <Bot_Builder> could get tricky
20:14:16 <Korollary> You're concentrating on the surface syntax of the DSL though. There's quite a bit more into it.
20:14:21 <Pseudonym> In Haskell, operators need to be infix.
20:14:30 <vincenz> Bot_Builder: I am not certain that would work
20:14:34 <vincenz> but
20:14:38 <Pseudonym> vincenz: Dot-operators are concrete constructors.
20:14:41 <vincenz> well maybe you could
20:14:44 <Bot_Builder> vincenz - yeah, it wouldn't - I don't know haskell yet
20:14:44 <Pseudonym> Sorry, colon-operators
20:14:50 <Pseudonym> As in, they can appear in data.
20:14:56 <vincenz> Bot_Builder: It might, depending on operator priority
20:14:57 <Pseudonym> But you can do this too:
20:15:02 <Pseudonym> x @@ xs = x : xs
20:15:03 <Pseudonym> Or something.
20:15:12 <vincenz> Pseudonym: oh funcs
20:15:18 <Pseudonym> Right.
20:15:27 <Pseudonym> Smart constructors don't need to really be "smart".
20:15:36 <Bot_Builder> Korollary - true, but I've got an idea for a DSL to allow writing the majority of the language rather elegantly.  Whether it will work practically is yet to be seen
20:15:50 <vincenz> Bot_Builder: what do you want to do with the DSL?
20:16:28 <Pseudonym> Korollary has a good point, of course.  Haskell encourages looking at the abstract syntax first.
20:16:29 <Bot_Builder> vincenz - oh, I'm just talking about the idea in general - that libraries can define their own DSLs you can use inline
20:16:36 <Pseudonym> The concrete syntax can wait.
20:17:08 <vincenz> Bot_Builder: ah that is perfectly possible in haskell
20:17:20 <Pseudonym> menu = do
20:17:25 <Pseudonym>     m "Edit"
20:17:32 <Pseudonym> Hmm.
20:17:37 <Pseudonym> Nah, probably not.
20:17:46 <vincenz> :- "Edit"
20:17:49 <vincenz> :> "Copy"
20:18:01 * Pseudonym shudders... :- looks like Prolog
20:18:05 <vincenz> hehe
20:18:18 <Pseudonym> Gofer had a cool Prolog interpreter, though:
20:18:32 <vincenz> Pseudonym: in DSL?
20:18:34 <Pseudonym> data HornClause = Term :- [Term]
20:19:12 <Pseudonym> There's something very elegant and yet very wrong about using :- for that.
20:19:23 <vincenz> :=>
20:19:42 <Bot_Builder> do all operators start with :?!?!?
20:19:46 <vincenz> no
20:19:51 <Bot_Builder> ok good
20:19:53 <vincenz> all infix data constructors
20:20:02 <vincenz> > [1..10] ++ [11..20]
20:20:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:20:09 <Pseudonym> You may have noticed that Haskell distinguishes stuff that starts with a capital letter from stuff that doesn't.
20:20:14 <Bot_Builder> > [1..10] + [11..20]
20:20:14 <lambdabot>  add an instance declaration for (Num [a])
20:20:15 <lambdabot>   In the definition of `nox': n...
20:20:19 <Bot_Builder> I see
20:20:19 <vincenz> > let x @ y = x*y in 1 @ 2
20:20:20 <lambdabot>  Parse error
20:20:22 <vincenz> whoops
20:20:25 <vincenz> Bot_Builder: ++
20:20:29 <vincenz> Bot_Builder: + is for addition
20:20:33 <Pseudonym> > let x @@ y = x * y in 1 @@ 2
20:20:35 <lambdabot>  2
20:20:40 <Bot_Builder> I know - wanted to see what would happen if i disobeyed it
20:20:42 <Pseudonym> @ is special
20:20:45 <vincenz> Pseudonym: what was off with mine?
20:20:45 <vincenz> oh
20:20:53 <Pseudonym> ?type (++)
20:20:55 <lambdabot> forall a. [a] -> [a] -> [a]
20:21:11 <Pseudonym> ?type (+)
20:21:11 <vincenz> > let x <~> y = if x then x else y in True <~> False
20:21:13 <lambdabot> forall a. (Num a) => a -> a -> a
20:21:13 <lambdabot>  True
20:21:14 <Korollary> Bot_Builder: If I were you, I'd get a copy of this book (http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/053494728X) for $10 as well.
20:21:28 <Bot_Builder> that's one thing i want to ask about - in the -> notation, why aren't the outputs distinguished from the inputs?
20:21:35 <Bot_Builder> well, i guess it is because its at the end
20:21:44 <Pseudonym> Basically, operators that start with a colon are the equivalent of identifiers that start with a capital letter.
20:21:45 <Bot_Builder> but its plain funky nonetheless
20:22:16 <vincenz> Bot_Builder: hmm?
20:22:18 * Pseudonym doesn't understand that question
20:22:20 <vincenz> a -> b is a function
20:22:24 <vincenz> from type a to b
20:22:47 <vincenz> for instance
20:22:50 <vincenz> @type (++)
20:22:51 <lambdabot> forall a. [a] -> [a] -> [a]
20:22:55 <Bot_Builder> isn't a -> b -> c a function from a and b to c?
20:23:00 <Pseudonym> Kind of.
20:23:01 <vincenz> no
20:23:06 <vincenz> oh
20:23:11 * vincenz parsed wrong
20:23:17 <Tela> it's a function from a to a function from b to c, as well
20:23:22 <Pseudonym> A -> B -> C is a fucnction of _one_ argument
20:23:25 <Pseudonym> A
20:23:28 <emu> it's a function from a -> (b -> c)
20:23:33 <Bot_Builder> ah
20:23:35 <Pseudonym> Which returns a value of type B -> C
20:23:42 <Pseudonym> This may help:
20:23:44 <vincenz> Bot_Builder: see the point is, in haskell all functions are curried, meaning you can provide their parameters one at a time
20:23:45 <Bot_Builder> which is a function which may be used
20:23:47 <Pseudonym> f :: A -> B -> C -> D
20:23:52 <Pseudonym> f a :: B -> C -> D
20:23:57 <Bot_Builder> ah, ok I understand
20:23:57 <Pseudonym> f a b :: C -> D
20:24:16 <Pseudonym> Note that function application is left-associative and -> is right-associative.
20:24:27 <Pseudonym> f :: A -> (B -> (C -> D))
20:24:31 <Pseudonym> f a :: B -> (C -> D)
20:24:39 <Pseudonym> (f a) b :: C -> D
20:24:43 <Pseudonym> etc
20:25:12 <vincenz> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:25:13 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:25:47 <Bot_Builder> yeah, i read through some of the fib examples
20:25:56 <vincenz> :)
20:25:58 <newsham> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in reverse fibs
20:26:03 <lambdabot> Terminated
20:26:13 <Bot_Builder> let fibs 1 1 = 2
20:26:21 <vincenz> newsham: it's infinitely long!
20:26:21 <Bot_Builder> > let fibs 1 1 = 2
20:26:22 <lambdabot>  Parse error
20:26:25 <Bot_Builder> bah
20:26:28 <newsham> vincenz: i can wait.
20:26:35 <emu> > let fibs 1 1 = 2 in fibs 1 1
20:26:36 <lambdabot>  2
20:26:39 <vincenz> LET definition IN expression
20:26:59 <vincenz> > let a = 1 in a
20:27:00 <lambdabot>  1
20:27:06 <vincenz> > let a = 1:a in a
20:27:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:27:10 <Pseudonym> > let fibs a b = a + fibs b (a+b) in fibs 0 1
20:27:11 <Bot_Builder> let fibs x y = x + y in fibs x y
20:27:13 <lambdabot>  out of memory (requested 1048576 bytes)
20:27:17 <Pseudonym> > let fibs a b = a : fibs b (a+b) in fibs 0 1
20:27:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:27:21 <newsham> > iterate (const 1) 0
20:27:23 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:27:24 <Bot_Builder> > let fibs x y = x + y in fibs x y
20:27:25 <lambdabot>  Not in scope: `y'
20:27:34 <ibid> vincenz: hm?
20:27:37 <Tela> > cycle [1]
20:27:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:27:42 <vincenz> > let fibs x y = x + y in fibs 1 2
20:27:43 <lambdabot>  3
20:27:46 <Bot_Builder> (this is a good study of a noobs struggle with haskell btw :) )
20:27:48 <vincenz> ibid: same issue with the links
20:27:51 <Bot_Builder> ohh
20:27:51 <Pseudonym> > let { fib 0 = 0; fib 1 = 1; fib n = fib (n-2) + fib (n-1) } in fib 10
20:27:53 <lambdabot>  55
20:28:45 <Pseudonym> Fibonacci numbers is the canonical example in functional programming, I think.
20:28:48 <newsham> > let { fib 0 = 0; fib 1 = 1; fib n = fib (n-2) + fib (n-1) } in fib -2
20:28:49 <lambdabot>  add an instance declaration for (Num (a -> a1))
20:28:57 <Pseudonym> Ha.
20:28:58 <newsham> > let { fib 0 = 0; fib 1 = 1; fib n = fib (n-2) + fib (n-1) } in fib (-2)
20:29:00 <vincenz> newsham: (-2)
20:29:00 <lambdabot>  Exception: stack overflow
20:29:10 <Tela> Pseudonym: That and fact
20:29:12 <Bot_Builder> ? let fibs 0 = 0
20:29:22 <emu> Bot_Builder: this convenient sort of prompt is available from ghci and similar
20:29:25 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/
20:29:27 <lambdabot> Title: Index of /darcs/numbertheory
20:29:31 <emu> where you can "ask questions" of the haskell system
20:29:35 <Bot_Builder> emu - yeah
20:29:41 <Pseudonym> That fibonacci thing handles negative numbers.
20:29:46 <newsham> ghci even lets you keep some previous definitions
20:31:16 <emu> and emacs haskell-mode lets you manage ghci from within emacs, loading files, using the prompt, etc
20:31:20 <emu> showing information
20:31:24 <emu> indentation
20:31:27 <ibid> vincenz: as i said, the last time it was your rss feed reader m
20:31:31 <ibid> 's fault
20:31:36 <ibid> vincenz: has this changed?
20:31:57 <Pseudonym> GHCi, by the way, makes a great desk calculatro.
20:32:42 <newsham> there are lots of great desk calculators.
20:33:15 <glguy> J makes a good desk calculator
20:33:35 <Pseudonym> Sure, but this is #haskell, not #J
20:33:40 <glguy> :(
20:34:10 <vincenz> ibid: my rss reader?  it's just google's!
20:34:12 <Korollary> among general purpose languages, ghci is the best desk calculator imho.
20:34:13 <ibid> vincenz: namely, it's treating a non-permalink guid as an uri it can present as a link to the original content. this is against the spec
20:34:15 <dons> glguy: why not write a J-like library for haskell?
20:34:24 <dons> providing all the fun symbols as an embedded DSL?
20:34:28 <dons> would be kind of fun.
20:34:34 <glguy> dons: this is true :)
20:34:36 <ibid> vincenz: "your X" ==> "the X that you use" :)
20:34:39 <vincenz> ibid: it's on google personalized homepage
20:34:46 <vincenz> they use it for ALL the content
20:34:49 <ibid> vincenz: report a bug?
20:34:51 <dons> glguy: how's the math challenge going?
20:34:56 <vincenz> ibid: okies
20:35:00 <glguy> i solved another problem in haskell tonight
20:35:01 <ibid> vincenz: as far as i can tell, the feed is correct
20:35:14 <glguy> 84% done
20:35:35 <glguy> 92 on the leader board, 3rd on the haskell board (the other two have all and all but one done)
20:35:41 <ibid> vincenz: if you can counter my argument, do so :)
20:35:56 <dons> how many entries all together?
20:36:05 <dons> if you're 92/* ?
20:36:16 <ibid> good morning, btw :)
20:36:18 <glguy> I've solved 110 of 127
20:36:32 <chessguy> glguy: is that on topcoder.com?
20:36:33 <glguy> the rest are starting to get harder :)
20:36:36 <ibid> vincenz: i *can* remove the guid, but i'd rather not
20:36:39 <glguy> chessguy: mathschallenge.net
20:36:53 <glguy> topcoder doesn't compile Haskell code
20:36:59 <ibid> vincenz: i'd rather google fixed their system. how likely that is, i don't know
20:37:02 <Cowmoo> ok, I don't know any Haskell, but could someone explain to me what people mean when they say functional languages "have no side effects" ?
20:37:10 <glguy> neither does mathschallenge, but it's okay because you compile your own
20:37:18 <dons> purely functional languages have no side effects, Cowmoo
20:37:20 <Cowmoo> does that just mean that variables can't be modified by functions?
20:37:27 <chessguy> glguy, i didn't think topcoder did
20:37:27 <dons> not quite
20:37:34 <glguy> all that a function can do is return a value
20:37:37 <Cowmoo> dons: right, do you mind elaborating then?
20:37:43 <glguy> and it should always return that same value given the same inputs
20:38:06 <chessguy> glguy, how do you compete on mathschallenge?
20:38:13 <dons> right. a pure function returns the same value, given the same input
20:38:19 <glguy> chessguy: they ask questions, you write a program to find the answer and type it in
20:38:26 <dons> so no "side effects" happen, like mutating some global state on the way
20:38:27 <vincenz> ibid: alright
20:38:29 <chessguy> oh, in the forums?
20:38:38 <vincenz> ibid: my knowledge of RSS is zilch :)
20:38:51 <Cowmoo> dons: what other side effects are there?
20:38:56 <dons> IO
20:39:02 <vincenz> ibid: I assumed it wasn't a google problem, cause ... hey... it's google :D but if you say it's their fault then maybe we should file a bug
20:39:35 <Cowmoo> because you can use that to input values from "outside" so to speak?
20:39:46 <ibid> vincenz: if you look at the feed, you can see that the "faulty" uris come from guid permalink="false" elements. then google for the rss 2.0 spec and read what it says about guid permalink="false" :)
20:39:49 <Cowmoo> thus the function stops depending only on the parameters?
20:39:51 <dons> well, a function that prints a string, and returns 1, does two things :)
20:39:58 <dons> Cowmoo: right
20:40:16 <dons> its a highly desirable property to have functions whose result depends only on the input arguments
20:40:30 <dons> since you can debug such functions in isolation (without having to reconstruct some program state)
20:40:31 <vincenz> ibid: :)
20:40:40 <dons> you can reason about them, inline them to your heart's content, and more
20:40:48 <vincenz> ibid: I doubt google will satisfy my search, I'm trying to use it to prove it is incorrect
20:41:06 <Cowmoo> dons: and I imagine with regards to complaints about efficiency, the compiler can make some nifty optimisations?
20:41:17 <Cowmoo> since it knows a lot more about the function
20:41:20 <dons> yes, you can do _much_ more when you know there aren't side effects
20:41:27 <dons> which is why gcc has added the new 'pure' keyword
20:41:38 <Cowmoo> oh has it? I wasn't aware
20:41:45 <dons> for example, you can paralellise things trivially
20:41:56 <glguy> Haskell is sweet, but not really fast enough to use on SPOJ (without butchering your code)
20:41:57 <Bot_Builder> yeah, I'm proud to say i invented pure in isolation on procedural languages
20:42:16 <Cowmoo> SPOJ?
20:42:17 <dons> glguy: that shouldn't be the case? we have been leading the other language shootout at times
20:42:19 <Bot_Builder> though it turns out most functions written in normal style aren't pure
20:42:30 <dons> glguy: you've looked at:
20:42:32 <dons> ?wiki Performance
20:42:33 <lambdabot> http://www.haskell.org/haskellwiki/Performance
20:43:07 <newsham> > let fac f n = if n == 0 then 1 else n * (f $ n-1) in (fix fac) 5
20:43:08 <dons> really, you should be able to get something around 1.2x the speed of C, on average, I think.
20:43:09 <lambdabot>  120
20:43:13 <dons> from ghc-compiled haskell
20:43:23 <vincenz> what is SPOJ?
20:43:39 <glguy> dons: then they give you 1 second to multiple 1000 numbers with as many digits each...
20:43:42 <vincenz> single processor on juice?
20:43:44 <newsham> dons: is there any public code that translates haskell into lambda calculus (even some subste of haskell) ?
20:43:50 <glguy> int-e's code ot do it is greusome
20:44:14 <dons> oh this is why he sent me a ByteString -> Integer patch to fps
20:44:26 <dons> so this is a particular case of IO + strings
20:44:32 <dons> which we solve with Data.ByteString these days
20:44:38 <sjanssen_> vincenz: Sphere Online Judge -- programming competition site
20:44:41 <vincenz> oh
20:44:41 <dons> not really a reflection on haskell as a whole
20:44:46 <sjanssen_> http://www.spoj.pl
20:44:47 <emu> 100,000 numbers
20:44:48 <lambdabot> Title: Sphere Online Judge (SPOJ)
20:44:59 <emu> heh but lets see if they'll install fps or at least ghc 6.6 when its out
20:45:02 <dons> newsham: not that I know of.
20:45:16 <dons> yeah, you definitely want to get 6.6 on the box, since then you get fps for free
20:45:17 <glguy> I'm looking forward to SPOJ getting FPS
20:45:21 <dons> and the new high speed regex lib
20:45:22 <sjanssen_> emu: we oughta campaign to have them install fps
20:45:26 <Bot_Builder> > let {fac 1 = 1; fac n = n * fac (n-1)} in fac(100)
20:45:27 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
20:45:31 <glguy> they done even have the current6.4 release
20:45:33 <Bot_Builder> holy shite!
20:45:38 <emu> sjanssen_: go to Wishlist thread on Online Judge forum and read page 4 =)
20:45:41 <dons> glguy: oh. really? that sucks.
20:45:46 <sjanssen_> emu: it'll only take half a dozen commands
20:45:47 <glguy> they run 6.4.1
20:45:59 <vincenz> my ogod
20:45:59 <dons> 6.4.2 + fps would be good. 6.6 would be better
20:46:01 <vincenz> spoj looks lame
20:46:02 <Bot_Builder> > let {fac 1 = 1; fac n = n * fac (n-1)} in fac(50)
20:46:02 <glguy> I wish they allowed J on SPOJ :) that would help a lot on certain problems
20:46:03 <vincenz> check this test out
20:46:04 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
20:46:05 <vincenz> http://www.spoj.pl/problems/TEST/
20:46:06 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem TEST
20:46:18 <sjanssen_> vincenz: spoj is pretty fun
20:46:19 <Bot_Builder> damn, what number format does that use?
20:46:20 <glguy> Bot_Builder: let fac n = product [1..n] in fac 50
20:46:32 <newsham> what's the last digit of fac (2**100000 - 1) ?
20:46:32 <sjanssen_> and it's way too easy to waste hours knocking out problems
20:46:33 <emu> the version of FCTRL that dons came up with runs in about 0.8-0.9s on n=100000
20:46:36 <Bot_Builder> well, thats the cheap way to write it :P
20:46:48 <vincenz> sjanssen_: so how do you submit and they're all realyl small puzzles like this?
20:46:53 <vincenz> sjanssen_: what's the complexity?
20:46:57 <lispy> newsham: 9 right?
20:46:57 <dons> Bot_Builder: what number format is ghc using above, you mean?
20:46:58 <glguy> on mathschallenge.net once you get to ~80% complete... instead of saying "if you can't solve a problem, you can't solve it, so don't ask"
20:47:07 <dons> ?type let {fac 1 = 1; fac n = n * fac (n-1)} in fac(50)
20:47:08 <glguy> it says "your feedback is welcome, email me at"
20:47:09 <lambdabot> forall a. (Num a) => a
20:47:22 <dons> i.e. Integer, gmp arbitrary precision integers
20:47:25 <Bot_Builder> ah
20:47:25 <newsham> @p \n -> product [1..n]
20:47:26 <lambdabot> Maybe you meant: palomer part paste pl pl-resume pointless poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . v
20:47:28 <dons> also, you'd write that as:
20:47:28 <Bot_Builder> coolio
20:47:32 <Bot_Builder> I expected it to bork
20:47:37 <dons> > let fac 1 = 1; fac n = n * fac (n-1) in fac 50
20:47:38 <newsham> @pl \n -> product [1..n]
20:47:38 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
20:47:39 <lambdabot> product . enumFromTo 1
20:47:42 <vincenz> > product [1..1000]
20:47:42 <sjanssen_> vincenz: most questions are implementing standard algorithms like topo sort and such
20:47:43 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
20:47:45 <glguy> let fac = product . enumFromTo 2 in fac 5
20:47:47 <glguy> > let fac = product . enumFromTo 2 in fac 5
20:47:48 <dons> ?pl let fac 1 = 1; fac n = n * fac (n-1) in fac 50
20:47:48 <lambdabot>  120
20:47:49 <lambdabot> 50 * 50 49
20:47:50 <sjanssen_> vincenz: but some are very tough
20:47:58 <vincenz> sjanssen_: ah, but that first test is a joke, right?
20:48:00 <dolio> let {fac n = n !! scanl (*) 1 [2..] } in fac 50
20:48:01 <emu> what's wrong with 6.4.1 and fps?
20:48:10 <dons> nothing?
20:48:13 <sjanssen_> vincenz: the idea is just to learn the system, I think
20:48:14 <dolio> > let {fac n = n !! scanl (*) 1 [2..] } in fac 50
20:48:15 <lambdabot>  Couldn't match `Int' against `[a]'
20:48:16 <dons> 6.4.2 is better though :)
20:48:23 <lispy> > let fibs = 1 : 1 : fibs : (tail fibs) in fibs !! 100
20:48:23 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:48:24 <vincenz> sjanssen_: how do you submit?
20:48:24 <lambdabot>    Expected...
20:48:27 <newsham> functional programmers sure know factorials and fibonnaci numbers.
20:48:34 <lispy> oh heh
20:48:44 <sjanssen_> vincenz: make an account, click the submit button
20:48:44 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs  tail fibs) in fibs !! 100
20:48:45 <lambdabot>  Parse error
20:48:46 <glguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 4
20:48:47 <lambdabot>  5
20:48:49 <vincenz> sjanssen_: what format/
20:48:56 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs  (tail fibs) in fibs !! 100
20:48:57 <lambdabot>  573147844013817084101
20:49:07 <dolio> Oh, backwards.
20:49:10 <lispy> so fac 100 >> fibs 100
20:49:11 <sjanssen_> vincenz: submit source code in your favorite language
20:49:25 <dolio> > let {fac n = flip (!!) n $ scanl (*) 1 [2..] } in fac 50
20:49:27 <lambdabot>  1551118753287382280224243016469303211063259720016986112000000000000
20:49:45 <newsham> > let fib n = product [1..n] in [fib n `mod` 10 | n <- [1..]]
20:49:47 <lambdabot>  [1,2,6,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
20:50:11 <Bot_Builder> your rabbits must have died
20:50:28 <newsham> > let fib n = product [1..n] in [fib n `mod` 2 | n <- [1..]]
20:50:30 <lambdabot>  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
20:50:40 <vincenz> sjanssen_: oh nice, you can even code live :)
20:50:42 <Pseudonym> Bot_Builder: That used to be a euphemism for pregnancy.
20:50:46 <vincenz> sjanssen_: instead of uploading a file :)
20:51:00 <vincenz> sjanssen_: how do they stop hackerS?
20:51:06 <Bot_Builder> Pse
20:51:10 <Bot_Builder> Pseudonym: huh
20:51:11 <sjanssen_> vincenz: dunno, chroot or something
20:51:14 <Pseudonym> Really.
20:51:19 <deadbeef> > let fibonacci' = (1, 0); fibonacci' 1 = (1, 1); fibonacci' x = ((+) y z, y) where (y, z) = fibonacci' ((-) x  1); fibonacci x = fst (fibonacci' x) in fibonacci 50
20:51:20 <lambdabot>  Not in scope: `fibonacci'
20:51:30 <dolio> > let {fac n = flip (!!) n $ scanl (*) 1 [1..] } in fac 50
20:51:32 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
20:51:43 <Pseudonym> Before the invention of the urinate-on-a-stick, pregnancy tests involved chemicals harvested from rabbit livers.
20:51:55 <Pseudonym> "The rabbit died" became a euphemism.
20:52:04 <Pseudonym> See what you learn on #haskell?
20:52:15 <deadbeef> omg
20:52:26 <Bot_Builder> yeah, was about to say you learn something new every day
20:52:45 <Pseudonym> ?google "the rabit died"
20:52:50 <lambdabot> http://www.abebooks.com/sm-search-0385140576-i-should-have-seen-it-coming-when-the-rabbit--is!0385140576.html
20:52:50 <lambdabot> Title: Abebooks Search Results - ISBN 0385140576
20:52:57 <Pseudonym> ?google "the rabbit died"
20:53:00 <lambdabot> http://www.snopes.com/pregnant/rabbit.htm
20:53:01 <lambdabot> Title: Urban Legends Reference Pages: Pregnancy (The Rabbit Test)
20:53:01 <glguy> hey, if anyone else here is going ot go to mathschallenge.net because I brought it up, please have the courtesy to use Haskell ;)
20:53:03 <Pseudonym> That's it.
20:53:27 <Pseudonym> Ah, no, it involved injecting the rabbit with urine.
20:53:30 <Pseudonym> I see.
20:53:35 <dons> sjanssen_: does the stream/build patch fuse? is it safe?
20:53:42 <Bot_Builder> well, my usage was that factorial is similar to rabbit population
20:53:53 <emu> are they more haskell friendly
20:53:53 <Pseudonym> You mena fibonacci.
20:54:00 <Bot_Builder> yeah i mean fib
20:54:05 <sjanssen_> dons: it fuses, and I believe it's safe
20:54:35 <lispy> sjanssen_: can you prove it's safe?
20:54:41 <sjanssen_> dons: also, that is only the framework to do the pack, I didn't actually update the code in Data.ByteString
20:55:45 <dons> yep ok.
20:55:59 <sjanssen_> dons: also, for the record, you're the fastest email receiver ever
20:56:00 <dons> I'll stick it in , and we can play around with it
20:56:04 <dons> heh ok
20:56:09 <glguy> I did to figure out a function for computing the continued fraction form of square roots, it will help me on a few of my remaining problems
20:56:49 <lispy> so any sites like SPOJ where it doesn't come down to IO is too slaw?
20:56:51 <lispy> er slow
20:57:28 <newsham> > let f g = let x = g x in x in let h f n = if n == 0 then 1 else n * (f $ n - 1) in (f h) 5
20:57:30 <lambdabot>  120
20:57:51 <emu> > (\x -> x x) (\x -> x x)
20:57:51 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
20:57:52 <lambdabot>    Expe...
20:57:59 <lispy> nice, spoj doesn't load for me...is it down?
20:58:04 <emu> its often slow
20:58:07 <sjanssen_> lispy: I'd estimate that you can do 80% of the problems on SPOJ without worrying about IO speed
20:58:12 <emu> i think they run the whole site on a PIII 700
20:58:18 <lispy> hehe
20:58:19 <glguy> it's not coming up for me
20:58:26 <lispy> well, my browser won't even wait for it
20:58:55 <lispy> gr...why am i using ie
20:59:00 * lispy goes back to his mac
20:59:02 <sjanssen_> I wonder how many of their recent hits stem from the mention on Haskell-cafe and #haskell
20:59:08 * glguy is on his mac :)
20:59:47 * vincenz wants a mac
21:00:24 <NoGoodNik> why?
21:00:42 <glguy> because no one wants to be teh "I'm a PC guy" ;)
21:00:51 <Pseudonym> let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0)); fac1 n = map (\p -> ((n - s p n) `div` (p-1)) (takeWhile (<=n) primes) } in fac1 10
21:01:09 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0)); fac1 n = map (\p -> ((n - s p n) `div` (p-1)) (takeWhile (<=n) primes) } in fac1 10
21:01:10 <lambdabot>  Parse error
21:01:56 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = map (\p -> ((n - s p n) `div` (p-1)) (takeWhile (<=n) primes) } in fac1 10
21:01:57 <lambdabot>  Parse error
21:02:08 <lispy> @type divMod
21:02:10 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:02:39 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = product [ p^((n - s p n) `div` (p-1)) | p <- takeWhile (<=n) primes ] } in fac1 10
21:02:40 * lispy points at what Pseudonym is doing and tries to explain to dons that we do need @let :)
21:02:41 <lambdabot>  250822656000
21:02:43 <Pseudonym> Done.
21:02:50 <dons> lispy: i'll take a patch
21:02:51 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = product [ p^((n - s p n) `div` (p-1)) | p <- takeWhile (<=n) primes ] } in fac1 0
21:02:52 <lambdabot>  1
21:02:54 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = product [ p^((n - s p n) `div` (p-1)) | p <- takeWhile (<=n) primes ] } in fac1 1
21:02:55 <lambdabot>  1
21:02:57 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = product [ p^((n - s p n) `div` (p-1)) | p <- takeWhile (<=n) primes ] } in fac1 2
21:02:58 <lambdabot>  2
21:02:59 <dons> maybe i'll write it this weekend anyway
21:03:00 <Pseudonym> > let { s p 0 = 0; s p n = let (q,r) = n `divMod` p in s p q + r; primes = sieve [2..]; sieve (p:ps) = p : sieve (filter (\n -> n `div` p /= 0) ps); fac1 n = product [ p^((n - s p n) `div` (p-1)) | p <- takeWhile (<=n) primes ] } in fac1 3
21:03:01 <lambdabot>  6
21:03:02 <Pseudonym> OK.
21:03:12 <lispy> dons: yeah, i was thinking about it
21:03:17 <dons> using sjanssen_'s plan, in State/Local.hs
21:03:23 <lispy> right
21:03:26 <dons> seems easy enough
21:03:40 <lispy> should you keep two states?
21:03:46 <dons> two?
21:03:52 <lispy> one being a list of the code and the other being the Local.hs
21:04:02 <lispy> sot hta people can do @let-list to see what's defined
21:04:08 <jgrimes> so does ghc still use a g-machine?
21:04:15 <dons> it uses an stg machine
21:04:22 <dons> nhc is a g machine, isn't it?
21:04:33 <jgrimes> yeah, and yhc
21:04:50 <dons> and hbc too, I suppose
21:05:22 <lispy> i think tonight i want to work more on getting my usb device working in haskell on osx
21:05:33 <lispy> which means i need to make the osx usb ffi code
21:05:34 <jgrimes> is the stg machine still a graph based machine?
21:05:49 <dons> ?google spineless tagless G machine
21:05:52 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
21:06:01 <jgrimes> cool
21:06:02 <dons> ?where+ stg http://citeseer.ist.psu.edu/peytonjones92implementing.html
21:06:03 <lambdabot> Done.
21:06:10 <lispy> we should get an fpga and implement the stg in hardware
21:06:22 <lispy> for the cool factor
21:06:28 <dons> no need! it maps to normal hardware easily enough :)
21:06:38 <dons> every 3 or 4 years someone suggests this on the mailing list :)
21:06:43 <lispy> ah
21:06:54 <dons> and simon replies that they spent all the 80s pondering whether they'd need to do taht
21:07:07 <Pseudonym> Implement SK combinators in hardware if you want a nice exercise, though.
21:07:51 <Korollary> the reason stg was invented is to run cbn on stock hardware
21:08:07 <Pseudonym> Every now and then some hardware researcher asks "what would you like to make declarative languages easier to implement?"
21:08:18 <Pseudonym> The consensus seems to be: Trapping arithmetic would be nice.
21:08:19 <weitzman> Is Haskell' going to exist anytime in the next year or two?
21:08:25 <dons> yep
21:08:30 <Bot_Builder> is graph based an architecture like register or stack based?
21:09:04 <Pseudonym> STF itself is a declarative language.
21:09:12 <Pseudonym> Which can be implemented register-based or stack-based.
21:09:13 <Pseudonym> STG
21:09:15 <Pseudonym> Not STF
21:09:25 <Bot_Builder> mmm
21:09:25 <Pseudonym> Hugs implements it using a stack machine, GHC uses a register machine.
21:10:17 <Bot_Builder> I'm just curious about architectures.  I've got a wierd idea.  Cross between an fpga and a cpu - a bunch of minicores in a grid.  basically make the minicores as simple as possible so you can have lots
21:10:34 <vincenz> Bot_Builder: they're working on that, the overhead is the communication tho
21:10:39 <Bot_Builder> yes
21:10:49 <Bot_Builder> will be sweet though, to pipeline cpus
21:11:03 <Bot_Builder> damn, everyone always steals my ideas before i'm out of hs...
21:11:12 <jgrimes> so is there a parallel stg machine?
21:11:42 <Pseudonym> Bot_Builder: Connection machine.
21:11:42 <dons> yep, it's called ghc
21:11:48 <jgrimes> :)
21:11:49 <Pseudonym> It was a huge array of 1-bit CPUs.
21:11:51 <jgrimes> ok
21:11:56 <Bot_Builder> Pseudonym: really
21:11:59 <Pseudonym> Yup.
21:12:13 <Bot_Builder> wasn't that that one famous Genetic algorithms guy...
21:12:14 <Bot_Builder> bah
21:12:31 <Bot_Builder> because i've heard of that machine
21:12:35 <Pseudonym> Danny Hillis.  Though famously, Feynmann worked there for a while.
21:12:43 <Bot_Builder> yes that guy :)
21:13:24 <Pseudonym> A bunch of AI researchers worked there over the years, actually.
21:13:36 <weitzman> I'm still waiting until we start using reconfigurable hardware and software gets compiled directly to a circuit design
21:13:46 <Pseudonym> Guy Steele, Marvin Minsky, Brewster Kahle, Stephen Wolfram, Doug Lenat...
21:15:30 <Korollary> weitzman: Hah. reconfigurable hardware.
21:15:38 <Bot_Builder> crap! my other two cpu architectures were taken by the transputer and cell
21:15:40 <weitzman> http://www.cs.cmu.edu/~phoenix/
21:15:41 <lambdabot> Title: The Phoenix Project
21:16:34 <dons> Pseudonym: interesting, http://www.polyomino.f2s.com/david/haskell/main.html
21:16:36 <lambdabot> Title: Learn Maths with Haskell, http://tinyurl.com/h9aov
21:16:59 <dons> http://www.polyomino.f2s.com/david/haskell/codeindex.html
21:17:01 <lambdabot> Title: Code Index, http://tinyurl.com/f9m94
21:17:12 <Pseudonym> Actually, the next thing that needs to be invented is transactional caches.
21:17:20 <Pseudonym> Haskell could really use that.
21:17:25 <Pseudonym> Wow!
21:17:28 <Pseudonym> Nice page.
21:17:34 <jgrimes> wow, thats a good resource
21:17:34 <dons> yep!
21:18:02 <Pseudonym> Hey, I needed some Groebner basis code.
21:18:08 <Pseudonym> Woohoo.
21:19:03 <weitzman> I'm going to learn about Groebner bases later this semester, assuming I haven't dropped my computer algebra course by then
21:19:08 <chessguy> err, does anyone here use visual haskell?
21:19:11 <weitzman> Strange you should mention them
21:19:28 <dons> Cale: anything fun we should be playing with in http://www.polyomino.f2s.com/david/haskell/codeindex.html?
21:19:31 <lambdabot> Title: Code Index, http://tinyurl.com/go2vz
21:19:40 <dons> Cale, I still want a free mathematica/mbot plugin for lambdabot :)
21:19:44 <dons> even if it runs haskell-maths
21:20:01 <vincenz> dons: octave
21:20:08 <dons> right.
21:20:19 <dons> someone know it enough to write a safe binding?
21:20:26 <vincenz> :/
21:21:16 <dons> ?remember DavidAmos the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use Haskell
21:21:29 <Pseudonym> dons: You could write a plugin for the integrator.
21:21:41 <newsham> quicker to write == more time for irc?
21:21:43 <Cale> dons: hm, I've never seen that page -- interesting :)
21:21:49 <newsham> @hoogle yhc
21:21:50 <lambdabot> No matches found
21:22:03 <Pseudonym> ?google the integrator
21:22:07 <lambdabot> http://integrals.wolfram.com/
21:22:08 <lambdabot> Title: The Integrator--Integrals from Mathematica
21:22:12 <dons> haskell's getting a bit of a niche as a gen. purpose prog lang for mathematicians (?)
21:22:38 <Pseudonym> Better that than Fortran.
21:22:53 <newsham> @where yhc
21:22:54 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
21:23:06 <vincenz> Pseudonym: he said mathematicians, not calculators
21:23:11 <Pseudonym> :-)
21:23:17 <Pseudonym> I want an up to date Sisal.
21:23:19 <deadbeef> when i search 'ndm' on google.it
21:23:27 <Pseudonym> And I want it embeddable in Haskell.
21:23:27 <deadbeef> i get the page of a teacher of mine
21:23:36 <deadbeef> wondering if he's him
21:23:47 <Pseudonym> But right now I want lunch.  BBS
21:24:41 <dons> deadbeef: are you at york?
21:24:56 <dons> no you're not, right?
21:24:56 <deadbeef> nop, uniba.it
21:25:03 <dons> so ndm is probably not your teacher then :)
21:25:13 <dons> he's a teacher, yes, (I think), but at York
21:28:24 <newsham> heh, a python interpretter to run yhc bytecode.
21:28:49 <dons> sacriledge, isn't it? (and bizarre imo)
21:29:02 <newsham> probably fun to write, though.
21:29:08 <newsham> and portable too?
21:30:27 <vincenz> ironpython :D
21:30:54 <newsham> no IronYhc?
21:31:39 <vincenz> and where do you see the python there?
21:31:49 <vincenz> deadbeef: uniba...bologna?
21:31:58 <deadbeef> bari
21:32:13 <vincenz> ah
21:32:18 <vincenz> sei su presto
21:32:51 <deadbeef> yes
21:32:58 <deadbeef> collapsed at like 9pm
21:33:16 <vincenz> newsham: where do oyou see the pythohn interpreter?
21:33:48 <lispy> Pseudonym: do they have an STFU architecture too? ;)
21:34:19 * Korollary kills lispy 
21:34:48 * lispy dies
21:34:54 <lispy> X_x
21:35:21 <newsham> http://haskell.org/haskellwiki/Yhc/Pyhi
21:35:23 <lambdabot> Title: Yhc/Pyhi - HaskellWiki
21:35:48 <vincenz> heh
21:36:15 <vincenz> not to mention that interpreting bytecode is even slower in a highlevel language as python
21:36:22 <vincenz> prolly faster to interpret higher levle concepts
21:36:52 <lispy> it's usually best to interpret at the level of turing machine
21:37:55 <vincenz> uhuh
21:40:12 <glguy> Hooray, yet anothing mathschallenge problem solved
21:40:30 <dons> cool :)
21:42:26 <glguy> 91/1369 :-)
21:42:41 <lispy> > 91/1369 * 100
21:42:42 <lambdabot>  6.647187728268809
21:42:53 <lispy> almost 7%!!
21:43:13 <glguy> top 7th percentile :-p
21:43:39 <lispy> so how does that site work?
21:43:43 <Korollary> math is so out of fashion now that Perelman quit.
21:43:45 <lispy> do you submit code?
21:43:49 <glguy> no
21:43:54 <newsham> glguy: when writing out the natural numbers in decimal, what is the faction of digits that are "4" ?
21:44:05 <Pseudonym> On the contrary, maths is seriously cool if it still lets you act like a drama queen!
21:44:12 <newsham> err..  rather.. what fraction of numbers has a digit "4"
21:44:25 <glguy> for all natural numbers?
21:44:28 <newsham> yah
21:44:43 <lispy> newsham: let's see...the denominator is inifinite in size....oh 0
21:45:00 <newsham> denominator?
21:45:11 <newsham> oh, in the faction.
21:45:19 <newsham> the numerator is also infinite in size.
21:45:23 <lispy> well, { # of numbers with 4 } / { size of naturals } :)
21:45:25 <lispy> yeah
21:45:44 <lispy> basically, i just wanted to point out that the question doesn't have a well defined answer
21:45:46 <newsham> but only aleph 0.  ;-)
21:45:54 <newsham> lispy: sure it does.  its a pretty simple question.
21:46:09 <glguy> I'm thinking :-p
21:46:24 <glguy> I guess i should figure out the number that don't have a 4
21:46:29 <glguy> and find the compliment of that
21:46:53 <lispy> newsham: then lets hear your reasoning on finding the answer
21:47:25 <glguy> does it limit out to 50%?
21:47:30 <Korollary> the fraction is the same as the numbers divisible by 4 within 1..100.
21:47:31 <newsham> lispy: my reasoning?  f(n) = percentage of numbers from 0 .. n that have a "4"
21:47:35 <newsham> f(n) as n->inf
21:47:41 <Pseudonym> > [ genericLength [ 1 | i <- [0..n], '4' `elem` show i ] / fromIntegral n | n <- iterate (*10) 10 ]
21:47:46 <lambdabot> Terminated
21:48:02 <Korollary> oh, I read it wrong
21:48:11 <Pseudonym> > [ genericLength [ 1 | i <- [0..n-1], '4' `elem` show i ] / fromIntegral n | n <- iterate (*10) 10 ]
21:48:15 <lambdabot> Terminated
21:49:16 <newsham> I actually used  f'(n) = number of numbers from 0..10**n with a "4"
21:49:16 <Pseudonym> Damn.
21:49:43 <newsham> figured out f' in closed form, and then ramped it up for some large n's divided by 10**n
21:50:10 <lispy> hm...i still think that's flawed, but i can't find the flaw
21:50:20 <glguy> seems to me like the fraction of number containing a 4 would approach 100%...
21:50:23 <Korollary> Find the fraction of numbers that don't have 4 in them. 1/9 + (1/9)^2 + ...
21:50:43 <newsham> answer's in http://www.thenewsh.com/~newsham/x/frac.py  if you wanna peek.
21:51:06 <Korollary> although 0 complicates things
21:51:27 <Pseudonym> The limit of that series is 1 / (1-r) - 1
21:51:33 <Pseudonym> Where r = 1/9
21:52:00 <Pseudonym> > let r = 1/9 in 1 / (1-r) - 1
21:52:02 <lambdabot>  0.125
21:52:21 <Pseudonym> > 1 - 0.125
21:52:22 <lambdabot>  0.875
21:52:24 <Pseudonym> That'
21:52:27 <Pseudonym> That's my guess.
21:52:36 <Korollary> It should be slighlty over 1/9 because the fraction is the same for 1,2,3,4 etc and it's lower for 0.
21:52:51 <Korollary> err slightly under
21:53:05 <newsham> its amusing because intuition gives people such different answers :)
21:53:14 <newsham> and once you see the real answer it makes good sense.
21:53:16 <lispy> x / 9 = .xxxxxx, for x in { 0 .. 9 }
21:53:29 <lispy> er i mean x / 9 = x (repeating)
21:53:30 <Korollary> it's not the same for 0
21:53:37 <Korollary> because it can't lead
21:53:53 <glguy> my thinking was that as the natural numbers approach infinity, the number of digits does, and as the number of digits does, the the numbers with no 4's approaches 0
21:54:04 <newsham> korollary: the number of 1 digit numbers with a zero in it is very close to th enumber of one digit numbers with a 4 in it.
21:54:11 <newsham> even more so for 2digit and 3 digit numbers
21:54:28 <Pseudonym> newsham: The problem is leading 0's.
21:54:35 <Pseudonym> You can't count 0's the same way as 4's.
21:54:53 <newsham> pseudo:  so of all the 3 digit numbers,  there's exactly one less that have a "0" than have a "4"
21:55:00 <newsham> because you count "444" but not "000"
21:55:07 <newsham> wait.. not true.
21:55:15 <newsham> sorry, my bad. :)
21:55:18 <Pseudonym> Right.
21:55:30 <Pseudonym> A three digit number may have any digit in the most significant place except 0.
21:55:32 <lispy> like explaining limits using 1/9 = .111..., 2/9 = .222..., ..., 7/9 . .777.., 8/9 = .888..., 9/9 = .9999... = 1 :)
21:55:49 <Pseudonym> BTW, nobody ever explains that correctly.
21:55:52 <newsham> hint:  pick a 1000 digit number at random.  what are the odds that it doesn't have at least one 4?
21:55:54 <Pseudonym> How .9999... = 1
21:56:02 <newsham> pick a 1000 ** 1000 digit number, what are the odds now?
21:56:20 <Thomas2_> Pseudonym: well, you need a fair amount of theory before you can explain that, no?
21:56:29 <lispy> Pseudonym: because 9/9 = 1
21:56:33 <Pseudonym> newsham: The problem with that is you can't pick a natural number at random.
21:56:37 <Pseudonym> Thomas2_: Not really.
21:56:43 <lispy> Pseudonym: it's an infinite series
21:56:47 <newsham> pseudo: i didnt say pick a natural number at random.
21:56:52 <newsham> I said "pick a 1000 digit number"
21:56:55 <Pseudonym> The proof is: Try to express 0.3999... in binary.  Distinguish it from 0.4.
21:57:13 <Korollary> Probability theory doesn't help here because it needs the precise computation we are trying to do.
21:57:14 <Thomas2_> ergh, that's not a proof
21:57:16 <Pseudonym> Actually, this is the problem with the question in general.
21:57:22 * Thomas2_ skulks back to #math
21:57:28 <Pseudonym> Thomas2_: No, but it's great intuition.
21:57:40 <Thomas2_> oh, sure, there are plenty of intuitive reasons for it
21:57:45 <dons> Thomas2_: we actually like proofs here :) the more mechanised, the better
21:57:45 <Korollary> try to express 1/3 in decimal
21:57:52 <newsham> the proof that a random 1 digit number doesnt have a 4 =   9/10
21:57:56 <newsham> err.. the prob
21:58:12 <newsham> the prob that a random 2 giti number doesnt have a 4 is (9/10)^2
21:58:22 <newsham> the prob that a random 3 digit number doesnt have a 4 is (9/10)^3
21:58:24 <Korollary> no
21:58:32 <dons> ?seen lispy
21:58:32 <lambdabot> lispy is in #oasis, #darcs, #haskell-blah and #haskell. I last heard lispy speak 1m 49s ago.
21:58:43 * lispy looks around widely
21:58:43 <glguy> Korollary: you are going to complain because of the zeros?
21:58:51 <dons> lispy: did you want to patch Url.hs to have composition with google work?
21:58:53 <Thomas2_> dons: well, I'd rather not appeal to isabelle etc
21:59:01 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ _ _ __ _..._ JIMBO WALES
21:59:02 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ _ _ .-' . . '-. THIS FUCKING PENISBIRD SHITS
21:59:04 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ _ _/. . ._ . ._\ DOWN YOUR NECK INTO YOUR STOMACH
21:59:04 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ _ /. . .(o) ./__) WHERE THE SHIT BURNS FOR THE REST OF
21:59:05 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ __ /. . .,_ . .| '| YOUR SHORT AND PATHETIC LIFE
21:59:07 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ |. . ./ .\ . /_/
21:59:09 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ _ /. . .`"`" . .} IT THEN GRIPS ONTO YOUR COCK WITH ALL ITS MIGHT
21:59:11 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ __ /. . . . . . . { AND INJECTS VARIOUS MUTAGENS INTO YOUR BLOODSTREAM
21:59:11 <newsham> kick teekwod
21:59:13 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ _ /. . . . . . . .} THROUGH ITS RAZOR-SHARP CLAWS WHERE IT REACTS
21:59:15 <lispy> dons: oh hm...maybe i should do that...i was supposed to read the manual for usb on osx :)
21:59:17 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ __ /. . . . .\/\ /\ { WITH YOUR VAST RESERVES OF FAT AND BLUBBER
21:59:17 --- mode: ChanServ set +o dons
21:59:19 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- _ _ |. . . . . .;``"``\
21:59:21 -Teekwod(n=roach@ppp-69-214-75-63.dsl.chcgil.ameritech.net)- __ /. . . . . . / ; ; ;| NOBODY IS SAFE FROM THE PENISBIRD, AND IT
21:59:21 --- mode: dons set +b *!*n=roach@*.dsl.chcgil.ameritech.net
21:59:22 <vincenz> TF
21:59:22 --- kick: Teekwod was kicked by dons (dons)
21:59:23 <vincenz> wTF
21:59:26 <vincenz> anyone else getting htis?
21:59:28 <Korollary> I thought he was banned
21:59:33 <dons> new ip address
21:59:38 <glguy> the ops are off their game :-p
21:59:40 <Korollary> low life scum
21:59:42 <vincenz> who is that guy?
21:59:53 <dons> Cale's stalker
21:59:54 <glguy> shouldn't lambdabot automagically protect us?
21:59:57 <lispy> dons: oh hm...maybe i should do that...i was supposed to read the manual for usb on osx :)
22:00:01 <vincenz> dons: no seriously
22:00:06 <dons> seriously.
22:00:09 <vincenz> o.O
22:00:14 <Cale> heh, no
22:00:15 <dons> glguy: how can lambdabot protect us?
22:00:16 <vincenz> Cale: your name is jimbo wales
22:00:16 <Pseudonym> Why don't I have a stalker?
22:00:20 <Cale> He just dislikes me
22:00:21 * vincenz stalks Pseudonym 
22:00:22 <lispy> vincenz: he was a prick in #math and then came here
22:00:23 <monochrom> Hard to imagine Cale has a stalker.
22:00:28 <Cale> because I ban him from #math
22:00:37 <vincenz> Cale: your name is Jimbo wales?
22:00:38 <Cale> because he's equally disruptive there
22:00:38 <Pseudonym> Cale: How did you manage that?
22:00:39 <Cale> no
22:00:47 <Cale> Pseudonym: manage what?
22:00:47 <glguy> dons: someone floods the channel like that... and lambdabot hits them witha kick
22:00:56 <Pseudonym> How come he doesn't keep coming back to #math?
22:01:05 * Pseudonym assumes it's a "he"
22:01:07 <dons> glguy: hmm.
22:01:08 <Cale> Pseudonym: he does
22:01:12 <Pseudonym> Ah, OK.
22:01:14 <vincenz> Pseudonym: path of least resistence
22:01:15 <lispy> dons: so one reservation i have is that the regexp we use to find urls is flawed
22:01:15 <Cale> Pseudonym: and I ban him again
22:01:22 <newsham> anyway, intuitively, as you start getting really really long numbers, virtually every number has at least one four in it.
22:01:22 <Pseudonym> I thought you might have thought of something that we haven't tried here.
22:01:31 <newsham> because there are so many digits.
22:01:33 <lispy> dons: so...if we use it with the @tiny-url command then some urls won't be tinable
22:01:44 <newsham> and the limit quickly approaches 100%
22:01:46 <glguy> new so the limit approaches 100%?
22:01:47 <vincenz> Cale: why does he call you that?
22:01:54 <Cale> vincenz: call me what?
22:01:55 <lispy> > (9/10)^100
22:01:57 <lambdabot>  2.6561398887587605e-5
22:02:04 <vincenz> Cale: jimbo wales
22:02:16 <Cale> Jimbo Wales is the creator of Wikipedia
22:02:16 <newsham> and Kor is right that I didnt properly do the accounting for zeros.  grr.  my bad.
22:02:17 <lispy> newsham: and you're computing 1 - (9/10)^n ?
22:02:21 <Cale> I have nothing to do with that
22:02:21 <vincenz> oh
22:02:42 --- mode: dons set -o dons
22:02:49 <newsham> glguy: yup.
22:02:55 <vincenz> oh
22:02:58 <vincenz> some people are weird
22:03:11 <weitzman> What does lambdabot do when you feed it a non-halting expression?
22:03:16 <dons> it halts it
22:03:21 <newsham> also interestingly, if you try to generate numbers sequentially and count, it starts getting so slow around 50% that you'll be scratching your head thinking if thats the limit
22:03:24 <dons> > last [1..]
22:03:24 <glguy> heh, you beat me to it
22:03:28 <lambdabot> Terminated
22:03:31 <newsham> but thats just because its really expensive to add more digits
22:04:07 * Pseudonym nods
22:04:20 <Pseudonym> Yeah, you're right.  Pretty much every number has a 4 in it.
22:04:48 <newsham> 4s are prolific.
22:04:53 <newsham> in N at least ;-)
22:05:01 <Thomas2_> I think you actually get 100% probability when you evaluate the probability up to infinite sets
22:05:42 <Thomas2_> that is, lim (x -> infinity) (percentage of numbers in [1..x] which have a 4) = 100
22:06:18 <newsham> thomas: yup.  in any base > 4.
22:06:25 <newsham> (4's are scarce in binary)
22:06:42 <Korollary> lifesucks
22:06:53 <glguy> bah, bases are artificial
22:07:10 <Pseudonym> Use the natural base: e
22:07:13 <newsham> so are alephs
22:07:49 <Korollary> dont use numbers. go with your gut regarding decisions about quantity.
22:07:54 <vincenz> Korollary: only if you ask nicely
22:08:03 <Pseudonym> Real maths is abstract.
22:08:16 <newsham> kor: or we could just use a unique symbol for every number
22:08:24 <newsham> rather than using a string of exponentially encoded symbols
22:08:59 <glguy> > let convertToTrueNumber n = replicate n () in convertToTrueNumber 10
22:09:01 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
22:09:01 <newsham> or the omre traditional 1,2,3, ... many ...
22:09:54 <Pseudonym> My 4 year old daughter asked if you can keep counting the other day.
22:10:10 <Pseudonym> After telling her yes, she confided: "But it really only goes to 20."
22:10:12 <dons> lovely!
22:10:32 <glguy> have her continue counting until she gets to the end
22:10:33 <Pseudonym> I resisted the urge to explain Graham's number.
22:10:35 <dons> she'll be up to recursion soon, I suppose :)
22:10:37 <newsham> and you of course told her that in that case, she'll never be able to drink?
22:10:48 <Pseudonym> In Australia, the magic age is 18.
22:10:54 <newsham> oh.  I see.
22:11:07 <newsham> this information woul dhave been useful 15 years ago.
22:11:18 <lispy> dons: so what should lambdabot say when the input fails to match the regexp?
22:11:20 * Pseudonym computes
22:11:24 <Pseudonym> You're old.
22:11:25 <lispy> dons: "Url not found." ?
22:11:55 <newsham> pseudo: not false.
22:11:58 <lispy> "Url not valid
22:12:08 <glguy> Does haskell have a ratio type?
22:12:15 <newsham> fractional?
22:12:15 <dons> lispy: say nothing, I think.
22:12:20 <dons> > 1 % 2
22:12:21 <lambdabot>  1%2
22:12:26 <dons> ?type 1 % 2
22:12:27 <lambdabot> forall a. (Integral a) => Ratio a
22:12:30 <dons> :)
22:12:30 <glguy> @index (%)
22:12:31 <lambdabot> Data.Ratio
22:12:31 <Pseudonym> newsham: Which is not the same as true in intuitionistic logic.
22:12:33 <dons> ?hoogle Ratio
22:12:33 <lambdabot> Data.Ratio :: module
22:12:33 <newsham> oh yah, ratio
22:12:34 <lambdabot> Ratio :: module
22:12:34 <lambdabot> Data.Ratio.Ratio :: data Ratio a
22:12:49 * Pseudonym is equally old, incidentally
22:12:51 <glguy> bitchin'
22:12:59 <lispy> dons: hmm...really, no feedback? I thought the rule was error -> feedback, success -> no feedback
22:13:04 <dons> hehe, spam is fun:
22:13:05 <dons> Dear Don,
22:13:05 <dons> Have you been considering furthering your graduate education?
22:13:05 <dons> Are these your personal challenges that prevent you from doing so?
22:13:06 <Korollary> that's why ghci makes a nice desk calculator
22:13:15 <dons> yes! my phd is getting in the way!
22:13:19 <lispy> dons: this is for explicit use of ?url-title and ?tiny-url not the context modes
22:13:38 <dons> lispy: hmm. explictly, then, "Not found" sounds ok
22:13:52 <Thomas2_> dons: I love the mail I get addressed "Dear Comp3231-list!"
22:14:01 <dons> hehe :)
22:16:11 * lispy likes the maybe function
22:16:13 <dons> Thomas2_: you doing much haskell hacking?
22:17:26 --- mode: ChanServ set +o dons
22:17:45 --- mode: ChanServ set -o dons
22:17:53 * dons practices 
22:18:09 <deadbeef> OMG TEH CHANSERV IS AILVE!!!11
22:18:22 <Thomas2_> dons: I'm about to actually. phil's going away, so I'm going to be implementing a patch
22:18:27 <newsham> "maybe f" = "liftM f" ?
22:18:32 <Thomas2_> speaking of which, I should probably install ghc
22:18:45 <dons> a patch for?
22:18:49 <dons> yeah, ghc's a good idea :)
22:19:08 <Thomas2_> dons: sel4. we've met, I think. I'm the guy who needs to shave who was in the dry run talk on wed.
22:19:20 <dons> ah yes :)
22:19:25 <Korollary> how romantic. You remembered!
22:19:30 <newsham> thom: you working on sel4?
22:19:33 <glguy> how might I fix this:
22:19:41 * Thomas2_ slaps Korollary with a trout
22:19:46 <glguy> > foldr (\x y -> x + 1 % y) [1,2,2,2,2]
22:19:46 <lambdabot>    Occurs check: cannot construct the infinite type: b = Ratio b
22:19:47 <lambdabot>    Expe...
22:19:48 <dons> Thomas2_: remember I said sel4 was the hot item round here ;)
22:19:58 <Thomas2_> newsham: i'm on l4.verified, but the distinction is getting fuzzy
22:20:10 <dons> oh right, phil's flying out for the HW very soon?
22:20:11 <Korollary> Oh I am way past being slapped with trouts. Philippa got me hooked on these whips.
22:20:21 <newsham> l4.verified == at a diff uni?
22:20:33 <Thomas2_> newsham: complementary project in formal methods
22:20:43 <dons> lispy++ -- more lambdabot patches
22:20:58 <lispy> :)
22:21:04 <Pseudonym> l4.verified should be a sticker attached to more hardware.
22:21:04 <glguy> > foldr1 (\x y -> x + 1 % y) [1,2,2,2,2]
22:21:05 <lambdabot>    Occurs check: cannot construct the infinite type: a = Ratio a
22:21:06 <lambdabot>    Expe...
22:21:15 <dons> lispy: oh, btw, you can use contextual stuff in offline mode now.
22:21:16 <Pseudonym> Sadly, L4 doesn't work with all hardware.
22:21:21 <dons> escape the string with: !
22:21:37 <Thomas2_> well, seems to work with a lot
22:21:38 <lispy> dons: i've yet to try offline mode :)
22:21:40 <dons> Thomas2_: hmm, we could just about run sel4 as a lambdabot plugin, no? ;)
22:21:43 <newsham> how does it fit in with sel4 (other than similar goals)?   same prototype?  same isabelle model?  entirely diff?
22:22:07 <dons> lispy: worth doing if you're actually hacking on the bot.... ;)
22:22:15 <lispy> dons: but i did notice that when you run the non-plugin version of lambdabot taht she doesn't always connect to irc on the first try...
22:22:27 <lispy> dons: ah
22:22:29 <dons> haven't noticed that myself
22:22:41 <lispy> maybe it's an osx thing
22:22:42 <Thomas2_> newsham: they're doing the API specification, we're doing the formalisation and verification. they're OS people, we're formal methods people.
22:22:46 <Korollary> glguy: where's the initial argument to foldr?
22:22:47 <lispy> er wait, this sin't oxs
22:22:55 <Cale> > foldr1 (\x y -> x + 1 / y) [1,2,2,2,2] :: Rational
22:22:57 <lambdabot>  41%29
22:22:59 <lispy> dons: maybe an amd64 debian thing i should say
22:23:01 <Cale> > foldr1 (\x y -> x + 1 / y) [1,2,2,2,2]
22:23:03 <lambdabot>  1.4137931034482758
22:23:03 <newsham> thom: ahh, so you guys are the ones taking the haskell prototype and pushing it into isabelle?
22:23:10 <Cale> > foldr1 (\x y -> x + 1 / y) [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
22:23:12 <lambdabot>  1.4142135623637995
22:23:15 <Thomas2_> if you've seen the translation paper, phil and kevin are sel4 and gerwin and dave are l4.verified.
22:23:16 <dons> Thomas2_: oh, you are the python-parser guy? :)
22:23:17 <glguy> Korollary: I forgot to type in in irc
22:23:24 <Thomas2_> as i said, the distinction is disappearing
22:23:30 <Thomas2_> dons: yes, that design decision would be my fault
22:23:37 <dons> ;)
22:24:05 <newsham> thom: what is the state of the project?   Are you guys done with the theorem proving or still doing that?  when do you think it will be translated down to C?
22:24:08 <lispy> i've noticed lately that it's useful to have the following function:
22:24:13 <dons> ?pretty let x = (+1) in map x [1..10]
22:24:13 <lambdabot>  i = let x = (+ 1) in map x [1 .. 10]
22:24:22 <newsham> (sorry for the 20 questions, i'm done now :)
22:24:23 <dons> ^^ haskell parsing in haskell ;)
22:24:27 <Thomas2_> heh yeah
22:25:07 <dons> lispy: oh, did you patch fix composition of tiny-url?
22:25:11 <lispy> > let { zipWith' f [] ys = ys; zipWith' f xs [] = xs; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys } in zipWith' (+) [1..3] [1..6]
22:25:13 <lambdabot>  [2,4,6,4,5,6]
22:25:16 <dons> the line ending issue?
22:25:20 <lispy> dons: i forgot to test, but it should
22:25:32 <dons> test please :) just run lambdabot offline
22:25:39 <Thomas2_> dons: yeah, I knew about the parser. at the time, we wanted to preserve comments and some layout features ($, `` etc) which I wasn't sure the frontend parser would. I should probably have investigated more
22:26:02 <dons> comments ah. good point. you need one of the external parsers for that. i'm just teasing though :)
22:26:08 <lispy> hm...
22:26:22 <dons> Thomas2_++ sel4 hackery
22:26:43 <lispy> dons: it looks like i fixed one bug but not the compose bug
22:26:53 <lispy> @. tiny-url google haskell.org
22:26:56 <lambdabot> http://www.haskell.org/
22:26:56 <lambdabot> Title: Haskell - HaskellWiki
22:26:59 <dons> its not loaded yet
22:27:05 <lispy> i know
22:27:11 <lispy> but that was the problem case righT?
22:27:16 <dons> yup
22:27:17 <Thomas2_> newsham: erm, not sure how much I should say. we're actually making changes to the spec at the moment ... the approach makes that easy to do, and I think it's good for the durability of the API we come up with, but it's postponing the implementation
22:27:22 <glguy> how do I get teh numerator of a ratio?
22:27:25 <dons> should just be a matter of stripping whitespace at the end.
22:27:27 <lispy> with my patch it doesn't find the title
22:27:33 <dons> ?hoogle numerator
22:27:34 <lambdabot> Ratio.numerator :: Integral a => Ratio a -> a
22:27:35 <lispy> dons: shouldn't the regexp do that?
22:27:40 <dons> glguy: lambdabot knows all
22:27:48 <newsham> thom:  cool.  I look forward to hearing more from you guys.  very interesting stuff.
22:27:51 <dons> lispy: hmm  maybe?
22:28:17 <lispy> dons: because now i call containsUrl on the text, but for some reason that's not fixing it
22:28:24 <Thomas2_> newsham: thanks. I for one hope you hear plenty :-0
22:28:53 <dons> lispy: what string is getting passed to tiny-url though? is it normalised?
22:28:58 <lispy> oh, the actually test case would be: @. tiny-url google http://wwww.haskell.org
22:29:18 <glguy> 90/* :-D
22:29:24 <lispy> dons: i don't know
22:29:45 <dons> glguy: hehe
22:30:01 <lispy> dons: process_    _ "url-title" txt -> fetchTitle gets the result of containsUrl txt
22:30:30 <lispy> so what do you mean by normalized?
22:30:34 <dons> oh, 'containsUrl' sounds like :: String -> Bool
22:30:38 <dons> not String -> String...
22:30:51 <lispy> for some reason containsUrl :: String -> Maybe String
22:30:55 <dons> i mean, stipped the whitespace from each end
22:30:56 <lispy> (i didn't write it)
22:31:07 <dons> ok
22:31:39 <Cale> http://xkcd.com/c26.html -- ahaha
22:31:41 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:31:42 <lispy> okay, so it looks for "https?://" to find the start of a url
22:31:53 <glguy> ?hoogle Rational -> Real
22:31:54 <lispy> and then takes until space
22:31:54 <lambdabot> No matches, try a more general search
22:32:10 <glguy> Rationals to decimal form?
22:32:13 <dons> lispy: so does the \n get left behind?
22:32:25 <Korollary> Cale: You are hopeless.
22:32:55 <lispy> dons: not sure...looking
22:33:19 <lispy> dons: adding it to ignoredUrlSuffixes to see it that helps
22:33:20 <Cale> http://xkcd.com/c24.html is actually better, I think
22:33:21 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:34:22 <Pseudonym> http://xkcd.com/c153.html
22:34:24 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:34:26 <dons> glguy:
22:34:27 <dons> > fromRational (1%2)
22:34:28 <lambdabot>  0.5
22:34:29 <Pseudonym> For some reason that's one of my favourites lately.
22:35:03 <lispy> dons: is there a trick to getting plugins to load in ghci?
22:35:12 <Cale> hehe
22:35:19 <dons> hmm, what are you doing now lispy ?
22:35:30 <lispy> i wanted to use ghci to help debug this :)
22:35:33 <dons> oh, you want to play plugins in ghci?
22:35:36 <lispy> call contrainsUrl directly and see what's going on
22:35:40 <dons> ok yes. its in the readme, iirc
22:35:45 <lispy> ah
22:35:49 <dons> Or with ghci (fastest turn around):
22:36:03 <dons> loading plugins is simpler, though
22:36:09 <Cale> http://xkcd.com/c32.html
22:36:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:36:11 <dons> just use the 'ghci' wrapper script
22:36:23 <lispy> what do you mean loading plugins?
22:36:27 <lispy> i just want to load Url.hs
22:36:34 <lispy> but it gives an error about the Plugin module not found
22:36:40 <dons> $ sh ghci Plugin/Url.hs
22:36:50 <dons> just passes to ghci the right flags
22:37:02 <lispy> huh,cool
22:37:24 * dons wonders how lispy ever wrote a lambdabot plugin without offline mode or ghc
22:37:27 <dons> ghci
22:37:50 <lispy> i just connected to a special channel no one uses :)
22:37:57 <dons> old skool
22:38:08 <lispy> hmm...
22:38:11 <Korollary> Probably #qbasic
22:38:21 <lispy> Prelude Plugin.Url> :t containsUrl
22:38:22 <lispy> <interactive>:1:0: Not in scope: `containsUrl'
22:38:35 <lispy> so, Plugin.Url is in scope, so why not containsUrl
22:38:38 <dons> touch it
22:38:47 <dons> looks like your're loading the compiled code?
22:38:53 <lispy> ah
22:38:55 <lispy> maybe
22:38:57 <lispy> no
22:39:00 <lispy> containsUrl is old
22:39:04 <lispy> that shouldn't be the problem
22:39:13 <dons> is containsUrl somewhere else?
22:39:25 <lispy> it's in Url.hs
22:39:48 <dons> you don't have an interpreted ghci prompt though...
22:39:51 * lispy feels like newb
22:39:57 <dons> so try: touch Plugin/Url.hs , then :reload in ghci
22:40:38 <lispy> yeah, that works
22:40:41 <lispy> weirdness
22:40:44 <lispy> thanks
22:41:14 <lispy> *Plugin.Url> containsUrl "\nhttp://www.google.com\n"
22:41:15 <lispy> Just "http://www.google.com"
22:41:17 <lambdabot> Title: Google
22:41:33 <lispy> so i dunno, seems like it's not really a newline problem
22:41:53 <dons> double check that it is actually broken?
22:42:11 <lispy> i checked with my bot and it's broken
22:42:20 <lispy> 22:33 <lispy> @. tiny-url google http://www.haskell.org
22:42:20 <lispy> 22:33 <notGiR> http://www.haskell.org/
22:42:20 <lispy> 22:33 <notGiR> Title:
22:42:22 <lambdabot> Title: Haskell - HaskellWiki
22:42:23 <lambdabot> Title: Haskell - HaskellWiki
22:42:29 <dons> did you reinstall it? are you running the most recent bot?
22:42:39 * lispy double checks
22:43:32 <lispy> yup, still a problem
22:44:17 <lispy> is there a way to make offline mode more readable?
22:44:28 <lispy> i hate all that "IrcMessage .." crap :)
22:45:26 <glguy> 88/* :-D
22:45:35 <dons> lispy: yeah, we could disable that stuff
22:45:43 * dons does so
22:47:34 <lispy> oh, i can just ignore it huh?
22:47:57 <musasabi> Is there a stable version of HaXml that does not depend on Data.FiniteMap ?
22:47:57 <dons> for now. i'm patching away
22:48:10 <dons> only the darcs version, musasabi, I thin.
22:48:19 <dons> ross was fixing that just yesterday, no?
22:48:39 <musasabi> yes, I remember that commit message.
22:48:44 <musasabi> It has a different API.
22:49:34 <Cale> http://xkcd.com/c74.html
22:49:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:52:20 <lispy> dons: here's the problem: *Plugin.Url> containsUrl "http://www.haskell.org/\nTitle: Haskell - HaskellWiki\n"
22:52:21 <lispy> Just "http://www.haskell.org/\nTitle:"
22:52:31 <dons> there we go
22:52:43 <lispy> so google foo is returning a lot more than i realized
22:53:02 <dons> the contextual stuff too then?
22:53:24 <lispy> i wonder why it's not killing off the \n
22:54:01 * foxy whispers C-x C-f in a north-westerly direction
22:54:15 <lispy> i sort of expect return $ stripSuffixes ignoredUrlSuffixes $ kind ++ url to do the trick
22:54:39 <musasabi> Modifying it was easy enough.
22:55:49 <lispy> oh
22:56:03 <lispy> if the string ends in \n then we're good to go
22:56:10 <lispy> the problem is that it ends in \nblah
22:56:11 <dons> foxy: I don't have time to look into it at the present
22:56:17 <dons> lispy: head . lines ?
22:56:46 <foxy> dons, okey
22:56:51 <lispy> well, that would work as long as the url is he head
22:57:00 <lispy> but what if that changes?
22:57:04 <lispy> then we have a bug again
22:57:22 <Cale> http://xkcd.com/c86.html
22:57:23 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
22:57:27 <Cale> (sorry) :)
22:59:21 <dons> lispy: you can't just use regexMatchAll to extract the url?
22:59:56 <dons> lispy: see how mkRegex is used in Karma.hs for "^nick++" karma
23:00:08 <Korollary> except it didn't work
23:00:11 <Korollary> @karma Korollary
23:00:12 <lambdabot> You have a karma of 4
23:00:15 <dons> Korollary++
23:00:19 <dons> ?karma Korollary
23:00:20 <lambdabot> Korollary has a karma of 5
23:00:25 <dons> you take back your words!
23:00:27 <Korollary> hmm
23:00:34 <Korollary> somebody karma--'d me then
23:00:43 <lispy> let url = takeWhile (`notElem` " \n\t\v") rest
23:00:46 <Korollary> It's also quiet
23:00:53 <dons> it is oh so quiet
23:00:54 <Pseudonym> Cale: #haskell-blah.  Just a suggestion.
23:00:54 <lispy> that's what makes sense to me
23:01:02 <Cale> yeah :)
23:01:06 <lispy> but i just tested it and it didn't work...
23:01:13 <lispy> oh
23:01:21 <lispy> n/m, tested the worng functino ;)
23:01:38 <lispy> okay, time to test the bot
23:05:04 <glguy> 87/* :-D and now me >>= bed
23:05:21 <dons> nice
23:05:46 <lispy> that was way harder than it should have been ;)
23:05:48 <glguy> everyone remember to represent Haskell on Mathschallenge.net
23:05:54 <Korollary> No
23:05:55 <glguy> woot, g'night
23:05:57 <glguy> ;)
23:05:59 <Korollary> nite
23:06:08 <lispy> as we say at work, "My english is to represent"
23:06:12 <dons> thanks lispy
23:06:22 <lispy> np, i'm glad it's fixed
23:06:30 <dons> lispy++ --patches
23:07:13 <lispy> i've now needed this function in three different programs
23:07:14 <lispy>             zipWith' _ [] ys = ys
23:07:14 <lispy>             zipWith' _ xs [] = xs
23:07:14 <lispy>             zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
23:07:26 * lispy adds it to his library of things he likes to have around
23:07:37 <dons> mmm, the 50th anniversary of UNSW's first electronic computer, UTECOM on Monday
23:07:47 <lispy> cool
23:07:55 <dons> Pseudonym: there you go, apparently UTECOM beat usyd by 1 day
23:08:27 <araujo> hello hello!
23:09:12 <Pseudonym> dons: Sorry, to what?
23:09:15 <Pseudonym> Ah.
23:09:17 <Pseudonym> Cool.
23:09:20 <dons> oh, to having a computer :)
23:09:58 <Pseudonym> The University of Melbourne had one before that.
23:10:13 <Pseudonym> The fact that it was a cast-off from the CSIR is completely irrelevant.
23:10:14 <dons> yeah, didn't cisro have the first in the ~1950?
23:10:16 <dons> right
23:10:31 <Pseudonym> Unimelb got CSIRAC in June 1956,
23:10:43 <dons> oh so 1956 was a busy year?
23:10:53 <Korollary> Pong came out that year, yes?
23:11:03 <dons> that would mean unimel, usyd and unsw all got machines between june-sep 1956
23:11:07 <Pseudonym> And Hunt the Wumpus, yes.
23:26:13 <dons> grr, i'm not sure i like this new core/non-core stuff
23:26:13 <dons> ghc-6.5: unknown package: network-2.0
23:26:53 <monochrom> Does -make solve it?
23:27:19 <dons> no, its the new ghc 6.5 stuff, i've mis-built it somehow.
23:29:24 <Korollary> comedy: http://hope.cs.rice.edu/twiki/pub/WG211/M3Schedule/foozles.pdf
23:32:07 <lispy> Korollary: that's no laughing matter
23:33:44 <lispy> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:33:44 <lambdabot> Done.
23:33:53 <lispy> bf seems to be broken again...
23:33:55 <lispy> yay!
23:33:56 <monochrom> bf = ?
23:34:01 <lispy> brainfuck
23:34:46 <lispy> okay, it seems to have produced the right output, but the cleanup killed it
23:34:50 <dons> did we sort out all issues with it?
23:34:56 <dons> since i disabled it :)
23:34:59 <dons> just in case...
23:35:10 <lispy> oh, is it disabled?
23:35:16 <dons> yes
23:35:28 <dons> so, does time limiting work? and we don't allow non-printable chars?
23:35:31 <lispy> okay, well it works great on my bot so that would explain it :)
23:35:39 <dons> ok, try again now
23:35:46 <lispy> depends on what you mena by non-printable chars and yes it only gets 3 seconds
23:35:51 <lispy> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:35:51 <lambdabot>  Hello World!
23:36:09 <lispy> ?bf ++++[>++++++++<-]>[.+]
23:36:10 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk...
23:36:13 <dons> i hold you personally responsible, lispy, if there's security issues in it...
23:36:19 <dons> ;)
23:36:19 <lispy> hehe
23:36:42 * dons -> home
23:36:49 <lispy> ?bf ++++[>+++++++++++<-]>[.+]
23:36:49 <lambdabot>  ,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw...
23:36:54 <lispy> ?bf ++++[>++++++++++++++++<-]>[.+]
23:36:55 <lambdabot>  @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
23:37:05 <lispy> as you can see it's throwing away other stuff
23:37:10 <lispy> ?bf ++++[>+++++++++++++++++++++<-]>[.+]
23:37:10 <lambdabot>  TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
23:37:15 <lispy> ?bf ++++[>++++++++++++++++++++++++++<-]>[.+]
23:37:16 <lambdabot>  hijklmnopqrstuvwxyz{|}~
23:37:35 <vincenz> ah
23:38:01 <Cale> You should probably kill off the 007F as well.
23:38:11 <deadbeef> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:38:12 <lambdabot>  Hello World!
23:38:15 <lispy> dons: i think the only possible exploit would be with unsafeRead unsafeWrite, but i mod the indices to read/write by the size of the array
23:38:17 <deadbeef> omg! what's it
23:38:31 <lispy> Cale: the ^?
23:38:35 <Cale> yes
23:39:29 <lispy> > filter isAscii ['a'..]
23:39:31 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL"
23:39:44 <lispy> interesting
23:40:01 <lispy> that's the same line i use to scrub the output of bf
23:47:15 <deadbeef> wondering if there's something similar to setenv() in haskell
23:50:12 <lispy> deadbeef: to setup an env before running a program?
23:50:12 <dolio> ?hoogle setEnv
23:50:13 <lambdabot> No matches found
23:50:17 <dolio> ?hoogle getEnv
23:50:18 <lambdabot> System.getEnv :: String -> IO String
23:50:19 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
23:50:31 <lispy> ?hoogle setEnvironment
23:50:32 <lambdabot> No matches found
23:50:42 <dolio> Ah.
23:50:43 <deadbeef> lispy: yes
23:50:44 <dolio> ?hoogle putEnv
23:50:46 <lambdabot> No matches found
23:50:47 <lispy> ?hoogle [(String, String)] -> IO ()
23:50:48 <lambdabot> No matches, try a more general search
23:50:56 <dolio> System.Posix.Env.putEnv
23:50:56 <lispy> deadbeef: yeah, it exists but i don't remember the name
23:51:13 <deadbeef> thanks a lot guys
23:51:16 <dolio> Or setEnv
23:51:50 <deadbeef> ?fptools System.Posix.Env.putEnv
23:51:51 <lambdabot> System.Posix.Env.putEnv not available
