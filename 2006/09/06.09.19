00:02:35 <lispy> i just snarked the favicon.ico from haskell.org
00:02:44 <lispy> so no more error about that missing :)
00:03:30 <dons> good
00:06:30 <lispy> it amazes me that webbrowsers still don't automatically convert urls that appear in 'plaintext' to hyperlinks
00:11:26 <bartw> lispy: hmz yeah that is weird
00:11:47 <bartw> pretty much all other apps do that now
00:11:51 <lispy> yup
00:12:12 <lispy> some day maybe i'll write a ff extension for it :)
00:12:28 * lispy hopes someone beats him to it
00:12:47 <lispy> just emailed the mod_fcgid list asking for help with logging
00:13:00 <lispy> it looks like this isn't the only fastcgi implementation for apache
00:13:05 <lispy> so, maybe i'm just using the wrong one
00:18:19 <psnl> @prirate
00:18:19 <lambdabot> Unknown command, try @list
00:18:24 <psnl> @pirate
00:18:24 <lambdabot> Unknown command, try @list
00:18:28 <lispy> ?arr
00:18:28 <psnl> @list
00:18:28 <lambdabot> Arrr!
00:18:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:18:37 <psnl> lispy: ta
00:18:38 <lambdabot> psnl: You have 1 new message. '/msg lambdabot @messages' to read it.
00:36:38 <bartw> ?arr !
00:36:39 <lambdabot> Yeh scurvy dog...
00:56:12 <lispy> okay, i should be asleep
00:56:22 <lispy> but instead, i was improving the lambdaweb page
00:56:29 <lispy> now it gives some example commands
01:10:34 <mux> ?seen dons
01:10:34 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 7m 3s ago.
01:46:00 <Bobstopper> Should this bother me?
01:46:10 <Bobstopper> Prelude Network.Socket> PortNum 1
01:46:11 <Bobstopper> 256
01:47:40 <dcoutts__> dons: ping
01:47:43 <dcoutts__> audreyt: ping
01:48:05 * dcoutts__ curses his flakey wireless connection
01:49:14 <roconnor> @arr
01:49:15 <lambdabot> I want me grog!
01:49:28 <lucca> @yarr
01:49:29 <lambdabot> Shiver me timbers!
01:50:30 <wilx|wrk> Bobstopper: That looks like native versus network byte order conflict.
01:50:48 <wilx|wrk> Dunno what should show show.
01:51:13 <sieni> http://en.wikipedia.org/wiki/Shiver_my_timbers
01:51:16 <lambdabot> http://tinyurl.com/fjxps
01:51:39 <sieni> good that that that that bot said is now clear
01:51:41 <Bobstopper> wilx|wrk: Hopefully that's all it is then. I was a little surprised show does that though.
01:52:14 <dons> dcoutts__: ?
01:52:32 <dcoutts__> dons: did you see my thoughts about a StringBuilder ?
01:52:44 <dcoutts__> sound feasable? not too many race conditions ?
01:52:50 <dons> haven't had time to read the logs today. i'll have a look
01:53:03 <dcoutts__> from -overflow
01:53:51 <dcoutts__> the headline is O(1) pure appends when used in a single-threaded way
01:54:07 <dcoutts__> and keeping O(1) conversion to ByteString
01:54:29 <dcoutts__> to strict ByteString that is
01:57:43 <roconnor> @type (\f -> (\x -> f (x x))(\x -> f (x x))
01:57:45 <lambdabot> parse error (possibly incorrect indentation)
01:57:49 <roconnor> @type (\f -> (\x -> f (x x))(\x -> f (x x)))
01:57:50 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
01:57:52 <lambdabot>    Expected type: t
02:00:07 <roconnor> How do I use the preprocessor to make one function definition for HUGS and another definition for GHC?
02:01:16 <dcoutts__> #ifdef __HUGS__
02:01:47 <dcoutts__> #ifdef __GLASGOW_HASKELL__
02:01:48 <deadbeef> hi dear friends
02:01:50 <deadbeef> sup
02:02:22 <dcoutts__> it be International Talk Like a Pirate Day! that's what be up!
02:02:23 <dcoutts__> @yarr!
02:02:24 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
02:02:59 <Syzygy-> @arr
02:02:59 <lambdabot> Swab the deck!
02:06:09 <roconnor> @where GHC
02:06:09 <lambdabot> http://haskell.org/ghc
02:13:41 <tibbe> could someone help me out with a small language issue. is this correct English: "the different states the client and the server have during the conversation", the word have looks a bit odd to me
02:15:37 <dcoutts__> tibbe: could you give us the full sentance?
02:16:38 <tibbe> "A conversation's life cycle is the different states the client and the server have during the conversation and the messages sent back and forth to change the parties' state."
02:16:47 <tibbe> the whole thing sounds strange to me
02:16:50 <dcoutts__> aye
02:16:54 <tibbe> (and I wrote it!)
02:16:58 <dcoutts__> :-)
02:17:08 <tibbe> I probably need to break it up
02:17:29 <tibbe> but does a "thing" have different state, or possess
02:17:42 <tibbe> see
02:17:46 <tibbe> I can't express it
02:17:48 <dcoutts__> same really
02:17:56 <mlh> nah, I was going to suggest 'sequence of states' or something like that
02:18:03 <dcoutts__> sequence is good
02:18:07 <dcoutts__> or trace
02:18:08 <tibbe> mlh, hmm, I'll try that
02:18:21 <aleator> ho. How do I pass options to linker using 'ghc --make' (-R namely)?
02:18:40 <dcoutts__> aleator: -optl
02:18:44 <tibbe> so the sequence of states that client and the server "goes thorugh"?
02:18:50 <dcoutts__> aleator: that passes them to gcc
02:18:51 <tibbe> through*
02:19:05 <aleator> dcoutts__: thanks. as usual :)
02:19:12 <dcoutts__> aleator: so if you need to get gcc to pass them to the linker then you need an additional escape
02:19:32 <dcoutts__> aleator: iirc it's: -optl-Wl,-R
02:19:34 <mlh> yeah "goes through" a little better than "have" I guess
02:19:49 <mlh> is a little ..
02:19:57 <tibbe> ok
02:19:58 <tibbe> thanks
02:21:40 <dcoutts__> tibbe: your trace contains both the states and the messages that make them change state?
02:21:46 <dcoutts__> isn't that somewhat redundant?
02:22:19 <dcoutts__> couldn't you just make it the messages, it being the messages that give state changes
02:22:59 <tibbe> dcoutts__, I'm trying to describe a finite automaton, before introducing finite automata
02:23:07 <dcoutts__> :-)
02:23:12 <tibbe> for describing network protocols
02:23:18 <tibbe> i.e. stateful SOAP
02:23:53 <vincenz> hi
02:23:59 <tibbe> hi
02:25:14 <bartw> tibbe: auch
02:25:27 <tibbe> bartw, ? :)
02:25:43 <tibbe> you think it's a bad idea?
02:25:56 <bartw> tibbe: maybe show an example and then explain finite automata
02:26:35 <tibbe> bartw, yes, I've given some and I broke up the sentence into two. Makes more sense now
02:26:50 <tibbe> more like, there are states. state are changed by messages
02:27:00 <tibbe> I was trying to say too much at once I think
02:27:45 <bartw> the state isn't chagned, another state became 'current'
02:28:19 <bartw> altough depends on you audience
02:28:50 <bartw> i know people who would think you're changing some attribute of the states :)
02:29:36 <kzm> Hi.
02:30:19 <kzm> I'd like to have build a data structure that is optimized if possible - specifically, I want to encapsulate an IntMap for Int, but Map Integer Int otherwise.
02:31:10 <kzm> In the process, I'd like to use a more general type signature ((Integral a => .. a) instead of just ...Int), but ghc complains about that.
02:32:11 <kzm> Since Int is a special case of Integral a => a, I'm not sure why this restriction is present.  Suggestions?
02:33:28 <bartw> ? you want a Map of Integer but use Map Int if the value's are valid for Int ?
02:34:21 <roconnor> kzm, how much preformance do you lose by just using Integer everywhere?
02:34:42 <kzm> A bit.
02:35:01 <kzm> And also by using Data.Map Int Int, there is a noticable loss compared to Data.IntMap INt
02:37:11 <roconnor> ah
02:37:37 <roconnor> presumably this can somehow be done with type classes?
02:38:15 <roconnor> So long as Map and IntMap are not part of the interface.
02:38:42 <roconnor> ... although it might lead to writing a bunch of instances...
02:38:47 <roconnor> hmm
02:39:42 <mux> ?dons
02:39:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:39:46 <mux> erm
02:39:48 <mux> ?seen dons
02:39:49 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 46m 58s ago.
02:39:53 <mux> dons: ping
02:43:36 <araujo> morning!
02:44:41 <audreyt> dcoutts__: pong
02:44:41 <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.
02:44:51 <dcoutts__> audreyt: ah yes, StringBuilder
02:44:54 <audreyt> lambdabot: @messages
02:44:55 <lambdabot> agentzh said 4h 40m 14s ago: i don't know how to reply malon's p6c mail: http://www.nntp.perl.org/group/perl.perl6.compiler/1511 maybe you're willing to help? :)
02:45:00 <dcoutts__> audreyt: wondering what API you need
02:46:08 <audreyt> append-with-stringbuilder
02:46:20 <audreyt> append-with-bytestring
02:46:37 <audreyt> substr
02:46:41 <audreyt> that's pretty much it
02:46:44 <dcoutts__> and convert to bytestr presumably?
02:46:55 <audreyt> actually as long as it's Stringable I don't care
02:47:06 <audreyt> but sure, convert to/fromo bytestr.
02:47:08 <dcoutts__> convert to bytestring then gives you append-with-stringbuilder and substr
02:47:40 <dcoutts__> audreyt: the thing I'm thinking of lets you append in O(1) but if you append to an older value then it costs O(n)
02:47:54 <audreyt> reminds me of diffarray
02:47:58 <dcoutts__> exactly
02:47:59 <audreyt> I think that's perfectly fine
02:48:10 <audreyt> so what does it llok like?
02:48:15 <dcoutts__> so if you take a substr and append to that it's O(n)
02:48:29 <audreyt> nod
02:48:31 <dcoutts__> it's only O(1) while it's the 'head' value
02:48:46 <audreyt> sure, though append can happen bothways
02:48:55 <dcoutts__> append and prepend ?
02:49:08 <audreyt> yes
02:49:09 <dcoutts__> that's a bit harder
02:49:29 <audreyt> though append is surely more common
02:49:50 <audreyt> SB ++ BS -- more common
02:49:54 <audreyt> BS ++ SB -- less so
02:49:55 <dcoutts__> prepend could be just append to the other one :-)
02:50:09 <audreyt> oh, you're talking about  SB ++ SB
02:50:10 <audreyt> sure
02:50:10 <audreyt> :)
02:50:17 <dcoutts__> but again that might incurr O(n)
02:50:36 <audreyt> k
02:50:47 <audreyt> so it's really optimizing for the SB++BS case
02:50:52 <dcoutts__> yes
02:51:05 <dcoutts__> or even single byte adds
02:51:06 <audreyt> cool!
02:51:08 <audreyt> url? :)
02:51:19 * dcoutts__ points inside his head
02:51:50 <dcoutts__> data StringBuilder = StringBuilder ByteString Int (IORef Int)
02:52:02 <dcoutts__> it involves imperitive trickyness
02:52:13 <dcoutts__> but presents a pure api
02:52:27 <audreyt> I'd be very keen to try it out and document and hack it and report findings :)
02:53:12 <kzm> roconnor, the way I've solved it previously is by building both structures (but lazily delaying them, of course), and calling a polymorphic continuation function with one of them.
02:53:13 <dcoutts__> basic idea is that you track the free space at the end of the BS
02:53:25 <dcoutts__> by two methods
02:53:41 <dcoutts__> the free space when the current ByteString was made and the free space now
02:54:09 <dcoutts__> if they're the same then you know you can mutatively write into the free space and increase the length of the ByteString
02:54:21 <audreyt> ahhh right
02:54:22 <dcoutts__> if they're not the same then you've got an old value and you'll have to copy
02:54:29 <dcoutts__> and then append
02:54:44 <audreyt> and we can start with an arbitrary alloc, and increase dynamically
02:54:56 <dcoutts__> right, just double when we run out of space
02:55:07 <dcoutts__> there's a possible race condition in reserving the extra space
02:55:28 <dcoutts__> so that needs to be considered carefully in the light of concurrenly appending
02:55:52 <dcoutts__> in the worst case the Int would have to be protected with an MVar
02:55:59 <dcoutts__> but I think it could be done with an IORef
02:56:16 <dcoutts__> and actually I think it might be able to do it locklessly
02:56:29 <dcoutts__> by detecting when the race occured and both copying
02:56:57 <dcoutts__> ie safe for concurrent append, just not fast
02:57:08 <dcoutts__> but then we're optimising for single threaded use
02:57:45 <audreyt> yup
02:58:08 <dcoutts__> one could imagine reserving free space and the beginning and end
02:58:14 <dcoutts__> to allow fast prepend and append
02:58:21 <audreyt> actually prepend could involve a simple memmove
02:58:24 <dcoutts__> but then you need two IORefs and two length
02:58:30 <audreyt> since memmove is usually fast-ish
02:58:37 <audreyt> still O(n), sure
02:58:41 <audreyt> but not like malloc
02:58:42 <dcoutts__> right, it can be simpler if you optimise for only append or only prepend
02:59:10 <audreyt> I think only for append makes most sense
02:59:13 <dcoutts__> we cannot mutate the bit of the buffer that has allready been reserved
02:59:36 <dcoutts__> since we can hand that bit out as a ByteString which must not get mutated
02:59:46 <audreyt> understood
02:59:56 <dcoutts__> so you can't shift it up to make space at one end
02:59:59 <audreyt> nodnod
03:00:05 <audreyt> but still it looks like a win
03:00:10 <dcoutts__> aye
03:00:14 <dcoutts__> if you're mostly doing appends
03:00:25 <dcoutts__> one could build it for prepends too obviously
03:00:53 <audreyt> *nod*
03:00:54 <dcoutts__> and I guess doing both is possible but probably wastes more space on average
03:01:01 <audreyt> I don't think it's worth it
03:01:05 <dcoutts__> ok good
03:01:06 <audreyt> as you observed, in SB++SB
03:01:17 <audreyt> the buffer on the fst as likely as good as snd
03:01:27 <audreyt> so reserve bothways doesn't actually buy us anything
03:01:47 <dcoutts__> well it could be O(1) if you reserve both ways
03:01:54 <dcoutts__> if you're doing short ++ long
03:02:19 <audreyt> but in practice long++short occurs more often...
03:02:24 <dcoutts__> good
03:02:56 <dcoutts__> I was trying to grok if it'd be possible with a lazy bytestring too
03:03:02 <audreyt> I need to run for dinner, but this sounds like a nice win
03:03:09 <dcoutts__> ok, later
03:03:11 <audreyt> thanks for thinking about it :)
03:03:15 <dcoutts__> :-) np
03:03:25 <mux> ?version
03:03:25 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
03:03:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:03:46 <dcoutts__> dons: can you understand the lazy case?
03:04:01 * dcoutts__ suspects dons is busy with other things
03:04:18 * dcoutts__ suspects he shouldn't pester dons
03:05:26 * kolmodin is off to lunch
03:05:59 <audreyt> fwiw in my sqlite GROUP_CONCAT patch
03:06:09 <audreyt> the initial extra alloc is 256
03:06:39 <audreyt> which worked best for one app -- but I'm not sure what a good global num will be
03:06:50 <dcoutts__> what does that mean exactly?
03:07:00 <audreyt> in that when you pack a SB
03:07:00 <dcoutts__> initial free space is 256?
03:07:06 <audreyt> allocate always 256 more bytes at the end
03:07:06 <dcoutts__> and then double from there?
03:07:10 <audreyt> yes
03:12:41 <aleator> Anyone got any ideas if would be possible that ghc compiled program, with ffi, on x86_64 would miscalculate floating point numbers, without it beeing user fault?
03:15:17 <norpan> aleator: it seems unlikely
03:16:32 <aleator> To me too.. However, it seems that same program works with x86.
03:16:56 <aleator> but it is probably that ghastly opencv library that is the cause..
03:24:52 <psnl> @arr
03:24:53 <lambdabot> Avast!
03:48:49 <aes2> Is there an existing Haskell function which does this? int f(int k){ for(int i=0 ; k>0 ; k=k/2){i++;} return i;}
03:53:08 <Lemmih> aes2: log?
03:55:28 <dons> hmm, perhaps:
03:55:32 <dons> ?pretty let f c = let g i k | k <= 0 = i | otherwise = g (i+1) (k`div`2) in g 0 c
03:55:33 <lambdabot> "Parse error" at column 74
03:55:47 <dons> ?let f c = let g i k | k <= 0 = i | otherwise = g (i+1) (k`div`2) in g 0 c
03:55:48 <lambdabot> <local>:10:0:     Multiple declarations of `L.f'     Declared at: <local>:1:1...
03:55:54 <dons> ?undefine
03:55:56 <dons> ?let f c = let g i k | k <= 0 = i | otherwise = g (i+1) (k`div`2) in g 0 c
03:55:56 <lambdabot> Undefined.
03:55:57 <lambdabot> Defined.
03:56:06 <dons> > L.f 100
03:56:07 <lambdabot>  7
03:57:32 <dons> which looks like a scanl of some flavour
03:58:03 <Lemmih> > ceiling $ logBase 2 100
03:58:05 <lambdabot>  7
03:59:35 <dons> > length . takeWhile (>0) $ scanl (\k _ -> k `div` 2) 100 [0..]
03:59:36 <lambdabot>  7
03:59:56 <aes2> Lemmih seems to be the winner :)
04:00:26 <dons> yep
04:01:17 <aes2> I thought iterating quot and then takewhile /= 0 and then taking the length would be a nice solution.
04:01:58 <dons> > findIndex (<= 0) $ scanl (\k _ -> k `div` 2) 100 [0..]
04:02:00 <lambdabot>  Just 7
04:02:12 <dons> ?pl \k _ -> k `div` 2
04:02:13 <lambdabot> const . (`div` 2)
04:02:31 <dons>  > findIndex (<= 0) . scanl (const . (`div` 2)) 100 $ [0..]
04:02:44 <dons> > findIndex (<= 0) . scanl (const . (`div` 2)) 100 $ [0..]
04:02:45 <lambdabot>  Just 7
04:02:58 <aes2> > logBase 2 0
04:02:59 <lambdabot>  -Infinity
04:03:39 <aes2> I get a different answer on my machine
04:03:46 <aes2> I get -179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
04:04:09 <aes2> Which is small, is nowhere near -Infinity :?
04:04:36 <dons> using the same code, logBase 2 0 ?
04:04:57 <aes2> dons: no, my mistake
04:05:16 <aes2> > (ceiling . logbase 2) 0
04:05:17 <lambdabot>  Not in scope: `logbase'
04:05:22 <aes2> > (ceiling . logBase 2) 0
04:05:23 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
04:05:31 <aes2> right
04:05:55 <dons> do you see how scanl generalises the for loop?
04:06:00 <dons> its a useful thing to remember
04:06:01 <dcoutts__> dons: any thoughts on said StringBuilder ?
04:06:22 <dons> dcoutts__: I'll need to read with my morning coffee and give you a considered reply
04:06:27 <bartw> anyone know a profiler that can show me my memory access patterns ?
04:06:34 <dcoutts__> dons: ok :-)
04:06:36 <dons> bartw: ghc -prof -auto-all ?
04:06:45 <dcoutts__> bartw: valgrind perhaps
04:06:52 <bartw> and windows ?
04:07:01 <dcoutts__> some intel tool
04:07:14 <aes2> dons: no, how do multiple counters work in one loop?
04:07:38 <dcoutts__> dons: morning coffee is essential to try and understand the concurrency implications :-)
04:07:45 <dons> oh, in this case you only need 1, but in general you pass a tuple of values to the scanl
04:08:16 <dons> > scanl (\k i -> k `div` 2) 100 [0..]
04:08:17 <lambdabot>  [100,50,25,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:08:40 <dons> (the use of the 'i' in the C code is to work around the lack of lazy lists in C ;)
04:09:28 <dons> > scanl (\(k,j) i -> (j+1,k `div` 2)) (0,100) [0..]
04:09:29 <lambdabot>  [(0,100),(101,0),(1,50),(51,0),(1,25),(26,0),(1,13),(14,0),(1,7),(8,0),(1,4)...
04:09:45 <bartw> guess ill have to write something myself
04:09:46 <dons> > scanl (\(k,j) i -> (k `div` 2, j+1)) (0,100) [0..]
04:09:47 <lambdabot>  [(0,100),(0,101),(0,102),(0,103),(0,104),(0,105),(0,106),(0,107),(0,108),(0,...
04:10:00 <dons> silly dons
04:10:14 <aes2> The only good way of say adding elements to a tree is using foldl, right?
04:10:35 <dons> > scanl (\(k,j) _ -> (k `div` 2, j+1)) (100,0) [0..]
04:10:36 <lambdabot>  [(100,0),(50,1),(25,2),(12,3),(6,4),(3,5),(1,6),(0,7),(0,8),(0,9),(0,10),(0,...
04:11:12 <aes2> something like foldl (\tree element->insert element tree) emptyTree listOfElements
04:11:21 <dons> would be one way.
04:17:09 <aes2> @type findIndex
04:17:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
04:17:23 <aes2> @where findIndex
04:17:23 <lambdabot> I know nothing about findindex.
04:17:29 <dons> ?index findIndex
04:17:29 <lambdabot> Data.List, Data.Map
04:17:39 <dons> or more generally,
04:17:41 <dons> ?hoogle findIndex
04:17:43 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
04:17:43 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
04:18:05 <bartw> hmz, why not Maybe Int for Map
04:18:23 <dons> hmm
04:18:25 <SamB> hmm, I have some patches but am unable to test them.
04:18:35 <SamB> well. maybe.
04:18:41 <dons> findIndex k t
04:18:42 <dons>   = case lookupIndex k t of
04:18:42 <dons>       Nothing  -> error "Map.findIndex: element is not in the map"
04:18:42 <dons>       Just idx -> idx
04:18:47 <dons> SamB: ?
04:18:56 * SamB tries a simpler property
04:20:21 <dcoutts__> dons: mm, another case where fusable IO might help is on output, imagine outputting directly into a mmaped files without any copy.
04:20:33 <aes2> dons: your code is incorrect for input 2.
04:20:55 <dcoutts__> dons: ie like writeStrUp but in IO and into a mmaped file, growing then file when it overflows
04:20:56 <SamB> oh sweeeeet
04:21:17 <SamB> lambdabot> scheck (\f b -> (f . not) b == (not . f) b)
04:21:18 <SamB>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
04:22:16 <SamB> dons: patches ho!
04:23:45 <dons> ?check \n -> ceiling (logBase 2 (fromIntegral n)) == (fromJust . findIndex (<= 0) . scanl (const . (`div` 2)) (n::Int)) [0..]
04:23:46 <lambdabot>  Falsifiable, after 5 tests: 2
04:23:51 <dons> :)
04:24:50 <SamB> @scheck (\f b -> (f . not) b == (not . f) b)
04:24:51 <lambdabot>     instance (Serial a, Show a, Show b) => Show (a -> b) -- Imported from ...
04:25:08 <SamB> dons: you didn't rebuild yet!
04:25:16 <dons> hmm?
04:25:28 <SamB> @scheck (\f b -> (f . not) b == (not . f) b)
04:25:28 <lambdabot>     instance (Serial a, Show a, Show b) => Show (a -> b) -- Imported from ...
04:25:30 <dons> (I rebuild once a week now ...)
04:25:43 <aes2> dons: Lemmih's function was incorrect too for input 0 and 1.
04:25:49 <SamB> you don't have to reboot it or anything
04:25:53 <dons> ah ok
04:25:59 <dons> using the patch that just arrived SamB
04:26:24 <dons> ?
04:26:28 <SamB> yes
04:26:54 <dons> I have a feeling these extra files should end up in a botlib library at some point
04:26:58 <SamB> see, as it stands RunSmallCheck has two Show instances for (->)
04:27:08 <SamB> which does *not* work
04:27:14 <dons> ah
04:27:16 <dons> nice
04:27:23 <dons> thanks for looking in to that
04:27:31 <dons> SamB++
04:28:18 <SamB> well, I read in the SmallCheck announcement that it was supposed to be able to show functions, and when I tried it I got that nasty partial message...
04:28:19 <vincenz> nee
04:28:38 * vincenz whoopses, wrong window
04:28:40 <dons> see, I don't read stuffs. i just hack the code :)
04:28:43 <SamB> and I guessed it was because of the Show instance lambdabot usually uses for (->)...
04:28:52 <dons> and guess right :)
04:29:59 <SamB> @scheck (\f b -> (f . not) b == (not . f) b)
04:30:03 <lambdabot>     instance (Serial a, Show a, Show b) => Show (a -> b) -- Imported from ...
04:30:24 * SamB hrmms
04:30:35 <dons> ok, try now.
04:30:38 <SamB> @scheck (\f b -> (f . not) b == (not . f) b)
04:30:40 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
04:30:45 <SamB> hooray ;-)
04:30:52 <dons> cheers
04:33:00 <SamB> isn't that ever so much better than...
04:33:03 <SamB> @check (\f b -> (f . not) b == (not . f) b)
04:33:05 <lambdabot>  Falsifiable, after 0 tests: <Bool -> Bool>, True
04:33:10 <dons> mm yes.
04:34:06 <dcoutts__> that's cool
04:34:24 <aes2> @hoogle IO Integer
04:34:25 <lambdabot> CPUTime.getCPUTime :: IO Integer
04:34:25 <lambdabot> IO.hFileSize :: Handle -> IO Integer
04:34:25 <lambdabot> System.IO.hTell :: Handle -> IO Integer
04:37:21 <sek> @version
04:37:21 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
04:37:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:38:52 <dons> i wish darcs tagged which repo was which when patches are sent
04:38:59 <dons> i.e. [lambdabot] darcs patch: fixed a bug where trailing spaces sent
04:39:06 <dons> or [goa] darcs patch: fixed url e ..
04:40:19 <SamB> dons: would be nice!
04:41:46 <dons> lispy: ok, patches applied. thanks
04:47:05 <musasabi> Where is documentation for the new regex libraries?
04:47:27 <sek> dons i dont have darcs and downloaded the directory recursively with wget. how do i install it though?
04:47:58 <SamB> sek: install?
04:48:05 <SamB> you don't install ;-)
04:48:13 <SamB> you just run it from there
04:50:09 <sek> ghc Main.hs complain
04:50:15 <sek> there's a build file but it complain also
04:50:23 <sek> *complains
04:50:26 <SamB> did you read README?
04:51:38 <sek> heh, there's no readme or install file
04:52:03 <SamB> you are talking about lambdabot right?
04:52:07 <SamB> it has a README file
04:52:14 <SamB> all caps
04:52:37 <sek> not in here http://www.cse.unsw.edu.au/~dons/lambdabot/
04:52:38 <lambdabot> Title: Index of /~dons/lambdabot
04:53:24 <sek> ah, ok, i found a main page for lambdabot
04:54:02 * SamB wonders where README went
04:54:54 <SamB> my guess is that you need a newer Cabal?
04:55:01 <sek> its in the tarballl
04:55:51 <SamB> dons: did you accidentally delete the README file from http://www.cse.unsw.edu.au/~dons/lambdabot/ (including _darcs/current)?
04:55:51 <lambdabot> Title: Index of /~dons/lambdabot
04:58:39 <SamB> @scheck \x -> complement x + 1 == negate (x :: Int)
04:58:40 <lambdabot>  Completed 10 test(s) without failure.
04:59:05 <SamB> huh, not so heavy on testing Int things is it?
04:59:21 <SamB> @check \x -> complement x + 1 == negate (x :: Int)
04:59:22 <lambdabot>  OK, passed 500 tests.
04:59:44 <SamB> @ask dons did you accidentally delete the README file from http://www.cse.unsw.edu.au/~dons/lambdabot/ (including _darcs/current)?
04:59:45 <lambdabot> Consider it noted.
05:00:27 <Cale> @scheck \x -> x * (x^2-1) * (x^2-2) * (x^2 - 3) * (x^2 - 4) * (x^2 - 5) == (0::Int)
05:00:28 <lambdabot>   Failed test no. 5. Test values follow.: 3
05:01:07 <Cale> oh, hehe
05:01:16 <Cale> @scheck \x -> x * (x^2-1) * (x^2-2^2) * (x^2 - 3^2) * (x^2 - 4^2) * (x^2 - 5^2) == (0::Int)
05:01:17 <lambdabot>   Failed test no. 8. Test values follow.: 6
05:01:35 <Cale> @scheck \x -> x * (x^2-1) * (x^2-2^2) * (x^2 - 3^2) * (x^2 - 4^2) * (x^2 - 5^2) * (x^2 - 6^2) == (0::Int)
05:01:36 <lambdabot>   Failed test no. 9. Test values follow.: 7
05:02:07 <Cale> @scheck \x -> product [x^2 - k^2 | k <- [0..10]] == (0::Int)
05:02:09 <lambdabot>  Completed 10 test(s) without failure.
05:02:11 <Cale> hehe
05:02:17 <Cale> @check \x -> product [x^2 - k^2 | k <- [0..10]] == (0::Int)
05:02:18 <lambdabot>  Falsifiable, after 20 tests: -12
05:02:35 <Cale> @check \x -> product [x^2 - k^2 | k <- [0..100]] == (0::Int)
05:02:37 <lambdabot>  OK, passed 500 tests.
05:02:41 <Cale> heheh
05:03:01 <Cale> > (\x -> product [x^2 - k^2 | k <- [0..100]] == (0::Int)) 101
05:03:02 <lambdabot>  True
05:03:17 <Cale> hmm, I am using ints :)
05:03:19 <Cale> > (\x -> product [x^2 - k^2 | k <- [0..100]] == (0::Integer)) 101
05:03:21 <lambdabot>  False
05:03:28 <Cale> @check \x -> product [x^2 - k^2 | k <- [0..100]] == (0::Integer)
05:03:29 <lambdabot>  Falsifiable, after 245 tests: 115
05:03:41 <Cale> okay, better :)
05:04:38 <Cale> I wonder if that polynomial really is zero over Int
05:04:48 <clanehin> if product would halt on zero, you could just write [0..]
05:04:55 <ValarQ> whats check and scheck?
05:05:07 <Cale> ValarQ: QuickCheck and SmallCheck
05:06:02 <Cale> QuickCheck generates random values and functions to test a property. SmallCheck is similar but generates "small" values of the right types to exhaustively check.
05:06:38 <Cale> clanehin: Hm?
05:07:23 <ValarQ> "lambdabot: out of memory (requested 8007513864475246592 bytes)", heh
05:07:40 <sieni> <3
05:08:01 <ValarQ> my local bot got greedy
05:08:07 <SamB> ValarQ: when did it do that?
05:08:20 <ValarQ> SamB: when executed
05:08:40 <clanehin> let product' [] = 1; product' (0:_) = 0; product' (n:ns) = n*product' ns in (\x -> [x^2-k^2 | k <- [0..]]) (10000 :: Integer)
05:08:55 <clanehin> > let product' [] = 1; product' (0:_) = 0; product' (n:ns) = n*product' ns in (\x -> [x^2-k^2 | k <- [0..]]) (10000 :: Integer)
05:08:56 <lambdabot>  [100000000,99999999,99999996,99999991,99999984,99999975,99999964,99999951,99...
05:08:59 <SamB> ValarQ: seriously?
05:09:13 <SamB> > log2 8007513864475246592
05:09:14 <lambdabot>  Not in scope: `log2'
05:09:15 <clanehin> let product' [] = 1; product' (0:_) = 0; product' (n:ns) = n*product' ns in (\x -> product [x^2-k^2 | k <- [0..]]) (10000 :: Integer)
05:09:21 <SamB> > log 8007513864475246592 / log 2
05:09:21 <lambdabot>  62.79606009890472
05:09:34 <clanehin> >  let product' [] = 1; product' (0:_) = 0; product' (n:ns) = n*product' ns in (\x -> product [x^2-k^2 | k <- [0..]]) (10000 :: Integer)  --grrrrr
05:09:38 <lambdabot> Terminated
05:09:41 <ValarQ> SamB: yes, but i do a 'darcs pull' and rebuild it
05:09:48 <SamB> ValarQ: some 64-bit bug?
05:09:49 <clanehin> ok well you see what I'm getting at
05:09:59 <ValarQ> SamB: maybe, i use amd64
05:10:17 <clanehin> not even a particularly good impl of product
05:17:32 <aes2> What's the equivalent of breaking something in your program and then finding all the breakages in a dynamic language?
05:18:38 <wolverian> ENOPARSE
05:18:42 <sieni> what's this thing called "a dynamic language"? some sort of selling point?
05:19:29 <ValarQ> sieni: it's a language that lacks definition
05:19:51 <wolverian> there are well defined dynamic languages.
05:20:02 <Cale> dynamically typed language?
05:20:04 <SamB> aes2: breaking your program and then not finding all the breakage
05:20:18 <Cale> SamB: excellent answer
05:20:35 <ValarQ> wolverian: youre thinking of dynimcally typed languages
05:20:37 <aes2> SamB: yes, I suppose you run the program get one breakage and repeat that.
05:20:44 <wolverian> ValarQ, what's a dynamic language then?
05:20:54 <ValarQ> wolverian: it's a language that lacks definition :)
05:21:02 <Cale> @remember SamB [Q: What's the equivalent of breaking something in your program and then finding all the breakages in a dynamically typed language?] Breaking your program and then not finding all the breakage.
05:21:02 <wolverian> ValarQ, ah. :)
05:21:05 <SamB> aes2: except that you never find it all until you have excercised the whole thing
05:21:38 <SamB> thats why I like to write VMs in Haskell ;-)
05:22:02 <SamB> it helps me find all the stuff that couldn't possibly work
05:23:14 <dons> ValarQ: I think your memory issue is to do with the State/seen file
05:23:14 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:23:29 <aes2> I had an assumption in my program that some data would come only in some form. I used a tuple to represent it. Now, I see that some of the values are optional. I broke the type, fixed all the errors one by one per module and it worked.
05:23:30 <dons> when it tries to parse garbage, it ends up asking for weird amounts of memory
05:23:48 <mux> hey, I have a patch for State/karma! :->
05:24:36 <ValarQ> dons: ok, perhaps that file should be removed from the build script, it seems to cause a lot of small trouble
05:25:20 <dons> sek the README file should be in the lambdabot dir (but the web sever doesn't like showing README files for some dumb reason)
05:25:31 <dons> ValarQ: hmm. maybe
05:26:25 <sek> dons: yeah, grabbed the tarball and will install it later on. thanks
05:32:45 <roconnor> > 3^101 `mod` 14
05:32:47 <lambdabot>  5
05:36:25 <dons> nightall
05:36:34 * dons falls unconcious
05:39:11 <dcoutts__> g'night dons
05:40:20 <ndm> night dons
05:42:22 <ndm> dcoutts__, we've got a serious push on Yhc at the moment, so we're hoping for a packageable version, with haskell.org base, soonish
05:43:14 <dcoutts__> ndm: cool
05:43:49 <dcoutts__> ndm: poke your nose into #gentoo-haskell if you want to talk with us about packaging issues any time
05:44:03 <kombinator> dcoutts__, g'day
05:44:15 <dcoutts__> hello
05:44:22 <kombinator> dcoutts__, long time ago we talked about high-level gui library
05:44:38 <dcoutts__> aye
05:44:45 <ndm> dcoutts__, will do :)
05:44:55 <ndm> kombinator: i have a high level GUI library :)
05:45:01 <ndm> @where proplang
05:45:02 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
05:45:10 * kombinator looks
05:45:25 <ndm> based on Gtk2hs
05:46:20 <kombinator> ndm, how do I build it (linux)?
05:46:31 <psnl> ndm: w.r.t your message: I'm stuck in cambridge, so can't really start coding until I get home, which will be saturday, I have done a bit of writing, but I'm trying to avoid writing checks I can't code, if you get what I mean
05:46:47 <ndm> kombinator: ghc --make
05:47:00 <ndm> kombinator: ghc --make Sample -package gtk
05:47:07 <ndm> thats all thats in the make.bat
05:47:30 <dcoutts__> aye, that's why I couldn't build it straight off :-)
05:47:44 <ndm> psnl: sounds sensible, am looking forward to it :)
05:47:51 <kombinator> thanks, turnes out I have to build gk2hs on my box first;)
05:47:52 <ndm> dcoutts, kombinator: patches welcome :)
05:47:54 <dcoutts__> . ./make.bat works though :-)
05:48:21 * ndm writes a Linux/Windows compataible shell script :)
05:48:30 <dcoutts__> @arr
05:48:31 <lambdabot> Yeh scurvy dog...
05:48:35 <dcoutts__> ahem
05:49:09 <kombinator> dcoutts__: I'm thinking of doing some kind of high-level gui as my master thesis
05:49:25 <dcoutts__> kombinator: cool!
05:49:30 <kombinator> but I'm not sure if it will work
05:49:54 <dcoutts__> kombinator: well you know my opinion, I think any such thing should be based on an existing mid level one
05:50:01 <beelsebob> @arr
05:50:01 <lambdabot> Aye Aye Cap'n
05:50:13 <beelsebob> Arr, lambdabot be joining in the fistivities I see
05:50:15 <kombinator> and what do you call 'mid level one'?
05:50:26 <ndm> gtk2hs, wxhaskell
05:50:36 <kombinator> ok
05:50:53 <ndm> i'd call proplang a mid-high level one - in between mid and high
05:51:07 <kombinator> i will take a look at it
05:51:30 <dons> dcoutts__: oh, one last thought. I talked to kfish today (the guy writing the ogg decoder over bytestrings). what he needs is seekable bytestring io.
05:51:48 * kombinator goes away
05:51:56 <dons> i.e. to jump somewhere into a file, read some frames, possibly reverse a bit around. all without having to read sequentially from the start of the bytestring
05:52:31 <dons> so that indexing into a bytestring built via seekable io would cause the os to do a seek and read onthe underlying handle
05:52:48 <dons> so like an mmap, but more portable and without needing, say, VM support
05:53:20 <dons> so our problem with 'tac' is just a special case of arbitrary seekable io
05:53:32 <xerox> This seems like a sensible technique, asking library implementors to write part of your program, hehe.
05:53:43 <dons> hah
05:59:34 <dcoutts__> dons: hmm, and he doesn't want to mmap ?
05:59:35 <dcoutts__> dons: we should get mmap working again
06:00:01 <dons> we should, yes.
06:00:21 <dons> i'd like to take a good look a fusible io at some point, including down io via seek
06:00:59 <mux> hey dons
06:01:04 <mux> didn't have time to commit my patch yet?
06:01:26 <dons> sorry, not yet. i'll do it tomorrow.
06:01:29 <GomoX> Hey
06:01:36 <mux> ok
06:01:36 <GomoX> Complete n00b here
06:02:02 <GomoX> Hugs.Base> func n | n > 0 = 2
06:02:02 <GomoX> ERROR - Syntax error in input (unexpected `|')
06:02:07 <GomoX> o_O
06:02:13 <GomoX> I swear that used to work
06:02:16 <dons> you can't declare functions on the command line in hugs
06:02:18 <dons> only in ghci
06:02:30 <dons> you need to pu the function definition in a file
06:02:43 <GomoX> my teacher just did it yesterday on "hugs for win32"
06:02:50 <GomoX> it's not the same i guess
06:02:51 <dons> (check here for more details: http://haskell.org/haskellwiki/Haskell_in_5_steps)
06:02:53 <GomoX> :(
06:02:54 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/gdrmd
06:03:05 <dons> in ghci you can write: let func n | n > 0 = 2
06:03:17 <dons> and in both hugs and ghci you can write: let func n | n > 0 = 2 in func 9
06:03:33 <dons> > let func n | n > 0 = 2 | otherwise = error "fail" in func 9
06:03:34 <lambdabot>  2
06:03:40 <dons> > let func n | n > 0 = 2 | otherwise = error "fail" in func 0
06:03:41 <dcoutts__> dons: sorry, wireless stoped for a bit; yes I think that'd be possible with a lazy bytestring
06:03:41 <lambdabot>  Exception: fail
06:03:43 <ndm> GomoX: tell your teacher to upgrade to the latest version of WinHugs, its about 3 years newer!
06:04:01 <GomoX> heh ok i might just do that :)
06:04:06 <dons> ndm, you can declare functions on the command line in WinHugs?
06:04:13 <dons> interactively?
06:04:14 <ndm> dons: no :(
06:04:28 <dcoutts__> dons: it's pretty much the first case I've seen where the extra indirection in the boxing of the list of chunks helps
06:04:28 <ndm> but you will be able to in GuiHaskell
06:05:02 <dons> yes, with lazy bytestrings, of course.
06:05:06 <dcoutts__> dons: you could readFileRandomAccess and not read in each chunk 'til the list element is forced
06:05:11 <dons> (he has to deal with gigabyte sound and video files)
06:05:17 <dcoutts__> then yes, tac would be faster
06:05:18 <dons> right
06:05:23 <GomoX> Where do i get this guihaskell?
06:05:28 <dcoutts__> ah, gb, fair enough
06:05:30 <ndm> GomoX: the future :)
06:05:37 <dons> that's what I imagined, a random access lazy bytestring io op.
06:05:38 * GomoX travels to the future
06:05:40 <ndm> @where GuiHaskell
06:05:41 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
06:05:58 <dcoutts__> dons: but is there any system where we couldn't mmap it?
06:05:59 <ndm> GomoX: although there is a preview of it there, and it works reasonably well for some thing
06:06:12 <dons> dcoutts__: hmm. multics?
06:06:23 <dcoutts__> dons: I suppose multi-gb files on a 32bit machine
06:06:32 <dons> the os guy who was there seemed to think that it might stress the vm a bit to do multi gig stuff
06:06:39 <dcoutts__> mm
06:06:44 <GomoX> ndm: I find you suspiciously helpful for a person on a programming language related channel
06:06:47 <dons> right, so we write our own memory subsystem ;)
06:06:57 <dons> GomoX: welcome to #haskell
06:07:01 <dons> :)
06:07:12 <dons> all your questions can be answered here, by friendly trained staff of hackers
06:07:13 <psnl> GomoX: giggle
06:07:25 <ndm> GomoX: you'll find everyone in here is surprisingly helpful!
06:07:29 <dons> or there: http://haskell.org
06:07:30 <lambdabot> Title: Haskell - HaskellWiki
06:07:33 <GomoX> You mean in the world of  functional programming people are actually nice and helpful??
06:07:34 <dons> even our bots are helpful!
06:07:40 <GomoX> this truly IS weird
06:07:59 <dons> ?vixen do you like to help people with their haskell problems?
06:08:00 <lambdabot> church is my favourite computer scientist.
06:08:12 <GomoX> heh
06:08:14 <dons> ?vixen what about Curry?
06:08:14 <lambdabot> i dunno, what about?
06:08:18 <dcoutts__> dons: now what'd be even cooler is discarding chunks if they get GC'ed and reading them back from the disk again if necessary
06:08:25 <dons> yeah
06:08:31 <dons> you'd almost need to do that, i think
06:08:37 <dcoutts__> dons: ie imagine a list of weak pointers to chunks
06:08:51 <dons> or have some kind of hint to tell the GC that it's ok to throw things away under pressure
06:08:57 <dons> hmm
06:09:04 <dcoutts__> and replace it with the thunk to re-read them
06:09:06 <mux> I wouldn't recommend to mmap() even a 4GB file on a 32bits system
06:09:12 <mux> it most likely wouldn't work anyways
06:09:20 <GomoX> Well i'm off for class, we'll be seen each other on the next few weeks I guess
06:09:24 <GomoX> *seeing
06:09:25 <GomoX> ouch
06:09:35 <GomoX> thanks
06:09:38 <dcoutts__> mux: indeed, you need some of that 4Gb for your process
06:09:42 * mux nods
06:09:46 <dcoutts__> the kernel, stack etc etc
06:09:55 <dcoutts__> ptobably the biggest you could mmap is 2Gb
06:09:56 <mux> mmap() is actually limited to 2GB on FreeBSD and 32bits system
06:09:58 <mux> yes
06:10:04 <dons> mm. interesting.
06:10:21 <roconnor> dons: I'm not trained.
06:10:31 <dons> oh, except roconnor. he's a rogue agent
06:10:41 <dons> so watch out!
06:10:42 <roconnor> oh wait, I have a BMath.  maybe that counts as training.
06:10:47 <dcoutts__> dons: if we're getting the GC to do work for us, we could also teach it to reclaim strings where only substrings are used
06:11:04 <dons> hmm, how?
06:11:06 <dcoutts__> ie free the gaps
06:11:19 <dcoutts__> it'd need custom code :-(
06:11:21 <dons> implicitly, with calling copy()?
06:11:46 <dcoutts__> possibly yes
06:12:05 <mux> are your chunks fixed-size?
06:12:10 <dcoutts__> no
06:12:16 <mux> *2 everytime ?
06:12:18 <dcoutts__> generally similar, but not necessarily
06:12:28 <mux> hm
06:12:29 <dcoutts__> can be any size
06:12:54 <mux> and the chunks are just linked for now?
06:13:00 <dons> I've discovered the key to having your research paper cited by other people many times. Change your name to "Wadler"
06:13:04 <mux> ie, I can't acces chunk N in O(1) ?
06:13:09 <dcoutts__> mux, right
06:13:16 <dcoutts__> dons: ha ha
06:14:07 <dons> dcoutts__: http://haskell.org/haskellwiki/Research_papers/Top_10
06:14:11 <lambdabot> Title: Research papers/Top 10 - HaskellWiki, http://tinyurl.com/l2blg
06:14:12 <dons> I wonder if I missed any?
06:14:34 <mux> dcoutts__: you know tht it's often faster to use realloc() and doubling the size than linking a new chunk?
06:14:56 <dcoutts__> dons: heh, wadler, wadler, wadler, SPJ and Huges
06:15:11 <mux> my name is Hindley-Milner
06:15:31 <dons> looks ike 89 and 92 were big years for haskell
06:15:33 <dcoutts__> mux: we can never realloc without copying
06:15:39 <mux> why is that?
06:15:41 <psnl> dons: I'm surprised the report isn't on there
06:15:47 <dcoutts__> mux: ghc doesn't do that
06:15:47 <dons> psnl: its the first item
06:15:51 <psnl> oops
06:15:59 <mux> dcoutts__: can't you call realloc() yourself?
06:16:11 <dcoutts__> mux: we'd rather use the ghc heap
06:16:14 <mux> ok
06:16:19 <pejo> dcoutts/dons, are you discussing teaching the GC about certain data structures, and reclaiming dead parts?
06:16:26 <dcoutts__> pejo: right
06:16:35 <dons> 90, 92, 92 , 89, 89, 93, 89, 95, 92, 95
06:16:42 <dons> magic numbers
06:16:46 <psnl> dons: http://haskell.org/onlinereport/ has the authors
06:16:47 <lambdabot> Title: The Haskell 98 Language Report
06:16:52 <roconnor> dons: Tackling the awkward squad?
06:17:03 <dons> roconnor: not cited that much, surprisingly. maybe its too new?
06:17:03 <dcoutts__> dons: hey those are my lotter numbers! don't tell eveyone!
06:17:10 <dons> heh
06:17:26 <roconnor> oh, top 10 cited according to google.
06:17:34 <dons> if anyone wants to go to scholar.google.com and try to find other papers > 200 cites on haskell
06:17:39 <dons> or on citeserr.. or somewhere else..
06:17:52 <dons> and make sure that list is correct, that'd be karma worthy :)
06:17:56 <pejo> dcoutts, not sure if you've seen it but Laura Effinger Dean, Chris Erickson, Melissa O'Neill, and Darren Strash had two papers at SPACE'06.
06:17:58 <dons> or we could go for the top 20-100 papers
06:18:19 <dcoutts__> pejo: we'd not. we were just speculating
06:18:31 * mux pondering the cost of an extra data structure to map chunks so that we can have random access
06:19:17 <mux> somewhat similar to the problem the VM has when it comes to handling memory ranges
06:19:24 <mux> IIRC, we use a splay tree for that
06:21:58 <mux> so we could have a splay tree where every node (be it a leaf or a real node) represents a chunk, containing a mean to access the said chunk and its size
06:24:27 <mux> and the fact that it's a splay tree help with repetitive random access to the same chunk, or nearby chunks
06:26:34 <dcoutts__> pejo: I can't find that paper online anywhere, do you happen to know if it's available ?
06:26:35 <ventonegro> forall is a GHC extension, right?
06:26:40 <dcoutts__> yep
06:26:52 <ventonegro> what are the potential problems of using it?
06:27:45 <bourbaki> moin
06:28:59 <sek> shouldnt importing a module import its classes too?
06:29:40 <sek> i invoking an instance of a class for a data type that i have included in the module's import list
06:29:43 <sek> and its complaining
06:29:45 <norpan> sek: it should - if the module exports those classes
06:29:52 <sek> ah
06:30:06 <sek> so i just have the class name along with data types and functions?
06:30:10 <norpan> yes
06:30:12 <sek> i see
06:30:33 <sek> thanks
06:31:14 <ventonegro> asking another way, i want to use the Gr type (a graph)
06:31:37 <ventonegro> but i don't want to parametrize on a single type of node
06:31:50 <mux> dcoutts__: what do you think of my above proposition?
06:32:05 <ventonegro> and I want to use forall for that
06:32:12 <ventonegro> is it experimental or stable?
06:34:00 <apfelmus> ventonegro: ? can you elaborate on Gr
06:34:43 <ventonegro> it's from Data.Graph.Inductive.Tree
06:34:54 <ventonegro> type Gr a b
06:35:15 <apfelmus> ventonegro: ok. what do you want to do with it?
06:35:18 <ventonegro> but i have to use more than one type of node
06:35:31 <ventonegro> such as Drawables, Transforms etc.
06:36:07 <apfelmus> ventonegro: ah, so you have node labels like 'a' and 1 at once
06:36:15 <ventonegro> so i thought about data Node = forall a. Drawable a => DrawableNode a | forall a. Transform a => TransformNode a
06:36:39 <ventonegro> apfelmus, yep
06:37:23 <dons> existential types are well supported by all haskell compilers, as an extension, I think
06:37:27 <dons> ?where haskell-exts
06:37:27 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
06:37:45 <dons> so you should be fine to use them.
06:37:58 <ventonegro> ok
06:38:02 <apfelmus> ventonegro: in general, it's better to build a big union of the concrete types you have like
06:38:05 <apfelmus> data Transformable = Circle Circle | Rect Rectangle
06:38:08 <apfelmus> but it's boilerplate.
06:38:23 <kombinator> @users
06:38:24 <ventonegro> dons, i was worried about using some experimental and/or unsupported feature
06:38:39 <lambdabot> seen module failed: IRCRaised thread killed
06:38:39 <dons> see here for more details: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
06:38:42 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/q9oj9
06:38:47 <dcoutts__> mux: oh you mean some log n tree of chunks rather than a list?
06:39:00 <dcoutts__> sjanssen was thinking of something similar before
06:39:02 <dons> ?users
06:39:03 <lambdabot> Maximum users seen in #haskell: 237, currently: 221 (93.2%), active: 35 (15.8%)
06:39:04 <ventonegro> apfelmus, but Drawable is a class
06:39:08 <dons> kombinator: weird.
06:39:10 <dcoutts__> I think it's complementary to a list
06:39:23 <ventonegro> so data Node = Drawable a gives an error
06:39:28 <lscd> apfelmus: why is that better?
06:39:39 <dcoutts__> mux: because it can't easily be lazy in the tail of the stream right?
06:39:40 <dons> lscd, its more precise?
06:39:45 <dons> and stays in h98?
06:39:57 <dons> though there are many real problems that are best done with existentials
06:40:12 <dcoutts__> mux: eg if we read from a net connection (rather than a file) then we'd have a problem, no?
06:40:22 <lscd> dons: more limited more than more precise, i'd think - but yeah, staying in h98 is a plus
06:40:26 <ventonegro> i'd rather stay in h98
06:40:30 <dcoutts__> mux: would we not have to read the whole stream?
06:40:35 <ventonegro> just couldn't figure out how
06:40:43 <apfelmus> ventonegro: yes. but if you know you know all instances, a big union might be better
06:40:51 <sjanssen> dcoutts__: a lazy tree would have to forgo balancing
06:40:55 <ventonegro> apfelmus, i see
06:40:59 <dons> ventonegro: so if you only have a few types you want to store in nodes, just use a union type.
06:41:19 <dons> data Node = IntNode Int | BoolNode Bool | ....
06:41:28 <dcoutts__> sjanssen: right
06:42:01 <ventonegro> thanks guys
06:42:07 <mux> dcoutts__: I was thinking of adding a splay tree but still keeping the list of chunks
06:42:14 <mux> dcoutts__: the splay tree would be used for random access
06:42:24 <ventonegro> so the answer is for classes use forall, to stay in h98 use a union of types
06:42:32 <mux> but that doesn't handle streams such as sockets and such :-)
06:42:35 <mux> didn't think of that
06:42:42 <dons> ventonegro: yeah, I think that's reasonable
06:42:46 <sjanssen> mux: wouldn't a splay tree be pretty nasty in a functional language?  you pretty much kill sharing
06:42:52 <dcoutts__> mux: it's a reasonable complementary structure, it's a rope I think.
06:42:55 <dons> though existential types, with classes, aren't too scary.
06:43:03 <mux> I have no idea about the viability of splay trees in a functional language
06:43:10 <dcoutts__> mux: finger trees are quite good
06:43:11 <mux> only used those in C :-).
06:43:30 <dcoutts__> that's what Data.Sequence uses I think
06:43:38 <dons> yep
06:43:44 <sjanssen> yeah, 2-3 FingerTrees by Hinze/Paterson
06:43:47 <dcoutts__> and I hear it's pretty fast
06:44:15 <lscd> mux: apparently, not so good, though splay heaps are ok - or at least, that's what my copy of "purely functional data structures" says
06:44:16 <sjanssen> I really should polish up my rope code and benchmark it
06:44:22 <dons> yes!
06:44:22 <dcoutts__> yes!
06:44:26 <dcoutts__> ha hah
06:44:31 <dons> jinx!
06:44:42 <dons> especially now the tshirts are almost on their way, sjanssen ... :)
06:44:54 <mux> whatever type of tree we use, having some binary search tree with the list of chunks would give us O(log n) random access instead of O(n)
06:45:01 <dcoutts__> mux, right
06:45:13 <mux> which was my main motivation
06:45:13 <dcoutts__> it's a good idea
06:45:17 <sjanssen> okay, I won't wear my tshirt until I benchmark my rope.  That should be motivation enough ;)
06:45:26 <dons> heh good :)
06:45:32 <mux> I then thought about splay trees because they have some nice properties for such cases
06:45:33 * dons hands sjanssen some incentive cookies to chew
06:45:34 <dcoutts__> sjanssen: how does your rope work?
06:45:40 <mux> but maybe that's not appropriate :)
06:45:42 <apfelmus> ventonegro: the point one wants to avoid existentials is that once you put a type in
06:45:45 <apfelmus>    let rect = Drawable (Rectangle 0 0 1 1),
06:45:48 <apfelmus> it is "gone" in the sense you can only use the methods of class Drawable on rect. there is no way to know wether rect contains a rectangle or circle or s.th. else
06:45:48 * deadbeef just tried to implement log2
06:45:54 <deadbeef> g x y = (x - 2^y <= 0)
06:45:54 <deadbeef> h x y = if g x y then y else h x (y + 1)
06:45:54 <deadbeef> myLog2 x = h x 0
06:45:56 <deadbeef> here it is
06:46:03 <deadbeef> what do you think ?
06:46:26 <dons> deadbeef: weird. we had someone else asking about log2 an hour or two ago
06:46:36 <deadbeef> lol
06:46:40 <mux> now I'm not sure if the added cost of managing the tree would be significant or not; if it is, maybe we'd need to have two separate APIs for traditional BS and BS with random access
06:46:48 <sjanssen> dcoutts__: uses the code from here http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
06:46:48 <deadbeef> it was an exercise for a course
06:46:51 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure, http://tinyurl.com/h5kcy
06:46:56 <ventonegro> apfelmus, i thought about it, the Drawable class has all the methods i need
06:47:26 <sjanssen> the data structure has an extensible measurement facility, so I use that to get indexing
06:47:55 <dons> > findIndex (<= 0) . scanl (const
06:47:56 <lambdabot>  Parse error
06:48:19 <dons> > findIndex (<= 0) . scanl (const . (`div` 2)) 100 $ [0..] -- deadbeef
06:48:21 <lambdabot>  Just 7
06:48:34 <dons> > ceiling $ logBase 2 100
06:48:35 <lambdabot>  7
06:48:46 <dcoutts__> sjanssen: right, nice.
06:48:59 <dcoutts__> mux: splay trees keep rotiating things on access right? so the next access is log n time where n is the distance from the last access
06:49:04 <xerox> let log2 = findIndex (<= 0) . flip (scanl (const . (`div` 2))) [0..] in log2 100
06:49:10 <deadbeef> dons: i've to implement it in a language that my prof made, called 'simple functional language'
06:49:22 <dons> do you get scanl?
06:49:25 <apfelmus> ventonegro: "we have all the development tools we need" (Microsoft) :)
06:49:31 <deadbeef> dons: it only has if-then-else, the N set, succ(n) and pred(n)
06:49:35 <mux> dcoutts__: yes
06:49:47 <ventonegro> apfelmus, :-)
06:49:50 <mux> dcoutts__: splaying means re-balancing the tree so that the last accessed element is the new root of the tree
06:49:56 <dcoutts__> aye
06:49:57 <xerox> Then write scanl and findIndex beforehand ;)
06:50:12 <dcoutts__> mux: so the provide goo caching
06:50:13 <mux> it would help repetitive random access to the same chunk, or sequential access etc
06:50:15 <xerox> import Prelude.sfl (simple functional language)
06:50:30 <mux> dcoutts__: we use splay trees in FreeBSD's VM to manage memory maps
06:50:34 <dcoutts__> mux: actually finger trees can do something similar
06:50:40 <dons> yeah, i'd just write it in haskell, and then translate to SFL :)
06:50:44 <mux> we used to have just a doubly-linked and hinted list
06:50:46 <dons> so you can use the good dev tools
06:51:01 <dons> hmm, like lambdabot :)
06:51:06 <dcoutts__> mux: right, because the access patterns match splay trees' well
06:51:11 * mux nods
06:51:57 <sjanssen> another advantage of finger trees is the guaranteed O(1) access to the head and tail
06:52:08 <sjanssen> erm, head and last
06:52:18 <dcoutts__> sjanssen: I'm right in thinking that with a finger tree you can splitAt and then take a left or right view on the two halves?
06:52:55 <dcoutts__> sjanssen: so you can get a sequence of m elements at position n in O(m + log n)
06:53:09 <sjanssen> dcoutts__: yes
06:53:28 <dcoutts__> rather than O(m * log n)
06:53:56 <sjanssen> actually, if you want a new finger tree holding the m elements, it is O(log n + log m)
06:54:35 <dcoutts__> oh, slice
06:54:41 <dcoutts__> I didn't see that op
06:55:08 <mux> ?google finger trees
06:55:09 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
06:55:09 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
06:55:22 * mux hearts lambdabot 
06:55:29 <sjanssen> well, it's just take m . drop n -- both of which are logarithmic operations
06:55:40 <dcoutts__> oh, of course
06:56:11 <mux> mmm, I need this purely functional data structures book
06:56:27 <dcoutts__> mux: the Osaki one, it's excelent
06:57:15 <dcoutts__> especially for groking amortised bounds
06:57:21 * mux adds this to the list of "to buy" books
06:57:42 <xerox> Okasaki?
06:57:51 * dcoutts__ spelt it wrong
06:57:53 <mux> Chris Okasaki, yes
06:57:57 <xerox> @yarrr
06:57:58 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
06:58:11 <sjanssen> mux: also, Ralf Hinze has a bunch of good papers on data structures
06:58:23 <ventonegro> Illegal polymorphic or qualified type: forall a. (Node a) => Gr a ()
06:58:32 <ventonegro> but there is  no forall in my code 0_o
06:58:48 <mux> sjanssen: if this is more like a generic book on data structure, I'm not really interested
06:59:02 <mux> a book on purely functional data structures would be handy though
06:59:09 <apfelmus> ventonegro: the missing forall is likely to be the problem...
06:59:27 <sjanssen> mux: they're specifically on designing data structures in (pseudo-) Haskell
06:59:38 <Cale> ventonegro: all unquantified variables are forall'd in Haskell
06:59:45 <mux> sjanssen: ok
06:59:50 <fasta> Why do people even release software that doesn't scale?
07:02:30 <lscd> fasta: a large number of reasons, from lack of time to lazyness to lack of knowledge to having it be something that really, really doesn't _need_ to scale
07:02:58 <permanente> :wq
07:03:01 <permanente> arx
07:03:01 <permanente> srx
07:03:01 <lscd> (an implementation of, say, single-player minesweeper would probably be in the last category)
07:03:07 <fasta> lscd: yes, but this particular bunch of people created software that outputs benchmarks.
07:03:31 <lscd> fasta: presumably, it worked for their examples, and for one of the first 3 reasons, they didn't try to scale it beyond that
07:03:53 <lscd> (which software, btw?  I've written something that does that recently, but it's quite lousy still)
07:04:59 <fasta> lscd: I hope you are not the author :)
07:05:16 <lscd> fasta: no, i haven't released mine - it's one-off junk :)
07:05:31 <lscd> wrong continent, wrong programming language... :)
07:06:49 <fasta> lscd: I have a C program which does the same only works in under a second.
07:07:03 <Syzygy-> @docs hopengl
07:07:04 <lambdabot> hopengl not available
07:07:06 <fasta> lscd: The Haskell program eats all my memory and I stop it.
07:07:08 <Syzygy-> @where hopengl
07:07:08 <lambdabot> http://haskell.org/HOpenGL/
07:07:12 <apfelmus> any dependent typers around? i wonder how one could enforce laws about functions in a dependently typed manner. specifically i wonder how to enforce the 3 monad-laws when writing the instance declaration
07:07:17 <Syzygy-> @where opengl
07:07:17 <lambdabot> I know nothing about opengl.
07:07:21 <Syzygy-> @docs opengl
07:07:21 <lambdabot> opengl not available
07:07:28 <Syzygy-> @docs
07:07:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:09:54 <ventonegro> @where hopengl
07:09:55 <lambdabot> http://haskell.org/HOpenGL/
07:11:04 <deadbeef> this is me
07:11:06 <deadbeef> http://www.macproject.it/chrix_photo/2.jpg
07:52:57 <glguy> hi
08:03:44 <glguy> phc-pkg: dependency cairo-0.10.0 doesn't exist
08:03:52 <glguy> Anyone seen that error when installing gtk2hs
08:03:53 <glguy> ?
08:04:30 <dcoutts__> there's never been a cairo-0.10.0
08:04:55 <dcoutts__> it's currently at 0.9.10.2
08:05:02 <glguy> oh
08:05:05 <glguy> yeah, that
08:05:07 <glguy> 0.9
08:05:10 <glguy> .10
08:05:30 <Syzygy-> Should this work?
08:05:31 <Syzygy->   mapM_ (\(x,y,z) -> preservingMatrix $ do
08:05:31 <Syzygy->     color $ Color3 x y z
08:05:31 <Syzygy->     translate $ Vector3 x y z
08:05:31 <Syzygy->     cube (0.1::GLfloat)
08:05:33 <Syzygy->   ) points
08:05:36 <dcoutts__> glguy: what's the error exactly? and what command did you use that gave the error?
08:05:42 <glguy> my computer shows that cairo is at version 1.2.4_1
08:05:56 <dcoutts__> glguy: that's the C lib, not the Haskell binding
08:06:00 <Lemmih> Syzygy-: Does it work?
08:06:10 <glguy> oh
08:06:27 <glguy> ?paste
08:06:28 <lambdabot> http://paste.lisp.org/new/haskell
08:06:43 <Syzygy-> Lemmih: Not really...
08:06:47 <lisppaste2> gtk2hs dports error pasted "glguy" at http://paste.lisp.org/display/26313
08:07:17 <dcoutts__> glguy: ah this is darwinports?
08:07:21 <glguy> yeah
08:07:32 <dcoutts__> glguy: check with them
08:07:35 <glguy> I just upgraded to gtk2 2.10
08:07:37 <glguy> oh, ok
08:07:39 <Syzygy-> Ah! Seems to work if I indent the final ) points enough.
08:07:56 <dcoutts__> glguy: they seem to be registering packages in the wrong order
08:08:07 <dcoutts__> glguy: or they're not building the cairo package
08:08:41 <kpreid> Syzygy-: flip mapM_ points $ \(x,y,z) -> preservingMatrix $ do ...
08:08:46 <dcoutts__> glguy: so I'd suggest filing a bug with the darwinport maintainer of the package
08:08:53 <glguy> ok
08:09:13 <dcoutts__> glguy: it may be that gtk2hs doesn't work yet with gtk 2.10 on mac, you're probably the first to try it
08:09:30 <dcoutts__> glguy: you can try building from source by hand, it's not hard
08:09:51 <dcoutts__> I don't know what the darwinports stuff is doing so can't really help with that
08:09:53 <glguy> how long does gtk2hs take to build?
08:10:08 <dcoutts__> 20 min with optimisations, 5 without
08:10:18 <dcoutts__> on a fast machine
08:10:33 <glguy> 1.5ghz G4
08:10:34 <glguy> ?
08:10:41 <glguy> do you consider that fast?
08:10:46 <dcoutts__> probably
08:11:15 <dcoutts__> glguy: use ./configure --with-hcflags-O0 for no optimisations
08:11:31 <glguy> kk
08:11:37 <dcoutts__> err: ./configure --with-hcflags=-O0
08:12:12 <glguy> post-activate   { set pkgs {glib gtk cairo gconf glade mogul}
08:12:16 <glguy> is that the correct order?
08:12:21 <dcoutts__> no
08:12:28 <dcoutts__> swap cairo and gtk
08:12:56 <glguy> post-activate   { set pkgs {glib cairo gtk gconf glade mogul}
08:13:02 <dcoutts__> @yarr
08:13:03 <lambdabot> What be a priate's favourite cheese?
08:13:03 <lambdabot> Yarrlsburg!
08:13:32 <Syzygy-> Gleh.
08:13:37 <dcoutts__> glguy: yep, try that
08:13:39 <glguy> alright, I've starteed the macports build over then
08:13:43 <Syzygy-> Now, I'm having problem with my little pointgenerating function
08:13:50 <Syzygy-> points :: Int -> [(GLfloat,GLfloat,GLfloat)]
08:13:51 <Syzygy-> points n = map (\k -> (sin(2*pi*k/n),cos(2*pi*k/n),0.0))  [1..n]
08:13:54 <dcoutts__> glguy: and then report the packaging bug :-)
08:14:03 <glguy> ?yarr
08:14:04 <lambdabot> Aye Aye Cap'n
08:14:05 <Syzygy-> I thought that multiplying something with pi should make it all a floating type.
08:14:16 <glguy> hey... that worked :)
08:14:22 <Syzygy-> But I get type mismatch, with 2*pi*k/n inferred Int and expected GLfloat
08:15:41 <glguy> dcoutts__: what is your role in gtk2hs? lead?
08:15:59 <dcoutts__> glguy: one of two devs/maintainers
08:16:12 <dcoutts__> Syzygy-: you've specified n to be an Int
08:16:24 <dcoutts__> hence the problem
08:16:45 <dcoutts__> points :: Int ->...
08:16:50 <dcoutts__> points n = ...
08:17:07 <Syzygy-> dcoutts__: But I want to start with a number of points to generate, and then do it... What type should I use for it to make sense?
08:17:22 <dcoutts__> so you probable just want to convert n to be floating point at the place you use it
08:17:30 <dcoutts__> ie use fromIntegral n
08:18:38 <Syzygy-> Hah! Great!
08:18:41 <dcoutts__> let points n' = map (\k -> (sin(2*pi*k/n),cos(2*pi*k/n),0.0))  [1..n] where n = fromIntegral n'
08:19:16 * dcoutts__ notices his mistake
08:19:27 <Syzygy-> points n = map (\k -> let t = 2*pi*(fromIntegral k)/(fromIntegral n) in (sin(t),cos(t),0.0))  [1..n]
08:19:33 <Syzygy-> This is what I ended up using.
08:19:54 <int-e> > [1.0 .. 3.0]
08:19:55 <lambdabot>  [1.0,2.0,3.0]
08:20:11 <Syzygy-> Setting n::Int makes [1..n] be [Int], so you end up with k::Int as well.
08:20:17 <Syzygy-> > [1.0 .. 3.2]
08:20:18 <lambdabot>  [1.0,2.0,3.0]
08:20:20 <Syzygy-> Ah.
08:20:26 <Syzygy-> So I don't need Int anyway.
08:20:26 <gds> > [1.2 .. 3.2]
08:20:28 <lambdabot>  [1.2,2.2,3.2]
08:20:31 <gds> :)
08:20:31 <glguy> [1.0,1.1..2.0]
08:20:36 <glguy> > [1.0,1.1..2.0]
08:20:38 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
08:20:41 <int-e> I wouldn't do that. :)
08:21:18 <Syzygy-> int-e: Not give it type signature GLfloat -> ... and use [1..n] at the end?
08:21:19 <int-e> but ints are safe, even when they've been converted to double.
08:21:23 <glguy> I don't think that it should let you do that
08:21:43 <int-e> Syzygy-: I'd think about using [1.. fromIntegral n]
08:22:21 <int-e> glguy: it has weird semantics.
08:22:28 <int-e> > [1.0..1.9]
08:22:28 <Syzygy-> points n' = let n = fromIntegral n' in map (\k -> let t = 2*pi*k/n in (sin(t),cos(t),0.0))  [1..n]
08:22:29 <lambdabot>  [1.0,2.0]
08:22:33 <int-e> > [1.0..1.5]
08:22:34 <lambdabot>  [1.0,2.0]
08:22:37 <int-e> > [1.0..1.49]
08:22:38 <lambdabot>  [1.0]
08:22:44 <Syzygy-> Oh, yeah. That's weird.
08:23:01 <Syzygy-> int-e: Does this last iteration look sensible?
08:23:13 <glguy> a scare on the face of haskell?
08:23:16 <roconnor> > logBase 2 10
08:23:17 <glguy> scar*
08:23:17 <lambdabot>  3.3219280948873626
08:23:24 <roconnor> > 130*it
08:23:25 <lambdabot>  Not in scope: `it'
08:23:28 <Cale> hm?
08:23:29 <roconnor> :)
08:23:38 <Cale> It makes sense to me
08:23:39 <roconnor> > 130*(logBase 2 10)
08:23:41 <lambdabot>  431.85065233535715
08:23:42 <int-e> Syzygy-: it does what you want, so yes it does.
08:23:56 <Cale> > [1..1.6]
08:23:57 <lambdabot>  [1.0,2.0]
08:24:03 <Cale> > [1..1.4]
08:24:05 <lambdabot>  [1.0]
08:24:07 <int-e> > [0,10..15]
08:24:09 <lambdabot>  [0,10]
08:24:10 <int-e> > [0,10..19]
08:24:11 <lambdabot>  [0,10]
08:24:14 <int-e> > [0,10..20]
08:24:15 <lambdabot>  [0,10,20]
08:24:31 <roconnor> float should not be in Enum!
08:24:33 <int-e> that's what I mean by 'weird'. it rounds instead of truncating.
08:24:38 <Cale> > [0,10..19]
08:24:39 <lambdabot>  [0,10]
08:24:41 <Cale> > [0.0,10..19]
08:24:42 <lambdabot>  [0.0,10.0,20.0]
08:25:01 <int-e> but of course if it did truncate, you'd not meet people's expectations.
08:25:17 <glguy> who expects that kind of behavior
08:25:19 <Cale> Considering what you'd probably use such enumerations for, it makes sense
08:25:23 <int-e> > [0,1/5..1] -- for stuff like this
08:25:25 <lambdabot>  [0.0,0.2,0.4,0.6000000000000001,0.8,1.0]
08:25:39 <gour> dcoutts__: hi, are you aware if hsql-sqlite3 (or hdbc) support user-defined functions?
08:25:50 <int-e> (not sure what to use in place of 1/5 there, but some fraction will work)
08:25:51 <roconnor> There was a discussion I read about this enumeration stuff, all the options are terrible.
08:26:08 <dcoutts__> gour: no idea, sorry.
08:26:18 <Cale> > [0,1/7..1]
08:26:19 <lambdabot>  [0.0,0.14285714285714285,0.2857142857142857,0.42857142857142855,0.5714285714...
08:26:22 <Cale> ugh
08:26:26 <Cale> > last [0,1/7..1]
08:26:28 <lambdabot>  0.9999999999999998
08:26:54 <Cale> glguy: It would sort of be a shame if that gave 0.857142857142857 instead.
08:26:57 <int-e> 1/9 does it
08:27:02 <int-e> > last [0,1/9..1]
08:27:02 <Cale> or yeah, 1/9
08:27:03 <lambdabot>  1.0000000000000002
08:27:11 <SimonRC> Aaaargh!  People doing weird things with the typesystem.
08:27:13 <glguy> Cale: I'd say it's a shame that it works at all ;)
08:27:31 <Cale> I don't know, such things are convenient to have around
08:27:36 <SimonRC> (Though optiona function argument could be handy
08:27:39 <SimonRC> )
08:27:58 <Cale> Especially when, say producing the graph of a floating point function.
08:28:02 <int-e> yep, you just need to know what they do when you use them.
08:28:04 <SimonRC> Few languages can claim to be able to implement such things in a library with static type checking
08:28:23 <glguy> I'd much rather see [fromIntegral n / 9 | n <- [0..9]]
08:28:24 <Cale> SimonRC: implement what?
08:28:30 <glguy> so you know exactly what you are getting
08:28:38 <Cale> glguy: well, you can write that too :)
08:28:49 <SimonRC> nononono
08:29:05 <SimonRC> I was thinking of this, and similar:   http://okmij.org/ftp/Haskell/keyword-arguments.lhs
08:29:07 <lambdabot> http://tinyurl.com/eaqcp
08:29:11 <Cale> Sometimes you want the behaviour that enumFromThenTo gives.
08:29:12 <int-e> glguy: I would do [n / 9 | n <- [0..9]] knowing that the sequence is exact because it consists of small enough integers.
08:30:49 <Cale> SimonRC: Ah, more of Oleg's typeclass swindling
08:30:52 <ndm> SimonRC: if you jsut don't read things by Oleg, its usually fine - i don't because i can't understand them
08:31:32 <Cale> Oleg does achieve some pretty cool effects from time to time. It's rare that it really seems worth all the trouble to me though.
08:32:20 <roconnor> Are we removing floating point types from Enum for haskell'?
08:32:24 <roconnor> please
08:36:19 <int-e> how does having those instances hurt anyone?
08:36:47 <mauke> > maxBound :: Float
08:36:52 <lambdabot>  add an instance declaration for (Bounded Float)
08:36:53 <lambdabot>   In the expression: maxB...
08:36:55 <int-e> that's Bounded
08:37:01 <mauke> just checking
08:37:03 <glguy> > succ 4.76
08:37:05 <lambdabot>  5.76
08:37:06 <int-e> that would hurt :)
08:37:19 <mauke> aren't floats bounded?
08:37:26 <sjanssen> > 1/0 :: Float
08:37:27 <lambdabot>  Infinity
08:37:33 <sjanssen> mauke: yes
08:37:42 <mauke> > [-1/0 .. 1/0]
08:37:43 <int-e> [-1/0 .. 1/0]
08:37:44 <lambdabot>  [-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infi...
08:37:49 <mauke> haha
08:38:00 <sjanssen> oh, you mean is there an instance Bounded Float, the answer there is no
08:38:29 <sjanssen> > [-1/0, 0 ..]
08:38:30 <lambdabot>  [-Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,N...
08:38:35 <sjanssen> better
08:38:47 <int-e> cute.
08:39:22 <Syzygy-> O.o
08:39:26 <roconnor> int-e: it hurts because only 12% of people know what enumFromTo does, and the other 78% will end up using it incorrectly in list shortands.
08:39:43 <jgrimes> what about the last 10%?
08:39:45 <Syzygy-> What -does- enumFromTo do then?
08:39:49 <Syzygy-> > 12+78
08:39:50 <lambdabot>  90
08:40:11 <jgrimes> :p
08:40:12 <roconnor> Syzygy-: exactly what it says in the haskell 98 report.
08:40:12 <int-e> enumFromTo a b = [a..b]
08:40:12 <int-e> ;)
08:40:18 <vincenz> int-e: erm, the other way around
08:40:25 <int-e> it's an equality.
08:40:29 <vincenz> no
08:40:33 <roconnor> Syzygy-: and if you can understand it, you get a gold star.
08:40:33 <vincenz> [a..b] == sugar
08:40:39 <Syzygy-> roconnor: Ah.
08:40:44 <Syzygy-> @where haskell98
08:40:45 <lambdabot> http://haskell.org/onlinereport/
08:40:49 <mauke> instance Enum a where enumFromTo a b = [a .. b]
08:40:58 <roconnor> jgrimes: the last 10% can't do math at all.
08:41:03 <vincenz> mauke: BWAHaHa
08:41:08 <jgrimes> roconnor, :)
08:41:19 <int-e> vincenz: what I wrote was meant to denote an equality, not a definition. I should turn it around to cause less confusion, but as an equality it's correct.
08:41:26 * vincenz nod
08:41:32 <vincenz> it is misleading, that's why I objected
08:41:40 * vincenz points at mauke 
08:42:01 <roconnor> enumFromTo a b == [a..b]
08:42:12 <int-e> anyway, yes, it's exact definitions are found in the Haskell report.
08:42:30 <Syzygy-> Ok. [Float..Float] wasn't that hard to understand.
08:42:31 <int-e> its
08:42:32 <roconnor> > quickCheck (enumFromTo a b) == [a..b::Double]
08:42:33 <lambdabot>  Not in scope: `b'
08:42:41 <vincenz> roconnor: gotta make it a func
08:42:42 <roconnor> > quickCheck (\a b -> (enumFromTo a b) == [a..b::Double])
08:42:43 <lambdabot>  Not in scope: `quickCheck'
08:42:48 <vincenz> @check..
08:42:49 <lambdabot>  Parse error
08:42:49 <roconnor> > quickcheck (\a b -> (enumFromTo a b) == [a..b::Double])
08:42:51 <lambdabot>  Not in scope: `quickcheck'
08:42:56 <roconnor> oh
08:42:59 <glguy> it's ?check
08:43:01 <roconnor> ?check (\a b -> (enumFromTo a b) == [a..b::Double])
08:43:03 <lambdabot>  OK, passed 500 tests.
08:43:03 <vincenz> @check (\a b -> (enumFromTo a b) == [a..b::Double])
08:43:04 <lambdabot>  OK, passed 500 tests.
08:43:45 * glguy wonders if there is a vim plugin that would allow one to save diffs while editing a file
08:43:52 <roconnor> Syzygy-: what is hard to understand is that it contains elements that are greater than b, sometimes.
08:44:02 <Syzygy-> So, enumFromTo keeps on adding 1 until it reaches b - up to being <= b+1/2 for floating types.
08:44:27 <Syzygy-> This containing bigger elements, thus, is an artefact on the floating check, which checks on membership in (-oo,b+1/2]
08:44:27 <jgrimes> yeah
08:44:35 <jgrimes> > enumFromTo 5.1 10.6
08:44:36 <lambdabot>  [5.1,6.1,7.1,8.1,9.1,10.1,11.1]
08:44:38 <jgrimes> :(
08:44:43 <roconnor> Syzygy-: sorry, it is enumFromThenTo that is even more messed up
08:44:53 <mauke> > [1.5, 2.5 .. 3]
08:44:55 <lambdabot>  [1.5,2.5,3.5]
08:45:09 <Syzygy-> roconnor: Yah. That looks more nontrivial.
08:45:18 <glguy> dcoutts__: does gtk2hs require gconf?
08:45:33 <SimonRC> ah, the usefulness of being able to have a function called ??????????
08:45:42 <mauke> > ?????
08:45:43 <lambdabot>  Parse error
08:45:53 <mauke> > (?????)
08:45:54 <lambdabot>  Not in scope: `?????'
08:46:09 <dcoutts__> glguy: no, it's optional
08:46:20 <SimonRC> mauke: nonono
08:46:23 <Syzygy-> So. enumFromThenTo a b c takes steps of b-a until you've gone past c+(b-a)/2
08:46:35 <dcoutts__> glguy: gtk2hs has several optional packages: glade, sourceview, mozembed, gconf
08:46:37 <Syzygy-> It's really not that much different from enumFromTo in that aspect.
08:46:38 <int-e> right, for Double.
08:46:46 * roconnor gives Syzygy- a gold star.
08:46:52 <Syzygy-> Yay!
08:46:58 <SimonRC> > let (?????)(????)(??????)=((??????),(????))in(3?????4)
08:47:00 <lambdabot>  (4,3)
08:47:03 <int-e> which is what you want if the right bound is exact
08:47:12 <roconnor> Syzygy-: See, it was an intuative definition wasn't it ;)
08:47:21 <Syzygy-> I'd even be prepared to say that it was the most obvious thing to do.
08:47:26 <int-e> > [1,3..10] -- but not necessarily for stuff like this.
08:47:28 <lambdabot>  [1,3,5,7,9]
08:47:43 <int-e> but the first case is useful enough, imho.
08:47:45 <Syzygy-> int-e: No, because you're not dodging float problems.
08:47:52 <Syzygy-> > [1::Double,3..10]
08:47:53 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
08:48:14 <roconnor> Syzygy-: Now try it in Haskell 1.3
08:48:16 <int-e> Syzygy-: I know why that instance rounds.
08:48:37 <Syzygy-> roconnor: I don't know where I'd get hold of Haskell 1.3, and I'm not that vested in the problem...
08:48:51 <int-e> Syzygy-: the point is, you can't expect it to be a drop-in replacement for the integer version. but in my opinion that's all right.
08:49:01 <roconnor> Syzygy-: well, I just read the Haskell 1.3 report.  I didn't try it.
08:49:05 <Syzygy-> int-e: That's a good point.
08:49:57 <roconnor> Syzygy-: It really screwed up my integration algorithm :)
08:50:12 <Syzygy-> Ouch, yeah I can see that...
08:50:56 <roconnor> Best to remove it, so that no one is happy.
08:51:12 <roconnor> well, I'd be happy.
08:51:51 <int-e> roconnor: move it to another module that needs to be imported explicitely. that should make everyone happy
08:52:16 <roconnor> int-e: even better, put all the different implementations into different modules that people can import.
08:53:50 <glguy> dcoutts__: the macport for gtk2hs doesn't depend on gconf directly, but assumes that gconf will be supported by gtk2hs and then tries to install that package whether or not it exists :)
08:55:47 <glguy> dcoutts__: otherwise everything seems ok on 2.10 so far
08:57:28 <sek> @type sum
08:57:30 <lambdabot> forall a. (Num a) => [a] -> a
08:59:46 <sek> > sum [1]
08:59:47 <lambdabot>  1
09:01:30 <ventonegro> > foldr1 (+) [1]
09:01:31 <lambdabot>  1
09:01:38 <sek> shouldnt sum check to see if the lengh is 1 and if it is then it prints the only element?
09:01:50 <int-e> > sum []
09:01:51 <lambdabot>  0
09:02:06 <int-e> sek: why?
09:02:16 <sek> because im calling sum on a list of one of my data types and its coming up with an extra element
09:02:49 <int-e> then your addition doesn't satisfy 0 + a = a
09:02:58 <sek> *PepaTimedSystemEquation> sum [TSEzero]     gives 0 + 0
09:03:14 <int-e> yes, that's correct.
09:03:29 <mauke> sum doesn't print anything
09:03:48 <int-e> 'return'
09:03:53 <sek> the show instance for TSESum does though
09:03:56 <ventonegro> @type sum
09:03:58 <lambdabot> forall a. (Num a) => [a] -> a
09:04:02 <glguy> he seems to have writen his own instance of Num
09:04:13 <sek> i have and it is simple i believe
09:04:15 <ventonegro> hum, lambdabot uses the extension
09:04:27 <int-e> sek: sum works correctly if 0 + a equals a. Your Num instance violates that law.
09:04:44 <glguy> which makes it not really a Num instance at all (c:
09:04:52 <int-e> sek: so surprises like this are to be expected.
09:05:05 <sek> basically if my data type is data Elem = Zero | Sum Elem Elem
09:05:34 <sek> and Show on Zero is 0. also the Num instance is (+) = Sum
09:05:51 <glguy> sek if that is your datatype, you'd never get numbers other than zero
09:05:51 <sek> and i call sum [Zero] and its printing 0 + 0
09:05:54 <sek> is that normal?
09:06:00 <int-e> yes.
09:06:01 <glguy> sek yes
09:06:06 <sek> glguy: i have other things in there but i didnt mention them:p
09:06:07 <int-e> it is normal and absolutely correct.
09:06:14 <sek> ah, ok
09:06:35 <sek> i am perprexing myself in vain then, heh
09:06:37 <int-e> you'll notice that 0 + 0 does equal 0 :)
09:06:46 * edwardk waves hello.
09:06:52 <therp> y
09:06:53 <sek> yeah, but what if i had One rather than Zero
09:06:59 <arcatan> hmm, so Chars support Unicode?
09:07:03 <int-e> then it'd be Zero + One
09:07:16 <sek> ofcourse, i see now
09:07:31 <int-e> the 0 doesn't come from the list, it's generated by fromInteger in your Num class.
09:07:32 <sek> [One] = [One:[]] and sum [] = Zero
09:08:09 <int-e> [One] = One:[]
09:09:34 <int-e> the result of Zero^10 should also look interesting.
09:09:59 <roconnor> int-e: indeed
09:11:01 <roconnor> oh wait, brackets are probably not printed?
09:11:27 <int-e> I hope they are
09:12:18 <sek> heh, show instance only prints with a * in between
09:12:31 <int-e> aww
09:12:37 <sek> ;p
09:14:36 <glguy> ?where mogul
09:14:37 <lambdabot> I know nothing about mogul.
09:15:46 <glguy> ?yarr
09:15:46 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
09:15:59 <int-e> sek: this should give you an idea: Mult (Mult (Mult (Mult (Var 'x') (Var 'x')) (Mult (Var 'x') (Var 'x'))) (Mult (Mult (Var 'x') (Var 'x')) (Mult (Var 'x') (Var 'x')))) (Mult (Var 'x') (Var 'x'))
09:18:44 <roconnor> @arr
09:18:44 <lambdabot> Har de har har!
09:18:56 <edwardk> ?yarr
09:18:57 <sieni> @arr
09:18:57 <lambdabot> Aye
09:18:57 <lambdabot> Drink up, me 'earties
09:19:09 <sieni> @yarr
09:19:09 <lambdabot> What be a priate's favourite cheese?
09:19:09 <lambdabot> Yarrlsburg!
09:19:19 <glguy> *someone has shit on the coats*
09:22:39 <int-e> sek: the show instance doesn't show that the equal subterms are shared in memory of course.
09:25:10 <sek> is that because of lazy evaluation or is that a principle in general?
09:25:28 <sek> i meaning keeping equal values in the same location
09:26:32 <sek> im assuming thats what you mean by shared in memory
09:26:42 <sek> s/meaning/mean/
09:26:52 <Cale> sek: Values which are equal because they came from the same variable are shared
09:27:15 <sek> lazy evaluation enforces that?
09:27:27 <Cale> Right, it's part of the definition of lazy evaluation
09:27:48 <Cale> Lazy evaluation is essentially outermost-first evaluation except with sharing.
09:28:33 <Cale> For example, if I had  double :: Int -> Int; double x = x + x; quadruple x = double (double x)
09:28:38 <Cale> and I wrote
09:28:42 <Cale> quadruple 1
09:28:50 <Cale> then this is  double (double 1)
09:28:55 <sek> 1 would be stored once but references 4 times
09:28:59 <Cale> and then the outermost double is expanded
09:29:07 <Cale> (double x) + (double x)
09:29:12 <Cale> but what you can't see here
09:29:13 <sek> *referenced
09:29:26 <Cale> is that those two (double x)'s are actually pointers to the same result
09:29:35 <sek> yeap
09:29:38 <Cale> so as soon as the left one is evaluated, the right one will be too
09:29:55 <Cale> Otherwise, it looks like we'll have to do more work
09:30:08 <Cale> (i.e. computation will be repeated)
09:30:16 <sek> yeah
09:30:30 <sek> we wrote a lazy evaluation interpreter in java a couple of months ago
09:30:33 <Cale> cool
09:31:06 <sek> i seem to remember mine didnt fully work though
09:31:09 <sek> heh
09:31:12 <Cale> hehe
09:32:00 <Cale> well, you were being forced to use Java
09:32:04 <Cale> heh
09:32:19 <sek> that must have been the reason:)
09:33:55 <int-e> writing a lazy evaluator in haskell seems to be a bit silly.
09:34:11 <Philippa> not entirely
09:34:12 <sek> im much happier coding haskell now. Even though the principles are quite different. i like not having to do uml and consider design patterns
09:34:18 <Philippa> although it's a little easier to do by accident
09:34:34 <Philippa> heh, yeah - the way design patterns tend to be one-line HOFs or typeclasses is cool
09:34:38 * araujo back
09:34:42 <araujo> yay!
09:34:42 <Philippa> and I never did like UML
09:34:51 <Philippa> 'lo araujo
09:34:58 <sek> uml is great when other people do it for you
09:35:02 <araujo> hi hi Philippa !
09:35:18 <int-e> I did enjoy writing a lambda interpreter though, without using higher order functions. the core evaluator is 9 lines of code (but a bit of the required work is done by the parser)
09:36:13 <sek> glyph22% cat *.java | wc -l
09:36:13 <sek> 1462
09:36:13 <sek> glyph22%
09:36:15 <sek> heh
09:36:31 <sek> thats parser, tokenizer, translator, the works
09:36:32 <int-e> poor soul
09:36:57 <Philippa> I tend to start off just by deriving Read on the datatype
09:37:06 <Philippa> usually I cba to write a nicer parser
09:42:20 <sek> hungry and cold here. Why on earth do they have airconditioning blasting rather than having bigger fans on all these computers
09:43:04 <ndm> often Drift is a good way to go
09:43:14 <ndm> with binary instance, otherwise Read/Show gets too slow
09:43:34 <ndm> but Read/Show is a nice little thing to have
09:43:42 <ndm> (deriving Binary would be so much nicer though)
09:44:39 <Philippa> sek: bigger fans on the comps does the wrong thing
09:45:08 <Philippa> the problem's room temperature, right? Comp fans're only supposed to adjust the temperature inside the case
09:45:34 <Philippa> deriving Binary would indeed be good
09:46:39 <bringert> lispy: you've got mail
09:46:51 <bringert> (lambdaweb patch)
09:49:34 <ndm> @seen int-e
09:49:34 <lambdabot> int-e is in #haskell-overflow and #haskell. I last heard int-e speak 13m 1s ago.
09:49:50 <ndm> int-e: you were asking me about SmallCheck being in a darcs repo right?
09:49:54 <ndm> (or was it someone else)
09:50:16 <int-e> ndm: that was someone else
09:50:38 <ndm> ah well :) - guess there's probably even no way to find out who...
09:52:35 <int-e> SamB or dons, maybe? *reads channel logs*
09:59:01 <ndm> was dons and someone else, was trying to remember the someone else...
09:59:12 <ndm> google doesn't search IRC logs does it?
09:59:48 <lispy> ndm: probably me
09:59:54 <lispy> ndm: i asked Colin about it
10:00:13 <lispy> ndm: he thought it seemed excessive and tar is ubiquitous by comparison
10:00:16 <ndm> lispy: he says he wants to keep it small, so doesn't really want many patches - but if you have ideas, email him
10:01:00 <lispy> ndm: mainly, if it's in darcs i can get it really easy, if it's in tar i need extra steps...and then if i want to change something it's a pain...i actually haven't downloaded it yet because i didn't want to deal with tar :)
10:01:17 <lispy> well, wget/tar
10:01:21 <ndm> lispy: i entirely agree, but he's not really a darcs kind of person...
10:01:39 <lispy> yeah, too bad
10:01:59 <ndm> i'll work on him, just for ease of downloading would be nice, and so someone can shove in a Cabal file
10:02:31 <lispy> oh, he doesn't use cabal either?
10:02:42 <lispy> wait, so if it's just one file, how is tar useful?
10:02:47 <ndm> hehe, i don't know, but would be deeply shocked if he did!
10:03:04 <lispy> i mean, it's not even ziped
10:03:15 <lispy> with 'darcs dist' he'd at least get a tar.gz
10:03:16 <scsibug> there are actually a few files in the tar....including a README
10:03:32 <ndm> i would guess at a readme
10:03:33 <lispy> ah, READMEs are good
10:03:34 <ndm> just downloading it now :)
10:03:45 <lispy> ?scheck True
10:03:47 <lambdabot>  Completed 1 test(s) without failure.
10:04:01 <lispy> for now that's how i play with small check :)
10:04:02 <ndm> and two examples as well
10:04:19 <ndm> @scheck reverse (reverse x) == x
10:04:19 <lambdabot>  Not in scope: `x'
10:04:26 <ndm> @scheck \ x -> reverse (reverse x) == x
10:04:26 <lambdabot>  Add a type signature
10:04:36 <ndm> @scheck (\ x -> reverse (reverse x) == x) :: [Int] -> Bool
10:04:40 <lambdabot>  Completed 623530 test(s) without failure.
10:04:53 <ndm> @scheck (\ x -> minimum x == head x) :: [Int] -> Bool
10:04:54 <lambdabot>  Exception: Prelude.minimum: empty list
10:05:08 <ndm> @scheck (\ x -> not (null x)  ==> minimum x == head x) :: [Int] -> Bool
10:05:09 <lambdabot>  Couldn't match `Bool' against `Property'
10:05:25 <ndm> @scheck (\ x -> not (null x)  ==> minimum x == head x) :: [Int] -> Property
10:05:27 <lambdabot>   Failed test no. 69284. Test values follow.: [0,-1]
10:05:42 <ndm> ah, dons has fixed it so it does iterative deepening now :)
10:05:45 <lispy> some of the random values are pathetic though
10:05:58 <ndm> they aren't random! thats teh whole point!
10:06:05 <ndm> its enumeration, not random generation
10:06:06 <lispy> but about lists?
10:06:12 <ndm> enumeration
10:06:31 <ndm> for example, if i do the same property, will fail with the same example each time
10:06:34 <ndm> @scheck (\ x -> not (null x)  ==> minimum x == head x) :: [Int] -> Property
10:06:35 <lambdabot>   Failed test no. 69284. Test values follow.: [0,-1]
10:06:52 <inv2004> hi all
10:06:58 <ndm> hi inv2004
10:07:11 <lispy> ?scheck \s -> not $ any (\y -> y < (-10) || y > 10) (s::[Int])
10:07:15 <lambdabot>  Completed 623530 test(s) without failure.
10:07:35 <inv2004> is ti posiible to trace programm step-by-step ? (I use hugs)
10:07:40 <inv2004> possible
10:08:03 <lispy> ndm: according to that is is a list of ints with very small magnitude :)
10:08:16 <inv2004> is it possible to trace program step-by-step ? (I use hugs)
10:08:18 <lispy> inv2004: there are ways yes
10:08:24 <glguy> ?scheck \xs -> length xs < 10
10:08:25 <lambdabot>  Add a type signature
10:08:25 <ndm> inv2004: not really, Hat gives you some of that, but its not really easy
10:08:28 <profmakx> @yarr
10:08:28 <lambdabot> Shiver me timbers!
10:08:30 <dolio> @scheck (\(x :: [Int]) -> not (null x) ==> minimum x == head (sort x))
10:08:30 <lambdabot>  Parse error in pattern
10:08:39 <ndm> lispy: you can write your own Int instance, really easy to do
10:08:39 <glguy> ?scheck \(xs :: [Int]) -> length xs < 10
10:08:39 <lambdabot>  Parse error in pattern
10:08:53 <lispy> ndm: ah, that's good to know
10:08:54 <glguy> ?scheck \xs -> length (xs :: [Int]) < 10
10:08:57 <lambdabot>  Completed 623530 test(s) without failure.
10:09:02 <glguy> ?scheck \xs -> length (xs :: [()]) < 10
10:09:03 <lambdabot>  Completed 9 test(s) without failure.
10:09:16 <ndm> lispy: i'm actually surprised it has negative numbers at all, Colin doesn't believe in them
10:09:17 <glguy> ?scheck \xs -> length (xs :: [()]) < 9
10:09:18 <lambdabot>  Completed 9 test(s) without failure.
10:09:24 <glguy> ?scheck \xs -> length (xs :: [()]) < 8
10:09:26 <lambdabot>   Failed test no. 9. Test values follow.: [(),(),(),(),(),(),(),()]
10:09:29 <lispy> ndm: because i probably will start using quick check at work...especially with some of my Enum instances it would be great because i could exhaustively test quite a bit of my code
10:09:55 <ndm> yeah, it does iterative deepening as well - so the longer you run, the more its tested
10:09:55 <lispy> and exhaustively verified == good enough for me :)
10:10:28 <ndm> yeah, i guess it is a real proof
10:10:59 <dcoutts__> hmm, gzip is faster at compressing than zlib, even though they do the same format and were written by the same person!
10:11:15 * dcoutts__ benchmarks his zlib bindings
10:11:19 <ndm> dcoutts__, and produces the same binary output?
10:12:25 <dcoutts__> ndm: yep
10:12:54 <dcoutts__> ndm: well gzip produces slightly different outpt from zlib's gzip format. header info is different. but they decompress to the same
10:13:19 <dcoutts__> gzip actually puts more info into the gzip stream header
10:13:42 <ndm> i was thinking about the compressed data - is it the same compressed data?
10:13:48 <dcoutts__> no
10:13:52 <ndm> or is one smaller than the other?
10:13:54 <dcoutts__> because of the different header
10:14:01 <dcoutts__> gzip is a few bytes bigger
10:14:02 <ndm> excluding the header?
10:14:06 <dcoutts__> you can't
10:14:19 <dcoutts__> they get compressed together I think
10:14:53 <dcoutts__> but it produces the same output as the reference zpipe.c from the zlib website
10:15:15 <dcoutts__> I'd always assumed that gzip used zlib but no
10:15:31 <dcoutts__> it's got it's own copy of deflate.c
10:15:57 <dcoutts__> which is apparently faster
10:16:11 <dcoutts__> I get the same speed as the reference zpipe.c
10:16:26 <dcoutts__> but gzip is faster by 25% or so in this example
10:17:31 <pianodogg> dcoutts__: with your own impl or just bindings
10:17:41 <dcoutts__> pianodogg: zlib bindings
10:17:57 <pianodogg> are you using your string buffers in this case then :)
10:18:12 <dcoutts__> lazy ByteStrings yes
10:18:32 <dcoutts__> so you can easily compress & decompress streams lazily
10:19:28 <pianodogg> a lot of interfaces could usefully use those byte strings
10:19:34 <dcoutts__> aye
10:19:41 <pianodogg> it's unfortunate that they might already use strings
10:19:47 <pianodogg> so there must be two copies of the interfaces
10:20:05 <dcoutts__> well you only need it when performance is important
10:20:06 <pianodogg> since a bytestring -> string -> whatever conversion might not be compiled by ghc in the kindest way
10:20:22 <dcoutts__> actually it fuses pretty well
10:20:55 <pianodogg> such that new interfaces need not be written to explicitly use bytestrings?
10:21:09 <pianodogg> (your use of the word "fuses" reminds me of your paper... should look at it again...)
10:21:21 <dcoutts__> indeed, all about fusion :-)
10:21:40 * lispy is reminded of dbz
10:21:57 <glguy> +o  -o  remindes me of dbz
10:22:22 <lispy> +o -o?
10:22:32 <glguy> irc user modes
10:22:54 <lispy> glguy: you lost me...you'll have to explain :)
10:22:54 <dcoutts__> pianodogg: it really depends on what the code is doing if it'd benefit a lot from using bytestrings
10:23:05 <dcoutts__> generally things dealing with lots of data benefit
10:23:08 <pianodogg> dcoutts__: well of course
10:23:19 <pianodogg> dcoutts__: it's essentially a bandwidth thing
10:23:25 <dcoutts__> so I don't think we need to go round converting all apis to ByteString
10:23:27 <glguy> lispy: when ops +o kick and -o
10:23:28 <ndm> dcoutts__, feel free to submit a patch changing Yhc to ByteString's :)
10:23:34 <dcoutts__> ndm: heh heh
10:23:43 <ndm> i'm dead serious!
10:23:44 <dcoutts__> ndm: what do you use for your lexer btw?
10:23:57 <ndm> good question, no idea - quite possibly parser combinators
10:24:00 <dcoutts__> lexer + parser
10:24:11 <lispy> glguy: i still don't get it :)
10:24:22 <lispy> glguy: but maybe that's okay...
10:24:39 <dcoutts__> ndm: there is continuing talk of a parsec-like thing for bytestrings
10:24:48 <dcoutts__> ndm: making alex use bytestrings would be trivial
10:25:01 <ndm> dcoutts__, would be nice - my parser will support ByteString's natively
10:25:10 <dcoutts__> oh?
10:25:28 <ndm> definately
10:25:32 <dcoutts__> this is your parser generator?
10:25:35 <ndm> yep
10:25:43 <glguy> bytestrings... isn't that the library for people with slow computers?
10:25:48 <glguy> j/k (c:
10:25:50 <dcoutts__> the super duper (not quite existing) one
10:25:51 <Philippa> remind me, how easy is it to make parsec use a silly amount of space?
10:25:55 <ndm> it supports C, so adding Haskell ByteString's is easy enough
10:26:29 <dcoutts__> ndm: to what extent does it exist?
10:26:35 <_dolio> Yikes. mathschallenge is dead.
10:26:40 <glguy> what??
10:26:52 <glguy> oh dear
10:27:00 <ndm> dcoutts__, slightly  - there is a prototype in C#, some intial stuff in Haskell
10:27:08 <dcoutts__> oh ok
10:27:18 <dcoutts__> and you can parse C already?
10:27:25 <ndm> plus the algorithms are confluent, terminating and have had their space bounds done
10:27:31 <dcoutts__> nice
10:27:49 <ndm> oh, by support C, i mean output C - i.e. one parser can parser <language> and output C, Haskell, Haskell ByteString etc.
10:27:57 <dcoutts__> ah right
10:28:07 <ndm> so you only need to write a parser for C once, and will definately be on the todo list
10:28:14 <pianodogg> ndm: multiplatform yacc then
10:28:17 <glguy> _dolio: serves them right for now posting new problems...
10:28:24 <pianodogg> er multioutput lang
10:28:26 <_dolio> :)
10:28:31 <dcoutts__> ndm: it's a royal pain in the posterior
10:28:34 <ndm> pianodogg: yes, my parser > yacc
10:28:38 <pianodogg> ha
10:28:49 <pianodogg> ndm: what, parsing C?
10:28:50 <ndm> dcoutts__, i am aware...
10:29:21 <pianodogg> parsing C is cake compared to other things
10:29:39 <Philippa> yeah, it's C++ that's the hard one
10:29:40 * dottedmag .oO(like parsing C++)
10:29:47 <Philippa> snap!
10:29:47 <pianodogg> or java 1.5
10:30:20 <glguy> It seems like haskell would be a little annoying with the spacing based blocks
10:32:35 <pianodogg> why would one invent a syntax which makes parsing so crazy?
10:32:43 <pianodogg> humans have to disambiguate it too
10:33:04 <dcoutts__> ndm: you need feedback between your lexer & parser to do C
10:33:05 <dcoutts__> ndm: ie a lexer monad
10:33:05 <dcoutts__> and some control over *when* productions get reduced
10:33:07 <dcoutts__> ugly ugly
10:33:24 <ndm> dcoutts__, you are entirely assuming the traditional lexer/parser split, which mine doesn't have
10:33:36 <ndm> and whats this "productions get reduced" stuff - thats not in my parser!
10:33:49 <pianodogg> ooh do tell then
10:33:56 <pianodogg> what IS in your parser
10:34:05 <glguy> it's a list of all possible C programs
10:34:07 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/parsing.php
10:34:10 <lambdabot> Title: Neil Mitchell - Parsing, http://tinyurl.com/g8j88
10:34:13 <glguy> and some pattern matching ;)
10:34:15 <pianodogg> glguy: ha ha
10:34:16 <ndm> pianodogg: thats my parser ^^^
10:34:38 <pianodogg> glguy: pretty big list then, eh?
10:34:45 <edwardk> aww, simon m didn't go @arr
10:34:56 <pianodogg> @arr
10:34:57 <lambdabot> Yeh scurvy dog...
10:34:58 <mauke> parsing C without a separate lexer is even harder
10:46:04 <pianodogg> indeed how would you parse C without separately discovering that certain identifiers are typedefs, structs, etc.
10:48:23 <glguy> that's probably handled by his "groups"
10:49:01 <glguy> nt girl?
10:49:41 <mauke> pianodogg: that part is easy
10:50:01 <mauke> you can just categorize identifiers in the parser
10:50:24 <mauke> the problem with C is the preprocessor
10:50:35 <integral> glguy: do you have a problem with my nick?
10:50:39 <pianodogg> re-lexing stuff you mean
10:51:08 <pianodogg> mauke: "categorize identifiers in the parser" requires lexer magic ahead of time
10:51:13 <mauke> pianodogg: nope
10:51:16 <glguy> integral: do you have a problem with my comment?
10:51:24 <integral> Not really :)
10:51:36 <glguy> then were good all around :-p
10:51:40 <pianodogg> okay fine
10:51:46 <mauke> pianodogg: I've written a simple scannerless declaration parser before
10:52:02 <pianodogg> i'm stuck in my lex/yacc world view
10:52:27 <mauke> pianodogg: just have a lex that returns a token for every char
10:52:40 <mauke> the describe the entire language in the yacc grammar
10:52:55 <pianodogg> well sure you _could_ do that
10:53:00 <pianodogg> :)
10:54:29 <glguy> Does anyone know if it's fairly standard to need to use IORefs when writing applications in gtk2hs to store the application state?
10:54:42 <pianodogg> is it really necessary to parse c/c++ in one pass though?  implement the preprocessor separately
10:55:01 <pianodogg> glguy: in the examples i've seen... yes
10:55:32 <ndm> glguy: yes, with me i always do
10:55:35 <glguy> I guess it's not a big deal to use the IORefs since all user input happens in the IO monad anyway
10:56:01 <pianodogg> gui's are inheritantly i/o dominant, so might as well program that way
11:07:14 <glguy> the dependency list for glade is fsking huge
11:07:31 <glguy> using macports you basically have to install all of gnome first
11:10:22 <dolio> Well, you would need gnome to use a gnome interface building, right? :)
11:10:27 <dolio> Builder, even.
11:11:12 <lispy> you guys talk a lot :)
11:11:32 <lispy> i leave for 40 min and the channel is full of text :)
11:12:08 <glguy> I don't need esound :-p
11:12:20 <dolio> Heh.
11:12:23 <glguy> and glade on windows sure doesn't need gnome
11:12:43 <glguy> hell, there's probably a glade os x installer that I should be using
11:13:00 <dolio> It's probably all statically linked on windows or something.
11:13:21 <glguy> there needs to be a native gtk2 for os x
11:13:37 <glguy> there is one
11:13:58 <glguy> in progress at least
11:15:55 <int-e> dolio: ping
11:16:01 <dolio> Yes?
11:16:21 <glguy> mathschallenge.net lives
11:17:23 <int-e> dolio: You discussed problem 127 of the project euler here a while ago. was the time you gave for the C version (0.026 seconds IIRC) for building a table of rad values or for the complete algorithm?
11:17:58 <dolio> int-e: Complete algorithm, I suspect.
11:18:26 <glguy> no one has solved it since dolio did
11:18:31 <int-e> dolio: how did you avoid the O(n^2) running time of trying all possible pairings for the sums?
11:18:43 <int-e> glguy: I don't have an account :-P
11:18:46 <glguy> int-e: that's the basis of the problem
11:18:47 <ventonegro> is there a way to specify "or" class contexts?
11:18:58 <glguy> int-e: to optimize away the unnecessary values
11:19:26 <int-e> glguy: hmm? precomputing the rad values is enough to make it run in a few seconds.
11:19:37 <int-e> glguy: no further effort required.
11:19:37 <glguy> if you sort the list by rad values
11:19:54 <glguy> you can test the values until one is too big
11:19:56 <int-e> ah.
11:19:58 <glguy> and then move on to the next
11:20:15 <int-e> yes, that should make it faster. thanks.
11:20:19 <glguy> and if rad c * 2 isn't < c then skip that c
11:20:52 <int-e> I did that
11:21:02 <int-e> and I also have special cases for rad <6'
11:21:03 <glguy> and you only need to do one gcd test
11:21:16 <glguy> and not 3
11:21:37 <int-e> I know
11:21:48 <glguy> k,then that's all I got for ya ;)
11:22:30 <glguy> int-e: are you only using Ints and not Integers?
11:22:32 <dolio> Yeah, I'm not sure if i'm missing something, or if the C methods are more efficient than the Haskell list processing.
11:22:40 <int-e> glguy: I was writing it in C.
11:22:43 <glguy> oh
11:23:06 <araujo> anybody got a good doc to write ghc libs?
11:23:14 <dolio> But I'm too lazy to read through the 2 pages of Delphi code for the "really fast" solution.
11:23:20 <int-e> glguy: it's straight forward number crunching, so I didn't even think of using Haskell.
11:23:42 <glguy> int-e: I used Haskell for all of the problems... I just used that site as a Haskell learning too
11:23:45 <glguy> l
11:24:01 <lispy> int-e: don't remember if i told you.  i fixed the problem with bf
11:24:03 <lispy> ?version
11:24:04 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
11:24:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:24:20 <lispy> int-e: but dons isn't running that version yet (I don't think)
11:24:24 <int-e> lispy: you didn't. I'd have noticed with the next lambdabot pull :)
11:24:30 <int-e> lispy: sooner or later.
11:24:46 <lispy> int-e: webversion has it fixed
11:24:52 <lispy> ?where lambdaweb
11:24:53 <int-e> @bf [[+.]+]
11:24:53 <lambdabot> Done.
11:24:53 <lambdabot> http://lambdabot.codersbase.com/
11:25:02 <glguy> int-e: why haven't you created an account? how do you check if you have the correct answers?
11:25:03 <lispy> try it here ^^^^
11:25:18 <int-e> lispy: it's fixed, it didn't require a lambdabot restart.
11:25:41 <int-e> glguy: I wasn't bored enough.
11:25:54 <int-e> glguy: it's hardly worth it for a single problem
11:26:23 <glguy> it doesn't ask for any information other than an email user and password, and you can skip the email step :-p
11:30:25 <ventonegro> there is System.Posix.Files for handling files in posix systems
11:30:29 <ventonegro> what about Windows?
11:32:05 <int-e> glguy: where is the 'I did it on paper' programming language?
11:36:08 <glguy> int-e : it's Pen & Paper
11:36:17 <glguy> int-e: or Paper & Pencil or something
11:36:50 <int-e> thanks
11:38:24 <glguy> I want to meet the genius that did the pandigital fibonacci number problem on paper
11:39:45 <int-e> I have a hard time believing that.
11:40:01 <glguy> there are quite a few problems that either someone is lying about
11:40:03 <lispy> pandigital?
11:40:05 <glguy> or is amazing
11:40:25 <glguy> lispy: the first and last 9 digits of the number contain the digits [1..9]
11:40:35 <glguy> in that particular problem
11:40:52 <lispy> and someone found a fibonacci number like that by hand?
11:40:59 <glguy> I don't believe it
11:41:05 <glguy> but I'm pretty sure that osmeone claims to have
11:41:07 <dolio> In most other problems, they use it to mean an n digit number that uses the digits 1 to n.
11:41:19 <lispy> well, they probably found some 'rules' and heuristics to help them locateit
11:41:26 <glguy> lol
11:41:28 <glguy> yeah
11:41:46 <glguy> and then calculated the fib series out to the 30000 range
11:41:47 <glguy> on paper
11:41:52 <lispy> but it sounds more like numerology than math
11:42:22 <lispy> gauss supposedly factored primes numbers whenever he had spare time
11:42:36 <dolio> Factoring primes is easy. :)
11:42:42 <lispy> and he would chunk off large ranges like 10k numbers at a time and plow through it pretty fast
11:42:48 <lispy> er
11:42:54 <dolio> Give me an arbitrary prime and I will factor it for you. :)
11:42:55 <lispy> well, sorry, factored numbers into primes :)
11:42:58 <int-e> sieve?
11:43:16 * lispy waves at cygnus 
11:43:34 * cygnus smirks
11:43:36 <lispy> cygnus: tonight is a developer meeting for #darcs, so i'll be up in portland tonight
11:43:47 <cygnus> lispy: awesome
11:44:20 <lispy> cygnus: probably too hectic to say hi though
11:44:28 <cygnus> that's what I figured
11:44:39 <cygnus> I'll just wave at you from across town
11:45:07 <lispy> heh
11:45:30 * lispy gets angry at his printer...and his printer won't like him when he's angry
11:45:35 * lispy starts to turn green
11:45:43 <glguy> don't puke!
11:45:57 <cygnus> printers have a habit of getting taken out into fields to get beaten up
11:46:13 <glguy> damn it feels good to be a gangster
11:46:17 * cygnus nods
11:46:52 <lispy> heh
11:46:59 <glguy> I look good, I look real good. Hey Everybody! come see how good I look!
11:47:27 * lispy power cycles the printer
11:47:51 <lispy> glguy: your nick makes that all the more vain
11:48:15 <lispy> nice, now everything i've printed in the last week seems to be coming out...
11:48:23 <cygnus> hah
11:48:30 <glguy> Good looking guy?
11:48:32 <lispy> in triplicate of course
11:48:57 <lispy> glguy: ya, i forgot what it really meant...some org you're in
11:49:13 <glguy> lispy: it doesn't mean anything anymore :)
11:49:21 <glguy> lispy: it's an artifact of my past
11:49:51 <lispy> ah, like my ex-gf
11:50:07 * lispy makes the bitter grin
11:50:08 <glguy> Do you use her everyday?
11:50:29 <glguy> but she has no meaning to you?
11:50:33 * lispy realizes this has become a #haskell-blah conversation :)
11:50:51 <glguy> When a #haskell converstation starts, we can stop
11:51:31 <dolio> Yikes. Pairs implemented using cond and numbers? How untraditional.
11:51:35 <lispy> my kingdom for a stapler....
11:55:50 <glguy> self advertising irc clients are the bane of my existence!
11:56:13 <dolio> :) Mine doesn't mention konversation anymore, does it?
11:56:19 <dolio> I think I changed it to a bash fork bomb.
12:01:32 <beelsebob> @arr
12:01:32 <beelsebob> ?arr
12:01:33 <lambdabot> Yeh scurvy dog...
12:01:33 <lambdabot> Keelhaul the swabs!
12:01:48 <beelsebob> yarr, lambdabot do be keeping up the days festivities
12:01:57 <SamB> int-e, ndm: I mentioned the subject of SmallCheck being in darcs, yes...
12:02:46 <SamB> there is a slightly modified version in lambdabot's repo, actually...
12:04:41 <SamB> man I am no good at observing talk like a pirate day
12:04:45 <SamB> I keep forgetting about it!
12:05:05 <dolio> I wouldn't worry about it too much.
12:05:57 <tibbe> yarr
12:06:05 <glguy> lambdabot is keeping track
12:06:09 <glguy> so don't get too comfortable
12:08:37 <glguy> If I ever meet any of the IE developers, I'm going to kick them squarely in the junk
12:09:14 <tibbe> glguy: how come?
12:09:38 <glguy> because of the way they implemented CSS
12:09:46 <ventonegro> actually, they're monkeys typing randomly
12:09:53 <glguy> like "Hmm, its friday, and we still need css support
12:10:00 <glguy> lets get something done before the weekend"
12:10:10 <glguy> *ship it*
12:10:34 <glguy> Hey Mike... What's this CSS standard document?
12:10:41 <abcde`> you didn't NEED position:fixed, did you?
12:10:43 <glguy> I found it wrapped around my cheeseburger
12:12:16 <tibbe> glguy: I was under the impression that most of IE was done before CSS was standardized but I could very well be wrong
12:12:44 <therp> usually I don't like when people bitch about software -- but this time it's really funny :)
12:13:14 <ventonegro> tibbe, so was netscape, the code base of mozilla
12:13:58 <glguy> I'd feel bad for the IE devs , since rendering out HTML and CSS is hard, if there weren't so many examples of how to do it better
12:14:09 <tibbe> ventonegro: I would guess that MS didn't want to put money into IE anymore
12:16:51 <glguy> If I ran this company, people running IE would see a message that their browser was outdated, and that they need to get into the 21st century to get the full browsing experience
12:16:59 <glguy> but I guess that's why I'm not in charge of the company
12:18:02 <glguy> How obsurd would it be to have a plug-in for IE, much like the flash player, that used gecko (for example) to render HTML?
12:18:06 <SamB> glguy: meaning that people who are in charge of companies don't get there by worrying overmuch about what webbrowsers people use?
12:18:25 <glguy> SamB: that they wouldn't alienate the whole of their customer base
12:18:40 <glguy> but yours was a valid point to
12:18:47 <SamB> glguy: oh, I thought you meant employees
12:20:06 <dmhouse> Time to own up. Who's 82.25.146.175?
12:20:29 <glguy> not me
12:21:15 <glguy> 175.146.25.82.in-addr.arpa domain name pointer cpc1-fare3-0-0-cust686.cos2.cable.ntl.com.
12:21:16 <ventonegro> me neither
12:21:29 <glguy> You'll have to call ntl ;)
12:21:49 <glguy> what's that person doing?
12:21:53 <glguy> haxoring your boxen?
12:22:30 <dmhouse> Nah. They added some stuff to the Wikibook and I'd like to discuss it with them.
12:22:39 <glguy> link?
12:22:43 <dmhouse> Besides, I believe hax0ring is spelt with a 0.
12:22:52 <SamB> > filter ((== read "82.25.146.175?") . ipAddress) #haskell
12:22:53 <lambdabot>  Not in scope: `haskell'
12:22:55 <glguy> Obviously I don't do much of it
12:23:05 <dmhouse> ?where wikibook
12:23:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:23:11 <glguy> I already did a /who on the address and hostname
12:23:49 <dmhouse> Their specific contributions are at http://en.wikibooks.org/w/index.php?title=Special:Contributions&target=82.25.146.175
12:23:52 <lambdabot> http://tinyurl.com/jaqo8
12:25:20 <glguy> You don't like the story of the lion and the cage
12:25:21 <glguy> ?
12:25:51 <dmhouse> It's a fun story. :) It's just not that well explained.
12:26:16 <dmhouse> And I think it'd fit better in somewhere else in that article.
12:28:05 <glguy> I like how he uses Haskell comments -- when he writes "not haskell code"
12:28:23 <glguy> it makes me wonder if that is also not a haskell comment
12:28:44 <glguy> ;)
12:30:45 <Philippa> /* this is not a C comment */
12:31:06 <glguy> This statement can not be proven in the principia mathematica
12:32:01 <roconnor> @yarr
12:32:02 <lambdabot> I want me grog!
12:32:05 <abcde`> This sentence is in Spanish while you're not looking
12:32:16 <glguy> gour: why don't you go advertise your irc client eslewhere?
12:32:23 <dmhouse> glguy: I'm reading that book currently :)
12:32:41 <glguy> dmhouse: I've been trying to get through it for a long time
12:33:03 <glguy> mnislaih++
12:33:19 <dmhouse> I'm about halfway through, and have hit a bit section of less interesting stuff on the structure of brains.
12:33:29 <Philippa> glguy: you mean the gour who's not reading? Unfortunately, most clients have a default part/quit message that advertises them
12:33:31 * dmhouse prefers the mathematics and logic.
12:33:47 <glguy> Philippa: I'm aware of both of these things
12:34:02 <glguy> (c: but I appreciate your concern
12:39:05 <glguy> glguy: 1 , IE: 0
12:40:46 <Blastur> hello! I'm trying to understand some haskell code, and at one place they use a weird looking expression: h 'max' (hp - 1) .. what does the 'max' part mean?
12:41:09 <glguy> `max` means use max like an inline function
12:41:10 <dmhouse> Blastur: you mean `max`?
12:41:16 <glguy> that is the same as: max h (hp -1)
12:41:31 <Blastur> yeah, sorry, maybe it's `max`
12:41:45 <Blastur> so what would max h (hp - 1) do? just max of h and (hp-1)?
12:42:01 <glguy> with symbols you can have: (+) 1 2 or 1 + 2, with words you have max 1 2 or 1 `max` 2
12:42:02 <dmhouse> max is a function that takes two things that can be compared and returns which one's the bigger of the two.
12:42:06 <dolio> > 2 `max` 1
12:42:07 <lambdabot>  2
12:42:09 <Lemmih> Blastur: Yes.
12:42:10 <dmhouse> > max 2 5
12:42:11 <lambdabot>  5
12:42:27 <Blastur> cool, thanks a bunch
12:42:51 <Blastur> what is the benefit of writing it in that weird fashion?
12:42:58 <dmhouse> Blastur: http://en.wikibooks.org/wiki/Haskell/More_on_functions#Infix_versus_Prefix might help.
12:43:01 <lambdabot> http://tinyurl.com/eb7rs
12:43:02 <Blastur> i think max a b makes more sense
12:43:11 <Lemmih> Blastur: It can be easier to read.
12:43:29 <dolio> a `mod` b is similar to mathematical notation, for instance.
12:43:29 <glguy> Blastur: a common example is : 4 `div` 3
12:43:34 <glguy> where div is integer division
12:43:35 <dolio> I'm not sure why you'd use it for max, though.
12:43:47 <Blastur> ah, yeah, of course.. that makes sense
12:44:15 <glguy> infix notation can also be used instead of flip
12:44:26 <glguy> flip f a   or   (`f` a)
12:44:41 <dmhouse> > 5 `elem` [1..10] -- another canonical example
12:44:42 <lambdabot>  True
12:45:20 <glguy> ?check "watching the game" /= "drinking a bud"
12:45:22 <lambdabot>  OK, passed 500 tests.
12:45:26 <glguy> bah :)
12:45:31 <glguy> > "watching the game" /= "drinking a bud"
12:45:33 <lambdabot>  True
12:45:47 <dmhouse> Heh :)
12:45:49 <Blastur> > hi
12:45:51 <lambdabot>  Not in scope: `hi'
12:46:04 <Blastur> > max [1..]
12:46:05 <lambdabot>  Add a type signature
12:46:17 <Blastur> > max [1..] 5
12:46:18 <lambdabot>  add an instance declaration for (Num [a])
12:46:23 <Blastur> oh man, i suck :)
12:46:25 <dmhouse> > maximum [1..5]
12:46:26 <lambdabot>  5
12:46:36 <Blastur> > maximum [1..]
12:46:41 <lambdabot> Terminated
12:46:41 <dmhouse> max finds the max of two values. maximum finds the maximum value in a list.
12:47:05 <dmhouse> If you've covered folds already, maximum = foldr1 max
12:47:10 <dolio> > foldr1 max [1..5]
12:47:11 <lambdabot>  5
12:47:25 <Blastur> yeah, it was long ago i actually used haskell
12:47:35 <glguy> > map chr $ ap (++) (map (+1)) [ord 'h']
12:47:37 <lambdabot>  "hi"
12:47:40 <Blastur> i was just reading an article with some code, and i needed to understand it
12:47:59 <dmhouse> > "hi"
12:48:00 <lambdabot>  "hi"
12:48:08 <dmhouse> Mine's shorter :)
12:48:11 <glguy> > map chr $ ap (++) succ "h"
12:48:12 <lambdabot>  Couldn't match `Int' against `Char'
12:48:25 <glguy> > map chr $ ap (++) (map succ) "h"
12:48:27 <lambdabot>  Couldn't match `Int' against `Char'
12:48:35 <glguy> > ap (++) (map succ) "h"
12:48:37 <lambdabot>  "hi"
12:48:56 <glguy> dmhouse: you just jumped straight there! no fair
12:49:17 <irgs> anyone here using haskelldb? i'm trying to figure out how to generate a dbspec from an existing database
12:50:15 <basti_> i used it once, to try it
12:50:33 * basti_ tries to remember
12:50:36 <dmhouse> > reverse "ih" -- how's this?
12:50:37 <lambdabot>  "hi"
12:50:58 <glguy> > take 2 $ drop 7 $ fix (('a':) . map succ)
12:50:59 <lambdabot>  "hi"
12:51:58 <irgs> hmm
12:52:05 <basti_> >_<
12:55:27 <glguy> > replicateM 2 ['a'..'z'] !! 190
12:55:29 <lambdabot>  "hi"
12:56:03 <dolio> @type replicateM
12:56:04 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
12:56:10 <Syzygy-> > replicateM 2 ['a' .. 'z'] !! 175
12:56:11 <lambdabot>  "gt"
12:56:18 <basti_> are you trying to find out the most possible ways to type "hi"?
12:56:21 <xerox> ?yow
12:56:22 <lambdabot> Now KEN and BARBIE are PERMANENTLY ADDICTED to MIND-ALTERING DRUGS ...
12:57:08 <dolio> > replicateM 2 (Just 'h')
12:57:09 <lambdabot>  Just "hh"
12:57:20 <basti_> there ought to be uncountably many :|
12:57:30 <dolio> replicateM 2 [1..3]
12:57:33 <dolio> > replicateM 2 [1..3]
12:57:34 <pianodogg> guess glguy will be here for a while
12:57:34 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
12:57:49 <glguy> replicateM n is just sequence . replicate n
12:58:39 <SamB> glguy: in source or in functionality?
12:58:46 <glguy> both I think
12:58:59 <glguy> GHC had a ticket filed to make replicateM more efficient
12:59:02 <dmhouse> So replicateM 2 ['a'..'z'] is all possible strings of length 2 whose characters fall in the range 'a'..'z'.
12:59:03 <SamB> well clearly the former implies the latter
12:59:04 <glguy> I'm not sure if it was ever closed
12:59:14 <SamB> what is inefficient about it?
12:59:27 <SamB> is sequence not a fold?
12:59:37 <glguy> SamB: I didn't investigate too deeply, I just know that ther ewas a ticket for it
12:59:41 <glguy> in the list of things to do
12:59:48 <glguy> someone submitted a patch
12:59:53 <glguy> I don't know if it was accepted
12:59:54 <Syzygy-> Btw, new installement up in my sequence of HOpenGL tutorial blog posts.
13:00:03 <basti_> sequence is a fold, technically
13:00:06 <dmhouse> > sequence [Just 4, Just 5, Just 10]
13:00:07 <lambdabot>  Just [4,5,10]
13:00:11 <ventonegro> Syzygy-, where?
13:00:11 <Syzygy-> @type replicate
13:00:12 <lambdabot> forall a. Int -> a -> [a]
13:00:13 <dmhouse> > sequence [Just 4, Just 5, Nothing, Just 10]
13:00:14 <lambdabot>  Nothing
13:00:15 <basti_> foldr1 (>>=) or something
13:00:20 <Syzygy-> ventonegro: blog.mikael.johanssons.org or planet.haskell.org
13:00:30 <Syzygy-> Prettier formatting at blog.mikael.johanssons.org :)
13:00:33 <dmhouse> I think sequence is a fold, but often not defined as such.
13:00:40 <ventonegro> Syzygy-, thanks
13:00:51 <Syzygy-> > replicate 2 3
13:00:52 <lambdabot>  [3,3]
13:00:59 <Syzygy-> > replicate 2 [1..3]
13:01:00 <lambdabot>  [[1,2,3],[1,2,3]]
13:01:06 <basti_> i don't think it's defined using "fold", either
13:01:14 <xerox> > ?index sequence
13:01:14 <lambdabot>  Parse error
13:01:18 <Syzygy-> @type sequence
13:01:20 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:01:20 <xerox> ?index sequence
13:01:21 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:01:24 <xerox> ?fptools Control.Monad
13:01:25 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
13:01:29 <glguy> sequence [] = return []
13:01:35 <basti_> probably it's something like sequenc = {-internalperversion-}
13:01:43 <Syzygy-> > sequence $ replicate 2 [1..3]
13:01:44 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
13:01:45 <xerox> sequence       :: Monad m => [m a] -> m [a]
13:01:45 <xerox> {-# INLINE sequence #-}
13:01:45 <xerox> sequence ms = foldr k (return []) ms
13:01:45 <xerox> 	    where
13:01:49 <xerox> 	      k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:01:50 <glguy> sequence (c:cs) = do x <- c; xs <- sequence cs; return (x:xs)
13:01:52 <SamB> WTH is s-x?
13:01:54 <basti_> oh
13:01:57 <Syzygy-> > sequence [1,2] [4,5,6]
13:01:57 <lambdabot>  add an instance declaration for (Num ([a1] -> a))
13:01:57 <lambdabot>   In the list element: 2
13:01:59 <SamB> emacs thinks I just typed it
13:02:02 <Syzygy-> > sequence [1,2] [4,5]
13:02:02 <xerox> sequence_ ms     =  foldr (>>) (return ()) ms
13:02:03 <lambdabot>  add an instance declaration for (Num ([a1] -> a))
13:02:06 <lambdabot>   In the list element: 2
13:02:11 <basti_> SamB: s-x?
13:02:16 <dmhouse> > let seq' [] = []; seq' xs = foldl1 (liftM2 (:)) xs in seq' [Just 5, Just 6]
13:02:16 <lambdabot>    Occurs check: cannot construct the infinite type: r = [r]
13:02:17 <lambdabot>    Expected...
13:02:23 <Syzygy-> > sequence [[1,2],[4,5]]
13:02:23 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
13:02:28 <Syzygy-> Ah!
13:02:53 <pianodogg> there you go; list monad
13:02:55 <dmhouse> > let seq' [] = []; seq' xs = foldl1 (\x y -> do x' <- x; y' <- y; return (x++[y])) xs in seq' [Just 5, Just 6]
13:02:56 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
13:02:56 <lambdabot>    Expected...
13:03:07 <dmhouse> Hrm, I thought that was it.
13:03:12 <glguy> and look what I've got started (c:
13:04:17 <dmhouse> ?fptools Control.Monad
13:04:18 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
13:04:34 <glguy> on WinHugs, you can type :f sequence
13:04:43 <dmhouse> sequence ms = foldr k (return []) ms
13:04:43 <dmhouse> 	    where
13:04:43 <dmhouse> 	      k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:04:47 <dmhouse> From that page.
13:05:04 <dolio> :) xerox beat you by 3 minutes.
13:05:15 <dmhouse> Pah. :)
13:05:46 <glguy> yeah... we've all already moved on to a new topic
13:06:09 <glguy> when are the ICFP winners announced?
13:06:19 <dmhouse> At ICFP.
13:06:25 <glguy> isn't that going on right now?
13:06:42 <kowey> will be announced in a few hours
13:06:50 <dmhouse> Awesome.
13:07:07 <kowey> hmm... i wonder if there are any wikibook people at ICFP
13:07:18 <dmhouse> kowey: seen my callCC stuff, by the way?
13:07:32 <kowey> was looking at it just now
13:07:52 <kowey> i don't completely get cps, by the way (so i guess i could be a good guinea pig)
13:08:04 <dmhouse> Good stuff.
13:08:25 <glguy> does ghc optimize away the fact that you never actually complete a function call?
13:08:56 <dmhouse> glguy: such as?
13:08:57 <Igloo> It doesn't use the C stack
13:09:42 <glguy> dmhouse: CPS functions don't return a value, they call another function, right?
13:10:10 <dmhouse> glguy: Oh, in the context of CPS.
13:10:29 <kowey> glguy: please help test the wikibook chapter! :-)
13:10:31 <norpan> glguy: well, they call another function and return it's value
13:10:38 <dolio> Well, they're all tail calls. GHC optimizes tail calls, no?
13:10:39 <norpan> but in essence, yes
13:11:15 <glguy> I've never actually used CPS, that's just how I understood it to work
13:12:44 <glguy> so CPS functions eventually call a continuation that just returns a value?
13:12:51 <Cale> glguy: yeah
13:13:07 <glguy> I wasn't sure if you just gave a callback
13:13:37 <glguy> or if a value was returned, so that makes more sense now
13:13:51 <Cale> Well, in certain contexts (not in Haskell), you think of them as "never returning"
13:14:34 <xerox> edwinb: you might find this one interesting <http://www.labri.fr/perso/casteran/CoqArt/>, there's even a link to the pages about [co-]inductive types! Yarr!
13:14:39 <Cale> So the CPS-ified function calls the future with its computed result, but that future doesn't return.
13:14:59 <Cale> This obviously is only meaningful when side-effects of evaluation are present
13:15:14 <glguy> and they aren't in Haskell, so it's not?
13:15:17 <Cale> right
13:15:34 <Cale> The only useful way to use CPS in Haskell is to actually return a value at some point.
13:15:57 <glguy> unless the program finishes its life inside of one?
13:15:58 <Cale> You can CPSify the IO monad though.
13:16:11 <glguy> ContT and IO?
13:16:14 <Cale> yeah
13:16:22 <Philippa> I dunno, I think you can usefully use it in the outer loop of a non-terminating server too?
13:16:27 <Cale> and that gives all the same sort of tricks that you get with call/cc in other languages.
13:16:45 <SamB> Philippa: I kinda thought forever was the thing that you used for that...
13:17:53 <Cale> Philippa: I'm just saying that a -> Void is a useless type when the (->) doesn't allow for side effects.
13:18:10 <Philippa> ah. Damn the overloading of "return" :-)
13:18:14 <glguy> Cale: you can only have forever if you consider time
13:18:17 <glguy> ;)
13:18:23 <Cale> yes :)
13:18:25 <Cale> hehe
13:18:47 <glguy> I won't tell if you don't (c:
13:19:00 <pianodogg> dmhouse: i find the cps examples in the little schemer to be good too
13:19:06 * glguy looks around suspiciously
13:19:43 <glguy> I need to pick up a copy of the seasoned schemer to complete my set
13:19:55 <Cale> Unrestricted continuations with side effects are at least as bad as GOTO
13:20:33 <xerox> Just more cryptic.
13:21:00 <dolio> The former can be harder to think about.
13:21:10 <dolio> goto can't reset variables to different states.
13:21:17 <glguy> if you name your functions f1, f2, f3 f4...
13:21:23 <Cale> yeah, they manage to actually further harm readability of code, while allowing for even more craziness, like GOTO-with-value
13:21:25 <Cale> and so on
13:22:22 <SamB> GOTO-with-value-and-stack
13:22:35 <SamB> you can't do that in BASIC!
13:22:49 <dolio> Heh.
13:22:50 <monochrom> Heh
13:22:58 <Cale> I'd like to see some interesting restrictions of ContT.
13:24:31 <Philippa> delimited continuations don't strike you as an interesting restriction?
13:24:39 <Philippa> or just not as a restriction of ContT?
13:25:26 <Cale> I suppose that's something.
13:25:50 <russo> Hey guys i'm trying to make a certain constructor output a given character
13:25:50 <Philippa> I suspect most of the interesting restrictions'd need delimited continuations to express anyway
13:25:54 <russo> what do i have to write
13:26:01 <Philippa> russo: that question doesn't make sense
13:26:04 <russo> it gives me an error saying show isn't defined
13:26:10 <Philippa> constructors don't do anything but build values
13:26:16 <russo> i'm really tired i hope you can answer it quick :D
13:26:27 <Cale> russo: you mean that you'd like to define Show on your own type?
13:26:35 <Cale> russo: and not just the derived one?
13:26:37 <russo> yes
13:26:39 <Philippa> Cale: I think most of the interesting restrictions will need delimited continuations
13:26:43 <russo> its a datatype i've define
13:26:50 <russo> d
13:27:05 <Cale> russo: You can add 'deriving Show' to the end of the data declaration to get a basic instance of show
13:27:15 <Cale> If you want more, you write:
13:27:24 <Cale> instance Show MyType where
13:27:34 <Cale>     show x = ...
13:27:52 <russo> perfect mate ;) thats exactly what i wanted to know thanks :)
13:27:57 <Cale> and if your type is parametric, you might want something like:
13:28:04 <dmhouse> (If you use the latter, don't use 'deriving'.)
13:28:08 <Cale> instance (Show a) => Show (MyType a) where
13:28:10 <Cale>  ...
13:28:25 <russo> yeah i just didnt know the syntax
13:28:38 <roconnor> @yarr!
13:28:39 <lambdabot> Swab the deck!
13:28:54 <russo> lambdabot :D i like this channel :D
13:29:20 <roconnor> ?vixen we all like this channel
13:29:21 <lambdabot> tell me a joke.. I like men that makes me laugh
13:29:34 * SamB wonders why apt-get is stupid enough to want to uninstall his kernel?
13:29:52 <russo> :O
13:29:55 <roconnor> SamB: Are you running ubuntu?
13:29:56 * russo is running osx
13:30:02 <SamB> roconnor: no!
13:30:03 * russo got a macbook this week :D
13:30:08 <glguy> os x ftw
13:30:12 <roconnor> SamB: Ah, found the problem.
13:30:12 <russo> macbook pro rather
13:30:19 <russo> mbp is ftw too :D
13:30:21 <roconnor> ;)
13:30:34 <SamB> the problem is that apt-get doesn't know that kernel packages are important
13:30:41 <SamB> I suppose
13:30:41 <glguy> SamB: I recommend that you not reboot whilst your kernel is missing
13:30:44 <russo> ok y'all take it easy i need to go walk my dog and then basically pass out in my bed :D
13:31:22 <glguy> ?. elite yarr
13:31:23 <russo> btw is there a good website with refrences to stuff like show
13:31:23 <lambdabot> sWAB +he de(k!
13:31:38 <roconnor> Debian always screws up my packages eventually.  I've never really understood why.
13:31:52 * russo uses slackware on all comps but his macbook
13:31:58 <roconnor> still, it's better than a kick in the head
13:32:05 <russo> slackware has no such problems
13:32:10 * glguy looks down his nose at the linux users
13:32:17 <russo> well cuz you compile everything  :D
13:32:32 * russo waves to glguy from his osx pedistal
13:32:35 <russo> pedestal*
13:32:48 <glguy> russo: I'm one a couple pedestals, but not an OS x one
13:32:48 <russo> i logged into my server today\
13:32:55 <russo> and did uptime
13:33:10 <russo> it said 17:30:45 and 78 days
13:33:11 <russo> :D
13:33:28 <russo> i decided it was time for a restart for the hell of it :D
13:33:37 <russo> considering i'm not where my server is :D
13:33:40 <roconnor> I got a kernel security patch today.
13:33:44 <glguy> russo: my windows workstation at work regualrly has that much *idle* time ;)
13:33:54 <glguy> (because i'm always talking in irc?)
13:34:01 <russo> :D
13:34:49 <glguy> russo: I'm much more likely to preach OpenBSD than OS X tho
13:35:06 <glguy> but I'm not really in the mood to today ;)
13:35:33 <russo> i'm much more happy that this looks 70 times better than kde or gnome or kde and gnome compined times xfce :D
13:35:45 <edwinb> xerox: it's a really nice book that one
13:35:51 <roconnor> glguy: Doesn't OpenBSD have some threading issues?
13:36:05 <russo> bsd doesnt have issues
13:36:08 <russo> its bsd...
13:36:19 <glguy> roconnor: if it does, not enough to bother me with it
13:36:23 <russo> they don't release if it has issues
13:36:28 <russo> issues is linux :D
13:37:13 <glguy> I wouldn't say that, but I would say that openbsd is more willing to just exclude a feature than incorporate it if it isn't "done right"
13:37:19 <russo> i just love how it syncs with my phone via bluetooth and it looks nice and the apps look nice and its runing bsd in the background etc
13:37:23 <glguy> that's not necessarily better
13:37:27 <Adamant> heh
13:37:29 <russo> yes true
13:37:37 <glguy> since a lot of people like ot play with the bleeding edge development
13:37:39 <russo> i meant osx btw in my rambling ;)
13:38:01 <russo> no thats just the bsd philosophy
13:38:07 <russo> vs. linux
13:38:50 <roconnor> ah, it was that gethostbyname_r isn't thread safe, or something like that
13:38:55 <roconnor> on OpenBSD
13:39:00 <roconnor> so I did't bother installing it
13:39:48 <glguy> I don't see gethostbyname_r in the man pages
13:39:53 <russo> i dunno i installed netbsd once
13:39:59 <russo> i use linux like i said
13:40:09 <russo> anyway ok i'm really leaving now good night all
13:40:20 <glguy> cya
13:41:42 <roconnor> @google gethostbyname_r
13:41:44 <lambdabot> http://www.die.net/doc/linux/man/man3/gethostbyname_r.3.html
13:41:44 <lambdabot> Title: gethostbyname_r(3): network host entry - Linux man page
13:42:42 <pianodogg> why the anti linux sentiment?
13:44:19 <glguy> who?
13:44:42 <glguy> I didn't notice anyone speaking against linux
13:44:48 <pianodogg> russo "issues is linux :D"
13:44:58 <glguy> oh, him, I figured he was joking
13:45:05 <Cale> roconnor: hmm... I ran debian unstable for 5 years without any serious issues
13:45:30 <pianodogg> i track gentoo unstable and it's fine
13:45:36 <Cale> roconnor: occasionally packages wouldn't be installable, but those sorts of things would tend to go away after a few days
13:45:46 <pianodogg> but i'm also not afraid to hack stuff if it's broken... not a big deal
13:45:55 <Cale> (I mean with packages getting messed up)
13:46:22 <pianodogg> makes my 233mhz thinkpad really sing :)
13:46:28 <SimonRC> Cale: if a package has self-contradictory requirements, there should be an older version hanging around
13:46:31 <Cale> I'm now running Ubuntu since I figured it was about time I freshly installed my machine (/usr/local was full of crap)
13:47:32 <Cale> and I was impressed with Ubuntu's ease of installation and how nice the default configuration was.
13:47:34 <roconnor> Cale: ah, apparently my problem is that I was running testing.
13:47:54 <roconnor> fortunately I'm running Kubuntu now, and have no major troubles.
13:47:58 <Cale> :)
13:49:24 <roconnor> why do I even bother trying to ask questions on #debian?
13:50:15 <glguy> roconnor: apparently OpenBSD doesn't have a gethostbyname_r and that was the issue
13:50:15 <Cale> hm?
13:50:30 <Cale> You should possibly be trying on #ubuntu?
13:50:51 <cygnus> roconnor: #debian is just like #php and #python, it's not worth it
13:51:38 <roconnor> Cale: you are probably right... But I was trying to install debian stable on my other laptop.  Clearly I should be running ubuntu.
13:52:09 <Cale> ah, debian stable is far too stable for me
13:52:14 <roconnor> glguy: oh.  Is gethostbyname not threadsafe?
13:52:33 <roconnor> Cale: My old laptop is very old.  It probably could use some stability.
13:52:50 <Cale> I might consider it for a server which was to sit there and serve up something without getting too much human interaction.
13:53:30 <glguy> roconnor: right, gethostbyname is never threadsafe
13:53:44 <roconnor> glguy: thanks.
13:54:22 <glguy> roconnor: but since it's really cheap to fork on most POSIX systems.. that's usually not an issue
13:54:24 * roconnor doesn't use C very much, so he doesn't know these things.
13:54:27 <pianodogg> what? strtok isn't threadsafe?  arghhhhhhhhh!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  :)
13:54:37 <glguy> heh
13:54:40 <roconnor> heh
13:54:51 <pianodogg> @arr
13:54:51 <lambdabot> I'll keel haul ya fer that!
13:55:01 <pianodogg> thanks, lambdabot
13:55:07 <xerox> pianodogg: I've fixed a unix utility *years* ago that suffered from using that function hehe
13:55:09 <glguy> we're kind of sad... always having lambdabot talk like a pirate for us
13:55:30 <pianodogg> xerox: gcc?  X?  i'm sure they've been guilty
13:55:41 <xerox> No something simpler hehe
13:55:51 <glguy> host?
13:55:53 <glguy> ;)
13:56:07 <xerox> Something to count ips of netmasks or something, I believe.
13:56:21 <roconnor> http://wiki.noreply.org/noreply/TheOnionRouter/TorFAQ#ServerOS
13:56:25 <lambdabot> Title: TheOnionRouter/TorFAQ - Noreply Wiki, http://tinyurl.com/qh5ta
13:56:37 <roconnor> So rather than threading on these platforms, we made Tor fork new processes. This means you need way more memory to run a Tor server, especially an exit server. If you want to run a Tor server, we recommend you upgrade to a better OS.
13:57:09 <glguy> roconnor: I read that same thing, but since I don't use Tor, I don't have to worry about it's deficiencies
13:57:15 <glguy> everything else works like the charm
13:57:28 <roconnor> what's the point in running OpenBSD if you aren't running Tor ;)
13:58:08 <roconnor> @arr
13:58:09 <lambdabot> Aye Aye Cap'n
13:58:42 <glguy> roconnor: and since gethostbyname_r is not part of any standard... you can't really fault OpenbSD for not having it
13:59:14 <roconnor> that's fair
13:59:19 <glauber_sp> hi guys. I need to write an article about parallelism and I decided to write something about haskell and parallelism. I saw there's 2 implementations: ph(MIT) and GUM. Can anyone suggest me a topic to write about? THe paper must have from 4 to 7 pages. I'm still  learning parallelism.
14:00:29 <roconnor> @what GUM
14:00:30 <lambdabot> I know nothing about gum.
14:01:37 <glauber_sp> roconnor, I searched and found 3 links with lots of papers, but I don't know which one to read.
14:02:17 <roconnor> glauber_sp: I fear I know nothing about parallism and haskell. Good luck to you.
14:02:55 <monochrom> You can demonstrate parallel programming in GUM, i.e., show examples of what such programs look like.  Or in ph.  You will find that they look nice.  Along that line, research papers have been written explaining GUM and ph, and part of them explains why it is possible to do parallel programming nicely in GUM and ph, and you can borrow that material.
14:03:33 <glauber_sp> roconnor, thanks =) eheh I'll try to discover something about this =)
14:04:23 <monochrom> (For example, one point they emphasize is that under the lack of mutable variables, there are way fewer things to worry about when you split a task over several computers.)
14:05:18 <glauber_sp> monochrom, to demonstrate, I need to define which kind of parallelism they implement first, right?
14:05:40 <dolio> Has GUM been absorbed into GHC?
14:05:44 <monochrom> Yeah, but it's trivial and you can find and copy from the papers.
14:06:00 <monochrom> No, dolio.
14:06:16 <dolio> The GPH/GUM website (if this is the correct one) talks about Haskell 1.4.
14:07:09 <glauber_sp> monochrom, do ph and gum implement the same kind of parallelism? spmd? DSM?
14:10:02 <monochrom> Here is another point.  In GUM for example, you (as a programmer) do not say "evaluate this expression on computer #4".  However, you say, using the "par" combinator, "find a computer to evaluate this expression".  Thus you enumerate the tasks and assume you have a processor farm; GUM will assign tasks to processors for you.  This is the lowest level you can get in GUM; there are higher levels using "strategies", in which you
14:10:02 <monochrom>  don't even have to manually enumerate your tasks.  These are all fleshed out in the papers.
14:10:50 <xerox> monochrom: wow, that sounds fun!
14:11:54 <dolio> Was the parallel haskell/evaluation strategies stuff in ghc developed independently of GUM, then?
14:12:18 <monochrom> I cannot exactly define what kind of parallelism it is.  But I can say GUM is implemented on top of PVM.  That should give you a pretty good idea what it's like in a nutshell.
14:12:20 <dolio> Or am I confusing different parts of the system?
14:13:32 <glauber_sp> monochrom, I'll read the papers, so =) I've reached the page for paper about gph/gum, simon p. jones papers and the PH site.
14:14:26 <monochrom> In principle GHC should include GUM.  This explains what the GHC docs are talking about wherever it says parallelism, i.e., yes, that's GUM stuff.  In practice no one volunteers to do the actual integration of GUM stuff into GHC.  This explains why the GHC parallelism part is vapourware.
14:15:37 <glguy> "In place of infinity we usually put some really big number, like 15."
14:16:12 <mwc> GUM?
14:16:53 <dolio> Ah. So, I could compile a program with the GPH stuff using GHC, but it wouldn't actually parallelize itself?
14:17:44 <dolio> Or something like that.
14:18:07 <monochrom> Something won't run.  I haven't tried.  Actually I have tried but forgotten the result.  Something won't even compile, maybe.
14:18:20 <dolio> Ah, heh.
14:23:57 <glauber_sp> monochrom, thanks for the speech. I'll read some papers now =D see ya
15:40:42 <dibblego> what is typically done with a .lhs file written using latex style?
15:42:01 <Cale> dibblego: Uh, it's compiled?
15:42:15 <dibblego> yeah but to produce documentation of some sort?
15:42:15 <Cale> Either with latex or ghc :)
15:42:40 <Cale> try  pdflatex file.lhs
15:42:50 <dibblego> I've used docbook all my writing life, not latext
15:43:05 <dibblego> ok ta
15:43:13 <dibblego> *latex
15:45:13 <glguy> docbook and latex solve pretty different problems... don't they?
15:46:29 * glguy &
15:46:40 <dibblego> sometimes
15:47:52 <dibblego> interesting article: http://web.mac.com/ben_moseley/frp/paper-v1_01.pdf
15:47:54 <lambdabot> http://tinyurl.com/esxmn
15:50:26 <Cale> For any n >= 1, the sentence (buffalo)^n is grammatical.
15:50:46 <Cale> http://en.wikipedia.org/wiki/Buffalo_buffalo_buffalo_buffalo_buffalo_buffalo_buffalo_buffalo
15:50:49 <lambdabot> http://tinyurl.com/rk25h
15:51:42 <dibblego> wtf?
15:53:41 <dibblego> oh that's interesting
15:59:07 <nich> hello!
15:59:58 <nich> just curious if there are any gentoo ghc users having that package upgraded/downgraded frequently
16:02:28 <Patterner> what package?
16:02:42 <nich> ghc-bin
16:03:10 <GomoX> how do i get the nth element from a list?
16:03:16 <nich> usually from some 4.4.2 to 4.2.1-r1 or something
16:03:17 <Patterner> nope
16:03:23 <Patterner> i use 6.x
16:03:28 <nich> there's 6?
16:03:29 <nich> >_>
16:03:32 * nich stabs self
16:03:39 <nich> oh
16:03:39 <malcolm> > [1..5] !! 3
16:03:41 <lambdabot>  4
16:03:47 <Patterner> ghc-6.4.2.ebuild :)
16:03:50 <nich> ya
16:03:53 <nich> my mistake
16:03:58 <GomoX> malcolm: well that's ugly
16:04:00 <GomoX> heh
16:04:00 <GomoX> :D
16:04:02 <nich> 6.4.2 and 6.4.1 ^^;
16:04:24 <Patterner> or 6.5.presomething.
16:04:39 <nich> :/
16:04:51 <nich> what profile?
16:04:57 <nich> can't find those here >_>
16:05:24 <Patterner> 2006.1 ~amd64
16:05:29 <nich> oh
16:05:33 <nich> <-- ~x86
16:05:34 <nich> :/
16:06:06 <Patterner> ghc-6.5_pre20060917 is from the haskell overlay
16:06:09 <dcoutts__> nich: what's the issue exactly?
16:06:28 <GomoX> (thanks btw)
16:06:29 <Patterner> 6.4.2 has KEYWORDS="~alpha amd64 hppa ~ia64 ppc ppc64 sparc x86 ~x86-fbsd"
16:06:30 <nich> it updates/downgrades once every week/15 days or so
16:06:44 <dcoutts__> nich: ghc does?
16:06:58 <dcoutts__> nich: are you using the haskell overlay or just normal portage?
16:07:01 <Patterner> emerge ghc-bin. emerge ghc. un-emerge ghc-bin. :)
16:07:07 <jgrimes> what work has been done in artificial intelligence using haskell?
16:07:12 <nich> dcoutts__: just normal portage
16:07:24 <nich> didn't know there was a haskell overlay
16:07:59 <dcoutts__> nich: ok, you're probably safer that way ;-)
16:08:15 <Patterner> bleeding edge, baby :)
16:08:20 <nich> :P
16:08:28 <dcoutts__> nich: hmm, well we've certainly not been changing ghc in portage much recently
16:08:36 <dcoutts__> we stabalised 6.4.2 recently, that's about it
16:08:51 <nich> hum
16:08:52 <nich> funny
16:08:55 <nich> just a sec
16:09:02 <nich> pastebin refuses to hurry :P
16:10:43 <cygnus> pastebin has been broken for me for weeks
16:10:48 * cygnus uses rafb.net/paste now
16:10:50 <dcoutts__> @paste
16:10:51 <lambdabot> http://paste.lisp.org/new/haskell
16:10:52 <nich> dcoutts__: http://pastebin.com/790289
16:10:55 <dcoutts__> use that ^^
16:10:56 <nich> oh
16:10:58 <nich> >_>
16:11:08 <dcoutts__> np
16:11:10 <dcoutts__> :-)
16:11:22 <dcoutts__> nich: btw there is a #gentoo-haskell channel for these issues too
16:11:24 <nich> dcoutts__: see what I meant? ^^;
16:11:27 <nich> wha?
16:11:37 <dcoutts__> it's taking it's time to load...
16:11:57 <nich> ya
16:11:59 <nich> lemme repaste
16:12:25 <lisppaste2> nich pasted "ghc in gentoo?" at http://paste.lisp.org/display/26325
16:12:33 <dibblego> "The assignment statement is the von Neumann bottle-neck of programming languages and keeps us thinking in word-at-a-time terms in much the same way thecomputer's bottleneck does." http://www.stanford.edu/class/cs242/readings/backus.pdf -- I like that bit :)
16:12:41 <lambdabot> http://tinyurl.com/easkf
16:12:55 <lisppaste2> malcolm pasted "test" at http://paste.lisp.org/display/26326
16:13:56 <malcolm> anyone know if that pastebin uses hscolour?
16:18:55 <jgrimes> malcolm, I don't think so.
16:19:32 <jgrimes> malcolm, the output html isn't very similar
16:21:17 <malcolm> jgrimes: good idea - if in doubt, look at the source
16:22:22 <malcolm> jgrimes: it could be a hacked version of hscolour in css mode.  but maybe that is just the only sensible way of doing it, even in an independent implementation
16:24:27 <Cale> http://www.cs.utexas.edu/users/arvindn/misc/knuth_song_complexity.pdf -- ahaha
16:24:29 <jgrimes> malcolm, yeah, it is coloring things similarly (different colors... but that doesn't really mean much) but the style selectors are named differently
16:24:30 <lambdabot> http://tinyurl.com/hjmp4
16:25:03 <lispy> anyone else hanging out at ICFP?
16:25:39 <malcolm> I'm listening to a talk about biXid
16:25:44 <dibblego> you mean physically or online?
16:26:35 <dibblego> malcolm, where are the talks available from?
16:26:56 <dcoutts__> from the conference hall presumably :-)
16:26:59 <malcolm> in the paper proceedings...?
16:27:03 <dibblego> http://icfp06.cs.uchicago.edu/ ?
16:27:05 <lambdabot> Title: 11th ACM SIGPLAN International Conference on Functional Programming (ICFP 2006)
16:27:31 <dcoutts__> dibblego: no streaming video this year ;-)
16:27:38 <xerox> Cale: hahaha `It is possible to generalize this lemma to the case of verses of differing lengths V_1, V_2, ..., V_m, provided that the sequence <V_k> satisfies certain smoothness condition. Details will appear in a future paper.''
16:27:47 <dibblego> dcoutts, streaming voice at least?
16:27:55 <dcoutts__> nope
16:27:59 <Cale> xerox: hehe
16:28:01 <malcolm> dcoutts__: was there ever streaming anything?
16:28:07 <dcoutts__> malcolm: no :-)
16:28:11 <lispy> i'm in the lobby right now
16:28:20 <malcolm> I have my camera here - recorded the hackathon presentations
16:28:24 <lispy> wireless is a bit flaky...
16:28:25 <dibblego> lispy, stream us some video :)
16:28:34 <dcoutts__> malcolm: cool
16:28:36 <malcolm> but there is no server I could bounce the video stream off live
16:28:53 <lispy> dibblego: heh
16:29:10 <dcoutts__> malcolm: it'd be useful non-live too
16:29:28 <bringert> hi lispy
16:29:32 <lispy> malcolm: actually, i have a server in a datacenter...that we could bounce off of if i knew how to set it up :)
16:29:35 <lispy> bringert: hi
16:29:39 <malcolm> the hackathon vids will appear on the ghc commentary wiki sometime soon
16:29:44 <lispy> bringert: will you be at the darcs thingy?
16:30:12 <bringert> lispy: not sure, I might want to prepare my talk a bit
16:30:27 <lispy> ah
16:30:33 <lispy> bringert: what are you giving a talk about?
16:30:36 <malcolm> lispy: is your server on MacOS? if so, then QuickTime Streaming Server is all that is needed (plus lots of bandwidth of course)
16:30:39 <xerox> Cale, that's too funny.  I mean, ``Given positive integers alpha and lambda, there exist a song ...''
16:30:40 <lispy> you can just practice here :)
16:30:44 <bringert> almost compositional operations
16:30:53 <lispy> malcolm: debian amd64 :)
16:31:01 <dcoutts__> malcolm: fantastic
16:31:16 <malcolm> lispy: OK, i think QSS runs on that too
16:31:23 <ihope_> > let x = if x then False else True
16:31:23 <lambdabot>  Parse error
16:31:24 <bringert> lispy: http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf
16:31:26 * lispy goes to look it up
16:31:27 <lambdabot> http://tinyurl.com/poma6
16:31:29 <ihope_> > let x = if x then False else True in x
16:31:30 <lambdabot>  Exception: <<loop>>
16:31:38 <ihope_> Really, there's not much else it could be.
16:31:42 * bringert restarts
16:32:25 <Cale> xerox: "However, the advent of modern drugs has led to demands for still less memory, and the ultimate improvement of Theorem 1 has consequently just been announced
16:32:35 <malcolm> I think I'm going to record the ICFP programming contest results on video
16:32:42 <malcolm> It starts in 15 minutes
16:32:49 <SamB> cool
16:32:50 <Cale> "Theorem 2. There exist arbitrarily long songs of complexity O(1).
16:32:51 <dcoutts__> :-)
16:32:59 <xerox> hahahahaha
16:33:06 <Cale> "Proof (due to Casey and the Sunshine Band)
16:33:08 <xerox> I'm spreading it... back to reading.
16:33:14 <malcolm> anyone interested in seeing that?
16:33:19 <lispy> malcolm: http://viz.aset.psu.edu/ga5in/StreamingMedia.html
16:33:22 <xerox> malcolm: yes yes yes yes!
16:33:23 <lambdabot> Title: ga5in - Streaming Media with Linux, http://tinyurl.com/kwrrd
16:33:40 <MarcWeber> Can you have a look at this error message? attach is defined at line 32. It should add some controls representing ge so that it can be edited by the user.. But I can't see why ghc throws this error message at me.
16:33:44 <lispy> grrr...
16:33:46 <dcoutts__> malcolm: yes, just to see how far down the board my team dropped :-)
16:33:53 <lispy> vlc doesn't want to install
16:33:58 <xerox> dcoutts__: you'll make the top ten! :D
16:34:01 <xerox> @yarr
16:34:01 <lambdabot> Swab the deck!
16:34:03 <dcoutts__> @arr
16:34:04 <lambdabot> Shiver me timbers!
16:34:13 <Cale> MarcWeber: which error message?
16:34:25 <lispy> okay, this requires a lot of package shuffling :(
16:34:36 <malcolm> OK, if it is short I'll try to upload the ICFP contest vid later today
16:34:57 <MarcWeber> Oh Have a look here, Cale http://rafb.net/paste/results/VfsiL665.html
16:35:00 <malcolm> might be up to about 150Mb
16:35:17 <xerox> malcolm: alright, thank you!
16:35:26 <MarcWeber> A was reading malcolm' message ;)
16:35:43 <MarcWeber> malcolm: I'm interested, too
16:36:38 <kpreid> jgrimes, malcolm: http://common-lisp.net/pipermail/lisppaste-requests/2006-August/000065.html , http://common-lisp.net/pipermail/lisppaste-requests/2006-September/000070.html
16:37:08 <jgrimes> kpreid, good to know, thanks :)
16:37:45 <Cale> MarcWeber: the way it's defined, attach must be polymorphic over the container type
16:38:01 <Cale> MarcWeber: So in particular, you can't pattern match.
16:38:11 <Cale> attach :: ContainerClass c => c -> ge -> IO (AttachedInfo ge)
16:38:39 <Cale> Perhaps you want to make the class:
16:38:51 <Cale> class GtkEditable ge c | ge -> c where
16:39:02 <Cale> er
16:39:10 <Cale> class (ContainerClass c) => GtkEditable ge c | ge -> c where
16:39:22 <MarcWeber> Cale: Can you give me the line number weher pattern matching makes trouble?
16:39:33 <Cale>     attach :: c -> ge -> IO (AttachedInfo ge)
16:39:47 <Cale> MarcWeber: exactly the one which the error mentions
16:39:55 <Cale> line 89
16:39:56 <malcolm> lispy: all I need to broadcast live is an IP address and port number to send the stream to.
16:39:59 <Cale>   attach (Auszubildender n v a g k)  = attachImpl5 n v a g k Auszubildender
16:40:09 <dcoutts__> hacking on a gtk-based thingie ?
16:40:15 * dcoutts__ is interested
16:40:27 <MarcWeber> Thx and I have to think about it..
16:40:52 <xerox> Cale: haha, `m bottles of beer' broken the n^(1/2) complexity barrier!
16:42:16 <MarcWeber> dcoutts__: ;) Yeah. I just tried to write a simple class which allows you to edit different types of data.. but I didn't succed yet.
16:42:59 <dcoutts__> interesting, what's the aim ?
16:46:01 <MarcWeber> dcoutts__: Use  do { v <- vBoxNew; AttachedInfo (modified, getData, detach) <- attach v ("abc",3); onButtonClick ( getData >>= \d -> print $ "you have entered " ++ (show d) ) } or something like this I'll create a working example if you want
16:46:40 * dcoutts__ tries to grok the example
16:47:40 <dcoutts__> MarcWeber: I'm not sure I see what's going on
16:48:17 <dcoutts__> so you attach some data to a widget
16:48:25 <Cale> 2 Again Kennedy ([8], p. 631) claims priority for the English, in this case because of the song "I'11 drink m if you'll drink m + 1." However, the English start at m = 1 and get no higher than m = 9, possibly because they actually drink the beer instead of allowing the bottles to fall.
16:48:37 <Cale> I'll*
16:49:32 <MarcWeber> dcoutts__: No, I wont to attach controls representing the data so that the user can modify it. Wait 2 minutes. I'll have to try Cale's suggestion.
16:49:39 <xerox> Cale: hehe
16:49:46 <xerox> Cale: how did you spot it?
16:49:52 <dcoutts__> MarcWeber: ok
16:50:26 <Cale> xerox: I checked what the superscript 2 referred to.
16:50:55 <xerox> Cale :P  I mean the paper.
16:50:57 <ihope_> Hmm...
16:51:09 <ihope_> Eh.
16:51:13 <Cale> xerox: oh, from wikipedia, a couple of links away from the buffalo thing
16:52:01 <MarcWeber> Cale: if I don't wont to create an instance for each ContainerClass type I need a foralld type?
16:52:26 <dcoutts__> MarcWeber: keep me posted, but I gotta go to bed
16:52:31 <dcoutts__> g'night folks
16:53:08 <Cale> MarcWeber: You need an instance with a type variable, but that will likely require even more extensions. (Undecidable instances, probably)
16:54:33 <lisppaste2> sris pasted "style?" at http://paste.lisp.org/display/26332
16:55:03 <sriiis> in that paste, which one is considered to have "the best style"
16:55:44 <MarcWeber> Cale: never heard about that. But thanks for this key word ;)
16:57:58 <MarcWeber> dcoutts__: g'night. I'll try to remember sending you a working example..
16:58:23 <dons> sriiis: hmm. neither? they're ok, but not ideal. can you post actual functions?
16:58:38 <dibblego> goodness, they are beating up this Irwin thing
16:59:05 <dons> sriiis: maybe it won't type check, but something like:
16:59:06 <dons> splitAt . elemIndices (1 % 2) . head . scanl f 0 $ bs
16:59:07 <dons>     where f x (_,y) = x+y
16:59:37 <dons> dibblego: you mean you're not wearing your khaki shirt today?
17:00:11 <chandler> malcolm: lisppaste's syntax coloring is not based on hscolour.
17:00:19 <dibblego> dons, I live near his zoo/house, the traffic this morning was terrible; I won't be wearing khaki
17:00:28 <dons> heh
17:00:29 <chandler> malcolm: you can see the implementation at http://paste.lisp.org/system-server/show/lisppaste/coloring-types
17:01:20 <sriiis> dons what does $ do?
17:01:28 <dibblego> @type ($)
17:01:29 <lambdabot> forall b a. (a -> b) -> a -> b
17:01:57 <dolio> > negate $ 5
17:01:57 <lambdabot>  -5
17:01:57 <dibblego> sriiis, it's also described quite well in YAHT
17:01:57 <dolio> > negate 5
17:01:57 <lambdabot>  -5
17:02:42 <dons> > map (*2)  filter (<10) $ [1..]
17:02:43 <lambdabot>    The function `map' is applied to three arguments,
17:02:43 <lambdabot>   but its type `(a -...
17:02:50 <dons> > map (*2)  . filter (<10) $ [1..]
17:02:54 <lambdabot> Terminated
17:03:07 <dolio> takeWhile
17:03:19 <dons> should give us some output though
17:03:24 <dons> > filter (<10) $ [1..]
17:03:28 <lambdabot> Terminated
17:04:11 <dolio> Well, doesn't lambdabot try to print out as many as possible up to a given number, though?
17:04:21 <dibblego> is there anything that converts a [(X, Y, Z)] to a ([X], [Y], [Z]) ?
17:04:25 <dons> > [1..]
17:04:27 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:04:38 <dons> > map (*2) [1..]
17:04:40 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
17:04:52 <dolio> It doesn't know if it will ever get to some more values less than 10 down the line.
17:04:58 <dons> > filter (>10) . map (*2) $ [1..]
17:04:59 <lambdabot>  [12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,...
17:05:03 <wkh> > filter (<10) (map (*2) [1..])
17:05:07 <lambdabot> Terminated
17:05:10 <wkh> o_O
17:05:27 <dibblego> ?index [(a, b, c)] -> ([a], [b], [c])
17:05:28 <lambdabot> bzzt
17:05:35 <dons> > filter (<10) [1..1000]
17:05:36 <lambdabot>  [1,2,3,4,5,6,7,8,9]
17:05:42 <mauke> ?hoogle unzip
17:05:43 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
17:05:43 <lambdabot> List.unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
17:05:43 <lambdabot> List.unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
17:05:57 <xerox> dons - I was reading your OpenBSD-related pages, I was also on OpenBSD until my brother killed that machine... sigh :)
17:05:58 <dibblego> ah thanks
17:05:58 <mauke> ?index unzip3
17:05:59 <lambdabot> Data.List, Prelude
17:06:34 <dons> > map (*2) . filter (<10) $ [1..100000]
17:06:34 <lambdabot>  [2,4,6,8,10,12,14,16,18]
17:06:34 <dons> > map (*2) . filter (<10) $ [1..1000000000]
17:06:34 <lambdabot> Terminated
17:06:37 <dons> > map (*2) . filter (<10) $ [1..10000000]
17:06:40 <lambdabot>  [2,4,6,8,10,12,14,16,18]
17:08:32 <dons> xerox: heh. well its a fun system to play with
17:08:36 <xerox> dons: indeed!
17:09:09 <xerox> dons: I liked the fact of having all the sources under /src (or /usr/src?) at the time.
17:09:24 <dons> yep. so 'make' just rebuilds the entire system. its nice like that
17:09:35 <dons> all the userland and kernel nicely coupled.
17:10:39 <xerox> I liked to play around with the kernel and stuff.  Much asm & C.
17:10:49 <sriiis> dons, splitAt . head . elemIndices (1 % 2) . scanl addDur 0 $ boogie
17:10:59 <dons> looks good
17:11:06 <xerox> Wow.
17:11:07 <sriiis> that wont work because splitAt need to now wich list to split too, is there i nice way to do that?
17:11:21 <dons> ?type splitAt
17:11:22 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:11:39 <dons> (flip splitAt bs) . head . elemIndices (1 % 2) . scanl addDur 0 $ boogie -- ?
17:11:44 <sriiis> because everything up to splitAt returns and integer
17:12:04 <sriiis> and it's supposed to split the same list (boogie) "at" that value
17:12:22 <dons> right, so apply splitAt to boogie, and then to the number
17:12:25 <dons> ?type splitAt
17:12:27 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:12:31 <dons> ?type flip splitAt
17:12:33 <lambdabot> forall a. [a] -> Int -> ([a], [a])
17:12:37 <dons> flip it , so it takes the list first
17:12:40 <dons> then apply it to the list
17:12:50 <dons> ? type flip spitAt [1..]
17:12:51 <sriiis> flip splitAt boogie . head . elemIndices (1 % 2) . scanl addDur 0 $ boogie
17:12:52 <sriiis> ?
17:12:54 <xerox> Why are we teacking points-free style now?
17:13:06 <xerox> *teaching
17:13:07 <dons> sriiis: yep
17:13:12 <sriiis> thanks
17:13:26 <dons> xerox: sriiis wanted some style advice. flip isn't so points free though
17:13:38 <dons> sriiis: or: let n = head . elemIndices (1 % 2) . scanl addDur 0 $ boogie in splitAt n boogie
17:13:39 <SamB> xerox: it is nicer than lambdas to glue things together?
17:13:46 <xerox> dons: it indeed is, if you want to avoid lambdas!
17:14:13 <dons> well, it ain't as bad as (.) . (. (.))
17:14:23 <xerox> So let's figure that out...
17:14:35 <sriiis> the $ seems really nice, i get a lot of cut fingernails in my code atm
17:14:43 <dons> heh
17:14:50 <dons> yeah, its to solve the cut fingernails problem
17:17:10 <mauke> ?. djinn type (.) . (. (.))
17:17:12 <lambdabot> f a b c = a (\ d e -> b c (d e))
17:17:43 <dons> easy
17:17:55 <xerox> :(
17:17:58 <dons> djinn++
17:18:16 <xerox> Those yougsters with their djinn tools...
17:18:20 <dons> heh
17:18:25 <MarcWeber> Cale: Do you know a paper introducing undecidable instances? I haven't found anything on the wike which was of much use for me.
17:18:51 <Cale> MarcWeber: tried the GHC documentation?
17:18:55 <sriiis> another style question, nested where clauses, how bad is that?
17:19:13 <Cale> sriiis: depends, it can be quite natural in places
17:19:17 <dons> back in xerox's day, he'd walk barefoot 10 kms to school in the snow to learn about pointfree style. the kids these days are spoilt rotten with their lambda-whatsits and djinn-amyjiggs
17:20:03 <Cale> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/type-extensions.html#undecidable-instances
17:20:06 <MarcWeber> Cale: Not yet
17:20:06 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/men2q
17:20:09 <sriiis> Cale, so im not necessarly "wrong" if i have i.e. three levels of where clauses?
17:20:23 <SamB> dons: have you been listening to ormgas?
17:20:25 <sriiis> s/im/it's
17:20:35 <dons> SamB: hmm? no.
17:20:48 <xerox> dons: manual points-free of expressions and reverse is just too fun.
17:20:49 <Cale> sriiis: not necessarily. You might consider the possibility of lifting some of the functions to the outer level if they could be more generally useful.
17:21:06 <sriiis> Cale, i see, thanks
17:21:14 <dibblego> if I define a function in a where, then load the source file (:load), how can I get the type of that function? since it is not in file scope
17:21:25 <Cale> dibblego: you simply don't
17:21:56 <dibblego> well that sucks
17:22:07 <xerox> Lambda lifting for the masses!
17:22:11 <dons> wow, they put a preview edition of the debian weekly news out to an "inner circle"
17:22:12 <Cale> dibblego: similarly, you can't ask for the type of things bound by a let or other subexpressions of a definition, as the definition may well not even exist anymore
17:22:33 <dons> ah, and they do translations too
17:22:33 <dibblego> can I ask for the type while it does exist?
17:22:52 <Cale> dibblego: you can lift the bindings out a level and then ask for them
17:23:13 <dibblego> Cale, but this particular function uses parts of the outer function
17:23:27 <Cale> dibblego: then it's just impossible
17:23:32 <dibblego> well that sucks
17:23:50 <Cale> dibblego: I've never found it to be a problem.
17:24:09 <Cale> You can always add function parameters in order to lift it though.
17:24:19 <Cale> and then it will be typeable
17:24:29 <dibblego> yes but the type given is not necessarily the right one
17:24:30 <Cale> In fact, its type as it stands isn't even expressible
17:24:54 <dibblego> it is at least a more general type
17:25:16 <Cale> Since there are likely type variables in it which are bound by the surrounding function definition
17:26:46 <Cale> In fact, there are times where you simply can't give a type to a function occurring in a where clause without GHC extensions making that possible.
17:27:06 <Cale> by that, I mean that you can't write a type signature for it
17:27:23 <lisppaste2> dibblego pasted "what is the type of 'rest'?" at http://paste.lisp.org/display/26334
17:27:56 <MarcWeber> Cale: I think thats some homework to do .. ;)
17:28:00 <Cale> dibblego: indeed, you can't write a typesignature in that case
17:28:13 <dibblego> ok
17:28:55 <Cale> unless you stick an explicit "forall a." quantifier at the start of the type signature for tokenise and have GHC extensions on
17:29:12 <dolio> Yeah, it needs lexically bound type variables, no?
17:29:15 <Cale> that will cause 'a' to be lexically scoped
17:29:16 <Cale> yeah
17:29:29 <Cale> then you can just write
17:29:34 <Cale> rest :: [[a]]
17:29:51 <dibblego> GHC extensions meaning -fglasgow-exts?
17:29:55 <Cale> yeah
17:29:58 <dibblego> ok thanks
17:31:13 <ihope> @djinn a -> b -> a -> b
17:31:14 <lambdabot> f _ a _ = a
17:31:22 <ihope> I suppose that's obvious...
17:31:47 <ihope> So can I use apt-get to get the Münster Curry Compiler?
17:32:35 <Cale> ihope: apt-cache search curry
17:32:36 <Cale> and see
17:33:17 <dons> hmm. I really need a Read instance with better error reporting
17:33:25 <dons> musasabi: did you look into that at some point?
17:33:28 <ihope> "zinc-compiler - Compiler of Zinc, a functional logic programming language"
17:33:29 <Cale> it seems that zinc is in dapper universe
17:33:35 <ihope> Any idea what that is?
17:33:44 <Cale> Compiler of Zinc, a functional logic programming language
17:33:44 <Cale> The main purpose of the Zinc Compiler is to develop an experimental
17:33:44 <Cale> Curry  compiler which features some extensions to the language, such
17:33:44 <Cale> as type  classes. Zinc Compiler is written in Haskell.
17:33:44 <Cale> The Zinc Compiler is being developed by Diego Berrueta as a final year
17:33:46 <Cale> project. It is available under the BSD license.
17:35:11 <ihope> Looks like Curry.
17:35:22 <pianodogg> tastes like curry?
17:35:32 <ihope> Smells like Curry, too.
17:35:35 * ihope eats it
17:35:39 <dons> ?remember ndm If you do things like this, randomly changing the semantics of functions, people will come round to your house with burning pitch forks!
17:35:50 <pianodogg> mmmmmmmm, zinc
17:35:53 <pianodogg> good for you
17:36:23 <dolio> Burning pitch forks? Is that like killing two birds with one stone?
17:36:52 <pianodogg> well, like killing one bird, and then immolating it so that there is no evidence
17:37:06 <dons> you take your fork, you set it on fire. (^2) as nasty!
17:37:41 <dolio> Weapons that are on fire are extra dangerous.
17:37:46 <dolio> As seen in The Scorpion King.
17:38:24 <dibblego> @pl f x = f1 $ f2 x
17:38:24 <lambdabot> f = f1 . f2
17:38:31 <pianodogg> is that a rock movie?  do you want to admit seeing that?
17:39:01 <dons> a rock movie?
17:39:08 <pianodogg> dons: as in "the rock"
17:39:14 <dons> ah right
17:39:26 <pianodogg> do you smell what the rock is cooking?  (answer: Curry)
17:39:37 <dons> now you're scaring me
17:40:01 <dolio> Sure, why not. I've seen worse movies than that.
17:41:14 <Bobstopper> rock movies are still better'n peter jackson movies
17:42:31 <dons> i don't know, "Braindead" is pretty funny
17:42:40 <dons> he might have made some other films since then, not sure ..
17:42:59 <gmh33__> @hoogle IO Char -> Char
17:43:01 <lambdabot> No matches, try a more general search
17:43:01 <Bobstopper> Wait, that was Peter Jackson? Crap... I'll have to revise my opinion of him...
17:43:11 <xerox> gmh33__: no function of type IO a -> a is allowed.
17:43:17 <gmh33__> : (
17:43:28 <xerox> gmh33__: modulo cheathing. IO is a one-way monad.
17:43:55 <gmh33__> how do I muck together a string from a serious of getChar calls then ?
17:43:59 <pianodogg> gmh33__: you don't know the constructors of IO types so you can't pattern match them away.  very sneaky
17:44:11 <dons> and "Bad Taste" - another classic
17:44:23 <xerox> gmh33__: since you are using IO actions, order matters.  Hence you need to sequence them.  You've got some options.
17:45:00 <xerox> gmh33__: the most convoluted one is using (>>=) manually. The other one is using the do syntax, which is quite a nice sugar on top of bind (a.k.a. >>=).
17:45:28 <gmh33__> I think I figured out a way.. maybe ?
17:45:37 <gmh33__> AppendMode and just keep writing the chars to it
17:45:43 <gmh33__> since I'm outputting to a file
17:45:56 <xerox> gmh33__: it works like this to get two chars from the user and print them out: do { a <- getChar; b <- getChar; putStr [a,b] }.
17:46:03 <xerox> gmh33__: is it intuitive enough?
17:46:38 <gmh33__> yeah, I was originally hoping to just make a [char] from IO Chars then shoot them into a file
17:46:43 <gmh33__> but if that's not possible, oh well
17:46:56 <gmh33__> have to go eat though now, so I'll be back in a bit to try something different : )
17:46:57 <xerox> Sure it is.
17:47:05 <xerox> ?type writeFile
17:47:07 <lambdabot> FilePath -> String -> IO ()
17:47:19 <pianodogg> ?type repeat
17:47:20 <lambdabot> forall a. a -> [a]
17:47:21 <Cale> gmh33__: note that 'a' and 'b' in xerox' example are Chars
17:47:31 <gmh33__> but getChar returns IO Char
17:47:33 <xerox> do { line <- getLine; writeFile "foo.txt" line }
17:47:37 <pianodogg> sequence (repeat 10 getChar) >>= writeFile "output"
17:47:41 <pianodogg> or something like that
17:47:42 <gmh33__> oh wait
17:47:43 <gmh33__> yeah
17:47:44 <gmh33__> bind
17:47:46 <Cale> gmh33__: so you have to run it in order to get a Char
17:47:46 <gmh33__> oops >_>;
17:47:58 <gmh33__> be back in a bit..
17:48:11 <pianodogg> gmh33__: good luck
17:52:06 <malcolm> OK guys, the ICFP programming contest results presentation was a whole 1hr long
17:52:36 <pianodogg> so who won
17:52:57 <malcolm> it will be a 120Mb download
17:53:03 <malcolm> (on video)
17:53:15 <malcolm> but first I'll need to find somewhere to host it
17:53:23 <xerox> yousendit.com ?
17:53:27 <malcolm> the winner was a language called 2D
17:53:46 <malcolm> and the winning team came from Google
17:53:50 <xerox> (Nah, up to 100Mb.)
17:53:57 <xerox> Oh!
17:54:09 <jgrimes> O_O
17:54:20 <dolio> Wow...
17:54:28 <dolio> http://en.wikipedia.org/wiki/2d_(programming_language)
17:54:31 <lambdabot> http://tinyurl.com/gjusq
17:54:47 <malcolm> second place went to a team from Tokyo University, writing in the language D
17:55:27 <Pseudonym> You know what this means?
17:55:28 <dons> huh
17:55:44 <Pseudonym> We should be developing a programming language that's optimised for ICFP contests NOW.
17:55:47 <Pseudonym> In time for next year.
17:55:50 <dons> yes!
17:55:52 <pianodogg> that's a great idea
17:56:27 <malcolm> next year's contest will be organised by Johan Jeuring and the Universiteit Utrecht
17:56:32 <Pseudonym> Because it seems to me that it's the odd languages that win these days.
17:56:34 <dons> ah nice.
17:58:53 <xerox> malcolm: oh cool!
17:59:18 <xerox> So 2D first, D second, ... what's third?
17:59:24 <xerox> 1/2 D?
17:59:31 <jgrimes> haha...
17:59:32 <dons> heh
18:00:27 <Pseudonym> Or 0
18:00:37 <profmakx> what is the metric for winning in this contest?
18:00:54 <dons> http://icfpcontest.org/
18:00:58 <lambdabot> Title: ICFP Programming Contest, 2006
18:04:10 <dons> @tell roconnor we need to syndcate your blog to planet.haskell.org, http://r6.livejournal.com/95963.html. would you like to ping ibid about it? Just hand him an rss url
18:04:11 <lambdabot> Consider it noted.
18:04:30 <kdinluks> hello guys
18:04:52 <pianodogg> what is this 2D; i've not heard of it (yet)
18:04:57 <wkh|cs> dons: livejournals always have a rss url
18:05:12 <kdinluks> i need some help here
18:05:16 <dons> hmm? they don't do rss??
18:05:37 <wkh|cs> i mean you can automaticaly find a livejournal's user syndication url
18:05:41 <Bobstopper> 2D looks a little like how programming with arrows might look if it was done visually...
18:05:42 <sjanssen> pianodogg: I believe it's a language invented for the ICFP contest itself
18:05:55 <pianodogg> that's nice
18:06:02 <dons> wkh|cs: oh sorry. i need coffee i misread 'always' as 'don't' :}
18:06:02 <pianodogg> indeed arrow programming really is visual programming
18:06:14 <pianodogg> staring at arrow types doesn't really elucidate them at all
18:06:32 <dons> wkh|cs: yep, i know. but ibid likes to check for the author's ok before steal^h^h^h syndicating their work
18:06:37 <Pseudonym> One of the problem with arrow types is the lack of infix type operators.
18:06:43 <wkh> dons: ok
18:06:48 <pianodogg> Pseudonym: yes
18:06:53 <dons> Pseudonym: hmm? we do have infix type operators now..
18:07:02 <Pseudonym> If you could express a b c as b ~> c instead
18:07:03 <dons> or , you mean, arrows don't supply them.
18:07:17 <malcolm> currently uploading the ICFP contest video to Google Video
18:07:21 <Pseudonym> Uhm... yeah.
18:07:27 <dons> malcolm++
18:07:28 <malcolm> should be there in about 10 minutes
18:07:30 <pianodogg> malcolm: oh sure, let the winners host the video
18:07:43 * pianodogg smiles
18:07:48 <xerox> Pseudonym: you can use (~>) !
18:07:50 <malcolm> pianodogg: hadn't though of that!
18:07:54 <malcolm> good point
18:08:01 <Bobstopper> Pseudonym: isn't that more of a simple syntactic sugar rather than a solution to arrows' difficulties?
18:08:03 <dons> yeah, isn't that what ~> is for? or is that something else.
18:08:18 <Pseudonym> No, it's not a solution.
18:08:21 <Pseudonym> But it helps a lot.
18:08:23 <dons>        liftA2 :: Arrow (~>)
18:08:23 <dons>               => (a -> b -> c) -> (e ~> a) -> (e ~> b) -> (e ~> c)
18:08:37 <kdinluks> can anyone explain me why on my function I'm getting this error Instance of Integral Double required ?!
18:08:44 <xerox> ?type (***) :: (Arrow (~>)) => (a ~> c) -> (b ~> d) -> ((a,b) ~> (c,d))
18:08:46 <lambdabot> (Arrow (~>)) => (a ~> c) -> (b ~> d) -> ((a,b) ~> (c,d)) :: forall (~> :: * -> * -> *) a c b d. (Arrow ~>) => ~> a c -> ~> b d -> ~> (a, b) (c, d)
18:08:48 <xerox> :D
18:08:57 <mauke> kdinluks: I'd have to see the code
18:08:59 <Bobstopper> hm. I've never found the a b c bit difficult. I find it more difficult getting all the 'circuits' connecting properly
18:09:54 <pianodogg> still, there's more complexity in those types than arrows really have
18:10:03 <mauke> ?type (^^)
18:10:05 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:10:13 <mauke> kdinluks: see above
18:10:19 <pianodogg> it's frustrating that such fundamental, simple abstractions have such absolutely insane type signatures!
18:10:42 <pianodogg> maybe i just need more time staring at them to exercise my brain's pattern matching skills
18:11:04 <kdinluks> mauke it's because i'm getting error when i try this (-2) ** 3
18:11:19 <mauke> > (-2) ** 3
18:11:20 <lambdabot>  -8.0
18:11:23 <mauke> no error
18:11:27 <kdinluks> and with this (-2) ^^ 3 its work
18:12:17 <kdinluks> mauke Program error: argument out of range
18:12:30 <kdinluks> mauke that's what I'm getting
18:12:50 <mauke> > (-2) ** 0.5
18:12:51 <lambdabot>  NaN
18:14:03 <kdinluks> mauke got it?
18:14:14 <malcolm> re ICFP contest video, it looks like google will review it before it goes live, so might take some time to appear
18:14:18 <mauke> I have no idea where that errors is coming from
18:14:53 <kdinluks> mauke =/ nedder does I
18:15:10 <dons> thanks malcolm !
18:15:33 <dolio> ?type (-2)**3
18:15:34 <lambdabot> forall a. (Floating a) => a
18:15:43 <malcolm> perhaps they will get to it fast if i point out that it features a winning google team
18:15:45 <kdinluks> mauke I'm using WinHugs and you?
18:17:19 <mauke> kdinluks: lambdabot
18:18:00 <dons> (which is using ghc)
18:18:13 <kdinluks> I'll try ghc
18:18:43 <dons> seems like a simple type constraint issue. you should paste the code, kdinluks
18:18:45 <dons> ?paste
18:18:46 <lambdabot> http://paste.lisp.org/new/haskell
18:19:27 <kdinluks> I'm just typing this at WinHugs: (-2)**3
18:19:32 <kdinluks>  and I'm getting: Program error: argument out of range
18:19:59 <dons> ah !
18:20:00 <dons> Hugs.Base> (-2)**3
18:20:00 <dons> Program error: argument out of range
18:20:02 <dons> :)
18:20:11 <kdinluks> yep
18:20:21 <kdinluks> but if you try (-2)^^3
18:20:28 <dons> while ghci says:
18:20:28 <kdinluks> it works
18:20:29 <dons> GOA> (-2)**3
18:20:29 <dons> -8.0
18:20:46 <kdinluks> that's why i'm saying
18:21:04 <kdinluks> but what's the type of ^^
18:21:10 <pianodogg> ?type (^^)
18:21:11 <dons> Hugs.Base> - (2**3)
18:21:12 <dons> -8.0
18:21:12 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:21:29 <pianodogg> thanks, lambdabot
18:21:33 <pianodogg> @arr
18:21:34 <lambdabot> Avast!
18:22:36 <kdinluks> (^^) is forall ?!?!
18:22:52 <pianodogg> no more than anything else
18:22:57 <pianodogg> ?type length
18:22:59 <lambdabot> forall a. [a] -> Int
18:23:13 <pianodogg> type variables are usually universally quantified over the entire type
18:23:16 <kdinluks> sorry
18:23:19 <mauke> > exp (log -2 * 3)
18:23:20 <lambdabot>  add an instance declaration for (Floating (a -> a))
18:23:20 <lambdabot>   In the definition o...
18:23:24 <pianodogg> it's only when they're not forall'ed over the whole thing that things get wacky
18:23:26 <mauke> > exp (log (-2) * 3)
18:23:27 <lambdabot>  NaN
18:23:55 <mauke> I still don't get why hugs throws an error
18:23:58 * araujo looks in
18:24:02 <dons> > log (-2)
18:24:04 <lambdabot>  -Infinity
18:24:10 <dons> > log (-2) * 3
18:24:12 <lambdabot>  -Infinity
18:24:19 <dons> > exp $ log (-2) * 3
18:24:20 <lambdabot>  NaN
18:24:52 <Patterner> > 1/0
18:24:53 <lambdabot>  Infinity
18:24:56 <kdinluks> look
18:24:57 <Patterner> > 1/-0
18:24:58 <lambdabot>  Not in scope: `/-'
18:25:04 <Patterner> > 1/(-0)
18:25:05 <lambdabot>  -Infinity
18:25:06 <kdinluks> that's an exemple of my code
18:25:26 <kdinluks> exp x = x ^^ x
18:25:38 <kdinluks> and then i get
18:25:42 <mauke> @type \x -> x ^^ x
18:25:44 <lambdabot> forall a. (Integral a, Fractional a) => a -> a
18:25:54 <dons> ?type exp
18:25:55 <lambdabot> forall a. (Floating a) => a -> a
18:25:58 <kdinluks> Instance of Integral Double required
18:26:11 <mauke> kdinluks: yes, because Double isn't an integral type
18:26:18 <dons> right. you're missing a fromIntegral
18:26:18 <kdinluks> what should i put in the deffinition
18:26:19 <kdinluks> ?
18:26:26 <kdinluks> exp :: Double -> Double
18:26:31 <dolio> ?type ^
18:26:32 <lambdabot> parse error on input `^'
18:26:36 <dons> ?let myexp x = x ^^ x
18:26:37 <dolio> ?type (^)
18:26:39 <lambdabot> Defined.
18:26:40 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:28:03 <malcolm> hmm, Google Video is throwing an error when i try to submit the desciprtion of the ICFP video
18:28:07 <malcolm> will try again later
18:28:18 <malcolm> got a drinks reception to go to
18:28:47 <dolio> > L.myexp 5
18:28:48 <lambdabot>  Add a type signature
18:28:56 <dolio> > L.myexp 5 :: Double
18:28:57 <lambdabot>  add an instance declaration for (Integral Double)
18:28:57 <lambdabot>   In the expression: L....
18:29:35 <dolio> > L.myexp 5 :: Integer
18:29:36 <lambdabot>  add an instance declaration for (Fractional Integer)
18:29:36 <lambdabot>   In the expression:...
18:29:41 <Pseudonym> ?type \x -> x ^^ x
18:29:42 <lambdabot> forall a. (Integral a, Fractional a) => a -> a
18:29:43 <dolio> :)
18:29:53 <mauke> ?unlet myexp
18:29:53 <lambdabot>  Parse error
18:29:57 <mauke> what
18:30:25 <dons> ?undefine
18:30:26 <dibblego> can a C application call into Haskell?
18:30:26 <lambdabot> Undefined.
18:30:37 <dons> dibblego: yep
18:30:41 <SamB> dibblego: not without help from Haskell!
18:30:45 <dibblego> lol
18:31:03 <dons> for exampe,
18:31:04 <dons>   hs_init(&argc, &argv);
18:31:04 <dons>   p = hs_eval_i("let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 20 :: Int");
18:31:07 <dons>   hs_exit();
18:31:15 <dons> (that's even doing runtime complation of haskell from c :)
18:31:21 <dibblego> is that C?
18:31:24 <dons> yep
18:31:25 <dibblego> ah I see
18:31:30 <SamB> dons: ... does that need hs-plugins?
18:31:34 <dons> it does, yes.
18:31:40 <dibblego> so you call Haskell by passing an expression as  a char* ?
18:31:41 <dons> its aactually calling hs-plugins from C
18:31:44 <dons> no.
18:31:51 <SamB> as I said. not without help from Haskell ;-)
18:31:56 <dons> dibblego: you can just call haskell functions as if they're C functions
18:32:04 <SamB> dons: what!
18:32:12 <dons> foreign export
18:32:19 <dibblego> dons, but that's not what you just did?
18:32:20 <dons> e.g. hs_eval_i above is a Haskell function
18:32:21 <SamB> that isn't "just"
18:32:24 <gmh33__> how do I write a function which reads a char, then puts it into a string and returns the string as a string ?
18:32:27 <dibblego> oh
18:32:32 <SamB> that is "foreign export and"
18:32:45 <gmh33__> as opposed to an IO string
18:32:46 <dons> dibblego: look up foreign export in the FFI spec
18:32:53 <dibblego> dons, ok thanks
18:32:54 <SamB> dons: paste the export for hs_eval_i!
18:33:04 <mauke> gmh33__: you can't do IO without IO
18:33:11 <dons> ok!!
18:33:29 <dons> foreign export ccall hs_eval_i  :: CString -> IO (Ptr CInt)
18:33:29 <gmh33__> mauke: would I just bind the output then ?
18:33:46 <mauke> ?type getChar
18:33:48 <lambdabot> IO Char
18:33:51 <dons> hs_eval_i :: CString -> IO (Ptr CInt)
18:33:52 <dons> hs_eval_i s = ....
18:34:11 <kdinluks> uhulll
18:34:29 <mauke> gmh33__: liftM return getChar ;-)
18:34:35 <kdinluks> thanks guys
18:34:42 <kdinluks> now it's working
18:34:47 <kdinluks> =]
18:35:03 <mauke> or do { c <- getChar; return [c] }
18:35:33 <dons> ?type return `fmap` getChar
18:35:34 <pianodogg> sequence (repeat 10 getChar) gives you an IO String with 10 chars
18:35:34 <lambdabot> forall (m :: * -> *). (Monad m) => IO (m Char)
18:35:56 <pianodogg> then you can write it to a file
18:36:09 <dons> ?. pl undo do { c <- getChar; return [c] }
18:36:09 <pianodogg> do { str <- sequence (repeat 10 getchar); writeFile "myfile" str }
18:36:10 <lambdabot> return `fmap` getChar
18:36:13 <dons> heh
18:36:24 <mauke> lambdabot: you're evil
18:36:40 <pianodogg> indeed, he's a pirate!
18:36:41 <pianodogg> @arr
18:36:42 <lambdabot> Ahoy mateys
18:36:49 <mauke> @yarr
18:36:49 <lambdabot> Yeh scurvy dog...
18:38:00 <gmh33__> @hoogle fmap
18:38:01 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
18:38:02 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
18:38:02 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
18:38:48 <mauke> (a -> b) -> {a} -> {b} where {} is an arbitrary container
18:38:59 <mauke> such as [] or IO
18:39:04 <pianodogg> or Maybe
18:41:34 <dons> or (->) a
18:41:42 <dons> let make this fun, eh!
18:42:21 <kdinluks> i'm doing a function to calc integral
18:42:36 <SamB> kdinluks: you are off to a bad start
18:42:55 <kdinluks> SamB what?
18:43:04 <dons> be nice SamB
18:43:21 <SamB> he isn't even using whole words!
18:43:40 <dibblego> how do you express the value for a function when you're in a do?
18:43:50 <SamB> dibblego: ... say again?
18:43:53 <SamB> in english?
18:43:56 <dibblego> never mind
18:44:00 <dons> dibblego: do x <- f ?
18:44:19 <kdinluks> it's because i'm not a netive english speaker
18:44:23 <kdinluks> i'm trying
18:44:38 <dibblego> I think I don't make sense, I'll read
18:44:38 <dons> kdinluks: don't worry about SamB, he's just grumpy some times.
18:44:49 <kdinluks> dons haha
18:45:00 <sjanssen> @SamB
18:45:00 <lambdabot> Unknown command, try @list
18:45:04 <SamB> hah
18:45:08 <dons> sjanssen: heh
18:45:09 <sjanssen> @palomer -- close 'nuff
18:45:10 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
18:45:13 <SamB> I'm not that quirky
18:45:22 <sjanssen> speaking of palomer, where has that guy been?
18:45:24 <SamB> or insane or whatever the critereon is
18:45:24 <sjanssen> @seen palomer
18:45:25 <lambdabot> I haven't seen palomer.
18:45:33 <dons> ?where stats
18:45:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:45:38 <dons> i think he's been gone for a month or two
18:47:27 <dons> 52 days
18:49:46 <dons> lispy: I think we should add an 'help' example after the 'listmodules' example to lambdaweb
18:49:55 <dons> anyone else got some comments http://lambdabot.codersbase.com/
18:49:57 <lambdabot> Title: Lambdabot Web Interface
18:53:15 <dons> ?users
18:53:30 <lambdabot> Maximum users seen in #haskell: 237, currently: 211 (89.0%), active: 32 (15.2%)
18:57:58 <jgrimes> it's pretty cool, it'd be nice if there was a buffer history
18:57:59 <jgrimes> :)
18:58:13 <jgrimes> so you don't have to copy and paste or whatever you might do instead
18:58:53 <jgrimes> Maybe a darker font for the user input
18:58:59 <kdinluks> does anyone wanna see my 147-lines-code and try to help me with integral?!
18:59:26 <kdinluks> I know it's difficult
18:59:29 <kdinluks> but
18:59:32 <dons> jgrimes: thanks yes.
18:59:36 <dons> kdinluks: just paste it here
18:59:37 <dons> ?paste
18:59:38 <lambdabot> http://paste.lisp.org/new/haskell
19:00:44 <lisppaste2> kdinluks pasted "Integral" at http://paste.lisp.org/display/26343
19:03:11 <jgrimes> it also might be nice to have a static list of the lambdabot's features
19:03:50 <jgrimes> well... I say features, I mean commands
19:04:00 <profmakx> o.o
19:04:11 <kdinluks> jgrimes that would be nice
19:04:32 <dons> ?list
19:04:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:04:34 <profmakx> ieks spanish?
19:07:17 <jgrimes> syntax highlighting would be cool... but not really necessary :)
19:07:34 <dons> yeah, we do want to add that
19:09:07 <dmwit> Haha.
19:09:35 <dmwit> "It is free to perform input/output, so it can consult some external oracle (whether it is raining, say) to decide which member of the set to choose."
19:10:48 <jgrimes> maybe have the hoogle results linked to the libraries
19:10:57 <jgrimes> documentation
19:10:59 <jgrimes> that is :)
19:10:59 <dons> yeah, needs a hoogle update
19:17:58 <jgrimes> very cool though, and speedy :)
19:20:54 <profmakx> @time dons
19:20:56 <lambdabot> Local time for dons is Wed Sep 20 12:20:32 2006
19:24:00 <kdinluks> @time kdinluks
19:24:03 <lambdabot> Local time for kdinluks is Tue Sep 19 23:23:36 2006
19:24:03 <kdinluks> haha
19:26:02 <SamB> I thought oracle was a database product?
19:26:08 <SamB> not a weather-forecasting package...
19:26:24 <dmwit> Oracles tell all sorts of things...
19:26:32 <dmwit> Like whether functions finish!
19:26:33 <dmwit> =)
19:26:37 <SamB> hah
19:27:38 <dons> it is nicely speedy, isn't it. fastcgi is fun
19:40:11 <araujo> What is an efficient way of deleting files from Haskell?
19:40:35 <dons> removeFile ?
19:40:45 <dons> ?hoogle removeFile
19:40:46 <lambdabot> Directory.removeFile :: FilePath -> IO ()
19:41:08 <araujo> Good!
19:43:09 <dylan> woo, record update syntax.
19:43:27 <dylan> I hadn't an idea such a thing existed.
19:44:38 <dons> is there any support for using an external editor to edit wiki pages from say firefox?
19:45:35 <jgrimes> dons, have you seen http://en.wikipedia.org/wiki/Wikipedia:Text_editor_support ?
19:45:40 <lambdabot> http://tinyurl.com/gxh9d
19:46:10 <dons> I'm just writing an article on efficient wiki editing with w3m and vim, but though i better do some back ground research :)
19:47:01 <dons> ah good, thanks jgrimes
19:57:55 <dwm> I use an extension in Firefox called mozex that kicks open the contents of textareas in gvim for me.
19:58:17 <dwm> Totally uncivilized to edit multiline text any other way.
19:59:04 <dons> yep
19:59:35 <profmakx> why not emacs? *runs*
19:59:48 <dons> or that
20:00:29 <dwm> :)  Totally uncivilized to edit multiline text in the browser in situ.
20:00:40 <dibblego> does the plugin use any editor or just gvim?
20:01:29 <dwm> dibblego: Any editor, and it does a lot more than textareas.
20:02:18 <dwm> Looking at the prefs.. you can define what happens for mailer, textarea, telnet, irc, ED2K, "source" news, ftp, download and send link.
20:02:30 <dwm> with commands you fill in.
20:02:53 <dwm> I'm guessing that source is page source.
20:03:02 <dwm> But I didn't bother with most of these settings.
20:03:44 <dons> ok, i put my thoughts here http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/20#efficient_wiki_editing
20:03:47 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/nhp9d
20:03:48 <dibblego> won't install for me
20:03:52 <dibblego> bugger it
20:03:52 <dons> if anyone has some feedback
20:04:28 <dibblego> s/I suspect the these/I suspect that these
20:04:38 <dwm> dibblego: Browser version?
20:04:42 <dibblego> s/inefficiences/ineffiencies
20:04:48 <dons> thanks
20:05:00 <dibblego> dwm, 1.5.0.5 Linux
20:05:02 <dons> i should really run a spell checker on these :)
20:05:40 <dibblego> s/We can fill these holes, and improve efficiency/We can fill these holes and improve efficiency
20:05:46 <sieni> dibblego: s/ineffiencies/inefficiencies/
20:05:57 <dibblego> er thanks :)
20:06:18 <dons> yes.
20:07:29 <dwm> I have 1.07.1 installed but I don't have the page marked where it came from. I wonder if something here will help: http://www.gatsby.ucl.ac.uk/~iam23/code/mozex/
20:07:33 <lambdabot> Title: Mozex with UTF-8 in Firefox 1.5, http://tinyurl.com/gyrhq
20:08:05 <dwm> Looks like somebody has been tinkering with this thing in the past few months.
20:08:39 <dibblego> I get some silly error message after it attempts to install
20:09:29 <SamB> @spell inefficiencies
20:09:30 <lambdabot> inefficiencies
20:10:11 <dibblego> @spell inefficiencies because nobody else can
20:10:12 <lambdabot> inefficiencies because nobody else can
20:13:05 <dwm> On a semi-related note, it only took my co-workers about 3 weeks to stop pressing me to give up Vim and use Eclipse for development at work.
20:13:25 <dibblego> dwm, Intellij IDEA > Eclipse
20:13:36 <dwm> I don't use IDEs.
20:13:36 <dibblego> dwm, it's an on-going war here, and IDEA is winning
20:13:46 <dibblego> I try not to use Java :)
20:14:01 <monochrom> Isn't Intellij IDEA specific to Java?
20:14:10 <dwm> dibblego: This job is actually all Perl, but they're gonzo about the big E.
20:14:21 <dibblego> monochrom, I use it for other things, but generally yes
20:14:28 <dibblego> monochrom, I use it for HTML/XML editing
20:16:48 <dons> dwm , heh.
20:17:28 <dons> I just realised: I only use vim and darcs to publish blog articles. It should be exacly the same for wikis (along with the web interface).
20:17:47 <dons> requiring a web interface hampers the power users
20:18:29 <dwm> I think it does, yeah.
20:18:39 <dwm> Does any Haskell discussion happen on usenet?
20:18:56 <dwm> I have not looked yet.
20:19:04 <dons> on comp.lang.functional?
20:19:14 <dolio> There's occasional stuff on comp.lang.functional.
20:19:21 <dolio> And there's the mailing list mirror.
20:19:36 <dons> dwm, http://groups.google.com/group/comp.lang.functional/about?hl=en
20:19:42 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/khb9e
20:19:59 <dons> note that since about 1993 the mailing lists hvae been more active :)
20:20:13 <dons> probably planet.haskell.org is more active than comp.lang.functional these days too
20:23:14 <jgrimes> Language.Haskell.Parser only parses Haskell 98 correct?
20:23:23 <dwm> thanks
20:27:28 <glguy> who won icfp?
20:29:00 <dolio> Someone using 2D.
20:29:15 <dons> google using 2D
20:29:17 <glguy> whats that
20:29:19 <dons> (!)
20:29:49 <dons> think of the publicity we get when google decides to run a team in the icfp contest..
20:30:32 <glguy> how did Haskell fair?
20:30:39 <malcolm> hi guys, I'm having difficulty getting Google Video to accept the description info about the ICFP contest video
20:30:52 <dons> hmm.
20:30:59 <malcolm> Haskell was not in the top three or the judges prize
20:31:57 <malcolm> (Google video gives a server error on submission.  The video is there, it is just that it won't be added to their index until the description is added and the content/format is reviewed.)
20:32:02 <glguy> Did google make up 2D for this competition??
20:32:29 <malcolm> I have a suspicion that 2D was one of the programming languages invented by the contest organisers
20:32:40 <dons> yes. it was.
20:32:59 <malcolm> since you didn't submit any source code, you just had to declare what your favorite language was
20:33:03 <araujo> malcolm, no!?
20:33:05 <araujo> argh
20:33:18 <dons> a funny case/products language, using circuit diagram layouts
20:33:26 <dons> so they probably didn't use 2D :)
20:33:48 <glguy> http://en.wikipedia.org/wiki/2d_%28programming_language%29
20:33:51 <malcolm> I should have asked them what they did use
20:33:51 <lambdabot> http://tinyurl.com/mg5ok
20:33:54 <glguy> I'd like to try programming in it :)
20:34:04 <dons> its rather horrible  :)
20:34:22 <dons> and to win you had to write a ray tracer in it, iirc
20:34:42 <malcolm> hmm, a one dimensional ray tracer....
20:34:47 <dons> yep :)
20:35:06 <malcolm> and there were only three colours...
20:35:09 <dolio> It'd be better if you didn't have to draw in ascii. :)
20:36:32 <dolio> I bet it was a joy to write the parser.
20:37:17 <dons> ah, here: http://www.cse.unsw.edu.au/~dons/code/icfp06/puzzles/CIRCS/raytrace_complete.2d
20:37:19 <lambdabot> http://tinyurl.com/jxc7h
20:37:37 <dons> :) written by Sean Seefried
20:37:56 <dons> (there are more high-scoring answers though, once you pack the tiles)
20:41:18 <glguy> *Avast!*
20:43:51 <dons> hey glguy
20:43:57 <dons> just building the ghc now with your patch
20:44:14 <glguy> yo ho ho!
20:45:11 <dfranke> how does garbage collection work with the FFI?
20:45:57 <dons> you don't collect stuff held outside of the haskell heap
20:46:07 <glguy> *squawk* wind in the sails
20:46:07 <dons> unless its got a finaliser attached, in which case the finaliser can be run
20:46:35 <dfranke> how do I attach a finalizer?
20:46:45 <dons> ?hoogle finalizer
20:46:46 <lambdabot> Foreign.Marshal.Alloc.finalizerFree :: FinalizerPtr a
20:46:46 <lambdabot> Foreign.ForeignPtr.FinalizerPtr :: type FinalizerPtr a
20:46:46 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
20:46:59 <dons> check the docs :) or read the FFI addendum
20:47:45 <dfranke> thanks
20:48:19 <dolio> I love slashdot's new tagging mechanism.
20:48:29 <dolio> "Can Linux Pick Up Users Abandoning Win98?"
20:48:37 <dolio> Tags: "no, yes, linux, maybe"
20:48:42 <dfranke> why?  Because everything deservedly gets tagged "stupid"?
20:49:04 <dolio> 'Noise Over Mac OS Market Share "Slip"'
20:49:11 <dolio> Tags: "fud, apple, notfud"
20:50:20 <dons> heh
20:51:08 <dfranke> I stopped reading /. the day I found Reddit.
20:51:38 <dolio> Reddit does get marginally better articles, I guess.
20:51:58 <glguy> I prefer digg to slashdot, the articles cycle faster
20:52:22 <dfranke> programming.reddit.com has some excellent stuff.
20:52:32 <glguy> I'll have to take a look
20:52:42 <dolio> Although it has some of its own peculiarities.
20:53:06 <dolio> I think the second day I was looking at it, there was an article posted entitled "Is Erlang hype the new Ruby hype?"
20:53:15 <dfranke> dolio: Paul Graham Paul Graham Paul Graham Paul Graham Paul Graham
20:53:32 <glguy> Ruby scares the hell out of me
20:53:35 <dolio> Only, I don't think there was any Erlang hype outside of people posting random blogs about it to reddit, and them subsequently getting voted up.
20:53:40 <glguy> I would hate to work on a ruby project with someone else
20:53:56 <dfranke> I like Ruby.
20:54:05 <glguy> the language lets you do some sweet things
20:54:16 <gmh33__> dfranke: word
20:54:27 <dons> hmm "Genuine University Degree 1n 4-6 weeks! Have you ever thought that the only thing stopping you from a great job and better pay was a few letters?" -- hmm yes, i'd probably have a job if it wasn't for the letters 'P', 'h', and 'D'. damn them!
20:54:29 <dfranke> gmh33__: ?
20:54:31 <dibblego> Ruby and all dynamic typing must die
20:54:35 <gmh33__> dfranke: I like it too
20:55:01 <glguy> I think that programming in a group of 3 is scary with C#, I can't imagine programming in a group at all in ruby
20:55:20 <gmh33__> glguy: that's why it's a scripting language >_>;
20:55:35 <wkh> dibblego: i just bought 2 rails books
20:55:42 <wkh> it looks pretty amazing
20:55:55 <glguy> gmh33__: fine, as long as people don't write more than a single files worth of code in it
20:56:02 <wkh> i was into it like a year ago but i got sick of dhh's personality, now i'm so sick of python crap that i don't see any other realistic choice
20:56:10 <gmh33__> I've written fair sized projects in it, on my own however
20:56:19 <dfranke> I mostly use Ruby for throwaway programs.  HTML scrapers, replacement for shell scripts, and such.
20:56:35 <dfranke> I've never used its OOness much.
20:56:41 <gmh33__> you just have to know what you intend to do with all the variables, outside of that dynamic typing can be very helpful
20:56:49 <dibblego> dynamic typing is a workaround to all the problems of more traditional languages - it is not a solution
20:57:06 <glguy> My impression of ruby is that if you can't keep the whole program in your head at once, don't use rubyu
20:57:55 <gmh33__> I'm sure like any big project, that if you plan and execute carefully it's not to bad
20:58:13 <wkh> dynamic typing is an advantage that lets you change your mind. i'm sorry that you're bitter than haskell is at the present time useless for just throwing stuff in and out of the database and sending the stuff over the wire but that's reality.
20:58:18 <gmh33__> except that it'd run excessively slow by comparason to other languages
20:58:36 <glguy> wkh: I'm sorry that you think I'm arguing for haskell right now
20:59:03 <dons> wkh, hmm... lambdabot, HAppS, the House network stack.. the network is no issue.
20:59:37 <dolio> I think the people who use Ruby for more substantial stuff tend to do a lot of unit testing.
20:59:56 <dons> maybe databases are, but Hope seems to run find on top of haskelldb , and theres a bunch of others, so I'm not convinced that its "useless" for database stuff either.
21:00:04 <gmh33__> I like ruby because it's similar in intended use to perl but much easier to learn
21:00:18 <gmh33__> soooooo yay
21:00:27 <gmh33__> anyway, have fun with the language war :P
21:01:01 <dolio> Which is sort of like a loose type checking for Ruby programs.
21:01:40 <dolio> Where "type" is defined by whether or not it responds correctly for the methods called on a particular object.
21:01:40 <monochrom> Dynamic typing is advantageous for exploiters.
21:02:04 <glguy> ruby doesn't have "types" it has starting points
21:02:06 <dibblego> I hope it dies soon so that real languages can become mainstream
21:02:33 <gmh33__> define "real"
21:03:14 <gmh33__> smalltalk was widely used in industry
21:03:28 <dibblego> no, popular is not synonymous with real - if anything, the opposite
21:03:45 <dibblego> real means the opposite of popular :)
21:03:56 <dibblego> which highlights the obvious paradox
21:03:57 <gmh33__> we must stop haskell from being widely used!
21:04:02 <gmh33__> else it will become a falsehood :P
21:04:06 <dibblego> exactly :)
21:04:07 <glguy> PHP is popular because any idiot can screw up with it
21:04:13 <gmh33__> hahah I hate php
21:04:14 <glguy> I know, I used to use it :)
21:04:26 <gmh33__> I never bothered to learn it because it was just bad
21:04:29 <monochrom> real. adj.  of what *I* care.  E.g., "the real world" = "my surroundings"
21:04:32 <dibblego> I fear that Haskell will never become popular because it is not broken enough
21:04:39 <dolio> I hate it too.
21:04:56 <gmh33__> Haskell will never become popular because you have to forcefully break your brain to learn it
21:05:20 <dibblego> I think it's easy to learn - it's just hard to unlearn all the other gumph
21:05:28 <monochrom> I didn't break my brain learning it.  In fact after learning it I understand other programming methods more.
21:05:28 <gmh33__> and because colleges only teach how to program in Java these days anyway :p
21:05:40 <dibblego> but most things I find easy others don't and vice versa it seems in my years on this planet
21:06:11 <gmh33__> It's not hard to learn
21:06:19 <monochrom> You do not fully understand your mother tongue until you learn another language, even another culture, to constrast with yours.
21:06:21 <gmh33__> once you completely abandon all prior programming thought
21:06:30 <dibblego> as soon a I abandon some preconceived idea, the idea that Haskell is trying to purport is strikingly clear
21:06:44 <gmh33__> :P
21:06:53 <gmh33__> anyway sleep time
21:06:59 <gmh33__> have fun discussing... languages ?
21:06:59 <dibblego> I argue that my 5 year old will learn Haskell easier than I am doing
21:07:03 <dibblego> g'night
21:07:09 <glguy> Also, while we are ranting, I'm tired of slashdot predicting the year of linux every year. The free OSs aren't going to take off because only the people that really care, and the people that those that really care can convince will convert, it won't get past that
21:07:20 <monochrom> Induction!
21:07:23 <glguy> the neutral convertees aren't going to continue the convertion
21:07:27 <glguy> conversion
21:07:36 <glguy> and the devotees don't have enough friends
21:07:46 <dolio> Heh.
21:08:05 <gmh33__> it's not polished enough to become widespread
21:08:07 <gmh33__> meh
21:08:08 <gmh33__> night
21:08:29 <dibblego> on the contrary, it's not dull enough to appeal to the intuition of the mass
21:08:30 <glguy> my highschool girlfriend switched because he college boyfriend said it was better
21:08:41 <glguy> but she hadly knew what linux was, just that she used it
21:08:46 <glguy> she wasn't going to convert any of her friends
21:09:10 <dibblego> glguy, precisely my girlfriend - we only use linux at home - but she doesn't know why exactly
21:09:41 <dibblego> or really, the only machines with monitors attached are linux I should say
21:09:45 <gmh33__> I use linux for servering, it's only real good use :P
21:09:55 <dibblego> my 5 year old uses and loves edubuntu
21:09:56 <glguy> my fiancce loves my Mac now that I've shown her some of the neat tricks
21:10:03 <glguy> and she's not much of a computer person
21:10:04 <dolio> Being unpopular is an advantage anyway. It keeps people from writing viruses for it.
21:10:14 <dibblego> he never uses the windows partition so I blew it away
21:10:21 <glguy> I see mac getting more of the people that linux wants
21:10:43 <glguy> the ones that don't know what they want
21:10:47 <glguy> or don't care
21:10:48 <dibblego> yes, my colleagues are mac zealots
21:10:58 <dibblego> I am the only linux in the house
21:11:33 <dibblego> we have some windows machines because linux refuses to install on them - some kind of MBR protection in the hardware or something - I gave up
21:11:49 <glguy> I think that programming languages will see the same results
21:11:59 <glguy> there are too many people who don't care about programming and who just do it as a job
21:12:13 <dibblego> I think a programming language can appeal to all levels of the skill pyramid
21:12:15 <glguy> and the ones that do it for the love of computer science aren't numerous
21:12:24 <glguy> enough to influence the masses
21:12:26 <dibblego> create a correct language, introduce broken bits, but market them well
21:12:28 <glguy> beyond their friends
21:12:43 <dibblego> then those at the top of the pyramid need not suffer for the deficiencies of those below them
21:12:56 <dibblego> let them talk about how great their broken bits are
21:13:09 <dibblego> the correction is available even if widely misunderstood
21:13:22 <dibblego> there should be compatibility between each level in the pyramid
21:13:54 <dibblego> does Haskell compile to the JVM or .NET runtime?
21:14:10 <glguy> closest thing I've seen for .NET is F#
21:14:21 <dibblego> that's a shame
21:14:25 <dolio> Something compiles to some kind of byte code.
21:14:25 <sjanssen> dibblego: I don't believe so
21:14:37 <glguy> yhc does bytecode
21:14:37 <dolio> Or am I thinking of something else?
21:14:44 <sjanssen> there was some work on YHC compiling to JVM bytecode I think
21:14:55 <sjanssen> maybe .NET too
21:14:59 <dibblego> I, and a few others, predict that the first half-decent FP language to provide a feasible migration off the nonsense will win the race
21:15:11 <glguy> yhc had a .net backend rumored on google
21:15:37 <sjanssen> what is the status of YHC?  Can I really use it now?
21:15:47 <glguy> ndm says not yet but soon (i think)
21:16:20 <sjanssen> I'm not sure what I would use it for, I like the speed of GHC
21:16:56 <glguy> yhc is supposed to compile way faster than ghc
21:17:01 <glguy> just not execute faster
21:17:30 <sjanssen> yeah, speed of generated code is what I appreciate
21:17:45 <jgrimes> dons, the URL output by "@fptools Language.Haskell.Parser" isn't correct because it is Parser.ly instead of Parser.hs
21:18:35 <sjanssen> @fptools GHC.Base
21:18:36 <lambdabot> GHC.Base not available
21:18:47 <sjanssen> @fptools GHC.List
21:18:47 <lambdabot> GHC.List not available
21:20:25 <dons> jgrimes: ah hmm. ok
21:20:30 <dons> let me check
21:21:23 <dons> ok, needs some tweaks.
21:22:24 <glguy> dons: why doesn't lambdabot import control.monad.error?
21:25:01 <dons> no good reason, i suspect. you want it?
21:25:09 <sjanssen> eww, fptools uses a static table?
21:25:19 <glguy> it would allow Either to be a monad
21:25:43 <dons> sjanssen: you know how to patch :)
21:25:55 <dons> there's a script to regen it, iirc
21:27:34 <glguy> > fail "this should work" :: Either String String
21:27:36 <lambdabot>  Left "this should work"
21:27:42 <glguy> did you just add that?
21:27:47 <glguy> or did I just figure out how to make it work?
21:28:50 <dolio> > (Left "error") >>= return 5 :: Either String Int
21:28:50 <lambdabot>  add an instance declaration for (Num (Either [Char] Int))
21:29:07 <sjanssen> I suppose if there is a script to regenerate the list, that isn't so bad
21:29:15 <dons> glguy: yes.I added it.
21:29:15 <dolio> > ((Left "error") >>= return 5) :: Either String Int
21:29:16 <lambdabot>  add an instance declaration for (Num (Either [Char] Int))
21:29:17 <glguy> > (Left "error") >> return 5 :: Either String Int
21:29:18 <lambdabot>  Left "error"
21:29:30 <dolio> Oh, right, mine won't work of course.
21:29:58 <glguy> > do { (x:xs) <- Right [] } :: Either String String
21:29:59 <lambdabot>  Parse error
21:30:06 <glguy> > do { (x:xs) <- Right []; return () } :: Either String String
21:30:07 <lambdabot>  Couldn't match `String' against `()'
21:30:14 <glguy> > do { (x:xs) <- Right []; return () } :: Either String ()
21:30:15 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:5-10"
21:30:19 <glguy> there way go
21:30:29 <dons> :)
21:30:30 <glguy> someone was asking for examples of when fail actually used its argument
21:30:40 <glguy> and I was trying to show them that
21:33:43 <dons> yay, haskell syntax highlighting inside wiki highlighting working in vim now :)
21:33:48 <dons> just for the haskellwiki
21:33:54 <dolio> > do { (x:xs) <- [] ; return [] } :: [Int]
21:33:55 <lambdabot>  Couldn't match `Int' against `[a]'
21:34:18 <dolio> Oops.
21:34:29 <dolio> > do { (x:xs) <- [[]] ; return [] } :: [Int]
21:34:30 <lambdabot>  Couldn't match `Int' against `[a]'
21:34:54 <dolio> > do { (x:xs) <- [[]] ; return [] } :: [[Int]]
21:34:55 <lambdabot>  []
21:35:39 <glguy> dolio: what are you demonstrating?
21:35:59 <dolio> I was seeing what a pattern match failure in list did.
21:36:12 <glguy> > do { (x:xs) <- ([] :: [()]); return [()] }
21:36:13 <lambdabot>  Couldn't match `()' against `[a]'
21:36:34 <glguy> > do { (x:xs) <- ([] :: [()]); return () }
21:36:35 <lambdabot>  Couldn't match `()' against `[a]'
21:36:47 <glguy> > do { (x:xs) <- []; return () }
21:36:49 <lambdabot>  []
21:36:52 <glguy> > do { (x:xs) <- [()]; return () }
21:36:53 <lambdabot>  Couldn't match `()' against `[a]'
21:37:48 <glguy> dolio: anyway... it returns (fail "no pattern match" :: [a]) which is just []
21:37:59 <dolio> Right.
21:38:07 <glguy> which I love to abuse
21:38:59 <dolio> I guess that could be handy.
21:39:11 <dolio> If you want to do head with mzero on failure, for instance.
21:41:18 <dolio> Seems hyrax42 is having difficulties.
21:42:28 <glguy> > let setsOf [] = [[]]; setsOf xs = [y:z | (y:ys) <- tails xs, z <- setsOf ys] in setsOf [1,2,3]
21:42:30 <lambdabot>  [[1,2,3],[1,3],[2,3],[3]]
21:42:49 <glguy> > let setsOf [] = [[]]; setsOf xs = [y:z | (y:ys) <- tails xs, z <- setsOf ys] in setsOf [1..4]
21:42:51 <lambdabot>  [[1,2,3,4],[1,2,4],[1,3,4],[1,4],[2,3,4],[2,4],[3,4],[4]]
21:43:28 <glguy> lambdabot: should be banning these people
21:43:58 <dons> hmm
21:44:10 --- mode: ChanServ set +o dons
21:44:20 --- kick: hyrax42 was kicked by dons (bouncing!)
21:44:23 --- mode: ChanServ set -o dons
21:44:49 <dons> argh
21:44:52 <glguy> lol, tell me you saw that coming
21:44:58 <dons> yeah, well I was hoping...
21:45:25 <dons> I don't want to ban him for this. I'd prefer to just /ignore hyrax42 for a little while
21:45:44 <dons> maybe he's ok now ... :)
21:45:51 * dons crosses fingers
21:45:57 <dolio> What was that setsOf function for?
21:46:32 <dolio> It's not a full power set.
21:47:07 <dons> I wonder if that kick helped hyrax's client ? or was it just coincidence..
21:47:42 <glguy> dolio: it's broken, I'm trying to remember how I did it :)
21:48:02 <dolio> :) Yeah, I remember you having it before.
21:48:09 <glguy> > let setsOf xs = [y:z | (y:ys) <- tails xs, z <- []:setsOf ys] in setsOf [1..4]
21:48:11 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,4],[1,3],[1,3,4],[1,4],[2],[2,3],[2,3,4],[...
21:48:15 <glguy> > let setsOf xs = [y:z | (y:ys) <- tails xs, z <- []:setsOf ys] in setsOf [1..3]
21:48:17 <lambdabot>  [[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
21:48:18 <dolio> I was trying to remember it, too, since I needed a power set for mathschallenge.
21:48:23 <glguy> there it is
21:52:59 <bringert> lispy: you around?
21:55:19 <dolio> Actually...
21:55:39 <dolio> > let setsOf xs = [] : [ y:z | (y:ys) <- tails xs, z <- setsOf ys ] in setsOf [1..3]
21:55:40 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
21:56:18 <glguy> that looks good
21:56:27 <malcolm> lispy was looking into organising a streaming server for live video feed from the ICFP programming contest result, but didn't get it organised in the ten minutes available before it started :-)
22:07:58 <glguy> ?index fix
22:07:59 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
22:14:46 <glguy> > let test as = fix (([] :) . (>>= f)) where f y = do dropWhile (<= head (y++[0])) as >>= return . (:y) in take 8 $ test [1..3]
22:14:48 <lambdabot>  [[],[1],[2],[3],[2,1],[3,1],[3,2],[3,2,1]]
22:19:21 <dibblego> what function will return all the elements of a list that filter will not return and not return all the elements that filter will return?
22:19:36 <glguy> partition
22:19:42 <glguy> oh
22:19:50 <glguy> instead of filter
22:19:52 <glguy> filter p i mean
22:19:55 <glguy> do filter (not . p)
22:20:06 <dibblego> ah ok
22:20:11 <glguy> but if you want to do both at the same time, partition
22:20:19 <dibblego> ?index partition
22:20:20 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
22:20:34 <glguy> ?type Data.List.partition
22:20:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:20:46 <glguy> > partition even [1..10]
22:20:48 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
22:22:38 <glguy> Does anyone else think that the first element of the topic list might be a little creepy?
22:22:55 <dons> Syzygy-: you don't compile your GLUT code with optimisations on? ghc --make -package GLUT HelloWorld.hs -o HelloWorld verus adding -O
22:23:09 <dons> glguy: supposed to be a joke. maybe we should remove it :)
22:23:30 <dons> (A recent microsoft press release said: Join us as we move towards the age of .Net)
22:23:30 <glguy> will we all be killing ourselves when the comet flies over?
22:23:36 <glguy> ah
22:24:28 <glguy> I can't wait till programmer are completely commoditized and in general little interesting devlopment takes place
22:24:57 <weitzma1> glguy: How long are you planning to live?
22:25:01 <dons> heh
22:25:16 <glguy> weitzman: at least 4 more years
22:25:28 <Cale> heh
22:25:34 <dons> seems like computer programming is how we'll solve problems forever more. you think it will become uninteresting?
22:25:49 <glguy> There will always be interesting problems
22:25:57 <Pseudonym> The overwhelming majority of computer programming is uninteresting today.
22:26:04 <Pseudonym> And it's already commoditised.
22:26:10 <glguy> Pseudonym: agreed, and I think it will only get worse
22:26:19 <glguy> I don't believe that to be a visionary statement
22:26:26 <Pseudonym> I couldn't think of anything worse than working on some CRM system.
22:26:31 <Cale> I promise to remain alive for the next five minutes. I'm going to bed after that, and while I can't promise I'll wake up in the morning, it seems astonishingly likely. :)
22:26:47 <glguy> Cale: I promise to bring up the sun for you if you do ;)
22:26:51 <Pseudonym> Though I did get a call from an agency today about a project in seismology.  That sounded cool.
22:27:09 <Cale> glguy: Good to have someone keeping the clocks moving along.
22:27:26 <glguy> Cale: that time arrow... all me
22:27:45 <Pseudonym> That's what makes software possible, after all.
22:27:49 <glguy> me?
22:27:50 <Cale> Keep up the good work.
22:27:53 <glguy> or the time arrow?
22:28:27 <glguy> I'm thinking of moving time from an Arrow to an Applicative
22:28:41 <glguy> and treating it as a sequence of events
22:29:22 <glguy> I'd like 6.6 to release first tho ;)
22:30:02 <weitzman> Question...
22:30:08 <weitzman> > partitoin even [1..10]
22:30:09 <lambdabot>  Not in scope: `partitoin'
22:30:13 <dons> ?seen ozone
22:30:14 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
22:30:15 <weitzman> you know what I mean
22:30:19 <weitzman> Simple expression
22:30:35 <weitzman> Suppose you wanted, instead of even, a function that returned true every other time it's called
22:30:38 <weitzman> Using the state monad
22:30:50 <glguy> weitzman: filterM would get you half way there
22:31:00 <weitzman> @type filterM
22:31:01 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:32:10 <weitzman> At least in theory, I feel like it shouldn't be hard to keep using partition
22:32:23 <dons> ozone: I wonder if we could syndicated some of your blog categories onto planet.haskell.org? what do you think? just ping ibid if you'd like this.
22:32:46 <ValarQ> good morning #haskell
22:33:32 <glguy> ?type modify not >> get
22:33:34 <lambdabot> forall (m :: * -> *). (MonadState Bool m) => m Bool
22:34:42 <weitzman> @type (\x -> modify not >> get)
22:34:44 <lambdabot> forall (m :: * -> *) t. (MonadState Bool m) => t -> m Bool
22:34:44 <weitzman> @type partition
22:34:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:35:19 <weitzman> Is there a way to map a function a -> (b -> c) to a -> (b -> m c) ?
22:35:29 <weitzman> Actually, that's not what I mean
22:35:35 <weitzman> Reverse that
22:35:59 <weitzman> @hoogle Monad m => (a -> b) -> c -> ((a -> m b) -> m c)
22:36:00 <lambdabot> No matches, try a more general search
22:36:39 <glguy> > runState ( filterM (const $ modify not >> get) [1..10]) True
22:36:41 <lambdabot>  ([2,4,6,8,10],True)
22:36:46 <glguy> > evalState ( filterM (const $ modify not >> get) [1..10]) True
22:36:48 <lambdabot>  [2,4,6,8,10]
22:37:10 <dibblego> how do you get the nth from (a,b,c,d,e,f) ?
22:37:20 <glguy> pattern matching
22:37:46 <dibblego> is there any other way?
22:37:55 <glguy> use a list
22:37:59 <weitzman> Use SML!
22:38:00 <dibblego> ok ta
22:38:21 <glguy> dibblego: if you are usinga tupple, all 5 could be different types
22:38:31 <dibblego> yeah I know
22:38:32 <glguy> dibblego: if you are usin an nth selector, it could return any type
22:38:45 <glguy> if you know everything is the same type, a list would be better
22:38:52 <dibblego> right
22:39:02 <weitzman> The nth selector could be syntactic sugar
22:39:35 <glguy> you could only hard code in the value
22:39:36 <Korollary> (,) etc are data constructors for a nonrecursive type.
22:40:38 <weitzman> (#n) ==> (\(_, _, _, ..., x, ..., _, _) -> x)
22:40:42 <glguy> readLn >>= \n -> (a,b,c,d,e) `nth` n    wouldn't be able to typecheck at runtime most of the time
22:41:08 <weitzman> That seems like a pretty harmless compiler rewrite
22:41:29 <glguy> weitzman: as long as you knew which element you were returningat compile time
22:41:54 <weitzman> Indeed. If you don't know what element you're returning, you aren't using the right datatype
22:42:44 <glguy> if you need to name them, you should: data MyTuple a b c d e= MyTuple { one::a, two::b, three...
22:43:45 <weitzman> @type thrd
22:43:46 <lambdabot> Not in scope: `thrd'
22:43:47 <weitzman> @type thd
22:43:49 <lambdabot> Not in scope: `thd'
22:43:50 <glguy> dibblego: just to make sure you know: fst and snd work on (a,b)
22:44:00 <weitzman> @type fst
22:44:02 <lambdabot> forall a b. (a, b) -> a
22:44:04 <weitzman> Indeed
22:44:06 <dibblego> yes I understand thanks
22:44:24 <glguy> dons: you there?
22:44:36 <dons> yep
22:44:50 <glguy> :m Control.Monad.State doesn't seem to work for me on my snapshot build of ghci
22:44:58 <glguy> is that normal
22:45:02 <dons> how doesn't it work?
22:45:08 <dons> are you missing the -package mtl ?
22:45:11 <glguy> yeah, that
22:45:16 <glguy> I couldn't ghci -package mtl
22:45:17 <dons> (its in the extra packges now)
22:45:20 <glguy> ah
22:45:23 <dons> ghc-pkg list
22:45:26 <dibblego> ?index (&)
22:45:26 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive
22:45:30 <dons> should tell if you its installed or not
22:45:41 <glguy> not
22:45:51 <glguy> why is that not, and stm is?
22:46:01 <glguy> same with template-haskell :)
22:46:03 <dons> stm hmm. needs primop support?
22:46:07 <dons> and that too.
22:46:17 <glguy> oh, it's hardcoded in?
22:46:29 <dons> the stm primitives are, yes, they're part of the rts
22:47:02 <glguy> ok, so I need to download another tarball?
22:47:13 <dibblego> what does the @ mean when a function is declared with f p xs@(x:xs')?
22:47:23 <glguy> "as" it's an alias to the whole pattern
22:47:45 <glguy> x is the head of xs, xs' is the tail of xs
22:47:47 <dibblego> so xs is an alias to (x:xs')
22:47:50 <glguy> yeah
22:47:53 <dibblego> ok ta
22:49:05 <glguy> dons: can i use today's extralibs with the 17th's core?
22:49:27 <dons> yeah, most likely
22:57:20 <dons> grr. the ruby web site is so glitzy. I wish we had a flash website :S
22:57:57 <glguy> because that would win over the kind of users you'd want
22:59:19 <dibblego> you have to concede to some points if you ever want mass acceptance
22:59:25 <dibblego> history says so anyway
22:59:27 <Korollary> If we had flash, we'd be binding and returning like nobody's business.
22:59:39 <dons> it'd be nice to have a pretty site
22:59:51 <glguy> dons: and lets put up hello world in haskell
22:59:53 <dons> the current haskell.org is very useful, but a bit spare
22:59:55 <dibblego> I would compromise on the website if it meant the language didn't have to - so overall, it may be a great idea
23:00:16 <dons> glguy: should be up already, on "Haskell in 5 Steps"
23:00:19 <glguy> dons: as the first thing you see, because that's what matters
23:00:31 <glguy> dons: ruby's website has that first thing
23:00:32 <dons> though probably no need to go into "oh and there's this hard thing called IO monads" as it currently does
23:00:35 <dons> yeah
23:00:48 <dibblego> lol
23:00:52 <glguy> lets just slap that on haskell.org/index.html
23:00:58 <dibblego> they are not hard, just abstract
23:01:07 <Korollary> big bones.
23:01:08 <glguy> haskell is so sweet, proof: putStrLn "hello world!"
23:01:23 <dons> well, we'd jsut start with: "hello, world" in ghci, I think
23:01:29 <dons> then add putStrLn
23:02:20 <newsham> if you dont say the "M" word, IO is pretty easy
23:02:30 <dons> yeah exactly
23:02:45 <lispy> what the crap.../me punches printer
23:02:48 * dons tries to simplify things a bit
23:02:51 <dibblego> you should make it valid XHTML - at least, any website that validates gets my credibility immediately
23:03:01 <dibblego> and it's pretty easy to do
23:03:06 <glguy> Haskell needs one of those CSS Zen Garden site's
23:03:12 <glguy> the kind that make you stop in your browsing tracks
23:03:19 <glguy> (and is flash free)
23:03:29 <glguy> s/site's/sites
23:03:36 <roconnor> glguy: actually, it's module Main where main=putStrLn "hello world!"
23:03:37 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
23:04:00 <glguy> roconnor: i think you can get around the moduleMain where part
23:04:05 <dons> well, you don't need the module Main since a long time
23:04:09 <dons> :)
23:04:38 <glguy> lets change the language so that if you don't have any functions then the stuff at the toplevel is the main do block!
23:04:47 <glguy> then... we could just say: putStrLn "hello world"
23:04:48 <dons> boo
23:04:51 <glguy> profit!
23:04:54 <dons> :)
23:05:00 <dons> worked for perl
23:05:01 <glguy> otherwise, we can't compete
23:05:02 <roconnor> dons: according to the Haskell 98 report you need it :P
23:05:16 <dons> not needed in hugs or nhc or ghc, so not needed, in my books :)
23:05:17 <glguy> ruby advertises that you don't need a pesky "main function"
23:05:27 <dons> boo on ruby
23:05:38 <glguy> lets steal some thunder
23:05:53 <Korollary> Perl doesn't have main, but Perl6 will.
23:06:03 <lispy> it really should have been entry instead of main
23:06:13 <glguy> Ruby has nothing on HQ9+ though...
23:06:46 <glguy> dons: if you made a new site, would it be Web2.0<beta> approved?
23:06:57 <glguy> with the shiny beta seal on the logo?
23:07:10 <roconnor> http://bushong.net/dave/comparisons/infinite-hello.html
23:07:13 <lispy> i was really suprised when i met SimonM and he actually knew my name already
23:07:14 <lambdabot> Title: Programming Comparisons: Infinite Hello, http://tinyurl.com/es3es
23:07:27 <roconnor> Haskell comes near the end :( :P
23:07:33 <Korollary> GHC HQ has files on everybody.
23:07:33 <lispy> turns out, i'm pretty much the only visual haskell user :)
23:07:40 <Heffalump> anyone know anything about the programming contest results?
23:07:47 <lispy> Heffalump: yeah
23:07:49 <musasabi> morning
23:07:52 <lispy> Heffalump: some people won :)
23:07:54 <roconnor> Haskell, more concise than Pascal
23:08:06 <Heffalump> lispy: oh, really? :-)
23:08:08 <Heffalump> what language?
23:08:11 <lispy> Heffalump: the team with honorable mention was just one guy :)
23:08:25 <lispy> um...it wasn't haskell
23:08:28 <Heffalump> do you know when they'll update their webpage?
23:08:42 <lispy> i seem to recall the top ranked language was the UM language
23:08:46 <Heffalump> was it team smartass?
23:08:50 <zarvok> what do you want to know?
23:08:53 <zarvok> yeah, smartass one
23:08:55 <zarvok> *won
23:08:57 <zarvok> man I'm tired
23:09:09 <zarvok> #2 was kuma-
23:09:20 <zarvok> #3 was Can't spell awesome without ASM
23:09:27 <lispy> ?all-dicts kuma
23:09:29 <lambdabot> No match for "kuma".
23:09:30 <Korollary> what did those teams use?
23:09:34 <bringert> hi lispy
23:09:35 <zarvok> judges prize was witrala for coming in 5th with only one person
23:09:50 <zarvok> can't spell awesome picked assembly
23:09:55 <lispy> bringert: hey
23:09:55 <zarvok> kuma picked D
23:09:57 * Heffalump has lots of questions but assumes the webpage will be updated at some point
23:10:08 <zarvok> and smartass picked 2D
23:10:11 <zarvok> :)
23:10:18 <Heffalump> lol
23:10:28 <lispy> i can't imagine making the parser for 2d
23:10:30 <zarvok> Heffalump: it might be a couple days, so if there is anything specific I'm happy to answer
23:10:31 <lispy> that's just insane
23:10:37 <zarvok> heh, it was interesting
23:10:38 <glguy> So 2D is the language of choice for discriminating Hackers?
23:10:47 <zarvok> they made me do it, since I'm the undergrad on the team
23:10:51 <Heffalump> zarvok: ok, what was the highest place Haskell team, and where did Duncomloolump come?
23:11:00 <lispy> zarvok: haha, yeah they said that
23:11:00 <zarvok> glguy: yes
23:11:08 <zarvok> Heffalump: one sec, I'll check
23:11:16 <Heffalump> thanks :-)
23:11:26 <bringert> lispy: do you want to set up a lambdweb repo? or should I?
23:11:41 <bringert> maybe at darcs.haskell.org?
23:11:50 <Heffalump> (what team and where did they come for the highest placed Haskell team)
23:11:54 <lispy> bringert: you can set it up at haskell.org?
23:11:59 <zarvok> Heffalump: Duncomloolump was 12, lazy bottoms was 18
23:12:04 <bringert> lispy: yes
23:12:14 <lispy> bringert: how would we push patches?  you have shell there?
23:12:16 <Heffalump> damn, we dropped out of the top 10 :-/
23:12:18 <Heffalump> thanks.
23:12:26 <zarvok> I don't know if anyone higher picked haskell for language of choice, but smartass listed haskell as a used language
23:12:28 <bringert> lispy: yes. I guess you could get that too
23:12:49 <lispy> bringert: hmm...that might be nice if we started hosting it there
23:12:59 <Heffalump> oh, interesting, what else did they use?
23:13:02 <lispy> bringert: i think that sounds like a good idea if you can create the repo there
23:13:18 <zarvok> also c++ and python, I think
23:13:22 <bringert> I guess there is no fastcgi on www.haskell.org
23:13:25 <glguy> dons: i just checked out the ghc darcs repo, am I correct in assuming that the OpenBSD fix is not there?
23:13:36 <lispy> bringert: boo!
23:13:40 <lispy> bringert: what do they have?
23:13:42 <dons> not yet, i'm still building the compiler
23:13:49 <bringert> I don't know
23:13:54 <Heffalump> so how did you guys make the UM? Write a compiler from your language of choice?
23:14:03 <lispy> bringert: lambdabot would be terribly slow with out the fcgi hacks we're using
23:14:20 <lispy> Heffalump: they implemented it twice in twelf
23:14:24 <lispy> Heffalump: one in post script
23:14:41 <lispy> Heffalump: and a few other odd ball langugaes, one even ran on a nokia phone
23:14:47 <Heffalump> sorry, I mean the codex.
23:14:52 <Heffalump> i.e UMIX
23:15:01 <lispy> oh, for that they modified an SML compiler
23:15:09 <lispy> to generate UM instructions
23:15:18 <Heffalump> right
23:15:28 <lispy> other than that i'm not too sure on details
23:15:40 <lispy> it's hard to remember now :)
23:15:52 <lispy> they did have so interesting 'junk' embedded in the codex
23:16:11 <lispy> and they encrypted the strings and compressed it all in self-hosted code
23:16:19 <lispy> that was all after the binary was generated
23:16:25 <lispy> which is interesting
23:16:59 <lispy> and they had special 'garbage' instructions so that if you incorrectly implemented endianness you'd get an error on start up along the lines of "ENDIAN"
23:17:34 <Heffalump> right, we ran into a few errors like that
23:18:02 <lispy> pretty clever of them
23:18:34 <lispy> Heffalump: we met with david and talked about patch theory a lot
23:18:45 <Heffalump> cool
23:18:50 <Heffalump> are you on #darcs?
23:18:51 <lispy> Heffalump: kowey was trying to take notes...but i'm not sure how much of it he got
23:18:55 <lispy> yeah
23:22:34 <glguy> dons: /me &
23:22:39 <glguy> err
23:22:40 * glguy &
23:23:19 <bringert> lispy: should I take the goa repo and remove everything but the lambdaweb stuff? or is there some other way to get the history over?
23:23:24 <zarvok> err, my internet connection died, so heffalump, if you asked something I didn't answer, feel free to try again
23:23:51 <Heffalump> lispy answered the other stuff (which was about how you implemented UMIX), thanks
23:23:58 <zarvok> no problem
23:24:08 <zarvok> the full scoreboard should go online within minutes
23:24:18 <Korollary> ole
23:24:30 <lispy> bringert: i'm not sure
23:24:36 <lispy> bringert: but...i was thinking
23:24:42 <lispy> bringert: how valuable is that history?
23:24:54 <lispy> bringert: maybe just start a new repo and say "bye bye" to the history
23:24:57 <bringert> not at all
23:25:02 <bringert> fine by me
23:25:09 <lispy> awesome
23:26:12 * macron is back (gone for 00:54.12)
23:26:12 * macron is back
23:26:36 * lispy goes to sleep
23:27:42 <zarvok> heffalump (and others): someone (malcomw I think?) videotaped the talk and it will be online tomorrow
23:28:04 <zarvok> also a techrepor will be posted
23:28:30 <roconnor> @seen ibid
23:28:31 <lambdabot> ibid is in #haskell. I last heard ibid speak 1d 19h 56m 46s ago.
23:28:33 <zarvok> and now I too am going to sleep
23:28:38 <Heffalump> night night
23:29:24 <dibblego> dons, I'll tidy up the XHTML on haskell.org if you like
23:30:05 <dibblego> when I get a chance that is
23:30:16 <dibblego> just get it to validate against W3C
23:31:01 <dibblego> who owns haskell.org?
23:31:28 <mnislaih> dons: do you know if hs-plugins will work with ghc 6.6 ?
23:31:40 <mnislaih> I'm running into issues with AltData.Typeable
23:32:15 <bringert> lispy: http://darcs.haskell.org/lambdaweb/
23:32:17 <lambdabot> Title: Index of /lambdaweb
23:32:23 <dons> it doesn't yet, no.
23:32:25 <dons> it won't be hard to port though.
23:32:31 <dons> dibblego: the community
23:32:48 <dibblego> dons, can you apply for commit access to the website only?
23:32:59 <dibblego> I assume it's darcs (I have never used it)
23:33:18 <dons> no, its a wiki
23:33:41 <dibblego> gah of course
23:35:35 <dibblego> well I'll drop my $0.02 on it if whoever cares wants me to - websites that have a little green validation tick in my firefox status bar are more credible
23:36:02 <dons> ok, i've simplified the 5 step program.
23:36:03 <dons> http://haskell.org/haskellwiki/Haskell_in_5_steps
23:36:07 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/gdrmd
23:36:19 <dons> Lemmih, Cale, et al, comments would be appreciated.
23:36:39 <dons> There were, I think, just too many qualifications and distractions in the old list of steps
23:37:07 <dibblego> that's good how it is
23:37:12 <mwc> hmm, so, do we know who won the ICFP?
23:37:25 <dons> dibblego: how it is now, after my changes?
23:37:31 <dons> mwc, google won :)
23:37:42 <dibblego> I didn't see it before, but it looks very good for a noobie
23:37:47 <mwc> so... python?!
23:37:48 <dons> ok :)
23:42:20 <roconnor> dons: I think there are too many commas in the Hello World program.
23:42:51 <roconnor> oh
23:42:55 <dons> you mean "Hello, World!" shouldn't have a comma?
23:43:07 <roconnor> That's what I would think, but I see that I am wrong
23:43:14 <roconnor> @wikipedia Hello World
23:43:16 <lambdabot> No Result Found.
23:43:23 <roconnor> @wikipedia Hello World program
23:43:23 <dons> (borked)
23:43:25 <lambdabot> No Result Found.
23:43:31 <dons> ?google site:wikipedia Hello World
23:43:34 <lambdabot> http://en.wikipedia.org/wiki/Hello_world_program
23:44:09 <roconnor> I need to go fix all my hello world programs now.
23:44:33 <russo> hello world sounds ultra geeky nowadays doesnt it
23:44:56 <dons> didn't it always?
23:45:16 <dons> roconnor: what did you think about adding your blog to planet.haskell.org? or at least the haskellish stuff?
23:45:20 <russo> nah the first instances of it sounded cool
23:45:24 <russo> then it went down
23:45:29 <russo> up again
23:45:35 <russo> only to turn geeky in 1995
23:45:55 <roconnor> dons: I was wondering if it is possible to filter my rss feed for <content>haskell</content>
23:46:14 <roconnor> otoh, it seems that non-haskell related posts are common
23:46:28 <Heffalump> can your blog tag posts?
23:46:28 <dons> yeah, anything is really ok, I think
23:46:42 <dons> certainly any programming language stuff, or internet-ish issues
23:46:59 <dons> roconnor: yeah, perhaps look at the other livejournal feeds we have? maybe they tag posts?
23:47:18 <russo> i was lazy and made my blog on iWeb
23:47:20 <russo> :D
23:47:38 <dons> roconnor: such as http://kpreid.livejournal.com/
23:47:43 <dons> which does seem to have tags
23:48:38 <Heffalump> is <category> something an aggregator can understand and filter on?
23:48:57 <Pseudonym> Heffalump: Only up to isomorphism.
23:49:03 <dons> not sure. but many blog generators seem to be able to produce rss feeds for subcategories
23:49:08 <dons> or particular tags
23:49:10 <russo> dons: i'm testing gltoy right now
23:49:20 <roconnor> dons: I know how to tag my posts, the question is how to provide planet haskell with only the haskell posts.
23:49:27 <dons> ah ok.
23:50:12 <russo> dons: "You cannot run GLToy on this computer. Contact the developer for a newer version"
23:50:44 <russo> heres the exact wording: You cannot use the screen saver GLToy on this computer. Contact the developer of this software for a newer version.
23:50:54 <dons> roconnor, does something like this work http://kpreid.livejournal.com/data/rss#haskell
23:50:58 <lambdabot> http://tinyurl.com/je43f
23:51:21 <roconnor> dons: nope.  I've tried varients of that.
23:51:27 <dons> russo: why are you telling me this? it's a nice warning, I agree.
23:51:37 <russo> it was on your blog
23:51:43 <dons> mine?
23:51:50 <dons> you mean on planet haskell?
23:52:35 <dons> (the haskell community's blog aggregator, to which I post sometimes, but not my blog :)
23:52:44 <russo> i dunno nvm :D i'll stop talking :D
23:52:49 <dons> heh
23:53:03 <dons> it's Syzygy- who's into the gl stuff
23:53:58 <roconnor> http://max.kanat.us/tag-syndicate/manual.php
23:54:00 <lambdabot> Title: LiveJournal Tag RSS Syndication
23:54:06 <mnislaih> FYI dons, Typeable.h has been cut down in 6.6. It doesn't include INSTANCE_TYPEABLEi where i>0
23:54:11 <roconnor> thus: http://max.kanat.us/tag-syndicate/?user=r6&tag=haskell
23:54:17 <lambdabot> http://tinyurl.com/q6w6h
23:54:23 <mnislaih> that's the 1st obstacle in making  hs-plugins with 6.6
23:54:23 <dons> urgh "In 2006, Ruby achieved mass acceptance"
23:54:37 <dons> mnislaih: yeah, you need 2 things:
23:54:49 <dons> a) a ghc 6.6 from mid July or older
23:54:54 <dons> and a 6.4.2 install
23:55:02 <mnislaih> that's hard, I'm on Mac Intel
23:55:09 <dons> with that you can use the typeable.h header from the 6.4.2 install and everything works
23:55:21 <dons> if you need a newer ghc, then we need some other things fixed first
23:55:32 <mnislaih> ah, if the header is all I need from 6.4.2
23:55:33 <dons> since the package system format changed, and also Typeable has been fixed,
23:55:41 <dons> not if you have a very recent ghc
23:55:53 <dons> it also has a change in .hi files which break hs-plugins
23:56:00 <mnislaih> ouch
23:56:16 <dons> it's fixible, but not trivial. the .hi file parser has to be modified in hs-plugins
23:56:40 <mnislaih>  nevermind. I was trying to get the dynamic loader in HSP to run but I'll go with CGI
23:57:14 <mnislaih> also, it's 9 AM. Time to leave to the uni!
23:57:18 <dons> ok. hopefully i'll get a chance to fix hs-plugins soon.
23:58:15 <mnislaih> dons btw, you and duncan will be receiving one crappy review from PADL (unless my sup fixes it!)
23:58:41 <Heffalump> as in badly written, or negative?
23:58:50 <mnislaih> ah no, just badly written
23:58:55 <dons> ah ok
23:59:08 <dons> don't scare me like that!
23:59:10 <dons> ;)
23:59:20 <mnislaih> it's not negative at all :'o !
23:59:22 <Heffalump> you're not generally supposed to tell people you're reviewing their papers, you know :-)
23:59:35 <dons> *cough* yeah, mnislaih ;)
23:59:50 * dons hears nothing, sees nothing, knows nothing
