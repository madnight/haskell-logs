00:00:21 <glguy> fromMaybe seems like a funny function to me, since all it is is "maybe id", but uses more characters than maybe id does
00:01:39 <dolio> ?type fromMaybe
00:01:40 <lambdabot> forall a. a -> Maybe a -> a
00:01:52 <glguy> ?type maybe id
00:01:53 <lambdabot> forall a a1. (a1 -> a -> a) -> Maybe a1 -> a -> a
00:02:14 <glguy> oh
00:02:18 <glguy> I guess it would be
00:02:23 <glguy> ?type flip maybe id
00:02:23 <glguy> ?
00:02:24 <lambdabot> forall a. a -> Maybe a -> a
00:02:24 <dolio> > maybe 5
00:02:24 <lambdabot>  Add a type signature
00:02:47 <glguy> > maybe 5 id (Just 1)
00:02:48 <lambdabot>  1
00:02:51 <glguy> > maybe 5 id Nothing
00:02:52 <lambdabot>  5
00:03:03 <glguy> > fromMaybe 5 Nothing
00:03:04 <lambdabot>  5
00:03:09 <glguy> > fromMaybe 5 (Just 1)
00:03:10 <lambdabot>  1
00:06:19 <lispy> hm...where is popen?
00:06:22 <lispy> ?hoogle popen
00:06:23 <lambdabot> No matches found
00:06:28 <glguy> ?index popen -- ?
00:06:29 <lambdabot> bzzt
00:06:31 <xerox> ?docs System.Process
00:06:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
00:06:32 <glguy> heh
00:08:00 <lispy> is it missing?
00:08:56 <dons> lispy: in Lib/Process.hs in lambdabot
00:09:50 <lispy> dons: thanks
00:09:53 <lispy> i'll try to use that
00:11:48 <lispy> dons: oh hm...you close the connection?
00:11:58 <lispy> i want to leave it open...so i'll need to modify this
00:12:18 <lispy> so maybe i just need runInteractiveProcess
00:13:09 <lispy> either way, showing me that module was perfect
00:14:17 <dons> yep, just tweak it to stay open
00:14:49 * dons has a darcs repo 452M big
00:14:57 <dons> go, darcs, go!
00:14:58 <lispy> nice
00:15:11 <xerox> You write too much code? :)
00:15:14 <lispy> you might need one of my recent patches if you ever run 'darcs w -l'
00:15:15 <dons> (the entire irc logs of #haskell, tagged and recorded daily)
00:15:20 <xerox> Ah-ha.
00:15:21 <lispy> hehe
00:15:22 <lispy> nice
00:15:24 <xerox> WE write too much.
00:15:33 * lispy blames xerox 
00:15:37 <dons> $ darcs get --partial /home/dons/haskell
00:15:37 <dons> Copying patch 1 of 1... done!
00:15:41 <xerox> Oh well.
00:15:42 * dons waits to apply
00:15:55 <dons> not too bad,  2754 dons      25   0  719m 714m 3144 R 99.7 70.9   1:52.85 darcs.real
00:16:01 <xerox> Rrrrrrr.
00:17:31 <dons> here, if anyone feels like stress testing darcs :) http://www.cse.unsw.edu.au/~dons/code/%23haskell/
00:17:33 <lambdabot> Title: Index of /~dons/code/#haskell, http://tinyurl.com/j97t7
00:17:48 <dons> or their bandwidth
00:18:16 <xerox> You'll be darcsrecording every day now?
00:18:33 <dons> yeah, it pulls down each days log, records and tags it
00:18:42 <dons> then my scripts compute the statistics
00:19:03 <glguy> welp... I can't "haskell golf" with my code any longer. 40 non-whitespace lines is the minimum before I start hurting readability
00:19:09 <glguy> so that means it's bed time
00:19:12 <glguy> goodnight all
00:21:50 <dons> Finished getting.
00:21:54 <dons> well done darcs
00:21:59 <xerox> darcs++
00:23:15 <profmakx> @karma darcs
00:23:15 <lambdabot> darcs has a karma of 6
00:23:27 <profmakx> much too low though
00:24:09 <emu> > maximum [1..10^6]
00:24:11 <lambdabot>  Exception: stack overflow
00:24:18 <emu> huh
00:24:33 <profmakx> you broke it!
00:24:36 <dons> I think that's a foldr buglet
00:24:41 <dons> fixed in more recent ghcs
00:24:52 <dons> > foldl' max [1..10^6::Int]
00:24:53 <lambdabot>  <[[Int]] -> [Int]>
00:24:56 <emu> ok
00:25:10 <dons> > foldl' max 0 [1..10^6::Int]
00:25:11 <lambdabot>  1000000
00:25:24 <dons> > foldl' max 0 [1..10^6]
00:25:25 <lambdabot>  1000000
00:25:32 <dons> > foldl' max 0 [1..10^10]
00:25:35 <lambdabot> Terminated
00:25:41 <dons> > foldl' max 0 [1..10^9]
00:25:44 <lambdabot> Terminated
00:25:45 <emu> it was puzzling me so i had written my own version
00:25:49 <dons> > foldl' max 0 [1..10^8]
00:25:52 <lambdabot> Terminated
00:25:56 <dons> > foldl' max 0 [1..10^7]
00:25:58 <lambdabot>  10000000
00:26:06 <dolio> > foldl max 0 [1..10^6]
00:26:08 <lambdabot>  Exception: stack overflow
00:26:25 <dons> I think lazy accumulators are a bug in fold
00:26:43 <dolio> Are there situations they're useful?
00:26:51 <dons> i've not found one yet.
00:26:58 <profmakx> dumb question: whats the difference between foldl and foldl'?
00:27:09 <bourbaki> moin
00:27:20 <profmakx> moin bourbaki
00:27:24 <dons> one is strict in the accumulator, so it is always evaluated to normal form before proceeding to the next element of the list
00:27:28 <sieni> plu
00:27:38 <profmakx> ah
00:27:38 <dons> foldl' f a []     = a
00:27:38 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:27:56 <profmakx> yös  now i remember...
00:28:04 <profmakx> i surely should code more haskell soon
00:28:06 <dons> foldl f z xs = lgo z xs
00:28:06 <dons>          where
00:28:06 <dons>         lgo z []     =  z
00:28:07 <dons>         lgo z (x:xs) = lgo (f z x) xs
00:28:17 <emu> admittedly i'm not a fan of the ' convention used there
00:28:21 <dolio> sum [1..10^6]
00:28:25 <dolio> > sum [1..10^6]
00:28:27 <lambdabot>  Exception: stack overflow
00:28:34 <dons> that's fixed in 6.6 as well.
00:28:40 <dons> it was a break in the build/foldr fusion system
00:28:41 <profmakx> hm, should be expected ;)
00:28:52 <dons> meaning many things were rewritten to not-so-nice lazy folds, iirc
00:28:58 <emu> nah it should print out a really large number=)
00:28:59 <dolio> Ah.
00:29:02 <dons> i should install 6.6 on that box at some point
00:29:16 <dolio> foldl' (+) 0 [1..10^6]
00:29:19 <emu> 6.6 is set to be released at the end of the month?
00:29:19 <profmakx> i meant if the max op fails then sum should fail too
00:29:20 <dolio> > foldl' (+) 0 [1..10^6]
00:29:22 <lambdabot>  500000500000
00:29:25 <profmakx> for some values of fail
00:31:22 <dons> emu, roughly, yep
00:37:16 <lispy> ?hoogle catch
00:37:16 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
00:37:16 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
00:37:16 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
00:37:50 <dons> use Control.Exception.catch
00:37:59 <lispy> :)
00:40:45 <lispy> dons: i tihnk...it's gonna work, but my cgi cannot see outside of it's web directory so it can't find the lambdabot binary
00:41:04 <dons> right. so you might want to stick it in cgi-bin ?
00:41:21 <dons> or some kind of chroot?
00:42:00 <lispy> for now, i just want to see it work...not sure what i'll do for long term
00:42:13 <dons> sure, ok.
00:42:33 <lispy> http://lambdabot.codersbase.com/bot.fcgi
00:42:34 <lispy> cool
00:42:39 <lispy> it is a permission problem
00:42:56 <lispy> i just catch the exception and then print it with 'runOneFastCGI' and quit
00:43:16 <lispy> oh, i wonder if my apache processo can't actually execute the binary
00:45:29 <lispy> oh
00:45:37 <lispy> this will have problems interacting with lambdabot
00:45:44 <lispy> i use hGetContents
00:46:06 <dons> oh, you'll want hGetLine, no?
00:46:14 <lispy> good idea
00:47:00 <lispy> closer
00:47:12 <lispy> i probably want to read until lambdabot>
00:47:17 <lispy> but that's another day
00:48:06 <lispy> ah yeah and now this time it's waiting for output taht will probably never happen
00:54:38 <lispy> bringert: i just started using your fastcgi library.  Pretty cool!
00:55:03 <lispy> bringert: trying to write a wrapper for lambdabot http://lambdabot.codersbase.com/bot.fcgi
00:55:19 <lispy> bringert: but...it's broken and i'm going to sleep for now...anyway, thanks for the fast cgi lib
00:56:18 <wkh> er
00:56:24 <wkh> using a pure functional language for web programming?
00:56:26 <wkh> actual input handling and stuff
00:56:32 <wkh> web rpgoramming is inherently stateful
00:57:04 <profmakx> Q: why do we do it?
00:57:09 <profmakx> A: Because we can!
00:57:10 <profmakx> -.-
00:57:27 <bringert> lispy: cool, good luck!
00:57:36 <bringert> lispy: let me know if you have any questions
00:58:02 <wkh> did you guys see all the drama about joel spolsky and ruby/rails?
00:58:04 <xerox> wkh: check out happs :)
00:58:09 <dons> wkh: monads dude :)
00:58:11 <lispy> bringert: okay, right now i'm trying to figure out how to reliably talk to the lambdabot shell without endind up with one process blocked on the other
00:58:24 <lispy> monads got your back!
00:58:29 <dons> global state is just another pure value :)
00:58:44 <lispy> ?remember dons global state is just another pure value :)
00:58:45 <wkh> i think the idea of creating a language to create your product in isn't such a bad idea and haskell seems great for that
00:58:51 <wkh> language-oriented engineering
00:58:53 <xerox> Don't catch me in a monad discussion! I've got to study!
00:59:07 <xerox> s/catch/bind/
00:59:07 <xerox> @arr
00:59:08 <lambdabot> Avast!
00:59:57 <lispy> ?yar
00:59:57 <lambdabot> Arrr!
01:01:27 <wkh> q: what does a pirate use to archive his data
01:01:29 <wkh> a: tarrrrrrrr
01:01:37 <xerox> haha
01:02:00 <lispy> dons: i think ultimately i'll stick a lambdabot install inside the a web accesible directory and then just use .htaccess to make everything but bot.fcgi forbidden to webbrowsers
01:02:31 <lispy> well, assuming that's possible :)
01:03:29 <dons> lispy: that sounds ok. i'd consider disabling most plugins, and just enabling and testing ones individually
01:03:40 <dons> starting with simple things
01:03:48 <dons> (you disable them by tweaking Modules.hs)
01:04:01 <wkh> what do you guys think of the idea of using continuations to create the illusion of stateful web programming, a la seaside
01:04:13 <dons> that's what WASH does, isn't it?
01:04:17 <wkh> no clue
01:04:18 <wkh> does it?
01:04:31 <dons> contnuations are widely used in haskell web stuff, I think.
01:04:33 <dons> let me find a ref.
01:04:39 <wkh> haskell is way the hell faster than smalltalk, that's for sure
01:05:17 <dons> heh
01:06:27 <wkh> smalltalk is OO done right, but it's very much a take it or leave it, all or nothing situation because of the fact that it runs in an image and you work with non-standard tools and non-standard widgets
01:07:04 <xerox> dons: if you grep bringert and http in the last days you'll find a pdf he mentioned to shapr that talks exactly about this
01:08:37 <dolio> It's funny that "OO done right" was invented decades ago, but none of the OO languages in widespread use today really come close.
01:08:49 <dolio> Then again, I suppose you can say the same thing about Lisp.
01:09:09 <wkh> right. ruby gets part of it, but the developmetn tools are nowhere close
01:09:52 <bringert> xerox, dons: http://csmisc14.cs.chalmers.se/haskellwebapps/dokument/slutrapport.pdf
01:09:53 <lispy> dons: well, as far as security goes i'm not too worry about lambdabot on the web compared to on irc.  But perhaps to get the blocking issues worked out that would be best
01:09:55 <lambdabot> http://tinyurl.com/hzb58
01:10:01 <xerox> That! wkh.
01:10:15 <bringert> and "slut" means "end" or "final" in Swedish, nothing else
01:10:24 <lispy> heh, ah
01:10:25 <sieni> slut report
01:10:26 <wkh> hokai!
01:10:30 <wkh> yeah i saw that too
01:10:36 <dons> bringert: ah that's it. I was scared to paste that url
01:10:40 <dons> not sure what was contained
01:10:48 <xerox> haha
01:11:18 <sieni> please report any sluts in and around Helsinki to me
01:11:23 <bringert> have you seen the IKEA office chair called "BESLUT"
01:11:34 * lispy once ran a full lisp repl on the telnet port without a single problem :)
01:11:54 <lispy> bringert: hehe, nice
01:12:09 <bringert> germans might appreciate the bed called "GUTVIK"
01:12:21 <profmakx> o.o
01:12:39 <bringert> http://www.recommendedbuys.co.uk/home-garden/beds/ikea-gutvik-bunk-bed.htm
01:12:41 <lambdabot> Title: Recommended Buys UK: IKEA Gutvik Bunk Bed reviews & best buys: IKEA Gutvik Bunk  ..., http://tinyurl.com/m4nvn
01:15:51 <bringert> lispy: Lemmih has reported that multi-threaded fastcgi works on lighttpd. which means that you could have only one process that serves all requests, with lambdabot compiled in
01:16:04 <dons> a challenge. i've a friend looking for: adjustM :: Monad m => (a -> m a) -> k -> Map k a -> m (Map k a)
01:16:10 <dons> to be created with just:
01:16:14 <dons> ?type Data.Map.adjust
01:16:15 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
01:16:20 <dons> and monad combinators
01:16:41 <lispy> bringert: hm...
01:16:53 <lispy> bringert: so forkIO with fastcgi and apache is bad?
01:17:07 <bringert> yes
01:17:32 <lispy> bringert: right now my fastcgi script just does the haskell equivalanet of popen on lambdabot
01:17:46 <lispy> okay, i'll look into removing the forkIOs
01:17:59 <bringert> lispy: Apache's mod_fastcgi doesn't seem to support concurrent requests to the same fastcgi proces
01:18:11 <lispy> i think i have to use apache...i can't stop using it for other stuff and i don't know how i'd get just this onet hing to be lightttp
01:18:38 <bringert> lispy: well, forkIO in itself is ok, just don't try to accept a new request before the old one is done
01:18:40 <lispy> (and i'd rather not use strange ports)
01:18:45 <lispy> heh
01:18:57 <lispy> how would i know?
01:18:59 <bringert> instead have apache start new fastcgi process dynamically
01:19:18 <lispy> ya know, i probalby don't even need the forkIO
01:19:22 <bringert> lispy: right
01:20:03 <lispy> but right now i really need my sleep
01:20:07 <lispy> thanks for the help
01:20:09 <bringert> lispy: you can run lightttpd on a strange port, and use mod_rewrite to forward requests there without the client ever knowing it
01:20:10 <lispy> good night!
01:20:13 <bringert> good night
01:20:22 <lispy> (i'll think about that)
01:39:07 <nothingmuch> hi dons
01:39:16 <nothingmuch> my modem reconnected on it's own
01:48:50 <inv2004> hi all
01:49:00 <inv2004> how to get list random Int ?
01:49:08 <inv2004> or just random Int
01:49:27 <defcon8> haskell doesn't seem to support imagemagick. is there an equivalent?
01:50:02 <inv2004> lambdabot: random
01:50:15 <boegel> defcon8: I recall shapr using something for his FLM project..
01:50:18 <integral> @hoogle randomIO
01:50:18 <lambdabot> Random.randomIO :: Random a => IO a
01:51:22 <boegel> defcon8: although I don't remember what
01:54:34 <psi> how does a language "support" imagemagick. isn't it just an executable?
01:54:46 <Syzygy-> psi: IIRC, it's a library as well.
01:55:15 <inv2004> lambdabot: Random.random
01:55:37 <Syzygy-> It has APIs to C, Ch, C++, Java, Lisp, Pascal, Perl, PHP, Python, Ruby and TCL according to imagemagick.org
01:56:08 <dblhelix> so, rephrase: no one has made an imagemagick api available for haskell?
01:56:20 <Syzygy-> But with the FFIs in haskell, you should be able to just import for instance the C or Lisp bindings?
01:56:35 <flux__> syzygy-, I might add ocaml to that list :)
01:56:55 <Syzygy-> flux__: May well be - it isn't listed on the imagemagick webpage, and I didn't bother looking further than that.
01:56:55 <psi> I assume it's a C library, so it shouldn't be too difficult
01:57:09 <Syzygy-> psi: Two or three of the existing language bindings are C.
01:57:27 <dblhelix> Syzygy-, flux__ : well, "just"... not sure about that... but, well, it's possible
01:58:02 <Syzygy-> dblhelix: Last time I looked at all at the FFIs, they seemed very neat and transparent to use.
02:00:13 <defcon8> boegel, :|
02:01:30 * defcon8 doesn't know about FFI's
02:03:03 <dons> ?tell lispy I forgot - you should look a GOA for a working popen binding to lambdabot (as used from ghci)
02:03:03 <lambdabot> Consider it noted.
02:35:20 <defcon8> is : like cons in cl?
02:35:44 <wkh> god the pickaxe book fucking sucks
02:35:56 <wkh> and yes : is like cons
02:36:01 <wkh> > 1:2
02:36:02 <lambdabot>  add an instance declaration for (Num [a])
02:36:07 <wkh> > 1:[2]
02:36:08 <lambdabot>  [1,2]
02:36:11 <wkh> there.
02:36:16 <defcon8> then why doesn't 5:6 work?
02:36:32 <wkh> i don't know, i'm new to this. 6 isn't a list
02:36:37 <wkh> [6] is
02:37:05 <wkh> ?hoogle :
02:37:06 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':'
02:37:06 <psi> ?t (:)
02:37:06 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:37:16 <psi> ?type (:)
02:37:17 <lambdabot> forall a. a -> [a] -> [a]
02:37:27 <defcon8> but in cl you can do (cons 5 6)
02:37:42 <wkh> haskell is more pedantic and less sloppy
02:37:48 <defcon8> sloppy? :O
02:37:49 <psi> : constructs lists
02:38:13 <psi> I suppose it's not exactly like cons in lisp
02:38:57 <araujo> morning!
02:39:07 <gds> > 1:2:[]
02:39:09 <lambdabot>  [1,2]
02:39:12 <psi> morning
02:41:19 <wkh> oh no, ruby has dirty perl shit!
02:41:25 <wkh> $_
02:41:29 <wkh> can you believe that, that someone woudl do that
02:41:37 <wkh> a crime against humanity
02:52:25 <Templar> today I heard there is a program whos easy to make dessigning and haskell to work together. Anyone knows what that program was called?
02:53:15 <wkh> in this channel?
02:53:17 <Templar> a program you for exampel can make buttons in and make the work with an function
02:53:19 <wkh> you could look through the loops
02:53:24 <wkh> er
02:53:25 <wkh> logs
02:53:34 <Lemmih> glade?
02:54:28 <Templar> Glade looks to be it! Thank you.
02:57:37 <kfish> glade rules, glade + gtk2hs rules even more
02:58:02 <kfish> duh
02:58:10 <kfish> glade rules, glade + gtk2hs + cairo rules even more
02:58:17 * dcoutts__ grins
03:00:46 <Templar>  gtk2hs + cairo =?
03:01:01 <Templar>  gtk2hs = .hs I guess
03:01:08 <dcoutts__> Templar: cairo bindings are included in gtk2hs
03:01:13 <Templar> aha, ok
03:01:21 <dcoutts__> and allow you to draw nice vector graphics
03:01:40 <Templar> a, it sounds REALLY cool
03:01:47 <dcoutts__> it is :-)
03:02:02 <Templar> do you know if it got Windows support?
03:02:08 <Templar> or just Linux..
03:02:16 <dcoutts__> yep, win32 too
03:02:19 <Templar> nice
03:02:24 <dcoutts__> including glade and cairo
03:02:33 <dcoutts__> and osx
03:02:37 <Templar> =D
03:02:44 <dcoutts__> and Solaris & *BSD
03:02:45 <dcoutts__> etc
03:03:29 <Templar> :P . Got windows now but will soon fix Linux. Easyer like that
03:06:25 <defcon8> mult x 0 = 0
03:06:25 <defcon8> mult x y = x + (y-1)
03:06:28 <defcon8> what is wrong with that?
03:06:32 <defcon8> oh
03:06:33 <defcon8> I know
03:06:51 <Templar> why is it wrong? ^^
03:07:10 <defcon8> mult x 0 = 0
03:07:10 <defcon8> mult x y = x + mult (y-1)
03:07:14 <defcon8> why isn't that working?
03:07:47 <defcon8> says cannot construct the infinite type a -> t
03:08:01 <norpan> because mult takes two arguments
03:08:04 <pejo> defcon, you forgot the second argument to mult
03:08:07 <Cale> defcon8: you're only passing (y-1) to mult
03:08:11 <defcon8> yeah, sorry
03:09:08 <Templar> defcon8: swe/CS/GU? ^^
03:09:57 <defcon8> I don't go to uni, yet
03:10:11 * defcon8 blames that absurd mistake on his cereals he ate this morning
03:10:30 <Templar> aha, okok, just woundered becous our class started with exacty the same problem today, or very similar :P
03:10:50 <defcon8> nice one
03:10:57 <defcon8> your first year?
03:11:09 <Templar> yea, second week
03:11:27 <defcon8> I could start uni next year, when I'm 17, but I think I'll do the extra certs so I can jump in at the second year when I'm 18
03:11:27 <Templar> really rules
03:11:34 <defcon8> you doing CS?
03:12:03 <Templar> I´m going at GU
03:12:34 <Templar> if thats what you mean ^^
03:12:37 <defcon8> what is that?
03:12:53 <Templar> university :P
03:13:07 <Templar> But I dont work with "CS" no
03:40:44 <cognominal> I am reading a paper about type theory. What is a "ground type"?
03:50:23 <dblhelix> cognominal: presumably, a base type such as int or char is meant
03:52:41 <dblhelix> cognominal: what paper are you reading?
03:52:43 <cognominal> indeed,  ground type is an object type with no variable says an entry found by google (buried into pokemon crap)
03:53:26 <cognominal> Gradual Typing for Functional Languages
03:54:44 <cognominal> I read the Pierce Book a year ago so I am far from fluent in type theory
03:55:02 <cognominal> too bad, it is so interesting
04:09:50 <dcoutts__> dons: any word on hs-plugins 1.0 ?
04:10:34 <dcoutts__> the 1.0-rc0 builds ok with ghc-6.6
04:10:40 <dcoutts__> not sure if it works...
04:11:59 <musasabi> dcoutts__: you wouldn't have some extra time to look at those c2hs patches? The "*-" is more urgent as I'd like to release code depending on that soonish.
04:12:18 <dcoutts__> musasabi: the fixes for 6.6 you mean?
04:12:28 <dcoutts__> or the other one
04:14:17 <musasabi> the other one (which introduces support for a new type of marshallers)
04:14:47 <fasta> My program gives different answers when run with ghc-6.5 when compared to ghc-6.4.2....
04:15:29 <dcoutts__> musasabi: I'd like to have ChilliX's ok on that one
04:15:51 <musasabi> I'll ask him.
04:16:13 <dcoutts__> musasabi: I'll do the ghc-6.6 one
04:16:51 <dons> dcoutts__: won't work with 6.6 yet.
04:17:09 <dcoutts__> dons: ok, ping me when there's a tarball to test
04:17:22 <musasabi> ok
04:17:44 <gds> fasta: What libs do you use?
04:18:03 <fasta> gds: go to #ghc
04:18:54 <gds> Oh good - they're far more likely to be able to usefully help than I :)
04:43:41 <lisppaste2> Templar pasted "average of Int -> Int -> Int -> Float" at http://paste.lisp.org/display/25879
04:44:04 <Templar> any ideas? =/
04:44:22 <pjd> hi; has anyone written a metacircular interpreter/evaluator for haskell?
04:44:52 <dons> don't think so, sounds fun though!
04:45:25 <dons> Templar: you're using /
04:45:28 <dons> ?type (/)
04:45:29 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:45:36 <dons> but I presume you want `div` ?
04:45:37 <dons> ?type div
04:45:39 <lambdabot> forall a. (Integral a) => a -> a -> a
04:45:47 <pjd> not even Template Haskell?
04:45:56 <dons> ?let averageThree a b c = (a+b+c) `div` 3
04:45:56 <Templar> dons: aha! yea, thanks
04:45:57 <lambdabot> Defined.
04:46:09 <dons> > L.averageThree 7 8 9
04:46:10 <lambdabot>  8
04:46:16 <dons> > L.averageThree 7 8 10
04:46:17 <lambdabot>  8
04:46:39 <dons> pjd, I've not heard of one. its an interesting question: perhaps ask on haskell-cafe@haskell.org ?
04:47:23 <dons> Templar: you might also consider trying ghc/ghci (then you'll be able to compile your haskell programs)
04:48:17 <Templar> you mean change from hugs to ghc?
04:48:33 <dons> only if you want to.
04:48:43 <Templar> whats the diffrens? ^^
04:48:44 <dons> it's just nice to be able to produce fast binaries :)
04:49:09 <dons> oh, you can compile to executables, and there's a number of newer language extensions not supported by hugs (you may not need those for a while though)
04:49:24 <dons> also, you can define new functions at the prompt
04:49:34 <dons> using 'let', as i did above
04:49:41 <Templar> sounds good =)
04:49:47 <dons> ?where ghc
04:49:47 <lambdabot> http://haskell.org/ghc
04:50:55 <Templar> think I already have it. Tried to convert .hs to .exe yesterday but did not when very whell. My code had aparently nothing to execute or something like that ^^
04:51:38 <Templar> a bit nicer with black background I mist say :P
04:51:43 <Templar> *must
04:51:50 <dons> missing 'main' function perhaps?
04:52:05 <dons> you need a module Main with the function 'main' defined in it, to get an executable
04:52:54 <dons> also, feel free to play with the lambdabot. she has lots of useful skills.
04:53:01 <dons> > map (^2) [1..10]
04:53:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
04:53:02 <Templar> yea, added that but ppl here said that I dident have something who could be excecuted(had only an forumla who changed Celcius to Fahrenhight) :)
04:53:26 <dons> right. so you'd need to wrap that up with a main function that reads some input, converts it, and prints it out
04:53:26 <Templar> hehe :D
04:53:43 <dons> one possibility would be: main = interact (show . convert . read)
04:54:02 <dons> would probably be enough. this would read lines from standard input, convert them, and print the out.
04:54:08 <dons> ?type map
04:54:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:54:11 <Templar> aha
04:54:18 <dons> ?hoogle (a -> b) -> [a] -> [b]
04:54:18 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
04:54:18 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:54:18 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
04:54:28 <dons> ?docs Data.List
04:54:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
04:54:37 <dons> ?fptools Data.List
04:54:38 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
04:55:17 <dons> ?check \s -> map (^2) s == map (\x -> x*x) (s :: [Int])
04:55:18 <lambdabot>  OK, passed 500 tests.
04:55:23 <dons> :)
04:55:34 <Templar> :P
04:55:47 <Templar> here it is, I had only add this line:       main :: IO ()
04:55:55 <mux> ooh, integrated QuickCHeck tests
04:56:00 <dons> mux, yup :)
04:56:09 <dons> Templar: so you already had a: main = ... ?
04:56:24 <mux> ?check \x -> reverse (reverse x) == x (x:: String]
04:56:25 <lambdabot>  Parse error
04:56:26 <mux> oops
04:56:30 <Templar> no... Thats the only main..
04:56:30 <mux> ?check \x -> reverse (reverse x) == x (x :: String)
04:56:31 <lambdabot>    The function `x' is applied to one arguments,     but its type `t_a1Oj' ...
04:56:58 <dons> ?check \s -> reverse (reverse s) == (x :: T)
04:56:58 <lambdabot>  Not in scope: `x'
04:57:04 <mux> mmm
04:57:06 <dons> ?check \s -> reverse (reverse s) == (s :: T) -- silly me
04:57:07 <lambdabot>  OK, passed 500 tests.
04:57:13 <mux> T ?
04:57:16 <dons> type T = [Int], just for fun.
04:57:18 <mux> parametric checking?
04:57:21 <mux> oh.
04:57:52 <mux> ?check \x -> reverse (reverse x) == x (x :: [Char])
04:57:52 <lambdabot>    The function `x' is applied to one arguments,     but its type `t_a1Oj' ...
04:57:58 <mux> why is it not working this way?
04:58:01 <Templar> you said I would add a line like this:?
04:58:01 <Templar> main = interact (show . convert . read)
04:58:08 <dons> mux, --> x (x :: [Char])
04:58:21 <dons> Templar: sometihng like that might be useful, yep.
04:58:27 <Templar> roger
04:58:38 <dons> mux, more fun. persistent decls:
04:58:40 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g (x::[Int])
04:58:41 <lambdabot> Defined.
04:58:47 <dons> ?check minimum `L.eqnotnull` (head . sort)
04:58:48 <mux> ?check \x -> reverse (reverse x) == (x :: [Char])
04:58:48 <lambdabot>  OK, passed 500 tests.
04:58:49 <lambdabot>  OK, passed 500 tests.
04:58:51 <mux> aah.
04:59:11 <mux> @karma+ lambdabot -- *heart*
04:59:12 <lambdabot> lambdabot's karma raised to 23.
04:59:46 <mux> dons: anyone can use ?let ?
04:59:50 <dons> sure
04:59:53 <dons> go nuts
04:59:58 <mux> I suppose there's a limit then
05:00:08 <dons> you can always ?undefine to wipe it all
05:00:13 <mux> ok
05:00:15 <dons> so they're just short lived.
05:00:34 <dons> and they have to typecheck and parse before ?let will accept them
05:00:48 <mux> ?let zeta s = [ (n :+ 0) ** (-s) | n <- [1..] ]
05:00:49 <lambdabot> Defined.
05:01:20 <dons> so now you can refer to zeta as L.zeta in either @run or @check
05:01:31 <Templar> can I see my PATH in GHC somehow?(ls, list) - Have Changed my enviromentvarible (PATH). Is it effecting GHC path also?
05:01:52 <mux> > sum (take 1000 (zeta (1 :+ 0)))
05:01:52 <lambdabot>  Not in scope: `zeta'
05:01:58 <mux> hey
05:02:02 <dons> Templar: Prelude> System.Environment.getEnv "PATH" >>= print
05:02:06 <mux> I just defined it
05:02:14 <dons> mux, L.zeta, its a qualified name
05:02:17 <mux> ok
05:02:25 <dons> (so people don't go redefining (+) and so on :)
05:02:35 <mux> > sum (take 1000 (L.zeta (1 :+ 0)))
05:02:36 <lambdabot>  7.485470860550343 :+ 0.0
05:02:44 <mux> > sum (take 2000 (L.zeta (1 :+ 0)))
05:02:45 <lambdabot>  8.178368103610284 :+ 0.0
05:03:06 <mux> > sum (take 4000 (L.zeta (1 :+ 0)))
05:03:07 <lambdabot>  8.871390299795198 :+ 0.0
05:03:33 <mux> > sum (take 000 (L.zeta (1 :+ 0)))
05:03:34 <lambdabot>  0.0 :+ 0.0
05:03:36 <mux> oops
05:03:43 <mux> > sum (take 10000 (L.zeta (1 :+ 0)))
05:03:44 <lambdabot>  9.787606036044348 :+ 0.0
05:05:20 <Templar> http://83.227.193.230/hs/ghc2.png
05:06:18 <mux> mmm, it's not converging fast for 1
05:06:27 <dons> hmm, seems a bit strange Templar.
05:06:38 <dons> firstly the path, secondly, where are your packages? ghc can't find them.
05:06:43 <mux> > sum (take 10000 (L.zeta (2 :+ 0)))
05:06:44 <lambdabot>  1.6448340718480652 :+ 0.0
05:06:51 <mux> > sum (take 100000 (L.zeta (2 :+ 0)))
05:06:53 <lambdabot>  1.6449240668982423 :+ 0.0
05:07:22 <mux> 2 is converging faster
05:07:27 <Lemmih> Templar: s/Enviroment/Environment/?
05:07:35 <dons> ah perhaps :)
05:07:42 <Templar> dons: that last line: was it not supposed to print out my path only? ..
05:08:13 <mux> > getCurrentDirectory >>= putStrLn
05:08:13 <lambdabot>  Not in scope: `getCurrentDirectory'
05:08:22 <Lemmih> Templar: Try :!ls
05:08:23 <mux> > System.Directory.getCurrentDirectory >>= putStrLn
05:08:24 <lambdabot>  Not in scope: `System.Directory.getCurrentDirectory'
05:08:50 <dons> you've made a typo, Templar: you wrote "Enviroment" <-- spelling mistake.
05:09:11 <Templar> aha
05:09:13 <mux> ?import System.Directory
05:09:13 <lambdabot> Unknown command, try @list
05:09:17 <mux> heh, was worth a try
05:09:22 <mux> @list
05:09:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:09:29 <dons> mux, you don't get any special IO privedges, just because I wrote some new plugin ;)
05:10:11 <mux> I hoped to find at least a minimal information leak :D
05:14:14 <Syzygy-> Hmmmmm. The HOpenGL tutorial I found uses matrixExcursion; some mailing list discussions mention it; but my ghc dies upon encountering it.
05:14:26 <Syzygy-> ColorCube.hs:9:10: Not in scope: `matrixExcursion'
05:14:33 <Syzygy-> Anyone know how to get it into scope?
05:15:15 <dons> hmm, is it defined in the tutorial?
05:15:43 <Syzygy-> "HOpenGL provides a function which allows to add some more transformations to some local parts of your shape. This function is called matrixExcursions which refers to the fact that transformations are technically implemented as matrixes. matrixExcursion has one argument, which is a monadic statement. The application of matrixExcursion is a monadic statement:"
05:15:48 <Syzygy-> matrixExcursion :: IO a -> IO a
05:16:20 <Syzygy-> That reads to me as if it should be defined in HOpenGL.
05:16:23 <dons> ok, so its in some OpenGL module. better check the HOpenGL docs
05:16:40 <Syzygy-> I cannot find any reference to it in the HOpenGL docs on the net though. :/
05:17:25 <dons> ?docs Graphics.Rendering.OpenGL
05:17:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
05:18:20 <Syzygy-> Is that thing searchable in some sane manner?
05:18:43 <dons> ?google matrixExcursion site:haskell.org
05:18:46 <lambdabot> http://www.haskell.org/pipermail/hopengl/2003-October/000402.html
05:18:46 <lambdabot> Title: [HOpenGL] ghc-6.0.1 and OpenGL enabled
05:18:58 <Syzygy-> Yeah, I've seen that discussion already.
05:19:04 <mux> ?hoogle matrixExcursion
05:19:05 <lambdabot> No matches found
05:19:06 <Syzygy-> That's the mailing list discussion I mentioned.
05:19:30 <Syzygy-> ?google matrixExcursion site:haskell.org/ghc/docs/lates/html/
05:19:31 <lambdabot> No Result Found.
05:19:35 <Syzygy-> ?google matrixExcursion site:haskell.org/ghc/docs/latest/html/
05:19:35 <dons> you'll just have to trawl the source I think
05:19:36 <lambdabot> No Result Found.
05:19:44 <Syzygy-> Oh joy. :-/
05:19:48 <dons> ?fptools Graphics.Rendering.OpenGL
05:19:48 <lambdabot> http://darcs.haskell.org/packages/OpenGL/Graphics/Rendering/OpenGL.hs
05:19:57 <dons> and its subdirectories
05:21:23 <dblhelix> @hoogle (//)
05:21:24 <lambdabot> Did you mean: (//)
05:21:24 <lambdabot> Prelude.undefined :: a
05:21:24 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
05:21:41 <dblhelix> @hoogle //
05:21:42 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
05:21:42 <lambdabot> Data.Array.(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
05:21:42 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
05:28:30 <Syzygy-> Oh joy.
05:28:48 <Syzygy-> matrixExcursion or for that matter the substring matrixE is nowhere to be found in the HOpenGL sourcetree.
05:30:19 <dons> maybe it has been replaced in hOpenGL 2.0?
05:30:30 <dons> I think the hopengl page lists the api changes
05:30:31 <Syzygy-> Quite possible...
05:36:45 <Syzygy-> ?docs Graphics.UI.GLUT
05:36:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT.html
05:37:38 <dons> ah, its in UI.*?
05:38:31 <Syzygy-> GLUT is. GL isn't.
05:38:33 <Syzygy-> :)
05:41:19 <Syzygy-> Right.
05:41:21 <ventonegro> newbie here
05:41:39 <dons> welcome!
05:41:40 <ventonegro> i know that are no loops in haskell
05:41:44 <Syzygy-> Now I got a program (of sorts) up and running, but my keyboardMouseCallback doesn't seem to be working as it should.
05:41:51 <ventonegro> so i've written this
05:41:52 <dons> ventonegro: yes there are :)
05:42:13 <ventonegro> mapM_ (addSource x s dt) [1..size]
05:42:43 <ventonegro> this is a waste of space, right?
05:43:05 <dons> should be ok
05:43:14 <dons> but you're not using the list
05:43:14 * mux often found a "foreach = flip mapM_" to be very useful
05:43:25 <ventonegro> dons, so haskell does not create the whole list?
05:43:32 <dons> not in this case, no.
05:44:03 <ventonegro> dons, i'm using the list as an arg to mapM_
05:44:10 <dons> you could just use: replicateM_ size $ addSource x s dt
05:44:27 <ventonegro> humm... didn't know this function
05:44:28 <dons> oh, is there a typo in your above code? yes.
05:44:41 <dons> mapM_ (\s -> addSource x s dt) [1..size] -- ?
05:45:05 <ventonegro> dons, no, it's a partial application
05:45:22 <dons> oh, the 4th arg. ok then. mapM_ is a good solution
05:45:43 <ventonegro> dons, ok, then. thanks!
05:45:46 <dons> replicateM_ would be if you _weren't_ using the list elements, and just wanted to repeat an action 'n' times.
05:45:53 <ventonegro> i see
05:45:57 <Syzygy-> ?hoogle printLn
05:45:58 <lambdabot> No matches found
05:46:00 <Syzygy-> ?hoogle print
05:46:00 <lambdabot> Prelude.print :: Show a => a -> IO ()
05:46:00 <lambdabot> Text.Printf.Print :: class Print
05:46:00 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
05:46:06 <dons> (you do have loops too, of course, with recursion)
05:46:18 <Syzygy-> Is print $ show c redundant?
05:46:26 <dons> also, in ghc 6.6 we have: forM_ [1..size] $ addSource x s dt
05:46:26 <ventonegro> dons, i was talking about foor loops :-)
05:46:36 <ventonegro> i know recursion is the haskell way
05:46:43 <dons> Syzygy-: yep
05:46:46 <ventonegro> ops, for* loops
05:46:46 <dons> ventonegro: ok :)
05:46:56 <mux> forM and forM_ are in GHC 6.6?
05:47:01 <ventonegro> forM_ seems even cooler
05:47:07 <mux> forM_ is like my foreach
05:47:09 <dons> forM_ = flip mapM_
05:47:47 <ventonegro> @type flip
05:47:49 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
05:48:30 <dons> flips the arguments
05:48:41 <mux> ghc owns me
05:48:55 <ventonegro> i guess i need to study more the standard functions
05:49:06 <dons> ?docs Control.Monad
05:49:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
05:49:09 <gour> dons: you can build lambdabot with 6.6?
05:49:29 <dons> gour: yep, you need the .cabal-ghc-6.6 file though, in place of lambdabot.cabal
05:49:31 <ventonegro> but the online docs only show the libraries, not the prelude
05:49:38 <dons> ?docs Prelude
05:49:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
05:49:50 <ventonegro> heh
05:49:54 <dons> ah heh. 404
05:49:55 <mux> I was so proud of myself for defining this stupid foreach thing, GHC raped me
05:50:00 <ventonegro> i guess i didn't look hard enough
05:50:01 <dons> the prelude is on haskell.org, anyway
05:50:07 <ventonegro> mux, hehehe
05:50:30 <mux> dons: btw, will there be some way to have ByteString's "by default" some day?
05:50:31 <dons> here, http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
05:50:33 <lambdabot> http://tinyurl.com/ovjef
05:50:44 <gour> dons: i used that, as well as ebuild from gentoo-haskell overlay, but it didn't work. you pushed some new patch(es) ?
05:50:56 <mux> for instance, if I want to have the map function from there by default instead of Prelude.map, I'm forced to do hacks
05:51:00 <mux> like
05:51:01 <mux> import Prelude ()
05:51:01 <dons> gour: you're using the darcs repo?
05:51:10 <mux> import Data.ByteString.Lazy.Char8
05:51:14 <dons> i'm building it right here with the ghc snapshot, and no problems.
05:51:18 <gour> dons: yes, lambdabot-darcs live ebuild (gentoo)
05:51:37 <dons> mux, hmm. by default? no, I don't think so: they're not as lazy as [Char], nor do they support pattern matching.
05:51:48 <mux> ok
05:52:00 <dons> I suppose some magic could be done with associated types, for certain problems. but I don't see any easy path
05:52:25 <dons> mux, import qualified Prelude as P
05:52:45 <mux> yeah, well that's not very satisfactory too :-)
05:52:58 <mux> ideally I'd like import Prelude without the String functions
05:52:59 <dons> grour, live ebuild? so it just uses the darcs repo directly?
05:53:06 <mux> but I guess I can live with that
05:53:08 <dons> have you tried building it not from an ebuild?
05:53:21 <dons> mux, hmm. interesting.
05:55:11 <Syzygy-> cooooool! I can rotate a tetrahedron!!! :)
05:55:22 <dons> hey cool. screenshot?
05:55:26 <Syzygy-> Did this channel have some sort of Karmathingie?
05:55:30 <gour> @where paste
05:55:30 <lambdabot> http://paste.lisp.org/new/haskell
05:55:41 <dons> yep, Syzygy- , either nick++ or @karma+ nick
05:56:10 <lisppaste2> gour pasted "lambdabot build failing" at http://paste.lisp.org/display/25885
05:56:26 <gour> dons: it is still the same (old) error
05:56:40 <dons> gour: hmm. ok.so the gentoo cabal is doing something hard/evil/not sure
05:56:48 <gour> dons: kolmodin also confirmed it
05:56:57 <dcoutts__> dons: let me check...
05:57:13 <dons> dcoutts__: so this Language.Haskell.ParseUtils is not exposed?
05:57:22 <dons> (since it works for me here with normal ghc 6.6)
05:57:47 <Syzygy-> http://mikael.johanssons.org/OrbitCube.png
05:57:48 <dons> other-modules:
05:57:49 <dons>         Language.Haskell.ParseUtils
05:57:49 <Syzygy-> dons++
05:58:02 <gour> dons: yep. it's under 'other modules'
05:58:12 <dons> very nice Syzygy- . you hacked that up in 10 mins or less?
05:58:17 <Syzygy-> Not really...
05:58:29 <Syzygy-> I've been poking at it sparsely for over a week.
05:58:47 <Syzygy-> This is the result of me giving up, copy-pasting the tutorial code and then tweaking that until it works.
05:59:01 <Syzygy-> What I really want to do is rendering a triangulation, and then calculate morse flows on it...
05:59:04 <dons> ah ok. good work though. you can add some evil tetrahedron monsters to frag now
05:59:13 <Syzygy-> But I wanted to be able to rotate viewpoint before I started.
05:59:22 <Syzygy-> *afk*
05:59:28 <dcoutts__> dons: seems so. it's now hidden. the ebuild isn't doing anything else evil.
05:59:41 <Syzygy-> (workgroup outing! *gone*)
05:59:44 <dons> dcoutts__: so has new cabal changed semantics for other-modules?
05:59:51 <dons> they're really really hidden?
05:59:52 <Syzygy-> Did my ++ work? How would I know?
05:59:59 <dons> Syzygy-: it worked
06:00:02 <Syzygy-> Right-o.
06:00:02 <dons> ?karma dons
06:00:03 <lambdabot> You have a karma of 68
06:00:26 <dcoutts__> dons: they've always been hidden
06:00:35 <gour> dons: Language.Haskell.PareUtils is declared as 'other-modules'
06:00:42 <dons> hmm. so why then is it building with my out-of-darcs ghc 6.6?
06:00:48 <dons> and has done for months..
06:00:51 <dons--> talk to me :)
06:00:56 <norpan> sorry
06:01:04 * dons was scared for just a second
06:01:12 <dons> i thought i saw double
06:01:15 * dcoutts__ slaps norpan
06:01:41 <dons> well, then, this module shouldn't be hidden, since its useful ... hmm
06:01:47 <norpan> back to work...
06:02:09 <dons> and why is it only on gentoo that this hidden issue seems to occur/
06:02:16 <dcoutts__> dons: http://darcs.haskell.org/packages/haskell-src/haskell-src.cabal
06:02:18 <dcoutts__> same ^^
06:02:19 <lambdabot> http://tinyurl.com/lvlm8
06:02:51 <dons> i understand its in other-modules. it is on my box too. but its only the gentoo build reporting that its actually hidden.
06:03:06 <dcoutts__> dons: I'll tell you why...
06:03:15 <dons> you install a newer cabal?
06:03:20 <dcoutts__> because we build via cabal and ghc builds via makefiles
06:03:27 <dcoutts__> and the two are currently inconsistent
06:03:40 <dons> oh so you enforce the hidden-ness?
06:03:49 <dcoutts__> http://darcs.haskell.org/packages/haskell-src/package.conf.in
06:03:51 <lambdabot> http://tinyurl.com/q8tnh
06:03:57 <dcoutts__> dons: no, we just build with cabal
06:04:07 <dons> ah!
06:04:07 <dcoutts__> but the makefiles us package.conf[.in]
06:04:09 <dons> there we go
06:04:24 <dcoutts__> that's why it fails for us and not for anyone else
06:04:36 <dons> ok. I say the .cabal file is a bug then
06:04:36 <dcoutts__> because we're doing "The Right Thing"tm :-)
06:04:45 <dons> that module shouldn't be hidden.
06:04:51 <dcoutts__> dons: send in a patch!
06:04:56 * dons sends
06:05:14 * gour congrats to dcoutts__
06:24:38 <ventonegro> are unboxed arrays of arrays slower then a single unboxed array?
06:25:14 <dons> I'd imagine so, there's on more indirection
06:25:19 <dons> a/one more/
06:25:36 <ventonegro> that's what i thought :-)
06:29:26 <lisppaste2> Templar pasted "GHC error" at http://paste.lisp.org/display/25888
06:29:40 <Templar> =/
06:30:36 <Templar> any ideas?
06:30:52 <sek_> is it possible that ghci parses 4 spaces differently from a tab?
06:31:16 <Igloo> Yes
06:31:24 <ventonegro> @type div
06:31:25 <lambdabot> forall a. (Integral a) => a -> a -> a
06:31:27 <Igloo> Tabs in Haskell are 8 spaces, and are evil, bad and wrong
06:31:40 <sek_> damnit, i thought my code looked alot nicer with 4 space tabbulating
06:31:46 <sek_> but i get parser errors
06:31:47 <int-e> tabs were never meant to be 4 spaces.
06:31:48 <ventonegro> div gives an Integral, your function gives a float
06:32:15 <sek_> so should i stick to long tabs or change my code slightly to suite 4-space tabs
06:32:25 <sek_> what is the norm i mean
06:32:26 <Igloo> int-e: It's not the 8 spaces that's EB&W, it's tabs
06:32:42 <Igloo> sek_: Use spaces IMO
06:33:13 * sek_ sulks and goes off to build a regular expression to do the job
06:33:15 <sek_> :p
06:33:24 <Templar> aha, floats not possible to divide, thanks :)
06:33:52 <ventonegro> Templar, np
06:34:05 <dons> sek, :set ts=4; :set expandtab ; :retab
06:34:08 <Templar> those stupid exercises are fooling me every time
06:34:11 <sek_> dons yeah
06:34:20 <sek_> i just rememberd i had that
06:34:23 <ndm> and can someone please tell cabal that mixing tabs and spaces is evil and wrong
06:34:33 <sek_> thanks
06:34:37 <ndm> in fact, would a patch replacing tabs with spaces get accepted to cabal?
06:34:41 <dcoutts__> ndm: yes
06:34:41 <dons> sek_: I even have:
06:34:43 <dons> syn match tabNasty display "\t"
06:34:43 <dons> hi link tabNasty Todo
06:34:51 <dcoutts__> ndm: it's the problem of multiple authors
06:34:54 <sek_> haha
06:35:04 <sek_> dons: just to be sure huh?
06:35:05 <ndm> dcoutts__, have you seen the intentation in Hugs - now thats pure evil!
06:35:05 <dons> which labels any tabs a lovely orange colour that I just want to delete on sight
06:35:15 <dcoutts__> ndm: I've not
06:35:20 <ndm> indent = 4 spaces, tab = 8 spaces
06:35:36 <norpan> but it's so simple: don't use tabs!
06:35:44 <ndm> so level 1 indent is 4 spaces, level 2 is 1 tab, level 3 is 1 tab + 4 spaces
06:35:51 <ndm> etc. until brain explodes
06:36:01 <dons> its even on the table to ban tabs from future haskell versions...
06:36:05 <int-e> Igloo: I wouldn't agree that tabs are evil, they've just outlived themselves. disk-space is cheap nowadays.
06:36:08 <dons> so definitely bad karma to use them
06:36:09 <ndm> yay!!!!!
06:36:16 <int-e> Igloo: I don't use them.
06:36:18 <ndm> ban tabs
06:36:40 <norpan> at least ban tabs where the tab stop setting will affect the semantics, if that's easy to do
06:36:42 <Igloo> int-e: In a layout-sensitive language they're definitely evil
06:36:55 <ndm> i did do a patch that removed all tabs from Yhc, which is why Yhc is now a tab free zone!
06:36:58 <bringert> haddock 0.7 doesn't seem to support hiding with imports when re-exporting a module
06:37:09 <Igloo> :set hls; /^I in bit of GHC source is just scary
06:37:16 <dcoutts__> bringert: you could try 0.8_rc1
06:37:25 * Igloo keeps meaning to write -Wtabs
06:37:25 <dons> Igloo: heh.
06:37:32 <dons> ah yes, that'd be good.
06:37:33 <dcoutts__> that'd be nice
06:37:37 <bringert> dcoutts__: do you know if it fixes that?
06:37:45 <dcoutts__> bringert: I don't know, sorry.
06:37:47 <dons> darcs does this in the testsuite. so should ghc
06:38:07 <dons> and dump the source to the console in garish ansi colours
06:38:15 <dons> that'd kill tabs off pretty quick
06:38:18 * Igloo should stop before I start ranting about trailing white space
06:38:28 <dons> syn match endspaceNasty display " *$"
06:38:28 <dons> hi link endspaceNasty Todo
06:38:31 <dons> :)
06:38:52 <ndm> Igloo: yay, another thing to have a -Wwhite
06:39:17 <sek_> hmm. i am getting problems when having two expressions in section A of the following let A in ...
06:39:30 * dons is member of vim-syntax-highlighting-as- -Wall society
06:39:44 <sek_> i have smarttab on vim as well, so the second declaration of A is under the first, tabulated twice that is
06:41:26 <sek_> ah, fixed it
06:41:50 <sek_> i wish parsers had some artificial intelligence builtin, heh
06:42:23 <ndm> sek_: that makes having a standard a little tricky
06:43:15 <sek_> why not have a parser that ignores tabulation in the first place
06:44:22 <dcoutts__> dons: I rely on vim syntax highliting for that too. gentoo encodes many of it's ebuild coding style guidlines as vim syntax highliting. It works well.
06:44:47 <dcoutts__> sek_: how could it do that?
06:44:59 <dcoutts__> a tab needs to be defined to be some amount of whitespace
06:45:04 <dcoutts__> the amount affects the meaning
06:45:13 <dcoutts__> at least, it can do
06:45:27 <sek_> i mean like simply skip whitespaces until text is found
06:45:30 <sek_> like in c say
06:45:37 <dcoutts__> C doesn't use layout
06:45:52 <norpan> sek_: because then you have to put in ugly curly braces
06:45:54 <dcoutts__> layout affects the meaning in languages like Haskell and Python
06:46:07 <sek_> oh ofcourse
06:46:26 <greenrd> what is a "with clause"?
06:47:12 <gds> > f x = y + y with y = x * 2 in f 2
06:47:12 <lambdabot>  Parse error
06:47:18 <gds> Hm - damn ;)
06:47:58 <greenrd> from the ghc docs, section 7.4.6: "You can bind linear implicit parameters in 'with' clauses."
06:48:10 <greenrd> I wondered if that is a typo and it is actually meant to be "where" clauses
06:49:17 <ndm> greenrd: seems likely...
06:53:48 <ventonegro> the difference between an immutable array and a list is basically access times?
06:55:46 <int-e> hmm, list has O(1) cons and tail.
06:56:24 <dcoutts__> aaarg, wash's build system is very broken
06:56:24 <dcoutts__> I hate fixing it
06:57:05 <ventonegro> but O(n) random access, I guess
06:57:08 <dcoutts__> ventonegro: right, you can do (!! n) in O(1) vs O(n)
06:57:53 <ventonegro> dcoutts, thanks
07:03:41 <Lemmih> Any #haskellers from Hamburg, Germany?
07:09:27 <profmakx> well im from germany
07:09:32 <profmakx> but not from hamburg ;)
07:10:48 <ventonegro> i had some german classes a long time ago :-P
07:11:19 <profmakx> ^^
07:12:14 <dcoutts__> anyone use wash? feel like cabalising it ?
07:12:40 <dcoutts__> and breaking up some of the large modules so they don't take >10 min to build
07:13:00 <ndm> anyone fancy doing my phd? ;)
07:13:03 <dcoutts__> hah
07:14:04 <int-e> you?
07:14:05 <ndm> or explaining why read of int, really really requires all of lex
07:14:40 <int-e> > read ('"' : repeat 'a') :: Int
07:14:44 <lambdabot> Terminated
07:14:53 <int-e> because otherwise you won't replicate this behaviour ;)
07:15:04 <ndm> oh, shame :)
07:15:17 <ndm> really, its screwing up my benchmark's
07:15:24 <ndm> no wonder read of Int goes so hopelessly slowly
07:15:52 <Patterner> Lemmih: yes
07:16:20 <sehute> hi smart people
07:16:32 <Patterner> hi dumb one :)
07:16:46 <Templar> lol
07:16:48 <sehute> hey ;)
07:17:25 <Patterner> well, if the name fits...
07:17:40 <sehute> i am dubm not!
07:18:12 <sehute> Patterner: my name is actually made by my own random-nick generator, so there ;)
07:18:31 <sehute> so, what's up in the wonderful world of haskell?
07:18:37 <sehute> Not much since 98? ;)
07:19:01 <sehute> Seems like there are plenty of cool projects all over the web, though
07:19:05 * Patterner tickles Lemmih with horse feathers
07:21:53 <int-e> ndm: on the other hand ghc's read implementation for integers is already incompatible to Haskell98 for several reasons.
07:22:33 <ndm> int-e: well my issue is that my analysis tool now has to analyse all of read, which is just plain stupid
07:23:08 <int-e> ndm: namely, it supports multiple negation signs ("- - 1"), signs outside of parentheses ("-(1)") and octal and hexadecimal numbers ("0o1", "0x1")
07:23:32 <int-e> ndm: I agree.
07:24:51 <ndm> lets start a campaign to unbreak read for Haskell' !
07:25:03 <ndm> if we could just add read to the Read class, i think that would be enough?
07:25:23 <int-e> nah, readsPrec is fine in my opinion.
07:25:42 <int-e> it's invoking the whole lex machinery all the time that's broken
07:25:45 <ndm> so is there anything to stop unbreaking this read Int already?
07:26:00 <ndm> i.e. could you submit a patch that properly handled readInt, but didn't invoke lex?
07:26:02 <int-e> my code returns immediately.
07:26:09 <int-e> because '"' isn't a digit.
07:27:21 <sjanssen> ndm: I think adding read to Read is an excellent idea
07:27:23 <ndm> so can that be done without changing anything - just tweaking the base library, but having the same interface (almost)
07:27:36 <int-e> sjanssen: why?
07:27:39 <sehute> sjanssen: hi, how did your soc project go, btw? :)
07:28:36 <sjanssen> int-e: then we can have specialized read functions that don't use the complicated parse functionality
07:28:40 <sjanssen> sehute: it went well
07:28:51 <sehute> sjanssen: great
07:28:52 <sjanssen> actually, maybe adding read is a bad idea
07:28:54 <int-e> sjanssen: you can do that with readsPrec, too. it's not really harder.
07:29:16 <sehute> sjanssen: looking forward to seeing the effects of what you've done
07:29:24 <ndm> int-e: so do you have the power to fix read without changing the interface or semantics - beyond moving _|_ NT to failure?
07:30:24 <sehute> sjanssen: which variant of unicode did you end up using?
07:30:48 <sjanssen> sehute: I store the strings as 32 bit values
07:31:22 <int-e> ndm: I have code for that, yes (I have functions readsPrecInt, readsPrecInteger, readsPrecRatioInt and readsPrecRational that match readsPrec for those types in Haskell98). No patch yet, because I've not made up my mind how it should look like.
07:31:28 <sjanssen> s/strings/chars
07:31:55 <int-e> ndm: the really hard part would be changing derived instances though - these are also defined in terms of lex I believe.
07:32:20 <sehute> sjanssen: that's the "full package"-solution, isn't it? Sounds great
07:32:20 <sjanssen> sehute: so it's kind of like UTF-32
07:32:27 <sehute> sjanssen: great
07:32:33 <ndm> int-e: is Int and Integer done by derived instances?
07:32:34 <sehute> sjanssen: was it hard to implement?
07:32:42 <int-e> ndm: no.
07:32:47 <sehute> lambdabot: why are there both Integer and int?
07:32:57 <sjanssen> sehute: somewhat time consuming, but not incredibly difficult
07:33:04 <int-e> sehute: me?
07:33:23 <sehute> int-e: no, just experimenting with lambdabot :) But yes, I do wonder why. :)
07:33:40 <sehute> sjanssen: will it be included in ghc or hugs?
07:33:51 <ndm> sehute: Int = 32 bits, Integer = unlimited
07:33:53 <int-e> sehute: Int is a machine word (32 bits or 64 bits, usually. it's guaranteed to have at least 30), Integer has arbitrary precision.
07:34:11 <sehute> ndm: ah, thanks
07:34:30 <sjanssen> sehute: there's still some work to be done, but hopefully in the future
07:35:00 <sehute> sjanssen: great
07:35:25 <int-e> ndm: these functions could replace the Read instances for Int and Integer. To get them into ghc I guess I'll have to add octal and hexadecimal numbers.
07:35:46 <ndm> int-e: well do so, the world will thank you
07:42:09 <int-e> Syzygy-: preservingMatrix seems to be the new name of matrixExcursion
08:01:51 <sehute> have a nice day
08:27:03 * edwardk waves ello
08:28:32 <ski> hi edwardk
08:28:33 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
08:29:50 <edwardk> heya ski
08:30:21 <edwardk> been working hard on the substructural types stuff. got a free proof of cut elimination by reformulating it and saying the same things slightly differently.
08:30:30 <edwardk> display logic is my friend
08:30:35 <sek_> how come i can do 1::Double, and not (length [2])::Double ?
08:30:57 <ski> '1' is overloaded
08:31:04 <ski> but the result from 'length' is not
08:31:07 <ski> @type 1
08:31:08 <edwardk> > genericLength [2] :: Double
08:31:11 <ski> @type length
08:31:24 <lambdabot>  1.0
08:31:24 <lambdabot> type module failed: IRCRaised thread killed
08:31:25 <lambdabot> forall a. [a] -> Int
08:31:26 <edwardk> @type genericLength
08:31:28 <lambdabot> forall i b. (Num i) => [b] -> i
08:31:34 <edwardk> =)
08:31:51 <ski> if it was
08:32:11 <ski> length :: Num b => [a] -> b
08:32:27 <ski> then '(length [2])::Double' would work
08:32:28 <edwardk> if it was overloaded then it would have to carry around the dictionary everywhere to add up the length, etc.
08:32:33 <ski> yes
08:32:43 <edwardk> hence why genericLength exists but isn't the default length
08:33:04 <sek_> ah, i see
08:33:48 <ski> sek_ : so, either use 'genericLength', or use a 'fromIntegral' on the result of 'length'
08:33:52 <norpan> well, the compiler could specialize the function for different types
08:33:59 <edwardk> after all Int is usually around your pointer size anyways, so if you have more nodes than that in your list you either have a cycle and can't finish counting or you have something massive and know what you mean
08:34:13 <edwardk> norpan: sure, but length typically does what people mean
08:34:24 <sjanssen> @check (\n -> let l = replicate (abs n) () in (genericLength l :: Float) == fromIntegral (length l))
08:34:26 <lambdabot>  OK, passed 500 tests.
08:34:32 <norpan> on a 64 bit machine, ints are often 32 bits
08:34:50 <norpan> but maybe ghc makes haskell Ints 64 bits anyway
08:35:05 <edwardk> not sure
08:35:53 <edwardk> The finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1] is all I think you are guaranteed
08:36:11 <edwardk> so they can tag it
08:36:35 <edwardk> so they can use a 64 bit rep if they want
08:36:54 <edwardk> > maxBound :: Int
08:36:55 <lambdabot>  2147483647
08:37:01 <edwardk> @version
08:37:01 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
08:37:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:37:15 <edwardk> anyone got a 64 bit ghc to test on? =)
08:39:18 <norpan> Prelude> maxBound ::Int
08:39:18 <norpan> 9223372036854775807
08:39:21 <norpan> yes, 64 bits
08:39:26 <sek_> ok, i fixed it now. thanks all
08:39:39 <edwardk> kk
08:40:02 <edwardk> so length does what it probably should anyways ;)
08:40:20 <norpan> yeah, Int is sufficient for length as long as Int == size of pointer
08:43:24 <edwardk> or is at most a few bits smaller (based on the granularity of objects in memory)
08:44:13 <glguy> Oh jalepeno sunflower seeds, how I love thee...
08:45:57 <edwardk> is this a seasoning thing of a freak of genetic engineering? =)
08:46:02 <edwardk> er thing or
08:46:55 <glguy> they are soaked in Jim Beam whiskey + jalepeno flavoring
08:47:06 <edwardk> ah
08:48:49 <glguy> edwardk: I don't remember if you were here when I was proudly announcing it, but I finally figure out hwo to use the ST monad correctly for my monopoly thingy
08:49:22 <glguy> figured*
08:49:23 <edwardk> glguy: paste?
08:50:11 <lisppaste2> glguy pasted "with ST" at http://paste.lisp.org/display/25898
08:52:49 <edwardk_> guess that works =)
08:53:09 <glguy> Once I figured out that you don't actually pass STArrays around in state
08:53:24 <glguy> it came together nicely
08:53:25 <edwardk_> yeah
08:53:51 <edwardk_> well, you could pass the reference to the STArray in the state, but I can see why you wouldn't want to here
08:54:03 <glguy> the reference shouldn't change
08:54:20 <glguy> so I imagine that you'd rather want ot use a Reader for something like that
08:54:25 <edwardk_> gl: well, state can be used like a "Reader" to stuff that isn't going to change
08:54:26 <edwardk_> yeah
08:54:41 <edwardk_> just since you also had the stdGen, it seemed clean to stuff them both in the state
08:54:46 <edwardk_> rather than have BOTh state and reader
08:55:10 <glguy> stuffing two things into the state was making the code that used the StdGen ugly
08:55:19 <edwardk_> yeah
08:55:21 <edwardk_> noticed that
08:55:35 <glguy> ti was defeating the point of having state at all :)
08:55:49 <glguy> because I was having to manually pass stuff around and push it back in
08:55:59 <edwardk_> well, you typically write a wrapper when you need complex state like that
08:56:09 <glguy> ah
08:56:18 <edwardk_> then use that
08:56:44 <edwardk_> but this is arguably quite clean this way
08:57:00 <glguy> I love how once you start doing things correctly
08:57:05 <glguy> the lines of code start melting away
08:57:09 <edwardk_> yeah
08:57:16 <edwardk_> best part of haskell
08:57:26 <edwardk_> is that it asymptotically approaches writing no code at all
08:57:27 <edwardk_> very zen
08:57:57 <glguy> I liked getting to write: lift (lift (tally c))
08:58:22 <edwardk_> heh. well by then you should probably write some form of specialized lifter to lift to a given level =)
08:58:29 <edwardk_> and bah on the nested parens ;)
08:59:06 <glguy> lift 5 tallc ;)
08:59:11 <glguy> lift 5 tally c ;)
08:59:31 <edwardk_> heh, well i was thinking more like liftIO or liftSTM for my typical usage scenario
08:59:44 <glguy> how do those work?
09:00:09 <glguy> ?type liftIO
09:00:10 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
09:00:15 <glguy> ?type lift
09:00:16 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:01:16 <edwardk_> you have some form of monad that contains multiple levels. then you can compose monad transformers and use the appropriate named lift to get out the right level
09:01:41 <edwardk_> so if you had a ReaderT'd StateT'd IO, then liftIO strips both outer layers for instance
09:01:55 <glguy> how does it do that?
09:02:07 <edwardk_> coz it makes them instances of an appropriate class
09:03:01 <edwardk_> so IO is an instance of MonadIO, StateT applied to anything that is an instance of MonadIO is an instance of MonadIO by lifting and applying the other instance's monadIO
09:03:10 <edwardk_> so you can liftIO over any # of stateT wrappers
09:03:19 <edwardk_> and get down to the IO at the soft chewy center
09:03:26 <glguy> hmm
09:05:51 <glguy> g1m0.se
09:06:01 <glguy> now there is a reputable looking hostname
09:28:27 <lispy> morning
09:28:27 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:28:35 <lispy> lambdabot: how are you?
09:29:00 <profmakx> botsnack
09:29:03 <profmakx> arx
09:29:06 <profmakx> @botsnack
09:29:06 <lambdabot> :)
09:29:33 <lispy> dons: thanks for the Ptr, i'll check out GoA
09:31:11 <beelsebob_> @vixen how are you lambdabot?
09:31:11 <lambdabot> i'm good, you?
09:31:35 <beelsebob_> @vixen pretty much doom - what you up to?
09:31:36 <lambdabot> not much, what's up with you?
09:31:51 <beelsebob_> @vixen I want a new toy, but I can't think what.
09:31:52 <lambdabot> I have a boyfriend, but he likes to watch.
09:32:06 <beelsebob_> @vixen not that kind of toy lambdabot.
09:32:06 <lambdabot> tell me more about yourself.
09:32:23 <glguy> uh oh... looks like someone is lonely
09:33:17 <lispy> heh
09:34:02 <lispy> ?vixen feeling feisty?
09:34:02 <lambdabot> why don't you guess?
09:40:00 <yip> anyone know of any gtk2hs issues with recent versions of ghc 6.5?
09:40:10 <dcoutts__> yip: yes
09:40:11 <Patterner> like "it doesn't compile"..?
09:40:33 <ventonegro> :-)
09:40:33 <dcoutts__> yip: it's not fixed yet, still on my TODO
09:40:46 <ventonegro> dcoutts, are you the author?
09:40:53 <dcoutts__> aye
09:41:02 <ventonegro> dcoutts, cool
09:41:08 <lispy> dcoutts__ ftw!
09:41:13 <lispy> ;)
09:41:16 * ventonegro bows to dcoutts skills
09:41:52 <yip> dcoutts_: i've managed to fix a bunch of compile errors, but there seem to be a never ending stream of them!
09:42:01 <dcoutts__> heh
09:42:04 <Patterner> mad hax0r ski||z...?
09:42:06 <dcoutts__> there's a tricky problem to fix
09:42:14 <dcoutts__> ghc's package system changed again
09:42:17 <yip> is it this one? "Something is amiss; requested module  cairo:System.Glib.UTFString differs from name found in the interface file glib:System.Glib.UTFString"
09:42:29 <dcoutts__> yip: exactly
09:43:07 <yip> i see... here's what i don't get though: wasn't hIDE being worked on using the ghc 6.6 ghc-api? aren't they using gtk2hs for hIDE?
09:43:32 <dcoutts__> yip: the package change was more recent than that
09:44:33 <yip> dcoutts: i see... is there some sort of plan to solve the compilation problems? if so should i wait, or should i try to fiddle around and fix this compiler error right now?
09:44:46 <dcoutts__> there is a plan
09:45:02 <dcoutts__> I've been sent some fixes, I just need to find a moment to review and test them
09:45:16 <dcoutts__> it's more tricky than you can fix just by fiddling
09:45:22 <dcoutts__> yip: ping me later
09:45:58 <yip> ok, thanks!
09:48:27 <gour> yip: have you managed to build hIDE?
09:48:37 <bringert> grr: ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): unknown exception
09:51:19 <vaios> hi
09:52:17 <glguy> are there screenshots anywhere of what hIDE looks like?
09:52:47 <ndm> @where hide
09:52:47 <lambdabot> http://haskell.org/haskellwiki/HIDE
09:52:52 <ndm> glguy: on the wiki
09:53:27 <gour> glguy: there is mockup on http://haskell.org/hawiki/hIDE
09:53:28 <lambdabot> Title: hIDE - The Haskell Wiki
09:53:53 <glguy> so how far along is its development?
09:54:37 <gour> glguy: Lemmih, dcoutts__ and dons are the main (only?) hackers
09:55:03 <dcoutts__> we've been busy with other things and waiting for releases of some other stuff
09:55:12 <glguy> ah, ok
09:56:21 <vincenz> > 180 /5 * 9 32
09:56:22 <lambdabot>  add an instance declaration for (Num (t -> a))
09:56:24 <vincenz> > 180 /5 * 9 +32
09:56:25 <lambdabot>  356.0
09:59:19 <glguy> > ((+32).(*9).(/5)) 100
09:59:20 <lambdabot>  212.0
10:00:23 <araujo> hi!
10:02:41 <cjeris> > + 32 $ * 9 $ / 5 $ 100
10:02:41 <lambdabot>  Parse error
10:02:53 <sieni> surprise
10:02:58 <ventonegro> use sections
10:03:34 <sieni> > (+) 32 $ (*) + $ (/) 5 100
10:03:34 <lambdabot>  Parse error
10:03:36 <cjeris> beginner still having trouble with syntax.  three days ago i had fits over indentation of a let
10:03:48 <sieni> > (+) 32 $ (*) 9 $ (/) 5 100
10:03:49 <lambdabot>  32.45
10:04:11 <glguy>  > (+) 32 $ (*) 9 $ (/) 100 5
10:04:15 <glguy> > (+) 32 $ (*) 9 $ (/) 100 5
10:04:16 <lambdabot>  212.0
10:04:19 <cjeris> (+) 32 $ (*) 9 $ (/) 5 $ 100
10:04:26 <cjeris> > (+) 32 $ (*) 9 $ (/) 5 $ 100
10:04:27 <lambdabot>  32.45
10:04:36 <glguy> cjeris:  flip 5 & 100
10:04:43 <cjeris> > (+) 32 $ (*) 9 $ flip (/) 5 $ 100
10:04:44 <lambdabot>  212.0
10:06:06 <glguy> > (+) 32 . (*) 9 . flip (/) 5 $ 100
10:06:06 <lambdabot>  212.0
10:06:23 <yip> gour: no, there seem to be serious problems with gtk2hs
10:07:24 <gour> yip: yes, with i'm aware of the problem with latest ghc. let's just find more enthusiasts to push & help  hIDE
10:08:18 <glguy> > ( do { a <- (/); return (32+9*a 5) } ) 100
10:08:19 <lambdabot>  212.0
10:09:17 <ndm> gour: there are plenty of projects in need of a lot of love...
10:09:36 <ndm> gour: i suspect GuiHaskell will hit the decks working before hIDE comes out, and will be useful as a stepping stone
10:09:48 <gour> ndm: you're right. yhc, jhc are some
10:10:34 <ndm> yeah, although i'm tempted to write another compiler :)
10:10:40 <glguy> > ((32 +) . (9 *) . ($ 5)) `fmap` (/) $ 100 --OK, i'm done (c;
10:10:41 <lambdabot>  212.0
10:10:45 <gour> ndm: GuiHaskell is your project, true? what about that 'commercial Haskell editor' ?
10:11:02 <gour> ndm: why, i.e. with what objective(s) ?
10:11:17 <ndm> gour: yep, my project - i'm not paying money for an editor - there has been one editor in the history of the world that is worth money - and thats TextPad
10:11:34 * gour never used TextPad
10:11:44 <cjeris> @type (do {a <- (/); return (32+9*a 5) })
10:11:46 <lambdabot> forall a. (Fractional a) => a -> a
10:11:47 <ndm> gour: like WinHugs, but all platforms, all compilers - plus integration with Cabal/Haddock/Hoogle/Lambdabot...
10:11:59 <gour> ..but GuiHaskell will enable one to use eg. gvim?
10:12:08 <ndm> yep, you can use whatever you want
10:12:09 <cjeris> glguy: what's the monad?  nothing?
10:12:19 <glguy> cjeris: ((->) r)
10:12:26 <gour> that integration with stuff like goa sounds good
10:12:34 <ndm> you can think of it as hIDE minus the editor bit
10:12:57 <ndm> i.e. a lot less work, less payoff in the end as well, but doesn't take people into a holy editor war
10:13:03 <gour> i'm not on win32, does WinHugs has some editor?
10:13:08 <ndm> nope
10:13:10 <glguy> vim :)
10:13:33 <ndm> think of it as GHCi with buttons, lots of added goodness, mild editor integration (click on an error message, jump to the error kind of thing)
10:13:42 <gour> ahh, that's similar to that aprroach used by pida (i sent you url)
10:13:51 <glguy> WinHugs actually integrates nicely with vim
10:14:00 <glguy> clicking on errors takes you to them and all
10:14:27 <gour> what about connection between editor & ghc for type-checking etc. ?
10:14:40 <glguy> WinHugs wasn't as good at figuring out what types some of my fuctions were tho
10:14:48 <cjeris> glguy: so after do {a <- (/) -- the type of a is (Num a) => a -> a where a is the same type as the whole monad is ((->) a) ?
10:14:56 <gour> like in Visual haskell (as i read about it)
10:14:57 <cjeris> aargh, id recycling
10:15:12 <yip> what is GuiHaskell?
10:15:19 <gour> hIDE is streaming in that direction, right?
10:15:44 <cjeris> glguy: correction: so after do {a <- (/) -- the type of a is (Num b) => b -> b where b is the same type as the whole do-block is ((->) b) ?
10:16:03 <glguy> That seems correct
10:18:55 <glguy> cjeris: same as: ( do { a <- asks (/); return (32+9*a 5) })
10:23:53 <ndm> glguy: glad you like the VIM integration :)
10:25:40 <glguy> ndm is that your doing then?
10:25:54 <ndm> glguy: indeed it is - with my office mate demanding vim integration
10:26:10 <glguy> Well... tell him thanks ;)
10:26:31 <ndm> i tried to add the editors i can find, but it was reasonably hard to detect that an editor is installed, and then invoke it
10:26:37 <glguy> I've heard tell of "TextPad" but I've never seen any editor than the one true ViM ;)
10:26:39 <ndm> i'm glad it worked "in the wild"
10:26:53 <ndm> exactly, everyone has "the one true editor"
10:27:12 <gour> ndm: when will you publish your code (GuiHaskell) ?
10:27:16 <ventonegro> everyone uses vim?
10:27:17 <ibid> ed is that standard editor
10:27:45 <glguy> ventonegro: well... some people use gvim
10:27:47 <ndm> gour: its online in a darcs repo, but a bit broken because Gtk+GHC+Threads is a tad dead...
10:27:58 <Philippa> TextPad seriously needs the 5.x versions out soon. I'm half tempted to try building my own on top of gtk2hs and the source editor control, which isn't a good sign
10:27:58 * gour uses & wants to learn more gvim
10:28:01 <dfranke> I actually use ed sometimes.
10:28:04 <ndm> @where+ GuiHaskell http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
10:28:05 <lambdabot> Done.
10:28:20 <dcoutts__> Philippa: that'd be nice
10:28:32 <ndm> Philippa: Yi would probably like your help
10:28:33 <glguy> I've had to use ed to revive dead Linux boxes
10:28:36 <glguy> but that's about it
10:28:36 <dcoutts__> ndm: you forgot +Windows :-)
10:28:38 <dfranke> Most often when I'm in a busybox rescue shell and my terminal settings are b0rked.
10:28:55 <Philippa> ndm: Yi would like my help if I were able to provide any :-) Is there an idiot's guide to getting a GUI yi built under windows yet?
10:29:01 <ndm> Philippa: and what are you missing in TextPad 5?
10:29:24 <Philippa> you mean that's going to be in 5.x and isn't in 4.x? Proper unicode support, for a start
10:29:30 <ndm> dcoutts__, its definatley not MS's fault, but might be yours, GTK's or GHC's :)
10:29:38 <Philippa> it can edit, but it won't display a lot of characters
10:29:42 <ndm> yeah, i don't speak anything but english so am happy :)
10:29:51 <dcoutts__> ndm: it's GHC on windows methinks, yes not MS
10:29:58 <glguy> ndm: hear hear ;)
10:30:05 <Philippa> suppose I wanted the crapload of new operators available? :-)
10:30:05 <ndm> (of course, you can actually blame MS for GHC ;) )
10:30:09 <dfranke> but in general, if I don't have my emacs customizations available and the system's vi is something other than vim, I'll use ed.
10:30:17 <dcoutts__> ndm: heh, yeah
10:30:37 <ndm> arrrrgggghhhh - operators are merely functions which instead of having a meaningful name have had some weird squigle as a name
10:30:44 <gour> ndm: it is buildable on linux?
10:31:00 <ndm> gour: yep, the second GuiHaskell screenshot is a linux one
10:31:03 <glguy> ndm: huh?
10:31:20 <ndm> glguy: huh at what?
10:31:26 <glguy> arrrrgggghhhhhh
10:32:10 <Philippa> operators are merely functions which you can type in a single keypress :-)
10:32:34 <ventonegro> or two, or three
10:32:34 <Philippa> I really wouldn't want to be using Parsec without the operators, even with `infix` function calls
10:32:39 <glguy> sure, but I didn't think that was a surprise to ndm, so I wondered what it was arrrgghhhing about
10:33:02 <ndm> glguy: just me being scared that once we have unicode, the we might as well rename Haskell as APL
10:33:04 <Philippa> and unicode offers a lot of symbols that're already understood
10:33:24 <ndm> indeed, a modicom of extra symbols is useful - i guarantee they will be abused to horrible lengths though
10:33:34 * Philippa nods
10:33:38 <gour> ndm: does it work with ghc?
10:33:42 <glguy> ndm: abused like ((->)r)?
10:33:46 <Philippa> and then people will be killed, and then things'll calm down again
10:33:47 <ndm> gour: ghc only
10:33:57 <Philippa> glguy: that's different, it's a type rather than a term
10:34:09 <ndm> gour: oh, when its running - hugs or GHC (although you might need to tweak the source code to change it from one to the other)
10:34:22 <Philippa> and really my only complaint about that's that you can't write out the pointful version
10:34:37 <Philippa> (on account of lack of type-level lambdas)
10:34:41 <glguy> Philippa: I just mean that people can already write some mean looking code :)
10:35:15 <Philippa> the one I'd worry about is multiple codepoints that map to a single glyph...
10:35:22 <dfranke> Unicode is actually a nice touch when you're using an editor with decent math input methods (read: emacs)
10:35:32 <gour> ndm: where is that PropLang module?
10:35:44 <ndm> @where proplang
10:35:44 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
10:35:58 <ndm> gour: will add that to the web page, good point
10:36:00 <glguy> I think that as long as crazy symbols are kept out of the standard libraries
10:36:02 <Philippa> dfranke: exactly. And hey, it'd be nice to have lambda characters for object-language lambdas when I'm writing YA lambda calculus implementation
10:36:07 <glguy> Haskell will survive ;)
10:36:48 <Philippa> the std libs'll have a nasty decision to make there - whether or not to stick within the ASCII character set
10:37:13 <Philippa> hrmm. Standard libraries really do make an all-too-effective vector for software-transmitted diseases
10:37:15 <glguy> It would be a real shame if they started using characters that can't be typed by a normal keyboard
10:37:21 <dfranke> just make sure you have ASCII-7 aliases for everything.
10:37:28 <ndm> glguy: its really unfortunate if we don't have set operators looking like set operators...
10:37:47 <Philippa> dfranke: not necessarily good enough, you'd at a minimum also want tools to translate between the two
10:37:47 <ndm> although the standard libraries will probably have both \in and `elem`, for example
10:38:02 <ndm> can anyone tell me why Data.Set uses member, not elem?
10:38:04 <jgrimes> the standard libs I don't really think we have to worry about... since don't they have to remain backwards compat. up to a point?
10:39:05 <glguy> so when does GHC get unicode support?
10:39:25 <ndm> i believe it already has, or is in 6.6 at least...
10:39:31 <ndm> or at least they changed the default codepage
10:39:53 <jgrimes> and we could use a preproc on someone's code if it was useful and had a lot of unicode symbols :)
10:40:14 <glguy> 6.5 hasn't kicked over to 6.6 yet, has it?
10:40:30 <dfranke> one week away, I'm told.
10:41:02 <Philippa> ndm: presumably because it avoids retroactively changing a type in the Haskell 98 standard libraries
10:41:22 <Philippa> that, and there seems to be a rule of thumb that the standard libraries (at least the H98 ones) shouldn't exhibit any namespace clashes
10:42:12 <ndm> Philippa: but Data.Set exports null, \\, map etc
10:42:28 <Philippa> ah. Spot who hasn't used it...
10:42:41 <glguy> if you use Data.Set, aren't you expected to use it as qualified?
10:43:09 <ndm> indeed
10:43:18 <ndm> qualified is about hte only way to use it, or Data.Map
10:43:34 * glguy wonders if there is a unicode character for bottom
10:43:50 <ndm> there is
10:44:02 <ndm> undefined could become _|_ (in unicode)
10:44:10 <glguy> okay, I'm sold ;)
10:44:13 <jgrimes> â¥
10:44:15 <jgrimes> :)
10:45:29 <dcoutts__> @let â¥ = undefined
10:45:29 <lambdabot>  Illegal character ''\138''
10:45:55 <glguy> > '\22a5'
10:45:56 <lambdabot>  Improperly terminated character constant
10:45:56 <glguy> ?
10:46:02 <cjeris> @let ? = undefined
10:46:03 <lambdabot>  Parse error
10:46:16 <lightstep> i think Fortress has unicode syntax, with automatic ascii equivalents for all identifiers
10:46:47 <glguy> > let (+) = "does this work" in +
10:46:48 <lambdabot>  Parse error
10:46:49 <cjeris> ah, how sad, can't even type it in my client.  it was CJK UNIFIED IDEOGRAPH, that one with a Japanese on-yomi of 'mu' and meaning roughly 'negation'
10:46:51 <glguy> > let (+) = "does this work" in (+)
10:46:52 <lambdabot>  "does this work"
10:47:11 <glguy> so it would have to be (unicode bottom) instead of just unicode bottom?
10:47:30 <glguy> > let + = "does this work" in +
10:47:30 <lambdabot>  Parse error
10:47:35 <dcoutts__> glguy: depends if it's classed as an operator or not
10:47:54 <glguy> dcoutts__: and what would determine if it was?
10:48:09 <dcoutts__> the unicode property database
10:48:52 <glguy> is that a Haskell thing?
10:48:54 <glguy> or a unicode thing
10:49:25 <Limbic_Region> is Num -> Num a valid signature for a function?
10:49:40 <glguy> no
10:49:52 <lightstep> Num isn't a type
10:49:53 <glguy> Num a => a - > a   would be
10:50:06 <Limbic_Region> ahhh
10:50:09 <Limbic_Region> thanks
10:50:14 <lightstep> so would (Num a, Num b) => a -> b
10:50:33 <glguy> \u203C could be used for list indexing :)
10:51:12 <glguy> but I haven't found any fonts on my windows computer that have bottom
10:51:58 * Limbic_Region is just going through YAHT and is in ch. 4 with types and type classes
10:52:03 <dfranke> I wish Terminus supported more funny symbols.
10:52:22 <Limbic_Region> was thinking about what the signature for a function that could take in any number and return any number would look like
10:52:22 <glguy> me too, especialy since I use it exclusively for SSH
10:52:30 * Limbic_Region has a tendency to get ahead of the tutelage
10:55:14 <lightstep> what language is CANADIAN (in unicode)?
10:55:45 <emu> you mean, in localization?
10:56:22 <lightstep> a line from the unicode database: 1515;CANADIAN SYLLABICS SHA;Lo;0;L;;;;;N;;;;;
10:56:54 <twanvl> 1400..167F; Unified Canadian Aboriginal Syllabics
10:57:35 <bourbaki> moin
10:58:07 <lightstep> weren't aborigines from australia?
10:58:39 <twanvl> aboriginal = original inhabitant
10:59:17 <glguy> ?all-dicts aboriginal
10:59:18 <lambdabot> *** "Aboriginal" gcide "The Collaborative International Dictionary of English v.0.48"
10:59:18 <lambdabot> Aboriginal \Ab`o*rig"i*nal\, a. [See {Aborigines}.]
10:59:18 <lambdabot>   1. First; original; indigenous; primitive; native; as, the
10:59:19 <lambdabot>    aboriginal tribes of America. "Mantled o'er with
10:59:21 <lambdabot>    aboriginal turf." --Wordsworth.
10:59:23 <lambdabot> [51 @more lines]
10:59:54 <lightstep> oh, that's just my bad english
11:08:32 <glguy> is it possible to define a circular Enum?
11:08:46 <glguy> where if succ is called enough times, you eventually loop?
11:10:05 <glguy> would i just have to write my own instance of Enum?
11:11:05 <glguy> ?index Enum
11:11:05 <lambdabot> Prelude
11:11:55 <lightstep> glguy, it isn't one of the axioms in the Prelude, but many expect non-circularity
11:12:42 <glguy> I thought that you could only maybe expect that from a Bounded type
11:13:17 <svref> How do I write this so it ends up with type Int -> Int -> Int -> Double?: lidless fp sp eyes = 5/6 - ((1+eyes) * (5/6)^sp * (1 - (1+fp)/2^fp))
11:14:14 <glguy> liberal appliation of fromIntegral?
11:14:58 <svref> wrap every parameter name in a call to fromIntegral?
11:15:23 <glguy> ?type \fp sp eyes = 5/6 - ( (1 + fromIntegral eyes) * (5/6)^sp * (1 - (1 + fromIntegral fp) / 2 ^ fp))
11:15:24 <lambdabot> parse error on input `='
11:15:29 <glguy> ?type \fp sp eyes -> 5/6 - ( (1 + fromIntegral eyes) * (5/6)^sp * (1 - (1 + fromIntegral fp) / 2 ^ fp))
11:15:30 <lambdabot> forall a b a1 a2. (Integral a, Integral b, Integral a1, Fractional a2) => a1 -> b -> a -> a2
11:15:55 <lightstep> glguy, i would like to think that succ = toEnum . (+1) . fromEnum
11:16:38 <xerox> ?type fromEnum
11:16:39 <lambdabot> forall a. (Enum a) => a -> Int
11:20:12 <svref> oh, and how do I do 2^n where n is a double?
11:20:36 <glguy> ?type (**)
11:20:37 <lambdabot> forall a. (Floating a) => a -> a -> a
11:20:38 <gattocarlo> forall a. (Floating a) => a -> a -> a
11:21:05 <glguy> ?version
11:21:05 <gattocarlo> lambdabot 4p0, GHC 6.4.2 (Linux i686 1000MHz)
11:21:05 <gattocarlo> darcs get
11:21:05 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
11:21:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:21:08 <gattocarlo> Title: "Index of /~dons/lambdabot"
11:21:15 <glguy> Umm... you don't need two lambdabots
11:21:22 <glguy> or rather, we don't
11:27:47 <klaus33> what this does ? [n | n <- ns, n `mod` p > 0]
11:28:26 <glguy> it returns a lists of elements from ns which satisfy  n `mod` p > 0
11:29:05 <klaus33> what mod does ?
11:29:38 <glguy> modulus, its the remainder of the division
11:29:46 <glguy> > 7 `mod` 3
11:29:47 <lambdabot>  1
11:29:47 <gattocarlo>    Failed to load interface for `ShowQ':
11:29:47 <gattocarlo>     Could not find module `Sho...
11:29:52 <sieni> almost
11:30:29 <sieni> > -4 `mod' 9
11:30:30 <lambdabot>  Parse error
11:30:30 <gattocarlo>  Parse error
11:30:33 <sieni> vittu
11:30:38 <sieni> oops
11:30:41 <sieni> > -4 `mod` 9
11:30:42 <glguy> ok, it returns the number in a "modulus n field"?
11:30:42 <gattocarlo>    Failed to load interface for `ShowQ':
11:30:42 <lambdabot>  -4
11:30:43 <gattocarlo>     Could not find module `Sho...
11:30:49 <sieni> what?
11:31:35 <sieni> wtf? has haskell taken the definition of modulus out of its ass?
11:31:37 <glguy> > (-4) `mod` 9
11:31:37 <gattocarlo>    Failed to load interface for `ShowQ':
11:31:37 <gattocarlo>     Could not find module `Sho...
11:31:38 <lambdabot>  5
11:31:38 <xerox> gattocarlo: sei italiano?
11:31:43 <sieni> aa
11:31:45 <sieni> ok
11:31:46 <sieni> better
11:31:50 <glguy> > (-4) `rem` 9
11:31:51 <gattocarlo>    Failed to load interface for `ShowQ':
11:31:51 <gattocarlo>     Could not find module `Sho...
11:31:51 <lambdabot>  -4
11:34:07 <astrolabe> > let {ns = [1..];p = 3} in [n | n<-ns,n`mod` p > 0]
11:34:08 <gattocarlo>    Failed to load interface for `ShowQ':
11:34:08 <gattocarlo>     Could not find module `Sho...
11:34:08 <lambdabot>  [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40,...
11:35:10 <astrolabe> IS gattocarlo a bot?
11:35:11 <glguy> klaus33: are you looking at a primes seive?
11:35:16 <glguy> astrolabe: obviously :)
11:36:35 <glguy> int-e: you are on op, right?
11:36:41 <int-e> no
11:36:44 <glguy> bah
11:38:09 <glguy> int-e: I ask because..
11:38:10 <glguy> > ()
11:38:11 <gattocarlo>    Failed to load interface for `ShowQ':
11:38:11 <gattocarlo>     Could not find module `Sho...
11:38:11 <lambdabot>  ()
11:38:38 <int-e> I see.
11:38:48 <int-e> lambdabot: run ()
11:38:53 <int-e> lambdabot: @run ()
11:38:54 <lambdabot>  ()
11:39:09 <glguy> I tried /stats p, but everyone is away :)
11:43:45 <bringert> haha, if you google "interpreter swedish german" (no quotes), I'm in 4th place. I've never even tried interpreting between swedish and german
11:44:02 <bringert> www.cs.chalmers.se has some serious googlejuice
11:44:18 <glguy> The Swedish Alphabet ?
11:44:24 <basti_> lol
11:44:52 <glguy> # 2 is Björn Bringert Curriculum Vitae for me
11:46:58 <bringert> hmm, different versions of the index maybe
11:47:51 <bringert> I tried it because I've been getting some proposals for interpreting gigs out of the blue lately
11:48:01 <edwardk_> hehehe
11:48:10 <edwardk_> how many? =)
11:48:31 <klaus33> How can i move every letter 2 positions upwards in the alphabet. This is only valid for alpha characters and not for dots, spaces, etc. The character lookup also works circular. This means that an Y becomes an A and a Z becomes a B, etc. So a simple chr(ord(char)+2) wont cut it.
11:49:08 <basti_> tried a circular list?
11:49:15 <basti_> > cycle [1,2,3]
11:49:16 <gattocarlo>    Failed to load interface for `ShowQ':
11:49:16 <gattocarlo>     Could not find module `Sho...
11:49:16 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
11:49:26 <mauke> chr ((ord c - ord 'A' + 2) `mod` 26 + ord 'A')
11:49:52 <basti_> yea or that
11:49:57 <velco> how do I "read" an octal number ?
11:50:08 <velco> (read, in the sense String -> Int)
11:50:21 <sjanssen> @pl rot2 c = chr ((ord c - ord 'A' + 2) `mod` 26 + ord 'A')
11:50:22 <lightstep> > read "0377" :: Integer
11:50:22 <lambdabot> rot2 = chr . (ord 'A' +) . (`mod` 26) . (2 +) . subtract (ord 'A') . ord
11:50:22 <gattocarlo> rot2 = chr . (ord 'A' +) . (`mod` 26) . (2 +) . subtract (ord 'A') . ord
11:50:23 <lambdabot>  377
11:50:23 <gattocarlo>    Failed to load interface for `ShowQ':
11:50:23 <gattocarlo>     Could not find module `Sho...
11:50:38 <klaus33> Translate "rpylqjyrc" :P
11:50:45 <sjanssen> @. let pl rot2 c = chr ((ord c - ord 'A' + 2) `mod` 26 + ord 'A')
11:50:46 <gattocarlo> compose module failed: IRCRaised Parse error: "let"
11:50:48 <twanvl> > readOct "123"
11:50:49 <gattocarlo>    Failed to load interface for `ShowQ':
11:50:49 <gattocarlo>     Could not find module `Sho...
11:50:50 <lambdabot> Defined.
11:50:50 <lambdabot>  [(83,"")]
11:51:00 <sjanssen> > map rot2 ['a' ..]
11:51:01 <lambdabot>  Not in scope: `rot2'
11:51:01 <gattocarlo>    Failed to load interface for `ShowQ':
11:51:01 <gattocarlo>     Could not find module `Sho...
11:51:11 <glguy> > map L.rot2 ['a'..]
11:51:12 <gattocarlo>    Failed to load interface for `ShowQ':
11:51:12 <gattocarlo>     Could not find module `Sho...
11:51:12 <lambdabot>  "IJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDE...
11:51:17 <velco> yeah, I know of readOct and readHex, is this the rihgvt way ?
11:51:23 <sjanssen> okay, so who owns gattocarlo?
11:51:39 <int-e> lambdabot: > readInt 8 isOctDigit digitToInt "177" ""
11:51:47 <int-e> lambdabot: @run readInt 8 isOctDigit digitToInt "177" ""
11:51:47 <lambdabot>    The function `readInt' is applied to five arguments,
11:51:48 <lambdabot>   but its type `a...
11:51:52 <velco> having to write something like let (val,_):_ = readOct "126512" seems a bit gross
11:51:53 <glguy> sjanssen: the braintrust that owns him probably doesn't know that it's joined #haskell
11:52:00 <lightstep> gattocarlo, @vixen who 0wns u?
11:52:00 <gattocarlo> i dunno, who?
11:52:06 <int-e> lambdabot: @run readInt 8 isOctDigit digitToInt "177"
11:52:07 <lambdabot>  [(127,"")]
11:52:19 <edwardk> gattocarlo: @version
11:52:20 <gattocarlo> lambdabot 4p0, GHC 6.4.2 (Linux i686 1000MHz)
11:52:20 <gattocarlo> darcs get
11:52:36 <edwardk> lambdabot: @version
11:52:36 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
11:52:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:52:39 <gattocarlo> Title: "Index of /~dons/lambdabot"
11:53:12 <int-e> readInt is in the Numeric module btw. the other two functions should be in Data.Char
11:53:13 <sjanssen> anybody with lambdabot op privileges?  I'm guessing gattocarlo's keeper didn't change the list
11:53:23 <lightstep> it's only on #haskell
11:53:46 <gour> who is the owner of gattocarlo (it says Lambda_Robots:_100%_Loyal)
11:54:01 <mauke> it might belong to someone called "Andrea Rossato"
11:54:16 <int-e> that's the lambdabot default
11:55:26 <lightstep> gattocarlo, @quit
11:55:27 <gattocarlo> Not enough privileges
11:55:34 <lightstep> damn
11:55:50 <gour> mauke: the one who posts a lot in the recent time
12:07:00 <glguy> ?version
12:07:01 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
12:07:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:07:05 <newgattocarlo> sorry for the previous mess
12:07:21 <newgattocarlo> I was trying to get lambdabot to work....
12:07:31 <newgattocarlo> ...with no results, obviously...
12:07:42 <newgattocarlo> ...and sorry for posting too much, lately...
12:07:58 <sjanssen> newgattocarlo: well, your lambdabot was definitely working!
12:08:04 <glguy> not well
12:08:18 <glguy> just enough to connect to the channel and run ?vixen and ?version :)
12:08:32 <glguy> and to throw lots of ShowQ errors
12:08:37 <int-e> all that was missing was copying the ShowQ module to where runplugs would find it
12:08:48 <int-e> because that's not done by cabal.
12:09:01 <newgattocarlo> and why is it working offline?
12:09:06 <int-e> but #haskell isn't the ideal place to test it.
12:09:35 <newgattocarlo> int-e: you're right, but i didn't know it was not working...
12:09:43 <int-e> it's just @run (>) that's missing.
12:09:44 <newgattocarlo> i found out looking at the logs
12:09:51 <int-e> it conflicts with lambdabot, too.
12:10:08 <int-e> @botsnack
12:10:08 <lambdabot> :)
12:10:55 <xerox> newgattocarlo: italiano?
12:11:52 <newgattocarlo> si
12:12:05 <xerox> Ciao :) C'Ã¨ #haskell.it se vuoi!
12:12:19 <glguy> take it to #haskell-it please ;)
12:12:36 <xerox> It's '.it'
12:12:49 <newgattocarlo> i'm there...
12:12:53 <glguy> heh
12:13:07 <gour> anyone for #haskell.hr ?
12:46:56 <vincenz> @where yaht
12:46:56 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
12:47:26 <gour> night folks
14:22:00 <dcoutts__> musasabi: we're having trouble building hsgnutls with ghc 6.6
14:22:57 <dcoutts__> src/Network/GnuTLS/Attributes.hs:94:8:
14:22:57 <dcoutts__>     Couldn't match kind `?' against `* -> *'
14:23:25 <dcoutts__> something odd going on there, probably due to a change in how functional deps are done
14:23:37 <yip> cool, there is gnutls for haskell? :O what about openssl?
14:23:51 <dcoutts__> interestingly it's my code originally according to the copyright :-)
14:23:59 <dcoutts__> I can't see how to fix it though :-)
14:24:16 <dcoutts__> yip: I think openssl has a problematic license
14:24:17 <monochrom> Did you comment the code? :)
14:24:26 <dcoutts__> nope
14:24:30 <monochrom> Ha!
14:24:36 <dcoutts__> it's been changed since I wrote it
14:25:02 <dcoutts__> using more functional deps
14:25:09 <monochrom> Still, old proverb: "six months later you will not recognize your own code" :)
14:25:17 <dcoutts__> indeed
14:25:26 <dcoutts__> I was suprised to find it
14:25:55 <dcoutts__> actually, it is commented, just not in a useful way to see why we're getting this failure
14:29:24 <satan> this is off topic, but does anyone know a place or forum or room for discussin image processing with matlab?
14:29:38 <vincenz> satan: #matlab?
14:29:44 <satan> yah empty :(
14:30:54 <vincenz> oh
14:31:57 <glguy> ?hoogle showIntAtBase
14:31:57 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
14:32:45 <Lemmih> Hi SyntaxNinja.
14:32:53 <dcoutts__> g'evening SyntaxNinja
14:33:25 <dcoutts__> SyntaxNinja: btw, I put out another cabal RC tarball
14:33:41 <SyntaxNinja> y0
14:33:43 <SyntaxNinja> dcoutts__: sweet
14:33:46 <SyntaxNinja> hi Lemmih
14:33:59 <SyntaxNinja> dcoutts__: announcy?
14:34:08 <dcoutts__> I could do I suppose
14:34:16 <dcoutts__> to ghc-users & libs
14:34:24 <dcoutts__> "please test"
14:34:41 <dcoutts__> we've been testing it with the gentoo ebuilds
14:35:01 <SyntaxNinja> cabal-devel would be a fine choice, methinks.
14:35:13 <dcoutts__> @arr
14:35:13 <lambdabot> Avast!
14:36:02 <SyntaxNinja> september 19th, man.
14:36:40 <vincenz> ?
14:36:56 <vincenz> icfp?
14:38:50 <newsham> > (.)(.)(+) 1 (* 2) 3
14:38:51 <lambdabot>  7
14:38:59 * edwardk 's head hurts.
14:39:42 <newsham> > (+) ((* 2) 3) 1
14:39:43 <lambdabot>  7
14:39:43 <edwardk> Moving from dependent products to dependent sums means I wind up with tuples of mixed type. Weird. =)      (1,Int) anyone? =)
14:40:55 <newsham> > (.)(.)(.) (* 2) (+) 3 4
14:40:56 <lambdabot>  14
14:42:26 <dcoutts__> SyntaxNinja: done
14:43:44 <newsham> > (.)(.)(.)(.) (\x y z -> x*x + y*y + z*z) 2 3 (+) 4
14:43:45 <lambdabot>  add an instance declaration for (Num (a -> a))
14:44:28 <edwardk> er i should say, mixed sorts
14:44:41 <edwardk> so (1,*,Int,Bool,Int -> Int)
14:44:47 <newsham> > (.)(.)(.)(.) (\x y z -> x*x + y*y + z*z) 2 3 (+ 4) 5
14:44:48 <lambdabot>  94
14:45:19 <monochrom> very mixed up :)
14:45:30 <edwardk> mono: heh
14:45:46 <edwardk> it makes sense in the appropriate context, really =)
14:47:27 <edwardk> trying to see what the appropriate solution is for dependent types in a dual calculus. dependent product types (Pi in classic pure type systems) fail coz functions never return, so the only way I can construct them is by negating sum types
14:48:23 <edwardk> relying on adjoint functor-ness of (,) and (->) to yield similar connections
14:48:30 <edwardk> in the dependent function spaces.
14:51:31 * edwardk goes quiet and returns to puttering ;)
15:00:04 <vincenz> NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
15:00:20 <Cale> NEWWWWWWWW
15:00:26 <vincenz> blegh
15:00:29 <vincenz> changed one line in my paper
15:00:36 <vincenz> and now i have two references spilling on pgage 7
15:00:50 <vincenz> Curse you latex!
15:05:25 <mahogny> add more references and soon page 7 is motivated
15:07:05 <vincenz> you can only have 6 pages
15:07:15 <vincenz> heh
15:07:21 <vincenz> two columns full of reference
15:07:22 <vincenz> LOL
15:07:31 <vincenz> reminds me of this one paper with 168 authors
15:07:37 <Patterner> use shorter words.
15:08:07 <Codex_> cut content..
15:08:17 <twanvl> change the margin size
15:08:17 <mahogny> cut author names
15:08:35 <Patterner> use a4 instead of letter
15:08:42 <mahogny> letter. omg
15:08:52 <twanvl> use a3 instead of a4
15:09:14 <Codex_> use smaller font
15:09:15 <mahogny> accidentaly forget references and hope they never check?
15:09:22 <vincenz> there are no author names
15:09:35 <vincenz> I'll have to reword some content
15:09:39 <vincenz> hope I can shave off a line here and there
15:10:03 <vincenz> the problem is that it's not doing exactly what I want, I have a small code sample, and it puts a lot of whitespace around it, even when I \vspace*{-0.25cm} it
15:10:25 <Patterner> \baselineskip{0.01}
15:10:37 <vincenz> ?
15:11:06 <vincenz> complains on that
15:11:21 <Patterner> it was a joke
15:11:26 <vincenz> anyways, that code sample was annoying, before it'd either put it almost against the text, or with lots of whitespace, no matter what the vspace
15:12:33 <Patterner> \setlength{\baselineskip}{1pt} % that's the correct syntax
15:13:06 <vincenz> woah
15:13:10 <vincenz> screws up the entire paragraph
15:13:12 <vincenz> and changes the font
15:13:16 <vincenz> but seems to be it yes
15:13:49 <vincenz> how do I set it back to normal
15:13:55 <vincenz> it screws up the paragraph after it
15:15:55 <Patterner> set it back to 12pt (or put it in {})
15:16:27 <vincenz> hmm
15:16:33 <vincenz> if I put it in {} it shows the previous behaviour
15:16:39 <vincenz> of putting the code far from the text
15:16:44 <vincenz> something is wrong with these coded environments
15:16:55 <vincenz> (lstenvironment)
15:17:31 <vincenz> grr, that doesn't do it
15:17:35 <vincenz> it's like a half-floating box
15:18:19 <Patterner> \begin{article}{\small ... }\end{article} % :)
15:18:40 <vincenz> hehe
15:19:35 <vincenz> doubt they'd like that
15:20:38 <jenner> heya
15:22:05 <jenner> guys, I'm skimming through some primers and tutorials and wondered what's the most commonly used interactive interpreter on *nix systems? ghci? hugs?
15:22:15 <vincenz> lambdabot!
15:24:52 <int-e> good question. it's hugs or ghci. :)
15:24:52 <xs> jenner, perhaps hugs whilst learning haskell, but afterwards ghci has a lot more to offer...
15:25:46 <jenner> xs: ok, thanks
15:26:07 <JosephRivers> is there a more concise way to construct an array that contains one repeated element than array (0,10) [0, i <- [0..10]]?
15:26:20 <jenner> I'm already stuck with ghci, since it seems to have a different syntax then the one used in most tutorials
15:26:38 <thetallguy> what trouble are you having?
15:27:25 <thetallguy> I always use ghci
15:28:12 <jenner> thetallguy: well, I can't make a function declaration (I know it's not always needed, but anyway) - stuff like "foo :: Int -> Int" just throws an error
15:29:10 <xs> ah. you'll want to put those declarations in a separate file, and then load them into the interpretter
15:29:25 <xs> s/tt/t/
15:29:37 <xs> hugs works like this too?
15:31:02 <thetallguy> Or you can just omit them
15:31:07 <thetallguy> > let foo x = x * x
15:31:07 <lambdabot>  Parse error
15:31:10 <jenner> hm... it's been ages since I touched hugs, I've forgotten almost everything, but iirc you could declare a function in the interactive shell
15:32:01 <thetallguy> But as xs says, put those declarations in a file and load it.
15:32:10 <thetallguy> :l foo.hs
15:32:14 <thetallguy> for exmaple
15:32:22 <thetallguy> Are you an emacs user?
15:32:40 <jenner> thetallguy: nope, I'm on the other side :)
15:32:49 <JosephRivers> is there really really no better way to construct a list of n repeated elements than something like [0 | i <- [0..n]]?
15:32:50 <jenner> Hugs.Base> let length [] = 0
15:32:50 <jenner> ERROR - Syntax error in expression (unexpected end of input)
15:33:21 <thetallguy> JR: sure
15:33:41 <thetallguy> >take 10  $ repeat  3
15:33:55 <JosephRivers> okay, cool thx
15:33:58 <thetallguy> > take 10 $ repeat 3
15:33:59 <lambdabot>  [3,3,3,3,3,3,3,3,3,3]
15:34:22 <xs> > replicate 10 0
15:34:23 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
15:34:54 <thetallguy> Jennery, I'm not sure about Hugs.  Never use it.
15:35:05 <thetallguy> By other side, you mean vim?
15:35:11 <jenner> thetallguy: yes
15:35:32 <thetallguy> http://www.haskell.org/libraries/hs.vim
15:36:00 <thetallguy> I assume this has something like the emacs mode
15:36:19 <thetallguy> edit the file, then run the command to load it into the interpreter
15:36:51 <thetallguy> emacs will start up another buffer with ghci running inside it and automatically load the file.  Then the symbols are available to you.
15:37:42 <thetallguy> contents of foo.hs: foo x = x * x
15:38:00 <thetallguy> Prelude> :load "/home/beshers/haskell/missingh/MissingH/foo.hs"
15:38:00 <thetallguy> Compiling Main             ( /home/beshers/haskell/missingh/MissingH/foo.hs, interpreted )
15:38:00 <thetallguy> Ok, modules loaded: Main.
15:38:00 <thetallguy> *Main>
15:38:15 <thetallguy> Effect of C-c C-l in haskell mode (emacs)
15:38:28 <thetallguy> *Main> foo 10
15:38:28 <thetallguy> 100
15:38:51 <newbcoder> why does haskell habve this existential type???
15:39:02 <newbcoder> it sounds like it's schemde's dynamic typing
15:39:10 <thetallguy> I  do that and then use quickcheck to build a test suit, and run the test suite.
15:39:34 <Cale> newbcoder: Not quite, it's a lot safer than dynamic typing.
15:39:36 <heatsink> newbcoder, existential types are more like C++ dynamic typing (without downcasting).
15:40:37 <heatsink> You have no idea what type (subclass, in C++) is contained in it, but you can still call some functions (the base class member functions, in C++) on the data.
15:40:54 <Cale> newbcoder: I'd say it's rather like the OO abstraction -- you only know that the value provides a given interface, and not what data actually is there. (Again, without the possibility of downcasting to recover the original values)
15:41:16 <Cale> (so I agree with heatsink :)
15:41:42 <newbcoder> why is it an haskell extentison?
15:41:50 <newbcoder> can it not be implmented in terms of the original haskell stuff?
15:42:06 <Cale> That's right, it can't.
15:42:15 <newbcoder> is this still consistent with the whole haskell being pure; statically typed; mathematically rigrous ideals?
15:42:17 <thetallguy> I blieve it was because it was  developed after Haskell 98 was frozen
15:42:21 <Cale> You'd have to pass around explicit dictionaries.
15:42:24 <newbcoder> (not tryikng to be a jerk; just curious)
15:42:31 <Philippa> it's entirely consistent with it
15:42:32 <Cale> yes, it is consistent with that
15:42:58 <Philippa> it's a reasonably lightweight encoding of the mathematically "obvious" way to type it
15:43:08 <Cale> All it lets you do is throw away information about the type of a value, along with your privileges to access that value in various ways.
15:44:19 <Cale> If all you know about a value is that it's of some type in Show, all you can do with it is show it (and the other minor variants of that from the Show class)
15:44:44 <newbcoder> is there certain things that I absolutely need existential types to do?
15:44:56 <newbcoder> or are they just syntacticac sugar?
15:45:05 <Philippa> there are things you absolutely need them to do
15:45:16 <newbcoder> like what?
15:45:24 <Cale> Well, not *really*, since you could sort of do them by hand, but it makes certain program designs convenient and usable instead of horribly clunky.
15:45:41 <Philippa> if you really insist they're syntactic sugar for something involving a big type that can't be generated until you start compiling Main
15:46:00 <heatsink> I haven't wanted to use them yet, so I'm curious what they're good for too.
15:46:04 <jenner> thetallguy: great, loading the code from files works much better, thanks
15:46:24 <Philippa> so you couldn't write libraries involving the encoding because you wouldn't know about Main and/or other use sites that could use types you don't know about yet
15:46:39 <Philippa> much like parametric polymorphism adds to the expressiveness in the first place
15:46:52 <Philippa> (exactly so: it's an encoding of the dual structure)
15:47:15 <Cale> Philippa: couldn't you replace existentially quantified values with the requisite typeclass dictionaries?
15:47:37 <Philippa> not in H98
15:47:43 <Philippa> you could do it in System F
15:48:12 <Philippa> but you can't even type the dictionary for a polymorphic type, for example
15:48:22 <Cale> hmm
15:48:43 <Philippa> that is, you can't in H98. Predicativity
15:51:19 <vincenz> Heya Philippa
15:52:57 <vincenz> Anyone here publishing in the functional world
15:53:07 <edwardk> bbiab, driving home
15:53:14 <vincenz> if I shorten Functional Programming Languages and Computer Architectuore to FPLCA
15:53:17 <vincenz> will people know it?
15:53:44 <Philippa> I wouldn't without an expansion somewhere
15:53:52 <Philippa> I'm not publishing, of course
15:54:50 <heatsink> Functional compute architecture -- that's what we need. Recursive datapaths are the future!
15:55:02 * heatsink hasn't heard of that publication before.
15:55:16 <vincenz> Philippa: working to remove the last two lines of my paper, it's 6 pages and 2 references on the 7th
15:55:23 <heatsink> but I don't read FP-related publications much.
15:56:43 <vincenz> Anyone know how to move the "References" header up further?
15:56:43 <monochrom> There are better ways of shrinking two lines.
15:56:47 <vincenz> monochrom: like what
15:56:53 <vincenz> monochrom: that just gained me a line
15:57:07 <monochrom> Fudge with spacing and font size.  Even a 2% reduction does the job.
15:57:28 <heatsink> You're usually not allowed to do that though
15:57:46 <vincenz> monochrom: I am fudging with spacing, but that's not enough
15:58:06 <vincenz> heatsink: I moved all my headers closer to the text
15:58:28 <heatsink> ok
15:59:53 <vincenz> For some stupid reason
16:00:00 <vincenz> \vspace*{} does not always have effect
16:00:12 <vincenz> for instance there's an X-load of whitespace aroun dmy Conclusion header
16:00:59 * heatsink no longer tries to understand how latex actually works.
16:01:09 <vincenz> it's supposedly a programming language
16:01:12 <vincenz> which are supposedly causal
16:01:41 <heatsink> I've noticed that it'll sometimes insert extra whitespace to avoid splitting paragraphs across pages.
16:02:02 <vincenz> Ah
16:02:10 <vincenz> it would move up the References headline to the next page
16:02:14 <vincenz> without references
16:02:24 <vincenz> and I guess it doesn't like putting a section without some content at the bottom
16:02:35 <Philippa> you could fudge the other way?
16:02:43 <Philippa> or is there a six page limit?
16:02:54 <vincenz> yeah
16:03:02 <vincenz> heh
16:03:07 <vincenz> my paper was originally a full 7 pages :)
16:03:28 <vincenz> is it permissible to cut words of references?
16:03:32 <vincenz> meaning, shorten them?
16:03:56 <Philippa> you can cut them from quotes by replacing them with an ellipsis
16:04:12 * vincenz doesn't have quote
16:04:13 <vincenz> s
16:04:35 * vincenz grumbles
16:04:39 <vincenz> if only this white space was gonoe
16:05:03 <vincenz> How do I force it to not want to bundle the "References" with at least several references, so it would move up to the previous column?
16:15:33 <dibblego> guten tag
16:16:16 <dibblego> http://www.willamette.edu/~fruehr/LLC/lab1.html can anyone provide any hints for problem 6? I humbly admit that I fail to produce a result in thought experiment
16:16:18 <lambdabot> Title: CS 451/LLC Lab 1: Basic Haskell Exercises, http://tinyurl.com/o2c4t
16:16:45 <AtnNn> what have you tried?
16:17:10 <dibblego> well, not much in terms of code - I have tried to think it out for quite some time to no avail
16:17:32 <dibblego> I have tried various combinations with map filter and words functions
16:17:53 <dibblego> but what I have before me is not much
16:18:22 <dibblego> it's not homework by the way - it's just a random web page that I decided to use to play with Haskell
16:18:34 <jgrimes> have you looked at unwords?
16:18:42 <dibblego> yes I have
16:18:49 <AtnNn> have you used zip before?
16:18:54 <dibblego> no
16:19:07 <dibblego> but I figured it might help - I wasn't sure - do you think it can?
16:19:13 <AtnNn> yeah
16:19:28 <dibblego> ok, I'll give it another go
16:19:35 <dolio> dibblego: Are you still trying to make the one-line solution? :)
16:20:04 <dibblego> dolio, I actually spent about an hour, then spent many hours trying to think it up and here I am the next day :)
16:20:19 <dibblego> I'm sure it's because I have been using imperative languages for years
16:20:33 <dibblego> to my detriment it seems in this case
16:20:45 <dolio> Using just map, filter and words you probably won't come up with a single line solution.
16:20:56 <dolio> At least, it'd be a hairy one.
16:21:05 <dibblego> it doesn't necessarily have to be one line
16:21:17 <dibblego> I have written various functions to attempt it
16:21:26 <dibblego> or just to help think about it mostly
16:21:56 <dolio> Well, what you want to do, is go over the list and find the maximum word length...
16:21:57 <dibblego> zip :: [a] -> [b] -> [(a, b)] I can't see how that will help
16:22:17 <dolio> And then filter on the length of the words.
16:22:22 <dibblego> dolio, yes I thought of doing it by going over the list twice (find the maximum length, then filter those that don't meet that length)
16:22:37 <dibblego> it is possible with one pass though surely
16:22:49 <dibblego> or maybe that's not the right way to think
16:22:52 <monochrom> longest "hi hello hello" = ?
16:23:00 <dibblego> "hello hello"
16:23:17 <monochrom> Yes, one pass is possible and also quite cute.
16:23:18 <dibblego> I think (I don't know how duplicates are handled)
16:23:33 <heatsink> dibblego, That's possible with one pass using fixed point code.  Fixed point is hard to get used to.
16:23:34 <dolio> Well, it is possible to do it in one pass, I'm sure, but it'd involve keeping a lot more state around.
16:23:56 <heatsink> or... "tying the knot" I guess it's called.
16:24:04 <dibblego> ok, so it's easier with two passes - I'll do that first
16:24:15 <dibblego> then I'll figure out wtf fixed point code is
16:24:25 <dolio> In one pass, it'd probably be a fold.
16:24:51 <monochrom> Only state: best length seen so far, and list/set of words of that length.  Whenever you see an even longer word, update "best length seen so far", and of course clear your list/set of memorized words in favour of your new discovery.
16:25:03 <dolio> That would produce a tuple with the max length so far, and a list of words of that length.
16:25:08 <heatsink> oh, monochrom is right.
16:25:09 <monochrom> You can easily functionalize my stateful description.
16:25:20 <dolio> And if you found a new max length, you'd throw the list away, and start a new one with the longer word.
16:25:25 <dibblego> monochrom, yes that is how I thought of it initially, but failed to substantiate it with Haskell
16:25:32 <monochrom> list/set <--- the choice depends on what you want with "hi hello hello".
16:25:53 <dibblego> let's assume "hello hello" since I am more familiar with list
16:25:59 <monochrom> OK, keep working on that, because it's a right approach.
16:26:14 <monochrom> ["hello", "hello"] you mean.
16:26:16 <dibblego> got any hints?
16:26:20 <dibblego> yeah I mean that
16:26:38 <monochrom> Write imperatively, then functionalize, if this works for you.
16:26:59 <dibblego> I could write it in C or Java in 30 seconds, but I don't think that's a right approach
16:27:15 <sris> Could someone point me in the right direction if i want a "nice" way of substituting wildards in a string, with another string, like sub '*' "my name is *" "foo" would return, "my name is foo"
16:27:56 <sris> i've tried som recursive stuff with takeWhile, and dropWhile ;)
16:28:21 <sris> it works, but it feels ugly ;) And i want to learn the "real" haskell way to do things
16:28:57 <dibblego> monochrom, is it possible to provide a hint without revealing an answer?
16:28:58 <heatsink> sris: Try making a function that only replaces the wildcard if it appears at the beginning of the string.  Then use that recursively to replace the whole string.
16:29:01 <dolio> dibblego: In one pass, map/filter won't work. It needs to be foldl/foldr.
16:29:09 <dibblego> dolio, ok
16:29:31 <dibblego> dolio, are you sure that foldl/foldr will work with one pass?
16:30:02 <twanvl> you could also use concatMap
16:30:43 <dolio> Yes, if you use a function like monochrom described above.
16:31:04 <dibblego> ok cheers
16:31:25 <dibblego> what's the difference between foldl and foldl' ?
16:31:34 <dibblego> or, what does a "strict version" mean?
16:31:40 <dolio> foldl' is strict in its accumulator.
16:31:57 <dolio> So you won't get stack overflows due to the accumulator being lazy.
16:32:00 <dibblego> does that somehow affect the result?
16:32:18 <dibblego> ok, I hope that makes sense to me one day :)
16:32:22 * edwardk wanders back in
16:32:28 <dolio> Well, for example...
16:32:37 <dolio> foldl (+) 1 [1..10]
16:32:48 <dolio> That does, essentially, 1 + 1 + 2 + 3 + ...
16:33:11 <dolio> Accumulating as it goes along.
16:33:37 <dolio> So it adds 1 + 1 -> 2, and calls tail recursively for foldl (+) 2 [2..10]
16:33:58 <dolio> But since haskell is lazy by default, 1 + 1 -> 2 doesn't get evaluated right away.
16:34:29 <dolio> It just gets stored as a thunk/closure, which contains a reference to the [1..10] list and so on.
16:34:50 <dolio> So for big lists, you end up using lots of memory, when instead you could reduce all of that to a single number.
16:35:07 <dibblego> ah so, foldl' reduces it to a single number straight away?
16:35:14 <dolio> foldl' evaluates the 1 + 1 right away, so there's no overhead like that.
16:35:23 <dibblego> and that's called "strictness"/
16:35:24 <dibblego> ?
16:35:40 <dmwit> I thought that was called eagerness?
16:35:53 <dolio> More or less.
16:36:01 <dibblego> well, the documentation for foldl' says "a strict version of foldl"
16:36:05 <dolio> There are a couple ways of defining strictness.
16:36:52 <dolio> f is strict if its arguments are evaluated before the function is called (or something like that).
16:36:56 <dibblego> <monochrom> Only state: best length seen so far, and list/set of words of that length.
16:37:11 <dolio> Or, f is strict if  f _|_ = _|_
16:37:14 <dibblego> that seems redundant - best length seen so far is a function of list/set of words
16:38:00 <heatsink> It's somewhat easier to store the best length instead of recalculating it from the set of words each time you want the value.
16:38:07 <dibblego> ok
16:39:21 <SamB> well, if your sets store length, it isn't so bad ;-)
16:39:50 <dolio> Not length of the set, length of the words in the set.
16:40:36 <dibblego> the length of the words in the set will be consistent
16:42:19 <dibblego> on the first pass, storing ["the"] and 3 is redundant, the second pass storing ["biggest"] and 7 is also redundant, etc. - but if it makes it easier, I won't worry about it
16:46:11 <dibblego> "storing state" means passing as parameters recursively right?
16:47:14 <dolio> Right.
16:49:11 <dmwit> @where paste
16:49:11 <lambdabot> http://paste.lisp.org/new/haskell
16:50:48 <dibblego> f [a] = length $ head a -- what is the type of function f?
16:50:49 <lisppaste2> dmwit pasted "possible solution?" at http://paste.lisp.org/display/25921
16:51:01 <dmwit> dolio: are you thinking something like this?
16:51:30 <dmwit> dibblego: try f a = ...
16:51:32 <dibblego> f :: [[Char]] -> Int -- if I declare it like this I get a compile-time error
16:51:40 <dolio> dmwit: Yeah.
16:51:48 <dibblego> ah thanks
16:52:00 <heatsink> @type \[a] -> length $ head a
16:52:01 <lambdabot> forall a. [[[a]]] -> Int
16:53:11 <dibblego> @type \a -> length $ head a
16:53:13 <lambdabot> forall a. [[a]] -> Int
16:57:19 <dmwit> @users
16:57:25 <lambdabot> Maximum users seen in #haskell: 242, currently: 209 (86.4%), active: 34 (16.3%)
16:59:54 <dmwit> So, do functors have kind * -> * -> *?
17:00:13 <dolio> ?kind IO
17:00:14 <lambdabot> * -> *
17:00:27 <dmwit> Hmm...
17:00:29 <heatsink> @kind Either
17:00:30 <lambdabot> * -> * -> *
17:00:31 <jgrimes> > let inf = inf in let alwaysseven n = 7 in alwaysseven inf
17:00:32 <lambdabot>  7
17:00:48 <dolio> Either e is a functor, not Either.
17:01:11 <heatsink> yea.
17:01:19 <monochrom> Either is a bifunctor XD
17:01:29 <dolio> :)
17:01:38 <heatsink> :7
17:01:56 <dolio> Speaking of bifunctors... I've been trying to read the bananas... paper...
17:02:24 <dolio> Too many parts are just long strings of symbols. My eyes glaze over. :)
17:02:42 <dmwit> =P
17:02:56 <dolio> I need to go back and learn some category theoy basics first, I think, so I have an idea of what they're talking about already.
17:03:04 <dolio> I don't think teir 2-page intro cuts it.
17:03:08 <dolio> Their, even.
17:04:07 <vincenz> Woot
17:04:08 <vincenz> at last
17:04:11 <vincenz> 6 pages
17:04:12 <dibblego> http://paste.lisp.org/display/25921 what is the type of the acc function?
17:04:38 <kpreid> dibblego: ghci can tell you
17:04:55 <dolio> acc :: [a] -> (Int, [[a]]) -> (Int, [[a]])
17:05:02 <dmwit> Well, something like [Char] -> (Int, [[Char]]) -> (Int, [[Char]])
17:14:07 <dmwit> Argh.
17:14:10 <dmwit> Okay, new question.
17:14:13 <dmwit> @kind Functor
17:14:14 <lambdabot> Class `Functor' used as a type
17:14:53 <dmwit> ...
17:14:56 <dmwit> =(
17:16:15 <dolio> ?kind []
17:16:16 <lambdabot> * -> *
17:17:36 <dmwit> @kind Functor []
17:17:37 <lambdabot> Class `Functor' used as a type
17:17:45 <dolio> ?instances Functor
17:17:46 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:17:51 <kpreid> dmwit: Do you want to know why classes can't be used like types?
17:18:11 <dmwit> Yeah, I'm still slogging my way through the differences...
17:18:32 <kpreid> dmwit: Consider (+).
17:18:34 <kpreid> @type +
17:18:35 <lambdabot> parse error on input `+'
17:18:37 <kpreid> @type (+)
17:18:38 <lambdabot> forall a. (Num a) => a -> a -> a
17:18:59 <kpreid> dmwit: + takes any Num, as long as all three are the *same* Num.
17:19:32 <kpreid> If you wrote Num -> Num -> Num, there would be no way to know whether you meant three identical instances of Num or three different ones.
17:19:45 <kpreid> So it's expressed as a restriction on a type variable.
17:20:09 <kpreid> @kind Functor a => a
17:20:10 <lambdabot>   `a' is not applied to enough type arguments
17:20:11 <lambdabot>   Expected kind `*', but `a' has kind `* -> *'
17:20:15 <Pseudonym> There are actually only a very small number of operations that make sense on Num as a type.
17:20:31 <heatsink> I thought the kind would be * -> * because the type of (+) is determined by exactly one type.
17:20:51 <Pseudonym> Anything that's realisable as a value has kind *.
17:20:56 <heatsink> I mean, the actual function executed by (+) depends on one type.
17:21:08 <dmwit> @kind (+)
17:21:09 <lambdabot> Not in scope: type variable `+'
17:21:17 <newsham> ?quickcheck
17:21:17 <lambdabot> Unknown command, try @list
17:21:20 <newsham> @list
17:21:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:21:30 <Pseudonym> showNum :: Num -> String
17:21:30 <heatsink> Oh, but that doesn't determine the kind of Num.
17:21:39 <Pseudonym> In think that's actually the only operation that makes sense on a Num alone.
17:21:46 <Pseudonym> Oh, yeah, fromInteger :: Integer -> Num
17:21:56 <Pseudonym> And obviously shows, showsPrec.
17:22:12 <Pseudonym> @kind (->)
17:22:14 <lambdabot> ?? -> ? -> *
17:22:23 <Pseudonym> Think of that as * -> * -> *
17:22:35 <newsham> ?check \x (y :: Int) -> let assoc f = f a b == f b a in f (+)
17:22:36 <lambdabot>  Parse error in pattern
17:22:44 <Pseudonym> The ? and ?? are artificial; they're there to implement unboxed types.
17:22:47 <newsham> ?check \x (y :: Int) -> let assoc f = f a b == f b a in assoc (+)
17:22:47 <lambdabot>  Parse error in pattern
17:22:49 <Pseudonym> You can ignore them.
17:23:11 <heatsink> @type unsafeCoerce#
17:23:12 <lambdabot> Not in scope: `unsafeCoerce#'
17:23:19 <dibblego> no, there are more operations on type Num depending on if you call a Num an axiom of software - if you do, then there are no more operations, if you don't, you are free to call a bit an axiom, and therefore, there is an operation of extracting each bit from a Num
17:24:32 <dibblego> just like a String is a [Char], a Num is a [Bit]
17:25:22 <newsham> ?check \x y -> x + y == y + (x :: Int)
17:25:23 <lambdabot>  OK, passed 500 tests.
17:25:26 <Pseudonym> I'm talking about the typeclass Num.
17:25:31 <dmwit> Oooo... thanks, kpreid.
17:25:34 <Pseudonym> [Bit] is unhelpful.
17:25:49 <Pseudonym> Because a sequence of bits depends highly on how you interpret it.
17:25:56 <dibblego> I'm referring to any particular instance of the Num typeclass
17:25:58 <Pseudonym> The same 64 bit sequence might be a Word64 or a Double.
17:26:07 <dibblego> a sequence of chars depends entirely how you interpet it
17:26:09 <Pseudonym> Both of which are models for Num.
17:26:16 <newsham> ?check \x y -> x - y == y - (x :: Int)
17:26:17 <lambdabot>  Falsifiable, after 0 tests: 0, 1
17:26:20 <Pseudonym> I dissent in part.
17:26:26 <Pseudonym> A String is a sequence of characters.
17:26:26 <dibblego> an integer is a function of a sequence of bits, just like a String is a function of a sequence of chars
17:26:35 <Pseudonym> A Num, in general, has more structure.
17:26:52 <Pseudonym> The logical structure of an Integer is quite different from a Dual Quaternion.
17:26:55 <Pseudonym> Or a Matrix.
17:26:57 <dibblego> that structure is entirely superficial
17:27:12 <emu> a string needs localization too
17:27:12 <newsham> ?check \x y -> let assoc f = f x y = f y (x :: Int) in assoc (+)
17:27:13 <lambdabot>  Parse error
17:27:20 <emu> or is this the wrong discussion for that
17:27:21 <newsham> ?check \x y -> let assoc f = f x y == f y (x :: Int) in assoc (+)
17:27:22 <dibblego> a culture that reads right to left would look at your sequence of characters as a String still
17:27:22 <lambdabot>  OK, passed 500 tests.
17:27:26 <Pseudonym> emu: Does it?
17:27:35 <Pseudonym> Does a string need localisation?
17:27:38 <emu> yes
17:27:43 <Pseudonym> Or is that a higher-up construct?
17:27:50 <dibblego> an alien might look at a sequence of bits as something other than the conventional ways of looking at it
17:27:54 <emu> operations on that string may vary depending on locality
17:27:59 <Pseudonym> Ah.
17:28:03 <Pseudonym> That's a different question.
17:28:05 <newsham> ?check \x y -> let assoc f = f x y == f y (x :: Int) in assoc (-)
17:28:06 <lambdabot>  Falsifiable, after 0 tests: 1, 0
17:28:07 <Pseudonym> Operations may, indeed, be localised.
17:28:09 <dolio> A Num as far as the haskell typeclass goes is more like a ring.
17:28:27 <dmwit> newsham: x - z == -(z - x)
17:28:30 <dolio> So you could have polynomials and such being Nums.
17:28:30 <Pseudonym> toUpper :: Locale -> String -> String -- I buy this
17:28:39 <emu> "This string is German" ++ "This string is English" hmm
17:28:44 <Pseudonym> length :: Locale -> String -> Int -- I don't buy this
17:28:49 <dolio> But I doubt anyone would argue that a polynomial is best thought of as a sequence of bits.
17:28:51 <emu> Pseudonym: it can matter
17:29:00 <emu> Pseudonym: for example, in some languages, characters combine
17:29:08 <emu> i'd say length needs a locale
17:29:37 <newsham> err, not "assoc"
17:29:39 <Pseudonym> emu: Surely unicode _normalisation_ might need a locale.
17:29:46 <dibblego> dolio, whether or not it is "best" depends on what you define as an axiom of software - I might propose that an integral value for example is indeed an axiom, and is not a composition of a sequence of bits
17:30:17 <dibblego> if all software is a composition of a 1 and 0, then it would be a bit hard, but definitely more flexible
17:30:24 <Pseudonym> A mathematical object has far more to do with its operations than with its representations.
17:30:35 <Pseudonym> Every category theorist knows that.
17:30:42 <Pseudonym> :-)
17:30:43 <dibblego> right, on all axioms, there exists no operations
17:30:57 <dibblego> I barely know any mathematics, just critical reasoning with myself
17:31:01 <Pseudonym> But the Num typeclass _is_ a set of operations.
17:31:09 <dibblego> or Haskell for that matter
17:31:16 <dibblego> I'm still deciphering problem 6
17:31:17 <emu> i'm no expert, but it seems to me that one of the biggest problems of languages trying to adapt i18n and l10n techniques is that they represent strings as sequence of characters
17:31:20 <Pseudonym> That's what defines Num.
17:31:33 <dibblego> Pseudonym, yes, we are talking about two slightly different things
17:31:33 <Pseudonym> emu: That's true.
17:31:57 <Pseudonym> Conflating sequence of Byte with String is the cause of many ills.
17:32:19 <Pseudonym> Ideally, you'd have an abstract type like FastPackedString, and you would only have iterators on it, not indices.
17:32:23 <emu> even sequence of abstract character
17:32:27 <dibblego> confusing byte with character without acknowledging the many possible functions
17:32:43 <Pseudonym> Sequence of code point is a necessary evil, but it should be for input and output ONLY.
17:32:56 <emu> i wasnt' even talking of the whole byte/char confusion, that's mostly a C issue
17:33:48 <dibblego> an emu ran in front of me on the weekend
17:33:56 <emu> awesome
17:34:00 <newsham> man, remember when characters used to be bytes?  that was such a nice simple time.
17:34:02 <newsham> *sigh*
17:34:04 <dibblego> I was riding along an isolated stretch of road to Minnie Water
17:34:20 <dibblego> they are crazy bastards without any road sense
17:35:44 <Pseudonym> I know someone who struck an emu while motorbike riding across the Nullabor.
17:35:58 <Pseudonym> Made a mess of the emu, apparently.
17:36:26 <dibblego> I can't imagine the result being anything but a come-off
17:36:45 <dibblego> I've hit a small wallaby, but it was only a glance
17:37:28 <dons> seen on the wmii (window manager) mailing list: Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not Haskell."
17:37:49 <edwardk> dons: lol
17:37:51 <dolio> Heh.
17:38:13 <dibblego> lol
17:38:24 * Pseudonym laughs
17:38:29 <dolio> Someone needs to put together a Haskell video like the Erlang video.
17:38:41 <dibblego> what's the Erlang video about?
17:38:55 <dmwit> dolio: @where erlang video
17:38:59 <dolio> Let me find it. It's a must watch...
17:39:04 <dibblego> ok
17:39:09 <dibblego> a comedy? educational?
17:39:13 <dolio> http://video.google.com/videoplay?docid=-5830318882717959520&q=erlang
17:39:16 <lambdabot> Title: Erlang: The Movie - Google Video, http://tinyurl.com/fwday
17:39:17 <dibblego> ta
17:39:18 <dolio> Hard to say.
17:40:42 <Pseudonym> Erlang II: The Revenge
17:40:46 <gmh33> I'm reading yaht and running into some confusion :/
17:42:52 <gmh33> how do you use something like ' data List a = Nil | Cons a (List a) '
17:43:08 <thetallguy> let x = Nil
17:43:10 <dons> Cons 'x' (Cons 'y' (Cons 'z' Nil))
17:43:26 <thetallguy> dons types too fast
17:43:33 <dons> > (:) 'x' ((:) 'y' ((:) 'z' []))
17:43:34 <lambdabot>  "xyz"
17:43:44 <dons> > 'x':'y':'z':[]
17:43:45 <lambdabot>  "xyz"
17:43:54 <dons> > ['x','y','z']
17:43:55 <lambdabot>  "xyz"
17:44:04 <dons> > "xyz" -- and that's it.
17:44:05 <lambdabot>  "xyz"
17:44:46 <dons> ?let cons = (:)
17:44:47 <lambdabot> Defined.
17:44:52 <dons> ?let nil = []
17:44:54 <lambdabot> Defined.
17:45:10 <dons> > L.cons 'x' (L.cons 'y' (L.cons 'z' nil)) -- close
17:45:10 <lambdabot>  Not in scope: `nil'
17:45:20 * dibblego watches
17:45:20 <dons> > L.cons 'x' (L.cons 'y' (L.cons 'z'L. nil))
17:45:21 <lambdabot>  Not in scope: `nil'
17:45:27 <dons> > L.cons 'x' (L.cons 'y' (L.cons 'z' L.nil))
17:45:28 <lambdabot>  "xyz"
17:45:43 <dmwit> That Erlang video is *boring*.
17:46:18 <dolio> It's so well acted, though.
17:46:24 <dibblego> what's the guy's name? I didn't catch it
17:46:38 <dons> gmh33: you got the syntax now for buiding a List a ?
17:46:56 <gmh33> I know how to build lists, but the thing was about defining a data type list myself
17:46:57 <gmh33> and using it
17:47:28 <dons> right. does the example above using 'cons' clarify this?
17:48:01 <dons> mylist = Cons 'x' (Cons 'y' (Cons 'z' Nil)) -- for example?
17:49:30 <dmwit> dolio: The guy whose head is always sideways disturbs me.
17:50:02 <dolio> Which is that? The guy with the moustache?
17:50:10 <gmh33> data List a = Nil | Cons a (List a) -- to use that I would do what ?
17:50:21 <lispy> mylist, yourlist, tomato, tomato
17:50:24 <dmwit> The guy that starts all the calls.
17:50:32 <gmh33> or would I just do Cons blah (Cons blah (Cons blah Nil))
17:50:36 <dons> right
17:50:40 <dons> you just use it.
17:50:41 <dibblego> the guy at the start with the heavy accent
17:50:47 <gmh33> oooo
17:50:48 <gmh33> nice :D
17:51:05 <gmh33> oh!  I get it
17:51:06 <dons> gmh33: I'm intrigued. what did you think you'd have to do ? :)
17:51:28 <dons> consider a similar type: Maybe a = Nothing | Just a
17:51:33 <gmh33> dons:  I'm trying to break out of "imperative mode"
17:51:34 <dons> to use it you'd "just use it":
17:51:49 <dons> > Just (Just (Just (Just (Just 'x'))))
17:51:50 <lambdabot>  Just (Just (Just (Just (Just 'x'))))
17:51:53 <gmh33> dons:  So I was thinking more in terms of instance like declarations
17:52:10 <lispy> a := new Maybe(); a.envalue(1);
17:52:13 <dons> ah no no. values for all here in #haskell. you just say what things are.
17:52:18 <emu> this has the production qualities of a 1970s bbc show
17:52:30 <dons> ?remember lispy a := new Maybe(); a.envalue(1);
17:52:33 <lispy> > return 1 :: Maybe 1
17:52:33 <lambdabot>  Parse error
17:52:45 <lispy> > return 1 :: Maybe Int
17:52:46 <lambdabot>  Just 1
17:53:06 <lispy> envalue is like return ;)
17:53:12 <dons> heh
17:53:56 <lispy> does lambdabot have any slow space leaks?
17:54:07 <lispy> i see that she's has RES of 72megs on myserver
17:54:12 <lispy> that semes like a bit
17:54:37 <gmh33> I've been trying to decide on wether to learn haskell or ocaml, but I like Haskell more so far
17:54:49 <gmh33> :)
17:54:56 <lispy> gmh33: go for the all out mind blowing...ie, haskell
17:55:06 <lispy> gmh33: plus the syntax is sexier :)
17:55:09 <gmh33> lispy: get the imperative out of my system all at once, huh? :P
17:55:11 <dmwit> gmh33: Sign #39 that you may be an academic...
17:55:17 <dons> and  its growing faster too
17:55:28 <dons> we have quite a lot of ocaml refugees here
17:55:34 <gmh33> lispy: I do like haskell's syntax a LOT better than ocaml's
17:55:41 <dons> lispy: not that i know of. she has a lot of state though
17:55:44 <emu> ocaml is .. odd
17:55:47 <gmh33> and the fact that you don't have to specify as many things like recursive and lazy
17:55:47 <jgrimes> > let inf = cycle [1] in let alwaysseven n = 7 in alwaysseven inf
17:55:48 <lambdabot>  7
17:56:03 <dons> but she could do with some profiling (and more bytestrings)
17:56:05 <emu> sml was pretty nice, but missing lots of features
17:56:34 <vincenz> emu: how is ocaml odd?
17:56:46 <gmh33> how do I add a show function for my List data ?
17:56:46 <lispy> functors!
17:56:52 <dgoldsmith> Pseudonym: Unicode normalization does not require a locale
17:56:58 <dons> gmh33: deriving Show
17:57:00 <lispy> gmh33: you could do it manually or automatically
17:57:06 <emu> oh lets see if remember
17:57:10 <dons> you add that to the line under your data declaratoin
17:57:23 <emu> let f = function x -> match x of ....
17:57:27 <emu> gaah
17:57:27 <coffeemug> hey guys
17:57:44 <gmh33> data ... deriving Show
17:57:44 <dmwit> Hey coffeemug.
17:57:48 <gmh33> ?
17:58:02 <coffeemug> question
17:58:08 <lispy> gmh33: for instance, data Foo = F deriving (Show)
17:58:14 <coffeemug> is there a way to handle a non exhaustive pattern match at runtime?
17:58:20 <lispy> gmh33: and there are others that can be derived
17:58:24 <dgoldsmith> Operations that typically require a locale are case folding, collation, text boundaries (graphemes, words, lines), date/time/number formatting/parsing, calendar operations (some locales use non-Gregorian calendars)
17:58:27 <emu> _ -> something?
17:58:31 <coffeemug> can I install a handler for this thing that gets called at runtime?
17:58:43 <dmwit> Use the Maybe monad.
17:58:47 <lispy> data Foo = Foo | Bar | Baz deriving (Show, Eq, Ord, Enum)
17:58:51 <gmh33> hmm I'm getting a load error
17:58:51 <gmh33> heh
17:58:58 <gmh33> oops nvm
17:59:23 <lispy> coffeemug: you can use Control.Exception.catch i think
17:59:27 <dons> coffeemug: yep, you can put a Control.Exceptoin.catch and handle it
17:59:34 <dons> but pattern match exceptions are programmer errors!
17:59:43 <coffeemug> no
17:59:50 <coffeemug> not in all cases
17:59:54 <dons> no?
18:00:03 <coffeemug> for example
18:00:08 <dons> ones not caught by -Wall -Werror ?
18:00:08 <coffeemug> I have a lisp interpreter
18:00:17 <monochrom> Well, it's still nice to be able to runtime-catch and handle them.
18:00:26 <dons> yes, its definitely useful to catch them
18:00:28 <coffeemug> and a lisp function is implemented by a haskell function
18:00:35 <coffeemug> so for example
18:00:40 <coffeemug> if I call a function in the interpreter
18:00:44 <dons> i use this trick in hmp3 and lambdabot: because sometimes you just have to keep running
18:00:45 <coffeemug> with a wrong number for params
18:00:45 <gmh33> is writing a compiler fairly easy in Haskell ? (random question)
18:00:56 <coffeemug> like (set f 5 6) when what's expected is (set f 5)
18:01:11 <coffeemug> I get a non exhaustive match in my Haskell version of set
18:01:12 <lispy> gmh33: writing most things is easier in haskell! (what kind of question is that for #haskell ;)
18:01:20 <dons> oh, you don't have a default case, coffeemug ?
18:01:27 <dons> f _ = error "f did something bad" ?
18:01:29 <gmh33> lispy: I assumed it was, just checking :P
18:01:31 <emu> gmh33: ghc is written in haskell
18:01:39 <coffeemug> dons: I can add a default case for set
18:01:40 <gmh33> emu: that's what I've heard :)
18:01:49 <coffeemug> but then I'll have to add a default case for every function I add
18:01:51 <coffeemug> and that sucks
18:01:55 <dons> coffeemug: but yes, Control.Exception.catch is what you're looking for.
18:01:56 <coffeemug> what I want in this case is to handle it
18:02:08 <emu> gmh33: functional languagse tend to make very good compiler writing languages
18:02:10 <dons> well, i'd argue you should have default cases.. but still, go for it.
18:02:14 <emu> at least in my experience
18:02:19 <lispy> dons: things that are currently less easy to write in haskell than some other laguages include, 1) Guis, 2) Win32 COM.  I haven't seen much else that is harder in haskell
18:02:26 <monochrom> I dislike random questions.  They're hard to distinguish from troll questions.
18:02:27 <coffeemug> dons: why?
18:02:29 <lispy> er
18:02:38 <lispy> gmh33: meant to say that to you not to dons
18:02:47 <coffeemug> haskell is excellent for writing compilers
18:02:55 <dons> it's just bad style to have nonexhaustive patterns. ghc even catches this for you, with -Wall
18:02:57 <coffeemug> for a range of reasons that I'm writing an article about :)
18:03:02 <gmh33> lispy: ooo
18:03:11 <gmh33> lispy:  I don't touch windows.. ever
18:03:13 <emu> i was actually kinda surprised ghc let me do non-exhaustive patterns
18:03:19 <gmh33> lispy: only to play video games now and again
18:03:22 <dmwit> gmh33: Check out Parsec.
18:03:30 <dmwit> It might take care of the first stage of a compiler...
18:03:38 <monochrom> Yeah, I use windows to play games and watch DVDs.
18:03:38 <emu> parsec is pretty slick
18:03:48 <gmh33> that's at the bottom of yaht I believe?
18:03:49 <Pseudonym> Any declarative language is optimised for writing its own compiler.
18:03:51 <lispy> gmh33: cool.  gtk2hs is nice for guis but i wouldn't say it's as mature as some gui libraries in certain languages
18:03:57 <emu> but the more interesting parts of a compiler are further
18:03:58 <coffeemug> btw
18:04:21 <coffeemug> non-exhaustive matches are Haskell's way to escape the world of static typing :)
18:04:23 <gmh33> emu: interesting parts ?
18:04:26 <jgrimes> if you are used to lex / bison like tools, alex and happy accommodate nicely
18:04:35 <lispy> coffeemug: i wouldn't say that
18:04:48 <lispy> coffeemug: unless your matching on strings or something weird
18:04:53 <coffeemug> effectively haskell's algebraic data types coupled with non-exhaustive matches allow small little sandboxes of duck typing
18:05:02 <coffeemug> if you wanna put it that way
18:05:25 <dons> hence non-exhaustive patterns are considered evil :)
18:05:28 <lispy> OO languages do seem to create problems for their solutions :)
18:05:38 <dons> heh
18:05:40 <emu> gmh33: if you find single assignment form, data flow analysis, partial redundancy elimination, and graph coloring to be interesting, yes
18:06:03 <Adamant> is the Haskell compiler written in Haskell or C?
18:06:10 <gmh33> emu: I'm pretty sure I'm not that deep into my compiler writting studies yet :P
18:06:10 <emu> "the" haskell compiler?
18:06:11 <Adamant> (ghc)
18:06:13 <dons> Haskell.
18:06:13 <emu> ghc is in haskell
18:06:15 <lispy> ghc is in haskell, i think hugs has a lot of C
18:06:21 <coffeemug> also I recently read a paper on open datatypes
18:06:30 <coffeemug> this bothered me for a while
18:06:40 <coffeemug> the fact that I can't extend the damned types once I declared them
18:07:00 <Adamant> awesome. can you compile it to C to port to new platforms?
18:07:06 <dons> yep
18:07:07 <lispy> Adamant: but, having said that, ghc integrates very well with C so it wouldn't surprise me if you found bits and pieces of C here and there in ghc's source  (but i've never looked)
18:07:21 <Adamant> now that is nifty.
18:07:22 <shrimpx> like the runtime system?
18:07:34 <Adamant> a big problem with Common Lips implimentations is porting.
18:07:37 <Adamant> Lisp
18:07:38 <shrimpx> all >60k loc of it? :)
18:08:01 * lispy doesn't know much about the ghc run-time and considers it sort of magical ;)
18:08:15 <emu> the big common lisp implementations don't compile to C, they have their own assemblers
18:08:55 <lispy> clisp uses bytecode and is otherewise written in C
18:09:00 <lispy> which makes it very portable
18:09:16 <coffeemug> well
18:09:27 <coffeemug> you can always use a project like LLVM as a backend
18:09:29 <coffeemug> instead of C
18:09:34 <lispy> it's also only 3rd on my list of lisp compilers i would want to use
18:09:54 <shrimpx> haha
18:09:58 <shrimpx> lispy: what is #1
18:09:58 <emu> C is a terrible target language really
18:10:02 <shrimpx> emacs
18:10:05 <emu> i'm told ghc does post-processing on the output of gcc
18:10:10 <shrimpx> yea it does
18:10:22 <shrimpx> whenever gcc gets upgraded something breaks in the post processor
18:10:27 <shrimpx> which is written in perl
18:10:45 <shrimpx> but ghc has native codegen these days on the important platforms i think
18:10:52 <emu> i imagine the more experimental compilers have their own backends
18:11:07 <gmh33> I almost wish I knew assembly language so I could write a native code compiler
18:11:16 <shrimpx> C is not a bad target langauge
18:11:40 <lispy> shrimpx: sbcl
18:11:50 <shrimpx> mostly because it has good optimizing compilers on every platform
18:11:53 <shrimpx> lispy: ah
18:12:10 <emu> sbcl should be compilable from any ANSI CL
18:12:15 <lispy> 1) sbcl 2) cmucl 3) clisp 4) .... haven't thought this far
18:12:16 <coffeemug> I think C is an excellent target for a backend
18:12:18 <Pseudonym> C is pretty good so long as you don't need anything which C really doesn't support.
18:12:28 <emu> the problem with C is that it is weakly typed and yet, still not machine code
18:12:32 <Pseudonym> The fact is, you need to maintain a C stack for Unix signal delivery anyway.
18:12:40 <emu> so you lose information which a backend could otherwise use
18:12:57 <coffeemug> the only real problem with it I see is that there are no real C compilers that are embeddable
18:12:57 <Pseudonym> emu: Such as?
18:13:01 <emu> and gcc isn't one of those "excellent optimizing compilers"
18:13:05 <coffeemug> so you can't do dynamic stuff
18:13:10 <Pseudonym> Most compilers, like GCC, do support sufficient hints.
18:14:25 <emu> i am totally not learning how to use arrays in haskell
18:14:41 <lispy> emu: what do you mean?
18:14:43 <gmh33> emu: from what I've read they're not really worth using..
18:14:48 <lispy> emu: it's painful or you're not getting it?
18:14:55 <emu> no i'm chatting too much=)
18:15:44 <lispy> gmh33: i'd say arrays are fairly advanced in haskell...in terms of when they make sense to use
18:15:54 <lispy> i haven't found them to be terribly difficult thoguh
18:16:03 <lispy> just, not always efficient like i would expect :)
18:18:03 <dons> they're certainly useful. sometimes crtical.
18:18:30 <dons> but you'l want to learn UArray, IOUArray and maybe STUArray
18:18:35 <dons> if you care about efficiency
18:18:53 <dfranke> I'm trying to define a synonym 'Pollard a' for the type class '(Eq a, PID a, Random a)'.  What's the proper syntax for that?
18:18:59 <emu> i just want to enter in a literal 2d array
18:19:16 <dons> there are no array literals
18:19:16 <dolio> Oh, speaking of STUArray, your recommendation was correct, dons. That did make the program I was fooling with the other day faster.
18:19:22 <emu> yea i just realized
18:19:24 <dons> you build them from lists
18:19:28 <dons> fromList [ ..... ]
18:19:36 <dons> or use newArray and friends
18:19:37 <emu> so i could do a "2d" list i guess
18:19:48 <lispy> dons: i'm going to work out now, but in an hour or so i'd like to talk to you about GoA, assuming you have some time
18:19:53 <dons> ok.
18:20:11 <lispy> cool, bbiab
18:20:53 <jgrimes> whats that language... that claims to have the most expressive type system ever? I think it is based on lisp.
18:21:00 <dfranke> i.e. I want all 'a' that satifies '(Eq a, PID a, Random a)' to automatically satisfy 'Pollard a'
18:21:33 <dfranke> jgrimes: Goo?
18:22:25 <coffeemug> ok, gonna get off
18:22:27 <coffeemug> thanks guys
18:22:32 <jgrimes> dfranke, hmm... don't think so.
18:25:39 <emu> @hoogle fromList
18:25:39 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
18:25:39 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
18:25:39 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
18:25:58 <monochrom> I think "class synonym" is a well-known trick.
18:26:05 <dons> ?hoogle newArray
18:26:05 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:26:06 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:26:06 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
18:26:17 <dons> ?docs Data.Array
18:26:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
18:27:35 <jgrimes> ah thats it. Qi
18:27:44 <newbcoder> ?slap lambdabot
18:27:45 * lambdabot beats up lambdabot
18:27:50 <newbcoder> hehe
18:27:52 <SamB> O_o
18:27:54 <newbcoder> i'm stupid like that
18:28:06 * deadbeef now is a FONero
18:30:39 <dfranke> monochrom: were you talking to me?
18:31:08 <monochrom> Yes.
18:31:15 <dfranke> monochrom: link?
18:31:23 <monochrom> I don't know.
18:32:41 <gmh33> woo Haskell makes so much more sense now lol
18:32:48 <gmh33> and all I did was figure out the typing thing
18:33:00 <dons> hehe
18:33:07 <dmwit> gmh33: All of it?? O_o
18:33:10 <dmwit> ;-)
18:33:18 <dons> ?remember gmh33 Haskell makes so much more sense now and all I did was figure out the typing thing
18:33:42 <coffeemug> had to come back for one more question :)
18:34:04 <coffeemug> suppose I have a series of nested monads
18:34:18 <coffeemug> like StateT -> ErrorT -> IO
18:34:26 <gmh33> dmwit: well, all of what I've learned up until this point really
18:34:36 <coffeemug> when I want to do an IO call within a state monad I lift it
18:34:47 <coffeemug> what's the "opposite" of lift?
18:34:51 <coffeemug> the reason I ask
18:34:53 <SamB> you mean StateT s (ErrorT e IO)?
18:34:58 <coffeemug> sam: yeah
18:35:08 <coffeemug> when I do a catch exception
18:35:14 <coffeemug> the catch function requires IO
18:35:19 <SamB> er, there isn't an opposite...
18:35:26 <coffeemug> but what I end up passing to it is my State monad
18:35:35 <SamB> you have to use the run* functions...
18:35:38 <SamB> it is a pain!
18:35:46 <coffeemug> yes, I know of the run functions
18:35:54 <SamB> I would really like it if someone smarter than I am figured out how to make it easy ;-)
18:35:57 <dons> or catch at the top level/
18:36:11 <coffeemug> but that means I either have to bring the run function in or catch further out
18:36:24 <coffeemug> which are both rather crappy solutions
18:36:40 <dons> btw, I consider StateT s (ErrorT e IO) to be a bit on the complex side. just a bit.
18:36:46 <monochrom> lift your catch
18:37:08 <dons> the ErrorT might be overkill in practice, though probably useful for pedagogical purposes
18:37:28 <monochrom> Need IOT :)
18:37:36 <dons> yeah, lift the catch into the monad.
18:37:41 <dons> we do that in lambdabot
18:37:58 <dons> just for fun:
18:38:01 <coffeemug> hmm
18:38:04 <dons> instance MonadError IRCError LB where
18:38:06 <coffeemug> lift the catch, eh
18:38:08 <dons>   m `catchError` h = lbIO $ \conv -> (conv m
18:38:09 <dons>               `catchDyn` \(SignalException e) -> conv $ h $ SignalCaught e)
18:38:09 <dons>               `catch` \e -> conv $ h $ IRCRaised e
18:38:13 <dons> :)
18:38:23 <monochrom> Theorem: Whenever you want to invert lift, lift even more, not less.
18:38:34 <coffeemug> heh
18:38:35 <dons> mm. nice monochrom .
18:39:19 <dons> coffeemug: or possibly look at a MonadError instance for your monad?
18:39:35 <dons> (which would involve a run* I think)
18:39:42 <dmwit> There are lots of go players here, right?
18:39:47 <dmwit> Is there any good SGF reader for Haskell?
18:43:06 <dmwit> I think it's Parsec to the rescue, here... =)
18:44:28 <coffeemug> hmm
18:44:34 <coffeemug> how would I lift the catch into the monad?
18:44:37 <coffeemug> I can lift the catch
18:44:43 * SamB thinks there maybe ought to be a MonadCatch class...
18:44:47 <newsham> is there an easier way to do:   \x n -> x { foo = n }   ?
18:45:03 <dolio> Isn't that what MonadError is for?
18:45:03 <coffeemug> and turn it from IO into my monad
18:45:11 <coffeemug> but the first argument of catch still expects IO
18:45:16 <coffeemug> not my monad
18:45:16 <SamB> dolio: I meant for catching IO exceptions
18:45:20 <coffeemug> regardless whether I lift it or not
18:45:24 <dolio> Ah.
18:45:29 <gmh33> > foldr (-) 2 [1,2,3]
18:45:30 <lambdabot>  0
18:45:45 <gmh33> > foldl (-) 2 [1,2,3]
18:45:46 <lambdabot>  -4
18:46:03 <dolio> Isn't IO an instance of MonadError?
18:46:22 <SamB> so I wouldn't have to write such unreadable code as... mapExceptionStateT f = mapStateT (\x -> x `catch` (throwIO . f))
18:46:27 <newsham> any "section" like things like   {foo =} ?
18:46:29 <dolio> Or is that not the right type of catch?
18:46:31 <dolio> ?type catch
18:46:32 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
18:46:41 <SamB> @instances MonadError
18:46:41 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
18:46:45 <newsham> or any other name given to the settors that get generated for records?
18:46:45 <SamB> hmm.
18:47:04 <dons> newsham: labels? accessor functions?
18:47:26 <newsham> dons: dunno what you're asking.
18:47:41 <newsham> I want:   \x n -> x {foo=n}     for record x with field foo.
18:48:13 <newsham> is there such a thing or do I need to use lambdas?
18:48:29 <dons> there's no such function, you get 'getters' (i.e. the label is an accessor function), but no 'putters'.
18:48:45 <dons> setfoo x n = x {foo=n}
18:49:01 <newsham> <not well thought out>would be nifty if it was just  {foo=}</not well thought out>
18:49:10 <SamB> okay, so apparantly MonadError can do what I mean...
18:49:24 <dons> SamB: I reckon so
18:49:48 <dons> what you wrote looked almost like lambdabot's industrial strength MonadError
18:50:27 <SamB> but I haven't touched that code in a while
18:50:37 <coffeemug> somehow when people get into monad transformers and stuff like that it just looks like most of the work goes into haskell type system trickery instead of the problem domain
18:50:47 <SamB> hmm
18:50:54 <newsham> trying to make a reasonable getOpt function that returns a record with all the config values updated...
18:51:14 <newsham> so each getOpt option needs a settor.  :\
18:51:18 <SamB> coffeemug: maaaaybe. but at least you don't have to spend hours tracking down what the fuck is happening to your global variables...
18:51:50 <SamB> (usually)
18:51:51 <dons> and big monad stacks aren't very common anyway, mostly in larger apps like pugs or lambdabot, where the payoff is worth it
18:52:01 <gmh33> yay my listFoldr and listFoldl foldr and foldl correctly (I think?) lol
18:52:04 <SamB> yeah, usually the stacks are pretty small
18:52:13 <SamB> but it would be nice not to have to change too much if you restack
18:52:28 <coffeemug> sam: that statement falsely assumes that you can't have a lazy language with a dynamic (or a more forgiving static) system
18:52:41 <SamB> coffeemug: eh...
18:52:45 <SamB> "more forgiving"?
18:53:00 <coffeemug> sure
18:53:04 <coffeemug> for example
18:53:05 <SamB> you mean "you are an idiot and your code makes no sense but I will run it anyway"?
18:53:18 <coffeemug> yeah
18:53:19 <coffeemug> basically
18:53:21 <gmh33> more or less
18:53:22 <SamB> hah
18:53:24 <dons> we just like to know things a really sorted statically here, as you've seen
18:53:26 <SamB> that is a good idea now?
18:53:38 <coffeemug> sure
18:53:43 <dons> leaving things to the runtime isn't really an option.
18:53:49 * SamB thought the whole point was to call the programmer an idiot at compile time ;-)
18:53:59 <coffeemug> well
18:54:03 <dons> for example, it never even occurs to me not to put in a default case for pattern matching.
18:54:07 <gmh33> knowing is half the battle!
18:54:07 <coffeemug> the point is to do what I want and get out of the way :)
18:54:08 <gmh33> ;P
18:54:22 <dons> but I presume leaving out cases is common in some dynamically typed languages?
18:54:24 <newsham> @hoogle [(a -> a)] -> (a -> a)
18:54:25 <lambdabot> No matches, try a more general search
18:54:36 <coffeemug> dons: sure
18:54:36 <newsham> is there a function that does   foldr (.) id ?
18:54:56 <gmh33> newsham: reverse map?
18:55:05 <coffeemug> dons: with multimethods that's what happens all the time
18:55:10 <gmh33> sorry didn't read anything past the hoogle
18:55:12 <dons> which I think reveals an interesting distinction in approach by the various communities.
18:55:14 <coffeemug> you create implementations for combos that make sense
18:55:27 <coffeemug> and don't worry about stuff that doesn't make sense
18:55:32 <coffeemug> if you call it at some point
18:55:41 <dons> hence I referred to missing pattern matches as programmer error, but in other communities this wouldn't be view that way
18:55:44 <newsham> > (reverse map) [(+ 3), (+ 2), (+ 5)] 1
18:55:45 <lambdabot>    Expecting a function type, but found `[a]'
18:55:45 <lambdabot>    Expected type: [a]
18:55:45 <lambdabot>   ...
18:55:46 <coffeemug> it's a bug in the program
18:55:50 <newsham> dont see how thats supposed to work
18:56:05 <newsham> > (foldr (.) id [(+ 3), (+ 2), (+ 5)]) 1
18:56:07 <lambdabot>  11
18:56:07 <coffeemug> no
18:56:17 <coffeemug> missing pattern matching case isn't a bug
18:56:28 <SamB> dons: yes! is programmer error in not supplying decent error message!
18:56:33 <coffeemug> calling the function with arguments that result in a missing case *is* a bug
18:56:45 <dons> i think it would be considered as such in haskell. since the definition of the function is incomplete
18:56:54 <dons> nothing to do with what data you supply to it
18:57:05 <newsham> I want   \l x -> (foldr (.) id l) x
18:57:20 <newsham> ie. chain all functions in l and apply them to x.
18:57:27 <SamB> dons: well, you really can't expect complete functions all the time...
18:57:31 <SamB> though they are nice...
18:57:37 <dons> who cares about the particular data. its about the statically known inhabitants of the type -- that's what tells you what cases you need to handle
18:57:48 <dons> SamB: well, you should certainly tag default cases though.
18:58:00 <dons> i hope you're not relying on pattern match failures in your code, SamB ;)
18:58:52 <SamB> it is good to have a more helpful default case than "blah blah pattern match failure at blah:2:21-3:56", to be sure..
18:58:57 <SamB> dons: relying on them?
18:59:12 <SamB> no way!
18:59:58 <SamB> > head []
18:59:58 <lambdabot>  Add a type signature
19:00:02 <SamB> > head [] :: ()
19:00:03 <lambdabot>  Exception: Prelude.head: empty list
19:00:10 <dons> coffeemug: i'll be interested to see our article, its giving me some insight into non-haskell thinkings :)
19:00:15 <dons> s/your/
19:00:18 <SamB> do you think that head should not exist?
19:00:32 <dons> I think you should handle the [] case!
19:00:40 <dons> and not just let it fail
19:00:40 <SamB> how!!!
19:01:00 <SamB> the only values of type a are _|_!
19:01:08 <dons> the usual way. with guards, of course, before caling 'head'. don't tell me that you write: f xs = head
19:01:18 <dons> rather than: f [] = error ... ; f xs = head
19:01:24 <SamB> oh, sure ;-)
19:01:45 <dmwit> > let test = \(x, z) -> [x, z] in test (1,3)
19:01:46 <lambdabot>  [1,3]
19:01:55 <SamB> I'm just saying that I'm pretty sure it still counts as incomplete after you put in your own call to error ;-)
19:02:12 <dons> yep sure :)
19:02:33 <SamB> and that head is one such function
19:02:48 <dons> but we'd always handle it. it's just wrong in haskell to let that fall through to a non-exhaustive case
19:03:13 <SamB> I usually let that happen about once
19:03:26 <dmwit> > last "hi"
19:03:27 <lambdabot>  'i'
19:03:41 <SamB> and then fix it to actually tell me what the args are ;-)
19:03:55 <dons> yep
19:04:22 <SamB> and then typically I finish the function and take that case out because of the overlapping cases warning ;-)
19:05:51 <monochrom> I prove my programs correct.
19:06:16 <SamB> hmm, I haven't the machinery for that
19:06:21 <dons> thus spake the compiler: neither shall thou permit thy patterned cases to overlap, nor to be of such sparse extant as to open gaping holies for thy data to fall into
19:06:27 <sjanssen> my programs are more correct than you deserve
19:06:37 <SamB> holes or holies?
19:06:53 <dons> I thought holies was more "authentic"
19:07:11 <monochrom> holies!
19:07:42 <sjanssen> yea verily, Brother dons decryeth the truth
19:07:50 <dons> ?remember monochrom [monochrom] I prove my programs correct. [sjanssen] my programs are more correct than you deserve
19:08:26 <coffeemug> somehow dynamic typing just appeals to me :)
19:08:30 <coffeemug> hmm
19:08:36 <coffeemug> saying that in #haskell is social suicide
19:08:37 <coffeemug> lol
19:08:42 <SamB> Data.Dynamic is your bitch ;-)
19:09:02 <monochrom> It's ok as long as you prove your program correct.
19:09:07 <coffeemug> Data.Dynamic isn't supported by anyone but ghc :)
19:09:09 * SamB hopes that doesn't mean anything nasty
19:09:27 <SamB> coffeemug: what?
19:09:37 <SamB> they don't have unsafeCoerce#?
19:09:56 <coffeemug> sam: I think hugs doesn't support dynamic facilities
19:10:03 <dons> yeah, dynamics are ok as long as the program has a correctness proof. though there's stil all that checking overhead to pay each time you run the code. oh well   :)
19:10:09 <coffeemug> sam: though I may be wrong
19:10:28 <dons> coffeemug: I think hugs doesn't support deriving Typeable, which is the issue.
19:10:41 <coffeemug> dons: right
19:10:44 <SamB> that isn't so much of an issue, is it?
19:10:53 <SamB> how hard is it to write a Typeable instance?
19:11:07 <coffeemug> well
19:11:08 <SamB> also, it shouldn't be too hard to *fix* either...
19:11:20 <coffeemug> if I am a startup founder
19:11:38 <coffeemug> my goal is to deliver software faster than competitors
19:11:42 <dons> Hugs.Base> :l Data.Dynamic
19:11:43 <dons> Data.Dynamic> :t toDyn
19:11:43 <dons> toDyn :: Typeable a => a -> Dynamic
19:11:43 <dons> Data.Dynamic> :t fromDyn
19:11:43 <dons> fromDyn :: Typeable a => Dynamic -> a -> a
19:11:44 <SamB> hmm
19:11:58 <dons> Data.Dynamic> toDyn 'x'
19:11:58 <dons> <<Char>>
19:12:01 <dons> hugs++
19:12:06 <coffeemug> proving things correct isn't really a high priority on my list as long as stuff works right
19:12:10 <SamB> @karma hugs
19:12:10 <lambdabot> hugs has a karma of 2
19:12:23 <SamB> hugs++ # hugs needs a hug
19:13:06 <sjanssen> coffeemug: ideally, the type system is a tool that guides you in making stuff "work right"
19:13:20 <monochrom> I'm a startup folder.
19:13:29 <monochrom> startup folder, not startup founder :)
19:13:57 <monochrom> My goal is to execute programs faster :)
19:14:02 <coffeemug> sjanssen: right, but in practice you end fighting the type system quite often
19:14:07 <monochrom> Or at least earlier :) :)
19:14:16 <sjanssen> coffeemug: I can't remember the last time I fought the type system
19:14:29 <dons> I'm not sure that's right, coffeemug. At least after the first couple of months of learning haskell.
19:14:48 <coffeemug> well, that depends entirely on what you do
19:14:59 <sjanssen> I can recall dozens of times in the past week the type system has told me that my program couldn't possibly work the way I'd written it
19:15:04 <coffeemug> I already found that haskell is excellent at dealing with some types of problems
19:15:05 <SamB> well, certainly you get a lot of type errors ...
19:15:06 <dons> you just come to accept that the type system knows that you're wrong, before you realise you're wrong.
19:15:11 <coffeemug> and pretty terrible with dealing with others
19:15:13 <SamB> but that doesn't mean you need to *fight* it...
19:15:17 <monochrom> 90% of the fight is caused by bad program design.
19:15:22 <jgrimes> > (\x -> (\y -> y) (\z -> z)) (\u -> u)
19:15:22 <lambdabot>  Add a type signature
19:15:35 <SamB> you need to avoid trying to make the type system do things it just can't do, though ;-)
19:16:10 <jgrimes> > (\x -> (\y -> y) (\z -> z)) (\u -> u)::(Int -> Int)
19:16:11 <lambdabot>  <Int -> Int>
19:16:29 <SamB> > (+1)
19:16:29 <lambdabot>  Add a type signature
19:16:40 <dons> no defaulting yet. needs 6.6
19:16:49 <dons> the -fextended-defaulting flag
19:17:15 <SamB> > \shirt -> (+1) shirt :: Int -> Int
19:17:16 <lambdabot>  add an instance declaration for (Num (Int -> Int))
19:17:21 <SamB> rmm...
19:17:23 <jgrimes> ah, ok
19:17:27 <SamB> > \shirt -> (+1) shirt :: Int
19:17:28 <lambdabot>  <Int -> Int>
19:17:34 <dons> coffeemug: what kinds of problems have you found haskell terrible at?
19:17:41 <SamB> that is ... odd looking!
19:18:10 <dons> or is this to appear in your next article? :)
19:18:30 <dons> we should have some haiku about fighting the type system
19:18:41 <jgrimes> dons, true
19:18:51 <dons> since people beginning on the haskell quest talk about having to fight the system
19:19:02 <dons> and the old hands say "what??"
19:19:20 <dons> "why are you fighting? the type system is just _right_. you're the one who is wrong"
19:19:26 <SamB> now, wrestling with the typesystem is fine ;-)
19:19:48 <dons> so perhaps, if you think you have to fight the type system, you're doing the wrong thing.
19:19:53 <SamB> (this is called "Design" ;-)
19:19:56 <dons> right.
19:20:08 <monochrom> I'm less sure but I still give it 90% probability.
19:20:25 <dons> ie. .don't stack up an infinite tower of reflective monads, before considering what architectural constraints this will make on the code
19:20:48 <SamB> nevermind that haskell doesn't allow infinite types!
19:20:53 <newsham> anyone got a sec for a quick syntax error?  in http://www.thenewsh.com/~newsham/x/file.hs if I hae the {}'s in "getOptions" it gives a parser error.  if I remove them it works fine.  why?
19:21:25 <dons> whenever I think of monad towers I think of that infinite reflective tower paper on metacircular interpreters from the 80s, and get drawn into that imagery :)
19:21:27 <SamB> okay, I gotta go to bed...
19:21:29 <monochrom> With typeclasses and various extensions in GHC you can do a whole lot.
19:21:34 <SamB> gotta get up at like 6:00
19:21:37 <SamB> @localtime SamB
19:21:38 <lambdabot> Local time for SamB is Tue Sep 12 22:21:18
19:22:15 <SamB> see you in a few hours ;-)
19:22:23 <newsham> I would like ot use {}'s to avoid having to constantly indent nested ifs.
19:22:59 <coffeemug> well
19:23:05 <coffeemug> some shortcomings I found
19:23:12 <coffeemug> are lack of extensible datatypes
19:23:19 <sjanssen> newsham: are you familiar with the case/guard idiom?  case () of _ | cond1 -> x; _ | cond2 -> y ...
19:23:21 <coffeemug> that's rather huge if your project gets big enough
19:23:28 <newsham> yup.
19:23:37 <newsham> but i'm testing different things each time
19:23:45 <monochrom> Similarly, people also fight with the IO monad.  "How to IO a -> a?"  90% of it comes from poor analogy with imperative languages.
19:23:48 <dons> coffeemug, yeah, that's an interesting, semi-open problem. easy to add functions,hard to add new variants.
19:24:04 <coffeemug> dons: right
19:24:13 <coffeemug> also functions aren't open
19:24:21 <coffeemug> which I feel is a problem
19:24:24 <dons> extensible data is getting easier though, as you've seen.
19:24:33 <dons> well, there's type class instances for that kind of thing
19:24:37 <dons> which are open
19:24:45 <coffeemug> another problem is lack of a portable introspection/generics mechanism
19:24:52 <dons> yep
19:25:06 <dons> TH somewhat, and Generics, but needs to be standardised
19:25:07 <coffeemug> yes, class instances let you do that
19:25:15 <Pupeno> @seen sephr
19:25:15 <lambdabot> I haven't seen sephr.
19:25:20 <Pupeno> @seen seprh
19:25:20 <lambdabot> I haven't seen seprh.
19:25:25 <Pupeno> @seen sehpr
19:25:25 <lambdabot> I haven't seen sehpr.
19:25:28 <Pupeno> mmhh.
19:25:30 <coffeemug> so right now if you do anything that requires generics/extensible types, you're kinda screwed
19:25:32 <dons> coffeemug: you've see the scrap-your-boilerplate series on generics?
19:25:41 <coffeemug> dons: yes
19:25:49 <Pupeno> @seen shapr
19:25:49 <lambdabot> Last time I saw shapr was when I left #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it, #haskell.se, #haskell_ru, #oasis, #perl6 and #scannedinavian
19:25:50 <lambdabot> 3d 19h 2m 27s ago, and .
19:25:57 <coffeemug> I just feel uneasy about the fact that there's only one implementation
19:26:06 <dons> i'd say you're fine if you want generics. extensible types you've not much choice other than Dynamic.
19:26:10 <emu> only one?
19:26:16 <emu> hmm
19:26:18 <dons> yeah, there's a few different flavours around
19:26:30 <dons> (as 3rd party libs)
19:26:34 <newsham> anyone know why adding {}'s would make the code break?  I thought {}'s were supposed to work like indentation to specify grouping
19:26:45 <coffeemug> I mean
19:26:51 <coffeemug> the exception mechanism kind of sucks
19:26:56 <coffeemug> because data types aren't extensible
19:27:07 <coffeemug> so you get the whole throwDyn thing
19:27:13 <dons> right, so there's the new extensible exception framework for that
19:27:16 <dons> coming with Haskell'
19:27:27 <emu> i gotta take a look at that
19:27:31 <dons> so that's being actively addressed
19:27:34 <coffeemug> dons: what's that?
19:27:41 <emu> yea the current exception system is very basic
19:27:42 <dons> let me find you a url
19:27:51 <coffeemug> then there's monad transfomers where you end up saying "lift . lift . lift . lift"
19:27:59 <sjanssen> @where paste
19:27:59 <lambdabot> http://paste.lisp.org/new/haskell
19:28:46 <lisppaste2> sjanssen pasted "guards for newsham" at http://paste.lisp.org/display/25931
19:29:06 <dons> http://hackage.haskell.org/trac/haskell-prime/wiki/ExtensibleExceptions
19:29:10 <lambdabot> Title: ExtensibleExceptions - Haskell Prime - Trac, http://tinyurl.com/k6prp
19:29:18 <newsham> hmm.. interesting. thanks.
19:29:37 <dons> SimonM's new paper to appear at  the HW workshop covers this
19:30:27 <dons> An Extensible Dynamically-Typed Hierarchy of Exceptions (Simon Marlow) Haskell '06: Proceedings of
19:30:31 <dons> the 2006 ACM SIGPLAN workshop on Haskell, Portland, Oregon, ACM Press, September 2006
19:30:36 <coffeemug> once again, I think many of the things I am mentioning aren't so much Haskell shortcomings as they are bits of Haskell that are resistant to understanding
19:30:42 <coffeemug> thanks
19:30:42 <dons> coffeemug: ^^ title contains all the words you like :)
19:31:13 <dons> yeah, that's true. things like monad stacks are just hard
19:31:19 <coffeemug> well
19:31:22 <dons> hence people just stick to IO or StateT + IO at most
19:31:29 <monochrom> I am not too sure about hierarchy.  I am more sure about DAG.
19:31:34 <coffeemug> I don't think they're hard
19:31:42 <coffeemug> I have a philosophy that nothing is hard
19:31:43 <coffeemug> only hard to teach
19:32:05 <dons> well, also some what tricky to get all the bits in place (e.g. MonadError)
19:32:22 <coffeemug> nobody figured out yet how to teach monad transformers to people well
19:32:31 <coffeemug> for a while this has been the case with single monads
19:32:34 <coffeemug> for years, actually
19:32:38 <dons> yep. I agree
19:32:40 <coffeemug> but then people cought on
19:32:54 <coffeemug> and now there are some excellent easily approachable monad tutorials
19:33:00 <dons> we can teach moands well. transformers are the next fronteir
19:33:03 <\z> hm....sounds like an interesting project.
19:33:40 <monochrom> Just have sigfpe write "you have invented monad transformers too!"
19:33:53 <dons> heh
19:34:25 <newsham> sjanssen: i updated my code to use that construct. thanks.  but back to the origina question, any idea why {}'s woul dintroduce a syntax error?
19:34:26 <newsham> I dont get it.
19:34:27 <dons> coffeemug: I wonder, maybe you'd like to sindicate your blog to planet.haskell.org?
19:34:41 <dons> if so, just ping ibid here, and he'll add the feed.
19:34:50 <\z> coffeemug: where did the monad tutorials fall down with transformers?
19:34:56 <coffeemug> dons: but my blog isn't entirely haskell related
19:35:02 <dons> no that's fine.
19:35:09 <dons> if you check planet.haskell.org, there's a real mix.
19:35:15 <coffeemug> dons: I think there will be quite a few haskell related articles
19:35:30 <dons> yes, very much appropriate to planet haskell, I think
19:35:34 <coffeemug> I'd love to add it, but does it mean I should create a separate haskell rss?
19:35:34 <sjanssen> newsham: I'm not sure.  I don't know explicit layout very well
19:35:41 <dons> coffeemug: nope
19:35:55 <dons> ibid can just add your normal feed
19:36:06 <coffeemug> ok
19:36:12 <coffeemug> let me msg him (her?)
19:36:21 <newsham> sjanssen: other than that, any other recommendations?  is that a sane way to do arg parsing or is there a simpler way?
19:36:29 <dons> him. yep. he's in europe, so will probably respond around 5 hours from now
19:36:39 <coffeemug> heh
19:36:43 <coffeemug> I go to planet haskell
19:36:46 <coffeemug> and first thing I see
19:36:49 <coffeemug> is a post on erlang :)
19:36:52 <dons> heh
19:36:55 <gmh33> ' data BinaryTree a
19:36:55 <gmh33> 	= Leaf a
19:36:55 <gmh33> 	| Branch (BinaryTree a) a (BinaryTree a) deriving (Show)
19:36:55 <gmh33> elements (Leaf x) = x
19:36:55 <gmh33> elements (Branch left x right) =
19:36:56 <gmh33> 	(elements left):(elements right):x:[] '
19:36:59 <dons> right. followed by one on python, I think.
19:37:10 <sjanssen> newsham: looks fine to me
19:37:12 <gmh33> sorry the paste link kind of eluded me (oops)
19:37:27 <monochrom> gmh33: I recommend not having keys in "Leaf".
19:37:31 <newsham> also is there a std library function for this?  runAll fs x = (foldr (.) id fs) x
19:37:37 <newsham> seems like it would be a common thing.
19:37:44 <dons> ?pl runAll fs x = (foldr (.) id fs) x
19:37:44 <lambdabot> runAll = foldr (.) id
19:38:10 <dons> hmm, something in Monad ((->) a) ?
19:38:11 <monochrom> data BinaryTree a = Leaf | Branch ... a ...    -- "Leaf" is kind of a null pointer.
19:38:12 <sjanssen> newsham: I don't think there is such a function
19:38:22 <newsham> thanks for the help.
19:38:26 <dons> do we have Foldable (-> a) ?
19:38:53 <lispy> dons: so is your GoA repo the authorative one?
19:38:56 <monochrom> Rationale: you will probably want a node with child on left and no child on right.
19:39:02 <gmh33> leaf in this instance is a stub
19:39:15 <dons> lispy: yep.
19:39:31 <lispy> dons: would you object to merging GoA with the lambdabot repository?
19:39:35 <sjanssen> @where goa
19:39:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
19:39:50 <lispy> either way, i think the cgi wrapper should live where GoA lives
19:39:53 <monochrom> OK, then I don't understand your goal.
19:39:59 <monochrom> Perhaps I'm not supposed to.
19:41:55 <lispy> dons: when i looked at the code in GoA it looks as though querying lambdabot pumps the output of lambdabot straight to stdout and then returns [] into the IO monad
19:42:44 <dons> yep
19:42:46 <lispy> dons: to make that work for cgi, it it returned whatever lambdabot output then i could liftIO and use the cgi output.  So...i'm thinking modifying GoA and then using it 'directly' is a good way to reuse code
19:42:55 <dons> yes.
19:43:07 <dons> maybe even distributing the cgi binary as part of goa?
19:43:17 <lispy> the binary?
19:43:27 <dons> the wrapper program?
19:43:27 <lispy> oh, does goa package a lambdabot binary?
19:43:34 <dons> nope.
19:43:42 <lispy> yeah, it just seems odd to package a binary with source :)
19:44:10 <dons> no, i meant, build goa and you get a) a ghci binding, b) a cgi binary, that wraps lambdabot
19:44:20 <dons> but proceed as you wish
19:44:30 <dons> you may want to just start with goa and hack
19:44:37 <lispy> right
19:44:38 <lispy> cool
19:44:57 <lispy> it actually shouldn't be too hard to use GoA + the cgi code i already wrote
19:45:05 <dons> yeah, i reckon so too
19:45:10 <coffeemug> ok
19:45:12 <lispy> does GoA cabal install itself as a library?
19:45:13 <coffeemug> now it's really time to sleep
19:45:19 <coffeemug> thanks for everyone's help
19:45:26 <coffeemug> good night
19:45:26 <dons> night coffeemug !
19:45:33 <dons> lispy: yep
19:45:37 <lispy> ah, perfect
19:45:39 <dons> libgoa
19:45:49 <lispy> so, then yes, i'll just modify the api
19:45:51 <\z> dons: so, what monad tutorials are out there these days, and where do they fall short?
19:45:56 <coffeemug> as usual, I apologize for silly questions
19:46:01 <coffeemug> :)
19:46:14 <lispy> \z: nomaware is a big one
19:46:20 <\z> yeah, I remember aam
19:46:22 <dons> \z there's a list on haskell.org. some say they fall short in not explaining transformers well
19:46:39 <gmh33> monochrom: apparently I was close the first time left ++ a ++ right, but I needed to put [ ] around a and [ ] around the leaf pattern
19:46:40 <dons> write a good monad transformer tutorial with a nice metaphor in the title, and you'll get famous :)
19:46:43 <gmh33> yay
19:46:53 <\z> aam was an interesting walk through, and I remember it was a cursory walk through each of the primary monads
19:46:55 <gmh33> that's what I had tried originally, only w/o the [ ]s
19:47:04 <lispy> aam?
19:47:06 <\z> dons: :-)
19:47:07 <monochrom> Right, need [a].
19:47:09 <lispy> all about monads?
19:47:15 <\z> lispy: yep
19:47:27 * lispy goes to hack
19:47:37 <\z> I remember getting stuck, until I read the mtl source in ghc
19:47:45 <\z> and kept reading it until I understood it.  :-)
19:48:46 <dolio> Yes. What are monad transformers in terms of apple boxes? :)
19:49:23 <\z> dolio: apple boxes?
19:49:32 <lispy> dolio: i think they change the box
19:49:52 <lispy> \z: i think it's a reference to the way Cale teaches monads
19:50:10 <dolio> Maybe you could use vacuum cleaners as a metaphor.
19:50:20 <\z> lispy: ah.  not familiar with cale's writings
19:50:22 <dolio> They have attachments that change their functionality.
19:50:33 <lispy> ah, the writings of Cale
19:50:47 <lispy> ?quote cale
19:50:47 <lambdabot> cale hasn't said anything memorable
19:50:51 <lispy> ?quote Cale
19:50:51 <lambdabot>  ... if sections were allowed at the type level ...
19:50:55 <lispy> ?quote Cale
19:50:55 <lambdabot>  They're using continental drift as a means of communication.
19:51:05 <lispy> ?quote Cale
19:51:06 <lambdabot>  ... if sections were allowed at the type level ...
19:51:09 <lispy> hmm...
19:51:13 <lispy> he has better quotes
19:51:17 <lispy> just not getting lucky :)
19:51:31 <\z> lispy: http://haskell.org/haskellwiki/Monads_as_Containers ?
19:51:34 <lambdabot> Title: Monads as Containers - HaskellWiki, http://tinyurl.com/kn2n3
19:51:45 <dolio> That's the one.
19:52:18 <lispy> \z: definitely cale
19:52:19 <dolio> "If you will give me a blueberry for each apple I give you (a -> b), and I have a box of apples (f a), then I can get a box of blueberries (f b)."
19:52:28 <\z> "If you will give me a blueberry for each apple I give you (a -> b), and I have a box of apples (f a), then I can get a box of blueberries (f b).
19:52:28 <\z> "If you will give me a blueberry for each apple I give you (a -> b), and I have a box of apples (f a), then I can get a box of blueberries (f b).
19:52:28 <\z> "If you will give me a blueberry for each apple I give you (a -> b), and I have a box of apples (f a), then I can get a box of blueberries (f b).
19:52:28 <\z> Yeah.  Now I remember.  ;-)
19:52:34 <\z> eeek!  sorry 'bout that.
19:52:43 <lispy> heh
19:52:44 <dolio> Heh.
19:52:55 <lispy> (it's echo day in #haskell)
19:52:58 <monochrom> You have a curious way of remembering things.
19:52:58 <\z> I guess that's a memorable quote.  :-)
19:53:33 <\z> um, yeah.  I'm blaming that on an overactive Cmd-V sequence.
19:54:44 <\z> so, a box of apples.
19:55:25 <\z> a monad transformer is a mechanism that lets you take a box of apples, a bigger box that can hold blueberries and something else, and gives you a box that can hold apples and blueberies in separate compartments.
19:55:46 <\z> repeat the process to get a 3-compartment box that holds apples, blueberries and cherries.
19:55:50 <\z> And so on.
19:55:55 <lispy> dons: so, i'd say probably the biggest flaw with using GOA as a library is that you can't change lambdabotHome
19:56:14 <dolio> Well, but the transformed monad still holds values of only one type.
19:56:15 <\z> the monad template library is very tricksy in how it does this magic in the smallest amount of effort.
19:56:27 <dolio> If you don't count the state in reader or state monads, for example.
19:56:28 <lispy> so i shall make that an IORef
19:56:34 <dons> lispy: right. so it should be a parameter. or in the env?
19:56:51 <dons> ok. good.
19:56:59 <dolio> It's more like an attachment for your box that turns it into a refrigerated box for keeping the food cold.
19:56:59 <\z> does that make any sense?
19:57:19 <\z> dolio: sorta.  except that the outer boxes can also serve as containers.
19:57:45 <dolio> Yeah, but your original box could be a state monad, too, where it stores values of two types.
19:57:48 <\z> so you can layer reader, writer, state and IO in one beasty
19:57:55 <dolio> But the state isn't part of the container metaphor.
19:58:02 <\z> but the combined thingy is simultaneously a reader, writer, state and IO
19:58:07 <\z> (well, maybe not IO0
19:58:53 <dons> sjanssen: so should we try to write our own dwm ? :)
20:00:07 <sjanssen> do you think it's do-able?
20:00:20 <monochrom> You can transform your fridge to, in addition containing apples, track inventory state and perform the IO of ordering more apples through the Internet.  Gosh, this is so Bill-Gates-vision.
20:00:21 <lispy> dons: so a friend of mine says today, (and keep in mind both of us are forced to use windows at work) "Windows sucks.  Wanna write a WM for Windows in Haskell and make it work on linux too?"
20:00:53 <dons> sjanssen: I think so. But i'll need to read the dwm and -package X11 source a bit more
20:01:06 <dons> lispy: do they have 3rd party window managers for windows yet?
20:01:24 <lispy> dons: yes, blackbox and some others...have since circa '98
20:01:33 <lispy> dons: just very unpopular :)
20:01:42 <dons> huh, didn't know that was even possible.
20:02:23 <lispy> dons: get this, someone even created a 'theme' (or is it an add-on?) for win 3.11 to make it look and feel like XP
20:02:36 <lispy> people do some crazy things...
20:02:40 <sjanssen> dons: let me know when/if you start hacking
20:03:01 <monochrom> Wow 3.11
20:03:26 <\z> anyone live around DC?
20:03:38 <Cale> \z hi
20:03:44 <\z> Hi Cale.
20:03:53 <Cale> heh, the beeping woke me up :)
20:04:19 <lispy> heh
20:04:22 <dons> sjanssen: ok. i'll see if i can start something this weekend or next
20:04:22 <Cale> actually, that was lispy's fault :)
20:04:32 <lispy> Cale: sorry :)
20:04:39 <Cale> that's cool
20:04:45 <monochrom> > repeat "Cale"
20:04:46 <lambdabot>  ["Cale","Cale","Cale","Cale","Cale","Cale","Cale","Cale","Cale","Cale","Cale...
20:05:09 <dolio> It may have been my fault. I shouldn't have mentioned boxes of apples.
20:05:29 <\z> blame it on the apple
20:05:31 <deadbeef> > length repeat "Cale"
20:05:31 <lambdabot>    The function `length' is applied to two arguments,
20:05:31 <lambdabot>   but its type `[a]...
20:05:31 <\z> it's been done before
20:05:37 <monochrom> or fridge of apples that also tracks inventory state and perform Internet IO.
20:05:40 <deadbeef> > length (repeat "Cale")
20:05:43 <lambdabot> Terminated
20:06:02 <monochrom> (blame Bill Gates)
20:06:11 <\z> when did lambdabot get elected governor of california?
20:06:23 <monochrom> It did?!
20:06:30 <monochrom> Oh oops haha.
20:06:32 <jgrimes> \z, haha
20:07:05 <\z> hm....what would happen if lambdabot were running skynet....
20:07:18 <monochrom> we would have world peace
20:07:25 <monochrom> and correct software
20:07:40 <lispy> hmm..does haddock choke no bangs in data declarations?
20:08:02 <\z> anyway, fringedc had a good first meeting this weekend
20:08:26 <\z> a lot of interest in haskell from a bunch people with interests in "fringe" languages
20:08:34 <\z> (common lisp, scheme, smalltalk, etc.)
20:08:48 <dons> \z, oh you were there? how'd it go?
20:09:00 <\z> yeah.  went well.  just beer and chatting
20:09:00 * dons isn't sure about the "fringe" thing
20:09:10 <newbcoder> is it possible to get lambda bot to say yo instead of "yo" ?
20:09:11 <dons> any other haskellers?
20:09:22 <\z> um, not really.
20:09:37 <\z> I gave a tutorial at oscon this summer.  someone who was at my tutorial attended
20:09:46 <lambdabot> yo!
20:10:03 <\z> dons: "fringe" as in "not c# or java or vb or other 'mainstream' language"
20:10:24 <\z> "fringe" as in lisp, prolog, and other things that are rarely used in production, but should be.  :-)
20:10:27 <dons> I know :) But I think haskell has some visions of going mainstream (or as mainstream as python anyway :)
20:10:42 <\z> the guy behind ucw was passing through
20:11:07 <\z> well, the two languages I heard mentioned most often were haskell and erlang
20:11:11 <dons> I was just pondering that 'fringe' implies 'can be dismissed as never viable'
20:11:23 <\z> 'fringe' came out of lispnyc
20:11:42 <\z> the idea being that 'lispnyc' frightens away people who are similarly minded but not particularly interested in lisp
20:11:47 <\z> per se
20:11:48 <dons> yeah.
20:12:10 <dons> that's true. lispnyc scares me too
20:12:20 <\z> it was like a user group meeting for ruby or python or perl, without the true beliver vibe
20:12:24 <Philippa> I'm not sure 'fringe' has that connotation to those who're on it
20:12:37 <\z> everyone just respected everyone else and were there to swap notes
20:12:55 <Adamant> Higher-Order Languages
20:13:05 <glguy> Alright, I'm back, what'd I miss (c;
20:13:17 <Philippa> it's not, though, and most Python and Ruby users wouldn't realise it refers to them
20:13:23 <dons> heh
20:13:46 * glguy just got smoked in a night of Bridge
20:14:01 <dons> noting that ruby got lots of press when they sun hired some guys last week, maybe we should put about more words on microsoft hiring Igloo ...
20:14:08 <dons> s/they//
20:14:09 <\z> Philipa: they were invited too.  there were a couple of ruby and python conversations
20:15:38 <Philippa> that's what I mean :-)
20:16:25 <\z> it was just the first meeting of fringedc.  decent turnout.  maybe 20 people over dinner and beer.  it's a first step
20:16:37 <\z> I volunteered to do a haskell talk for their second formal meeting.
20:18:09 <dons> cool!
20:18:12 <dons> \z++
20:18:30 <\z> :-)
20:18:56 <\z> I've got some time.  The 'second formal meeting' is scheduled for March.
20:19:12 <dons> oh heh
20:19:47 <dwm> \z: Did you say around DC?
20:19:55 <\z> yeah
20:20:20 <dwm> I'm in Raleigh. Not close, but then again, not so far that meeting is out of the question.
20:20:29 <jgrimes> dwm, I'm in Raleigh
20:20:38 <dwm> jgrimes: dude :)
20:20:39 <\z> dwm: you've got six months to get to DC.  :-)
20:20:56 <jgrimes> dwm, I'm at NCSU
20:21:00 <dons> heya weitzman
20:22:10 <glguy> dons: It was mentioned in #haskell today that GHC6.6 was only around 1 week away, is that true?
20:22:12 <dwm> jgrimes: Cool. I am actually not a student. Perl programming for a living this past couple of years.
20:22:48 <\z> 6.6?  any chance for osx86 support?
20:22:54 <jgrimes> dwm, cool deal
20:24:13 <dons> glguy: yep
20:24:33 <glguy> dons: Just out of curiosity, what's left to wrap up?
20:24:51 <dons> hmm, testing. and the icfp conference
20:25:28 <weitzman> dons: Hello
20:25:36 <glguy> si it being released at the conference?
20:25:38 <dons> glguy: you looking to get hold of some hot ghc cakes fresh from the oven?
20:26:00 <glguy> I'll be waiting at the door for the shop  to open ;)
20:26:06 <dons> no, but the hackers head off to icfp for a week, and the release is after that, I think.
20:26:29 <\z> g'nite y'all
20:26:34 <dons> night \z
20:29:59 <newsham> is this idiom ever used or did I just invent something novel?  http://www.thenewsh.com/~newsham/x/for.hs
20:30:18 <lispy> is there a concatMap for monads?
20:30:28 <glguy> =<<
20:31:08 <deadbeef> ?type <<
20:31:10 <lambdabot> parse error on input `<<'
20:31:11 <lispy> well, i have (a -> m b) and [a]
20:31:15 <lispy> and i want m b
20:31:28 <lispy> ?type (=<<)
20:31:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
20:31:32 <glguy> ?type mapM
20:31:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
20:31:41 <dons> ?type sequence
20:31:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
20:31:46 <lispy> that's m [b], which is really close
20:31:53 <dons> ?type lift concat
20:31:54 <lambdabot> forall (t :: (* -> *) -> * -> *) a. (MonadTrans t) => t ((->) [[a]]) [a]
20:31:58 <dons> ooh
20:32:06 <glguy> ?type foldM
20:32:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:32:08 <lispy> ?type [[a]] -> [a]
20:32:09 <lambdabot> not an expression: `[[a]] -> [a]'
20:32:20 <lispy> ?hoogle [[a]] -> [a]
20:32:21 <lambdabot> Prelude.concat :: [[a]] -> [a]
20:32:25 <dons> foldM yeah.
20:32:38 <dons> concatMap is a foldr, after all
20:32:43 <lispy> idon't think foldM is right
20:32:43 <dibblego> does hoogle find functions that match a given signature?
20:32:49 <glguy> yes
20:32:50 <dons> dibblego: yep
20:32:57 <dons> ?help hoogle
20:32:57 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
20:33:15 <lispy> i think i just need to run concat and then call my monad functionin this case
20:33:31 <lispy> but i want to concat with '\n'...so Data.List.intersperse
20:33:35 <lispy> ?type intersperse
20:33:35 <dons> ?type sequence_ . concat
20:33:36 <lambdabot> forall a. a -> [a] -> [a]
20:33:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m ()
20:33:55 <dons> ?type sequence_ . concatMap
20:33:56 <lambdabot>   Expecting a function type, but found `b'
20:33:56 <lambdabot>    Expected type: (a1 -> [b]) -> [m a]
20:36:32 <lispy> lambdabot> IrcMessage {msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@run 1 + 1 "]} fd:6: hClose: resource vanished (Broken pipe)
20:36:33 <lispy> hm...
20:36:34 <dons> newsham: you mean, is foreach new?
20:36:49 <dons> lispy: no hs-plugins?
20:36:55 <lispy> oh
20:36:56 <dons> i.e. and no 'runplugs' either?
20:36:56 <lispy> right
20:36:57 <lispy> :)
20:37:04 <lispy> so, what is a 'core' command?
20:37:09 <lispy> something i can test with
20:37:11 <dons> newsham: I agree, its rather nice:
20:37:13 <dons>     foreach args (\arg -> do
20:37:13 <dons>         foreach [1..3] (\n -> do
20:37:13 <dons>             putStrLn ((show n) ++ ") " ++ arg)
20:37:27 <dons> though'd I'd toss some $ in there :)
20:37:34 <lispy> nice
20:37:35 <dons> (and foreach is known as forM_ in ghc 6.6)
20:37:39 <lispy> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:37:41 <lambdabot> http://tinyurl.com/jz56b
20:37:48 <lispy> that was the result of 'list'
20:37:53 <dons> yep
20:37:58 <glguy> dons: forM_ = flip mapM_?
20:38:02 <dons> yep
20:38:03 <newsham> dons: yah, is this new or is it a common idiom?
20:38:15 <dons> its not common, but its growing
20:38:19 <newsham> also, seems like it would be easy to transform (say in TH) to make it easier in do blocks
20:38:23 <dons> i've not seen nested forM_/foreach before
20:39:02 <newsham> err.. actually I dont know if it would be easy, but it would be nice.
20:39:04 <lispy> http://lambdabot.codersbase.com/bot2.fcgi?cmd=vixen+hello
20:39:06 <lambdabot> http://tinyurl.com/kf9yq
20:39:07 <dibblego> http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-15/index.html what list functions would assist with solving "1 List Prefix"?
20:39:10 <lambdabot> Title: CSc 372 - Comparative Programming Languages 15 : Haskell -- Exercises, http://tinyurl.com/z8as7
20:39:12 <newsham> the transform is easy, dunno if the parser lets you get wacky like that
20:39:26 <dons> lispy++ !!
20:39:57 <dons> hehe "church is my favourite computer scientist." :)
20:40:15 <jgrimes> lispy, nice nice
20:40:26 <dolio> dibblego: use zip
20:40:27 <dons> note down this date, people, 13-09-2006. today lambdabot == skynet
20:40:32 <weitzman> Are there any famous computer scientists who were party animals and womanizers ala Feynman?
20:40:36 <lispy> lol
20:40:38 <dolio> dibblego: Or, zipWith, actually.
20:40:44 <dibblego> :t zipWith
20:40:49 <jgrimes> weitzman, von neumann
20:40:50 <dibblego> thanks
20:40:53 <lispy> ?remember dons note down this date, people, 13-09-2006. today lambdabot == skynet
20:41:20 <newsham> dibblego: you could easily do it with simple recursion..  zip would work well too
20:41:38 <lispy> dons: and now you can configure the location of lamdabot from your dot-ghci (i think)
20:41:40 <dolio> dibblego: You'll want all, as well.
20:41:41 <weitzman> Actually I hear Bill Gates was quite the player when he was still a rich bachelor
20:41:51 <dons> lispy: oh nice. well done.
20:41:55 <dons> so we can fold that back into goa
20:42:01 <lispy> dons: all a person needs to do to configure it shoul be 'writeIORef lambdabotHome "home"'
20:42:05 <dibblego> I really fail to see how either zip or zipWith solve anything
20:42:13 <newsham> all [x == y | (x,y) <- zip l1 l2]      reads nicely methinks
20:42:13 <dons> lispy: so we can write a little wrapper for that
20:43:01 <dons> I wish for parallel comprehensions sometimes: all [ x == y | x <- l1 | y <- l2 ]
20:43:16 <dons> but i think they're not widely enough used to get up for Haskell'
20:43:16 <dolio> Oops, that should be and, not all.
20:43:18 <monochrom> dibblego: do you want to take a look at Data.List.isPrefixOf? :)
20:43:45 <lispy> dons: are bangs not allowed in data definitions when using haddock?
20:43:49 <dons> lispy: you'll want to update lambdabot, i've disable those IrcMessages now
20:43:49 <glguy> what do you mean " wish for " ... don't they already exist?
20:43:49 <dibblego> not really, just want to understand this problem and how to solve it
20:43:55 <dons> (but i'll have to patch goa too , I think)
20:44:05 <lispy> dons: ah
20:44:07 <dons> lispy: hmm. I think they're ok.
20:44:35 <lispy> okay...i tried to 'haddock'ify GOA.hs but i get an error on the first line with !
20:44:40 <newsham> all (\(x,y) -> x == y) zip(l1, l2)    ?
20:44:48 <lispy> data ST = ST !Handle -- ^ Handle to lambdabot stdin
20:44:58 <monochrom> Write your own recursion, or zipWith (==) then do something extra.  Note that the longer list gets its extra tail ignored.
20:45:42 <monochrom> Oh damn that breaks (begin "xy" "x") doesn't it?
20:45:50 <newsham> dibblego: interactively look at zip [1,2] [1,2,3,4] and   zip [1,2,3,4] [1,2]
20:46:01 <dibblego> zip is associative and begin is not
20:46:02 <newsham> > zip [1,2] [1,2,3,4]
20:46:03 <lambdabot>  [(1,1),(2,2)]
20:46:06 <dibblego> newsham, yes I am doing that right now
20:46:08 <newsham> > zip [1,2,3,4] [1,2]
20:46:09 <monochrom> OK, write your own recursion.
20:46:09 <lambdabot>  [(1,1),(2,2)]
20:46:29 <deadbeef> > [ (x,y) | (x,y) <- zip ( [1..10] [5..15] ), x == y ]
20:46:30 <lambdabot>    The function `[1 .. 10]' is applied to one arguments,
20:46:30 <lambdabot>   but its type `...
20:46:45 <deadbeef> ?type zip
20:46:46 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
20:47:09 <deadbeef> > [ (x, y) | (x, y) <- zip [1..10] [5..15], x == y ]
20:47:10 <lambdabot>  []
20:47:39 <dolio> Oh, so begin [1,2,3] [1] should be False?
20:47:42 <deadbeef> > [ (x, y) | (x, y) <- zip [1..10] [5..15] ]
20:47:43 <lambdabot>  [(1,5),(2,6),(3,7),(4,8),(5,9),(6,10),(7,11),(8,12),(9,13),(10,14)]
20:47:49 <dibblego> dolio, I'd imagine so
20:48:17 <monochrom> > Data.List.isPrefixOf [1,2,3] [1]
20:48:18 <lambdabot>  False
20:48:23 <deadbeef> > [ (x, y) | x <- [1..10], y <- [5..15], x == y ]
20:48:24 <lambdabot>  [(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:48:31 <monochrom> Just remember to test your solution against isPrefixOf :)
20:48:33 <newsham> so you see how you can compare the tuples that come out of zip?  but thats not the whole answer, because comparing them doesnt always tell you if one is a prefix of the other
20:48:48 <deadbeef> > map f [ (x, y) | x <- [1..10], y <- [5..15], x == y ]
20:48:48 <lambdabot>  Not in scope: `f'
20:48:53 <deadbeef> > map fst [ (x, y) | x <- [1..10], y <- [5..15], x == y ]
20:48:54 <lambdabot>  [5,6,7,8,9,10]
20:49:28 <dibblego> newsham, yes I can do it fine in my head; I imagine you'd zip, test if all elements are equal and that length l1 <= length l2
20:49:31 <newsham> an entirely different approach, you could take items from the longer list and see if its equal to the prefix.
20:49:45 <newsham> less efficient compute time wise, but maybe simpler code wise
20:50:06 <jtoy_> is there a haskell web framework?
20:50:33 <dons> jtoy_: HAppS, or HWS or some others
20:50:40 <Lemmih> jtoy_: There are several.
20:50:44 <dons> check the 'libraries and tools' link on haskell.org
20:50:45 <newsham> > let pref a b = a == (take (length a) b) in pref "foo" foobar"
20:50:46 <lambdabot>  Improperly terminated string
20:50:51 <newsham> > let pref a b = a == (take (length a) b) in pref "foo" "foobar"
20:50:52 <lambdabot>  True
20:50:58 <newsham> > let pref a b = a == (take (length a) b) in pref "foobar" "foo"
20:50:59 <lambdabot>  False
20:51:10 <newsham> > let pref a b = a == (take (length a) b) in pref "bar" "foobar"
20:51:10 <lambdabot>  False
20:51:46 <newsham> haskell server pages
20:52:01 <jtoy_> thanks
20:52:03 <dons> ah yes, I meant HSP, but typed HWS :)
20:52:17 <dons> ?where HAppS
20:52:17 <lambdabot> http://happs.org
20:52:22 <dons> ?where HSP
20:52:22 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
20:52:30 <jtoy_> hmm, thats a nice hello world example: http://happs.org/HAppS/examples/hello.hs
20:53:13 <dons> huh. kind of reminiscent of a lambdabot plugins!
20:53:17 <newsham> ?check \x,y = let pref a b = (a :: [Char]) == (take (length a) b) in isPrefixOf a b == pref a b
20:53:17 <lambdabot>  Parse error
20:53:25 <newsham> ?check \x,y = let pref a b = (a :: [Char]) == (take (length a) b) in isPrefixOf a b == pref a b
20:53:25 <lambdabot>  Parse error
20:53:28 <newsham> oops
20:53:35 <dolio> dibblego: You can write it in terms of foldl, although it might be ugly.
20:53:45 <newsham> ?check \a b = let pref a b = (a :: [Char]) == (take (length a) b) in isPrefixOf a b == pref a b
20:53:45 <lambdabot>  Parse error
20:54:08 <newsham> I give up
20:54:26 <dons> \a b = ? <-- wrong syntax
20:54:43 <lispy> dons: i'm going to create a .cabal file and place this 'bot.hs' file into the GoA repository
20:54:54 <weitzman> Is there a good tutorial/article about function monads (or the arrow monad, if that's what I'm talking about)?
20:54:55 <newsham> yah, i can never remember the ?check syntax
20:55:06 <dons> its just haskell
20:55:12 <dons> lispy: ok.
20:55:15 <dons> and darcs send?
20:55:17 <dons> or i'll pull?
20:55:19 <lispy> yup
20:55:28 <lispy> i don't have this one public, so i'll send
20:55:29 <deadbeef> > let f 0 = (1, 0); f 1 = (1, 1); f x = (y + z, y) where (y, z) = f (x - 1) in f 15
20:55:30 <lambdabot>  (987,610)
20:56:20 <dons> ?check \x y -> let prop a b = (a :: [Char]) == take (length a) b in isPrefixof a b == prop a b
20:56:20 <lambdabot>  Not in scope: `b'
20:56:28 <dons> ?check \a b -> let prop a b = (a :: [Char]) == take (length a) b in isPrefixof a b == prop a b
20:56:28 <lambdabot>  Not in scope: `isPrefixof'
20:56:34 <dons> ?check \a b -> let prop a b = (a :: [Char]) == take (length a) b in isPrefixOf a b == prop a b
20:56:35 <lambdabot>  OK, passed 500 tests.
20:56:42 <deadbeef> > let f 0 = (1, 0); f 1 = (1, 1); f x = (y + z, y) where (y, z) = f (x - 1); f' x = fst (f x); f'' 0 = 1; f'' 1 = 1; f'' x = f'' (x - 1) + f'' (x - 2) in f'' 10
20:56:43 <lambdabot>  Not in scope: `f'''
20:58:54 <weitzman> If I'm trying to understand (return (+)), is Control.Arrow the right place to look?
20:59:27 <dons> hmm, isn't that a Monad ((->) a) instance?
20:59:33 <dons> ?type return (+)
20:59:34 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m (a -> a -> a)
20:59:37 <weitzman> dons: I dunno. You tell me!
20:59:47 <lispy> dons: oh hmmm..you can only have one .cabal file in a directory...
20:59:49 <weitzman> Is (->) documented somewhere?
21:00:02 <dons> ?docs Control.Monad.Instances
21:00:02 <lambdabot> Control.Monad.Instances not available
21:00:12 <dons> bah, its there...
21:00:12 <dons> [A
21:00:17 <dons> ?docs Control.Monad
21:00:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
21:00:41 <dons> ?fptools Control.Monad
21:00:41 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
21:01:04 <lispy> oh, n/m
21:01:06 <dons> the type above suggests to me it isn't any special magic, weitzman
21:01:07 <dibblego> how do you get rid of the parentheses from f1 (f2 x) y using $ or . ?
21:01:40 <dons> f1 . f2 x $ y ?
21:01:51 <dons> oh, no.
21:02:02 <dons> ?pl f1 (f2 x) y
21:02:03 <lambdabot> f1 (f2 x) y
21:02:13 <weitzman> dons: It may be very mundane magic, but I don't know what implementation of return is being invoked
21:02:25 <dons> well, it depends on the monad you're in.
21:02:28 <dons> which is?
21:02:42 <weitzman> dons: Oh, I think I'm being partially stupid
21:02:44 <dons> you can't tell just from the fragment: return (+) which monad it is.
21:02:47 <dons> ?type return (+)
21:02:48 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m (a -> a -> a)
21:02:59 <dons> ^^ see, its parameterised over the monad
21:03:09 <dolio> f1 $ f2 x $ y?
21:03:13 <dons> ?type return (+) :: IO (Int -> Int -> Int)
21:03:14 <lambdabot> IO (Int -> Int -> Int) :: IO (Int -> Int -> Int)
21:03:29 <dolio> ?pl f1 $ f2 x $ y
21:03:29 <lambdabot> f1 (f2 x y)
21:03:37 <dolio> Ah, nope.
21:03:55 <weitzman> What I'm *actually* trying to do is figure out how (liftM2 (==) f g) works
21:04:00 <dons> weitzman: fwiw, here's the Monad -> a instance, but I think its not relevant in this case, http://darcs.haskell.org/packages/base/Control/Monad/Instances.hs
21:04:03 <lambdabot> http://tinyurl.com/gwk7s
21:04:04 <AtnNn> flip f1 y $ f2 x
21:04:13 <dons> ?type \f g -> liftM2 (==) f g
21:04:14 <lambdabot> forall a2 (m :: * -> *). (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
21:04:28 <dons> ?fptools Control.Monad
21:04:29 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
21:04:38 <dons> ^^ to check how liftM* works
21:04:59 <weitzman> @type liftM2 (==)
21:05:01 <lambdabot> forall a2 (m :: * -> *). (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
21:05:09 <weitzman> The next argument is an (m a2)
21:05:12 <weitzman> whatever that means
21:05:17 <weitzman> And I pass a function
21:05:38 <newsham> is (liftM2 (==)) any different than (==) ?
21:05:49 <weitzman> Oh, but M is a ->
21:06:03 <weitzman> And I keep ignoring the existense of the (->) monad
21:06:31 <dons> an m a2, is a monadic action
21:06:32 <dolio> liftM2 (==) is \f g x -> (f x) == (g x)
21:06:33 <newsham> > (liftM2 (==)) [1] [1]
21:06:33 <lambdabot>  [True]
21:06:35 <weitzman> *s/s/c/
21:06:39 <newsham> ahh.. i get it
21:06:44 <dolio> For functions.
21:06:47 <dons> so liftM2 (==) takes two monad actions, and returns == applied to it, in the same monad
21:06:52 <dons> it lifts a function of 2 args into a monad
21:06:53 <newsham> > (liftM2 (==)) "foo" "foo"
21:06:54 <lambdabot>  [True,False,False,False,True,True,False,True,True]
21:07:05 <dons> ^^ in that case the list monad
21:07:14 <dons> often you'll see functions of one argument lifted:
21:07:15 <dwm> It's lifting the function into the monad so that it can act on the two args?
21:07:24 <dons> liftM (map toUpper) (getContents)
21:07:44 <dons> ie. getContents >>= return . map toUpper
21:07:52 <lispy> so, cabal says copy dist/build/bot.fcgi/bot.fcgi to ~/webspace/codersbase/lambdabot/bot.fcgi
21:07:53 <dons> dwm, yep.
21:07:56 <lispy> and ls disagrees
21:08:02 <lispy> $ ls -l ~/webspace/codersbase/lambdabot/bot.fcgi
21:08:02 <lispy> ls: /home/dagit/webspace/codersbase/lambdabot/bot.fcgi: No such file or directory
21:08:11 <glguy> > liftM2 (/) sum genericLength [1,3,7,10]
21:08:12 <lambdabot>  5.25
21:08:42 <newsham> > liftM2 (+) [-2,2] [10, 20]
21:08:43 <lambdabot>  [8,18,12,22]
21:08:59 <weitzman> Well, liftM has type (a -> b) -> a m -> b m, if my memory serves me
21:09:08 <dons> newsham: so one point (you may well receive email on this) is that we don't tend to add syntax for control structures (except for the special if-then-else case)
21:09:11 <dwm> newsham: Oh, that's spooky.
21:09:11 <weitzman> @type liftM
21:09:12 <glguy> > liftM2 (/) (asks sum) (asks genericLength) [1,3,7,10]
21:09:13 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:09:13 <newsham> > liftM2 (+) (Just 5) (Just 3)
21:09:13 <lambdabot>  5.25
21:09:14 <lambdabot>  Just 8
21:09:19 <weitzman> Yay
21:09:24 <dons> so likely people will just say: live with foreach [1..10] $ \x -> ... :)
21:09:33 <newsham> > liftM2 (+) (Just 5) Nothing
21:09:34 <lambdabot>  Nothing
21:09:49 <dons> now, whether TH can do this, depends on whether  foreach args arg parses as valid haskell
21:10:00 <newsham> dons: yah, which is why i'm curious if I can add it myself with TH.
21:10:03 <dons> if its parses. then you can transform it all you want.
21:10:27 <newsham> the thing is, this interacts with the way that whitespace is parsed...
21:10:31 <dons> its things that aren't currently valid haskell grammar that won't parse (but i think this will parse as some type-incorrect expr)
21:10:34 <newsham> which makes me think that TH wont be up to snuff
21:10:49 <dons> hmm possibly
21:11:17 <newsham> not that the syntax is unbearable without the extra sugar...
21:11:25 <dons> you may have to live with: foreach x (foreach y ..)
21:11:34 <dons> to get the right parsing without making your life too hard
21:11:52 <glguy> You could always just use C# (c;
21:11:53 <dons> and then just rewrite the 'foreach' token into the right hsSyn structure
21:11:58 <weitzman> > liftM (not . ) (==) 1 2
21:11:59 <lambdabot>  True
21:12:09 <newsham> one thing I dislike about the whitespace rules is that I have to move the closing brace just one over from being lined up underneath the line that started it
21:12:12 <newsham> else it gives a syntax error
21:12:20 <newsham> (also same when using {}'s)
21:13:23 <glguy> > ap (++) reverse "asdf"
21:13:24 <lambdabot>  "asdffdsa"
21:14:35 <dons> Lemmih: we have forM_ now too, but newsham's point is that he wants a if-then-else syntaxy feel for foreach, using TH or something like it
21:15:57 <Lemmih> dons: Wasn't the point to remove the parentheses?
21:16:55 <dons> and the lambdas?
21:17:08 <weitzman> @check (\f x -> liftM f x == (x >>= return . f)) :: (Int -> Int) -> [Int] -> Bool
21:17:11 <lambdabot>  OK, passed 500 tests.
21:17:17 <Lemmih> I kinda like the lambdas.
21:17:22 <lisppaste2> dolio pasted "foldl begin for dibblego" at http://paste.lisp.org/display/25933
21:17:36 <dons> yeah, I've no problem with first class control structures either :)
21:17:36 <dibblego> thanks
21:18:02 <dons> a little tutorial on rolling your own keywords might be fun though, using some small preprocessor or TH
21:18:16 <newsham> ahh.. forM_
21:18:25 <dolio> dibblego: I think writing out the recursion explicitly is the way to go for that one.
21:18:40 <dibblego> dolio, my head hurts
21:18:40 <Lemmih> It can't be done with TH, though. (not nicely anyway)
21:19:02 <newsham> the (flip mapM_) doesnt read very nicely :)
21:19:07 <sjanssen> newsham: nested for loops are probably done better with a list comprehension
21:19:09 <newsham> forM_ reads fine though
21:19:16 <dons> (`mapM_` [1..10]) $ \args ...
21:19:20 <dons> is another way
21:19:26 <newsham> sjanssen: even in IO monad?
21:19:26 <dons> little-known, though
21:19:45 <newsham> dons: yah, but forM_ even easier to type and read
21:19:49 <dons> good point. sequence_ [ do .... ; do ... | <- ... ]
21:20:03 <lispy> dons: okay, sent both patches
21:20:14 <lispy> now we tell ndm?
21:20:38 <lispy> dons: oh, and maybe we needed to update GoA to work with latest lamdabot?
21:20:49 <dons> well, let me testify things
21:20:49 <sjanssen> newsham: sure, just like dons wrote
21:21:03 <newsham> having the iterated variables come at the end (as in list comprehensions) would make for a bad read, too.
21:21:19 <lispy> dons: good idea
21:21:44 <newsham> hmm.. except I dont see forM_ in my ghc
21:22:32 <dons> its only in 6.6
21:22:37 <dons> you'd need a snapshot.
21:22:45 <newsham> I can make my own for the time being
21:22:49 <dons> it is just: forM_ = flip mapM_ if you want to write your own.
21:22:52 <newsham> yup
21:23:10 <glguy> Will there be a forM to compliment that?
21:23:20 <dons> #if __GLASGOW_HASKELL__ >= 606 import Control.Monad (forM_) #else forM_ = flip mapM_ #endif
21:23:26 <dons> glguy: there is, yes.
21:27:12 <dons> ?uptime
21:27:12 <lambdabot> uptime: 1d 19h 42m, longest uptime: 2d 8h 20m 7s
21:27:38 <lispy> dons: if i set a bindir when i compile lambdabot will that copy things like runplugs to the right location?
21:27:44 <deadbeef> ?version
21:27:45 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
21:27:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:27:46 <lispy> dons: or should i manualy move stuff?
21:28:07 <dons> bindir will copy things where you specify, yes.
21:28:12 <lispy> sweet!
21:28:12 <dons> but lambdabot needs to be int he lambdabot dir/
21:28:14 <lispy> cabal++
21:28:25 <dons> runplugs, bf etc, will work anywhere though
21:28:41 <lispy> dons: if move State then will lambdabot be okay?
21:29:19 <dibblego> http://en.wikipedia.org/wiki/Proof_by_exhaustion "Each cube number is the cube of some integer n. This integer is either a multiple of 3, or is 1 more or 1 less than a multiple of 3" -- don't all integers fit that criteria anyway?
21:29:22 <lambdabot> http://tinyurl.com/k68u7
21:29:25 <dons> hmm. there may be hard coded assumptions that State/ is in ""
21:29:26 <dons> "."
21:29:39 <dons> best for now to leave lambdabot in the lambdabot tree, if possible
21:29:41 <lispy> yeah, i was going to preserve that relation
21:30:01 <lispy> dons: hmm...i didn't really want to put the whole lambdabot install in a public html dir
21:30:02 <dons> it should only need lambdabot and State though, just to be in the same dir
21:30:20 <dons> right. I think, just having all the bins in one dir, with State in the same place, will work
21:30:23 <dons> i think...
21:30:36 <dons> so you could use --bindir, and also copy ShowQ.* and State/ into that dir.
21:30:47 <lispy> actually, i think i'm disabling most state based plugins anyway
21:31:04 <dons> yep. good idea.
21:33:44 <dons> lispy, btw, there's a 'b' in 'lambda' :) you missed this _twice_ in the dot-ghci file ;)
21:34:08 <lispy> dons: sorry :(
21:34:18 <lispy> i didn't test the dot-ghci :(
21:34:34 * lispy goes to put his old glasses on for a while
21:34:36 <dons> ok, all good now:
21:34:38 <dons> $ ghci
21:34:38 <dons> GOA> :t lambdabot
21:34:38 <dons> lambdabot :: String -> String -> IO [Char]
21:34:38 <dons> GOA> :pl \x y f -> f y + f x
21:34:40 <dons> lambdabot> flip (ap . ((+) .) . flip id) . flip id
21:34:46 <dons> just need to filter the prompt
21:35:58 <dons> ok done.goa works again. let's try this fastcgi now.
21:36:55 <dons> ?where fastcgi
21:36:56 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/
21:37:30 <lispy> oh yeah, you'll be chasing deps for a bit
21:37:39 <lispy> and it looks like fastcgi.cabal has a typo
21:37:51 <lispy> it requuests cgi>=blah and it should be cgi-compat
21:38:00 <dibblego> I justify the advantage of referential transparency by stating that the world is immutable, but mutable time is an axiom of software relative to the observer - are there any publications that try to explain it?
21:38:01 <lispy> i forgot to tell bringert wheni had the chance
21:38:10 <dons> fastcgi has further dependencies?
21:38:23 <lispy> fastcgi depends on cgi-compat
21:38:29 <dons> ok
21:38:36 <lispy> but i think that ends the chain
21:38:42 <lispy> oh, well fps too
21:38:45 <lispy> but you might ahev that :)
21:38:58 <glguy> referential transparency is easy to justify if you want to be able to reason about the correctness and behavior of a given function
21:39:03 <dons> dibblego: hmm. the RealWorld# stuff in 'Tackling the Awkward Squad'
21:39:17 <dibblego> yes but the ability to reason is not absolute, it's just a benefit, with a potential drawback
21:40:00 <dibblego> *why* can you reason? I have always held the position that most people don't understand time very well
21:40:01 <glguy> I'd kill to be able to reason about half the functions actually do at work that people have been writting
21:40:16 <glguy> what half*
21:40:19 <dibblego> time is required for a computer to compute
21:40:41 <dibblego> it is time that is mutable and if time is mutable, everything else becomes immutable
21:40:57 <lispy> dons: should i update my lambdabot now?
21:41:06 <dibblego> thanks dons
21:41:29 <dons> lispy: yep.
21:41:45 <lispy> cool, and goa i would assume as well
21:41:47 <dons> lispy, is cgi-compat /= cgi?
21:41:59 <dons> http://darcs.haskell.org/packages/cgi
21:42:02 <lambdabot> Title: Index of /packages/cgi
21:42:09 <dibblego> when a client states his requirements for some piece of software, he states that "from inception to the collapse of time itself, this software, given inputs i will result in output o (i -> o)" -- this is a paraphrase of a basic premise of software?
21:42:13 <dons> oh, I see: http://darcs.haskell.org/packages/cgi/mk-cgi-compat.sh
21:42:14 <lambdabot> http://tinyurl.com/z6cu5
21:42:19 <lispy> dons: i'm not sure, but changing the .cabal file to say cgi-compat instead of cgi works.  So I don't know what's goingon
21:42:28 <dibblego> I'll go back to philosophy land, bye
21:42:55 <dons> maybe we just depend on 'cgi' the?
21:42:56 <dons> n
21:42:56 <lispy> dons: i wanted to ask bringert before jumping to conclusions
21:42:59 <dons> ok
21:43:13 <lispy> for now i'll just hack my .cabal file and it works :)
21:44:13 <dons> ?where+ haskell-cgi http://www.cs.chalmers.se/~bringert/darcs/haskell-cgi/
21:44:13 <lambdabot> Done.
21:44:27 <dibblego> fwiw, I found some discussion here: http://lambda-the-ultimate.org/node/724 "taking into account the time dimension, which is the underlying factor which creates the illusion of mutable state."
21:44:27 <dons> seems to be about 5 patches ahead of the darcs.haskell.org repo
21:44:28 <lambdabot> Title: Haskell for C Programmers | Lambda the Ultimate
21:46:57 <lispy> dons: input in bf should have been harmless, but disabling it was probably a good idea too...did you just make the instruction ignored?
21:48:27 <lispy> which module provides let?
21:48:34 <lispy> ?help run
21:48:34 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
21:49:31 <dons> lispy: yep. since it just produced an error about closed handles
21:49:38 <dons> eval provide let
21:49:49 <dons> comment it out from the moduleCmds list to disable just that
21:50:03 <dons> 10:45 dons:: @bf ,.
21:50:03 <dons> 10:45 lambdabot::  bf:<stdin>:hGetChar:illegaloperation(handleisclosed)
21:50:09 <dons> was what i tried to kill
21:50:23 <lispy> yeah
21:50:43 <lispy> i hate conflicts with darcs
21:50:44 <lispy> grrr
21:50:52 <lispy> i have no idea which changes are yours and which are mine
21:51:11 <dons> yours are the ones that will disappear if you revert
21:51:15 <dons> ;)
21:51:24 <lispy> true
21:52:09 <lispy> next, the cgi page could use a bit of work maybe?
21:52:22 <lispy> but i guess as is, it's realy easy to machine accept the output
21:54:41 <dons> yeah, i'd imagine a nice menu of plugin functions, some input field and so on
21:55:32 <lispy> yeah, with full web interactivity....
21:55:43 <lispy> and maybe a way to say, raw
21:55:54 <lispy> so that if you're a webservice you don't have to deal with pretty html
21:56:07 <dons> also, you'll want to check how logs are created
21:56:16 <dons> we definitely want to ensure full logging is working
21:56:27 <dons> ie. what's ending up in State/Log/*
21:57:02 <lispy> hmm...speaking of which, i just deleted that and it stopped working :)
21:57:12 <dons> (I think I need to tweak the log module to record lambdabot commands, also)
21:57:57 <lispy> hmm...i think i'm having goa issues
21:58:11 <dons> and we need a better name than package bot :)
21:58:30 <dons> lambdabot-live :)
21:58:48 <lispy> you don't like bot???? ;)
21:59:01 <dons> -package lambdabot.net ;)
21:59:13 <jgrimes> lambdabot-live-web-2.0-beta
21:59:52 <dons> heh
22:00:01 <lispy> hmm..
22:00:07 <dons> oh and I need fcgiapp.h
22:00:13 <lispy> i can load up lambdabot on the commandline just fine
22:00:22 <lispy> oh, i forgot to build fastcgi yeah
22:00:35 <lispy> i just did, sudo apt-get install libfcgi-dev
22:01:23 <lispy> hrm...
22:01:37 <lispy> okay, i can run ghci and load GOA and communicate with lambdabot
22:01:45 <lispy> and i can run it on the commandline, but my fcgi is failing
22:02:04 <lispy> why would that suddnely start happening...
22:02:43 <dibblego> which debian package contains Prelude.hs ?
22:03:07 <lispy> maybe a ghc-src pacakge
22:03:43 <dibblego> found it I think ghc6-libsrc
22:07:14 <dibblego> how come there are just function names separated by commas in Prelude.hs and not their definitions?
22:07:26 <lispy> dibblego: keepreading
22:07:30 <lispy> they are in their
22:07:32 <lispy> there
22:07:41 <dibblego> I don't see them - it is 193 lines long
22:07:57 <lispy> hmm...
22:08:16 <dibblego> http://rafb.net/paste/results/ZROVtk84.html
22:10:13 <Pupeno> installing a package anywhere requires to modify a central package.conf ?
22:10:38 <dolio> dibblego: Oh, it's just importing a bunch of packages and then re-exporting stuff.
22:10:40 <lispy> dibblego: maybe their hidden inside an imported module? import GHC.Base
22:10:44 <dons> nope, you can modify a local pakcage.conf
22:10:56 <dons> --user argument to cabal
22:10:59 <dibblego> dolio, what does that mean and where can I see the function definitions?
22:11:03 <lispy> dons: i'm not confident the new GOA + new lambdabot is happy
22:11:33 <dolio> If you look below, there are a bunch of "import ..." lines. The functions are defined there.
22:11:34 <dons> hmm. let me double check
22:11:34 <lispy> dons: i'm doing a double check on all the parts involved recompiling...just yeah...not sure it's working nicely
22:11:50 <dons> maybe i forgot to push something
22:11:57 <dolio> Prelude imports the other modules, and then exports the functions that should be in the prelude.
22:12:07 <dibblego> dolio, is there a way to derive the .hs file from the module name?
22:12:21 <glguy> is there a better idiom for this: length [() | [a,b] <- choose 2 sets, check a b]?
22:12:27 <dibblego> actually I think I can figure it out
22:12:31 <dolio> import Foo.Bar.Baz is in Foo/Bar/Baz.hs
22:12:49 <dons> glguy: you could write that as a foldl'
22:13:09 <glguy> dons: do you think that would be more clear?
22:13:18 <dons> lispy: what behaviour have you seen that seems strange?
22:13:24 <dons> glguy: hmm, not sure. maybe?
22:13:37 <dons> or just a length . filter . map ?
22:13:45 <lispy> dons: try this, 'haddock map'
22:13:53 <lispy> mmand, try @list
22:14:07 <lispy> i typed haddock but meant hoogle
22:14:11 <lispy> then things got weird
22:14:11 <dons> ok
22:14:17 <dibblego> is the term "foreign" used to denote native functions?
22:14:24 <dons> yes
22:14:34 <lispy> then i get this when i correct the haddock to hoogle: TH: getEnv: does not exist (no environment variable)
22:14:52 <dons> ok, so hoogle map works nicely here
22:15:09 <dons> $ ghci
22:15:10 <dons> GOA> :hoogle map
22:15:10 <dons> Prelude.map :: (a -> b) -> [a] -> [b]
22:15:11 <dons> ...
22:15:18 <lispy> oh, i'm missing the hoogle database
22:15:28 <dons> ah
22:15:32 <dons> its not in State? bad dons
22:16:05 <lispy> scripts/hoogle/src/hoogle.txt
22:16:06 <dons> yeah, hoogleText = "./scripts/hoogle/src/hoogle.txt"
22:16:10 * dons fixies
22:16:48 <lispy> p :: (a -> b) -> [a] -> [b] Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
22:16:56 <lispy> so, i should tweak the cgi a bit
22:17:00 <lispy> hmm..
22:17:19 <dibblego> why are some files file.hs and others are file.lhs ?
22:17:20 <lispy> i interpersed '\n' and set it to text/plain for output...but maybe my broweser doesn't care
22:17:22 <Pupeno> where's the user package.conf that is used when using --user ?
22:17:36 <dons> in ~/.ghc/
22:17:48 <dons> dibblego: .lhs is literate haskell, an alternative comment style
22:17:49 <Pupeno> dibblego: hs is haskell and lhs is literate haskell.
22:17:54 <dons> .lhs <-
22:18:13 <lispy> dons: okay, looks like parsing of error output is a bit off
22:18:20 <dons> lispy, ok, fixed the hoogle issue
22:18:24 <dons> it just looks in State/ now
22:18:28 <dibblego> the comment style looks the same to me
22:18:40 <lispy> dons: cool, well i need to hack on this another
22:18:53 <lispy> dons: er, another day...i'm sleepy and need to get up early tomorrow :)
22:18:59 <Pupeno> and where do you normally install libraries when using --user ? ~/.ghc/ as well ?
22:19:02 <lispy> but, we're right there....
22:19:06 <lispy> at the event horizon
22:19:23 <dons> yep good
22:19:35 <Pupeno> dibblego: in .lhs everything is comment unless it starts with > in which it is code.
22:19:51 <dons> Pupeno: ~/ ? i.e. into /home/$USER/lib
22:20:22 <lispy> dons: type isn't getting parsed correctly either
22:20:33 <lispy> . (a -> b) -> [a] -> [b]
22:20:45 <lispy> but, that's enough for one day
22:20:52 <lispy> i should probaby put this away till at least friday :)
22:20:55 <dibblego> Pupeno, it doesn't look that way in this file Base.lhs http://rafb.net/paste/results/puhEyU42.html what am I missing?
22:23:09 <dibblego> brb
22:23:15 <Pupeno> dibblego: oh, that's another kind of literate haskell.
22:23:32 <dibblego> oh the alternate alternate literate haskell :)
22:23:46 <dibblego> what makes it different?
22:23:54 <Pupeno> dibblego: in that kind, code starts at \begin{code} and ends up at \end{code}. The rest is comments (in LaTeX notation).
22:24:08 <dibblego> ok thanks
22:24:16 <Pupeno> dibblego: you can compile that file to PDFs and take it with you to read on the bus.
22:24:25 <dibblego> sounds fun
22:26:16 <lispy> dons: god, i *just* now understood this line: ">tobadbmal\n" `isPrefixOf` acc = return $ reverse (drop 11 acc)
22:26:28 <lispy> i kept going "wtf? is tobadbmal...."
22:26:42 <lispy> to bad bmal
22:27:05 <lispy> > reverse "lambdabot"
22:27:06 <lambdabot>  "tobadbmal"
22:27:15 <dons> :)
22:27:17 <dons> sorry
22:27:25 <dons> I was feeling a bit perverse that day
22:27:30 <lispy> hehe
22:27:34 <Pupeno> I am running ghc 6.4.2 from the Gentoo Overlay. Shouldn't I already have FPS ?
22:27:56 <dons> nope. only comes by deflt with ghc 6.6 and hugs 2006
22:28:29 <Pupeno> ok.
22:28:35 <dons> ok, so now I can finally try to build -package bot
22:28:45 <dons> done
22:28:48 <dons> cabal++
22:29:05 <lispy> heh
22:29:09 <lispy> you're gonna catch up to me
22:29:21 <dons> getting there,
22:29:22 <dons>  $ ./bot.fcgi
22:29:22 <dons> bot.fcgi: user error (FCGX_Accept failed)
22:29:24 <dons> :)
22:29:29 <lispy> sweet!
22:29:48 <lispy> do you have a fastcgi server?
22:29:55 <dons> nope
22:29:55 <lispy> we need a way to 'emulate' it maybe for testing?
22:29:59 <dons> yeah
22:30:10 <lispy> i could give you shell and webspace on my server
22:30:20 <lispy> if you want a place to test stuff
22:30:36 <dons> I'll see if I can set it up on my box
22:30:43 <lispy> okay
22:30:50 <dons> bot.hs needs -fallow-overlapping-instances  ?
22:31:07 <lispy> let's see...i seem to recall an issue with the CGI monad
22:31:11 <dons> oh hmm
22:31:16 <lispy> take it out and see what happens?
22:31:37 <dons> should be in the .cabal file anyway
22:31:46 <dons>     Overlapping instances for MonadCGI (CGIT IO)
22:31:50 <dons> huh
22:32:05 <lispy> i'm totally mystified as to why goa works flawlessly but bot.hs is not getting the right output
22:32:46 <dons> just pushed some small wibbles to fcgi/
22:33:15 <lispy> cool
22:35:00 <lispy> anyway, i'm sleeping now :)
22:35:03 <lispy> thanks for the help today
22:36:19 <dons> no worries
22:39:34 <lispy> i think it's cool how all the different pieces go together
22:39:44 <lispy> and afaik, each piece is open source
22:39:49 <lispy> all the way down to apache and the OS
22:40:08 <dons> yeah its cool. i was getting the feeling just then that cabal was really working for haskell
22:40:23 <dons> we were pulling pieces from all over the place, they were getting checked, and things just worked
22:40:28 <lispy> yeah, darcs + cabal is great
22:40:33 <dons> with darcs gluing it all together
22:40:34 <dons> yeah
22:40:39 <lispy> darcs++
22:40:40 <lispy> cabal++
22:40:43 <lispy> haskell++
22:40:46 <lispy> opensource++
22:40:47 <lispy> :)
22:40:52 <lispy> spam--
22:40:56 <dons> heh
22:42:42 <sieni> java--
22:43:26 <dfranke> What's the right way to put a GHC pragma into literate source?
22:43:35 <dons> that's dangerous. simply speaking about java is like to throw lambdabot into a karma rage
22:44:18 <dons> dfranke: what kind of literate source?
22:44:22 <dons> bird style or latex?
22:44:24 <dfranke> latex
22:44:27 <lispy> dfranke: but it in the first comment of source
22:44:31 <dons> if latex, \begin{code}
22:44:32 <dons> {-# OPTIONS_GHC -fno-implicit-prelude #-}
22:44:33 <lispy> dfranke: er put
22:44:40 <dons> if bird, > {-# OPTIONS_GHC -fno-implicit-prelude #-}
22:44:41 <dons> I think.
22:44:48 <dons> for whatever pragma you want.
22:44:58 <dfranke> you guessed the right one :-)
22:45:07 <lispy> well, with bird you probably have to buffer that line with "> " on the line before it
22:45:31 <lispy> wasn't i disappearing? geez
22:45:40 <lispy> i'm a like a bad habbit around heree
22:46:19 <dfranke> bad hobbits are pretty /good/ at disappearing.
22:46:30 <weitzman> Lambdabot and I have come to an understanding about what (f >>= (\r s -> ...)) does if f only takes one argument, but I still can't see the significance of ((==) >>= (\r a -> ...)) if there is any.
22:47:33 <weitzman> Higher-order functions make my head hurt
22:47:36 <sieni> literate programming must be one of the most obnoxious inventions in the field of programming ;-)
22:47:48 <dolio> That's in the ((->) r) monad.
22:47:50 <dfranke> sieni: why?
22:47:56 <dons> > map (+1) [1..10] -- is nice in irc though :)
22:47:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:47:59 <dolio> Which is the reader monad.
22:48:18 <dons> ?hoogle Reader
22:48:18 <lambdabot> Control.Monad.Reader :: module
22:48:18 <lambdabot> Control.Monad.Reader.Reader :: r -> a -> Reader r a
22:48:18 <lambdabot> Control.Monad.Reader.Reader :: newtype Reader r a
22:48:26 <weitzman> dolio: I don't know what that means, but I'm filing in my head that (->) has something to do with Reader
22:48:49 <chessguy> not always, weitzman
22:49:00 <dolio> Well, reader is usually defined as newtype Reader = Reader (r -> a)
22:49:00 <dons> instance MonadReader r ((->) r) where
22:49:00 <dons>     ask       = id
22:49:00 <dons>     local f m = m . f
22:49:15 <dolio> r is the immutable state passed around.
22:49:25 <dons> newtype Reader r a = Reader { runReader :: r -> a }
22:49:31 <weitzman> dons: I was very disappointed with I got > (==) :: ((->) Int (Int -> Bool)) to typecheck and then realized I had only stated the obvious. I was hoping for some kind of revelation
22:49:48 <dons> heh
22:50:02 <dons> well, you're heading somewhere I think
22:50:14 <dons> not quite sure which road, or which direction, but you're definitely _moving_
22:50:21 <bourbaki> moin
22:50:32 <weitzman> I'm moving it tight little circles, but hopefully with an outward spiral
22:51:13 <bourbaki> dons did you read the mini text?
22:51:19 <dolio> The reader monad, essentially, adds a parameter to all functions which is the mutable state.
22:51:19 <dons> just answer now.
22:51:26 <dons> s/answering/
22:51:41 <bourbaki> ah cool
22:51:53 <dolio> Just like the state monad adds an implicit state parameter (and causes state to be passed out, as well).
22:52:51 <dfranke> ok, I think I'm sold on Haskell now.  I just wrote this up for my cryptography class, and it probably would have taken about half-again as much code in Lisp and been limited to integers: http://daniel.franke.name/convolve.pdf
22:53:46 <weitzman> dolio: I was reading about the Reader monad a day or two ago, but it's not clear to me how it gets involved in (->). (->) seems to have the power to compose functions
22:54:27 <bourbaki> has anyone of you ever heared of algebraic petri nets ?
22:55:04 <weitzman> @check (\f x -> (f >>= (\r s -> r)) x == f x) :: (Int -> Int) -> Int -> Bool
22:55:05 <lambdabot>  OK, passed 500 tests.
22:55:10 <dolio> Well, newtype Reader r a = Reader (r -> a)
22:55:10 <dfranke> does that have something to do with generalizing the multiplication of bacteria?
22:55:16 <dolio> Reader r is the monad.
22:55:26 <weitzman> @check (\f x -> (f >>= (\r s -> s)) x == x) :: (Int -> Int) -> Int -> Bool
22:55:27 <lambdabot>  OK, passed 500 tests.
22:55:29 <dons> weitzman: that's a nice little check
22:55:46 <dolio> If you look, that's Reader r = Reader (r ->) = Reader (->) r
22:56:31 <dolio> So when you bind functions with reader, it passes the same value to the first parameter of all of them.
22:56:45 <glguy> dolio: how about that problem "evaluate 28433 * 2^7830457 + 1" (c;
22:57:04 <bourbaki> dons would two or three graphs of programs do the job and the operators for folding and such or do you want to get it in a text?
22:57:06 <dons> > 28433 * 2^7830457 + 1 -- dare I?
22:57:10 <lambdabot> Terminated
22:57:24 <dons> bourbaki: yeah, just some little examples
22:57:33 <dons> i don't quite yet have a feel for the structure
22:57:37 <glguy> > (28433 * 2^7830457 + 1) `mod` (10^10)
22:57:39 <dolio> glguy: Eh? That wasn't too bad. Although I was apparently unable to write a fast-exp algorithm that worked in Haskell.
22:57:40 <lambdabot> Terminated
22:57:57 <glguy> dolio: (^) is such a function :)
22:58:17 <bourbaki> dons ok i think i can do that are there any topics you are particularly good at ie neural nets or something like that? then id choose that as an example?
22:58:20 <glguy> that runs in under 1 second on my powerbook
22:58:24 <dolio> glguy: It's easy to reduce using the Euler totient theorem.
22:58:35 <dons> > (1 `shiftL` 7830457)
22:58:35 <lambdabot>  Add a type signature
22:58:39 <dons> > (1 `shiftL` 7830457)  :: Integer
22:58:43 <lambdabot> Terminated
22:59:34 <dons> bourbaki: hmm, I guess I'm more of an implementation guy. So i'd be interested in seeing some little lambda calculus, and writing some concise clever interpreter for that. I'm not sure if that's what you're aiming for though?
23:01:39 <dolio> glguy: You didn't just type it in, did you?
23:01:47 <dons> heh
23:01:51 <bourbaki> dons my main idea of application would be ai stuff cause you can mix things like neural nets and decision trees and normal program code and do FSMs quite natrualy and such i think ill choose a simple program where you cut and glue as an example
23:02:06 <glguy> dolio: yeah... I typed it in, I wasn't going to write something that was that trivial
23:02:28 <chessguy> FSMs = Finite State Machines?
23:02:30 <dons> bourbaki: right. do you need to find an AI guy?
23:02:34 <bourbaki> chessguy yes
23:02:51 <dolio> glguy: And it took less than a second?
23:02:54 <bourbaki> dons no the approach is so general that it will find a lot of application fields i think
23:02:57 <glguy> dolio: yeah
23:03:01 <dolio> Hmm...
23:03:09 <dons> bourbaki: ok.
23:03:22 <bourbaki> also i think that its more interesting to focus on other things for this kind of conf
23:03:28 <glguy> Powerbook G4 (c;  it's a powerhouse
23:03:31 <glguy> j/k
23:04:01 <dibblego> I am playing A grade this season, but I hope she knows that for tonight
23:04:10 <dibblego> oops sorry
23:04:43 <dons> .. and then we buried the body, but man it was hard to cut up
23:04:49 <dons> OH! oops
23:05:14 <bourbaki> hehe
23:05:39 <dibblego> too many things at once and not looking where I was going :)
23:06:15 <glguy> dolio: ok, when I actually time it, it takes right around 2 seconds :)
23:06:28 <glguy> I guess I was underestimating
23:06:51 <dolio> Hmm.
23:07:06 <glguy> why?
23:07:56 <glguy> real    0m1.544s
23:07:56 <glguy> user    0m1.386s
23:07:56 <glguy> sys     0m0.061s
23:08:11 <glguy> main = print ((28433 * 2^7830457 + 1) `mod` (10^10))
23:08:22 <dolio> Just typing in that expression takes way longer than a second for me.
23:08:34 <glguy> what kind of computer?
23:08:45 <dolio> Athlon 64.
23:08:57 <dolio> 3000, I think.
23:09:28 <glguy> on my Athlon 1700+ it takes 2.5 seconds
23:09:33 <glguy> on my G4 powerbook, 1.544
23:10:13 <glguy> and I wouldn't say that my powerbook is known for it's speed..
23:10:27 <Pseudonym> Depends how high you drop it from.
23:10:37 <dolio> Hmm.. I just redid it, and now it takes 2 seconds.
23:10:44 <dolio> I must not have been parenthesizing things correclty.
23:11:10 <dolio> Infix mod must have been screwing me.
23:12:39 <newsham> http://www.thenewsh.com/~newsham/x/until.hs
23:13:17 <dolio> Yeah, that's it. If I don't put parentheses around the a*2^b + 1, it takes a long time.
23:13:41 <glguy> because it was doing the mod first?
23:13:55 <dons> ?type lift unless
23:13:56 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *). (MonadTrans t, Monad m) => t ((->) Bool) (m () -> m ())
23:14:04 <dons> ?type liftM2 unless
23:14:05 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 Bool -> m1 (m ()) -> m1 (m ())
23:14:12 <dons> ?type liftM unless
23:14:13 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 Bool -> m1 (m () -> m ())
23:14:26 <glguy> ?type liftM useless
23:14:27 <lambdabot> Not in scope: `useless'
23:14:43 <glguy> (that's what I thought you typed (: )
23:15:04 <dolio> Does ghc automatically rewrite (mod (a^b) n) into a more efficient algorithm than just exponentiating and modding afterward?
23:15:23 <glguy> I doubt that
23:15:25 <dons> only one way to find out (well, there's severa)
23:15:38 <dolio> How long does it take you to do just a^b on your powerbook?
23:15:45 <dolio> It hasn't stopped here.
23:15:49 <glguy> dolio: takes longer to print it
23:15:53 <glguy> than compute it
23:15:58 <glguy> I'll give it a shot
23:16:01 <dolio> It's not printing anything yet.
23:16:03 <glguy> piped to /dev/null
23:16:46 <glguy> main = print (2^7830457)  (don't forget that the number had something like 200000 digits
23:17:47 <glguy> I bet if we profile that, show takes all the time
23:18:24 <dons> ( (mod (10^20) 30) :: Int)
23:18:24 <dons> case ^ (GHC.Base.I# 10) (GHC.Num.S# 20) of I# x -> case modInt# x 30 of _ ->
23:18:31 <dons> before and after
23:18:38 <Pseudonym> http://www.antiquark.com/sliderule/sim/n3t/virtual-n3-t.html <- This might help.
23:18:38 <dons> but not before code gen, which might yet do some tricks.
23:18:39 <dons> let's see
23:18:41 <lambdabot> Title: Virtual Pickett N3-T Slide Rule, http://tinyurl.com/f9dx2
23:19:04 <glguy> dons: so it does optimize the math for mod n?
23:19:29 <Pseudonym> Actually, this one might be better:
23:19:30 <glguy> or doesn't, what you pasted means little to me :)
23:19:31 <Pseudonym> http://www.antiquark.com/sliderule/sim/n904t/virtual-n904-t.html
23:19:35 <lambdabot> Title: Virtual Pickett N904-T TRIG and DECIMAL KEEPER SPEED RULE Slide Rule, http://tinyurl.com/f5ol6
23:19:46 <Pseudonym> Flip it over and work out the decimal places.
23:19:46 <dons> glguy: it doesn't do anything special to it, no
23:19:55 <glguy> so show is the problem then?
23:20:12 <dons> (mod (10^20) 30) -> case 10^20 of x -> mod x 30
23:20:32 <Pseudonym> Yikes.
23:20:44 <Pseudonym> People don't really compute power-mod that way, do they?
23:20:44 <dolio> > 2^4 `mod` 10
23:20:45 <lambdabot>  6
23:20:55 <dolio> > (2^4) `mod` 10
23:20:56 <lambdabot>  6
23:21:08 <dolio> > 3 * 2^4 `mod` 10
23:21:09 <lambdabot>  8
23:21:15 <dolio> > (3 * 2^4) `mod` 10
23:21:16 <lambdabot>  8
23:21:35 <dolio> > 3 * 2^4 + 1 `mod` 10
23:21:37 <lambdabot>  49
23:21:42 <dolio> Ah, there we go.
23:22:03 <dolio> It was adding (1 `mod` 10^10) to that huge number and trying to print it.
23:22:08 <glguy> > 3 `mod` 10 ^ 2
23:22:09 <lambdabot>  3
23:23:22 <dolio> > mod (2^7830457) (10^10)
23:23:26 <lambdabot> Terminated
23:23:30 <dolio> Ah well.
23:23:48 <glguy> dolio: I went back and removed the extra lines from the cyclic problem: http://mathschallenge.net/index.php?section=project&ref=forum&id=61
23:23:49 <dolio> lambdabot is not running fast enough to solve the problem.
23:23:51 <lambdabot> http://tinyurl.com/jsovy
23:24:01 <glguy> I challenge the people using other languages to match it :)
23:26:06 <glguy> that perl guy make get close if he's not use pregenerated lists
23:26:48 <Pseudonym> @let powmod b e n = if e < 5 then ((b^e) `mod` n) else let { (q,r) = e `divMod` 2; pm2 = powmod b r n } in case r of { 0 -> (pm2*pm2) `mod` n; 1 -> (pm2*pm2*b) `mod` n }
23:26:49 <lambdabot> Defined.
23:27:06 <Pseudonym> > L.powmod 2 7830457 (10^10)
23:27:06 <dolio> Were there any J solutions posted?
23:27:07 <lambdabot>  8
23:27:19 <dolio> Oh yeah.
23:27:27 <Pseudonym> Is that the answer?
23:27:27 <dolio> It's actually longer than yours. :)
23:27:28 <glguy> > L.powmod 2 7830457 (10^10)
23:27:29 <lambdabot>  8
23:27:29 <dons> nice Pseudonym
23:28:16 <glguy> did I use powmod incorrectly there?
23:28:25 <glguy> dons: the prolog solution is pretty terse
23:28:29 <glguy> errr
23:28:31 <glguy> dolio: ^
23:28:53 <Pseudonym> Sorry that's so badly written, BTW.  it's nicer if you have better layout than @let provides.
23:29:04 <glguy> it helps that I generate all the series from a single list of pairs
23:30:12 <dolio> Yeah. That's quite something.
23:30:34 <Pseudonym> For the next exercise, implement PKCS#1 in Haskell.
23:30:43 <Pseudonym> And then X.500.
23:31:54 <glguy> > fix ( (1:) . zipWith (+) [2..])
23:31:55 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
23:32:00 <newsham> bonus points if you dont make the same mistake openssl made
23:33:23 <newsham> http://www.matasano.com/log/469/many-rsa-signatures-may-be-forgeable-in-openssl-and-elsewhere/
23:33:26 <lambdabot> Title: Matasano Chargen Â» Many RSA Signatures May Be Forgeable In OpenSSL and Elsewher ..., http://tinyurl.com/p8bfw
23:33:29 <dolio> > fix ((1:) zipWith (+) [2,5..]
23:33:29 <lambdabot>  Parse error
23:33:35 <dolio> > fix ((1:) zipWith (+) [2,5..])
23:33:36 <lambdabot>    The function `(1 :)' is applied to three arguments,
23:33:36 <lambdabot>   but its type `[a...
23:33:43 <dolio> > fix ((1:) . zipWith (+) [2,5..])
23:33:45 <lambdabot>  [1,3,8,16,27,41,58,78,101,127,156,188,223,261,302,346,393,443,496,552,611,67...
23:33:47 <dolio> Gah.
23:33:47 <glguy> ?pl \x -> fix ( (1:) . zipWith (+) [3,5..])
23:33:47 <lambdabot> const (fix ((1 :) . zipWith (+) [3,5..]))
23:33:54 <glguy> > fix ( (1:) . zipWith (+) [3,5..])
23:33:55 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
23:34:34 <dolio> > fix ((1:) . zipWith (+) [4,7..])
23:34:35 <lambdabot>  [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,7...
23:35:07 <glguy> once I figured that out, I knew that I needed to update my posting
23:35:13 <dolio> :)
23:37:04 <dolio> I must say, it would never occur to me to write a solution to one of these in assembly language.
23:37:15 <newsham> now make it generate the sequence where the difference between items is from the values not in the sequence
23:37:30 <newsham> ie 1,3,7,12,18,...
23:40:41 <dolio> I also find it amusing when people discuss how you can make the exponentiation faster by testing individual bits in the exponent, when they missed that you can make the exponent several orders of magnitude smaller by applying some number theory.
23:42:00 <GeoffSK> i have a newbie question about application design - triggered (for me) by getStdRandom vs [big-list-of-random-numbers] - any one got a few moments?
23:42:59 <glguy> > let f 0 = [1]; f n = f (n-1) ++ [last (f (n-1)) + head ([1..] \\ (f (n-1)))] in f 4
23:43:00 <lambdabot>  [1,3,5,7,9]
23:43:02 <glguy> first attempt
23:43:23 <newsham> dolio: how do you make the exponent smaller?  modulo phi(N) or something?
23:43:31 <newsham> <- not up on his number theory
23:43:42 <dolio> Yeah.
23:43:51 <dolio> It was 2^n mod 10^10
23:44:08 <dolio> The 2^10 part is 0 (n > 10).
23:44:11 <newsham> what is phi(10^10) ?
23:44:23 <dolio> So you only need to compute 2^n mod 5^10.
23:44:48 <dolio> And since 5^10 and 2 are relatively prime, you only need to compute 2^(n mod phi(5^10))
23:45:18 <dolio> And phi(5^10) = 7812500
23:46:05 <dolio> So instead of 2^7830457, you need 2^17957.
23:46:08 <dolio> Quite a savings.
23:46:46 <newsham> is this something you can apply generally and often save, or does it just work out well in this case?
23:47:39 <dolio> Well, it depends on the bases being relatively prime.
23:48:02 <newsham> and phi(N) being much smaller than the exp?
23:48:53 <glguy> > let f n ds = n : f (n + head (ds \\ [n])) (tail $ ds \\ [n]) in take 10 $ f 1 [2..]
23:48:54 <lambdabot>  [1,3,7,12,18,26,35,45,56,69]
23:49:01 <glguy> newsham: hows that
23:49:09 <dolio> Well, phi(n) isn't much smaller in this case, but it happens to cut it by a factor of 400.
23:49:32 <newsham> glguy: nice :)
23:49:54 <glguy> > let f n ds = let ds' = n `delete` ds in  n : f (n + head ds') (tail ds') in take 10 $ f 1 [2..]
23:49:55 <lambdabot>  [1,3,7,12,18,26,35,45,56,69]
23:50:00 <dolio> Which is the difference between 2 seconds and 0.004 seconds.
23:50:10 <newsham> dolio: factor of 400 is just 9 bits.
23:50:35 <newsham> is it worth it to save 9 modulos ?
23:51:03 <dolio> Yeah, but the number you're multiplying doubles in digits with each bit.
23:51:33 <dolio> Although you can use modulo arithmetic in the exponentiation algorithm to soften that.
23:51:45 <newsham> i thought it stays the same since you're reducing it modulo N after each step?
23:52:17 <glguy> > let f n ds = let (d:ds') = n `delete` ds in  n : f (n + d) ds' in take 10 $ f 1 [1..] -- I don't see anything else to delete
23:52:19 <lambdabot>  [1,3,7,12,18,26,35,45,56,69]
23:52:31 <dolio> Anyhow, it's maily useful when your numbers are bigger, I guess.
23:53:36 <newsham> i'm just wondering how much extra work it makes and how much its saving, given that the russian's peasant thing only does one set of operations per bit in the exponent.
23:53:50 <dolio> glguy: Now turn that into fixpoint notation. :)
23:53:57 <newsham> (and only if the bit is set, so some exponents are really simple)
23:55:24 <glguy> > take 10 $ fix (\f n ds -> let (d:ds') = n `delete` ds in  n : f (n + d) ds') 1 [1..]
23:55:25 <lambdabot>  [1,3,7,12,18,26,35,45,56,69]
23:55:36 <glguy> dolio: cheating?
23:55:45 <dolio> Heh. perhaps.
23:56:26 <newsham> is there a function that runs a command (like System.Cmd.system) but returns the stdout output stream?  (like popen)
23:58:32 <dolio> Something in System.Process, maybe?
23:58:41 <newsham> yah, looking, might be..
23:58:47 <dolio> runProcess?
23:59:21 <dolio> or runInteractiveProcess, perhaps.
