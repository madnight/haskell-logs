00:00:32 <jknecht_1729> Does anybody now any open-source haskell projects that are haskell-newb-friendly and looking for volunteers?
00:00:42 <jknecht_1729> ^now^know^
00:01:17 <kowey> darcs has a collection of ProbablyEasy bugs which might be good for haskell newbies
00:01:46 <kowey> http://bugs.darcs.net/issue?@columns=title,id,activity,status&@sort=-activity&@group=priority&@filter=topic,status,assignedto&@pagesize=50&@startwith=0&topic=6&status=-1,1,2,3,4,5,6,7&assignedto=-1
00:01:50 <araujo> hi hi
00:01:56 <lambdabot> Title: List of issues - Darcs issue tracker, http://tinyurl.com/f2p89
00:02:05 <jknecht_1729> i'll look into that; just started using darcs for my haskell stuff and am really liking it..
00:02:31 <araujo> There is some way to specify a path to look for files using cabal?
00:09:48 <Lemmih> araujo: Look for what files?
00:09:49 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
00:10:41 <araujo> Lemmih, oh well ... i think i found the problem ... one of the src-extralibs for the ghc snapshot is using an incorrect path for C-Sources.
00:11:03 <gour> anyone played with hdbc (sqlite driver) ?
00:12:55 <lispy> gour: no only the ODBC driver to connect to MS access
00:13:00 <lispy> gour: seems to fill my needs though
00:13:50 <gour> lispy: ahh...ok. i'm wondering whether sqlite driver enables user-defined functions
00:14:19 <lispy> i'd check the sqlite driver source
00:14:24 <lispy> it's probably pretty reabale
00:14:32 <lispy> i found the ODBC source to be not bad
00:15:42 <lambdabot> Consider it ignored.
00:18:50 <gour> lispy: i'm not (yet) fluent in reading (haskell)
00:24:36 * lispy has probably never been fluent in any language
00:24:41 <lispy> i just read them enough to get buy
00:24:43 <lispy> er by
00:24:48 * edwardk waves ello.
00:24:56 <lispy> edwardk: hi
00:25:03 * lispy >>= bed
00:25:14 * edwardk =<<<< bed
00:25:16 <Pseudonym> Night.
00:25:23 <edwardk> night lispy =)
00:25:28 <lispy> night :)
00:25:36 <gour> lispy: i'll try. don'ta laugh at my pronunciation and/or stammering
00:25:55 <gour> lispy: d'night
00:33:03 <vincenz> hey peep
00:33:04 <vincenz> s
00:36:23 <vincenz> wikipedia is so intellectual
00:36:28 <vincenz> on the page of tzaziki
00:36:29 <vincenz> " For a more garlicky taste, add more garlic."
00:38:10 <Cale> haha
00:38:54 <Cale> It's like "This is good, but I wish the taste was more garlicky. I wonder what to do? I know, wikipedia!"
00:39:12 <vincenz> :D
00:39:45 <vincenz> "For a saltier flavour, add salt"
00:40:03 <Pseudonym> This reminds me of Terry Pratchett's description of popcorn.
00:40:10 <Pseudonym> "If you add salt and butter, it tastes like salty butter."
00:40:35 <vincenz> "warning, burns when hot"
00:40:37 * vincenz snickers
00:43:40 <vincenz> hey Itkovian!
00:43:55 <vincenz> soon our profiling library will be multithreaded-robust :)
00:45:45 <Itkovian> cool
00:50:34 <vincenz> someone needs to slap me, I'm getting into scheme
00:50:49 <dons> ?slap vincenz
00:50:50 * lambdabot slaps vincenz
00:51:04 <dons> better now?
00:51:08 <vincenz> still not enough :/
00:51:15 <dons> ?slap vincenz again
00:51:15 <lambdabot> why on earth would I slap vincenz again
00:51:15 <vincenz> I feel like writing a scheme compiler in scheme
00:51:19 <Korollary> He was asking a question, vincenz.
00:51:29 <vincenz> oh no that's not the point
00:51:34 <vincenz> the point is that I feel like writing
00:51:40 <vincenz> scheme-scheme->bytecode
00:51:50 <vincenz> and bytecode-c->assembly (aka interpreter in c)
00:51:52 <Korollary> why?
00:51:59 <vincenz> cause I'm sick?
00:52:01 <Korollary> Yes
00:52:08 <Korollary> I mean, there is SISC already
00:52:19 <Adamant> write a Scheme to native-code compiler
00:52:22 <vincenz> seen mosquito lisp?
00:52:22 <Korollary> I suppose you can have an IronScheme
00:52:37 <vincenz> that's the direction I'd like to experiment in :)
00:53:08 <vincenz> Adamant: that's called a VM with a jit
00:53:27 <Adamant> screw VM's
00:53:37 <Adamant> I mean a REAL native code compiler. :)
00:53:37 <vincenz> tbh, with dyn-typed languages, since you're already losing on dynamic typng overhead
00:53:46 <vincenz> going to native code makes -no- sense
00:53:51 <vincenz> you lose portability
00:54:14 <Adamant> tbh?
00:54:19 <vincenz> to be honest
00:54:32 <Korollary> There's Stalin.
00:54:48 <Korollary> Bigloo compiles to native, too, yes?
00:54:54 <vincenz> I think so yes
00:54:59 <vincenz> I'm new to the scheme community
00:55:20 <Adamant> I'm reading Lisp in Small Piece
00:55:22 <Adamant> s
00:55:29 <vincenz> it's lisp?
00:55:40 <Adamant> compiling to native code sounds like a challenge.
00:55:48 <edwardk> good idea, its hard to read lisp in large pieces... all the ()'s get in the way.
00:55:48 <Adamant> Scheme and Common Lisp are covered
00:55:58 <edwardk> adamant: look at the chicken scheme compiler and some others.
00:55:58 <velco> vincenz: I like Gambit Scheme the most
00:56:02 <vincenz> edwardk--
00:56:15 <vincenz> velco: why's that?
00:56:20 <vincenz> anyways
00:56:28 <vincenz> scheme is a simple enough language to make a compiler for in 1,2,3
00:56:31 <Adamant> vincenz, wouldn't that be (- edwardk 1)?
00:56:40 <Korollary> not in #haskell
00:56:56 <Adamant> haskell has --?
00:57:01 <vincenz> Adamant: no that would be lambdabot not reacting
00:57:03 <dons> subtract edwardk
00:57:06 <edwardk> vincenz is an engineer, we can forgive him his C leanings.
00:57:15 <vincenz> heh
00:57:20 <edwardk> dons: Yes I am quite negative, thank you ;)
00:57:22 <vincenz> first language engineers got in college was scheme
00:57:25 <vincenz> they now switched that to java
00:57:26 <dons> edwardk: :)
00:57:32 <Korollary> wth
00:57:38 <vincenz> I actually never learned C officially
00:57:49 <Korollary> they teach c/c++ to engineers in most places
00:57:53 <Adamant> I never actually learned Scheme officially
00:57:55 <vincenz> not here
00:58:01 <vincenz> it's java all the way now (puke)
00:58:16 <edwardk> I didn't get really good at C until I started writing a mud. sad as it is to reflect upon.
00:58:18 <Adamant> I hope they aren't teaching EE/CE's Java
00:58:23 <Adamant> that's awful.
00:58:24 <Korollary> well, EE's interact with hardware so C makes more sense than java or scheme.
00:58:27 <edwardk> adamant: they do
00:58:36 <Adamant> now that is just not right.
00:58:54 <vincenz> Korollary: sure, we see it in lab practices, but it's kinda assumed you know it then, we had to for instance optimize an mp3 player... but they never taught us C
00:59:09 <edwardk> Adamant: typically by the end of the program you'll pick up c/c++ just in time to give in VLSI type things and forget it
00:59:22 <edwardk> er just in time to dive into
00:59:40 <vincenz> you mean systemC?
00:59:54 <Korollary> the EE's I worked with wrote C regularly. Most of them didn't know what scheme was. They knew java was a language.
00:59:55 <edwardk> As a rule, I won't hire anyone straight out of college any more. They don't learn how to program.
01:00:08 <Adamant> I thought y'all used VHDL and Verilog
01:00:31 <velco> hw engineers here use VHDL
01:00:36 <edwardk> yeah
01:00:40 <Korollary> EE's that design digital circuits do. Others don't.
01:00:43 <vincenz> systemC is the new thing
01:00:58 <vincenz> especially for designing for instance a whole processor for cycle-accurate simulation
01:01:12 <edwardk> I hide far far away from circuit design these days. I can find few things less interesting. ;)
01:01:17 <velco> hmm, there was some lips or scheme based thing ...
01:01:21 <velco> ^lisp
01:01:32 <Korollary> edwardk: I actually have a degree in EE. It wasn't what I wanted.
01:01:44 <edwardk> kor: thats what most people who do it say.
01:02:25 <Korollary> edwardk: No, most people work as EE's. It's not that common to turn into a sw engineer.
01:02:32 <Adamant> do people like CE's?
01:02:41 <Adamant> CE degrees.
01:02:46 <Korollary> I have a MS in CE
01:02:47 <velco> what is CE ?
01:02:55 <Adamant> Computer Engineering
01:02:59 <Adamant> EE for computers.
01:03:15 <edwardk> kor: must have a skewed perspective. Half of the 'computer science' folks I've worked with have been EE or CE.
01:03:43 <edwardk> kor: er I must have..
01:03:53 <Adamant> I'm coming at it the other way, a CS type getting interested in electronics
01:04:02 <edwardk> Adamant: weirdo ;)
01:04:09 <Korollary> edwardk: It depends on where you are I guess. I don't know a lot of people with EE degrees that became sw devs. If you have a CE degree or focus, it's quite likely tho
01:04:51 <edwardk> then again I'm near university of michigan, so the area is saturated with EE/CE folks.
01:06:56 <edwardk> cale: oh, you were right, i don't seem to have been able to maintain principal typings. I want to figure out how to play with the polarization of the type system to get them back though.
01:11:00 <vincenz> quick golf question
01:11:04 <vincenz> clean way to print out a map
01:11:08 <vincenz> Map String Int
01:11:33 <edwardk> ?
01:12:42 <dons> print?
01:13:26 <dons> > show (M.singleton "foo" 8 :: M.Map String Int)
01:13:28 <lambdabot>  "{\"foo\":=8}"
01:13:39 <dons> > M.singleton "foo" 8 :: M.Map String Int)
01:13:40 <lambdabot>  Parse error
01:13:46 <dons> > M.singleton "foo" 8 :: M.Map String Int
01:13:47 <lambdabot>  {"foo":=8}
01:13:59 <vincenz> I guess that will do for now
01:14:11 <vincenz> @hoogle Map
01:14:11 <lambdabot> Data.Map :: module
01:14:12 <lambdabot> Data.Map.Map :: data Map k a
01:14:12 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:19:54 <jrmole> dons, how do i list lambdabot's qualified imports like that?
01:42:49 <dons> jrmole: you mean, how do you find out what other qualified imports lambdabot uses?
01:47:36 <jrmole> yeah
01:49:07 <dons> there's only two. Set as S, and Map as M
01:49:12 <jrmole> ah
02:01:22 <int-e> IntSet as I
02:01:27 <int-e> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs :)
02:21:20 <vincenz> @hoogle a -> (a -> a) -> [a]
02:21:21 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
02:21:21 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
02:21:21 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
02:22:21 <deadbeef> hme0: HAPPY MEAL 8:0:20:8E:5C:FF
02:22:26 <deadbeef> what a name
02:29:36 * dblhelix is ready to go and give gtk2hs a try
02:30:23 <dcoutts__> dblhelix: good! :-)
02:38:28 <integral> (,) can't be sectioned like (,nil)?
02:39:18 <flux__> > (,42)
02:39:18 <lambdabot>  Parse error
02:39:41 <flux__> hm, actually, what should it do?
02:40:03 <integral> (,42) ==== (\x -> (x,42)), like (+42) ==== (\x -> (x+42))
02:40:21 <dblhelix> flip (,) 42
02:40:30 <dblhelix> @type flip (,) 42
02:40:31 <lambdabot> forall a b. (Num b) => a -> (a, b)
02:40:35 <flux__> uh, of course
02:41:05 <dblhelix> @pl (\x -> (x, 42))
02:41:06 <lambdabot> flip (,) 42
02:48:57 <Bobstopper> Hey, does anyone know of any interfaces to the berkeley database for Haskell?
02:50:03 <dons> did you look at the databases page of haskell.org's "libraries and tools" link?
02:51:44 <dons> ?wiki Libraries_and_tools/Database_interfaces
02:51:44 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
02:53:06 <Bobstopper> I did... but I didn't see anything that mentioned BDB
02:54:22 <norpan> http://gopher.quux.org:70/devel/missingpy/html/MissingPy.AnyDBM.html#v%3AopenSpecificDBM
02:54:36 <norpan> http://gopher.quux.org:70/devel/missingpy/
02:54:37 <lambdabot> Title: Gopher: missingpy
02:55:03 <kzm> About BS.Lazy, I presume a concat will preserve the exact BS's?  So the number of blocks will get large?  (from unlines, say)
02:55:27 <kzm> And indexing has a cost linear in the number of blocks?
02:55:43 <dons> yep
02:55:57 <dons> with 32k chunks by default
02:56:28 <kzm> ...but I do (roughly)  unlines . myProcess . lines
02:56:35 <kzm> Perhaps I should reconsider that...
02:56:52 <Bobstopper> MissingPy's not really what I'm after... I'm hoping to deploy with just haskell libraries, not having to deploy python stuff too..
02:56:59 <SamB> kzm: what do you do after that?
02:57:30 <kzm> iterate over the strings, creating hashes from (overlapping) k-words
02:57:57 <SamB> I mean, what do you do with the result of that whole function?
02:58:05 <SamB> (you know, after unlines?)
02:58:38 <kzm> Umm... generate Int/eger hashes, and throw the rest away.
02:59:23 <kzm> So I could possible modify my hashing code to work on the 'raw' input, but i'd rather not clutter it with data-format stuff.
02:59:32 <SamB> that does indexing?
03:01:03 <kzm> (Not sure I understand what you ask for.)
03:01:37 <SamB> you seem to be concerned that indexing after unlines will be inefficient?
03:02:20 <kzm> The process is roughly: read input data as BS.Lazy, parse as Sequence objects (consisting of BSes mainly), create hashes from a Sequence BS.
03:02:57 <kzm> Creating the hashes involve a lot of indexing into the BS.  The BS used to be the strict kind, which incurs a lot of GC overhead.
03:03:14 <kzm> I tried the Lazy, but now it incurs a lot of indexing overhead (I think).
03:03:25 <SamB> why does that involve indexing?
03:03:28 <kzm> The GC overhead is reasonable, at least with GHC 6.4.1.
03:04:03 <kzm> SamB... because, because... I haven't looked carefully at other ways to approach it?
03:04:15 <dcoutts__> ForeignPtr representation uses another indirection in ghc-6.4.x
03:04:24 <kzm> I should probably write it as a fold or something, right?
03:04:26 <musasabi> fps is much faster with 6.5
03:04:49 <SamB> kzm: something like that
03:04:50 <kzm> musasabi, not in my case - GC time is >50% with 6.5, but ~20% with 6.4.1
03:04:52 <dcoutts__> kzm, a fold will probably be faster than a recursion with indexing
03:05:04 <SamB> you should at least use head and tail or take and drop...
03:05:04 <dcoutts__> kzm, especially on 6.4.x
03:05:31 <int-e> kzm: have you played with the heap size?
03:05:46 <kzm> Right.  It's complicated a bit by having to skip over parts etc, but it should be very doable, I think.
03:05:56 <SamB> kzm: skip over parts?
03:06:08 <dcoutts__> kzm, and of course indexing for .Lazy can be slower, due to the list of chunks
03:06:11 <kzm> int-e, the funny thing is that with a larger heap (which usually helps), things are actually slower with 6.5
03:06:21 <SamB> why does the string have those parts?
03:06:24 <int-e> interesting
03:06:29 <kzm> dcoutts__, right.  It didn't hurt (much?) before I switched to lazy.
03:07:02 <kzm> SamB, just that there's no valid hash for some characters in the string, and thus I skip the words containing such chars.
03:07:18 <kzm> I could generate Maybe Hash, and filter out the Nothings.
03:07:44 <SamB> kzm: so why do you have one big string instead of a bunch of little ones, again?
03:08:09 <kzm> int-e, the GC behavior is very confusing, but I'm fairly sure it's correct, and submitted a report to Simon M.
03:08:47 <kzm> If anybody else would like to take a look, the URL is http://www.ii.uib.no/~ketil/toSM.tgz
03:09:56 <int-e> you could convert the lazy bytestring lines into strict bytestrings (at least with a very recent fps). in the common case (one chunk in the lazy bytestring for that line) that is cheap.
03:10:10 <kzm> SamB, I do have a bunch of little ones.  But each of the little ones consist of several lines, which (with BS.Lazy) are shared from the original input, and not copied.
03:10:16 <int-e> (if using Strict.concat . Lazy.toChunks)
03:10:49 <int-e> and indexing into strict bytestrings avoids all the nasty checks for ends of lists.
03:11:05 <dcoutts__> int-e: is your issue that you're retaing too much ?
03:11:14 <int-e> dcoutts__: No.
03:11:20 <dcoutts__> ok
03:11:24 <int-e> dcoutts__: it's not my problem anyway.
03:12:15 <kzm> I think rewriting the iteration as a fold may reduce the indexing cost.  I'll try that first.
03:12:45 <int-e> dcoutts__: I'm just thinking about the case where I want to process many lines individually and index into them a lot. and process . map (S.concat . L.toChunks) . L.lines  seems like a good idea then.
03:13:57 <dcoutts__> int-e: in that case you might be better off with strict from the beginning
03:14:06 <dcoutts__> how big is the thing you're processing
03:14:32 <int-e> dcoutts__: imagine it's a huge stream of data. it's all hypothetical. kzm has the real problem. :)
03:15:10 <kzm> int-e, I used to do it much like that, but it causes a lot of garbage.
03:15:40 <kzm> And GC appears to be a weak spot at the moment - at least for BSes (ForeignPtr?)
03:16:18 <dcoutts__> map (S.concat . L.toChunks) . L.lines  isn't a terrible idea actually
03:16:41 <dcoutts__> most of the chunks will be length 1
03:16:52 <dcoutts__> and S.concat is optimised for that case
03:16:52 <int-e> dcoutts__: right, that's what I was thinking
03:17:13 <dcoutts__> you'll only get 2 in the case of a line crossing a 32k boundary
03:17:22 <dcoutts__> which will be comparitively rare
03:19:33 <int-e> unless your lines are very long, obviously.
03:20:03 * SamB thinks maybe there should be toStrict/fromStrict functions
03:20:20 <sieni> int-e: this long? http://en.wikipedia.org/wiki/Long_line_%28topology%29
03:20:23 <int-e> that got voted down yesterday ;)
03:20:37 <SamB> what?
03:20:50 <dcoutts__> SamB: their trivially implementable outside fps
03:20:54 <SamB> well yes
03:20:59 <SamB> so?
03:21:21 <dcoutts__> and I don't see that we should be encouraging it that much
03:21:30 <SamB> point...
03:21:57 <dcoutts__> toStrict = S.concat . L.toChunks
03:22:02 <SamB> yes I know
03:22:10 <int-e> which makes it clear that potentially a lot of work is done.
03:22:29 <dcoutts__> fromStrict p = L.fromChunks [p]
03:22:52 <dcoutts__> SamB: I know you know :-) I'm just thinking out loud
03:23:03 <dcoutts__> int-e: good point
03:23:28 <int-e> that was my reason for agreeing with not including it. I'd have argued for including it otherwise ;)
03:24:14 <SamB> maybe should at least include them in the haddock documentation somewhere?
03:25:08 <dcoutts__> int-e: heh :-)
03:25:47 <dcoutts__> SamB: submit a patch if you like. where do you think they should go? attached to to/fromChunks docs perhaps.
03:25:58 <SamB> yes
03:27:37 <kzm> Hmm... I guess the reason for not using a fold (for my word hashes) in the first place, is that they operate on a compound object, which doesn't have the characteristics of a sequence (ie. no head or tail).
03:28:31 <kzm> So a fold needs access to internals of the data type, which aren't exposed... oh well.
03:28:48 <SamB> ???
03:29:22 <int-e> the idea was to use ByteString's fold. (which I think gets inlined in the end)
03:29:41 <int-e> at least as I understood it.
03:29:58 <kzm> But my 'hashes' function doesn't know anything about BS, the BS is contained within another data type.
03:30:09 <kzm> Not really a problem, I just need to expose more internals.
03:30:15 <int-e> ah. your internals.
03:32:22 <kzm> Yes.  All my private parts, in plain view of any inquisitive function.
03:32:30 <dcoutts__> !!
03:32:58 <kzm> And please no comments on the line of 'I've looked at your code, and I can clearly see you're nuts'
03:33:19 * kzm apologizes for his poor puns, and goes off to write some code. 
03:45:09 <xerox> ?yow!
03:45:09 <lambdabot> I think I'm having a mid-week crisis.
03:45:19 <xerox> But it's week-end.
03:45:32 <dcoutts__> yay
03:51:58 * sieni is seriously thinking about writing a simple home accounting plugin for yi with hdbc/pgsql as backend.
04:02:43 <deadbeef> is there any way to embed asm code into an haskell program ?
04:03:04 <int-e> using FFI, yes.
04:03:08 <deadbeef> what's ffi ?
04:03:31 <int-e> well, 'embed'. you can link to it. FFI = foreign function interface.
04:03:42 <int-e> there's no inline assembler.
04:04:06 <deadbeef> got it, thanks
04:04:46 <int-e> Which boils down to the same thing as linking to C. You follow the C calling convention and it works.
04:45:57 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..]
04:45:59 <lambdabot>  Exception: stack overflow
04:46:43 <mauke> > length [1..]
04:46:47 <lambdabot> Terminated
04:46:55 <mauke> OPTIMIZED
04:47:11 <profmakx> -.-
04:47:15 <Thomas2_> boo yeah
04:47:48 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..99999999]
04:47:50 <lambdabot>  Exception: stack overflow
04:47:53 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..9999]
04:47:54 <lambdabot>  9999
04:48:03 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..999999]
04:48:03 <mauke> > length [1..99999999]
04:48:05 <lambdabot>  Exception: stack overflow
04:48:08 <lambdabot> Terminated
04:48:10 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..99999]
04:48:12 <lambdabot>  99999
04:48:20 <mauke> poor lambdabot
04:48:21 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..599999]
04:48:23 <lambdabot>  Exception: stack overflow
04:48:26 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..399999]
04:48:28 <lambdabot>  399999
04:48:31 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..499999]
04:48:32 <profmakx> o.O
04:48:33 <lambdabot>  499999
04:48:33 <Thomas2_> yeah, everyone really seems to hate it
04:48:39 <profmakx> build your own
04:48:39 <profmakx> -.-
04:48:44 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..559999]
04:48:46 <lambdabot>  Exception: stack overflow
04:48:53 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..539999]
04:48:55 <lambdabot>  Exception: stack overflow
04:48:58 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..519999]
04:49:00 <lambdabot>  519999
04:49:03 <deadbeef> > let f [] = 0; f (_:xs) = 1 + f xs in f [1..529999]
04:49:05 <lambdabot>  Exception: stack overflow
04:49:10 <profmakx> well, exercise for the reader: write a programm that does the bisection automatically -.
04:49:46 <deadbeef> > length [1..529999]
04:49:47 <lambdabot>  529999
04:49:50 <deadbeef> omg it works
04:50:09 <vincenz> FPLCA is a known conference
04:50:09 <vincenz> ?
05:12:17 <tibbe> ?type concat
05:12:18 <lambdabot> forall a. [[a]] -> [a]
05:12:29 <tibbe> @type concat
05:12:30 <lambdabot> forall a. [[a]] -> [a]
05:12:57 <tibbe> @type (++)
05:12:59 <lambdabot> forall a. [a] -> [a] -> [a]
05:16:39 <vincenz> @type foldr (++) []
05:16:41 <lambdabot> forall a. [[a]] -> [a]
05:24:41 <Limbic_Region> Igloo ping
05:26:33 <shapr> Good morning #haskell!
05:26:49 <profmakx> hmm
05:26:53 <profmakx> its 3 pm here
05:26:56 <profmakx> so
05:27:00 <profmakx> erm
05:27:06 <profmakx> 2:26
05:27:13 <profmakx> but anyway, good morning shapr
05:28:01 <Limbic_Region> well, it is a good but tiring morning for me
05:28:04 <Igloo> Limbic_Region: pong
05:28:19 <shapr> profmakx: It's 8am here.
05:28:19 <Limbic_Region> Igloo - I finally got GHC compiling on Win32
05:28:28 <Igloo> Cool
05:28:41 <Limbic_Region> in fact, I decided to use darcs to checkout daily
05:28:53 <Limbic_Region> as to avoid the very long build process (circa 2 hours once I figured out everything I needed to do)
05:29:07 <Limbic_Region> Igloo - had 2 issues that may or may not need to be addressed
05:29:33 <Limbic_Region> The first is that the build died after about an hour because there was no gmp library on my system
05:29:34 <profmakx> shapr, i was just being an ass about time zones ;)
05:29:45 <profmakx> GMT for #haskell now!
05:29:46 <Limbic_Region> I would think that should be in a dependency scan during configure
05:30:03 <Igloo> It should use an in-tree gmp if you don't have one
05:30:09 <Limbic_Region> The second is that configure didn't correctly identify my GccDir
05:30:18 <Limbic_Region> err wait, let me finish that thought in a second
05:30:25 <Limbic_Region> It did not Igloo - it just plain died
05:30:34 <Limbic_Region> worked fine after I installed my own
05:30:55 <Limbic_Region> The second is that configure didn't correctly identify my GccDir so the copying over of gcc-lib and friends at the install failed
05:31:02 <Limbic_Region> I was easily able to do this by hand though
05:31:46 <Limbic_Region> other than that - great experience
05:32:18 <Limbic_Region> unfortunately, my wife occassionally needs a break from taking care of our daughter (7 months) and last night was it - not a whole lot of sleep
05:33:10 <Igloo> Limbic_Region: Can you show me a log of it dieing?
05:33:59 <Igloo> And of the GccDir thing for that matter
05:34:08 <Limbic_Region> I don't know - does the build process automatically create a log
05:34:23 <Limbic_Region> and if so, does it append, create a new one, or overwrite on subsequent builds?
05:34:54 * Limbic_Region really doesn't relish the thought of starting over 
05:44:56 <Igloo> It doesn't create one
05:47:11 <Limbic_Region> Igloo - ok, what I can do sometime this weekend is to copy off my local checkout and temporarily remove the gmp libraries
05:47:17 <Limbic_Region> I will run the make with a tee option
05:47:27 <frederik> hi everyone. Does anybody use eclipsefp with haskell?
05:47:56 <frederik> it doesn't compile or run ghci or hugs for me
05:52:26 <Igloo> OK, thanks
05:54:37 <fasta> frederik: I installed it, but I consider it to be a waste of time.
05:55:07 * gour would prefer having hIDE instead
05:55:14 <fasta> frederik: I did manage to get it somewhat working (more than you currently have working)
05:56:00 <fasta> Emacs X11 with Monospace would be just fine for me too. Every language having its own editor is not sensible, I think.
05:56:22 <frederik> hm, what a pitty, it might be a nice enviroment for developing haskell ... a memory hungry one ....
05:56:39 <frederik> yes, I'm using emacs
05:56:57 <fasta> frederik: who cares about memory? Memory is cheap
05:57:03 <frederik> fasta: I'd like to have something with better code browsing capabilites
05:57:43 <frederik> gour: is there any hIDE development going on?
05:57:52 <fasta> frederik: 1) That's possible with Emacs with some small customizations 2) Languages that depend on such thing are mostly broken.
05:57:54 <frederik> gour: the last blog entry is several months old
05:58:23 <frederik> fasta: hehe, tell me more about 1) *g
05:58:25 <gour> frederik: afaik - no, maybe Lemmih can say more, although dcoutts told me he plan to resume development
05:58:38 <frederik> fasta: (I don't fully agree with 2) btw)
05:59:51 <fasta> frederik: Someone is working on a commercial Haskell editor, IIRC.
05:59:51 <gour> in any case, it would be wonderful to have native haskell IDE
06:00:04 <gour> fasta: really?
06:00:07 <dons> fasta: ?
06:00:22 <wilx|wrk> HIDE? :)
06:00:24 <dons> I remember getting some emails from a guy who wanted to do something like that with the yi code base. hmm.
06:00:36 <wilx|wrk> I think there is existing project of Haskell IDE in Haskell.
06:00:44 <fasta> Or this person is working on a commercial editor which does a number of languages including Haskell.
06:00:49 <shapr> dons: Tell us more!
06:00:56 <fasta> But I got the impression it was targeted at Haskell.
06:00:56 <frederik> fasta: it would have be to be quiite a lot better than emacs to make me switch to properitary software
06:01:00 <gour> @where hIDE
06:01:01 <lambdabot> http://haskell.org/haskellwiki/HIDE
06:01:19 <gour> wilx|wrk: ^^^
06:01:21 <dons> shapr: oh, it was just one mail a long time ago, maybe a year or more. he wanted to know about the license, and if it was could be used in commerical stuff
06:01:26 <dons> since he had some app to write.
06:01:30 <fasta> frederik: so you give up your ideals for features. Don't let them hear that in #fsf ;)
06:01:32 <frederik> fasta: what license is yi release under?
06:01:33 <dons> didn't hear any more.
06:01:45 <fasta> frederik: don't know
06:02:01 <frederik> fasta: :) I might, do that, the last time I tried that ... well, it didn't last long
06:02:02 <shapr> Hey, when is Haskell Workshop again?
06:02:04 <shapr> And who's going?
06:02:05 <dons> $ cd dons/src/yi
06:02:05 <dons> $ head -1 LICENSE
06:02:05 <dons>                     GNU GENERAL PUBLIC LICENSE
06:02:21 <frederik> fasta: (tried to use OS X on my ibook, went back to GNU Linux quite fast)
06:02:31 <dons> frederik: heh
06:02:55 <dons> fasta, do you have any url for this commerical editor?
06:03:02 <dons> how'd you hear about it?
06:03:52 <fasta> dons: debugging with trace works nicely, btw, but I am not sure whether the order of the need for a value is kept in trace output. I thought it was, but what I am seeing suggests otherwise.
06:03:59 <fasta> dons: I will see whether I can find it.
06:04:41 <Igloo> shapr: 17 Sep
06:04:42 <frederik> fasta: oh, could you get back to point 1) from above btw :*)
06:05:01 <Igloo> shapr: And I think at least ChilliX, JaffaCake, kosmikus and me from this channel
06:05:03 <frederik> fasta: what do you use for browsing projects in emacs with haskell
06:05:05 <frederik> ?
06:05:08 <Igloo> shapr: And SyntaxNinja
06:06:02 <fasta> frederik: reading the Emacs Lisp manual helps a lot
06:06:05 <dons> Igloo: do you have a paper to present, or are you appearing wearing your ghc hat?
06:06:24 <frederik> fasta: haskell mode does show declarations and imports, but I'd be quite happy if I could jump to the declarations in those imports quickly for example
06:06:41 <fasta> frederik: You need to make a TAGS file then.
06:07:14 <fasta> frederik: put something like visit-tags-table <the tags file> in your .emacs in case you only have one project you are working on.
06:08:08 * gour would like some IDE-environment with shorter learning curve than emacs 
06:08:15 <frederik> fasta: was there any way for auto-updating tags
06:08:16 <Igloo> dons: GHC hat
06:08:21 <dons> cool
06:09:02 <fasta> gour: It's not that Emacs has a learning curve. Haskell mode for Emacs is just sub-optimal.
06:09:29 <fasta> From what I understand of dons, the vim haskell mode is bette.r
06:09:43 <dons> well, i'm not sure. it doesn't try to do anything :)
06:09:51 <dons> the syntax highlighting is good :)
06:09:55 <gour> fasta: well that's just another inconvenience then. still, hIDE features list on wiki is quite good
06:09:58 <vincen1> f
06:10:14 <dons> i've a piece of a vimscript indenter for vim, but i think i'd prefer to write it in .hs, and link that instead
06:10:26 <dons> haven't looked at the vimscript FFI *cough* enough yet
06:11:07 <jgrimes> it'd be cool to get yi up to part
06:11:10 <jgrimes> par, even
06:11:11 <jgrimes> :)
06:11:21 <gour> dons: is yi still main editor considered for hIDE?
06:11:25 <dylan> vim is truely amazing in how many languages you can embed in it
06:11:41 <norpan> you can?
06:11:44 <dons> gour: not sure. hIDE's kind of stalled.
06:11:53 <fasta> dons: http://www.haskell.org/pipermail/haskell-cafe/2006-May/015898.html
06:11:56 <lambdabot> Title: [Haskell-cafe] Editors for Haskell, http://tinyurl.com/evomx
06:12:02 <gour> dons: tha't s pity
06:12:32 <dylan> norpan: you were asking me or what?
06:12:42 <fasta> dons: also http://www.metamilk.com/
06:12:44 <lambdabot> Title: metamilk.com software tools for developing digital creations Home
06:12:48 <norpan> dylan: yes
06:12:58 <dons> huh, i missed that
06:12:59 <gour> is haste IDE dead?
06:13:04 <dylan> norpan: yes, you can embed python, ruby, tcl, perl, and mzscheme at least.
06:13:13 <dylan> possibly more.
06:13:17 <norpan> haskell?
06:13:26 <dons> i'd think yes
06:13:36 <dons> it's just some C stuff, last time I looked
06:13:44 <dons> hasn't been done though
06:13:45 <fasta> dons: although that website gives me little confidence
06:13:46 <dons> but we should!
06:14:25 <dylan> dons: I would appreciate your vimscript indenter.
06:14:39 <dons> i'll tidy it up and put it out then
06:14:45 <norpan> do you need to compile vim with some extra feature to use it?
06:14:57 <dylan> norpan: yes, or on debian install the right package.
06:15:08 <dylan> e.g. vim-perl, vim-python, etc.
06:15:10 <dylan> or vim-all.
06:15:22 <dylan> on gentoo it's just a USE flag though.
06:15:27 <gour> Someone said, "Haskellers of the World, Unite!"
06:16:42 <norpan> hmmm, how does that work on debian? one different version of the vim binary for each feature?
06:16:51 <dylan> basically, yes.
06:16:54 <fasta> norpan: for every combination ;)
06:17:23 <dylan> Not for every combination.
06:17:29 <fasta> dylan: I know
06:17:30 <norpan> what happens if you have both installed?
06:17:42 <fasta> norpan: depends whether they "conflict".
06:18:01 <norpan> well, they contain the same file
06:18:13 <dylan> vim-python and vim-perl can both be installed
06:18:17 <dylan> it seems
06:18:25 <dylan> I'm guessing it must farm it out to a shared library.
06:18:32 <norpan> hmmm
06:18:44 <norpan> interesting
06:19:42 <norpan> so we should do vim-haskell
06:19:43 <vincenz> vim-ruby, vim-scheme....
06:20:06 <vincenz> both built in I think
06:20:12 <vincenz> just need ruby or mzscheme on your sys
06:20:20 <dons> right. we should do vim-haskell
06:20:26 <dons> probably not a lot of work.  big payoff
06:20:36 <norpan> eternal glory etc
06:20:46 <dons> and eternal glory
06:21:28 <dons> first would be to get support for integrating haskell .o files statically
06:21:34 <dons> then look at dynamically loaded stuff
06:21:47 <dons> and then i suppose, ultimately, ghc-api eval'd stuff
06:22:10 <dons> but just the second point would be enough to start extending the haskell support with proper parsers and indenters and so on
06:24:04 <fasta> dons: could you answer my question regarding trace?
06:24:13 <dylan> it'd give haskell a major boost over othjer languages in vim development. :)
06:25:44 <dylan> (in a certain other channel, I got into an argument with someone that thought 'vim' was only for crusty C programmers, and wasn't good for doing naything non-mainstream....)
06:26:08 <integral> hmm,  how unsafe is (unsafePerformIO (newIORef nil)), both in CAFs and non-CAFs?
06:32:36 <shapr> @users
06:32:38 <lambdabot> Maximum users seen in #haskell: 232, currently: 230 (99.1%), active: 29 (12.6%)
06:32:50 * shapr boings
06:32:52 <shapr> @users
06:32:54 <lambdabot> Maximum users seen in #haskell: 232, currently: 230 (99.1%), active: 29 (12.6%)
06:35:51 <vincenz> @boign
06:45:19 <dons> ?users
06:45:20 <lambdabot> Maximum users seen in #haskell: 233, currently: 233 (100.0%), active: 27 (11.6%)
06:55:09 <ventonegro> anyone knows a good FFI guide?
07:01:29 <kosmikus> who's the mailman admin for haskell.org?
07:01:44 <fasta> SPJ?
07:05:07 <Cale> ventonegro: the actual FFI standard is quite readable
07:05:22 <Cale> @where ffi
07:05:23 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:05:33 <ventonegro> Cale, i'm reading it right now :-)
07:05:36 <ventonegro> Cale, thanks
07:11:52 <ventonegro> is there a standard monad State?
07:13:13 <musasabi> Has anyone packaged an utility to create graphical module dependency graphs in from Haskell source files?
07:13:52 <musasabi> I have several hacky things with dot (graphviz), but something good and working could be nice.
07:13:59 <Cale> ventonegro: yep
07:14:05 <Cale> Control.Monad.State
07:14:10 <ventonegro> ah!
07:14:21 <ventonegro> i tried browsing Control.State
07:14:37 <Cale> (though I suppose that it's not "standard" in that there's no document which standardises what's in it)
07:15:01 <Cale> But every implementation uses the same library base at the moment :)
07:16:20 <ventonegro> humm... so much to learn
07:17:58 <musasabi> Cale: jhc does not.
07:18:12 <Cale> Oh?
07:18:27 <Cale> I suppose I haven't actually tried jhc yet
07:18:29 <musasabi> it uses a modified version.
07:19:09 <musasabi> but mostly same structure and tries to be conformant.
07:19:32 <musasabi> The largest problem is that parts of base are ghc-dependent so a base dependency does not really tell that much.
07:24:44 <glguy> jhc doesn't have Control.Monad.State?
07:25:25 <musasabi> No MPTC+FD
07:26:30 <gour> @where yhc
07:26:31 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
07:36:58 <shapr> kosmikus: I think JaffaCake is the mailman admin.
07:38:48 <kzm> Okay - I fixed my code (for those who were around earlier).  The good news is that removing the indexing speeds things up markedly.
07:39:08 <kzm> The bad news is that this makes GC an even larger part of the total time - 60% according to -s
07:40:03 <int-e> and it still gers slower when playing with the heap size?
07:40:07 <int-e> *gets
07:41:22 <kzm> int-e, haven't gotten around to that yet.
07:41:33 <kzm> I've compiled with 6.4.1 to see how that performs.
07:41:39 <kosmikus> shapr: thanks
07:42:20 <kzm> The nice thing is that the indexing code was long overdue for maintenance, and as a result, it is a bit cleaner now.
07:43:41 * kzm wonders if it would be possible to output a memory profile when a program crashes with out of memory.
07:54:58 <shapr> kzm: What are you hacking on?
07:55:11 <shapr> kzm: Yeah, that's a feature I'd love.
07:56:53 <shapr> @users
07:56:54 <lambdabot> Maximum users seen in #haskell: 234, currently: 232 (99.1%), active: 28 (12.1%)
07:58:55 <jgrimes> :D
07:59:04 <jgrimes> but wait... 3 people just left.
07:59:08 <kzm> shapr, (sorry; i was out for a sec)
07:59:12 <jgrimes> 232 + 3 = 235
07:59:22 <dwm> Wow, 232 people here now?
07:59:23 <dwm> :o
07:59:31 <kzm> Well - at the moment, it is a small script to identify repeats from clustered sequences.
07:59:53 <kzm> I.e. just find the words that occur in more than one set of sequences, really.
08:00:55 <kzm> dwm, you should probably deduct some who are here in muliplicates.
08:01:20 <dwm> forked individuals
08:03:29 <vincenz> kzm: oh!
08:03:33 <vincenz> kzm: I made something like that
08:03:35 <vincenz> kzm: in fact
08:03:39 <vincenz> kzm: it was nestable
08:03:45 <kzm> Urg. 6:53 with GHC 6.5, 4:06 with 6.4.1
08:03:55 <kzm> vincenz, ?
08:04:12 <vincenz> 16:59 < kzm> Well - at the moment, it is a small script to identify repeats from clustered sequences.
08:04:33 <vincenz> I had something for any datatype that did Eq
08:04:39 <vincenz> (was done in ocaml but easy to port)
08:04:41 <vincenz> for instance
08:04:47 <vincenz> A A B A A B A B A A B A A B A B
08:05:12 <kzm> OK.  Efficient?  Ideally, I'd like to run on relatively large amounts of data, but the Maps (which I use) tend to get pretty big.
08:05:25 <vincenz> Repeat (2, [Repeat (2, [Repeat(2, [A]), Single B])], ...
08:05:27 <vincenz> well you get the idea
08:05:29 <vincenz> and trust me
08:05:36 <vincenz> I had to do it on like 70M packets
08:06:28 <kzm> vincenz, I don't think it's quite the same thing.
08:06:30 <vincenz> oh
08:06:33 <vincenz> oh well
08:06:47 <vincenz> in simple words (without all the datacon spam
08:07:00 <vincenz> 2*[2*[2*A,B],A,B]
08:07:09 <vincenz> :)
08:07:39 <kzm> From a number of sets of strings, I need to find all substrings that occur in strings in more than one set.
08:07:45 <vincenz> oh
08:07:51 <vincenz> ouch
08:08:08 <vincenz> that sounds like an O(n^2) if not more
08:08:41 <mux_> there are tons of fixed-string searching algorithms in the world
08:08:47 <kzm> No, it's nlogn, I think: I maintain maps of all seen-once words, and all repeated words.
08:08:54 <vincenz> kzm: but you want substrings
08:09:00 <kzm> But the maps tend to get big...
08:09:07 <mux_> many need to precompute stuff from the searched substring
08:09:16 <mux_> Boyer-Moore is one widely used algorithm for this
08:09:22 <dottedmag> kzm: you'll need the O(e^n) memory to keep strings.
08:09:31 <dottedmag> substrings, i meant
08:09:45 * Prip stocazzo
08:09:46 <mux_> http://www-igm.univ-mlv.fr/~lecroq/string/
08:09:48 <lambdabot> Title: ESMAJ
08:09:52 <mux_> I recommend this very much
08:10:03 <mux_> it's the best reference on exact string matching algorithms around
08:10:18 <kzm> I can do multi-pass (by word prefix).  So I get k*(n + n/k log n) for arbitrary k, and n/k log n space usage.
08:10:22 <mux_> of course, this will need adaptation to a purely function and lazy language such as haskell
08:10:33 <mux_> s/function/&al/
08:10:33 <vincenz> hp
08:10:39 <kzm> dottedmag, only fixed-length substrings.
08:10:43 <Prip> straminchia
08:10:46 <dottedmag> ah, that's easier
08:10:49 <mux_> kzm: watch that site
08:12:26 <kzm> Another (obvious) choice could be to build a suffix tree/array from the data.  Could be fast, but expensive in terms of memory.
08:13:28 <kzm> But one reason I don't is that I may want to use gapped words later on.  Another is that I want to treat each word and its reverse complement identically.
08:13:57 <kzm> (nucleotide sequence: ACGA in one direction, but TCGA in the other)
08:14:08 <kzm> (sorry: TCGT)
08:14:29 <dwm> ?type divmod
08:14:31 <lambdabot> Not in scope: `divmod'
08:14:50 <kzm> Nice site, mux.
08:14:55 <kzm> @type divMod
08:14:56 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:15:08 <mux> kzm: yeah, I love it so much. :-)
08:15:13 <kzm> > 11 `divMod` 7
08:15:14 <dwm> kzm: Thank you
08:15:15 <lambdabot>  (1,4)
08:19:55 <glguy> I feel dirty.  I solved the sudoku question on mathschallenge using simple back-tracking in the list monad, instead of actually using "logic"
08:20:50 <Cale> hehe
08:21:08 <Cale> The mathschallenge problems are mostly kind of stupid like that though.
08:21:37 <glguy> they give me something mildly interesting to code instead of doing real work
08:22:03 <Cale> At least, all the ones I've ever seen haven't involved too much work, and most of the solutions seem to be in the form of a number.
08:22:22 <glguy> they are all in the form of a number, i believe
08:22:59 <glguy> I only have 12 problems left, so you'll hear me talk about it less and less ;)
08:24:16 <Cale> If you want a real mathematics challenge, I have a problem in ring theory which I'd like to know the answer to. :) If R is a commutative ring, and J is an ideal of R, when is the set of units in 1+J a subgroup of the full group of units in R?
08:24:50 <Cale> I haven't found a counterexample to the claim that the answer is "always".
08:25:00 <Cale> (but I also haven't looked very hard)
08:25:04 <mauke> <3 liftM2 (&&) (>= '0') (<= '9')
08:25:09 <glguy> stfu :-p don't try to downplay my fun
08:25:36 <Cale> hehe
08:25:37 <shapr> kzm: Can you use standard compression algorithms to do that sort of thing?
08:27:03 <kzm> shapr, maybe.  Compression and string indexing is fairly closely related.
08:27:38 <kzm> Feel free to hack my code. :-)
08:27:57 <kzm> Actually, I still haven't gotten around to use Judy for the Maps.
08:28:37 <kzm> Even though Caio already did all the heavy lifting... bad me.
08:30:44 <shapr> I have other stuff to do, so I doubt I'll have time to hack on your code :-)
08:31:09 <Cale> If J is a nil ideal, then the answer is that it definitely is a subgroup, because in that case if 1+x is a unit in 1+J, then x is nilpotent, that is, x^n = 0 for some n, and the inverse of 1+x is 1 - x + x^2 - x^3 + ... + (-1)^(n-1) x^(n-1), which is again going to be in the ideal J since it's closed under addition and multiplication.
08:31:54 <Cale> (and ideals are closed under multiplication, so existence of inverses for the units is all there really is to check)
08:32:33 <Cale> Oh, well, I should spell that last point out...
08:33:13 <Cale> If u = 1 + x, and v = 1 + y are units in 1 + J, then uv = 1 + x + y + xy, and x + y + xy will be an element of J, so uv will be in 1 + J
08:34:35 <Cale> I've also found good examples where J is not a nil ideal, and still has this property, so that's not necessary, only sufficient.
08:35:23 <musasabi> hmm. Any preferences as to hunit vs quickcheck for use with HPC (code coverage tool) ?
08:42:03 <glguy> How could I make the following more efficient? fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
08:42:25 <glguy> write it as a function instead of a list?
08:42:43 <mauke> depends on what you want to do with it
08:43:03 <int-e> > take 10 $ fix ((1:) . scanl' (+) 1)
08:43:08 <lambdabot>  Not in scope: `scanl''
08:43:16 <int-e> aww
08:43:40 <glguy> I want to find the first fibonacci sequence that is 1-9 pandigital in the first 9 and last 9 digits
08:43:45 <musasabi> http://www.cubbi.org/serious/fibonacci/haskell.html
08:43:48 <lambdabot> Title: cubbi.com: fibonacci numbers in Haskell, http://tinyurl.com/rduz3
08:43:54 <glguy> but first I need a better way to generate the sequence
08:46:57 <glguy> thanks musasabi, I'll give algorithm 3b a look
08:47:53 <int-e> the zipWith isn't really bad - it would profit from a bit of added strictness so it doesn't create thunks for the addition.
08:48:10 <int-e> if what you want is to generate fibonacci numbers sequentially
08:48:14 <glguy> int-e: I do
08:48:33 <glguy> int-e: do I need to add strictness if I am evaluting each number as it is generated?
08:48:50 <ndm> musasabi: i suspect smallcheck is the recommended way
08:49:00 <ndm> musasabi: but should be fairly neutral as to what runs the tests
08:49:12 <int-e> glguy: maybe, maybe not. maybe the compiler is smart enough
08:50:30 <glguy> is show relatively slow for large numbers?
08:50:51 <int-e> what's your ghc version?
08:51:02 <glguy> I'm using visual haskell for this
08:51:08 <glguy> so 6.5 i think
08:51:24 <sjanssen_> glguy: show for large Integers is slow in 6.4, fast in 6.5
08:51:31 <int-e> in 6.5 it shouldn't be so bad.
08:52:38 <norpan> is there an alternative to gmp yet for Integers and whatsnot
08:52:42 * musasabi looks at smallcheck
08:52:52 <int-e> not with ghc
08:53:00 <glguy> for testing the first 9 digits, would it be faster to do a show (x `mod` (10^10)) than to take 9 $ show x?
08:53:22 <int-e> glguy: strange notion of 'first' :)
08:53:30 <glguy> that's for the last
08:53:38 <glguy> oh
08:53:41 <glguy> duh
08:53:48 <glguy> you know what I mean...
08:53:56 <glguy> is mod faster than showing a larger number
08:54:03 <musasabi> ndm: that doesn't come with a homepage, darcs repo or cabal support?
08:54:10 <int-e> I would use the first for the last digits and the second for the first digits.
08:54:11 <glguy> this would be for the last digits
08:54:14 <int-e> yes
08:54:23 <glguy> k
08:54:26 <ndm> musasabi: nope :)
08:54:41 <ndm> neither does hpc though
08:55:27 <glguy> last question. would i be correct in assuming that the code that checks the last digits would be faster than the code that checks the first digits
08:55:50 <glguy> (planning to run the faster test more often than the slower one )
08:56:41 <int-e> that depends on how you do it.
08:56:45 <glguy> k
08:57:48 <glguy> is this statement true? length . nub is O(n^2) while length . group . sort is O(n log n) (when run on a list of 9 elements)
08:58:12 <mauke> both O(1) if the input is fixed
08:58:19 <glguy> (does length O(n) need to be considered in my guess)?
08:58:32 <glguy> true
08:58:55 <mauke> @type nub
08:58:56 <sjanssen_> how long can the list be?
08:58:57 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:59:06 <mauke> yeah, looks like sort can be faster
08:59:07 <glguy> nevermind O(n^2) + O(n) = O(n^2)
08:59:23 <glguy> so the length doesnt' matter
08:59:52 <sjanssen_> also, if the range of your elements is smallish (less than 50 or so), some magic with accumArray would be the fastest
09:00:07 <glguy> @type accumArray
09:00:09 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
09:01:00 <glguy> How would I use accumArray to do this? (I've never used accumArray)
09:01:01 <sjanssen_> an algorithm with accumArray could be O(n + k) where k is the size of your domain
09:01:15 <int-e> which is 10
09:01:27 <int-e> (decimal digits)
09:01:32 <glguy> you mean to make one pass over the list
09:01:38 <glguy> and mark which digits I've seen as I go
09:01:46 <sjanssen_> glguy: exactly
09:01:56 <glguy> yeah... that sounds smarter
09:02:45 <glguy> I guess I'd have to make a second pass to see that all elements are accoutned for
09:03:03 <sjanssen_> do you want to go for as fast as possible, or reasonably fast and somewhat elegant?
09:03:04 <int-e> maybe. depends.
09:03:33 <glguy> I'm looking for balls to the wall solutions ;)
09:03:57 <JKnecht> wrong lingo
09:05:26 <glguy> @index accumArray
09:05:26 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
09:07:16 <sjanssen_> @hoogle shiftR
09:07:17 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
09:07:18 <lambdabot> GHC.Exts.shiftRL# :: Word# -> Int# -> Word#
09:07:18 <lambdabot> GHC.Exts.iShiftRA# :: Int# -> Int# -> Int#
09:09:10 <glguy> > and $ elems (accumArray (||) False (1,9) $ map (flip (,) True) [1,2,3,4,5,6,7,9])
09:09:11 <lambdabot>  False
09:09:14 <glguy> > and $ elems (accumArray (||) False (1,9) $ map (flip (,) True) [1,2,3,4,5,6,7,8,9])
09:09:15 <lambdabot>  True
09:09:18 <kzm> Damn OOM!  Anybody else see problems where limiting heap doesn't work?
09:09:25 <glguy> like that?
09:09:38 <kzm> (or understand how ghc's RTS limits heap use)
09:10:00 <sjanssen_> glguy: exactly like that
09:10:38 <sjanssen_> glguy: for added speed make sure that accumArray is building a UArray i Bool
09:10:43 <glguy> kk
09:12:13 <glguy> I'm going to use UArray Char Bool, rather than reading the results of show
09:13:35 <musasabi> ndm: does smallcheck works if the tested functions are in IO ?
09:13:58 <ndm> musasabi: absolutely no idea, email Colin
09:15:46 <int-e> glguy: does it have to be fast?
09:16:10 <int-e> > product [1..9] / 10^9
09:16:12 <lambdabot>  3.6288e-4
09:16:17 <glguy> int-e: yes
09:16:19 <int-e> > 1 / (product [1..9] / 10^9)^2
09:16:20 <lambdabot>  7594058.428126624
09:16:59 <glguy> > product [1..9]
09:17:01 <lambdabot>  362880
09:17:18 <glguy> > product [1,1,3,6,5,6,7,8,9]
09:17:19 <lambdabot>  272160
09:17:24 <glguy> > product [1,1,3,8,5,6,7,8,9]
09:17:25 <lambdabot>  362880
09:18:42 <weitzman> I can tell if I'm typing something wrong or of djinn can't handle the massive complexity of this query
09:18:48 <weitzman> @djinn  [(i, a)] -> [a]
09:18:48 <lambdabot> -- f cannot be realized.
09:19:03 <sjanssen_> weitzman: djinn doesn't know lists
09:19:06 <weitzman> Oh
09:19:26 <weitzman> I guess djinn is more of an array person
09:19:29 <weitzman> I can dig it
09:19:37 <mauke> f = fmap snd
09:20:41 <sjanssen_> @. pl djinn (a -> b -> c -> d -> e) -> d -> c -> b -> a -> e
09:20:41 <lambdabot> f = flip . ((flip . (flip .)) .) . flip . (flip .) . flip
09:21:32 <weitzman> @djinn (a -> c) -> (b -> c) -> c
09:21:32 <lambdabot> -- f cannot be realized.
09:21:47 <weitzman> No lambdas either?
09:21:49 <int-e> glguy: let me just say that a 10 lines program solved this in less than 1 minute, without putting too much thought into it.
09:21:56 <sjanssen_> weitzman: no, you made a typo
09:21:59 <weitzman> Oh
09:22:07 <sjanssen_> @djinn (a -> b) -> (b -> c) -> c
09:22:08 <lambdabot> -- f cannot be realized.
09:22:18 <weitzman> No, I typed what I meant
09:22:22 <sjanssen_> @djinn (a -> b) -> (b -> c) -> a -> c
09:22:23 <lambdabot> f a b c = b (a c)
09:22:31 <weitzman> Oh, wait
09:22:32 <weitzman> Yeah
09:22:34 <weitzman> No I didn't
09:22:39 <int-e> @free f :: (a -> b) -> (b -> c) -> c
09:22:40 <lambdabot> h . p = q . g => k . f1 = f2 . h => k (f p f1) = f q f2
09:22:50 <glguy> int-e: would you look at my solution and just tell me what you think my bottle-neck is?
09:23:15 <glguy> I don't want to see the correct answer, I just don't know enough about haskell performance tuning to know what's killing me
09:23:31 <dcoutts__> g'evening SyntaxNinja
09:23:48 <int-e> I didn't use show. Show is fast if you want all digits, but not really for this problem.
09:23:52 <ndm> I just wrote a haskell compiler :)
09:24:06 <ndm> or at least, wrote a Yhc -> Hite -> Transform -> C pass
09:24:10 <glguy> int-e: what did you use instead of show?
09:24:11 <dcoutts__> ndm: nice
09:24:25 <dcoutts__> ndm: what are the middle two ?
09:24:25 <int-e> divisions and mod
09:24:29 <ndm> dcoutts__: just trying to get some benchmarks :)
09:24:45 <glguy> int-e: did you have to take the log to determine what to div by?
09:24:46 <dcoutts__> l
09:24:48 <dcoutts__> oops
09:24:56 <ndm> dcoutts__: Hite is my reduced haskell language from my Catch work, Transform is a reduced transformation system from my Catch thing
09:25:05 <int-e> no. you can just keep track of a power of 10 as you go along.
09:25:09 <ndm> its an entirely first order language :)
09:25:15 <dcoutts__> ok
09:26:05 <glguy> heh... my solution finished :)
09:26:16 <int-e> glguy: for inspiration. my main loop has this type: Int -> Int -> Integer -> Integer -> Integer -> Int -> [Int]
09:26:48 <monochrom> Int galore!
09:27:16 <sjanssen_> @djinn Int -> Int -> Integer -> Integer -> Integer -> Int -> [Int]
09:27:17 <lambdabot> -- f cannot be realized.
09:27:18 <int-e> hey, only 6 arguments. that's harmless.
09:28:06 <glguy> 84/* :-D
09:28:54 <glguy> I think that the major improvement over my last solution was the 2 pass pandigital check
09:30:55 <glguy> int-e: in your solution, how did you check the pandigital property?
09:31:19 <int-e> test a = [1,2,3,4,5,6,7,8,9] == (sort . map (`mod` 10) . take 9 $ iterate (`div` 10) a)
09:31:24 <shapr> greetz SyntaxNinja
09:31:39 <int-e> input: a 9 digit number.
09:32:29 <glguy> should that be faster than the accumArray version?
09:32:34 <int-e> not really
09:32:57 <int-e> it's not optimized at all
09:33:14 <int-e> beyond not using nub
09:35:59 <int-e> it's probably a bit faster than length . group . sort ...
09:36:19 <int-e> (and does something slightly different)
09:36:44 * shapr throws lambdas
09:36:51 * dcoutts__ catches one
09:37:01 <dcoutts__> ohh it's a unicode one
09:37:13 <shapr> Yeah, extra bits!
09:37:34 <shapr> I've never had a UTF-31 lambda, I wonder how they taste.
09:37:43 <dcoutts__> greek
09:38:10 <shapr> Makes sense.
09:38:25 <monochrom> There is UTF-31?
09:38:36 <dcoutts__> no
09:38:51 <dcoutts__> you get 8, 16 or 32
09:38:59 <sjanssen_> there is UTF-7
09:39:01 <glguy> when I was a kid, all we had was ASCII, and we were thankful for it!
09:39:03 <glguy> ;)
09:39:05 <dcoutts__> anything else is a herracy
09:39:10 <shapr> We typed uphill both ways in the snow!
09:39:13 <sjanssen_> UTF-7 is obscure though
09:39:15 <CosmicRay> glguy: that's right, because the alternative is ebcdic
09:39:18 <dcoutts__> specifically UTF-7 is a heracy
09:39:20 <dottedmag> monochrom: if you find the machine with 31-bit in word :)
09:39:25 <shapr> And NOBODY likes ebcdic.
09:39:27 <CosmicRay> oh wait, EBCDIC is still with us ;-)
09:39:31 <dcoutts__> sjanssen_: and it's deprecated
09:39:37 <CosmicRay> shapr: I completely concur.  I still have to work with it to process crap from an as/400
09:39:59 <shapr> dcoutts__: http://en.wikipedia.org/wiki/UTF-8 shows UTF-{7,8,16,32} and some other serious weirdness.
09:40:10 <shapr> CESU-8 anyone? or Punycode?
09:40:18 <CosmicRay> shapr: yes, I was just trying to come up with that page.  there's a uuencode version too, right?
09:40:22 <sjanssen_> http://en.wikipedia.org/wiki/UTF-9
09:40:28 <monochrom> I know a 36-bit computer.  It was actually a famous public FTP server.
09:40:29 <sjanssen_> but that was a joke
09:40:38 <dcoutts__> CosmicRay: want to contribute a bytestring Codec.Text.EBDIC.(to|from) :: ByteString -> ByteString
09:40:46 <xerox> http://www.motobit.com/util/punycode-decoder-encoder.asp
09:40:52 <lambdabot> Title: ASP unicode to punycode idn online decoder and encoder., http://tinyurl.com/gvlpu
09:40:54 <CosmicRay> dcoutts: NO! :-)
09:40:59 <dcoutts__> CosmicRay: hah
09:41:05 <shapr> sjanssen_: wow, scary
09:41:38 <CosmicRay> dcoutts: though I do have code that will parse ints or floats from the as/400 once the underlying data has been converted to ASCII
09:41:58 <dcoutts__> sounds unpleasent :-)
09:42:14 <shapr> Heck, I thought AIX was unpleasant.
09:42:22 <CosmicRay> they do some seriously weird crap to indicate things like signedness.  if the last digit is not a number but certain punctuation symbols, then it's negative and there are rules to apply to convert that punctuation back to a number
09:42:23 <CosmicRay> stuff like that
09:42:39 <CosmicRay> shapr: AS/400 makes AIX look positively attractive
09:42:52 <shapr> CosmicRay: I'm getting that impression quickly...
09:43:25 <CosmicRay> shapr: also you have to take down the TCP stack on the AS/400 to run a backup
09:43:33 <shapr> whatever for?
09:43:44 <CosmicRay> lesse, what else.  oh yes, as/400 has some braindead equivolent of tcpdump, but you can only send its output to a printer.
09:43:49 <shapr> nuts
09:43:54 <glguy> not too long ago you had to relink SCO's kernel to check your ipaddress
09:43:55 <CosmicRay> shapr: I dunno, apparently all sorts of stuff has to be shutdown
09:44:04 <shapr> Man, I have this urge to write QuickCheck tests.
09:44:05 <glguy> change*
09:44:07 <shapr> What should I test?
09:44:52 <CosmicRay> http://en.wikipedia.org/wiki/UTF-EBCDIC
09:44:53 <CosmicRay> sigh.
09:45:06 <CosmicRay> yes, there is really a unicode encoding for ebcdic.
09:46:06 <shapr> That makes me think of the XML encoding for ASN.1
09:46:29 <dottedmag> shapr: there is one
09:46:37 <shapr> I know XER is for debugging, but it's still one of the better oxymorons I know... an xml encoding for a binary format.
09:46:41 <shapr> dottedmag: I know, I've used it.
09:46:44 <CosmicRay> heh
09:47:27 * dottedmag really think someone in IBM had a funny (optionally boring) days inventing all this XML stuff on AS/400
09:48:19 <glguy> is that "third-person-plural"?
09:48:21 <glguy> ;)
09:48:51 <dottedmag> oops.
09:48:56 * dottedmag is not a native speaker
09:49:27 <glguy> I just wanted to say "third-person-plural"
09:51:02 <shapr> I'd like to say SHAZAM!
09:51:22 <glguy> say it then!
09:52:30 <glguy> That seems like a pre-emptive quit... he joined, and was killed for the subsequent join flood
09:52:49 <glguy> that he was about to commit :)
10:18:54 <araujo> hi hi!
10:19:08 * araujo throws sugar lambdas at everyone
10:20:45 <dottedmag> Beware! Syntactic sugar causes cancer of the semicolon.
10:20:58 <Codex_> s/hi/(\x.x x)/
10:25:33 <araujo> dottedmag, lambda sugar is healthy!
10:27:45 <dottedmag> araujo: Of course! It may heal the code, when applied in proper doses :)
10:30:13 <shapr> Has anyone arranged a #haskell meeting near Haskell Workshop?
10:31:18 <araujo> :-)
10:35:34 <dolio> ?hoogle unique
10:35:36 <lambdabot> Data.Unique :: module
10:35:36 <lambdabot> Data.Unique.Unique :: data Unique
10:35:36 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
10:36:23 <glguy> dolio: you want the unique elements in a list?
10:37:04 <dolio> :) That's what I was considering.
10:37:34 <mauke_> @type List.nub
10:37:39 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:37:41 <glguy> I usually use: nub, or map head . group . sort
10:38:20 <dolio> Ah yes, nub. :)
10:38:32 <xerox> > map (head &&& length) . group . sort $ "the brown fox jumps over the lazy dog"
10:38:33 <lambdabot>  [(' ',7),('a',1),('b',1),('d',1),('e',3),('f',1),('g',1),('h',2),('j',1),('l...
10:39:15 <glguy> > map (liftM2 (,) head length) . group . sort $ "the brown fox..."
10:39:16 <lambdabot>  [(' ',2),('.',3),('b',1),('e',1),('f',1),('h',1),('n',1),('o',2),('r',1),('t...
10:39:29 <mauke_> haha, I was about to type that> map (liftM2 (,) head length)
10:39:35 <xerox> :D
10:39:44 <xerox> I like &&& more.
10:39:49 <velco> duh .. concise and easy to understand, eh ?
10:39:52 <glguy> I'm always looking for places to use liftMn and sequence :)
10:42:06 <glguy> > liftM (liftM2 (,) head length) . group . sort $ "the brown fox..."
10:42:07 <lambdabot>  [(' ',2),('.',3),('b',1),('e',1),('f',1),('h',1),('n',1),('o',2),('r',1),('t...
10:42:09 <glguy> :)
10:43:39 <mauke> > liftM (liftM (liftM (liftM2 (,) head length)) group) sort $ "the brown fox..."
10:43:40 <lambdabot>  [(' ',2),('.',3),('b',1),('e',1),('f',1),('h',1),('n',1),('o',2),('r',1),('t...
10:43:41 <xerox> Now just rewrite sort, group, length, head and (,) in terms of liftM# ...
10:43:53 <mauke> (.) is the obvious candidate
10:47:11 <tibbe> @ya
10:47:12 <lambdabot> I'll crush ye barnacles!
10:47:19 <tibbe> @yi
10:47:19 <lambdabot> Maybe you meant: . bf id pl v wn yow
10:47:52 <glguy> @. bf id pl v wn yow
10:47:53 <lambdabot> Done.
10:47:58 <dolio> @id foo
10:47:59 <lambdabot> foo
10:50:04 <xerox> ?. pl undo \f amb -> do { x <- amb; return (f x); }
10:50:04 <lambdabot> fmap
10:51:19 <SamB> @. bf . id . pl . v . wn yow
10:51:29 <lambdabot> Done.
10:51:33 <dolio> Heh.
10:51:37 <xerox> hahaha
10:52:00 <xerox> @remember SamB <SamB> @. bf . id . pl . v . wn yow  <lambdabot> Done.
10:52:20 <dolio> @help yow
10:52:21 <lambdabot> yow. The zippy man.
10:52:26 <xerox> @ya
10:52:26 <lambdabot> This is the END for you, you gutter-crawling cur!
10:52:30 <SamB> hmm, perhaps it would work better if we left out the ". bf " part?
10:52:40 <dolio> @yow
10:52:41 <lambdabot> I feel like a wet parking meter on Darvon!
10:52:50 <xerox> SamB: the more! the better!
10:52:58 <SamB> @. id . pl . v . wn yow
10:53:05 <lambdabot> Just 'J'
10:53:09 <xerox> Just J.
10:53:19 <xerox> @. wn yow
10:53:31 <lambdabot> *** "catsup" wn "WordNet (r) 2.0"
10:53:31 <lambdabot> catsup
10:53:31 <lambdabot>    n : thick spicy sauce made from tomatoes [syn: {ketchup}, {cetchup},
10:53:31 <lambdabot>      {tomato ketchup}]
10:53:31 <lambdabot> No match for "and".
10:53:33 <lambdabot> [144 @more lines]
10:53:53 <SamB> @help v
10:53:53 <lambdabot> let v = show v in v
10:54:07 <SamB> @. bf . id . pl . v . wn yow
10:54:12 <lambdabot> Done.
10:54:18 <SamB> oops
10:54:19 <xerox> The . wn yow part isn't useful.
10:54:27 <xerox> @. v id foo
10:54:27 <lambdabot> Exception: <<loop>>
10:54:30 <xerox> O_o
10:54:38 <glguy> > fix (\f xs -> let h = head xs; t = tail xs in guard (not $ null xs) >> (f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f(t >>= \x -> guard (x>=h) >> [x]))) [5,4,3,2,1]
10:54:39 <lambdabot>  [1,2,3,4,5]
10:54:41 <mauke> that's from @v
10:54:47 <xerox> @. v id arr
10:54:48 <lambdabot> "\"#$%&'()*+,\""
10:54:52 <xerox> @. v id why?!
10:54:53 <lambdabot> "\""
10:55:49 <monochrom> glguy: you have mastered "fix" indeed! :)
10:56:02 <glguy> :-p
10:56:23 <glguy> I mostly just wanted to use guard a lot
10:56:23 <SamB> @pl fix (\f xs -> let h = head xs; t = tail xs in guard (not $ null xs) >> (f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f(t >>= \x -> guard (x>=h) >> [x]))) [5,4,3,2,1]
10:56:23 <SamB> <lambdabot>  [1,2,3,4,5]
10:56:28 <lambdabot> fix (flip ap (fix . const . tail) . flip ap (fix . const . head) . (flip .) . flip ((.) . (.) . (>>) . guard . not . null) . ap (ap . (ap .) . (((++) .) .) . (. ((. flip (ap . ((>>) .) . (guard .) .
10:56:28 <lambdabot> flip (<)) (: [])) . (>>=))) . (.)) ((ap (:) .) . (. ((. flip (ap . ((>>) .) . (guard .) . flip (>=)) (: [])) . (>>=))) . (.))) [5, 4, 3, 2, 1]
10:56:28 <lambdabot> optimization suspended, use @pl-resume to continue.
10:56:33 <SamB> oh, oops...
10:56:38 <glguy> remove the data
10:56:45 <glguy> @pl fix (\f xs -> let h = head xs; t = tail xs in guard (not $ null xs) >> (f (t >>= \x -> guard (x<h) >> [x]) ++ h : f(t >>= \x -> guard (x>=h) >> [x])))
10:57:01 <lambdabot> fix (flip ap (fix . const . tail) . flip ap (fix . const . head) . (flip .) . flip ((.) . (.) . (>>) . guard . not . null) . ap (ap . (liftM2 (++) .) . (. ((. flip (ap . (((>>) . guard) .) . flip (<)
10:57:01 <lambdabot> ) return) . (>>=))) . (.)) ((ap (:) .) . (. ((. flip (ap . (((>>) . guard) .) . flip (>=)) return) . (>>=))) . (.)))
10:57:01 <lambdabot> optimization suspended, use @pl-resume to continue.
10:57:06 <glguy> lol
10:57:14 <monochrom> I think it's futile.
10:57:19 <CosmicRay> @help pl
10:57:19 <lambdabot> pointless <expr>. Play with pointfree code.
10:57:24 <glguy> looks like quick sort is going to stay in the realm of pointed functions
10:57:27 <CosmicRay> what does @pl do?
10:57:32 <glguy> removes variales
10:57:34 <glguy> variables*
10:57:36 <CosmicRay> oh, very interesting.
10:57:42 <SamB> something very pointless!
10:57:45 <glguy> or at least it removes function arguments
10:57:49 <mauke> remove lambda, actually
10:57:55 <xerox> CosmicRay: it converts your code to points-free form, i.e. no more named arguments
10:58:11 <xerox> (i.e. just a composition of combinators)
10:58:18 <SamB> @pl let x = x in x
10:58:18 <lambdabot> fix id
10:58:25 <SamB> not just lambdas!
10:58:29 <SamB> also lets...
10:58:36 <mauke> let is just a special case of \
10:58:41 <SamB> no it isn't!
10:58:50 <SamB> show me a \ that does that!
10:59:03 <glguy> the Y combinator?
10:59:07 <mauke> yeah, scoping :/
10:59:15 <CosmicRay> glguy: paul graham?
10:59:21 <SamB> remember than in Haskell, let is actually letrec...
10:59:37 * lispy thinks that letrec is a waste of keyword :)
10:59:52 <SamB> so did the designers of Haskell ;-)
10:59:58 <lispy> yay!
11:00:06 <CosmicRay> let rec -- isn't that from ocaml?
11:00:16 <lispy> yeah, when i wanted to use ocaml i kept wanting to redefine the syntax to make it haskell syntax ;)
11:00:17 <SamB> or really, I think it is a waste of letters!
11:00:24 <CosmicRay> to define a recursive function?
11:00:34 <SamB> and, more importantly, whitespace!
11:00:38 <sjanssen> @pl fix (\quicksort xs -> if null xs then [] else (let p = partition (< head xs) (tail xs) in fst p ++ head x : snd p))
11:00:39 <lambdabot> ap (flip if' [] . null) (liftM2 (++) fst ((head x :) . snd) . fix . const . ap (partition . flip (<) . head) tail)
11:00:55 <glguy> CosmicRay: I think that letrec puts the function's name in the fuctions scope, while let does not
11:00:57 <CosmicRay> lispy: I had a very similar experience.  I learned ocaml before I learned haskell, and there were things about ocaml that kept ticking me off (particularly that there are multiple APIs for everything, and some weird 80s syntax)
11:00:58 <lispy> and since i kept wanting ocaml to be haskell i stopped using ocaml and went back to haskell :)
11:01:30 <CosmicRay> lispy: once I learned Haskell, I thought that Haskell was not only the language I really wanted OCaml to be, but also the language I really wanted Python to be
11:01:42 <SamB> heh
11:01:44 <lispy> CosmicRay: amen
11:01:58 * SamB has trouble imagining Python as Haskell
11:02:30 <CosmicRay> SamB: well, there are similarities.  indentation as syntactically significant, list comprehensions.
11:02:32 <glguy> Python should definitely have a "Snakes on a Plane" web framework
11:02:39 <SamB> hah
11:03:05 <SamB> you could suggest that for the next Twisted-based web framework ;-)
11:03:11 <CosmicRay> SamB: up until the past couple of years, python was also steadily adding fp-like features.  map, lambda functions, etc
11:03:17 <xerox> @quote emertens
11:03:17 <lambdabot>  screw ruby on rails, I'm using snakes on a plane
11:03:39 <shapr> CosmicRay: I thought it had them from the beginning by popular demand.
11:03:50 <shapr> I am irritated that pep3k is removing reduce.
11:03:57 <shapr> "write a loop instead" it says
11:04:02 <frederik> somebody is working on a port of the haskell prelude to ruby or something like that ....
11:04:04 <SamB> well, that reduce is messed up, you have to admit!
11:04:08 <shapr> and lambdas will likely require parenthesization.
11:04:11 <ventonegro> data RawLuaState = Ptr ()
11:04:15 <glguy> shapr: write your own reduce and tell them to fsck off
11:04:15 <frederik> sounded rather strange to me
11:04:20 <ventonegro> isn't this supposed to be void*?
11:04:27 <shapr> glguy: I just use Haskell.
11:04:30 <glguy> and what the hell is pep3k? some kind of bio-science app?
11:04:35 <CosmicRay> shapr: I thought most of that was added in the 1.5.x days
11:04:37 <SamB> how about pep3k1: \ for lambdas!
11:04:54 <sjanssen> writing loops is so 20th century
11:04:56 <shapr> CosmicRay: I'm not sure, I thought it was there when I picked up 1.4
11:05:08 <SamB> hmm, remind me what is wrong with Python's lambdas, I know there was something...
11:05:08 <shapr> But that has been a little while...
11:05:21 <SamB> oh, perhaps the way they only work for expressions?
11:05:26 <shapr> SamB: single line lambdas in a language that requires indentation for scope.
11:05:28 <CosmicRay> shapr: hmm, ok then
11:05:44 <mauke> SamB: the real problem is that python can't embed statements in expressions
11:05:48 <mauke> unlike, say, perl
11:06:00 <lukeh> aoeaoeu23423432666663435 454234  234 32 asech asoaentuhaosebethu
11:06:01 <xerox> ...say...
11:06:05 <shapr> CosmicRay: Guido has never liked fp stuff, I suspect he was mauled by a lisp interpreter as a child, thus leading to his dislike of parens, curly braces, and fp.
11:06:11 <SamB> its easy to have trouble remembering stuff like that when you are in a language where imperatives are expressions
11:06:17 <shapr> lukeh: aoeuaoeuaoeu!
11:06:23 <lukeh> oops, sorry
11:06:27 <CosmicRay> shapr: hehe
11:06:28 <SamB> Haskell is the only language I know with first-class support for imperative programming
11:06:41 <CosmicRay> SamB: now there's a quote.
11:06:54 <SamB> CosmicRay: so, why don't you add it to the collection?
11:07:05 <xerox> SamB is extremely productive on the quotation side
11:07:10 <CosmicRay> SamB: can't be bothered to learn how ;-)
11:07:17 <xerox> @remember SamB Haskell is the only language I know with first-class support for imperative programming
11:07:24 <lukeh> shapr: are you a dvorak user?
11:07:26 <sjanssen> @quote SamB
11:07:26 <CosmicRay> xerox: I'm not so much, which is why I brought MegaMonad to life ;-)
11:07:26 <lambdabot>  Because sliced bread gives horribly uninformative error messages?
11:07:27 <shapr> Yeh, it's bad manner to add your own quotes to lambdabot. I think I'm the only person who does that =)
11:07:31 <shapr> lukeh: How'd you guess?
11:07:38 <lukeh> aoeu :)
11:07:45 <lispy> dvorak++
11:07:46 <shapr> lukeh: Or I should have said How'd you guessL
11:07:46 <xerox> @slap shapr
11:07:47 <SamB> sjanssen: that was me explaining why I thought Parsec was the best thing since sliced bread
11:07:47 * lambdabot beats up shapr
11:07:50 <glguy> left hand home row
11:08:09 <shapr> lukeh: Since 1992
11:08:17 <CosmicRay> I tried a dvorak layout once.  the most maddening computer experience I've had in a long time.  my productivity nosedived as my typing speed went from >100wpm to like 20
11:08:25 <CosmicRay> I'm sure if I had stuck with it, i'd be fine, but I just couldn't.
11:08:38 <shapr> CosmicRay: Hey use what works for you.
11:08:47 <lukeh> I've used it since 2000 or so, now I type faster than I used to
11:08:48 <glguy> When I want to mess with my girlfriend or coworkers, I switch to dvorak (my capslock and control key are already switched)
11:08:56 <shapr> Still, since I learned dvorak, qwerty users look like they're jumping all over the keyboard to get not so much typed.
11:08:56 <lukeh> ...even when programming
11:09:21 <lukeh> I feel like I'm jumping all over the kbd when I type qwerty now
11:09:21 <shapr> Yeah, I learned dvorak before I learned emacs, happily for me.
11:09:53 <glguy> Emacs is nice, but I prefer Linux
11:10:01 <shapr> I like House.
11:10:03 <lukeh> control keys are the only things that are difficult when first learning, because you have to rely upon your memory of the key mapping rather than your spatial memory.
11:10:20 <lukeh> SamB: I just jumped in on this conversation, what do you mean about Haskell being imperative?
11:10:29 <shapr> lukeh: I also switched to a kinesis keyboard and I use my "I am not a koala" customized layout.
11:11:02 <lukeh> tried kinesis, didn't like it much for programming.  Symbol keys are in weird places.
11:11:13 <glguy> lukeh: code inside a do is imperitive, but his quote was emphasizing "first-class"
11:11:18 <lukeh> shapr: "I am not a koala"?
11:11:20 <SamB> lukeh: Haskell is the only language I know where I can pass around groups of statements as values
11:11:44 <sjanssen> first class actions are sexy
11:11:53 <lukeh> SamB/glguy: ah, comprendez
11:12:03 <glguy> SamB: what about lisp?
11:12:10 <SamB> well, I mean, I suppose you could claim that lambdas are that way...
11:12:20 <lukeh> glguy: I second that question...
11:12:23 <shapr> lukeh: Yeah, I shouldn't be holding down modifier keys with my pinky. Koalas have two thumbs, I do not.
11:12:24 <SamB> (in things like LISP...)
11:12:42 <shapr> lukeh: So I moved all of my modifier keys under my thumbs.
11:13:04 <shapr> You can really do that with a kinesis - http://www.kinesis-ergo.com/images/adv_wht.jpg
11:13:06 <glguy> I guess anonymous delegates (c#) and function pointers (c) are not first class?
11:13:09 <lukeh> shapr: How long did it take you to adjust to that?
11:13:16 <SamB> but I dunno if I even think LISP counts as FP...
11:13:35 <shapr> lukeh: Day and a half at most, but I adjust my keyboard regularly so I can stay adaptable.
11:13:48 <lukeh> shapr: nice.
11:13:52 <SamB> Haskell just makes it looks so *EASY*
11:14:04 <sjanssen> glguy: how can you create a new action that executes two actions in sequence in C?
11:14:20 <shapr> lukeh: I have purpose specific keys mapped as well, following Jef Raskin's Humane Interface ideas.
11:14:22 <glguy> sjanssen: with delegates
11:14:29 <mauke> glguy: C doesn't have delegates
11:14:32 <glguy> OH
11:14:34 <glguy> sorry
11:14:39 <glguy> I thought you said C#
11:14:43 <glguy> I didn't read close enough
11:14:43 <shapr> I have IrcKey, DiskKey, KillKey, SwapKey, etc
11:15:02 <mauke> sjanssen: I allocate a buffer and write custom machine code to it, then I cast it to a function pointer!
11:15:07 <mauke> what do I win?
11:15:18 <SamB> mauke: a daredevil prize!
11:15:27 <glguy> What does your DiskKey do?
11:15:29 <SamB> also, a portability nightmare!
11:15:29 <sjanssen> mauke: and when you're done with this action?
11:15:32 <lispy> @pl \x y -> x:[y]
11:15:32 <lambdabot> (. return) . (:)
11:15:34 <lukeh> shapr: so you don't have 2 thumbs but you have 30 fingers??
11:15:51 <mauke> sjanssen: then I free it
11:16:07 <kpreid> What's the difference between Data.Set.elems and Data.Set.toList?
11:16:23 <xerox> ?docs Data.Set
11:16:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
11:16:25 <monochrom> @pl \x -> h (f x) (g x)
11:16:26 <SamB> lukeh: he means he doesn't have two thumbs on each hand...
11:16:26 <lambdabot> liftM2 h f g
11:16:30 <glguy> > elems (Data.Set.fromList [1,1])
11:16:30 <lambdabot>  Not in scope: `Data.Set.fromList'
11:16:42 <xerox> ?fptools Data.Set
11:16:42 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
11:16:49 <SamB> just the ones on the inside edges
11:16:57 <xerox> elems :: Set a -> [a]
11:16:57 <xerox> elems s
11:16:57 <xerox>   = toList s
11:16:58 <xerox> hehe
11:17:01 <lispy> ?quote shapr
11:17:03 <lambdabot>  I encourage my competitors to use Windows.
11:17:10 <lispy> heh
11:17:27 <shapr> glguy: DiskKey is http://www.emacswiki.org/cgi-bin/wiki/DiskKey
11:17:29 <lambdabot> Title: EmacsWiki: DiskKey
11:17:38 <monochrom> @pl \x -> op (f x) (op (g x) (h x))
11:17:39 <lambdabot> liftM2 op f (liftM2 op g h)
11:18:01 <SamB> what does the IrcKey do? come up with a witty comment and send it?
11:18:08 <monochrom> @pl \x -> f x ++ (g x  ++ h x)
11:18:09 <lambdabot> liftM2 (++) f (liftM2 (++) g h)
11:18:13 <monochrom> Nice.
11:18:36 <lispy> @hoogle (a,a) -> [a]
11:18:37 <lambdabot> No matches, try a more general search
11:19:01 <shapr> SamB: Nah, connect to irc (and join my standard channels), or reconnect to irc, or swap to a channel that has activity I haven't viewed yet.
11:19:05 <mauke> @pl \(a,b) -> [a,b]
11:19:06 <lambdabot> uncurry ((. return) . (:))
11:19:25 <SamB> oh, yeah, you are one of the people who disconnects from IRC
11:19:27 <lispy> @type concatMap (\(x,y) -> [x,y])
11:19:28 <lambdabot> forall b. [(b, b)] -> [b]
11:19:38 <glguy> You can disconnect from IRC?
11:19:49 <lispy> glguy: it hurts :(
11:19:50 <glguy> I thought that that meant that the person was dead
11:19:52 <shapr> SamB: Hey, I keep moving to other countries and I don't run irc in a screen session on my virtual server.
11:19:58 <shapr> lispy: hah
11:20:06 <shapr> lispy: Oh hey, I like your haskell testing post.
11:20:13 <lispy> shapr: thanks
11:20:21 <shapr> I had some thoughts/comments on that post, but I don't remember what they were...
11:20:33 <lispy> shapr: if you do let me know
11:20:36 <shapr> I will.
11:20:56 <lispy> it's been working great for me so far
11:21:03 <shapr> Yay, looks like I will be at Haskell Workshop after all.
11:21:25 <shapr> Lemmih: I'll get to see you again! Are you bringing your unicycle this time?
11:21:33 <glguy> I should probably get some work done today...
11:21:43 <Lemmih> shapr: That's great!
11:21:43 <shapr> me too.
11:21:52 <shapr> Lemmih: Hey, did you get a mic?
11:21:57 <Lemmih> shapr: If I can bring it for free, yes.
11:22:06 <shapr> Will yours fit in your luggage?
11:22:07 <Lemmih> shapr: Alas, no.
11:22:09 <glguy> Lines of code isn't a very good indicator of progress, unless it's 0
11:22:14 <shapr> Mine won't, unsurprisingly.
11:22:31 <shapr> glguy: Even then, lots of thrown away code could still be progress of understanding.
11:22:39 <SamB> yeah, if you have one line of code it might be the program!
11:22:42 <SamB> hmm, hehe
11:22:48 <Lemmih> shapr: Do you have experience with FreeBSD, btw?
11:22:58 <shapr> Nope, why?
11:23:16 <Lemmih> I might rent a server with BSD on it.
11:23:31 <glguy> OpenBSD for the win ;)
11:24:02 <monochrom> @pl \x -> liftM2 op (f x) (g x)
11:24:02 <Lemmih> I'm off to see my brother. Cya later.
11:24:03 <lambdabot> ap (liftM2 op . f) g
11:24:07 <shapr> cya
11:24:11 <monochrom> Ha! Interesting!
11:24:47 <Lemmih> (shapr: I'm really glad I get to see you again.)
11:25:47 <monochrom> But I don't like ap (liftM2 op . f) g, it's asymmetric.  I prefer liftM2(liftM2 op) f g
11:26:57 <monochrom> > (liftM2 (:) head tail) "hello"
11:26:59 <lambdabot>  "hello"
11:28:38 <glguy> ap f g == liftM2 f id g
11:28:43 <glguy> i think
11:30:04 <glguy> in J, liftM2 and ap can be used implicitly :)
11:32:56 <monochrom> @type uncurry (curry (++))
11:32:58 <lambdabot>   Couldn't match `[a]' against `(a1, b)'
11:32:58 <lambdabot>    Expected type: (a1, b) -> c
11:33:14 <glguy> @type curry (uncurry (++))
11:33:15 <lambdabot> forall a. [a] -> [a] -> [a]
11:33:38 <_dolio> ?pl curry . uncurry
11:33:39 <lambdabot> id
11:33:39 <monochrom> @pl \(x,y) -> op x y
11:33:40 <lambdabot> uncurry op
11:33:57 <tibbe> ?type op
11:33:59 <lambdabot> Not in scope: `op'
11:36:35 <tibbe> @type 5 :: a
11:36:37 <lambdabot>   No instance for (Num a)
11:36:37 <lambdabot>    arising from the literal `5' at <interactive>:1:0
11:36:53 <tibbe> @type (5 :: Int) :: a
11:36:54 <lambdabot>   Couldn't match the rigid variable `a' against `Int'
11:36:55 <lambdabot>    `a' is bound by the polymorphic type `forall a. a' at <interactive>:1:0-14
11:37:06 <tibbe> hmm
11:37:19 <SamB> tibbe: what are you doing?
11:37:29 <tibbe> in the wobbly types paper they have an eval Term -> a function
11:37:39 <tibbe> and then they return an Int
11:37:43 <tibbe> how does that work
11:37:47 <SamB> wasn't it...
11:37:55 <SamB> eval :: Term a -> a ?
11:38:00 <tibbe> yes
11:38:17 <tibbe> data Term a = Lit :: Int -> Term Int
11:38:25 <SamB> well, see...
11:38:25 <tibbe> eval (Lit i) = i
11:38:34 <SamB> they case into it...
11:38:34 <lispy> if you do a qualified import of an operator what is the syntax to call it
11:39:16 <tibbe> to me it seems like they are returning something that's "less" than an a namely an Int
11:39:26 <SamB> basically, since the (Lit i) must be of type (Term Int)...
11:39:33 <SamB> you get to return an Int
11:39:33 <tibbe> yes
11:39:37 <tibbe> but the RHS
11:39:43 <lispy> oh, n/m
11:39:57 <tibbe> but why doesn't @type (5 :: Int) :: a work then
11:40:08 <tibbe> if eval :: Term a -> a
11:40:16 <tibbe> can return an Int instead of an a
11:40:32 <SamB> but, see, the Lit proves that the type of the term is Term Int, so that a is Int...
11:40:56 <tibbe> I can see how we can statically guarantee that i is an Int
11:41:11 <tibbe> but so would my @type expression
11:41:24 <tibbe> since I've explicitly added a signature that says that it is
11:42:02 <SamB> well, I don't fully understand the math, but I can say that it only works because of the relationship between the type of the term and the type of the result...
11:42:25 <SamB> I mean, you never complain about [a] -> a being able to return an Int when you pass it a [Int]...
11:42:43 <tibbe> hmm, I think I understand
11:42:59 <SamB> hmm, by [a] -> a I meant head :: [a] -> a...
11:43:11 <tibbe> so we can return the i because we know that we got an a in so we can pass and a out forall a
11:43:19 <SamB> the GADT does of course do more, but that is kinda the point of GADTs ;-)
11:44:00 * tibbe fetches some desert, it helps my thinking, really...
11:44:16 <SamB> hmm... do you mean dessert?
11:44:25 <tibbe> probably ;)
11:44:38 <sieni> he probably lives in egypt and literally goes to fetch a bucket of sand
11:44:46 <tibbe> I blame the fact that I'm lying in a sofa
11:44:55 <tibbe> sieni: :p
11:45:07 <tibbe> an intellectual desert of sorts
11:45:08 <SamB> sieni: it doesn't usually taste very good, though!
11:45:10 <tibbe> ;)
11:47:01 <shapr> Lemmih: thanks!
11:47:12 <shapr> grr, silly computers
11:51:11 <ventonegro> argh
11:51:17 <ventonegro> how do I get a state back?
11:52:01 <monochrom> @pl liftM2 (op f) h t
11:52:02 <lambdabot> liftM2 (op f) h t
11:52:06 <Templar> anyone knows if there is any "clear screen"(cls) command for irc?
11:52:07 <monochrom> @pl \f -> liftM2 (op f) h t
11:52:08 <lambdabot> flip (flip liftM2 h . op) t
11:52:13 <xerox> ventonegro: "a state" ?
11:52:26 <monochrom> @pl \f -> uncurry (op f) (h &&& t)
11:52:27 <lambdabot> flip uncurry (h &&& t) . op
11:52:37 <ventonegro> xerox, from Control.Monad.State
11:52:46 <xerox> > runState (do { x <- get; modify (+1); y <- get; return (x+y) }) 1
11:52:47 <lambdabot>  (3,2)
11:52:47 <tibbe> Templar: Alt + F4
11:52:59 <sieni> Templar: depends on the client, but e.g. /clear might work
11:53:08 <Templar> nice
11:53:11 <Templar> thx
11:53:21 <monochrom> @pl \f -> uncurry (op f) . (h &&& t)
11:53:21 <lambdabot> (. (h &&& t)) . uncurry . op
11:53:22 <tibbe> works on XChat
11:53:33 <monochrom> Yucky, but should work.
11:53:34 <Templar> just started with haskell so will come back with tons of questions soon :P
11:54:02 <tibbe> monochrom: sometimes I resist using the pl form, if it obfuscates too much
11:54:07 <tibbe> Templar: sure
11:54:14 <xerox> ventonegro: if do you need an action to get the state inside a stateful computation, that is get.  If you need to run a stateful computation and get the final state, that's evalState.
11:54:21 <monochrom> Oh it obfuscates. :)
11:54:56 <xerox> monochrom: do not listen, it's lies!
11:55:09 <tibbe> calling a style with a lot of dots pointless is a bit funny I think
11:56:05 <tibbe> when @pl starts to produce alot of flips then I usually don't use it
11:56:10 <ventonegro> xerox, since you are helping... :-)
11:56:16 <ventonegro> luaClose :: LuaState ()
11:56:20 <ventonegro> luaClose = rawLuaClose $ get
11:56:37 <ventonegro> this is not working with Couldn't match `State PtrLuaState ()' against `()'
11:56:54 <monochrom> Please wish me luck
11:56:55 <xerox> ventonegro: what's the type of rawLuaClose ?
11:56:57 <tibbe> I was really baffled yesterday how effective Haskell text processing can be. my haskell program was only slightly longer than my sed and awk
11:57:01 <xerox> Good luck monochrom.
11:57:06 <monochrom> danke
11:57:09 <ventonegro> rawLuaClose:: PtrLuaState -> ()
11:57:31 <xerox> ventonegro: I am not sure what do you want to do.
11:57:45 <ventonegro> rawLuaClose is a FFI function
11:57:59 <ventonegro> void lua_close(lua_State* L);
11:58:00 <xerox> Oh I see.
11:58:15 <ventonegro> and I want a nicer monadic version, luaClose
11:58:19 <xerox> liftM rawLuaClose get
11:58:29 <ventonegro> this works: luaOpen = put rawLuaOpe
11:58:32 <xerox> That should work if I understand correctly.
11:58:56 <ventonegro> hum, let me see this liftM :-)
11:59:04 <ventonegro> (second week of haskell here)
11:59:18 <xerox> liftM = fmap = \f amb -> do { x <- amb; return (f x) }
12:00:01 <xerox> ?type liftM
12:00:02 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:00:07 <tibbe> ?type fmap
12:00:08 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:00:44 <xerox> You've got a 'm PtrLuaState' and you want a 'm ()', liftM takes a function PtrLuaState -> (), and gets the former to the latter.
12:00:55 <ventonegro> xerox, yes, it's compiled
12:00:58 <ventonegro> thanks :-)
12:01:06 <xerox> You're welcome.
12:01:16 <emu> does that OPTIONS_GHC pragma thing still work
12:02:37 <emu> or does it not apply to the linker
12:07:44 <ventonegro> main = do {luaOpen, luaClose; return ()}
12:07:52 <ventonegro> Couldn't match `IO' against `Control.Monad.State.State PtrLuaState'
12:07:54 <ventonegro> :-(
12:08:12 <roconnor> @dice 1d142
12:08:12 <lambdabot> 1d142 => 71
12:08:17 <xerox> You've used a , while you need to use a ;.
12:08:31 <ventonegro> actually each one is in a line
12:08:38 <ventonegro> i changed to put it here
12:09:06 <ventonegro> ?paste
12:09:06 <lambdabot> http://paste.lisp.org/new/haskell
12:10:21 <lisppaste2> ventronegro pasted "Lua interface" at http://paste.lisp.org/display/25661
12:12:09 <cjeris> @dice 3d6, 3d6
12:12:09 <lambdabot> unexpected ",": expecting digit, "+" or end
12:12:17 <xerox> ventonegro: right, main is plainly wrong.
12:13:03 <cjeris> 13,13,11,10,12,12 ... that's pretty mediocre :p
12:13:11 <ventonegro> why?
12:13:16 <xerox> ventonegro: you need to run the stateful computation inside the IO one.
12:13:20 <xerox> ?type runState
12:13:21 <lambdabot> forall s a. State s a -> s -> (a, s)
12:13:48 <int-e> @dice d8+d13
12:13:49 <lambdabot> unexpected "d": expecting number
12:13:49 <xerox> This will run your LuaState () computation, with initial state s, and return a tuple (the result and the final state).
12:13:59 <int-e> @dice 1d8+1d13
12:14:00 <lambdabot> 1d8+1d13 => 4
12:14:36 <xerox> @slap int-e
12:14:36 * lambdabot smacks int-e about with a large trout
12:14:51 <int-e> keep those trouts to yourself.
12:15:00 <xerox> @botsnack
12:15:00 <lambdabot> :)
12:15:06 <xerox> (The trout)
12:16:30 <int-e> @. elite quote xerox
12:16:31 <lambdabot> y0U KNOW, B3FuN9E i5 PrOBAb1y The onlY |aNGuage I'v3 Se3n WHEr3 joo caN rUn cODe pAST3D phrOM ir( WItH tH3 <nI(k> tA9S ztILl In p|4(3 ;-)
12:16:32 <ventonegro> xerox, so i'll have to pass the state variable around?
12:16:54 <xerox> ventonegro: nope. Sorry I have to dash, maybe someone else will be able to help you now :(
12:17:07 <ventonegro> xerox, thank you very much :-)
12:17:22 <sieni> @. elite quote sieni
12:17:23 <lambdabot> SCh3/\/\E ADHEr3z tO th3 TImTobphT+WTDi PRiN(iP|E Inz7E4d Oph 7imtO\/\/7DI
12:17:38 <sieni> @. elite quote sieni
12:17:39 <Cale> heh, apparently my friend's Ph.D. supervisor will only be around for a few hours every three weeks.
12:17:39 <lambdabot> 7HE ADvAn+49e oph H4$K3Ll I$ THA7 iT D03sn'T SUxx
12:18:12 <Cale> @quote sieni
12:18:12 <lambdabot>  C provides people with the expressiveness of fortran combined with the portability of assembler
12:18:15 <Cale> @quote sieni
12:18:16 <lambdabot>  C provides people with the expressiveness of fortran combined with the portability of assembler
12:18:17 <Cale> @quote sieni
12:18:18 <lambdabot>  python, like php, is just training wheels without the bike
12:18:20 <Cale> @quote sieni
12:18:21 <lambdabot>  the advantage of haskell is that it doesn't suck
12:18:23 <Cale> @quote sieni
12:18:24 <lambdabot>  C provides people with the expressiveness of fortran combined with the portability of assembler
12:18:44 <Cale> It would be nice if it tried to avoid repeats :)
12:18:48 * musasabi thinks Haskell sucks in an elegant, functional and very satisfying manner
12:19:14 <Cale> @quote sieni
12:19:14 <lambdabot>  python, like php, is just training wheels without the bike
12:19:26 <Cale> @quote sieni
12:19:26 <lambdabot>  python, like php, is just training wheels without the bike
12:19:41 <Cale> I'm trying to get the scheme quote :)
12:20:03 <Cale> Ah, scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
12:20:23 <int-e> right, just look at http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
12:20:32 <Cale> yeah
12:23:26 <lukeh> A question for the floor: I am familiar with functional programming constructs and concepts, and I have done some programming in Scheme and Haskell, but I haven't followed the Haskell world for a few years.  What is the best way to get up to speed quickly?  i.e. what are the best resources?
12:24:02 <Cale> This one, the wiki(s) and the mailing lists?
12:24:30 <Cale> If you need a tutorial, YAHT is good, though you sound like you already know the language to some extent
12:24:59 <monochrom> Re-visit www.haskell.org
12:25:34 <int-e> @quote desrt
12:25:35 <lambdabot>  man... there's this whole dark side to haskell that dr. kahl didn't teach us in 3e03
12:30:34 <glguy> 83/* :-D
12:30:45 <ihope> @hoogle deepSeq
12:30:46 <lambdabot> No matches found
12:30:47 <ihope> Mmh.
12:31:09 <ventonegro> ?type get
12:31:11 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
12:32:25 <int-e> @index rnf
12:32:26 <lambdabot> Control.Parallel.Strategies
12:32:40 <glguy> ventonegro: if you are using MonadState, don't forget about gets and modify
12:33:18 <ventonegro> ?type modify
12:33:19 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
12:33:22 <int-e> rnf is deepSeq, more or less.
12:34:02 <ventonegro> this modify seems useful
12:34:20 <glguy> gets returns the value of a function on the state, and modify updates the state with the results of the function on the state
12:34:26 <monochrom> very useful.  saves a lot of put's and get's
12:34:42 <int-e> and adds a ton of potential lazyness problems.
12:34:50 <ventonegro> i chose to learn FFI and Monads at once
12:34:56 <ventonegro> no wonder i'm suffering
12:35:05 <monochrom> Ha darn.
12:35:38 <ventonegro> the problem now is that newCstring only gives me a IO CString
12:35:57 <ventonegro> i don't want that IO, damnit! :-)
12:36:43 <int-e> . o O ( modify' f = modify f >>= get >>= (`seq` return ()) )
12:38:39 <shapr> SHAZAM!
12:38:40 <int-e> ventonegro: is what you're doing there safe outside IO? If there are side effects you probably want to stay inside IO.  If you're sure that it's safe you can wrap your IO code for marshalling in an unsafePerformIO
12:39:42 <ventonegro> int-e, the majority of cases yes, only the lua_State state will be changed
12:39:57 <ventonegro> but if the Lua script has IO, so some IO will be performed
12:40:11 <ventonegro> ?type unsafePerformIO
12:40:13 <lambdabot> Not in scope: `unsafePerformIO'
12:40:51 <int-e> @index unsafePerformIO
12:40:52 <lambdabot> System.IO.Unsafe, Foreign
12:41:04 <int-e> @type Foreign.unsafePerformIO
12:41:05 <lambdabot> forall a. IO a -> a
12:41:15 <int-e> anyway, that does sound seriously unsafe.
12:41:59 <ventonegro> what's the definition of safe? not breaking monad laws?
12:42:16 <int-e> not breaking referential transparency.
12:42:39 <ventonegro> i see
12:43:07 <dwm> Is those the same but the one is System.io.Unsafe is the newer namespacing?
12:43:15 <dwm> er, ARE those the same
12:45:05 <int-e> in fact I suspect you should bind your primitives as IO actions. (rawLuaOpen :: IO PtrLuaState  etc.) I suspect Haskell is free to sare the results otherwise if it finds the arguments are the same.
12:45:37 <int-e> actually I'm quite sure.
12:45:47 <ventonegro> int-e, i was trying to avoid have to pass PtrLuaStates around
12:46:42 <int-e> Yu can do that. You can wrap a monad around IO for that, like StateT (a monad transformer).
12:46:47 <int-e> @index StateT
12:46:48 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
12:47:23 <int-e> @type return () :: Control.Monad.State.StateT Int IO ()
12:47:25 <lambdabot> Control.Monad.State.StateT Int IO () :: StateT Int IO ()
12:47:51 <ventonegro> hum...
12:48:11 <ventonegro> i guess i must increase my haskell powers before :-)
12:48:19 <int-e> but if you're just learning monads that may not be the best example to start with :)
12:49:14 <ventonegro> heh
12:51:28 <glguy> int-e: what laziness issues does modify introduce?
12:52:18 <glguy> turns the state into a thunk?
12:52:21 <int-e> modify is lazy. let me try to give an example where that's problematic
12:52:49 <glguy> int-e: so are you saying that using get and put is not lazy?
12:52:58 <int-e> imagine you want to have a monad in which you basically do some computations, but you also want to keep track of the number of evaluation steps.
12:53:06 <int-e> no, put and get are lazy, too.
12:53:21 <glguy> oh, so the State monad in general introduces laziness issues?
12:53:30 <glguy> (I'm imagining )
12:53:40 <int-e> So you use a   State Int   monad,   with the primitive   step = modify (1+)
12:53:57 <int-e> and use it on some large computation using runState (computation) 0
12:54:02 <glguy> ok
12:54:30 <int-e> what happens it that instead of incrementing the counter, the program builds a huge unevaluated expression,
12:54:35 <int-e> 1+1+1+1+.....+0
12:54:56 <glguy> so... modify (ap seq (1+)) ?
12:55:02 <int-e> then when you evaluate the counter, you'll likely get a stack overflow if the expression was really big.
12:55:09 <int-e> it also costs memory.
12:55:24 <glguy> ?type modify (ap seq (1+))
12:55:26 <lambdabot> forall a (m :: * -> *). (MonadState a m, Num a) => m ()
12:55:35 <int-e> using seq is a good idea, but trying to use it with modify will fail
12:56:24 <int-e> step = get >>= \x -> put $! (1+x)  works.
12:56:51 <int-e> the difference is that with modify there's still no operation there that requires the new state to be forced
12:57:12 <glguy> int-e: but as long as you are also using gets and using the state during the computation
12:57:15 <int-e> so the only effect you get is that you build an even bigger expression that involves calls to seq besides the additions.
12:57:15 <glguy> it should be ok?
12:57:24 <int-e> glguy: right.
12:57:41 <glguy> so what we need is a modify'
12:58:19 <int-e> yes, which can be implemented with put and get: modify' f = get >>= (put $!) . f
12:58:43 <shapr> GHC has some truly priceless error messages: "You can get a PhD for explaining the True Meaning of this last construct" "Can't happen" "TELL SIMON: evalAbsence" "Urk infer" "even with cunning newtype deriving the newtype is recursive"
12:58:44 <int-e> in a sense, modify is inherently lazy, while with put and get some strictness can be recovered.
13:03:14 <int-e> glguy: did that make sense?
13:03:30 <glguy> sure
13:04:01 <glguy> just by using modify, the strictness function would be inside "f"
13:04:09 <glguy> as you wrote your version
13:04:19 <glguy> and would not be called until it was forced to
13:04:23 <glguy> thus.. lazy
13:04:54 <ventonegro> ?type liftM
13:04:56 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
13:05:19 <glguy> @index liftIO
13:05:20 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:05:24 <glguy> @type liftIO
13:05:26 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
13:06:28 <glguy> I'm not old or new, I'm middle school
13:07:05 <int-e> @type lift
13:07:07 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:07:21 <glguy> What is MonadTrans?
13:07:29 <int-e> so many lift functions, so much happiness
13:07:36 <glguy> @instances-importing MonadTrans
13:07:37 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
13:07:40 <glguy> oh
13:07:42 <glguy> nvm
13:08:59 <ventonegro> heh
13:09:07 <glguy> lift make so many other functions superfluous
13:09:14 <ventonegro> it was lift I was looking for
13:09:18 <glguy> lift* that is
13:09:49 <cjeris> shapr: my favorite ever is from TeX: "I'm broken. Please show this to someone who can fix can fix"
13:10:35 <int-e> wasn't there a 'TeX capacity exceeded. Please ask a wizard to enlarge me.', too?
13:12:48 <cjeris> int-e: Yes, but IIRC modern versions of TeX no longer have the statically determined table sizes.
13:13:36 <cjeris> (It used to be you would have two binaries 'tex' and 'bigtex', the latter reserved for bigger jobs, and allocating larger string and symbol pools on startup.)
13:14:29 <int-e> yep. I remember that.
13:15:53 <int-e> well, the message is still in the tex.pool file.
13:15:58 <int-e> (here)
13:17:57 <int-e> also cute: 'I can only go up to 2147483647='17777777777="7FFFFFFF, so I'm using that number instead of yours.'
13:20:41 <int-e> heh, there's also a reference to Pandora's box in there.
13:22:20 <lispy> shapr: nice
13:22:42 <lispy> shapr: darcs has error messages about the impossible happening :)
13:26:56 <ihope> int-e: what's that?
13:27:10 <ihope> The 2147483647 thing?
13:27:16 <int-e> a tex message
13:27:24 <ihope> @type 3 :: Int
13:27:26 <lambdabot> Int :: Int
13:27:39 <ihope> I see that that bug's still in there.
13:27:54 <ihope> @type 3 :: forall a. Integral a => a
13:27:56 <lambdabot> forall a. Integral a => a :: forall a. (Integral a) => a
13:28:07 <ihope> @type 3 :: forall a. Integral a => a
13:28:09 <lambdabot> forall a. Integral a => a :: forall a. (Integral a) => a
13:28:11 <ihope> Erm.
13:28:16 <ihope> @type 3 :: forall a. (Integral a) => a
13:28:17 <lambdabot> forall a. (Integral a) => a :: forall a. (Integral a) => a
13:28:29 <ihope> Eh, so, um.\
13:28:35 <int-e> @type let x :: Int; x = 3 in x
13:28:37 <lambdabot> Int; x = 3 in x :: Int
13:28:48 <int-e> fun.
13:28:56 <lispy> neato
13:29:00 <lispy> what causes that?
13:29:15 <ihope> Well, GHC outputs
13:29:18 <ihope> ...
13:29:25 <ihope> Well, GHC outputs "let x :: Int; x = 3 in x :: Int", I think.
13:30:04 <ihope> Instead of throwing away "let x :: Int; x = 3 in x :: " and leaving "Int", it throws away "let x :: ", leaving "Int; x = 3 in x :: Int".
13:30:52 <shapr> I haven't been in the US in six years, it's hard to readjust in some ways.
13:32:10 <cjeris> shapr: are you from US originally?
13:35:00 <glguy> additionally... where were you prior to returning?
13:36:04 <lispy> shapr: why are you in the US?
13:36:14 <lispy> shapr: i mean...if you got out, why come back? ;)
13:39:46 <monochrom> Because it's a free country! :)
13:40:47 <lispy> yes, but lately d(freedom)/dt has been negative :(
13:41:19 <cjeris> and also d^2(freedom)/dt^2
13:41:19 <glguy> oh no you don't, this isn't #uspolitics :op
13:42:39 <monochrom> So, shapr, may I ask what you do in the US?
13:42:47 <glguy> If I want to hear about hwo bad the US is, I'll continue listening to NPR
13:42:56 <ihope> @docs System.IO
13:42:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
13:43:14 <lispy> glguy: okay, i dropped it so don't tempt me :)
13:43:24 <ihope> @hoogle removeFile
13:43:25 <lambdabot> Directory.removeFile :: FilePath -> IO ()
13:43:33 <ihope> @docs Directory
13:43:33 <lambdabot> Directory not available
13:43:50 <ihope> @index removeFile
13:43:51 <lambdabot> System.Directory, Distribution.Compat.Directory
13:43:56 <ihope> Ere we go.
13:44:05 <ihope> @docs System.Directory
13:44:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html
13:54:42 <ihope> Hmm...
13:54:53 <shapr> cjeris: Yeah, I'm from Alabama
13:54:55 <shapr> lispy: I had to.
13:55:06 <shapr> monochrom: Same thing, contract programming.
13:55:27 <shapr> glguy: I was in Sweden the last few years, and Finland a few years before that. Total time living outside the US is seven years.
13:55:43 <stepcut> shapr: are you back in the united states of america now ?
13:55:47 <shapr> yup
13:55:51 <stepcut> what part?
13:55:55 <shapr> Looking for contract work, preferably Haskell.
13:55:59 <shapr> I'm in Birmingham
13:56:14 <shapr> stepcut: Hey, do you get to go to ICFP along with the Linspire guy going to CUFP?
13:56:27 <stepcut> shapr: no :(
13:56:28 <shapr> aww
13:56:37 <stepcut> :p
13:56:39 <shapr> It seems I'll be in the area for Haskell Workshop, thought I might meet you.
13:57:34 <stepcut> no luck this year ;)
13:57:56 <shapr> stepcut: Where is Linspire?
13:58:00 <stepcut> San Diego
13:58:01 <shapr> Anywhere close to the southeast usa?
13:58:02 <shapr> oh
13:58:19 <shapr> Well, if you guys are hiring...
13:58:21 <stepcut> very close to south*west* :)
13:58:54 <glguy> you sure mention staying in southeast usa a lot, do you have warrants in all the states bordering the southeast forcing you to avoid driving through them?
13:59:34 <shapr> No, just that I've been circulating in the southeast for decades: Florida, Alabama, Kentucky, Tennessee, Virginia, etc
13:59:39 <shapr> So I know those states well.
13:59:57 <shapr> Thus I am willing to drive a few hours to hang out with people for a coupla days.
14:00:28 <shapr> So if I can find enough Haskellers nearby, I'll try to get them to all meet in the same place.
14:00:44 <shapr> That's been successful twice so far with EuroHaskell and AngloHaskell.
14:03:23 <shapr> @map
14:03:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:03:29 <glguy> What might it mean when someone tells you that you "look like you've been holding coffee all your life" when you walk by them
14:03:52 <glguy> (with coffee of course)
14:05:21 <cjeris> glguy: way back in WW1 it was said that flying aces all developed a characteristic look, tight-drawn rictus grins, eternal shaking tension in their fingers, ...
14:41:32 <lispy> reading C++ is hard
14:42:08 * weitzman scrolls up the IRC history to find that line that uses the "fix" function
14:42:10 <shapr> What's the best wifi card I can buy for Linux?
14:42:10 <yip> woohoo, it's c++ bashing hour again!
14:42:11 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
14:42:18 <shapr> oh I do?
14:42:42 <monochrom> It's very cool, weitzman.
14:42:44 <lispy> yip: yup...they're even using strtok *cringe*
14:42:59 <monochrom> strtok is 31337
14:43:10 <lispy> they call this c++ but they use all the most evil C functions
14:43:41 <monochrom> I once asserted, "if you don't know how to use strtok, you don't know the standard C library, meaning you don't know standard C."  :)
14:44:34 <yip> strtok is very evil
14:44:40 <weitzman> For the record, the line I'm thinking of:
14:44:41 <weitzman> fix (\f xs -> let h = head xs; t = tail xs in guard (not $ null xs) >> (f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f(t >>= \x -> guard (x>=h) >> [x]))) [5,4,3,2,1]
14:44:47 <lispy> appear to not use C++ string but instead use CStringArray
14:45:00 <glguy> weitzman: why are you quoting my quicksort ? :-)
14:45:04 <lispy> bleh...non-standard blah!
14:45:04 <weitzman> Now I don't claim to be a Haskell expert
14:45:13 <weitzman> In fact
14:45:17 <weitzman> I'm defintely not
14:45:28 <weitzman> And I'm going to call that unreadable
14:45:38 <glguy> it's not supposed to be readable
14:45:44 <weitzman> I guessed as much
14:45:44 <dmhouse> weitzman: that could be rendered a lot more readable than that, though.
14:46:04 <glguy> I typed it in in a single go... I didn't try to make it pretty
14:46:18 <monochrom> Well it's all merged into one line.  If you break it into a few more lines, indent a bit, turn some of those >>= into do-notation or list-comprehension, you're good.
14:46:20 <weitzman> Although I looked a bit at Okasaki's purely functional data structures
14:46:28 <weitzman> Which I find hard to grok
14:46:33 <weitzman> Despite not being obfuscated
14:46:58 <weitzman> The persistent balanced real-time trees and such
14:47:06 <shapr> If you were looking at his amortized data structures you really want to understand laziness first.
14:47:42 <weitzman> I find in programming languages there are many levels of understanding
14:47:50 <shapr> Yeah, true.
14:48:01 <monochrom> I have solid proof that layout defines the difference between "unreadable" and "readable".
14:48:13 <weitzman> I can tell you what callcc does, but it's still going to take me a bit to understand code that uses it liberally
14:49:30 <dmwit> Wth does "wearing a hair shirt" refer to?
14:49:43 <dmwit> I mean, obviously it has to do with Haskell being lazy, but I just don't see the connection.
14:49:45 <monochrom> A shirt made of hair?
14:50:06 <monochrom> Haskell wears shirts?
14:50:21 <dmwit> A few papers I read refer to Haskell as wearing a hair shirt...
14:50:38 <shapr> "Wearing the the hair shirt" was a retrospective that Simon Peyton-Jones wrote.
14:50:44 <dmhouse> weitzman: sort (h:t) = sort [ x | x <- t, x < h] ++ [h] ++ sort [ x | x <- t, x >= h]
14:50:54 <dmhouse> weitzman: that's an alternative for the really unreadable thing you pasted.
14:51:08 <dmhouse> It defines an equivalent function. (Doesn't actually call it, though.)
14:51:10 <dmwit> Where did he come up with that name?
14:51:14 <shapr> And the hair shirt metaphor itself is about penitence, I believe.
14:51:41 <Cale> http://en.wikipedia.org/wiki/Cilice
14:51:43 <shapr> yup
14:51:43 <dmwit> Some kind of Biblical allusion?
14:52:09 <shapr> Nah, catholic
14:52:31 <glguy> > fix (\f xs -> guard (not $ null xs) >> (f [x | x <- tail xs, x < head xs] ++ [head xs] ++ f [x | x <- tail xs, x >= head xs])) [5,4,3,2,1]
14:52:32 <lambdabot>  [1,2,3,4,5]
14:52:55 <glguy> better?
14:53:00 <weitzman> Much
14:53:13 <glguy> but so boring.. eh?
14:53:15 <dmhouse> > let sort (h:t) = sort [ x | x <- t, x < h] ++ [h] ++ sort [ x | x <- t, x >= h] in sort [5,4,3,2,1]
14:53:17 <lambdabot>  Non-exhaustive patterns in function sort
14:53:23 <dmhouse> Ah, yes. Oops :)
14:53:35 <dmhouse> > let sort [] = []; sort (h:t) = sort [ x | x <- t, x < h] ++ [h] ++ sort [ x | x <- t, x >= h] in sort [5,4,3,2,1]
14:53:37 <lambdabot>  [1,2,3,4,5]
14:53:54 <dmwit> > reverse [5,4,3,2,1]
14:53:55 <lambdabot>  [1,2,3,4,5]
14:53:56 <dmwit> ;-)
14:53:58 <monochrom> > let sort = Data.List.sort in sort [5,4,3,2,1] {- dammit! -}
14:53:58 <weitzman> Is there a simple one-liner for bogosort in Haskell?
14:53:59 <lambdabot>  [1,2,3,4,5]
14:54:18 <weitzman> @hoogle Random
14:54:19 <lambdabot> Random :: module
14:54:19 <lambdabot> System.Random :: module
14:54:19 <lambdabot> System.Random.Random :: class Random a
14:54:23 <monochrom> What is bogosort?
14:54:32 <weitzman> Randomly permute the list, check if it's sorted
14:54:35 <weitzman> Repeat until done
14:54:36 <monochrom> Is it observationally equivalent to Data.List.sort?
14:54:42 <dmhouse> Anything involving random numbers tends to be a bit messy in Haskell.
14:54:51 <weitzman> Depends. Is Data.List.sort supposed to be stable?
14:54:55 <dmhouse> monochrom: surely all sorts should be observationally equivalent?
14:55:16 <monochrom> Perhaps running time is also an observation. :)
14:55:24 <shapr> hm
14:55:33 <lispy> bogosort?
14:55:44 <lispy> > sort [3,4,2,1,5]
14:55:45 <lambdabot>  [1,2,3,4,5]
14:55:55 <lispy> is that a one liner? ;)
14:56:11 <weitzman> @hoogle permute
14:56:12 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
14:56:13 <lambdabot> Distribution.GetOpt.Permute :: ArgOrder a
14:56:15 <Igloo> weitzman: Yes
14:56:20 <dmhouse> > let sort = sort in Data.List.sort [3,4,2,1,5]
14:56:21 <lambdabot>  [1,2,3,4,5]
14:56:43 <dmhouse> That's got worse space and time performance than this 'bogosort'.
14:56:44 <weitzman> @hoogle shuffle
14:56:45 <lambdabot> No matches found
14:57:11 <mauke> > fix (\f xs -> let (h : t) = xs in f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f (t >>= \x -> guard (x>=h) >> [x])) [5,4,3,2,1]
14:57:14 <lambdabot>  Exception: stack overflow
14:57:29 <mauke> ah, right
14:58:19 <weitzman> Haskell doesn't have a library function to randomly permute a list?
14:59:06 <weitzman> Oh, time for dinner
14:59:08 <weitzman> Ciao
14:59:08 <glguy> > random getStdGen
14:59:09 <lambdabot>  No IO allowed
14:59:16 <glguy> can lambdabot do random numbers?
14:59:28 <glguy> or rather, will it
15:02:18 <monochrom> > take 3 (randoms (mkStdGen 42))
15:02:20 <lambdabot>  Add a type signature
15:02:24 <monochrom> > take 3 (randoms (mkStdGen 42)) :: Int
15:02:25 <lambdabot>  Couldn't match `Int' against `[a]'
15:02:28 <monochrom> > take 3 (randoms (mkStdGen 42)) :: [Int]
15:02:30 <lambdabot>  [-1673289139,1483475230,-825569446]
15:02:40 <monochrom> I need a telepathic interface to my computer.
15:11:16 <mauke> argh, I'm an idiot
15:11:47 <mauke> > fix (\f xs -> do (h : t) = xs; f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f (t >>= \x -> guard (x>=h) >> [x])) [5,4,3,2,1]
15:11:48 <lambdabot>  Parse error
15:12:15 <mauke> > fix (\f xs -> do (h : t) <- xs; f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f (t >>= \x -> guard (x>=h) >> [x])) [5,4,3,2,1]
15:12:16 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
15:12:16 <lambdabot>    Expected...
15:12:28 <mauke> > fix (\f xs -> do (h : t) <- [xs]; f (t >>= \x -> guard (x<h) >> [x]) ++[h]++ f (t >>= \x -> guard (x>=h) >> [x])) [5,4,3,2,1]
15:12:29 <lambdabot>  [1,2,3,4,5]
15:12:37 <mauke> stupid guards
15:12:40 <inv2004> hi all
15:13:19 <inv2004> searching the way to split list into (begin_of_the_list and last_element)
15:13:37 <inv2004> like head:tail, but tail is the last of list
15:13:42 <mauke> @hoogle [a] -> ([a], a)
15:13:43 <lambdabot> No matches, try a more general search
15:14:18 <inv2004> found that last l gets the last
15:14:34 <inv2004> but what is the easiest way to get list without last ?
15:14:53 <mauke> > init [1,2,3,10]
15:14:54 <lambdabot>  [1,2,3]
15:15:07 <inv2004> init ? thx
15:15:16 <dmhouse> head is to tail as init is to last.
15:15:37 <inv2004> thx, I real need that
15:19:10 <inv2004> what is better than (init_val++[last_val]) and (init_val++(last_val:[])) ?
15:19:32 <inv2004> is there smth like ``:'', but for init and last ?
15:19:34 <chessguy> ok, i'm in hugs, trying to do filter isLower "Hello"
15:19:41 <chessguy> and it can't figure out what isLower is
15:19:48 <chessguy> Char.isLower doesn't work either
15:19:55 <dmhouse> inv2004: sadly not. The former's probably your best bet.
15:19:58 <dmhouse> chessguy: why not?
15:20:03 <inv2004> ok
15:20:03 <dmhouse> > filter isLower "Hello"
15:20:03 <Limbic_Region> do you have to specify the -glassext thingy
15:20:04 <lambdabot>  "ello"
15:20:12 <Limbic_Region> no
15:20:17 <Limbic_Region> that should be part of Prelude
15:20:25 <chessguy> dmhouse, i don't know, that's what i'm asking
15:20:26 <Limbic_Region> fwiw, I am going through YAHT now too
15:20:33 <dmhouse> Limbic_Region: thinking of -fglasgow-exts? :)
15:20:37 <Limbic_Region> yes dmhouse
15:20:41 <dmhouse> chessguy: what do you type, what does it give you?
15:20:50 * Limbic_Region is using ghc and the examples are working fine
15:21:09 <chessguy> i type: filter Char.isLower "Hello"
15:21:18 <chessguy> i get: ERROR - Undefined variable "isLower"
15:21:38 <Limbic_Region> so it isn't recognizing it as a function
15:21:49 <Limbic_Region> what about without the Char.
15:21:59 <chessguy> that's what i just said, that doesn't help
15:22:12 <Limbic_Region> doesn't help - meaning same error
15:22:15 <Limbic_Region> or different error
15:22:40 <chessguy> only difference is it says Undefined qualified variable
15:22:46 <Limbic_Region> what does filter (isLower) "Hello" produce
15:23:01 <chessguy> same thing
15:23:12 * Limbic_Region suggests you abandon hugs
15:23:17 <Limbic_Region> it can't compile anyway
15:23:18 <dmhouse> That's weird indeed.
15:23:21 <Limbic_Region> ;-)
15:23:28 <dmhouse> Yeah, I'd stick to GHCi these days.
15:23:41 <dmhouse> Unless you're on Windows, when WinHugs is probably the system of choice.
15:23:45 <dmhouse> ?hoogle isLower
15:23:46 <lambdabot> Char.isLower :: Char -> Bool
15:23:54 <chessguy> i am on windows
15:23:56 * Limbic_Region wanders back to YAHT
15:24:04 * Limbic_Region is also on Windows and compiled GHC from source
15:24:11 <Limbic_Region> but I am also a masochist
15:24:19 <dmhouse> ?tell ndm hoogle's still using the non-hierarchial modules. I can't remember whether you decided this was deliberate or not
15:24:20 <lambdabot> Consider it noted.
15:25:19 <chessguy> what are extensions?
15:25:32 <dmhouse> You don't need any here.
15:25:56 <dmhouse> They're basically extensions added to the language.
15:26:15 <mauke> @pl \c f x y -> f x `c` f y
15:26:15 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:26:18 <dmhouse> Some are only supported in GHC, some have reached a kind of 'unofficial standard' level of support.
15:26:29 <mauke> @pl \c f g x y -> f x `c` g y
15:26:29 <lambdabot> ((flip . ((.) .)) .) . (.)
15:27:06 <chessguy> > map isUpper "aBCde"
15:27:07 <lambdabot>  [False,True,True,False,False]
15:28:26 <chessguy> > length filter isLower "aBCde"
15:28:27 <lambdabot>    The function `length' is applied to three arguments,
15:28:27 <lambdabot>   but its type `[...
15:28:32 <Limbic_Region> leuse parens
15:28:36 <Limbic_Region> use parens even
15:28:51 <lispy> le use?
15:28:58 <Limbic_Region> length(filter isLower "aBCde")
15:29:02 <lispy> @bable fr en le use
15:29:03 <lambdabot>  uses
15:29:19 <chessguy> > length(filter isLower "aBCde")
15:29:21 <lambdabot>  3
15:29:30 <chessguy> > length(filter isLower "aBCdef")
15:29:31 <lambdabot>  4
15:29:38 <monochrom> @bable en fr join . ((flip . ((.) .)) .) . (.)
15:29:39 <lambdabot>  joignez. ((chiquenaude. ((.).)) .) . (.)
15:29:45 * monochrom giggles
15:29:47 * Limbic_Region isn't much further ahead of chessguy in YAHT
15:30:14 <monochrom> @bable length(filter isLower "aBCde")
15:30:14 <lambdabot> babel module failed: IRCRaised Error: Language length(filter not supported
15:30:20 <monochrom> @bable en fr length(filter isLower "aBCde")
15:30:21 <lambdabot>  isLower "aBCde" de length(filter)
15:31:00 <monochrom> Hey!  English-to-French translation opens up another route to pointfree transformations!
15:31:13 <lispy> heh
15:31:29 <monochrom> /alias @pl @bable en fr
15:31:35 <lispy> ?bablel fr en le use parens
15:31:36 <lambdabot>  parens uses
15:34:55 <Limbic_Region> ok, I am sure I am just getting ahead of the tutorial, but in if/else blocks in haskell - are multiple statements allowed after the condition?
15:35:24 <dmhouse> Multiple statements aren't allowed anywhere apart from in do-blocks.
15:35:40 <Limbic_Region> ok - thanks
15:35:54 <shizzy0> you could have a let-in statement which may be what you're thinking of as multiple statements.
15:36:26 <Limbic_Region> what I am thinking of in terms of an imperative language is if (foo) { statement1; statement2;statement3 }
15:36:55 <Limbic_Region> again, I am sure I am just getting ahead of the tutorial
15:37:13 <dmhouse> Multiple statements only make sense within a do-block.
15:37:25 <dmhouse> Haskell Is Not Lisp. :)
15:38:01 * Limbic_Region is a Perl crack head and has never touched FP
15:38:21 <Limbic_Region> though, if you ever read my code you would see a strong FP influence
15:40:58 <monochrom> (f . g . h . i) x    this is functional multiple statement.
15:41:43 <monochrom> You are of course welcome to write f, g, h, i, on four separate lines.
15:41:55 <chessguy> is there an easy way to specify, say, a list of the integers from 1 to 100?
15:41:59 <dmhouse> f $
15:42:00 <dmhouse> g$
15:42:01 <chessguy> or a tuple
15:42:02 <dmhouse> h $
15:42:04 <monochrom> [1..100]
15:42:04 <dmhouse> i $
15:42:07 <dmhouse> x
15:42:33 <shizzy0> good point, monochrom (the functional multiple statement).  :)
15:42:41 <chessguy> hm, that looks like python
16:05:03 <Limbic_Region> anyone bored that enjoys interesting but useless programming tasks want to solve a few so I can examine (and hence learn from) your code?
16:05:32 <yip> i think there might be a rule here against solving homework assignments
16:05:47 <Limbic_Region> yip - homework?
16:05:50 <Limbic_Region> heh
16:05:58 * Limbic_Region is an autodidact
16:06:03 <emu> I'm having a bit of confusion with guards: docs say that further patterns are not matched if all guards failed on a particular match
16:06:13 <emu> and yet, it seems to be doing just that
16:06:38 <Limbic_Region> yip - I am just having a hard time wrapping my head around certain FP principals
16:06:51 <monochrom> There is a rule against solving homework using elementary means.
16:06:58 <yip> Limbic_Region: ask ye question and thee shall recieve thy answer
16:07:04 <Limbic_Region> I did ask
16:07:19 <chessguy> i'd like to see the results too
16:07:29 <Limbic_Region> but if you would like me to provide an example of the type of useless but interesting problems
16:07:29 <emu> test n | n > 2 = True | n < 1 = True; test n = False
16:07:32 <Limbic_Region> consider the following
16:07:39 <monochrom> But solving homework using e.g., arrows in pointfree style and a couple of monad transformers is ok.
16:07:42 <emu> shouldn't evaluating test 1 at this point cause an error?
16:07:43 <Limbic_Region> a list of integers positive and negative
16:08:00 <monochrom> The ideal is to do it the Oleg way.
16:08:26 <Limbic_Region> find a contigous subset of that list that produces the largest sum
16:08:32 <profmakx> @yow
16:08:32 <lambdabot> Catsup and Mustard all over the place!  It's the Human Hamburger!
16:08:58 <Limbic_Region> for instance - 3 2 8 9 -25 5 8 4 4 -3 5 3 -10
16:09:01 <Limbic_Region> should produce
16:09:10 <Limbic_Region> 5 8 4 4 -3 5 3
16:09:21 <mauke> hmm, how do I brute force that?
16:09:37 <monochrom> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/75ef570981cd2d3c/9a4a844e63d6feed?lnk=st&q=&rnum=1&hl=en#9a4a844e63d6feed
16:09:38 <Limbic_Region> brute forcing is easy (at least in Perl) but completely unnecessary
16:09:39 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/fur5e
16:09:52 <Limbic_Region> mauke - it can be done as O(N)
16:09:53 <monochrom> That's the solution.
16:10:16 <monochrom> I'm a prophet.  I knew you will ask.
16:10:23 <profmakx> .o
16:10:49 <Limbic_Region> monochrom - heh, let me come up with a different
16:10:52 <Limbic_Region> oe
16:10:55 <Limbic_Region> one even
16:11:01 <Limbic_Region> though thanks - will study that
16:11:01 <monochrom> I think I made a mistake in it.  Change "foldl" to "foldl1"
16:11:29 <mauke> @type scanl
16:11:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:11:44 <Limbic_Region> I will just point to a link for the next one as it will be a bit hard to explain here
16:12:06 <chessguy> Limbic_Region, did you get as far as doing something like square x = x * x
16:12:20 <Limbic_Region> yes chessguy
16:12:26 <chessguy> did it work?
16:12:27 <Limbic_Region> I paused a bit after that
16:12:28 <Limbic_Region> yes
16:12:32 <chessguy> darnit
16:12:36 <Limbic_Region> http://perlmonks.org/?node_id=559228 is the link for the next oe
16:12:38 <Limbic_Region> one even
16:12:39 <lambdabot> Title: Challenge: &quot;Insanity&quot; Cube Puzzle
16:12:50 <Limbic_Region> I bet monochrom can't produce a solution quite so fast this tie
16:12:53 <Limbic_Region> time even
16:13:20 * Limbic_Region wanders off to study the subset solution in the interim
16:14:39 <emu> i pulled an example out of a haskell tutorial which purports to demonstrate match failure when guards all fail, but it doesn't fail
16:14:39 <monochrom> Yeah, will take a while.  But I can already bet on the approach.  I bet forward constraint propagation will do fine.
16:15:01 <monochrom> I already wrote a general routine for forward constraint propagation.
16:15:22 <chessguy> i guess there is no good haskell interpreter for windows :(
16:15:41 <monochrom> ghci and hugs should be fine interprets, Windows or not, no?
16:15:49 <chessguy> hugs isn't working right for me
16:15:50 <Limbic_Region> monochrom - for the record, I am an extreme neophyte with Haskell so while you can make the algorithm as complex as you want - please consider documenting it ;-)
16:16:08 <chessguy> if i do sqr x = x * x    <--this bombs
16:16:13 <Limbic_Region> monchrom - really - if chessguy can be believed, it really isn't behaving properly
16:16:25 <pandres> @lambda
16:16:26 <lambdabot> (line 1, column 1):
16:16:26 <lambdabot> unexpected end of input
16:16:26 <lambdabot> expecting white space or simple term
16:16:35 <mauke> chessguy: what do you mean by "bombs"?
16:16:41 <pandres> @lambda: (\x -> x+1) 1
16:16:41 <lambdabot> 2
16:16:46 <pandres> juaz
16:16:53 <chessguy> ERROR - Syntax error in input (unexpected `=')
16:17:02 <emu> > let test n | x > 2 = True in test 3
16:17:03 <lambdabot>  Not in scope: `x'
16:17:06 <mauke> chessguy: yeah, you can't use = in expressions like that
16:17:08 <emu> > let test n | n > 2 = True in test 3
16:17:08 <chessguy> > sqr x = x * x
16:17:09 <lambdabot>  True
16:17:09 <lambdabot>  Parse error
16:17:11 <emu> > let test n | n > 2 = True in test 1
16:17:13 <lambdabot>  Non-exhaustive patterns in function test
16:17:17 <pandres> @pl (\x -> x+1)
16:17:18 <lambdabot> (1 +)
16:17:21 <mauke> chessguy: you have to put definitions in a file
16:17:22 <pandres> mm
16:17:28 <emu> > let {test n | n > 2 = True ; test n = False} in test 1
16:17:29 <lambdabot>  False
16:17:44 <chessguy> oh, that's dumb. why does it matter if it's in a file?
16:17:45 <emu> shouldn't that also be an error?
16:18:17 <mauke> emu: why?
16:18:23 <spiffy> i thought with gchi you could introduce def in the interperter with some extension?
16:18:30 <emu> it says "once a pattern matches, if all guards fail, no further patterns are matched"
16:18:47 <mauke> emu: url?
16:18:59 <emu> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf  page 83
16:18:59 <mauke> spiffy: ghci can do it, hugs can't
16:19:03 <emu> also gentle intro
16:19:09 <spiffy> ah
16:19:19 <emu> i was just digging through the report for the semantics now
16:19:45 <pandres> @lp unaryInterval f (ojp) = (o, map f p)
16:19:45 <lambdabot> Maybe you meant: . bf help id map pl slap v wn
16:20:12 <mauke> weird
16:21:40 <Limbic_Region> monochrom would you mind helping me debug the solution you linked to?
16:21:48 <pandres> @lp (\f,(o,p) -> (o, map f p))
16:21:49 <lambdabot> Maybe you meant: . bf help id map pl slap v wn
16:22:20 <pandres> @pl (\f,(o,p) -> (o, map f p))
16:22:21 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip ((.) . (,)) . map)
16:22:31 <pandres> awful
16:22:47 <pandres> @lambda: (\f,(o,p) -> (o, map f p)) [1,2,3,4]
16:22:48 <lambdabot> (line 1, column 4):
16:22:48 <lambdabot> unexpected ","
16:22:48 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:22:59 <pandres> @lambda: (\f,(o,p) -> (o, map f p)) (\x -> x+1) [1,2,3,4]
16:23:00 <lambdabot> (line 1, column 4):
16:23:01 <lambdabot> unexpected ","
16:23:01 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:23:01 <pandres> arg
16:23:13 <pandres> @lambda: (\f,(o,p) -> (o, map f p)) (\x -> x+1) ([1,2,3,4],[1,2])
16:23:14 <lambdabot> (line 1, column 4):
16:23:14 <lambdabot> unexpected ","
16:23:14 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:23:22 <pandres> @lambda: (\f,(o,p) -> (o, map f p)) (\x -> x+1) (1,2)
16:23:23 <lambdabot> (line 1, column 4):
16:23:23 <lambdabot> unexpected ","
16:23:23 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:23:32 <pandres> im bad
16:23:57 <mauke>  If one of the guards evaluates to True, the corresponding right-hand side is evaluated in the same environment as the guard. If all the guards evaluate to False, matching continues with the next alternative.
16:24:12 <mauke> looks like the tutorial is wrong
16:24:13 <emu> where is this
16:24:19 <monochrom> My code needs debugging?!
16:24:24 <Limbic_Region> yes
16:24:28 <mauke> http://haskell.org/onlinereport/exps.html , search for guards
16:24:29 <lambdabot> Title: The Haskell 98 Report: Expressions
16:24:36 <Limbic_Region> paste?
16:24:41 <Limbic_Region> @paste
16:24:41 <lambdabot> http://paste.lisp.org/new/haskell
16:24:53 <emu> i was reading the informal semantics of pattern matching
16:25:07 <monochrom> What is debugging?
16:25:12 <emu> ok
16:25:18 <emu> got the paragraph
16:25:24 <lisppaste2> Limbic_Region pasted "error output" at http://paste.lisp.org/display/25669
16:25:36 <emu> it's under case expressions, 3.13
16:26:12 <chessguy> woohoo, i'm up to 1232/1368 on mathschallenge
16:26:16 <pandres> @lambda: (\f,(o,p) -> (o, map f p)) (\x -> x+1) (1,[2])
16:26:17 <lambdabot> (line 1, column 4):
16:26:17 <lambdabot> unexpected ","
16:26:17 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:26:35 <pandres> @lambda: ((\f,(o,p) -> (o, map f p)) (\x -> x+1)) (1,[2])
16:26:35 <lambdabot> (line 1, column 5):
16:26:36 <lambdabot> unexpected ","
16:26:36 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:28:12 <emu> mauke: if i understand the formal semantics correctly, they also support this interpretation.. so the tutorial is wrong
16:28:20 <emu> thanks
16:28:38 <pandres> @lambda: (\f, op) -> map f p) (\x -> x+1) 1
16:28:39 <lambdabot> (line 1, column 4):
16:28:39 <lambdabot> unexpected ","
16:28:39 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:28:53 <pandres> @lambda: ((\f, op) -> map f p) (\x -> x+1)) 1
16:28:53 <lambdabot> (line 1, column 5):
16:28:54 <lambdabot> unexpected ","
16:28:54 <lambdabot> expecting letter or digit, identifier, "." or "->"
16:29:13 * Limbic_Region wonders if monochrom saw the paste?
16:29:45 <chessguy> ok, i have no idea how to attack this problem in FP
16:29:52 <Limbic_Region> which problem
16:29:53 <pandres> @lambda: (\f op -> map f p) (\x -> x+1) 1
16:29:54 <lambdabot> unbound variable: p
16:30:00 <Limbic_Region> the first one I gave or the second
16:30:02 <pandres> @lambda: (\f op -> map f op) (\x -> x+1) 1
16:30:03 <lambdabot> type error
16:30:08 <chessguy> Find the sum of all the even terms in the Fibonacci sequence below one million.
16:30:23 <pandres> @lambda: (\f op -> map f op) (\x -> x+1) [1]
16:30:23 <lambdabot> [2]
16:30:40 <Limbic_Region> thats should be pretty easy
16:30:43 <Limbic_Region> I would think
16:30:47 <pandres> @lambda: (\f (o,p) -> (o, map f p) (\x -> x+1) (1,[2])
16:30:47 <lambdabot> (line 1, column 5):
16:30:48 <lambdabot> unexpected "("
16:30:48 <lambdabot> expecting identifier, "." or "->"
16:30:59 <chessguy> it would be easin in imperative programming. i don't know how to think in FP
16:31:13 <pandres> @lambda: (\f o p -> (o, map f p) (\x -> x+1) 1 [2]
16:31:14 <lambdabot> (line 1, column 14):
16:31:14 <lambdabot> unexpected ","
16:31:14 <lambdabot> expecting letter or digit, var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or ")"
16:31:18 <mauke> > let f = 1 : 1 : zipWith (+) f (tail f) in sum $ filter even $ takeWhile (< 1000000) f
16:31:19 <lambdabot>  1089154
16:31:22 <Limbic_Region> you are going to want a foldl to do the sum, a filter to get the list of even, etc
16:31:32 <mauke> Limbic_Region: I prefer sum for sums :-)
16:31:43 <Limbic_Region> mauke - didn't get that far in the tutorial yet
16:31:49 <chessguy> yeah, but how do i generate the list to begin with
16:32:18 <Limbic_Region> chessguy - you have never seen a recursive implementation of the fibonacci series?
16:32:23 <chessguy> sure
16:32:30 <mauke> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)  -- list of all fibonacci numbers
16:32:45 <chessguy> wtf is zipWith?
16:32:52 <profmakx> a function ^^
16:33:00 <Limbic_Region> chessguy - zip should be obvious
16:33:12 <Limbic_Region> zipWith says to apply a function while zipping
16:33:17 * Limbic_Region assumes anyway
16:33:21 <mauke> zipWith f [x1, x2, x3, ...] [y1, y2, y3, ...] = [f x1 y1, f x2 y2, f x3 y3, ...]
16:33:31 <Limbic_Region> I have all of about 30 minutes of haskell under my belt
16:33:58 <velco> zipWith f xs ys = [f x y | x <- xs, y < ys]
16:34:06 <sjanssen> velco: wrong
16:34:08 <mauke> velco: no
16:34:18 <velco> hmm ...
16:34:28 <velco> what is wrong ?
16:34:36 <sjanssen> > [(x, y) | x <- [1..3], y <- [1..3]]
16:34:37 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:34:46 <sjanssen> the code you gave is cartesian product
16:34:50 <mauke> > zipWith (,) [1..3] [1..3]
16:34:51 <lambdabot>  [(1,1),(2,2),(3,3)]
16:34:55 <velco> ah yes
16:35:15 <chessguy> so then how do i get all the numbers in the fib sequence that are less than 1 million
16:35:29 <Limbic_Region> takeWhile
16:35:29 <clanehin> > zip [1..3] [1..3]
16:35:30 <lambdabot>  [(1,1),(2,2),(3,3)]
16:35:31 <mauke> chessguy: takeWhile (< 1000000) fibs
16:35:31 <Limbic_Region> see above
16:36:33 <chessguy> so takeWhile returns a list?
16:36:35 <mauke> takeWhile f [] = []; takeWhile f (x : xs) = if f x then x : takeWhile f xs else []
16:36:37 <Limbic_Region> no
16:36:39 <mauke> yes
16:36:58 <Limbic_Region> well, it *may* return a list
16:36:58 <velco> zipWith f xs ys = map (uncurry f) (zip xs ys)
16:37:04 <velco> now better ?
16:37:04 <mauke> takeWhile returns the initial part of the list that satisfies the condition
16:37:13 <sjanssen> velco: excellent
16:37:13 <Limbic_Region> though I guess no return is an empty list
16:37:19 <velco> yay!
16:41:16 <mauke> > let foo f k = do (x : xs) <- [k]; if f x then x : foo f xs else fail "hi2u" in foo (< 50) [1..9]
16:41:17 <lambdabot>  [1,2,3,4,5,6,7,8,9]
16:41:25 <mauke> <3
16:42:38 <chessguy> does haskell have a builtin mod operator?
16:42:59 <mauke> > 10 `mod` 3
16:43:00 <lambdabot>  1
16:45:15 <resiak> mauke: ITYM 
16:45:22 <chessguy> 10 `mod` 3 == 1
16:45:25 <chessguy> > 10 `mod` 3 == 1
16:45:26 <lambdabot>  True
16:45:32 <mauke> U+2765 (0xe2 0x9d 0xa5): ROTATED HEAVY BLACK HEART BULLET []
16:45:41 <mauke> wow, my font doesn't even have that symbol
16:45:53 <resiak> It's the most emo unicode character ever :)
16:46:24 <mauke> chessguy: if you want to check mod 2, there's a built-in even function
16:46:42 <Limbic_Region> isEven ?
16:47:46 <mauke> @type even
16:47:48 <lambdabot> forall a. (Integral a) => a -> Bool
16:47:55 <chessguy> woohoo!
16:47:56 <chessguy> foldr (+) 0 (filter isEven (takeWhile (< 1000000) fibs))
16:48:05 <chessguy> now that's cool
16:48:17 <mauke> chessguy: you can use sum instead of foldr (+) 0
16:50:51 <chessguy> aha
16:54:13 <monochrom> Limbic_Region: foldl1 max (scanl op 0 l)   I misplaced parens.
16:54:18 <chessguy> so, i learned about [1..20], is there a good way to get all the multiples of a number. like, if i want a list like [100, 200, 300, 400, ...]
16:54:42 <wkh> map multiplication over a range?
16:55:20 <chessguy> like map (*) 100 [1..100]
16:55:38 <velco> map (100*) [1..100]
16:55:56 * Limbic_Region tries it monochrom
16:56:43 <sjanssen> > [100, 200, .. 800] -- for chessguy
16:56:43 <lambdabot>  Parse error
16:56:56 <sjanssen> > [100, 200 .. 800]
16:56:57 <lambdabot>  [100,200,300,400,500,600,700,800]
16:57:01 <chessguy> > map (*) 100 [1..10]
16:57:02 <lambdabot>    The function `map' is applied to three arguments,
16:57:03 <lambdabot>   but its type `(a -...
16:57:21 <wkh> > map (100*) [1..10]
16:57:22 <lambdabot>  [100,200,300,400,500,600,700,800,900,1000]
16:57:30 <chessguy> what is 100*
16:57:35 <alec> you could probably also do it with list comprehension
16:57:47 <spiffy> or a lambda to make it clear
16:57:50 <Limbic_Region> ok - "foo: user error (Prelude.readIO: no parse)"
16:57:52 <velco> chessguy: it's a partial application of *
16:57:57 <Limbic_Region> what am I doing wrog
16:57:59 <Limbic_Region> wrong
16:58:00 <chessguy> ugh
16:58:28 <sjanssen> Limbic_Region: you're using readLn but it can't parse the stuff you're typing in
16:58:38 <alec> > let a = 100 : 200 : [ x | x <- tail a ]
16:58:38 <lambdabot>  Parse error
16:58:47 <Limbic_Region> sjanssen - yeah, but why
16:58:52 <spiffy> > map \x->x*100 [1..10]
16:58:53 <lambdabot>  Parse error
16:58:55 <spiffy> damn
16:58:57 <Limbic_Region> if I just type in a 3 and hit return
16:59:02 <Limbic_Region> it still spits out that error
16:59:12 <alec> > let a = 100 : 200 : [ x + 100 | x <- tail a ]
16:59:12 <lambdabot>  Parse error
16:59:16 <sjanssen> is it really expecting an Int?
16:59:22 <chessguy> ok, so the question is, what is the smallest number that is evenly divisible by all of the numbers from 1 to 20?
16:59:25 <wkh> > map (\x->x*100) [1..10]
16:59:26 <lambdabot>  [100,200,300,400,500,600,700,800,900,1000]
16:59:30 <Limbic_Region> I think it is expecting a list of ints
16:59:40 <chessguy> i made a isMultipleOf x y
16:59:42 <sjanssen> Limbic_Region: then you should type in a list of ints
16:59:52 <Limbic_Region> hence my question
16:59:55 <Limbic_Region> what am I doing wrong
16:59:57 <spiffy> thanks wkh
16:59:58 <wkh> chessguy: i'm so lazy that i'd start at 20! and work down
17:00:00 <velco> > let mul x y = x * y; mul100 = mul 100; in map mul100 [1..10]
17:00:02 <lambdabot>  [100,200,300,400,500,600,700,800,900,1000]
17:00:07 <Limbic_Region> how do I do that
17:00:23 <chessguy> < [1..20!]
17:00:28 <chessguy> just kidding
17:00:28 <sjanssen> [1,2,3] will parse as a list of Ints
17:00:31 <Limbic_Region> nevermind
17:00:45 <Limbic_Region> yeah, I was providing a tuple not a list
17:01:08 <chessguy> that's a nice one, velco
17:01:23 <Limbic_Region> monochrom great code except it doesn't actually do what I posed as the problem
17:01:23 <velco> chessguy: that's what (100*) means
17:01:39 <Limbic_Region> it is supposed to return the list that produces the largest sum - not the sum
17:01:45 <wkh> chessguy: look at the prime factors of 1, 2, ..., 20
17:01:54 <wkh> it's the product of all the prime numbers that appear
17:02:20 <wkh> 1*2*3*5*7*9*11*13*15*17*19, i think
17:02:25 <sjanssen> wkh: you also have to consider numbers that repeat a prime factor
17:02:51 <chessguy> > 1*2*3*5*7*9*11*13*15*17*19
17:02:52 <lambdabot>  1309458150
17:03:03 * spiffy jumped in late, whats the actual problem we're trying to help solve?
17:03:14 <chessguy> wrong
17:03:27 <chessguy> spiffy, the question is, what is the smallest number that is evenly divisible by all of the numbers from 1 to 20?
17:03:39 <chessguy> or rather, how should i attack solving that question in FP
17:03:48 <sjanssen> write code to figure out the prime factorisation of a number (that's easy)
17:04:24 <Limbic_Region> chessguy - is this a project euler thing?
17:04:29 <chessguy> yes
17:04:32 <twanvl> isn't this the least common multiple?
17:04:40 <wkh> it's a problem better solved by paper and pencil than computer. it's like asking for a computerized proof of the identity 1 + ... + n = n(n+1)/2. you can produce one but it's clumsier than a nice, simple proof by induction
17:04:47 * Limbic_Region solved most of those in Perl and got bored with the site
17:04:58 <Limbic_Region> they have subsequently added new puzzles but whatever
17:05:01 <chessguy> wkh: yes, but i'm trying to learn haskell by solving these problems with them
17:05:15 <spiffy> twanvl: yes, yes it is
17:05:42 <sjanssen> > foldr lcm [1..20]
17:05:43 <lambdabot>  add an instance declaration for (Integral [a])
17:05:56 <sjanssen> > foldr lcm 1 [1..20]
17:05:58 <lambdabot>  232792560
17:06:19 <spiffy> haskell has lcm built in?
17:06:20 <chessguy> wow
17:06:21 <spiffy> kool
17:06:24 <chessguy> that was way too easy
17:06:26 <mauke> @index lcm
17:06:26 <lambdabot> Prelude
17:06:30 <mauke> wow.
17:06:37 <Limbic_Region> given a list of integers (positive and negative), how would I go about finding the contigous subset of that list that yields the largest sum?
17:06:54 <sjanssen> yeah, I knew gcd was in the Prelude . . . wasn't too sure if lcm was
17:06:55 <Limbic_Region> monochrom provided a solution that yields the sum itself, not the subset
17:06:57 <chessguy> can i do a trace of a computation?
17:07:09 <chessguy> like if i want to see how it worked out that fold?
17:07:16 <mauke> @index trace
17:07:17 <lambdabot> Debug.Trace
17:07:31 <sjanssen> Limbic_Region: that's a class dynamic programming problem (I think)
17:07:46 <Limbic_Region> sjanssen - well, in FP maybe
17:07:58 <sjanssen> s/class/classic
17:08:04 <Limbic_Region> in an imperative paradigmn - it is much simpler than that
17:08:26 <chessguy> so...it figures out the lcm of 19 and 20
17:08:27 <wkh> Limbic_Region: because of how my brain works i'd use genetic algorithms
17:08:35 <chessguy> and then figures out the lcm of 18 and that number
17:08:38 <chessguy> and so on, right?
17:08:53 <sjanssen> chessguy: actually it does lcm 20 1 first
17:09:00 <mauke> what's the imperative algo?
17:09:00 <chessguy> well, ok
17:09:06 <sjanssen> chessguy: but after that, you're right
17:09:06 <chessguy> but then it does what i sai
17:09:06 <chessguy> d
17:09:07 <Limbic_Region> well, I don't really care what algorithm or approach is taken
17:09:17 <Limbic_Region> I am most interesting in learning from others code
17:09:30 <Limbic_Region> provided the algorithm is adequately explained ;-)
17:09:32 <wkh> Limbic_Region: first of all, do you realize that the search space you're considering is exponentially large?
17:09:47 <wkh> certainly brute force won't work, in general
17:09:48 <Limbic_Region> wkh - it can be done in O(N)
17:09:54 <Limbic_Region> trivially
17:10:00 <sjanssen> wkh: Limbic_Region is just looking for substrings, not subsets
17:10:01 * Limbic_Region pastes the Perl solutionn
17:10:08 <wkh> oh.
17:10:26 * Limbic_Region apologizes for improper use of the vernacular
17:10:26 <wkh> eh whatever
17:10:29 <Limbic_Region> @paste
17:10:30 <lambdabot> http://paste.lisp.org/new/haskell
17:10:45 <sjanssen> O(n) . . . I thought it's O(n^2)
17:11:13 <lisppaste2> Limbic_Region pasted "perl solution " at http://paste.lisp.org/display/25671
17:11:48 <wkh> if it's so trivial, why ask here
17:12:16 <Limbic_Region> wkh - um, because I am trying to learn Haskell
17:12:51 <spiffy> if you like the impertive so much, perhaps monads?
17:12:59 <Limbic_Region> and probably because I am too impatient to wade through YAHT
17:13:14 <Limbic_Region> spiffy - it isn't that I like it, it is just what I know
17:13:16 <twanvl> That perl algorithm looks wrong
17:13:27 <Limbic_Region> twanvl - it isn't
17:14:07 <twanvl> If there is a small negative number, like -1 in the list, say [100,-1,100] it doesn't take the entire list
17:14:37 <mauke> why not?
17:15:04 <monochrom> Hmm, should be fun to isolate the segment and keep the algorithm elegant :)
17:15:08 <chessguy> wow, i'm now a 1% genius
17:15:09 <Limbic_Region> twanvl - yes it does
17:15:18 <twanvl> oh, wait, $cur += ..., not $cur =
17:15:53 <chessguy> i'm in the 82nd percentile :)
17:16:04 <stepcut> chessguy: :p
17:16:13 <Limbic_Region> monochrom - the way the algorithm I pasted from perl does it by just keeping track of the start and end and then producing the list at the end
17:16:23 <chessguy> ugh, this one looks nasty
17:16:34 <chessguy> find the 10001st prime
17:16:49 <Limbic_Region> sieve anyone?
17:16:56 <mauke> meh, generate list of all primes, drop 10001, take 1
17:17:20 <chessguy> i don't have a clue how to generate a list of all primes
17:17:24 <Cale> mbot: % Prime[10001]
17:17:33 <Cale> mbot: @math Prime[10001]
17:17:35 <mbot> Cale: 104743
17:17:36 <chessguy> that's cheating, Cale
17:17:46 <Cale> mbot: @part #haskell
17:18:00 <monochrom> (system "math") is not considered Haskell :)
17:18:17 <Cale> okay then
17:18:32 <twanvl> > let f (x:xs) = x : f (filter ((/=0) . (`mod` x)) xs) in take 20 $ f [2..]
17:18:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
17:18:48 <twanvl> It is way too slow though
17:19:03 <monochrom> division is slow.
17:19:04 <chessguy> that looks like gibberish to me
17:19:24 <wkh> what would be a haskellish interpretation of the sieve of eratosthenes or whatever
17:19:28 <Cale> > let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes
17:19:29 <stepcut> > let f (x:xs) = x : f (filter ((/=0) . (`mod` x)) xs) in ((f [2..]) !! 10001)
17:19:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:19:33 <lambdabot> Terminated
17:19:36 <Cale> wkh: that :)
17:20:40 <chessguy> ok, i'm trying to learn how to think about this here
17:21:03 <chessguy> then again, i don't even know how i'd think about this in imperative programming
17:21:18 <Limbic_Region> chessguy - really?
17:21:35 <Limbic_Region> if you could do closures it would be simple to create an iterator that walked the primes
17:21:38 <chessguy> to generate 10001 primes?
17:21:42 <Limbic_Region> yes
17:21:59 <Limbic_Region> or you could use the sieve as I suggested when you first asked
17:22:01 <deadbeef> hi dear friends
17:22:01 * chessguy shrugs
17:22:03 <deadbeef> sup
17:22:17 <chessguy> yeah but how do i know how many numbers to sieve
17:22:53 <Cale> the prime number theorem?
17:22:58 <Limbic_Region> chessguy - this is project euler
17:23:03 <Limbic_Region> exactly Cale
17:23:24 <Limbic_Region> you won't know the exact number, but you will know the exact limit
17:24:01 <Limbic_Region> of course, if you assume the riemann hypothesis is true, I think you could get an exact number too though it would take longer to calculate then just to brute force it
17:24:27 <chessguy> n ln n?
17:24:29 <Cale> and if it doesn't work, then you've proved RH is false :)
17:24:41 <mauke> Limbic_Region: is [5,8,4,4,-3,5,3,-10] right?
17:24:57 <Limbic_Region> chessguy - almost every single problem in the project euler has a trick to it that euler had some involement in - find the trick and the code is cake
17:25:03 <Limbic_Region> no
17:25:15 <mauke> hmm, then I'm doing it wrong
17:25:16 <Limbic_Region> mauke - you should never ever ever end in a negative number
17:25:22 <mauke> yeah :(
17:25:24 <Limbic_Region> no - you just have a one off
17:25:34 <chessguy> i'm not that interested in the mathematics of it at the moment
17:25:38 <Cale> p_n < n log n + n log log n
17:25:45 <Cale> for n > 6
17:25:49 <lispy> dons: i'm trying to keep you busy with lambdabot patches, can you tell?
17:25:51 <mauke> yeah, it's [5,8,4,4,-3,5,3] now :-)
17:26:07 <Limbic_Region> mauke - in haskell?
17:26:34 <mauke> yes
17:26:49 <Limbic_Region> btw - I know about head and tail, is there a tip (last element of a finite list)?
17:26:49 <Cale> > ceiling (10001 * log 10001 + 10001 * log (log 10001))
17:26:51 <lambdabot>  114320
17:26:57 <Limbic_Region> mauke - paste it?
17:27:01 <Cale> there's your bound :)
17:27:04 <lispy> lambdabot: last?
17:27:11 <lispy> er
17:27:14 <lispy> Limbic_Region: last
17:27:15 <Cale> also, there's a nice lower bound
17:27:19 <lispy> > last [1..10]
17:27:20 <lambdabot>  10
17:27:23 <Limbic_Region> thanks
17:27:36 <mauke> sec, cleaning up
17:27:43 <Cale> > floor (10001 * log 10001 + 10001 * log (log 10001) - 10001)
17:27:45 <lambdabot>  104318
17:27:45 <Limbic_Region> Cale - and with that bound, it would just be smarter to walk backwords and stop at the first prime
17:27:49 <Limbic_Region> but you didn't hear e say that
17:27:54 <Limbic_Region> me
17:28:03 <chessguy> Cale, i'm more interested in learning how to attack this problem using FP
17:28:07 <Limbic_Region> no worries - thanks mauke
17:28:18 * wkh thinks the euler challenge is stupid
17:28:24 * Limbic_Region agrees wkh
17:28:27 <Cale> well, my stupid prime sieve found it after about a minute
17:28:48 <Limbic_Region> I did do many of the problems though as I was unfamiliar with the math tricks and gave me reason to do research
17:28:50 <Cale> 10001 isn't a very large number
17:28:57 <Limbic_Region> nope
17:29:12 <Limbic_Region> but all the project euler problems are supposed to be solved in less than 60 seconds
17:29:31 <Limbic_Region> not that a correct answer after 24 hours will be penalized
17:29:36 <lisppaste2> mauke pasted "translation of the loop code" at http://paste.lisp.org/display/25673
17:29:47 <Limbic_Region> it is kinda of a yardstick to let you know if you have the intended solution
17:29:47 <sjanssen> there aren't very many (non-trivial) problems that can be solved in less than 60 seconds
17:29:56 <chessguy> so the key here is to come up with a way to generate a list of all the primes, right?
17:30:08 <Cale> Problems that can be solved in less than 60 seconds are usually not worth doing.
17:30:09 <Limbic_Region> sjanssen - they only become trivial if you know the trick - at least for the hard problems
17:30:30 <Cale> (if you can do them that quickly)
17:30:32 <Limbic_Region> chessguy - no, the trick is to know the prime number theorem
17:30:43 <mauke> Limbic_Region: I'm sure this code can be made more haskelly, but this is what you get when you translate the loop to a recursive function
17:30:51 <Cale> Or know how to look up actual bounds on the nth prime number
17:31:09 <chessguy> Cale, can you explain to me your siev?
17:31:09 <Limbic_Region> mauke - will look at it in a few minutes - saying goodnight to my daughter
17:31:11 <chessguy> sieve
17:31:13 <Cale> The PNT doesn't actually give a bound of any sort, but related theorems do.
17:31:17 <Cale> chessguy: sure
17:31:33 <Cale> sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0]
17:31:40 <Cale> er
17:31:44 <Cale> sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]
17:31:50 <Cale> hehe, that's a severe bug there :)
17:32:09 <Cale> Okay, so what this does is takes the first element, and calls it prime
17:32:19 <chessguy> first element of what?
17:32:23 <Cale> of (x:xs)
17:32:31 <mauke> (it takes a list)
17:32:35 <chessguy> ok
17:32:40 <chessguy> oh ok
17:32:42 <chessguy> got it
17:32:43 <Cale> we're eventually going to call sieve [2..] to get all the primes
17:32:53 <Deformative-II> What is some good code to read to help me understand haskell?
17:33:02 <Cale> then it removes all the multiples of x from xs, and calls sieve on the rest
17:33:04 <Deformative-II> The compiler is the only thing i know written in haskell.
17:33:08 <Deformative-II> This is my first language.
17:33:12 <chessguy> go ahead
17:33:24 <mauke> we're done :-)
17:33:25 <lispy> Deformative-II: darcs  is written in haskell
17:33:30 <Cale> Deformative-II: from actual projects?
17:33:46 <lispy> @where nehe-tus
17:33:46 <lambdabot> I know nothing about nehe-tus.
17:33:48 <lispy> @where nehe-tuts
17:33:48 <lambdabot> I know nothing about nehe-tuts.
17:33:49 <Deformative-II> Yes,  or samples,  eather or.
17:34:21 <mauke> that's not how you learn to program
17:34:30 <Cale> http://www.haskell.org/haskellwiki/Example_code
17:34:32 <lambdabot> Title: Example code - HaskellWiki, http://tinyurl.com/kb3j6
17:34:35 <lispy> Deformative-II: opengl code from the nehe tutorials: http://projects.codersbase.com/repos/nehe-tuts/
17:34:37 <lambdabot> Title: Index of /repos/nehe-tuts, http://tinyurl.com/z45ck
17:34:41 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_practice
17:34:44 <lambdabot> Title: Haskell in practice - HaskellWiki, http://tinyurl.com/jth4m
17:35:22 <Deformative-II> Well, it is an alright way to help you understand,  the best way to learn to write GOOD code,  is to read good code.
17:35:37 <lispy> Deformative-II: email filter language that compiles to procmail recipes: http://projects.codersbase.com/repos/autoproc/
17:35:41 <lambdabot> Title: Index of /repos/autoproc, http://tinyurl.com/gxshu
17:35:53 <Cale> Deformative-II: Or just write bad code and then paste it here, and watch as it is mangled into shape :)
17:36:02 <lispy> heh
17:36:09 <lispy> #haskell++
17:36:43 <Deformative-II> Eh, I guess so,  I would like to read the 6.001 book one day though,  that is supposed to help a lot.
17:36:56 <Cale> 6.001?
17:37:28 <jgrimes> SICP?
17:37:41 <Deformative-II> I have been told it is a book,  that you read,  and it is just like getting programming experience,  just faster.
17:37:50 <chessguy> SICP rocks
17:37:55 <Deformative-II> Yeah sicp.
17:38:14 <chessguy> at least, the video lecture series does. i haven't read the book yet
17:38:24 <Deformative-II> But I am gonna wait untill I learn the basics of SOME language, before i buy the book.
17:38:37 <chessguy> ok Cale, i'm with you up to sieve [y | y <- xs, y `mod` x /= 0]
17:38:40 <Cale> I haven't seen the videos, only read (most of) the book :)
17:38:47 <jgrimes> sicp is online for free :D
17:38:54 <Cale> chessguy: okay, and then you apply sieve to [2..]
17:39:05 <Cale> chessguy: and that's the list of primes
17:39:06 <Deformative-II> It is?
17:39:08 <Deformative-II> Where?
17:39:13 <Deformative-II> I thought it was a textbook.
17:39:15 <chessguy> i meant, that's the part i don't understand
17:39:20 <jgrimes> mitpress.mit.edu/sicp/
17:39:25 <Cale> http://mitpress.mit.edu/sicp/full-text/book/book.html
17:39:27 <lambdabot> Title: Structure and Interpretation of Computer Programs, http://tinyurl.com/2a8cj
17:39:28 <Limbic_Region> mauke - going to take me a while to understand that
17:39:30 <Limbic_Region> thanks
17:39:30 <Cale> chessguy: ah
17:39:39 <jgrimes> great book
17:39:46 <mauke> Limbic_Region: "step" is the loop body
17:40:01 <Cale> chessguy: okay, so [y | y <- xs, y `mod` x /= 0], that's the list of elements of xs such that they are not 0 modulo x
17:40:06 <mauke> Limbic_Region: its second argument is the loop state (your $cur, $best, etc variables)
17:40:16 <Cale> chessguy: that means that they are not divisible by x
17:40:33 <Limbic_Region> I can see that it is a translation
17:40:39 <mauke> Limbic_Region: b is the best list, bl is its length, c is the current list, cl is its length, s is the current sum
17:40:54 <Limbic_Region> but my brain doesn't think recursively
17:40:54 <Deformative-II> I will read that book after I learn the basics of both haskell and python.
17:41:01 <Limbic_Region> so I need to translate it back into iteration
17:41:21 <mauke> should be easy, it's tail recursive
17:41:32 <Deformative-II> Then after a year or so I will prolly learn C.
17:41:34 <chessguy> so /= is not equal?
17:41:34 <Cale> chessguy: this is analogous to taking the list  2, 3, 4, 5, 6, 7, ..., and saying, okay, 2 is a prime, so throw out all multiples and work with 3, 5, 7, 9, 11, 13, 15, ...
17:41:35 <Limbic_Region> did you see my perl.com article on iterators?
17:41:41 <Cale> chessguy: yeah
17:41:46 <mauke> Limbic_Region: nope
17:41:59 <Cale> > 100 /= 5
17:42:00 <lambdabot>  True
17:42:01 <chessguy> wow, that sounds way too simple
17:42:06 <Limbic_Region> mauke - http://www.perl.com/pub/a/2005/06/16/iterators.html
17:42:08 <lambdabot> Title: perl.com: Understanding and Using Iterators, http://tinyurl.com/egxyc
17:42:33 <Cale> chessguy: and then you sieve the rest, so 3 is the next prime, throw out all the multiples of it and continue
17:42:59 <chessguy> it really is the sieve of eratosthenes
17:43:07 <Cale> yep
17:43:09 <chessguy> so how do i throw out the first 10000 then
17:43:17 <Cale> drop 10000 primes
17:43:24 <Cale> and then wait :)
17:43:26 <lispy> that's really slow
17:43:34 <lispy> want a faster primality tester?
17:43:37 <Cale> or just do  primes !! 10001
17:43:41 <Limbic_Region> under the covers it is really just dropping 1 at a time?
17:43:51 <chessguy> that takes the 10001th prime?
17:43:57 <lispy> try out this guy http://files.codersbase.com/miller-rabin.hs
17:44:00 <mauke> it's a linked list; it has to walk all elements
17:44:01 <sjanssen> Limbic_Region: for each of those reasons to use iterators, Haskellers would use lists
17:44:12 <Limbic_Region> sjanssen - yes I know
17:44:15 <Cale> Limbic_Region: it has to compute the first 10000 to be able to get that far into the list
17:44:28 <Limbic_Region> oh right - lazy evaluation
17:44:36 <chessguy> Cale, i thought 10000 wasn't that big of a number :)
17:44:36 <Cale> The list is infinite
17:44:44 <Cale> It's not that big of a number
17:44:56 <Cale> so even this rather slow way to find primes will work
17:44:59 <Limbic_Region> sjanssen - I was just trying to illustrate that my brain really really doesn't think recursively
17:45:01 <Deformative-II> /j #vim
17:45:04 <Deformative-II> Oops.
17:45:04 <Cale> It'll just take a minute :)
17:45:06 <mauke> haskell's lists _are_ iterators
17:45:13 <Limbic_Region> yay
17:45:13 <sjanssen> so, what exactly is a big number?
17:45:27 <Limbic_Region> a googol I would imagine
17:45:31 <sjanssen> mauke: only if you consume them lazily
17:45:45 <Cale> sjanssen: In this context, 10^20 or so?
17:45:47 <Limbic_Region> certainly a googol to a googol exponent
17:46:10 <Cale> That'd be where you start to have problems computing it :)
17:46:33 * Limbic_Region didn't pay attention
17:46:41 <Limbic_Region> what alg did you use to determine primality?
17:47:07 * chessguy taps his fingers
17:47:29 <Cale> Limbic_Region: Sieve of Eratosthenes
17:47:36 <Cale> I'm done :)
17:47:37 <Limbic_Region> Cale, I mispoke
17:47:40 <Cale> 104759
17:47:40 <Cale> (114.56 secs, 3430915652 bytes)
17:47:51 <Limbic_Region> before removing all multiples of a prime
17:48:01 <Limbic_Region> how did you determine the number itself was prime
17:48:07 <chessguy> still waiting :)
17:48:07 <Cale> Limbic_Region: It's the first element
17:48:24 <Cale> Limbic_Region: in the end, we apply it to the list [2..]
17:48:33 * Limbic_Region scrolls back
17:48:37 <chessguy> 104759 is wrong
17:48:53 <Cale> oh, zero indexed :)
17:49:22 <chessguy> so i actually want to do primes !! 10000 ?
17:49:26 <Cale> yeah
17:49:30 <chessguy> augh!
17:49:35 <mauke> Limbic_Region: http://rafb.net/paste/results/qGlXQa51.html
17:49:56 * chessguy starts over and goes back to tapping
17:50:05 <Limbic_Region> Cale - your mod /= 0 is what I was talking about
17:50:09 <Cale> if you did "let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]" as a separate line in ghci, then you wouldn't have to wait :)
17:50:18 <Cale> Limbic_Region: ah
17:50:32 <Limbic_Region> that's what I meant by your alg to determine primality
17:50:50 <chessguy> what do you mean as a separate line?
17:51:11 <Deformative-II> What does =>
17:51:13 <Cale> chessguy: issue that as a command, then issue the command primes !! 10001
17:51:15 <Limbic_Region> Cale - can you work through just that piece of it for me?
17:51:24 <chessguy> that's what i did
17:51:25 <chessguy> in Hugs
17:51:33 <Deformative-II> What does => mean
17:51:42 <Cale> Deformative-II: in what context?
17:51:49 <Cale> Deformative-II: in a type signature?
17:52:03 <chessguy> actually, i did sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]  followed by primes=siev [2..] followed by primes 10000
17:52:03 <sjanssen> Deformative-II: it means the class constraints on the types on the left must be satisfied in the type signature in the right
17:52:31 <Cale> chessguy: hmm, then computing the next one should have been quick
17:52:38 <Cale> Prelude> primes !! 10000 104743
17:52:38 <Cale> (114.02 secs, 3429306444 bytes)
17:52:38 <Cale> Prelude> primes !! 10001
17:52:38 <Cale> 104759
17:52:39 <Cale> (0.02 secs, 1182384 bytes)
17:52:49 <Deformative-II> Oh,  I thought it was greater than or equal to.
17:52:58 <mauke> nah, that's >=
17:53:16 <chessguy> equal than or greater to?
17:53:30 <Limbic_Region> Cale - would you mind explaining just the primality test part of the alg?
17:53:34 <Deformative-II> Aha, I get it.
17:53:41 <Cale> Deformative-II: on the value level, I think quickcheck defines => as an operator to constrain test generators
17:53:56 <mauke> Limbic_Region: it doesn't really test, per se
17:53:58 <Cale> Limbic_Region: Do you know how the Sieve of Eratosthenes works?
17:54:02 <Limbic_Region> yes
17:54:08 <Cale> Limbic_Region: It's just that
17:54:10 <Limbic_Region> I was the 1st one to suggest it
17:54:14 <Deformative-II> Alright,  wow,  this is way more difficult than python or C,  but I think it will be worth it.
17:54:15 <Cale> Only with an infinite list
17:54:26 <mauke> each sieve call removes more numbers from the list, leaving the primes
17:54:41 <Limbic_Region> right
17:54:46 <Cale> Deformative-II: of course, you don't have to care about that one unless you're using the Quickcheck library :)
17:55:16 <Limbic_Region> hrmm - how can I explain my confusion
17:55:22 * chessguy is still waiting
17:55:37 <Cale> chessguy: use ghci, it's a little faster :)
17:55:44 <Limbic_Region> I am trying to understand why that y mod x is there in the 1st place
17:55:46 <chessguy> i'm using windows
17:55:50 <Cale> ah, okay
17:56:03 <Limbic_Region> I was thinking you were implementing the sieve inefficiently
17:56:06 <Cale> Limbic_Region: that's the "remove all multiples of x" part
17:56:13 <Limbic_Region> oh, duh
17:56:24 <chessguy> Limbic_Region: you're removing the members of the list y, such that y mod x is 0
17:56:29 <Limbic_Region> yes
17:57:53 <Cale> this has quadratic complexity overall
17:58:18 <Cale> because really, you're building up a great big list of tests which are applied to each element of [2..]
17:58:25 <Limbic_Region> I guess I should have paid more attention to the parts I didn't recognize (notation
17:58:38 <mauke> lazy evaluation == transpose
17:58:39 <Limbic_Region> ) and less time on the parts that I didnt recognize (mod)
17:59:11 * Limbic_Region will continue in YAHT tomorrow
17:59:17 <Limbic_Region> brownie time for me
17:59:25 <chessguy> hmmm
17:59:33 <chessguy> There exists exactly one Pythagorean triplet for which a + b + c = 1000.
17:59:33 <chessguy> Find the product abc.
18:00:41 <chessguy> imperatively, i'd do three nested loops
18:00:49 <mauke> > [a * b * c | a <- [1 .. 1000], b <- [a .. 1000], c <- [b .. 1000], a + b + c == 1000]
18:00:50 <lambdabot>  [998,1994,2988,3980,4970,5958,6944,7928,8910,9890,10868,11844,12818,13790,14...
18:01:10 <mauke> huh?
18:01:17 <mauke> oh, right
18:01:19 <Cale> [31875000]
18:01:19 <Cale> (3.53 secs, 278390448 bytes)
18:01:31 <sjanssen> > [a * b * c | a <- [1 .. 1000], b <- [a .. 1000], c <- [b .. 1000], a + b + c == 1000, a^2 + b^2 == c^2]
18:01:33 <Cale> [a*b*c | a <- [1..1000], b <- [a..1000], let c = 1000 - b - a, a^2 + b^2 == c^2]
18:01:35 <lambdabot> Terminated
18:01:40 <Cale> > [a*b*c | a <- [1..1000], b <- [a..1000], let c = 1000 - b - a, a^2 + b^2 == c^2]
18:01:40 <mauke> that's what I meant
18:01:44 <lambdabot>  [31875000]
18:01:53 <chessguy> whoah
18:01:57 <chessguy> you can do that?
18:02:01 <Cale> sure
18:02:07 <Limbic_Region> TTFN al
18:02:08 <chessguy> that's...insane
18:02:22 <chessguy> how the heck does it actually evaluate that?
18:02:32 <dwm> That was really cool, that comprehension.
18:02:32 <lispy> chessguy: iteration
18:02:45 <Cale> by trying all possible a's, and for each, all possible b's
18:02:53 <Cale> and testing the guard condition
18:02:57 <lispy> > [(x,y) | x <- [1..5], y <- [1..5]]
18:02:58 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
18:03:01 <chessguy> that's really fast though
18:03:17 <syntaxfree> good evening.
18:03:20 <chessguy> how does it get that speed
18:03:23 <mauke> > do { a <- [1..000]; b <- [a .. 1000]; let c = 1000 - b - a; guard (a^2 + b^2 == c^2); return (a*b*c)}
18:03:24 <lambdabot>  Parse error
18:03:50 <deadbeef> wondering how can i get all the permutations of 1..n using haskell
18:03:54 <deadbeef> with O(n)
18:03:54 <Cale> by computing the ordered triples, and not the unordered ones, for one
18:04:06 <deadbeef> i did it in C
18:04:17 <Cale> deadbeef: you mean O(n!)?
18:04:18 <lispy> O(n) permutations?
18:04:30 <deadbeef> Cale: nop, i did it in O(n)
18:04:34 <sjanssen> > do { a <- [1..000]; b <- [a .. 1000]; let {c = 1000 - b - a}; guard (a^2 + b^2 == c^2); return (a*b*c)}
18:04:35 <lambdabot>  []
18:04:39 <syntaxfree> I'm finding it easier to predict the time complexity of simple Haskell programs as time goes by.
18:04:44 <deadbeef> lispy: nop, all the permutations of 1..n in O(n)
18:04:48 <lispy> a <- [1..1000]
18:04:51 <lispy> you'r missing the 1
18:04:56 <syntaxfree> Memory space is a different thing, though.
18:04:56 <Cale> deadbeef: there are n! permutations, which you couldn't write into memory or onto the screen in O(n) time
18:05:07 <deadbeef> op sorry
18:05:10 <deadbeef> a random permutation
18:05:25 <Cale> oh, that's different
18:05:25 <chessguy> i'll brb, my machine's running really hot and slow for some reason
18:05:28 <sjanssen> @undo do { a <- [1..1000]; b <- [a .. 1000]; let {c = 1000 - b - a}; guard (a^2 + b^2 == c^2); return (a*b*c)}
18:05:29 <lambdabot> [1 .. 1000] >>= \ a -> [a .. 1000] >>= \ b -> let { c = 1000 - b - a} in guard (a ^ 2 + b ^ 2 == c ^ 2) >> return (a * b * c)
18:05:36 <deadbeef> yes all the perms isn't possible in O(n)
18:05:37 <Cale> You'd do it in much the same way you would in C.
18:05:44 <sjanssen> @, pl undo do { a <- [1..1000]; b <- [a .. 1000]; let {c = 1000 - b - a}; guard (a^2 + b^2 == c^2); return (a*b*c)}
18:05:45 <lambdabot> Maybe you meant: . v
18:05:49 <deadbeef> Cale: in C i used an array
18:05:52 <Cale> I have a page where someone asked the same question
18:05:56 <deadbeef> in haskell lists have a sequential access
18:05:58 <sjanssen> @. pl undo do { a <- [1..1000]; b <- [a .. 1000]; let {c = 1000 - b - a}; guard (a^2 + b^2 == c^2); return (a*b*c)}
18:06:01 <lambdabot> (line 1, column 51):
18:06:01 <lambdabot> unexpected "{"
18:06:01 <lambdabot> expecting natural, identifier or "in"
18:06:02 <lisppaste2> syntaxfree pasted "this doesn't do what I expected it to. " at http://paste.lisp.org/display/25674
18:06:20 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
18:06:22 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
18:06:36 <syntaxfree> @type guard
18:06:37 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:07:06 <Cale> deadbeef: adapting the method I used there to use arrays instead of lists would not be hard
18:07:23 <Cale> deadbeef: (look for my response at the bottom)
18:07:52 <deadbeef> thanks a lot
18:07:53 <deadbeef> !
18:07:54 <lambda_the_insig> anyone know of an existing haskell imagemagick binding?
18:11:02 <chessguy> err, what's the notation for a is in [1..1000]
18:11:07 <lispy> lambda_the_insig: hmm...i think one exists
18:11:25 <lispy> @google image magick haskell
18:11:27 <lambdabot> http://www.free2code.net/plugins/forums/view.php?f=8&p=47121
18:12:50 <lispy> lambda_the_insig: oh maybe not...
18:12:52 <Cale> chessguy: from the above?
18:12:59 <lispy> lambda_the_insig: may be not that hard to make though
18:13:01 <chessguy> yes
18:13:03 <Cale> > [a*b*c | a <- [1..1000], b <- [a..1000], let c = 1000 - b - a, a^2 + b^2 == c^2]
18:13:06 <lambdabot>  [31875000]
18:13:16 <Cale> a <- [1..1000]
18:13:30 <chessguy> > 3 <- [1..5]
18:13:31 <lambdabot>  Parse error
18:13:36 <lispy> > do { a <- [1..1000]; return a }
18:13:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:13:45 <chessguy> > 3 <-[1..5]
18:13:46 <lambdabot>  Parse error
18:13:47 <Cale> It only works in list comprehensions and do-notation :)
18:13:51 <chessguy> bah
18:13:57 <wkh> does haskell let you have lists with different kinds of values in them?
18:13:59 <Cale> > 3 `elem` [1..5]
18:14:01 <lambdabot>  True
18:14:04 <sjanssen> wkh: no
18:14:05 <Cale> wkh: no
18:14:09 <wkh> that's fucking gay
18:14:22 <Cale> wkh: It's quite alright
18:14:43 <wkh> how is that ok
18:15:08 <Cale> It just never comes up that you want a list with things of different types in it
18:15:11 <Cale> and for the times when you *really* think you need it, there are existential types.
18:15:32 <Cale> Well, also there's Dynamic
18:16:06 <chessguy> > primes !! 1000
18:16:07 <lambdabot>  Not in scope: `primes'
18:16:12 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
18:16:27 <wkh> i can think of situations where i have a big tree-like structure with strings and numbers in it
18:16:41 <Cale> wkh: then make a new datatype
18:16:56 <Cale> wkh: Which enforces the particular tree-like structure you want
18:17:04 <Cale> and tags values appropriately
18:17:11 <clanehin> wkh learn how the type system works before whining about it
18:17:15 <Cale> Lists are not an appropriate approximation to trees :)
18:18:53 <Deformative-II> People are telling me to learn C before haskell, I was planning on doing so after haskell,  shoudl I listen to them or no?
18:19:28 <Cale> I learned C before Haskell, and I'd say learn it after :)
18:19:33 <chessguy> i must say, Haskell is awfully cool
18:19:35 <Pupeno> Hello.
18:19:58 <lispy> Deformative-II: just learn both and don't worry about the order...maybe learn them at the same time?
18:20:06 <Pupeno> Type declarations, as any other thing, can be spawned into various lines, right ?
18:20:38 <chessguy> it makes me mad that in my entire 4 years studying comp sci, they're going to spend a grand total of maybe a couple weeks teaching me about paradigms other than imperative and OO
18:21:13 <Korollary> No reason to be mad.
18:21:30 <monochrom> I learned BASIC before I learned machine code, if that's any consolation for you.
18:21:43 <chessguy> i started with dartmouth basic
18:21:51 <jgrimes> yeah, our comp sci program doesn't have any functional programming courses, which is why I got proactive about the issue
18:22:02 <Deformative-II> Be right back, I need to restart x.
18:22:02 <emu> which school
18:22:11 <chessguy> i'm at PSU
18:22:23 <jgrimes> I'm at NCSU, in the US
18:22:39 <chessguy> hmm. hugs keeps crashing when i do primes !! 10000
18:22:41 <lispy> chessguy: oh, hey i'm at OSU
18:22:46 <monochrom> In addition, all CS curricula teach a HLL first before going under the hood.  By this token, Haskell should go before C, and C before the hardware.
18:23:00 <chessguy> OSU? Oregon? Ohio?
18:23:03 <emu> here they start off with Java these days, then theory guys use SML
18:23:07 <lispy> monochrom: at my school they teach C then move to java
18:23:16 <lispy> chessguy: oregon
18:23:22 <chessguy> ah
18:23:25 <Korollary> monochrom: A lazy language makes it tough when teaching complexity theory, though. Scheme is a better candidate imho.
18:23:44 <Korollary> or SML
18:24:17 <emu> they're in love with Sun here though
18:24:35 <Korollary> javaschools
18:24:50 <monochrom> Whatever your opinion is, you must answer this question first: In your opinion, should it be high-level stuff then low-level stuff, or should it be the other way round?  Then that fixes the only rational order according to your own answer.
18:25:02 <emu> prob cause a bunch of the java designers graduated here
18:25:18 <jgrimes> yeah, we are a java school =/
18:25:19 <monochrom> For example if you go like C -> Java -> hardware or C -> hardware -> Java, you're being inconsistent.
18:25:34 <Korollary> monochrom: Where did hardware get in?
18:25:48 <monochrom> Assembly language programming.
18:26:02 <chessguy> yes, no university program goes in any real kind of order, i think
18:26:05 <Korollary> ASM is largely irrelevant.
18:26:09 <monochrom> Understanding how to command your computer in various ways, at various levels of abstraction.
18:26:26 <clanehin> monochrom: no, I think it would be reasonable to teach python and asm, and then move on to C -- the first two introduce fundamental concepts, while C is just a pragmatic mess that you need to know to graduate
18:26:38 <chessguy> the whole notion of separating things into a bunch of semester long courses is pretty silly
18:26:44 <monochrom> "language" is actually irrelevant.  It is more about how and what things you do at what level.
18:26:46 <emu> CS and practical programming are two different things really
18:26:57 <bonfyre> my uni did ASM and Java concurrently, then C, then Python & Perl... which is a bit of a messed up order
18:28:49 <chessguy> ok, time for a dumb question
18:29:14 <chessguy> why is it foldr (+) 0 [1..10] instead of foldr + 0 [1..10]
18:29:27 <emu> syntax requierment
18:29:27 <deadbeef> because (+) is a function
18:29:41 <monochrom> What fundamental concepts?  To me, fundamental concepts means understanding the computer.  But the computer is an onion --- many levels.  It seems to me there are only two coherent ways of understanding this onion: inside-out, or outside-in.
18:29:54 <chessguy> very true monochrom
18:30:13 <emu> there is a notion of "computation" which can be studied independently of any physical computer
18:30:27 <Korollary> monochrom: True. But I don't think you need to include the asm level. At least, not all of asm needs to be mentioned.
18:30:31 <chessguy> emu: a la Wolfram?
18:30:33 <monochrom> Yes, that is one of the middle layers, emu.
18:30:36 <emu> indeed the first computer scientists had no such luxury
18:30:46 <deadbeef> > let 3 + 1 = 69 in map (+1) [1..5]
18:30:48 <lambdabot>  Non-exhaustive patterns in function +
18:31:10 <clanehin> monochrom: I think that "low-level" and "high-level" concepts are both important, and I know for a fact that you can teach from either end, I'm not aware of any important "middle-level" concepts
18:31:24 <deadbeef> > let (+1) 3 = 69 in map (+1) [1..5]
18:31:25 <lambdabot>  Parse error in pattern
18:31:52 <deadbeef> > map (+1) [1..5]
18:31:54 <lambdabot>  [2,3,4,5,6]
18:31:59 <emu> the meaning of "low level" and "high level" is subject to some different interpretations
18:32:20 <monochrom> "Haskell" could be one of the "computation" of emu.  That means you look at a very outer layer of "computation".
18:32:36 <GeoffSK> Q: where do i get a socket.dll for hugs?
18:32:45 <emu> "Haskell" is indeed a "Model of Computation"
18:32:56 <emu> much like Lambda Calculus or Turing Machines are
18:33:14 <monochrom> Yes.
18:34:03 <deadbeef> > let f 1 = 2 in map f [1,2]
18:34:05 <lambdabot>  Non-exhaustive patterns in function f
18:34:13 <deadbeef> > let f 1 = 2; f 2 = 4 in map f [1,2]
18:34:14 <lambdabot>  [2,4]
18:36:04 <chessguy> foldr (+) 0 (takeWhile (< 1000000) primes)
18:36:06 <chessguy> > foldr (+) 0 (takeWhile (< 1000000) primes)
18:36:07 <lambdabot>  Not in scope: `primes'
18:36:11 <chessguy> bah
18:36:19 <deadbeef> > let (+) x y = x in 1 + 2
18:36:20 <lambdabot>  1
18:36:48 <deadbeef> > let (+) x y = x in map (+1) [1..5]
18:36:49 <lambdabot>  [1,2,3,4,5]
18:39:24 <Korollary> ?users
18:39:28 <lambdabot> Maximum users seen in #haskell: 242, currently: 214 (88.4%), active: 33 (15.4%)
18:41:08 <deadbeef> ?type RandomGen
18:41:09 <lambdabot> Not in scope: data constructor `RandomGen'
18:41:37 <deadbeef> ?type RandomRIO
18:41:39 <lambdabot> Not in scope: data constructor `RandomRIO'
18:41:48 <deadbeef> ?type randomRIO
18:41:50 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:41:54 <deadbeef> ooh here we go
18:43:08 <chessguy> what the heck does that definition mean?
18:43:50 <monochrom> are you referring to randomRIO
18:44:00 <deadbeef> > randomRIO (0::Int, 5)
18:44:01 <lambdabot>  No IO allowed
18:44:05 <chessguy> [21:40] <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:44:29 <monochrom> Do you already understand "(a,a) -> IO a" ?
18:44:55 <deadbeef> wondering how could i workaround that "IO a" thing
18:45:03 <chessguy> no, i don't
18:45:05 <chessguy> i'm a n00b
18:45:14 <deadbeef> maybe there's another function that simply outputs an Integer
18:45:22 <SamB> @doc System.Random
18:45:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
18:45:26 <monochrom> Do you understand things like "IO Int", "IO Char", "IO a", etc.?
18:45:42 <SamB> there are some pure things in that module too...
18:45:53 <chessguy> mmm, no.
18:46:06 <chessguy> i take it IO in this context isn't input/output
18:46:10 <monochrom> OK, you need more help than I can afford
18:46:23 <chessguy> ok
18:46:25 <deadbeef> ?type random
18:46:27 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
18:46:56 <SamB> chessguy: it involves a global variable... really quite icky...
18:47:13 <monochrom> But in short, randomRIO (10,20) returns a random number between 10 and 20, inclusive.  If you now ask: integer or double?  Answer: you have the say!
18:47:27 <chessguy> ewwww
18:47:35 <chessguy> monads?
18:47:37 <deadbeef> > random 5
18:47:38 <lambdabot>  Add a type signature
18:47:42 <deadbeef> > random 5::Int
18:47:43 <dons> moin
18:47:44 <lambdabot>  Couldn't match `Int' against `(a, g)'
18:47:53 <monochrom> If you write like randomRIO (10::Int, 20), you're forcing it to be integer, for example.
18:47:59 <deadbeef> > random (0::Int, 5)
18:48:00 <lambdabot>  add an instance declaration for (RandomGen (Int, b))
18:48:00 <lambdabot>   In the definition ...
18:48:21 <deadbeef> > random (RandomGen (0::Int, 5))
18:48:21 <monochrom> I think it's time for me to write the second section of my random tutorial :)
18:48:22 <lambdabot>  Not in scope: data constructor `RandomGen'
18:48:57 <monochrom> deadbeef: are you sure you must get rid of the IO part?  You know, most often you don't have to.
18:49:34 <deadbeef> just because lambdabot doesn't allow IO
18:49:54 <monochrom> Ah ok, that's a minor problem.
18:50:10 <dons> ?users #haskell
18:50:11 <lambdabot> Maximum users seen in #haskell: 242, currently: 214 (88.4%), active: 35 (16.4%)
18:50:16 <dons> oh! new high score!
18:50:20 <monochrom> Do you already know how to use randomRIO etc.?
18:50:20 <jgrimes> yep :)
18:50:27 <deadbeef> i think yes
18:50:41 <deadbeef> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers is awesome
18:50:43 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
18:50:52 <monochrom> Then you're good.  You can test things on your own ghci or hugs.
18:51:49 <SamB> @type random
18:51:51 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
18:51:58 <SamB> @instances RandomGen
18:52:00 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
18:52:12 <SamB> @instances-importing System.Random RandomGen
18:52:13 <lambdabot> StdGen
18:52:23 <SamB> @hoogle StdGen
18:52:24 <lambdabot> System.Random.StdGen :: data StdGen
18:52:24 <lambdabot> Random.getStdGen :: IO StdGen
18:52:24 <lambdabot> Random.mkStdGen :: Int -> StdGen
18:52:52 <SamB> > random (mkStdGen 0)
18:52:53 <lambdabot>  Add a type signature
18:52:56 <SamB> > random (mkStdGen 0) :: Int
18:52:57 <lambdabot>  Couldn't match `Int' against `(a, g)'
18:53:02 <SamB> oh right
18:53:09 <SamB> > fst $ random (mkStdGen 0) :: Int
18:53:10 <lambdabot>  2092838931
18:54:33 <Cale> Heh, it'd be awesome to have one of those eye-charts they make you read, only with various mathematical symbols on it. Rather than a big "E" at the top, it would be a "there exists" :)
18:55:04 <dons> heh
18:55:11 <Korollary> Cale: You are h......
18:55:20 <SamB> only those aren't an alphabet, so people wouldn't necessarily be familiar with all the same ones...
18:55:21 <thetallguy> Unnecessary comment to bump the users stat.
18:55:31 <chessguy> Cale: that would make for a cool t-shirt
18:55:38 <Cale> chessguy: yeah :)
18:55:48 <SamB> thetallguy: why are you making an unnecessary comment to boost your stat?
18:56:07 <thetallguy> ?users #haskell
18:56:08 <lambdabot> Maximum users seen in #haskell: 242, currently: 213 (88.0%), active: 35 (16.4%)
18:56:18 <SamB> oh, *that* users stat...
18:56:50 * SamB thought he was trying to increase his placement in the 10 most wanted yakkers list...
18:56:55 <thetallguy> D'oh!  Prip left the room.
18:56:56 <SamB> or whatever
18:57:05 <thetallguy> Nah.
18:57:11 <thetallguy> Not that much of a yakker.
18:57:22 <SamB> which wouldn't really work well unless you were really far down...
18:58:36 <dons> 35 active is pretty high
18:58:58 <lispy> heya dons, i'm trying to keep ya busy with patches :)
19:00:01 <dons> yep got them!
19:00:03 <dons> lispy++=
19:00:05 <dons> lispy++
19:00:19 <dons> now, just have to write a plugin to the new haskell termination checker
19:00:34 <dons> ?where aprove http://aprove.informatik.rwth-aachen.de/
19:00:35 <lambdabot> I know nothing about aprove.
19:00:38 <lispy> oh, cool
19:00:41 <dons> ?where+ aprove http://aprove.informatik.rwth-aachen.de/
19:00:42 <lambdabot> Done.
19:01:00 <dons> oh urgh jar-file
19:01:25 <dons> ah but maybe i can use the web interface
19:01:45 <stepcut> heh
19:02:02 <lispy> so we know that to be a tricky problem, how much can they actually detect?
19:02:09 <stepcut> they wrote a haskell termination checker in java ? :-/
19:02:25 <thetallguy> snort
19:03:15 <dons> "Please select a timeout"
19:03:20 <stepcut> at least they have some graphs to make things easy to understand: http://aprove.informatik.rwth-aachen.de/images/snapshot3.gif
19:03:40 <stepcut> ;)
19:04:00 <lispy> very easy
19:04:04 <lispy> now if i could just read it...
19:04:11 <dons> heh
19:04:12 <thetallguy> Ah, very clear
19:04:18 <thetallguy> looks like a matchbox track
19:04:29 <dons> it's noodle soup!
19:04:33 <stepcut> haha
19:04:37 <thetallguy> lol
19:05:06 <lispy> oh hey, it's a dependency grah
19:05:10 <lispy> graph*
19:06:01 <dons> oh , interesting, i wonder if we could prove termination of rewrite rules in ghc this way
19:06:15 <stepcut> heh
19:09:15 <lispy> "Please select a module to be loaded additionally to the Prelude"
19:09:27 <dons> java.lang.RuntimeException: aprove.Framework.Haskell.HaskellError: types are not unifiable
19:09:28 <lispy> 'a' module?  man, no frills :)
19:10:02 <dons> yay, H-Termination of the given Haskell-Program with start terms could successfully be proven:
19:10:57 <thetallguy> stepcut: what file were you editing yesterday?
19:12:25 <Korollary> Hmm, they can prove termination for some terms. They time out on others, etc.
19:13:10 <lispy> well, it's been correct about two programs so far
19:13:33 <Korollary> It could be useful in an IDE actually.
19:13:36 <lispy> x = x was probably too easy though
19:13:40 <jgrimes> write a program to find an odd perfect number and see what it says
19:13:54 <lispy> or an odd prime
19:14:04 <lispy> er
19:14:08 <jgrimes> ;p
19:14:09 <lispy> heh, even prime != 2
19:14:25 * lispy types before thinking sometimes...he admits it
19:16:08 <lispy> ?type any
19:16:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:16:13 <lispy> ?hoogle any
19:16:14 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
19:16:14 <lambdabot> Text.ParserCombinators.Parsec.Char.anyChar :: CharParser st Char
19:16:14 <lambdabot> Text.ParserCombinators.Parsec.Combinator.anyToken :: Show tok => GenParser tok st tok
19:16:22 <lispy> hmm...it doesn't have the any function
19:16:27 <lispy> ?type even
19:16:29 <lambdabot> forall a. (Integral a) => a -> Bool
19:17:08 <emu> since 2 is the only even prime, doesn't that make it a bit "odd"? :P
19:17:16 <lispy> oh, n/m "import qualified Prelude" tripped me up
19:18:58 <lispy> yeah, i think it's not so good at finding termination when searching for an even prime greater than 2
19:20:27 <emu> we could solve all world problems if only we could find an even prime > 2!!
19:23:01 <lispy> emu: it might exist....you never know
19:23:12 <lispy> so.... i dunno...
19:23:30 <lispy> i think firefox crashed or is not terminating on their proof of non-termination
19:23:45 <lispy> oh, no just had to wait 5 minutes :)
19:24:36 <lispy> it's impressive all the work it does
19:31:38 <lispy> ?hoogle getBounds
19:31:39 <lambdabot> No matches found
19:35:10 <dons> the ghc is too old
19:36:54 <lispy> dons: when was getBounds added?
19:37:18 <lispy> someone with 6.4 says they're getting an error about getBounds not being in scope when compiling darcs
19:37:42 <lispy> but darcs checks #if __GLASGOW_HASKLLE__ > 604 ... getBounds #else .. bounds ...
19:38:04 <lispy> i would think 6.4 would hit the else branch
19:38:19 <monochrom> GLASGOW_HASKLLE  is this spelt right?
19:38:31 <lispy> that was my typo
19:38:37 <lispy> #if __GLASGOW_HASKELL__ > 604
19:38:44 <lispy> that's the cut 'n paste that time
19:42:26 <emu> lispy: sure, an even number not divisible by 2
19:49:40 <emu> is there a better way of saying: case ... of Just x -> x ; Nothing -> undefined?
19:50:04 <SamB> fromJust might be a better way...
19:51:47 <dons> ?type maybe
19:51:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:52:15 <dons> ?docs Data.Maybe
19:52:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
19:52:39 <lispy> mabye is good when you have defaults
19:52:45 <dons> getBounds was added hmm, 1 week ago?
19:53:07 <lispy> i wonder why his 6.4 compiler was getting tripped up
19:53:13 <lispy> it really should have hit the else branch
19:53:41 <lispy> i told him to remove the 'if' and the 'then' for now and just compile the else part
19:55:07 * lispy switches to old glasses as he just can't sit and read with the new ones :(
20:02:19 <Cale> ahaha, I love Ashley Yakeley's response to Stephan Swiderski's announcement of an automatic Haskell98 termination analyzer.
20:02:39 <lispy> where is that?
20:02:42 <lispy> url please!
20:02:46 * lispy jumps up an down
20:02:51 <Cale> Haskell mailing list
20:02:51 <lispy> i want to read it tooo!!!!
20:03:00 <lispy> oh...i didn't seee it.../me checks again
20:03:01 <Cale> [Haskell] ANN: Haskell98 termination analyzer (AProVE)
20:03:13 <Korollary> It's a premature argument
20:03:27 <lispy> hm...
20:03:37 <lispy> i must not be on 'haskell', i'm on libraries and cafe
20:03:48 <Korollary> It's on haskell.general.
20:04:29 <Cale> http://www.haskell.org/pipermail/haskell/2006-September/018457.html
20:04:31 <lambdabot> Title: [Haskell] ANN: Haskell98 termination analyzer (AProVE), http://tinyurl.com/o3gwg
20:04:34 <Cale> http://www.haskell.org/pipermail/haskell/2006-September/018460.html
20:04:36 <lambdabot> Title: [Haskell] Re: ANN: Haskell98 termination analyzer (AProVE), http://tinyurl.com/er4om
20:05:32 <lispy> ah, google groups calls it fa.haskell
20:06:54 <lispy> heh, nice response, ya
20:16:00 <lispy> hmm...usenet is sort of dead huh?
20:21:30 <deadbeef> ?type repeat
20:21:32 <lambdabot> forall a. a -> [a]
20:24:19 <chessguy> ?type map
20:24:20 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
20:31:30 <dons> ?quit new code
20:32:16 <dons> ?version
20:32:44 <lambdabot> lambdabot 4p156, GHC 6.5 (OpenBSD i386 )
20:32:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:32:50 <dons> ?help ft
20:32:58 <lambdabot> ft <ident>. Generate theorems for free
20:33:02 <dons> ft id
20:33:09 <dons> ?ft id
20:33:10 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
20:33:11 <lambdabot>   forall x1 :: T1.
20:33:11 <lambdabot>    h1 (t1 x1) = t1 (h1 x1)
20:33:16 <dons> ?free id
20:33:17 <lambdabot> f . id = id . f
20:33:32 <dons> ?ft map
20:33:34 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
20:33:34 <lambdabot>   forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
20:33:34 <lambdabot>    forall f1 :: T3 -> T1.
20:33:34 <lambdabot>     forall g1 :: T4 -> T2.
20:33:34 <lambdabot>      (forall x2 :: T3.
20:33:35 <lambdabot>       h1 (f1 x2) = g1 (h2 x2))
20:33:46 <dons> ?free map
20:33:47 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
20:40:42 <glguy> 81/* :-D
20:41:17 <glguy> 9 problems to go
20:41:30 <glguy> I just got back... what'd I miss?
20:41:41 <dons> nice work glguy
20:41:45 <dons> ?users
20:41:46 <lambdabot> Maximum users seen in #haskell: 242, currently: 206 (85.1%), active: 4 (1.9%)
20:41:51 <dons> we hit a new high score :)
20:42:30 <glguy> Hey... you haven't had time to get GHCI working on OpenBSD... have you?
20:43:06 <dons> its on the todo list. need to update to a 4.0 snapshot
20:43:12 <dons> then i'll post some ghc 6.4.2 and 6.6 binaries
20:43:14 <deadbeef> is it difficult to port ghc ?
20:43:18 <dons> should be pretty easy to fix
20:43:27 <dons> deadbeef: hmm, a little. easier than porting gcc
20:43:32 <dons> deadbeef: what arch?
20:43:43 <deadbeef> netbsd/sparc64
20:43:44 <dons> its already been ported to most things anyway
20:43:47 <deadbeef> or linux/arm
20:44:01 <dons> sparc64/linux runs, so does linux/arm. so netbsd/sparc64 should be doable.
20:44:11 <dons> i think the arm has some floating point issues? check with Igloo
20:44:13 <dons> he was doing the arm port
20:44:23 <deadbeef> i have a ultra workstation here, if it's simple i can try
20:44:42 <deadbeef> (with netbsd on it)
20:44:52 <dons> deadbeef: you hvae to follow the porting guide in the ghc user's guide.
20:44:59 <deadbeef> ok, thanks
20:45:08 <dons> and you need one other machine with ghc installed, to first generate .hc files on
20:45:17 <dons> which you copy over to the target machine, and finish building with gcc
20:52:45 <Cale> dons: almost time to do another darcs checkpoint for yi :)
20:55:06 <dons> whoa 589
20:55:09 <dons> i didn't realise that
20:55:25 <dons> yes, should tag 0.2
20:58:31 <stepcut> I was trying to hack on the yi emacs keybindings a few days ago, but the handling of the 'meta' key seemed broken :-/
21:00:45 <dons> use emacs2 or mg
21:00:58 <dons> i should remove the plain 'emacs' binding, its not even close to finished
21:01:06 <stepcut> I think emacs2 imports emacs
21:01:13 <stepcut> but emacs2 was the one I was using
21:01:43 <glguy> 79/* :-D
21:02:45 <dons> hey lennart
21:05:22 <stepcut> everything I try to do M-<something> it says, "Key sequence not defined : ESC [27]" (always 27)
21:05:32 <stepcut> haven't been able to track it down yet
21:05:45 <stepcut> C-<something> works though
21:08:56 <dons> hmm. weird
21:11:24 <Cale> here's an idea... text editors should syntax highlight contextually, so for instance, the line or function which you're working on could get more colour, for instance, painting variables so as to make them easy to follow through the code (would work especially well if it could detect shadowing), while the others would get basic structural colouring.
21:20:44 <glguy> That's crazy talk!
21:27:20 <Korollary> How about this: ghc-server like emacs server loads into memory and ghc is not restarted for every little file to be compiled.
21:27:55 <dons> yes, using ghc-api is probably the only way to do things. but i'm inclined to instead write a ghc-api binding from vim and emacs. might be more profitable
21:27:57 <lispy> Korollary: that's maybe how they do it with the ghc-api?
21:28:14 <dons> since getting yi or hIDE to emacs/vim standard is too much work
21:28:40 <lispy> the biggest problem (at least in visual haskell) with the ghc-api is that if there is one tiny little error in the file you get no results
21:29:16 <lispy> using visual haskell i endup with a lot of foo = undefined
21:29:32 <lispy> just so i can get thing feedback
21:29:40 <dons> we should be able to avoid that
21:29:48 <dons> i.e. don't change things on errors from ghc-api
21:30:18 <midfield> dons: in Binary / NewBinary is list deserialization lazy?
21:31:14 <midfield> e.g. if i have serialized [a], does take 1 (get bh) deserialize the whole list?
21:31:23 <lispy> dons: it would be even better if ghc-api could say, "oh tha thing has a problem, now we pretend like it doesn't exist or it's working and try to analyze the rest"
21:31:42 <dons>     put_ bh l =
21:31:42 <dons>     do put_ bh (length l)
21:31:42 <dons>        mapM (put_ bh) l
21:31:42 <dons>        return ()
21:31:42 <dons>     get bh =
21:31:45 <dons>     do len <- get bh
21:31:47 <dons>        mapM (\_ -> get bh) [1..(len::Int)]
21:32:22 <midfield> i'm a noob!  i don't understand laziness of mapM.
21:32:54 <dons> looks lazy to me
21:33:00 <dons> since len is just an Int field
21:33:00 <midfield> sweet!
21:33:18 <midfield> i guess the proof will be in the profiling
21:33:33 <dons> yep
21:33:33 <lispy> but i thought the proof was in the pudding
21:33:57 * Korollary kills lispy 
21:36:15 * lispy x_X
22:11:58 <Korollary> Hmm. haskell-doc.el has the type of print wrong. Heh.
22:13:34 <glguy> (Show a) => a -> IO ()  ?
22:15:24 <Korollary> It shows (Show a) => IO ()
22:19:13 <Korollary> Bah
22:19:38 <nuffer> has anyone here worked with HOC before?
22:19:45 <Korollary> In Data.Graph, why is type Vertex = Int? Why can't I use any Show?
22:20:08 <nuffer> or any idea why I get "parse error on input `,'" in lots of .conf-inplace files?
22:21:23 <lisppaste2> midfield pasted "Monad question" at http://paste.lisp.org/display/25679
22:21:46 <midfield> ok folks, i'm having trouble satisfying the type checker.
22:21:47 <emu> @type print
22:21:48 <lambdabot> forall a. (Show a) => a -> IO ()
22:23:20 <midfield> i want to write a function which takes the output of dumpSortedChunks (which is IO [BinHandle]) and produces an IO [[a]], e.g. reads back in the [a]'s.
22:25:36 <midfield> this is the beginnings of an external (offline) sort: i take a list of stuff, break them up into chunks, sort those chunks, dump them to disk, then (eventually) perform a mergesort reading them back from the disk.  i've gotten to the point of dumping them to files and getting the list of handles.
22:26:57 <gour> anyone know if linspire folks are doing something with Qt bindings?
22:28:36 <Korollary> midfield: what is the error message?
22:29:06 <midfield> Korollary: let me make a paste
22:31:22 <lisppaste2> midfield annotated #25679 with "my failing effort" at http://paste.lisp.org/display/25679#1
22:32:35 <Korollary> I don't see a mapM, though.
22:33:30 <midfield> return (mapM get hs)
22:34:08 <Korollary> oops
22:36:18 <Korollary> What's get?
22:37:02 <midfield> get is a function on the class Binary which has signature (Binary b) => BinHandle -> b.  it reads a thing of type b off a binary handle.
22:37:19 <Korollary> not IO b?
22:37:29 <midfield> yes, IO b, sorry.
22:39:16 <Korollary> type of mapM get hs is IO [b] then?
22:40:20 <midfield> yes, but the thing about "get" is you force the type of the output to the thing you know is stored in the file.  i just dumped [a]'s into files, so i should get IO [[a]] out of mapM get hs.
22:40:45 <Korollary> return $ mapM get hs won't give IO [[b]], though.
22:41:08 <glguy> > evalState (mapM (\x -> get >>= \n -> put x >> return n) [1,4,2,7]) 0
22:41:09 <lambdabot>  [0,1,4,2]
22:41:51 <glguy> > runState (mapM (\x -> get >>= \n -> put x >> return n) [1,4,2,7]) 0
22:41:52 <lambdabot>  ([0,1,4,2],7)
22:42:03 <glguy> Seems like a reasonable enough way to shiftR
22:42:05 <glguy> ;)
22:43:06 <midfield> Korollary: I don't understand.
22:43:24 <lispy> glguy: cool example
22:43:35 <lispy> glguy: really helps to show how the state monad works
22:43:49 <Korollary> midfield: you have IO [b]. Returning that won't produce IO [[b]]
22:43:50 <glguy> I'm pretty sure you are being sarcastic ;)
22:44:29 <lispy> glguy: not, i mean it, there is a bit going on but it's all pretty simple and easy to see
22:45:26 <midfield> Korollary: let me rephrase.  i have [[a]].  i dump the [a]'s into BinHandles and sequence, so I get IO [BinHandle].  now i want to read the [a]'s back out, to get a list of [a]'s (in the IO monad.)
22:45:46 <midfield> by the types, get should "know" that i'm expecting a [a] out of each file.
22:46:14 <glguy> > runState (mapM (\x -> do { n <- get; put x; return n }) [1,4,2,7]) 0
22:46:15 <lambdabot>  ([0,1,4,2],7)
22:46:16 <Korollary> midfield: You said get's type is Handle -> IO a. Not Handle -> IO [a].
22:46:20 <glguy> might be more illustrative
22:48:26 <midfield> but obviously i'm wrong about my reasoning...
22:48:26 <midfield> damn my wireless is really flakey right now.
22:49:02 <midfield> i said get's type is (Binary b) => BinHandle -> IO b.  in this case, b = [a].
22:57:46 <Korollary> midfield: The annotation above externalSort leads to the error message. For that type to work, (mapM get hs) should produce [[a]], but it produces IO [[a]].
22:58:53 <Korollary> You apparently dont need the return.
23:01:09 <midfield> whoa
23:01:13 <midfield> thanks
23:01:21 <midfield> i'm going to have to meditate on that one...
23:02:34 <lispy> well, return is for injecting values into monads
23:03:51 <midfield> i see. so return "foo" is IO String, but "foo" is String.  mapM ...yields IO [b], so i don't need to do return mapM ...
23:05:58 <lispy> > return 1 :: [Int]
23:05:59 <lambdabot>  [1]
23:06:20 <midfield> ok that was wrong... :P
23:06:24 <lispy> 'return' itself doesn't decide the monad :)
23:06:29 <lispy> > return 1 :: IO Int
23:06:30 <lambdabot>  No IO allowed
23:06:44 <midfield> ah, you're using the list monad!
23:06:52 <lispy> sneaky, huh :)
23:07:00 <lispy> :t runState
23:07:11 <lispy> ?type runState
23:07:12 <lambdabot> forall s a. State s a -> s -> (a, s)
23:07:29 <lispy> > return 1 :: State Int Int
23:07:30 <lambdabot>  add an instance declaration for (Show (State Int Int))
23:07:46 <lispy> hm...that one is harder to demonstrate i guess
23:08:08 <lispy> ?type return
23:08:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
23:08:22 <glguy> > fix (\ ~(x,y,z) -> (1,x,y))
23:08:23 <lambdabot>  (1,1,1)
23:08:39 <therp> is there anything in haskell that allows the subversion of the control flow like scheme continuations? (I haven't yet finished wondering if this even makes sense in the light of monads and lazyness)
23:09:04 <lispy> therp: there is a continuation monad
23:09:29 <therp> lispy: ah thanks for the hint. /me will have a look
23:09:32 <lispy> therp: in fact, monads can and have been used to implement various control structors
23:10:56 <lispy> therp: and the list monad is there for simulating non-deterministic computations
23:19:13 <glguy> > let ordered xs = and $ do { (a:b:bs) <- tails xs;[a<=b] }; permutations [] = [[]] ; permutations xs = do {a <- xs; map (a:)(permutations (a `delete` xs)) }; sort' = fromJust . find ordered . permutations in sort' [5,1,2,7]
23:19:14 <lambdabot>  [1,2,5,7]
23:19:28 <glguy> I wonder if that sorting algorithm has a name ;)
23:19:38 <foxy> therp: look for papers about shift/return operators
23:19:49 <foxy> @google lambda the ultimate
23:19:52 <lispy> glguy: i think i saw something like that in prolog
23:19:52 <lambdabot> http://lambda-the-ultimate.org/
23:19:52 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
23:19:52 <therp> foxy: will do
23:20:16 <lispy> glguy: of course it wasn't destructive, but it did that permutation thing
23:20:24 <therp> LTU is a really nice resource
23:20:38 <lispy> LtU is nice
23:22:29 <foxy> therp: http://lambda-the-ultimate.org/node/606
23:22:31 <lambdabot> Title: How to remove a dynamic prompt: static and dynamic delimited continuation operat ...
23:23:06 <foxy> and papers by Chung-chieh Shan
23:27:43 <glguy> > foldr insert [] [1,5,2,4,7,1,0]
23:27:44 <lambdabot>  [0,1,1,2,4,5,7]
23:32:48 <glguy> > runState (mapM (modify . (:)) [1,2,3,4,5]) []
23:32:50 <lambdabot>  ([(),(),(),(),()],[5,4,3,2,1])
23:36:13 <foxy> @type modify
23:36:14 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
23:36:18 <glguy> > evalState (mapM ((>> get) . modify . (:)) [1,2,3,4,5]) []
23:36:19 <lambdabot>  [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
23:36:38 <lispy> cool
23:36:56 <glguy> I'm going to keep typing in stupid lines of code while eveyone else is quiet
23:37:08 <dons> :)
23:37:18 <foxy> @free evalState (mapM ((>> get) . modify . (:))
23:37:19 <lambdabot> Extra stuff at end of line
23:37:55 <foxy> @free evalState (mapM ((>> get) . modify . (:)))
23:37:56 <lambdabot> Extra stuff at end of line
23:38:02 <glguy> "stuff" very technical
23:38:17 <dcnstrct> Hi. I know this is kind of a troll thing to do, but I want to ask you people to compare Haskell to Common LIsp for me.   I've started to learn CL, I think its amazing.  My whole programming life up to a year ago was spent in C and Java.  Now I'm really starting to appreciate this functional paradigm.  I'd like to know what Haskell can offer to a lisp programmer ?  Can it produce faster code ?  Does it have cool features that enable s
23:38:17 <dcnstrct> tuff that lisp cant do ?   I'm looking for a few good reasons to learn Haskell.
23:38:41 <glguy> How about, "Because isn't isn't really functional"
23:38:46 <glguy> Lisp^
23:38:52 <foxy> dcnstrct: Haskell is strongly typed and referentially transparent
23:38:56 <sieni> glguy: well, lisp has closures
23:39:12 <foxy> @karma lisp
23:39:12 <lambdabot> lisp has a karma of 0
23:39:18 <foxy> @karma Haskell
23:39:18 <glguy> most modern languages do :) even C# does
23:39:18 <lambdabot> Haskell has a karma of 9
23:39:23 <glguy> @karma dons
23:39:24 <lambdabot> dons has a karma of 56
23:39:32 <glguy> by this logic, you should learn "dons"
23:39:48 <dcnstrct> foxy,  well strong typing doesnt sound too impressive.  I've realized what a drag it can be during my java career
23:39:57 <lispy> dcnstrct: yes it can produce faster code
23:40:00 <lispy> @where shootout
23:40:01 <lambdabot> http://shootout.alioth.debian.org/
23:40:03 <sieni> dcnstrct: how?
23:40:11 <lispy> dcnstrct: check the shootout for proof
23:40:12 <glguy> strong typing is wonderful when youalso have "inferred typing"
23:40:14 <foxy> dcnstrct: Does Java have type-inference?
23:40:32 <astrolabe> dcnstrct: The type system for haskell is really REALLY helpful
23:40:44 <foxy> dcnstrct: strong typing eliminates all sorts of potential bugs
23:40:48 <lispy> static typing is only nice when you add things like parametric polymorphism and type classes
23:40:52 <dcnstrct> in java strong typing means you have to type alot of "extra" stuff, and then people use casts anyway so they lose the benifits
23:40:55 <sieni> dcnstrct: you don't have to explicitly give the types of variables in haskell, since haskell can deduce them statically for you during compilation
23:41:17 <dcnstrct> OUUHH
23:41:32 <dcnstrct> now thats impressive
23:41:35 <astrolabe> dcnstrct: It means the compiler catches almost all your bugs, and types are very easy to specify
23:41:57 <sieni> dcnstrct: http://en.wikipedia.org/wiki/Type_inference
23:42:02 <foxy> > 3 (+) True
23:42:02 <Korollary> Lisp is nice. So is haskell. Learn both if you can. Haskell is a bit more "unique", though. And quite a bit more modern.
23:42:03 <lambdabot>     add an instance declaration for (Num ((a -> a -> a) -> Bool -> a1))
23:42:03 <lambdabot>  ...
23:42:20 <dons> like 40 years more modern :)
23:42:28 <dcnstrct> well I'm amazed at how differnet haskell code looks from lisp code
23:42:32 <astrolabe> dcnstrct:  Look at this
23:42:37 <astrolabe> @type map
23:42:38 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:42:49 <lispy> map is like mapcar
23:43:02 <lispy> foldl is like reduce
23:43:03 <astrolabe> that means that the function map takes a function from type a to type b
23:43:12 <astrolabe> and a list of as
23:43:21 <astrolabe> and returns a list of bs
23:43:30 <glguy> Haskell allows you to pass functions around easier... you don't need special "#'" syntax and "apply" and whatnot
23:43:43 <glguy> a list of bullshit?
23:43:51 <astrolabe> > map  (+1)  [3,5]
23:43:53 <lambdabot>  [4,6]
23:43:54 <glguy> takes a list of ass and returns a list of bull?
23:43:57 <lispy> but haskell takes a bit more learning before you can do the equivalent of setf
23:44:03 <foxy> > let sort (x:xs) = [ y | y <- xs, y < x  ] ++ [x] ++ [ y | y <- ys, y > x] in sort $ permute [1..10]
23:44:04 <lambdabot>  Not in scope: `permute'
23:44:22 <glguy> > sequence [(+1),(-1)] 3
23:44:22 <lambdabot>  add an instance declaration for (Num (a -> a))
23:44:23 <lambdabot>   In the list element: (- 1)
23:44:37 <glguy> > sequence [(1-),(1+)] 3
23:44:38 <foxy> > let sort (x:xs) = [ y | y <- xs, y < x ] ++ [x] ++ [ y | y <- ys, y > x] in sort $ ["Rocks","Haskell"]
23:44:38 <lambdabot>  [-2,4]
23:44:39 <lambdabot>  Not in scope: `ys'
23:44:39 <glguy> oops
23:44:52 <foxy> > let sort (x:xs) = [ y | y <- xs, y < x ] ++ [x] ++ [ y | y <- xs, y > x] in sort $ ["Rocks","Haskell"]
23:44:53 <lambdabot>  ["Haskell","Rocks"]
23:44:59 <glguy> and they're off!
23:45:17 <glguy> dcnstrct: one of haskells biggest differences is laziness
23:45:28 <glguy> dcnstrct: let ones = 1 : ones in take 10 ones
23:45:34 <glguy> > let ones = 1 : ones in take 10 ones
23:45:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
23:45:43 <Cale> > let sort (x:xs) = l ++ [x] ++ g where (l,g) = partition (<x) xs in sort ["Rocks", "Haskell"]
23:45:44 <lambdabot>  ["Haskell","Rocks"]
23:45:45 <glguy> dcnstrct: ones is infinitely recursive, but that is ok
23:45:55 <foxy> dcnstrct: a key feature in the implementation of laziness is #haskell :)
23:46:04 <dcnstrct> hahaha
23:46:05 <astrolabe> poor dcnstrct has found a lot of evangelists
23:46:09 <Cale> hehe
23:46:10 <lispy> http://java.justgotowned.com/
23:46:12 <lambdabot> Title: Aninote.com - Java just got OWNED!
23:46:19 <glguy> > foldr insert [] ["Rocks","Haskell"] -- :)
23:46:21 <lambdabot>  ["Haskell","Rocks"]
23:46:38 <foxy> @type partition
23:46:39 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:47:25 <glguy> dcnstrct: but seriously, one of Haskell's biggest differences to most other languages is it's laziness.  it really changes the ways you can look at a problem
23:47:28 <Cale> > partition (<5) [7,2,5,9,1,0,3,12,4,8,6]
23:47:30 <lambdabot>  ([2,1,0,3,4],[7,5,9,12,8,6])
23:47:40 <dcnstrct> well this lazy eval thing sounds cool, but what happens when you want to write data to a file, can you guarentee when it will be written ?
23:47:51 <foxy> @type seq
23:47:52 <lambdabot> forall b a. a -> b -> b
23:48:00 <lispy> @hoogle evaluate
23:48:00 <lambdabot> Control.Exception.evaluate :: a -> IO a
23:48:01 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
23:48:12 <Cale> dcnstrct: There's a thing called the IO monad which generally gives you control of the order of IO actions.
23:48:20 <lispy> dcnstrct: you use the IO monad which can be 'strict'
23:48:41 <dcnstrct> is that a pain ? or relativly useful ?
23:48:43 <Cale> There are some primitives for doing lazy IO, but this is all on the read side.
23:49:08 <Cale> The write side must be strict, because otherwise, nothing would ever happen.
23:49:26 <glguy> dcnstrct: it's useful because it allows you to write more general algorithms than you might have otherwise
23:49:31 <glguy> (for one)
23:49:47 <Cale> It's doing IO output which starts the chain of demand for values, and causes anything to be computed at all
23:50:34 <Cale> Laziness is nice because it lets you reuse code in new ways which you couldn't before.
23:50:38 <foxy> dcnstrct: and Haskell doesn't force you to implement everything as bloated objects
23:50:50 <Cale> For example, that sorting algorithm
23:51:00 <glguy> kind of like schrodingers (sp) cat. Until you check if the value is computed, it both is and isn't :-p
23:51:10 <Cale> If you only demand the first element of the resulting list, it takes O(n) time.
23:51:30 <dcnstrct> foxy, well lisp doesnt either... does it ?
23:51:32 <glguy> or maybe in this case... it isn't ;)
23:51:35 <Cale> So you can somewhat reasonably use sort as a findMinimum
23:51:56 * foxy hides
23:51:58 <dcnstrct> foxy, I can write lots of stuff in lisp without using its object system
23:52:19 <foxy> dcnstrct: I felt like OO/Java bashing :)
23:52:22 <dcnstrct> haha
23:52:23 <Cale> In similar ways, new uses for existing programs crop up far more than in strict languages.
23:52:24 <lispy> dcnstrct: so one thing the lispers might tell you haskell is missing is macros, but for that we have template haskell...not as polished but it's a type safe way to introspect/generate code at compile time
23:52:41 <glguy> dcnstrct: say you wrote an implementation of newton's method for finding roots. you could write one function that returns an infinite list of closer approximations and then another function to run along that list until the relative error is within some parameters
23:52:51 <glguy> instead of including those parameters in your original function
23:53:33 <foxy> and you could reuse the code to work with any datatype that implements (Num a)
23:53:52 <Cale> Or if you were writing a game AI, you could define the entire, possibly infinite game tree, and only after, decide what parts of it are interesting and what you want to look at.
23:54:24 <glguy> there is a paper called "Why Functional Programming Matters" that really covers neat things you can do with laziness, if you are interested
23:54:38 <dcnstrct> I'll check it out
23:54:42 <foxy> @where haskellwiki
23:54:43 <lambdabot> I know nothing about haskellwiki.
23:54:52 <Cale> You'd normally handle this with recursion, but laziness turns data structures into control structures that just haven't happened yet.
23:54:53 <foxy> @slap lambdabot
23:54:53 * lambdabot slaps lambdabot
23:55:12 <foxy> @google Haskell Wiki
23:55:14 <lambdabot> http://haskell.org/hawiki/
23:55:14 <lambdabot> Title: FrontPage - The Haskell Wiki
23:55:29 <lispy> ?slap google
23:55:30 * lambdabot slaps google
23:55:34 <foxy> dcnstrct: There are links from the Wiki to interesting papers
23:55:48 <foxy> @karma google
23:55:48 <lambdabot> google has a karma of -1
23:55:53 <Cale> The advantage is the flexibility of reaching in and altering the control flow, but that's perhaps a little deep of a statement to make without letting you get some experience with it first :)
23:55:56 <lispy> sometimes i think this should be #evangalize-fp
23:56:01 <Cale> But have a look at this:
23:56:31 <Cale> isSubstringOf w s = any (isPrefixOf w) (tails xs)
23:56:45 <Cale> tails is the function which takes a list, and produces the list of its tails
23:57:01 <Cale> isPrefixOf is the function which checks if a list is a prefix of another list
23:57:36 <Cale> any will apply a test to all the elements of a list and check if it holds true for any one of them
23:58:03 <Cale> Now, you might think, in a strict language, this would be an incredibly stupid and inefficient way to program this algorithm.
23:58:19 <Korollary> ?users
23:58:20 <lambdabot> Maximum users seen in #haskell: 242, currently: 207 (85.5%), active: 17 (8.2%)
23:58:27 <foxy> dcnstrct: and Haskell is the hackers language of choice according to the ICFP
23:58:29 <Cale> You'd end up constructing all of the tails, then possibly even checking them all before returning a result.
23:58:52 * glguy imagines that the biggest advantage to learning haskell is getting to be in #haskell and have lambdabot execute random one-liners for you
23:59:05 <Cale> But here, this is equivalent to the easy nested-loops with early breakouts algorithm.
23:59:17 <dcnstrct> so is it easy to extend the language ?  In getting my head around lisp I've learned ways to extend the language to include stuff from my problem domain.   I then write my program in that new "domain specific language".  Does that style of programming carry over to Haskell ?
23:59:18 <Cale> The difference is that you're reusing code you already have.
23:59:28 <Cale> Oh, certainly
23:59:40 <dcnstrct> ok just making sure
23:59:41 <foxy> > repeat "Yeah glguy!"
23:59:42 <lambdabot>  ["Yeah glguy!","Yeah glguy!","Yeah glguy!","Yeah glguy!","Yeah glguy!","Yeah...
23:59:57 <glguy> > [1..5] >> "Woot "
23:59:59 <lambdabot>  "Woot Woot Woot Woot Woot "
