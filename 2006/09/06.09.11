00:00:06 <dons> morning Lemmih
00:00:20 <Lemmih> Good morning, dons.
00:00:36 <dons> ?let f x = (x,x)
00:00:37 <lambdabot> <local>:1:10:     Warning: This binding for `f' shadows an existing binding  ...
00:00:44 <dons> ?undefine
00:00:46 <lambdabot> Undefined.
00:00:48 <dons> ?let f x = (x,x)
00:00:49 <lambdabot> Defined.
00:00:54 <dons> > L.f ()
00:00:55 <lambdabot>  ((),())
00:00:55 <dons> :)
00:01:27 <dons> check case L.f () of ((),()) -> ()
00:01:29 <dons> ?check case L.f () of ((),()) -> ()
00:01:30 <lambdabot>  Arguments exhausted after 0 tests.
00:02:36 <glguy> > Left 1 `mplus` Right 2
00:02:37 <lambdabot>  add an instance declaration for (MonadPlus (Either a))
00:02:37 <lambdabot>   In the definitio...
00:03:21 <dfranke> oh, duh...
00:03:27 <dons> > Left 1 `mplus` (Right 2 :: Either Int Int)
00:03:27 <lambdabot>  add an instance declaration for (MonadPlus (Either Int))
00:03:28 <lambdabot>   In the definit...
00:03:48 <dfranke> this is in linux with _clone(), so threads don't get their own PID.
00:03:50 <dfranke> So only one shows up.
00:04:25 <dfranke> If I add a getChar at the end of main, it runs for a while then prints
00:04:32 <dfranke> user error (Cannot create OS thread.)
00:04:49 <dfranke> meaning it's run out of allocation.
00:05:08 <glguy> dons: I dont understand why Either is in this list
00:05:10 <glguy> ?instances-importing MonadPlus
00:05:11 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:05:17 <dons> dfranke: right, since the main thread blocked
00:05:24 <dons> ?instance Monadplus
00:05:24 <lambdabot> Maybe you meant: instances instances-importing
00:05:29 <dons> ?instances MonadPlus
00:05:30 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:05:41 <dons> the -importing does nothing
00:05:47 <dons> (in this case)
00:05:53 <glguy> Ok, I don't understand why it's in that list "either"
00:05:59 <glguy> no pun intended?
00:06:18 <dons> Either e is an instance of MonadPlus, that's why :)
00:06:39 <dolio> Either e is like Maybe with information attached to Nothing.
00:07:32 <glguy> so Left + _ = Left, Right + x = x
00:07:41 <dons> not sure where the monadPlus instance for Either a lives though
00:07:53 <dons> we have, in Control.Monad.Instances:
00:07:54 <dons> instance Functor (Either a) where
00:07:54 <dons>     fmap _ (Left x) = Left x
00:07:54 <dons>     fmap f (Right y) = Right (f y)
00:08:32 <dolio> No, Left is like Nothing, isn't it?
00:08:34 <dons> ah, got it, mtl/Control/Monad/Error.hs
00:08:36 <glguy> oh... so Left is like nothing then
00:08:50 <dons> instance (Error e) => Monad (Either e) where
00:08:50 <dons>     return        = Right
00:08:50 <dons>     Left  l >>= _ = Left l
00:08:50 <dons>     Right r >>= k = k r
00:08:50 <dons>     fail msg      = Left (strMsg msg)
00:09:04 <dons> and then
00:09:05 <dons> instance (Error e) => MonadPlus (Either e) where
00:09:05 <dons>     mzero            = Left noMsg
00:09:05 <dons>     Left _ `mplus` n = n
00:09:05 <dons>     m      `mplus` _ = m
00:09:42 <glguy> ok, I had my left and right crossed :)
00:10:01 <dolio> Right is the right answer. :)
00:10:02 <glguy> I'm not yet convinced that Left and Right are the best names... but I'll get used to it ;)
00:10:04 <dons> sjanssen++ -- patches
00:11:22 * glguy >>= sleep
00:14:16 <dons> ?quit better decls
00:15:59 <dons> ?wait on freenode
00:16:28 <lambdabot> Maybe you meant: fact part quit what
00:17:01 <dons> ?undefine
00:17:03 <lambdabot> Undefined.
00:17:12 <dons> ?let f (y,x) = (x,y)
00:17:13 <lambdabot> Defined.
00:17:43 <dons> > case L.f ("rules", "haskell") of (a,b) -> a ++ " " ++ b
00:17:44 <lambdabot>  "haskell rules"
00:17:58 <dons> thanks sjanssen
00:19:21 <dfranke> lol, somebody is spamming the EKP address for my PGP keyserver.
00:20:21 <dfranke> I got a bounced keyserver reply sent to my administrator address, stating, "your command, 'this watch is outrageous', was invalid"
00:20:22 <foxy_> how do declare an instance of: (Monad ((->) (m a))) ?
00:42:43 <dblhelix> foxy: do you mean Monad ((->) a)?
00:43:30 <dblhelix> foxy: or (Monad m) => Monad ((->) (m a))?
00:55:15 <dcoutts__> dons: so what shootout test does ByteString regex fix?
00:55:30 <dcoutts__> I've not looked at the regext stuff yet
00:55:36 <dcoutts__> there seem to be several
00:55:47 <dons> well, certainly regex-dna
00:56:08 <dcoutts__> which regex libs work with strict & lazy ByteString?
00:56:10 <dons> (forall time, space and loc)
00:56:14 <dcoutts__> right
00:56:38 <dons> regex-posix, Text/Regex/Posix/ByteString.hs
00:56:52 <dons> not sure if any use .Lazy though
00:57:00 <dcoutts__> ok, so that's based on posix C bindings right
00:57:01 <dfranke> Will GHC 6.6 do OS-level multi-threading only when instructed, or will it be smart enough that if you write let foo = (longComputation, anotherLongComputation) in show foo, it'll do the two in parallel?
00:57:05 <dons> mm, nice,
00:57:05 <dons> instance RegexLike Regex ByteString where
00:57:06 <dons>   matchTest regex bs = unsafePerformIO $
00:57:06 <dons>     let asCString = if (0==B.last bs)
00:57:06 <dons>                       then B.unsafeUseAsCString
00:57:16 <dons> TuringTest++ -- optimisation hacker
00:57:21 <dcoutts__> dfranke: not fully automatic
00:57:45 <dcoutts__> dfranke: though see the par operator
00:57:57 <dcoutts__> @hoogle par
00:57:58 <lambdabot> Control.Parallel.par :: a -> b -> b
00:57:58 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
00:57:58 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
00:58:36 <dfranke> dcoutts__, yeah, I'm aware of par.  But it would be neat if you didn't have to use it.
00:58:52 <dcoutts__> there is a great deal of research on that issue
00:58:59 <dcoutts__> dons: yes, I was thinking of that optimisation
00:59:27 <foxy_> dblhelix: I meant the latter, but I think I've sorted that bit out, thanks
00:59:30 <dons> dcoutts__: seen @let ?
00:59:51 <dcoutts__> dons: however the other advantage of the safe one is that it doesn't matter if the buffer is modified, with the unsafe one the C code has to promise not to tough the buffer.
00:59:54 <foxy_> Is there any way to force a particular instance for overlapping instances?
00:59:56 <dcoutts__> dons: no @let ?
00:59:56 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g (x::[Int])
00:59:57 <lambdabot> <local>:2:10:     Warning: This binding for `f' shadows an existing binding  ...
01:00:02 <dons> ?undefine
01:00:03 <lambdabot> Undefined.
01:00:04 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g (x::[Int])
01:00:05 <lambdabot> Defined.
01:00:23 <dons> ?check minimum `L.eqnotnull` (head . sort)
01:00:24 <lambdabot>  OK, passed 500 tests.
01:00:31 <dcoutts__> cool
01:00:41 <dons> works in > too
01:00:45 <dcoutts__> nice
01:00:54 <dcoutts__> @type check
01:00:55 <lambdabot> Not in scope: `check'
01:01:10 <dons> ?let f x = x*x
01:01:10 <lambdabot> <local>:1:10:     Warning: This binding for `f' shadows an existing binding  ...
01:01:15 <dcoutts__> > check (/=100)
01:01:16 <lambdabot>  Not in scope: `check'
01:01:18 <dons> ?undefine
01:01:19 <lambdabot> Undefined.
01:01:25 <dons> ?let f x = x*x
01:01:26 <lambdabot> Defined.
01:01:31 <dons> > f 8
01:01:31 <dfranke> by the way, why do I see it labeled 6.5 in some places and 6.6 in others?  Is it just the unstable-odd convention?
01:01:31 <lambdabot>  Not in scope: `f'
01:01:35 <dons> > L.f 8
01:01:36 <lambdabot>  64
01:01:43 <dcoutts__> dfranke: yes.
01:02:01 <dcoutts__> dev version 6.5 will become stable version 6.6
01:02:47 <dfranke> how close is it to being released?
01:03:22 <dons> |------| this close
01:05:33 <dcoutts__> where each - represents about 2 days :-)
01:06:07 <dfranke> dcoutts__: seriously, it's that close?
01:06:19 <dcoutts__> aproximately, yes
01:07:34 <dfranke> cool, that's about when my new multi-core system arrives :-)
01:08:13 <dons> "Researchers also hope ultimately the discs would operate autonomously, locating and killing enemy
01:08:17 <dons> troops of their own accord.'
01:08:30 <dons> killer frisbees are scary
01:08:33 <dfranke> dons, I saw that...
01:09:06 <dfranke> I'm wondering how they plan to discern friendlies from hostiles.
01:09:44 <kowey> 2
01:09:49 <kowey> oops, wrong window
01:24:38 <wkh> i think chopin makes good Haskell music
01:26:37 <tibbe> I need some stylistic inspiration for my thesis, do any of you guys know of a very well written thesis (i.e. good use of layout, structure, languages, etc)?
01:27:48 <ibid> for layout, you probably need to conform to the institute requirements
01:27:56 <wkh> right
01:28:09 <dfranke> http://www.antlr.org/article/1055550517640/parr.phd.thesis.pdf
01:28:12 <lambdabot> http://tinyurl.com/gwj7t
01:28:30 <tibbe> ibid, yes, structure then, i.e. presenting things in an easily asorbable manner
01:28:39 <ibid> hm, why is lambdabot putting out url obfuscations instead of de-obfuscations?
01:28:42 <tibbe> dfranke, thanks
01:28:58 <tibbe> ibid, she probably uses @pl :D
01:29:59 <ibid> tibbe: i've found the grin dissertation fairly readable
01:30:07 <dons> ibid: she computes tinyurls now :)
01:30:20 <dons> suitable for copy-n-pasting
01:30:23 <wkh> i didn't know a bot could be gendered
01:30:32 <dons> ?vixen-on
01:30:33 <lambdabot> What's this channel about?
01:30:37 <dons> a/s/l?
01:30:38 <lambdabot> 19/f/California
01:30:46 <wkh> hah
01:30:46 <lambdabot> am i funny?
01:30:48 <dons> ?vixen-off
01:30:49 <lambdabot> Bye!
01:31:01 <ibid> yes, i noticed. it's less useful, though
01:31:17 <dons> it still computes the title for valid .html pages
01:31:37 <ibid> ah
01:31:38 <tibbe> ibid, the grin dissertation?
01:31:41 <tibbe> @where grin
01:31:42 <lambdabot> http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
01:31:42 <ibid> heh, yes, that makes sense
01:31:43 <tibbe> :D
01:31:57 <ibid> tibbe: the boquist thesis, yes
01:32:03 <tibbe> lol
01:32:18 <tibbe> I wrote the @where grin for fun, but lambdabot found it, freaky
01:32:31 <tibbe> @where evil
01:32:31 <lambdabot> I know nothing about evil.
01:32:44 <ibid> tibbe: that probably isn't the thesis, but it probably helps you to locate it :)
01:32:52 <ibid> tibbe: what level, what topic?
01:33:41 <tibbe> ibid, MS, conversational web services
01:33:58 <tibbe> I'm at a engineering university so we do our thesis at companies
01:34:35 <tibbe> or must of us do anyway
01:34:50 <tibbe> although in hindsight I should probably have done it at the institution
01:35:10 <dfranke> oh, MS is master of science.  I was thinking, "a conversation with an MS web service probably involves a lot of swearing"
01:35:19 <tibbe> haha
01:35:22 <tibbe> M.Sc.
01:35:47 <wkh> you're at a uni. where they have masters in web services?
01:36:11 <tibbe> no no, in Software Development and Management
01:36:26 <wkh> oh
01:36:34 <tibbe> at Chalmers
01:37:05 <tibbe> not terribly exciting unfortuneatly :/
01:37:31 <tibbe> *coffee break*
01:38:59 <dibblego> what functions would you use to trim a String of whitespace?
01:39:32 <dons> dropWhile isSpace
01:39:37 <dibblego> reverse (dropWhile isSpace (reverse (dropWhile isSpace a)))
01:39:41 <dibblego> I doubt that is the best way
01:40:14 <dons> ?let dropSpace = let f = reverse . dropWhile isSpace in f . f
01:40:14 <lambdabot> <local>:2:16:     Warning: This binding for `f' shadows an existing binding  ...
01:40:20 <dons> ?undefine
01:40:21 <lambdabot> Undefined.
01:40:24 <dons> ?let dropSpace = let f = reverse . dropWhile isSpace in f . f
01:40:24 <lambdabot> Defined.
01:40:34 <Cale> It's not great, but it's also not terrible, given that lists of characters are not a terribly efficient string representation to begin with :)
01:40:36 <dons> > L.dropSpace "    some stuff    "
01:40:37 <lambdabot>  "some stuff"
01:41:02 <dons> if you care about efficiency, you're using bytestring anyway, which have better options for this stuff
01:42:05 <dibblego> can you find what module(s) a given function belongs to in the Haskell library?
01:42:19 <dons> ?index dropWhile
01:42:20 <lambdabot> Data.List, Prelude
01:42:33 <dibblego> how is that looked up?
01:42:43 <dibblego> from http://haskell.org/ghc/docs/latest/html/libraries/ ?
01:42:45 <lambdabot> http://tinyurl.com/hxrk7
01:42:48 <dons> we have a precomputed data base, generated from a script
01:42:54 <dibblego> ok
01:45:11 <dons> ?quit tweak
01:45:54 <dons> ?bot
01:46:21 <lambdabot> :)
01:46:31 <dons> > L.dropSpace "    some stuff    "
01:46:37 <lambdabot>  "some stuff"
01:50:30 <lokadin> say, anyone know whatever happened to the whole, "in the future, we will be eating everything in pill form" thing
01:50:58 <dons> not enough fibre
01:51:00 <fwd> ppl, could anyone propose a complete book on haskell?
01:51:10 <fwd> though suitable to start with?
01:51:17 <sieni> no
01:51:27 <lokadin> dons: lol, well could'nt you just take that in pill form to?
01:51:35 <dons> fwd: start here http://haskell.org/haskellwiki/Haskell_in_5_steps
01:51:37 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/gdrmd
01:51:52 <fwd> dons, already did
01:52:07 <dons> well there's a list of textbooks at the end.
01:52:12 <dons> we'd only restate that list :)
01:52:12 <fwd> just want a good book to read from pda
01:52:12 <lokadin> it's just i'm really tired of having to have a balanced diet and everything, would be much easier if i just knew to take these select things and i'll be healthy
01:52:17 <tibbe> then your next step would be to understand category theory... ;)
01:52:25 <tibbe> it's the natural progression here
01:52:32 <dons> ah, an online text. yaht then
01:52:32 <tibbe> it requires... faith
01:52:38 <dons> ?where yaht -- fwd
01:52:39 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
01:52:48 <fwd> dons, tnx
01:53:01 <fwd> and a paper book would be great too
01:53:11 <lokadin> you can print it
01:53:57 <wkh> fwd: i'm reading Bird's book
01:54:12 <fwd> wkh, and how's it?
01:54:52 <wkh> i think you'll like it if you want something that really gives you full blown functional programming unapologetically
01:55:02 <wkh> it talks about lazy vs non-lazy evaluation on page 8, for instance
01:57:09 <fwd> ;) well I'm on master discrete math studies now, so I already know a lot's of that stuff
01:57:30 <fwd> lazy/non-lazy eval for instance ;)
01:57:42 <fwd> wkh, ok - thanks
01:58:11 <wkh> oh. it's an introduction to functional programming. there are some haskell tutorials for people who already know functional programming on haskell.org
01:59:56 <fwd> whk, I'm quite new to func programming. though I know a lot of math ;-)
02:44:20 * edwardk waves ello.
02:45:26 * edwardk <<3 display logic.
02:48:24 <edwardk> My cut-elimination proof was going on 20 pages... now its like 8 lines =)
02:52:01 <tibbe> have anyone used latex to typeset sequence diagrams?
02:52:14 <edwardk> sequence diagrams?
02:52:51 <edwardk> oh the uml things?
02:52:55 <edwardk> hrmm
02:53:42 <tibbe> edwark, not neccesarly, just to vertical lines with some labeled arrows going back and forth, I'm trying to illustrate a message exchange
02:53:48 <tibbe> s/to/two
02:54:08 <tibbe> and a title above each line
02:54:09 <edwardk> http://www.tug.org/tex-archive/macros/latex/contrib/lsc/lsc.pdf
02:54:12 <lambdabot> http://tinyurl.com/gtvo3
02:55:19 <tibbe> edwark, thanks, I'll try that one
03:06:17 <dibblego> ?index fromIntegral
03:06:18 <lambdabot> Prelude
03:12:07 <SamB> @karma Java
03:12:07 <lambdabot> Java has a karma of -2
03:12:12 <SamB> @karma java
03:12:12 <lambdabot> java has a karma of -3
03:12:20 <edwardk> heh
03:12:22 <SamB> java--
03:12:31 <edwardk> even asking about java lowers it =)
03:12:35 <dolio> Hah.
03:12:43 <SamB> edwardk: hah
03:12:48 <SamB> yeah right!
03:12:51 <fwd> Ö)
03:12:53 <mauke> @krama jehova
03:12:53 <lambdabot> jehova has a karma of 0
03:12:53 <fwd> :-)
03:12:57 <SamB> in fact, lambdabot is an idiot
03:13:14 <SamB> and distinguishes between cases
03:13:14 <fwd> SamB, he's written in java?
03:13:16 <edwardk> say nice things about her or karma samb may be adversely affected ;)
03:13:24 <sieni> @karma java
03:13:25 <lambdabot> java has a karma of -4
03:13:28 <SamB> edwardk: do not care!
03:13:30 <dolio> Is it pre or post-decrement, though?
03:13:30 <sieni> @karma java
03:13:31 <lambdabot> java has a karma of -4
03:13:41 <SamB> my karma is under the name SamB, not samb!
03:13:43 <sieni> php--
03:13:45 <profmakx> hm
03:13:46 <fwd> @karma Budda
03:13:46 <lambdabot> Budda has a karma of 0
03:13:49 <fwd> ;)
03:13:49 <profmakx> @karma php
03:13:49 <lambdabot> php has a karma of -1
03:13:55 <fwd> don't beleive it
03:13:58 <mux> @karma php
03:13:58 <lambdabot> php has a karma of -1
03:13:58 <profmakx> @karma python
03:13:59 <lambdabot> python has a karma of 0
03:13:59 <fwd> @karma Budda
03:13:59 <lambdabot> Budda has a karma of 0
03:14:01 <fwd> @karma Budda
03:14:01 <lambdabot> Budda has a karma of 0
03:14:04 <fwd> hehe
03:14:18 <fwd> @karma lisp
03:14:18 <lambdabot> lisp has a karma of 0
03:14:20 <fwd> @karma lisp
03:14:20 <lambdabot> lisp has a karma of 0
03:14:22 <fwd> ;-)
03:14:31 <dolio> @karma scheme
03:14:31 <lambdabot> scheme has a karma of 0
03:15:10 <fwd> @karma haskell
03:15:10 <lambdabot> haskell has a karma of 5
03:15:13 <fwd> ;)
03:15:15 <fwd> @karma haskell
03:15:16 <lambdabot> haskell has a karma of 5
03:15:34 <edwardk> ok ok already, we get the idea ;)
03:16:31 <dolio> ?hoogle mod
03:16:31 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
03:16:31 <lambdabot> Prelude.module :: keyword
03:16:31 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
03:16:39 <dolio> ?hoogle exp
03:16:39 <lambdabot> Prelude.exp :: Floating a => a -> a
03:16:39 <lambdabot> Language.Haskell.TH.Exp :: data Exp
03:16:39 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
03:20:21 <SamB> oh and I wouldn't slip in anything to increase the karma of people who try to raise java's karma. I might take out the lower-casing though...
03:21:06 <sieni> haskell++
03:21:13 <SamB> hmm.
03:21:20 <profmakx> is it still case-sensitive?
03:21:24 <profmakx> @karma Haskell
03:21:25 <lambdabot> Haskell has a karma of 9
03:21:25 <SamB> profmakx: yes!
03:21:30 <profmakx> @karma haskell
03:21:30 <lambdabot> haskell has a karma of 6
03:21:33 <profmakx> hm
03:21:37 <int-e> I hope noone ever invents a java plus plus :)
03:21:44 <profmakx> why not int-e
03:21:51 <profmakx> think of some useless features now!
03:21:52 <int-e> will be bad for karma
03:22:11 <SamB> it would be nice if we could come up with a way to hook it up with
03:22:17 <SamB> er, with the Seen module
03:22:36 <SamB> anyway, don't say "Java++ this" or "Java++ that" at the beginning of a line!
03:22:46 <SamB> it will adversely affect your karma!
03:23:12 <profmakx> which is not necessarily a bad thing ;)
03:23:32 <SamB> perhaps we could come up with a short list of things++ to be ignored, such as C++
03:23:48 <SamB> because we don't want to raise C's karma whenever people talk about C++, do we?
03:23:56 <edwardk> why do we want the ++ notation anyways? =)
03:23:57 <profmakx> or with some obfuscated increment-operator ;)
03:24:06 <edwardk>  @karma is so much more explicit
03:24:18 <SamB> edwardk: for people who are used to #perl6 ;-)
03:24:39 <edwardk> you'll start talking about list concatenation and all of a sudden x's and y's will start getting karma ;)
03:24:59 <SamB> they like to write stuff like, oh,
03:25:21 <ndm> @seen dons
03:25:26 <edwardk> samb: i use javascript optimized for space, i am used to chained together statements laden with side effects ;)
03:25:40 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 21m 32s ago.
03:25:42 <SamB> dcoutts++ # for working on optimizing Data.ByteString
03:25:43 <profmakx> @karma dons
03:25:47 <lambdabot> dons has a karma of 66
03:26:04 <profmakx> @botsnack
03:26:04 <lambdabot> :)
03:26:14 <ndm> @tell dons people can't comment on your blog (or at least i'm not clever enough to figure out how...)
03:26:14 <lambdabot> Consider it noted.
03:26:16 <SamB> edwardk: only if you write ugly code
03:26:24 <SamB> if you write:
03:26:33 <dcoutts__> SamB: ta
03:26:36 <SamB> x++y, that is fine
03:26:50 <edwardk> samb: well, the need there to minimize space is paramount. takes a compiler from being 100k to 8k
03:27:46 <SamB> dcoutts: that was just an example of what a #perl6 person might say, to show why I added that notation for karma
03:28:20 <SamB> edwardk: I was talking about the list stuff giving x and y karma...
03:28:29 <SamB> if you write:
03:28:34 <SamB> x ++ y, that is also fine
03:28:34 <edwardk> samb: nods.
03:28:39 <SamB> if you write
03:28:42 <edwardk> samb yeah but x++ y =)
03:28:49 <profmakx> @karma x
03:28:50 <lambdabot> x has a karma of 0
03:28:52 <edwardk> or (x++) y
03:29:02 <SamB> xs++ ys, then you increase xs's karma, unless dons added countermeasures
03:29:19 <profmakx> @karma xs
03:29:19 <lambdabot> xs has a karma of 1
03:29:22 <profmakx> nope
03:29:24 <edwardk> what language don't you like?
03:29:26 <edwardk> C++
03:29:27 <edwardk> =)
03:29:30 <SamB> edwardk: this only matches at the begining of a line...
03:29:46 <SamB> edwardk: that one we should maybe filter out, as I said ;-)
03:29:55 <SamB> @karma C
03:29:56 <lambdabot> C has a karma of 2
03:30:00 <edwardk> what else don't you like?
03:30:04 <edwardk> VisualJ++
03:30:04 <edwardk> =)
03:30:49 <SamB> you want to filter out programming languages? go ahead and write a patch ;-)
03:31:12 <edwardk> just giving you hell =)
03:31:33 <SamB> anyway I wrote this at least a few days ago...
03:31:40 <xerox> It's all logged, you'll pay for this, eventually.
03:32:00 <profmakx> .Net++?
03:32:08 * profmakx shudders
03:32:16 <edwardk> heh, well
03:32:20 <edwardk> all we have to do is talk about
03:32:22 <edwardk> C--
03:32:26 <edwardk> a lot =)
03:33:17 <SamB> hmm, perhaps we could come up with a better regex than "^(\\w+)(\\+\\+|--)($| )"
03:33:34 <wkh> i don't see anything wrong with virtual machines and big libraries
03:33:39 <wkh> C# is a drag, though
03:33:55 <wkh> a lot of people who still use java rather than ruby aren't loyal to java the language, they're loyal to java the platform
03:33:57 <lament> @karma haskell
03:33:57 <lambdabot> haskell has a karma of 6
03:34:04 <lament> @karma lambdabot
03:34:05 <lambdabot> lambdabot has a karma of 22
03:34:11 <lament> hm
03:34:18 <profmakx> not for too long anymore wkh
03:34:27 <wkh> i know. i'm glad of that.
03:34:33 <profmakx> they will be using .NET the platform
03:34:39 <profmakx> which doesnt make me happier either
03:34:49 <SamB> well, Java's libraries seem rather too big, at least in terms of resident size...
03:35:08 <wkh> in java the libraries never let you do things the simple way
03:35:14 <crzivn> stupid question: is there anywhere on the net exercises to ch3 of thompson book?
03:35:42 <SamB> wkh: I never actually tried to program in it ;-)
03:36:09 <profmakx> i tried to keep a healthy distance from java
03:36:10 <wkh> i only use it when a gun is put to my head to do so
03:36:14 <SamB> I think I have played with some Java programs written in Python, though ;-)
03:36:22 <wkh> probably good for your hairline and your mental health, profmakx
03:36:37 <profmakx> well, wkh as if C++ was a better alternative *grumles*
03:36:53 <wkh> i do not claim c++ is better
03:37:11 <profmakx> ;)
03:37:36 <profmakx> i just wanted to say, that my hairline suffered from c++ instead
03:38:40 <wkh> if you're havin' code problems i feel bad for you son
03:38:46 <wkh> i got 99 problems but c++ ain't one
03:40:13 <profmakx> well
03:40:30 <profmakx> lets say im learning haskell and i am using python for quite a while now
03:40:40 <profmakx> so c++ wont be a problem for much longer -.-
03:40:42 <profmakx> hopefully
03:40:56 <edwardk> prof: good luck with that one =) lemme know when c++ goes away ;)
03:41:17 <SamB> I am actually taking a C++ class.
03:41:23 <wilx|wrk> Seriously, why do people hate C++ so much?
03:41:34 <wilx|wrk> IMO it is very fine language.
03:41:45 <profmakx> wilx|wrk, as long as i do not have to use it: fine
03:41:52 <profmakx> :)
03:41:59 <SamB> I dunno if it is a good thing or a bad thing that we are still going over stuff I already know from C...
03:42:34 <dons> ndm, right, no comments. i should try to fixify that?
03:42:34 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
03:43:28 <SamB> ndm: dons doesn't usually go to bed so early...
03:44:12 <profmakx> so... is anyone still working on "frag" or similar projects=
03:45:07 <ndm> dons: only if you want pe9ople to post answers, or comments
03:45:08 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:45:29 <ndm> dons, i've had that lambdabot message before!
03:45:39 <profmakx> -.-
03:48:48 <xerox> <http://channel9.msdn.com/ShowPost.aspx?PostID=230326>
03:48:48 <lambdabot> http://channel9.msdn.com/ShowPost.aspx?PostID=230326>
03:49:00 <xerox> Oops nope.
03:49:24 <xerox> http://channel9.msdn.com/ShowPost.aspx?PostID=231495
03:49:28 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory, http://tinyurl.com/hk54p
03:49:38 <xerox> "Recently, we visited MSR Cambridge(UK) to meet some of the great minds working there. In this case, we were fortunate enough to get an hour's time with Simon Peyton-Jones and Tim Harris, who are researchers working on a very hard problem: making it easier (more predictable, more reliable, more composable) to write concurrent applications in this the age of Concurrency (multi-core is a reality, not a dream)."
03:49:46 <profmakx> it made my dillo crash
03:49:50 <profmakx> -.-
03:49:56 <xerox> This is the one :)
03:50:05 <sieni> how can a dildo crash?
03:50:12 <xerox> @slap sieni
03:50:12 * lambdabot beats up sieni
03:50:29 <SamB> hmm, should I have heard of Tim Harris?
03:51:04 <Igloo> He did the STM stuff I think
03:51:11 <xerox> In C# it seems.
03:51:32 <Igloo> And the Haskell too AIUI
03:52:54 <eivuokko> Igloo, Hi.  Was your fix to ghc cg the native gen generating wrong stdcall symnames or what?
03:53:18 <Igloo> eivuokko: It was generating __imp__expf rather than _expf
03:53:27 <eivuokko> Hmm, ok.
03:54:23 <eivuokko> There's a problem in what names native cg generates for stdcall-convention, but I don't recall how I triggered it...
03:54:40 <eivuokko> (I think that was the problem for me once)
03:54:54 <Igloo> eivuokko: Do you mean I broke something with my change, or there is another problem?
03:55:07 <eivuokko> No, it's another problem I thought you maybe fixed.
03:55:41 <eivuokko> I haven't seen this expf-stuff and haven't tested your fix, I just read the commit mails :)
03:55:42 <Igloo> I think I've only fixed it for a precise list of things that get statically linked in from the mingw libraries
03:56:06 <eivuokko> expf gets statically linked, hmmm.
03:56:43 <Igloo> According to the comment in rts/Linker.c, yes (search for expf and scroll up)
03:59:39 <eivuokko> Ah, yeah, this stuff.  Right.
04:06:16 <vincenz> Wow, this is something neat I didn't know
04:06:21 <vincenz> gzip files are concatennable
04:07:02 <vincenz> meaning in haskell
04:07:15 <vincenz> gunzip (gzip a ++ gzip b) == a ++ b
04:08:03 <edwardk> vincenz: heh yeah
04:09:03 <vincenz> @localtime dons
04:09:05 <lambdabot> Local time for dons is Mon Sep 11 21:08:42 2006
04:12:40 <kowey> interestingly, gzip (a ++ b) /= gzip a ++ gzip b
04:13:32 <edwardk> yeah, coz you get more compression in the former case, only one dictionary, header, etc.
04:14:11 <kowey> right, not a property of the compression algorithm, just that gunzip understands concatenated gz files
04:14:28 <edwardk> *nods*
04:14:38 <edwardk> I'm over here hiding from #math =)
04:14:52 <edwardk> only so long you can try to beat an idea into someone's skull
04:17:21 <Pupeno> good morning Haskell!
04:17:58 <dons> ndm , did you want to tell me what comment you would have put on the blog? :)
04:18:02 <Pupeno> ghc compiles to C and then uses gcc ?
04:18:15 <SamB> it can, yes
04:18:21 <dons> Pupeno: to C, with gcc, to bytecode, and also asm
04:18:30 <ndm> dons: was going to mention that the css from planet doesn't show up in my RSS reader
04:18:49 <Pupeno> I couldn't understand that.
04:18:55 <ndm> dons: and that its nice to know everyone is going to end up using my syntax colouring preferences :)
04:19:04 <dons> hehe :)
04:19:29 <SamB> Pupeno: what couldn't you understand?
04:19:55 <Pupeno> to build a binary, does it depend on gcc ?
04:20:07 <edwardk> one of these days i'll bother to figure out why half of the rss links from planet.haskell don't work in firefox
04:20:11 <SamB> hrmm. I think so.
04:20:34 <SamB> It might not actually use the C compiler aspect, but it probably calls gcc for linking too...
04:20:35 <edwardk> kind of annoying coz i see something by wadler and go to read it, i have to go to the site, scroll and find it, not just click the link in the live bookmark
04:20:47 <boliver> lhs2TeX question:
04:21:06 <Pupeno> oh, I see.
04:21:12 <boliver> when I do: %format f x = "mathbb{" x "}
04:21:24 <SamB> GHC supports both compiling via C with GCC *and* native code generation (but only for a few architectures)
04:21:30 <dons> edwardk: hmm. all works for me. i've not seen anything break.
04:21:38 <boliver> it implicitly generates: ... \ConId{x}
04:21:56 <dons> SamB: and don't forget #!/usr/bin/env runhaskell
04:22:11 <SamB> dons: hmm?
04:22:18 <boliver> does anyone know if it is possible to generate it without the "ConId" around?
04:22:38 <dons> (well, you can leave it as a src file with #!/usr/... at the top, and let the bytecode do the work :)
04:22:46 <SamB> Pupeno: and it can also compile to bytecode, which it can then run, but it doesn't write that to files...
04:26:06 <Pupeno> I see, thanks.
04:27:21 <jakeluck> who else here going to the hackathon this week?
04:27:46 <edwardk> jakeluck: i'll arrive at the ICFP a couple days too late for the hackathon =(
04:28:55 <dons> ndm, i think to get the highlighting to work, ibid would have to change the planet page to use an absolute url to planet.css, and not a relative path, href="planet.css"
04:29:00 <dons> ndm, sound reasonable?
04:29:09 <dons> ibid: ^^ ?
04:29:31 <jakeluck> edwardk: you still have the whole ICFP ahead of you
04:29:38 <edwardk> jake: yeah =)
04:29:44 <dons> ibid, ndm was wondering why the highlighting didn't work in his local feed reader
04:29:52 <edwardk> jake: looking forward to meeting some haskellers.
04:30:18 <ndm> dons: sounds sensible
04:30:21 <jakeluck> wondering if anyone here wants to share a ride
04:31:28 <edwardk> jake: flying out =)
04:32:13 <jakeluck> yes, trying to figure out how to get from where i am staying to the campus
04:32:19 <edwardk> jake: ahh
04:32:44 <jakeluck> edwardk, have you been to psu?
04:32:48 <edwardk> jake: nope
04:33:01 <edwardk> jake: never had a reason to set foot in oregon before
04:34:17 <xerox> I'll paste it again, maybe more people want to see some Simon:
04:34:23 <xerox> http://channel9.msdn.com/ShowPost.aspx?PostID=231495 "Recently, we visited MSR Cambridge(UK) to meet some of the great minds working there. In this case, we were fortunate enough to get an hour's time with Simon Peyton-Jones and Tim Harris, who are researchers working on a very hard problem: making it easier (more predictable, more reliable, more composable) to write concurrent applications in this the age of Concurrency (multi-core is a realit
04:34:26 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory, http://tinyurl.com/hk54p
04:38:10 <ibid> dons: does the feed reader load css?
04:38:43 <dons> ndm?
04:38:49 <vincenz> dons: !
04:39:16 <vincenz> dons: suggestion for lambdabot: refactor out the hoogle path into the Config.hs, like the rest.  I might look into it, but right now I can't build it
04:39:30 <vincenz> *** Exception: Line 22: Unknown field 'hs-source-dirs'
04:39:37 <dons> cabal version issue
04:40:12 <dons> vincenz: change it to hs-source-dir, iirc.
04:41:02 <dons> vincenz: why do you want to move the hoogle path?
04:41:11 <vincenz> dons: cause i think it's a config setting
04:41:13 <vincenz> just like fortune
04:41:14 <dons> since we use an in-tree hoogle, there should never be a need to modify that.
04:41:20 <vincenz> oh
04:41:22 <vincenz> that I was not aware of
04:41:29 <vincenz> ghc-6.4.1: could not execute: dist/build/BotPP/BotPP
04:41:53 <dons> let me try 6.4.1.
04:43:00 <tibbe> @where lambdabot
04:43:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:43:09 <dons> configure works here without any tweaks (sounds like your cabal is too old)
04:43:20 <vincenz> hmmm
04:43:25 <vincenz> yeah it's my desktop, haven't updated in a bit
04:43:35 <dons> try out ghc 6.4.2, its fun, its new!
04:43:42 <vincenz> (my cpufan sounds like a vacuumcleaner)
04:43:49 <vincenz> dons: 6.4.2 doesn't ship with ubuntu
04:44:31 <dons> ok, all building here nicely with 6.4.1
04:44:35 <dons> try updating your cabal
04:44:44 * vincenz nods
04:44:47 <dfranke> odd... did anyone receive my email to the mailing list yesterday?  The archives just refreshed and it's not there.
04:44:48 <dons> i'm using Cabal-1.1.4
04:44:53 <dons> with my 6.4.1
04:45:02 <dons> dfranke: no, didn't receive it
04:45:09 <dons> i was waiting for it :)
04:45:18 <dfranke> weird
04:45:44 <dfranke> It was PGP-signed. Did that cause it to get filtered for whatever reason?
04:45:55 <dons> shouldn't do.
04:46:03 <dons> you sure it was sent to haskell@ ?
04:47:00 <dfranke> yup, right here in my outbox.
04:47:22 <dons> vincenz: lambdabot 4p179, GHC 6.4.1 (OpenBSD i386 )
04:51:09 <dons> ndm, do you use hat much?
04:51:44 <dons> i'm considering some kind of hat plugin for lambdabot, that will reduce an expression by one step (or more), and show the reduced expr
04:52:44 <dfranke> oh god, I'm an idiot...
04:53:01 <dfranke> I reinstalled Debian last week and haven't set up outgoing SMTP yet.
04:53:18 <mux> darcs send not working? :-)
04:53:56 <mux> dons: where can I find yours and dcoutts's paper on loops fusion?
04:54:06 <dcoutts__> @where fps
04:54:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:54:11 <dons> ?google rewriting haskell strings
04:54:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
04:54:13 <lambdabot> Title: Rewriting Haskell Strings
04:54:21 <dons> heh
04:54:25 <dfranke> dons, ah well, I'll get around to setting it up.  For the meantime it's listed on the wiki under Development Tools/Emacs
04:54:27 <mux> thanks guys
05:01:04 <Pupeno> lambdabot runs on OpenBSD ?
05:01:25 <dons> yup
05:01:44 <Pupeno> nice.
05:03:00 <araujo> morning
05:14:11 <kzm> Ahem.  Anybody get *negative* samples (presumably the time) in a +RTS -h output?
05:14:31 <kzm> perhaps unsurprisingly, hp2ps fails to deal with this.
05:15:13 <dons> hmm, better let Igloo know, and supply a source program and compile and rts flags
05:15:27 <kzm> @seen Igloo
05:15:28 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 18m 45s ago.
05:15:55 <kzm> This is with 6.5.something, perhaps it has been fixed since.
05:18:12 <dons> ?users
05:18:13 <lambdabot> Maximum users seen in #haskell: 242, currently: 228 (94.2%), active: 40 (17.5%)
05:18:14 <kzm> It just wraps at BEGIN_SAMPLE 2000 or so.  Int32 used as a fixnum?
05:18:34 <dons> oh should be easy to fix, hopefully
05:22:41 <ndm> dons, i don't use hat at all really :(
05:23:00 <ndm> dons: i'm waiting for library support and Yhc hat trail generation - all things that are in the pipeline
05:23:50 <vincenz> dons: once lambdabot stabilizes a bit (in not requiring the ultralatest cabal etc...) perhaps it could become a package for different *nices
05:24:03 <dons> yep
05:24:16 <vincenz> slap on ndm's gui
05:24:17 <dons> just a bit of cleaning up needed, definitely on the list once 6.6 is out and about
05:24:23 <vincenz> and brand it as eclipse++ for haskell
05:24:37 <dons> heh
05:24:48 <ndm> vincenz: requires Gtk+GHC+Threads to behave first
05:24:49 <vincenz> cause it really is a grand development tool
05:24:54 <ndm> but i do love the idea
05:25:04 <vincenz> maybe throw in some crap to do project management
05:25:07 <vincenz> and a semi-decent editor
05:25:12 <ndm> and GuiHaskell will definately have full lambdabot support in it
05:25:16 <vincenz> \o/
05:25:22 <dons> ?remember vincenz [talking about lambdabot] cause it really is a grand development tool
05:25:33 <ndm> i even considered adding a (launch IRC for help) button
05:25:33 <vincenz> @quote vincenz
05:25:34 <lambdabot>  Geek is Chique.
05:25:40 <dons> ndm, heh
05:25:57 <vincenz> ndm: oh yeah, F1 -> IRC#haskell
05:26:00 * vincenz snickers
05:26:45 <ndm> indeed - i considered "email haskell-cafe", but thought that might generate to much useless traffic
05:27:04 <dons> ndm, did you see ibid ask if your client uses css at all?
05:27:08 <ndm> if someone had done an IRC client in haskell as a library, i'd even be able to lauch that
05:27:24 <dons> ndm, IRC.hs in lambdabot :)
05:27:30 <dons> (that's what hircules uses)
05:27:40 <ndm> dons: no, i didn't see - i use google reader, not sure if it supports CSS
05:27:56 <xerox> Anybody saw the STM video?
05:28:03 <ndm> dons: i want a gtk gui package, where "createIrcChannel" bungs an extra tab  into GuiHaskell
05:28:05 <ndm> xerox: yep
05:28:15 <xerox> Pretty nice! Isn't it?
05:28:49 <ndm> yep, i liked the "building skyscrapers out of banana's" bit
05:28:59 <xerox> @yarr
05:28:59 <lambdabot> This is the END for you, you gutter-crawling cur!
05:30:19 <mux> dons, dcoutts__ : very nice paper
05:33:07 <dcoutts__> mux: ta
05:37:11 <kzm> @hoogle S#
05:37:12 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
05:37:56 * kzm wonders if he is using the wrong character set.
05:37:57 <ndm> bad kzm, no unboxing please :)
05:38:07 <ndm> kzm,
05:38:09 <kzm> Hey - I'm just asking about it.
05:38:33 <ndm> kzm, # == > for hoogle, since searching "a -> b" at the console gives you a redirect
05:38:44 <ndm> kzm, therefore, hoogle treats a -# b as a -> b
05:39:08 <ndm> lambdabot shouldn't really go via the console, it should use the library version which doesn't have this behaviour
05:39:16 <ndm> and i'll patch it for hoogle 4
05:39:27 <kzm> Okay.  S# is from Integer, yes?
05:39:30 <dons> I think this # stuff   is weird and un-unixy, btw :) should just escape things with quotes
05:39:39 <dons> hoogle 'x -> y'
05:39:52 <ndm> dons: yeah, it was an experiment
05:40:06 <kzm> @hoogle Bin
05:40:07 <lambdabot> Language.Haskell.TH.BindS :: Pat -> Exp -> Stmt
05:40:07 <lambdabot> System.Win32.File.BinaryType :: type BinaryType
05:40:07 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
05:40:28 <dons> right, i sould look at the library interface
05:40:43 <kzm> Hmm... I was hoping it was the constructor for Data.Map.  Am I abusing hoogle here?  (Only types?)
05:40:58 <dons> the hidden constructor?
05:41:07 <kzm> Not from my profiling runs :-)
05:41:18 <ndm> kzm, its no in the interface, hence hoogle can't find it
05:41:36 <kzm> Okay - that stands to reason.
05:42:10 <kzm> However, I still under the assumption that S# is an Integer constructor - is that correct?
05:43:42 <dons> data Integer
05:43:42 <dons>    = S# Int#                -- small integers
05:44:35 <dons> ?users
05:44:35 <lambdabot> Maximum users seen in #haskell: 242, currently: 232 (95.9%), active: 44 (19.0%)
05:44:42 <dons> close..
05:45:00 <dons> i think 44 active is a new record
05:45:12 <kzm> dons, ah - thanks.  Found it in trac, though.
05:45:47 <kzm> Any idea about the space consumption of an IntMap x vs Map x Integer (with the Integers being S# type)?
05:46:12 <kzm> dons: you mean the bot doesn't track the high and low water marks?
05:46:23 <dons> for activity, no.
05:46:26 <kzm> ..yet, I might add :-)
05:47:14 * dons -> sleep
05:49:26 <dcoutts__> g'night dons
05:55:02 <kzm> I thought there was mention of a 6.6 release candidate - is it just the least dated 6.5 snapshot?
05:55:59 <defcon8> does anyone know of some decent haskell t-shirt that can be sent to the U.K. and accept paypal as payment?
05:56:10 <kzm> cafepress?
05:56:33 <kzm> (Not sure about paypal)
05:56:39 <defcon8> cafepress don't accept paypal
05:56:49 <dcoutts__> kzm, yes all recent 6.5 snapshots count as 6.6 release candidates
05:57:32 <kzm> Okay - I'll grab yesterday's.  Any reason 386 is three times x86_64 in size?
05:57:57 <defcon8> :(
05:58:12 <defcon8> I don't have a CC, so I'm not able to get one
06:00:19 <dcoutts__> kzm, no idea
06:00:51 <kzm> Seems suspicious.  I guess I'll find out when I unpack them :-)
06:01:02 <defcon8> how do I change directories on windows with ghci?
06:06:01 <Stinger_> haskell tshirts? I mean I like programming but .. :)
06:06:15 <beelsebob> lol
06:07:26 <ibid> dons: btw, the feeds do not have css references and i don't know that one can be added to them
06:11:13 <ndm> ibid: <link type="stylesheet" ?
06:14:50 <deadbeef> hai 2 u
06:16:03 * beelsebob prods ndm with sticks
06:16:07 <ibid> ndm: and this is legal RSS or Atom?
06:16:17 * ndm hits Beelsebob back
06:16:20 <ndm> ibid: nope :)
06:16:25 <mux> this is HTML
06:16:39 <mux> <link rel="stylesheet" type="text/css" href="..." />
06:16:39 <ibid> i'm talking about feeds, not html
06:16:49 <ndm> ibid: or probably inside the HTML area of the feed
06:16:50 <mux> btw
06:17:06 <ibid> ndm: in which case the original sites could add it :)
06:17:17 <ndm> ibid: but its much easier if you did...
06:17:28 <ibid> not for me :)
06:17:29 <ndm> i'm not that fussed, honestly
06:17:33 <CosmicRay> is there any server framework on haskell?
06:17:41 <CosmicRay> I want to write a http and gopher server
06:17:53 <CosmicRay> and it would be nice to have something that would handle fork/thread pools, timeouts, etc.
06:18:33 <ibid> CosmicRay: write one? :)
06:18:49 <CosmicRay> ibid: well yes, but I wanted to see if anyone else had before reinventing the wheel
06:18:54 * ibid finds bout three quarters of the fun in handling all that :)
06:19:03 <ibid> ... in writing a server
06:19:10 <ibid> ... for fun
06:20:51 <Igloo> There's HWS(?)
06:21:58 <CosmicRay> yeah, I'm not sure that will be generic enough, but I guess I could take a look.
06:22:14 <vincenz> how do you output stuff with brainfuck?
06:22:31 <xerox> There's HaskellNet which aims to be a comprehensive protocol library
06:22:42 <xerox> IIRC .
06:23:16 <xerox> Yep, with '.'
06:23:24 <Igloo> Oh, right, you'll probably have to frameworkify it, yes, but it should be a good start
06:23:26 <vincenz> so how do I get one letter?
06:23:41 <CosmicRay> xerox: yeah, I should check that out too.
06:24:09 <xerox> > replicate (ord 'a') '+' ++ "."
06:24:10 <lambdabot>  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
06:24:40 <xerox> Or ",." :D
06:25:04 <AStorm> Write a Haskell -> Brainfuck compiler :P
06:25:12 <AStorm> That'd be quite an achievement.
06:27:18 <ventonegro> @index lift
06:27:18 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
06:27:18 <lambdabot> ParserCombinators.ReadPrec, Text.Read
06:28:13 <kpreid> it would be neat if "@. fptools index" worked
06:29:10 <Cale> Probably easier just to write an Assembly -> Brainfuck compiler for one of the assembly languages which GHC can produce and then compose that with GHC. :)
06:29:16 <Cale> er
06:29:25 <Cale> Brainfuck -> Assembly rather
06:30:05 <xerox> I can't find that ...
06:30:23 <xerox> kpreid: it'd work if it interspersed ' ' instead of ", " I think the fix should be easy
06:30:35 <ndm> AStorm: should be relatively trivial with Yhc + the Yhc.ByteCode library - don't even need to get inside the compiler
06:30:56 <Cale> ah, yeah
06:31:03 <Cale> that would probably be even cleaner :)
06:31:18 <AStorm> Hehe, right.
06:33:29 <vincenz> kpreid: you mean @. fptools . first . index
06:33:33 <vincenz> drop the last
06:33:34 <vincenz> .
06:33:53 <xerox> Here it is!
06:33:54 <xerox> http://paste.lisp.org/display/13015
06:34:06 <xerox> vincenz: no it's fine I think
06:34:12 <xerox> @fptools Data.Map foo bar baz
06:34:12 <lambdabot> Data.Map foo bar baz not available
06:34:15 <xerox> :(((
06:34:32 <xerox> Some plugins take the head, some other don't...
06:35:35 <kpreid> it doesn't help that the first @index result isn't always the one with the implementation
06:38:31 <ventonegro> please help :-)
06:38:42 <ventonegro> lift $ rawLuaLoadFile ls cname
06:39:08 <ventonegro> the function rawLuaLoadFile takes a CString, but cname is IO CString
06:39:28 <kpreid> ventonegro: cname >>= rawLuaLoadFile
06:39:28 <ventonegro> and my code is compiling! what's the catch?
06:39:56 <kpreid> oh
06:40:04 <kpreid> are you sure about the types of those things?
06:40:05 <ventonegro> cname <- lift $ newCString name
06:40:25 <kpreid> cname is a CString then
06:40:27 <ventonegro> newCString gives a IO CString, doesn't it?
06:40:38 <kpreid> if it does, then cname is still a CString
06:40:41 <kpreid> remember what <- means
06:40:59 <ventonegro> but it's a StateT
06:41:12 <ventonegro> i thought it wouldn't change the inner monad
06:41:40 <kpreid> so you're using the monad StateT s IO, rather than IO
06:41:57 <ventonegro> yep
06:41:59 <kpreid> there's still only one monad
06:42:13 <kpreid> if there wasn't then your do-notation wouldn't be working
06:42:19 <ventonegro> newtype LuaState = StateT PtrLuaState IO
06:42:32 <kpreid> if you really wanted two layers you wouldn't be using -T
06:43:07 <ventonegro> humm... isn't it the other way around?
06:43:17 <kpreid> no!
06:43:20 <ventonegro> i'm using two layers because i need IO and my state
06:43:26 <kpreid> you are not using two monads
06:43:33 <kpreid> you are using one monad defined with a transformer
06:44:57 <ventonegro> oh
06:45:37 <ventonegro> so the <- "unwraps" the IO monad and ignores the state?
06:48:50 <kpreid> no
06:48:59 <kpreid> it unwraps the StateT PtrLuaState IO
06:49:08 <xerox> (x :: a) <- (amb :: (Monad m) => m a)
06:49:20 <kpreid> @index newCString
06:49:20 <lambdabot> Foreign.C.String, Foreign.C
06:49:34 <ventonegro> @type newCString
06:49:34 <kpreid> @type (Foreign.C.newCString >>=)
06:49:35 <lambdabot> Not in scope: `newCString'
06:49:36 <lambdabot> forall b. (IO Foreign.C.String.CString -> String -> b) -> String -> b
06:49:59 <kpreid> @type (Control.Monad.Trans.lift (Foreign.C.newCString "") >>=)
06:50:01 <lambdabot> forall (t :: (* -> *) -> * -> *) b. (Monad (t IO), MonadTrans t) => (Foreign.C.String.CString -> t IO b) -> t IO b
06:50:26 <ventonegro> so many types! :-)
06:50:41 <kpreid> notice the function that the right side of bind is taking gets an argument of CString
06:51:05 <ventonegro> yep
06:51:14 <kpreid> the whole point of monad transformers is *not* to have two monadic containers
06:51:26 <kpreid> if you wanted to have that, you'd use return instead of lift
06:51:37 <kpreid> @type return (newCString "")
06:51:38 <lambdabot> Not in scope: `newCString'
06:51:46 <kpreid> @type return (Foreign.C.newCString "")
06:51:47 <lambdabot> forall (m :: * -> *). (Monad m) => m (IO Foreign.C.String.CString)
06:52:42 <ventonegro> makes sense
06:52:47 <ventonegro> thanks very much!
07:14:24 <dfranke_> I'm trying to install a Cabal package and I'm getting this:
07:14:31 <dfranke_> $ r
07:14:35 <dfranke_> oops
07:14:56 <dfranke_> $ runhaskell Setup.lhs configure --ghc
07:15:08 <dfranke_> Could not find module `Distribution.Compat.FilePath':
07:15:15 <dfranke_>   it is hidden (in package Cabal-1.0)
07:15:20 <dfranke_>   (imported from Setup.lhs)
07:15:32 <profmakx> yäi all hail the new subversion
07:15:44 <profmakx> oh wait i am using darcs...
07:15:57 <sjanssen> dfranke_: are you running GHC 6.5?
07:16:06 <dfranke_> 6.4.1
07:16:59 <Lemmih> What Cabal package is it?
07:17:09 <dfranke_> NumericPrelude
07:22:01 <dfranke_> dylan maintains that, right?
07:22:17 <dfranke_> I'll harrass him when he gets back.
07:24:26 <dylan> wgat?
07:24:37 <dylan> I maintain nothing...
07:24:48 <ventonegro> it's working!
07:24:49 <dylan> perhaps a typo for dons?
07:24:58 <ventonegro> hello world from Lua from haskell
07:25:15 <araujo> Lua from Haskell ?
07:25:40 <ventonegro> managed to open a Lua file and run it from inside haskell
07:26:00 <ventonegro> not hard though, haskell's FFI is cool
07:26:21 <vincenz> ventonegro: woo
07:27:32 <ventonegro> now on exporting haskell functions to lua... :-)
07:28:03 <dfranke_> dylan: maintainer's name is Dylan Thurston.  That's not you?
07:28:15 <dylan> I'm Dylan Hardison.
07:28:25 <dfranke_> meh
07:29:30 <dylan> it's not an uncommon name... 3rd most common name in Ireland, 10th or so most common name in Canada...
07:29:46 <dfranke_> ah.  It's pretty rare in the US.
07:31:27 <dylan> I know, I live in the US. :)
07:31:36 <dylan> actually, though, it's in the top 25.
07:32:06 <dylan> usually with the anglified spellings, though.
07:32:40 <dylan> (e.g. Dillon, Dilan, Dilen... some of them make you go 'WTF?')
07:34:04 <CosmicRay> hadn't someone written a networkalt for haskell?
07:34:21 <dylan> networkalt?
07:34:24 <dcoutts__> CosmicRay: yeah, I've heard of it
07:34:39 <CosmicRay> I can't seem to track it down with google
07:34:55 <CosmicRay> dylan: an alternative to the Network package, one that works with ipv6 among other things
07:35:18 <falconair> i'm trying to figure out if the unfold function can be used to bind one end of of a list to network connection reading new values (think stock quote feed), and fold on the other end of the feed to process that data (basically a producer/consumer queue but using a list interface so I can use fold/filter/map on it) ... are there any examples of such?  does it even make sense?
07:35:46 <dcoutts__> falconair: using lazy IO, sure
07:35:58 <dcoutts__> hGetContents on the incomming data
07:38:08 <dfranke_> ok, trying this with Cabal-1.1.4...
07:38:21 <falconair> dcoutts__, ok i found an example of hGetContents on google (http://www.zvon.org/other/haskell/Outputio/hGetContents_f.html), but in haskell I can't 'populate' a list right, won't that violate referential transparency?
07:38:23 <lambdabot> http://tinyurl.com/j2tps
07:38:51 <dcoutts__> falconair: no, it's not a problem, you're not doing anything destructively
07:39:49 <dcoutts__> falconair: you can build lists, not sure what you're getting at exaclty with 'populate'
07:40:14 <dcoutts__> hGetContents just reads characters from a handle, building a list of them as it goes
07:40:26 <falconair> dcoutts__, i guess that's is where i am confused, how do i build lists on the fly for incoming data, is that where the unfold function comes in?
07:40:54 <dcoutts__> falconair: hGetContents returns a list of chars
07:40:57 <gds> You don't need unfold if you have hGetContents, do you?
07:41:07 <dcoutts__> so you've already got the list
07:41:30 <dcoutts__> but yes it's true, unfold can also be used to build a list
07:41:54 <gds> If you'd rather have a list of strings, call split over the list of chars, and split on something useful...
07:42:16 <falconair> i see, i think this will help me out...thanks dcoutts__
07:42:20 <dcoutts__> np
07:42:53 <gour> dcoutts__: you're waiting winter in sweden not believing media how hard it is?
07:43:17 <dcoutts__> hah, no, I'm only here for the rest of the month
07:43:41 <dcoutts__> but I'll be back in December for a couple weeks, so I'll get some snow hopefully
07:43:48 <gour> well, here was 8C in the morning, so you can, with some luck, catch some snow
07:43:51 * dcoutts__ is severely deprived of snow
07:44:06 <dcoutts__> gour: up here it's 20C
07:44:21 <gour> dcoutts__: here it is 23C now
07:44:23 <dcoutts__> and up in the artic circle last week it as 18C :-)
07:48:09 * vincenz blows some fake snow at dcoutts__ 
07:48:19 <dcoutts__> hmm
07:49:46 <Stinger_> mmm springtime :)
07:55:40 <dfranke_> yup, alright.  It needs Cabal-1.1.4.  Documenting that would have been nice.
07:56:54 <gour> dcoutts__: what's the most simple package for relaying mail to isp (for situations like darcs send) ?
07:57:05 <dcoutts__> ssmtp
07:58:14 <dcoutts__> gour:  it's in portage. then edit /ets/ssmtp/ssmtp.conf to put in your isp's smtp server
07:58:54 <gour> dcoutts__: thank you
07:59:25 <gds> dcoutts__: Do I remember you having something to do with the solaris GHC packages?
07:59:40 <dcoutts__> gds, nope, I only use sparc linux
08:00:36 <gds> Ah - fair enough :)
08:01:04 <vincenz> dcoutts__: you use procmail?
08:01:09 <dcoutts__> nope
08:14:26 <glguy> is there some "super ^C" for windows ghci that I don't know?
08:14:40 <ndm> glguy: task manager
08:15:29 <norpan> aka ctrl-alt-del
08:15:54 <glguy> I don't want to lose my one liner :)
08:16:00 <ndm> norpan: ctrl-alt-del no longer does what it once did...
08:28:46 <wkh> morning
08:28:56 * wkh sips coffee and fights the urge to crawl back into bed
08:38:23 <sehute> hi smart ppl
08:38:34 <sehute> *
08:38:39 <glguy>  think they all left...
08:38:43 <jgrimes> :)
08:38:46 <sehute> ;)
08:39:04 <dcoutts__> yep, there they go
08:39:13 <sehute> oh noes
08:39:25 <sehute> so, how's your week?
08:39:31 <sehute> (*)
08:39:41 <dcoutts__> *?
08:39:42 <sehute> (meant for all, not a nipple-smiley)
08:39:47 <dcoutts__> hah
08:40:15 <vincenz> > True ==> 1
08:40:15 <lambdabot>  Not in scope: `==>'
08:40:19 <vincenz> @type (==>)
08:40:20 <lambdabot> Not in scope: `==>'
08:40:26 <vincenz> @hoogle (==>)
08:40:27 <lambdabot> Did you mean: (==>)
08:40:27 <lambdabot> Prelude.undefined :: a
08:40:27 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:40:33 <vincenz> o.O
08:42:43 <vincenz> @let (==>) = \a b -> if a then b else True
08:42:46 <lambdabot> Defined.
08:43:00 <vincenz> > True L.==> Fale
08:43:00 <lambdabot>  Not in scope: data constructor `Fale'
08:43:01 <vincenz> > True L.==> False
08:43:02 <lambdabot>  False
08:43:05 <xerox> Blah!
08:43:21 <mauke> what is L?
08:43:25 <xerox> Lambdabot ?
08:43:37 <mauke> ah, nice
08:43:40 <vincenz> check \l -> (not (null l)) ==> (length l > 0)
08:43:52 <vincenz> @check \l -> (not (null l)) ==> (length l > 0)
08:43:53 <lambdabot>  Add a type signature
08:44:00 <vincenz> @check \l -> (not (null l)) ==> (length (l :: [Int]) > 0)
08:44:02 <lambdabot>  OK, passed 500 tests.
08:44:18 <vincenz> :)
08:45:13 <mauke> > "ab" L.<< "xyz"
08:45:14 <lambdabot>  "aaabbb"
08:45:33 <vincenz> << ?
08:45:41 <vincenz> oh right
08:45:48 <xerox> ?!
08:45:48 <lambdabot> Maybe you meant: . v
08:45:50 <xerox> Ah!
08:45:51 <vincenz> @let (<<) = flip (>>0
08:45:51 <lambdabot>  Parse error
08:45:53 <vincenz> @let (<<) = flip (>>)
08:45:53 <lambdabot> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):         checkPr...
08:45:59 <ndm> woohoo!
08:45:59 <vincenz> WOAH
08:46:01 <xerox> O_O
08:46:02 <vincenz> I broke it!
08:46:17 <wkh|work> > 2+2
08:46:18 <lambdabot>  4
08:46:24 <wkh|work> still works, natch
08:46:26 <xerox> @remember lambdabot ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
08:46:33 <vincenz> @tell dons I broke @let :  @let (<<) = flip (>>)   =>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):       checkPr....
08:46:33 <lambdabot> Consider it noted.
08:46:36 <mauke> > "xyz" >> "ab"
08:46:37 <lambdabot>  "ababab"
08:47:07 <xerox> > [1..10] >> "x"
08:47:08 <lambdabot>  "xxxxxxxxxx"
08:47:15 <vincenz> > "x" << "xxx"
08:47:16 <lambdabot>  Not in scope: `<<'
08:47:19 <vincenz> @let (<<) = flip (>>)
08:47:20 <lambdabot> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):         checkPr...
08:47:29 <vincenz> @let (<<) = \a b -> b >> a
08:47:30 <lambdabot> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):         checkPr...
08:47:34 <vincenz> @let << = \a b -> b >> a
08:47:34 <lambdabot>  Parse error
08:47:37 <vincenz> hmm
08:47:42 <mauke> don't redefine my beatiful <<
08:47:43 <xerox> It is defined
08:47:49 <vincenz> oh
08:47:59 <vincenz> @let (==>) = flip (==>)
08:48:00 <lambdabot> <local>:4:0:     Multiple declarations of `L.==>'     Declared at: <local>:2:...
08:48:22 <vincenz> > True ==> False
08:48:23 <lambdabot>  Not in scope: `==>'
08:48:28 <vincenz> > True L.==> False
08:48:29 <lambdabot>  False
08:48:38 <twanvl> @let (<<) = flip (>>) :: Monad m => m b -> m a -> m b
08:48:39 <lambdabot> ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):         checkPr...
08:48:55 <xerox> @ghc
08:48:55 <lambdabot>  Can't splice the polymorphic local variable
08:50:19 <mauke> > negate L.<< undefined $ 42
08:50:20 <lambdabot>  -42
08:52:27 <sehute> > take 5 [1..]
08:52:28 <lambdabot>  [1,2,3,4,5]
08:52:32 <vincenz> mauke: how is << defined?
08:52:52 <mauke> p << q = do { x <- p; q; return x }
08:53:43 <AStorm> And >> ?
08:53:54 <norpan> shouldn't << do q first?
08:54:10 <mauke> no, that would defeat the point of having a separate <<
08:54:19 <Cale> hmm
08:54:25 <norpan> @type <<=
08:54:26 <lambdabot> parse error on input `<<='
08:54:27 <vincenz> @let p << q = do { x <- p; q; return x}
08:54:28 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
08:54:28 <Cale> > [1,2,3] << [4,5]
08:54:29 <lambdabot>  Not in scope: `<<'
08:54:32 <norpan> @type (<<=)
08:54:33 <lambdabot> Not in scope: `<<='
08:54:34 <vincenz> Cale: L.
08:54:41 <Cale> > [1,2,3] L.<< [4,5]
08:54:42 <lambdabot>  [1,1,2,2,3,3]
08:54:44 <norpan> @type (=<<)
08:54:44 <vincenz> norpan: erm
08:54:45 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
08:54:54 <Cale> It does q first
08:55:22 <mauke> > [4,5] >> [1,2,3]
08:55:23 <lambdabot>  [1,2,3,1,2,3]
08:55:37 <Cale> er, oh
08:55:38 <Cale> I see
08:55:53 <Cale> what's L an alias for?
08:56:00 <vincenz> Cale: Local
08:56:02 <vincenz> Cale: @let
08:56:08 <norpan> so << uses another order than =<< then
08:56:15 <norpan> that's even more confusing
08:56:24 <Cale> yeah, okay, it's not just flip (>>)
08:56:27 <mauke> it's not my fault =<< is misdefined
08:56:40 <Cale> I don't think that =<< is misdefined
08:56:45 <norpan> mauke: you can't define it any other way i think
08:56:50 <mauke> norpan: yeah :-)
08:56:51 <Cale> This << seems odd.
08:56:58 <mauke> Cale: it's useful for writing parsers
08:57:20 <mauke> token '(' >> expr << token ')'
08:57:29 <norpan> the combinator may be useful, but calling it << is asking for trouble :)
08:58:12 <Cale> I agree
08:58:37 <sehute> > [1,2,3] >> [1,2,3]
08:58:38 <lambdabot>  [1,2,3,1,2,3,1,2,3]
08:58:52 <vincenz> > [1,2,3] >>= const [1,2,3]
08:58:53 <lambdabot>  [1,2,3,1,2,3,1,2,3]
08:59:02 <sehute> > [1] >> ["a"]
08:59:03 <lambdabot>  ["a"]
08:59:20 <sehute> What does >> do? I'm still a n00b at monads :)
08:59:52 <Cale> x >> y = x >>= const y
08:59:53 <mauke> a >> b = do { a; b }  -- :-)
09:00:09 <vincenz> mauke: erm no?
09:00:23 <mauke> no?
09:00:33 <vincenz> p >> q = do { x <- p; q }
09:00:48 <Cale> vincenz: same thing?
09:00:49 <mauke> how is that different?
09:00:49 <mux> for lists, it's just concatMap IIRC
09:00:49 <vincenz> > do {[1..3]; [1..3]}
09:00:50 <lambdabot>  [1,2,3,1,2,3,1,2,3]
09:00:53 <vincenz> Cale: ah
09:01:09 <Cale> mux: bind is concatMap
09:01:18 <mux> yeah
09:01:23 <mux> that's what I wanted to say :)
09:01:51 <mux> > concatMap (const [1,2,3]) [1,2,3]
09:01:52 <lambdabot>  [1,2,3,1,2,3,1,2,3]
09:01:57 <Cale> for lists, (>>) is concatMap . const
09:13:27 <sehute> > const [1,2,3]
09:13:28 <lambdabot>  Add a type signature
09:13:33 <sehute> > const [1,2,3] :: List
09:13:33 <lambdabot>  Not in scope: type constructor or class `List'
09:13:40 <sehute> > const [1,2,3] :: [int]
09:13:41 <lambdabot>    Expecting a function type, but found `[int]'
09:13:41 <lambdabot>    Expected type: [int]
09:13:41 <lambdabot> ...
09:13:45 <sehute> ?
09:14:01 <sehute> what does const do? and what kind of type does it want?
09:14:04 <dylan> ?type const
09:14:05 <lambdabot> forall a b. a -> b -> a
09:14:15 <dylan> ?type const [1,2,3]
09:14:16 <lambdabot> forall a b. (Num a) => b -> [a]
09:14:17 <vincenz> > const 1 2
09:14:18 <lambdabot>  1
09:14:24 <vincenz> > const "a" "3
09:14:24 <lambdabot>  Improperly terminated string
09:14:25 <sehute> strangeness
09:14:26 <vincenz> > const "a" 3
09:14:27 <lambdabot>  "a"
09:14:38 <sehute> I think I'll need to do some reading on that :D
09:14:41 <vincenz> sehute: simple: const == \a b -> a
09:15:01 <vincenz> const a b = a
09:15:40 <xerox> Cale: hmm no
09:15:42 <xerox> > ((. const) . (>>=)) [1..10] "x"
09:15:43 <lambdabot>  "xxxxxxxxxx"
09:15:51 <xerox> > [1..10] >> "x"
09:15:51 <lambdabot>  "xxxxxxxxxx"
09:15:57 <sehute> vincenz: ah, thanks :)
09:17:10 <xerox> const x = \_ -> x
09:19:16 <vincenz> const = \o -> \_ -> o
09:19:51 <vincenz> @type \o -> \_ -> o
09:19:53 <lambdabot> forall t t1. t -> t1 -> t
09:25:37 <dcoutts__> SyntaxNinja: ping
09:25:46 <SyntaxNinja> dcoutts__: y0
09:25:54 <dcoutts__> SyntaxNinja: I need to know what to do about Distribution.Compat.FilePath
09:26:07 <dcoutts__> SyntaxNinja: some packages use it, notably lhs2tex
09:26:19 <SyntaxNinja> and the question is whether to make it public?
09:26:27 <dcoutts__> I was intending to hide all the Distribution.Compat.* modules
09:26:41 <SyntaxNinja> has cabal had releases where it was public?
09:26:44 <xerox> Distribution.Compat.FilePath is useful!
09:26:49 <dcoutts__> accidentally, yes
09:27:02 <SyntaxNinja> xerox: no doubt.
09:27:12 <dcoutts__> SyntaxNinja: right, there doesn't seem to be any sensible alternative to Distribution.Compat.FilePath for Setup.hs scripts
09:27:26 <SyntaxNinja> dcoutts__: hm. that's a good point
09:27:31 <dcoutts__> they can't rely on other packages, like an external FilePath package
09:27:46 <SyntaxNinja> the thing is, we want to get it OUT of cabal eventually,b ut I guess it'll be in the standard libs at that point
09:27:53 <SyntaxNinja> is it planned to go into ghc 6.6, btw?
09:27:56 <dcoutts__> SyntaxNinja: no
09:28:09 <dcoutts__> so not until 6.8 at the soonest
09:28:17 <SyntaxNinja> hmmm
09:28:34 <SyntaxNinja> &     <------->    ||         (rock, hard place)
09:28:47 <dcoutts__> quite
09:29:11 <dcoutts__> SyntaxNinja: lhstext also uses the ReadP module
09:29:24 <SyntaxNinja> does lhs2tex use it in the Setup script, or elsewhere?
09:29:32 <dcoutts__> only in Setup.hs
09:29:59 <dcoutts__> SyntaxNinja: so it's not adding Cabal as a dep just to get those modules, but it does some non-trivial stuff in Setup.hs
09:30:27 <dcoutts__> ie find the latex install & build docs (using lhs2tex)
09:31:29 <SyntaxNinja> OK I say let's leave it public. it was a stop gap to start with, and the gap is still there; let's be pragmatic instead of fundamentalists. what do you think?
09:31:36 <dcoutts__> ok
09:32:06 <dcoutts__> so I suggest exposing:
09:32:15 <dcoutts__> Distribution.Compat.FilePath, Distribution.Compat.ReadP
09:32:15 <SyntaxNinja> when the problem can be solved in some practical way (either cabal-install exists or the module is in ghc or whatever)
09:32:19 <dcoutts__> and hiding the rest
09:32:20 <SyntaxNinja> then we'll do that.
09:32:26 <SyntaxNinja> how many others are there?
09:32:35 <SyntaxNinja> is ReadP in ghc libraries?
09:32:44 <dcoutts__> not sure
09:32:47 <dcoutts__>         Distribution.GetOpt,
09:32:47 <dcoutts__>         Distribution.Compat.Map,
09:32:47 <dcoutts__>         Distribution.Compat.Directory,
09:32:47 <dcoutts__>         Distribution.Compat.Exception,
09:32:50 <dcoutts__>         Distribution.Compat.RawSystem
09:33:10 <SyntaxNinja> OK.
09:33:32 <dcoutts__> ah, yes
09:33:32 <SyntaxNinja> yeah, keep the others hidden.
09:33:33 <dcoutts__> Text.ParserCombinators.ReadP
09:33:43 <dcoutts__> not sure if the APIs are exactly the same
09:33:54 <dcoutts__> could check that
09:36:24 <SyntaxNinja> OK.
09:36:33 <SyntaxNinja> yeah, wouldn't really want people using anything that's unnecessary
09:42:32 <ndm> SyntaxNinja, dcoutts__, i can try and push for 6.6.1 with FilePath?
09:42:36 <dcoutts__> SyntaxNinja: yep,  Distribution.Compat.ReadP just re-exports Text.ParserCombinators.ReadP (if ghc > 6.3)
09:42:49 <dcoutts__> ndm: you'll be lucky, no api changes in 6.6 -> 6.6.1
09:42:55 <ndm> :(
09:42:58 <dcoutts__> that's the usual policy
09:43:10 <ndm> well i'm going to shove it in the next WinHugs release anyway :)
09:43:17 <ndm> and its going to be shipping with Yhc from day 1
09:43:18 <dcoutts__> since ghc doesn't even give you the patch level as a cpp var
09:43:37 <SyntaxNinja> ahh, FilePath is a great module.
09:43:54 <dcoutts__> ndm: you can get it into base HEAD of course, just not the ghc 6.6 branch
09:43:57 <ndm> I will send a patch over to convert to System.FilePath, as soon as its accepted into base
09:44:12 <ndm> then you can dupe System.FilePath exactly as it is in base
09:44:41 <SyntaxNinja> is there any reason it's not going into 6.6?
09:44:49 <ndm> not ready yet, still needs API changes
09:45:10 <ndm> unfortunately FilePath is a little bit of a touchy subject with some people
09:45:11 <SyntaxNinja> FilePath does? what API changes/
09:45:29 <ndm> my FilePath, not the Cabal one
09:45:31 <SyntaxNinja> ndm: I've noticed, but I thought everyone gave up on the "FilePath isn't ready" argument.
09:45:40 <SyntaxNinja> oh, you have a FilePath too?
09:45:47 <ndm> yep, and mine is the one I'm pushing for base
09:45:55 <dcoutts__> it's a nice improved one
09:45:56 <SyntaxNinja> oh, well that sucks :P
09:45:57 <ndm> it subsumes the cabal one
09:46:03 <SyntaxNinja> oh, well, that's good then
09:46:06 <ndm> i stole from that, and all other filepath modules
09:46:14 <ndm> the API is incompatible, but does more than yours does
09:46:18 <SyntaxNinja> ahh. excellent.
09:46:19 <ndm> and more regular
09:46:21 <glguy> would this work: let expensive = .... in trace "Done" $! expensive
09:46:24 <glguy> like i think it would
09:46:32 <SyntaxNinja> ndm: well, I didn't write the cabal one, at least not most of it.
09:46:43 <ndm> anyway, i do intend to convert Cabal as soon as I've got the API frozen and it hits base
09:46:46 <dcoutts__> glguy: depends how you think it should wor :-)
09:46:55 <SyntaxNinja> ndm: fine.
09:46:56 <ndm> SyntaxNinja: I know, I've talked with whoever did (name escapes me now...)
09:47:04 <SyntaxNinja> krasimir
09:47:12 <glguy> dcoutts__: I'm building a lookup array, and i just want to see how long the code spends building that array
09:47:22 <glguy> I want done printed when the array is built
09:47:30 <glguy> (its a UArray Int Int)
09:47:30 <dcoutts__> glguy: yep, should work
09:47:33 <glguy> cool
09:47:40 * glguy has never really used $! before
09:47:44 <dcoutts__> glguy: oh, hmm
09:47:56 <dcoutts__> no, it'll be done before
09:48:28 <ndm> SyntaxNinja: I also talked to Malcolm about stealing the dependancy stuff from HMake
09:48:42 <glguy> I think i want it ot work like: let expensive = ... in expensive `seq` trace "done" expensive
09:48:45 <ndm> SyntaxNinja: he said yes to the parser, no to the topological sort (since someone else wrote it, so not his copyright)
09:48:47 <dcoutts__> glguy: it'll be done before, see:
09:48:50 <dcoutts__> trace :: String -> a -> a
09:48:50 <dcoutts__> trace string expr = unsafePerformIO $ do
09:48:50 <dcoutts__>     putTraceMsg string
09:48:50 <dcoutts__>     return expr
09:48:52 <SyntaxNinja> ndm: I've talked to him before; he seemed OK in theory, but never seemed 100%
09:49:04 <SyntaxNinja> a topological sort should not be hard to write from scratch
09:49:12 <ndm> SyntaxNinja: but topological sort == 5 lines well written, 100's in HMake
09:49:30 <SyntaxNinja> I think there's one in the old cabal-get code that Lemmih wrote
09:49:33 <ndm> anyway, i talked to him, he said its fine - send him a personal email asking for a specific file to steal, and he'll almost certainly say yes
09:49:37 <SyntaxNinja> yeah, the HMake code is really hard to tease apart
09:49:40 <glguy> dcoutts__: so I'mdoing it right or wrong? (with either seq or $!)
09:49:48 <SyntaxNinja> cool.
09:49:50 <ndm> the parser should be self contained, so that is worth stealilng
09:50:07 <SyntaxNinja> as I recall, the hmake parser wasn't self contained, but maybe I'm wrong
09:50:16 <dcoutts__> SyntaxNinja, ndm: kolmodin already did a topological sort for his cabal patch that adds improved c2hs support
09:50:41 <dcoutts__> the bit that orders c2hs deps
09:50:51 <SyntaxNinja> we should have Distribution.Compat.TopologicalSort so everyone can stop writing their own (and spuriously depend on cabal  ;)
09:50:54 <ndm> SyntaxNinja: malcolm said it was horrid, but self contained and very well tested - if you email him he might be able to find where it is
09:51:05 <SyntaxNinja> ndm: ok
09:51:09 <SyntaxNinja> dcoutts__: coolness
09:51:24 <ndm> I was thinking of writing a standalone one in Parsec, but using a well tested one gets you all the niggles for free
09:51:33 <dcoutts__> glguy: wrong
09:51:46 <kolmodin> oh, I used Data.Graph, but that might not have been such a good idea when it comes to compability
09:52:05 <glguy> dcoutts__: I wwonder what it's doing then... because when I remove the $!, the trace message is printed first
09:52:07 <dcoutts__> glguy: as trace will print the message *before* evaluating the thing
09:52:34 <glguy> dcoutts__: that's why $! was in there tho... is that not how you use $!?
09:52:38 <ndm> kolmodin: its much better to use something else, rather than write a new one!
09:52:50 <dcoutts__> glguy: oh, yes, I see. Sorry. My mistake
09:53:01 <glguy> ok cool
09:53:07 <dcoutts__> the $! will force it to be evaluated first
09:53:12 <glguy> it's fun putting those messages in the code, it makes my solution much more interactive :)
09:53:24 <dcoutts__> glguy: only use it for debugging though
09:53:33 <dcoutts__> production code shouldn't use Debug.Trace
09:53:43 <glguy> This isn't a production program :)
09:53:50 <glguy> just a mathschallenge.net problem I was optimizing
09:53:55 <ndm> dcoutts__, yes, production programs should be moved over to unsafePerformIO
09:54:02 <kolmodin> ndm: very true
09:54:03 <dcoutts__> if you need stuff to be printed, there are better ways to do it
09:54:07 <dcoutts__> ndm: hah hah
09:54:50 <dcoutts__> kolmodin, ndm: though it'd make building Data.Graph a bit tricky if Cabal needs Data.Graph to build itself :-)
09:55:35 <sehute> How can I run Lambdabot when I'm not superuser? Darcs is installed, but I'm not able to install anything globally. Any hints? :)
09:56:04 <glguy> If I call listArray and create a UArray, the whole array will always be built, right? (UArrays can't be lazy by definition?)
09:56:05 <dcoutts__> use configure --user --prefix=$HOME
09:56:11 <dcoutts__> sehute: ^^
09:56:20 <dcoutts__> glguy: right
09:56:23 <sehute> dcoutts_: is that a darcs parameter?
09:56:24 <glguy> cool
09:56:25 <int-e> glguy: right. unless you don't use the array at all
09:56:32 <dcoutts__> sehute: no, a cabal one
09:56:41 <sehute> dcoutts: okay, I'll try, thanks
09:57:03 <dcoutts__> sehute: runghc Setup.hs configure [etc]
09:57:04 <sehute> dcoutts: I don't think I've got cabal installed
09:57:17 <dcoutts__> sehute: you probably do, it comes with ghc
09:57:22 <sehute> dcoutts: runghc is not installed, but ghc and haskell is
09:57:34 <SyntaxNinja> dcoutts__: have you tried xerox's one-line-test-script?
09:57:42 <dcoutts__> sehute: oh, what version of ghc ?
09:57:44 <SyntaxNinja> sehute: ghc-pkg |grep Cabal
09:57:44 <sehute> dcoutts: ghc 6.2.2. It's red hat enterprise
09:57:51 <SyntaxNinja> !
09:58:03 <SyntaxNinja> I knew there was a reason we're keeping cabal compatible w/ ghc 6.2 (well, don't know if it still is)
09:58:14 <dcoutts__> SyntaxNinja: not yet, what does it do?
09:58:14 <dcoutts__> sehute: ghc --version
09:58:29 <SyntaxNinja> sehute: www.haskell.org/cabal
09:58:33 <sehute> It's Red Hat 3.4.6-3, and ghc --version is: The Glorious Glasgow Haskell Compilation System, version 6.2.2
09:58:37 <glguy> and is listArray the fastest way to populate an array?
09:58:43 <ndm> SyntaxNinja: isn't Galois on 6.2?
09:59:19 <SyntaxNinja> sehute: don't use cabal 1.0, but probably the next version that's available.
09:59:21 <dcoutts__> sehute: ok, use ghc --make Setup.hs -o setup &&./setup configure --prefix=$HOME --user && ./setup build && ./setup install
09:59:35 <SyntaxNinja> dcoutts__: he doesn't have cabal.
09:59:49 <dcoutts__> sehute: ah, you'll need to install Cabal first
10:02:12 <SyntaxNinja> sehute: that ghc version is solid, but growing whiskers, fwiw, but I assume it's not up to you.
10:02:31 <sehute> no, unfortunately not :)
10:02:43 <Igloo> dcoutts__: Can't we rely on cabal-install or distro build-deps to install packages deps before Setup.hs is compiled?
10:03:23 <dcoutts__> Igloo: I guess so, but that doesn't help right now.
10:03:26 <sehute> How do I install cabal as a user? The README-file does not say.
10:03:37 <SyntaxNinja> sehute: "make setup"
10:03:51 <SyntaxNinja> ./setup configure --user --prefix=$HOME
10:03:53 <SyntaxNinja> ./setup build
10:03:54 <SyntaxNinja> ./setup install
10:04:14 <sehute> A google-search only points to a log from here :D
10:04:17 <Igloo> dcoutts__: It means FilePath can go into its own package
10:04:17 <SyntaxNinja> there are so few people who don't have root on their own boxes these days.
10:04:18 <ventonegro> does ghc uses the C preprocessor on .hs files?
10:04:24 <SyntaxNinja> ./setup install --user  (, that is)
10:04:41 <ndm> ventonegro: if you want it to, pass -cpp
10:04:52 <dcoutts__> Igloo: right, it would mean that. but again it doesn't help now.
10:05:03 <Igloo> dcoutts__: Why not?
10:05:07 <SyntaxNinja> sehute: cabal is well documented, and uses cabal itself to install itself, the only difference being a bootstrapping step of "make setup" see the cabal docs
10:05:09 <sehute> SyntaxNinja: make: /usr/bin/ghc: Command not found. (my ghc is not there). Do you know which file it's in?
10:05:12 <ventonegro> ndm, what's preferred, use a #define or a const function?
10:05:18 <sehute> SyntaxNinja: GNUmakefile, is that where it's from?
10:05:24 <ndm> ventonegro: always a const function
10:05:26 <dcoutts__> Igloo: all the people who don't use cabal-setup, since it doesn't come with ghc yet.
10:05:30 <ventonegro> ndm, thanks!
10:05:34 <dcoutts__> Igloo: err cabal-install
10:05:34 <ndm> ventonegro: #define's are evil - use them only if you absolutely have to
10:05:44 <sehute> SyntaxNinja: I'm not familiar with haskell-ish-makesystems :)
10:05:50 <ventonegro> ndm: ok
10:05:53 <Igloo> dcoutts__: OK, but you can just put instructions in the README
10:06:14 * Igloo doesn't have major objections to making D.C.F public if that's what you want to do, anyway
10:06:17 <SyntaxNinja> sehute: yeah, GNuMakefile
10:06:23 <sehute> SyntaxNinja: hah, make works, thanks! :)
10:07:09 <dcoutts__> Igloo: people don't read instructions. they expect runghc Setup.hs to work
10:10:31 <sehute> how to install cabal as a user: 1) download 2) unpack 3) edit GNUmakefile so that it finds ghc 4) make setup 5) mkdir $HOME/where_you_want_cabal_installed 6) ./setup configure --user --prefix=$HOME/where_you_want_cabal_installed 7) ./setup build 8) ./setup install --user
10:10:48 <sehute> hope it shows up in an irc-log on the web somewhere ;)
10:11:15 <sehute> now checking if it actually works ;)
10:11:22 <glguy> instructions?
10:12:43 <sehute> yeah
10:13:08 <TreyHarris> Hi, I just built ghc-6.5.20060910 from source.  It doesn't have readline support, even though I have readline installed which works with other programs.  Do I need to supply a configure flag or something to get readline support?
10:13:17 <SyntaxNinja> sehute: there might actually be a "make install-user" or something.
10:13:21 <glguy> In case anyone didn't know... if you eat salt sunflower seeds all day, all week, your tongue will become sore...
10:13:35 <SyntaxNinja> glguy: pitted or unpitted?
10:13:46 <glguy> with the shell
10:13:49 <sehute> how can I add the newly install library to the environment? Is it "LIB"? "USRLIB"?
10:13:55 <sehute> *newly installed
10:14:23 <tibbe> glguy: eating sour candy every day makes the upper parts of your mouth blead
10:14:25 <sehute> ERROR "./Setup.hs" - Can't find imported module "Distribution.Simple
10:14:43 <sehute> tibbe: it's the truth, I did that once, a few years ago
10:14:48 <glguy> tibbe: I'd glad that I haven't found that out...
10:14:50 <glguy> I'm*
10:15:06 <sehute> tibbe: it wasn't like omg it's bleeding, though, only sore
10:15:15 <SyntaxNinja> sehute: it's pretty yucky w/ ghc 6.2 actually, you have to tell it to find ~/.ghc-packages, so your cabal-related command lines will look something like "ghc --make -package Cabal -package-file=~/.ghc-packages" or something like that, see the ghc man page for help
10:15:20 * glguy hasn't stopped eating the seeds... just knows that it hurts
10:15:42 <SyntaxNinja> glguy: maybe you should switch to the ones without the shells
10:15:42 <sehute> SyntaxNinja: ah, I see
10:15:50 <sehute> SyntaxNinja: thanks
10:15:54 <tibbe> sehute: no, but I could taste it
10:15:59 <Igloo> TreyHarris: Can we see the configure output?
10:16:25 <TreyHarris> Igloo: you want to see config.log?
10:16:26 <SyntaxNinja> sehute: np. I recommend a "cabal-make-go" script that's something like "ghc --make ... && ./setup configure --prefix= ... && ./setup install --user"
10:16:30 <glguy> SyntaxNinja: but the Jim Beam soaked "jalapeno"-flavored ones are soooo good
10:16:30 <SyntaxNinja> s/script/alias
10:16:46 <SyntaxNinja> glguy: maybe we should plan an intervention.
10:17:10 <sehute> SyntaxNinja: yeah. Or a curses-program that automagically fetches, configures and installs various tarballs from around the net :-)
10:17:21 <sjanssen_> @yow!
10:17:21 <lambdabot> A wide-eyed, innocent UNICORN, poised delicately in a MEADOW filled
10:17:21 <lambdabot> with LILACS, LOLLIPOPS & small CHILDREN at the HUSH of twilight??
10:17:45 <SyntaxNinja> sehute: it's not curses yet, but cabal-install will do that sometime Real Soon Now.
10:17:54 <SyntaxNinja> I'm sure that we'll have to back-port it to 6.2, though.
10:17:57 <sehute> SyntaxNinja: that would be incredibly nifty tm
10:17:59 <ndm> please, never make it curses based...
10:18:10 <SyntaxNinja> ndm: the UI should be pluggable, of course.
10:18:12 <ndm> if you want a GUI, use a GUI toolkit, not an abomination
10:18:12 <Igloo> TreyHarris: That should do
10:18:17 <sehute> ndm: xdialog/zenity/kdialog then :)
10:18:20 <SyntaxNinja> OK I'm having too much fun chatting
10:18:21 * SyntaxNinja &
10:18:30 <ndm> sehute: win32 all the way for me
10:18:41 <sehute> ndm: :^O
10:18:44 <weitzman> another vote for win32
10:18:45 <weitzman> w00t
10:19:08 <glguy> Win32? is that for people who can't run OpenBSD?
10:19:08 <sehute> ndm: well, you can use cygwin and win32 is POSIX-compatible, that's something
10:19:13 <weitzman> I'm going to need to repartition my new box before I can install linux also
10:19:33 <ndm> sehute: i morally refuse to use Cygwin - because its crap, and evil
10:20:02 <ndm> glguy: its for people who are cool (TM)
10:20:06 <sehute> ndm: you shouldn't have to refuse something morally if you think it's crap. Either it's crap, or you refuse to use it morally :)
10:20:32 <weitzman> What if you're morally opposed to crap?
10:20:34 <ndm> sehute: i refuse to use it because its so crap, which is a moral choice
10:20:39 <sehute> weitzman: that's possible :D
10:20:40 <TreyHarris> Igloo: http://sial.org/pbot/19603
10:20:41 <lambdabot> Title: Paste #19603 from "TreyHarris" at 216.254.17.198
10:20:54 <sehute> ndm: so, your crap-judgment is based on you morals? :D
10:21:19 <glguy> sehute: 11 commandment, don't use cygwin because it is crap
10:21:21 <ndm> sehute: no, my crap judgement is based on how well it works etc - my decision not to use it because its crap is a moral one, since i object to software that's that bad
10:21:34 <glguy> 11th*
10:21:37 <sehute> ndm: I see. Pretty much what weitzman said, then :)
10:21:44 <sehute> ndm: cygwin works nicely, though
10:21:49 <ndm> @remember glguy 11th commandment, don't use cygwin because it is crap
10:22:06 <weitzman> sehute: As it turns out, I don't like Cygwin either!
10:22:06 <ndm> sehute: it really doesn't :)
10:22:22 <sehute> ndm: what part of win32 do you like the most? The ability to execute PE-files?
10:22:26 <sehute> ndm: the userinterface?
10:22:38 <sehute> ndm: the networking (*coff*) capabilities
10:22:44 <weitzman> sehute: One thing I've always liked about windows is its ability to use my wireless card
10:23:04 <ndm> sehute: the fact that it works (TM) - i can install Firefox in under 35 seconds - Next, Next, Finish - it took my Linux using deskmate over 3 hours
10:23:16 <sehute> weitzman: You know that you can use the windows-driver for your wireless-card with ndiswrapper under linux? You even have a gui for installing it.
10:23:24 <weitzman> sehute: Don't think I haven't tried
10:23:31 <Igloo> TreyHarris: Hmm, what is it that isn't working for you?
10:23:35 <weitzman> sehute: Don't know why it wouldn't work, don't care
10:23:37 <int-e> ndm: errr. did it compile the browser?
10:23:42 <weitzman> sehute: It shouldn't be hard
10:23:54 <sehute> weitzman: Well, in that case, I agree that the makers of the wireless card you've bought made a really bad job on making drivers for more than one OS
10:24:07 <glguy> ndiswrapper is for the lose... OpenBSD's wireless support is the money
10:24:08 <ndm> int-e: it just plain didn't work, dependancy hell, some recompilation, but not of the actual Firefox core
10:24:08 <glguy> ;)
10:24:08 <weitzman> sehute: That's highly probable
10:24:31 <sehute> weitzman: the non-workingness of your wireless card is a property of those who made it, not any os
10:24:37 <TreyHarris> Igloo: readline support
10:24:50 <Igloo> TreyHarris: What are you doing and what does it say?
10:24:54 <glguy> Windows.. you ahve to click next next enxt to install firefox... ew
10:25:04 <glguy> OpenBSD? pkg_add firefox
10:25:09 <weitzman> weitzman: The property of being compatible with my hardware is something I value in an OS
10:25:16 <weitzman> Ah, now I'm talking to myself
10:25:36 <sehute> ndm: Installing firefox in any debian-based os (like ubuntu) goes in seconds, with a lot less effort than in windows. It's true. I've done both.
10:25:53 <fasta> Where do you put your tests (e.g. Quickcheck, or not using a framework, or whatever)? In a separate module, from the implementing module? Any system that has a good testing architecture that I can look at?
10:25:56 <Igloo> TreyHarris: Or do you mean you can't edit the line in ghci?
10:25:57 <sehute> ndm: linux isn't an OS, it's a kernel, btw :)
10:26:04 <TreyHarris> Igloo: type 'ghci'.  type a few chars.  try to move back to edit.  on my old ghci, I get my cursor to move back.  on the one I just built, "^B^B^B^B" echoes to the terminal.
10:26:25 <ndm> sehute: yeah, thats the other thing - when my GUI doesn't work I have an issue with "Windows", when Linux craps up, i get a list of other people to blame, but not a solution!
10:26:32 <TreyHarris> Igloo: also, pugs always had readline support.  all i've done is upgrade ghc, and now its configure script complains of no readline support
10:26:44 <weitzman> I dream a day when linux and windows software can run side-by-side in harmony within different environments on top of a single system
10:27:05 <weitzman> And WINE ain't it, before you say anything
10:27:07 <dmwit> weitzman: QEmu?
10:27:12 <sehute> ndm: if you use Ubuntu and your GUI doesn't work, you have an issue with "Ubuntu". You have people who will help, people you can blame and even people you can pay for support, instead of paying for both software and support that you don't use (as you do with Windows)
10:27:26 <fasta> ndm: I find that I always find a solution or get a solution.
10:27:27 <Igloo> TreyHarris: Does libraries/readline/libHSreadline.a exist?
10:27:40 <sehute> weitzman: xen :-)
10:27:45 <ndm> sehute, fasta: I am happy, I use Windows, I think we can all smile about that :)
10:27:46 <Igloo> TreyHarris: (in the source tree you built)
10:28:12 <weitzman> dmwit: I don't know how xen handles transfer of data between OS environments, but I suspect we'll all be using something like xen in the future
10:28:13 <sehute> ndm: No! You are categorized in the "unhappy user" box, since you say you're a happy Windows user. ;-)
10:28:15 <TreyHarris> Igloo: it does in the prior source, it doesn't in the new source
10:28:27 <TreyHarris> (prior=6.4.2)
10:28:33 <sehute> ndm: (but I get your point, there are too much discussion about things like this in the world)
10:29:11 <glguy> It's not about if you are happy or not, it's about if the other person feels that they are *happier* than you
10:29:20 <glguy> and that they are sure you know ti
10:29:36 <glguy> how self centered to think that it was about you ;)
10:29:37 <Igloo> TreyHarris: Can I see libraries/readline/config.log ?
10:29:39 <eivuokko> sehute, Then why on Earth you tried to bait another flamewar into existence?  Stuff like that makes Windows users shut up because they become pressured for being Windows users, it's not too polite.
10:29:46 <weitzman> In that case, anyone who has succeeded at installing AFS on *any* OS is happier then me
10:30:17 <sehute> eivuokko: Do you want to continue the same debate?
10:30:36 <sehute> eivuokko: You are flamebaiting me right now
10:30:41 <glguy> who likes Haskell?
10:30:42 * ndm gives eivuokko and sehute a group hug and points them at #haskell-blah
10:30:47 <sehute> Haskell! Yay! :)
10:31:07 <weitzman> glguy: I'll get back to you in a few years with my review
10:31:09 <eivuokko> sehute, Because readin backlog makes me want to kick you from this channel.  But you're right, sorry.
10:31:10 <fasta> glguy: Only academics like Haskell ;)
10:31:18 * fasta starts a flamewar
10:31:25 <sehute> eivuokko: you are flamebating me again
10:31:34 <dmwit> Why Haskell over, say, Assembly?
10:31:34 <TreyHarris> Igloo: http://sial.org/pbot/19604
10:31:35 <lambdabot> Title: Paste #19604 from "TreyHarris" at 216.254.17.198
10:31:42 <sehute> eivuokko: if you don't wish to discuss, don't flamebate me
10:31:49 <ndm> fasta: i'd redefine that as "only academics know about haskell"
10:32:08 <weitzman> ndm: Only academics can understand code written in Haskell?
10:32:09 <eivuokko> sehute, Uh.  I'm sorry to offend you so, I tried to ask you to behave more nicely.
10:32:11 <SyntaxNinja> most generalizations are wrong.
10:32:16 <SyntaxNinja> <---- not an academic
10:32:32 <sehute> eivuokko: okay, bait taken, what exactly have I said that makes me eligable for being kicked?
10:32:40 <ndm> SyntaxNinja: but you have published academic papers, and you are on an academic workshop committee
10:32:44 <sehute> eivuokko: besides, I did not intend to start a flamewar
10:32:48 <Igloo> TreyHarris: Oh, do you really have readline, or do you have editline pretending to be readline?
10:32:49 <SyntaxNinja> sehute, sehute: take it to #haskell-blah
10:32:55 <sehute> eivuokko: and, please explain what you mean by "stuff like that"
10:32:56 <SyntaxNinja> er sehute & eivuokko
10:33:05 <sehute> eivuokko: "Stuff like that makes Windows users shut up because they become pressured for being Windows users, it's not too polite."
10:33:19 <sehute> >:<
10:33:21 <ndm> oh SyntaxNinja - did you get selected for the post-publication for TFP?
10:33:32 <SyntaxNinja> ndm: nah. not academic enough ;)
10:33:44 <TreyHarris> Igloo: i've never heard of editline, can you suggest how i might discover the difference?  all my libs are 'libreadline...'
10:33:47 <fasta> Is there any Haskell project which makes good use of Quickcheck etc?
10:33:49 <ndm> hmm, i did, but have heard nothing in ages - submitted my final draft ages ago...
10:33:54 <TreyHarris> Igloo: and I installed GNU readline
10:33:56 <ndm> I had to rewrite most of it :(
10:34:04 <TreyHarris> Igloo: but not knowing what 'editline' is, maybe?
10:34:04 <fasta> darcs seems to test using Perl.
10:34:10 <sjanssen_> @where fps -- for fasta
10:34:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:34:19 <ndm> http://www.cs.york.ac.uk~
10:34:22 <fasta> sjanssen_: thank you
10:34:33 <ndm> http://www.cs.york.ac.uk/~ndm/projects/libraries.php -- for fasta again
10:34:37 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/m7p7a
10:34:38 <eivuokko> sehute,  The baiting you did?  Huh?
10:34:55 <ndm> fasta: that has quickcheck properties in the code, and the haddock, and a test suite
10:34:57 <sehute> eivuokko: as the others said, take this to #haskell-blah. Now it's you that's "not behaving nicely"
10:37:44 <eivuokko> sehute, It is nice for you to disagree with me without actually saying so and blame me.  As for #haskell-blah, no thanks.  Maybe I should have given up with Haskell community already, it's not like Windows users can nicely chat here about haskell instead of getting trouble on mention of positive opinions on Windows OSses.
10:38:12 <sehute> pussy
10:38:21 <xerox> Stop that sehute.
10:38:26 <sehute> sorry
10:39:46 <sehute> I didn't mean it in the cursing-kind-of way :)
10:39:52 <sehute> Anyways
10:39:56 <sehute> > 1+1
10:39:57 <lambdabot>  2
10:40:53 <Igloo> TreyHarris: Does http://www.haskell.org/pipermail/cvs-ghc/2006-September/031285.html and the two other messages in that thread help?
10:40:56 <lambdabot> Title: GHC Hackathon, http://tinyurl.com/ljq5x
10:42:27 <glguy> wtf wrt eivuokko whining about Windows users getting slack... this was the first time I've seen it even come up and no one was actually insulting anyone's operating system...
10:43:04 <TreyHarris> Igloo: well, I'm remaking, so I guess I'll know in some hours ;-)
10:43:16 <TreyHarris> Igloo: thanks for pointing me at it
10:43:27 <weitzman> Is the House project dead?
10:43:55 <sehute> glguy: I found it hard to understand as well, but he refused to tell me and quit
10:44:30 <ndm> weitzman: have you seen hOp?
10:44:32 <glguy> I use Windows too, I wasn't offended... in fact I use all three operating systems... Windows, OS X, and OpenBSD
10:44:42 <ndm> weitzman: i think that may be a continuation of the house project, or related in some way
10:44:49 <weitzman> @where hOp
10:44:50 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
10:44:52 <fasta> weitzman: hOp is the predecessor
10:45:06 <fasta> weitzman: House should be newer
10:45:06 * ventonegro has to use Windows in his day job
10:45:08 <TreyHarris> Igloo: or, perhaps... since I now have a libHSreadline.a, is there some way for me to not have to remake ghc itself?
10:45:09 <ventonegro> it sucks
10:45:16 <sehute> glguy: I don't have anything against any of them either, except perhaps parts of Windows ;)
10:45:27 <sehute> anyhoo
10:45:35 <weitzman> I'm always a fan of OS's written in strongly-typed languages
10:45:41 <sehute> weitzman: are there any?
10:45:46 <weitzman> House?
10:45:53 <sehute> House? *googling*
10:45:57 <weitzman> This summer I should have gotten access to Singularity
10:45:58 <weitzman> @where House
10:45:59 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
10:46:04 <glguy> there is that L4 project
10:46:04 <weitzman> I was working at MS
10:46:08 <weitzman> But I didn't
10:46:10 <weitzman> And I regret it
10:46:13 <glguy> written in something that started with an I
10:46:14 <weitzman> @where singularity
10:46:14 <lambdabot> I know nothing about singularity.
10:46:21 * SyntaxNinja thinks House needs a filesystem!
10:46:21 <weitzman> @google singularity C#
10:46:22 <glguy> singularity was the C# one
10:46:22 <Igloo> TreyHarris: It should do that itself
10:46:26 <lambdabot> http://research.microsoft.com/os/singularity/
10:46:33 <sehute> weitzman: ah, cool, I've never seen it before. :-)
10:46:36 <SyntaxNinja> too bad no one is cool enough to add one</baiting>
10:46:43 <fasta> There is also an OS written in Common Lisp called Movitz.
10:46:46 <weitzman> @google coyotos
10:46:50 <lambdabot> http://www.eros-os.org/
10:46:50 <lambdabot> Title: The EROS Operating System
10:47:00 <xerox> @where hafs
10:47:00 <lambdabot> I know nothing about hafs.
10:47:15 <glguy> We need an operating system written in epigram...
10:47:29 <SyntaxNinja> @where halfs
10:47:33 <lambdabot> http://www.haskell.org/halfs
10:50:40 <TreyHarris> Igloo: oh?  i tried just doing another make install... I still seem to lack readline support
10:51:05 <TreyHarris> Igloo: so you're saying there's no point in my doing a clean re-make if that didn't work?
10:51:06 <Igloo> TreyHarris: Oh, delete compiler/stage2/ghc-6.5 and run make again
10:51:47 <TreyHarris> Igloo: ok
10:52:14 <glguy> Igloo: did you give up on mathschallenge.net?
10:52:38 <Igloo> glguy: I didn't give up on it so much as stop having time for it
10:52:57 <glguy> I didn't mean that in the coudldn't handle it sense
10:53:18 <Igloo> Sure, I just mean i didn't actively decide to stop doing it
10:53:23 <glguy> ah, ok
10:54:18 <glguy> Igloo: check out the score board there for Haskell sometime :0D
10:57:26 <d04jk> Can anyone explain how to use the Maybe data typ, or point me to some kind of explanation of it ;)
10:57:30 <Igloo> glguy: Congrats  :-)
10:57:31 <d04jk> type*
10:57:43 <ndm> d04jk: do you know how null is used in Java?
10:57:44 <glguy> d04jk: what do you understand about it so far?
10:57:51 <Philippa_> building Maybes:
10:57:52 <d04jk> ndm, sure
10:57:54 <Philippa_> Nothing
10:57:58 <weitzman> @let maybeInt = Just 4
10:57:59 <lambdabot> Defined.
10:58:02 <Philippa_> Just 2 <- a Maybe Int, maybe
10:58:08 <ndm> d04jk: just think of Nothing == null, Just x = a real value
10:58:10 <sehute> @let my people go
10:58:10 <lambdabot>  Parse error
10:58:11 <d04jk> glguy, i kind of think i understand how to use it in some occasions
10:58:15 <Philippa_> taking maybes apart:
10:58:15 <weitzman> @let maybeNothing = Nothing
10:58:16 <lambdabot> Defined.
10:58:26 <Philippa_> case (maybe) of {Nothing -> 0; Just x -> x}
10:58:53 <ndm> d04jk: its just a simple value - which might be there or not, in teh same way that a list is a sequence of 0 or more values, maybe is a 0 or 1 value
10:59:02 <glguy> d04jk: if a function returns a ( Maybe Int ) that means that it *might* return an Int, or it might return nothing
10:59:16 <glguy> d04jk: it represents a computation that can fail
11:00:04 <glguy> d04jk: find (>2) [1,2,3,4] is of the type Maybe Int, because find can either find an index, or it can fail to
11:00:27 <weitzman> @type find (>2)
11:00:28 <lambdabot> forall a. (Ord a, Num a) => [a] -> Maybe a
11:00:37 <weitzman> > find (>2) []
11:00:38 <lambdabot>  Nothing
11:00:44 <weitzman> > find (>2) [1, 2, 3]
11:00:45 <lambdabot>  Just 3
11:00:54 <sehute> bye all, see you some other time :)
11:00:56 <d04jk> i think i understand some usage of it of. but when you use it like this? http://rafb.net/paste/results/npAEJA87.html
11:00:59 <glguy> ciao
11:01:23 * edwardk waves ello.
11:01:40 <glguy> d04jk: do you understand pattern matching in function declarations?
11:01:57 <d04jk> depends on what it means ;)
11:02:11 <edwardk> foo (Just x) = ...
11:02:13 <glguy> d04jk: in that example, the first function is used when the first argument is a Nothing
11:02:28 <glguy> d04jk: the second function is used when the first argument is a Just
11:02:32 <edwardk> foo Nothing = ...
11:02:37 <d04jk> "a Noting" is that acutally a value, or just "nothing"
11:03:06 <d04jk> like, orElse 12
11:03:08 <edwardk> d04jk: nothing is one of the two constructors that can generate "Maybe", so technical nothing is something =)
11:03:10 <TreyHarris> Igloo: cool, that seemed to work.  ghci still doesn't let me edit for some reason, but ghc itself has readline support now :-)
11:03:10 <d04jk> is there a nothing in there :D
11:03:24 <glguy> > let orElse = mplus in   Nothing `orElse` Just 1 `orElse` Nothing
11:03:25 <lambdabot>  Just 1
11:03:51 <glguy> > let orElse = mplus in   Nothing `orElse` Just 1 `orElse` Just 2 `orElse` Nothing
11:03:52 <lambdabot>  Just 1
11:06:50 <d04jk> i think need to do some reading about what a constructor is
11:06:51 <glguy> d04jk: Now that you've been attacked with so much information, you should ask new questions to get clarrification... no one knows what you don't understand now :)
11:07:15 <glguy> d04jk: does this make sense: Maybe a = Nothing | Just a
11:07:41 <glguy> or rather: data Maybe a = Nothing | Just a
11:08:07 <edwardk> d04jk: think of constructors as tags that tell you what type of data you have. Maybe a has two of them. Nothing, which indicates the absence of a value of type a, and Just a, which provides a single value of type a.
11:08:08 <d04jk> i know its a "data type" definition, or atleast i think so
11:08:40 <edwardk> so when you say that a function that takes a 'Maybe a" then it will receive one of those two constructors as its argument.
11:08:50 <edwardk> anything else is illegal
11:08:53 <glguy> d04jk: do you know C or C++ or C# or java?
11:08:59 <d04jk> i know java
11:09:23 <d04jk> i find some usages of Maybe really sensible, but others just weird
11:09:28 <glguy> d04jk: Maybe a is a generic (a can be any type) and it is an abstract class... Nothing is a subclass of Maybe a, and so is Just a
11:09:31 <glguy> for example
11:10:14 <edwardk> you can think of Nothing kinda like haskell's null, but thats not a very useful abstraction, coz Just Nothing and Just (Just 12) are also valid =)
11:10:25 <edwardk> coz you could have Maybe (Maybe Int) =)
11:10:51 <glguy> d04jk: does that comparison to Java make sense? (I dont' know all the java terminology)
11:10:52 <d04jk> http://rafb.net/paste/results/g8ice136.html
11:11:01 <d04jk> that makes perfect sense to me
11:11:14 <d04jk> but i find the other example i pasted really hard to understand
11:11:44 <glguy> errDiv only gives a result when m/=0
11:12:03 <glguy> it expresses the fact that the computation succeeded by returning a Just
11:12:04 <d04jk> glguy, yeah exactly, that one is easy ;)
11:12:13 <edwardk> when m/=0, its safe to divide, so it does so and returns that wrapped in a Just, otherwise it returns Nothing rather than blow up trying to perform a division by zero =)
11:13:06 <d04jk> maybe i was unclear, but the latter example i, think, i understand
11:13:08 <Igloo> d04jk: Is it http://rafb.net/paste/results/npAEJA87.html you have problems with?
11:13:10 <glguy> and that won't compile, because "nothing" doesn't mean anything ;) and div needs to be surrounded with backticks
11:13:11 <edwardk> also was that missing some back quites and a capital on Nothing?
11:13:29 <d04jk> Igloo, yes
11:13:49 <glguy> d04jk: which part of it specifically?
11:13:50 <d04jk> glguy, i just copied it manually from a book ;)
11:13:56 <edwardk> d04jk: that one will return the first "Just" it finds out of its rwo arguments. so
11:14:12 <Igloo> d04jk: Is http://rafb.net/paste/results/H9yuJt26.html easier to understand?
11:14:21 <edwardk> foo `orElse` bar, will return foo if foo is of the form "Just something" or bar if foo is of the form Nothing.
11:15:04 <d04jk> ah, probably the _ i dont understand ;)
11:15:19 <glguy> _ is a variable that is only used once
11:15:23 <edwardk> _ is a magical variable name that says 'i don't care, don't bother binding it to a variable'
11:15:46 <edwardk> so if you just are going to ignore the variable, rather than make you call it 'dummy' or some such nonsense, just bind it to _
11:15:47 <d04jk> i see, maybe it's the "pattern matching" i dont understand really
11:15:56 <edwardk> do you understand case?
11:16:07 <d04jk> in what language?
11:16:17 <glguy> d04jk: orElse (Just a) ... means, if the argumetn is a Just, bind 'a' to the value contained in the just
11:16:25 <edwardk> well, you can rewrite that example in haskell as
11:16:59 <d04jk> edwardk, when you say case, i think of "guards"
11:16:59 <edwardk> orElse x y = case x of { Nothing -> y ; Just a -> Just a }
11:17:35 <d04jk> glguy, what would "is a Just" mean?
11:17:37 <edwardk> d04jk: case in haskell does pattern matching on all of the parts of a constructor. so Nothing has no arguments, Just a, has a simple argument.
11:17:55 <edwardk> so if you use case in haskell you are really saying 'crack open this thing and show me its guts'
11:17:58 <glguy> d04jk: something of type Maybe a is either a Just a, or a Nothing
11:18:04 <d04jk> yes
11:18:15 <edwardk> but since Nothing and Just take different numbers of arguments, each version needs a different set of arguments.
11:18:30 <edwardk> hence in the above case, i cracked open the first argument with case
11:19:02 <d04jk> I think i didn't relize that Nothing and Just are types them self
11:19:14 <Cale> Nothing and Just are not types
11:19:16 <edwardk> Nothing and Just are 'constructors'
11:19:20 <d04jk> hehe, well
11:19:31 <edwardk> somewhat related as a notion, but its not Java =)
11:19:35 <weitzman> Well, they correspond to Java classes somewhat
11:19:42 <weitzman> Which could be called types
11:20:14 <edwardk> you can think of them as tags what indicate which version of Maybe you have. gotta be careful to avoid the term types for constructors or people like cale will jump down your throat ;)
11:20:40 <fasta> Why doesn't /topic include a way for people to actually learn Haskell? Like a link to YAHT?
11:21:00 <weitzman> I'm not too familiar with GADTs, but I think the specific constructors used are involved in typechecking
11:21:01 <glguy> Cale is alaways watching too, so don't think that because he's not talking that he's not waiting to pounce
11:21:09 <d04jk> sorry for that, but i just think of them as some kind of "keyword" indicating weither something was going to stay as it was, or "not be anything at all"
11:21:10 <edwardk> yeah =)
11:21:21 <edwardk> sure
11:21:23 <ventonegro> glguy, Cale == Chuck Norris?
11:21:33 <edwardk> they are tags that indicate what you are looking at.
11:21:39 <cjeris> d04jk: do you know C unions? every one of these types is like a tagged union in C, except without the suck
11:22:09 <glguy> cjeris: I stopped using the suck keywords a long time ago in my C code..
11:23:13 <edwardk> or in java it would be like attempting to cast up from some common superclass to a subclass that you might not have. if you fail the cast, you fail the pattern match. Haskell pattern matching is kind of like asking a java object to cast to a subclass and hand you back all of its values in local variable names all at once.
11:23:28 <Cale> glguy: The fact that I wasn't talking in this instance would be because I was calling my ISP to cancel service since we're switching to another provider.
11:23:40 <edwardk> ah
11:23:47 <glguy> Cale: good to know ;)
11:23:51 <cjeris> glguy: i have a little perl script that aliases gcc -freduced-suckage to ghc
11:23:55 <edwardk> we just figured you were letting him get enough rope to hang himself with ;)
11:24:04 <Cale> heh
11:24:07 <edwardk> cjeris: heh
11:24:24 <glguy> edwardk, cjeris : heh
11:24:39 <d04jk> well, you've all been really helpfull, i just need to catch up on some basic stuff i think
11:24:46 <glguy> avoid basic
11:24:51 <d04jk> i will :D
11:24:51 <glguy> not a good language
11:24:54 <glguy> ;)
11:24:56 <Cale> @quote+ cjeris i have a little perl script that aliases gcc -freduced-suckage to ghc
11:24:56 <lambdabot> cjeris i have a little perl script that aliases gcc -freduced-suckage to ghc hasn't said anything memorable
11:25:02 <Cale> @remember cjeris i have a little perl script that aliases gcc -freduced-suckage to ghc
11:25:06 <Cale> hmm
11:25:14 * glguy wonders what just happened
11:25:17 <edwardk> d04jk: the trick is not letting constructors and types and classes in haskell get intermixed with constructors and types and classes in your mind from Java. They are all very very different.
11:25:39 <edwardk> lambdabot doesn't love you cale.
11:26:02 <edwardk> @quote cjeris
11:26:02 <lambdabot>  i have a little perl script that aliases gcc -freduced-suckage to ghc
11:26:06 <edwardk> ah it did take it
11:26:06 <Cale> @quote cjeris
11:26:07 <lambdabot>  i have a little perl script that aliases gcc -freduced-suckage to ghc
11:26:09 <Cale> okay
11:26:15 <Cale> it's just quiet about it
11:26:18 <edwardk> yeah
11:26:21 <edwardk> @quote cale
11:26:21 <lambdabot> cale hasn't said anything memorable
11:26:23 <kettle> @[1,2,3]
11:26:23 <lambdabot> Unknown command, try @list
11:26:24 <edwardk> @quote Cale
11:26:24 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
11:26:50 <edwardk> kettle: that was either very strange or a very oblique joke.
11:27:57 <glguy> ?. elite quote
11:27:57 <lambdabot> iN\/2004 $aY5: la/\/\bd480+: /\/\On4dz ?
11:30:07 <edwardk> @tell dons what would it take to make @type prepend the name of the function, so it could be @.'d with free?
11:30:07 <lambdabot> Consider it noted.
11:30:54 <edwardk> @help check
11:30:55 <lambdabot> check <expr>
11:30:55 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
11:31:01 <Pupeno> Are Haskell Chars/Strings unicode ?
11:31:11 <edwardk> pupeno: in theory.
11:31:39 <edwardk> pupeno: Char is 32 bit. In practice it seems implementations just take them mod 256 though =(
11:31:43 <Pupeno> edwardk: and in practice ?
11:32:02 <Pupeno> edwardk: including ghc ?
11:32:13 <glguy> > maxBound :: Char
11:32:14 <edwardk> ghc was where i saw that comment about mod 256 =)
11:32:14 <lambdabot>  '\1114111'
11:32:35 <Igloo> Char is 32-bit in ghc, but lots of functions treat it as being 8-bit
11:32:51 <edwardk> i think in 6.5+ is trying to fix that, and letting unicode operators and function names in
11:33:00 <edwardk> but not sure how many things still have broken logic
11:35:34 <emu> shouldn't Char be abstract?
11:35:41 <emu> or more abstract than "32 bit"
11:36:08 <edwardk> arguably Char maybe should be a class or something like Num, but right now its just a 32 bit bucket ;)
11:36:28 <emu> that sounds like a good idea
11:36:46 <SamB> ergh!
11:36:46 <edwardk> then you could have instances of Char like Ascii or Iso8859_1 or Utf8, etc, but then you now have multiple character chars, etc.
11:36:52 <emu> permitting user-extensible instances
11:36:52 <SamB> um...
11:36:56 <edwardk> and life gets hella complicated
11:36:59 <emu> hehe
11:37:00 <emu> i guess
11:37:07 <emu> you'd need a default for Char
11:37:21 <SamB> I think Stringy would make a better class than Chary would
11:37:26 <emu> yea
11:37:56 <emu> the connection between "Chars" in a string can be different in various languages
11:37:58 <SamB> but it might not be very pretty without views
11:38:04 <edwardk> and try to explain to newbies why they need to say: foo :: Char a => [a] -> ... for their functions ;)
11:38:18 <cjeris> peelCheese :: Stringy chz => [chz] -> chz
11:38:20 <SamB> or to oldbies!
11:38:25 <SamB> cjeris: heh
11:38:28 <edwardk> heh
11:38:40 <SamB> hmm.
11:38:47 <SamB> don't you have that backwards?
11:38:53 <SamB> shouldn't it be...
11:38:58 <edwardk> well, i'm all for a clean UTF-8, UTF-16, etc. abstraction, as soon as someone finds one that isn't clunky i'll go and implement it in a project or something ;)
11:39:02 <emu> there's a lot of annoying issues which i generally try not to think about regarding i18n support
11:39:05 <SamB> peelCheese :: Stringy chz => chz -> [chz]
11:39:29 <emu> (i just hope someone else has in the implementation!)
11:39:51 <SamB> perhaps it would be...
11:39:52 <edwardk> yeah i have to do lots of internationalization working in linguistics, and before that i was a big i18n/l10n fan in the design of my systems.
11:40:19 <dcoutts__> Char is fine, it's just a Unicode code point
11:40:26 <cjeris> SamB: i think to do this correctly we need to implement the Mozzarella monad
11:40:28 <dcoutts__> no need for UTF variants of it
11:40:39 <SamB> class Stringy string char | string -> char where ....
11:40:40 <edwardk> though i admit to taking the dumb american stance than unicode is good enough, which of course pisses off chinese and japanese users ;)
11:40:43 <dcoutts__> it's strings which need the abstraction over encoding/representation etc
11:40:56 <emu> yea
11:41:14 <edwardk> dcoutts: well, motivating for instance than bytestrings are usually best stored in utf8, etc when you don't need ready access to their length, etc.
11:41:20 <SamB> and then "Hello, World!" :: Stringy s Char => s
11:41:22 <edwardk> dcoutts: there are good reasons for all of the representations
11:41:28 <edwardk> well, almost all =)
11:42:05 <edwardk> dcoutts: and yeah i agree its probably the strings that should be fixed, not the chars
11:42:25 <DeliQ> can somebody help me? question about binary tree...
11:42:26 <edwardk> dcoutts: then you can fix the iterators for the strings to deal with multibyte encodings etc.
11:44:34 <glguy> > let fibs = fix(scanl1(+).([0,1]++)) in take 10 fibs
11:44:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
11:45:55 <glguy> > let fibs = fix(scanl(+)0 .(1:)) in take 10 fibs
11:45:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
11:46:08 <emu> ?ty fix
11:46:09 <lambdabot> forall a. (a -> a) -> a
11:46:28 <fasta> Does Haskell' dump the monomorphism restriction?
11:46:50 <SamB> we don't know yet!
11:46:53 <DeliQ> say I represent a set S = {1, 3, 4, 5, 7, 8, 13} in a binary search tree, i'm looking for 2 numbers who have the smallest difference, but I don't know how to do it?
11:47:00 <SamB> it is still Haskell', after all!
11:47:08 <fasta> SamB: OK!
11:47:12 <fasta> SamB: I understand!
11:47:17 <fasta> SamB: ;) !
11:47:54 <emu> @hoogle fix
11:47:54 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:47:54 <lambdabot> Control.Monad.Fix :: module
11:47:54 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
11:48:25 <fasta> DeliQ: that's a typical data structure course problem
11:48:31 <DeliQ> idd
11:48:45 <DeliQ> i need a starting point on how to solve it
11:49:30 <emu> ?doc Control.Monad
11:49:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
11:49:39 <DeliQ> i needs to be O(n) so you have to use a traversal i guess
11:50:01 <DeliQ> postorder or something
11:51:30 <DeliQ> nobody ?
11:53:38 <glguy> DeliQ: why would you use a binary search tree to find thenumbers with the smallest difference?
11:54:00 <DeliQ> it was a question in an exam
11:54:13 <DeliQ> so it isn't my idea :P
11:54:56 <glguy> well... I'd say that since it's a binary search tree, then it woudl be easy to retreive a sorted list of elements
11:55:00 <ventonegro> is there a library for generating images?
11:55:09 <glguy> and then i'd just go down the list looking for the smallest difference
11:55:20 <DeliQ> idd, inorder traversal..
11:55:28 <DeliQ> would yield a sorted list
11:55:42 <glguy> yeah..
11:55:51 <DeliQ> what is your point then ?
11:56:28 <glguy> I guess I don't know what you are asking then, nevermind
11:56:47 <DeliQ> hehe, thanks for time anyway;)
11:56:50 <DeliQ> your
11:56:57 <dmhouse> I don't know what exactly a binary search tree is, but if you could do an ordered traversal, then surely it's easy?
11:57:14 <glguy> i just said that and got shot down :)
11:57:31 <DeliQ> how do i find the the numbers then ?
11:57:42 <DeliQ> it needs to be O(n) worst case
11:57:55 <int-e> DeliQ: you got your answer already'
11:58:04 <glguy> in-order traversal is O(n)
11:58:09 <DeliQ> true..
11:58:15 <glguy> and checking differences on a sorted list is O(n)
11:58:16 <dmhouse> DeliQ: find the difference between pairs of successive numbers
11:58:39 <DeliQ> so i also need to remember my current smallest difference
11:58:48 <dmhouse> Yeah.
11:59:08 <DeliQ> hmm
11:59:19 <DeliQ> than it's quite easy i guess :P
11:59:21 <SyntaxNinja> omg http://www.unsafeperformio.com/
11:59:23 <lambdabot> Title: Gill and Warbington Website
12:00:05 <dmhouse> What on earth is that?
12:00:16 <int-e> the result of unsafeperformio?
12:00:38 <SyntaxNinja> Andy Gill is a fairly prominent Haskell Hacker who works at galois
12:01:28 <SamB> so why does he waste it on a family-oriented website?
12:01:43 <int-e> why not?
12:01:46 * CosmicRay notes that gill-warbington.com brings up the same thing
12:01:56 <CosmicRay> perhaps he just got the domain registered and hasn't set up its own content yet?
12:02:05 <SamB> I suppose
12:02:10 <glguy> I think what SamB is trying to say is that no one wants to see pictures of his kid :-p
12:02:35 <SyntaxNinja> maybre we should make it a shared web site for photographs of the spawn of Haskell hackers.
12:02:50 <SyntaxNinja> that way, those who don't want to see such things shouldn't be going to unsafePerformIO.com anyway, obviously
12:02:57 <CosmicRay> heh
12:03:04 <SamB> well, I was just saying that his family won't appreciate the name unsafeperformio.com, whereas Haskell hackers are unlikely to appreciate photos of his kids...
12:04:23 <SyntaxNinja> yeah, babies are yuck
12:04:42 <SamB> well not exactly
12:04:42 <SyntaxNinja> but anyway, if you clicked on it, it's your own fault. it's obviously unsafe.
12:04:55 * CosmicRay keeps that in mind for when his own child is born in a few weeks ;-)
12:05:08 <SyntaxNinja> man, simon marlow started a trend ;)
12:05:40 * SyntaxNinja &
12:05:58 <SamB> but, I was hoping for intriguing uses of unsafePerformIO and suchlike things!
12:07:18 <CosmicRay> SamB: I think there are some that would argue this is the most intriguing use yet -- in fact, one that predates haskell itself by some thousands of years!
12:08:07 <SamB> CosmicRay: except that you don't use unsafePerformIO for that...
12:08:35 <ventonegro> no??
12:08:46 <CosmicRay> SamB: if nobody did, then plan b wouldn't be in the news ;-)
12:10:18 <glguy> If the religious right knew how powerful Haskell was, they'd protest it too
12:10:51 <glguy> with that claim that writing Haskell code is playing God
12:11:57 <fasta> What's "better" QuickCheck or HUnit?
12:12:36 <araujo> hi hi!
12:13:45 <dmhouse> fasta: QuickCheck's the more popular.
12:14:08 <fasta> dmhouse: Is it advisable to read the paper on it?
12:14:11 <dmhouse> QuickCheck applies in a lot of situations but I've come across ones where it doesn't, and forging my own test cases was better in that instance.
12:14:26 <dmhouse> fasta: I would assume so, although I haven't read it myself.
12:16:48 <SamB> HUnit is probably, like, work or something!
12:17:51 <xs> halfs does not work with ghc 6.2.2? and also does not work with fuse 2.5?
12:18:00 <xs> erm, s/6.2/6.4/
12:21:57 <glguy> > take 10 $ fix(([1,1]++).ap(zipWith(+))tail)
12:21:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
12:22:02 <dfranke> Well that was ingeniously tasteless...
12:22:10 <dfranke> at 8:46 a stunt plane buzzed my uni's clock tower.
12:22:17 <ventonegro> I'm planning a numerical simulation app, and I need arrays
12:22:25 <ventonegro> what are boxed and unboxed arrays?
12:22:31 <defcon8> simulation?
12:22:52 <glguy> lazy and strict (slower and faster), at least that's how I use them
12:24:02 <fasta> ventonegro: ever heard of premature optimization?
12:24:10 <ventonegro> so, MArray IOUArray ?
12:24:19 <ventonegro> fasta, yeah, i did :-)
12:24:27 * glguy has never heard of optimization that was premature... tell me more
12:24:43 <fasta> ventonegro: ok, there's a wiki entry by Bulat on arrays
12:25:59 <ventonegro> fasta, gonna search for it, thanks
12:27:15 <monochrom> boxed means pointer/reference to the real thing
12:29:21 <newbcoder> please give me a link to read up on ML vs Haskell
12:32:23 <monochrom> I can give you a link to read up on ML, and a link to read up on Haskell.  You can easily do the "vs" part afterwards.
12:32:39 <newbcoder> sounds good
12:32:42 * glguy is interested in the ML link ;)
12:33:08 * xerox smells an evil plan
12:33:08 <monochrom> Let me see if www.sml.org works
12:33:09 <dylan> <bitter>hopefully a link about SML and not ocaml. </bitter>
12:33:45 <newbcoder> wait wait
12:33:50 <newbcoder> please explain on sml vs ocaml
12:33:58 <newbcoder> the ocaml guys said they had the same mathematical rigor
12:34:01 <newbcoder> but web disagrees
12:34:06 <newbcoder> dylan: please enlightenme onthis deabte
12:34:09 <monochrom> http://en.wikipedia.org/wiki/Standard_ML
12:34:16 <monochrom> http://www.haskell.org/
12:34:16 <glguy> Welcome to #Haskell :)
12:34:18 <lambdabot> Title: Haskell - HaskellWiki
12:34:40 <dylan> newbcoder: as far as I know, there is nothing wrong with ocaml. The community around it is less active and seems less friendly to me than ... most other communities.
12:34:50 <araujo> newbcoder, Haskell is a purely functional language , neither ML  nor Ocaml is .....
12:35:43 <lightstep> araujo, are there pure functional languages beside haskell, clean and miranda?
12:35:58 <lightstep> (that is, not haskell-like languages?)
12:35:58 <glguy> Does scala count?
12:36:03 <dylan> lightstep: Erlang is pure and strict, no?
12:36:14 <araujo> lightstep, yes
12:36:15 <dylan> strict == non-lazy
12:36:15 <glguy> I guess scala might not be pure, i don't remember
12:36:16 <newbcoder> there is lisp w/o set! and c without =
12:36:34 <dylan> c without = is not a functional language.
12:36:37 <araujo> Also Hope ...
12:37:02 <lightstep> dylan, i think so. but you have threads, and when you call them they don't always return the same result
12:37:18 <dylan> lightstep: but threads arn't functions.
12:37:47 <psi> IO is not pure in erlang
12:37:49 <dylan> I suppose you could say ! is a non-pure  function.
12:38:02 <lightstep> i don't know the syntax, but you can surely create the counter function, like in list (let ((x 0)) (lambda () (inc! x) x)))
12:38:04 <dylan> well, erlang is strictly evaluated.
12:38:06 <lightstep> s/list/lisp/
12:38:16 <araujo> newbcoder, being a pure language goes beyond not having certain operators
12:38:16 <dylan> IO not being pure isn't really an issue to its functionalness, is it?
12:39:04 <araujo> That depends upon what you mean with 'functionalness' ...
12:39:05 <glguy> heh, it is if you don't want to be a poser- pure, functional language
12:39:30 <dylan> I would say erlang is as pure as it could be without uniqueness types of monads?
12:39:38 <fasta> dmhouse: how can I create a Property value?
12:39:38 <dylan> err, of = or
12:39:50 <glguy> are you askign what you would say?
12:40:08 <psi> dylan: *shrug* referential tranparency is lost. what does pure mean to you?
12:40:28 <dylan> I was adding the sound of a question to the sentence to express uncertainty.
12:41:26 <dylan> Erlang also does not make very many static gurantees.
12:41:53 <dylan> It makes no gurantee that a function will not perform I/O, just as it makes no gurantee a function won't accept an integer in place of a symbol.
12:42:50 <dylan> it's self-consistent in that regard. Haskell is more interesting because of the compile-time gurantees, of course.
12:44:05 <psi> well, with messages and IO, functions can return different values on every call
12:44:21 <dylan> or in one line, erlang is scheme with pattern matching, prolog syntax, and no -! functions. ;)
12:44:44 <newbcoder> what is -! functions
12:44:47 <fasta> cuts
12:44:50 <dylan> err
12:44:54 <fasta> er wrong
12:44:57 <dylan> I mean functions ending with !
12:44:57 <newbcoder> what are cuts?
12:45:00 <newbcoder> oh
12:45:03 <glguy> destructive functions
12:47:39 <dylan> Oh.
12:47:46 <dylan> And doesn't haskell have things like unsafePerformIO?
12:48:06 <lightstep> dylan, only in the ffi addendum
12:48:15 <lightstep> it wasn't in the original standard
12:48:33 <dylan> okay, point taken.
12:48:35 <lightstep> and it's not a natural part of the language, like multithreading in dylan
12:48:56 <dylan> Would unsafePerformIO be unsafe if the language had non-lazy evaluation?
12:49:00 <Pupeno> @seen shapr
12:49:00 <lambdabot> Last time I saw shapr was when I left #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it, #haskell.se, #haskell_ru, #oasis, #perl6 and #scannedinavian
12:49:00 <lambdabot> 2d 12h 25m 36s ago, and .
12:49:23 <lightstep> it breaks type safety
12:50:18 <dylan> hmm, anyway, I think I shall avoid using the term "purely functional" in the future. To some (Erlang people, for instance?) it means only single assignmnet, no mutable variables.
12:50:32 <dylan> But for more people, it implies referential transparency, yes?
12:51:06 <pejo> dylan, Amr Sabry has written an article about what a pure functional language is.
12:52:14 <araujo> dylan, actually , referential transparency is one of the most important feature for considering a language purely functional
12:52:15 <fasta> pejo: so, this person decides what a pure functional language is?
12:52:20 <dylan> I'd be more interested in how the usage of "purely functional" has evolved in literature over a large span of time.
12:53:28 <pejo> fasta, since he probably spent some time pondering the question I'd say it's worth a read.
12:53:32 <dylan> I'll try to use the term that will cause the least amount of confusion, but I am certain I've read in multple places Erlang refered to as a purely functional language.
12:53:35 <araujo> And actually, many authors would go saying "Haskell is purely functional because it is referentially transparent..."
12:53:38 <dylan> Perhaps by those less educated in such matters.
12:55:50 <dylan> Ah, and I have read "What is a purely functional language" by Amr Sabry, it was in the comp.lang.functional FAQ.
12:55:57 <pejo> fasta, and one of the things stated pretty early in the article is that referential transparency and independence of order of evaluation do not have agreed upon definitions for starters.
12:56:28 <glguy> So it all comes down to Haskell envy?
12:56:29 <glguy> ;)
12:56:36 <monochrom> It's always prudent to use an ambiguous language in a way that will cause least confusion to the known audience.
12:56:38 <fasta> pejo: yes, I saw that he coauthored with a number of other guys that I already regard as not wasting my time.
12:57:01 <dylan> monochrom: yes, but it's sometimes hard to remember what language to use when one reads so many different things.
12:57:39 <monochrom> Yeah, the calamity of being above the crowd and having vision.
12:57:44 <dylan> Heck, I forgot the word "apple" earlier today. And english is my native language.
12:58:07 <dylan> I only remembered the spanish word for it. :-/
12:58:19 <monochrom> Your brain is amazing :)
12:59:04 <dylan> well, that reminds me..
13:00:02 <dylan> I think of ">>" in the IO monad as like the way I organize things in my mind.
13:00:52 <dylan> e.g. the way one has to think to avoid saying words out of order.
13:00:56 <fasta> -fno-monomorphism-restriction only affects performance, right?
13:01:20 <fasta> (and some programs do work with it)
13:03:03 <dylan> doesn't -fno-monomorphism-restriction allow ambiguous types and repeated evaluation of some things?
13:03:49 <bitshifter> has anyone used hp2ps lately?
13:06:13 <fasta> dylan: yes, that's what I said only somewhat more abstract.
13:06:22 <glguy> wouldn't scoped type variables fix the monomorphism restriction?
13:07:25 <dylan> fasta: ah, so I take it ambiguous types don't lead to the type checker going into a loop.
13:07:39 <fasta> dylan: no, that's not the problem.
13:09:03 <fasta> dylan: and I am not too sure regarding the ambiguous types.
13:13:57 <bitshifter> does hp2ps output ill-formed postscript for anyone else here?
13:16:44 <Trevion> bitshifter, I think it is for a colleague of mine.
13:20:49 <Igloo> bitshifter: With a 6.6 RC?
13:20:53 <glguy> What is hp2ps? Does it convert HP inkjet formatted documents to postscript?
13:21:02 <Igloo> glguy: hp == heap profile
13:21:17 <glguy> oh..
13:21:21 <Igloo> glguy: Compile with -prof -auto-all and run with +RTS -h to make one
13:21:21 <bitshifter> 6.4.2 actually
13:21:41 <kzm__> bitshifter, I get that only when I try to run gv on the .hp file instead of the .ps :-)
13:21:49 <Igloo> bitshifter: Can you put the .hp and .ps file on the web somewhere?
13:22:18 <bitshifter> certainly, is there a wiki-post-thing for this channel?
13:22:19 <Igloo> bitshifter: (the .hp should compress well if it is large)
13:22:30 <Igloo> @paste
13:22:30 <lambdabot> http://paste.lisp.org/new/haskell
13:22:33 <Igloo> There's that
13:22:53 <Igloo> I think there's a paste page on the wiki too, but I don't know where OTTOMH
13:23:36 <Igloo> Ah, http://haskell.org/hawiki/HaskellIrcPastePage
13:23:41 <dmhouse> An actual pastebin's better.
13:28:09 <bitshifter> http://home.frognet.net/~bitshftr/haskell/hp2ps-failure.tar.bz2
13:28:12 <lambdabot> http://tinyurl.com/jmsfj
13:28:23 <dmhouse> Plus paste.lisp.org has Emacs integration! That's really convenient.
13:28:51 <dmhouse> Mark something, C-c p, choose a channel and nick and it sends an XMLRPC.
13:29:25 <int-e> and it got haskell syntax highlighting.
13:31:15 <bitshifter> Igloo: it's ~1MB
13:31:35 <Igloo> bitshifter: Nothing jumps out at me. I'll investigate
13:32:45 <dmhouse> int-e: and wicked-bad indentation.
13:33:02 <bitshifter> Igloo: when I try to view the ps file it creates it gives me a syntax error
13:33:17 <Igloo> bitshifter: Yeah, I get the same problem
13:33:27 <bitshifter> file position 72236?
13:34:27 <Igloo> Near enough - 72248. Probably just different hp2ps options/version
13:35:08 <ventonegro> is it correct to use newArray with IOUArrays?
13:36:21 <int-e> @index newArray
13:36:21 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Foreign.Marshal.Array, Foreign.Marshal, Foreign
13:36:25 <int-e> yep
13:36:43 <int-e> @type Data.Array.MArray.newArray
13:36:44 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:36:54 <inv2004> hi all
13:37:50 <ventonegro> i have type DoubleArray = IOUArray Int Double
13:38:09 <ventonegro> but au = newArray (1, size) 0.0 gives me an error
13:38:30 <ventonegro> Couldn't match `Double' against `a Int e'
13:38:36 <int-e> try  au = newArray (1, size) 0.0 :: DoubleArray
13:38:45 <int-e> hmmmm
13:40:00 <int-e> check the surrounding code for why it thinks au is of type IO Double
13:42:18 <int-e> sorry, that should've been :: IO DoubleArray
13:42:52 <int-e> giving au a type signature (or its expression as I did above) will help in localizing the error.
13:43:34 <ventonegro> now it is Couldn't match `DoubleArray' against `IO DoubleArray'
13:44:18 <int-e> I know, I was missing an IO there.
13:44:36 <int-e> I already wrote that.
13:44:46 <int-e> hmm.
13:45:03 <int-e> unless it's complaining about a different place now?
13:45:12 <ventonegro> nope, same place
13:45:40 <glguy> Is there a way to use fix to return the fixpoint of this function?
13:45:42 <glguy> > take 10 (iterate (\(a,b) -> (a + b `mod` 10, b `div` 10)) (0,456))
13:45:42 <lambdabot>  [(0,456),(6,45),(11,4),(15,0),(15,0),(15,0),(15,0),(15,0),(15,0),(15,0)]
13:46:03 <ventonegro> oops, my bad
13:46:04 <Syzygy-> @type fix
13:46:05 <lambdabot> forall a. (a -> a) -> a
13:46:09 <ventonegro> it's a differente place now
13:46:14 <ventonegro> different
13:46:45 <daavid> data Cp x = Cp x | None deriving (Show)
13:46:47 <daavid> apa [x] = (x, None)
13:46:49 <daavid> apa (x:xs) = (x, Cp (apa xs))
13:46:51 <daavid> why doesn't that work?
13:47:24 <daavid> i'm trying to generate e.g. (1, (2, (3, None))) from [1,2,3]
13:48:25 <ventonegro> Couldn't match `Double' against `a i e'
13:48:35 <int-e> @pl fix' f a = if a==f a then a else fix' f (f a)
13:48:36 <lambdabot> fix' = fix (ap (ap . join . (if' .) . ap (==)) . ((.) =<<))
13:49:09 <int-e> glguy: you can express general recursion with fix, but I think that's not what you meant.
13:49:17 <glguy> correct
13:49:24 <int-e> glguy: so the answer is no
13:49:38 <glguy> ok :)
13:50:03 <int-e> daavid: there's no type for that function
13:50:21 <ventonegro> hum... newArray seems to wrap the results in a monad
13:50:24 <dcoutts__> glguy: you want something like: iterateToFixpoint f x = let xs = iterate f x in fst $ head $ dropWhile (uncurry (/=)) $ zip xs (tail xs)
13:50:43 <daavid> int-e: what do you mean?
13:51:00 <glguy> dcoutts__:yeah... I knew how ot write that, I was just seeing if there was a way to be clever with it
13:53:10 <int-e> daavid: the compiler should be complaining about having to construct an infinite type. that's exactly what's happening. the type of apa would be   [a] -> (a, Cp (a, Cp (a, Cp (a, ...)))))
13:53:28 <int-e> daavid: and such infinite types don't exist in Haskell's type system.
13:54:03 <glguy> > take 10 $  fix (\xs -> 1 : (head xs + 1) : xs)
13:54:04 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
13:54:20 <int-e> daavid: the trick is to make Cp itself recursive, data Cp a = None | Cp (a, Cp a) - which is pretty much the definition of a list.
13:55:17 <monochrom> Who is re-inventing lists? :)
13:55:23 <int-e> daavid.
13:55:47 <int-e> although it looks more like an attempt at reinventing lisp, in haskell, to me.
13:57:49 <edwardk> Random obligatory question: Anyone here know anything about display logics and/or gaggle theory?
13:58:02 <xerox> > take 10 $ fix ([1,2]++)
13:58:03 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
13:58:24 <mahogny> int-e, template haskell is reinventing lisp for haskell. might not be a bad thing at times ;)
13:58:43 <edwardk> mahogny: and we all know how intuitive template haskell is =P
13:59:20 <mahogny> it's on my don't-touch list. lets see how long I can stay away from it :(
13:59:46 <edwardk> its not that bad actually.
13:59:55 <lispy> i'm trying to find information on the trick here you extend the IO monad with your application state...what is that called gain?
14:00:19 <int-e> StateT
14:00:23 <edwardk> I found that with about 2 hours worth of preparation I was able to generalize a bunch of code for doing binary type level operations to a bunch of template haskell code for doing hexadecimal type level arithmetic.
14:00:26 <int-e> trick?
14:00:35 <edwardk> i just had to learn to contort my thinking into template haskell
14:01:01 <edwardk> and its totally unreadable
14:01:01 <int-e> there are also global variables (sort of), that would qualify as a trick in my book.
14:01:03 <lispy> int-e: thanks...well design pattern
14:01:11 <emu> @type fix
14:01:12 <lambdabot> forall a. (a -> a) -> a
14:01:26 <emu> > fix (1+)
14:01:27 <lambdabot>  Exception: <<loop>>
14:01:35 <edwardk> StateT Foo IO is really useful as a pattern =)
14:01:42 <lispy> int-e: this code already does a lot of work in the IO monad, now it would be nice if it would also thread a bit of state (or just an environment) for me
14:01:46 <Syzygy-> > fix (1*)
14:01:47 <lambdabot>  Exception: <<loop>>
14:02:23 <emu> @type mzero
14:02:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:02:31 <int-e> edwardk: do the [|...|] things help?
14:02:31 <edwardk> lispy: carry your 'globals' around in Foo, then lift to do IO. and x <- get and x <- set to set your state. you can even store IOrefs in the state so it can be immutable with just refs that change
14:02:34 <glguy> > take 10 $  fix (1:)
14:02:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
14:02:42 <edwardk> int-e: not very much
14:03:12 <emu> > [1,2] `mplus` [2,3]
14:03:13 <lambdabot>  [1,2,2,3]
14:03:14 <edwardk> int-e: especially if you use TH for generating class instances, etc.
14:03:14 <int-e> that's a pity then, because then it'll be horrible compared to lisp.
14:03:31 <lispy> edwardk: and if you didn't want to have the env be mutable you'd use ReaderT Foo IO?
14:03:57 <edwardk> lispy: you can. I never did get around to liking ReaderT, but thats its purpose =)
14:04:02 <bitshifter> Does anyone know what the format of heap profile files is?
14:04:22 <edwardk> ReaderT Foo IO can be pretty powerful I guess, especially if Foo contains IORefs anyways.
14:04:34 <bitshifter> the GHC reference pages are quite unhelpful
14:05:38 <monochrom> Given a convergence test (a -> a -> Bool) and a function (a -> a) to be iterated, and an initial value (a) too, we can get the convergent thusly: convergent test function init = search (iterate function init) where search (x:xs@(y:_)) = if test x y then x else search xs
14:06:23 <monochrom> Usually the convergence test is equality or "close enough under a given threshold".
14:06:46 <edwardk> gah
14:06:56 <edwardk> trillian can be a little annoying at times
14:07:15 <monochrom> Remark: the words "fixpoint", "fixed point", etc., have very different meanings in different communities.  In particular, the PL meaning is very different from the NA meaning.
14:07:33 <fasta> monochrom: NA?
14:07:53 <monochrom> Given this is a PL community, I wouldn't use this word to refer to the NA notion.  I have chosen the word "convergent" for that.
14:08:08 <fasta> monochrom: I mean what is NA?
14:08:14 <monochrom> Numerical analysis.
14:09:03 <monochrom> I think it is a bit perverse now of glguy to be obsessed with the "fix" function for convergents, after months of being told it's relatively irrelevant.
14:09:11 <edwardk> heh
14:09:30 <monochrom> Perhaps not irrelevent, but certainly beside the point.
14:10:31 <araujo> How can i turn a [Char] into a ByteString?
14:10:38 <dcoutts__> pack
14:10:49 <araujo> hi dcoutts__ :-)
14:10:57 <dcoutts__> Data.ByteString.Char8.pack
14:11:00 <dcoutts__> hia araujo
14:11:09 <monochrom> It's like asking "how do I use referential transparency for Gaussian elimination?"  OK, if you write in Haskell, you certainly will want to work with referential transparency, but it's hardly a noteworthy aspect of any implementation of Gaussian elimination.
14:11:17 <araujo> dcoutts__, ok, i check
14:11:52 <edwardk> mono: that almost sounds like something protontorpedo would ask ;)
14:11:58 <edwardk> @quote protontorpedo
14:11:58 <lambdabot> protontorpedo hasn't said anything memorable
14:12:07 <edwardk> hrmm
14:12:14 <edwardk> what was his nick again? =)
14:12:22 <edwardk> @quote photontorpedo
14:12:22 <lambdabot> photontorpedo hasn't said anything memorable
14:12:25 <edwardk> hrmm
14:12:33 <kpreid> @protontorpedo
14:12:33 <lambdabot> treid comon lisp. ansi common lisp bok by graham. it sucked
14:12:39 <monochrom> My convergence test then concludes that glguy and protontorpedo are "close enough under a given threshold". :)
14:12:43 <kpreid> edwardk: the notables get their own commands
14:12:43 <edwardk> @photontorpedo
14:12:43 <lambdabot> look at smalltalk. they invented oo proramming
14:12:47 <edwardk> ah
14:12:52 <edwardk> @photontorpedo
14:12:53 <lambdabot> why did someone create haskell?
14:13:07 <edwardk> of course, coz them being treated like other folks would be consistent ;)
14:13:11 <araujo> thanks dcoutts__ !
14:13:15 <dcoutts__> np
14:13:26 <bitshifter> In haskell heap profiling, is there a way to get the rts to spit out the WHOLE identifier instead of truncating and adding "..."?
14:13:30 <fasta> @photontorpedo
14:13:30 <lambdabot> that dude is selling u  a book
14:13:35 <edwardk> guess he wasn't that memorable i couldn't even remember his name
14:15:02 <edwardk> gotta go
14:16:09 <Trevion> @photontorpedo
14:16:09 <lambdabot> how does haskell do with large systems?
14:16:38 <monochrom> Perhaps a better analogy is this.  A conference organizer learns Haskell lately and comes in to ask "how do I use functions to model events?"  The question is asked because he confuses "conference function" with "Haskell function".
14:17:53 <emu> you can model events with functions!
14:18:19 <emu> doh, i just tried to use a ratpoison keybinding on windows
14:21:37 <monochrom> ratpoison?
14:22:55 <fasta> WM
14:23:25 <fasta> Apparently one all the cool hackers are using
14:24:05 <emu> I am trying to eliminate rat-usage
14:25:15 <monochrom> Aha! Now I understand.  But I like my cute mouse! :)
14:25:45 <emu> you'll like it less when your wrist hurts from it
14:28:11 <mahogny> no mouse. suddenly it sounds interesting
14:28:44 <mahogny> except the stupid coders might consider making an effort in eliminating the mouse in gnome gtk etc
14:28:57 <mahogny> YAWM
14:33:52 <bitshifter> Igloo: I have some more info
14:34:22 <bitshifter> hp2ps -m4 pawprints.hp produces output that can be viewed
14:34:32 <dwm> Quick question about the classes in the prelude. I'm looking at the chart in the H98 Report. The graphy one with ovals for things like Eq, Show, Integral..
14:34:58 <bitshifter> 5 and up doesn't until you get to the point where it no longer tries to draw the key.
14:35:29 <dwm> So, let's take Integral as an example. Somewhere there's `class Integral a where ...`
14:35:49 <dwm> Actually, looks like `class (Eq a, Show a) => Integral a where ...`
14:36:13 <Igloo> bitshifter: Interesting, thanks
14:36:52 <dwm> So, then there are things in this chart not in bold, like in the Integral node: Int, Integer
14:37:23 <dwm> Are those things that were defined with data and then instanced to Integral?
14:37:30 <heatsink> yea
14:38:29 <Igloo> dwm: they are the "Prelude types that are instances of these classes" from the caption
14:38:32 <monochrom> Int is a type, an instance of a type class.  Integral is a type class.
14:38:49 <monochrom> I wouldn't commit myself to "defined with data".
14:39:05 <dwm> As in, could have been newtype
14:39:48 <monochrom> As in, they're builtin, you never know what non-Haskell tricks are used.
14:40:53 <dwm> ok, but they're not a class and not a type synonym. They're a data type.
14:40:59 <monochrom> Yes.
14:41:46 <dwm> Thank you.
14:47:43 <fasta> Igloo: I get a build error when building GHC from darcs. Do you have time to look at it? Or otherwise: is there a way to build GHC such that it works for sure?
14:49:18 <Igloo> fasta: What's the error?
14:49:19 <lisppaste2> glguy pasted "Game Sim" at http://paste.lisp.org/display/25846
14:49:33 <Igloo> fasta: And what OS/arch?
14:49:33 <glguy> wouldn't someone mind looking at that code, and telling me the correct way to simulate multiple turns?
14:49:48 <fasta> ------------------------------------------------------------------------
14:49:48 <fasta> make[2]: Makefile: No such file or directory
14:49:48 <fasta> make[2]: *** No rule to make target `Makefile'.  Stop.
14:49:48 <fasta> make[1]: *** [boot] Error 1
14:49:50 <fasta> make[1]: Leaving directory
14:50:11 <bitshifter> Does anyone know how to make heap profiling spit out the full identifier instead of just the first 20 charachters?
14:56:13 <monochrom> glguy: what is meant by "simulate multiple turns"?
14:57:06 <glguy> (I'm open to massive changes) I want to keep a tally of which squares get landed on the most
14:57:14 <glguy> simulateTurn was supposed to take the current position
14:57:21 <glguy> and advance to a new random position
14:57:29 <glguy> and keep a tally
14:57:44 <glguy> (maybe the tally should be kept outside)
14:58:02 <edwardk> you can stuff a tally in an array if you want
14:58:10 <glguy> I am :)
14:58:22 <edwardk> oh
14:58:24 <edwardk> doh =)
14:58:31 <monochrom> OK, if you have a notion of "current position" and it changes at each step, it should be part of your state too.  Consequently, "simulateTurn" should not take a parameter.
14:58:47 <glguy> ok
14:58:52 <glguy> and I also need to track the StdGen
14:58:54 <edwardk> glguy: thats going to b sooow, btw
14:58:58 <edwardk> er sloooow
14:59:06 <monochrom> Tally is also part of the state.  Easier that way.
14:59:09 <edwardk> coz of the // array modification
14:59:25 <glguy> edwardk: yeah... but I'm mostly doing this as an exercise in State
14:59:31 <monochrom> Ha, you can also use STArray or STUArray....
14:59:33 <edwardk> one sec.
15:00:15 <glguy> monochrom: so I've got to track StdGen, tally array, and current position
15:00:29 <glguy> do that all inside one State?
15:00:34 <edwardk> yeah
15:00:36 <monochrom> Up to you.
15:00:50 <monochrom> I would just use one layer of State.
15:00:52 <edwardk> modifying your code to do so now, and to use an IOArray
15:01:03 <edwardk> and to StateT IO
15:01:08 <monochrom> No!  No IOArray!
15:01:17 <edwardk> STArray? =)
15:01:29 <monochrom> OK, I can concede to STArray.
15:01:47 <edwardk> StateT'd ST is a little crufty to get used to though and confusing when you are first learning one or the other
15:02:10 <edwardk> coz of the capital S and T in StateT being unrelated to them in ST =)
15:02:15 <glguy> right
15:02:19 <monochrom> For self-education I still recommend doing State with immutable array and // first.  Then StateT ST for the second lesson.
15:02:25 <glguy> I've used STArray to write a fast Kruskals algorithm
15:03:53 <lisppaste2> glguy pasted "I've used ST before (figured this out on my own)" at http://paste.lisp.org/display/25850
15:17:28 <deadbeef> ?type isIEEE
15:17:30 <lambdabot> forall a. (RealFloat a) => a -> Bool
15:18:20 <deadbeef> > isIEEE (10 / 3)::Realfloat
15:18:21 <lambdabot>  Not in scope: type constructor or class `Realfloat'
15:18:28 <deadbeef> > isIEEE (10 / 3)
15:18:29 <lambdabot>  True
15:18:44 <deadbeef> > pi
15:18:45 <lambdabot>  3.141592653589793
15:18:46 <dibblego> reverse (dropWhile isSpace (reverse (dropWhile isSpace a))) -- can that be converted to using . for composing functions?
15:18:51 <deadbeef> > isIEEE pi
15:18:52 <lambdabot>  True
15:19:38 <deadbeef> dibblego: are you trying to invert the order of words in a sentence ?
15:19:55 <dibblego> I don't really know what I'm doing
15:20:10 <Igloo> dibblego: f = reverse . dropWhile isSpace . reverse . dropWhile isSpace   is if't a function definition
15:20:15 <dibblego> I read somewhere that x . y is the same as f x (y) (?)
15:20:30 <Igloo> f (g x) == (f . g) x
15:20:35 <dibblego> yeah that
15:20:52 <Igloo> You could also say (reverse . dropWhile isSpace . reverse . dropWhile isSpace) a
15:21:21 <dibblego> ah thanks
15:21:29 <glguy> unwords . map reverse . words
15:21:31 <glguy> ?
15:21:51 <glguy> or rather unwords . reverse. words
15:22:48 <deadbeef> > unwords . reverse . words $ "97 config files in /etc need updating"
15:22:49 <lambdabot>  "updating need /etc in files config 97"
15:23:14 <dibblego> > (reverse . dropWhile isSpace . reverse . dropWhile isSpace) "  abc  "
15:23:15 <lambdabot>  "abc"
15:23:35 <edwardk> glguy: almost done =)
15:23:40 <edwardk> glguy haven't forgotten you =)
15:23:49 <glguy> oh, cool :)
15:24:07 <edwardk> been refactoring the solution a bit
15:26:15 <dibblego> ?index unwords
15:26:15 <lambdabot> Data.List, Prelude
15:26:51 <deadbeef> > isInfinite (1/0)
15:26:52 <lambdabot>  True
15:26:54 <deadbeef> > isInfinite (1/1)
15:26:56 <lambdabot>  False
15:29:03 <deadbeef> ?tyèe seqiemce
15:29:05 <lambdabot> Not in scope: `seqiemce'
15:29:14 <deadbeef> ?type sequence
15:29:15 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:29:24 <deadbeef> omg, monads
15:31:04 <sjanssen_> @check \x -> x == x :: Float -> Bool
15:31:04 <monochrom> ?type (+)
15:31:05 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Float -...
15:31:06 <lambdabot> forall a. (Num a) => a -> a -> a
15:31:11 <edwardk> whee now to wrestle with the ST monad =-)
15:31:25 <edwardk> I never can just get the ST stuff to typeheck first time
15:31:53 <sjanssen_> @check (\x -> x == x) :: Float -> Bool
15:31:54 <lambdabot>  OK, passed 500 tests.
15:32:07 <sjanssen_> @check (\x -> x == x) :: Float -> Bool
15:32:08 <lambdabot>  OK, passed 500 tests.
15:32:20 <monochrom> edwordk: http://www.vex.net/~trebla/haskell/annote-STArray.html may help
15:32:23 <lambdabot> Title: How to annotate STArray types?, http://tinyurl.com/gmrt9
15:32:37 <sjanssen_> > let x = sqrt (-1) in x == x
15:32:38 <lambdabot>  False
15:32:47 <deadbeef> @check (\x -> x == x + 1 - 1) :: Fòpat -> Bool
15:32:48 <lambdabot>  Not in scope: type constructor or class `Fòpat'
15:32:50 <deadbeef> ops
15:32:54 <deadbeef> @check (\x -> x == x + 1 - 1) :: Float -> Bool
15:32:55 <lambdabot>  Falsifiable, after 29 tests: 0.33333334
15:32:59 <edwardk> mono: thanks =)
15:33:28 <sjanssen_> @check (\x -> x == x + 1 - 1) :: Float -> Bool
15:33:29 <lambdabot>  Falsifiable, after 8 tests: 0.5714286
15:34:06 <monochrom> Ha!
15:34:34 <AstralStorm> Now that's because of binary floats.
15:34:34 <AstralStorm> Define some small epsilon.
15:34:57 <deadbeef> @check (\x -> x == x + 1 - 1) :: Integer -> Bool
15:34:58 <lambdabot>  OK, passed 500 tests.
15:35:09 <weitzman> Is there a builtin that's like (.) but with the parameters reversed?
15:35:23 <AstralStorm> Is there some "epsilon comparison" operator?
15:35:28 <deadbeef> @check (\x -> x == x | False) :: Bool -> Bool
15:35:28 <lambdabot>  Parse error
15:35:47 <sjanssen_> @hoogle (>>>)
15:35:48 <lambdabot> Did you mean: (>>>)
15:35:48 <lambdabot> Prelude.undefined :: a
15:35:48 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:35:57 <deadbeef> @hoogle or
15:35:57 <lambdabot> Prelude.or :: [Bool] -> Bool
15:35:57 <lambdabot> Char.ord :: Char -> Int
15:35:57 <lambdabot> GHC.Conc.orElse :: STM a -> STM a -> STM a
15:36:18 <twanvl> > True || False
15:36:19 <lambdabot>  True
15:36:19 <deadbeef> @check (\x -> x == or [x, False]) :: Bool -> Bool
15:36:20 <lambdabot>  OK, passed 500 tests.
15:36:54 <weitzman> Hooray
15:36:55 <lisppaste2> edwardk annotated #25846 with "Partial set of changes. ST monad stuff here is totally hosed though" at http://paste.lisp.org/display/25846#1
15:37:00 <twanvl> deadbeef: | is for gaurd syntax, || is boolean or
15:37:07 <deadbeef> ok, thanks
15:37:08 <edwardk> so someone want to carry that the rest of the way? =)
15:37:10 <weitzman> I find (words >>> reverse >>> unwords) more readable then (unwords . reverse . words)
15:37:22 <AstralStorm> deadbeef: to reiterate - how does one implement a comparision with defined precision in Haskell?
15:37:39 <deadbeef> AstralStorm: no idea, i'm a newb
15:37:50 <AstralStorm> ~== operator for instance :>
15:37:57 <AstralStorm> Ah.
15:38:21 <deadbeef> maybe
15:38:39 <sjanssen_> weitzman: you might want to try Control.Arrow.>>>
15:38:46 <twanvl> Something like: > a ~== b = abs (a - b) < 0.0000001
15:38:57 <deadbeef> if ((x - 0.1) < y < (x + 0.1)) then true
15:39:08 <weitzman> sjanssen_: Thanks
15:39:09 <deadbeef> but surely there's something better
15:39:19 <deadbeef> ah ok there's not
15:40:37 <hyrax42> anyone have links on doing ai stuff in haskell
15:40:37 <AstralStorm> twanvl: simple, thanks :>
15:40:56 <AstralStorm> Just from math definition of epsilon, as I thought.
15:41:06 <hyrax42> diong an intro to ai course, and want to use haskell methinks
15:41:07 <hyrax42> or try
15:41:16 <hyrax42> there's a competition involved :p
15:41:16 <glguy> simulateTurn :: StateT (Int,(Array Int Int)) (State StdGen) ()
15:41:21 <glguy> this does what I was expecting
15:41:33 <glguy> but I'm going to suspect that I don't way to use a stateT when my return type is ()
15:41:37 <sjanssen_> @let infix 5 ~==; x ~== y = abs (x - y) < epsilon; epsilon = 1e-5
15:41:38 <lambdabot> Defined.
15:41:43 <AstralStorm> Oh, is there a way to embed a limited haskell interpreter in a haskell app?
15:41:48 <monochrom> glguy: it is correct.
15:42:07 <sjanssen_> @check \x -> x ~== x - 1 + 1
15:42:08 <lambdabot>  Not in scope: `~=='
15:42:28 <sjanssen_> @check \x -> x L.~== x - 1 + 1
15:42:29 <lambdabot>  OK, passed 500 tests.
15:42:32 <AstralStorm> sjanssen_: you first have to define it :>
15:42:33 <sjanssen_> yay!
15:42:38 <bitshifter> heap profiling with +RTS -hx gives me an error message saying invalid heap profile option, it goes on to list options including -hx am I missing something?
15:42:41 <AstralStorm> Yep
15:42:45 <sjanssen_> AstralStorm: that's what the @let was for
15:42:59 <glguy> monochrom: I think what I should have done is: (Int,Array Int Int)-> State StdGen (Int, Array Int Int)
15:43:00 <AstralStorm> @check (\x -> x L.~== x + 1 - 1) :: Float -> Bool
15:43:01 <lambdabot>  Couldn't match `Double' against `Float'
15:43:13 <glguy> monochrom: and then used iterate or something
15:43:14 <monochrom> No no no no no.
15:43:24 <AstralStorm> Hmm, it defined it as Double :>
15:43:26 <AstralStorm> @check (\x -> x L.~== x + 1 - 1) :: Double -> Bool
15:43:27 <glguy> ok, then I'll stick with what I've got :)
15:43:27 <lambdabot>  OK, passed 500 tests.
15:43:48 <sjanssen_> AstralStorm: yep monomorphism restriction/numeric defaulting
15:43:57 <sjanssen_> @undefine
15:43:58 <lambdabot> Undefined.
15:45:03 <sjanssen_> @let infix 5 ~==; (~==) :: Fractional a => a -> a -> Bool; x ~== y = abs (x - y) < epsilon; epsilon = 1e-5
15:45:04 <lambdabot> <local>:1:54:     Inferred type is less polymorphic than expected       Quant...
15:45:20 <AstralStorm> sjanssen_: but there's a problem - the app itself will be compiled... I want it to use "plugins" in Haskell.
15:46:09 <sjanssen_> @let infix 5 ~==; (~==) :: Fractional a => a -> a -> Bool; x ~== y = abs (x - y) < epsilon; epsilon :: Fractional a => a; epsilon = 1e-5
15:46:10 <lambdabot> <local>:1:76:     Could not deduce (Ord a) from the context (Fractional a)   ...
15:46:14 <sjanssen_> bleh
15:46:20 <AstralStorm> Has someone an idea how to implement that properly?
15:46:26 <sjanssen_> AstralStorm: hmm, don't think I catch your drift
15:46:38 <AstralStorm> E.g. can Yi be compiled, while the plugins stay in source form?
15:46:47 <AstralStorm> sjanssen_: unrelated to ~==
15:47:03 <sjanssen_> AstralStorm: there's hs-plugins that can do some of that stuff
15:47:15 <AstralStorm> Hmm... let's see.
15:47:26 <sjanssen_> @where hs-plugins
15:47:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:47:47 <AstralStorm> Oh yes.
15:47:53 <AstralStorm> sjanssen_: my google was faster :P
15:49:00 <sjanssen_> yes, but google is nowhere near as cool as lambdabot
15:49:17 <AstralStorm> True.
15:51:27 <AstralStorm> These hs-plugins are even better than what I need :D
15:51:55 <lennart> who wrote @undo?
15:51:57 <AstralStorm> They'll allow me to resolve the graph by just making the code - no work from core at all.
15:52:27 <sjanssen_> lennart: me
15:52:47 <lennart> sjanssen_:  very useful!
15:52:58 <lennart> but does it do the right thing yet? :)
15:53:04 <sjanssen_> lennart: thanks.  Have you seen @redo?
15:53:29 <lennart> @redo f >>= \ x -> g (x+1)
15:53:30 <lambdabot> do { x <- f; g (x + 1)}
15:53:36 <lennart> nice
15:53:40 <edwardk> neat! =)
15:53:41 <sjanssen_> @undo do (Just y) <- m; return y
15:53:42 <lambdabot> m >>= \ a -> case a of { (Just y) -> return y; _ -> fail ""}
15:53:50 <lennart> cool!
15:54:22 <edwardk> now we can take it apart, render it pointless and shove it back in, hrmm. probably not so useful i guess
15:54:22 <twanvl> @redo (\x -> g (x+1)) =<< f
15:54:22 <AstralStorm> I wonder how powerful is that.
15:54:22 <lambdabot> (\ x -> g (x + 1)) =<< f
15:54:28 <sjanssen_> redo isn't yet smart enough to get rid of that case expression, but it's definitely possible
15:54:37 <AstralStorm> @undo printStrLn "Blah"
15:54:38 <lambdabot> printStrLn "Blah"
15:54:39 <lennart> @. undo redo do (Just y) <- m; return y
15:54:39 <lambdabot> m >>= \ a -> case a of { (Just y) -> return y; _ -> fail ""}
15:54:57 <lennart> hmmmm
15:55:02 <sjanssen_> @. redo undo do (Just y) <- m; return y
15:55:02 <lambdabot> do { a <- m; case a of { (Just y) -> return y; _ -> fail ""}}
15:55:18 <lennart> oops
15:55:27 <AstralStorm> @undo putStrLn "Blah"
15:55:27 <lambdabot> putStrLn "Blah"
15:55:31 <AstralStorm> (blah @ me :P )
15:56:07 <AstralStorm> It doesn't detect irreversible operations correctly.
15:56:21 <bringert> @redo (>>=) f (\ x -> g (x+1))
15:56:22 <lambdabot> (>>=) f (\ x -> g (x + 1))
15:56:37 <sjanssen_> bringert: redo is very very simple
15:56:45 <lennart> i should get myself a lambdabot and use instead of ghci
15:57:04 <twanvl> AstralStorm: It isn't undo in the Ctrl+Z sense, it is un-do
15:57:08 <AstralStorm> lennart: me too :>
15:57:13 <bringert> @vixen: isn't that a good idea?
15:57:13 <lambdabot> good? not great?
15:58:04 <AstralStorm> twanvl: ah, converts function with "do" to a function without...
15:58:04 <bringert> good night
15:58:06 <AstralStorm> Nice :>
15:59:51 <bitshifter> Is there any way to convince the RTS to output XML for heap profiling?
16:03:08 <glguy> sweet, my sim works
16:03:52 <glguy> Now I'll try wrapping it up in ST
16:04:34 * glguy >>= (drive home)
16:05:10 <AstralStorm> @type >>=
16:05:12 <lambdabot> parse error on input `>>='
16:05:20 <twanvl> @type (>>=)
16:05:22 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
16:05:25 <AstralStorm> @type (>>=)
16:05:25 <sjanssen_> @redo glguy >>= (drive home)
16:05:26 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
16:05:26 <lambdabot> (drive home)
16:05:43 <sjanssen_> umm
16:06:03 <sjanssen_> @yarr -- there be bugs in these parts!
16:06:03 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
16:06:09 <twanvl> that doesn't seem right, it looks like you lost him
16:06:49 <AstralStorm> >>= is wrong metaphor for moving :P
16:07:02 <AstralStorm> It's more like for change, not even state change.
16:29:23 <heatsink> @ghc
16:29:23 <lambdabot>  Exotic pattern inside meta brackets
16:29:24 <glguy> I was using it as an action
16:29:50 <glguy> You people sure didn't do much while i was driving :)
16:30:45 <clanehin> glguy: what is your sim?
16:31:08 <glguy> I was just writing the mathschallenge monopoly problem in Haskell
16:31:15 <glguy> (I originaly did it in C#)
16:31:25 <glguy> I'm still not that comfortable with MonadTrans yet
16:31:44 <glguy> so I'm using it as a haskell exercise
16:34:53 <clanehin> ah, embedding an ST monad in the IO monad?
16:44:22 <dibblego> is Maybe a monad?
16:44:27 <glguy> yes
16:44:30 <edwardk> yup
16:44:41 <dibblego> data Maybe a = Nothing | Just a
16:44:44 <dibblego> what makes it a monad?
16:45:14 <clanehin> instance Monad Maybe where . . .
16:45:28 <dibblego> ok so that Maybe above is not a monad?
16:45:43 <dibblego> ?index Maybe
16:45:43 <lambdabot> Data.Maybe, Prelude
16:45:44 <clanehin> right "data" doesn't make it a monad
16:45:48 <dibblego> ok ta
16:45:58 <araujo> dibblego, you know what a monad is?
16:46:09 <dibblego> araujo, only very vaguely
16:46:29 <araujo> You can think of a monad as a container. In this case Maybe fits into this definition very well.
16:46:37 <clanehin> > Just 2 >>= (return . (* 2))
16:46:38 <lambdabot>  Just 4
16:46:45 <araujo> @type (Just 4)
16:46:46 <lambdabot> forall a. (Num a) => Maybe a
16:46:55 <clanehin> > Nothing >>= (return . (* 2))
16:46:56 <lambdabot>  Nothing
16:47:21 <weitzman> > msum [Nothing, Nothing, Just 3, Nothing, Just 4, Nothing]
16:47:22 <lambdabot>  Just 3
16:47:32 <weitzman> How thrilling
16:47:54 <dibblego> @type Either
16:47:55 <lambdabot> Not in scope: data constructor `Either'
16:48:26 <clanehin> @type Left 2
16:48:27 <lambdabot> forall a b. (Num a) => Either a b
16:49:06 <araujo> > return 1 :: Maybe Int
16:49:07 <lambdabot>  Just 1
16:49:38 <araujo> See, there, Maybe _contains_ the type Int
16:50:33 <araujo> A type constructor, containing other type constructor, helps you to combine and produce different type of computations.
16:51:22 <araujo> So, in this case, an expression of type Maybe a, it is a computation that might have a value (Just a) or not (Nothing)
16:51:26 <glguy> ?kind Either
16:51:27 <lambdabot> * -> * -> *
16:52:17 <dibblego> thanks
16:53:18 <wkh> i have returned
16:53:21 <wkh> what are the haps my friends
16:53:41 <glguy> monochrom: you there?
17:05:02 <dibblego> data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat  deriving (Eq, Ord, Enum, Show) -- what does the deriving part mean exactly? what is it called (so I can look it up)?
17:05:29 <sjanssen_> dibblego: the compiler can write instances of certain classes for you
17:06:19 <sjanssen_> those classes are for equality, order comparisons, enumerations, and the ability to be converted into a string
17:06:36 <dibblego> ok thanks
17:23:13 <dibblego> if Show goes from type to String, is there a way of going back?
17:23:21 <glguy> Is there is shortcut using modify for this:
17:23:21 <dibblego> "Sun" -> Sun
17:23:39 <glguy> do { a <- get; a' <- lift (specialCase a); put a'
17:23:43 <glguy> ?
17:25:15 <kfish> dibblego, implement Read for your type
17:25:24 <dibblego> ok thanks
17:44:25 <dibblego> http://rafb.net/paste/results/XL16rx98.html why won't this compile
17:45:02 <dolio> The Sun constructor doesn't take a parameter?
17:45:14 <sjanssen_> dibblego: whichDay Sun 7
17:45:19 <dibblego> but whichDay takes two parameters
17:45:32 <dolio> Then that's whichDay Sun 7
17:45:33 <dons> yes, whichDay (Sun 7) is wrong. toss the parens
17:45:34 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:45:40 <dibblego> thanks
17:46:38 <sjanssen_> dibblego: also, print is shorthand for putStrLn . show
17:46:54 <dibblego> ok thanks
17:47:38 <dons> e.g main = print $ whichDay Sun 7
17:48:01 <dibblego> putStrLn (show (whichDay Sun 7))) -- putStrLn . show (whichDay Sun 7)) why can't it be written that way?
17:48:24 <dons> one too many parens?
17:48:36 <dons> putStrLn . show $ whichDay Sun 7
17:48:39 <dibblego> putStrLn (show . whichDay Sun 7) -- or that way
17:48:48 <dons> (putStrLn . show) (whichDay Sun 7)
17:49:11 <dons> ?type (.)
17:49:12 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
17:49:22 <dons> so the two arguments to (.) must be functions
17:49:28 <dibblego> ok
17:49:31 <dons> but (whichDay Sun 7) isn't a function
17:49:34 <dons> its a Day
17:49:43 <dibblego> ok thanks
17:49:46 <dibblego> ?type ($)
17:49:47 <lambdabot> forall b a. (a -> b) -> a -> b
17:49:48 <dons> so show . whichDay Sun 7 --> show . (whichDay Sun 7) --> wrong.
17:49:55 <dons> however,
17:50:06 <dons> show $ whichDay Sun 7 -- is fine, as the type of $ says
17:50:23 <dons> and is the same as: show (whichDay Sun 7), but with less parens
17:51:42 <deadbeef> dear friends, one question
17:51:49 <deadbeef> a bit offtopic btw
17:52:06 <deadbeef> i'm looking for an app that takes a mysql database and gives a graphic layout of it
17:52:13 <deadbeef> so i can insert it in documentation and stuff
17:52:15 <deadbeef> any idea ?
17:56:56 <dibblego> (f1 . f2) a can be rewritten as f1 $ f2 a
17:58:26 <dons> right
17:58:37 <sjanssen_> @check (\f g x -> (f . g) x == (f $ g x)) :: (Int -> Int) -> (Int -> Int) -> Int -> Bool
17:58:38 <lambdabot>  OK, passed 500 tests.
17:58:39 <dons> though: f1 . f2 $ a -- would be preferred
17:59:06 <dons> sjanssen_: also, you have the synonyms type I = Int, and type T = [Int] , for @check purposes
18:00:02 <glguy> Is there a better way to do what I do in "simulateTurn" ? http://paste.lisp.org/display/25854
18:00:19 <glguy> (question asked of anyone who knows how to use StateT)
18:01:11 <monochrom> Now I'm back.
18:01:24 <glguy> monochrom: check out that link and see if you like what you see better than my first attempt
18:01:28 <glguy> if you don't mind, of course
18:02:15 <glguy> liftM sum $ replicateM 2 (getRandomR (1,4)) is probably more clear than join (liftM2 (+)) (getRandomR (1,4))
18:02:24 <dibblego> toEnum . (+1) . fromEnum $ a -- what is the preferred way of writing this?
18:02:32 <monochrom> It's good.  I would do it this way too.
18:02:42 <dons> me too.
18:02:50 <dons> ?pl toEnum . (+1) . fromEnum $ a
18:02:50 <lambdabot> toEnum (fromEnum a + 1)
18:03:00 <dibblego> what does ?pl mean?
18:03:05 <glguy> I'm just trying ot clean this up before I represent Haskell in the forum with it :)
18:03:06 <dons> wel, @pl is not human :)
18:03:15 <dons> ?help pointfree
18:03:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:03:20 <dons> ?help pl
18:03:20 <lambdabot> pointless <expr>. Play with pointfree code.
18:03:26 <dons> ?wiki Pointfree
18:03:26 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
18:03:40 <glguy> pointfree is one step away from tacit programming :)
18:04:03 <glguy> actually, those words probably mean th same thing
18:04:14 <glguy> but J people talk about tacit, and Haskell people pointfree
18:04:46 <dibblego> so  toEnum (fromEnum a + 1) is pointfree?
18:05:50 <glguy> yeah
18:05:57 <monochrom> Imperative programmers have used pointfree programming tacitly.  http://www.vex.net/~trebla/weblog/pointfree.html
18:06:01 <lambdabot> Title: The Point of Pointfree, http://tinyurl.com/jk7cd
18:06:04 <glguy> stuff with points include \x -> dostuff x and let f x = dostuff x
18:06:55 <glguy> point-free code is great for those times when you just can't be bothered to "declare arguments"
18:07:43 <monochrom> Indeed.  I think pointfree-bashing is overrated.
18:07:56 * lispy dares someone to go into #lisp and tell them that common lisp is the fortran of functional programming and haskell is the C
18:08:01 <dons> nice link monochrom
18:08:22 <edwardk> hehehe
18:08:41 <edwardk> common lisp is the algol of functional programming ;)
18:08:51 <monochrom> I don't like Haskell likened to C. :)
18:09:32 <lispy> monochrom: yeah, it's a trolly thing to even say :)
18:09:41 <lispy> no point, but it stirs people up
18:10:26 <dons> very constructive lispy :P
18:10:38 <monochrom> trolly trolly happy happy joy joy
18:10:41 <wkh> it's no fair comparing haskell to circa-1980s technology
18:10:54 <wkh> it's more fun to compare lisp to stuff stuck in the 70s
18:10:58 <wkh> like say, C# 2.0
18:11:23 <lispy> heh
18:12:14 <lispy> or
18:12:15 <lispy> gah
18:12:33 * lispy needs to learn to use his control key when activiting emacs commands :)
18:14:04 <dibblego> whichDay a b = toEnum (fromEnum a + mod b 7)
18:14:15 <dibblego> http://www.willamette.edu/~fruehr/LLC/lab1.html problem 3
18:14:16 <wkh> o no u di'int
18:14:18 <lambdabot> Title: CS 451/LLC Lab 1: Basic Haskell Exercises, http://tinyurl.com/o2c4t
18:14:23 <lispy> dons: how hard would it be to write a fastcgi wrapper for lambdabot?
18:14:26 * wkh wags his finger back and forth in a self-righteous, condescending manner
18:14:39 <lispy> dons: even if we had to write it in *shudder* perl or php?
18:15:03 <dibblego> actually that is wrong, I need to +1
18:15:44 <dibblego> er -1
18:16:09 <lispy> hmm...
18:16:18 <lispy> dibblego: how does this work?
18:16:35 <dibblego> lispy, how does what work? I'm just glad it does work - buggers me how
18:16:44 <dons> lispy: i'd just use fastcgi :) (the haskell lib)
18:16:44 <dibblego> whichDay a b = toEnum (fromEnum a - 1 + mod b 7)
18:16:54 <dons> i.e. for a web interface?
18:17:01 <lispy> b `mod` 7 is the more idomatic way, just so you know
18:17:06 <lispy> dons: ya
18:17:09 <dons> hmmm. /me tries dwm. fast!
18:17:10 <dibblego> ok, I did that to start off
18:17:17 <lispy> dwm?
18:17:29 <dons> ?google dwm dynamic window manager
18:17:32 <lispy> dons: a window manager? ah
18:17:33 <lambdabot> http://www.wmii.de/dwm/
18:17:59 <lispy> oh, just so you know why i was in a trolling moood...i've been hunting through C++ code all day looking for a particular function...
18:18:11 <lispy> it does things to your head :)
18:18:17 <weitzman> How will you know if you've found the function?
18:18:20 <Pseudonym> WHat function?
18:18:21 <dons> here, actually, http://www.shortest.de/
18:18:22 <lispy> dibblego: so, what are a b?
18:18:23 <lambdabot> Title: shortest code project
18:18:37 <dibblego> lispy, whichDay :: Day -> Int -> Day
18:18:51 <lispy> hmm...
18:19:05 <glguy> Did anyone else notice that Katie  Corric put on 10 years when she started doing evening tv?
18:19:06 <lispy> dibblego: so it's like which day is now + int?
18:19:13 <Pseudonym> glguy: No.
18:19:20 <dibblego> lispy, the first Day argument is the day of the first day of the month
18:19:26 <glguy> I used to think she lookedpretty
18:19:29 <Pseudonym> glguy: BTW, who is Katie Corric?
18:19:36 <weitzman> @google katie corric
18:19:39 <lambdabot> http://www.nicedoggie.net/2005/index.php/?feed=rss2&p=1010
18:19:51 <Pseudonym> nicedoggie?
18:19:52 <Cale> http://en.wikipedia.org/wiki/Katie_Couric
18:19:53 <weitzman> Well that was a worthless result
18:20:06 <Pseudonym> glguy: Not everyone is American, you insensitive clod.
18:20:10 <weitzman> Lambdabot needs a @wikipedia to get useful results
18:20:25 <Pseudonym> @google site:wikipedia.org Katie Courci
18:20:27 <lambdabot> No Result Found.
18:20:34 <Pseudonym> @google site:wikipedia.org Katie Couric
18:20:36 <lambdabot> http://en.wikipedia.org/wiki/Katie_Couric
18:20:39 <Pseudonym> There we go.
18:20:40 <weitzman> Also good
18:20:42 <dons> ?wikipedia Katie Couric
18:20:44 <lambdabot> No Result Found.
18:20:47 <dons> still broke. eh?
18:20:49 <glguy> You silly foreigner, I was obviously asking all of the important people in the channel ;)
18:20:59 <lispy> dibblego: Ah!
18:21:01 <lispy> dibblego: i see
18:21:04 <Pseudonym> glguy: People who watch Katie Couric are important?
18:21:15 <dibblego> lispy, problem 4 looks daunting
18:21:15 <glguy> no, americans are :-p
18:21:40 <lispy> dibblego: so do you understand how whichDay works?
18:21:48 <dibblego> lispy, sure, I wrote it after all
18:22:00 <lispy> dibblego: oh, well, you sounded a bit confused abuot it :)
18:22:00 <glguy> Problem 4?
18:22:18 <dibblego> lispy, yes I am confused because I am applying all the reading I have been doing for the first time
18:22:22 <Pseudonym> Does anyone here remember any analog electronics?
18:22:33 <dibblego> glguy, http://www.willamette.edu/~fruehr/LLC/lab1.html problem 4
18:22:35 <lambdabot> Title: CS 451/LLC Lab 1: Basic Haskell Exercises, http://tinyurl.com/o2c4t
18:22:53 <lispy> dibblego: it's actually pretty easy
18:23:03 <lispy> dibblego: have you used list comps yet?
18:23:05 <dibblego> yeah I know, I just have to shift my head in the right direction
18:23:14 <dibblego> what is a list comp?
18:23:14 <lispy> dibblego: because i bet you could express it very nicely with a list comp.
18:23:40 <lispy> > [(x,y) | x <- [1..3], y <- [1.. x], x /= 2]
18:23:41 <lambdabot>  [(1,1),(3,1),(3,2),(3,3)]
18:23:54 <dibblego> that looks like a list of tuples
18:24:05 <lispy> > [y | x <- [1..3], y <- [1.. x], x /= 2]
18:24:06 <lambdabot>  [1,1,2,3]
18:24:19 <lispy> dibblego: you get to use set builder notation from math to contruct lists!
18:24:27 <lispy> construct*(
18:24:39 * lispy can't type obviously, but hopefully ti makes sense inspite of it
18:24:44 <sjanssen_> dons: so if dwm is less than 2000 lines of C . . . how hard can it be to port it to Haskell? ;)
18:25:20 <Pseudonym> Woah.
18:25:22 <dibblego> lispy, I don't think that's the intention of the exercise
18:25:38 <weitzman> @check \x -> (\= 2) == not . (== 2) :: Int -> Bool
18:25:39 <lambdabot>  Not in scope: `\='
18:25:39 <Pseudonym> There's a hournal here called "Classical and Quantum Gravity".  Publication years: 1874 -- 1993.
18:25:48 <weitzman> @check \x -> (/= 2) == not . (== 2) :: Int -> Bool
18:25:49 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Int -> ...
18:25:54 <weitzman> I always lose
18:26:09 * Pseudonym has a suspicion it wasn't called that for all of its history
18:26:09 <sjanssen_> weitzman: you want parens around the lambda expression
18:26:09 <weitzman> @check (\x -> (/= 2) == not . (== 2)) :: Int -> Bool
18:26:10 <lambdabot>  add an instance declaration for (Eq (a -> Bool))     In a lambda abstractio...
18:26:46 <weitzman> @check (\x -> (/= 2) == $ not . (== 2)) :: Int -> Bool
18:26:47 <lambdabot>  Parse error
18:26:54 <weitzman> I surrender
18:27:07 <glguy> dibblego: Are you in that class and are lucky enough to have Haskell-homework? or are you just practicing?
18:27:13 <weitzman> > 1 /= 2
18:27:14 <lambdabot>  True
18:27:17 <weitzman> > 2 /= 2
18:27:18 <lambdabot>  False
18:27:22 <dibblego> glguy, I just googled up that web page for something to do
18:28:13 <lispy> dibblego: i just coded up the solution and modified it so you can cehck if numbers are perfect!
18:28:19 <lispy> > L.isPerfect 28
18:28:20 <lambdabot>  True
18:28:23 <dons> sjanssen_: yeah, i've pondered this. and we can use -package X11
18:28:34 <weitzman> @check (\x -> (/= 2) x == (not . (== 2) ) x) :: Int -> Bool
18:28:35 <lambdabot>  OK, passed 500 tests.
18:28:43 <dibblego> what is the definition of perfect?
18:28:44 <lispy> > [ x | x <- [1.. 100], L.isPerfect x]
18:28:45 <lambdabot>  [6,28]
18:28:55 <lispy> dibblego: a number is the sum of it's devisors
18:28:59 <lispy> divisors
18:29:01 <dibblego> ah that's right
18:29:12 <lispy> > [ x | x <- [1.. 100[], L.isPerfect x]
18:29:13 <lambdabot>  Parse error
18:29:19 <lispy> > [ x | x <- [1.. 10000], L.isPerfect x]
18:29:22 <lambdabot> Terminated
18:29:27 <lispy> > [ x | x <- [1.. 1000], L.isPerfect x]
18:29:28 <lambdabot>  [6,28,496]
18:29:42 <lispy> they're sort of scarce
18:30:10 <dibblego> yes I recall reading a book that mentioned them
18:31:07 <weitzman> Question: Why doesn't this terminate:
18:31:16 <weitzman> > filter (L.isPerfect) [1..]
18:31:19 <lambdabot> Terminated
18:31:24 <weitzman> What about laziness?
18:31:26 <lispy> i'm not sure exactly
18:31:27 <dons> why would it terminate?
18:31:31 <lispy> i noticed that  yesteraday
18:31:37 <weitzman> Sure, it's infinite
18:31:39 <dons> you think we should get some output?
18:31:40 <lispy> shouldn't it at least produce some output?
18:31:51 <weitzman> > [1..]
18:31:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:31:58 <glguy> > fix (1:)
18:31:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:32:15 <dons> > filter (\x -> x `mod` 2 == 0) [1..]
18:32:16 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
18:32:16 <Cale> > fix ((0:) . scanl (+) 1)
18:32:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:32:20 <weitzman> I guess maybe isPefect is too slow
18:32:22 <lispy> weitzman: someone noticed the same with list comps. yestarday too
18:32:23 <dons> > filter (\x -> x `mod` 100 == 0) [1..]
18:32:24 <lambdabot>  [100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700...
18:32:31 <dons> too slow, I reckon, yes.
18:33:01 <dons> isPerfect = (\n -> sum [ f | f <- [1..(n-1)], n `mod` f == 0] == n)
18:33:02 <lispy> dons: do you think it could be a fussion problem?
18:33:20 <glguy> > fix $ scanl (+) 0 . (1:)
18:33:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:33:22 * lispy pokes dons, don't poste it... dibblego is working on that problem still :)
18:33:32 <dons> oh sorry.
18:33:40 * dons erases history
18:33:44 <lispy> heh
18:33:47 <newbcoder> stupid chanserv; it's function
18:34:06 <dibblego> I'm not going to write that anyway - I can barely read it
18:34:33 <Cale> hmm, iterate f x = fix ((x:) . map f)
18:35:06 <lispy> how is fix defined?
18:35:10 <lispy> ?type fix
18:35:11 <lambdabot> forall a. (a -> a) -> a
18:35:12 <Cale> fix f = f (fix f)
18:35:46 <Cale> @djinn (a -> a) -> a
18:35:47 <lambdabot> -- f cannot be realized.
18:35:49 <Cale> :)
18:36:05 <lispy> iterate f = fix ((x:) . map f) = ((x:) . map f) (fix ((x:) . map f))
18:36:13 <lispy> hmm...
18:36:18 <weitzman> @djinn doesn't believe in using the conclusion to prove the premise
18:36:19 <lambdabot> -- f cannot be realized.
18:36:20 <weitzman> Lame
18:36:44 <lispy> ?type iterate
18:36:45 <lambdabot> forall a. (a -> a) -> a -> [a]
18:37:02 <lispy> iterate (+1) 0 [1..3]
18:37:04 <lispy> > iterate (+1) 0 [1..3]
18:37:10 <lambdabot>    The function `iterate' is applied to three arguments,
18:37:12 <lambdabot>   but its type `...
18:37:15 <lispy> oh, duh
18:37:16 <Cale> > iterate (+1) 0
18:37:19 <lispy> > iterate (+1) 0
18:37:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:37:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:37:37 <weitzman> Hey, I wrote that same function
18:37:56 <Cale> > fix ((0:) . map (+1))
18:37:57 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:38:20 <lispy> the map kinda confuses me
18:38:32 <lispy> ?type (0:) . map (+1)
18:38:33 <lambdabot> forall a. (Num a) => [a] -> [a]
18:38:49 <Cale> ((0:) . map (+1)) [0,1,2,3]
18:38:51 <Cale> > ((0:) . map (+1)) [0,1,2,3]
18:38:52 <lambdabot>  [0,1,2,3,4]
18:38:52 <lispy> that accepts a list, which make sense, but where is the list
18:38:59 <Cale> > ((0:) . map (+1)) []
18:39:00 <lambdabot>  [0]
18:39:03 <Cale> > ((0:) . map (+1)) [0]
18:39:04 <dolio> Add one to the whole list, then append a zero.
18:39:04 <lambdabot>  [0,1]
18:39:06 <Cale> > ((0:) . map (+1)) [0,1]
18:39:07 <lambdabot>  [0,1,2]
18:39:10 <Cale> > ((0:) . map (+1)) [0,1,2]
18:39:11 <lambdabot>  [0,1,2,3]
18:39:12 <Cale> > ((0:) . map (+1)) [0,1,2,3]
18:39:14 <lambdabot>  [0,1,2,3,4]
18:39:16 <dolio> Then when you fix, you do that an infinite number of times.
18:39:33 <Cale> actually, you're not starting with the empty list though :)
18:39:41 <dolio> Or, do it until you get something out that's the same as what you put in.
18:40:17 <lispy> ?type fix (0:) . map (+1)
18:40:18 <lambdabot>   Couldn't match `[a]' against `b -> c'
18:40:19 <lambdabot>    Expected type: (b -> c) -> b -> c
18:40:23 <lispy> ?type fix $ (0:) . map (+1)
18:40:24 <lambdabot> forall a. (Num a) => [a]
18:40:35 <lispy> ?type fix
18:40:37 <lambdabot> forall a. (a -> a) -> a
18:40:52 <Cale> really, all that happens is when you demand the first element of  fix ((0:) . map (+1)), it expands fix, giving ((0:) . map (+1)) (fix ((0:) . map (+1)))
18:41:06 <Cale> It then applies (.)
18:41:19 <Cale> = (0:) (map (+1) (fix ((0:) . map (+1))))
18:41:43 <dolio> ?type mfix
18:41:44 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
18:41:45 <lispy> but...where is the starting point?
18:41:47 <Cale> and at this point, you can see what the first element of the list it
18:41:49 <Cale> s*
18:42:00 <lispy> the first element is 0
18:42:07 <lispy> because it starts with (0:) ?
18:42:12 <Cale> yeah
18:42:13 <Oliver> Hmm, that makes sense.. there is no end of the list at all, it's just expanding more and more cons cells
18:42:17 <dibblego> whichDay :: Day -> Int -> Day can I use a type class like Num or Integral instead of Int
18:42:27 <Cale> and to get the second element, well, that's the first element of (map (+1) (fix ((0:) . map (+1))))
18:42:40 <lispy> dibblego: i think so
18:42:40 <Cale> which is (+1) 0
18:42:47 <dibblego> lispy, how does it look?
18:42:52 <Cale> does that make sense?
18:42:54 <lispy> dibblego: but you may need to add Enum a
18:43:09 <lispy> Cale: why is it the second element?
18:43:15 <Cale> of the overall list
18:43:18 <Cale> okay
18:43:20 <lispy> dibblego: whichDay :: Enum a => Day -> a -> Day
18:43:29 <lispy> dibblego: or whichDay :: Num a => Day -> a -> Day
18:43:37 <Cale> We want the second element of 0 : (map (+1) (fix ((0:) . map (+1))))
18:43:45 <Cale> that is, head . tail of it
18:44:09 <Cale> (head . tail) (0 : (map (+1) (fix ((0:) . map (+1))))
18:44:12 <lispy> so we peel off the 0 and look at (map (+1) (fix ((0:) . map (+1))))
18:44:16 <Cale> = head (map (+1) (fix ((0:) . map (+1)))
18:44:52 <Cale> and then we have to expand the fix enough to pattern match for map
18:45:00 <dibblego> the compiler complains
18:45:07 <lispy> dibblego: what does it say?
18:45:13 <Cale> = head (map (+1) (0 : (fix ((0:) . map (+1))))
18:45:17 <newbcoder> parseNumber = liftM (Number . read) $ many1 digit
18:45:17 <newbcoder>  <-- please explain taht line to me
18:45:25 <newbcoder> wtf is liftM doing in taht line
18:45:28 <newbcoder> and why do I need it?
18:45:38 <dibblego> lispy, http://rafb.net/paste/results/Wj2Vj666.html
18:45:47 <lispy> newbcoder: you need to lift (Number . read) into the parser monad
18:45:53 <Cale> = head ((+1) 0 : (map (+1) (fix ((0:) . map (+1))))
18:46:00 <Cale> = (+1) 0
18:46:07 <Cale> = 1
18:46:31 <glguy> newbcoder: that is the same as: do { a <- many1 digit; return (Number (read a)) }
18:46:44 <lispy> Cale: hmm...so does each successive element require one more unfolding?  I mean, element n, requires n unfoldings of fix to be computed?  meaning that the complexity is very bad?
18:46:54 <newbcoder> glguy, where did the lift go in that statementthlugh?
18:46:56 <lispy> dibblego: looking
18:47:02 <newbcoder> glguy, and what would code w/o thelift look like?
18:47:08 <Cale> lispy: that's the best complexity that can be achieved
18:47:11 <glguy> newbcoder: just like you pasted
18:47:25 <lispy> Cale: wouldn't iteration be better?
18:47:32 <lispy> Cale: i mean traditional C style looping
18:47:34 <Cale> they're both O(n)
18:47:38 <newbcoder> glguy the code I pasted has a liftM in it ...
18:47:51 <glguy> lispy: the point of generating fibonacci numbers with fix and scanll isn't efficiency
18:47:52 <lispy> ?type fromEnum
18:47:53 <lambdabot> forall a. (Enum a) => a -> Int
18:48:18 <glguy> newbcoder: I showed you what the code would look like without the lift...
18:48:20 <lispy> ?type fromIntegral
18:48:22 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:48:32 <lispy> dibblego: your 'fromEnum' is the problem
18:48:35 <newbcoder> do { a <- many1 digit; return (Number (read a)) }
18:48:37 <deadbeef> @check (\x -> x == or [x, False] && True ) :: Bool -> Bool
18:48:38 <lambdabot>  OK, passed 500 tests.
18:48:40 <newbcoder> that is w/o liftm ?
18:48:43 <weitzman> > fromIntegral 5 :: Real
18:48:43 <lambdabot>    Class `Real' used as a type
18:48:44 <lambdabot>   In the type `Real'
18:48:44 <lambdabot>   In an expression ...
18:48:44 <lispy> dibblego: if you wrap that in fromIntegral then you can use Num
18:48:48 <weitzman> Aw
18:48:51 <dibblego> ah thanks
18:49:03 <newbcoder> parsing.hs:36: Variable not in scope: `liftM'
18:49:03 <newbcoder> make: *** [parsing] Error 1
18:49:03 <newbcoder>  <-- how do I kill that compiler error ... i.e. fixit
18:49:09 <weitzman> > fromIntegral 3 :: Float
18:49:10 <lambdabot>  3.0
18:49:11 <dibblego> lispy, I'll leave that for another day, cheers
18:49:14 <weitzman> Booyah
18:49:17 <glguy> import Control.Monad for liftM
18:49:24 <lispy> newbcoder: so, lift means to bring a function up inside another context...does that help?  I can explain more if not
18:49:33 <newbcoder> please explain more
18:49:33 <Cale> the fix and scanl version is actually a pretty damn quick fibonacci generator due to sharing
18:49:39 <newbcoder> i'm trying to learn haskell; very confused
18:49:48 <lispy> newbcoder: so you can think of the parser monad as a container
18:49:51 <lispy> just ask Cale
18:49:59 <wkh> @hoogle fix
18:49:59 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
18:50:00 <lambdabot> Control.Monad.Fix :: module
18:50:00 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
18:50:04 <lispy> newbcoder: and inside that container we want to use the function (Number . read)
18:50:12 <lispy> ?type liftM
18:50:13 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:50:20 <newbcoder> I thought monad is for i/o ... how is that a container?
18:50:21 <Cale> hehe, that's actually one case where I don't tend to use the container analogy, but sure :)
18:50:47 <lispy> ?google haskell monad container
18:50:51 <Cale> newbcoder: monads aren't just for IO
18:50:53 <lambdabot> http://www.nomaware.com/monads/html/meet.html
18:50:53 <dolio> fix and scanl are just shorthand for writing the accumulating recursion by hand, which is the functional equivalent of iteration.
18:50:53 <lambdabot> Title: Meet the Monads
18:50:58 <weitzman> newbcoder: Monad is much more confusing and scary then they seem at first
18:51:10 <Cale> newbcoder: actually IO is probably the worst example of a monad possible
18:51:14 <weitzman> newbcoder: Beware!
18:51:28 <sjanssen_> newbcoder: I say the opposite of weitzman
18:51:41 <Kahdloc> IO is confusing....and i've yet to find something that suitably explains it.
18:51:45 <Cale> Monads are actually quite a lot easier to understand than people who learned them earlier on will tell you
18:51:59 <Cale> IO is confusing
18:52:02 <lispy> newbcoder: you can either manually lift functions into the monad (using the do notation) or you can take advantage of predefined functions like liftM
18:52:06 <newbcoder> damn none of these comments actually hyelp me learn i/o or monads
18:52:12 <Cale> newbcoder: hehe
18:52:21 <Cale> @wiki Monads_as_Containers
18:52:21 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
18:52:26 <Cale> @wiki Introduction_to_IO
18:52:26 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
18:52:36 <Cale> read those links in either order :)
18:52:49 <dylan> monads in terms of list comprehensions is a neat angle to teach, I think.
18:53:11 <Cale> Yeah, that's rather like my containers analogy
18:53:17 <lispy> i think the list monad and the state monad are really important exmalpse
18:53:18 <glguy> We need monad comprehensions back!
18:53:29 <Cale> lispy: I agree
18:53:38 <Kahdloc> why do they call it "pointless notation" if it's not pointless?
18:53:42 <lispy> the state monad made no sense to me for a long time...now it seems so logical
18:53:45 <dylan> IO is confusing... I don't find them so, and I'm a newbie. Thus I fear there is something I don't understand about IO now. :(
18:53:52 <lispy> Kahdloc: i think it's usually called point free
18:53:53 <Cale> Kahdloc: points-free notation, really
18:54:11 <glguy> the 'point-less" isa joke
18:54:22 <Kahdloc> point-free ...sounds like "pointless"
18:54:25 <Cale> dylan: well, have you gotten as far as reading my intro to IO tutorial?
18:54:25 <dylan> Kahdloc: points-free notation doesn't refer to the '.', that's not the point, so to speak. ;)
18:54:50 <lispy> Cale++ -- thanks for all the tutorials and feeding the newbies
18:54:50 <Kahdloc> i know that. i'm just not sure what the "point" really  is.
18:54:55 <dylan> Cale: No, I do bad with tutorials. I just started writing things and reading the standard library.
18:55:03 <Cale> Kahdloc: the point is the value being manipulated by a function
18:55:06 <lispy> Kahdloc: points are the named parameters
18:55:14 <Kahdloc> ah, cool
18:55:19 <Pseudonym> "Point" is actually a category theory term.
18:55:20 <newbcoder> is ((a . b . c) d) the same as (a (b (c d))) ?
18:55:22 <Cale> Kahdloc: the term comes from topology, where functions are usually acting on spaces of points
18:55:36 <Pseudonym> newbcoder: Yes, except for some stuff you don't need to know about.
18:55:42 <lispy> newbcoder: and the same as a . b . c $ d
18:56:01 <newbcoder> explain $ to me please; I read it's aninfinix operator
18:56:04 <Kahdloc> what's the $ for?
18:56:04 <newbcoder> but other thanthat; it makes no sense
18:56:11 <Pseudonym> That's function application.
18:56:13 <lispy> ?type ($)
18:56:13 <Cale> f $ x = f x
18:56:14 <lambdabot> forall b a. (a -> b) -> a -> b
18:56:14 <dolio> f $ x === f x
18:56:15 <Pseudonym> But it's low-precedence.
18:56:28 <Pseudonym> a $ b c = a (b c)
18:56:31 <Kahdloc> hmm, $ in haskell's going to remind me of perl too much.
18:56:43 <lispy> Kahdloc: then skip it for now
18:56:49 <Kahdloc> ok :)
18:56:50 <Cale> Except that it means a completely different thing from perl's $ :)
18:56:50 <lispy> took me almost a year to be comfortable with it
18:56:58 <dylan> Cale: But continue. Is there some strange magic of IO that is illustrated in the tutorial?
18:57:00 <glguy> or use it until you think of Haskell when you see Perl code
18:57:06 <newbcoder> parseNumber = do a <- many1 digit
18:57:06 <newbcoder>                  return (Number (read a))
18:57:06 <newbcoder>  <-- how do I rewrite that using >>= notation?
18:57:09 <Pseudonym> The main place where $ is useful is precisely in that function composition situation.
18:57:17 <Pseudonym> prepareOutput . process . parseInput $ x
18:57:21 <Pseudonym> Like that.
18:57:23 <Cale> dylan: not really, I just express what I consider to be the "right" way of looking at it
18:57:35 <glguy> many1 digit >>= \a -> return (Number (read a ))
18:57:41 <lispy> newbcoder: start with rewriting the 'return' line to take a parameter
18:57:52 <dolio> ?undo do { a <- many1 digit ; return (Number (read a)) }
18:57:52 <lambdabot> many1 digit >>= \ a -> return (Number (read a))
18:57:56 <glguy> yeah, i guess explaining it would be better...
18:57:57 <lispy> newbcoder: return (Number (read a)) ===> \a -> return (Number (read a))
18:58:05 <weitzman> @undo do z <- many1 digit; return (Number (read a))
18:58:06 <lambdabot> many1 digit >>= \ z -> return (Number (read a))
18:58:29 <weitzman> Oops
18:58:29 <lispy> newbcoder: now, a <- foo; bar a ==> foo >>= bar
18:58:30 <newbcoder> lispy: please go on
18:58:33 <dylan> Cale: Ah. Right now, I can deal with monads about as well as I can handle basic algebra. I know what to do, I understand it, but I don't have words for it. Only symbols.
18:58:40 <lispy> newbcoder: can you seet it?
18:59:10 <Cale> dylan: Well, there are two useful analogies, which are rather different :)
18:59:14 <dylan> Cale: Although the use of bind in the IO monad to sequence things feels like something normal.
18:59:20 <newbcoder> i don't understand the first transformikng of return (Number (read a)) ===> \a -> return (Number (read a))
18:59:34 <newbcoder> lispy: seems like youjust added \a -> return
18:59:42 <lispy> newbcoder: are you familiar with lambda abstractions?
18:59:51 <newbcoder> i am familiar with lambda from scheme
18:59:56 <lispy> > (\x -> (x+1)) 2
18:59:57 <lambdabot>  3
19:00:08 <newbcoder> \x is lambda (x) ?
19:00:14 <lispy> yup
19:00:14 <dons> yep
19:00:17 <Cale> One is to treat values of type (m a) as actions, which if ever carried out, would produce a value of type a, but evaluation doesn't cause that to happen.
19:00:23 <dylan> Cale: are those two views the "monad as container" and "monad as unit computation"?
19:00:24 <dons> > (\x -> x+1) 2
19:00:25 <lambdabot>  3
19:00:28 <Cale> yeah
19:00:29 <dons> > (+1) 2
19:00:30 <lambdabot>  3
19:00:32 <dylan> *unit of computation.
19:00:34 <lispy> newbcoder: so i converted that return statement to a function of one variable
19:00:36 <Cale> unit computation?
19:00:43 <Cale> type of computation
19:00:50 <dylan> Yes, that.
19:00:51 <newbcoder> okay; then the next line ... how do you explain the a <- foo; bar a; line ?
19:00:58 <Cale> or computation in a particular abstract machine
19:01:03 <newbcoder> why is that not bar(foo) ?
19:01:12 <Cale> newbcoder: think about the types
19:01:15 <lispy> newbcoder: let's look at (>>=)
19:01:18 <lispy> ?type (>>=)
19:01:19 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:01:22 <dylan> Cale: My mental model is some strange mix of both of those, then.
19:01:27 <Cale> a <- foo will run foo, capturing its result in 'a'
19:01:49 <newbcoder> okay; then how about bar(foo()) ?
19:01:53 <Cale> whereas bar foo will simply pass the *action* foo to bar
19:01:57 <Cale> without executing it
19:02:12 <lispy> newbcoder: well, in haskell you don't need those parens
19:02:23 <lispy> newbcoder: in fact, foo () means something...
19:02:23 <Cale> this is not something you tend to do in, say C, but it's useful in Haskell
19:02:29 <newbcoder> so is far >>= bar the same as bar(foo()) ?
19:02:37 <Cale> no
19:02:38 <lispy> newbcoder: nope
19:02:47 <newbcoder> but by Cale's descriptino ....
19:02:51 <newbcoder> i run foo; capture it in a;
19:02:53 <newbcoder> then feed it to bar
19:02:57 <Cale> oh
19:03:13 <Cale> I thought both examples were meant as Haskell
19:03:14 <lispy> newbcoder: right and to do that, you need to write a <- foo; bar a, OR, foo >>= bar
19:03:14 <Cale> hehe
19:03:27 <dons> i.e. do x <- getChar ; putChar x  --> getChar >>= putChar
19:03:28 <newbcoder> what does bar(foo()) mean then?
19:03:28 <lispy> oh, was bar(foo()) meant to be c?
19:03:39 <newbcoder> well; I didn't jknow it meantly diffrently in haskell
19:03:46 <monochrom> C is confusing.  Even more so when discussing Haskell.
19:03:47 <Cale> (bar foo) in Haskell means to apply the function bar to the action foo
19:03:54 <Cale> without executing foo
19:04:02 <dmwit> foo() means pass () to foo
19:04:05 <newbcoder> foo and foo() become the same?
19:04:07 <dons> > let bar = sort ; foo = [1..10] in bar foo
19:04:08 <newbcoder> hmm
19:04:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:04:12 <lispy> ?type ()
19:04:13 <lambdabot> ()
19:04:16 <Cale> newbcoder: no, foo and foo () aren't the same
19:04:28 <lispy> newbcoder: in haskell () has a special meaning, it's the empty tuple
19:04:30 <Cale> () is an empty-tuple
19:04:34 <newbcoder> lol is () some type of empty list that I am passyikng to foo
19:04:34 <newbcoder> oh
19:04:36 <dons> a bit like void *
19:04:37 <newbcoder> oh man
19:04:46 <newbcoder> so like '() in scheme
19:04:50 <dmwit> Yes!
19:04:50 <dons> yes, the zero tuple
19:04:52 <Cale> yeah, rather like that
19:04:59 <dons> > ()
19:05:00 <lambdabot>  ()
19:05:05 <monochrom> Except there is also []
19:05:07 <Cale> > () : []
19:05:08 <lambdabot>  [()]
19:05:18 <lispy> newbcoder: haskell has a lot in common with scheme, and monads are very much like scheme functions
19:05:18 <dons> > ("x", 89, 'y', (), [1..3])
19:05:19 <lambdabot>  ("x",89,'y',(),[1,2,3])
19:05:25 <monochrom> It's too confusing to draw analogies, methinks.
19:05:49 <Cale> yeah, probably best not to carry the language analogies too far :)
19:05:49 <lispy> newbcoder: well, i should say scheme functions which deal with state are like haskell's monads
19:06:03 <Cale> lispy: some of those monads, anyway
19:06:03 <newbcoder> parseNumber = do a <- many1 digit
19:06:03 <newbcoder>                  \a return (Number (read a))
19:06:03 <newbcoder>  <-- why does that not compile
19:06:11 <newbcoder> why does adding the \a kill it?
19:06:16 <lispy> Cale: heh, yup, bad analogies again :)
19:06:22 <dons> because its wrong, newbcoder :)
19:06:35 <dons> do a <- ... ; return ...
19:06:36 <Cale> newbcoder: it's not syntactically correct?
19:06:38 <newbcoder> it was also part of lispy's first rewrite though
19:06:48 <Cale> oh, perhaps a typo then
19:06:55 <lispy> newbcoder: right, you can't actually mix those two notations
19:07:01 <Cale> parseNumber = do a <- many1 digit; return (Number (read a))
19:07:08 <Cale> try that
19:07:14 <newbcoder> that's what i started with
19:07:15 <lispy> Cale: and you forgot the arrow '->'
19:07:20 <lispy> \a -> return (Number (read a))
19:07:28 <lispy> er sorry not Cale, but newbcoder
19:07:36 <monochrom> many1 digit >>= (\a -> return (Number (read a)))
19:07:37 <newbcoder> true
19:07:57 <Cale> yeah, monochrom is illustrating how to write it without do-notation
19:07:57 <lispy> newbcoder: we do that rewrite because of the type of (>>=)
19:08:01 <lispy> ?type (>>=)
19:08:02 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:08:09 <lispy> ?type return
19:08:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
19:08:27 <Cale> only look at the last part, which is the important bit :)
19:08:32 <newbcoder> is adding extra () in haskell harmless? they are harmless in c and kill me in scheme; how does haskell view this?
19:08:45 <lispy> i'm not sure if you can see it, but \a -> return (Number (read a)) :: a -> m a
19:08:45 <Cale> newbcoder: they'll usually cause type errors
19:08:51 <dolio> () is a value.
19:08:58 <dolio> So, foo () is not the same as foo.
19:09:02 <Cale> f () will only be valid if f :: () -> t for some type t
19:09:04 <newbcoder> i meant foo vs (foo)
19:09:04 <deadbeef> is there anything like UCW for haskell ?
19:09:17 <Cale> newbcoder: oh, in that case, you're fine
19:09:19 <glguy> When is () harmless in C?
19:09:30 <monochrom> At a certain stage of learning a language (any language, human or computer), it is counterproductive to ask "why is ... wrong?", because the only answer is really "because you're confused".  It is more productive to ask "how to correct ...." and do this many times to train your neural network.
19:09:31 <newbcoder> i meant adding it around expressiosn to denote what gets executed first
19:09:43 <Cale> newbcoder: adding more parens around expressions will always work fine
19:09:48 <glguy> you can use parenthesis in Haskell to denote order
19:09:56 <Cale> newbcoder: s/executed/evaluated/
19:10:10 <newbcoder> lispy ?type return
19:10:10 <newbcoder> lambdabot forall (m :: * -> *) a. (Monad m) => a -> m a <-- how do I read that?
19:10:19 <Cale> There's a distinction between execution and evaluation in Haskell
19:10:33 <Cale>  (Monad m) => a -> m a
19:10:38 <sieni> newbcoder: yes, that works. Plain () is just the value of the unit type, roughly corresponding to `void' in C.
19:10:38 <Cale> that's the important part
19:10:39 <lispy> newbcoder: well, the 'forall (m :: * -> *) a.' is more than i want to explain today :)
19:11:02 <lispy> newbcoder: so skip that part up to '(Monad m) =>', which means when we use the type variable 'm' we mean a monad
19:11:12 <Cale> You read it as saying that return takes a value of some type 'a', and produces a value of type 'm a'
19:11:20 <newbcoder> so return is a monda, which when given 'a gives result m a ?
19:11:24 <lispy> newbcoder: then you read 'a -> m a', which means it's a function from anything to a monad of anything
19:11:39 <newbcoder> okay
19:11:40 <Cale> m might be some kind of computation, like IO, or it might be a sort of container type, like lists
19:11:43 <newbcoder> I'll believe that
19:11:46 <Cale> m itself is the monad
19:11:47 <lispy> newbcoder: return is how you inject a value into a monad (remember the monad is container?)
19:11:57 <Cale> the values of type m a are not called monads
19:12:10 <lispy> ah true
19:12:15 <lispy> so i wasn't careful about that
19:12:19 <sjanssen_> I wish lambdabot/ghci would only show kinds and forall's when strictly necessary
19:12:25 <Cale> > return 5 :: [Integer]
19:12:26 <lambdabot>  [5]
19:12:30 <Cale> > return 5 :: Maybe Integer
19:12:31 <lambdabot>  Just 5
19:13:07 <Cale> So treating the monad as a type of container, you can see that it just forms the container containing only that one value.
19:13:12 <sjanssen_> actually, is it ever necessary to give a kind declaration in the type of a function?  I would think not
19:13:19 <lispy> > return 1 :: IO Int -- lambdabot won't allow this but it's valid
19:13:19 <lambdabot>  No IO allowed
19:13:46 <newbcoder> since "return $ String x" maps to "return (String x)" how does this differ from "return String x" ?
19:13:48 <dibblego> http://rafb.net/paste/results/wfY3V731.html does the iterate function help somehow here?
19:13:52 <Cale> As a type of computation, (return x) is the computation which does nothing extra, and simply returns x when executed
19:14:14 <Cale> newbcoder: return String x = (return String) x
19:14:23 <lispy> newbcoder: return takes on parameter, so it gets confused if  you write "return String x" because it thinks you mean to give two parameters to return
19:14:42 <newbcoder> but in general I can write f g h x to denote (f (g (h x))) ?
19:14:47 <Cale> no
19:14:50 <glguy> in C, return is a special keyword. In Haskell, return is a function like any other
19:14:53 * lispy thinks he hsould let Cale explain :)
19:14:57 <Cale> f g h x = ((f g) h) x
19:15:17 <newbcoder> but if f; g; and h are functions
19:15:19 <newbcoder> then when I eval it
19:15:27 <newbcoder> I apply h; then pass it to g; then pass it to f; no ?
19:15:33 <Cale> no
19:15:38 <Cale> you'll be passing g as a parameter to f first
19:15:43 <Cale> which will give another function
19:15:48 <Cale> and then you'll pass h to that
19:15:53 <Cale> which will give another function
19:15:58 <lispy> newbcoder: take map (+1) [1,2,3], this is actually (map (+1)) [1,2,3
19:16:00 <Cale> and finally you'll apply that to x
19:16:20 <Cale> hehe, careful with the 'take' there :)
19:16:21 <lispy> > (map (+1)) [1,2,3]
19:16:22 <lambdabot>  [2,3,4]
19:16:28 <lispy> Cale: good call :)
19:16:37 <lispy> > map (+1) [1,2,3]
19:16:38 <dibblego> ?type take
19:16:38 <lambdabot>  [2,3,4]
19:16:39 <lambdabot> forall a. Int -> [a] -> [a]
19:16:49 <newbcoder> > (+1) [1, 2, 3]
19:16:49 <lambdabot>  add an instance declaration for (Num [a])
19:17:13 <lispy> ?type (map (+1))
19:17:14 <lambdabot> forall a. (Num a) => [a] -> [a]
19:17:21 <Cale> @type map
19:17:22 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:17:31 <Cale> map takes a function of type (a -> b)
19:17:32 <lispy> so that says that 'map (+1)' takes a list of numbers and produces a list of numbers
19:17:40 <Cale> and returns a function of type ([a] -> [b])
19:17:47 <lispy> which means that 'map (+1)' is a function
19:18:13 <Cale> this is in fact, how multiple parameters are always handled in Haskell
19:18:16 * lispy heads home and to food
19:18:51 <deadbeef> hey lispy, do you know UCW ?
19:19:20 <deadbeef> (UnCommon Web)
19:19:26 <Cale> Ultimate Christian Wrestling?
19:19:41 <deadbeef> lol
19:19:42 <monochrom> Sick!
19:19:44 <Cale> (seriously, that appears on the first page of google results for UCW)
19:19:48 <deadbeef> it's a web framework for lisp
19:20:19 <deadbeef> common-lisp.net/project/ucw/
19:21:08 <deadbeef> i wonder if it's worn learning
19:22:03 <sieni> deadbeef: might be. depends if you find common lisp hot or not
19:22:30 <deadbeef> something like that for haskell would be hot
19:22:36 <wkh> i think ucw's markup language syntax is ugly
19:22:44 <wkh> "<ucw:a"
19:22:45 <wkh> blegh
19:23:44 <sieni> are there other web frameworks in haskell in addition to HAppS
19:24:06 <dibblego> are there any production sites up that use HAppS?
19:24:34 <sieni> dibblego: who cares?
19:24:45 <dibblego> sieni, I do
19:25:13 <wkh> web people are sheep and only want to use something if they know it's a sure bet
19:25:31 <wkh> because they were weened on herd languages that encourage herd mentality and conformity
19:26:03 <sieni> I would say that in software business the main rule is that if some tool is widely used, then with a very high probability it is complete crap.
19:26:32 <dibblego> sieni, the qualification of "software" in "software business" is unnecessary
19:27:19 <dibblego> perhaps it is more obvious to critical thinkers in an immature industry such as software
19:27:19 <sieni> I meant "software business" as "business of writing software".
19:27:24 <deadbeef> i'm reading HAppS doc
19:27:26 <deadbeef> it's hot
19:27:33 <dibblego> "business" would do just fine
19:27:34 <sieni> Hammers are used widely in construction business, and I don't see them as complete crap.
19:27:56 <Cale> sieni: hehe
19:28:09 <dibblego> I used to work in construction, I assure you, there are analogies, but less so due to the maturity
19:28:17 <monochrom> Hammers are not software.
19:28:20 <sjanssen_> sieni: on the contrary, the hammer/screwdriver is far superior to the run of the mill hammer
19:28:36 <newbcoder> You may want to replace noneOf "\"" with a new parser action that accepts either a non-quote character or a backslash followed by a quote mark. <-- anyone want to teach me how to do this by ecample? (not hw; online tutorial; will even give you link to prove it)
19:28:39 <dibblego> the hammers that most carpenters use are expensive well marketed
19:28:41 <dibblego> American junk
19:28:45 <monochrom> The assertion "widely used => crap" is restricted to software, not hammers.
19:29:17 <newbcoder> monochrom, keyboards are crap
19:29:19 <sjanssen_> I mean, Prof. Frink did win a Nobel prize for it
19:29:43 <dibblego> it is not about being "not crap", it is just about being "less crap than the other guy"
19:30:23 <monochrom> No, it's about flame wars over generalizations.
19:31:03 <lennart> keyboards these days are crap
19:31:06 <dibblego> the question remains, is HAppS used in production by anyone?
19:32:48 <sjanssen_> dibblego: I'm going to bet it isn't
19:33:17 <dibblego> I think I read somewhere that haskell.org is intending to use it (or was it something else?)
19:33:51 <weitzman> I'm looking at the Monads_as_Containers document
19:33:57 <weitzman> And it has an excercise
19:34:04 <newbcoder> what is HAppS ?
19:34:05 <weitzman> and I don't have a copy of Haskell
19:34:17 <weitzman> So can anyone grade my solution?
19:34:27 <sjanssen_> dibblego: not likely, haskell.org uses MediaWiki which is PHP (if I remember correctly)
19:35:13 <weitzman> I propose the following bind operator on trees:
19:35:18 <dons> pass.net runs happs, i think (?)
19:35:30 <weitzman>  xs >>= f <==> case {Leaf a -> Leaf . f $ a; Branch a b -> Branch (a >>= f) (b >>= f)}
19:36:02 <sjanssen_> yeah, there is pass.net.  But, does anybody use pass.net?
19:36:05 <dons> yep, Copyright (c) HAppS Inc. 2006
19:36:19 <weitzman> And return x == Leaf x
19:37:02 <dolio> weitzman: I don't think that will work.
19:37:07 <weitzman> Doh!
19:37:24 <sjanssen_> that won't type check, but you're very close
19:37:27 <weitzman> Well, I seem to have messed up the case syntax
19:37:27 <dolio> f returns a Tree a, so Leaf . f $ a is Tree (Tree a)
19:37:31 <weitzman> case xs of
19:38:13 <weitzman> Oh, then I just need Leaf a -> f a
19:38:24 <dolio> Right.
19:39:15 <weitzman> I guess having a Leaf constructor in there amounts to redoing the work of "return"
19:39:16 <lispy> deadbeef: no i don't
19:39:27 <weitzman> And I feel like those two operations shouldn't be duplicating each others
19:39:36 <lispy> deadbeef: i haven't actively coded in lisp is like 6-9 months :(
19:40:13 <lispy> deadbeef: i spend all my time in Haskell or some language dictated by my job (like C++, Java, Python, R, ...)
19:40:42 * lispy gets to use Haskell at his job for the current project which is nice though
19:41:16 <deadbeef> i should make an inference engine using RETE for my thesis, to use it in some semantic web apps
19:41:23 <deadbeef> wondering if they allow me to do it in haskell
19:42:30 <wkh> i never understood precisely what in the flying fuck "the semantic web" was/is/will be
19:43:19 <lispy> wkh: that's web technologies in a nut shell if you ask me
19:43:24 <deadbeef> afaik it should be to store knowledge instead of information
19:43:28 <deadbeef> so ontologies and stuff
19:43:34 <jcreigh> wkh: I have no clue either. I've assumed it meant something like using RSS and the like. The main thing about the web these days is lining up your buzzwords.
19:43:39 <lispy> but, isn't everything an ontology?
19:43:45 <deadbeef> yes
19:44:04 <deadbeef> but it isn't structured in some ontology-oriented language
19:44:10 <deadbeef> like OWL, RDF and stuff
19:44:10 <wkh> i'm suspicious of people claiming expert systems and inference is a silver bullet
19:44:15 <wkh> that shit failed big time
19:44:40 <lispy> so, the computers should be able to understand our web of information?
19:44:43 <lispy> that's the goal?
19:44:51 <deadbeef> yes
19:44:55 <newbcoder> hmm
19:45:04 <newbcoder> I can get 95% accuracy by just predicting porn
19:45:09 <newbcoder> you guys work on the other 5%
19:45:13 <lispy> so maybe i should start blogging lojban(sp?)?
19:45:29 <deadbeef> http://protege.stanford.edu
19:45:30 <lambdabot> Title: The Prot&eacute;g&eacute; Ontology Editor and Knowledge Acquisition System
19:45:40 <deadbeef> this is a neat project to manage knowledge through ontologies
19:45:48 <weitzman> It's strange how some people are trying to get the web to be self-evident XML while others are trying to replace information with JavaScript that displays the information in some outrageous way
19:46:03 <lispy> weitzman: yeah, the latter pisses me off
19:46:12 <wkh> JSON?
19:46:38 <weitzman> lispy: I use the firefox plugin that doesn't run JavaScript by default, and it's impressive how many websites don't display correctly without it
19:46:43 <wkh> i like how protege doesn't have an RSS feed
19:46:49 <dolio> Heh. You don't want to replace all your desktop apps with a browser + javascript?
19:47:01 <lispy> depends on the app
19:47:14 <dolio> :) All of them. They're all obselete!
19:47:16 <wkh> clearly <textarea> is far superior to emacs/vim
19:47:17 <deadbeef> ghc.js lol
19:47:18 <lispy> i mean...how do you replace screen?
19:47:42 <deadbeef> emacs.js omg
19:47:49 <dolio> Tabbed browsing.
19:47:50 <weitzman> I want pretty much the opposite of running every app remotely. I want to be able to run useful but untrusted code on my computer without fear
19:48:01 <dolio> What are you using a terminal for anyway? All you run is a browser. :)
19:48:51 <deadbeef> a browser on top of SEL4 maybe
19:49:07 <weitzman> I'm waiting for OS's with capability-based security to catch on
19:49:11 <weitzman> It's going to be a looooong wait
19:49:48 <lispy> weitzman: what is that?
19:49:53 <wkh> actually, lispy
19:49:57 <wkh> have you seen youOS?
19:49:59 <wkh> youos.com
19:50:31 <wkh> they think fucked up windows that are slow as hell to redraw (and i'm on a pentium 4 2.8 ghz!) and break usability are a replacement to a desktop GUI
19:50:40 <weitzman> lispy: First-class permissions, basically. If a program needs to be able to do X, you can pass it a token over IPC so it can do X. No token, no doing X
19:50:41 <wkh> leet web 2.0 chutzpah
19:50:48 <lispy> wkh: creepy
19:50:50 <weitzman> lispy: As opposed to, say, access control lists
19:52:36 <monochrom> People love Turing-complete languages.
19:52:37 <lispy> weitzman: so, that's kinda like what zone alarm does now right?
19:53:21 <weitzman> lispy: In the sense that all programs get rejected by default, yes
19:54:59 <lispy> monochrom: is there more to that? :)
19:55:22 <jcreigh> monochrom: Actually, I like expressive languages. As opposed to languages that were born as config files, and then slouch like Frankenstein's monster towards Turing completeness, which they finally attain, but without a soul.
19:55:25 <lispy> weitzman: yeah, i was just thinking how you approve x progrom on y port as being sort of a capability
19:55:50 <lispy> jcreigh: the monster didn't have a soul?
19:55:59 <lispy> jcreigh: i thought that was sort of the point of the story
19:56:11 <weitzman> I'm not a big fan of turing-complete languages. Other than infinite loops, nobody really needs more than primitive recursion
19:56:35 <jcreigh> lispy: Err...dunno...never read it. It's just an analogy. :)
19:56:53 <monochrom> lispy: Yes, there is more to that.  People love Turing-complete languages because people are control freaks.  For example they use Javascript for no reason other than "I want to control how the web page looks like on you".
19:57:01 <lispy> jcreigh: maybe i'm taking you too figuratively :)
19:57:24 <lispy> monochrom: ah, right
19:57:33 <glguy> what the hell non-turing-complete language are you people talking about?
19:57:49 <lispy> glguy: compare xml to javascript + xml
19:57:56 <lispy> glguy: the latter is turing complete
19:58:06 <weitzman> Since when does xml qualify as a programming language?
19:58:07 <glguy> xsl is turing complete, and it's written in xml
19:58:12 <glguy> does that sount
19:58:26 <lispy> glguy: i'd say xsl is a different language than xml
19:58:42 <lispy> glguy: but it's true, the distinctions get fuzzy
19:58:43 <glguy> oh, the nxml isn't a programming language
19:58:52 <lispy> it isn't?
19:58:56 <glguy> it's a markup language
19:59:04 <monochrom> I'm commenting on why people use Javascript unnecessarily.  No comment on XML.
19:59:44 <lispy> glguy: but xml can be used to 'program' my browser, it just lacks certain levels of control, right?
19:59:56 <weitzman> JavaScript has a special place in my heart because it's the first programming language I ever used
20:00:02 <glguy> no, i doesn't program your browse...
20:00:08 <glguy> r
20:00:58 <monochrom> Well I had my first language too.  BASIC.  So when reading a Dijkstra writing tearing BASIC apart, you can imagine my feeling....
20:01:06 <lispy> glguy: but, it is a sequence of instructions that tells my brower how to display something right?
20:01:09 <monochrom> "Hahaahaha, this guy is damn right!"  :)
20:01:31 <weitzman> People take Dijkstra's rants too seriously
20:01:34 <edwardk> mono: heh, yeah =)
20:01:38 <weitzman> Everyone freaks out when you use goto in C
20:01:48 <weitzman> "But Djikstra says goto is harmful!"
20:02:01 <lispy> weitzman: better to use returnfrom :)
20:02:01 <edwardk> weitzman: yeah and its critical to making a fast emulator =)
20:02:12 <glguy> lispy: are .ini files written in the .ini programming language?
20:02:20 <deadbeef> weitzman: indeed with GOTOs it's hard to abstract on computations
20:02:21 <edwardk> 10 comefrom 10
20:02:44 <lispy> glguy: i don't know, i'm doing this more as a rhetorical discussion
20:02:55 <lispy> glguy: i guess to some extent, yes
20:03:18 <lispy> oh, comefrom...i misremember that as returnfrom
20:03:21 <glguy> lispy I just think that a programming languge is more than an agreed upon syntax
20:03:51 <lispy> well, a programming language would just be a language you can give sequences of instructions in right?
20:03:55 <dolio> XML is more of a standard way of describing data.
20:04:06 <dolio> Not a set of instructions that your browser executes.
20:04:17 <lispy> so, there is an important part we're not talking about...and that's the 'interpretation'
20:04:46 <lispy> like you mentioned that xsl transformations are stored in xml
20:05:00 <lispy> so under the xslt interpretation those are programs
20:05:03 <dolio> Unless you're actually talking XSLT or something like it, in which case the data described are instructions to be executed.
20:06:20 <lispy> but, it's interesting to note that the definition of program (at least when i type dict program) doesn't mention turing theory
20:06:22 <edwardk> dolio: hrmm. i think it still might be turing complete by way of entity declarations. they can include files of other entity declarations, and you can do some weird border cases.
20:06:26 <weitzman> There are some good programming languages that aren't turing complete
20:06:28 <dwm> I wonder if part of this distinction could be that XSL has things like conditional statements, recursion. But, say, a XHTML document has none of those things.
20:06:35 <br1> Why does ghc not like $ here?
20:06:35 <br1> newtype PP = PP (forall a. a)
20:06:35 <br1> pp = PP $ undefined
20:06:41 <weitzman> I write my mail filtering rules in the seive language
20:06:49 <dolio> edwardk: I suppose that could be. I'm not that familiar with that end of the stuff.
20:06:53 <dons> br1, hmm, rank-n issues with $ ?
20:07:02 <glguy> from Wikipedia: "ANSI/ISO SQL and Charity are examples of languages that are not Turing complete yet often called programming languages."
20:07:02 <dons> br1, try parens
20:07:20 <dons> (probably the same reason $ doesn't play well with the ST monad)
20:07:31 <dolio> edwardk: That'd probably be quite a perversion of the intent of XML, though. :)
20:07:35 <AstralStorm> SQL is not programming, ugh
20:07:38 <edwardk> dolio: of course
20:07:44 <lispy> br1: fwiw, i often run into places where ($) is not okay but parens work fine
20:08:02 <glguy> I've seen people write sql statements long enough to be their own programs ;)
20:08:15 <br1> dons: OK, I'll just use parens.  Thanks.
20:08:22 <lispy> AstralStorm: really? but it's a sequence of instructions which the computer inerprets and executes, right?
20:08:22 <weitzman> I saw an SQL command that was a few hundred lines this summer
20:08:30 <edwardk> I really want a $ as a language construct so I don't run into that type level $ not working problem.
20:08:39 <weitzman> My officemate was a PM
20:08:44 <edwardk> I wrote lots of code assuming it and had to go back and insert ()'s ;)
20:08:46 <weitzman> He did a lot of data analysis
20:08:54 <dons> edwardk: isn't it partially alleviated by the new impredicativity stuff?
20:09:03 <AstralStorm> That's still not programming, just multiple statements linked.
20:09:14 <dons> i've noticed at least some formally-broken uses of $ now work with 6.6
20:09:15 <AstralStorm> You don't have any real flow control in SQL.
20:09:19 <edwardk> weitzman: i work with lots of those kinds of sql statements. typically written by linguists, not programmers =/
20:09:20 <dons> formerly
20:09:41 <edwardk> dons: will test at some point
20:09:49 <edwardk> getting some sleep
20:09:53 <lispy> AstralStorm: my dictionary doesn't mention control flow or turing completeness for programs as part of the defition
20:10:09 <lispy> is my dictionary wrong?
20:10:14 <AstralStorm> Then my .ini file is programming too.
20:10:29 <AstralStorm> It's text describing to the computer what to do :P
20:10:41 <dwm> I think the term is used very loosely at times. i.e. 'programming the VCR'
20:10:46 <dons> br1, edwardk i can confirm that pp = PP $ undefined works with ghc 6.6
20:11:07 <edwardk> nice
20:11:18 <dons> people talk about programming html too :)
20:11:31 <AstralStorm> So call that "programming the database" not "programming in SQL" :>
20:11:35 <weitzman> Primitive recursion doesn't have control flow and isn't Turing complete, but it's pretty effective for calculations
20:11:44 <edwardk> does it work in the newtype though? =) I want newtype PP = PP $ forall a. a =)
20:11:57 <dwm> dons: That just makes me grumpy, but I can't really say that it's not some definition of programming. By that I mean I see where lispy is coming from on all this.
20:12:01 <AstralStorm> weitzman: for some, yes
20:12:10 <br1> dons: Cool.
20:12:24 <dons> edwardk: heh
20:12:25 <edwardk> to a non-programmer anyone who can make a computer do something is a programmer.
20:12:35 <weitzman> AstralStorm: Can you name me a computation problem that can't be solved by a primitive recursive function?
20:12:47 <weitzman> AstralStorm: The ackermann function doesn't count
20:12:50 <AstralStorm> weitzman: as seen by me computing factorials recursively in Excel :
20:12:54 <AstralStorm> :P
20:13:17 <dons> I think that if html is considered programming, then so is any structured text, making use of markup. such as the full stop, or "" operator. we're all programmers now
20:13:30 <lispy> heh
20:13:38 * lispy programs some irc text
20:13:49 <edwardk> dons: you wouldn't belive how often I hear html referred to as programming in my workplace. sad sad sad.
20:13:56 <glguy> dons: who in this channel isn't a programmer already, without the special natural language inclusion
20:14:08 <lispy> edwardk: if it's html + javascript i wouldn't bat an eye
20:14:15 <dons> glguy: hmm, lambdabot?
20:14:25 <dons> though she's probably a better programmer than some
20:14:27 <weitzman> AstralStorm: You can compute factorials primitive-recursively
20:14:30 <lispy> dons: alright, idea for a new plugin :)
20:14:45 <lispy> ?program
20:14:45 <lambdabot> Unknown command, try @list
20:14:54 <lispy> and then she spits out code :)
20:14:59 <AstralStorm> weitzman: how do you stop recursion without simple flow control such as "if"? :>
20:15:15 <AstralStorm> Or limiting the amount of it?
20:15:18 <weitzman> AstralStorm: Lambda calculus doesn't have an if statement
20:15:19 <edwardk> lispy: no javascript is implied when they say it ;)
20:15:28 <lispy> edwardk: :(
20:15:46 <lispy> @google site:wikipedia.org primitive recursion
20:15:50 <weitzman> AstralStorm: True can be defined as a function \x y -> x, false as \x y -> y
20:15:51 <lambdabot> http://en.wikipedia.org/wiki/Primitive_recursive_function
20:15:52 <dons> dwm, do you use dwm?
20:16:04 <dons> (the window manager)
20:16:04 <edwardk> astralstorm: if in the lambda calculus is based on how they define booleans.
20:16:18 <dwm> dons: heh, you're the second person to ask that. I do not, if you're taking about the window manager. I use fluxbox.
20:16:21 <lispy> weitzman: but lambda calc. is turing complete, so of course we canfind a way
20:16:34 <dwm> BTW, I recently found a permanent nick. I was using Dino_ for a few months.
20:16:47 <AstralStorm> edwardk: ugh, right :>
20:16:50 <dons> a right. yes.
20:16:55 <AstralStorm> I know all that :>
20:17:00 <AstralStorm> Anyway, lambda calculus implies flow control.
20:17:07 <AstralStorm> SQL isn't lambda calculus.
20:17:22 <glguy> unlambda is turing complete and how no flow control
20:17:33 <lispy> dwm: oh, did you used to hang out in some other channeli might know youfrom?  maybe #lisp?
20:17:34 <weitzman> unlamda is just lambda calculus
20:17:41 <glguy> hooray!
20:17:56 <dwm> lispy: No, never. But I did have somebody decommission the 'dwm' nick for me. It was unused for a long time.
20:18:15 <lispy> dwm: ah, the dino nick is the one that seemed familiar
20:18:17 <dwm> Haskell represents my first ever functional anything at all. Period.
20:18:23 <edwardk> AstralStorm: yeah but that didn't stop oracle from making PL/SQL ;)
20:18:35 <glguy> so.. you intentionally had an underscore in your nick?
20:19:08 <dwm> glguy: I didn't, but when my client tried to use 'Dino' it got changed to include the _ by being taken.
20:19:22 <glguy> oh, OK :)
20:19:39 <dwm> Ok, I guess you could say I left it that way for a while. Vaguely intentional.
20:20:25 * lispy has thoughts of basing his nick on his name
20:20:31 <glguy> dons: you there?
20:20:33 <lispy> but ultimately....i kinda like this nick
20:20:46 <lispy> but dagit wouldn't be a bad nick either
20:20:54 * lispy shrugs
20:20:56 <edwardk> lispy: its a lot easier to figure out who you are
20:20:56 <dibblego> I don't, I have to press tab twice ( lisppaste2 lispy )
20:21:03 <glguy> monochrom: you there?
20:21:40 <lispy> edwardk: you mean if i use dagit?
20:21:45 <edwardk> yeah
20:21:49 <lispy> yup
20:21:52 <lispy> which is the con
20:22:06 <edwardk> i gave up on 'harmless' a while back and just settled on using my name
20:22:20 <lispy> i sometimes drink and irc or vent on irc and i don't think a potential employeer should be able to find that so easily :)
20:22:22 <dons> glguy: ?
20:22:27 <edwardk> now I'm EdwardAllanKmett on AIM, Edward Kmett on slashdot, etc. ;)
20:22:31 <dwm> BTW, from Wikipedia on 'programming languages': Non-computational languages, such as markup languages like HTML or formal grammars like BNF, are usually not considered programming languages; however, informal usage sometimes includes them.
20:22:32 <edwardk> heh
20:22:37 <glguy> You know that code I showed you earlier using StateT?
20:22:48 <lispy> dwm: ah, cool
20:22:49 <edwardk> lispy: thats ok, you've now mentioned it in a publicly accessible log ;)
20:23:14 <lispy> edwardk: yup, but it's not so commonly linked or distinct that google ranks it highly
20:23:25 <dibblego> factors :: Integer -> [Integer] -- is the filter function going to solve it somehow?
20:24:00 <edwardk> lispy: all I'd have to do is lisppaste something so the context link would point back here ;)
20:24:10 <glguy> dons: I was just wondering if you could help me figure out what the type of simulateTurn would be if I kept tally with an STArray
20:24:25 <lispy> so, what is a language based on primitve recursion that you can actually program in?
20:24:27 <dons> just a bit busy atm. give me a couple of hours
20:24:37 <glguy> lispy: unlambda?
20:24:50 <lispy> i thought unlambda was a joke?
20:24:52 <edwardk> glguy: did you get my version that i never finished?
20:25:05 <glguy> edwardk: nope
20:25:08 <glguy> I'd like to tho
20:25:21 <edwardk> glguy: look up your original paste its annotated there
20:25:30 <lispy> google 'primitive recrusive control flow' doesn't turn up much...
20:25:35 <edwardk> i just didn't finish the ST stuff
20:25:39 <glguy> edwardk: do you know how I would modify http://paste.lisp.org/display/25854 to use STArray?
20:25:41 <edwardk> coz i suck at fixing up ST
20:26:00 <edwardk> ah thats another post. hrmm
20:26:10 <glguy> right now simulateTurn :: StateT Int (State StdGen) Int
20:26:11 <weitzman> unlambda isn't primitive recursive
20:26:13 <edwardk> the one i annotated was a lot shorter =)
20:26:17 <dibblego> http://rafb.net/paste/results/UNVWoR42.html there's probably a better way of doing that
20:26:19 <weitzman> It's Turing complete
20:26:31 <weitzman> I don't know of any primitive recursive languages
20:26:43 <glguy> edwardk: the important stuff is all at the top of my new post
20:26:57 <edwardk> 25846
20:27:11 <lispy> weitzman: well, we should make one...then it's easy to prove termination.  an dwe can have a way to escape to a turing complete space when you need it
20:27:24 <dolio> ?type join . liftM2
20:27:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> a1 -> r) -> m a1 -> m r
20:27:28 <edwardk> http://paste.lisp.org/display/25846
20:27:36 <lispy> http://www.catb.org/retro/
20:27:37 <lambdabot> Title: The Retrocomputing Museum
20:27:39 <lispy> or look at bloop
20:27:51 <edwardk> but like i said it needed to be fixed
20:27:54 <lispy> ?type join . liftM
20:27:55 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a1)
20:27:55 <lambdabot>    Expected type: (a1 -> r) -> m a1 -> m a1 -> a
20:28:30 <dolio> > join (liftM2 (+)) (subtract 1) $ 2
20:28:31 <lambdabot>  2
20:28:44 <weitzman> lispy: I wonder how elegantly you could express a primitive-recursive DSL within Haskell
20:29:43 <weitzman> lispy: Actually, Haskell would mess the whole thing up by allowing infinite loops. Curses, Haskell!
20:29:44 <edwardk> you must have been away when i pasted it earlier
20:29:47 <lispy> weitzman: or in the type system! ;)
20:29:58 <weitzman> lispy: That's what I was thinking
20:30:00 <glguy> edwardk: I probably was, but what you've pasted will help me finish mine
20:30:08 <glguy> I wasn't use how to do ST inside StateT
20:30:20 <weitzman> lispy: But Haskell will allow an infinite loop anywhere.
20:30:20 <lispy> i thought join . liftM was bind
20:30:24 <glguy> sure*
20:30:27 <lispy> weitzman: yup :(
20:30:31 <lispy> silly haskell
20:31:04 <lispy> ?type \f x -> join . liftM f x
20:31:05 <glguy> lispy: (join .) . liftM
20:31:05 <lambdabot> forall (m :: * -> *) a a1 a11. (Monad m) => (a11 -> m (m a)) -> (a1 -> a11) -> a1 -> m a
20:31:07 <glguy> maybe?
20:31:17 <lispy> glguy: yeh, i think so
20:31:25 <lispy> ?pl (join .) . liftM
20:31:26 <lambdabot> (=<<)
20:31:51 <lispy> glguy: http://www.codersbase.com/index.php/Haskell
20:31:57 <lispy> glguy: check the irc snippet :)
20:32:34 <glguy> heh
20:32:48 <lispy> > let o = 0 in ([o]) -- look ascii art
20:32:49 <lambdabot>  [0]
20:33:06 <lispy> ([o]) reminds me of something from the game metroid
20:33:56 <lispy> ?pl flip (join .) . fmap
20:33:56 <lambdabot> flip (join .) . fmap
20:34:02 <lispy> ?pl flip $ (join .) . fmap
20:34:02 <lambdabot> (>>=)
20:37:11 <dmwit> >
20:37:18 <dmwit> > (<font size="3">(: "a little surprise.") =<<) "Oh, look! " </font>
20:37:18 <lambdabot>  Parse error
20:38:01 <weitzman> nuffer: you there, nuffer?
20:38:10 <nuffer> yes I am
20:38:16 <weitzman> nuffer: I believe we shared a car once
20:38:19 <weitzman> Earlier this year
20:38:37 <dolio> > ((: "foo") =<<) "bar"
20:38:38 <lambdabot>  "bfooafoorfoo"
20:38:59 <weitzman> I just thought that was an odd coincidence
20:39:00 <dmwit> <font size="3">That's wahat I thought it ought to do... =P</font>
20:39:07 <nuffer> uh, when?
20:39:28 <weitzman> On the way home from CMU
20:39:31 <nuffer> oh yeah
20:39:32 <nuffer> I just remembered
20:39:36 <nuffer> haha
20:39:38 <nuffer> I'm in morewood
20:39:43 <dmwit> <font size="3">dolio: wait, what is different with that example?</font>
20:39:44 <nuffer> doing 415 hw
20:40:01 <weitzman> Good times. Anyway, I notice you occasionally coming and going from this channel
20:40:09 <dolio> dimwit: Yours has html font tags in it for some reason.
20:40:10 <nuffer> yeah, I'm not exactly a regular
20:40:17 <weitzman> Nor am I
20:40:28 <dmwit> <font size="3">Ah.</font>
20:40:37 <dmwit> <font size="3">Yeah, I got it from a web page.</font>
20:40:42 <dolio> dimwit: Actually, all of your subsequent messages have, too.
20:40:53 <lispy> heh
20:40:57 <dmwit> <font size="3">Hmmm... =(</font>
20:41:30 <nuffer> you still living in the same building as last year?
20:41:36 <lispy> so scroll down to the bottom to the MonadIO instance: http://www.haskell.org/hawiki/ImperativeHaskell
20:41:40 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki, http://tinyurl.com/gfbuv
20:41:47 <lispy> does that mean you can then use that instance in place of, say, IO a
20:41:54 <dmwit> dolio: Do I still have HTML in my messages?
20:42:11 <lispy> basically, what's the point of the MonadIO class
20:42:15 <dolio> dimwit: Nope. Gone now.
20:42:30 <dmwit> Sweet.
20:42:39 * lispy wonders if the first i is for intentional :)
20:45:17 <weitzman> nuffer: I responded out-of-channel. Don't know if you saw it
20:45:26 <nuffer> nope
20:46:05 <nuffer> it's cool though
20:46:23 <lispy> weitzman: doesn't look like you have identified with nickserv, if that's the case it's unlikely you'll be able to message people
20:46:29 <weitzman> Oh
20:46:39 <weitzman> Fixed!
20:46:43 <dmwit> lispy: The first "dmw" is for "my initials." =)
20:47:03 <lispy> dmwit: yes, but dolio kept typing dimwit ;)
20:47:15 <lispy> i think teasing you
20:47:25 <lispy> but i'm not sure
20:47:26 <dmwit> Ah, I didn't catch that...
20:47:36 <weitzman> nuffer: How did you come to be interested in haskell?
20:47:38 <dolio> Oops, my bad.
20:47:49 <nuffer> I just sort of stumbled upon it
20:48:04 <dolio> Hah. I'll have to chalk that up to studies on reading comprehension and middle letters.
20:48:09 <dolio> My apologies.
20:48:26 * lispy took a class and became fascinated by parametric polymorphism, laziness and the automatic partial application
20:48:44 <lispy> that's how i started learning haskell
20:49:07 <lispy> but if it weren't for darcs i probably wouldn't have starting using haskell for 'real work'
20:49:36 <lispy> my hatred of cvs and love of darcs made we want to add some functionality to darcs so we could use that in place of cvs
20:49:46 <lispy> so i ended up learning more haskell and liking it
20:50:07 <lispy> (i know no one asked for my motivation to learn haskell, but maybe someone will find it interesting ;)
20:50:21 <Adamant> I do! I do!
20:50:29 <Adamant> darcs is the bomb.
20:50:40 <Adamant> cvs will set you up the bomb
20:51:08 <lispy> lol
20:51:15 <lispy> cvs will set yo up the darcs ;)
20:51:17 <Thomas2_> for great justice ...
20:51:26 <dmwit> Take off all zig!
20:51:33 <Thomas2_> does anyone know if there's a way to save/restore the haskell heap through the FFI?
20:51:59 <lispy> Thomas2_: i don't know how much you can do, but you can work with the RTS some
20:52:19 <lispy> Thomas2_: the ghc manual has an example of how to start the RTS if you're making a haskell dll
20:53:07 <Thomas2_> hrmm. I'm out of my league here, I think.
20:53:47 <lispy> Thomas2_: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/win32-dlls.html#win32-dlls-create
20:53:50 <lambdabot> Title: 11.5. Building and using Win32 DLLs, http://tinyurl.com/hg8ux
20:54:07 <lispy> Thomas2_: what do you plan to accomplish by saving/restoring the heap?
20:54:33 <lispy> Thomas2_: maybe ffi is the wrong approach...maybe hs-plugins would be better
20:54:36 <Thomas2_> essentially we want to be able to trace a running system.
20:54:54 <Thomas2_> ffi is necessary, the system lives in haskell but is driven by a main loop across the ffi
20:55:18 <weitzman> While we're sharing why-I'm-learning/why-I-learned Haskell stories:
20:55:25 <weitzman> Everyone else was doing it. I just wanted to be popular
20:55:32 <Thomas2_> now my colleague is doing all this work thinking about how to represent the state, and how to save it delta-compressed, etc, and I was thinking that the heap contains all that already
20:55:35 <lispy> weitzman: touching
20:55:38 <lispy> weitzman: ;)
20:55:52 <lispy> Thomas2_: ah
20:56:05 <lispy> Thomas2_: i'd start by looking at Rts.h
20:56:13 <weitzman> Two friends of mine the last few years have been programming languages people
20:56:14 <lispy> i'm trying to locate that now
20:56:19 <dons> can someone help me find the first reference to the debugger/tracer 'hat' ? i.e. a first commit message, first release date or similar?
20:56:34 <weitzman> So between that and some courses I've taken, that's why I'm interested
20:56:40 <dons> i'm cross checking dates for the history of haskell paper.
20:56:54 <weitzman> And while they're off getting worthless PhDs, I'm going to be raking in mad loot
20:57:02 <lispy> dons: i'll try to help
20:57:07 <lispy> dons: i'll check irc logs
20:57:16 <dons> maybe start here, http://www.haskell.org/hat/
20:57:17 <lambdabot> Title: Hat - the Haskell Tracer
20:57:23 <lispy> okay
20:58:12 <dons> something circa. 2000 if possible (since we think that's the original date)
20:58:14 <lispy> they have a cvs repository...
20:58:22 <lispy> i'll try to check the history
20:58:24 <dons> ok. check that perhaps?
20:58:30 <dons> lispy++
20:59:34 <glguy> dons: is this possible simTurn :: StateT (STArray s Int Int) (State StdGen) ()
20:59:48 <dons> ?kind StateT (STArray s Int Int) (State StdGen) ()
20:59:49 <lambdabot> Not in scope: type constructor or class `STArray'
20:59:49 <lambdabot>  
20:59:49 <lambdabot> <interactive>:1:16: Not in scope: type variable `s'
21:00:26 <lispy> revision 1.1
21:00:27 <lispy> date: 1999-10-11 11:50:18 +0000;  author: sparud;  state: Exp;
21:00:27 <lispy> branches:  1.1.1;
21:00:28 <lispy> Initial revision
21:00:31 <lispy> that's close to 2000
21:01:21 <dons> looks good. is that on a public url?
21:01:30 <lispy> kinda
21:01:38 <dons> url please :)
21:01:46 <lispy> i checked out with anon cvs and then used cvs log | grep date: | less
21:01:51 <lispy> http://www.haskell.org/hat/cvs.html
21:01:52 <dons> ok
21:01:52 <lambdabot> Title: Hat in CVS
21:02:03 <glguy> meme?
21:02:11 <glguy> oh
21:02:34 <glguy> I just kind figure out how to manipulate the STArray inside simTurn
21:02:54 <glguy> which is making me think I'm using ST Array wrong
21:03:02 <glguy> can't*
21:03:35 <dolio> glguy: Don't you need to use an ST array in an ST monad, not a StateT?
21:04:17 <glguy> dolio: I'm doing the runST one level above that, if possible
21:04:18 <glguy> that's why I'm trying to figure out howto do what I'm trying to do
21:04:19 <dons> lispy: what about HaXml, can you find a ref from 1999?
21:04:28 <lispy> dons: sure thing boss!
21:04:30 <dons> lispy: i've got http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg06230.html
21:04:31 <lambdabot> Title: HaXml stuff ..., http://tinyurl.com/z6h6o
21:04:36 <dons> but that's Feb 2000
21:04:53 <dolio> glguy: Right, but you need to pass out something like ST s (STArray s Int Int)
21:05:00 <lispy> dons: well, the icfp paper is 99
21:05:43 <dons> ok. url?
21:05:43 <jgrimes> "The HaXml library and tools were written by and are copyright to
21:05:43 <jgrimes>     (c) copyright 1998-2005    Malcolm Wallace and Colin Runciman
21:05:43 <jgrimes> "
21:05:59 <glguy> Ok, maybe my question is, "How do I combine State StdGen and STArray?"
21:06:15 <dons> ah nice. i'll use that, but take the 99 paper as the official date (we use papers where they exist)
21:06:23 <jgrimes> :)
21:07:01 <lispy> yeah
21:07:22 <lispy> dons: scrolldown for the icfp99 link http://www.cs.york.ac.uk/fp/HaXml/
21:07:24 <lambdabot> Title: HaXml: Haskell and XML
21:07:59 <dolio> Hmm... Maybe something like...
21:07:59 <dons> cheer
21:08:01 <dons> s
21:08:25 <dolio> StateT StdGen (ST s) (STArray s Int Int)
21:08:45 <lispy> do you need parens around (StdGen (ST s)) ?
21:09:10 <Cale> no
21:09:10 <dolio> No, StdGen is the state of the StateT transformer
21:09:20 <dolio> ST s is the underlying monad.
21:09:55 <lispy> ?kind StateT
21:09:56 <lambdabot> * -> (* -> *) -> * -> *
21:10:05 <lispy> ?kind ReaderT
21:10:06 <lambdabot> * -> (* -> *) -> * -> *
21:10:18 * lispy gets confused
21:10:37 <lispy> hoan: welcome
21:10:49 <hoan> thanks
21:11:18 <dolio> StateT s takes a monad m and turns it into a monad with the properties of m, but also storing a threaded state s.
21:11:27 <glguy> dolio: using that type, whatwould the simplest function definition be?
21:12:25 <dolio> glguy: Hmm... Where's your latest candidate?
21:12:54 <glguy> simTurn = do { r <- gets (randomR (1,6)); lift $ newArray (0,39) 0 }
21:13:06 <glguy> that seems to type check
21:13:36 <glguy> but I'm not sure that this allows me to use the same array over and over
21:13:57 <lispy> is nomaware down?
21:13:58 <dolio> Hmm...
21:14:09 <glguy> know what I mean?
21:14:13 <dolio> Yeah.
21:14:21 <lispy> i was going to read up on StateT but it seems to be not responding
21:14:26 <Cale> glguy: the array is just being returned, it's not being carried around, though you're in ST, so it's not hard to stash it in an STRef
21:14:42 <Cale> (or use an STArray
21:14:53 <Cale> er, I suppose you are)
21:14:55 <glguy> Well, what's the "best" way to do something like this
21:15:10 <Cale> something like what?
21:15:43 <Cale> also, if you're using  StateT StdGen, you might want to steal my RandomT
21:15:47 <glguy> I'm trying to use STArrays to keep a tally of squares visited.  this is the non-starray version
21:15:52 <glguy> follows
21:15:56 <glguy> http://paste.lisp.org/display/25854
21:16:04 <glguy> ^ how i did it tallying at the end
21:16:37 <glguy> Cale, maybe what I want is ot use this "RandomT" then... link?
21:16:55 <Cale> http://www.haskell.org/haskellwiki/NewMonads/MonadRandom
21:16:57 <lambdabot> Title: NewMonads/MonadRandom - HaskellWiki, http://tinyurl.com/nlrgg
21:19:00 <dons> lispy: I need a 1996 reference for Haskore
21:20:31 <ubuntu> I just want to say that the lastest ubuntu can apparently detect my computer's wireless card, and that's awesome
21:20:57 <glguy> awww, he's gone...
21:21:06 <glguy> and I wanted to hear more about things that ubuntu just started being able to do
21:21:24 <dons> Hugs 1.0 was released on valenties day. hehe
21:21:31 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg01446.html
21:21:33 <lambdabot> Title: Hugs on Valentines day!, http://tinyurl.com/hdp5b
21:23:41 <lament> awwwww
21:23:49 <lament> <3
21:24:24 <sieni> <3
21:24:28 <lament> well, i suppose sex is not for everyone :D
21:24:52 <dons> can anyone find a reference to the haskell.org website from earlier than 1996?
21:25:52 <lispy> dons: google wasn't around back then, were they?
21:26:02 <lispy> but i'll see what i can find
21:26:45 <dons> well, the whois db says 1996, but Hudak et al suggest ~94
21:26:52 <Cale> glguy: hm? I run ubuntu as well if that wasn't sarcasm :)
21:27:31 <lispy> dons: well, wikipedia says 1996 too: http://en.wikipedia.org/wiki/Haskore
21:27:35 <dibblego> ubuntu wouldn't detect my wireless card, so I took it back and got a new one - now the driver crashes
21:27:43 <dons> ah, for Haskore. thanks.
21:27:52 <dons> lispy, what about the haskell.org site?
21:28:21 <lispy> hmm..let me sleuth around a bit
21:28:29 <lispy> '94 is the one to confirm?
21:28:40 <dons> yeah, for haskell.org
21:28:50 <dons> i have 96. but suspect it is earlier
21:29:50 <Cale> dibblego: huh. I have no experience with wireless networks, as I've never owned a laptop.
21:30:18 <dibblego> Cale, I hadn't owned a laptop until recently, but I've been using wireless for a long time
21:30:34 <Cale> dibblego: to connect desktop machines?
21:30:39 <dibblego> Cale, right
21:30:40 <Cale> I suppose you can do that
21:30:49 <dibblego> Cale, no wires around my house for the kids to trip over
21:30:55 <dolio> Linux is notoriously flaky when it comes to wireless cards.
21:31:21 <dibblego> only on those with proprietrary device drivers
21:31:41 <Cale> heh, I just buy really long cables. At one point, I went out and got a 100 foot network cable and ran it through the underground tunnel to my neighbour's apartment so we could all be on the same network :)
21:31:42 <dolio> Yeah, well, from what I understand, that covers quite a few. :)
21:31:53 <dolio> Perhaps it's gotten better, though.
21:32:07 <dibblego> there is always ndiswrapper
21:32:16 <dolio> Yeah, that helps too.
21:32:21 <dibblego> Cale, you're odd :)
21:32:22 <Oliver> Hehe, that's my trick too Cale - I run a 30M cable over the roof to connect to upstairs :)
21:32:37 <dibblego> Oliver, I used to do that, until lightning struck my house
21:32:44 <jgrimes> dons, does this count http://citeseer.ist.psu.edu/context/2421543/0
21:32:52 <Oliver> Haha, not a good result?
21:33:00 <dibblego> Oliver, an expensive result
21:33:06 <lispy> jgrimes: which one is thta for?
21:33:08 <lament> Cale: did you have to dig an underground tunnel first?
21:33:15 <lispy> jgrimes: haskell.org date?
21:33:18 <lament> Cale: using nothing but your fingers and a rusty spoon?
21:33:19 <Cale> lament: no, it was preexisting
21:33:21 <lament> oh :(
21:33:23 <jgrimes> lispy, yes
21:33:42 <lispy> dons: http://cvs.haskell.org/Hugs/pages/hugsman/basics.html
21:33:43 <Cale> we were in a sort of complex of joined-together houses
21:33:44 <lambdabot> http://tinyurl.com/ppjcm
21:34:00 <dons> jgrimes: that's a mailing list entry though? not the www.haskell.org site?
21:34:15 <lispy> dons: i don't know how well you can consider that correlated, but it says, hugs copy right 1994-1999 and says to get it from haskell.org
21:34:26 <lispy> dons: so maybe we can find an order copy of that file
21:34:29 <jgrimes> dons, true
21:34:30 <dons> ok. that's good
21:35:08 <dons> i'll leave it as 96, and see if wadler, hudak etc can clear that up
21:35:45 <dons> ok, now: Fudgets. wikipedia says 1991-96, but can we find a paper?
21:35:53 <dons> (hallgren's fudgets thesis is 98)
21:35:54 <lispy> if i can find the cvs repo for hugs i can probably clear it up :)
21:38:46 <dons> one place to look is comp.lang.functional, http://groups.google.com/group/comp.lang.functional/about?hl=en
21:38:47 <lispy> dons: fudgets was 1991 accord to its own website: http://www.md.chalmers.se/Cs/Research/Functional/Fudgets/
21:38:49 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/khb9e
21:38:53 <lambdabot> Title: Fudgets Home Page, http://tinyurl.com/epmzo
21:40:27 <dons> ok, we have, Programming with Fudgets - a tutorial
21:40:28 <dons>     Last updated on 9 Dec 1994
21:40:38 <dons> oh, and
21:40:40 <dons> Fudgets - A Graphical User Interface in a Lazy Functional Language
21:40:41 <dons>     An FPCA-93 paper describing the Fudget system. This was the first publication of fudgets
21:40:44 <dons> that'll do
21:41:49 <lispy> you don't trust their own website? :)
21:42:10 <lispy> this cvs repo for hugs is a deadend...i don't see anything older than 1999
21:42:34 <dons> I prefer a paper if they exist.
21:42:52 <dons> hugs is fine. i've got http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg01446.html
21:42:53 <lambdabot> Title: Hugs on Valentines day!, http://tinyurl.com/hdp5b
21:44:34 <deadbeef> what about turning HappS into an apache plugin ?
21:44:39 <deadbeef> it would be neat imho
21:45:30 <lispy> dons: oh, i was curious about hugs because i wanted to date haskell.org
21:46:09 <sieni> 3735928559: might be
21:46:28 <dons> lispy: ah right.
21:47:02 <dibblego> someone should write a function HttpRequest -> HttpResponse then write an Apache plugin to call some function definition
21:47:40 <jgrimes> we have cgi/fastcgi interfaces
21:48:35 <deadbeef> something like php would nice imho
21:48:41 <lispy> jgrimes: can you give me a fastcgi implementation url?
21:48:46 <deadbeef> <% haskell code %>
21:48:48 <lispy> jgrimes: i'd like lambdabot to speak fastcgi
21:48:55 <lispy> deadbeef: that exists too
21:49:01 <jgrimes> lispy, http://www.cs.chalmers.se/~bringert/darcs/haskell-fastcgi/doc/
21:49:02 <lispy> deadbeef: wash i think?
21:49:05 <lambdabot> http://tinyurl.com/jeppk
21:49:11 <deadbeef> omg let me search
21:49:14 <lispy> jgrimes: thanks,i'll checkit out in a minute
21:49:34 <lispy> dons: http://web.archive.org/web/*/http://haskell.org
21:49:37 <lambdabot> Title: Internet Archive Wayback Machine, http://tinyurl.com/jtngg
21:49:39 <deadbeef> omg amazing
21:49:41 <deadbeef> lispy: thanks
21:50:11 <jgrimes> lispy, it lets you use the new-cgi library ( I think the name changed to cgi-compat ) with fastcgi
21:50:15 <lispy> deadbeef: heh, gladi could help
21:50:28 <lispy> jgrimes: well, does it work with apache2 and is reasonably efficient?
21:50:34 <lispy> jgrimes: because that's all i care about :)
21:50:42 <jgrimes> lispy, from what I've used it, yes
21:51:03 <jgrimes> but I haven't had very heavy loads or anything either
21:51:12 <lispy> jgrimes: i would consider it efficient as long as i don't have to restart lambdabot for every http request
21:51:57 <dons> lispy: thanks.
21:52:08 <dons> yes, you don't want to have to restart lambdabot
21:52:23 <lispy> dons: you already know about this fastcgi interface?
21:52:39 <lispy> if it were traditional cgi that would be required right?
21:52:50 <lispy> (excluding wrappers around lambdabot)
21:52:59 <dons> right, excluding wrappers
21:53:33 <lispy> well, i probably won't get it working tonight, but that is something i would like to get working
21:53:39 <lispy> @localtime lispy
21:53:40 <lambdabot> Local time for lispy is Mon Sep 11 21:53:15 2006
21:54:08 <lispy> dons: the only caveat to using wayback machine is we don't know how reliable they are and they didn't start till 1996
21:54:22 <lispy> dons: but it gives us at least one data point
21:54:26 <lispy> in 1997
21:55:03 <dons> ?tiny-url http://groups.google.com/group/comp.lang.functional/browse_thread/thread/b7a36e7d4540ab2e/f870d86ecc9cbda7?lnk=gst&q=%22Journal+of+Functional+Programming%22&rnum=6#f870d86ecc9cbda7
21:55:05 <lambdabot> http://tinyurl.com/o54br
21:55:28 <lispy> tiny-url++
21:55:35 <dons> :)
21:56:26 <dons> ?tiny-url http://groups.google.com/group/comp.lang.functional/browse_thread/thread/d19a4fa9084851eb/a5cc6ac1df70e358?lnk=gst&q=%22Haskell+Report%22&rnum=4#a5cc6ac1df70e358
21:56:27 <lambdabot> http://tinyurl.com/lrhqc
21:57:16 <dons> apparently I can get a copy of the Haskell 1.0 Report if I send 5 pounds to The Haskell Project, Department of Computing Science University of Glasgow
21:57:19 <dons> should I try?
21:57:31 <dons> has to be payable to "The Haskell Project"
21:57:40 <lispy> hahah
21:57:55 <lispy> since i'm not british i can ask, 5 pounds of what??
21:58:02 <bitshifter> flax
21:58:07 <Pseudonym> flesh
21:58:11 <dons> lambdas?
21:58:19 <Pseudonym> How much does a lambda weigh?
21:58:39 <Pseudonym> Actually, that's a better currency than karma.
21:58:40 <dons> well, /\ are heavier than \, I presume. so maybe more info requried
21:58:41 <lispy> okay, so even after getting a recent cabal i still have a problem with cabal install not making libraries world readable...any ideas?
21:58:43 <bitshifter> approx 3.3 angel's footsteps
21:59:04 <Pseudonym> dons: Lambda, not type lambda.
21:59:19 <dons> :)
21:59:32 <lispy> my umask is 0007
21:59:35 <lispy> could taht be the problem?
21:59:47 <lispy> if so, what is a umask that works with cabal's installer?
22:00:09 <glguy> hey... i got it working in ST
22:00:19 <lispy> glguy: cool
22:00:43 <glguy> can StateT work on StateT?
22:00:48 <lispy> http://www.haskell.org/pipermail/libraries/2005-July/004132.html
22:00:51 <lambdabot> Title: cabal permissions problems, http://tinyurl.com/mfgsm
22:01:02 <lispy> hmm...so that was in 2005, you'd think the problem would be fixed in 6.4.2
22:01:25 <Pseudonym> glguy: You bet it can.
22:01:46 <Pseudonym> For serious uncertain computing, put NondetT on top of NondetT.
22:06:02 <glguy> wow, using two StateTs was easy
22:06:11 <glguy> and MUCH cleaner
22:10:47 <glguy> ?hoogle modifySTArray
22:10:47 <lambdabot> No matches found
22:10:53 <glguy> ?hoogle readSTArray
22:10:53 <lambdabot> No matches found
22:10:55 <glguy> ?hoogle readArray
22:10:56 <lambdabot> Data.Array.MArray.readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
22:11:00 <glguy> ?hoogle modifyArray
22:11:01 <lambdabot> No matches found
22:11:14 <dylan> ?hoogle writeArray
22:11:14 <lambdabot> Data.Array.MArray.writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
22:11:26 <glguy> yeah, i just wondered if there was a way to not read it and then write it
22:11:28 <glguy> but do it in one motion
22:11:58 <dylan> try composing readArray and writeArray and asking @pl :-)
22:12:11 <glguy> lol :)
22:15:18 <glguy> http://paste.lisp.org/display/25854#1
22:15:25 <glguy> if anyone cares to see my handiwork ;)
22:16:06 <lispy> Setup.hs: cannot satisfy dependency cgi>=2006.8.29
22:16:08 <lispy> hmm...
22:16:18 <lispy> i just installed the latest NewCGI
22:16:33 <lispy> which gave me cgi-compat-2006.9.6
22:16:38 <lispy> so where is cgi?
22:17:28 <lispy> jgrimes: any ideas what i'm missing?
22:21:20 <dibblego> http://www.willamette.edu/~fruehr/LLC/lab1.html is problem 7 solvable using max and filter somehow? if not, what common functions can be used?
22:21:23 <lambdabot> Title: CS 451/LLC Lab 1: Basic Haskell Exercises, http://tinyurl.com/o2c4t
22:21:55 <lament> i wish my cs courses had haskell.
22:22:06 <dolio> Where's problem 7?
22:22:29 <dibblego> er problem 6
22:22:30 <dylan> lament: I wish my CS courses had CS..
22:22:33 <dibblego> tricked ya!
22:22:39 <Lemmih> lispy: Change the dependency to cgi-compat?
22:22:40 <dolio> :)
22:22:50 <dibblego> lament, I just picked a random web pages with haskell problems
22:22:58 <lispy> Lemmih: yeah, taht does seem to be working :)
22:23:00 <lament> dibblego: that's what they all say
22:23:00 <lispy> Lemmih: thanks
22:23:03 <dibblego> lament, I expect students are offered hints of some sort
22:23:32 <lispy> dibblego: look at maximum
22:23:37 <lispy> dibblego: length
22:23:39 <lispy> dibblego: and map
22:23:51 <dibblego> lispy, so is it all solvable with maximum length and map?
22:24:05 <dibblego> ?type maximum
22:24:06 <lambdabot> forall a. (Ord a) => [a] -> a
22:24:16 <dibblego> actually I meant that one
22:24:37 <lispy> dibblego: well, i tihnk filter would be needed
22:24:49 <lispy> dibblego: but you could skip filter by using a list comp.
22:24:52 <dibblego> ok, so maximum length map and filter
22:24:57 <dolio> You'd probably want groupBy
22:24:58 <dibblego> I don't want to do that just yet
22:25:08 <dibblego> ?index groupBy
22:25:08 <lambdabot> Data.List
22:25:20 <lispy> groupBy would give nice solutions...or what about sortBy?
22:25:24 <lispy> ?type sortBy
22:25:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:27:36 <lispy> actually, sortBy ain't so hot
22:27:47 <lispy> because you'd still need to know how many elements to take
22:29:53 <lispy> oh, and the problem with groupBy is this:
22:30:05 <lispy> > groupBy (==) [1,1, 2, 1]
22:30:06 <lambdabot>  [[1,1],[2],[1]]
22:30:15 <dolio> Yeah, what's with that?
22:30:35 <lispy> probably done that way so it will still work on finite lists
22:30:40 <glguy> > group $ sort [1,1,2,1]
22:30:41 <lambdabot>  [[1,1,1],[2]]
22:30:43 <lispy> er infinite
22:30:43 <dolio> Oh, I see.
22:30:50 <dolio> Yeah, you need to sort and then group.
22:31:04 <lispy> right, so you could sortBy length
22:31:11 <lispy> but, it gets sort of messy
22:31:29 <lispy> map, length, filter and so on i think gives a more natural and efficient way
22:31:35 <glguy> > map (ap (,) head) $ group $ sort [1,1,2,1]
22:31:36 <lambdabot>  [([1,1,1],1),([2],2)]
22:31:49 <glguy> > map (liftM2 (,) head length) $ group $ sort [1,1,2,1]
22:31:50 <lambdabot>  [(1,3),(2,1)]
22:32:25 <dolio> ?pl \f g a b -> f (g a) (g b)
22:32:26 <lambdabot> join . ((flip . ((.) .)) .) . (.)
22:32:27 <glguy> > map ((&&&) head length) $ group $ sort [1,1,2,1]
22:32:28 <lambdabot>  [(1,3),(2,1)]
22:32:54 <glguy> dolio: join (liftM2 f) g
22:33:06 <dolio> Does that work?
22:33:10 <lispy> i guess using map and length you probably want to zip too
22:33:12 <glguy> > join (liftM2 (,)) length [1,2,3]
22:33:13 <lambdabot>  (3,3)
22:33:14 <dolio> I thought that was f (g x) (g x)
22:33:23 <glguy> oh, that?
22:34:02 <dolio> I want f (g x) (g y)
22:34:18 <dolio> For sortBy (\a b -> f a `compare` f b) situations.
22:34:43 <Cale> > ap (,) length [1,2,3]
22:34:44 <lambdabot>  ([1,2,3],3)
22:34:48 <glguy> I usually just write: comparing f a b = f a `compare` f b
22:35:21 <Cale> glguy: that one's going to be in Data.Ord in 6.6 :)
22:35:22 <glguy> ?let comparing = (\f a b -> f a `compare` f b)
22:35:23 <lambdabot> <local>:2:27:     Ambiguous type variable `a' in the constraint:       `Ord a...
22:35:34 <dolio> Ah, well, that'll be handy, at least.
22:35:37 <lispy> Cale: ah good
22:35:45 <lispy> ghc6.6++
22:35:46 <lispy> ;)
22:36:28 <glguy> Cale: I finally figure out how to use the StateTs and STs and STRefs all together: http://paste.lisp.org/display/25854#2
22:36:52 <glguy> figured*
22:45:02 <lispy> http://paste.lisp.org/display/25865
22:45:06 <lispy> i could use some help
22:45:52 <dons> ?remember JohnPeterson [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
22:46:09 <lispy> oh, n/m
22:48:18 <dons> hey nothingmuch. long time, no see.
22:50:52 <bringert> hmm, if you got one of those free cell phone e-mail chain letter hoaxes, would you: a) throw it away, or b) send it to lots of people hoping to get a free phone, including a bunch of your university professors, the University IT helpdesk, the some Swedish authorities and the course mailing lists for courses that you've taken
22:51:47 <Cale> bringert: heh
22:52:15 <dons> hehe
22:52:53 * Pseudonym feels neglected
22:52:55 <Pseudonym> I didn't get this hoax.
22:54:04 <bringert> Pseudonym: here you go: http://www.breakthechain.org/exclusives/ericsson.html
22:54:07 <lambdabot> Title: Free Phones from Ericsson or Samsung - BreakTheChain.org, http://tinyurl.com/jgnnm
22:54:19 <dons> hmm, these spiralfrog files are supposed to expire after 6 months, if you don't view the adverts. seems unlikely to work... :)
22:57:23 <glguy> wait, you are saying that I'm not going to get a free phone?
23:06:10 <Pseudonym> Thanks!
23:06:23 <Pseudonym> Though I'd have preferred to receive it in email so I could report it.
23:06:24 * Pseudonym grumbles
23:09:07 <lispy> damn, did i just miss bringrt and he's the fastcgi author?
23:09:47 <Lemmih> Got some fastcgi questions?
23:11:32 <lispy> yeah
23:12:01 <lispy> i compiled up hello.hs and put it as hello.fcgi but i'm gettting 403
23:12:02 <lispy> http://lambdabot.codersbase.com/hello.fcgi
23:12:18 <lispy> but it's world readable and executable
23:12:53 <lispy> i don't see anything in my error logs
23:13:44 <lispy> which would make me think fastcgi is not firing...but it's an enabled module and i have AddHandler fcgid-script .fcgi
23:17:05 <dibblego> I wish I picked a webpage with exercises that had hints
23:18:35 <lispy> dibblego: yeah, how's that one coming
23:18:52 <dibblego> I only just started, but I'm a bit lost
23:18:54 <lispy> dibblego: i figured out it's a bit tougherthan i thoguhtif you use map and length
23:19:16 <lispy> dibblego: sortBy, groupBy are maybe a bit easier
23:19:18 <dibblego> I figure I need a function [a] -> a -> [a]
23:19:26 <lispy> dibblego: but then youneed to know more haskell
23:19:36 <dibblego> why do I need to know more?
23:20:08 <lispy> the way i was thinking of using sortby and groupby you need the 'compare' function too
23:20:15 <dibblego> ?type compare
23:20:16 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
23:20:22 <dibblego> ?index compare
23:20:22 <lambdabot> Prelude
23:20:39 <dibblego> can you download the haskell documentation for local perusal?
23:20:49 <lispy> okay, so any .fcgi is giving this 403
23:21:01 <lispy> @google Prelude.hs
23:21:05 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
23:21:05 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
23:21:10 <dolio> dibblego: What do you need the [a] -> a -> [a] for?
23:21:10 <lispy> i'd start there
23:21:15 <lispy> the report is pretty easy to read
23:21:28 <dibblego> dolio, dunno, I'm just guessing a bit
23:21:45 <Lemmih> lispy: Try executing the binary from the console.
23:22:19 <lispy> Lemmih: $ ./hello.fcgi
23:22:19 <lispy> hello.fcgi: user error (FCGX_Accept failed)
23:24:06 <dibblego> dolio, I figure I will have a function that is calling itself with a list and the next value in the list and determining whether or not that value should go in the existing list (same length) or a new list (greater than existing)
23:24:50 <dolio> Ah, i see.
23:26:33 <dibblego> dolio, it's still just a guess though
23:26:49 <dibblego> I'll go for a walk to the train station and try again on the train
23:26:53 <dibblego> I've been distracted too much
23:27:20 <dolio> Good luck.
23:27:27 <dibblego> wanna know something funny?
23:27:45 <dibblego> you know how some days feel like they go longer than others?
23:28:13 <dibblego> I just had someone try to tell me that that is the fundamental point of the general theory of relativity
23:28:23 <dibblego> and I laughed thinking it was a joke, but he was serious
23:28:25 <dolio> Heh.
23:28:50 <glguy> I imagine that if time slowed down... your preception of time would slow down too
23:28:53 <glguy> and you'd never know it
23:29:15 <dibblego> you assume that time is a static entity external to yourself, which is wrong
23:29:33 <glguy> that's not totally true...
23:29:34 <dibblego> time cannot "slow" - it can only slow relative to the observer - yourself? then it didn't "slow"
23:29:38 <glguy> i think that the world revolves around me
23:29:50 <dibblego> well, then we have conflicting axioms :)
23:30:23 <glguy> and the reason that the sun will come up tomorrow is because I wait for it to
23:30:31 <dibblego> do not ask "what is the time?" - instead ask "what is your time?"
23:30:50 <dibblego> then extrapolate your own time from that frame of reference
23:33:11 <glguy> one of the types in my "simulation" (c;  simTurn :: (Num e, MonadTrans t, MonadTrans t1, MonadState a (t (t1 m)), MArray a1 e m, MonadState s (t1 m), Ix a, Integral a, RandomGen s, Random a) => a1 a e -> t (t1 m) ()
23:33:33 <dolio> Nice.
23:34:41 <Pseudonym> It's times like this that you really want typeclass synonyms.
23:34:41 <glguy> dolio: You'd better write your own monopoly sim in Haskell (c;
23:35:00 <glguy> Pseudonym: fortunately for me, that is an inferred type
23:35:20 <lispy> oh, i got it
23:35:38 <lispy> lombdabot instead of lambdabot in one place and it was 95% working :)
23:35:49 <lispy> stupid typos :)
23:36:13 <dons> heh
23:36:23 <glguy> making functions readable takes all of the fun out of writting them ):
23:38:48 <dolio> glguy: Why are you writing a monopoly sim?
23:39:13 <glguy> dolio: as a Haskell exercise now (it's a mathschallenge problem)
23:39:27 <glguy> I had already solved it in C#
23:39:38 <glguy> but I figured it would be good to learn how to use ST and StateT better
23:40:10 <Cale> glguy: I recall there was an article in an old Scientific American where they investigated the probability of landing on the various squares after n turns.
23:40:26 <glguy> Cale: that is what this sim is for (c:
23:40:33 <dolio> Oh, I see.
23:40:59 <dolio> I haven't looked at that one yet.
23:42:00 <lispy> dons: okay, so i've completeted the first step...which was to get fast cgi working with an example haskell app...so now how do we get lambdabot working as a cgi program
23:42:09 <lispy> dons: probably through a command line option?
23:42:14 <lispy> --cgi
23:42:32 <lispy> or maybe it would need a whole different cabal file...
23:42:43 <lispy> yes, i think it would need a different cabal file
23:46:36 <dons> a separate build seems reasonable, to avoid all the dependencies
23:46:45 <emu> > logBase 10 1000
23:46:46 <lambdabot>  2.9999999999999996
23:47:26 <lispy> dons: right and i thinking probably need a -D__CGI__ so that you can take over main...
23:47:28 <dolio> > logBase 10 1000 :: Rational
23:47:28 <lambdabot>  add an instance declaration for (Floating Rational)
23:47:28 <lambdabot>   In the expression: ...
23:48:00 <dolio> > logBase 10 1000 :: Real
23:48:01 <lambdabot>    Class `Real' used as a type
23:48:01 <lambdabot>   In the type `Real'
23:48:01 <lambdabot>   In an expression ...
23:48:06 <dons> yeah, lispy, perhaps
23:48:09 <emu> > toRational $ logBase 10 1000
23:48:10 <lambdabot>  6755399441055743%2251799813685248
23:48:54 <lispy> dons: i'll try to get it all working on my lambdabot instance before i send the patches...they might get ugly :)
23:49:05 <glguy> is there a standard way to do this:  reverse . sort?
23:49:15 <glguy> like a sortBy reversecompare
23:49:16 <dons> lispy: yes. that sounds good
23:49:17 <lispy> ?pl reverse . sort
23:49:17 <lambdabot> reverse . sort
23:49:25 <glguy> or maybe (sortBy (flip compare))
23:51:41 <lispy> oh, actually i bet i could just write a cgi-wrapper in .hs which does a popen on lambdabot...yes, that's probably the right way to o this
23:52:15 * lispy has to think about it a bit more
23:52:16 <dons> ah yes. that's roughly what i was thinking
23:52:22 <dons> open up a pipe
23:52:26 <dons> and communicate over that
23:52:33 <lispy> but, a fast cgi program keesp running
23:52:33 <dons> possibly disabling certain plugins
23:52:44 <lispy> so does this really make sense?
23:52:50 <dons> right, you want to keep things running somehow
23:53:38 <lispy> oh right
23:53:40 <lispy> i've got it
23:53:47 <lispy> so in main, yo udo the popen
23:53:59 <lispy> and then you communicate in 'cgiMain' which gets called repeatedly
23:54:19 <sieni> "yo udo"? an accept fan?
23:54:31 <lispy> lol
23:54:47 * lispy has issues with the space bar :)
