00:05:41 <musasabi> What is the status of attributes in Gtk2hs ?
00:07:24 <musasabi> dcoutts: would it be possible to package the attribute stuff as a separate cabal package (so one could only depend on that).
00:08:17 * musasabi is trying to avoid copypasting a separate attribute implementation to yet an another project.
00:13:07 <dolio> > 10^10 :: Int
00:13:08 <lambdabot>  1410065408
00:15:43 <newsham> @hoogle FilePath -> FilePath -> FilePath
00:15:44 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
00:15:44 <lambdabot> Distribution.Compat.FilePath.joinPaths :: FilePath -> FilePath -> FilePath
00:17:28 <newsham> > joinPaths "foo" "bar"
00:17:28 <lambdabot>  Not in scope: `joinPaths'
00:25:56 <musasabi> Any good ideas how to traverse a graph with STM and "data NodeT v = NodeT v [Node]" "type Node = TVar NodeT"? (i.e. mark nodes as visited) ?
00:29:20 <dcoutts__> musasabi: note sure yet, we may yet change them a little
00:29:40 <dcoutts__> also, we try to remain as close to H98 as possible
00:29:56 <dcoutts__> so we have a better chance of building with yhc in future
00:31:16 <gour> dcoutts__: is jhc also gtk2hs' target?
00:32:36 <musasabi> dcoutts__: I am more interested in getting a common API rather than the finer "should we use :~> or ::=> for purpose X", so that multiple libraries would work in the same way.
00:32:40 <dcoutts__> gour: sure
00:33:07 <gour> dcoutts__: fine
00:33:10 <dcoutts__> musasabi: sure I'm not concerned with :~+> etc
00:33:34 <dcoutts__> musasabi: it's things like language extensions, and we may want to add more inforation into some of our attrs
00:34:07 <dcoutts__> for gtk2hs attrs we may want to add property names, if that'd
00:34:47 <dcoutts__> that'd work with the class based interface I think
00:34:47 <dcoutts__> though that's not what we currently use, we use a simpler one that doesn't use MPTC+FDs
00:35:16 <dcoutts__> oh and the FDs need fixing for ghc 6.6
00:36:54 <musasabi> yes. I don't think it is possible in pure H98.
00:37:33 <musasabi> or may be but not with the generalized things.
00:37:48 <dcoutts__> musasabi: indeed, we're already using exestential data types
00:39:02 <musasabi> hmm, I think one can live without them.
00:39:52 <musasabi> but the encoding would be more messy.
00:40:50 <dcoutts__> musasabi: any thoughts on how to fix the current code for 6.6 ?
00:41:42 <musasabi> let me look at how it fails.
00:44:40 <musasabi> dcoutts__: at least for hsgnutls attributes a simple type signature was enough to make things compile, now looking at gtk2hs.
00:50:34 <musasabi> And the hsgnutls ones are generalized over an arbitrary monad. Failed to build darcs gtk2hs (see #haskell-overflow for the error)
00:50:50 <dcoutts__> musasabi: the attrs in gtk2hs are ok, the code's different
00:52:29 <musasabi> ok. So which code has fundeps problems with 6.6?
00:53:35 <dcoutts__> musasabi: just the hsgnutls, what was the type sig you added?
00:54:37 <dons> I know Shellac breaks with the fundep changes
00:55:24 <dcoutts__> there were some others listed here too:
00:55:26 <dcoutts__> http://www.haskell.org/~gentoo/gentoo-haskell/projects/GHC-6.5-failures.html
00:55:29 <lambdabot> Title: Packages failing with GHC 6.5, http://tinyurl.com/jxo2e
01:31:13 <vincenz> Hello!
01:31:49 <bourbaki> hidiho
01:36:29 <wkh> does anyone have experience with using linux from windows using vmware player?
01:36:41 <wkh> i have to say i'm sick of windows but i still need to be able to view pr0n and play games
01:37:20 <vincenz> dons: I was demonstrating lambdabot's sexyness in #scheme yesterday, after protontorpedo came up (seems he's going there under different names for the last 1.5 years now)
01:37:39 <gene9> wkh: I have. it's slow.
01:38:10 <Syzygy-> wkh: You can view pr0n under linux without much problem...
01:38:19 <dons> vincenz: yes, he has been. at least 30 in this channel
01:38:24 <dons> for 10 months at lesat
01:38:31 <vincenz> dons: I wonder what motivates people to waste time like that
01:38:39 <vincenz> dons: btw, @check is super-drooly
01:38:46 <dons> :)
01:38:54 <dons> did you try that in #scheme too?
01:39:01 <Thomas2_> yeah, some people have too much free time.
01:39:01 <vincenz> dons: but I made something crash the other day, can't remember, I @tell'd you
01:39:02 <vincenz> dons: yeah!
01:39:12 <wkh> gene9: i'm getting one with xubuntu that's faster than gnome et al
01:39:23 <dons> yeah, you elicted a panic in 6.5 ghc. vincenz, but its fixed in latest ghc
01:39:24 <wkh> i mean it uses xfce which is faster than kde and certainly faster than gnome
01:39:29 <dons> hey Thomas2_
01:39:41 <vincenz> dons: cool, what waas it due to?
01:39:51 <dons> not sure. but it doesn't happen with recent ghc
01:40:28 <Thomas2_> dons: hey there.
01:40:50 <Thomas2_> for reference, my brother once amused himself for several hours logging on to enemy territory servers and dynamiting his team's spawn point
01:41:21 <vincenz> Thomas2_: that's not 1.5 years of trolling the same issue
01:41:22 <Thomas2_> and I frequently get games in warcraft that are given away by a player actively trying to sabotage his teammates.
01:41:42 <Thomas2_> well, I bet whoever it is isn't doing it themselves
01:42:06 <Thomas2_> they just have some script that randomly targets given locations or people from time to time
01:42:21 <Thomas2_> it's quite likely they've forgotten who all their targets are
01:43:22 <vincenz> nono
01:43:26 <vincenz> it was talking
01:43:29 <vincenz> asking inane questions
01:43:32 <vincenz> @proton
01:43:32 <lambdabot> oleg?
01:43:34 <vincenz> @proton
01:43:34 <lambdabot> are objects kina just subroutines
01:43:50 <Thomas2_> oh, not the guy whose bot just floods?
01:45:27 <dons> nope, bottom of this page http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
01:45:28 <lambdabot> http://tinyurl.com/mkqad
01:48:17 <wkh> i like coke better than pepsi because coke suppresses communist labor organizers in south america while pepsi does not
01:49:38 <Thomas2_> dons: nice, those all look genuine.
01:49:42 <Thomas2_> you have a bone fide fruitcake
01:50:18 <Syzygy-> Why does this give me ColorCube.hs:23:0: Parse error in pattern
01:50:33 <Syzygy-> cone2 x [y,z]:xs = (cone2 x [y,z]) ++ (cone2 x xs)
01:50:34 <Syzygy-> ?
01:51:27 <dcoutts__> you need ()'s
01:51:41 <dcoutts__> cone2 x ([y,z]:xs)
01:51:45 <Syzygy-> Ah.
01:51:59 <dcoutts__> and are you sure you didn't mean: cone2 x (y:z:xs)
01:52:17 <Syzygy-> Yeah, I probably do.
01:52:33 <dcoutts__> ([y,z]:xs) would mean a list of lists
01:53:14 <dcoutts__> Syzygy-: since the base pattern is (_:_), so ([_,_]:_) would be a list where the elements are also lists, ie a list of lists
01:53:35 <Syzygy-> Ah, right.
01:53:38 <Syzygy-> That makes sense.
01:53:45 <Cale> dons: <Keal> are there full body recognition files for sorting art?
01:53:58 <Syzygy-> Now, why does he seem to infer type [[a]] for xs in the call here:
01:54:00 <Syzygy-> simplices2 (x:xs) =( map (cone2 x) $ (completeGraphEdges xs)) ++ simplices2  xs
01:54:06 <dons> oh, where was that, Cale?
01:54:08 <Syzygy-> completeGraphEdges is [a] -> [a]
01:54:10 <Cale> in #math
01:54:22 <dons> recently?
01:54:25 <Cale> yeah
01:54:31 <dcoutts__> Syzygy-: because cone2 takes a list, so x must be a list
01:54:35 <Cale> He said that, and then:
01:54:36 <Syzygy-> And in the completeGraphEdges xs bit, the compiler expects [[a]] and infers [a]
01:54:39 <Cale> <Keal>  bb]
01:54:40 <Cale> <Keal> \
01:54:40 <Cale> <Keal> that was my cat
01:54:44 <vincenz> Cale: OH NO!
01:54:48 <vincenz> dons: Q:
01:54:50 <dons> yikes
01:54:52 <vincenz> keal == protontorpedo?
01:54:59 <dons> nope
01:55:08 <Syzygy-> dcoutts__: But cone2 is a -> [a] -> [a], so cone2 x should by ok with x an object of the list?
01:55:18 <Cale> vincenz: no, completely different kind of crazy :)
01:55:28 <Cale> @keal
01:55:28 <lambdabot> i need math friendly compiler to compile for jvm or flash
01:55:28 <dcoutts__> Syzygy-: oh, yes. hmm
01:55:34 <Cale> @keal
01:55:35 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
01:55:57 <dcoutts__> Syzygy-: the usual strategy here is to add type signatures, that'll help the compiler to pinpoint where the error is
01:55:58 <Syzygy-> So that cone2 x was supposed to be a partial evaluation, that I then map across... Oh. NOW I see!
01:56:14 <vincenz> Cale: Does quantum effects affect typing in HOL
01:56:17 <Syzygy-> That map shouldn't be there.
01:56:18 <dcoutts__> Syzygy-: partial application, partial evaluation is different :-)
01:56:56 <Syzygy-> Ah. Ok.
01:57:05 <Syzygy-> (what -is- the difference? *curious*)
01:57:10 <Syzygy-> dcoutts__ ++
01:57:24 <dcoutts__> partial evaluation is a program transformation/optimisation technique
01:58:14 <Cale> "can haskell pipe the raw irrational megaequation into an analog device"
01:58:39 <Cale> i only trust opensource tools. where can i download haskell for windows?"
01:58:42 <Cale> haha
01:58:52 <dcoutts__> Syzygy-: it's a good strategy to add type sigs when you get type errors, it makes you think about what the types really are, and after you've added what you think the types are the compiler will be able to tell you where you've been inconsistent in the types.
01:59:11 <Syzygy-> Ayup.-
02:00:01 <dcoutts__> Cale: ah that's a good one, only trust open source tools like a closed source OS
02:13:44 * edwardk waves ello.
02:14:02 <vincenz> Cale: LOL on the last one
02:20:28 * wkh is extracting his 1.7gb xubuntu vmware image
02:21:18 <vincenz> wkh: They have prebuilt images?
02:22:52 <wkh> i downloaded this: http://canned-os.blogspot.com/2006/08/xubuntu-6061-lts-vmware-virtual.html
02:22:55 <lambdabot> Title: The Canned OS Project: Xubuntu 6.06.1 LTS VMware Virtual Appliance, http://tinyurl.com/za2ub
02:23:51 <vincenz> Nice
02:25:27 <araujo> morning!
02:26:08 <vincenz> araujo: morning
02:27:23 <xerox> ?yow!
02:27:23 <lambdabot> Oh, I get it!!  "The BEACH goes on", huh, SONNY??
02:28:43 <Cale> You know you're a functional programmer when turning the timer back a bit on the toaster makes you think of calling a previously captured continuation.
02:29:42 <xerox> @slap Cale gently
02:29:42 * lambdabot beats up Cale gently
02:29:53 <vincenz> "beats up gently" *snickers*
02:29:58 <vincenz> talk about a contradiction inse
02:31:23 <mux> any people using darcs for *big* repositories?
02:31:32 <xerox> mux: dons
02:31:49 <dcoutts__> what counts as big?
02:31:50 <xerox> www.cse.unsw.edu.au/~dons/code/#haskell
02:32:13 <vincenz> Yeah what counts as big/
02:32:17 <vincenz> I have reasonably sized repos
02:32:31 <deadbeef> @check (\x -> x == x + 1 - 1)::Float
02:32:31 <lambdabot>    The lambda expression `\ x -> ...' has one arguments,     but its type `...
02:32:35 <mux> imagine the FreeBSD ports tree for instance
02:32:43 <deadbeef> @check (\x -> x == x + 1 - 1)
02:32:43 <lambdabot>  Add a type signature
02:32:48 <xerox> www.cse.unsw.edu.au/~dons/code/%23haskell that's probably it
02:32:55 <vincenz> @check \x -> (x :: Float) x == x + 1 - 1
02:32:56 <lambdabot>    The function `(x :: Float)' is applied to one arguments,     but its typ...
02:33:00 <vincenz> @check \x -> (x :: Float)  == x + 1 - 1
02:33:01 <lambdabot>  Falsifiable, after 6 tests: 0.6666667
02:33:03 <psnl> mux: isn't there a darcs repo of the linux kernel?
02:33:07 <vincenz> NICE
02:33:18 <dons> that's some 500M , the #haskell repo :)
02:33:29 <dons> nice vincenz .
02:33:38 <psnl> mux: http://darcs.net/linux.html
02:33:40 <lambdabot> Title: Linux kernel darcs repository
02:34:00 <xerox> @check \x -> (x::Int) == x + 1 - 1
02:34:01 <lambdabot>  OK, passed 500 tests.
02:34:49 <mux> psnl: well, the reason I'm asking this is that there is a huge discussion on the FreeBSD mailing lists to change the VCS
02:34:59 <vincenz> dons: try doing that with a dyn-typed language
02:35:10 <vincenz> @check \x -> (x :: Fractional)  == x + 1 - 1
02:35:10 <lambdabot>    Class `Fractional' used as a type     In the type `Fractional',     In a...
02:35:11 <mux> people have mentioned darcs, but they have also said that darcs isn't fast enough yet, giving as a proof that it can't handle the Linux kernel
02:35:14 <vincenz> hmm
02:35:24 <vincenz> @list-classes Fractional
02:35:25 <mux> and the ports tree repository, is several times bigger
02:35:25 <lambdabot> Unknown command, try @list
02:35:32 <xerox> @instances Fractional
02:35:33 <vincenz> @instances Fractional
02:35:33 <lambdabot> Double, Float
02:35:34 <lambdabot> Double, Float
02:35:40 <vincenz> hmm
02:35:40 <mux> dozens of thousands of files and directories
02:35:45 <vincenz> What about the 1/2 one then?
02:35:52 <xerox> Rational ?
02:35:53 <vincenz> @check \x -> (x :: Doubl)  == x + 1 - 1
02:35:53 <lambdabot>  Not in scope: type constructor or class `Doubl'
02:35:55 <vincenz> @check \x -> (x :: Double)  == x + 1 - 1
02:35:56 <lambdabot>  Falsifiable, after 14 tests: 7.857142857142857
02:36:03 <vincenz> @instances Rational
02:36:04 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
02:36:05 <psnl> mux: I would have thought svn would work for the freeBSD style of doing things, where you want a centralized repo system
02:36:09 <xerox> Rational is a data type
02:36:10 <vincenz> @check \x -> (x :: Rational)  == x + 1 - 1
02:36:11 <lambdabot>  add an instance declaration for (Arbitrary (Ratio Integer))     In the defi...
02:36:17 <vincenz> oy
02:36:19 <mux> we actually don't want a centralized repo but a distributed one
02:36:20 <xerox> Ack!
02:36:30 <vincenz> Someone in ghc needs to fix that
02:37:03 <mux> I haven't used darcs enough to confirm or infirm the claims about darcs' speed
02:37:09 <psnl> mux: ooh, I'll have to find and read the thread
02:37:18 <mux> psnl: it's on developers@ :-P
02:37:34 <mux> well, there's another one in the public ML I think, but this one isn't interesting
02:37:38 <wkh> drum n bass, innit
02:38:37 <araujo> morning vincenz :-)
02:38:40 <araujo> @yarr!
02:38:41 <lambdabot> Yarrr!
02:40:46 <mux> Mercurial/Hg seems nice
02:48:05 <vincenz> Hot off the press and definitely requiring comments: http://notvincenz.blogspot.com/2006/09/organizing-information.html
02:48:08 <lambdabot> Title: lambda.oasis: Organizing information, http://tinyurl.com/e5hv4
02:48:36 <fasta> Is it better to newtype a type isomorphic to Maybe, or just use Maybe?
02:51:16 <edwardk> fasta: in general its clearer to use Maybe
02:51:23 <wkh> vincenz: let me type up my thoughts on your post. one sec
02:51:32 <edwardk> fasta: everyone knows its properties and stuff is built into the prelude for it
02:51:56 <edwardk> unless you think you might extend it with another case or something
02:52:16 <xerox> That would not be isomorphic
02:52:46 <edwardk> yeah in the truest sense, but something that is isomorphic now, later on while refactoring may not be =)
02:52:46 <fasta> xerox: well, it could be isomorphic at some point in time, and later one could have a new insight and think otherwise.
02:53:03 <xerox> Meaningful names are also welcome
02:55:44 <wkh> vincenz: i proposed an automated way to keep track of your papers :)
02:56:54 <vincenz> wkh: :)
02:57:17 <vincenz> wkh: it presupposes the ability to read .pds
02:57:26 <edwardk> wkh: heh i need one of those. i'm buried in them here =)
02:57:30 <vincenz> And I still think that an orthogonal tag system is necessary to properly categorize papers
02:58:40 <edwardk> Currently I print them out clip them if they have an obvious main topic I sort them into that pile and I throw a sheet of paper into the other piles saying where its sorted and its name if it also covers stuff related to that pile. Poor man's tagging system ;)
02:58:57 <edwardk> I probably should use CiteULike more
02:58:58 <wkh> vincenz: text extraction from PDFs is probably doable :/
02:59:33 <edwardk> vincenz: have you see citeulike?
03:01:36 <vincenz> edwardk: not yet
03:01:47 <edwardk> vincenz: take a look. serves the purpose rather well
03:02:43 * vincenz ndos
03:02:55 <vincenz> Feel free to put it as a comment for all to read :)
03:03:05 <profmakx> @version
03:03:05 <lambdabot> lambdabot 4p179, GHC 6.5 (OpenBSD i386 )
03:03:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:03:08 <xerox> wkh: it's doable only if the pdf isn't a series of images, or not encrypted, I think
03:04:10 <wkh> ok. make the algorithm: if it isn't a wonky binary format, get the text; otherwise prompt the user for tags/keywords
03:04:10 <wkh> :P
03:04:51 <vincenz> It's also just the general management of files, basically the tool would serve to remove all hassle
03:06:36 <wkh> hm, there was a guy who wrote something using PLT Scheme for something like this...
03:06:38 <wkh> one sec
03:07:38 <wkh> http://jay.makeoutcity.com/#yppdb meh
03:12:37 <wkh> if you're going to make an organizational app
03:12:46 <wkh> focus on making it very very simple. like drop-dead braindead simple
03:12:58 <wkh> otherwise the tool will add more complexity to your life rather than subtracting it :)
03:16:32 <dblhelix> @hoogle unfoldr
03:16:32 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
03:16:32 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
03:16:42 <dblhelix> @hoogle unfold
03:16:42 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
03:16:43 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
03:16:43 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
03:16:50 <dblhelix> @hoogle fold
03:16:51 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
03:16:51 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
03:16:51 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
03:24:03 <beelsebob> @type interleave
03:24:04 <lambdabot> Not in scope: `interleave'
03:24:10 <beelsebob> @type intersperse
03:24:11 <lambdabot> forall a. a -> [a] -> [a]
03:30:32 <dblhelix> @pl \(x, y) -> liftM2 (:) x (ana y)
03:30:32 <lambdabot> uncurry ((. ana) . liftM2 (:))
03:33:26 <SamB> @type \f g x -> f (g x)
03:33:27 <lambdabot> forall t t1 t2. (t -> t2) -> (t1 -> t) -> t1 -> t2
03:34:01 <SamB> @pl \f g x -> f (g x)
03:34:01 <lambdabot> (.)
03:34:10 <SamB> @pl \f g x y -> f (g x y)
03:34:10 <lambdabot> (.) . (.)
03:34:15 <SamB> @pl \f g x y z -> f (g x y z)
03:34:16 <lambdabot> (.) . (.) . (.)
03:38:52 <Cale> dons: around?
03:41:57 <dons> yep
03:43:33 <Cale> dons: any idea why lambdabot might just silently die while loading the seen module?
03:43:58 <dons> yes, the state format changed, and we don't catch that. remove State/seen
03:44:03 <dons> I'll fix that now
03:44:04 <Cale> aha
03:49:22 <dons> Cale, are there logs of #math? I'd be interested to see how the bot is used.
03:49:45 <Cale> I think so...
03:50:14 <Cale> http://www.irclogs.net/freenode/math/
03:50:18 <dons> cheers
03:50:32 <lambdabot> Title: IRC Logs @ #math on freenode
03:53:18 * SamB would really like to see some kind of framework for serialization that allows for smooth updates on format changes...
03:54:01 <dons> we probably should write versioning functions, and tag module versions in the state, if we were serious about doing this
03:54:19 <dons> semi-eternal-compatibiity-in-theory
03:56:11 <dons> i wonder if the HAppS guys have looked at this. I seem to recall musasabi talking about it
04:08:14 <NamelessOne> A newb quesition, I've defined some data types such as
04:08:15 <NamelessOne> data MyTree a = ...
04:08:15 <NamelessOne> data MySet a = ...
04:08:15 <NamelessOne> now I want to define a Collection class for them
04:08:15 <NamelessOne> class Collection ? where
04:08:15 <NamelessOne>   singleton :: ? -> ? -- as for MyTree it should be:  a -> MyTree a
04:08:17 <NamelessOne>   add :: ? -> ? -> ?  -- as for MyTree it should be:  a -> MyTree a -> MyTree a
04:08:19 <NamelessOne> I can't figure out how the "?" part should be...
04:10:49 <wilx|wrk> class Collection col....singleton :: a -> col?
04:10:58 <wilx|wrk> And then instances for each different type...
04:11:12 <wilx|wrk> I bet there are many tutorials that teach how to use classes and instances.
04:12:01 <SamB> wilx: huh?
04:12:36 * wkh echoes SamB's sentiments
04:12:41 <SamB> that ain't gonna work...
04:13:10 <dons> NamelessOne: have a look at existing collection types, e.g.
04:13:11 <dons> class  Functor f  where
04:13:11 <dons>     fmap        :: (a -> b) -> f a -> f b
04:13:32 <dons> your collection class looks a bit like a monoid, e.g.
04:13:45 <dons> class Monoid a where
04:13:45 <dons>     mempty  :: a
04:13:45 <dons>     -- ^ Identity of 'mappend'
04:13:45 <dons>     mappend :: a -> a -> a
04:13:45 <dons>     -- ^ An associative operation
04:13:48 <dons>     mconcat :: [a] -> a
04:14:08 <dons> maybe it is a Monoid :)
04:14:12 <dons> ?docs Data.Monoid
04:14:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
04:16:25 <NamelessOne> dons: thanks
04:29:49 <vincenz> How do you change your ircname
04:29:51 <wkh> dons: your bytestring thing is totally mega-awesome
04:29:59 <wkh> vincenz: /nick new-nickname-you-want
04:30:04 <vincenz> nono
04:30:08 <vincenz> ircname
04:30:19 <Cale> vincenz: reconnect with a different one
04:30:24 <wkh> :/
04:30:34 <vincenz> Not nickname, the name in your whois field
04:30:48 * JKnecht seems to recall it being set with an env var
04:30:56 <Cale> How to change that would generally be client-dependent
04:31:36 <Cale> iirc, it's one of the fields in the USER command to the irc server which is sent when your client connects
04:31:42 <vincenz> ah
04:31:54 <JKnecht> i lost mine (juan@acm.org) when I dumped my external server with a static ip.
04:32:35 <vincenz> no not that field
04:32:54 <vincenz> The second line in /w/hois
04:33:00 <dons> wkh, hehe thanks :)
04:34:46 <bourbaki> dons did you receive the mail yet?
04:39:15 <hygge> The language of choice for discriminating hackers - What does that mean? ;P
04:40:55 <xerox> That the language is a separator in the category of Hackers?
04:41:06 <boliver> hygge: see this
04:41:09 <hygge> :)
04:41:10 <boliver> http://icfpc.plt-scheme.org
04:41:12 <lambdabot> Title: ICFP 2005 Contest
04:42:06 <hygge> xerox, you mean, either you love it or hate it* (*haskell) ?
04:42:18 <xerox> I was trying a category theoretic approach to the question.
04:43:07 <boliver> xerox: are the objects programs and the arrows Hackers:)?
04:45:14 <dcoutts__> boliver: hmm, so the functors would be?
04:45:44 <boliver> humm, good question
04:46:21 <gds> I think they might be management or somesuch...
04:46:33 <gds> (as in "pointy haired" management)
04:47:02 <dcoutts__> heh
04:52:55 <JKnecht> in irssi /set real_name sets IRCNAME
04:53:14 <JKnecht> but looks like you have to bounce the session
04:55:40 <vincenz> JKnecht: thx
04:55:52 <vincenz> Seems not to have worked tho
04:55:53 <vincenz> o.O
04:55:55 <vincenz> Anywho
04:56:39 <JKnecht> you should see it having worked for me if do a who on my nick
04:56:50 <vincenz> Well I did it
04:56:53 <vincenz> and then a /reconnect
04:56:57 <vincenz> so perhaps I have to restart irssi
04:57:31 <JKnecht> yeah somebody in irssi said that would work but I had to bounce irssi
04:58:04 <JKnecht> (didn't work with 2 diff irc nets)
05:00:37 <sieni> what?
05:05:23 <JKnecht> vincenz: worked now, huh?
05:05:59 <vincenz> Jup :)
05:06:18 <vincenz> Though it's not choosing my hostname like I want it to o.O
05:06:50 <JKnecht> yeah, I could only get that by having a static ip.
05:23:45 <JKnecht> vincenz: angelos in #irssi advises you have to disconnect/connect, reconnect not enuf.
05:23:56 * vincenz nods
05:23:57 <vincenz> thx :)
05:31:17 <Pupeno> I am trying to build haskell-fastcgi, but it complaints: Setup.hs: cannot satisfy dependency cgi>=2006.8.29. I have installed the lattest cgi-compat, what else am I missing ?
05:31:32 <xerox> cgi-compat?
05:31:39 <xerox> I think you need cgi from bringert's site.
05:32:11 <Pupeno> I thought that was cgi-compat.
05:32:26 <dcoutts__> Pupeno: if it asks for cgi then it needs cgi, it's looking for the exact name
05:32:51 <dcoutts__> you might be able to get it to use -compat, but you're on your own there
05:33:11 <Pupeno> and where do I get "cgi" from ?
05:35:18 <xerox> cabal-install :D
05:35:25 <deadbeef> :D
05:35:48 <Pupeno> xerox: what's that ?
05:35:56 <xerox> wget http://hacakge.haskell.org/~paolo/darcs/cabal-install/test-cabal-install && chmod 755 test-cabal-install && ./test-cabal-install
05:35:58 <lambdabot> http://tinyurl.com/h7uzv
05:36:07 <xerox> cabal-install install cgi
05:39:04 <xerox> Or even just darcs get it and install it
05:39:17 <xerox> then cabal-install update and cabal-install install cgi
05:39:48 * Pupeno would just like to know where cgi is.
05:40:04 <xerox> bringert's site
05:40:15 <xerox> @google bringert
05:40:18 <lambdabot> http://www.cs.chalmers.se/~bringert/
05:40:19 <lambdabot> Title: Bj&ouml;rn Bringert
05:47:47 <dons> Pupeno: I think you can just rename cgi to cgi-compat, and things will work
05:49:21 <Pupeno> dons: thanks.
06:00:32 <Pupeno> it failed to build: FastCGI.hsc:48:21: error: fcgiapp.h: No such file or directory
06:00:54 <dons> you need to install the fastcgi C library
06:01:01 <dons> check the haskell-fastcgi readme
06:01:05 <mux> fcgi-2.4.0
06:01:10 <dons> (probably its in your package system)
06:01:30 * mux just had to install mod_fastcgi and fcgi on one of his systems for a website written with ruby on rails
06:08:00 <clanehin> ghc complains that module X is imported, but nothing from it is used, but then if I comment out X, it complains about symbols not being in scope; what does this mean "except perhaps instances visible in 'module X'" --- the module is System.Time
06:09:03 <dcoutts__> dons: you not going to icfp either?
06:17:59 <dons> nope
06:21:06 <mux> where is ICFP this year?
06:21:22 <boliver> Portland
06:21:23 <mux> ?google ICFP06
06:21:28 <lambdabot> http://icfp06.cs.uchicago.edu/
06:21:28 <lambdabot> Title: 11th ACM SIGPLAN International Conference on Functional Programming (ICFP 2006)
06:21:32 <mux> oh
06:21:37 <mux> a bit far for me
06:21:48 <mux> too bad I wasn't in functional languages when there was the ICFP in Paris
06:22:33 <wkh> it's amazing how much more vibrant the community is for haskell than for common lisp :/
06:24:51 <dons> @tell ndm I note hoogle links to the old wiki for keyword searches. i've updated the new wiki keyword page though. perhaps you'd like to change which wiki hoogle points to?
06:24:52 <lambdabot> Consider it noted.
06:29:28 <Philippa> wkh: I think scheme'd probably be a fairer comparison
06:29:51 <Philippa> there's no particular reason to expect new things out of common lisp
06:30:18 <vincenz> Philippa: I wish scheme would pick up a bit
06:30:40 <vincenz> Philippa: I think both static an dyn typed languages have their place :)
06:30:45 * Philippa nods
06:30:55 <vincenz> BTW
06:30:59 <\z> what about termite?  and r6rs?
06:31:11 <vincenz> what should I get? xbox 360, ps2 or wait for ps 3?
06:31:18 <vincenz> \z: I meant community wise, the channel is often silent
06:31:20 <Philippa> depends on a lot
06:31:24 <\z> ah
06:32:01 <Philippa> the ps2's got a fair amount of stuff available for it, and it's cheap. The 360's shiny, the PS3's getting delayed muchly, going to be horribly expensive on launch and is running a serious risk of flopping in the marketplace
06:32:16 <gds> vincenz: a wii :):)
06:32:19 <vincenz> alright so it's a tossup between xbox and ps2
06:32:21 <vincenz> gds: what's a wii
06:32:28 <agentzh> is there a builtin to convert a list to a tuple?
06:32:29 <vincenz> sound like a wireless access protocol
06:32:31 <gds> The nintendo one with the cool controler :)
06:32:43 <Philippa> agentzh: no, it wouldn't be typeable
06:32:55 <agentzh> Philippa: okay, thanks
06:33:04 <gds> vincenz: http://media.games.ign.com/articles/693/693580/vid_1657122.html
06:33:07 <lambdabot> Title: IGN: IGN Weekly Video 1657122, http://tinyurl.com/znvkv
06:33:10 <vincenz> Philippa: be careful, oleg might hear you and prove you wrong
06:33:14 <Philippa> you can write a family of functions to convert lists to tuples of size n...
06:33:23 <vincenz> nintendo tends to be too cartoony
06:33:24 <vincenz> besides
06:33:30 <vincenz> my brother had the 64 and it sucked
06:33:39 <vincenz> gds: don't have the latest flash (linux)
06:33:45 <Philippa> it's not /usefully/ typeable. You won't know the size of the tuple until run-time...
06:33:45 <gds> Take a look at the Red Faction bit of that video before leveling the "cartoony" line ;)
06:33:56 <gds> Ah - I have that prob too :/
06:34:02 <agentzh> Philippa: yes, of course. :)
06:34:29 <Philippa> the 64 had some pretty specific problems. The Wii's not trying to compete with the 360 and the PS3 for sheer graphical power, mind - it's all about the controller
06:34:31 <gds> vincenz: Well, I was a sega boy back in the day, then ps1 and 2, and now I'm waiting for the wii.
06:34:54 <vincenz> wiiii
06:34:58 <gds> (if that helps you to place it culturally)
06:36:07 <vincenz> my main reason for xbox360 is oblivion
06:36:16 <vincenz> I have the pc version and a laptop...go figure
06:37:22 <Philippa> yeah, I need to see more titles before I really think about buying any of the next generation
06:37:36 <vincenz> then again, tekken is a reason for ps2
06:37:41 <Philippa> though I'm curious as to whether the PS3'll be region-free for PS1 and PS2 titles
06:37:41 <Philippa> heh
06:38:22 <gds> lol
06:38:35 <kpreid> Philippa: you could write a typeclass and convert a runtime-length-checked list into a fixed size tuple
06:38:44 <kpreid> that seems not-implausible-to-be-useful
06:39:08 <gds> Well, I got a DS and Animal Crossing a couple of months ago, and now everyone in my house, and most of my local friends have one too...
06:39:12 <Philippa> then you need a pile of instances
06:39:31 <Philippa> and you get barely anything of use compared to just using a case statement
06:39:39 <kpreid> sure, same as for anything else on tuples
06:41:57 <vincenz> I doubt you can have different instances for different lenghts
06:42:22 <Philippa> sure you can, you're dispatching on the result type ala read
06:42:36 <Philippa> looking at that wii video I can't help thinking it's a serious invitation to RSI if you play a lot...
06:45:12 <gds> Philippa: Really? More so than a standard controler? I was thinking the opposite - but then I don't have RSI...
06:46:00 <dolio> > ap (,) (+1) 2
06:46:01 <lambdabot>  (2,3)
06:46:09 <dolio> > liftM2 (,) id (+1) 2
06:46:10 <lambdabot>  (2,3)
06:46:40 <Philippa> a standard controller you don't need to hold in the air for a long session
06:46:45 <Philippa> the hand split bit's good, granted
06:46:55 <gds> Hm.
06:47:12 <gds> I've never played with a standard controler without holding it in the air...
06:47:25 <gds> But then I may be misunderstanding "hold in the air"...
06:47:43 <Philippa> if your arms're going a bit you can just rest it in your lap
06:48:00 <gds> Ah - I've never got to that stage.
06:48:37 <gds> I figured that motion-sensing would allow us to take some of the complexity out of button combinations and put it into more natural gestures...
06:48:42 <Philippa> there's a bit of strain on the wrists if you need to have access to the whole pad all the time (say, if you're playing a fighter), but for something like an RPG where you can mostly let your hand relax helps
06:48:47 <gds> and so reduce unnatural movements, and hence RSI...
06:48:53 <Philippa> yeah, but the problem's not my thumbs
06:48:56 <gds> But that's just a vague theory at a distance..
06:49:00 <gds> I see :)
06:49:18 <Philippa> wrists and arms're what take most of the damage in front of a computer, for example
06:49:56 <gds> My Dad's gettiing arthiritis in his thumbs, so I guess I'm thinking more from that standpoint...
06:50:20 <gds> He can't play playstation stuff anymore - but the touch screen on the DS is still cool.
06:50:24 <vincenz> Philippa: know any good rpg titles?
06:50:26 * Philippa nods
06:50:50 <Philippa> vincenz: um, not lately. Been playing Nippon Ichi's strat-RPGs, which're fun but hard to get hold of a few months after launch
06:51:14 <Philippa> (La Pucelle Tactics, Disgaea, Phantom Brave, Makai Kingdom - Disgaea 2's due out soon, they're on PS2)
06:51:24 <vincenz> what are they like?
06:51:41 <Philippa> have you seen either of the Final Fantasy Tactics games?
06:51:46 <vincenz> hmm
06:51:52 <vincenz> I've seen final fantasy 7?
06:52:01 <Philippa> yeah, not the same
06:52:17 <Philippa> okay, think turn-based tactical combat plus RPG trappings over a campaign system
06:52:34 <vincenz> so it's inherently multiplayer
06:52:35 <mux> vincenz: ToME
06:52:37 <Philippa> no
06:52:42 <vincenz> tome?
06:52:43 <Philippa> it *would* be if it was done that way...
06:52:45 <mux> if you don't mind text-based rogue like games :-)
06:52:51 <mux> ToME rocks
06:52:52 <Philippa> (compare and contrast with the X-Com games, I guess)
06:52:57 <mux> it's one of the numerous angband derivatives
06:53:03 <mux> www.t-o-m-e.net
06:53:05 <vincenz> Philippa: ah :)
06:53:40 <vincenz> mux: neat
06:53:41 <Cale> vincenz: basically, think of it as if you turned Final Fantasy into a drug, and then you fed that to Chess.
06:53:45 <vincenz> mux: platform?
06:53:53 <ValarQ> ToME is great :)
06:53:56 <Philippa> much of the combat system's lighter weight than X-Com, and there's a lot less emphasis on range, whereas there's a lot more of the kind of attacks you'd see in something like Final Fantasy
06:54:08 * vincenz nodnods
06:54:15 <mux> vincenz: unix, windows, etc
06:54:26 <Philippa> Cale: then, if we're talking NI's games, add a capacity for levelling and powergaming that shames anything Square's ever done...
06:54:28 <vincenz> mux: so tome is good?
06:54:34 <mux> ValarQ: uhoh, I think know the meaning of your nick now :-P
06:54:38 <mux> vincenz: I like it a lot
06:54:45 <vincenz> mux: I always fear that games based on public novels are lame cause they'll just use the publicity of the book
06:54:55 <bourbaki> NI?
06:55:01 <ValarQ> mux: :)
06:55:03 <Philippa> the max level in Disgaea's 9999, but a 'basic' character levelled that high with the biggest sword you can buy won't be able to scratch the last boss in the post-game and probably not the second-to-last either
06:55:06 <mux> ToME has *thousands* of different objects/artefacts
06:55:13 <Philippa> bourbaki: Nippon Iche
06:55:15 <Philippa> Ichi, even
06:55:17 <bourbaki> ah
06:55:18 <mux> same for monsters and uniques
06:55:35 <mux> it's very Tolkien-ish, which I like too
06:55:40 <vincenz> Philippa: so lots of customisability
06:55:43 <Philippa> you don't need the crazy levelling to complete the plot, though
06:55:54 <vincenz> mux: yeah I like tolkien, just fear that games based on it will be lame, games based on books tend to be
06:55:55 <ValarQ> the only drawback with ToME is that it doesn't seem to work on my new cpu arch :(
06:55:58 <Philippa> which is good, because even nailing the second-to-last boss took me to 100 hours on the clock...
06:56:10 <mux> vincenz: not this one - at least in my opinion :-)
06:56:16 <vincenz> :)
06:56:19 <vincenz> mux: thanks for the suggestion!
06:56:23 <mux> yw
06:56:45 <vincenz> mux: so like nethack but better
06:57:10 <mux> much, much more complex
06:57:22 <mux> I used to play nethack, finished it once, but now I'm bored by it
06:58:02 <bourbaki> does anyone of you know a game that i can play on pc making good use of a gamepad? especially of the xbox360?
06:58:25 <vincenz> mux: I haven't finished nethack at all, but I still find it boring
06:59:12 <Philippa> you could grab a console or arcade emulator?
06:59:41 <bourbaki> Philippa hm maybe but then i wouldnt have all the cool features of the xbox game pad would i?
06:59:56 <Philippa> nope
07:00:19 <bourbaki> i have searched for some top down scrollers but they are as good as dead
07:04:07 <Philippa> There're a few Japanese titles, I think
07:04:28 <bourbaki> oh for the pc as well?
07:04:41 <Philippa> ah, point. For the PC you're looking at the open source crowd
07:04:46 <Philippa> anyway, I should go shower
07:04:46 <bourbaki> yep
07:05:11 <bourbaki> codemages.sf.net/brane.rar thats the start of my own non linear top down scroller :)
07:07:09 <vincenz> bourbaki: ?
07:07:12 <mux> vincenz: if you're into angband like games, check out http://oook.angband.cz/
07:07:27 <vincenz> never tried angband
07:07:30 * vincenz mutters at his laptop keyboard
07:11:31 <vincenz> mux: that site ain't working
07:12:00 <mux> oops, sorry, it's angband.oook.cze
07:12:02 <mux> -e
07:12:06 <mux> not the other way around
07:12:07 <dons> ?yow!
07:12:08 <lambdabot> Is this going to involve RAW human ecstasy?
07:13:49 <mux> > sum (take 10000 (L.zeta (4 :+ 0)))
07:13:50 <lambdabot>  1.082323233710861 :+ 0.0
07:13:59 <mux> > sum (take 100000 (L.zeta (4 :+ 0)))
07:14:01 <lambdabot>  1.082323233710861 :+ 0.0
07:14:11 <mux> cool
07:14:59 <dons> hey, ralf lammel has a blog, and it's not on planet haskell?
07:15:02 <dons> ibid, http://blogs.msdn.com/ralflammel/
07:15:05 <lambdabot> Title: Grammarware, Haskellware, XMLware
07:16:11 <dcoutts__> cool
07:16:27 <dcoutts__> btw have you beeing paying attention to the new ghc commentary
07:16:37 <dcoutts__> it's been expanding rapidly in recent days
07:16:43 <dons> oh, hmm. haven't seen that
07:16:48 <dcoutts__> http://hackage.haskell.org/trac/ghc/wiki/Commentary
07:16:52 <lambdabot> Title: Commentary - GHC - Trac, http://tinyurl.com/ocuyo
07:17:00 <dons> ?remember ralflammel I am confident about my admiration for Haskell
07:17:09 <dcoutts__> Simon & Simon have been updating it for the hackathon
07:17:12 <dons> i need a rss feed for the wiki
07:17:32 <dons> oh, lots of fun new things
07:17:36 <dcoutts__> yep
07:17:42 <dcoutts__> yes, rss would be good
07:17:52 <dons> i added a section on rewrite rules
07:17:57 <dons> maybe you'd like to take a peek at that
07:18:02 <dcoutts__> oh, where ?
07:18:13 <dons> though hmm, not the above wiki
07:18:37 <dons> http://haskell.org/haskellwiki/GHC/Using_Rules
07:18:39 <lambdabot> Title: GHC/Using Rules - HaskellWiki, http://tinyurl.com/z26ev
07:18:43 <dcoutts__> the ghc wiki is for hacking on ghc, not using it
07:18:44 <d04jk> is it possible to make zip create a list as long as the longest of the two list's you are zipping?
07:18:53 <dcoutts__> dons:  so you've probably put it in the right place
07:19:04 <dons> yep. i notice roman's put up a little bit on the rules stuff too,on the ghc wiki
07:19:17 <dons> d04jk: if you extend the shorter list
07:19:27 <dons> i.e. by adding some default value to the end
07:19:41 <d04jk> dons,  do you know an easy way to extend a list "in the middle" of it
07:19:54 <dcoutts__> split & join
07:19:55 <d04jk> i.e. neither in the begining nor the end
07:23:21 <ibid> dons: you know the drill :)
07:23:34 <dons> hmm, I do what? contact ralf and get him to mail you?
07:23:55 <ibid> or otherwise communicate permission
07:24:00 <ibid> (such as a blog post)
07:24:28 <ibid> dons: which you'll need to point out to me if he does that ;)
07:24:33 <dons> ok. /me writes a little mail to ralf
07:24:43 <ibid> but bus time, bbl
07:25:29 <vincenz> mux: holy cow
07:25:36 <vincenz> mux: if I start tome it launches 9 terminls
07:27:46 <petekaz> dons: what is the point of the tiny url in the url-title plugin?
07:28:05 <petekaz> It doesn't make any sense to me.
07:28:25 <dons> makes copy-n-paste easier
07:28:28 <dons> esp. for really long urls
07:28:55 <dons> i understand that some people use clients from which they can directly click on links, so such people don't care/wonder what the point is :)
07:29:16 <petekaz> I see.
07:30:02 <dons> e.g. http://groups.google.com/group/comp.lang.functional/browse_thread/thread/d19a4fa9084851eb/a5cc6ac1df70e358?lnk=gst&q=%22Haskell+Report%22&rnum=4#a5cc6ac1df70e358
07:30:04 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/lrhqc
07:30:11 <dons> note so much fun to cut
07:30:15 <dons> s/e//
07:30:45 <mux> vincenz: try it with tome -mgcu -- -b
07:33:10 <musasabi> Is there a reason why there is no Ord for StableNames?
07:36:08 <dons> hmm "APP Design, Inc. released a pre-alpha code set for the Prelude project. The goal is to enable Ruby programmers to use higher-order functions, monads, infinite lists, and other Haskell features."
07:36:33 <dons> http://rubyforge.org/projects/prelude
07:36:34 <lambdabot> Title: RubyForge: Prelude Library: Project Info
07:36:35 <dons> crikey!
07:36:36 <xerox> Does it ship with ghc?
07:38:54 <\z> the project page says "Development Status: 2 - Pre-Alpha"
07:39:49 <dons> what's status 1 ?
07:40:15 <dons> "Development Status: 1 - A Twinkle in the Author's Eye"?
07:40:36 <dons> ?seen kowey
07:40:36 <lambdabot> kowey is in #haskell and #darcs. I last heard kowey speak 5h 50m 31s ago.
07:40:51 <dons> kowey: we should get your blog on planet haskell!
07:41:40 <kowey> dons: koweycode?
07:41:40 <dons> kowey, just let ibid know, and hand him the rss url.
07:41:44 <dons> yep
07:41:53 <dons> pretty please :)
07:42:04 <kowey> dons: ok
07:42:06 * dons wants to read more darcs+haskell articles :)
07:42:20 * kowey now has to be extra careful about blathering on mindlessly
07:42:27 <dons> ibid: ^^ more feeds for you http://koweycode.blogspot.com/
07:42:29 <lambdabot> Title: koweycode
07:42:31 <ikegami--> Status 1 - Planning
07:42:32 <dons> kowey++
07:43:10 <dons> kowey: heh. it can be mindless, as long as it type checks :)
07:43:30 <kowey> mmm... static typechecking of blog matter
07:43:56 <dons> tasty!
07:44:03 <Pupeno> Today is programmer's day, happy day! http://en.wikipedia.org/wiki/Programmer's_day
07:44:21 <dons> kowey: btw, does lambdabot get much exercise in #darcs?
07:44:47 <\z> dons: the ruby prelude looks like a nice idea, but not fully there yet
07:44:55 <\z> a not-so-representative sample:
07:44:56 <\z> #   class Maybe < Monad
07:44:56 <\z> #     # maybe       -- :: b -> (a -> b) -> Maybe a -> b
07:44:56 <\z> #     def maybe
07:44:56 <\z> #       warn "Method 'maybe' is not implemented yet." if $VERBOSE
07:44:56 <\z> #       return []
07:44:58 <\z> #     end
07:44:59 <kowey> not very much, though she is quite helpful with the urls
07:45:12 <kowey> localtime is handy for setting meetings
07:45:20 <dons> we've even got quickcheck these days
07:45:34 <dons> ?check \s -> s == (reverse .reverse) (s :: [Int])
07:45:35 <lambdabot>  OK, passed 500 tests.
07:45:58 <dons> \z, scary.
07:46:02 <kowey> people seem impressed though; we get the occasional 'cool bot!'
07:46:12 <dons> nice
07:46:22 * mux wonders how to tell quickcheck to try to verify the RH with the zeta function he defined in lambdabot
07:46:29 <dcoutts__> dons:
07:46:31 <dcoutts__> > length "ยง"
07:46:32 <lambdabot>  2
07:46:34 <dcoutts__> :-)
07:46:35 <mux> ?check that riemann was right
07:46:36 <lambdabot>  Not in scope: `was'
07:46:49 <dcoutts__> don't you just hate string encodings
07:46:54 <dons> dcoutts__: ? /me sees funny ascii
07:47:45 <dcoutts__> > "ยง"
07:47:46 <lambdabot>  "\194\167"
07:48:02 <dolio> > L.zeta 2
07:48:04 <lambdabot>  [1.0 :+ -0.0,0.25 :+ -0.0,0.11111111111111109 :+ -0.0,6.25e-2 :+ -0.0,4.0000...
07:48:09 <dcoutts__> dons: your irc client doesn't do utf8?
07:48:20 <ikegami--> because many small points satisfy the RH Hypothesis, I guess QuickCheck fails to find the counterexample
07:48:28 <mux> dolio: it's the infinite list of the terms of the zeta function, you need to sum them
07:48:30 <dons> 8 bits forever!
07:48:56 <dons> yeah, i'm sure there's a way to kick irssi+rxvt into unicode, but .. lazy functional programmer..
07:49:34 <dons> ?seen kpreid
07:49:34 <lambdabot> kpreid is in #haskell. I last heard kpreid speak 1h 9m 55s ago.
07:49:37 <dcoutts__> dons: it's the single char '\167' in ISO-8859-1
07:49:45 <dons> ah
07:49:49 <kpreid> hmmm?
07:49:55 <dcoutts__> dons: but in utf8 it's a two byte encoding
07:50:11 <roconnor> \x -> zeta(x) == 0.0 ==> Im(x) <= whatever
07:50:12 <dons> kpreid: do you want to get your blog up on planet.haskell.org too?
07:50:22 <dons> one aggregator to bind all the haskell blogs :)
07:50:33 <dons> if so, just ping ibid with the rss feed url
07:50:36 <kpreid> dons: it is unlikely to be a long-term haskell blog
07:50:46 <dcoutts__> dons: so my irc client is sending utf8, then lambdabot is using ghc-6.4.x and so doesn't decode the utf8 when lexing the string literal
07:50:55 <kpreid> dons: I just write about whatever's interesting, and I happen to be using Haskell recently
07:51:02 <dons> dcoutts__: hmm. or is Language.Haskell saying no?
07:51:05 <mux> roconnor: it's Re(x) = 1/2
07:51:09 <dons> kpreid: hmm, I think that's ok.
07:51:20 <dons> kpreid: have a look at the current planet.haskell.org page
07:51:21 <kpreid> dons: that said, I do use categories, and if *you* think it's appropriate, feel free to let ibid know
07:51:26 <dcoutts__> dons: oh, dunno. whatever is lexing the string
07:51:40 <mux> ?check \x -> L.zeta x == 0 => Re x == 0.5
07:51:40 <lambdabot>  Parse error
07:51:48 <dons> kpreid: ok. I think from what I've read so far it seems appropriate
07:51:59 <xerox> @slap mux
07:51:59 * lambdabot beats up mux
07:52:25 <dons> ibid, another feed (kpreid says ok) http://kpreid.livejournal.com/
07:52:26 * mux whines
07:52:43 <dons> google's blog search is pretty good at finding haskell blogs :)
07:52:47 <xerox> :P
07:53:06 <cjeris> mux: isn't it already checked for the first 10^11 zeros or so?
07:55:26 <vincenz> mux: pm me or get on #oasis
07:56:27 <mux> cjeris: yes, even more IIRC
07:56:35 <mux> but it would be funny to have quickcheck do it :-)
07:58:06 <dons> mux, you could ask quickcheck to generate specific ranges of values
07:58:10 <dons> with 'gather' iirc
07:58:15 <dons> ?hoogle gather
07:58:15 <lambdabot> Text.ParserCombinators.ReadP.gather :: ReadP a -> ReadP (String, a)
07:58:19 <dons> nope
07:58:44 <dons> ?hoogle collect
07:58:44 <lambdabot> Test.QuickCheck.collect :: (Show a, Testable b) => a -> b -> Property
07:58:44 <lambdabot> Data.Graph.Inductive.Internal.Thread.Collect :: type Collect r c
07:59:23 <mux> dons: ok, I'll see about this later, I've been sidetracked by $REAL_JOB
07:59:49 <glguy> mux: are you implying that your real job is variable?
07:59:57 <dons> ?check \n -> n % 4 == 0 ==> (n::Int) == subtract (subtract n)
07:59:57 <lambdabot>    Expecting a function type, but found `a'       Expected type: Int,      ...
08:00:34 <dons> ?check \n -> (n % 4 == 0) ==> (n::Int) == - (- n)
08:00:35 <lambdabot>  Arguments exhausted after 105 tests.
08:00:39 <dons> interesting
08:01:22 <mux> glguy: these days it's pretty much variable indeed :)
08:01:24 <glguy> dons: where is ==> defined
08:01:32 <glguy> dons: I typed to ?type (==>)
08:02:05 <kpreid> @type (Test.QuickCheck.==>)
08:02:06 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
08:02:14 <glguy> ah, ok
08:06:34 <fasta> I have a list with elements. I want to "filter" out all elements x that occur after the first occurence of x. What is the easiest way to do that?
08:06:59 <xerox> dropWhile
08:07:07 <xerox> > dropWhile (<5) [1..10]
08:07:08 <lambdabot>  [5,6,7,8,9,10]
08:07:31 <glguy> I think he means: [1,2,3,2,3,2,3,2,3] -> [1,2,3,3,3,3]
08:07:33 <dons> depends on wether filter here means keep all those before, or keep all those after 'x' ?
08:07:47 <dons> > takeWhile (/= 5) [1..10]
08:07:48 <lambdabot>  [1,2,3,4]
08:07:54 <dons> > dropWhile (/= 5) [1..10]
08:07:55 <lambdabot>  [5,6,7,8,9,10]
08:08:02 <dons> fasta: yeah?
08:09:29 <glguy> I think he wants to use break
08:09:56 <dons> > break (== 5) [1..10]
08:09:57 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
08:10:23 <glguy> let (a,b) = break (/=2) [1,2,3,2,3,2,3] in a ++ head b : filter (/= 2) (tail b)
08:10:26 <glguy> > let (a,b) = break (/=2) [1,2,3,2,3,2,3] in a ++ head b : filter (/= 2) (tail b)
08:10:27 <lambdabot>  [1,3,3,3]
08:10:38 <Daveman> xerox :)
08:10:39 <glguy> without removing that first 2
08:10:52 <glguy> > let (a,b) = break (==2) [1,2,3,2,3,2,3] in a ++ head b : filter (/= 2) (tail b)
08:10:53 <lambdabot>  [1,2,3,3,3]
08:11:55 <glguy> > let onlyKeepOne n xs = let (a,b) = break (==n) xs  in a ++ head b : filter (/= n) (tail b) in onlyKeepOne 2 [1,2,3,4,2,3,4,2,3,4]
08:11:57 <lambdabot>  [1,2,3,4,3,4,3,4]
08:12:45 <dcoutts__> dons: good description of rules on the wiki
08:13:29 <dcoutts__> dons: do you think it'd be possible to have the main == instances defined in that way, so we can have more robust rules using eqWord8 etc
08:16:57 <dons> yes, I hope so. I want to look at that
08:27:31 <bourbaki> moin
08:28:02 <vincenz> @localtime mux
08:28:03 <lambdabot> Local time for mux is Wed Sep 13 17:27:40 2006
08:28:15 <fasta> No, I want [1,2,3,4,3,5,1,2]->[1,2,3,4,5]
08:29:10 <fasta> Using lists this is easily O(n^2). I would like to do something better.
08:29:16 <dmwit> nub
08:29:31 <dmwit> > nub [1,2,3,4,3,5,1,2]
08:29:32 <lambdabot>  [1,2,3,4,5]
08:29:32 <fasta> dmwit: I am not aware of it being order preserving.
08:29:55 <dmwit> > nub [1,2,5,4,3,5,4,2,1]
08:29:56 <lambdabot>  [1,2,5,4,3]
08:30:06 <dmwit> fasta: it preserves order
08:30:42 <fasta> dmwit: Ok, and I also thought it was O(n^2), but since it's a library function it will probably be replaced some day.
08:31:04 <sjanssen> fasta: yes, it is O(n^2), and it isn't likely to change
08:31:19 <dmwit> If you want order-preserving, how can it not be O(n^2)?
08:31:20 <fasta> sjanssen: because?
08:32:04 <sjanssen> fasta: because the original type signature doesn't have Ord, so using a sorting approach would break backwards compatibility
08:32:25 <fasta> sjanssen: good point
08:32:45 <sjanssen> dmwit: using a stable sort or iteratively adding "seen" elements to a Data.Map
08:33:08 <sjanssen> both are O(n log n)
08:33:08 <dmwit> sjanssen: Ah, I didn't think of keeping the old list around when using a Map.
08:33:12 <dmwit> Nice.
08:34:36 <dons> ndm, around?
08:35:04 * dons tries smallCheck 0.1
08:35:16 <dons> ?where+ smallcheck http://www.cs.york.ac.uk/fp/smallcheck0.1.tar
08:35:16 <lambdabot> Done.
08:35:24 <vincenz> what is it?
08:35:34 <dons> "SmallCheck is similar to QuickCheck (Claessen and Hughes 2000-)
08:35:34 <dons> but instead of a sample of randomly generated values, SmallCheck
08:35:34 <dons> tests properties for all the finitely many values up to some depth"
08:36:34 <vincenz> oh!
08:36:37 <vincenz> That's the idea I had earlier
08:36:37 <fasta> dons: is that supposed to be understood by anyone?
08:36:43 <vincenz> having a full test for bounded data types
08:36:47 <fasta> dons: "some depth"
08:36:58 <vincenz> fasta: you have to imagine him handwaving
08:36:59 <vincenz> :P
08:37:10 <fasta> vincenz: Oh, I think I already see
08:37:36 <fasta> vincenz: basically all the possible combinations of some algebraic structures up to some depth.
08:37:40 <int-e> fasta: you just need to picture ADTs as trees I think.
08:38:00 <int-e> fasta: then you get a notion of depth, namely the depth of that tree.
08:38:12 <fasta> int-e: yes, I was already to that point :)
08:38:50 <dons> fasta, oh there's some missing bits I didn't bother pasting
08:38:52 <dons> explaing the rules
08:39:32 <dons> ndm, tell Colin to put his code in darcs... :)
08:40:03 <deadbeef> http://forum.cosenascoste.com//viewtopic.php?topic=7308&forum=6
08:40:05 <deadbeef> ops
08:40:06 <lambdabot> http://tinyurl.com/jpad4
08:40:22 * dons adds smallcheck to lambdabot
08:40:23 <deadbeef> sorry
08:40:25 <fasta> The major weakness I saw in Quickcheck for me is that it doesn't include tests for all the library data types. Simple tests for lists don't cut it for me.
08:40:41 <musasabi> audreyt: how do you handle object identity in Pugs?
08:40:56 * musasabi wonders how to get TVar identity.
08:41:19 <musasabi> reallyUnsafePointerEq# seems unsafe.
08:41:19 <dons> that's not really a weakness of QuickCheck. you're supposed to write your own tests. e.g. Map and ByteString come with big ole testsuites of properties
08:41:21 <fasta> The "frame work" could be nice, but it's pretty trivial software.
08:41:48 <dons> if you're looking for other base library QC properties, check the src for the base libs themselves
08:42:03 <dons> ?remember musasabi reallyUnsafePointerEq# seems unsafe.
08:42:05 <fasta> dons: will do
08:42:26 <dmwit> I used the -O2 flag.
08:42:34 <dmwit> Now I run out of stack space *much* quicker.
08:42:39 <dons> here's the fps properties for ByteString, http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
08:42:40 <lambdabot> http://tinyurl.com/hcek8
08:43:09 <fasta> dons: yes, I saw those, but Data.Graph.Inductive does not have them, besides the ones in test.hs, which are completely trivial.
08:43:13 <dons> and Data.Map properties, http://darcs.haskell.org/packages/base/Data/Map.hs
08:43:15 <lambdabot> http://tinyurl.com/jc332
08:43:20 <dons> fgl is a bit old skool
08:43:26 <dons> not sure if Erwig uses QC?
08:43:33 <fasta> dons: he doesn't.
08:43:44 <fasta> dons: what are the other graph libraries out there then?
08:43:52 <dons> Data.Graph, but its not as complete
08:44:02 <dons> ?fptools Data.Graph
08:44:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Graph.hs
08:44:04 <fasta> I thought that one was old sjool
08:44:06 <dons> old too, so maybe no QCs
08:44:06 <vincenz> dons: oh yeah check this out
08:44:10 <fasta> er skool
08:44:19 <vincenz> @check \x -> (x :: Rational) == x
08:44:24 <lambdabot>  add an instance declaration for (Arbitrary (Ratio Integer))     In the defi...
08:44:24 <dons> its really post ghc 6.2 that you start to see QC stuff coming standard with new libs
08:44:50 <dons> vincenz: ? you want a new Arbitrary instance?
08:45:04 <fasta> dons: the thing about graphs and random generation of them is that it's not completely trivial to get interesting distributions.
08:45:05 * dons is collecting Arbitraries
08:45:08 <vincenz> dons: well I don't think it'd be that difficult
08:45:23 <vincenz> dons: I could do it myself, but it seems so trivial the overhead of sending it would be bigger than doing it
08:45:24 <dons> vincenz: was that your implicit question though? (/me is tired)
08:45:32 <vincenz> dons: no worries
08:45:32 <dons> ok. i'll add it now
08:45:35 <vincenz> @localtime dons
08:45:37 <lambdabot> Local time for dons is Thu Sep 14 01:45:13 2006
08:45:41 <vincenz> dons: don't forget to filter for 0 in the quotient
08:46:21 <fasta> dons: did you actually catch bugs using QuickCheck? Even more interesting would be if you introduced bugs that were caught by it.
08:46:53 <dons> vincenz: instance Random a => Random Ratio a where
08:46:53 <dons>   randomR = do a <- arbitrary
08:46:53 <dons>                b <- arbitrary
08:46:53 <dons>                return (a % b)
08:47:15 <vincenz> dons: yep ;)
08:47:17 <dons> fasta: oh yes. it was _critical_ to getting the one man show that was Data.ByteString to a stage it was usable
08:47:22 <vincenz> > 0 % 0
08:47:23 <lambdabot>  Exception: Ratio.%: zero denominator
08:47:28 <dons> right
08:47:38 <dons> ?karma QuickCheck
08:47:38 <lambdabot> QuickCheck has a karma of 10
08:47:41 <vincenz> Don't want your arbitrary forming an exception
08:47:51 <dons> fasta, 10 bugs I caught developing Data.ByteString :)
08:48:06 <fasta> dons: what is that @karma <plus> <plus> -- some comment syntax?
08:48:14 <fasta> dons: does the comment matter?
08:48:22 <dons> comment is meaningless
08:48:37 <dons> test++ <-- increments test's karma
08:48:44 <dons> ?karma+ test -- so does this
08:48:45 <lambdabot> test's karma raised to 2.
08:48:48 <dons> ?karma- test
08:48:48 <lambdabot> test's karma lowered to 1.
08:48:56 <vincenz> test++
08:48:57 <vincenz> @karma test
08:48:58 <lambdabot> test has a karma of 2
08:48:59 <vincenz> hmm
08:49:02 <vincenz> it's a silent one
08:49:04 <dons> yes
08:49:07 <vincenz> that explains
08:49:09 <dons> the perl6 guys use that syntax
08:49:14 <dmwit> So don't start your messages with "C++"... =)
08:49:17 <dons> but they don't want the noise
08:49:18 <fasta> @karma fasta
08:49:18 <lambdabot> You have a karma of 0
08:49:19 <dons> C++
08:49:22 <dons> special case
08:49:23 <dmwit> @karma c
08:49:23 <lambdabot> c has a karma of -1
08:49:27 <dmwit> @karma C
08:49:27 <lambdabot> C has a karma of 2
08:49:33 <dons> (unrelated)
08:49:39 <dons> C++
08:49:43 <fasta> @karma dons
08:49:43 <lambdabot> dons has a karma of 68
08:49:44 <dons> @karma C
08:49:44 <lambdabot> C has a karma of 2
08:49:55 <dmwit> dons: Nice.
08:54:52 <musasabi> "unsafeCoerce# :: TVar a -> Word" seems like a cheap way to make temporary identities for TVars.
08:57:52 <glguy> <:-S Apple made iTunes ugly
09:02:21 <lispy> meep meep! Good morning #haskell!
09:02:49 <lispy> glguy: in some recent update or in general?
09:02:50 <glguy> morning
09:02:55 <dolio> ?localtime lispy
09:02:56 <glguy> 7.0 came out
09:02:57 <lambdabot> Local time for lispy is Wed Sep 13 09:02:33 2006
09:03:24 * lispy just had his morning jog and is sitting down to breakfast
09:03:34 <lispy> 8miles is a great way to start your day! :)
09:03:50 <dons> vincenz: how's this:
09:03:51 <dons> instance (Integral a, Arbitrary a) => Arbitrary (Ratio a) where
09:03:52 <dons>   arbitrary    = do a <- arbitrary
09:03:52 <dons>                     b <- arbitrary
09:03:52 <dons>                     if b == 0
09:03:54 <dons>                         then arbitrary
09:03:56 <dons>                         else return (a % b)
09:03:59 <dons>   coarbitrary m = variant (fromIntegral $ if n >= 0 then 2*n else 2*(-n) + 1)
09:04:02 <dons>     where n = numerator m
09:04:06 <dons> lispy: you jog 8 miles before breakfast?
09:04:14 <lispy> i did today :)
09:04:18 <dons> that's cool. I should really start running again.
09:04:23 <lispy> i'm traning for a marathon
09:04:23 <vincenz> dons: *wince*
09:04:39 <dons> vincenz: got some magic sugar for me?
09:04:41 <vincenz> yeah
09:04:45 <vincenz> not as nice but yeah
09:04:49 <vincenz> I mean not as claen
09:04:53 <glguy> dons: your arbitrary could theoretically never return :)
09:04:59 <dons> it could
09:05:12 <dons> let us all await the day lambdabot diverges on this code fragment :)
09:05:28 * lispy holds his breath
09:05:36 <vincenz> dons: not as  nice but ok
09:05:42 <vincenz> instance (Integral a, Arbitrary a) => Arbitrary (Ratio a) where
09:05:42 <vincenz>   arbitrary    = do a <- arbitrary
09:05:42 <vincenz>                     b <- arbitrary
09:05:42 <vincenz>                     if b == 0
09:05:42 <vincenz>                         then
09:05:45 <vincenz>                           if a == 0 then return (1 % 1) else return (b % a)
09:05:47 <vincenz>                         else return (a % b)
09:06:00 <vincenz> It's not like we need a nice gaussian distribution
09:06:09 <dons> no ok.
09:06:15 <glguy> vincenz: wouldn't your create an uneven distribution of 1s?
09:06:23 <dons> and you don't have a coarbitrary :)
09:06:37 <dons> so what happens when someone wants a random _function_ over Ratio a ;)
09:06:42 <vincenz> glguy: yeah, but who cares?
09:06:56 <vincenz> dons: what is a coarbitrary?
09:07:10 <dons> its the other method in the Arbitrary class
09:07:16 <vincenz> right but what does it do
09:07:17 <dons> its used to generate random functions over types
09:07:24 <dcoutts__> which is very cool
09:07:26 <vincenz> ?
09:07:28 <dons> check the second half of ever quickcheck paper for the explanation :)
09:07:31 <glguy> explain moew
09:07:32 <vincenz> so does it need to be an inverse?
09:07:32 <glguy> more
09:07:41 <vincenz> if not
09:07:46 <vincenz> stick to your coarbitrary
09:07:48 <vincenz> and use my arbitrary
09:08:48 <dons> @check \x -> (x :: Rational) == x
09:08:54 <lambdabot> Terminated
09:09:00 <vincenz> haha
09:09:05 <dons> heh
09:09:08 * dons puzzles
09:09:12 <vincenz> I think 0 is a very common case
09:09:19 <dons> maybe
09:09:28 <bourbaki> dons did you get the mail ?
09:09:32 <vincenz> dons: use my impl?
09:09:41 <glguy> dons: can lispy breathe now?
09:09:49 <dons> that was my code.
09:09:55 <vincenz> dons: I mean try it
09:10:01 <dons> yeah I will ok.
09:10:14 <lispy> *gasp*
09:10:19 <lispy> *pant* *pan*
09:12:05 <lispy> wow, it's late in aussie land
09:12:28 <glguy> it's always late somewhere :-p (who's in aussie land?)
09:12:44 <dons> me
09:12:57 <lispy> yeah, it's funny about irc
09:13:42 <dons> @check \x -> (x :: Rational) == x
09:13:43 <lambdabot>  OK, passed 500 tests.
09:13:44 <lispy> channels like this with people from so many timezones don't go quiet very long
09:13:46 <vincenz> \o/
09:13:50 <dons> vincenz++
09:14:03 * glguy dives in to save vincenz
09:14:03 <vincenz> @check \x -> (x :: Rational) == x - 1 + 1
09:14:04 <lambdabot>  OK, passed 500 tests.
09:14:07 <glguy> dons: he's drowning
09:14:09 <dons> lesson: don't recurse after 1am
09:14:14 <lispy> hehe
09:14:15 <vincenz> glguy: lol, no
09:14:22 <vincenz> dons: I don't get why it infinitely recursed tho
09:14:23 <int-e> @check \x -> (x :: Float) == x - 1 + 1
09:14:24 <lambdabot>  Falsifiable, after 29 tests: -0.33333334
09:14:25 <vincenz> dons: that's just bad
09:14:45 <dons> int-e, isn't that good :)
09:14:47 <glguy> it recursed to prove my point ;)
09:15:10 <dons> i think ghc is monitoring my conversations, and breaking code to spite me
09:15:54 <dcoutts__> dons: seen SmallCheck ?
09:16:13 <dons> dcoutts__: do you mean to ask: is it a lambdabot plugin yet?
09:16:18 <dons> answer: almost
09:16:19 * vincenz hehes
09:16:19 <dcoutts__> hah
09:16:22 <dcoutts__> cool
09:16:24 <int-e> @check \x -> (x :: Float) - x == 0
09:16:24 <vincenz> dons: get some sleep!
09:16:25 <lambdabot>  OK, passed 500 tests.
09:16:35 <dcoutts__> dons: might be useful for BS's tests
09:16:53 <int-e> > (1/0) - (1/0) == 0
09:16:54 <lambdabot>  False
09:17:15 <dcoutts__> dons: we had some cases where we were not generating some corner cases well
09:17:24 <dcoutts__> like chunk size
09:17:38 <dons> ah right. we could try that. yes.
09:18:04 <lispy> smallcheck?
09:18:11 <musasabi> @where smallcheck
09:18:11 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.1.tar
09:18:29 <lispy> bleh, i don't want a tar, i want a darcs repo or a html page :)
09:18:37 <dcoutts__> lispy: see the announcement on the haskell mailing list
09:18:45 <vincenz> ah
09:18:48 <vincenz> that's why I didn't hear about it
09:18:51 * vincenz is no longer on ML
09:18:57 <lispy> ah, i'm not on haskell, i'm only on haskell-cafe buti'll check the google group
09:18:57 <musasabi> the author for some reason uses tar-files instead of darcs repos...
09:19:14 <dons> we can get ndm to bug colin about this, and move into the darcs age
09:19:42 <glguy> dons: does that intentionally sounds like the "dark age"?
09:20:05 <dons> heh, i was thinking 'space age'
09:20:36 <SyntaxNinja> dons: what's the topic?
09:20:52 <dons> hmm?
09:20:56 <dons> heya SyntaxNinja
09:21:17 <dons> prize for weirdest haskell blog entry goes to: "I?m learning Haskell a relatively new functional programming language developed at MIT. "
09:21:29 <SyntaxNinja> hehe
09:21:44 <deadbeef> the famous Hascheme
09:21:58 <SyntaxNinja> what colin-related software wer eyou talking about when I got here?
09:22:04 <vincenz> dons: ????
09:22:24 <dons> SyntaxNinja: ah, SmallCheck
09:23:48 <lispy> okay, i just emailed Colin encouraging him to publish a public darcs repo
09:25:08 <lispy> as dons and i showed earlier, darcs + cabal gives a really nice turn around on glueing libraries together
09:27:06 <dolio> Man, these SICP lectures are great.
09:27:22 <basvandijk> Hi guys, I just did 'darcs get  --partial http://darcs.haskell.org/ghc', './darcs-all --extra get', 'configure --prefix=$HOME/programs', 'make' followed by a 'make install'. Now I would like to install the documentation so I did a 'make install-doc'. Make installs the documentation and doesn't produce an error. But when I look at $HOME/programs/share/ghc-6.5/html/libraries/index.html it shows a nice haddock page but without any packages?
09:27:35 <dolio> Evidently Sussman was unsuccessful in his attempt to get the keyboard industry to include lambda keys.
09:34:53 <glguy> dolio: do you have the SICP lectures link?
09:35:13 <dolio> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
09:35:18 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
09:35:40 <\z> dolio: http://lambda-the-ultimate.org/node/1096 as well
09:35:40 <lambdabot> Title: iPod-compatible SICP | Lambda the Ultimate
09:35:51 <\z> (320x240 ipod-friendly encoding)
09:36:14 <\z> er, glguy.
09:36:14 <dolio> Heh, well, I don't have a video ipod. :)
09:36:25 <dolio> Oh, okay.
09:36:36 <\z> I think the files are smaller
09:36:50 <araujo> hi all!
09:36:52 * araujo back
09:36:52 <dolio> Ah, that could be a boon. Their mpegs are giant.
09:37:25 <\z> get 'em while they're still small
09:37:39 <glguy> I started watching these lectures a year ago or so
09:37:39 <dolio> I guess even 400 - 500 megs a piece for the divx encodes is pricey.
09:37:45 <\z> as of yesterday, ipod video will be 640x480, with a monstrously large bitrate
09:37:48 <glguy> but never finished them
09:39:32 <bourbaki> hey esap
09:39:35 <esap> hi
09:40:43 <karshv> Any HSQL developers here?
09:59:39 <dons> ?users #haskell
09:59:39 <lambdabot> Maximum users seen in #haskell: 242, currently: 233 (96.3%), active: 39 (16.7%)
10:02:17 <dons> ?quit add smallcheck
10:03:02 <dons> ?version
10:03:13 <Sentinel> nice
10:03:14 <dons> oops
10:03:19 <jgrimes> :p
10:03:22 <Sentinel> haskell i assume since it crashes ;)
10:03:29 * dons has to remembe rthat ^C isn't the same as ^D in screen
10:03:50 <dons> ?version
10:04:18 <lambdabot> lambdabot 4p188, GHC 6.5 (OpenBSD i386 )
10:04:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:04:23 <dons> ?help scheck
10:04:40 <lambdabot> scheck <expr>
10:04:42 <lambdabot> You have SmallCheck and 3 seconds. Test something.
10:04:48 <dons> ok i will.
10:04:52 <dons> ?scheck True
10:04:53 <lambdabot>  Completed 1 test(s) without failure.
10:05:08 <dons> ?scheck \s -> (s :: [Int]) == (reverse . reverse) s
10:05:11 <lambdabot>  Completed 623530 test(s) without failure.
10:05:21 <int-e> ?scheck isDigit
10:05:22 <lambdabot>  add an instance declaration for (Serial Char)
10:05:22 <lambdabot>   In the definition of `irn...
10:05:27 <dons> ?scheck \s -> minimum (s :: [Int]) == head (sort s)
10:05:28 <lambdabot>  Exception: Prelude.minimum: empty list
10:05:37 <dons> ?scheck \s -> not (null s) ==> minimum (s :: [Int]) == head (sort s)
10:05:42 <lambdabot>  Completed 623530 test(s) without failure.  But 1 did not meet ==> condition.
10:05:49 <dons> good , the [] case
10:06:15 <musasabi> ?scheck (putStrLn "hello world")
10:06:16 <lambdabot>  add an instance declaration for (Testable ())
10:06:17 <lambdabot>   In the definition of `wkw...
10:06:30 <musasabi> ?scheck (putStrLn "hello world" >> return True)
10:06:31 <lambdabot>  Completed 1 test(s) without failure.
10:06:37 <musasabi> ;P
10:06:38 <dons> inneresting.
10:06:43 <int-e> ?scheck id
10:06:44 <lambdabot>  Add a type signature
10:06:52 <int-e> ?scheck id :: Bool -> Bool
10:06:53 <lambdabot>   Failed test no. 2. Test values follow.: False
10:07:07 <musasabi> dons: there is an instance Testable a => Testable (IO a) with unsafePerformIO.
10:07:15 <dons> ah didn't see that
10:07:22 <dons> evil Colin!
10:08:20 * musasabi requested "Testing things with IO in SmallCheck" ;)
10:08:26 <dons> ?scheck (putStrLn "hello world" >> return True)
10:08:28 <lambdabot>  Completed 1 test(s) without failure.
10:08:30 <int-e> evil musasabi ;)
10:10:28 <dons> ?scheck (putStrLn "hello world" >> return True)
10:10:29 <lambdabot>  add an instance declaration for (Testable (IO Bool))
10:10:29 <lambdabot>   In the definition ...
10:10:48 <dons> No, I won't, even if ghc says to
10:11:36 <SyntaxNinja> @seen shapr
10:11:37 <lambdabot> Last time I saw shapr was when I left #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.es, #haskell.it, #haskell.se, #haskell_ru, #oasis, #perl6 and #scannedinavian
10:11:37 <lambdabot> 4d 9h 48m 15s ago, and .
10:11:47 <int-e> ?scheck const True unsafePerformIO
10:11:48 <lambdabot>  Not in scope: `unsafePerformIO'
10:11:48 <nomeata> ?scheck true
10:11:49 <lambdabot>  Not in scope: `true'
10:11:57 <nomeata> ?scheck True
10:11:58 <lambdabot>  Completed 1 test(s) without failure.
10:12:08 <nomeata> ?scheck False
10:12:09 <lambdabot>   Failed test no. 1. Test values follow.:
10:13:27 <dons> ?scheck \s -> minimum (s :: T) == last (sort s)
10:13:28 <lambdabot>  Exception: Prelude.minimum: empty list
10:13:46 <dons> ?scheck minimum `L.eqnotnull` (head . sort)
10:13:47 <lambdabot>     add an instance declaration for (Testable Test.QuickCheck.Property)
10:13:47 <lambdabot>  ...
10:13:53 <dons> ah heh.
10:13:59 <dons> interoperability, please :)
10:14:29 <SyntaxNinja> xs: I hear you know mathieu :)
10:14:38 <dons> ?scheck \x -> ((x :: I) < 256)
10:14:39 <lambdabot>  Completed 10 test(s) without failure.
10:15:20 <dons> ?scheck \x -> (x :: Float) - x == 0
10:15:21 <lambdabot>  add an instance declaration for (Serial Float)
10:15:21 <lambdabot>   In the definition of `lx...
10:15:28 <dons> ah and not enough instances yet
10:16:26 <dons> ?scheck \xs ys zs -> xs++ys == zs ==> exists $ \t -> (xs,ys) == span t zs :: [Bool] -> [Bool] -> [Bool] -> Property
10:16:26 <lambdabot>    Expecting a function type, but found `Bool'
10:16:27 <lambdabot>    Expected type: [Bool] ...
10:16:42 <bourbaki> isnt it dangerous to let ppl execute stuff like that on your bot?
10:16:51 <basvandijk> Does anybody know if the GHC API as explained in http://www.haskell.org/haskellwiki/GHC/As_a_library still exists?
10:16:54 <lambdabot> Title: GHC/As a library - HaskellWiki, http://tinyurl.com/kffsp
10:17:19 <dons> bourbaki: we have ways and means
10:17:31 <bourbaki> ah ok but you can execute recursions?
10:18:00 <twanvl> > let f x = f (x + 1) in f 1
10:18:02 <lambdabot>  Add a type signature
10:18:06 <dons> ?scheck \xs -> not (null xs) ==> \f -> foldl1 f xs == foldr1 f (xs::T)
10:18:07 <lambdabot>     instance (Serial a, Show a, Show b) => Show (a -> b) -- Imported from ...
10:18:14 <dons> boo
10:18:22 <dons> bourbaki: sure. recurse your self silly :)
10:18:40 <dons> > let f () = f () in f () :: ()
10:18:44 <lambdabot> Terminated
10:19:21 <bourbaki> hehe but wont i be able to make it crash with a recursion? or create a zombie process or so?
10:19:43 <dons> don't think so.
10:19:56 <dons> it cleans up zombies
10:20:01 <SyntaxNinja> how come none of you have sent me your resumes?
10:20:11 <SyntaxNinja> well, almost none of you ;)
10:20:31 <bourbaki> ah ok
10:20:42 <bourbaki> what resumes?
10:20:44 <dons> SyntaxNinja: oh, the new position?
10:21:06 <bourbaki> SyntaxNinja do you need a new ninja vilian ;)?
10:22:56 <SyntaxNinja> bourbaki: Galois is seeking a talented Ninja Villain to drop in silently on unsuspecting victims and develop high assurance software.
10:23:10 <bourbaki> :)
10:23:32 <musasabi> Galois is far far away and people have lives which make moving harder.
10:23:35 <fasta> SyntaxNinja: do you know of a high assurance OS?
10:23:43 <twanvl> dons: is that copy/paste work I see in the lambdabot plugin sources?
10:23:45 <dons> House !
10:23:53 <dons> twanvl: where's that?
10:23:55 <Templar> can anyone tell me how I add text after an output function? Exampel: eu =5*10 = 50 [units/text or something after output]
10:24:42 <dons> twanvl: ah yes. I know what you mean
10:24:46 <dons> ?localtime dons
10:24:49 <lambdabot> Local time for dons is Thu Sep 14 03:24:24 2006
10:24:52 <dons> refactors not at this hour
10:24:58 <fasta> dons: I meant more like something more complete.
10:25:24 <twanvl> Templar: use strings
10:25:25 <twanvl> > show 5 * 10 ++ " meter"
10:25:27 <lambdabot>  add an instance declaration for (Num String)
10:25:27 <SyntaxNinja> fasta: there's none yet.  as soon as there is one, we'll be using it ;)
10:25:28 <fasta> dons: and AFAIK, House is not actively developed.
10:25:37 <twanvl> > show (5 * 10) ++ " meter"
10:25:38 <lambdabot>  "50 meter"
10:25:49 <dons> > printf "%d meter" (5*10)
10:25:49 <fasta> SyntaxNinja: how unfortunate
10:25:49 <SyntaxNinja> fasta: we'll probably be working w/ SELinux in the mean-time.
10:25:50 <lambdabot>  Add a type signature
10:25:53 <dons> > printf "%d meter" (5*10) :: String
10:25:54 <lambdabot>  Add a type signature
10:26:02 <dons> > printf "%d meter" (5*10::Int) :: String
10:26:03 <lambdabot>  "50 meter"
10:26:05 <SyntaxNinja> fasta: what's your interested in high assurance OSs?
10:26:05 <Templar> should use " x " chars then?
10:26:05 <fasta> SyntaxNinja: is SELinux more secure than OpenBSD?
10:26:09 <Templar> " "
10:26:16 <SyntaxNinja> fasta: probably ;)
10:26:21 <dons> boo
10:26:37 <Templar> ok, ty
10:26:38 <SyntaxNinja> but a high assurance OS would probably only be good for very specific tasks, not as a general-purpose box.
10:26:41 <Templar> checking it out
10:26:50 <SyntaxNinja> you don't want to have _any_ extra code running on it.
10:27:01 <pejo> fasta, doubt that OpenBSD and SElinux have the same target audience.
10:27:14 <fasta> pejo: because?
10:27:35 <cjeris> SyntaxNinja: can I call you back in 3 years?  (i made the in-hindsight-critical error of studying pure math :))
10:28:34 <SyntaxNinja> cjeris: yeah, call me in 3 years.
10:28:49 <SyntaxNinja> fasta: are you into formal methods?
10:29:09 <pejo> fasta, SElinux is just mandatory access controls (MAC) for linux, isn't it? Does OpenBSD have something similar?
10:29:23 <fasta> pejo: I know FreeBSD has
10:29:25 <AstralStorm> Hi all. I've Yet Another Newbie Question: Is there some nice howto about implementing continuations in Haskell?
10:29:43 <pejo> fasta, yes, but that is from the TrustedBSD stuff afaik.
10:30:14 <AstralStorm> I mean I have to make the function return some value denoting error, but sometimes ignore it and continue with previous state.
10:30:50 <twanvl> Can't you use the error monad (Either)?
10:31:10 <dons> AstralStorm: if you want nice continuations, try the Cont monad?
10:31:19 <pejo> (And the goal of the entire thing is to separate information based on confidentiality and integrity requirements, sounds typical NSA).
10:31:20 <beelsebob_> AstralStorm: I'd just give it an Either return type
10:31:28 <pejo> dons, boggle, don't you have all the answers for this, wearing your openbsd hat? :P
10:31:36 <AstralStorm> Lets'see.
10:31:55 * dons is too tired to put on openbsd hats 
10:32:08 <dons> lambdabot likes openbsd though :)
10:32:08 <bourbaki> openbsd hat?
10:32:31 <AstralStorm> dons: thanks.
10:32:34 <bourbaki> i remember a bowie song put on your red hat and dance with me
10:32:42 <AstralStorm> beelsebob_: no, it wouldn't store the state in case of an error.
10:34:12 <beelsebob_> AstralStorm: in which case (Maybe Error, State)
10:34:18 <AstralStorm> beelsebob_: no.
10:34:24 <AstralStorm> That would return Error
10:34:39 <AstralStorm> And I'd have to cater for the state myself :P
10:34:45 <beelsebob_> AstralStorm: hmm?
10:34:50 <beelsebob_> return error?
10:34:58 <beelsebob_> I'm talking purely functional here
10:35:03 <AstralStorm> I'd like it to just store the function and continue if called again.
10:35:05 <beelsebob_> 90% of the time when you need state you don't
10:35:13 <beelsebob_> oh, I see
10:35:15 <AstralStorm> I do, in this case, really.
10:35:20 <beelsebob_> fair enough
10:36:16 <AstralStorm> I could also emulate that with Functor, but Cont looks better.
10:36:53 <inv2004> hi all
10:36:57 <AstralStorm> Much better indeed.
10:37:05 <ValarQ> hello mr 2004
10:37:08 <inv2004> how to get random Int ?
10:37:41 <inv2004> without IO Int
10:37:49 <AstralStorm> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
10:37:51 <lambdabot> http://tinyurl.com/eu3xo
10:37:56 <inv2004> thx
10:37:56 <dolio> ?type randomR
10:37:58 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:40:26 <dolio> > fst . randomR (1, 10) $ (mkStdGen 3094)
10:40:27 <lambdabot>  10
10:41:07 <inv2004> thx
10:41:21 <dolio> Note that 3094 is the seed there.
10:41:46 <dolio> You can't get an auto-randomized seed without IO.
10:42:39 <inv2004> fst . R.randomR (1, 10) $ (R.mkStdGen 3094)
10:42:44 <inv2004> ERROR - Unresolved overloading
10:43:00 <inv2004> Type       : (Num a, Random a) => a
10:43:04 <inv2004> Expression : fst . randomR (1,10) $ mkStdGen 3094
10:43:05 <Templar> !paste
10:43:05 <dons> probably a missing constraint, inv2004 ?
10:43:08 <Templar> paste
10:43:13 <dons> ?paste
10:43:14 <lambdabot> http://paste.lisp.org/new/haskell
10:43:24 <Templar> ty
10:44:59 <lisppaste2> Templar pasted "string" at http://paste.lisp.org/display/25963
10:45:26 <inv2004> > fst . randomR (1, 10) $ (mkStdGen 3094)
10:45:28 <lambdabot>  10
10:45:59 <inv2004> > mkStdGen 3094
10:46:01 <lambdabot>  3095 1
10:46:15 <inv2004> > :t (mkStdGen 3094)
10:46:16 <lambdabot>  Parse error
10:46:19 <inv2004> ok
10:46:34 <xs> @type mkStdGen 3094
10:46:35 <lambdabot> StdGen
10:46:52 <inv2004> @type randomR (1, 10) $ (mkStdGen 3094)
10:46:54 <lambdabot> forall a. (Random a, Num a) => (a, StdGen)
10:46:55 <inv2004> cool bot
10:47:17 <inv2004> @type fst . randomR (1, 10) $ (mkStdGen 3094)
10:47:19 <lambdabot> forall a. (Random a, Num a) => a
10:48:10 <inv2004> don't understand
10:48:21 <Templar> should I make "string" into the type line when adding text?
10:48:48 <dolio> inv2004: Which part?
10:53:14 <lisppaste2> Saukko pasted "C++ ongelma" at http://paste.lisp.org/display/25964
10:55:20 <lisppaste2> saukko annotated #25964 with "C++" at http://paste.lisp.org/display/25964#1
10:58:48 <d04jk> what is usually the remedy if you find yourself writing fuinctions with a lot of guards ;)
11:00:38 <d04jk> im learning haskell and i find it hard to not try to write "java" in haskell ;)
11:00:53 <vincenz> nickserv down?
11:01:01 <dons> d04jk: more practice?
11:03:38 <karshv> Does anybody here uses WASH for web development?
11:12:17 <glguy> guard aren't necessarily a sign of bad code... are they?
11:12:21 <glguy> guards*
11:13:42 <SamB> of course not ;-)
11:13:55 <SamB> why would we have them if they were?
11:16:46 <dolio> Guards are the declarative alternative to case/if expressions.
11:18:00 <glguy> guards : declarative :: pattern matching : ?
11:18:15 <glguy> as in let f 0 = 0; f n = f (n-1)
11:18:16 <dolio> Pattern matching is declarative.
11:18:38 <dolio> At least, that's how it's classified in the history of haskell paper.
11:18:41 <glguy> ok, I didn't remember if there was some other distinction
11:18:47 <dolio> Pattern matching, guards and where clauses are declarative.
11:18:47 <glguy> I remember that from the paper
11:18:55 <glguy> but didn't remember the specifics of the paper
11:19:08 <dolio> Let, if, case and lambda are expression-oriented.
11:19:49 <dolio> And "foo f = ..." would be the dual to "foo = \f -> ..." I guess.
11:19:59 <glguy> I tend to use Haskell in a much more declarative way
11:20:19 <dolio> Yeah, I kind of prefer that way, too.
11:20:46 <dolio> Using let and case and such reminds me of scheme, and seems more verbose.
11:21:20 <glguy>  I like using where because I feel like I'mtelling you what my function does, and if you care, you can look at the definitions of the functions that it calls
11:21:31 <dolio> Yeah.
11:21:31 <glguy> if you can't figure out what it does implicitly
11:21:52 <fasta> A programming language is different from mathematics. Mathematics is declarative, Haskell is not.
11:22:05 <dylan> I have trouble finding a good indent with multi line functions
11:22:07 <dylan> + where
11:23:07 <dylan> only really been a problem with using lots of getDirectoryContents and similar IO functions, though.
11:23:22 <dylan> (otherwise it can all fit on one 90-char wide line)
11:23:52 <emu> haskell is not declarative?
11:24:31 <SamB> not so much!
11:24:39 <int-e> you declare a lot of constants.
11:24:42 <SamB> it actually has to run somehow, after all!
11:24:50 <SamB> whereas math doesn't have to run...
11:24:54 <SamB> it just has to make sense
11:25:01 <int-e> and the main constant gets interpreted as an IO action.
11:25:33 <emu> haskell programs have to run?
11:25:42 <emu> i was just writing them down on the backs of envelopes and napkins
11:25:47 <int-e> (that's my personal view of things)
11:25:49 <int-e> emu: heh
11:25:56 <SamB> well, you don't have to run them
11:26:23 <SamB> but the language has a number of concessions to the possibility that you might want to
11:26:49 <int-e> 'declarative' is a fuzzy term.
11:27:06 <SamB> no infinite sets here, no siree!
11:27:11 <fasta> int-e: it's marketing blurb to put it extreme
11:27:18 <emu> > [1..]
11:27:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:27:30 <int-e> that's not really infinite :)
11:27:33 <emu> darn lambdabot, refusing to print out infinite sets
11:27:35 <int-e> > last [1..]
11:27:39 <lambdabot> Terminated
11:27:42 <SamB> I was going to point out that that isn't a set...
11:27:57 <int-e> otherwise this should give an error instead of not terminating
11:28:16 <fasta> And it's even countable infinite
11:28:21 <int-e> (hah, I'm making no sense :)
11:36:15 <beelsebob> chdfiuyuixmbht
11:37:19 <beelsebob> cgfyp.oqjkidghm
11:37:49 <int-e> cat?
11:38:59 * araujo looks in
11:42:40 <int-e> hi araujo
11:42:48 <int-e> @users
11:42:50 <lambdabot> Maximum users seen in #haskell: 242, currently: 229 (94.6%), active: 30 (13.1%)
11:43:05 <int-e> > 30/229
11:43:06 <lambdabot>  0.13100436681222707
11:43:47 <araujo> hi hi int-e
11:44:03 <emu> > [0, -1, ..]
11:44:03 <lambdabot>  Parse error
11:44:07 <emu> > [0, -1..]
11:44:08 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
11:44:21 <emu> > (reverse [0, -1..]) ++ [1..]
11:44:25 <lambdabot> Terminated
11:44:26 <emu> =)
11:45:33 <int-e> > let omega = repeat () in omega ++ omega -- ordinal numbers ;)
11:45:34 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:46:14 <emu> > let omega = repeat () in cycle omega
11:46:16 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:46:45 <int-e> evil. does cycle stop at omega?
11:46:59 <emu> actually it's the identity function on infinite lists :/
11:47:36 <int-e> I know. And omega ++ omega is the same as omega, unless we choose a non-standard model of Haskell ;)
11:52:37 <newsham> hi
11:56:39 <lightstep> ho
11:56:54 <newsham> idaho?  udaho!
11:57:11 <newsham> *ahem* i mean, "hellO"
12:14:47 <ibid> kpreid: added. check your listing and complain if it is wrong :)
12:17:02 <ibid> dons: all three added
12:24:09 <lightstep> > let piseq = map (
12:24:09 <lambdabot>  Parse error
12:24:24 <lightstep> ?type recip
12:24:26 <lambdabot> forall a. (Fractional a) => a -> a
12:27:00 <ptolomy> Is it safe to say that the combination of template haskell and the GHC type system make for code "generative" abilities beyond that of C++'s templates?
12:27:32 <Heffalump> the GHC type system is irrelevant
12:27:38 <glguy> > foldr1 ((.recip).(+)) [3, 7, 15, 1, 292, 1, 1, 1]
12:27:39 <lambdabot>  3.1415926536189365
12:27:49 <Heffalump> I think both are technically turing complete, if you ignore the template unfolding limits.
12:28:05 <Heffalump> but given the template unfolding limits, and given the practical limitations of templates, yes
12:35:09 <ptolomy> Hm.
12:35:11 <ptolomy> neat.
12:35:17 <cjeris> glguy: reference for that continued fraction?
12:35:35 <lightstep> > let piseq = zipWith ($) (cycle [id,negate]) (map recip [1,3..]); sums (x:xs) = x : map (+x) (sums xs); square x = x * x; euler (x0:x1:x2:xs) = x2 - square(x2-x1) / (x0-2*x1+x2) : euler (x1:x2:xs); tableau t s = map head $ iterate t s in map (*4) $ tableau euler $ sums $ piseq
12:35:38 <lambdabot>  [4.0,3.166666666666667,3.142105263157895,3.1415993573190044,3.14159271403377...
12:36:01 <lightstep> i love this sicp formula
12:37:34 <lightstep> > let piseq = zipWith ($) (cycle [id,negate]) (map recip [1,3..]); sums (x:xs) = x : map (+x) (sums xs); square x = x * x; euler (x0:x1:x2:xs) = x2 - square(x2-x1) / (x0-2*x1+x2) : euler (x1:x2:xs); tableau t s = map (head . tail) $ iterate t s in map (*4) $ tableau euler $ sums $ piseq
12:37:37 <lambdabot>  [2.666666666666667,3.1333333333333337,3.1414502164502167,3.1415908603958806,...
12:49:43 * CosmicRay waits impatiently for his macbook pro to arrive
12:50:01 <CosmicRay> err, ww, sorry
12:50:09 <glguy> Maths Teacher: Now suppose the number of sheep is x...
12:50:10 <glguy> Student: Yes sir, but what happens if the number of sheep is not x?
12:57:16 <ProfTeggy> hehe
12:58:05 <ProfTeggy> glguy, the math teacher should explicitly universally quantify the variables he/she uses
13:18:20 <user317> i need to verify that a new header at least exports the same symbols as an older version, does anyone know of any tools that will help me do that?
13:18:32 <user317> for C
13:18:48 <glguy> grep?
13:20:31 <user317> its more complicated then grep or diff can handle, i actually need to verify that the new source is backwards compatibile, so i need some sort of C parser that can give me all the symbols and their values
13:20:52 <user317> is there a C parser in happy? or parsec?
13:21:40 <zamez> how about etags?
13:21:44 <edwardk_> user: that sounds like a rather masochistic task. any other way you could go about doing it?
13:22:27 <user317> edwardk_, not really, i mean i need to make sure its backwards compatible, i dont care how :), but id rather not do it by hand its a couple hundred headers
13:23:21 <edwardk_> user: well. I suppose you could compile them and skim through the symbols in the object files ;)
13:23:37 <user317> edwardk_, thats only binary compatibility
13:24:15 <edwardk_> sure, unfortunately what you are asking for is a little ill defined. coz I can have a header be compatible with a previous version that changes some random symbols, adds a few defines, etc.
13:24:26 <user317> edwardk_, we have an object model that uses macros for inheritance, its kind of like COM, so i need to make sure that no one broke any interfaces
13:25:09 <edwardk_> user: sounds like a job for a regression test suite ;)
13:26:39 <user317> edwardk_, well, pretend that you dont have one, and you need to do this :)
13:27:36 <edwardk_> user317: dust off resume? =)
13:28:22 <edwardk_> well, hrmm, honestly lets think. there is a c++ grammar for antlr that you could use.
13:28:31 <edwardk_> but its a lot of work to make anything usable from
13:28:43 <edwardk_> speaking from experience.
13:28:46 <xpuni> Webradio: * BR-Radio|ElCativO  (ElCativOs Alternative Stream ( http://radio.bitreactor.to:8000/listen.pls )
13:29:15 <user317> edwardk_, is there a C parsec written using parsec somewhere?
13:29:34 <edwardk_> none i know of. but i figure the antlr grammar could be run through happy
13:29:42 <edwardk_> with a little massaging
13:30:32 <user317> c2hs must be somehow parsing C headers
13:30:50 <edwardk_> that might work too, hrmm
13:31:27 <edwardk_> yeah it appears to have one
13:32:03 <edwardk_> http://darcs.haskell.org/c2hs/c2hs/c/CParser.y
13:32:06 <lambdabot> http://tinyurl.com/l4zvt
13:33:37 <edwardk_> there ya go again, answering your own questions.
13:33:37 <edwardk_>  what do you need us for? =)
13:34:31 <user317> edwardk_, work, we have a platform for embedded devices, and we have a major release coming up with tons and tons of changes, our customers will be pissed if source or binary compatibility is broken
13:34:41 <edwardk_> understand
13:35:28 <user317> hehe, i volunteered to try to verify this :), gives me a chance to use something besides C
13:35:59 <edwardk_> I used to write code for routers and for a holographic computer display system (totally different jobs), so fortunately didn't have any customers in my embedded space itself, just users of the devices in question.
13:36:28 <edwardk_> but that explains the embedded pseudo-COM stuff
13:38:37 <user317> edwardk_, yea, its a pia, but its fast and small, just fragile
13:39:28 <SamB> oooooh
13:39:36 <SamB> holographics!
13:40:06 <edwardk_> samb: yeah, one of the weird hats I used to wear. =)
13:40:21 <edwardk_> computer generated holography geek ;)
13:40:37 <SamB> so they really have real-time holographics?
13:40:58 <edwardk_> yeah, its a trick, but its real holography for a single viewer.
13:41:07 <SamB> hmm
13:41:52 <edwardk_> shoot a couple of projectors into a white-light pass-through hologram of a pair of boxes from different viewing angles. getting full spectrum from the projectors is tricky and patented by the company
13:42:13 <edwardk_> so basically each eye sees the image from one of the projectors
13:43:33 <edwardk_> I wrote opengl & direct3d drivers for it that  basically did eye separation and fed back to the hardware ones and code for the inverse perspective transform you have to use to undo the off-axis projection needed for the display box and controlling of the idiot box controls on the screen for adjusting it.
13:44:11 <edwardk_> Then the crook who ran the company screwed me out of a lot of money. I quit and took the entire technical team with me.
13:44:32 <edwardk_> They went off and formed another company with the technology and the holographer from the first company. I sold them what I'd done. Haven't heard much since.
13:44:43 <edwardk_> Intrepid Holographic Display Systems, if you want to try to track it down
13:45:00 <SamB> what did they do about the patent?
13:45:37 <edwardk_> the patents were all held by the holographer, Gaylord Moss, not the company. =)
13:45:48 <SamB> oh cool
13:45:54 <edwardk_> slightly misspoke above.
13:46:02 <SamB> yes you did ;-)
13:46:11 <edwardk_> though they do have to license another one from a 3rd party.
13:46:16 <glguy> The "holographer"?
13:46:34 <SamB> holographician?
13:47:05 <edwardk_> since aparently using any sort of multiple exposure hologram for pass through white light optics is still patented by someone
13:47:16 <edwardk_> holographer is the term I always heard used in the industry.
13:47:45 <SamB> so did he take your hologram for you?
13:47:58 <edwardk_> well, thats not exactly the kind of work we did. ;)
13:48:25 <edwardk_> they did make a hologram of a 5 million dollar famous necklace of some sort though. Can't remember its name.
13:48:43 <SamB> I mean, the one with the boxes...
13:48:49 <glguy> and then stole the necklace
13:48:53 <edwardk_> hahaha
13:48:54 <glguy> and to this day, no one knows?
13:48:55 <edwardk_> I wish =)
13:49:00 <glguy> until now?
13:49:01 <edwardk_> then they would have had the money to pay me ;)
13:49:17 <glguy> what was the practical application?
13:49:25 <edwardk_> for the display or the necklace?
13:49:33 <glguy> for the technology
13:49:55 <glguy> displaying the necklace might be good for convincing people to buy into it, but what did thye do with it to make dollars
13:50:16 <edwardk_> the necklace thing was a proof of full color holographic technology, true color recreation/matching stuff. good enough to fool jewelers looking at it from outside of the box with their instruments, coz the resolution of silver halide is higher than the little hand magnifiers they carry
13:50:35 <glguy> ah
13:51:16 <edwardk_> the displays were for GIS applications mostly. they had some pie-in-the-sky dreams of deals with Coke for vending machines and some other security purposes with stereo cameras.
13:52:03 <edwardk_> but the costs were too high. ~50k/unit.
13:52:35 <SamB> heh
13:52:39 <edwardk_> possibilities to see that as low as $2k after 5 years, but not quickly
13:52:50 <SamB> I could have told you that the coke machine thing was too expensive ;-)
13:52:54 <edwardk_> =)
13:52:56 <edwardk_> yeah
13:53:05 <edwardk_> well, at the $2k/each thing coke was willing to go for it as i recall
13:53:31 <SamB> hmm
13:53:37 <SamB> what was it supposed to do?
13:54:41 <edwardk_> well. basically given a pair of projectors I can show you a stereoscopic image and head track you via a stereo camera so its dead on. secondary viewers just see a monoscopic image if they are looking on from the side.
13:55:50 <edwardk_> so, when I have a reasonably small field of view, say a vending machine or an ATM. I can pop up a 3d display, make it appear to hover in air 'in front' of the screen or on the screen and layer a touch screen over the silver halide
13:55:57 <edwardk_> kinda neat
13:56:10 <edwardk_> I was more interested in the actual unit we had working than the marketing goals
13:56:28 <glguy> I hate marketing people
13:56:38 <glguy> scum of the earth after lawyers
13:57:35 <edwardk_> the ones we were using were basically a box of say a meter cube with arms that came up holding about a 30" silver halide display. the box contained the projectors and the mirrors to hit the screen at the right angle, and the embedded system to electronically correct for the off-axis projection
13:59:01 <edwardk_> so it basically bounced around the projection for a virtual 10 foot throw distance. you then fed the two projectors from a commercial off the shelf 3d video card.
13:59:30 <edwardk_> got the display drivers to work well enough to run quake3 and wolfenstein 3d, which should tell you how long ago it was I worked on this.
14:00:20 <edwardk_> kinda neat actually playing those autostereoscopically.
14:00:28 <edwardk_> there original market was going to be the game market actually
14:00:30 <edwardk_> er
14:00:37 <edwardk_> their
14:06:09 <edwardk_> in any event, the holographic display is easier on the eyes than using shutters, doesn't give you nausea like wearing a headset, and doesn't give you vertigo like polarized lenses, and has better resolution than the cheesy lenticular displays.
14:06:36 <edwardk_> so, despite any hard feelings I may have towards the company, I did think they had something neat.
14:23:59 <glguy> What are the three HTML tags for definitions?
14:24:02 <glguy> <dl><dd>
14:24:05 <glguy> <dt>?
14:24:08 <twanvl> yes
14:24:27 <twanvl> definition-list, -term, -definition
14:24:27 <glguy> <dl><dt><dd> in that order?
14:24:31 <glguy> kk
14:26:25 <dwm> Well, <dl> goes around the other two.
14:26:31 <glguy> right
14:26:35 <glguy> but dt and dd are not nested
14:29:32 <ijoshua> newbie query: I'm trying to understand monads.  What does () mean?
14:29:44 <basti_> () is like "void" in C
14:29:48 <basti_> the type which has only one value
14:29:54 <ijoshua> or nil in Ruby?
14:29:58 <basti_> and that value is - somewhat confusingly - also called ()
14:30:04 <basti_> not really no
14:30:22 <\z> nil is more like undefined or bottom (_|_)
14:30:25 <\z> and also false
14:30:28 <ijoshua> oh, a type, not a value
14:30:44 <basti_> it can be both.
14:30:44 <\z> () is both the type and its solitary value
14:30:47 <basti_> there's a type ()
14:30:52 <sjanssen> @type ()
14:30:54 <lambdabot> ()
14:30:56 <basti_> and it's only value besides "error" is ()
14:31:24 <glguy> basically: data () = ()
14:31:29 <basti_> yea
14:31:31 <lispy> > ()
14:31:33 <lambdabot>  ()
14:31:33 <lispy> ?type ()
14:31:35 <lambdabot> ()
14:31:43 <glguy> > () :: () -- (c;
14:31:43 <ijoshua> in the context of:   put s = State $ \_ -> ((),s)
14:31:44 <lambdabot>  ()
14:31:48 <ijoshua> is it a type or a value?
14:31:56 <lispy> value
14:32:05 <ijoshua> so, a void value?
14:32:13 <lispy> basically
14:32:13 <basti_> yea
14:32:19 <lispy> () is also known as the empty tuple
14:32:22 <glguy> It's a way of returning nothing while still returning something
14:32:25 <monochrom> <dl> <dt>Haskell</dt> <dd>Lazy Pure Function Language</dd> <dt>C</dt> <dd>Hello World Language</dd> </dl>
14:32:53 <ijoshua> ok, I think I understand that
14:32:56 <ijoshua> thanks
14:32:58 <lispy> are we talking in html today? </lisp>
14:33:02 <basti_> It's just like c's "void"
14:33:11 <basti_> just a little more explicit
14:33:19 <lispy> basti_: as a type it is, but C doesn't have a void value
14:33:23 <basti_> the void value in C isn't named.
14:33:37 <basti_> "return;" returns a void value.
14:33:38 <lispy> basti_: it doesn't exist at all does it?
14:33:42 <lispy> hmm...
14:33:50 <basti_> i think that is a pointless question ;)
14:33:52 <monochrom> The value that can be named is not the True Value  *duck*
14:34:00 <lispy> but, void foo = return;  doesn't work :)
14:34:07 <ijoshua> monochrom: :)
14:34:14 <basti_> yea, you can't really save a void value, thats true.
14:34:49 <basti_> however, there's plenty of void values
14:34:54 <ijoshua> monochrom: is this the Tao Te Haskell?
14:35:03 <basti_> and you can't confuse any of them
14:35:08 * lispy thinks he should modify his irc client to  put </lispy> at the end of every thing i say in irc :)
14:35:15 <basti_> so it's also wrong to say there's no void values in C
14:35:23 <Heffalump> C++/GNU C have empty structures, those might be closer
14:35:46 * basti_ nods
14:35:48 <lispy> typedef struct { } empty_t; ?
14:35:49 <sjanssen> doesn't "void" in C mean absence of value, rather than a void value?
14:36:31 <basti_> I'm not entirely sure how "absence of value" is different to "returning a type that has just one possible value"
14:36:45 <basti_> the fact that you returned is C's way of expressing that you returned the one possible value
14:36:55 <dwm> I'm thinking now about how you see plenty of functions returning type void. And you see void *func_ptr things that can have a value of null. But that's the _pointer_ being null, not the void.
14:36:56 <\z> lispy: you should change your nick to <lispy> first.  ;-)
14:37:19 <edwardk_> \z: a lot of clients display with <>'s around the name, like MIRC.
14:37:21 <sjanssen> basti_: it can be passed to another function if it's really a value
14:37:22 <lispy> \z: in my irc client when someone speaks it puts <> around their nick :)
14:37:36 <basti_> sjanssen: well, it can, you just don't notice it. ;)
14:37:38 <dwm> lispy: Mine does that, irssi
14:37:42 <monochrom> "void" is an abstract type with no constructor, deconstructor, accessor, or operation.  How many values inhabit this type you'll never know.
14:37:43 <Heffalump> void is clearly not first-class in the sense that struct {} is
14:37:44 <basti_> I'm being a bit philosophical here
14:37:48 <sjanssen> I don't think: void f(){}; g(f()); is valid, is it?
14:37:55 <basti_> monochrom: thats a point
14:38:20 <lispy> inthat case it would work if g accepts a function pointer
14:38:32 <Heffalump> lispy: no it wouldn't, f() isn't a function pointer
14:38:35 <lispy> in C a function's identifier doubles as its pointer
14:38:38 <\z> void in C is just a type, like int, float, double, and struct *haskell_interpreter
14:38:41 <lispy> hmm...
14:38:45 <lispy> ah yeah, i missed those parens
14:38:47 <basti_> what a bizarre conversation.
14:38:49 <Heffalump> void f(void) confuses the issue further, of course.
14:39:00 <\z> it is literally translated to "don't push anything onto the stack" (or thereabouts)
14:39:03 <Heffalump> the second void isn't really a type at all. It's just "this is an empty parameter list"
14:39:09 <monochrom> However, for the purpose of typed logic, you can always assume each type is inhabited.
14:39:24 <edwardk_> too bad you can't just put a / after your nick, lispy. =)
14:39:32 <edwardk_> then it would just be <lispy/>
14:39:33 <edwardk_> =)
14:39:37 <\z> void* is a pointer type, so it has a size of a generic pointer, but it can't be de-referenced, so it points to an opaque block of memory
14:39:41 <edwardk_> very self-contained humor
14:39:54 <Heffalump> not very opaque given that you can cast it :-)
14:40:10 <\z> casting is another thing entirely
14:40:20 <\z> you can cast an int into a double, or more reasonably a double into an int
14:40:29 <\z> you can't cast a void, because voids don't exist
14:40:30 <monochrom> OK, the most consistent way to understand C is to treat "void" as syntactic sugar for something totally different.
14:40:51 <\z> you can cast a void* into an int* or a struct haskell_interpreter* and pretend there's something meaningful hiding behind that void*
14:40:58 <\z> yeah
14:41:27 <\z> C's void doesn't really translate into the empty tuple
14:41:38 <\z> you can have two void*'s that are totally unrelated
14:42:29 <twanvl> void* is more like an (exists a. a)*
14:45:18 <lispy> yeah, i'd say the meaning of void in void foo() {} is quite a bit different than void *
14:46:50 <dwm> But you could have void *foo() { /* return some fp or null */ }
14:47:17 <\z> dwm: right.  with return types, void* returns *something*, void returns *nothing*
14:47:20 <dwm> Is it an error to void foo() { return null; }  ?
14:47:35 <\z> dwm: yes.  null is a value
14:47:47 <\z> it's also an error to declare a parameter or a variable as type null.  that' can't exist.
14:49:37 <dwm> There is no type 'null' but it's that catch-all value of nothingness that can sit in many types.
14:49:52 <dwm> Is that accurate?
14:50:10 <\z> there is no type null in c, because null is a value
14:50:16 <\z> it usually has type int*
14:51:27 <\z> because null has one and only one value, it's typically used as a sentinal, as in a null pointer (like [] in a:[b:[c:[]]])
14:51:47 <\z> it's usually a pointer to memory address 0x00000000, but not necessarily
14:52:50 <int-e> what sort of syntax is that?
14:52:57 <twanvl> #haskell is now known as #c?
14:53:10 <int-e> a:b:c:[] is Haskell
14:53:57 <int-e> a:[b:[c:[]]] is a list of lists of lists ... probably not what you want.
14:54:16 <\z> right.  I meant a:(b:(c:[]))
14:54:28 <monochrom> :[ :(  :)
14:55:02 <int-e> ok. you don't need the parentheses there, : is right associative.
14:55:29 <monochrom> <dl> <dt>APL</dt> <dd>Punctuation Language</dd> <dt>Haskell</dt> <dd>Emoticon Language</dd> </dl>
14:56:35 <monochrom> APL: Punctuation Language.  Haskell: Emoticon Language.  COBOL: English Language.  :)
14:56:43 <deadbeef> > Array.array (1, 10) [ (x, x * x) | x <- Array.range (1, 10) ]
14:56:43 <lambdabot>  Not in scope: `Array.range'
14:57:03 <int-e> ?!
14:57:03 <monochrom> Ix.range?
14:57:04 <lambdabot> Maybe you meant: . v
14:57:05 <int-e> [1..10]
14:57:15 <deadbeef> > array (1, 10) [ (x, x * x) | x <- range (1, 10) ]
14:57:16 <lambdabot>  array (1,10) [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(1...
14:57:18 <deadbeef> here it is
14:57:58 <int-e> > range ((1,1), (2,2))
14:57:59 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
14:58:10 <deadbeef> > (array (1, 10) [ (x, x * x) | x <- range (1, 10) ])!5
14:58:11 <lambdabot>  25
14:59:15 <monochrom> (:):(:):(:):[]
14:59:29 <deadbeef> > (:):(:):(:):[]
14:59:30 <lambdabot>  Add a type signature
14:59:45 <monochrom> It has no Show functionality.
15:00:37 <int-e> > (:):(:):(:):[] :: [Int -> [Int] -> [Int]]
15:00:38 <lambdabot>  [<Int -> [Int] -> [Int]>,<Int -> [Int] -> [Int]>,<Int -> [Int] -> [Int]>]
15:00:52 <monochrom> Darn, it does.
15:01:04 <SamB> hah!
15:01:17 <SamB> hmm
15:01:34 <int-e> > (:):(:):(:):[] :: [() -> [()] -> [()]] -- more smiley-ish
15:01:36 <lambdabot>  [<() -> [()] -> [()]>,<() -> [()] -> [()]>,<() -> [()] -> [()]>]
15:01:48 <monochrom> >,<
15:02:28 <lispy> heh
15:02:37 <kpreid> > ((:):(:):[]):((:):(:):[]):[]
15:02:38 <lambdabot>  Add a type signature
15:03:10 <int-e> > ((:):(:):[]):((:):(:):[]):[] :: [[() -> [()] -> [()]]]
15:03:12 <lambdabot>  [[<() -> [()] -> [()]>,<() -> [()] -> [()]>],[<() -> [()] -> [()]>,<() -> [(...
15:03:17 <int-e> ow.
15:03:30 <kpreid> that's...not what I wanted
15:03:44 <int-e> no?
15:04:12 <kpreid> > let f x = (:):(:):[f] in (f 1,f)
15:04:13 <lambdabot>  Couldn't match `[a] -> [a]' against `[a -> [a] -> [a]]'
15:04:22 <kpreid> > let f x = (:):(:):[x] in (f 1,f)
15:04:23 <lambdabot>  add an instance declaration for (Num (a -> [a] -> [a]))
15:05:35 <kpreid> > let x = (:):(:):[] in (head x) 1 `seq` x
15:05:36 <lambdabot>  Add a type signature
15:05:53 <kpreid> > let x = (:):(:):[] in (head x) "" `seq` x
15:05:54 <lambdabot>  Add a type signature
15:06:10 * kpreid quits
15:13:03 <edwardk> Anyone here tried Coq/Twelf/Yarrow at all?
15:13:54 <monochrom> I tried Coq a long time ago.
15:15:39 <edwardk> I'm currently trying to get my head around embedding display logic in coq. debating about whether twelf or yarrow might be more appropriate given their more lambda calculus-ish roots.
15:15:57 <edwardk> though I think more people know Coq.
15:18:12 <ndm> @seen lispy
15:18:12 <lambdabot> lispy is in #oasis, #darcs, #haskell-blah and #haskell. I last heard lispy speak 15m 44s ago.
15:18:14 <ndm> @seen dons
15:18:15 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 4h 17m 13s ago.
15:18:28 <ndm> @karma+ lispy -- lambdabot website
15:18:29 <lambdabot> lispy's karma raised to 12.
15:54:35 <deadbeef> wondering if Arrays are also lazy
15:56:26 <monochrom> Yes they are.
15:56:32 <deadbeef> amazing
15:58:20 <monochrom> let r = listArray (0,3) ( False : [ not (r!(i-1)) | i <- [1..3] ] )
15:58:52 <monochrom> This is what you gain from laziness.  When defining an array element, you can refer to other elements.
15:59:09 <deadbeef> what's the : ?
15:59:11 <deadbeef> ah ok
15:59:28 <monochrom> x:y = [x]++y
15:59:45 <deadbeef> yes
15:59:46 <deadbeef> Cons
15:59:47 <monochrom> Need a base case, even with laziness :)
16:00:30 <deadbeef> so when you access r!n
16:00:35 <monochrom> Probably easier to read: let r = listArray (0,3) [False, not(r!0), not(r!1), not(r!2)]
16:00:51 <deadbeef> you evaluate r!0, r!1, .., r!n
16:01:08 <deadbeef> ah ok
16:01:21 <deadbeef> and you get [False, True, False, True, ..]
16:01:22 <deadbeef> ok
16:01:24 <deadbeef> thanks
16:01:38 <deadbeef> ops
16:01:49 <deadbeef> s/, ..//g
16:02:55 <deadbeef> so it's likey
16:02:57 <deadbeef> *like
16:03:07 <deadbeef> you can transpose a matrix and stuff without evaluating its values
16:03:08 <deadbeef> amazing
16:04:19 <int-e> yes. but dangerous, too.
16:04:26 <deadbeef> why ?
16:04:29 <int-e> as always with lazyness.
16:04:43 <int-e> you can add 1 to an array element without actually evaluating the addition
16:05:16 <monochrom> Thus dynamic programming (at least when using arrays) is trivial in Haskell.  Recall that when you learn dynamic programming, a great deal of time is spent on "setting the array elements in the right order".  Well Haskell figures that out for you.  Just write down the recurrence in Haskell notation.
16:05:57 <lennart> yeah, that's pretty cool.  I've used it on occasion.
16:06:01 <int-e> deadbeef: if you do that a few thousand times and then force the value, you'll get a stack overflow (in ghc at least)
16:07:47 <deadbeef> on swi-prolog there's an option to use all the memory you can
16:08:00 <deadbeef> so that the only limit is the hw
16:18:50 <newsham> are there functions for joining and splitting filename paths in the standard libs?
16:19:18 <newsham> closest I found is joinPaths in Distribution.Compat.FilePath (cabal)
16:20:15 <ndm> newsham: use System.FilePath
16:20:16 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
16:20:33 <ndm> newsham: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
16:20:36 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
16:20:51 <newsham> no such thing, according to ghc docs.
16:21:11 <ndm> newsham: see the library i linked to - its going to end up in base, by 6.8
16:21:28 <newsham> i'm not using 6.8 :\
16:21:33 <ndm> no one is
16:21:40 <ndm> as it stands, install that library, and use that
16:21:50 <ndm> already used by Hoogle, Yhc, and a few other projects
16:21:50 <newsham> i'm not usign non-std libs
16:21:53 <ndm> and soon by lambdabot
16:22:03 <ndm> in that case hack it up yourself, and want it break on windows :(
16:22:52 <ndm> @tell dons patches welcome for hoodoc :) - you are right of course, and thanks for hacking up the keyword stuff
16:22:53 <lambdabot> Consider it noted.
16:23:10 <newbcoder> ocaml has cil; does haskell have anything like that?
16:23:35 <sjanssen_> what is cil?
16:23:56 <newbcoder> c parser
16:24:16 <ndm> @karma+ dons -- keyword stuff, since it was on my todo list
16:24:16 <lambdabot> dons's karma raised to 69.
16:24:17 <edwardk> newb: there is one baked into c2hs if you want to extract it
16:24:24 <lispy> newbcoder: someone as writing a C parser for haskell for a summer of code project
16:24:34 <ndm> dons: hehe, karma 69 - ndm giggles like a school girl...
16:24:40 <lispy> ndm: we have new karma syntax you can just do foo++
16:24:45 <sjanssen_> @karma foo
16:24:46 <lambdabot> foo has a karma of 0
16:24:52 <lispy> foo++
16:24:54 <lispy> @karma foo
16:24:55 <lambdabot> foo has a karma of 1
16:24:58 <sjanssen_> does it work midsentence? foo++
16:25:00 <sjanssen_> @karma foo
16:25:01 <lambdabot> foo has a karma of 1
16:25:05 <ndm> lispy: i know, but i like the old school one :)
16:25:08 <newbcoder> @karma newbcoder
16:25:09 <lambdabot> You have a karma of 0
16:25:16 <newbcoder> newbcoder++
16:25:18 <newbcoder> newbcoder++
16:25:19 <newbcoder> newbcoder++
16:25:23 <newbcoder> @karma newbcoder
16:25:24 <lambdabot> You have a karma of 0
16:25:26 <edwardk> what can haskell compile down to?
16:25:28 <edwardk> c--
16:25:28 <newbcoder> sigh
16:25:29 <ndm> foo--
16:25:32 <edwardk> =)
16:25:35 <ndm> @karma foo
16:25:35 <lambdabot> foo has a karma of 0
16:25:38 <edwardk> @karma c
16:25:39 <lambdabot> c has a karma of -2
16:25:44 <edwardk> I like
16:25:45 <edwardk> C++
16:25:47 <edwardk> @karma C
16:25:48 <lambdabot> C has a karma of 2
16:25:58 <ndm> @karma c
16:25:58 <lispy> edwardk: C is ignored
16:25:59 <lambdabot> c has a karma of -2
16:26:05 <edwardk> C++ is neat.
16:26:07 <edwardk> @karma C
16:26:07 <sjanssen_> C++++
16:26:08 <lambdabot> C has a karma of 2
16:26:09 <lispy> at least c++ is
16:26:12 <sjanssen_> @karma C++
16:26:13 <lambdabot> C++ has a karma of 0
16:26:13 <edwardk> ah
16:26:24 <edwardk> VisualJ++ is also neat
16:26:26 <int-e> java--
16:26:26 <ndm> lispy: whats the lambdabot link again - on a different system here
16:26:26 <edwardk> @karma VisualJ
16:26:28 <lambdabot> VisualJ has a karma of 2
16:26:40 <edwardk> VisualJ++ lalala
16:26:42 <AstralStorm> Oh no, karmic monsters!
16:26:44 <AstralStorm> :>
16:26:45 <edwardk> @karma VisualJ
16:26:46 <lambdabot> VisualJ has a karma of 3
16:26:51 <edwardk> heh
16:27:00 <monochrom> children
16:27:17 <int-e> shh, pay attention, monochrom is speaking.
16:27:21 <edwardk> I need to name a language with ++ in its name just so I can give it karma ;)
16:27:40 <edwardk> or rather make one, then make a ++ version I can talk about
16:27:50 <AstralStorm> edwardk: what about brainfuck==?
16:29:13 <edwardk> never liked language names I had to censor. ;)
16:29:22 <edwardk> though I did want to name a language sex once.
16:29:33 <edwardk> Coz no programmer would say his language was better than sex.
16:30:53 <edwardk> dead silence.
16:30:54 <edwardk> =)
16:31:03 * ndm thinks edwardk hasn't met that many programmers...
16:31:27 <edwardk> ndm: hehe, well, most of them would lack a reference point to compare against =P
16:31:39 <shrimpx> haha
16:31:55 <newbcoder> edwark: your life does not generalixe to the programming population
16:32:18 <edwardk> I would dare say that it doesn't ;)
16:36:11 <vincenz> edwardk--
16:36:39 <edwardk> In any event I figured that 'style' was a safer name. coz then you'd get jokes like 'programming in style', etc.
16:36:43 <edwardk> much higher brow
16:36:44 <edwardk> woot
16:36:47 <edwardk> @karma edwardk
16:36:48 <lambdabot> You have a karma of -2
16:36:51 <edwardk> =)
16:36:59 <edwardk> i'm a troll baybee! =)
16:37:03 <edwardk> just a very slow one
16:38:53 * edwardk wanders off to study the coq.
16:39:57 <jbalint> coq?
16:40:06 <edwardk> proof system
16:44:32 <mwolak> is it possible to define MonadState without MPTCs?
16:45:39 <sjanssen_> mwolak: no
16:46:09 <mwolak> thanks. That would explain why I was unable to do it :P
16:51:12 <bringert> grr
16:51:21 * bringert doesn't like airlines
16:51:48 * bringert has been at chicago o'hare for 6.5h now
16:51:59 <bringert> another 2.5h to go
16:52:02 <edwardk> anyone going to icfp?
16:52:07 <bringert> yep
16:52:10 <edwardk> cool =)
16:52:21 <bringert> if I get there
16:52:25 <edwardk> *nods*
16:52:35 <edwardk> I get there saturday so I'll miss the hackathon
16:52:58 <bringert> if anyone is flying in, remember not to bring toothpaste, liquor etc
16:53:01 <edwardk> put in a word for monad comprehensions for us ;)
16:53:17 <edwardk> oh yeah forgot about the current madness
16:53:20 <bringert> :-)
16:53:36 <coffeemug> evening, everyone
16:54:01 <bringert> I just found out that -threaded can now use both cores on my macbook, so I'm thinking I should add a-j flag to ghc --make
16:54:18 <bringert> terror alert level hotpink or whatever it is
16:54:32 <bringert> at least they let me in the country
16:54:33 <edwardk> well thas one way to burn the intervening 2.5 hours and then some of your flight ;)
16:54:43 <edwardk> *nods*
16:54:57 <bringert> evening coffeemug
16:55:02 <edwardk> heh, I have enough trouble in american airports these days, and I live here ;)
16:55:20 <bringert> any other haskellers heading to portland stuck at O'Hare by any chance?
16:55:20 <bringert> if so, wanna grab a beer?
16:55:59 <coffeemug> I was flying to france a week ago
16:56:03 <coffeemug> on my flight there and back
16:56:09 <coffeemug> they gave us real metal knives
16:56:18 <coffeemug> which were pretty big by general standards
16:56:31 <coffeemug> yet I couldn't bring in a nail clipper in carry on
16:56:36 <edwardk> heh
16:56:47 <coffeemug> makes me think that the only reason nobody hijacked a plane since 9/11 is because nobody really tried
16:59:22 <ndm> i'm worried that you can't bring on a water bottle, but semtex is just fine...
16:59:31 <sjanssen_> bringert: at one point setting +RTS -N 2 would make ghc --make parallel.  Not sure if that's still in or not
16:59:35 <bringert> darcs is great when you are flying. hack away, and record. they push when you get there
16:59:48 <bringert> sjanssen_: ah, I'll try
17:00:44 <coffeemug> darcs is excellent for some types of projects
17:00:49 <coffeemug> and completely horrific for others
17:01:07 <ndm> coffeemug: horrific for what?
17:01:42 <coffeemug> ndm: there are a few cases where darcs really fails
17:01:53 <ndm> coffeemug: care to give examples?
17:01:53 <coffeemug> one is well known and it's the fact that you can't check out a particular folder
17:02:07 <coffeemug> so if your repository really grows
17:02:14 <ndm> but you can wget a particular folder easily enough
17:02:18 <ndm> if you do darcs over http
17:02:23 <coffeemug> sure
17:02:30 <coffeemug> but that just gives you a source
17:02:33 <coffeemug> not source control
17:02:41 <ndm> true
17:02:42 <coffeemug> you can't record
17:02:43 <coffeemug> or push
17:02:49 <coffeemug> so for big projects and big teams
17:02:52 <coffeemug> it's a big problem
17:02:54 <ndm> i guess if you have a patch based system, you don't have much chance of doing directory only
17:03:02 <coffeemug> well
17:03:07 <coffeemug> the thing is
17:03:10 <sjanssen_> at that point, shouldn't you split the project into multiple small projects?
17:03:21 <coffeemug> there is nothing in darcs that I am aware of that lets you split a repository into multiple smaller repositories
17:03:33 <ndm> coffeemug: cp, rm ?
17:03:41 <sjanssen_> coffeemug: cp -r the directory a couple times, then darcs rm the stuff that doesn't belong
17:03:55 <coffeemug> right
17:03:59 <coffeemug> but then the shared history is gone
17:04:08 <ndm> no, its not
17:04:20 <coffeemug> I mean
17:04:21 <ndm> the history is a static thing, so making two copies of it preserves it
17:04:23 <coffeemug> it is no longer shared
17:04:38 <ndm> true, but thats merely a disk space issue - which is minor
17:04:54 <coffeemug> well
17:04:59 <coffeemug> it's not just a diskspace issue
17:04:59 <bringert> hmm, ghc --make +RTS -N2 -RTS compiles *a lot* faster, but still uses only one core. And type checking fails for a module which compiles fine without the RTS flags
17:05:07 <sjanssen_> this seems like a pretty hypothetical situation . . .
17:05:15 <coffeemug> but anyway
17:05:18 <coffeemug> this is my guess
17:05:21 <coffeemug> not something I ran into
17:05:25 <coffeemug> one thing I did run into
17:05:31 <coffeemug> and which is a big problem IMO
17:05:41 <coffeemug> is inability to do "weak" patches
17:05:45 <sjanssen_> bringert: I wonder if GHC is compiled with the threaded RTS?
17:06:03 <coffeemug> so for example let's say I modify comments in ten files
17:06:14 <sjanssen_> and that type checking problem is surely a bug
17:06:25 <coffeemug> I record it
17:06:39 <coffeemug> then if I want to propagate it I have to push ALL ten files
17:06:45 <coffeemug> even though they don't depend on each other
17:07:01 <sjanssen_> coffeemug: record each comment change separately?
17:07:23 <coffeemug> sj: that's what I do now
17:07:26 <wkh> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml i think these benchmarks could be improved if someone converted the examples that use haskell strings to use bytestring
17:07:28 <coffeemug> that's pretty unintuitive
17:07:32 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/glm93
17:07:35 <ndm> coffeemug: if you record a pile of things together, its because you know they are a unit, surely? (something cvs makes very painful)
17:07:53 <sjanssen_> wkh: do they have ByteString installed?
17:07:54 <coffeemug> yeah
17:07:55 <ndm> wkh: no bytestring until 6.6 is out, which is when dons will convert EVERY SINGLE benchmark to ByteString :)
17:07:58 <coffeemug> but it's a pain in the ass
17:08:14 <ndm> coffeemug: a different mental model - one which i find more natural
17:08:17 <wkh> ndm: ok.
17:08:39 <coffeemug> well
17:08:43 <coffeemug> I have to do record ten times
17:08:48 <int-e> why?
17:08:58 <coffeemug> what I'd like to do is record once and say that it's a "weak" patch
17:09:03 <int-e> why do you want 10 separate patches?
17:09:05 <coffeemug> so files don't depend on each other
17:09:33 <coffeemug> int-e: because if files dont' depend on each other I may want to pull them separately in other branches
17:09:44 <coffeemug> int-e: and if I record something as one patch I can't do that
17:09:52 <ndm> coffeemug: should each line of comment be separate, or each file be separate?
17:10:00 <int-e> you want rcs, right?
17:10:03 <coffeemug> ndm: each file
17:10:21 <ndm> coffeemug: each enough to add a darcs mode that invoked record for each file individually]
17:10:30 <ndm> *easy
17:10:35 <coffeemug> yeah it's pretty easy
17:10:39 <ndm> its not a new type of patch, its a new type of UI
17:10:45 <coffeemug> you can even do a script that calls darcs appropriately
17:10:51 <coffeemug> right
17:11:03 <ndm> if you hacked it up, they might even accept a patch with a --separate flag for record
17:11:13 <ndm> (although something in me guesses they would reject it)
17:11:30 <bringert> sjanssen_: ok, the type checking thing was my fault, or possibly GNU make's.
17:12:07 <coffeemug> I don't know, it just feels like subversion is much better if I had a company of 20 developers
17:12:10 <bringert> when I used the RTS flags, they replaced the existing GHCFLAGS, which had the effect of turning off extensions, and optimization
17:12:15 <bringert> hence the fast compile
17:12:26 <coffeemug> but for projects that are shared over the web and have a few developers
17:12:31 <coffeemug> or even one developer
17:12:34 <coffeemug> darcs is excellent
17:13:03 <coffeemug> that's what I use for my website
17:13:07 <coffeemug> and for personal projects
17:13:11 <coffeemug> and I absolutely love it
17:13:38 <coffeemug> another big problem with darcs is inability to push via ftp
17:13:55 <coffeemug> I'd say it's the single biggest problem I've ecountered so far
17:21:02 <newsham> I'm getting a runtime error (Exception: Prelude.(!!): index too large).  Whats the best way to track down where this is happening?
17:22:43 <newsham> are there any tools that would track this exception back to a line number in src?
17:24:11 <int-e> I usually add `trace` calls in suspicious locations
17:24:25 <sjanssen_> coffeemug: yeah, that is a major annoyance of mine too
17:29:53 <coffeemug> sjanssen: I use NetDrive to remedy that
17:30:01 <coffeemug> you can't use field labels in newtype?
17:30:25 <sjanssen_> newsham: http://www.haskell.org/pipermail/haskell-cafe/2006-February/014723.html
17:30:28 <lambdabot> Title: [Haskell-cafe] Code snippet, a `trace' with line and column numbers, http://tinyurl.com/fsqfj
17:30:29 <sjanssen_> coffeemug: yeah, you can
17:30:46 <sjanssen_> you aren't trying to put more than one field in there, are you?
17:30:59 <coffeemug> yeah
17:31:00 <coffeemug> why?
17:31:14 <sjanssen_> can't do that, use data
17:31:26 <coffeemug> ah
17:31:27 <coffeemug> why is that?
17:32:20 <sjanssen_> newtype is supposed to be a wrapper around an existing type -- like a type synonym with added checking
17:32:57 <lispy> okay, looks like i'll be at the haskell-workshop
17:33:01 <lispy> anyone else going to be there?
17:33:08 <lispy> it would be nice to say hi in person
17:33:11 <bringert> lispy: I will
17:33:17 <weitzman> lambdabot has spoiled me. It makes the actually interactive console in WinHugs seem very lame
17:33:23 <lispy> bringert: ah, cool.  BTW, i have some questions about fastcgi now
17:33:27 <bringert> assuming this plane every arrives
17:33:36 <lispy> bringert: at the airport now?
17:33:40 <bringert> yeo
17:33:45 <lispy> cool
17:33:47 <bringert> well, an airport
17:33:51 <bringert> O'Hare
17:34:00 <bringert> I start travelling about 20 hours ago
17:34:01 <sjanssen_> the restrictions in newtype allow for a more efficient representation in the compiler
17:34:03 <bringert> ed
17:34:06 <lispy> wow
17:34:18 <lispy> bringert: our code to interact with lambdabot works great from inside of ghci
17:34:37 <lispy> bringert: but when we put it on the web it starts dropping characters in the outptu
17:34:46 <bringert> hmm
17:35:00 <lispy> bringert: it starts dropping the first n characters and then n+1 then n+2...
17:35:06 <ndm> weitzman: why is the WinHugs console lame?
17:35:09 <lispy> pretty soon you get no data
17:35:13 <bringert> weird
17:35:33 <bringert> so you run a single lambdabot on the server, and has fastcgi processes which connect to it?
17:35:35 <ndm> weitzman: the successor to WinHugs, GuiHaskell, will offer all the goodness of lambdabot plus the existing winhugs
17:35:37 <lispy> bringert: well, i wonder if it could be a bug in the way we manage lambdabot  state + apache threads + fastcgi
17:35:44 <bringert> eh, modolo correct grammar
17:35:47 <weitzman> ndm: A couple things I've noticed. One is that there are expressions that I can get the type of from lambdabot and not from hugs
17:36:10 <weitzman> @type ((+ 1) >> =)
17:36:11 <lambdabot> parse error on input `='
17:36:15 <weitzman> Oops
17:36:17 <lispy> bringert: the fast cgi starts a lambdabot process, saves away handles to cummunicate with it and then in runFastCGI it sends/recives with lambdabot
17:36:18 <weitzman> @type ((+ 1) >>=)
17:36:20 <lambdabot> forall a b. (Num a) => (a -> a -> b) -> a -> b
17:36:23 <weitzman> That doesn't work in hugs
17:36:27 <weitzman> *** Instance   : Monad ((->) a)
17:36:27 <weitzman> *** Expression : (flip (+) 1 >>=)
17:36:33 <ndm> Hugs> :t ((+ 1) >>=)
17:36:34 <ndm> (flip (+) 1 >>=) :: (Monad ((->) a), Num a) => (a -> a -> b) -> a -> b
17:36:35 <sjanssen_> weitzman: load Control.Monad.Reader
17:36:38 <lispy> bringert: i'll find the code and show you
17:36:43 <lispy> ?whree goa
17:36:44 <lambdabot> Maybe you meant: free where where+
17:36:46 <bringert> lispy: what kind of fastcgi process do you use? dynamic, external, etc?
17:36:48 <weitzman> Well now I'm just confused
17:36:48 <lispy> ?where goa
17:36:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
17:36:55 <lispy> bringert: i don't know...
17:37:03 <bringert> probably dynamic then
17:37:04 <ndm> weitzman: make it haskell extensions, options/allow Hugs/GHC Extensions
17:37:16 <lispy> bringert: http://www.cse.unsw.edu.au/~dons/code/goa/fcgi/bot.hs
17:37:18 <lambdabot> http://tinyurl.com/hrwtu
17:37:21 <bringert> so apache can start several fastcgi processes if needed
17:37:27 <weitzman> ndm: Ah. Cool, I'll try that
17:37:45 <weitzman> ndm: Do I want overlapping instances? No idea what that is
17:37:50 <ndm> but lambdabot does have much goodness WinHugs is missing
17:38:00 <weitzman> ndm: I also want an @index command
17:38:01 <ndm> weitzman: no, probably not - just hte basic extensions is usually plenty
17:38:15 <ndm> well that will be in GuiHaskell, along with Hoogle etc
17:38:21 <weitzman> cool
17:38:22 <lispy> bringert: wakeup starts the lambdabot process and cgiMain is where we communicate with lambdabot
17:38:34 <ndm> weitzman: have you seen :f ? I usually find its better than @index
17:38:56 <bringert> if you have one lambdabot per fastcgi process, you might just as well compile lambdabot into the fastcgi program
17:38:58 <weitzman> ndm: I tried using :f once and didn't get any results
17:39:00 <bringert> right?
17:39:19 <lispy> bringert: that should be equivalent, but can we do that without modifying lambdabot ?
17:39:22 <ndm> weitzman: have you got an editor installed? like TextPad which WInHugs can communicate with? if so do :f take
17:39:29 <lispy> bringert: this seemed the least intrusive to lambdabot
17:39:37 <bringert> lispy: depends on lambdabots API I guess
17:39:41 <bringert> lispy: true
17:39:58 <bringert> so do you know where the output gets dropped?
17:40:10 <lispy> bringert: i have this setup, want to play with it?
17:40:14 <ndm> lispy: it worked fine when running a hoogle command
17:40:16 <weitzman> ndm: Seems to work for some of the names I'm trying now. Can't remember what I was looking for earlier
17:40:20 <bringert> lispy: sure
17:40:32 <ndm> weitzman: only works for things which have been :load'd
17:40:35 <lispy> bringert: http://lambdabot.codersbase.com/bot.fcgi
17:40:41 <ndm> weitzman: although usually hoogle is a better choice than @index
17:40:42 <weitzman> ndm: Example: (:f ap)
17:40:42 <bringert> I could try it on my machine too
17:40:46 <weitzman> ndm: Maybe I have to load it
17:40:59 <lispy> bringert: i think it starts to drop output when there is an error but, from ghci the same sequence of commands doesn't cause a problemm
17:41:02 <ndm> weitzman: try the hoogle online interface, it gives maximum goodness :)
17:41:14 <lispy> bringert: oh and from the web you don't need to use @, so just type, 'hoogle map' for exampl
17:41:16 <weitzman> ndm: But I'm a clueless newbie and I don't know what I'm looking for
17:41:33 <ndm> weitzman: which makes hoogle all the more useful!
17:41:37 <weitzman> ndm: Well, lambdabot gives me hoogle on the interactive promp!
17:41:51 <ndm> weitzman: but not as much hoogle goodness as the web version
17:41:53 <ndm> @where hoogle
17:41:53 <lambdabot> http://www.haskell.org/hoogle
17:41:55 <lispy> weitzman: you can intgrate lambdabot into ghci
17:42:15 <lispy> weitzman: it's called ghci on acid if you're interested
17:42:28 <bringert> lispy: hmm, yeah, it doesn't drop more for every command
17:42:48 <bringert> have you figured out what increments the number of chars dropped?
17:42:52 <lispy> hmm..maybe 'haddock map' is the one that triggers the bug
17:43:03 <lispy> and it's the only one that does
17:43:09 <lispy> i'll try it in ghci again
17:43:13 <weitzman> ndm: Also, @pl and @undo have been hlepful to me in my evil experimenting
17:43:16 <ndm> lispy: vixen asl did it for me
17:43:27 <lispy> ndm: but ith ink that was after i ran 'haddock map'
17:43:51 <weitzman> ndm: So I when I started using the command prompt, my experience was that half the commands I use are missing and typechecking isn't the same as lambdabot, for reasons not clear to me
17:44:24 <weitzman> ndm: Which is not a good first experience
17:44:37 <lispy> from ghci i see no problem
17:44:56 <ndm> weitzman: true, the successor to WinHugs will have full lambdabot support
17:44:56 <lispy> wait a sec
17:45:10 <lispy> i might be running the wrong lambdabot binary
17:45:31 <newsham> > normalizeTimeDiff noTimeDiff noTimeDiff
17:45:32 <lambdabot>  Not in scope: `noTimeDiff'
17:45:39 <newsham> > normalizeTimeDiff
17:45:40 <lambdabot>  Not in scope: `normalizeTimeDiff'
17:45:50 <newsham> hmm, thats in the docs but not in my ghc.
17:46:05 <lispy> oh, no, that shouldn't be the problem
17:46:06 <weitzman> ndm: I look forward to using it. Alas, I suspect at my current level I can't do anything to help hasten the next release of the next WinHugs
17:46:19 <lispy> ah ha!
17:46:25 <lispy> it's a problem with GOA after all
17:46:26 <bringert> lispy: you should probably set the content-type to text/plain for the output by the way, or wrap it in a <pre>
17:46:33 <weitzman> I'm very bad at typing sentences. I always rewrite them halfway through :(
17:46:36 <ndm> weitzman: no one can, not even me (and i'm writing it!) - its stuck on a deep bug in someone elses stuff
17:46:40 <lispy> bringert: oh, i used to have it doing that
17:47:00 <lispy> bringert: but i guess in this version of bot.hs i broke lost that
17:47:28 <lispy> bringert: also, i noticed that fastcgi depends on cgi
17:47:34 <lispy> bringert: but i could only find cgi-compat
17:47:35 <bringert> it would cool with an ajax thing that send each commend and added the output to the current page
17:47:43 <bringert> lispy: ah, right
17:47:49 <lispy> bringert: so i just changed fastcgi.cabal to depend on cgi-compat
17:47:59 <lispy> bringert: it certainly would
17:48:00 <bringert> it has gotten a little messy now that cgi will come with ghc 6.6
17:48:24 <lispy> bringert: but, id on't know how to do ajax..and the main goal is to make lambdabot a webservice
17:48:39 <lispy> bringert: or at least something we can ping from the google home  page :)
17:48:47 <bringert> sure, and it's great
17:49:09 <lispy> so 1) i'll submit a bug report to dons about GOA
17:49:18 <lispy> 2) ???
17:49:20 <lispy> 3) Profit
17:49:42 <bringert> maybe someone could use joel bjornson's javascript combinators to implement the ajax thing
17:50:02 <bringert> and it would use your service for the back-end
17:50:09 <lispy> ah good idea
17:50:14 <lispy> btw, how do i set the content type?
17:50:15 <weitzman> ndm: Example of more confusion: How can I get "mfix" in scope of evaluated expressions  in hugs?
17:50:34 <ndm> @hoogle mfix
17:50:35 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
17:50:42 <ndm> weitzman: import Control.Monad.FIx
17:50:43 <bringert> lispy: setHeader "Content-type" "text/plain"
17:51:02 <lispy> bringert: and do that in cgiMain?
17:51:13 <lispy> oh hm..
17:51:14 <weitzman> ndm: Typing that at the prompt doesn't seem to work
17:51:15 <bringert> yeah
17:51:24 <lispy> oh, i see where i want to do that
17:51:25 <ndm> weitzman: lambdabot imports a lot of stuff at any given time, way more than any interpretter
17:51:33 <ndm> weitzman: :l Control.Monad.Fix
17:51:53 <weitzman> "Warning: Shell escape terminated abnormally"
17:52:13 <ndm> weitzman: Hugs or WinHugs?
17:52:16 <weitzman> WinHugs
17:52:31 <weitzman> It made a dos prompt appear and disappear, briefly
17:52:35 <ndm> May 2006?
17:52:41 <weitzman> Yes
17:52:54 <ndm> hmm, you might have it configured for cpp support
17:53:12 <lispy> http://lambdabot.codersbase.com/bot.fcgi?cmd=hoogle+map
17:53:16 <lambdabot> http://tinyurl.com/kcgvo
17:53:16 <lispy> okay now that displays correctly
17:53:38 <weitzman> ndm: I haven't changed anything but enabling the haskell extensions a minute ago
17:53:51 <weitzman> ndm: It's the more complete version of winhugs (not minhugs)
17:54:11 <ndm> weitzman: doesn't make any difference in this case between them
17:54:30 <ndm> weitzman: can you type ":set" then give me the last 5 lines of output
17:54:39 <weitzman> Current settings: +quAR -stgl.QwkoOITH -h1000000 -p"%s> " -r$$ -c40
17:54:39 <weitzman> Search path     : -P.;{Hugs}\packages\*
17:54:39 <weitzman> Source suffixes : -S.hs;.lhs
17:54:39 <weitzman> Editor setting  : -EC:\WINDOWS\notepad.exe
17:54:39 <weitzman> Compatibility   : Hugs Extensions (-98)
17:55:10 <weitzman> That's some intense configuration
17:55:42 <deadbeef> omg notepad.exe
17:55:43 <weitzman> For what it's worth, now when I run (!:) there's no output, although it doesn't seem to bring anything new into scope
17:56:28 <ndm> weitzman: don't do !:, ever!
17:56:38 <ndm> type ":load Control.Monad.Fix"
17:56:52 <weitzman> ndm: It was (:1 Control.Monad.Fix) actually. I passed an argument
17:57:04 <ndm> no need for ! - that indicates a shell escape, which WinHugs won't be particularly helpful
17:57:11 <ndm> its :l (as in L)
17:57:17 <ndm> no need for the brackets
17:57:24 <ndm> literally, the following without the quotes:
17:57:31 <ndm> ":load Control.Monad.Fix"
17:57:47 <bringert> haha, airport announcment: "Maloney and Webber, wherever you are, we're going, bye bye!"
17:57:57 <ndm> and, please, please, download TextPad - you'll thank me for it in the long run
17:58:10 <weitzman> ndm: Oh, I was typing things completely wrong then
17:58:12 <ndm> it integrates seamlessly with WinHugs
17:58:18 <bringert> ok, time to grab some food
17:58:18 <deadbeef> ndm: what about eclipsefp ?
17:58:22 <ndm> weitzman: ! introduces a shell escape, so its broken]
17:58:28 <deadbeef> or that plugin for vs.net
17:58:33 <weitzman> :L moves me into Control.Monad.Fix>
17:58:35 <weitzman> And works
17:58:43 <bringert> lispy: good luck, let me know how it works out
17:58:44 <ndm> deadbeef: its not through WinHugs though
17:58:47 <weitzman> Although I would prefer to import things rather than "changing directories"
17:59:02 <deadbeef> got it
17:59:08 <lispy> thanks bringert
17:59:23 <ndm> weitzman: once you write some real code, that does import statements in the source code - this is more just for experimentation
18:00:10 <weitzman> ndm: Experimentation is pretty much all I'm doing right now. I like to construct commands incrementally and ask lambdabot about the types of every part
18:00:36 <ndm> weitzman: probably faster in WinHugs, but useful in either - i wish there was a GUI that did that automatically!
18:01:50 <ndm> weitzman: its not really "changing directory" - try ":l Data.List Data.Map", for example
18:01:57 <ndm> :l (L) is an abbreviation for :load
18:02:15 <weitzman> I've noticed that Control.Monad.Fix.mfix doesn't work
18:02:25 <weitzman> Do you always need to import?
18:03:53 <weitzman> I tried ":l Control.Monad.Fix Control.Monad", but it only seems to import from Control.Monad, not *.*.Fix
18:05:37 <weitzman> I'm trying, as an experiment, to have both "ap" from Control.Monad and "mfix" from Control.Monad.Fix in scope simultaniously
18:11:08 <newsham> how do I force "s <- hGetContents h" to evaluate immediately (strict)?
18:12:19 <newsham> is it  s <- ! hGetContents h     ?
18:15:09 <deadbeef> http://xkcd.com/c149.html
18:15:10 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
18:16:19 <Eidolos> I love that webcomic.
18:17:06 <newsham> anyone know how to force hGetContents to be strict?
18:20:07 <gmh33> why does yaht have to weave in things like continuation passing style :P
18:21:56 <lispy> weird
18:22:02 <lispy> lambdabot hangs on some input
18:22:14 <lispy> but rejects most invalid input
18:22:15 <lispy> a
18:22:26 <lispy> er, if you run lambdabot typing just 'a' will make it hang
18:23:21 <gmh33> doesn't lamdbabot interpret brainf*ck?
18:23:37 <lispy> gmh33: yeah
18:23:41 <gmh33> sweat
18:23:43 <lispy> gmh33: i added that actually :)
18:23:50 <weitzman> @bf ..+++==
18:23:50 <gmh33> now if that isn't the best language ever, I don't know what is
18:23:50 <gmh33> lol
18:23:50 <lambdabot> Done.
18:24:07 <lispy> it's even an optimizing interpreter
18:24:09 <weitzman> I have no idea what I just told lambdabot to do
18:24:10 <gmh33> :O
18:24:13 <gmh33> lispy, you dah man
18:24:14 <weitzman> But it was done?...
18:24:17 <lispy> yeah, bf is opaque :)
18:24:34 <lispy> weitzman: probably the program diverged and then lambdabot killed it
18:24:40 <weitzman> I guess the only illegal bf programs are ones with mismatched parens
18:24:48 <gmh33> lispy: you write it in haskell I'm willing to guess?
18:24:53 <lispy> gmh33: yup
18:25:01 <lispy> gmh33: the code is in the lambdabot repo if you want to lok at it
18:25:04 <lispy> ?where lambdabot
18:25:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:25:09 <gmh33> eh that's ok
18:25:17 <gmh33> I still don't understand the entirety of this beautiful language
18:25:24 <gmh33> I'm trying to get through YAHT atm
18:25:51 <newsham> grr, I'm trying to use runInteractiveProcess on win32, and if I hGetContents the output stream and print it, it work sfine, but if I dont print the contents, it hangs when i try to wait for the process
18:26:06 <newsham> and I dont know how to force haskell to evaluate the hGetContents without printing it
18:27:46 <lispy> is there a function to trim whitespace?
18:27:58 <lispy> i just want to trim at the beginning and end
18:28:05 <lispy> ?hoogle trim
18:28:06 <lambdabot> No matches found
18:28:11 <dibblego> me oh me!! pick me!! I have that function!! me me!!
18:28:21 <dmwit> dibblego: =)
18:28:38 <lispy> oh, guess not :)
18:28:52 <lispy> ?hoogle isSpace
18:28:52 <lambdabot> Char.isSpace :: Char -> Bool
18:31:35 <lispy> ?let trim = dropWhile isSpace . reverse . dropWhile isSpace . reverse
18:31:37 <lambdabot> Defined.
18:31:44 <gmh33> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
18:31:45 <lambdabot>  HelloWorld!
18:31:46 <lispy> > L.trim " aoeu blah foo  "
18:31:48 <lambdabot>  "aoeu blah foo"
18:31:50 <gmh33> :D
18:32:54 <gmh33> I think I'm going to abandon my haskell studies in favor of brainf*ck :P
18:33:10 <dmwit> > L.trim " 	j
18:33:10 <dmwit> "
18:33:11 <lambdabot>  Improperly terminated string
18:33:23 <gmh33> > L.trim "     j      "
18:33:24 <lambdabot>  "j"
18:33:50 <dmwit> > L.trim " 	j	"
18:33:50 <gmh33> > L.trim "    j
18:33:51 <lambdabot>  "j"
18:33:52 <lambdabot>  Improperly terminated string
18:33:53 <gmh33> > "
18:33:54 <lambdabot>  Improperly terminated string
18:34:16 <newsham> gmh cannot properly terminate his strings
18:34:25 <gmh33> I was seeing if that would work :P
18:34:41 <dibblego> all list comprehensions can be rewritten using map and filter?
18:35:02 <dmwit> dibblego: I think I saw something somewhere saying yes. =P
18:35:15 <dibblego> I think I am seeing that too
18:35:25 <gmh33> @bf ,>++++++[<-------->-],[<+>-],<.>.
18:35:25 <lambdabot> Done.
18:35:26 <newsham> all list comprehensions can be rewritten using list monad.
18:35:28 <dmwit> (List comprehensions are actually just syntactic sugar for map/filter if I remember well.)
18:36:04 <lispy> dibblego: well, you can translate a list comp. to do notation fairly easily and then from there transform to the list monad (in terms of bind/return) and then you could take the underlying implmeentaion of those to get the low level list functions :)
18:36:22 <lispy> dibblego: short cuts exist too
18:36:36 <dibblego> is there a short cut to making sense of all this?
18:36:42 <lispy> gmh33: input has been disabled
18:36:47 <gmh33> I knowticed : (
18:36:48 <newsham> small steps...
18:36:48 <gmh33> lol
18:36:53 <lispy> gmh33: meaning, programs with comma (i think) don't work
18:37:23 <dmwit> gmh33: But, how hard can a bf interpreter be? ;-)
18:38:46 <gmh33> a 9 piece pattern
18:38:56 <gmh33> where the _ does nothing ^_~
18:41:18 <gmh33> is Continuation Passing Style very important in learning haskell ? :/
18:41:37 <gmh33> this part is kind of .. not holding my attention lol
18:42:17 <dons> not really
18:42:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:42:21 <dons> well, hmm maybe a bit
18:42:30 <dibblego> I use CPS in Java
18:42:37 <dibblego> to avoid using exceptions and null
18:43:01 <lispy> Could not find module `Test.QuickCheck':
18:43:01 <lispy>   use -v to see a list of the files searched for
18:43:01 <lispy>   (imported from scripts/QuickCheck.hs)
18:43:05 <lispy> why am i getting this
18:43:09 <lispy> i have quickcheck installed
18:43:15 <lispy> and the cabal file says that it depends on quickcheck
18:43:18 <lispy> so what gives...
18:43:20 <dons> its in -package QuickCheck ?
18:43:25 <dons> capitals/
18:43:31 <lispy> right
18:43:35 <lispy> dons: this is lambdabot
18:43:49 <dons> hmm
18:44:07 <lispy> it's lambdabot.cabal.plugins...
18:44:12 <lispy> is that a file i wrote?
18:44:21 <dons> you sure its in lambdabot.cabal ?
18:44:41 <dons> or you've moved lambdabot.cabal.plugins -> lambdabot.cabal ?
18:44:41 <lispy> $ grep -i quickcheck lambdabot.cabal
18:44:42 <lispy> Build-Depends:       base, unix, network, parsec, mtl, haskell-src, haskell98, readline, plugins>=1.0, fps>=0.7, QuickCheck
18:44:42 <lispy> Executable:          quickcheck
18:44:42 <lispy> Main-is:             QuickCheck.hs
18:44:53 <dons> ok
18:44:59 <gmh33> I'm trying to think of how you'd keep track of variable values with a haskell interpretter
18:45:00 <gmh33> heh
18:45:09 <gmh33> since I... don't know haskell
18:45:19 <lispy> dons: i fixed all the known bugs and few unknown bugs with GoA and i'm about to record and send
18:45:25 <profmakx> whats a variable ^^
18:45:39 <dibblego> how do you get the nth element from a list?
18:45:44 <gmh33> I meant.. an interpretter written in haskell
18:46:07 <lispy> dons: oh, i bet i just need to clean and configure
18:46:40 <dolio> list !! n
18:47:07 <lispy> dons: here is something to try, run a lambdabot shell and type: a
18:47:13 <lispy> dons: lambdabot should hang
18:47:18 <dibblego> ta
18:49:19 <coffeemug> hmm
18:49:31 <coffeemug> haskell is one of the very few languages I've learned where I have to think more than type
18:49:42 <lispy> dons: oh, maybe latest lambdabot doesn't hang
18:50:40 <coffeemug> pretty funny how even though everything I do in it is slow because I don't know it well, it's still 20 times faster than doing it in C and probably 5 times faster than doing it in Java
18:51:09 * gmh33 doesn't like java
18:51:14 * dmwit shudders at the amount of anecdotal evidence pointing towards saved programmer time.
18:52:07 <waern> but is it faster than doing it in python?
18:52:13 <dmwit> I mean honestly, if you do your thinking while you are typing, it might not be that much of a difference.
18:52:29 <gmh33> that's impossible
18:52:29 <dmwit> I'm all for Haskell, but "guessing" isn't my idea of good support... =/
18:52:30 <gmh33> :P
18:55:22 <lispy> dons: okay, sent you the latest goodies
18:55:33 <lispy> dons: webinterface seems to be rock 'n along now
18:55:55 <newsham> hmm..  d <- readFile fn; print $ length d     is giving me weird results in win32.
18:56:28 <gmh33> win32 is weeeeeeird
18:56:37 <newsham> heh, first character is a ^Z.
18:56:48 <newsham> any way I can get this thing ot read raw binary data? :)
18:57:22 <newsham> i guess I want openBinaryFile
18:57:43 <lispy> ?help quote
18:57:43 <lambdabot> quote <nick>
18:57:44 <lambdabot> remember <nick> <quote>
18:57:44 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:58:35 <jcreigh> are ?command and @command equivalent?
18:58:56 <lispy> yes
18:59:49 <gmh33> @bf .+.[+.]
18:59:50 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
19:00:03 <lispy> gmh33: nice
19:00:09 <jcreigh> Oh dear
19:00:20 <weitzman> But if you accidentally have a space in front of the @ because of a copy-paste error, lambdabot won't talk to you
19:00:22 <weitzman> :(
19:00:39 <lispy> she's picky that lambdabot
19:00:51 <gmh33> yeah, she cut off my output D:<
19:00:52 <gmh33> lol
19:01:01 <dmwit> weitzman: I think it's on purpose.
19:01:08 <gmh33> I need to dl a bf interpretter for my lappy
19:01:08 <dmwit> @quote delicious-malicious-test
19:01:09 <lambdabot>  @quote dmt
19:01:19 <dmwit> To prevent that from recursing. =)
19:01:40 <lispy> i think lambdabot ignores itself anyway
19:01:41 <weitzman> dmwit: Well, lambdabot could just have a policy of not talking with itself
19:02:36 <Patterner> we need an Eliza for lambdabot to talk...
19:02:54 <lispy> ?yow
19:02:55 <lambdabot> Am I elected yet?
19:02:58 <dmwit> gmh33: http://en.wikipedia.org/wiki/Brainfuck#Implementations
19:03:01 <lambdabot> http://tinyurl.com/km4pw
19:03:27 <dmwit> Patterner: @vixen?
19:04:46 <sjanssen_> @vixen how are you this evening?
19:04:46 <lambdabot> i'm good, you?
19:05:03 <Patterner> i'm new here...
19:05:25 <dmwit> Welcome to #haskell!
19:05:38 * Welcome_ to #haskell!
19:06:06 <dmwit> Wow!
19:06:18 <lispy> bringert: thanks for the help ealier
19:06:23 <gmh33> dmwit: that's where I'm looking now
19:06:23 <lispy> bringert: seems like i got those bugs ironed out
19:06:32 <bringert> lsipy: sweet
19:06:35 <dmwit> Welcome is a bot?
19:06:37 <lispy> bringert: it wasn't any fault with fcgi
19:06:50 <bringert> lispy: I started playing with an Ajax front-end for it
19:06:58 <bringert> but I keep falling asleep
19:06:59 <lispy> bringert: already?  sweet
19:07:02 <lispy> haha
19:07:02 <bringert> typing gibberish
19:07:59 <lispy> bringert: well, show me what you have when we get to the haskell-workshop :)
19:08:36 <bringert> lispy: will do
19:09:28 <dmwit> "...there is no possibility that a parallel program will give one result in one run and a different result in a different run."
19:09:39 <dmwit> That is SO not what my profs said last quarter...
19:09:44 <dmwit> =P
19:10:25 <dons> lispy: any url where I can play with the web interface?
19:10:35 <lispy> dons: http://lambdabot.codersbase.com/bot.fcgi
19:10:42 <lispy> dons: that's the official one for the time being
19:10:50 <gmh33> bah this little bf interpretter doesn't wrap around properly I don't think :/
19:10:59 <lispy> dons: i still don't see why it diverges on the input 'a'
19:11:08 <dons> doesn't do it here.
19:11:15 <dons> lambdabot> a
19:11:15 <dons> Maybe you meant: all-dicts arr ask . v
19:11:20 <lispy> gmh33: oh maybe, there have been some programs that don't simulate correctly
19:11:51 <dons> lispy++ nice
19:12:05 <gmh33> should get to 255 then hit 0 on a wrap around and end the loop
19:12:09 <dons> oh so it doesn't seem to like 'a' :/
19:12:22 <gmh33> when running .+[.+].
19:13:01 <lispy> gmh33: hmm...
19:13:10 <gmh33> it's not lambdabot
19:13:11 <lispy> gmh33: i think the core pointer wraps around
19:13:14 <gmh33> it's a little one from the implimentation thing
19:13:22 <lispy> gmh33: but, i don't know about incrementing bytes
19:13:36 <dmwit> gmh33: It may not be just a byte behind the scenes...
19:14:24 <lispy> gmh33: what should that program do exactly?
19:14:39 <gmh33> print out a list of all the ascii characters
19:14:40 <gmh33> : )
19:14:47 <gmh33> from 0 to 255
19:14:48 <lispy> gmh33: when i ran it just now on the command line it didn't reurn anything
19:14:54 <lispy> (the program .+.[+.])
19:15:02 <lispy> gmh33: oh, well we have to scrub the output quite a bit
19:15:08 <gmh33> @bf .+[.+].
19:15:09 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
19:15:12 <gmh33> see : )
19:15:22 <lispy> only chars in the range [33 .. 126] are valid
19:15:27 <lispy> everything else is dropped
19:15:30 <gmh33> boo
19:16:08 <lispy> also, lambdabot  is truncating the output
19:16:12 <gmh33> @bf ++++++++++++++++++++++++++++++.
19:16:13 <lambdabot> Done.
19:16:25 <lispy> for some reason when i run bf on the commandline though, it's not terminating on that program
19:16:38 <gmh33> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
19:16:39 <lambdabot>  Z
19:16:44 <dmwit> lispy: 32 (white space) isn't printed?
19:16:52 <dons> is it blocking?
19:17:00 <lispy> dmwit: nope
19:17:12 <gmh33> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
19:17:13 <lambdabot>  F
19:17:13 <lispy> dons: i think so, top shows no activity...i may be have a screen issue
19:18:04 <lispy> ah yup, fresh putty session and all is well
19:18:25 <weitzman> > [5, 'a']
19:18:26 <lambdabot>  add an instance declaration for (Num Char)
19:18:26 <lambdabot>   In the list element: 5
19:18:26 <lambdabot>   I...
19:18:28 <lispy> gmh33: what OS are you on?
19:18:31 <gmh33> os x
19:18:32 <weitzman> @type [5, 'a']
19:18:33 <lambdabot>   No instance for (Num Char)
19:18:34 <lambdabot>    arising from the literal `5' at <interactive>:1:1
19:18:41 <lispy> gmh33: if you installed lambdabot you could play with bf at the commandline and see the 'full' power
19:18:43 <weitzman> Interesting. hugs gives a type
19:18:47 <gmh33> ooo
19:18:55 <dmwit> @type (5, 'a')
19:18:57 <lambdabot> forall a. (Num a) => (a, Char)
19:18:59 <lispy> ?where lambdabot
19:19:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:19:02 <gmh33> @type (5, 'a')
19:19:03 <weitzman> Hugs says [5,'a'] :: Num Char => [Char]
19:19:03 <lambdabot> forall a. (Num a) => (a, Char)
19:19:12 <weitzman> And I was going to ask about it
19:19:17 <weitzman> But then lambdabot dissed and dismissed me
19:19:23 <dmwit> =P
19:19:24 <lispy> dons: did you see that bringert wants to build an ajax shell for lambdabot ?
19:19:27 <gmh33> weitzman: you can't have mixed types in a list
19:19:38 <dons> lispy: no, how'd that work?
19:19:49 <dons> ah using hsp.clientside magics?
19:19:52 <lispy> dons: not sure, but i think he knows what he's doing
19:19:56 <dons> yep
19:20:08 <dons> did you direct him towards the goa src?
19:20:11 <weitzman> gmh33: I was wondering if hugs was trying to say that it would be a list if I could extend Char to be an instance of Num, somehow
19:20:34 <dons> weitzman: huh interesting idea
19:20:38 <bringert> lispy, dons: I'm actually writing it in straight html + javascript right now
19:20:40 <lispy> gmh33: actually just download this file http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/BF.hs
19:20:42 <lambdabot> http://tinyurl.com/emoay
19:20:52 <bringert> it should work with the exisiting web app
19:20:58 <weitzman> Any thoughts on why hugs says [5,'a'] :: Num Char => [Char]?
19:21:06 <lispy> so many layers :)
19:21:10 <dons> bringert: so it will talk to the underlying goa binding?
19:21:12 <sjanssen_> weitzman: your explanation is exactly right
19:21:14 <dmwit> @type [5, 1.2]
19:21:15 <lambdabot> forall a. (Fractional a) => [a]
19:21:16 <gmh33> weitzman: because you confused it?
19:21:17 <lispy> gmh33: if you get that version you can even re-enable input
19:21:29 <dmwit> @type [5, 6%5]
19:21:29 <lispy> dons: i think  it will talk to my url
19:21:31 <lambdabot> forall a. (Num (Ratio a), Integral a) => [Ratio a]
19:21:31 <bringert> dons: it will talk to lispy's web app
19:21:35 <dons> ah ok
19:21:40 <dons> tricksy
19:21:46 <dmwit> weitzman: Looks like you could...
19:21:59 <bringert> lispy: it will rely on the fact that you output plain text with newlines
19:22:04 <dons> bringert: html + javascript sounds good. we can then embed it in haskell.org :)
19:22:09 <lispy> bringert: sure
19:22:27 <weitzman> sjanssen_:  But (Num Char) looks to me like it wants the list to be a list of numbers, but it says it's a list of chars
19:22:27 <lispy> bringert: although, ndm wants me to upgrade the hoogle output to do colored html at some point
19:22:30 <dons> lispy: ok, so what do we need to sort out with your page now? this non-terminating 'a' ?
19:22:47 <lispy> dons: yeah, that's the only bug i know about right now
19:22:51 <bringert> if you change that to make something pretty, could you add a parameter that tells it to output plain text
19:23:02 <lispy> bringert: sure, very reasonable
19:23:02 <dons> ok, i've a clue about that, lispy, let me see..
19:23:21 <sjanssen_> weitzman: what's really happening is that numeric literals are overloaded.  "5" gets replaced with "fromInteger 5" (fromInteger is a function in the Num class)
19:23:47 <gmh33> lispy how do I compile that version?
19:24:00 <lispy> bringert: but, say we do get pretty coloring and html tags in some of the output, do you expect we'd eventually have a way to splice it in?
19:24:12 <lispy> gmh33: ghc --make BF.hs -o bf
19:24:25 <lispy> gmh33: do yo usee how to re-enable input commands?
19:24:42 <lispy> gmh33: look for   doCommand' InputByte _ bf@(BF c cp ip) = {-# SCC "InputByte" #-} do
19:24:49 <weitzman> > (let b = 5.5 :: Float in b) :: Int
19:24:49 <lambdabot>  Couldn't match `Int' against `Float'
19:24:58 <lispy> there is a comment that starts above that line and ends before the JmpForward command
19:24:59 <gmh33> the -- InputByte comment?
19:24:59 <bringert> lsipy: hmm, maybe.
19:25:02 <weitzman> > (let b = 5.5 :: Num in b) :: Int
19:25:02 <bringert> lispy that is
19:25:02 <lambdabot>    Class `Num' used as a type
19:25:03 <lambdabot>   In the type `Num'
19:25:03 <lambdabot>   In an expression ty...
19:25:17 <lispy> bringert: okay, w'll worry about it later
19:25:37 <lispy> dons: yes, having lambdabot accessible from haskell.org would be really cool
19:25:58 <dons> isI was thinking of just using HsColor for the colorised haskell output
19:26:01 <lispy> and i'm happy that i can say i helped with some small part :)
19:26:09 <lispy> dons: oh, good idea
19:26:11 <sjanssen_> weitzman: Num isn't a type, it's a class (a class is a set of types with accompanying functions)
19:26:22 <lispy> dons: although, geishi a la new wiki looks better
19:26:27 <dons> yep true
19:26:29 <lispy> dons: and links to prelude
19:27:13 <gmh33> it throws an error :/
19:27:30 <gmh33> BF.hs:40:21:
19:27:30 <gmh33>     Ambiguous occurrence `bounds'
19:27:30 <gmh33>     It could refer to either `Data.Array.Base.bounds', imported from Data.Array.IO at BF.hs:21:0-19
19:27:30 <gmh33>                           or `GHC.Arr.bounds', imported from Data.Array at BF.hs:22:0-31
19:27:46 <dons> ok, you have to tweak the import for bounds.
19:27:55 <dons> since you're using a different ghc to me
19:28:58 <lispy> well, i need to run home
19:29:07 <dons> hmm 'a' seems to work in goa
19:29:28 <lispy> dons: hmm..i am running latest lambdabot and latest goa thou
19:29:37 <lispy> dons: on the url...
19:29:43 <dons> does :def aa        lambdabot "a"
19:29:48 <dons> GOA> :aa
19:29:48 <dons> Maybe you meant: all-dicts arr ask . v
19:29:53 <dons> work for you, in ghci?
19:30:05 <lispy> actually
19:30:05 <lispy> weird
19:30:12 <lispy> ./lambdabot
19:30:18 <lispy> lambdabot> a
19:30:19 <lispy> Signal: SIGINT
19:30:24 <lispy> i had to hit ctrl C
19:30:31 <lispy> so maybe the copy in my webdir is not right
19:30:41 <dons> ok, maybe you've not got a recent lambdabot
19:30:48 <dons> I think I fixed this issue on the weekend
19:30:54 <lispy> $ darcs pull
19:30:54 <lispy> Pulling from "http://www.cse.unsw.edu.au/~dons/lambdabot"...
19:30:55 <lispy> No remote changes to pull in!
19:30:58 <dons> (it's just waiting for output that never arrives)
19:31:04 <dons> and you reinstalled it and rebuilt?
19:31:17 <dons> with the right --bindir ?
19:31:22 <lispy> do i need to run install+
19:31:32 <lispy> or just 'build'
19:31:39 <lispy> okay, it says text busy
19:31:39 <dons> ./build should just work
19:31:42 <lispy> so i'll kill the fcgi
19:31:45 <dons> as long as your --bindir arg was correct
19:31:48 <lispy> and try to re-run build
19:31:54 <lispy> yeah bindir is right
19:32:49 <lispy> oh hmm..
19:32:57 <lispy> i have some backup lambdabot  processes
19:33:05 <lispy> sudo kill -9 isn't cutting it
19:34:32 <lispy> yeah, still doing it
19:34:43 <lispy> so i copied over ShowQ.*, L.* and State
19:34:47 <lispy> was there anything else?
19:34:54 <dons> hmm. let me try to do that.
19:35:07 <dons> gmh33: I just pushed a patch to fix your BF.hs isue.
19:35:11 <lispy> dons: okay i need to go
19:35:13 <dons> try downloading that file again
19:35:19 <lispy> oh what was the issue?
19:35:24 <lispy> anyway, i need to go :)
19:35:33 <lispy> i'll check the darcs histor :)
19:35:37 * lispy waves
19:35:37 <dons> ok. thanks for the hacking!
19:35:41 <lispy> thank you!
19:35:47 <gmh33> :O
19:35:48 <gmh33> :D
19:36:08 <sjanssen_> dons: I'm really excited at the prospect of writing a WM in Haskell
19:36:30 <sieni> that sounds cool as fsck
19:36:36 <sieni> s/fsck/funk/
19:36:44 <dons> sjanssen_: me too :)
19:36:50 <dons> are you looking at the dwm source?
19:37:13 <dons> sjanssen_: you can just start if you want!
19:37:26 <dons> i'd try to just reproduce some minimal dwm behaviour, so we can learn the apis for X
19:37:33 <sjanssen_> dons: I've been peeking here and there
19:37:44 <dwm> huh?
19:37:52 <dons> not that dwm
19:38:00 <dwm> kidding
19:38:05 <dons> :P
19:38:19 <jgrimes> a WM in haskell would be very fun
19:39:28 <sjanssen_> I don't think I'll have time before next week to start hacking
19:39:56 <dons> oo
19:39:57 <dons> k
19:41:41 <dons> lispy: hmm, i just rebuild everything, lambdabot seems to handle 'a' nicely:
19:41:43 <dons> lambdabot> a
19:41:44 <dons> Maybe you meant: all-dicts arr ask . v
19:42:13 <glguy> I've said it once, I'll say it again, the new iTunes looks terrible!
19:43:27 <dmwit> =O A Haskell WM?
19:43:28 <gmh33> damn lispy left didn't he
19:43:42 <dmwit> But I've finally got Compiz doing what I want...
19:43:43 <glguy> haskell WM?
19:43:44 <gmh33> the new iTunes has a lot of new 'features' in it ;P
19:43:56 <gmh33> and everyone hated the last version of it when it came out
19:44:04 <glguy> The new iTunes doesn't look like any of the other Mac applications
19:44:15 <glguy> and uses a new ugly blue music note
19:44:18 <gmh33> it is pretty slick though
19:44:31 <glguy> Oh sure, take the ugly guys side ;)
19:44:35 <bringert> lispy: I keep getting "No lambdabot process"
19:46:09 <dons> bringert: he switched it off, I think
19:46:18 <glguy> gmh33: do you use a Mac?
19:46:19 <bringert> ah
19:46:23 <gmh33> glguy: yes
19:46:40 <glguy> gmh33: do you think this is going to be the look of 10.5?
19:46:42 <gmh33> and I'm also using iTunes right now :P
19:46:48 <bringert> dons: I seem to have a working prototype ajax-frontend
19:46:48 <glguy> me too!
19:46:49 <glguy> ;)
19:46:54 <dons> bringert: cool!
19:47:01 <gmh33> glguy: I haven't scoped out 10.5 screenies as of yet
19:47:03 <gmh33> at least not much
19:47:22 <glguy> I have a friend that went to WWDC
19:47:29 <glguy> and has Jaguar installed
19:47:30 <glguy> but
19:47:47 <glguy> he lives in Texas and is sticking ot his non-disclosure agreement
19:48:00 <gmh33> there are screenies somewhere on the internets
19:49:05 <bringert> boarding!!
19:50:59 <newsham> i need to manipulat some large "strings" from files (insert data, delete data, overwrite data).  Is FPS the way to go?
19:51:09 <newsham> or would arrays be more natural for those operations?
19:51:43 <dons> hmm. depends on how much you need to do destructive updates
19:51:54 <dons> but i'd think start with fps , and try uarrays if you get really stuck
19:52:10 <newsham> i have one copy of the original, and a bunch of  String -> String functions that make changes.
19:52:29 <dwm> I'm having some trouble understanding some State monad stuff I'm reading..
19:52:54 <newsham> the changes can alter the size of the string by insertion or by deletion.
19:53:01 <dwm> I'm looking at an example from All About Monads.
19:53:32 <newsham> so sometimes destructive update would be useful but not always
19:53:44 <dwm> it's got: getAny = do { g <- get ; (x,g') <- return $ random g ; ... }
19:53:52 <dwm> And then there's the put and return, blah blah after that
19:53:55 <sjanssen_> newsham: so your program can be expressed as a pipeline of string transformers?
19:54:10 <newsham> sjan: part of the program, yes.  thats the current implementation.
19:54:23 <sjanssen_> you should try Data.ByteString.Lazy
19:54:24 <newsham> its really slow though.   I'm using "drop" and "take" and "!!" a lot.
19:54:35 <dwm> The type here is: getAny :: (Random a) => State StdGen a
19:54:57 <sjanssen_> newsham: all of those are quite fast with ByteStrings
19:55:05 <newsham> perfect. thanks.
19:55:15 <newsham> dwm: what's the question?
19:55:22 <dwm> So, the question I have is, that first action g <- get. How is that becoming one value to be passed to random in the next action?
19:55:51 <dwm> get in MonadState looks like: get   = State $ \s -> (s,s)
19:56:04 <gmh33> so who's looking forward to windows SP3 ?
19:56:05 <gmh33> lol
19:56:23 <weitzman> gmh33: Will it be out before Vista?
19:56:26 <newsham> dwm: the state monad is implicitely passing around this state object, and "get" is retrieving it.
19:56:35 <gmh33> weitzman: it is vista
19:56:41 <glguy> *burn*
19:56:46 <weitzman> gmh33: I see
19:57:22 <newsham> the "\s -> (s,s)" has to do with how the state monad's type is defined.
19:57:47 <dwm> I guess what I'm saying is, the 'get = State $ \s -> (s,s)' doesn't look like it could create a RandomGen value.
19:58:18 <weitzman> gmh33: I've used Vista for a few months, and I'm looking forward to it. In particular, I grow weary of right-clicking IE and doing a "Run As..." in XP whenever I want to do something as admin
19:58:18 <newsham> its not creating the object, the object is already wrapped up inside the state monad thingy
19:58:24 <newsham> it's just retrieving it
19:58:39 <newsham> later when you "runState" on the results you will have to pass it in.
19:58:46 <gmh33> weitzman: isn't the best part the clock?
19:58:48 <gmh33> :/
19:59:24 <weitzman> gmh33: Actually I believe you can make the clock accessible to limited users. Could be wrong
19:59:37 <newsham> dwm: (I hope i get this right, its been a while)..   the  \s -> (s',x)    is a function take takes a state (s) and returns a value (x) and an updated state (s')
19:59:39 <gmh33> hahahahahahah
19:59:45 <dwm> Is it the runState implementation that's unpacking this?
20:00:06 <weitzman> gmh33: The thing that really bothers me is that I got XP Home on my new machine since I'm just going to reinstall the OS in a few months, and they don't give you a file ACL dialog. You gotta change permissions from the command line, or use a third-party tool
20:00:06 <newsham> if yo uhave    \s -> (s,s)    its saying it takes in a state, and returns a value (s) and a new state (s)... ie. it returns the current state, and doesnt chang it
20:00:54 <newsham> dwm: when you write code in the state monad, all the code is wrapped up in an (inert) state object.  it doesnt run until you use "runState" on it
20:01:24 <newsham> runstate takes the big (\s -> (s', x))  thing you built up and feeds an initial "s" into it to make it go.
20:01:41 <newsham> to get out the resulting "x"
20:02:14 <glguy> weitzman: Home edition doesn't support "advanced" file permissions?
20:02:18 <dwm> So, expressions like this getAny would not work at all outside of a runState evaluation.
20:02:40 <weitzman> weitzman: Well, it "supports" everything. All the windows SKUs are basically the same. It just doesn't have a dialog for it so things are harder
20:02:44 <newsham> getAny must appear inside the state monad (ie. inside a "do")
20:03:01 <glguy> weitzman: are you talking to yourself now (c;
20:03:06 <dwm> Yeah, and its type: getAny :: (Random a) => State StdGen a
20:03:24 <weitzman> glguy: Damn, that's the second time I've done that
20:04:04 <dwm> newsham: Ok, I get it slightly more, but not how the machinery works in there. But enough to get that the state business with this monad relies on runState to be executed.
20:04:16 <dwm> thanks
20:04:17 <weitzman> glguy: Another thing home edition lacks is the part of the computer management console where you grant rights to limited users, so I can't tell if there's a clock-changing permission
20:04:36 <newsham> dwm: think of you "do" block as just building up an inert machine from a bunch of smaller inert machines (geAny is one of them)
20:04:44 <glguy> I don't ever remember seeing a clock changing permission
20:04:54 <newsham> and runState as the thing that makes it go.
20:05:13 <dwm> newsham: I see. It's slightly different from when you'll just wrap a do around, say, some IO and get input, do things with it.
20:05:24 <dwm> perform output..
20:05:25 <newsham> it might be clearer to undo all the monad stuff to see how it is really working, but that might be a bit much for IRC
20:05:26 <weitzman> glguy: There's a permission to change network settings, which I found useful in Pro for letting me disable/enable wireless/wired as a limited user
20:05:45 <newsham> dwm: not entirely.  when you're using "IO" you're basically taking a bunch of small IO machines and splicing them together
20:06:02 <newsham> and then the hsakell system makes the big IO machine you built up go
20:06:08 <dwm> Sure, but nothing has to 'runIO'
20:06:23 <newsham> think of "runIO main" as being the top of the program.
20:07:16 <dwm> ok
20:07:35 <dwm> It may help too if I examine what runState looks like inside.
20:07:58 <glguy> who is trying to understand State?
20:08:09 <newsham> dwm: if you have time and you want to understand better,  expand the definition of "State" and "runState" and "getAny" in a small example
20:08:17 <newsham> and rewrite without using the do-notation
20:08:50 <newsham> "runState" is a cute little hack, its really just an accessor to return the function that represents the state.
20:09:08 <newsham> so when you "runState <stateobj> ...." it gets the "<statefunc> ..."
20:10:33 <dibblego> factors a = filter ((\x y -> x `mod` y == 0) a) [1..a] -- can this be written any 'nicer'?
20:10:35 <newsham> newtype State s a = State { runState :: (s -> (a,s)) }
20:11:04 <newsham> see how the "State" type is just a record with one field called "runState" and that field has a function (s -> (a,s))
20:11:15 <monochrom> I understand Church and State.
20:11:15 <newsham> so "runstate s" just gets that function out of the record
20:11:26 <monochrom> Yes
20:11:36 <glguy> [ x | x <- [1..a], a `mod` x == 0]
20:11:56 <dibblego> glguy, that is a list comprehension right?
20:11:58 <newsham> > runState (State (\s -> (s, 5))) 9
20:11:59 <glguy> (and you only need to check up to a `div` 2
20:12:00 <lambdabot>  (9,5)
20:12:01 <glguy> dibblego: yeah
20:12:14 <monochrom> Works :)
20:12:14 <dibblego> what do you mean by "only need to check up to a `div` 2"?
20:12:15 <newsham> > runState (State (\s -> (s, 5+s))) 9
20:12:17 <lambdabot>  (9,14)
20:12:26 <dwm> I see, so the runState around the do, is it getting a lot of the functions, and they get put together.
20:12:32 <monochrom> It's beautiful :)
20:12:37 <newsham> > runState (return 3) 9
20:12:38 <lambdabot>  (3,9)
20:12:53 <glguy> dibblego: the only number that is a factor of n, and is greater than n `div` 2 is n itself
20:12:58 <monochrom> Yeah >>= does the chaining for you.
20:13:21 <dibblego> glguy, so you mean there is a potential for that optimistion, particularly for large numbers
20:13:26 <dwm> This is what you meant by expand and write with >>= instead of do
20:13:57 <glguy> there are definitely better factoring algorith,s
20:14:13 <glguy> but that is 1 optimization
20:14:27 <newsham> > runState (return 3 >>= (\y -> return (2+y))) 8
20:14:29 <lambdabot>  (5,8)
20:14:29 <dibblego> yes, if the factor is prime
20:15:18 <newsham> > runState (return 3 >>= (\y -> put 12 >> return (2+y))) 8
20:15:20 <lambdabot>  (5,12)
20:15:32 <glguy> if you know all the prime factors, it is trivial to generate all of the factors
20:15:36 <newsham> see how one part of the tuple is used to carry the state (8 and then later 12)
20:15:49 <newsham> and the other part is used to carry the computed values (3 and then 5)
20:15:59 <newsham> and the (>>) and (>>=) mix them together
20:16:20 <dwm> I see that, why was the 8 showing up as the snd value in the other one?
20:16:27 <newsham> > runState (return 3 >>= (\y -> put 12 >> get) 8
20:16:27 <lambdabot>  Parse error
20:16:45 <newsham> because 8 is the value I pass in as the initial state
20:16:53 <newsham> and I'm never updating the state (with put) except in that one example
20:17:02 <dibblego> can all expressions that use filter be transformed to a list comprehension?
20:17:17 <monochrom> return 3 and return (2+y) don't change the state.  The state receives 8 initially.
20:17:24 <glguy> dibblego: dibblego yeah
20:17:40 <glguy> filter f xs === [a | a <- xs, f a]
20:17:42 <newsham> right,  "return 3" fills in the "value" part of the result but not changing the "state" part of the result
20:17:51 <dwm> @type Control.Monad.State.runState
20:17:53 <lambdabot> forall s a. State s a -> s -> (a, s)
20:18:10 <dwm> Ah, ok, I see it.
20:18:15 <glguy> have you guys discussed the ever useful evalState, and execSTate
20:18:28 <newsham> we didnt yet, no.
20:19:07 <monochrom> In practice we seldom use runState.  We use evalState or execState.
20:19:38 <newsham> runState was returning both the end state and the end value.  often you dont care about the end state (you just wanted to make sure it got chained through the various machines)
20:20:03 <newsham> > evalState (return 3 >>= (\y -> put 12 >> return (2+y))) 8
20:20:04 <lambdabot>  5
20:20:09 <dibblego> glguy, do you use === to mean "is equivalent to"?
20:20:13 <newsham> evalState just gives you what you want.
20:20:14 <glguy> yeah
20:20:27 <dibblego> glguy, did you make that up or is that a common convention?
20:20:48 <glguy> I definitely didn't make it up :)
20:20:52 <dibblego> ok :)
20:21:09 <glguy> I've seen it used the same as the three bar equal sign "is identical to"
20:21:18 <glguy> since == is a test for equality, and = is assignment
20:21:29 <newsham> evalState is just fst . runState, right?
20:21:34 <dibblego> three bars means "is equivalent to" I thought
20:21:44 <dwm> ah, I see. In the example I'm looking at, they use the fst of the returned value. I did think that was a tiny bit odd.
20:21:57 <newsham> > fst . runState (return 3 >>= (\y -> put 12 >> return (2+y))) 8
20:21:58 <lambdabot>    Expecting a function type, but found `(a, s)'
20:21:58 <lambdabot>    Expected type: a1 ->...
20:21:59 <weitzman> @type (===)
20:22:00 <lambdabot> Not in scope: `==='
20:22:03 <dwm> After all the runState business is done.
20:22:19 <newsham> > fst $ runState (return 3 >>= (\y -> put 12 >> return (2+y))) 8
20:22:20 <lambdabot>  5
20:23:27 <dibblego> can map f xs be converted to a list comprehension?
20:23:37 <glguy> > execState (replicateM_ 3 (modify (2*))) 3
20:23:38 <lambdabot>  24
20:23:40 <newsham> [f x | x <- xs]
20:23:47 <monochrom> [ f x | x <- xs ]
20:23:55 <dibblego> ah thanks
20:24:30 <monochrom> There is a whole endian war on "always use comprehension" vs "never use comprehension".
20:24:41 <dibblego> sounds fun, can't wait to join
20:24:46 <dwm> Ok, and execState is the other way around. Discard the value.
20:24:50 <dibblego> are there any "middle ground" campers?
20:24:53 <monochrom> And in the former camp there is a whole hair-splitting war on "use comprehension" vs "use do"
20:25:08 <newsham> Execute this state and return the new state, throwing away the return value. Very much like snd composed with runstate.
20:25:11 <shrimpx> wow people argue about the most meaningless things in the context of haskell
20:25:14 <newsham> thats what the docs seem to say :)
20:25:27 <glguy> Yeah... Haskell got dumbed down )-: Monad comprehensions were lost
20:25:31 <monochrom> Yeah, the middle-ground campers go like "both of you should use arrows"
20:25:58 <dwm> Well, this has really helped. Thank you all.
20:26:14 <Patterner> You'll all burn in PHP Hell!
20:26:22 <monochrom> I'm making all this up.  There is no war. :)
20:26:34 * weitzman has lurked through the MonadState discussion and also feels good about it
20:26:44 <newsham> dwm: best thing to do is play around with it.  build your own state machinelets, apply them with evalstate and runstate
20:26:58 <dibblego> it is the first thing I thought about when I realised that there is an equivalence relationship
20:27:06 <newsham> write out 'get' and 'put' the long way (as shown in that article) and try them with >>=
20:27:25 <glguy> and don't forget about modify and gets!
20:27:32 <dwm> I'll do that. Perhaps not this evening, but tomorrow.
20:27:55 <monochrom> egets!
20:28:37 <newsham> then goof around with liftM and liftM2 when you understand the basics
20:29:53 <glguy> I can't see liftM being too useful in MonadState
20:30:03 <newsham> ghc question: I saw some docs that say "+RTS -p" but my ghc doesnt seem to have "-p", is it new?  is it old?  do I need to build a special way to get it?
20:30:27 <weitzman> I find liftM2 most useful when using check
20:30:37 <weitzman> As in, @check (==) f g
20:30:50 <weitzman> Oops, lift2 (==) f g
20:31:00 <glguy> I use liftM2, just not in MonadState
20:31:38 <dons> newsham: hmm. you only get +RTS -p if you compile your program with -prof -auto-all
20:31:56 <newsham> ahh.. makes sense.
20:41:22 <dons> ?yow
20:41:22 <lambdabot> Yow!  Those people look exactly like Donnie and Marie Osmond!!
20:48:36 <glguy> ?type Data.ByteString.zip
20:48:37 <lambdabot> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString -> [(Word8, Word8)]
20:57:15 <dibblego> if there a function Integral a => a -> Char for ascii/unicode conversion?
20:57:48 <dmwit> > chr 65
20:57:49 <lambdabot>  'A'
20:57:54 <dibblego> thanks
20:58:04 <dibblego> ?index chr
20:58:05 <lambdabot> Data.Char
20:58:41 <dibblego> what about the other way?
20:58:51 <dmwit> Not sure...
20:58:56 <dmwit> > toInteger 'a'
20:58:57 <lambdabot>  add an instance declaration for (Integral Char)
20:58:57 <lambdabot>   In the definition of `w...
20:59:10 <dibblego> ord I think
20:59:26 <dmwit> > ord 'a' -- as in this?
20:59:28 <lambdabot>  97
20:59:39 <dibblego> Prelude> Data.Char.ord 'A'
20:59:39 <dibblego> 65
21:03:41 <lennart> toEnum
21:03:48 <lennart> and fromEnum
21:03:54 <lennart> > fromEnum 'A'
21:03:56 <lambdabot>  65
21:04:11 <dons> mmm. Memory: 80G real, 77G free, 322M swap in use, 72G swap free
21:04:28 <lennart> 80G?
21:04:42 <kmag> dons: not 96 GB?
21:04:44 <lennart> that's not too shabby :)
21:04:47 <glguy> twh are you  doing that uses 3 gigs
21:04:55 <glguy> wth*
21:04:57 <dons> yeah, a Sun F6900, 40 cpus, being used to run some smp ghc
21:05:16 <kmag> dons: which OS?
21:05:35 <dons> solaris. a colleague is using it for the data parallel haskell work
21:05:47 <kmag> Which version of Solaris?
21:06:01 <dons> don't know.
21:06:01 <kmag> I ran into some threading library issues on Solaris 8
21:06:12 <glguy> Does parallel haskell add extra syntax? functions?
21:06:15 <kmag> SF V1280
21:06:16 <dons> oh, i think it might be newer than that.
21:06:22 <dons> glguy: extra libraries
21:06:40 <dons> (think like bytestring, but over arbitrary arrays, in parallel)
21:06:47 <kmag> only 12 CPUs
21:06:57 <kmag> more RAM than HD space
21:07:46 <dons> I still kind of boggle that this is considere a midrange server :)
21:07:53 <glguy> ?where sicp
21:07:54 <lambdabot> I know nothing about sicp.
21:09:27 <dons> oh, a bargain at ~$300k US
21:09:35 <dons> I should get one to run lambdabot on
21:10:41 <glguy> "Hey, why are you typing that long program into an irc client?"
21:10:51 <dons> hehe
21:10:55 <glguy> "Oh, it's the fastest computer that I have access to :)"
21:11:14 <glguy> You could install the whole program using ?let ;)
21:11:38 <glguy> I'd rather have ?where tho ;)
21:11:40 <kmag> how much state does lambabot keep?
21:11:56 <dons> hmm, a little. mostly static
21:12:03 <dons> only a meg or so of actual data
21:12:06 <dibblego> all list comprehensions take the form of [f1 a | a <- xs, f2 a] right?
21:12:30 <glguy> parallel ones don't
21:12:47 <glguy> and you can have multiple lists to sequence
21:13:04 <dons> dibblego: right, your syntax is a valid h98 list comp.
21:13:05 <dons> hey tmoertel
21:13:17 <dons> dibblego: which corresponds to a 'filter' or a 'map'
21:13:26 <glguy> > [ 1 | a  <- [1,2], b <- [3,4], even (a+b)]
21:13:27 <lambdabot>  [1,1]
21:13:31 <dons> there's an extension to provide 'zip'-like comprehensoins
21:13:35 <dibblego> [(x,y) | x <- [1..5], y <- [x..7]] -- how does that correspond to f1 a?
21:13:58 <dibblego> f1 a = (x,y) ?
21:14:15 <sris> Could someone help me understand what's causing the error: "irrefutable pattern failed for pattern (x, (y : ys) )" when i run this code: http://paste.lisp.org/display/26005
21:14:32 <dons> oh, my mistake. the 40 cpu version starts somewher above $2,026,090US
21:15:08 <glguy> sris:  if break returned a null list for (y:ys)
21:15:15 <glguy> sris: then that pattern would fail
21:15:35 <sris> i thought i alwas return something sensible
21:15:44 <sris> like ("","") at worst
21:15:57 <glguy> sris, "" does not match (y:ys)
21:16:09 <sris> maybe not ;)
21:17:27 <sris> aside from that, do you think it seems like a resonable substitute function? in terms of "good" haskell
21:18:05 <glguy> show me any example of what its for?
21:18:49 <sris> substitute '*' "my name is *" "sris", should produce "my name is sris"
21:19:25 <glguy> and it is to allow for multiple wildcards?
21:19:51 <sris> yes, like "hi * *" "glguy" -> "hi glguy glguy"
21:20:27 <dibblego> ?index listArray
21:20:28 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
21:21:05 <glguy> > let sub _ [] _ = []; sub w (t:ts) s = if w == t then s ++ sub w ts s else t : sub w ts s in sub '*' "like * this *?" "test"
21:21:06 <lambdabot>  "like test this test?"
21:21:11 <glguy> ok
21:24:38 <glguy> > let sub w t c = if w == c then t else [c] in "wondering * about this" >>= (sub '*' "test")
21:24:39 <lambdabot>  "wondering test about this"
21:25:36 <glguy> hey dons, can lambdabot interpret guards in lets?
21:25:42 <sris> im afraid of if the else, stuff. i've got the impression that it's "bad style" but maybe im just making it difficult for myself
21:25:59 <glguy> sris, you could use guards instead of if else
21:26:15 <glguy> sub w t c
21:26:20 <glguy>  | w == c = [c]
21:26:21 <dons> > let x | True = 1 | otherwise = 2 in x
21:26:23 <lambdabot>  1
21:26:27 <glguy> ah, ok
21:26:43 <glguy> > let sub w t c | w == c = t | otherwise = [c] in "wondering * about this" >>= (sub '*' "test")
21:26:44 <lambdabot>  "wondering test about this"
21:26:49 <glguy> no guards
21:26:50 <glguy> err
21:26:53 <glguy> no if then else
21:27:23 <glguy> (I don't think there was anything wrong about the way you were doing it, i just like to golf)
21:27:43 <sris> im not getting my version to work though ;)
21:27:52 <glguy> change (y:ys) to y
21:28:04 <glguy> oh
21:28:05 <glguy> wait
21:28:10 <glguy> you'll have ot test for null stil anyway
21:28:17 <sris> but then i have to use tail in the recursive call to sub.
21:28:20 <glguy> but either way you need to fix your pattern match
21:29:03 <glguy> whoa, paste.lisp.org can colorize as Hskell now?
21:29:35 <glguy> That's new since I last checked (c:
21:29:50 <glguy> sris: right, you'll have to use tail
21:30:09 <glguy> sris: because otherwise you'll have to check so see that 't' contains wildcard
21:30:12 <glguy> before calling break
21:30:15 <glguy> and that seems inefficient
21:30:29 <sris> yea, you're right
21:30:50 <sris> im just trying to learn the best way to do things, and i was told pattern matching was good stuff ;)
21:30:52 <dibblego> I think there is a mistake in the "Haskell for C Programmers" document
21:31:50 <dibblego> http://www.haskell.org/~pairwise/intro/section3.html#part5 map (\x -> "the " ++ show x) [1, 2, 3, 4, 5]
21:31:53 <glguy> sris I usually try to avoid explicit recursion whenever possible
21:31:54 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/zcxw9
21:31:59 <glguy> using concatMap , map, fold, etc
21:32:16 <dibblego> to me, that function evaluates to a [Char] yet the document has a [[Char]]
21:32:31 <glguy> dibblego: that evaluates to a [[Char]] aka [String]
21:32:32 <sris> glguy, i want to do that, but still find it really hard to "see" when i can
21:32:47 <dibblego> glguy, that document disagrees
21:33:00 <glguy> easy to resolve:
21:33:03 <glguy> ?type map (\x -> "the " ++ show x) [1, 2, 3, 4, 5]
21:33:04 <lambdabot> [[Char]]
21:33:09 <dibblego> oh wait
21:33:21 <dibblego> I was ignoring the map
21:33:21 <glguy> do you see what it's doing?
21:33:25 <dibblego> yes, my mistake
21:35:19 <glguy> > foldr (\x y -> if x == '*' then "test" ++ y else x:y) [] "simple * ex * example"
21:35:20 <lambdabot>  "simple test ex test example"
21:35:22 <sris> glguy, would you be able to write a method like sub. without explicit recursion?
21:35:31 <glguy> sris: way ahead of you
21:35:35 <sris> oh ;)
21:36:22 <glguy> > let sub w t s = foldr (\x y -> if x == w then s ++ y else x : y) [] in sub '*' "glguy" "*: says hi *"
21:36:23 <lambdabot>  <[Char] -> [Char]>
21:36:29 <weitzman> @type (. map) . (.) . filter
21:36:30 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
21:36:46 <glguy> hmm
21:37:41 <glguy> > let sub w t s = foldr (\x y -> if x == w then s ++ y else x : y) [] t in sub '*' "*: says hi *" "glguy"
21:37:42 <lambdabot>  "glguy: says hi glguy"
21:37:48 <glguy> forgot a variable :)
21:38:42 <sris> i have to learn the lambda-notation stuff
21:39:40 <weitzman> So (. f) . (.) sorta converts a function to use CPS
21:39:53 <weitzman> It takes the continuation function as the first argument
21:39:56 <weitzman> That's interesting
21:40:02 <glguy> > let sub w t s = foldr f [] t where f x y | x == w = s ++ y | otherwise = x : y in sub '*' "*: says hi *" "glguy"
21:40:03 <lambdabot>  "glguy: says hi glguy"
21:40:10 <glguy> there it is w/o lambda-expressions
21:40:21 <weitzman> Is there a more clear way to write (. f) . (.) while remaining point-free?
21:40:31 <glguy> you can use flip
21:40:38 <glguy> i believe...
21:41:19 <glguy> ?type \f -> (. f) . (.)
21:41:20 <lambdabot> forall a b c a1. (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
21:41:33 <weitzman> @hoogle forall a b c a1. (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
21:41:35 <lambdabot> Did you mean: Forall a b c A1. (a -> A1 -> b) -> (b -> c) -> a -> A1 -> c
21:41:57 <glguy> ?djinn (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
21:41:57 <lambdabot> f a b c d = b (a c d)
21:42:00 <sris> glguy, nice, i guess it would be a good time to practice it anyway
21:42:35 <weitzman> @pl  f a b c d = b (a c d)
21:42:36 <lambdabot> f = flip ((.) . (.))
21:42:48 <weitzman> That's a fun-looking function
21:43:09 <weitzman> Although I don't find it more readable
21:43:59 <weitzman> I guess my function isn't very general
21:44:10 <weitzman> It assumes exactly 2 args
21:44:13 <weitzman> ?
21:44:20 <glguy> yeah
21:44:37 <weitzman> There's probably some nifty MonadReader function that does what I want
21:44:42 <glguy> what do you want
21:45:17 <weitzman> Well, basically I want to convert a function to give its result to a continuation instead of just returning it
21:45:27 <weitzman> Specifying the function, then the continuation, then args
21:45:36 <weitzman> And I guess you need to know how many args there are...?...
21:46:04 <glguy> I don't know much about continuation passing style
21:46:24 <glguy> but if I understand your question correctly, you'll need to know the number of argument
21:46:27 <glguy> s
21:46:43 <weitzman> Suppose I've got f :: (Int -> Int -> Bool). I want to get g :: (Bool -> c) -> Int -> Int -> C
21:47:13 <weitzman>  (. f) . (.) does that, but not very clearly
21:48:02 <weitzman> I'm thinking about this because of a tutorial question
21:48:08 <weitzman> Convert "func2 f g l = filter f (map g l)" to point-free
21:48:12 <weitzman> If possible
21:48:27 <weitzman> I wasn't very successful, but lambdabot found something
21:49:47 <glguy> heres where I was thinking
21:49:49 <glguy> >  ( (.recip).(+)) 3 7
21:49:50 <lambdabot>  3.142857142857143
21:49:51 <glguy> >  flip ((+).recip) 3 7
21:49:53 <lambdabot>  3.142857142857143
21:50:07 <glguy> so, (.f).(.) could be flip ((.).f)
21:50:14 <dons> roconnor: you blog much haskell/programming stuff?
21:50:39 <dons> (would you like to have your blog syndicated to planet.haskell.org? )
21:53:37 <glguy> was my thinking, but recip and (.) have different type sigs
21:55:03 <JosephRivers> what is the prefered style for block comments in haskell?
21:56:20 <dons> {- -}
21:56:29 <glguy> .lhs (-:
21:56:29 <dons> though generally, you just see -- on consectutive lines
21:56:32 <dons> -- line one
21:56:34 <dons> -- line two ...
21:56:39 <glguy> dons: what next?
21:56:55 <dons> ?fptools Data.List
21:56:55 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:57:03 <dons> JosephRivers: ^^ check some actual library source
21:57:24 <dons> (useful for picking up good style)
21:57:42 <dons> glguy: ?
21:57:48 <dons> ?brain
21:57:48 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
21:57:49 <glguy> -- line four?
21:58:04 <JosephRivers> thanks for the answers guys
21:58:06 <dons> oh, I was going to suggest: what next, what we do every day glguy -- try to take over the world!
21:58:14 <glguy> lol
21:58:25 <glguy> a much better response than I had anticipated (c:
21:58:34 <dons> heh
22:00:12 <JosephRivers> why does the vertical bar | keep appearing the the List.hs comments? Does it have some significance to a comment -> documentation generator?
22:00:26 <dons> that's to do with the haddock documentation generator, yes
22:00:37 <dons> it generates, from source, documents like:
22:00:39 <dons> ?docs Data.List
22:00:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:00:48 <dons> ?where haddock
22:00:49 <lambdabot> http://www.haskell.org/haddock/
22:01:12 <dons> so its really specific to library code (where you want to generate user docs)
22:06:36 <dons> does anyone have some favourite library source they like the coding style of?
22:06:48 <dons> i'm collecting some good examples for the wiki
22:19:28 <Pseudonym> Can you nominate your own?
22:19:40 <dons> sure
22:19:50 <dons> Pseudonym: you have some nice numeric stuff, that would be instructive?
22:19:53 <Pseudonym> My Dfa.lhs has been reused more than anything, so people like it.
22:19:56 <Pseudonym> http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Dfa/Dfa.lhs
22:20:02 <lambdabot> http://tinyurl.com/s3mzk
22:20:04 <dons> cheers
22:20:31 <Pseudonym> It's officially under any attribution licence you want, so feel free to grab it./
22:20:44 <foxy> @index State
22:20:44 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
22:20:44 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
22:21:46 <glguy> what is Dfa?
22:21:55 <dons> ?foldoc dfa
22:21:57 <lambdabot> *** "dfa" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
22:21:57 <lambdabot> DFA
22:21:57 <lambdabot>  
22:21:57 <lambdabot>     Deterministic Finite-state Automaton.  See {Finite State
22:21:57 <lambdabot>     Machine}.
22:21:59 <lambdabot>  
22:22:10 <Pseudonym> I also like this guy's style, apart from the fact that he doesn't respect the 80 column limit:
22:22:17 <Pseudonym> http://www.polyomino.f2s.com/david/haskell/foundations.html
22:22:20 <lambdabot> Title: Haskell for Maths: Foundations, http://tinyurl.com/gk2cl
22:22:53 <Pseudonym> Too much indentation, but otherwise very clean.
22:23:18 <dons> ah good yes.
22:25:14 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/
22:25:18 <Pseudonym> That's most of my interesting numeric code.
22:25:20 <lambdabot> Title: Index of /darcs/numbertheory
22:25:32 <Pseudonym> Well, number theoretic code, anyway.
22:25:43 <Pseudonym> Most of my floating point numeric code I am not proud of.
22:26:37 <dons> heh ok :)
22:26:48 <dons> do you know of any applications that looks nice?
22:26:51 <dons> or are instructive?
22:27:03 <dons> i have some obvious ones (from darcs, pugs, yi, ...)
22:27:15 <dons> but maybe there are some little gems out there.
22:27:18 <dons> djinn I think, perhaps
22:30:47 <newsham> dons: fps much much faster.  thanks!.
22:30:57 <dons> cool! :)
22:31:09 <dons> is the code somewhere public? i'll comment on it if you like
22:31:22 <weitzman> Does the fail function actually do anything with the string you give it?
22:31:31 <Pseudonym> Conjure seems very nicely written, though not well documented.
22:31:33 <glguy> depends on the monad
22:31:35 <dons> > fail "possibly" :: ()
22:31:36 <lambdabot>  Couldn't match `()' against `m a'
22:31:42 <dons> > fail "possibly" :: [()]
22:31:43 <lambdabot>  []
22:31:51 <weitzman> Yeah, I tested with a list monad
22:31:52 <Pseudonym> http://j.mongers.org/pub/haskell/darcs/conjure/Conjure/
22:31:53 <dons> > fail "possibly" :: Maybe String
22:31:54 <lambdabot>  Nothing
22:31:57 <lambdabot> Title: Index of /pub/haskell/darcs/conjure/Conjure, http://tinyurl.com/j9w56
22:32:01 <glguy> I'm guessing it works in Either
22:32:07 <dons> Pseudonym:good
22:32:14 <dons> > fail "possibly" :: Either String ()
22:32:15 <lambdabot>  add an instance declaration for (Monad (Either String))
22:32:16 <lambdabot>   In the expressi...
22:32:20 <dons> > fail "possibly" :: Either String String
22:32:21 <lambdabot>  add an instance declaration for (Monad (Either String))
22:32:21 <lambdabot>   In the expressi...
22:32:23 <dons> boo
22:32:39 <Pseudonym> http://darcs.haskell.org/~lemmih/downNova/src/ <- downNova, not too bad.
22:32:44 <lambdabot> Title: Index of /~lemmih/downNova/src, http://tinyurl.com/ghq57
22:33:00 <Pseudonym> Actually, point to the root directory.
22:33:04 <Pseudonym> Remove the /src/
22:33:28 <dons> yep that's good
22:33:33 <Pseudonym> And, of course, lambdabot is just SO well-engineered. :-)
22:33:37 <dons> :)
22:33:44 <dons> there's some nice plugins in lambdabot
22:33:46 <weitzman> Looks like IO does something with the string, but I couldn't have tested that on lambdabot
22:33:52 <Pseudonym> That's my lsit exhausted.
22:33:55 <Pseudonym> list
22:35:56 <glguy> http://www.nomaware.com/monads/html/errormonad.html
22:35:59 <lambdabot> Title: The Error monad, http://tinyurl.com/hgna5
22:36:00 <glguy> is an example
22:36:23 <glguy> of a place where fail *could* be meaningful
22:37:09 <weitzman> Are exceptions not a real part of Haskell 98?
22:37:26 <weitzman> They must be, I guess
22:37:30 <weitzman> > tail []
22:37:31 <lambdabot>  Add a type signature
22:37:46 <weitzman> > (tail []) :: [Int]
22:37:47 <lambdabot>  Exception: Prelude.tail: empty list
22:42:25 <glguy> If Cale were here, he'd complain about "fail"
22:43:10 <dons> Pseudonym: here, http://haskell.org/haskellwiki/Example_code
22:43:11 <lambdabot> Title: Example code - HaskellWiki
22:43:38 <dons> (I noticed that several non-haskell people were citing examples from this page for what haskell is supposed to look like -- and they weren't good example :S
22:44:53 <Pseudonym> Cool.
22:45:17 <Pseudonym> Looks good.
22:45:38 <dons> I like Colin Runicman's code, it exhibits this nice early-90s simplicity
22:45:49 <dons> before we were spoiled by -fglasgow-exts and cpp
22:47:00 <newsham> kids these days
22:47:17 <Pseudonym> I wish I still had my Miranda code.
22:53:37 <lispy> heh
22:53:51 <lispy> early-90s simplicity...god taht's good
22:56:01 <Pseudonym> OTOH those programs tend to do simple jobs.
22:56:06 <Pseudonym> I can't imagine darcs in that style.
22:57:48 <dons> yeah, there's a tradeoff. lambdabot or yi couldn't be written that way either.
22:57:52 <lispy> so which on is Colin Runicman'scode?
22:57:53 <dons> sometimes the IO just kicks your butt
22:58:00 <dons> lispy: SmallCheck
22:58:03 <lispy> ah
22:58:17 <lispy> so what is early 90's about it?
22:58:18 <Pseudonym> The best I managed to do was an implementation of diff in Mercory.
22:58:22 <dons> I think ndm inherits some of this too, the love for h98 for example
22:58:26 <dons> and lots of lists
22:58:32 <dons> no pragmas, no seqs, no nothing bad
22:58:34 <Pseudonym> The fact that you could cleanly separate the IO from the algorithms inside made it quite pretty.
22:58:45 <dons> mm. yes.
22:59:05 <Pseudonym> But that's like a compiler, and we all know that declarative languages are optimised for writing compilers.
22:59:06 <lispy> ah, i prefer to write my code that way, but i have been geting spoiled by things like overlapping instancens
22:59:51 <lispy> it seems that darcs is mostly in the IO mand
22:59:54 <lispy> er monad
23:00:05 <dons> lispy: yeah, yi/hmp3 too
23:00:11 <dons> though there could be some StateT in there
23:00:15 <lispy> and most functions take the same parameters in addition to the parameters they really care about
23:00:39 <lispy> so, recently we thought, maybe it should be in StateT or ReaderT
23:00:55 <lispy> like type DarcsM = ReaderT DarcsEnv IO
23:01:28 <lispy> put the redundant commonly occuring values into DarcsEnv and then pass them implicity
23:02:46 <lispy> in darcs we have a lot of functions which vary their 'strategy' passed on the command line options
23:03:07 <lispy> functions which stop their search at a certain point, or only produce a summary, maybe they do a dry run and so on
23:04:00 <lispy> it seems like a very real-world problem.  Haskell certainly doesn't get in the way for implementing it, but i don't know that it really helps either
23:04:19 <dylan> hmm. I wonder if I could replace some m4 templates with something haskell-related.
23:04:23 <lispy> (but i often i assume if i knew haskell better that maybe i would think it does help)
23:05:17 <lispy> dylan: if you're using m4 macros as part of your build configuration tools (like autotools) then maye you could use cabal hooks
23:05:26 <dylan> Ho
23:05:34 <dylan> I use m4 for redundant config files.
23:05:40 <dylan> like ~/.screenrc
23:05:48 <lispy> hmm...
23:05:51 <dylan> (I have slightly different .screenrcs for different machines.
23:05:54 <dylan> )
23:05:54 <lispy> that i know nothing about :)
23:06:51 <dylan> (I do have a perl project for testing esoterica about various systems... such as where to put vim config files)
23:07:07 <lispy> heh
23:08:08 <dylan> or the size of any given C structure, endianness, etc. some friends are using for a rather large C++ project. But anyway.
23:08:21 <dylan> since the following is possible:
23:08:25 <dylan> @let foo = "bunnies"
23:08:27 <lambdabot> Defined.
23:08:29 <dylan> > foo
23:08:30 <lambdabot>  Not in scope: `foo'
23:08:33 <dylan> err
23:08:36 <dylan> > L.foo
23:08:37 <lambdabot>  "bunnies"
23:08:54 <dylan> Then, it should be possible to embed haskell code in a file, given some delimiter.
23:09:08 <lispy> hmm...no lambdabot process...did i break my lambdabot server
23:09:35 <dylan> [% something %] where something is a haskell expression.
23:09:57 <dylan> with the same IO restriction and such as lambdabot
23:10:42 <lispy> @logs
23:10:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:10:57 <lispy> dylan: template haskell?
23:11:14 <dylan> lispy: that's for evaluating haskell code in haskell code, right?
23:11:18 <lispy> yeah
23:11:20 <dylan> like lisp macros or camlp4
23:11:23 <lispy> so maybe not what you want :)
23:11:28 <dylan> I want to evaluate haskell code in ~/.screenrc
23:11:35 <lispy> ?where log
23:11:36 <lambdabot> I know nothing about log.
23:11:42 <lispy> ?where logs
23:11:42 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
23:11:50 <dylan> (well, actually, in ~/wc/conf/screenrc@HOSTNAME.src.
23:12:01 <dylan> I have a rather complicated dotfile system. XD
23:12:04 <lispy> dylan: well, one of the haskell webserver libraries does this with html
23:12:23 <dylan> it seems easy, so I figure it must exist.
23:13:35 <dylan> heck, it'd be pretty easy to embed evaluated scheme in it.
23:13:56 <dylan> hmm, though, perhaps I should just try to find another preprocessor like m4 that isn't so kludgey
23:14:24 <dylan> though haskell is interesting because I could be sure there are no side effects!
23:19:30 <newsham> what about IO?
23:21:36 <dylan> well, it should be like @eval -- no IO allowed.
23:21:38 <dons> the world is my threaded state value
23:21:45 <dons> its all pure in the end
23:22:02 <lispy> dylan: actually @eval disallows more than IO
23:22:05 <lispy> ?help eval
23:22:05 <lambdabot> eval. Do nothing (perversely)
23:22:10 <newsham> dons: how do rewrite rules get added to ghc?
23:22:12 <lispy> dylan: i think you mean @run
23:22:21 <dylan> err, what ever > is
23:22:26 <lispy> newsham: look at the fps code :)
23:22:32 <lispy> ?help run
23:22:32 <dons> newsham: with the RULES pragma
23:22:33 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
23:22:35 <dons> @run 1+1
23:22:36 <lambdabot>  2
23:22:37 <newsham> which part?
23:22:50 <dons> ?google site:haskell.org using rewrite rules
23:22:53 <lambdabot> http://haskell.org/haskellwiki/GHC/Using_Rules
23:22:53 <lambdabot> Title: GHC/Using Rules - HaskellWiki
23:23:21 <lispy> i don't know exactly why my web lambdabot was down
23:23:23 <lispy> that was odd
23:23:32 <lispy> i thought it was working when i left for dinner
23:23:37 <lispy> so...i'll keep an eye on it
23:23:45 <newsham> ty
23:24:16 <lispy> but, for now i shall sleep
23:24:23 <lispy> dons: going to the workshop?
23:24:38 <lispy> dons: if so it would be nice to shake hands and say hi
23:24:47 <lispy> droundy talked me into going
23:24:56 <dons> it would be nice if someone pays for my flight :) so no, unfortunately, first one i've missed in 3 years
23:25:02 <lispy> ah
23:25:12 <lispy> i bet from your home that's a very $$ ticket
23:25:52 <lispy> for me it's 90 minutes in a car :)
23:25:55 <dons> yeah, it is a bit. the pacific is too big, and there's not enough competition on the sydney->LA path (I've heard tell its the most profitable route in the airline business)
23:26:08 <lispy> damn
23:26:15 <dons> more like 13 hours for me :)
23:26:29 <dons> then whatever it is from LAX to Portand
23:26:43 <lispy> lax to pdx is probably pretty short
23:26:53 <lispy> pdx to san fransisco is like 2 hours
23:26:55 <lispy> tops
23:27:01 <lispy> i think that included baggage
23:27:03 <dons> yeah, sounds about right
23:27:14 <dons> I think it was 2 hrs from LAX to salt lake city for the 04 workshoip
23:27:24 <lispy> i'd believe that
23:27:43 <newsham> travelling rule of thumb: never fly through lax.
23:27:46 <dons> that was nice, 04, desert sand storms on landing , then snow in the mountains that night
23:27:57 <lispy> hehe
23:28:20 <lispy> does the US seem boring compared to austrailia?
23:28:41 <lispy> we consider it to be exotic...so maybe the reverse is true :)
23:29:06 <dons> boring? seems like a bit busier australia, with more tv channels and highways. and more americans
23:29:21 <dons> they're pretty similar on the scale of things
23:29:25 <Pseudonym> Australia is, in many respects, the US' younger sibling.
23:29:32 <dons> yeah.
23:29:32 <lispy> heh
23:29:39 <lispy> we do love our tv
23:29:53 <Pseudonym> The main difference is that Australia has never had a war on its soil.
23:30:04 <Pseudonym> Unless you count a few Japanese bombs in WW2.
23:30:05 <lispy> for some values of war
23:30:13 <Pseudonym> For most values of war.
23:30:29 <Pseudonym> The number of armed insurrections can be counted on one hand.
23:30:42 <lispy> i don't know much about australia's history, but what about the colonies taking over the land of the natives?
23:30:43 <Pseudonym> And they mostly date from the penal colony days.
23:30:54 <dons> or last summer in cronulla
23:30:57 <newsham> so hawaii doesnt count now?
23:30:57 <dfranke> The US hasn't had one either since 1861.
23:31:22 <dfranke> Hawaii wasn't American soil during Pearl Harbor.  It became a state only after the war.
23:31:26 <Pseudonym> I guess you could call that a war of sorts, but there was no declaration, no treaties etc.
23:31:31 <Thomas2_> there wasn't really a war against the natives
23:31:34 <newsham> hawaii was a territory at the time
23:31:43 <Pseudonym> Not like New Zealand.  The British fought a formal war with the natives.  And LOST.
23:31:43 <Thomas2_> there was relatively little coordinated violence
23:31:51 <newsham> Wed Sep 13 20:27:49 HST 2006
23:31:54 <lispy> i've heard that asustralians made many of the same 'attacks' (mistakes?) against their natives that americans are guilty of
23:32:00 <Pseudonym> Sure.
23:32:06 <dons> that's quite true.
23:32:11 <Thomas2_> only in a couple of places
23:32:15 <Pseudonym> For the overwhelmingly common case, though, it was "settlers".
23:32:25 <Pseudonym> As they used to be called.
23:32:30 <Thomas2_> most of the rest of it is going on the poorest of historical evidence
23:32:53 <Thomas2_> it's also hard to evaluate to what degree the introduction of western diseases did all the work for them.
23:33:00 <Pseudonym> Basically, vigilantes conducting massacres, the horror of which should not be understated.
23:33:10 <Pseudonym> But I'd put that in the category of "crime" rather than "war".
23:33:15 <dfranke> Actually, on a technicality I wouldn't even count 1861.  That was on confederate soil.
23:33:21 <lispy> Pseudonym: fair enough
23:33:24 <dfranke> So 1812 then.
23:33:50 <lispy> well, i should bugger off to bed
23:33:54 <lispy> night all!
23:33:57 <lispy> and happy hacking
23:34:12 <dons> I think it would be interesting to do an aussie versoin of Deadwood, set in Ballarat or some such. There's many similar themes and issues
23:34:26 <Thomas2_> have you seen the tracker?
23:34:30 <dons> yeah.
23:34:53 <Thomas2_> I've only seen bits of it, not sure when I'll see the rest
23:43:18 <sjanssen> dfranke: there were battles fought on US soil
23:43:35 <dfranke> sjanssen: in which war?
23:44:11 <sjanssen> we're talking about the Civil War, yeah?
23:44:26 <dfranke> sjanssen: we were talking about a bunch of different ones.
23:44:57 <sjanssen> meh, I'm too tired to make sense.  Carry on
23:50:04 <dfranke> sjanssen: and right... I'd forgotten that the Battle Antietam penetrated onto Union soil.
23:51:41 <dfranke> anyhow, bed.
23:52:06 <newsham> hmm.. if I build with -prof -auto-all it doesnt find Data.ByteString
23:52:35 <dons> you haven't built fps with -prof ?
23:52:43 <dons> you need to pass the -p flag to cabal's configure phase
23:53:08 <newsham> will both prof and non-prof builds coexist?
23:53:30 <dons> yes
23:53:38 <newsham> thx
23:53:42 <Thomas2_> argh, can I quiz you guys about some haskell syntax?
23:53:58 <Thomas2_> suppose I have this:
23:54:04 <Thomas2_> f x =
23:54:17 <Thomas2_> erm, can that
23:54:18 <Thomas2_> f x
23:54:29 <Thomas2_>   | test x    = True
23:54:35 <Thomas2_> f 1 = True
23:54:39 <Thomas2_> f _ = False
23:54:56 <Thomas2_> do the latter terms get used if the test is false?
23:55:21 <dons> yes
23:55:25 <Thomas2_> ah
23:55:49 <Thomas2_> all these extraordinarily flexible haskell features seem to keep cropping up and breaking my translator
23:56:09 <weitzman> Translator from what to what?
23:56:17 <dons> ....
23:56:19 <Thomas2_> haskell to Isabelle/HOL
23:56:21 <dons> !
23:56:27 <dons> :)
23:56:49 <Thomas2_> well, come on, I didn't expect to have to deal with infix `` notation on the LHS of definitions off the bat
23:56:56 <Thomas2_> nor this particular use of case syntax
23:57:15 <dons> you should Language.Haskell to parse the stuff :)
23:57:27 <dons> ?hoogle parseModule
23:57:27 <lambdabot> Language.Haskell.Parser.parseModule :: String -> ParseResult HsModule
23:57:27 <weitzman> I don't know much about theorem proving environments, but I have to cheer for Twelf because Pfenning is awesome
23:57:27 <lambdabot> Language.Haskell.Parser.parseModuleWithMode :: ParseMode -> String -> ParseResult HsModule
