00:00:19 <lispy> dcnstrct: that is something haskell and lisp share, but have different strengths and weaknesses.  I'd say that lisp it's easier to make your new language blend in a bit more but in haskell it's easier to do the parts that really pay off
00:00:30 <P4W3R> o
00:00:34 <P4W3R> OOO
00:00:36 <Cale> I wrote a sudoku solver by constructing a monad specially tailored to solving Sudoku, essentially a small embedded language for solving sudoku puzzles. I then implemented the naive backtracking system in 4 or so lines :)
00:00:54 <P4W3R> not impresive in a haskell chanel
00:01:03 <P4W3R> try on a C++ channel
00:01:08 <dcnstrct> lol
00:01:51 <Cale> well, I'm not trying to be particularly impressive, just giving a sense of how one can construct domain specific languages that are effective
00:02:17 <glguy> Cale: I'm pretty sur that he just joined and is talking from his ass, but I've been wrong before
00:02:26 <Cale> glguy: yeah
00:02:33 <glguy> cool, we're on the same page ;)
00:02:38 <P4W3R> glguy: got me
00:02:50 <Cale> glguy: He was sort of responding to my comment though
00:03:01 <glguy> I'm sure he couldn't read the whole thing tho...
00:03:46 <foxy> @type (>>)
00:03:47 <Cale> dcnstrct: If you'd like to look, http://www.haskell.org/haskellwiki/Sudoku -- the top one is mine.
00:03:47 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
00:03:49 <lambdabot> Title: Sudoku - HaskellWiki
00:04:06 <foxy> > "Woot" >> "Woot"
00:04:07 <lambdabot>  "WootWootWootWoot"
00:04:19 <Cale> foxy: heh
00:04:34 <Cale> > [1..3] >> "Woot"
00:04:35 <lambdabot>  "WootWootWoot"
00:04:58 <glguy> > concat ["Woot" | _ <- "Woot"]
00:04:59 <lambdabot>  "WootWootWootWoot"
00:04:59 <lispy> > [0..] >> "Woot"
00:05:00 <lambdabot>  "WootWootWootWootWootWootWootWootWootWootWootWootWootWootWootWootWootWootWoo...
00:05:18 <P4W3R> > "Woot" ++ "Woot"
00:05:19 <lambdabot>  "WootWoot"
00:05:32 <P4W3R> nebwie command
00:05:35 <P4W3R> ~~
00:06:05 <lispy> > [ if c == 'o' then '0' else c | c <- "Woot" ]
00:06:06 <lambdabot>  "W00t"
00:06:10 <foxy> how does the construct |[1, 2, 3] >> Woot| work ?
00:06:30 <lispy> foxy: can you desugar it?
00:06:46 <lispy> i guess that's not a good way to put it
00:06:54 <lispy> i just mean, can you figure out how to break it down a bit more
00:07:08 <Cale> [1,2,3] >> "Woot" = [1,2,3] >>= const "Woot" = concat (map (const "Woot") [1,2,3])
00:07:26 <lispy> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y)}
00:07:27 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
00:07:43 <int-e> > cycle ""
00:07:44 <lambdabot>  Exception: Prelude.cycle: empty list
00:07:47 <foxy> yeah, I haven't used the list monad...
00:07:52 <P4W3R> > (/x [1..x] >> "Woot") 3
00:07:53 <lambdabot>  Not in scope: `x'
00:07:57 <P4W3R> mm
00:07:59 <P4W3R> forgot
00:08:12 <int-e> \x ->
00:08:14 <dcnstrct> this why functional programming matters link is great
00:08:18 <dcnstrct> thnx everyone for your help
00:08:19 <P4W3R> > (/x -> [1..x] >> "Woot") 3
00:08:20 <lambdabot>  Parse error
00:08:24 <lispy> which desugared is > [1,2,3] >>= (\x -> [4,5,6 >>= (\y -> return (x,y))))
00:08:30 <Cale> P4W3R: \
00:08:31 <P4W3R> > (\x [1..x] >> "Woot") 3
00:08:32 <lambdabot>  Parse error in pattern
00:08:36 <P4W3R> > (\x -> [1..x] >> "Woot") 3
00:08:37 <Cale> ->
00:08:38 <lambdabot>  "WootWootWoot"
00:08:38 <foxy> how is >>= implemented for lists?
00:08:44 <glguy> concatMap
00:08:46 <lispy> > [1,2,3] >>= (\x -> [4,5,6] >>= (\y -> return (x,y))))
00:08:47 <lambdabot>  Parse error
00:08:49 <Cale> x >>= f = concat (map f x)
00:08:50 <int-e> foxy: (>>=) = flip concatMap
00:08:50 <P4W3R> > (\x -> [1..x] >> "Woot") [1..2]
00:08:52 <lambdabot>  add an instance declaration for (Num [a])
00:08:52 <lispy> > [1,2,3] >>= (\x -> [4,5,6] >>= (\y -> return (x,y)))
00:08:52 <lambdabot>   In an arithmetic sequence: [1...
00:08:53 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
00:08:53 <glguy> or rather flip concatMap
00:09:07 <P4W3R> > (\x -> [1..x] >> "Woot") 10
00:09:09 <lambdabot>  "WootWootWootWootWootWootWootWootWootWoot"
00:09:09 <lispy> foxy: well, lets look at the type
00:09:14 <lispy> ?type (>>=)
00:09:15 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
00:09:20 <glguy> [1..3] >>= join replicate
00:09:23 <glguy> > [1..3] >>= join replicate
00:09:25 <lambdabot>  [1,2,2,3,3,3]
00:09:35 <lispy> for lists that means [a] -> (a -> [b]) -> [b]
00:10:00 <foxy> OK, I get [1..3] >> "Woot" now :)
00:10:01 <glguy> > [1..3] >>= ap replicate (1+)
00:10:02 <lambdabot>  [2,3,3,4,4,4]
00:10:03 <Cale> foxy: you obviously haven't read Monads as Containers yet, so I feel tempted to foist it upon you :)
00:10:04 <lispy> from the (a -> [b]) -> [b] we see that it probably has a concat
00:10:15 <P4W3R> bye
00:10:18 <foxy> Cale, you mean boxes of apples?
00:10:30 <lispy> foxy: and since it has [a] , then it probably needs a map
00:10:56 <Cale> foxy: indeed
00:10:58 <lispy> foxy: so we see that it will have concatMap without really knowing more than the type :)
00:11:03 <glguy> > [1..3] >>= liftM2 replicate (1+) ((-1)+)
00:11:04 <lambdabot>  [0,0,1,1,1,2,2,2,2]
00:11:07 <Cale> foxy: so maybe you have :)
00:11:21 <foxy> lispy, ah.... :D
00:11:33 <foxy> Cale, yeah, I just skimmed it
00:11:34 <Cale> > [1..3] >>= join replicate
00:11:36 <lambdabot>  [1,2,2,3,3,3]
00:11:36 <lispy> i'm pretty sure P4W3R was teekwod, but he was good this time...maybe the topic lock?
00:11:50 <glguy> Cale: I did that one first, but quickly tired of it ;)
00:12:04 <foxy> @type join
00:12:06 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
00:12:08 <Cale> glguy: ah, I'd missed it
00:12:16 <foxy> @type replicate
00:12:17 <lambdabot> forall a. Int -> a -> [a]
00:12:26 <glguy> Cale: teach him (->) r
00:12:28 <glguy> ;)
00:12:50 <foxy> @instance Monad
00:12:50 <lambdabot> Maybe you meant: instances instances-importing
00:12:59 <foxy> @instances Monad
00:13:00 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:13:06 <int-e> glguy: that's just a tablet with a value inscribed on it.
00:13:21 <int-e> glguy: in the monads as containers view.
00:13:22 <Cale> > let stutter = concat . zipWith replicate [1..] in stutter "Hello"
00:13:24 <lambdabot>  "Heelllllllooooo"
00:14:31 <Cale> int-e: hm?
00:14:40 <glguy> reader is ^
00:15:22 <int-e> Cale: you have values on a tablet, but you can also read the value on the tablet.
00:15:23 <Cale> In the monads as containers view, the reader monad ((->) r) gives you containers which are essentially boxes indexed by all the elements of r
00:15:43 <int-e> Cale: you're being too abstract ;)
00:15:44 <Cale> At least, that's how I'd translate it :)
00:16:40 <int-e> Cale: I just picked one particular such container.
00:16:50 <glguy> (\xs -> do { s <- sum; n <- genericLength; return (s / n) }) [1,3,7,10]
00:16:52 <Cale> Ah, I suppose you can sort of do that
00:16:55 <glguy> > (\xs -> do { s <- sum; n <- genericLength; return (s / n) }) [1,3,7,10]
00:16:55 <lambdabot>  Add a type signature
00:17:10 <glguy> > (\xs -> do { s <- sum; n <- genericLength; return (s / n) }) [1,3,7,10] :: Rational
00:17:11 <lambdabot>  Couldn't match `Ratio' against `(->) [i]'
00:17:31 <lispy> ?type genericLength
00:17:32 <lambdabot> forall i b. (Num i) => [b] -> i
00:17:33 <glguy> > (do { s <- sum; n <- genericLength; return (s / n) }) [1,3,7,10] :: Rational
00:17:34 <lambdabot>  21%4
00:17:46 <lispy> oh, cool
00:19:07 <glguy> > liftM2 (/) sum genericLength [1,3,7,10] :: Rational
00:19:08 <lambdabot>  21%4
00:19:39 <lispy> i should use rational more
00:19:45 <lispy> it's a nice class of numbers
00:21:04 <int-e> > toRational $ sqrt 2
00:21:05 <lambdabot>  6369051672525773%4503599627370496
00:21:11 <int-e> suggestive ;)
00:21:21 <glguy> (do { f <- (+); f }) 5
00:21:23 <glguy> > (do { f <- (+); f }) 5
00:21:24 <lambdabot>  10
00:21:49 <dons> ?undo (do { f <- (+); f }) 5
00:21:50 <lambdabot> ((+) >>= \ f -> f) 5
00:22:01 <dons> ?. pl undo (do { f <- (+); f }) 5
00:22:01 <lambdabot> 10
00:22:03 <dons> :)
00:22:19 <glguy> > join (+) 5
00:22:21 <lambdabot>  10
00:22:50 <int-e> @undo \x -> do Just a <- x; return a
00:22:51 <lambdabot> \ x -> x >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
00:22:59 <int-e> oh, it learned that.
00:23:27 <ValarQ> dons: undo?
00:23:37 <dons> undoes the do notation
00:23:37 <int-e> @help undo
00:23:44 <glguy> hey!
00:23:45 <ValarQ> i see
00:27:56 * lispy feels like he's really geting the hang of monads these days now that converting between do and bind notation is pretty natural and the state monad just seems to be logical
00:28:21 <Templar> can someone recommend any good(+free) text-editor for windows? Would like to have some more colors then wordpad have to offer ^^
00:28:35 <glguy> like Vim?
00:29:08 <Templar> dont know Vim. Is fre for download. Would like to have something like gedit
00:29:34 <Templar> should go for "Vim" then?
00:29:41 <dons> emacs? vim?
00:29:46 <dons> pfe?
00:29:57 <dons> is there bbedit for the windows?
00:29:59 <glguy> he said he's already got an operating system, windows, he doesn't need emacs also ;)
00:30:01 <lispy> Templar: textpad is pretty okay and can be configured to syntax highlight haskell, but i think it's only free as a tria
00:30:14 <lispy> Templar: or maybe JEdit
00:30:16 <gour> glguy: is g(vim) the best choice for haskell on linux (besides emacs - no time for learning it) ?
00:30:32 <glguy> seems popular enough to me
00:30:32 <ValarQ> glguy: you can't have windows without the want to replace it :P
00:30:34 <foxy> Templar, emacs
00:30:55 <glguy> Templar: ViM has a bit of a learning curve
00:31:07 <glguy> but then so does Haskell (for many people)
00:31:12 <lispy> Templar: if you can get a copy of visual studio 2003 from somewhere (like maybe throgh your university if you go to college) then visual haskell isn't half bad for beginners
00:31:18 <Templar> hmm, ok, I who thought emacs was complicated but guess it¥s good to learn :)
00:31:32 <lispy> Templar: i'm using emacs right now :)
00:31:35 <lispy> to chat with you :)
00:31:40 <ValarQ> :)
00:31:42 <dottedmag> lispy: +1
00:31:42 <glguy> there's a reason that people say "emacs is nice ,but I prefer linux"
00:31:54 <arcatan> cream is vim-made-easy
00:31:56 <ValarQ> lispy: which emacs irc client?
00:31:59 <glguy> what's that? faux-karma?
00:32:13 <dons> lispy++ -- is the preferred way
00:32:16 <lispy> ERC Version 5.0 $Revision: 1.743 $
00:32:23 <dons> since lambdabot will actually track it :)
00:32:39 <ValarQ> lispy: neat
00:33:30 <glguy> I really like using Visual Haskell... it's nice to see type errors as soon as possible
00:34:24 <gour> glguy: we want something like that on linux!
00:34:25 <ValarQ> i like the indentation help in the latest haskell-mode
00:34:43 <dottedmag> gour: eclipsefp?
00:35:07 <gour> dottedmag: it looks too bloated (eclipse itself)
00:35:17 <kep> gour here is an eclipse plugin for haskell
00:35:20 <midfield> if i want to profile a library that uses FPS, do i have to recompile FPS to use profiling too?
00:35:37 <dons> yep
00:35:52 <dons> add the -p flag to the configure step of building fps
00:35:57 <gour> dottedmag, kep: i'm trying with gvim & pida
00:36:33 <midfield> dons: thanks
00:36:53 <lispy> ?palomer
00:36:54 <lambdabot> Category theory is the Paris Hilton of mathematics
00:37:06 <glguy> even if you don't use it to program, Vi is definitely a good skill to have. If the computer you are on doesn't have MS Notepad... it'll have vi :)
00:37:17 * lispy nods at glguy 
00:37:31 <kep> gour: in this case I should try emacs :)
00:37:42 <gour> kep: emacs or xemacs?
00:38:00 <lispy> gour: doesn't really matter, they both seem to have pretty much the same features
00:38:19 <lispy> gour: i tend to stick with emacs because it's shorter to type :)
00:38:34 <gour> lispy: what about utf-8 support?
00:38:52 <lispy> gour: that i don't know...i live in the us so that's rarely a problem
00:38:54 <glguy> lispy: with that logic, you'd be an excellent candidate for "vi" ;)
00:39:08 <lispy> vi is nice for quick&dirty editing
00:39:19 <glguy> and emacs is good for irc? ;)
00:39:26 <ValarQ> glguy: exactly :)
00:39:30 <lispy> I use VI as a quick&dirty editor, but my fingers belong to Emacs.
00:39:30 <lispy> Larry Osterman
00:39:40 <lispy> glguy: emacs is the best irc client i've used
00:40:02 <gour> lispy: i live in croatia and it's important. vim is pretty good with unicode
00:40:35 <lispy> gour: well, emacs definitely supports non-ascii characters, i just don't know how well it does unicode (emacs supported it before unicode really existed)
00:41:14 <gour> lispy: xemacs has mule?
00:41:29 <lispy> gour: maybe (at the risk of starting a flame war) you should ask in #emacs and see what the crowd says
00:41:48 <lispy> gour: not sure, i only used xemacs for a few months about 3-4 years ago
00:41:57 <gour> what (x)emacs has in terms of haskell support over vim?
00:42:22 * gour already uses vim (lightly)
00:42:23 <Adamant> if you know Lisp (lot of Haskellers do), the Emacs are terrific
00:42:35 <Adamant> since they are programmable in Emacs Lisp.
00:42:36 <gour> Adamant: i'm not the one
00:42:41 <lispy> not sure, emacs has an indentation mode and syntax highlighting and it can display the types of Prelude functions in the status bar
00:43:20 <gour> hIDE with emcs/vim choice would be better solution for sure
00:43:29 <lispy> gour: but i'd say lambdabot is more help when programming in haskell than any editor i've used
00:43:52 <gour> lispy: on irc or run locally?
00:44:03 <lispy> gour: because of things like hoogle, pl, type and so on
00:44:13 <lispy> gour: you're on windows so you won't be able to run it locally (yet)
00:44:18 <lispy> er wait
00:44:23 <lispy> no that wassomeone else
00:44:26 * gour is on gentoo
00:44:30 <lispy> gour: i use lambdabot mostly from irc
00:44:53 <lispy> if you want to use lambdabot in offline mode i recommend ghci on acid (where you incorporate lambdabot into your ghci)
00:45:19 <arcatan> I would like to learn Emacs, but it's hard :(
00:45:52 <lispy> you need to have a hardcopy of the quickref sheet for the first couple months :)
00:46:03 * gour didn't know about ghci on acid. looks great
00:46:07 <midfield> @hoogle String -> Int
00:46:08 <lambdabot> No matches, try a more general search
00:46:17 <midfield> @hoolge String -> Num
00:46:17 <lambdabot> No matches, try a more general search
00:46:34 <lispy> @hoogle [Char] -> a
00:46:35 <lambdabot> No matches, try a more general search
00:46:39 <lispy> hmeee
00:46:44 <lispy> @hoogle Char -> a
00:46:45 <lambdabot> No matches, try a more general search
00:46:53 <lispy> something is wrong with hoogle right now i think
00:46:59 <lispy> @hoogle a
00:47:00 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
00:47:00 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
00:47:00 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
00:47:07 <lispy> @hoogle Char -> Int
00:47:08 <lambdabot> Char.digitToInt :: Char -> Int
00:47:08 <lambdabot> Char.ord :: Char -> Int
00:47:11 <lispy> or not
00:47:31 <midfield> hm
00:47:41 * lispy should go to sleep
00:47:43 <lispy> @localtime lispy
00:47:45 <lambdabot> Local time for lispy is Sat Sep  9 00:47:19 2006
00:48:38 * lispy >>= (\x -> do { y <- bed x; return $ rested y })
00:54:45 <kep_> lambdabot: @localtime kep
00:56:04 <kep_> @localtime kep
00:59:50 <foxy> Is this a Cabal problem? |undefined reference to `DistributionziPackage_a_closure'|
01:01:09 <boegel> @localtime dons
01:01:11 <lambdabot> Local time for dons is Sat Sep  9 18:00:48 2006
01:01:25 <boegel> @localtime boegel
01:01:26 <lambdabot> Local time for boegel is Sat Sep  9 10:01:07
01:01:37 <boegel> dons's day is almost over, mine is about to begin :))
01:01:44 <dons> :)
01:02:03 <dons> foxy: missing -package Cabal flag?
01:02:10 * boegel wonders how he'll deal with jetlag issues on his first trip to the US next week
01:02:21 <foxy> dons, do I need to do that with --make ?
01:02:29 <dons> shouldn't have to
01:02:55 <foxy> C:\Apps\MSYS\1.0\local\lib\ghc\Haskell\plugins-1.0\ghc-6.4.2/libHSplugins-1.0.a(Env.o)(.text+0xc7e):fake: undefined reference to `DistributionziPackage_a_closure'
01:03:25 <foxy> Cabal-1.1.4
01:04:17 <gour> lispy: it looks that goa needs fps & newer cabal. does ghc-6.6 satisfy both?
01:05:44 <dons> gour: should do
01:05:47 <dons> let me check..
01:06:50 <dons> gour: 6.6 seems to build just fine. but it doesn't need fps, does it?
01:06:52 <dons> ?where goa
01:06:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
01:07:31 <gour> dons: i have gentoo haskell overlay with ghc-6.5_pre20060901
01:07:54 <dons> goa doesn't need fps (or a newer cabal). so it should just build
01:07:58 <gour> dons: i'll try with that
01:08:02 <dons> if you're using the above goa
01:08:17 <gour> dons: but lambdabot needs it, true?
01:08:21 <dons> yep
01:08:23 <Templar> dose anyone know what this means?:
01:08:25 <Templar> Main> quickCheck prop_fahcon;  Falsifiable, after 0 tests:;  3 % 1
01:08:27 <dons> which 6.6 satisfies
01:08:42 <dons> Templar: it means your test failed with the input "3 % 1" i think
01:09:19 <Templar> ok =/
01:09:28 <foxy> @where hs-plugins
01:09:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
01:09:29 <Templar> geting faild with everything
01:09:41 * boegel poofs off again
01:10:49 <foxy> dons:
01:10:50 <foxy> $ darcs get --partial http://www.cse.unsw.edu.au/~dons/hs-plugins
01:10:50 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
01:10:52 <foxy> Invalid repository:  http://www.cse.unsw.edu.au/~dons/hs-plugins
01:10:52 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
01:11:04 * foxy blushes
01:11:30 <foxy> woops, not darcs repo
01:13:43 <dons> yeah, we don't have a @darcs for repos, but we should
01:25:35 <profmakx> hrmpf...
01:25:45 <profmakx>  Could not find module `Data.ByteString.Char8':
01:25:45 <profmakx>       it was found in multiple packages: base fps-0.8
01:25:54 <profmakx> when compiling lambdabot
01:26:02 <profmakx> anyone any hints where this comes from
01:26:03 <profmakx> ?
01:32:50 <falconair> hi, is it true that parser combinators consist of two distinct kinds of functions: parsers, which operate on some input data, accept it reject; and combinators which take parsers as parameters but don't operate directly on an input stream?
01:38:49 <dons> profmakx: means you've installed fps with a ghc 6.6 -- whihc you don't have to do
01:39:02 <profmakx> ah well
01:39:04 <profmakx> *selfslap
01:39:10 <dons> the fps dependency in lambdabot should be removed from lambdabot's .cabal file when using 6.6
01:39:14 <profmakx> why does it say ghc 6.5"?
01:39:26 <dons> ghc 6.5 =~ ghc 6.6
01:39:34 <profmakx> hehe okay
01:39:36 <profmakx> thanks!
01:39:55 <dons> yep. fps is in the base haskell package in new ghc 6.5s , and the upcoming ghc 6.6
01:40:13 <profmakx> i remember you writing this here a while ago
01:40:29 <dons> quite possibly
01:50:39 <profmakx> hmm and it seems regex-compat is a good idea too ;)
01:53:29 <dons> yes, you need to add regex-compat
01:53:34 <dons> i should check in a 6.6 .cabal file
01:53:47 <dons> in summary: replace the fps dep with a regex-compat dep
01:54:31 <foxy> @type filter
01:54:32 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:59:57 <foxy> @index partition
01:59:59 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
02:02:03 <dons> ?seen gds
02:02:03 <lambdabot> gds is in #haskell. I don't know when gds last spoke.
02:47:27 <foxy> > (\(x :: Num a => a) (y :: Num a => a) -> x + y) 3 4
02:47:27 <lambdabot>  Parse error in pattern
02:47:42 <xerox> ?yow!
02:47:42 <lambdabot> Now I'm having INSIPID THOUGHTS about the beautiful, round wives of
02:47:42 <lambdabot> HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS and being approached
02:47:42 <lambdabot> by SMALL BOYS selling FRUIT ...
02:47:46 <foxy> > (\(x :: Num a) (y :: Num a) -> x + y) 3 4
02:47:46 <lambdabot>  Parse error in pattern
02:49:27 <xerox> foxy: Num a is not a type.
02:49:38 <xerox> It is a class constraint on a type variable `a'.
02:50:03 <xerox> The syntax <expr> :: <type> can be extended for <type> :: (<constraints>, ..) => <type>.
02:50:14 <foxy> yeah, which is what I want to achieve in my app...
02:51:07 <int-e> > (\(x :: Num a => a) y -> x + y) 3 4
02:51:07 <lambdabot>  Parse error in pattern
02:51:16 <int-e> ah, of course.
02:51:32 <araujo> yay!
02:51:37 * araujo throws lambdas at everyone
02:51:53 <int-e> ouch!
02:51:58 <araujo> :-)
02:52:03 <int-e> these things are sharp you know.
02:52:15 <int-e> can't you throw - hmm - omicrons?
02:52:58 <foxy> classes are automatically exported from a module aren't they?
02:52:59 <araujo> haha
02:53:06 <dons> foxy: yep
02:53:55 <foxy> dons, does hs-plugins know this?
02:54:43 <dons> nope
02:55:06 <dons> i'm not sure it needs to
02:56:30 <foxy> dons, well I'm trying to use a type class as arguments for a dynamically-loaded function and I get |Not in scope: type constructor or class `Forkable'} when I try to dynamically compile
02:57:58 <dons> i suspect an explicit import will solve this
03:00:01 <foxy> dons, I'm restricted to listing imports as arguments to eval_
03:00:29 <beelsebob> foxy: type signatures can't go in patterns
03:01:14 <beelsebob> > ((\x y -> x + y) :: (Num a => a -> a -> a)) 3 4
03:01:14 <lambdabot>  Parse error
03:01:52 * beelsebob slaps lambdabot 
03:02:47 <int-e> > ((\x y -> x + y) :: Num a => a -> a -> a) 3 4
03:02:48 <lambdabot>  7
03:03:25 <foxy> OK, I've changed it to that, but dons, I still get |Not in scope: type constructor or class `Forkable|
03:03:44 <int-e> > ((\x y -> x + y) :: (Num a) => (a -> a -> a)) 3 4
03:03:45 <lambdabot>  7
03:03:49 <dons> not sure what's happening. you can fully control the imports , iirc.
03:04:05 <foxy> @where hs-plugins
03:04:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
03:04:09 <dons> e.g. as lambdabot does, for @eval
03:04:42 <foxy> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-4.html#node_sec_7 <- here
03:04:43 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/f8sdr
03:05:22 <dons> check the haddock docs?
03:05:55 <dons> http://www.cse.unsw.edu.au/~dons/hs-plugins/html/System-Eval-Haskell.html
03:05:56 <lambdabot> http://tinyurl.com/lxh4h
03:06:38 <dons> so the Forkable module isn't in the import list?
03:07:09 <dons> --> [Success]? is beelsebob using a haskell irc client?
03:07:19 <foxy> the forkable class is in one of the modules in the import list
03:07:21 <dons> oh ,that would be ExitSuccess
03:07:31 <dons> foxy, hmm. not sure then. sounds odd
03:07:46 <dons> build with debugging enabled, and check the generated src file, perhaps?
03:08:47 <foxy> how do I do that?
03:09:31 <dons> add -DDEBUG to the ghc-options in the .cabal file, and rebuild and install hs-pugins
03:09:41 <foxy> ok
03:13:05 <gour> dons: how lambdabot should be built in order to be used in goa (offline) ?
03:15:06 <dons> the normal way. just build and install in the lambdabot directory, using the normal build instructions
03:15:17 <dons> when building goa, edit GOA.hs and add the path to your lambdabot directory
03:15:27 <dons> the README describes, this. I think.
03:16:32 * deadbeef is reading pugs
03:16:56 <deadbeef> (or trying to)
03:16:58 <xerox> Good reading!
03:17:53 <deadbeef> rly
03:17:55 <gour> dons: Could not find module `Distribution.Simple':
03:19:29 <foxy> dons, the temporary file doesn't seem to get created, since its a compile error
03:19:53 <foxy> s/its/it\'s/
03:20:46 <dons> oh you might have to edit the src to prevent it removing the src file. (remove makeCleaner tmpf from src/System/Eval/Haskell.hs
03:28:36 <foxy> @where paste
03:28:37 <lambdabot> http://paste.lisp.org/new/haskell
03:29:07 <lisppaste2> foxy pasted "dynamic code" at http://paste.lisp.org/display/25685
03:29:31 <foxy> dons, I pasted the source generated, class forkable is defined in Operators
03:33:00 <araujo> morning!
03:33:20 <dons> foxy: ah, you need Operators already compiled (or else use makeAll), and you also need to supply the -I flag to have it included when ghc searches for it
03:33:43 <dons> so basically, ghc is compiling this file in /tmp, so it can't find either the Operators.hs file, or its .hi and .o friends
03:33:47 <dons> make sense?
03:34:06 <foxy> think so :) I'll try and see... it works for other things defined in Operators
03:35:37 <foxy> dons doesn't putting Operators in the argument to eval_ take care of this?
03:36:00 <dons> it'll get it into the import list, but how will ghc find the file?
03:38:09 <lisppaste2> foxy annotated #25685 with "more dynamics" at http://paste.lisp.org/display/25685#1
03:38:20 <foxy> um, well, um, but it works for other functions defined in Operators, like this paste
03:40:02 <dons> i'm not sure what's happening then
03:40:19 <dons> is Forkable defined in Operators?
03:40:28 <foxy> yes...
03:41:21 <dons> is it just the Forkable annotation is wrong? you need some -fglasgow-exts flags?
03:41:48 <foxy> class Forkable a where
03:41:50 <foxy>     fork :: Atomic -> a -> a -> a
03:43:34 <foxy> simple typeclass
03:49:39 <dons> foxy: hmm, how are you going to turn the polymorphic Forkable value into a Typeable?
03:49:53 <foxy> :)
03:49:55 <dons> dynamics don't work on polymorphic values.
03:50:03 <dons> you do some tricks with the Sem?
03:50:24 <foxy> Sem wraps things up, I thought I could do it that way
03:50:43 <dons> does that original src fragment even typecheck offline?
03:50:50 <dons> can you load http://paste.lisp.org/display/25685 in ghci?
03:51:23 <dons> seems to me you'll have a problem applying toDyn directly to something of polymoprhic type
03:51:46 <dons> > toDyn ((\a b -> a + b) :: Num a => a -> a -> a)
03:51:47 <lambdabot>  Add a type signature
03:52:00 <dons> never going to work
03:52:10 <dons> you'd have to wrap it before applying toDyn
03:52:43 <dons> (mentioned in the hs-plugins paper, I think, in a section on dealing with polymorphic dynamics)
03:53:09 <dons> oh hmm?
03:53:10 <dons> > toDyn ((\a b -> a + b) :: Num a => a -> a -> a)
03:53:10 <dons> <<Integer -> Integer -> Integer>>
03:53:11 <lambdabot>  Add a type signature
03:53:24 <dons> worked in ghci? /me boggles
03:53:34 <dons> ah I see :)
03:53:42 <dibblego> good evening
03:53:43 <int-e> > id
03:53:44 <lambdabot>  Add a type signature
03:53:50 <int-e> > id :: Int -> INt
03:53:50 <lambdabot>  Not in scope: type constructor or class `INt'
03:53:52 <int-e> > id :: Int -> Int
03:53:52 <lambdabot>  <Int -> Int>
03:54:07 <int-e> why does the above give <<...>>?
03:54:09 <dons> twas the defaulting turned my explicit Num a into an Integer.
03:54:29 <dons> hmm?
03:54:33 <foxy> dons, no it doesn't work in GHCi, this was going to be my use case for polymorphic dynamics
03:54:34 <int-e> no, why two < and >?
03:54:48 <int-e> @type toDyn
03:54:49 <lambdabot> forall a. (Typeable a) => a -> Dynamic
03:54:56 <dons> foxy: ok. well, if it doesn't work in ghci, i can't see how its going to work in hs-plugins :)
03:55:17 <dons> int-e, oh, ghci prints Typeables. lambdabot has its own show instance for some values
03:55:17 <foxy> dons, yeah but it was failing before I expected it to
03:55:34 <dons> right, not sure what that is.
03:55:56 <dons> but if you can find something that _does_ typecheck in ghci, but not in hs-plugins, i can investigate further
03:55:58 <foxy> dons, so I have a case where I need polymorphic dynamics
03:56:03 <foxy> dons, ok
03:56:24 <dons> int-e, we have 2 free theorem generators now :)
03:56:26 <dons> ?ft id
03:56:27 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
03:56:27 <lambdabot>   forall x1 :: T1.
03:56:27 <lambdabot>    h1 (t1 x1) = t1 (h1 x1)
03:56:42 <dons> the correct-but-verbose version, and:
03:56:44 <dons> ?free id
03:56:45 <lambdabot> f . id = id . f
03:56:54 <dons> Pseudonym's short-n-sweet one
03:57:53 <dons> "lambdabot, bringing you sophistamacated computer science since 2001"
04:08:35 <dons> ibid: looks like eivuokko has a haskell blog :) http://tamelambda.net/
04:08:37 <lambdabot> Title: tamelambda.net
04:08:48 <dons> eivuokko: want to add it to planet.haskell.org? (just ping ibid)
04:19:04 <araujo> sequence down?
04:31:40 <deadbeef> omg
04:31:44 <deadbeef> pugs is HUGE
04:32:09 <dons> strip the binary? and built with splitobjs?
04:32:22 <deadbeef> i mean it's like 1hr i'm building it
04:32:38 <dons> cool!
04:32:54 <dons> the longer you have to wait for it to build, the more goodies you get
04:33:08 <deadbeef> haha
04:34:34 <basti_> lol
04:35:12 <pejo> dons, interesting. I must immediately start porting ghc to vax.
04:35:33 <dons> think of the goodness!
04:35:50 * Patterner compiles 6.5-pre20060907 on gentoo  "Bleeding Edge, Baby!"
04:36:17 <pejo> dons, probably too good for me!
04:37:23 <Adamant> bleed bleed bleed
04:37:34 <Adamant> -funroll-loops!
04:37:45 <Adamant> (I keed, I use Gentoo)
04:44:07 <foxy> http://lambda-the-ultimate.org/node/1715
04:44:08 <lambdabot> Title: Rewriting Haskell Strings | Lambda the Ultimate
04:45:05 <dons> hey nice :)
04:57:19 <foxy> dons, pg 12, ", up to 88% faster". Is there something missing?
04:58:28 <int-e> on average, and up to. no, nothing is missing
04:59:05 <dons> yeah looks ok to me.
04:59:18 <Pupeno> Haskell can't be properly highlighted by Kate :(
04:59:32 <dons> Kate--
04:59:36 <foxy> I missed the "on average" sorry :)
04:59:50 <foxy> nice work dons + co. :)
04:59:52 <dons> that's ok. I forgive you. but don't let it happen again!    ;)
05:00:19 <dons> :)
05:00:30 <Pupeno> Is yi usable ?
05:00:46 <dons> its a usable vi, yep
05:01:01 * foxy coughs
05:01:32 <dons> what foxy? something go down the wrong way? you shouldn't talk and eat at the same time   ;)
05:06:24 <foxy> heh
05:07:17 * dons notes a bit of a spike in paper downloads after the LtU article
05:07:42 <int-e> big brother dons
05:08:36 <dons> heh
05:14:47 <spiffy> hmmm is it possbile for an instance of a class to have a more specific return type then in the class def?
05:15:36 <xerox> spiffy: may you be more precise, i.e. write it down in Haskell? :)
05:16:11 <int-e> The way I understand the question the answer is no.
05:17:01 <spiffy> well i have a type signature in the class definition of a -> Type b , can an instance possibly have a type signature of a -> Type String
05:18:29 <dons> with ATs or FDs you could
05:18:36 <dons> maybe GADTs too?
05:19:10 * spiffy 's eyes glaze over
05:19:11 <dons> if you're happy to associate one type with each instance?
05:19:21 <spiffy> i am
05:19:34 <dons> ok. FDs then. let me write something ...
05:19:40 <int-e> class X a b | a -> b where foo :: a -> b  could maybe do what you want, yes
05:19:47 <Baughn> Is it possible to have GHC emit the full inferred type information for some source?
05:20:32 <dons> int-e, yep. that's what i had too
05:21:02 <spiffy> can someone explain that example a little more?
05:21:24 <dons> class C a b | a -> b where f :: a -> Int -> b
05:21:24 <dons> instance C Int String where f a i = show a  -- Int -> Int -> String
05:21:24 <dons> instance C Bool ()    where f a i = ()      -- Bool -> Int -> ()
05:21:40 <dons> you associate a return type, 'b' with each instance
05:22:00 <dons> the | a -> b tells the compiler that each 'b' is uniquely determined (i.e. a function) by a given type 'a'
05:22:19 <spiffy> ah perfect
05:22:38 <dons> f :: forall a b. (C a b) => a -> Int -> b
05:22:44 <dons> for example
05:23:06 <dons> *Main> f (8 :: Int) 3
05:23:07 <dons> "8"
05:23:07 <dons> *Main> f True 3
05:23:07 <dons> ()
05:23:08 <dons> :)
05:23:22 <spiffy> ERROR file:main.hs:5 - Haskell 98 does not support dependent parameters
05:23:46 <dons> in hugs you'll need to add -98 at least
05:23:56 <dons> or just use ghc :)
05:24:16 <dons> (since you're adding multiparameter type classes and functional dependencies)
05:24:35 <xerox> Milliolegs.
05:24:49 <spiffy> well since that seems so freakin awsome ill get ghc :)
05:25:01 <dons> hugs might be able to do it too. let me see.
05:25:15 <dons> yep, hugs -98
05:25:16 <dons> Main> :t f
05:25:16 <dons> f :: C a b => a -> Int -> b
05:25:35 <xerox> @remember spiffy well since that seems so freakin awesome ill get ghc :)
05:25:39 <dons> hehe
05:26:03 <dons> Baughn: yep. let me find the url for you on how to do this
05:26:03 <spiffy> d'oh didnt actually enable extensions on that restart
05:28:43 <spiffy> oo thats damn cool
05:29:12 <fasta> It seems lazyness actually helps debugging. Who would have thought that?
05:29:26 <dons> Baughn: i thought that ghc -ddump-types would work, but doesn't seem to here. -ddump-parsed gives you the parse tree.
05:29:40 <Baughn> dons: If only it had a manpage. :/
05:30:04 <dons> it does. check the 'users guide' on haskell.org/ghc
05:30:19 <Baughn> I'm reading it, but that isn't really a manpage in the "man ghc" sense
05:31:23 <fasta> his  manual  page documents briefly the ghc and ghci commands.  Exten‚Äê sive documentation is available in various other formats including DVI, PostScript and HTML; see below.
05:32:06 <dons> you can use the following script to infer types from vim, if that's kind of what you're doing: http://www.cse.unsw.edu.au/~dons/tmp/typeOf.txt
05:32:08 <lambdabot> http://tinyurl.com/f6fe9
05:32:22 <Baughn> fasta: So.. it's just me who's missing a manpage, then.
05:32:30 <fasta> Baughn: actually it's a Debian service.
05:32:39 <dons> (and you can always -ddump-simpl to see the fully annotated, desugared source)
05:32:46 <fasta> Baughn: You are using?
05:32:54 <Baughn> fasta: Gentoo
05:33:02 <fasta> Baughn: there you have your problem :P
05:33:19 <dons> ah, my mistake, -ddump-tc does work
05:33:49 <dons> TYPE SIGNATURES
05:33:49 <dons>     :Main.main :: IO ()
05:33:49 <dons>     main :: forall a. a
05:33:49 <dons>     x :: Integer
05:33:49 <dons>     y :: [Char]
05:33:51 <dons>     z :: (Bool, Maybe ())
05:34:03 <Baughn> Okay, this could be useful
05:34:11 <dons> just using $ ghc -ddump-types
05:34:49 <dons> -ddump-tc dumps it out as:
05:34:50 <dons>     Main.y :: [Char]
05:34:50 <dons>     []
05:34:50 <dons>     { y = "foo" }
05:34:55 <dons> for y = "foo"
05:35:33 <fasta> dons: I did state<-get;update_state_somewhere;put state{member=value}, by tracing I saw that update_state_somewhere was not evaluated. Pretty useful, in a strict language it would have been evaluated, but it would be "overwritten" again.
05:36:27 <dons> ah nice
05:46:41 <dmwit> @where monads as containers
05:46:41 <lambdabot> http://www.nomaware.com/monads/html/index.html
05:47:22 <dmwit> @google monads as containers
05:47:24 <lambdabot> http://haskell.org/hawiki/MonadsAsContainers
05:47:24 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
05:48:34 * kanzi just read that tutorial - found it helpful.
05:57:48 <dons> Baughn: I added a wiki page, http://haskell.org/haskellwiki/Inferring_types
05:57:51 <lambdabot> Title: Inferring types - HaskellWiki, http://tinyurl.com/l44zc
05:58:36 <gds> dons: You "@seen"ed ?
05:58:37 <dons> morning ndm
05:58:47 <ndm> morning dons
05:58:48 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:58:51 <dons> gds, ah let me think
05:59:03 <gds> (morning all ;)  )
05:59:13 <dons> gds, I think it was to ask if you wanted to add your blog to planet.haskell.org ?
05:59:26 <gds> Ah - yes, that would be very cool :)
05:59:34 <ndm> @tell dmhouse its deliberate for now, hoogle 4 will fix it
05:59:35 <lambdabot> Consider it noted.
05:59:37 <dons> in which case, just ping ibid, and he'll add it
05:59:52 * dons wants more haskell blogs to read :)
05:59:52 <ndm> dons: i was wondering, is haskell weekly news dead/dying?
05:59:59 <dons> nope. just busy :)
06:00:02 <dons> expect an issue tomorrow though
06:00:06 <ndm> dons: and if so, i was thinking of things to make it easier for you to do
06:00:09 <dons> i'd prefer to make it bi-weekly
06:00:12 <gds> Cool - will do :)
06:00:38 <dons> ndm, i could get it down weekly if i had a tool to grab the gmanue mail url from my email client
06:00:52 <dons> so when I read some new article, it goes straight into the content.hs file
06:00:55 <ndm> perhaps wiki it, then freeze it once a week? perhaps have an account where people can send summaries and you just glob them up?
06:00:59 <dons> currently, i have to go and trawl gmane to find it
06:01:05 <dons> hmm. maybe!
06:01:14 <ndm> what if you had a tool that automatically searched gmane for you?
06:01:23 <ndm> i.e. after you've got the whole thing done
06:01:49 <dons> right. what i could have is a tool that given a mail author/subject pair, gave me the gmane url for that mail
06:01:56 <dons> that would save a lot of time
06:02:15 <ndm> yeah, was just trying to think of things that would save you some time, and make it easier for you
06:02:23 <dons> thanks :)
06:02:25 <ndm> not that i could even write such a tool...
06:02:32 <dons> you've spotted the issue, its just time pressure
06:02:40 <dons> in particular, this paper, and before that, my phd review.
06:02:51 <ndm> yeah, i understand :)
06:02:52 <dons> hence the gaps in the last 6 weeks
06:03:08 <dons> but i've tomorrow's article almost done
06:03:13 <ndm> ok, cool
06:03:31 <dons> i'll think about this tool issue, its help so far to automate things
06:04:00 <ndm> would having it on a wiki slow down you at all?
06:04:24 <dons> it might make it easier to get extra content
06:04:42 <dons> i don't think it would help prepare the basic article though, i'd still have to read the mail archives
06:05:04 <ndm> so where is the most time spent?
06:05:07 <dons> (i do have some articles sent in already. more would be better)
06:05:22 <dons> oh, 90% is reading the mailing list archives, extrating threads and urls
06:05:54 <ndm> threads/urls can be automated
06:05:57 <dons> during the week i note down new releases and so on, then on publishing day i read all the mailing list archives, and write some markup, which is then further typeset by a tool, generating the html, wiki and txt versions
06:06:08 <dons> ndm, yes, I think so.
06:06:12 <dons> particuarly the url stuff
06:06:40 <ndm> hmm, reading all the archives at the end sounds painful
06:06:40 * dons has a peek at the gmane search system
06:06:49 <dons> takes about 1 hour
06:06:49 <ndm> don't you usually read them as you are going through?
06:06:57 <dons> yes! in my mail client
06:07:07 <dons> i only read the subjects, of course
06:07:24 <dons> the problem is getting from the msg in my inbox, to a permanent url (or thread)
06:07:33 <dons> boo on indirection ;)
06:08:05 <dons> haskell.org's mail server should tag msgs with a permanent url
06:08:13 <dons> that would make life super easy for us all
06:08:26 <ndm> (phone)
06:09:49 <dons> looks like some useful searching tools on gmane. hmm
06:10:32 <ndm> what i'd love is for patches to have a link to the actual diff
06:10:52 <ndm> and gmane url's would also be uber handy
06:11:24 <dons> yes, darcs patches. i agree. that would be useful
06:11:54 <ndm> it would also be nice to have a ghc-developers and a ghc-patches
06:12:06 <dons> ?users #haskell
06:12:06 <lambdabot> Maximum users seen in #haskell: 242, currently: 217 (89.7%), active: 23 (10.6%)
06:12:12 <dons> so who wants to bet on the date we hit 300?
06:14:08 <foxy> do you have a graph of usage over time?
06:14:27 <dons> ?where stast
06:14:28 <lambdabot> I know nothing about stast.
06:14:30 <dons> ?where stats
06:14:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
06:14:33 <dons> is the best we have
06:15:10 <ndm> why not a maximum users concurrently graph?
06:15:19 <ndm> or average concurrent users
06:15:38 <dons> too much thinking. but i think freenode has a page for that hmm.
06:18:13 * basti_ doesnt even appear in that graph :(
06:18:41 <dmwit> basti_ was tight-lipped, too, averaging 31.9 characters.
06:18:46 <ndm> dcoutts_ has quite a potty mouth. 0.0% words were foul language.
06:18:48 <ndm> Pseudonym also makes sailors blush, 0.0% of the time.
06:19:00 <ndm> haskell has a pretty pathetic amount of swearing
06:19:02 <basti_> huh
06:19:16 <basti_> ah, but not in 2006
06:19:23 <dons> ndm, but so many type errors!
06:19:29 <xerox> ?ya
06:19:29 <lambdabot> Aye
06:20:07 <Igloo> You should add "Java" and suchlike as swearwords
06:20:10 <Daveman> xerox :)
06:20:17 <xerox> :)
06:20:22 <dons> heh Igloo
06:21:44 <dmwit> lambdabot's faithful follower, dons, didn't speak so much
06:21:46 <dmwit> =P
06:23:18 * Patterner is still compiling ghc...
06:23:29 <Patterner> more than 2 hours now
06:23:37 <basti_> :|
06:34:31 <dons> ndm, ok. seems i can search fairly accurately with just subject, list and mail address on gmane. maybe i can automate this
06:34:35 <Baughn> I'm getting a few errors compiling the HAppS hello world application, namely this:
06:34:38 <Baughn> /usr/local/lib/HAppS-0.8.1/ghc-6.4.2/libHSHAppS-0.8.1.a(ParseURI.o): In function `__stginit_HAppSziProtocolsziSURIziParseURI_':ghc16290.hc:(.text+0x5dbc): undefined reference to `__stginit_HAppSziUtilziByteStringCompat_'
06:34:46 <ndm> dons: cool :)
06:34:48 <Baughn> Should I be passing something I'm not?
06:34:58 <dons> looks like a missing -package flag/
06:35:02 * musasabi feels guilty.
06:35:15 <dons> oh :S
06:35:16 <musasabi> Baughn: repull in a few minutes.
06:36:27 <ndm> i wrote a haskell compiler :) - which generates C out of the back end of Yhc
06:36:59 <dons> a C backend, that's new isn't it?
06:37:09 <dons> or not?
06:37:34 <ndm> yep, brand new
06:37:44 <ndm> and also a pile of transformations as well
06:37:57 <dons> very nice!
06:38:00 <dons> ndm++
06:38:17 <musasabi> Baughn: pull and runghc Setup build again.
06:38:29 <ndm> i haven't benchmarked it yet - i'm working on a suitable benchmark
06:39:48 <musasabi> I really should move the test scripts to use Cabal to catch bugs in cabal files.
06:40:49 <Baughn> musasabi: That's what I call quick turnaround!
06:41:08 <Baughn> musasabi: But you realize I'll expect you to solve all my problems in two minuts from now on, don't you?
06:41:38 <musasabi> heh
06:47:24 <Philippa> ndm: is YHC's bytecode documented anywhere?
06:47:41 <ndm> Philippa: yes, just looking..
06:47:43 <ndm> @where yhc
06:47:43 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
06:47:57 <ndm> Philippa: http://www-users.cs.york.ac.uk/~ndm/yhc/bytecodes.html
06:48:01 <lambdabot> Title: Yhc - Bytecode Documentation, http://tinyurl.com/h84m8
06:49:35 <Patterner> yay! "Glasgow Haskell Compiler, Version 6.5.20060907"
06:51:33 <Philippa> thanks
06:53:12 <Pupeno> With ghc 6.4.2, do I have to install FPS separately ?
06:54:28 * SamB wonders how to get rid of Debian packages he doesn't actually use...
06:54:37 <Pupeno> SamB: aptitude
06:54:48 <SamB> how will it know what I actually use?
06:54:54 <dons> Pupeno: yep
06:55:00 <Pupeno> SamB: aptitude is capable of removing unused dependecies.
06:55:11 <dmwit> ... you can also use it [unsafePerformIO] to defeat the Haskell type system... =O
06:55:13 <Pupeno> SamB: the cach is that you'll have to use aptitude to install the files as well.
06:55:16 <SamB> I meant like if it looked access times or something...
06:55:26 <SamB> er, *looked at
06:55:26 <Pupeno> SamB: it works like this:
06:55:38 <SamB> unfortunately I didn't install everything with aptitude
06:56:07 <Pupeno> SamB: each package is either automatic or not-automatic.
06:56:16 <SamB> yes, I know how that works...
06:56:49 <Pupeno> SamB: you can use markauto and unmarkauto to make your choices of what you really want, and the aptitude will clean up.
06:57:22 * clanehin thinks that SamB wants debian to actively watch when he never uses a program
06:57:59 <Pupeno> I believe there are programs for doing that... but that's too fine grained for my taste.
06:58:25 <SamB> I want something that will tell me some application packages I never use...
06:58:34 <SamB> or at least, not lately...
06:58:45 <SamB> you know, the ones I forgot I installed
06:58:58 <SamB> (tool packages too...)
07:00:47 <dwm> I periodically go through the output of `dpkg --get-selections` or `dpkg -l` and look for obvious programs I installed at some time and never use. Blow them away.
07:01:17 <dwm> Also, the selections list is nice to dump during a regular backup so you can use it to repopulate a new system in the event of tragic disaster.
07:03:04 <dons> ndm, done!
07:03:05 <dons> $ gmane haskell 'Simon Marlow' 'putStr is not evaluated in the correct order'
07:03:05 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/14168/
07:03:07 <dons> :)
07:03:09 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/z8dvl
07:03:22 <ndm> dons, well done :)
07:03:30 <dons> takes the list, author and subject, gives me an url.
07:03:40 <dons> haskell++ -- who needs shell scripts? not me!
07:03:44 <ndm> and all that can be automated
07:03:54 <ndm> how do you scrape a web page using haskell?
07:04:12 <dons> system "w3m -dump_source" :)
07:04:13 <ndm> I just want a readURL :: URL -> IO String, but never found one
07:04:21 <dons> oh, lambdabot has one of those
07:04:25 <ndm> why not wget?
07:04:35 <clanehin> samB, popcon has a facility that does something like this
07:04:38 <dons> getHtmlPage :: URI -> Proxy -> IO [String]
07:04:54 <dons> ah yeah, should just use wget
07:05:44 <ndm> i would love if getHtmlPage was in the network library, but a little bit less HTML'y
07:11:07 <gour> dons: with latested cabal & ghc emerged, lambdabot complains about missing 'network-any' ?
07:11:36 <dons> you don't have package network installed?
07:11:43 <dons> its in the extra-libs of ghc now.
07:12:43 <gour> dons: ahh...let me check haskell overlay...
07:17:17 <int-e> network wasn't a problem here. the fps dependency is superfluous and something wanted the regex-compat package.
07:19:05 <dons> ah yes. with 6.6 s/fps/regex-compat/
07:19:22 <dons> i think i in fact checked in lambdabot.cabal.ghc-6.6
07:26:59 <gour> @where paste
07:26:59 <lambdabot> http://paste.lisp.org/new/haskell
07:27:45 <lisppaste2> gour pasted "lambdabot build error" at http://paste.lisp.org/display/25703
07:27:59 <gour> dons: ^^^
07:28:09 <dons> mising haskell-src somehow?
07:30:23 <lisppaste2> gour annotated #25703 with "ghc-pkg list" at http://paste.lisp.org/display/25703#1
07:30:46 <gour> dons: ^^^
07:35:55 <Pupeno> there's a Haskell overlay ?
07:36:23 <gour> Pupeno: yes. emerge layman and you'll see it
07:36:37 <gour> Pupeno: if you're on gentoo
07:36:46 <Pupeno> gour: yes, I am. I'll check it.
07:37:34 <gour> Pupeno: join #gentoo-haskell too
07:51:35 <lisppaste2> syntaxfree pasted "weird error" at http://paste.lisp.org/display/25705
08:01:45 <int-e> @karma <
08:01:46 <lambdabot> < has a karma of 0
08:01:49 <int-e> <--
08:01:53 <int-e> @karma <
08:01:53 <lambdabot> < has a karma of 0
08:01:57 <ndm> @karma hoogle
08:01:58 <lambdabot> hoogle has a karma of 2
08:02:03 <ndm> @karma lambdabot
08:02:03 <lambdabot> lambdabot has a karma of 22
08:02:37 <ndm> @karma spj
08:02:38 <lambdabot> spj has a karma of 0
08:15:29 <mahogny> compiling with parsec, what need I add to the ghc? getting lots of undefined references
08:18:30 <jgrimes> mahogny, -package parsec?
08:18:51 <mahogny> yes thx
08:18:58 <jgrimes> :D
08:19:15 <dwm> Is that for the link step?
08:19:31 <mahogny> yeah
08:43:57 <tibbe> @ya
08:43:57 <lambdabot> Drink up, me 'earties
08:44:08 * tibbe have just had a nice day of math at the beach
08:44:17 <tibbe> - the have
08:44:18 <fasta> Shouldn't two runs of the same function give the same trace?
08:45:41 <Lemmih> Trace as in Debug.Trace? No.
08:46:13 <fasta> Lemmih: why not?
08:46:22 <fasta> Lemmih: I am running this from ghci
08:50:09 <glguy> fasta: I don't know your specific situation, but if some value didn't need to be recomputed... the path that ran through a trace function might not be executed again
08:50:22 <glguy> (i imagine at least)
08:50:29 <fasta> glguy: yes, I imagine that too.
08:50:46 <fasta> glguy: but I don't expect that for two sequential runs
08:50:57 <fasta> glguy: (in ghci)
08:51:34 <fasta> glguy: I expect that the environment is cleared when I evaluate another expression, and apparently it is not.
08:51:38 <SamB> well, you might be able to change it...
08:51:58 <SamB> ah
08:52:00 <fasta> Oh, sure I can change everything, that's the nature of software
08:52:00 <glguy> I think it's cool that if I type: let f = trace "a" 1
08:52:00 <SamB> :set +r
08:52:02 <glguy> and then f and then f
08:52:07 <glguy> the "a" only appears once
08:52:21 <SamB>  Options for ':set' and ':unset':
08:52:21 <SamB>     +r            revert top-level expressions after each evaluation
08:52:57 <fasta> SamB: thanks, what was the configuration file again?
08:53:10 <fasta> (to make the change permanently)
08:53:15 <SamB> fasta: oh, ~/.ghci
08:53:22 <SamB> but why would you want to?
08:53:47 <fasta> SamB: I am debugging something, and I want reproducable output
08:54:16 <SamB> or, you could just use the .ghci file in that directory, instead
08:54:16 <fasta> The trace is part of what I consider to be output.
08:54:38 <fasta> I don't use the trace as output for any other program.
08:54:53 <fasta> I know what not to use trace for.
08:55:12 <SamB> so, maybe in $PWD/.ghci instead ;-)
08:55:48 <SamB> probably if you put something there GHCi will complain about the permissions until you get them set to its liking...
08:56:21 <fasta> I need to read the users guide first to figure out the syntax of the .ghci file, unless you tell me it.
08:56:31 <fasta> (which I don't expect)
08:57:07 <SamB> just the same as input to ghci, really...
08:58:13 <SamB> so, you'd literally just put ":set +r" in it...
08:59:24 <fasta> Yeah, I verified that from the user manual. Thanks
08:59:27 * SamB wonders who's top-level expressions are reverted
09:00:14 <fasta> Unfortunately, it does not work as advertised
09:00:18 <SamB> oh?
09:00:37 <SamB> what happens when you run GHCi? look carefully for error messages!
09:00:37 <fasta> I don't get the same trace, while I evaluate the same expression
09:01:01 <fasta> No, error messages.
09:01:02 <SamB> also, make sure none of your files are compiled! that might be important.
09:01:14 <fasta> SamB: none are compiled
09:01:23 <SamB> hmm. okay I guess it is broken.
09:01:51 <SamB> so, you have floated-out expressions involving trace?
09:04:01 <lisppaste2> gour pasted "lambadbot error" at http://paste.lisp.org/display/25709
09:04:19 <gour> anyone can spot what's wrong ^^^ ?
09:04:23 <fasta> SamB: floated-out expressions?
09:04:38 <fasta> SamB: what is that?
09:05:17 <SamB> well...
09:06:02 <SamB> expressions that do not depend on the arguments to a function can be floated out of it
09:06:43 <xerox> gour: ghc-pkg describe haskell-src-1.0 shows that the mentioned module is exported?
09:07:12 <SamB> or perhaps you actually put traces in top-level expressions?
09:09:05 <fasta> SamB: I haven't got the word trace in the thing I evaluate in ghci. I do however have them inside the expression it stands for obviously.
09:12:17 <SamB> actually, GHCi doesn't do optimization does it...
09:12:29 <SamB> what does your code look like?
09:16:06 <fasta> SamB: I don't think it does. I can't post the code, but it's full of traces.
09:23:58 <gour> dons: kolmodin says you're using some module from haskell-src which is not supposed to be used
09:24:17 <kolmodin> argh, don't drag me into this! :D
09:24:56 <gour> he he
09:25:07 <kolmodin> in haskell-src.cabal,  Language.Haskell.ParseUtils is listed under 'other-modules', not under 'exposed-modules'
09:25:21 <kolmodin> so it sure looks like it's not supposed to be used
09:25:30 <gour> kolmodin: you can cope with him
09:26:35 <kolmodin> dons don't look to be in atm
09:27:17 <kolmodin> gour: btw, are you using the latest lambdabot?
09:27:28 <gour> kolmodin: yep
09:27:33 <kolmodin> ok
09:32:10 <shapr> @yow!
09:32:10 <lambdabot> TAILFINS!! ... click ...
09:32:45 <dylan> @yow!
09:32:45 <lambdabot> Could I have a drug overdose?
09:35:16 * shapr hugs lambdabot
09:35:51 <pandres> @yow!
09:35:52 <lambdabot> Can I have an IMPULSE ITEM instead?
09:36:43 <xerox> @vixen No way.
09:36:44 <lambdabot> Most guys don't understand me, but we really seem to connect.
09:36:56 <shapr> I can't BELIEVE it's not BUTTER!
09:37:10 <shapr> I'm tempted to manufacture my own yow! quotes.
09:37:17 <shapr> @remember yow I can't BELIEVE it's not BUTTER!
09:37:29 * xerox stares blankly
09:37:50 <shapr> @remember yow Butch Cassidey had my CHILDREN in MINNETONKA!
09:38:33 * shapr blanks staringly
09:42:24 <sieni> @yow
09:42:24 <lambdabot> One FISHWICH coming up!!
09:42:38 <SamB> @google "Last night I was at this dive bar listening to live music and there was this cute girl"
09:42:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
09:42:43 <SamB> oh, rats...
09:43:02 <SamB> @google site:tunes.org "Last night I was at this dive bar listening to live music and there was this cute girl"
09:43:04 <lambdabot> http://tunes.org/~nef/logs/haskell/06.08.24
09:43:35 <xerox> @seen JohnMeacham
09:43:35 <lambdabot> I haven't seen JohnMeacham.
09:43:43 * xerox hopes he's still alive
09:43:47 <SamB> arg
09:43:55 <SamB> that one is newer than the incident
09:44:08 <xerox> ?!
09:44:08 <lambdabot> Maybe you meant: . v
09:44:28 <SamB> xerox: I was looking for the original in the IRC logs...
09:44:47 <xerox> ...incident?
09:44:55 <SamB> whatever
09:44:57 <therp> hm the tex sources of haskell-98-tutorial are a bit ugly.
09:45:06 <SamB> incident isn't really the best word...
09:45:26 <therp> it's not really possible to get a decent looking tutorial on A4
09:46:25 <SamB> arg! google finds no original :-(
09:48:33 <xerox> SamB: wget and grep?
09:48:59 <int-e> maybe he didn't say it on #haskell?
09:50:10 <int-e> it was said on haskell-blah apparently
09:50:45 <int-e> (<JohnMeacham> heh. "what is said in haskell-blah, stays in haskell-blah")
09:51:01 <xerox> O_o
09:51:36 <SamB> oooh
09:51:44 <SamB> so I could break into lambdabot and steal it?
09:51:51 <xerox> Not *exactly*, lambdabot surveillance is becoming stricter and more comprehensive every day.
09:52:03 <sieni> argh, I get an error: setup: Error: Could not find module: Database.HDBC with any suffix: ["hi"]
09:52:10 <SamB> or, I could ask dons to retrieve it and fix the quotes file...
09:52:20 <sieni> while trying to install hdbc after building it
09:52:37 <sieni> I wonder what that's supposed to mean
09:52:55 <SamB> hmm.
09:53:04 <xerox> @ghc
09:53:04 <lambdabot>  Can't splice the polymorphic local variable
09:53:31 <sieni> The configure whines that pfesetup, c2hs and greencard are not found, but it doesn't complain that it would be an error
09:53:41 <SamB> sounds like some piece of software has an algorithm to find files related to modules, that it probably uses for source files and interface files, which failed trying to find the interface file for that module...
09:54:48 <SamB> sieni: did it build that module?
09:55:44 <sieni> It appears that it only built Database.HDBC.ColTypes, Database.HDBC.Types and Database.HDBC.DriverUtils
09:56:21 <sieni> so probably some dependency is missing and instead of giving on error at configure, it just happily goes forward until the install fails
09:56:25 <sieni> or something like that
09:59:40 <sieni> wtf are pfesetup and greencard anyway?
10:01:19 <sieni> ahh, greencard is some sort of haskell ffi preprocessor
10:05:15 <sieni> veeeeery useful error messages with port install c2hs
10:05:32 <glguy> macports?
10:05:41 <sieni> damn these (mac|darwin)ports are b0rked
10:05:42 <sieni> yes
10:05:59 <sieni> First I get: Error: Target com.apple.build returned: shell command "./Setup build -v" returned error 11
10:06:18 <sieni> then the build continues and I get Error: Status 1 encountered during processing.
10:06:25 <shapr> SamB: Do you want the history behind the JohnMeacham quote? I saved it after he said it on #haskell-blah
10:06:25 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
10:06:25 <sieni> thanks for the info!
10:06:37 <shapr> hiya ValarQ
10:06:54 <shapr> The @message command should also save the originating channel I think.
10:08:43 <vincenz> shapr: and pms then?
10:08:49 <vincenz> . /msg lambdabot @tell xxx
10:09:13 <sieni> Argh, I'll try to resolve the build problems tomorrow
10:09:16 <sieni> damn macs
10:09:23 <glguy> sjanssen: you there?
10:09:28 <sieni> with debian _everything_ would work just immediately
10:09:38 <sm> good morning all
10:09:46 <glguy> sieni: lol, you konw that's not true
10:10:10 <sieni> glguy: no I don't
10:10:21 <sm> I'm building hpodder, it looks like just what I need
10:10:23 <glguy> ok then, well now you do ;)
10:11:01 <sm> I'm using ghc, not hugs and have changed Setup.lhs accordingly. I get Setup.lhs configure gives *** Exception: Line 13: Parse of field 'extensions' failed, any ideas ?
10:12:08 <sm> also, where do I learn more about the Setup.lhs system ? is this cabal ?
10:12:25 <sieni> lots of packages on the packaging system, which until recently was called darwinports, seem to be broken
10:12:52 <sieni> fortunately at least ghc build without problems
10:14:56 <sieni> +s
10:19:50 <dylan> heh
10:19:59 <dylan> http://lambda-the-ultimate.org/node/1715
10:20:00 <lambdabot> Title: Rewriting Haskell Strings | Lambda the Ultimate
10:20:28 * sm removes the Extensions line from .cabal
10:22:16 <lisppaste2> monochrom pasted "maximum segment sum and its segment" at http://paste.lisp.org/display/25714
10:22:30 <monochrom> That's mainly for Limbic_Region
10:25:17 <shapr> @users
10:25:19 <lambdabot> Maximum users seen in #haskell: 242, currently: 234 (96.7%), active: 38 (16.2%)
10:25:24 <shapr> 242!
10:25:36 <shapr> That's seven over our previous high water mark.
10:25:43 <monochrom> Why oh why did lisppaste start from 1 rather than 0
10:25:45 <xerox> > product . enumFromTo 1 $ 242 -- = 242!
10:25:46 <lambdabot>  2372472101786237237034263348929581250598543735380608448130803076287704800855...
10:26:54 <xerox> monochrom: maybe if you convince chandler he will give you the 0th paste, or sell it to you.
10:27:01 <monochrom> haha
10:27:32 <shapr> @seen SyntaxNinja
10:27:32 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 19h 31m 18s ago, and .
10:29:09 * sm tries to build a sufficiently new version of MissingH, fails, upgrades to edgy
10:33:36 <chessguy> does haskell have the notion of substrings, or sub-lists?
10:34:30 <xerox> > take 3 . drop 6 $ "Hmm.. yes?"
10:34:31 <lambdabot>  "yes"
10:36:04 <chessguy> mmm, was that supposed to be an anwer to my question?
10:36:14 <Lemmih> What's a sublist?
10:36:54 <chessguy> so for the list [a,b,c], one sublist is [a,b]
10:38:24 <Lemmih> I'd say no, then. Although with the right abstraction everything is possible (as seen with, say, FPS).
10:38:39 <chessguy> FPS?
10:38:39 <dylan> > take 3 . drop 6 $ [1,2,3,4,5,6,7,8,9,10]
10:38:40 <lambdabot>  [7,8,9]
10:38:59 <chessguy> aha
10:39:03 <xerox> dylan: do you know there exist the short-hand [1..10] ?
10:39:13 <dylan> xerox: I was trying to make it obvious
10:39:22 <dylan> I am aware of [1..] as well
10:39:27 <xerox> dylan: sure!
10:39:32 <tibbe> > let subList a b = take (b - a) . drop a in subList 1 2 [1,2,3,4,5,6]
10:39:33 <lambdabot>  [2]
10:39:37 <int-e> > concatMap tails $ inits [1,2]
10:39:38 <lambdabot>  [[],[1],[],[1,2],[2],[]]
10:40:05 <chessguy> hmm, so if i wanted to get all the the sublists of length 5, how might i do that?
10:40:33 <chessguy> in this case, [1..5],[2..6],...,[6..10]
10:40:44 <int-e> > map take 5 $ tails [1..6] -- plus a bit of cleanup
10:40:44 <lambdabot>    Expecting a function type, but found `[b]'
10:40:44 <lambdabot>    Expected type: a -> b
10:40:44 <lambdabot>  ...
10:40:52 <int-e> > map (take 5) $ tails [1..6] -- plus a bit of cleanup
10:40:53 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6],[4,5,6],[5,6],[6],[]]
10:40:55 <xerox> > filter ((5==) . length) . (>>= tails) . inits $ [1..10]
10:40:56 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
10:41:46 <chessguy> hmm. can you explain that code to me?
10:42:00 <chessguy> i'm a n00b
10:42:04 <tibbe> xerox: he wants you to make it shorter with @pl ;)
10:42:04 <xerox> I just added filter (\xs -> length xs == 5) to int-e's code.
10:42:23 <int-e> (>>= x) is concatMap x
10:42:25 <gour> xerox: do you run goa (& lambdabot) ? here it does not build with ghc-6.5_20060907
10:42:25 <tibbe> xerox: I know it's already on pf form :)
10:42:26 <xerox> tibbe: I don't use @pl! :D
10:42:45 <int-e> in this context.
10:43:11 <xerox> gour: I don't know, I didn't try out GOA's embedding in lambdabot yet.
10:43:17 <chessguy> i'm confused, sorry.
10:43:35 <chessguy> i'm quite a n00b
10:43:45 <tibbe> perhaps holding off monads one second would help
10:43:53 <gour> xerox: but to build goa you need lambdabot built, true?
10:44:11 <clanehin> I'm unclear about how best to perform generic numerical type conversions, the best I see is fromRational . toRational
10:44:28 <xerox> > let sublists = (>>= tails) . inits in filter (\xs -> length xs == 5) (sublists [1..10]) -- chessguy, this is my code in pointy-form, with names.
10:44:29 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
10:44:40 <xerox> gour: I am not sure, it might be the case.
10:44:56 <xerox> @localtime dons
10:44:58 <lambdabot> Local time for dons is Sun Sep 10 03:44:35 2006
10:45:06 <shapr> @localtime shapr
10:45:06 <lambdabot> Local time for shapr is Sat Sep  9 12:44:47 2006
10:45:23 <shapr> @localtime xerox
10:45:24 <lambdabot> Local time for xerox is 2006-09-09 19:45:13 +0200
10:45:33 <tibbe> ?type inits
10:45:35 <lambdabot> forall a. [a] -> [[a]]
10:45:45 <tibbe> > inits [1..10]
10:45:46 <int-e> @type realToFrac
10:45:46 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
10:45:47 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
10:46:22 <int-e> note that inits is O(n^2). if you can write something in terms of tails as well, you should do that.
10:46:25 <chessguy> xerox: ok, i'll play with it
10:46:49 <chessguy> oh, hugs doesn't know what inits is
10:46:59 <int-e> it's in Data.List (or List)
10:47:10 <xerox> @docs Data.List
10:47:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:47:13 <chessguy> how do i tell Hugs that?
10:47:21 <xerox> :also Data.List
10:47:29 <tibbe> > (>>= tails) . inits [1..10]
10:47:30 <lambdabot>    Expecting a function type, but found `[[a]]'
10:47:30 <lambdabot>    Expected type: a1 -> ...
10:47:37 <xerox> '$'
10:47:38 <tibbe> > (>>= tails) . inits $ [1..10]
10:47:39 <lambdabot>  [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[],...
10:47:42 <chessguy> aha
10:47:54 <int-e> :load Data.List seems to do the trick.
10:48:13 <AStorm> Why not import Data.List?
10:48:15 <chessguy> so the >>= is what exactly?
10:48:23 <int-e> AStorm: on the hugs command line?
10:48:24 <xerox> It is called bind.  Monadic bind.
10:48:33 <AStorm> int-e: ah, hugs :P
10:48:36 <xerox> For the list monad, it is (flip) concatMap.
10:48:49 <chessguy> uh-huh
10:49:19 <xerox> instance Monad [] where return x = [x]; xs >>= f = concat (map f xs)
10:49:53 <tibbe> haskell is so beautiful
10:50:03 <xerox> G'day lennart.
10:51:03 <chessguy> so what does (>>= tails) do?
10:51:12 <xerox> It is concatMap tails.
10:51:37 <tibbe> tails [1..5]
10:51:44 <tibbe> > tails [1..5]
10:51:45 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
10:52:00 <tibbe> > (>>= tails) [1..5]
10:52:00 <lambdabot>  add an instance declaration for (Num [a])
10:52:00 <lambdabot>   In an arithmetic sequence: [1...
10:52:11 <tibbe> > (>>= tails) [[1..5]]
10:52:12 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
10:52:24 <tibbe> > (>>= tails) (inits [1..5])
10:52:25 <lambdabot>  [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[],...
10:52:30 <lennart> howdy
10:52:33 <monochrom> If you call inits and subsequently just ask for the mth list in it, the time cost should be just O(m).
10:52:41 <tibbe> you get all sub lists with some duplicates I think
10:53:18 <Limbic_Region> chessguy - you back at it again?
10:53:24 <Limbic_Region> how far have you gotten in YAHT now?
10:53:35 <chessguy> i'm mostly using it for a refference now
10:53:37 <chessguy> reference
10:53:50 <Limbic_Region> oooh
10:54:04 * Limbic_Region is forcing himself to go through it page by page
10:54:21 <monochrom> Limbic_Region: have you noticed my new mss solution?
10:54:33 <Limbic_Region> no?
10:54:37 <Limbic_Region> link?
10:54:45 <monochrom> <lisppaste2> monochrom pasted "maximum segment sum and its segment" at http://paste.lisp.org/display/25714
10:55:06 <SamB> hmm...
10:55:17 <Limbic_Region> did you see mauke's solution?
10:55:21 <monochrom> No.
10:55:37 <monochrom> I think mauke's was imperative?
10:55:40 <Limbic_Region> let me paste that as I only have local copy
10:55:52 * SamB wonders why 'xlsfonts -fn "-*-courier-medium-r-*-*-*-160-*-*-*-*-iso8859-1"' lists four fonts but with -o as well it can't find any
10:55:56 <Limbic_Region> pretty much - translated my perl into haskell
10:56:23 <monochrom> OK, I know the imperative solution in pseudocode (and therefore in all imperative languages).
10:56:40 <xerox> monochrom: even brainfuck?
10:57:02 <tibbe> monochrom: whitespace?
10:57:02 <Limbic_Region> @paste
10:57:03 <lambdabot> http://paste.lisp.org/new/haskell
10:57:04 <monochrom> To be fair, the functional solution is not any different.
10:57:44 <monochrom> OK, brainfuck and whitespace are machine code. :)
10:57:49 <lisppaste2> Limbic_Region pasted "mauke's solution" at http://paste.lisp.org/display/25716
10:57:52 <xerox> Pfft :)
10:58:35 <Limbic_Region> monochrom thanks so much - will study later
10:58:49 <monochrom> I think it makes sense to hypothetically imagine there is virtual hardware for brainfuck or whitespace, and you write in Haskell and compile to brainfuck or whitespace.
10:59:32 <monochrom> mauke's is isomorphic to mine :)
10:59:32 <xerox> Now, that sounds like a project.
10:59:39 <monochrom> Great minds think alike.
11:01:04 <Limbic_Region> well - AFAIK, mauke just did a direct translation of someone else's Perl
11:01:12 <Limbic_Region> not that I am trying to take anything away from mauke
11:03:40 <monochrom> "maxes" corresponds to "step".  only difference is "step" throws away the history of intermediate states, while "maxes" produces that history.
11:05:20 <monochrom> Then I use foldl1 to collapse that history and pick out the winner.
11:06:16 <monochrom> I rely on futuristic optimizing compilers to recognize this produce-consume composition and optimize away the history. :)
11:06:20 <chessguy> by the way, has anything loke genetic algorithms or genetic programming been done in haskell?
11:06:46 <xerox> monochrom: well, not *so* futuristic, did you see the recent dons&dcoutts paper?
11:06:55 <xerox> s/so/too/ maybe :)
11:07:11 <chessguy> s/loke/like/
11:07:44 <monochrom> I live in the future.
11:09:55 <chessguy> monochrom, cooll. what's it like?
11:10:05 <chessguy> less spelling mistakes, i hope
11:10:10 <xerox> Imagine your clock showing a different time...
11:10:37 <monochrom> It is like you write down a specification and the computer generates code.
11:11:43 <Oejet> monochrom: That sounds a bit like...today. ;-)
11:12:37 <monochrom> Windows no longer crashes or possesses security holes.  Linux too.
11:13:27 <chessguy> what, microsoft hasn't gone out of business yet?
11:13:36 <chessguy> you must not be very far in the future
11:13:50 <xerox> Anachronistic!
11:14:04 <int-e> who bought microsoft and made them good?
11:14:05 <int-e> :)
11:14:11 <monochrom> SPJ is the CEO and CTO of Microsoft now.  Windows is written in Haskell'''''.  That's why.
11:14:18 * xerox laughs
11:14:18 <Oejet> chessguy: Do you know any behemoth of a company, which went out of business?
11:15:16 <monochrom> Linux is written in SML4000.
11:15:56 <Oejet> Researchers also found out that Simons brain is not biologically
11:16:19 <monochrom> Yeah, we like kind of like that.
11:16:22 <Oejet> degradable, and is switched between human hosts.
11:16:22 <int-e> Oejet: how about this: http://lkml.org/lkml/2003/6/21/49
11:16:24 <lambdabot> Title: LKML: Stephan von Krawczynski: Re: [OT] Re: Troll Tech [was Re: Sco vs. IBM]
11:18:27 <Oejet> int-e: Ah, good one.
11:18:30 <Adamant> Oejet, Montgomery Ward used to be one of the biggest retailers in the U.S. Now it doesn't exist anymore.
11:19:12 <Adamant> companies die, big companies just take longer to do so.
11:32:04 <tibbe> what is the reason flip concatMap is bind for the list monad?
11:32:38 <newsham> > [1,2,3,4] >>= (+ 5)
11:32:39 <lambdabot>  add an instance declaration for (Num [b])
11:32:57 <newsham> > [1,2,3,4] >>= liftM (+ 5)
11:32:57 <lambdabot>  add an instance declaration for (Num [a1])
11:32:57 <lambdabot>   In the list element: 4
11:33:42 <ihope_> > '\33'
11:33:43 <lambdabot>  '!'
11:34:02 <ihope_> @type concatMap
11:34:03 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
11:34:33 <ihope_> tibbe: it has the right type. Can you think of a better (>>=)?
11:38:03 <newsham> > [1,2,3,4] >>= (\x -> [x+5, x+6])
11:38:04 <lambdabot>  [6,7,7,8,8,9,9,10]
11:38:20 <newsham> > map (\x -> [x+5, x+6]) [1,2,3,4]
11:38:21 <lambdabot>  [[6,7],[7,8],[8,9],[9,10]]
11:38:33 <newsham> > concat map (\x -> [x+5, x+6]) [1,2,3,4]
11:38:34 <lambdabot>    The function `concat' is applied to three arguments,
11:38:34 <lambdabot>   but its type `[...
11:38:52 <newsham> > concatMap (\x -> [x+5, x+6]) [1,2,3,4]
11:38:53 <lambdabot>  [6,7,7,8,8,9,9,10]
11:39:15 <newsham> > (flip concatMap) [1,2,3,4] (\x -> [x+5, x+6])
11:39:16 <lambdabot>  [6,7,7,8,8,9,9,10]
11:40:24 <monochrom> tibbe: One way is to pretend that the list monad is a monad for nondeterministic results.
11:40:58 <newsham> imagine a function that returns multiple values, like the quadratic equation solution
11:41:56 <newsham> in a chain, you'd get lists of values that need to each be used in turn in the next equation, their results concatenated together into a single list
11:42:32 <newsham> another example is a NFA state transition function, for any state you can go several ways on the same input.
11:43:44 <tibbe> monochrom: I was wonderings if there was some theory behind it or if it was just useful
11:44:11 <newsham> tibbe: it also matches well with what happens inside a list comprehension.
11:44:25 <monochrom> I try not to distinguish "theory" and "useful".
11:44:40 <newsham> > do { x <- [1,2,3]; y <- [4,6,8]; return (x + y) }
11:44:41 <lambdabot>  [5,7,9,6,8,10,7,9,11]
11:44:42 <Korollary> But you are special.
11:44:48 <dolio> ?type join
11:44:49 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:44:53 <dolio> ?type fmap
11:44:54 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
11:45:00 <monochrom> At least, if it's useful then there is a theory to go with it.
11:45:06 <newsham> > [x + y | x <- [1,2,3], y <- [4,6,8]]
11:45:07 <lambdabot>  [5,7,9,6,8,10,7,9,11]
11:45:33 <newsham> tibbe: the do {} is just short hand for using the list monad, as you probably know
11:45:55 <glguy> ?
11:46:07 <SamB> languages where "useful" things don't have theories behind them ... well, I guess they just suck.
11:46:39 <monochrom> There is always a theory.  The question is whether someone bothers to flesh it out.
11:46:51 <glguy> is that your theory?
11:47:07 <newsham> > [1,2,3] >>= (\x -> [4,6,8] >>= (\y -> [x+y]))
11:47:08 <lambdabot>  [5,7,9,6,8,10,7,9,11]
11:47:13 <SamB> well... sometimes the theory is so icky that it is better not to think of it as such...
11:47:16 <glguy> [1,2,3] >> [4,5,6]
11:47:17 <SamB> if that even qualifies...
11:47:20 <glguy> > [1,2,3] >> [4,5,6]
11:47:21 <lambdabot>  [4,5,6,4,5,6,4,5,6]
11:47:36 <monochrom> So-called "experience" is just a theory whose owner does not bother to write down and scrutinize.
11:47:54 <dolio> ?type join . fmap
11:47:54 <newsham> glguy: for x in [1,2,3] : append [4,5,6]   (not using x at all)
11:47:55 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (f a)
11:47:55 <lambdabot>    Expected type: (a -> b) -> f a -> f a -> a1
11:48:00 <SamB> I don't think experience is much of a theory
11:48:15 <glguy> newsham: I know what it's doing :-p
11:48:16 <monochrom> Example.  "From my experience, the sun will set later today and rise again tomorrow."  Sounds like a theory to me.
11:48:19 <SamB> it is something that you can use to form theories...
11:48:21 <newsham> glguy: ahh, sorry then.
11:49:01 <chessguy> hey glguy, i've been solving some of the mathschallenges problems with haskell
11:49:05 <chessguy> it's good practice
11:49:14 <newsham> mono: because of the angular momentum of the earth, the sun will be at the horizon again tomorow
11:49:31 <SamB> what if the earth blows up today?
11:49:32 <glguy> I see you've knocked out 5 already
11:49:49 <newsham> samb: my model hadn't accounted for that
11:49:52 <tibbe> monochrom: I didn't mean it like that. :) More like, was there several options and this was the best one or does the structure of the monad (ie list) imply one particular bind
11:49:58 <dolio> glguy inspired me to play around with mathschallenge, as well.
11:50:08 <glguy> Actually, the sun comes up because I wait for it to, and ti goes down for the same reason. When I stop waiting for the sun to rise and fall... it will cease to
11:50:20 <glguy> That's my theory
11:50:27 <SamB> glguy: you obviously don't have ADD, if you really think so
11:50:37 <SamB> ADD people know that the *opposite* is true
11:50:48 <newsham> tibbe: I think its a natural extension of the Maybe monad (or perhaps the other way around, the maybe monad is a subste of the list monad) and because its what is happening in list comprehensions
11:50:51 <SamB> the sun only rises and falls when you are *not* waiting for it
11:51:14 <newsham> (maybe monad is like list monad if you only use   [] and [a] )
11:51:34 <glguy> (the little boy in Infinite Dungeons, a Neverwinter Nights expansion, makes that statement about the sun)
11:51:42 <monochrom> tibbe: I like that question.  I have not verified, but my hunch is >>= can be derived for cons-list, i.e., unique.
11:51:42 <SamB> newsham: and don't use MonadPlus
11:52:16 <glguy> > msum [Just 1, Just 2, Nothing, Just 3]
11:52:16 <lambdabot>  Just 1
11:52:37 <monochrom> May be much easier to derive "join, return".  ("fmap" is already a done deal.)  Then >>= follows.
11:52:38 <glguy> > msum [[1],[2],[],[3]]
11:52:39 <lambdabot>  [1,2,3]
11:52:39 <newsham> what's monadplus do for lists?  I dont know that one
11:52:41 <SamB> > msum [[], [2]]
11:52:42 <lambdabot>  [2]
11:52:45 <newsham> ahh
11:53:00 <SamB> wait...
11:53:08 <SamB> > msum [[], [2], [3]]
11:53:09 <lambdabot>  [2,3]
11:53:12 <dolio> From what I gather, bind isn't taken as primitive in category theory. Instead join :: m (m a) -> m a is primitive.
11:53:21 <SamB> > msum [Nothing, Just 2, Just 3]
11:53:21 <newsham> > msum [[1], [], [2,3]]
11:53:22 <lambdabot>  Just 2
11:53:22 <lambdabot>  [1,2,3]
11:53:28 <monochrom> Yeah, join is easier to work with in the theory.
11:53:31 <tibbe> I see
11:53:33 <glguy> SamB: what's wrong?
11:53:38 <dolio> Then you define extend as:  extend f m = join (fmap f m)
11:53:45 <dolio> And bind = flip extend.
11:53:58 <dolio> In the list monad, join == concat, and map == fmap.
11:54:02 <glguy> > sequence [Just 1, Just 2, Just 3]
11:54:03 <glguy> > sequence [Just 1, Just 2, Just 3, Nothing]
11:54:03 <lambdabot>  Just [1,2,3]
11:54:04 <lambdabot>  Nothing
11:54:05 <dolio> So bind = flip (concat . map)
11:54:09 <SamB> glguy: oh, I failed to demonstrate a difference between the MonadPlus instances, the first time...
11:54:12 <SamB> thats all
11:54:28 <monochrom> From my experience (!), join is easier to work with in theoretical derivations. :)
11:54:49 <SamB> @type join
11:54:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:55:07 <SamB> @type (!)
11:55:08 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
11:55:16 * SamB fails to see how (!) is relevant
11:55:21 <glguy> map join [Just (Just 1), Nothing, Just Nothing]
11:55:25 <glguy> > map join [Just (Just 1), Nothing, Just Nothing]
11:55:25 <lambdabot>  [Just 1,Nothing,Nothing]
11:55:35 <newsham> > do { x <- 25; sqr <- [x, -x]; [-3 + sqr, 3+sqr] }
11:55:35 <lambdabot>  add an instance declaration for (Num [a])
11:55:35 <lambdabot>   In a 'do' expression: x <- 25...
11:55:50 <newsham> > do { x <- [25]; sqr <- [x, -x]; [-3 + sqr, 3+sqr] }
11:55:51 <lambdabot>  [22,28,-28,-22]
11:56:04 <monochrom> I fail to see why you would think I meant (!) to be a Haskell operator.
11:56:23 <glguy> because it is one, and you sequenced it together with a comma into "join"
11:56:23 <glguy> ;)
11:56:34 <monochrom> Do you also go "@type ." because I have a . at the end of my sentences?
11:56:38 <SamB> monochrom: I am trying to provoke you into telling me what it really is
11:56:39 <newsham> blah stupid example
11:57:01 <Cale> join is often easier to define than bind
11:57:04 <SamB> I know what the periods at the end of sentences are...
11:57:40 <glguy> What if I end my sentence like this? Seems silly(.)
11:57:58 <monochrom> Have you not seen people writing in plain English to include "(!)" to express exclamation?  OK, now you have.
11:58:19 <SamB> in the middle of a sentence?
11:58:20 <glguy> I've seen cartoon characters do that...
11:58:23 <newsham> if its really suprising(!) people sometimes denote that with an exlamation mark.
11:58:27 <glguy> but it's usually over their head
11:58:54 <newsham> KP2 x Q (!)
11:59:22 <monochrom> Yes.  At the end of a sentence, you just go "!".  But if you want to do it in the middle, first you insert parentheses like you would for anything in the middle, then you put "!" inside the parentheses.
11:59:22 <glguy> Man... someone really sidetracked the List as a Monad discussion
11:59:30 <SamB> well, if you said something and stuck (.) in the middle of a setence, I probably *would* think you were talking about the composition operator
12:00:25 <newsham> amusign about (< 5) and ((<) 5) on the list
12:00:55 <glguy> link?
12:01:12 <newsham> google haskell-cafe
12:01:20 <glguy> @google haskell-cafe
12:01:22 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
12:01:22 <lambdabot> Title: Haskell-Cafe Info Page
12:01:26 <monochrom> They must be really bored if they talk about (< 5) and ((<) 5).
12:01:42 <monochrom> Will they next talk about (!) and (.)? :)
12:02:21 <glguy> monochrom: were you really excited about the word "about" ?
12:02:44 <monochrom> No.  Do I look like I'm?
12:02:54 <glguy> Like you are what?
12:02:55 <newsham> someone wrote (< 5) when they meant ((<) 5) and wanted to warn about it
12:03:20 <SamB> hmm, IIRC you use join and fmap? I suppose the only reasons not to do have those for primitives are: that it could be really inefficient in GHC because GHC doesn't do specialization, and that fmap is in a different typeclass...
12:03:21 <tibbe> newsham: wasn't it the other way around?
12:04:14 <dolio> Yeah, well, if you'll recall, one of the lists recently had a huge discussion about whether Functor should be required for all Monads.
12:04:40 <dolio> Since all Monads are Functors, but it's currently not required, so there are cases where the Functor instance isn't declared.
12:04:57 <monochrom> >>= is much more popular than join in usage.
12:05:50 <monochrom> liftM is fmap anyway :)
12:06:12 <dolio> You could set it up to declare either, couldn't you?
12:06:21 <dolio> Have defaults for both join and bind in terms of one another?
12:06:34 <dolio> And then choose which you want to implement?
12:06:48 <monochrom> Unfortunately not.  You must provide >>= in your Monad instance.  You cannot provide join.
12:07:06 <dolio> Assuming you required Functor instances for all Monads.
12:07:21 <dolio> Well, right, I know you can't do it currently, but could you set it up that way?
12:07:23 <glguy> You could write join, and then provide >>= in terms of the join you wrote
12:07:34 <glguy> (along with fmap)
12:07:36 <monochrom> I would agree to set it up that way.
12:07:46 <SamB> it would be cool if Monad could define a default implementation of fmap... and if Monad instances could define fmap...
12:08:08 <SamB> and if you could define fmap and join instead of >>= and return, if you wanted...
12:08:47 <SamB> hmm
12:08:55 <SamB> @type join
12:08:56 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:08:59 <SamB> @type fmap
12:09:00 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:09:03 <SamB> @type return
12:09:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
12:09:26 <dolio> You need return either way, don't you?
12:09:31 <monochrom> Yes.
12:09:39 <SamB> oh.
12:10:02 <SamB> I was just about to ask djinn to write me a function that took join and fmap and gave me return ;-)
12:10:08 <dolio> It's either return + join (+ fmap) or return + bind.
12:10:29 <SamB> so... is fmap optional?
12:10:49 <dolio> Well, fmap has to do with functors.
12:10:50 <jonick> Tried this one: allAlteration :: Iff (forall a b. c a b) (forall b a. c a b)
12:11:02 <jonick> Got: Illegal polymorphic or qualified type: forall b a. (forall a b. c a b) -> c a b
12:11:04 <dolio> All monads are functors, but not all functors are monads.
12:11:08 <SamB> oh, so it might be taken for granted...
12:11:11 <jonick> Any way to get this working?
12:11:32 <monochrom> "instance Functor where fmap = ..." is optional in Haskell98.  If your monad satisfies all the monad laws, then fmap has to be equivalent to liftM, though you can write different code.
12:11:54 <tibbe> @seen nibro
12:11:55 <lambdabot> I haven't seen nibro.
12:12:18 <tibbe> Nicklas Broberg, are you here?
12:12:44 <glguy> What would be an example of a Functor that was not a Monad?
12:12:58 <glguy> wait, nvm
12:13:01 <dolio> Hmm...
12:13:03 <glguy> join isn't part of Functor
12:13:16 <glguy> just fmap, right?
12:13:21 <dolio> Right.
12:13:28 <glguy> OK, then I don't need examples :)
12:14:05 <monochrom> Good.  It's hard to give an example and justify that it is an example.
12:14:26 <ihope_> @type \x -> fix (x >>)
12:14:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
12:14:33 <ihope_> Whee.
12:16:50 <dolio> The "Applicative programming with effects" has an example of an applicative functor that isn't a monad.
12:16:59 <dolio> The "..." paper, that is.
12:17:13 <SamB> ihope_: ooooh
12:17:30 <SamB> you have come up with an interesting implementation of forever...
12:17:41 <ihope_> @hoogle forever
12:17:42 <lambdabot> No matches found
12:17:48 <SamB> @pl forever p = let x = p >> x in x
12:17:49 <lambdabot> forever = fix . (>>)
12:18:14 <SamB> forever is just the name we call this function by, it is not in a library or anything
12:23:04 <monochrom> @hoogle repeatM
12:23:04 <lambdabot> No matches found
12:23:41 <monochrom> http://www.haskell.org/pipermail/libraries/2002-August/000649.html
12:23:43 <lambdabot> Title: Adding repeatM / repeatM_ to Control.Monad, http://tinyurl.com/j8zth
12:23:50 <monochrom> repeatM == forever :)
12:24:03 <monochrom> I mean repeatM_
12:25:35 <Templar> anyone who knows whats wrong in the third colomn here: http://83.227.193.230/hs/four.png ?
12:26:09 <dmhouse> Templar: you're not applying three to any arguments
12:26:09 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
12:26:26 <Templar> hmm
12:27:02 <dmhouse> Templar: if you want the functions to share the scope, make them part of the same function using where/let clauses.
12:27:03 <Templar> have to make "three" to a funktion with a line then?
12:28:37 <Templar> "where/let clauses", havent come to that yet I think =/
12:29:28 <dmhouse> Templar: then apply three to some arguments
12:30:07 <dmhouse> Templar: try replacing 'three' with 'three a b c' in the definition of four.
12:33:32 <Templar> yea, then I can load the .hs but it becomes "true" with only 1 number changed
12:34:00 <dmhouse> Then there's a problem with your logic.
12:34:18 <Templar> jepp
12:34:29 <lisppaste2> jonick pasted "Is it possible to workaround this problem?" at http://paste.lisp.org/display/25720
12:36:22 <dmhouse> jonick: what problem?
12:36:45 <jonick> Getting Illegal polymorphic or qualified type: forall b a. (forall a b. c a b) -> c a b
12:37:16 <Pupeno> @seen shapr
12:37:17 <lambdabot> I saw shapr leaving #ScannedInAvian and #haskell 1h 37m 55s ago, and .
12:37:33 <dmhouse> jonick: use different letters? Might be a scope thing.
12:37:36 <Pupeno> "and ." ? something's missing there.
12:37:43 <Cale> jonick: should those b's be the same thing, since they're not
12:37:58 <Templar> "illegal"? error or false? ^^
12:38:49 <jonick> dmhouse: Impl (forall a. forall b. (c a b)) (forall b. forall a. (c a b)) works fine
12:39:37 <jonick> Cale: don't think they need to.
12:40:10 <Cale> forall b a. (forall u v. c u v) -> c a b
12:40:15 <Cale> that's the same
12:40:43 <Templar> but if I have a function, should it not be easy to just define it with any command so I can put it somewhere else?
12:41:02 <jonick> Cale: thanks, so I need to transform manually?
12:42:03 <Cale> jonick: Well, I have no idea what you're doing :)
12:43:42 <jonick> Cale: trying to map simple predicate formula to haskell.
12:46:38 <weitzman> @type (const .)
12:46:39 <lambdabot> forall b b1 a. (a -> b) -> a -> b1 -> b
12:46:44 <weitzman> @type ((const .) .)
12:46:45 <lambdabot> forall b b1 a a1. (a1 -> a -> b) -> a1 -> a -> b1 -> b
12:46:46 <jonick> Cale: and letting the type checker do the work ;-)
12:47:36 <weitzman> @type .
12:47:37 <lambdabot> parse error on input `.'
12:47:44 <weitzman> Eek!
12:48:08 <tibbe> is it possible to have cabal hide a certain package, I'm having troubles with fps as it's included in both fps and in bse in ghc 6.6
12:48:11 <tibbe> base*
12:48:40 <weitzman> I suppose . has type  (a -> b) -> (b -> c) -> (a -> c)
12:48:43 <weitzman> Is that the right order?
12:49:03 <Cale> @type (.)
12:49:05 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
12:49:07 <weitzman> Aha
12:49:09 <weitzman> Clever
12:49:45 <Cale> You have to do that with all infix operators to refer to them on their own.
12:50:42 <weitzman> But in the expressions (const .)
12:50:47 <weitzman> I assume it works out?
12:50:52 <weitzman> As in, (const (.))
12:52:05 <mauke> (const .) == ((.) const)
12:52:09 <weitzman> Oh
12:52:15 <weitzman> Well
12:52:25 <weitzman> Now that would make things more clear
12:52:45 <weitzman> Does it work that way with all infix operators?
12:52:54 <weitzman> > (1 +) 3
12:52:55 <lambdabot>  4
12:52:57 <weitzman> Aha
12:53:05 <weitzman> Neat
12:53:12 <weitzman> Except it's not clear to me that it should
12:53:31 <weitzman> But I guess that's why they call them design decisions
12:53:56 <mauke> (x `f`) == f x;  (`f` x) == flip f x == \y -> f y x
12:54:11 <araujo> @type (1 +)
12:54:12 <lambdabot> forall a. (Num a) => a -> a
12:55:09 <weitzman> @type flip
12:55:10 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
12:55:29 <clanehin> #type (const (.))
12:55:34 <clanehin> @type (const .)
12:55:35 <lambdabot> forall b b1 a. (a -> b) -> a -> b1 -> b
12:55:52 <weitzman> @type (const (.))
12:55:53 <lambdabot> forall b c a b1. b1 -> (b -> c) -> (a -> b) -> a -> c
12:55:56 <araujo> it's a way of writing infix operators. (sections)
12:56:05 <clanehin> yeah they have different types, one passes the function to const
12:56:16 <clanehin> the other composes with const
12:56:26 <weitzman> Indeed
12:56:28 <tibbe> ?type const
12:56:29 <lambdabot> forall a b. a -> b -> a
12:59:03 <weitzman> >(`-` 1) 5
12:59:38 <tibbe> have anyone succeeded in building lambdabot with ghc 6.6?
12:59:56 <araujo> > ((-) 6) 8
12:59:57 <lambdabot>  -2
12:59:57 <Igloo> Does anyone know about Windows __imp_ symbols?
13:00:12 <araujo> weitzman, no need `
13:00:26 <weitzman> That's not the result I was looking for, actually
13:00:35 <weitzman> Since (`f` x) is apparently flip f x
13:00:36 <newsham> do most people use parsec when writing parsers in haskell?
13:00:39 <araujo> and what were you looking for?
13:00:43 <weitzman> I was trying to do a flip (-) 1
13:00:47 <araujo> newsham, probably ....
13:01:16 <newsham> are there any GLR parser generators?
13:02:06 <araujo> > ((-) 6) 8 == (6 - 8)
13:02:07 <lambdabot>  True
13:02:07 <mauke> weitzman: - is special ("broken") because it's also a unary operator
13:02:12 <newsham> any reason why parsec is preferred over a parser that doesnt require left factoring or other massaging of the grammar?
13:02:32 <weitzman> Ah
13:02:33 <araujo> therefore ...
13:02:39 <weitzman> In SML they distinguish ~ from -
13:02:43 <araujo> > ((-) 6) 8 == flip (-) 8 6
13:02:44 <lambdabot>  True
13:03:20 <newsham> (I want to write a parser and I'm trying to figure out what my options are and the pros/cons..  i havent yet used parsec)
13:04:56 <mauke> recursive descent makes sense
13:05:15 <lennart_> newsham: it's nice to write a parser in a language where you have the full power of a programming language on the grammar level
13:05:25 <newsham> sometimes.. sometimes recursive descent means lots of backtracking or grammar massaging
13:05:25 <lennart_> so I prefer parsing combinators
13:05:41 <newsham> lenn: makes sense.
13:07:15 <lennart_> e.g., if you notice that you parse comma-separated things (but different things) in several places, you can make a function that takes a parser of x and returns a parser for comma-separated x
13:07:37 <newsham> right, but thats also fairly easy to tackle in ebnf
13:07:50 <newsham> x -> el (',' el)*
13:08:37 <newsham> i'm sure you can come up with a more complicated example that would be tedious in ebnf that could be done once in haskell and reused
13:08:44 <mauke> ok, now a sequence of between 2 and 16 hex digits
13:08:53 <newsham> *nod*
13:09:13 <glguy> What's the Parsec function for that? (I've not done much at all with Parsec)
13:09:23 <newsham> (thats also not hard if you have a scannerless parser and repetition operators)
13:09:33 <newsham> [0-9a-fA-F]{2,16}
13:09:45 <newsham> but i undersatnd your point
13:10:48 <mauke> glguy: no idea, maybe it doesn't have one
13:11:04 <mauke> in my lib it's manyNtoMS 2 16 hexDigit
13:11:24 <glguy> that's what I meant, what does that function look like
13:11:47 <glguy> manyNtoMs
13:12:28 <mauke> manyNtoMS = manyNtoM (<||>)
13:12:38 <mauke> manyNtoM c m n p = liftM2 (++) (manyN m p) (manyToN c n p)
13:13:00 <mauke> manyN n p = sequence (replicate n p)
13:13:22 <mauke> manyToN c n p  | n <= 0 = return []  | otherwise = prepend p (manyToN c (n - 1) p) `c` return []
13:13:27 <glguy> sequence (replicate n p)... is that replicateM n p ?
13:13:34 <mauke> ?type replicateM
13:13:35 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
13:13:42 <mauke> yes
13:13:47 <mauke> thanks :-)
13:18:04 <newsham> cracki: oh?  url?
13:18:25 <glguy> > replicateM 2 [1,2,3]
13:18:26 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
13:18:47 <xerox> (!)
13:20:26 <Cale> > [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
13:20:27 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
13:20:40 <Cale> > drop 20 $ [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
13:20:41 <lambdabot>  ["u","v","w","x","y","z","aa","ab","ac","ad","ae","af","ag","ah","ai","aj","...
13:20:48 <xerox> Nice!
13:22:41 <emu> > replicate 1 [0..9]
13:22:42 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9]]
13:23:11 <Cale> > replicate 2 [0..9]
13:23:12 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,8,9]]
13:23:25 <emu> > [replicate k [0..9] | k <- [1..]]
13:23:26 <lambdabot>  [[[0,1,2,3,4,5,6,7,8,9]],[[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,8,9]],[[0,1...
13:23:31 <Cale> > sequence (replicate 2 [0..9])
13:23:32 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[1,0],[1,1],[1,...
13:23:32 <emu> yikes
13:23:48 <Cale> > sequence (replicate 2 [0..3])
13:23:49 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3],[3,...
13:24:09 <emu> > (replicate 2 [0..3]) >>= sequence
13:24:10 <lambdabot>  add an instance declaration for (Num [a])
13:24:10 <lambdabot>   In an arithmetic sequence: [0...
13:24:26 <emu> > [(replicate k [0..3]) | k <- [1..]] >>= sequence
13:24:27 <lambdabot>  [[0],[1],[2],[3],[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1]...
13:25:46 <emu> > map sequence (replicate 2 [0..3])
13:25:47 <lambdabot>  add an instance declaration for (Show (m [a]))
13:26:15 <Cale> > map sequence [(replicate k [0..3]) | k <- [1..]]
13:26:16 <lambdabot>  [[[0],[1],[2],[3]],[[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2...
13:27:09 <emu> > sequence (replicate 2 [0..3])
13:27:10 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3],[3,...
13:27:32 <glguy> Cale: is there a way to do the following with sequence or some other monad function (but more importantly, without explicit recursion)
13:27:36 <glguy> > let f [] = [[]]; f xs = do { (y:ys) <- tails xs; map (y:) (f ys)} in f [1,2,3]
13:27:36 <lambdabot>  [[1,2,3],[1,3],[2,3],[3]]
13:28:29 <mauke> > tails []
13:28:30 <lambdabot>  Add a type signature
13:28:44 <emu> @type tails
13:28:45 <lambdabot> forall a. [a] -> [[a]]
13:28:53 <mauke> > tails ""
13:28:54 <lambdabot>  [""]
13:29:11 <emu> > tails [1,2,3]
13:29:12 <lambdabot>  [[1,2,3],[2,3],[3],[]]
13:31:32 <Cale> > let f [] = [[]]; f xs = do { (y:ys) <- tails xs; map (y:) (f ys)} in f [1,2,3,4]
13:31:33 <lambdabot>  [[1,2,3,4],[1,2,4],[1,3,4],[1,4],[2,3,4],[2,4],[3,4],[4]]
13:31:58 <weitzman> Can lambdabot rewrite statements so they don't need parenthesization?
13:32:22 <mauke> hmm, should be trivial
13:32:41 <glguy> you could do it with a load of lambda :)
13:32:44 <glguy> lambdas
13:33:07 <newsham> how much is a load of lambdas?
13:33:15 <glguy> $4
13:33:20 <newsham> sold!
13:34:18 <Templar> anyone knows the command to convert .hs -> .exe in GHC in WIN XP?
13:34:25 <Templar> Prelude> xxxxx
13:34:53 <mauke> what do you mean by "in GHC"?
13:34:54 <Igloo> ghc --make foo.hs -o foo.exe   from a comandline
13:35:20 <Templar> Igloo: thanks! Trying it out
13:35:32 <yip> and make sure that you have a "Main" module with a "main" value
13:35:32 * basti_ thinks one lambda is as good as a load of
13:36:45 <newsham> wow, if each lambda is worth a load of lambdas, and I'm getting a whole load of them, thats a lot of lambdas!
13:38:36 <clanehin> a strict language wouldn't be able to handle all those lambdas
13:39:00 <Templar> dont get it to work, Note I¥m doing it in Windows!
13:39:02 <Templar> http://83.227.193.230/hs/ghc.png
13:39:34 <mauke> Templar: not in ghci; do it in the normal command line!
13:40:00 <Templar> aha, 2 sec, will try it
13:40:13 <weitzman> How might you write f (y 3) without parens?
13:40:17 <xerox> haha, -- is a comment.
13:40:24 <Cale> f . y $ 3
13:40:26 <Cale> or
13:40:30 <Cale> f $ y 3
13:40:49 <mauke> let tmp1 = y 3 in f tmp1
13:40:50 <weitzman> I'm going to have to figure out what the magical money does
13:41:00 <Cale> f $ x = f x
13:41:01 <mauke> nothing :-)
13:41:04 <weitzman> Oh
13:41:09 <Cale> but $ has low precedence
13:41:28 <yip> lower then function application
13:41:38 <newsham> templar: quit ghci, from dos command prompt run "ghc --make temperature.hs -o test.exe"
13:41:43 <Cale> lower than anything else
13:41:50 <Cale> function application has the highest precedence
13:41:55 <weitzman> Is it right- or left- associative?
13:41:57 <newsham> err, someone already said that
13:42:00 <Cale> higher than any infix operator
13:42:28 <Cale> $ is set to be right associative
13:42:34 <weitzman> Cool
13:42:36 <Cale> which is actually wrong, if you ask me
13:42:56 <Cale> It would be better left associative
13:43:10 <Cale> to match ordinary function application
13:43:51 <norpan> that would take the whole point out of $
13:43:58 <Cale> norpan: no it wouldn't
13:44:07 <norpan> which is to be associative different from normal function application
13:44:13 <Cale> that's not the point
13:44:29 <Cale> the point is to have low precedence :)
13:44:43 <norpan> well, one point
13:44:52 <Cale> anywhere that you write f $ g $ h x, you could write f . g $ h x instead
13:45:00 * kpreid loses
13:45:07 <kpreid> heh. left-associative $ would eliminate the choice between f . g $ x and f $ g $ x
13:45:11 <Cale> right
13:45:27 <Cale> and it would open up new uses
13:45:31 <yip> they intentially designed it to be less then optimal in order to encourage paranthesis lisp-like style
13:45:48 <newsham> so its sorta like qwerty?
13:46:43 <Cale> $! being right associative to match $ is severely annoying
13:46:57 <Cale> if you've ever wanted to apply more than one parameter in a strict way
13:47:14 <norpan> why, just tack on the parameters with $!?
13:47:29 <Cale> You have to write (f $! x) $! y
13:47:33 <Cale> for  f x y
13:47:52 <Cale> because f $! x $! y means f $! (x $! y)
13:48:04 <newsham> cant you just define  ($$!) = ($!)  with diff associativity?
13:48:08 <Cale> you can
13:48:10 <Templar> ok, I¥m having problems. The "command line" dont accept "ghc offcorse but I guess I should run ghc from "Run" right? Cant I type like this at Run:
13:48:18 <Templar> C:\Program\ghc\ghc-6.4.2\bin\ghc.exe --make C:\temperature.hs -o C:\out.exe
13:48:32 <Cale> But still, just fixing the associativity of $! is the right thing to do
13:48:35 <mauke> the command line doesn't accept ghc because it's not in your PATH
13:48:43 <Cale> There's no need for it to be right associative :)
13:48:53 <Templar> :P
13:48:55 <Templar> okok
13:49:00 <emu> glguy: is that the same as: f' xs = tails xs >>= \(y:ys) -> map (y:) (f' ys)
13:49:05 <Templar> trying commandline once more with path right
13:49:07 <mauke> I forgot the cmd.exe syntax
13:49:11 <newsham> templare: you could add it to your path (right click computer, properties, advanced, environment variables)
13:49:16 <mauke> how do you add something to %PATH%?
13:49:25 <yip> set
13:49:35 <Templar> ah, roger
13:49:37 <yip> set PATH=C:\Program\ghc\ghc-6.4.2\bin\
13:49:47 <mauke> add to, not replace
13:49:56 <yip> that's all he's going to need ;)
13:50:02 <yip> although it shouldn't even be necessary
13:50:02 <newsham> set path=%path%;c:\....
13:50:05 <weitzman> set path=blah;%path%
13:50:21 <mauke> ah, thanks
13:50:22 <weitzman> Except you might need quotes if you have spaces
13:50:28 <weitzman> I forget where the quotes go
13:50:50 <emu> > let {f' [] = [[]]; f' xs = tails xs >>= \(y:ys) -> map (y:) (f' ys)} in f' [1..3]
13:50:51 <lambdabot>  Non-exhaustive patterns in lambda
13:52:40 <emu> aye, f' xs = tails xs >>= \z -> case z of [] -> []; y:ys -> map (y:) (f' ys)
13:52:48 <emu> yow
13:52:55 <emu> @yow
13:52:56 <lambdabot> Yow!  I'm imagining a surfer van filled with soy sauce!
13:53:21 <yip> where did all those quotes come from?
13:54:03 <newsham> do lambdabots dream of electric sheep?
13:54:10 <lispy> yip: pinhead?  i'm not sure on the history exactly but emacs has that command also
13:54:19 <lispy> newsham: heh
14:00:35 <glguy> emu: that f' you asked about would not work because (y:ys) is not exhaustive
14:00:43 <glguy> but you used it in a lambda expression
14:02:18 <newsham> import pdb; pdb.pm();   print board;  print board[0]
14:02:21 <newsham> oops
14:02:39 <tibbe> newsham: heh, dating some imperative language on the side, eh? ;)
14:02:52 <emu> glguy: yea yea apparently the list monad takes care of non-exhaustive match
14:03:32 <newsham> tibbe:  thats the wife, dont tell her i'm here...
14:03:40 <glguy> emu: when the pattern match fail, it returns "fail"
14:03:45 <glguy> > fail :: [Int]
14:03:46 <lambdabot>    Expecting a function type, but found `[Int]'
14:03:46 <lambdabot>    Expected type: [Int]
14:03:46 <lambdabot> ...
14:04:04 <glguy> > fail "":: [Int]
14:04:04 <lambdabot>  []
14:04:16 <newsham> obs: so thats why its not working, your board isnt the 2-dim list you expected it to be.
14:04:35 <newsham> blah, i'm no good with irc windows, my apologies
14:04:53 <emu> f' xs = concatMap (whenNotNil $ \(y:ys) -> map (y:) (f' ys)) (tails xs)
14:04:57 <emu>     where whenNotNil _ [] = []; whenNotNil f l  = f l
14:05:00 <emu> that works=)
14:06:00 <tibbe> ?type let whenNotNil _ [] = []; whenNotNil f l  = f l in whenNotNil
14:06:01 <lambdabot> forall a a1. ([a] -> [a1]) -> [a] -> [a1]
14:06:27 <tibbe> let whenNotNil _ [] = []; whenNotNil f l  = f l, f' xs = concatMap (whenNotNil $ \(y:ys) -> map (y:) (f' ys)) (tails xs) in f'
14:06:32 <tibbe> ?type let whenNotNil _ [] = []; whenNotNil f l  = f l, f' xs = concatMap (whenNotNil $ \(y:ys) -> map (y:) (f' ys)) (tails xs) in f'
14:06:33 <lambdabot> parse error on input `,'
14:06:50 <tibbe> cant you have several lets seperated by commas?
14:07:30 <tibbe> > let a = 1, b = 2 in a + b
14:07:31 <lambdabot>  Parse error
14:07:33 <emu> no just do semicolons
14:07:36 <glguy> > let f xs = if null xs then [[]] else init (tails xs) >>= \x -> map (head x:) (f $ tail x) in f [1,2,3]
14:07:37 <lambdabot>  [[1,2,3],[1,3],[2,3],[3]]
14:07:48 <emu> aye i was working on a solution with inits rofl
14:07:53 <tibbe> ?pl let whenNotNil _ [] = []; whenNotNil f l  = f l; f' xs = concatMap (whenNotNil $ \(y:ys) -> map (y:) (f' ys)) (tails xs) in f'
14:07:53 <lambdabot> (line 1, column 18):
14:07:53 <lambdabot> unexpected "["
14:07:53 <lambdabot> expecting pattern or "="
14:07:55 <emu> just discovered that function in prelude
14:08:39 <tibbe> bah, I wanted some @pl magic
14:12:49 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in f $ map return [1..4]
14:12:50 <lambdabot>  [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]]
14:12:53 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in f $ f $ map return [1..4]
14:12:54 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
14:13:53 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in runState (replicateM (modify f)) $ map return [1..4]
14:13:54 <lambdabot>    Expecting a function type, but found `State s a'
14:13:54 <lambdabot>    Expected type: St...
14:14:06 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in runState (replicateM 2 (modify f)) $ map return [1..4]
14:14:07 <lambdabot>  ([(),()],[[1,2,3],[1,2,4],[1,3,4],[2,3,4]])
14:14:15 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in runState (replicateM 1 (modify f)) $ map return [1..4]
14:14:16 <lambdabot>  ([()],[[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]])
14:14:34 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) in execState (replicateM 1 (modify f)) $ map return [1..4]
14:14:35 <lambdabot>  [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]]
14:15:08 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) ; perms n xs = execState (replicateM n (modify f)) (map return xs) in perm 2 [1..4]
14:15:09 <lambdabot>  Not in scope: `perm'
14:15:13 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) ; perms n xs = execState (replicateM n (modify f)) (map return xs) in perms 2 [1..4]
14:15:14 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
14:15:19 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) ; perms n xs = execState (replicateM n (modify f)) (map return xs) in perms 1 [1..4]
14:15:20 <lambdabot>  [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]]
14:16:17 <glguy> > let f = (>>= \x -> map (:x) [1..head x - 1]) ; combs n xs = execState (replicateM n (modify f)) (map return xs) in flip combs [1..4] =<< [0..3]
14:16:18 <lambdabot>  [[1],[2],[3],[4],[1,2],[1,3],[2,3],[1,4],[2,4],[3,4],[1,2,3],[1,2,4],[1,3,4]...
14:17:05 <glguy> there it is, my "no recursion combination generator" :)
14:18:35 <newsham> and there's no recursion in there?
14:19:06 <glguy> replicateM probably uses recursion to loop
14:19:24 <glguy> similarly wih map and >>=
14:19:30 <ndm> not >>=
14:19:33 <ndm> but enumFromTo does
14:19:37 <Templar> anyone who knows why I¥m getting import error here?: http://83.227.193.230/hs/ghc.png
14:20:06 <ndm> Templar: can you paste the first 5 lines of your code?
14:20:11 <ndm> @paste
14:20:11 <lambdabot> http://paste.lisp.org/new/haskell
14:20:30 <Templar> main :: IO ()
14:20:30 <Templar> import Data.Ratio
14:20:30 <Templar> import Test.QuickCheck
14:20:30 <Templar> import ArbitraryRatio
14:20:30 <Templar> prop_fahcon :: Double -> Bool
14:20:38 <glguy> ndm: but regardless, my code doesn't have ot recurse, that's all safely nested away in the standard library
14:20:42 <integral> Templar: import has to be *BEFORE* the code starts
14:21:05 <ndm> glguy: safely? when you use head?
14:21:13 <ndm> :)
14:21:14 <glguy> yeah
14:21:17 <glguy> safely
14:21:17 <glguy> :)
14:21:19 <Templar> glguy: aha, ok, 2 sec :)
14:21:29 <glguy> ?
14:21:49 <Templar> sry, wrong :)
14:21:56 <Templar> *intregral
14:22:09 <integral> My name is "integral".  8 letters.
14:22:33 * ndm wonders if integral is your real name....
14:22:35 <newsham> glguy: cant you do the same with iterate (\x -> [x:y | y<-[1..x]]) [] ?
14:22:41 <glguy> My name is "ninechars". 9 chars
14:22:42 <newsham> or something like that (i botched it)
14:22:47 <integral> ndm: Too much irc does that to you
14:22:54 <glguy> newsham: maybe... give it a shot :)
14:23:02 <newsham> heh.. no baiting!
14:24:10 <glguy> newsham: iterate works... but doesn't stop
14:24:30 <newsham> glguy: you're making all permuations of [1,2,3,4] ?
14:24:36 <glguy> combinations
14:24:43 <newsham> err yah
14:25:05 <glguy> I know that using MonadState to do the function composition isn't the best way :)
14:25:17 <lisppaste2> Templar pasted "GHC" at http://paste.lisp.org/display/25724
14:26:12 <ndm> Templar: the type for a function comes immediately above the function, so move the type sig and definition of prop_fahcon together
14:26:16 <Templar> http://83.227.193.230/hs/ghc.png
14:26:18 <ndm> and you hvae to define main, just not give a type of it
14:26:34 <integral> ndm: the position of the type doesn't *have* to be there
14:26:47 <Templar> ...
14:26:53 <ndm> Templar: and right click, mark, copy - to copy a dos box message
14:28:23 <Templar> ok, that dos copy thing dosent work =/
14:28:40 <Cale> what?
14:29:11 <Templar> dont know why ^^
14:29:20 <ndm> Templar: it really does on my box boxes
14:29:22 <glguy> > (iterate ((\x -> [ y:x | y <- [1..head x - 1]]) =<<) (map return [1..4])) !! 2
14:29:23 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
14:29:26 <glguy> > (iterate ((\x -> [ y:x | y <- [1..head x - 1]]) =<<) (map return [1..4])) !! 1
14:29:27 <lambdabot>  [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4]]
14:29:49 <ndm> Templar: Right click, select Mark, drag an area of the screen, press Enter
14:29:50 <Templar> and you using windows?.
14:29:54 <glguy> > ((iterate ((\x -> [ y:x | y <- [1..head x - 1]]) =<<) (map return [1..4])) !!) =<< [0..3]
14:29:55 <lambdabot>  [[1],[2],[3],[4],[1,2],[1,3],[2,3],[1,4],[2,4],[3,4],[1,2,3],[1,2,4],[1,3,4]...
14:29:57 <ndm> Templar: then you can paste
14:30:12 <ndm> Templar: yep
14:30:25 <ndm> Templar: and i have to recommend winhugs to you - much easier for learning than GHC
14:31:00 <Templar> ah, now I understand that copy thing, thanks
14:31:17 <ndm> WinHugs would make the copying a million times easier though :)
14:31:35 <Templar> ndm: I¥m using winhugs but I nedd CGH to convert my .hs files to .exe right?
14:31:43 <Trevion> I remember when I first started learning Haskell I was frustrated with WinHugs lack of being able to make new definitions at the prompt... is that better now?
14:31:48 <ndm> Templar: yep, you do
14:31:54 <ndm> Trevion: no :(
14:32:39 <ndm> although its never been an issue for me - i usually have a file for defintions etc anyway
14:33:20 <emu> > (iterate (\x -> x++[1..(1+(length x))]) [])
14:33:21 <lambdabot>  [[],[1],[1,1,2],[1,1,2,1,2,3,4],[1,1,2,1,2,3,4,1,2,3,4,5,6,7,8],[1,1,2,1,2,3...
14:34:00 <Trevion> Yeah, I came to Haskell directly from DrScheme...
14:34:21 <Templar> but you are saing that I need to define my main here then? http://paste.lisp.org/display/25724
14:34:24 <Templar> how do I do that?
14:34:50 <Cale> Templar: what do you want it to do?
14:35:06 <Cale> Templar: you could delete the typesig for main and just load the file up in GHCi of course
14:35:25 <Templar> Cale: I whant to make the .hs to .exe but getting the error:
14:35:26 <Templar> "http://paste.lisp.org/display/25724"
14:35:29 <Templar> ops
14:35:40 <Cale> Templar: what should the .exe do when it's run?
14:36:04 <ndm> Templar: get it so your program runs, and typing "main" in WinHugs does what you want, then try compiling with GHC
14:36:15 <Templar> Will work like WinHugs I guess?(never done it)
14:37:04 <Templar> whant ppl who dont have WinHugs to be availibel to test it
14:37:18 <ndm> yes, but it doesn't do anything at the moment...
14:38:28 <Templar> it¥s an forumla when you :l it in WinHugs, is it not the same thing when it¥s converted to .exe?
14:40:03 <ndm> in WinHugs, load a file, run "main"
14:40:11 <ndm> by typing main, then enter at the winhugs prompt
14:40:16 <ndm> then ghc will give you the same thing
14:41:53 <Templar> dame, couldent load my file in WinHugs now when I have added "main :: IO ()" =/
14:42:05 <newsham> whats a good example of a lexer written with parsec?
14:51:23 <nomeata> newsham: not sure if its, good, but there is an article around that introduces haskell by implementing a scheme implementation, which uses a little bit parsec.
14:52:03 <ndm> newsham: i tried writing a lexer in parsec, and found out that parsec doesn't really work that way
14:52:06 <newsham> hmm.. good point.. scheme's lexically simple, but still might be useful..  i'll go look
14:52:56 <newsham> ndm: I dont entirely need a separate lexer, but I do need to make sure it handles reserved words and whitespace and such properly
14:53:27 <newsham> the toy examples in the parsec doc were a bit simplistic, i still have many questions
15:38:09 <newsham> how would one parse /* .... */ ?   do { string "/*"; many (noneOf "*") ... } ?
15:38:52 <newsham> is there a function for "anything until this string" ?
15:39:22 <edi> between (string "/*") (string "*/") ... -- maybe?
15:39:35 <newsham> ahh, perfect.. just stumbled on that.
15:41:02 <newsham> does that have to be  (try (string "*/"))  or something?
15:41:11 <newsham> parsing /* ... * .. */  ?
15:41:39 <newsham> wait, only need try for <|> right?
15:42:14 <mauke> I don't think between would work
15:43:35 <mauke> string "/*" >> manyTill anyChar (try (string "*/"))
15:43:54 <newsham> whats the reason between wouldnt work?
15:44:43 <mauke> between a b x = do { a; r <- x; b; return r } AFAIK
15:46:32 <newsham> single_comment = string "//" >> manyTill anyChar (char '\n')
15:46:34 <newsham> make sense?
15:47:23 <newsham> so between (char 'x') (char 'x') (string "foo")  matches just "xfoox" then?
15:47:47 <mauke> I think so
15:48:43 <mauke> .oO( single_comment = string "//" >> many (noneOf "\n") )
15:49:15 <newsham> mauke: yah..
15:50:41 <newsham> assuming no escapes:  qstring = between (char '"') (char '"') (many (noneOf "\""))   ?
15:51:18 <mauke> yeah
15:51:31 <mauke> man, << is so much more readable
15:51:48 <mauke> qstring = char '"' >> many (noneOf "\"") << char '"'
15:52:07 <newsham> but doesnt between just return the "between" stuff?
15:52:20 <mauke> so does my version
15:53:00 <mauke> ?pl (<<) a b = a >>= \r -> b >> return r
15:53:00 <lambdabot> (line 1, column 10):
15:53:00 <lambdabot> unexpected "="
15:53:00 <lambdabot> expecting variable, "(", operator or end of input
15:53:02 <newsham> heh, i dont fully understand yours.  I'm fairly used to >> by now, but << mixed in is confusing me
15:53:09 <mauke> ?pl f a b = a >>= \r -> b >> return r
15:53:09 <lambdabot> f = (. ((. return) . (>>))) . (>>=)
15:53:13 <newsham> ahh
15:58:28 <lispy> i thought (<<) didn't exist
15:58:39 <ndm> @hoogle <<
15:58:39 <lambdabot> Text.Html.(<<) :: HTML a => (Html -> b) -> a -> b
15:58:39 <lambdabot> Control.Arrow.(<<<) :: Arrow a => a c d -> a b c -> a b d
15:58:39 <lambdabot> Control.Arrow.(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
15:58:43 <deadbeef> ?type (<<)
15:58:44 <lambdabot> Not in scope: `<<'
15:58:45 <lispy> oh
15:59:00 <lispy> part of html
15:59:18 <Deformative-II> Hmm.
15:59:20 <SamB> ?pl a << b = a >>= \r -> b >> return r
15:59:20 <lambdabot> (line 1, column 8):
15:59:20 <lambdabot> unexpected "="
15:59:20 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:59:53 <SamB> needs a better parser...
16:00:17 <ndm> SamB: send a patch...
16:00:40 <newsham> one thing about using parsec, its not as clear what the language that the parser accepts is.
16:00:52 <SamB> hmm
16:00:53 <newsham> whereas with a parser generator you have the CFG
16:01:31 <newsham> (ie. in parsec forgetting a "try" could give you a much diff grammar than you expect)
16:01:47 <ndm> yep, i don't like parsec because of that
16:01:53 <ndm> although in other ways its beautiful
16:02:00 <newsham> seems like that would be bad for formal work.
16:02:15 <ndm> for a hacky parser, its definately better
16:02:17 <newsham> ndm: what do you typically use?
16:02:27 <newsham> yah, i think this is great for simple config file type parsers.
16:02:33 <lispy> if you were parsing latex i think parsec would be great
16:02:38 <newsham> its actually pretty fun to use so far (though I havent had to do expressions yet!)
16:02:47 <ndm> newsham: http://www-users.cs.york.ac.uk/~ndm/projects/parsing.php
16:02:49 <lambdabot> Title: Neil Mitchell - Parsing, http://tinyurl.com/g8j88
16:02:50 <SamB> lispy: o rly?
16:02:57 * SamB does not
16:03:00 <lispy> because latex grammar is apparently a pain in the ass to describe formally
16:03:05 * SamB thinks only TeX can do it...
16:03:07 <ndm> for parsing hoogle queries - something thats a bit quirky, its great
16:03:13 <ndm> i think it would be perfect for latex
16:03:23 <ndm> but mainly because latex is broken
16:03:31 <newsham> ndm: what kind of parser is that?
16:03:38 <ndm> newsham: a Neil (TM) parser
16:03:55 <ndm> newsham: an entirely different theory/implementation/use model to all others
16:04:02 <newsham> does it use any well known techniques like shift-reduce, tomita, recursive descent?
16:04:08 <newsham> ahh
16:04:08 <ndm> nope :)
16:04:24 <ndm> it uses deterministic stack automata
16:04:30 <newsham> what grammars can it deal with and what type of runtime?
16:04:47 <ndm> unknown what hte formal power is - but it seems to correspond to "useful ones"
16:05:04 <ndm> and the runtime is similar to Alex/Happy - you write a config file, it generates some tables
16:05:13 <newsham> so your hunch is not all context-free, but broad coverage of the useful ones?
16:05:16 <ndm> although only generates tables, no code, so can be invoked at runtime
16:05:35 <newsham> ambiguous grammars?
16:05:37 <ndm> indeed, it has more powerful than context-free in some areas, less in others
16:05:44 <ndm> definately not ambiguous grammars
16:05:56 <newsham> precedence rules to disambiguate?
16:06:07 <ndm> nope, maximal munch
16:06:14 <ndm> since thats almost always the right thing
16:06:20 <newsham> dunno what that means (sounds greedy)
16:06:24 <ndm> if not actually always, and then poorly encoded
16:06:26 <SamB> indeed ;-)
16:06:27 <ndm> the classic problem is:
16:06:52 <ndm> if a if b else d
16:06:55 <ndm> is that:
16:07:01 <ndm> (if a (if b) else d)
16:07:03 <ndm> or
16:07:10 <ndm> (if a (if b else d))
16:07:22 <newsham> (i wrote a GLR parser generator (using SLR tables))
16:07:27 <ndm> every Happy/Yacc based parser generates a shift-reduce conflict for that
16:07:29 <SamB> it isn't a problem in Haskell ;-)
16:07:35 <SamB> because...
16:07:43 <SamB> every if must have an else ;-)
16:07:47 <ndm> yes, not in haskell, but its the classic problem
16:07:54 <ndm> and does occur in haskell, buit with other bits of syntax
16:07:59 <newsham> the "dangling-else problem"
16:08:03 <ndm> indeed
16:08:23 <newsham> its not just a shift-reduce conflict, its a true ambiguity in the grammar.
16:08:25 <ndm> mine hops for hte second, by default, without a warning/error - since the second gives the inner token the most number of characters
16:08:49 <ndm> i.e. maximal munch - gives the inner expression more characters, more munch
16:08:54 <newsham> thats the typical resolution (prefer shift over reduce, in yacc)
16:09:04 <ndm> yes, but thats a bit of a hack in yacc
16:09:10 <ndm> whereas in my system its pure
16:09:12 <newsham> though you can override that behavior with annotations in the grammar
16:09:34 <ndm> and yacc sometimes fails to generate a grammar from a bunch of definitions
16:09:45 <ndm> conflicts/ambiguities etc
16:09:48 <ndm> mine has none of that
16:09:55 * SamB wonders how a flex-compability mode work work for a generator that generates Haskell?
16:09:58 <newsham> I dont think its a hack.  There's an ambiguity (parser longer or parser shorter, bind tighter or bind looser), and there's  aresolution (prefer longer).
16:10:05 <SamB> er, would work
16:10:19 <newsham> right, yacc can only do LALR(1) (more or less), so some grammars cannot be handled.
16:10:31 <ndm> i don't like it, its maybe not a total hack, but its giving a warning for something thats "standard"
16:10:46 <ndm> yes, mine is as powerful as the syntax
16:10:46 <newsham> the shift-reduce parser has some ambiguities in its parse decision that arent based on true ambiguities in the grammar.
16:11:04 <ndm> i.e. you wrote, it works
16:11:39 <newsham> you can take a shift-reduce parser and make it "nondeterministic" to try out all possibilities whenever an ambiguity is encountered.. thats what tomita parsers do
16:11:51 <ndm> yep
16:11:56 <ndm> packrat parsing is also pretty nice
16:12:01 <ndm> but mine is nicer than all of them
16:12:02 <newsham> and when you do so, the benefits of using LALR(1) over LR(0) go away, so most people just use LR(0)
16:12:25 <ndm> plus, as an acidental side effect,  mine is also fastest :)
16:12:42 <ndm> (in theory, the implementation has not got far enough to prove this :( )
16:12:54 <newsham> but even so, its still useful to be able to write out an ambiguous grammar (ie. E -> E + E) and then annotate it with disambiguating rules (plus associates to the left) that get rid of ambiguities
16:13:00 <ndm> but i did prove O(n)
16:13:05 <newsham> similarly for the if-then-else dangling-else problem.
16:13:26 <newsham> shift-reduce is also O(n)
16:13:35 <ndm> not quite, its "almost" O(n)
16:13:51 <newsham> how so?
16:14:00 <ndm> my grammar system doesn't have things like E -> E + E, so its not really a similar problem in my language
16:14:19 <ndm> the stack manipulations can take a time proportional to the number of characters plus a small bit
16:14:48 <ndm> its not much above O(n), and usually it is, but for pathalogical grammars its slightly worse
16:15:01 <newsham> did you look at any of the "fast early" parsers?
16:15:11 <newsham> (I prob mispelled "earley"?)
16:15:17 <ndm> the generalised yacc?
16:15:26 <ndm> yep, they are about O(n^2.5) i think
16:15:45 <ndm> but on average, are O(n^1.something_small)
16:16:08 <ndm> they a nice in that you wrote it means it works
16:16:10 <newsham> you like lex and not yacc?  :)
16:16:14 <ndm> but my parsers are written in a nicer way
16:16:18 <newsham> lex also has backtracking (oops.. almost O(n))
16:16:18 <ndm> no, i like some of lex
16:16:31 <ndm> ah, no, lex is very clearly O(n^2)
16:16:37 <ndm> unless you use the Neil (TM) algorithm
16:16:49 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/helix.php - proof :)
16:16:51 <lambdabot> Title: Neil Mitchell - Helix, http://tinyurl.com/erkka
16:16:53 <newsham> your slides say lex is O(n)
16:17:03 <ndm> i know they do, and when i wrote those slides i thought it was
16:17:15 <ndm> turns out i was wrong, but i now have an O(n) lex algorithm
16:17:20 <ndm> even if no one else does
16:17:31 <newsham> how is lex O(n^2) ?
16:17:41 <ndm> look at that page, it has an example
16:17:57 <ndm> bascially a | a*b
16:18:03 <ndm> with the rule "match as much as you can"
16:18:17 <ndm> is "aaaaaaa...." a first one, or a second one?
16:18:18 <newsham> gotcha
16:18:39 <ndm> my algorithm does that in O(n) time and O(n) space
16:18:49 <ndm> lex does it in O(n^2) time, O(1) space
16:19:13 <ndm> where O(1) space implies you are reading from a file or something - in a lazy language its O(n) space, and probably in most implementations too
16:19:40 <SamB> umm...
16:19:55 <ndm> and mine is only O(n) space where Lex would have been O(n^2) time - i.e. you don't pay for it unless its needed
16:19:56 <SamB> why is that O(1) space?
16:19:57 <newsham> nah,  a lexer buffer is still O(1), just a bigger "1"
16:20:12 <SamB> oh, because you could fseek back?
16:20:12 <ndm> yes, but you might need to backtrack an arbitrary amount
16:20:28 <newsham> i see what you're saying
16:20:29 <ndm> yeah, its O(1) as long as you don't mind fseek'ing
16:20:51 <ndm> but in haskell, say, if you are parsing from a file you'll space leak the O(n) regardless
16:21:01 <ndm> if you just use readFile  as a String
16:21:03 <SamB> yeah...
16:21:10 <SamB> fortunately O(n) is the worst case ;-)
16:21:32 <ndm> indeed
16:21:37 <ndm> ditto with my parser as well
16:21:49 <SamB> I assume the best case is Omega(1)?
16:21:59 <ndm> hence for most practical implementations, i can claim identical memory, better time
16:22:02 <ndm> yep
16:22:26 <SamB> of course, in actual practice you'd likely get something like 10...
16:22:40 <ndm> depends, really
16:22:56 <ndm> given haskell, 1 char is 12 bytes, so depending on waht you call 1...
16:25:52 <ndm> anyway, i'm going to bed now, night
16:56:40 <newsham> @hoogle octDigit
16:56:40 <lambdabot> Text.ParserCombinators.Parsec.Char.octDigit :: CharParser st Char
16:56:41 <lambdabot> Char.isOctDigit :: Char -> Bool
16:58:44 <newsham> > digitToInt '9'
16:58:45 <lambdabot>  9
16:58:48 <newsham> > digitToInt 'f'
16:58:49 <lambdabot>  15
16:59:44 <newsham> > digitToInt '!'
16:59:45 <lambdabot>  Exception: Char.digitToInt: not a digit '!'
17:04:38 <dylan> hmm, where can I find some example code for STM? or something tutorial-like?
17:07:13 <Pupeno> any particularly recomended library for SQLing ?
17:10:32 <thetallguy> ?users
17:10:34 <lambdabot> Maximum users seen in #haskell: 243, currently: 217 (89.3%), active: 33 (15.2%)
17:16:15 <glguy> dylan: have you read http://research.microsoft.com/~satnams/lock_free_haskell_stm.pdf
17:16:17 <lambdabot> http://tinyurl.com/hyrom
17:19:51 <monochrom> Yeah, that paper contains actually quite introductory examples, up to renaming.
17:20:43 <glguy> Did lambdabot create that tiny url for the url I pasted just now?
17:20:45 <monochrom> It contains a common, mutable, pointer/reference-based data structure to be shared.
17:20:58 <monochrom> Yes.
17:21:07 * dylan emails that paper to himself so he can read it and still have a responsive computer.
17:21:17 <dylan> (yay gmail!)
17:21:25 <monochrom> Apparently iff the original URL exceeds a certain length, a tinyurl is made.
17:21:47 <sieni> Pupeno: I've still to try, but heard that HDBC or HaskellDB are the tools of choice
17:21:51 <weitzma1> I'm sure everyone using terminal-based IRC clients on cell phones will appreciate it
17:22:19 <sieni> Pupeno: http://darcs.complete.org/hdbc/doc/Database-HDBC.html and http://haskelldb.sourceforge.net/
17:22:21 <lambdabot> http://tinyurl.com/rrers
17:22:38 <weitzma1> @where hdbc
17:22:39 <lambdabot> http://quux.org/devel/hdbc
17:27:57 <Pupeno> sieni: I've took a look at HaskellDB, the syntax was a punch in my eye.
17:28:19 <Pupeno> I'll take another look in a day or so, wearing a healmet, and maybe I'll get used to it.
17:28:39 <sieni> Pupeno: It seems hdbc is more traditional
17:32:03 <Pupeno> sieni: it is not about being traditional, I am not traditional myself, it is just a matter of getting use to the syntax, I'll get used to it.
17:32:04 <Lemmih> hdbc and haskelldb are two completely different things.
17:32:33 <Pupeno> Lemmih: they are not as different as hdbc and yi or as haskelldb and cabal.
17:33:49 <Lemmih> Pupeno: They have the same theme but they are used for different things.
17:36:31 <SamB> hmm
17:36:36 <Pupeno> Doesn't most Haskell programs end up being huge set of actions with only a couple of real functions ?
17:36:38 <SamB> I think nethack needs better help...
17:36:50 <SamB> I can't remember what to do with boxes and chests!
17:36:59 <dmwit> kick
17:37:10 <Lemmih> Pupeno: Those actions /are/ real functions (:
17:37:14 <SamB> dmwit: seriously?
17:37:26 <dmwit> It was the only thing I could ever get to work...
17:37:35 <SamB> Lemmih: what say you?
17:37:42 <dmwit> You can try *open* but they're usually locked.
17:37:58 <dons> ?users #haskell
17:37:58 <lambdabot> Maximum users seen in #haskell: 243, currently: 218 (89.7%), active: 36 (16.5%)
17:38:05 <dons> oh another high score
17:38:16 <SamB> I think open only works on doors!
17:38:31 <dmwit> #loot
17:38:38 <dmwit> Sorry, I forgot.
17:38:46 <glguy> if all that you program does is IO, then your program will just be a series of actions
17:39:03 <stepcut> SamB: if you have a credit-card you can pick the locks ;)
17:39:14 <SamB> a credit-card?
17:39:17 <SamB> okay...
17:39:20 <monochrom> s/Haskell//
17:39:22 <sieni> Lemmih: could you elaborate on how hdbc and haskelldb are used for different things?
17:39:24 <dmwit> stepcut: A standard-issue lockpick does the trick just as well... ;-)
17:39:24 <SamB> I was wondering what those were for
17:39:41 <stepcut> SamB: yeah, the 'tourist' starts with a credit card
17:39:53 <Lemmih> sieni: HaskellDB is a way of creating SQL, hdbc is an abstraction of multiple database backends.
17:40:12 <Pupeno> I am thinking about a Django-like web framewrok, since db queries are fundamental, they'll permate everything into being an action; well, most of it.
17:40:16 <Lemmih> sieni: HaskellDB /must/ use hsql or hdbc to execute the SQL it creates.
17:40:28 <sieni> Lemmih: ahh, ok
17:40:39 <Pupeno> Lemmih: they are *that* separated ? awesome.
17:41:08 * Pupeno dislike that the SQL generator and the SQL connector are somehow mixed in CL-SQL.
17:41:17 <glguy> pure code can be used inside of actions without permiating it
17:41:19 <monochrom> The credit card is used as a rigid, thin card.  For some doors and frames, you can slide in a rigid, thin object through the door gap to push away the plugger.
17:42:39 <SamB> monochrom: I figured
17:42:53 <SamB> I realize that these objects do not actually take credit
17:45:18 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ _ _ __ _..._ JIMBO WALES
17:45:19 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ _ _ .-' . . '-. THIS FUCKING PENISBIRD SHITS
17:45:20 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ _ _/. . ._ . ._\ DOWN YOUR NECK INTO YOUR STOMACH
17:45:21 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ _ /. . .(o) ./__) WHERE THE SHIT BURNS FOR THE REST OF
17:45:22 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ __ /. . .,_ . .| '| YOUR SHORT AND PATHETIC LIFE
17:45:23 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ |. . ./ .\ . /_/
17:45:24 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ _ /. . .`"`" . .} IT THEN GRIPS ONTO YOUR COCK WITH ALL ITS MIGHT
17:45:25 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ __ /. . . . . . . { AND INJECTS VARIOUS MUTAGENS INTO YOUR BLOODSTREAM
17:45:26 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ _ /. . . . . . . .} THROUGH ITS RAZOR-SHARP CLAWS WHERE IT REACTS
17:45:28 -Teekwod(n=roach@061092123212.ctinets.com)- _ __ /. . . . .\/\ /\ { WITH YOUR VAST RESERVES OF FAT AND BLUBBER
17:45:30 -Teekwod(n=roach@061092123212.ctinets.com)- _ _ |. . . . . .;``"``\
17:45:32 -Teekwod(n=roach@061092123212.ctinets.com)- __ /. . . . . . / ; ; ;| NOBODY IS SAFE FROM THE PENISBIRD, AND IT
17:45:34 -Teekwod(n=roach@061092123212.ctinets.com)- _ |. . . . . . / ; ; ; | FUCKING HATES FAGS LIKE JIMBO WALES
17:45:36 -Teekwod(n=roach@061092123212.ctinets.com)- _ \ . . . ._.-`|; ; ; ;|
17:45:38 -Teekwod(n=roach@061092123212.ctinets.com)- _ /`-..--`` a a| ; ; ; | YOU ARE NEXT, YOU FUCKING FAT, FILTHY PIG
17:45:40 -Teekwod(n=roach@061092123212.ctinets.com)- _|a a a a a a a|; ; ; ;|
17:45:42 -Teekwod(n=roach@061092123212.ctinets.com)- _| a a a a a a | ; ; ; /_ _ _ _ ,--........,,
17:45:42 <chessguy> how lovely
17:45:44 -Teekwod(n=roach@061092123212.ctinets.com)- _|a a a a a a / ; ; ; ; _ _ _ .' . . . . . -='.
17:45:46 -Teekwod(n=roach@061092123212.ctinets.com)- _| a a a a a / ; ; ; / _ _ _ _\ . . . . . . . :
17:45:48 -Teekwod(n=roach@061092123212.ctinets.com)- _|a a a a a/` ; ; ; \ _ _,==" .\ . . . . . . .'
17:45:50 -Teekwod(n=roach@061092123212.ctinets.com)- _\ a a a .'. _ ,._'\.\~" o //` .\. . . . . .'
17:45:52 -Teekwod(n=roach@061092123212.ctinets.com)- _|a a a.___~' \ \-~| | o ./,\.` .\. . . _.'
17:45:54 -Teekwod(n=roach@061092123212.ctinets.com)- p|; a a/ _|.-~'| |o| |. . . . ,-''\..--'
17:45:55 <Lemmih> Cale: Around?
17:45:56 -Teekwod(n=roach@061092123212.ctinets.com)- p| _..-'"'. . .| | | |. . _="`
17:45:58 -Teekwod(n=roach@061092123212.ctinets.com)- pp~ . . . \\ . | | / /_="`
17:46:00 -Teekwod(n=roach@061092123212.ctinets.com)- ppp. . . ./,\ / /_,)")
17:46:02 -Teekwod(n=roach@061092123212.ctinets.com)- pppp . . ._,.-)")
17:46:04 -Teekwod(n=roach@061092123212.ctinets.com)- pppp__,=~"| ===================
17:46:06 -Teekwod(n=roach@061092123212.ctinets.com)- ppppp|; .;| Penisbird/. 1.3.tex
17:46:08 -Teekwod(n=roach@061092123212.ctinets.com)- pppp | y .| ===================
17:46:10 -Teekwod(n=roach@061092123212.ctinets.com)- pppp |;|\ |
17:46:12 -Teekwod(n=roach@061092123212.ctinets.com)- ppp_ |/' \| LETS GET IT ON, MOTHERFUCKERS.
17:46:12 --- mode: ChanServ set +o Cale
17:46:31 <chessguy> such talent
17:46:41 --- mode: Cale set +b *!*@061092123212.ctinets.com
17:46:50 <newsham> doesnt freenode have a method to prevent anyone who hasnt identified with identitybot form talking?
17:46:55 <Cale> yes
17:46:58 <newsham> and another mechanism for banning pepole based on their identity?
17:47:16 <dylan> O.o
17:47:19 <newsham> hmm, i guess he could just keep makin gnew identities anyway
17:47:23 <Cale> yeah
17:47:59 <chessguy> he seemed like such a frienly guy
17:48:07 <chessguy> *friendly
17:48:18 <dylan> @pl broadcast hs msg = mapM_ sendMsg hs where sendMsg h = hPutStrLn h msg
17:48:18 <lambdabot> (line 1, column 53):
17:48:18 <lambdabot> unexpected "="
17:48:18 <lambdabot> expecting variable, "(", operator or end of input
17:48:29 <dylan> oh, right. where.
17:49:02 <monochrom> That error message is very Parsecque :)
17:49:32 <Cale> Parsecesque
17:49:47 <monochrom> Parsque
17:49:52 <Cale> queuesque is a nice word
17:50:24 <Cale> Two q's three ue's and an s
17:50:38 <stepcut> Teekwod: take it to #haskell-blah ;)
17:50:51 <Cale> Teekwod isn't here
17:51:07 <Cale> and don't tell him that
17:51:08 <sieni> Cale: does it mean something like "dicky" in english?
17:51:20 <stepcut> Cale: I know, it was just a joke :p
17:52:34 <kpreid> @pl broadcast hs msg = mapM_ (\h -> hPutStrLn h msg) hs
17:52:34 <lambdabot> broadcast = flip (mapM_ . flip hPutStrLn)
17:55:23 <SamB> hmm, all I need now is a candle...
17:56:26 <Pupeno> what is the difference between import Cards.Cards and import qualified Cards.Cards ?
17:57:14 <kpreid> Pupeno: the latter does not let you use the names unqualified
17:57:16 <SamB> import qualified Cards.Cards doesn't try to bring names from that module into scope
17:57:21 <SamB> exactly...
17:58:01 <monochrom> Under the latter you must write like Card.Card.card
17:58:12 <Pupeno> monochrom: and under the first one only card ?
17:58:15 <monochrom> Under the former it's optionally.
17:58:19 <SamB> so, for instance, you almost always "import qualified Data.ByteString as Foo"
17:58:20 <kpreid> Pupeno: 'import qualified' is useful when the module you're importing exports names which you are already using unqualified to refer to something else
17:58:41 <SamB> because it has so many functions named the same as Prelude and Data.List functions
17:58:50 <kpreid> Data.Map and Data.Set, too
17:58:54 <SamB> yes
18:02:03 <SamB> oh, huh...
18:02:12 <SamB> I just found a floor with two stairways down!
18:02:35 <stepcut> yes
18:02:46 <stepcut> one goes to the mines, the other continues down the dungeons
18:03:18 <SamB> which way to go...
18:03:28 * clanehin /joins #netheck (no really, he does)
18:03:38 <SamB> #netheck ?
18:03:58 <clanehin> :/ do what I mean not what I type
18:04:08 <SamB> hmm, that place is smaller than this one!
18:04:08 <monochrom> #natheck
18:11:04 <dons> Cale: so I wonder how long it will take him to get a new isp?
18:11:11 <vincenz> nethack
18:11:20 --- mode: ChanServ set +o dons
18:11:24 --- mode: ChanServ set -o dons
18:11:27 <Cale> dons: I think he's just using zombies
18:11:31 --- mode: Cale set -o Cale
18:11:46 <dons> I suppose that's possible too
18:12:51 <Cale> He was right back on immediately after being k-lined 2 times in a row
18:13:00 * SamB is safe from the penisbird -- has no fat and blubber!
18:13:15 <dons> in #math?
18:13:57 <monochrom> I noticed that n=roach is an invariant so far.
18:15:15 <Cale> dons: In #haskell too
18:15:37 <dons> when did that happen?
18:15:59 <monochrom> half an hour ago
18:16:27 <Cale> also, a few days back
18:16:36 <dons> ah I see.
18:16:45 <Cale> Remember when nalioth was k-lining him?
18:16:56 <Cale> and he came right back?
18:17:03 <dons> oh yes, right
18:26:25 <Deformative-II> What is the haskell speed of development compaired to C?
18:27:28 <dons> should be dramatically faster. some studies indicate betwee 4 and 10x more productive
18:27:39 <dons> that's been my experience, also
18:28:12 <dons> (which makes sense, if you think about what aspects of C are transparently automated in haskell)
18:28:53 <Deformative-II> Well,  what is the preformance tradeoff?
18:28:58 <newsham> my speed writing haskell is very slow, but someone who knows it prob much faster.  :)   good first order approx should be similar lines of code per hour, which is a huge win for haskell
18:29:33 <Deformative-II> How is preformance of haskell compaired to C?
18:29:57 <dons> 1.2x slower on average, for proficient haskellers, roughly
18:30:04 <dons> though that's coming down
18:30:05 <clanehin> without wanting to nitpick, 1 line of haskell code can do a lot more work than 1 line of C code
18:30:08 <newsham> def: a good place to compare language is the language shootout
18:30:28 <newsham> http://shootout.alioth.debian.org/gp4/
18:30:30 <lambdabot> Title: Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language Shootout Benchmarks
18:30:50 <newsham> you can compare features that matter to you (ie. speed, memory, lines of code) of various languages, and see what the code looks like for similar programs in diff languages
18:31:05 <Deformative-II> Hmm,  well,  will bad haskell run better than bad C?
18:31:21 <Deformative-II> Because i know with python it will do stuff for you,  since one line of python does so much.
18:31:22 <newsham> good question.
18:31:25 <dons> Deformative-II: a good place for a general overview is haskell.org's http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
18:31:29 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/writ
18:31:30 <dons> bad C won't run at all :)
18:31:49 <newsham> dons: i have lots of counterexamples to disprove that statement
18:31:51 <dons> Deformative-II: just dive in. if you start hacking in haskell, it'll be clear what the benefits are.
18:32:13 <dons> visit haskell.org to begin with
18:32:30 <Deformative-II> I have been reading about it...  But I haven't accually started the hacking because i have been having preformance issues with my gui.
18:32:36 <Deformative-II> That is why I asked.
18:32:39 <Cale> There's a wide class of programs in Haskell which run fine but wouldn't run at all when written similarly in another language.
18:32:47 <Deformative-II> I don't want to have the same problem with programs that I write myself.
18:33:19 <newsham> def: perf will be substantially better than python, but in general not as good as C (unless you have limited time to implement and its algorithmically complex, in which case the speed of development will give you more time to optimize and hence a performance advantage)
18:33:38 <AStorm> Cale: you mean like dependency resolution based on cyclic graph theory :P
18:33:47 <newsham> which is why languages like ocaml and haskell do well in programming contests
18:33:48 <dons> Deformative-II: check the performance wiki then
18:33:51 <dons> ?wiki Performance
18:33:51 <lambdabot> http://www.haskell.org/haskellwiki/Performance
18:33:54 <Cale> AStorm: basically anything which requires laziness :)
18:34:06 <AStorm> That would run unusuably slow when implemented in other languages. Maybe even C.
18:34:42 <dons> Deformative-II: are you using ghc?
18:34:47 <Deformative-II> Yes.
18:34:54 <dons> with -O ?
18:35:13 <AStorm> Well, laziness can be sometimes implemented in a strict language... but it's damn hard to do properly.
18:35:32 <newsham> deformative:  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
18:35:43 <lambdabot> http://tinyurl.com/lepfo
18:35:51 <Deformative-II> Uhh, I just followed the howto,  what is -0 dons?
18:36:00 <newsham> like -O in gcc. optimize
18:36:09 <AStorm> Haskell will probably be best for that dependency resolution problem I'm facing :>
18:36:19 <newsham> are you running in ghci?  or compiling with ghc and running binary?
18:36:25 <deadbeef> > cons 1 (cons 2 nil)
18:36:25 <lambdabot>  Not in scope: `nil'
18:36:38 <dons> > (:) 1 ((:) 2 [])
18:36:40 <lambdabot>  [1,2]
18:36:49 <Cale> > [(x,y,z) | n <- [4..], x <- [1..n], y <- [x..n], let z = n - x - y, y < z, x^2 + y^2 == z^2]
18:36:53 <lambdabot> Terminated
18:36:55 <Deformative-II> ghc then running binary.
18:37:01 <Cale> > take 30 $ [(x,y,z) | n <- [4..], x <- [1..n], y <- [x..n], let z = n - x - y, y < z, x^2 + y^2 == z^2]
18:37:02 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(10,24,...
18:37:04 <AStorm> The idea is to linarise a probably cyclic nondirected graph.
18:37:04 <Deformative-II> I don't like ghci.
18:37:08 <deadbeef> dons: so (:) means 'cons' and [] means 'nil' ?
18:37:12 <deadbeef> or viceversa
18:37:13 <dons> yep
18:37:18 <deadbeef> ok, thanks
18:37:21 <dons> > [] -- the empty list
18:37:22 <lambdabot>  Add a type signature
18:37:26 <dons> ?type (:)
18:37:26 <Cale> dons: @eval doesn't seem lazy enough
18:37:27 <lambdabot> forall a. a -> [a] -> [a]
18:37:29 <deadbeef> yes
18:37:29 <AStorm> By breaking cycles, of course, when necessary.
18:37:48 <dons> Cale, hmm, it's got to force the value with show?
18:37:55 <newsham> > let cons = (:); nil = [] in cons 1 (cons 2 nil)
18:37:56 <lambdabot>  [1,2]
18:38:06 <deadbeef> so 'length (x:xs)' is equivalent to 'length (x cons xs)' ?
18:38:09 <Cale> dons: I mean, it's obviously computing more than it's displaying
18:38:15 <AStorm> And proper reordering and merging of subgraphs.
18:38:17 <Cale> > [(x,y,z) | n <- [4..], x <- [1..n], y <- [x..n], let z = n - x - y, y < z, x^2 + y^2 == z^2]
18:38:21 <lambdabot> Terminated
18:38:30 <Cale> > take 200 . show $ [(x,y,z) | n <- [4..], x <- [1..n], y <- [x..n], let z = n - x - y, y < z, x^2 + y^2 == z^2]
18:38:32 <lambdabot>  "[(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(10,24...
18:38:32 <dons> Cale, how could that be?
18:38:50 <deadbeef> > cons 1
18:38:50 <lambdabot>  Not in scope: `cons'
18:38:52 <Cale> I'm not sure.
18:38:56 <Cale> but look at that
18:38:57 <deadbeef> > Cons 1
18:38:58 <lambdabot>  Not in scope: data constructor `Cons'
18:39:13 <dons> deadbeef: there's no Cons/cons :)
18:39:22 <AStorm> So that I get a directed acyclic graph. Another caveat is that I can't m√≥ve the subgraphs before the "current barrier"
18:39:27 <dons> there's just (:), which is pronounced 'cons'
18:39:35 <Cale> It could be that it's computing enough to fill the old size of buffer
18:39:38 <newsham> is (:) a constructor or an operator?
18:39:39 <Deformative-II> Well, I am gonna go compile a kernel followed by learning some more haskell.
18:39:44 <Deformative-II> Thanks for the help everyone.
18:39:44 <AStorm> > :1
18:39:45 <Cale> and only printing one line now
18:39:45 <lambdabot>  Parse error
18:39:47 <dons> a constructor
18:39:56 <AStorm> Hehe
18:39:58 <AStorm> > 1:[]
18:39:59 <lambdabot>  [1]
18:40:02 <Cale> It used to print 5 lines or se
18:40:04 <Cale> so*
18:40:05 <newsham> so   length (x:xs)    is    length ((:) x xs)
18:40:16 <deadbeef> > 1:2:3:[]
18:40:17 <lambdabot>  [1,2,3]
18:40:23 <AStorm> Exactly.
18:40:38 <dons> Cale, so it runs through http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs and http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Eval.hs
18:40:39 <lambdabot> http://tinyurl.com/z7nbx
18:40:56 <newsham> > let foo ((:) a b) = (a,b) in foo "hi there"
18:40:57 <lambdabot>  ('h',"i there")
18:40:59 <gmh33> newsham: yes
18:41:16 <AStorm> Hmm... damn hard thing to do... I mean designing a proper GraphNode type :>
18:41:24 <Cale> dons: ah, right, it's taking 2048, and not exactly what's demanded by the eval plugin
18:41:36 <AStorm> Well... now that is quite simple, uh.
18:41:39 <dons> ah
18:42:04 <dons> hmm
18:42:14 <Cale> probably not so easy to fix that
18:42:15 <AStorm> data GraphNode = Nothing | [GraphNode]
18:42:46 <Cale> though I suppose it could capture as much output as was generated before termination
18:43:13 <AStorm> The fact that the graph isn't directed makes everything very complicated :/
18:43:24 <dons> hmm. as long as it doesn't make it to the network
18:43:58 <AStorm> Or... maybe I can make it directed by inversing the resolution order... let's see.
18:43:59 <newsham> astorm: why not start with a directed graph and just augment the graph with reverse edges before using it?
18:44:29 <dons> so we could remove the 2048 constraint in runplugs, and instead do that on the Eval.hs side of things
18:44:29 <AStorm> Uh, impossible, I can't traverse that graph backwards.
18:44:39 <dons> so that we won't add any extra strictness
18:44:42 <AStorm> It doesn't have to be a digraph :>
18:44:59 <AStorm> Hm.
18:45:42 <AStorm> The cycles have to be broken at some place (heuristics)
18:46:38 <AStorm> I could make the graph directed, but that'll probably increase the memory usage 100x
18:46:50 <AStorm> By duplicating nodes.
18:47:12 <AStorm> But then, I have to find the duplicates in the reordering phase and merge them.
18:47:18 <AStorm> That'll be slow.
18:47:22 <newsham> def addEdge g src sink = (\n -> if n == src then sink else if n == sink the src else g n ) ?
18:47:57 <newsham> empty = (\n -> error "node not found")
18:48:29 <jgrimes> ok, so for the G-machine, how long are indirection nodes kept?
18:48:32 <newsham> (ie. graph is a funciton mapping a node to another onde)
18:48:40 <jgrimes> until GC decides it isn't going to need those anymore?
18:49:06 <Deformative-II> Does python make nice config files or something?  For some reason most the python apps I know of are just configured in python,  but the base is in C.
18:49:12 <dylan> wow, STM is pretty easy
18:49:30 <AStorm> newsham: I know how to build graphs, thank you. The problem isn't building the graph.
18:49:37 <newsham> deformative: it makes a nicer scripting engine than sh or perl.
18:49:53 <newsham> astorm: what is the problem?
18:51:02 <Deformative-II> newsham,  but it is a config file,  like .pypanelrc
18:51:12 <AStorm> It's whether to duplicate the nodes and go with dag (cycles broken on addition), or not dupliate them, go with undirected cyclic graph and break the cycles+redirect the graph later.
18:51:20 <AStorm> I think the first solution will be faster...
18:51:35 <newsham> why do you need to break cycles?
18:51:53 <AStorm> The graph is cyclic.
18:52:02 <AStorm> There is a possibility of circular dependencies.
18:52:29 <newsham> lots of graphs are cyclic :)
18:52:39 <AStorm> Detecting a cycle is a recursive operation.
18:52:58 <AStorm> Unfortunately not a fast one.
18:53:16 <newsham> isnt strongly-connected-component O(n) ?
18:53:32 <AStorm> It's possible to check for the cycles while building the tree...
18:53:43 <AStorm> It is.
18:54:20 <AStorm> The problem is that I have another variable to check too (that GraphNode was a bit simplistic)
18:54:33 <AStorm> And there are impossible graphs.
18:55:28 <AStorm> Two factors - dependency does exist and if neccessary, has a given option in a given state.
18:55:49 <newsham> scc = depth-first-find(reverse(postorder roots))
18:56:01 <AStorm> When these invariants are broken, the graph is impossible.
18:56:13 <AStorm> Can't reverse!
18:56:42 <newsham> why not?
18:56:59 <deadbeef> ?type reduce
18:57:00 <lambdabot> Not in scope: `reduce'
18:57:12 <AStorm> Wait a while... (maybe it's a bit too late for me to think straight)
18:57:27 <newsham> http://sherry.ifi.unizh.ch/king95structuring.html
18:57:30 <lambdabot> Title: Structuring Depth-First Search Algorithms in Haskell - King, Launchbury (Researc ..., http://tinyurl.com/fpnvt
18:58:05 <AStorm> I wonder if breadth first wouldn't be better in this case... easier to detect cycles.
18:59:06 <AStorm> I mean most of the time the cycles are in breadth, not in depth.
18:59:20 <newsham> i have no idea what that means
18:59:34 <jgrimes> nevermind on that g-machine indirection node question
18:59:35 <jgrimes> :p
19:00:08 <AStorm> I'd stumble on a cycle faster if I search breadth-first.
19:00:14 <newsham> if you use the grpah library it probably already has scc
19:00:15 <AStorm> Probably.
19:00:28 <AStorm> Uh I know :>
19:00:37 <AStorm> It's simple to implement in Haskell anyway.
19:01:12 <deadbeef> ?type zip
19:01:13 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
19:01:33 <deadbeef> > zip [1,2] [3,4]
19:01:34 <lambdabot>  [(1,3),(2,4)]
19:02:02 <deadbeef> ?index zip
19:02:02 <lambdabot> Data.List, Prelude
19:02:12 <deadbeef> ?fptools Data.List
19:02:12 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
19:02:17 <AStorm> The thing is not to walk the nodes twice.
19:02:53 <AStorm> So I'll probably have to check on every step if a given node is in the graph...
19:02:58 <lisppaste2> dylan pasted "echo server, many to many" at http://paste.lisp.org/display/25732
19:03:06 <AStorm> Or... a flag to the node.
19:03:35 <AStorm> If it's been traversed.
19:03:44 <dylan> lispy: was it you that had the echo-server thing that had a memory leak? :)
19:03:47 <dons> dylan: nice.
19:04:00 <AStorm> (I told you the graph wasn't directed)
19:04:01 <dylan> of course, this has a memory leak too, but that's just because it is a hack
19:04:30 <jgrimes> dylan, cool deal :)
19:05:04 <dylan> it's really nice. I wrote the type signatures first, and never had a type error.
19:05:19 <AStorm> Ok, so just a simple class and I'm done.
19:06:22 <deadbeef> ?type partition
19:06:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:06:36 <AStorm> Uh, short-circuiting _will_ backfire in cycle detection unless I specifically check for that :/
19:06:56 <deadbeef> > let p x = mod x 2 == 0 in partition p [1,2,3,4]
19:06:57 <lambdabot>  ([2,4],[1,3])
19:07:07 <lisppaste2> dons annotated #25732 with "pointfree fun" at http://paste.lisp.org/display/25732#1
19:07:17 <AStorm> :/
19:07:18 <dons> dylan: ^^
19:07:50 <AStorm> deadbeef: even, then odd? Why in this way?
19:08:03 <dylan> err, that's the same link, isn't it?
19:08:18 <AStorm> There are probably faster ways?
19:08:26 <dons> annotated. oh, and also this would be nicer
19:08:26 <dons> getHandles :: TVar [Handle] -> IO [Handle]
19:08:27 <dons> getHandles = atomically . readTVar
19:08:30 <dylan> ah, after hitting refresh a few times, now I see the annotated
19:08:47 <deadbeef> AStorm: i didn't know 'partition'
19:09:21 <AStorm> Hehe.
19:09:23 <dons> dylan: just for fun :) not obviously clearer. though the above getHandles looks good
19:09:36 <AStorm> Nice function, yes.
19:09:40 <newsham> how do you plan to identify cycles while adding to the graph?
19:09:51 <dons> use fgl instead?
19:09:57 <AStorm> It breaks up a list according to another list.
19:10:00 <newsham> dons++
19:10:01 <dons> ?docs Data.Graph.Inductive
19:10:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
19:10:06 <AStorm> @type partition
19:10:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:10:13 <AStorm> newsham: not sure yet.
19:10:20 <newsham> methinks easier to build the graph and detect cycle with a separate traversal
19:10:35 <newsham> me-also-thinks using graph lib is the way to go
19:10:48 <AStorm> That'll be... O(n^3)
19:10:51 <AStorm> :P
19:11:08 <newsham> how do you figure?  SCC = O(n)
19:11:10 <deadbeef> omg, cubic!
19:11:33 <newsham> scc tells you if you have cycles (and more, what cycles there are and which nodes are in htem)
19:11:36 <AStorm> SCC doesn't work for cycle detection :P
19:11:43 <dylan> dons: danke, btw.
19:11:51 <dons> no worries :)
19:11:56 <AStorm> Wait wait.
19:12:02 <dylan> dons: I gave up on point-free while I was trying to write it as the type signature said.
19:12:44 <AStorm> If I mark the nodes as traversed, then it well might be O(n)
19:12:48 <dons> yep, i'm not suggesting pointfree is better in this case :)
19:12:53 <emu> is there a better version of haskell-mode than "haskell-mode-2.1" than monnier's?
19:12:58 <emu> er
19:13:02 <emu> is there a better version of haskell-mode than "haskell-mode-2.1" by monnier
19:13:36 <AStorm> But I have to detect the subcycles too.
19:13:47 <AStorm> How do you plan to get that? :>
19:13:56 <newsham> astorm: why not (1) just use fgl, or (2) read the "structuring graph algos in haskell" paper which talks about techniques for doing this
19:14:01 <deadbeef> > let p x y = x == y in deleteBy p 2 [1,2,3]
19:14:01 <lambdabot>  [1,3]
19:14:31 <AStorm> Probably I'm just not thinking well because of tiredness :>
19:14:46 <AStorm> Ah, possible, simple really.
19:14:53 <dylan> dons: and.. using STM like this, there's no chance of deadlocks?
19:14:59 <newsham> astorm: graph decomposition.  find SCC in graph, make new graph out of relations between SCCs.  repeat.
19:15:43 <AStorm> Due to the depth-first when I stumble against a node already checked in this iteration... but what about the others? :P
19:16:13 <AStorm> I'd love to reuse the data w/o wasting tons of memory. Some kind of memoisation probably.
19:17:09 <deadbeef> > partition (mod 2 == 0) [1,2,3,4]
19:17:10 <lambdabot>    Expecting a function type, but found `Bool'
19:17:10 <lambdabot>    Expected type: a -> Bo...
19:18:16 <emu> ?doc Control.Concurrent.STM
19:18:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
19:18:21 <newsham> > partition (\x -> (x `mod` 2) == 0) [1,2,3,4]
19:18:22 <lambdabot>  ([2,4],[1,3])
19:18:33 <deadbeef> omg, the lambda notation!
19:19:04 <newsham> > partition ((== 0) . (`mod` 2)) [1,2,3,4]
19:19:05 <lambdabot>  ([2,4],[1,3])
19:19:22 <jgrimes> what would be the best reads on strictness analysis?
19:23:12 <deadbeef> > transpose [[1,2,3],[4,5]]
19:23:12 <lambdabot>  [[1,4],[2,5],[3]]
19:23:33 <foxy_> @type transpose
19:23:35 <lambdabot> forall a. [[a]] -> [[a]]
19:24:13 <foxy_> how long does ghc take to compile on a P4 1.8?
19:27:58 <stepcut> foxy_: hours probably
19:28:09 <foxy_> and is the GHC API documented anywhere (I don't see it in the library docs)
19:30:18 <newsham> http://www.haskell.org/ghc/documentation.html
19:30:19 <lambdabot> Title: The Glasgow Haskell Compiler
19:30:29 <dons> jgrimes: http://haskell.org/haskellwiki/Research_papers/Compilation#Strictness
19:30:32 <lambdabot> Title: Research papers/Compilation - HaskellWiki, http://tinyurl.com/zvujp
19:31:54 <stepcut> whats the advantage of lambdabot generating tinurls, btw?
19:32:42 <dons> easier to cut and paste? do you find them annoying?
19:32:42 <jgrimes> dons, thanks.
19:33:03 <dons> ?tiny-url http://www.google.com
19:33:05 <lambdabot> http://tinyurl.com/1c2
19:33:29 <foxy_> newsham: I'm talking about the API to ghc's innards, I don't see that in 'hierarchical libraries'
19:33:35 <dons> (they were introduced to solve a problem with long urls wrapping, and breaking pastes)
19:33:45 <stepcut> dons: I was just curious -- since I can click on url's in erc, that advantage was not obvious to me
19:34:01 <stepcut> ah, that problem I have had
19:34:02 <dons> oh, you can click eh?
19:34:42 <stepcut> yeah
19:34:49 <stepcut> there cheers for emacs :)
19:34:55 <stepcut> s/there/three/
19:35:20 <emu> do you use haskell-mode?
19:35:27 <stepcut> yes
19:35:31 <emu> which version?
19:36:03 <stepcut> haskell-mode 2.1-1 from debian
19:36:31 <emu> do you notice any peculiarities with its behavior?
19:37:08 <emu> (i'm trying to determine what and whether I should try to hack the elisp into a better form)
19:38:02 <stepcut> it definately has some bugs
19:38:49 <stepcut> though 2.1 is a lot better than 1.4
19:39:16 * stepcut tries to remember what bugs still happen
19:39:28 <emu> do if ...
19:39:40 <stepcut> yeah!
19:39:53 <emu> multiple arguments on separate lines
19:40:25 <stepcut> I'm so used to it sucking that I don't notice anymore :)
19:40:27 <emu> hm i need to start writing these down
19:40:44 <foxy_> dons, have you seen http://lambda-the-ultimate.org/node/1717 about build/fold fusion?
19:40:45 <stepcut> the 'do if...' one is definately at the top of my hit list though
19:40:45 <lambdabot> Title: Folds, Church Encodings, Builds, and Short Cut Fusion for Nested Types: A Princi ...
19:41:15 <clanehin> using 2.0, if it would just indent to any word-start on any previous line such that there is no intervening line of white space, that would make it easier to work with
19:41:18 <emu> do let... also but
19:41:24 <glguy> 78/* :-D 6 problems to go
19:41:27 <emu> i think you have to put that in parens regardless
19:41:31 <dons> foxy_: yeah I've seen that. interesting.
19:42:09 <chessguy> glguy, how long are the problems taking you now?
19:42:10 <glguy> (or 7 rather)
19:42:24 <glguy> chessguy: I've been getting a couple of them a day now
19:42:52 <chessguy> i mean how long do you spend on each
19:43:21 <glguy> Once I decide how to write the program... I usually only spend 10 or 20 minutes
19:43:37 <glguy> but I let them mull around in my head at work and whatnot
19:43:59 <glguy> I probably waste a lot of time trying to clean up the solution to post in the forum
19:47:52 <sm> hi all, what does this mean, when building hpodder on edgy: http://paste.lisp.org/display/25735
19:48:19 <dons> you've got some overlapping instances
19:48:31 <dons> is that with ghc 6.5?
19:48:51 <sm> no, 6.4.2
19:49:11 <dons> perhaps add -fallow-overlapping-instances ?
19:49:23 <dons> or ask the author what's the story.
19:49:39 <glguy> This problem really lets Haskell shine (especially among the solutions posted in the forum) http://mathschallenge.net/index.php?section=project&ref=problems&id=61
19:49:40 <sm> aha.. thanks
19:49:42 <lambdabot> http://tinyurl.com/fx2mk
19:50:05 <dons> gds :)
19:50:14 * dons reads planet.haskell.org
19:55:32 <glguy> Anyone got a good fast primes sieve?
19:56:39 <SamB> "fast" and "sieve"... in the same sentence?
19:57:20 <glguy> all it has to do is generate primes as fast as possible
19:57:24 <glguy> I don't care if it's a sieve
19:57:45 <chessguy> ooh, someone gave me a sieve yesterday
19:57:51 <chessguy> i don't know how fast it is
19:58:19 <chessguy> sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0]
19:58:19 <chessguy> primes = sieve [2..]
19:58:43 <chessguy> i think that came from Cale
19:59:22 <dons> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
19:59:26 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:00:02 <dons> what's the coolest new plugin lambdabot could have?
20:00:13 <dons> ideas anyone?
20:01:21 <chessguy> something related to chess? :)
20:01:27 <wkh> genetic programming to output code for a function given desired inputs and outputs
20:01:37 <dons> we used to have a chess plugin. not too irc friednly though
20:01:46 <dons> wkh, like @djinn? but smarter?
20:01:52 <wkh> i don't know what djinn is
20:02:00 <dons> ?djinn b -> (a -> b) -> Maybe a -> b
20:02:01 <lambdabot> f a b c =
20:02:01 <lambdabot>   case c of
20:02:01 <lambdabot>   Nothing -> a
20:02:01 <lambdabot>   Just d -> b d
20:02:22 <dons> the type specifies the inputs and outputs, the solver then finds a solution
20:02:36 <SamB> @. djinn type inits
20:02:37 <lambdabot> -- f cannot be realized.
20:02:45 <SamB> @type inits
20:02:45 <dons> ?djinn (a -> b -> c) -> b -> a -> c
20:02:46 <lambdabot> forall a. [a] -> [[a]]
20:02:46 <lambdabot> f a b c = a c b
20:02:51 <SamB> hmm
20:02:54 <dons> ?. pl djinn (a -> b -> c) -> b -> a -> c
20:02:54 <lambdabot> f = flip
20:03:16 <clanehin> I asked Integer -> Bool and it said f _ = False  :(
20:03:18 <dons> ?. pl . djinn type flip
20:03:19 <lambdabot> f = flip
20:03:30 <dons> clanehin: that's a valid function :)
20:03:31 <deadbeef> dons: what about something to output news from rss feeds
20:03:55 <dons> hmm. interesting. i've thought a bit about news, but it seems hard to do concisely
20:04:11 <dons> possibly we could _generate_ news feeds?
20:04:17 <SamB> clanehin: what were you wanting?
20:04:20 <SamB> dons: from what?
20:04:30 <dons> from events that happen here.
20:04:37 <SamB> what kind of event?
20:04:40 <dons> so when someone demos something, or announces it here.
20:04:54 <SamB> umm...
20:05:02 <SamB> demos, doable.
20:05:02 <dons> we could effectively aggregate the best-of-#haskell,  a bit like @remember/@quote
20:05:13 <SamB> announces? dunno.
20:05:33 <clanehin> SamB: well the first thing that came to my mind would be (< 0)
20:05:52 <SamB> clanehin: and here I would probably be thinking (== something)
20:06:00 <dons> clanehin: it uses the curry-howard isomophism. so you need to supply polymorphic functions to have anything reasonable generated
20:06:07 <dons> (a bit like the free theorems plugin)
20:06:12 <dons> ?free flip
20:06:13 <lambdabot> (forall x. f . k x = p (g x) . h) => f . flip k y = flip p (h y) . g
20:06:24 <dons> ?free ord
20:06:25 <lambdabot> ord = ord
20:06:34 <dons> nothing much interesting known about monomorphic types
20:06:40 <clanehin> I just imagine that it would pick randomly from some functions that map to the output type, and compose them
20:07:14 <dons> ah right. it doesn't try to do that. but that would be an interesting plugin for non-polymorphic things, yes
20:07:15 <clanehin> pretty useless feature (the way I describe it), but . . .
20:07:35 <dons> ?ft ord
20:07:36 <lambdabot>  t1 = t1
20:07:43 <dons> ?ft flip
20:07:44 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
20:07:44 <lambdabot>   forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
20:07:44 <lambdabot>    forall T5,T6 in TYPES. forall h3 :: T5 -> T6, h3 strict.
20:07:44 <lambdabot>     forall f1 :: T3 -> T5 -> T1.
20:07:44 <lambdabot>      forall g1 :: T4 -> T6 -> T2.
20:07:46 <lambdabot> [6 @more lines]
20:08:04 <dons> noisy :) i've asked the author for advice on making things more concise
20:08:20 <dons> such as having implicit top-level quantification, for starters
20:09:10 <dons> what about other ide features, or bot features you see in other channels?
20:10:03 <monochrom> I see in #math they can do highschool algebra :)
20:10:06 <clanehin> you could give lambdabot a bayesian filter to detect when SamB is talking about nethack and automatically direct him to #nethAck  :)
20:10:19 <monochrom> Haha that's cool
20:10:49 <clanehin> I'm pretty sure that would break a rule about irc bots though
20:11:07 <glguy> Haskell strikes again!
20:11:18 <SamB> clanehin: what do you mean?
20:11:33 <SamB> they have a bot in #python that whacks you whenever you say lol, iirc!
20:12:42 <clanehin> SamB: was that not you earlier?  I mean like a spam filter, but it detects words like "chest" "pet" "dragon" "floating eye"
20:13:23 <SamB> clanehin: yes! I was talking about nethack. I mentioned it.
20:13:32 * SamB stares at vixen's chest ;-P
20:13:52 <dons> hehe
20:13:52 <SamB> but, how is that against an IRC bot rule?
20:14:20 * SamB have expects vixen to send him flying ;-)
20:14:21 <dons> there are bot rules now?
20:14:23 <SamB> er, half...
20:14:28 <dons> ?vixen-on
20:14:28 <lambdabot> What's this channel about?
20:14:29 <SamB> dons: probably a few...
20:14:30 <lambdabot> Hahaha
20:14:33 <clanehin> IRC bots are not generally supposed to respond to chat unless explicitly asked, i.e. with >
20:14:34 <lambdabot> you are soooo interesting
20:14:37 <SamB> like, don't abuse the network!
20:14:37 <lambdabot> are you being sincere?
20:14:37 <glguy> a/s/l
20:14:38 <lambdabot> 19/f/California
20:15:04 <dons> ?vixen-off
20:15:04 <lambdabot> Bye!
20:15:19 <dons> clanehin: who made this rule?
20:15:29 <SamB> this is our channel. we make the rules!
20:15:38 <clanehin> dons: I read it somewhere, but it seems like common sense to me
20:15:46 <dons> (e.g. lambdabot supplies tiny urls and titles without prompting)
20:15:57 <dons> though perhaps http:// should be considered a prompt
20:16:03 <clanehin> dons: exactly
20:16:03 <monochrom> It is :)
20:16:06 <SamB> as long as we don't get pissed at ourselves, we will be fine ;-)
20:16:15 <glguy> I never did like me
20:16:15 <SamB> monochrom++
20:16:19 <stepcut> as long as we don't have *two* bots
20:16:24 <monochrom> In general, everything you say is a prompt.
20:16:25 <SamB> hmm...
20:16:37 <SamB> @karma monochrom
20:16:38 <lambdabot> monochrom has a karma of 6
20:16:40 <SamB> monochrom++
20:16:41 <monochrom> haha
20:16:42 <SamB> @karma monochrom
20:16:43 <lambdabot> monochrom has a karma of 7
20:16:53 <SamB> oh cool, stealth karma ;-)
20:16:58 <dons> yep
20:17:01 <dons> for #perl6
20:17:05 <Adamant> @karma @karma @karma @karma @karm chameleon
20:17:06 <lambdabot>  @karma has a karma of 0
20:17:08 <SamB> figured
20:17:09 <dons> didn't we talk about this?
20:17:15 <SamB> dunno!
20:17:23 <SamB> maybe I wasn't here when we discussed it ;-)
20:17:31 <dons> ok with you, though?
20:17:36 <SamB> yeah!
20:17:41 <SamB> I was considering it myself...
20:17:45 <dons> ok good
20:17:59 <SamB> maybe we did discuss it, I dunno
20:18:11 <dons> seems to me like we did, then i wrote the code
20:18:17 <dons> but maybe i just imagine that
20:18:36 <SamB> but I don't think it was a very long discussion
20:18:53 <SamB> anyway, however it came about, ;-)
20:19:12 <SamB> as long as your mindreading powers *WORK*
20:26:35 <newsham> is there a function for joining a string with a separator string?
20:26:42 <newsham> like unwords but not with spaces.
20:27:12 <emu> hm, i figured out how to fix the "if" problem
20:27:27 <emu> now the question: how much indentation?
20:27:27 <dolio> ?hoogle [[a]] -> a -> [a]
20:27:27 <lambdabot> No matches, try a more general search
20:27:39 <dons> > concat . intersperse ',' $ ["foo","bar","fum"]
20:27:40 <lambdabot>  Couldn't match `[a]' against `Char'
20:27:46 <dons> > concat . intersperse "," $ ["foo","bar","fum"]
20:27:47 <lambdabot>  "foo,bar,fum"
20:28:09 <dons> > concat . intersperse '!' $ "haskell"
20:28:10 <lambdabot>  Couldn't match `[a]' against `Char'
20:28:31 <newsham> > foldr1 (\w s -> w ++ ", " ++ s) ["this", "is", "a", "test"]
20:28:32 <lambdabot>  "this, is, a, test"
20:28:38 <newsham> like that, but precanned?
20:28:59 <dons> > concat . intersperse ", " $ ["foo","bar","fum"]
20:29:00 <lambdabot>  "foo, bar, fum"
20:29:17 <newsham> I dont see the benefit
20:29:25 <dons> well, intersperse is your function anyway
20:29:34 <dons> and people will understand what you're doing if you use it
20:29:43 <lennart> exactly
20:30:29 <dons> evening lennart
20:30:39 <newsham> so there isnt a function (concat . intersperse sep) ?
20:30:53 <lennart> no
20:30:59 <lennart> not a named one
20:31:04 <dons> newsham: there's some join-ish functions like that in external libraries (MissingH, for example)
20:31:22 <lennart> and you can always make your own
20:31:35 <lennart> dons: good, hmmm, morning?
20:31:37 <newsham> > let joinWords sep = concat . intersperse sep in joinWords ["foo","bar","fum"]
20:31:38 <lambdabot>  <[[[Char]]] -> [[Char]]>
20:31:44 <dons> @localtime dons
20:31:48 <lambdabot> Local time for dons is Sun Sep 10 13:31:23 2006
20:31:52 <dons> close :)
20:31:54 <newsham> > let joinWords sep = concat . intersperse sep in joinWords ", " ["foo","bar","fum"]
20:31:55 <lambdabot>  "foo, bar, fum"
20:32:11 <newsham> i'll use that, danke.
20:32:35 <stepcut> I have seen the name 'consperse' used -- as in, let consperse = concat . intersperse
20:32:57 <weitzma1> @localtime weitzman
20:33:11 <dons> ?localtime weitzma1
20:33:12 <weitzma1> That didn't work so well
20:33:18 <weitzma1> Oh
20:33:24 <weitzma1> Aha
20:33:26 <dons> some clients don't repond
20:33:29 <thetallguy> Which I collapsed to 'conspace = consperse " "'
20:33:37 <newsham> I have seen the word "join" used ;-)
20:34:00 <SamB> but...
20:34:02 <SamB> @type join
20:34:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:34:13 <stepcut> > unwords ["or","you","could","use","unwords?"]
20:34:14 <lambdabot>  "or you could use unwords?"
20:34:25 <monochrom> heh
20:34:38 <SamB> > join (words "or you could use unwords?")
20:34:39 <thetallguy> I could, but conspace was more fun
20:34:40 <lambdabot>  "oryoucoulduseunwords?"
20:34:45 <stepcut> :p
20:34:51 <SamB> see, join doesn't quite do what you want ;-)
20:34:59 <newsham> "like unwords but not with spaces."
20:35:04 <SamB> not *quite*
20:35:11 <monochrom> We consperse to make Haskell popular.
20:35:23 <thetallguy> lol
20:35:24 <newsham> samb:  print ", ".join(["foo", "bar", "blah"])    seems to work fine for me
20:35:25 <SamB> monochrom: I think you mean conspire
20:35:58 <SamB> @type print ", ".join(["foo", "bar", "blah"])
20:35:59 <lambdabot>   Expecting a function type, but found `IO ()'
20:35:59 <lambdabot>    Expected type: b -> c
20:36:04 <SamB> o rly?
20:36:09 <monochrom> "consperse" is our secret code for "conspire", shh :)
20:36:15 <newsham> (even curries properly, thanks to self-binding:    ", ".join)
20:36:51 <SamB> oh, actually that is Python isn't it?
20:36:54 <SamB> heh
20:37:03 <weitzman> Can lambdabot run quickCheck?
20:37:12 <newsham> >>> x = ", ".join
20:37:12 <newsham> >>> print x
20:37:12 <newsham> <built-in method join of str object at 0xf701d880>
20:37:12 <newsham> >>> x(["1", "2", "3"])
20:37:12 <newsham> '1, 2, 3'
20:37:21 <SamB> > quickCheck True
20:37:22 <lambdabot>  Not in scope: `quickCheck'
20:37:22 <dons> in channel, weitzman  ?
20:37:26 <newsham> the only time I get free currying in python :(
20:37:33 <SamB> > Debug.QuickCheck.quickCheck True
20:37:33 <lambdabot>  Not in scope: `Debug.QuickCheck.quickCheck'
20:37:43 <SamB> > Test.QuickCheck.quickCheck True
20:37:43 <lambdabot>  Not in scope: `Test.QuickCheck.quickCheck'
20:37:50 <SamB> hmm
20:37:51 <dons> might be useful, I suppose.
20:37:57 <dons> (its not available atm)
20:38:00 * SamB was expecting to get a type error
20:38:03 <SamB> or something like that
20:38:09 <weitzman> I can't say whether it'd be useful
20:38:09 <dons> ?type Test.QuickCheck.quickCheck True
20:38:10 <lambdabot> IO ()
20:38:13 <weitzman> But it might be neato
20:38:21 <dons> well, you couldn't run 'quickCheck'
20:38:32 <SamB> it should be easy to add quickChecking to runplugs, right?
20:38:55 <dons> we'd need a pure interface
20:39:01 <newsham> you mean the scripting interface?
20:39:07 <SamB> oh, would you?
20:39:14 <dons> ?type Test.QuickCheck.quickCheck
20:39:15 <lambdabot> forall a. (Test.QuickCheck.Testable a) => a -> IO ()
20:39:17 <newsham> you can jsut invoke quickCheck on properies manually, no need for script frontend
20:39:22 <SamB> dons: oh, true
20:39:38 <SamB> hey, no you wouldn't!
20:39:52 <SamB> doesn't runplugs already print the output on standard output?
20:40:07 <dons> it does. but we don't like users running code in IO
20:40:16 <SamB> yes.
20:40:35 <SamB> @instances-importing Test.QuickCheck Testable
20:40:35 <lambdabot> (), (a -> b), Bool, Property, Result
20:40:45 <SamB> I don't see a problem there!
20:41:29 <dons> so what do you want to do? specify a property, and then what?
20:41:33 <wkh> did you guys program in stuff for lambdabot to prevent people from executing arbitrary code?
20:41:49 <newsham> @hoogle intersperse
20:41:49 <lambdabot> List.intersperse :: a -> [a] -> [a]
20:41:52 <dons> wkh, try it :)
20:41:53 <SamB> well, you don't seem to have a problem with using "print" in runplugs...
20:42:16 <SamB> so why not make it so that it can invoke either "print" or "quickCheck"?
20:42:18 <dons> > print "as if"
20:42:18 <lambdabot>  No IO allowed
20:42:29 <SamB> no, no, no!
20:42:30 <dons> oh, you mean like a quickplugs wrapper?
20:42:34 <weitzman> @type  unsafePerformIO
20:42:35 <lambdabot> Not in scope: `unsafePerformIO'
20:42:39 <dons> that takes a property and tests it?
20:42:41 <SamB> well, I don't see as you would need a new wrapper
20:42:46 <dons> (rather than printing it)
20:42:53 <foxy_> @paste
20:42:53 <lambdabot> http://paste.lisp.org/new/haskell
20:42:56 <SamB> you could just parameterize runplugs
20:43:03 <dons> right.
20:43:11 <dons> ok. maybe this would be fun!
20:43:16 <SamB> and have @quickcheck and @run tell it different things...
20:43:24 <dons> more theorems to check
20:43:25 <dons> yep.
20:43:42 <dons> i'll add @check and a quickplugs binary (just so i don't break runplugs in the process)
20:43:55 <lisppaste2> foxy pasted "how to get this working for functions that take monadic arguments" at http://paste.lisp.org/display/25741
20:44:01 <dons> should be useful for introducing users to quickcheck
20:44:09 <foxy_> @seen bringert
20:44:09 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 2d 2h 46m 9s ago, and .
20:44:58 <dons> ?index quickCheck
20:44:58 <lambdabot> Test.QuickCheck, Debug.QuickCheck
20:45:14 <weitzman> @type observe
20:45:16 <lambdabot> Not in scope: `observe'
20:45:20 <foxy_> anyone able to help me fix my typeclass instance to work for monadic functions (see above paste)
20:46:50 <thetallguy> So, I've been thinking about JohnG's enounter with laziness in insertWith
20:47:23 <thetallguy> Data.Map.insertWith, that is.
20:47:40 <thetallguy> Instead of having foo and foo' for everything
20:49:15 <thetallguy> WOuld it make sense to define some data type to wrap a function in to say whether it's application should be strict or nor?
20:49:36 <clanehin> foxy: what is the code supposed to do?
20:50:55 <foxy_> clanehin: split arguments and pass them to more than one function
20:52:06 <foxy_> clanehin: but the functions are of Type foo = (IO NRef -> IO NRef), so fork :: foo -> foo -> foo takes an IO NRef, runs it and passes its results to the first two arguements of foo
20:52:32 <foxy_> s/guem/gum/
20:53:38 <lisppaste2> foxy_ annotated #25741 with "works without monads" at http://paste.lisp.org/display/25741#1
20:53:59 <foxy_> clanehin: I just pasted a version that works (without the monadic stuff)
20:55:19 <lispy> thetallguy: forcing beginners to think about the difference might be a con to that method right?
20:55:52 <thetallguy> Hmm...  They have to choose between insertWith and insertWith' right now.
20:56:31 <lispy> i didn't notice foldl' for at least a year
20:57:28 <thetallguy> Fair point.  But I think JohnG's example shows that people will run into strictness issues rather quickly when doing production programming.
20:57:44 <lispy> that's true
20:57:52 <lispy> that's when you tend to hit it
20:57:53 <dons> luckily most are much easier to fix than insertWith was
20:58:13 <dons> (i.e. a deft application of ! or $! is often enough)
20:58:19 <dons> (and will be easier now with bang patterns)
20:58:25 <thetallguy> Well, that's what i was looking for.
20:58:34 <thetallguy> Something like
20:58:58 <thetallguy> insertWith ($!) or insertWith ($)
20:59:15 <dons> yep
20:59:24 <thetallguy> Something more functional.
20:59:56 <thetallguy> I was also trying to come up with an interesting example of using Data.Map with infinite lists as the values
21:00:01 <stepcut> http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns
21:00:04 <lambdabot> Title: BangPatterns - Haskell Prime - Trac, http://tinyurl.com/r6cvf
21:00:15 <thetallguy> to demonstrate that one still wanted the lazy option.
21:00:38 <stepcut> those look neat -- though they don't appear to offer any new functionality -- just prettier code (?)
21:00:45 <dons> yep
21:00:49 <dons> f !x !y = ....
21:01:03 <dons> rather than f x y | x `seq` y `seq` False = undefined | .... :)
21:01:34 <dons> they're in ghc 6.5 now
21:01:57 <stepcut> so, are bang patterns also insufficient to fix the insertWith space leak ?
21:02:34 <dons> i think so, yes.
21:02:37 <clanehin> foxy: so right now it seems like the instance of Forkable for IO NRef is wanting to have an output type of IO (IO Nref)
21:02:39 <dons> since it couldn't be done with seq either
21:03:35 <stepcut> dons: ok, that was my assumption -- I haven't actually got around to using 6.5 yet
21:03:48 <clanehin> I'm still trying to grok how this should work
21:04:13 <thetallguy> To fix it in insertWith, the users function would have to be applied with either $ or $! inside insertWith, right?
21:04:32 <lispy> it couldn't even be done by a function which wraps insertWith?
21:04:35 <lispy> why is that?
21:05:12 <thetallguy> The problem was adding one to the value bound to a key
21:05:32 <thetallguy> all you can do is pass in a function which insertWith applies
21:05:53 <lispy> oh i think i see
21:06:19 <lispy> and if that part is done lazily then seq can't help
21:06:32 <lispy> but what if you demand that element right away with evaluate?
21:06:46 <thetallguy> Then you double your work.
21:06:47 <stepcut> you could possibly do a deepseq over the Map after every insert to force the thunks -- but that would be terrible :)
21:07:06 <thetallguy> insert into the map does a log n search
21:07:19 <lispy> hmm...
21:07:28 <thetallguy> and it's efficiency comes from amortization
21:07:53 <dfranke> Data.Set is awesome... finally a language where I don't have to rewrite that library.
21:08:03 <thetallguy> :-D
21:08:12 <thetallguy> That's what I tell people about Haskell
21:08:36 <thetallguy> It's the first language where I can implement things and end up not wanting to rewrite it somehow.
21:08:52 <emu> ?doc Data.Set
21:08:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
21:09:25 <clanehin> well for a second what I said above made sense to me, and now I can imagine writing something similar from scratch but I don't see how to fix what's there -- Forkable more combines things than forks them apart
21:09:33 <dfranke> thetallguy: what's the antecedent to "it" in that sentence?
21:09:35 <foxy_> clanehin: Instance Forkable (IO NRef) works, (return type IO NRef)
21:09:39 <thetallguy> data MaybeStrict f = Strict f | Lazy f
21:09:59 <thetallguy> dfranke: Haskell is the first language...
21:10:04 <foxy_> clanehin, yeah, Joinable would be a better word
21:10:29 <thetallguy> dfranke: oh, you meant the second 'if'?
21:10:38 <newsham> @hoogle AssocLeft
21:10:39 <lambdabot> Text.ParserCombinators.Parsec.Expr.AssocLeft :: Assoc
21:10:39 <lambdabot> Language.Haskell.Syntax.HsAssocLeft :: HsAssoc
21:11:47 <dfranke> thetallguy: "not wanting to rewrite _it_ somehow"
21:12:13 <thetallguy> dfranke: anytime I write a library, there's always some ugliness, some choice you have to make that is suboptimal for one purpose or another
21:12:29 <dfranke> thetallguy: ah, ok.
21:12:38 <weitzman> Ah, lambdabot went away
21:12:43 <weitzman> We were having a lovely conversation
21:12:50 <thetallguy> dfranke: so ``it'' refers to the code that I just wrote.
21:12:58 <weitzman> Hooray
21:13:18 <thetallguy> ?doc Data.Map
21:13:37 <dons> weitzman: did you break it somehow?
21:13:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
21:13:47 <weitzman> Umm
21:13:49 <weitzman> Maybe?...
21:13:57 <weitzman> (00:11:35) weitzman: > iterate (+ 1) 0 !! 100
21:13:57 <weitzman> (00:11:37) lambdabot:  100
21:13:57 <weitzman> (00:11:48) weitzman: > repeat 3
21:13:57 <weitzman> (00:12:03) weitzman: > repeat 3 !! 110
21:13:57 <weitzman> (00:12:03) User is not logged in
21:14:11 <dons> > repeat 3
21:14:16 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
21:14:20 <weitzman> Worked
21:14:22 <weitzman> Hmm
21:14:26 <dons> > repeat 3 !! 110
21:14:30 <lambdabot>  3
21:14:40 <dons> lambdabot: out of memory (requested 7340032 bytes)
21:14:47 <dfranke> weitzman: data Maybe a = Nothing | Just a.
21:14:47 <weitzman> Aha
21:15:02 <dons> probably the patch i was just experimeneting with
21:15:57 <weitzman> I don't want to download haskell over the wireless net and I can't connect to through the wall yet
21:16:01 <weitzman> So me and lambdabot are talking
21:16:06 <dons> that's ok :)
21:16:25 <dons> its my fault for putting up a dodgy patch
21:17:15 <emu> haskell on air?
21:17:33 <dons> ?quit undo patch
21:18:49 <emu> anyone interested in testing out my changes to haskell-mode identation?
21:19:12 <dons> > repeat 3
21:19:22 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
21:19:24 <stepcut> emu: i will be eventually, but not tonight
21:19:41 <thetallguy> ?type ($!)
21:19:43 <lambdabot> forall b a. (a -> b) -> a -> b
21:20:35 <thetallguy> emu: what did you change?
21:21:09 <emu> very little actually; i just adjusted the indentation pre- certain keywords and a little indentation post keywords
21:22:51 <dfranke> I'd really like a haskell-mode that gives some minimal LaTeX support without involving mmm-mode kludges.
21:23:05 <thetallguy> emu: send it along
21:23:12 <dfranke> doesn't have to be as nice as auctex
21:23:25 <thetallguy> I'm going to spend a few hours hacking either tonight or tomorrow morning
21:24:33 <dfranke> just let my shortcut keys work without having to reposition the point first.
21:24:44 <emu> lisppaste2: url
21:24:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:25:06 <lisppaste2> emu pasted "diff to haskell-mode 2.1" at http://paste.lisp.org/display/25743
21:28:44 <lisppaste2> clanehin pasted "am I anything close to foxy's problem?" at http://paste.lisp.org/display/25744
21:28:56 <lisppaste2> emu annotated #25743 with "example" at http://paste.lisp.org/display/25743#1
21:29:39 <lispy> hmm...nondet on haskell-cafe is interesting
21:29:45 <thetallguy> Okay, got to update from 1.45 first.
21:32:55 <foxy_> clanehin: OK, that works, but then how do you make Instance Joinable (IO a -> IO a) etc...
21:35:41 <lisppaste2> foxy annotated #25744 with "this is where the problem lies" at http://paste.lisp.org/display/25744#1
21:35:57 <weitzman> Is there a paper somewhere that will make it clear why the list monad does concat and map?
21:36:58 <dons> check the Mark Jone's paper on monads on the haskell.org 'research papers/monads' section
21:37:09 <weitzman> Thanks
21:41:01 <lispy> weitzman: can kinda help you see it
21:41:13 <lispy> ?type (>>=)
21:41:15 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:41:30 <lispy> weitzman: now let's simplify that for the list monad
21:41:48 <lispy> (>>=) :: [a] -> (a -> [b]) -> [b]
21:42:03 <weitzman> Ah
21:42:10 <weitzman> Well, I guess there's only a few reasonable things to do
21:42:17 <lispy> yup
21:42:31 <lispy> (a -> [b]) means we need a concat right?
21:42:34 <thetallguy> Weitzman, there was also a web article recently that explained the list monad well.
21:42:46 <lispy> and [a] -> (a -> [b]) means we'll need to map the function to the list [a] :)
21:42:51 <weitzman> Either concat or throwing away data
21:42:55 <weitzman> Which probably breaks some monad law
21:42:57 <thetallguy> stepcut: do you still ahve that reference?
21:43:00 <lispy> weitzman: exactly
21:43:20 <lispy> ?free foo :: [a] -> (a -> [b]) -> [b]
21:43:21 <lambdabot> $map g . h = k . f => $map g (foo xs h) = foo ($map f xs) k
21:44:19 <lispy> ?type concatMap
21:44:20 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
21:44:28 <lispy> ?type flip concatMap
21:44:30 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
21:44:35 <lispy> yay, and now we have bind
21:45:00 <clanehin> foxy_: is there a practical goal to this?
21:49:24 <lisppaste2> clanehin annotated #25744 with "additional solution to join functions" at http://paste.lisp.org/display/25744#2
21:49:40 <foxy_> clanehin: yes, implementing "and" in my NLP program
21:53:24 <foxy_> clanehin: the problem is that in a function of type join ::  (IO NRef -> IO NRef) -> (IO NRef -> IO NRef) -> (IO NRef -> IO NRef), the last argument has to be evaluated and /then/ passed to the first two functions, so I don't think liftM2 will do the trick
21:56:12 <vincenz> > repeat 3 !! 120
21:56:13 <lambdabot>  3
21:56:15 <vincenz> > repeat 3 !! 120
21:56:16 <lambdabot>  3
21:56:19 <vincenz> > repeat 3 !! 1200
21:56:20 <lambdabot>  3
21:56:24 <vincenz> > repeat 3 !! 12000
21:56:25 <lambdabot>  3
21:56:30 <vincenz> pretty fast
21:56:34 <vincenz> > repeat 3 !! 1000000
21:56:35 <lambdabot>  3
21:56:39 <vincenz> > repeat 3 !! 100000000
21:56:42 <lambdabot>  3
21:56:44 * vincenz whistles
21:56:56 <weitzman> > last (repeat 3)
21:56:58 <vincenz> > repeat 3 !! 1000000000
21:57:00 <lambdabot> Terminated
21:57:03 <lambdabot> Terminated
21:57:05 <vincenz> > repeat 3 !! 1000000000
21:57:09 <lambdabot> Terminated
21:57:19 <clanehin> foxy: oops, I see the problem
21:59:53 <clanehin> if you evaluate it first, then you would have a -> IO a, which is not IO a -> IO a
22:00:04 <clanehin> unless you used return, nm
22:00:13 <foxy_> clanehin, but it gets passed as |return a|
22:00:16 <foxy_> :)
22:06:47 <lisppaste2> clanehin annotated #25744 with "another attempt" at http://paste.lisp.org/display/25744#3
22:07:06 <clanehin> I think that's going to be my last try.
22:10:56 <foxy_> clanehin++, thanks for the help :)
22:11:40 <clanehin> it was interesting
22:13:39 <Pupeno> Is Distribution.GetOpt the best of its kind or is there anything better ?
22:14:01 <dons> ?hoogle getOpt
22:14:02 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
22:14:02 <lambdabot> Distribution.GetOpt :: module
22:14:02 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
22:14:29 <dons> I use System.Console.GetOpt usually
22:15:18 <Pupeno> dons: that's not on Hoogle.
22:16:17 <dons> ?hoogle+
22:16:21 <gour> dons: d'morning. have you see yesterday's message regarding lambdabot & haskell-src ?
22:16:34 <gour> s/see/seen
22:16:40 <dons> I did. Seems odd. Why don't I get any errors?
22:18:13 <foxy_> dons: it's been a bad week for .au, sting-rays, cars, and SA! :D
22:18:24 <foxy_> s/:D/:(/
22:18:29 <dons> :(
22:18:58 <dons> what was it, 24-16 ?
22:18:59 <dons> boo
22:19:12 <foxy_> yeah, I just caught the end of the replay
22:19:20 * dons decides to watch aussie rules from now on
22:19:30 <foxy_> heh
22:19:42 <dons> ?quit new plugin
22:20:20 <gour> dons: Language.Haskell.Hsx.ParseUtils is under 'Other-modules', not 'Exposed-modules'. which cabal you use?
22:20:21 <dons> ?version
22:20:30 <dons> gour: oh hang on. Hsx??
22:20:48 <lambdabot> lambdabot 4p165, GHC 6.5 (OpenBSD i386 )
22:20:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:21:09 <dons> gour: where's this Hsx import?
22:21:14 <dons> new plugin!
22:21:18 <dons> ?check True
22:21:19 <lambdabot>  OK, passed 100 tests.
22:21:32 <gour> dons: this is in haskell-src-exts cabal
22:21:51 <dons> ?check \s -> minimum (s :: [Int]) == head (sort s)
22:21:52 <lambdabot>  Exception: Prelude.minimum: empty list
22:22:12 <dons> ?check \s -> null s || minimum (s :: [Int]) == head (sort s)
22:22:13 <lambdabot>  OK, passed 100 tests.
22:22:24 <dons> ?check \s -> null s || minimum (s :: [Int]) == last (sort s)
22:22:25 <lambdabot>  Falsifiable, after 4 tests:
22:22:49 <dons> gour, no I mean. I didn't think any of my projects used Hsx anymore.
22:23:05 <dons> can you point me to a module that uses it? (lambdabot doesn't afaik)
22:23:18 <dons> I do see: import Language.Haskell.ParseUtils
22:23:22 <dons> but that's not hsx.
22:24:19 <dfranke> is there a Haskell library that provides cross-platform persistent configuration?  e.g., uses the registry when running on 'doze and a configuration file in your home directory when running on POSIX?
22:24:26 <gour> dons: Parser.hs #22
22:24:45 <dons> gour, right import Language.Haskell.ParseUtils
22:24:53 <dons> that's not hsx though.
22:24:55 <gour> dons: but haskell-src-exts package exports hsx
22:25:14 <dons> we use haskell-src don't we?
22:25:18 <dons> not haskell-src-exts
22:26:01 <gour> dons: i'll check again, but kolmoding gets the same error
22:26:08 <gour> err. kolmodin
22:26:14 <Pupeno> any ideas why tab doesn't indent but insert spaces untill the next tabstop in Haskell mode ?
22:26:57 <dons> because tabs are evil in haskell?
22:27:02 <dons> since they mess with layout
22:27:46 <Pupeno> dons: by tab I meant hitting the tab key... isn't it supoused to iterate thru the possible indents for the current line ?
22:28:02 <dons> oh .ok.
22:28:43 <Pupeno> but it is just inserting whitespaces up to the next tabstop... something is not working.
22:28:51 <dons> ?check \s -> not (null s) ==> minimum (s :: [Int]) == last (sort s)
22:28:51 <lambdabot>  Not in scope: `==>'
22:29:06 <foxy_> how does one make the extra libraries in the snapshots of ghc-6.5 ?
22:29:46 <foxy_> ignore me
22:32:04 <gour> dons: haskell-src.cabal does not expose Language.Haskell.ParseUtils (#23), it's under 'other-modules' and you're importing it
22:32:22 <dons> right.
22:32:31 <dons> so then, why don't I see an error, but you guys have?
22:33:38 <gour> dons: which cabal?
22:33:45 <dons> 6.6
22:34:01 <dons> I should probably just push my expr parser back into Language.Haskell
22:34:33 <dons> ?quit improve @quit
22:34:34 <gour> cabal-1.1.5.9.2  & ghc-20060907 here
22:34:44 <dons> hmm
22:34:54 <dons> ok, i'll look into this
22:34:59 <gour> dons: thanks
22:35:00 <dons> gour++ thanks for the research
22:35:12 <dons> ?version
22:35:35 <lispy> ?version
22:35:39 <lambdabot> lambdabot 4p165, GHC 6.5 (OpenBSD i386 )
22:35:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:35:50 <dons> ?check \s -> not (null s) ==> minimum s == head (sort (s :: [Int]))
22:36:03 <lispy> oh, a quickcheck module?
22:36:03 <lambdabot> lambdabot 4p165, GHC 6.5 (OpenBSD i386 )
22:36:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:36:09 <dons> yep
22:36:11 <lambdabot>  OK, passed 100 tests.
22:36:20 <dons> ?check False
22:36:21 <lambdabot>  Falsifiable, after 0 tests:
22:36:40 <dons> ?check \s -> not (null s) ==> minimum s == last (sort (s :: [Int]))
22:36:40 <lispy> neato
22:36:41 <lambdabot>  Falsifiable, after 2 tests:
22:36:41 <lambdabot> [-3,2,-3]
22:36:49 <Pupeno> is there any option of haskell-mode that is know to more or less work with 22.0 ?
22:37:04 <lispy> dons: did you use any of my TH hackery for quickcheck?
22:37:12 <dons> nope :)
22:37:58 <dons> ?docs Test.QuickCheck
22:37:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
22:38:28 <lispy> ?check \s -> s == (reverse (reverse (s  :: [Int])))
22:38:29 <lambdabot>  OK, passed 100 tests.
22:39:03 <lispy> ?check [1..] == [1..]
22:39:07 <lambdabot> Terminated
22:39:08 <dons> ?check reverse . reverse == id :: [Int] -> [Int]
22:39:09 <lambdabot>    Expecting a function type, but found `Bool'
22:39:09 <lambdabot>    Expected type: [Int] -...
22:39:36 <dons> ?check \s -> (reverse . reverse) s == (id s) where t = s :: [Int]
22:39:36 <lambdabot>  Parse error
22:39:42 <dons> argh no 'where' :)
22:40:06 <dons> ?check 1/0 == 1/0
22:40:07 <lambdabot>  OK, passed 100 tests.
22:40:13 <dons> > 1/0 == 1/0
22:40:13 <lambdabot>  True
22:40:19 <weitzman> > 1/0
22:40:20 <lispy> ? check 0/0 /= 0/0
22:40:20 <dons> > 1/0
22:40:20 <lambdabot>  Infinity
22:40:21 <lambdabot>  Infinity
22:40:25 <lispy> ?check 0/0 /= 0/0
22:40:26 <lambdabot>  OK, passed 100 tests.
22:41:45 <dons> I wonder if i can have a useful default instance to [Int]
22:41:57 <dons> i'd need -fextended-defaulting, I think
22:43:28 <lispy> well, fwiw I've created quite a few quickcheck propertyes now and almost every one uses [Int] or a custom instance of arbitrary
22:43:46 <lispy> so i think it sounds quite reasonable
22:43:51 <weitzman> QuickCheck seems to have very conservative random number generation
22:43:54 <weitzman> @check (\x -> x < 100) :: Int -> Bool
22:43:55 <lambdabot>  OK, passed 100 tests.
22:45:28 <lispy> @check (\x -> -100 < x && x < 100) :: Int -> Bool
22:45:29 <lambdabot>  OK, passed 100 tests.
22:45:35 <dons> ?check (\x -> x < 1) :: Int -> Bool
22:45:37 <lambdabot>  Falsifiable, after 1 tests:
22:45:37 <lambdabot> 1
22:46:05 <dons> ?check (\x -> x < 16) :: Word8 -> Bool
22:46:06 <lambdabot>  Falsifiable, after 0 tests:
22:46:06 <lambdabot> 195
22:46:15 <dons> ?check (\x -> x < 256) :: Word8 -> Bool
22:46:16 <lambdabot>  Falsifiable, after 0 tests:
22:46:16 <lambdabot> 185
22:47:03 <weitzman> > 185 < (256 :: Word8)
22:47:04 <lambdabot>  False
22:47:13 <dons> ah :)
22:47:26 <dons> ?check (\x -> x < (maxBound ::Word8)) :: Word8 -> Bool
22:47:27 <lambdabot>  OK, passed 100 tests.
22:47:32 <dons> good :)
22:47:48 <lispy> oh
22:47:55 <lispy> > 256 :: Word8
22:47:56 <dons> since its compiled, I might be able to increase the number of tests run
22:47:56 <lambdabot>  0
22:48:13 <weitzman> > 257 :: Word8
22:48:14 <lambdabot>  1
22:49:33 <weitzman> @type (1 :: Word16) + (2 :: Word8)
22:49:34 <lambdabot>   Couldn't match `Word16' against `Word8'
22:49:34 <lambdabot>    Expected type: Word16
22:49:40 <lispy> dons: were you able to implement the termination checker in lambdabot yet?
22:49:51 <weitzman> > (1 :: Word16) < (2 :: Word8)
22:49:52 <lambdabot>  Couldn't match `Word16' against `Word8'
22:49:54 <dons> nope, looks too hard to talk to
22:50:15 <lispy> dons: what about talking to the html version?
22:50:25 <lispy> use it like a webservice?
22:50:40 <dons> i thought it seemed too verbose to deal with easily
22:50:54 <lispy> hmm...yeah it is very verbose
22:52:19 <lispy> it's too bad these those sorts of programs are usually limited to H98 because the programs i usually want to use them usually use extensions :)
22:52:24 <lispy> eg., darcs
22:52:46 <glguy> has anyone here built and installed HaXml and know if it's ok to simply run ./setup configure, build, install
22:53:17 <dons> bring on Haskell'
22:53:23 <lispy> glguy: i installed it in windows but i don't remember what i did...if it has .cabal then that should be enough
22:53:46 <glguy> (I ask because I started the ./setup build procedure and then went on to read the install instructions and it shows ./configure and make)
22:57:13 <Pupeno> is there any particularly good definition of options, arguments, parameters, format parameters, etc ?
22:57:25 <dons> ?free sortBy
22:57:26 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
22:59:06 <dons> ?check \g h f x y -> g x == h (f x) . f) ==> (map f . sortBy g) y == (sortBy h . map f) (y :: [Int])
22:59:07 <lambdabot>  Parse error
22:59:21 <dons> ?check \g h f x y -> (g x == h (f x) . f) ==> (map f . sortBy g) y == (sortBy h . map f) (y :: [Int])
22:59:22 <lambdabot>  add an instance declaration for (Arbitrary Ordering)
22:59:22 <lambdabot>   In the definition ...
22:59:27 <dons> ah
22:59:55 <dolio> ?pl \f g x y -> f (g x) (g y)
22:59:55 <lambdabot> join . ((flip . ((.) .)) .) . (.)
23:00:11 <dolio> ?pl \f g h x y -> f (g x) (h y)
23:00:11 <lambdabot> ((flip . ((.) .)) .) . (.)
23:00:14 <lispy> dons: so, Pseudonym tells me that unless the function is _|
23:00:29 <lispy> _|_ in disgues that it should be true just from the type signature
23:00:49 <lispy> s/disgues/disguise
23:01:28 <lispy> ?freemap
23:01:28 <lambdabot> Unknown command, try @list
23:01:30 <lispy> ?free map
23:01:32 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
23:02:14 <lispy> ?check \f h k g -> (f . h == k.g) ==> map f . map h == map k . map g
23:02:14 <lambdabot>  add an instance declaration for (Eq ([a] -> [c]))
23:02:23 <dons> that's right. it should be true just from the type
23:02:35 <dons> (if its polymorphic)
23:02:42 <emu> ?doc Data.set
23:02:42 <lambdabot> Data.set not available
23:02:44 <emu> ?doc Data.Set
23:02:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
23:03:25 <dons> ?check \g h f x y -> (g x == h (f x) . f) ==> (map f . sortBy g) y == (sortBy h . map f) (y :: [Int])
23:03:26 <lambdabot>  add an instance declaration for (Eq (Int -> Ordering))
23:03:49 <dons> ?check \g h f x y -> (g x y == h (f x) . f $ y) ==> (map f . sortBy g) y == (sortBy h . map f) (y :: [Int])
23:03:49 <lambdabot>    Expecting a function type, but found `Bool'
23:03:49 <lambdabot>    Expected type: a -> b
23:04:38 <dons> ?check \g h f x y -> ((g x y) == (h (f x) . f) y) ==> (map f . sortBy g) y == (sortBy h . map f) (y :: [Int])
23:04:39 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
23:04:39 <lambdabot>    Expected...
23:04:39 <lispy> ?check \f h k g -> (f . h == k . g) ==> map (f::Int->Int) . map (h::Int->Int) == map (k::Int->Int) . map (g::Int->Int)
23:04:40 <lambdabot>  add an instance declaration for (Eq ([Int] -> [Int]))
23:04:48 <dons> ?free id
23:04:49 <lambdabot> f . id = id . f
23:05:13 <dons> ?check \s -> f . id $ s == id . f $(s :: [Int])
23:05:13 <lambdabot>  Not in scope: `f'
23:05:19 <dons> ?check \f s -> f . id $ s == id . f $(s :: [Int])
23:05:20 <lambdabot>    Expecting a function type, but found `Bool'
23:05:20 <lambdabot>    Expected type: a -> b
23:05:39 <dons> ?check \f s -> (f . id) s == (id . f) (s :: [Int])
23:05:40 <lambdabot>  Add a type signature
23:05:54 <dons> ?check \f s -> ((f :: [Int] -> [Int]) . id) s == (id . f) (s :: [Int])
23:05:55 <lambdabot>  OK, passed 100 tests.
23:06:12 <lispy> nice!
23:06:31 <dons> lets see if I can turn on some defaulting
23:07:27 <lispy> > (\(x::Int) -> x + 1) 1
23:07:28 <lambdabot>  Parse error in pattern
23:07:43 <lispy> i wish that was valid syntax
23:07:53 <lispy> it would make this sort of stuff easier :)
23:07:58 <emu> rofl mathschallenge: you cannot submit more than 3 answers in one minute
23:08:03 <emu> what if they're easy?
23:08:08 <foxy_> dons, I get an error when compiling hs-plugins with ghc-6.5 in AltData.Typeable (the INSTANCETYPEABLE macros don't parse)
23:08:08 <dons> heh
23:08:28 <dons> yep. foxy_ you need to add  -I/home/dons/l
23:08:33 <lispy> ?check \f h k g -> (f . h == k . g) ==> map (f::Int->Int) . map (h::Int->Int) == map (k::Int->Int) . map (g::Int->Int)
23:08:33 <lambdabot>  add an instance declaration for (Eq ([Int] -> [Int]))
23:08:34 <dons> ib/ghc-6.4.2/include/ to ghc-options in the .cabal file
23:08:45 <dons> foxy_: and includes:             Linker.h Typeable.h
23:08:47 <foxy_> ok
23:08:58 <dons> assuming your ghc 6.4.2 lives in /home/dons :)
23:09:02 <foxy_> :)
23:09:21 <lispy> ?check \f h k g s -> (f (h (s::Int)) == (k (g s))) ==> map (f::Int->Int) . map (h::Int->Int) == map (k::Int->Int) . map (g::Int->Int)
23:09:22 <lambdabot>  add an instance declaration for (Eq ([Int] -> [Int]))
23:09:49 <Pupeno> ok, good night!
23:09:51 <dons> so something's not fully applied
23:10:03 <dons> map g, for example
23:10:39 <thetallguy> emu: tried your haskell-mode patch
23:10:51 <lispy> yeah, so i'm wondering how to specify (f . h == k . g) without map on some input list that will get fed to map g
23:11:04 <thetallguy> I didn't notice any significant difference.
23:11:38 <thetallguy> Tried the example you added to the paste and it seemed to format identically with or without your patch
23:11:54 <thetallguy> which seemed to imply that perhaps I didn't get it applied correctly.
23:12:20 <lispy> ?check \f h k g s -> (map (f . h) (s::[Int]) == map (k . g) s) ==> (map (f::Int->Int) . map (h::Int->Int)) s == (map (k::Int->Int) . map (g::Int->Int)) s
23:12:21 <lambdabot>  OK, passed 100 tests.
23:12:43 <dons> lispy++
23:12:58 <foxy_> dons, where does the ghc API interface live?
23:13:17 <dons> it comes with ghc snapshots (its build in the ghc/compiler/ subdir)
23:13:49 <lispy> ?type (.)
23:13:50 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
23:14:07 <lispy> ?free compose :: (forall c a b. (b -> c) -> (a -> b) -> a -> c)
23:14:07 <lambdabot> f . k = p . h => h . q = f1 . g => f . compose k q = compose p f1 . g
23:14:53 <lispy> so that says: f . k == p . h ==> h . q == f1 . g ==> f . (k . q) == (p . f1) . g
23:15:27 <lispy> i wonder if we can use that to rewrite the theorem for map into some more complex statement :)
23:17:24 <lispy> ?check \f h k g s -> (map (f . h) (s::[Int]) == map (k . g) s) ==> (map f . map h) s == (map k . map g) s
23:17:24 <lambdabot>  Add a type signature
23:19:19 <lispy> ?check \f k p h q f1 g s -> ((f . k) (s::Int) == (p . h) s && ((h . q) s == (f1 . g) s)) ==> (f . (k . q)) s == ((p . f1) . g) s
23:19:20 <lambdabot>  Add a type signature
23:19:52 <emu> are there weird consequences of using a list comprehension based on an infinite list
23:20:34 <emu> > [ x | x <- [1..], x < 10 ]
23:20:38 <lambdabot> Terminated
23:23:33 <emu> oh nvm, it must be trying to apply x < 10 to every integer
23:24:39 <lispy> > take 4 [x | x <- [1..], x < 10 ]
23:24:40 <lambdabot>  [1,2,3,4]
23:26:34 <dons> > 1 :: T
23:26:35 <lambdabot>  add an instance declaration for (Num T)
23:26:35 <lambdabot>   In the expression: 1 :: T
23:26:35 <lambdabot>   I...
23:26:41 <dons> > [1] :: T
23:26:42 <lambdabot>  [1]
23:26:57 <lispy> huh?
23:27:10 <dons> ?check \f h k g s -> (map (f . h) (s::T) == map (k . g) s) ==> (map (f::Int->Int) . map (h::Int->Int)) s == (map (k::Int->Int) . map (g::Int->Int)) s
23:27:11 <lambdabot>  OK, passed 100 tests.
23:27:12 <lispy> dons: what did you just do :)
23:27:20 <dons> type T = [Int]
23:27:26 <dons> (couldn't get defaulting to work)
23:27:31 <lispy> hmm..
23:27:44 <lispy> ah
23:27:46 <lispy> i see  it now
23:28:02 <dons> and maybe type I = Int, not sure
23:28:35 <dfranke> alright... I'm looking for a Haskell equivalent to something comparable to Java's java.util.prefs: a platform-independent way of storing hierarchial configuration data.  Any recommendations?
23:28:45 <dons> yes, read/show
23:28:48 <dons> ?type read
23:28:50 <lambdabot> forall a. (Read a) => String -> a
23:28:53 <dons> ?type show
23:28:54 <lambdabot> forall a. (Show a) => a -> String
23:29:08 <dons> write a data type for your configuration value, using records
23:29:20 <dons> and dump it into a file using hPutStr file . show
23:29:32 <lispy> dons: that's too easy....
23:29:33 <audreyt> I wonder if there's a way to derive a Read that ignores missing record keys.
23:29:35 <dons> read it back in with read . hGetContents f
23:29:56 <dons> fancier would be to use a custom parser, or the Binary class, to store it as compressed binary data
23:29:59 <dons> (hmp3 does this)
23:30:03 <dfranke> dons, what I'm looking for is a wrapper around platforms' native backend.  E.g., registry in Windows, Info.plist in OS X, GConf in UNIX.
23:30:27 <dons> you're on your own then. there's no such library, afaik. at least not in haskell
23:30:33 <dons> if there's a C lib, you could bind to that instead
23:30:44 <dons> GConf is native?
23:30:49 <audreyt> or you can invoke a java helper..
23:31:19 <dfranke> yeah, I'm half-tempted to just use GCJNI.
23:31:33 <dfranke> seems a little ridiculous.
23:32:04 <audreyt> why would a app-specific file in the app dir be unaccpetable ?
23:32:22 <audreyt> I understand the desire for native system integration, but e.g. CLR applications usually ignore those.
23:32:24 <lispy> i've used this java properties and i was not impressed...what do they do that works so good?
23:33:14 <dfranke> lispy: they just abstract away all OS details so I don't have to worry about the right place to store the file.
23:33:41 <emu> > take 10 [ x | x <- [1..], x < 10 ]
23:33:44 <lambdabot> Terminated
23:34:03 <emu> oh right
23:34:18 <audreyt> > take 10 [ x | x <- [0..], x < 10 ]
23:34:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
23:34:22 <emu> > take 9 [ x | x <- [1..], x < 10 ]
23:34:23 <lambdabot>  [1,2,3,4,5,6,7,8,9]
23:34:56 <emu> better to leave out the <
23:36:33 <emu> > takeWhile (<10) [ x | x <- [1..], x `rem` 2 == 0 ]
23:36:34 <lambdabot>  [2,4,6,8]
23:45:18 <lispy> > filter (< 10) [1..]
23:45:22 <lambdabot> Terminated
23:45:55 <emu> > takeWhile (<10) [1..]
23:45:56 <lambdabot>  [1,2,3,4,5,6,7,8,9]
23:46:40 <glguy> ?type rem
23:46:41 <lambdabot> forall a. (Integral a) => a -> a -> a
23:46:42 <glguy> ?type mod
23:46:43 <lambdabot> forall a. (Integral a) => a -> a -> a
23:46:58 <glguy> synonyms?
23:49:24 <dolio> I thought there was a difference between quotRem and divMod, but I can't remember what it is.
23:50:42 <glguy> ?check \a b -> a `rem` b == a `mod` b
23:50:43 <lambdabot>  Add a type signature
23:51:05 <dons> > maxBound `rem` minBound :: Int
23:51:06 <dons> 2147483647
23:51:06 <lambdabot>  2147483647
23:51:09 <dons> > maxBound `mod` minBound :: Int
23:51:09 <dons> -1
23:51:10 <lambdabot>  -1
23:51:29 <dons> ?check \a b -> a `rem` b == a `mod` b :: Int
23:51:30 <lambdabot>  Couldn't match `Int' against `Bool'
23:51:37 <dons> ?check \a b -> a `rem` b == a `mod` (b :: Int)
23:51:38 <lambdabot>  Exception: divide by zero
23:51:45 <glguy> heh
23:51:51 <dons> ?check \a b -> b > 0 ==> a `rem` b == a `mod` (b :: Int)
23:51:52 <lambdabot>  Falsifiable, after 8 tests:
23:51:52 <lambdabot> -3
23:52:04 <glguy> ohhh negative numbers
23:52:10 <glguy> i remember now
23:52:13 <dolio> Ah, there you go. Dividing by negatives is different.
23:52:20 <dons> ?check \a b -> (a > 0 && b > 0) ==> a `rem` b == a `mod` (b :: Int)
23:52:21 <lambdabot>  OK, passed 100 tests.
23:52:29 <dons> ?check \a b -> (a < 0 && b > 0) ==> a `rem` b == a `mod` (b :: Int)
23:52:30 <lambdabot>  Falsifiable, after 6 tests:
23:52:30 <lambdabot> -2
23:52:33 <dons> :)
23:52:40 <dons> QuickCheck++
23:59:19 <dons> blogged :) http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#quickcheck
23:59:21 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/p78d6
