00:00:13 <jrmole> Clean's uniqueness types enforce singlethreadedness of the world state, so you can use impure functions and know what the execution order will be
00:00:50 <dibblego> ok I need to read more
00:00:58 <jrmole> dibblego, i don't know Clean, sorry
00:01:13 <dibblego> no problem , I onmy know *of* it
00:01:16 <dibblego> *only
00:44:02 <dons> huh, today was the busiest day in #haskell on record, http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html
00:44:04 <lambdabot> Title: #haskell @ freenode.org stats by dons, http://tinyurl.com/kpre5
00:48:25 <dons> ?users
00:48:27 <lambdabot> Maximum users seen in #haskell: 225, currently: 211 (93.8%), active: 27 (12.8%)
00:51:42 <lokadin> where do i go look to see how to add instances ?
00:53:04 <lokadin> i need to add instance of (Read PortNumber)
00:53:16 <lokadin> to read i guess
00:53:30 <lokadin> hmmm i'll go look up on YAHT
00:54:26 <lokadin> first day of school tommorrow :)
00:57:36 <lokadin> er well in 5 hours
00:58:10 <lokadin> fi'i kep
01:15:05 <falconair> can some tell me what the heck is a fix point?  while reading haskell and programming language theory literature (very beginner stuff), i keep coming across it, but don't understand why it is useful
01:15:43 <beelsebob> a fixed point is a value for which a function returns the same value
01:15:46 <beelsebob> so...
01:15:54 <beelsebob> there are infinitely many fixed points for id
01:16:04 <beelsebob> 1 is a fixed point for id because id 1 = 1
01:16:29 <beelsebob> it's called a fixed point because if you keep applying the function, it fixes it's self to that value...
01:16:48 <beelsebob> id $ id $ id $ id $ id $ id $ id $ id 1 = 1
01:17:38 * beelsebob tries to think of an interesting example
01:18:05 <falconair> right, i understand that much, but id of id of id of 1 is 1 is like saying water is wet...it seems obviuos...why does it need to be stated and studied?
01:18:17 <beelsebob> well...
01:18:33 <beelsebob> one interesting example would be calculating pi
01:18:40 <musasabi> falconair: think of a function like f(x) = x*x.
01:18:54 <beelsebob> there are functions that given any input the result will tend towards pi
01:19:14 <beelsebob> so... if I give it 5, it gives me 4, then 3, then 3.1, then 3.14......
01:19:27 <beelsebob> but... if I give it pi, the result doesn't change
01:19:40 <beelsebob> so I can calculate pi, by finding the fixed point of that function
01:20:11 <falconair> beelsebob: i read that as well (didn't work through the example for sqrt though) ... but i don't understand why it is important for programming language theory
01:21:10 <beelsebob> good question, give an example of where it's stated
01:21:14 <eivuokko> beelsebob, is your explanation that fixed point is interesting because there isn't otherwise nice iteration/recursion in maths?  So fixed point works as a sort of base-case?  That's who it looks to me :)
01:21:22 <eivuokko> *how
01:21:44 <beelsebob> eivuokko: I guess that's one way of looking at it
01:23:15 <beelsebob> quite a nice way in fact
01:23:52 <falconair> i was just reading the language manual for scala (i've seen it many times before in haskell papers) ... i think in that example the author used sqrt...now rest of the manual is fantastic in how easy it makes concepts from statically typed functional programming...yet fix point is described as a function such as f(x)=x (or an f(x) that 'tends' towards x) ... i must be missing some greater meaning
01:24:33 <falconair> ...oh, i see it often mentioned in some of the more abstract papers that talk in terms of 'algebra' of this or that rather than actual code examples (can't think of specific instances now)
01:24:54 <beelsebob> well, it's often used to calculate the denotational semantics of a function
01:25:18 <velco> data-flow analysis in compilers for imperative languages
01:25:21 <beelsebob> if I have a recursive function, and i need to define a mathematical function to represent it's semantics, I need to find where the recursion stops
01:25:37 <beelsebob> (I need to calculate the fixed point of the recursion)
01:25:42 <velco> it's based on fixed-points theory
01:26:46 <falconair> so similar to what eivuokko said, it is a purely mathematical way of describing recursion/iteration of programming languages?
01:26:58 <beelsebob> it can be used to do so, yes
01:27:05 <beelsebob> (assuming you were using denotational semantics)
01:28:44 <falconair> so, wikipedia tells me that it is related to the y-combinator ... will understanding the y-combinator help me understand fixed point?
01:28:52 <beelsebob> I have no idea
01:28:59 <beelsebob> I don't know what the y-combinator is :P
01:39:36 <falconair> hm...the web doesn't help much...if google doesn't know then i don't need to know about fixed points :)  thanks beelsebob, et all
02:09:54 <beelsebob> @where ghc intel mac
02:09:55 <lambdabot> http://haskell.org/ghc
02:15:32 <bringert> does anyone know when the Read instance for Data.Map appeared?
02:21:18 <foxy> in one analysis verbs are given type |S|, nouns are given type |NP|, and other syntactic categories are given types such as |NP -> NP|, which is an adjective.  Comparing the phrases "golden and white socks" and "golden socks and white socks" in the first sentence "and"  is of the type |(NP -> NP) -> (NP -> NP) -> (NP -> NP)| and in the second sentence it is of type |NP -> NP -> NP|, so it...
02:21:20 <foxy> ...would seem it is of type |forall a.a -> a -> a|.  On the semantic side, the "and" implementation must take each argument and 'fork' it to each of its arguments.  Can anyone find a way to implement this in Haskell+ ?
02:21:46 <dons> bringert: around the time Data.Map appeared
02:21:55 <dons> there was a discussion about how it was a weird instance
02:23:04 <bringert> it seems like GHC 6.4.1 has Data.map without Read
02:23:18 <bringert> Data.Map that is
02:23:48 <bringert> so I would have to use ifdefs and add my own instance if I want to use read
02:23:57 <bringert> I'll just roll my own functions instead
02:37:57 <tibbe> @yarr
02:37:58 <lambdabot> I heard andersca is a pirate
02:39:45 <tibbe> ?users
02:39:47 <lambdabot> Maximum users seen in #haskell: 225, currently: 216 (96.0%), active: 28 (13.0%)
02:40:00 <tibbe> lambdabot: are you a user?
02:40:59 <dons> yeah
02:41:04 <dons> I think so (?)
02:41:26 <tibbe> lambdabot: so what are you on?
02:41:30 <profmakx> hooray for lambdabot!
02:41:59 <dons> ?seen lambdabot
02:42:00 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
02:47:34 <tibbe> ?type repeatM
02:47:36 <lambdabot> Not in scope: `repeatM'
02:47:43 <tibbe> @hoogle repeatM
02:47:44 <lambdabot> No matches found
02:48:16 <dons> ?type let repeatM = sequence_ . repeat in repeatM
02:48:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
02:52:36 <tibbe> :)
02:53:06 <tibbe> they guy who wrote about who functional programming can make you unhappy, I get his point now
02:55:43 <bringert> tibbe: how is that? knowing fp makes you miserable when forced to use other languages?
02:56:45 <dcoutts__> I can cetainly understand that
02:56:59 <Igloo> Does cabal-install really use TH?
02:57:04 <edwardk> tibbe: yeah i really feel his point.
02:57:14 <dcoutts__> Igloo: dunno, sorry, I hope not
02:57:24 <edwardk> it makes you feel every moment you are stuck wasting typing in boilerplate
02:57:38 <dcoutts__> Igloo: I'm removing that bit from Cabal.cabal
02:57:47 <dcoutts__> since we don't build it anyway
02:58:10 <dcoutts__> @seen xerox
02:58:11 <lambdabot> I saw xerox leaving #haskell-overflow, #haskell-blah, #perl6 and #haskell 9h 38m 56s ago, and .
03:01:36 <dcoutts__> anyone know what the difference between an error and a failure is with HUnit?
03:03:30 <nominolo> ok, this probably a stupid newby Q, but:  how can I build alex/happy after having them checked out using darcs get --partial <url> ? there's no makefile and ghci Setup.lhs errors out
03:03:36 <dons> ah this came up the other day dcoutts__
03:04:08 <dcoutts__> nominolo: you might need a later version of Cabal to build them
03:04:19 <dons> nominolo: runhaskell Setup.hs configure --prefix=/my/dir ; runhaskell Setup.hs build  ?
03:04:51 <dcoutts__> dons: I'm fighting Cabal's testsuite, it doesn't seem to have any way to run individual tests. Or I'm blind and ignorant of HUnit.
03:05:14 <nominolo> hm, might help. i'm new to building haskell programs on my own ..
03:05:21 <nominolo> i'll try
03:07:27 <fasta> How can I do mystate<-get;dontcare<-if sometest then return (trace "foobar" somevalue) else return (trace "otherbar" someothervalue);other computations? The problem is now that the whole conditional is not evaluated because it's not "needed". I want it to evaluate it anyway.
03:08:42 <dcoutts__> evaluate (trace "foobar" ())
03:09:25 <dcoutts__> evaluate (trace (if sometest then "foobar" else "otherbar") ())
03:09:55 <fasta> dcoutts__: Is evaluate code or English?
03:09:55 <dcoutts__> oh but evaluate is only in IO
03:10:04 <dcoutts__> not sure what monad you're in
03:10:09 <fasta> dcoutts__: State
03:10:12 <dcoutts__> @hoogle evaluate
03:10:13 <lambdabot> Control.Exception.evaluate :: a -> IO a
03:10:13 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
03:10:27 <dcoutts__> fasta: then use seq
03:10:44 <dcoutts__> trace (if sometest then "foobar" else "otherbar") othercomputations
03:10:49 <velco> reading "Gentle Introduction ..." there's a line like "client init ~(resp:resps) = init : client (next resp) resps"
03:10:59 <SamB> dcoutts: you didn't say seq in there!
03:11:01 <dcoutts__> or no need, just use trace in the way it is indented to be used
03:11:03 <velco> and later "in Haskell, pattern bindings are assumed to have an implicit ~ in front of them"
03:11:07 * dcoutts__ noticed that :-)
03:11:09 <SamB> oh
03:11:20 <velco> does that mean that theoabove "~" is redundant ?
03:11:20 <SamB> that makes more sense, yes ;-)
03:11:44 <dcoutts__> fasta: the point is, with trace that you attach it to some value that will be demanded
03:12:02 <SamB> velco: that ain't a pattern binding, is it?
03:12:11 <dcoutts__> so an obvious such value is the entire remainder of the computation
03:12:39 <dcoutts__> don't try an use it as a monadic value
03:12:45 <dcoutts__> since as you noticed, it's not needed
03:12:55 <velco> SamB: oh, IO see
03:13:00 <fasta> dcoutts__: I'd rather use seq, but I don't see how to use it.
03:13:01 <velco> *I
03:13:11 <dcoutts__> fasta: using seq is the same
03:13:20 <dcoutts__> so there's no advantage
03:13:31 <SamB> dcoutts: wouldn't it also work to to just apply "return ()" to it?
03:13:47 <dcoutts__> yeah, probably
03:14:01 <SamB> ... probably?
03:14:07 <dcoutts__> yes, it would.
03:14:11 <dcoutts__> better? :-)
03:14:16 <SamB> yes ;-)
03:14:39 <dcoutts__> make sure you use trace (..) (return ()) and not return (trace (..) ())
03:14:51 <fasta> I wish I could get a trace of my whole program, without inserting the traces myself. (like in "popular" programming language)
03:15:05 <dons> you can use hood or hat for this
03:15:20 <fasta> dons: does it compile? Is there a binary?
03:15:21 <dons> if you really want to see how your program is reduced
03:15:24 <dcoutts__> or modify your monad to generate a trace
03:15:25 <dons> yep
03:15:40 <dons> let me find some urls
03:15:59 <dons> ?where+ hood www.haskell.org/hood/
03:15:59 <lambdabot> Done.
03:16:05 <fasta> dcoutts__: So, what do you suggest w.r.t. my originnal example?
03:16:11 <fasta> original, even
03:16:29 <beelsebob> William Shatner: I'm interested in man's march into the unknown but to vomit in space is not my idea of a good time. Neither is a fiery crash with the vomit hovering over me. I do want to go up but I need guarantees I'll definitely come back.
03:16:33 <dons> ?where+ hat www.haskell.org/hat/
03:16:33 <lambdabot> Done.
03:16:35 <dcoutts__> fasta: test (if thing then "foo" else "bar") (return ())
03:16:41 <dcoutts__> err test/trace
03:16:44 <beelsebob> that was already there wasn't it?
03:16:52 <dons> maybe
03:16:56 <fasta> dons: I see hood is tested with ghc 4.08. Why would it work with 6.4.2?
03:17:08 <dons> why wouldn't it?
03:17:10 <SamB> @where hat
03:17:10 <lambdabot> www.haskell.org/hat/
03:17:29 <beelsebob> fasta: tbh, I would reccommend hat over hood
03:17:30 <SamB> what happens if you @where+ a key that already exists?
03:17:30 <dons> generally, viewing the trace isn't very interesting
03:17:37 <dcoutts__> dons: most things broke with ghc 5.x and 6.0 and again with 6.4 :-)
03:17:37 <dons> since its easy enough to do by hand anyway
03:17:44 <beelsebob> fasta: hood requires you to add tags indicating what code to observe
03:17:45 <dons> and you don't have any weird state to build up
03:17:52 <beelsebob> (which is not one of your requirements)
03:18:00 <dcoutts__> we took >6months to get ghc 6.4 to work with all packages in gentoo :-)
03:18:03 <dons> SamB: it overwrites it
03:18:09 <fasta> dons: Haskell bitrots fast
03:18:22 <dons> not if you write in h98
03:18:34 <SamB> wasn't the 6.4 breakage due to changes in the package file format or whatever?
03:18:38 <beelsebob> indeed - I never had a problem with the ghc 6.4 update
03:18:51 <fasta> dons: What about Data.Char vs Char?
03:18:53 <beelsebob> if you actually write Haskell, it all works
03:18:57 <dons> my h98 code from 1999 still compiles
03:19:01 <dons> fasta, what about it?
03:19:10 <fasta> dons: Ok, that's not 98.
03:19:21 <dons> import Char stlil works
03:19:23 <SamB> oh, well, -package haskell98 gets you Char back...
03:19:36 <fasta> dons: In GHC? Interesting
03:19:48 <dons> in all systems, as far as I'm aware
03:20:04 <dcoutts__> h98 doesn't break
03:20:07 <beelsebob> fasta: specifically what would you like to trace?
03:20:15 <dons> you don't need -package haskell98 or anything. h98 just works.
03:20:42 <fasta> beelsebob: I have this hugely complex algorithm which I want to test on increasingly difficult graphs.
03:20:47 <SamB> dons: um, yes you do if you compile a program!
03:20:57 <SamB> and link it!
03:21:04 <dons> dont' need it here...
03:21:06 <fasta> beelsebob: I want to see what paths are taken in the code what changes are done to the state variables.
03:21:32 <dons> $ cat A.hs
03:21:32 <dons> import Char
03:21:32 <dons> main = print (toUpper 'x')
03:21:32 <dons> $ ghc A.hs
03:21:35 <beelsebob> fasta: so do you have bugs, or do you want to simply look at what happened?
03:21:35 <dons> $ ./a.out
03:21:35 <dons> 'X'
03:21:41 <SamB> dons: hmm
03:21:48 <SamB> maybe it depends what version of GHC you have
03:22:14 <SamB> or maybe your haskell98 package was unhid or something
03:22:28 <fasta> beelsebob: right
03:22:33 <dons> works with 6.2.2, 6.4.x and 6.6. my haskell98 package is whatever it comes as
03:22:44 <fasta> beelsebob: I have bugs and I want to see what happened
03:22:48 <beelsebob> fasta: you just want to see what happened?
03:22:51 <SamB> yes, but maybe there aren't parens around it nomore!
03:22:59 <dons> in cabal you have to specify the haskell98 dep explicitly
03:23:06 <beelsebob> if this is the case I would reccommend pretty-hat, although it may struggle with very large programs
03:23:13 <beelsebob> alternatively hat-anim
03:23:29 <fasta> @where pretty-hat
03:23:29 <lambdabot> I know nothing about pretty-hat.
03:23:38 <dons> if its complex, you might want to try QuickCheck to specify properties of the components first
03:23:44 <beelsebob> hat-observe will give you what functions were called, how they were called, and what their results were
03:23:46 <dons> that's the most common debugging tool
03:23:59 <beelsebob> @where+ pretty-hat http://www.haskell.org/hat
03:24:00 <lambdabot> Done.
03:24:06 <beelsebob> @where+ hat-anim http://www.haskell.org/hat
03:24:07 <lambdabot> Done.
03:24:12 <beelsebob> @where+ hat-observe http://www.haskell.org/hat
03:24:13 <lambdabot> Done.
03:24:16 <beelsebob> @where+ hat-detect http://www.haskell.org/hat
03:24:17 <lambdabot> Done.
03:24:21 <beelsebob> bored now
03:24:25 <SamB> oh, right, it was someone else who had this problem... and it was with cabal...
03:24:38 <fasta> Ok, I hope hat will help
03:25:12 <beelsebob> fasta: the other tools quite deliberately don't show you what happened in what order
03:25:21 <beelsebob> because to debug you don't need to know evaluation order
03:25:47 <SamB> yeah, it might be nice to know which branch of an if was taken though...
03:25:48 <beelsebob> you just need to know what all the bits of your program "should" do
03:26:06 <beelsebob> SamB: yes, this is easy to find out
03:26:10 <dons> D[Dand break the program up. you shouldn't ever reach a point where you need to employ hat to understand what your program is doing :) it should be made from pieces that can be debugged in isolation anyway, with QuickCheck or HUnit
03:26:12 <SamB> okay
03:26:30 <SamB> QuickCheck is neato
03:26:32 <beelsebob> dons: that's exactly what hat does for you
03:26:41 <dons> yeah, hat is cool
03:26:54 <SamB> beelsebob: debugs your program with QuickCheck and HUnit?
03:26:54 <beelsebob> the whole point of algorithmic debugging is that it does divide and conquer on the program without you having to do it manually
03:27:06 <beelsebob> SamB: the latest version, yes
03:27:22 <fasta> Do I need to apply all the patches?
03:27:37 <beelsebob> fasta: I would recommend using the cvs version
03:27:45 <beelsebob> it includes a version of QuickCheck that can be used with hat-delta to make it find the bug faster
03:27:58 <beelsebob> (assuming I remembered to check it in)
03:27:59 <fasta> beelsebob: for what version does that work? I currently only have 6.4.2
03:28:04 <AStorm> Typed lambda calculus is so much fun :>
03:28:25 <beelsebob> fasta: I've had no problems with it on anything between 6.2 and 6.5
03:28:31 <beelsebob> not tested it on anything else
03:31:45 <araujo> morning!
03:31:49 <beelsebob> moin
03:32:05 * araujo throws sugar lambdas at everyone
03:32:15 * beelsebob opens mouth
03:32:20 * SamB too
03:32:23 <araujo> :-)
03:36:15 <dons> ?remember lennart  I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less useful for functional code
03:37:16 <AStorm> Debugging is for wimps ;-)
03:37:25 <beelsebob> hehe
03:37:26 <AStorm> Proper programmers understand written code and can write tests.
03:37:35 <beelsebob> how about writing a debugger without a debugger?
03:37:41 <AStorm> ^
03:37:41 <dons> heh
03:38:01 <beelsebob> writing tests does not imply finding the bug
03:38:12 <sieni> debuggers are only useful for finding segfaults and assertion failures
03:38:23 <sieni> for other things there's printf()
03:38:24 <AStorm> Debugging is only good for unexpected errors. Those don't happen too often in Haskell.
03:38:25 <beelsebob> what's a test failure?
03:38:31 <beelsebob> it's an assertion failure
03:38:48 <beelsebob> AStorm: this is true... but when they do happen, they're an absolute bastard to track down
03:38:57 <eivuokko> You don't debug what you expect.  You can't write tests for what you don't expect, really.
03:39:10 <dons> also, we have to remember that debuggers in FP are quite different to debuggers in imperative languages
03:39:14 <AStorm> :>
03:39:18 <AStorm> You still have to read code.
03:39:21 <dons> you usually can't roll back time in an imperative debugger :)
03:39:29 <eivuokko> dons, Eh, well..
03:39:34 <beelsebob> there are actually quite a few I've seen that do this
03:39:34 <Igloo> I wish you could
03:39:38 <AStorm> You can get a traceback though.
03:39:44 <eivuokko> dons, Sometimes you actually can.
03:39:50 <beelsebob> the point though is that it's not usually as useful to go forwards in a functional program
03:39:54 <Igloo> ...he says, with a pile of randomly occuring GHC testsuite failures
03:40:01 <dcoutts__> heh
03:40:06 <dons> hehe
03:41:38 <eivuokko> Me?  Well, shows just how unusefull the tests are, the tests I care about don't fail on my machine...
03:41:52 <AStorm> Well, stepping execution could be nice still.
03:41:53 <AStorm> With function granularity.
03:42:02 <eivuokko> They don't catch all the external conditions :-(
03:42:09 <AStorm> eivuokko: tests are more like proofs of correctness.
03:42:22 <AStorm> Yes, they don't, but are great for tracking regressions.
03:42:24 <AStorm> :>
03:43:10 <fasta> I installed hat, but I don't really see how to use it, as the manpages didn't install and doing hat-observe Main also doesn't work.
03:44:27 <fasta> /usr/local/bin/hat-observe: line 5: exec: /usr/local/lib/hat-2.04//hat-observe: cannot execute: No such file or directory
03:44:51 <SamB> peculiar!
03:45:05 <SamB> did you do it with cabal?
03:45:07 <AStorm> Hmm.
03:45:17 * SamB heard something about cabal not installing binaries
03:45:20 <Igloo> eivuokko: I didn't mean the Windows ones. I have random tests failing (I think due to the threaded RTS) on random Linux arches
03:45:30 <eivuokko> Ah
03:46:11 <SamB> I could easily be confused
03:46:23 <SamB> I never tried it myself, iirc...
03:47:32 <fasta> How do I obtain a .hat file?
03:47:51 * araujo printing a lambda paper to read on the univ free time
03:48:09 <SamB> well, you run hat on your program and it spits out another program that uses the processed libraries...
03:48:48 <SamB> hat-trans, maybe its called
03:49:23 <SamB> I don't seem to have hat installed anymore
03:49:37 <dons> SamB: could you whip up a patch to add the '^nick++($| .*)' regex matching on karma names?
03:50:04 <dons> have you used Text.Regex?
03:50:07 <SamB> I have to get ready for school, really...
03:50:16 <SamB> I haven't really used Text.Regex, no...
03:50:18 <dons> ah ok :)
03:50:50 * dons forgets what time things are at other parts of the sphere
03:50:51 <SamB> I have looked at it, but it seems useless for anything but testing if something matches a regex...
03:50:58 <SamB> hehe
03:51:03 <SamB> @localtime SamB
03:51:04 <lambdabot> Local time for SamB is Wed Sep  6 06:50:43
03:51:07 <dons> you can get bcak the matched bits
03:51:14 <SamB> oh really?
03:51:16 <dons> or the bits before the match, or after, or replace :)
03:51:17 <SamB> is it a new one now?
03:51:20 <dons> no
03:51:30 <SamB> hmm
03:51:35 <SamB> @docs Text.Regex
03:51:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
03:51:42 <dons> i.e. | Just (a,_,b,_) <- runplugs  `matchRegexAll`  s
03:51:51 <dons> returns all the bits
03:52:05 <dons> ?type Text.Regex.matchRegexAll
03:52:07 <lambdabot> Text.Regex.Posix.Regex -> String -> Maybe (String, String, String, [String])
03:52:41 <dons> (using the pattern guard syntax is nice ^^)
03:52:46 <SamB> ooh!
03:52:50 <fasta> dcoutts__: Fantastic, return () works :)
03:53:02 <SamB> fasta: that was my idea wasn't it?
03:53:16 <dons> in hat, you mean, fasta?
03:53:36 <SamB> or aren't you talking about that trace call?
03:53:57 <SamB> dons: sweet
03:54:02 <SamB> I didn't see that before!
03:54:05 <fasta> SamB: right, my mistake.
03:54:26 <SamB> well, dcoutts *did* say it would work after I suggested it (with a bit of prodding ;-)
03:54:28 <fasta> SamB: I miss things that do not have fasta in it.
03:54:44 <SamB> I suppose I suggested it to dcoutts ;-)
03:54:54 <deadbeef> ciao amici
03:54:57 <deadbeef> ops
03:55:01 <deadbeef> hi dear friends
03:55:09 <SamB> oh, I thought that meant "goodbye"!
03:55:14 <dons> ?babel it en ciao amici
03:55:16 <lambdabot>  hello friends
03:55:19 <dons> :)
03:55:37 <SamB> I could tell amici meant friends
03:55:41 <dons> ?babel en it hello, deadbeef. how are you?
03:55:43 <lambdabot>  ciao, deadbeef. come siete?
03:55:47 <nominolo> ok, so to build alex i need happy.  and when i try to build happy, i get a linker error (duplicate _Main_main_closure)
03:55:53 <deadbeef> fine thanks
03:55:55 <deadbeef> dons: you ?
03:55:56 <SamB> @babel en it goodbye
03:55:57 <lambdabot>  arrivederci
03:55:58 <nominolo> can someone help with this plz?
03:56:02 <SamB> @babel en it bye
03:56:04 <lambdabot>  arrivederci
03:56:09 <SamB> okay.
03:56:13 <SamB> shows what I know!
03:56:22 <dons> ?babel en it good! lots of fun code to write.
03:56:23 <lambdabot>  buon! lotti del codice di divertimento da scrivere.
03:56:23 <deadbeef> arrivederci = see you
03:56:25 <deadbeef> indeed
03:56:32 <deadbeef> haha
03:56:40 <deadbeef> lotti del codice di divertimento <-
03:56:53 <dons> ?babel it en lotti del codice di divertimento
03:56:54 <lambdabot>  lotteries of the divertimento code
03:56:56 <dons> heh
03:57:00 <dons> gets worse
03:57:02 <SamB> heh
03:57:05 <fasta> dons: no, I mean without using hat. I think I will read the "tutorial" of Hat first, since it's quite unusable without reading it.
03:57:13 <dons> good idea :)
03:57:20 <SamB> yes, quite a good idea!
03:57:21 <dons> I think i have some slides on its use somewhere. let me see...
03:57:30 <SamB> I must get some cerial
03:58:34 <dons> hmm. can't seem to find them :/
03:58:49 <nominolo> - bbs
04:00:46 <AStorm> I guess I love layout, just like I love mandatory indentation of Python.
04:00:51 <AStorm> :-)
04:01:10 <Philippa> layout's not as dictatorial - you can use semicolons and braces instead
04:01:17 <Philippa> (in fact, it desugars to them)
04:01:32 <AStorm> I know.
04:01:34 * edwardk wakes up and stumbles about.
04:02:01 <dons> > let{x=y;y=z;z=3}in(z+y)
04:02:02 <lambdabot>  6
04:02:02 <AStorm> But still, looks great. No reason to use punctuation.
04:02:06 <edwardk> i need to slap together a layout desugarer for my little project
04:02:35 <dons> Requiring { ;; } is an admission of failure for parser writers :)
04:02:44 <edwardk> its after 'of' 'where' 'do' and and 'in' right?
04:02:56 <Philippa> yeah. Frequently failure to be arsed :-)
04:02:56 <vincenz> edwardk: also after "if"
04:02:58 <dons> let, where, do, of
04:02:59 <fasta> I can't use hat at the moment, because it requires hmake, and hmake tries to call the hat scripts, but those scripts are broken.
04:03:05 <edwardk> if?
04:03:12 <vincenz> well the else and then need to be more indented
04:03:23 <edwardk> yeah but thats to defeat layout, right?
04:03:27 <dons> fasta: sounds very unusual. let me try to build it...
04:03:29 <edwardk> not to insert {;;}'s
04:03:40 <edwardk> otherwise lyout tries to stick a ; in the middle
04:04:23 <fasta> dons: try to install Hat from CVS and then do hat-observe
04:04:46 * dons tries the stable version first..
04:05:24 <edwardk> hrmm, for a language starting from scratch, given the success of layout, would you say that it might make sense to employ a heavier weight bracket there than { } so as to reclaim { } for a more common use?
04:05:29 <dons> you could have found your bug in ghci by now ;)
04:05:39 <Philippa> possibly, yes
04:05:42 <dons> edwardk: not a bad idea
04:05:43 <edwardk> then let layout get rid of the multicharacter bracket?
04:05:45 <fasta> dons: right, I think I will go down that path now.
04:05:58 <Philippa> it depends whether you think there's reasonable cause to use explicit bracketing very often
04:06:15 <edwardk> i use it once in a while when talking to lambdabot, not much
04:06:25 <edwardk> ; i can't really justify reclaiming, but the {}'s maybe
04:06:44 <dons> ; might be fun as >>
04:06:47 <Philippa> I think ;'s justifiable if you find another single-char replacement
04:06:47 <dons> ;)
04:07:18 <edwardk> yeah, just that its someone comfortable to programmers in its current role.
04:07:31 <edwardk> {}'s have all sorts of possible toy meanings =
04:08:17 <fasta> I'd rather have people come up with a programming environment first before they come up with indentation.
04:08:42 <dons> yeah, its called ghci+emacs
04:08:57 <edwardk> fasta: i'm just trying to figure out the best way to adapt the stuff that works in haskell
04:09:05 <fasta> dons: emacs is not fool proof.
04:09:08 <edwardk> without slavishly copying
04:09:14 <dons> programming is not for fools
04:09:22 <tibbe> back from lunch
04:09:38 <fasta> dons: Try to make a multi line comment when you are in do notation. Indenting breaks then.
04:09:53 <dons> hmm?
04:10:02 <edwardk> its hard to highlight "correctly" without doing a full parse.
04:10:12 <edwardk> its hard to maintain a full parse while people edit away
04:10:28 <tibbe> bringert, yes, that's it, it's sometime frustating to use less expressive languages when you know more expressive ones
04:10:37 <dons> main = do
04:10:37 <dons>     print 1
04:10:37 <dons>     {- some
04:10:37 <dons>        stuff -}
04:10:38 <dons>     print 2
04:10:53 <dons> you have so many complaints, fasta!
04:11:03 <edwardk> heh
04:11:06 <fasta> dons: suppose you have do foobar<newline>otherthingie<newline> {- look this is a <newline> comment -} <press enter> type "otheraction" <press TAB> => result no indenting in the correct way
04:11:13 <fasta> dons: I like correctness
04:11:39 <fasta> If Linux wouldn't be this "popular" I would be using OpenBSD
04:11:52 <dons> ?version
04:11:53 <lambdabot> lambdabot 4p124, GHC 6.5 (OpenBSD i386 )
04:11:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:12:01 <fasta> dons: I know you run it
04:12:06 <deadbeef> OpenBSD omg
04:12:29 <tibbe> edwarkd, I guess the Eclipse guy do that by using an incremental compiler/parser
04:12:45 <deadbeef> OpenBSD: how to turn a intel core duo into a 386 emulator
04:12:52 <dons> i stil can't find an error, fasta.
04:12:53 <dons> main = do
04:12:53 <dons>   print 1
04:12:53 <dons> {- look this is a
04:12:53 <dons>  comment -}
04:12:55 <dons>   print 2
04:12:58 <dons> works fine
04:13:04 <edwardk> *nods* i suppose something could be done with a fancy parser built over a recomputation monad or something.
04:13:15 <edwardk> but i wouldn't want to be the guy to write it ;
04:13:47 <tibbe> the biggest problem for me is that emacs stops indenting when I separate things with newlines
04:14:09 <dons> ahh, you talking about emacs indenting being broken? my mistake.
04:14:15 <dons> no wonder I didn't notice any broken indenting in vim
04:14:18 <edwardk> heh
04:14:36 <tibbe> probably a bug in vim that makes it work by accident
04:14:37 <edwardk> *shrugs* i've been so used to indenting being broken I don't even notice when I have to manually outdent
04:14:40 <dons> yeah, no one wants to write a good indenter for emacs, buut they still complain :)
04:14:58 <fasta> dons: I meant that if you do two enters, and then a tab, it doesn't indent. Indeed the same as tibbe describes.
04:15:01 <tibbe> s/work/works
04:15:10 <dons> yeah, emacs is famously bad at indenting haskell
04:15:17 <edwardk> and no matter what you think of and call 'the right way' someone else will always find a usage case in which you're wrong. ;)
04:15:21 <edwardk> so i give up =)
04:15:30 <dons> but that's because no one steps up to fix it...
04:15:32 * tibbe is famously bad at writing Lisp, else he would fix it
04:15:50 <dons> would it be faster to just write a lisp binding to haskell...
04:16:02 <dons> and then use one of our standard pretty printers/
04:16:03 <dons> ?
04:16:16 <edwardk> stg->lisp? =)
04:16:25 <dons> ffi via C?
04:16:36 <dons> lisp can surely call C, right?
04:16:38 <edwardk> ah
04:16:51 <dons> you used to be able to mix haskell and lisp in yale haskell
04:16:52 <SamB> dons: well, there is not standard
04:17:01 <SamB> er, *no standard
04:17:11 <fasta> dons: I think you need to recompile your whole Emacs to add C code.
04:17:22 <SamB> there is some package that tries to let you write your FFI stuff once and for all
04:17:29 <fasta> dons: but you know better than me, I guess.
04:17:53 <dons> i don't use emacs, but i'd think an ffi binding from elisp to haskell, done once, would be useful...
04:18:05 <SamB> oh, I thought you were talking about CL
04:23:12 <tibbe> > (concat $ repeat 10 "(") ++ "this is a Lisp expression" ++ (concat $ repeat 10 ")")
04:23:13 <lambdabot>    The function `repeat' is applied to two arguments,
04:23:13 <lambdabot>   but its type `a -...
04:23:30 <tibbe> > (concat $ replicate 10 "(") ++ "this is a Lisp expression" ++ (concat $ replicate 10 ")")
04:23:31 <lambdabot>  "((((((((((this is a Lisp expression))))))))))"
04:23:36 <dons> heh
04:23:43 <tibbe> waaay to few paranthesis
04:23:43 <deadbeef> lol
04:23:55 <tibbe> > (concat $ replicate 15 "(") ++ "this is a Lisp expression" ++ (concat $ replicate 15 ")")
04:23:56 <lambdabot>  "(((((((((((((((this is a Lisp expression)))))))))))))))"
04:24:55 <tibbe> I've been thinkinh about prefix syntax some, to me the problem (with arithmetic expressions in particular) is that you have to jump back an forth on a line to parse it
04:25:05 <tibbe> s/thinkinh/thinking
04:25:54 <ndm> > let depth = 15 in replicate depth '(' ++ "this is a Lisp expression" ++ replicate depth ')'
04:25:55 <lambdabot>  "(((((((((((((((this is a Lisp expression)))))))))))))))"
04:26:00 <tibbe> and it goes against the pattern recognition we have learnt in math
04:26:13 <ndm> tibbe: no point in concat $ replicate blah "(" - its just replicate blah '('
04:26:19 <tibbe> ndm, you need to generalize it more ;)
04:26:23 <ndm> tibbe: and you want to ensure the brackets match :)
04:26:38 <tibbe> ndm, *nod*
04:26:53 <deadbeef> > let f x 0 = x; f x n = f ("(" ++ x ии++ ")") (n - 1) in f "expression" 5
04:26:55 <lambdabot>  Not in scope: `ии'
04:26:56 <AStorm> (car (car (car (car (car "H") "e" ) "l" ) "l" ) "o")
04:26:56 <AStorm> :>
04:27:51 <deadbeef> what's wrong
04:28:05 <deadbeef> @free error
04:28:07 <lambdabot> ( g z = z  =>   $map g x = y ) => f (error x) = error y
04:28:12 <twanvl> > let paren x = "("++x++")" in iterate paren "lisp likes parentheses" !! 15
04:28:13 <lambdabot>  "(((((((((((((((lisp likes parentheses)))))))))))))))"
04:28:25 <dons> > let f x 0 = x; f x n = f ("(" ++ x ++ ")") (n - 1) in f "expression" 5
04:28:26 <lambdabot>  "(((((expression)))))"
04:28:37 <dons> deadbeef: there were some weird chars in your output
04:28:46 <deadbeef> asd
04:29:03 <AStorm> dons: I think your's slower and less clean.
04:29:04 <AStorm> :>
04:29:06 <AStorm> Though...
04:29:11 <dons> not mine.
04:29:16 <dons> see above.
04:29:30 <deadbeef> sry
04:29:37 <AStorm> Ah, right.
04:29:37 <deadbeef> started with hs a few days ago
04:29:50 <dons> deadbeef: no problems :) keep at it!
04:30:00 * AStorm started 2 days ago, even
04:30:34 <tibbe> ?type foldl
04:30:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:31:00 * dons started 2802 days ago
04:31:16 <AStorm> What kind of definition is that? :> function -> some values with list?
04:31:20 <dons> how time flys!
04:31:23 <edwardk> i think i'm up to 2 months now.
04:31:24 <edwardk> wow
04:31:39 <edwardk> i totally got sidetracked =)
04:31:44 <dons> heh
04:31:54 <tibbe> um, I was here briefly before Christmas when I wrote an interpreter in a Programming Languages course
04:32:04 <edwardk> not that thats surprising for me, as you've probably noticed ;)
04:32:05 <tibbe> so I probably have 2 months as well
04:32:25 <AStorm> dons: any explanation of that foldl? Because the type def. looks funny
04:32:46 <dons> that type def is fine , it's just explicitly quantified
04:32:58 <dons> i.e. the type variables 'a' and 'b' are bound by the forall
04:33:09 <dons> (a -> b -> a) -> a -> [b] -> a is the same thing, but the forall is assumed
04:33:14 <SamB> dons: okay, so I sent you a patch. It might even work. There really should be a good way to test contextual stuff offline...
04:33:23 <dons> ah yes
04:33:28 <dons> good idea!
04:34:01 <dons> > foldl (\n _ -> n+1) 0 [1..100]
04:34:02 <lambdabot>  100
04:34:14 <dons> ?pl \n _ -> n+1
04:34:14 <lambdabot> const . (1 +)
04:34:26 <dons> > foldl (const . (1 +)) 0 [1.10000]
04:34:27 <lambdabot>  1
04:34:33 <dons> > foldl (const . (1 +)) 0 [1..10000]
04:34:34 <lambdabot>  10000
04:34:36 <AStorm> Fun, hehe.
04:34:43 <bringert> dons: is the 2802 days true, or just a ballpark figure?
04:34:51 <dons> bringert: pretty close
04:35:00 <dons> > 7*365 + 247
04:35:01 <lambdabot>  2802
04:35:10 <dons> - 30 or so
04:35:20 <AStorm> It is almost like mapping over the list.
04:35:21 <AStorm> Any major diffs?
04:35:31 <dons> right, its reducing the list to a final value
04:35:38 <dons> but it traverses the list much as map does
04:35:46 <bringert> > 6 * 365 + 7
04:35:47 <lambdabot>  2197
04:35:50 <bringert> or so for me
04:36:18 <xerox> ?yow!
04:36:18 <lambdabot> Uh-oh -- WHY am I suddenly thinking of a VENERABLE religious leader
04:36:18 <lambdabot> frolicking on a FORT LAUDERDALE weekend?
04:36:33 <bringert> hmm, lamdbabot could have a date mosule that dould figure out the number of days until or since a given date
04:36:34 <bringert> etc
04:36:39 <Igloo> dons: what does that mean - second or third term? Of how many?
04:36:39 <bringert> hi shapr
04:36:41 <shapr> Good morning #haskell!
04:36:42 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
04:36:54 <shapr> Lemmih: yes, I get mail there.
04:37:01 <xerox> Hello.
04:37:01 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
04:37:18 <xerox> A message! :)
04:37:19 <ndm> hi everybody!
04:37:31 <AStorm> bringert: it's easy to write that simple a function
04:37:36 <AStorm> :>
04:37:37 <edwardk> shapr lives!
04:37:38 <ndm> btw, there is now a hoogle mailing list for everyone who likes emailing me about hoogle :)
04:37:38 <shapr> bringert: Hello, how's code?
04:37:48 <shapr> ndm: Does it have a gmane connection?
04:37:50 <AStorm> 3 arguments, some cases
04:38:03 <edwardk> where you been, man?
04:38:09 <ndm> shapr: its on haskell.org, as of this morning - not sure if that means yes or no
04:38:11 <bringert> AStorm: sure, it would be a nice sweet lambdabot example
04:38:15 <AStorm> You also have to get the current date somehow.
04:38:16 <AStorm> :>
04:38:26 <ndm> shapr: but i'd be happy for it to have one, if i knew how
04:38:27 <shapr> edwardk: I was moving back to the USA.
04:38:32 <bringert> well, that's easy enough
04:38:32 <edwardk> shapr: ahh
04:38:36 <dons> shapr: you need to submit your review for the SoC within the next 2 days
04:38:41 <edwardk> shapr: what brought that about?
04:38:45 <SamB> ndm: just go to the gmane website and look around
04:38:46 <shapr> edwardk: necessity
04:38:49 <edwardk> fair nuff
04:38:50 <shapr> dons: ok
04:38:58 <bringert> shapr: I adding stuff to newcgi, trying to get as much as possible in before GHC 6.6 :-)
04:39:12 <shapr> bringert: So NewCGI got into GHC?
04:39:17 <bringert> yep
04:39:21 <shapr> spiffy!
04:39:22 <bringert> well, extralibs
04:39:24 <dons> shapr, you're in the states for good now?
04:39:32 <shapr> Yup.
04:39:41 <dons> wow!
04:39:43 <edwardk> shapr: was looking for you a couple of weeks back to talk to you about 'codependent' types, but have since resolved the issue ;)
04:39:50 <edwardk> shapr: whereabouts?
04:40:01 <shapr> Alabama at the moment. Aren't you in Michigan or something?
04:40:04 <SamB> ack, my shoes smell like they've been in the creek
04:40:06 <edwardk> yeah
04:40:28 <bringert> shapr: it's taken over the Network.CGI name. now there is some messiness now because of the fact that it can't do that on older systems where there is a Network.CGI in the network package
04:40:49 <edwardk> quite a long unicycle ride from alabama ;)
04:40:50 <shapr> NewCGI is better, I'm glad it's taking over.
04:40:54 <shapr> edwardk: truly
04:41:06 <dcoutts__> shapr: well how am I going to meet up now? :-)
04:41:13 <bringert> hmm, there should be a flag for ghc that warns if your type signatures could be more general
04:41:17 <dcoutts__> shapr: perhaps if dons and I get out paper accpeted...
04:41:18 <edwardk> shapr: a money thing? visa thing? job thing?
04:41:30 <edwardk> inquiring minds want to know ;)
04:41:36 <dcoutts__> shapr: the conference is up in MN.
04:41:36 <shapr> Especially since none of my friends have a Presta valve pump. It seems that schrader valves are the norm here in the USA.
04:41:40 <SamB> they probably deported him for not making enough money
04:41:42 <vincenz> hey shapr
04:41:47 <shapr> edwardk: Pretty much all of those connected.
04:41:50 * SamB leaves for school
04:41:51 <shapr> SamB: yup
04:41:55 <edwardk> shapr: fair nuff
04:42:12 <shapr> dcoutts__: Yeah, maybe at the next US Haskell conference :-)
04:42:22 <edwardk> shapr: you going to icfp?
04:42:29 <shapr> There's a small chance that I will.
04:42:35 <edwardk> kk
04:42:36 <shapr> Not worth depending on though.
04:42:36 <bringert> that's progressive sweden for you, deport people if they don't make enough money
04:42:52 <vincenz> bringert: swedish?
04:43:01 <edwardk> bringert: well, it'll bring up the per capita income ;)
04:43:05 <bringert> vincenz: I'm swedish, yeah
04:43:11 <Igloo> Have dcoutts__ and shapr met before?
04:43:18 <vincenz> bringert: how does a phd student fit in such a system?
04:43:20 <bringert> edwardk: but not the total GDP
04:43:23 <vincenz> bringert: they barely make any money!
04:43:25 <shapr> Igloo: At AngloHaskell?
04:43:30 <edwardk> i need to get over to sweden if only to meet all my relatives
04:43:31 <bringert> vincenz: they don't deport citizens
04:43:32 <Igloo> Good point  :-)
04:43:33 <bringert> yes
04:43:34 <bringert> yet
04:43:35 <ndm> shapr: have registered hoogle on gmane now
04:43:35 <shapr> Igloo: You were there too :_)
04:43:35 <dcoutts__> Igloo: you mean my 3rd personality?
04:43:48 <shapr> ndm: thanks!
04:43:50 <vincenz> bringert: shame, if you're gognna do something, do it good
04:43:56 <dcoutts__> Igloo: I know that dcoutts met shapr, not sure about dcoutts__ though.
04:43:59 <Igloo> shapr: It was more than 6 minutes ago, so I have no memory of it
04:44:03 * shapr grins
04:44:06 <dcoutts__> ha ha ha
04:44:40 <bringert> ndm mentioned making a webapp which runs lambdabot, I was thinking that I might do that if I get the time
04:44:46 <dcoutts__> shapr: so is that a change of jobs/clients too or you've retained them?
04:44:51 <shapr> bringert: I spoke to migrationsverket, my case officer said that if I want a permanent permit in Sweden there are only two approaches, marry someone or own my own business and stay profitable.
04:45:01 <vincenz> Igloo: I know the feeling, people'll come up to me and I'll say "DAMN it's been a long time" and they'll respond "What, we had dinner on monday!"
04:45:03 <bringert> I've never hacked lambdabot, but it should be easy enough to interface right?
04:45:23 <shapr> dcoutts__: I've retained my clients so I won't starve.
04:45:32 <dcoutts__> shapr: oh good.
04:46:09 <bringert> shapr: what if you get a local job? that'll only get you a temporary permit?
04:46:14 <fasta> Hmm, foobar<-trace "Hey there!" (return ()) doesn't print anything, while in another stateful computation it did :?
04:46:18 <shapr> bringert: It was kinda irritating, I had plenty of employment opportunities but couldn't accept them.
04:46:25 * beelsebob yawns
04:46:28 <beelsebob> yummy lunch
04:46:32 <shapr> bringert: Yup, a job gets you only a max of 1.5 years permit.
04:46:34 <dcoutts__> shapr: damn, lambda consulting already exists, we'll need a different name
04:46:34 <beelsebob> fasta: no tracing working?
04:46:37 <ndm> fasta: () <- trace "hey there" (return ())
04:46:43 <shapr> bringert: and I think it's bound to that job only.
04:46:54 <bringert> dcoutts__: how about lazy consulting?
04:46:57 <shapr> hah
04:47:01 <eivuokko> lol
04:47:03 <dcoutts__> hah ha
04:47:05 <dcoutts__> nice
04:47:08 <tibbe> shapr, there's a third way hiding from the police usually works better than trying to play by the rules :/
04:47:10 <fasta> ndm: Thank you :)
04:47:14 <vincenz> dcoutts__: consulting bananas
04:47:17 <bringert> might not get you a lot of gigs though
04:47:33 <dcoutts__> http://lambdaconsultants.com/
04:47:35 <lambdabot> Title: lambda consulting
04:47:39 <bringert> vincenz: you mean like consulting with bananas, lenses and barb wire?
04:47:40 <shapr> tibbe: I could probably have done that, but it's against my principles.
04:47:45 <vincenz> bringert: yeah
04:47:46 <dcoutts__> bunch of CS people from chicago uni
04:48:10 <AStorm> Consulting for lambda probe design? ;-)
04:48:12 <vincenz> heh: "We accept only a few projects per year so we can craft each one to the client's needs, and assure top quality results."
04:48:17 <tibbe> shapr, I didn't want to suggest it as a good approach, I was just whining ;)
04:48:26 <beelsebob> fasta: is your tracing working now?
04:48:28 * tibbe thinks that lambda is an ugly symbol
04:48:29 <bringert> if you're going to cheat the system, it might be better to do it in a nice way, come as a tourist and leave often enough
04:48:46 <foxy> in one analysis verbs are given type |S|, nouns are given type |NP|, and other syntactic categories are given types such as |NP -> NP|, which is an adjective. Comparing the phrases "golden and white socks" and "golden socks and white socks" in the first sentence "and" is of the type |(NP -> NP) -> (NP -> NP) -> (NP -> NP)| and in the second sentence it is of type |NP -> NP -> NP|, so it...
04:48:47 <foxy> edwardk, I have a question you or your linguist friends might be able to help me with...
04:48:49 <foxy> ...would seem it is of type |forall a.a -> a -> a|. On the semantic side, the "and" implementation must take each argument and 'fork' it to each of its arguments. Can anyone find a way to implement this in Haskell+ ?
04:49:24 <fasta> beelsebob: yes, but I don't understand the difference between the case with an if and without, I would have expected the same behaviour.
04:49:32 <edwardk> foxy: whats up?
04:49:35 <AStorm> tibbe: lambda looks really nice, compare that to small omega
04:49:48 <bringert> foxy: it's not really forall a, you can use conjunction on conjuctions for example
04:49:54 <beelsebob> fasta: which case with an if and which case without?
04:50:06 <foxy> edwardk: see just above
04:50:16 <edwardk> reading
04:50:18 <bringert> foxy: it's more like "and" is overloaded I think
04:50:25 <edwardk> and is very very heavily overloaded.
04:50:43 <bringert> and :: Conjunctible a => a -> a -> a
04:50:53 <edwardk> and parsing requires a lot of context, ask a syntactician about the amount of semantics of and some time. ;)
04:51:14 <foxy> well my current solution is to do on the fly metaprogramming to read the function type and generate sufficient abstractions to fork the arguments
04:51:43 <edwardk> foxy: what context is this being used in, natural language processing?
04:51:50 <foxy> edwark: yes
04:52:16 <bringert> in GF, we'd normally have different Ands (And_NP, And_S etc), which have the same linearization
04:52:23 <edwardk> foxy: what problem domain, where is the verbage coming from?
04:52:59 <edwardk> plus with and you get weird problems in english like first conjunct agreeent, so those signatures are a little too general
04:53:11 <bringert> foxy: maybe you want to have a look at GF, http://www.cs.chalmers.se/~aarne/GF/
04:53:13 <lambdabot> Title: GF Version 2.6
04:54:16 <bringert> with GF you can handle the weirdnesses of the individual langages (like the agreement edwardk mentions) independently of the abstract syntax
04:54:25 <edwardk> GF?
04:54:33 <foxy__> I just disconnected, did anyone say anything to me after "foxy: maybe you want to have a look at GF, http://www.cs.chalmers.se/~aarne/GF/" ?
04:54:33 <lambdabot> Title: GF Version 2.6
04:55:00 <foxy__> edwark: general natural language parsing...
04:55:07 <edwardk> ah
04:55:27 <deadbeef> >>> Emerging (2 of 344) sys-devel/gettext-0.15 to /
04:55:29 <deadbeef> here we go
04:55:35 <tibbe> hah
04:55:37 <tibbe> 3 days
04:55:38 <edwardk> foxy: problem is until you start constraining the problem to specific sources and usage patterns its too broad to make much headway on it seems
04:55:41 <velco> lol
04:56:06 <tibbe> deadbeef, why the complete rebuild, gcc 41?
04:56:09 <tibbe> 4.1
04:56:09 <edwardk> and parsing feeds back so heavily from semantics and content, that it can't be solved really on its own
04:56:34 <deadbeef> tibbe: it's a few months i don't upgrade
04:56:41 <foxy__> edwardk, OK, well I want to be able to define one |and| to parse "golden and white socks" and "golden socks and white socks"
04:57:09 <foxy__> I was wondering whether with advances in typing this could be done in Haskell
04:57:10 <bringert> that's tricky I think
04:57:18 * tibbe wants a pair of golden socks...
04:57:44 <bringert> foxy__: is a type class good enough for you? i.e. do you consider and ad hoc overloaded and to be one and?
04:57:54 <bringert> eh, too many ands there
04:58:05 <foxy__> bringert: that would do...
04:58:11 <bringert> foxy__: is a type class good enough for you? i.e. do you consider an ad hoc overloaded "and" to be one "and"?
04:58:17 <bringert> that's what I meant to say
04:58:37 <bringert> class Andable a where and :: a -> a -> a
04:58:41 <foxy__> bringert: if the type class automagically generates sufficient abstractions to fork arguments
04:58:50 <edwardk> tibbe: i understand the desire. and i'm sure you could do a simple syntax tree model that allowed for conjunctions, but i'm not sure it will be very useful. classification of words to those roles is something we disambiguate from context. go back and read all my sentences without the context that we're talking about 'and' as a noun, and most derivations crash ;)
04:59:41 <bringert> foxy__: you would have one instance for each word class, so that should work
04:59:46 <edwardk> so you're looking at lots of possible parses.
05:00:10 <AStorm> Now, haskell has the best type system I've ever seen yet.
05:00:16 <bringert> yeah, I'm not considering parsing here, rather semantics, and maybe generation
05:00:42 <foxy__> (and :: a -> a -> a) (white :: NP -> NP) ->B (\x y.and (x y) white (y)) :: (NP -> NP) -> (NP -> NP)
05:00:56 <edwardk> semantically, you can make a clean definition for conjunction i think, no problem.
05:00:57 <tibbe> edwardk, I don't want to parse sentences, foxy__ does, I just want the socks... ;)
05:01:04 <edwardk> tibbe: hehehe
05:01:24 <foxy__> (and :: a -> a -> a) (white :: NP -> NP) ->B (\x y.and (x y) (white y)) :: (NP -> NP) -> (NP -> NP)
05:01:32 <bringert> foxy__: what is it you want to use this for?
05:02:15 <foxy__> see I can write that function, but then for "golden and white socks": (and :: a -> a -> a)(white socks :: NP) ->B (\x.and x (white socks)) :: NP -> NP
05:02:29 <foxy__> bringert: World Domination!!!
05:02:35 <bringert> ah
05:02:39 <foxy__> bringert: machine translation
05:02:53 <bringert> so you need parsing then I take it?
05:03:01 <foxy__> bringert: yes
05:03:29 <bringert> foxy__: I really suggest looking at GF then, if you want to do grammar-based translation and like Haskell's type system
05:03:37 <foxy__> argh, last thing was "golden socks and white socks"
05:03:38 <bringert> GF is based on constructive type theory
05:04:15 <edwardk> foxy: the problem is your types won't alway be just noun phrases or adjectives. plus you can't stop at words, you need morphemes, and morphemes should form islands of meaning but they don't. a functional programmer is one who writes functional programs. Not a programmer who functions.
05:04:29 <edwardk> foxy: so its very hard to parse syntax at that level alone.
05:04:51 <AStorm> foxy__: try: "He did that and his brain got nuked."
05:05:04 <AStorm> If you can parse it... now that's an accomplishment.
05:05:18 <edwardk> foxy: so words don't form the nice little structures you learn in english 101 or ling 201 =
05:05:31 <foxy__> AStorm: easy, if |and :: S -> S -> S|
05:05:32 <edwardk> astorm: thats coz of an elided 'then' =)
05:06:01 <edwardk> and doesn't just mean conjunction though., in that case it implies causality from context.
05:06:17 <edwardk> just like 'but' means and, but has a different connotation of contrast.
05:06:19 <AStorm> edwardk: yep :>
05:06:30 <foxy__> edwardk, but that's not surface structure, that gets dealt with during semantic analysis
05:06:41 <AStorm> Not only, also "that" w/o reference.
05:06:46 <AStorm> Also past tenst.
05:06:51 <AStorm> Yes.
05:07:03 <edwardk> sure, but there are a lot of implicit coercions that need to be made. things that wouldn't BE noun phrases but for the surounding conjunction.
05:07:14 <edwardk> forced agreements, etc.
05:07:38 <foxy__> edwardk, those can be dealt with in a Lambek derivative by using lexical rules
05:07:38 <AStorm> E.g: "He tried that and although he failed, it wasn't so bad"
05:07:45 <AStorm> Now try to coerce that :P
05:08:09 <foxy__> edwardk, lexical rules take Lambek past context-free
05:08:36 <edwardk> i'm not a syntax guy, i just treat it as a minefield :)
05:09:16 <foxy__> well, I realise that NLP is a *difficult* thing, my question really is just if it is possible to overload and, and if not what technology is required :D
05:09:21 <edwardk> my only real linguistic interests are admittedly in minimalist syntax (at a really abstract level to see how deep the rabit hole goes), phonology and a bit of morphology.
05:10:03 <edwardk> the phonology stuff came from the fact that i used to do speech synth and recognition stuff, later on wrote some lipsyncing stuff as lightweight recognition
05:10:13 <edwardk> gah
05:10:15 <edwardk> closed window
05:10:45 <sieni> foxy__: Neuro-Linguistic Programming?
05:10:48 <bringert> foxy__: I think the overloading you want is possible, and shouldn't make parsing wore than it already is. let us know how it works out
05:11:16 <foxy__> I can parse all sorts of nasty structures with implementations for words written in Haskell, except for conjunctions, which I need to do in my meta toy lambda calculus
05:12:09 <edwardk> *nods*
05:12:51 <foxy__> @where paste
05:12:52 <lambdabot> http://paste.lisp.org/new/haskell
05:13:23 <edwardk> The only real interest in parsing I have has to do with large scale data mining for connections between entities and people. some former coworkers of mine went off to work on that sort of thing
05:13:32 <foxy__> is there a different paste site?
05:13:43 <edwardk> before they realized the lack of commercial viability of their product ;)
05:13:56 <edwardk> there is the rafb one iirc
05:14:01 <foxy__> edwardk: ah, I want to be able to mine biological articles for gene networks
05:14:14 <foxy__> @where rafb
05:14:15 <lambdabot> I know nothing about rafb.
05:14:21 <edwardk> foxy: heh, someone here on campus has been doing something similar.
05:14:26 <foxy__> @google rafb
05:14:29 <lambdabot> http://www.rafb.net/paste/
05:14:29 <lambdabot> Title: Nopaste
05:15:12 <edwardk> gah i have to go teach in an hour or two. i should figure out whats in the book i'm teaching ;)
05:15:17 <edwardk> bbiab
05:16:20 <foxy__> http://www.rafb.net/paste/results/JSZTHa97.html is how I'm implementing and-type things at the moment
05:16:56 * dcoutts__ notes that hackell-consultants.* is available
05:17:08 <dcoutts__> ie .net .com .eu etc etc
05:17:27 <deadbeef> .va ?
05:17:38 <foxy__> dcoutts__ what about *haskell-consultants* ;)
05:17:49 <dcoutts__> bah
05:17:55 * dcoutts__ typos
05:18:46 <Igloo> functional-consultants might be better
05:19:10 <foxy__> sieni, heh, natural language parsing ;)
05:19:24 <foxy__> bringert: how do you reckon I could do it?
05:19:40 <kowey> natural language processing, rather? us generation folk are nlp too :-)
05:19:50 <dcoutts__> Igloo: well that's available too
05:20:00 <foxy__> s/processing/parsing/
05:20:04 * dcoutts__ prefers the Haskell name
05:20:19 <lokadin> parsec
05:20:49 <Igloo> Fair enough  :-)
05:20:58 <lokadin> i'm doing an artificial human-to-human language parser right now actually
05:21:10 <Igloo> Anyway, the names the easy bit. Just wait until you get to the logo  :-)
05:21:19 <kowey> is that the same as machine translation?
05:21:31 <dcoutts__> Igloo: hah
05:21:48 <foxy__> lokadin: what sort of formalism are you using?
05:21:49 <tibbe> Igloo, don't include a lambda in it
05:21:58 <lokadin> foxy__: formalism/
05:22:00 <lokadin> ?
05:22:02 <dcoutts__> but it'd have to include a lambda in it!
05:22:21 <Igloo> Have yo considered upsilon? A most underused Greek letter
05:22:24 <dcoutts__> \lambda haskell -> consultancy
05:22:28 <lokadin> foxy__: i actually have my first linguistics lecture in an hour
05:22:30 <lokadin> lol
05:22:49 <foxy__> lokadin: ah. well linguistics and the lambda calculus mix well...
05:23:02 <lokadin> i guess i'll find out :)
05:23:22 <kowey> yeah, formal semantics is fun
05:23:23 <lokadin> lojban --the language i'm working on-- is actually really easy to make a parser for
05:24:13 <lokadin> i mean i can already take words out of a string of the language containing no spaces
05:24:32 <foxy__> lokadin, yeah, I've had a look at lojban (well, descriptions in english)
05:24:44 <bringert> foxy__: I think a type class would work for you
05:24:47 <vincenz> lokadin: o.O
05:25:37 <lokadin> yea, it's made so it's easy for a computer to decode speech ( or easier rather) as it doesn't have to worry about pausing
05:26:10 <lokadin> and i've only been working on it maybe a day and a half seriously
05:26:20 <lokadin> so parsec is really great
05:26:37 * shapr hugs parsec
05:26:56 <bringert> that reminds me that I wanted to add a function to parsec
05:26:59 <foxy__> bringert: so if I say Andable a => Andable (a -> a) where fork a = \x -> and a x do you think that would work?
05:27:02 <lokadin> .ui.u'i.i'i
05:27:37 <foxy__> @yarr
05:27:37 <lambdabot> This is the END for you, you gutter-crawling cur!
05:27:40 <bringert> foxy__: something like that yeah, without knowing anything about the specifics of what you are doing
05:27:42 <foxy__> something like that
05:28:04 <JaffaCake> kzm_: please send me that program, thanks
05:28:26 <foxy__> bringert, I need to generate abstractions, depending upon the type of the first argument to and (is it (NP), (NP -> NP), ((NP -> S) -> NP)
05:30:41 <bringert> foxy__: what is the relation between the type of the first argument and the type of the abstraction?
05:30:56 <shapr> @arr
05:30:57 <lambdabot> Shiver me timbers!
05:31:04 <shapr> coi lokadin .i ma nuzba
05:31:21 <shapr> hiya JaffaCake
05:31:46 * JaffaCake waves to shapr
05:32:14 <JaffaCake> excellent, lambdabot has a pirate plugin?  is it talk like a pirate day yet?
05:32:28 <JaffaCake> seem to remember that was later in Sept
05:34:18 <beelsebob> hehe, I wonder if that day has a significant impact on global warming
05:34:32 <JaffaCake> lol
05:35:39 <beelsebob> or in fact if the FSM is angered too much when we switch back
05:36:40 <beelsebob> @. elite arr
05:36:40 <lambdabot> a|-|oY /\/\4+EYS
05:38:26 <tibbe> JaffaCake, I submitted a documentation patch a while ago to the cvs list, just wanted to check so that it hasn't dissapeared.
05:38:59 <tibbe> JaffaCake, I need to know if it needs more work :) otherwise I could continue with something else
05:39:13 <JaffaCake> tibbe: I thought I committed it... but it's entirely possible I lost it instead :)  I'll take a look
05:40:27 <dcoutts__> hia JaffaCake
05:40:37 <JaffaCake> hi there
05:41:06 <foxy__> bringert: say the first argument is of type (NP -> NP), then the abstraction has to take an NP and fork it to the first argument and to the (not yet applied) second argument
05:42:27 <foxy__> bringert: (and :: a -> a -> a)(golden :: NP -> NP) -> (\x y.and (x y) (golden y) :: (NP -> NP) -> (NP -> NP)
05:43:09 <JaffaCake> tibbe: committed "Add more documentation to System.Posix.Files" on 13 Aug... is that the one you mean?
05:43:47 <foxy__> bringert: but also (and :: a -> a -> a)(golden socks :: NP) -> (\x.and x (golden socks) :: NP -> NP)
05:44:40 <JaffaCake> dcoutts_: you might want to mosy on over to #ghc
05:44:40 <bringert> sure, since and :: Andable a => a -> a -> a, all you do is apply "and"
05:47:11 <shapr> There's a GHC irc channel now?
05:49:32 <foxy__> bringert, I just can't see how to do it :(
05:49:44 <dcoutts__> shapr: news to me too
05:49:57 <foxy__> bringert: implement the class instance, that is...
05:50:42 <bringert> foxy__: ok, I'll try writing it
05:50:59 <foxy__> @karma+ bringert
05:51:00 <lambdabot> bringert's karma raised to 10.
05:51:22 <shapr> @karma+ bringert -- for Hope, NewCGI, Haskell-xhtml
05:51:23 <lambdabot> bringert's karma raised to 11.
05:51:32 <shapr> @karma+ bringert -- one just isn't enough
05:51:33 <lambdabot> bringert's karma raised to 12.
05:52:03 <shapr> @karma+ bringert -- for parsedate
05:52:04 <lambdabot> bringert's karma raised to 13.
05:54:43 <shapr> Hi lane
05:54:59 * beelsebob pokes shapr with sticks
05:55:01 * bringert blushes
06:07:33 <foxy__> anyone know how to get german (Fraktur) fonts in LateX math mode (I \usepackage{amsfonts})
06:08:30 <Cale> \mathfrak ?
06:10:26 <foxy__> that works
06:10:28 <foxy__> :)
06:12:09 <bringert> foxy__: ah, now I see the problem, Andable must be a mutli-parameter class
06:12:23 <bringert> sicne you can use "and" between things of different type
06:12:46 <foxy__> bringert, um, the two arguments are always going to be of the same type at any given use
06:13:11 <foxy__> just different uses could have different types
06:14:54 <bringert> golden `and` white socks
06:15:14 <bringert> golden :: NP -> NP; white socks :: NP
06:15:16 <bringert> right?
06:15:36 <foxy__> bringert: I'm parsing that as ((and golden white) socks)
06:15:36 <bringert> ah, of course, (golden `and` white) socks
06:15:36 <Cale> that just seems misparsed
06:17:00 <bringert> ok, I think I did it
06:17:09 <bringert> @where paste
06:17:09 <lambdabot> http://paste.lisp.org/new/haskell
06:17:28 <lisppaste2> bringert pasted "and" at http://paste.lisp.org/display/25530
06:18:10 <bringert> foxy__: with that "(golden `and` white) socks" works, as does "golden socks `and` white socks"
06:18:23 <foxy__> ooh, looking at it now
06:22:26 <foxy__> bringert, *clap* *clap*
06:22:46 <tibbe> JaffaCake, ah yes, I must have missed it somehow even though I looked for it on the list.
06:22:52 <foxy__> bringert, OK, unfortunately there are almost infinite number of possible argument types to and
06:23:14 <foxy__> bringert, well done, thanks
06:23:49 <edwardafk> well, you can try building some of them up with some creative instancing declarations
06:23:50 <bringert> foxy__: you can change the Andable AP instance to: instance Andable a => Andable (a -> a) where
06:24:00 <edwardafk> yeah
06:24:43 <foxy__> bringert, awesome, now I can move implementation into dynamically-loaded code snippets for each word!!
06:25:04 <foxy__> @karma+ Haskell -- NLP goodness
06:25:04 <lambdabot> Haskell's karma raised to 9.
06:25:52 <bringert> foxy__: it'd be fun to see what you end up with, feel free to e-mail me at bjorn@bringert.net
06:26:24 <foxy__> bringert: OK, the code is broken at the moment, but I'll send you a copy when I get it workable...
06:27:46 <kzm> @seen JaffaCake
06:27:47 <lambdabot> JaffaCake is in #haskell and #ghc. I last heard JaffaCake speak 2m 49s ago.
06:28:10 <JaffaCake> kzm: hi
06:28:18 <JaffaCake> if you have that program, I'm interested
06:28:44 <kzm> Yes, I can tar it up.  It's a bit big and unwieldy, but I think the test case is relatively straightforward.
06:29:35 <kzm> Uses BS.Lazy, which may have something to do with it - although generally the situation has improved.  I can also try the 6.6 RC.
06:36:39 * beelsebob wonders what the current talk has to do with functional progarming
06:37:33 <dons> what's the current talk about?
06:37:41 <norpan> i see no current talk
06:37:51 <dons> i presume beelsebob's at a conference (?)
06:37:58 <norpan> aha
06:38:18 <beelsebob> dons: IFL
06:38:33 <beelsebob> he seems to be talking about some hardware description langague
06:38:38 <beelsebob> but it's in no way functional
06:38:45 <beelsebob> and I really wonder what the fuck is going on
06:38:54 <dons> heh
06:38:56 <norpan> what is the language called?
06:39:00 <beelsebob> Avon
06:39:02 <kzm> Thank god you brought your laptop :-)
06:39:04 <Syzygy-> @seen Syzygy-
06:39:05 <lambdabot> You are in #haskell. I last heard you speak just now.
06:39:12 <Syzygy-> :)
06:39:16 <Syzygy-> Just had to try it...
06:39:28 <Cale> @seen @seen
06:39:28 <lambdabot> I haven't seen @seen.
06:39:32 <kowey> hey foxy__: you're not worried about semantics, right?
06:39:32 <norpan> never heard of it
06:39:34 <beelsebob> kzm: that's been the way of a lot of talks
06:39:41 <beelsebob> but this one breaks all records
06:39:45 <Cale> @seen you
06:39:46 <lambdabot> I haven't seen you.
06:40:06 <Cale> Haha! I remain undetected!
06:40:07 <beelsebob> @seen a monkey
06:40:07 <lambdabot> I haven't seen a.
06:40:10 <beelsebob> boring!
06:40:29 <sek> --- you :Erroneous Nickname
06:40:33 <sek> thats strange
06:40:41 <kzm> @seen 'a simian'
06:40:41 <lambdabot> I haven't seen 'a.
06:40:46 * kzm sighs.
06:41:26 <beelsebob> @seen "a monkey"
06:41:26 <lambdabot> I haven't seen "a.
06:41:28 <beelsebob> damn
06:41:32 <beelsebob> ohhh, shiny new iMacs
06:42:03 <foxy__> kowey: I am, but the way it works one will be (and (golden socks_1) (white socks_1) and the other will be (and (golden socks_1) (white socks_2)) :)
06:42:06 <beelsebob> and mac minis
06:42:10 <xerox> Yuck, 24".
06:42:11 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:17 <xerox> Another message!!
06:42:18 <beelsebob> xerox: what's wrong with 24"?
06:42:37 <xerox> It's "new".
06:42:49 <xerox> The biggest available was 20", the one I have here.
06:43:00 <beelsebob> hahahahaha
06:43:02 <kowey> foxy__ : would this also deal with "drinking and driving is a bad idea"?
06:43:09 <beelsebob> so it's yuck 24" because you can't have one
06:43:24 <xerox> :D
06:43:45 <beelsebob> in which case... yuck 24"
06:43:50 <beelsebob> I have a 20" cinema display
06:43:55 <foxy__> kowey: yes (is (and drinking driving) (det idea [bad])
06:44:14 <kowey> yay!
06:44:30 <foxy__> :D
06:44:30 <tibbe> xerox: does a 20" improve your productivity, I'm stuck with just a 14" latop currently
06:44:40 <beelsebob> tibbe: yes
06:44:45 <xerox> tibbe: I'm not sure, but it's great for movies. =P
06:44:54 <beelsebob> you are able to have latex, bibtex and two terminals neatly arranged
06:45:00 <beelsebob> so that you can see everything easily
06:45:09 <xerox> Hm yeah, there's much space :=)
06:45:35 <xerox> Sometime I fint suprising that I move a window on the side and it doesn't overlap with the one behind... "oh, space."
06:45:38 <xerox> *find
06:45:44 <beelsebob> hehe
06:45:54 <beelsebob> also... HD resolution
06:45:58 <beelsebob> at least for 720p
06:46:14 <sek> the F9 key a 13.3" macbook works like a charm:p
06:46:26 <sek> s/key a/key and a/
06:46:48 <xerox> :)
06:47:17 <sek> even though, i currently have 2 19" babies infront of me
06:47:20 <sek> plenty of space
06:47:38 <tibbe> xerox, I can't even fit 2 emacses next to each other, I would like to run inf-haskell and my editing buffer next to each other :(
06:47:59 <foxy__> C-x 3
06:49:18 <tibbe> foxy__, yes but they're not 80 chars wide each
06:49:25 <tibbe> so I don't see all my code
06:49:42 <tibbe> 1280x1024 would be alright for two emacses, I've tried
06:49:46 <foxy__> C-x 2?
06:49:49 <tibbe> 1024x768 is not enough
06:50:07 <tibbe> foxyy_, that's what I do now but seeing more code at once helps my thinking
06:50:37 <tibbe> especially since haskell code is short enough so you can get almost all the relevant stuff on screen at once
06:50:56 <tibbe> btw I think that's one big advantage for non-verbose languages
06:51:08 <foxy__> tibbe: I agree entirely, especially with daft indentation of emacs, I have 1024x768 and get 62 cols with C-x 3
06:51:14 <tibbe> seing alot of code keeps you from having to remember it while looking at something else
06:51:34 <xerox> Write small modules :)
06:51:55 <tibbe> foxy__, 62 is a bit too few for some of the code I write, what's daft indentation?
06:52:39 <foxy__> Well, I've seen monadic code that just indents say 4 spaces on a new line, but emacs insists on aligning the next line with 'do'
06:53:19 <xerox> foxy__: I usually indent the first line manually, and then work with that.
06:53:44 <foxy__> really_long_foo x y = do
06:53:45 <foxy__>                                     a <- really_long_bar x
06:53:47 <foxy__>                                     return $ y a
06:53:48 <foxy__>                
06:53:50 <foxy__>                
06:53:57 <foxy__> xerox: I'll try that...
06:53:57 <Cale> uhh
06:53:58 <deadbeef> > let s [] = []; s (x:xs) = s [ y | y <- xs, y < x ] ++ [x] ++ s [ y | y < xs, y >= x ] in s [ 1, 3, 2, 5, 4 ]
06:54:00 <lambdabot>  Not in scope: `y'
06:54:03 <deadbeef> omg
06:54:11 <Cale> that's not aligned :)
06:54:12 <tibbe> if I put do on the first line by itself my emacs only idents 4 spaces
06:54:12 <deadbeef> ops
06:54:18 <deadbeef> > let s [] = []; s (x:xs) = s [ y | y <- xs, y < x ] ++ [x] ++ s [ y | y <- xs, y >= x ] in s [ 1, 3, 2, 5, 4 ]
06:54:19 <lambdabot>  [1,2,3,4,5]
06:54:35 <xerox> deadbeef: quicksort!
06:54:46 <foxy__> deadbeef, now do it with inplace updates!!!
06:54:48 <foxy__> @yarr
06:54:48 <lambdabot> Avast!
06:54:51 <Cale> > let s [] = []; s (x:xs) = s l ++ [x] ++ s g where (l,g) = partition (<x) xs in s [ 1, 3, 2, 5, 4 ]
06:54:53 <lambdabot>  [1,2,3,4,5]
06:54:54 * xerox shoots foxy__ 
06:55:06 <dcoutts__> JaffaCake: do you know if there is any concensus on module namespace for gzip/bzip? should I use Data.Codec.* or Data.Encoding.*? This is taken from your and Malcolm Wallace's proposals.
06:55:25 <xerox> @slap paolino
06:55:25 * lambdabot smacks paolino about with a large trout
06:55:36 <dcoutts__> JaffaCake: I'm writing gzip/bzip bindings for BytrString.Lazy
06:55:44 <tibbe> Cale, I really like the code improving properties of #haskell, post a snippet and it will improve automatically
06:55:53 <Cale> :)
06:55:59 <tibbe> Cale, should be a lambda bot module really
06:56:03 <xerox> Is it a thanks tibbe ? :D
06:56:05 <dons> heh
06:56:08 <Cale> @improve
06:56:08 <lambdabot> Unknown command, try @list
06:56:21 <tibbe> xerox: yeah :D
06:56:24 <Syzygy-> Will I regret it if I say @list?
06:56:31 <Cale> @list
06:56:32 <lambdabot> list [module|command]. Where modules is one of:
06:56:32 <lambdabot> babel base bf compose dice dict djinn drhylo dummy elite eval fact free fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system
06:56:32 <lambdabot> tell todo topic type undo unlambda url version vixen where
06:56:36 <Syzygy-> Ah.
06:56:40 <foxy__> @djinn ((a -> b) -> a) -> a
06:56:41 <lambdabot> -- f cannot be realized.
06:56:48 <JaffaCake> dcoutts__: as far as I'm aware, the most canonical layout proposal is http://darcs.haskell.org/ghc/libraries/docs/lib-hierarchy.html
06:56:49 <kzm> dcoutts__, can I access a .gz directly as BS.Lazy?
06:56:56 <xerox> improve = compose pl djinn
06:56:56 <xerox> :P
06:57:00 <AStorm> Huh?
06:57:06 <dcoutts__> kzm, that's the idea
06:57:11 <JaffaCake> try again:  http://darcs.haskell.org/ghc/libraries/doc/lib-hierarchy.html
06:57:14 <lambdabot> Title: Haskell Library Hierarchy, http://tinyurl.com/erv8b
06:57:21 <dcoutts__> kzm, gunzip :: ByteString -> ByteString
06:57:29 <dcoutts__> JaffaCake: ta.
06:57:34 <foxy__> @compose pl djinn Eq a => a -> a -> Bool
06:57:35 <lambdabot> Cannot parse command
06:57:49 <JaffaCake> Codec.Compression.Gzip
06:58:04 <foxy__> @compose pl djinn  [a] -> [[a]]
06:58:05 <lambdabot> (line 1, column 1):
06:58:05 <lambdabot> unexpected "-"
06:58:05 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
06:58:05 <dcoutts__> JaffaCake: ok
06:58:15 <kzm> Hmm... I want :: FilePath -> ByteString, but I guess that's fairly trivial to implement equally efficienty.
06:58:31 <dcoutts__> kzm, fmap gunzip . readFile
06:58:50 <foxy__> @compose pl djinn a -> a
06:58:50 <lambdabot> f = id
06:58:57 <norpan> gunzip? :)
06:59:02 <Cale> fmap gunzip readFile
06:59:07 <Cale> er, no
06:59:08 <kzm> dcoutt__, there may be a performance advantage to block sizes?  Perhaps esp. with bzip?
06:59:08 <Cale> hehe
06:59:11 <tibbe> what does djinn do?
06:59:15 <Cale> readFile takes a parameter :)
06:59:23 <foxy__> @djinn [a] -> [[a]]
06:59:23 <lambdabot> -- f cannot be realized.
06:59:33 <foxy__> @karma- djinn
06:59:33 <lambdabot> djinn's karma lowered to -2.
06:59:36 <dcoutts__> kzm, there will be convenience versions and ones with more parameters to fiddle with.
06:59:38 <foxy__> @slap djinn
06:59:38 * lambdabot smacks djinn about with a large trout
06:59:51 <AStorm> @help djinn
06:59:52 <lambdabot> djinn <type>.
06:59:53 <lambdabot> Generates Haskell code from a type.
06:59:53 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
06:59:57 <AStorm> Hmm.
07:00:16 <foxy__> @djinn (a -> b -> b) -> b -> [a] -> [b]
07:00:16 <lambdabot> -- f cannot be realized.
07:00:30 <AStorm> Why do you want djinn to resolve ambiguous code?
07:00:42 <tibbe> I know lennart talked about who everything comes easily ones you have the type more than on one occasion
07:00:49 <tibbe> s/who/how
07:00:55 <foxy__> @djinn Bool -> Bool -> Bool
07:00:55 <lambdabot> f a b =
07:00:55 <lambdabot>   case a of
07:00:55 <lambdabot>   False -> b
07:00:55 <lambdabot>   True -> False
07:01:13 <foxy__> @compose pl djinn Bool -> Bool -> Bool
07:01:13 <lambdabot> (line 3, column 11):
07:01:13 <lambdabot> unexpected ">" or "-"
07:01:13 <lambdabot> expecting variable, "(", operator or end of input
07:01:33 <foxy__> @compose pl djinn (Bool -> Bool -> Bool)
07:01:33 <lambdabot> (line 3, column 11):
07:01:33 <lambdabot> unexpected ">" or "-"
07:01:33 <lambdabot> expecting variable, "(", operator or end of input
07:01:42 <foxy__> @help compose
07:01:42 <lambdabot> . <cmd1> <cmd2> [args].
07:01:42 <lambdabot> . [or compose] is the composition of two plugins
07:01:42 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
07:01:43 <norpan> why won't djinn just reply f a b = False?
07:02:03 <norpan> does it have to use the input parameters in some specific way?
07:02:05 <dons> it tries harder
07:02:10 <dons> yep
07:02:17 <foxy__> dons, is compose not working properly?
07:02:23 <AStorm> norpan: no. It tries to actually use the arguments
07:02:23 <AStorm> :>
07:02:36 <dons> foxy__: doesn't handle multiline results
07:02:39 <foxy__> ah
07:02:47 <dons> buglet of some sort
07:03:01 * foxy__ gets ready to duck
07:03:13 <foxy__> dons, looked at C-x C-f yet? %)
07:03:35 <dons> :P
07:03:46 <AStorm> @djinn [a] -> (a,as)
07:03:47 <lambdabot> -- f cannot be realized.
07:04:02 <AStorm> Huh.
07:04:07 <foxy__> @djinn [a] -> a
07:04:08 <lambdabot> -- f cannot be realized.
07:04:13 <tibbe> C-x C-f, I don't understand
07:04:23 <dfeuer> djinn?
07:04:29 <dons> @djinn List a -> a
07:04:29 <lambdabot> -- f cannot be realized.
07:04:31 <AStorm> tibbe: Emacs for open file.
07:04:32 <dons> ah well
07:04:36 <foxy__> tibbe: yi+gtk reference, I'm stuck
07:04:44 <kzm> JaffaCake, http://www.ii.uib.no/~ketil/toSM.tgz
07:04:59 <kzm> And lambdabot, you can stop trying to find the title :-)
07:05:01 <tibbe> foxy__, you want C-X C-f in yi?
07:05:10 <JaffaCake> kzm: thanks
07:05:29 <foxy__> tibbe: there's a deadlock in C-x C-f in yi+gtk (if dons applied my last patch)
07:05:32 <AStorm> Hmm, maybe the djinn isn't really all that magic.
07:05:43 <kzm> My pleasure!  I included the binaries I built with the different compilers, as well as -s output
07:05:56 <tibbe> foxy__: ah, never tried Yi
07:05:59 <tibbe> @where yi
07:06:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
07:06:11 <kzm> Also: generally, specifying a big heap in advance improves time, but not in this case.
07:06:12 <foxy__> @where yi+gtk
07:06:12 <lambdabot> darcs get http://www.scannedinavian.org/repos/yi/
07:06:14 * kzm shrugs.
07:06:15 <AStorm> @djinn Bool -> (Bool, Bool)
07:06:16 <lambdabot> f a =
07:06:16 <lambdabot>   case a of
07:06:16 <lambdabot>   False -> (False, False)
07:06:16 <lambdabot>   True -> (False, True)
07:06:40 <AStorm> @djinn [Bool] -> (Bool, Bool)
07:06:41 <lambdabot> f _ = (False, False)
07:06:41 <Cale> interesting solution :)
07:06:56 <Cale> @djinn-env
07:06:57 <lambdabot> data () = ()
07:06:57 <lambdabot> data Either a b = Left a | Right b
07:06:57 <lambdabot> data Maybe a = Nothing | Just a
07:06:57 <lambdabot> data Bool = False | True
07:06:57 <lambdabot> data Void
07:06:58 <kzm> Anway: back to - and I'd never  d a r e  to admit it to anybody else - object oriented Python programming.
07:06:59 <lambdabot> type Not x = x -> Void
07:07:00 <kzm> :-)
07:08:30 <fasta> How can I clear the *ghci* buffer in Emacs?
07:09:18 <foxy__> fasta: C-x k, C-x C-l ;; non-solution
07:09:35 <AStorm> As usual, select everything then delete.
07:09:36 <AStorm> :>
07:09:36 <AStorm> Or use some nice keyboard shortcut (can't remember)
07:09:37 <AStorm> @djinn [Bool] -> (Bool, Bool)
07:09:38 <lambdabot> f _ = (False, False)
07:09:47 <vincenz> hehe
07:09:51 <foxy__> *C-c l*
07:10:03 <AStorm> Now that's a nonsolution.
07:10:03 <AStorm> :P
07:10:04 <vincenz> or
07:10:14 <vincenz> C-s C-x L-c K-x M-a c
07:10:23 <AStorm> @djinn [Bool] -> (Bool, [Bool])
07:10:23 <lambdabot> f a = (False, a)
07:10:33 <fasta> C-x h C-k RET
07:10:38 <AStorm> Ugh.
07:10:54 <AStorm> I'd expect that to do something like (x,xs)
07:10:55 <AStorm> :>
07:10:59 <fasta> Emacs powah
07:11:21 <AStorm> vincenz: K? What kind of modifier is that?
07:11:27 <vincenz> AStorm: the kinded one
07:11:36 <AStorm> :P
07:11:39 <foxy__> M-x shell ; cd / ; rm -r *
07:11:51 <norpan> esc-meta-alt-ctrl-shift
07:11:59 <AStorm> foxy__: M-x eshell; rm -r /
07:12:10 <vincenz> C-e C-m C-a C-c C-s M-r M-e M-q M-u M-i M-r M-e M-s C-W C-A C-Y C-t C-o C-o...
07:12:48 <AStorm> But doesn't destroy my ESC and : like vim :>
07:12:51 <AStorm> (I use both)
07:12:57 <vincenz> for what?
07:13:03 <vincenz> C-V Esc
07:13:09 <vincenz> besides you can use : fine
07:13:16 <foxy__> you should be using Yi
07:13:16 <AStorm> For programming, sys admin, others
07:13:23 <vincenz> AStorm: where?
07:13:35 <AStorm> No, it is somehow broken, sometimes doesn't work :>
07:13:36 <vincenz> AStorm: those things are called terminals
07:13:47 <AStorm> Esp. ESC
07:13:54 <vincenz> Why do you need ESC -inside- emacs?
07:13:59 <vincenz> screen
07:14:01 <vincenz> vim
07:14:01 <AStorm> No, inside Vim.
07:14:03 <vincenz> CTRL+A c
07:14:08 <vincenz> AStorm: for what purpose?
07:14:18 <AStorm> To exit out of input mode.
07:14:23 <AStorm> p
07:14:24 <AStorm> :>
07:14:28 <vincenz> so how is that broken?
07:14:43 * vincenz scratches his head
07:14:45 <AStorm> It puts too much strain on one key.
07:14:47 <AStorm> :P
07:14:51 <vincenz> oh!
07:15:04 <AStorm> Also, :0,$s:whatever:whatevah:g isn't quite readable :>
07:15:15 * vincenz doesn't know why but his mostly strained key is the 'j'
07:15:26 <Cale>  :%s/.../.../g
07:15:39 <AStorm> Cale: that works too, except I use / too often.
07:15:43 <AStorm> (to bother escaping)
07:15:46 <vincenz> :%s|...|...|g
07:15:50 <vincenz> you can use any character
07:15:54 <Cale> or : or whatever :)
07:16:03 <vincenz> :%sC...C...Cg
07:16:17 <AStorm> THe % doesn't work? :P
07:16:24 <AStorm> (It starts from current place and down)
07:16:37 <tibbe> I have a tendency to misstreat my return key
07:16:44 <vincenz> AStorm: works fine
07:16:50 <AStorm> tibbe: not only you
07:16:51 <vincenz> :%s%...%...%g
07:17:06 <tibbe> I'm probably trying to emulate a type writer by hitting return harder to get that line feed sound
07:17:08 <Cale> 	%		equal to 1,$ (the entire file)	
07:17:15 <AStorm> :%s*ping*pong*g
07:17:17 <Cale> from the documentation on ranges
07:17:19 <AStorm> 0,
07:17:37 <AStorm> Still have to get to know more Vim.
07:17:42 <Cale> The first line is numbered 1 here
07:17:43 <AStorm> Too much vi on me :>
07:25:43 <foxy__> @type \f x -> x
07:25:45 <lambdabot> forall t t1. t1 -> t -> t
07:27:13 <AStorm> @type \f . x -> x
07:27:15 <lambdabot> parse error on input `.'
07:27:44 <AStorm> Just as I thought :>
07:28:04 <foxy__> @type \f -> (\x -> f (x x))(\x -> f (x x))
07:28:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
07:28:05 <lambdabot>    Expected type: t
07:28:28 <musasabi> Is the no threaded + prof GHC only for head or 6.6 too ?
07:28:45 <musasabi> Profiling applications that only work with -threaded is quite important.
07:29:46 <Igloo> It's for both
07:29:55 <musasabi> igh. That is serious :-(
07:30:20 <musasabi> How much work would fixing it be?
07:30:37 <musasabi> (and in the compiler or the rts?)
07:30:43 <Igloo> Simon says "Difficulty: Moderate (1 day)", and you have around 1 day to get the patch in  :-)
07:30:46 <Igloo> rts
07:33:56 <bringert> is there a way to tell ghc not to look for modules in in the current directory?
07:34:09 <Igloo> I don't think so
07:36:40 <bringert> is there a way to hack around that? I want to run a program in the directory where the sources for Text.XHtml are, and the program uses Text.XHtml (the installed version is the intention) to do some output. now runghc says  conflict: module `Text.XHtml' belongs to the current program/library
07:36:40 <bringert>     and also to package xhtml-2006.7.5
07:36:47 <CosmicRay> Igloo: any alpha update?
07:37:13 <Igloo> CosmicRay: Making some progress, but no result yet
07:37:38 <CosmicRay> bringert: with hugs, you can specify an alternate search path that doesn't include ".".  don't know if you can with ghc, but you might try.
07:37:40 <AStorm> Hey again, is there some predefined (contains) operator?
07:37:59 <AStorm> contains :: x -> [x] -> Bool
07:38:03 <sjanssen> @type elem
07:38:06 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:38:10 <CosmicRay> AStorm: there is now, in ghc 6.6.
07:38:15 <AStorm> Ah, thanks.
07:38:19 <CosmicRay> AStorm: Data.List.isInfixOf.  it is not in ghc 6.4 yet.
07:38:36 <musasabi> Igloo: looking at it the changes seem quite simple (just inserting locks), so I getting them at the release time is not so important to me as they can be fixed at any time on the 6.6 branch.
07:38:43 <CosmicRay> AStorm: MissingH has one as well in MissingH.List, and it's called contains.
07:38:44 <irgs> AStorm: you could just have hoogled for the type-signature you gave there, the first hit on that is elem ;)
07:38:50 <CosmicRay> AStorm: are you a python refugee too?
07:39:02 <CosmicRay> oh right, you want elem.
07:39:02 <AStorm> Yep.
07:39:16 <bringert> CosmicRay, Igloo: it seems that "-i" (without any paths) clears the search path, so that . is not in it
07:39:16 <CosmicRay> since you're looking for one element in a list, not for a sublist (or substring)
07:39:17 <bringert> thanks
07:39:22 <Igloo> musasabi: Yeah, that should be fine
07:39:30 <Igloo> bringert: Oh, fair enough
07:40:04 <fasta> http://www.comics.com/comics/workingdaze/archive/images/workingdaze2002714560906.jpg
07:41:44 <AStorm> If I was looking for a sublist, I'd use a list comprehension all right :>
07:42:04 <AStorm> (but there's probably something in the library for that too)
07:43:51 <Cale> http://www.marriedtothesea.com/090606/wheres-my-bird.gif
07:44:09 <fasta> What kind of attitude is that, we all know that Haskell has no library!
07:44:23 <AStorm> Blah blah :P
07:45:04 <AStorm> Yeah right, and you reimplement everything as it goes :P
07:45:05 * shapr blahs
07:45:14 <shapr> I had a library once.
07:45:23 <shapr> Cale: That's scary.
07:45:35 <AStorm> Poor bird.
07:45:37 * shapr explodes
07:45:47 <fasta> Poor shapr
07:46:07 <shapr> hoi fasta
07:46:22 <shapr> hoe gaat het?
07:46:55 <fasta> I am still not further than hej shapr, sorry :)
07:47:00 <fasta> er then
07:47:09 * shapr grins
07:47:19 <shapr> That's okay, you can speak southern to me now that I'm back in Alabama.
07:47:24 <shapr> Y'all come back now!
07:47:28 <mlh> ik gaat
07:47:39 <shapr> g'day mlh
07:47:49 <mlh> dag shapr
07:47:57 <vincenz> mlh is belg?
07:48:04 <AStorm> Uh, Swedish? :P
07:48:19 <shapr> mlh: Г¤r du svensk?
07:48:27 <vincenz> he's aussie
07:48:31 <shapr> I thought so.
07:48:39 <norpan> alla kan inte vara svenskar
07:48:49 <shapr> tyvГ¤rr
07:49:09 <mlh> nee, ik van Austrlie
07:49:21 <mlh> Aussie
07:49:26 <dylan> @hoogle DAG
07:49:27 <lambdabot> Data.Graph.Inductive.Example.dag3 :: Gr Char ()
07:49:27 <lambdabot> Data.Graph.Inductive.Example.dag3' :: IO (SGr Char ())
07:49:27 <lambdabot> Data.Graph.Inductive.Example.dag4 :: Gr Int ()
07:49:50 <vincenz> shapr is een helicopter
07:49:57 <shapr> ik begrijp het niet!
07:50:05 <shapr> How did I become a helicopter?
07:50:40 <mlh> ik ook
07:50:41 <vincenz> isn't that one of your first dutch statements?
07:50:59 <shapr> Nah, I talked about tandeborstals.
07:51:05 <vincenz> tandenborstel
07:51:10 <shapr> oops
07:52:03 <jgrimes> have there been any G-Machines written in C?
07:52:09 <mlh> ik vind oliebollen lekker
07:52:16 <shapr> mlh: Talar du svensk?
07:52:20 <mlh> nee
07:52:20 <jgrimes> as in the one from Implementing Functional Languages
07:53:06 <vincenz> jgrimes: link?
07:53:25 <jgrimes> vincenz, http://research.microsoft.com/~simonpj/Papers/pj-lester-book/
07:53:27 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/fsb9s
07:54:00 <mlh>  unn dunno
07:54:07 <mlh> oops wong channel
07:57:48 <shapr> Six years away from the USA is freakin me out.
07:58:27 <dylan> 21 years in the USA is freakin' me out...
07:58:55 <vincenz> damn
07:58:58 <shapr> Suddenly I return and it's all different!
07:59:00 <vincenz> http://www.getafreelancer.com/
07:59:02 <lambdabot> Title: Custom Web Design and Programming. Freelance Programmers. Outsource Web Developm ...
07:59:12 <shapr> vincenz: Most of those websites suck like a black hole.
08:03:14 <ndm> jgrimes: Yhc
08:03:24 <vincenz> shapr: besides.... how can one see if someone provides quality!
08:03:33 <jgrimes> ndm, oh really?
08:03:41 <jgrimes> ndm, I'll have to check that out
08:03:49 <vincenz> shapr: reminds me of this book wheer everybody lives separately in a metal container
08:04:06 <vincenz> shapr: and they had bids online, and someone noticed that the bids were completely artificial, and existed just to give reason to their lives
08:04:19 <vincenz> (as well as more and more containers were getting killed faster and faster)
08:04:20 <ndm> jgrimes: a pertty pure implementation, mainly based on that book, so should be relatively easy for you to figure out
08:04:36 <jgrimes> ndm, cool deal. thanks.
08:09:06 <shapr> vincenz: That would make reproduction difficult.
08:09:19 <mikael-> hey, what's the best way to use haskell on an intel macbook these days?
08:09:35 <mikael-> oh, hey shapr!  my haskell course at GU just started :-)
08:09:39 <shapr> cool!
08:09:48 <shapr> Did you mention to them that you have some prior experience?
08:09:53 <mikael-> yeah.  koen claessen is doing it instead of john hughes this year
08:10:07 <shapr> Or are you just going to embarass the teacher by submitting solutions using arrows or something?
08:10:07 <mikael-> nah, it's a huge class in a huge lecture hall
08:10:13 <shapr> Oh, you have Claessen
08:10:18 <mikael-> that's my plan ;-)
08:10:21 <shapr> heh, awesome!
08:10:28 <bringert> mikael-: see http://cvs.haskell.org/trac/ghc/wiki/X86OSXGhc
08:10:31 <mikael-> (not that I'd have any idea how to)
08:10:32 <lambdabot> Title: X86OSXGhc - GHC - Trac, http://tinyurl.com/za42p
08:10:39 <mikael-> oh, hey bringert, thanks
08:11:18 <shapr> btw, why GU instead of Chalmers?
08:11:30 <bringert> mikael-: I'm TA:ing in the other FP course, the one for people who do not take it as a first programming course, only first FP course
08:12:21 <mikael-> shapr: we get to choose our own curriculum after the first year
08:12:31 <shapr> Chalmers doesn't give you that option?
08:12:37 <mikael-> not that I know of
08:12:55 <mikael-> plus, in GU I know some of my upperclassmen from the internet :-)
08:13:03 <bringert> mikael-: anyway, you are welcome to ask me stuff about courses or whatever
08:13:14 * bringert went the chalmers path
08:13:35 <shapr> It sounds like you also know upperclassmen at Chalmers.
08:13:44 <bringert> the chalmers programs have more mandatory courses than the GU CS program
08:14:24 <bringert> so if you don't like physics etc, GU can be a good choice
08:14:42 <gour> @where yhc
08:14:42 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
08:14:48 <mikael-> the GU CS program is entirely on the chalmers campus, and you study with chalmerists, anyway
08:15:04 * bringert remembers the semiconductor physics course and shudders 
08:15:04 <gour> @where jhc
08:15:05 <vincenz> chalmerists
08:15:05 <lambdabot> http://repetae.net/john/computer/jhc/
08:15:12 <vincenz> bringert: yeah yick
08:15:25 <mikael-> and GU's lunch room is called Monaden, whereas the chalmers computer program lunch room doesn't have a name nearly as cool
08:15:34 <gour> @where nhc98
08:15:34 <lambdabot> http://haskell.org/nhc98
08:15:36 <Lemmih> Igloo, shapr: Have you been reimbursed by MSR yet?
08:15:57 <bringert> mikael-, true "the Monad" is cooler than "the Database"
08:16:06 <shapr> Lemmih: I haven't but I got a reply from the finance dept saying they'd try to send it out by monday.
08:16:09 <mikael-> ~-)
08:16:11 <shapr> Want me to forward the mail to you?
08:16:17 <mikael-> er, ":-)"!
08:16:21 <Lemmih> shapr: Yeah, that'd be nice.
08:16:24 <shapr> k
08:16:35 <Lemmih> Thanks.
08:16:43 <bringert> though "basen" translates to "al Qaeda" in arabic
08:16:54 <mikael-> bringert: does TAing mean you help students in "idelaran" and grade labs and such?
08:16:54 <ndm> does anyone else on the planet want a debugger for haskell, or is it just me?
08:16:59 <mikael-> bringert: haha
08:17:22 <shapr> ndm: There's a significant chunk of Haskellers who feel that debuggers are un-necessary. I don't know if they're right, but they exist.
08:17:23 <bringert> mikael-: yes, and grade exams, and hold exercise classes etc
08:17:38 <ndm> shapr: they seem to be quite vocal
08:17:51 <ndm> shapr:  i'd just be curious to see what the split between debugger vs not was...
08:18:03 <shapr> Well, I happen to agree with them, but I'm not closed minded about it. If you think debuggers are important, I'd like to hear why.
08:18:21 <ndm> seeing why you got an error message like "head []"
08:18:35 <ndm> i fail to see how anyone can argue that being given a complete stack trace there is a bad idea...
08:18:49 <bringert> yeah, I mostly don't feel the need to use one, but I can definitely imagine how it could be useful
08:19:00 <bringert> ndm: true
08:19:18 <ndm> next point, you have a function that goes wrong, producing an erroneous value
08:19:33 <ndm> thats because at some point you have misunderstood between what a function does, and what you thought it does
08:19:48 <ndm> either you can view the outputs from all the functions, seeing them, and seeing if they "feel right"
08:20:07 <ndm> or analyse each equation in incredible detail to find something that might only be a single ASCII character out
08:20:33 <ndm> i.e. its much easier to tell that sort isn't producing the right answer, than it is to spot a <= vs >= bug
08:21:13 <ndm> in summary, some bugs are scream out loud in the value sense, but are very subtle and quiet at the code sense, a debugger can help with those
08:21:13 <shapr> Do you think that debuggers are still important if you have comprehensive unit tests?
08:21:27 <ndm> that assumes unit testing is feasible
08:21:36 <shapr> Hm, when isn't it?
08:21:48 <ndm> unit testing being testing each unit in isolation?
08:22:01 <shapr> I mean like HUnit.
08:22:14 <ndm> those are useful to detect something is going wrong
08:22:19 <ndm> but not where it is going wrong
08:22:21 <shapr> http://c2.com/cgi-bin/wiki?UnitTest
08:22:24 <lambdabot> Title: Unit Test
08:22:32 <dylan> Actually, any time I catch myself value-spotting in a debugger (or with print statements), I write a unit test to do the eye-balling for me.
08:23:13 <ndm> but sometimes the code you are running is a massive chunk - the unit test tells you its going wrong
08:23:16 <gour> @where haste
08:23:16 <lambdabot> http://haste.dyndns.org:8080/
08:23:20 <dylan> This was really a fun experience in ocaml, with static typing and all. I esentually had a test for every function.
08:23:21 <ndm> but its hard to drill down into where the bug is
08:23:31 <shapr> Or you could write a unit test first, and then the code later.
08:23:39 <gour> haste ide is dead?
08:23:39 <ndm> not always feasible
08:23:45 <ndm> for example, when solving the halting problem
08:23:47 <shapr> When is it not feasible?
08:23:52 <dylan> shapr: I do both.
08:23:54 <shapr> I don't understand.
08:24:00 <shapr> ndm: Can you explain?
08:24:02 <dylan> start at both ends and work to the middle.
08:24:16 <ndm> shapr: Catch - i want the program to prove a haskell program doesn't crash - which is impossible to do
08:24:31 <ndm> shapr: as a result i want it to get as close as it can, which you can't specify in a unit test
08:24:39 <ndm> i can add tests for ones i get working to check they don't get worse
08:24:47 <ndm> but i can't add tests before i write the code
08:24:48 <shapr> ok, but how does that fit into the debugger discussion?
08:24:52 <shapr> Sure you can.
08:24:58 <shapr> I add tests before I wrote code all the time.
08:25:03 <ndm> you can sometimes
08:25:06 <ndm> but not always
08:25:10 <shapr> You can do it with both HUnit and QuickCheck.
08:25:34 <ndm> you can fundamentally, but sometimes you don't know the answer until you have it
08:25:57 <ndm> anyway, its a nightmare to debug, because its a complex system, without any nice "cut points"
08:25:59 <dylan> I've never really had much use for a debugger, but I can imagine in some cases it's invaluable.
08:26:06 <ndm> so when something goes wrong, its hard to figure out where
08:26:14 <shapr> ndm: it = what?
08:26:30 <ndm> shapr: it = Catch, in this particular instance
08:26:38 <shapr> ah
08:26:52 <shapr> You could use Epigram instead, you can prove it won't crash.
08:27:00 <Lemmih> What do you guys think of the debugger in GHCi?
08:27:02 <ndm> hehe, its a tool to prove absence of crashes
08:27:14 <ndm> if i use epigram, i might as well say there is no need for my tool
08:27:23 <shapr> Yeah, that would defeat the purpose...
08:27:33 <ndm> and epigram would turn my phd into a marathon...
08:27:46 <shapr> Anyway, this is #haskell, so let's skip the Epigram bit :-)
08:27:59 <ndm> since my algorithm is not finished, and is definately buggy until the very end
08:28:09 <shapr> What sort of algorithm are you writing?
08:28:14 <ndm> Lemmih: not tried it, but want to
08:28:22 <ndm> one that solves the halting problem :)
08:28:25 <shapr> ndm: Is the GHCi debugger cabalized?
08:28:36 <shapr> ndm: How can you do that outside a strongly normalizing language?
08:28:48 <ndm> shapr: i believe its an entire build of GHC, with patches - so probably hard to build
08:28:56 <ndm> shapr: you can't, i'm trying to get close though
08:28:58 <shapr> Is GHC cabalized?
08:29:02 <ndm> no
08:29:05 <shapr> too bad
08:29:36 <ndm> catch has a transformation stage, an equation solving stage - incorporating various mathsy transformations, regular expressions, analysis stuff
08:29:53 <ndm> its the equation stage where a small tweak can have a big result on the answer
08:30:02 <ndm> but might not be obvious from the code
08:32:33 <shapr> Igloo: Do you want a copy of the microsoft reimbursement mail I got?
08:32:43 <gour> what do you guys think about hIDE?
08:33:21 <ndm> looks cool, but doesn't look finished
08:33:36 <ndm> if there was a windows binary i'd probably have a play...
08:34:26 <gour> ndm: i thought about the need to have one, ie. haskell-oriented ide. yes, it does not look finished...
08:35:01 <ndm> gour: i hope i can get GuiHaskell up and going faster than a full IDE, and with enough features to make it a useful intermediate
08:35:16 <gour> ndm: win32 only?
08:35:18 <ndm> gour: i.e. i full expect that one there is a good IDE, people will migrate off of GuiHaskell and on to it
08:35:28 <vincenz> shapr: do those sites actually work?
08:35:29 <ndm> gour: its not, it used to be, but not anymore
08:35:43 <shapr> vincenz: The job sites?
08:35:50 <gour> ndm: ohh, really. that sound great. what about editor component?
08:36:03 <ndm> gour: none, integration with your editor
08:36:20 <shapr> vincenz: Do you mean the contract sites like getacoder, etc?
08:36:21 <vincenz> shapr: yeah
08:36:38 <ndm> vincenz: they suck, you'd be better of searching for coppers in the street
08:36:46 <gour> ndm: even better
08:36:49 <vincenz> ndm: I know, I just find them odd
08:37:03 <vincenz> who the hell goes on there and takes it seriously?/
08:37:05 <gour> @where GuiHaskell
08:37:06 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/guihaskell
08:37:14 <ndm> gour: it will be done as soon as threading+gtk isn't entirely broken on Windows
08:37:49 <gour> ndm: i need it for linux only. any web page besides repo?
08:38:05 <shapr> vincenz: I think they're ripoffs. I've never gotten any money from those sites.
08:38:15 <shapr> vincenz: I spent a few months seriously trying to do so.
08:38:28 <vincenz> shapr:  :/
08:38:34 <ndm> gour: http://www-users.cs.york.ac.uk/~ndm/temp/carrot.png http://www-users.cs.york.ac.uk/~ndm/temp/carrot2.png
08:38:37 <vincenz> I just don't get it, seems like a cattlemarket
08:38:45 <shapr> Sort of, yeah.
08:38:55 <shapr> If you want to make money on those sorts of jobs, ask your friends if they need anything.
08:39:21 <ndm> vincenz: i had the same experience as shapr, where you do get a contract its usually not paid in teh end, and its heavily weighted so you have to get a "premium" account at the sites etc to get anything good...
08:39:28 <gour> ndm: thanks. do you know about PIDA?
08:39:41 <ndm> gour: not a clue what that stands for
08:39:42 <vincenz> ndm: -not- paid???
08:39:48 <shapr> And even the premium accounts don't do much for you. I had one for several months.
08:39:56 <gour> ndm: http://pida.berlios.de/
08:39:57 <shapr> Yeah, *not paid*
08:39:58 <lambdabot> Title: Home - PIDA
08:40:01 <ndm> vincenz: its hard to extract the money, even if you do the work
08:40:10 <vincenz> so you work for a month on something, deliver, and they don't pay?
08:40:14 <shapr> And even when you get paid, it often takes months.
08:40:16 * vincenz boggles
08:40:27 <ndm> i had a premium account as well for a month or so - the whole point of the site is to get people to take premium accounts, otherwise you can't work them at all
08:40:34 <shapr> You can easily spend as much time extracting payment as you spent doing the work.
08:40:35 <ndm> the best contracts are premium only
08:40:54 <shapr> So the websites make money on the premium accounts, and that's the only money made as far as I can tell.
08:41:05 <shapr> Oh, the clients get work done for little or no money as well.
08:41:24 <ndm> gour: looks more like hide than guihaskell - guihaskell is modelled on WinHugs
08:41:38 <ndm> shapr: usually the sites bleed the clients for premium membership as well
08:41:43 <shapr> oh, I didn't know that.
08:41:54 <ndm> yeah, its basically one big scam
08:41:58 <gour> ndm: yes. it puts together different components, ie. editor, vcs plugins etc.
08:42:25 <ndm> gour: mine doesn't really put them together, its a very light integration - i.e. it might start your editor and hop to the right line, might notice you saved a file
08:42:27 <ndm> nothing more
08:43:49 <CosmicRay> I used to work for (now-defunct) quovix.com, which was a little different than all those sites.  quovix did the project management in-house, so we handled talking to developers for clients, keeping projects on-track, etc.  clients paid us, and we paid developers.  so no worries about payment from developers and no worries about delivery from clients (if the developers disappeared on us, we'd find someone to do it ourselves)
08:44:03 <CosmicRay> I don't know if there's anyone like that around anymore though
08:44:09 <gour> ndm: for yhc?
08:44:35 <shapr> CosmicRay: How did quovix die?
08:44:37 <shapr> it sounds perfect.
08:44:39 <ndm> gour: and jhc, cabal, haddock, ghci, ghc, hugs, hoogle...
08:44:50 <CosmicRay> shapr: not enough customers
08:44:52 <vincenz> CosmicRay: I used to work for an outsourcing company, but the project were always several months ,onsite with the client, and the pay waas fix from the outsourcing company, even when projectless
08:45:09 <gour> ndm: wonderful. however i'd still like to see full-featured hIDE
08:45:10 <shapr> Along the same lines, I would be happy to pursue open source bounties, but the websites are never current!
08:45:16 <ndm> CosmicRay: if only you'd bled all your clients and develoeprs just that little bit harder :)
08:45:27 <glguy> @hoogle trace
08:45:28 <lambdabot> Debug.Trace.trace :: String -> a -> a
08:45:28 <lambdabot> Debug.Trace :: module
08:45:28 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
08:45:30 <ndm> gour: me too, but this is a lot less work, so more feasible in teh short term
08:45:44 <CosmicRay> shapr: we were more expensive than the small sites, and perceived as more risky than regular outsourcing, I think
08:45:56 <shapr> If I'd know, I would have joined.
08:46:01 <CosmicRay> shapr: our code base does live on at innocentive.com though
08:46:13 <CosmicRay> which was a special-purpose fork
08:46:39 <gour> ndm: i agree.
08:46:52 * gour hopes that hIDE dev will resume shortly
08:47:03 <CosmicRay> quovix had very talented management and I really liked working there, despite having to use Java all day ;-)
08:47:47 <Gnezdo> hi
08:47:55 <Gnezdo> how can I convert from Integer to Int?
08:48:09 <bringert> @type fromIntegral
08:48:12 <CosmicRay> gnezdo: fromIntegral, I believe.
08:48:14 <lambdabot> forall b a. (Num b, Integral a) => a -> b
08:48:16 <dcoutts__> @yarr!
08:48:17 <lambdabot> Smartly me lass
08:48:26 * dcoutts__ gets cabal's testsuite working
08:50:20 <ndm> @where guihaskell
08:50:21 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/guihaskell
08:50:26 * gour notices lot of posts in the ml regarding debugger in haskell
08:50:44 <Gnezdo> looks like I could just expilcitly specify type with :: Int :-)
08:50:46 <Gnezdo> thanks
08:59:14 <ziggy> nick \z
09:08:37 <\x-> x+1
09:19:09 <SyntaxNinja> xerox: you've got mail :)
09:20:32 <SyntaxNinja> xerox: btw, you can send me a draft if you want and I'll help you with it.
09:26:54 <shapr> hiya SyntaxNinja!
09:27:34 <SyntaxNinja> shapr!
09:37:02 * Limbic_Region forgot to ask xerox how the cabal-put went yesterday
09:45:31 <ventonegro> if i were to right a binding for a C library, where every function takes as first argument a state variable, i'd write a monad, right?
09:47:25 <cjeris> http://www.haskell.org/haskellwiki/Learning_Haskell links to a tutorial called "Write yourself a Scheme in 48 hours".  Are there any ways in which this tutorial is known to be out of date or otherwise not representative of current good practice?
09:47:28 <lambdabot> Title: Learning Haskell - HaskellWiki, http://tinyurl.com/gg7z2
09:48:16 <SyntaxNinja> cjeris: running into problems?
09:48:18 <tennin> do the functions have side effects other than changing the state variable?
09:48:58 <ventonegro> tennin, some do I/O
09:49:21 <cjeris> SyntaxNinja: no, just asking because i'm a relative novice and don't know how fast the state of Haskell practice is changing over time.
09:49:39 <araujo> yay!
09:51:09 <AStorm> tennin: mostly Haskell functions have no side effects
09:51:22 <araujo> amen
09:51:27 * araujo back from univ.
09:51:37 <ventonegro> we are talking about a C library :-)
09:51:37 <dmhouse> AStorm: why not all?
09:51:37 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
09:51:54 <AStorm> dmhouse: all except IO
09:52:11 <dmhouse> AStorm: well, the side effect is encapsulated by the IO monad, surely?
09:52:29 <AStorm> Somewhat, yes.
09:52:31 <dmhouse> And at some conceptual level, the functions are just state transformers on a state of the RealWorld.
09:52:41 <AStorm> But it's a side effect anyway.
09:52:51 <dmhouse> You have to close your eyes and pretend a little bit, but that's the idea.
09:52:54 <tibbe> wii, finally home
09:53:03 <dmhouse> Ah, I see what you mean.
09:53:12 <dmhouse> Well, in that case, it's not limited to IO.
09:53:43 <AStorm> data dmhouse x = -x
09:53:45 <AStorm> :>
09:53:51 <AStorm> data dmhouse x = (-x)
09:54:04 <dmhouse> data dmhouse = very confused by what you're trying to do
09:54:22 <AStorm> You're inverted.
09:54:22 <AStorm> :P
09:55:10 <psi> how is e.g. putStrLn not pure?
09:55:24 <Syzygy-> psi: It has sideeffects.
09:55:34 <Syzygy-> More specifically, it changes the state of the stdout stream...
09:55:39 <dmhouse> It depends on your terminology.
09:55:40 <psi> not the function
09:55:58 <psi> putStrLn always returns the same IO action, no?
09:56:03 <dmhouse> An _actual_ side effect would be something that violates referential transparency.
09:56:03 <psi> for the same argyment
09:57:04 <dmhouse> But sometimes it's useful to call, say, a Writer monadic function side effectual, because it adds to the log.
09:57:18 <dmhouse> But it's not a 'real' side effect, because we encapsulate said effect with the monad
09:59:28 <dmhouse> I.e. a function f :: Writer [String] a has, 'in reality', the type (a, [String]), so there's no 'real' side effect, but it seems to have one so the terminology sometimes reflects that.
10:00:07 <dmhouse> I appear to have sent everyone else to sleep.
10:00:17 <ventonegro> hehe
10:00:27 <psi> okay, I'm not familiar with the Writer monad, but e.g, putStrLn :: String -> IO () does not have side effects, and is therefore pure
10:00:35 <ventonegro> i'm still trying to understand monads
10:00:42 <psi> that's my view on it
10:00:49 <ventonegro> i'm in chapter 9 of Yet Another Haskell Tutorial
10:01:01 <dmhouse> ventonegro: well, my rant wasn't a great introduction; it wasn't intended to be one.
10:01:10 <dmhouse> Ooh, don't learn monads from YAHT, that's a terrible chapter.
10:01:11 <ventonegro> i know
10:01:19 <dmhouse> A great tutorial in general, but that chapter didn't do anything for me.
10:01:31 <ventonegro> humm... do you suggest other source?
10:01:36 <dmhouse> I learnt from 1) the wikibook, and 2) All about monads.
10:01:37 <dmhouse> ,wikibook
10:01:44 <dmhouse> Err :)
10:01:46 <dmhouse> ?where wikibook
10:01:47 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:01:52 <dmhouse> ?where aam
10:01:52 <lambdabot> I know nothing about aam.
10:01:58 <dmhouse> ?google all about monads
10:02:01 <lambdabot> http://www.nomaware.com/monads/
10:02:01 <lambdabot> Title: Nomaware | Monads
10:02:08 * dmhouse has to dash and get some food.
10:02:26 <dmhouse> Specifically, the 'understanding monads' chapter of the wikibook.
10:02:40 <ventonegro> thanks!
10:05:43 <dylan> perhaps someone should @where+ aam http://www.nomaware.com/monads/   ?
10:05:43 <lambdabot> Title: Nomaware | Monads
10:08:28 <deadbeef> is there a way to get where's the source of a function using lambdabot ?
10:08:28 <lambdabot> deadbeef: You have 1 new message. '/msg lambdabot @messages' to read it.
10:08:39 <deadbeef> f.e. if i want to read the source for 'fix'
10:08:52 <deadbeef> omg teh message!!!11
10:28:21 <Igloo> Lemmih: My cheque arrived by post this morning, postmarked yesterday
10:28:35 <dmhouse> dylan: why don't you do it?
10:29:06 <dylan> dmhouse: that's not a privledged thing?
10:29:12 <dylan> @where+ aam http://www.nomaware.com/monads/
10:29:12 <lambdabot> Done.
10:29:17 <dylan> Oh. Handy
10:29:22 <dmhouse> I think that answers the question.
10:29:32 <dylan> My question was rhetorical
10:45:52 <ventonegro> any tutorials for writing FFIs?
10:47:49 <dcoutts__> SyntaxNinja!
10:47:52 <dcoutts__> g'evening
10:48:11 <dcoutts__> SyntaxNinja: I'm releasing a Cabal RC tarball
10:48:19 <dcoutts__> having fixed the testsuite
10:48:20 <SyntaxNinja> dcoutts__: excellent
10:48:27 <dcoutts__> all the tests work for ghc now
10:48:36 <dcoutts__> I've been ignoring hugs
10:48:36 <tibbe> @where wobbly types
10:48:37 <lambdabot> I know nothing about wobbly.
10:48:39 <SyntaxNinja> yay!
10:48:48 <tibbe> where's the wobbly types paper?
10:48:59 <tibbe> @google wobbly types
10:49:02 <lambdabot> http://citeseer.ist.psu.edu/716904.html
10:49:24 <SyntaxNinja> dcoutts__: maybe we can still release cabal-install with it.
10:49:33 <dcoutts__> SyntaxNinja: really?
10:49:34 <SyntaxNinja> not this RC I mean, but future
10:49:37 <dcoutts__> I was assuming not
10:49:51 <dcoutts__> ghc 6.6.1 will not be that far away
10:50:03 <dcoutts__> 6.6 is going to be a bit unstable anyway
10:50:04 <SyntaxNinja> for the actual release, perhaps we can get a cabal-install beta in with no promises.  Not in GHC, though, just the cabal tarball
10:50:23 <SyntaxNinja> and we can provide a "just cabal-install" tarball too perhaps for those who have the ghc cabal already
10:50:24 <dcoutts__> SyntaxNinja: we can do another relase for interested people any time
10:50:33 <dcoutts__> SyntaxNinja: we don't need to wait for ghc releases
10:50:35 <xerox> Hey SyntaxNinja! In fact I did make a draft script <http://hackage.haskell.org/~paolo/tmp/get-cabal-install.sh> here.
10:51:19 <SyntaxNinja> dcoutts__: yes, but it's just a nice goal to have it ready by the time we release the actual version.
10:51:22 <xerox> I changed sudo to su - -c because Baughn that was trying it, here on the channel.
10:51:57 <dcoutts__> SyntaxNinja: it'd need a good deal of testing, since if it's in ghc 6.6 we can't update that very easily 'til 6.6.1
10:52:07 <xerox> Anyway, that is wrong now. Since I've made the stand-alone repo, but it's the same code anyway.
10:52:11 <dcoutts__> if it's a seperate release it's a bit easier to update
10:52:12 <SyntaxNinja> xerox: that'll install cabal, not cabal-install, right?
10:52:22 <dcoutts__> or rather we won't have so many people with a borken version
10:52:31 <xerox> SyntaxNinja: very true... scratch that.
10:52:34 <cjeris> mother :: Sheep -> Maybe Sheep ??!
10:52:35 <dcoutts__> we've not had very wide testing
10:52:43 * cjeris busts out laughing
10:52:46 <SyntaxNinja> dcoutts__: I'm not talkling about releasing it w/ ghc. just releasing it at the same time, with the cabal tarball.
10:53:02 <xerox> cjeris: well, if it doesn't *know* who was...
10:53:16 <dcoutts__> SyntaxNinja: ah ok, yes I think it'd be a reasonable strategy to get it out in a seperate release for interestied parties to bang on
10:53:45 <SyntaxNinja> xerox: I think you could replace a lot of that with "make install" ; just make sure that the makefile can install cabal-install as well.
10:53:52 <sjanssen> cjeris: that declaration isn't consistent w/ the theory of evolution
10:54:05 <xerox> SyntaxNinja: i.e. provide a Makefile instead of a .sh ?
10:54:08 <SyntaxNinja> xerox: did you know that you can do "make install" w/ cabal? Also, your script will get screwy due to bootstrapping problems sometimes.
10:54:16 <xerox> I didn't know!
10:54:22 <SyntaxNinja> xerox: we already provdie a makefile for bootstrapping cabal.
10:54:32 <dcoutts__> SyntaxNinja: so yes, sure lets do a release with cabal-install soon after cabal-1.1.6
10:54:34 <xerox> Oh, wait, I see what you mean now.
10:54:39 <SyntaxNinja> so I think that the last 2 lines should go in the Setup.lhs file, maybe
10:54:44 <xerox> SyntaxNinja: you mean doing make install in Cabal/
10:54:47 <SyntaxNinja> and all of the install stuff should be replaced w/ "make install"
10:54:50 <SyntaxNinja> xerox: yeah
10:54:59 <xerox> Not in general with cabalized packages, okay.
10:56:09 <SyntaxNinja> dcoutts: I'm thinking that our tarball of cabal-1.1.6 should include cabal-install; and we provide it separately as well.  that way, we'll know that cabal-install works w/ cabal 1.1.6, which will be both the standalone-released version _and_ the ghc version.
10:56:18 <xerox> Why does Cabal need bootstrapping?
10:56:38 <SyntaxNinja> xerox: you can't assume that cabal is already installed :)
10:56:57 <dcoutts__> SyntaxNinja: is it a good idea to have the version with ghc differ from the standalone one?
10:57:12 <dcoutts__> SyntaxNinja: it's just as easy to have 1.1.6 and 1.1.7
10:57:28 <SyntaxNinja> dcoutts__: cabal the library won't differ, just the cabal-install binary.
10:57:53 <dcoutts__> SyntaxNinja: I think it'd be less confusing to have a different version
10:58:12 <dcoutts__> SyntaxNinja: you might be interested to know that kolmodin has been hacking on dependency infrastructure for Cabal. At the moment it can do proper deps for c2hs (since .chs files can depend on each other and so have to be built repecting that order)
10:58:24 <SyntaxNinja> dcoutts: cool :)
10:58:28 <SyntaxNinja> kolmodin: yay
10:58:48 <dcoutts__> this is one of the things we need to cabalise gtk2hs
10:58:53 <SyntaxNinja> dcoutts: well, it's not clear that GHC is going to include cabal-related binaries in general.
10:59:01 <dcoutts__> SyntaxNinja: really?
10:59:03 <dcoutts__> oh
10:59:16 <dcoutts__> it includes lots of other binaries
10:59:18 <SyntaxNinja> we haven't talked about it specifically. so far it's only the library, but that's all cabal has ever been.
10:59:31 <SyntaxNinja> does it include non-ghc-specific stuff?
10:59:38 <dcoutts__> it includes hsc2hs
10:59:45 <dcoutts__> which is not ghc specific
10:59:57 <dcoutts__> and it includes profiling bits and bobs
10:59:59 <dcoutts__> hstags
11:00:29 <SyntaxNinja> hmm
11:00:45 <xerox> It includes ar.exe ?
11:00:46 <xerox> :=
11:00:48 <xerox> :)
11:00:49 <dcoutts__> heh
11:00:59 <SyntaxNinja> can you ask Simon (or maybe Igloo is the one to ask now?) if he wants to include cabal-setup and cabal-install in the future?
11:01:03 <xerox> (I was thinking that we could go for including tar.exe if wee need, hehe)
11:01:07 <dcoutts__> SyntaxNinja: sure
11:01:10 <dcoutts__> I'll ask
11:01:13 <SyntaxNinja> thanks
11:01:42 <dcoutts__> SyntaxNinja: I think he was ok with cabal-setup
11:01:53 <SyntaxNinja> hmmmmm
11:01:55 <kolmodin> SyntaxNinja: :)
11:01:57 <SyntaxNinja> OK.
11:02:06 <dcoutts__> xerox: so what are are remaining deps? http right?
11:02:10 <xerox> Yep.
11:02:14 <SyntaxNinja> kolmodin: I take it you're Lennart?
11:02:21 <kolmodin> that's correct
11:02:26 <SyntaxNinja> nice to meet you.
11:02:34 <kolmodin> nice to meet you too :)
11:02:44 <SyntaxNinja> sorry I've been unresponsive to most cabal-devel stuff that's not cabal-install right now.  september is more insane than ever.
11:03:09 <dcoutts__> SyntaxNinja: no probs, I've been hacking on it today, I think it's all looking good
11:03:12 <SyntaxNinja> I'm runninng two projects at work, plus haskell prime, and trying to hire people
11:03:14 <SyntaxNinja> sweet
11:03:31 <SyntaxNinja> you'd be surprised how hard it is to hire haskellers :(
11:03:52 <kolmodin> why?
11:03:55 <dcoutts__> SyntaxNinja: because they;re all such independent personalities? ;-)
11:04:00 <kolmodin> haha :)
11:04:20 <dcoutts__> because they only care about beautiful programs and not deadlines?
11:04:33 <xerox> @arrr
11:04:33 <lambdabot> Swab the deck!
11:05:02 <dcoutts__> SyntaxNinja: we keep pondering starting a part-time consultancy outfit
11:05:08 <SyntaxNinja> They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing what I'm doing." ;)
11:05:18 <dcoutts__> hah
11:05:25 <xerox> hehe.
11:05:30 <dcoutts__> I can believe that
11:05:53 <dcoutts__> that'd work quite well for a distributed consultancy, but not a traditional "in one building" company
11:05:56 <SyntaxNinja> well, it would be awesome if there were a pool of Haskell consultants. galois often has need of temporary consultants.
11:06:12 <kolmodin> SyntaxNinja: hah :)
11:06:18 <xerox> @remember SyntaxNinja You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing what I'm doing." ;)
11:06:24 <dcoutts__> SyntaxNinja: aye, to offer services to support in-house development, etc
11:06:40 <dcoutts__> supporting tools, code review, lib design, testing etc
11:06:50 <kolmodin> I don't know if I'd like to just work remotely, I need to see people once in a while. can't do everything from home
11:07:04 <xerox> dcoutts__: that's your description? ;)
11:07:11 <SyntaxNinja> dcoutts: that would rule :)
11:07:31 <dcoutts__> SyntaxNinja: it's a matter of time and energy
11:07:43 <dcoutts__> people are busy
11:08:20 <SyntaxNinja> yeah
11:08:26 <xerox> IIRC Cale was looking for some way to unleash his power, maybe you could ask him :)
11:08:29 <Igloo> SyntaxNinja: Dude, you need an Oxford office
11:08:36 <dcoutts__> heh, yeah
11:09:12 <SyntaxNinja> Cale: are you looking for some way to unleash your power?
11:09:14 <kolmodin> many work with haskell as research or as a hobby beside their real work
11:09:21 * xerox grins
11:09:25 * SyntaxNinja tries to picture Igloo actually saying "dude" out loud.
11:09:29 <sh10151> some of us prefer Columbus to Seattle! :-P
11:09:32 <xerox> hahaha.
11:09:33 <dcoutts__> I'm not sure I'd move to the US even if it was for a full time Haskell job
11:09:43 <SyntaxNinja> sh10151: we're not in seattle, silly.
11:09:54 <sh10151> portland?
11:09:56 <sh10151> wherever
11:09:56 <SyntaxNinja> ja
11:09:58 <sh10151> it's all the same
11:09:58 <kolmodin> dcoutts__: me neither. or perhaps..
11:10:05 <sh10151> ever see the new yorker cartoon?
11:10:13 <dcoutts__> kolmodin: haskell-consultants.eu :-)
11:10:16 <SyntaxNinja> sh10151: link?
11:10:21 <sh10151> a manhattan resident's idea of geography?
11:10:25 <sh10151> let's see if I can find one
11:10:25 <SyntaxNinja> sh10151: I've lived in Columbus... for 7 years.
11:10:25 <xerox> dcoutts__: that would be interesting :)
11:10:26 <kolmodin> dcoutts__: that would be sooo cool :)
11:10:32 <SyntaxNinja> it's better here, trust me ;)
11:10:46 * Igloo says "dude" or "dudes" out loud not infrequently
11:10:53 <dcoutts__> kolmodin: well, first thing we need to know is which country to incorperate in.
11:11:06 <kolmodin> yeah, what about .eu :)
11:11:15 <SyntaxNinja> dcoutts__: U.S.A... U.S.A... We're Number 1!
11:11:26 <dcoutts__> kolmodin: ie what the fees and admin of setting up a small company are
11:11:26 <xerox> @slap SyntaxNinja
11:11:27 * lambdabot slaps SyntaxNinja
11:11:30 <Igloo> dcoutts__: What are the practicalities that affect that? Physical locations of people? Taxes?
11:11:40 <dcoutts__> SyntaxNinja: so I keep hearing ;-)
11:11:40 <kolmodin> dcoutts__: ok, luxemburg then
11:12:00 <dcoutts__> Igloo: someone probalbe needs to be in the country
11:12:18 <gour> dcoutts__: me too. no attraction for us & its eg. food
11:12:19 <kolmodin> skype moved out of sweden and has operate in the uk, luxemburg and poland
11:12:20 <dcoutts__> Igloo: but anywhere in europe is ok
11:12:46 <xerox> Cyprus!
11:12:47 <kolmodin> dcoutts__: yeah, I'll even lear german if I have too
11:12:55 <kolmodin> s/too/to/
11:13:00 <dcoutts__> heh :-)
11:13:08 <dcoutts__> we can probably find a native or three
11:13:08 <sh10151> SyntaxNinja: small graphic, but http://www.thenewyorkerstore.com/assets/2/50326_l.jpg
11:13:26 <deadbeef> @index length
11:13:27 <lambdabot> Data.List, Prelude
11:13:31 <sh10151> "View of the World from 9th Avenue"
11:13:41 <dcoutts__> kosmikus, der_eq: any idea how difficult it is to start a small buisness in .de ?
11:13:47 <deadbeef> @fptolls Data.List
11:13:48 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:14:45 <SyntaxNinja> sh10151: cute. have you ever been to the pacific northwest? are you coming out for ICFP?
11:15:42 <sh10151> no and no, I should make the trip sometime though, I have a bunch of friends working for Microsoft
11:16:00 <sh10151> though since my sister is getting married in CA, that will probably be my travel budget
11:16:40 * sh10151 has been all over the east coast and midwest, never west of the mississippi though
11:16:53 <der_eq> dcoutts__: no idea, but as far as I've read it takes a lot longer than in other EU countries
11:16:54 <sieni> ca == certificate authority?
11:17:06 <dcoutts__> der_eq: ok, not .de then :-)
11:17:28 * kolmodin is trying to wrap his head around template haskell. not that easy to get into
11:17:37 <der_eq> dcoutts__: what are you planning?
11:17:39 <kolmodin> got to fix my laundry, brb
11:17:51 <sh10151> california
11:18:04 <Igloo> dcoutts__: Do you know if the UK is good or bad yet?
11:18:11 <sh10151> I hope she did make sure his certificate had a trusted signer though
11:18:21 <dcoutts__> Igloo: http://www.companieshouse.gov.uk/
11:18:22 <sh10151> he's from Austria
11:18:23 <lambdabot> Title: Companies House
11:18:27 <dcoutts__> Igloo: I think it's not too bad.
11:18:41 <SyntaxNinja> sh10151: oregon is the canada of california.
11:18:41 <SyntaxNinja> (and the mexico of washington, but we don't think about that)
11:18:52 <SyntaxNinja> the UK is good. they are our only allies.
11:18:54 <dcoutts__> der_eq: possibly to start a haskell consultency company
11:18:57 <Igloo> dcoutts__: OK; I ask as I know some people who have done it I could ask, but I don't know if they'd know how it compares
11:19:06 <dcoutts__> Igloo: do ask.
11:19:12 <Igloo> OK
11:19:27 <SyntaxNinja> someone should talk to Alastair Reid who started one a while back.
11:19:51 <dcoutts__> yes, good point
11:19:56 <dcoutts__> it costs ВЈ20
11:19:58 <sh10151> I read that someone had commercialized that financial contracts stuff that SPJ wrote a while ago
11:20:00 <dcoutts__> apparently
11:20:19 <dcoutts__> http://www.companieshouse.gov.uk/infoAndGuide/companyRegistration.shtml
11:20:22 <lambdabot> Title: Information &amp; Guidance - Company Registration, http://tinyurl.com/zbd9n
11:20:36 <dcoutts__> A new company must:
11:20:36 <dcoutts__>     * give details of its constitution in the form of a Memorandum and Articles of Association
11:20:36 <dcoutts__>     * give details of its directors, company secretary and members.
11:20:36 <dcoutts__>     * have a registered office.
11:22:03 <Igloo> dcoutts__: He thinks UK is easier than France, and France is similar to the rest of Europe
11:22:12 <dcoutts__> Igloo: interesting
11:22:46 <Igloo> (but he could be wrong or out-of-date)
11:28:48 <kolmodin> I think it's easier to recruit new haskell coders if you live in a english speaking country
11:29:42 <dottedmag> kolmodin: do you mean in France you only find the OCaml coders? :)
11:30:35 <kolmodin> haha :)
11:30:45 <kolmodin> no, it's easier to talk to the customers
11:32:05 <astrolabe> I guess uk taxes are intermediate between US and most of Europe
11:41:02 <Syzygy-> Ummmm. Why doesn't this work:
11:41:06 <Syzygy->   (alpha,beta,r) <- get pPos
11:41:07 <Syzygy->   lookAt (Vertex3 x y z) (Vertex3 0 0 0) (Vertex3 x2 y2 z2) where
11:41:07 <Syzygy->     (x,y,z) = calculatePOV alpha beta r
11:41:12 <Syzygy-> Fails with Flow_appDef.hs:18:27: Not in scope: `alpha'
11:42:03 <tibbe> > let f = concat . filter ((>= 186000) . read . (! 1) . words) . lines in f "bah 2133\nfoo 1232131"
11:42:04 <lambdabot>  Couldn't match `Array i e' against `[String]'
11:42:13 <tibbe> array?
11:42:26 <int-e> !
11:42:26 <tibbe> > let f = concat . filter ((>= 186000) . read . (!! 1) . words) . lines in f "bah 2133\nfoo 1232131"
11:42:27 <lambdabot>  "foo 1232131"
11:42:30 <tibbe> ah
11:42:40 <int-e> @type (!)
11:42:42 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
11:42:46 <tibbe> @pl let f = concat . filter ((>= 186000) . read . (!! 1) . words) . lines in f
11:42:47 <lambdabot> join . filter ((>= 186000) . read . (!! 1) . words) . lines
11:44:02 * tibbe is proud of his solution, almost as short as awk but still in a general purpose language
11:44:15 <tibbe> ?type join
11:44:16 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:44:25 <int-e> in the list monad that's concat
11:44:31 <tibbe> lambdabot prefers join to concat
11:44:37 <tibbe> know :)
11:45:04 <deadbeef> > unwords . reverse . words $ "ciao belli"
11:45:06 <lambdabot>  "belli ciao"
11:50:09 <daavid> euler_y_n x0 y0 h f  = y0 : [ a+b | (a,b) <- zip (euler_y_n x0 y0 h f) (map (*h) (f_n x0 y0 h f)) ]
11:50:09 <daavid> f_n x0 y0 h f = map f (zip (x_n x0 h) (euler_y_n x0 y0 h f))
11:50:24 <Syzygy-> So, I have an IORef, passed into my function as pPos, containing a 3-tuple of numbers. So my function is defined as fun pPos = do (a,b,r) <- readIORef pPos <newline> dostuff using a,b,r
11:50:36 <Syzygy-> And ghc complains on the second of those lines, claiming a,b,r not in scope.
11:50:44 <daavid> that is an implementation of the euler haskell for integrating 1st order differential equations (i.e. y_n+1 = y_n + h*f(y_n-1, x_n-1)
11:51:28 <Syzygy-> Does anybody know how I should extract the bits nd pieces of my IORef in order to actually be able to use them?
11:51:57 <daavid> but it's extremely slow. if you do take 20 euler_y_n 0 1 0.1 f (where f (x,y) = -2*y - 1/4*x*x + 1/8) it gets the first few elements fast but as we get to element 10 it starts taking more than half a second to calculate a single value
11:52:07 <daavid> why is it so slow?
11:52:57 <Syzygy-> daavid: Could it be that it recurses back through everything for each new? *wild guess*
11:54:44 <daavid> i though values in lists were cached?
11:57:18 <deadbeef> configure: Dependency readline-any: using readline-1.0
11:57:18 <deadbeef> Setup.hs: cannot satisfy dependency plugins>=1.0
11:57:21 <deadbeef> what this means ?
11:57:26 <deadbeef> in the building of lambdabot
11:57:38 <deadbeef> i did ./Setup.hs configure --bindir=`pwd`
11:57:59 <SyntaxNinja> you need to install the package "plugins"
11:58:35 <deadbeef> hs-plugins
11:58:36 <deadbeef> here we go
11:58:37 <deadbeef> thanks
11:59:36 <lisppaste2> tim annotated #21824 with "lovewell" at http://paste.lisp.org/display/21824#2
12:00:45 <lisppaste2> Tim annotated #21824 with "hello" at http://paste.lisp.org/display/21824#3
12:01:20 <tibbe> how to run lambdabot in ghci?
12:16:15 <dcoutts__> Igloo: a UK LLP might be the right setup
12:16:45 <dcoutts__> that is a "Limited Liability Partnership"
12:16:54 <dcoutts__> it looks like it can have members that are not based in the UK
12:17:14 <dcoutts__> and it's otherwise a for-profit membership/partnership style company
12:31:35 <shapr> dcoutts__: Spiffy
12:31:42 <shapr> @users
12:31:48 <lambdabot> Maximum users seen in #haskell: 232, currently: 227 (97.8%), active: 31 (13.7%)
12:32:02 <shapr> dcoutts__: Of course, we'd need a UK Haskeller to do that, right?
12:32:11 <dcoutts__> shapr: right
12:32:14 <dcoutts__>  to register
12:32:23 <dcoutts__> and possibly to be a 'designated' member
12:33:00 <dcoutts__> meaning the one(s) reponsible for returning accounts etc each year
12:33:42 <tibbe> lambdabot: I need you in efnet
12:34:41 <dcoutts__> an LLP need not maintain capital
12:34:45 <dcoutts__> which is good
12:35:05 <dcoutts__> it has members rather than directors & shareholders
12:35:21 <dcoutts__> it can employ people in addition to having members
12:35:32 <shapr> Sounds perfect.
12:35:42 <dcoutts__> the members/pertners have limited liability
12:36:17 <dcoutts__> the LLP itself (as distinct from it's members individually) is liabale for debts etc, being sued
12:43:32 <fasta> Can ghci understand C preprocessor macros?
12:43:48 <Igloo> If you use -cpp I think it will
12:48:15 <Igloo> dcoutts__, shapr: http://en.wikipedia.org/wiki/Limited_Liability_Partnerships_Act_2000 gives an overview
12:50:57 <dcoutts__> Igloo: I was reading stuff from companies house, it has an intro/overview in it's newsletter, in addition to the formal stuff
12:54:58 <shapr> What's the tax rate in the UK?
12:55:44 <dcoutts__> generally higher than US, lower than rest of Europe
12:55:45 <Patterner> too much...
12:56:59 <Igloo> Roughly, income tax is 0% on the first 5l, 10% on the next 5-7k, then 22% on 30k, then 40%
12:57:04 <Igloo> http://www.hmrc.gov.uk/rates/it.htm for the real numbers
12:57:07 <lambdabot> Title: HM Revenue &amp; Customs: Rates and Allowances - Income Tax
12:57:22 <Igloo> There's also NI, but I don't know if you'd pay that if you were in the US?
12:57:38 <Igloo> I'm also not sure if it's UK or US income tax you'd pay
12:57:51 <Igloo> s/5l/5k/
12:58:03 <shapr> I think that I'd pay US income tax if I work for a UK company while living in the USA.
12:58:09 <Igloo> Ooops, sorry, what I said wasn't consistent
12:58:26 <Igloo> Roughly, income tax is 0% on the first 5k, 10% on the next 2k, then 22% on the next 30k, then 40% on the rest
12:58:36 <shapr> What about the taxes the company itself pays?
12:58:48 <shapr> In Sweden it's 25% VAT across the board.
12:59:01 <dcoutts__> In UK it's 17.5%
12:59:18 <dcoutts__> shapr: an LLP is not a company as such
12:59:31 <dcoutts__> so each member is treated as self-employed
12:59:32 <shapr> oh, so it wouldn't pay taxes?
12:59:33 <Igloo> Would that be due on income?
12:59:46 <dcoutts__> so the company itself wouldn't pay corporation tax I think
13:00:10 <shapr> In the US a corporation is a separate legal entity similar to an LLP, and I think it does have its own tax burden.
13:00:12 <Igloo> OK, and I don't think there would be any capital gains tax to worry about either, right?
13:00:23 <Igloo> shapr: What is the tax rate over there?
13:00:34 <dcoutts__> Igloo: what circumstance are you thinking of?
13:00:40 <dcoutts__> you'd pay the tax personally on any income from being a member
13:01:02 <Igloo> dcoutts__: I thought you were saying 17.5% VAT would have to be paid on income to the LLP
13:01:08 <shapr> Igloo: Not sure, haven't been here in six years.
13:01:15 <dcoutts__> Igloo: no that's on stuff bought by the LLP
13:01:21 <dcoutts__> just like another company
13:01:35 <dcoutts__> http://www.companieshouse.gov.uk/about/busRegArchive/RegIssue56.pdf
13:01:39 <dcoutts__> has an intro
13:02:28 <Igloo> Right, but that would be essentially nothing
13:03:58 <Igloo> Oh, tax might be less if you can be paid minimum wage and take the rest in dividends from the company?
13:04:09 * Igloo doesn't understand all this stuff
13:05:57 <dcoutts__> Igloo: there are no divedends, since there are no shares
13:06:16 <dcoutts__> but the revenue of the partnership can be shared among the members
13:06:50 <dcoutts__> either equal share or it can be shared according to a seperate agreement
13:07:04 <dcoutts__> eg, who does the work on a contract gets paid
13:11:52 <dcoutts__> Igloo: a company employs people (who may also be shareholders) where as a partnership shares revenue between members and has no directors or shareholders.
13:16:19 <waern> has anyone seen the problem of make clean in ghc repo removing source files in /libraries?
13:16:49 <waern> I suspect I'm doing something wrong since no-one else has reported this
13:17:41 <kolmodin> waern: hi!
13:17:48 * kolmodin is just off to bed
13:17:49 <waern> kolmodin, hejsan!
13:17:52 <kolmodin> tja :)
13:17:58 * waern is already laying in bed 
13:18:00 <tibbe> joel spolsky does some serious name dropping these days
13:18:01 <kolmodin> hah :)
13:18:41 <tibbe> I think we succeeded in mentioning, web 2.0, reddit, paul graham, lisp, ruby,haskell, functional programming and good know what else
13:18:49 <tibbe> in his last two articles
13:18:55 <kolmodin> waern: how did that haddock/ghc thing go? when will it be included?
13:21:02 <kolmodin> g'night
13:21:09 <ventonegro> what's the difference between type and newtype?
13:21:26 <waern> kolmodin, it went fine but there's still lots of work to do. I've told JaffaCake patches for ghc are ready... don't know when they will be included
13:21:44 <waern> probably quite soon
13:23:34 <Igloo> waern: Which files?
13:23:59 <Igloo> ventonegro: type makes another name for an existing type, newtype makes a new type (that, e.g., can have its own instances)
13:24:33 <ventonegro> humm... I thought 'data' did that
13:24:48 <waern> Igloo, darcs patches.. haven't sent them
13:24:59 <Igloo> data lets you design your own types
13:25:34 <SamB> newtype makes a new type with the same representation as another
13:25:45 <Igloo> waern: Hmm? You were talking about make clean removing source files?
13:25:52 <waern> ah.
13:26:01 <waern> Igloo, stuff in Cabal and base for instance
13:26:04 <waern> source files
13:26:35 * Igloo needs specifics
13:26:45 <waern> most of the files disappear :)
13:26:50 <ventonegro> newtype State s a = State (s -> (s, a))
13:27:00 <ventonegro> that's from the wikibook
13:27:01 <Igloo> That sounds very odd
13:27:13 <ventonegro> data State s a = State (s -> (s, a)) wouldn't work?
13:27:28 <Igloo> ventonegro: It would work, but it doesn't have quite the same meaning
13:27:34 <waern> Igloo, yeah.. I should to try get a new repo
13:27:44 <SamB> ventonegro: it would be slower!
13:27:58 <Igloo> ventonegro: For example, State _|_ and _|_ are the same with the newtype but not with the data
13:28:36 <Igloo> ventonegro: Normally, if newtype works then that is what you want
13:28:46 <ventonegro> I see
13:28:58 <ventonegro> and when would data work but not newtype?
13:29:39 <Igloo> When you want multiple constructors, or multiple types in a single constructor
13:29:56 <ventonegro> ah, ok
13:29:58 <ventonegro> thanks
13:29:59 <Igloo> e.g. data Foo = Foo | Bar    data Foo = Foo Int Char
13:30:19 <SamB> newtype only works when you want a single constructor with a single field...
13:35:24 <musasabi> Is there a good paper about how the indexed data/newtype families work and examples what they are good for beside the Map one?
13:47:55 <deadbeef> a decent haskell ide
13:48:01 <deadbeef> i can found in the gentoo portage ?
13:48:19 <tibbe> deadbeef: emacs ;)
13:48:25 <deadbeef> nooo pls don't say that
13:48:45 <deadbeef> emacs is like a kamasutra for fingers
13:48:54 <musasabi> eclipse. But it is worse than emacs ;)
13:49:03 <deadbeef> hIDE seems sexy
13:49:08 <deadbeef> but it isn't in the portage
13:49:18 <SamB> it works?
13:49:23 <musasabi> http://eclipsefp.sourceforge.net/
13:49:24 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
13:49:28 <deadbeef> dunno, only seen some shots
13:49:34 <deadbeef> musasabi: yes, i use that on my laptop
13:49:56 <deadbeef> (but it runs XP)
13:50:25 <musasabi> that should work on Linux too.
13:50:34 <lispy> dons: ping
13:52:42 <lispy> ?tell dons friend of mine wants to embed a programmable calculator in his personalized google search page.  I told him to use lambdabot as the calculator.  He pointed out that he doesn't want to have to define all his functions every time in one big let.  How hard do you think it would be to get lambdabot to 'remember' function definions entered through 'let'?
13:52:42 <lambdabot> Consider it noted.
13:52:51 * lispy probabyl should have sent email :)
13:53:26 <Patterner> we cannot read your email. well, not officially...
13:54:01 <SamB> Patterner: you can read his email?
13:54:18 <Patterner> Not officially...
13:54:25 <SamB> in practice?
13:54:37 <deadbeef> not (officially)
13:54:54 <SamB> I never said anything about any officials!
13:55:21 * Patterner denies knowledge
13:57:14 <dmhouse> ?karma+ dons -- for that trace with line number function
13:57:15 <lambdabot> dons's karma raised to 56.
13:57:18 <dmhouse> Wow.
13:57:22 <dmhouse> 56!?
13:57:53 <SamB> dons *does* do a lot of cool foundational stuff, you know!
13:58:08 <SamB> lambdabot... bytestrings... hs-plugins...
13:58:13 <dmhouse> ?fptools Control.Exception
13:58:14 <lambdabot> http://darcs.haskell.org/packages/base/Control/Exception.hs
13:59:43 <shapr> perspectival: So, do you like statically czeched languages?
14:00:04 <perspectival> definitely
14:00:19 <perspectival> I much prefer them to dynamically-Czeched ones
14:00:23 <shapr> Spiffy
14:00:24 * shapr grins
14:00:41 <perspectival> is my location available somehow? ;-)
14:00:46 <shapr> Have you already heard that joke a thousand times?
14:00:48 <shapr> Yes, it is.
14:01:13 <perspectival> ah, I see
14:01:26 <perspectival> the jabber aim transport--great for anonymity
14:01:36 <perspectival> no, you're the first
14:01:43 <Philippa_> more accurately, your hostmask's available and ends .cz
14:01:49 <perspectival> rather, that, yes
14:02:03 <SamB> apparantly your client is gaim, too?
14:02:04 <shapr> I thought it might be one of those old tired programming jokes in .cz
14:02:58 <perspectival> I wouldn't know; I'm an english teacher
14:03:11 <dmhouse> I saw an awesome T-shirt once. It had 'PRAGUE' in big letters, and underneath, 'Czech it out'.
14:03:11 <shapr> Oh, how'd you end up on #haskell?
14:03:12 <perspectival> but yeah, my client is gaim (which had the annoying logout message until recently)
14:03:24 <perspectival> I started learning haskell, and plan to continue it
14:03:35 <dmhouse> perspectival: not as bad as 'Konversation terminated!'
14:03:38 <shapr> Spiffy, how's it going? Any questions, difficulties, etc?
14:04:50 <perspectival> I've gotten to monads, and partially understand them, but haven't had time to delve into all the tutorials yet. I think haskell is a good bet for a future computer language--I'm astounded it hasn't caught on yet (though it's getting there I think)
14:05:04 <shapr> I'd be happy to explain monads to you when you do have time.
14:05:13 <dmhouse> There are many good tutorials aroundl
14:05:18 <perspectival> you guys are great ;-)
14:05:19 <dmhouse> Trouble is, there are many bad ones too.
14:05:21 <perspectival> and yeah, there are
14:05:46 <dmhouse> ?google "Understanding monads" Haskell site:wikibooks.org
14:05:49 <lambdabot> http://en.wikibooks.org/wiki/Programming:Haskell_monads
14:05:55 <dmhouse> Not that one.
14:06:13 <SamB> hmm
14:06:13 <dmhouse> http://en.wikibooks.org/wiki/Haskell/Understanding_monads -- this is worth checking out
14:06:18 <dmhouse> ?google All About monads
14:06:20 <lambdabot> http://www.nomaware.com/monads/
14:06:20 <lambdabot> Title: Nomaware | Monads
14:06:22 <dmhouse> So is that one.
14:06:35 <perspectival> what I'm really interested in is a databinding for xml (relax ng preferrably , rather than schema) that translates to haskell types, and hopefully back again
14:06:42 <perspectival> I don't know if it's been done yet
14:06:58 <perspectival> I can find the paper on UUXML, but an implementation...
14:07:13 <sjanssen> perspectival: I think HaXml has a dtd2haskell tool
14:07:19 <perspectival> yeah, I've seen that
14:07:55 <shapr> And HaXML has the XmlContent typeclass in 1.15 and later.
14:08:11 <perspectival> like some others I've seen, I think haskell could be a big language for web services (which the Links project is also involved in)
14:08:22 <perspectival> I would rather write a few lines of haskell than XSLT
14:08:43 <shapr> I've had great success doing XSLT tricks with HXT
14:08:51 <SamB> but yuck!
14:08:55 <perspectival> yeah? I'll have to czech it out
14:08:58 * shapr laughs
14:09:10 <SamB> HXT lets it all hang out -- which is BAD!
14:09:27 <SamB> it seems probable that HXT has too much to start with...
14:09:30 <shapr> It took me three days to do with HXT what another programming could not do in a month+ of Java & JavaScript & XSLT.
14:09:32 <glguy> anyone know a way to do something like this with liftM2?
14:09:33 <glguy> sequence (sequence [(+),(-)] 3) 4
14:09:35 <glguy> > sequence (sequence [(+),(-)] 3) 4
14:09:36 <lambdabot>  [7,-1]
14:09:44 <dmhouse> glguy: that homework?
14:09:47 <glguy> nope
14:09:55 <dmhouse> Sounds like a weird question to ask.
14:09:56 <glguy> Reader monad obfuscation
14:10:13 <shapr> Sounds like you want the pair apply op from arrows.
14:10:34 <perspectival> shapr: I believe you
14:10:42 <dolio> ?pl sequence (sequence [(+),(-)] 3) 4
14:10:42 <lambdabot> sequence (sequence [(+), (-)] 3) 4
14:10:56 <shapr> Hm, I wonder if pointless is aware of arrows?
14:10:58 <glguy> > sequence (sequence [(+),(-),(*),(/)] 3) 4
14:10:59 <lambdabot>  [7.0,-1.0,12.0,0.75]
14:11:12 <SamB> shapr: it may use some of the combinators for functions...
14:11:15 <glguy> thsi is for the mathschallenge question where you have to find all the ways to combine arithmetic functions
14:11:25 <glguy> I finished it, and now I am screwing around
14:11:38 <dmhouse> shapr: I don't believe so.
14:11:45 * shapr grabs the lambdabot source
14:11:50 <shapr> I should really be working, but...
14:11:57 <dmhouse> ?type (***)
14:11:58 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:12:17 <dmhouse> ?pl \f g (x, y) -> (f x, g y)
14:12:18 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
14:12:20 <SamB> > (uncurry (+) &&& uncurry (-)) (3, 4)
14:12:22 <lambdabot>  (7,-1)
14:12:31 <dmhouse> ?type \f g (x, y) -> (f x, g y)
14:12:33 <lambdabot> forall a b a1 b1. (a -> a1) -> (b -> b1) -> (a, b) -> (a1, b1)
14:12:40 <glguy> I'm doing this in the list monad, so tuples won't work
14:12:48 <dmhouse> shapr: Nope.
14:13:16 <SamB> why do you want to use liftM2?
14:13:28 <glguy> dmhouse: just to clarify on the homework question, I working on this problem: http://mathschallenge.net/index.php?section=project&ref=problems&id=93&lookup=who and my nick "glguy" is listed as having solved it, so don't worry about helping me cheat :)
14:13:44 <glguy> I don't specifically want to use liftM2
14:13:56 <glguy> I just wondered if there was a cleaner way than chaining sequences
14:14:09 <dmhouse> glguy: sure, it's just that you asked for a very specific solution, involving one particular function, which is why it sounded like homework.
14:14:16 * shapr hugs dmhouse
14:14:16 <dmhouse> I trust you when you say it's not :)
14:14:19 * glguy drools over the prospect of having "haskell homework"
14:14:25 <SamB> hehe
14:14:34 <dmhouse> glguy: I'm teaching a course in Haskell from next week! :)
14:14:36 <norpan> i have some haskell workwork
14:14:40 <shapr> dmhouse: awesome!
14:14:40 <SamB> iirc, glguy says he used to be glsec when he was in gamma lambda...
14:14:47 <glguy> yeah
14:14:51 <dmhouse> I need to write some notes for that.
14:14:51 <shapr> I have some Haskell homework! well... it's not for a grade...
14:15:01 <shapr> dmhouse: Yeah, and then let us look at your notes and suggest things!
14:15:01 <glguy> SamB: why do you remember that? :)
14:15:13 <SamB> glguy: I remember being surprised the gl didn't stand for OpenGL!
14:15:39 <glguy> ah, OK :)
14:16:25 <glguy> ?pl \a b -> sequence (sequence [(+),(-),(*)] a) b
14:16:25 <lambdabot> sequence . sequence [(+), (-), (*)]
14:16:32 <glguy> that's not too bad I suppose
14:16:35 <shapr> I need exercise desparately :-( Does anyone know how I can get a tire pump for a presta valve delivered to me in Birmingham, AL?
14:16:49 <shapr> Yeah I know, silly question...
14:16:56 <shapr> Any Haskellers in the Southeast USA?
14:17:08 <glguy> sounds like homework...
14:17:10 <glguy> ;)
14:17:11 <shapr> :-P
14:17:20 <SamB> no it doesn't!
14:17:26 <glguy> for PE class
14:17:28 <glguy> ?
14:17:29 <SamB> homework doesn't ask such real-world questions!
14:17:30 <shapr> I turn 35 in 1.5 weeks, I would actually enjoy some homework.
14:17:32 <dylan> shapr: give me a few more months, and I'll call myself a haskeller. ;)
14:17:37 <shapr> dylan: Where are you?
14:17:42 <SamB> the answers are too changing!
14:17:45 <shapr> Ah, tampa
14:18:03 <SamB> anyway, if it were PE homework the point would be to have the pump, not how you got it...
14:18:05 <dylan> shapr: Florida, which is as south and as east as it gets.
14:18:14 <shapr> dylan: Do you ever get up to Alabama?
14:18:16 <glguy> The line is used might be clearer than tooling around with sequence tho... opResults a b = [a*b,a+b,a-b] ++ (guard(b/=0) >> [a / b])
14:18:18 <dylan> (specifically the greater Tampa area)
14:18:20 <SamB> unless you were supposed to walk or something!
14:18:34 <dylan> shapr: Not usually, but I'm planning on going to Georgia in a few months
14:18:42 <shapr> What part? Atlanta?
14:18:43 <glguy> SamB: You feeling particularly argumentative? ;)
14:18:46 <dylan> yeah, Atlanta
14:18:53 <SamB> glguy: no!
14:18:56 <SamB> this is normal!
14:18:56 <glguy> lol
14:19:18 <shapr> Atlanta is two hours drive from here, so it's unlikely I'll show up and see you. Mostly because I don't have a car, mind you...
14:19:37 <dylan> shapr: haha, I also don't have a car. XD
14:19:46 <shapr> How do you survive in the US without a car?
14:19:58 <dylan> Well, I bike to class...
14:19:59 <shapr> Carillon_: your bells are swinging!
14:20:07 <dylan> for LUG meetings, I get someone to give me a ride
14:20:17 <dylan> for the grocery store, either my girlfriend drives or I bike there.
14:20:28 * shapr figures a cruel insult for a carillon is to call it a glockenspiel.
14:20:32 <dylan> and for work, I car pool with my father.
14:21:41 <shapr> I'd go without a car if that were a worthwhile option.
14:21:43 <dmwit> I had a light-bulb moment today: I now understand the ($) operator.
14:21:50 <shapr> dmwit: spiffy
14:22:02 <shapr> dmwit: How would you explain that op?
14:22:29 <mauke> ($) = id
14:22:43 <dmwit> It just sends the second bit as an argument to the first, but at really low priority.
14:22:51 <dmwit> I think.
14:23:02 <glguy> > ($) 1
14:23:03 <lambdabot>  add an instance declaration for (Num (a -> b))
14:23:03 <dylan> shapr: it helps that this is a pretty city-like area. Everything is close by and there is a comprehensive bus network.
14:23:13 <shapr> Yup, it's just like function application, but low priority.
14:23:34 <shapr> dylan: B'ham does not have pedestrian anything, and I'm not sure there's a bus system at all.
14:23:44 <mauke> ($) = id :: (a -> b) -> (a -> b)
14:23:55 <dmwit> So, I can replace things like ((f .) . g) to (f $ g) now and feel much, much better.
14:24:15 <dmwit> Plus it works for g's that take more than two arguments... =)
14:24:23 <xerox> (f .) . g  =  \x y -> f (g x y)
14:24:36 <dylan> shapr: Yikes, that sucks. We have a highway-for-bikes here, and lots of side walks. I think it's mostly for recreation, but freaks like me use it for other purposes.
14:24:39 <xerox>   = let (.:) = (.) . (.) in f .: g
14:24:46 <xerox> (The last one is kinda nice, I think.)
14:24:47 <SamB> highway for bikes?
14:24:53 <SamB> What is that!?!
14:25:02 <shapr> dylan: I just found the bus route map - http://www.bjcta.org/fileadmin/user_upload/bjcta.org/images/routes/dartbig.jpg
14:25:03 <glguy> @type (.) . (.)
14:25:05 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:25:23 <xerox> glguy: the number of compositions composed is equal to the arity of the function composed with an unary one
14:25:24 <xerox> :D
14:25:32 <dylan> SamB: it is a road where only bikes are allowed. It has over-passes over all the busy streets.
14:25:46 <shapr> It seems that bham's bus coverage includes only a few blocks around the university.
14:25:51 <dylan> shapr: That is a horrible system map
14:25:53 <glguy> ?pl fork f g h x = f x `g` h x
14:25:54 <lambdabot> fork = (ap .) . flip (.)
14:25:55 <SamB> dylan: sounds cooooool
14:26:15 <shapr> This is the worst bus system I've ever seen.
14:26:23 <SamB> a few blocks?
14:26:26 <mauke> ?pl \g f h x -> f x `g` h x
14:26:27 <lambdabot> liftM2
14:26:31 <mauke> huhu
14:26:47 <dylan> http://www.pinellascounty.org/trailgd/PDF/overview_map.pdf <-- map of the trail (the bike highway is my pet name for it)
14:26:56 <SamB> mauke: that (r ->) Monad again ;-)
14:27:30 <shapr> SamB: The coverage appears to be 25 city blocks by 15 city blocks.
14:27:51 <SamB> oh
14:27:51 * dmwit returns to lurk mode
14:27:54 <glguy> I've become very used to the forks (as shown) and hooks (ap in (->) r)
14:28:11 <SamB> that sounds like it might be of *some* use
14:28:13 <glguy> of J, makes some of the craziness in (->) r more desireable
14:28:17 <shapr> dmwit: Nice to talk to you, feel free to jump in more :-)
14:28:39 <glguy> (liftM2 (/) sum length) [1,4,6]
14:28:42 <glguy> > (liftM2 (/) sum length) [1,4,6]
14:28:42 <lambdabot>  add an instance declaration for (Fractional Int)
14:28:47 <glguy> > (liftM2 (/) sum length) [1.0,4,6]
14:28:48 <lambdabot>  add an instance declaration for (Fractional Int)
14:28:48 <lambdabot>   In the list element: 1.0
14:29:01 <glguy> > (liftM2 (/) sum length) map fromIntegral [1,4,6]
14:29:01 <lambdabot>    The function `(liftM2 (/) sum length)' is applied to three arguments,
14:29:01 <lambdabot>  ...
14:29:04 <glguy> > (liftM2 (/) sum length) $ map fromIntegral [1,4,6]
14:29:05 <lambdabot>  add an instance declaration for (Fractional Int)
14:29:10 <glguy> OHH
14:29:10 <glguy> lenght
14:29:14 <glguy> length*
14:29:14 <mauke> length returns int
14:29:35 <glguy> > (liftM2 (/) sum (fromIntegral . length)) [1,4,6]
14:29:37 <lambdabot>  3.6666666666666665
14:29:40 <glguy> there we go
14:29:44 <SamB> glguy: you do realize that 1 = fromInteger 1, right?
14:30:02 <dolio> ?hoogle length
14:30:03 <lambdabot> Prelude.length :: [a] -> Int
14:30:04 <lambdabot> Data.PackedString.lengthPS :: PackedString -> Int
14:30:04 <lambdabot> Foreign.Marshal.Array.lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
14:30:06 <mauke> > (liftM2 (/) sum genericLength) [1,4,6]
14:30:08 <lambdabot>  3.6666666666666665
14:30:17 <glguy> ah, very good
14:30:41 <SamB> probably it is better to use fromInteger . length than genericLength...
14:30:50 <glguy> why is that?
14:30:52 <SamB> er, fromInt
14:30:55 <SamB> whatever...
14:31:01 <Cale> they're the same :)
14:31:11 <Cale> well, not quite
14:31:20 <SamB> Cale: I betcha length fuses better!
14:31:49 <Cale> hmm, if nobody implemented the fusion stuff for genericLength
14:32:01 <cjeris> glguy: were you actually programming in J for money?
14:32:07 <glguy> naw
14:32:18 <glguy> It just looked useful for mathschallenges.net problems
14:32:19 <SamB> also length probably has a more efficient loop, using Int#s as it probably does!
14:32:20 <dcoutts__> SamB: length doesn't fuse
14:32:21 <glguy> so I learned enough to use it
14:32:30 <SamB> dcoutts: it doesn't?
14:32:41 <SamB> ... why not?
14:32:47 <dcoutts__> SamB: since it's implemented as a foldl, not a foldr
14:32:54 <dcoutts__> SamB: read the ByteString paper
14:33:00 <glguy> so this isn't true?  genericLength = fromInt . length ?
14:33:09 <SamB> @type fromInt
14:33:11 <lambdabot> Not in scope: `fromInt'
14:33:11 * cjeris thinks J wins Ken Iverson the "certifiable mad genius" award
14:33:20 <SamB> hmm, apparantly fromInt is something I just invented
14:33:22 <dcoutts__> SamB:  we can do either and we explain roughly why build/fold can't
14:33:22 <glguy> Who told me to use fromInt then?
14:33:25 <SamB> fromIntegral is the real name
14:33:37 <glguy> so this isn't true?  genericLength = fromIntegral . length ?
14:33:46 <Cale> SamB: fromInt was available in Haskell 1.4 or 1.3, I think
14:33:51 <Cale> glguy: not quite
14:33:54 <SamB> glguy: probably not
14:33:57 <dcoutts__> glguy: correct, that's not true.
14:34:10 <glguy> ok, so what does genericLength actually do?
14:34:14 <Cale> glguy: If the list length doesn't fit in an Int, those will differ
14:34:23 <SamB> but it should give the same answers if you don't have a really wierd computer
14:34:35 <dcoutts__> glguy: it's not true because of precision. Imagine if and Int is not big enough.
14:34:47 <SamB> Cale: aren't Ints 64 bit on 64-bit architectures?
14:34:54 <dcoutts__> glguy: fromIntegral . length  does it with Int and then converts to say Integer
14:34:55 <Cale> SamB: probably
14:35:13 <dcoutts__> glguy: but that doesn't help if it was longer than an Int could hold!
14:35:16 <SamB> actually, I was thinking more of the Float case ;-)
14:35:38 <SamB> but, you can't fit lists that big in memory anyway, usually...
14:35:40 <dcoutts__> glguy: you'd need to do it from the beginning using a bigger integer type, that's what genericLength does.
14:35:48 <SamB> so unles all you are doing is taking their length...
14:36:09 <dcoutts__> glguy: so they'll be the same most of the time, unless your list is longer than an Int can hold.
14:36:21 <dcoutts__> glguy: make sense?
14:36:40 <glguy> I suppose
14:37:27 <glguy> does it compute in terms of Int until the maximum is exceeded and then start using Integers (under the hood)
14:37:33 <Cale> It's pretty hard to count to  9223372036854775807
14:37:42 <glguy> or use Integers for the whole thing
14:37:55 <dmwit> glguy: whole thing
14:37:55 <SamB> > 2^32 :: Integer
14:37:56 <lambdabot>  4294967296
14:38:09 <Cale> If it's Integer that you're using than it will use Ints if things stay small enough
14:38:12 <dolio> > 2^32 :: Int
14:38:12 <tibbe> > 2^64 :: Integer
14:38:14 <lambdabot>  18446744073709551616
14:38:15 <lambdabot>  0
14:38:44 <SamB> dcoutts: how much memory does a String of length n take again?
14:39:14 <dolio> As I recall, the paper said 12 bytes per Char.
14:39:36 <SamB> so...
14:39:41 <dolio> 12n bytes.
14:40:02 <SamB> > 2^32 / 12
14:40:04 <lambdabot>  3.579139413333333e8
14:40:20 <dmwit> > 2 ^ 32 * 12
14:40:21 <lambdabot>  51539607552
14:40:23 <int-e> 12 bytes, but only because the chars are shared - so you end up with one tag and two pointers for one list element.
14:40:40 <dcoutts__> glguy: but Ineger is already special cased for numbers that fit into Int, so that's ok
14:40:42 <SamB> dmwit: you don't have that much address space on a 32-bit arch...
14:40:58 <dmwit> Exactly...
14:41:03 <dcoutts__> SamB: lots :-)
14:41:16 <dmwit> That's how much space you'd need to overflow an Int in the length function, right?
14:41:33 <dcoutts__> SamB: see the ByteString paper, but from memory I think it's 12 bytes per char.
14:41:50 <SamB> dcoutts: thats what I thought ;-)
14:41:55 <SamB> anyway, even if it was 1...
14:42:07 <dcoutts__> SamB: hence reversing a 50Mb file takes a lot of memory :-)
14:42:12 <glguy> when I execute > length (repeat ())   does ghc actually build a huge list?
14:42:30 <dcoutts__> glguy: no, thanks to lazy evaluation.
14:42:39 <Cale> It would build a list and throw it away as it goes.
14:42:46 <glguy> so it garbage collects the used portion
14:42:49 <Cale> Or it would get fused.
14:42:55 <SamB> you couldn't fit 2^32 of those in memory and have room left for anything else, so you couldn't overflow the Int unless you weren't actually using the list for anything else...
14:43:03 <dcoutts__> Cale: though in this case it doesn't.
14:43:25 <glguy> What's the outlook on ghc6.5?
14:43:29 <SamB> dcoutts__: certain?
14:43:41 <dcoutts__> SamB: for Data.ByteString.length we reuturn Int for the same reason.
14:44:09 <dcoutts__> SamB: where as for Data.ByteString.Lazy.length we use Int64 since you can stream things much bigger than memory
14:44:22 <SamB> hmm
14:44:34 <dcoutts__> SamB: am I sure about the length not fusing under build/fold fusion you mean? Yes I am.
14:44:49 * SamB would think it would be dangerous to take the length of something bigger than memory
14:45:09 <dcoutts__> so long as you're not otherwise retaining it, you're fine
14:45:13 <glguy> What's this build/fold you keep talking about? does this go back to the shortcut deforestation?
14:45:29 <dcoutts__> glguy: yes, it's shortcut deforestation
14:45:30 <SamB> yes... but WTH would you *JUST* want to take the length of such a huge bytestring?
14:45:42 <dcoutts__> SamB: not often I guess :-)
14:45:58 <musasabi> SamB: implement wc -m ?
14:46:05 <SamB> musasabi: um
14:46:11 <dcoutts__> wc -c
14:46:13 <SamB> wc has to calculate three things!
14:46:29 <dcoutts__> wc -c calculates only the byte count
14:46:37 <dcoutts__> wc on it's own does all three
14:46:46 <vincenz> wc -flush
14:46:54 <dcoutts__> heh
14:46:56 <SamB> I would think wc calculated all three and just printed the byte count...
14:47:02 <dcoutts__> nope
14:47:11 <dcoutts__> you can tell by how long it takes
14:47:18 <dcoutts__> it's much slower to calculate all three
14:47:26 <SamB> interesting!
14:47:37 <dcoutts__> SamB: I've just submitted a paper where we benchamark all this stuff :-)
14:48:14 <dcoutts__> we wrote one line haskell unix utils and benchmaked then against the GNU versions
14:48:22 <dcoutts__> and the ordinary List versions
14:48:28 <vincenz> and then changed the parameters until the haskell versions won
14:48:33 <dcoutts__> hah
14:48:34 * vincenz whistles
14:48:44 <dcoutts__> yeah, basically :-)
14:48:54 <dcoutts__> of course the GNU utils still beat us
14:49:01 <dcoutts__> but often not by a big margin
14:49:13 <dcoutts__> where as we beat list by several orders of magnitude
14:53:16 <Cale> dcoutts__: Yeah, some of those graphs might have worked better with a log scale :)
14:53:27 <dcoutts__> aye, true
14:53:40 <dcoutts__> we can fix that for the final version of the paper
14:54:02 <dcoutts__> though a log scale graph doesn't quite have the same visual impact
14:54:06 <Cale> yeah :)
14:54:14 <dcoutts__> showing the massive difference
14:54:21 <Cale> that's true
14:54:36 <vincenz> Cale: what I also love is when people quietly cut off the bottom part of the y-grah
14:54:37 <dcoutts__> and the insignificant difference between the fast ByteString and the ultra-fast GNU utils
14:54:39 <vincenz> showing ony like
14:54:43 <vincenz> y:15-17
14:54:48 <Cale> vincenz: hehe
14:54:50 <SamB> hmm, it takes JHC a while to notice that my Main module has no main function...
14:54:50 <vincenz> with the original solution 15.1
14:54:53 <vincenz> and their solution 16.9
14:55:18 * SamB wonders if it will notice if he gives main a type of Int
14:55:29 <dcoutts__> vincenz: aye, that's a clasic trick
14:55:35 <vincenz> dcoutts__: sickens me
14:55:43 <Cale> Or use an exponential scale graph :)
14:57:12 <glguy> what's an examlpe of one of these one-liners
14:57:22 <SamB> how about...
14:57:31 <SamB> main = interact id
14:57:35 <SamB> guess!
14:57:42 <glguy> cat
14:57:43 <vincenz> yep
14:57:44 <vincenz> cat
14:57:47 <vincenz> or dog
14:57:47 <glguy> kind of
14:57:49 <SamB> good guess ;-)
14:57:55 <glguy> echo rather
14:58:00 <SamB> okay, so it is oversimplified!
14:58:02 <SamB> no, not echo!
14:58:05 <SamB> echo would be...
14:58:51 <glguy> cat file1 file2 file3 should actually output the concatenated contents of those files... interact id wouldn't do that
14:59:05 <dibblego> I just read some abstract tutorial on the IO monad - am I right in thinking that there is some implicit argument passed and returned and each successive function call depends on the value returned and so giving an order of execution?
14:59:05 <mauke> can't beat perl anyway :-)
14:59:10 <mauke> perl -pe0
14:59:19 <SamB> @pl main = getArgs >>= \args -> putStrLn (unwords args)
14:59:20 <lambdabot> main = putStrLn . unwords =<< getArgs
14:59:29 <mauke> dibblego: depends on the monad instance
15:00:06 <SamB> dibblego: that how GHC avoids confusing the order of things, yes...
15:00:14 <SamB> but an implementation detail!
15:00:18 <dibblego> ok
15:00:34 <dolio> Yeah, you don't have to do it that way.
15:00:35 <SamB> though actually it is explicit in some of the GHC.* code!
15:00:36 <dibblego> is that specific to the IO monad or could the same (fixed) reasoning apply to all monads?
15:00:36 <glguy> OK, so it's not echo, and it'd not cat
15:00:49 <SamB> glguy: it is a simplified cat
15:01:04 <SamB> works better than the one in BF though!
15:01:09 <SamB> as it is NUL clean
15:01:44 <glguy> BF is your benchmark? ;)
15:01:50 <SamB> no!
15:02:05 <glguy> "how good is your language?" "better than BF!"
15:02:11 <SamB> but come on! what do you expect from a one liner!
15:02:18 <glguy> :-D
15:02:22 <SamB> the GNU cat is probably like 10k lines!
15:02:26 <vincenz> SamB: a kitty
15:03:38 <dolio> dibblego: One way of visualizing the IO monad is to think of it as a State monad with the world as the state.
15:03:42 * SamB wonders what package has the curvy corner glyphs JHC uses for xterm
15:03:58 <dibblego> so now I have to read up on the State monad
15:04:02 <dolio> dibblego: The state monad is State s a = s -> (a, s), which is how you get the implicit parameters.
15:04:12 <dolio> dibblego: But not all monads are necessarily like that.
15:04:14 <SamB> @fptools Control.Monad.State
15:04:15 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
15:04:16 <dibblego> ok thanks
15:04:20 <dcoutts__> SamB: it relly is! :-)
15:04:23 <SamB> dibblego: just go look at it!
15:04:31 <dibblego> SamB, I have, many times
15:04:44 <dcoutts__> SamB: I think it might just squeese in under 10k, but not by a huge margin. :-)
15:04:50 <SamB> dcoutts: my estimate is good? cool!
15:05:19 <glguy> OpenBSD's cat is 255 lines
15:05:25 <SamB> heh
15:05:29 <glguy> according to wc -l
15:05:35 <SamB> what in the world does GNU's do?
15:05:43 <glguy> it's a trojan
15:05:54 <dcoutts__> mmap this and align buffers there etc etc
15:05:57 <mauke> at least it doesn't read mail, like GNU helloworld
15:06:08 <dibblego> is the State monad a reasonable place to start internalising what a monad is?
15:06:15 <SamB> dibblego: sure!
15:06:25 <dcoutts__> that or the list monad
15:06:28 <dolio> It's certainly better than the Cont monad.
15:06:34 <SamB> the list monad is a bit confusing...
15:06:34 <dcoutts__> heh, yes
15:06:41 <mauke> dibblego: "monad" is just an interface
15:06:43 <glguy> though not as good as the (->) r monad
15:06:55 <SamB> the (->) r monad doesn't sequence
15:06:56 <dcoutts__> SamB: but it gives you the perspective that monads are not just IO style stateful computations
15:07:01 <dcoutts__> even Maybe is a monad
15:07:08 <SamB> true
15:07:10 <dolio> Oh, speaking of which, glguy, are there any good tutorials on J you used when learning?
15:07:15 <mauke> isn't there an identity monad?
15:07:19 <SamB> but at least Maybe doesn't confuse you with nondeterminism...
15:07:19 <dcoutts__> yep
15:07:45 <dcoutts__> SamB: it's not that bad, it's just like list comprehensions
15:07:45 <glguy> dolio: I read a paper called "Easy-J: An Introduction to the World's Most Remarkable Programming Language" from the wiki
15:07:50 <glguy> among others
15:07:56 <SamB> dcoutts: true
15:07:57 <dolio> Ah, okay. Thanks.
15:08:09 <dcoutts__> SamB: backtracking/nondeterminism is just one of the things you can model that way
15:11:05 <musasabi> SamB: utf-8 terminal.
15:11:14 <musasabi> (for jhc)
15:11:21 <SamB> musasabi: hmm?
15:11:28 <SamB> I have my terminal running in UTF-8...
15:11:45 <SamB> I'm just missing some glyphs!
15:12:19 <musasabi> doesn't work either in uxterm?
15:12:26 <musasabi> missing fonts could be an issue.
15:12:37 <musasabi> it is mostly just arrow symbols
15:13:10 <musasabi> and the "threading" like listing of subterms in the verbose outputs
15:13:35 <SamB> isn't uxterm just a shellscript that sets some env vars and calls xterm?
15:14:15 <musasabi> yes. I was thinking of it as a quick test to see whether it was some terminal issue or font issue.
15:15:06 <musasabi> (as uxterm is what I have seen it to work with)
15:17:11 <musasabi> -> sleep
15:17:26 <SamB> oooookay... it works in uxterm...
15:21:10 <dcoutts__> Igloo: ta for fixing the alex/happy issue
15:25:16 <Igloo> np
15:26:25 <glguy> Does the steel rain pierce the heart of the silver dove?
15:29:28 <xerox> SamB: the (->) a monad *do* sequence!!!
15:29:36 <xerox> SamB: it's a pretty neat combinator too.
15:30:11 <xerox> > sequence [even,odd,(<10)] 2
15:30:12 <lambdabot>  [True,False,True]
15:30:18 <SamB> that ain't what I meant!
15:30:20 <SamB> I mean that
15:31:04 <shizzy0> Hi everyone.  I have a question about how I might refactor some code.  It has to do with named records.
15:31:12 <SamB> well, the computations need not be done in any particular order
15:32:39 <shizzy0> I have a number of flip functions that look like this: flipGravity world = world { gravityActive = (not.gravityActive) world }
15:33:00 <shizzy0> One more so you can see the general pattern: flipDamping world = world { dampingActive = (not.dampingActive) world }
15:33:43 <SamB> thats about as good as it gets right now...
15:33:44 <shizzy0> I just want to know if there's a way rewrite these flip* functions of mine to be more generic and still do the record update.
15:34:06 <shizzy0> really?
15:34:12 <SamB> admittedly kinda pathetic...
15:34:22 <SamB> considering how common that sort of pattern is...
15:34:41 <SamB> (updating a field with a function like thaT)
15:34:45 <SamB> er, *that
15:34:57 <shizzy0> bummer.
15:36:20 <shizzy0> but that's cool.  At least I don't have to look at that code and wonder if there's a better way in Haskell to do it.
15:36:43 <shizzy0> Thanks SamB for having a look at it.  :)
15:42:49 <Tela> Can you use contexts in type synonyms? I can't seem to get it to work
15:43:03 <Tela> type Point = Floating a => (a,a)
15:44:59 <dcoutts__> xerox: you about?
15:45:05 <dcoutts__> SyntaxNinja: ping
15:45:28 <dcoutts__> I'm wondering if I can remove most of the Cabal/dependencies directories
15:45:36 <dcoutts__> currently we have:
15:45:39 <dcoutts__> Crypto-2.0.0  GnuPG-0.1.1  hackage-client-0.1.0  HaXml-1.2  HTTP-2005.5.5  NewBinary-0.1  XmlRpc-2005.5.5
15:46:04 <dcoutts__> I think only HTTP is needed, and actually we'll use a later version that doesn't depend on so much stuff
15:46:39 <dcoutts__> so for this release I think I can blow it all away
15:47:10 <dcoutts__> we may add HTTP-2006.x.y back later for a subsequent release including cabal-install
15:47:20 <xerox> dcoutts__: check my repo
15:47:26 <dcoutts__> where's that?
15:47:42 <xerox> http://hackage.haskell.org/~paolo/darcs/Cabal
15:47:49 <dcoutts__> ta
15:47:54 <xerox> Ops
15:47:55 <xerox> A second
15:48:00 <dcoutts__> heh
15:48:14 <xerox> I did elimitate the link because I did the cabal-install, but let me do it again
15:48:21 <dcoutts__> ta muchly :-)
15:48:45 <xerox> Done.
15:48:52 <xerox> np :)
15:49:01 <xerox> G'night.
15:49:24 <dcoutts__> g'night xerox
15:59:56 <mnvl> @help
15:59:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:00:05 <mnvl> http://www.google.com
16:00:06 <lambdabot> Title: Google
16:00:13 <mnvl> http://localhost
16:00:38 <mnvl> http://localhost/
16:02:00 <SamB> presumably lambdabot isn't running a webserver on port 80 ;-)
16:02:40 <mnvl> well i had to check
16:03:30 <dibblego> can a tuple contain n elements for any n?
16:03:35 <mnvl> http://whatismyip.com
16:03:36 <lambdabot> Title: WhatIsMyIP.com - 129.94.174.82
16:03:50 <SamB> dibblego: well...
16:03:54 <SamB> no.
16:04:01 <SamB> but almost
16:04:25 <dibblego> why almost?
16:04:46 <dcoutts__> the implementation will have some upper bound
16:04:49 <SamB> they go higher than *eyes* do
16:04:58 <newlambder> hey sexy folks
16:05:03 <newlambder> i got ghc on my win xp
16:05:06 <newlambder> now what
16:05:12 <dcoutts__> @brain
16:05:13 <lambdabot> I think so, Brain, but I don't think Kaye Ballard's in the union.
16:05:25 <dcoutts__> hmm, not what I was thinking of
16:05:36 <dcoutts__> newlambder: now time to take over the world.
16:05:59 <SamB> no,no. The same thing we do every night, pinky!
16:06:04 <SamB> Try to take over the world!
16:06:08 <dcoutts__> right
16:06:11 <dcoutts__> @brain
16:06:12 <lambdabot> Gee, Brain, what are we going to do tonight?
16:06:12 <lambdabot> The same thing we do every night, Pinky. Try to take over the world!
16:06:15 <dcoutts__> yay
16:07:45 <dcoutts__> newlambder: now to write some code I guess, have you read any tutorials etc?
16:07:53 <dibblego> is the data keyword exclusively associated with type constructors?
16:08:22 <dcoutts__> newtype can also be used, it's kind of a special case of data
16:08:29 * SamB doesn't understand the question
16:08:37 <dcoutts__> dibblego: perhaps I didn't understand the Q either
16:09:53 <dibblego> I am just reading about type constructors - just want to know that every time I see the data keyword, I know I am looking at a type constructor declaration
16:10:08 <vincenz> you're looking at a data type declaration
16:10:12 <vincenz> this compromise a type constructor
16:10:14 <vincenz> and data constructors
16:10:58 <dcoutts__> data Foo = Bar Int
16:11:10 <dcoutts__> Foo is the type name and indeed a type constructor
16:11:19 <dcoutts__> Bar is a data constructor for the type Foo
16:11:19 <vincenz> Bar is the data constructor
16:11:26 <vincenz> :)
16:11:27 <dibblego> X a = Just a | Nothing
16:11:33 <dibblego> why doesn't ghci like that?
16:11:33 <vincenz> dibblego: you mean
16:11:34 <vincenz> data X a
16:11:46 <dibblego> Prelude> data X a = Just a | Nothing
16:11:47 <dibblego> <interactive>:1:0: parse error on input `data'
16:11:49 <vincenz> and you can't enter data declarations into ghci
16:11:54 <dibblego> ok
16:11:56 <vincenz> ghci doesn't allow declarations afaik
16:11:59 <vincenz> only expressions
16:12:03 <dcoutts__> righht
16:12:35 <shapr> @users
16:12:36 <lambdabot> Maximum users seen in #haskell: 232, currently: 210 (90.5%), active: 29 (13.8%)
16:12:37 <shapr> wheee
16:12:56 <vincenz> > return "cookie" >>= replicate 210
16:12:58 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
16:13:14 <dibblego> and ghci can't declare type synonyms either?
16:13:21 <vincenz> no declarations
16:13:24 <vincenz> not even function
16:13:26 <vincenz> that's why you have to do
16:13:30 <vincenz> let xxx  = yyy
16:13:33 <vincenz> instead of
16:13:35 <vincenz> xxx = yyy
16:13:45 <SamB> you are lucky to be allowed *that* much
16:13:48 <dibblego> ok
16:13:56 <vincenz> SamB: well it's an io monad
16:14:33 <vincenz> you can use let without in in monads
16:14:34 <SamB> well, yeah, but those names require a dynamic environment...
16:14:52 <SamB> I mean, that isn't really because of the IO monad...
16:15:11 <dibblego> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html "Values of the built-in type Int are whole numbers. They are limited in size (32 bits)" -- I thought Int extended to +/-infinity
16:15:13 <lambdabot> Title: Tour of the Haskell Syntax, http://tinyurl.com/kf5wj
16:15:22 <SamB> dibblego: nope!
16:15:56 <dibblego> in ghci I can type an integer literal greater than 32 bits and the expression is evaluated
16:15:57 <dmwit> Integer, though... ;-)
16:16:03 <SamB> doesn
16:16:14 <SamB> 't have + or - Infinity either
16:16:27 <dmwit>  That's true.
16:16:41 <dibblego> there is a distinction between Int and Integer?
16:16:48 <vincenz> yes
16:16:52 <vincenz> Integer isn't bounded
16:17:18 <int-e> > (10^20 :: Int, 10^20 :: Integer)
16:17:20 <lambdabot>  (1661992960,100000000000000000000)
16:17:24 <dibblego> gah, that's right underneath
16:18:36 <SamB> > 10^20
16:18:37 <lambdabot>  100000000000000000000
16:18:40 <newlambder> i want to learn to use happs
16:18:48 <vincenz> > 2 ^ 100
16:18:49 <newlambder> I guess ghc is the first step eh
16:18:49 <lambdabot>  1267650600228229401496703205376
16:18:52 <vincenz> > 2 ^ 100000
16:18:54 <lambdabot>  9990020930143845079440327643300335909804291390541816917715292738631458324642...
16:18:56 <vincenz> damn
16:18:58 <vincenz> > 2 ^ 100000000
16:19:02 <lambdabot> Terminated
16:19:06 * vincenz is trying to go over his 3 second
16:19:30 <vincenz> 01:18 < vincenz> > 2 ^ 10000000
16:19:30 <vincenz> 01:18 < lambdabot> Terminated
16:19:30 <vincenz> 01:18 < vincenz> > 2 ^ 1000000
16:19:30 <vincenz> 01:18 < lambdabot>  out of memory (requested 1048576 bytes)
16:19:32 <vincenz> woo
16:23:01 <dibblego> my laptop calculated it
16:23:08 <vincenz> of course
16:23:13 <vincenz> your laptop doesn't include dons' thing
16:23:13 <dibblego> it made the fan spin though
16:23:22 <SamB> ... the fan?
16:23:27 <dibblego> the CPU fan
16:23:35 <SamB> ... not the disk?
16:23:36 <vincenz> prolly caching of memory
16:23:41 <dibblego> no, the CPU fan
16:23:43 <vincenz> and most likely disk
16:23:56 <vincenz> I get the same noise when my laptop starts calculating big things
16:24:10 <dibblego> I get that noise when my laptop gets hot
16:24:21 <dibblego> like when it doesn't hibernate properly in its case
16:24:31 <vincenz> dibblego: make?
16:24:40 <dibblego> Dell
16:24:47 * vincenz too
16:24:51 <vincenz> dibblego: which one
16:24:59 <dibblego> Inspiron 6400
16:25:01 <vincenz> doh, my ghci is hanging and CTRL+C won't kill it
16:25:05 <vincenz> I did 2^1000000
16:25:11 <vincenz> latitude d610
16:25:18 <dibblego> just kill -9 ghci
16:25:28 <dmwit> Wait, so recursion + memoization == dynamic programming?
16:25:58 <vincenz> no
16:26:01 * vincenz goes to bed now
16:26:08 <dmwit> Okay, phew.
16:38:50 <SyntaxNinja> dcoutts__: yeah, I think you can/should blow the unnecessary dependencies away.  also check for duplicate unnecessary dependencies ;)
16:39:03 <dcoutts__> heh
16:39:10 <dcoutts__> it's all gone now
16:39:14 <dcoutts__> I've pushed
16:39:20 <dcoutts__> and I'm just uploading a tarball
16:39:22 <SyntaxNinja> yay
16:39:29 <dcoutts__> second RC
16:39:32 <dcoutts__> 1.1.5.9.2
16:39:32 <SyntaxNinja> at least while I'm in stupid meetings, the rest of the world is productive ;)
16:41:31 <dcoutts__> heh
16:46:30 <sjanssen_> @. elite keal
16:46:30 <lambdabot> Per|-|4pz I jUzT GEnius ANd N3\/Er 7E$TED
16:46:46 <sjanssen_> perhaps keal, perhaps
16:49:00 <dcoutts__> SyntaxNinja: http://www.haskell.org/cabal/release/cabal-1.1.5.9.2/
16:49:02 <lambdabot> Title: Index of /cabal/release/cabal-1.1.5.9.2, http://tinyurl.com/ku8t4
16:49:15 <dcoutts__> we need an updated changelog btw
16:49:21 <dcoutts__> and probably some manual updates
16:49:31 <dcoutts__> and the website is getting a bit out of date
16:49:52 <dcoutts__> in the mean time I'll got make a gentoo ebuild for that release candidate
16:50:03 <dcoutts__> and test it with the current ghc rc snapshot
16:51:37 <SyntaxNinja> dcoutts__: cool
16:51:42 <lispy> dcoutts__: i tried to cabalize darcs the other day and i think it would be nice if cabal could do some dynamic configuration based on fields in the .cabal file
16:52:00 <dcoutts__> lispy: that's a planned feature
16:52:06 <lispy> dcoutts__: goody
16:52:08 <dcoutts__> confiurations we're calling it
16:52:20 <dcoutts__> well that but spelt correctly
16:52:35 <lispy> dcoutts__: so that on windows it adds in or subtracts certain packages?
16:52:37 <dcoutts__> lispy: what dynamic stuff do you need?
16:52:47 <dcoutts__> yes, that should be fine
16:52:54 <dcoutts__> well, only adds
16:53:06 <dcoutts__> so you'd have a base set and add to that depeding on os
16:53:29 <SamB> that sounds bad...
16:53:50 <SyntaxNinja> lispy: yeah, but configurations turning into a can of worms, so not clear how long it's going ot take
16:53:54 <deadbeef> nite there
16:53:56 <deadbeef> 2am here
16:54:00 <deadbeef> and i've an exam tomorrow
16:54:11 <SamB> deadbeef: you should be in bead already!
16:54:16 <SamB> er, bed1
16:54:18 <deadbeef> rly
16:54:22 <glguy> yarly
16:54:27 <SamB> hehe
16:54:40 <glguy> nowai!
16:54:56 <lispy> dcoutts__: i'm not sure to what extent, but darcs uses autotools and all that cruft currently for a lot of heavy lifting at config time
16:55:38 <dcoutts__> lispy: aye, so it's sometimes hard to see what it's doing. I've got the same with gtk2hs
16:55:42 <lispy> another thing i would like to be able to do is exclude files from the typical config
16:56:20 <dcoutts__> SyntaxNinja: though we think we have a consistent story for configurations, fewer worms.
16:57:04 <lispy> maybe there is more to cabal than i realize, but i think maybe you should be able to easily hook into and inspect/manipulate command line parameters right when a file is about to be compiled
16:57:33 <lispy> so maybe i'm talking about things to do in Setup.lhs now
16:57:52 <dcoutts__> mm, that's not ideal
16:58:03 <dcoutts__> it wants to be more static than that
16:58:20 <dcoutts__> so that eg IDEs have a chance to know what options you're using to build something
16:58:31 <dcoutts__> or other build tools
17:00:04 <dcoutts__> SyntaxNinja: yeah, so musasabi and I think we've got a reasonable configurations plan, now we just need to sell it to you, JaffaCake and other people.
17:00:54 <lispy> dcoutts__: hmm...well, hopefully whatever you decide on allows darcs to be built with its multitude of options
17:01:36 <dcoutts__> lispy: can you give me any idea of the trickiness of darc's build options?
17:01:38 <SyntaxNinja> dcoutts__: have you broached it on cabal-devel?
17:01:51 <dcoutts__> SyntaxNinja: yep, long threads
17:01:59 <dcoutts__> various iterations
17:02:10 <SyntaxNinja> dcoutts__: oh, so not something new that hasn't been discussed on cabal-devel?
17:02:43 <dcoutts__> no, but we've not had other people take enough of a look at what we came with in the end
17:03:03 <dcoutts__> we'll try and sell it again after ghc 6.6 is out the door
17:03:22 <SyntaxNinja> OK. sorry if I was unresponsive, I thought I'd replied on all of the configurations threads.
17:03:37 <Igloo> To some extent there's no single Right Answer, so in discussions you're always going to have people saying they think it should be done differently
17:04:18 <Igloo> I'd recommend putting together a concrete suggestion, seeing if people have /major/ problems with it, and if not implement it
17:04:55 <dcoutts__> Igloo: aye
17:05:04 <SyntaxNinja> I recommend seeing if people have a major problem, then pouring concrete on them, and implementing what you want anyway ;)
17:05:10 <dcoutts__> that's probably the best approach
17:05:15 <dcoutts__> hah
17:05:47 <dcoutts__> the main thing is that we're not letting devs get away with being too sloppy at the expense of packagers or package managers
17:06:37 <Igloo> Does cabal have a way to use packages in-place, BTW?
17:06:46 <dcoutts__> nope
17:06:54 <dcoutts__> though all the building block are in place
17:07:08 <Igloo> Ah, so it will for 6.8?
17:07:13 <dcoutts__> heh
17:07:25 <dcoutts__> Igloo: that's a use case we've not thought about enoughh yet,
17:07:39 <dcoutts__> a bit project made up of several cabal packages in one source tree
17:07:44 <dcoutts__> bit/big
17:07:58 <dcoutts__> that's where you want registering in place right?
17:07:58 <Igloo> We're going to need it if we want to use cabal to build GHC
17:08:04 <dcoutts__> indeed
17:08:12 <dcoutts__> or gtk2hs, or HDBC or whetever
17:08:50 <SamB> dcoutts: actually, if people have a *real* problem, pouring concrete on them will just let their code bitrot and it was probably something really cool like darcs or hIDE or gtk2hs or something like that
17:08:52 <Igloo> Unfortunately I don't think it's safe in general, as you have to just know that the libraries don't care that they aren't installed where you told them they were going to be
17:09:12 <dcoutts__> Igloo: true
17:09:25 <Igloo> SamB: Are you saying dcoutts__ has a real problem?
17:09:34 <SamB> Igloo: no!
17:09:39 * dcoutts__ has several
17:09:43 <Igloo> SamB: Oh, OK, I'll say it then.
17:09:53 <Igloo> Damn, beaten to it!
17:09:54 <dcoutts__> hah hah
17:10:08 <SamB> I was just saying that encasing poeple in concrete is not the best solution to that problem
17:10:30 <dcoutts__> @remember SamB I was just saying that encasing poeple in concrete is not the best solution to that problem
17:11:10 <SamB> ah, such wacky quotes we get ;-)
17:11:11 <SamB> @quote
17:11:12 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
17:11:18 <SamB> @quote
17:11:19 <lambdabot> twb says: But, I love my job. It's like being in a rock band. i.e. no pay, but fun.
17:11:29 <SamB> @quote
17:11:29 <lambdabot> vincenz says: Geek is Chique.
17:11:35 <SamB> @quote
17:11:36 <lambdabot> mwc says: I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
17:11:49 <SamB> @quote
17:11:49 <lambdabot> Pseudonym says: If Hofstadter had said this, it would have been much funnier.
17:12:04 <SamB> @quote
17:12:04 <Igloo> Wait, Haskell isn't pseudo code? You mean I can actually /run/ my programs?
17:12:05 <lambdabot> lennart says: [August 1990] DON'T BLAME HASKELL WHEN THINGS GO WRONG
17:12:09 <SamB> Igloo: heh!
17:12:32 <Igloo> Sorry, I seem to be in a silly mood tonight
17:12:51 * Igloo blames writing python
17:12:55 <SyntaxNinja> Igloo: silliness is permitted.
17:12:57 <SamB> hahaha
17:13:07 <SyntaxNinja> just don't say "dude". I can't picture it.
17:13:10 <SamB> am silly also I!
17:13:12 <SamB> heh
17:13:16 * dcoutts__ neither
17:13:24 <SamB> @quote
17:13:25 <lambdabot> edwardk says: lambdabot is the first irc bot i ever added to my buddy list
17:13:31 <Igloo> You should have come to AFP in Sweden. You could have seen it in person.
17:13:35 <SyntaxNinja> Igloo: also, how come you're always up at the same time I am even though you live on the other side of the world.
17:13:41 <dcoutts__> Igloo: or use HUnit for the ghc testsuite :-)
17:13:48 * Igloo got accused of being Holly by a Chalmers dude
17:13:58 <SamB> Holly?
17:13:59 <SyntaxNinja> Who is Holly?
17:14:04 <Igloo> From Red Dwarf
17:14:12 <Igloo> SyntaxNinja: Us Brits don't need sleep
17:14:13 <SamB> I was just about to ask if it was that computer dude
17:14:24 * Igloo points at dcoutts for corroboration
17:14:29 <dcoutts__> SyntaxNinja: Igloo is nocturnal
17:14:44 <SamB> do you occasionally impersonate a newer model to get people to appreciate you?
17:14:59 <Igloo> dcoutts__: This isn't for the testsuite as such. I disabled the threaded way for unreg arches, but then of course it couldn't build timeout...
17:15:11 <Igloo> So now I have a python timeout too
17:15:23 <dcoutts__> sounds unpleasent
17:16:05 <dcoutts__> does the timeout prog really need the threaded rts?
17:16:07 <newlambder> ok
17:16:08 <newlambder> http://www.haskell.org/haskellwiki/Haskell_in_5_steps#Why_learn_Haskell.3F
17:16:11 <lambdabot> Title: Haskell in 5 steps - HaskellWiki, http://tinyurl.com/nxq82
17:16:13 <Igloo> It's better than a threaded testsuite driver running a threaded compiler to build and run threaded tests on a machine that randomly locks up if you use threads
17:16:21 <newlambder> when they are telling you how to make an executible
17:16:23 <dcoutts__> heh, ok
17:16:29 <newlambder> where do you place the hello.hs?
17:16:54 <newlambder> ghc is installed into c:\ghc\ghc-6.4.2
17:17:01 <dmwit> Anywhere you want.
17:17:11 <newlambder> and ghc wil find it?
17:17:21 <dcoutts__> you'll tell ghc where it is
17:17:25 <newlambder> ah
17:17:28 <dmwit> I think the deal is usually, you find ghc and tell it where the .hs is.
17:17:28 <Igloo> And yes, as waitForProcess will be a blocking IO call
17:17:33 <dmwit> (I'm too slow...)
17:17:55 <dcoutts__> Igloo: I see
17:18:08 <dcoutts__> newlambder: eg by cd'ing into the direcrory and saying: ghc --make hello.hs
17:18:27 <newlambder> ok
17:18:35 <dcoutts__> newlambder: and it'll build you a hello.exe
17:18:49 <Igloo> My python actually uses a SIGALRM timer, but I don't think doing it that way would play well with the RTS. Haven't tried it, admittedly.
17:18:56 <dcoutts__> newlambder: or maybe it's main.exe
17:19:09 <dcoutts__> they changed the default recently
17:19:29 <dmwit> What?  No a.out? ;-)
17:19:43 <dcoutts__> dmwit: not in win32 :-)
17:19:54 <Igloo> It'll be hello.exe in 6.6
17:20:24 <dcoutts__> Igloo: the rts uses that SIGALRM for scheduling right?
17:20:29 <dmwit> dcoutts__: Ah, right, it would have to be a.out.exe. =P
17:20:37 <dcoutts__> heh
17:20:48 <Igloo> Right
17:20:49 <SamB> dmwit: or a.exe
17:21:04 <SamB> I'm pretty sure it is a.exe
17:21:14 <dmwit> You mean for gcc and its ilk?
17:21:19 <SamB> yes
17:21:22 <dcoutts__> I recall it being main.exe for ghc-6.4.x
17:21:29 <SamB> hmm
17:22:05 <SamB> ghc handles that or they changed mingw?
17:22:16 <dcoutts__> just tell gcc -o main.exe
17:22:28 <dcoutts__> ie ghc just tells gcc -o main.exe
17:22:36 <SamB> yes, I know you can do that!
17:22:42 <SamB> obviously...
17:22:47 <dcoutts__> so yes, ghc handles that
17:22:57 <dcoutts__> by doing the obvious thing
17:23:08 * dcoutts__ -> bed
17:37:36 <dmwit> @type curry
17:37:38 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
17:37:45 <dmwit> @type uncurry
17:37:46 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
17:37:55 <dmwit> I can never keep those straight...
17:44:28 <ihope_> @type curry id
17:44:29 <Igloo> Just remember that currying is making a function into the natural Haskell style
17:44:29 <lambdabot> forall a b. a -> b -> (a, b)
17:44:50 <Pseudonym> ?free curryId :: a -> b -> (a,b)
17:44:51 <lambdabot> f ($proj_2_1 (curryId x y)) = $proj_2_1 (curryId (f x) (g y)) && g ($proj_2_2 (curryId x y)) = $proj_2_2 (curryId (f x) (g y))
17:45:00 <ihope_> @. pl djinn (a, b) -> (a -> b -> c) -> c
17:45:01 <lambdabot> f = uncurry (flip . flip id)
17:45:11 <ihope_> @type flip uncurry
17:45:11 <dmwit> But I don't consider passing tuples to be the "natural" Haskell style -- is it?
17:45:13 <lambdabot> forall a b c. (a, b) -> (a -> b -> c) -> c
17:45:23 <ihope_> pl fails.
17:45:25 <Pseudonym> dmwit: No, but returning tuples is.
17:45:31 <Igloo> No, but when you curry a function it doesn't take a tuple any more
17:45:49 <dmwit> Ah, good.
17:46:33 <Pseudonym> Sometimes you need to make a pipeline of functions, and one of those functions returns a tuple.
17:46:58 <dmwit> Yes, that is exactly what I needed to do... :)
17:47:19 <ihope_> Why doesn't Haskell use bras and kets to handle that? :-P
17:48:17 <dmwit> Kets?  According to Webster, that means carrion... =P
17:48:48 <Pseudonym> @pl Either (|True> <True|) (|False> <False|)
17:48:49 <lambdabot> (line 1, column 9):
17:48:49 <lambdabot> unexpected "|"
17:48:49 <lambdabot> expecting lambda abstraction or expression
17:48:52 <Pseudonym> Oh well.
17:49:06 <ihope_> dmwit: how nice.
17:49:10 <ihope_> It's Dirac notation.
17:49:49 <dmwit> Interesting!
17:49:58 * dmwit loves Google.
17:51:05 <ihope_> ...Curry isn't purely functional?
17:52:00 <Pseudonym> dmwit: You know about push-down automata?
17:52:08 <dmwit> Nope!
17:52:12 <Pseudonym> Ah, OK.
17:52:17 <Pseudonym> Dirac notation is a nice way to describe them.
17:52:23 <Pseudonym> That's why I thought I'd mention it.
17:52:24 <dmwit> I'm just a poor undergrad just starting his CS curriculum... =P
17:52:33 <dolio> Oh? Haven't seen that...
17:53:08 <dmwit> Ha, abbreviated PDA.
17:53:12 <dmwit> I bet that's never confusing.
17:53:13 * dolio has only seen it in intro to quantum computing.
17:53:47 <Pseudonym> If your basis states are orthonormal, that's the classical limit of quantum computing.
17:54:03 <Pseudonym> i.e. if there are no superpositions
17:55:20 <Pseudonym> You can think of <phi| as pushing symbol phi onto a stack.
17:55:24 <Pseudonym> And |phi> as popping it.
17:55:35 <Pseudonym> Let 0 be the empty set and 1 be the empty string.
17:55:41 <dmwit> But if phi isn't on top?
17:55:53 <Pseudonym> I'm getting to that.
17:55:56 <dmwit> k
17:55:59 <Pseudonym> <phi| |phi> = 1
17:56:17 <Pseudonym> i.e. pushing phi then popping phi does nothing
17:56:22 <Pseudonym> <psi| |phi> = 0
17:56:35 <Pseudonym> That is, the inner product is orthonormal.
17:56:48 <dolio> Hmm, interesting.
17:56:55 <Pseudonym> Finally, the change of basis rule:
17:56:56 <dmwit> Okay...
17:57:08 <Pseudonym> |a> <a| + |b> <b| + ... + |z> <z| = 1
17:57:15 <Pseudonym> Where + is set union.
17:57:28 <Pseudonym> That's basically the axioms of an orthonormal spinor algebra.
17:57:50 <Pseudonym> Yes, that last axiom requires that the stack be non-empty.
17:57:56 <Pseudonym> i.e. there's a "vacuum" state.
17:58:31 <Pseudonym> You can think of there being a distinguished symbol <0| on the bottom of the stack to represent that.
17:59:04 <dmwit> "Pop 0"?
17:59:19 <Pseudonym> Well, you can't pop the ground state.
17:59:30 <Pseudonym> Details, BTW.
17:59:40 <dmwit> Yes, of course, just formalism, right?
17:59:41 <dmwit> =)
17:59:42 <Pseudonym> Anyway, you can now write a regular expression that accepts a^n b^n:
17:59:44 <dolio> Well, you do in some PDAs.
17:59:58 <Pseudonym> <0| (a <1|)* (b |1>)* |0>
18:00:20 <Pseudonym> Note that a <phi| = <phi| a
18:00:37 <Pseudonym> If a is a terminal symbol.
18:00:58 <Pseudonym> Terminal symbols play the role of scalars in the spinor algebra.
18:01:24 <Pseudonym> Except that a b != b a
18:02:40 <dolio> Hmm, that is nice.
18:02:52 <dmwit> Wait.
18:03:08 <dmwit> <phi| a b |phi> = 1?
18:03:10 <dolio> Simpler than context free grammars in some cases, I guess.
18:03:12 <Pseudonym> No.
18:03:23 <Pseudonym> <phi| a b |phi> = a b
18:03:24 <dmwit> <phi| a b |phi> = "ab"?
18:03:27 <dmwit> Okay.
18:03:29 <dmwit> Got it.
18:03:52 <Pseudonym> Oh, E* is the equivalent of exp(E).
18:04:02 <Pseudonym> Which makes sense when you Taylor expand exp.
18:04:21 <Pseudonym> exp(E) = 1 + E + E^2/2 + E^3/3! + ...
18:04:22 <Pseudonym> Whereas:
18:04:29 <Pseudonym> E* = 1 + E + E^2 + E^3 + ...
18:04:42 <Pseudonym> The constants disappear because E + E = E
18:05:14 <dmwit> Nice.
18:05:32 <Pseudonym> But I haven't got to the really cool part yet.
18:05:41 <dolio> Heh.
18:05:54 <Pseudonym> First, consider E(0), where you substitute 0 for all the terminal symbols.
18:06:00 <Pseudonym> E(0) is either 0 or 1.
18:06:12 <Pseudonym> It's 1 if E accepts the empty string, otherwise it's 0.
18:06:23 <Pseudonym> Which is nice enough.
18:06:36 <Pseudonym> Now we make a partial derivative operator:
18:06:46 <Pseudonym> da/da = 1
18:06:49 <Pseudonym> db/da = 0
18:07:00 <Pseudonym> d(E1 + E2)/da = dE1/da + dE2/da
18:07:11 <Pseudonym> d(E*)/da = dE/da E*
18:07:26 <Pseudonym> (Note how that is the rule for exp.)
18:07:29 <Pseudonym> And finally:
18:07:30 <dmwit> I sense some orthonormal matrices coming up.
18:07:43 <Pseudonym> d(E1 E2)/da = E1(0) dE2/da + dE1/da E2
18:07:57 <Pseudonym> You need E1(0) because the product isn't commutative.
18:08:06 <Pseudonym> But it looks kinda like a product rule.
18:08:21 <Pseudonym> Now, you can convert a regular expression to a DFA purely algebraically.
18:08:41 <Pseudonym> Each state of a DFA "accepts" some regular expression.
18:08:47 <Pseudonym> You can imagine moving the start state there.
18:09:05 <Pseudonym> If E represents some state, then dE/da is the state that you transition to by accepting a.
18:09:27 <Pseudonym> E(0) is 1 if that state should be a terminal state and 0 if it shouldn't be.
18:09:36 <Pseudonym> So you end up with:
18:09:46 <Pseudonym> E = E(0) + a dE/da + b dE/db + ... + z dE/dz
18:09:59 <Pseudonym> Which, if you stare at it for a moment, is Taylor's theorem.
18:10:25 <Pseudonym> THAT is the cool part.
18:10:35 <dmwit> That is pretty far out.
18:10:38 <dolio> Nice.
18:10:46 <Pseudonym> And they don't teach any of this to undergrads.
18:10:51 <dmwit> =/
18:10:53 <Pseudonym> Even though it's been known since the 60s.
18:10:58 <dolio> :) Of course not.
18:11:11 <dolio> Most have enough trouble figuring out regular expressions at all.
18:11:26 <dmwit> Instead they teach memory management in C++... boring.
18:11:29 <dolio> Or, at least, enough to keep the class from going into stuff like that.
18:11:35 <dmwit> It may be important, but it's *boring*.
18:12:02 <dolio> Heh, is it important? :)
18:12:20 <dmwit> Well, I'm guessing it is -- we spent a lot of time on it. ;-)
18:12:20 <Pseudonym> Incidentally, I coded this up in Haskell:
18:12:23 <Pseudonym> http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Dfa/Dfa.lhs
18:12:30 <Pseudonym> It's ended up in a few projects by now.
18:12:38 <Pseudonym> But if you're curious, that's how you can implement it.
18:13:21 <dibblego> does the RDF refer to Resource Description Framework?
18:13:28 <Pseudonym> I think so.
18:16:15 <dibblego> didn't you write it?
18:16:50 <Pseudonym> I only wrote the DFA module.
18:16:56 <dibblego> ok
18:19:55 <dmwit> @hoogle concatMap
18:19:56 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
18:20:32 <Pseudonym> @type (>>=)
18:20:34 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:20:36 <Pseudonym> @type flip concatMap
18:20:37 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
18:21:07 <Pseudonym> @type (=<<)
18:21:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
18:21:15 <Pseudonym> Right, that's concatMap.
18:21:42 <dolio> @type join . fmap
18:21:44 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (f a)
18:21:45 <lambdabot>    Expected type: (a -> b) -> f a -> f a -> a1
18:21:57 <dmwit> Is there a reason to use one over the other?
18:22:20 <Pseudonym> Emphasis.
18:22:44 <Pseudonym> It's like word ordering in a fully declined language.
18:23:06 <Pseudonym> You use whatever makes the most sense rhetorically.
18:23:24 <dmwit> Hmm...
18:23:27 <Pseudonym> Most people don't consider the rhetoric of programming. :-)
18:23:35 <dmwit> So, first become fluent in Haskell, then write. =)
18:23:41 <lispy> yes
18:23:55 <sjanssen_> @localtime dons
18:23:56 <lambdabot> Local time for dons is Thu Sep  7 11:23:33 2006
18:23:59 <dmwit> To become fluent in Haskell, practice by writing.
18:24:02 <dons> ?karma+ SamB -- lambdabot patches
18:24:02 <lambdabot> SamB's karma raised to 13.
18:24:04 <Pseudonym> Indeed.
18:24:06 <dons> sjanssen_: hey
18:24:06 <dmwit> ...and mutual recursion saves the day.
18:24:07 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:24:14 <Pseudonym> ?uptime
18:24:15 <lambdabot> uptime: 2d 1h 48m 10s, longest uptime: 2d 1h 48m 10s
18:24:21 <Pseudonym> Lambdabot patches not applied, I see.
18:24:37 <dons> not, that'll happen on saturdays
18:24:53 <lispy> i had this problem the other day where i wanted map :: (a -> [[a]]) -> [a] -> [[a]] and i wasn't sure if the lambda should be "return" or "(:[])"
18:25:05 <Pseudonym> @karma- dons -- release early, release often
18:25:05 <lambdabot> dons's karma lowered to 55.
18:25:10 <dons> heh
18:25:18 <Pseudonym> You had karma to burn and you know it.
18:25:23 <dons> :)
18:25:31 <dolio> @type (join .) . fmap
18:25:33 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
18:25:37 <dolio> Ah, there we go.
18:25:52 <dmwit> @type join $ fmap
18:25:53 <lambdabot> forall b. (b -> b) -> b -> b
18:26:01 <sjanssen_> dons: I had an idea to do concatenation well with stream fusion.  What is a good test to try?
18:26:11 <Pseudonym> ?free joinFmap :: (b -> b) -> b -> b
18:26:12 <lambdabot> f . g = h . f => f . joinFmap g = joinFmap h . f
18:26:36 <dons> sjanssen_: hmm. a fusible concat you mean?
18:26:38 <lispy> @type concatMap
18:26:39 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
18:26:44 <dmwit> So why does using the double-composition require two different types?
18:26:47 <Pseudonym> ?free concatMap
18:26:48 <lambdabot> $map f . h = k . g => $map f . concatMap h = concatMap k . $map g
18:27:00 <Pseudonym> Unsurprising.
18:27:14 <Pseudonym> ?free mapping :: (F a -> G a) -> (H a -> J a)
18:27:14 <lambdabot> $map_G f . g = h . $map_F f => $map_J f . mapping g = mapping h . $map_H f
18:27:17 <sjanssen_> dons: well, append actually
18:27:18 <dons> sjanssen_: well, check that something like : map . concat . lines fuses
18:27:22 <Pseudonym> General pattern there.
18:27:24 <dons> ah ok. close.
18:27:44 <dons> you want to check that things like map/fold fuse with the append
18:28:00 <lispy> how do you check that something fuses?
18:28:05 <dons> i.e by inspecting the core, and running the FusionBench.hs
18:28:08 <dons> oh, you watch the rules fire
18:28:28 <lispy> dons: with ghc -vn?
18:28:32 <lispy> for some n?
18:28:34 <dons> so if fusion happens you should see: Rule fired: read/write fusion in -ddump-simpl-stats
18:28:42 <lispy> ah
18:28:43 <lispy> cool
18:30:45 * lispy heads home for the day
18:32:53 <dolio> ?pl \f -> (f .)
18:32:53 <lambdabot> (.)
18:33:03 <dolio> ?pl \f -> ((f .) .)
18:33:03 <lambdabot> (.) . (.)
18:33:15 <dolio> ?pl \f -> (((f .) .) .)
18:33:15 <lambdabot> (.) . (.) . (.)
18:33:19 <dolio> Heh.
18:33:32 <lispy> ?type (.) . (.) . (.) . (.)
18:33:33 <lambdabot> forall a a1 a2 b c a3. (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
18:33:45 <lispy> ?pl (.) . (.) . (.) . (.)
18:33:45 <lambdabot> (.) . (.) . (.) . (.)
18:35:14 <dmwit> @pl \p1 p2 -> latticeLength p1 p2 == 1
18:35:14 <lambdabot> flip flip 1 . ((==) .) . latticeLength
18:35:24 <dmwit> Ew.
18:35:55 <Pseudonym> @pl \p1 p2 -> 1 == latticeLength p1 p2
18:35:56 <lambdabot> ((1 ==) .) . latticeLength
18:35:58 <Pseudonym> A bit better.
18:36:10 <dmwit> @pl (1 ==) $ latticeLength
18:36:11 <lambdabot> 1 == latticeLength
18:36:22 <Pseudonym> Well, "better" is a matter of opinion.
18:36:29 <dmwit> @pl (1 ==) $ (latticeLength :: a -> a -> Int)
18:36:30 <lambdabot> (line 1, column 30):
18:36:30 <lambdabot> unexpected ">"
18:36:30 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
18:36:42 <dolio> ?djinn (b -> c -> d) -> (a -> b) -> a -> b -> c -> d
18:36:43 <lambdabot> f a b c _ d = a (b c) d
18:38:15 <Pseudonym> ?free ff :: (b -> c -> d) -> (a -> b) -> a -> b -> c -> d
18:38:15 <lambdabot> h . p x = q (f x) . g => f . f1 = f2 . k => h . ff p f1 y z = ff q f2 (k y) (f z) . g
18:38:18 <Pseudonym> Woo.
18:38:43 <lightstep> ?help free
18:38:44 <lambdabot> free <id :: a -> a>. Generate theorems for free
18:39:04 <dmwit> @type sequence
18:39:05 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:40:58 <dmwit> What does it mean to "evaluate an action" for the list monad?
18:41:02 <dolio> @. djinn pl (b -> c -> d) -> (a -> b) -> a -> c -> d
18:41:03 <lambdabot> Cannot parse command
18:41:03 <lambdabot> Cannot parse command
18:41:03 <lambdabot> Cannot parse command
18:41:33 <dons> ?pl f a b c _ d = a (b c) d
18:41:33 <lambdabot> f = ((const .) .) . (.)
18:41:46 <dons> ?. pl djinn (b -> c -> d) -> (a -> b) -> a -> c -> d
18:41:46 <lambdabot> f = (.)
18:42:24 <dolio> Oh, right.
18:42:26 <dolio> Backwards.
18:46:14 <lightstep> dmwit, the monad rules only allow composing actions, not running them
18:46:48 <dmwit> sequence :: Monad m => [m a] -> m [a]Evaluate each action in the sequence from left to right,  and collect the results.
18:47:09 <dmwit> ... ?
18:47:24 <dmwit> I think this is clear for the IO monad, but for lists?
18:47:31 <lightstep> dmwit, the "evaluation" here is in m, the type parameter
18:48:36 <lightstep> what they really mean is "take the value of each of the action, and return the list of values". which, for nondeterminism monads, ranges over all the options
18:49:27 <lightstep> here you get the cartesian product (assuming all lists are finite)
18:50:33 <dmwit> Hmm....
19:01:44 <dons> ?seen SyntaxNinja
19:01:45 <lambdabot> I saw SyntaxNinja leaving #haskell and #darcs 27m 28s ago, and .
19:01:49 <Pseudonym> ?free sequence :: [M a] -> M [a]
19:01:50 <lambdabot> $map_M ($map f) . sequence = sequence . $map ($map_M f)
19:04:05 <dolio> ?free fmapM
19:04:06 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `fmapM'\n\n"
19:04:25 <dolio> ?free fmapM :: (a -> m b) -> f a -> m (f b)
19:04:26 <lambdabot> free module failed: IRCRaised Plugin/Free/Type.hs:(153,16)-(161,44): Non-exhaustive patterns in case
19:04:35 <dolio> Oops.
19:04:38 <sjanssen_> dons: do I need GHC 6.5 to get these streams rules to work?
19:04:44 <dolio> ?free fmapM :: (a -> M b) -> F a -> M (F b)
19:04:44 <lambdabot> $map_M g . h = k . f => $map_M ($map_F g) . fmapM h = fmapM k . $map_F f
19:04:45 <Pseudonym> ?free fmapM :: (a -> M b) -> F a -> M (F b)
19:04:46 <lambdabot> $map_M g . h = k . f => $map_M ($map_F g) . fmapM h = fmapM k . $map_F f
19:04:51 <Pseudonym> Right.
19:05:02 <Pseudonym> free can't handle constructor classes.
19:05:05 <dons> sjanssen_: yep the newer the better
19:05:10 <Pseudonym> Or type classes in general.
19:05:34 <dons> and if you're adding new rules, be careful with the inline pragma phasing
19:05:54 <dons> things you want to match in rules need to be inline [1] or inline [0]
19:37:43 <dmwit> @pl mappablefind string = uncurry (find dmap string)
19:37:43 <lambdabot> mappablefind = uncurry . find dmap
19:42:49 <sjanssen_> dons: appendA has two arguments and they can fuse if both are either strProducerUp or strProducerBi.  Do I write 4 rules or is there a better way?
19:43:37 <dons> hmm. why would you need to write more rules?
19:44:07 <dons> so you're thinking of identifying appends in rules explicitly?
19:44:35 <sjanssen_> maybe, I'll be the first to admit that I don't understand the scheme from top to bottom
19:44:51 <dons> ideally, a suitable appendA would just fuse directly, since it will be in terms of consumers and producers that already fuse
19:45:05 <dons> as for the other *A functions
19:45:21 <dons> but , yes, this producer* path seems a good idea
19:48:41 <sjanssen_> here's why I need more rules for append: appendA a1 a2 = strProducerUp (readStrUp a1 `catS` readStrUp a2).  because of the catS strProducerUp can't fuse with the underlying readStrUps
19:48:44 <sjanssen_> does that make sense?
19:48:57 <dons> yep
19:49:08 <dons> we'd need some combinator to wrap the catS
19:49:20 <dons> i.e. strCatUp or something
19:49:32 <dons> and then rules. hopefully that would be reusable for concatMap or zip too
19:53:58 <sjanssen_> there's another idea I was toying with.  Adding a constructor to Step: NextStream Stream
19:54:15 <sjanssen_> but this is separate from the general append issue
19:57:38 <dmwit> @hoogle generic
19:57:39 <lambdabot> Data.Generics.Aliases.Generic :: type Generic c
19:57:39 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
19:57:39 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
19:57:56 <dons> sjanssen_: how'd that work?
19:58:26 <dmwit> @hoogle genericLength
19:58:27 <lambdabot> List.genericLength :: Integral a => [b] -> a
19:58:29 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
19:58:54 <dons> ?instance Integral
19:58:55 <lambdabot> Maybe you meant: instances instances-importing
19:58:58 <dons> ?instances Integral
19:59:00 <lambdabot> Int, Integer
19:59:02 <dons> ?instances Num
19:59:03 <lambdabot> Double, Float, Int, Integer
19:59:08 <dons> isn't that intersting.
19:59:14 <lispy> new hoogle?
19:59:21 <dons> no?
19:59:33 <lispy> ?instances Show
19:59:34 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:59:42 <dons> > genericLength [1..10] :: Float
19:59:43 <lambdabot>  10.0
20:00:12 <lispy> so it only shows you instances in some restricted subset? maybe instances defined in the same module...oh wait it uses haddock doesn't it?
20:00:13 <foxy__> > 10.0 `mod` 3.0
20:00:14 <lambdabot>  Add a type signature
20:00:24 <sjanssen_> dons: dcoutts says catS is slow because it has to check whether the first stream is exhausted each time it emits a character
20:00:31 <dons> ah right
20:00:34 <foxy__> > 10.0 `mod` 3.0 :: Float
20:00:35 <lambdabot>  add an instance declaration for (Integral Float)
20:00:35 <lambdabot>   In the expression: 10....
20:00:47 <dons> ?type mod
20:00:48 <lambdabot> forall a. (Integral a) => a -> a -> a
20:00:50 <foxy__> > 10.0 `mod` 3.0 :: Integer
20:00:51 <lambdabot>  add an instance declaration for (Fractional Integer)
20:01:05 <dons> > 10 `mod` 3 :: Integer
20:01:06 <lambdabot>  1
20:01:52 <foxy__> @instance Fractional
20:01:52 <lambdabot> Maybe you meant: instances instances-importing
20:01:59 <foxy__> @instances Fractional
20:02:00 <lambdabot> Double, Float
20:02:11 <dmwit> @hoogle Float -> Int
20:02:12 <lambdabot> No matches, try a more general search
20:02:23 <dmwit> @hoogle Num a => a -> Int
20:02:24 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
20:02:24 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
20:02:24 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
20:02:35 <foxy__> @type toInteger
20:02:36 <lambdabot> forall a. (Integral a) => a -> Integer
20:02:44 <sjanssen_> dons: so NextStream encodes concatenation.  so catS will catch Done from the first stream, and replace it with NextStream theSecondStream
20:02:50 <dmwit> @hoogle floor
20:02:51 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
20:03:07 <sjanssen_> so I'll start another sentence with so
20:03:07 <foxy__> @instances RealFrac
20:03:08 <lambdabot> Double, Float
20:03:25 <lispy> so, do it already
20:03:30 <lispy> so we don't have to wait
20:03:39 <lispy> so much anticipation :)
20:03:46 <dmwit> So bad...
20:04:14 <dons> hmm. interesting idea sjanssen_ .
20:04:23 <foxy__> > (\x -> "so " ++ x) "what!"
20:04:24 <lambdabot>  "so what!"
20:04:38 <dons> QuickCheck is in the non-core packages now?
20:04:48 <dons> ah well, I guess that's ok
20:04:49 <lispy> ?pl \x -> "so" ++ x
20:04:49 <lambdabot> ("so" ++)
20:04:53 <sjanssen_> dons: only problem is that it uglies up several other combinators somethin' fierce
20:05:03 <dons> yep, i can imagine.
20:05:13 <dons> i'm hoping there's another way
20:05:13 <sjanssen_> and may not be all that useful
20:25:34 <newsham> data RootBeer a = Empty | Full a
20:25:56 <newsham> :t Full (1.0 :: Float)
20:34:51 <dmwit> newsham: RootBeer Float? :-)
20:37:07 <Pseudonym> Whisky MakeItA Double
20:37:23 <dwm> Finally accepted that I can't have "Dino" and registered something.
20:51:58 <Cale> http://it.slashdot.org/comments.pl?sid=195888&cid=16057175
20:52:00 <Cale> :)
20:52:02 <lambdabot> Title: Will Solve Captcha for Money?, http://tinyurl.com/zwfh9
20:53:03 <Cale> (In a rather off-topic thread about computing square and other roots :)
20:53:18 <glguy> ?pl \(a,b) -> f a > f b
20:53:19 <lambdabot> uncurry ((. f) . (>) . f)
20:53:41 <glguy> is there an arrow operator that does something like that?
20:54:29 <Cale> hmm
20:55:23 <glguy> (***)? half way at least
20:55:32 <Korollary> Cale: the slasdot crowd seems to underappreciate your comments.
20:55:55 <dons> heh
20:55:56 <Cale> Korollary: oh? I just submitted that, is there a reply?
20:55:59 <glguy> > (***) length ([()],[])
20:55:59 <lambdabot>  Couldn't match `(->)' against `(,)'
20:56:49 <Cale> @pl \f -> liftM2 (>) (f . fst) (f . snd)
20:56:50 <lambdabot> ap (liftM2 (>) . (. fst)) (. snd)
20:56:56 <Cale> hm
20:57:02 <glguy> > join (***) length ([()],[])
20:57:04 <lambdabot>  (1,0)
20:57:18 <Cale> @type (***)
20:57:19 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:57:29 <Cale> @type (&&&)
20:57:29 <Korollary> Cale: no, I looked at your history.
20:57:31 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:57:33 <Cale> Korollary: ah
20:58:10 <Cale> Korollary: yeah, I don't post that often, since I hardly ever bother to look at the comments at all
20:58:29 <glguy> > uncurry (>) $ join (***) length ([()],[])
20:58:30 <lambdabot>  True
20:59:56 <deadbeef> wondering if captchas can be solved by an algorithm
21:00:14 <Cale> deadbeef: Many of them can be
21:00:21 <glguy> > join (liftM2 (>)) length [()]
21:00:23 <lambdabot>  False
21:00:23 <deadbeef> maybe using some pattern recognition technique
21:00:58 <glguy> OCR?
21:00:59 <Cale> There are a lot of awfully weak captchas out there
21:01:32 <Cale> You have to at least distort the text a bit to make it hard for the people who know what they're doing.
21:01:43 <Pseudonym> And most of them are good enough for what they're for.
21:02:06 <Pseudonym> A weak captcha is fine for your blog, especially if you don't have commonly-used software.
21:02:06 <glguy> not to stop all spam just casual spam
21:02:12 <Pseudonym> Right.
21:02:24 <Pseudonym> The point is to reduce spam to the point that it's managable by hand.
21:03:03 <Korollary> The point behind captchas is similar to encryption. Algorithms do handle them. They are just expensive.
21:03:13 <newsham> do all "standard functions" (ie. prelude, ghc libs) have patterns that are guaranteed to match?  (what's the formal word for that, "total"?)
21:03:31 <Cale> http://sam.zoy.org/pwntcha/
21:03:35 <lambdabot> Title: PWNtcha - captcha decoder
21:03:48 <Korollary> newsham: head doesn't match []. It's not total.
21:03:53 <Cale> newsham: no, head and tail are good examples
21:04:04 <newsham> does head have no match for that case, or does it use "error" for that case?
21:04:19 <newsham> (splitting hairs, I know, but curious)
21:04:26 <Korollary> I think it has an error "Empy list"
21:04:58 <Korollary> Yeah
21:05:07 <newsham> i guess the deeper question I'm getting at would be "if I grep for 'error' in standard libraries, are those the only runtime errors that can occur when using them?"
21:05:10 <dwm> @head []
21:05:18 <Korollary> > head []
21:05:19 <lambdabot>  Add a type signature
21:05:22 <Korollary> argh
21:05:28 <newsham> > head [] :: [Int]
21:05:30 <dwm> bah
21:05:30 <lambdabot>  Exception: Prelude.head: empty list
21:06:02 <Korollary> newsham: no. For instance you can try to read, and it may fail
21:06:15 <Korollary> > read "Blah" :: Int
21:06:17 <lambdabot>  Exception: Prelude.read: no parse
21:06:29 <newsham> and that's not from an "error" statement?
21:06:38 <Korollary> oh
21:06:46 <Korollary> Yes, probably you will find such a statement
21:07:12 <glguy> > let h (x:xs) = x in h []
21:07:13 <lambdabot>  Add a type signature
21:07:19 <glguy> > let h (x:xs) = x in h [] :: [()]
21:07:20 <lambdabot>  Non-exhaustive patterns in function h
21:07:33 <deadbeef> http://sam.zoy.org/pwntcha/
21:07:38 <lambdabot> Title: PWNtcha - captcha decoder
21:07:44 <newsham> so... all patterns in the libs are "exhaustive"?
21:07:55 <Cale> http://www.cs.sfu.ca/~mori/research/gimpy/
21:07:57 <lambdabot> Title: Breaking a Visual CAPTCHA
21:07:59 <newsham> (ghc would warn if they werent, right?)
21:08:01 <dons> newsham: hopefully
21:08:07 <dons> since you'd get warnings if they weren't
21:08:23 <dons> well, there are cases where they're non-exhaustive, but a proof exists that this is ok
21:08:23 <NamelessOne> undefined | False = undefined
21:08:23 <NamelessOne> :)
21:08:44 <dons> NamelessOne: that looks like the gofer defn of 'undefined'
21:08:48 <newsham> dons: are the proof in comments in the libs?
21:08:58 <dons> hopefully
21:09:05 <dons> they are for Data.ByteString.Lazy
21:09:11 <dons> which is the one example I can think of
21:09:16 <newsham> nifty
21:09:59 <newsham> if I had a program and I wanted to prove that it has no runtime exceptions, i'd have to hunt down all the errors and come up with proofs that each one cant happen...
21:10:24 <newsham> just wondreing if searching for "error" would be sufficient
21:10:45 <dons> well, there are implicit errors too, like pattern match failures
21:10:57 <dons> and then things like / 0
21:10:59 <glguy> that version of undefined would not type check, would it?
21:11:01 <newsham> those only happen if the pattern isnt exhaustive, right?
21:11:01 <Thomas2_> yeah, and you've have to hunt down things like unsafeIO
21:11:08 <newsham> yah,  divide by zero, thats a good one...
21:11:12 <dons> > let undefined | False = undefined :: a in undefined
21:11:13 <lambdabot>  undefined :: a
21:11:13 <lambdabot>   In a right-hand side of function `undefined': undefined ...
21:11:40 <newsham> are the lib "errors" pretty well documented?  What about things like "/0" ?   possible IO exceptions that might be in native code?
21:11:43 <dons> > let undef :: a ; undef | False = undef in undef
21:11:44 <lambdabot>  Add a type signature
21:11:47 <dons> > let undef :: a ; undef | False = undef in undef ::
21:11:47 <lambdabot>  Parse error
21:11:50 <dons> > let undef :: a ; undef | False = undef in undef :: ()
21:11:51 <lambdabot>  Non-exhaustive patterns in function undef
21:11:53 <Cale> > 1/0
21:11:54 <lambdabot>  Infinity
21:11:54 <dons> there you go
21:11:59 <Cale> > 1/0 :: Integer
21:12:00 <lambdabot>  add an instance declaration for (Fractional Integer)
21:12:00 <lambdabot>   In the expression:...
21:12:05 <Cale> > 1/0 :: Rational
21:12:07 <lambdabot>  Exception: Ratio.%: zero denominator
21:12:19 <Cale> > 1 `div` 0 :: Integer
21:12:21 <lambdabot>  Exception: divide by zero
21:12:36 <newsham> dons: finding "non-exhaustive" in ghc is a sound analysis, right?  if it doesnt complain, I can be assured there are none?
21:13:07 <dons> maybe. you'd have to check the relevant papers
21:13:38 <glguy> any news on how the Haskell teams faired at ICFP?
21:13:54 <newsham> glguy: was wondering that yesterday, looked up th esite, awards announced this weekend i think
21:14:09 <newsham> err.. wait, awards around the 18th or 19th or so
21:14:23 <newsham> so if anything, nothing official yet
21:14:26 <glguy> I could never participate in a competition that put off the announcement of the results so long
21:14:32 <dons> won't be announced till ICFP , surely
21:15:01 <newsham> yup, announced at the conf
21:15:03 <dons> glguy: its not really a big deal :) you just get back to work. delayed gratification and all that.
21:15:28 <Korollary> dons won't win anyways
21:15:29 <lispy> delayed grati...what?  that doesn't exist in the US :)
21:15:40 <glguy> *I want it now*
21:15:40 <newsham> seems like if people wanted to use haskell for high assurance stuff,  having docs that say what can go wrong would be a good prereq
21:15:45 <dons> Korollary: true.
21:16:00 <lispy> newsham: something can go wrong?
21:16:11 <Korollary> ghc has bugs
21:16:16 <newsham> > 1 / 0
21:16:18 <lambdabot>  Infinity
21:16:24 <lispy> haskell programs can't seg...oh wait...
21:16:27 <dons> newsham: surely _proofs_ are better than docs ;)
21:16:29 <glguy> > 0 / 0
21:16:30 <lambdabot>  NaN
21:16:38 <newsham> dons: yes.
21:16:40 <dons> C++ does the docs thing. how's that working out?
21:16:42 <lispy> > 0 / 0 / 0
21:16:44 <lambdabot>  NaN
21:17:12 * lispy patches 
21:17:39 <lispy> dons: what's wrong with C+...oh wait need to patch again...anyway, what's wrong with (++ program....damn, crashed again...oh well
21:18:24 <Korollary> I can say that nothing I wrote in c++ within the last year crashed.
21:18:36 <lispy> personally, i think we should use asm.  It's multiparadigm and you can build anything with it...
21:18:36 <dons> I saw an interesting talk yesterday about translating haskell to isabelle, for the L4 kernel project
21:18:40 <dons> very interesting stuff
21:18:50 <newsham> kor: yah, but dont run lispy's c++ code.
21:18:54 <Korollary> dons: I've read that. Interesting indeed.
21:19:06 <newsham> dons: yah, the seL4 project.. was reading about that.
21:19:06 <dons> it's nice using Isabelle as an extended type checker, of sorts, for the proofs that are hard to encode in the haskell type checker
21:19:09 <dons> like termination
21:19:13 <dons> yep
21:19:25 <newsham> they prototyped in haskell, translated to isabelle for proofs,  and are going to trnaslate the results into C eventually
21:19:26 <lennart> > 1 / 0 * 0
21:19:27 <lispy> i wrote some C++ code once that was bug free and didn't crash...then i upgraded g++ and it segfaulted every time i ran it...that was fun
21:19:27 <lambdabot>  NaN
21:19:29 <newsham> quite the project
21:19:37 <Korollary> dons: Though Oleg seems to like twelf better for the proofs look more like hand made proofs. He complains about boilerplate for the likes of coq/isabelle.
21:19:47 <glguy> But what about a kernel in epigram?
21:19:47 <dons> newsham: nope, they generate C from the Isabelle
21:20:07 <lennart> > 1 / (-1 / 0)
21:20:09 <lambdabot>  -0.0
21:20:19 <newsham> thats "translate", although reading I didnt see anything that hinted it was automated trnaslation.. but thats cool
21:20:23 <deadbeef> lispy: maybe you were modifying a const char array
21:20:25 <dons> so prototype in haskell, since that's a good psuedocode for specing out kernels. translate to Isabelle and prove things, generate C and run it
21:20:28 <newsham> wouldnt want a human to muck tihngs up at the last step
21:20:36 <deadbeef> lispy: that happened to me too
21:20:52 <newsham> dons: did they give a status report in the talk?  are they generating C now?
21:21:11 <dons> hmm, maybe they're not fully generating it yet
21:21:22 <dons> they demoed the haskell kernel running C programs on an arm simulator
21:21:33 <newsham> thats really cool.
21:21:40 <dons> with proofs for termination of syscalls and so on
21:21:50 <glguy> What's all this about Isabelle?
21:21:58 <Korollary> She's hot.
21:22:01 <dons> the full talk will be at the HW
21:22:07 <newsham> tiny tiny kernel almost done!  now they can start writing a high assurance OS and then some apps ;-)
21:22:36 <dons> they've got apps. expect to see tetris or something running by the HW ;)
21:22:37 * lispy wants to go to ICFP since it will be in his backyard but it's just too much money to pay out of pocket
21:22:55 <lennart> lispy: just sneak in
21:22:55 <newsham> glguy: http://www.ertos.nicta.com.au/research/sel4/ and http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html
21:22:56 <lambdabot> Title: Sel4 - ERTOS - National ICT Australia
21:23:04 <lispy> lennart: yeah, maybe i should
21:23:13 <lennart> nobody cares
21:23:14 <lispy> worth a shot
21:23:21 <dons> lispy: also, the HW is cheaper by far than ICFP, isn't it?
21:23:24 <newsham> dons: yah, but they didnt prove the apps.  just the microkernel.
21:23:24 <dons> and more fun :)
21:23:32 <dons> right
21:23:32 <newsham> I have tons of unproven apps! :)
21:23:50 <lispy> dons: it's either or?
21:24:06 <dons> you could go to both, but if you're short of cash, HW is cheaper.
21:24:11 <newsham> hmm.. lambdabot only does title for one URL if there are multipel urls in a PRIVMSG
21:24:20 <dons> and you don't have to sit through boring OCaml talks ;)
21:24:36 <newsham> why not translate OCaml into haskell while they give the talk?
21:24:43 <lispy> haha
21:25:09 <lennart> lispy: are you in portland?
21:25:55 <araujo> yay!
21:26:03 * araujo back
21:26:27 <Korollary> I'd go but I don't understand the abstracts of the papers.
21:26:42 <lennart> all the more reason to go :)
21:26:45 <lispy> lennart: close by
21:26:55 <lispy> lennart: about 90 minutes away by car
21:27:10 <Korollary> Nah. I need more experience before I can relate.
21:27:18 <glguy> I like learning new programming languages when they force me to look at solving problems differently that the other languages I know.  Presently I use a lot of C#, Haskell, and some J.  Is there anything unique to O'Caml that would make it worth me looking at (different ways of looking at things)
21:27:33 <dons> modules?
21:27:42 <lispy> one of the reasons i want to go is to meet #haskellers in person
21:27:47 <dons> well, not unique to OcCaml, but different to haskell
21:27:55 <Korollary> Also the O' bit.
21:27:57 <glguy> it's an ML thing, right?
21:27:57 * deadbeef knows xerox irl
21:28:07 <dons> glguy: right.
21:28:09 <lennart> but no one uses the O' bit :)
21:28:15 <Korollary> True
21:28:24 <newsham> glguy: ocaml's neat, but if you're using haskell, and you know {perl,c#,python,...} I dont know that you'll get much more out of ocaml
21:28:24 <dons> it was just a branding exercise, right, lennart ?
21:28:43 <lennart> very successful one, i think
21:28:49 <dons> yeah
21:28:52 <glguy> what is the O' bit?
21:28:55 <glguy> "object"?
21:29:01 <lennart> yes
21:29:16 <dons> so we should rename Haskell' as O'Haskell#++ on Rails
21:29:33 <newsham> i've been learning some ocaml and it was really easy to pick up having already known haskell (and knowing several languages)
21:29:37 <lennart> i think it's too late
21:29:50 <Korollary> heh. As long as use monads in the object system, nobody will even know that we don't have an object system.
21:29:56 <glguy> dons: you forgot the prime... :)
21:30:04 <newsham> its kind of neat to be lazy (as a programmer) and use side effects whenever you want, but then, why so strict about types :)
21:30:07 <dons> and the aspect oriented bits
21:30:57 <lispy> O'Haskell On Rails, sounds like a musical
21:31:02 <lispy> HoR
21:31:06 <lispy> hmm...
21:31:09 <glguy> Haskell on rockets
21:31:09 <lispy> nota good name :)
21:31:10 <newsham> sounds like something the DEA would be interested in looking into
21:31:43 <dons> ?quote emertens
21:31:44 <lambdabot>  screw ruby on rails, I'm using snakes on a plane
21:31:48 <lennart> just face it, haskell will never be popular with the masses, no matter how we rename it :)
21:32:04 <dons> say it ain't so, lennart!
21:32:20 <lennart> VB will do it all, anyway
21:32:22 <newsham> if you just rename "monad" to something cooler
21:32:24 <glguy> No way, the major imperative languages are rapidly adopting functional features
21:32:24 <lispy> lennart: those are unwashed masses, thank you very much ;)
21:32:33 <glguy> and moving closer just becoming haskell :)
21:32:39 <newsham> like "wrapperlets" or something
21:32:39 <dons> just as long as its popular enough to keep me in a job ...
21:32:55 <lennart> dons: want a job?
21:32:58 <glguy> C#'s LINQ was inspired by list comprehensions
21:33:07 <lispy> glguy: yeah, but do you actually use C#?  'adopting' them is more like 'bastardizing' and then every things their dumber than they were in lisp/ML/foo where they heard about them
21:33:14 <dons> lennart: in 10 months or so ... yes :)
21:33:22 <glguy> lispy: unfortunately I use a lot of C#
21:33:33 <dons> got to knock off this dissertation thingy
21:33:43 <lennart> well, hurry up!
21:33:47 <glguy> but I'd rather have basterdized versions at work than none at all
21:34:01 <dons> I will!
21:34:19 <lennart> LINQ has some interesting features, and given what c# is, it's kinda clever
21:34:48 <glguy> I've used closures and anonymous delegates in C# to greate effect
21:34:54 <lennart> but yeah, they are stealing all our good stuff!
21:35:07 <newsham> what about visual haskell or ironpython or visual f#?
21:35:23 <dons> maybe we should just declare that C# and perl6 etc. are just officially FP languages, with special monadic syntax ;)
21:35:24 <lennart> what about them?
21:35:27 <glguy> I use Visual Haskell at work
21:35:37 <glguy> it looks like I'm working on a C# proejct
21:35:40 <newsham> common language runtime interop, work with c#?
21:35:48 <dons> we can instantly increase the users of FP languages by 100 fold then :)
21:35:54 <lispy> glguy: me too
21:35:59 <dons> 10000 fold even..
21:36:03 <glguy> F# is interesting, but it's not Haskell
21:36:12 <lennart> include VB and we FP will have most of the market :)
21:36:14 <glguy> so I'd rather learn more Haskell than split time into F#
21:36:23 <newsham> fair enough
21:36:28 <glguy> Java is the most popular language (after maybe Cobol)
21:36:36 <glguy> can you work it in?
21:36:49 <lispy> oh,i think i kinda insulted darcs infront of droundy today
21:37:07 <lispy> i said something about it having x users and jokingly put x and 4000
21:37:07 <lennart> can darcs be insulted?
21:37:15 <lispy> he was like, "I think we have more users than that"
21:37:20 <dons> hehe bad lispy
21:37:27 <dons> there's got ot be more than 4k users, surely
21:37:38 <dons> there's probably 4k projects using darcs
21:37:42 <lispy> yeah, i realized that after i said it
21:37:47 <lispy> and he corrected me :)
21:37:54 <newsham> C + C++ together have more users than Java
21:38:12 <lispy> java is a fad
21:38:21 <lispy> wont last more than a couple years i'm sure
21:38:23 <lennart> all languages are
21:38:24 <glguy> I was just thinking about Template Haskell. What does using it buy you?
21:38:36 <newsham> http://www.tiobe.com/tiobe_index/images/tpci_trends.gif  doesnt graph like a fad
21:38:42 <lispy> glguy: compile time execution
21:38:54 <dons> compile time code generation without a preprocessor
21:38:55 <lispy> glguy: compile time introspection of code + assembly of new code
21:39:05 <glguy> hwo does that relate to Lisp macros?
21:39:12 <newsham> i want a TH "printf" for formatting HTML using format strings with strong type checking.
21:39:22 <lennart> very similar to lisp macros in many ways
21:39:38 <lispy> glguy: lisp macros give you compile time execution, code introspection and assembly of new code
21:39:56 <lispy> newsham: check the old haskell wiki
21:39:59 <dons> lispy, Results 1 - 10 of about 134,000 for _darcs
21:40:03 <lispy> newsham: i seem to recall a printf example there
21:40:13 <newsham> yah, there's a printf example inthe TH pages
21:40:25 <newsham> i want one that will parse the string as HTML and inject pieces into it
21:40:32 <dons> and Results 1 - 10 of about 1,820,000 for darcs
21:40:35 <newsham> and give you back a parsed HTML tree
21:41:05 <newsham> ie  formatHtml "<li><a href=%u>%t</a></li>" url name
21:41:13 <lispy> dons: those numbers are cool, but you know that's inaccurate :)  i mean, think how many of those are just the mailing lists
21:41:13 <lennart> newsham: you can do that
21:41:19 <newsham> should type check url and name, and return an HTML tree.
21:41:32 <newsham> lennart: i know..  i wish *someone else* would do it, because I want it. :)
21:41:57 <dons> searching for _darcs hits an awful lot of repos
21:42:03 <lispy> i found two things i didn't like about TH 1) top level splice restriction get old fast 2) I wanted to reify modules by name
21:42:05 <dons> ?google _darcs
21:42:05 <lennart> newsham: ah, you want, but don't want to do :)
21:42:09 <dons> what's the numer 1 repo
21:42:09 <lambdabot> http://drupal.ru/repo/modules/fudforum/4.7/_darcs/
21:42:09 <lambdabot> Title: Index of /repo/modules/fudforum/4.7/_darcs
21:42:12 <dons> bizarre
21:42:13 <dolio> newsham: Perhaps you should look at the implementation of HSP.
21:42:27 <dolio> They implemented syntax for first class html somehow.
21:42:27 <newsham> does HSP have that?
21:42:43 <dolio> And pattern matching against html/xml.
21:42:53 <newsham> interesting, will put it on my todo list.
21:43:13 <lennart> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
21:43:19 <lambdabot> Title: Haskell-Source with eXtensions, http://tinyurl.com/qoqzt
21:43:20 <lennart> @where hsx
21:43:21 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
21:44:11 <lispy> i still haven't figured out that trace thing dons wrote which showed up on that debugging thread
21:44:27 <dons> yeah?
21:44:34 <dons> you mean, you don't understand how it works?
21:45:01 <lispy> basicaly
21:45:01 <dolio> ?google haskell server pages dynamic loading
21:45:04 <dons> it just catches the Assert exception, stringifies it, and prints that out nicely, letting execution resume
21:45:05 <lambdabot> http://portal.acm.org/citation.cfm?id=1088353&dl=acm&coll=&CFID=15151515&CFTOKEN=6184618
21:45:06 <lambdabot> Title: Haskell server pages through dynamic loading
21:45:14 <lispy> dons: how does it know the line + column?  is that returned with the error?
21:45:19 <dolio> That paper's not too long, and describes it some.
21:45:21 <dons> assert is magic that way
21:45:35 <newsham> blah, ACM.
21:45:36 <NoGoodNik> Haskell can do dynamic loading?
21:45:39 <dons> it throws an exception with the line and col number in it
21:45:40 <dolio> It's free.
21:45:43 <dons> NoGoodNik: yep
21:45:48 <dons> ?where hs-plugins
21:45:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:46:05 <lennart> it even works ;)
21:46:06 <NoGoodNik> thanks!
21:46:07 <dons> > map (+1) [1..10] -- <-- dynamic loading in action!
21:46:08 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:46:20 <NoGoodNik> eh
21:46:26 <lispy> dons: okay, so it returns the location where assert appears in the code or the location where it was evaluated?
21:46:42 <NoGoodNik> dons: how's that dynamic loading?
21:46:59 <dons> how isn't it? :)
21:47:15 <dons> its turning the src fragment into object code, loading it and running it in a sand box
21:47:18 <newsham> huh, neat syntax hacks in this HSP thing.
21:47:28 <NoGoodNik> ah, it's not interpreting?
21:47:30 <lispy> dons: does it even use a sand box?
21:47:48 <dons> i consider a separate address space a sand box :)
21:47:54 <lispy> hmm....okay
21:48:00 <dons> so it can't muck about inside lambdabot
21:48:17 <lispy> dons: oh, did you have any thoughts about my question about having an environment for lambdabot?
21:48:36 <dons> I did! I'm pondering @let x = e
21:48:49 <lispy> yeah, i think you'd need @unlet
21:48:52 <dons> which would bind expressions to be reused later
21:48:54 <dons> yep
21:48:59 <lispy> just in case someone does things like, @let 1 = 2
21:49:14 <lennart> > let 1 = 2 in 3
21:49:15 <lambdabot>  3
21:49:23 <lispy> > let 1 = 2 in 1
21:49:25 <lambdabot>  1
21:49:42 <lispy> oh, then the problem is this way
21:49:50 <lispy> > let 1 + 2 = 4 in 1 + 2
21:49:51 <lambdabot>  4
21:50:00 <lispy> > let 1 + 2 = 4 in 1 + 3
21:50:01 <lambdabot>  Non-exhaustive patterns in function +
21:50:03 <lennart> yes, that's a problem :)
21:50:31 <lispy> dons: so maybe disallow 'shadowing' of 'top level' bindings?
21:50:32 <lennart> > let (1 + 2) = 4 in 1 + 2
21:50:32 <lambdabot>  Parse error in pattern
21:51:08 <deadbeef> > let _ + 1 = 5 in 1 + 1
21:51:10 <lambdabot>  5
21:51:47 <glguy> > let 1 + 1 = 1 + 1 in 1 + 1 -- Yeah, I'm aware
21:51:48 <lambdabot>  Add a type signature
21:51:54 <glguy> guess i wasn't :)
21:52:07 <glguy> > let 1 + 1 = 1 + 1 in 1 + 1 :: ()
21:52:11 <lambdabot> Terminated
21:52:15 <lispy> dons: then the other question...which i have no idea how to do....would it be possible to turn lambdabot into a web service that could be polled over javascript (I have no idea how to do that sort of stuff or what it really means)
21:52:22 <glguy> just warming up dons room ;)
21:52:44 <dons> ndm wants to do this, yes.
21:52:45 <glguy> smells like AJAX to me
21:52:51 <lispy> glguy: exactly
21:53:05 <lispy> we want to interact with lambdabot from the google personal search page
21:53:12 <dons> since hoogle-via-the-web gets something like 20x the hits of hoogle in irc
21:53:22 <SIAMJam> cale: new proxy, new nick, new ident, same old story
21:53:25 <dons> maybe the other lambdabot plugins should be exposed too. but i'm not sure of the best way yet.
21:53:27 <lispy> then you'd be able to embbed a calculator + neat-o in your google home page :)
21:53:28 <SIAMJam> but in the mean time, how do you feel about crapfloods? i like them
21:53:29 <deadbeef> @where ndm
21:53:30 <lambdabot> I know nothing about ndm.
21:53:34 <glguy> hoogle via the web is more useful than hoogle-irc tho
21:53:34 <deadbeef> ?where ndm
21:53:34 <lambdabot> I know nothing about ndm.
21:53:37 --- mode: ChanServ set +o Cale
21:53:42 <deadbeef> @hoogle ndm
21:53:43 <lambdabot> Data.Map.deleteFindMax :: Map k a -> ((k, a), Map k a)
21:53:44 <lambdabot> Data.Map.deleteFindMin :: Map k a -> ((k, a), Map k a)
21:53:44 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
21:53:44 --- mode: ChanServ set +o dons
21:53:46 <deadbeef> omg
21:53:51 <Cale> okay
21:53:53 <dons> to fast for me Cale :)
21:54:03 <lispy> heh
21:54:17 <lennart> > let (+) + 1 = (+) in 2 + 1
21:54:19 <lambdabot>  2
21:54:21 <deadbeef> is any way to make a search on google ?
21:54:36 <Cale> dons: He's probably going to annoy #ghc
21:54:43 --- mode: ChanServ set -o dons
21:55:10 --- mode: Cale set +b *!*@ip68-102-94-170.ks.ok.cox.net
21:55:16 --- mode: Cale set -o Cale
21:55:37 <dons> hmm. yes. we need an op for #ghc
21:55:43 <dons> Igloo: ping!
21:56:04 <dons> what's the fastest way to get a network admin?
21:56:28 <lispy>  /stats p
21:56:35 <lispy> then message one of the names
21:57:07 <Cale> probably nalioth right now
21:57:24 <lispy> yup
22:01:45 <lispy> dons: if you have ideas for @let maybe i could work on that while you finish the stuff with fps
22:02:10 <lispy> dons: oh, about fps + darcs, droundy liked the idea but he really wanted to preserve backwards compatibility...do you have a strategy for that?
22:02:12 <dons> well, the two ideas i have are. a) keep a "symbol table" of src fragements, and add them to @eval calls
22:02:37 <dons> or b) actually keep the .o files around and link them
22:03:04 <dons> lispy: yeah, just #if __GLASGOW_HASKELL_ >= 605 ... use Data.ByteString ... #else FastPackedString ...
22:04:13 <lispy> dons: re: eval, okay i think keeping a [String] for the function definitions and then dumping them every time is good.  re: darcs, ah if that works cool.
22:04:43 <lispy> i guess it doesn't have to be [String] but you get the idea
22:05:26 <lispy> plus if we store the definitions we can add @let-list
22:05:28 <dons> yeah, the Map Ident Expr soln would be best, since it works with the current eval strategy pretty cleanly
22:05:29 <lispy> to list all the bindings
22:05:41 <dons> so we'd want: @let , @reload I think
22:05:44 <dons> like ghci
22:05:51 <lispy> @reload would do what?
22:05:51 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
22:05:52 <dons> so the 2nd would wipe the entire state
22:06:00 <lispy> ah
22:06:03 <dons>  @clear
22:06:14 <dons> versus @let , which will shadow by design
22:06:16 <lispy> i'm thinking, @let, @let-clear, @let-list, @unlet
22:06:28 <dons> something like that, yep
22:06:45 <lispy> part of the eval module?
22:06:52 <dons> then the issue is to reject type-incorrect programs
22:07:01 <dons> since you don't want them filling up your state
22:07:05 <dons> this will be tricky
22:07:19 <dons> you want to check they both parse and type check before you go sticking them in
22:07:30 <dons> (we had similar issues with djinn's env)
22:08:09 <lispy> parse is easy, type check... i guess we have to dump them in a file and try to compile it?
22:08:54 <dons> see. this is the part where I start not to like the idea of a shared ghci environment :)
22:09:01 <dons> since it seems too easy to break things for everyone.
22:09:07 <dons> you could have per-ick bindings, i suppose
22:09:12 <dons> per-nick
22:09:31 <lispy> hmm...how would you break things?
22:10:09 <lispy> when someone tries to define something you try to compile it with all the other bindings, success -> add it, failure -> give the user an error
22:10:12 <dons> insert valid defintions of (+) in some other channel?
22:10:31 <lispy> don't let them redefine things :)
22:11:01 <lispy> compile it with the -fwarn-shadow or whatever and -Werror
22:11:27 <dons> maybe, yeah
22:11:39 <dons> though that also breaks f x = let y x = ...
22:12:24 <lispy> yup, has to be f x = let y x' = ...
22:12:34 <lispy> but better to be too picky than let people break things
22:20:34 <sjanssen> dump user defns in their own module, then import that module qualified?
22:21:35 <dons> then the users refers to them as say, L.foo (for Lambdabot)
22:21:37 <dons> not a bad idea!
22:21:56 <dons> i.e. just keep the defns in State/Local.hs
22:22:17 <dons> and then only recompile if the file changes
22:23:52 <lispy> mm...yes, not bad
22:24:20 <lispy> it's longer but what about having it be the Let module
22:24:31 <lispy> @let blah, > Let.foo ...
22:24:31 <lambdabot> No module "blah, > Let.foo ..." loaded
22:24:51 <dons> This.foo ?
22:24:54 <dons> :)
22:25:06 <lispy> i like red bike sheds
22:25:12 <edwardafk> blue!
22:25:19 <lispy> exactly
22:25:27 <lispy> qed
22:25:39 <dons> I think a single letter is a good idea. L.foo or T.foo or something
22:25:41 * edwardafk is armwrestling with a bikeshed color at the moment in his little pet project and can't pick =)
22:26:05 <lispy> edwardafk: according to the pragmatic programmer that means make it a configuration option
22:26:37 <edwardk> well, not exactly possible coz its at the core of the language ;)
22:26:49 <edwardk> guess its a little more than a bike shed then
22:26:56 <lispy> :)
22:27:13 <lispy> what about making it a compile time option though?
22:27:20 <lispy> i mean, ghc has -fglasgow-exts
22:27:32 <lispy> and that changes the language quite a bit
22:28:13 <edwardk> basically started looking at the collected set of all of the modalities i picked up i my toy language, and noticed some symmetries that let me take it from 6 things to 9, in a symmetrical way so that i can express it as a cross product of two features with 3 options each.
22:28:31 <edwardk> but it means that i lose my cool regexp inspired syntax ;)
22:28:37 <newsham> wow, Simon PJ's Miranda book is awesome.
22:28:44 <edwardk> newsham: yeah it doesn't suck
22:29:01 <lispy> he wrote a Miranda book?
22:29:08 <newsham> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
22:29:15 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
22:29:26 <lispy> i guess miranda largely inspired haskell
22:29:28 <wli> Yeah, it is phenomenal.
22:29:53 * therp waits for his library to ship this book
22:30:08 <edwardk> so instead of rambling on about affine, relevant, linear, unrestricted, and uniqueness. i get to ramble on about {mutable, copyable, unique} x {forgettable, destructible, strict} modulo the choice of better names.
22:30:29 <lispy> edwardk: oh, he has another book like that about compiling to the g-machine
22:30:45 <edwardk> where there is a nice symmetry in the way the types promote within the two groups.
22:31:04 <edwardk> not sure i've seen that one.
22:31:19 * lispy goes to check del.icio.us
22:31:26 <edwardk> lispy: if you read the history-of-haskell paper it goes on about how they wantd to just extend miranda, but the guy who wrote it said no.
22:31:46 <edwardk> so a lot of the haskell decisions were made to copy miranda and some were made to make it different enough that it wouldn't be mistaken for it.
22:32:25 <SIAMJam> you know this is going to start a war
22:32:28 <lispy> edwardk: yeah, i remember that
22:32:30 <SIAMJam> are you so sensitive about your name that its banworthy?
22:32:42 --- mode: ChanServ set +o Cale
22:32:47 <SIAMJam> NIGGER
22:32:51 --- topic: set to 'NIGGERS' by SIAMJam
22:32:51 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:51 --- topic: set to 'NIGGERS' by SIAMJam
22:32:51 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:52 --- topic: set to 'NIGGERS' by SIAMJam
22:32:52 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:53 --- topic: set to 'NIGGERS' by SIAMJam
22:32:53 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:55 --- topic: set to 'NIGGERS' by SIAMJam
22:32:55 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:57 --- topic: set to 'NIGGERS' by SIAMJam
22:32:57 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:32:59 --- topic: set to 'NIGGERS' by SIAMJam
22:32:59 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:33:01 --- topic: set to 'NIGGERS' by SIAMJam
22:33:01 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:33:03 --- topic: set to 'NIGGERS' by SIAMJam
22:33:03 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by ChanServ
22:33:03 --- mode: Cale set +b SIAMJam!*@*
22:33:04 --- mode: ChanServ set +o dons
22:33:10 <newsham> kick SIAMJam
22:33:18 --- mode: Cale set +b *!*@c-24-3-204-85.hsd1.pa.comcast.net
22:33:24 --- kick: SIAMJam was kicked by Cale (Cale)
22:33:32 <edwardk> ah look its our good friend teekwod
22:33:40 <sjanssen> @teekword
22:33:41 <lambdabot> Unknown command, try @list
22:33:46 <dons> the topic is locked for non-admin users now
22:33:47 <sjanssen> oh well, maybe tomorrow
22:33:51 <newsham> why not +t ?
22:34:03 --- mode: Cale set +t
22:34:06 <newsham> if the bot is going ot change back anyway (is the bot opped?)
22:34:24 <dons> what's the difference between +t and the way it is currently locked?
22:34:31 <dons> no change at all possible?
22:34:36 <Cale> dons: right
22:34:37 <edwardk> yeah
22:34:41 <dons> ok. that'll do
22:34:43 <edwardk> can only be changed by ops
22:34:49 <newsham> the way it was previously locked, SIAMJam coul dchange the topic
22:34:56 <edwardk> and spam the hell out of us
22:35:00 <lispy> edwardk: this http://citeseer.ist.psu.edu/peytonjones92implementing.html  but that's only a draft not the full thing
22:35:09 <edwardk> ah read that =
22:35:16 <dons> yes, i see. though ChanServ catches it and flips it back at least
22:35:18 <edwardk> borrowed lots of stuff from  it in fact
22:35:30 <edwardk> yeah, but it means he can fill your screen with crap
22:35:34 <dons> yep
22:36:11 <lispy> what's his major malfunction?  just a chip because Cale banned him in #math?
22:36:19 <lispy> if so, that's pretty weak
22:36:19 <Cale> lispy: basically
22:36:29 <Cale> And it's not like I banned him for nothing
22:36:41 <Cale> He was basically trying to get banned.
22:36:50 <lispy> of course
22:37:01 <lispy> i would be shocked if you "just banned" anyone
22:37:03 <edwardk> so can anyone think of a good reason to stick to 'relevant, affine, unrestricted, linear' rather than switch to a nice symmetric set of modalities taken from a cross product of two completely orthogonal sets of concepts?
22:37:16 <newsham> enough talk about random idiot who isnt here anymore...
22:37:25 <dons> yep. agreed
22:37:36 <lispy> edwardk: more to learn and understand in the second case
22:38:04 <lispy> edwardk: i look at it and i see at least 6 options, but i think you said you did a full product to get 9?
22:38:31 --- mode: dons set -o dons
22:38:43 <edwardk> lispy: in one sense. but once i've extended the former with uniqueness types and destructible types i get 9 in the former anyways. well, technically 16, but 7 of those are degenerate. once i remove those i get two axes on which i have 3 options each.
22:39:03 <edwardk> and a nice clean set of arrows to move between them and a good computational reason to move on one axis before the other one.
22:39:12 <edwardk> so it makes the rules of when to do what much more clean.
22:39:33 <edwardk> you can view one axis as talking about how the value will be evaluated, and the other talking about how the value will be copied.
22:39:42 <lispy> well, if one is easier to learn and use correctly then i'd say it's pretty obvious :)
22:39:57 <edwardk> without it i wind up talking about how 16 different things interact, i might have to provide 240 rules ;
22:39:58 <sjanssen> lisppaste2: url
22:39:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:39:58 <edwardk> ;
22:40:01 <edwardk> er ;)
22:40:03 <edwardk> gah
22:40:36 <lispy> edwardk: 240 rules would still be less than C++ ;)
22:40:59 <lispy> looks like the big dogs are here now :)
22:42:15 <edwardk> the last hing i am debating about is whether or not to actually think of affinity and relevance as true modalities, in which case i would distinguish, affine relevant from relevant affine from unrestricted. the former would allow you to optionally discard it, and if you didn't, evaluate everything you've done and allow it to be copied freely and updated strictly from then on, the latter would allow you to update it strictly, but throw
22:43:04 <edwardk> then you can wind up with a countably infinite hierarchy of modalities, of nested affinity and relevance, which seems like it might be awkward, but it really does express possibly useful information.
22:43:24 <edwardk> and qualifiers are related by whether or not one is a subsequence of the other.
22:43:55 <edwardk> and unrestricted is simply a wildcard that allows unrestricted mixing of cotnraction and weakening.
22:44:05 <lispy> well, it sounds like you thought about it a lot.  What do you think you should do?
22:44:18 <edwardk> not sure. kinda kicking it around for the last hour or so
22:44:35 <edwardk> this is the real devil's advocate to the simple 3x3 idea
22:45:43 <edwardk> coz it seems useful to be able to specify when in the type more specifically when it might be copied or evaluated, but i'm worried than if those possible sequenes grow too much, i might lose principal typing.
22:45:57 <edwardk> and that will make my error messages worse
22:46:55 <beu> hmm
22:46:58 <lispy> otoh, you don't know taht for sure until you have programs to compile?
22:47:08 <lisppaste2> sjanssen pasted "why doesn't this fuse?" at http://paste.lisp.org/display/25563
22:47:11 * beu waves to araujo 
22:47:22 <sjanssen> dons: any idea why that doesn't fuse?
22:47:26 <dons> looking...
22:47:42 <edwardk> well, my worry is that doing a lot of subsequence calculations for every typing judgement will drag my compilation down to a crawl
22:47:56 <edwardk> also minimal supersequence calculations as well.
22:48:11 <dons> those inlines looks a bit suspicious, sjanssen
22:48:17 <dons> shouldn't they be INLINE [0] ?
22:48:32 <dons> maybe not. hmm
22:49:21 <edwardk> plus there are longest common subsequence problems. all of which are NP. so solvable, but i wouldn't want to do this for long sequences =)
22:49:48 <lispy> oh i see
22:49:58 <edwardk> but it'd be a lot cooler to have this little infinite algebra in the middle =)
22:50:31 <edwardk> but i think i may have to limit myself to the 9 cases.
22:51:06 <lispy> i want to start a band called, "Inifinite Algebra"
22:51:07 <edwardk> and do them as a cross product of two ideas. first one saying how the object/term has been copied, and the second one saying how it will be used.
22:51:50 <edwardk> {mutable, copyable, unique} i can move mutable -> copyable for free, copyable -> unique by copying, mutable -> unique for free.
22:52:20 <lispy> nice
22:52:31 <edwardk> {forgettable, destructible, strict} i can move from forgettable to destructable by inserting a null destruction operation, destructable to strict by evaluating it, and forgettable to strict by evaluating.
22:52:36 <Korollary> It's all vaporware!
22:53:12 <edwardk> then linear is unique strict, relevant is copyable strict, affine is unique forgettable, unrestricted is copyable forgettable.
22:53:38 <edwardk> uniqueness becomes mutable forgettable to get the ones from Clean.
22:54:15 <dons> sjanssen: seems to generate some too-complex code for the bindings
22:54:24 <dons> such that the rule won'tmatch
22:54:25 <edwardk> destructible types let me store other destructible types in them, that way you can have a form of linear type held in a form of unrestricted type, but when you go to destroy the region containing it it will have to call the destructor for all destructible types in it.
22:55:23 <dons> ah ha, got it sjanssen
22:55:24 <edwardk> you can store references to almost every type in every other, which is why i had to add destructible. otherwise there was no way to get the idea that you could have an unrestricted type holding a linear one, coz you could dispose of the unrestricted constructo without doing something to the linear argument.
22:55:26 <dons> 12 RuleFired
22:55:26 <dons>     1 FPS replicate -> fused
22:55:26 <dons>     1 FPS strTransformerUp/strProducerBi
22:55:29 <dons> :)
22:56:03 <sjanssen> in my original code, if I supply huff with undefined fusion fires, otherwise it doesn't
22:56:15 <edwardk> you can only access affine/linear contents of relevant/unrestricted constructors by swapping, which i haven't figured out a good notation for in the case statement though =(
22:56:39 <lisppaste2> dons annotated #25563 with "make things a bit easier to spot" at http://paste.lisp.org/display/25563#1
22:56:50 <edwardk> coz you can only use a linear type once, and you can use its container more than once the only ay to keep the reference counts right is to swap another linear object into its place when you take it out.
22:57:20 <edwardk> Korollary: bah ;)
22:58:17 <dons> sjanssen: so this works:     B.putStrLn . huff t . B.replicate 10000 $ 42
22:58:27 <sjanssen> yeah, funny how that works out
22:58:44 <edwardk> only problem i have is that i find the mnemonics for those two axes to be clunkier than the regexp inspired ones for unrestricted, relevant, affine and linear. =/
22:58:46 <dons> so I think its about the rule matcher not catching the let x = .. in let y = ... case very well
22:59:01 <edwardk> and they force me to think in pretypes, not comonads.
22:59:51 * edwardk watches lispy snore away on his keyboard.
23:00:03 <dons> sjanssen: nice idea by the way :)
23:01:36 <edwardk> i really need to learn my way around the rule engine in haskell in more detail one of these days -- more than just {-# INLINE #-}'ing stuff ;)
23:05:17 <edwardk> ok, giving up on the infinite tower version.
23:05:23 <edwardk> *sniff*
23:13:09 <edwardk> now i just need better names than those
23:21:19 <Stinger> is there an easy way to print integers in binary (i.e. library provided?)
23:22:01 <dons> nope. but should be easy to write a one liner to do this
23:22:05 <dons> using Data.Bits
23:22:30 <Stinger> cool I'll hoogle Data.bits
23:23:10 <int-e> > showIntAtBase 2 intToDigit 42 ""
23:23:11 <lambdabot>  "101010"
23:23:19 <dons> ah :)
23:23:42 <dons> ?karma+ int-e --  remembering showIntAtBase
23:23:42 <lambdabot> int-e's karma raised to 19.
23:23:58 <Stinger> > showIntAtBase 16 intToDigit 42 ""
23:23:59 <lambdabot>  "2a"
23:24:03 <Stinger> excellent
23:24:08 <int-e> I did just look at Numeric again, for other reasons (read integer stuff)
23:26:26 * dblhelix has to teach java in 30 mins... :|
23:30:57 <Stinger> oh dear, it would seem windows ghci doesnt like breaking out of neverending computations :(
23:31:24 <lispy> Stinger: inside cmd or Msys?
23:31:29 <dons> hit it with a hammer?
23:31:36 <lispy> iirc, msys doesn't handle ctrl+c correctly
23:31:50 <dblhelix> Stinger: I myself don't like being trapped inside a neverending computation, but, hey, that's just me
23:31:54 <lispy> (and by msys i mean the rxvt thingy taht comes with mingw)
23:31:54 <Stinger> I don't really know, just ran it from the start menu
23:32:15 <lispy> hm...don't know if i've ever started ghci that way
23:32:25 <lispy> and i'm my mac at the moment :)
23:32:38 <Stinger> well it closes fine
23:32:55 <Stinger> have to enter all my bindings in again though
23:34:41 <lispy> bummer
23:34:54 <Stinger> all two of them ;)
23:35:06 <lispy> i would recommend writing them down in a (temp?) file next time and using :r to reload them
23:35:38 <Stinger> normally I would, but this is just some throw away computations
23:35:58 <eivuokko> Stinger, did you use ghci.sh to start ghci?
23:36:18 <lispy> Stinger: ah okay
23:36:28 <Stinger> probably by the fifth time I accendentily try to compute some infinite computation I'll open emacs ;)
23:36:33 <eivuokko> Ah, right, the non-console prog...probably doesn't work like lispy said.
23:36:44 <dylan> @hoogle flush
23:36:44 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
23:36:45 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
23:36:45 <lambdabot> IO.hFlush :: Handle -> IO ()
23:38:09 <lispy> eivuokko: how goes code?
23:38:24 <dylan> holy mystic toilet gods lambdabot. ;)
23:38:55 * dblhelix wonders if dylan secretly is batman's helper
23:39:06 <dons> not so secret..
23:39:10 <dylan> I serve the toilet.
23:39:24 <lispy> all hail the toilet
23:39:26 <dylan> @google Data.Bytestring docs
23:39:29 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-ByteString-Base.html
23:39:36 <Stinger> hangover?
23:39:42 <dblhelix> speaking of toilets... well... nevermind
23:39:47 * dblhelix is off for class
23:39:55 <lispy> @. tiny-url google Data.ByteString docs
23:39:57 <lambdabot> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-ByteString-Base.html
23:40:15 <lispy> now why do you think that didn't work?
23:40:21 <dons> not sure. bit weird
23:40:27 <lispy> @tiny-url http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-ByteString-Base.html
23:40:29 <lambdabot> http://tinyurl.com/f294t
23:40:55 <dons> ?. tiny-url id http://haskell.org
23:40:55 <lambdabot> http://haskell.org
23:41:04 <dons> ?id http://haskell.org
23:41:04 <lambdabot> http://haskell.org
23:41:09 <lispy> it accepts the url just fine so it must be a problem with ?. and ?tiny-url at the same time
23:41:15 <dons> yeah
23:41:34 <lispy> maybe when i defined it i didn't pat match the case for compose/
23:41:48 <dons> should just work
23:43:22 <dons> it adds a \n to the end
23:43:33 <dons> compose, that is
23:43:34 <dylan> whee, echo server with fps and forkIO seems to be working.
23:43:39 <dons> cool!
23:44:04 <dylan> pretty good for 20 minutes total research and implementation.
23:44:10 <dons> :)
23:45:06 <lispy> dylan: nice
23:45:25 <lispy> i tried to write an echo server with threads sharing some state and it always had a space leak :(
23:45:30 <dylan> I wonder if a tail call in an IO-monadic function is causing a lot of wasted CPU...
23:45:35 <lispy> and then would go spinnig out of control and crash...
23:46:08 <dylan> I'm assuming hGetLine pauses the forkIO thread...
23:46:22 <lispy> dons: so the \n at the end messes it up you think?
23:46:34 <dons> isi think so
23:46:44 <dylan> lispy: sharing state with STM or with traditional stuff?
23:46:44 <dons> ?tiny-url http://www.cse.unsw.edu.au\n
23:46:45 <lambdabot> http://www.cse.unsw.edu.au\n
23:46:45 <lispy> dons: but the regexp for detecting the url shouldn't care about that should it?
23:46:51 <dons> there :)
23:46:58 <lispy> dylan: tradtional, but i'd like to try it again with stm
23:47:04 <dons> ?tiny-url http://www.cse.unsw.edu.au  stuff
23:47:04 <lambdabot> http://www.cse.unsw.edu.au  stuff
23:47:07 <lispy> dons: Oh
23:47:16 <dons> ?tiny-url http://www.cse.unsw.edu.au
23:47:18 <lambdabot> http://tinyurl.com/odfzl
23:47:25 <dylan> I'm used to state-machine stuff (single-threaded) and erlang-style message passing.
23:47:26 <dons> so whitespace is ok, other stuff not so
23:47:29 <lispy> dons: BTW, i noticed a problem when a url has parens in it, this happens with wikipedia
23:47:33 <dylan> Never ever bothered touching normal threading
23:47:41 <lispy> dons: oh, i know
23:47:45 <dons> lispy, example?
23:47:55 <lispy> dons: when you use ?tiny-url it just uses the whole input instead of running the regexp
23:48:04 <dons> ah right
23:48:14 <dons> so it should actually clean it up
23:48:25 <lispy> ?tiny-url http://www.foo.com/blah(bar)baz
23:48:26 <lambdabot> http://tinyurl.com/rntcx
23:48:28 <dylan> URLs shouldn't have unescaped parens in them, should they?
23:48:35 <dons> because the contextual stuff and the tiny-url should behave roughly the same
23:49:08 <lispy> that was a bad example, but iirc, it cuts off afer the r in bar
23:49:16 <musasabi> morning
23:49:30 <lispy> dons: yeah, i think i just was lazy and did whatever url-title did
23:49:48 <lispy> dons: so it probably has this bug as well
23:50:06 <lispy> ?. url-title google haskell.org
23:50:53 <lispy> http://en.wikipedia.org/wiki/Celebrity_Jeopardy!_(SNL)
23:51:06 <lispy> ?tiny-url http://en.wikipedia.org/wiki/Celebrity_Jeopardy!_(SNL)
23:51:07 <lambdabot> http://tinyurl.com/ffydf
23:51:10 <dylan> lispy: what http useragent are you getting that from?
23:51:20 <dylan> here, say,
23:51:24 <dylan> I get http://en.wikipedia.org/wiki/Scheme_%28mathematics%29
23:51:39 <dylan> with %28 being ( and %29 being )
23:51:39 <lispy> oh well, that wone worked because tiny-url doesn't use the regexp...duh
23:51:56 <lispy> need a longer url :)
23:52:20 <lispy> dylan: i'm using firefox, fwiw
23:52:39 <dylan> same here.
23:52:41 <lispy> yeah, that works
23:52:46 <dylan> @tiny-url http://en.wikipedia.org/wiki/Scheme_%28mathematics%29?I%20am%20popula%20with%20the%20chickens
23:52:47 <lambdabot> http://tinyurl.com/fuwwe
23:52:49 <lispy> but when i look it up on wikipedia i get the first kind
23:53:21 <dylan> always copy from the URL bar?
23:53:24 <lispy> http://en.wikipedia.org/wiki/Scheme_(mathematics)#The_category_of_schemes
23:53:37 <lispy> ?url-on
23:53:38 <lambdabot> Not enough privileges
23:53:41 <lispy> hmm...
23:54:04 <lispy> bleh, i should sleep
23:54:19 <lispy> i need to get up early tomorrow and it's already midnight :)
23:54:33 <dylan> it's 2:55 here.
23:55:23 <lisppaste2> dylan pasted "echo-server.hs" at http://paste.lisp.org/display/25564
23:58:54 <lispy> dylan: now make it echo to all the other threads
23:59:07 <lispy> dylan: that's what i was trying to do and have the threads share an environment
23:59:21 <lispy> dylan: basically the start of a 'chat' server to build something like a mud on top of
23:59:37 <dylan> lispy: First I'd like to get persistence going. ;0
