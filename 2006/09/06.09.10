00:01:02 <jgrimes> nice :D
00:02:39 <dons> > 1 :: I
00:02:40 <lambdabot>  1
00:02:48 <dons> type I = Int
00:07:04 <lispy> i lke the new karma syntax
00:07:12 <lispy> was that SamB?
00:07:56 <dons> yep
00:08:53 <dolio> Hmm...
00:09:03 <dolio> Oh.
00:09:13 <lispy> SamB++
00:09:31 <dolio> -n `mod` a parses as -(n `mod` a)?
00:09:33 <hitodama> hmm, does anyone know if I can access the ghc interpreter from within eclipse?
00:09:36 <dolio> No wonder they looked the same.
00:10:09 <lispy> hitodama: i never figured out how, but i'm no eclipse expert (and haven't used it for a few months)
00:10:17 <lispy> hitodama: using eclipse-fp?
00:10:22 <hitodama> yes
00:10:35 <lispy> email the author, he's always been really helpful
00:12:00 <lispy> dons: do you think lambdabot/GoA could be hooked up as just another editor mode in yi?
00:12:34 <dons> yeah, maybe
00:13:22 <lispy> not sure how nice that would be in practice...but the integration could be nife
00:13:24 <lispy> er nice
00:15:31 <dons> ibid, I wonder if we could get some HsColour css tags for planet.haskell.org, so the haskell markup gets coloured? (using, e.g., http://www.cse.unsw.edu.au/~dons/tmp/hscolor.css, we can then get hsColour -css to color things nicely. e.g. http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#quickcheck)
00:15:32 <lambdabot> http://tinyurl.com/goapg
00:15:55 <gour> lispy: i also think it would be nice as part of hIDE
00:20:37 <dolio> glguy: You tried #127 on mathschallenge yet?
00:22:15 <dons> how you guys going with that? what's the highest ranked haskell entrant so far?
00:23:00 <dolio> The highest haskell guy is ranked 54th.
00:23:11 <dolio> glguy is 75th
00:23:30 <dons> who's #54?
00:23:40 <dolio> "Eighty"
00:23:49 <newsham> is there a function converting List to Maybe ([] -> Nothing, (x:xs) -> Just x)   ?
00:24:04 <dons> what's the type?
00:24:14 <newsham> [a] -> Maybe a
00:24:20 <dons> ?hoogle [a] -> Maybe a
00:24:20 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
00:24:20 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
00:24:26 <newsham> perfect
00:24:32 <dons> > listToMaybe [1,2,3]
00:24:33 <lambdabot>  Just 1
00:24:37 <dons> > listToMaybe []
00:24:38 <lambdabot>  Add a type signature
00:24:49 <dons> > listToMaybe ([] :: T)
00:24:50 <lambdabot>  Nothing
00:25:12 <newsham> zactly what i wanted
00:25:30 <thetallguy> ?list
00:25:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:26:19 <ibid> dons: reload planet now
00:26:37 <dons> oh nice!
00:26:40 <dons> ibid++ :)
00:27:02 <dons> i'll post a little entry on how to get the nice colouring for the other guys
00:30:44 <emu> @type List.group
00:30:45 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
00:30:48 <dons> ?where HsColour
00:30:48 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
00:31:07 <emu> > List.group [1,2,2,3]
00:31:08 <lambdabot>  [[1],[2,2],[3]]
00:32:07 <emu> is group something new?
00:32:28 <emu> i can't seem to use it in ghc 6.4.2
00:32:38 <thetallguy> Should be there
00:32:40 <thetallguy> Data.List
00:32:41 <ibid> nothing new, it's hg98
00:32:46 <ibid> -g
00:33:02 <emu> keeps telling me its not in scope, i tried group, List.group, Data.List.group
00:34:38 <emu> bah had to "import List" for some reason
00:35:16 <thetallguy> what version are you using?
00:35:21 <thetallguy> Oh
00:35:25 <thetallguy> ghc 6.4.2
00:35:33 <thetallguy> That doesn't seem right.
00:38:13 <dons> List is in the haskell98 package
00:38:35 <dons> the 21st century soln is to use Data.List instead
00:42:06 <Lemmih> It's only on the GHCi cmd-line you can access qualified symbols without import statements.
00:42:21 <emu> aye, i got confused by that
00:55:19 <newsham> if I have a "module Mod" in a Mod.hs with its own "main", can I build it with ghc (ghc --make Mod?) so that I get a binary that invokes main?
00:55:46 <newsham> or is it mandatory to have a Main module?
00:56:01 <Lemmih> newsham: Try: --main-is Mod.main
00:56:21 <newsham> ghc-6.4.2: unrecognised flags: --main-is
00:57:27 <newsham> -e looks like what i want kinda, but it is incompatible with --make
00:57:35 <Lemmih> newsham: -main-is, maybe.
00:58:14 <newsham> that almost worked, lemmih, but link errors
00:58:21 <newsham> : undefined reference to `__stginit_ZCMain'
00:58:21 <newsham> : undefined reference to `ZCMain_main_closure'
00:58:34 <Lemmih> newsham: Touch Mod.hs and try again.
00:58:52 <newsham> tada!
00:59:30 <Lemmih> Magic touch! Aeyyy.
01:00:15 <newsham> so my parser is almost working properly (works on some inputs), but I'm seeing a weird error:
01:00:26 <newsham> unexpected served word "classify" or served word "boolean"
01:00:26 <newsham> expecting lowercase letter, uppercase letter, digit, whitespace, "packet", "classify", "array", "(" or "}"
01:00:30 <emu> is there a better way to say something like: (\x -> \y -> fst x == fst y)?
01:00:43 <newsham> weird that it says "served word"  (I imagine it means 'reserved word')
01:00:47 <Lemmih> emu: (\x y -> fst x == fst y)?
01:01:01 <newsham> also weird that I have a   reserved "classify"   and I have "classify" in the list of my reserved words
01:01:14 <dolio> ?pl \x y -> fst x == fst y
01:01:14 <lambdabot> (. fst) . (==) . fst
01:01:20 <newsham> (it says unexpected and then later it says its expecting it!)
01:01:25 <emu> hmm
01:06:27 <emu> opWithKey o k = (. k) . (o) . k -- seems like a useful fn =)
01:07:48 <newsham> anyone know why i might see this behavior with parsec?
01:10:09 <newsham> oh well, enough code for today.. sleep
01:20:28 <dolio> > maxBound :: Int
01:20:29 <lambdabot>  2147483647
01:22:00 <dons> > maxBound :: Word64
01:22:01 <lambdabot>  18446744073709551615
01:23:38 <int-e> emu: yes, several people have come up with this before (under different names. the one I remember is 'attach'). opWithKey compare  is implemented as 'comparing' in http://haskell.org/hawiki/LicensedPreludeExts
01:23:40 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
01:23:52 <dons> > 18446744073709551615 ^ 100
01:23:53 <lambdabot>  3908159226643238711988440663885495103153377707739061175077580776059325191881...
01:26:36 <profmakx> ive got another problem with lambdabot, dons... or at least with hs-plugins
01:27:07 <profmakx> (perhaps i should use ghc 6.4...)
01:27:47 <profmakx> when compiling hs-plugins i get a parse error in src/AltData/Typeable.hs:452:0
01:27:47 <dons> yes?
01:28:14 <dons> you don't need hs-plugins to use lambdabot these days, though?
01:28:20 <profmakx> i dont?
01:28:24 <profmakx> hmm
01:28:28 <dons> are you using lambdabot from darcs? or the snapshot?
01:28:33 <profmakx> from darcs
01:28:44 <profmakx> is there any doc apart from the code?
01:28:48 <dons> Build-Depends:       base, unix, network, parsec, mtl, haskell-src, readline, haskell98, fps>=0.7
01:28:54 <profmakx> hmm
01:29:03 <dons> there's a commentary file, and there's the wiki/home page
01:29:08 <dons> ?where lambdabot
01:29:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:29:29 <profmakx> can it evaluate expressions without the plugins?
01:29:34 <dons> so with ghc 6.5, you need, Build-Depends:       base, unix, network, parsec, mtl, haskell-src, readline, regex-compat
01:29:37 <dons> nope
01:29:53 <dons> so if you want that, you do in fact need hs-plugins.
01:30:08 <dons> let me find the faq for 6.5
01:31:33 <dons> you need a ghc 6.5 older than about a month ago
01:31:44 <dons> and then you need to edit the .cabal file for hs-plugins in 2 places:
01:32:16 <dons> adding the path to your 6.4.x include dir, -I/home/dons/lib/ghc-6.4.2/include/ to ghc-options:
01:32:21 <dons> and includes:             Linker.h Typeable.h
01:32:33 <dons> so either way, you still need a ghc 6.4.x installed
01:32:53 <dons> several changes to the package and .hi file formats mean hs-plugins is temporarily broken with ghc 6.5
01:33:03 <dons> (without ghc 6.4.x also installed)
01:33:04 <profmakx> yeah, i think i will just build a 6.4.x
01:33:08 <profmakx> for the time being
01:33:12 <dons> ok
01:33:35 <profmakx> because i dont want to have too many places causing problems while just beginning with haskell ;)
01:33:42 <profmakx> thanks anyway
01:37:38 <dons> no problems. i'd be interested to hear how you use it, and any other feedback you have on lambdabot
01:47:17 <emu> ?pl ((==0) . (n `rem`))
01:47:18 <lambdabot> (0 ==) . (n `rem`)
01:48:29 <profmakx> dons, i will use a lambdabot as bot on some channels on euirc
01:48:37 <dons> cool
01:48:43 <profmakx> and use it as toy to laern haskell
01:48:48 <dons> let me know if you have any issues with it
01:49:07 <profmakx> i think one of the first things to do is flood protection... kiddies
01:49:18 <dons> it already has flood protection :)
01:49:22 <profmakx> oh
01:49:23 <profmakx> thhen
01:49:31 <profmakx> my first task is: find out how it works ;)
01:49:59 <dons> the flood protection emits large output line-by-line in 1 sec intervals
01:50:11 <dons> however, we usually also ensure that plugins don't produce large amounts of output anyway
01:50:13 <dons> > [1..]
01:50:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:50:41 <profmakx> what i meant was that for example one of the users has so much fun with the karma-plugin that she calls it on and on
01:51:15 <profmakx> i _really_like infinite data structures ;)
01:53:00 <dons> ah ok.
01:53:11 <dons> so that would require some other tweaking then
01:53:35 <profmakx> perhaps i first make one of those useless weather-plugins
01:53:45 <profmakx> thats more like copy some plugin and then parse html
01:53:51 <dons> yep
01:58:43 <dons> ?check True
01:58:44 <lambdabot>  OK, passed 1000 tests.
01:58:52 <gour> Lemmih: is hIDE buildable with ghc-20060907 ?
01:59:15 <dons> ?check \x -> ((x :: I) < 256)
01:59:16 <lambdabot>  Falsifiable, after 749 tests:
01:59:16 <lambdabot> 351
01:59:55 <dolio> ?index I
01:59:55 <lambdabot> bzzt
02:01:12 <dons> type I = Int
02:01:20 <dons> (shorthand for #haskell :)
02:01:53 <newsham> ?check \x y -> x <= (max x y) && y <= (max x y)
02:01:54 <lambdabot>  Add a type signature
02:02:09 <Lemmih> gour: I have no idea.
02:02:16 <dons> you need to tell QuickCheck which Arbitrary instance to use
02:02:18 <newsham> ?check \x y -> x <= (max x y) && y <= (max (x :: Int) (y :: Int))
02:02:19 <lambdabot>  OK, passed 1000 tests.
02:02:48 <dons> ?check \x y -> x <= max x y && y <= max (x::I) (y::I)
02:02:49 <lambdabot>  OK, passed 1000 tests.
02:02:58 <gour> Lemmih: ok. let me see...
02:03:02 <newsham> ?check \a b c -> ((a :: Int) + b) + c == a + (b + c)
02:03:03 <lambdabot>  OK, passed 1000 tests.
02:03:24 <newsham> ?check \a b c -> ((a :: Int) - b) - c == a - (b - c)
02:03:25 <lambdabot>  Falsifiable, after 2 tests:
02:03:25 <lambdabot> 2
02:03:40 <newsham> hmm, doesnt give all of a,b,c ?
02:03:51 <dons> let me see
02:04:11 <dons> ah, it truncates the output
02:04:14 * dons fixifies
02:04:54 <newsham> also, doenst quickCheck usually just do 100 iters?
02:05:09 <newsham> quickCheck prop_Max
02:05:09 <newsham> OK, passed 100 tests.
02:05:14 <dolio> Humm... I seem to have hit the wall as far as optimizing this algorithm goes...
02:05:22 <dolio> I'm as slow as TCL.
02:05:31 <dons> yep, i thought we'd add 1000 since its compiled and since 1000 > 100
02:05:52 <newsham> tcl me elmo
02:05:58 <emu> ?pl  \y -> ((. fst) ((\x -> ((==) (fst x))) y))
02:05:58 <lambdabot> (. fst) . (==) . fst
02:06:17 <profmakx> whee
02:07:20 <dolio> "Tcl:4.5s and C:67ms"
02:07:38 <dolio> Not a paritcularly spectacular showing when compared to C.
02:07:58 <dons> what kind of problem is it?
02:08:02 <newsham> 9x slowdown, same order of magnitude ;-)
02:08:26 <int-e> dolio: what are you doing?
02:09:02 <dolio> Given a, b, c, all relatively prime, a < b, a + b = c, rad(abc) < c...
02:09:26 <newsham> the language where everything is a string is not supposed to be fast
02:09:28 <dolio> Find the sum of all such c < 100,000.
02:10:54 <int-e> and rad is the radius of the circumcircle?
02:11:18 <dolio> rad is the product of the unique prime factors.
02:11:30 <dolio> rad(2^n) = 2
02:11:31 <int-e> oh
02:11:37 <dolio> Etc.
02:12:19 <profmakx> hmm
02:12:26 <profmakx> semms like a radical to me ;)
02:12:26 <emu> ?pl  \z -> (\y -> ((==) (fst y) (fst z)))
02:12:27 <lambdabot> (. fst) . (==) . fst
02:12:34 <emu> ?yow
02:12:34 <lambdabot> This MUST be a good party -- My RIB CAGE is being painfully pressed up
02:12:35 <lambdabot> against someone's MARTINI!!
02:12:38 <int-e> it's number crunching. I'd do it in C ;)
02:13:24 <dolio> :) If I did it in C, I couldn't say I did it in Haskell on mathschallenge.net
02:13:32 <dons> ?quit heh
02:13:38 <newsham> so you generate all (a,b) st a+b < 100k and a<b, then factor and see if relatively prime, and compute rad and see if its good?
02:13:43 <falconair> is it possible for a language like haskell to allow arbitrary language syntax to be embedded within it?  for example: "let x = <html> <body....." or "let y = select * from table" ?
02:14:08 <Cale> falconair: It doesn't.
02:14:10 <emu> ?pl \o k a b c -> (o (k a) (k b) (k c))
02:14:13 <dolio> Well, you could do it that way, but that's way too slow.
02:14:16 <Cale> falconair: But there's HSP
02:14:37 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
02:14:43 <emu> rofl
02:14:48 <astrolabe> ping Cale
02:14:52 <dolio> When I first solved the problem, I set it to work while I slept, and it took about an hour and forty minutes for a naive algorithm.
02:14:53 <Cale> hi
02:14:53 <dons> ?check \a b c -> ((a :: Int) - b) - c == a - (b - c)
02:14:57 <dolio> Now I've got it to around 4 second.
02:14:57 <newsham> there's an HTML lib that has syntax like html in haskell.
02:15:08 <dolio> Although it's much uglier.
02:15:10 <lambdabot>  Falsifiable, after 1 tests: -1, 2, -2
02:15:40 <dons> ?check \a b c -> ((a :: Int) + b) + c == a + (b + c)
02:15:42 <lambdabot>  OK, passed 1000 tests.
02:15:54 <astrolabe> cale: With a polynomial, you can find the quadratic and higher factors by taking the gcd of f and f'.  Do you know anything similar for integers?
02:15:54 <newsham> does lambdabot ever keep state?
02:16:00 <emu> ?info join
02:16:00 <lambdabot> join
02:16:01 <dons> yep mostly
02:16:07 <dons> ?users
02:16:07 <lambdabot> Maximum users seen in #haskell: 242, currently: 212 (87.6%), active: 7 (3.3%)
02:16:08 <emu> ?type join
02:16:09 <dons> for example
02:16:10 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
02:16:12 <newsham> can I define propAssoc and use quickCheck on it afterwards?
02:16:17 <dons> nope
02:16:20 <falconair> Cale, I'm not actually interested in putting html or sql in my haskell file, i'm just curious if one could 'import' some syntax definition and change the syntax of the language being used (so the 'kernel' language could be in something like scheme, but a veil of syntax could be put over it)
02:16:27 <dons> there's no state for @eval or @check (yet)
02:16:49 <newsham> falcon: haskell has much more mallable syntax than most languages.
02:16:56 <newsham> but not infinitely so.
02:17:25 <dons> Cale: can you think of anything interesting to try to check with @check ?
02:17:26 <falconair> so is there a theoretical reason why one couldn't get 'infinitely malliable' syntax?
02:17:33 <Cale> falconair: You can't create arbitrary syntax, but the ability to define new monads makes up for lots of that
02:17:47 <dolio> Anyway, I think part of the problem is that generating the memoized lists is slower in Haskell than it is using arrays in imperative languages.
02:17:48 <Cale> astrolabe: I don't think so...
02:18:01 <dons> dolio: so use arrays then :)
02:18:04 <newsham> falconair:  off the top of my head -- you'd want different lexing rules in certain contexts.
02:18:05 <astrolabe> Thanks.  I thought we'd crashed you :)
02:18:07 <Cale> astrolabe: though there is an arithmetic derivative you could try :)
02:18:25 <emu> @check \n -> map (n+) . floor $ sqrt n
02:18:26 <lambdabot>  add an instance declaration for (Testable [a])     In the definition of `im...
02:18:27 * astrolabe googles
02:18:27 <newsham> as far as I know haskell doesnt let you tweak the language lexing rules
02:18:30 <dolio> dons: What kind? STArray?
02:18:39 <dons> STUArray?
02:18:51 <Cale> astrolabe: however, I don't think it's practical
02:18:53 <dons> ?help check
02:18:53 <newsham> also haskell lets you make minor changes to syntax, but not larger scale changes...
02:18:54 <lambdabot> check <expr>
02:18:54 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
02:19:12 <Cale> astrolabe: afaik, the arithmetic derivative is at least as hard to compute as factoring the number
02:19:13 <newsham> ie. I cant define a nested context where you coul dhave different operator associativities (I dont think)
02:19:22 <newsham> in theory I dont see why one couldnt make something like that
02:19:28 <newsham> but I havent heard of any languages doing that
02:19:30 <astrolabe> Cale: hmmm thanks.
02:19:53 <Cale> p' = 1 if p is prime, (nm)' = n' m + n m'
02:20:03 <falconair> newsham: couldn't a preprocessor be run before the compiler does a type check?  it seems like an obvious thing for someone to try to figure out, are there any papers I can read on this?
02:20:41 <dons> there's a wide range of DSL preprocessors for haskell code
02:20:46 <dons> harp, for example
02:20:56 <dons> even lambdabot has one for defining a few custom keywords
02:21:03 <newsham> if you're writing a preprocessor anything's possible :)
02:21:04 <dons> keyword: plugins , for example
02:21:09 <newsham> but thats a separate parser.
02:21:29 <newsham> you seem to be asking for a parser that changes the way it parses based on what has been parsed so far.
02:21:46 <newsham> i've not heard of such a thing (not a proof of non-existance :)
02:21:46 <Cale> astrolabe: I suppose that doesn't really agree with the usual differentiation if you defined it that way for polynomials.
02:21:54 <profmakx> i wonder if anyone is doing something in the lines of frag still?
02:22:07 <emu> @check \n -> n + (floor $ sqrt n)
02:22:08 <lambdabot>  Add a type signature
02:22:15 <dons> emu, what are you checking?
02:22:21 <dons> it needs to be an expression in Testable
02:22:33 <emu> hm kept thinking @check was typecheck
02:22:33 <dons> ?instances-importing Test.QuickCheck Testable
02:22:34 <lambdabot> (), (a -> b), Bool, Property, Result
02:22:48 <dons> so a Boolean expression, or a Property or so on
02:22:53 <dons> ?check True
02:22:54 <lambdabot>  OK, passed 1000 tests.
02:22:56 <newsham> @check \a b -> a ** (b :: Int) == b ** a
02:22:56 <lambdabot>  add an instance declaration for (Floating Int)
02:22:59 <profmakx> more like model-checking isnt it?
02:23:11 <dons> ?check \a b -> a ** (b :: Int) == b ** (a::I)
02:23:12 <lambdabot>  add an instance declaration for (Floating Int)
02:23:15 <emu> actually i'm kinda curious about number overloading... ie: f n = n + (floor $ sqrt n)
02:23:20 <dons> oh, Floating.
02:23:29 <newsham> ?check \a  b -> a + b == b + (a :: Int)
02:23:30 <lambdabot>  OK, passed 1000 tests.
02:24:11 <emu> so I have to insert fromIntegral in front of n?
02:24:12 <Saulzar> You can make a parser which changes depending on what has parsed so far, parsec for example stores a state ... you could put another parsec parser as the state
02:24:22 <Cale> ?check \a b -> False
02:24:22 <lambdabot>  Add a type signature
02:24:37 <emu> > let f n = n + (floor $ sqrt n) in f 5
02:24:38 <lambdabot>  Add a type signature
02:24:38 <Cale> ?check \(a :: Int) -> False
02:24:39 <lambdabot>  Parse error in pattern
02:24:48 <dons> no pattern type sigs in h98
02:24:51 <Cale> ?check (\a -> False) :: Int -> Bool
02:24:52 <lambdabot>  Falsifiable, after 0 tests: 1
02:25:01 <Cale> ah, it stops immediately
02:25:01 <emu> > let f n = fromIntegral n + (floor . sqrt $ fromIntegral n) in f 5
02:25:02 <lambdabot>  7
02:25:06 <gour> @where paste
02:25:07 <lambdabot> http://paste.lisp.org/new/haskell
02:25:07 <newsham> saulzar: but a parser which, for example, adds a new alternative to S -> if e then e else e | ... | .    ?
02:25:31 <newsham> first of all, the programmer woul dhave to know about all of the existing grammar to be able to add to it
02:25:40 <newsham> and 2nd he would have to be able to hook in where he wants
02:25:54 <newsham> and one alteration to the grammar might interact with another's
02:25:54 <Cale> ?check (const False) ==> True
02:25:55 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Bool,  ...
02:26:09 <Saulzar> newsham, I haven't been following the conversation so I have no idea what that's about :)
02:26:10 <Cale> ?check (const False) ==> (\x -> True) :: Int -> Bool
02:26:11 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Bool,  ...
02:26:16 <Cale> ?check (const False) ==> ((\x -> True) :: Int -> Bool)
02:26:16 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Bool,  ...
02:26:18 <Cale> er
02:26:23 <Cale> oh right
02:26:28 <dons> ?check \s -> (not . null $ s) ==> s == reverse (s::T)
02:26:29 <lambdabot>  Falsifiable, after 2 tests: [-2,-3]
02:26:32 <newsham> (also, the lexer would have to be handled by the parser so that different lexing rules could be applied in their proper contexts)
02:27:07 <newsham> parsers are pretty complicated beasts..
02:27:25 <Saulzar> newsham, You could grab the parser for "S" from the state and use that, and modify it as you go...
02:27:28 <Cale> ?check \x -> False ==> x == reverse x
02:27:29 <lambdabot>  Add a type signature
02:27:34 <newsham> it might occasionally be easy to extend one part of its grammar (ie. adding expression operators)
02:27:36 <Cale> ?check \x -> False ==> x == reverse (x :: Int)
02:27:36 <lambdabot>  Couldn't match `Int' against `[a]'
02:27:43 <Cale> ?check \x -> False ==> x == reverse (x :: [Int])
02:27:44 <lambdabot>  Arguments exhausted after 0 tests.
02:27:44 <dons> type T = [Int]
02:27:46 <Saulzar> parsec does both lexing and parsing, so you're ok there too..
02:27:49 <newsham> but changing arbitrary parts of the grammar is a lot more complex
02:27:59 <Saulzar> Hmmm
02:28:49 <newsham> saulzer: ok, so the current state in the parser has the current parser in it, I extract that, and how do I add my statement into that huge parser monad thingamajig?
02:29:08 <newsham> especially if my modifications are nested several layers down in that parser?
02:29:31 <Saulzar> newsham, You'd have to make it more fine grained than the whole parser, ie. have the various parts as a record ..
02:29:41 <Saulzar> Then re-construct the pieces needed
02:29:56 <newsham> so then you cant make arbitrary changes, only the changes the framework permits
02:29:59 <Cale> ?check \f g xs -> (map (f . g) xs) == (map f . map g $ xs :: T)
02:30:00 <lambdabot>  Add a type signature
02:30:15 <Saulzar> What do you mean?
02:30:19 <Cale> ?check \f g xs -> (map ((f :: Int -> Int) . (g :: Int -> Int) xs) == (map f . map g $ xs :: T)
02:30:19 <lambdabot>  Parse error
02:30:33 <newsham> i can plug into any of the fine-grained parts of the parser that you expose
02:30:35 <Cale> ?check \f g xs -> (map ((f :: Int -> Int) . (g :: Int -> Int)) xs) == (map f . map g $ (xs :: T))
02:30:38 <lambdabot> Terminated
02:30:40 <newsham> but not any of the finer grained structures
02:31:11 <newsham> (not to mention the grammar might be specially designed to backrack over a few select ambiguities (talking parsec here) and my additions might add new, unforseen, ambiguities
02:31:13 <Saulzar> Right, you're going to have to chose what you want to be able to modify...
02:31:15 <newsham> so my additions might not even work
02:32:05 <newsham> most grammar systems arent very modular.
02:32:25 <Saulzar> Well that's your problem :)
02:32:31 <newsham> ie. making a change to a parsec grammar might require you to make changes all over the place.
02:32:39 <Saulzar> Why do you want such a thing?
02:32:42 <newsham> ditty for LALR(1) (yacc) stuff
02:32:49 <newsham> s/ditty/ditto/
02:33:10 <newsham> scannerless GLR parsers are modular, but adding to them on the fly, I'm not sure how you woul dmake that work
02:33:24 <Saulzar> Hmm... I am not so sure about that, you can keep it fairly modular. There are constructs for handling stuff like left recursion...
02:33:58 <newsham> saulzar:  heh, the lexer in parsec seems very very fragile to me, hardly modular.
02:35:06 <Saulzar> I am sure changing the lexer is much harder than the parser in the case of parsec
02:35:11 <dons> ?check \f g -> map (f . g) xs == map (f::I->I) . map (g::I->I) $ (xs :: T)
02:35:12 <lambdabot>  Not in scope: `xs'
02:35:22 <dons> ?check \f g xs -> map (f . g) xs == map (f::I->I) . map (g::I->I) $ (xs :: T)
02:35:22 <lambdabot>    Expecting a function type, but found `a'       Expected type: [I],      ...
02:35:57 <newsham> ?check \x -> (x :: String) == reverse (reverse x)
02:35:58 <lambdabot>  OK, passed 1000 tests.
02:36:04 <xerox> QuickCheck?
02:36:06 <xerox> (G'day.)
02:36:41 <dons> xerox: yep
02:37:24 <Saulzar> ?check \x -> (x :: Int) < 10000
02:37:25 <lambdabot>  OK, passed 1000 tests.
02:37:36 <musasabi> Is there a good way to avoid the overhead of having lots of Bool fields in a record?
02:38:08 <Saulzar> Well, the C/C++ way is to use bitmasks...
02:38:28 <dons> ?check \f g xs -> (map (f . g) xs) == (map (f::I->I) . map (g::I->I)) (xs :: T)
02:38:31 <lambdabot>  OK, passed 500 tests.
02:38:36 <musasabi> yes, but I'd like a nice way. Of course accessors are easy - but record updaters are nice too.
02:38:41 <Saulzar> Weather that is deemed "good", I am not sure :)
02:39:08 <dons> whether the weather is good for the wether, i'm not sure
02:39:38 <newsham> flag r x = (flags r) & (1 `lshift` fromEnum x) ?
02:39:47 <newsham> and make an enum for all your bools?
02:39:51 <Saulzar> Haha, I thought that looked wrong.
02:39:58 <newsham> err add ina "!= 0" in there
02:43:35 <lokadin> i imported System.IO but it's telling me that getStrLn is not in scope
02:44:03 <lokadin> :(
02:44:09 <xerox> ?index getStrLn
02:44:09 <lambdabot> bzzt
02:44:14 <xerox> ?index readLine
02:44:14 <lambdabot> bzzt
02:44:18 <xerox> ?index readLn
02:44:18 <lambdabot> System.IO, Prelude
02:44:53 <lokadin> >import System.IO
02:44:53 <lokadin> >
02:44:53 <lokadin> >main = do
02:44:53 <lokadin> >   ln <- getStrLn
02:44:54 <lambdabot>  Parse error
02:46:00 <xerox> Where do you see getStrLn defined?
02:46:16 <dons> who sees that, not me?
02:46:28 <lokadin> defined?
02:46:32 <dons> ?hoogle get
02:46:33 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
02:46:33 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
02:46:33 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
02:46:40 <dons> ?hoogle+
02:46:40 <lambdabot> CPUTime.getCPUTime :: IO Integer
02:46:40 <lambdabot> Directory.getCurrentDirectory :: IO FilePath
02:46:40 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
02:46:41 <xerox> @docs System.IO
02:46:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
02:46:46 <dons> too many gets
02:47:12 <xerox> lokadin: see 'Special cases for standard input and output'
02:48:08 <lokadin> is that the link? kk i'll go look
02:50:16 <lokadin> oh man, it's getLine
02:50:28 <lokadin> .oiro'a
03:15:15 <xerox> ski <http://golem.ph.utexas.edu/category/2006/08/cartesian_closed_categories_an.html>
03:15:15 <lambdabot> http://golem.ph.utexas.edu/category/2006/08/cartesian_closed_categories_an.html>
03:17:49 <flux__> bug?
03:19:14 <xerox> ski: in fact there is more if it interests you...
03:20:00 <xerox> http://golem.ph.utexas.edu/category/2006/08/cartesian_closed_categories_an_1.html
03:20:03 <lambdabot> Title: CCCs and the &lambda;-calculus | The n-Category Caf&#xE9;, http://tinyurl.com/onj2n
03:25:54 <tibbe> perhaps a little bit OT: If a relation R is reflexive does that also imply that it's symmetric?
03:26:26 <profmakx> i doubt it
03:26:53 <profmakx> why would one then want to have refelexiveness and symmetry for equivalence relations?
03:27:10 <profmakx> *runs for coutnerexample*
03:27:22 <deadbeef> ordering relations are reflexive but not symmetric
03:27:32 <profmakx> hmm
03:27:37 <profmakx> at least less than
03:27:46 <profmakx> theyre antisymmetric and reflexive
03:27:53 <deadbeef> yes
03:28:00 <xerox> @slap deadbeef
03:28:00 <lambdabot> why on earth would I slap deadbeef
03:28:08 <deadbeef> omg teh slap!!!!11
03:28:16 <xerox> Silly :P
03:37:37 <edwardk> tibbe: no
03:38:09 <edwardk> tibbe: every partial ordering is reflexive, transitive and ANTI-symmetric for instance =)
03:39:14 <edwardk> woops
03:39:22 <edwardk> didn't see the above response. window was scrolled up
03:40:07 <tibbe> edwardk: I think I meant to ask the opposite question.  Does symmetry imply reflexiveness?
03:41:26 <edwardk> tibbe: nah. say { 0 <-> 1, 1 <-> 0 } 0 <-> 0 and 1 <-> 1 are both not present
03:41:55 <edwardk> symmetry and transitivity together might though, haven't thought about it
03:42:05 <edwardk> yeah
03:42:11 <edwardk> that should hold
03:42:31 <edwardk> coz if a -> b, then b -> a by symmetry so a -> a by transitivity
03:42:42 <edwardk> so if you are both symmetric and transitive you are reflexive
03:42:58 <edwardk> but symmetric alone isn't sufficient
03:44:22 * Cale watches the sun rise
03:44:33 <edwardk> don't remind me, Cale ;)
03:44:41 <Cale> And I *have* gone to sleep!
03:44:43 <edwardk> I have so much to do today
03:44:48 <edwardk> me neither ;)
03:45:22 <Cale> A few days ago I was staying up this late
03:45:39 <Cale> but it seems I managed to turn my hours around
03:45:50 <edwardk> *nods*
03:46:14 <edwardk> itting here trying to apply all the stuff i learned about substructural logic to my original goal of a substructural pure type system.
03:46:29 <edwardk> funny how well everything fits together once you have a better perspective.
03:47:12 <Codex_> substructural pts? What does substructural bring to it?
03:47:34 <edwardk> codex: linearity, affinity, relevance, etc. so you can say more about the usage of the types and terms
03:48:20 <edwardk> codex: er and uniqueness typing, coz i've unified that into my notion of substructural types
03:49:02 <Codex_> does it preserve strong normalisation?
03:49:15 <edwardk> codex: building it up over a PTS^{<=}, not just a PTS, because then dereliction, etc. emerge as a natural consequence of the subtyping relation.
03:49:37 <edwardk> codex: so far so good. I'm still in the process of the formal proof but it appears to hold so far.
03:50:34 <edwardk> codex: i've been going all the way back to the early geuvers et al, and berendregt papers on PTSs and their early proofs of the properties they hold.
03:51:03 <edwardk> codex: very little really depends on how the context is split.
03:51:37 <edwardk> codex: and i can split contexts algoorithmically borrowing a trick from Walker and adapting it to a wider class of substructural types.
03:52:54 <araujo> morning!
03:53:11 <edwardk> codex: and it appears to preserve the type-checking property of injective PTSs as well.
03:55:55 <edwardk> codex: and the same proof that weak normalization implies strong normalization for non-dependent PTSs should work, as its also independent of how contexts are split
03:59:35 <Codex_> might be possible, if it only affects context structure, and not mess up the axiom, weakening etc rules
03:59:43 <edwardk> I would like to show that if the Barendregt-Geuvers-Klop conjecture holds for PTSs it would hold here, but I'm not sure
04:00:40 <edwardk> weakening is the only rule adversey affected, but that can be argued as being really part of the manipulation of contexts. I allow weakening in a more limited set of scenarios.
04:04:24 <edwardk> an interesting result is that by the PTS formallation a straightforward translation to substructural types disallows dependent typing where the x in (\x:A.b) : (@x:A.B) is linear unless one of the x's involved there is a _.
04:04:48 <edwardk> er where @ is Pi, like in Yarrow
04:05:17 <Codex_> Pi? not Product?
04:05:20 <edwardk> came up coz of my context split.
04:05:33 <edwardk> Pi x:A.B in classic pure type system.
04:05:36 <edwardk> er context
04:07:09 <edwardk> the reason is i need to split the x between the two \ and @ contexts there, which necessitates contraction. so only if the subPTS allows contraction on that type can it apply.
04:08:32 <edwardk> but  you can still do -> types by _'ing the x in the Pi to get (\x:A.b) : (@_:A.B) which is equivalent to (\x:A.b) : A -> B
04:09:41 <edwardk> or A -o B if you want to be strict about your linear notation.
04:13:27 <edwardk> if nothing else i'll try to prove strong normalization for the lambda cube equivalents
04:16:07 <edwardk> heya esap
04:16:12 <esap> hi
04:16:21 <esap> what's up?
04:16:26 <edwardk> not much
04:16:36 <edwardk> sitting around staring at greek symbols. got bored, came online ;)
04:16:47 <esap> greek symbols?
04:17:36 <edwardk> all that substructural type system stuff i've been on here rambling about the last few weeks ;)
04:18:13 <Codex_> esap: you missed lots of pts stuffs. :)
04:18:30 <esap> I actually read a book that had description about substructural type system stuff recently. Pierce: Advanced Topics in Types and Programming Languages.
04:18:57 <edwardk> esap: yeah walker does a decent introduction to affine, linear and unrestricted types. he glosses over the relevant case though
04:19:44 <edwardk> esap: i've been working on an extended set of substructural types to mix in uniqueness types with those and the work of fluet et al. on lambda^refURAL and linear regions.
04:20:11 * tibbe thinks #haskell is just an alias for #math ;)
04:20:14 <edwardk> heh
04:20:28 <edwardk> tibbe: if you want i can drag this over to #haskell-overflow
04:20:37 <edwardk> I realize its not entirely relevant
04:20:59 <tibbe> no no
04:21:05 <mux> it would be a shame, noone is talking about haskell right now so this is very interesting!
04:21:05 <edwardk> kk =)
04:21:19 <tibbe> it's just that I'm hanging out in both #math and #haskell right now and there are, eh, some similarities
04:21:22 <tibbe> not just now
04:21:24 <esap> edwardk: I'm not familiar with fluet et al. Is it this: http://www.cs.cornell.edu/people/fluet/research/substruct-regions/index.html
04:21:27 <lambdabot> Title: Matthew Fluet -- Linear Regions Are All You Need, http://tinyurl.com/zv334
04:21:46 <edwardk> thats one paper. the other you want is called a 'step indexed model of substructural state' or something like that
04:22:10 <edwardk> the linear regions paper explains why i'm using linear regions for memory management in my little intermediate language though
04:22:31 <edwardk> coz i'm storing substructural types in linearly used regions to avoid garbage collection overhead.
04:23:26 <edwardk> Esa/Tero Pulkkinen, is there a relation?
04:23:37 <Codex_> yup
04:23:38 * esap nods
04:23:39 <edwardk> ah
04:23:54 * esap points at his brother.
04:24:14 <dolio> dons: Thanks for the suggestion. STUArray seems to have cut the time in half (roughly).
04:24:39 <edwardk> esap: so you have an interest in pure type systems?
04:25:05 <edwardk> esap: my interest here is largely practical, but i'd like to generate some nifty theoretical results on the way if possible.
04:25:20 <esap> edwardk: well I'm somewhat interested in them, mostly because they are so simple.
04:25:26 <edwardk> esap: you also might want to read jan zwanenberg's paper on pure type systems with subtyping
04:25:43 <edwardk> coz i'm using that notion to introduce the substructural types in a PTS context.
04:25:44 <edwardk> yeah
04:26:19 <edwardk> my current work started by trying to see what it would take to write a substructural pure type system. i went kinda full circle, and now i'm coming back to the PTS formulation coz its so clean.
04:27:31 <edwardk> I pretty much wandered off to adapting wadler's dual calculus for pattern matching linear logic in the same manner than rudiak-gould, mycroft and peyton jones extended his dual intuitionistic logic to obtain a virtual machine.
04:27:50 <esap> edwardk: I actually ignored substructural type system stuff for long time for my compiler, because I thought I could generalize on it, but I think that approach didn't work
04:28:38 <edwardk> esap: i'm putting together an intermediate language for compiling and an abstract machine to run it on, atm.
04:28:52 <edwardk> esap: have you looked at uniqueness types?
04:29:26 <esap> edwardk: not much. Browsed through the clean spec
04:29:33 <edwardk> esap: they mesh nicely with the traditional substructural types. in particular uniqueness relevant and uniqueness unrestricted types tell you stuff about the past of an object, while traditional substructural types tell you about the future.
04:30:10 <edwardk> esap: so you can take that as another axis on which you can extend your substructural types. you can either introduce a * comonad to your type system for uniqueness or you can extend the lattice of substructural types.
04:30:30 <edwardk> depending on if you want comonads or qualifiers
04:30:40 <esap> edwardk: in Walker's article, it has an interesting comment that "researchers have not found use for other substructural logics than those presented"
04:31:00 <esap> edwardk: which to me sounds like a challenge :-)
04:31:08 <edwardk> esap: well, he's wrong, at least now. since i have extended his set of 4 to 9 quite readily ;)
04:31:20 <edwardk> er.
04:31:32 <edwardk> well his core 4, ignoring the ordered and reference counted types
04:31:47 <edwardk> the linear, relevant, affine, and unrestricted types.
04:32:54 <esap> edwardk: right. When I read that choice, it appeared to me that they chose the substructural logics to use based on the multiplicity constraints on how many times variables can be used.
04:33:16 <edwardk> if you add uniqueness, you get a very different notion of a singleton reference to an object. that gets you to 6. if you adopt the lambda-refURAL folks' model in spirit it suggests a more limited notion of affinity for strict type containment, which gives you a total of 9 types in a lattice that is a lattice product of two lattices containing 3 concepts each.
04:35:35 <edwardk> esap: so my current qualifier list looks something more like { forgettable, destructable, strict } x { new, contractable, unique } where linear = strict unique, unrestricted = forgettable contractable, clean uniqueness = forgettable new, affine = forgettable unique, and relevant = strict contractable
04:37:20 <edwardk> and F->D, F -> S, D -> S  and N->C, N->U, C->U are the two lattices/categories, in which all initial arrows in {N,C,U} lattice are free to perform (C->U requiring copying), and all terminal arrows in the {F,D,S} lattice require evaluation.
04:38:19 <edwardk> that way the underlying substructural types give you a model for mixing lazy and strict evaluation, because relevance/strictness analysis is implicit in the typing
04:38:24 <xerox> esap, edwardk, maybe it could be of interest to you http://golem.ph.utexas.edu/category/2006/08/cartesian_closed_categories_an_1.html
04:38:27 <lambdabot> Title: CCCs and the &lambda;-calculus | The n-Category Caf&#xE9;, http://tinyurl.com/onj2n
04:39:57 <esap> xerox: hmm.. baez has done discussion on CCCs, hmm.. interesting...
04:40:15 <xerox> Yep. More on the n-category caf√®.  Like this one:
04:40:19 <edwardk> xerox: the categorical derivation gets rather hairy once you add in substructural types, you aren't talking about a CCC any more you are dealing with an SMCC and various comonads
04:40:23 <xerox> http://golem.ph.utexas.edu/category/2006/08/cartesian_closed_categories_an.html
04:40:25 <lambdabot> Title: Categories and Computation | The n-Category Caf&#xE9;, http://tinyurl.com/zjfep
04:42:32 <esap> I attempted to understand coexponentials for a long time before I found a paper that explained them well, and how they relate to semantics of programming languages, e.g. coroutines.
04:43:28 <edwardk> *nods* i've been mostly dealing with them implicitly through the value/continuation duality, not directly.
04:45:10 <esap> there is all kinds of trouble there, because coexponentials have a habit of causing the logic to become degenerated.
04:45:14 <edwardk> yeah
04:45:23 <edwardk> if you have exponentials and coexponentials you are poset
04:45:53 <esap> crolard has good papers about that
04:45:59 <edwardk> any bi-[CCC] is a partial order, etc.
04:46:29 <edwardk> searching to see if they are in my 'have read' pile =)
04:46:55 <esap> Crolard: Subtractive logic  is a must read. As is the followup paper.
04:47:12 <edwardk> yeah read those
04:47:26 <edwardk> found it in my cite-u-like listing from before i gave up keeping it up to date
04:49:13 <edwardk> esap: on a more pragmatic note have you read the wadler call-by-value is dual to call-by-name and the gould, mycroft, peyton jones paper on 'haskell is not not ml'?
04:49:57 <esap> edwardk: I've read the wadler's paper, but I'm not sure about the other one.
04:50:10 <edwardk> the latter presents the notion of duality i've been employing in a substructural context, coz its also very simple.
04:50:59 <edwardk> and seems to mesh well with the PTS ideals. i've been trying to deriving a Pi equivalent in that style of calculus.
04:51:19 * esap goes to read the paper...
04:51:21 <edwardk> its a little funny coz of the limitation that functions can never return basically. its a pure CPS formulation of values and continuations
04:51:30 <edwardk> read it, put it aside, read it again later ;)
04:51:44 <edwardk> there are some pretty deep ideas buried in it that aren't obvious on first reading
04:51:52 <edwardk> and aren't explicitly stated
04:53:29 <dmwit> I have a question about something I just saw in Tackling the Awkward Squad.
04:54:06 <dmwit> They define a function forever a = a >> forever a
04:54:20 <edwardk> k
04:54:33 <dmwit> If you actually put this in a program and used it, would you ever have to worry about running out of (stack) space?
04:56:18 <edwardk> hrmm trying to think of where a monad there wouldn't result in a tail call.
04:56:21 <edwardk> it seems to be safe
04:56:25 <dmwit> I ask because I remember when I was learning about recursion in C I often overran the stack...
04:56:39 <edwardk> dmwit: do you know about tail-call optimization?
04:56:52 <edwardk> dmwit: that should always result in a tail-call
04:56:53 <dmwit> edwardk: No, tell me about it.
04:57:26 <edwardk> dmwit: ok. in haskell if the last thing a function does is return the value of another function, then it knows that the current stack frame is irrelevant to the result, so it collapses it
04:57:40 <dmwit> Oh, okay.
04:57:46 <edwardk> dmwit: therefore you can do infinite recursion safely, as long as the last thing you do is return the result of another function.
04:57:59 <wkh> tail-recursive algorithms are equivalent to iterative code so they can be automatically transformed
04:58:07 <dmwit> Nice. Thanks.
04:58:17 <tibbe> @localtime dons
04:58:20 <lambdabot> Local time for dons is Sun Sep 10 21:57:56 2006
04:58:42 <wkh> if you've ever seen functions with an "accumulator variable" as a parameter it was probably tail-recursive
04:58:43 <edwardk> and note its any tail-call, not just tail-recursion.
04:58:53 <wkh> meh
04:58:59 * wkh should go to bed
04:59:00 <dmwit> edwardk: Yeah, that's good.
04:59:00 <edwardk> so you can call any function as the last thing you do =)
04:59:05 <wkh> @localtime wkh
04:59:07 <lambdabot> Local time for wkh is Sun Sep 10 04:58:18 2006
04:59:09 <wkh> o_O
05:00:07 <edwardk> dmwit: lack of tail recursion requires you to jump through lots of hoops to emulate it when compiling down to a language that doesn't have it. i've had to do something of the sort with javascript which lacks it =(
05:00:35 <dmwit> ...
05:00:36 <edwardk> er lack of tail-call-optimization i should say
05:00:42 <dmwit> You compile Haskell to Javascript?
05:01:11 <edwardk> i compile javascript to javascript via a continuation passing style transformation, so i can emulate blocking and threading
05:01:23 <dmwit> =P
05:01:45 <edwardk> haven't gotten around to writing a haskell->javascript compiler yet =)
05:03:11 <edwardk> though in all honesty the buk of it should be doable in a pretty straightforward manner translating spineless tagless g-machine code to javascript (where the STG stuff refers to the intermediate code that GHC generates before it generates C) -- that is if it was easier to get at the STG output from GHC =(
05:04:10 <dmwit> I am so out of my league in this room... =)
05:04:26 <edwardk> dmwit: don't worry you'll catch up fast =)
05:04:51 <edwardk> I barely knew what haskell was 2 months ago ;)
05:05:50 <dmwit> Well, I have one month to start writing Haskell->Javascript compilers, then... =D
05:06:33 <dmwit> Also, there are far too many smilies flying around here.
05:06:38 <dmwit> It was the best of times. :)
05:06:42 <edwardk> probably =)
05:06:43 <dmwit> It was the worst of times. :(
05:07:23 <gour> @where hIDE
05:07:23 <lambdabot> http://haskell.org/haskellwiki/HIDE
05:08:58 <profmakx> i just realized how much my advanced logic lectures pay off ^^
05:09:05 <edwardk> prof: ?
05:09:23 <profmakx> well
05:09:49 <profmakx> like what "Types" have to do with it for example
05:09:54 <edwardk> ah
05:10:01 <profmakx> sometimes i am quite slow at realizing such things
05:10:23 <edwardk> I really wish I had actually had them presented to me in a classroom context some times.
05:10:25 <profmakx> hmm and that with some construct in mathematical logic called "type"
05:10:34 <edwardk> I just have picked up what I've needed as I've gone along.
05:11:01 <profmakx> i actually did one of my diploma-exams on mathematical logic
05:11:10 <edwardk> nice
05:11:32 <profmakx> model-theory, infinitary logic and so on
05:11:45 <edwardk> my math background couldn't really be much farther from type theory if I tried ;)
05:12:12 <profmakx> yeah ;) geometry not being too close to logic ;)
05:12:13 <spiffy> my math background is highschool calculus, and one day of MATH 1000 (so far)
05:12:59 <edwardk> prof: heh, well, we have 'affine' logics. now i just want a projective one ;)
05:13:22 <profmakx> ;)
05:13:42 <edwardk> er though i guess you could make a case that once you move to pretty much any bi-<whatever> logic its taken on a lot of projective qualities.
05:15:04 <edwardk> I really really want to find a use for bi-lambek or non-commutative bi-linear logic, just so i can play around with an environment with two dualities, that combine to net me 4 proofs for every proof ;)
05:15:22 * edwardk <<3 dualities.
05:18:04 <edwardk> spiffy: math isn't bad once you let go of being afraid of it. Most people just decide they are bad at math and shy away from it.
05:18:22 <profmakx> edwardk, me concur
05:20:05 <spiffy> edwardk: O I enjoy calculus, just havent had much experience yet
05:20:08 <edwardk> but, unlike most disciplines mathematics pretty much has a constant difficulty level as you proceed. Most disciplines tend to be fairly shallow. Learning math feels like a constant uphill climb on a slope with constant gradient. If you enjoy that sort of thing, well, the view as you get higher can be pretty nice. =)
05:20:51 <spiffy> I had a really good intro to calc teacher who basically drilled that same idea into us ;-)
05:21:00 <edwardk> You just seem to lose the ability to communicate with normal people I guess ;)
05:21:04 <edwardk> glad to hear it
05:21:16 <profmakx> i hate calculus ^^
05:21:22 <profmakx> im more the discrete type
05:22:32 <edwardk> Most people stop with calculus, then think thats all there is to mathematics. Calculus is really just a lab in which you can explore a lot of ideas of convergence, etc in a physically applicable setting, since its needed to really understand physics its early in the cirriculum. Calculus as done at the intro college level is very poor 'mathematics' coz all you are doing is applying tools you are given, not proving anything about their 
05:23:34 <astrolabe> I find it higher maths more difficult, and more difficult to find the information about.
05:24:40 <edwardk> astrolabe: sure, but its a different kind of difficult. Calculus in the end turns into one long series of exercises of 'guess how the instructor constructed this integral' ;)
05:25:16 <edwardk> People get a culture shock when they leave that and go on to do proofs.
05:25:33 <profmakx> hmm that not like that here, edwardk
05:25:38 <astrolabe> I found maths go easier when I went to university
05:25:42 <edwardk> Fair enough
05:25:52 <profmakx> i remember some fairly tricky proofs in calculus in my first semesters
05:25:55 * spiffy was forced to do extremely basic proofs in highschool calc, just to let us know they existed
05:25:59 <astrolabe> but others found the abstraction very hard
05:26:08 <edwardk> prof: maybe it was just the presentation I encountered.
05:26:14 <lokadin> how can i check if a [String] contains a certain String abu
05:26:29 <astrolabe> @type elem
05:26:29 <profmakx> might be, edwardk there are different kinds of lecturers
05:26:30 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:26:54 <lokadin> astrolabe: thanks
05:27:48 <edwardk> prof: and in my case, the first college i did calc at was an engineering college and the second was a 'teaching' college. Neither of which is big on proof.
05:27:54 <astrolabe> Wheras, at school, I couldn't be bothered with all the different trig formulas, methods of integration etc.
05:28:24 <edwardk> I never did take trig, so I wound up having to rederive it. =/
05:28:30 <astrolabe> :)
05:30:00 <edwardk> to this day i tend to work with dot products or complex numbers, then tear things apart into sines and cosines, just because they are more familiar tools. was hell when i got to fourier analysis at first
05:30:08 <dons> tibbe: you looking for me?
05:30:49 <tibbe> dons: well, kinda, have you tried to compile lambdabot using 6.6? (lambdabot is your creation right?)
05:31:03 <tibbe> dons: I'm having FPS problems
05:31:05 <dons> tibbe: yep and yep
05:31:16 <dons> can I guess the answer for you? :)
05:31:21 <tibbe> sure
05:31:25 <dons> s/fps/regex-compat/ in the .cabal file :)
05:31:40 <dmhouse> Okay all, I need advice. The context: I'm going to be teaching a course on Haskell from Thursday, but nothing too deep, it's only half an hour once a week.
05:31:46 <tibbe> dons: thanks, I'll give it a try
05:31:46 <int-e> and delete the >=0.7 (or is that gone?)
05:31:52 <dons> tibbe: and in fact, i checked in a new lambdabot.cabal.ghc-6.6 which should have this
05:32:01 <dons> int-e, there should be no fps dep at all now
05:32:06 <dons> since its really a dep on base
05:32:12 <int-e> I know, I know.
05:32:15 <tibbe> dons, I'll check it out
05:32:23 <dons> int-e, ah sorry. i see what you mean
05:32:41 <dons> s/fps >= 0.7/regex-compat/
05:33:13 <dmhouse> The first lesson will be giving out some notes, seeing how many people we have, checking out people's backgrounds (how many people do maths? How many people have programmed before?), etc., but I'd like to get people excited about the course if possible.
05:33:30 <dmhouse> Is there some nice Haskell that people would recognise even if they're non-programmers?
05:33:51 <dons> hmm, something from 'the haskell road to maths and logic" ?
05:34:24 <dons> ?check \a b -> (a < 0 && b > 0) ==> a `rem` b == a `mod` (b :: Int)
05:34:24 <dmhouse> Don't have that book, any specific algorithm recommendations?
05:34:25 <lambdabot>  Falsifiable, after 1 tests: -1, 2
05:34:59 <xerox> dmhouse: you could do L-Systems :D
05:35:14 <dons> that's not a bad idea.
05:35:17 <dmhouse> xerox: hey, nice idea.
05:35:25 <tibbe> dons, um, did a need to do some s// replace or not?
05:35:33 <dmhouse> xerox: are the system specifications expressed in Haskell?
05:36:01 <dons> tibbe: yep. you need to remove the fps depenednecy, and add a regex-compat dependency (or else use lambdabot.cabal.ghc-6.6)
05:36:26 <xerox> dmhouse: You need a bit of parsec, but it's quite easy. I don't know exactly how dcoutts did it.
05:36:45 <dmhouse> dcoutts_: ping?
05:37:14 <xerox> You need to parse things like "A -> AB" for deterministic l-systems.
05:37:54 <xerox> [(1%2,"A -> A+A"),(1%2,"A -> AB")] for non-deterministic ones.
05:38:16 <xerox> (At which point MonadRandom is VERY handy.)
05:40:38 <dmhouse> Any other ideas?
05:40:45 <Cale> You can actually write the lsystem expansion algorithm generalised over the monad.
05:41:22 <foxy_> dmhouse: lambda interpreter
05:41:31 <Pupeno> Good morning.
05:41:41 <dmhouse> foxy_: won't mean much to someone who doesn't know what the lambda calculus is.
05:41:52 <Cale> Oh, I didn't see the question :)
05:41:56 <xerox> Cairo drawings are surely more exciting than lambda expressions :P
05:42:01 <Pupeno> Anyone using Emacs 22.0.50 or close to it ?
05:42:21 <wkh> oh, snap, son
05:42:21 <dmhouse> Pupeno: "23.0.0.2" is mine
05:42:22 <wkh> http://www.woodpecker.org.cn:9081/doc/Python/_PDF/Manning.Publications.wxPython.in.Action.Mar.2006.pdf
05:42:25 <lambdabot> http://tinyurl.com/eopry
05:42:30 <wkh> ^________^
05:42:47 <Pupeno> dmhouse: that might be too different.
05:43:59 <Cale> What's with the whole emacs version number thing? I've heard that it can become a bit of a religious issue :)
05:44:35 <dons> they need to switch to ipv6 naming ;)
05:44:47 <xerox> Does it happen with GHC versions too?
05:44:57 <Pupeno> Cale: I am just trying to find out if anybody is using this same version of Emacs with some haskell-mode succesfully, and if so, what version of haskell-mode. Because here the indentation is so broken than it is useless (I am using the space bar to indent).
05:45:08 <Pupeno> dons: hehehe.
05:45:15 <Cale> Pupeno: switch to using simple-indent
05:45:17 <dmhouse> Pupeno: do you know how indentation in haskell-mode is meant to work?
05:45:26 <Pupeno> dmhouse: yes.
05:45:31 <dmhouse> Pupeno: keep pressing tab to cycle through the possible tab stops.
05:45:43 <Cale> Pupeno: you get a choice during installation between simple and smart indenting, I just pick simple
05:45:55 <dmhouse> Smart works good for me.
05:46:01 <Pupeno> dmhouse: I know that, here, tab insert spaces where the cursor is up to the next tabstop or something like that, it doesn't indent anything.
05:46:02 <Cale> The smart indenter often doesn't have the indents that I want
05:46:40 <Pupeno> Cale: I think my problem is beyond simple/smart.
05:46:52 <cm> genius indent
05:46:56 <xerox> I've just found a CD-RW with some code from 2002 that I have written...
05:47:03 <xerox> ...guess what? It's inline ASM in C sources.
05:47:04 <Cale> What exactly is the problem?
05:47:13 <Cale> er
05:47:55 <dmhouse> xerox: eww. Eww. Eww.
05:48:04 <xerox> O_o
05:48:11 <Pupeno> Cale: tab inserts whitespaces in the coursor/point up to the next tab stop, it doesn't indent.
05:48:18 <astrolabe> I bet it was fast though
05:48:25 <dmhouse> Why am I looking at a PDF about wxPython?
05:48:28 <Cale> Pupeno: isn't that the definition of indenting?
05:48:32 <Cale> Pupeno: hehe
05:48:46 <Pupeno> Cale: no.
05:48:47 * dmhouse needs to stop clicking every link posted into the channel
05:48:51 <Cale> Pupeno: what's the 'next tab stop'?
05:49:03 <Cale> does it vary depending on the line above?
05:49:17 <Cale> Or is it always the same?
05:49:53 <Pupeno> Supouse I have the line "(o,n,[]  ) -> if el|em Help o" where | is the cursor, I press tab and I get "(o,n,[]  ) -> if e              |lem Help o"
05:50:09 <Pupeno> but, I think I've found a document that I should have read.
05:50:12 <tibbe> dons: so move lambdabot.cabal.ghc-6.6 lambdabot.cabal basically, what about the .cabal.plugins file, what's that?
05:50:28 <Cale> Pupeno: what's wrong with that?
05:50:44 <Cale> Pupeno: though that's a few too many spaces for me :)
05:51:14 <int-e> it's not how autoindent usually works in emacs
05:51:34 <Pupeno> Cale: what's wrong ? it is not indenting, it is inserting spaces, in-place.
05:52:04 <edwardk> hrmm. does anyone know if there is any formal development or presentation of substructural data structures and algorithms out there?
05:52:08 <Cale> I'm used to that behaviour. What if I want to indent part of a line which is not at the start of the line?
05:52:22 <dmhouse> Cale: that's not 'indentation', then.
05:52:29 <Cale> dmhouse: sure it is :)
05:52:32 <Pupeno> Cale: what if I want to just indent a line... I can't!
05:52:44 <Cale> Pupeno: hit home first :)
05:52:52 <edwardk> i.e. for showing what the improved time bounds are once you get substructural optimizations on some traditional functional data structures?
05:53:14 <Pupeno> Cale: in home, it does the same: insert a ton of whitespaces without regarding the structure of the code above in any way. Besides I configured emacs to always indent.
05:53:45 <Pupeno> ok, I think I solved it.
05:54:07 <dons> tibbe: don't need the .plugins file
05:54:14 <int-e> Pupeno: I have to explicitely turn it on, using turn-on-haskell-indent in the haskell-mode-hook.
05:54:18 <dons> so yep, just move lambdabot.cabal.ghc-6.6 lambdabot.cabal
05:54:36 * dons $ sleep
05:54:44 <int-e> Pupeno: I'm sure that's documented somewhere, but I forgot where.
05:54:49 <Pupeno> int-e: yes, somehow in haskell-mode 1.x it was more automatic than in 2.1.
05:57:12 <dmhouse> haskell.org down?
05:58:06 <Jaak> works here
05:58:10 <gour> dons: haskell-src-exts is showstopper for building hs-plugins (&co.)
05:58:55 <dmhouse> Jaak: huh. Really?
05:58:57 <dmhouse> Anyone else?
05:59:39 <kfish> works for me
06:01:37 <Pupeno> works from here as well.
06:04:38 <dmhouse> Seems to be working now.
06:04:48 <edwardk> @tell esap do you recall what the coexponential/coroutine paper you mentioned earlier was titled?
06:04:48 <lambdabot> Consider it noted.
06:09:31 <esap> edwardk: "Crolard: A Formulae-as-Types Interpretation of Subtractive Logic"
06:09:31 <lambdabot> esap: You have 1 new message. '/msg lambdabot @messages' to read it.
06:10:26 <esap> edwardk: The other paper was the "Crolard: Subtractive logic". Both are very nice papers.
06:10:45 <edwardk> esap k
06:10:54 <edwardk> esap: wasnt sure if it was from something else
06:11:03 <edwardk> esap: have read those =)
06:11:20 <edwardk> esap: did you get a chance to read the IL/Not not ML paper
06:11:20 <edwardk> ?
06:11:31 <esap> edwardk: Yes, I read it.
06:11:41 <edwardk> esap: any initial reaction?
06:13:11 <edwardk> esap: i've basically taken that and modified its duality to work for wadler's 'down with the beauracracy of syntax' pattern matching linear logic paper.
06:13:40 <edwardk> esap: then changed substructural type systems to the broader class i mentioned before
06:13:49 <edwardk> rather than one with a single ! modality
06:14:24 <Pupeno> lisppaste2: url
06:14:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:14:25 <esap> edwardk: The interesting part of the paper was clearly how they didn't use function types, and substituted with negation.
06:14:34 <edwardk> esap: yeah =)
06:14:54 <edwardk> esap: thats why i'm rather fond of it. the clean CPSification of everything
06:15:26 <lisppaste2> Pupeno pasted "Possible indentantions according to haskell-mode" at http://paste.lisp.org/display/25764
06:15:32 <edwardk> esap: i've been trying to apply the same transformation in a PTS context this evening
06:15:44 <edwardk> esap: coz it drastically changes the shape of a PTS.
06:15:52 <Pupeno> There I have the two possible indentations offered by haskell-mode, I believe the right one is the third, am I wrong ?
06:16:40 <edwardk> now Pi isn't needed in its original form, coz (\x:A.B) always returns a ~A, since B must be of type 0.
06:16:47 <esap> edwardk: I'm thinking this stuff should be combined with the second negation from 'Subtractive logic'. E.g. dualize the continuation stuff.
06:16:49 <lokadin> anyone know where i could go to discuss interface design ideas?
06:17:05 <lokadin> sorry a lil offtopic
06:17:10 <lokadin> maybe i should ask in freenode
06:17:29 <edwardk> i'm kinda leery there. there are heyting vs. classical connotations involved there that bug me.
06:19:53 <esap> edwardk: yea, it might result in degenerate system.
06:19:59 <edwardk> you basically would wind up with the same Bi-[CCC] problems that crolard mentioned I think, and I really want a non-degenerate system
06:20:24 <edwardk> A -> ~~A, but not ~~A -> A. You can only colift ~~~A -> ~A.
06:21:01 <esap> edwardk: right, I think that's well-known already from logic
06:21:29 <edwardk> it fits nicely with my substructural types coz then strict types map onto A and lazy types onto ~~A, and the substructural type annotations tell yoou which translation of A -> B to use.
06:21:39 <edwardk> basically performing strictness analysis.
06:21:49 <edwardk> and yeah, it is =)
06:22:03 <edwardk> its a pretty basic property of any heyting logic.
06:22:37 <edwardk> er heyting algebra
06:23:20 <edwardk> so basically my strict types follow the SL translation, and my non-strict (affine, unrestricted) types pretty much follow the LL translation in that paper.
06:23:46 <esap> edwardk: Another interesting thing from that paper was the handling of recursion and Curry's paradox
06:23:48 <edwardk> insert context splitting to maintain contraction-freeness of unique types, and you have the bulk of it
06:24:12 <edwardk> yeah. the v alpha. alpha was a nice graph introduction notation.
06:24:55 <edwardk> well, nu alpha. alpha technically i guess
06:25:23 <esap> edwardk: the example of 'single negation node pointing to itself' is nice paradox
06:25:38 <edwardk> *nods*
06:25:47 <dmhouse> Anyone use Haskore?
06:26:07 <dmhouse> Or have used?
06:26:13 * esap goes to watch some anime... bbl
06:26:17 <edwardk> My current abstract machine looks a lot like their AM with some additional type qualifier annotations and an additional swap operator
06:26:21 <edwardk> kk
06:26:23 <edwardk> have fun
06:27:16 <edwardk> esap: you might also look at Jan Zwanenberg's Pure Type System with Subtyping
06:33:06 <gour> @where hs-plugins
06:33:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:33:27 <basti_> say, might it be that continuations are some sort of "distributive law" between monads and comonads? (lists and datastreams eg.)
06:33:42 <basti_> or, the operator that is to be distributed?
06:34:33 <basti_> I tried, in coq, to translate a stream of bytes (strem of lists of bits) to a stream of bits
06:35:06 <basti_> and i observed that i always needed a thing similar to a continuation to get from lists to streams
06:37:33 <edwardk> hrmm.
06:38:06 * basti_ is making people think.
06:38:25 <edwardk> trying to figure out how to tear that apart actually =)
06:38:31 <basti_> lol
06:38:46 <edwardk> comonads and monads can interact in several ways as i seem to recall.
06:38:57 * basti_ nods
06:39:03 <edwardk> not sure that continuations are in any way shape or form fundamental in that interaction
06:39:16 <basti_> ok
06:39:41 <edwardk> i'm just looking at the set of comonads and monads i've been using to model substructural types.
06:39:57 <edwardk> there doesn't appear to be any deep continuation based principal at work in between them
06:40:11 <edwardk> might be a useful tool in the toolchest, not sure its fundamental
06:40:12 <basti_> hmm I'm not sure at all either
06:40:42 <basti_> i was thinking like that: when the list ends, you'll need a stream to append to the stream you want to return.
06:40:53 <vincenz> dons++
06:40:55 <basti_> thats not a real continuation i think, but somewhat close.
06:40:56 <vincenz> dons++
06:41:01 <vincenz> hmm
06:41:06 <vincenz> @karma+ dons
06:41:06 <lambdabot> dons's karma raised to 59.
06:41:08 <vincenz> @karma+ dons
06:41:09 <lambdabot> dons's karma raised to 60.
06:41:11 <vincenz> @bot
06:41:11 <lambdabot> :)
06:43:07 <basti_> what are streams for if they never end?
06:43:23 <edwardk> basti: what is any infinite list for? =)
06:43:29 <dmhouse> dons++ works in #math.
06:43:49 <basti_> well a list may potentially end
06:43:53 <damkor> hi there
06:44:01 <basti_> but a stream never does, no matter what i do.
06:44:04 <edwardk> dmhouse: yeah and there it causes all sorts of problems when people talk about c++
06:44:09 <edwardk> basti: sure.
06:44:15 <damkor> I have a problem with ghc and make
06:44:17 <basti_> hmm, but i could disregard the rest of the stream.
06:44:46 <dmhouse> > take 10 [1..]
06:44:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:45:01 <basti_> i'm not sure if haskell data is data or codata.
06:45:02 <edwardk> basti: exactly. in haskell everything is really codata and coinductive, etc. so infinite lists are really codata by nature.
06:45:07 <vincenz> @. check free
06:45:07 <lambdabot>  Parse error
06:45:13 <basti_> k
06:45:28 <edwardk> codata can be finite or infinite, data can only be finite
06:45:37 * basti_ nods
06:45:52 <dmhouse> ?help free
06:45:52 <lambdabot> free <ident>. Generate theorems for free
06:45:55 <dmhouse> ?free foo
06:45:56 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `foo'\n\n"
06:46:02 <dmhouse> What's it do?
06:46:09 <damkor> I use literal haskell, and haddock as well. I stablished %.o: %.hs and %.hs: %.lhs in the makefile, so I can latter do something like make doc and run haddock on every hs file
06:46:09 <dmhouse> ?free map
06:46:10 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
06:46:24 <basti_> it generates a random function? ;)
06:46:24 <edwardk> you can always autolift data to codata though going the other way you might get stuck in an infinite computation =)
06:46:32 <basti_> edwardk: i see.
06:46:53 <basti_> edwardk: so basically, computation can transform data to codata and vv?
06:46:57 <damkor> the main problem is that either make or ghc delete the generated .hs file after calling ghc <file>.hs -c -o <file>.o
06:47:05 <edwardk> thats what esap and i were talking about above with A -> ~~A, but ~~A -> A does not always hold.
06:47:16 <basti_> oo
06:47:23 * basti_ is having flashbacks
06:47:40 <edwardk> its a property of heyting algebras and intuitionistic logic
06:47:52 <basti_> yea, i had a lecture about that once
06:47:58 <basti_> heard
06:48:11 <edwardk> if we programmed in classical logic some how, then it'd be reversible, but then we couldn't have any infinite structures, recursion, etc.
06:48:20 * basti_ nods
06:49:11 <basti_> will chosing the wrong dual get me some sort of problems?
06:49:16 <edwardk> CHARITY explores that problem space (with explicit data/codata cata/ana-morphisms, etc)
06:49:30 <edwardk> but it lacks recursion so its hardly more than a toy
06:49:37 <basti_> u huh
06:49:57 <edwardk> but its a good place to look to get your head around the distinctions
06:50:50 <basti_> @where CHARITY
06:50:50 <lambdabot> I know nothing about charity.
06:51:00 <basti_> hmm
06:51:13 <basti_> stupid name for a cs project :|
06:51:14 <edwardk> http://pll.cpsc.ucalgary.ca/charity1/www/literature.html
06:51:17 <edwardk> yeah
06:51:17 <lambdabot> Title: CHARITY - The Charity Literature, http://tinyurl.com/zvle7
06:51:36 <edwardk> it gets into pretty deep category theory quickly though
06:51:47 <edwardk> the idea of charity is to use category theory as the basis for the language.
06:51:51 <basti_> u huh
06:52:05 <edwardk> and throw out whatever isn't naturally expressed in CT.
06:52:21 <edwardk> hence the lack of recursion, coz they want all functions to be total, etc.
06:52:34 <basti_> i see
06:55:32 <basti_> codata is stronger than data isnt it? (there's a map from every data type to a co-datatype, but not vv)
06:55:50 <edwardk> yeah
06:56:09 <edwardk> you can always take a value and return a trivial computation that will generate that value.
06:56:13 <basti_> (and i mean every, so that data is a proper subset of codata - up to some iso)
06:56:18 * basti_ nods
06:56:23 <edwardk> in fact if you structure your value types right you can do it for free by autolifting
06:56:31 <basti_> yea i see
06:57:00 <basti_> how does lazy vs. eager evaluation relate to that?
06:57:02 <edwardk> the idea being that you would tag the constructors of your value types to point to a trivial function that just returns the current thunk
06:57:21 <basti_> u huh
06:57:41 <edwardk> then you can make values just return themselves and computations go off and compute and return something in WHNF.
06:57:49 <basti_> WHNF?
06:57:54 <edwardk> weak head normal form
06:57:57 <basti_> ah ok
06:58:13 <basti_> i think i see what you mean
06:58:34 <edwardk> basically if you had data Either a b = Left a | Right b, and had a computation that returned Either a b, when you went to look at the result, you would evaluate it to WHNF to see if you had Left or Right.
06:58:48 <basti_> u huh
06:58:51 <edwardk> you wouldn't necessarily have evaluated the contents of the Left or Right, just that far
06:58:58 <basti_> yea ok
06:59:15 <edwardk> so the 'head' is normalized, the rest of it not necessarily
06:59:19 <edwardk> hence WHNF
06:59:22 * basti_ nods
06:59:42 <basti_> but now we got codata
06:59:47 <edwardk> haskell thunks work that way, computing their contents, and translating themselves into WHNF
06:59:55 <basti_> since we're using "computations"
06:59:58 <edwardk> sure
07:00:12 <edwardk> but ML on the other hand is strict, so it deals with values, not thunks by default.
07:00:15 <basti_> yea
07:00:32 <basti_> lazy eval is the only way to work with (all) codata isnt it?
07:00:35 <edwardk> so eager works with data, and lazy works by necessity with codata.
07:00:38 <Cale> The Weak in WHNF refers to the idea that it could also be a lambda abstraction, in the case that it's a function.
07:00:41 <basti_> yea ok
07:01:05 <edwardk> *nods*
07:01:08 <Cale> \x -> ((\y -> y + x) 2) is in WHNF, but not HNF.
07:01:26 <basti_> ok, now how does that relate to endless loops/turing-completeness?
07:01:35 <basti_> i can write an endless loop in C or ML
07:01:54 <basti_> i can also work with streams (codata) in C, i just never get done.
07:01:55 <edwardk> basti: well, you don't necessarily evaluate the tail end of the list in haskell unless you 'look at it'
07:02:07 <Cale> Actually, I think haskell's data is somewhere in between data and codata :)
07:02:16 <basti_> (or, i even can get done)
07:02:31 <Cale> Though I haven't really looked at that so carefully
07:02:37 <basti_> does "computation" always include data *and* codata?
07:02:44 <edwardk> cale: i think the literature pretty much views haskell's data type as a codata type.
07:02:50 <basti_> (since without being able to generate codata, we wouldnt be TC?)
07:03:02 <edwardk> TC?
07:03:06 <basti_> turing complete
07:03:08 <edwardk> tring complete
07:03:10 <edwardk> yeah
07:03:15 <edwardk> well
07:03:51 <edwardk> because of the presence of recursion you aren't really dealing strictly with data either ;)
07:03:54 <basti_> i mean, for example, /dev/zero is a codata store
07:03:57 * basti_ nods
07:04:07 <basti_> i thought there'd be some caveat ^^
07:04:13 <edwardk> heh
07:04:47 <basti_> did somebody ever formalize that relation?
07:05:02 <basti_> turing-complete computation - data - codata?
07:05:12 <basti_> or is that a no-brainer?
07:05:56 <edwardk> not sure that does entail turing completeness, coz you need some way to compute with them, not just their presence =)
07:06:44 <basti_> hmm
07:06:55 <Cale> edwardk: well, you have both length and enumFrom on the Haskell list type
07:06:58 <basti_> yea, without computation, data is stupid
07:07:05 <Cale> edwardk: Doesn't that sort of make it both?
07:07:11 <basti_> thats a point Cale.
07:07:35 <edwardk> cale: well, length presupposes its finite, treating it as data and isn't defined on all lists.
07:07:42 <Cale> right
07:07:42 <basti_> I think, computation that can't work with both of data and codata is not TC
07:08:05 <basti_> read: (all) data & codata
07:08:10 <Cale> So it's like you're simultaneously defining data and codata in an overlapping manner. :)
07:08:32 <Cale> and some things just won't terminate
07:08:35 <basti_> which would reduce to only all codata, since data is a subset of some sorts of codata
07:08:47 <basti_> yea, to be meaningful, computation has to be TC
07:08:59 <basti_> and TCness brings nontermination
07:09:45 <edwardk> cale: well, the haskell model for codata has codata subsuming  data, since data can always be lifted to codata.
07:09:55 <edwardk> cale: the relationship isn't symmetrical though
07:12:23 <Pupeno> ahg!
07:12:59 <basti_> ?
07:13:03 <Pupeno> haskell-mode drives me crazy, what can it indent and if - then - else correctly ?
07:13:30 <basti_> cos nobody ever goes and fixes it
07:13:46 * Pupeno wonders what Haskellers use...
07:13:48 <basti_> i had a look once but my lisp-fu isn't strong enough
07:14:11 <lennart> there's always the space bar...
07:14:29 <Pupeno> lennart: for that I'll drop haskell-mode and emacs all-together.
07:14:54 <lisppaste2> int-e pasted "haskell-mode hook (far from perfect)" at http://paste.lisp.org/display/25770
07:15:02 <lennart> real programmers use cat to edit.
07:15:59 <int-e> if-then-else gets a bit better with that, but as I wrote, not perfect.
07:16:16 <edwardk> wow you're allowed cat? i'm jealous. I was never allowed to leave the shell. echo > file; echo >> file; ...
07:17:17 <Pupeno> int-e: that didn't help me, with that, the sole indentation after and if is at the same level of the if.
07:17:27 <edwardk> actually I wonder if it would be _more_ cruel to make someone edit with ed than cat, sure its technically more powerful, but...
07:17:45 <Pupeno> and case fails to indent the second case.
07:18:25 <basti_> haskell-mode is very broken as it is.
07:18:43 <es> hello. what does 'generalising' mean when haskell is type checking? is it trying to resolve a variable to a specific type or make it polymorphic?
07:19:15 * Pupeno would like to try yi.
07:22:22 <lennart> edwardk: ed is a perfectly fine editor.  Nothing cruel, just luxury.  It is after all the EDitor.
07:22:51 <lennart> es: making it polymorphic
07:25:08 <lennart> ?users
07:25:09 <lambdabot> Maximum users seen in #haskell: 242, currently: 222 (91.7%), active: 31 (14.0%)
07:25:22 <int-e> Pupeno: I guess I really layout ifs manually (with spaces). *shrugs*
07:29:52 <Pupeno> Are =, ->, =>, ::, etc, infix operators ?
07:30:08 <basti_> hmm
07:30:17 <basti_> they're infix, but not haskell operators.
07:30:23 <basti_> -> is haskell, in some way, though
07:30:32 <basti_> that is, you can't say (::)
07:30:38 <basti_> but you can say (->) and it does make sense
07:30:59 <basti_> = is a haskell operator, too, but the = after "data" isn't haskell =
07:31:05 <basti_> does that answer your question? ;)
07:31:37 <Pupeno> more or less.
07:35:17 <kpreid> basti_: don't you mean ==?
07:35:31 <basti_> hmmmm
07:35:34 <basti_> yea
07:35:35 <basti_> k
07:35:55 * basti_ goes stand in a corner
07:42:33 * sieni brings the whip
07:57:56 <Pupeno> where can I find a list of characters that can act as infix operators ?
08:00:42 <wilx> In the Haskell Report probably...
08:03:13 * Pupeno is browsing thru it.
08:03:58 <Templar> can someone tell me how I should type: "div"? (¥div¥, "div", 'div')?? I cant get it to work...
08:04:06 <audreyt> `div`
08:04:08 <wilx> `div`
08:04:18 <audreyt> the key on the left of "1"
08:04:24 <Pupeno> it seems these are: ascSymbol   ->   ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @ |   \ | ^ | | | - | ~
08:04:28 <wilx> 2.4 is IMO the relevant chapter.
08:05:54 <Templar> left of "1" is the "ß" and "Ω" key here...
08:07:11 <Templar> ah, now I found it :P. thx!
08:12:41 <mauke> ?type liftM2 (flip id)
08:12:42 <lambdabot> forall a1 c (m :: * -> *). (Monad m) => m a1 -> m (a1 -> c) -> m c
08:49:46 <mauke> how do I read a floating point number in base 16?
08:49:57 <profmakx> as you do in base 10?
08:50:05 <Templar> anyone who knows if it¥s possible to clear the prompt/window in WinHugs somehow?(/clear, cls, cl....)
08:50:14 <mauke> profmakx: no, that would give the result in base 10
08:50:28 <profmakx> or do you mean with haskell ;)
08:50:32 <profmakx> then i am lost
08:50:46 <mauke> yeah, in haskell :-)
08:50:50 <profmakx> damn
08:50:52 <profmakx> ;)
08:58:34 <tuomov> hmmm.. how did state work in parsec
08:58:36 <tuomov> ?
08:59:23 <tuomov> If I 'update state; p; restore state', and if p fails, does the state get restored to the state it was before I modified it, as it backtracks, or does it remain?
09:17:13 <SamB> @hoogle System.Posix.Types.CPid -> System.Process.Internals.ProcessHandle
09:17:14 <lambdabot> No matches, try a more general search
09:17:24 <SamB> @type System.Process.Internals.ProcessHandle
09:17:26 <lambdabot> System.Process.Internals.PHANDLE -> System.Process.Internals.ProcessHandle
09:19:10 <SamB> ack, my Alt key stopped working in Emacs again...
09:20:47 <SamB> hmm, I may actually have the means to find out what version added mkProcessHandle...
09:23:30 <SamB> aww, --partial foils my plans!
09:25:23 <weitzman> Hmm
09:25:27 <weitzman> @type ap
09:25:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
09:25:32 <weitzman> @type zipWith (+)
09:25:33 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
09:25:38 <weitzman> @type ap (zipWith (+))
09:25:39 <lambdabot> forall b. (Num b) => ([b] -> [b]) -> [b] -> [b]
09:26:26 <SamB> why don't we have some kind of history-browsing thing on the server?
09:28:07 <weitzman> For no apparent reason, the ap function is making me confused
09:31:29 <mauke> > uncurry (flip (.) (liftM2 (/) (forceRead Numeric.readHex) ((16 ^) . fromIntegral . length)) . (+) . forceRead Numeric.readHex) . second tail . break ('.' ==)
09:31:30 <lambdabot>  Not in scope: `forceRead'
09:31:37 <mauke> k thx
09:33:19 <mauke> > let force [(x, "")] = x in uncurry (flip (.) (liftM2 (/) (force . readHex) ((16 ^) . fromIntegral . length)) . (+) . force . readHex) . second tail . break ('.' ==) $ "f.8"
09:33:21 <lambdabot>  15.5
09:33:51 <mauke> ok, now can I get this in more sane?
09:35:13 <wilx> Heh.
09:35:17 <wilx> What does it do?
09:36:17 <mauke> parses a hex float
09:37:03 <SamB> hmm, autoconf checks an awful lot of stuff unasked...
09:39:47 <weitzman> @check (\a b -> (ap a b) == (let f x y = concat ( map (\z -> map z y) x) in f a b)) :: [Int -> Int] -> [Int] -> Bool
09:39:52 <lambdabot> Terminated
09:40:36 * SamB wonders why you'd need a mutex on a process handle...
09:43:02 <SamB> @tell dons the hmp3 repo is missing a default email
09:43:02 <lambdabot> Consider it noted.
09:46:22 <weitzman> I'm trying to figure out why both (ap [(+ 1)]) and (ap (zipWith (+))) both typecheck
09:46:27 <weitzman> Since
09:46:31 <weitzman> @type (zipWith (+))
09:46:33 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
09:46:33 <weitzman> and
09:46:38 <weitzman> @type [(+ 1)]
09:46:39 <lambdabot> forall a. (Num a) => [a -> a]
09:46:51 <mauke> [] and (e ->) are both monads
09:47:11 <weitzman> Oh dear
09:47:14 <int-e> @type ap [(+ 1)]
09:47:15 <lambdabot> forall a. (Num a) => [a] -> [a]
09:47:29 <mauke> ap c f x = x `c` f x, I think
09:47:48 <int-e> @type ao
09:47:49 <lambdabot> Not in scope: `ao'
09:47:50 <int-e> @type ap
09:47:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
09:47:54 <SamB> why do id (()) and (id []) both typecheck?
09:47:57 <SamB> er.
09:48:07 <SamB> I mean (id ()) and (id []) ;-)
09:48:32 <mauke> @karma+ undefined
09:48:32 <lambdabot> undefined's karma raised to 1.
09:49:03 <int-e> ap = liftM2 id
09:49:27 <int-e> ap f a = do f' <- f; a' <- a; return (f a)
09:49:41 <int-e> return (f' a')
09:50:20 <int-e> @. pl undo \f a -> do f' <- f; a' <- a; return (f a)
09:50:21 <lambdabot> liftM2 (.) (>>=) ((const .) . ap (>>=) . ((const . return) .))
09:53:36 <int-e> @pl--
09:53:36 <lambdabot> (line 1, column 1):
09:53:36 <lambdabot> unexpected end of input
09:53:36 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:53:51 <int-e> @karma- @pl
09:53:51 <lambdabot>  @pl's karma lowered to -1.
09:56:05 <mauke> liftM2 id c f x = c x `id` f x = c x (f x) = x `c` f x
10:00:34 <weitzman> Another thing I've found to hurt my brain is a this:
10:00:38 <weitzman> @type msum [(* 2), (+ 1)]
10:00:39 <lambdabot> forall a. (MonadPlus ((->) a), Num a) => a -> a
10:00:41 <weitzman> @type msum [(* 2), (+ 1)] 2 43 54 6 4
10:00:42 <lambdabot> forall t t1 t2 t3 t4. (MonadPlus ((->) (t1 -> t2 -> t3 -> t4 -> t)), Num (t1 -> t2 -> t3 -> t4 -> t), Num t1, Num t2, Num t3, Num t4) =>
10:00:49 <weitzman> @type msum [(* 2), (+ 1)] 23 34 534 2 3 4 21 23 43 3 53 3
10:00:50 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11. (MonadPlus ((->) (t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t)), Num (t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10
10:00:50 <lambdabot> -> t11 -> t), Num t1, Num t2, Num t3, Num t4, Num t5, Num t6, Num t7, Num t8, Num t9, Num t10, Num t11) =>
10:01:01 <weitzman> That's not the kind of function I'm used to
10:01:18 <weitzman> I don't know if it does anything
10:01:21 <weitzman> But it's pretty cool
10:02:18 <weitzman> I guess adding more arguments changes the type of the argument monad or somesuch
10:03:17 <weitzman> I was hoping msum would just compose my functions in the list
10:05:31 <fasta> @pl foo $ bar a b
10:05:32 <lambdabot> foo (bar a b)
10:06:02 <fasta> @pl (\a b->foo $ bar a b)
10:06:03 <lambdabot> (foo .) . bar
10:09:41 <mauke> ?type foldr (.) id
10:09:43 <lambdabot> forall a. [a -> a] -> a -> a
10:20:48 <weitzman> Hmm. There's a typo in quickCheck. "The lambda expression `\ x y z -> ...' has three argumentss"
10:21:12 <dmhouse> weitzman: patch it! :)
10:21:19 <weitzman> They probably use darcs
10:21:21 <weitzman> ?
10:21:27 <dmhouse> Guess so.
10:22:14 <weitzman> Actually I guess nobody knows what they use
10:22:17 <weitzman> It's just a file on a website
10:23:05 <weitzman> Except the error message I got isn't in QuickCheck.hs
10:23:33 <weitzman> So I wonder where it came from
10:23:59 <weitzman> Oh wait a second
10:24:02 <weitzman> It's from haskell
10:24:18 <weitzman> What's lambdabot running on?
10:24:22 <weitzman> Anyone know?
10:24:46 <dmhouse> dons' computer?
10:24:51 <profmakx> @version
10:24:52 <lambdabot> lambdabot 4p165, GHC 6.5 (OpenBSD i386 )
10:24:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:41:29 <sehute> hi, anybody tried coding rgb to hsv conversion?
10:41:42 <sehute> I'm struggling with the algorithm
10:42:09 <kpreid> if weitzman were still here, I'd tell him about flip (foldl ($))
10:46:27 <dylan> @type flip (foldl ($))
10:46:28 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
10:46:29 <lambdabot>    Expected type: (b1 -> b) -> b1 -> b1 -> b
10:46:38 <dylan> @type flip (foldl id)
10:46:39 <lambdabot>   Occurs check: cannot construct the infinite type: t = b -> t
10:46:39 <lambdabot>    Expected type: (b -> t) -> b -> b -> t
10:46:43 <dylan> thought so.
10:48:19 * SamB notices that the optimizations curses does for serial communication are good for raster-based terminals too...
10:48:53 <kpreid> er
10:49:09 <kpreid> sorry, I meant flip (foldr ($)) or flip (foldl (flip ($)))
10:49:44 <SamB> sehute: I still don't know what hsv is...
10:50:09 <kpreid> hue/saturation/value
10:50:37 <SamB> yes, I know what the letters stand for...
10:51:14 <sehute> it's a color-system?
10:51:42 <sehute> SamB: what category of answer are you looking for? :)
10:52:21 <SamB> @wikipedia hsv
10:52:23 <lambdabot> No Result Found.
10:52:40 <SamB> @google site:wikipedia.org hsv
10:52:41 <lambdabot> http://en.wikipedia.org/wiki/HSV_color_space
10:53:37 <kpreid> I don't know, but I suspect the algorithm might involve matching against [r > g, g > b, b > r]
10:54:00 <runehol> it is a color space distinct from RGB that many artists feel models more accurately how they think about colors
10:54:27 <sehute> I've tried that algorithms, but it still fails to work the same way as the color-dialog of GTK/Gimp
10:55:13 <runehol> sehute: sometimes HSV is confused with HSL which is similar but not quite the same, and has a different conversion algorithm
10:55:21 <kpreid> sehute: there is a very s...what runehol said
10:55:37 <kpreid> also called HSB (brightness)
10:55:40 <runehol> http://en.wikipedia.org/wiki/HSL_color_space
10:56:12 <sehute> runehol: thanks for the hint, however I've just implemented the algorithm from wikipedia/hsv, and it still fails to act in a similar way
10:56:20 <sehute> I've even implemented it in both C++ and Python, just to check
10:56:25 <sehute> And double-checked my floats
10:56:32 <kpreid> sehute: you're sure that Gimp's dialog isn't doing HSL?
10:56:34 <sehute> And double-checked my code
10:56:37 <runehol> oh, so it works in C++ and python, but not in haskell?
10:56:44 <sehute> I've tried three different algorithms and two different languages
10:56:45 <runehol> or does it work in neither implementation?
10:56:49 <sehute> runehol: neither implementation
10:56:51 <Korollary> I suppose you can look at gtk's source
10:56:53 <SamB> runehol: hasn't someone said that already?
10:57:02 <sehute> kpreid: no, that might be!
10:57:09 <kpreid> sehute: particularly, if you turn up the slider all the way, is it white or colorful? the former is HSL and the latter is HSV
10:57:10 <runehol> SamB: might be, I joined not long ago
10:57:17 <sehute> kpreid: *checking*
10:57:30 <SamB> that about "oh, so it works in C++ and python, but not in haskell?"
10:57:44 <sehute> kpreid: all the way in Gimp is colorfoul, not white
10:57:48 <sehute> kpreid: thanks!
10:57:51 * SamB think he's seen something like that before somewhere...
10:57:53 <sehute> kpreid: that explains everything
10:57:58 <sehute> kpreid: you're my hero now
10:58:05 <kpreid> sehute: so Gimp is doing HSV, so that doesn't explain it
10:58:09 <sehute> huh?
10:58:09 <sehute> hm
10:58:11 <sehute> *thinking*
10:58:25 <sehute> oh
10:58:32 <sehute> I'm still lost then :D
10:58:34 <SamB> you are using floating point right?
10:58:39 <sehute> SamB: float everywhere
10:58:55 <sehute> SamB: and no ints in the python-code
10:59:05 <sehute> SamB: only decimals
11:00:41 <sehute> Strange thing is, all the "s" and "v" are always correct, and "h" is never correct
11:00:56 <runehol> how wrong is it?
11:01:14 <runehol> h is circular, so it might just be atan or something giving a different range than you expect
11:02:06 <sehute> runehol: it's 0 or "nan", when it should've been 0.93...
11:02:18 <SamB> or maybe their h starts at a different part of the wheel?
11:02:21 <SamB> oh.
11:02:28 <sehute> runehol: Yeah, I might need to dive into the maths of h
11:02:50 <sehute> runehol: I'm a bit dissapointed that a direct translation from the hsv-algo on wikipedia didn't churn out a correct result, though
11:03:07 <sehute> runehol: There still is a possibility that it's something wrong with my implementation(s), though
11:03:25 <sehute> SamB: might be, might be
11:03:40 <sehute> Actually, I'll check out the GTK-sourcecode
11:03:42 <SamB> sehute: that wouldn't explain such strange things
11:03:45 <runehol> sehute: getting nan suggests an implementation error, yes
11:03:47 <SamB> as 0 and nan
11:03:54 <sehute> runehol: it does, but that's only one of the algorithms
11:03:59 <sehute> runehol: the others gives 0
11:04:08 <SamB> that also sounds bad!
11:04:14 <sehute> it does
11:04:50 <sehute> It might just be that I've repeated a mistake in all the implementations :/
11:04:58 <sehute> *triple-checking code*
11:05:15 <sehute> I've pretty much copy-and-pasted this algo: http://www.cs.rit.edu/~ncs/color/t_convert.html
11:05:21 <sehute> and it still returns the wrong result
11:05:39 <sehute> not even pretty much, but actually copy and pasted it :)
11:06:01 <SamB> > let h r g b = m where m = max [r, g, b] in h 1 0 0
11:06:02 <lambdabot>  Add a type signature
11:06:26 <SamB> > let h r g b = m where m = max [r, g, b] in h 1 0 0 :: Float
11:06:27 <lambdabot>    Expecting a function type, but found `Float'
11:06:27 <lambdabot>    Expected type: Float
11:06:27 <lambdabot> ...
11:06:34 <SamB> > let h r g b = m where m = maximum [r, g, b] in h 1 0 0
11:06:35 <lambdabot>  1
11:09:40 * edwardk waves ello.
11:10:26 * sehute cheers!
11:10:32 <sehute> I found an algo that worked in Python
11:10:43 <sehute> :-)
11:10:56 <edwardk> rgb -> hsv is what you're after?
11:10:59 <sehute> yes
11:13:30 <newsham> just one?
11:16:19 <edwardk> rgb2hsv r g b = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = (flip mod) 360 $ 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d
11:16:25 <edwardk> or something like that
11:16:55 <edwardk> er / should be `div` i'd guess since you probably want ints
11:17:15 <edwardk> then again, maybe not
11:17:39 <sehute> edwardk: that's exactly the part I'm not sure of :)
11:18:19 <edwardk> well, fromIntegral your arguments, use /, then you can always truncate them to ints once you're done.
11:18:29 <edwardk> i've always done these in floats, so that seems appropriate.
11:19:55 <edwardk> no sense accumulating rounding error during the translation
11:21:08 <sehute> edwardk: agreed
11:22:05 <TreyHarris> Anyone have suggestions for how to get a GHC 6.6 on OS X powerpc?  either a build incantation that works, or binaries i can download?
11:25:00 <edwardk> trey no idea =/
11:25:50 <alec> TreyHarris: you can get 6.4.1 from fink, and I assume you can use that to build 6.6
11:26:18 <integral> There's also the 6.4.1 DMG from the GHC website, which I've used to build 6.6
11:27:38 <edwardk> fasta, nick any relation to the bioinformatics format? =)
11:27:40 <edwardk> doh
11:28:35 <TreyHarris> alec, integral: i have 6.4.1.  i've never been able to build a 6.6 using it.  but the last time i tried was a long time ago, i'll try again.  thanks
11:29:36 <edwardk> "fasta: is your nick any relation to the bioinformatics format?"
11:29:51 <fasta> edwardk: yes
11:30:01 <edwardk> ah k
11:30:29 <edwardk> figured it was that or some gangsta reference to speed ;)
11:30:55 <fasta> I am writing some code which needs to do a number of operations to the same object. In an imperative language one could do this:
11:31:15 <fasta> a=foobar;a=operation a;a=another_operation etc
11:31:18 <SamB> > let rgb2hsv r g b = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = (flip mod) 360 $ 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in rgb2hsv (1/3, 1/2, 1)
11:31:19 <lambdabot>     add an instance declaration for (Integral (a, a1, c), Fractional (a, a...
11:31:32 <fasta> I would like to put comments between the various operations.
11:31:50 <emu> > let foo n = n + sqrt n in foo 3
11:31:51 <lambdabot>  4.732050807568877
11:31:57 <fasta> Using let forces me to invent new names.
11:31:58 <edwardk> fasta perhaps to it in a monad so you can use do notation.
11:32:02 <emu> > let foo n = n + (floor $ sqrt n) in foo 3
11:32:02 <lambdabot>  Add a type signature
11:32:09 <edwardk> er perhaps do it
11:32:25 <emu> > let foo m = n + (floor $ sqrt n) where n = fromIntegral m in foo 3
11:32:26 <lambdabot>  Add a type signature
11:32:32 <fasta> edwardk: yes, but what monad?
11:32:33 <edwardk> fasta then you can bundle all of your state into the monad, and just say
11:32:42 <fasta> edwardk: I don't have state
11:32:46 <dmhouse> fasta: you can use let.
11:32:48 <emu> > let foo n = fromIntegral n + (floor . sqrt $ fromIntegral n) foo 3
11:32:48 <lambdabot>  Parse error
11:32:50 <edwardk> method = do foobar; operation; operation; another_operation
11:32:56 <emu> > let foo n = fromIntegral n + (floor . sqrt $ fromIntegral n) in foo 3
11:32:56 <dmhouse> fasta: invent new names by adding apostrophes.
11:32:57 <lambdabot>  4
11:33:05 <edwardk> fasta: well, the obvious one would be state
11:33:11 <dmhouse> > let a = 4; a' = a + 2; a'' = a' * 4
11:33:12 <lambdabot>  Parse error
11:33:14 <dmhouse> > let a = 4; a' = a + 2; a'' = a' * 4 in a''
11:33:15 <lambdabot>  24
11:33:29 <emu> why doesn't the "where n = fromIntegral m" work? shouldn't it just substitute
11:33:30 <edwardk> fasta then again you might want IO or ST s if you really want to think imperatively
11:33:43 <fasta> edwardk: heh, no, I don't want that :)
11:33:45 <dmhouse> Alternatively, you can use let and shadow the previous bindings, but this is considered bad style and is a warning in some compilers:
11:34:02 <dmhouse> > let a = 4; a = a + 2; a = a * 4 in a -- actually, I'm not even sure this'll work
11:34:03 <lambdabot>    Conflicting definitions for `a'
11:34:03 <lambdabot>   In the binding group for: a, a, a
11:34:06 <SamB> > let rgb2hsv r g b = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = (flip mod) 360 $ 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in map (id&&&rgb2hsv) [(0.0,0.0,0.0),(0.0,0.0,1.0),(0.0,1.0,0.0),(0.0,1.0,1.0),(1.0,0.0,0.0),(1.0,0.0,1.0),(1.0,1.0,0.0),(1.0,1.0,1.0)]
11:34:07 <lambdabot>     add an instance declaration for (Fractional (a, b, c), Integral (a, b,...
11:34:11 <SamB> oh, right..
11:34:14 <fasta> dmhouse: see, that doesn't work.
11:34:15 <dmhouse> fasta: use the apostrophe trick, then.
11:34:21 <edwardk> the state version would then encourage you to write your operations like operation = do x <- get; {- do something with x -}; put x
11:34:29 <mauke> > (* 4) {- quadruple -} . (+ 2) {- add two -} $ 4
11:34:30 <lambdabot>  24
11:34:39 <monochrom> Do we know fasta is using a monad?
11:34:58 <edwardk> monoochrom: he's not, i suggested using a state monad to get the separation he was looking for.
11:35:08 <fasta> monochrom: I don't have a lot of state variables, so from that point I don't need it.
11:35:17 <edwardk> there are plenty of ways to get the desired syntax.
11:35:52 <monochrom> I'm thinking if it comes down to f(g(h(a)) there are a few ways to break it into a few lines and add comments.
11:35:57 <SamB> > let rgb2hsv r g b = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in map (id&&&rgb2hsv) [(0.0,0.0,0.0),(0.0,0.0,1.0),(0.0,1.0,0.0),(0.0,1.0,1.0),(1.0,0.0,0.0),(1.0,0.0,1.0),(1.0,1.0,0.0),(1.0,1.0,1.0)]
11:35:57 <lambdabot>  add an instance declaration for (Fractional (a, b, c))
11:36:18 <fasta> dmhouse: I use that trick, but 10 '-characters is a bit over the top.
11:36:33 <dmhouse> fasta: you're using that many?
11:36:46 <fasta> dmhouse: no, but that would be necessary when using your scheme
11:36:51 <monochrom> May I ask what the current code looks like?
11:36:52 <mauke> > let (|>) = flip (.) in flip id () $ return 4 |> (+ 2) |> (* 4)
11:36:53 <lambdabot>  24
11:36:58 <SamB> @type let rgb2hsv r g b = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in rgb2hsv
11:36:59 <lambdabot> forall a. (Ord a, Fractional a) => a -> a -> a -> (a, a, a)
11:37:11 <SamB> oh right...
11:37:12 <dmhouse> fasta: I've never needed 10 apostrophes.
11:37:17 <edwardk> samb: still playing with that? =)
11:37:38 <SamB> > let rgb2hsv (r,g,b) = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = (flip mod) 360 $ 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in map (id&&&rgb2hsv) [(0.0,0.0,0.0),(0.0,0.0,1.0),(0.0,1.0,0.0),(0.0,1.0,1.0),(1.0,0.0,0.0),(1.0,0.0,1.0),(1.0,1.0,0.0),(1.0,1.0,1.0)]
11:37:38 <lambdabot>  Add a type signature
11:37:42 <SamB> erg
11:37:51 <dmhouse> SamB: /query would be appreciated.
11:37:56 <SamB> sorry
11:39:31 <monochrom> Use function composition (.) or monad composition (aka bind, >>=).
11:39:33 <SamB> > let rgb2hsv (r,g,b) = (h,d/max, max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h = 60*if (r == max) then (g-b)/d else if (g == max) then 2 + (b -r)/d else 4 + (r-g)/d in rgb2hsv(0,0,0)
11:39:33 <SamB> (NaN,NaN,0.0)
11:39:34 <lambdabot>  (NaN,NaN,0.0)
11:39:43 <SamB> oh, oops, pasted answer too...
11:39:52 <SamB> anyway...
11:40:16 <SamB> that one is broke, even if you take out the nonsensical use of the mod function on a non-integral value!
11:40:26 <monochrom> If you have 20 intermediates but they all come from a chain, you should go pointfree.
11:40:28 <edwardk> fair nuff =)
11:40:38 <edwardk> you can switch the mod for a if its less than 0 add 360
11:40:52 <edwardk> er for a check that
11:41:02 <SamB> it still won't work, though!
11:41:27 <edwardk> the other case needs a little bit of case analysis to remove when delta = 0 from the hsv calc =)
11:41:39 <edwardk> it was a back of the envelope calculation =)
11:42:38 <monochrom> And by that, I think I've pinned down the characterisation of when and when not to go pointfree.
11:43:00 <emu> ?pl \n -> fromIntegral n + (floor . sqrt $ fromIntegral n)
11:43:01 <lambdabot> liftM2 (+) fromIntegral (floor . sqrt . fromIntegral)
11:43:34 <edwardk> > let rgb2hsv (r,g,b) = if d>0 then (h,d/max,max) else (0,0,max) where d = max - min; max = maximum [r,g,b]; min = minimum [r,g,b]; h' = 60* if (r == max) then (g-b)/d else if (g == max) then 2 + (b-r)/d else 4+(r-g)/d; h = if h'<0 then h'+360 else h' in rgb2hsv(0,0,0)
11:43:35 <lambdabot>  (0.0,0.0,0.0)
11:43:38 <edwardk> there =)
11:43:50 <edwardk> not very pretty
11:44:37 * edwardk isn't a huge fan of HSV.
11:44:52 <SamB> oh, I suppose it makes sense for h to be NaN if r = g = b
11:45:02 <edwardk> yeah =)
11:45:23 <dylan> @hoogle catchJust
11:45:23 <lambdabot> Control.Exception.catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
11:45:42 <emu> ?type liftM2 (+) fromIntegral (floor . sqrt . fromIntegral)
11:45:43 <lambdabot> forall a b. (Integral b, Integral a) => a -> b
11:45:50 <fasta> monochrom: how do you comment pointfree code? I suppose you can do a . b . c {-comment-} . d . e, but the way you can do this in do notation or in imperative language seems more easy to read.
11:45:52 <emu> liftM2 (+) fromIntegral (floor . sqrt . fromIntegral)
11:45:54 <emu> oops
11:45:59 <emu> > (liftM2 (+) fromIntegral (floor . sqrt . fromIntegral)) 3
11:45:59 <SamB> okay, in that case, I don't see anything wrong with the Wikipedia algorithm!
11:46:00 <lambdabot>  4
11:46:02 <emu> grr
11:46:22 <dmhouse> fasta: lay it out how you wish.
11:46:25 <dmhouse> a .
11:46:26 <dmhouse> b .
11:46:29 <monochrom> First of all you may have chosen better and more self-commenting names for a,b,c,d.
11:46:30 <dmhouse> c . --comment
11:46:32 <dmhouse> d .
11:46:34 <dmhouse> e $ foo
11:46:45 <monochrom> Secondly you can write a.b.c.d in four lines.
11:46:49 <emu> "add an instance declaration for (Monad ((->) a))"
11:46:50 <dmhouse> Think of the '.' by being like a semicolon.
11:46:51 <edwardk> of course then your reader has to know to read that bottom to top
11:47:01 <dmhouse> s/by/as/
11:47:04 <mauke> emu: import Control.Monad.Reader
11:47:19 <emu> cool
11:47:24 <fasta> dmhouse: ok, that's nice
11:47:31 <monochrom> Your reader is an Arabic or an ancient East Asian.  Right-to-left makes more sense. :)
11:47:33 <mauke> edwardk: easily fixed by defining an op for flip (.)
11:48:00 <edwardk> yeah or using >>>
11:48:26 <monochrom> OK, bottom-to-top is stretching it.  Use >>> or invent your own symbol for (flip (.))
11:49:06 <monochrom> It is a pity ; is taken.
11:49:12 <edwardk> yeah
11:49:29 <fasta> For what is ; taken?
11:49:37 <mauke> >>
11:49:38 <emu> structuring
11:49:43 <SamB> layout!
11:49:47 <fasta> Oops
11:49:49 <monochrom> let { x=1; y=2 } in x+y
11:50:00 <fasta> I knew that, I just never use it
11:50:13 <emu> is @ usable outside of patterns?
11:50:21 <SamB> some people are liking to write more than one thing on a line sometimes
11:50:24 <SamB> such as...
11:50:39 <edwardk> emu: insofar as function arguments are patters, etc.
11:50:45 <emu> yea i guess
11:50:53 <SamB> erm...
11:51:11 <edwardk> > (\x@y = x + y) 2
11:51:11 <lambdabot>  Parse error
11:51:12 <monochrom> If you import Control.Arrow you can use >>> for pure functions.
11:51:28 <edwardk> > (\ x@y -> x+y) 2
11:51:29 <lambdabot>  4
11:51:35 <SamB> well, maybe they want to define more than one thing in a let for lambdabot or GHCi...
11:51:35 <edwardk> helps not to typo =)
11:51:38 <fasta> monochrom: don't I need to wrap them in arr then?
11:51:48 <SamB> or a short do
11:51:53 <edwardk> fasta nah coz -> is an arrow type
11:52:03 <monochrom> > (sin >>> asin) 0
11:52:03 <lambdabot>  0.0
11:52:04 <emu> @type (>>>)
11:52:05 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
11:52:16 <fasta> Oh, sweet.
11:52:25 <mauke> any ideas for improving let force [(x, "")] = x in uncurry (flip (.) (liftM2 (/) (force . readHex) ((16 ^) . fromIntegral . length)) . (+) . force . readHex) . second tail . break ('.' ==) ?
11:52:26 <monochrom> "a->b" is already an instance of Arrow.
11:53:16 <monochrom> arr is needed if you use a non-trivial Arrow
11:53:17 <edwardk> >  let force [(x, "")] = x in uncurry (flip (.) (liftM2 (/) (force . readHex) ((16 ^) . fromIntegral . length)) . (+) . force . readHex) . second tail . break ('.' ==)
11:53:18 <lambdabot>  Add a type signature
11:54:42 <mauke> apply it to "ff.8"
11:55:35 <SamB> @instances Arrow
11:55:36 <lambdabot> (->), Kleisli m
11:55:44 <emu> ?pl \n o k = (. k) . o . k
11:55:44 <lambdabot> (line 1, column 8):
11:55:44 <lambdabot> unexpected "="
11:55:44 <lambdabot> expecting pattern or "->"
11:55:49 <emu> ?pl \o k = (. k) . o . k
11:55:49 <SamB> @hoogle Kleisli
11:55:49 <lambdabot> Control.Arrow.Kleisli :: a -> m b -> Kleisli m a b
11:55:50 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
11:55:52 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
11:55:54 <lambdabot> (line 1, column 6):
11:55:56 <lambdabot> unexpected "="
11:55:58 <lambdabot> expecting pattern or "->"
11:56:02 <emu> ?pl \o k -> (. k) . o . k
11:56:03 <lambdabot> ap ((.) . flip (.)) . (.)
11:56:47 <edwardk> afk a bit
11:56:49 <monochrom> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/6179df438bd4138d/17520bdd236b3351?lnk=st&q=&rnum=3&hl=en#17520bdd236b3351
11:56:51 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/z2ek5
11:57:16 <monochrom> I really rubbed it into George Russell's face on the "one thing per line" thing.
11:57:46 <emu> man, that ?pl is the best tool ever for obfuscated programming contests
11:57:55 <edwardk> emu: hhehe
11:58:20 <newsham> i think something that reduced haskell code to lambdas would also be good to throw in a few large monstrocities
11:58:32 <newsham> like spj does in his miranda book
11:59:20 <newsham> especially if you then go and implement lambdas in c preprocessor or javascript or something
11:59:37 <mauke> preprocessor? sounds impossible
11:59:50 <mauke> it should be trivial in javascript
11:59:52 <fasta> What is the definition of ap?
12:00:10 <edwardk> @type ap
12:00:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:00:36 <emu> it's function application in a monad
12:00:51 <mauke> ap mf mx = do { f <- mf; x <- mx; return (f x) }
12:01:07 <monochrom> ap cmdf cmda = do { f <- cmdf; a <- cmda; return (f a) }
12:01:14 <newsham> wasnt one of the obfuscated C contest winners a program that ran entirely at preprocess time using cpp, written in a functional style?
12:01:24 <emu> ?pl \mf mx -> do { f <- mf; x <- mx; return (f x) }
12:01:24 <lambdabot> (line 1, column 14):
12:01:24 <lambdabot> unexpected "{"
12:01:24 <lambdabot> expecting variable, "(", operator or end of input
12:01:57 <emu> ?pl \mf mx -> do f <- mf; x <- mx; return (f x)
12:01:58 <lambdabot> (line 1, column 21):
12:01:58 <lambdabot> unexpected ";"
12:01:58 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
12:02:02 <mauke> pl doesn't know do notation
12:02:07 <fasta> complete pointfree programming is still not natural for me
12:02:08 <emu> ah
12:02:15 <emu> ok
12:02:19 <monochrom> No, don't go complete pointfree.
12:02:21 <fasta> nor do I expect it to ever be
12:02:26 <edwardk> @. pl undo \mf mx -> do f <- mf; x <- mx; return $ f x
12:02:26 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
12:02:28 <mauke> ?pl \mf mx -> mf >>= \f -> mx >>= \x -> return (f x)
12:02:29 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
12:02:29 <edwardk> sok =)
12:02:40 <edwardk> . pl undo to the rescue =)
12:02:54 <emu> ?pl \a b c d e -> o (b c) (b d) (b e)
12:02:54 <lambdabot> const (flip =<< ((flip . ((.) .)) .) . (flip =<< (((.) . o) .)))
12:02:59 <mauke> what does undo do? full desugarisation?
12:03:06 <edwardk> undo removes do sugar
12:03:06 <SamB> takes out dos
12:03:13 <edwardk> sjannsen wrote it
12:03:15 <mauke> d'oh. makes sense
12:03:26 <monochrom> If your dataflow is a straight chain, or close to a straight chain, you go pointfree.  f >>> g >>> h >>> i >>> j  short and sweet pipeline.
12:03:27 <edwardk> prepends nicely to @pl
12:03:28 * SamB didn't know about undo before
12:03:45 <edwardk> samb: sjannsen slapped it together a week or two back
12:03:58 <mauke> can't we redefine pl as . real-pl undo?
12:04:10 <fasta> monochrom: I need some argument order differences (I'd guess flip)
12:04:15 <SamB> does lambdabot have macros yet?
12:04:29 <edwardk> take that up with dons i guess
12:04:37 <monochrom> The more your dataflow deviates from a chain (e.g., some output of some stage is not used by the next immediate stage, but jumps several stages and rejoins there), pointfree becomes harder to follow.
12:05:28 <edwardk> pl doesn't really use any of the arrow tools, does it, just reader monad tricks?
12:08:06 <monochrom> Examples.  do { x<-cmd1; y<-cmd2; return (f x y) }   or   proc a -> do { x <- f1 -< a; y <- f2 -< a; returnA -< f x y }   these or their scaled-up counterparts are not easy to point-free.
12:10:27 <sjanssen> @. pl undo do { x<-cmd1; y<-cmd2; return (f x y) }
12:10:27 <lambdabot> (`fmap` cmd2) . f =<< cmd1
12:11:16 <mauke> @. pl undo \f cmd1 cmd2 -> do { x<-cmd1; y<-cmd2; return (f x y) }
12:11:16 <lambdabot> liftM2
12:11:25 <edwardk> heh
12:11:59 <sjanssen> interesting it doesn't rewrite the lambdaless version to use liftM2
12:12:30 <int-e> @. pl undo \cmd1 cmd2 -> do { x<-cmd1; y<-cmd2; return (x y) }
12:12:30 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
12:12:36 <lisppaste2> dylan pasted "echo-to-many server, v3, without obvious leak (one hopes)" at http://paste.lisp.org/display/25778
12:12:37 <int-e> == liftM2 id
12:12:44 <edwardk> so you think it should find liftM2 f x y?
12:12:58 <sjanssen> I think the real solution for @pl is to make it use a real Haskell parser, then use the code from undo to desugar the constructs it doesn't understand
12:13:51 <sjanssen> edwardk: well liftM2 f cmd1 cmd2, but yes, I think it should
12:13:51 <newsham> here's the IOCCC program I was thinking about..  the preprocessor solves the problem (hanoi), the resulting program just prints it out:  http://east.isx.com/~vanb/1995.ioccc
12:13:55 <monochrom> It's liftM2 f cmd1 cmd2 dammit!
12:14:12 <edwardk> er yeah =)
12:14:44 <newsham> the preprocessor expansions do the computing, #including itself allows for looping
12:15:03 <monochrom> Nice.
12:15:05 <sjanssen> newsham: you should rewrite that in Haskell, using type classes instead of CPP
12:15:22 <monochrom> Evil.
12:15:32 <newsham> how about implement lambdas, and write a haskell -> cpp compiler?
12:15:49 <monochrom> Nuts.
12:15:57 <Moo_Moo> http://wlserver1-he.gindis.com/modules.php?name=WLAccount&file=visitor&op=game&userid=MzU4Ng== Gindis game the best game ever , if anyone get into, in down of page have flags choice flags on language u want play
12:15:59 <mauke> argh. have you seen boost.preprocessor?
12:15:59 <lambdabot> http://tinyurl.com/qlk28
12:16:16 <edwardk> mauke: yeah
12:16:26 <mauke> isn't that bad enough? :/
12:17:38 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ __ _..._ JIMBO WALES
12:17:41 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ .-' . . '-. THIS FUCKING PENISBIRD SHITS
12:17:43 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _/. . ._ . ._\ DOWN YOUR NECK INTO YOUR STOMACH
12:17:46 <newsham> or better yet, haskell -> sendmail.cf?
12:17:46 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ /. . .(o) ./__) WHERE THE SHIT BURNS FOR THE REST OF
12:17:47 <dylan> Oh dear
12:17:48 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ __ /. . .,_ . .| '| YOUR SHORT AND PATHETIC LIFE
12:17:51 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ |. . ./ .\ . /_/
12:17:53 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ /. . .`"`" . .} IT THEN GRIPS ONTO YOUR COCK WITH ALL ITS MIGHT
12:17:56 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ __ /. . . . . . . { AND INJECTS VARIOUS MUTAGENS INTO YOUR BLOODSTREAM
12:17:57 <dylan> This is really annoying
12:17:58 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ /. . . . . . . .} THROUGH ITS RAZOR-SHARP CLAWS WHERE IT REACTS
12:17:59 <newsham> /mode #haskell +p
12:18:01 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ __ /. . . . .\/\ /\ { WITH YOUR VAST RESERVES OF FAT AND BLUBBER
12:18:03 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ |. . . . . .;``"``\
12:18:06 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- __ /. . . . . . / ; ; ;| NOBODY IS SAFE FROM THE PENISBIRD, AND IT
12:18:08 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ |. . . . . . / ; ; ; | FUCKING HATES FAGS LIKE JIMBO WALES
12:18:09 * dylan does /ignore kjdfs
12:18:11 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ \ . . . ._.-`|; ; ; ;|
12:18:13 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ /`-..--`` a a| ; ; ; | YOU ARE NEXT, YOU FUCKING FAT, FILTHY PIG
12:18:16 -kjdfs(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a a a|; ; ; ;|
12:18:18 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _| a a a a a a | ; ; ; /_ _ _ _ ,--........,,
12:18:21 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a a / ; ; ; ; _ _ _ .' . . . . . -='.
12:18:23 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _| a a a a a / ; ; ; / _ _ _ _\ . . . . . . . :
12:18:26 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a/` ; ; ; \ _ _,==" .\ . . . . . . .'
12:18:28 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _\ a a a .'. _ ,._'\.\~" o //` .\. . . . . .'
12:18:31 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a.___~' \ \-~| | o ./,\.` .\. . . _.'
12:18:33 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- p|; a a/ _|.-~'| |o| |. . . . ,-''\..--'
12:18:35 <gour> kill this monster!
12:18:36 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- p| _..-'"'. . .| | | |. . _="`
12:18:38 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pp~ . . . \\ . | | / /_="`
12:18:40 <basti_> uhm
12:18:41 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppp. . . ./,\ / /_,)")
12:18:41 <dylan> or /ignore * NOTICES
12:18:42 <basti_> yea
12:18:43 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp . . ._,.-)")
12:18:44 <basti_> plz
12:18:46 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp__,=~"| ===================
12:18:48 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppppp|; .;| Penisbird/. 1.3.tex
12:18:51 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp | y .| ===================
12:18:52 <edwardk> i'm guessing its our old friend teekwod? =)
12:18:52 <chessguy> very slick
12:18:53 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp |;|\ |
12:18:55 * johnnowak drinks his coffee
12:18:56 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppp_ |/' \| LETS GET IT ON, MOTHERFUCKERS.
12:18:58 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ __ _..._ JIMBO WALES
12:19:01 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ .-' . . '-. THIS FUCKING PENISBIRD SHITS
12:19:03 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _/. . ._ . ._\ DOWN YOUR NECK INTO YOUR STOMACH
12:19:06 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ /. . .(o) ./__) WHERE THE SHIT BURNS FOR THE REST OF
12:19:08 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ __ /. . .,_ . .| '| YOUR SHORT AND PATHETIC LIFE
12:19:11 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ |. . ./ .\ . /_/
12:19:13 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ /. . .`"`" . .} IT THEN GRIPS ONTO YOUR COCK WITH ALL ITS MIGHT
12:19:16 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ __ /. . . . . . . { AND INJECTS VARIOUS MUTAGENS INTO YOUR BLOODSTREAM
12:19:18 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ /. . . . . . . .} THROUGH ITS RAZOR-SHARP CLAWS WHERE IT REACTS
12:19:21 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ __ /. . . . .\/\ /\ { WITH YOUR VAST RESERVES OF FAT AND BLUBBER
12:19:23 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ |. . . . . .;``"``\
12:19:25 <SamB> lambdabot needs ops
12:19:26 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- __ /. . . . . . / ; ; ;| NOBODY IS SAFE FROM THE PENISBIRD, AND IT
12:19:28 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ |. . . . . . / ; ; ; | FUCKING HATES FAGS LIKE JIMBO WALES
12:19:31 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ \ . . . ._.-`|; ; ; ;|
12:19:33 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ /`-..--`` a a| ; ; ; | YOU ARE NEXT, YOU FUCKING FAT, FILTHY PIG
12:19:36 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a a a|; ; ; ;|
12:19:39 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _| a a a a a a | ; ; ; /_ _ _ _ ,--........,,
12:19:41 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a a / ; ; ; ; _ _ _ .' . . . . . -='.
12:19:44 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _| a a a a a / ; ; ; / _ _ _ _\ . . . . . . . :
12:19:46 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a a a/` ; ; ; \ _ _,==" .\ . . . . . . .'
12:19:48 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _\ a a a .'. _ ,._'\.\~" o //` .\. . . . . .'
12:19:51 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _|a a a.___~' \ \-~| | o ./,\.` .\. . . _.'
12:19:51 * edwardk shakes dons to see if he'll wake up.
12:19:51 <newsham> someone needs to /on ^privmsg *PENISBIRD* /kick
12:19:53 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- p|; a a/ _|.-~'| |o| |. . . . ,-''\..--'
12:19:56 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- p| _..-'"'. . .| | | |. . _="`
12:19:58 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pp~ . . . \\ . | | / /_="`
12:20:01 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppp. . . ./,\ / /_,)")
12:20:03 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp . . ._,.-)")
12:20:06 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp__,=~"| ===================
12:20:08 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppppp|; .;| Penisbird/. 1.3.tex
12:20:10 <dylan> y'know, it's too bad he chose dylan`
12:20:10 <Lemmih> Cale: Around?
12:20:11 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp | y .| ===================
12:20:13 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- pppp |;|\ |
12:20:16 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- ppp_ |/' \| LETS GET IT ON, MOTHERFUCKERS.
12:20:18 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ __ _..._ JIMBO WALES
12:20:19 <dylan> if it was dylan_, I could have nickserv kill it
12:20:21 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _ .-' . . '-. THIS FUCKING PENISBIRD SHITS
12:20:23 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ _/. . ._ . ._\ DOWN YOUR NECK INTO YOUR STOMACH
12:20:24 <Cale> ugh
12:20:25 <edwardk> heh
12:20:26 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ _ /. . .(o) ./__) WHERE THE SHIT BURNS FOR THE REST OF
12:20:28 --- mode: ChanServ set +o Cale
12:20:28 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ __ /. . .,_ . .| '| YOUR SHORT AND PATHETIC LIFE
12:20:31 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ |. . ./ .\ . /_/
12:20:33 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ _ /. . .`"`" . .} IT THEN GRIPS ONTO YOUR COCK WITH ALL ITS MIGHT
12:20:36 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ __ /. . . . . . . { AND INJECTS VARIOUS MUTAGENS INTO YOUR BLOODSTREAM
12:20:39 -dylan`(n=hitlist@FL-ESR1-72-49-148-39.fuse.net)- _ _ _ /. . . . . . . .} THROUGH ITS RAZOR-SHARP CLAWS WHERE IT REACTS
12:20:47 --- mode: Cale set +b dylan`!*@*
12:20:47 <gour> Haskellers of the world, unite and kill this one!
12:21:13 --- mode: Cale set +b *!*@FL-ESR1-72-49-148-39.fuse.net
12:21:16 <profmakx> why are there always these *!"*"ß*?ß"
12:21:19 <dylan> is jimbo wales even in this channel?
12:21:24 <Cale> no
12:21:52 <johnnowak> profmakx: that's just you methinks.
12:21:54 <monochrom> I suddenly think this is a plot similar to that of Star Wars. :)
12:22:04 <newsham> he keeps dumping the same things, someone could make an auto-kick
12:22:12 <Cale> yeah
12:22:16 <dylan> Cale: if you use irssi and have trigger.pl, you could make a trigger to op yourself and kick on that pattern of behavior. :)
12:22:38 <Cale> I'm using X-Chat, it's also scriptable like that
12:22:40 <SamB> what should the plugin be called?
12:22:55 <newsham> hair-plugs
12:22:56 <dfranke> castratebird.pl?
12:22:57 * SamB wants to write a lambdabot plugin
12:22:59 <profmakx> penisBird-ex
12:23:11 <SamB> maybe would be used for more than that...
12:23:26 * dylan is somewhat worried that a variant of his nick is in the banlist
12:24:08 --- mode: Cale set -b dylan`!*@*
12:24:45 <int-e> what confuses me is that this guy is on #math and shows almost normal behaviour.
12:25:00 <dylan> hmm, nickserv is not responding to me
12:25:05 <dfranke> int-e: this all started in response to ban from #math
12:25:25 <SamB> hmm
12:25:34 * SamB decides he doesn't have a clue how to do this...
12:25:46 <dons> :/
12:25:46 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:25:48 <int-e> oh, it's teakwood again?
12:25:55 <int-e> tekwod, you name it.
12:25:56 <dylan> err, nickserv and chanserv don't respond
12:25:59 <dylan> should I be worried?
12:26:11 <newsham> i think it was better before IRC when teenage math "enthusiasts" were confined to their bedrooms
12:26:13 <newsham> ;-)
12:26:21 --- mode: ChanServ set +o dons
12:26:46 <profmakx> they woke the giant!
12:27:02 <dylan> this is somewhat worrisome because I'd rather like to be able to change a chanserv setting for my own channel, #slug.fl...
12:27:21 <monochrom> In a #haskell far far away...  things have been pretty democratic.  Then troll attacks abound, and after some of these the citizens are inclined to op lambdabot.  Little do they know that lambdabot devised this scheme; it's behind the troll attacks and its goal is to get opped, crowned emperor, to establish the first haskellian empire...
12:27:53 <lightstep> ?paste
12:27:54 <lambdabot> http://paste.lisp.org/new/haskell
12:28:24 <SamB> monochrom: hmm
12:28:47 <dylan> Oh dear. I'm a moron.
12:28:49 --- mode: ChanServ set -o dons
12:28:59 <dylan> I ignored notices. XD
12:29:02 <newsham> Troll postings often contain an ASCII art representation of some offensive image, often related to shock sites, with a nonsensical or provocative subject line. The 'Penis bird' troll, a crude ASCII representation of a bird perched on an erect penis, is a common variant, derived from the Penisbird image.
12:29:04 <SamB> heh
12:30:11 * SamB wonders how hard it would be to get lambdabot to recognize trolls by ascii art...
12:30:12 <lisppaste2> lightstep pasted "hanoi towers at compile time" at http://paste.lisp.org/display/25780
12:30:27 <dylan> But, I understand (how to use) STM. so I'm not a complete moron.
12:30:48 <lightstep> sjanssen, it didn't come out as obfuscated as the C version
12:30:49 <newsham> lstep: heh
12:30:58 <dylan> SamB: it could mistake some pointless syntax for ascii art.
12:31:22 <monochrom> Like (.) . (.)  (:D~~~)
12:31:24 <SamB> dylan: nah...
12:31:49 <SamB> it wouldn't kill for just one line
12:32:05 <monochrom> OK, that's better.
12:33:02 <dfranke> how about three lines in one minute, none of which parse as Haskell code.
12:33:14 <int-e> I would trigger on the text in that, actually.
12:33:22 <fasta> monochrom: the syntax you used for arrows is not natural to me, but >>> seems to work. I will need to use them more, I guess. Thanks, also others
12:33:36 <lightstep> int-e, what about @yow?
12:33:42 <lightstep> or @vixen?
12:34:08 <int-e> I've not seen them mentioning that bird yet.
12:34:33 <SamB> well...
12:34:34 <dylan> it'd be fun if lambdabot kicked herself.
12:34:40 <SamB> anyone could mention the PENISBIRD
12:34:54 <SamB> but anyway, it shouldn't ban unless the offense is repeated...
12:34:59 <int-e> suure. we could put it into the topic.
12:35:04 <int-e> 'don't mention P...' ;)
12:35:16 <SamB> nobody reads the topic, dude!
12:35:18 <dylan> I used to have fun with trolls in a tetrinet server. I made it so the server filtered certain words / etc into other things.
12:35:20 <int-e> and kick newbies who ask 'why shouldn't I mention ...'?
12:35:40 <dfranke> int-e: that would be fun to watch.
12:36:17 <int-e> (see http://bash.org/?627168)
12:36:18 <lambdabot> Title: QDB: Quote #627168
12:38:39 <dfranke> maybe the h4x0rs could keep their channel pure by having a bot that kicks you if you type anything that spellchecks.
12:39:00 <Cale> hah
12:39:35 <int-e> wh at  ab out  for eign  lang uag es  and  short  words?
12:40:10 <dfranke> int-e: bah, no excuses!
12:40:18 <Cale> @elite wh at  ab out  for eign  lang uag es  and  short  words?
12:40:18 <lambdabot> WH At 4b 0U+ For eI9n lang UaG Ez 4Nd s|-|or+ w0rDs?
12:40:38 <Cale> @elite wh at  ab out  for eign  lang uag es  and  short  words?
12:40:39 <lambdabot> W|-| AT 4b OU7 foR 3IGn |an9 UAG e5 4nd $H0r+ wORd$?
12:40:56 <Cale> f0|2
12:41:06 <Cale> 47
12:42:15 <monochrom> ŒµŒªŒπœÑŒµ
12:42:25 <Cale> heh
12:42:56 <Cale> Œπ Œ±Œº Œ±ŒΩ ŒµŒªŒπœÑŒµ ŒìœÅŒµŒµŒ∫ Œ∑Œ±œáŒøœÅ!
12:43:36 <Cale> Setting up a Greek keyboard layout with a toggle is convenient.
12:43:47 <mauke> eww, eta for h
12:45:52 <dfranke> Cale, I prefer to use emacs input methods
12:46:10 <dfranke> I do it all the time when I want to put math symbols in my comments.
12:46:24 <Cale> mauke it's just because that's what that key produces, and I was too lazy to make it pronounce correctly :)
12:46:33 <dfranke> or, if I'm feeling sadistic, my variable names.
12:47:26 <Cale> > let xs ‚äï ys = zipWith (+) xs ys in [1,2,3] ‚äï [4,5,6]
12:47:27 <lambdabot>  Illegal character ''\138''
12:47:29 <Cale> heh
12:47:56 <dfranke> well, it works in PLT Scheme :-)
12:48:28 <Cale> I think that might actually be an issue with the bot interface
12:48:46 <Cale> 6.5/6.6 is supposed to have decent unicode support in source files
12:49:23 <Cale> lambdabot pre-parses the source so as to ensure that it's actually valid Haskell on its own, to avoid code injection attacks
13:02:38 <runehol> how would one represent a directed graph in haskell?
13:02:44 <runehol> e.g. like a data flow graph in a compiler
13:03:33 <runehol> I'm having a hard time seeing how one would express sharing of nodes
13:03:43 --- mode: Cale set -o Cale
13:03:56 <profmakx> what do you mean with "sharing"?
13:04:02 <Cale> runehol: By representing edges explicitly somehow
13:04:28 <runehol> profmakx: if two operations use the result of one operation, they should both point to the same operation so it doesn't get evaluated twice
13:04:50 <Cale> runehol: You could use a UArray Int Int Bool as an adjacency matrix.
13:04:54 <Cale> er
13:05:00 <runehol> Cale: right, but could that be done in a way that make pattern matching still work?
13:05:03 <Cale> runehol: UArray (Int,Int) Bool
13:05:06 <runehol> *makes
13:05:15 <Cale> pattern matching on what?
13:05:37 <runehol> Cale: also, a data dependency graph is typically very sparse, so an adjacency matrix would be inefficient memory-wise
13:06:02 <runehol> Cale: i.e. be able to match plus(constant, constant) when doing optimizations
13:06:05 <Cale> okay, then probably you want something like a Map Vertex (Set Vertex) or some such.
13:06:30 <runehol> hmm
13:07:06 <Cale> But mostly, you'd represent it much like you would in another language
13:07:25 <runehol> with pointers?
13:07:36 <Cale> Well, or Int in place of pointers :)
13:07:46 <runehol> right
13:08:11 <runehol> that's hardly elegant, but okay
13:08:12 <profmakx> what? haskell does not have pointers? *runsincircles*
13:08:32 <Cale> Algebraic datatypes don't really work for structures with cycles. If you try to represent the cycles directly with sharing, you'll end up with something that looks like an infinite structure.
13:08:34 <emu> cycle [1..10]
13:08:55 <runehol> Cale: yeah, I feared as much
13:08:55 <Cale> and there will be no way to detect things like when you've exhaustively searched it.
13:09:18 <emu> > cycle [1..10]
13:09:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
13:09:21 <runehol> I read purely functional data structures the other day, and graphs were conspiciously absent
13:09:39 <Cale> There are some nice functional graph algorithms
13:09:44 <emu> you read the whole thing?
13:10:09 <Cale> http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
13:10:11 <lambdabot> http://tinyurl.com/gf73z
13:10:14 <runehol> okay, browsed would be a better word
13:10:49 <Cale> runehol: that paper is an extremely elaborate answer to your question :)
13:10:49 <runehol> Cale: thanks
13:10:56 <runehol> looks interesting
13:11:23 <Cale> supposing that you don't want to just use adjacency arrays or explicit recording of edges :)
13:11:51 <sehute> My rgb and hsv interpolation program is finished. Thanks for all hints earlier on. :-) *happy*
13:12:14 <Cale> The basic idea there is to break a graph into a stream of "contexts", where a context is a vertex together with some of the arcs incident on it
13:12:18 <emu> i like how part of his introduction mentions newsgroups as a source
13:13:40 <kolmodin> someony might be interested in common failures for packages not yet fixed for ghc 6.5. it's a review of the packages we have in gentoo linux: http://www.haskell.org/~gentoo/gentoo-haskell/projects/GHC-6.5-failures.html
13:13:43 <lambdabot> Title: Packages failing with GHC 6.5.20060906, http://tinyurl.com/jxo2e
13:15:02 <sehute> on an unrelated notice, I just can't get past how beautiful Haskell is
13:15:25 <profmakx> sehute, me concur
13:15:44 <sehute> How is reading other people's Haskell-code, btw? A place between perl and python?
13:16:40 <lispy> so, in darcs we explicitly thread [DarcsFlags] to most functions...there must be a better way
13:19:03 <lispy> sehute: i find haskell easier to read than python because of the types
13:19:34 <sehute> lispy: that's good point. If the types are included in the definition of functions, it does bring a lot of clarity.
13:20:09 <lispy> and when they're not you can ask the compiler what type something has :)
13:20:42 <sehute> true, but then you're doing more than just reading :)
13:28:18 <Cale> sehute: but even so, it helps a lot in determining where you should plug in your modification, and ensuring to some extent that what you've done is sane
13:32:28 <dylan> hmm, can one use Data.ByteString with QuickCheck?
13:32:40 <dylan> (is there an instance of Aribtrary ByteString?)
13:33:07 <lispy> dylan: perhaps, i know quickcheck is used with in the Data.ByteString source
13:39:54 <dylan> can't find a ByteString instance of Arbitrary. :(
13:42:22 <SyntaxNinja> xerox: y0
13:42:27 <xerox> Hi..
13:42:58 <SyntaxNinja> xerox: I'm about to have some patches for you
13:43:01 <SyntaxNinja> you are sometimes silly ;)
13:43:08 <xerox> You are probably right
13:43:42 <sjanssen> dylan: instance Arbitrary P.ByteString where {arbitrary = P.pack `fmap` arbitrary; coarbitrary s = coarbitrary (P.unpack s)}
13:44:15 <dylan> where P is Data.ByteString.Char8, say?
13:44:18 <sjanssen> dylan: that's a wrapper around the Arbitrary for lists, taken from the ByteString testsuite
13:44:29 <sjanssen> dylan: sure
13:44:37 <dylan> Righto
13:45:56 <SyntaxNinja> xerox: did you get my patches?
13:46:13 <SyntaxNinja> xerox: are you planning to keep cabal-install separate from the cabal codebase? I wanted it as a single codebase.
13:46:39 <xerox> SyntaxNinja: I thought you wanted it separate for the makefile madness, i.e. for simplifying things.
13:47:16 <sjanssen> @check (\x -> x == negate (negate x)) :: Int -> Bool -- this is very cool!
13:47:17 <lambdabot>  OK, passed 500 tests.
13:47:56 <SyntaxNinja> xerox: no, I just wanted "make" in the cabal directory to _also_ install cabal-install :)
13:48:05 <xerox> SyntaxNinja: AH!
13:48:08 <SyntaxNinja> yay! I got it to work!
13:48:18 <xerox> SyntaxNinja: then that's what Cabal Makefile was trying to do
13:48:26 <SyntaxNinja> I installed the rss tool which installed haxml.
13:48:27 <SyntaxNinja> sweeeet
13:48:33 <xerox> Oh, I'm happy.
13:48:34 <beelsebob> @where lambdabot
13:48:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:48:44 <xerox> I have got stomach ache, but still happy for this :)
13:48:53 <xerox> (I'm applying the patches now.)
13:48:55 <SyntaxNinja> why have you got a somach ache?
13:49:10 <xerox> I don't know, I woke up ill this morning :-/
13:49:37 <xerox> Maybe I should stop sleeping with the window open, it's getting more cold these last nights.
13:50:37 * SyntaxNinja nods
13:50:40 <SyntaxNinja> take care of yourself
13:51:00 * xerox groans - thanks
13:52:48 <lispy> xerox: i'm thinking the same thing lately
13:53:10 <xerox> SyntaxNinja: should it work to save the mail and darcs apply it?
13:53:18 <xerox> (The contents)
13:54:07 <SyntaxNinja> xerox: yeah
13:54:21 <xerox> Allright!
13:54:23 <SyntaxNinja> xerox: did you get an error?
13:54:39 <xerox> Yeah I didn't add the first lines of summary.
13:55:06 <emu> Cale: am i delusional or does his function to compute depth first spanning forests (pg 17) have a slight flaw
13:55:07 <xerox> Pushed, now the repo has them.
13:55:12 <xerox> Thank you SyntaxNinja.
13:55:51 <dylan> hmm, how does one turn a String into a ByteString? (for testing purposes...)
13:56:04 <dylan> I tried @hoogle to no avail.
13:56:11 <emu> pack
13:56:13 <SyntaxNinja> xerox: sweet.  what's a good test program? preferably w/ like one dependency
13:56:23 <xerox> I think so....
13:56:23 <emu> @hoogle pack
13:56:24 <lambdabot> Data.PackedString.packString :: String -> PackedString
13:56:24 <lambdabot> Distribution.InstalledPackageInfo.package :: InstalledPackageInfo -> PackageIdentifier
13:56:24 <lambdabot> Distribution.PackageDescription.package :: PackageDescription -> PackageIdentifier
13:56:46 <sjanssen> dylan: Data.ByteString.Char8.pack
13:56:55 <xerox> SyntaxNinja: If there was Hope it had to install a lot of small modules.
13:57:05 <dylan> sjanssen: thanks.
13:57:06 <dylan> and all.
13:57:09 <sjanssen> dylan: but you have to watch out, ByteString can only represent Chars <= 255
13:57:26 <xerox> SyntaxNinja: I don't think one gets more than 2 levels deep now.  But monk people can use ~paolo/bin/cabal-put to add packages.
13:58:06 <dylan> sjanssen: I'm only dealing with utf-8, so...
13:58:16 <emu> clearly we need larger bytes
13:58:38 * dylan personally dislikes UTF-{16,32}
13:59:38 <sjanssen> UTF-8 can represent characters that are greater than 255
13:59:43 <sjanssen> just not in one byte
13:59:46 <emu> i'm not aware of the state of unicode support in ghc
13:59:55 <emu> but yea, we're confusing the notion of char and byte here
14:00:36 <xerox> SyntaxNinja: oh sorry, you said "one"
14:00:51 <xerox> SyntaxNinja: hnop is a good test program, since it's very ... light? But no dependencies.
14:01:21 <xerox> SyntaxNinja: maybe XmlRpc is, I think it needs crypto, so needing newbinary, but I am not sure now.
14:02:09 <sjanssen> emu: in GHC, a Char represents a Unicode code point.  However, all input functions treat the input as plain old bytes.  Also, output functions only output the lowest 8 bits of a Char
14:04:50 <sjanssen> dylan: it is unwise to rely on that behavior holding in the future, I bet it will change someday
14:07:04 <newsham> why is Data.Map.lookup k -> Map k a -> m a?
14:07:06 <SyntaxNinja> xerox: do you think you can get re-integrated into the cabal codebase and get a script working?
14:07:15 <xerox> SyntaxNinja: yep
14:07:36 <xerox> @localtime SyntaxNinja
14:09:09 <Cale> emu: what is that?
14:09:51 <SyntaxNinja> xerox: another patch coming your way
14:09:56 <xerox> OK.
14:10:17 <xerox> SyntaxNinja: I'll take the official Cabal repo and integrate this whole thing
14:10:30 <xerox> OK?
14:10:42 <dcoutts__> xerox: cool, just don't commit to the main repo 'til after the ghc 6.6 release :-)
14:10:50 <xerox> dcoutts__: I can't.
14:11:16 <SyntaxNinja> xerox: not sure what you're asking.
14:11:21 <dcoutts__> xerox: but certainly, make a copy of the current Cabal repo and integrate your patches in so it'll be easy to merge after the 1.1.6 release
14:11:51 <SyntaxNinja> xerox: yeah, do what you were doing before w/ your own repo; just tweak the cabal makefile so that it also installs cabal-install :)
14:12:06 <xerox> Allright.
14:12:08 <SyntaxNinja> hey! can people please try this out:
14:12:11 <SyntaxNinja> darcs get http://hackage.haskell.org/~paolo/darcs/cabal-install/ && \
14:12:11 <SyntaxNinja> cd cabal-install && \
14:12:11 <SyntaxNinja> make && \
14:12:11 <SyntaxNinja> sudo make install && \
14:12:11 <SyntaxNinja> sudo cabal-install update && \
14:12:12 <SyntaxNinja> cabal-install install --prefix=~/tmp --user hnop && \
14:12:13 <lambdabot> Title: Index of /~paolo/darcs/cabal-install, http://tinyurl.com/fzpo9
14:12:14 <SyntaxNinja> ls -l /tmp/bin/hnop
14:12:30 <Cale> newsham: because it really should be  (MonadZero m) => k -> Map k a -> m a, but there's only a Monad constraint because there's no MonadZero anymore and Monad has fail (which usually crashes the program, but anyway)
14:13:02 <Cale> newsham: basically, to represent failure
14:13:24 <Cale> newsham: if you use the Maybe or list monad for m, then it does the right thing
14:13:39 <Korollary> Cale: If it was MonadZero, would failure be mzero?
14:13:44 <Cale> Korollary: yeah
14:13:56 <xerox> SyntaxNinja: http://hackage.haskell.org/~paolo/tmp/test-cabal-install
14:13:57 <lambdabot> http://tinyurl.com/prakl
14:14:11 <newsham> ty
14:14:16 <xerox> wget http://hackage.haskell.org/~paolo/tmp/test-cabal-install && chmod 755 test-cabal-install && ./test-cabal-install
14:14:18 <lambdabot> http://tinyurl.com/prakl
14:15:17 <xerox> But you probably want ls ~/tmp...
14:15:30 <SyntaxNinja> xerox: does it work for you?
14:15:51 <xerox> SyntaxNinja: I've jsut copied your script for ease of use for people here who want to try
14:16:25 <xerox> Let me see.
14:16:38 <SyntaxNinja> oh yeah, fix that ~/ problem
14:16:43 <xerox> I did.
14:17:12 <xerox> cabal-install: /etc/cabal-install/packages/hnop-0.1: openFile: permission denied (Permission denied)
14:17:31 <xerox> !
14:18:31 <SyntaxNinja> xerox: make it /tmp instead of ~/tmp
14:18:40 <xerox> Okay.
14:20:00 <xerox> Complains: mkdir: /etc/cabal-install: File exists
14:20:42 <SyntaxNinja> xerox: that's what my new patch fixes
14:20:48 <xerox> Added -p ?
14:20:52 <SyntaxNinja> xerox: check your mail. I also added the test script to the repo so we can both update it ;)
14:21:02 <xerox> Right :D
14:21:10 <xerox> SyntaxNinja knows how to do development.
14:21:42 <emu> Cale: f:f' where (f, ...) = ... something that returns ([a], ...)
14:21:54 <SyntaxNinja> as soon as xerox pushes, the command should be:  wget http://hackage.haskell.org/~paolo/darcs/cabal-install/test-cabal-install && chmod 755 test-cabal-install && ./test-cabal-install
14:21:56 <lambdabot> http://tinyurl.com/jemrl
14:22:03 <Cale> emu: f : f' is not a subexpression of that
14:22:16 <SyntaxNinja> :)
14:22:20 <Cale> Br v f : f'
14:22:25 <Cale> = (Br v f) : f'
14:22:30 <xerox> Done.
14:22:56 <emu> gaah
14:23:19 <xerox> cabal-install: /etc/cabal-install/packages/hnop-0.1: openFile: permission denied (Permission denied)
14:23:39 <xerox> Maybe the packages/unstable/ permissions are fscked up
14:24:11 <emu> this is why i use parens!!
14:24:44 <SyntaxNinja> xerox: yeah, I don't get that error
14:26:13 <SyntaxNinja> OK, even without /etc/cabal-install, it works for me now.
14:27:54 <xerox> That path is wrong...
14:30:52 <SyntaxNinja> xerox: I'm going to ask cabal-devel to try out the script. I gotta take off (going climbing, yay).
14:30:59 <xerox> Oh! Have fun!
14:31:21 <xerox> I've fixed make install-user too, I always used that in fact
14:31:22 <SyntaxNinja> danke
14:31:44 <SyntaxNinja> dcoutts: try this? wget http://hackage.haskell.org/~paolo/darcs/cabal-install/test-cabal-install && chmod 755 test-cabal-install && ./test-cabal-install
14:31:46 <lambdabot> http://tinyurl.com/jemrl
14:31:57 <xerox> That complains for permissions problems here :(
14:32:12 <SyntaxNinja> xerox: are the wrong commands being run as root?
14:32:20 <xerox> If I use ~/.cabal-install it works tho
14:32:24 <xerox> Hm.
14:32:34 <SyntaxNinja> do you use sudo?
14:32:38 <xerox> Yep
14:32:53 <SyntaxNinja> which command is failing? cabal-install update?
14:33:07 <xerox> cabal-install install ... hnop
14:33:13 <SyntaxNinja> feel more than free to mod scripty to do it as a regular user, that would be better anyway.
14:33:28 <xerox> It bails out with "Downloading 'hnop-0.1'
14:33:29 <xerox> Downloading 'hnop-0.1'
14:33:29 <xerox> cabal-install: /etc/cabal-install/packages/hnop-0.1: openFile: permission denied (Permission denied)"
14:33:34 <xerox> Alright, I prefer that too.
14:33:44 <SyntaxNinja> ls -lh  /etc/cabal-install/packages/hnop-0.1
14:33:56 <SyntaxNinja> do you have read permission? is cabal-install tryign to open it write?
14:34:05 <xerox> That path doesn't even exist
14:34:20 <xerox> packages/hnop/hnop-0.1.{cabal,tar.gz} do
14:35:09 <xerox> $ ls -lh /etc/cabal-install/packages/hnop/
14:35:09 <xerox> -rw-r--rw-   1 paolo  paolo  220B Aug 20 14:37 hnop-0.1.cabal
14:35:28 <xerox> Yeah the problem is that it can't fetch the tarball
14:35:38 <xerox> Because it can't write there, I think.
14:35:45 <xerox> cabal-install fetch hnop fails.
14:45:51 <xerox> SyntaxNinja: added test-cabal-install-user script.
14:47:07 <beelsebob> @where fps
14:47:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
14:49:53 <Cale> http://www.boasas.com/?c=695 - haha
14:49:54 <lambdabot> Title: [Boy on a Stick and Slither]
14:50:25 <xerox> :D
15:07:03 <dfranke> has anyone had any luck getting the syntax highlighter to behave sensibly in emacs mmm+haskell+latex?
15:09:44 <beelsebob> @where fptools
15:09:44 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
15:09:51 <beelsebob> arse... 404
15:10:13 <xerox> @fptools
15:10:14 <lambdabot>  not available
15:10:17 <xerox> @fptools Data.List
15:10:18 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
15:11:17 <beelsebob> xerox: I need an fptools install for lambdabot
15:12:15 <beelsebob> @version
15:12:15 <lambdabot> lambdabot 4p165, GHC 6.5 (OpenBSD i386 )
15:12:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:12:35 <xerox> Maybe you need packages/ ?
15:22:21 <glguy> and glguy takes the lead for haskell users on mathschallenge :) 1 problem to go
15:23:13 <newsham> goodluck guy
15:23:24 <glguy> it's the one that I've been putting off the longest :)
15:23:57 <newsham> by definition.
15:24:14 <glguy> intentionally
15:24:19 <glguy> :-p
15:24:48 <dolio> :)
15:25:03 <glguy> and now it's time to eat!
15:25:05 <dolio> How fast is your 127?
15:25:19 <dolio> I've been fiddling with mine, but I'm nowhere near the 60 ms that the C guys are at.
15:27:42 <SyntaxNinja> xerox: didja get it working?
15:27:43 <Cale> dolio: 127?
15:28:08 <xerox> SyntaxNinja: nope it still barks, -user script works
15:28:21 <dolio> Problem 127 from mathschallenge.
15:29:21 <xerox> SyntaxNinja: it's just the ermissions anyway, if I run with sudo it works with /etc/cabal-install
15:29:36 <xerox> But I can't find what is exactly the thing with wrong permissions
15:30:31 <SyntaxNinja> did you update the script in the repo?
15:30:52 <SyntaxNinja> looks to me like it still does the global install
15:31:10 <xerox> Yes the other one ending in -user does the user install
15:31:10 <beelsebob> @prod dons
15:31:11 <lambdabot> Unknown command, try @list
15:31:19 <xerox> ...or do you want just one?
15:31:43 <SyntaxNinja> oh I see...
15:32:02 <xerox> I think there is an error
15:32:04 <beelsebob> anyone who knows about lambdabot here?
15:32:14 <xerox> ...can you do ls packages/
15:32:19 <stepcut> beelsebob: what do you want to know ?
15:32:21 <xerox> Does it contain both hnop and hnop-0.1 ?
15:32:32 <beelsebob> stepcut: why it's not connecting to IRC properly
15:32:35 <SyntaxNinja> xerox: yeah
15:32:48 <xerox> That's wrong... I think
15:33:04 <stepcut> beelsebob: what happens ?
15:33:17 <beelsebob> ah, got it going now :(
15:33:18 <beelsebob> :)
15:33:23 <stepcut> :p
15:34:05 <xerox> $ file hnop-0.1
15:34:05 <xerox> hnop-0.1: gzip compressed data, from Unix, max compression
15:34:07 <xerox> Urgh.
15:34:16 <beelsebob> hmm, no
15:34:24 <beelsebob> now it's not fully connecting
15:34:41 <SyntaxNinja> gotta go!
15:37:23 <beelsebob> all I get is:
15:37:23 <beelsebob> Initialising plugins ................................................ done.
15:37:24 <beelsebob> Forking threads ...
15:37:24 <beelsebob> NOTICE: ["AUTH",":*** Looking up your hostname..."]
15:37:24 <beelsebob> NOTICE: ["AUTH",":*** Found your hostname."]
15:38:27 <stepcut> that could be because the host is not responding to ident
15:38:32 <stepcut> but it should eventually connect
15:38:45 <beelsebob> it doesnt... it recieves an EOF from the server
15:39:04 <stepcut> hrm
15:39:31 <beelsebob> and my host should respond... it works from my other IRC client
15:40:39 <dolio> ?hoogle [Maybe a] -> [a]
15:40:40 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
15:49:02 <Lemmih> kosmikus: ping.
15:54:15 <Pupeno> Hello.
15:54:21 <Pupeno> @seen sephr
15:54:22 <lambdabot> I haven't seen sephr.
16:16:52 <delicious-malici> @quote delicious-malicious-test
16:16:53 <lambdabot>  @quote dmt
16:17:07 <delicious-malici> rats
16:17:26 <xerox> O_o
16:24:58 <Pupeno> lisppaste2: url?
16:24:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:26:07 <lispy> @quote dmt
16:26:07 <lambdabot> dmt hasn't said anything memorable
16:26:28 <lispy> @quote foo-bar-baz-quux-blah-duh
16:26:29 <lambdabot> foo-bar-baz-quux-blah-duh hasn't said anything memorable
16:26:34 <lispy> interesting
16:26:52 <Pseudonym> @quote
16:26:52 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
16:26:54 <dmwit> ...but suppose delicious-malicious said, "@quote delicious-malicious" and lambdabot responded to itself...
16:27:02 <lispy> so i wonder if delicious up there was trying to get lambdabot to activate its own quote mechanism
16:27:32 <lispy> @quote lambdabot
16:27:32 <lambdabot>  Done.
16:27:38 <lispy> lol
16:27:42 <lispy> @quote lambdabot
16:27:42 <lambdabot>  Beer, it's so much more than just a breakfast drink!
16:27:44 <nuffer> so if I have some C code, any way to make that call haskell code?
16:27:57 <lispy> nuffer: yupper
16:28:07 <lispy> nuffer: check the ghc manual for details
16:28:11 <xerox> @quote
16:28:12 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
16:28:12 <lambdabot> godawful construct?
16:28:30 <newsham> foreign functions interface.  the old wiki had some examples (not sure how you get to them now)
16:28:37 <newsham> (ffi)
16:28:41 <lispy> @where oldwiki
16:28:41 <lambdabot> I know nothing about oldwiki.
16:28:45 <xerox> @oldwiki
16:28:46 <lambdabot> http://www.haskell.org/hawiki/
16:29:03 <newsham> its possible someone updated the new wiki with the same info too
16:29:52 <newsham> http://www.haskell.org/hawiki/FfiTutorial  and links to othe rpages at bottom
16:29:54 <lambdabot> Title: FfiTutorial - The Haskell Wiki
16:30:20 <lispy> nuffer: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/ffi.html
16:30:22 <lambdabot> Title: Chapter 8. Foreign function interface (FFI), http://tinyurl.com/hcxmk
16:30:37 <nuffer> lispy: I just found that link... thanks
16:51:16 <xerox> http://www.businessweek.com/magazine/content/06_04/b3968001.htm
16:51:19 <lambdabot> Title: Math Will Rock Your World, http://tinyurl.com/dmanf
16:51:47 <lisppaste2> Pupeno pasted "Any way to make it less ugly ?" at http://paste.lisp.org/display/25795
16:52:09 <Pupeno> Can anybody give me some hints how to make that function less ugly ? maybe more Haskellish.
16:52:27 <kosmikus> Lemmih: pong
16:53:18 <xerox> Pupeno: maybe you could use guards instead of ifs.
16:54:20 <xerox> (opts, args, []) | Help `elem` opts -> ...
16:54:20 <xerox>                  | Version `elem` opts -> ...
16:54:20 <xerox>                  | otherwise -> case ...
16:54:22 <xerox> IIRC.
16:56:14 <lispy> it's odd taht you only allow version information if they specified help?
16:56:42 <Pupeno> lispy: what do you mean ?
16:57:01 <Pseudonym> Quants annoy me for some reason.
16:57:14 <Pseudonym> These mathematicians and physicists could have developed a unified field theory by now.
16:57:17 <lispy> if elem Help options ... else if elem Version
16:57:22 <Pseudonym> Instead, they're feeding The Man.
16:57:31 <xerox> Pseudonym: please elaborate further.
16:57:34 <lispy> Pseudonym: heh?
16:57:37 <lispy> er huh
16:57:43 <Pseudonym> Well...
16:57:54 <Pseudonym> It seems like a waste of a mathematician.
16:58:00 <Pupeno> lispy: you can specify only one at a time, version or help.
16:58:22 <lispy> really?
16:58:36 <Pseudonym> I dunno.  My unease is not well thought out.
16:59:11 <lispy> Pseudonym: http://xkcd.com/c114.html
16:59:13 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
16:59:59 <lispy> Pseudonym: maybe you should substritutue computational linguistics and put quant in its place
17:00:26 <newsham> cunning linguists
17:00:42 <Pseudonym> I'm thinking of quants in particular.
17:00:48 <Pseudonym> People who try to predict "the market".
17:00:56 <Pseudonym> As if it's some system in physics.
17:01:09 <Pseudonym> It seems so damn artificial.
17:01:20 <newsham> http://www.nytimes.com/2006/08/13/business/yourmoney/13stra.html?ex=1313121600&en=d53c2829a2daa992&ei=5088&partner=rssnyt&emc=rss
17:01:22 <lambdabot> http://tinyurl.com/p7lmo
17:01:30 <Pseudonym> Oh, bloody hell.  Am I sounding like Smerdyakov?
17:01:37 <xerox> It's fine.
17:02:03 <newsham> "The professors reported that before transaction costs, this portfolio produced an annual average return of 62 percent over the dozen years covered in the study."
17:02:11 <newsham> seems like pretty decent "prediction" of the market to me
17:02:44 <Pseudonym> There's a more moral way to make money, and that's actually to _start_ a business.
17:02:49 <Pseudonym> Actually make something or do something.
17:02:59 <Pseudonym> That's what talented people who want money should be doing.
17:03:21 <newsham> you subscribe to the viewpoint that markets and traders do not add any value to society?
17:03:33 <Pseudonym> No, I'm not saying that.
17:03:39 <lispy> i think that
17:03:41 <Pseudonym> I'm saying that quants add little.
17:03:52 <newsham> you're implying that its not a moral way to make money
17:03:53 <Pseudonym> There's nothing wrong with allowing people to invest in your business.
17:03:58 <Pseudonym> If you have the talent and they have the capital.
17:04:08 <Pseudonym> No, what I'm implying is that playing the market is less moral.
17:04:37 <Pseudonym> It doesn't produce anything.
17:04:40 <Pseudonym> Investing in companies does.
17:04:43 <Pseudonym> Indirectly.
17:04:50 <newsham> "playing the market" allocates assets and conveys important information.
17:04:55 <Pseudonym> As I said, this is not well thought out, so I probably can't argue this correctly.
17:05:36 <Pseudonym> How important is that information?
17:05:44 <Pseudonym> That's not rhetorical, I'm genuinely curious.
17:05:53 <newsham> the information tells members of societies what to produce and what not to produce.
17:06:09 <newsham> as such, I'd say its "invaluable" (or maybe "highly valuable")
17:06:13 <Pseudonym> Oh, you mean the market.
17:06:17 <newsham> i'm sure there are people who would disagree
17:06:18 <Pseudonym> As opposed to the share/stock market.
17:06:32 <Pseudonym> That tells you nothing about what to produce and what not to produce.
17:06:35 <newsham> the stock market and other markets, and day traders and long traders and short traders ...
17:06:48 <Pseudonym> The way to tell what to produce and what not to produce is, surely, to look at your sales.
17:07:13 <Pseudonym> The stock market sells bits and pieces of companies.  That tells you nothing about actual production.
17:07:26 <Pseudonym> What is being bought and sold there is not goods or services.
17:07:57 <newsham> sure it does, if one company is turning a huge profit, they're employees and stock holders will benefit, and it will draw in more resources and more competition.
17:08:40 <Pseudonym> Take Google as an example.
17:08:47 <Pseudonym> Their shares do not pay dividends.
17:08:48 <newsham> if a company that has historically done very well gets rid of its top talent and starts to do poorly, the mraket will quickly penalize them and allocate resources elsewhere
17:09:00 <Pseudonym> By buying Google shares, you're really only buying an idea.
17:09:11 <Pseudonym> And giving Google capital.
17:09:36 <Pseudonym> newsham, I understand the feedback effect.
17:09:45 <Pseudonym> And I don't actually have a huge problem with this.
17:09:59 <Pseudonym> In the sense that investing in good companies is good for the company and the investor.
17:10:03 <Pseudonym> So there's goodness there.
17:10:24 <Pseudonym> The thing is, there gets a point where the analysis is not done on how good a company is.
17:10:44 <Pseudonym> Quants look for patterns in the complexity.  It gets several steps removed from how good a company is.
17:10:50 <newsham> the analysis has nothing to do with how good a company is.  its how the company is valued relative to its true worth
17:10:57 <JKnecht> markets as a mechanism are neutral/moral. As a means for enforcing a social order they may or may not be.
17:11:07 <newsham> its all in the margins.  the potential differences if you will.
17:11:21 <Pseudonym> This doesn't actually address my original assertion.
17:11:27 <Pseudonym> Which is that it's a waste of a good mathematician.
17:12:04 <newsham> its a whole collctive knowledge system,  if there's a bunch of bad knowledge going into the market there's high financial motivation for more knowledgable individuals to put their money into the system and extract profit and in the process drive the market closer to the "truth"
17:13:16 <newsham> in a sense we're paying successful traders for their knowledge.
17:13:18 <lisppaste2> Pupeno annotated #25795 with "There, a bit better, but I bet it is still improvable." at http://paste.lisp.org/display/25795#1
17:13:20 <xerox> What about currency market, I mean where you buy dollars, sell yes, exchange in euros...
17:13:40 <Pseudonym> Which is one step removed from paying successful companies for being good at what they do.
17:14:12 <Pseudonym> Think of it this way:
17:14:20 <newsham> xerox: fundamentally the same ideas though the details differ (which govts are loaning out money at which rates, where the cheap labor is, what the trade surplusses and deficits are, etc)
17:14:22 <Pseudonym> Suppose doing business is a morphism.
17:14:33 <Pseudonym> Then the share market is a functor.  One step abstracted above.
17:14:43 <Pseudonym> Then the quant system is one step further abstracted.  Natural transformation.
17:15:14 <newsham> pseudo: it still provides companies with capital, and in the long term you'd be hard pressed to say that it doesnt provide productive companies with omre capital than unproductive ones.
17:15:15 <Pseudonym> Eventually you get to the point that the system has very little to do with creating goods or services.
17:16:05 <xerox> ....except for how do play in the system?
17:16:10 <newsham> just because there are 2nd order and 3rd order things going on doesnt mean that the HUGE first order effect (allocating resources) isnt functioning
17:16:51 <Pseudonym> You have to wonder how much more money would end up with good companies if it weren't for the middle men on top.
17:16:52 <newsham> underlying the billions of $s going to google is a sound reasoning -- people are expecting google to have big future profits
17:17:29 <newsham> the "middlemen" are the grease that makes the whole thing go!  the less middlemen you have, the slower the process runs and the longer it takes to drive towards steady state
17:18:10 <Pseudonym> I'm not certain that increased speed is a benefit.
17:18:12 <xerox> But once the money has flowed in the company, people will convert shares back to that, hurting the companies?
17:18:35 <newsham> the people triaging between the london market, the currency markets, the US exchanges, etc..  thats what keeps everything somewhat balanced.  and the sheer volume drives the speed that the market can react to changes
17:18:44 <Pseudonym> It means the companies have to redirect resources from doing business to responding to things that have nothing to do with their core business.
17:19:24 <newsham> pseudo: answering to bankers and shareholders has nothing to do with their core business?   well, only if they could do their cor ebusiness without all of our money!
17:19:24 <xerox> Can one open an exchange market? :)
17:19:42 <newsham> xerox: financial trading is regulated by the govt.
17:19:46 <Pseudonym> Companies answer to shareholders directly.
17:20:07 <Pseudonym> It's the answering to the market analysts which is the problem.
17:21:37 <newsham> there are public scandals that point to some flaws, but market analysts exist because they give useful information to people (and act as a proxy for the share holders in many ways)
17:21:45 <newsham> overall a very important part of the system I think.
17:23:19 <xerox> G'night.
17:23:25 <Pseudonym> Night.
17:23:31 <newsham> i used to share a viewpoint like yours that there were these parasitic entities doing this non-productive trading (middlemen, in stocks, in goods, etc)
17:23:55 <newsham> but i'm completely won over to market capitalism after reading a little about it
17:24:42 <Pseudonym> It seems to me a bit like evolution.
17:24:50 <Pseudonym> Evolution finds a local extremum in fitness.
17:25:03 <Pseudonym> But there is a global extremum yet to be found.
17:25:33 <Pseudonym> The kinds of devices which are found by evolution also tend to be more horribly complex than any machine that a human would design.
17:25:48 <newsham> perhaps.  if you know a system for finding global optimality, please tell the world.
17:26:05 <newsham> we've discovered recently that humans arent so good at manual allocation
17:26:22 <Pseudonym> I'm a geek.  The globally optimal solution is obvious: Benevolent dictatorship meritocracy.
17:26:25 <newsham> markets seem to be doing fairly well for us, but still some foibles that allow manipulation (enron!)
17:26:27 <Pseudonym> :-)
17:26:39 <newsham> dictator cant possibly know enough about everything to shift resources around.
17:26:44 <Pseudonym> But more seriously.
17:27:28 <Pseudonym> No engineer would build a light sensor such that the wiring is on the business side of the transducers.
17:27:35 <Pseudonym> But that's the way the human eye works.
17:27:50 <Pseudonym> The market seems similar.
17:27:55 <Pseudonym> To this layperson.
17:28:15 <newsham> right, and engineers still havent made anything that works as well as the brain.
17:28:25 <Pseudonym> Yet.
17:28:26 <alec> lambdabot forgets less!
17:28:29 <newsham> or anything that works as well as a market :)
17:28:41 <Pseudonym> I think we've built sensors better than the eye, though.
17:28:59 <Pseudonym> Perhaps not as long-lived, but certainly better as sensors go.
17:29:09 <SamB> alec: yes, but lambdabot doesn't remember things unless you can remember the keys!
17:29:20 <SamB> and you know how people are with losing their keys!
17:29:36 <alec> :)
17:29:47 <Pseudonym> Perhaps that's the problem.
17:29:54 <Pseudonym> I'm thinking too much like an engineer.
17:30:04 <Pseudonym> I'm thinking that any system should be well-designed.
17:30:17 <Pseudonym> If I thought more like a lawyer, I might feel better about it.
17:30:19 <SamB> I don't think markets are wired right in the US.
17:30:28 <SamB> Lawyers love to make money on lawsuits!
17:30:32 <SamB> don't go by them!
17:30:52 <Pseudonym> That's exactly what I meant. :-)
17:30:53 <newsham> pseudo: our society's resource allocation system already has a machine-friendly interface.
17:31:02 <Pseudonym> The job of a lawyer is to play the system.
17:31:12 <newsham> any system that thinks it can better allocate resources can make a killing off the market.
17:31:25 <newsham> have at it, engineers.
17:31:30 <SamB> umm
17:31:42 <SamB> what if it involves CHANGING THE DAMN LAWS?
17:31:44 <Pseudonym> Any such system would have to operate alongside the current market.
17:31:58 <newsham> (its already happening, to a large degree, there's a lot of data mining and automated trading going on)
17:32:01 <Pseudonym> I guess that's the real issue here.
17:32:07 <Pseudonym> There's only one global financial system.
17:32:11 <Pseudonym> Nothing to compete against.
17:32:17 <SamB> oh yay!
17:32:25 <newsham> pseudo: in a "game" sense, nobody would play against the machine if the machine would always win all the money.
17:32:29 <Pseudonym> So let's go up one more level of abstraction!
17:32:31 <SamB> we just have to terraform mars!
17:32:36 <newsham> so, if it was sufficiently better at humans, then it wouldnt have to operate alongside
17:32:42 <SamB> an engineering problem!
17:33:02 <newsham> s/at/than/
17:33:30 <SamB> newsham: is there a machine-friendly interface to the legal system?
17:33:37 <SamB> with write access for mechanicals?
17:33:47 <newsham> samb: unfortunately there arent any friendly interfaces to the legal system :(
17:34:08 <Pseudonym> The legal system is actually more like nature than the market is.
17:34:08 <SamB> newsham: that is probably not good
17:34:21 <Pseudonym> Except that the laws are constantly changing.
17:34:35 <SamB> I think the US is too big.
17:34:38 <Pseudonym> And that experiments in the legal system are REALLY expensive.
17:34:45 <newsham> pseudo: but precedence has strong powers, so change is very organic
17:34:46 <Pseudonym> You posit a theory, then test it before the courts.
17:34:46 <SamB> Should be split into competing pieces...
17:35:06 <newsham> samb: red state v. blue state?
17:35:13 <SamB> um
17:35:21 <SamB> how about purple and green?
17:35:32 <SamB> red and blue sounds like it has to do with political parties
17:36:01 <qwr> eh, you have the damn states. why you don't use them? ;)
17:36:07 <SamB> or that!
17:36:09 * dylan would like an economic system that was based on lack of scarcity and used food as currency.
17:36:13 <Pseudonym> Don't talk to me about red and blue.  Working on athlete monitoring for amateur boxing has worn me out on that.
17:36:24 <newsham> i wonder what it would be like if all the big financial and tech centers (blue) were separated from the other regions (farming, industrial manufacturing, water and oil resources)
17:36:36 <newsham> would be very interesting at the least
17:36:43 <SamB> newsham: how are those first things blue?
17:37:02 <Pseudonym> Sounds more like white collar vs blue collar.
17:37:08 <newsham> samb: nyc, bay area, LA, pacific northwest, tend towards blue.
17:37:09 * qwr thinks that historically american states were way more independent, than today
17:37:28 <SamB> qwr: you want to back to the articles of confederation?
17:37:40 <newsham> big cities in general vs. rural which tend towards conservative republican.
17:37:46 <Pseudonym> SamB: Do we get to keep slaves?
17:37:56 <SamB> hmm, probably not.
17:38:13 <SamB> I think the states would ban it quickly if it became a problem...
17:39:17 <newsham> http://en.wikipedia.org/wiki/Red_state_vs._blue_state_divide
17:39:19 <lambdabot> http://tinyurl.com/8gorw
17:39:27 <newsham> thats just the way the map ends up being colored
17:41:35 <qwr> SamB: hmm, i live in europe
17:43:34 <sjanssen_> qwr, SamB: even after the Articles of Confederation the states had more influence than nowadays
17:46:23 <Pupeno> is there a function to perform search and replace on strings ?
17:47:08 <sjanssen_> Pupeno: do you need to search and replace single characters, or substrings?
17:47:20 <Pupeno> sjanssen_: substrings.
17:47:43 <Pupeno> I could use regexs, but it's an overkill.
17:48:30 <sjanssen_> regexes are probably the simplest solution here
17:52:03 * glguy finishes mathschallenge
17:52:31 <dolio> Congratulations.
17:53:59 <glguy> thanks :)
17:54:10 <dolio> How fast is your #127?
17:54:25 <glguy> under 1 minute
17:54:27 <glguy> :)
17:54:33 <glguy> I didn't time it exactly
17:54:39 <glguy> probably closer to 40 seconds
17:55:02 <glguy> I know how to really speed it up
17:55:02 <sjanssen_> what is this #127 I keep hearing about?
17:55:23 <dolio> Ah.
17:55:34 <dolio> I've been fooling with mine trying to get it fast.
17:55:43 <glguy> http://mathschallenge.net/index.php?section=project&ref=problems&id=127
17:55:43 <dolio> C penis envy or something like that.
17:55:46 <lambdabot> http://tinyurl.com/l4fxv
17:55:55 <glguy> dolio: have you completed it then?
17:56:12 <glguy> ah, i see you on the bottom of the list
17:56:27 <dolio> Yeah. I finished it a day or two ago, but it was really slow when I first finished.
17:56:56 <dolio> But I read over some of the stuff in the forums and tried some tricks there.
17:56:57 <SamB> sjanssen_: so where did the influence go? national TV?
17:57:30 <dolio> Although all the tricks make things uglier. :)
17:57:35 <sjanssen_> SamB: the federal government
17:57:43 <glguy> dolio: my code was really clean...
17:57:53 <glguy> dolio: I don't think that the trick in the forums make it oto bad
17:58:08 <glguy> unless you are tlaking about more than memoization and sorting
17:58:33 <dolio> Well, I wrote the rad sieve using STUArray.
17:59:08 <SamB> sjanssen_: so how did the federal government get it?
17:59:21 <SamB> and how do we get it back?
17:59:27 <dolio> Any my function for generating triples does all the work now with a list comprehension and a huge where clause.
17:59:53 <dolio> Because I want to generate the sieve array only once.
18:00:21 <glguy> yeah.. that's the memoization I was referring to
18:00:49 <dolio> It's pretty fast, though. :) Around 2 seconds.
18:02:02 <dolio> Although that's a lot longer than the 60 ms that some people on there cite.
18:02:07 <glguy> heh
18:02:20 <glguy> I was a bit rushed... I was doing it at work (instead of actually working)
18:02:41 <dolio> Heh.
18:02:55 <glguy> So I was doing it in visual haskell because it looks close enough to VS.NET 2005
18:03:04 <dolio> Ah. That's handy.
18:03:40 <dolio> I don't think I can make it much faster without rewriting it so it doesn't do list processing, though.
18:04:29 <glguy> I did all of the problem with list processing
18:04:46 <glguy> in some extreme cases I used UA
18:04:48 <glguy> Uarrays
18:05:24 <dolio> Yeah. That'll get the job done.
18:06:06 <dolio> But I wanted to make sure that Haskell could beat TCL on the problem. :)
18:06:47 <glguy> There are some gruesome solutions to some of those problems in the forums
18:07:14 <glguy> If I wrote 10 pages of for loops... I sure wouldn't admit to it by posting the whole thing in a forum
18:07:26 <dolio> Yeah, the guy that posts delphi solutions...
18:07:33 <dolio> It's just a page long block of text.
18:07:33 <glguy> when other people are solving it in 4 lines of J
18:08:16 <dolio> Heh, yeah, I was impressed with the J solution to 124.
18:08:26 <dolio> Especially since they said it runs in less than a second.
18:08:42 <glguy> J does really well with factoring numbers and generating primes
18:08:44 <dolio> Where my Haskell algorithm that does things about the same way takes several seconds.
18:09:02 <dons> ?users
18:09:03 <lambdabot> Maximum users seen in #haskell: 242, currently: 213 (88.0%), active: 30 (14.1%)
18:10:25 <dolio> I guess since it's built into the language, they can write factoring and such in highly tuned C or something.
18:11:17 <glguy> rad in J is  ~.&.q:
18:11:59 <sjanssen_> SamB: it was a gradual trend since the Civil War (which was essentially about states rights)
18:12:00 <glguy> or rather "radical"
18:12:18 <SamB> wow.
18:12:21 <SamB> just... wow.
18:12:35 <dolio> I was going to try out the 'Learning Maths in Haskell' code for the factoring on those problems, but the factoring code was missing. :)
18:12:40 * SamB never thought he was going to say this... but he almost wishes the south won!
18:13:04 <SamB> dolio: haha
18:13:18 <sjanssen_> SamB: how come?
18:13:20 <dolio> Although for numbers that small, I don't know if they'd be appreciably faster.
18:13:38 <glguy> I used http://www.polyomino.f2s.com/david/haskell/numbertheory.html for my factoring code
18:13:41 <lambdabot> Title: Basic Number Theory in Haskell, http://tinyurl.com/g7alh
18:14:20 <dolio> Right, that's where I went, but both the FactoringECM and FactoringCFRAC were 404.
18:14:37 <glguy> oh
18:14:43 <dolio> Still are.
18:15:20 <SamB> sjanssen_: I do not like such a concentration of power!
18:15:32 <glguy> what are you two talking about?
18:15:36 <glguy> are you both watching a TV show?
18:15:43 <glguy> listening to a radio stream?
18:15:44 <SamB> except, I wouldn't likely be here if the south had won...
18:15:50 <SamB> glguy: no...
18:15:58 <dolio> The primes module has a factoring algorithm, too, but it just does trial division against a list of primes.
18:15:59 <glguy> reading a blog?
18:16:04 <SamB> no...
18:16:26 <glguy> dolio: I just used the trial division factoring algorithm for everything :)
18:17:25 <dolio> Yeah, it's probably not much worse for numbers as small as 100,000.
18:17:52 <dolio> When they start posting problems with 4000 bit numbers, maybe the other modules will be useful. :)
18:19:11 <glguy> I typed > 2^4000 in PM to lambdabot and it got 7 lines back :)
18:19:31 <glguy> where 6 of the lines spanned 3 terminal lines each
18:19:50 <glguy> I didn't expect lambdabot to go through with it
18:20:03 <dolio> Heh.
18:23:36 <dolio> ?type fmap (read . head)
18:23:37 <lambdabot> forall (f :: * -> *) a. (Functor f, Read a) => f [String] -> f a
18:25:39 <glguy> dolio: I thought that it was going to be cool to finish the problems... now I'm just bored
18:26:11 <dolio> :) You could start in on the other site mentioned on haskell-cafe.
18:26:17 <glguy> spoj?
18:26:21 <dolio> Yeah.
18:27:10 <glguy> It'd be more fun if they had FPS installed... I get tired of IO getting in the way
18:27:34 <glguy> and having to constantly battle IO speed instead of the algorithm itself
18:27:55 <dolio> I guess that would be a pain.
18:28:35 <glguy> it sucks to solve the problem on your machine, and then find out that you don't know how tot do the IO fast enough to turn it in
18:29:00 <dolio> ?hoogle [Maybe a] -> [a]
18:29:01 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
18:29:20 <glguy> sequence
18:29:23 <glguy> ?
18:29:43 <dolio> Hmm...
18:30:03 <glguy> if you want to verify that they are all Just
18:30:07 <dolio> > sequence [Just 2, Just 3, Nothing, Nothing] :: [Int]
18:30:08 <lambdabot>  Couldn't match `Int' against `[a]'
18:30:10 <glguy> and get the list back
18:30:19 <dolio> > (sequence [Just 2, Just 3, Nothing, Nothing]) :: [Int]
18:30:19 <lambdabot>  Couldn't match `Int' against `[a]'
18:30:39 <dolio> > (sequence [Just 2, Just 3, Nothing, Nothing]) :: Maybe [Int]
18:30:40 <lambdabot>  Nothing
18:30:41 <glguy> > concat $ map maybeToList [Just 2, Just 3, Nothing, Nothing]
18:30:42 <lambdabot>  [2,3]
18:31:10 <dolio> catMaybes [Just 2, Just 3, Nothing, Just 4] :: [Int]
18:31:11 <glguy> > maybeToList =<< [Just 2, Just 3, Nothing, Nothing]
18:31:12 <lambdabot>  [2,3]
18:31:16 <dolio> > catMaybes [Just 2, Just 3, Nothing, Just 4] :: [Int]
18:31:17 <lambdabot>  [2,3,4]
18:31:25 <glguy> serious?
18:31:29 <glguy> ?type catMaybes
18:31:30 <lambdabot> forall a. [Maybe a] -> [a]
18:31:35 <glguy> heh
18:34:53 <dons> can you ask to have fps installed?
18:36:20 <glguy> maybe?
18:37:19 <sjanssen_> glguy: emu made a request to install fps in the SPOJ forums, I'm not sure how that's going
18:37:37 <glguy> if it works , it's going to be amazing :)
18:37:50 <dolio> ?pl \(x,y) -> [x,y]
18:37:51 <lambdabot> uncurry ((. return) . (:))
18:37:51 <glguy> I'll have something to do with my free time ... at work ;)
18:38:01 <dons> hehe
18:38:21 <dons> i suppose once 6.6 comes out we can use that instead/
18:38:28 <dons> and get both regex and fps for free
18:38:28 <glguy> looking forward to it...
18:39:04 <glguy> I'm both elated to hear about regex and disgusted ;)
18:39:10 <dons> hmm?
18:39:26 <glguy> I like using regex, i just relate it to perl
18:39:29 <dons> bytestring-based regexes should solve at least 1 language shootout issue too :)
18:39:32 <glguy> or associate it, rather
18:39:36 <dons> ah
18:39:53 <dons> SamB: your patch isn't quite right
18:39:54 <glguy> but I think that the only reason that I don't like perl is that i don't know it well
18:40:02 <glguy> since I love J, and it's ugly
18:40:08 <dons> SamB, pid2phdl pid = ProcessHandle pid is for ghc 6.4, and 6.4.1
18:40:30 <SamB> dons: hmm, let me look at it again...
18:40:34 <dons> but in 6.4.2 we have pid2phdl pid = unsafePerformIO $ mkProcessHandle pid
18:40:38 <dons> (and in 6.5)
18:40:52 <dons> and since there's no way to distinguish minor versions in cpp (we're not supposed to)
18:41:01 <dons> we just have to live with it: you need ghc 6.4.2
18:41:16 <SamB> does hmp3 even run on Windows?
18:41:28 <dons> i've heard tell that its possible
18:41:57 <SamB> who the hell came up with this version scheme?
18:42:12 <SamB> where minor versions are indistinguishable?
18:42:14 <dons> well, it all works well, as long as the apis don't change between minor releases
18:42:22 <dons> which is supposed to be the case
18:42:23 <SamB> but the interface does change?
18:42:29 <dons> however, it did change this one thing
18:43:12 <dons> (note that itsSystem.Process.Internals, which maybe isn't supposed to be exposed)
18:43:19 <SamB> of course it is!
18:43:23 <dons> so it may well be my own fault :)
18:43:25 <SamB> it is in the base package
18:43:33 <SamB> everything in the base package is exposed!
18:44:01 * SamB rather likes this fact ;-)
18:44:10 <dons> anyway, you know how to build it on 6.4.{1,0}, but since 6.4.2 is standard now, i'll not apply the patch
18:44:14 <dons> heh
18:44:38 <glguy> dolio: Are you still there?
18:44:44 <dolio> Yeah.
18:44:53 <SamB> it means I don't have to be afraid some vital internals module will be hidden ;-)
18:44:53 <glguy> Have you looked at 61 yet?
18:45:06 <dolio> Hmm.. Not yet.
18:45:30 <glguy> You need to solve it so that we can discuss solutions
18:45:36 <glguy> I'd like to see another Haskell solution
18:45:40 <SamB> too bad autoconf doesn't know how to check for functions in Haskell modules...
18:45:44 <dolio> Hmm, all right.
18:45:54 <SamB> that would be sweet for this!
18:55:16 <dons> dylan: did you find your Arbitrary instance for QuickCheck?
18:55:45 <dons> here, instance Arbitrary P.ByteString where
18:55:46 <dons>   arbitrary = P.pack `fmap` arbitrary
18:55:46 <dons>   coarbitrary s = coarbitrary (P.unpack s)
18:57:08 <dons> ah, I see sjanssen_ found one for you anyway. good
18:58:53 <dylan> dons: yep.
18:59:11 <dylan> and I figured out one for Char by myself.
18:59:26 <dons> ok. i've a few instances here http://www.cse.unsw.edu.au/~dons/code/fps/tests/QuickCheckUtils.hs
18:59:28 <lambdabot> http://tinyurl.com/mwg5s
18:59:40 <dons> instance Arbitrary Char where
18:59:40 <dons>   arbitrary = choose ('\0', '\255')
18:59:43 <dons> for example
19:00:12 <dons> and a couple here http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
19:00:13 <lambdabot> http://tinyurl.com/q2vhr
19:00:55 <hitodama> Does anyone have any resources on genetic programming in Haskell other than the things listed on the Haskell wiki?
19:03:43 <dons> weitzman: you had some weird error with lambdabot?
19:06:58 <weitzman> Oh yes
19:07:02 <weitzman> It was with ghc, actually
19:07:13 <weitzman> If by weird error you mean typo in an error message
19:07:40 <dylan> hmm, while it seems haskell is unknown at my university, the math department has some related research.
19:07:58 <weitzman> dons: However since my IRC client isn't configured to log, I can't replicate the error message
19:08:12 <weitzman> I believe it included the word "assumptionss"
19:08:27 <wkh> what are the haps my friends
19:09:00 <dmwit> Word to your maternal, wkh.
19:09:08 <glguy> sheit
19:09:21 <glguy> dons, what would coarbitrary for Char be?
19:09:27 <glguy> dons ord?
19:09:37 <weitzman> The lambda expression `\ Just x -> ...' has two argumentss,
19:09:50 <weitzman> Aha
19:10:04 <weitzman> I blame Simon Peyton Jones
19:10:08 <weitzman> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2005-July/005307.html
19:10:12 <lambdabot> Title: [ ghc-Bugs-1231273 ] confusing error, http://tinyurl.com/hkxu4
19:10:29 * araujo would take it as one argument
19:11:29 <weitzman> dons: Although I think my function that's never satisfied with how many arguments it has is cooler
19:12:05 <weitzman> I've just plain forgotten it though
19:13:26 <weitzman> Aha
19:15:31 <dons> glguy:   coarbitrary c = variant (ord c `rem` 16)
19:16:22 <dons> ok, interesting . weitzman, you're doing some haskell exploratoin with lambdabot, I take it?
19:16:49 <weitzman> Indeed
19:17:46 <dons> cool. let me know if you have any feedback (or if you install it locally -- any build/use issues)
19:18:20 <glguy> How do people survive with the capslock not being the control key???
19:18:26 <weitzman> If I get around to installing anything locally I think I may go directly to the haskell interactive prompt
19:18:29 <glguy> I'm on my mom's computer... it's terrible
19:18:30 <weitzman> Hardcore
19:18:44 <weitzman> If you change it, she won't notice
19:18:45 <dons> hehe ok:)
19:19:35 <weitzman> The thing that bothers me is the little indentation in the capslock key. Once you've switched it to control, there's no harm in accidentally pressing it
19:20:05 <glguy> my keyboard at home doesn't have one of those indentations
19:20:35 <weitzman> Neat
19:20:54 <stepcut> my keyboard at home has Control in the right place :)
19:21:31 <weitzman> Sun?
19:21:37 <stepcut> happy hacker keyboard lite 2
19:21:43 <dons> stepcut, me too!
19:21:57 <stepcut> same layout as the Sun III (i think)
19:21:58 <glguy> I need to blow a bunch of money on one of those "Das Keyboards" or the one that looks like it has two holes for your hands or the happy hacker keyboard or something :)
19:21:59 <dons> though modmap makes it easy enough to map caps lock to ctrl wherever i go
19:22:01 <dolio> > print (1, 2, 3, 4, 5, 6)
19:22:01 <lambdabot>  No IO allowed
19:22:11 <dolio> > (1, 2, 3, 4, 5, 6)
19:22:12 <lambdabot>  (1,2,3,4,5,6)
19:22:16 <glguy> My Powerbook has a setting to fix the control key in Preferences
19:22:26 <stepcut> http://images.google.com/imgres?imgurl=http://www.pfu.fujitsu.com/en/hhkeyboard/images/lite2_us_top.jpg&imgrefurl=http://www.pfu.fujitsu.com/en/hhkeyboard/leaflet/photo.html&h=410&w=897&sz=73&hl=en&start=2&tbnid=y6tBo4McgLuKrM:&tbnh=67&tbnw=146&prev=/images%3Fq%3Dhappy%2Bhacker%2Bkeyboard%2Blight%2B2%26svnum%3D10%26hl%3Den%26lr%3D%26ie%3DUTF-8%26c2coff%3D1%26safe%3Doff%26sa%3DN
19:22:29 <lambdabot> Title: Google Image Result for http://www.pfu.fujitsu.com/en/hhkeyboard/images/lite2_us ..., http://tinyurl.com/j96bq
19:22:37 <dolio> 6-tuples aren't showable?
19:22:38 <stepcut> heh, I see the need for the tinyurl :)
19:22:46 <dons> dolio: they are up to 7, iirc
19:22:56 <glguy> i was about to say that stepcut :)
19:23:12 <lennart> > (1,2,3,4,5,6,7)
19:23:13 <lambdabot>  (1,2,3,4,5,6,7)
19:23:21 <weitzman> If I were going to make a happy hacking keyboard, I wouldn't bother with the right Alt button
19:23:25 <dons> or maybe its 15 now?
19:23:27 <dolio> > (1,2,3,4,5,6,7,8)
19:23:28 <lambdabot>  (1,2,3,4,5,6,7,8)
19:23:43 <dons> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
19:23:45 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
19:23:47 <stepcut> weitzman: I think I actually use the right alt sometimes
19:23:50 <dons> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
19:23:50 <glguy> > (,,) 'w' 'o' 'w'
19:23:51 <lambdabot>     add an instance declaration for (Show (a,
19:23:51 <lambdabot>               ...
19:23:52 <lambdabot>  ('w','o','w')
19:23:54 <dons> :)
19:24:14 <dolio> The ghc hierarchical modules say up to 5, I guess. Maybe >5 is in 6.6.
19:24:24 <weitzman> Is there any logical way to conclude the following statement in Haskell:
19:24:26 <weitzman> > msum [(+ 1), (* 3)]
19:24:27 <lambdabot>  add an instance declaration for (MonadPlus ((->) a))
19:24:27 <lambdabot>   In the definition ...
19:24:45 <weitzman> I don't actually know what msum does
19:24:56 <weitzman> But I know the type!
19:24:56 <stepcut> weitzman: maybe you'd add some other keys like this one ? http://www.pfu.fujitsu.com/en/hhkeyboard/images/Lite2JP_b.jpg
19:24:59 <glguy> msum is foldr mplus mzero
19:25:00 <lambdabot> http://tinyurl.com/goa2j
19:25:06 <glguy> i believe
19:25:22 <lennart> The Haskell standard requires Show for all tuples (unless H98 changed that), but few implementations get that right.
19:25:24 <glguy> > msum [Nothing, Just 1, Just 2, Nothing]
19:25:25 <lambdabot>  Just 1
19:25:54 <glguy> for lists, msum is concat
19:25:57 <dons> lennart: [56] Not an instance Prelude.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) ;)
19:26:08 <dons> s/few/any ?
19:26:10 <weitzman> @pl msum [Nothing, Just 1, Just 2, Nothing]
19:26:11 <lambdabot> msum [Nothing, Just 1, Just 2, Nothing]
19:26:18 <glguy> > msum [[1,2],[],[3,4]]
19:26:19 <lambdabot>  [1,2,3,4]
19:26:21 <lennart> dons: Yale Haskell had it
19:26:38 <dons> oh, nice.
19:28:02 <glguy> @instances-importing MonadPlus
19:28:03 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
19:28:31 <glguy> > Left 1 `mplus` Right 2
19:28:32 <lambdabot>  add an instance declaration for (MonadPlus (Either a))
19:28:32 <lambdabot>   In the definitio...
19:28:55 <dons> not importing MonadPlus maybe
19:29:00 <dons> I'll add it
19:29:22 <glguy> I figured that I screwed something up :)
19:29:28 <glguy> It didn't occur to me to blame lambdabot
19:30:06 <weitzman> This is not the error message I expected:
19:30:06 <weitzman> @free mplus
19:30:07 <lambdabot> Expected variable or '.'
19:30:22 <dons> there's a kind annotation breaking @free
19:30:28 <dons> ?type mplus
19:30:29 <weitzman> Oh
19:30:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:30:38 <dons> ?free M a -> M a -> M a
19:30:38 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:30:46 <dons> ?free mplus :: M a -> M a -> M a
19:30:47 <lambdabot> $map_M f . mplus x = mplus ($map_M f x) . $map_M f
19:31:02 <weitzman> @type map_M
19:31:04 <lambdabot> Not in scope: `map_M'
19:31:17 <dons> free generates code not-quite-haskell
19:31:25 <glguy> but there is a mapM :)
19:31:27 <dons> in this case $map_M == mapM, I think
19:32:03 <dons> ?free foldl
19:32:05 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
19:32:57 <glguy> > runState (mapM (modify (1+)) [(),(),()]) 0
19:32:58 <lambdabot>  Couldn't match `State s b' against `()'
19:33:25 <glguy> did I get that backwards?
19:35:42 <glguy> > runState (mapM (const (modify (+1))) [(),(),()]) 0
19:35:43 <lambdabot>  ([(),(),()],3)
19:57:36 <glguy> 21:29  glguy> It didn't occur to me to blame lambdabot
19:57:36 <glguy> 21:29  weitzman> This is not the error message I expected:
20:02:24 <lennart> ?
20:02:49 <kpreid> weitzman: earlier you mentioned composing functions from a list. flip (foldr ($)) or flip (foldl (flip ($))) will do that
20:03:29 <weitzman> I was trying to figure out mplus and how functions get interpreted as Monad
20:03:54 <kpreid> it's the reader monad
20:03:56 <weitzman> Or more specifically, I was trying to understand my crazy function that refused to actually run
20:04:24 <weitzman> I've been typing random stuff into lambdabot and watching what happens
20:04:37 <kpreid> see Control.Monad.Reader
20:04:38 <weitzman> And I keep stepping beyond what I'm probably ready to think about
20:04:53 <kpreid> yes, I would recommend not thinking about the reader monad :)
20:05:35 <dons> has lambdabot become a gateway drug to hardcore haskell?
20:05:56 * dons hopes so
20:06:16 <weitzman> I don't actually have anything I want to write in Haskell, and even if I did I don't think I would *need* to learn much about things like "fix" and "liftM2" and "msum" and other madness
20:06:36 <weitzman> But they amuse me
20:06:43 <dons> they're fun, yes :)
20:06:56 <dons> you've played with @pl ?
20:07:02 <dons> or @djinn ?
20:07:05 <weitzman> A bit
20:07:08 <weitzman> Well, djinn is very boring
20:07:23 <weitzman> But pl keeps giving me things to think about
20:07:26 <dons> its good once you add more types to the default state
20:07:33 <dons> then you can start proving some fun things
20:07:46 <dons> also, @free and @ft can be good
20:07:47 <kpreid> weitzman: write stuff in the straightforward way, then add things like liftM when you get sick of the verbosity
20:07:53 <weitzman> Like (f .) . b should be \
20:07:59 <weitzman> \x y -> f (b x y)
20:08:00 <weitzman> I think
20:08:07 <dons> ?pl \x y -> f (b x y)
20:08:07 <lambdabot> (f .) . b
20:08:10 <weitzman> @pl \x y = f (b x y)
20:08:10 <lambdabot> (line 1, column 6):
20:08:11 <lambdabot> unexpected "="
20:08:11 <lambdabot> expecting pattern or "->"
20:08:17 <dons> would be good to have @unpl
20:08:44 <kpreid> weitzman: haskell uses -> when the thing on the left is a pattern, and = when it is a binding
20:09:04 <dons> ah, kpreid, that's a good explanation
20:09:17 <dfranke> Is it necessary to subscribe to haskell@haskell.org in order to post to it?
20:09:23 <weitzman> I encountered the "ap" function because of @pl, actually
20:09:26 <dons> yep, i think so, dfranke
20:09:32 <dons> do you have an announcement to make?
20:09:37 <dfranke> Yes
20:09:57 <dons>  maybe @pl is the gateway drug to hardcore monads
20:10:04 <weitzman> I said something like this:
20:10:05 <weitzman> @pl let x = 1 : 1 : (zipWith (+) x (tail x))
20:10:05 <lambdabot> (line 1, column 41):
20:10:05 <lambdabot> unexpected end of input
20:10:05 <lambdabot> expecting variable, "(", operator, ":", "++", ";" or "in"
20:10:15 <weitzman> oops
20:10:16 <dons> ?pl x = 1 : 1 : (zipWith (+) x (tail x))
20:10:17 <lambdabot> x = fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
20:10:19 <kpreid> i see a parsec error!
20:10:29 <weitzman> Yeah
20:10:33 <weitzman> That's what it said
20:11:39 <weitzman> (ap (zipWith (+)) tail) is weird
20:11:52 <weitzman> > (ap (zipWith (+)) tail) [1, 2, 3, 4]
20:11:53 <lambdabot>  [3,5,7]
20:11:59 <dons> ?type (ap (zipWith (+)) tail)
20:12:00 <lambdabot> forall b. (Num b) => [b] -> [b]
20:12:19 <dons> ?type (ap (zipWith (+)))
20:12:20 <lambdabot> forall b. (Num b) => ([b] -> [b]) -> [b] -> [b]
20:12:45 <kpreid> ?type ap
20:12:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
20:13:09 <Pseudonym> ?free ap :: M (a -> b) -> M a -> M b
20:13:09 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map_M h x = y) => $map_M g . ap x = ap y . $map_M f
20:13:20 <weitzman> @check \x -> (ap (zipWith (+)) tail) x == zipWith (+) (tail x) x
20:13:20 <lambdabot>  Add a type signature
20:13:30 <weitzman> @check \x -> (ap (zipWith (+)) tail) x == zipWith (+) (tail x) :: [Int] -> Bool
20:13:31 <lambdabot>    Expecting a function type, but found `a'       Expected type: [b],      ...
20:13:56 <weitzman> @check \x -> (ap (zipWith (+)) tail) x == zipWith (+) x (tail x) :: [Int] -> Bool
20:13:57 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: [Int] -...
20:14:01 <weitzman> I lose
20:14:37 <kpreid> Is there a way to find the type of ap given that m is some more specific type (e.g. (->) a)?
20:14:42 <weitzman> @check (\x -> (ap (zipWith (+)) tail) x == zipWith (+) x (tail x)) :: [Int] -> Bool
20:14:44 <lambdabot>  OK, passed 500 tests.
20:14:47 <dons> ?check \x -> (ap (zipWith (+)) tail) x == zipWith (+) (tail x) (x :: T)
20:14:48 <lambdabot>  Exception: Prelude.tail: empty list
20:14:57 <dons> ?check \x -> (not . null $ x) ==> (ap (zipWith (+)) tail) x == zipWith (+) (tail x) (x :: T)
20:14:58 <lambdabot>  OK, passed 500 tests.
20:14:59 <weitzman> @check (\x -> (ap (zipWith (-)) tail) x == zipWith (-) x (tail x)) :: [Int] -> Bool
20:15:01 <lambdabot>  OK, passed 500 tests.
20:15:10 <weitzman> @check (\x -> (ap (zipWith (-)) tail) x == zipWith (-) (tail x) x) :: [Int] -> Bool
20:15:11 <lambdabot>  Exception: Prelude.tail: empty list
20:16:03 <weitzman>  @check (\x -> not . null $ x ==> (ap (zipWith (-)) tail) x == zipWith (-) (tail x) x) :: [Int] -> Bool
20:16:16 <dons> ^^ leading space
20:17:04 <weitzman> @check (\x -> (not . null $ x) ==> (ap (zipWith (-)) tail) x == zipWith (-) x (tail x)) :: [Int] -> Bool
20:17:05 <lambdabot>  Couldn't match `Bool' against `Property'
20:17:19 <weitzman> That's odd
20:18:01 <weitzman> I'm going to assume that if I could get that to typecheck, the test would fail
20:18:02 <dons> ?check \x -> (not . null $ x) ==> (ap (zipWith (-)) tail) x == zipWith (-) (x::T) (tail x)
20:18:03 <lambdabot>  OK, passed 500 tests.
20:18:27 <weitzman> Hmm
20:18:28 <stepcut> heh
20:18:31 <dons> ?check \x -> (not . null $ x) ==> (ap (zipWith (-)) tail) x == zipWith (+) (x::T) (tail x)
20:18:32 <lambdabot>  Falsifiable, after 3 tests: [-2,0,2]
20:18:34 <stepcut> neat
20:18:42 <dons> stepcut: you like?
20:18:54 <dons> i hoping it will introduce people to quickcheck
20:18:57 <stepcut> yeah
20:19:07 <weitzman> ?check \x -> (not . null $ x) ==> (ap (zipWith (-)) tail) x == zipWith (-) (tail x) (x::T)
20:19:08 <lambdabot>  Falsifiable, after 5 tests: [1,3]
20:19:12 <stepcut> people should learn and use quickcheck+hunit early on
20:19:12 <weitzman> Aha
20:19:19 <glguy> > let fibs = 1:1: ap (zipWith (+)) tail fibs in take 10 fibs
20:19:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
20:19:32 <dons> I agree.
20:19:44 <dons> so now people learn pointfree and Monad ((->) a) early one :)
20:19:44 <glguy> It didn't occur to me before ot use ap for fibs before I saw you just do it
20:21:49 <weitzman> I know there's some lambdabot command that replaces the do -> notation
20:22:06 <glguy> undo?
20:22:11 <weitzman> Aha
20:22:12 <weitzman> Yeah
20:22:15 <dfranke> Alrighty, new toy announced on the mailing list.
20:22:22 <glguy> link?
20:22:25 <dons> ?undo do x <- y ; return x
20:22:25 <lambdabot> y >>= \ x -> return x
20:22:33 <dfranke> http://daniel.franke.name/latex-lhs-mode.el
20:22:39 <dons> ?. pl undo do x <- y ; return x
20:22:40 <lambdabot> y
20:22:45 <weitzman> In my happy little world of learning, I wish something undo-like could partially evaluate things like msum and show me what they really do
20:23:12 <dons> do you have an example of what you'd like to see done?
20:23:17 <glguy> msum [Just 1, Just 2] == Just 1 `mplus` (Just 2 `mplus` mzero)
20:23:28 <weitzman> Something like that
20:23:30 <newsham> ?pl do r <- x; y; return r
20:23:30 <lambdabot> (line 1, column 10):
20:23:30 <lambdabot> unexpected ";"
20:23:30 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
20:23:30 <dons> so do a couple of reductions?
20:23:31 <weitzman> maybe
20:23:32 <weitzman> I'm not sure
20:23:43 <newsham> ?pl do { r <- x; y; return r }
20:23:43 <lambdabot> (line 1, column 4):
20:23:43 <lambdabot> unexpected "{"
20:23:43 <lambdabot> expecting variable, "(", operator or end of input
20:23:46 <dons> i could hook in hat and do just this, I think.
20:23:59 <glguy> ?. pl undo do { r <- x; y; return r }
20:23:59 <lambdabot> (y >>) . return =<< x
20:24:01 <newsham> ?pl \x y -> do { r <- x; y; return r }
20:24:01 <lambdabot> (line 1, column 12):
20:24:01 <lambdabot> unexpected "{"
20:24:01 <lambdabot> expecting variable, "(", operator or end of input
20:24:08 <dolio> glguy: Finished.
20:24:08 <weitzman> Basically, functions that don't involve monads are easy to understand, often from the type alone
20:24:14 <glguy> 61?
20:24:15 <weitzman> But functions that do are not so easy
20:24:22 <dolio> Yep.
20:24:27 <glguy> did you post to the forum?
20:24:30 <dons> unless they're in IO :)
20:24:35 <dolio> No, but I could.
20:24:37 <dons> then they're pretty simple, aren't they?
20:24:46 <glguy> did you look at my solution in the forum?
20:24:53 <dolio> No, I just got done.
20:24:57 <glguy> oh, heh
20:25:01 <glguy> well post, I want ot see how you did it
20:27:29 <dolio> How do you enclose things in the yellow boxes? [code][/code] ?
20:27:34 <glguy> exactly
20:28:16 <dolio> Bah, my lines are too long.
20:29:08 <glguy> I never knew you could do: f, g :: Int
20:31:25 <dolio> There we go, now it fits.
20:32:23 <glguy> cool, I probably should have used the divMod too... I didn't know about that function either
20:32:27 <dolio> Yeah, I don't think any of the tutorials I ever read mentioned that syntax, but I've seen it sprinkled in various mailing list messages and such.
20:34:32 <glguy> but other than the minor details, I'd say the solutions approach the problem the same way
20:35:20 <glguy> there were just some wild solutions in the other languages, thought it'd be interesting to see what you did in haskell
20:35:50 <dolio> Yeah. They look about the same.
20:36:15 <dolio> Although I did some cheapo tagging of the lists instead of writing a fancy permutation function like you did. :)
20:36:57 <dolio> Wow, someone wrote a solution in VBA?
20:37:39 <glguy> that's probably the same guy that used VBA's builtin date functions for the question about Sundays that fall on the 1st
20:39:52 <dolio> Heh, I like the perl guy who wrote out his arrays explicitly.
20:51:56 <dolio> ?hoogle Char -> Int
20:51:56 <lambdabot> Char.digitToInt :: Char -> Int
20:51:57 <lambdabot> Char.ord :: Char -> Int
20:52:04 <dolio> > ord 'c'
20:52:05 <lambdabot>  99
20:52:14 <dolio> > ord 'C'
20:52:15 <lambdabot>  67
20:55:31 <Patterner> digitToInt '0'
20:55:35 <Patterner> > digitToInt '0'
20:55:36 <lambdabot>  0
20:55:40 <Patterner> > digitToInt 'a'
20:55:41 <lambdabot>  10
20:55:45 <Patterner> > digitToInt 'z'
20:55:47 <lambdabot>  Exception: Char.digitToInt: not a digit 'z'
20:55:55 <Patterner> but 'a' is? :)
20:56:21 <dolio> span (',' /=) "foo,bar,baz"
20:56:24 <dolio> > span (',' /=) "foo,bar,baz"
20:56:25 <lambdabot>  ("foo",",bar,baz")
20:56:28 <dons> hex?
20:56:52 <Patterner> not really
20:57:04 <Patterner> > hexdigitToInt 'f'
20:57:05 <lambdabot>  Not in scope: `hexdigitToInt'
20:57:09 <Patterner> > digitToInt 'f'
20:57:10 <lambdabot>  15
20:57:12 <Patterner> > digitToInt 'g'
20:57:13 <lambdabot>  Exception: Char.digitToInt: not a digit 'g'
20:58:40 <lispy> > break (==',') "foo,bar,baz"
20:58:41 <lambdabot>  ("foo",",bar,baz")
20:58:57 <lispy> guess that's the same as the span above
20:59:00 <lispy> ?type span
20:59:02 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:59:53 <dolio> break p == span (not . p)
21:00:42 <dons> lambdabot> let x = 1
21:00:42 <dons> Defined.
21:00:42 <dons> lambdabot> > L.x
21:00:42 <dons>  1
21:00:44 <dons> :)
21:01:51 <lispy> oh
21:01:53 <lispy> shiny
21:02:05 <lispy> dons++
21:03:26 <lispy> so i told my advisor i want to either work on a scene graph library in haskell or darcs for my masters project
21:03:43 <lispy> and he said, "Let's have a meeting"
21:03:47 <lispy> so um...
21:04:01 <Patterner> "Is it Visual Basic compatible?"
21:04:04 <lispy> that's makes we think he is not sold :)
21:04:11 <lispy> heh
21:04:17 <lispy> darcs.NET
21:04:18 <dons> yikes :)
21:04:20 <Pseudonym> A meeting will kill almost any good idea.
21:04:37 <lispy> ?remember Pseudonym A meeting will kill almost any good idea.
21:04:37 <Patterner> And 1.5% of brain cells of the people in the meeting.
21:04:50 <Patterner> 3% if you wear a tie.
21:05:24 <dons> oh, I think the effect of ties are underappreciated in the literature
21:05:31 <dons> so perhaps higher, maybe 15%
21:05:47 <lispy> he's a professor of graphics and animation...so the scene graph idea is not novel but a least something he might find interesting..and no one appears to have done it in haskell yet
21:05:49 * Pseudonym ties the knot
21:06:06 <Patterner> congrats :)
21:06:26 <Pseudonym> ?google TyingTheKnot
21:06:32 <lambdabot> http://www.tyingtheknot.net/
21:06:32 <lambdabot> Title: Tying the Knot Photography
21:06:32 <Pseudonym> But thanks anyway!
21:06:36 <Pseudonym> Oh.
21:06:39 <Pseudonym> Weird.
21:06:43 <Pseudonym> ?google TyingTheKnot haskell
21:06:47 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
21:06:47 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
21:06:49 <Pseudonym> That's it.
21:07:15 <Patterner> TtK is slang for marriage in german :)
21:07:35 * lispy in america too
21:07:46 <Pseudonym> Yup.
21:08:03 <dylan> tying the knot is slang for marriage in english too.
21:14:57 <dibblego> is there an online reference of standard libraries?
21:16:42 <dons> yes, front page of haskell.org should get you there
21:16:48 <dons> ?docs Data.List
21:16:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:16:52 <dons> for example
21:38:09 <dons> ?users
21:38:11 <lambdabot> Maximum users seen in #haskell: 242, currently: 211 (87.2%), active: 24 (11.4%)
21:38:59 <jcreigh> How is "active" calculated? Spoke in last X minutes?
21:39:47 <thetallguy> woof
21:39:50 <thetallguy> ?users
21:39:51 <lambdabot> Maximum users seen in #haskell: 242, currently: 212 (87.6%), active: 26 (12.3%)
21:39:58 <jcreigh> heh
21:43:17 <dons> ?help users
21:43:18 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in last 4 hours
21:43:40 <dons> ok, so that's not really a defn of active. but close
21:44:21 <lisppaste2> GeoffSK pasted "test for same constructor ?" at http://paste.lisp.org/display/25804
21:45:39 <GeoffSK> Is it possible to test for the same constructor?
21:46:42 <vincenz> dons: nice work on check
21:46:51 <vincenz> check \a -> a == a
21:46:56 <vincenz> @check \a -> a == a
21:46:57 <lambdabot>  Add a type signature
21:47:02 <dons> GeoffSK: use 'case'
21:47:02 <vincenz> @check \a -> a == (a :: Bool)
21:47:04 <lambdabot>  OK, passed 500 tests.
21:47:19 <vincenz> \√∏/ 500 cases for something that has only 4 possibilities
21:47:28 <vincenz> erm, make that 2
21:47:28 <dons> thorough!
21:48:28 <GeoffSK> dons: so i need to list out all the constructors?
21:48:32 <sjanssen> @check True
21:48:34 <lambdabot>  OK, passed 500 tests.
21:48:34 <glguy> > foldM replicate 2 [1,2,3]
21:48:35 <lambdabot>  [3,3,3,3]
21:48:36 <vincenz> dons: it would be neat if the instances of quickcheck had control over the amount of tests, such that bounded data classes could restrict
21:48:55 <vincenz> make that Arbitrary
21:49:24 <dons> GeoffSK: if you've an instance of Eq for you type, you could just use guards and ==
21:50:05 <vincenz> that would be a neat TH system
21:50:13 <vincenz> getting dataconstructors out
21:50:17 <vincenz> :)
21:50:57 <vincenz> aka make a generic typeclass
21:50:59 <vincenz> dataConsOf
21:51:14 <vincenz> and then have $(deriving DataCons)
21:51:19 <vincenz> :)
21:52:06 <GeoffSK> hmmm... making the constuctor-type a parameter was easier.
21:52:36 <dibblego> data Sheep = Sheep {name::String, mother::Maybe Sheep, father::Maybe Sheep} what is it called when brackets are used in a type constructor?
21:52:58 <GeoffSK> fields?
21:54:14 <vincenz> named fields
21:54:18 <vincenz> it's JUST the same as
21:54:22 <weitzman> Is there a library function that finds fixed points of functions?
21:54:26 <vincenz> Sheep String (Maybe Sheep) (Maybe Sheep)
21:54:33 <weitzman> @hoogle forall a. (Eq a) => (a -> a) -> a -> a
21:54:34 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
21:54:34 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
21:54:34 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
21:54:34 <vincenz> it just adds field labels
21:54:43 <vincenz> dons: ping
21:55:04 <dons> yes/
21:55:12 <vincenz> dons: what about piping lambdabot output to PMs?
21:55:18 <vincenz> dons: since the channel is growing
21:55:36 <dons> hard to interact then.
21:55:45 <dons> wilx: you want fix, or fixM ?
21:55:50 <dons> ?hoogle fix
21:55:51 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
21:55:51 <lambdabot> Control.Monad.Fix :: module
21:55:51 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
21:55:55 <weitzman> Well, fix doesn't take a starting argument
21:56:01 <lisppaste2> GeoffSK annotated #25804 with "sameCons" at http://paste.lisp.org/display/25804#1
21:56:05 <dons> ah right
21:57:07 <lispy> vincenz: i just open a window to /msg lambdabot if i don't think others will care
21:57:15 <lispy> vincenz: i sort of assume others are doing the same
21:57:42 <dons> or install the bot locally
21:57:52 <vincenz> dons: *cough*
21:58:30 <dons> yes?
21:58:36 <vincenz> nm
21:58:48 <vincenz> I was being trolly, lambdabot ain't always the easiest to compile
21:58:48 <dons> are you suggesting we stop having lambdabot talk in channel?
21:58:59 <vincenz> no, but reduce the outpout
21:59:03 <dons> oh. pretty easy for a 20k loc app, in my opinion
21:59:56 <dibblego> I do what lispy said
22:00:26 <glguy> I try stuff in PM with lambdabot too
22:04:09 <weitzman> Sometimes I think @pl is just trying to screw with me
22:04:39 <glguy> I like when people talk to lambdabot in channel... I get ideas
22:04:57 <lambdabot> Not surprising. I'm brilliant.
22:04:57 <dons> vincenz: what kind of stuff is too verbose?
22:05:55 <dylan> someone should debianize lambdabot.
22:06:26 <lispy> dons: maybe hoogle? it did just use 3 lines..otoh, i don't presonally think it's too verbose
22:06:48 <weitzman> Well, I was hoogling in-channel to make a point
22:06:53 <weitzman> I actually did it out of channel first
22:07:01 <Pseudonym> dylan: Was that you I heard volunteering?
22:07:05 <weitzman> The point was, "I actually searched, didn't find anything"
22:07:07 <dylan> .. I probably just volunteered for that, didn't I?
22:07:08 <dons> ?quit persistent declarations!
22:07:18 <sjanssen> ooh, this should be exciting
22:07:20 <dylan> Pseudonym: I suppose so...
22:07:24 <glguy> persistent declarations?
22:07:34 <dons> yeah, we'll see how this pans out, sjanssen
22:07:50 <dons> so the rules are: currently only value decls are allowed
22:07:59 <dons> and to use them in @eval, you qualify them with L for local
22:08:01 <dons> so
22:08:03 <dons> let x = 8
22:08:07 <dons> ?let x = 9
22:08:16 <dons> now we wait on freenode....
22:08:33 <lambdabot> Defined.
22:08:37 <dons> ok good
22:08:42 <sjanssen> dons: no functions?
22:08:42 <dons> > L.x
22:08:44 <lambdabot>  9
22:08:56 <dons> oh, maybe i made a mistake.
22:09:04 <dons> functions should be ok, but I think I disallowed them by accident
22:09:12 <dons> > L.x + L.x
22:09:13 <lambdabot>  18
22:09:17 <dons> let y = L.x
22:09:24 <dylan> ?let f x = x + x
22:09:24 <lambdabot> Invalid declaration
22:09:25 <dons> ?let y = L.x
22:09:26 <lambdabot> Defined.
22:09:31 <sjanssen> dons: I haven't tried it yet, I wondered what you mean by "only value decls"
22:09:33 <dons> yes, there's a bad regex to test for decls :)
22:09:39 <dons> i mean, no instances or types
22:09:46 <sjanssen> oh, okay
22:09:52 <dons> (since encoding russel in the type system is easy, and makes ghc diverge)
22:10:00 <dons> > L.y + L.x
22:10:01 <lambdabot>  18
22:10:10 <dons> so in the env now is:
22:10:10 <dons> {-# LINE 1 "<local>" #-}
22:10:11 <dons> x = 9
22:10:11 <dons> y = L.x
22:10:24 <sjanssen> @let if' b x y = if b then x else y -- for @pl
22:10:24 <lambdabot>  Unterminated end-of-line comment
22:10:30 <dons> i'll just tweak it to allow functions.
22:10:31 <sjanssen> @let if' b x y = if b then x else y
22:10:31 <lambdabot> Invalid declaration
22:10:42 <dons> and to remove the enivronment:
22:10:46 <dons> ?undefine
22:10:47 <lambdabot> Undefined.
22:10:50 <dons> > L.x
22:10:51 <lambdabot>  Not in scope: `L.x'
22:11:02 <sjanssen> @let if' = \b x y -> if b then x else y
22:11:03 <lambdabot> Defined.
22:11:06 <glguy> ?let what = "should I speak up?"
22:11:07 <lambdabot> Defined.
22:11:09 <glguy> > what
22:11:10 <lambdabot>  Not in scope: `what'
22:11:15 <glguy> > L.what
22:11:16 <lambdabot>  "should I speak up?"
22:11:29 <dons> the env thus contains:
22:11:30 <dons> if' = \b x y -> if b then x else y
22:11:31 <dons> what = "should I speak up?"
22:11:53 <Pseudonym> ?let id = undefined
22:11:53 <lambdabot> Defined.
22:11:55 <dons> so some future enhancements would be to selectively undefine
22:11:55 <weitzman> @let collatz = (let f 1 = True; f x | (mod x 2 == 0) = f (div x 2); f x = f (3*x + 1) in f)
22:11:56 <lambdabot> Defined.
22:11:57 <Pseudonym> > id 2
22:11:58 <lambdabot>  2
22:12:01 <Pseudonym> Hmmm.
22:12:04 <glguy> > L.id 2
22:12:05 <lambdabot>  Add a type signature
22:12:06 <dons> qualified name.
22:12:17 <glguy> > L.id 2 :: ()
22:12:18 <Pseudonym> Aha.
22:12:18 <lambdabot>  Undefined
22:12:19 <weitzman> @check \x -> collatz x
22:12:20 <lambdabot>  Not in scope: `collatz'
22:12:33 <dons> (its qualified so we don't confuse the newbies with override + and so on)
22:12:33 <weitzman> @check \x -> (L.collatz) x
22:12:34 <lambdabot>  Not in scope: `L.collatz'
22:12:46 <Pseudonym> ?let pi = iterate (\x -> x + sin x) 3 !! 20
22:12:47 <lambdabot> Defined.
22:12:48 <dons> and it doesn't extend to @check yet
22:12:50 <Pseudonym> > L.pi
22:12:51 <lambdabot>  3.141592653589793
22:12:51 <weitzman> Ah
22:12:54 <glguy> dons: what is the lifespan of a persisted decl?
22:13:07 <dons> the universe, or a call to @undefine, which ever comes first
22:13:11 <weitzman> > L.collatz 1000
22:13:13 <lambdabot>  True
22:13:26 <glguy> > L.setinpm
22:13:27 <lambdabot>  "I set this in PM"
22:13:34 <dons> ok. yes.
22:13:40 <dons> its a shared resource
22:14:04 <Pseudonym> ?let setinpm = "I didn't set this in PM"
22:14:05 <lambdabot> <local>:7:0:     Multiple declarations of `L.setinpm'     Declared at: <local...
22:14:07 <Pseudonym> Aha.
22:14:22 <sjanssen> > L.setinpm
22:14:23 <lambdabot>  "I set this in PM"
22:14:24 <dons> ok, so adding Local.hs to @check is easy. I'll do that, then fix the function decls
22:14:27 <lispy> selective undefine will be nice
22:14:33 <lispy> cool
22:14:36 <lispy> dons++
22:14:39 <dons> right, i went for the more conservative approach first, to see how this works
22:14:42 <dylan> dons++
22:14:47 <glguy> ?undefine setinpm
22:14:48 <lambdabot> Undefined.
22:14:50 <glguy> ?undefine what
22:14:51 <lambdabot> Undefined.
22:15:07 <weitzman> > collatz 3
22:15:08 <lambdabot>  Not in scope: `collatz'
22:15:14 <weitzman> > L.collatz 4
22:15:15 <lambdabot>  Not in scope: `L.collatz'
22:15:23 <dons> its all gone, when they hit ?undefine
22:15:27 <weitzman> Yeah
22:15:37 <Pseudonym> I give it a week before someone finds a way to crack lambdabot.
22:15:53 <dons> Pseudonym: a week? I'd have thought sooner. but we'll see.
22:16:10 <glguy> so we can't define functions, but we can store lambda expressions?
22:16:12 <dons> it does 3 things: checks for a valid decl, checks for a valid rhs-expressoin, and typechecks it
22:16:20 <Pseudonym> I'm betting karma here, so yes, a week.
22:16:29 <dons> glguy: right, just no n-ary syntax yet.
22:16:34 <dons> Pseudonym: ok, I give it 3 days.
22:16:57 <sjanssen> too bad we don't have @wager-karma yet
22:17:10 <glguy> dons if someone defines something... can the raw definition be looked up?
22:17:18 <dons> not yet.
22:17:39 <dons> but the raw definition is the defn you give it, minus the "let "
22:17:56 <lispy> how can you use persistent decls to crack lambdabot in some way that hasn't already been done?
22:18:12 <glguy> > L.secret 4
22:18:13 <lambdabot>  add an instance declaration for (Num [Char])
22:18:15 <dons> if I knew that, I'd lower my bet to several minutes :)
22:18:22 <glguy> > L.secret "4"
22:18:23 <lambdabot>  "incorrect"
22:18:29 <glguy> > L.secret "thepassword"
22:18:30 <lambdabot>  "tempting"
22:18:31 <dons> hehe, nice glguy
22:18:42 <weitzman> @let x = Lambdabot.IRCRWState
22:18:43 <lambdabot> <local>:3:4: Not in scope: data constructor `Lambdabot.IRCRWState'
22:19:08 <sjanssen> @let x = 10; type FooBar = Int
22:19:08 <lambdabot>  Parse error
22:19:10 <dons> gee, what do you take me for ? :)
22:19:28 <lispy> @let main = Main.main
22:19:28 <lambdabot> <local>:3:7: Not in scope: `Main.main'
22:19:36 <dons> sjanssen: close, could have got through, but I added an extra check for that.
22:20:07 <lispy> @let b = putStrLn
22:20:08 <lambdabot> Defined.
22:20:15 <lispy> > L.b "hi"
22:20:16 <lambdabot>  No IO allowed
22:20:21 <lispy> nice!
22:20:24 <dons> we have a type system for that :)
22:20:35 <lispy> ?type L.B
22:20:36 <lambdabot> Couldn't find qualified module.
22:20:37 <lispy> ?type L.b
22:20:38 <lambdabot> Couldn't find qualified module.
22:20:43 <foxy_> @let u = unsafePerformIO
22:20:43 <dons> not in scope yet. should add it
22:20:44 <lambdabot> <local>:4:4: Not in scope: `unsafePerformIO'
22:21:04 <foxy_> @let u = unsafeCoerce#
22:21:05 <lambdabot>  Parse error
22:21:18 <Pseudonym> @let data Foo = Foo | Bar
22:21:19 <lambdabot> Invalid declaration
22:21:19 <vincenz> dons: @hoogle
22:21:32 <lispy> dons: okay, so how long do you think before we can use lambdabot as a webservice?
22:21:49 <dons> could be done already, I suppose. bit scary though.
22:22:04 <vincenz> dons: afraid of spammers?
22:22:10 <lispy> once we have that, i want to embeded lambdabot into my google home page :)
22:22:15 <vincenz> dons: make it a registered user server with a captcha for registration?
22:22:17 <dibblego> f (x:_) = return $ read x
22:22:18 <dons> h4x0rs
22:22:20 <dibblego> what does that mean?
22:22:24 <lispy> doesn't have to be the lambdabot but a lambdabot
22:22:30 <glguy> omg, ghc on google homepage
22:22:35 <weitzman> @type Control.Monad.Reader.ask
22:22:36 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
22:22:45 <glguy> I want some!
22:23:13 <weitzman> @type  Control.Monad.Reader.ask >>= env
22:23:14 <lambdabot> Not in scope: `env'
22:23:18 <lispy> dibblego: take the head of the list and try to read it into some monad
22:23:37 <lispy> ?type \(x:_) -> return $ read x
22:23:38 <lambdabot> forall (m :: * -> *) a. (Monad m, Read a) => [String] -> m a
22:23:46 <glguy> > ( do { s <- ask sum; n <- ask genericLength; return (s / n) } ) [1,3,7,10]
22:23:47 <lambdabot>  5.25
22:24:02 <dibblego> is $ a function?
22:24:07 <lispy> yes
22:24:08 <glguy> ?type ($)
22:24:09 <lispy> ?type ($)
22:24:10 <lambdabot> forall b a. (a -> b) -> a -> b
22:24:11 <lambdabot> forall b a. (a -> b) -> a -> b
22:24:16 <glguy> lispy: i win :-p
22:24:19 <lispy> heeh
22:24:45 <lispy> dibblego: basically, it helps you avoid parens
22:25:08 <lispy> return (read x) == return $ read x
22:25:57 <glguy> it can also be used like this: map ($ 5) [(1+), (2+)]
22:26:20 <dibblego> which module is it in?
22:26:29 <glguy> (which is similar to: sequence [(1+),(2+)] 5)
22:26:33 <sjanssen> dibblego: Prelude
22:27:39 <Pseudonym> ?let foo   =    id
22:27:39 <lambdabot> Invalid declaration
22:27:52 * dons is lazy
22:27:56 * Pseudonym noticed
22:28:25 <vincenz> yeah, we definitely noticed after a gazillion patches to fps and lambdabot
22:28:48 <glguy> Haskell is lazy...
22:28:59 <glguy> is that how you meant it? ;)
22:29:15 <glguy> do the work as it is demanded of you :-p
22:29:40 <weitzman> The three great virtues: Laziness, Impatience, Hubris
22:29:46 <weitzman> How many does Haskell have?
22:29:48 <Pseudonym> I also note that the time taken for ?let is O(N^2) in the number of times ?let is invoked.
22:29:58 <Pseudonym> No way around that, I think.
22:30:15 <sjanssen> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
22:30:15 <lambdabot>  HelloWorld!
22:30:16 <dons> oh, you mean in terms of compilation time?
22:30:20 <Pseudonym> Yeah.
22:30:47 <dons> why's it N^2?
22:30:54 <vincenz> sjanssen: where are the letters stored???
22:30:58 <Pseudonym> It's linear in the size of L.hs.
22:31:03 <Pseudonym> And L.hs is added one line at a time.
22:31:05 <dons> right.
22:31:12 <dons> oh ok :)
22:31:29 <Pseudonym> ?let psl = putStrLn
22:31:29 <lambdabot> Defined.
22:31:36 <vincenz> o.O
22:31:38 <Pseudonym> ?let putStrLn = id
22:31:39 <vincenz> > psl 1
22:31:39 <lambdabot> <local>:3:4:     Ambiguous occurrence `putStrLn'     It could refer to either...
22:31:39 <lambdabot>  Not in scope: `psl'
22:31:43 <vincenz> woah
22:31:48 <sjanssen> vincenz: no idea, I just got that while reading lambdabot patches
22:31:50 <vincenz> @karma+ dons lets!
22:31:51 <lambdabot> dons's karma raised to 65.
22:31:53 <dons> O((1/how-fast-is-ghc*N) ^ 2)
22:32:17 <lispy> sjanssen: that's a brainfuck interpreter
22:32:27 <lispy> sjanssen: not good for much other than proof of concept
22:32:31 <Pseudonym> ?let L.putStrLn = id
22:32:32 <lambdabot>  Parse error in pattern
22:32:37 <Pseudonym> Hmm.
22:32:53 <dons> > 1+2
22:32:55 <lambdabot>  3
22:33:01 <dons> ok, good so far I think
22:33:06 <sjanssen> @let [x, y] = [4, 5]
22:33:07 <lambdabot> Invalid declaration
22:33:08 <dons> the goal is to not have @eval break
22:33:15 <dons> nice point sjanssen
22:33:23 <Pseudonym> ?let putStr = id
22:33:24 <lambdabot> Defined.
22:33:32 <Pseudonym> ?let test1 = putStr 2
22:33:32 <lambdabot> <local>:9:8:     Ambiguous occurrence `putStr'     It could refer to either `...
22:33:51 <sjanssen> @let p = pack
22:33:51 <lambdabot> <local>:9:4: Not in scope: `pack'
22:33:57 <dons> oh hmm. what's that then, Pseudonym
22:34:00 <Pseudonym> ?let test2 = unsafePerformIO
22:34:01 <lambdabot> <local>:9:8: Not in scope: `unsafePerformIO'
22:34:03 <sjanssen> why are there two putStr's in scope?
22:34:07 <vincenz> dons: are we stress testing?
22:34:12 * Pseudonym is stress testing
22:34:17 <vincenz> @let id=id
22:34:17 <lambdabot> Invalid declaration
22:34:20 <dons> ?hoogle putStr
22:34:20 <vincenz> @let id = id
22:34:21 <lambdabot> Prelude.putStr :: String -> IO ()
22:34:21 <lambdabot> Prelude.putStrLn :: String -> IO ()
22:34:21 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
22:34:21 <lambdabot> <local>:8:9:     Ambiguous occurrence `id'     It could refer to either `L.id...
22:34:24 <vincenz> > id
22:34:24 <lambdabot>  Add a type signature
22:34:39 <vincenz> @let let = let
22:34:39 <lambdabot>  Parse error
22:34:47 <Pseudonym> Aha.
22:34:51 <vincenz> why is @let id = id invald?
22:34:58 <Pseudonym> ?let hPutStr = id
22:34:59 <lambdabot> Defined.
22:35:06 <dons> ok, I'm not sure why the putStr got in. how'd that work?
22:35:29 <Pseudonym> dons: Declaring a symbol called "putStr" isn't a problem.
22:35:30 <dons> oh, no shadow warnings, I think. that's ok.
22:35:35 <Pseudonym> The problem is when you try to use it.
22:35:36 <dons> yes, that's fine
22:35:50 <dons> ?let (+) = (*) -- for example
22:35:50 <lambdabot>  Unterminated end-of-line comment
22:35:56 <Pseudonym> In particular, if you refer to it inside L.hs, you get an ambiguous occurrence error.
22:35:57 <dons> should add a \n
22:36:05 <dons> yep
22:36:12 <dons> that's fine, I think.
22:36:26 <Pseudonym> There's a problem, but it doesn't compromise security.
22:36:34 <Pseudonym> You can stuff things up for everyone using L.hs after you.
22:36:41 <Pseudonym> ?let sum = undefined
22:36:41 <dons> yes
22:36:42 <lambdabot> Defined.
22:36:50 <vincenz> > sum
22:36:51 <lambdabot>  Add a type signature
22:36:55 <vincenz> > sum [1..10]
22:36:56 <lambdabot>  55
22:37:01 <Pseudonym> ?let test2 = sum [1..1]
22:37:01 <lambdabot> <local>:3:8:     Ambiguous occurrence `sum'     It could refer to either `L.s...
22:37:04 <vincenz> > L.sum [1..10]
22:37:05 <lambdabot>  Add a type signature
22:37:06 <Pseudonym> That's why.
22:37:08 <dons> right
22:37:19 <vincenz> what version?
22:37:21 <dons> so I should add a shadowing warning flag
22:37:29 <Pseudonym> Probably, yeah.
22:37:33 <dons> to ghc, which will prevent those.
22:37:41 <vincenz> dons: isn't this killing your proc?/
22:37:48 <Pseudonym> ?let newtype Bool = Bool Int
22:37:48 <lambdabot> Invalid declaration
22:37:52 <lispy> yes, -Wall -Werror might not be a bad idea for ?let
22:37:57 <dons> vincenz: haven't noticed.
22:38:12 <dons> lispy: tried that. it would require type sigs for all
22:38:18 <lispy> oh
22:38:25 <dons> vincenz: manzano$ uptime
22:38:25 <dons>  3:37PM  up 20 days, 30 mins, 3 users, load averages: 0.21, 0.21, 0.17
22:38:28 <lispy> well just -fno-warn-<typesignatures>
22:38:33 <dons> so no, alles gut
22:38:51 <glguy> My Windows box at work has 1500 hours of System Idle Time
22:38:58 <weitzman> @let inf = 1 : inf
22:38:59 <lambdabot> Defined.
22:39:08 <weitzman> > length L.inf
22:39:11 <lambdabot> Terminated
22:39:15 <Pseudonym> I had a FreeBSD box with three years' uptime once.
22:39:17 <weitzman> Goodbye, memory
22:39:31 <glguy> I've never had the power stay on that long :)
22:39:33 <dons> laziness is fun :)
22:39:39 <Pseudonym> We had our own substation.
22:39:41 <dons> > L.inf
22:39:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:39:58 <lispy> dons: -Wall -Werrer -fno-warn-missing-signatures?
22:40:06 <dons> ah maybe
22:40:09 <Pseudonym> The only reason it rebooted is I figued I should probably patch the kernel.
22:40:11 <dons> let me try that.
22:41:18 <lispy> dons: may need to turn off unused imports too
22:41:38 <lispy> well, depending of course on what you import
22:41:48 <dons> yep
22:42:40 <lispy> dons: i'll tell my friend about it tomorrow and see if he's had any thoughts on the webservice front
22:42:47 * lispy heads to bed
22:42:59 <Pseudonym> Night.
22:43:05 <lispy> i don't actually understand what a webservice is
22:43:14 <lispy> how you contact it and so on
22:43:28 <glguy> it's a standard interface for calling functions and gettinga return value
22:43:32 <wkh> it's just where you can interact with a website via HTTP and receive a useful response, in the form of xml
22:43:34 <wkh> or something else.
22:43:44 <wkh> you just send a normal http request
22:43:47 <glguy> a lambdabot web interface might accept a one-liner, and return the output
22:43:52 <dibblego> it's a buzzword
22:44:02 <glguy> not really...
22:44:06 <dibblego> some people refer to it as a HTTP request
22:44:14 <glguy> it's more than a simple request
22:44:20 <lispy> having lambdabot accept a one liner and return the output would be perfect
22:44:33 <dibblego> with some context applied by the observer
22:48:35 <wkh> > [1..]
22:48:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:49:01 * wkh 's attempt to hax lambdabot has been foiled
22:49:22 <dons> heh
22:52:11 <sjanssen> dons: what's the point of parsing the expression twice, the second time with an added newline?
22:52:26 <sjanssen> (I'm talking about Plugin.Eval.define btw)
22:52:50 <dons> I wanted to be sure: type = * couldn't get through
22:52:54 <sjanssen> okay
22:52:58 <dons> possibly its redundant now though
22:53:07 <dons> my original plan was to allow types, but i'm holding back on that
22:53:26 <sjanssen> I'm going to rewrite that code to check the AST to see if everything is safe
22:53:36 <dons> ok good. thanks!
22:53:53 <dons> what will you be looking for?
22:55:14 <sjanssen> make sure there are no imports and that all decls are either type signatures or function/pattern bindings
22:55:31 <dons> ok
22:55:46 <dons> i just pushed a small patch, you might want to pul
22:56:24 <dibblego> dons, are you studying at unsw?
22:56:32 <dons> yes.
22:56:39 <dibblego> phd?
22:57:03 <dons> ?where dons  -- let's see
22:57:04 <lambdabot> http://www.cse.unsw.edu.au/~dons
22:57:11 <dons> hehe someone put that in.
22:58:08 <dons> ?quit tweak decl code a bit
22:58:52 <dons> ?version
22:59:19 <lambdabot> lambdabot 4p172, GHC 6.5 (OpenBSD i386 )
22:59:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:59:38 <dons> ?let f x = (x,x)
22:59:38 <lambdabot> Defined.
22:59:53 <dons> > L.f "bot"
22:59:54 <lambdabot>  ("bot","bot")
23:00:00 <dons> ?undefine
23:00:01 <lambdabot> Undefined.
23:03:02 <dons> ?let nonzero = not . null
23:03:03 <lambdabot> Defined.
23:03:29 <dons> ?check \s -> nonzero s ==> (s :: T) == (reverse . reverse ) s
23:03:30 <lambdabot>  Not in scope: `nonzero'
23:03:38 <dons> ?check \s -> L.nonzero s ==> (s :: T) == (reverse . reverse ) s
23:03:39 <lambdabot>  OK, passed 500 tests.
23:03:42 <dons> good
23:03:50 <dons> weitzman: ^^
23:04:43 <weitzman> @let check = \p x -> not . null x ==> p x
23:04:43 <lambdabot> <local>:2:16:     precedence parsing error         cannot mix `(.)' [infixr 9...
23:05:10 <weitzman> @let check = \p x -> ((not . null x) ==> p x)
23:05:11 <lambdabot> <local>:2:32: Not in scope: `==>'
23:05:16 <dons> ah right.
23:06:33 <dons> ?undefine
23:06:34 <lambdabot> Undefined.
23:07:06 <dons> ?let check p x = (not.null) x ==> p x
23:07:07 <lambdabot> Defined.
23:07:12 <weitzman> Hooray
23:07:53 <dons> ?check check (\s -> minimum s == (head . sort) (s :: T)
23:07:54 <lambdabot>  Parse error
23:07:55 <dons> ?check check (\s -> minimum s == (head . sort) (s :: T))
23:07:56 <lambdabot>    The lambda expression `\ s -> ...' has one arguments,     but its type `...
23:08:14 <weitzman> @check (check (\x -> map (+ 1) (tail x) == tail (map (+ 1) x))
23:08:15 <lambdabot>  Parse error
23:08:22 <dons> ?check \t -> check (\s -> minimum s == (head . sort) s) (t::T)
23:08:23 <lambdabot>    The lambda expression `\ s -> ...' has one arguments,     but its type `...
23:08:35 <weitzman> @check \y (check (\x -> map (+ 1) (tail x) == tail (map (+ 1) x)) y
23:08:36 <lambdabot>  Parse error
23:08:36 <dons> i'm not sure 'check' in its current form is useful :)
23:08:40 <weitzman> Hmm
23:08:43 <dons> ?undinef
23:08:43 <lambdabot> Unknown command, try @list
23:08:48 <dons> ?undef
23:08:49 <lambdabot> Undefined.
23:08:51 <weitzman> Perhaps not
23:09:49 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g x
23:09:50 <lambdabot> Defined.
23:10:25 <dons> ?check \t -> (id `eqnotnull` (reverse.reverse)) (t::T)
23:10:26 <lambdabot>  Not in scope: `eqnotnull'
23:10:32 <dons> ?check \t -> (id `L.eqnotnull` (reverse.reverse)) (t::T)
23:10:34 <lambdabot>  OK, passed 500 tests.
23:10:36 <dons> :)
23:10:40 <weitzman> Oo goody
23:11:01 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g (x::T)
23:11:02 <lambdabot> Defined.
23:11:08 <dons> ?undef
23:11:09 <lambdabot> Undefined.
23:11:10 <dons> ?let eqnotnull f g = \x -> (not (null x)) ==> f x == g (x::T)
23:11:11 <lambdabot> Defined.
23:11:28 <dons> ?check id `L.eqnotnull` (reverse.reverse)
23:11:29 <lambdabot>  OK, passed 500 tests.
23:11:32 <dons> hehe
23:12:37 <dons> ?check minimum `L.eqnotnull` head.sort
23:12:37 <lambdabot>    precedence parsing error         cannot mix `L.eqnotnull' [infixl 9] and...
23:12:45 <dons> ?check minimum `L.eqnotnull` (head.sort)
23:12:46 <lambdabot>  OK, passed 500 tests.
23:12:52 <dons> haskell++
23:12:56 <weitzman> dons++
23:12:59 <weitzman> @karma dons
23:12:59 <lambdabot> dons has a karma of 66
23:13:02 <weitzman> woa
23:13:05 <weitzman> You got mad karma
23:13:08 <dons> that's getting silly I think.
23:13:27 <sieni> @karma haskell
23:13:27 <lambdabot> haskell has a karma of 5
23:13:30 <dons> somehow my karma turned into the test case people use to see how @karma+ works
23:13:34 <sieni> @karma
23:13:34 <lambdabot> You have a karma of 2
23:13:48 <dons> ?karma+ Java
23:13:49 <lambdabot> dons's karma raised to 67.
23:13:50 <weitzman> Everyone's going to hate me for this, but I'm going to do it anyway
23:13:53 <weitzman> Java++
23:13:56 <dons> ?karma+ java
23:13:56 <lambdabot> dons's karma raised to 68.
23:14:04 <dons> doh. i thought I had a special case for that.
23:14:13 <dons> seems like it broke...
23:14:24 <sjanssen> what?? dons == java?
23:14:40 <dons>   | map toLower nick == "java" && km == 1 = changeKarma km "lambdabot" sender
23:14:47 <dons> ?karma- java
23:14:47 <lambdabot> java's karma lowered to -3.
23:14:58 <dons> did someone slip that in without me seeing? SamB?
23:15:18 <dons> it's supposed to be:   | map toLower nick == "java" && km == 1 = changeKarma (-km) "lambdabot" sender
23:15:28 <weitzman> There's no Java love in #haskell, it seems
23:15:42 <weitzman> I have love enough to share it with both haskell and Java
23:15:44 <dibblego> Java is buested
23:15:50 <dibblego> *busted too
23:16:00 <weitzman> Java has its ups and downs
23:16:20 <sieni> The main down of Java is that it exists.
23:16:22 <weitzman> But Java written by anyone competent is very easy to understand
23:16:25 <weitzman> And I appreciate that
23:16:26 <dibblego> I hate convenient fantasies that attempt to represent reality
23:17:08 <weitzman> Also, a Java version of lambdabot could dynamically load and unload updated plugins, and could run untrusted code safely in-process
23:17:15 <dons> can't believe i did that twice in 2 days
23:17:27 <dons> ?quit grrify
23:18:04 <weitzman> And IntelliJ IDEA, the most rockin' editor on the planet, happens to be a Java IDE
23:18:18 <dibblego> I am using Intellij IDEA to write a book on why Java is utterly broken
23:18:31 <sjanssen> I have one of the 6.6 RC's, how am I supposed to install mtl?
23:18:46 <dons> sjanssen: you've got to get the extra-libs bundle
23:19:00 <dons> i did that by building from darcs, i've not tried other methods
23:19:00 <dibblego> but Intellij IDEA broke too, so now I'm stuck
23:19:35 <weitzman> For an utterly-broken language, Java sure is solving a lot of real problems in the world
23:19:48 <weitzman> But, this is offtopic
23:19:52 <dibblego> it is at least appearing to - whether or not it actually is, is a point of debate
23:19:55 <dibblego> indeed
23:19:59 <dons> sjanssen: the \n thing is for comments, btw. better fix that so it works
23:20:11 <dons> ?let f = f -- some comment
23:20:11 <lambdabot>  Unterminated end-of-line comment
23:20:23 <dons> silly Language.Haskell
23:20:47 <dons> ?check head `eqnotnull` tail -- still there?
23:20:48 <lambdabot>  Not in scope: `eqnotnull'
23:20:56 <dons> ?check head `L.eqnotnull` tail -- still there?
23:20:57 <lambdabot>  Couldn't match `Int' against `[Int]'
23:21:09 <dons> ?check head `L.eqnotnull` last
23:21:10 <lambdabot>  Falsifiable, after 5 tests: [1,-1]
23:21:14 <dons> goodo
23:21:50 <dibblego> I still have some of my IBM code from the IBM Java implementation :)
23:21:58 <dibblego> found it in my repsitory
23:22:09 * dibblego stabs it profusely
23:22:33 <weitzman> I reserve my bitterness for C and C++
23:22:53 <dibblego> I am not bitter, I'm just pretending
23:23:01 <weitzman> But I like to simultaniously hate them and apologize on their behalf
23:23:16 <weitzman> One language that really saddens me is SML
23:23:32 <weitzman> The language mostly-works
23:23:43 <weitzman> But they need some serious work on the error messages and tools
23:23:54 <weitzman> Alas, nobody cares enough to do it
23:24:03 <weitzman> And I have to use SML for a lot of assignments
23:24:32 <Pseudonym> I don't like the fact that you have to declare something lexically before you use it.
23:24:36 <weitzman> And OCaml is ugly
23:24:50 <Pseudonym> This isn't the 1970s.  There's no excuse for that any more.
23:27:02 <dibblego> http://rafb.net/paste/results/w1O7n994.html why doesn't this compile?
23:28:46 <weitzman> All this talk of inexcusable vestiges of pre-1980 reminds me of how much I don't miss the win32 programming I did this summer
23:28:59 <weitzman> w00t
23:34:21 <foxy_> http://rafb.net/paste/results/0sxZdo41.html <-- dibblego
23:34:35 <dibblego> thanks
23:38:52 <dibblego> isn't there a way without changing the signature of the problem1 function?
23:39:15 <kowey> return (problem1 args)
23:39:40 <dibblego> ta
23:40:40 <foxy_> http://rafb.net/paste/results/6FHeNU77.html
23:40:46 <foxy_> fooey
23:41:59 <dibblego> thanks
23:43:08 <foxy_> homework skeleton?
23:44:40 <dfranke> why does this not cause a forkbomb?
23:44:47 <dfranke> let fork n = do Control.Concurrent.forkOS $ fork (n+1)
23:44:47 <dfranke>                 yield in
23:44:47 <dfranke> fork 0
23:47:38 <dolio> ?hoogle forkOS
23:47:39 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
23:50:10 <_velco> guess needs to be executed
23:50:30 <dfranke> "guess"?
23:51:56 <dons> it forks a very large number of threads here
23:52:13 <dons> just watch ghci climb to the top of top
23:52:29 <dfranke> strange.  For me it exits immediately.
23:53:01 <dons> it should return immediately to the main thread, but those child threads keep spawning
23:53:12 <dons> you won't know unless you watch the process externally
23:57:10 <dfranke> nothing comes up on top.
23:57:25 <dons> are you using an old ghc without -threaded?
23:57:40 <_velco> shouldn't one call this from main ?
23:57:40 <dfranke> I'm using 6.4.1 and compiling using -threaded.
23:57:54 <dfranke> here's the actual program
23:57:57 <dfranke> module Main where
23:57:57 <dfranke>     import Control.Concurrent
23:57:57 <dfranke>     fork n = do forkOS $ fork (n+1)
23:57:57 <dfranke>                 yield
23:57:57 <dfranke>     main = fork 0
23:58:05 <lucca> is ghc for darwin-ppc likely to work on darwin-intel, given appropriate libraries?
23:58:35 <dfranke> If I insert a putStrLn $ show n, it just prints 0.
23:58:42 <lucca> (that isn't as stupid a question as it sounds...)
23:58:49 <dfranke> If I change forkOS to forkIO, it prints 0 and 1 and nothing else.
23:58:57 <dons> dfranke: but your program will terminate when the main thread exits..
23:59:07 <dons> which happens almost immediately, after yield, doesn't it?
23:59:18 <dolio> main = fork 0 >> main?
23:59:31 <dons> you'd better 'wait' on the child, or run it in ghci, for example, which will wait for you
23:59:33 <Lemmih> dfranke: Try adding 'takeMVar =<< newEmptyMVar' to main.
