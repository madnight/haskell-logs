00:00:13 <dons> almost all of it?
00:00:17 <dons> 'cept for (:[])
00:01:05 <dons> any other useful little tools to add?
00:03:29 <shapr> @users
00:03:31 <lambdabot> Maximum users seen in #haskell: 216, currently: 214 (99.1%), active: 18 (8.4%)
00:03:46 * shapr goes inactive
00:06:32 <dcoutts__> dons: space = input $ intersperse ""
00:06:38 <dcoutts__> dons: ie []/""
00:06:47 <dcoutts__> possibly clearer
00:06:57 <dons> ok
00:08:04 <vincenz> > replicate 214 "lambda-cookie"
00:08:05 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
00:08:27 <dcoutts__> dons: ah I see you added our string checksum example :-)
00:08:44 <dcoutts__> hash actually
00:08:48 <dons> :)
00:10:19 <dcoutts__> nice examples
00:10:36 <dcoutts__> most work with bytestring too I guess
00:10:43 <dons> yeah
00:10:49 <dcoutts__> except the ones with (:)
00:11:11 <dcoutts__> num is a bit obscure
00:11:18 <dcoutts__> could that be clearer ?
00:11:20 <vincenz> dons: addnum = zipWith (\n l -> show n ++ ": " ++ l) [1..] . unlines
00:11:37 <vincenz> > let addnum = zipWith (\n l -> show n ++ ": " ++ l) [1..] . unlines  in addnum "ab\ncd"
00:11:37 <lambdabot>  Couldn't match `[Char]' against `Char'
00:11:57 <vincenz> @type unlines
00:11:58 <lambdabot> [String] -> String
00:12:16 <vincenz> > let addnum = unlines . zipWith (\n l -> show n ++ ": " ++ l) [1..] . lines  in addnum "ab\ncd"
00:12:17 <lambdabot>  "1: ab\n2: cd\n"
00:12:21 <dcoutts__> num = input $ zipWith (\n line -> show n ++ " " ++ line)
00:12:28 <dcoutts__> num = input $ zipWith (\n line -> show n ++ " " ++ line) [1..]
00:12:36 <vincenz> doubt that'll work
00:12:42 <vincenz> input is stateless
00:12:54 <vincenz> never mind
00:13:01 <vincenz> but yeah :)
00:13:26 <vincenz> it'd be nice if you could get it spaced evenly, but that wouldn't be very efficient
00:13:35 <dons> printf?
00:13:46 <dons> maybe it shoudl use printf anyway
00:13:52 <vincenz> I was thinking mor eabout the fact that ot know how far to space it, you'd need to get the last line before outputting the first
00:14:06 <vincenz> s/typos/typoless/
00:14:11 <dons> zipWith (printf "%3d %s")
00:14:21 <vincenz> dons: so what if your file > 1000 lines
00:14:37 <dons> i don't care :)
00:14:43 <vincenz> @type printf "%rd %s"
00:14:44 <lambdabot> forall r. (PrintfType r) => r
00:14:44 <dons> printf looks nicer though
00:14:45 <vincenz> @type printf "%3d %s"
00:14:46 <lambdabot> forall r. (PrintfType r) => r
00:15:00 <vincenz> > printf "%3d %s" 1 "lala
00:15:00 <lambdabot>  Improperly terminated string
00:15:01 <vincenz> > printf "%3d %s" 1 "lala"
00:15:02 <lambdabot>  Add a type signature
00:15:07 <vincenz> > printf "%3d %s" 1 "lala" :: String
00:15:07 <lambdabot>  Add a type signature
00:15:19 * vincenz wrinkles his nose
00:15:34 <wilx> > printf "%3d %s" (1::Int) "lala"
00:15:36 <lambdabot>  Add a type signature
00:15:38 <wilx> :)
00:16:03 <vincenz> > printf "%3d %s" (1::Int) ("lala" :: String) :: String
00:16:04 <lambdabot>  "  1 lala"
00:16:05 <dons> input $ zipWith (printf "%3d %s") [(1::Int)..]
00:16:14 <vincenz> that's insane
00:16:20 <vincenz> you need to specify the type of "lala"?
00:16:27 <vincenz> > printf "%3d %s" (1::Int) "lala" :: String
00:16:28 <lambdabot>  "  1 lala"
00:16:30 <dons> could be IO :)
00:16:35 <vincenz> ah no, the number and the output
00:16:38 <dons> you need to tell printf . hack that class system
00:17:27 * vincenz sighs
00:17:28 <dons> i've never zipped with printf. seems like a useful idiom
00:17:53 <vincenz> twenty million places to replicate code
00:17:57 <wilx> How does it work?
00:18:07 <wilx> I thought printf was not possible with ordinary Haskell.
00:18:28 <dons> nope, its fine. even in h98
00:18:31 <dons> ?hoogle printf
00:18:31 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
00:18:32 <lambdabot> Text.Printf :: module
00:18:32 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
00:18:34 <dons> ?type printf
00:18:35 <lambdabot> forall r. (PrintfType r) => String -> r
00:18:35 <vincenz> everything is possible with haskell and oleg
00:18:59 * vincenz kicks ocaml
00:18:59 <dons> > printf "%d %f %s" (1::Int) (2::Double) "foo" :: String
00:19:01 <lambdabot>  "1 2.0 foo"
00:19:33 <wilx> @type printf "%3d %s"
00:19:34 <lambdabot> forall r. (PrintfType r) => r
00:19:49 <wilx> @type printf "%3d %s" (1::Int)
00:19:50 <lambdabot> forall t. (PrintfType (Int -> t)) => t
00:20:00 <dons> ?type \(d::Int) (s::String) -> printf "%3d %s"
00:20:02 <lambdabot> forall r. (PrintfType r) => Int -> String -> r
00:20:09 <dons> ?type \(d::Int) (s::String) -> printf "%3d %s" :: String
00:20:10 <lambdabot> String :: Int -> String -> String
00:20:19 <dons> typeclasses forever!
00:22:53 * vincenz hmms
00:23:05 <vincenz> dons: fps works for binary data as well, correct?
00:23:10 <dons> sure
00:23:13 <dons> its all just Word8 to fps
00:23:20 * vincenz hmms
00:23:29 <vincenz> I'm tempted to rewrite my loganalyzer to haskell
00:23:32 <vincenz> just to see how it'd perform
00:23:47 <Eidolos> Like buttah
00:23:55 <vincenz> ?
00:24:15 <dons> have a go. i think kzm wrote a log analyser with byteStrings, and it did just fine.
00:24:32 <vincenz> Originally this thing was in python, 50 minutes... then ported to ocaml -> 50 seconds, since then it grew however and now it's about 5minutes (without too many options) for about 1-2GB of data (one packet is more or less 20 bytes)
00:24:35 <Eidolos> Linda Richman? No? :/
00:25:04 <vincenz> dons: it's a lot of word-per-word stuff tho
00:25:17 <vincenz> well byte-per-byte even, as I check endianness
00:25:22 <dons> should do much as ocaml does
00:25:35 <vincenz> even with lazyness biting your ass?
00:26:04 <vincenz> sure for simple things it should, but my loganalyzer is hardly a 'map' or a 'filter'
00:26:05 <dons> doesn't have to bite. sometimes it can give you a good massage. try .lazy bytestrings..
00:26:22 <vincenz> I meant with lazyness building up a computation instead of modifying the state on the fly
00:26:41 <vincenz> it's very stateful in behaviour
00:26:44 <dons> if laziness is an issue, strictify things.
00:26:59 <dons> this is a lazy and strict language, remember :)
00:30:03 <lispy> it's also a pure and stateful language
00:31:51 <foxy> I'm parsing a file with ByteString but I don't know how to convert the file formats 3byte format into a Word32 http://www.biosemi.com/faq/file_format.htm
00:31:53 <lambdabot> Title: Biosemi EEG ECG EMG BSPM NEURO amplifiers systems
00:32:23 <dcoutts__> foxy: bit twiddling
00:32:25 <lispy> is ByteString a Word32?
00:32:30 <dcoutts__> no
00:32:34 <dcoutts__> but you need to know the endianness
00:32:35 <lispy> i thought it was word8
00:32:36 <foxy> no, I get three bytes
00:32:38 <lispy> ah
00:32:59 <dons> foxy, so you want to take each 3 bytes and pack it into a Word32?
00:33:07 <foxy> dons, yeah, exactly
00:33:25 <dons> i.e. f :: Word8 -> Word8 -> Word8 -> Word32 --?
00:33:25 <dcoutts__> byte1 `shiftL` 16 .|. byte2 `shiftL` 8 .|. byte3
00:33:36 <dons> concurrent teaching :)
00:33:43 <foxy> :)
00:33:48 * dons writes the types, dcoutts/djinn derives the code
00:33:58 <lispy> if you use addition and multiplication you don't need to know endianness though righT?
00:34:00 <roconnor> @djinn Word8 -> Word8 -> Word8 -> Word32
00:34:01 <lambdabot> -- f cannot be realized.
00:34:12 <dons> use @dcoutts
00:34:17 <roconnor> oh right
00:34:22 <dcoutts__> ha ha ha
00:34:25 <lispy> heh
00:34:33 <therp> code-inference - that's neat :)
00:35:06 <roconnor> @djinn (a -> b) -> b -> Maybe a -> b
00:35:06 <lambdabot> f a b c =
00:35:06 <lambdabot>   case c of
00:35:06 <lambdabot>   Nothing -> b
00:35:06 <lambdabot>   Just d -> a d
00:35:13 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
00:35:13 <lambdabot> f a b c =
00:35:14 <lambdabot>   case c of
00:35:14 <lambdabot>   Left d -> a d
00:35:14 <lambdabot>   Right e -> b e
00:35:56 <lispy> ?. pretty djinn (a -> b) -> (c -> b) -> Either a c -> b
00:35:56 <lambdabot> "Parse error" at column -13
00:36:09 <lispy> two questions
00:36:14 <lispy> why does that give a parse error
00:36:24 <lispy> why is the parse error at column -13? ;)
00:36:24 <dons> multilines are joined with \n' by dflt
00:36:33 <dons> hmm, magic?
00:36:41 <dons> not sure
00:36:58 <dons> if @djinn used explicit layout, it would work
00:37:02 <foxy> has anyone built CLAPACK on windoze?
00:38:00 <lispy> not i
00:38:27 * lispy needs to update his lambdaweb with bringert's patches but lispy has been busy...
00:38:37 <lispy> and i won't have time this weekend :(
00:38:50 <lispy> so if i don't do it tomorrow night...it may never happen at all...
00:39:40 <foxy> @paste
00:39:40 <lambdabot> http://paste.lisp.org/new/haskell
00:40:02 <lispy> heh
00:40:03 <lispy> 15789 virtuald  15   0 1320m  22m  85m S  0.0  2.2   0:00.17 java
00:40:13 <lisppaste2> foxy pasted "converting 3 bytes to Word32 don't work" at http://paste.lisp.org/display/26509
00:40:19 <lispy> and virtuald always complains that my emacs sessions are using too much memory....
00:40:36 <foxy> dcoutts, I get a type error with that code ^^^
00:41:01 <dcoutts__> foxy: you'll need to cast each byte to Word32 first
00:41:03 <dons> some missing fromIntegrals?
00:41:20 <foxy> ah, ok
00:41:22 <foxy> thanks
00:41:24 <dcoutts__> foxy: do make sure you get the endianness right
00:41:32 <foxy> how do I do that?
00:41:34 <dons> for reference, here's a Word32 binary read:
00:41:36 <dons> getWord32 :: Handle -> IO UInt32
00:41:36 <dons> getWord32 h = h `seq` do
00:41:36 <dons>     w1 <- getWord8 h
00:41:36 <dons>     w2 <- getWord8 h
00:41:38 <dons>     w3 <- getWord8 h
00:41:41 <dons>     w4 <- getWord8 h
00:41:43 <dons>     return $!! ((fromIntegral w1 `shiftL` 24) .|.
00:41:46 <dons>            (fromIntegral w2 `shiftL` 16) .|.
00:41:46 <dcoutts__> according to that diagram I think you want the bytes the otherway around
00:41:48 <dons>            (fromIntegral w3 `shiftL`  8) .|.
00:41:51 <dons>            (fromIntegral w4))
00:42:24 <dcoutts__> foxy: well, you'll figure it out, it's either one way round or the other :-)
00:42:36 <dcoutts__> it's not a big search space
00:42:41 <lispy> foxy: what does that file format store?  (followed the link but got a bunch of jargon i couldn't understand)
00:42:44 <foxy> dcoutts__: how do you swap the direction?
00:42:51 <foxy> lispy, brain wave data
00:43:03 <dcoutts__> foxy: permute 1 2 3 to 3 2 1 :-)
00:43:19 <lispy> foxy: cool
00:43:39 <lispy> you can actually calculate endianess at runtime
00:43:57 <foxy> I'm trying to convince the person I'm working with to let me write code in Haskell instead of Matlab, hence the need for CLAPACK
00:43:57 <lispy> i did this once because i was too lazy to find out what endianess my computer had :)
00:44:05 <roconnor> dons: that code is from your UM right?
00:45:03 <dons> yep :)
00:45:09 <roconnor> @hoogle getWord8
00:45:09 <lambdabot> No matches found
00:45:14 <dons> but before that, from NewBinary
00:45:43 * lispy needs to write an irc client which doesn't space leak
00:46:19 * vincenz sniffs at his code
00:46:29 <lisppaste2> roconnor pasted "bigE" at http://paste.lisp.org/display/26510
00:46:31 <dcoutts__> dons: we need a NewerBinary
00:46:37 <dons> we do!
00:46:52 <dcoutts__> but we can be cheaky and give is a more standard name
00:47:01 <roconnor> Binary
00:47:01 <dcoutts__> then people will beileve it's standard
00:47:04 <dons> yes ;)
00:47:10 <dcoutts__> NewBinary just looks bad
00:47:18 <dcoutts__> it shouts "please replace me!"
00:47:21 <roconnor> Trinary
00:47:33 <dons> I think i'll write Binary on Sunday the, class Binary a where put :: a -> ByteString ; get :: ByteString -> a
00:47:47 <dons> how's that sound?
00:47:57 * shapr cheers!
00:48:04 <roconnor> I have 6 bits in my byte :(
00:48:07 <vincenz> dons: with automatic advancement?
00:48:14 <lispy> dons: this is a fresh lambdabot  7601 dagit     16   0 48592  10m  19m S  0.0  1.0   0:00.32 lambdabot
00:48:18 <foxy> how do I cast a Word32 to a Double?
00:48:21 <vincenz> dons: and shouldn't that be monadic?
00:48:24 <dons> lispy: ?
00:48:27 <dons> vincenz: no.
00:48:27 <lispy> dons: but the one i just killed was using somethng like 80megs res
00:48:34 <dons> lispy: I know! ....
00:48:36 <vincenz> dons: put should be monadic
00:48:42 <dcoutts__> dons: hmm, that get doesn't give the remaining input
00:48:44 <lispy> dons: any ideas why that happens?
00:48:53 <dcoutts__> dons: the monadic interface does seem reasonable
00:48:58 <dons> lispy: I think its the seen state, but I'm not sure. I'll chase it up.
00:49:11 <roconnor> @type encodeFloat
00:49:12 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
00:49:13 <foxy> @hoogle Word32 -> Double
00:49:13 <lambdabot> No matches, try a more general search
00:49:14 <dons> vincenz, dcoutts__ then the other option is to have a -> Handle , via bytestrings
00:49:21 <lispy> dons: oh, i should run it for a few days compiled for profiling...i but that would help a lot
00:49:31 <lispy> which profiling...retainer?
00:49:35 <dons> lispy: mine got up to around 200M after 5 days
00:49:40 <dons> normally it sits on 10M or so.
00:49:44 <dons> so i've introduced a leak somewhere
00:49:44 <foxy> @index fromIntegral
00:49:45 <lambdabot> Prelude
00:49:46 <lispy> interesning
00:49:51 <roconnor> foxy: In principle you can use encodeFloat if you can get the mantissa and exponent.
00:50:00 <dcoutts__> dons: what do you mean about the Handle ?
00:50:06 <roconnor> one assumes there is a better way though.
00:50:37 <dons> oh, the current NewBinary interface is :: Handle -> IO a, Handle -> a -> IO ()
00:50:39 <dcoutts__> dons: you mean to a file handle? we should keep it pure
00:50:45 <dons> but then it has an icky layer to get at memory
00:50:53 <dcoutts__> dons: then there is no need for seperate in memory or io versions
00:51:01 <dons> so i'd prefer just a -> ByteString, ByteString -> a
00:51:15 <dcoutts__> dons: but that doesn't give the remaining input
00:51:19 <dons> or a continutation-ish readS version then
00:51:29 <dons> since we don't want to append
00:52:07 <dcoutts__> dons: if we use some kind of monad then it single threads the lazy bytestring underneatht
00:52:14 <dcoutts__> then we can append I think
00:52:20 <dons> ok, that'd work
00:52:23 <dcoutts__> so we use a monad
00:52:28 <dcoutts__> but running the monad is pure
00:52:30 <dons> a monadic ReadS, in essence?
00:52:34 <dcoutts__> aye
00:52:42 <dons> a bit like Parsec
00:52:46 <dcoutts__> so get :: Binary a; put :: a -> Binary
00:52:46 <lispy> could not findCould not find module `Data.ByteString.Char8':
00:52:49 <dcoutts__> so get :: Binary a; put :: a -> Binary ()
00:52:51 <dons> mm. yes.
00:52:52 <lispy> hmm...
00:53:12 <dons> lispy: did I commit a ghc 6.6 .cabal file by accident?
00:53:18 <dons> or not so accidental
00:53:19 <lispy> maybe
00:53:40 <dcoutts__> dons: or perhaps we need different monads for reading or writing
00:53:41 <lispy> i don't think it's the cabal file...
00:53:49 <lispy> fps>=0.7
00:53:50 <dons> in which case, tweak for .fps dependencies in the .cabal file
00:53:53 <dons> oh hmm
00:54:15 <lispy> and i have 0.8
00:54:19 <dcoutts__> deserialise :: Serialise a -> ByteString -> a
00:54:36 <dcoutts__> serialise :: Serialise a -> a -> ByteString
00:54:39 <dons> mmm
00:54:53 <dcoutts__> or something
00:54:55 <dons> yeah, i could live with something like that
00:55:17 <dcoutts__> serialise :: Deserialise a -> a -> ByteString
00:55:24 <dcoutts__> oops
00:56:28 <dcoutts__> pickle :: Pickle a -> a -> ByteString
00:56:28 <dcoutts__> unpickle :: Unpickle a -> ByteString -> a
00:56:52 <dcoutts__> get :: Unpickle a
00:56:55 <dons> roconnor: btw, you don't like g `fmap` f ?
00:57:00 <dcoutts__> put :: a -> Pickle ()
00:57:00 <dons> :)
00:57:09 <dons> mm. maybe
00:57:29 * vincenz screams
00:57:42 <vincenz> 20 miillion times the same concept in differnet forms
00:57:48 <vincenz> copy paste copy paste copy paste copy paste
00:58:02 <dons> heh vincenz goes crazy in ocaml world
00:58:10 <vincenz> yeah but I doubt it'd be much better in haskell
00:58:16 * dons hands vincenz a typeclass
00:58:22 <vincenz> dons: that wouldn't solve the issue
00:58:39 <lispy> dons: could it be because i turned on profiling?
00:58:40 <vincenz> a) c++: define mapping from packet to integer, encode data
00:58:49 <vincenz> b) ocaml: define mapping from integer to data type
00:58:49 <dons> lispy: I don't think so, i've seen the same thing here.
00:58:50 <lispy> dons: maybe it's complaining because it wants a profiling version of fps?
00:59:00 <vincenz> c) ocaml: have a switch statement from data type to proper function
00:59:00 <dons> i've pushed a couple of possible fixes , so we'll see if it recurs
00:59:06 <dons> lispy: ah yes. that's what it is
00:59:16 <vincenz> d) ocaml: have the definition of that function both in interface and implementation of the generic analyzer
00:59:27 <vincenz> e) ocaml: have a method on the specific analysis engines that matches this
00:59:29 <lispy> hmm...okay, i'll try to make a profiled fps
00:59:40 <dons> ./Setup.hs configure -p
01:00:37 <dons> I wonder if: input f = interact $ unlines . f . lines
01:00:46 <dons> should be in System.IO
01:00:52 <dons> or with another name
01:01:09 <dons> since it seems that interact + unlines.lines is really common
01:01:43 <lispy> interactMap
01:02:33 <dons> linesM ?
01:03:15 * vincenz needs some good metaprogramming
01:03:29 <lispy> hmm...profiled lambdabot is a pain to build
01:03:36 <lispy> because now i need a profiled hs-plugins
01:03:39 <lispy> which needs a profiled cabal
01:04:23 <lispy> maybe cabal needs a mode to install both profile and unprofiled versions at once by default (default per user)
01:04:30 <dons> lispy: you can't use hs-plugins profiled
01:04:40 <dons> i.e. remove the hs-plugins dep
01:04:43 <lispy> oh
01:04:50 <dons> and just keep a runplugs around from an old build
01:04:50 <dcoutts__> dons: btw did you grok the pure StringBuilder concept ?
01:05:02 <dons> ah, I never got back to that.
01:05:08 <dons> i should read it
01:05:19 * dcoutts__ is happy to explain
01:09:02 <lispy> dons: what breaks in hs-plugins when you try to profile?
01:09:16 * vincenz rubs his temples
01:09:27 <[MaKuBeX]> Visit http://www.omgema.lt  itÿs good . Have a nice day!
01:09:30 <lambdabot> Title: .: OMgema :.
01:09:37 <[MaKuBeX]> cool =]
01:09:42 <vincenz> [MaKuBeX]: erm....
01:09:55 <vincenz> damn he left
01:09:58 <vincenz> /w/hois [MakuBex]
01:10:33 <vincenz> . /ban *!*@omgema.lt ?
01:10:43 --- mode: ChanServ set +o dons
01:10:43 --- mode: ChanServ set +o vincenz
01:10:53 --- mode: ChanServ set -o dons
01:10:54 <dons> go for it
01:11:02 --- mode: vincenz set +b *!*@omgema.lt
01:11:03 <vincenz> done
01:11:17 --- mode: vincenz set -o vincenz
01:11:53 <vincenz> anyways, if I had scheme's macro system, a lot of this duplication could be bypassed, sadly scheme's performance is abysmal
01:12:21 <dcoutts__> is that because it's too dynamic ;-)
01:12:22 <lispy> vincenz: lisp has scheme's macro system on steroids and much better performance :)
01:12:26 <vincenz> to give you an idea
01:12:36 <vincenz> http://rafb.net/paste/results/EeKKlz28.html
01:12:41 <vincenz> and imagine like 30 of those
01:12:46 <lispy> sbcl for example, generates very fast code...not haskell fast, but fast
01:12:56 <sieni> lispy: yeah, right
01:13:01 <vincenz> thanks but no thanks
01:13:09 <vincenz> heh, I got into a funny argument on #scheme the other day
01:13:13 <lispy> vincenz: actually i thought ocaml had a macro system?
01:13:16 <vincenz> they said that a compiler could make a dyntyped language as fast a stat tpyed
01:13:20 <vincenz> lispy: it's horrible
01:13:42 <lispy> dons: Chasing modules from: scripts/QuickCheck.hs
01:13:43 <lispy> Could not find module `System.Eval.Haskell':
01:14:04 <dons> right. you need to keep and old quickcheck and runplugs around
01:14:05 <dons> and smallcheck
01:14:10 <sieni> lispy: at least the bignums were horribly slow in sbcl the last time I tried
01:14:14 <lispy> oh you tihnk that's the same probelm?
01:14:29 <skew> vincenz: sure, with one of these http://www.idsia.ch/~juergen/goedelmachine.html
01:14:32 <lambdabot> Title: GOEDEL MACHINE HOME PAGE, http://tinyurl.com/h7ts6
01:14:52 <bartw> moin
01:15:06 <vincenz> skew: :D
01:15:10 <vincenz> bartw: goede ochtend
01:15:39 <vincenz> one thing that irks me about o'caml is the redundancy of .mli and .ml files
01:15:45 <vincenz> that's one of the biggest irks
01:18:34 <roconnor> skew: it sounds slow
01:18:42 <skew> oh, for a while
01:18:55 <roconnor> ;)
01:19:18 <roconnor> proof search is very slow
01:19:37 <vincenz> woo, 174 character long lines \o/
01:19:48 * roconnor wonders what proof system they are using.
01:20:27 <skew> I don't think it matters too much.
01:20:47 <skew> But I do wonder whether there is such a thing as a proof that switching right now does better in all possible cases
01:21:03 <mux> omg, I watched that ICFP programming contest video, and it really looks like it was a hell lot of fun
01:21:11 <skew> you can still join!
01:21:14 <skew> you just can't win
01:21:17 <mux> heh
01:21:26 <roconnor> skew: sure it does.  The proof system limits which recursive functions are provably total.
01:21:52 <lmbdwr> oi
01:21:58 <roconnor> So it will miss certain more optimal algorithms that it can't prove are more optimal.
01:22:11 <lmbdwr> I have a small question regarding lambda calculus degree of terms
01:22:21 <roconnor> I should read the paper.
01:22:26 <bartw> i never understood the obsession with provability
01:23:32 <lmbdwr> I dont understand why the degree of the -redex- t is =< to the degree of the -term- t
01:23:56 <roconnor> provability is at the heart of correctness
01:24:06 <lispy> what does degree mean?
01:24:39 <lmbdwr> lispy: its like the degree of liberty, more or less.
01:25:02 <bartw> between world, to pragmatic for the theoretical side, and to clean for the pragmatists
01:25:08 <lispy> lmbdwr: which is?
01:25:53 <lmbdwr> d(T) = 1 if T is atomic, d(U x V) = d(U -> V) = max(d(U), d(V)) + 1
01:26:30 <lmbdwr> but you can define d(T) and D(T), one beeing the degree of the redex T and the other one the degree of the term T
01:27:09 <vincenz> time to debug
01:27:32 <lmbdwr> and its said that d(T) =< D(t)
01:27:54 <lmbdwr> e.g. the degree of the redex T is always smaller or equal to the degree of the -term- t
01:28:26 <lmbdwr> the degree of the term t beeing the maximum degree of his redex (hum hum)
01:29:11 <lispy> dons: i should go to bed...but for some reason this lambdabot doesn't write anything to the lambdabot.prof file (but it does create the file)
01:29:33 <dons> it won't until exit.
01:29:35 <lmbdwr> (sorry, in what I said : t = T)
01:29:45 <dons> though you sure you compiled the bot with -prof -auto-all ?
01:29:51 <foxy> @index zip4
01:29:51 <lambdabot> Data.List
01:30:33 <lispy> dons: well, -p --enable-executable-profiling
01:30:38 <lispy> dons: and run with +RTS -p
01:30:43 <dons> hmm
01:30:48 <dons> that should be enough
01:30:53 <lispy> dons: i told the bot to quit andthe file wast still empty
01:30:54 <dons> and it doesn't write anything on exit?
01:30:58 <dons> hmm
01:31:02 <dons> i'll look into it
01:31:22 <lispy> well, hopefully i'll look into it also
01:31:28 <lispy> :)
01:31:36 <lispy> but for now i'm turning in :)
01:31:55 <lmbdwr> ok hum I think I understood
01:33:12 <lispy> dons: is it because i built the plugin version?
01:33:20 <lispy> dons: maybe i have to build with the normal cabal file?
01:33:31 <dons> perhaps
01:33:32 <foxy> what's a good way of applying a list [a -> b] to a [[a]] to get [[b]] ?
01:33:41 <dons> I'd double check and add -prof -auto-all into the cabal file
01:33:56 <lispy> ah
01:33:58 <lispy> good idea
01:34:00 <dons> foxy: hmm. map ($) ?
01:34:01 <lispy> i was doing it in configure
01:34:22 <dons> ?type [ord, ord , ord]
01:34:23 <lambdabot> [Char -> Int]
01:34:32 <foxy> :t map ($)
01:35:17 <gds> @type map ($)
01:35:18 <lambdabot> forall a b. [a -> b] -> [a -> b]
01:35:19 <dons> ?type zipWith ($) [ord, ord , ord] ['x','y','z']
01:35:21 <lambdabot> [Int]
01:35:26 <dons> > zipWith ($) [ord, ord , ord] ['x','y','z']
01:35:28 <lambdabot>  [120,121,122]
01:35:56 <gds> [[a]] though - not [a] ;)
01:36:12 <dons> , yeah [[a]] and [a -> b] seems weird
01:36:18 <dons> concat the [[a]] first?
01:36:43 <gds> zipwith.map ?
01:36:54 <dons> > zipWith ($) [toUpper,toLower,toUpper,toLower.toUpper] $ concat ["foo","bar"]
01:36:56 <lambdabot>  "FoOb"
01:37:31 <foxy> nah, I have list of n samples of n channels and I need to apply a list of conversions for each channel to each sample
01:37:58 <dons> so the function at fns !! n should be applied to data !! n ?
01:38:03 <dons> or is it a fold?
01:38:10 <bartw> > toLower . toUpper "a"
01:38:10 <lambdabot>    Expecting a function type, but found `Char'
01:38:11 <lambdabot>    Expected type: a -> Ch...
01:38:26 <dons> > toLower . toUpper $ 'a'
01:38:28 <foxy> > zipWith ($) [(+ 1),(+ 2),(+ 3)] [[1,2,3],[2,3,4],[3,4,5]]
01:38:28 <lambdabot>  'a'
01:38:28 <lambdabot>  add an instance declaration for (Num [a])
01:38:30 <gds> Sounds to me like he wants to map your first zipwith over his list of samples...
01:38:34 <dons> > (toLower . toUpper) 'a'
01:38:35 <lambdabot>  'a'
01:38:51 <bartw> i don't get it :(
01:38:58 <dons> ?type toUpper
01:39:00 <lambdabot> Char -> Char
01:39:02 <dons> ?type toUpper 'a'
01:39:04 <lambdabot> Char
01:39:06 <lispy> bartw: ['a'] vs. 'a'
01:39:09 <dons> ?type toLower (toUpper 'a')
01:39:10 <lambdabot> Char
01:39:16 <dons> ?type "a" -- n.b.
01:39:17 <lambdabot> [Char]
01:39:21 <dons> ?type ['a']
01:39:22 <lambdabot> [Char]
01:39:30 <dons> > map toLower "some chars"
01:39:32 <lambdabot>  "some chars"
01:39:37 <bartw> ah right
01:39:40 <dons> > map (toUpper.toLower) "some chars"
01:39:42 <lambdabot>  "SOME CHARS"
01:39:58 <gds> > map (zipWith ($) [ord, ord , ord]) ["abc", "def"]
01:39:59 <lambdabot>  [[97,98,99],[100,101,102]]
01:40:05 <gds> foxy: That what you want?
01:40:06 <dons> nice gds
01:40:08 <bartw>  one little thing, what does '.' do ?
01:40:17 <dons> ?type (.) -- function composition
01:40:18 <gds> dons: Cheers:)
01:40:18 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
01:40:20 <foxy> 8) gds
01:40:34 <dons> bartw: so it takes a function from (b -> c), and another from (a->b)
01:40:40 <dons> and a value of type 'a'
01:40:53 <dons> and applies (a -> b -> c), giving you a final c
01:40:56 <dons> now, let's see:
01:41:00 <bartw> with right to left application
01:41:03 <bartw> ah right
01:41:07 <dons> > ord . toUpper $ 'x'
01:41:08 <lambdabot>  88
01:41:17 <dons> > (ord . toUpper)
01:41:19 <lambdabot>  <Char -> Int>
01:41:36 <bartw> why the $ then ?
01:41:46 <dons> that's just for avoiding parenthesis
01:41:48 <dons> ?type ($)
01:41:50 <lambdabot> forall b a. (a -> b) -> a -> b
01:41:56 <dons> i.e. f $ x = f x
01:42:06 <vincenz> dons: have a simple .hs file that demonstrates hwo to read byte per byte?
01:42:07 <dons> > toUpper $ 'x'
01:42:09 <lambdabot>  'X'
01:42:13 <vincenz> dons: something I could us as boilerplate?
01:42:19 <dons> > toLower (toUpper 'x')
01:42:20 <lambdabot>  'x'
01:42:25 <dons> > toLower $ toUpper 'x'
01:42:26 <lambdabot>  'x'
01:42:37 <bartw> ah ok
01:42:44 <dons> vincenz: hmm. let me see
01:42:49 <deadbeef> > toLower . toUpper $ 'x'
01:42:51 <lambdabot>  'x'
01:42:55 <bartw> i need to train my internal parser some maore then ;)
01:43:10 <dons> vincenz: getWord8 :: Handle -> IO Word8
01:43:11 <dons> getWord8 h = h `seq` do
01:43:11 <dons>     c <- hGetChar h
01:43:11 <dons>     return $! (fromIntegral (ord c))
01:43:15 <lispy> bartw: $ took me quite a while
01:43:15 <dons> you mean?
01:44:05 <dons> bartw: yeah, retraining your parser is a good way to put it
01:44:20 <dons> since you need to understand layout, to work out how far to the right the $ replaces the ( )
01:44:48 <dons> > (`map` [1..10]) $ \i -> i ^ 2 -- just for fun :)
01:44:50 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
01:44:56 <lispy> bartw: and when you're done with that one we have other fun challenges
01:45:01 <lispy> > join (*) 3
01:45:02 <lambdabot>  9
01:45:08 <mux> ?check \c -> toLower . toUpper $ c == c :: Char -> Bool
01:45:09 <lambdabot>  Couldn't match `Char' against `Bool'
01:45:09 <dons> heh
01:45:20 <mux> omg, I can never remember the correct syntax for quickcheck
01:45:25 <dons> mux, parens
01:45:32 <mux> mm
01:45:35 <vincenz> dons: this is not bytestring based?
01:45:43 <mux> ?check (\c -> toLower . toUpper $ c == c) :: Char -> Bool
01:45:43 <lambdabot>  Couldn't match `Char' against `Bool'
01:45:53 <vincenz> dons: and isn't going through char dangerous?
01:45:56 <dons> ?check \c -> (toLower . toUpper) c == c
01:45:57 <lambdabot>  OK, passed 500 tests.
01:46:05 <mux> ohhh.
01:46:14 <dons> let it infer the type (its not polymorphic once you use toupper)
01:46:20 <mux> right
01:46:25 <vincenz> erm
01:46:26 <vincenz> that's funny
01:46:31 <dons> vincenz: dangerous?
01:46:32 <vincenz> that test shouldn't pass for uppercase chars
01:46:37 <Syzygy-> Are you really guaranteed to get back c there?
01:46:45 <vincenz> dons: yeah, just like reading binary files in textformat is dangerous
01:46:48 <dons> ?scheck \c -> (toLower . toUpper) c == c
01:46:49 <lambdabot>  add an instance declaration for (Serial Char)
01:46:49 <lambdabot>   In the definition of `gak...
01:46:49 <mux> toLower . toUpper $ 'A'
01:46:53 <Syzygy-> > (toLower . toUpper) 'A'
01:46:54 <mux> DD> toLower . toUpper $ 'A'
01:46:54 <lambdabot>  'a'
01:46:56 <lispy> > (`map` [1..10]) $ join (*)
01:46:56 <mux> grr
01:46:57 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
01:47:00 <mux> yeah, it should have failed
01:47:04 <vincenz> @check \c -> (toLower . toUpper) c == c
01:47:04 <mux> I was expecting it to do so
01:47:05 <lambdabot>  OK, passed 500 tests.
01:47:08 <vincenz> @check \c -> (toLower . toUpper) c == c -- should fail!
01:47:09 <lambdabot>  OK, passed 500 tests.
01:47:13 <mux> @check toLower . toUpper == id
01:47:14 <lambdabot>  add an instance declaration for (Eq (Char -> Char))     In the definition o...
01:47:16 <Syzygy-> o.O
01:47:23 <mux> @check (toLower . toUpper) == id
01:47:23 <lambdabot>  add an instance declaration for (Eq (Char -> Char))     In the definition o...
01:47:24 <dons> oh, could be my Arbitrary Char instance
01:47:33 <lispy> > (`map` [1..10]) $ (*) `join`
01:47:33 <lambdabot>  Parse error
01:47:38 <vincenz> dons: lol
01:47:42 <dons> instance Arbitrary Char where
01:47:42 <dons>     arbitrary     = choose ('a', 'z')
01:47:42 <dons>     coarbitrary c = variant (ord c `rem` 4)
01:47:44 <dons> :D
01:47:46 <vincenz> dons: testinig is only as safe as your arbitrary :P
01:47:50 <mux> oops! :D
01:47:57 * dons hackifies
01:48:06 <Syzygy-> Ah.'
01:48:09 <lispy> > (`map` [1..10]) $ ((*) `join`)
01:48:11 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
01:48:12 <vincenz> hmm
01:48:12 <dons> since you guys are apparently betting your companies on lambdabot now...
01:48:14 <musasabi> @hoogle Monad m => m a -> m b -> m a
01:48:15 <lambdabot> Prelude.asTypeOf :: a -> a -> a
01:48:15 <lambdabot> Prelude.const :: a -> b -> a
01:48:15 <lambdabot> Prelude.seq :: a -> b -> b
01:48:26 <vincenz> @hoogle getWorkd8
01:48:27 <lambdabot> No matches found
01:48:29 <vincenz> @hoogle getWord8
01:48:30 <lambdabot> No matches found
01:48:36 <mux> lambdabot is my second most used haskell too after ghc ;-)
01:48:39 <mux> tool
01:48:43 <vincenz> dons: getword8 reasonably performant?
01:48:59 <dons> vincenz: yep, stick a {-# INLINE getWord8 #-} just to be sure
01:49:02 <Syzygy-> So far I think haskell and my local ghci rank more or less the same in time spent. :P
01:49:06 <lispy> vincenz: write code then optimize! :)
01:49:08 <dons> or ... use bytestrings to read huge chunks of Word8s...
01:49:10 <vincenz> dons: thx
01:49:27 <dons> Syzygy-: you mean, #haskell? or lambdabot?
01:49:30 <vincenz> lispy: bs, for well defined idioms one should just use em
01:49:37 <Syzygy-> dons: Well.. both, really.
01:49:45 * mux often uses lambdabot in offline mode to use the pl plugin
01:49:50 <mux> :-)
01:49:53 <Syzygy-> But comparison done on development time, and not just socializing...
01:49:55 <dons> me too. i have a vim binding for it
01:50:03 <vincenz> dons: ooh, gimme
01:50:09 <mux> :lambdabot pl ?
01:50:22 <mux> that would kick ass
01:50:27 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/vim/pl
01:50:29 <lambdabot> http://tinyurl.com/os99h
01:50:55 <mux> great
01:50:58 <lispy> mux: lambdabot is also on the web
01:51:05 <lispy> ?where lambdaweb
01:51:06 <dons> so just stick that somewhere executable, and use !!pl to refactor a line from vim
01:51:06 <lambdabot> I know nothing about lambdaweb.
01:51:20 <lispy> http://lambdabot.codersbase.com/
01:51:22 <lambdabot> Title: Lambdabot Web Interface
01:51:25 <mux> cool
01:51:40 <dons> n.b there's some other lambdabot scripts there, http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/vim/
01:51:41 <lambdabot> Title: Index of /~dons/code/lambdabot/scripts/vim, http://tinyurl.com/na787
01:51:44 <dons> one for inferring types I also use
01:51:57 <dons> using : :map ty :.!typeOf %^M
01:52:14 <deadbeef> www.christianubuntu.com
01:52:30 * dons boggles
01:52:46 <mux> heh, I was going to say we should write some ctags-like tool for haskell and call it htags, but there's already an htags
01:52:53 <mux> for C, C++, Java..
01:52:58 <dons> mux, yeah, just use htags :)
01:53:04 <dons> also known as hasktags
01:53:05 <mux> can it handle haskell?
01:53:07 <gds> @where+ lambdaweb http://lambdabot.codersbase.com
01:53:07 <lambdabot> Done.
01:53:07 <mux> aaah.
01:53:13 <mux> @where hasktags
01:53:13 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
01:53:25 <dons> i've got a precomputed tag file for the fptools library, here
01:53:33 <lispy> dons: fwiw, i went to the vanilla cabal file, added -prof -auto-all, cleaned and rebuilt and the resulting lambdabot was buggy (running vixen caused the bot to lock up)
01:53:58 <dons> lispy: hmm. ok. i'll chase this up
01:54:31 <dons> http://www.cse.unsw.edu.au/~dons/tmp/tags
01:55:39 * mux finishes his FreeBSD MFC candidates sweep
01:55:56 * mux notes boss is busy
01:55:59 <mux> time to write haskell!
01:56:35 <vincenz> ok dons
01:56:45 <vincenz> dons: gonna try rewriting my tool in haskell, or at least a subset thereof :)
01:56:49 <dons> ok
01:57:05 <vincenz> a lot of crap I had to do in ocaml comes for free in haskell
01:57:08 <vincenz> I mean... if you have ord instances
01:57:16 <vincenz> then your tuples are automatically ord'ed
01:57:25 <vincenz> and you don't have to define this yourselff to make a map over tuples
01:57:40 <vincenz> @hoogle Handle
01:57:41 <lambdabot> System.IO.Handle :: data Handle
01:57:41 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
01:57:41 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
01:57:54 <vincenz> @hoogle a -> Handle
01:57:55 <lambdabot> No matches, try a more general search
01:58:01 <vincenz> @hoogle a -> m Handle
01:58:02 <lambdabot> Prelude.id :: a -> a
01:58:02 <lambdabot> Prelude.asTypeOf :: a -> a -> a
01:58:02 <lambdabot> Prelude.const :: a -> b -> a
01:58:36 * dcoutts__ prods dons
01:58:42 <dons> hmm?
01:59:04 <dcoutts__> StringBuffer ? :-)
01:59:23 <dons> time for dinner!
01:59:24 * dcoutts__ is happy to give an explanation :-)
01:59:29 <dcoutts__> ha hah ha
01:59:35 <dcoutts__> see you later ;-)
01:59:36 * dons feels too fuzzy headed for new ideas at this hour
01:59:41 <dcoutts__> @arr
01:59:41 <lambdabot> Aye Aye Cap'n
01:59:43 <vincenz> localtime dons
01:59:45 <vincenz> @localtime dons
01:59:47 <lambdabot> Local time for dons is Fri Sep 22 18:59:24 2006
01:59:58 <dons> i've just done um. 10 hours straight hacking
02:00:01 <Syzygy-> @localtime vincenz
02:00:02 <dcoutts__> wow
02:00:08 <vincenz> 11am
02:00:38 <dcoutts__> dons: is that 10 straight hacking on "um"? :-)
02:01:03 <dons> heh
02:01:05 <dons> @check \c -> (toLower . toUpper) c == c -- should fail!
02:01:07 <lambdabot>  Falsifiable, after 362 tests: '\482'
02:01:12 <dons> vincenz: happy?
02:01:17 * mux happy
02:01:25 * Syzygy- happy
02:01:34 * dcoutts__ happy
02:01:38 <dcoutts__> why are we happy?
02:01:38 <vincenz> dons: yep :)
02:01:55 <Syzygy-> dcoutts__: Because @check recognizes that toLower.toUpper /= id
02:02:15 <dcoutts__> oh good, it used not to?
02:02:20 <vincenz> nope
02:02:24 <vincenz> it used to give 500 Tests OK
02:02:29 <vincenz> on toLower . toUpper $ c == c
02:02:34 <vincenz> (with proper parens)
02:02:37 <dcoutts__> because it bounded chars to 255 ?
02:02:44 <vincenz> no
02:02:47 <vincenz> cause it only used lowercase
02:02:50 <Syzygy-> because it took chars out of 'a' .. 'z'
02:02:50 <vincenz> uppercase would fail on that
02:03:00 <mux> the Arbitraty Char instance was wrong
02:03:05 <dcoutts__> ohh, naughty
02:03:08 <mux> doh, Arbitrary
02:03:14 <vincenz> Arbitrary is arbitrary
02:03:30 <dcoutts__> I feel arbitRaty sometimes
02:03:41 <dons> yeah, it was an arbitrary Arbtrary
02:04:03 <vincenz> dcoutts__: arbit raty?
02:04:15 <dcoutts__> ar bit ratty?
02:04:21 <mux> arctic rabbit?
02:04:42 <vincenz> @arr
02:04:43 <lambdabot> Drink up, me 'earties
02:11:06 <vincenz> dcoutts__: vim or emacs?
02:12:10 <gour> i just stumbled on very interesting post - for haskell lovers http://lua-users.org/lists/lua-l/2006-08/msg00512.html
02:12:10 <dcoutts__> vincenz: nedit & vim
02:12:10 <lambdabot> Title: Re: Lua vs. Haskell (was Re: Bridging Lua to native C/C++ code automatically), http://tinyurl.com/ox8xn
02:13:14 * vincenz nods at dcoutts 
02:15:22 * mux tired of his searches returning files in _darcs/ and creates self a darcsgrep script
02:17:30 <mux> find . -type f ! -ipath "*/_darcs/*" -name "*.hs" -print0 |
02:17:36 --- topic: '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]'
02:17:36 --- topic: set by ChanServ on [Wed Sep 06 22:32:40 2006]
02:17:42 <vincenz> grep -r "mystuff"  | grep -v "_darcs"
02:17:51 * vincenz shrugs
02:18:18 <mux> that does unnecessary searches and is thus less efficient, also it greps other files than .hs ones
02:18:24 <mux> so it's not really what I want :-)
02:18:51 <vincenz> @hoogle int32
02:18:52 <lambdabot> Data.Int.Int32 :: data Int32
02:18:57 <psnl> mux: you would have problems if you got about 4096 source files, but unless you are searching ghc.....
02:19:01 <vincenz> @hoogle uint32
02:19:02 <lambdabot> No matches found
02:19:09 <mux> psnl: I wouldn't
02:19:09 <vincenz> dcoutts__: is there such a thing as an unsigned 32bitter?
02:19:29 <dcoutts__> never heard of such a thing
02:19:31 <mux> psnl: you are apparently referring to the ARGS_MAX problem but that isn't relevant since this is using find and xargs
02:19:32 <psnl> mux: how so?
02:19:46 <vincenz> Uint32?
02:19:59 <bartw> psnl: it uses stdout for passing filesnames
02:20:16 <bartw> psnl: find -print0 | xargs -0
02:20:48 <mux> and btw, ARG_MAX is often much more than 4096 these days
02:20:57 <mux> butane% getconf ARG_MAX
02:20:57 <mux> 262144
02:21:24 <psnl> mux: cool
02:22:02 <mux> this is FreeBSD, I don't know if Linux has getconf already
02:22:17 <mux> they are not so keen on following the POSIX specs :-)
02:22:25 <dcoutts__> getconf ARG_MAX
02:22:25 <dcoutts__> 131072
02:22:31 <psnl> bartw: yeah, your right
02:22:31 <mux> oh fear, my bad :-P
02:22:38 <psnl> s/yor/you're/
02:22:46 <mux> the Linux guys are up-to-date! shock! :-)
02:23:02 <mux> dcoutts__: I suppose they also have sysconf()/pathconf() ?
02:23:47 <dcoutts__> yep
02:26:01 <mux> psnl: for the record, the -print0 / xargs -0 is not what works around the ARG_MAX problem, xargs + find is sufficient, the -print0 / -0 trick is for the command to handle filenames with spaces correctly
02:26:21 <psnl> mux: aye
02:26:33 <yip> dcoutts__: hey
02:26:35 <vincenz> \o/ for incremental design.  Haskell so rocks... I can start with simple data types, just use "type xxx = UInt32" and then later I can choose to lock down on the implementation by newtyping it and only allowing certain tcs :)
02:26:45 <dcoutts__> yip: hia, not yet
02:27:41 <yip> dcoutts__: ok cool thanks anyway :\
02:27:58 <dcoutts__> yip: it is nearer the top of the todo list though :-)
02:28:00 <yip> dcoutts__: btw, i applied that patch and everything compiled correctly
02:28:06 <yip> dcoutts__: sweet :)
02:28:07 <dcoutts__> great
02:28:21 <yip> dcoutts__: only problem is that gtk2hs programs only run when compiled, not interpreted
02:28:33 <dcoutts__> yip: oh?
02:28:37 <yip> dcoutts__: is it true that in ghc 6.6 the interpreter is now runs in "threaded" mode?
02:28:43 <dcoutts__> ah yes
02:29:12 <vincenz> @hoogle UInt32
02:29:13 <lambdabot> No matches found
02:29:40 <yip> *** Exception: user error (initGUI: Gtk2Hs does not currently support the threaded RTS
02:29:41 <yip> see http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
02:29:41 <yip> Please relink your program without using the '-threaded' flag.)
02:29:44 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Writing multi-threaded GUIs, http://tinyurl.com/j7dxw
02:29:44 <vincenz> where is UInt32 defined?
02:29:59 <dcoutts__> yip: yup
02:30:11 <dcoutts__> vincenz: I think you mean Word32
02:30:33 <vincenz> oh
02:31:07 <vincenz> th
02:31:07 <vincenz> thx
02:31:57 <yip> dcoutts__: is there any plan to fix this bug in gtk2hs?
02:32:07 <dcoutts__> yip: it's not a bug in gtk2hs
02:32:12 <dcoutts__> it's a limitation in ghc
02:32:46 <yip> dcoutts__: that blog post mentions possible work arounds
02:32:58 <dcoutts__> I've been talking to JaffaCake about it but there's no concrete plan yet
02:33:06 <dcoutts__> yip: they all involve not using -threaded
02:33:35 <yip> dcoutts__: what about fixing the limitation of ghc then?
02:33:50 <dcoutts__> as I said, I've been talking to JaffaCake about it
02:43:09 <roconnor> Is the GÃ¶del machine conscious?
02:43:28 <roconnor> A: If we equate the notion of ``consciousness'' with the ability to execute unlimited formal self-inspection and provably useful self-change (unlimited except for the limits of computability and provability), then the GÃ¶del machine and its Global Optimality Theorem do provide the first technical justification of consciousness in the context of general problem solving.
02:43:41 <roconnor> apparently I'm not conscious.
02:44:33 <vincenz> @hoogle ($!!)
02:44:35 <lambdabot> Did you mean: ($!!)
02:44:35 <lambdabot> Prelude.undefined :: a
02:44:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
02:44:58 <skew> probably something to do with DeepSeq
02:47:18 * vincenz nods
02:47:54 <bartw> roconnor : that response is pretty bad, "if by good you mean evil, yes i'm good"
02:50:02 <roconnor> seq puts something in head normal form, while deepseq puts it in normal form?
02:50:33 <skew> yay, my GADTs are turning all my case ... Foo -> error "Foo should be gone by now" into "Inaccessible case alternative ..."
02:50:54 <vincenz> skew: woo
02:50:58 <roconnor> Haskell is turning into epigram.
02:52:23 <skew> that reminds me, does anyone around here know how you might help ESC/Haskell validate your annotations?
02:52:49 <vincenz> btw
02:52:57 <vincenz> what is the accepted way of working?
02:53:01 <vincenz> for operations that may fail?
02:53:06 <vincenz> exceptions?
02:53:20 <vincenz> right now the type is:  :: String -> IO LogFile
02:53:30 <skew> excellent, -fwarn-incomplete-patterns appears to also agree that those cases can no longer happen
02:53:33 <vincenz> but this may fail if it has the wrong heade r(I have some magic bytes at the beginning)
02:53:44 <mux> vincenz: Maybe?
02:54:03 <vincenz> IO (Maybe LogFile)?
02:54:05 <vincenz> seems yucky
02:54:06 <Saulzar> I'd say exceptions are cleaner in general
02:54:33 <roconnor> (Monad m) => IO (m Logfile)
02:54:43 <mux> exceptions could do too
02:54:45 <Saulzar> If it's a pure structure you can return it in an arbitrary monad, like Data.Map.lookup...
02:54:52 <mux> whether it's more or less convenient probably depends on the rest of the code
02:55:33 <wkh> thank the good lord for the pirate bya
02:55:35 <bourbaki> moin
02:55:35 <vincenz> that's pretty yucky :/
02:55:39 <vincenz> I'll just throw an exception
02:56:00 <wkh> i remember when i didn't know who bourbaki was
02:56:04 <roconnor> If you are already in the IO monad, you might as well throw an exception.
02:56:12 <wkh> i was in the library and i was like "god damn that guy wrote a lot of god damn books!"
02:56:12 <vincenz> @pl \x -> sequence $ replicate 4 x
02:56:13 <lambdabot> sequence . replicate 4
02:56:20 <bourbaki> wkh wasnt your live dull back these days :)?
02:56:21 <vincenz> suggestions for shortening?
02:56:38 <mux> replicateM maybe?
02:56:40 <dons> vincenz: replicateM_ ?
02:56:44 <wkh> bourbaki: buh? :(
02:56:50 <vincenz> @type replicateM
02:56:51 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
02:56:53 <vincenz> \o/
02:56:55 <bourbaki> wkh are you a mathematician?
02:56:58 <mux> yay, I'm a haskell lord, I gave the same answer as dons :-P
02:56:59 <mux> or nearly!
02:57:08 <vincenz>   cs <- replicateM (getWord8 handle)
02:57:10 <dons> ?type replicateM_
02:57:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
02:57:23 <dons> ah, but my answer is wrong :)
02:57:26 <roconnor> there's a replicateM!
02:57:43 <roconnor> OMG
02:57:51 <vincenz> dons: thx :)
02:58:14 <roconnor> can someone list all the useful function that I don't know about plz?
02:58:21 <mux> heh
02:58:22 <wkh> bourbaki: i'm a math fan
02:58:43 <wkh> but right now i am downloading dvd-rs and listening to tunes instead of doing math
02:58:47 <wkh> and soon i will sleep!
02:59:27 <vincenz> dons: so... my IO LogFile return... just throw exceptions?
03:00:08 <vincenz> @hoogle unless
03:00:09 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
03:00:09 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
03:00:09 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
03:11:38 <Bobstopper> Is there a way I can modify the "no parse" error read can give within a pure function?
03:11:54 <mnislaih> has anyone ever written a fixpoint monad ? Does it make any sense ?
03:12:16 <mnislaih> i.e. a monad in which all computations are fixpoint
03:14:00 <skew> I don't know about fixpointing everything, but see www.cs.nott.ac.uk/~txa/talks/bctcs06.pdf
03:15:05 * mnislaih gives a look
03:16:29 <skew> that's more about shoving nontermination, and the ability to take general fixpoints off into a monad
03:16:44 <dcoutts__> Bobstopper: see reads
03:16:47 <dcoutts__> @type reads
03:16:49 <lambdabot> forall a. (Read a) => ReadS a
03:17:04 <dcoutts__> it gives the list of all parses, or [] for none
03:20:38 <dcoutts__> @type Maybe.listToMaybe . map fst . reads
03:20:40 <lambdabot> forall a. (Read a) => String -> Maybe a
03:20:48 <dcoutts__> Bobstopper: ^^
03:21:36 <dcoutts__> or case reads "foo" of [] -> ... ; ((x,_):_) -> ... x ... ;
03:22:00 <Bobstopper> ok, thanks
03:22:42 <Bobstopper> Also, is there somewhere I can get at GHC's darcs (or whatever it uses) repository? I'd like to submit a patch against the latest source.
03:25:40 <Lemmih> Bobstopper: A patch for GHC or for the libraries?
03:26:01 <Bobstopper> libraries actually I think. Network.Socket.
03:27:19 <Lemmih> Then you want: http://darcs.haskell.org/pacakges/network
03:27:27 <Bobstopper> thanks
03:28:32 <Lemmih> What are you patching, btw?
03:29:43 <Bobstopper> implementing inet_addr and inet_ntoa outside the IO monad
03:30:50 <dons> Bobstopper: the details for getting the darcs source are on the 'Developers Wiki' page at haskell.org/ghc
03:31:01 <Bobstopper> tah
03:33:45 <gour> what's the nick of Malcolm (haxml author) ?
03:40:43 <dons> gour: 'malcolm'
03:41:36 <gour> dons: thank you
03:44:28 <vincenz> \o/
03:44:31 <vincenz> much cleaner :)
03:45:43 <vincenz> @hoogle getARgs
03:45:44 <lambdabot> System.getArgs :: IO [String]
03:52:11 <vincenz> stupid question
03:52:16 <vincenz> how do I get a lazy list from a file that I'm reading?
03:52:26 * vincenz has a function
03:52:31 <vincenz> Handle -> IO (Packet)
03:52:40 <vincenz> now I'd like Handle -> IO [Packet]
03:52:43 <vincenz> that autocloses at the end
03:52:46 <vincenz> (or is that last not feasible?
03:53:37 <musasabi> do you have a "String -> (Packet,String)" function?
03:53:54 <vincenz> no
03:54:08 <musasabi> for the easy solution. Of course you can always use unsafeInterleaveIO
03:54:38 <skew> hmm, ghc doesn't seem to be very good at working out exhaustivity of cases on GADTs
03:54:50 <vincenz> musasabi: I'm just curious ... if I return a IO [Packet]]
03:54:54 <vincenz> will it still be lazy?
03:55:49 <musasabi> vincenz: depends on how you do it.
03:56:00 <musasabi> with unsafeInterleaveIO the general idiom is:
03:56:05 <vincenz> http://rafb.net/paste/results/Trdg7A62.html
03:56:20 <vincenz> that safe?
03:56:26 <vincenz> or will it close the file prematurely?
03:56:30 <vincenz> (or possibly force it all into memory)
03:57:04 * vincenz adds a 'do' after then
03:57:06 <musasabi> getPackets :: Handle -> IO [Packet]; getPackets h = unsafeInterleaveIO $ do if atEnd then hClose h >> return [] else do p <- getPacket h; ps <- getPackets h; return (p:ps)
03:57:33 <vincenz> why the need for unsafeInterleaveIO?
03:57:55 <musasabi> vincenz: if you want it to be lazy. Your function is strict. Depends on what behaviour you want.
03:58:02 <vincenz> oh
03:58:19 * vincenz nods
03:58:28 <skew> If I get an "Inaccessible case alternative" error when I have a pattern, I shouldn't get a "Pattern match(es) are non-exhaustive" warning when I remove it!
03:58:42 <vincenz> musasabi: I could just do a sequence getPacket
03:58:43 <musasabi> a stylistic note: "liftM2 (:) (f h) (getPackets lf)" may be more readable than the `ap` thing.
03:58:53 <vincenz> musasabi: but the issue is with isEof
03:59:00 <skew> Wait, I'm using some random 6.5, maybe it's been fixed
03:59:06 <vincenz> the isEof is bugging me :/
04:00:00 <vincenz> I'll use unsafeInterlave
04:00:01 <vincenz> thanks :)
04:00:52 <gour> hi, anyone has some experience with haxml?
04:12:58 <roconnor> mnislaih: I've successfully used a fixpoint (state) monad, and could successfully reimplement it I believe.
04:13:02 <mux> gour: I have used it a bit
04:13:23 <mnislaih> roconnor: is the code online or do you have it around ?
04:14:15 <roconnor> the code that uses the fixpoint monad, or the code that implements a fixpoint state monad?
04:14:26 <gour> mux: it looks haxml is more user-friendly (at least for novice) than hxt?
04:14:31 <mnislaih> I'm interested in what such a monad looks like
04:14:36 <mux> gour: IMHO yes
04:14:51 <mux> HXT has a very complex interface, way too much arrows and stuff
04:15:01 <roconnor> It should be easy to pull out the definition of monad fix from the state monad definition in GHC.
04:15:24 <roconnor> where are the haskell sources to the standard lib for GHC?
04:15:28 <roconnor> @where sources
04:15:29 <lambdabot> I know nothing about sources.
04:16:03 <roconnor> mnislaih: I looked at it before online.  It was very instructive.  I just need to find it again.
04:16:04 <dons> ?fptools Data.List
04:16:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
04:16:07 <gour> mux: i'd need to import (insert into sqlite database) xml files (each record from database is in one xml file) into my application
04:16:10 <gour> mub
04:16:19 <yip> mux: what's wrong with the arrows? they have excellent type safety
04:16:24 <roconnor> ?fptools Mondad.State
04:16:25 <lambdabot> Mondad.State not available
04:16:36 <gour> mux: and then be able to export database record(s) into valid xml
04:16:51 <roconnor> ?fptools Control.Mondad.State
04:16:51 <lambdabot> Control.Mondad.State not available
04:16:55 <roconnor> ?fptools Control.Monad.State
04:16:56 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
04:16:59 <dons> ?source Control.Monad
04:16:59 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
04:17:02 <gour> mux: however i'd like to design relaxng for my xml format, but haxml works only with dtd
04:17:16 <roconnor> mnislaih: there it is
04:17:20 <roconnor> instance MonadFix (State s) where
04:17:20 <roconnor> 	mfix f = State $ \s -> let (a, s') = runState (f a) s in (a, s')
04:17:32 <mux> yip: the problem is not with the arrows themselves but with the fact that there are way too many of those, and generally too many functions in HXT
04:18:25 <gour> mux: will haxml get support for relaxng?
04:18:30 <SamB> mux: and that *ALL* of them are exported
04:18:32 <mux> gour: I have no idea
04:18:34 <SamB> or at least it seems like it
04:18:40 <mux> SamB: yeah
04:18:47 <SamB> someone should do relaxng support for haxml
04:18:58 * gour agrees
04:19:01 <SamB> and include direct support for Compact from the start
04:19:10 <gour> right
04:19:20 <SamB> or, at least, make it easy
04:19:53 <mux> I was thinking about some possible improvements to the Haskell2Xml stuff as well
04:20:24 <mux> there are some limitations there that makes it hard to get exactly the data structure you want from XML
04:20:37 <musasabi> I think there is some relax ng haxml thing existing.
04:20:39 * gour would like to see support for relaxng & compact syntax -perfect
04:20:40 <malcolm> mux: the haskell2xml stuff has changed anyway
04:20:41 <roconnor> mnislaih: so you see, the output of the runState, a, is passed as an argument that your monad can use.
04:20:54 <roconnor> mnislaih: classic circular programming
04:20:55 <mux> malcolm: oh? where can I see about these changes?
04:21:13 <gour> malcolm: relaxng support?
04:21:25 <musasabi> http://www.cs.uu.nl/docs/vakken/gp/index2004-2005.html <- maybe something was implemented?
04:21:28 <lambdabot> Title: Generiek Programmeren, http://tinyurl.com/zvoht
04:21:31 <gour> musasabi: yes, hxt
04:21:34 <malcolm> no relaxng support yet - i'm happy to include it if someone writes it
04:22:14 <malcolm> haskell2xml and dtd2haskell both now use a single XmlContent class
04:22:35 <SamB> I sent some Relax NG Compact code to the libraries list and got no response...
04:22:46 <malcolm> and the parser from untyped XML representation to typed representation is much better - gives error messages even
04:22:55 <SamB> or, at least, not very soon after
04:24:07 <malcolm> HXT seems to have relaxNG support
04:24:15 <SamB> yes it does
04:24:30 <SamB> but it also has "Eeek! too many functions!" support :-(
04:25:11 <SamB> HXT seems to be a conglomeration of code written to go along with papers, and not much more...
04:25:22 <SamB> or do I mean not much *less*
04:25:54 <mux> yeah
04:25:59 <yip> but it has that cool arrow interface
04:26:24 <gour> malcolm: haxml is more usable ;)
04:26:41 <mux> malcolm: are we still limited to use data/newtype for XmlContent?
04:27:00 <SamB> mux: what else is there?
04:27:05 <malcolm> mux: what else is there?
04:27:06 <mnislaih> roconnor: sorry if I failed to say thanks. I was absorted thinking
04:27:33 <mux> I don't remember but I used to think about another way of doing all this
04:27:41 <mux> which wouldn't be so constraining
04:27:53 <mux> I'll have to get back to it
04:28:07 <SamB> ... how else do you get types, mux?
04:28:14 <mux> this is not a matter of how to get types
04:28:27 <mux> but a way to implement the XmlContent stuff without being forced to overload types such as Strings
04:28:45 <mux> just to be able to define new fromAttrs/toAttrs methods and such
04:28:51 <SamB> oh
04:28:57 <SamB> that does sound rather icky
04:29:00 <mux> I don't remember what it was though :-P
04:29:19 <malcolm> I see - gabrielle was mentioning to me about how she overloads the attributes using a class
04:29:22 <SamB> annotations in comments?
04:29:46 * mux scratches his head hard
04:31:22 <mux> maybe I just dreamt it - I'll have to get back to HaXml and think about it some more but I can't at the moment, $REALJOB etc
04:33:20 <SamB> mmhmm
04:33:30 * SamB has some $SCHOOL to go to fairly soon
04:33:45 <mux> $SCHOOL > $REALJOB
04:33:46 <mux> :-)
04:33:54 <mux> I wish I was still a student
04:34:04 <SamB> well. it is only a community college...
04:37:07 <musasabi> HXT is very cool for trying out things, HaXML is good for code that works.
04:37:35 <SamB> HXT is good if you have a lot of time to waste looking for methods that you might actually want to use
04:37:42 <sek> @t partition
04:37:42 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
04:37:45 <SamB> or, um, functions
04:37:54 <SamB> sek: what?
04:37:57 <sek> @type partition
04:37:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:38:02 <sek> thats the one:p
04:38:05 <SamB> oh, yeah. @type ;-)
04:38:28 <SamB> @free partitition
04:38:30 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `partitition'\n\n"
04:38:42 <SamB> @free partition
04:38:43 <SamB> oops
04:38:43 <lambdabot> $map f ($fst (partition (g . f) xs)) = $fst (partition g ($map f xs)) && $map f ($snd (partition (g . f) xs)) = $snd (partition g ($map f xs))
04:38:57 <SamB> I hate it when I add extra copies of a sylable
04:38:59 <sek> whats that?
04:39:07 <SamB> thats a free theorem
04:39:19 <SamB> unfortunately you often seem to get what you pay for
04:39:22 <sek> like a proof that it works>?
04:39:34 <dons> ?help free
04:39:34 <lambdabot> free <ident>. Generate theorems for free
04:39:43 <SamB> no, a proof of what it could do in an idealized world based on its type
04:39:46 <dons> ?google free theorems wadler
04:39:48 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
04:39:55 <SamB> or rather, something that would be true ideally based on its type.
04:39:58 <dons> ?ft partition
04:39:59 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
04:40:00 <lambdabot>   forall f1 :: T1 -> Bool.
04:40:00 <lambdabot>    forall g1 :: T2 -> Bool.
04:40:00 <lambdabot>     (forall x2 :: T1.
04:40:00 <lambdabot>      f1 x2 = g1 (h1 x2))
04:40:01 <lambdabot> [7 @more lines]
04:40:08 <dons> or the mega version
04:40:15 <sek> i see
04:40:21 <SamB> (seq seems to throw a wrench in the works, though)
04:41:12 <sek> man, you've all done an amazing job with this bot
04:41:15 <SamB> oooh, strictnes in this one?
04:41:22 <SamB> sek: well, I'
04:41:23 <SamB> er.
04:41:30 <SamB> I'm not sure *all* of us have contributed
04:42:04 * SamB wrote the google plugin and apparantly the todo plugin as well
04:42:04 <dons> SamB: yeah. Janis is really careful with the strictness
04:42:09 <dons> ?ft id
04:42:10 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
04:42:10 <lambdabot>   forall x1 :: T1.
04:42:10 <lambdabot>    h1 (t1 x1) = t1 (h1 x1)
04:42:15 <dons> ?free id
04:42:17 <lambdabot> f . id = id . f
04:42:28 <SamB> hmm
04:42:36 <sek> nice, anyhow, its a great example of a full scale standalone haskell program that does alot
04:42:39 <SamB> dons: why doesn't it use the name id?
04:42:50 <SamB> sek: and you can write something too!
04:42:56 <SamB> if you think of anything
04:43:14 * SamB needs to go to school soooooon
04:43:32 <sek> i would if a could and had the time
04:43:49 <SamB> sek: you could if you had the time
04:44:02 <dons> ?check \f -> (f . id) x == (id . f) (x :: I)
04:44:03 <lambdabot>  Not in scope: `x'
04:44:09 <dons> ?check \f x -> (f . id) x == (id . f) (x :: I)
04:44:10 <lambdabot>  Add a type signature
04:44:33 <dons> ?check (\f x -> (f . id) x == (id . f) x) :: (I -> I) -> I -> Bool
04:44:34 <lambdabot>  OK, passed 500 tests.
04:45:29 <dons> ?scheck (\f x -> (f . id) x == (id . f) x) :: (I -> I) -> I -> Bool
04:45:35 <lambdabot> Terminated
04:45:39 <dons> too hard
04:45:51 <dons> ?scheck (\f x -> (f . id) x == (id . f) x) :: (Bool -> Bool) -> Bool -> Bool
04:45:52 <lambdabot>  Completed 8 test(s) without failure.
04:46:02 <dons> 8 tests. clever
04:46:11 <SamB> dons: actually no
04:46:48 <SamB> it is simple simple simple
04:46:52 <dons> no? am i reading too much in there, and that's just depth 8?
04:47:29 <SamB> in this case it just passes in all possible values
04:47:39 <dons> right, so its clever.
04:47:42 <SamB> there are only four different functions from Bool -> Bool
04:47:58 <mux> dons: hey, I forgot to ask you, lambdabot is apparently infected with the GPL so I can't release my Figlet plugin under a BSDL? :-)
04:48:49 <dons> release it under whatever you want.
04:48:53 <SamB> mux: why not? dons is not mean!
04:48:56 <dcoutts__> BSD is compatible with GPL
04:49:07 <mux> well, you can't link GPL code with BSD code
04:49:12 <dcoutts__> yes you can
04:49:15 <SamB> sure you can
04:49:16 <dcoutts__> the result is GPL
04:49:17 <dons> umm.... sure you can.
04:49:25 <mux> yes, the result is GPL, so you can't
04:49:30 <dcoutts__> doh!
04:49:33 <SamB> but, the source is still BSD
04:49:38 <dons> unless its a dynamic plugin framework...
04:49:42 <mux> that's the very reason the FreeBSD kernel isn't shipped with GPL'ed modules such as ext2fs
04:49:44 <SamB> so you could tear it out and use it for something else
04:49:50 <mux> or we'd be fucked
04:49:59 <mux> I don't really care anyways
04:50:06 <dcoutts__> mux: you can only not do it if you're not happy with the result geing GPL
04:50:15 <dcoutts__> since it's already GPL that's ok
04:50:18 <SamB> I don't think you'd be fucked if they were optional
04:50:23 <mux> it is optional
04:50:30 <dcoutts__> so you can add BSD to a GPL system and remain a GPL system
04:50:32 <SamB> I mean BSD source is released anyway...
04:50:35 <mux> but we can't for instance ship a kernel containing a GPL module
04:50:44 <SamB> you can't?
04:50:46 <SamB> why not?
04:50:48 <dcoutts__> you can't add GPL to a BSD system and remain a BSD system
04:50:49 <mux> no, or we'd do it
04:51:03 * SamB doesn't understand GPL
04:51:15 <SamB> you could, I think.
04:51:21 <dcoutts__> SamB: you can do it, it's just that people don't want to
04:51:25 <mux> no, that's 100% sure
04:51:34 <dcoutts__> because they're not happy with the overall result being GPL
04:51:37 <SamB> you'd have to offer the whole source under the GPL terms, but that is easy to get
04:51:40 <mux> of course we're not :-)
04:51:42 <mux> this is FreeBSD
04:51:58 <SamB> just take the original source and change the headers to be GPL headers...
04:52:06 <dcoutts__> but the reverse is not a problem at all
04:52:16 <dcoutts__> liunx has lots of BSD licensed modules
04:52:20 <SamB> you don't have to *only* offer GPL source
04:52:21 <mux> yep
04:52:27 <mux> BSDL isn't a virus, GPL is
04:52:48 <mux> the viral nature of the GPL is the very reason behind LGPL for instance
04:53:13 <mux> but I'm digressing
04:53:17 <wolverian> mux, it's a voluntary virus, though :)
04:53:29 * wolverian thinks that word is misused in this context
04:53:48 <mux> I'd rather not even enter this argument :-P
04:54:18 <camster> Does anyone have any idea what the HAppS documention is alluding to when it says it uses "write ahead logging of queued events" and claims this works out because protocls like HTTP and SMTP are atomic?
04:54:34 <dons> camster: try musasabi . he probably wrote that
04:56:14 <mux> dons: any reason why ircPrivilegedUsers is a "Map String Bool" in IRCRWState, with every Bool set to True?
04:56:17 <camster> Will do. I can understand how he can do some sort of STM approach to recreate the internal state of the application from the write ahead logs, but I can't see where SMTP fits in. If there's an HTTP request which sends an email as a side-effect, then I can't see how a duplicate email won't be sent if the application tries to recreate its internal state after a crash by replaying the log.
04:56:23 <SamB> I think the viral nature of the GPL is only a problem when you wanted a *more* restrictive license
04:57:25 <SamB> or when you start moving the code about
04:57:29 <SamB> anyway, to school I go
04:57:35 <SamB> I hope I don't miss the busses
04:58:48 <mux> well I think your point doesn't hold if you consider the BSDL, which is much *less* restrictive than the GPL
04:58:51 <mux> but enjoy school :-)
04:59:58 <twanvl> mux: Since you wrote it, you can just release your code under the bsd license, at the point someone wants to compile the entire program your code gets relicensed as gpl, which is allowed by the bsd license. But for other purposes you can still consider it to be bsd licensed.
05:00:14 <mux> twanvl: yeah I know this
05:00:46 <dons> mux, hmm no idea.
05:01:30 <mux> dons: it looks weird, since the mere existence of a nick in that map already means it's a privileged user - and the Bool holds no purpose that I can see
05:01:47 <malcolm> BSD may be a less restrictive licence, but the point is that it permits the code to become restricted
05:01:52 <mux> maybe someone wanted to be able to explicitely exclude people from the privileged users by entering those in the map with the boolean set to False?
05:02:12 <malcolm> whereas the GPL enforces that the code must not be restricted
05:02:18 <mux> thereby causing lots of problems
05:02:24 <dons> weird, only 200 or so hits on yesterdays 'Testing with QuickCheck' tutorial, but already almost double that for the 'unix tools' tutorial, in just a couple of hours.
05:02:25 <mux> but I don't think this is an appropriate discussion in this channel
05:02:34 <dons> people must either have no bugs in their haskell code, or not care if they do...
05:03:07 <malcolm> tutorials? where?
05:03:33 <dons> oh, just small ones. you need to track planet.haskell.org :)
05:03:38 <dons> ?wiki Simple_unix_tools
05:03:39 <lambdabot> http://www.haskell.org/haskellwiki/Simple_unix_tools
05:03:46 <dons> ?wiki Introduction_to_QuickCheck
05:03:47 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
05:03:49 <dons> beginner tuts
05:03:53 <malcolm> haven't got round to checking my RSS feeds since returning from ICFP
05:04:08 <gour> dons: thanks for those tutorials. very useful.
05:04:17 * gour considers dons to be a nice teacher
05:04:40 <dons> thanks :)
05:04:59 <dons> gour: you've read both?
05:05:12 <bourbaki> hey dons
05:05:18 <dons> any idea why the unix tools is getting 3-4x the traffic?
05:05:32 <dons> heya bourbaki . sorry, haven't replied yet. i'll do it tomorrow!
05:05:46 * dons updates todo list
05:05:51 <bourbaki> dons cool thanks
05:06:14 <gour> dons: yes. i actually had idea to save 1st one as a wonderful example, but then you yourself put it on the wiki. we are missing more of those tutorials
05:06:37 <dons> yeah, and they're pretty easy to write, too.
05:07:04 <dons> i'm going to try to write one every couple of days, in this style. we'll see how that goes
05:07:30 <Syzygy-> @type sortBy
05:07:32 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:07:36 <Syzygy-> @type sorting
05:07:38 <lambdabot> Not in scope: `sorting'
05:07:45 <gour> dons: maybe you can put them in a book - a kind of haskell cookbook
05:07:58 <Syzygy-> @docs sortBy
05:07:58 <lambdabot> sortBy not available
05:08:01 <Syzygy-> @hoogle sortBy
05:08:03 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
05:08:09 <Syzygy-> @docs List
05:08:10 <lambdabot> List not available
05:08:21 <dons> i've been thinking about a practical haskell book... seems like there'd be a use for it.
05:08:28 <vincenz> @localtime dons
05:08:30 <lambdabot> Local time for dons is Fri Sep 22 22:08:07 2006
05:08:32 * vincenz shoves dons to his bed
05:08:55 <dons> :p
05:09:00 <musasabi> camster seems to have left.
05:09:23 <dcoutts__> dons: I was thinking about get/put and Storable, but I don't think storable will work because of allignment issues
05:09:29 <gour> dons: definitely it will be; with more advanced stuff too
05:09:30 <dcoutts__> at least I can't see how to do it
05:09:59 <vincenz> @hoogle unsafeInterleaveIO
05:10:00 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
05:10:40 <gour> dons: eg. after Craft of FP or SOE, there are not much choices, i.e. some intermediary or advanced stuff & practical (at the same time)
05:11:25 <dons> yeah, the way to learn the hard stuff is to read papers and source. for a community with so many authors, there could be more textbooks .. :)
05:11:56 <sieni> yes, more advanced textbooks, please!
05:12:54 <gour> and the papers are not often not the bet for 'practical things, ie. lot of extra baggage not needed for pragmatical souls
05:13:16 * gour like theory, but not too much
05:13:26 <gour> s/bet/best
05:14:03 <norpan> there are a number of advanced tutorials though
05:15:36 <norpan> http://en.wikibooks.org/wiki/Haskell for instance, although it's not enough by a long shot
05:16:35 <vincenz> newtype LogFile = LF !Handle !(Handle -> IO LogPacket)
05:16:39 <vincenz> why does it complain on the second !
05:16:40 <vincenz> ?
05:17:00 <norpan> vincenz: you'
05:17:05 <dcoutts__> use data
05:17:09 <norpan> vincenz: you can only have one type in a newtype
05:17:17 <vincenz> oh
05:17:55 * vincenz sighs at the if then else indentation rule
05:17:59 * vincenz wishes he could do
05:17:59 <matthew-_> what is the difference between "newtype" and "type"?
05:18:00 <vincenz> if xxxx then
05:18:04 <vincenz> else if ... then
05:18:06 <vincenz> else
05:18:09 <vincenz> on the same line
05:18:12 <norpan> matthew-_: type only creates an alias
05:18:14 <vincenz> matthew-_: newtype is opaque
05:18:35 <Philippa_> use braces?
05:18:38 <norpan> with newtype you have a type constructor
05:18:39 <Philippa_> heck, use cases
05:18:58 <matthew-_> ahh, ok. I think.
05:19:06 <dcoutts__> newtype is very similar to data with only one constructor (which has one arg)
05:19:14 <vincenz> @hoogle ord
05:19:15 <lambdabot> Char.ord :: Char -> Int
05:19:15 <lambdabot> Prelude.Ord :: class Eq a => Ord a
05:19:15 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
05:19:30 <dcoutts__> matthew-_:  the disctinction is in the strictness (and representation)
05:19:33 <vincenz> @hoogle shiftL
05:19:34 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
05:19:34 <lambdabot> GHC.Exts.shiftL# :: Word# -> Int# -> Word#
05:19:34 <lambdabot> GHC.Exts.iShiftL# :: Int# -> Int# -> Int#
05:20:01 <matthew-_> ok, that makes sense.
05:20:11 <gour> this is reply which i got one min ago on #xml: "haskell! didn't know anyone used that as anything but a toy"
05:20:24 <dcoutts__> heh
05:20:25 <vincenz> dcoutts__: any option for this without $!!
05:20:27 <vincenz>   return $!! ((fromIntegral w1 `shiftL` 8) .|.
05:20:27 <vincenz>               (fromIntegral w2))
05:20:38 <matthew-_> gour: and what did you say?
05:20:45 <dcoutts__> vincenz: use $!  ? :-)
05:21:19 <Syzygy-> gour: Well, y'know, I use it as one of the more important tools I have in my algebraic research right now.
05:21:22 <dcoutts__> vincenz: it looks reasonable to me, what don't you like
05:21:34 <gour> matthew-_: i sent the guy what James Clark said about it - http://lua-users.org/lists/lua-l/2006-08/msg00512.html
05:21:36 <lambdabot> http://tinyurl.com/ox8xn
05:22:04 <skew> I think I finally got my typechecker together.
05:22:18 <Syzygy-> Oh, and it appeals very strongly to my sense of category theory. :P
05:22:34 <gour> matthew-_: striking back with their own weapon :-)
05:23:13 <matthew-_> heh, but they're not wrong though. Outside of academia, there are very few projects based on it - darcs is the only one I can think of off-hand
05:23:38 <skew> Anybody read "Gradual Typing for Functional Languages"? Anybody want to see it extended with Hindley-Milner type inference?
05:24:02 <matthew-_> not Mycroft typing then? ;-P
05:24:18 * matthew-_ is embarassed at making a type-theory joke!
05:24:27 <vincenz> skew: send on through
05:24:32 <skew> http://rafb.net/paste/results/1sg2C033.html
05:24:41 <skew> I think it works now.
05:25:13 <vincenz> skew: sigma's are polytypes?
05:25:26 <skew> yep, only produced by generalizing let-bindings
05:25:34 <vincenz> wanna see mine?
05:25:44 <vincenz> and use pastebin next time
05:25:47 <vincenz> it has syntax coloring
05:26:09 <vincenz> so what does this do over normal Hindley-Milner?
05:26:23 <skew> Unfortunately, you can't use GADTs to help you get stuff with mutable state correct
05:26:48 <vincenz> skew: what's Ground and Dyn?
05:27:25 <skew> In theory, introduce dynamically typed values which can be used transparently, reducing to the untyped lambda calculus with enough ? annotations, and ML if everything is annotated with *
05:27:57 <skew> ground is just some type constant, so you can introduce things like Int or Char - just treated as atomic types and compared by string equality
05:27:58 <vincenz> :)
05:28:04 <skew> Dyn is a dynamically typed thing
05:28:10 <vincenz> neat
05:28:14 <vincenz> so I take it
05:28:16 <vincenz> that at the end
05:28:21 <vincenz> all remaining vars are turned into dyns?
05:28:34 <skew> re coloration, I'm hoping you'd try it out and look for bugs and things
05:28:54 <skew> I'm planning to mail it off to the author of that paper once I'm sure it's settled
05:29:07 <skew> At the end I just leave free variables as free variables
05:29:48 <skew> Variables prefixed with a ? appear in some type a dynamic was used at somewhere, so type applications for those variables have to be preserved at runtime
05:31:00 <skew> So I think the possibility for runtime type errors is shown in the types, if you consider totally internal consistency violations to be the same sort of error as nontermination
05:32:03 <skew> one slightly strange thing is that writing down any upper case name is taken to be some constant of that Ground type
05:32:54 <skew> perhaps I should have a more general facility for declaring a subterm to have some type, perhaps written as {type}
05:33:02 <vincenz> why not dynamise things that don't infer??
05:33:09 <vincenz> s/??/?
05:33:40 <skew> you mean deal with type clashes by making stuff dynamic? because then you don't properly reduce to ML if you constrain everything
05:34:09 <skew> by the way, * in a type means "infer any dynamic-free type for this part of the type"
05:34:33 <skew> so annotating all binders with * should be just like an unannotated ML program
05:37:01 <vincenz> ah right
05:37:36 <vincenz> erm
05:37:40 <vincenz> I don't see that
05:37:47 <vincenz> where do you coerce dyn-types to static types
05:37:55 <skew> oh, I don't do that either
05:38:17 <vincenz> so when you annotate it all with *
05:38:20 <vincenz> they're all Dyn...
05:38:23 <vincenz> so how is that unannotated ML?
05:38:34 <skew> No, ? is "dynamic"
05:38:38 <vincenz> oh, right
05:38:39 <vincenz> sorrry
05:41:14 <skew> probably a real language would use a flag or a block construct or something to default unannotated binders to ? or * in a big swath of code
05:41:37 <skew> Hmm, ? and * could be confusing against the Haskell kinds
05:42:27 <skew> especially as my declarative rules (just written up on paper) had a judgement saying a type was "described by" an annotation, written like Int->Int::*, or ?->Bool::?->*
05:43:11 <skew> I'm thinking allowing annotations on arbitrary terms might also help to set up situations to test inference
05:43:42 <skew> Maybe some way of introducing fresh type variables with annotations so they show up in several places
05:44:26 <skew> As it stands, each * in a source program is essentially a separate fresh unification variable
05:44:40 <Syzygy-> > 7*7
05:44:42 <lambdabot>  49
05:44:43 <Syzygy-> > 7*7*7
05:44:45 <lambdabot>  343
05:45:17 * vincenz begs for inline data-decls
05:49:14 <skew> does anyone else care to try out my type checker?
05:49:33 <vincenz> skew: I think one would need a lot more code to get it to work?
05:49:42 <Bourbaki> 9^9^9^9^9^9^9^9^9^9^9
05:50:00 <vincenz> >  9^9^9^9^9^9^9^9^9^9^9
05:50:03 <skew> hmm? I've been running testMono and testPoly from ghci, on strings
05:50:05 <lambdabot> Terminated
05:50:08 <Bourbaki> :)
05:50:13 <vincenz> skew: well other files?
05:50:16 <vincenz> skew: "import TC"
05:50:22 <vincenz> skew: make a darcs repo :)
05:50:40 <skew> this is all I've written
05:51:13 <vincenz> ah whoops
05:51:19 <vincenz> still
05:51:22 <vincenz> darcs repo :)
05:51:24 <vincenz> easier to download
05:51:31 <profmakx> @karma+ darcs
05:51:31 <lambdabot> darcs's karma raised to 8.
05:51:36 <vincenz> darcs+=
05:51:38 <vincenz> darcs++
05:52:14 <sieni> vincenz: lambdabot should reply with BFN when something like that is given to it.
05:52:22 <vincenz> bfn?
05:52:45 * vincenz winces at the performance of haskell
05:52:53 <vincenz> crap, it's leaking
05:52:57 <sieni> vincenz: BFN == Big Number
05:53:02 <norpan> @karma +lambdabot
05:53:03 <lambdabot> +lambdabot has a karma of 0
05:53:08 <norpan> @karma+ lambdabot
05:53:08 <lambdabot> lambdabot's karma raised to 27.
05:53:21 <dmwit> > [9,9..]
05:53:22 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
05:53:27 <vincenz>  97.5 25.2
05:53:29 <sieni> @karma Haskell
05:53:30 <lambdabot> Haskell has a karma of 9
05:53:33 <sieni> @karma haskell
05:53:34 <vincenz> % cpu and % mem
05:53:34 <vincenz> :/
05:53:34 <lambdabot> haskell has a karma of 7
05:53:44 <dmwit> > foldr1 (^) [9,9..]
05:53:44 <sieni> hmm, those should be merged :-)
05:53:46 <lambdabot>  Exception: stack overflow
05:53:46 <vincenz> crap 50% memory
05:53:56 <mux> > cycle [9]
05:53:57 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
05:54:08 <dmwit> Ooo, even better.
05:54:11 <vincenz> 29706 vincenz   25   0  509m 507m  708 R 84.0 50.3   1:45.15 Counter
05:54:25 <profmakx> what´s he counting there -.-
05:54:28 <twanvl> > repeat 9
05:54:30 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
05:54:39 <mux> heh, you beat me to it
05:54:40 <dmwit> ?type cycle
05:54:41 <lambdabot> forall a. [a] -> [a]
05:54:44 <profmakx> > repeat 42
05:54:46 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
05:54:47 <mux> that was my next eval command
05:54:48 <vincenz> profmakx: packets in a binary file
05:54:54 <dmwit> > cycle [3..5]
05:54:55 <lambdabot>  [3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4,5,3,4...
05:55:06 <dmwit> mmmm
05:55:19 <vincenz> ocaml
05:55:21 <vincenz> 30182 vincenz   19   0  2316  900  440 R 86.1  0.1   0:05.85 countPackets
05:55:29 <vincenz> stays at 0.1 mem
05:55:29 <Bourbaki> foldr1 (^) repeat 1
05:55:36 <profmakx> Bourbaki, >
05:56:04 <Bourbaki> is anyone of you in one of the european pirate parties?
05:56:16 <vincenz> @arr -- ?
05:56:17 <lambdabot> Ahoy mateys
05:57:16 <vincenz> @hoogle deepSeq
05:57:17 <lambdabot> No matches found
05:58:21 <dmwit> Reddit's pirate is dead! =(
05:58:55 <fasta> I think I need this "generic traversal"-hack in Haskell. I have a Haskell function foo which I want to apply innermost. How can I do that best?
05:59:29 <dcoutts__> you can read about "scrap your boilerplate"
05:59:31 <Bourbaki> dmwit who is reddit?
05:59:42 <dmwit> ?google reddit
05:59:44 <lambdabot> http://reddit.com/
05:59:45 <lambdabot> Title: reddit.com: what&#39;s new online
06:00:25 <Bourbaki> dmwit i thought more about the polotical parties
06:00:54 <sek> anyone know what this means?: *** Exception: not complete
06:01:25 <vincenz> alright, no lazy leaking anymore
06:01:27 <sek> not the most descriptive exception ever:p
06:01:52 <fasta> dcoutts__: I already read it.. I just feel lazy reading it again...
06:06:06 <vincenz> or read bringert's paper to icfp :)
06:06:08 <vincenz> that one was gREAT!
06:06:29 <dons> ah, i see why there's been like 500 hits to the 'unix tools' page in an hour or so. someone linked it on reddit.com. how interesting!
06:06:34 <psi`> are the any videos from icfp?
06:06:42 <dons> ?where icfpcontest-video
06:06:43 <lambdabot> I know nothing about icfpcontest-video.
06:06:45 <vincenz> psi`: yep, lazy bottoms gets mentioned :)
06:06:46 <dons> doh!
06:06:53 <psi`> I saw one on google videos, but I can't watch that
06:07:06 <dons> you can download it an view it in mplayer
06:07:14 <dons> works on openbsd, so probably works everywhere?
06:07:22 <psi`> I guess :)
06:07:43 * vincenz sighs at the slowness
06:08:12 <vincenz> 30678 vincenz   25   0  3560 1828  704 R 96.5  0.2   8:08.77 Counter
06:08:44 <skew> vincenz: did you try running my code?
06:08:58 <vincenz> skew: no sorry, busy with my work
06:09:58 <vincenz> damn, haskell is frying my cpu
06:10:37 * vincenz uploads the naer 1GB file to the office-desktop and recompiles his apps there
06:11:28 <psi`> if it's disturbing your other processes, you can just renice it.
06:11:38 <vincenz> that's not the point
06:11:50 <vincenz> the point is that I want to see how long it takes w.r.t. ocaml before I rewrite my entire tool in haskell
06:12:51 <psi`> ok
06:15:10 <fasta> vincenz: URL?
06:15:48 <vincenz> fasta: for?
06:15:55 <fasta> vincenz: bringert's paper
06:16:03 <vincenz> oh
06:16:05 <vincenz> hmm
06:16:13 <vincenz> @google composop bringert
06:16:16 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/composOp/
06:16:17 <lambdabot> Title: Index of /~bringert/darcs/composOp
06:16:20 <vincenz> that one?
06:16:33 <fasta> vincenz: I don't know, you suggested it.
06:16:35 <vincenz> yep
06:16:38 <vincenz> check paper
06:18:03 <bartw> what is the paper about ?
06:21:52 <fasta> vincenz: I looked at the slides and it's not exactly what I am looking for. Thanks, anyway.
06:22:36 <vincenz> welcome :)
06:23:37 <vincenz>   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME CPU COMMAND
06:23:38 <vincenz> 22149 poucetc   25   0  1772 1772   656 R    49.3  0.1   2:24   0 Counter
06:23:48 <vincenz> either the desktop pc is faster, or IO is slower :)
06:23:52 <vincenz> I only get 50% cpu rate
06:24:16 <bartw> hyperthreaded maybe ?
06:25:01 <vincenz> dunno
06:25:06 <vincenz> yeah
06:25:50 <fasta> vincenz: What are you trying to do?
06:26:24 <bartw> what imperative language comes close to the syntax haskell uses ?
06:27:34 <fasta> bartw: OCaml?
06:27:42 <vincenz> fasta: erm, nothing quite yet
06:27:49 <vincenz> just compare ocaml vs haskell
06:27:59 <vincenz> speedwise
06:28:06 <bartw> the data type thing of haskell is really grabbing me
06:28:48 <yip> nemerle has syntax that is has syntax that is similar to haskell, but it is C-ized
06:28:54 <matthew-_> ok, I need a combination of foldl and filter. I need to go through a list, dropping items, and the predicate is based on the acc in foldl. Am I missing an obvious prelude function?
06:29:44 <Syzygy-> matthew-_: I would guess that the answer is to roll your own...
06:29:48 <bartw> data Tree a = Leaf a | Node (Tree a) (Tree a) is such a bit of genius
06:29:57 <vincenz> ack!
06:30:02 <vincenz> people should definitely unlearn that
06:30:04 <vincenz> it's WRONG
06:30:09 <vincenz> the correct one is
06:30:19 <vincenz> data Tree a = Leaf | Node (Tree a) a (Tree a)
06:30:21 <vincenz> for 2 reasons
06:30:27 <vincenz> a) the first one only stores data on the fringe
06:30:31 <vincenz> b) the first one does not allow empty trees
06:30:43 <bartw> b is a very good one
06:30:51 * vincenz mutters at all the books that talk about
06:30:58 <vincenz> data Tree a = Leaf a | Node (Tree a) (Tree a)
06:31:12 <bartw> a mightactually be wanted
06:31:23 <vincenz> seems inefficient
06:31:25 <vincenz> and if you want that
06:31:35 * vincenz ponders
06:31:46 <bartw> still, i like it very much
06:31:49 <vincenz> don't know why you would, RBtrees in imperative languages use empty leafs
06:32:02 <phas> trying to compile hmp3
06:32:05 <phas> ./Tree.hs:30:77: Module `Data.ByteString.Char8' does not export `joinWithChar'
06:32:15 <vincenz> psi`: old fps?
06:32:25 <dcoutts__> yep, our api is a bit smaller now
06:32:28 <phas> bash-3.1$ ghc-pkg -list | grep fps
06:32:28 <phas>     (data-1.0), fgl-5.2, fps-0.8, haskell-src-1.0, haskell98-1.0,
06:32:41 <bartw> i just don't know yet how to marry it with my own piece of hobbyism
06:32:51 <phas> 0.8, fresh installed
06:32:56 <matthew-_> does ghc do loop fusion?
06:32:58 <bartw> so long nullable types
06:33:10 <dcoutts__> phas: but you can easily implement that function in terms of the others
06:33:19 <dcoutts__> matthew-_: read the ByteString paper! :-)
06:33:24 <phas> dcoutts__ _urgh
06:33:25 <dons> phas: update your hmp3
06:33:30 <gds> vincenz: You can define a leaf-only tree with Monads though - I don't think you can do that with the data in the middle...
06:33:33 <dons> (.e. darcs pull)
06:33:37 <phas> dons: ok
06:34:05 <dcoutts__> phas: oh, sorry, I didn't notice it wasn't your code you were building
06:34:29 <phas> dcoutts__ : :P
06:34:30 <dons> hmm. 'simple unix tools' is #2 on the reddit hot list. how intrguing!
06:34:44 * edwardk_ waves hello.
06:34:46 <vincenz> gds: erm sure you could if you could do it with monads..
06:34:46 <dcoutts__> reddit?
06:34:55 <vincenz> dcoutts__: programming.reddit.com
06:35:08 <edwardk_> so what is the next functional programming conference coming up?
06:35:08 <dons> dcoutts__: its the 21st centruy, and people traverse the net collecting links and posting about them
06:35:17 <dcoutts__> bizzaro
06:35:18 <dons> edwardk_: POPL/PADL ?
06:35:58 * dons notes that the top list includes: ruby, haskell, scheme, erlang ..
06:36:02 <bartw> currently thinking about going to popl, anyone else going ?
06:36:11 <dons> so maybe a few FP people read reddit?
06:36:17 <dons> bartw: yeah, maybe ... :)
06:37:37 <bartw> worst case it's only as boring as a vendor conference
06:37:47 <bartw> i have no idea what to expect
06:38:22 <edwardk_> hrmm
06:38:51 <dons> edwardk_: there's a list on the 'Conferences' page on haskell.org
06:38:56 <dons> could do with some dates info though
06:39:01 <dons> and there's plenty missing I'm sure.
06:40:28 <edwardk_> hrmm. after popl? looking for one whose call for papers hasn't passed =)
06:41:47 <edwardk_> ESOP still seems to be in the future ffor abstract submissions.
06:42:49 <phas> bash-3.1$ hmp3 *
06:42:49 <phas> <file descriptor: 119>: hFlush: resource vanished (Broken pipe)
06:42:49 <phas> bash-3.1$
06:42:51 <phas> wtf?!
06:42:52 <mux> darcs whatsnew
06:42:55 <mux> blah...
06:43:10 <vincenz> dons: *wince*
06:43:38 <vincenz> http://rafb.net/paste/results/OXd6t433.html
06:43:45 <bartw> edwardk_ : how does that work with papers ?
06:43:57 <psi`> dons: can mplayer play .gvp files?
06:44:06 <edwardk_> bartw: how do you mean?
06:44:22 <dons> psi`: hmm. not sure. when I downloaded it it came as a .avi file
06:44:27 <bartw> edwardk_ : do you write them for work ? and what about ? and why ?
06:44:30 <psi`> how did you download it?
06:44:32 <edwardk_> bartw: right now i'm just looking to see what conferences are coming up that I could get a paper/abstract submitted to in time.
06:44:47 <dons> phas: you have mpg321 on your machine?
06:45:02 <dons> psi`: just cliked on 'download for windows' I think
06:45:10 <dons> and saved it to disk
06:45:14 <edwardk_> bartw: well, in my case I want to write up a subset of my current research to get it out there and make it visible, etc.
06:45:21 <dons> then starting playing the .avi.part file when it was about 20% done
06:45:44 <dons> vincenz: so youre haskell's a bit inefficient.
06:45:49 <glguy> does anyone have that video link of the scheme guy that slags off FP?
06:45:50 <vincenz> dons: yeah and it doesn't do much
06:46:01 <glguy> and then says behaviors are great
06:46:09 <fasta> glguy: what an improbable combination!
06:46:13 <psi`> dons: That gives me GoogleVideoPlayerSetup.exe. Clicking the 'Manual download' link gives me the .gvp file.
06:46:14 <dons> vincenz: profile, and repeat. you'll learn lots :)
06:46:25 <vincenz> yeah
06:46:28 <vincenz> I added -O now
06:46:30 <dons> psi`: hmm. there was some way to get the .avi file
06:46:32 <vincenz> but if it takes 20 mins to run
06:46:33 <dons> vincenz: !!
06:46:35 <bartw> edwardk_ : ah ok, this is all new for me
06:46:35 <vincenz> who knows how long it'll take to profile
06:46:38 <dons> you didnt use -O ???
06:46:38 <glguy> fasta: yeah, that's why I wanted to watch it
06:46:39 <phas> dons: yeah, and it works
06:46:41 <edwardk_> bartw: likewise
06:46:42 <vincenz> dons: erm, no
06:46:49 <dons> crazy person
06:47:14 <dons> phas: latest hmp3 with mpg321 works fine here. not sure what you're doing.
06:47:20 * vincenz is rerunning now
06:47:22 <psi`> dons: Maybe it's because I'm on windows right now
06:47:37 <dons> psi`: ah, maybe IE plays silly games/google plays silly games with IE
06:47:44 * fasta enters a new fase as he imports Data.Generic
06:47:51 <dons> hehe
06:47:55 <dons> fasta++
06:47:56 <fasta> Generics, even
06:47:57 <psi`> firefox, actually, but yeah
06:48:33 * fasta also discovers that everywhere is a completely broken name and fixes it in his sources to bottomup :)
06:48:35 <gkr> Is there something defined like swap [1,2,3,4] 0 2 = [3,2,1,4]?
06:49:06 <vincenz> gkr: that would be inefficient
06:49:32 <dons> should be a one liner to write though
06:49:46 <vincenz> prolly more than one liner
06:49:51 <vincenz> gotta check which index is bigger
06:49:53 <vincenz> ...
06:50:00 <fasta> Can I derive Data in GHC?
06:50:07 <dons> fasta: yep
06:50:11 <dons> might need -fglasgow-exts
06:50:18 <fasta> dons: ooooh, sweet :)
06:50:41 <dons> fasta: talk to audreyt about it. pugs does it all over the place, iirc
06:51:02 <fasta> dons: Right, I need those, since I observed it didn't work.
06:51:11 <roconnor> Isn't there a darcs command to replace words in the entire project?
06:51:18 <gkr> vincenz :-(
06:51:35 <vincenz> gkr: lists are O(n) random access not O(1)
06:52:18 <edwardk_> oooh, dons, forgot to mention.. talked to Simon Marlow, and he basically said if we put together a patch to reintroduce monad comprehensions via a flag he wouldn't reject it :-)
06:52:30 <glguy> huzzah
06:52:38 <vincenz> dons: down to 5.5m
06:52:41 <vincenz> 5m29
06:52:46 <fasta> dons: I have this as the first line in my source file {-#OPTIONS -fglasgow-exts #-}
06:52:55 <edwardk_> Sat down with igloo and browsed through the code, and it didn't seem too bad to implement
06:53:03 <vincenz> > (5*60+29)/50
06:53:05 <lambdabot>  6.58
06:53:09 <matthew-_> wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
06:53:12 <dons> vincenz: now you profile :) and learn a good lesson: -O is _required_
06:53:19 <vincenz> :)
06:53:25 <vincenz> dons: then why not make it implict!
06:53:31 <vincenz> heh...profiling will take ages
06:53:39 <dcoutts__> edwardk_, dons: meaning we could do bytestring comprehensions ?
06:53:41 <fasta> I get Not in scope: type constructor or class `Data'
06:53:42 <vincenz> just -prof right?
06:53:53 <edwardk_> dcoutts: if its a monad, I don't see why not.
06:53:55 <dons> oh!
06:54:04 <dons> bring on monad comprehensions!
06:54:11 <edwardk_> though I'd be kinda leery of getting it to comply wiht the interface
06:54:13 <bringert> matthew-_: if you have any HaskellDB questions, you are welcome to ask me
06:54:21 <gkr> Bah, my code should change drastically grr.
06:54:24 <roconnor> matthew-_: You should go tell the people in #python that. ;)
06:54:42 * bringert is back home
06:54:52 <dons> ?remember matthew-_ wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
06:54:56 <vincenz> dons: do I still use -O when doing -prof
06:54:57 <dons> :)
06:54:57 <vincenz> ?
06:54:59 <edwardk_> heya bringert. did you have fun at the conference?
06:55:03 <dons> vincenz: yes, absolutely
06:55:11 <dons> you want to profile the behaviour of the code you actually run with
06:55:15 <yip> bringert: what is your connection with haskellDB?
06:55:24 <vincenz> thx
06:55:32 <bringert> edwardk_: sure did. you?
06:55:37 <bringert> yip: maintainer
06:55:46 <yip> cool
06:55:47 <fasta> audreyt: ping
06:56:00 <audreyt>  pong
06:56:27 <audreyt> what's up? (I'm about to sleep :))
06:56:37 <fasta> audreyt: I have a datatype where I put deriving (Eq, Data) and I put -# OPTIONS -fglasgow-exts #-} on top of the file
06:56:39 <edwardk_> bringert: lots. got to talk to everyone I needed to talk to. I don't think I got to stop moving the entire conference.
06:56:50 <fasta> audreyt: I get the error Not in scope: type constructor or class `Data'
06:57:14 <fasta> audreyt: dons said that you would know what was going on, as you use Data.Generics a lot in Pugs.
06:57:44 <fasta> audreyt: I have the "missing" '{' in my file, don't worry about that.
06:57:47 <bringert> fasta: import Data.Generics
06:57:57 * dons only guessed, since audreyt uses all extensions available
06:58:13 <fasta> bringert: oh, I see I added it to the wrong file....
06:58:18 <fasta> bringert: thanks
06:58:20 <bringert> fasta: I think you need deriving (Eq, Typeable, Data) btw
06:58:39 <fasta> bringert: I think so too, since that's what Ralf uses
06:58:57 <matthew-_> bringert: thanks for the offer. one quick Q: I need to invoke the now() SQL function in a query. I'm using "do project (Revisions.created << Expr (ConstExpr (OtherLit "now()")))". Is that a sane way or are there better ways?
06:58:59 <fasta> Ooh, it works :)
06:59:20 <sek> how can i force a type to be defined by two classes in a function definition, ie func :: Eq a, Show a => a -> ...  doesnt seem to parse
07:00:10 <Lemmih> sek: (Eq a, Show a) =>
07:00:10 <edwardk> sek: (Eq a, Show a) => a -> ...
07:00:14 <ibid> sek: add parentheses
07:00:27 <bringert> matthew-_: unfortunately you can't do much better than that. one thing you can do is to declare now :: Expr CalendarTime somewhere, that way you give it a nice type
07:00:36 <fasta> @paste
07:00:36 <lambdabot> http://paste.lisp.org/new/haskell
07:00:38 <sek> nice, thanks for the tripple answer:)
07:01:15 <bringert> now :: Expr CalendarTime
07:01:15 <bringert> now = Expr (ConstExpr (OtherLit "NOW()"))
07:01:46 <bringert> matthew-_: without that type signature, it can be used as any type, so you lose some safety
07:01:47 <lisppaste2> me pasted "Generics?" at http://paste.lisp.org/display/26522
07:01:55 <matthew-_> bringert: yeah, except that as hdbc and haskelldb don't agree about timestamps in postgres, I'm reading them a strings and then reparsing them myself
07:02:23 <fasta> I don't really understand the error message that I get.
07:02:37 <bringert> matthew-_: yeah, that's a pain. maybe you an submit a patch. I think it could be fixed in hdbc, but I haven't looked at it for a while
07:03:26 <matthew-_> bringert: yep, definately worth looking at. fromSQL dies with "Cannot read "Mon Sep 24 10:00:23.84032" as Integer" style errors
07:03:55 <matthew-_> and it's the fromSQL in HaskellDB.HDBC...
07:04:24 <bringert> that's the main reason why I still mostly use HSQL
07:04:24 <fasta> Never mind, I had to add mkT.
07:04:55 <matthew-_> bringert: I've still not got my head around how haskelldb, hsql and hdbc all play with one another ;)
07:08:43 <vincenz> NOO
07:08:51 <vincenz> dons: why is Counter.prof empty?
07:09:02 <dcoutts__> bringert: any chance there will be a new haskelldb release that we can package for gentoo?
07:09:18 <bringert> ah, yes
07:09:23 <dcoutts__> bringert: iirc, the last tarball is rather on the old side
07:09:45 <vincenz> %: %.hs ghc -prof -auto-all -O --make -main-is $@ -o $@ $<
07:09:53 <vincenz> for some reason the .prof file was empty :/
07:10:00 <dons> vincenz: you didn't compiled with -prof -auto-all ? you're using a ghc 64.x and your program didn't terminate cleanly?
07:10:14 <vincenz> I did compile, it did terminate cleanly
07:10:24 <bringert> dcoutts__: here's the issue: there are lots of unfixed issues with the current darcs version, the testsuite doesn't cover all that much, and many tests fail. however, I think it's still better than the previous release
07:10:32 <dons> no idea then. something else at play. double check (and try with small data)
07:10:35 <vincenz> dons: 6.4.2
07:10:41 <bringert> maybe I should just make a release anyway
07:10:45 <dons> and check that a simple toy program will correctly produce output
07:10:48 <dcoutts__> bringert: I see
07:10:49 <dcoutts__> bringert: I was also wondering why there needs to be so many packages, there seem to be haskelldb packages for each of the hsql backends. I'd have hoped that there could be just one for hsql in general.
07:11:15 <bringert> dcoutts__: there can't, since HSQL itself consists of that many packages
07:11:26 <dcoutts__> and if different hsql backends need different SQL that this could be done without needing lots of packages
07:11:52 <bringert> ah, right
07:11:53 <dcoutts__> bringert: once you've got a hsql connection object isn't that all you need?
07:12:13 <dcoutts__> though you want to generate different flavours of SQL for different dbs
07:12:15 <bringert> dcoutts__: try, but currently we hide the HSQL API completely from the user
07:12:30 <dcoutts__> bringert: hmm
07:12:36 <bringert> and I think we need to do that to get the dynamic driver loading to work
07:12:43 <dcoutts__> but then we can't use it with other dbs easily
07:12:46 <dcoutts__> like HDBC etc
07:12:53 <bringert> why?
07:12:55 <dcoutts__> and we end up with N*M packages
07:13:01 <dcoutts__> rather than N+M
07:13:08 <fasta> I did everywhere (mkT <somefunction from MyType->MyType>)
07:13:08 <bringert> what are N and M?
07:13:22 <dcoutts__> DB systesm and backend of those
07:13:33 <dcoutts__> eg HDBC & HSQL
07:13:34 <dcoutts__> N=2
07:13:37 <fasta> Now, I don't really see why I don't just obtain a function which I can apply to a value.
07:13:54 <fasta> Oh, I do see, nm.
07:14:01 <dcoutts__> hdbc-postgresql, hdbc-mysql, hdbc-odbc, etc
07:14:07 <dcoutts__> and the same for hsql
07:14:12 <dcoutts__> M=4 or 5
07:14:50 <dcoutts__> so ideally haskelldb would just have two backends, one for each of hsql and hdbc
07:15:16 <dcoutts__> then if you need to split it up, M more for varying the SQL generated for the speicic db you're talking to
07:15:25 <bringert> dcoutts__: yes, that's right. but we want all haskelldb drivers to have the exact same type for the connection function, to make them interchangeable and make dynamic driver loading work. thus we must call the connection function from hsql-mysql in haskelldb-hsql-mysql
07:15:42 <dcoutts__> though the connection functions need different info
07:16:03 <bringert> they all take [(String,String)] in the haskelldb API
07:16:21 <dcoutts__> ok, I was assuming a design where you connect using the backend and then after that use it via the main api
07:16:30 <dcoutts__> that's how hsql and hdbc both work
07:16:37 <dcoutts__> so the core doesn't depend on the backends
07:17:08 <fasta> I have everywhere (mkT <some _partial_ function from MyType->MyType>). How can I let the function apply only on those places, well... , where it applies?
07:17:24 <dcoutts__> bringert: the difficulty is that we'd need to build all of the backends
07:17:35 <dcoutts__> if the core depends on them
07:17:49 <dcoutts__> and that pulls in loads of C packages that people don't want
07:17:52 <twanvl> festa: you need a total function, and return some sensible default in cases where it does not apply
07:18:03 <fasta> twanvl: thank you
07:18:05 <bringert> dcoutts__: hmm, right. I would like to still allow reading all the db connection info from something like a text file, and use hs-plugins to load the right driver, and connect with that
07:18:30 <bringert> dcoutts__:  why does the core have to depend on the drivers?
07:18:45 <bringert> dcoutts__: by core, do you mean the main haskelldb package?
07:18:49 <dcoutts__> bringert: yep
07:18:55 <glguy> Who's idea was it to change the IO message to Pervert?
07:19:03 <dons> ?seen mnislaih
07:19:03 <lambdabot> I saw mnislaih leaving #haskell 2h 33m 36s ago, and .
07:19:08 <bringert> it's the other way around in the current haskelldb packages
07:19:29 <bringert> dcoutts__: you can install the haskelldb package without any drivers, and then install what ever drivers you want to use
07:19:39 <dons> ibid, mnislaih has a blog, http://pepeiborra.blogspot.com/
07:19:41 <lambdabot> Title: blog :: Date -> Maybe String
07:19:53 <dcoutts__> bringert: oh ok, and then the connection function specifies a backend by name?
07:20:04 <dons> ?tell mnislaih would you like to have your blog added to planet.haskell.org ? just ping ibid the rss feed url
07:20:05 <lambdabot> Consider it noted.
07:21:25 * mux is on his way to overflow dons' TODO list
07:21:36 <dons> dcoutts__: this "reddit" effect is pretty interesting, after 5 hours:
07:21:37 <dons> 181. Simple unix tools (1,202 views)
07:21:37 <dons> 182. Category theory (1,191 views)
07:21:46 <Syzygy-> Wha?
07:21:48 <dcoutts__> heh
07:21:53 <bringert> dcoutts__:  there is no connection function in the haskelldb package, there is one in each driver package. then there is also a dynamic driver, which uses hs-plugins to load a driver by name. So, there are two ways to connect: import a specific driver, and use its connection function, or use the dynamic driver and give the name of the driver
07:21:56 <Syzygy-> Reddit effect?
07:22:16 <dcoutts__> bringert: that sounds reasonable
07:22:23 <dons> Syzygy-: traffic sent to haskell.org after being spotted on programming.reddit.com
07:22:38 <Syzygy-> Ah.
07:22:48 <bringert> the reason why there are lots of packages is to avoid forcing the user to install all the libs
07:23:03 <ibid> dons: you know the drill :)
07:23:09 <dons> :)
07:23:13 <dcoutts__> bringert: since you've got that split couldn't you have the best of both worlds...
07:23:15 <dons> I'll wait till he appears
07:23:19 <ibid> perhaps i should write a page about this
07:23:22 <bringert> dcoutts__: how?
07:23:31 <bringert> or rather, what?
07:23:52 <bringert> is the best?
07:24:05 <dons> ibid: did you know that you can subscribe to googles feed of its blog searches for a specific term?
07:24:17 <dons> (not suggesting you add _that_ to planet haskell though)
07:24:52 <dons> e.g. all haskell blog entries in the last week, I think: http://www.google.com.au/blogsearch?hl=en&q=Haskell&ie=ISO-8859-1&num=100
07:24:54 <lambdabot> Title: Google Blog Search: Haskell, http://tinyurl.com/hp3zo
07:25:09 <ibid> dons: i *think* i've seen that but never paid much attention to it
07:25:40 <dons> i've found a lot of the newer contributors when they've popped up in this feed
07:25:42 <dcoutts__> bringert: you have each backend take a backend specific object, ie a HSQL.connection or a HDBC.connection, ie if you don't use the dynamic backend then you don't shield the user from the backend-specific setup
07:25:45 <dons> let google do the searching :)
07:25:48 <ibid> :)
07:26:02 <dcoutts__> bringert: and then if using the dynamic one then you get protected from that with lots of strings and dynamic loading
07:26:16 <dcoutts__> then we don't need the many-many packages
07:27:08 <bringert> dcoutts__: ah, the dynamic driver first loads HSQL.MySQL etc. dynamically, looks up the connection function, and passes the result to haskelldb-hdbc or haskelldb-hsql
07:27:16 <bringert> dcoutts__: good idea
07:27:29 <bringert> it does make the standard import API a little worse though
07:27:38 <bringert> and I think that's what most people use
07:27:45 <bringert> but not a lot I guess
07:28:09 <dcoutts__> bringert: btw, how does the dynamic driver call the backend without depending on it statically?
07:28:23 <dcoutts__> bringert: ie how does it call HSQL.MySQL.connect
07:28:34 <dcoutts__> without depending on hsql-mysql
07:28:56 <dcoutts__> or does the haskqlldb-hsql-mysql register something
07:29:18 <bringert> dcoutts__: it doesn't, it calls HaskellDB.HSQL.MySQL.connect, which lives in haskelldb-hsql-mysql, which depends on hsql-mysql
07:29:37 <bringert> the dynamic driver uses loadPackage to load haskelldb-hsql-mysql
07:29:54 <dcoutts__> and it provides a standardised string based entry point
07:30:00 <dcoutts__> I see, hmm
07:30:01 <bringert> right
07:30:56 <dcoutts__> you see from our point of view we've already got hsql-* and hdbc-* (4+5 packages), it seems a lot to add (1+2+4+5) new ebuilds
07:31:43 <bringert> right. though it is one only haskelldb driver package for each existing package.
07:32:05 <dcoutts__> true
07:32:21 * bringert runs off for a while
07:32:25 <dcoutts__> perhaps the dynamic loader could be even more dynamic...
07:32:33 <dcoutts__> but yes, later
07:34:09 <hn_> I have a fairly trivial bit of code using parsec, but when I run ghc on it, I get more than a screenful of errors of the following form: : undefined reference to `TextziParserCombinatorsziParsecziPrim_zdfMonadGenParser_closure'
07:34:09 <hn_> Main.o: In function `s1KE_info':
07:34:29 <dons> missing -package parsec
07:34:35 <hn_> ah-hah. thank you
07:34:51 <mux> ?zify fooBarBaz
07:34:52 <lambdabot> Unknown command, try @list
07:34:55 <hn_> That worked.
07:34:57 <mux> we need a zify plugin :)
07:34:59 <hn_> dons++
07:35:01 <mux> and unzify
07:40:15 <kpreid> even, unzify-linker-error
07:40:19 <ventonegro> what's the meaning of vertical bars in class declarations?
07:42:00 <phas> i have this function
07:42:02 <phas> pathFile :: [FilePath] -> [(FilePath, IO [FilePath])]
07:42:02 <phas> pathFile = map (\x->(x,getDirectoryContents x))
07:42:25 <phas> and i want it to return an IO [(FilePath, [FilePath])]
07:42:28 <phas> instead
07:42:32 <phas> how can i do it?
07:43:30 <matthew-_> phas, chuck add "do return $ " to the front of it?
07:43:42 <mux> phas: I think I'd use zipWithM
07:44:02 <matthew-_> phas: ignore me, I can't read
07:44:26 <mux> mmm, maybe not
07:45:26 <phas> mux: uhm
07:47:11 <phas> mux: i can do it in ?do notation?
07:47:18 <phas> like
07:47:20 <Lemmih> phas: pathFile xs = do cs <- mapM getDirectoryContents xs; return (zip xs cs)
07:47:35 <phas> Lemmih: oh thx
07:47:47 <twanvl> ventonegro: The part after the | is a functional dependency, for example "class a b | a -> b" means that the type used a uniquely determines the type b.
07:47:55 <mux> phas: give me some time and I'll get you the zipWithM version :-)
07:49:12 <emu> so they're adding "lambda" to C++, rofl
07:49:19 <ventonegro> twanvl, maybe an example could help :-)
07:49:19 <Syzygy-> o.O
07:49:26 <ventonegro> i saw it in the vertigo paper
07:49:35 <emu> I wonder if they realize they'll need GC now
07:49:42 <twanvl> ventonegro: The best examples are in the Control.Monad.* library
07:49:42 <ventonegro> class Floating s => VertexOf s v | s -> v
07:49:45 <emu> or perhaps that will take another 20 years and "discoveries"
07:50:13 <mux> phas: actually I don't think zipWithM is appropriate :-P
07:51:31 <ventonegro> ooops, v -> s
07:52:02 <phas> mux : :P
07:52:04 <twanvl> In this case if the compiler sees for example "VertexOf Double ???" it can fill in the ??? because there can only be one instance (assuming such an instance exists of course)
07:53:05 <ventonegro> twanvl, i see, thanks!
07:59:29 <gour> @where haskelldb
07:59:29 <lambdabot> http://haskelldb.sourceforge.net/
08:10:36 <dons> dcoutts__: 147. Simple unix tools (1,510 views) / 150. Haskell Brooks Curry (1,466 views)
08:11:04 <dcoutts__> nice
08:11:25 <dons> note that's about 10x as many hits as the paper got when it came out.
08:11:31 <dcoutts__> hah, yes
08:11:51 <dcoutts__> planet.haskell doesn't get quite the same readership :-)
08:12:02 <dons> not yet, anyway ;)
08:12:13 <dcoutts__> heh
08:12:15 <dons> just have to ensure planet posts end up on reddit, it seems ;)
08:12:21 <dcoutts__> right
08:12:41 <dcoutts__> maybe you'll have to register :-)
08:15:12 <dons> oh, the paper made reddit too http://programming.reddit.com/info/gi07/comments
08:15:15 <lambdabot> Title: Rewriting Haskell Strings (reddit.com), http://tinyurl.com/zfl8p
08:15:21 <gour> dons: i got feedback about one python 'friend' seeing Unix tools in reddit
08:15:31 <dons> gour: oh yeah?
08:15:43 <Limbic_Region> ok - so is anyone here on the ghc dev mailing list (cvs-ghc) ?
08:15:56 <dons> Limbic_Region: sure. quite a few people
08:16:19 <Limbic_Region> ok - how should I interpret no response in about 2 days to a question I posed to the list
08:16:25 <Limbic_Region> it was my first question and I just joined
08:16:33 <dons> oh, you should interpret that as "everyone is at ICFP"
08:16:36 <gour> dons: yes. i 'preached' a lot about haskell in #sandbox, but they are pretty stubborn, but he liked tutorial. then i sold him 'quickcheck' one too - sell while it's hot :-)
08:16:39 <Limbic_Region> I don't want to sound whiny but I really do want to work ....
08:16:40 <Limbic_Region> ahhh
08:16:41 <Limbic_Region> nevermind
08:16:43 <Limbic_Region> thanks
08:16:53 <Limbic_Region> when does ICFP end and things resume to normal
08:16:59 <dons> Limbic_Region: also, check #ghc if you want to talk about ghc dev questions.
08:17:01 <dons> next week
08:17:06 <Limbic_Region> k
08:17:07 <dons> most people are getting home over the weekend
08:17:16 <dons> gour: hehe. ncie.
08:17:32 * Limbic_Region doesn't think he can get to #ghc from here but he will see if accomodations can be made
08:17:50 <dons> it's just over here -->
08:18:14 <dons> but of course, everyone's travelling, so you won't get a response
08:18:50 <Limbic_Region> dons - I am using CGI:IRC which limits the channels you can access
08:19:07 <Limbic_Region> in fact, I am not even using IRC ATM - I am just viewing a web page
08:19:27 <dons> ohh huh.
08:19:30 <dons> :)
08:19:36 <Limbic_Region> terribly convenient when you are in environments that restrict outbound access to just http/https
08:19:44 <dons> ah nice!
08:20:01 <dons> so that's why I've seen so many "CGI:IRC" clients recently
08:20:36 <Limbic_Region> dons - likely, the machine "feather" which is dedicated to perl 6 development is running a cgi:irc server for several channels
08:21:04 <dons> ah right
08:21:11 <Limbic_Region> #parrot on irc.perl.org, #haskell, #perl6, #svk, #jifty on freenode
08:21:56 <Limbic_Region> out of curiosity - what platform do you use for haskell and what implementation do you prefer?
08:22:08 <dcoutts__> linux ghc
08:22:18 * Limbic_Region is a haskell neophyte though he knows more about the ghc build system than he does haskell
08:22:27 <fasta> I already tried this with generics and implemented it with, but I would like to know the generics solution: I want to apply the following transformation everywhere, such that I get a sane result.
08:22:43 <dons> i like ghc on any unix :)
08:22:58 <psi`> does ghci work on openbsd now?
08:23:07 <dons> psi`: yep. patch went in yesterday
08:23:15 <dons> (to the ghc head)
08:23:19 <psi`> oh, cool
08:23:24 <dons> quite an interesting issue in the end
08:23:34 <dcoutts__> I run ghc on gentoo linux x86, amd64 and sparc (& ia64)
08:23:34 <Limbic_Region> I am trying to get ghc working again on Cygwin but having difficulty cross-compiling
08:23:35 <fasta> f (A x) = B (A x); f(B (A x)) = A x
08:23:40 <Limbic_Region> which is the msg that has gone unanswered on the list btw
08:23:57 <dcoutts__> Limbic_Region: why do you want cygwin rather than mingw ?
08:24:03 <Limbic_Region> I am using Win32 MinGW as the source which lacks the "unix" package
08:24:09 <dons> yeah, you'll want to wait for the microsoft guys to get back, probably
08:24:12 <dons> or maybe talk to ndm
08:24:13 <Limbic_Region> dcoutts__ - (we) want both
08:24:18 <glguy> dons: will you be backporting mypatch to 6.4.2?
08:24:31 <dons> glguy: nope. but it should make the new release next week of 6.6
08:24:46 <glguy> cool
08:24:53 <glguy> will 6.4.3 still be released?
08:24:57 <dcoutts__> Limbic_Region: the cygwin port is not really suppoted and is bitrotted, so it'll be a bit of work
08:25:07 <Limbic_Region> dcoutts__ yes, I know
08:25:17 <Limbic_Region> my opening sentence in the email to the list is something along the lines of
08:25:19 <dcoutts__> Limbic_Region: what do you want it for ?
08:25:26 <Limbic_Region> I must enjoy inflicting pain upon myself.
08:25:32 <psi`> dons: is it working on all archs?
08:25:32 <dcoutts__> ha ha
08:25:36 <Limbic_Region> dcoutts__ - Pugs
08:25:52 <psi`> or specifically, ppc
08:26:02 <dcoutts__> Limbic_Region: oh they want pugs on cygwin, ho hum.
08:26:04 <dons> psi`: not sure. I suspect 6.6 should work though
08:26:18 <psi`> I don't think debians ghci works on ppc.
08:26:31 <dcoutts__> gentoo's does I think
08:26:37 <Limbic_Region> dcoutts__ actually, they have pugs on cygwin but no imbedded perl 5
08:26:40 <psi`> dcoutts__: yep
08:27:04 <dcoutts__> dons: does openbsd do sparc ?
08:27:06 <Limbic_Region> that is related to the ghc being MinGW and not Cygwin
08:27:38 <dcoutts__> dons: if so, have you tried 6.6 on sparc. it borks for me.
08:27:58 <vincenz> dcoutts__: any idea why my app would generate an empty .prof?
08:28:08 <dcoutts__> nope
08:28:16 <vincenz> :/
08:28:30 <dons> 6.2.2 works on sparc, i've not tried more recent ones
08:28:35 <dcoutts__> vincenz: you have a great way of comming up with questions with no context :-)
08:28:42 <dons> I suppose the 6.4 cmm backend rewrite broke sparc somewhere?
08:28:58 <vincenz> dcoutts__: oh sorry.  Well basically I compiled an application with -prof and -auto-all and I'm getting a .prof file which is empty
08:29:00 <dons> though rl is using it on solars 10/sparc64 (I think) without too much backend hacking
08:29:04 <dcoutts__> dons: yes, though via-C works for 6.4.x
08:29:45 <dcoutts__> dons: we've got registerised build with ghci etc working for 6.4.2, but 6.5 complains about unsafe reschedule
08:29:56 <dcoutts__> unsalfe re-entering the scheduler
08:30:14 <dons> huh
08:30:20 <dons> i'll keep an eye out for that
08:30:39 <vincenz> doh
08:30:44 <vincenz> app +RTS -p
08:30:46 <dcoutts__> ghc-6.5.20060917: schedule: re-entered unsafely.
08:30:46 <dcoutts__>     Perhaps a 'foreign import unsafe' should be 'safe'?
08:31:14 <dcoutts__> vincenz: well done :-)
08:31:41 <vincenz> dcoutts__: heh
08:32:22 <vincenz> seems the most inefficient functions is the getWord8 one
08:32:28 <vincenz> 59.9% allocs
08:33:42 <dons> don't use getWord8
08:33:48 <dons> read a lazy bytestring instead
08:34:55 <dons> (you really really don't want to lock the Handle and read each byte from the file, so while getWord8 is good for smaller problems, you just have to bite the bullet and read in blocks for substantial data sizes)
08:35:04 * vincenz nods
08:35:08 <vincenz> @where fps
08:35:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
08:35:24 <fasta> I don't like the documentation for Data.Generics.
08:35:54 <dons> you could start sketching your own docs, and submit that as a darcs patch?
08:36:02 <dcoutts__> vincenz: even in C it's worth about a 3x speedup when just reading bytes: changing from getchar() to getchar_unlocked()
08:36:25 <dcoutts__> vincenz: and I think the haskell Handle locking overhead is higer than that
08:36:50 <glguy> wicked... I didn't know about getchar_unlocked
08:37:07 <fasta> dons: I would like to use them like this: http://nix.cs.uu.nl/dist/stratego/stratego-lib-docs-stable-latest/docs/html/strategy/traversal/fixpoint.str.html#24
08:37:11 <lambdabot> Title: strategy/traversal/fixpoint.str, http://tinyurl.com/m6yrv
08:37:12 <emu> so icfp is over?
08:37:28 <dons> emu: uh hu.
08:37:52 <glguy> did anyone else who wrote rev.2d write it out as a fold first?
08:39:09 <vincenz> dons: is unpack unadviseable?
08:39:13 <int-e> you mean with a 'fold' box?
08:39:41 <glguy> int-e: no, not really at that level, I didn't know how to do HOF in 2d :)
08:40:22 <dons> vincenz: nope.
08:40:40 <int-e> glguy: I always had a wrapper box and a helper box.
08:41:41 <int-e> so basically, let reverse = rev []; rev r [] = r; rev r (a:as) = rev (a:r) as
08:41:43 <glguy> int-e: I had a starting block and a recusive block
08:41:47 <glguy> yeah
08:41:49 <glguy> exactly
08:42:08 <int-e> if that's what you mean by fold, then yes.
08:42:20 <glguy> I just meant that I wrote out the haskell foldl definition first
08:42:26 <glguy> and then made my boxes on that :)
08:42:28 <int-e> no, I didn't.
08:42:43 <glguy> I want to see a Visio plugin to generate 2d files :)
08:43:37 <int-e> my final reverse hat a very funny knot
08:43:51 <int-e> in the wires.
08:43:58 <glguy> my second to last one did too
08:44:10 <glguy> I was trying to pack my boxes in too tightly
08:44:15 <glguy> and made it almost impossible
08:44:34 <lisppaste2> int-e pasted "reverse" at http://paste.lisp.org/display/26538
08:44:51 <glguy> oh my!
08:45:01 <xerox> int-e: hehe
08:45:04 <xerox> G'day.
08:45:09 <glguy> wwhat was your area for that?
08:45:35 <dcoutts__> aarg! iconv has a borked api
08:45:45 <int-e> 820
08:46:03 <glguy> Mine was low 1200s
08:46:10 <glguy> so I guess the knot typing was worth it
08:46:17 <int-e> I didn't discover the trick of putting the end of file marker (TARGET) at the end of the last line during the contest, unfortunately.
08:46:28 <glguy> I didn't really go back and smash it tho
08:47:02 <dcoutts__> dons: get this: if there's an incomplete multi-byte sequence at the end of one chunk (ie a chunk boundary falls inside a 2-byte utf8 sequence) then iconv leaves that at the end of the buffer
08:47:19 <dcoutts__> dons: and expects us to put that at the beginning of the next buffer
08:47:56 <dcoutts__> ie we have to realloc the follwing chunk so we can cons a byte or two onto it
08:47:58 <dcoutts__> doh!
08:48:19 <glguy> int-e: were you able to write the ray tracer?
08:48:25 <dcoutts__> why couldn't the iconv stream's state just held onto the byte or two
08:49:19 <dcoutts__> this way, using iconv always requires copying the data twice
08:49:42 <int-e> glguy: Na, I spent my time on other things, I didn't even try to understand the spec thoroughly. I started two days into the contest. And I slept, too. :)
08:50:08 <glguy> int-e: I wish that I'd have worked on the problems during the contest, but I had stuff going on that weekend :(
08:50:13 <int-e> glguy: I'd have written some sort of compiler though, and not bothered with optimizing the result.
08:50:15 <glguy> I wouldn't have won
08:50:24 <glguy> but it'd be fun to have played
08:51:17 <gour> dcoutts__: why are you doing this iconv-bindings work?
08:51:18 <int-e> yep. it was great. and it was a clever contest.
08:51:30 <dcoutts__> gour: because it's useful
08:51:36 <dcoutts__> and should have been easy
08:51:42 <gour> dcoutts__: i think so, but for what?
08:51:46 <dcoutts__> given the code I just wrote for zlib & bzlib
08:52:02 <glguy> int-e: I was reading a blog entry from a guy that wrote an adventure solver without knowing  that you could switch the outputs
08:52:22 <dcoutts__> gour: useful for converting character sets when reading / writing files etc
08:52:27 <glguy> and then gave his reaction after someone told him :)
08:52:27 <dons> dcoutts__: urk
08:52:49 <int-e> glguy: I did that. (but it's not my blog entry)
08:52:53 <gour> dcoutts__: ghc-6.6. will work with utf-8 source?
08:52:59 <dcoutts__> gour: yes
08:53:12 <dcoutts__> dons: it's clearly designed for the case of using a fixed buffer and reading from a file
08:53:19 <dons> mm. yes.
08:53:29 <dons> not streaming, eh/
08:53:31 <dcoutts__> where it's easy to copy a few trailing bytes back to the beginning of the buffer
08:54:32 <dcoutts__> hmm, so how do we deal with that ?
08:55:04 <dons> how often does it happen? can we just link in these chunks as small LPS elements?
08:55:13 <dons> and hope they're rare?
08:55:54 <dcoutts__> we could try keeping a small buffer to use for the purpose
08:55:54 <dcoutts__> you can't do them at all on their own
08:55:55 <dcoutts__> it has to be a whole multi-byte character sequence at once
08:55:58 <dcoutts__> contiguous
08:56:11 <int-e> glguy: Oh well, I wasted maybe 2 hours for that. It could have been worse. Of course I felt stupid for forgetting about the goggles (which I had examined and used the day before).
08:56:13 <dcoutts__> never split accross chunks
08:56:17 <dcoutts__> so it must be consed onto a bit more data
08:56:32 <dcoutts__> enough to find the end of the seuqnce
08:56:45 <glguy> int-e: i was considering an XSLT solution
08:56:50 <dcoutts__> but we can't find the end of the sequence since we don't know the encoding
08:57:38 <dons> there's a new hit on the unix tools page every 5s. this is really cool :)
08:58:00 <dcoutts__> dons: for a multi-byte encoding it's going to happen ~50% of the time
08:58:10 <dons> argh
08:58:23 <dons> bind to libssl instead?
08:58:41 <dcoutts__> libssl ?
08:59:19 <dons> ;) i.e. write something else
08:59:29 <dcoutts__> hah
08:59:38 <dcoutts__> right, musasabi is doing that one
08:59:40 <int-e> glguy: hmm. After hearing "I wonder if XSLT programmers speak of 'one-pagers' in the same sense as other people speak of 'one-liners'" I decided not to look at the language unless I'm forced to. (I've skimmed the spec though, I think I know roughly what it does.)
09:00:39 <dons> the @quote effect on language adoption, eh, int-e?
09:01:11 <glguy> int-e: lol, I can definitely see that
09:01:23 <int-e> glguy: oh and it's XML. And I think XML is not for human consumption, with the few exceptions where it's truely markup (i.e. you have mainly text with just a few annotations sprinkled within)
09:02:07 <glguy> I've only written one function in XSLt, it returned the filename from a full path
09:02:08 <int-e> ironically, XML was designed for the latter use case, where a lot of its redundancy actually makes sense.
09:02:30 <glguy> but the language is so simple that it doesn't take much to learn it
09:02:58 <glguy> XMLs biggest advantage is that as a standardized format, there are a lot of tools that can operate on any given XML file
09:03:55 * gour would like to have haxml with relaxng support (compact syntax)
09:04:10 <int-e> I know, XML was too good.
09:04:31 <int-e> And we're probably stuck with it :(
09:04:39 <flux__> I wonder how much energy would be saved in the world, if xml had just been a binary format (but would've gained the same level of acceptance) ;)
09:04:51 <gour> he he
09:05:00 <int-e> it wouldn't be a markup language then.
09:05:20 <flux__> well, a 1:1 binary alternative would be sufficient
09:05:24 <flux__> something computers can use
09:05:35 <flux__> actually there is something like that what is usable with wap
09:05:38 <flux__> but nobody uses wap, so..
09:05:50 <int-e> but you know how it is, you wait 3 months and buy a faster server ;)
09:08:18 <glguy> > [(+1)] <*> [2]
09:08:19 <lambdabot>  Not in scope: `<*>'
09:10:38 <roconnor> xml gzipped is a binary format
09:11:00 <glguy> > [1] <$ [2]
09:11:01 <lambdabot>  Not in scope: `<$'
09:11:35 <glguy> > [1] *> [2]
09:11:35 <lambdabot>  Not in scope: `*>'
09:11:45 <glguy>  >:-\
09:12:00 <roconnor> those are in the standard prelude.
09:12:04 <roconnor> aren't
09:12:21 <glguy> Neither is runState
09:12:30 <roconnor> ;)
09:12:40 <roconnor> @loaded-modules
09:12:40 <lambdabot> Unknown command, try @list
09:12:45 <roconnor> @list
09:12:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:12:51 <glguy> > runState get 0
09:12:52 <lambdabot>  (0,0)
09:13:06 <roconnor> @listmodules
09:13:06 <lambdabot> babel base bf check compose dice dict djinn drhylo dummy elite eval fact free fresh ft haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap small spell
09:13:07 <lambdabot> state system tell todo topic type undo unlambda url version vixen where
09:13:22 <int-e> > join (,) 0
09:13:24 <lambdabot>  (0,0)
09:13:34 <roconnor> oh, there is no list of loaded modules
09:13:47 <glguy> int-e: the point is that runState is the mtl package and <*> is not in an extra-libs package :-p
09:14:05 <xerox> > (id &&& id) 0
09:14:06 <glguy> not that I know how to print (0,0)
09:14:06 <lambdabot>  (0,0)
09:14:19 * glguy does one of those anime sighs
09:14:43 <int-e> > (id &&& id) ()
09:14:45 <lambdabot>  ((),())
09:14:57 <glguy> > (id *** id) (0,0)
09:14:59 <lambdabot>  (0,0)
09:15:01 <roconnor> > (0,0)
09:15:03 <lambdabot>  (0,0)
09:15:07 <xerox> > liftM id (,) 0 0
09:15:08 <lambdabot>  (0,0)
09:15:22 <xerox> > ap (,) id 0
09:15:24 <lambdabot>  (0,0)
09:15:32 <int-e> liftM id ...
09:15:36 <glguy> > do { a <- id; b <- id; return (a,b) } 0
09:15:36 <lambdabot>  Parse error
09:15:40 <xerox> hehe
09:15:41 <ventonegro> @index &&&
09:15:42 <sieni> (0,0) is a valid siteswap
09:15:43 <lambdabot> Control.Arrow
09:15:48 <glguy> > (do { a <- id; b <- id; return (a,b) }) 0
09:15:49 <lambdabot>  (0,0)
09:15:58 <sieni> most people are juggling (0,0) most of the time
09:16:03 <int-e> 'useless use of `id` award'
09:16:16 <roconnor> > id (0,0)
09:16:16 <xerox> haha
09:16:16 <glguy> > id (0,0)
09:16:17 <lambdabot>  (0,0)
09:16:18 <lambdabot>  (0,0)
09:16:21 <roconnor> ;)
09:16:36 <glguy> > fix $ const (0,0)
09:16:37 <lambdabot>  (0,0)
09:16:49 <glguy> > fix (~(a,b)->(b,1))
09:16:49 <lambdabot>  Parse error
09:16:54 <glguy> > fix (\~(a,b)->(b,0))
09:16:55 <lambdabot>  Parse error
09:16:59 <xerox> > (>>= (,)) id 0
09:17:00 <lambdabot>  (0,0)
09:17:01 <roconnor> > runIdentity . return $ (0,0)
09:17:01 <lambdabot>  Not in scope: `runIdentity'
09:17:13 <glguy> > fix (\ ~(a,b) -> (b,0))
09:17:14 <lambdabot>  (0,0)
09:17:58 <xerox> > (((,) =<< id) 0, (id >>= (,)) 0)
09:17:59 <lambdabot>  ((0,0),(0,0))
09:18:27 <glguy> but more importantly, why isn't Control.Applicative in scope :)
09:18:45 <glguy> it would enable us to golf much more efficiently
09:18:53 <glguy> and obfuscatedly
09:20:05 <int-e> damn, they are stealing all the good infix operators.
09:20:46 <dcoutts__> dons: ah! I think it can be done...
09:20:52 <dcoutts__> with a little cunning
09:21:03 <xerox> OK I did as much as I could I think :P
09:21:47 <dcoutts__> dons: suppose you've got 2 or 3 bytes left over from one buffer, and the following buffer is big, eg 4k+ we don't want to realloc 4k just to cons on 2 bytes
09:22:01 <int-e> and infix operators are precious, because qualified infix operators just look ugly.
09:22:11 <dcoutts__> dons: however, we could keep a small buffer and copy some of the 4k into that
09:22:31 <glguy> int-e: then don't import Control.Applicative in your infix operator heavy .hs files :)
09:22:32 <xerox> > (>>) undefined (,) 0 0
09:22:33 <lambdabot>  (0,0)
09:22:37 <dcoutts__> dons: then we write the 2 bytes into that temp buffer and iconv that.
09:22:50 <dcoutts__> dons: err 2 bytes + a prefix of the next 4k chunk
09:23:32 <int-e> glguy: I'm half joking :)
09:23:53 <glguy> I think that the infix operators in Control.Applicative are bad simply because they don't convey any speical meaning to me
09:24:09 <dcoutts__> dons: now if iconv leaves a few bytes over in this mini buffer then we can detect that and start our iconv of the big 4k buffer from the position of the beginning of that incomplete sequence
09:24:14 <glguy> but I still want to use them :)
09:25:18 <dcoutts__> dons: the only thing we need to guarantee is that there is some upper bound on the number of bytes used to encode a single char in any char encoding
09:25:27 <dcoutts__> eg 32, 64 would do
09:25:38 <dcoutts__> one cacheline would be ideal
09:25:40 <glguy> 64 byte character encodings?
09:25:57 <dcoutts__> glguy: I just need an upper bound
09:26:06 <dcoutts__> there are some wierdo statefull encodings around
09:26:53 <dcoutts__> so I think it's possible to do effeciently, just a right pain in the posterior
09:27:22 <roconnor> > uncurry (,) (0,0)
09:27:23 <lambdabot>  (0,0)
09:27:53 <int-e> > uncurry (flip (,)) (1,2)
09:27:55 <lambdabot>  (2,1)
09:29:01 <cjeris> there's plenty of good infix operators in U+2190..U+22FF, U+2A00..U+2AFF :)
09:29:42 <glguy> int-e: what unicode character was that one UM password representing?
09:29:50 <glguy> I just realized what that was
09:30:00 <int-e> glguy: the ying yang sign
09:30:13 <glguy> oh, wow
09:30:17 <int-e> glguy: and the username was ying
09:30:18 * gds reads dons' blogged haskell one-liners Unix tutorial, and wonders if there's an easy way to use runplugs like "perl -e"...
09:30:25 <glguy> yang
09:30:29 <int-e> close.
09:31:21 <cjeris> "Unicode: More funky arrows than even a twitching monaddict could use in one program"
09:31:42 <dcoutts__> gds, you know that ghc -e work right?
09:32:05 <roconnor> > decodeFloat 0
09:32:07 <lambdabot>  (0,0)
09:32:28 <int-e> â â â â â â â â
09:32:29 <gds> dcoutts__: I didn't really, no - but I'm glad it does - does it automagically import sensible libs (like the ones dons uses), or are there switches to do that?
09:32:34 <glguy> ?type quotRem
09:32:36 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:32:50 <glguy> > quotRem 0 1
09:32:52 <lambdabot>  (0,0)
09:32:57 <dcoutts__> gds, ghc -e Foo.Bar.baz works fine
09:32:58 <int-e> and another scim latex table bug. it lists â as searrow which somehow fails to work.
09:32:59 * cjeris blocks int-e's spinning piledriver
09:33:38 <glguy> â¯
09:33:39 <dcoutts__> gds, ie every exposed package is available fully qualified
09:33:47 <int-e> glguy: yeah
09:33:57 <glguy> int-e: did that display on your screen?
09:34:18 <int-e> glguy: yes, and it's almost recognizable, too, despite the small font size.
09:34:28 <glguy> int-e: what IRC clientdo you use?
09:34:36 <int-e> xchat
09:34:40 * gds will have a play later :)
09:34:44 <cjeris> int-e: what are you using to type those characters?  one thing that frustrates me about perl 6 is I don't have an editor that makes it simple to type exotica without cut-and-paste
09:35:00 * gds waves and descends into The Tube...
09:35:02 <int-e> cjeris: scim with a modified latex scim table.
09:35:12 <glguy> I can see those characters with Colloquy
09:36:15 <emertens> âº
09:36:59 * cjeris is stuck on windows.  cjeris guts himself with a \Longrightarrow
09:37:10 <int-e> â â â â
09:37:25 <emertens> (+) (-) (x) (.)
09:37:37 <emertens> translated for those that can't see unicode ;)
09:37:37 * dottedmag .oO(old good APL games)
09:37:43 <dcoutts__> > foldl (â) 0
09:37:44 <lambdabot>  Illegal character ''\138''
09:37:58 <int-e> cjeris: scim isn't too bad (if you're running something X11 based). the latex table requires some fluency in latex, obviously.
09:38:35 <cjeris> i've always wondered whether the marvel people just don't know any math; why are Wolverine, Psylocke et al running around wearing big tensor product signs?
09:39:53 <emertens> dottedmag: there is probably a unicode thought bubble that you could use ;)
09:39:58 <sieni> cjeris: haha
09:40:41 <cjeris> i guess "MULTILINEAR-ALGEBRA-MEN" isn't such a catchy title for a comic
09:40:56 <emertens> I'd watch it
09:42:49 <int-e> glguy: fwiw, if I were seriously using unicode I'd look for a different input method that requires fewer keystrokes.
09:43:18 <int-e> cjeris: oh, that was meant for you.
09:43:33 <emertens> I was trying to think of something clever to say in response
09:43:37 <emertens> but you corrected too soon
09:43:38 <emertens> ;)
09:44:38 <Bourbaki> what?
09:44:43 <Bourbaki> id buy such a comic :)
09:45:02 <Bourbaki> whos the main character?
09:45:31 <araujo> hi hi!
09:45:39 * araujo 's birthday is today!
09:45:53 <emertens> Wish him a happy birthday for us
09:46:01 <roconnor> \o/ happy birthday!
09:46:12 <emertens> someone save roconnor , he's drowning!
09:46:22 <int-e> hmm, maybe you can make speech bubbles from ï¸¸
09:46:25 <roconnor> I can't swim ~\o/~
09:46:49 <emertens> I also see a transformer robot squinting
09:47:25 <araujo> Thanks emertens roconnor !
09:51:10 <emertens> A couple days ago this was said in channel, "Rabhi & Lapalme describe the Burstall & Darlington rewriting system. I was totally unfamiliar with such system before reading that book. Afterwards both my Haskell and Python outputs were more efficient."
09:51:26 <emertens> Does anyone know what the Burstall & Darlington rewriting system is?
09:51:52 * emu is gonna try compiling ghc from darcs
09:59:56 <gour> emertens: reference says: A transformation system for developing recursive programs"
10:00:21 <gour> emertens: Journal of ACM, vol24, pp.24-67
10:00:53 <gour> emertens: does it help?
10:01:21 <emertens> Are those journals available online?
10:01:56 <gour> emertens: don't know
10:03:09 <gour> emertens: shortly is says: "The basis of idea is to treat a program as a set of equations and then perform a series of 'equal-to-equal' substitutions in order to get an equivalent program." (from Algorithms book)
10:06:58 <emertens> gour: thank you
10:08:26 <fasta> I can only name complete patterns, right? Not subparts of patterns?
10:08:53 <emertens> xs@(x: ys@(y:ys))
10:09:11 <emertens> you mean like that?
10:15:15 <chris2> that burnstall paper reminds me a lot about the fusing one
10:19:49 <roconnor> @seen shapr
10:19:49 <lambdabot> I saw shapr leaving #haskell 1h 22m 19s ago, and .
10:21:03 <emertens> âIn Japan there is a perception that one yen is the same as one dollar and one euro, so Japanese people feel itâs a little expensive,â said Nanako Kato, a spokeswoman for SCEI in Tokyo.
10:21:10 <emertens> Â¥49,980 (US$427)
10:21:28 <roconnor> @google 1 yen in dollars
10:21:29 <lambdabot> 1 Japanese yen = 0.00852369587 U.S. dollars
10:21:47 <roconnor> @google 49980 yen in dollars
10:21:49 <lambdabot> 49,980 Japanese yen = 426.01432 U.S. dollars
10:21:55 <emertens> And here I was thinking Asians were good at math ;)
10:22:24 <vincenz> chinese!
10:22:26 <vincenz> not japanese
10:22:30 <vincenz> dr yau
10:22:30 <emertens> oh
10:22:33 <roconnor> google is good at math
10:22:34 <tennin> my Asian stereotype is that they seem to consistently use more cooking analogies than others.
10:22:50 <dfranke> How do I tell cabal what .h file to use when invoking c2hs?
10:22:50 <emu> i like how Alex comes with no build instructions
10:28:01 <irgs> @google 1 yen in euros
10:28:02 <lambdabot> 1 Japanese yen = 0.00672215763 Euros
10:29:59 <int-e> @google 1 psi in pa
10:30:02 <lambdabot> http://en.wikipedia.org/wiki/Pascal
10:30:23 <int-e> @google 1 psi in pascal
10:30:25 <lambdabot> 1 pound per square inch = 6,894.75729 pascal
10:31:29 <cjeris> @google c in furlongs per fortnight
10:31:30 <lambdabot> the speed of light = 1.8026175 x 10^12 furlongs per fortnight
10:31:53 <cjeris> hey, that's pretty neat.  i didn't know you could do that.
10:32:13 <emu> @google c
10:32:16 <lambdabot> http://en.wikipedia.org/wiki/C_programming_language
10:32:21 <emu> heh
10:33:11 <int-e> psi is just a unit that I encountered in real life and gave up converting in my head.
10:35:45 <emertens> pounds per square inch... is that used to sell fabric?
10:36:17 <vincenz> tires
10:36:44 <mux> ?seen dons
10:36:44 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 36m 5s ago.
10:37:21 <mux> dons: still around?
10:37:59 <int-e> @localtime dons
10:38:02 <lambdabot> Local time for dons is Sat Sep 23 03:37:39 2006
10:39:26 * shapr guesses not
10:40:09 <mux> heh, I solved my problem anyway
10:44:09 <emertens> why do they put so much garbage on the TV during the day??
10:44:14 <emertens> I stay home to have a bed delivered
10:44:19 <emertens> and it's like they don't even care
10:45:41 * gour prefers reading to TV
10:45:55 <fasta> emertens: yes, I mean like that.
10:47:17 <cjeris> emertens: most of the time, watching TV is like stabbing an IV catheter into your eyeball, except the IV tube is full of diarrhea.
10:47:25 <fasta> emertens: you mean there are quality programs at other times?
10:47:38 <emertens> I typically only watch TV thursday nights because my fiancee likes a couple of the programs that are on
10:48:18 <cjeris> PBS has some good stuff here (Boston)
10:49:00 <emertens> usually I'd use NPR as my background noise, but they started interviewing another person I don't care about
10:49:26 <fasta> You can watch Google Techtalks when you are bored.
10:49:32 <emertens> oh?
10:50:30 <fasta> emertens: did that pattern matching work as you posted it?
10:50:42 <emertens> fasta: I didn't try it, but I know that you can nest them
10:50:59 <fasta> emertens: ok, and was "oh?" meant for me?
10:51:08 <shapr> CosmicRay: My mother gave me a Linux book, and your name was on the front!
10:51:10 <emertens> yeah
10:51:22 <fasta> http://video.google.com/videoplay?docid=-8246463980976635143&q=type%3Agoogle+engEDU
10:51:24 <lambdabot> Title: Human Computation - Google Video, http://tinyurl.com/reoh5
10:51:28 <fasta> emertens: this one is pretty nice
10:51:32 <emertens> > let f xxs@(x:xs@(y:ys)) = (x,ys) in f [1,2,3,4,5]
10:51:32 <CosmicRay> shapr: whoo!
10:51:36 <CosmicRay> shapr: which one?
10:51:39 <lambdabot>  (1,[3,4,5])
10:51:48 <shapr> Due to the quality of TV and radio for the last few decades, I only read research papers.
10:51:57 <shapr> CosmicRay: Linux Unleashed
10:52:06 <shapr> fourth edition
10:52:09 <emertens> lol... last few decades ;)
10:52:50 <CosmicRay> shapr: this is a touch embarrassing, but I can't remember exactly what parts of that book I wrote ;-)   I think it was about 5 chapters or so
10:52:54 <shapr> Quality music and video does exist, but it's rare and unpopular.
10:53:01 * shapr grins
10:53:11 <shapr> I told my mother that I knew you online and she was amused.
10:53:14 <CosmicRay> shapr: check out greencine.com
10:53:16 <CosmicRay> hehe
10:53:31 <fasta> project gutenberg ;)
10:53:56 <CosmicRay> shapr: my mother still doesn't quite understand how I am friends with people from europe
10:54:04 <shapr> CosmicRay: Hey, voxee was a great recommendation, thanks!
10:54:05 <basti_> -g-
10:54:13 <CosmicRay> shapr: great!
10:54:20 <shapr> CosmicRay: I'm from Alabama, and now back in Alabama.
10:54:37 <shapr> Though I surely do feel like I'm from Europe.
10:54:44 <shapr> This America place is confusing.
10:54:57 <CosmicRay> shapr: yeah, I know
10:55:23 * shapr decides he's from Europe anayway...
10:55:34 <vincenz> Europeans!
10:55:46 <CosmicRay> shapr: .... at least until the next presidential election ...
10:55:58 * gour is from Balkan :-)
10:55:59 <shapr> When is that anyway?
10:56:03 <CosmicRay> shapr: 2008
10:56:08 <shapr> oh
10:56:13 <CosmicRay> btw there's talk of setting up darcs.debian.org today
10:56:24 <fasta> I have a datatype which is an instance of Typable and Data and I want to run this function over it bottomup, but I don't want that this function gets run over the newly generated terms. How can I do that? f (B (A x)) = A x; f (A x) = B (A x)
10:56:29 <CosmicRay> shapr: yeah, you've got two more years of maniacs in charge.
10:56:53 <Oejet> Congratulations team Lazy Bottoms. :-)
10:57:32 <fasta> I have the suspicion that "everywhere" does call "f" in this case again on the newly generated term.
10:57:50 <fasta> (which is, as stated, not what I want).
10:58:04 <shapr> darcs.debian.org would rock!
10:58:55 <ndm> is haskell.org being lightly fried?
10:59:04 <fasta> Is my question unclear, or is it just that nobody touched Data.Generics before?
10:59:07 <vincenz> in monadic crisps?
10:59:26 <fasta> ndm: it is here
10:59:36 <ndm> well the web pages aren't working like they were yesterday, so it must be monadic in some way
10:59:53 <ndm> :( - i want to release some software, but can't until haskell.org comes back to life :(
11:00:15 <emertens> Listening to this talk on human computation, I can't help but expect that he is going to say that ubuntu is actually a human computation device ;)
11:00:30 <fasta> emertens: he won't.
11:00:40 * ndm tries to run top on haskell.org
11:00:59 <fasta> ndm: are you "into" Data.Generics?
11:01:10 <ndm> fasta: sorry, never touched it
11:03:02 <ndm> CPU on haskell.org is about 2%, so its not that obviously...
11:05:51 <mcnster> howdy
11:07:05 <mcnster> anybuddy familiar with the "syscall" instruction in x86_64?
11:08:04 <fasta> mcnster: #asm is over there
11:08:51 <mcnster> fasta, everyone is sleeping in #asm and #haskell has way-technical people...
11:09:33 <fasta> mcnster: I would advice you to read the manuals, and you could use the GHC sources to see how it's used, I guess.
11:10:15 <mcnster> fasta, the manuals are on my lap.  both intel and amd say nothing about it
11:10:17 <dolio> I thought everyone in #haskell is a useless academic, unconcerned with real-life factors like assembly language. :)
11:10:27 <fwd> Ö)
11:10:29 <fwd> :)
11:10:31 <fwd> I am
11:10:32 <mcnster> heh
11:11:01 <fwd> mcnster, isn't it like 80h?
11:11:04 <mcnster> well, *occassionally* there has been known to be useful conversation here :)
11:11:22 <mcnster> fwd, hi.  does stack switching occur on syscall from dpl3 to 0?
11:11:30 <mcnster> cpl
11:11:33 <fwd> sure
11:11:41 <fwd> that's what are syscalls for
11:11:56 <fwd> ask kernel to do smth
11:12:05 <fwd> and kernel works only in ring 0
11:12:26 <mcnster> ok, so where does sysret get rsp3 from?
11:13:23 <fwd> rsp?
11:13:37 <mcnster> 64-bit mode
11:14:21 <fwd> still not following you
11:14:23 <fasta> mcnster: do you need to be a company to get the dead tree version of the manuals from AMD and Intel?
11:14:41 <mcnster> fwd, i assume rsp3 must be reloaded from cpl3's stack, but i can't find a reference to the stack layout in any manual
11:15:04 <fwd> mcnster, and why do you need it?
11:15:18 <fwd> doesn't ret take care about it?
11:17:17 <mcnster> fwd, follow me here:  on syscall from cpl3, rsp for cpl0 is loaded from the tss.  so rsp for cp3 must be saved somewhere.  where?
11:18:10 <mcnster> fasta, u have to have friends in low places to get amd and especially intel hard-copy manuals ;-)
11:18:43 <fasta> mcnster: ok, so you asked a friend with a company to order them?
11:20:18 <fwd> mcnster, hmm. let me think a minute
11:20:49 <mcnster> fwd, we're talking about the "syscall" instruction, right?  (not syscall-ing in the generic)
11:23:07 <mcnster> hmm, i could look at the linux kernel sources i s'pose...
11:27:32 <ptolomy> Is Haskell.org down, or is my network stupid?
11:27:53 <ndm> haskell.org is down :(
11:28:06 * ndm is trying to release a piece of software, which he now can't :(
11:28:19 <ptolomy> Bugger. Now I have to do work. :(
11:35:26 <fasta> ndm: still drhaskell?
11:35:40 <ndm> fasta: yep
11:35:47 <ndm> if can now spot things like:
11:36:06 <ndm> myfunc = if a then 1 else if b then 1 else 0
11:36:10 <ndm> and suggest you use an ||
11:38:18 <shapr> It's funny that #haskell is often the best #python #c etc
11:38:44 <fasta> ndm: I get a fairly strong "wrong tool for the job"-feeling. Do you really think Haskell is good for this stuff?
11:39:19 <shapr> fasta: I get the impression you prefer Scheme over Haskell :-)
11:39:36 <ndm> fasta: for what? for drhaskell /= dr scheme, just so people know :)
11:39:37 <fasta> shapr: for most of my code I prefer Haskell over Scheme
11:39:53 <fasta> shapr: Haskell is more practical for me
11:40:00 <shapr> What do you do?
11:40:50 <fasta> shapr: It's just that sometimes generic traversals are nice, and it seems the model Ralf has is not as powerful as e.g. Stratego's (which can be ported to Scheme with some effort).
11:42:11 <fasta> ndm: for the tool your are writing.
11:42:46 <ndm> fasta: why? its about 50 lines of haskell, would be hard to beat that in any language...
11:43:15 <fasta> ndm: Ok, well, I was assuming you would want to do something more complex later on.
11:43:26 <ndm> fasta: suggestions?
11:43:38 <ndm> i'm not sure what more complex thing is needed
11:43:58 <ndm> other than syntax analysis, possibly - i.e. x:[] ====> [x], redundant brackets etc.
11:45:07 <ndm> but that requires a parse tree, so depends on the Yhc.Parse library, which is years away at best!
11:49:24 <ventonegro> damn, poor guy
11:50:12 <pandres> yes, he'l be remembered
11:50:24 <pandres> i want to do  a script in haskell, i saw a nice article about this a while ago and cant find it again, somebody knows where i can find it?
11:52:36 <fasta> ndm: I suppose if you want to have an intimate relationship with Yhc, you are right. You might want to have a look at http://ericbouwers.blogspot.com/ who has built a simple static analyzer tool for PHP in Stratego in a couple of months, where he works on a real parse tree, indeed.
11:52:37 <lambdabot> Title: EricBouwers
11:53:10 <ndm> fasta: not really want to, it just makes it much easier
11:53:23 <fasta> ndm: it?
11:54:00 <ndm> fasta: Yhc makes the dr haskell project a 1 day hack, instead of a proper project :)
11:54:53 <fasta> ndm: Can I use Control.Monad.State with Yhc, btw?
11:55:01 <ndm> fasta: no :)
11:55:53 <fasta> ndm: clean webpage
11:56:15 <ndm> ?
11:56:31 <ndm> fasta: which webpage?
11:56:38 <fasta> ndm: http://www-users.cs.york.ac.uk/~ndm/yhc/
11:56:39 <lambdabot> Title: yhc - York Haskell Compiler
11:57:29 <ndm> ah, webpages all over
11:57:35 <ndm> the wiki has most of the info now
11:58:58 <fasta> ndm: the wiki takes ages to get here
11:59:09 <fasta> ndm: nm
11:59:12 <ndm> fasta: the wiki is dead
11:59:19 <fasta> ndm: hosted at haskell.org
12:00:18 <fasta> ndm: what is zapping analysis?
12:00:34 <sylvan> what's going on with haskell.org?
12:01:13 <ndm> fasta: for garbage collection, free memory faster
12:01:21 <ndm> fasta: yep, haskell.org is dead
12:01:45 <fasta> ndm: did you make up the term, as Google doesn't give sane results.
12:02:03 <ndm> fasta: i didn't, its probably been in nhc for years, but may not be well known
12:02:14 <fasta> ndm: is nhc dead?
12:03:52 <ndm> fasta: my opinion, yes, officially, no
12:04:11 <ndm> and dead is a bit harsh, I'd say that Yhc is nhc's successor
12:05:13 <fasta> ndm: by "dead" I mean "unmaintained" as most people I think.
12:05:25 <Patterner> it's just sleeping...
12:05:37 <vincenz> dead is dead, long live its offsprinigs
12:05:50 <vincenz> fasta: bitrotting
12:06:02 <ndm> fasta: its somewhat maintained, but won't have much more added ever, if anything
12:27:37 <SamB> @google icfp contest video
12:27:40 <lambdabot> http://www.cis.upenn.edu/~plclub/contest/results.php
12:27:41 <lambdabot> Title: ICFP Programming Contest 2004
12:27:48 <SamB> @google icfp contest 2006 video
12:27:51 <lambdabot> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/15317
12:27:51 <lambdabot> Title: gmane.comp.lang.haskell.cafe
12:28:36 <vincenz> http://video.google.com/videoplay?docid=6419094369756184531
12:28:39 <lambdabot> Title: ICFP programming contest 2006 results - Google Video, http://tinyurl.com/oshpp
12:29:10 <SamB> vincenz: yes, that was in the email google just found ;-)
12:32:19 <vincenz> :)
12:34:46 <bartw> those initial comical slides are such a nice touch
12:35:51 <vincenz> ;)
12:35:54 <vincenz> popcorn
12:36:11 <vincenz> hehe "Until daddy takes the keyboard away"
12:36:44 <vincenz> fun f () = ... and g () = .... and h () =.... "until daddy..
12:39:00 <bartw> we should torrent a higher quality recording
12:39:14 <vincenz> yeah
12:39:23 <vincenz> so "Lazy Bottoms" is very clearly seen :)
12:39:42 <sjanssen> vincenz: nobody wants to see your lazy bottom
12:39:58 <vincenz> (_|_) to you
12:40:15 <bartw> do they put the slides online themselves ?
12:40:16 <sjanssen> haha, that even looks like a bottom
12:43:05 <SamB> zarvox is not here
12:43:09 <SamB> so who knows?
12:43:24 <SamB> @ask zarvox if the slides are online
12:43:25 <lambdabot> Consider it noted.
12:43:30 <vincenz> "Note how this is a logarithmic scale, mainly intended to embarass python's performance"
12:43:34 <vincenz> LOL
12:44:00 <bartw> python can't be that bad without doing something badly
12:44:16 <SamB> bartw: well. it is not intended for VMs to be written in Python, I guess.
12:44:25 <vincenz> they even wrote an interpreter in Twelf and in postscript
12:44:27 <vincenz> not to mention awk
12:44:28 <SamB> Haskell, really, isn't so great
12:44:41 <SamB> could only get up to about 1/4 the spead of C, apparantly
12:46:37 <bartw> doesn't sound so bad
12:47:05 <dolio> Yeah, but the 1/4 speed Haskell version is longer and harder to follow than the C.
12:47:31 <bartw> the real performance point was allocation
12:47:47 <SamB> the chief advantage of a Haskell version is that it is less likely to fail mysteriously the first time you run it...
12:48:26 <SamB> @google Haskell ums
12:48:34 <lambdabot> search module failed: IRCRaised Lib/Url.hs:159:6-51: Irrefutable pattern failed for pattern Data.Maybe.Just ctype
12:48:39 <SamB> ouch
12:48:40 <dolio> http://www.cse.unsw.edu.au/~dons/um.html
12:48:41 <bartw> i don't get that, i had memory safety with range checking and it did not run faster with it disabled
12:48:42 <lambdabot> Title: Haskell UM
12:48:58 <SamB> did lambdabot run out of net again?
12:49:33 <SamB> who are these malfunctional programmers and how did they get past me in the chart?
12:51:15 <SamB> and I thought dons said I should be ahead of edwardk?
12:51:35 <bartw> whats your ranking then ?
12:51:59 <SamB> 3 now!
12:52:37 <bartw> guess i should try mine ?
12:53:11 <SamB> only if it isn't 64-bit clean
12:53:29 <bartw> it is 32bit only umvm
12:53:45 <SamB> because the 32-bit ones are naturally faster when they work
12:53:49 <vincenz> mine is 64bit clean
12:54:01 <SamB> dons should put those in a different color
12:54:04 <bartw> why ?
12:54:14 <bartw> nothing in the um screams 64bit
12:54:30 <SamB> bartw: because it isn't their fault they are slower!
12:54:38 <shapr> I want a 128 bit cpu.
12:54:59 <SamB> the 64-bit clean ones should probably run on most anything, shouldn't they?
12:55:17 <bartw> too bad i can't submit my umvm impl,
12:55:19 <SamB> as long as it had the appropriate 32-bit type?
12:55:25 <SamB> bartw: you can!
12:56:02 <SamB> just @tell dons my UM is at http://my.domain.name/my/path/um.c
12:56:05 <lambdabot> Title: my.domain.name
12:56:12 <SamB> hahahaha
12:56:32 <bartw> ehmz, it is in delphi, win32 only, and delphi is nonfree
12:56:38 <SamB> oh
12:56:41 <SamB> too bad :-(
12:56:52 <SamB> why did you use Delphi and not C?
12:57:01 <vincenz> what are the ingredients for martini/
12:57:21 <bartw> my head was filled by delphi because of work
12:57:48 <glguy> my C# UM isn't faster than the C and C++ ones, but it's plenty fast for actual use
12:58:06 <dolio> Gin and vermouth.
12:58:12 <dolio> Or, use vodka instead of gin.
12:58:19 <shapr> CosmicRay: Hey, what's the best place to buy network hardware online in the USA? Or desktop PC hardware for that matter...
12:58:38 <glguy> newegg.com used to be the best, i don't know if it still is
12:59:21 <vincenz> I'm such a dork
12:59:32 <shapr> Also, are there any good options for non-x86 Linux hardware? I remember when the Alpha chips were two or three times as fast as x86 for the same cost, is there anything like that these days?
12:59:33 <SamB> mine seems a lot shorter than the ones from "malfunctional programmer"
12:59:33 <vincenz> I got noilly pratt and "martini" vermouth
12:59:35 <vincenz> instead of gin
12:59:43 <shapr> glguy: thanks, I'll try that.
12:59:50 <SamB> I think I have more faith in the optimizer
13:00:20 <vincenz> so I have two the same products and no gin :/
13:00:25 <vincenz> (or vodka)
13:00:30 <dolio> Heh.
13:00:33 * vincenz sniffs
13:01:15 <shapr> hej mejja, lÃ¤rar du Haskell?
13:01:16 <SamB> glguy: you must have a different idea of actual use than I do
13:01:35 <SamB> perhaps because I have a PII 450 MHz with 256 MB of RAM
13:01:35 <shapr> Or should that be lÃ¤rar sig?
13:01:35 * shapr wonders
13:01:56 <bartw> argh, i skewed the baseline
13:01:57 * basti_ actually thinks the conversation is here is rather informal
13:01:59 <shapr> Dude, why not upgrade?
13:02:10 <glguy> SamB: my C# one runs in 4minutes 30 seconds roughly (on a 2.6ghz p4)
13:02:12 <bartw> hmz, maybe if i run edwardk's on my mahcine i can compare it
13:02:20 <glguy> and that's without any attempts at optimization
13:02:29 <shapr> hej magnus-
13:02:32 <magnus-> hej shapr
13:02:35 <glguy> but that speed is plenty responsive for runing the codex
13:02:55 <psi> shapr: "lÃ¤r du dig haskell", but I donÃ¤
13:02:57 <psi> bah
13:03:07 <magnus-> Shae
13:03:11 <SamB> the only attempts at optimization I made (a) stuffing pointers into uint32_t
13:03:16 <psi> don't think anyone would phrase it like that
13:03:17 <shapr> Yes?
13:03:35 <shapr> Skriker du Ã¥t mig?
13:03:35 <magnus-> shapr: Oh, I just checked what your real name was :)
13:03:40 <magnus-> :P
13:03:42 <shapr> psi: What's the right way to say it?
13:03:42 <glguy> I allocate arrays and dump them into a hashtable with a unique key generated by incrementing
13:03:48 <SamB> (b) pre-offsetting my pointers to the beginning of the array
13:04:00 <glguy> since C# isn't realyl a fun of pointers
13:04:18 <glguy> fan*
13:04:31 <glguy> and I didn't want to run the whole thing in an unsafe block
13:04:38 <SamB> and (c) not copying the zero array in the "load program" opcode
13:04:39 <shapr> magnus-: Oh, I'm Shae Erisson, founder of the #haskell channel, responsible for (lack of issues for) The Monad.Reader, found at ScannedInAvian.com and shae.erisson@gmail.com
13:04:56 <magnus-> shapr: I think I've read your blog a few times
13:04:57 <SamB> oh, and using the "inline" keyword all over the place
13:05:00 <glguy> SamB: if you copy the zero array when loadprogram is called on 0
13:05:01 <shapr> Oh, I should update my "About Shae" page on my blog to give my new location in the USA. I am no longer in Stockholm.
13:05:08 <glguy> SamB: the program will run too slow to finish
13:05:09 <shapr> Was it cool?
13:05:11 <norpan> shapr: hey, i forgot to congratulate you on your birthday
13:05:12 <glguy> SamB: sandmark in one day
13:05:17 <Syzygy-> shapr: What did you do in Stockholm?
13:05:18 <magnus-> shapr: Where in USA? I'm also in USA.. In Delaware
13:05:27 <shapr> norpan: w00! I'm 35!
13:05:29 <glguy> loadprogram 0 is how the um does jumps
13:05:32 <SamB> glguy: yes I know that doesn't really count
13:05:33 <glguy> and it happens a LOT
13:05:33 <basti_> shapr: uhm, so you totally moved back to the US now?
13:05:44 <shapr> magnus-: I'm in Birmingham Alabama for now.
13:05:58 <vincenz> shapr: 35?
13:06:06 <shapr> Syzygy-: I was was self employed. To make a long story short, 3.5 years in Finland then 3.5 years in Sweden, now back to the USA.
13:06:08 <magnus-> shapr: not too close
13:06:12 <vincenz> shapr: congrats
13:06:13 <SamB> it does after all say
13:06:13 <SamB> "                  The '0' array shall be the most sublime choice for
13:06:13 <SamB>                   loading, and shall be handled with the utmost
13:06:13 <SamB>                   velocity.
13:06:14 <shapr> vincenz: Sure, I'm old!
13:06:23 <psi> shapr: it's funny, I can't quite figure it out, but I'm a bit drunk. man.
13:06:24 <SamB> hrmm
13:06:30 * SamB doesn't know where the quote came from
13:06:47 <shapr> but most people think I'm in my late twenties, so I'm not worried about looking old yet.
13:07:18 <basti_> shapr: you moved back to the US for now yes?
13:07:22 <shapr> magnus-: Sadly not. But I may organize another free gathering "Haskell for US!" or something.
13:07:23 <int-e> http://icfpcontest.org/um-spec.txt
13:07:40 <shapr> basti_: Yup, for the next three years at least.
13:07:51 <shapr> When do people in the US tend to have time off?
13:07:58 <psi> shapr: I guess what I said is reasonably idiomatic
13:08:03 <basti_> shapr: what about your girl there in sweden?
13:08:06 <magnus-> shapr: never
13:08:11 <vincenz> o'cult was a fun puzzle :)
13:08:14 <SamB> so, basically, I use pre-offset pointers directly, and one inline (which I could have just written in the middle of main() anyway). that is the extent of my optimizations.
13:08:25 <vincenz> o'cult is like a messed up scheme macro system
13:08:42 <shapr> I'd like to organize something #haskell in Birmingham, Atlanta, or some other major city where people could drive, fly, or take the train (hint CosmicRay).
13:08:44 <glguy> I liked it
13:08:52 <shapr> magnus-: True that.
13:09:02 <bartw> 2:44 on my laptop for my vm
13:09:06 <shapr> basti_: She's still my girl in Stockholm. She's flying over to visit me in October! w00!
13:09:10 <basti_> :)
13:09:13 <shapr> @users
13:09:20 <lambdabot> Maximum users seen in #haskell: 238, currently: 236 (99.2%), active: 37 (15.7%)
13:10:11 * shapr laughs at http://lwn.net/Articles/199430/ "Kernel trees - Linus Torvalds: Arrr! Linux 2.6.18. (September 20, 2006)"
13:10:22 <shapr> Anders Carlsson has influenced the world!
13:10:40 <shapr> At least, andersca is why lambdabot has @arr
13:11:58 <dmwit> ?arr!
13:11:58 <lambdabot> Drink up, me 'earties
13:12:36 <dmwit> @vixen Quit swashbuckling me heart, yon landlubbin' lass!
13:12:37 <lambdabot> yup
13:12:56 * shapr grins
13:13:23 * dmwit loves Sept. 19
13:14:26 <bartw> 2m 7 for edwardk's baseline
13:16:23 <bartw> SamB: i have a rating of 1.29 compared to edwardk on my laptop, that would make me 4th ?
13:16:36 <SamB> um.
13:16:49 <SamB> well, maybe!
13:17:07 <bartw> SamB: would make mine the fastest contest used umvm :)
13:17:21 <SamB> who knows what the rankings are on windows, though?
13:17:33 <SamB> or that you compiled edwardk's entry correctly
13:17:41 <SamB> try also the other two
13:17:57 <bartw> i admit to only using gcc -O
13:18:05 <SamB> aha!
13:18:13 <SamB> you are supposed to use like -O3!
13:18:22 <bartw> lets try that :)
13:19:38 <SamB> as you can see, my Haskel UM is currently third from the bottom ;-)
13:19:53 <glguy> the UM allocates a metric shit-ton of 3 element arrays in sandmark
13:20:00 <vincenz> SamB: not my bottom
13:20:11 <SamB> no, the bottom of the list!
13:20:21 <vincenz> that's infinitely far!
13:20:36 <bartw> i use the fastmm allocator, that one works great for small objects like an oo language produces
13:20:43 <vincenz> bartw: link?
13:20:43 <bartw> 1m57 10seconds faster
13:20:52 <bartw> fastmm.sf.net
13:21:11 <vincenz> th
13:21:12 <vincenz> +x
13:21:25 <bartw> you should be able to hook the precompiled dll into other languages on windows, or take the code and adapt it for linux
13:21:30 <SamB> vincenz: different list, then!
13:22:06 <SamB> bartw: what size objects does it produce in adventure?
13:22:19 <glguy> during the 99 benchmark, there are at least 18000 arrays allocated
13:22:38 <bartw> SamB: i haven't checked
13:22:56 <bartw> SamB: small string sized ones afaik
13:23:21 <vincenz> SamB: bottom is infinitely far away
13:23:27 * vincenz goes off to get a bottle of gin to try out martinis
13:23:36 <vincenz> you guys recommend gin or vodka?
13:23:41 <SamB> vincenz: you stop being a pain in the lazy bottom!
13:23:55 <vincenz> I didn't sleep last night, I get giddy then :/
13:24:14 <dolio> Have you had gin before?
13:24:19 <vincenz> hmm
13:24:20 <vincenz> dunno
13:24:21 <bartw> i prefer port
13:24:28 <vincenz> in a martini?
13:24:34 <glguy> I prefer *vim*
13:24:35 <vincenz> bartw: port is nice, but it gets too sweet fast
13:24:37 <bartw> yes, without the martini
13:24:52 <dolio> Vodka's a little more bland, if you prefer that sort of thing.
13:24:57 <vincenz> but I tasted a martini in toronto for the first time ( I always thought the vermouth sold as "martini" was martini)
13:25:04 <vincenz> and I liked it quite a bit :)
13:25:06 <vincenz> so I want to experiment
13:25:17 * vincenz got a bottle of noilly prat and martini vermouth, just no gin or vodka
13:25:47 <dolio> Go with gin, I guess. You can make other quality drinks with it.
13:25:57 <dolio> If you don't like the martinis, that is.
13:26:10 <vincenz> thx
13:26:16 <astrolabe> gin is too nice
13:26:23 <dolio> Gin and tonic/ginger ale is also good.
13:26:31 <glguy> hear hear!
13:26:38 <glguy> or here here
13:26:40 <glguy> i don't know
13:26:53 <astrolabe> hear :)
13:27:01 * vincenz hmms
13:27:04 <vincenz> and then time to test squeak
13:27:05 <glguy> hmm hmm
13:27:25 <Patterner> Stirred, not shaken!
13:27:53 * vincenz is off to nightshop
13:27:53 <vincenz> brb
13:28:11 <Patterner> btw, it's not a Martini with vodka...
13:29:01 <dolio> Yeah, it'd be a vodka martini. Real martinis are gin.
13:29:48 <SamB> bartw: I have no idea how to use Delphi code on Linux...
13:30:17 <Patterner> isn't delphi called kylix on linux?
13:30:32 <SamB> well. and with C.
13:30:38 <bartw> SamB : there are a few opensource project that try to compile it, most of it is horribly alpha
13:30:55 <SamB> probably not going to help me ;-)
13:31:21 <SamB> it might not be better than the malloc I' anyway...
13:31:23 <SamB> er.
13:31:29 <SamB> s/I'/I'm using/
13:31:45 <SamB> which is just the one that comes with glibc...
13:43:02 <vincenz> backok so I sold out a bit
13:43:06 <vincenz> I got gordon's
13:43:18 <vincenz> I was missing 2 euros for bombay sapphire
13:44:14 <Syzygy-> vincenz: Ginned up_
13:44:21 <Syzygy-> s/_/?/
13:44:29 <vincenz> no I just got it
13:44:37 <vincenz> tried to google for a martini recipe but can't find it
13:45:44 <Syzygy-> vincenz: Wikipedia.
13:46:18 <piggybox> I'm watching the ICFP video. What's that 2D language?
13:46:44 <SamB> piggybox: it is a PITA
13:46:59 <Patterner> the bombay sapphire is much much better than gordon's
13:47:04 <Syzygy-> vincenz: According to Casino Royale, the martini Bond drinks is 3x gin (preferably Gordons), 1x vodka (Russian or Polish), 1/2 x Kina Lillet, shaken until ice cold and with a lemon peel.
13:47:05 <vincenz> I know
13:47:10 <SamB> you get more points the less "area" your program occupies
13:47:16 <bartw> SamB: it might not be better then the glibc one, it is however miles better than the default one that comes with delphi ;P
13:47:19 <vincenz> I read in my brother's book (in italy) that you need > 40% for the good flavours
13:47:27 <vincenz> but bombay was out of my range (only had change on me)
13:47:28 <SamB> bartw: well, I imagine so ;-)
13:47:32 <vincenz> and gordon's is only 37%
13:48:15 <Syzygy-> vincenz: Further from Wikipedia: A standard modern martini is 5x Gin, 1x Vermouth
13:48:29 <vincenz> thx
13:48:31 <vincenz> I'll try the in and outt
13:48:33 * vincenz goes to make ice
13:48:33 <emu> don't spoil good gin with nasty vermouth
13:48:38 <vincenz> emu: I have noilly prat
13:48:43 <vincenz> and "martini" the std onoe
13:48:43 <piggybox> PITA? What does that stand for?
13:48:53 <bartw> piggybox : ask google
13:49:04 <astrolabe> * * the ass
13:49:10 <vincenz> astrolabe: you mean pain in the *
13:49:19 <astrolabe> :)
13:49:20 <vincenz> normally one blots the swear word
13:49:27 <emu> pita in the *
13:49:36 <emu> recursive acronym
13:49:39 <astrolabe> surely pain is worse than asses
13:49:42 <piggybox> oh...
13:50:08 <vincenz> do I need to cool either?
13:50:18 <piggybox> Is that language invented by CMU or the first winner?
13:50:22 <Syzygy-> emu: That would be pitp, wouldn't it?
13:50:37 <Syzygy-> vincenz: The idea would be to stir them with ice, then strain into a martini glass.
13:50:59 * vincenz goes to make ice
13:51:06 * vincenz is tempted to use bottled water
13:51:09 <Patterner> NO ICE ALLOWED
13:51:25 <emu> > fix (++['i','t','a'])
13:51:26 <lambdabot>  Exception: <<loop>>
13:51:36 <Patterner> he
13:51:47 <Syzygy-> Patterner: Nonono... No -shaking- allowed, you still want to chill - you only don't want to dilute.
13:51:53 <astrolabe> wikip says it includes ice
13:52:29 <astrolabe> and the Europeans prefer a 6:1 ratio
13:52:30 <Patterner> NO ICE FROM TAPWATER ALLOWED
13:52:35 <astrolabe> ah
13:52:38 <emu> yao
13:52:42 <basti_> so you guys are debating how you want your solvents?
13:52:44 <Syzygy-> Patterner: No need to shout damnit.
13:52:50 <vincenz> seems I have to chill martini and vermouth
13:52:53 <lispy> haskell.org is down?
13:53:00 <basti_> ah, thats why
13:53:00 <Patterner> some things are important enough for shouting
13:53:21 <lispy> i wonder why it does down
13:53:25 <Syzygy-> Patterner: But not that.
13:53:33 <emu> what goes up must come down
13:53:33 <vincenz> Syzygy-: small question "strain" ?
13:53:50 <dolio> You don't want the ice in it while you're drinking it.
13:53:55 <Syzygy-> vincenz: As in get the ice out of there.
13:54:04 <Syzygy-> Pouring through a fine mesh that keeps the ice out.
13:54:18 <vincenz> th
13:54:19 <vincenz> x
13:54:25 <Syzygy-> http://images.google.de/images?q=tbn:8gK--DRmK_1QYM:http://images.cb2.com/is/image/CB2/SSCocktailStrainer%3F%24lg%24
13:54:29 <lambdabot> http://tinyurl.com/gkev6
13:54:29 <Syzygy-> Typically something like that.
13:54:39 <vincenz> alright, so the only thing I'm missing is a martini glass and ice
13:54:48 <vincenz> ah right, I'll just pour carefully :)
13:54:49 <CosmicRay> shapr: newegg.com is pretty good
13:55:10 <vincenz> Syzygy-: think I should put the bottles in the fridge?
13:55:32 * basti_ tried long time to find the correct alcohol/time rate to get a decent buzz and not get sick the next day, but then gave up with 24 or something
13:55:35 <Syzygy-> vincenz: What makes you think I know anything about it? I started drinking alcohol a month and a half ago... :)
13:56:04 <vincenz> oh
13:56:05 <dolio> If you stick the bottles in the freezer, you might not need the ice.
13:56:06 <vincenz> :)
13:56:17 <dolio> Since it'll already be cold.
13:56:21 <vincenz> true
13:56:22 * vincenz hmms
13:56:29 <basti_> that depends
13:56:31 <vincenz> I'll put them in the fridge not the freezer as trade-off
13:56:34 <vincenz> the water is needed apparently
13:56:35 <vincenz> for dilution
13:56:36 <glguy> and you'll know if someone took alcohol out of the bottle and replaced it with water
13:56:42 <dolio> Heh.
13:56:47 <basti_> if he wants his martiniy today, i wouldn't wait until the bottles are cold
13:56:58 <basti_> since glass insulates well
13:57:01 <basti_> thermically
13:57:07 <Syzygy-> And not necessarily go with the fridge either...
13:57:26 <basti_> I'd not necissairly go with alcohol at all
13:57:29 <basti_> if you ask me
13:57:31 <basti_> but that's just me
13:57:32 <basti_> ;)
13:57:43 <Syzygy-> basti_: I think that option is gone already for vincenz
13:57:52 <basti_> *G*
13:58:14 <basti_> well i don't mind alcohol. the problem is the day after.
13:58:17 <br1> I'm getting this error when trying to install Streams:
13:58:18 <br1> *** Exception: Line 17: Unknown field 'extra-source-files'
13:58:18 <basti_> and the night
13:58:24 <br1> What is it?
13:58:35 <basti_> apparently, a record error message?
13:58:48 <dolio> Gin can give some nasty hangovers.
13:58:52 <vincenz> basti_: one or two drinks  don't cause a day after
13:58:57 <vincenz> I just wanted a martini for a change
13:59:00 <basti_> ah
13:59:13 * Syzygy- has yet to experience a day after...
13:59:18 <vincenz> nothing wrong with enjoying oneself
13:59:32 <vincenz> Sadly, no martini glasses :/
13:59:33 <br1> basti_:  Do I have to update cabal or something?
13:59:53 <dolio> Just drink it out of a plastic party cup.
13:59:56 <basti_> br1: i don't know how to fix it... it seems rather like a bug internal to the stuff you're compiling. But thats just a guess out of the blue.
14:00:07 <Syzygy-> vincenz: Cup your hands - and drink it FAST.
14:00:10 <Syzygy-> :p
14:00:30 <astrolabe> Syzygy: Are you named for maths or biology?
14:00:32 <vincenz> I have other glasses !
14:00:35 <Syzygy-> astrolabe: Maths.
14:00:41 <astrolabe> yay!
14:00:53 <basti_> vincenz: don't understand me wrong. I support every attempt to get ones' brain messed up, i just think, alcohol is about the last thing i'd try it with.
14:00:53 <Syzygy-> astrolabe: Please note the other channels I'm active in. :P
14:01:13 <vincenz> basti_: I don't like getting drunk
14:01:14 * Syzygy- is op in EFNet:#math, and active in Freenode:#math...
14:01:23 <vincenz> basti_: I just like having 1 drink
14:01:26 <vincenz> basti_: like enjoying a coffee
14:01:27 <vincenz> or a pizza
14:01:32 <basti_> hmm yea.
14:01:37 <sylvan> There was a paper in Science a few years ago that showed that euphoria is directly proportional to dC/dt, where C is the blood alcohol concentration, whereas "the day after" is a function of things like total amount, and other stuff. In other words, optimize your drinking by taking about one shot of hard liquor each hour or so :-)
14:01:42 <basti_> coffee is a drug too ^^
14:01:57 <dolio> Mmm, martini and pizza. The perfect combination.
14:02:08 <vincenz> basti_: so is oxygen
14:02:10 <basti_> my point is: it's not worth making a difference between "getting drunk" and "having a drink".
14:02:30 <basti_> you're having a drink, at least partially because it contains alcohol
14:02:58 <vincenz> ...
14:03:00 <basti_> i don't think many people drink alcohol for the sake of it's taste
14:03:05 * Syzygy- do.
14:03:08 <vincenz> I only get drunk, or even 'happy' after 4 drinks
14:03:16 <vincenz> one drink is definitely NOT for the alcohol
14:03:27 <basti_> believe what makes you happy.
14:03:28 <Syzygy-> I refuse to drink alcohol for the effects - don't see the point of ti. But I do drink beverages with an appealing taste.
14:03:35 <bartw> basti_ : i do, thas why i consume a whopping bottle per 2 months
14:03:36 <vincenz> basti_: believe what makes you happy as well
14:03:42 <br1> haskell.org is down?
14:04:13 <basti_> appears to be down yea.
14:04:14 <Syzygy-> br1: It would seem that way.
14:04:35 <Syzygy-> 97 packets left till reboot...
14:05:48 <psi> I think cannabis is quite superior to alcohol in terms of getting "messed up" - although I have limited experience with both
14:06:13 <basti_> we could talk about that in -blah
14:06:45 <vincenz> oasis
14:06:46 <vincenz> #oasis
14:06:58 <vincenz> psi: I agree
14:06:58 <psi> I haven't got much else to say ;)
14:07:16 * vincenz tokes some in college, not much, like 10-15 times over the course of 2 years
14:07:20 <vincenz> or 3 years
14:07:21 * vincenz ponders
14:07:37 <vincenz> but yeah, definitely better than getting drunk, I never get drunk, I hate it
14:08:17 <bartw> after using canabis twice, and both times heavily halucinating and throwingup/being sick, i decided that i wouldn't use anything
14:08:26 <vincenz> bartw: ouch :/
14:08:34 <vincenz> bartw: I heard that some people react badly to certain types tho
14:08:39 <sylvan> So has anybody heard about that language Haskell? I hear it's kind of cool!
14:08:39 <vincenz> and don't mix it with alcohol!
14:08:59 <psi> is it like mushrooms?
14:09:02 <vincenz> sylvan: is it haskucinogenic?
14:09:06 * basti_ invites everyone over to #haskell-blah
14:09:12 <sylvan> Only if you mix it with C
14:09:19 <basti_> that channel is specifically for non-haskell topics
14:09:55 <vincenz> #oasis :)
14:10:13 <Lemmih> bartw: If you were hallucinating then you probably smoked something more than cannabis.
14:21:21 <weitzman> Haskell.org seems to be having issues?
14:21:35 <Patterner> It's Dead, Jim.
14:21:42 <weitzman> That's the issue!
14:25:00 * lispy is rereading 'tackling the awkward squad' and finding it to be very helpful
14:25:02 <lispy> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
14:25:05 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/jl2rm
14:31:22 <ptolomy> Maybe someone should acknowledge the status of haskell.org in the topic..
14:32:21 <dmwit> Yeah, Tackling is a nice paper.
14:34:22 <dmwit> I also liked the financial contracts one.
14:34:35 <br1> I thought IORef and STRef were isntances of the same class.  Where is this class?
14:35:14 --- mode: ChanServ set +o shapr
14:35:22 <dmwit> ?type IORef
14:35:24 <lambdabot> Not in scope: data constructor `IORef'
14:35:25 <lispy> shapr: thanks
14:35:26 --- topic: set to '["haskell.org","Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by shapr
14:35:35 <dmwit> ?index IORef
14:35:36 <lambdabot> Data.IORef
14:35:40 <dmwit> ?type Data.IORef
14:35:40 <shapr> lispy: For what?
14:35:42 <lambdabot> Couldn't find qualified module.
14:35:53 <dmwit> ?type f :: Data.IORef
14:35:55 <lambdabot> Couldn't find qualified module.
14:35:57 <lispy> shapr: for changing the topic...although, you might want to add "...is down."
14:36:00 <shapr> oh
14:36:05 --- topic: set to '["haskell.org is down for the moment","Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by shapr
14:36:42 -ChanServ(ChanServ@services.)- shapr!n=user@cs6625118-129.bham.res.rr.com ACCESS [#haskell] ADD lispy 39
14:37:00 <SyntaxNinja> haskell libs can be found here: http://hackage.haskell.org/~ijones/tmp/ghc-libraries/
14:37:04 <lambdabot> http://tinyurl.com/fqq5f
14:37:28 <Lemmih> SyntaxNinja: You asked for me some time ago.
14:37:41 <shapr> lispy: Now you too can change the topic.
14:38:26 <SyntaxNinja> Lemmih: wanted to ask you to hack up a web  hackage interface using xerox et al's new package database.
14:39:35 <lispy> shapr: cool, thanks
14:41:13 <cinema> Does anyone know if the GHC hackathon has been recorded on audio or video ?
14:41:30 <Lemmih> SyntaxNinja: Ah.
14:42:19 <SyntaxNinja> cinema: yeah it has, malcolm wallace did it
14:42:37 <cinema> SyntaxNinja, Great news !
14:43:42 <br1> How do I install a lib manually?
14:44:45 <shapr> with a STICK!
14:44:48 <Lemmih> br1: Manually? Without Cabal?
14:44:50 * shapr goes off to take his meds...
14:45:53 <br1> yes, cabal isn't working for me.  I get *** Exception: Line 17: Unknown field 'extra-source-files'
14:46:20 <lispy> br1: try upgrading your cabal
14:46:25 <lispy> br1: it's actually pretty easy
14:46:26 <Lemmih> br1: You're better off fixing the cabal file than installing manually.
14:46:44 <lispy> br1: do you know what version of cabal you're using?
14:46:55 <lispy> br1: if it's with ghc you can type, ghc-pkg list | grep -i cabal
14:46:58 <br1> I'm running ghc 6.4.1
14:47:13 <lispy> br1: do you have darcs?
14:47:13 <Lemmih> or just: ghc-pkg field Cabal version
14:47:34 <SyntaxNinja> Lemmih: interested?
14:47:34 <br1> cabal 1.0
14:47:49 <SyntaxNinja> br1: a newer cabal is advised :)
14:47:53 <lispy> br1: okay, sounds like we just need to get you upgraded cabal-wise
14:47:58 <br1> ok
14:48:02 <SyntaxNinja> but haskell.org is down, 'eh
14:48:08 <br1> :)
14:48:08 <lispy> oh...right
14:48:10 <yip> that bugger is down again? :O
14:48:13 <Lemmih> SyntaxNinja: Hm, I might be.
14:48:14 <lispy> i can put up a recent cabal archive
14:48:36 <lispy> recent as of yestarday
14:49:09 <SyntaxNinja> Lemmih: it would be a big help. SPJ is absolutely convinced we need it ASAP.
14:49:23 <lispy> br1: darcs get http://projects.codersbase.com/repos/Cabal/
14:49:24 <lambdabot> Title: Index of /repos/Cabal
14:49:30 <SyntaxNinja> I'm more convinced that we need cabal-install to work, but he thinks the website is vital
14:49:58 <Lemmih> SyntaxNinja: I'm not completely sure I know what the website should look like.
14:51:03 <impec> @hoogle (~)
14:51:05 <lambdabot> Did you mean: (~)
14:51:05 <lambdabot> Prelude.undefined :: a
14:51:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:51:32 <lispy> @hoogle ((~))
14:51:33 <lambdabot> Did you mean: ((~)
14:51:33 <lambdabot> Prelude.undefined :: a
14:51:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:51:38 <lispy> :(
14:51:50 <lispy> @hoogle :(
14:51:50 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':('
14:52:05 <impec> :-)
14:52:45 <darinm> shapr: I just sent you that list
14:53:06 <lispy> i don't know if br1 will use my repo but the fact that i can just mv my checkedout copy over to a web accessible directory is nice
14:53:17 <glguy> impec: are you trying to figure out what ~ is for?
14:53:19 <lispy> darcs is so cool like that
14:53:56 <Lemmih> Sleep well, #haskell.
14:54:01 <lispy> Lemmih: good night
14:54:04 <br1> lispy: I'm working on it.
14:54:06 <Cale> impec: hm?
14:54:18 <Cale> impec: Where is ~ showing up?
14:54:29 <lispy> br1: i can help if you're having problems
14:55:09 <br1> It told me 'Invalid multiplex command' but it seems to be working
14:55:11 <darinm> lazy patterns?
14:55:11 <impec> here : http://dada.perl.it/shootout/ary3.ghc.html
14:55:13 <lambdabot> Title: ary3.ghc
14:55:30 <lispy> br1: oh, i haven't seen that one before
14:55:52 <glguy> ~[n] <- getArgs
14:56:23 <lispy> SyntaxNinja: is my cabal problem with installing libraries just a umask issue?
14:56:27 <glguy> I'm guessing that that causes the application not to break if more than one argument is specified
14:56:29 <lispy> SyntaxNinja: (do you remember what i'm takling about...)
14:56:54 <glguy> > let f ~[x] = x in f [1,2]
14:56:55 <lambdabot>  Irrefutable pattern failed for pattern [x]
14:56:59 <glguy> hmm
14:57:25 <lispy> > let f ~x = 1 in f undefined
14:57:25 <glguy> > do { ~[x] <- [[1,2]]; return x}
14:57:26 <lambdabot>  1
14:57:27 <lambdabot>  Irrefutable pattern failed for pattern [x]
14:57:32 <lispy> > let f x = 1 in f undefined
14:57:33 <lambdabot>  1
14:57:38 <glguy> that shows it ^^
14:58:00 <glguy> > do { [x] <- [[1,2]]; return x}
14:58:01 <lambdabot>  []
14:58:03 <darinm> ~ is covered in the haskell tutorial part in the pattern section IIRC
14:58:04 <glguy> > do { ~[x] <- [[1,2]]; return x}
14:58:05 <lambdabot>  Irrefutable pattern failed for pattern [x]
14:58:06 <darinm> for lazy patterns
14:58:49 * glguy doesn't really know why ~[x] is better than (x:_)
14:59:54 <impec> haskell.org is down?
15:00:00 <lispy> impec: indeed
15:00:59 <impec> too bad. will continue learning with local docs
15:03:09 <impec> darinm: thanks
15:03:13 <impec> bye
15:03:16 <darinm> np
15:03:43 <bartw> what would have been the world's most expensive hello world ?
15:04:02 <lispy> bartw: this sounds like the setup of a bad joke :)
15:04:07 <br1> lispy: How do I install Cabal now?
15:04:19 <bartw> lispy: not really
15:04:30 <dolio> > let f (a,b) = True in f undefined
15:04:32 <lambdabot>  Undefined
15:04:33 <lispy> br1: runghc Setup.hs configure; runghc Setup.hs build; sudo runghc Setup.hs install
15:04:38 <shapr> darinm: thanks
15:04:43 <dolio> > let f ~(a,b) = True in f undefined
15:04:45 <lambdabot>  True
15:04:49 <darinm> welcome
15:05:12 <lispy> bartw: what do you mean?
15:05:13 <darinm> I was a bit lazy or I would have done it up in bibtex with some other stuff.. heh
15:05:18 <darinm> but I think there's a lot there
15:05:23 <bartw> lispy: i just finished a helloworld test at work for a bigass framework, if they scrap it it would be an expensive helloworld
15:05:35 <lispy> bartw: Ah
15:05:38 <bartw> lispy: but there probablyis a seriously more expensive one
15:06:45 <bartw> lispy: maybe an AI project that only ever produced a hello world after a few M$ ?
15:07:20 * lispy parsed that as "...after a few microsoft" at first :)
15:07:48 <glguy> i saw milliseconds
15:07:59 <dolio> Mega-dollars?
15:08:11 <lispy> no, i think it's the currency monad
15:08:17 <lispy> M $ Double
15:08:25 <glguy> M $ ?
15:08:35 <glguy> where ? must have some value
15:08:35 <lispy> takes a currency type and a value
15:09:08 <glguy> maybe he wanted us to form the sentece, and then apply a qusetion to it
15:09:14 <lispy> hehe
15:09:26 <lispy> higher order conversations
15:09:38 <glguy> but if he had said: Something like this $! ?
15:09:46 <glguy> I guess we would have to consider the question first
15:09:54 <glguy> and then form the sentence
15:09:58 <lispy> strictly speaking :)
15:10:09 <glguy> ;)
15:10:29 <shapr> The ! always looks to me like the ruler a strict teacher would carry.
15:10:50 <glguy> Look at shapr, strutting around with his @
15:11:07 <bartw> M$ as in megabucks, milions of dollars
15:12:01 <bartw> hmz, if i had to choose a weapon i would go for the >, nice little boomeranf
15:12:23 <glguy> if we could use unicode characters...
15:12:26 <bartw> usable as an axe in case of trouble
15:12:39 <bartw> thats cheating
15:13:06 <glguy> There are no *rules* in choosing weapons from character encodings (c:
15:13:16 <lispy> irc is a bit primitive in what you can do /me considers that a good thing
15:13:19 <bartw> shuriken *
15:13:23 <br1> lispy: It worked!
15:13:27 <lispy> br1: cool!
15:13:32 --- mode: shapr set +o glguy
15:13:41 <br1> Should I keep your version of Cabal once haskell.org wwakes up?
15:13:43 <shapr> glguy: I was just changing the topic :-P
15:13:44 <glguy> whoa
15:13:44 --- mode: shapr set -o shapr
15:13:49 <glguy> look at me go ;)
15:13:53 <lispy> hehe
15:13:59 * glguy is taking a screenshot
15:14:16 * shapr grins
15:14:17 <ihope> Somebody opped some random person on the streets?
15:14:20 <ihope> :-P
15:14:24 --- mode: glguy set -o glguy
15:14:54 <glguy> I redid the screen shot with me deop-ing myself ;)
15:15:05 <glguy> put that in the old scrap book
15:16:06 <SyntaxNinja> lispy: no, I don't. sorry :)
15:16:15 <glguy> giving out ops isn't what it used to be (with a chanserv around) I used to be in some efnet channel that would have 8 bots netted protecting the channel
15:16:17 <SyntaxNinja> lispy: well, obviously a permission problem, but I don't remember the details.
15:16:22 <glguy> like being in the wild west
15:17:12 <glguy> I think that 8 was the number because you could only deop 3 nicks ata time
15:17:19 <glguy> and that gave the bots enough time to respond
15:17:26 <lispy> SyntaxNinja: oh, well whenever i install something using cabal i have to go back and add read permissions manually.
15:18:08 <lispy> SyntaxNinja: i'd rather not change my umask, but also i don't know which umask would need to be changed and to what value.  I ideally cabal could be set to do the right thing for me...
15:18:29 <glguy> umask 002 wtf ;)
15:20:33 <lispy> well, my regular user has umask 0007
15:20:44 <glguy> when did #haskell get a +t?
15:20:53 <shapr> glguy: Yeah, ops on freenode isn't the same with chanserv around.
15:21:03 <shapr> +t happened when spambots started puttings urls in the topic.
15:21:06 <lispy> and sudo su -c umask says 0022
15:21:29 <SyntaxNinja> lispy: this should be very easy to fix. if cabal isn't setting the permissions explicitly, it could be made to do so;  it's the .exe bit, I take it?
15:21:34 <glguy> oh yeah... forgot the other 2
15:21:43 <glguy> good thing I never change mine ;)
15:22:03 <lispy> SyntaxNinja: my fix is to usually chmod a+rX -R /usr/lib/foo*
15:22:28 <SyntaxNinja> lispy: I assume you've opened a darcs bug?
15:22:45 <lispy> SyntaxNinja: you mean a cabal bug? but no i haven't
15:23:12 <lispy> SyntaxNinja: i didn't even try to look for the bug tracker...i started asking around here first :)
15:23:26 * lispy feels silly
15:28:12 * glguy decides its time for the weekend to start
15:28:14 * glguy &
15:53:31 <lispy> hey, i think t's backup
15:53:43 <lispy> or at least one page loaded for me
15:55:17 <lispy> SyntaxNinja: it's not clear to me how to create a bug report
15:55:34 <lispy> SyntaxNinja: i followed the bug report link and Trac complains that i don't have permission
15:56:50 <lispy> SyntaxNinja: i see a login link, but afaik i don't have an account
15:59:18 <lispy> SyntaxNinja: ah, i found a guest login...which lets me add a bug report
16:11:23 <shapr> darinm: Hey, this is an excellent message, you should post it on LtU!
16:11:50 <darinm> thanks, I'll think about it :)
16:12:24 <Cale> which message?
16:12:49 <darinm> I sent a little reading list on proof theory kinda stuff
16:13:27 <ivant> is haskell.org up? I can't get to the frontpage, though I can ping it
16:13:32 <ihope> What's the keyword "of" used for?
16:13:55 <ivant> ihope: case smth of ...
16:14:25 <ihope> Ah, yes.
16:15:01 <ivant> http://haskell.org
16:15:08 <ihope> @hoogle mean
16:15:18 <dmwit> ivant: check the topic... ;-)
16:15:21 * ihope pokes lambdabot
16:15:46 <ivant> ah, yes
16:17:26 <lambdabot> No matches found
16:18:51 <araujo> argh , haskell.org down!
16:19:13 * araujo jumps and throws a piece of lambda cake for everyone
16:19:36 <int-e> will we survive?
16:20:38 <araujo> @hoogle print
16:20:39 <lambdabot> Prelude.print :: Show a => a -> IO ()
16:20:39 <lambdabot> Text.Printf.Print :: class Print
16:20:39 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
16:22:37 <ivant> fix lambda cake
16:23:14 <araujo> :-)
16:30:12 <shizzy0> I miss haskell.org.  I was going to try to use haddock today.
16:55:25 <impec> @where fptools
16:55:26 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
17:14:47 <lispy> integer = do { char '-'; d <- natural; return (-d) } <|> do { char '+'; natural } <|> natural -- this parser seems to work, but i expected to need some try's in there...why don't i need the trys?
17:17:47 <sylvan> lispy because if either of the two first fails, they won't consume anything (i.e. they fail right away)
17:18:10 <lispy> sylvan: they don't even consume the first char that they looked at? ah
17:18:11 <sylvan> You only need try if the two alternatives have a common prefix
17:18:18 <lispy> Oh
17:18:37 <sylvan> It only consumes characters that succeed.
17:19:11 <kpreid> if that didn't work, you'd need try on every single <|>
17:19:56 <sylvan> I actually prefer ReadP for parsing.. Haven't done any benchmarks or anything so I don't know if there are any good reasons not to use it rather than Parsec, but it saves you from having to worry about "try"
17:20:22 <sylvan> And you get all possible parsers automatically
17:20:26 <sylvan> parses
17:20:32 <lispy> kpreid: which is sort of how my current parsers are written :)
17:20:55 * lispy makes good note
17:20:59 <lispy> thanks
17:23:57 <lispy> ?hoogle Real a, Num b => a -> b
17:23:59 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:23:59 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
17:23:59 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
17:24:43 <lispy> ?hoogle fromReal
17:24:43 <lambdabot> No matches found
17:25:21 <lispy> ?hoogle Floating
17:25:21 <lambdabot> Prelude.Floating :: class Fractional a => Floating a
17:25:39 <lispy> ?hoogle Double -> Floating a
17:25:40 <lambdabot> No matches, try a more general search
17:25:50 <lispy> anyone know what function i want?
17:25:58 <lispy> ?hoogle Floating a => Double -> a
17:25:59 <lambdabot> No matches, try a more general search
17:29:34 <twanvl> ?type realToFrac
17:29:35 <lambdabot> forall b a. (Fractional b, Real a) => a -> b
17:29:51 <twanvl> ?type floor
17:29:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:30:17 <lispy> ?hoogle Floating a => Float -> a
17:30:18 <lambdabot> No matches, try a more general search
17:30:27 <lispy> ?instances Floating
17:30:28 <lambdabot> Double, Float
17:30:34 <lispy> bleh, not worth the trouble :)
17:30:54 <twanvl> What are you trying to do?
17:31:43 <lispy> well, i'm parsing floats and i was hoping to avoid needing to sprinkle around numeric conversions by making the parser polymorphic
17:31:52 <lispy> so i did this for the integer parser
17:32:13 <lispy> it returns Num a
17:32:27 <twanvl> You could just stick to Rationals, Language.Haskell does that
17:33:02 <lispy> well, i'll be outputing some of the values later as floating point stuff
17:33:13 <lispy> so i'm not sure Rationals are right
17:33:39 <twanvl> Maybe you need RealFrac?
17:36:06 <twanvl> and maybe I need sleep...
17:36:13 <lispy> :)
17:36:18 <lispy> i think this will be fine
17:36:27 <lispy> i think i'm worrying too much about a small detail
17:50:52 <magnus-> Is there any nice tools for debugging someone elses haskell code
17:51:08 <magnus-> like a stepper
17:51:31 <magnus-> for example stepping through what happens in the IO monad
17:51:56 <lispy> magnus-: i don't know about the IO monad but, iirc buddah is a debugger that lets you do that sort of stuff
17:52:01 <lispy> also ghci will get that feature soon
17:52:14 <magnus-> cool, I'll look up buddah :)
17:52:20 <lispy> magnus-: also look at hat
17:52:25 <magnus-> okay
17:54:02 <lispy> i wanted to say manyTill anyChar (newline <|> eof), what should i say?
17:54:10 <lispy> I want to parse to either the end of the line or the end of the input
17:54:15 <lispy> which ever comes first
17:54:46 <magnus-> That should work I would have thought
17:55:01 <magnus-> I've used that kind of construct in my own code
17:55:21 <lispy> well, manyTill anyChar newline works until i hit eof, but eof has different type than newline
17:55:25 <magnus-> let me check exactly what I had typed
17:55:52 <magnus-> oh, it's a type error?
17:55:56 <lispy> yeah
17:56:07 <lispy> so maybe i need to ignore the return of newline
17:56:16 <magnus-> newline >> return ()
17:56:56 <lispy> right
17:57:10 <lispy> eol = newline >> return () <|> eof
17:57:38 <magnus-> yeah
17:57:49 <magnus-> I don't know the precedence of >> vs <|> but it looks right
17:58:01 <lispy> yeah, i had to add parens
17:58:12 <lispy> haven't tested yet, but i think this will work
17:58:43 <lispy> ah, perefct
17:58:55 <lispy> now i don't have to worry about pesky lack of newline
17:59:04 <magnus-> :)
17:59:11 <magnus-> Parsec is so nice to use
17:59:15 <lispy> indeed
17:59:24 <lispy> i worry about leaving out trys
17:59:28 <lispy> but otherwise i'm very happy with it
18:00:07 <magnus-> It's good if you can avoid it
18:00:21 <magnus-> avoid using try
18:01:01 <lispy> well, i find that i don't always understand when i need it, so sometimes it's missing and i hit a buggy 'corner' case :)
18:01:53 <magnus-> amen to that :)
18:04:00 <magnus-> !url buddah
18:04:15 <magnus-> !where buddah
18:04:25 <lispy> ?url buddah
18:04:26 <lambdabot> I know nothing about buddah.
18:04:35 <magnus-> can't find it on google
18:04:40 <magnus-> I only see it mentioned
18:04:42 <justmikeeh> PAYPAL ACCEPTED! MUST GO NOW! 1 dell xps m1710 laptop for 600$ (4 512mb Nvidia 7900 Geforce pcie$300 each , 2 OCZ 2GB DDR2 ram$250, 2 AMD athlon 64 FX-60 processor $300 each and 2 Asus motherboards 150 each Prices include shipipng and paypal is accepted.  message me if interested on aim at laptopmike1981 or msn at thisisjustmike@telusmail.net paypal accepted
18:05:01 <lispy> magnus-: http://www.cs.mu.oz.au/~bjpop/buddha/
18:05:02 <lambdabot> Title: A declarative debugger for Haskell 98
18:05:20 <lispy> magnus-: yeah, i had to google declarative debugger haskell
18:05:24 <magnus-> ah you spelled it wrong :P
18:05:30 <lispy> Oh
18:05:36 * lispy is a terrible spellur
18:05:43 <magnus-> np
18:07:47 <magnus-> is haskell.org down?
18:08:05 <lispy> yes
18:08:11 * lispy points at the topic :)
18:08:17 <lispy> we don't know why
18:08:20 <lispy> it just is :(
18:09:57 <sjanssen> I did it
18:11:38 * lispy chases sjanssen around with a spoon
18:12:16 <magnus-> They must be launching haskell prime
18:12:27 <sjanssen> ha
18:12:29 <lispy> ?undo do x <- p; spaces; return r
18:12:29 <lambdabot> p >>= \ x -> spaces >> return r
18:12:36 <lispy> ?. pl undo do x <- p; spaces; return r
18:12:36 <lambdabot> p >> (spaces >> return r)
18:12:49 <lispy> ?. pl undo do x <- p; spaces; return x
18:12:49 <lambdabot> (spaces >>) . return =<< p
18:21:32 <jtoy_> anyone have the link for the comic that shows what happens when developing software, everyone has a different point of view
18:47:22 <wkh> planet haskell works fine for me btw
19:00:02 <dons> hmmm. do the admins know that haskell.org is down?
19:14:17 <lispy> dons: probably not
19:14:22 <lispy> dons: how do you contact them?
19:15:04 <glguy> use the red phone
19:16:51 <Cale> IT'S A TRAP
19:20:47 <dons> argh, and so the mailing list is also down.
19:20:54 <araujo> hi hi!
19:20:55 <jgrimes> =/
19:21:04 <araujo> h.o still down?
19:21:07 <araujo> :-(
19:21:11 <dons> and just when the new tut was hot on reddit. boo :/
19:21:23 <jgrimes> bad timing
19:21:28 <jgrimes> anyone got a mirror?
19:21:33 <glguy> reddit took down h.o
19:21:34 <glguy> ?
19:21:47 <dons> hmm. no?
19:21:48 <araujo> somebody let know to the admin?
19:21:50 <dolio> It's been down since this morning.
19:21:59 <dons> it was only about 20 hits a minute from reddit
19:22:20 <dons> and it was handling that fine for several hours
19:22:23 <dolio> Then again, the new tutorial's been on reddit since this morning, at least.
19:22:41 <dons> yeah, its been up fro 18 hrs, but haskell.orgs been down for the last 8 of those
19:22:42 <dolio> So evidently the outage hasn't affected its hotness that much.
19:22:51 * araujo didn't know about that tutorial.
19:23:00 <dons> well, it has a lot more 'down votes now :/
19:23:08 <dolio> You don't even need to read a haskell story to know it's good. :)
19:23:09 <dons> it was 1/5 down before, now its getting closer to 1/2
19:23:26 <glguy> Are people saying why they are down voting it in the comments?
19:23:45 <dons> http://programming.reddit.com/info/jgbf/details
19:23:48 <lambdabot> Title: Simple Unix Tools in Elegant Haskell (reddit.com), http://tinyurl.com/fhzw5
19:24:07 <dons> just usual silly comments you'd expect from random humans
19:24:41 <araujo> argh ....
19:24:47 <glguy> wow, they really latched on to the "Elegant" title
19:24:48 <araujo> yeah, just saw it
19:25:16 <dons> seems like a provocative title is the way to get viewers
19:25:21 <dons> don't mention 'Monad'
19:25:32 <glguy> Wow... reddit is definitely not a programming site
19:25:35 <dons> just say "Make your code faster", "Simpler, better, good"
19:25:36 <dons> :)
19:26:23 <dons> it ain't no LtU that' for sure
19:26:24 <araujo> it is a pretty much a mixed site
19:26:51 <jgrimes> it gets pretty political at times
19:26:53 <araujo> geez, want to read that article for sure, anybody got it mirrored?
19:26:59 <dons> I feel kind of lost without haskell.org
19:27:03 <dons> araujo: yeah, let me find the link
19:27:10 <dons> not the full link, just the src.
19:27:10 <glguy> Hmm, time to start learning Clean I guess...
19:27:26 <dons> all it was was: http://planet.haskell.org/
19:27:28 <lambdabot> Title: Planet Haskell
19:27:29 <dons> grr. not that
19:27:32 <dons> http://www.cse.unsw.edu.au/~dons/data/Basics.html
19:27:34 <lambdabot> Title: Haskell Unix Tools, http://tinyurl.com/zq2lk
19:27:34 <dons> ah
19:28:03 <dons> just a quick hack. but there you go, the masses love it when its simple
19:29:03 <dons> i feel kind of adrift without haskell.org. please Galois Admins in the Sky, bring it back!
19:29:05 <araujo> dons, thanks!
19:29:22 <araujo> yeah,h.o down is not good :-(
19:29:41 <Thomas2_> dons: see that big light in the sky? that tells you it's time to stop worrying about haskell.org and go to the beach
19:29:56 <glguy> I just checked, it's still down
19:30:00 <glguy> (c:
19:30:10 <dons> Thomas2_: good idea!
19:30:21 <dolio> Wow, I can see what that guy was saying about all those $ and @. Who could ever read code like this? :)
19:30:29 <dons> 12:29  dons:: ?temp
19:30:30 <dons> 12:30  lambdabot::  now 24.3Â°
19:30:36 <dons> hmm. feels hotter than that
19:30:44 <glguy> He probably thinks that the $ are some kind of perl magic
19:30:44 <Thomas2_> i usually take net outages as a sign from the gods that it's time to not be working
19:30:57 <Thomas2_> dons: i think the shade/sun temperatures might be out of sync
19:31:03 <glguy> The internet has only one god!
19:31:09 <Thomas2_> it's just getting hot now
19:31:49 <dons> maybe I should have used 'box' for '$ (:[]) .'
19:32:16 <glguy> or maybe return?
19:32:24 <dons> ah.. good idea
19:32:32 <glguy> ludites can deal with return
19:32:38 <araujo> yeah, was thinking about return too
19:32:46 <glguy> they won't know why it works, but they don't know what (:[]) works either
19:32:50 <Thomas2_> argh, nooo ...
19:33:10 <Cale> Thomas2_: hm?
19:33:26 <glguy> is it ironic that "sellout" has "quit"?
19:33:36 <araujo> join = input . return . concat
19:33:42 <araujo> probably?!
19:33:42 <Thomas2_> I really don't understand how fl people think that running the omega algorithm in your head to deduce that this particular fragment typed as "Maybe x" and thus liftM has *those* semantics is somehow intuitive
19:33:59 <Thomas2_> ditto return, fail
19:34:18 <glguy> ?
19:34:20 <Cale> Thomas2_: hm?
19:34:31 <Cale> return on lists is (\x -> [x])
19:34:35 <Cale> that's all there is to is :)
19:34:38 <Cale> it*
19:34:39 <Thomas2_> yeah, I know
19:34:46 <glguy> Thomas2_: you don't like that Monad semantics vary based on how they are implemented?
19:35:06 <Thomas2_> but I've seen code in huge chunks of *another* monad which can only be understood when you realise how Maybe behaves
19:35:24 <Cale> hmm
19:35:29 <Thomas2_> (and that that particular line typed as Maybe anyhow, which is usually invisible information)
19:35:31 <Cale> Like, they're using Maybe locally?
19:35:46 <araujo> Plus I don't understand why he uses the quicksort example when the whole point of Haskel (according to the article) is that you don't care about the procedural aspect of things.
19:35:50 <araujo> wt?!
19:36:10 <glguy> araujo: we've already established that the people that felt the need to comment shouldn't have children ;)
19:36:13 <Thomas2_> right at the end, return $ f (liftM t x) (liftM t y)
19:36:19 <dolio> Obivously only procedural people need to sort things. :)
19:36:21 <Cale> Thomas2_: It's rather like how you use + with integers and floats, and it's not that much of a problem, even though they're implemented really differently
19:36:29 <Thomas2_> where f, t are some constants and x, y came out of the monad earlier
19:36:36 <Thomas2_> Cale: no, it's not. the semantics change entirely
19:36:44 <Cale> They change with + too
19:37:16 <Thomas2_> if you realise all the examples we care about embed in some subset of some modulo of the complex numbers, no they don't
19:37:32 <Cale> But most of the same properties are satisfied, which is what makes it manageable
19:37:34 <dons> ok, I cleaned it up a bit, http://www.cse.unsw.edu.au/~dons/data/Basics.html
19:37:35 <lambdabot> Title: Haskell Unix Tools, http://tinyurl.com/zq2lk
19:37:38 <araujo> > (return 1 :: [Int]) == ((: []) 1)
19:37:40 <lambdabot>  True
19:37:52 <Cale> Thomas2_: polynomials, matrices
19:38:07 <Thomas2_> Cale: both vector fields
19:38:10 <dons> ?check \x -> return x == (:[]) (x::String)
19:38:12 <lambdabot>  OK, passed 500 tests.
19:38:18 <Thomas2_> until you want to talk about '*' in the same breath
19:38:20 <araujo> dons, nice
19:38:23 <Cale> vector spaces, you mean
19:38:37 <Cale> they're more than that though, they're rings
19:38:46 <Cale> (which makes them algebras)
19:38:54 <Thomas2_> erm, yeah, s/fields/spaces/
19:39:06 <lispy> > (`map [1..10]) $ ((*)`join`) -- me thinks this is illustrative haskell ;)
19:39:06 <lambdabot>  Parse error
19:39:08 <Cale> but here, we have two things which are both monads
19:39:09 <lispy> oops
19:39:16 <lispy> > (`map` [1..10]) $ ((*)`join`) -- me thinks this is illustrative haskell ;)
19:39:17 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:39:19 <Cale> so they behave reasonably similarly
19:39:42 <Cale> > (`map` [1..10]) $ (join (*))
19:39:44 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:39:47 <lispy> it should be very clear to anyone how that function works :)
19:39:49 <Cale> > (`map` [1..10]) (join (*))
19:39:51 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:40:16 <Cale> > map (join (*)) [1..10]
19:40:17 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:40:30 <lispy> > map (\i -> i * x) [1..10]
19:40:31 <lambdabot>  Not in scope: `x'
19:40:35 <lispy> > map (\i -> i * i) [1..10]
19:40:36 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
19:40:38 <lispy> lol, i can't type
19:41:02 <glguy> Doesn't this all boil down to the fact that the Monad class simply describes a type of computation
19:41:04 <Cale> join in the reader instance is handy
19:41:22 <glguy> and sometimes its necessary to know what that method of computation is
19:41:27 <glguy> and osme times it isn't
19:41:32 <Cale> Well, of course.
19:43:43 <Cale> Sometimes if you have a computation which acts on things of a monadic type, you can get some really crazy code reuse happening.
19:45:08 <glguy> with the obvious examples including things like join
19:45:43 <Cale> For example, in nymphaea, the L-System generator, the input rules are parametrised over monad, where the identity monad results in deterministic L-systems, the list monad gives nondeterministic systems where all results are computed, the Random monad can be used to describe nondeterministic L-systems which give you a random result, with weighted rule application
19:47:04 <Cale> and the code to expand the system is the same regardless -- it's just the input type which is changing
19:47:19 * edwardk_ waves hello.
19:47:25 <Cale> hi
19:47:27 <jgrimes> has anyone here looked at Brisk, from University of Bristol?
19:47:39 <glguy> hi
19:47:47 * edwardk_ just realized he left his power supply in Las Vegas on the flight back =/
19:47:56 <dons> jgrimes: well, I know it had one release about 10 years ago
19:48:00 <glguy> At least you get to go back to Las Vegas
19:48:04 <edwardk_> heh
19:48:06 <glguy> did you have fun the first time? (c:
19:48:06 <edwardk_> I wish
19:48:16 <edwardk_> yeah
19:48:19 <jgrimes> dons, yeah, the page was updated last in '99
19:48:31 <edwardk_> made $500 on my return trip. paid for my conference almost ;)
19:48:40 <glguy> did you give up your seat?
19:48:53 <edwardk_> no, there were slot machines in the airport
19:49:03 <glguy> oh, sweet
19:49:41 * Korollary censors himself from saying something crass
19:50:11 <Korollary> Two more surgeries and I will be rid of this damn conscience.
19:50:20 <edwardk_> dropped $20 in some 'star wars' themed slot machine, and kept playing off what I won initially. Killed time quite well.
19:50:26 * glguy cencors himself from saying something crass
19:50:36 <glguy> or rather snide
19:50:40 <edwardk_> ?
19:51:09 <glguy> I've gone gambling once on the river boats
19:51:10 <Korollary> It's friday night. Naturally I want to hear swearing and sniff bodily fluids in the air.
19:51:12 <edwardk_> I typically view gambling as a tax on people who are bad at math.
19:51:14 <glguy> lost $20
19:51:21 <glguy> but the alcohol was crazy cheap
19:51:24 <edwardk_> *nods*
19:51:41 <edwardk_> yeah. If you view it as a social occasion, and figure that you are spending money appropriately, its fine.
19:51:45 <Korollary> You don't have to be good at math. Casinos openly declare the return rate to your face.
19:51:50 <edwardk_> hehehe
19:51:51 <edwardk_> yeah
19:51:53 <glguy> we saved money going to the casino and gambling 20$ between the 3 of us
19:52:05 <wkh> edwardk_: i generally think the same thing but apparently there are techniques you can use in some of the games to make the odds nearly even so if you like the feeeling of being at the table, it can be worth it
19:52:11 <edwardk_> well, I usually think of it as such in the face of lottery tickets and such.
19:52:12 <wkh> personally i don't/wouldn't
19:52:45 <glguy> Going to the casino was just fun, but I can see the lottery being an idiot tax
19:52:52 <wkh> yeah
19:52:52 <edwardk_> wkh: sure, you can play craps and consistently bet the don't, or 'count cards' which if done poorly is actually to the house's advantage etc. ;)
19:53:19 <wkh> i thought they watch for card counters
19:53:22 <Korollary> Casinos are fun because you can laugh at freaks who play till 5am.
19:53:26 <edwardk_> they do
19:53:40 <wkh> did you ever read the book Eudaemonic Pie?
19:53:49 <edwardk_> but really for the most part they don't care, because view people have the head for statistics needed to actually do it right
19:53:55 <edwardk_> er few people
19:53:57 <wkh> pretty clever, kind of like the more recent one Bringing Down the House
19:54:02 <glguy> My boss recently went to Vegas, gambled enough to get free hotel stay and food, and won enough money to make the trip free
19:54:33 <wkh> glguy: maybe that guy will tell his friends who aren't so smart he had a great time and they'll go and give the casino lots of their money
19:54:54 <edwardk_> *nods*
19:54:59 <edwardk_> its a good racket.
19:55:06 <glguy> most business is
19:55:29 <edwardk_> So, I guess I made enough money in vegas to pay for the power cord I lost either there or on the flight back from there.
19:55:35 <edwardk_> but still its annoying =)
19:56:03 * edwardk_ is stuck computing on his rickety old laptop in the meantime
19:56:25 <glguy> how old and rickety is your rickety old laptop?
19:56:50 <edwardk_> 2 years. the rickety part has to do with the hinges that I need to get fixed. I was going to ship it back and just hadn't gotten around to it.
19:57:17 <glguy> anyone here played the ESP Game?
19:57:20 <edwardk_> I think technically this one has a faster video card in it than my current laptop. Just about 1/3rd of the storage space and a 1/5th of the ram.
19:57:24 <edwardk_> ESP/
19:57:36 <Korollary> I read minds regularly
19:59:25 <glguy> I hate politicians, marketing people, and lawyers...
20:00:11 <lispy> edwardk_: hey, how goes?
20:00:29 <glguy> hmm, did anyone else notice that haskell.org was down?
20:00:37 * lispy points glguy to the topic
20:00:47 * glguy points lispy to lastlog
20:00:47 <edwardk_> heya lispy, not bad, lost my power supply on the flight back, just noticed. otherwise good.
20:01:46 <lispy> edwardk_: dang :(
20:02:42 <edwardk_> but, won enough in vegas on the return trip to be able to buy a new one, so it all balances out.
20:05:18 <lispy> haha
20:05:24 <lispy> edwardk_: you went to vegas on the way back?
20:05:35 <lispy> that's funny
20:05:36 <edwardk_> I wound up with a 2 hour layover in vegas
20:06:10 <edwardk_> So I tossed $20 in a slot machine and kept playing with half of the winnings repeatedly
20:06:14 <lispy> i was in st. louis once and i bet at a casino...won about $30 and the next morning i read in the paper they declared bankruptcy...that was funny
20:06:20 <lispy> cool
20:07:21 <edwardk_> Did you have fun at the conference?
20:07:38 <Korollary> 72 Pens for $4 @ OfficeDepot. Yay.
20:07:50 <lispy> edwardk_: yeah, although, i didn't go to much of it other than the workshop
20:07:58 <edwardk_> *nods*
20:07:59 <lispy> but it was a really good experience
20:08:14 <lispy> Korollary: the strangest things make you happy :)
20:08:37 <edwardk_> I wish I would have gone to one of these a year ago. Of course, I probably would have had to care about functional programming and such then =)
20:08:44 <glguy> lispy: Korollary seems to have a parently or something with a gambling problem
20:08:57 <glguy> or something to that effect ;)
20:09:21 <lispy> edwardk_: heh
20:09:36 * lispy has been into FP since he took an ai class where they 'forced' lisp on us
20:09:50 <lispy> you may have guessed that i found i liked lisp :)
20:10:00 <edwardk_> I learned LISP forever ago, just never saw the point of using it =)
20:10:26 <edwardk_> I did discover that I kind of liked scheme though
20:10:57 <Korollary> I wrote a while statement in scheme today. Felt dirty.
20:11:08 <edwardk_> hehe
20:11:15 <lispy> Korollary: heh
20:11:33 <lispy> looping in lisp was always odd...i *had* to have the manual at hand
20:11:37 <lispy> loop is so complex
20:11:40 <glguy> I like Scheme in the way that I like 2D
20:12:34 <edwardk_> the lang from the icfp contest? =)
20:12:38 <glguy> yeah
20:12:44 <glguy> both are fun to program in
20:12:50 <glguy> but I consider them a novelty
20:12:52 <edwardk_> heh the google folks named that as their language this year =)
20:12:59 <glguy> yup (c:
20:13:40 <Korollary> Those smileys are considered from southern hemisphere.
20:13:42 <glguy> Lisp is ugly, (and I'm not talking about the sexps) but it's more functional (useful) than Scheme is (in my limited opinion)
20:14:06 <lispy> the CL spec is gross
20:14:12 <glguy> but Scheme appeals to me in how clean it is
20:14:17 <Korollary> r5rs is tiny.
20:14:25 <lispy> CL implementations tend to be faster than scheme too
20:14:27 <edwardk_> got to sit right behind them at the awards. talked to them after. apparently their membership consists of half of  the team smartass from last year and half new folks
20:14:28 <Korollary> but modern distros have large libs
20:15:01 <lispy> yeah, lisp code tends to take tons of memory too because you have a full interpreter running
20:15:02 <edwardk_> they did write one of their tools in haskell, i think their adventure theorem prover.
20:15:08 <glguy> I liked writing individual algorithms in scheme, but I wouldn't want to write applications in it
20:15:40 <edwardk_> scheme is fine once you build up enough define-syntax macros to build your DSL.
20:15:49 <edwardk_> until then its fairly useless
20:15:52 <Korollary> not everything needs a dsl
20:16:22 <edwardk_> yeah, admittedly, it just seems that everything you develop in scheme turns into one. or maybe thats just how I write scheme.
20:17:03 <Korollary> hammer detected.
20:17:07 * lispy agrees with edwardk_
20:17:11 <edwardk_> kor: hehehe
20:17:13 <lispy> why is a DSL a hammer?
20:17:36 * edwardk_ puts down the hammer and backs away from template haskell.
20:17:37 <Adamant> because when you have a hammer, every problem looks like a nail
20:18:02 * lispy closes his eyes when he has a hammer ;)
20:18:07 <lispy> i just thrash
20:18:24 <Korollary> Speak softly and drive a tank, eh?
20:18:29 * edwardk_ reminds himself to never hand lispy a hammer.
20:18:39 <Adamant> is tunes ever going to write an OS kernel?
20:19:16 * lispy goes searching for a hammer
20:19:20 <lispy> hammer time!
20:19:23 <dons> hehe
20:19:27 <Adamant> if I had a hammer
20:19:28 * lispy does the hammer dance into the next room
20:19:32 <Adamant> I'd hammer in the morn
20:19:35 <glguy> STOP!
20:19:43 <weitzman> Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
20:19:45 <Adamant> Hammer Time?
20:19:50 <glguy> :)
20:20:02 <edwardk_> heh
20:20:06 <lispy> weitzman: nice
20:20:29 <lispy> ?remember weitzman Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
20:20:46 * lispy pokes lambdabot 
20:20:47 <Adamant> why would you with a hammer on Polish Diningware?
20:20:54 <lispy> ?vixen did you get that?
20:20:54 <lambdabot> i'll hafta plead the fifth on that one.
20:20:57 <weitzman> We Java apologists need to make up excuses
20:21:29 <Korollary> @botsmack
20:21:29 <lambdabot> :)
20:21:42 <Adamant> @. elite brain
20:21:43 <lambdabot> i 7|-|iNK $O, bR4in! But D0 i H4Ve \/\/HAT iT TAKe TO b3 7H3 'LOrD 0ph tHe d4nc3'?
20:22:08 <Adamant> hmm, needs more randomness
20:22:36 <Adamant> I think I got the same reponse yesterday.
20:22:39 <Korollary> No, you're just inherently l33t and can read it easily. To us mortals, it's illegible.
20:22:46 <Adamant> not that
20:22:48 <dons> can someone go to galois and reboot haskell.org?
20:22:51 <Adamant> the phrase
20:23:05 <glguy> is galois a person or a place?
20:23:06 <lispy> dons: say the magic words
20:23:17 <lispy> dons: hm.m..syntaxninja was here earlier when it was down
20:23:22 <Korollary> breaking and entering?
20:23:23 <Adamant> SQUEAMISH OSSIFRAGE?
20:23:31 <lispy> dons: after that the server with cabal on it came back up
20:23:52 <dons> oh hmm. the cabal server also went down?
20:23:59 <dons> I wonder, did they have a power failure?
20:24:01 <lispy> dons: i think so
20:24:13 <glguy> Maybe the Java people attacked it!
20:24:15 <lispy> dons: either that or it timedout from being busy :)
20:24:24 * weitzman whistles nonchalantly
20:24:39 <dons> glguy: galois.com, haskell company
20:24:50 <dons> well the galois site is up...
20:25:18 <araujo> dons, that could be a nice idea for a busybox-like shell .....
20:25:36 <dons> araujo: hmm?
20:25:42 <dons> afternoon foxy
20:25:54 <araujo> dons, about the Unix Haskell tools.
20:25:59 <dons> ah
20:26:14 <dons> araujo: did you see, I tweaked it some more. any comments http://www.cse.unsw.edu.au/~dons/data/Basics.html
20:26:15 <lambdabot> Title: Haskell Unix Tools, http://tinyurl.com/zq2lk
20:26:17 <dons> or any I should add?
20:26:33 <araujo> I just saw your changes about 'return' ..
20:26:36 <araujo> i am checking
20:26:58 <dons> then I replaced 'input' with 'io' (from lambdabot)
20:27:21 <glguy> dons: I'm surprised that none of the brains commenting on reddit didn't notice the lack of variables
20:27:26 <glguy> well, i guess I'm not surprised
20:27:27 <dons> heh
20:27:29 <glguy> but kind of
20:27:35 <araujo> oh, yeah, i noticed that change too
20:27:45 <dons> yeah, there's a bit of a lack of analysis, eh, glguy ?
20:27:57 <glguy> I don't think that they got past "elegant"
20:28:01 <glguy> and '$'
20:28:11 <glguy> all of those "english words" were lost
20:28:18 <Korollary> Who cares
20:28:21 <dons> one guy seems to have clicked on the 'why haskell matters page' and commented on that instead
20:28:25 <dons> (the stuff about qsort)
20:28:35 <glguy> yeah... that's awesome
20:28:50 <glguy> "I thought that only people that wrote procedural programs sort things"
20:28:59 <dons> that's so cool
20:29:10 <glguy> maybe he's lightyears ahead of us
20:29:14 <dons> here in haskell land, we just make it so!
20:29:24 <dons> our data is always sorted
20:29:31 <glguy> maybe sorting really is a relic of the procedural word
20:29:33 <glguy> world
20:29:45 <int-e> I'm sorting all the time.
20:29:57 <glguy> sounds like you are stuck in the past...
20:30:08 <araujo> That was such an ignorant comment.
20:30:15 <glguy> heh, mine?
20:30:25 <araujo> The qsort comment
20:30:30 <glguy> ;)
20:30:32 <dons> its funny
20:31:09 <dons> since in non-imperative languages apparently we don't "do" things to data -- that would be procedural
20:31:19 <int-e> glguy: I know, the modern answer is 'put your data into a database and let that deal with it.'
20:32:01 <glguy> how is sort actually implemented in GHC? mergesort?
20:32:05 <int-e> yes.
20:32:15 <int-e> and it's a neat algorithm
20:32:24 <glguy> ?fptools sort
20:32:24 <lambdabot> sort not available
20:32:30 <glguy> ?index sort
20:32:30 <lambdabot> Data.List
20:32:34 <glguy> ?fptools Data.List
20:32:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
20:32:46 <lispy> we use a lot of qsort in our C code at work
20:32:48 <dons> ?source Data.List
20:32:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
20:32:56 <lispy> which sort of surprised me
20:32:56 <dons> ?users #haskell
20:33:06 <lambdabot> Maximum users seen in #haskell: 238, currently: 207 (87.0%), active: 22 (10.6%)
20:33:07 <glguy> the in-place qsort is pretty efficient
20:33:17 <araujo> And if you ask me, we in the FP world are almost always ordering data/functions
20:33:25 <int-e> but quicksort is a bad choice for linked lists.
20:33:29 <glguy> right
20:33:54 * araujo points the importance of Lists in FP
20:33:58 <lispy> araujo: yeah, i've written code to call a sort function in a non functional language a few times outside of school work
20:34:03 <lispy> araujo: but i do it a LOT in haskell
20:34:16 <araujo> lispy, indeed
20:34:18 <araujo> me too.
20:34:36 <glguy> merge sort allows for constant factor space complexity against the size of the data... right?
20:34:41 <int-e> glguy: there are two interesting things to note about that merge sort: 1) head . sort  is actually O(n) in time (where n is the list length) 2) it's a stable sort.
20:35:13 <lispy> why is stable sort a good thing?
20:35:18 <lispy> incase you sort twice?
20:35:23 <int-e> yes
20:36:15 <hyrax42> what algorithm does the built in sort use
20:36:22 <int-e> hyrax42: merge sort.
20:36:25 <hyrax42> oh ok
20:36:30 <hyrax42> that's cool
20:36:35 <hyrax42> I often wondered about head . sort
20:36:42 <int-e> (at least in ghc. what about hugs?)
20:36:46 <hyrax42> beign equivalent or not to maximum
20:36:54 <glguy> minimum
20:37:05 <int-e> hyrax42: if your Ord instance is a partial ordering (as it should be), the two are equivalent.
20:37:06 <hyrax42> oh
20:37:14 <int-e> minimum, yes.
20:37:30 <glguy> maximum = head . sortBy (flip compare) (c:
20:37:33 <hyrax42> head . (sortBy (flip compare))
20:37:33 <lispy> i was writing a spec today where i have to put strings in a database field and another tool has to read them...the strings are basically type names.  I started to think, oh it doesn't matter if the strings have spaces or mixed caps.  Then i realized how hard taht would be to deal with in, say C.
20:37:36 <hyrax42> yeah
20:37:38 <int-e> hyrax42: if your Ord instance lies, there are subtle differences.
20:37:55 <hyrax42> ok that's cool
20:37:57 <lispy> i was thinking in haskell where you filter then map toLower and you have a 'cannonical' name
20:38:05 <hyrax42> I was thinking of that just yesterday
20:38:21 <int-e> > let cmp (a,_) (_,b) = compare a b; list = [(1,1),(1,1),(0,1),(1,0)] in (head $ Data.List.sortBy cmp list, Data.List.minimumBy cmp list)
20:38:21 <int-e> 00:07:45 <lambdabot> ((1,1),(1,0))
20:38:22 <hyrax42> laziness ftw
20:38:23 <lambdabot>  ((1,1),(1,0))
20:38:31 <dons> ?uptime
20:38:32 <lambdabot> uptime: 22h 10m 6s, longest uptime: 2d 8h 20m 7s
20:38:44 <int-e> That's one bad example. The 'compare' isn't a partial ordering.
20:38:53 <int-e> err, the cmp
20:39:07 <int-e> so sort and minimum have different results.
20:39:44 <int-e> lispy: that's also a feature of stable sorts btw
20:39:48 <hyrax42> ugh
20:40:03 <lispy> int-e: ah
20:40:11 <lispy> int-e: yes, i think i see
20:40:41 <hyrax42> so that fails on more or less every requirement of a partial order
20:40:41 <hyrax42> right
20:40:42 <hyrax42> ?
20:40:59 <hyrax42> def not transitive or antisymmetric
20:41:17 <hyrax42> or reflexive either for that matter
20:41:22 <glguy> Prelude definition of sort:
20:41:22 <lispy> one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures :)
20:41:23 <glguy> sortBy cmp = foldr (insertBy cmp) []
20:41:44 <weitzman> > sortBy (const (const False)) [1..10]
20:41:45 <lambdabot>  Couldn't match `Ordering' against `Bool'
20:41:54 <weitzman> > sortBy (const (const LT)) [1..10]
20:41:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:42:01 <dons> ?remember lispy one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
20:42:31 <lispy> :)
20:42:35 <glguy> streams ftw
20:42:37 <int-e> > sortBy (const (const GT)) [1..10] -- should revert, I think
20:42:39 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
20:42:51 <int-e> reverse
20:42:51 <hyrax42> sort = sortBy compare?
20:42:57 <int-e> hyrax42: yes
20:42:57 <glguy> hyrax42: yeah
20:43:14 * araujo feels impotent without haskell.org
20:43:48 <weitzman> @check (==) (sortBy (const (const GT))) reverse :: [Int] -> Bool
20:43:49 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: [Int] -...
20:43:54 <hyrax42> wait won't that be insertion sort?
20:44:13 <weitzman> @check liftM2 (==) (sortBy (const (const GT))) reverse :: [Int] -> Bool
20:44:14 <int-e> hyrax42: not necessarily.
20:44:14 <lambdabot>  OK, passed 500 tests.
20:44:23 <weitzman> @scheck liftM2 (==) (sortBy (const (const GT))) reverse :: [Int] -> Bool
20:44:23 <glguy> the sort that I pasted was
20:44:28 <lambdabot>  Completed 623530 test(s) without failure.
20:44:33 <weitzman> Wowzers
20:44:52 <weitzman> Now that's what I call testing
20:45:01 <hyrax42> wo
20:45:03 <hyrax42> what is scheck
20:45:08 <weitzman> I have no idea
20:45:12 <glguy> @check liftM2 (==) sort (foldr insert []) :: [Int] -> Bool
20:45:13 <lambdabot>  OK, passed 500 tests.
20:45:15 <int-e> SmallCheck
20:45:27 <hyrax42> @type insert
20:45:28 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
20:45:34 <lispy> hyrax42: small check doesn't try random values, it tries to test exhaustively by enumerating all the values
20:45:36 <hyrax42> ok how is foldr insert []
20:45:40 <lispy> hyrax42: starting with the smallest ones
20:45:42 <hyrax42> not an inswsertion sort
20:45:47 <hyrax42> ah cool
20:45:48 <int-e> It tests small examples - in this case, short lists with small integers - exhaustively.
20:45:49 <weitzman> I don't think smallcheck enumerated all possible lists
20:46:09 <lispy> right, it takes short cuts in some ways
20:46:15 <int-e> it increases the bounds for the int values to test gradually.
20:46:19 <lispy> for example, it's random number generator with lists is pathetic
20:46:23 <lispy> (but can be overridden)
20:46:31 <hyrax42> would any of those lists have had mor than one element?
20:46:43 <glguy> @scheck liftM2 (&&) ((<9).length) ((<9).maximum) :: [Int] -> Bool
20:46:44 <lambdabot>  Exception: Prelude.maximum: empty list
20:46:57 <weitzman> @scheck (> 1) . length :: [Int] -> Bool
20:46:58 <lambdabot>   Failed test no. 1. Test values follow.: []
20:47:02 <glguy> @scheck liftM2 (&&) ((<9).length) ((<9).maximum.(0:)) :: [Int] -> Bool
20:47:06 <lambdabot>  Completed 623530 test(s) without failure.
20:47:10 <weitzman> @scheck (< 1) . length :: [Int] -> Bool
20:47:11 <lambdabot>   Failed test no. 2. Test values follow.: [-1]
20:47:18 <weitzman>  @scheck (< 2) . length :: [Int] -> Bool
20:47:23 <glguy> @scheck liftM2 (&&) ((<8).length) ((<9).maximum.(0:)) :: [Int] -> Bool
20:47:24 <lambdabot>   Failed test no. 9. Test values follow.: [-1,-1,-1,-1,-1,-1,-1,-1]
20:47:27 <weitzman> @scheck (< 2) . length :: [Int] -> Bool
20:47:28 <lambdabot>   Failed test no. 3. Test values follow.: [-1,-1]
20:47:35 <glguy> @scheck liftM2 (&&) ((<9).length) ((<8).maximum.(0:)) :: [Int] -> Bool
20:47:38 <weitzman> That took me far to many tries
20:47:39 <lambdabot>  Completed 623530 test(s) without failure.
20:47:45 <glguy> @scheck liftM2 (&&) ((<9).length) ((<7).maximum.(0:)) :: [Int] -> Bool
20:47:48 <lambdabot>   Failed test no. 554250. Test values follow.: [7]
20:48:01 <glguy> it tests lists up to eight elements with values up to 7
20:48:05 <hyrax42> hahaa
20:48:06 <hyrax42> nice
20:48:12 <lispy> ?scheck \s -> maximum (s :: [Int]) < 10
20:48:13 <lambdabot>  Exception: Prelude.maximum: empty list
20:48:25 <glguy> lispy: that's why I .(0:) 'd mine
20:48:32 <lispy> ?scheck \s -> null s || maximum (s :: [Int]) < 10
20:48:35 <lambdabot>  Completed 623530 test(s) without failure.
20:48:47 <lispy> ?scheck \s -> null s || maximum (s :: [Int]) < 9
20:48:48 <hyrax42> ok but still
20:48:49 <hyrax42> how is
20:48:50 <lambdabot>  Completed 623530 test(s) without failure.
20:48:53 <glguy> ?check \xs -> (not . null) xs ==> length xs < 9
20:48:54 <lambdabot>  Add a type signature
20:48:55 <lispy> ?scheck \s -> null s || maximum (s :: [Int]) < 5
20:48:56 <hyrax42> sort = foldr insert []
20:48:56 <lambdabot>   Failed test no. 7426. Test values follow.: [-1,-1,5]
20:49:01 <hyrax42> not an insertion osrt
20:49:02 <glguy> ?check \xs -> (not . null) xs ==> length xs < 9 :: [Int] -> Bool
20:49:02 <int-e> ?scheck \s -> null s || last (s :: [Int]) + length s < 10
20:49:02 <lambdabot>    Expecting a function type, but found `Property'       Expected type: [In...
20:49:05 <lambdabot>  Completed 623530 test(s) without failure.
20:49:14 <glguy> ?check \xs -> (not . null) xs ==> length (xs::[Int]) < 9
20:49:15 <lambdabot>  Falsifiable, after 19 tests: [-7,7,-1,9,-10,-6,-8,1,-11]
20:49:22 <glguy> ?scheck \xs -> (not . null) xs ==> length (xs::[Int]) < 9
20:49:25 <lambdabot>  Completed 623530 test(s) without failure.  But 1 did not meet ==> condition.
20:49:25 <dons> araujo: I agree. I'm forced to actually do some work when haskell.org's not up
20:49:43 <int-e> ?scheck \s -> null s || last (s :: [Int]) + length s < 9
20:49:47 <lambdabot>  Completed 623530 test(s) without failure.
20:49:51 <hyrax42> @hoogle a
20:49:51 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
20:49:51 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
20:49:51 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
20:49:52 <int-e> ?scheck \s -> null s || last (s :: [Int]) + length s < 8
20:49:53 <lambdabot>   Failed test no. 10. Test values follow.: [-1,-1,-1,-1,-1,-1,-1,0]
20:50:13 <hyrax42> oh @hoogle doesn't contact cll hoogle remotely
20:50:15 <hyrax42> makes sense
20:50:22 <hyrax42> call
20:50:50 <hyrax42> dons, were you on the icfp winning team for the cops and robbers?
20:51:02 <int-e> ?scheck \s -> null (s :: [Int]) || minimum s >= (-1)
20:51:05 <lambdabot>  Completed 623530 test(s) without failure.
20:51:35 <int-e> that's a true shortcoming imho.
20:51:50 <araujo> dons, :-(
20:51:56 <araujo> dons, nobody knows what it is happening?
20:52:16 <glguy> this is worse than the lambdabot crash of 2006
20:52:32 <glguy> ~\o/~
20:52:50 <weitzman> Well, all least nobody has revolted and set up a competing haskell'.org
20:53:13 <glguy> i know, at least in the lambdabot crash of '06 a temporary replacement was installed
20:53:37 <lispy> weitzman: haha, funny you say that, someone needed to get a copy of cabal so i setup a temporary repository for them :)
20:54:02 <glguy> lispy: and you registered haskell'.org?
20:54:11 <dons> araujo: well the mailing list is also down.
20:54:15 <lispy> glguy: good ideas
20:54:21 <dons> and at list syntaxNinja knows about it (he's at galois)
20:54:25 * lispy runs a whois
20:54:36 <dons> we don't have haskell'.org.  we really should!
20:54:45 <dons> mirror mirror on the wall...
20:54:53 <glguy> and it's the weekend \o/ h.o could be down all weekend
20:54:55 <weitzman> Are primes even allowed in domain names?
20:55:02 <glguy> sadly no...
20:55:09 <glguy> I was kidding as usual
20:55:43 <lispy> whois.net just returns the results for haskell.org when i type that in
20:55:45 <lispy> :(
20:55:51 <araujo> dons, he reported it?
20:55:56 <weitzman> Shortsightedness has warped the sad word of file and resource naming
20:56:19 <weitzman> What's wrong with spaces and primes and unicode resource locators?
20:56:36 <glguy> the world runs on ASCII
20:56:37 <dmwit> They didn't exist?
20:57:01 <lispy> yeah i mean, why can't domain names have a '.' in them
20:57:07 <weitzman> The first the I do on any windows box is make a new home directory with no spaces in the path
20:57:08 <glguy> they can
20:57:16 <dons> what about the .de domains that have umlauts now?
20:57:23 <glguy> they do??
20:57:23 * lispy is not serious
20:57:26 <dons> do we get any useful characters there?
20:57:34 <dons> glguy: yes.
20:57:39 <lispy> haskell with an umlaut?
20:57:59 <dons> well, I'm wondering that maybe some other chars are also allowed
20:58:01 <glguy> dons: I can't think of a better way to make sure that most of the world won't go to your website
20:58:04 <lispy> is curry.org taken?
20:58:06 <dmwit> I think the umlaut ought to go over the 's'.
20:58:09 <dons> hehe
20:58:15 <glguy> lispy: by the indian food people?
20:58:17 <dons> haskell-prime.org ....
20:58:46 <glguy> goodlucktypingthisin.Ã³du
20:58:59 <lispy> fglasgow-exts.org is free
20:59:12 <glguy> lispy: -fglasgow-exts.org?
20:59:24 <glguy> did Gentoo users already get -O99.org?
20:59:41 <lispy> glguy: can't start with the -
20:59:43 <dons> mmm. -fglasgow-exts.org sounds fun.
20:59:50 * glguy * lispy is not serious
21:00:00 <dons> ghc-O2-funbox-strict-fields.org
21:00:12 <glguy> fun box... that's cute
21:00:20 <glguy> fun roll loops
21:00:27 <dons> funbox.org?
21:01:54 <glguy> what's the status of -fmonad-comprehensions?
21:04:09 <edwardk_> glguy: i talked to simon marlow, he said it was ok to write. i started banging one out, haven't had time to work on it since i returned from ICFP.
21:04:35 <glguy> edwardk_: how much needs to be changed?
21:04:50 <edwardk_> about 40 lines and i have to figure out how to add in the option for it.
21:04:58 <edwardk_> unless I missed something
21:05:13 <edwardk_> in which case it might be a lot harder
21:05:16 <glguy> what file? DsLispComp?
21:05:19 <edwardk_> yeah
21:05:34 <glguy> There appear to be two cases, did you modify both?
21:05:38 <glguy> or was one list specific
21:05:53 <edwardk_> one is parallel comprehension stuff
21:06:10 <glguy> dons: why doesn't lambdabot support parallel list comprehensions
21:06:35 <edwardk_> the question that igloo had that I wasn't able to answer was if the list monad sugar will fuse away
21:06:46 <dons> glguy: its a -fglasgow-exts, and we use a h98 parser to verify code before running it
21:06:54 <glguy> ah
21:06:57 <edwardk_> I wanted to do some tests of that before I ran ahead implementing it
21:07:05 <edwardk_> coz if it will, then it should be a pretty clean change
21:07:31 <glguy> parallel monad comprehensions... would that make sense in the general case?
21:08:03 <edwardk_> that was another question I had =)
21:08:24 <edwardk_> liftMn
21:08:25 <edwardk_> or ap
21:08:34 <edwardk_> hrmm
21:08:38 <glguy> true...
21:09:34 <glguy> wait
21:09:34 <glguy> no
21:09:38 <glguy> liftM2 doesn't do the same thing
21:10:00 <edwardk_> well, over a tuple
21:10:09 <glguy> hmm
21:10:24 <edwardk_> still playing with it
21:10:38 <edwardk_> i was in the process of trying to type it up as you asked =P
21:11:29 <edwardk_> [(x,y) | x <- a | y <- b] is zipWith (,) a b
21:11:31 <edwardk_> right?
21:12:09 <glguy> yeh
21:12:26 <glguy> but zipWith is list specific
21:12:33 <edwardk_> yeah i know =)
21:12:35 <dolio> > liftM2 (,) [1..5] [2..10]
21:12:36 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,2),(2,3),(2,4),(2...
21:12:56 <glguy> I know you know, but I'm trying to understand the general case :)
21:13:04 <edwardk_> heh
21:14:00 <edwardk_> i'm not sure there is a general case for monads
21:14:19 <dolio> There's really no particular m a -> m b -> m (a,b), is there?
21:15:19 <edwardk_> @type liftM2 (,)
21:15:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
21:15:24 <edwardk_> but it has the wrong meaning
21:15:25 <glguy> wouldn't parallel monad comprehensions just break their sequential nature?
21:15:39 <glguy> it would allow you to perform multiple operations on the same state
21:16:09 <edwardk_> yeah i don't think there exists a general parallel monad comprehension
21:16:28 <glguy> that would blow up in IO especially
21:17:07 <dolio> There's no parallel do notation either. :)
21:17:20 <glguy> then it's settled
21:17:22 <edwardk_> heh
21:17:23 <dolio> Or is there?
21:17:45 <glguy> I don't know of any
21:18:00 <edwardk_> mdo is as close as you get, and its not really the same thing
21:18:02 <lispy> what about unsafeInterleaveIO
21:18:10 <lispy> isn't that a parallel way to compose IO?
21:18:22 <edwardk_> lispy: now generalize to all monads ;)
21:18:41 <glguy> nothing "unsafe" is considered general
21:20:06 <edwardk_> I was just looking at patching the other case anyways
21:24:51 <edwardk_> If I could come up with some form of general monad class that admitted parallel list comprehensions i'd use it, but i can't think of any other than List off hand.
21:26:34 <dons> is the 'end' keyword in ruby used to work around the lack of layout?
21:27:03 <dolio> Basically.
21:27:09 <edwardk_> *nods*
21:27:16 <dons> it's _almost_ there, but they didn't quite get it
21:27:22 <edwardk_> heh
21:27:23 <dons> e.g.
21:27:23 <dons>   if word.length > max
21:27:24 <dons>     max = word.length
21:27:24 <dons>     puts "Words of length #{max}:"
21:27:24 <dons>   end
21:27:38 <dons> argh. you don't need that 'end'. fix the damn parser :)
21:27:53 <dons> nice to see newer languages adopting 2d layout though.
21:28:00 <MechaBlue> I don't think Ruby has a 2D layout, though
21:28:10 <dons> well, lack of ; anyway :)
21:28:46 <glguy> which languages outside the the C, C++, Java, C# class of languages use ;?
21:29:08 <dons> sed, optionally
21:29:16 <glguy> well, haskell does optionally
21:29:22 <dolio> Ruby uses it optionally.
21:29:25 <glguy> I can think of ObjC does
21:29:30 <glguy> but that's still C family
21:29:36 <glguy> does O'Caml?
21:29:38 <dolio> max = word.length ; puts "Words of length #{max}"
21:29:51 <edwardk_> pascal
21:30:14 <glguy> was pascal ever anything more than a toture instrument for highschool kids?
21:30:16 <dons> ocaml certainly has lots of ;
21:30:20 <edwardk_> yeah
21:30:38 <dolio> glguy: Heh. There's plenty of delphi solutions on mathschallenge. :)
21:30:51 <glguy> dolio: I thought it was one guy posting all of those :)
21:31:01 <dolio> There's at least two, I think.
21:31:12 <dolio> Unless that guy is posting multiple delphi solutions per problem.
21:31:20 <glguy> not unheard of :)
21:31:22 <dolio> Which I guess I wouldn't rule out.
21:31:24 <dolio> :)
21:31:41 <Selva_> python uses ;
21:31:49 <Selva_> optionally, of course
21:31:55 <edwardk_> javascript is in the optional ; camp strangely ;)
21:31:56 <glguy> the guy that writes the delphi solutions seems to write very fast, but verbose soloutions
21:31:59 <Selva_> ocaml uses ;;
21:32:12 <Selva_> that's two ;
21:32:14 <dolio> Yeah. They're rather opaque.
21:32:22 <glguy> ;; is something used in the interpreter ?
21:32:24 <dolio> No empty lines even.
21:33:03 <glguy> the delphi solutions should say this: I solved this in 145 unreadable lines of delphi in 0.3 seconds
21:33:07 <glguy> one line and they are good
21:33:36 <glguy> dolio: I'd argue that the J solutions are usually clearer
21:33:39 <glguy> (at least to me)
21:33:50 <dolio> Heh. I suppose they are if you know J.
21:34:05 <glguy> and what's the deal with people nesting 9 levels of for loops
21:34:06 <dolio> I need to get back to reading the paper so I can understand them.
21:34:26 <glguy> soooo ugly
21:34:39 <dolio> I imagine the J solutions are usually easy to understand, it's just that all the operators look like line noise if you don't know the language.
21:34:43 <dons> for a second there I though glguy was doing a seinfeld-for-geeks routine :)
21:35:10 <araujo> dons, http://arjox.org/ShC.hs
21:35:18 <araujo> To slightly prove my point
21:35:43 <dons> mmm :)
21:35:49 <dons> I posted some more as well
21:35:54 <glguy> lol
21:35:56 <dons> you might want to grab them http://www.cse.unsw.edu.au/~dons/data/Basics.html
21:35:58 <lambdabot> Title: Haskell Unix Tools, http://tinyurl.com/zq2lk
21:36:09 <dons> and run HsColour -css over the source
21:36:18 <dons> i.e. HsColor -css ShC.hs > ShC.html
21:36:31 <araujo> Ok, let's see
21:36:34 <dons> then link to the http://www.cse.unsw.edu.au/~dons/syntax.css file
21:36:50 <araujo> Ok, good.
21:37:08 <araujo> So that's a file we can (ab)use?
21:37:09 <araujo> :-)
21:37:45 <glguy> abuse it too much and dons might add body { content: "My website sucks" }
21:37:46 <glguy> ;)
21:40:35 <glguy> or rather: body:before { content: "whatever" }
21:43:22 <glguy> when run side by side... my UM VM runs faster than edwardk's
21:43:29 <glguy> but I might have not used the right -O flags
21:43:32 <glguy> for his
21:43:44 <glguy> (which some might not consider 'fair')
21:44:00 <edwardk_> -O3 should suffice for mine
21:44:12 <glguy> I'll recompile and give that a shot then
21:44:14 <int-e> what about -fomit-frame-pointer?
21:44:20 <edwardk_> yeah that too
21:44:23 <edwardk_> its been a while =)
21:44:30 <glguy> I know that mine should be slower, it's written in C#
21:44:42 <dolio> Dude, you need -ffast-math and -funroll-all-loops, too.
21:44:45 <foxy> join #lapack
21:44:52 <foxy> :(
21:44:57 <int-e> there's no floating point in that, dolio
21:45:06 <dolio> So?
21:45:15 <int-e> and -funroll-all-loops is questionable at best.
21:45:25 <edwardk_> no floating point. and -funroll-all-loops may not be a win. i'd have to recheck
21:45:27 <int-e> dolio: so -ffast-math has no effect whatsoever.
21:45:34 <dolio> Shhh! It adds 10 horsepower.
21:45:57 <glguy> with those two flags, edwardks gets a good lead
21:46:22 <edwardk_> woohoo =)
21:46:23 <dolio> unroll-all-loops is usually bad, from what I hear.
21:46:44 <glguy> anyone know if C# has optimization flags that should be turned on to compete?
21:47:58 <int-e> "This option makes code larger, and may or may not make it run faster." sums it up nicely
21:48:03 <int-e> (from gcc.info)
21:49:25 <int-e> dolio: -fomit-frame-pointer on the other hand is pretty much always a win on x86
21:49:30 <edwardk_> yeah
21:49:50 <int-e> frees a register, you get 7 instead of 6 to play with.
21:50:26 <edwardk_> 1 short of what you need for the UM in its entirety ;)
21:51:44 <glguy> adding the optimization flags to my C# um doesn't make it faster, but much more competitive
21:52:14 <int-e> glguy: you mean it makes it faster but still not as fast as the C one?
21:53:26 <araujo> dons, updated sir, http://arjox.org/ShC.html
21:53:58 <glguy> right
21:54:06 <glguy> I was on 28 when edwardk's finished
21:55:42 <int-e> that's not bad.
21:55:46 <ValarQ> good morning #haskell
21:56:46 <glguy> int-e: I bet that my biggest performance hit is that I can't just cast pointers to allocated arrays into uints
21:56:52 <glguy> and drop those into the register when I allocate
21:57:05 <dons> araujo: I'd ditch the 'module Main where' line, its not needed
21:57:19 <glguy> my current solution is to dump them into a Dictionary<uint, uint[]>
21:57:25 <dons> also, there seems to be some repeated lines?
21:57:53 <int-e> C# probably does bounds check.
21:57:57 <dons> araujo: but I like this single binary idea.
21:58:09 <dons> that might solve a problem in h4sh atm: too many binaries
21:58:30 <int-e> glguy: do you treat the 0 array specially?
21:59:23 <araujo> dons, yes, i think that's a nice idea ....
21:59:24 <int-e> glguy: regardless, yes, a dictionary instead of a plain array should hurt.
21:59:40 <glguy> int-e: yeah, i maintain a special reference to arrays[0]
21:59:46 <glguy> int-e: so that I don't have ot look it up all the time
22:00:45 <glguy> int-e: I considered creating a stack of array ids, and using them as I allocate new arrays and pushing them back when I'm done
22:00:58 <glguy> so that I could fill an array of arrays
22:01:06 <glguy> insteaad of trying to figure out where to put new allocations
22:02:06 <araujo> ok, updated again ...
22:02:17 * araujo forgot a function
22:02:18 <int-e> glguy: my C version does that (for what it's worth, so did all my haskell versions)
22:03:12 <glguy> int-e: did you find any particular safe upperbound for the number of concurrent allocations?
22:03:25 <glguy> or do you just increase the limit as needed?
22:03:54 <glguy> I might just start at 20000 and add 10000 as needed
22:05:07 <int-e> glguy: I doubled as needed
22:05:34 <int-e> and started with 64.
22:05:51 <araujo> dons, that's pretty much an example of how a busy-box-like shell would look like in Haskell.
22:13:36 <glguy> int-e: using the array over the dictionary, I can outperform the edwardk build that previously beat me when i was at 28 :)
22:13:46 <glguy> definitely faster
22:13:57 <glguy> than the previous iteration
22:14:21 <glguy> i don't know if it slows the C version down to use cygwin
22:14:54 <glguy> Mine finishes when the other is at 45 now
22:16:07 <edwardk_> I keep thinking that I want to do a version of the JIT with GNU lightning, but then I don't want to write a third jit for this thing ;)
22:17:47 * araujo impotent
22:18:01 <glguy> poor araujo ... misses his h.o
22:18:40 <edwardk_> stole the idea from kevin millikin at the conference
22:18:46 <araujo> :-(
22:18:52 <int-e> edwardk_: wait, a third one?
22:19:36 <edwardk_> yeah
22:19:43 <edwardk_> would be fun to do though
22:19:53 <edwardk_> wrote 2, one in haskell -> haskell, one in perl -> c.
22:20:19 <int-e> ah, I missed the haskell -> haskell one then.
22:20:26 <int-e> or forgot about it
22:20:59 <edwardk_> it was.. forgettable. =)
22:21:15 <edwardk_> i abused hsplugins and just jitted down to haskell
22:25:56 <edwardk_> which tool is the current one for taking c and generating a usable haskell interface?
22:26:07 <edwardk_> and does it handle source files full of macros gracefully?
22:26:38 <araujo> c2hs
22:26:39 <araujo> ?
22:26:46 <edwardk_> yeah
22:26:52 <edwardk_> ok, was making sure there wasn't another one =)
22:27:14 <edwardk_> does c2hs handle macros at all?
22:27:17 <araujo> well, c2hs is a more friendly and powerful front-end on top of FFI
22:27:42 <araujo> i think it does, but check it to be sure
22:41:09 <glguy> anyone know where the verification program for publications is inside the codex?
22:45:49 <int-e> ftd login
22:54:16 <foxy> is there a HWN web resource?
22:55:04 <int-e> @google "Haskell Weekly News"
22:55:07 <lambdabot> http://sequence.complete.org/hwn
22:55:31 <dons> ?where hwn
22:55:32 <lambdabot> http://sequence.complete.org/
22:55:47 <dons> also, the darcs archive is online
22:57:08 <int-e> . o O ( Fatal error: Call to undefined function: data() in /var/local/drupal-4.6.5/modules/archive.module on line 233 )
22:57:44 <int-e> following the 'previous month' link on the calendar there
22:58:32 <foxy> is haskell.org down?
22:58:52 <int-e> foxy: yes
22:59:04 <foxy> @arr
22:59:05 <lambdabot> I want me grog!
22:59:22 <int-e> I think we should add a "does anyone ever read the topic?" in the middle of the topic :)
22:59:32 <dons> ?topic #haskell
22:59:32 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
22:59:40 <dons> ?topic-tell #haskell
22:59:40 <lambdabot> ["haskell.org is down for the moment","Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating
22:59:40 <lambdabot> hackers"]
23:00:16 <sieni> dons: ?topic-tell must be one of the most useless features of lambadabot :-D
23:00:23 <dons> i'm just a little suspicious with everyone flying back from ICFP, that it wil remain down for the weekend
23:00:33 <dons> yeah, its' a legacy from the days when we thought it would be an irc bot
23:00:43 <dons> and not a haskell ide it's become
23:00:48 <int-e> haha
23:01:19 <foxy> For anyone who wants to see into the head of a haskeller: http://ofb.net/~frederik/mri2/
23:01:21 <lambdabot> Title: Images
23:01:23 <int-e> @tell dons But it is an IRC bot, too. A bit like emacs, which also happens to be an editor.
23:01:23 <lambdabot> Consider it noted.
23:01:37 <dons> true, int-e
23:01:37 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:01:39 <sieni> dons: well, ok it's useful, if you want to know another channel's topic but don't want to join that channel
23:01:49 <dons> yep
23:02:07 <dons> foxy: freaky
23:02:10 <weitzman> ?topic-tell #haskell-blah
23:02:10 <lambdabot> #haskell-blah: Anonymous Haskallians (AH), don't be ashamed to talk about your problems - add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html - lambdabot's
23:02:11 <lambdabot> first words: "Ooh, functional programmers are so hot" - current topic: "America is broken, and surely your leader should symbolise your country. Hence, Bush is the perfect leader." (ndm)
23:02:15 <int-e> hmm, /topic #channel  does that for me
23:02:27 <int-e> and lambdabot doesn't even have to be there ;)
23:02:56 <dons> ?topic #math
23:02:56 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
23:03:03 <dons> ?topic-tell #math
23:03:03 <lambdabot> Do not know that channel
23:03:05 <dons> huh
23:03:15 <dons> shows how often i use that feature
23:03:19 <edwardk_> foxy: I note a dark patch in the back where a normal programmer has his object-oriented lobe. This explains your haskell fixation.
23:03:50 <dons> but its at ~frederik
23:03:52 <foxy> :) not mine, Frederik Eaton, mine is probably not so well developed 8)
23:04:09 <dons> the temporal lambda node seems over developed.
23:04:11 <edwardk_> heh
23:04:19 <int-e> @echo
23:04:20 <lambdabot> echo; msg:IrcMessage {msgPrefix = "int-e!n=noone@t54fc417c.pool.terralink.de", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]} rest:""
23:04:50 <dons> do we get to see inside anyone else in the channel?
23:04:57 <dons> can someone write a @brain-scan <nick> plugin?
23:05:06 <edwardk_> nope, just frederik
23:05:29 <int-e> "Sorry, brain not found."
23:05:38 <edwardk_> lol
23:05:39 <dons> ?brain
23:05:40 <lambdabot> But where are we going to find a duck and a hose at this hour?
23:05:57 <dons> ?. vixen brain
23:05:57 <lambdabot> Is that a real poncho or is that a Sears poncho?
23:06:07 <dons> ?. vixen brain
23:06:08 <lambdabot> i'm not going anywhere
23:06:15 <dons> fun fun
23:06:18 <int-e> ?. elite . vixen vixen
23:06:19 <lambdabot> |-|iYA
23:06:26 <dons> ?. vixen . vixen brain
23:06:26 <lambdabot> I work and go to school
23:07:04 <int-e> ?. vixen free id
23:07:06 <lambdabot> there are a lot of weirdos on here
23:07:14 <dons> heh
23:07:14 <int-e> nice :)
23:07:30 <araujo> haha
23:07:33 <dons> ?remember lambdabot [in #haskell] there are a lot of weirdos on here
23:11:54 <foxy> has anyone installed Frederik Eaton's Futilities ?
23:20:21 <gour> developer Works has article about wxWidgets, but wxhaskell is not mentioned - http://www-128.ibm.com/developerworks/linux/library/l-wxwidgets/?ca=dgr-btw03GUIwxWidgets
23:20:24 <lambdabot> Title: Build cross-platform GUIs using wxWidgets, http://tinyurl.com/gpmrt
23:38:57 <dons> ?yow!
23:38:57 <lambdabot> I want to perform cranial activities with Tuesday Weld!!
23:39:09 <foxy> dcoutts__: ping
23:40:56 <foxy> has the c2hs darcs repo been updated for GHC 6.5?  I get problems with Data.Set interface when compiling.
23:45:30 <deadbeef> is haskell.org down or something ?
23:46:37 <dibblego> Just down
23:46:59 <dons> ?topic-tell #haskell
23:46:59 <lambdabot> ["haskell.org is down for the moment","Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating
23:47:00 <lambdabot> hackers"]
23:47:10 <dons> rumours of a power failure
23:47:16 <foxy> how do I deal with an unapplicable darcs patch?
23:47:24 <deadbeef> thanks dons
23:47:29 <foxy> dons: darcs.haskell.org is up though?
23:47:45 <dons> yes, even haskell.org the machine is up. just not the web server
23:47:53 <dons> I seem to remembe this happening once before
23:59:02 <foxy> > (\w -> foldl setBit 0 $ snd . unzip . filter ((== True) . fst) $ zip (map (testBit w) [1..8]) $ reverse [1..8]) (123 :: Word8)
23:59:02 <lambdabot>  Add a type signature
23:59:16 <foxy> > (\w -> foldl setBit 0 $ snd . unzip . filter ((== True) . fst) $ zip (map (testBit w) [1..8]) $ reverse [1..8]) (123 :: Word8) :: Word8
23:59:18 <lambdabot>  120
23:59:37 <foxy> @pl (\w -> foldl setBit 0 $ snd . unzip . filter ((== True) . fst) $ zip (map (testBit w) [1..8]) $ reverse [1..8])
23:59:38 <lambdabot> foldl setBit 0 . snd . unzip . filter ((True ==) . fst) . ($ reverse [1..8]) . zip . flip map [1..8] . testBit
