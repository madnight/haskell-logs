00:00:08 <glguy> bah, that should be do { a <- [1..] ; return (a + 1) }
00:00:13 <dons> @. type redo print 1 >>= \_ -> print 2
00:00:15 <lambdabot> IO ()
00:00:22 <dons> :)
00:00:35 <xerox> G'day.
00:00:53 <jrmole> it's not a type-preserving syntactic transform, though
00:01:14 <lispy> it is when the input is type sound
00:01:26 <glguy> a syntactic transform is type-preserving by defintion
00:01:27 <dons> yeah, i hope so
00:01:45 <jrmole> yeah, but it takes badly-typed terms to well-typed terms without error
00:01:46 <jrmole> *shrug*
00:01:53 <dons> shrug
00:01:57 <dons> that's what @compose type is for
00:02:13 <glguy> dons: you should add a rule that if jrmole provides input, lambdabot assumes type error ;)
00:02:21 <dons> heh
00:02:34 <jrmole> @redo print "screw you all ;)"
00:02:35 <lambdabot> print "screw you all ;)"
00:03:00 <lispy> @pl join . fmap
00:03:01 <lambdabot> join . fmap
00:03:07 <lispy> @type join . fmap
00:03:08 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (f a)
00:03:09 <lambdabot>    Expected type: (a -> b) -> f a -> f a -> a1
00:03:09 <glguy> looking for bind?
00:03:17 <xerox> ?type (join .) . fmap
00:03:19 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
00:03:34 <lispy> what is the one that ends up as =<<?
00:03:35 <xerox> ?type let (.:) = (.) . (.) in join .: fmap
00:03:36 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
00:03:38 <xerox> :D
00:03:55 <xerox> ?type (=<<)
00:03:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
00:04:18 <glguy> bind is concatMap, join is concat, fmap is map
00:04:41 <glguy> (in [a])
00:04:51 <jrmole> @hoogle (Monad m) => m (m a) -> m a
00:04:52 <lambdabot> Prelude.id :: a -> a
00:04:52 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
00:04:52 <lambdabot> Prelude.asTypeOf :: a -> a -> a
00:05:13 <glguy> > join [[1,2],[3,4]]
00:05:14 <lambdabot>  [1,2,3,4]
00:05:20 <lispy> (join .) . fmap $ (return 1) (return 2)
00:05:22 <xerox> > join (*) 2
00:05:22 <lambdabot>  4
00:05:34 <lispy> > (join .) . fmap $ (return 1) (return 2)
00:05:35 <lambdabot>  add an instance declaration for (Num (a1 -> f a))
00:05:36 <glguy> > join (Just (Just 2))
00:05:37 <lambdabot>  Just 2
00:06:10 <lispy> oh, why is > join (*) 2 == 4?  reader?
00:06:12 <xerox> > ((join .) . fmap) (\x -> [x,x^2] [1,2,3]
00:06:13 <lambdabot>  Parse error
00:06:16 <xerox> > ((join .) . fmap) (\x -> [x,x^2]) [1,2,3]
00:06:17 <lambdabot>  [1,1,2,4,3,9]
00:06:17 <xerox> Yep.
00:06:20 <jrmole> @type join
00:06:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
00:06:25 <edwardk> lispy: yeah
00:06:28 <glguy> in reader, join f x = f x x
00:06:39 <lispy> yeah, makes sense
00:06:43 <xerox> > sequence [even,(>10)] 12
00:06:44 <lambdabot>  [True,True]
00:06:45 <xerox> :D
00:07:05 <jrmole> @type join (*)
00:07:07 <lambdabot> forall a. (Num a) => a -> a
00:07:34 <glguy> > let join' f = do { a <- f; a } in join' (*) 2
00:07:35 <lambdabot>  4
00:07:36 <lispy> man, filling your code with join foo, instead of \x -> foo x x, would be evil though :)
00:07:54 <xerox> lispy: no why! :D
00:08:03 <dons> you'd get used to it quickly I think
00:08:08 <dons> that's a pretty easy one
00:08:11 <edwardk> yeah
00:08:24 <xerox> > join (&&&) (*2) (1,2)
00:08:24 <edwardk> ap and join are all fun and fairly obvious reader monad uses
00:08:25 <lambdabot>  add an instance declaration for (Num (a, b))
00:08:27 <xerox> Ops.
00:08:34 <glguy> > let join' = (=<<) id in join' (*) 2
00:08:35 <lambdabot>  4
00:08:36 <lispy> @type ap
00:08:38 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
00:09:07 <lispy> > (+1) `ap` return 2
00:09:08 <lambdabot>  add an instance declaration for (Num (a -> b))
00:09:14 <xerox> > join (***) (*2) (1,2)
00:09:15 <lambdabot>  (2,4)
00:09:23 <lispy> > liftM (+1) `ap` return 2
00:09:23 <lambdabot>  Add a type signature
00:09:36 <xerox> OK enough random code I think =)
00:09:38 <glguy> > ap (,) (+1) 3
00:09:39 <lambdabot>  (3,4)
00:09:40 <edwardk> heh
00:09:42 <Korollary> ?users
00:09:43 <lambdabot> Maximum users seen in #haskell: 220, currently: 190 (86.4%), active: 25 (11.4%)
00:09:53 <xerox> Oh, activity monitor too.
00:09:54 <Korollary> chatty channel
00:10:01 <xerox> Big Brother lambdabot.
00:10:03 <edwardk> @seen shapr
00:10:04 <lambdabot> I haven't seen shapr.
00:10:12 <jrmole> does lambdabot have stats on most popular commands?
00:10:28 <glguy> > and @pl would win outright
00:10:28 <lambdabot>  Not in scope: `outright'
00:10:30 <glguy> heh
00:10:35 <xerox> jrmole: somebody should implement that
00:10:46 <Korollary> jrmole: I believe most of its state data is in darcs. You could grep it yourself.
00:10:51 <lispy> jrmole: no , but you could build that from the chat logs more easily than having lambdabot track it, i would think
00:11:00 <edwardk> yeah, but @. pl undo is a lot of fun too
00:11:02 <glguy> lambdabot keeps stats on who cusses the most, I'm sure that it tracks command usage
00:11:15 <xerox> lispy: I think it would be simple enough to let lambdabot do it
00:11:18 <Korollary> glguy: Does it? I think that would be me right after Philippa.
00:11:33 <lispy> @where stats
00:11:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:11:43 <xerox> It even logs.
00:11:56 <xerox> If any you could parse them, but it isn't really needed.
00:12:09 <Korollary> It's a load of fanboy nonsense anyway.
00:12:34 <glguy> what's full of fanboy nonsense?
00:12:34 <edwardk> kor: yer just sayingthat coz you dropped out of the top 25 ;)
00:12:36 <xerox> One just need to populate a Map String Int with commands performed, and then have a module that pretty-prints stats.
00:12:53 <jrmole> @pl let qsort [] = []; qsort (x:xs) = qsort lt ++ [x] ++ qsort ge where { lt = [ y | y <- xs, y < x ]; ge = [ y | y <- xs, y >= x ] } in qsort
00:12:54 <lambdabot> (line 1, column 11):
00:12:54 <lambdabot> unexpected "["
00:12:54 <lambdabot> expecting pattern or "="
00:13:08 <jrmole> @pl let { qsort [] = []; qsort (x:xs) = qsort lt ++ [x] ++ qsort ge where { lt = [ y | y <- xs, y < x ]; ge = [ y | y <- xs, y >= x ] } } in qsort
00:13:09 <lambdabot> (line 1, column 5):
00:13:09 <lambdabot> unexpected "{"
00:13:09 <lambdabot> expecting natural, identifier or "in"
00:13:14 <lispy> lambdabot spoke a total of 365911 words!
00:13:15 <lispy> lambdabot's faithful follower, dons, didn't speak so much: 337642 words.
00:13:24 <jrmole> hehe
00:13:28 <lispy> dons is the faithful follower...lol
00:13:48 <jrmole> why doesn't it like me?
00:13:51 <Korollary> Dr dons, mr lambdabot
00:14:16 <Korollary> ?vixen you like jrmole ?
00:14:20 <lambdabot> i'd say i like
00:14:23 <jrmole> :)
00:14:26 <xerox> @pl qs (x:xs) = qs (filter (<x) xs) ++ [x] ++ qs (filter (>=x) xs)
00:14:30 <lambdabot> qs = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))
00:14:40 <edwardk> hrmm. what would an STM-like comonad look like? i can't seem to make the monad version work in my type system, but i should be able to graft the unrestricted comonad into a comonadic version =/
00:15:10 <dolio> So much clearer than the J quicksort.
00:15:17 <edwardk> hehehe
00:15:22 <int-e> and so wrong
00:15:27 <glguy> J's pointsfree quicksort is actually understandable to a J programmer
00:15:30 <audreyt> edwardk: heya. I'm considering rolling in your STM hash
00:15:37 <edwardk> audreyt: its all yours
00:15:39 <audreyt> to pugs; is there a cabalized version somewhere?
00:15:49 <audreyt> need to bench it against (TVar Map)
00:16:01 <edwardk> audreyt: hrmm, lemme see if its still in the repository on mmy machine, if not i'll roll one fast
00:16:15 <audreyt> I wonder if there's an ordered map somewhere of if it's possible
00:16:24 <audreyt> i.e. a patricia tree. your hash is unordered, right?
00:16:38 <xerox> int-e: one just have to stick qs [] = [] on the line above and it's fine.
00:16:44 <xerox> Hiya audreyt.
00:16:49 <audreyt> greetings xerox.
00:16:51 <edwardk> this version is, its possible to create a version of this that has a defined key ordering, but it won't be alphabetical.
00:16:54 <lispy> > (fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))) [0, 2, -3, 4, 8]
00:16:58 <lambdabot> Terminated
00:16:59 <edwardk> the notes in the code say where to shift the define space
00:17:06 <glguy> lispy: no terminating case
00:17:11 <audreyt> edwardk: I need a mutable IntMap
00:17:13 <int-e> xerox: not really, once you pl-ed it.
00:17:16 <lispy> glguy: ah
00:17:18 <audreyt> in the STM monad, basically
00:17:22 <edwardk> yeah
00:17:24 <audreyt> that implementsthe perl idea of "array"
00:17:25 <xerox> > let qs [] = []; qs = (fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))) [0, 2, -3, 4, 8] in qs [4,3,2,1]
00:17:26 <lambdabot>    Varying number of arguments for function `qs'
00:17:26 <lambdabot>   In the definition of `...
00:17:27 <edwardk> don't have one of those =)
00:17:29 <xerox> ops.
00:17:32 <int-e> xerox: because then it'd calling the wrong version recursively
00:17:38 <xerox> Crazy int-e ! I didn't think of that.
00:17:38 <audreyt> that's fine, I can hack one together if needed =)
00:17:45 <audreyt> for now TVar (IntMap) will do
00:17:51 <int-e> *it's*
00:17:58 <edwardk> i wandered off and played with type-level 2s complement numbers and things, and now am off doing thesis stuff on type systems
00:18:46 <xerox> > let qs xs | null xs = [] | otherwise = (fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>=))) . (.)))) xs in qs [4,3,2,1]
00:18:50 <lambdabot> Terminated
00:18:59 <xerox> Oh well.
00:19:01 <dfeuer> edwardk, do you understand Kaplan & Tarjan's implementation of catenable, splittable persistent deques that they claim have O(log log n) concatenation?
00:19:47 <edwardk> dfeuer: haven't looked at it, but i've read a lot of tarjan's stuff, send me a url and i might play with it =)
00:20:22 <dfeuer> 'kay.
00:20:22 <dolio> @pl qs x = if null x then [] else qs (filter (< head x) (tail xs)) ++ [head x] ++ qs (filter (>= head x) (tail xs))
00:20:23 <dfeuer> 1 sec.
00:20:24 <lambdabot> qs = fix (ap (flip if' [] . null) . ap (ap . ((++) .) . (. flip (filter . flip (<) . head) (tail xs))) (ap ((++) . return . head) . (. flip (filter . flip (>=) . head) (tail xs))))
00:21:08 <dolio> > (fix (ap (flip if' [] . null) . ap (ap . ((++) .) . (. flip (filter . flip (<) . head) (tail xs))) (ap ((++) . return . head) . (. flip (filter . flip (>=) . head) (tail xs))))) [4, 3, 2, 1]
00:21:09 <lambdabot>  Not in scope: `xs'
00:21:16 <edwardk> er, whats the cabal line for BSD license?
00:21:27 <dfeuer> edwardk, http://citeseer.ist.psu.edu/kaplan96purely.html
00:21:31 <dolio> Oops.
00:21:47 <dolio> @pl qs x = if null x then [] else qs (filter (< head x) (tail x)) ++ [head x] ++ qs (filter (>= head x) (tail x))
00:21:48 <lambdabot> qs = fix (ap (flip if' [] . null) . ap (ap . ((++) .) . (. ap (filter . flip (<) . head) tail)) (ap ((++) . return . head) . (. ap (filter . flip (>=) . head) tail)))
00:21:49 <audreyt> edwardk:
00:21:50 <audreyt> License:             BSD3
00:21:55 <audreyt> License-file:        LICENSE
00:22:04 <dolio> > (fix (ap (flip if' [] . null) . ap (ap . ((++) .) . (. ap (filter . flip (<) . head) tail)) (ap ((++) . return . head) . (. ap (filter . flip (>=) . head) tail)))) [4, 3, 2, 1]
00:22:05 <lambdabot>  Not in scope: `if''
00:22:12 <dolio> Ah well.
00:23:00 <glguy> qsort =: ]`((}.#~{.>:}.) , {. , }.#~{.<}.)@.(* & #)
00:23:16 <dfeuer> edwardk, did you catch the link?
00:23:23 <Korollary> lambdabot didn't.
00:23:28 <Korollary> where's the teeny url
00:23:52 <glguy> @paste
00:23:52 <lambdabot> http://paste.lisp.org/new/haskell
00:23:59 <Korollary> ?tiny http://citeseer.ist.psu.edu/kaplan96purely.html
00:24:01 <lambdabot> http://tinyurl.com/khw3j
00:24:32 <dfeuer> Why do you want it tiny?
00:24:36 <edwardk> audreyt: try http://slipwave.info/haskell/thash/
00:24:38 <lambdabot> Title: Index of /haskell/thash
00:25:03 <Korollary> dfeuer: All the cool kids are doing it.
00:25:03 <dfeuer> edwardk, did you catch the link?
00:25:05 <edwardk> should be able to pull with darcs
00:25:21 <edwardk> dfeuer: yeah, was building a darcs repo, heading back for it now
00:25:29 <dfeuer> oookay
00:26:03 <edwardk> ah like most fast functional toys its got a 2-3 finger tree in it =)
00:26:07 <dfeuer> I found the first data structure they describe in the paper reasonably understandable, but then the second looks like a bunch of spaghetti.
00:26:29 <dfeuer> And the third seems almost handwaved in.
00:27:07 <edwardk> given tarjan's involvement i wonder where the union-find algorithm kicks in ;)
00:27:21 <dfeuer> I don't even know what the union-find algorithm is :-/
00:27:34 <edwardk> @google union-find algorithm
00:27:39 <glguy> disjoint sets
00:27:42 <edwardk> yeah
00:27:49 <lambdabot> search module failed: IRCRaised thread killed
00:28:01 <edwardk> interesting result there
00:28:19 <Korollary> It's a sign.
00:28:21 <dfeuer> Tarjan seems to be involved in half the persistent or amortized data structures out there, except the ones that are both persistent and amortized, which he likes to leave to Okasaki.
00:28:23 <Korollary> Don't read that doc.
00:28:55 <edwardk> yeah pretty much any time you see a time bound that includes an O (foo * alpha(n)) he's involved
00:28:59 <lisppaste2> glguy pasted "union find in ST" at http://paste.lisp.org/display/25138
00:29:47 <edwardk> funny how often you wind up using that trick
00:30:15 <edwardk> i use it in compilers for flowgraph reduction, in computational geometry for visibility calculations, etc.
00:30:20 <dfeuer> edwardk, foo * alpha(n)?  Is that a joke?
00:30:28 <dfeuer> What trick?
00:30:29 <edwardk> well, for just about any foo
00:30:30 <dfeuer> Union find?
00:30:32 <edwardk> yeah
00:30:37 <dfeuer> and just about any alpha too?
00:30:51 <edwardk> no, alpha being the 'practical inverse of the ackermann function'
00:31:05 <glguy> "grows real slow"
00:31:06 <edwardk> i.e. < 4 for any realistic input.
00:31:09 <edwardk> all but constant.
00:31:10 <dfeuer> i.e., log log n, log*n, etc?
00:31:21 <edwardk> dfeuer: lower =)
00:31:31 <dfeuer> hm.  Well, this one is log log n.
00:31:41 <edwardk> yeah
00:31:47 <dfeuer> And hey, log log n <= 6, and log* n <= 5.
00:32:19 <edwardk> yeah, the alpha(n) is funny, but is still a tighter bound ;)
00:32:47 <dfeuer> Whatever...
00:33:10 <edwardk> it comes up in my visibility stuff coz i have this annoying n^4 alpha(n) algorithm for some things, where i have a provable lower complexity bound of n^4, so it might be possible to trim the alpha(n) i'm just not that smart
00:33:26 <dfeuer> If you can explain the second and third data structures, that'd be unbelievably cool.
00:33:27 <edwardk> but then the alpha(n) might as well be a constant
00:33:52 <dfeuer> Yeah.
00:33:56 <dfeuer> So it's just a little itch.
00:33:58 <edwardk> heh, then i have another algorithm i use that yields n^4 2^alpha(n) complexity, which ALSO might as well be a constant.
00:34:30 <dfeuer> When compared to n^4, for sure....
00:34:46 <edwardk> the aphas there come from davenport-schinzel sequences and arrangements of hyperbolas in a plane and scary things line that
00:34:56 <dfeuer> gleep
00:35:10 <edwardk> one of the few cases where it doesn't come from something tarjan proved.
00:35:35 <edwardk> but they still annoy =)
00:35:36 <dfeuer> Does it actually have to do with the Ackerman function, or is it some other slow-growing function?
00:36:07 * glguy guesses the ackerman function just came in because he used a union/find operation
00:36:14 <edwardk> dfeuer: there is no ackerman function involved here. it just has to do with the total number of areas that a bunch of curves can carve a plane into when you know something about how many times any two of the curves can intersect
00:36:30 <edwardk> glguy: no union/find in those cases either.
00:36:39 * dfeuer must go to sleep.
00:36:40 <glguy> oh well, I tried :)
00:36:59 <dfeuer> I want to make macaroni and cheese tomorrow, and I've never done that before.
00:37:11 <Korollary> Are you sure you are ready for that?
00:37:12 <glguy> :-/
00:37:14 <dfeuer> At least, I think I want to.
00:37:30 <glguy> What about going... outside...
00:37:32 <edwardk> glguy: you wind up with an interesting result there involving the maximum complexity of davenport schinzel sequences, and it in the end tells you how complex the algorithm is, but no one in their right might would actually IMPLEMENT that algorithm ;)
00:37:43 <edwardk> so its an existential comp sci argument, fun
00:37:52 <edwardk> thats why i wanted to do something more concrete this time around =)
00:38:21 <dfeuer> Is this the n^4 thing?
00:38:29 <edwardk> and in fact it doesn't even give the means to construct it, just a computational complexity lower and upper bound
00:38:29 <edwardk> yeah
00:38:32 <edwardk> not your paper
00:38:37 <edwardk> sorry
00:38:40 <edwardk> got stuck on a tangent =)
00:38:56 <dfeuer> So no one would want to write it because it would be slow, and no one knows how to write it anyway?
00:39:17 * dfeuer never knew there were non-constructive algorithm-existence proofs.
00:39:21 <edwardk> dfeuer: its the fastest solution to the problem, but the complexity is high enough you don't want to apply it in the real world
00:39:58 <dfeuer> So it's not a practically solvable problem.
00:40:03 <edwardk> yeah
00:40:18 <dfeuer> (would it be useful to solve efficiently if it were possible to do so?)
00:40:21 <edwardk> n^4, now apply it to a couple million curves.
00:40:26 <edwardk> yeah
00:40:29 <dfeuer> Oh.
00:40:32 <dfeuer> A couple million.
00:40:40 <edwardk> well, there are tricks
00:40:47 <dfeuer> Approximation tricks?
00:40:58 <dfeuer> Or algorithms that work almost all the time but sometimes don't tricks?
00:41:33 <edwardk> i can break it apart like i usually do BSPs, and get it to work with n log n chunks of 50 curves, so its only 50^4, but then the algorithm is randomized and the proofs are hairy
00:42:12 <edwardk> dfeuer: it becomes las vegas, so you know you got the right solution, but don't always get an answer, but can re-randomize and try again
00:42:28 <edwardk> basically its a pain in the ass ;)
00:42:46 <edwardk> but its solvable
00:42:54 <dfeuer> I only understood about half of that lost sentence.
00:43:14 <dfeuer> last
00:43:18 <edwardk> well, you know polynomial time right?
00:43:21 <dfeuer> Yah.
00:43:27 <dfeuer> I don't know what a BSP is.
00:43:38 <edwardk> er. graphics term, binary space partitioning tree.
00:43:49 <dfeuer> Or why hairy proofs are a problem for practical programming.
00:44:00 <dfeuer> Sounds vaguely familiar.
00:44:06 <edwardk> http://www.flipcode.com/articles/harmless_issue02.shtml
00:44:15 <lambdabot> Title: flipcode - Harmless Algorithms, http://tinyurl.com/k354r
00:44:47 <xerox> Why the heck does it provide a tinyurl? :P
00:44:48 <dfeuer> I think you're a little too far over my head.
00:44:50 <edwardk> well, i was writing this stuff up academically, not as an engineering problem
00:45:03 <dfeuer> I got that bit.
00:45:06 <edwardk> so tough proofs were a problem =)
00:45:17 <dfeuer> Then you were talking about tricks to make it practical..
00:45:25 <dfeuer> And I got a little lost.
00:45:27 <dfeuer> Whatever.
00:45:33 <edwardk> sure, coz i like engineering real solutions with obscure theory
00:45:36 <dfeuer> Go back to the article I gave you!
00:45:40 <edwardk> heh
00:46:11 <edwardk> anyways, my point was it was an existential proof of an algorithm, that COULD be used in practice, but i didn't get around to finding a construction ;)
00:47:16 <edwardk> heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
00:47:48 <jrmole> often with terrible time complexity though
00:47:56 <dfeuer> heh
00:48:05 <edwardk> jr: yeah
00:48:07 <xerox> @remember edwardk heh i should probably just type up the problem specification in haskell and click compile. funny how that seems to yield the answer ;)
00:48:24 <dfeuer> @remember
00:48:24 <lambdabot> Incorrect arguments to quote
00:48:34 <dfeuer> @forget
00:48:35 <lambdabot> Unknown command, try @list
00:48:59 <xerox> You have to wait GC for that
00:49:01 * xerox ducks
00:49:07 <jrmole> har
00:50:31 <dfeuer> What does @remember do, exactly?
00:50:37 <dfeuer> How do you get the quotes out?
00:50:39 <xerox> @quote edwardk
00:50:39 <lambdabot>  been playing with type level 2s complement arithmetic
00:50:40 <glguy> @quote emertens
00:50:40 <lambdabot>  screw ruby on rails, I'm using snakes on a plane
00:50:45 <jrmole> @quote lambdabot
00:50:45 <lambdabot>  Occurs check: cannot construct the infinite type: a
00:51:13 <dfeuer> @quote your mom
00:51:14 <lambdabot> your mom hasn't said anything memorable
00:51:30 <jrmole> @quote lambdabot
00:51:31 <lambdabot>  Nobody brings small problems into a laundromat.
00:51:57 <edwardk> @quote xerox
00:51:58 <lambdabot>  you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
00:52:06 <edwardk> hhah
00:52:08 <xerox> lol
00:52:49 <dfeuer> @quote your_mom
00:52:50 <lambdabot>  Oh, that felt good.  Can you do it again?
00:53:23 <dfeuer> @quote
00:53:23 <lambdabot> Miod says: [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
00:53:37 <dfeuer> Wow.
00:53:44 <edwardk> yeah neat huh?
00:53:49 <dfeuer> yah.
00:53:50 <edwardk> the paragon of CISC
00:54:32 * dfeuer thinks the Intel Pentium processors are full of crazy ass instructions only a lunatic would use.
00:54:49 <dfeuer> [mostly left over from the 286 and earlier processors, I think]
00:55:21 <edwardk> some are nuts, though the multi register addressing modes work well, just not enough registers =(
00:55:41 <dfeuer> I don't know too much about it.
00:55:54 <dfeuer> Just a few of the ones I saw in the manual looked uber-sketchy.
00:55:58 <edwardk> and besides a lot of the crufty old 286 stuff has terrible performance
00:56:11 <edwardk> i.e. the bit stuff is often faster to loop over by hand
00:56:39 <dfeuer> Some look like they were put in there because one programmer one time wanted to use them.
00:57:14 <jrmole> or because compilers were very stupid back then
00:57:16 <glguy> J has a function that computes polynomials of arbitrary degree
00:57:19 <glguy> p.
00:57:31 <jrmole> glguy, has anyone implemented J in hardware? ;)
00:57:33 <edwardk> well you have to remember the time, when you're talking 16 mhz, getting a 4-fold increase in a common business op mattered a lot more than now =)
00:57:43 <dfeuer> Aren't there some weird ones specifically designed to work with character strings or something silly like that?
00:58:00 <jrmole> yeah, there are instructions for BCD, and conversion to/from ASCII
00:58:02 <edwardk> plus it had marketing pull that you could do more than the other processor, and stuff
00:58:06 <dfeuer> oh yeah....
00:58:08 <dfeuer> UGH.
00:58:13 <edwardk> hey, xlat is useful =)
00:58:17 <dfeuer> xlat?
00:58:28 <Korollary> finance types needed that bcd crap iirc
00:58:33 <edwardk> the opcode for doing ascii lookups basically
00:58:35 <dfeuer> Computing polynomials of arbitrary degree at least is generally useful.
00:59:14 <edwardk> heh i don't miss having to code assembly to make inner loops fast
00:59:15 <int-e> xlat: al := [bx+al]
00:59:29 <edwardk> yeah thats the one
00:59:32 <dfeuer> sorry.
00:59:35 <int-e> (I wonder what it does in 32 bit more? use ebx?)
00:59:36 <dfeuer> That means jack shit to me.
00:59:51 <edwardk> basicay it looks up a byte in a table and replaces the byte
01:00:07 <edwardk> was originally designed for fast ascii/ebcdic translation, etc.
01:00:10 <int-e> my favourite undocumented (yet pretty much universally supported) opcode was salc - set al to carry.
01:00:21 <edwardk> yeah
01:01:25 <dfeuer> That sounds vaguely useful.
01:01:31 <dfeuer> Why would it be undocumented.
01:01:31 <dfeuer> ?
01:01:43 <edwardk> heh undocumented opcodes. i used to use those a lot on the 6502
01:02:32 <int-e> dfeuer: I don't know. Maybe Intel wasn't sure whether they were going to support it in the future. Or someone forgot. But they weren't documented before the 586 or so.
01:02:37 <edwardk> dfeur: it wasn't specified, it jsut worked. like on the 6502: you could use a byte AF, which only worked because the tail bits specified both cases, and it actually loaded 2 registers with a value.
01:02:40 <int-e> Pentium of course ;)
01:03:12 <edwardk> dfeuer: even though it was just a combination of AD and AE for loading the two registers individually.
01:03:16 <int-e> another useful feature was using aam and aad with bases other than 10.
01:03:27 <edwardk> worked coz the way they mapped the bits around to the gates internally
01:03:31 <edwardk> salc same way
01:04:17 * dfeuer is lost.  Also tired.  Will go to sleeeeep.
01:04:42 <int-e> it's almost useless knowledge anyway.
01:04:45 <edwardk> yeah
01:04:52 <edwardk> unless you're writing an emulator
01:05:00 <int-e> I said, almost :)
01:05:11 <edwardk> and i don't think i'll write another apple iigs or c64 emulator =)
01:05:33 <edwardk> optimizing one in haskell wouldn't be fun.
01:05:40 <edwardk> jits and such are not haskell's strong suit ;)
01:06:27 <dfeuer> hehe.
01:07:11 <dfeuer> I'd like to see an emulator complete enough to run Windows XP, supporting a useful number of devices, and fast enough to be useful.
01:07:38 <xerox> Paralles is that.
01:07:42 <edwardk> http://slipwave.info/#%5B%5BICFP06%20Universal%20Machine%5D%5D has hopefully the last jit i'll ever write in haskell ;)
01:07:45 <xerox> Parallels*
01:08:35 <therp> t du
01:08:37 <therp> sorry typo..
01:09:03 <xerox> dfeuer  <http://youtube.com/watch?v=gE1XQyT_IbA>
01:09:55 <edwardk> one algorithm i'd really like to see done in a functional style would be a skew suffix array construction.
01:10:23 <dfeuer> xerox, is that actually emulation?
01:11:15 <dfeuer> (another way to put it: could a faulty Windows program crash the Mac?]
01:11:16 <dfeuer> )
01:11:31 <xerox> The latter: no, I don't think so.
01:11:41 <dfeuer> The former?
01:12:14 <xerox> I think it uses some property of the duo chips to run that "natively fast" I don't know exactly what.
01:12:27 <dfeuer> duo?
01:12:48 <jrmole> seeing as the host and guest arch are the same, it's probably virtualizing
01:12:57 <dfeuer> virtualizing?
01:13:14 <jrmole> and that's not special to the duo, nor does it require that the guest programs can crash the host OS (no program can crash a well-designed OS)
01:13:25 <edwardk> dfeuer: they've been adding stuff to the current chips to support virtual ring 0 stuff so you can run multiple oses
01:13:34 <dfeuer> hmmmm
01:13:37 <dfeuer> yummy.
01:13:37 <jrmole> you can virtualize on most x86 chips i think
01:13:51 <edwardk> all the stuff that people had to do the hard way before.
01:14:12 <jrmole> all it requires is a way to catch the "errors" from priviledged instructions and emulate them
01:14:18 <edwardk> so you don't have to scan for attempts to modify the gtlb in the upcoming code before allowing execution, or do other hacks
01:14:22 <edwardk> yeah
01:14:29 <dottedmag> jrmole: and that's slow, as you can see with the VMWare.
01:14:34 <dfeuer> gtlb?
01:14:40 <jrmole> dottedmag, no, almost all instructions run natively
01:14:46 <jrmole> and VMWare runs at near-native speed
01:14:48 <dfeuer> And what do you do about access to peripherals?
01:14:54 <jrmole> dfeuer, you emulate them usually
01:14:55 <edwardk> global table that indicates how to map memory around
01:15:06 <dfeuer> jrmole, what about video?
01:15:12 <jrmole> again, emulated
01:15:21 <jrmole> sometimes with a modified driver on the guest OS side
01:15:26 <dfeuer> jrmole, that's fast enough?
01:15:28 <jrmole> edwardk, don't you need supervisor privs to modify the GTLB
01:15:34 <dfeuer> oh, I see.
01:15:34 <jrmole> dfeuer, you won't get 3D, but yes
01:15:35 <edwardk> dfeuer: not to game, but otherwise, yeah
01:15:55 <jrmole> with the modified driver, it's basically as fast as any other (say) X app
01:16:04 <jrmole> in fact i bet you could get 3d without too much trouble
01:16:13 <dfeuer> sounds like a good thing.
01:16:27 <jrmole> not emulating a 3D card, but just passing OpenGL / Direct3D commands to the host OS
01:16:30 <jrmole> kind of how Wine does
01:16:34 * dfeuer would like to be able to run Windows under Linux like that.....
01:16:53 <jrmole> dfeuer, you can get some versions of VMWare for free
01:16:58 <jrmole> and get others for, *cough* free
01:17:06 <dfeuer> hehheh
01:17:14 <dfeuer> Are there any open source sorts?
01:17:29 <jrmole> plex86 was open-source virtualization; i think it's dead now
01:17:33 <jrmole> it was never very good
01:17:33 <dfeuer> aww
01:17:43 <jrmole> i believe both qemu and bochs are emulators proper
01:17:55 <jrmole> you might look at Xen, though iirc it requires some guest-OS modifications
01:17:57 <edwardk> jrmole: the guy went off and did another one that relied on running in a lower ring
01:18:21 <edwardk> jrmole: it was based on explicitly not emulating the expensive operations
01:18:39 <edwardk> i kinda stopped keeping up with the virtualization stuff about 3 years ago
01:18:47 <edwardk> so i'm not sure whats happened in that space.
01:20:11 <dfeuer> ah
01:20:18 <dfeuer> Good night peeps.
01:20:23 <dfeuer> I must to bed.
01:20:27 <jrmole> nite
01:23:39 <jrmole> eh, same for me
01:23:41 <jrmole> ttyl all
01:29:39 <Pupeno> [OT] when configuring a monitor, the biggest possible refrosh is the better, right ?
01:29:56 <Korollary> for your eyes, yes
01:30:49 <Korollary> unless it's an lcd
01:30:56 <Pupeno> it's an lcd.
01:31:04 <Korollary> they tend to look better at 60 instead of 75
01:32:00 <edwardk> depends on the grey-to-grey time on the screen.
01:32:40 <edwardk> and whether the lcd actually changes its refresh rate or just lies to the os and says it does ;)
01:32:53 <edwardk> and just drops a frame every so often
01:33:11 <edwardk> its amazing the shit the vendors pull
01:33:46 * Korollary throws weaselwords at edwardk 
01:33:58 <edwardk> my 1600x1200 lcd monitor that is really 1540x1200
01:34:32 <dons> so they just lie?
01:34:34 <edwardk> so i can't use a standard windows display mode without using a cheesy little software shim i had to write
01:34:43 <edwardk> in order to change the desktop area
01:35:22 <edwardk> dons: yeah. you can test it by counting refreshes with directx and flipping every x frames.
01:35:31 <edwardk> you can eventually sync it so you find the drop rate =)
01:35:47 <edwardk> and gee, 1 in 5 =) when i go fro 60 to 75. hrmm. i can do the math =)
01:36:08 <dons> heh
01:36:13 <dons> nice trick
01:36:43 <edwardk> returned 2 monitors for crap like that
01:36:50 * dons remembers lots of fun calculating custom modelines so I could get an extra ~70 columns on my last crt 
01:36:55 <edwardk> heh
01:38:09 <int-e> it should be advertised as having 60 Hz refresh rate then - I guess they didn't do that?
01:38:13 <edwardk> currently running my weird 1200x1540 lcd (coz its on its side) coz i don't want to abuse my ati card to warp the display to fit and drop scanlines.
01:39:07 <edwardk> i always wind up staring at the fonts when it does
01:39:11 * edwardk shrugs.
01:39:22 <edwardk> heya dcoutts
01:39:42 <int-e> that 1540 is weird.
01:39:56 <edwardk> yeah, samsung 204b, stay away, stay far away =)
01:40:19 <edwardk> int-e: the worst part is you can't SET the display mode to the physical display region. it'll lie and say it can take the extra lines
01:40:27 <xerox> 1680x1050 here!
01:40:39 <edwardk> then just clip off the bottom or top of your screen
01:40:50 <edwardk> er, normally the left or right
01:40:53 * dottedmag really wants notebooks with more than 1280x800 and < 3kg
01:41:04 <vincenz> dons: I have one
01:41:07 <vincenz> dottedmag: I have one
01:41:14 <vincenz> 14" : 1400x1050
01:41:22 <edwardk> which seems just stupid, coz thats either where the start of the text or the scrollbar and the X button for the fullscreen window is ;)
01:41:28 <edwardk> depending
01:41:34 <dottedmag> vincenz: nice. what's the model?
01:41:36 <int-e> who needs those ;)
01:41:37 <vincenz> d610
01:41:49 <vincenz> latitude by dell
01:41:54 <edwardk> heh, i gave up on light laptops and just lug around something ridiculous these days
01:41:58 * Pupeno will have to readapt from 1400x1050 to 1024x768 :(
01:42:11 <dottedmag> vincenz: how about non-windowoze on it?
01:42:30 <edwardk> i really like having a big screen on the laptop, and will give up almost anything for it in features.
01:43:57 <dottedmag> vincenz: really nice laptop, thanks a lot!
01:46:07 <vincenz> dottedmag: I use linux :)
01:46:16 <vincenz> dottedmag: ubuntu, works great on it
01:53:42 <therp> dottedmag: my girlfriend just bought lenovo 3000 n100 / 15.4": 1680x1050. about 3kg. about 1000eur. depends on process/gfx card. linux works nicely (except builtin webcam and fingerprint reader).
01:54:00 <therp> but that might be to big/heavy when you are concerned with size.
01:54:28 <dottedmag> therp: yes, I'm searching for the light nb.
01:54:47 <dottedmag> therp: d610 is the good variant for me.
01:54:58 <vincenz> me too
01:55:09 <vincenz> I wanted: light, not -too- expensive, with decent amount of ram and cpu
01:55:14 * vincenz has 1G
01:55:41 * therp has 128mb, 500mhz and 1024x768 and 3kg :)
01:55:56 <vincenz> 1G, 1.6G, 1400x1050, < 3kg
01:56:07 <edwardk> heh, mine will never be light, laptop has 2 harddrives ;)
01:56:10 <vincenz> and 2MB cache
01:57:33 * therp is a pure PhD student and envys ppl with cool laptops :)
01:57:52 <edwardk> heh
01:58:17 <vincenz> therp: me too
01:58:22 <vincenz> it only cost me 1400 euros
01:58:54 <therp> "only" ?! that's the budget for living for next half year :p
01:59:01 <edwardk> hehe
01:59:08 <edwardk> thats why i'm leery of doing a ph.d ;)
01:59:08 * vincenz saves a lot
01:59:20 <vincenz> my phd is paying me the same as my prior job as IT consultant
01:59:30 <vincenz> :)
02:00:00 <vincenz> well software consultant, not IT
02:00:01 <xerox> How do you expand `phd' in wordy words?
02:00:21 <therp> maybe I should get someone to pay me for my PhD.. "functional program induction in a haskell-like synthesis language" :) ... anyone?
02:00:33 <vincenz> philosophae doctorandi
02:00:34 <vincenz> I think
02:01:36 <vincenz> oh no
02:01:39 <vincenz> just plain "doctor"
02:02:22 <edwardk> philosophiae doctor
02:04:53 <xerox> @index printf
02:04:54 <lambdabot> Text.Printf
02:13:28 <xerox> ?pl \prop err -> prop >>= \res -> if res then return () else error err
02:13:29 <lambdabot> (. (flip (flip if' return) . error)) . (>>=)
02:13:31 <xerox> Pfft.
02:13:49 <vincenz> heh
02:13:55 <vincenz> the funny thing is that if' is not even defined :D
02:13:58 <xerox> mif or something.
02:14:05 <vincenz> @hoogle mif
02:14:05 <lambdabot> No matches found
02:14:09 <vincenz> @hoogle f'
02:14:10 <lambdabot> Data.Graph.Inductive.Query.DFS.dff' :: Graph gr => gr a b -> [Tree Node]
02:14:10 <lambdabot> Data.Graph.Inductive.Query.DFS.rdff' :: Graph gr => gr a b -> [Tree Node]
02:14:10 <lambdabot> Data.Graph.Inductive.Query.DFS.udff' :: Graph gr => gr a b -> [Tree Node]
02:14:13 <vincenz> @hoogle if'
02:14:13 <lambdabot> No matches found
02:14:15 <vincenz> @hoogle if
02:14:16 <lambdabot> Prelude.if :: keyword
02:14:16 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
02:14:16 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
02:14:19 <vincenz> nopes
02:14:26 <xerox> No I mean, my expression is..
02:14:41 <xerox> mif :: IO Bool -> String -> IO ()
02:15:19 <vincenz> oh
02:15:31 <vincenz> there's a better option
02:15:34 <vincenz> @hoogle when
02:15:35 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
02:15:35 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
02:15:48 <vincenz> what you want s
02:15:50 <vincenz> when not
02:16:32 <vincenz> oh nm
02:16:57 <vincenz> @pl \prop err -> prop >>= \res -> when (not res) (error err)
02:16:57 <lambdabot> (. (flip (when . not) . error)) . (>>=)
02:17:11 <vincenz> @pl \err prop -> prop >>= \res -> when (not res) (error err)
02:17:12 <lambdabot> (=<<) . flip (when . not) . error
02:17:57 <xerox> :(
02:18:30 <vincenz> ?
02:18:32 <xerox> unless :: (Monad m) => m Bool -> m () -> m -> () ?
02:18:38 <xerox> ?type when
02:18:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:18:43 <vincenz> yeah
02:18:46 <vincenz> replace when . not
02:18:47 <vincenz> by unless
02:18:59 <vincenz> @pl \err prop -> prop >>= unless res (error err)
02:18:59 <lambdabot> (=<<) . unless res . error
02:19:10 <vincenz> @pl \err prop -> prop >>= \res -> unless res (error err)
02:19:10 <int-e> ?type unless
02:19:11 <lambdabot> (=<<) . flip unless . error
02:19:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:19:39 <xerox> Oh, there _is_ unless.
02:19:48 <xerox> All Bool ->, not m Bool -> :(
02:20:16 <xerox> I wonder what's the cleanest code one can write.
02:21:11 <vincenz> @pl \prop action -> prop >>= \res -> unless res action
02:21:12 <lambdabot> (. flip unless) . (>>=)
02:21:13 <vincenz> that
02:21:19 <vincenz> @pl \action prop -> prop >>= \res -> unless res action
02:21:19 <lambdabot> (=<<) . flip unless
02:21:22 <vincenz> or that :)
02:21:41 <xerox> Nah! :D
02:22:49 <vincenz> you just want to whine, donthca?
02:22:50 <vincenz> :P
02:23:02 <xerox> Pfffft!
02:23:08 <vincenz> @pl mif c a b = c >>= \x -> if x then a else b
02:23:09 <lambdabot> mif = (. (flip . flip if')) . (.) . (>>=)
02:33:27 <gour> yip: any luck in building hIDE?
03:11:04 <xerox> ?yow!
03:11:05 <lambdabot> HUMAN REPLICAS are inserted into VATS of NUTRITIONAL YEAST ...
03:12:03 <ndm> @quote lambdabot
03:12:03 <lambdabot>  Occurs check: cannot construct the infinite type: a
03:12:51 <wilx> @quote me
03:12:52 <lambdabot> me hasn't said anything memorable
03:12:55 <wilx> :)
03:16:03 <dons> you could add a patch for that
03:18:23 <ndm> did you get your paper done dons?
03:20:39 <dons> 2 more days. almost there :)
03:21:23 <ndm> i'm getting pretty close to doing the validity checks on your code
03:23:10 <dons> great!
03:23:16 <dons> that's really cool.
03:41:08 <ihope_> @quote You
03:41:09 <lambdabot> You hasn't said anything memorable
03:41:14 <ihope_> Yes I have :-P
03:41:19 <beelsebob> moo
03:41:23 <xerox> moo bee
03:42:02 <beelsebob> squishie waves
03:42:08 <xerox> @arrr
03:42:09 <lambdabot> Aye Aye Cap'n
03:43:20 <beelsebob> @. elite arr
03:43:20 <lambdabot> yeH 5(Ur\/y Dog...
03:44:37 <beelsebob> @. pl arr
03:44:38 <lambdabot> (line 2, column 1):
03:44:38 <lambdabot> unexpected end of input
03:44:38 <lambdabot> expecting space or simple term
03:50:34 <dmwit> import Debuggers hiding (hat)
03:50:38 <ihope_> @kind TheAnswer -> (Life, TheUniverse, Everything)
03:50:39 <dmwit> print preference
03:50:40 <lambdabot> Not in scope: type constructor or class `TheAnswer'
03:50:40 <lambdabot>  
03:50:40 <lambdabot> <interactive>:1:14: Not in scope: type constructor or class `Life'
03:51:05 <xerox> ihope_: *
03:51:26 <ihope_> * as in 6*9?
03:51:27 <beelsebob> dmwit: hat
03:51:38 <xerox> ?kind (Int -> Int)
03:51:40 <lambdabot> *
03:51:41 <beelsebob> dmwit: what are your requirements?
03:52:10 <dmwit> beelsebob: I'm just getting started in Haskell and decided that copy/pasting into GHCi wasn't going to cut it.
03:52:25 <dmwit> beelsebob: Also, I can't seem to get hat working properly.  (Though I haven't tried very hard yet.)
03:52:33 <xerox> dmwit: there's a bunch of things you can't do in the GHCi prompt. Think of it as a do block.
03:52:53 <beelsebob> dmwit: what's not working with building it?
03:52:55 <xerox> dmwit: you can do actions (evaluate code), and define new bindings with let.
03:53:02 <beelsebob> are you using the cvs version, or the latest release?
03:53:05 <ndm> beelsebob: most of it :)
03:53:35 <beelsebob> ndm: shut up, you're using windows so your opinion doesn't count :P
03:53:47 <beelsebob> it builds every day on my mac
03:54:07 <ndm> beelsebob: hey - i build hat on Windows - and even provide binaries to download!
03:54:17 <ndm> beelsebob: it works just as well as on any other platform...
03:54:21 <beelsebob> ndm: right then, so stop saying it doesn't build
03:54:32 <beelsebob> dmwit: what's the error? ndm and I should be able to help
03:54:33 <dmwit> I know, but let has taken care of me so far...
03:54:33 <dmwit> I just installed what came from apt.  (I'm on Ubuntu, and they offer a "hat" package.)
03:54:46 <beelsebob> ah, I see
03:54:53 <ndm> beelsebob: oh, i just assumed he meant he couldn't get his program compiling with hat
03:55:03 <beelsebob> okay, did it successfully install hmake?
03:56:11 <Igloo> nnggh:
03:56:12 <Igloo> xargs c:/ghc/ghc-6.4.2/bin/ar q libHSbase.a
03:56:12 <Igloo> xargs: c:/ghc/ghc-6.4.2/bin/ar: Argument list too long
03:56:25 <xerox> Aha!
03:56:35 <dmwit> beelsebob: let me work my way up to where I was yesterday (so it's fresh in mind) and I'll come back. =)
03:56:58 <Igloo> audreyt: I haven't looked at it yet, but it sounds like GHC should be told where to find the includes, yes
03:57:01 <beelsebob> dmwit: tbh, I would recommend doing your own build rather than using the package manager
03:57:11 <beelsebob> very few of them are up to date enough to have fixes for a lot fo bugs
03:57:23 <dmwit> Ah, interesting.
03:58:25 <beelsebob> hence the do you have hmake? If that works then building hat is probably fairly straightforward
03:58:35 <dmwit> I have hmake.
03:58:41 <dmwit> So, I'll look into that, too.
03:58:47 <beelsebob> okay
03:58:53 <beelsebob> in which case... cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs login
03:59:00 <beelsebob> password is cvs
03:59:13 <beelsebob> then do a checkout of the module 'hat'
03:59:27 <dmwit> Nice, thanks.
03:59:42 <beelsebob> ./configure, make and make install should work
03:59:49 <dmwit> As always. =)
04:00:11 <beelsebob> if it doesn't bitch at me, or ndm, or Malcolm Wallace
04:00:26 <ndm> dmwit: or the hat@ mailling list
04:00:35 <beelsebob> or use the hat mailing list http://haskell.org/mailman/listinfo/hat
04:00:36 <lambdabot> Title: Hat Info Page
04:00:36 <ndm> which reaches all 3 of us, and more :)
04:00:42 <beelsebob> well said ndm
04:01:02 <ndm> but compiling hat is pretty reliable, from what i found
04:01:17 <beelsebob> yeh, it doesn't tend to break on the common set ups
04:01:32 <beelsebob> what is more fun is trying to get your code to compile in it
04:01:50 <beelsebob> but then Tom is working on that
04:01:53 <ndm> indeed, and thats the bit thats broken :)
04:02:13 <beelsebob> but as dmwit is a beginner, he shouldn't have too many problems
04:02:16 <ndm> yep, Tom to the rescue
04:02:30 <beelsebob> probably the only one will be specifying the type of numeric values
04:02:35 <dmwit> Well... even beginners can use Data.Map, no?
04:02:38 <ndm> hmm, i got problems with the simplest programs, but i geuss thats a lack of luck
04:02:51 <ndm> dmwit: not beginners who use Hat :)
04:02:56 <dmwit> =)
04:02:59 <dmwit> ...
04:03:01 <dmwit> =/
04:03:02 <beelsebob> dmwit: hehe, no, Data.Map is pretty much the only Data construct we don't support now
04:03:07 <ndm> but yeah, thats not really an acceptable answer, and work is being done on it
04:03:17 <beelsebob> I'd suggest writing a simple drop in replacement that uses tuples in lists
04:03:19 <ndm> beelsebob: why not write Data.Map in terms of an associative list?
04:03:27 <dmwit> But, I found a few judicial replacements of FiniteMaps got that taken care of.
04:03:27 <ndm> you beat me to it :)
04:03:30 <beelsebob> great minds
04:03:37 <ndm> why not put that in the Hat CVS?
04:04:01 <beelsebob> ndm: I might at some point... at the moment I've got to get my functional value representation stuff working before bedapest
04:04:09 <beelsebob> so I have 2 days essentially
04:04:20 <ndm> beelsebob: neat, good luck - are you doing a live demo?
04:04:32 <beelsebob> ndm: depends how fast I talk
04:04:34 <ndm> and in summary, is what you are doing worth it?
04:04:52 <ndm> i.e. are functional value representations useful, or just something to explore
04:05:08 <beelsebob> ndm: absolutely... it gives some pretty huge gains in debugging any higher order code
04:05:17 <ndm> beelsebob: neat :)
04:05:18 <beelsebob> most notably - monadic code
04:05:34 <ndm> although i now have a working defunctionaliser
04:05:42 <ndm> which is type safe, so no more higher order for me :)
04:05:46 <beelsebob> ndm: yeh, but that's a bit of a problem
04:05:53 <beelsebob> in that debugging requires the user to know the program
04:06:03 <beelsebob> so if you change it, you bugger their understanding of it
04:06:10 <ndm> yeah, i know, and how dictionary transformations work etc.
04:06:26 <ndm> its relatively easy for me now, but i'm not sure how much of that is me getting used to it
04:06:46 <ndm> i'll try it on a real programmer at some point, to see if it really does make sense, or if i just have a warped mind
04:06:47 <beelsebob> probably quite a bit... but then you could argue that people *should* get used to it
04:07:05 <ndm> not as much as you'd think
04:07:14 <ndm> since functions pretty much relate
04:07:25 <ndm> i.e. you can tell "oh, this function comes from this function"
04:07:31 <beelsebob> uhhuh?
04:07:34 <ndm> so don't have to globally figure out the changes, only locally
04:07:40 <beelsebob> makes sense
04:07:51 <ndm> you can figure out easily by name which functions relate
04:08:02 <beelsebob> problem I forsee is... oh... these 5000 functions come from this block of monadic code do they?
04:08:16 <ndm> then don't write monadic code!
04:08:20 <beelsebob> hehe
04:08:20 <ndm> but yeah, thats an issue
04:08:26 <ndm> however, a lot of monadic code is reduced away
04:08:33 <beelsebob> see my approach deals with monadic code relatively nicely
04:08:42 <ndm> since all monadic inputs are assumed to be unknown
04:08:50 <ndm> and all monadic outputs are disguarded
04:08:52 <beelsebob> in that it manages to reduce it to essentially setp by step debugging in an algorithmic debugger
04:09:05 <ndm> hence, there isn't many monadic bits left
04:09:11 <beelsebob> makes sense
04:09:23 <beelsebob> so your solution to monadic code is to pretend it's not there :DDD
04:09:25 <ndm> neat, so you have higher order views in hat-delta yet?
04:09:26 <beelsebob> I like it
04:09:28 <ndm> indeed
04:09:42 <beelsebob> higher order views?
04:09:44 <ndm> safely, of course :)
04:09:47 <beelsebob> tell me what you mean by that
04:09:48 <ndm> viewing higher order functions
04:09:58 <ndm> instance Show (a -> a) :)
04:10:03 <beelsebob> well, it always has shown you higher order functions
04:10:08 <beelsebob> it's just not done it nicely
04:10:11 <beelsebob> or in a way you could use
04:10:14 <xerox> instance Typeable a => Show (a -> a) ?
04:11:07 <musasabi> dcoutts__: ping
04:11:17 <dcoutts__> @ar
04:11:17 <lambdabot> Arrr!
04:11:23 <Pupeno> lisppaste2: ur?
04:11:31 <beelsebob> the basic idea is to fix the semantics of any functions passed as arguments... so...
04:12:09 <beelsebob> map g [1,2,3] = [3,4,5]? becomes... map {1 ->  3, 2 -> 4, 3 -> 5} [1,2,3] = [3,4,5]?
04:12:12 <musasabi> dcoutts__: a quick C2HS question:
04:12:24 <beelsebob> and the user now only has to think about their intended semantics for map
04:12:31 <beelsebob> instead of those for g as well
04:12:39 <musasabi> Should 'lookupDftMarshIn "CH" [DefinedET gcry_cipher_hd_t h; "CH"]' match or not?
04:12:48 <dcoutts__> ugg
04:12:48 <beelsebob> (noting that g may be locally defined and hence the function symbol be ambiguous)
04:13:44 <ndm> beelsebob: looks a lot like defunctionalisation to me :)
04:13:46 <dcoutts__> musasabi: no idea, sorry. I've not really looked at that bit of the c2hs code before.
04:13:46 <dcoutts__> musasabi: ask ChilliX or post to the c2hs list
04:13:48 <musasabi> I think it should match and would make my problems away, but I am unsure whether to submit that as a patch or not.
04:13:52 <beelsebob> ndm: in a way
04:13:55 <lisppaste2> Pupeno pasted "Better way to solve excercise 4.7 of YAHT ?" at http://paste.lisp.org/display/25144
04:13:59 <beelsebob> but kinda after the issue
04:14:08 <ndm> yeah
04:14:18 <beelsebob> kinda dynamic-defunctionalisation I guess you could call it
04:14:38 <musasabi> ChilliX: ping
04:17:54 <dcoutts__> musasabi: no harm in submitting a patch and trying to explain the change in behaviour
04:19:25 <ihope_> @kind *
04:19:26 <lambdabot> parse error on input `*'
04:19:31 <ihope_> Mmh.
04:19:31 <Pupeno> Is there any better way to solve excercise 4.7 of YAHT other than by concatenating Neithers ?
04:19:40 <ihope_> @kind (*)
04:19:42 <lambdabot> parse error on input `*'
04:20:00 <xerox> '*' *is* a kind, it *hasn't* got a kind.
04:20:04 <xerox> It would have got a meta-kind.
04:20:04 <dmwit> @type (*)
04:20:06 <lambdabot> forall a. (Num a) => a -> a -> a
04:20:25 <beelsebob> @kind (*)
04:20:26 <lambdabot> parse error on input `*'
04:20:32 <ihope_> xerox: why couldn't it be a type as well?
04:20:32 <beelsebob> fnyergh
04:20:39 <beelsebob> @. kind type (*)
04:20:42 <lambdabot> *
04:20:44 <beelsebob> :)
04:20:56 <dmwit> Heh.
04:22:29 <beelsebob> @type *
04:22:30 <lambdabot> parse error on input `*'
04:22:50 <beelsebob> @. . type kind type (*)
04:22:52 <lambdabot> compose module failed: IRCRaised Parse error: "parse"
04:22:56 <beelsebob> lol
04:23:10 <beelsebob> @. type . kind type (*)
04:23:14 <lambdabot> parse error on input `*'
04:23:24 <beelsebob> shame there's no bracket module
04:23:28 <beelsebob> @eval
04:23:42 <dmwit> > 3 + 3
04:23:42 <beelsebob> @eval "(" ++ "*" ++ ")"
04:23:43 <lambdabot>  6
04:24:25 <ndm> xerox: a meta-kind, is called a sort :)
04:24:32 <beelsebob> @run "(" ++ "*" ++ ")"
04:24:38 <xerox> ndm: nice :)
04:24:58 <ndm> type theorists always want one more level of type...
04:25:11 <dmwit> Did he disappear?
04:25:14 <dmwit> @botsnack
04:25:29 <lambdabot>  "(*)"
04:25:31 <lambdabot> :)
04:26:13 <carp_> ndm: type theorists and Betrand Russell :)
04:26:17 <dmwit> This is excellent:
04:26:19 <dmwit> @help run
04:26:19 <lambdabot> run <expr>
04:26:20 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
04:26:38 <ndm> dmwit: have you seen @pl yet?
04:26:55 <dmwit> Yes... another nice pun.
04:27:21 <beelsebob> ndm go boom!
04:29:10 <xerox> @where yaht
04:29:11 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
04:30:30 <xerox> @wiki
04:30:31 <lambdabot> http://www.haskell.org/haskellwiki/
04:32:16 <SamB> hey, how come in this Fruit screenshot I see a Java icon?
04:34:54 <dmwit> @wiki hat
04:34:54 <lambdabot> http://www.haskell.org/haskellwiki/hat
04:35:37 <SamB> dmwit: probably that page doesn't exist :-(
04:35:50 <dmwit> It does, but it points you over to haskell.org/hat
04:35:57 <SamB> huh
04:37:53 <lisppaste2> dmwit pasted "Pointing GHC to interface files" at http://paste.lisp.org/display/25145
04:38:17 <dmwit> Doesn't seem to believe me when I supply the -I option... ?
04:40:34 <dmwit> How can I ask it (nicely) not to put Hat/ at the end of the include path?
04:41:06 <SamB> huh?
04:41:22 <dmwit> GHC is looking for PreludeBasic.hi
04:41:31 <dmwit> I've found it in a path, call it /foo/bar
04:41:55 <dmwit> When I pass -I/foo/bar to hmake, GHC looks in /foo/bar/Hat instead.
04:42:05 <SamB> isn't it Hat that does this?
04:42:22 <Igloo> dmwit: You want -i/foo/bar
04:42:42 <dmwit> It's what I typed, but gaim autocorrected it for me here in IRC.
04:42:44 <dmwit> (Sorry.)
04:42:48 <SamB> hah
04:43:15 <dmwit> SamB: No, I think this comes after the call to haskell-compiler.
04:43:16 <SamB> my client mostly corrects my tehs to thes ;-)
04:43:37 <SamB> ... even though most of the time when I type "teh" I really want to say that!
04:43:43 <Stinger_> corrections and smileys are terrible for programmers
04:44:04 <SamB> Stinger_: you mean like #-} might look like a smiley to gaim?
04:44:14 <dmwit> Yeah, but I'm not a programmer the whole time I'm on gaim... =P
04:44:18 <SamB> heh
04:44:20 <Stinger_> or something like (:)
04:44:29 <SamB> maybe you should use a real IRC client ;-)
04:44:42 <dmwit> Yeah, probably.
04:44:46 <Stinger_> gets turned into (<smiley face>
04:44:52 * SamB doesn't even know how to get gaim to connect to IRC
04:45:02 * SamB supposes it isn't hard, but hasn't bothered to try it
04:45:45 <Pupeno> Some time ago, someone made a page containing very nice diagrams of foldl and foldr... is that page stil somewhere ?
04:46:01 <SamB> @google foldl diagrams
04:46:04 <lambdabot> http://www.dcs.gla.ac.uk/~jtod/research/
04:46:04 <lambdabot> Title: John O'Donnell's Research
04:46:51 * SamB wonders if an image search would help?
04:46:54 <Pupeno> mh... searching the same string in google gives me another result.
04:46:56 * dmwit decides to symlink /foo/Hat to /foo/bar and use -i/foo
04:47:13 <SamB> Pupeno: yeah, @google is always feeling lucky
04:47:29 <Pupeno> SamB: I thought feeling lucky returned the first match, not the third.
04:47:39 <SamB> Pupeno: ideally yes!
04:47:49 <SamB> Pupeno: complain to google!
04:48:21 <SamB> maybe it personalizes the results... *shudder*
04:48:49 <SamB> hopefully lambdabot, having no cookie, gets no personalized results...
04:49:23 <SamB> huh huh huh!
04:49:28 <SamB> I get that third too!
04:49:39 <SamB> @google foldl diagrams
04:49:41 <lambdabot> http://www.dcs.gla.ac.uk/~jtod/research/
04:49:41 <lambdabot> Title: John O'Donnell's Research
04:49:47 <SamB> still that one
04:50:03 <Pupeno> I still can't find the diagram.
04:51:21 * SamB tries an image search
04:51:41 <Pupeno> I had no luck with that. The original was svg and there was a pdf version I believe.
04:53:04 <SamB> I don't suppose you remember what text was in it?
04:54:11 <Pupeno> not much, only foldl, and foldr and some other higher-order functions, expressed graphically.
04:55:07 <Pupeno> I'll ask my father, I've sent him a copy to print it and he doesn't delete anything... oh! then I may have it in my sent-mail.
04:57:14 <velco> http://myweb.lsbu.ac.uk/~abdallae/units/fp/listhofs.pd
04:57:16 <velco> http://myweb.lsbu.ac.uk/~abdallae/units/fp/listhofs.pdf
05:00:08 <Pupeno> velco: the ones I am talking about were all in one page (to hang on the wall) and they were really beautiful.
05:00:28 <SamB> Pupeno: found anything yet?
05:00:36 <Pupeno> nope.
05:01:27 <int-e> Cale linked to a svg once and to pngs a few times, but the links are dead. I suppose he still has the pictures though.
05:01:59 <Pupeno> int-e: that might be it.
05:02:30 <SamB> what was the filename for the SVG?
05:03:30 <int-e> folds.svg
05:03:39 <int-e> google for it, one hit ;)
05:04:19 <velco> hahah, irc log
05:06:45 * dmwit shudders at 587 lines of error messages
05:07:27 <foxy__> > True ~= False
05:07:28 <lambdabot>  Not in scope: `~='
05:09:12 * Pupeno should have saved the files.
05:09:39 <SamB> @google "folds.svg"
05:09:40 <lambdabot> http://tunes.org/~nef/logs/haskell/05.12.23
05:09:42 <int-e> @localtime Cale
05:09:43 <lambdabot> Local time for Cale is Sat Sep  2 08:05:39
05:09:52 <Pupeno> ok, maybe latter.
05:10:19 <SamB> same timezone as me ;-)
05:10:42 <int-e> 14 hours behind dons
05:11:27 <dmwit> SamB: me too.
05:15:51 <lisppaste2> Pupeno pasted "Are these implementations correct ?" at http://paste.lisp.org/display/25147
05:16:04 <Pupeno> Are those implementations of foldl and foldr correct ?
05:18:57 <int-e> looks good
05:19:51 <velco> Pupeno: going over the tutorial ?
05:21:56 <Pupeno> velco: for the second time, yes.
05:22:16 <velco> Pupeno: there are answers at the end
05:22:28 <Pupeno> the first time was very long time ago.
05:23:40 <velco> looked very familiar :D http://paste.lisp.org/display/25149
05:24:06 <SamB> oh, for a second there I thought you meant that you were answering for the second time ;-)
05:24:42 <velco> Pupeno: then don't look at the following paste
05:25:53 <lisppaste2> velco pasted "cps map filter" at http://paste.lisp.org/display/25150
05:25:59 <velco> do these look ok ?
05:26:09 <velco> (seem to work, no answer in the tut to verify though)
05:27:32 <SamB> @docsTest.QuickCheck
05:27:33 <lambdabot> Unknown command, try @list
05:27:34 <SamB> erg
05:27:37 <SamB> @docs Test.QuickCheck
05:27:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
05:27:48 <SamB> accidentally hit the insert key before adding an "s" ;-P
05:39:11 <foxy__> what is the operator for not equal?
05:39:41 <SamB> > 1 /= 2
05:39:42 <lambdabot>  True
05:39:48 <foxy__> heh
05:39:59 <foxy__> I tried (~=) (<>) (!=)
05:40:09 <sieni> but not the manual?
05:40:12 * sieni ducks
05:40:29 <SamB> you could have tried :i Eq ;-)
05:40:29 <xerox> ?hoogle Eq a => a -> a -> Bool
05:40:31 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
05:40:31 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
05:40:31 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
06:17:36 <integral> @type Control.Monad.liftM
06:17:37 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
06:17:52 <integral> @type (.)
06:17:53 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
06:18:38 <mauke> > ((*2) `liftM` (+1)) 5
06:18:39 <lambdabot>  12
06:21:54 <integral> @type \(f :: a -> b) (m :: env -> a) -> liftM f m
06:21:55 <lambdabot> forall b env a1. (a1 -> b) -> (env -> a1) -> env -> b
06:22:10 <integral> hmm, why did it rename a to a1?
06:23:17 <int-e> you had two different as
06:23:20 <xerox> Unifying?
06:23:30 <integral> oh, I see, so...
06:23:36 <int-e> @type \(f :: d -> b) (m :: env -> a) -> liftM f m
06:23:37 <lambdabot> forall b env a. (a -> b) -> (env -> a) -> env -> b
06:23:52 <int-e> so when unifying the types it had to rename one.
06:23:57 <int-e> or so.
06:23:57 <integral> @type forall a. \(f :: a -> b) (m :: env -> a) -> liftM f m
06:23:59 <lambdabot> Not in scope: `forall'
06:23:59 <lambdabot>  
06:23:59 <lambdabot> <interactive>:1:7: Not in scope: `a'
06:24:04 <integral> bleh, can't do that in haskell :-(
06:24:51 <xerox> Right, that's like \(f :: forall a b. a -> b) (m :: forall env a. env -> a) -> liftM f m.
06:26:17 <integral> @type \f m -> liftM f m :: (env->) z
06:26:18 <lambdabot> parse error on input `)'
06:26:24 <integral> @type \f m -> liftM f m :: (->) env z
06:26:26 <lambdabot>   Inferred type is less polymorphic than expected
06:26:26 <lambdabot>    Quantified type variable `z' is mentioned in the environment:
06:27:06 <xerox> ?type \f m -> liftM f (m :: env -> z))
06:27:08 <lambdabot> parse error on input `)'
06:27:22 <xerox> ?type \f m -> liftM f (m :: env -> z)
06:27:23 <lambdabot>   Inferred type is less polymorphic than expected
06:27:23 <lambdabot>    Quantified type variable `z' is mentioned in the environment:
06:27:25 <xerox> expr :: type -- ings the whole expr
06:27:42 <integral> @type \f m -> (liftM f m :: (->) env z)
06:27:43 <lambdabot>   Inferred type is less polymorphic than expected
06:27:44 <lambdabot>    Quantified type variable `z' is mentioned in the environment:
06:27:58 <integral> I wanted to type the (liftM f m) :-/
06:28:53 <integral> so the problem is that I've got an (implicit) forall z. there, and that can't unify with the tyvar from the type deduced for f?
06:29:55 <xerox> I don't know!
06:30:22 <integral> @type \(f :: y -> z) m -> (liftM f m :: (->) env z)
06:30:23 <lambdabot>   Inferred type is less polymorphic than expected
06:30:24 <lambdabot>    Quantified type variable `env' is mentioned in the environment:
06:30:38 <integral> @type \(f :: y -> z) (m :: (->) env y) -> (liftM f m :: (->) env z)
06:30:40 <lambdabot> forall env r a1. (a1 -> r) -> (env -> a1) -> env -> r
07:10:42 <dons> heh, http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
07:10:44 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki, http://tinyurl.com/mlvyg
07:11:26 <dons> and prize for the weirdest monad metaphor goes too...
07:11:45 <dons> and to think that monads-as-containers was controversial at one point
07:12:16 <Philippa> heh
07:16:52 <ndm> wow, thats pretty well written
07:17:06 <dons> it spoke to you?
07:17:14 <ndm> no ;)
07:23:14 <ndm> who did that Bob the monadic lover thing?
07:23:30 <ndm> Doesn't: newtype Lover a = Lover { loverDiary :: ([Name],a) } make more sense?
07:25:28 <int-e> or even [(Name,a)]
07:25:46 <int-e> next comes Data.Map ;)
07:25:52 <dons> just about to say ..
07:26:24 <beelsebob> hehe
07:26:37 <ndm> am map can only have one item of each key
07:26:44 <beelsebob> ndm: Data.Map should just be a Data.List of type (a,b) shouldn't it?
07:26:50 <beelsebob> and then other things are really easy to sort out
07:26:58 <ndm> what if he has two different women with the same name?
07:27:11 <ndm> beelsebob: for Hat purposes, yes - should be tirival to implement
07:27:15 <beelsebob> cool :)
07:27:15 <int-e> ndm: you apply alpha-conversion.
07:27:33 <ndm> int-e: in my experience, women do not support alpha renaming
07:27:37 <ndm> or variable shadowing
07:27:41 <dcoutts__> hah
07:27:56 <Igloo> why is hat having to do things specially?
07:27:57 <int-e> you can always rename the previous one.
07:28:06 <dons> we use a unique supply of ' to name members of our research group
07:28:11 <dons> sean, sean' ..
07:28:17 <dons> (really!)
07:28:25 <ndm> Igloo: cause it doesn't handle Data.Map, and doesn't build the heirarchical libraries properly
07:28:33 <ndm> (but might do, once they build with cabal)
07:29:11 <Igloo> ndm: What's the Data.Map problem, though?
07:29:38 <ndm> Igloo: no idea in particular, it may just be that no one has tried, although i think there is some feature that hat doesn't support in there...
07:30:45 <ndm> beelsebob: Igloo's question, what stops Data.Map from building?
07:31:08 <beelsebob> ndm: IIRC the need for Data.Typable
07:31:34 <ndm> beelsebob: really? Hugs doesn't have that, and in most cases it can be #if'd out
07:31:58 <beelsebob> hang on... I'll try putting it in the source tree and see what blows up then
07:32:25 <beelsebob> gyah... where do you get it from again?
07:32:32 <ndm> @where base
07:32:33 <lambdabot> I know nothing about base.
07:33:01 <ndm> @where+ base http://darcs.haskell.org/packages/base/
07:33:02 <lambdabot> Done.
07:33:19 <ndm> beelsebob: you should also add hat support to cabal :)
07:33:38 <beelsebob> ndm: I have *no* idea how cabal works
07:33:39 <beelsebob> so... no
07:33:53 <ndm> beelsebob: its quite cute :) not that hard
07:33:59 <Limbic_Region> Igloo - out of curiosity, any update on the Win32 binary build front?
07:34:04 <ndm> a little broken around the edges, but nothing too bad :)
07:34:12 <Limbic_Region> and again, thanks for everyone's help last night
07:35:07 <Igloo> Limbic_Region: Not yet
07:38:14 <Limbic_Region> ok, I am working with audreyt over in #perl6 to see if she can resolve what I believe to be the last failure preventing pugs from building
07:38:14 <beelsebob> ndm: atm... hat-trans: Unknown preprocessor directive at line 183 in file "Data/Map.hs"
07:38:15 <beelsebob> if __GLASGOW_HASKELL__
07:38:22 <Limbic_Region> I don't believe it to be a ghc issue
07:38:25 <ndm> beelsebob: cpphs :)
07:38:26 <Limbic_Region> she may say otherwise
07:39:03 <Limbic_Region> so when ghc 6.6 is finally released, will the extralibs be part of the Win32 .msi?
07:39:09 <beelsebob> ndm: indeed... you can't rely on that when building hat
07:39:14 <ndm> beelsebob: a perfect change to practice with cabal, darcs get cpphs, then build it :)
07:39:20 <beelsebob> shall I just take out the __GLASGOW_HASKELL__ sections?
07:39:20 <ndm> beelsebob: why not?
07:39:30 <ndm> beelsebob: yeah, i guess
07:39:36 <beelsebob> because it adds a dep, and people will not be happy with it
07:39:56 <ndm> people aren't happy with Hat because it doesn't work, no because of dependancies :)
07:40:08 <ndm> and not working with Data.Map is a biggie
07:40:17 <ndm> plus hmake is a bad dependancy, cpphs is nice and easy
07:40:32 <ndm> anyway, cabal is the way forward for hat-trans
07:40:59 <ndm> you might want to do cpphs on the code first anyway manually
07:41:05 <ndm> to save you doing the preprocessing by hand
07:41:17 <ndm> and any chance of Data.Set, Data.IntMap, Data.IntSet ?
07:41:41 <ndm> with those, i think i'll be able to get hoogle going through
07:55:22 <beelsebob> ndm: it appears... a big dependancy chain
07:55:37 <beelsebob> Control/Applicative... which requires Control/Monad/Instances....
07:55:42 <ndm> beelsebob: in that case, you should be able to fake it in a few minutes
07:55:50 <beelsebob> ndm: indeed
07:55:56 <beelsebob> I'm just trying dep chasing at the mo
07:56:09 <SamB> why are you using slashes instead of dots?
07:56:10 <ndm> beelsebob: and once you have that faked, you can fake Set, IntSet and IntMap from the same faked original
07:56:27 <ndm> SamB: cause he has to run and find the file each time, and manually compile it!
07:56:33 <yip> gour_: haven't exactly tried yet :\
07:57:00 <ndm> beelsebob: although be aware that the runtime behaviour will be different - for example with a non-transitive ==, Data.Map can non-terminate
07:57:07 <ndm> but not enough to worry about
07:57:08 <beelsebob> indeed
07:57:36 <SamB> non-transitive ==?
07:57:38 <SamB> is that allowed?
07:57:53 <SamB> isn't there a law for the Eq class forbidding it?
07:58:20 <ndm> SamB: a law, but not an enforced law
07:58:34 <ndm> its highly not recommended :)
07:59:10 <ndm> nhc98 had a non-transitive Eq instance for file positions, i spent 6 hours trying to track that down...
07:59:21 <SamB> anyone who did it on purpose... well... is either an idiot or just asking for trouble...
07:59:56 <ndm> yeah, it wasn't on purpose
08:00:03 <SamB> I know
08:00:19 <ndm> Pos had a column number, and a line number
08:00:22 <SamB> because idiots don't write Haskell compilers
08:00:38 <ndm> and if the column number was -1, that means that there is no column
08:00:59 <ndm> and the test didn't take that into account in some way in some direction
08:01:09 <ndm> SamB: ever read the type checker for Yhc?
08:01:15 <SamB> no!
08:01:26 <ndm> you might take back your idiots comment :)
08:01:36 <SamB> are you implying that it looks like it was written by idiots?
08:01:50 <SamB> well I bet if I wrote a typechecker it would look *and* act as if it was written by idiots
08:02:05 <ndm> yep, the Yhc one does both
08:02:18 <SamB> does it check types?
08:02:20 <ndm> its complex, and got a lot of legacy in it, before type checkers were well understood
08:02:22 <ndm> somewhat
08:02:36 <ndm> it doesn't support haskell 98, but no one has any idea where it differs
08:02:46 <ndm> it doesn't do kind inference, which is required for haskell 98
08:02:48 <SamB> why isn't it replaced?
08:02:55 <ndm> but somehow, it seems to get away with it
08:03:03 <ndm> there is a SoC project to do that, we're waiting for the result
08:03:09 <SamB> oh rly?
08:03:17 <SamB> but SoC was over last month!
08:03:39 <beelsebob> SamB: the people who wrote yhc's typechecker say it looks like it was written by idiots
08:04:19 <SamB> beelsebob: that is because it *does* look like it was written by idiots
08:07:18 <kolmodin> I'm trying to do a "withValue :: forall a b. Arg a => Value -> (a -> b) -> b" but I'm getting my ass kicked. Isn't this possible?
08:07:59 <kolmodin> withValue v f = case v of ValueByte x -> f x ; _ -> undefined
08:09:02 <Lemmih> kolmodin: How do you make sure 'x' is of type 'a'?
08:09:16 <kolmodin> mmm...
08:09:29 <beelsebob> ndm: it would appear I've found the problem
08:09:43 <beelsebob> Data/Foldable.hs won't traslate because hat-trans's type checker is borken
08:09:55 <kolmodin> because data Value = ValueByte Word8,   and I have a instance Arg Word8
08:10:07 <kolmodin> not a valid reasoning?
08:10:33 <SamB> beelsebob: it too looks as if it was written by idiots?
08:10:46 <beelsebob> SamB: IIRC it's the same one
08:13:59 <Lemmih> kolmodin: How about using GADTs?
08:14:10 <kolmodin> Lemmih: I have to read up on that :)
08:14:16 <kolmodin> would that solve my problem?
08:14:27 <Lemmih> kolmodin: Yeah.
08:14:47 <kolmodin> Lemmih: ok, I wasn't sure it would. worth picking up then
08:15:28 <kolmodin> I think I've put a paper about that somewhere arond here...
08:16:23 <Lemmih> kolmodin: This works: data Value a where ValueByte :: Word8 -> Value Word8; withValue :: Value a -> (a -> b) -> b
08:17:03 <kolmodin> Lemmih: nice, thanks
08:17:30 <kolmodin> btw, how portable is GADTs?
08:17:34 <kolmodin> only ghc?
08:18:31 * vincenz hmms
08:18:34 <vincenz> interesting
08:19:32 <vincenz> that might be a downside of haskell
08:19:50 <vincenz> the complexity of what the language and compiler do preclude a lot of experimentation within lots of compilers
08:22:20 <Lemmih> Hurrah for Haskell', then.
08:23:12 <ndm> beelsebob: doh, any way round foldable? could you write a custom foldable and get lots of things for free?
08:33:28 <yip> is there such a thing as GHC 6.6 RC?
08:33:40 <ndm> yip: yes, was announced yesterday
08:34:25 <yip> ndm: is it better than ghc-6.5.20060901?
08:35:04 <ndm> yip: it was defined as a particular nightly build
08:35:24 <ndm> yip: 6.5.20060831
08:35:35 <ndm> that is the official release candidate
08:35:49 <yip> ndm: i see... so should i get 6.5.20060831 or 6.5.20060901?
08:35:58 <ndm> yip: i have no idea :)
08:36:08 <ndm> yip: i guess 0831
08:36:17 <yip> ndm: really?
08:36:19 <ndm> but i suspect there are very few changes, if any, between them
08:36:29 <ndm> thats what they claimed as RC
08:36:40 <ndm> so that RC should be the most stable one
08:36:48 <ndm> although, in reality, there are probably no differences
08:36:52 <ndm> flip a coin :)
08:37:11 <yip> when a coin is flipped i always end up losing :(
08:37:30 <ndm> hehe, then reverse it :)
08:38:10 <esap> Just guess that the coin will stand on its edge...
08:40:11 <ski> hiya esap
08:40:18 <esap> ski: Hi!
08:40:28 <esap> ski: what's up?
08:40:54 <ski> nothingmuch
08:41:20 <ski> been thinking on various small things
08:42:01 * esap has been reading "Advanced topics in Types and Programming languages".
08:42:19 <ski> have e.g. read about allegories in "Algebra of Programming"
08:42:37 <esap> ski: what are those?
08:43:00 <ski> think : like Categories, but for (binary) relations, instead of functions
08:43:28 <ski> (it's an extension of the category concept .. all allegories are categories)
08:44:04 <esap> ski: Is it somehow built on pullbacks?
08:44:19 <ski> i don't think so
08:44:36 <esap> ski: Because pullbacks can be used to compose relations
08:44:51 <ski> possibly one could build some concrete allegories that way .. but it's not included in the abstract specification
08:45:35 <ski> esap : i assume you mean when relations are represented as subobjects of product of the domain and the codomain
08:46:00 <esap> ski: yes.
08:46:12 <ski> but that is a particular implementation
08:47:19 <esap> ski: yes I suppose you can build an abstract specification of relations
08:47:38 <ski> there are particulary appealing definitions of 'total','surjective','injective','"functive"' in an allegory
08:47:49 <ski> esap : yes .. allegories in one such
08:48:08 <esap> ski: Though I'm wondering if that would run into Rice's theorem.
08:48:24 <ski> which is ?
08:48:43 <esap> ski: see http://en.wikipedia.org/wiki/Rice's_theorem
08:49:52 <esap> ski:Basically that the only possible subsets of Recursively enumerable languages that are not undecidable are the empty set and the full collection of all recursively enumerable languages
08:50:20 <esap> (I hope I'm not misrepresenting it :-)
08:50:34 <ski> forall R : A -> B. total R  <=>  id_A =< R^ . R
08:50:51 <ski> forall R : A -> B. surjective R  <=>  id_B =< R . R^
08:51:21 <ski> forall R : A -> B. injective R  <=>  R^ . R =< id_A
08:51:42 <ski> forall R : A -> B. functive R  <=>  R . R^ =< id_B
08:52:06 <ski> 'R^' is the converse relation of 'R'
08:52:34 <ski> esap : what do you think about those ?
08:52:37 <esap> That reminds me of something that was said in "Sets for mathematics" regarding transitivity.
08:52:47 <ski> mhm
08:52:57 <esap> and reflexivity
08:53:14 <kolmodin> Lemmih: in the example that I gave you above, naturally Value has more constructors
08:53:21 <xerox> What are '^' and '=<' ?
08:53:50 <esap> "Relation R ---> XxX on X is transitive iff R o R \in_XxX R
08:53:57 <ski> forall R : A -> A. reflexive R  <=>  id_A =< R
08:54:15 <ski> forall R : A -> A. transitive R  <=>  R . R =< R
08:54:36 <ski> forall R : A -> A. symmetric R  <=>  R =< R^
08:55:01 <ski> forall R : A -> A. anti_symmetric R  <=>  R /\ R =< id_A
08:55:04 <Lemmih> kolmodin: That's ok.
08:55:19 <ski> xerox : ' is relation converse, '=<' is relation containment
08:55:30 <kolmodin> so how would withValue look like?
08:55:36 <ski> arg
08:55:42 <kolmodin> hi araujo!
08:55:53 <ski> s/' is/'^' is/
08:56:03 <araujo> hi hi!
08:56:07 <araujo> kolmodin!
08:56:20 <kolmodin> :)
08:56:31 <ski> '/\' is intersection
08:56:42 <ski> in the allegory Rel (like Set, but for relations) :
08:56:51 <esap> ski: I wasn't aware of this type of definitions for totality, surjectivity and injectivity.
08:57:10 <ski> b R^ a <=> a R b
08:57:20 <ski> a1 id_A a0 <=> a0 = a1
08:57:43 <kolmodin> Lemmih: something like   withValue v f = case v of ValueByte x -> f x; ValueString x -> f x      doesn't work, as expected
08:57:51 <ski> b (R /\ S) a <=> b R a /\ b S a
08:57:58 <Lemmih> kolmodin: How did you expect it to work?
08:58:27 <ski> c (S . R) a <=> exists b. c S b /\ b R a
08:58:56 <ski> R =< S  <=>  forall a b. b R a => b S a
08:59:00 <kolmodin> Lemmih: I don't know :)
08:59:33 <ski> (xerox,esap : hope that explains the basic constructs somewhat)
09:00:25 <esap> ski: Yea, those are clear since I've read Sets for mathematics, which uses some of those.
09:00:38 <ski> esap : and (at least in Rel)  mono R <=> total R /\ injective R  and  epi R <=> surjective R /\ functive R
09:00:55 <esap> ski: But it's actually good to see there are consistent formulations of many concepts in terms of such relations
09:01:36 <ski> also,  functional R <=> total R /\ functive R  (and  "cofunctional" R <=> surjective R /\ injective R  )
09:02:17 <esap> ski: I'm not familiar with the concept 'functive'.
09:02:24 <ski> own term
09:02:38 <ski> (i don't know a good, generally accepted one)
09:02:53 <ski> it means that no input maps to multiple outputs
09:03:13 <ski> (compare with 'functional dependency')
09:04:02 <ski> 9;2~(whereas i'm using 'functional' to mean roughly that each input maps to exactly one output)
09:04:27 <esap> ski: maybe "single-valued mapping" is a good term for that?
09:04:46 <ski> a bit too long :/ :)
09:04:48 <Bluelive> i wasn't aware of a type of function that mapped a value to multiple results
09:05:03 <ski> Bluelive : this is relations, not functions
09:05:08 <johnnowak> sqrt could map to two results.. :)
09:05:16 <ski> hehe
09:05:30 <SamB> relations have inputs and outputs?
09:05:39 <esap> ski: or actually even better term is "f is a function", then it's obvious it's single-valued.
09:05:50 <ski> SamB : figuratively speaking (this is binary relations)
09:06:01 * esap thinks of relations as not having '
09:06:02 <Bluelive> johnnowak: only if you take sqrt() == sqr-1()
09:06:20 * esap thinks of relations as not having 'input' and 'output', rather just links between values
09:06:49 <SamB> esap: I thought they *were* links between values?
09:06:50 <ski> the important thing is that it is directed (ordered pairs)
09:07:16 <esap> SamB: No, a relation is more like a collection of links. A link is like a pair of values.
09:07:34 <SamB> hmm...
09:07:37 <SamB> whatever...
09:07:54 * esap makes distinction between links and associations.
09:08:13 * johnnowak prefers the terms 'innies' and 'outies'
09:08:33 <esap> heh
09:08:36 <ski> esap : btw, did you mean "single-valued mapping" for "maps to exactly one output", or "maps to at most one output" ?
09:09:08 <esap> ski: exactly one
09:09:17 <ski> ok
09:09:32 <ski> (my (and the book's) 'functional', i.e.)
09:09:43 <ski> (as opposed to my 'functive')
09:09:58 <_Codex> a->_|_, does it have exactly one output or 0 outputs?
09:10:27 <esap> codex: depends on how many elements you have in _|_ :-)
09:10:37 <xerox> Bottom as a type?
09:10:49 <ski> (actually, the book uses s/functive/simple/, s/total/entire/)
09:11:27 <xerox> undefined :: forall a b. a -> b -- has infinite inputs and no output!
09:12:16 * ski thinks _Codex meant that as a single "link", not asa type
09:12:39 <xerox> ?type const undefined -- like this?
09:12:45 <lambdabot> forall a b. b -> a
09:13:11 <ski> possibly
09:14:11 <ski> esap : one cool thing i saw in "Toposes, Triples and Theories" was the idea of "cograph"
09:14:20 <esap> ski: yes, that is cool
09:14:31 <esap> ski: external and internal diagrams
09:14:46 <esap> ski: It's explained in detail in "Sets for mathematics"
09:14:47 <xerox> It's even mentioned in the first pages of `Sets for Mathematics' !
09:14:47 <ski> i.e. like the cograph of a functional relation
09:14:52 <xerox> :)
09:15:41 <esap> ski: one of the nice things is that graph (of a function) is dual to the cograph of the function. (Which is obvious from the terminology).
09:15:58 <esap> ski: But both have similar nice properties...
09:16:04 <ski> yes, equivalent ways of expressing the functional relation
09:16:57 <esap> ski: I've been thinking about cographs of epimorphic r : A+B -> R.
09:17:02 <ski> but cograph for (ordinary) relations seems to be weaker than graph for them
09:17:16 <ski> esap :)
09:17:30 <ski> "Sets for mathematics" ?
09:17:45 <esap> ski: no, it didn't have that one
09:17:54 <ski> "Sets for mathematicians", by Lawvere ?
09:17:59 <esap> ski: yes
09:18:12 * ski hasn't managed to get hold of that one, yet
09:18:14 <ski> :/
09:18:22 * esap misread that one :-(
09:18:28 <_Codex> good book
09:18:40 <esap> mathematics, not mathematicians
09:18:41 <xerox> If you went to AngloHaskell you'd be very near Cambridge University Press :)
09:18:54 <yip> yikes, where can i get a libreadline.so.4 binary?
09:19:08 <ski> esap : ok, so it is anothe book then ? (or do i misremember the title ?)
09:19:42 <xerox> I think I have a photo...
09:19:55 <esap> ski: It's "Lawvere,Rosebrugh: Sets for Mathematics"
09:20:03 <ski> ok
09:20:34 <ski> esap : so what were you thinking on quotients over coproducts ?
09:20:34 <esap> ski: http://www.mta.ca/~rrosebru/setsformath/
09:20:36 <lambdabot> Title: SETS FOR MATHEMATICS by F. WILLIAM LAWVERE AND ROBERT ROSEBRUGH
09:20:46 <ski> (ty)
09:21:05 <xerox> Imageshack is so slow...
09:21:18 <esap> ski: About their cographs
09:21:38 <ski> esap : err, i'd say they would *be* cographs
09:22:33 <xerox> <http://img483.imageshack.us/my.php?image=03082006001ai4.jpg>
09:22:35 <xerox> :D
09:22:36 <esap> ski: I mean, epimorphic maps r : A+B -> R. Which I believe is dual to a relation.
09:22:57 <ski> (btw, one thing that allegories has made me think about (again) is unique-quantifiers)
09:23:02 <esap> ski: You can link elements of the domain with the cograph picture
09:23:12 <xerox> When I saw it I said "Argh! I payed shipment to Italy for nothing!"
09:23:14 <esap> ski: and you can link elements of the codomain with the cograph picture
09:24:13 <esap> ski: Think of A+B -> R as two arrows, A -> R and B -> R, where R is common
09:24:32 <ski> i'd say, in Set, cograph specifies relations that are a subclass of those specified by graphs
09:24:36 <ski> or is that wrong ?
09:26:28 <esap> ski: Why would the subclass relation be there?
09:27:09 <esap> ski: A graph, in essence, specifies a n-dimensional space. A cograph, in contrast, specifies a relationship between two spaces.
09:27:53 <ski> (basically, if 'b0 R a0' and 'b0 R a1' and 'b1 R a1' then 'b1 R a0' must hold for relations 'R' specified by a cograph)
09:30:45 <ski> (esap : btw, that contrast between graph and cograph is basically contrast between multiplicative and additive connectives, i think :)
09:31:14 <esap> ski: maybe
09:31:45 <esap> ski: dimensions vs. alternatives
09:32:00 <ski> (i bet in Complete Atomic Boolean Algebra (CABA), that contrast is reversed)
09:33:12 <esap> ski: What does the atomic part mean?
09:35:11 <ski> i'm not sure .. but i've read that CABA should be dual to Set :)
09:35:45 <esap> I found a definition: A BA is atomic if every nonzero element of the BA is above an atom.
09:35:50 <ski> (my bro' says dual to more general boolean algebras are stone spaces)
09:36:16 <ski> ok
09:37:08 <ski> hm .. one thing they do in the book is to define datatypes over (tabular) allegories
09:37:32 <esap> where can I find a definion of an allegory?
09:37:43 <ski> and since the opposite of an allegory is the same allegory, categorical products and coproducts coincide
09:38:25 <ski> so, their "sum" is the categorical product/codrpduct
09:38:28 <esap> ski: hmm.. is there some connection with vector spaces. I think vector spaces have that property as well
09:39:04 <ski> and they define a different "relation product" (not categorical product) (i'm tempted to call it the 'tensor product" :)
09:39:43 <ski> esap : yes, i'm reminded by vector spaces when i read about this :)
09:41:47 <irgs> hello there
09:41:52 * esap googled for allegory and found reference to a book called "Freyd, Scedrov: Categories, Allegories"
09:42:01 <ski> "An allegory A is a category endowed with three operators in addition to target, source, composition and identities. These extra operators are inspired by the category Rel of sets and relations. Briefly we can compare relations with a partial order =<, take the intersection of two relations with /\, and take a relation to its converse with the unary operator (_)^. The purpose of this section is to describe these operators axiomatically."
09:42:34 <ski> yes, Freyd seems to have worked on allegories (though i've not read anything by him on that (yet))
09:42:40 <ski> hello irgs
09:42:56 <carp_> esap: I've got that book it's a bit eccentric
09:43:26 <irgs> i'm experimenting with hsp, using hspr. i managed to compile and install it, but when trying to evaluate a test page, it says "unknown symbol `HSPziData_zdfIsXMLXML_closure'"
09:43:42 <irgs> any ideas?
09:44:48 * ski has not used hsp ..
09:45:14 <ski> (that sounds like a linker error, of some sort)
09:45:16 * esap goes to get something to eat. bbl.
09:46:02 <irgs> hm well, the linker should know where everything is, as all packages have been installed with cabal, shouldn't it?
09:46:20 <ski> esap : would you like me to state the axioms for those three operators, from the book ?
09:49:33 <zeeeeee> hi all, is currying just a special case of partial function application? (i always see folks making a point of distinguishing currying from partial function application, but they seem to get at the same thing)
09:49:59 <zeeeeee> (special case where you must do partial function application one param at a time from left to right)
09:50:42 <ski> currying is having a function take one argument and return another function that takes next argument
09:51:27 <ski> i.e. a function can be curried, and a function application can be a partial application
09:51:57 <ski> (a function can not be a partial application, and a function application can't be curried)
09:52:11 <ski> one term refers to functions. the other to applications of functions
09:52:17 <ski> (that's my understanding)
09:52:28 * ski goes to eat dinner
09:53:18 <carp_> ?type curry
09:53:20 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
09:53:36 <mauke> ?. djinn type curry
09:53:38 <lambdabot> f a b c = a (b, c)
09:54:06 <yip> ok so where exactly is the hIDE darcs repository? there seem to be 3 different ones in darcs.haskell.org
09:54:19 <Korollary> zeeeeee: This comment can be relevant: http://srfi.schemers.org/srfi-26/mail-archive/msg00000.html
09:54:22 <lambdabot> Title: It's not currying!, http://tinyurl.com/ee5bf
10:07:03 <lennart> ?users
10:07:06 <lambdabot> Maximum users seen in #haskell: 220, currently: 206 (93.6%), active: 32 (14.5%)
10:09:30 <irgs> ski: hmm, the problem was that the HSP library was installed in my home directory, and ghc didn't seem to look for the library there..
10:12:43 <yip> @seen Lemmih
10:12:43 <lambdabot> Lemmih is in #ghc, #haskell-overflow and #haskell. I last heard Lemmih speak 1 hour, 14 minutes and 47 seconds ago.
10:12:48 <yip> @seen gour_
10:12:48 <lambdabot> gour_ is in #haskell. I don't know when gour_ last spoke.
10:13:07 <ski> (irgs : ok)
10:13:11 <ndm_> irgs: did you do runhaskell Setup install after?
10:13:26 <ndm_> that should tell GHC where it put the package
10:13:27 <irgs> ndm_: yes, with --user
10:13:29 <Korollary> hi lennart
10:13:44 <ndm_> irgs: then thats probably a cabal bug, shoot the nearest cabal developer :)
10:13:51 <lennart> hi
10:14:18 <ndm_> irgs: or send an email to cabal-devel@   haskell DOT org with the details
10:14:36 <irgs> ndm_: k, thanks
10:14:54 <ski> (though, there was one person who wanted to reserved 'curried function' for staged functions .. i.e. that does non-trivial work between the curried arguments)
10:15:03 <Korollary> do you need to pass --user to setup.hs install? I dont remember.
10:15:09 <ski> (s/reserved/reserve/)
10:15:44 <ndm_> i beleive passing --user at register time is the design
10:15:58 <ndm_> but if it works at install time, then it should still get the GHC package info right - but i guess it doesn't
10:16:35 <Lemmih> yip: Yo.
10:16:55 <yip> Lemmih: hey.... where is the darcs repos for hIDE?
10:17:24 <Lemmih> yip: Here: http://darcs.haskell.org/hIDE/
10:17:26 <lambdabot> Title: Index of /hIDE
10:17:35 <yip> Lemmih: thanks man, let's see if this shit compiles!
10:17:38 <Korollary> I would rerun setup.hs install with verbose output
10:19:18 <yip> Lemmih: the README in that says: darcs get --partial http://darcs.haskell.org/ghc.hide
10:19:19 <lambdabot> Title: Index of /ghc.hide
10:19:30 <yip> Lemmih: should i run that command now?
10:24:44 <Lemmih> yip: ghc.hide is a frozen version of ghc. Other versions may not be able to compile hide.
10:25:26 <yip> Lemmih: what about ghc-6.5.20060901?
10:35:23 <yip> @seen dcoutts
10:35:24 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
10:35:51 <dcoutts__> @yarr
10:35:51 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
10:35:54 <dcoutts__> ahem
10:36:13 * dcoutts__ gets his wireless connection back
10:36:21 <yip> dcoutts: hi! i've got latest gtk2hs darcs, but i try "autoconf" and it fails :(
10:36:32 <dcoutts__> try autoreconf
10:37:17 <cm> what's the difference between all those autotools anyway? :)
10:38:34 <yip> cool seems to work thanks
10:38:39 <yip> but i need happy :(
10:40:21 * monochrom hands yip some happiness
10:41:54 <ski> Happy Happy Joy Joy.
10:43:03 <yip> how come happy doesn't come with ghc?
10:44:01 <monochrom> because ghc doesn't come with Mac OS X
10:46:45 * xerox pokes monochrom 
10:48:47 <yip> argh! happy doesn't compile! "LALR.lhs:626:34: Not in scope: `bounds'"
10:49:04 <lispy> happy not happy
10:49:46 <monochrom> this is odd
10:50:18 * ski peeks esap
10:54:41 * lispy gives lambdabot on windows another go
10:57:17 <yip> anyone have some ideas about this 'bounds' error?
10:58:48 <lispy> yip: can you find the bounds function?
10:59:20 <yip> lispy: no
10:59:48 <lispy> then no wonder ghc can't :)
10:59:57 <lispy> i'ne never used happy
11:00:48 <yip> > bounds 5
11:00:50 <lambdabot>  add an instance declaration for (Num (Array i e))
11:00:56 <lispy> @hoogle bounds
11:00:57 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
11:00:57 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
11:00:57 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
11:01:21 <lispy> maybe add import Data.Array (bounds) to the top the file?
11:04:31 <Igloo> bounds moved between 6.4.x and 6.6
11:05:23 <waern> yip, your problem is that your ghc version is not in synch with the latest libraries
11:05:27 <ndm_> lispy: no chance! no lambdabot plus windows
11:05:40 <ndm_> lispy: btu i am working on it, trying to slowly get things sorted
11:05:49 <cm> lambdabot likes windows, he told me once
11:05:50 <lispy> ndm_: oh, i was working on it too
11:06:06 <waern> yip, or whatever you are building are not synch with them
11:06:08 <ndm_> lispy: neat, i have to go now, but will talk later!
11:06:10 <ndm_> bye
11:06:34 <lispy> ndm_: right now i'm chasing some cabal issue...for some reason if i'm working out of a directory on my C: drive ghc cannot find cabal...but if i'm on my network drive (H:) cabal is found...weird huh?
11:07:34 <SamB> lispy: and where is cabal?
11:08:34 <dcoutts__> use configure -v to see where cabal is looking for ghc
11:08:50 <dcoutts__> oh, sorry other way around
11:09:41 <lispy> cabal is in C:\ghc\ghc-6.4.1\imports
11:09:54 <lispy> at least Distribution.Simple (which is not being found) is in there
11:09:55 <yip> waern, Igloo: so what should i do?
11:10:06 <lispy> yip: just need to change your import statements
11:10:36 <lispy> but ghc is looking in \usr\local\Haskell... which doesn't exist
11:11:03 <SamB> lispy: but does it exist on the H: drive?
11:11:11 <lispy> trying to check
11:11:32 <lispy> it's so inefficent in windows to get to file browsing :)
11:11:33 <SamB> I thought it might involve an "absolute" path with no drive letter...
11:12:06 <lispy> hm...my H:\ drive has died
11:12:08 <lispy> grrr
11:12:33 * lispy tries from osx
11:13:09 <lispy> oh dmm...
11:13:18 <lispy> maybe the server really is having problems
11:19:13 <lispy> that path does not exist on the network drive
11:19:50 <yip> another error: ProduceCode.lhs:31:20: Not in scope: `Data.Array.MArray.indices'
11:20:06 <lispy> @hoogle indices
11:20:06 <lambdabot> Array.indices :: Ix a => Array a b -> [a]
11:20:07 <lambdabot> Data.Array.indices :: Ix i => Array i e -> [i]
11:20:07 <lambdabot> Data.Array.IArray.indices :: (HasBounds a, Ix i) => a i e -> [i]
11:20:46 <lispy> yip: can you get a version of happy which has been ported to 6.6?
11:21:52 <lispy> oh wait, it is on the network direv
11:21:58 <lispy> i just over looked it
11:22:09 <lispy> in fact, that's where cabal is
11:22:53 <lispy> geez that's lame
11:23:39 <lispy> or
11:23:40 <lispy> er
11:26:00 <tibbe> lispy: what are you talking about? :D
11:27:52 <lispy> tibbe: why does it install things to my network drive when the rest of the instalation is on C:\ and then not be able to find it
11:28:19 <tibbe> dunno
11:36:06 <SamB> missing drive letters, maybe!
11:36:21 <SamB> drive letters are rather a pain, are they not?
11:36:32 <lispy> agreed!
11:36:36 <SamB> Amiga's system is much nicer ;-)
11:36:39 <lispy> but why does it have to do it wrong! ;)
11:36:44 <ski> SamB : hehe
11:36:49 <SamB> did Mac do that too?
11:37:09 <lispy> mac uses mount points under /
11:37:09 <SamB> not that I have ever used a real amiga, but I've played with UAE a bit
11:37:18 <ski> (hm, drive letters come from CP/M, yes ?)
11:37:21 <SamB> lispy: I meant old mac, actually
11:37:27 <lispy> SamB: oh
11:37:43 <lispy> so, it looks like i'm forced to build/install from my C: drive if i want sanity
11:37:47 <SamB> I could start bII, but I don't feel like it
11:37:51 * ski has an A1200 and an A3000
11:37:59 <SamB> it looks like you are forced to file a bug!
11:38:02 <ski> (um, and an A500)
11:38:17 <lispy> SamB: who is the bug with? cabal? ghc? windows?
11:39:29 <lispy> gr..what manner of cygwin install is this...no vi or emacs...hmm
11:39:33 <SamB> well, who tried to install the packages?
11:39:39 <SamB> er, files.
11:39:40 <lispy> me
11:39:42 <yip> alright, i got happy installed, but now i need alex! :-=
11:39:58 <SamB> no, I meant which package tried to install files?
11:39:58 <gour> yip: i see you are having fun...
11:40:00 <SamB> cabal or GHC?
11:40:04 <SamB> it isn't Windows
11:40:12 <yip> gour: all this to get gtk2hs installed so i can try compiling hIDE
11:40:17 <SamB> windows is *supposed* to have drive letters, for better or worse
11:41:33 <gour> yip: i also had too many issues in the past in the attempt to build hIDE. otoh, I'd like to have native IDE on Linux...what do you think to offer some bounty so that someone picks up the development?
11:41:36 <lispy> *** Exception: ./.setup-config: openFile: permission denied (Permission denied)
11:42:13 <SamB> I think you need a decent escrow service
11:43:12 <lispy> gour: well, in the linux world emacs, vi or something like that is considered a good ide
11:43:29 <SamB> except for the fact that not a one of them is good
11:43:41 * lispy likes emacs just fine
11:43:53 <SamB> most of them are considerably better than nothing
11:44:00 <lispy> it's better than visual studio when what you need to do is edit your code :)
11:44:04 <gour> lispy: emacs - life is too short for learning it. vi(m) - i use it, but would like something better
11:44:32 <lispy> i find visual studio is really good when i want to look busy
11:44:43 <Korollary> and professional
11:44:52 <Korollary> emacs makes me look like a hippie
11:44:57 <lispy> true
11:45:05 <dcoutts__> gour: you're welcome to work on it :-)
11:45:08 <lispy> especially with my neo on black color scheme
11:45:14 <lispy> er neon
11:45:22 <gour> dcoutts__: i'm missing (some) skills
11:45:31 <dcoutts__> gour: how's that going btw?
11:45:32 <Korollary> enterprise service-oriented architecture xml oracle amen. Now I am good.
11:45:45 <dcoutts__> gour: you were doing pretty well with that book iirc
11:45:49 <yip> gour: i have zero money
11:46:06 <yip> gour: but i am myself interested in some sort of haskell IDE
11:46:15 * dcoutts__ too
11:46:22 * waern too 
11:46:23 <SamB> you just need to open the little watchacallit thingy with the treeview...
11:46:36 <dcoutts__> aye, that's step 1
11:46:38 <SamB> ah, speedbar
11:47:00 <SamB> if you want to look like you are programming ;-)
11:47:08 <gour> dcoutts__: after returning from india, i didn't even have enough time to resume my jyotish study, too much travelling...
11:47:09 <dcoutts__> I got a experimental version of that working with the new gtk2hs tree view system
11:47:24 <dcoutts__> and it updates live using kolmodin's inotify bindings
11:47:39 <gour> dcoutts__: however, on monday, i'll resume my study (hopefully both jyotish & haskell)
11:47:50 <waern> dcoutts, cool
11:47:52 <dcoutts__> I just need to extend it to be a full tree rather than a single flat dir I tried as an experiment
11:48:14 <dcoutts__> gour: great
11:48:29 <gour> dcoutts__: moreover, i'm still fighting that my project will be realized in haskell :/
11:48:35 <dcoutts__> ah
11:48:46 <gour> but i'm not giving up (so easily :-)
11:48:55 <gour> it's too good ;)
11:49:30 <ihope_> So what was that dynamic scoping or whatever thing?
11:49:31 <SamB> who are you fighting with?
11:49:41 <SamB> ihope_: you mean implicit bindings?
11:49:50 <ihope_> SamB: maybe. What're those?
11:50:00 <lispy> hmm...so the big hurdle with lambdabot on would be...Posix signals i think
11:50:10 <lispy> s/on /on windows /
11:50:19 <SamB> @google site:haskell.org/ghc 'implicit bindings'
11:50:21 <lambdabot> http://www.haskell.org/ghc/docs/5.04.3/html/users_guide/release-5-04.html
11:50:33 <SamB> @google site:haskell.org/ghc 'implicit parameters'
11:50:35 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/type-extensions.html
11:50:35 <lambdabot> Title: 7.4. Type system extensions
11:50:40 <SamB> oh, was that the name
11:50:46 <SamB> implicit parameters
11:51:01 <ihope_> Yeah, that's it.
11:51:08 <ihope_> Can those be bound in do blocks?
11:51:12 * SamB wishes google could find the nearest anchor too...
11:51:13 <ski> dynamic scoping with static types
11:51:14 <ihope_> do ?handle <- foobar; ...
11:51:41 <SamB> you can do that?
11:51:44 <ski> do let ?handle = ...
11:51:55 <ski> not sure about monadic bindings
11:51:57 <ihope_> do handle <- foobar; let ?handle = handle?
11:52:16 <SamB> ihope_: should work...
11:52:19 <ski> ihope_ : at least latter should work, methinks
11:52:20 <ihope_> s/the ? at the end/ -- ?/, if you don't like punctuation in your Haskell code.
11:52:53 <ski> ('handle?' started looking like a scheme identifier :)
11:54:05 <ihope_> (cond (handle? x) (process x) (error (mung x)))
11:54:58 <dolio> :) You're missing some parens, I think.
11:56:38 <SamB> just stick on a few cards full of parens ;-)
11:59:53 <ihope_> Missing some parens?
12:00:00 <ihope_> I don't think so...
12:00:21 <gour> dcoutts__: so, after ghc-6.6, we can expect that hide dev will resume somewhat?
12:00:43 <dcoutts__> gour: I'd like to work on it after the next gtk2hs release
12:00:44 <dolio> (cond ((handle? x) (process x)) (else (error (mung x)))) ?
12:01:13 <ihope_> Hmm...
12:01:21 <ihope_> Don't think so.
12:01:22 <dolio> Or was that the lazy if function and not the scheme special form?
12:01:45 <ihope_> Does Scheme's special form thing use that ugly hackery?
12:01:58 <dolio> Well, in scheme/lisp...
12:02:26 <ihope_> ...everything's ugly hackery?
12:02:39 <gour> dcoutts__: and i'll help (at least by some testing) desiring it to become manifested one day. more & more users are becoming interested for haskell and having native IDE would be very nice...
12:03:03 <dolio> (cond (test-exp1 exp11 exp12 ...) (test-exp2 exp21 exp22 ...) ... (test-expN expN1 expN2 ...) (else expE1 expE2 ...))
12:03:08 <dcoutts__> gour: aye
12:03:31 <ihope_> ...That doesn't make any sense.
12:03:42 <ihope_> Or does it?
12:03:43 <dolio> cond is like a case expression.
12:04:01 <dolio> Only with tests, rather than pattern matching.
12:04:36 <dolio> And you can have sequences of expressions, rather than just one (since scheme lets you do some imperative stuff wherever).
12:05:02 <carp_> dcoutts__: is the oxford fp course page accessible from outside?
12:05:02 <lispy> it kinda works like pattern matching if you use typep in your conds
12:05:18 <dcoutts__> carp_: sadly not
12:05:22 <carp_> :(
12:05:25 <lispy> i did this once after learning a bit of haskell and ... kinda realized i was just pining for pattern matching :)
12:05:44 <Korollary> some scheme implementations also offer pattern matching
12:05:52 <dcoutts__> carp_: it's available on request for other uni teachers
12:05:52 <dolio> Yeah, it's hard to write scheme/lisp after getting used to pattern matching.
12:06:11 <dolio> All kinds of head/tail/null sprinkled everywhere.
12:06:21 <dcoutts__> carp_: are you interested in it for anything in particular?
12:06:41 <norpan> pattern matching is the roxx
12:06:48 <jcreigh> dolio: well, car/cdr/null?
12:07:40 <dolio> jcreigh: Yeah, well, whatever. :)  first/rest/null? if you're progressive, right?
12:08:25 <carp_> dcoutts__: Interested in the practicals mainly
12:09:24 <carp_> dcoutts__: ours are a bit old fashioned
12:09:57 <dcoutts__> carp_: are you a student or someone involved in teaching?
12:10:08 <dolio> ?pl \e -> g (f e) e
12:10:08 <lambdabot> g =<< f
12:10:24 <carp_> sorry :), i'm someone involved in teaching in this case
12:10:43 <dcoutts__> carp_: ah ok, then it's worth asking
12:11:03 <dcoutts__> carp_: I'd try writing to the academic administrator
12:11:12 <dcoutts__> carp_: or to Richard Bird directly
12:11:26 <carp_> dcoutts__: I thought you were in charge of practicals?
12:11:48 <dcoutts__> I only wrote one
12:12:10 <carp_> ah ok
12:12:12 <dcoutts__> and I'm not in the country currently to ask if it's ok to give out (though I'm sure it is)
12:12:53 <dcoutts__> so if you email prof Bird and cc me asking if it's ok then I can give you the one I wrote
12:13:02 <dcoutts__> and probably the first practical too
12:13:02 <carp_> ok i might do that thanks
12:13:36 <dcoutts__> carp_: what uni are you with?
12:13:57 <carp_> nottingham, i've met you a couple of times actually :)
12:14:08 <carp_> i work with epigram
12:14:16 <dcoutts__> heh, sorry, nicks/faces :-)
12:14:23 <carp_> is ok :)
12:14:45 * dcoutts__ tends to forget the nick<->name mapping
12:17:49 <dcoutts__> carp_: if you just want a look I'll send it now, we just don't want published solutions to pop up on the net too much
12:17:55 <dcoutts__> email?
12:18:25 <carp_> oh cheers, jmc@cs.nott.ac.uk
12:18:44 <yip> dcoutts, we have a problem:
12:18:53 <yip> <no location info>: can't find file: glib/System/Glib/FFI.hs
12:19:04 <dcoutts__> mm
12:19:30 <gour> dcoutts__: your teaching material tends to be a little bit graphic-oriented?
12:19:44 <dcoutts__> gour: only the one I wrote
12:19:56 <yip> dcoutts: actually, i get an error before that:
12:19:59 <yip> tools/c2hs/base/general/Binary.hs:59:7:
12:19:59 <yip>     Could not find module `Data.FiniteMap':
12:19:59 <yip>       Use -v to see a list of the files searched for.
12:20:13 <dcoutts__> yip: ah, you need a patch for ghc 6.6 for c2hs
12:20:16 <gour> dcoutts__: ok. anyway, i'll just resume with thompson's book...
12:20:17 <dcoutts__> it's on the mailing list
12:20:26 <dcoutts__> but I've not had time to apply iy yet
12:20:42 <dcoutts__> yip: see the gtk2hs-devel list
12:20:42 <SamB> dcoutts: you don't heed deprecation warnings?
12:20:57 <dcoutts__> SamB: well currently we support building with old ghc's
12:21:07 <dcoutts__> which don't have Data.Map
12:21:11 <SamB> oh
12:21:22 <dcoutts__> now we're forced to require 6.2 minimum
12:21:35 <dcoutts__> gtk2hs still builds with ghc-5.04.3 and 6.0
12:21:50 <dcoutts__> (and Gtk+ 2.0, 2.2, 2.4 etc)
12:22:01 <SamB> hmm, you think they should have left Data.FiniteMap in longer?
12:22:06 <dcoutts__> yes
12:22:08 <ndm> SamB: definately!
12:22:14 <SamB> you should file a bug, then!
12:22:15 <dcoutts__> ndm: cabalise it
12:22:19 <dcoutts__> :-)
12:22:29 <ndm> dcoutts__, no, i don't care enough - i just point people at a download link
12:22:51 <ndm> since hoogle is an online app, and no one uses catch, it doesn't actually bother me that much
12:22:53 <dcoutts__> there is a wrapper somewhere for the FiniteMap api with the Data.Map impl
12:22:59 <ndm> yep, malcolm did that
12:23:04 <gour> dcoutts__: is yhc far from being able to compile gtk2hs?
12:23:08 <dcoutts__> right
12:23:10 <ndm> gour: yes
12:23:15 <dcoutts__> sadly
12:23:21 <gour> ahh, i thought about jhc...
12:23:29 <dcoutts__> gtk2hs needs to be cabalised first
12:23:41 <gour> what about jhc & gtk2hs?
12:23:44 <ndm> and the base library needs to be cabalised
12:23:49 <dcoutts__> gour: similar
12:23:52 <ndm> and we need yhc support in cabal
12:24:09 <gour> how do jhc & yhc compare?
12:24:10 <SamB> so how does that work?
12:24:11 <lispy> ndm: do you have a plan for replacing System.Posix.Signals for lambdabot?
12:24:24 <ndm> lispy: yes, write a new one with stubs
12:24:27 <SamB> cabalizing the base module?
12:24:38 <ndm> which is why it irked me that there was on with a blank implementation
12:24:52 <ndm> SamB: buildnig base with cabal - its possible
12:25:18 <ndm> lispy: my plan was to strip out all the CPP, and provide stubs for all the unix methods
12:25:45 <ndm> which either get as close as they can to the unix semantics (exitImmediately -> exit), or just are total stubs (i.e. signals)
12:26:03 <SamB> hey, doesn't C have signals too?
12:26:25 <ndm> where this goes wrong is that System.Posix.Signals is in base, and required by lambdabot, and has different API sig in base from the unix version
12:26:29 <ndm> SamB: no
12:26:41 <ndm> SamB: they are an API available through C
12:26:44 <gour> dcoutts__: what are prereqs for cabalizing gtk2hs?
12:26:51 <SamB> ndm: I meant...
12:27:06 <lispy> ndm: what about using cygwin.dll ?
12:27:19 <ndm> lispy: eek! thats not a native windows build
12:27:22 <lispy> i thought it provided posix on windows
12:27:33 <SamB> lispy: slowly and unreliably
12:27:36 <Korollary> it doesnt provide all of posix anyway
12:27:43 <ndm> lispy: anyway, if all you want is a command line version (not an IRC version) most of the unix stuff is totally irrelevant
12:27:46 <lispy> or even USFW (or whatever they call it, the unix for windows thingy that MS provides ;)
12:27:59 <SamB> why does my signal(2) manpage say at the bottom:
12:27:59 <Pupeno> Hello.
12:28:00 <lispy> hmm...i see
12:28:03 <SamB> CONFORMING TO
12:28:03 <SamB>        ANSI C
12:28:07 <lispy> why does lambdabot even need signals for irc then?
12:28:15 <ndm> nah, non-implemented stubs will probably take you at least 95% of the way there
12:28:27 <ndm> exitImmediately is the only one that won't, and thats easy enough to fix up
12:28:30 <Pupeno> Any news regarding Cale's diagrams ?
12:28:35 <ndm> lispy: no idea :)
12:28:50 <ski> (SamB : maybe it is just copied from somewhere else ?)
12:28:56 <ndm> lispy: but i don't think their loss will make anyone upset
12:29:08 <Korollary> SamB: mine says "conforming to posix.1".
12:29:25 <SamB> why does it say at the top:
12:29:28 <SamB> NAME
12:29:28 <SamB>        signal - ANSI C signal handling
12:29:38 <lispy> ndm: here is what i don't get...if lambdabot needs those functions then how will it work when you replace them with stubs?
12:29:41 <Pupeno> @seen Cale
12:29:42 <lambdabot> Cale is in #haskell. I don't know when Cale last spoke.
12:29:50 <ndm> lispy: i'm not convinced it does
12:29:58 <Pupeno> @help remember
12:29:59 <lambdabot> quote <nick>
12:29:59 <lambdabot> remember <nick> <quote>
12:29:59 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:30:07 <Pupeno> @help tell
12:30:08 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
12:30:25 <dcoutts__> gour: well one this is making cabal deal correctly with .chs modules (ie respect their dependencies). fortunately kolmodin has a patch for that.
12:30:30 <ndm> lispy: of course, only dons knwos this for sure
12:30:35 <Korollary> SamB: this one? http://www.die.net/doc/linux/man/man2/signal.2.html
12:30:37 <lambdabot> Title: signal(2): ANSI C signal handling - Linux man page, http://tinyurl.com/jmz4s
12:30:39 <lispy> ndm: hehe
12:30:44 <dcoutts__> gour: then we need to make gtk2hs use the mainline c2hs rather than it's own fork.
12:31:01 <dcoutts__> gour: and probably various other things.
12:31:02 <ndm> dcoutts__: does that do full Cabal dependancy analysis? (ndm hopes...)
12:31:05 <Pupeno> @tell Cale Hello... today I searched for your beautiful diagrams on the different folds and all I've found was a dead link. Are they anywhere ? Do you still have them ?
12:31:06 <lambdabot> Consider it noted.
12:31:16 <dcoutts__> ndm: I asked the same question :-)
12:31:28 <dcoutts__> ndm: not yet, but it could be generalised
12:31:30 <ndm> lispy: anyway, a compiling version will probably get us quite a long way - and then we can see what fails, i suspect it will be minimal
12:31:34 <gour> dcoutts__: so, technology is (mostly) there, just (some) work...
12:31:36 <ndm> dcoutts__, woot :)
12:31:43 <dcoutts__> ndm: talk to kolmodin
12:31:50 <dcoutts__> gour: right, just work
12:32:02 <dcoutts__> or more accurately, time
12:32:13 <dcoutts__> as that's the limiting factor
12:32:24 <gour> Pupeno: i've Cale's graphic
12:32:31 <ndm> dcoutts__, i should focus on my phd for a bit of time... - i'll see where cabal is in a few months
12:32:35 <Korollary> SamB: You're right. signal.h seems to be part of Ansi C. http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V40F_HTML/AQTLTBTE/DOCU_093.HTM#lib_signal_sec
12:32:37 <lambdabot> Title: Signal Handling (<signal.h>), http://tinyurl.com/nauxs
12:32:46 <Pupeno> gour: really ? that's good... url ? or can you send them by mail ?
12:32:47 <dcoutts__> ndm: heh, same here :-)
12:33:07 <gour> Pupeno: i can send via email.
12:33:14 <dcoutts__> carp_: sent
12:33:23 <Pupeno> gour: Thank you... pupeno at pupeno dot com is my address.
12:33:29 * ski got some of the fold pics, too
12:33:57 <dolio> @. pl undo ap (++) . map
12:33:58 <lambdabot> ap (++) . map
12:34:23 <Korollary> also see http://tinyurl.com/q4u6p
12:34:26 <lambdabot> Title: Google Groups: comp.lang.c
12:36:14 <gour> Pupeno: sent
12:36:26 <lispy> ndm: so apparently irc can raise signals
12:36:42 <ndm> lispy: so we just make it console only?
12:36:59 <ndm> that suits me, since no one really wants to run a half-baked lambdabot port on a real IRC channel :)
12:37:01 <lispy> i don't know if it's only irc that generates them :)
12:37:24 <ndm> my guess, if there are any they are to do with user pressing ctrl+c (in which case dying is what the user wants)
12:37:46 <ndm> or they come from a 3 second timeout on eval, but not entirely sure on that
12:37:56 <ndm> depends how eval is implemented, hopefully not via signals
12:38:09 <lectus> Hi! I'm new to Haskell. Where can I find more information about it? Haskell can build GUI applications?
12:38:15 <lispy> when you say eval you mean '>' ?
12:38:18 <ndm> @learning
12:38:18 <lambdabot> Unknown command, try @list
12:38:27 <ndm> lispy: yep
12:38:31 <ndm> @learn
12:38:32 <lambdabot> http://www.haskell.org/learning.html
12:38:36 <ndm> lectus: ^^^
12:38:45 <ndm> lectus: that web page
12:38:47 <ndm> @where yaht
12:38:48 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
12:38:54 <ndm> lectus: ^^^ that tutorial
12:39:03 <ndm> lectus: and most definately yes to GUI's
12:39:05 <ndm> @where gtk2hs
12:39:06 <lambdabot> http://haskell.org/gtk2hs/
12:39:14 <ndm> lectus: ^^ those gui's :)
12:39:38 <ndm> lispy: yep, >, plugs, there are a few ways to prod it
12:40:46 <Pupeno> gour: thank you.
12:40:56 <gour> Pupeno: you've got it?
12:40:59 <SamB> hmm, I want a shell with higher-order functions
12:41:18 <lectus> I'll try to learn Haskell. Don't know anything about it yet. Just found it. LOL
12:41:27 <SamB> or at least a decent sexpr format
12:41:31 <ndm> SamB: there is on, hsshell maybe, i think dons did it with hs-plugins
12:41:34 <dolio> SamB: scsh?
12:41:43 <SamB> dolio: scsh?
12:41:52 <dolio> @google scsh
12:41:53 <ndm> lectus: well if you have any questions, just ask - working through the Yaht might be a good way to start
12:41:55 <lambdabot> http://www.scsh.net/
12:41:55 <lambdabot> Title: Scsh - The Scheme Shell
12:42:03 <lispy> ?where h4sh
12:42:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
12:42:10 <SamB> I want something to stick -ps before a list of pids
12:42:23 <lispy> xargs?
12:42:27 <Pupeno> gour: I can't check mail right now, as soon as I can I'll check it.
12:42:34 <gour> Pupeno: ok
12:42:35 <lispy> SamB: xargs takes input and generates commandlines
12:42:36 <SamB> lispy: one -p per PID
12:43:48 * ndm is happy he just managed to create a module named Train.Wreck in his project
12:43:56 * SamB wonders why xmms has opened so many pipes
12:44:10 <lectus> Just before I start learning, I'd like to know if is there any project done in Haskell so I can see it "working"?
12:44:24 <sieni> lectus: ghc?
12:44:29 <SamB> sieni: hah
12:44:32 <SamB> lambdabot!
12:44:37 <wilx> darcs
12:44:42 <SamB> @google Haskell tutorial
12:44:42 <sieni> yi
12:44:44 <lambdabot> http://www.haskell.org/tutorial/
12:44:44 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
12:44:45 <lispy> ndm: look at Lib/Signals.sh looks like lambdabot sets up certain OS signals to tell it when it has irc activity...so yeah, i'm betting that getting ride of online mode in win32 should leave a working lambdabot
12:44:56 <SamB> see, lambdabot google for you ;-)
12:45:08 <SamB> er, insert "can" after the comma...
12:45:16 <dolio> What's the name of the gtk2hs program that generates fractals? That one's a pretty example.
12:45:18 <SamB> er, no.
12:45:22 <SamB> after the lambdabot.
12:45:25 * SamB is awful.
12:45:39 <lispy> also darcs is in haskell
12:45:40 <dcoutts__> dolio: there's nymphea
12:45:52 <dcoutts__> @where nymphea
12:45:53 <lambdabot> I know nothing about nymphea.
12:45:55 <dcoutts__> @where nymphaea
12:45:55 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
12:46:01 <lispy> program i'm writing at work is in haskell and in generates excel spreadsheets from a database :)
12:46:10 <lispy> but you can't se it..
12:46:16 <dolio> dcoutts__: That's what I was thinking of.
12:46:54 <ndm> lispy: thats good news :)
12:47:19 <ndm> lectus: hoogle
12:47:21 <ndm> @where hoogle
12:47:22 <lambdabot> http://www.haskell.org/hoogle
12:47:41 * tibbe takes a deep breath
12:47:56 <xerox> We see the joint tibbe
12:48:02 <tibbe> hah!
12:48:05 <xerox> :P
12:48:06 <SamB> waaah
12:48:59 <SamB> for some reason xmms is getting stuck in a loop somewhere trying opening GTK themes again and again
12:49:07 <tibbe> but I guess you need to be a bit high to run Gentoo
12:49:28 <SamB> at least, they never get closed...
12:49:28 * tibbe is going to compile all the GHC stuff + libs
12:50:34 <SamB> oh, they are getting read actually
12:51:36 <SamB> oh no wonder...
12:51:38 * lispy thinks tibbe is certainly high :)
12:51:41 <lectus> Is Haskell compiled or interpreted? Does it run on windows as well as linux?
12:51:49 <SamB> heh, my ~/.gtkrc.mine is recursive...
12:52:05 <xerox> ?remember SamB heh, my ~/.gtkrc.mine is recursive...
12:52:13 <sieni> lectus: both depend on the implementation
12:52:16 <lispy> lectus: yes, yes, yes and yes (yes to all parts of that)
12:52:22 <ndm> lectus: both compiled (GHC) and interpretted (Hugs) and in between (Yhc) - and all run on windows, mac, linux at the very least
12:52:24 <integral> lectus: that depends on the implementation.  GHC compiles either to bytecode or to native code,  and there's plenty of windows impls
12:52:43 <tibbe> SamB: :D exiting
12:52:55 <tibbe> I think there should be a C somewhere in there
12:53:03 <tibbe> dunno where
12:53:07 <tibbe> exciting?
12:53:13 <sieni> tibbe: yes
12:53:30 <lispy> this was just on haskell-cafe but it's worth the 5 minute read: http://hope.cs.rice.edu/twiki/pub/WG211/M3Schedule/foozles.pdf
12:53:33 <tibbe> alright so I'm not exiting ;)
12:55:12 <SamB> the funny thing is it claims to be autogenerated
12:55:23 <tibbe> that was very funny lispy
12:55:28 <SamB> why would it be autogenerated to be recursive?
12:56:22 <xerox> lispy: hehe yes.
12:59:03 <dolio> Geeze, my .xsession-errors is huge.
12:59:16 <yip> hm... i seem to be having trouble applying this patch
13:01:54 <ihope_> @index Handle
13:01:55 <lambdabot> System.IO
13:06:45 <ihope_> @hoogle a -> IO (MVar a)
13:06:46 <lambdabot> GHC.Conc.newMVar :: a -> IO (MVar a)
13:09:52 <dcoutts__> hah, nice foozles
13:10:46 <lispy> well, yeah, but you can already do that in lisp
13:11:00 <ihope_> @hoogle MVar a -> IO a
13:11:01 <lambdabot> GHC.Conc.takeMVar :: MVar a -> IO a
13:11:01 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
13:11:01 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
13:11:33 <vincenz> dcoutts__: sadly... I use gmail
13:11:39 <vincenz> dcoutts__: I just unsubscribed in the end :/
13:12:08 <dcoutts__> :-(
13:14:49 <ndm> vincenz: i use gmail, and i can happily filter haskell' emails - and do
13:15:29 <ndm> vincenz: To haskell-prime -AT- haskell.org, Skip Inbox, Flag Haskell
13:15:42 <ndm> i also send ghc mailing list ones to that too
13:17:45 <lispy> or
13:17:54 <lispy> gah...i really need to learn to type
13:17:57 <tibbe> gmail works great for me to, apply label and skip inbox
13:18:15 <tibbe> lispy, try a dynamic language, then you won't have to
13:18:17 <ndm> lispy: are you making lambdabot with cabal, or with ghc --make ?
13:18:42 <lispy> tibbe: heeh, different type of typing :)
13:18:56 <ndm> lispy: you mean a kind?
13:18:59 <lispy> ndm: i was trying with cabal but i'm taking a break
13:19:10 <gour> 'night
13:19:11 <ndm> hehe, yeah, i know the feeling :)
13:19:13 * lispy meant to change channels not type "or" into irc
13:19:14 <tibbe> night
13:19:33 <ndm> well between us, we should be able to get it going through
13:19:43 <rindolf> Hi all.
13:19:47 <tibbe> hi
13:19:50 <ndm> hi rindolf
13:19:59 <rindolf> Can anyone help with http://sial.org/pbot/19427
13:20:00 <lambdabot> Title: Paste #19427 from "rindolf" at 88.153.53.7
13:21:26 <ndm> rindolf: type is just a synonym - which is expanded
13:21:45 <rindolf> ndm: so what should I do?
13:21:49 <ndm> so you wrote: instance Show (Map PhraseCounterKey PhraseCounterValue)
13:21:54 <ndm> and there is already show for map
13:22:11 <apfelmus> rindolf: -fglasgow-exts
13:22:15 <lennart> make PhraseCounter a data type
13:22:31 <ndm> rindolf: change type PhraseCounter to data PhraseCounter = PhraseCounter (Map PhraseCounterKey PhraseCounterValue)
13:22:41 <ndm> then you can give it a proper Show instance
13:23:26 <rindolf> ndm: thanks.
13:23:30 <ndm> rindolf: and you might also want to look at toAscList, which means you can skip the sort bit
13:23:35 <apfelmus> rindolf: newtype is better than data in this case.
13:23:52 <ndm> rindolf: plus \a -> \b -> x === \a b -> x
13:24:06 <rindolf> ndm: OK.
13:28:10 <rindolf> apfelmus: what should I put there?
13:28:13 <vincenz> ndm: oh
13:28:15 <vincenz> ndm: hmm
13:28:19 <vincenz> ndm: it's the to-field
13:28:28 <vincenz> ndm: oh well :/ either way I wasn't reading a lot
13:28:36 <ihope_> > '\126'
13:28:38 <lambdabot>  '~'
13:28:44 <ihope_> > words ([
13:28:45 <lambdabot>  Parse error
13:28:47 <ndm> vincenz: me neither, type stuff was floating over my head :)
13:28:56 <ndm> lispy: so if we can come up with a game plan for lambdabot, we can start trying to get patches into dons - even before it compiles
13:28:59 <ihope_> > words ([' '..'~'] ++ [' '..'~'])
13:29:00 <lambdabot>  ["!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
13:29:31 <xerox> ^_`
13:29:35 <ndm> lispy: do you think the stub route is going to be easiest? and if so, how do we do the stubs, since they tend to clash with base
13:29:42 <vincenz> ndm: I actually unsubscribed from most haskell lists, either a lot of libs I wasn't using, or newbie Qs or typestuff overy m head
13:30:01 <ndm> vincenz: i have to keep a look out to plug hoogle :)
13:30:02 <ihope_> > words "This is\tquite\rthe\ntest"
13:30:03 <lambdabot>  ["This","is","quite","the","test"]
13:30:08 <ihope_> Hmm...
13:30:15 <ndm> although usually other people beat me to it nowadays...
13:30:16 <ihope_> > words "Foo bar\r\n"
13:30:17 <lambdabot>  ["Foo","bar"]
13:30:23 <ihope_> Ah, that's good.
13:30:35 <vincenz> ndm: that's a good thng
13:30:37 <vincenz> (TM)
13:30:44 <apfelmus> rindolf: either you use newtype PhraseCounter = PhraseCounter (Map PhraseCounterKey PhraseCounterValue) which is haskell98 compliant or you can switch on GHCs extensions of the haskell language by giving it the -fglasgow-exts switch on the command line
13:30:48 <apfelmus> it does not really matter wether you use a data or newtype declaration, but the latter is a tiny bit more performant
13:31:19 <ndm> apfelmus: plus overlapping instances, whcih is why this would be a bad idea
13:31:41 <ndm> apfelmus: i'm not convinced newtype is faster than data - if it is then GHC's a crap optimizer...
13:32:09 <ndm> unless there aer some semantic differences?
13:32:44 <ndm> I just always use data, so my brain has less to deal with
13:32:55 <lennart> ndm: there's a semantic difference
13:33:19 <ndm> lennart: to do with strictness?
13:33:30 <ndm> or undefined values?
13:33:41 <lennart> on undefined values, yes
13:34:00 <lennart> so data has to be implemented by one more level of indirection
13:34:04 <ndm> so is it equivalent to data Foo = Foo !field ?
13:34:26 <lennart> ndm, so there's a subtle difference between that and newtype too
13:34:38 <ndm> how come?
13:34:44 <apfelmus> ndm: ah, right i forgot. -fallow-overlapping-instances is a must in this case
13:34:44 <apfelmus> rindolf: there is already an Show instance for Map a b, and you override it, so the instances overlap.
13:34:52 <ndm> in that example, Foo undefined == undefined
13:34:59 <lennart> case Foo undefined of _ -> 1
13:35:23 <ndm> lennart: with the field defined strict? Foo = Foo !field ?
13:35:26 <lennart> this is undefined with the data and a strict constructor, but 1 with newtype
13:36:08 <ndm> ok, so how does that differ from data Foo = Foo field ?
13:36:28 <ihope_> Is there a function to take just the first two words from a string?
13:36:39 <ndm> ihope_: take 2 . words
13:36:53 <ihope_> I want to get the rest of the string, too.
13:37:01 <ihope_> But not wordsified.
13:37:12 <apfelmus> ndm: with data, _|_ is a value of Foo. with newtype, it's not.
13:37:47 <rindolf> apfelmus: I see.
13:37:54 <ndm> apfelmus: is there a piece of code that gives different beahviour with both versions?
13:37:55 <rindolf> apfelmus: OK, I'll define my own different function.
13:38:29 <apfelmus> ndm: data Foo has "two undefined" values: _|_ and Foo _|_ whereas newtype Foo has only Foo _|_.
13:38:58 <ndm> apfelmus: but how can i test that?
13:39:25 <vincenz> apfelmus: because newtype has a strict constructor?
13:39:36 <vincenz> hmm
13:39:41 <vincenz> > Just undefined
13:39:42 <lambdabot>  Add a type signature
13:39:44 <vincenz> > Just undefined :: Just 1
13:39:45 <ndm> i think i understand where the bottoms fit in now
13:39:45 <lambdabot>  Parse error
13:39:50 <vincenz> > Just undefined :: Maybe Int
13:39:51 <lambdabot>  Undefined
13:39:52 <vincenz> say Nope
13:40:12 <vincenz> > Just undefined == undefined
13:40:13 <lambdabot>  Add a type signature
13:40:21 <kpreid> > case Just undefined :: Maybe Int of Just _ -> True; Nothing -> False
13:40:22 <vincenz> > (Just undefined :: Maybe Int) == undefined
13:40:23 <lambdabot>  True
13:40:23 <lambdabot>  Undefined
13:40:35 <apfelmus> vincenz: no, the type it envelopes retains its lazyness. but the newtype envelope does not add an extra _|_ indirection
13:40:35 <vincenz> kpreid: ok, now do that for a newtype
13:40:58 <vincenz> kpreid: I think you'll get the same
13:40:59 <ihope_> > words "     goo"
13:41:00 <lambdabot>  ["goo"]
13:41:10 <kpreid> name me a newtype!
13:41:33 <vincenz> dunno!
13:41:43 <vincenz> heh
13:41:53 <vincenz> expression-local datadeclarations would rock
13:41:55 <ihope_> Oh, heck. I'll just hope the server sends me perfectly formed messages :-P
13:42:34 <ihope_> Hmm, well...
13:43:16 <ihope_> ...Argh.
13:43:29 <ihope_> @hoogle String -> (String, String)
13:43:30 <lambdabot> No matches, try a more general search
13:43:35 <ihope_> @hoogle String -> Maybe (String, String)
13:43:36 <lambdabot> No matches, try a more general search
13:43:55 <ndm> ihope_: trying to take the first 2 words, and then the rest?
13:44:02 <ihope_> ndm: yeah.
13:44:34 <ndm> break (f 4) x
13:44:53 <ndm> hmm, no, that won't work...
13:45:13 <ihope_> break isWhite?
13:45:19 <ndm> ihope_: write your own words function
13:45:31 <ndm> getWord :: String -> (String, String)
13:45:38 <lennart> ndm: http://www.augustsson.net/lennart/Foo.hs
13:45:43 <ihope_> Yeah, that was what I wanted to write.
13:45:44 <apfelmus> ndm: let f x = case x of Foo _ -> 1 in f undefined. for newtype, it really gives 1.
13:45:58 <ndm> getWord x = let (a,b) = break isWhite x in (a,dropWhile isSpace x)
13:46:02 <lennart> maybe I should write a wiki entry about this.  it seems to crop up all the time
13:46:03 <ndm> getWord x = let (a,b) = break isWhite x in (a,dropWhile isSpace b)
13:46:14 <ndm> lennart: i was gonig to do that once i understood it :)
13:46:21 <ihope_> Thanks.
13:46:34 <lennart> nmd: you can use my code :)
13:46:41 <lennart> ndm, even
13:46:57 <ndm> lennart: thanks
13:47:16 <ndm> the behaviour of the last one looks very strange, y3
13:47:54 <vincenz> lennart: intresting
13:48:07 <lennart> ndm: but that's the crux of the matter
13:48:19 <lennart> the constructor means nothing for a newtype
13:48:28 <ndm> yeah, thats what was throwing me
13:48:29 <lennart> it only changes the type
13:48:57 <thetallguy> Anyone built the 6.6 snapshot on x86_64?
13:49:41 <lispy> > case undefined of _ -> 1
13:49:42 <lambdabot>  1
13:49:51 <tibbe> lennart: what are you doing now when you're no longer at CTH?
13:50:04 <lennart> i'm working at a bank :)
13:50:07 <Igloo> thetallguy: Why do you ask?
13:51:01 * vincenz *KICKS* google
13:51:24 * ihope_ bans Google
13:51:25 <ndm> vincenz: having gmail issues?
13:51:36 <ndm> @karama+ Google -- i still love google
13:51:36 <lambdabot> Google's karma raised to 1.
13:51:51 <lennart> karama?
13:51:59 <ndm> @karma lennart
13:51:59 <lambdabot> lennart has a karma of 0
13:52:02 <lennart> lambdabot is too clever
13:52:12 <psi> gmail has been not working good lately
13:52:21 <lennart> @karma augustss
13:52:22 <lambdabot> augustss has a karma of 1
13:52:33 <psi> the advanced version, anyway
13:52:38 <thetallguy> Igloo: I just tried it and it failed...
13:52:39 <vincenz> ndm: no google
13:52:45 <ndm> vincenz: why?
13:52:50 <Igloo> thetallguy: Failed how?
13:52:52 <thetallguy> ...but I am very suspicious about the build environment.
13:53:04 <Google> Why, thank you!
13:53:08 <vincenz> @karma- google Even though google personal is fortunately in english, when going to straight google it defaults to the dutch version, which has less options and NOWHERE can you choose you want the english .com google
13:53:08 <lambdabot> google's karma lowered to -1.
13:53:16 <lispy> so now that we'll have bang patterns in 6.6 can you have anti-bang patterns?  specify you want something to be non-strict and if ghc ends up thinking it should be strict then you get a compiler warning?
13:53:18 <Google> :-(
13:53:33 <ndm> vincenz: sign in, personalised search, and it respects you and your options
13:53:41 <thetallguy> stage1/nativeGen/MachCodeGen.hi
13:53:51 <thetallguy> nativeGen/MachCodeGen.hs:108:30: Not in scope: `assignReg_I64Code'
13:54:04 <vincenz> ndm: yeah but for quicksearchses using firefox thingamajig...
13:54:08 <vincenz> ndm: it defaults back to .be
13:54:15 * vincenz mutters
13:54:17 <vincenz> it's annoying to do
13:54:18 <vincenz> CTRL+N
13:54:19 <vincenz> home
13:54:20 <vincenz> click
13:54:23 <vincenz> search
13:54:25 <ndm> vincenz: are you sure thats not firefox's fault?
13:54:40 <vincenz> no, it's google not allowing a choice of language
13:54:50 <thetallguy> I may have gotten the wrong chroot.  There is a 32 bit environment running inside a 64-bit one
13:54:50 <vincenz> . /ig is just cause /ig is only in english
13:54:53 <apfelmus> lennart: i'd imagine working at a bank rather boring. and the freetime for coding and thinking is gone.
13:54:57 <tibbe> vincenz: hmm, I'm in France but get google to search in english
13:54:59 <Igloo> thetallguy: OK, I haven't seen that one (but I haven't tried building from the tarball on amd64 yet)
13:55:04 <ndm> i happily get .com, when being in the uk
13:55:04 <thetallguy> I expect the settings got confused
13:55:26 <thetallguy> -H16m
13:55:28 <mux> tibbe: tiring to do it everytime, though :-)
13:55:35 <lennart> apfelmus: it's not boring at all.  i write haskell all day :)
13:55:42 <tibbe> mux, do what you mean? change the settings?
13:56:01 <mux> yes, everytime you're on a new computer, or using a new browser or flushed cookies etc
13:56:02 <lispy> lennart: nice!
13:56:03 <tibbe> I'll see what I can do about it when I start in Januari ;)
13:56:15 <tibbe> mux, ah yes
13:56:38 <mux> and it still likes to return french pages sometimes
13:56:46 <tibbe> mux, perhaps you should invest in google browser sync, although I really don't like syncing cookies, but it's nice for bookmarks
13:56:50 <lennart> darn, I wish they had taught Geometric Algebra when I took maths, mechanics, physics, etc.  it looks so cool
13:57:14 <mux> tibbe: is it opensource and runs on a unix-like system?
13:57:36 <tibbe> mux, it's closed source and probably run on one of googles unix systems, it's a firefox plugin
13:57:49 <SamB> tibbe: one?
13:57:51 <mux> bleh
13:58:21 <apfelmus> lennart: oh! :) so you're the one who runs the whole bank's computing environment by the powers of your mind (haskell) alone
13:58:55 <tibbe> SamB: ok perhaps two
13:59:03 <SamB> tibbe: TWO?
13:59:05 <lennart> hehe, i wish
13:59:07 <SamB> just TWO?
13:59:31 <tibbe> SamB: as my neural networks lecturer once said, roughly equal to >> and 1
14:00:02 <tibbe> SamB, and then he saw that it could in fact also be smaller so he invented something like <~=>>
14:00:11 <SamB> hmm?
14:00:26 <tibbe> much greater than but could also be equals to or somewhat smaller than
14:00:43 <waern> hehe
14:01:30 <SamB> hah!
14:02:15 <tibbe> can't remember what he was talking about though
14:02:22 <apfelmus> lennart: i'd like to know what exactly you are coding for your bank? and how they discovered haskell?
14:02:26 <tibbe> (i.e. it was probably a proof of something)
14:04:32 <lennart> apfelmus: if you come to cufp in portland i'll give a talk about it
14:04:48 <lennart> (i will even if you don't come :) )
14:06:14 <tibbe> lennart: but for use who can't come :/
14:06:49 <ndm> lennart: cufp doesn't have proceednigs does it?
14:07:32 <lennart> right now i'm trying to make a framework for defining pricing models more easily.  mostly how to describe the user interface
14:07:43 <lennart> how they found haskell is a long story...
14:08:14 * lispy thinks he should make a combinator library for layouts, as per the discussions of late
14:09:18 <apfelmus> lennart: an US trip is out of reach for me. can you put slides on the net afterwards?
14:09:34 <lennart> i'll try and do that
14:09:56 <apfelmus> lennart: that would be great :)
14:10:04 <tibbe> banks do an awful lot of software don't they?
14:10:13 <lennart> yes, they do
14:10:37 <lennart> the group i work in has about 60 mathematicians and physicist
14:10:43 <tibbe> woa
14:10:49 <lennart> it's the modelling group
14:10:53 <tibbe> what do they do exactly?
14:10:55 <tibbe> ah
14:11:02 <tibbe> for investment?
14:11:09 <tibbe> like in modelling stock markets?
14:11:12 <lennart> yes, it's an investment bank
14:11:17 <lennart> credit suisse
14:11:20 <tibbe> interesting
14:11:34 * tibbe is going to get an account there
14:11:40 <lennart> stock markets, bond markets, foreign exchange, interet rates, ...
14:11:51 <tibbe> it's a swiss bank right (suisse)?
14:12:16 <tibbe> if I remember corretly that's what googled recommended in zurich
14:12:17 <lennart> yes, but very little investment banking in Switzerland
14:12:30 <tibbe> do they only do investment banking?
14:12:41 <tibbe> then it's probably not the bank I'll take
14:12:43 <lennart> no, they do all kinds of banking
14:12:57 <tibbe> is it a big bank in Switzerland?
14:13:00 <lennart> but globally i think investment banking is the big thing
14:13:16 <lennart> i don't know about the regular banking branch, but i think so
14:13:20 * tibbe wishes he knew more math
14:13:34 <lennart> they sure use a lot of very complex math
14:13:43 <tibbe> could someone recommended me a good math book to read in my spare time, I've finished the book (in algorithms) I was reaidng
14:13:43 <lennart> stochastic maths
14:14:11 <tibbe> s/reading/reading
14:14:15 <lispy> lennart: actuary or pure math?
14:14:19 <tibbe> xD
14:14:34 <vincenz> tibbe: comonadic types with barbed wire lenses over semi-monadic function algebras in category theory for semi-duplicated sets
14:14:48 <tibbe> vincenz: hah, too easy!
14:15:04 <tibbe> I was thinking discrete math or statistics
14:15:08 <lennart> lispy: well, the objective is to apply it, but there's some rather deep theory behind it
14:15:25 <vincenz> tibbe: "binary math: more discrete than does, it does not get"
14:15:49 <lispy> lennart: hmm...so probably they all have a degree in actuarial science and then a lot of bath background?
14:15:58 <lispy> hehe, not bath
14:15:59 <lispy> math!
14:16:03 <rindolf> How do I split a string according to '\t' in Haskell?
14:16:32 <lispy> rindolf: unfortunately i think you'll have to write it...there is words and lines but those won't split the way you want
14:16:41 <lispy> rindolf: look at break
14:16:46 <lispy> @hoogle break
14:16:47 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:16:47 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
14:16:47 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
14:16:56 <lennart> lispy: haha, no they all seem to have phds in maths of physics
14:17:00 <lispy> > break (=='\t') "blah\tblah"
14:17:01 <lambdabot>  ("blah","\tblah")
14:17:02 <tibbe> I've always thought there should be some sort of wordsWith
14:17:12 <tibbe> oh there's break?
14:17:15 <lispy> there should be a splitOn
14:17:19 <tibbe> @hoogle break
14:17:20 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:17:20 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
14:17:20 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
14:17:33 <tibbe> oh, only a pair, yech
14:17:42 <lispy> yup, you have to keep applying it
14:18:08 <lispy> i wrote splitOn :: Eq a => [a] -> [a] -> [[a]] but i don't have the implementation handy to give you the code :(
14:18:16 <apfelmus> > foldr (\c (x,xs) -> if c == ' ' then ([],x:xs) else (c:x,xs)) ([],[]) "asd ahsgd zei"
14:18:18 <lambdabot>  ("asd",["ahsgd","zei"])
14:18:58 * esap first thought of 'partition', but I suppose break is almost the same thing.
14:19:51 <rindolf> Here's my version of split http://sial.org/pbot/19428
14:19:55 <lambdabot> Title: Paste #19428 from "rindolf" at 88.153.53.7
14:19:56 <apfelmus> > let splitOn c s = let z = foldr (\y (x,xs) -> if y == c then ([],x:xs) else (c:x,xs)) ([],[]) s in fst z : snd z in splitOn ' ' "one two three, and again, one ..."
14:19:57 <lambdabot>  ["   ","   ","      ","   ","      ","   ","   "]
14:20:04 <Cale> map (takeWhile (/= 'a')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= 'a'))
14:20:12 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:20:27 * esap was wrong, partition can actually reorder the string :-(
14:22:41 <apfelmus> > let splitOn c s = (let z = foldr (\y (x,xs) -> if y == c then ([],x:xs) else (y:x,xs)) ([],[]) s in fst z : snd z) in splitOn ' ' "one two three, and again, one ..."
14:22:42 <lambdabot>  ["one","two","three,","and","again,","one","..."]
14:23:42 <ndm> esap: parition is for sets
14:24:08 <lispy> trix are for kids
14:24:37 <esap> ndm: right, I noticed when I tried it out: partition isDigit "fo1o" == ("1","foo"), whereas break isDigit "fo1o" == ("fo","1o")
14:25:45 <lennart> partition doesn't really reorder the list, but you can't reverse what it's done
14:25:58 <lennart> it's totally different from break
14:26:03 <esap> right
14:26:34 * esap hasn't used 'partition' enough to remember its semantics...
14:26:37 <apfelmus> lennart: you mentioned the long story of haskell at credit suisse
14:26:56 <tibbe> lennart: yes, the night is young
14:27:07 * tibbe lights a camp fire
14:27:11 <tibbe> tell us uncle lennart ;)
14:27:16 <lispy> i have a 3 day weekend, so get started :)
14:27:32 <lennart> apfelmus: to make it short, they wanted functions in Excel, googled, found an spj article, talked to him, posted a job ad on the haskell mailing list
14:27:58 <lispy> oh, i bet i know the paper they found
14:28:24 <lispy> i used to study under one of the coauthors
14:29:01 <tibbe> I used to study under lennart ;)
14:29:09 <lispy> ah
14:29:32 <lennart> and so they hired me and gabrielle keller for a year
14:29:50 <dmwit> Okay, I'm having trouble with hmake/ghc.
14:30:22 <lispy> oh, hmm...people use hmake?
14:30:23 <dmwit> It's looking for Hat.PreludeBasic.
14:30:29 <dmwit> What should I use instead?
14:30:39 <ihope_> @hoogle Char -> Bool
14:30:40 <lambdabot> Char.isAlpha :: Char -> Bool
14:30:40 <lambdabot> Char.isAlphaNum :: Char -> Bool
14:30:40 <lambdabot> Char.isAscii :: Char -> Bool
14:30:49 <ihope_> And the rest of them?
14:30:52 <ihope_> @hoogle space
14:30:53 <lambdabot> Text.PrettyPrint.HughesPJ.space :: Doc
14:30:53 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
14:30:53 <lambdabot> Text.Html.spaceHtml :: Html
14:30:58 <ihope_> @hoogle isSpace
14:30:59 <lambdabot> Char.isSpace :: Char -> Bool
14:31:15 <lennart> @hoogle isDigit
14:31:16 <lambdabot> Char.isDigit :: Char -> Bool
14:31:21 <lispy> dmwit: i like cabal
14:31:32 <ihope_> @hoogle isWhite
14:31:32 <lambdabot> No matches found
14:31:34 <dmwit> ...
14:31:43 <lispy> dmwit: easier to use than make once you see the examples in the manual
14:31:45 <dmwit> k, google here I come.
14:31:59 <esap> In category theory, does it make sense to universally quantify a hom-set? [which is NOT necessarily an object in the category]
14:32:03 * dmhouse dashes back into the room
14:32:29 <lennart> does anything make sense in category theory?
14:32:43 <esap> lennart: hehe, well I'm assuming it does make sense.
14:33:13 <dmhouse> Wonderful, 66 unread messages in my [Haskell] and [Haskell-cafe] label.
14:33:29 <tibbe> dmhouse: try mark unread, delete
14:33:34 <lispy> hehe
14:33:37 * lispy does that a lot
14:33:41 * tibbe too
14:33:59 <apfelmus> lennart: well, functions in excel is not haskell yet. what came next?
14:34:08 <tibbe> I have some 10 mailing lists on gmail, good when you're bored at work but otherwise I don't have the time to read all that
14:34:22 <dmhouse> Gmail needs a 'Mark boring' option.
14:34:28 <tibbe> yes
14:34:46 <lennart> apfelmus: they found simon's article about functions in excel.  talked to him and realized that maybe they needed some functional programmers :)
14:35:01 <dmhouse> Any interesting threads I should really read?
14:35:34 <esap> In particular, I'm wondering about the difference between an arrow f : 1 -> (forall x.x -> x) and g : forall x (x -> x). In one case, the *object* is defined with universal quantification. In the other, it's the Hom-Set that's universally quantified.
14:37:59 <apfelmus> lennart: only maybe? :)
14:38:00 <esap> but if the category has existentials, then you can transform from one to the other. But I haven't seen anywhere that hom-sets would be explicitly universally quantified.
14:38:33 <lennart> apfelmus: well, they believed it enough to hire two
14:39:15 <ihope_> @type ?foo
14:39:17 <lambdabot> forall t. (?foo::t) => t
14:39:23 * vincenz hugs Philippa 
14:39:25 <vincenz> :)
14:39:34 <vincenz> thx for the support :)
14:39:45 <apfelmus> :) ok thanks lennart, i really have to go sleep now. see ya!
14:40:02 <ihope_> ?foo has type t, if used in an environment where ?foo has type t.
14:40:02 <lambdabot> Maybe you meant: faq todo yow
14:40:21 <vincenz> @karma+ Philippa
14:40:21 <lambdabot> Philippa's karma raised to 1.
14:40:36 <tibbe> ?users
14:40:39 <lambdabot> Maximum users seen in #haskell: 220, currently: 211 (95.9%), active: 36 (16.4%)
14:40:40 * dmhouse just bought GEB
14:40:45 <xerox> dmhouse: good move!
14:40:56 <tibbe> dmhouse: GEB?
14:41:00 <dmhouse> Anyone got any personal reviews?
14:41:10 <xerox> Gödel-Escher-Bach
14:41:13 <Eidolos> tibbe: Goedel, Escher, Bach
14:41:17 <tibbe> I see
14:41:22 <Eidolos> I have it but I haven't read it yet.
14:41:23 <dmhouse> tibbe': Gödel, Escher Bach - Eternal Golden Braid' by Hofstadter.
14:41:29 <Cale> an Eternal Golden Braid
14:41:45 <xerox> I was unsure about the whole title in English :)
14:41:45 <vincenz> I liked GEB
14:41:58 <esap> The djinni story in GEB is nice application of recursion...
14:42:08 <dmhouse> xerox: did you read it in Italian or English?
14:42:10 <xerox> It goes like `un'Eterna Ghirlanda Brillante' in Italian.
14:42:29 <dmhouse> xerox: I think for a bilinguist it'd be interested to compare the two.
14:42:31 <xerox> Ghirlanda = Braid, Brillante = Shiny (Golden).
14:42:57 <xerox> dmhouse: it was a joint work of more than one person to translate it! Very interesting.
14:43:02 <vincenz> Eterna = Eternal
14:43:13 <xerox> Yeah, I was pointing out the other two, vincenz, because they are swapped :)
14:43:20 <xerox> But the acronym remain ordered.
14:43:33 <Bluelive> good book, don't be affraid to read it out of order
14:43:40 <vincenz> or with lazy evaluation
14:43:48 <Bluelive> except keep track of what you haven't read yet
14:43:56 <vincenz> that's under the hood memoization
14:44:01 <vincenz> implementation details!
14:44:11 <xerox> @palomer
14:44:12 <lambdabot> That's nuts!
14:44:15 <xerox> Exactly.
14:44:56 <lennart> @palomer
14:44:56 <lambdabot> woof
14:45:28 <vincenz> @proton
14:45:29 <lambdabot> look at smalltalk. they invented oo proramming
14:45:39 <vincenz> @proton
14:45:40 <lambdabot> is haskell more powerful than any jedii?
14:45:54 <lennart> @palomer
14:45:54 <lambdabot> That's a lie
14:45:57 <vincenz> @proton
14:45:58 <lambdabot>  and is haskell ez to debug?
14:46:06 <lennart> @palomer
14:46:07 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
14:46:09 <vincenz> @proton
14:46:10 <lambdabot> so this java guy I know says that java is the best when things get really complex and u need your apps do do real work
14:46:23 <lennart> @palomer
14:46:24 <lambdabot> Hrmph, looks like I killed the channel
14:46:27 <vincenz> @proton
14:46:27 <lambdabot> no I cant read online for long my eyes get fuzzy
14:46:37 <xerox> @slap vincenz
14:46:37 <vincenz> that's after I told him to read a tutorial
14:46:37 * lambdabot smacks vincenz about with a large trout
14:46:41 <xerox> @slap lennart
14:46:41 * lambdabot smacks lennart about with a large trout
14:46:45 <vincenz> @lart xerox
14:46:48 <vincenz> @zap xerox
14:46:48 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
14:46:51 <xerox> haha
14:46:54 <vincenz> o.O
14:46:56 <xerox> map.
14:47:05 <lennart> hey, just trying to get some good conversation going here
14:47:26 <xerox> Did you find a good name for Kleisli composition yet, lennart?
14:47:26 <Bluelive> ill go back to lurking now :)
14:47:39 <lennart> xerox: no :(
14:48:03 <Adamant> me likely teh-Haskell.
14:48:27 <xerox> Parse error.
15:11:47 <SyntaxNinja> xerox: you've got mail!
15:13:52 <Beelsebob|Mini> so who here will I see in Budapest tomorrow?
15:14:01 <Beelsebob|Mini> (if anyone)
15:14:16 <tibbe> Budapest?
15:14:21 <Beelsebob|Mini> IFL
15:15:51 <ndm> Beelsebob|Mini: have fun :)
15:16:08 <Beelsebob|Mini> ndm: will do... finally, a good conference venue :P
15:16:15 <Adamant> correction - me likey teh-Haskell
15:16:46 <tibbe> me likes tea-n-Haskell
15:23:41 <ndm> Beelsebob|Mini: it doesn't say the programme on the IFL 2006 website?
15:23:58 <ndm> Beelsebob|Mini: oh, it does - me = stupid (and tired)
15:24:54 <ndm> edwinb will be there
15:24:55 <Beelsebob|Mini> lol
15:24:57 <Beelsebob|Mini> I know
15:25:19 <ndm> Chris Brown, but i guess you knew that one
15:25:26 <Beelsebob|Mini> haha
15:25:38 <Beelsebob|Mini> his desk is the first on my right
15:25:44 <ndm> i notice there is an Olaf session
15:25:53 <ndm> Session 7
15:25:57 <Beelsebob|Mini> yes indeed
15:26:03 <Beelsebob|Mini> strangely, none of them are his talks
15:26:11 <Beelsebob|Mini> his is the last talk of the whole conference
15:26:33 <ndm> yeah, just spotted that
15:26:44 <ndm> so 4 author/co-author in that one conference - quitea lot
15:26:51 <Beelsebob|Mini> 5 I think
15:26:55 <Beelsebob|Mini> I think there's one at the start too
15:26:56 <ndm> missed one :)
15:27:04 <ndm> what is his promoting lazy programming stuff?
15:27:14 <ndm> just a position paper, or any research?
15:27:19 <Beelsebob|Mini> not sure
15:27:23 <Beelsebob|Mini> I'll find out when I see
15:27:36 <ndm> hehe, i guess
15:28:02 <ihope_> @hoogle FilePath -> IO String
15:28:03 <lambdabot> Prelude.readFile :: FilePath -> IO String
15:28:18 <Beelsebob|Mini> ndm: did you see my note about why Data.Map wasn't there?
15:28:33 <Beelsebob|Mini> it's getting closer as time goes by
15:28:35 <ndm> Beelsebob|Mini: yep, so are you going to fake foldable, or fake data.map?
15:28:42 <Beelsebob|Mini> I'll fake Data.Map
15:28:46 <Beelsebob|Mini> much easier
15:32:09 <ndm> and IntMap/IntSet/Set ?
15:32:12 <ndm> (please :)
15:32:20 <Beelsebob|Mini> Set is already there isn't it?
15:32:26 <ndm> oh, is it
15:32:29 <Beelsebob|Mini> the standard Data.Map imports it
15:32:30 <Beelsebob|Mini> a
15:32:34 <Beelsebob|Mini> and it didn't bitch
15:32:38 <Beelsebob|Mini> so I guess it's there
15:33:03 <ndm> hmm, i didn't realise
15:33:04 <ihope_> > lines "Hello,\n\n\n\n\n\nworld!"
15:33:05 <lambdabot>  ["Hello,","","","","","","world!"]
15:33:12 <ndm> well make sure we have IntMap/IntSet/Set/Map once we have finished
15:33:15 <ihope_> Mmh.
15:33:31 <ndm> since i use at least 3 of them in hoogle 4
15:35:44 <ihope_> So is GHCi actually an interpreter, or is it a fancy compiler thingy?
15:36:23 <Igloo> That depends on how you define interpreter
15:36:26 <ndm> ihope_: yes :)
15:36:30 <Igloo> It compiles to bytecode, while GHC compiles to machine code
15:36:53 <ihope_> Sounds interpreted to me.
15:37:43 <ndm> ihope_: is Yhc an interpetter or a compiler? Java?
15:38:08 <ihope_> Java compiles into something interpreted, aye?
15:38:25 <ndm> yse, but x86 machine code is interpretted
15:38:36 <ndm> on a RISC machine, using micro-code
15:38:53 <Igloo> x86 machine code is pretty much compiled these days, isn't it?
15:38:58 <ndm> and Java has hotspot which produces x86 code at runtime
15:39:45 <ndm> AMD and Intel both use RISC processors at the heart of their CPU's
15:40:04 <ndm> or things a lot more RISC like than x86 at least
15:40:33 <ndm> (what i'm basically trying to say is that interpretted/compiled is a bit of an arbitrary distinction)
15:40:41 <Bluelive> actually x86 is CISC, but it converts the instruction tu u-ops which are RISC and execute those, its pretty interresting stuff
15:41:18 <ndm> yeah, I know x86 is CISC, but its an interpretted language was my point
15:41:32 <ndm> by a RISC machine
15:42:10 <Bluelive> its not interpretted, its jitted to uops ;))
15:43:07 <ndm> does it use a profiling/hotspot style JIT?
15:43:38 <Bluelive> you could say that the branch predictor is somethign along those lines
15:44:07 <ndm> yeah, but it doesn't do re-jitting based on the branch predictor
15:44:12 <ndm> more a runtime hint
15:44:24 <Bluelive> altough im unsure if that influences the u-ops themselves or just how they are executed in hardware
15:44:25 <ndm> i wondered if it did the proper better compile on hot areas
15:44:45 <ndm> i think it just influences their interprettation, not them directly
15:45:50 <ihope_> Pah, RISC. Let's just turn it all to OISC.
15:46:04 <Bluelive> it would make sense to change the uops, it would paralelize better
15:46:55 <ndm> yes, thats kind of what they did for itanium...
15:47:18 <ndm> but they do have freedom to change the uops, its just hard to get CISC->uop mapping, hence a trade off
15:47:39 <Bluelive> but i would call it interpretted, because there is no 'software' doing the conversion
15:48:51 <Bluelive> would not
15:49:48 <Bluelive> i wonder if it would be helpfull to reason about the uops instead of the instructions
15:50:27 <Bluelive> o well, back to lurking, and some sleep
15:51:13 <SamB> ihope_: OISC?
15:51:25 <ihope_> Just one instruction.
15:51:40 <SamB> ... which is?
15:51:49 <ihope_> Depends on the OISC.
15:52:25 <ihope_> There's "subtract and branch unless positive", the close relative "subtract and branch if negative", and the more distant relative "reverse subtract and skip if borrow".
15:53:14 <SamB> and then there is the "copy memory" (with accompanying memory-mapped registers)
15:53:26 <SamB> and arithmatic units and such...
15:53:27 <ihope_> Actually, reverse subtract and skip if borrow is really more like two instructions, as there's a special memory location that's considered to be the instruction pointer.
15:54:05 <SamB> well, a lot of 'em have that
15:54:18 <heatsink> heh, arithmantic units :)
15:54:29 <ihope_> "Reverse subtract and relative jump if borrow", though... hmm.
15:55:42 <Bluelive> find the most perverse condition and use that :)
15:56:24 <Bluelive> according to wikipedia someone actaully implemented a OISC in hardware
15:57:05 <SamB> let me guess - for a school project?
16:01:36 <jcreigh> I think OISC is a misnomer...it's *two* instructions, disguised as one. I mean, if instructions of any complexity can be counted as "one instruction", then x86 is a OISC, with the implicit instruction "EMUX86", which emulates an x86...
16:02:29 <ndm> TISC, you are voting for?
16:02:35 <jcreigh> Yep. :)
16:08:07 <jcreigh> ...although, I supposed if you were allowed only one instruction, then "subtract and branch if negative" is probably among the simplest...
16:18:19 <jcreigh> Is CPS generally difficult to understand, or is it just me?
16:21:34 <Cale> jcreigh: Yes, it's generally a good way to obfuscate things unless you have a good reason for it.
16:21:56 <Cale> Though it's quite possible to do some neat things with that sort of thinking.
16:24:51 <Cale> *Main> start push 1 push 2 push 3 add add end
16:24:51 <Cale> 6
16:24:59 <Cale> You can do fun things like that :)
16:25:30 <Cale> cale.yi.org/autoshare/forthish.hs
16:26:59 <vincenz> Cale: add http://
16:27:10 <Cale> http://cale.yi.org/autoshare/forthish.hs
16:27:16 <vincenz> :)
16:27:19 <Cale> yeah, it's not ftp
16:27:23 <Cale> or gopher
16:27:26 <Cale> hehe
16:27:28 <vincenz> not only that, it makes clicking nice ;)
16:27:32 * vincenz is a lazy bastard
16:27:41 <Cale> oh, my client recognises it as a link anyway
16:28:35 <vincenz> Cale: what client?
16:28:40 <Cale> X-Chat
16:28:59 * vincenz uses terminal and gnome-term
16:29:02 <vincenz> irssi that is
16:29:27 <vincenz> what monad is that?
16:29:32 <Cale> it's not a monad
16:29:37 <vincenz> oh
16:29:40 <vincenz> pure continuuations
16:29:42 <Cale> right
16:29:50 <Cale> start k = k ()
16:29:50 <Cale> end (x,_) = x
16:29:53 <vincenz> but then
16:30:00 <vincenz> start push 1 push 2 push 3 and add end...
16:30:06 <vincenz> shouldn't it need () ?
16:30:51 <vincenz> ah nm
16:30:53 <vincenz> nice set up :)
16:31:27 <vincenz> typewise it can be hell though
16:31:33 <vincenz> I mean you're making a really deep tupple
16:31:48 <Cale> yeah, the type errors can get quite insane :)
16:32:07 <Cale> failing to put 'start' in that example there gives:
16:32:13 <Cale>     No instance for (Num ((b1 -> a -> ((a, b1) -> t) -> t, b)
16:32:13 <Cale>                           -> (b2 -> a1 -> ((a1, b2) -> t1) -> t1)
16:32:13 <Cale>                           -> t2
16:32:13 <Cale>                           -> ((a2, (a2, b3)) -> ((a2, b3) -> t3) -> t3)
16:32:13 <Cale>                           -> ((a3, (a3, b4)) -> ((a3, b4) -> t4) -> t4)
16:32:14 <Cale>                           -> ((a4, b5) -> a4)
16:32:16 <Cale>                           -> a5))
16:32:16 <SamB> Cale: huh
16:32:20 <Cale>       arising from the literal `2' at <interactive>:1:12
16:32:33 <SamB> reminds me of that paper about using epigram to prove the correctness of a compiler
16:33:28 <SamB> Cale: except I bet the epigram thing doesn't give such insane type errors, nor does my Haskell one, to my knowledge...
16:33:33 <SamB> I did use GADTs though
16:34:52 <RobHu> Hello, I am learning Haskell with the YAHT using GHCi. Is it possible to do multiple lines in GHCi, e.g.: signum x =
16:34:56 <RobHu>   if x < 0
16:34:57 <RobHu> ...
16:35:10 <SamB> RobHu: stick in file
16:35:21 <SamB> :l file.hs
16:35:34 <SamB> fix errors, type :r
16:35:38 <Cale> RobHu: You can sort of do things like that though, if you crush them onto one line.
16:35:49 <SamB> but you'd need a let
16:35:56 <Cale> and yeah, you'll need a let
16:35:56 <RobHu> Cale / SamB : Thankyou
16:36:22 <Cale> But yeah, you're really expected to put your declarations in a file -- the prompt is for evaluating expressions only.
16:36:47 <Cale> and when you get to things like declaring new types and so on, there's no way to do that from the interactive prompt
16:37:39 <SamB> anyway, a real editor is better for editing those huge things
16:40:00 <jcreigh> Hmmm...is there some elegant way to define map in terms in foldl? Foldr is easy: foldr (\a b -> f a : b) [] but the best I could come up with for foldl is foldl (\a b -> a ++ [f b]) [] which seems ugly.
16:43:32 <vincenz> @pl \f -> foldl (\a b -> a ++ [f b]) []
16:43:32 <lambdabot> flip foldl [] . flip ((.) . (++)) . flip flip [] . ((:) .)
16:43:37 <vincenz> that better?
16:44:17 <vincenz> jcreigh: problem with foldl is that it tendsd to reverse a list
16:44:23 <vincenz> I guess using continuations might be an idea
16:44:41 <jcreigh> > flip foldl [] . flip ((.) . (++)) . flip flip [] . ((:) .) (*2) [1..5]
16:44:42 <lambdabot>  Couldn't match `a -> [a1] -> c' against `[b]'
16:45:08 <jcreigh> > (flip foldl [] . flip ((.) . (++)) . flip flip [] . ((:) .)) (*2) [1..5]
16:45:09 <lambdabot>  [2,4,6,8,10]
16:45:39 <heatsink> > foldl (\f x -> f . (x+1 :)) id [1,2,3] []
16:45:41 <lambdabot>  [2,3,4]
16:45:45 <heatsink> There you go
16:49:08 <vincenz> @pl \f l -> foldl (\g x -> g . (x + 1 :)) f l []
16:49:09 <lambdabot> flip flip [] . foldl ((. ((:) . (1 +))) . (.))
16:50:01 <heatsink> well, f should always be id to behave like map
16:50:34 <vincenz> then erm
16:50:37 <vincenz> then it's not map
16:50:46 <vincenz> oh
16:50:47 <vincenz> nm
16:50:58 <vincenz> @pl \f l -> foldl (\g x -> g . (f x :)) id l []
16:50:58 <lambdabot> flip flip [] . flip foldl id . flip ((.) . (.)) . ((:) .)
16:51:03 <vincenz> like that then
16:51:05 <heatsink> yea
16:51:53 <heatsink> lambdabot draws ascii boobies.
16:57:48 <esdegan> is one allowed to ask a newbie short question here?
16:58:00 <heatsink> not if it's about perl.
16:58:09 <SamB> heatsink: why not?
16:58:16 <lispy> esdegan: don't ask to ask, just ask :)
16:58:18 <heatsink> because there's a whole channel for that!
16:58:29 <SamB> #perl-newbies, you mean?
16:58:57 <esdegan> oo.. thanks. I'm finding this code behaves differently in ghci and the compiled code
16:59:00 <heatsink> I presume one would go to #perl for a perl question
16:59:10 <esdegan> main = do putStr ("enter name: ")
16:59:23 <esdegan>           name <- getLine
16:59:35 <esdegan>           putStrLn ("hello " ++ name)
16:59:48 <esdegan> in the compiled code, getLine is executed first before putStr. Why is that?
17:00:05 <araujo> Output buffered.
17:00:07 <heatsink> esdegan, It might be that the output is buffered by ghci.
17:00:12 <musasabi> esdegan: they get executed in the correct order, but hPutStr does not flush the buffer.
17:00:21 <musasabi> @type hFlush
17:00:22 <lambdabot> Not in scope: `hFlush'
17:00:28 <musasabi> @type System.IO.hFlush
17:00:29 <lambdabot> GHC.IOBase.Handle -> IO ()
17:00:49 <musasabi> i.e. hFlush stdout
17:00:54 <musasabi> and import System.IO
17:01:38 <esdegan> that crossed my mind, but then does that mean every time I want a one line prompt + input I have to follow with flushing the buffer?
17:02:14 <musasabi> no. You write a function "myReadLine :: String -> IO String" - and call that.
17:02:29 <lispy> @hoogle interact
17:02:30 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
17:02:30 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
17:02:30 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
17:04:12 <araujo> Or you could use, hSetBuffering stdout NoBuffering
17:04:27 <araujo> esdegan, ^
17:05:29 <lispy> man, i don't get the purpose of interact
17:05:38 <esdegan> hmmm... ic. thank you very much.
17:23:55 <ski> xerox : Kleisli composition ?
17:24:20 <ski> (>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
17:24:21 <ski> ?
17:24:51 <dons> lispy: interact is cool!
17:24:54 <ski> (from "The Craft ..")
17:24:59 <dons> main = interact id -- cat
17:25:22 <ski> > interact reverse
17:25:23 <lambdabot>  No IO allowed
17:25:26 <dons> it's like withFoo for stdin
17:25:44 <lispy> but you get one charater at a time and it takes String -> String?
17:26:00 <ski> @type interact
17:26:02 <lambdabot> (String -> String) -> IO ()
17:26:03 <dons> you the the lot, look at the type :)
17:26:25 <lispy> ghc -e "interact id" echos as a type
17:26:30 <dons> interact $ unlines . f . lines -- line-by-line
17:26:35 <dons> lispy: buffering?
17:26:37 <vincenz> dons: just found out abou that now???
17:26:47 <dons> vincenz: hmm?
17:26:50 <ski> interact error
17:27:06 <dons> vincenz: I was anwering lispy "10:01  lispy:: man, i don't get the purpose of interact"
17:27:15 <vincenz> oh
17:27:49 <vincenz> interact is pretty spiffy
17:27:59 <vincenz> let me guess
17:28:30 <vincenz> getContents >>= \x -> return (f x) >>= putStr
17:28:36 <vincenz> @pl getContents >>= \x -> return (f x) >>= putStr
17:28:37 <lambdabot> putStr =<< f `fmap` getContents
17:28:52 <dons> it should know about interact..
17:28:53 <vincenz> or possibly
17:29:05 <vincenz> @pl \f -> getContents >>= \x -> return (f x) >>= putStr
17:29:06 <lambdabot> (getContents >>=) . flip flip putStr . (flip id .)
17:29:27 <vincenz> @pl \f -> liftM f getContents >>= putStr
17:29:27 <lambdabot> (putStr =<<) . flip fmap getContents
17:29:39 <vincenz> that's funny
17:29:39 <ihope_> @type flip flip
17:29:41 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
17:29:45 <vincenz> (putStr =<<) . flip fmap getContents
17:29:49 <dons> ?. pl undo do s <- getContents ; putStr (f s)
17:29:50 <vincenz> putStr =<< f `fmap` getContents
17:29:50 <lambdabot> putStr . f =<< getContents
17:29:51 <vincenz> stop
17:29:52 <ihope_> @type flip flip flip
17:29:53 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
17:29:54 <vincenz> they're different
17:29:55 <vincenz> (putStr =<<) . flip fmap getContents
17:29:57 <vincenz> putStr =<< f `fmap` getContents
17:29:59 <vincenz> !!!
17:30:08 <ihope_> @type flip flip flip flip
17:30:10 <dons> hmm?
17:30:10 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
17:30:15 <ihope_> Eh.
17:30:27 <vincenz> nm
17:30:34 * vincenz is tired and nonsensical
17:31:23 <heatsink> flip flip flip is flip flip flip flip??
17:31:42 <lispy> @. type unquote eval replicate 6 "flip "
17:31:43 <lambdabot> compose module failed: IRCRaised Parse error: "unquote"
17:34:19 <vincenz> @unquote "aa"
17:34:20 <lambdabot> "aa" hasn't said anything memorable
17:34:45 <lispy> @type flip flip flip flip flip flip flip
17:34:46 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
17:35:08 <lispy> ?type flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
17:35:09 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
17:35:22 <lispy> oh it converged
17:35:25 <heatsink> @type fix flip
17:35:27 <lambdabot> forall a c. a -> a -> c
17:35:30 <lispy> now it's idempotent
17:35:46 <lispy> @type flip flip flip flip flip flip flip flip
17:35:47 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
17:35:50 <vincenz> > fix flip 1
17:35:50 <vincenz> > fix flip 1 1
17:35:51 <lambdabot>  Add a type signature
17:35:51 <lambdabot>  Add a type signature
17:35:59 <vincenz> > fix flip 1 1 :: Int
17:36:02 <lambdabot> Terminated
17:36:04 <vincenz> wait
17:36:09 <vincenz> fix flip ... returns type ... c
17:36:12 <vincenz> o.O
17:36:19 <vincenz> > fix flip 1 1 :: [Int]
17:36:23 <lambdabot> Terminated
17:36:41 <dons> lispy, ndm: lambdabot needs signals to correctly handle unusual situations. like sighups, where it must correctly flush the state to disk
17:36:56 <dons> you can disable them only for the windows version
17:37:20 <heatsink> > flip flip flip (const (const 1))
17:37:20 <lambdabot>  Add a type signature
17:37:23 <lispy> dons: surely windows has a mechanism we can borrow...maybe it's just not part of the standard libs yet...
17:37:28 <heatsink> > flip flip flip (const (const 1)) :: Int
17:37:29 <lambdabot>    Expecting a function type, but found `c'
17:37:29 <lambdabot>    Expected type: (a -> b ->...
17:37:33 <dons> lispy, yeah maybe
17:37:36 <dons> that would be fine.
17:37:40 <lispy> ?type const const
17:37:41 <lambdabot> forall a b b1. b1 -> a -> b -> a
17:38:01 <heatsink> @type const . const
17:38:03 <lambdabot> forall b a b1. a -> b -> b1 -> a
17:38:22 <heatsink> yea, that's right
17:38:55 <lispy> ?type flip flip flip flip (const . const)
17:38:56 <lambdabot> forall a b. a -> b -> a
17:39:12 <lispy> ?pl flip flip flip flip (const . const)
17:39:12 <lambdabot> const
17:39:16 <lispy> ;)
17:39:53 <heatsink> @type flip flip flip
17:39:55 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
17:39:59 <lispy> ?pl flip flip flip flip
17:40:00 <lambdabot> flip flip flip
17:40:26 <audreyt> given something of type "a"
17:40:32 <heatsink> oh!
17:40:40 <audreyt> is there a way to know whether a unsafeCoerce# into Word will succeed?
17:40:54 <audreyt> i.e. is there a way to know if it's represented as a heap value, or a mutable pointer?
17:41:04 <audreyt> (GHC specific, very evil, question.)
17:41:51 <lispy> audreyt: someone told me there are things that perl6 needs to do but can't be implemented easily in pugs...is that true?
17:42:10 <audreyt> lispy: yes. perl6 needs to run perl5
17:42:14 <audreyt> and that part is very hard.
17:42:16 <lispy> audreyt: the person implied that haskell makes it nearly impossible to implement those things
17:42:18 <audreyt> so we cheat and embed perl5.
17:42:25 <lispy> oh, nice
17:42:42 <audreyt> lispy: do you perchance remember one of those things?
17:43:10 <lispy> audreyt: this person didn't know any details...you can imagine that i tried to get the knowledge from them...
17:43:11 <audreyt> as far as I know, what we really need is a decent unicode string
17:43:24 <lispy> i think they heard things at OSCON
17:43:48 <lispy> ghc doesn't cut it for unicode?
17:44:07 <audreyt> well, currently it's either very slow but unicode happy
17:44:10 <audreyt> ([Char])
17:44:16 <audreyt> or very fast but not at all unicode aware
17:44:18 <audreyt> (ByteString)
17:44:28 <audreyt> or somewhat okay on both ground but essentially unmaintained
17:44:31 <audreyt> (FastPackedString)
17:44:32 <musasabi> audreyt: what are you unsafeCoerce#:ing into Word ?
17:44:47 <SamB> what about Data.ByteString.UCS4 or whatever?
17:45:12 <audreyt> musasabi: possibly a TVar/IORef, which would succeed. possibly a [a]/Integer, which will fail.
17:45:31 <audreyt> musasabi: the thing is, it's an existential type
17:45:40 <audreyt> so I have no knowledge of the actual layout
17:45:47 <audreyt> I guess I can Typable it and typecase
17:45:57 <audreyt> but I wonder if there's such a lowlevel hook somewhere.
17:45:59 <lispy> why do people insist on putting ">" in front of lines when they post code on haskell-cafe?  It makes it so hard to figure out what's being quoted and what's being posted...
17:46:15 <dons> lispy... literate haskell??
17:46:23 <heatsink> reverse literate haskell :)
17:46:31 <musasabi> Not hte Word as defined in GHC.Word ?
17:46:39 <lispy> can i ask them to stop? ;)
17:46:58 <SamB> lispy: you can!
17:47:00 <audreyt> it is the GHC.Word.
17:47:09 * lispy goes off to make enemies
17:47:16 <SamB> but you better ask them to use the \begin{code} style..
17:47:19 <lispy> "SamB said I could ask!"
17:47:43 <dons> ?uptime
17:47:43 <lambdabot> uptime: 1 day, 18 hours, 48 minutes and 27 seconds, longest uptime: 1 day, 18 hours, 48 minutes and 27 seconds
17:47:45 <audreyt> musasabi: in pugs we use
17:47:45 <lispy> SamB: yeah, that style wouldn't bug me so much
17:47:46 <audreyt> pugs> VAR([1,2,3])
17:47:46 <audreyt> (#<Array:0x2899d650>,)
17:48:04 <audreyt> which boils down to
17:48:06 <audreyt> instance (Typeable a) => Show (IVar a) where show v = "<" ++ showType (refType (MkRef v)) ++ ":0x" ++ showHex addr ">"
17:48:22 <audreyt> where addr = unsafeCoerce# v
17:48:29 <audreyt> :: Word
17:48:49 <audreyt> that works just fine, if the underlying storage is TVar, IORef, HashTable, JudyMap
17:49:04 <audreyt> but if it's actually [a], it segfaults
17:49:34 <lispy> so if v :: [a] then it segfaults?
17:49:36 <audreyt> so I'm looking for a GHC way to tell a mutable structure from another
17:49:39 <audreyt> yes.
17:50:47 <audreyt> you can play at home with
17:50:48 <audreyt> import GHC.Exts
17:50:52 <audreyt> import Numeric
17:50:54 <audreyt> main = print $ addr []
17:50:57 <audreyt> addr x = showHex (unsafeCoerce# x :: Word) ""
17:51:01 <audreyt> which demos the behaviour
17:51:28 <audreyt> (yes, I'm aware that I'm abusing GHC beyond its designed purpose. :))
17:51:38 <dons> heh
17:51:56 <dons> ?remember audreyt yes, I'm aware that I'm abusing GHC beyond its designed purpose
17:52:04 <dons> audreyt: note that your warranty may now be void
17:52:21 <audreyt> I remember GHC comes with a preallocated void warranty pointer
17:52:22 <dons> and you'll have to pay for a licensed ghc hacker to repair things
17:52:38 <dons> :)
17:52:44 <musasabi> At least scavenging for closure types might work, but that is extra-dirty.
17:52:49 <SamB> audreyt: hah!
17:52:51 <audreyt> but I'm a BSD-licensed ghc hacker!
17:53:00 <audreyt> musasabi: elaborate?
17:53:11 <SamB> audreyt: I want to see your BSD license!
17:53:51 <musasabi> audreyt: 1) make sure the thing is evaluated (seq), 2) use a short C-stub to get the closure type, 3) do something evil with it.
17:53:56 <audreyt> SamB: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
17:54:04 <dons> heh
17:54:16 <SamB> audreyt: that isn't the whole license!
17:54:24 <SamB> what about the first part?
17:54:25 <audreyt> you need to pay for the rest of the license!
17:54:47 <audreyt> musasabi: elaborate on 2)?
17:54:49 <dons> ok, that license looks to be in order. sorry for your time.
17:55:38 <audreyt> is a license to sell hash to people an unordered license, then?
17:56:01 <SamB> yes!
17:56:15 <dons> you need a different licence to sell h4sh:
17:56:16 <dons> Name:                h4sh
17:56:16 <dons> Version:             0.2
17:56:16 <dons> License:             GPL
17:56:17 <vincenz> why are licenses required to be so damn difficult
17:56:26 <vincenz> "You downloaded it git, go complain elsewhere"
17:56:31 <vincenz> simple, easy to understand
17:56:38 <musasabi> audreyt: the closures have a structure that one can get from C, and that includes a type field that is useful.
17:56:43 <SamB> vincenz: they have to talk about what you can do, too
17:57:11 <SamB> musasabi: but not a TYPE type, just a closure type
17:57:32 <vincenz> "it's yours, be happy, now sue yourself"
17:59:15 <musasabi> SamB: of course. But closure type might be enough for the cases audreyt needs.
17:59:40 <SamB> I suppose so
17:59:50 <SamB> but how do you identify a closure type?
18:00:00 <musasabi> ghc/rts/Printer.c might be relevant.
18:00:13 <musasabi> (includes things like printing closure types etc)
18:01:06 <SamB> pointer identity is unreliable at best, FYI
18:01:41 <SamB> because some closure types might get linked in both statically and dynamically...
18:02:26 <Igloo> audreyt: Can you coerce to a Word# instead, and then wrap it in a W#?
18:02:47 <audreyt> wow.
18:02:53 <audreyt> Igloo++ # that works beautifully
18:02:54 <SamB> Igloo: wouldn't that do something totally different?
18:03:07 <Igloo> Yes, but he only wants the same thing to look the same I assume
18:03:15 <SamB> um
18:03:19 <SamB> she, now!
18:03:25 <Igloo> Sorry
18:03:41 <SamB> hence the new name!
18:03:53 <audreyt> that's fine, took myself ten years to adjust too :)
18:04:32 <SamB> @seen autrijus
18:04:33 <lambdabot> I haven't seen autrijus.
18:04:38 <SamB> hmm, once that actually worked.
18:05:01 * SamB thinks it should be hardwired to still work ;-P
18:05:10 <dons> the state has long since been zapped
18:05:23 <dons> since we changed the type of the seen state a few times
18:07:30 <vincenz> dons: you should work on state migration :)
18:07:39 <audreyt> uhm, how do I get visibility to W# and Word#
18:07:51 <audreyt> without importing everything from GHC.Exts?
18:08:20 <Igloo> import GHC.Exts (Word#(W#)) with -fglasgow-exts
18:08:37 <audreyt> test.hs:1:32: Module `GHC.Exts' does not export `Word#(W#)'
18:08:38 <Igloo> Sorry, that's rubbish
18:08:45 <musasabi> GHC.Word ?
18:09:01 <audreyt> ah,
18:09:01 <audreyt> import GHC.Exts (unsafeCoerce#, Word(W#), Word#)
18:09:26 <Igloo> Yes, although you can actually get Word(W#), Word# from Data.Word instead if you want
18:09:31 <audreyt> okie
18:09:34 <dons> ?index Word#
18:09:35 <lambdabot> bzzt
18:09:39 <dons> boo
18:09:44 <dons> ?hoogle Word#
18:09:45 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
18:09:48 <dons> double boo!
18:09:58 <audreyt> you mean GHC.Word, though
18:10:24 <audreyt> actually neither works...
18:10:49 <SamB> > 1# :: Word#
18:10:50 <lambdabot>  Parse error
18:11:01 <SamB> dons: your parser should parse sharp things!
18:11:12 <SamB> you should fix the lexer ;-)
18:11:15 <Igloo> Oh, ghci is showing me things that aren't in scope. Maybe my brain is confusing it with haddock's output
18:11:18 <SamB> it should not be hard...
18:11:33 <audreyt> yay, it works!
18:11:39 <Igloo> Cool
18:11:49 <audreyt> Igloo++ # dedicated support for GHC
18:12:14 <Igloo> Igloo-- # telling users to coerce to Word#
18:12:38 <audreyt> but it's exactly what I asked for :)
18:12:56 <Igloo> :-)
18:15:13 <audreyt> so Haskell is _also_ the best weakly-typed language...
18:16:14 <dons> hehe
18:16:35 <SamB> dons: you better implement that as an alternative @karma syntax soon...
18:27:21 <dons> SamB, hmm. wouldn't be too hard with the contextual stuff
18:27:28 <dons> SamB, would you like to send me a patch for it?
18:27:33 <dons> i can give you hints
18:27:41 <dons> but i'm a bit busy atm to work on it
18:27:43 <SamB> hmm
18:28:19 <dons> see Url.hs for examples of non-command processing of channel text
18:28:48 <SamB> yeah, that is how I know it is possible too ;-)
18:30:30 <SamB> hmm a conflict
18:30:41 <SamB> ooh corrupt repository!
18:34:41 <dons> hmm
18:35:06 <dons>  darcs get --partial http://www.cse.unsw.edu.au/~dons/code/lambdabot works
18:35:08 <lambdabot> Title: Index of /~dons/code/lambdabot, http://tinyurl.com/ezkcr
18:35:59 <dons> ?users
18:36:00 <lambdabot> Maximum users seen in #haskell: 220, currently: 192 (87.3%), active: 23 (10.5%)
18:38:28 <SamB> dons: it was my own repository that was corrupt, sorry for any confusion ;-)
18:38:45 <SamB> okay so how to build it these days
18:38:46 <SamB> ?
18:43:17 <dons> ./Setup.hs configure --bindir=`pwd`
18:43:19 <dons> ./build
18:43:35 <dons> presuming you have fps 0.7
18:52:33 <audreyt> Igloo: it seems under -O casting to Word# no longer works
18:52:39 <audreyt> i.e. it still segfaults
18:52:45 <audreyt> it does work when building unoptimized
18:52:52 <dons> noinline something?
18:53:15 <audreyt> could it be the unbox strict fields?
18:53:30 <dons> you're not running -optc* something?
18:53:41 <audreyt> hm wait, I'm not even using unbox strict fields.
18:54:12 <audreyt> no
19:01:03 <explicitjelly> hi.
19:01:08 <explicitjelly> that may be a very dumb question...
19:01:18 <explicitjelly> but where can I find the implementation of the list monad as haskell source?
19:02:46 <dons> ?fptools GHC.Base
19:02:47 <lambdabot> GHC.Base not available
19:03:29 <dons> here: http://darcs.haskell.org/packages/base/GHC/Base.lhs
19:03:35 <dons> grep for 'Monad'
19:03:56 <dons> in fact, :
19:03:57 <dons> instance  Monad []  where
19:03:57 <dons>     m >>= k             = foldr ((++) . k) [] m
19:03:57 <dons>     m >> k              = foldr ((++) . (\ _ -> k)) [] m
19:03:57 <dons>     return x            = [x]
19:03:59 <dons>     fail _              = []
19:04:32 <explicitjelly> aah, thanks.
19:05:21 <lispy> oh wait, it uses foldr?
19:05:30 <lispy> does that mean it's stack inefficient?
19:05:48 <dons> its required to use foldr/concatMap
19:06:00 <dons> concatMap f             =  foldr ((++) . f) []
19:06:07 <jrmole> is foldr better because of some rule magic?
19:06:29 <dmwit> Because of monad sequencing?
19:06:30 <dons> quite possibly yes
19:09:58 <explicitjelly> there's this part about the list monad where it's concatMap instead of just map. i did understand why but it always slips away from me :)
19:10:44 <explicitjelly> i think it's because the values are each in an own list, due to the definition of return-
19:10:59 <explicitjelly> or is that wrong thinking?
19:15:35 <dmwit> So, am I the only one who has a hard time debugging Haskell?
19:15:45 <dmwit> To be clear, I don't mean finding the problem, I mean using the debuggers.
19:16:01 <dmwit> I ask because there is so little documentation around...
19:16:18 <lispy> dmwit: you found a debugger?
19:16:30 <dmwit> ...
19:16:32 <dmwit> hat?
19:16:41 <Cale> explicitjelly: Well, what's the type of bind?
19:16:55 <lispy> dmwit: oh i thought hat was just tracing
19:17:00 <Cale> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b, right?
19:17:09 <dmwit> Hmmm...
19:17:18 <dmwit> hat-detect describes the process I'm trying to do.
19:17:23 <Cale> So in the case of lists, that's: [a] -> (a -> [b]) -> [b]
19:17:46 <dmwit> s/hat-detect/The man page for hat-detect/
19:17:57 <Cale> So if you're defining x >>= f, and you try something like map f x, you'll end up with something of type [[b]]
19:18:22 <Cale> so you need some way to join the list of lists together into one, and that's exactly what concat does
19:18:44 <Cale> explicitjelly: does that help?
19:18:46 <lispy> dmwit: i don't seem to have the man page for hat or hat-detect (curse you darwinports!)
19:19:04 <dmwit> I don't have man pages or binaries for hat.
19:19:14 <dmwit> But, in the hat-* family:
19:19:38 <dmwit> anim, cover, explore, nonterm, stack, trans, check, detect, graph, observe, trail, view
19:19:51 <dmwit> And I can't figure out how to use a single one. =/
19:20:15 <explicitjelly> Cale, still thinking (i'm having a conversation about a software project at the same time via icq, which doesn't help right now...)
19:20:44 <dons> dmwit: I think most of us don't use debuggers. we just write code fragments in ghci to test
19:20:55 <dmwit> k
19:20:59 <dons> i..e 99% of haskell programmers don't use debuggers
19:21:04 <dmwit> It's worked so far, I guess I'll keep doing it...
19:21:08 <Cale> Yeah, I mostly treat ghci as a debugger
19:21:10 <dmwit> =P
19:21:27 <Cale> Referential transparency means that there's usually no need to breakpoint things
19:21:33 <lispy> there was this one time when i wanted a debugger...but i can't remember why now
19:21:42 <dons> right. you can test all the components in isolatoin
19:21:45 <Cale> But the new ghci is supposed to be getting a breakpoint mechanism anyway
19:21:48 <dons> without having to reconstruct a large program state
19:21:54 <dmwit> Cale: maybe, but I'm not as good as you yet. ;-)
19:22:16 <dons> hat does help people learn the evaluation order, I think
19:22:20 <dons> as you can view the reductoins
19:22:23 <lennart> there are times when a debugger would be helpful.  but usually i don't miss it
19:22:53 <dons> lennart: hey. what's all this netbsd you-must-sign-contracts-to-hack stuff?
19:22:55 <Cale> There have been times when I wanted that ability, since the crash was happening in the middle of an operation on a rather large datastructure. It's really only the most subtle algorithmic things on large data which can slip by and become irritating.
19:23:13 <dons> lennart: or did I misread the weird announcement?
19:23:16 <lispy> oh, i remember, when i hit 'error "blah"' for smething like tail
19:23:18 <jrmole> @type bind
19:23:19 <lambdabot> Not in scope: `bind'
19:23:27 <Cale> But often the best way to attack those is to actually find ways to break apart your algorithm better.
19:23:37 <Cale> jrmole: (>>=) is called bind
19:23:39 <jrmole> @type join
19:23:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:23:42 <Cale> @type (>>=)
19:23:44 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:23:50 <jrmole> right, got bind/join mixed up
19:24:26 <lispy> breaking things apart allows to test things better with, say, quickcheck so that helps reduce the need for a debugger as well
19:24:36 <dmwit> I guess getting a debugger up and running is just a habit.
19:24:38 <lispy> if all the subparts work as expected, you probably don't need to trace them
19:24:45 <jrmole> liftM and join are complete for monads, right?
19:24:48 <dmwit> I figured I'd need it eventually, but maybe not.
19:25:30 <lispy> dmwit: yeah, switch to a test driven development (or at least more testing) plus using ghci to prototype everything and you'll rarely want a debugger
19:25:44 <lennart> dons: oh, there's some paper to sign to make sure you sign over the copyright, or something.  i've never signed it
19:26:16 <lispy> lennart: journal publishing?
19:26:36 <dons> lispy, no. netbsd contributions
19:26:41 <lispy> oh
19:26:43 <jrmole> hmm, since Monads are Functors, isn't liftM redundant with fmap?
19:26:59 <lispy> jrmole: monads in haskell are not functors
19:27:10 <lispy> jrmole: i mean, mathematically, you are correct
19:27:14 <jrmole> so how is the haskell notion of a monad weaker than the categorical one?
19:27:15 <Cale> jrmole: indeed
19:27:18 <lispy> jrmole: but the way the type classes are written it's not required
19:27:46 <jrmole> lispy, but could we in principle require every Monad to have a Functor instance, without excluding any Monads?
19:27:55 <Cale> jrmole: That's true
19:28:06 <Cale> jrmole: by defining instances as  fmap = liftM
19:28:07 <dmwit> Well, now I've installed hmake, cabal, alex, hat, and buddha in a wild goose chase. =D
19:28:08 <lispy> jrmole: without excluding any monads that follow the monad laws
19:28:27 <lispy> dmwit: install quickcheck or hunit too :)
19:28:28 <lennart> netbsd has a problem, it doesn't have a crazy leader like linux and openbsd
19:28:40 <dmwit> lispy: Why not, the more the merrier.
19:28:43 <Cale> jrmole: It's a stupidity that's been around since Haskell 98. There were a number of crazy things which happened to the prelude which should probably be called mistakes.
19:28:44 <jrmole> explicitjelly, do you understand the nondeterminism interpretation of the list monad?
19:29:01 <lispy> dmwit: this might help you with debugging: http://www.galois.com/~andy/hpc-intro.html
19:29:03 <lambdabot> Title: Hpc: Haskell Program Coverage
19:29:05 <dons> lennart: yeah. crazy leaders are good to scare people into doing work
19:29:14 <jrmole> torvalds isn't so much crazy as just odd
19:29:17 <Cale> Merging MonadZero into MonadPlus was another mistake, as was including fail in the Monad class.
19:29:19 <dmwit> lispy: Thanks.
19:29:21 <dons> and get publicity, and enforce rules
19:29:32 <jrmole> de raadt, though, is crazy
19:29:35 <explicitjelly> Cale, jrmole, just a moment please, i'm currently engaged in a conversation. i have to finish it first before thinking about monads makes sense
19:29:39 <lennart> dons: it doesn'rt matter if they are crazy.  it attracts attention
19:29:43 <jrmole> explicitjelly, that's fine, take your time
19:29:46 <dons> oh he's not so bad, jrmole.
19:29:50 <explicitjelly> Cale, jrmole, then i'll be really grateful for your help :)
19:29:54 <Cale> explicitjelly: Have you read Monads as Containers?
19:29:55 <dons> he's just a perfectionist, I think
19:30:04 <dons> which is good for a kernel hacker
19:30:09 <jrmole> well, he's crazy in a way that makes the OS better (see: ipf vs. pf)
19:30:18 <Cale> explicitjelly: If not, you really should, I think it will help immensely :)
19:30:19 <dons> yeah, exactly
19:30:21 <dons> ?version
19:30:21 <jrmole> and when your niche is "no-compromises security" you need someone like that
19:30:22 <lambdabot> lambdabot 4p109, GHC 6.5 (OpenBSD i386 )
19:30:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:30:36 <dmwit> lispy: interesting link.  Is this a kind of tool that's available for other languages, too?
19:30:52 <jrmole> linux doesn't have such a well-defined niche, it really tries to be everything to everyone, so torvalds can't be so authoritarian :)
19:30:55 <Cale> @wiki Monads_as_Containers
19:30:55 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
19:31:12 <lennart> linus isn't paranoid, which theo seems to be :)
19:31:15 <lispy> dmwit: sometimes, i see nice commercial ones for C and there is one for gcc (name eludes me at the moment)
19:31:34 <lispy> dmwit: code coverage tools are just as important as testing but harder to make so less common
19:31:48 <lennart> oh, and stallman is a lunie :)
19:31:56 <dmwit> lispy: Yeah, makes sense.  I'm going to start looking around... =)
19:32:05 <jrmole> yeah, but stallman doesn't have a complete OS in his iron fist
19:32:17 <jrmole> although i'm sure duke nukem forever will be released for Hurd any time now
19:32:18 <lispy> dmwit: valgrind and ...maybe...gconv or gprof work for C
19:32:39 <lennart> hurd almost works, i thought
19:32:44 <lispy> dmwit: and python has one but i don't remember the name
19:32:52 <jrmole> lennart, you can't have more than 4GB of hard drive on 32-bit machines
19:32:58 <lennart> but no one cares abour hurd :)
19:32:58 <jrmole> for starters
19:33:04 <lispy> i installed debian hurd about 3 years ago and it was...eh, usable for simple stuff
19:33:44 <lennart> who needs more than 4G?
19:33:52 <jrmole> who needs 32-bit machines? ;)
19:34:02 <lispy> who needs unix?
19:34:02 <jrmole> eh, i'm using one now, actually
19:34:04 * jrmole disappears
19:34:22 <jrmole> lispy, agreed.  but i'm not smart enough to write something better, yet
19:35:17 <lispy> i haven't seen anything better than unix, yet
19:35:26 <jrmole> plan9 has some interesting ideas
19:35:44 <lispy> i've heard that...i was going to install it once, but they made you register so i never made it to the download
19:35:48 <lennart> plan9 is very cool
19:36:07 <jrmole> there's a lot of things that unix clearly does wrong, that could be done right pretty easily
19:36:15 * lispy thinks registering at every single website you visit is a waste
19:36:31 <lispy> jrmole: like not having drive letters?
19:36:54 <jrmole> not having drive letters is a good thing
19:37:04 <dmwit> o rly?
19:37:15 <jrmole> i think everyone, even microsoft, agrees with this by now
19:37:18 <explicitjelly> okay. now you're having my full attention :)
19:37:24 <lispy> one of teh really nice things about cabal installing something on win32 that i found is...if you install from something besides C:\ your files install to somewhere besides C:\ and then ghc can't find them later :(
19:37:53 <explicitjelly> sooo.
19:37:57 <lispy> so working from my network drive is not possible if i plan to cabal install
19:38:02 <explicitjelly> jrmole, to answer your question: uhm... no?
19:38:19 <jrmole> explicitjelly, a value of type [a] can be viewed as a nondeterministic value of type a
19:38:25 <explicitjelly> Cale, and concerning the type... yes but why is the function that is applied a -> m b? why not a -> b? or m a -> m b?
19:38:33 <jrmole> that is, zero or more possible values
19:38:55 <explicitjelly> jrmole, ah, okay. i can see that.
19:39:22 <jrmole> so if you have some input possibilities [a], and you want to apply some nondeterministic function a -> [b] to each
19:39:33 <jrmole> then you want the list of all output possibilities
19:39:49 <jrmole> not the list of, for each input possibility, the corresponding output possibilities
19:39:56 <jrmole> so you concat the resulting lists together
19:40:12 <explicitjelly> jrmole, aaah. so the trick is just that it allows computations which may have multiple (or no) values per list element
19:40:19 <jrmole> yeah
19:40:30 <JosephRivers> What's the symbol for "not equals"?
19:40:30 <lennart> yep
19:40:35 <jrmole> /=
19:40:40 <JosephRivers> thanks
19:40:46 <explicitjelly> jrmole, wow. that's actually not that hard.
19:40:52 <jrmole> yeah, and it's very useful too
19:41:14 <jrmole> in fact a list comprehension is basically a list monad do statement written in a different order
19:41:28 <jrmole> and in earlier versions of the language, you could do comprehensions on arbitrary monads
19:41:36 <explicitjelly> jrmole, with the list monad as an example, i was just looking at computations which return one value for every value.
19:42:22 <explicitjelly> well. yes. now it's clear.
19:42:46 <explicitjelly> a -> m b also makes perfect sense for the Maybe monad
19:43:02 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; if x^2 + y^2 == z^2 then [(x,y,z)] else []
19:43:03 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
19:43:25 <jrmole> you might prefer the definition of monads in terms of join :: m (m a) -> m a and map :: (a -> b) -> m a -> m b
19:43:31 <jrmole> which is more categorical, i guess
19:43:36 <Cale> @wiki Monads_as_Containers
19:43:36 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
19:43:46 <jrmole> for [], the former is concat and the latter is map, as you'd expect from the types
19:43:47 <Cale> Have you read that?
19:43:59 <Cale> you still need return
19:44:16 <jrmole> yeah
19:44:23 <explicitjelly> Cale, i'm about halfway through
19:44:28 <Cale> explicitjelly: cool :)
19:45:17 <explicitjelly> jrmole, so bind (>>=) is actually: take a monad (with something in it or not), which may well be the result of a previous computation, compute it and return a monad with the result(s) (or not) of that computation.
19:45:31 <explicitjelly> jrmole, chain together as you want.
19:45:53 <jrmole> you're on the right track
19:46:02 <dmwit> explicitjelly: I found this site helpful: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
19:46:06 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
19:46:19 <jrmole> what you said makes more sense the more like a container the monad is
19:46:55 <explicitjelly> jrmole, ah, because it doesn't need to be very container-like.
19:47:01 <explicitjelly> jrmole, like IO, i suppose.
19:47:06 <jrmole> Cale, good tutorial, but i challenge you to interpret the Cont monad in terms of containers ;)
19:47:14 <jrmole> it's a good way to look at the usual suspects, though
19:47:15 <Cale> Yeah, monads like IO aren't too container-like, and State is a bit of a stretch
19:47:26 <Cale> Cont can be handled, sort of :)
19:47:57 <jrmole> the more general notion is m a <=> "m-having-computation yielding values of type a"
19:48:06 <Cale> Cont r a = (a -> r) -> r, right?
19:48:31 <Cale> So, let's take Cont Bool as an example
19:49:01 <Cale> A Cont Bool is sort of like a container which you can't observe the contents directly, but which you can ask yes or no questions about them.
19:49:10 <jrmole> so IO a <=> "side-effecting computation yielding a", Maybe a <=> "possibly-undefined computation yielding a", etc
19:50:26 <Cale> (return (x::a)) :: Cont Bool a  is just the container which will answer such questions regarding the value x.
19:51:01 <Cale> Of course, the trickiness of the cont monad comes from the fact that you can do funny things with the questions before having to answer them.
19:51:52 <jrmole> then join :: ((a -> Bool) -> Bool) -> Bool) -> Bool -> (a -> Bool) -> Bool
19:52:15 <jrmole> and what in the good name of lambda does that mean?
19:52:46 <Cale> join :: Cont Bool (Cont Bool a) -> Cont Bool a
19:53:25 <jrmole> it implements the identity question on booleans, then?
19:53:33 <Cale>      = ((((a -> Bool) -> Bool) -> Bool) -> Bool) -> ((a -> Bool) -> Bool)
19:54:40 <Cale> So we have a box with which one can ask boolean-valued questions about a box which one can ask boolean valued questions about a value of type a
19:55:46 <Cale> To turn this into a box which one can ask boolean-valued questions about a value of type a, all we do is produce the box which takes the question, and asks the former box "What would the box respond if asked this question?"
19:56:04 <Cale> Perhaps I should name all the boxes to keep things straight :)
19:56:10 <jrmole> yeah, i see
19:56:19 <Cale> Let x :: Cont Bool (Cont Bool a)
19:56:20 <jrmole> it's a pretty cool interpretation, actually
19:57:52 <Cale> and so join x :: (Cont Bool a), when given a question q of type (a -> Bool) will ask x the question "What would your (Cont Bool a) respond with when asked the question q?"
19:57:59 <jrmole> i see how continuations can be used to model various sorts of data hiding
19:58:02 <Cale> But yeah, I think you get it :)
19:58:54 <Cale> You can also use them to produce all sorts of rather insane control structures, including goto, and goto-with-value
19:59:46 <Cale> Because you essentially have at every point, a handle on "the rest of the computation".
19:59:56 <Cale> That is, the question which is being asked.
20:01:02 <jrmole> the future is first-class ;)
20:01:43 <dmwit> Once again, time bends itself to convenience the programmer.
20:02:00 <lispy> heh
20:02:11 <lispy> that's funny given the time warp last night
20:02:19 <lispy> er even funnier i mena
20:02:20 <dmwit> ?
20:02:46 <lispy> i can't remember who, but someone had a clock that was a couple days off andthen fixed it
20:02:56 <lispy> so @localtime kept giving us differen times for tha person
20:03:07 <dmwit> Ah.
20:03:08 <lispy> and there was some dicussion of writing a program in J to fix the clock
20:03:29 <lispy> ?localtime dmwit
20:04:00 <dmwit> ... I don't know how to answer.
20:04:09 <dmwit> But it's 23:00 here.
20:11:32 <lispy> ?localtime lispy
20:11:33 <lambdabot> Local time for lispy is Sat Sep  2 20:07:51 2006
20:11:41 <lispy> well, lambdabot should answer for you!
20:11:55 <jrmole> ?localtime lambdabot
20:12:03 <lispy> ?localtime dons
20:12:05 <lambdabot> Local time for dons is Sun Sep  3 13:08:23 2006
20:12:13 <jrmole> ?localtime jrmole
20:12:14 <lambdabot> Local time for jrmole is Sat Sep  2 22:08:25
20:12:26 * lispy is still enjoying saturday
20:12:32 <explicitjelly> ?localtime explicitjelly
20:12:35 <lambdabot> Local time for explicitjelly is Sun Sep  3 05:08:53 2006
20:12:41 <explicitjelly> yup, that's right.
20:12:46 <heatsink> ?localtime heatsink
20:12:47 <lambdabot> Local time for heatsink is Sat Sep  2 22:08:02
20:13:16 <lispy> ?localtime *
20:13:32 <lispy> aw, i wanted all the localtimes :)
20:13:40 <jrmole> a graph of active users per timezone over time would be cool
20:13:55 <jrmole> but perhaps CTCPing everyone regularly would be impolite
20:14:02 <dmwit> lispy: when you ask for my localtime, lambdabot sends me a personal message asking me the time... =)
20:14:04 <lispy> a bit weird to say the least
20:14:22 <lispy> dmwit: yup, most irc clients just reply back automatically
20:14:23 <heatsink> so does it only work for people who are online?
20:14:25 <heatsink> @localtime shapr
20:14:26 <dmwit> Incidentally, your time suggests you're in CA -- are you, by chance?
20:14:36 <jrmole> dmwit, that's how it always works, yes?
20:14:47 * dmwit shrugs in ignorance
20:15:09 <lispy> dmwit: no
20:15:21 <SamB> heatsink: of coures
20:15:24 <SamB> er, course
20:15:27 <SamB> it uses CTCP
20:15:30 <lispy> dmwit: you can find me on the haskell user map tho :)
20:15:32 <SamB> not magical preknowledge
20:15:41 <dmwit> =)
20:15:54 <jrmole> @where haskell user map
20:15:55 <lambdabot> http://haskell.org/
20:15:57 <jrmole> great
20:16:02 <SamB> @map
20:16:02 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:16:12 <heatsink> SamB: you mean it needs more haskell?
20:16:26 <SamB> heatsink: hmm?
20:16:30 <SamB> what do you mean?
20:17:18 <heatsink> joke about haskell's not-always-sequential evaluation semantics.
20:17:19 <jrmole> sure, just use the MagicalPreknowledge monad
20:17:54 <SamB> I said "magical preknowledge", not "a MonadFix instance"
20:17:56 <SamB> silly!
20:18:01 <dmwit> lispy: your coordinates point to San Jose -- that's not CA?
20:18:23 <lispy> hmm...
20:18:39 <lispy> perhaps i changed that to San Jose last summer and forgot to change it back
20:18:42 <SamB> lispy obviously is confused as to his whereabouts
20:18:48 <dmwit> =D
20:18:52 * lispy goes looking for himself
20:18:58 <lispy> dmwit: i'm near portland, OR
20:19:44 <dmwit> Behold, the power of introspection.
20:19:50 <lispy> and i'm all out of beer
20:19:57 <lispy> i should go stock up
20:22:44 <dmwit> @. vixen yow
20:22:44 <lambdabot> my keyboard doesn't have an
20:23:09 <lispy> oh snap, that page is immutable
20:23:11 <lispy> :(
20:23:21 <heatsink> Can you log in?
20:23:30 <SamB> @. vixen yow
20:23:30 <lambdabot> is that why?
20:23:32 <SamB> @. vixen yow
20:23:33 <lambdabot> Beer, it's so much more than just a breakfast drink!
20:23:39 <dmwit> =)
20:23:40 <heatsink> heh
20:23:43 <SamB> hmm, how do you get it to show the input too?
20:23:59 <dmwit> tee?
20:24:05 <SamB> @help tee
20:24:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:24:09 <SamB> nope
20:24:14 <SamB> @help state
20:24:14 <lambdabot> state is a module.
20:24:17 <dmwit> It's a Linux joke.
20:24:19 <SamB> @listcommands state
20:24:19 <lambdabot> Unknown command, try @list
20:24:30 <SamB> dmwit: oh, I thought it was a guess based on a linux command
20:24:33 <lispy> heatsink: if there is a way to login i don't see it
20:24:40 <SamB> @list state
20:25:04 <heatsink> @wiki UserPreferences
20:25:21 <SamB> oh know
20:25:23 <heatsink> lispy: use the user preferences page
20:25:29 <SamB> did someone do a @list in the background again?
20:25:38 <dons> oh we should fix that
20:25:41 <lambdabot> state has no visible commands
20:25:42 <heatsink> it's linked from the front page.  You can create an acct & then log in.
20:25:51 <lambdabot> http://www.haskell.org/haskellwiki/UserPreferences
20:26:00 <dons> yes, someone did do a @list :)
20:26:05 <lispy> heatsink: oh, how ... intuitive... :)
20:26:09 <dmwit> It was me.
20:26:21 <dmwit> =/
20:26:25 <dons> its ok :) we should just link to a generated page or something instead
20:27:02 <dons> ?remember lambdabot Beer, it's so much more than just a breakfast drink!
20:27:12 <jrmole> @quote lambdabot
20:27:12 <lambdabot>  tERmIN473d
20:27:14 <jrmole> @quote lambdabot
20:27:14 <lambdabot>  Nobody brings small problems into a laundromat.
20:27:37 <SamB> hmm
20:27:44 <explicitjelly> is lambdabot written in haskell?
20:27:45 <SamB> I wonder if I did that earlier one...
20:27:49 <SamB> explicitjelly: yes!
20:27:53 <explicitjelly> SamB, cool.
20:28:09 <dons> ?version
20:28:09 <lambdabot> lambdabot 4p109, GHC 6.5 (OpenBSD i386 )
20:28:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:28:15 <dons> you can browse the src ^^
20:28:21 <dons> or visit the home page and learn more :)
20:28:23 <dons> ?where lambdabot
20:28:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:30:30 <dons> ?uptime
20:30:31 <lambdabot> uptime: 1 day, 21 hours, 31 minutes and 19 seconds, longest uptime: 1 day, 21 hours, 31 minutes and 19 seconds
20:31:50 <dmwit> @users
20:31:51 <lambdabot> Maximum users seen in #haskell: 220, currently: 197 (89.5%), active: 22 (10.0%)
20:32:19 <dmwit> Must be bed-time...
20:32:19 <dons> > 22 / 197 * 100
20:32:21 <lambdabot>  11.16751269035533
20:32:54 <dons> a bug !
20:33:00 <dons> and fixed.
20:33:35 <dmwit> That was quick. ^^
20:33:52 <dons> just rebuilding now
20:34:19 <heatsink> lispy: finished?
20:34:53 <dons> ?quit more code
20:35:50 <dmwit> @users
20:35:51 <dons> ?versi
20:36:06 <dons> silly freenode takes ages to settle
20:36:15 <lambdabot> Maximum users seen in #haskell: 220, currently: 198 (90.0%), active: 2 (1.0%)
20:36:17 <lambdabot> lambdabot 4p120, GHC 6.5 (OpenBSD i386 )
20:36:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:36:23 <dons> ?uptime
20:36:23 <lambdabot> uptime: 1 m  28s, longest uptime: 1 d, 21h, 35m  42s
20:36:46 <dons> some wibbles in the new formatting string to be done
20:38:58 <lispy> dons: did you figure out what was wrong with that one patch?
20:39:09 <dons> no idea
20:39:14 <dons> I suspect it wsa the seen state file
20:39:23 * lispy too
20:39:30 <dons> so removing it would fix things
20:39:36 <lispy> that one is binary so i didn't look at it, but the other one looed fine
20:41:46 <lispy> looking at the user map i should try to visit waggle or syntaxninja sometime
20:42:38 <lispy> dons: for now i just don't pull that patch
20:42:49 <dons> well, can't you just pul lthe patch, and delete your seen state?
20:43:01 <dons> or doesn't that help?
20:43:10 <dons> rm State/seen
20:43:19 <dons> ?quit wibbles
20:44:03 <lispy> dons: do you think maybe it's broken because my seen data has diverged from yours?
20:44:04 <dons> ?uptime
20:44:04 <explicitjelly> jrmole, Cale, thanks again for your help
20:44:09 <jrmole> no problem
20:44:14 <explicitjelly> jrmole, Cale, I think it's clear now.
20:44:14 <lispy> dons: i guess that makes sense
20:44:16 <dons> lispy, it'd would be broken because we changed the seen state type
20:44:24 <lispy> ah
20:44:25 <dons> so that when it is parsed back in, it builds some boguys value
20:44:31 <lambdabot> uptime: 43s, longest uptime: 1d 21h 35m 42s
20:44:37 <explicitjelly> jrmole, Cale, tomorrow, I will implement my own State monad (and perhaps others) so that it finally sticks :)
20:44:48 <explicitjelly> but i've gotta sleep now.
20:44:50 <explicitjelly> n8!
20:44:55 <jrmole> cool, ttyl
20:45:08 <explicitjelly> (detach)
20:45:16 <heatsink> @quote
20:45:17 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
20:45:30 <lispy> heh
20:45:37 <lispy> @quote
20:45:38 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
20:45:46 <heatsink> :)
20:45:54 <heatsink> @quote
20:45:54 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
20:48:16 <jrmole> @quote
20:48:17 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
20:49:09 <jrmole> woo, i'm famous
20:49:21 <jcreigh> FSVO famous
20:49:27 <jcreigh> :)
20:49:34 <jrmole> FSVO?
20:49:39 <jcreigh> For Some Value Of
20:49:51 <jrmole> hehe
20:50:19 <SamB> I can see it now! Jr. Mole, right up next to Tim Toady!
20:51:08 <stepcut> ?quote protontorpedo
20:51:08 <lambdabot> protontorpedo hasn't said anything memorable
20:51:15 <stepcut> ?protontorpedo
20:51:15 <lambdabot> how abut vs APL
20:51:33 <SamB> @protontorpedo
20:51:33 <lambdabot> am I cracked?
20:51:36 <SamB> @protontorpedo
20:51:36 <lambdabot> I got some info b 4 about how lazy eval makes macros not needed please expand...
20:51:48 <SamB> @protontorpedo
20:51:49 <lambdabot> paul graham said static typing is a problem for macros building
20:52:09 <stepcut> heh, what a pun '...macros not needed please expand...'
20:52:26 <SamB> hehe
20:52:35 <SamB> glad I'm not the only one who thought so ;-)
20:52:38 <SamB> @protontorpedo
20:52:39 <lambdabot> is functional progrmaming the same as object oriented?
20:52:42 <SamB> hah!
20:52:43 <SamB> @protontorpedo
20:52:44 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
20:52:44 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
20:52:53 <jcreigh> Who's protontorpedo?
20:53:01 <stepcut> jcreigh: troll
20:53:03 <jcreigh> (stupid, troll, or both?)
20:53:05 <dons> a troll we found amusing
20:53:11 <dons> though not while he was here
20:53:14 <SamB> similar to keal?
20:53:29 <dons> more annoying, less insane
20:53:33 <SamB> mmm
20:53:36 <SamB> @keal
20:53:36 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
20:53:44 <SamB> @keal
20:53:44 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
20:53:48 <dons> he'd  use multiple names in multiple channels to pretend to be a newbie for 10 months
20:53:57 <dons> now he's banned in 5-6 prog. lang chans
20:54:05 <SamB> really?
20:54:10 <SamB> why did he need to pretend?
20:54:38 <dons> see bottom of: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
20:55:03 <dons> he'd just ask the same scripted questions ... for months
20:55:14 <dons> leading to long Q and A sessions from just about everyone here
20:56:51 <dons> anyone know any tricks for pdf -> ascii conversion?
20:57:19 <SamB> you mean like pdftotext?
20:57:27 <dons> perhaps ...
20:57:45 <dolio> If that's too simple, pdf2ps | ps2ascii
20:58:00 <dons> yeah, that doesn't work for me
20:58:06 <dons> ps2ascii gives no output
20:59:48 <lennart> @palomer
20:59:49 <lambdabot> woof
20:59:59 <SamB> @quote palomer
20:59:59 <lambdabot> palomer hasn't said anything memorable
21:00:14 <SamB> @quote arr
21:00:14 <lambdabot> arr hasn't said anything memorable
21:00:41 <SamB> @yarr
21:00:41 <lambdabot> Smartly me lass
21:00:43 <SamB> @arr
21:00:43 <lambdabot> Yo ho ho, and a bottle of rum!
21:00:46 <SamB> @yarr
21:00:46 <lambdabot> I'll crush ye barnacles!
21:00:48 <SamB> @yarr
21:00:48 <lambdabot> Yo ho ho, and a bottle of rum!
21:00:58 <dons> pdftotext worked :) thanks
21:01:02 <dons> ?karma+ SamB
21:01:02 <lambdabot> SamB's karma raised to 11.
21:01:37 <SamB> heh, "actually it bug in math"
21:03:35 <audreyt> SamB: history-v2?
21:03:52 <SamB> audreyt: huh?
21:04:08 <audreyt> oh. nvm
21:04:44 <audreyt> bad context. it's kealList
21:04:47 <SamB> oh great: "i only trust opensource tools. where can i download haskell for windows?"
21:05:06 <dons> audreyt: heh
21:05:10 * SamB wonders what we would want a # function for
21:05:12 <audreyt> spj in history-v2.pdf said that guard clauses in haskell fixes a bug in mathematica notation
21:05:30 <audreyt> i.e. guards in math aligns to right, where it should align to left
21:05:52 <dons> bug in math
21:06:40 <audreyt> dons: btw, nice timeline :)
21:06:50 <SamB> hmm, did kealList exist before keal left?
21:07:02 <SamB>     ,"making a bot of me is highly offensive"
21:07:05 <dibblego> in conversation the other day, a friend told me about a book he has lying around called "beginner's guide to haskell" -- but I find no such title - is there anything similar that just isn't popping up in google for some reason?
21:07:16 <dons> audreyt: oh its mostly Bernie Pope's work. I did the date spotting, he did all the renderising
21:07:28 <audreyt> cool. what software did Bernie use to make that?
21:07:39 <dons> inkscape
21:07:42 <dons> pretty nice, eh?
21:07:58 <Cale> make what?
21:07:59 <audreyt> indeed
21:08:08 <SamB> indeed, what?
21:08:11 <dons> the timeline of haskell, Cale.
21:08:18 <SamB> which is...?
21:08:20 <Cale> ah
21:08:26 <SamB> @timeline
21:08:26 <lambdabot> Unknown command, try @list
21:08:26 <Cale> yeah, inkscape rules
21:08:31 <SamB> @where timeline
21:08:31 <lambdabot> I know nothing about timeline.
21:08:31 <dons> http://www.cs.mu.oz.au/~bjpop/timeline/timeline.4.png
21:08:37 <dons> ?where+ timeline http://www.cs.mu.oz.au/~bjpop/timeline/timeline.4.png
21:08:38 <lambdabot> Done.
21:08:57 <Cale> there was one with a legend
21:09:03 <dons> ah yes. hmm
21:09:08 <Cale> http://www.cs.mu.oz.au/~bjpop/timeline/timeline.5.png
21:09:20 <dons> ?where+ timeline http://www.cs.mu.oz.au/~bjpop/timeline/timeline.5.png
21:09:20 <lambdabot> Done.
21:09:22 <audreyt> mmm 20 years.
21:09:46 <SamB> but FFI only for 3 years!
21:09:49 <jrmole> i like how _|_OHCC is in the same category as the invention of the language
21:10:38 <Cale> I love how the Haskell 98 report came out in 1999
21:10:40 <SamB> that is the "beginnings" category?
21:10:52 <SamB> Cale: timed to match the release of Windows 98?
21:10:57 <audreyt> no, "meetings"
21:11:05 <SamB> oh
21:12:08 <SamB> wow, 9 years without GHCi? how did anyone survive?
21:12:27 <audreyt> hugs, most likely.
21:12:32 <SamB> hmm
21:12:40 <jrmole> it's interesting that when GHC came out, it was too big to run on most personal workstations
21:12:53 <dons> it was?
21:12:56 <SamB> that was like a three year wait...
21:12:58 <dons> I suppose it was.
21:13:02 <SamB> hugs, I mean...
21:13:04 <jrmole> according to the history paper
21:13:11 <audreyt> actually, no
21:13:14 <audreyt> Gofer :)
21:13:25 <dons> hbi
21:13:35 <audreyt> oh, there was hbi?
21:13:37 <dons> $ hbi
21:13:37 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
21:13:37 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
21:13:37 <dons> Type "help;" to get help.
21:13:37 <dons> >
21:13:38 <SamB> gofer looks like it was about half a year before GHC ;-)
21:13:40 <dons> there _is_ hbi
21:13:50 <jrmole> gofer wasn't exactly haskell, either
21:13:52 <SamB> it isn't on the timeline
21:13:57 <audreyt> nice use of exclamation mark in "Jun 29!"
21:14:02 <SamB> hbi
21:14:04 <dons> gofer is close enough to be haskell
21:14:06 <SamB> I mean...
21:14:14 <dons> i used it in a haskell course in '99
21:14:21 <dons> (you just had to write your own instances, instead of deriving)
21:14:28 <audreyt> I wonder which value is the value in prelude.
21:14:45 <SamB> which what value?
21:14:50 <audreyt> 06:09 < dons> Loading prelude... 1 values, 4 libraries, 200 types found.
21:14:55 <dons> > help;
21:14:56 <dons>                 HBI  -- Interactive Haskell B 1.3
21:14:56 <lambdabot>  Parse error
21:15:07 <dons> > whatis ();
21:15:07 <dons> constructor (Prelude.()) :: (Prelude.())
21:15:07 <dons> data (Prelude.()) = (Prelude.Prelude.())
21:15:07 <dons> instances Array.Ix (Prelude.()), Prelude.Bounded (Prelude.()), Prelude.Enum (Prelude.()), Prelude.Eq (Prelude.()), Prelude.Ord (Prelude.()), Prelude.Read (Prelud
21:15:08 <lambdabot>  Parse error
21:15:10 <dons> e.()), Prelude.Show (Prelude.())
21:15:12 <audreyt> aha.
21:15:13 <dons> hbi is cool
21:15:32 <dons> ?hoogle ()
21:15:33 <audreyt> indeed
21:15:34 <lambdabot> Did you mean: ()
21:15:34 <lambdabot> Prelude.undefined :: a
21:15:34 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:15:45 <audreyt> ugh, bug
21:16:12 <dons> yeah, hbi++ hoogle--
21:17:01 <audreyt> dons: is sjanssen still hacking at fps?
21:17:19 <dons> yeah, I think so
21:17:37 <dons> i'll be doing a merge soon (been a bit caught up with paper writting)
21:18:01 <audreyt> so his work is in fps-unstable?
21:18:08 <dons> nope, its in fps-soc
21:18:25 <dons> but it'll move into maybe a fps-vector package, and some into fps-unstable
21:18:28 <dons> something like that
21:18:47 <audreyt> gotcha.
21:19:55 <goltrpoat> sort of an organization question here.  started working on my haskell chess program.  the simplest search function is something like alphabeta pos a b depth [] = ... (evaluate, either stalemate or mate), alphabeta pos a b 0 _ = static_eval pos, and the actual implementation is something along the lines of alphabeta pos a b depth (m:ms) = let score = alphabeta (makeMove pos m) -b -a depth-1 in if (score > beta) then beta else alpha
21:20:19 <goltrpoat> trouble is, in a real-world program, alphabeta is going to be composed of a large number of computations, that one would want to be able to drop in and swap out
21:20:55 <goltrpoat> so my first thought was combinators, but i don't know what the hell the monad is going to be, and the whole thing doesn't really feel monadic to begin with
21:20:59 <goltrpoat> ideas?
21:21:44 <goltrpoat> sorry if that's not stated terribly clearly, long day
21:21:56 <jrmole> only somewhat related, but have you seen http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf
21:22:17 <jrmole> ends with a general implementation of alphabeta
21:22:22 <audreyt> there's code in http://www.hcsw.org/haskell/ttt.tgz
21:22:33 <jrmole> anyway, what do you mean by drop in / swap out?
21:22:47 <audreyt> GameAI.hs
21:23:31 <SamB> hmm, my Cabal does not like lambdabot's cabal file...
21:23:43 * SamB goes to bed like he shoulda done over an hour ago...
21:23:57 <goltrpoat> reading the pdf, thanks..  by drop in and swap out i mean there is any number of computations that might end up getting dropped into alphabeta as the program is developed.  some examples are ordering moveList@(m:ms) in order to maximize pruning, adding transposition table lookup, stuff like that
21:25:17 <goltrpoat> oh, i remember reading chapter 5 from that paper, actually
21:25:38 <goltrpoat> this is a little bit less general than what i'm talking about
21:26:55 <lennart> dons:  hbi!  I've not seen that in a while
21:27:07 <lennart> it was too much ahead of its time ;)
21:27:14 <goltrpoat> similar thing with the tictactoe tgz that audrey mentioned
21:28:03 <goltrpoat> i mean, i can certainly write the various improvements to alphabeta as separate functions, and make it work, i was just trying to figure out if there's a nice modular way of doing it
21:29:04 <jrmole> goltrpoat, can you state each transformation as a function on move lists?
21:30:15 <dons> lennart: I agree! lambdabot's only just catching up. I should dive in to hbi and do some more exploring, see what can be stolen^h^h^h adapted.
21:30:16 <goltrpoat> no, there's a number of things that don't even require a move list.  one common pruning strategy is null moves, for instance -- you (illegally) give the opponent two moves in a row, and if they fail low, then there's no reason to care about the rest of the subtree
21:31:07 <goltrpoat> that's usually inserted before you generate the move list to begin with
21:32:03 <goltrpoat> then, move lists are typically ordered by using past knowledge -- eg, this move caused a beta cutoff at a bunch of nodes ive previously considered, so let's see if that move is legal in the current node, if so, put it up front
21:33:00 <audreyt> dons: Stringable etc looks very much fine, but there's no code that deals with unicode at all?
21:33:08 <audreyt> dons: I think I'll just start hacking soon
21:33:22 <audreyt> just want to make sure it's not duplicating existing effort
21:33:55 <audreyt> what I'd need is a Stringable  thing that dynamically uses Char8, Char16 and Char32 underneath
21:34:07 <audreyt> roped together in a finger tree
21:34:23 <dons> audreyt: I think there is unicode, but its not in yet. You might just want to have a chat with sjanssen about where to take things
21:34:29 <dons> but yeah, feel free to just go for it
21:34:32 <SamB> wouldn't that be slow?
21:34:33 <goltrpoat> basically, i don't really know what i'm asking.  i can write the whole thing in a relatively straightforward manner, but it'll be hard to change later on.  from past experience, the evaluation function is the type of thing that changes day to day, and it'd be nice to come up with a way to just turn it into a chain of computations, and drop in specific ones that we care about
21:34:34 <lennart> hmmm, no hbi on the timeline
21:34:36 <SamB> oh oops I should be sleeping
21:34:44 <dons> lennart: ah good idea. hbc, but no hbi.
21:34:46 <audreyt> SamB: why? I expect it to be faster than the current alternatives
21:34:58 <lennart> the timeline needs some colour explanation as well
21:35:00 <dons> lennart: I agree, hbi should be up there.
21:35:15 <audreyt> goltrpoat: will the eva function change its type?
21:35:20 <dons> you looking at the version with a key?
21:35:22 <dons> ?where timeline
21:35:22 <lambdabot> http://www.cs.mu.oz.au/~bjpop/timeline/timeline.5.png
21:35:28 <SamB> audreyt: is it using all these Word types in the same string?
21:35:31 <goltrpoat> audrey:  no
21:35:48 <audreyt> gaal: then make it parameterize on the eval function...
21:35:54 <audreyt> er, wrong nick
21:36:05 <audreyt> goltrpoat: then make take the eval function as input...
21:36:11 <audreyt> use an implicit param if you must :)
21:36:22 <goltrpoat> input to what?
21:36:55 <audreyt> to your alphabeta function?
21:37:08 <audreyt> SamB: no... the idea is that a string has segments
21:37:15 <audreyt> each chunk uses the most efficient representation
21:37:16 <goltrpoat> oh, sorry, i thought you meant eval, as in, the alpha-beta function
21:37:18 <audreyt> which is usually Char8
21:37:32 <audreyt> but Char16 if needed
21:37:32 <SamB> audreyt: so, these segments are not divided based on what size the chars are?
21:37:37 <audreyt> and Char32 if really needed
21:37:48 <audreyt> nope
21:37:59 <SamB> oh, okay, that sounds efficient enough then ;-)
21:38:00 <audreyt> say you have a perl6 string literal
21:38:02 <audreyt> "foo"
21:38:06 <audreyt> that will get repr as Char8
21:38:06 <goltrpoat> nah, the static evaluation happens at leaf nodes, right.  there's a lot of stuff that happens between the root and the leaves though.
21:38:17 <audreyt> and when you concat with "SomeChineseString" here
21:38:20 <audreyt> which gets repr as Char16
21:38:31 <audreyt> a Rope is forme dwithout changing the underlying structures
21:38:43 <goltrpoat> the eval function gets called a lot, but the point is that we'd like to avoid ever getting to the eval function.  so there's a number of heuristics that get inserted *during* the search.
21:39:00 <audreyt> and if you flatten a Rope, it turns into a Char16, but you don't normally flatten a Rope until you need to FFI out.
21:39:01 <goltrpoat> the eval function itself stays "relatively" constant during development
21:39:23 <audreyt> goltrpoat: aha. gotcha.
21:45:04 <lennart> dons: wow, it seems hbi has been around at least since 1992 :)
21:45:25 <dons> huh! 15 years of interactive haskell eh?
21:46:25 <dons> Date: Mon, 13 Jul 92 08:48:02 +0100
21:46:26 <dons>   hbi                   if you want to write large Haskell programs.
21:46:27 <dons>                         hbi is an interactive version.  Written in LML.
21:46:27 <dons>                         You need a big machine.
21:46:59 <dons> "You need a big machine." heh
21:47:09 <lennart> yeah, but i think it was available earlier.  The July 29 announcment on c.l.f doesn't mention hbi as anything new
21:47:21 <goltrpoat> obligatory:  "i think i need a bigger box."
21:47:23 <lennart> but existential type were new in that version :)
21:47:28 <dons> yeah, the above is in a haskell status report, where it is already known, it seems
21:48:24 <dons> the first reference to hbc I can find is Date: Fri, 19 Oct 90 17:18:55 +0100
21:49:08 <dons> here, http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00031.html
21:49:10 <lambdabot> Title: 'deriving' in Haskell 'interface's, http://tinyurl.com/fwo6e
21:50:42 <lennart> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/de6ed4ddbb84b3ba/22278300a655f7dd?lnk=st&q=haskell+b+compiler+group%3Acomp.lang.functional&rnum=5&hl=en#22278300a655f7dd
21:50:44 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/zszz9
21:51:10 <dons> ah cool!
21:51:18 <lennart> "(,) is allowed and is the (curried) pairing function."
21:51:22 <dons> we should get hold of these archives and index them
21:51:46 <lennart> I can't remember, does H98 allow (,) ?
21:52:07 <dons> yeah, Hugs.Base>  (,) 1 2
21:52:07 <dons> (1,2)
21:52:36 <Cale> > (1,) 6
21:52:36 <lambdabot>  Parse error
21:52:43 <Cale> That doesn't work though :)
21:52:45 <dons> > (,) 1 2
21:52:46 <lambdabot>  (1,2)
21:53:01 <Cale> but it's just as easy to write (,) 1
21:53:39 <dons> ?remember lennart L M L  version 0.99. FTP a copy now and a free Haskell compiler is included.
21:55:25 <dons> ?remember lennart [August 1990] DON'T BLAME HASKELL WHEN THINGS GO WRONG
21:55:34 <lennart> lol
22:02:33 <dons> ?where+ comp.lang.functional http://groups.google.com/group/comp.lang.functional/about?hl=e
22:02:34 <lambdabot> Done.
22:03:05 <tessier> Can't believe Haskell has been around for so long and nobody has heard of it
22:03:17 <tessier> So many languags out there, none materially better than any other. We have only religion to guide us. :(
22:03:57 <dons> ?users #haskell
22:03:58 <lambdabot> Maximum users seen in #haskell: 220, currently: 195 (88.6%), active: 15 (7.7%)
22:04:05 <dons> ?users #perl6
22:04:06 <lambdabot> Maximum users seen in #perl6: 139, currently: 127 (91.4%), active: 3 (2.4%)
22:04:11 <dons> ;)
22:04:37 <dibblego> ?users #perl
22:04:37 <lambdabot> Maximum users seen in #perl: 1, currently: 0 (0.0%), active: 0 (NaN%)
22:04:42 <dons> heh
22:04:53 <dibblego> wtf?
22:04:56 <tessier> 441 in #perl actually
22:04:59 <dons> (lambdabot doesn't bahve well on channels its not in)
22:05:40 <int-e> (NaN%)
22:05:46 <int-e> nice.
22:05:48 <foxy> time to play guess the author...
22:06:27 <dons> heh, "Views in Haskell---why were they removed?                       x  %Bjorn Lisper
22:06:30 <dons> _ 1 Ben Lian Jun 12 1990"
22:07:05 <foxy> "Beings within the world are things, natural things, and "valuable" things.  Their thingliness becomes a problem.  And since the thingliness of the latter is based upon natural thingliness, the being of natural things, nature as such is the primary theme.
22:08:03 <dons> its not Borges?
22:08:10 <dons> ?google Beings within the world are things, natural things, and "valuable" things
22:08:14 <lambdabot> http://hughhewitt.townhall.com/
22:08:14 <lambdabot> Title: Hugh Hewitt
22:09:15 <dons> I guess not
22:10:33 <dons> oh, I was thinking of: "animals are divided into:  1. those that belong to the Emperor,  2. embalmed ones, ... 4. suckling pigs,  5. mermaids,  6. fabulous ones, ..10. innumerable ones,  8. those included in the present classification,"
22:10:44 <dons> 14. those that from a long way off look like flies.
22:11:57 <goltrpoat> dons:  that's been quoted in about fifteen bajillion different essays though
22:12:24 <dons> sure
22:12:39 <vincenz> o.O
22:12:42 <vincenz> never heard that before
22:17:26 <goltrpoat> it's supposedly an old (pre-Ming) chinese taxonomy that i suspect has got more to do with writing than it does with species
22:20:42 <Cale> These ambiguities, redundances, and deficiences recall those attributed by Dr. Franz Kuhn to a certain Chinese encyclopedia entitled Celestial Emporium of Benevolent Knowledge. On those remote pages it is written that animals are divided into (a) those that belong to the Emperor, (b) embalmed ones, (c) those that are trained, (d) suckling pigs, (e) mermaids, (f) fabulous ones, (g) stray dogs, (h) those that are included in this class
22:20:42 <Cale> ification, (i) those that tremble as if they were mad, (j) innumerable ones, (k) those drawn with a very fine camel's hair brush, (l) others, (m) those that have just broken a flower vase, (n) those that resemble flies from a distance.
22:24:04 <dons> i thought it was a fictional pseudo-reference, like Borges often uses. but I see some people think it may be real (despite evidence for this;)
22:25:07 <goltrpoat> i have to say i like h
22:25:32 <dons> it's a bit FP :)
22:25:35 <goltrpoat> hehe
22:33:17 <audreyt> I just reread MinCaml paper
22:33:24 <audreyt> and gosh I hope there's something like that for Hs :)
22:34:15 <audreyt> it really motivates newcomers to learn ML, and meanwhile that paper reinforces the idea that Haskell is 1)more complex 2)much slower
22:34:35 <audreyt> ( http://www.kb.ecei.tohoku.ac.jp/~sumii/pub/FDPE05.pdf )
22:35:09 <dons> core haskell is pretty easy to hack up. we do a minihaskell in our prog. lang. course for undergrads
22:35:13 <audreyt> which, though we know that it's not always true (and not as dramatic as most believe), it's kinda hard to show it easily
22:35:22 <audreyt> dons: ooh. code? papers? slides?
22:35:33 * dons finishes off bytestring paper with good graphs 
22:36:30 * audreyt looksForward >>= readByteStringPaper
22:36:51 <dons> our minihaskell also beats gcc for lots of things
22:36:57 <dons> (recursion, fib ... )
22:37:03 <dons> the kind of things you can write in a mini haskell
23:31:08 <lispy> > beer >>= lispy
23:31:09 <lambdabot>  Not in scope: `lispy'
23:32:15 <dons> ?pl beer >>= return . lispy
23:32:16 <lambdabot> lispy `fmap` beer
23:32:26 <lispy> lol
23:32:48 <int-e> ?free beer
23:32:49 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
23:33:12 <lispy> not free as in beer, free as in speech! :)
23:33:28 <int-e> I doubt free speech would fare any better.
23:34:04 <lispy> ?free join
23:34:06 <lambdabot> Expected variable or '.'
23:34:16 <lispy> ?free (++)
23:34:17 <dolio> ?type beer
23:34:18 <lambdabot> Not in scope: `beer'
23:34:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
23:34:26 <lispy> ?free concat
23:34:28 <lambdabot> $map f . concat = concat . $map ($map f)
23:35:09 <lispy> i wonder, if you took the output of free and had quickcheck check it, and it was false, 1) is that possible 2) you have a bug?
23:37:13 <dolio> When they were first putting the free theorems together, I seem to recall someone saying that seq (among other things?) make the free theorems not always true.
23:37:28 <dolio> I'm not sure how relevant that'd be in most cases.
23:38:08 <lispy> well, seq breaks eta reduction so not surprising that it causes problems
23:38:36 <lispy> basically, seq doesn't truely belong in a 'true' lambda calculus
23:39:30 <lispy> i forget the exact example, but i know the #haskell logs contain it...
23:40:03 <Cale> I think the worst that you can have happen is that one side of the resulting equation becomes bottom while the other is not.
23:40:15 <dolio> It might not matter for something like unit testing, unless you're testing conditions on bottom.
23:40:32 * lispy has just watch a video on the potential falsity of the american lunar landing and a video that challenges the accepted theories of the origins of man so is open to debate :)
23:40:53 <lispy> i don't tend to test bottom
23:42:03 <lispy> Cale: you're a professor right?
23:42:08 <Cale> not at all
23:42:16 <Cale> I just have a BMath degree.
23:42:30 <lispy> oh hmm...ithought you were an instructor of some sort
23:42:43 <Cale> People always seem to think that I'm far more educated than I actually am :)
23:42:53 <lispy> heh, good for you :)
23:42:59 <lispy> if i may ask....what do you do?
23:43:07 <Cale> Look for jobs? :)
23:43:47 <lispy> okay, i'll ask something less personal...where can i find online forums full of people studying math...there is #math but where else?
23:43:49 <int-e> Cale: people asked about your folds.svg, do you still have it?
23:44:06 <Cale> int-e: I replied to Pupeno on that. I linked it from cale.yi.org
23:44:43 <Cale> lispy: Planetmath.org, I suppose
23:44:56 <int-e> Cale: ah, nice :)
23:45:08 <lispy> Cale: here http://blog.codersbase.com/2006/08/17/learn-math-10-tips/ i say that you should find a community of other math learners, so i'm curious if you've found one i can share with the world :)
23:45:11 <lambdabot> Title: dagit.o » Blog Archive » Learn Math (10 tips), http://tinyurl.com/g4ddd
23:45:23 <Cale> lispy: I plan to get some small programming job and make some money, pay off my debts and go travelling for a bit. Then I'll probably return to academia.
23:45:44 <lispy> Cale: that sound very familiar
23:46:16 <Cale> I had to spend some time in decompression after finishing my degree.
23:46:27 * lispy is finishing his masters, plans to work for a bit to pay some more debt and will eventually get an advanced degree in math most likely
23:46:33 <Cale> cool
23:47:11 * goltrpoat is finishing his beer, plans to go have a cigarette in a bit, and eventually get back to work, since he has a deadline on monday
23:47:17 <Cale> heh
23:47:20 <lispy> i once had an account an planetmath i should check there again and see if it still works :)
23:47:31 <lispy> goltrpoat: heeh
23:48:06 <lispy> i have a deadline in september and one in decemeber...but since the specificiation of what i'm supposed to deliver has yet to be written i'm not so worried
23:48:51 <dolio> There's sci.math*
23:48:56 <goltrpoat> i wrote the specification
23:48:59 <lispy> but i get to use haskell so i work on it a fair bit...the code i have written has a lot of tests and documentation, it just doesn't do much
23:49:00 <goltrpoat> which is what makes me worried
23:49:11 <dolio> But that seems to be dominated by people who argue with various nuts who think they've disproved set theory and stuff.
23:49:42 <lispy> dolio:hmm...i should try to look it up on google groups
23:49:53 <dolio> http://groups.google.com/group/sci.math?lnk=oa
23:49:55 <lambdabot> Title: Google Groups: sci.math, http://tinyurl.com/z47hd
23:50:02 <lispy> so far then, i have, #math, sci.math* and planet math
23:50:26 <Kahdloc> wikipedia isn't bad
23:50:39 <goltrpoat> im not sure if there's much of a substitute for reading books and doing exercises until your ears bleed
23:50:47 <dolio> I guess most of the threads on sci.math aren't that bad.
23:50:50 <goltrpoat> i mean, the internet is great and all, but it won't teach you math
23:50:51 <lispy> i've heard that until you have 3 different proofs for something you don't understand it...so maybe three different forums is a good start (assuming the analogy carries over)
23:51:03 <dolio> It's just that the ones with nuts are orders of magnitude larger.
23:51:05 <Kahdloc> goltrpoat, it can, if you want it to :)
23:51:24 <lispy> goltrpoat: right, i want some bit of human interaction to compliment the reading and doing
23:51:25 <goltrpoat> if you ask it nicely?
23:51:25 <goltrpoat> hehe
23:51:30 <goltrpoat> ah right
23:51:33 <goltrpoat> yeah, #math is great.
23:51:45 <goltrpoat> and planetmath and maybe mathworld
23:52:09 * lispy makes a note
23:52:10 <goltrpoat> the latter tends to be written better, on average -- but also have a lot more mistakes, on average
23:52:10 <Kahdloc> hmm, sounds like a #math type conversation.
23:52:28 <lispy> i sohuld join #math by default but i don't...lame me
23:52:44 * lispy tries to correct the situation
23:52:48 <goltrpoat> by #math i mean efnet #math, i have no idea what the freenode one is like
23:53:02 <Kahdloc> didn't know efnet had a #math
23:53:10 <lispy> efnet has everything
23:53:11 <Adamant> freenode #math is good
23:53:16 <Kahdloc> relatively.
23:53:19 <lispy> in fact, they have the best #gba channel i've seen
23:53:22 <Adamant> it's got Cale, what more do you need?
23:53:26 <Adamant> ;)
23:53:32 <lispy> heh
23:53:44 <dons> that's a good thing about haskell. we don't get trolls arguing that they've proved that [a] doesn't type check and so on
23:53:48 <Kahdloc> there's always a few math geeks in #math
23:54:10 <lispy> dons: i could start if you like :)
23:54:11 <dons> (unlike math nuts who claim that math is broken)
23:54:19 <lispy> > [a] :: [Int] -- wtf?
23:54:20 <lambdabot>  Not in scope: `a'
23:54:27 <Adamant> I don't think very many of the freenode channels get real trolls.
23:54:27 <lispy> @keal
23:54:28 <lambdabot> you need a Zh function in Haskell
23:54:32 <dons> lambdabot says there's a flaw in your reasoning , lispy
23:54:41 <Kahdloc> dons, arguing math is broken would be like saying the haskell specification is broken.
23:54:45 <lispy> dons: no, bug in maths!!!!
23:54:58 <dons> ?keal
23:54:59 <lambdabot> my proof show math is broken right now
23:55:00 <Kahdloc> and i'm sure several people think haskell's spec. is broke.
23:55:03 <dons> ha!
23:55:10 <dolio> I was reading one of the huge sci.math threads recently...
23:55:17 <lispy> Kahdloc: there have been some mathematicians that have succeed in that argument tho...look at cantor for instance
23:55:27 <dolio> The main guy seemed to be arguing that all mathematicians are lazy/stupid, because they don't prove their axioms.
23:55:31 <dolio> And that's why science is better.
23:55:40 <Adamant> how do you prove axioms? WTF?
23:55:50 <dons> Kahdloc: i was referring to the nut/troll keal, who used to come in here to say that math was broken :)
23:55:51 <Kahdloc> uh...yeah....
23:55:54 <dolio> Adamant: If you weren't so lazy, you'd know! :)
23:56:10 <Kahdloc> why would you complain about math in #haskell?
23:56:21 <Kahdloc> we don't complain about haskell in #math :/
23:56:24 <dibblego> using logic in imperative programming language channels is generally considered trolling
23:56:25 <dons> i guess we're just good listeners
23:56:36 <dons> dibblego: heh!
23:56:40 <lispy> heh
23:56:46 <dibblego> at least, that's been my experience
23:56:50 <dons> ?remeber dibblego using logic in imperative programming language channels is generally considered trolling
23:57:01 <dibblego> remember?
23:57:03 <dylan> LOL
23:57:06 <jrmole> @quote
23:57:07 <lambdabot> Taral says: But I can do DP in C, which has no RT
23:57:07 <dons> (expect to see that in the HWN on  tuesday...)
23:57:22 <dibblego> do you mean remeber or remember?
23:57:26 <lispy> DP in C?
23:57:33 <Kahdloc> what's an RT?
23:57:34 <dons> dibblego: i did, but lambdabot worked it out
23:57:37 <dons> ?quote dibblego
23:57:37 <lambdabot>  using logic in imperative programming language channels is generally considered trolling
23:57:56 <dibblego> clever lambdabot
23:58:17 <jrmole> Kahdloc, runtime probably
23:58:33 <Kahdloc> jrmole, what?
23:58:48 <jrmole> i presume that's what was meant by RT
23:58:54 <Kahdloc> oh, i see.
