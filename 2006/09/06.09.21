00:14:22 <es> what breaks 'do' block? I thought failure in pattern matching, which will call fail. But it seems to me Nothing also breaks it?
00:16:18 <astrolabe> You mean a do block for the Maybe monad?
00:16:37 <es> yes
00:17:14 <dons> > do Nothing :: Maybe ()
00:17:16 <lambdabot>  Nothing
00:17:23 <dons> > do fail "yikes" :: Maybe ()
00:17:24 <lambdabot>  Nothing
00:17:49 <dons> > do return () :: Maybe ()
00:17:50 <lambdabot>  Just ()
00:23:27 <ibid> es: in the maybe monad, nothing is the same as fail "whatever"
00:24:42 <es> I'm sorry I'm just beginning haskell here. I don't know how to demonstrate properly. but it's something like this:
00:25:01 <es> do Nothing :: Maybe (); Just 4 :: Maybe Int
00:25:23 <es> (not exactly that) but it didn't go through to Just 4, it breaks at Nothing
00:25:48 <Thomas2_> that's what the maybe monad does
00:25:53 <Thomas2_> Nothing is like throwing an error
00:25:56 <Thomas2_> it stops the computation there
00:26:01 <Thomas2_> this is sort of the whole point of that monad
00:26:02 <ibid> as i said, in Maybe, Nothing is the same as fail "whatever"
00:26:05 <dons> > do Nothing ; Just 4 :: Maybe Int
00:26:07 <lambdabot>  Nothing
00:26:25 <dons> > do fail "right here" ; Right 4 :: Either String Int
00:26:27 <lambdabot>  Left "right here"
00:26:40 <dons> > do Left "stop!" ; Right 4 :: Either String Int
00:26:42 <lambdabot>  Left "stop!"
00:26:49 <es> Ooo... so when there's failure in pattern matching and fail is called, it wasn't fail that breaks the block, but the fact that fail's value is Nothing breaks the block?
00:27:06 <Thomas2_> well, these are connected
00:27:13 <Thomas2_> fail is usually meant to do something that stops the computation
00:27:41 <Thomas2_> > do Left "stop!" ; Right 4
00:27:43 <lambdabot>  Left "stop!"
00:30:02 <dons> > do Right 1 ; Right 2 ; Right 3 ; Left "stop!" ; Right 4 ; Right 5 ; Right 6 -- monads forever!
00:30:04 <lambdabot>  Left "stop!"
00:31:27 <norpan> es: look at the definition of the (>>=) function for the monad
00:31:57 <norpan> for the maybe monad it's something like Nothing >>= _ = Nothing
00:33:42 <es> Oooo.. ic. it didn't break it. I understand now. thank you very much.
00:33:48 <bartw> moin
01:11:14 <dcoutts__> hia Lemmih
01:11:26 <dcoutts__> nice paper, sad to hear you couldn't present it
01:11:43 * dcoutts__ announces Codec.Compression.GZip & .BZip on the haskell mailing list
01:14:08 <dons> dcoutts__: hey, just talked to ozone , he's going to write a quicktime decoder over bytestrings
01:14:16 <dcoutts__> cool!
01:14:24 <dons> as part of his real world job, I think
01:14:26 <dons> so that's good
01:14:33 <dcoutts__> aye, indeed
01:15:08 <dons> so we have compression, and audio (Hogg), and soon video streaming with lazy bytestrings :)
01:15:16 <dcoutts__> yay!
01:15:32 <dcoutts__> next: iconv, binary serialisation, ...
01:15:56 <dons> yeah binary, and a full set of parsec-ish combinators
01:16:17 <dcoutts__> dons: oh, we still need to fix the semi-closing of handles on lazy reads/writes
01:16:25 <dons> I wonder how hard it would be to get haddock to colorise with HsColor inline code?
01:16:39 <dons> oh hmm
01:16:50 <dcoutts__> haddock doesn't really parse all the code like that
01:16:51 <dons> you mean, they're not semi closed atm?
01:16:55 <dcoutts__> right
01:17:02 <dons> oh, I thought we'd fixed that :/
01:17:23 <bourbaki> moin
01:17:24 <dcoutts__> not yet
01:23:43 <bourbaki> not yet what?
01:23:54 <dcoutts__> bourbaki: before you arrived :-)
01:24:40 <bourbaki> ah ok sry
01:41:37 <mux> ?seen dons
01:41:38 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 24m 34s ago.
01:41:43 <mux> dons: hello!
01:45:34 <Baughn> @undo do { bar <- string "foo"; whitespace; return bar }
01:45:35 <lambdabot> string "foo" >>= \ bar -> whitespace >> return bar
01:56:55 <Baughn> Is there some simple way to make a function memoized? Obviously I can't wrap it with a hash-table or anything, so.. hmm..
01:59:13 <wilx> Using unsafePerformIO or something?
02:00:08 <Baughn> Hmm..
02:00:10 <dons> is it pure? then just: let v = f x and share v around
02:00:31 <Baughn> It is pure, but I can't share v
02:00:46 <Baughn> (It's deeply embedded in a parser)
02:01:37 <dons> we'd need more info to debug this.
02:01:59 <Baughn> Right. I'll submit the thing for suggestions (it's not many lines) once I've got it /working/.
02:08:30 <Syzygy-> @karma Syzygy-
02:08:30 <lambdabot> You have a karma of 0
02:08:57 <deadbeef> root@OpenWrt:~# head -3 /proc/cpuinfo
02:08:57 <deadbeef> system type             : Broadcom BCM947XX
02:08:57 <deadbeef> processor               : 0
02:08:58 <deadbeef> cpu model               : BCM3302 V0.8
02:09:05 <deadbeef> wondering if there's a ghc  version for mips
02:10:15 <roconnor> Doesn't GHC automemoize functions?
02:10:16 <mux> can't GHC generate C code?
02:10:30 <mux> dons: hey
02:10:46 * mux is starting to wonder if dons has him on his ignore list :-)
02:12:34 <dons> mux, no no. i'm just trying to get to your code :)
02:13:07 <dons> i've just been working on a bunch of things this week
02:13:10 <mux> dons: actually, I have a question only indirectly related to my code if you don't mind
02:13:17 <mux> no problem, I understand, I was mostly kidding
02:13:25 <dons> sure, ask away.
02:13:52 <mux> I wonder however why having a filter transformation function of "filter ((== "more") . fst)" wouldn't work as expected
02:14:09 <mux> I'd like the more filter to kick in if the figlet plugin outputs too much lines
02:14:17 <mux> this doesn't seem to happen for some reason
02:14:31 <mux> I added debug prints to ensure that getName for the more plugin indeed returns "more"
02:14:59 <dons> more only kicks in in particular output mechanisms. I can't remember which , but maybe if you use ircPrivmsg? and if you return input as a list of lines
02:15:25 <dons> if you return it as a single line with \ns, you don't get @more (I might have this the wrong way around)
02:15:26 <mux> ooooh, damn me, I know seem to remember I only return output as one line
02:15:28 * mux kicks self
02:15:33 <mux> that's something I need to check, thank you!
02:17:11 * mux notes writing plugins for lambdabot is infinitely more interesting than this Perl script he has to write for work that parses Excel spreadsheets (ugh..) to change things in an LDAP directory
02:17:25 <mux> (that is actually an Active Directory server)
02:17:38 <profmakx> ieieiek
02:17:50 <dons> hehe
02:18:47 <mux> talk about pain and suffering
02:19:02 <mux> hmm, I actually seem to return the figlet outputs as a list of lines...
02:27:40 <mux> yes, it's indeed returned as several lines
02:27:46 <mux> there must be some other explanation then
02:27:56 * mux hearts debugStrLn
02:30:18 <dons> right, so looking at the code it seems that if you break it into lines, you _dont_ get @more, if you leave it as a single line (or use unlines), then a single ircPrivMsg applies, which will invoke @more
02:30:30 <dons> looking at the impl of ircPrivMsg
02:31:14 <mux> ooh, so it's the opposite
02:31:22 * mux tries to unlines things to see if it works
02:31:54 <mux> I read badly what you said
02:36:15 <mux> yay, it works now :-)
02:36:18 * mux hearts dons 
02:36:19 <mux> thanks again
02:37:05 <mux> dons: I now have a few changes to send you WRT to the last diff
02:37:39 <vegai> is ghc-6.6 still far away?
02:40:37 <dcoutts__> not very far
02:40:58 <mux> heh, damnit
02:41:13 <mux> it is good to have the more filter working but the limit is slightly too small
02:41:20 <mux> for the figlet plugin
02:41:52 <dons> I'm not sure we should be running figlet in channel anyway. we disabled the @moo plugin for the roughly same reasons
02:42:08 <dons> which means: you could forget about @more, and just assume people are using it either on the lambdaweb interface, or on the command line
02:42:19 <mux> right, I could do that
02:42:34 <mux> it's clearly not really appropriate for a channel since it's spam material
02:43:13 <mux> I couldn't find a better idea to implement as a plugin
02:43:25 <mux> I thought about a cowsay plugin but it would fall in the same category :D
02:43:31 <roconnor> Can I somehow get diff to only diff the *.v files in my given directories?
02:43:32 <mux> do you know cowsay?
02:43:52 <dons> roconnor: diff -ruN --exclude=*.things you don't want ?
02:43:59 <dons> maybe there's a --include?
02:46:02 <roconnor> thanks.
02:59:17 <bartw> SamB : ping
03:07:13 <roconnor> @seen Cale
03:07:14 <lambdabot> Cale is in #haskell and #ghc. I last heard Cale speak 6h 35m 50s ago.
03:07:42 <araujo> morning!
03:11:46 <musasabi> scsibug: did you get HAppS working?
03:17:14 <gour> shapr: have you seen http://etrunko.blogspot.com/2006/09/rhythmbox-is-near.html ?
03:17:17 <lambdabot> Title: (void *): Rhythmbox is near, http://tinyurl.com/za63z
03:18:57 <mux> hmm, nice
03:40:06 <bartw> hi arjanb
03:58:06 <sek> http://haskell.org/tutorial/haskell-98-tutorial.pdf is this a good intermediate/advanced haskell tutorial?
03:58:09 <lambdabot> http://tinyurl.com/hxzd7
03:59:13 <Cale> roconnor: hi
04:04:37 <Cale> sek: depends how much you already know about functional programming
04:04:48 <roconnor> Your MonadRandom sould be part of the standard library.
04:05:00 <Cale> roconnor: yeah, that would be good :)
04:05:10 <roconnor> put a trac on haskell'
04:05:21 <sek> cale id classify myself vaguely intermediate
04:05:30 <roconnor> (I added a function to your module)
04:05:48 <sek> ie, done a uni course on it, used it for a few small projects, and am now working on a big project
04:06:12 <Cale> sek: then it should make sense at least
04:06:47 <sek> ok:) so there's no other text that is much better for the same level?
04:07:02 * SamB wonders why sek wants a tutorial at this point ;-)
04:07:32 <sek> SamB: past couple of days i have announced haskell my favorite language:p
04:07:49 <Cale> roconnor: Can I even do that? I don't think I have trac access on Haskell'
04:07:52 <SamB> I mean, it sounds like you should just be using it to me ;-)
04:08:20 <roconnor> Cale: probably not.
04:08:23 <sek> SamB: i am threatend by the potential that there could be so much more i could be doing, heh
04:08:54 <SamB> go look at libraries then ;-)
04:08:54 * roconnor wonders if sek should read the haskell 98 report.
04:08:56 <Cale> There's always more to know :)
04:09:09 <Cale> You could read the Report, that's true
04:09:27 * roconnor learned about the comparing function this week on #haskell
04:09:35 <SamB> I don't think they *make* advanced tutorials
04:09:37 <Cale> hehe, that's mine too :)
04:09:46 <sek> http://www.haskell.org/onlinereport/ this one?
04:09:48 <lambdabot> Title: The Haskell 98 Language Report
04:09:51 <Cale> yep
04:09:53 <SamB> at least not general ones
04:11:19 <roconnor> sek: You don't have to understand everything the first time you read it, but it make make you familiar with some langauge features that you may not be aware of.
04:11:24 <SamB> sek: hey, what kind of project are you doing anyway?
04:11:34 <SamB> roconnor: or at least make you aware of their existance
04:11:42 <roconnor> right
04:12:02 <SamB> of course, it only works for Haskell 98 features ;-)
04:12:13 <sek> SamB: its this program called ipc, it compiles PEPA models to DNAMca models. its all written in haskell
04:12:41 <sek> i am working on extending it by making it convert PEPA models to stochastic simulation models in Dizzy format
04:12:49 <SamB> neato
04:12:59 <SamB> I dunno what all that means, but it sounds cool ;-)
04:12:59 <sek> and also continuous state space models represented by systems of coupled odes
04:13:06 <sek> heh
04:13:18 <SamB> I'm guessing it has to do with physical simulations?
04:13:26 <sek> yeah
04:13:46 <sek> typical simulations are client-server ones, voting simulations, virus infections etc etc
04:15:25 <sek> PEPA models looks alot like concurrency state models. for example you have 100 clients that do an action request_task at rate x, cooperating with 3 servers that do a a service action at rate...
04:16:32 <sek> anyhow, its a compiler im working on, heh
04:17:14 <roconnor> is tla file-diffs f | patch -R the best way to do revert in tla?
04:18:20 <roconnor> that's crazy
04:20:45 <SamB> tla does seem crazy
04:20:59 <SamB> I tried to submit a patch for that Inform 7 IDE written in Haskell, once...
04:21:14 <SamB> It was not fun.
04:21:28 <SamB> we really gotta do something about that guy being hooked on arch...
04:22:06 <wilx> Isn't there that baz thing that is compatible but with svn like command set?
04:22:22 <SamB> that won't help!
04:22:32 <wilx> Heh, ok :)
04:22:34 <SamB> it is only svn like, isn't it?
04:22:56 <mlh> bzr? it's not svn like
04:23:02 <wilx> I have actually given up on tla, too
04:23:05 <roconnor> SamB: The funny thing is that I got that tla commad from the darcs manual.
04:23:15 <SamB> roconnor: that is funny!
04:23:17 <mlh> it has some common commands.  it's very different under the hood
04:23:53 <SamB> mlh: yes, we know that
04:24:11 <wilx> Huh, I thought it was completely repo-compatible.
04:24:18 <wilx> Two frontends for the same thing.
04:24:38 <vegai> mercurial seems pretty good.
04:25:17 <mlh> wilx: you're thinking of bazaar1; bzr is quite a different thing.  by some of the same time, but different language, different architecture
04:25:30 <mlh> 'by some of the same _team_'
04:25:31 <wilx> Ah.
04:25:59 <mlh> http://bazaar-vcs.org/
04:26:01 <lambdabot> Title: Welcome - Bazaar Version Control
04:26:35 <mlh> mercurial and bzr have a fair bit in common
04:28:55 <foxy_> how do I get around duplicate instance declarations?
04:29:38 <foxy_> @paste
04:29:38 <lambdabot> http://paste.lisp.org/new/haskell
04:29:40 <dcoutts__> don't import the duplicate or don't define your own
04:29:44 <dcoutts__> or make a newtype
04:30:43 <lisppaste2> foxy_ pasted "duplicate instances" at http://paste.lisp.org/display/26434
04:30:57 <SamB> newtypes FTW!
04:31:19 <Cale> foxy: which is it supposed to use?
04:31:47 <Cale> foxy: anything which is both a computation and a function will cause a duplicate instance with that
04:32:25 <SamB> hmm
04:32:40 <foxy_> Cale, I need to be able to distinguish between types of (m a) -> b and a -> b where b can be (m a) or a function like (m a) -> (m a)
04:32:49 <SamB> that is valid Haskell syntax, but somehow I get the impression you are leaving something out?"
04:32:53 <SamB> s/"//
04:33:06 <SamB> also, you don't need the wheres when there isn't anything in them...
04:33:10 <foxy_> should I be using types, not classes?
04:33:12 <Cale> SamB: it's actually not valid H98 :)
04:33:40 <Cale> Maybe you should be using types.
04:33:52 <Cale> What are you writing?
04:34:06 <SamB> Cale: but a parser would parse it wouldn't it?
04:34:35 <foxy_> a categorial grammar based natural languag parser, I'm trying to implement conjunctions, which have to be able to take arguments of differing arities
04:34:42 <SamB> foxy_: you should paste the whole classes ;-)
04:34:54 <Cale> SamB: Depends. In H98, instance heads are supposed to start with a type constructor.
04:35:11 <SamB> Cale: oh, point!
04:35:18 <SamB> however
04:35:42 <SamB> I expect the grammar doesn't reflect this
04:35:49 <lisppaste2> foxy_ annotated #26434 with "the entire file" at http://paste.lisp.org/display/26434#1
04:35:52 <wilx> Hmm, what wiki software does http://bazaar-vcs.org/ use?
04:35:54 <lambdabot> Title: Welcome - Bazaar Version Control
04:36:59 <mlh> moin
04:37:03 <SamB> just that, upon reaching such an instance head, the compiler would complain...
04:37:55 <SamB> @fptools Text.Printf
04:37:55 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
04:38:04 <SamB> foxy_: maybe that would be of interest?
04:38:22 <SamB> @fptools Test.QuickCheck
04:38:23 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
04:38:25 <SamB> or that.
04:38:35 <foxy_> SamB: thanks, looking...
04:38:46 <SamB> both involve things with variable arity
04:38:51 <dons> ?source Test.QuickCheck
04:38:52 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
04:38:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:38:56 <dons> oh right
04:38:56 <SamB> I guess printf would be less useful
04:39:02 <SamB> dons: heh
04:39:03 <dons> not updated yet.
04:39:11 <SamB> oh you changed it?
04:39:18 <dons> yeah, but not rebuilt yet
04:39:30 <ndm> dons: are you going to try doing the Yhc for lambdabot thingy?
04:39:36 <SamB> oh, are you upping the output size for @scheck?
04:39:52 <dons> ndm, at some point, maybe yes.
04:40:08 <dons> SamB: hmm maybe
04:40:33 <ndm> dons: neat, i was wondering if you'd want to do a Dr Haskell thingy as well - its just that requires a working Yhc on the machine (but not actually a working execution thingy, so is a lot safer)
04:41:08 <SamB> @scheck \f z xs -> last (scanr f z xs) == foldr (f :: Bool -> Bool -> Bool) z xs
04:41:09 <lambdabot>   Failed test no. 513. Test values follow.: {True->{True->True;False->True};...
04:41:40 <SamB> shortening the output wouldn't hurt either
04:42:14 <SamB> @check \f z xs -> last (scanr f z xs) == foldr (f :: Bool -> Bool -> Bool) z xs
04:42:15 <lambdabot>  Falsifiable, after 0 tests: <Bool -> Bool -> Bool>, True, [False]
04:42:19 <dons> you want me to both up the output size and shorten it?
04:42:43 <foxy_> SamB, I don't think either of those examples take functions as possible arguments in the (a -> b) case which is why I'm doing this
04:42:58 <SamB> dons: I mean shorten the attempted output, *and* increase the amount of this that you let through to the channel
04:43:30 <SamB> or I could do the former
04:46:54 * mux wonders what plugin to write for lambdabot
04:47:20 <roconnor> @google Computational Archaeolinguistics
04:47:23 <lambdabot> http://www.myspace.com/zessa
04:47:23 <lambdabot> Title: www.myspace.com/zessa
04:47:34 <ndm> mux: Dr Haskell :)
04:47:39 <ndm> mux: or Yhc :)
04:48:06 <mux> I was hoping for something that wouldn't take me too long :-) I'm keen on toying with lambdabot but don't have the time to invest in long projects
04:48:09 <dcoutts__> dons: do you remember where JaffaCake's heiricharcal module naming guide is?
04:48:25 <dcoutts__> it's somewhere on haskell.org/ghc
04:48:35 <dcoutts__> but I can't find it now :-(
04:48:45 <SamB> @google site:haskell.org/ghc heirarchical naming
04:48:46 <lambdabot> No Result Found.
04:48:58 <SamB> @google site:haskell.org/ghc heirarchical guide
04:48:59 <lambdabot> No Result Found.
04:49:07 <SamB> dcoutts: are you sure?
04:49:14 <SamB> @google site:haskell.org/ghc naming
04:49:16 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/libraries/base/Control-Monad.html
04:49:21 <SamB> @google site:haskell.org/ghc naming guide
04:49:23 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/type-extensions.html
04:49:23 <lambdabot> Title: 7.4. Type system extensions
04:49:38 <roconnor> ``hey, all! the most amazing thing has happened -- i'm going on a dig! instead of sitting in my office all day, writing code, reading some comp. archaeolinguisitcs journal, i going to go "on-site".
04:50:30 <SamB> @google heirarchical naming simon
04:50:32 <lambdabot> http://www.haskell.org/pipermail/libraries/2004-March/001939.html
04:50:32 <lambdabot> Title: Heirarchical name space allocation
04:51:10 <SamB> dcoutts: is that of interest?
04:52:23 <dcoutts__> SamB: ah, that looks familiar, thanks!
04:52:32 <SamB> you are welcome ;-)
04:53:09 <dcoutts__> http://www.haskell.org/~simonmar/lib-hierarchy.html
04:53:11 <lambdabot> Title: Haskell Library Hierarchy, http://tinyurl.com/lphbd
04:53:13 <SamB> next time, if you don't find anything in the place you are looking which contains the keywords what you are looking for would have to contain...
04:53:21 <SamB> expand your search space!
04:53:25 <dcoutts__> @arr
04:53:26 <lambdabot> I want me grog!
04:53:39 <mux> lambdabot has no commands to allow admins to op themselves?
04:54:04 <roconnor> ``been putting off work on a tech report version of "A Dependently-Typed Domain-Specific Language for Computational Archaeolinguistics".
04:54:55 <roconnor>  A Dependently-Typed Domain-Specific Language for Computational Archaeolinguistics.
04:54:55 <roconnor> With Tom Murphy VII, Daniel Spoonhower, Christopher J. Casinghino, and Grol Blirtri.
04:54:55 <roconnor> Submitted for publication, April, 2006.
04:55:11 <profmakx> anyone seen the userfriendly for 19.9?
04:55:12 <Syzygy-> Computational archeolinguistics??
04:55:20 <Syzygy-> profmakx: Of course.
04:56:07 <roconnor> computational archaeolinguistics is the study of the languages and machines that people historically used to calculate things, mostly like calendars and economic stuff about crops and trade. sometimes more fancy stuff like codes and encryption.
04:56:53 <xerox> It's a made-up word!
04:59:34 <Cale> heh, there are more results for computational archaeolinguistics than archaeolingustics -computational
05:04:05 <ick> hi i need help returning a random item from a list
05:04:31 <dcoutts__> list !! randomIndex
05:04:46 <dcoutts__> ok, a bit simplistic :-)
05:05:00 <xerox> MonadRandom!
05:05:05 <roconnor> fromList :: (MonadRandom m) => [(a,Rational)] -> m a
05:05:16 <roconnor> just set all the weights to 1.
05:05:26 <dcoutts__> xerox: always with the monads!
05:05:28 <roconnor> zip l [1..]
05:05:31 <Syzygy-> roconnor: Ah.
05:05:43 <xerox> http://haskell.org/haskellwiki/NewMonads/MonadRandom
05:05:46 <lambdabot> Title: NewMonads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
05:06:03 <dcoutts__> sometimes just simple functions with ordinary parameter passing is the simplest
05:06:11 <roconnor> ... I suppose one could make an optimized version for equal weights
05:06:17 <xerox> Pfft! :)
05:06:23 <dcoutts__> ;-)
05:07:07 * dcoutts__ nearly made a writer monad layered on IO using unsafeInterleaveIO
05:07:08 <roconnor> do { i <- getRandomR (0, (length l -1)); return l!!i}
05:07:12 <ick> xerox: actually, i am trying to use the Random monad
05:07:13 <Cale> ick: Without using my library there, just compute the length of the list, generate a random integer from 0 to n-1 and use !!
05:07:26 <Cale> ah, cool
05:07:32 <Cale> then roconnor just described it :)
05:07:40 <dcoutts__> yes, that's the simplest thing to do
05:07:40 <dcoutts__> (and therefore best)
05:07:41 <ick> roconnor: that looks a bit like my approach!
05:07:45 <xerox> That's IO monad.
05:07:54 <ick> xerox: sorry :$
05:07:59 <Cale> do {i <- getRandomR (0, length l - 1); return (l!!i)}
05:08:03 <roconnor> Cale, But I'm using your MonadRandom
05:08:12 <xerox> Be sure to check that |length l > 0|.
05:08:31 <Cale> true :)
05:08:49 <xerox> Then complain of the complexity of the code, and use MonadRandom!
05:09:33 <roconnor> do { when (null l) (fail "empty list error"); i <- getRandomR (0, length l - 1); return (l!!i)}
05:10:14 <xerox> (fail "Can't get a random element out of an empty list" ?)
05:10:20 <roconnor> sure
05:10:43 <roconnor> > fail "Can't get a random element out of an empty list"
05:10:44 <lambdabot>  add an instance declaration for (Show (m a))
05:10:45 <xerox> (Or even return a default choice)
05:11:50 <dcoutts__> @type \g l -> let (i, g') = Random.randomR (0, length l - 1) g in l !! i
05:11:52 <lambdabot> forall g a. (RandomGen g) => g -> [a] -> a
05:12:20 <roconnor> @type \g l -> let (i, g') = Random.randomR (0, length l - 1) g in (l !! i,g')
05:12:21 <lambdabot> forall g a. (RandomGen g) => g -> [a] -> (a, g)
05:12:21 <dons> dcoutts__: its on the 'libraries and tools' page at the bottom
05:12:29 <dcoutts__> dons: ta
05:12:38 <roconnor> @type \l g -> let (i, g') = Random.randomR (0, length l - 1) g in (l !! i,g')
05:12:39 <lambdabot> forall g a. (RandomGen g) => [a] -> g -> (a, g)
05:13:03 <roconnor> @type \l -> getStdRandom (\g -> let (i, g') = Random.randomR (0, length l - 1) g in (l !! i,g'))
05:13:04 <lambdabot> forall a. [a] -> IO a
05:13:26 <dcoutts__> dons: though that's missing JaffaCake's current version, we should link that in
05:15:03 <dcoutts__> added
05:21:17 <mux> ?listmodules
05:21:18 <lambdabot> babel base bf check compose dice dict djinn drhylo dummy elite eval fact free fresh ft haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap small spell
05:21:18 <lambdabot> state system tell todo topic type undo unlambda url version vixen where
05:22:18 <xerox> ?version
05:22:18 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
05:22:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:22:44 <mux> this is gettind old
05:22:48 <mux> darcs is at 4p221 :)
05:22:52 <MarcWeber> How can I tell ghci not only to load my main module but also to exectute main and exit? (because that would be faster than compiling to native using ghc in many cases)
05:23:04 <ndm> MarcWeber: runhaskell
05:23:06 <mux> runhaskell
05:23:10 <mux> heh
05:23:12 <mux> jinx!
05:48:09 <zzctb> how do i get epoch time in?
05:48:25 <xerox> @hoogle time
05:48:26 <lambdabot> System.Time :: module
05:48:26 <lambdabot> Time :: module
05:48:26 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
05:48:30 <xerox> ?docs System.Time
05:48:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
05:49:13 <Syzygy-> Can I go from Double to Float somehow? Or for that matter from Float to Double?
05:49:13 <xerox> Hm.
05:49:22 <ndm> @hoogle Double -> Float
05:49:24 <lambdabot> No matches, try a more general search
05:49:34 <Syzygy-> @hoogle Float -> Double
05:49:35 <lambdabot> No matches, try a more general search
05:49:57 <ndm> Syzygy-: realToFrac
05:50:06 <Syzygy-> @hoogle realToFrac
05:50:06 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
05:50:07 <ndm> the web version of Hoogle gets it straight off...
05:50:19 <xerox> Yeah, realToFrac.
05:53:08 <matthew-_> hi. more haskelldb issues I'm afraid. Does anyone know how I invoke an SQL function in a "restrict" clause in haskelldb?
05:53:38 <matthew-_> I want to say "restrict (fieldName .==. now())" where now() is the SQL command/function
05:55:29 <zzctb> do t <- getClockTime; print t gets me the date, but i dont understand how to go on from there to get the epoch time? =(
05:55:59 <ventonegro> why unlike C++ that has libstdc++, ghc links the RTS into every program?
05:58:09 <matthew-_> zzctb: try MissingH.Time
05:58:19 <Cale> ventonegro: I suppose it makes the programs easier to distribute
05:58:36 <ndm> ventonegro: if you want something like that, Yhc doesn't
05:58:46 <ventonegro> yeah, no external dependencies
05:59:08 <ventonegro> maybe if there were more programs written in haskell that would change
05:59:27 <matthew-_> zzctb: yeah, MissingH.Time has clockTimeToEpoch
05:59:42 <ventonegro> ndm, how does it compare to ghc?
05:59:44 <Cale> Yeah, I think that on Mac OS X, there's an option to dynamically link the runtime
05:59:55 <ndm> ventonegro: slower, less stable (for the moment)
06:00:30 <ndm> ventonegro: but some nice stuff that makes it more attractive in other ways, more portable, faster compile times, some good little utilities make use of it etc.
06:00:30 <Cale> and probably fewer supported extensions as well?
06:00:38 <ndm> Cale: very very few
06:00:50 <ventonegro> ndm, so i'll stay with bigger programs for a while :-)
06:01:10 <ndm> ventonegro: would be my advice, although one day Yhc will rule :P
06:01:31 <ventonegro> by the way, have any of you used clean? can speak about it?
06:01:41 <Cale> ndm: How about a browser plugin for running yhc applets? ;)
06:02:01 <ndm> Cale: possible - we could compile with a javascript back end
06:02:20 <ndm> Cale: actually, with my new back end thats actually almost feasible with nearly no code...
06:02:21 <Cale> or java itself
06:02:40 <ndm> we have a Java interpretter for .hbc files, so thats pretty much done
06:02:49 <ventonegro> ndm, is yhc yours? :-)
06:03:07 <Cale> http://www-users.cs.york.ac.uk/~ndm/yhc/
06:03:09 <lambdabot> Title: yhc - York Haskell Compiler
06:03:14 <ventonegro> heh
06:03:33 <ventonegro> i guess this is the IRC with highest collective IQ ever
06:03:46 <ventonegro> the IRC channel
06:04:09 <Syzygy-> You think so?
06:04:19 <ndm> ventonegro: somewhat, more Tom's, i help with various things
06:04:30 <Cale> There's efnet #math, which has a reasonably large number of mathematics professors in it.
06:04:48 <vegai> #mensa? :P
06:04:59 <matthew-_> #republicans?
06:05:29 <vegai> ventonegro: you forget the fact that groups are always dumber than individuals
06:05:32 <Cale> That would be a pessimisation
06:05:52 <psykotic> cale: efnet #math also has plenty of people lowering the average iq :)
06:05:53 <Syzygy-> Mmmmm. EFnet:#math. :)
06:06:15 <Syzygy-> psykotic: It was the highest collective IQ that was asked, not highest average IQ.
06:06:18 <Cale> psykotic: Yeah, but I was considering the sum :)
06:06:20 <psykotic> ah, true.
06:06:39 <psykotic> in that case any of the mega channels could beat it if only because of the normal distribution of iq
06:06:51 <psykotic> adding normal distributed random variables doesn't tell you much useful :)
06:06:52 <ventonegro> vegai, i agree, i probably pull the IQ down
06:06:54 <Cale> how about (product over x of (IQ(x)/100))?
06:07:02 <vegai> ventonegro: same here..
06:07:06 <roconnor> shouldn't the collective IQ be the IQ score that the group would get by taking the test together ... over IRC?
06:07:19 <roconnor> it should be no more than the max of the IQ
06:07:25 <roconnor> probably less ... ;)
06:07:33 <psykotic> you're forgetting about parallellization :)
06:07:37 <Cale> @keal
06:07:38 <lambdabot> evaluating expressions is ALL haskell does?????
06:07:44 <Syzygy-> Hehe
06:07:50 <Cale> @keal
06:07:50 <lambdabot> i use an 8088
06:07:52 <Cale> @keal
06:07:53 <lambdabot> i prove infinity never ends in both directions
06:08:28 <psykotic> just finished watching the presentation on the ICFP contest. i can't believe how much effort went into that.
06:09:25 <psykotic> i think they said they wrote over 100,000 lines of code for the codex?
06:10:14 <matthew-_> has anyone got any ideas about my haskelldb questin?
06:10:22 <ventonegro> interesting idea, the haskell parts create bytecodes run by an ANSI C VM
06:10:55 <roconnor> psykotic: I hope the problem set become a classic, something that all 1st year students play for fun.
06:11:09 <ventonegro> i guess java works the same
06:11:17 <psykotic> indeed. i'm actually story i watched that presentation now, since it had spoilers for everything.
06:11:20 <psykotic> *sorry
06:11:37 <roconnor> psykotic: me too, I didn't realize adventure was so interesting.
06:11:44 <roconnor> I didn't work on the problem.
06:11:44 <psykotic> i didn't have time to participate that weekend but a few hours the following week hacking up a UM and playing around with some of the low hanging fruit problems.
06:11:49 <roconnor> but I'm tempted to now.
06:12:12 <roconnor> even though I see how to solve it.
06:12:21 <psykotic> actually, i'm more interested in some of the meta-problems, like writing a parser for that 2D language :)
06:12:45 <psykotic> i have an idea for how to do it really easily so i think i'll give it a shot tonight
06:12:57 <roconnor> I'm nearing completion of my article on how to write a UM assember.
06:15:52 <Cale> http://www.rafb.net/paste/results/pgnGZP62.html -- aaaaaaaaahhh!
06:16:22 <mux> lol
06:16:42 <psykotic> very succint
06:16:43 <triple_> my eyes! :<
06:16:57 <wilx> Heh, what is that?
06:16:58 <xerox> Oh my.
06:17:19 <psykotic> my first nontrivial program ever was along those lines. it was a text adventure game and i had a separate procedure for every possible game state.
06:17:44 <psykotic> so a function for the state corresponding to "goblin died in room foo, you're carrying the lamp and the sword"
06:17:51 <mux> Cale: omg, is this some generated C++ code or did someone actually write this?!
06:18:15 * psykotic learned the meaning of combinatorial explosion then.
06:18:16 <roconnor> Cale: auto inline
06:18:18 <Cale> mux: I don't know. Someone in #math pasted it, I haven't got an answer on whether it was machine generated yet
06:18:20 * SamB would think that the fact that #haskell is not run by commitee would increase the collective IQ considerably...
06:18:30 * Popz is a Haskell n00b!
06:18:42 <ndm> i've seen similar Ada code, in first year programming assignments
06:18:46 <xerox> Welcome Popz!
06:19:03 <ndm> not quite that long though...
06:19:15 <psykotic> abstraction is overrated
06:19:24 <Popz> hey, just started learnin Haskell @ university :p
06:19:27 <ndm> (104 lines, = 52 *2 - for a deck of cards)
06:20:04 <xerox> Popz: lucky guy....
06:20:05 <SamB> psykotic: haha
06:20:06 <SamB> right!
06:20:14 <SamB> not *that* overrated
06:20:24 <psykotic> who needs anything except ctrl-c and ctrl-v?
06:20:26 <xerox> Overrating is overrated.
06:20:59 * psykotic is at this point reminded of subtext (www.subtextual.org)
06:21:05 <Syzygy-> Cale: Oh, THAT's where that ugly paste came from...
06:21:16 <xerox> Heh, yeah Syzygy-.
06:22:58 <Cale> The REAL wtf is why thedailywtf.com won't load when privoxy is running.
06:24:05 <malcolm> 218 page views of the ICFP programming contest video so far, plus 68 downloads
06:24:31 <psykotic> oh, you were the one who recorded it, right? great job, i really enjoyed watching it.
06:25:14 <malcolm> it was a great presentation from the CMU people - I just had to hold the camera
06:25:20 <SamB> hehe
06:25:27 <SamB> well you did zoom in sometimes
06:25:43 <SamB> I haven't really had a good watch though
06:26:03 <SamB> I think my computer is too slow to play it properly in Flash
06:26:26 <xerox> No, the video itself is a bit sloppy..
06:26:30 <psykotic> malcolm: didn't one of the slides with a graph indicate that they'd written over 100k lines of code for the codex or something obscene like that?
06:26:40 <xerox> (But still great!)
06:26:48 <SamB> or maybe those videos are always crap in Flash
06:26:52 <malcolm> yup, but it was 100k lines of UM
06:26:59 <psykotic> ohh
06:27:07 <sek> > let modNonZero = \x y -> ((x `mod` y)/=0) in [x | x<-[5..], y<-[[2..(x `div` 2)]], (foldr1 (&&) (map (modNonZero x) y)) == True]
06:27:09 <lambdabot>  [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,...
06:27:10 <xerox> $ lpr um.ps
06:27:14 <sek> sweeeeeeet
06:27:21 <SamB> malcolm: ... they weren't expecting to be believed?
06:27:23 <malcolm> the video was encoded at 15 frames per second with 75 frame checkpoints, so it is probably a bit choppy
06:27:24 <sek> that took me 45 minutes to come up with
06:27:26 <psykotic> xerox: haha that was awesome.
06:27:32 <xerox> sek: primes?
06:27:36 <sek> heh, yeah
06:27:38 <SamB> I don't believe they wrote anywhere near that much UM
06:27:49 <psykotic> SamB: they had a compiler, no?
06:27:56 <psykotic> they mentioned UML, core SML + custom extensions
06:28:12 <sek> i had some trouble figuring out i needed double brackets around the [[2....] for y
06:28:13 <SamB> psykotic: I assume. but I don't call it "UM" if it isn't, well, "UM"
06:28:17 <psykotic> i took the 100k count as referring to UML code, not generated code.
06:28:26 <bartw> whups
06:28:40 <SamB> and I don't count it as having been written if it was actually the output of a compiler
06:28:42 <psykotic> (and it appears i was wrong to assume that)
06:28:45 <psykotic> right, of course
06:29:19 <psykotic> that's why i was kind of floored. i wasn't sure how long they'd been working on it.
06:29:20 <malcolm> they did write a whole bunch of different UML compilers in different languages
06:29:34 <psykotic> the postscript one was legendary
06:29:35 <bartw> 100klines, that would be too much work for a contest ?
06:29:51 <malcolm> just to see how it went, in advance of the contestants doing the same thing
06:30:24 <SamB> UML?
06:30:29 <SamB> where does that come in?
06:30:41 <bartw> SamB: did you want the brain script for adventure that i used to bypass the censory engine ?
06:30:48 <SamB> bartw: oh, sure!
06:30:50 <malcolm> universal machine language
06:31:00 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes
06:31:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:31:14 <bartw> http://bwerf.xs4all.nl/bartw/icfp/brain.txt
06:31:17 <xerox> sek: -^
06:31:19 <psykotic> malcolm: are you referring to UM bytecode or what murphy called UML in the video?
06:31:28 <SamB> malcolm: I mean, I don't remember contestants writing UML compilers...
06:31:36 <psykotic> iirc in the video what he referred to as UML he described as "core SML with modifications"
06:31:51 <sek> yikes. i am checking evens, i forgot about that
06:31:53 <bartw> it loops over all the characters and for each character compares it to all possible characters that it could be and uses the world to carry a single equality bit
06:31:55 <malcolm> Oh I cant remember exactly, I just know there was a joke in the name UML
06:32:27 <SamB> oh oh oh
06:32:30 <SamB> that ick stuff!
06:32:49 <bartw> it hardly the best possible solution, but it works
06:33:00 <psykotic> haha
06:33:10 <psykotic> i recently read something about "executable UML". what a horrible thought.
06:33:11 <SamB> bartw: that actually sounds like a pretty good way to do it, if you ask me
06:33:56 <bartw> the case 1000 > c was needed because adventure had the nasty effect of going oom
06:34:03 <sek> haha, xerox yours is soo much faster
06:34:14 <sek> completely trashed mine
06:35:27 <bartw> SamB: thanks, it took me many hours of applying head to keyboard
06:35:50 <SamB> mine tried to do too much
06:35:52 <SamB> I think
06:36:02 <SamB> and that 1000 > c is a good idea ;-)
06:36:09 <dons> ndm hehe. "it has the feel of a program that hasn't had much love recently" -- nicely put!
06:36:12 <xerox> Erastosthenes++ sek :)
06:36:15 <bartw> in the end this did not give me any real advantage
06:36:34 <sek> indeed:)
06:37:24 <roconnor> http://bushong.net/dave/comparisons/primes-up-to.html
06:37:26 <lambdabot> Title: Programming Comparisons: primes-up-to, http://tinyurl.com/z8egv
06:37:52 <roconnor> f n=[x|x<-[2..n],all((0<).mod x).f$x-1]
06:38:10 <xerox> yah.
06:38:22 <roconnor> sub f{grep{(1x$_)!~/^(11+)\1+$/}2..pop}
06:38:32 <xerox> Again that damn regexp...
06:38:37 <roconnor> ;)
06:38:43 <xerox> It's evil!
06:39:15 <dons> that's perl, yeah? been so long i hardly recognise it
06:39:51 <petekaz> I have a use for haskell at work!
06:39:58 <roconnor> (~R∈R∘.×R)/R←1↓ιR
06:40:10 <cjeris> @karma+ APL
06:40:10 <lambdabot> APL's karma raised to 1.
06:40:21 <xerox> petekaz: TaPL fits the missing part of your desk's leg? :P
06:40:28 * xerox ducks
06:40:34 <bartw> using extended characters in code? ieks
06:40:41 <dons> xerox: heh!
06:40:56 <roconnor> bartw: good ol' APL
06:41:04 <cjeris> bartw: hell, APL had its own golf-ball for the IBM teletypes
06:41:11 <dons> ?remember xerox [petekaz] I have a use for haskell at work! [xerox] TaPL fits the missing part of your desk's leg?
06:41:17 <xerox> Yuck!
06:41:18 <petekaz> I need a high-performance simple utility to read a file that contains comma-separated fields, and just changes field 10 to something based on a simple leookup.
06:41:30 <petekaz> I think the lazy fps stuff will be great.
06:41:37 <dons> yeah, that's a good use
06:41:46 <dons> should be simple enough with some take and drop calls
06:42:11 <petekaz> It's a 400mb file.
06:42:16 <dons> small!
06:42:39 <dons> can you process it lazily?
06:42:47 <dons> (i.e. how do you do the lookup?)
06:42:47 <petekaz> sure.
06:43:02 <petekaz> It will be a simple hashmap.
06:43:06 <bartw> wow, i'm scared and impressed at the same time
06:43:21 <petekaz> I wrote it in python.
06:43:30 <dons> petekaz: ok. sounds simple enough
06:43:31 <petekaz> But I want to see how fast haskell would be.
06:43:48 <petekaz> As the developer wanted to write it in C (ug)
06:44:06 <dons> should be possible to whip python -- it has been every time i've tried to do that so far
06:44:10 <mux> writing such a thing in C is not such a bad idea either
06:44:19 <mux> depends on if you're looking for maximum speed or not
06:44:37 <dons> and how many lines of code you want to write.
06:44:43 <dons> 2 or 30?
06:44:45 <dons> :)
06:44:49 <mux> heh
06:45:13 <petekaz> I was basically going to just to a lines on it, then split the line on the commas, but what is the easisst way to change item 10 in a list of 30.  Can I make this a one liner?
06:45:31 <SamB> bartw: wow your code is simple ;-)
06:45:43 <petekaz> This is a file of CDRs (call detail records) I work for a telco.
06:46:34 <dons> petekaz: break
06:46:47 <dons> ?type break -- and then specialies to bytestrings
06:46:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:46:57 <dons> ?type splitAt
06:46:58 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:47:32 <dons> and then join then either with explicit concat/++, or just print  them out directly
06:48:17 <mux> omg, phone call from client "I HAVE A PROBLEM WITH THE SCRIPT IT FAILS AT LINE 17"
06:48:21 <mux> looking at line 17:
06:48:24 <mux> my $ldap = Net::LDAP->new('192.168.0.110') or die($@);
06:48:29 <mux> indeed, his LDAP server was down
06:48:30 * mux grins
06:48:33 <mux> stupid clients
06:48:36 <dons> heh
06:48:39 <xerox> :)
06:48:55 <dons> there's a bug in the internet!
06:49:12 <mux> THE INTARWEB IS BROKEN !!!!1111
06:49:20 <Syzygy-> *gasp*
06:49:26 * xerox faints
06:49:44 <bartw> stupid users, asking for user-friendlyness
06:50:34 <roconnor> spoken like a true technocrat
06:50:42 <Cale> http://img.thedailywtf.com/images/200609/zero.jpg
06:50:45 <lambdabot> http://tinyurl.com/fptg6
06:50:54 <dons> we shouldn't anthroporphise programs : projecting qualities like "friendly" onto opcodes
06:51:06 <mux> Cale: heh yeah, this one killed me yesterday
06:51:08 <sjanssen> @where zlib
06:51:09 <lambdabot> I know nothing about zlib.
06:51:09 <dons> anthropomorphise... some where I lost half that string
06:51:17 <mux> it's from a honk-kong subway station
06:51:17 <Syzygy-> A program written in large friendly opcodes.
06:51:25 <sjanssen> @where+ zlib http://haskell.org/~duncan/zlib
06:51:25 <lambdabot> Done.
06:51:29 <bartw> dons: i guess 'SCIENCE' would be -INF on that friendlyness scale
06:51:30 <dons> happy instructions!
06:51:32 <xerox> C:\DBU>
06:51:38 <dons> bartw: heh
06:51:41 <sjanssen> @where+ bzlib http://haskell.org/~duncan/bzlib
06:51:42 <lambdabot> Done.
06:52:08 <dons> > let science = -(1/0) in science
06:52:10 <lambdabot>  -Infinity
06:52:15 <xerox> Lies.
06:52:21 <roconnor> series of four bytes A,B,C,D should be interpreted with
06:52:21 <roconnor>   'A' as the most magnificent byte, and 'D' as the most shoddy, with
06:52:21 <roconnor>   'B' and 'C' considered lovely and mediocre respectively
06:52:31 <mux> hah
06:52:35 <dons> hhehe
06:52:39 <bartw> gna
06:53:00 <dons> I prefer sublime registers
06:53:02 * bartw remebers spending the first 30 mins getting stuck on endianess infact :p
06:53:54 <dons> but you can't complain about unfriendly UMS ... "ENDIAN" is a great error
06:54:02 <bartw> it is
06:54:15 <mux> little or big endian is too easy
06:54:18 <mux> pdp-endian ftw!
06:54:27 <bartw> thats why i was stuck, if i flipped the endianess it crashed on a vm bug, so i had a working error, or nothing :)
06:54:42 <dons> ?quote Miod
06:54:43 <lambdabot>  [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
06:55:20 <dons> sounds almost like an icfp puzzle
06:55:30 <Popz> 3!
06:57:38 <bartw> [icfp] anyone here that has an explanation online of the black problem ?
06:57:50 <cjeris> is there an awards-report web page for icfp2006 yet?  all i've found are the final contest standings
06:58:20 <dons> not yet. though the winning team used Haskell, C++ and Python this year
06:58:22 <petekaz> Is there a lines and unlines for fps?
06:58:41 <dons> petekaz: yep, in Data.ByteString.*.Char8
06:58:49 <petekaz> thank.
06:59:42 <roconnor> wow, not C.
06:59:51 <vegai> dons: I'd like to confirm this. "Team Smartass" used Haskell, C++ and Python, right?
07:00:12 <petekaz> I thought team smartass was a java team?
07:00:15 <dons> that's what zarvok passed on yes. full analysis will probably go up next week, I think
07:00:42 <petekaz> previous years smartass was java
07:00:51 <Philippa_> that figures, I don't think this was a challenge where one language was enough
07:01:09 <Philippa_> and one good dyntyped language, one good statically typed language and one fast language for the VM makes sense
07:01:16 <dons> yeah. I expect they wrote the um in C++, and then solve the various puzzles in haskell or python
07:01:41 <Philippa_> I wouldn't be surprised if slower solvers got translated from one of the latter two into C++ either
07:03:07 <dons> so yay, haskell has been used by the winning team 3 years running :)
07:03:24 <buggmuzz> what competition is this?
07:04:05 <bartw> dons: my learning haskell has a strong correlation with that fact :)
07:04:07 <dons> which means 4/8 icfp contests have gone to haskell teams, 2/8 to OCaml, and one each to C++ and hmm something else
07:04:31 <cjeris> the first one went to an MIT-local parallel dialect of C called Cilk
07:04:39 <roconnor> I think it shows that multiple langauges are useful for solving problems.
07:04:47 <dons> ah right that's it, cjeris
07:05:30 <cjeris> buggmuzz: the annual ICFP programming contest. http://www.icfpcontest.org/
07:05:33 <lambdabot> Title: ICFP Programming Contest, 2006
07:05:38 <bartw> can't wait for next year
07:05:50 <bartw> if a team needs another member i'm intrested
07:05:57 <buggmuzz> oh i see
07:05:58 <cjeris> yeah, maybe next year i won't remember to read the contest page a week late :|
07:06:06 <dons> now we just need to get the ACM prog comp to open up to all comers.
07:06:21 <mux> we need to have a #haskell team for ICFP(07
07:06:27 <mux> s/(/'/
07:07:17 <dottedmag> dons: ACMs are significantly different.
07:07:19 <buggmuzz> our ACM coach requested haskell as an allowable language but he got denied cause everyone said haskell would make a lot of the problems trivial
07:07:26 <dottedmag> buggmuzz: +1
07:07:33 <dons> :(
07:07:33 <bartw> hehe
07:07:35 <buggmuzz> huh, +1?
07:07:37 <dons> silly silly contest
07:07:44 <dottedmag> buggmuzz: == agree
07:07:56 <sjanssen> I don't think that Haskell would make problems that much easier
07:07:56 <buggmuzz> i see
07:08:02 <dons> blackdog, from this channel, entered the acm contest a couple of years back using a Hsakell->C translator we wrote.
07:08:05 <sjanssen> ACM problems that is
07:08:05 <dottedmag> sjanssen: it would
07:08:09 <roconnor> can't we complie haskell to byte code intepreted by a C program, and hand that in for solutions to the ACM contest?
07:08:17 <sjanssen> dottedmag: agree to disagree I suppose
07:08:28 <roconnor> dons: :)
07:08:28 <dons> he lead for the first couple of hours, till they disqualified him for "breaking the spirit" of the competition
07:08:36 <roconnor> really!
07:08:37 <gour> i need to read some xml data, put them into sqlite database and serialize them back (using some other xml schema) into xml. which haskell package do you recommend?
07:08:49 <roconnor> dons: are you serious?
07:08:50 <sjanssen> dons: if he brought in his own program to do the translation, he was cheating
07:08:53 <psnl> dons: "breaking the spirit" -> "making it too easy"?
07:08:58 <Philippa_> would they have done it if the translator'd been written in C during the contest?
07:09:00 <dons> yeah, it just dumped compiled ghc binaries into a large C array, which could then be submitted and compiled with gcc
07:09:05 <Philippa_> psnl: "taking the piss"
07:09:10 <sjanssen> Philippa_: I don't think so
07:09:11 <dons> (even though you were allowed to use yacc and other preprocessors!)
07:09:12 <roconnor> sjanssen: in the ACM contest, you are allowed to bring your own code IIRC.
07:09:17 <Philippa_> *snigger* yeah, that's taking the piss :-)
07:09:28 <sjanssen> anybody that writes a Haskell compiler in less than 5 hours deserves to win
07:09:37 <sjanssen> roconnor: in paper form, but not electronic
07:09:39 <bartw> ghe: encoding compiled binaries into c sources tasted *bad*
07:09:44 <roconnor> sjanssen: ah, right.
07:10:26 <dons> I think the little adventure did reveal one thing: haskell is way way more productive for ACM-style contests, than whatever they currently use
07:10:37 <psnl> dons: is it done in C?
07:10:42 <roconnor> dons: what about top-coder?
07:10:44 <dons> C, C++ and Java?
07:10:47 <Philippa_> presumably hand-translating would've been okay?
07:11:01 <sjanssen> dons: or blackdog just tends to be smarter than the average person
07:11:19 <dons> or that too.
07:11:22 <psnl> Philippa_: I would be really impressed if you could hand-translate haskell to C
07:11:58 <roconnor> I wonder how big a compressed base64 encoded run time would be?
07:12:06 <roconnor> then you could type that in and write a decompressor in C.
07:12:16 <dons> i've got some C src lying around here. let me find it...
07:12:39 <dons> ah, here's the "compiler" http://www.cse.unsw.edu.au/~dons/code/hsinc/hsinc
07:12:40 <lambdabot> http://tinyurl.com/jjh5r
07:12:48 <cjeris> hm. maybe not haskell, but it's conceivable to do a tiny lisp in a few hours in Java?
07:12:53 <Philippa_> psnl: it's not that hard if you're methodical about it
07:13:01 <Philippa_> especially if you desugar it thoroughly first
07:13:15 <Philippa_> oh, and assuming we're only talking about translating the dynamic meaning
07:13:35 <Philippa_> it's conceivable to do it in C, especially if you don't give a damn about memory usage
07:13:36 <Cale> I think I could hand-translate Haskell to C. Implementing laziness where needed would be the most difficult bit, and that's not so bad.
07:13:50 <dons> and a sample submission, (920k) http://www.cse.unsw.edu.au/~dons/data/run_haskell.c
07:13:52 <lambdabot> http://tinyurl.com/jw9ed
07:14:20 <Philippa_> by default, just implement laziness /everywhere/
07:14:24 <Cale> Of course, the resulting programs would be hard to understand, and 10 to 20 times longer than the Haskell programs :)
07:14:25 <Philippa_> tedious, but you'll manage it
07:14:27 <Philippa_> yup
07:14:40 <Philippa_> actually, give me C++ rather than C and I imagine I'll find it pretty sane
07:14:59 <Philippa_> after all, all your functions're single-parm so you can built a templated "thunk" class and override to fill in the code
07:15:02 <dons> o in the end its fun to have been disqualified for using superior alien super technology
07:15:59 <xerox> dons: that's quite some sed code!
07:16:18 <dons> sed is fun
07:16:25 <xerox> Yeah.
07:16:31 <dons> doesn't everyone write code generators in sed??
07:16:37 <xerox> @slap dons
07:16:38 * lambdabot slaps dons
07:16:53 <bartw> i'm a real outsider for using java and delphi it seems
07:17:10 <bartw> is it fixable ? :)
07:17:17 <dcoutts__> @tell malcolm thanks so much for recording the icfp contest presentation, it was great fun to watch. :-)
07:17:17 <lambdabot> Consider it noted.
07:17:42 <dcoutts__> now I discover what the goggles did! bah
07:17:52 <dons> doh!
07:17:56 <dcoutts__> I wrote a parsec parser for those objects
07:17:56 <dons> us too!
07:18:00 <bartw> dcoutts: i'd pissed about that too
07:18:03 <bartw> i'm
07:18:09 <dcoutts__> heh :-)
07:18:22 <bartw> cost atleast an hour to get the bugs out of the parser alone
07:18:45 <dcoutts__> aye
07:19:01 <dons> should really ponder the meaning of cryptic sentences harder next time
07:19:55 <bartw> my adventure solver was so partial that i still needed to hand write and sort the actual commands, next time i'll take the extra step if i can be bothered
07:20:01 <dons> I think this means we had 5(?) teams of #haskell people in the top 50
07:20:58 <dons> duncan etal, lazy bottoms, roconnor and friends, deaus-ex-machinea and int-e. any others?
07:21:04 <bartw> don't let google hear it or they will sweep and and kidnap you all
07:21:27 <dcoutts__> not too shabby
07:21:28 <gds> lol - I can see the headlines now - "Google Hire IRC channel"
07:21:33 <dons> heh
07:21:37 <Philippa_> where did team roflcopter end up? I know Kirsten's been in here before
07:21:52 <mnislaih> I knew of Lazy bottoms and duncom..whatever. Which were the other three haskell teams?
07:21:56 <dcoutts__> no no, you should be joining haskell-consultantcy.org not google
07:22:11 <bartw> iew, consultancy
07:22:32 <dcoutts__> bartw: got a better company name?
07:22:38 <dons> roflcopter, deaus-ex-machina , and int-e on his own
07:23:31 <dons> oh and team LemonLime- that's bringert et al.
07:23:32 <bartw> dcoutts: something short without dashes would be a start
07:23:51 <dcoutts__> mm
07:24:10 <dcoutts__> dons: someone should do a hardware implementation of UM on a FPGA
07:24:17 <dcoutts__> that'd beat jitting
07:24:37 <dons> I think the jitting ran pretty fast, after the 2 hours of jitting was over
07:24:39 <sjanssen> someone should build a UM out of sand
07:24:46 <bartw> the memory management instructions would be gatecalls or somethign then ?
07:24:47 <dcoutts__> ha ha ha
07:24:48 <dons> lesson: don't use ghc for jitting
07:25:21 <dcoutts__> dons: really? why was it so bad? what jit technique was that?
07:25:40 <roconnor> dons: who was on your team?
07:25:43 <sjanssen> dons: the JIT generated Haskell code?
07:26:18 <dons> right.
07:26:32 <sjanssen> wow . . . seems like C would be a better candidate
07:26:43 <dons> after the contest edwardk hacked up a UM that used hs-plugins+ghc to jit frames from the UM.. just for fun
07:26:50 <roconnor> Philippa_: 34th place.
07:28:23 <dons> roconnor: me, sean seefried (at UNSW), and guys from Peter Thiemann's group at Freiburg (stefanw, matthias neubauer)
07:29:09 <bartw> so now we have to wait 9 months till the next one ? any dates set ?
07:29:09 <dons> i think we may have been the only team that used a haskell VM for the entire contest ?
07:29:41 <sjanssen> dons: I did, but I didn't really participate
07:30:01 <sjanssen> only did the intro tasks
07:30:06 <roconnor> dons: I still want to know what the fastest safe implementation is.
07:30:23 <dons> sjanssen, ah cool! I guess you're looking for a team next year.... ?
07:30:29 <dons> roconnor: you mean, no unsafeAts?
07:30:31 <xerox> um = unsafePerformIO . runCommand -- :P
07:30:55 <sjanssen> dons: I will be.  I would've found somebody this year, but I was gone for half the contest
07:30:56 <dons> and no ptrs -as-int-offset tricks?
07:31:10 <roconnor> dons: no aribrary memory access.
07:31:22 <Philippa_> does provably-safe arbitrary memory access count?
07:31:25 <dons> you only want checked access? boo :P     ;)
07:31:36 <Philippa_> (that is, manually-checked or guarded by maintained invariants)
07:31:39 <roconnor> Philippa_: Probably
07:31:39 <dons> yeah, I think if you've got the proof, go nuts :)
07:31:54 <Philippa_> only I've got an implementation for a 64bit system using lazy arrays, right... :-)
07:32:23 <roconnor> Basically an implemenation that won't let the contest organiser 0wn you.
07:32:23 <Philippa_> or does it have to quit on UM errors as well? (spec said "may")
07:33:02 <bartw> a range check on page and offset is cheap, the cache effects drowned out the cost of those on my delphi um vm
07:37:19 <bartw> doesn't allow you to simply use a pointer-as-int as pagenumber however
07:37:36 <bartw> nothing a layer of indirection won't fix
07:39:24 <kolmodin> icfp contest presentation? where may I find it?
07:39:36 <roconnor> @where icfpcontest-video
07:39:37 <dons> ?where icfpcontest-video
07:39:37 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
07:39:38 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
07:39:47 <kolmodin> thanks!
07:39:51 <dons> ?. tiny-url where icfpcontest-video
07:39:53 <lambdabot> http://tinyurl.com/oshpp
07:39:56 <dons> good bot
07:40:36 <roconnor> ?. tiny-url where icfpcontest-video
07:40:37 <lambdabot> http://tinyurl.com/oshpp
07:41:00 <dons> referentially transparent bot!
07:41:11 <roconnor> impressive
07:41:38 <dons> > 26 ^ 5
07:41:40 <lambdabot>  11881376
07:41:55 <velco> ?. tiny-url where http://tinyurl.com/oshpp
07:41:56 <lambdabot> http://tinyurl.com/hd8hw
07:42:00 <Cale> ahaha
07:42:01 <dons> heh
07:42:14 <Syzygy-> Can you fold tinyurls ? :)
07:42:22 <Cale> that gives an error
07:42:32 <Syzygy-> Say, I want a tinyurl with depth 6? :P
07:42:37 <dons> ?. tinyurl . tinyurl . tinyurl where http://www.google.com
07:42:38 <lambdabot> compose module failed: IRCRaised Parse error: "tinyurl"
07:42:50 <Syzygy-> Awwww.
07:42:53 <dons> ?. tiny-url . tiny-url . tiny-url where http://www.google.com
07:42:56 <lambdabot> http://tinyurl.com/fhd
07:43:06 <dons> ?. tiny-url . tiny-url where http://www.google.com
07:43:08 <lambdabot> http://tinyurl.com/fhc
07:43:14 <ventonegro> i felt tempted to ask lambdabot to eval product [1..1000]
07:43:16 <dons> ?. tiny-url where http://www.google.com
07:43:17 <lambdabot> http://tinyurl.com/1c2
07:43:27 <dons> > product [1..1000]
07:43:29 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
07:43:52 <ventonegro> ah, it's smart to clamp the output
07:44:22 <dons> ?. tiny-url . tiny-url . tiny-url . tiny-url where http://www.google.com
07:44:24 <bartw> is it also limited to a sane subset of 0..127 ?
07:44:25 <lambdabot> http://tinyurl.com/fhe
07:44:36 <dons> fhc -> fhd -> fhe eh?
07:45:15 <dons> > ['\0' ..]
07:45:17 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
07:45:36 * dons sleepifies. night!
07:45:40 <ventonegro> > iterate tiny-url $ where http://www.google.com
07:45:40 <lambdabot>  Parse error
07:45:41 <lambdabot> Title: Google
07:46:11 <ventonegro> > iterate tiny-url http://www.google.com
07:46:13 <lambdabot>  Not in scope: `com'
07:46:13 <lambdabot> Title: Google
07:46:17 <bartw> > ['\128' ..]
07:46:19 <lambdabot>  "\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\144\145\14...
07:46:23 <ventonegro> > iterate tiny-url "http://www.google.com"
07:46:24 <lambdabot>  Not in scope: `url'
07:46:25 <lambdabot> Title: Google
07:46:29 <ventonegro> argh
07:47:51 <gds> ventonegro: I think dons did something like that by putting one of the functions into @state...
07:47:53 <bartw> this is the best expression executing bots i have seen so far
07:48:19 <gds> then composing eval, state and (in your case) tinyurl...
07:48:24 <gds> Oh wait...
07:48:32 <gds> No - the state was just for the second arg wasn't it...
07:48:46 <gds> You probably only need eval, compose and tinyurl...
07:48:48 <gds> Hm.
07:49:08 <ventonegro> gds, wanna give it a try? :-)
07:49:20 <gds> lol :)
07:49:51 <gds> No - I should stop distracting myself and actually do some work ;)
07:50:06 <ventonegro> heheh
07:50:11 <ventonegro> same here
07:52:54 <roconnor> Goochaeologists got 970 points on Black. ... that's strange.
07:53:17 <roconnor> same with Krakow Dragons
08:10:47 * bringert hangs out at pdx
08:10:56 <bringert> anyone awake?
08:11:14 <roconnor> awake
08:16:43 <ndm> awake, but very tired
08:19:43 * bringert too
08:20:00 <bringert> got up at 05.30 to go to the airport
08:20:05 <bartw> its 5 pm here, i better be awake :)
08:20:51 <bringert> *boarding*
08:22:16 <xerox> Have fun bringert :)
08:23:11 <shapr> @yow !
08:23:12 <lambdabot> I want to so HAPPY, the VEINS in my neck STAND OUT!!
08:23:21 <shapr> bringert: Have a good flight!
08:25:17 <ValarQ> hej formarn
08:28:35 <matthew-_> hey, shapr, is there a recomended way of invoking an SQL function from within haskelldb?
08:28:37 <matthew-_> nowQuery =
08:28:37 <matthew-_>     do project (Revisions.created << Expr (ConstExpr (OtherLit "now()")))
08:29:04 <matthew-_> is what I'm using. Just wondering if there's a more "official" way?
08:48:01 <Popz> can haskell be used for web apps like mysql/php?
08:50:37 <vegai> Popz: http://happs.org
08:50:39 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
08:50:54 <vegai> depending on what you mean by "like mysql/php"
08:50:57 <Popz> ty
08:51:10 <dottedmag> vegai: buggy and slow :)
08:52:51 <Popz> btw is anyone here from the university of edinburgh, scotland?
08:54:12 <Popz> is anyone here from scotland?
08:54:44 * dottedmag .oO(the next question would be "is anyone here from Earth?")
08:54:52 <Popz> nope
08:55:04 <Popz> is anyone here, from anywhere?
08:55:34 <roconnor> i am
08:55:52 <Popz> what country?
08:55:55 <Popz> brb
08:55:58 <dottedmag> roconnor: how is it going in Anywhere?
08:56:52 <dmhouse> Anyone know if there's Haskell forum software around anywhere?
08:58:48 <edwinb> Popz|brb: are you in Edinburgh?
09:03:01 <roconnor> dottedmag: not well,  I wrote two proofs today, and they are both wrong.
09:03:59 <Popz> edwinb: yes
09:04:53 <edwinb> I could just have done a /whois, of course ;)
09:06:04 <dmhouse> ?freshname
09:06:05 <lambdabot> Hay
09:06:12 <dmhouse> ?freshname
09:06:13 <lambdabot> Haz
09:06:15 <dmhouse> ?freshname
09:06:16 <lambdabot> Haba
09:06:28 <dmwit> ?help freshname
09:06:29 <lambdabot> freshname. Return a unique Haskell project name.
09:06:55 <shapr> @yow !
09:06:56 <lambdabot> Hmmm ... a PINHEAD, during an EARTHQUAKE, encounters an ALL-MIDGET
09:06:56 <lambdabot> FIDDLE ORCHESTRA ... ha ... ha ...
09:07:06 <musasabi> dottedmag: not buggy and slow most of the time. (please report any bugs you find)
09:07:44 <shapr> matthew-_: bringert is the person to ask.
09:07:51 <shapr> hej ValarQ
09:08:18 <shapr> dmhouse: The comment plugin for Hope would be easily hacked into forum software.
09:08:38 <dmhouse> shapr: I thought I might build one.
09:08:48 <dmhouse> Which would give me an excuse to finally install Hope. :)
09:09:13 <dmhouse> Is xerox's cabal-get working enough for the installation process to be sane?
09:09:15 <shapr> You'd only need to change it so that a top level message would be a comment that's not attached to anything.
09:09:32 <musasabi> HAppS beats PHP consistently in performance the last time  we did performance measurements.
09:09:35 <shapr> Last I heard cabal-get can install everything except Hope itself.
09:09:41 <dmhouse> Cool.
09:11:52 <Tobsan> can somebody please explain to me how random numbers work in haskell?
09:12:14 <wilx> Randomly.
09:12:21 <mauke_> same as in other languages
09:12:27 <Philippa_> mauke: that's misleading
09:12:46 <Tobsan> mauke_ it sure does not
09:12:51 <mauke_> Tobsan: why not?
09:12:52 <Philippa_> Tobsan: from a user's perspective or a theoretical one? You need to get a seed from somewhere to really get "random" or you'll always get the same sequence of numbers
09:12:59 <Philippa_> and that "somewhere" pretty much means IO
09:13:13 <deadbeef> hey dear friends
09:13:16 <deadbeef> one question
09:13:16 <Tobsan> Philippa_ i just want to create a random generator, and then i want to use it
09:13:22 <Tobsan> but ow du i create it?
09:13:23 <deadbeef> i just calculated the complexity of an algorithm
09:13:39 <deadbeef> can O(n*log(n*x)) be written in a more friendly way ?
09:13:40 <mauke_> Tobsan: why don't you use the standard generator?
09:13:57 <Tobsan> mauke_ i'm trying, and that's the problem
09:14:01 <Philippa_> mauke: we're being asked how
09:14:08 <Tobsan> i'm kind of new to haskell, so i dont know how to use it
09:14:09 <integral> If you're in the IO monad, just use randomIO...
09:14:10 <Philippa_> *loads docs*
09:14:10 <int-e> n log(n) + n log(x)
09:14:15 <mauke_> ah, ok
09:14:20 <Philippa_> Tobsan: do you know how IO works? If not, you may be in trouble
09:14:23 <musasabi> Current HAppS does 1450 request/second on average on my test machine :-)
09:14:25 <Philippa_> because random numbers aren't a pure function
09:14:39 <int-e> is the relationship of n and x known?
09:14:39 <Philippa_> (a sequence of 'random' numbers generated from a seed is, sure)
09:14:57 <Tobsan> i just want it to work =)
09:15:07 <edwinb> work to do what though?
09:15:08 <Philippa_> yes, we know you do. Now, do you know how to do IO?
09:15:13 <deadbeef> int-e: i love you
09:15:19 <Philippa_> if so, this is easy
09:15:22 <Philippa_> if not, this gets harder
09:15:24 <Tobsan> i need a function that takes a StdGen as an argument and gives me some random numbers
09:15:26 <int-e> deadbeef: uh, not so fast please.
09:15:28 <int-e> deadbeef:  ;)
09:15:30 <edwinb> I have in the past just used a quick and dirty thing that takes a seed and returns the next number...
09:15:31 <Tobsan> Philippa_ i dont think i know that
09:15:58 <deadbeef> there's no relationship between n and x
09:16:00 <deadbeef> thanks a lot!
09:16:11 <int-e> deadbeef: anyway if x should be bounded by a polynomial in n, then it'd just be O(n log(n))
09:16:26 <deadbeef> yes
09:16:40 <Tobsan> Philippa_ could you tell mne how to create a StdGen?
09:17:01 <lightstep> ?hoogle IO StdGen
09:17:02 <lambdabot> Random.getStdGen :: IO StdGen
09:17:02 <lambdabot> Random.newStdGen :: IO StdGen
09:17:26 <Philippa_> Tobsan: got the docs for System.Random open?
09:17:29 <Philippa_> you'll need those
09:17:40 <Tobsan> Philippa_ yes i have
09:18:01 <mauke_> > getStdRandom random
09:18:05 <lambdabot>  Pervert!
09:18:09 <mauke_> what
09:18:16 <Tobsan> :S lol
09:18:17 <Philippa_> you can use mkStdGen with a seed to get one
09:18:26 <Philippa_> > next (mkStdGen 7)
09:18:30 <lambdabot>  (279420,320112 40692)
09:18:41 <Philippa_> oh wow, there's a show instance for StdGen too
09:18:41 <Tobsan> Philippa_ ok
09:18:55 <Philippa_> the first element there was a random number, the second a new StdGen
09:19:01 <Philippa_> which you use to get the next random number
09:19:13 <Tobsan> ant the third?
09:19:17 <Philippa_> so you can build a function to give you an infinite list of random numbers on top of that using unfold
09:19:23 <Tobsan> ok
09:19:27 <mauke> Tobsan: there wasn't a third element
09:19:27 <Philippa_> isn't a third, it's part of the StdGen
09:19:36 <mauke> > getChar
09:19:37 <lambdabot>  Pervert!
09:19:40 <mauke> ah, ok
09:19:41 <Tobsan> mauke  (279420,320112 40692) i count 3
09:19:51 <bartw> whats is a good haskell environment for debian sarge ?
09:19:51 <mauke> Tobsan: there's only one comma there
09:19:53 <Philippa_> that's because you're counting wrong. Only one comma, that's a pair
09:19:55 <Tobsan> a
09:19:58 <Tobsan> ah
09:20:32 <Philippa_> btw, if you want a seed picked for you you'd need to do IO, that's what getStdGen et al're for. But you don't need to worry about that for now, I guess
09:22:18 <bartw> is ghc6 recent enough ?
09:22:30 <xerox> What is the second number in the version?
09:22:42 <mauke> which ghc6?
09:23:38 <ventonegro> latest is 6.4
09:23:42 <bartw> i don't know
09:23:43 <shapr> Is sarge stable or unstable?
09:23:47 <bartw> stable
09:23:49 <ventonegro> stable
09:24:03 <ventonegro> etch is testing, and sid unstable
09:24:20 <shapr> Unlike the real estate market, the imaginary estate market is growing.
09:24:25 <mauke> bartw: what does ghc --version say?
09:24:41 <bartw> 6.2.2
09:24:59 <shapr> 6.4 is preferred.
09:25:16 <bartw> because of bug fixes ?
09:25:28 <shapr> And new features
09:30:53 <bartw> i'll try this one atleast till i have passed some more tutorials
09:33:39 <shapr> @users
09:33:43 <lambdabot> Maximum users seen in #haskell: 239, currently: 229 (95.8%), active: 44 (19.2%)
09:34:01 <ValarQ> active?
09:34:51 <shapr> last four hourse
09:35:00 <shapr> hours*
09:36:53 <ValarQ> ok
09:36:55 * shapr hacks on Fermat's Last Margin
09:37:18 <shapr> Anyone want to sign up to alpha test FLM?
09:37:40 <Philippa_> sure. What's the tech base for it now, anyway?
09:38:29 <dmhouse> Random question: do people tend to bother specifying their hobby projects? If so, to what kind of level of detail?
09:38:30 <lightstep> shapr, is there a link? google can't find it
09:38:33 <shapr> No real changes, I just want to release what I had before to get feedback and start hacking in more features.
09:39:15 <shapr> dmhouse: I like to use QuickCheck for specifications.
09:39:22 <shapr> lightstep: No link, not since I changed servers.
09:39:44 <dmhouse> shapr: okay, but talking I'm higher-level. Specifying, say, what the features of a program should be.
09:41:03 <xerox> Heh, someone at my university just published a paper on Monads!
09:41:16 <shapr> cool!
09:41:16 <xerox> http://www.dm.unito.it/quadernidipartimento/2006/pdf/q07-06.pdf
09:41:21 <lambdabot> http://tinyurl.com/fyysa
09:41:43 <xerox> It's in english, but I don't understand a single word beside the title.
09:53:45 <deadbeef> http://somafm.com/groovesalad.pls
09:53:49 <deadbeef> i love this track
09:54:51 <musasabi> it seems to be geometry related.
10:04:11 <araujo> hi!
10:14:13 <shapr> I always read LHZ as LegoHertz.
10:14:21 <shapr> Makes me wonder how fast Lego resonates.
10:16:27 <araujo> yay!
10:16:44 * araujo jumps and throws shuriken-sugar-lambdas
10:17:23 <cjeris> part of this complete functional breakfast?
10:18:12 <araujo> yay!
10:18:32 * araujo happy because his professor will let him use Haskell for this semester project
10:18:36 * araujo jumps and boings 
10:19:08 <dolio> Hmm, I never noticed, but stream processing in Scheme looks a lot like it does in Haskell.
10:19:18 <dolio> Only with parentheses instead of .
10:19:23 <araujo> lambda candy for everyone1
10:20:39 <petekaz> Does this code have any glaring newbie mistakes in it: http://paste.kazmier.com/?action=Display&id=1158851114910946000000
10:21:15 <petekaz> I was hoping to see some lightning fast speeds with lazy bytestrings.
10:21:38 <petekaz> But I'm not, my imperative python version is faster.
10:23:49 <Lemmih> petekaz: What does profiling say?
10:24:29 * shapr hugs Lemmih 
10:24:36 <moonlite> if i have a list of type [Type] and want to do a fold like this: "t1 == t2 == t3 ... == tn", can i construct that with just foldr or foldr1?
10:24:37 <dolio> It's possible that mapIndex is being too lazy in the index accumulator and slowing things down.
10:24:42 <petekaz> I should mention what this is for ... I have a CSV file.  Each line has 30 fields.  I need to change field 10 of each line if a key is found in some map, otherwise, leave alone.  It should take stdin, and then write it out to stdout.
10:24:59 <petekaz> Lemmih: don't know how to profile yet
10:25:01 <shapr> dolio: Except that you can't do multidimensional traversal of lazy streams easily in scheme.
10:25:16 <petekaz> Lemmih: I'll google for it.
10:25:50 <dolio> shapr: I hadn't thought it through much, but I'm watching the SICP lectures, and he just put up something like...
10:26:12 <dolio> shapr: (fold cons '() (filter odd (map fib (interval 1 n))))
10:26:33 <dolio> shapr: Which is similar to: fold (:) [] . filter odd . map fib $ [1..n]
10:26:52 <Popz> xerox u c how sum1 @ ur uni just published that paper?
10:27:16 <Cale> dolio: is 'fold' a right fold or a left fold?
10:27:34 <shapr> Popz: Please use real words :-/ Does it really take that much extra time to type the entire thing?
10:28:16 <shapr> Popz: If you're using xchat you can get the shortcut words to automatically expand to the real word.
10:28:43 <shapr> That's also true with emacs but I don't know about irssi or bitchx.
10:28:55 <xerox> Popz: its under unito.it which is the University of Torino :)
10:29:03 <xerox> Gotta dash for a conference! See you later.
10:29:36 <dolio> Cale: Hmm... I think his is foldr. He calls it accumulate, but it doesn't actually use an accumulator.
10:29:58 <Cale> Is it the identity map?
10:30:06 <Cale> foldr (:) [] = id
10:30:17 <dolio> No, accumulate is foldr.
10:30:51 <Cale> I mean is fold (:) [] the identity?
10:30:54 <dolio> I guess he doesn't actually need it in that particular example, but he was trying to show how it's similar to adding things up in a stream.
10:31:16 <dolio> Yeah, I think so.
10:31:20 <Cale> foldl (flip (:)) [] = reverse
10:31:43 <Cale> So I think it's pretty surely a right fold, and could be simplified out
10:31:54 <dolio> Having accumulate be foldl would kill his lazy streams later.
10:31:58 <Cale> yes
10:35:32 <dolio> He wanted to show how similar it was to (accumulate + 0 (map square (filter odd (enum-tree tree)))), though, so getting into a whole discussion about (accumulate cons '()) is identity would probably be counter-productive.
10:35:55 <Lemmih> Greetings shapr (:
10:38:07 <ski_> @hoogle unfoldM
10:38:08 <lambdabot> No matches found
10:38:15 <ski_> bah!
10:39:25 <dolio> petekaz: Do you have any sample data?
10:39:37 <bourbaki> moin
10:40:57 <dolio> Hmm, apparently I don't have fps compiled for profiling.
10:40:57 <Popz> shapr: sorry, i am used to talking in another server where everyone uses shorthand. all i wanted to say is that monads were "made" by my lecturer
10:41:12 <petekaz> dolio: I do but I can't share it.  They are billing records (I work for a telco).
10:41:13 <bourbaki> shapr did you check the mail?
10:41:18 <dolio> Ah, I see.
10:41:50 <petekaz> dolio: re: fps comment, is this why I only see this when profiling: http://paste.kazmier.com/?action=Display&id=1158860254547152000000
10:42:07 <petekaz> dolio: I can't seem to get anything useful other than all the time is being spent in main.
10:42:27 <dolio> Hum...
10:44:30 <petekaz> Oh well, I must be doing something wrong with lazy bytestrings because shouldn't this program be able to take advantage of all the work they've been doing to make fps fast?
10:45:16 <bartw> hello again
10:45:32 <dolio> Does the map only have that one value in it (i'm not too familiar with Data.Map)?
10:45:53 <petekaz> yes for my testing purposes (I'll load it up from a flat file at some point).
10:46:18 <dolio> Okay. What happens if you add a line like this in the where clause of mapIndex:
10:46:26 <petekaz> I'm assuming that 'dict' isn't actually called each time.
10:46:43 <dolio> m f i x = f `seq` i `seq` x `seq` False = undefined
10:46:52 * mux sighs with relief
10:46:58 <mux> it's good to be back home
10:47:35 <dolio> Or, really "i `seq` False", I guess.
10:47:59 <ski_> (mux : channel or physical place ? :)
10:48:14 <petekaz> dolio: what should the full line look like?
10:48:45 <russo> could you guys take a look at this
10:49:00 <russo> i'm trying to get show to work for a datatype that i've created
10:49:04 <dolio> Oh, my bad, I got that wrong at first.
10:49:10 <mux> ski_: well, both :-) I'm back home physically and since there was an electrical break at home and my boxes were off, I could't got back to my bouncer (the ssh key is only on my home box) thus I'm back in the channel too!
10:49:19 <dolio> m f i x | i `seq` False = undefined
10:49:30 <russo> http://rafb.net/paste/results/ydZ9Ar93.html
10:49:36 <mux> bouncer :: ssh + screen + irssi
10:49:41 <russo> i'm trying to get show to work for a datatype i've created
10:50:16 <ski_> mux : aha
10:51:13 <petekaz> dolio: that made it slower.
10:51:16 * mux watches fsck having fun
10:51:18 <dolio> Heh.
10:52:42 <dolio> You put that before or after the others?
10:52:50 <petekaz> you wanted it before right?
10:52:54 <dolio> Right.
10:53:02 <dolio> I'm out of immediate ideas, then. :)
10:53:10 <petekaz> actually, I put it in the middle.
10:53:24 <petekaz> should it go first?
10:53:32 <ski> yes
10:54:39 <petekaz> ok ... it was faster by a second on a test data set.
10:54:52 <dolio> Is that good?
10:55:10 <petekaz> I dunno, I'll run the whole file, and see how it compares to a simple python version.
10:55:35 <petekaz> It's a 300mb file.
10:56:53 <petekaz> the python verion is basically:
10:56:56 <petekaz>     for line in sys.stdin:
10:56:56 <petekaz>         fields = line.split(',', srctg_idx+1)
10:56:56 <petekaz>         fields[srctg_idx] = tgmap.get(fields[srctg_idx], fields[srctg_idx])
10:56:56 <petekaz>         print ",".join(fields),
10:57:26 <petekaz> I was hoping I could make a simple haskell version that was faster.
10:57:43 <petekaz> dolio: on the full data set, still took twice as long as the python version.
10:58:06 <dolio> Hmm. Is the profile any different now?
10:58:08 <petekaz> dolio: oh well, no big deal.
10:58:28 <mux> are you using FPS?
10:58:32 <petekaz> yes.
10:58:43 * mux crawls back under his rock
10:59:06 <petekaz> mux: but I'm a newbie so its possible that I'm doing something dum.
10:59:10 <petekaz> dumb even.
10:59:35 <petekaz> dolio: still 90% in main, 10 in my mapindex.
10:59:47 <mux> I'd be interested in looking at it, if you could give me the URL, but I'm far from being an experienced haskell hacker
11:00:06 <dolio> Well, then, my change didn't do much.
11:00:11 <petekaz> http://paste.kazmier.com/?action=List
11:00:20 <mux> thanks
11:00:24 <petekaz> mux: third from the top is my program.
11:00:31 <petekaz> 2nd from top is my profile results
11:00:53 <petekaz> 1st from top is a python full blown version (but the 4 key lines do all of the lifting)
11:00:54 <mux> oh, dons and ndm have had a go at it already?
11:01:07 <petekaz> no ... that is an old post.
11:01:12 <petekaz> 20 days ago.
11:01:34 <petekaz> I will post to cafe this weekend for a wider audience.
11:01:39 <mux> mmm
11:02:07 <petekaz> I'm using 6.5.20060920
11:04:16 <dolio> It could be the map that's the problem, too, and not fps.
11:04:27 <mux> maybe if you could split main into several functions instead of using "where" would gave us more data to chew on in the profile
11:04:34 <dolio> On the full version, at least.
11:04:42 <petekaz> ok.
11:06:19 <petekaz> http://paste.kazmier.com/?action=Display&id=1158861947573771000000
11:06:43 <mux> interesting
11:07:18 <petekaz> I'm happy, it seems my mapIndex is not too blame :-)
11:08:08 * mux nods
11:08:39 <dolio> It can be difficult to tell sometimes, though.
11:09:06 <dolio> I had a program that was too lazy in such an accumulator, and profiling didn't show much time spent in it...
11:09:18 <petekaz> dolio: its definitely better with your one-line addition.
11:09:32 <petekaz> (that is what the most recent profiling time was showing)
11:09:55 <petekaz> dolio: I see.
11:09:58 <dolio> But what it did was build a bunch of thunks, and then pass it up higher, where the thunks had to be reduced, so all the time was spent in enclosing functions, even though the problem was in the accumulating function. :)
11:11:19 <dolio> If you're using late 6.5 or 6.6, you should be able to put a ! somewhere in the definition of m to make i strict without the ugly seq line, but I'm not exactly sure where it goes.
11:11:45 <petekaz> ok .. I'll try that.  I got the snapshot from last night.
11:12:12 <dolio> m f !i ... or something like that.
11:12:19 <mux> mmmm, cute!
11:12:26 <mux> I've always waited `seq` tricks
11:12:33 <mux> err, s/waited/hated/
11:12:41 <petekaz> hmm ... parse error.
11:13:06 <dolio> You might need to use !(i), I'm not sure.
11:13:36 <petekaz> neither worked for me ... I'll google to see if I can find the right syntax.
11:13:41 <dolio> Ah well.
11:13:50 <mux> at least it works this way in type declarations
11:14:03 <mux> maybe you need to pass GHC a specific flag to tell him to enable this extension?
11:14:07 <mux> such as with -farrows
11:14:12 <petekaz> oh ... yeah.
11:14:15 <dolio> Oh, yeah, that could be.
11:14:41 <dolio> http://www.haskell.org/ghc/dist/current/docs/users_guide/sec-bang-patterns.html
11:14:43 <lambdabot> Title: 7.8. Bang patterns, http://tinyurl.com/ov3p4
11:14:46 <dolio> -fbang-patterns
11:14:51 <mux> cool
11:15:15 <petekaz> yeah, that worked.
11:15:55 <russo> hey guys
11:16:00 <russo> i have a quick one
11:16:39 <russo> in an else statement i want something like an if else statement
11:16:45 <russo> anyway i want it to run the function again
11:16:59 <russo> would i say else x && f x-1?
11:17:11 <russo> do you know what i mean
11:17:12 <mux> no, you'd do another if inside the else
11:17:18 <mux> if I understand what you mean correctly
11:17:53 <russo> i mean if the else executes i want the function to execute f y
11:18:13 <mux> sorry, I'm not following you
11:18:16 <irgs> what's the difference between ~ and !?
11:18:39 <mux> irgs: well they are kinda opposite in meaning :-) ~ is used for lazy patterns
11:18:44 <mauke> ~ is bitwise not, ! is logical not, huhu
11:18:54 <mux> russo: maybe you can write some pseudo-code?
11:19:02 <russo> say its if x == something then 1 (and now i want to run f y)
11:19:09 <russo> so would i type &&
11:19:11 <irgs> i thought ~ is used to make a function strict in arguments?
11:19:19 <russo> i mean thats how i twould work i c++ i think :S
11:19:27 <russo> just to execute the following command to
11:19:37 <russo> i dunno i'm asking
11:19:51 <russo> is ~ and? in the sence that it would execute f y also
11:19:56 <mux> russo: you are thinking in terms of sequential operations, which doesn't make sense in Haskell unless you're in a Monad
11:20:03 <mux> I don't really inderstand what you mean
11:20:28 <russo> i'll paste my code it just wont make sense because its an abstract assignment :D
11:20:53 <russo> its only a couple of lines though
11:21:38 <irgs> mux: so what's the difference between f ~x = x and f !x = x ?
11:21:54 <shapr> Popz: No worries about the shorthand. Your lecturer is Moggi? Or do you mean Wadler?
11:22:07 <Popz> Wadler :S
11:22:08 <shapr> Lemmih: y0!
11:22:16 <shapr> bourbaki: Still haven't looked at it, but I'll do it now.
11:22:29 <bourbaki> shapr cool thanks
11:22:41 <russo> http://rafb.net/paste/results/JdRNU918.html
11:22:51 <russo> hmm i'm starting to wonder if this is correct then
11:22:54 <mux> irgs: I'm not sure I'd be able to explain it properly, so I'd rather redirect you to some doc on lazy patterns :-) http://haskell.org/tutorial/patterns.html#sect4.4
11:22:57 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns, http://tinyurl.com/f53ck
11:23:18 <russo> fst works btw
11:23:33 <dolio> > let f ~x = True in f undefined
11:23:34 <lambdabot>  True
11:23:45 <dolio> > let f !x = True in f undefined
11:23:46 <lambdabot>  Not in scope: `f'
11:23:53 <dolio> > let f x = True in f undefined
11:23:54 <lambdabot>  True
11:24:02 <russo> are you guys answering for me
11:24:05 <russo> i'm so confused
11:24:10 <shapr> bourbaki: Oh this is interesting. I think I've seen some papers that relate to this, but I don't think I've seen this specifically.
11:24:19 <shapr> Still, let me search for some references.
11:24:28 <psi> russo: no
11:24:32 <russo> did you guys take a look
11:24:47 <irgs> thanks anyway, mux :)
11:24:47 <bourbaki> shapr cool and uncool :) i still thought the idea was quite unique
11:25:16 <shapr> I don't think it's unique, I think it's the next step after several related papers.
11:25:17 <psi> russo: do you perhaps want to build a list of vals? what you have there doesn't make sense in haskell.
11:25:51 <bourbaki> shahn true especially the arrow stuff
11:25:57 <bourbaki> at least i think
11:25:59 <russo> no i just wanted to display i.e. (K A ( K B ( K D (K A Konez)))) as Alpha Beta Delta Alpha
11:26:07 <bourbaki> or hope :)
11:26:29 <russo> psi do you get where i'm coming from now?
11:26:44 <ski> bourbaki : hm, what is this idea you're speaking of ?
11:27:02 <psi> russo: yes, you want to build a string?
11:27:19 <bourbaki> ski extending arrows to graphs
11:27:32 <russo> basically... but i mean i defined show
11:27:36 <russo> i just want this string to run
11:27:43 <ski> bourbaki : any details ?
11:27:50 <russo> this is for my understanding not that i'm turning this in for a grade :)
11:27:55 <bourbaki> yep ski come on over to teh chan :)
11:28:10 <ski> which one ?
11:28:13 <psi> russo: in order to get the string "Alpha" from an A you must call "show" on it
11:28:30 <russo> yes but it works with fst
11:28:31 <shapr> ski: #ScannedInAvian
11:28:33 <russo> that part works
11:28:40 <russo> what dosnt work is showall
11:29:24 <psi> you must think about the function showall as something that builds something larger. you can't just say, do this, then that, etc.
11:30:41 <russo> well i just need the interpreter to display it correctly
11:30:45 <russo> i know what you mean now
11:30:50 <russo> i don't actually want an output
11:31:04 <russo> i just want the interpreter not to show show errors
11:31:12 <russo> and i've already accomplished that
11:31:17 <psi> russo: so if you want to turn a Lis into "Alpha Beta Delta Alpha", you want a function with the type List -> String
11:31:24 <russo> so if i type A it says "Alpha"
11:31:38 <psi> I see
11:32:30 <russo> psi: i was just wondering how i can have it reapply the function but this time with y if y != Konez
11:32:37 <russo> although i just realized another way to do it
11:32:43 <russo> with != :D
11:32:48 <psi> I think you still want what I said.
11:33:09 <psi> showall doesn't have the appropriate type
11:33:45 <russo> AH
11:33:47 <russo> crap
11:34:03 <russo> no i'm having problems with my if statements
11:34:15 <russo> not with showall
11:34:29 <russo> brb my dog is sitting at the door looking at me like i'm a shitty owner
11:34:41 <russo> need to go walk him
11:34:48 <russo> bbl (15 mins)
11:34:52 <psi> ok
11:44:39 <psi> russo: if don't need exactly what you said, you could tack on "deriving Show" on you Lis definition
11:44:59 <ValarQ> hej herr psi
11:45:19 <psi> hallå där
11:45:28 <shapr> hej!
11:46:01 <psi> tjejper
11:57:11 <russo> psi whats derriving show
11:57:38 <psi> russo: it automatically makes an instance of Show
11:57:42 <Cale> russo: It makes the compiler generate some basic code so that you can apply show to elements of your type and get something sensible
11:58:07 <russo> hmm ok
12:00:45 <russo> http://rafb.net/paste/results/IBqJJv74.html
12:00:56 <russo> psi: do you see what i'm trying to do
12:01:03 <russo> the problem isnt that it can't show it
12:01:20 <russo> ERROR "/opt/local/lib/hugs/packages/hugsbase/Hugs.hs":15 - Syntax error in input (unexpected keyword "if"
12:02:12 <abcde`> russo: on line 15, it sees the "x", then the "if"
12:02:29 <russo> i know
12:02:40 <abcde`> what is the x doing there?
12:02:57 <russo> i want it to give back x as long as y isn't Konez
12:03:37 <abcde`> you know Perl? because perl does backwards-if like that
12:04:01 <psi> russo: what is allVal supposed to do?
12:04:12 <russo> just give back the Vals
12:04:15 <abcde`> if y /= Konez    then x   else        -- is what I think you want
12:04:15 <russo> this is a tree right
12:04:24 <psi> the type is wrong
12:04:31 <russo> it looks like (K A ( K B ( K C (K D (K D Konez)))))
12:04:47 * psi nods
12:05:10 <russo> i just want it to freaking give back x (like fst does) as long as y isn't Konez
12:05:10 <russo> thats it
12:05:22 <russo> Konez is russian for end btw :)
12:06:10 <psi> and if y is konez?
12:06:29 <russo> to stop
12:06:41 <russo> and just give back that last x
12:06:47 <russo> associated with that Y
12:07:01 <russo> i.e. (K D Konez) it would give back D and then stop
12:07:30 <psi> you're saying one thing but I'm sensing something else.
12:07:33 <russo> so (K A ( K B ( K C (K D (K D Konez))))) would be ABCDD
12:08:13 <russo> rather allVal of that Lis would become that
12:08:25 <russo> and don't worry about the strings and how it would come out
12:08:29 <russo> i want to start out small
12:08:37 <russo> i'm just confused about if statements in haskell
12:08:38 <psi> you need to make it a string.
12:08:48 <russo> no!!1 i need the if to work thats it!
12:08:52 <kpreid> russo: you can't not worry about it; what the result is is fundamental
12:09:07 <abcde`> I would use pattern matching to test for Konez
12:09:11 <abcde`> maybe that is just me though
12:09:19 <russo> hmm
12:09:27 <russo> you mean its not running because its getting stuck there
12:09:30 <kpreid> allVal Konez   = ""
12:09:30 <kpreid> allVal (K x y) = show x ++ allVal y
12:09:33 <russo> then why does fst run correctly
12:09:42 <kpreid> russo: no, it is not running because it is nonsensical
12:09:50 <russo> ty ++ was my question
12:09:52 <kpreid> what I just wrote is a definition that will work
12:09:56 <russo> i didnt know the syntax in haskell
12:09:56 <russo> :D
12:10:09 <kpreid> oh
12:10:38 <kpreid> allVal (K x y) = x ++ if y /= Konez then allVal y else ""
12:10:38 <psi> so the question was "how do I concatenate 2 strings"
12:10:39 <kpreid> would work
12:10:54 <kpreid> except it would not work on the empty list
12:11:27 <russo> i see what you mean
12:11:28 <psi> russo: do you understand what ++ is?
12:11:35 <russo> is it not and?
12:11:38 <psi> no
12:11:39 <russo> or && in c++
12:11:48 <psi> not even close :)
12:11:50 <abcde`> that's && still
12:11:51 <russo> damn
12:11:52 <russo> :D
12:12:11 <russo> hmm
12:12:15 <psi> understand that allVal is BUILDING SOMETHING
12:12:24 <psi> it's not doing one thing, then another, then another, etc.
12:12:30 <abcde`> > "My favourite cheese is: " ++ "Edam"
12:12:31 <lambdabot>  "My favourite cheese is: Edam"
12:12:50 <russo> argh ok
12:12:58 <abcde`> I don't like Edam, but that's how you concatenate two strings (or lists)
12:13:12 <psi> is = should be
12:13:32 <abcde`> no way
12:13:42 <russo> is a not equal to b a!=b?
12:13:51 <abcde`> /=
12:13:58 <mauke> > 1 /= 2
12:13:59 <lambdabot>  True
12:14:01 <psi> abcde`: I meant in my comment about allVal
12:14:05 <abcde`> oh
12:14:20 <abcde`> I thought you were getting into cheese wars
12:14:26 <psi> hehe
12:21:10 <bartw> Gouda is the best cheese anyways :p
12:21:19 <bartw> but only because i live there
12:22:13 <cjeris> mmm smoked gouda and dry salami
12:22:31 <bartw> forall a : iew smoked a
12:23:03 * cjeris <3 smoked-almost-anything
12:23:08 <bartw> but the dried salami makes it good again
12:23:56 <shahn> hi
12:24:08 <shahn> i got problems with compiling haskell with ffi
12:24:31 <shahn> i always compiled with : rm *.o ; ghc -fffi -no-hs-main Test.hs simple_client.c -ljack
12:24:31 <russo> ERROR "/opt/local/lib/hugs/packages/hugsbase/Hugs.hs":16 - Syntax error in expression (unexpected `}', possibly due to bad layout)
12:24:35 <russo> what does that mean
12:24:37 <shahn> without any error
12:25:03 <SamB> russo: when did you get it?
12:25:19 <russo> allVal :: Lis -> Val
12:25:19 <russo> allVal (K x y) = if y==Konez then x
12:25:24 <russo> it gets it in the last line
12:25:33 <mauke> russo: where's the else?
12:25:38 <shahn> but with -O2 i get: warning: implicit declaration of function ?getStablePtr?
12:25:46 <SamB> shahn: ah
12:25:47 <russo> oh
12:25:56 <SamB> shahn: thats a C thing
12:26:23 <SamB> if you reference the header file, it will appease the C compiler
12:26:36 <SamB> I forget how you do that though...
12:28:05 <russo> ohh crap! i just realized that i've missunderstood my syntax up until now :D
12:29:49 <shahn> SamB: you mean Test_stub.h ?
12:30:38 <SamB> shahn: hmm
12:30:57 <SamB> did you call that in your C file?
12:31:01 <russo> is there a command to exit an if statement
12:31:06 <russo> like return
12:31:10 <SamB> russo: nope!
12:31:10 <russo> or exit or something
12:31:13 <russo> argh
12:31:50 <shahn> yes, besides "HsFFI.h"
12:32:19 <SamB> shahn: huh
12:32:21 <mauke> russo: there are no if statements
12:32:27 <mauke> russo: in fact, there are no statements
12:32:31 <SamB> you'd think that would be in there!
12:32:33 <shahn> now i tried the option "-#include <file>" but same message
12:33:15 <SamB> shahn: now which file did you get this warning in?
12:33:59 <SamB> oh arg I should have known better than to try loading an RML program while actually at my computer
12:34:01 <shahn> how do you mean "in" ?
12:34:03 <brunoperator> is it just me or is circular programming confusing :)
12:34:18 <pejo> russo, you get "out" by returning something, like you did with that x up there (except it was missing an else).
12:34:35 <roconnor> brunoperator: I find circular programming as confusing as recrusion.
12:34:39 <SamB> shahn: just paste the whole output of the compilation process on the pasteboard?
12:34:41 <SamB> @paste
12:34:41 <lambdabot> http://paste.lisp.org/new/haskell
12:34:48 <SamB> roconnor: heh
12:35:21 <russo> yeah well i forgot how i wrote my dataype my datatype can either be a K Val Lis or Konez and i thought it was K Val and then Lis or Konez at the end
12:35:49 <shahn> how does the pasteboard work?
12:36:06 <mauke> irc + cgi + awesome
12:36:12 <SamB> shahn: go to the site, paste your text in the big box, type your nick in the nick box and a title in the title box
12:36:14 <abcde`> ircgi
12:36:19 <shahn> ok i get it
12:36:25 <shahn> gimme a sec
12:37:39 <lisppaste2> shahn pasted "compilation output" at http://paste.lisp.org/display/26474
12:38:10 <SamB> good job ;-)
12:38:40 <MarcWeber> dcoutts: My idea is working now. (at least sort of). http://rafb.net/paste/results/ZQUoPT11.html You are supposed to write only the stuff from line 123 on
12:38:41 <shahn> hey thanks :)
12:38:57 <pejo> russo, that didn't make sense.
12:39:00 * cygnus laughs at "Ads absolutely not by Google"
12:39:12 <russo> pejo: let me get a bit farther it might get more clear :)
12:39:22 <SamB> whoah that is a lot of output!
12:39:34 * SamB wonders why shahn used -v
12:39:35 <shahn> well, with -v its a lot
12:39:59 <shahn> search for "warning"
12:40:36 <SamB> hmm
12:40:41 <SamB> that may be purely incidental
12:41:11 <SamB> I mean, maybe something got floated out of the library...
12:41:27 <SamB> or maybe a slight compiler bug
12:41:51 <SamB> it shouldn't be a problem though
12:42:05 <yip> are functional programming compilation optimization techniques at the level where they can compete with C, for very short programs that are targeted for very simple processors? i am thinking how practical it would be to develop a pure functional language similar to haskell to be used as a shader language for graphics processors, as a replacement for the popular Cg/GLSL/HLSL
12:42:17 <SamB> yip: huh?
12:42:27 <SamB> very simple processors?
12:42:30 <SamB> oh.
12:43:03 <SamB> I expect a functional language for those could be nice, but I dunno if it would be any easier to optimize
12:43:33 <newsham> http://www.zazzle.com/product/235589401840930475 -- t-shirt, questionably offensive.
12:43:35 <lambdabot> Title: MYSPACE DAUGHTER BJ Front Only t-shirt and apparel from Zazzle.com, http://tinyurl.com/zpw93
12:43:41 <SamB> I mean I don't think any of those languages is especially imperative is it?
12:44:47 <vincenz> yip: I thought they were already functional langs
12:44:56 <shahn> SamB:
12:45:06 <shahn> it shouldn't be a problem?
12:45:18 <SamB> shahn: well doesn't it run still?
12:46:04 <shahn> yeah, you're right.
12:46:29 <shahn> ok
12:46:31 <shahn> thanks
12:46:54 <SamB> if it hadn't, I'd have told you to use -fasm
12:49:04 <yip> vincenz: they are very similar, but they have mutable variables, and they have for loops
12:49:46 <yip> SamB: they are designed to be as similar to c as possible
12:50:40 <SamB> well. I dunno how much you'd win with a functional language. I sorta suspect that it might just look prettier. and then maybe only sometimes.
12:50:58 <sylvan> yip, check out "vertigo"
12:51:20 <sylvan> Haskell embedded language which spits out ps/vs 1.1
12:51:28 <SamB> ps/vs 1.1?
12:51:32 <sylvan> (or some such, don't remember the details)
12:51:32 <SamB> what is ps/vs 1.1?
12:51:37 <sylvan> pixel shader, vertex shader
12:51:39 <sylvan> version 1.1
12:51:42 <SamB> oh
12:51:47 <SamB> ... what is that?
12:52:03 <sylvan> language for describing shading of vertices and pixels on consumer hardware
12:52:07 * SamB would think the name of some standard would need to be prefixed
12:52:08 <sylvan> basically asm language for graphics chips
12:52:28 <SamB> or library
12:52:39 <SamB> such as, oh, DirectX...
12:52:52 <sylvan> right, or OpenGL
12:53:00 <SamB> are they the same thing?
12:53:10 <sylvan> no, two different APIs for communicating with the hardware
12:53:12 <sylvan> competing even
12:53:19 <SamB> I realize that
12:53:44 <sylvan> OpenGL is retarded, but DirectX isn't open, nor cross platform
12:53:44 <SamB> I meant, do DirectX and OpenGL both use the same ps/vs?
12:53:58 <sylvan> yeah I think so..
12:54:08 <shahn> SamB: Sorry, it doesn't really work
12:54:14 <SamB> shahn: oh?
12:54:18 <SamB> tried -fasm?
12:54:19 <sylvan> not sure though.. nobody writes asm anymore though...
12:54:25 <shahn> the c haskell interfacing is somehow not working
12:55:09 <shahn> maybe this isn't important, but i am deleting *.o before every compile to avoid error messages
12:55:23 <sylvan> http://conal.net/Vertigo/
12:55:25 <lambdabot> Title: The Vertigo GPU compiler
12:55:59 <int-e> OpenGL 2.0 was disappointing. they had such neat plans, orthogonalizing the interface and abstracting render targets. in the end it's just 1.5 with some more extensions that took way to long to come out.
12:56:29 <SamB> shouldn't they have called that 1.6?
12:56:33 <yip> sylvan: hm... looks interesting
12:56:39 <int-e> I think so.
12:57:07 <SamB> the trouble with standards is...
12:57:21 <SamB> @spell comittees
12:57:22 <lambdabot> committees committee's committee comity's Comte's
12:57:29 <ventonegro> they called 2.0 because of the programmable shaders
12:57:32 <SamB> um, I'll take the first one
12:58:24 * SamB would like to see MountainGL
12:58:28 <SamB> MesaGL is too flat
13:03:42 <int-e> ventonegro: but as far as I remember, they left all support for rendering to textures out of OpenGL, so you still need to deal with GLX or WGL for that stuff. Which is bad.
13:04:19 <ventonegro> int-e, you can use FBO, no?
13:04:42 <SamB> int-e: that is bad!
13:04:54 <SamB> ventonegro: hmm?
13:05:05 <ventonegro> Frame Buffer Objects
13:05:37 * ventonegro is right now trying to code a primitive scene graph in Haskell
13:05:44 <Limbic_Region> Is there a guide for effectively posting questions to the cvs-ghc dev mailing list?
13:06:05 <SamB> Limbic_Region: cvs-ghc?
13:06:15 <SamB> that sounds wrong somehow...
13:06:28 <Limbic_Region> SamB - I got the address from the dev wiki
13:06:29 <shahn> SamB: -fasm doesn't affect the behavior
13:06:37 <Limbic_Region> and the archive leads me to believe it is the right place
13:06:51 <SamB> shahn: maybe you did something wrong in your C code
13:07:06 <Limbic_Region> I am wondering if perhaps I am just being too impatient
13:07:06 <SamB> why are you trying to call Haskell from C anyway?
13:07:55 <SamB> Limbic_Region: well, I didn't say it *was* wrong
13:07:59 <shahn> SamB: i am doing realtime audio processing with the jack sound server
13:08:06 <SamB> shahn: and?
13:08:23 <Limbic_Region> SamB - I agree that it does sound wrong.  Probably was re-purposed after inception
13:08:24 <SamB> I kind of figured that from the -ljack...
13:08:32 <shahn> well i have to call the jack api in c
13:08:50 <SamB> why?
13:08:55 * SamB is puzzled
13:09:52 <shahn> i have to pass the library a function pointer to the audio processing function
13:10:00 * SamB thinks it is much easier to call C from Haskell
13:10:14 <shahn> and i thought that couldn't be done in Haskell itself
13:10:18 <SamB> it can!
13:10:27 <shahn> yeehaaw!
13:10:40 <Limbic_Region> shahn - perhaps you didn't get the memo, but there isn't anything Haskell can't do
13:10:55 <shahn> ^^
13:11:15 <SamB> shahn: now, what is the signature for this function pointer?
13:11:48 <shahn> int process (jack_nframes_t nframes, void *arg)
13:12:16 <SamB> and void *arg is what?
13:12:22 <shahn> but you have to initialize ports first where the function writes to and reads from
13:12:29 <shahn> nothing
13:12:29 <ventonegro> foreign import "process" Process :: Int -> Ptr () -> Int
13:12:30 <SamB> oh, ports
13:12:36 <ventonegro> ops
13:12:39 <ventonegro> foreign import "process" Process :: Int -> Ptr () -> IO Int
13:13:03 <SamB> ventonegro: that isn't acutally a funciton
13:13:05 <SamB> er, function
13:13:08 <russo> guys can you take a look at this... one sec http://pastebin.ca/178998
13:13:16 <russo> can you guys plz take a look
13:13:21 <SamB> that is the signature of a function shahn wants to pass to a C library
13:13:29 <SamB> I forget how you do that...
13:13:39 <SamB> @google site:haskell.org ffi callback
13:13:41 <lambdabot> http://www.haskell.org/pipermail/cvs-hugs/2003-July/001987.html
13:13:42 <lambdabot> Title: cvs commit: hugs98/tests testScript hugs98/tests/ffi Callback.hs Callback.input  ...
13:13:49 <ventonegro> then it's foreign export :-)
13:14:50 <SamB> ventonegro: we want the one that takes a Haskell function and returns a wrapped version...
13:15:00 <cinema> Does anyone know if the GHC hackathon has been recorded on video ?
13:15:03 <ventonegro> SamB, I see
13:15:19 <russo> did anyone look at my pastebin by cahnce
13:15:32 <int-e> ventonegro: if you can show me where in opengl 2.0 that's defined ...
13:15:49 <ventonegro> int-e, it's an extension :-P
13:16:10 <roconnor> ugh, fmap shouldn't be infix
13:16:23 <int-e> ventonegro: well it should have been part of 2.0 :(
13:16:44 <ventonegro> int-e, agreed
13:17:25 <ventonegro> well, gotta go
13:17:26 <ventonegro> night
13:17:41 <SamB> @google "foreign import dynamic"
13:17:44 <lambdabot> http://www.haskell.org/ghc/docs/5.00/set/sec-entry.html
13:18:59 <shahn> One conceptual question: if i pass the function pointer out, there will be another thread calling the function. Can i tell my Haskell-written process to, well, just wait? (i thought, as haskell is a funcitonal language...)
13:19:23 <bartw> ehmz
13:20:18 <SamB> hmm, why the heck does it take so long to even *read* RML, nevermind parsing it?
13:20:34 <SamB> does it try to get it all into one array or something?
13:21:20 <russo> data Lis = K Val Lis | Konez
13:21:20 <russo> fst :: Lis -> Val
13:21:20 <russo> fst (K x y) = x
13:21:20 <russo> zip :: Lis -> Lis -> Lis
13:21:21 <russo> zip (Konez) v = v
13:21:21 <russo> zip u (Konez) = u
13:21:23 <russo> zip (K x y) v = (K x (zip y v))
13:21:31 <russo> ahh crap fst doesnt do anything for the example
13:21:35 <russo> oh well
13:21:45 <russo> i meant to edit it before pasting like that ;)
13:22:01 <russo> anyway i'm not surea bout the last line :(
13:22:02 <Lemmih> shahn: What function pointer?
13:22:23 <int-e> @where paste
13:22:23 <lambdabot> http://paste.lisp.org/new/haskell
13:22:27 <shahn> Oh, i think i'm too slow for this...
13:22:41 <russo> sry paste was just down
13:22:44 <russo> i just tried it
13:22:47 <russo> now its back up
13:22:51 <SamB> Lemmih: the one passed to libjack?
13:23:15 <shahn> Lemmih: I am trying to do audio processing
13:23:24 <shahn> using the jack api
13:23:39 <lisppaste2> russo pasted "get the last line to zip until y==Konez" at http://paste.lisp.org/display/26476
13:24:18 <shahn> a jack client has to export a function pointer of the processing function and a special realtime audio thread will call that function
13:24:30 <shahn> and the other thread has to wait
13:24:45 <shahn> well at least if its written in c
13:25:01 <SamB> Haskell too...
13:25:25 <shahn> jaa
13:25:26 <SamB> you could just takeMVar an MVar that will be filled when you are done (or never)
13:25:31 <russo> I'm not gonna ask anymore but could someone please take a look at this http://paste.lisp.org/display/26476 ;)
13:25:57 * SamB wonders what happens when Haskell gets called from a thread GHC did not make
13:28:05 <shahn> SamB: i won't try that now, cause my c - haskell - thing works (without -O2)
13:28:16 <shahn> But thank you for your help
13:28:20 <SamB> how odd!
13:28:57 <shahn> One last question: do you use "hoogle" (the word) as a verb?
13:29:09 <SamB> why not?
13:29:15 <SamB> grep is one!
13:29:19 <SamB> google is one!
13:30:09 <shahn> ok
13:35:00 <shahn> russo: What is your problem?
13:35:10 <shahn> i had a look at your code
13:35:17 <russo> i think the problem is deeper than i thought
13:35:21 <russo> i think theres more to it
13:35:34 <SamB> a common problem ;-)
13:36:07 <shahn> ^^
13:36:18 <russo> i just want it to keep checking if y==Konez and thus recursively making Lises until the last y (which is a Lis is Konez)
13:36:31 <russo> but i think i'm not thinking of it functionally enough :)
13:36:42 <shahn> ^^
13:36:55 <russo> what would you say though shahn
13:37:00 <russo> after having looked at it
13:37:34 <shahn> well this function does concatenate lists, not zip them
13:37:53 <russo> concentrate
13:37:57 <russo> i couldn't think of a name
13:38:07 <russo> its supposed to just put 2 lists together :)
13:38:22 <russo> one at the end of the other
13:38:28 <russo> Konez is russian for end :)
13:38:43 <shahn> that's called concatenating. Hoogle for "++"
13:38:53 <shahn> yeah, i got that
13:39:49 <russo> i should google for ++
13:39:52 <russo> ?
13:39:54 <shahn> when i was small i saw a czech tv series where they said "Konec" at the, guess what, end.
13:40:16 <russo> :D those bloody czechs :D
13:40:24 <shahn> http://haskell.org/hoogle/
13:40:25 <lambdabot> Title: Hoogle
13:40:41 <russo> the funniest thing is my mate asked me how you say woof woof in russian
13:40:55 <russo> and i said gaf gaf cuz thats what it is and he said in czech its haf haf
13:41:00 <russo> lol i still find that funny :D
13:41:11 <shahn> in german its wau wau
13:41:17 <russo> i know german too :)
13:41:24 <russo> kommst du aus deutschland?
13:41:27 <shahn> ja
13:41:33 <shahn> ich sitze hier in Berlin
13:41:36 <russo> geil ich studiere an der TU Berlin
13:41:38 <russo> :D :D :D
13:41:43 <shahn> Ich auch
13:41:46 <shahn> wahnsinn
13:41:49 <russo> echt :D
13:41:50 <russo> geil
13:41:52 <shahn> jo
13:41:56 <russo> wie heisst du
13:42:00 <shahn> Soenke
13:42:06 <shahn> und du?
13:42:06 <russo> ich bin Dmitry
13:42:20 <shahn> studierst du informatik?
13:42:21 <russo> du sollst dich fuer facebook anmelden
13:42:25 <russo> TI :)
13:42:41 <shahn> und lernt ihr da auch haskell?
13:42:44 <shahn> oder opal?
13:42:45 <int-e> uhm ...
13:42:53 <russo> opal aber ich wollte im sommer was gutes machen :D
13:42:56 <int-e> could you take this off channel, please?
13:42:59 <russo> eine richtige sprace
13:43:01 <russo> sprache*
13:43:03 <shahn> sorry
13:43:06 <russo> sry :D
13:43:06 <shahn> yes
13:43:18 <russo> i can't believe we study at the same university
13:43:22 <russo> what year are you?
13:43:26 <russo> or semester rather
13:43:30 <shahn> we just realized we study at the same university
13:43:39 <russo> lol...
13:43:47 <russo> i still can't believe how rediculous that is lol!!!
13:43:48 <shahn> 8
13:44:04 <russo> oh yeah well i'm going into 3 but i didnt really do everything i should of
13:44:12 <russo> hmmm maybe we have some friends in common
13:44:18 <russo> all my friends study info
13:44:24 <shahn> do you have an cs-account?
13:44:32 <russo> russo@cs.tu-berlin.de
13:44:32 <shahn> and icq
13:44:33 <russo> :)
13:44:33 <shahn> ?
13:44:46 <russo> www.djdmitry.com/dmitry/about_me
13:44:48 <russo> i think
13:44:50 <russo> wait let me check
13:45:09 <russo> ah sites down again
13:45:18 <russo> servers been acting stupid
13:46:18 <vincenz> private message?
13:46:22 <shahn> i sent you my icq
13:46:34 * vincenz introduces russo  and shahn to /msg
13:46:47 <russo> :D :D thanks
13:47:49 <zzctb> randCard' = do; s <- getStdRandom (randomR (1,52)); print s = Unresolved top-level overloading; (Random b, Num b). What am I doing wrong? Thanks.
13:48:07 <russo> shahn: hold on i'm new to this irc :D i just got a macbook through apple campus :)
13:48:40 <Cale> zzctb: it needs to know what kind of random number you want to generate, but this is somehow escaping being specified somewhere
13:49:03 <Cale> zzctb: add a type declaration to the 1 there, like  randomR (1::Int, 52)
13:49:23 <Cale> @type getStdRandom
13:49:24 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
13:49:28 <Cale> uh
13:49:35 <Cale> that's not going to work :)
13:49:50 <Cale> @type randomR
13:49:51 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:50:01 <Cale> @type newStdGen
13:50:03 <lambdabot> IO StdGen
13:50:14 <Cale> you use newStdGen to get a generator
13:50:18 <zzctb> Cale: thanks a bunch, that helped.
13:50:23 <Cale> do g <- newStdGen
13:50:38 <Cale>    x <- randomR (1 :: Int, 52)
13:50:44 <Cale>    print x
13:52:16 <monochrom> the flexibility of type classes means sometimes you need type annotations, unlike in utopia or sml
13:52:30 <monochrom> (I am not saying sml is utopia! XD )
13:57:04 <nomeata> If I use more than one module for my program, in several files, I have to put the data type definitions in one separate file, right?
13:57:19 <nomeata> (and then import that from the other files)
13:58:57 <monochrom> not "have to".  in some cases a convenience to.
13:59:20 <nomeata> ok, so what's wrong with this:
13:59:35 <nomeata> module Common (WikiInfo, basenames) where data WikiInfo = WikiInfo { basenames :: [String] }
13:59:56 <monochrom> should be nothing wrong as far as I can see.
14:00:02 <nomeata> in Common.hs. If I then "import Common" in my main file, it says: Not in scope: data constructor `WikiInfo'
14:01:32 <monochrom> "module Common (WikiInfo) ..."  recall there are two "WikiInfo"s.  Which one does Haskell think it refers to?
14:02:35 <nomeata> dunno. I renamed the Type, and tried to export the constructor, but haskell wouldn't let me:
14:02:53 <monochrom> Haskell thinks it refers to the type name, not the constructor.
14:02:56 <nomeata> module Common (WikiInfo, basenames) where data WI = WikiInfo { basenames :: [String] }
14:03:03 <nomeata> gives: ./Common.hs:1:15: Not in scope: type constructor or class `WikiInfo'
14:03:28 <monochrom> "module Common(WI(WikiInfo))" is how you export the constructor.
14:03:38 <nomeata> so I can't export Construktors?
14:03:48 <SamB> module Common (WI (..), basenames) -- maybe?
14:04:01 <monochrom> Back to the original code, "module Common( WikiInfo(WikiInfo), basenames ) ..."
14:04:30 <nomeata> thx, that works
14:04:33 <monochrom> See also section 5.2
14:04:38 <nomeata> didn't know that syntax
14:05:54 <liam123> hey does anyone have some time to spare on someone who met haskell like 2 h ago?
14:06:12 <liam123> i'm like seriously confused
14:06:18 <twanvl> liam123: Ask away!
14:06:24 <SamB> why do you care if we actually have time to spare, as long as we help you?
14:06:31 <liam123> :)
14:07:04 <monochrom> I think it is a normal process to be confused by 2 hrs.  Try to give it another 22.
14:07:23 <nomeata> you know, SamB has written an automatic beginners' questions answer bot written in NewB, which is interpreted by a 30 line haskell program
14:07:32 <liam123> i have this issue with variables.. I have to count operations that haskell does i try to use something like i++ but don\t know how
14:07:35 <nomeata> you know, nomeata is just joking.
14:07:43 * SamB doesn't remember this
14:08:12 <dmwit> SamB: Try ?faq. ;-)
14:08:18 <SamB> @faq
14:08:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:08:22 <SamB> hahaha
14:08:29 <SamB> but I didn't do it, I tell you!
14:08:43 <monochrom> OK, if I can think of a way that can be understood by a person who has just started Haskell 2 hours ago, I'll let you know.
14:08:44 <SamB> I think that is from the dummy module
14:09:18 <dmwit> liam123: Usually, variables don't change value in Haskell.
14:09:25 * SamB is going to suggest that liam123 go play some video games
14:09:34 <monochrom> I can do it with such things as state monads, but I prefer to tell you next week rather than now.
14:09:50 <twanvl> First of all: what are 'operations'?
14:09:59 <dmwit> =P
14:10:06 <SamB> or, just don't worry about counting things and just write a program to calculate something interesting ;-)
14:10:47 <dmwit> SamB: How about calculating how many operations it took? =)
14:10:59 <SamB> that isn't a calculation
14:11:22 <Lemmih> liam123: How about making a list of the operations and then figure out the length of that list?
14:11:29 <dmwit> liam123: Could you tell us a bit more about what you're trying to do?
14:11:32 <SamB> O.o ;-)
14:11:42 <liam123> http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Further_applications
14:11:45 <liam123> basicaly this
14:11:45 <lambdabot> http://tinyurl.com/nudf6
14:12:02 <chessguy> maybe you guys will be willing to take a crack at this formal languages question. i'm not sure where else to ask it. My book makes the statement "...consider the common rule that all variables must be declared before they are referenced. It can be proven that this rule cannot be specified in BNF." ...what would such a proof look like?
14:12:04 <monochrom> I think this leads me to understand why people like imperative programming so much and find it so "natural".  Like, they spend more time getting their home pages to say "you are the Nth visitor" than putting up some worthwhile content.
14:12:57 <SamB> chessguy: BNF doesn't know anything
14:13:06 <SamB> doing that requires an environment
14:13:13 <dmwit> liam123: log?
14:13:15 <SamB> therefore, BNF can't do that...
14:13:27 <chessguy> what do you mean by "know" anything?
14:13:41 <twanvl> liam123: Have you already got a version that doesn't count the operations?
14:13:42 <liam123> log?
14:14:00 <SamB> you cannot pass things around in BNF, correct?
14:14:16 <dmwit> liam123: Even better: convert the exponent to binary first.
14:14:22 <chessguy> yes
14:14:27 <chessguy> correct
14:14:28 <liam123> i can count them if i manually enter the i
14:14:30 <liam123> like power :: Integer -> Integer -> Integer
14:14:30 <liam123> power x n
14:14:31 <dmwit> Then it should be straightforward to calculate the number of squares needed.
14:14:42 <SamB> so, you can't pass around a list of variables in scope...
14:15:02 <chessguy> ok, you're arguing intuitively though
14:15:15 <monochrom> The proof defines a grammar that ensures declaration before use, (this is most conveniently done by allowing yourself a context-sensitive grammar), then proves (maybe by pumping) that the generated language is not context-free.
14:15:26 <Cale> you'd use something like the pumping lemma
14:15:50 <chessguy> aha, that was more what i was looking for
14:15:58 <SamB> the proof seems overly complicated
14:16:08 <SamB> when it is quite obvious that you can't do that...
14:16:31 <chessguy> monochrom, that only proves that that particular grammar is not context-free though
14:16:32 <Cale> SamB: yeah, the formal tools for working with CFLs are annoying
14:16:47 <chessguy> how do you know that CSG couldn't be re-formulated as a CFG
14:17:22 <Cale> I think you wouldn't specify the grammar exactly
14:17:25 <SamB> consider that there is presumably an infinite number of acceptable variable names
14:17:26 <monochrom> pump pump pump
14:17:49 <chessguy> i suppose i'm probably being too rigorous
14:17:51 <Cale> chessguy: the pumping lemma applies to a language, not a grammar
14:17:56 <twanvl> liam123: One simple way of counting is to use (pseudocode):  power :: Integer(base) -> Integer(exponent) -> (Integer(result), Integer(count))
14:18:23 <dcoutts__> MarcWeber: ok, so you make a bunch of fields then a compound record, then attach this record to a container. Then later you can get the value of the record back. So you're automatically building an editor for a record.
14:18:29 <SamB> you can't do any kind of finite-state gymnastics to keep track of what variables have been declared...
14:18:32 <chessguy> Cale, i didn't say anything about the pumping lemma. i was responding to monochrom's idea
14:18:37 <Cale> chessguy: ah
14:18:38 <russo> ok good night all
14:18:42 <russo> thanks to all that helped me
14:18:44 <russo> :)
14:19:33 <chessguy> i was just curious when it mentioned that. i wondered about that exact question last semester, and a proof would be neat to see
14:20:39 <monochrom> Prove the claim for a very simple language of declaration and use, like "DxxUxx" is good, "DxxUy" is wrong, etc.  OK, so how to draw the same conclusion about other languages?  I suppose the answer is "construct a reduction".
14:20:45 <alkoma> hi.  I started using lambdabot and GOA recently and it is very handy for someone learning haskell.  I have a question: how can I add my code, or other library not part of the standard release, so that index, hoogle, type, etc know about them ?
14:20:48 <nomeata> is sequence lazy? I.e., can I do "do runs <- sequence (repeat 3 cmd); err = listToMaybe $ dropWhile (isResultOk) runs; " to try something thrice and get an err of Nothing if it went ok, but stop after the first error and get that in err?
14:21:13 <nomeata> replicate instead of repeat
14:21:18 <Cale> alkoma: download the source and write a module
14:21:23 <monochrom> sequence's laziness depends on >>='s laziness.
14:21:36 <Heffalump> oh, Utrecht is organising next year's ICFP contest
14:22:20 <nomeata> monochrom: ok, so is >>= lazy? :-)
14:22:27 <nomeata> (IO monad)
14:22:38 <monochrom> That depends on the actual monad you use.  IO is fairly eager.
14:23:05 <twanvl> But in your example you talk about Maybe, not IO
14:23:12 <SamB> I guess I just prefer practical languages...
14:23:16 <Cale> in Maybe, it's lazy
14:23:25 <alkoma> Cale: I am not sure I follow, but let me check the src first ...
14:23:26 <monochrom> Example.  "sequence getChar" is very eager.
14:23:55 <SamB> alkoma: er.
14:23:58 <monochrom> err sequence [getChar, getChar, ...]
14:24:27 <SamB> hmm.
14:25:06 <alkoma> @index check
14:25:06 <lambdabot> Control.Concurrent.STM, Test.QuickCheck, Debug.QuickCheck
14:25:13 <alkoma> @index query
14:25:13 <lambdabot> Network.URI
14:25:15 <nomeata> ok, my example does not work. something was eager :-(
14:25:59 <alkoma> SamB: do I need to write a new module for thing like that?  I am using haskelldb and I want to see stuff from there too
14:26:53 <nomeata> But I don't see a resont to evauluate more of "cmd" if one faild to be sucessful
14:26:58 <nomeata> @paste
14:28:21 <lisppaste2> nomeata pasted "To eager" at http://paste.lisp.org/display/26481
14:28:48 <nomeata> Can someone give me a hint, how I make that work right?
14:29:54 <nomeata> it would make such a nice showcase of how great functional programming is :-]
14:30:09 <monochrom> I don't understand.  But if runLatex doesn't throw an exception, it's "successful".
14:30:55 <nomeata> it's unsuccessfull if the return code is not ExitSucess
14:31:19 <nomeata> It happens that on every invocation, "ExitError 1" gets returned
14:31:41 <monochrom> Bottomline.  sequence [a, b, c, d].  If a,b,c don't throw exceptions, d will be run.
14:31:42 <nomeata> So I'd expect Haskell to top running runLatex'es at that point
14:31:51 <nomeata> hmm. Ok
14:32:11 <SamB> hello
14:32:17 <SamB> how did the split look like from your end?
14:32:22 <nomeata> so, sequence is eager in the sens that it will evaulate results it might not need after all
14:32:32 <musasabi> nomeata: look at e.g. runCommand in http://happs.org/HAppS/src/HAppS/Util/Common.hs
14:32:34 <nomeata> about 20 people leaving and comming
14:32:58 <SamB> I should have looked at the count before it ended...
14:33:48 <monochrom> Please don't say "sequence is eager".  You know it's the wrong way to state it.
14:34:10 <int-e> sequence is lazy :)
14:34:10 <nomeata> no, honestly, I don't
14:34:21 <monochrom> IO is eager.
14:34:28 <musasabi> > head $ sequence ["foo","bar","baz"++error "is it eager?"]
14:34:39 <nomeata> lazy would mean for me that the whole execution of the runLatex's is held back until I output something that needs it
14:34:44 <nomeata> like in this case "err"
14:35:02 <nomeata> and then I would expect haskell to runn the first command, see that it is enough to output "err" and stop
14:35:22 <musasabi> nomeata: the strictness is dependant on the monad in question.
14:35:38 <nomeata> ok, so IO is eager.
14:35:59 <nomeata> ah, I guess I have to put the evaluation inside the takeWhile
14:36:22 <musasabi> you can treat IO actions in a lazy fashion.
14:36:39 <nomeata> musasabi: how do I do that in my case?
14:36:56 <musasabi> but inside IO there is strict sequencing (because the lazy semantics would be confusing most of the time)
14:37:00 <monochrom> I suggest writing runLatex to throw an exception, and tex2pdf to catch and examine exceptions.
14:37:28 <nomeata> ok, might be a possibility
14:37:59 <musasabi> nomeata: I don't know very much about your particular case (and was going to bed).
14:38:17 <monochrom> If you were more advanced, I would suggest an unsafeInterleaveIO trick.
14:41:11 <nomeata> sounds unsafe :-)
14:42:03 <lisppaste2> nomeata annotated #26481 with "Better version" at http://paste.lisp.org/display/26481#1
14:42:17 <nomeata> now that's less elegant, but it clearly does what I want
14:44:17 <nomeata> I could probably be shortend by some foldl or scan or something.
14:45:10 <dcoutts__> IO is not strict in the values it computes, it sequences side effects
14:45:39 <dcoutts__> try return undefined in the IO monad
14:46:08 <dcoutts__> return undefined >> print "hello"
14:46:24 <nomeata> ah, I think I get the idea. I thought, printing err would trigger all the required calculations. but since printing err itself is in the IO monad, it runs all the others first.
14:46:43 <glasser> ghc 6.4 doesn't run on intel macs at all, does it?
14:46:56 <lambdabot> http://tinyurl.com/nk8nd
14:46:56 <nomeata> would be nice to tell IO "This command has no side effect, please skip if not needed"
14:47:14 <lambdabot>  "fbb"
14:48:22 <monochrom> That's unsafeInterleaveIO, and besides, it's skip whether there is side effect or not.
14:48:53 <monochrom> do { getChar; putStrLn "bye!" }   try this.
14:49:10 <monochrom> do { unsafeInterleaveIO getChar; putStrLn "bye!" }   then try this.
14:49:47 <monochrom> But you aren't advanced, I shouldn't be promoting this.
14:50:17 <nomeata> ah, nice
14:51:39 <MarcWeber> dcoutts__: Basically yes.. But I'm struggling implementing it for type [a] ;-)
14:52:12 <dcoutts__> because the types are tricky?
14:52:36 <dcoutts__> MarcWeber: have you looked at the other generic forms things that people have done?
14:55:18 <MarcWeber> dcoutts__: Not yet. I had a look at WASH once ago. There is also HToolkit and fudgets?
14:55:43 <dcoutts__> MarcWeber: there's some kind of generic editor/forms thing on top of wxHaskell
14:55:51 <dcoutts__> I've never really investigated it
14:56:46 <vincenz> dcoutts__: concgrats on 12th
14:56:54 <dcoutts__> vincenz: ta
14:56:56 <vincenz> Anyone know a good system to encrypt partitions?
14:57:39 <dcoutts__> MarcWeber: http://autoforms.sourceforge.net/
14:57:42 <lambdabot> Title: AutoForms
14:58:40 <dcoutts__> MarcWeber: also: http://www.sandr.dds.nl/FunctionalForms/index.html
14:58:43 <lambdabot> Title: FunctionalForms, http://tinyurl.com/p98ls
14:59:13 <MarcWeber> dcoutts__: I've tried wxwidgets once using C/C++ long time ago and I didn't like the interface at  that time..
14:59:45 <dcoutts__> MarcWeber: I'd love to see some kind of forms system on top of Gtk2Hs
14:59:59 <dcoutts__> just pointing at ideas you might like to compare with
15:00:29 <dcoutts__> btw, one thing you might like to try to improve on...
15:00:42 <dcoutts__> most automatically layed out forms look ugly
15:00:52 <dcoutts__> just look at the autoforms screenshots
15:01:21 <dcoutts__> perhaps some way to customise the layout would be good
15:01:42 <dcoutts__> eg if your items are named then perhaps they could be bound to named widgets from a glade file
15:01:44 <MarcWeber> dcoutts__: *g* Some kind of themes?
15:01:54 <dcoutts__> then you could design the layout visually in glade
15:02:35 <dcoutts__> so if you don't provide any glade file then it's laied out automagically
15:02:43 <dcoutts__> and if you want you can tweak it
15:03:04 <dcoutts__> even better --- produce the automatic layout as a glade file !
15:03:21 <MarcWeber> dcoutts__: I don't know why but I don't like those tools.. Perhaps because I had  bad experience using .net 1.0... ;)
15:03:21 <dcoutts__> so the user has something to start tweaking
15:03:36 <dcoutts__> there's a new glade-3 btw
15:03:58 <dcoutts__> imho it makes it easier to get started with a nice layout
15:04:09 <dcoutts__> doing layout in code is hard and usually produces ugly results
15:04:37 <MarcWeber> motivation problem? :) But you are right, writing glade xml files would be a way
15:05:03 <vincenz> ouch
15:05:08 <vincenz> the guy from continations on the web
15:05:13 <vincenz> he's totally trashing "the haskell guys"
15:05:44 <Philippa_> what/where?
15:05:52 <shizzy0> ugh, reminds me of writing layouts in Java Swing.  Yuck.
15:06:09 <dcoutts__> MarcWeber: well have fun. I'm off to bed.
15:06:18 <vincenz> Philippa_: let me see where I fished that link
15:06:52 <vincenz> Philippa_: http://download.microsoft.com/download/9/4/1/94138e2a-d9dc-435a-9240-bcd985bf5bd7/Shriram.wmv
15:06:56 <lambdabot> http://tinyurl.com/rh7zz
15:15:27 <yip> dcoutts__: hi
15:16:27 <MarcWeber> yip: 00:05 < dcoutts__> MarcWeber: well have fun. I'm off to bed.
15:16:34 <MarcWeber> I think hes gone
15:16:51 <yip> MarcWeber: doh!
16:11:41 <ihope> So there's not much for interactive Curry thingies for Windows?
16:28:10 <dolio> > mapAccumL (\a b -> (a+1,b)) [1..]
16:28:11 <lambdabot>  add an instance declaration for (Num [a])
16:28:34 <dolio> @type mapAccumL
16:28:35 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:28:46 <dolio> > mapAccumL (\a b -> (a+1,b)) 0 [1..]
16:28:52 <lambdabot> Terminated
16:29:03 <dolio> Oh, right.
16:29:37 <dolio> > snd $ mapAccumL (\a b -> (a+1,b)) 0 [1..]
16:29:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:30:25 <dolio> > snd $ mapAccumL (\a b -> (a+1,a)) 0 [1..]
16:30:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:31:28 <dolio> > L.primes
16:31:28 <lambdabot>  Not in scope: `L.primes'
16:32:49 * xerox grins evilly
16:33:07 <xerox> > fix ((2:) . scanl1 (const ((/2) . ap (+) (2/))))
16:33:09 <lambdabot>  [2.0,2.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.4142...
16:33:17 <xerox> > fix ((2:) . scanl1 (const ((/2) . ap (+) (2/)))) !! 1000
16:33:19 <lambdabot>  1.414213562373095
16:33:22 <xerox> > sqrt 2
16:33:23 <glguy> programming reverse in 2D was actually pretty cool
16:33:24 <lambdabot>  1.4142135623730951
16:33:29 <xerox> Aha.
16:33:35 <glguy> but I think that a ray tracer is out of my scope atm
16:37:00 <dolio> Heh.
16:37:16 <dolio> Someone posted a link to one a couple days ago, I think...
16:37:41 <dolio> Yeah, I have it here, but I don't know what the link was.
16:37:45 <dolio> It's several pages long.
16:43:08 <dolio> I've been playing around seeing if I can make a stream-processing rad sieve that's anywhere near as fast as the imperative one I wrote.
16:43:15 <dolio> So far it appears that no, I cannot. :)
16:44:08 <dolio> In fact, the two things I've written so far are slower than mapping a rad function over [1..] which just factors and multiplies. :)
16:46:19 <dons> ?uptime
16:46:20 <lambdabot> uptime: 3d 21h 41m 12s, longest uptime: 3d 21h 41m 12s
16:46:44 <xerox> Hiya dons
16:47:19 <dons> hey
16:47:20 <xerox> Longest uptime... and counting!
16:47:42 <xerox> dons: I was skimming sicp for unknown reasons and I came up with a nice fixed point.
16:47:46 <dolio> petekaz: ping
16:47:48 <xerox> > fix ((2:) . scanl1 (const ((/2) . ap (+) (2/)))) !! 1000
16:47:50 <lambdabot>  1.414213562373095
16:48:35 <dons> mmm nice!
16:48:56 <xerox> :D
16:49:00 <jgrimes> that is pretty sweet... :)
16:49:29 <xerox> I'm now hungry.
16:54:15 <emu> ?type ((.) . (.))
16:54:17 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:54:45 <emu> > ((.) . (.)) not (==) 1 1
16:54:46 <lambdabot>  False
16:56:23 <dolio> dons: Notice anything obviously wrong with this: http://paste.kazmier.com/?action=Display&id=1158851114910946000000
16:56:35 <dons> loooking...
16:56:40 <dolio> We were trying to help petekaz with it earlier, but I don't think we did much for him.
16:56:50 <dolio> Apparently his Python version is faster. :)
16:57:55 <emu> @hoogle fix
16:57:56 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
16:57:57 <lambdabot> Control.Monad.Fix :: module
16:57:57 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
16:58:25 <dons> ah ok. i'll have a look.
16:58:47 <dons> do we havee an input data file somehwere?
16:59:04 <dolio> Unfortunately, it's classified.
16:59:33 <dons> hmm. ok.
16:59:43 <dolio> It's something like a bunch of csv lines.
17:00:02 <dolio> And the map would normally be built from a file as well.
17:00:07 <dons> ok, i might have one of those around.
17:02:26 * SimonRC mutters
17:04:53 <SimonRC> That guy from yesterday (http://tinyurl.com/rh7zz) slags off functional (esp. Haskell) programming (repeatedly, around 30min into the presentation), then just minutes later is demostrating how you can do reactive programming in his brilliant new lang (flapjax).
17:05:15 <SimonRC> He even calls the behaviours behaviours.
17:05:45 <SimonRC> the demos are at around 39min
17:06:45 <Cale> what is this?
17:06:50 <Cale> (sorry, just connected)
17:07:32 <SimonRC> me on http://tinyurl.com/rh7zz
17:09:18 <glguy> slags off?
17:09:35 <dons> dolio: how big was the data file again? 400M?
17:10:10 <xerox> SimonRC: those things are mentioned in `links' presentations by Wadler :)
17:10:16 <SimonRC> glguy: criticizes
17:10:30 <SimonRC> xerox: links? where?
17:10:37 <dolio> dons: Smaller than that, I think.
17:11:03 <dolio> dons: In the single-digits-of-megs, I think.
17:11:12 <xerox> http://groups.inf.ed.ac.uk/links/
17:11:15 <lambdabot> Title: Links
17:11:46 <SimonRC> xerox: sorry, didn't spot that page
17:11:57 <petekaz> dons: 300mb I believe
17:11:59 <dons> dolio: ok, with tweaks i can run through 150M in 13s
17:12:14 <dons> petekaz: what kind of speed where you getting?
17:12:21 <xerox> SimonRC: in the presentations by wadler
17:12:30 <dons> and it processes in ~1500k heap too :)
17:12:54 <petekaz> With my version, it took a minute and 20 secs I believe, where my python version took 40 secs.
17:13:20 <dons> ok. let me post my changes. it may actually be the Map structure you're using. the bytestring speed seems to be rather good
17:13:27 <xerox> SimonRC: the other two are ~20MB, this is 783 KB. http://homepages.inf.ed.ac.uk/wadler/papers/links/links-cambridge.pdf
17:13:30 <lambdabot> http://tinyurl.com/g28aj
17:13:31 <petekaz> I was so intrigued by your wc program and the lazy fps, I was hoping to achieve the same.
17:13:55 <ihope> So why don't we all just abandon HTTP and HTML and use something else?
17:13:56 <petekaz> dons: thanks!
17:14:06 <ihope> Or is that what XHTML 2.0 or whatever's going to be?
17:14:08 <SimonRC> ihope: legacy
17:14:34 <ihope> We care about people with Internet Explorer 2.0?
17:14:38 <dons> petekaz: http://paste.kazmier.com/?action=Colorize
17:15:10 <petekaz> dons: Yeah, that url doesn't work, I have to fix that ...
17:15:13 <dons> so, it seems to run really quite well, here on my laptop. but i don't have the Map structure you're using. I would imagine that is actually the bottleneck.
17:15:32 <petekaz> I mean the real url is http://paste.kazmier.com/?action=Display&id=1158884046813755000000
17:15:34 <dons> http://paste.kazmier.com/?action=Display&id=1158884046813755000000
17:15:36 <dons> :)
17:16:05 <dons> compile your program with profiling,and run it on your data, and you'll soon see if its the Map causing problems
17:16:39 <petekaz> http://paste.kazmier.com/?action=Display&id=1158861947573771000000
17:16:58 <petekaz> It didn't look like it was the problem from that profiling.
17:17:33 <dons> ah ok. that looks ike its the copying 'join' that is the problem
17:17:54 <ihope> How does GHC have IO stored "internally"?
17:18:08 <petekaz> let my run your version to see how fast it is
17:18:16 <dons> if the speed (with -O) is still too slow, try avoiding interfact, and rather than using 'join' and 'unlines' to build the final program, use map print . ... lines =<< getContents
17:18:25 <dons> s/final string/
17:18:44 <dons> i.e. that unlines and join is $expensive on array-based strings
17:19:34 <dons> both unlines and join must do a bunch of array copies
17:19:48 <dons> so you should be able to at least replace 'unlines' with mapM_ putStrln
17:20:37 <petekaz> ok.
17:20:42 <petekaz> what about the join?
17:20:43 <dolio> Heh. "You have back-buttoned too far".
17:21:18 <dons> mmm. 'cycle' is great for generating test data on disk
17:21:24 <lispy> someone at haskell-workshop wanted a 'magical' way to optimize haskell programs....i almost said, "Get your problem added to the great PL shootout and then email the haskell-cafe list explaining that haskell doesn't have an entry yet, then wait 2 weeks" :)
17:21:39 <jgrimes> haha...
17:21:41 <dons> petekaz: if join is also a problem, don't use it, and instead mapM_ print over the 3 components of each line
17:22:17 <lispy> but, i do see that erlang is better at concurency now
17:22:17 <petekaz> dons: ok ... thanks for the input.
17:22:50 <dolio> This presentation is great.
17:23:00 <dolio> "Is that a question?" "Yeah, can you stop shouting?"
17:23:03 <dons> yes, this seems a bit faster, main = mapM_ B.putStrLn . map doline . B.lines =<< B.getContents
17:23:33 <petekaz> I suppose in this case, my experiment was a failure.  The naive python version was 2x as fast and only 4 lines of code (and much easier to read).
17:23:39 <lispy> i have another way to generate test data on disk
17:23:41 <petekaz> dons: I'll give that a try ...
17:24:18 <lispy> echo "blah" > foo1.txt; cat foo1.txt > foo2.txt; cat foo2.txt >> foo1.txt; cat foo1.txt >> foo2.txt; (repeat)
17:24:31 <lispy> foo1 and foo2 will grow exponentially :)
17:24:49 <dons> petekaz: you're compiling with -O ?
17:24:56 <petekaz> -O2
17:25:01 <dons> ok.
17:25:16 <petekaz> It was pointed out that I should make 'i' strict.
17:26:18 <xerox> lispy: echo -n "1" > foo; while $(true); do cat foo > bar; cat bar >> foo; cat foo >> bar; done
17:26:34 <dons> petekaz: yes, that was the first thing i did :)
17:26:45 <SimonRC> Quote: "Fran?  I don't what that is.  It sounds like some kind of functional stuff because it begins with 'f'.  That's probably why it didn't work."
17:26:53 <SimonRC> (approx.)
17:27:10 <lispy> SimonRC: ouch
17:27:21 <lispy> xerox: yes, that's quite nice
17:27:30 <lispy> dd also works if you need binary data
17:27:34 <dons> petekaz: avoiding join altogether, runs through 100M in 9s in my tests:
17:27:35 <dons> main = mapM_ (\s -> mapM_ B.putStr s >> B.putStrLn B.empty)
17:27:35 <dons>      . map doline . B.lines =<< B.getContents
17:27:35 <dons>     where doline    = mapIndex fixup . B.split ','
17:27:48 <dons> (you could clean up that map . map a bit)
17:28:07 <SimonRC> Much better: "You can have a declarative specification about something that is imperative."
17:28:41 <dons> SimonRC: urgh. "It sounds like some kind of functional stuff ..." etc fud
17:28:44 <petekaz> dons: on my box, the whole file takes me 1m18s with interact, and without it, it took 1m4s.
17:29:09 <petekaz> now I'll try no join.
17:29:10 <dons> 1m4s with the changes I made?
17:29:17 <dons> including the strict mapIndex?
17:29:26 <dons> can i ask what ghc you're using?
17:29:38 <dons> (6.6 is a lot better with large numbers of bytestrings)
17:30:02 <glguy> dons did you ever get the UM running on Haskell (with a decent responsiveness)
17:30:12 <dons> yeah sure.
17:30:19 <dons> did the whole competition with a haskell um
17:30:33 <dons> around 4x the speed of the fastest UM.
17:30:39 <dons> its still a hard problem in haskell though
17:30:55 <dolio> Heh, I looked at your code. It has all kinds of magic in it.
17:30:59 <petekaz> dons: 1m4s with the code you pasted to my pastebin, minus interact.
17:30:59 <dons> or python, or perl, or ocaml ...
17:31:13 <dons> petekaz: hmm. ghc 6.4 or 6.6?
17:31:46 <petekaz> 6.5 snapshot from last night.
17:32:12 <lispy> dons: why is it a hard problem in haskell? (I have a hankering to rewrite our traffic simulation software at work in haskell and it seems like a similar problem)
17:32:21 <dons> weird. I would really need to get some understanding of the data you're using, and the Map contents to debug this further , petekaz
17:32:35 <SamB> dons: you should say "around 4x slower"
17:32:37 <dons> lispy: a low level machine? its easy to write in Haskell, but hard to approach ASM
17:32:41 <SamB> not "around 4x the speed"
17:32:52 <petekaz> dons: no join took 48secs, better.
17:33:00 <SamB> if you say "around 4x the speed", it sounds like you mean it takes a fourth as long to do something
17:33:02 <dons> 4x the speed. let C speed = n, haskell speed = 4x n
17:33:13 <dons> no, that would be 1/4x the speed
17:33:17 <dons> ;)
17:33:20 <SamB> speed = something/time
17:33:30 <SamB> noto time/something!
17:33:38 <dons> yeah. speed =~ time. I mean time.
17:33:41 <glguy> 4x the time?
17:33:44 <dons>  /=
17:33:47 <dons> right.
17:33:59 <dons> petekaz: hmm. ok. can you profile that and post it then?
17:34:15 <petekaz> here is the python version:
17:34:18 <petekaz> for line in sys.stdin:
17:34:18 <petekaz>   fields = line.split(',', 3)
17:34:18 <petekaz>   fields[3] = tgmap.get(fields[3], fields[3])
17:34:22 <petekaz>   print ",".join(fields),
17:35:00 <dons> we should add a combinator layer for these kind of operations
17:35:09 <dons> what does tgmap.get do?
17:35:18 <dons> is that indexing the map?
17:35:24 <petekaz> tgmap is the dictionary ...
17:35:30 <lispy> why do you always use fields[3], you don't care about the other elements of fields?
17:35:34 <petekaz> get(key, defaultvalueifkeynothtere)
17:35:49 <petekaz> lispy: 3 is really a parameter in my program.
17:35:55 <dons> ah, and that's a destructive update.
17:35:58 <lispy> petekaz: ah
17:35:59 <dons> fields[3] =  ... -- ?
17:36:11 <petekaz> destructive update.
17:36:24 <petekaz> line.split(',')   does what you think
17:36:42 <dons> and what about print ",".join
17:36:45 <petekaz> with that list, modify field 3 if key in dictionary, otherwise leave alone
17:36:58 <lispy> dons: ",".join == interprse ","
17:37:04 <dons> right. so avoids a concat too
17:37:05 <petekaz> ",".join([1,2,3]  is   "1,2,3"
17:37:16 <dons> oh.
17:37:23 <dons> slilly oO syntax
17:37:25 <lispy> oh, so concat $ interprse ","
17:37:37 <lispy> intersperse*
17:38:09 <dolio> Heh, that's a pythonism.
17:38:11 <dons> petekaz: how big is the Map you build?
17:38:13 <petekaz> dons: the join() method on a string is disputed frequently.
17:38:28 <petekaz> it's small, maybe 10-20 items.
17:38:35 <dons> ah ok.
17:38:43 <SimonRC> I would prefer: interleave :: [a] -> [[a]] -> [a]
17:38:44 <dons> can you profile the current version for me then?
17:38:57 <petekaz> I'm running it now ...
17:39:14 <lispy> ?type intersperse
17:39:16 <lambdabot> forall a. a -> [a] -> [a]
17:39:32 <dons> this is rather intriguing. maybe we should try strict strings, since we're processing line by line anyway. ..
17:39:36 <dons> let me try that
17:39:40 <lispy> SimonRC: how does that work?
17:40:13 <lispy> ?type \x xs -> concat (intersperse x xs)
17:40:15 <lambdabot> forall a. [a] -> [[a]] -> [a]
17:40:20 <lispy> SimonRC: like that?
17:41:22 <SimonRC> lispy: interleave x [] = []; interleave x [y] = [y]; interleave x (y:ys) = y ++ x ++ interleave x ys -- or equivalent that is faster
17:41:53 <SimonRC> interleave ", " $ map show [1..5] = "1, 2, 3, 4, 5"
17:41:55 <lispy> SimonRC: right, i think it's just interleave x xs = concat $ intersperse x xs
17:42:05 <SimonRC> interleave ", " $ map show [] = ""
17:42:08 <SimonRC> interleave ", " $ map show [1] = "1"
17:42:29 <SimonRC> note silghtly irregular case for second parameter being empty
17:42:36 <lispy> > (\x xs -> concat (interperse x xs)) ", " $ map show [1..5]
17:42:37 <lambdabot>  Not in scope: `interperse'
17:42:45 <lispy> > (\x xs -> concat (intersperse x xs)) ", " $ map show [1..5]
17:42:47 <lambdabot>  "1, 2, 3, 4, 5"
17:42:59 <lispy> > (\x xs -> concat (intersperse x xs)) ", " $ map show []
17:43:00 <lambdabot>  Add a type signature
17:43:05 <lispy> > (\x xs -> concat (intersperse x xs)) ", " $ map show [] :: String
17:43:06 <lambdabot>  Add a type signature
17:43:15 <lispy> > ((\x xs -> concat (intersperse x xs)) ", " $ map show []) :: String
17:43:16 <lambdabot>  Add a type signature
17:43:29 <lispy> > ((\x xs -> concat (intersperse x xs)) ", " $ map show ([]::[Int]))
17:43:31 <lambdabot>  ""
17:43:47 <lispy> > ((\x xs -> concat (intersperse x xs)) ", " $ map show ([1]::[Int]))
17:43:49 <lambdabot>  "1"
17:43:56 <lispy> SimonRC: i think it's the same
17:44:07 <lispy> SimonRC: unless i missed something in your specification
17:44:15 <petekaz> dons: http://paste.kazmier.com/?action=Display&id=1158885818658856000000
17:44:46 <petekaz> that was the lazy version.
17:45:07 <SimonRC> lispy: ah, I see, yes
17:45:23 <SimonRC> silly me
17:45:34 <SimonRC> Silly SimonRC goes to bed.
17:45:41 <lispy> heh
17:45:44 <lispy> good night
17:47:54 <dolio> Is this guy actually disparaging functional programming, or is he trying to pull the wool over the audience's eyes?
17:51:42 <int-e> hmm, he eliminates mutable variables (mostly), has closures, continuations ... I don't see the connection to functional programming at all ;)
17:52:29 <dons> petekaz: some small changes, runs just under 9s now on my box, http://paste.kazmier.com/?action=Display&id=1158886300552848000000
17:53:55 <lispy> dolio, int-e: what are you talking about?
17:54:14 <dolio> The video SimonRC posted.
17:54:27 <int-e> http://tinyurl.com/rh7zz I think
17:54:50 <petekaz> dons: testing now ...
17:55:00 <int-e> Oh I'm getting to the meat of it. "Declarative programming: Wrong-headed, evil, failed idea."
17:55:13 <dons> crikey!
17:55:26 <jgrimes> I can't wait to watch it
17:55:30 <dolio> int-e: I think that's just a rhetorical device, though.
17:55:45 <dolio> Because directly after that, he introduces a functional reactive programming language. :)
17:55:54 <dons> does sigfpe hang out here?
17:55:57 <dons> ?seen sigfpe
17:55:58 <lambdabot> I haven't seen sigfpe.
17:56:08 <int-e> dolio: yes, but it's a fun quote out of context.
17:56:09 <lispy> hmm...
17:56:16 <dolio> :)
17:56:31 <lispy> heh, i shouldn't download this from work
17:56:33 <lispy> it's huge :)
17:56:35 <petekaz> dolio: took 1m13s
17:56:41 <petekaz> er .. dons
17:56:49 <ihope> Isn't declarative programming just everything except imperative programms?
17:57:01 <ihope> s/programms/programming.
17:57:09 <int-e> 85 MB, roughly
17:57:12 <dons> imperative programming is just a special case of declartive programs with a RealWorld monad..
17:57:24 <dons> petekaz: heh, ok.
17:57:26 <ihope> What isn't declarative, then?
17:57:57 <SamB> dons: would be!
17:57:59 <ihope> How simple can a programming language get, exactly?
17:58:08 <SamB> can be, in Haskell
17:58:14 <SamB> but in most things it is worse...
17:58:15 <dons> ihope: 1 combinator.
17:58:20 <dons> or maybe 2, for fun: S ad K
17:58:26 <SamB> because they don't have any of the *other* monads to use inside...
17:58:36 <petekaz> dons: well, thanks for your help.  I guess this just proves the point that its always good to have lots of languages in your toolbox.
17:58:43 <ihope> dons: what, with nesting and everything?
17:59:00 <dons> petekaz: yeah. I think in this case they win with the destructive update, and a fast mutable hash. but we do pretty well, I reckon.
17:59:05 <ihope> X(XX)X(X(XXX)X(XXXX(X)X)XX)X?
17:59:16 <petekaz> dons: 2x as slow is well?
17:59:25 <ihope> And X would be an impure combinator?
17:59:28 <dons> I think as soon as you try to scale this problem up to do more complex things - any kind of data structure hacking - haskell would start to win
17:59:56 <xerox> dons: what's the One Combinator?
18:00:13 <petekaz> dons: that's what all the losers say :-)
18:00:16 <dons> petekaz, 2x slower is hmm, surprising, but it seems to run at full speed here. i can't see why it seems to run slower on your box
18:00:41 <dons> I don't understand why it runs in 9s for 100M here, and what 1m10s for 300M on your box.
18:00:46 <petekaz> did you try the python version?
18:00:50 <dons> something's going on that's isn't being reproduced here.
18:00:53 <petekaz> is it 2x as fast on your box?
18:00:55 <dons> ah good idea. let me try that.
18:01:41 <int-e> xerox: look at this: http://ling.ucsd.edu/~barker/Iota/
18:01:55 <petekaz> for those 4 lines to work, you need to have add this line first: tgmap = {'Pete':'Kazmier'}
18:02:00 <dons> petekaz: I don't use python. how do I run it? just stick it in foo.py and run with: python foo.py ?
18:02:03 <dons> ah right
18:02:23 <petekaz> #!/usr/bin/python at top, or python foo.py
18:02:26 <dons> do i need to import sys or something?
18:02:37 <petekaz> yes .. sorry.
18:02:38 <dons>     for line in sys.stdin:
18:02:38 <dons> NameError: name 'sys' is not defined
18:03:20 <petekaz> import sys
18:03:33 <petekaz> let paste the full program for you:
18:03:39 <petekaz> http://paste.kazmier.com/?action=Display&id=1158861356331730000000
18:03:52 <petekaz> er .. let me truncate that for you.
18:03:53 <dons> python seems to use a lot more cpu....
18:04:03 <dons> 20s now and still going...
18:04:18 <dons> 97% cpu 35.299 total
18:04:29 <dons> verus haskell,
18:04:29 <dons> 96% cpu 9.191 total
18:04:45 <dons> which is what i would have guessed the result would look like.
18:04:54 <dons> so now, why is it running slower on your machine?
18:04:58 <petekaz> huh?
18:05:09 <petekaz> weird ... I must be doing something stupid then.
18:05:18 <SamB> but Python is obviously more efficient, since it spends 1% more of the time actually computing ;-P
18:05:31 <dolio> Heh.
18:05:35 <dons> heh
18:05:49 <petekaz> Must be my haskell newbie-ness doing something wrong.
18:06:06 <dolio> Are you still running with profiling?
18:06:16 <dons> maybe it smy data?
18:07:01 <dons> ah, now this might be it. i had a different field separator, and now the haskell version runs in
18:07:04 <dons> 98% cpu 40.319 total
18:07:09 <dons> so my fault :S
18:07:55 <dons> so, ok, I can live with 40s for no destructive updates or mutable hashes. its still surprising, but I guess python is just really optimised for exactly this kind of filtering/string program?
18:16:30 <dolio> Heh. "Stream programming is not new... what do you do when reality strikes back?" "What reality? We have working applications."
18:16:37 * lispy tries out the latest erc
18:16:39 <lispy> i also disabled joins/parts
18:16:43 <lispy> which should be nice for #haskell which gets so many
18:16:48 <xerox> lispy: try Circe!
18:17:16 <lispy> xerox: last time i looked at it it was not ready for general use
18:17:23 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
18:17:24 <lispy> xerox: why would i like it over erc?
18:17:24 <xerox> heh
18:17:35 <xerox> Clean, maintainable, short codebase.
18:17:39 <xerox> Sane defaults
18:17:53 <lispy> hmm...
18:18:01 <xerox> The developer is a nice guy :P
18:18:03 <lispy> good reasons, but i already have erc configured :)
18:18:10 * lispy wonders if xerox wrote it :)
18:18:18 <xerox> hehe no.
18:18:33 <lispy> i don't have emacs 22 yet, any reason to upgrade?
18:19:02 <xerox> Compulsive upgrade syndrome, sorry.
18:19:14 <lispy> well, i love to be running recent stuff
18:19:26 <lispy> so if there is any reason i might upgrade :)
18:19:46 <dolio> Anti-aliasing?
18:19:49 <xerox> Probably a whole Changelog of reasons, no idea if they are good enough though.
18:20:51 <lispy> dolio: hard to get anti-aliasing in screen
18:21:13 <xerox> Carbon Emacs does it, hehe.
18:21:15 * lispy runs emacs on a remote server 90% of the time and the other 10% runs 'emacs -nw' :)
18:21:18 <dolio> :) I have it when I run it in konsole.
18:21:45 <dolio> In fact, I used to run emacs in a console specifically because it had nicer text than windowed mode.
18:21:50 <xerox> lispy: crazy, and you get the meta/ctrl/blargh-stuff all correct?
18:21:57 <dolio> That and I wasn't big on the widgets anyway.
18:22:00 <Cale> I got fed up with Emacs' lack of support for good looking fonts.
18:22:08 <xerox> How many years of meditation and actual configuration did it take you?
18:22:11 <lispy> xerox: sure
18:22:19 <lispy> xerox: none :)
18:22:49 <xerox> Cale: in fact you can get debs of a version that lets you use Vera Sans and the others...
18:22:55 <lispy> well...on osx it took some tweaking with terminal, but i found that the defaults were wrong for every program so i don't count it as special time for emacs :)
18:23:16 <Cale> xerox: that would be good
18:23:19 <xerox> lispy: under screen you get C-a = move-beginning-of-line, or what?
18:23:24 <lispy> Oh
18:23:32 <lispy> in screen i rebound it it C-z
18:23:38 <lispy> so everything is C-z foo
18:23:44 <lispy> no conflict with emacs now :)
18:24:33 <xerox> Cale http://people.freedesktop.org/~keithp/emacs-xft/
18:24:37 <lambdabot> Title: Index of /~keithp/emacs-xft, http://tinyurl.com/zohdf
18:27:42 <xerox> lispy: do you also get colors? If so, how many?
18:29:30 <lispy> xerox: i do get colors, the number depends on the settings
18:29:39 <lispy> xerox: iirc, gnome terminal gets the most
18:29:45 <xerox> You might be interested in this http://twb.ath.cx/~twb/doc/misc/terminal-256color.txt
18:29:48 <lambdabot> http://tinyurl.com/qkdyr
18:29:50 <lispy> xerox: putty get some, but they are not as pretty by default
18:31:01 <dolio> "It's absurd how well mathematics models the world."
18:33:13 <Cale> dolio: ugh
18:33:26 <dolio> Hehehe. Thought you'd like htat.
18:33:32 <SamB> dolio: ... why is it absurd?
18:33:39 <SamB> it isn't exactly an accident, you know!
18:33:51 <dolio> Hey, don't ask me. Ask the random Slashdot dude.
18:33:56 <SamB> heh
18:33:56 <emu> re emacs22: http://steve-yegge.blogspot.com/2006/06/shiny-and-new-emacs-22.html
18:33:58 <SamB> no thanks
18:34:00 <lambdabot> Title: Stevey's Blog Rants: Shiny and New: Emacs 22, http://tinyurl.com/qq7tl
18:34:06 * SamB blames it on God
18:34:16 <emu> also, emacs can use any  font your system can, so.. uh, blame X :P
18:34:23 <Cale> Mathematics does *not* model the world.
18:34:37 <Cale> Physics models the world, using mathematics.
18:34:44 <SamB> true enough
18:35:16 <dolio> It was in the "supernovae may not be standard candles" article.
18:35:30 <SamB> so what if physics is *reasonable*
18:35:32 <SamB> um
18:35:45 <SamB> candles != novae, period!
18:35:46 <Cale> dolio: yeah, and it's been said a million times before
18:35:47 <xerox> icfp again?
18:35:54 <SamB> candles are short sticks of wax.
18:36:01 <SamB> novae are blown-up stars
18:36:12 <xerox> SamB has spoken.
18:36:13 <SamB> (did I mention the strings?)
18:36:15 <emu> physics models both!
18:36:23 <SamB> this is true
18:36:26 <dolio> Where people, of course, couldn't resist talkign about how magic it is that 2 + 3 = 5.
18:36:33 <SamB> um
18:36:34 <dolio> Talking, even.
18:36:37 <SamB> its not magic
18:36:40 <SamB> its just a fact
18:36:47 <SamB> 2 is just one more than one...
18:36:59 <SamB> 3 is just one more than two...
18:37:02 <SamB> etc.
18:37:23 <SamB> its all very simple
18:37:52 <SamB> if 2 + 3 = 6, than, well, you have different digits than me!
18:37:52 <lispy> xerox: circle doesn't have a debian package :(
18:37:59 <dolio> Yes, yes. I know. But hey, this is slashdot. Not some website that purports to be a community of savvy, science/technology/mathematically oriented people.
18:38:02 <xerox> lispy: cvs get it.
18:38:14 <lispy> xerox: no darcs!?!
18:38:16 <xerox> lispy: the homepage explains it all, its very straightforward
18:38:19 * lispy grumbles :)
18:38:31 <xerox> lispy: yes probably, either finally now, or in the near future
18:38:42 <SamB> descartes seems like he was being unreasonably paranoid at that point in his "meditations on first philosophy"
18:39:34 <SamB> (the point where he was worried that some Deciever might be confusing his arithmetic)
18:39:46 <lispy> i also don't have an emacs22 deb package in apt
18:39:47 <lispy> :(
18:39:50 <lispy> so i won't upgrade yet
18:40:07 <lispy> i've tried in the past to mix custom emacs build with the debian one and didn't like the result
18:40:19 <dolio> Well, you know demons like nothing better than to trick you into thinking that 2 + 2 /= 4.
18:41:06 <glguy> GHC could have fooled me
18:41:11 <dolio> @scheck 2 + 2 == 4
18:41:13 <lambdabot>  Completed 1 test(s) without failure.
18:41:15 <gmh33> can someone summarize monads for me concisely?  or is that asking too much :P
18:41:21 <glguy> I'd swear that GHC ASSERTS that 2+2==5
18:41:25 <dolio> Hehehe.
18:41:42 <dolio> ?wiki monads as containers
18:41:42 <lambdabot> http://www.haskell.org/haskellwiki/monads as containers
18:41:52 <dolio> That probably won't work.
18:42:02 <dons> gmh33: this is also recommended, http://www.nomaware.com/monads/
18:42:04 <lambdabot> Title: Nomaware | Monads
18:42:29 <dolio> http://haskell.org/haskellwiki/Monads_as_Containers
18:42:32 <lambdabot> Title: Monads as Containers - HaskellWiki, http://tinyurl.com/kn2n3
18:44:54 <dibblego> guten morgen
18:47:21 <newsham> guttenberg
18:54:39 * araujo back
19:00:23 <lispy> xerox: i'm trying to install this 256 color thing now
19:00:26 <lispy> xerox: looks pretty col
19:00:28 <lispy> er cool
19:06:51 <glguy> she says to her dad: "The scars of my broken home have made me wise beyond my years"
19:29:41 <lispy> hmm...i recompiled screen to do 256 colors, my terminal supports it but the new screen is still using 16
19:32:07 <lispy> ah!
19:32:18 <lispy> the instructions to enable 256 colors were a bit off
19:43:40 <lispy> http://www.chatmag.com/news/191806_levin_death_unconfirmed.html
19:43:44 <lambdabot> http://tinyurl.com/pr6dg
19:43:46 <lispy> some people think rob levin didn't die
19:46:45 <dons> hmm
19:46:50 <SyntaxNinja> dcoutts what's your login on darcs.h.o?
19:46:53 <SyntaxNinja> hi dons!
19:47:03 <dons> heya SyntaxNinja
19:47:26 <araujo> > [1 .. 9] >>= ((:[]) . (* 9))
19:47:27 <lambdabot>  [9,18,27,36,45,54,63,72,81]
19:49:12 <SyntaxNinja> xerox: alive?
19:49:17 <SyntaxNinja> Lemmih: alive?
19:51:07 <Cale> > [1 .. 9] >>= (return . (* 9))
19:51:09 <lambdabot>  [9,18,27,36,45,54,63,72,81]
19:51:18 <Cale> > fmap (*9) [1 .. 9]
19:51:19 <lambdabot>  [9,18,27,36,45,54,63,72,81]
19:51:39 <Krooga> > [1..10]
19:51:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:51:57 <Krooga> hmm
19:52:00 <Krooga> [1..]
19:52:18 <Krooga> :(
19:52:22 <dons> > [1..]
19:52:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:52:27 <Krooga> oh right
19:52:30 <dons> hack away
19:52:33 <araujo> > (return 1 :: [Int]) == ((: []) 1)
19:52:34 <lambdabot>  True
19:52:37 <araujo> I see :-)
19:54:02 <Krooga> > [(x,y) | x <- [1..5], y <- [1..5]]
19:54:04 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
19:55:03 <dons> > zip [1..5] [1..5]
19:55:05 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
19:55:41 <Krooga> > atan (1/0)
19:55:42 <lambdabot>  1.5707963267948966
19:56:31 <Krooga> > atan 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
19:56:33 <lambdabot>  1.5707963267948966
19:57:29 <Krooga> that breaks hugs iirc
19:58:01 <dons> 1.5707963267949
19:58:01 <dons> Hugs.Base>
19:58:04 <dons> works for me.
19:58:13 <Krooga> hmm
19:58:25 <sjanssen> hugs rounded sooner for me
19:58:30 <Krooga> it was giving me 'arithmetic overflow' in a program I wrote
19:58:30 <dons> yep
19:58:43 <dons> use ghc :)
19:58:43 <Krooga> and once it ctd
20:00:01 <SyntaxNinja> dons: you got mentioned today at CUFP, did you hear?
20:00:03 <Krooga> oh wait, yeah, i think the ctd required a LOT of 9s
20:00:07 * SyntaxNinja pokes Lemmih and xerox
20:01:11 <dons> SyntaxNinja: oh?
20:01:24 <dons> I should put a summary of ICFP and CUFP into the HWN this week
20:01:41 <dons> anyone want to write a sentence or two on each talk at CUFP? .... :)
20:01:59 <SyntaxNinja> dons: yep. cliff from linspire said you were his hero or something... something to do w/ strings or something ;)
20:02:18 <dons> oh strings. right . hehe.  :)
20:02:24 <dons> that's really nice to know.
20:02:42 <Korollary> dons++
20:02:43 <SyntaxNinja> dons: john hughes was taking notes and is going to write a full report, you might poke him for summaries in the short term.
20:03:00 <dons> ah good idea!
20:03:02 <SyntaxNinja> I think he was just doing htat so he could show off his sweet tablet PC
20:03:27 <Korollary> I want more videos. gah.
20:04:13 <dons> SyntaxNinja: he was taking notes at CUFP? or ICFP? or both?
20:04:23 <SyntaxNinja> dons: cufp at least.
20:04:28 <dons> ok cheers
20:04:40 <SyntaxNinja> cufp was 1337.
20:05:00 <dons> yeah, the line up looked very good. it gets better each year, I think.
20:05:04 <Igloo> dons: "$name said types were really cool, FP rocks and Excel is the best programming language. It's hard to find FPers. $company is hiring."
20:05:05 <SyntaxNinja> there was a guy there bragging that he pays programmers minimum wage.
20:05:25 <SyntaxNinja> dons: yeah, I think everyone must be hiring.
20:05:27 <SyntaxNinja> Igloo: where u at?
20:05:34 <Igloo> PDX airport
20:05:44 <Igloo> With free wifi
20:06:06 <Igloo> Fantastically quiet airport when you're used to Heathrow/Gatwick
20:06:07 <SyntaxNinja> Igloo: I see.  it was good seeing you!  sorry I didn't get a chance to say goodbye (that I remember)
20:06:09 * dons casts Igloo a puzzled glance
20:06:21 <SyntaxNinja> pdx airport rocks.
20:06:25 <Igloo> You too  :-)
20:06:30 <SyntaxNinja> it's small, easy to get to, and goes to good places.
20:06:31 <Igloo> dons: You wanted a few lines on each talk
20:06:36 <dons> oh right. :)
20:07:03 <Igloo> Oh, s/best/most common functional/, sorry
20:07:23 <SyntaxNinja> Korollary: there will probably be video of the programming contest talk, which was awesome.
20:07:32 <dons> ?where icfpcontest-video
20:07:33 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
20:07:51 <Igloo> Easy to get to? It takes 14 hours in the air  :-)
20:08:23 <dons> you can just download it from google, save it as a .avi file, and play it with mplayer.
20:08:34 <Igloo> Oh, there was talk about setting up an FP consortium website with job ads and success stories to point UGs at too
20:08:48 <dons> oh, sounds like a good idea
20:08:54 <Korollary> SyntaxNinja: I've seen the contest video
20:08:56 <dons> the 'jobs' page on haskell.org is a bit dated
20:09:49 * Korollary went to a Seattle Perl Users Group meeting two days ago. Don't ask why.
20:10:01 <dons> to tell them about pugs?
20:10:18 <Korollary> no. they already know anyways.
20:10:18 <dons> or to scout out the opposition?
20:10:38 <jcreigh> Korollary: reverse "?yhw"
20:10:43 <Korollary> I was mildly interested in what kind of things they talk about.
20:11:58 <Korollary> There are a lot of very competent people in every community. Different approaches for different problems.
20:12:01 <dons> Igloo: there's been talk of an FP or Haskell consortium for the last 3 or 4 years at least. People should just set up a page! :)
20:12:25 <SyntaxNinja> dons: I think this is finally the year we get critical mass
20:12:51 <dons> for the consortium? oh good, I hope so.
20:13:18 <SyntaxNinja> dons: in 2003 or whenever it was, Galois and Bluespec were the only ones interested, according to Andy Adams-Moran who was orgnanizing it.  I think that with 55+ people at CUFP this year, it may be critical mass.
20:13:18 <Adamant> a consortium for FP'ers?
20:13:31 <Korollary> Speaking of videos, there are a few Don Syme videos on F#.
20:13:34 <dons> mm. very interesting, SyntaxNinja
20:14:03 <dons> even places like Credit Suisse, I suppose, now recognise Haskell
20:16:40 <Korollary> http://www.langnetsymposium.com/speakers.asp
20:16:43 <lambdabot> Title: Lang.NET Symposium
20:17:13 <Korollary> There's also Shriram Krishnamurthi's continuations + flapjax talk there.
20:20:11 <Igloo> dons: I get the impressino there have been a number of failed $language consortium efforts, but they're hoping that a global FP consortium will find it easier to reach critical mass
20:20:24 <dons> yeah, that seems like a good idea.
20:20:43 <dons> esp. considering the cross polination between ocaml and haskell jobs
20:20:59 <dons> it makes sense
20:21:32 <dons> Igloo: oh, possibly my openbsd/linker.c patch should be merged to stable
20:21:45 <dons> if not, i'll need to include it anyway in any binary bundles I post for that OS
20:22:02 <dons> s/stable/6.6 branch/
20:25:27 <Igloo> dons: Did you push it before the pre-FC-tagging?
20:25:40 <dons> no, it went in after.
20:25:44 <Igloo> OK
20:25:53 <dons> just missed Manuel's "lock"
20:26:05 * Igloo makes a note to check it makes it
20:26:22 <dons> Igloo++
20:28:27 <glguy> dons: is that the openbsd linker patch?
20:28:44 <dons> yes.
20:28:52 <dons> glguy: did you get my msg. seems to run nicely on 3.8 too
20:29:07 <glguy> Yeah, I got that one, that's good to hear :)
20:29:23 <glguy> I'd glad that it's not version specific
20:29:29 <glguy> that would get ugly
20:29:32 <dons> right
20:31:16 <SyntaxNinja> hm. has anyone ever actually used the register --inplace flag?
20:31:57 <dons> dcoutts maybe?
20:32:44 <int-e> me.
20:32:48 <int-e> hmm
20:32:50 <int-e> no.
20:37:56 * lispy grumbles about this 256 color stuff just not working for him...
20:38:26 <dibblego> I'm getting really tired of the :load File.hs, touch File.hs, :reload sequence - why is my ghci so broken?
20:38:59 <lispy> dibblego: doesn't exactly fix your problem, but you can shorten :load to :l and :reload to :r
20:39:08 <dibblego> yeah I know, thanks
20:39:22 <lispy> dibblego: why are you forced to touch the file?
20:39:26 <dons> if you've changed the file, :reload should just work....
20:39:29 <dibblego> nfi
20:39:34 <dibblego> I don't change the file
20:39:41 <dibblego> I am forced to change the file to get it to load properly
20:39:47 <dibblego> s/change/touch
20:40:02 <dons> explicitly export the things you need in scope then
20:40:09 <dons> or.... define a macro
20:40:13 <dibblego> gah, it's working properly now
20:40:31 <dibblego> next time I'm not whinging about it, the same thing will happen
20:40:40 <dibblego> ok, I guess I'll have to
20:42:03 <lispy> i can use 256 colors over putty, but as soon as i run screen i'm back to 16 colors.  This is with a custom screen binary compiled with --enable-256colors
20:42:11 <lispy> anyone else tried this?
20:42:20 <lispy> (last time i ask and then i'll move to another channel ;)
20:44:57 <Igloo> SyntaxNinja: I did for compiling core libraries with cabal while building GHC
20:46:00 <SyntaxNinja> Igloo: yay
20:46:18 <Igloo> yay?
20:46:18 <SyntaxNinja> Igloo: I was going to add something to the docs... I wonder if there's a reason to use it without --user?
20:46:27 <SyntaxNinja> Igloo: I'm glad you used it.
20:47:05 <Igloo> I can't think of a use with --user or --global; --with-package-database is when it is useful (for distros compiling multi-package packages)
20:47:29 <Igloo> (that and the special case of building GHC, which uses a -inplace version of ghc-pkg)
20:48:45 <SyntaxNinja> Igloo: huh? is there a --with-package-database flag?
20:48:50 <SyntaxNinja> or you mean in ghc-pkg?
20:49:34 <Igloo> SyntaxNinja: No, but I think there needs to be for it to be useful (other than the special case of GHC)
20:49:38 <SyntaxNinja> I thought that register --inplace actually registered the package into a local package database, but it still tries to register it into the global package database.
20:49:52 <SyntaxNinja> ahh, what if it did what I just said I thought it did? :)
20:50:26 <SyntaxNinja> so are you saying its not useful in its current form?
20:50:36 <Igloo> What does "local" mean?
20:50:58 <Igloo> It needs to be somewhere that you can tell other cabal setups where to find it
20:53:41 <dons> ?tell shapr you've updated your address for Google SoC tshirts?
20:53:42 <lambdabot> Consider it noted.
21:01:12 <Bobstopper> Hmm. Wouldn't inet_addr and inet_ntoa from Network.Socket be more convenient if they were just implemented in haskell outside the IO () monad? I'm not really seeing the need for the IO monad there...
21:01:31 <dons> ?hoogle inet_addr
21:01:32 <lambdabot> Network.Socket.inet_addr :: String -> IO HostAddress
21:02:03 <dons> inet_addr :: String -> IO HostAddress
21:02:03 <dons> inet_addr ipstr = do
21:02:03 <dons>    withCString ipstr $ \str -> do
21:02:03 <dons>    had <- c_inet_addr str
21:02:03 <dons>    if had == -1
21:02:06 <dons>     then ioError (userError ("inet_addr: Malformed address: " ++ ipstr))
21:02:08 <dons>     else return had  -- network byte order
21:03:02 <Korollary> what does c_inet_addr do?
21:03:12 <Bobstopper> aton :: String -> HostAddress
21:03:12 <Bobstopper> aton = sum . shiftBytes . toBytes
21:03:12 <Bobstopper>     where toBytes = (map read) . (split ".")
21:03:12 <Bobstopper>           shiftBytes = zipWith (flip shift) (map (*8) [0..])
21:03:40 <dons> c_inet_addr is a wrapper for inet_ntoa
21:03:55 <dons>      inet_ntoa() takes an Internet address and returns an ASCII string repre-
21:03:55 <dons>      senting the address in `.' notation.  The routine inet_makeaddr() takes
21:03:55 <dons>      an Internet network number and a local network address and constructs an
21:03:55 <dons>      Internet address from it.
21:04:28 <dons> maybe it could be pure. we'd need to check  the C code
21:04:48 <Bobstopper> Well, I've written a pure equivalent just obove
21:05:27 <Bobstopper> Other than the foreign call, I don't think it really needs any IO
21:06:12 <SyntaxNinja> Igloo: local means like, ./local-package-config or something
21:06:27 <SyntaxNinja> or ./local-pkg-db
21:06:33 <dons> Bobstopper, if you're interested in pursuing this, submit a patch, and some tests to show it works, to libraries@haskell.org, where if there are no objections form the network guys, it could be adopted.
21:06:44 <Igloo> SyntaxNinja: But you need to be able to point cabal at ../my-package-dep/local-pkg-db then
21:06:52 <Bobstopper> dons:  cool, thanks
21:07:01 <SyntaxNinja> Igloo: yeah.
21:07:17 <Igloo> SyntaxNinja: Well, you'll have to be able to do that wherever you put it, so that's fine
21:07:27 * Igloo disappears
21:07:32 <SyntaxNinja> Igloo: fine go then
21:07:43 <SyntaxNinja> the guy thinks that just because he has a plane to catch he can stop IRCing
21:07:53 <dons> heh
21:08:02 <dons> what is this? 2005??
21:15:33 <dibblego> what is the point of the Prelude.seq function?
21:15:46 <dibblego> what does it mean to be 'bottom'?
21:16:28 <dons> > let x = undefined in 72
21:16:30 <lambdabot>  72
21:16:35 <dons> > let x = undefined in x `seq` 72
21:16:36 <lambdabot>  Undefined
21:16:43 <dons> > let x = undefined in 32 `seq` 72
21:16:45 <lambdabot>  72
21:18:07 <dibblego> <confused>
21:18:31 <dons> it forces strict evaluate of its first argument, and then returns its second argument.
21:18:37 <dons> check the haskell98 report for the gory details
21:18:51 <shapr> @yow !
21:18:52 <lambdabot> ... I have read the INSTRUCTIONS ...
21:18:57 <shapr> @users
21:19:03 <shapr> SyntaxNinja: Hiya!
21:19:06 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
21:19:10 <dons> shapr: yeah, @users has a bit of a space leak. need to fix it
21:19:13 <lambdabot> seen module failed: IRCRaised thread killed
21:19:14 <dons> ?users
21:19:21 <dons> should be fine second time around
21:19:21 <lambdabot> Maximum users seen in #haskell: 239, currently: 210 (87.9%), active: 20 (9.5%)
21:19:36 <dons> i think the Map state gets a bit big
21:19:53 <SyntaxNinja> hi shapr whazzup
21:21:12 <dibblego> > const 5 6
21:21:13 <lambdabot>  5
21:21:22 <dibblego> does const just return the first argument?
21:21:33 <dons> ?type const
21:21:34 <lambdabot> forall a b. a -> b -> a
21:21:42 <dons> if in doubt, check the type.
21:21:51 <dons> ?djinn a -> b -> a
21:21:52 <lambdabot> f a _ = a
21:21:56 <dons> ?. pl djinn a -> b -> a
21:21:56 <lambdabot> f = const
21:21:59 <dons> :)
21:22:02 <dibblego> I did, I don't know how you can figure out that it is always going to return the first argument from the type
21:22:23 <dibblego> const 7 8 could return 5 from that type
21:22:30 <dons> no, it couldn't!
21:22:34 <dons> it's polymorphic..
21:22:43 <dmwit> const has to work for ALL pairings of a and b...
21:22:49 <dons> ?type let f 7 y = 8 in f
21:22:51 <lambdabot> forall a t t1. (Num a, Num t1) => a -> t -> t1
21:22:56 <dons> not the same :)
21:23:08 <dons> as soon as you do something to the argument, you place some constraint on it, that changes the type
21:23:14 <dibblego> ok
21:23:30 <dibblego> then seq always returns the second argument
21:23:37 <dons> so, forall a b . a -> b -> a, really must be the function that returns just its first argument.
21:23:46 <dons> ?type seq
21:23:48 <lambdabot> forall b a. a -> b -> b
21:23:49 <dibblego> yes I think I know what you are saying
21:24:02 <dons> for example, try to come up with a function of type: a -> a
21:24:08 <dons> how many such functions are there?
21:24:22 <dibblego> good point
21:24:30 <dons> ?type let f x = x in f -- one option
21:24:32 <lambdabot> forall t. t -> t
21:24:38 <dons> now, are there any others (hint: yes)
21:24:54 <dons> let me know if you want more clues...
21:25:14 <dibblego> > let f x = x in id x
21:25:15 <lambdabot>  Not in scope: `x'
21:25:24 <dibblego> er
21:25:36 <dibblego> let f x = id x in f
21:25:40 <dibblego> > let f x = id x in f
21:25:41 <lambdabot>  Add a type signature
21:25:45 <dibblego> gah I dunno
21:25:50 <dons> ?type let f x = id x in f
21:25:52 <lambdabot> forall a. a -> a
21:25:58 <dons> so, yes, using id you can write id :)
21:26:06 <dibblego> was that your point?
21:26:10 <dons> no...
21:26:16 <dons> there's always "bottom" too!
21:26:21 <dons> ?type f x = undefined in f
21:26:23 <lambdabot> parse error on input `='
21:26:28 <dons> ?type let f x = undefined in f
21:26:30 <lambdabot> forall t a. t -> a
21:26:34 <dons> ?type let f x = undefined in f :: a -> a
21:26:36 <lambdabot> a -> a :: forall a. a -> a
21:26:40 <dibblego> wtf is bottom?
21:26:49 <dons> ?type undefined
21:26:51 <lambdabot> forall a. a
21:26:55 <vincenz> _|_
21:27:01 <vincenz> or in lisp syntax
21:27:03 <vincenz> (_|_)
21:27:14 * dolio snickers.
21:27:23 <dons> bottom/undefined is an inhabitant of every (non-strict) type in haskell. it represents divergent computations and more
21:27:24 <dibblego> why is undefined called bottom?
21:27:48 <dmwit> LaTeX... ?
21:27:51 <dons> undefined is known as _|_ in the literature (pronounced 'bottom). as opposed to T (top)
21:28:10 <dons> the bottom inhabitant of every type
21:28:11 <vincenz> or in english, arse
21:28:14 <dmwit> Oh, so "just because".
21:28:22 <dons> > True :: Bool -- one inhabitant of the type Bool
21:28:22 <vincenz> dons: just like the bottom inhabitant of every human?
21:28:23 <lambdabot>  True
21:28:28 <dons> > False :: Bool -- another
21:28:29 <lambdabot>  False
21:28:34 <dons> > undefined :: Bool -- and another!
21:28:35 <lambdabot>  Undefined
21:28:40 <dons> > error "the same thing" :: Bool
21:28:42 <lambdabot>  Exception: the same thing
21:28:50 <vincenz> error is a bit flawed :/
21:28:58 <dons> well, its just another way to write bottom
21:29:18 <vincenz> except now you have different kinds of bottoms
21:29:34 <dons> they're the same to the type system though.
21:29:53 <vincenz> yeah but since they're not hte same to the runtime system
21:29:55 <dons> > let f = f in f :: Bool -- another!
21:29:56 <lambdabot>  Exception: <<loop>>
21:29:58 <vincenz> you gotta be careful in what your computer does
21:30:02 <vincenz> err
21:30:06 <vincenz> s/computer/compiler/
21:31:21 <dmwit> ?type .
21:31:22 <lambdabot> parse error on input `.'
21:31:25 <dibblego> then what is the point of the (a -> a) argument to until?
21:31:28 <dmwit> ?type (.)
21:31:30 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
21:31:33 <dibblego> since all (a -> a) functions are equivalent
21:31:44 <dmwit> ?type until
21:31:46 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
21:32:04 <dmwit> You can substitute a more specific type for 'a' in there.
21:32:22 <dmwit> So, you could have a function f :: Num a => a -> a
21:32:32 <dibblego> ok
21:32:34 <dmwit> which now no longer needs to be id
21:32:37 <dons> > until (\c -> c == 10) (\c -> c+1) 0
21:32:38 <lambdabot>  10
21:33:13 <vincenz> until is a rather lame function
21:33:24 <vincenz> since we have no side-effects...
21:33:34 <vincenz> might as well use iterate and dropWhile
21:33:40 <dibblego> > until (== 10) (+1) 0
21:33:40 <vincenz> (alternatively takeWhile)
21:33:41 <lambdabot>  10
21:33:46 <dibblego> > until (== 10) (+2) 1
21:33:49 <lambdabot> Terminated
21:33:59 <dibblego> > until (== 10) (+2) 2
21:34:01 <lambdabot>  10
21:34:02 <dons> > until (\(c,_) -> c == 10) (\(c,(x:xs)) -> (c+1,xs)) (0,"haskell is fun")
21:34:03 <dibblego> ok ta
21:34:04 <lambdabot>  (10," fun")
21:34:17 <vincenz> dons: heh....
21:34:41 <dons> until++
21:34:45 <vincenz> > dropWhile (\x -> fst x < 10) $ zipWith [0..] "haskell is fun"
21:34:45 <lambdabot>    Expecting a function type, but found `a'
21:34:46 <lambdabot>    Expected type: [(a, b)]
21:34:46 <lambdabot>  ...
21:34:53 <vincenz> > dropWhile (\x -> fst x < 10) $ zip [0..] "haskell is fun"
21:34:55 <lambdabot>  [(10,' '),(11,'f'),(12,'u'),(13,'n')]
21:35:02 <dons> > drop 10 "haskell is fun"
21:35:04 <lambdabot>  " fun"
21:35:10 <dons> until--
21:35:12 <vincenz> > "fun"
21:35:13 <lambdabot>  "fun"
21:35:47 <dmwit> > let countDrop n xs = (n, drop n xs) in countDrop 10 "haskell is fun"
21:35:49 <lambdabot>  (10," fun")
21:36:13 <vincenz> not quite the same
21:36:20 <vincenz> dons' original one with until would crash on strings < 10
21:36:27 <vincenz> patternmatching failure
21:36:35 <dmwit> ah
21:40:35 <dons> mmm now 30.1°
21:43:17 <dibblego> nice hey :)
21:43:25 <dons> warm up there?
21:43:32 <dibblego> yeah, and they are "testing" our a/c
21:43:38 <dibblego> i.e. it is off
21:43:40 <dons> heh
21:44:18 <dibblego> I made some grammatical changes to your "Introduction to QuickCheck" document
21:44:30 <dibblego> actually, I think I only made one or two changes
21:44:48 <dibblego> just to test if I could update the wiki
21:44:50 <dons> yeah, I saw. thanks for that!
21:44:54 <dons> dibblego++
21:44:55 <dibblego> no problem
21:45:01 <monochrom> They need QuickCheck for the a/c.
21:48:18 <dons> yay, my hacky sacks arrived from the US :)
21:49:02 <dons> they'd forgotten my order, and I mailed them a couple of days ago, and now I find they sent me double the number of sacks + stickers too apologise for the delay :)
21:49:20 <skew> how long did they forget for?
21:49:26 <dons> 8 weeks :/
21:49:37 <dons> i was writing a paper, so I forgot too :}
21:50:38 <skew> I mailed Daan a few weeks ago to remind him that his page promises he will release an interpreter sometime in september, since octoboer last year.
21:51:04 <skew> Turns out you can get it from his homepage under microsoft.
21:51:05 <dons> hehe
21:51:17 <dons> oh? interpreter for what?
21:51:26 <skew> his type systems
21:51:41 <dons> ah yes.
21:53:23 <skew> www.equational.org/morrow
21:54:48 <skew> there's no proper page at www.equational.org.  Aha - www.equational.org/repos/
21:55:27 <monochrom> What is a hacky sack?
21:58:01 <dons> here, http://en.wikipedia.org/wiki/Footbag
22:03:03 <vincenz> hackey sack
22:03:12 <vincenz> \o/
22:03:35 <dons> hockey stick
22:03:42 <dons>  /o\
22:03:52 * dons plays funny games
22:04:28 <vincenz> :)
22:04:39 <vincenz> I have a hackey sack but noone to play it with
22:04:48 <vincenz> I have several, they also make good juggling balls
22:05:00 <dons> ah yes.
22:07:46 <lispy> hmm..
22:07:55 * lispy tries his new colors in emacs
22:08:41 * skew feels slightly silly using crazy GADTs to build a mostly-statically correct type checker for a partially dynamic type system
22:09:27 <lispy> skew: are you sure *that's* the reason you feel crazy? ;)
22:09:30 <dons> ?remember skew feels slightly silly using crazy GADTs to build a mostly-statically correct type checker for a partially dynamic type system
22:09:46 <lispy> er i guess skew feels silly not crazy
22:09:50 <lispy> maybe i feel crazy
22:09:56 * lispy ponders
22:10:08 * weitzman ruminates
22:10:22 <lispy> well, i didn't go for my jog yet and it's after 10pm
22:10:26 <dons> "Lambdas in C++ are one of the more interesting things to look forward to in the next C++ standard"
22:10:29 <lispy> guess i'm not going to do it today...
22:10:37 <lispy> dons: wha?
22:10:44 <dons> mainstream IT press, http://www.regdeveloper.co.uk/2006/09/22/cplusplus-lambda-future/
22:10:48 <lambdabot> http://tinyurl.com/zsvkm
22:10:52 <weitzman> I'm guessing that means the next C++ comes complete with garbage collection
22:11:40 <lispy> the standard solution in C++ is to explicitly use ref counting via constructors
22:11:48 <lispy> (well and destructors)
22:11:52 * gour would like that next C++ comes with RIP label
22:12:04 <lispy> hehe
22:12:08 <weitzman> If your lambdas refer to object fields, they need pointers to the object
22:12:14 <weitzman> And the object might have pointers to the lambda
22:12:18 <weitzman> And bad things will happen
22:13:04 <dons> gah, all the junk in there about what to do "Lambdas may reference variables and continue to do so after it is no longer safe"
22:13:09 <dons> mmm. broken before it even begins...
22:13:22 <skew> so it will just helpfully "undefined behaviour" if you try to use a "lambda" outside the declaring function?
22:13:34 <dons> oh, beautiful: <> (auto x, auto& y) { y += x; }
22:13:34 <weitzman> Well, I guess "this might not work" is an easy-to-implement solution
22:14:03 * lispy runs in fear
22:14:20 <dons> "You cannot do address arithmetic on function pointers unless you reinterpret_cast them"
22:14:32 <vincenz> dons: what was that
22:14:34 <vincenz> <> stuff
22:14:47 <weitzman> I would be cool if there was a C++ compiler that fully exploited the power of undefined behavior
22:14:47 <vincenz> dons: yeah, don't expect closures in c++
22:14:48 <dons> that's \x y -> y+x -- :)
22:14:56 <dibblego> @type asTypeOf
22:14:58 <lambdabot> forall a. a -> a -> a
22:15:02 <weitzman> It could start printing prime numbers anytime you dereference NULL
22:15:05 <skew> didn't the early gcc do something amusing?
22:15:21 <dibblego> that always returns the first argument?
22:15:22 <vincenz> weitzman: :P
22:15:42 <dibblego> > asTypeOf 7 8
22:15:43 <lambdabot>  7
22:15:48 <dibblego> why not 8?
22:16:01 <vincenz> > 7 `asTypeOf` 8
22:16:02 <lambdabot>  7
22:16:18 <vincenz> heh, infix vs prefix...
22:16:25 <weitzman> > (read "3") `asTypeOf` (1::Int)
22:16:27 <lambdabot>  3
22:16:35 <weitzman> > (read "3") `asTypeOf` 1
22:16:35 <dibblego> ah
22:16:37 <lambdabot>  3
22:16:37 <Cale> The reason that's in the prelude is as an apology for not having lexically scoped type variales
22:16:41 <Cale> variables*
22:17:03 <skew> http://en.wikipedia.org/wiki/Undefined_behavior
22:17:06 <lambdabot> http://tinyurl.com/mtknp
22:17:06 <weitzman> > (read "[3]") `asTypeOf` []
22:17:08 <lambdabot>  Add a type signature
22:17:14 <weitzman> > (read "[3]") `asTypeOf` [4]
22:17:15 <lambdabot>  [3]
22:17:31 <dibblego> > (read "[3]") `asTypeOf` [] :: [Int]
22:17:33 <lambdabot>  [3]
22:17:47 <vincenz> > (read "[3]") :: [Int]
22:17:48 <lambdabot>  [3]
22:18:22 <skew> more specifically, http://www.djmnet.org/humor/gcc-pragma.txt
22:22:55 <dibblego> is ByteString (http://www.cse.unsw.edu.au/~dons/data/ByteString.html) some kind of attempt to increase performance by using a char* ?
22:23:08 <dons> it's some kind of attempt, yes.
22:23:17 <dibblego> is it a successful attempt?
22:23:22 <dons> ?where fps
22:23:43 <Cale> It's an attempt that results in better than naive C programs' performance on some applications.
22:23:54 <weitzman> Lambdabot is dead again
22:23:58 <dons> where's my bot?
22:24:16 <Cale> heh
22:24:28 <weitzman> Oh goody. Netsplits
22:24:30 <weitzman> Anybody there?
22:24:31 <dcoutts__> @botsnack
22:24:39 <Cale> http://www.cse.unsw.edu.au/~dons/fps.html
22:24:58 <dcoutts__> dibblego: we think it's a successful attempt
22:25:17 <lispy> whoa....my new pretty colors don't seem to exist in osx terminal
22:25:40 <Cale> dibblego: This talk gives a good quick overview http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
22:25:40 <dons> ?bot
22:25:52 <dibblego> thanks
22:26:30 <dons> ?bot are you listening to me?
22:26:39 <dons> yes, it seems, #haskell> ?bot are you listening to me?
22:26:40 <dons> hmm
22:26:43 <Cale> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html -- and this is the paper on it
22:27:17 <Cale> dons: there have been times when I was able to hit Ctrl-C and get it to come back to life
22:27:23 <Cale> (rather than quitting)
22:27:30 <skew> Also excellent paper about writing haskell libraries
22:27:49 <lispy> Cale: same here, which makes me think signals are not handled correctly in all cases
22:28:02 <dibblego> what does fps stand for?
22:28:10 <Cale> fast packed string
22:28:20 <Cale> which was the old name for the library
22:28:41 <Cale> or I suppose still the shortform?
22:28:46 <dons> yeah
22:29:04 <dcoutts__> lambdabot!
22:29:07 <dcoutts__> @botsnack
22:29:15 <Cale> > 1 + 1
22:29:19 <Korollary> 2
22:29:27 <dcoutts__> 3
22:29:35 <lambdabot> :)
22:29:36 <dons> let's jsut wait on freenode's arbitrary 'threadDelay' ...
22:29:41 <dons> good bot
22:29:45 <lambdabot>  2
22:29:46 <dolio> Does botsnack do anything now that lambdabot doesn't smile?
22:29:57 <dcoutts__> @botsnack
22:29:58 <lambdabot> :)
22:29:59 <Cale> > scanl (flip (:)) [] [1,2,3,4]
22:29:59 <Korollary> raises its cholesterol
22:30:00 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
22:30:08 <dons> that too, Korollary. yes.
22:30:31 <dolio> Oh, Apparently I just don't pay enough attention.
22:30:46 * Korollary puts dolio on medication
22:31:45 <Cale> @check \xs -> let f = (map head . drop 1 . scanl (flip (:)) []) in f xs == (xs :: [Int])
22:31:46 <lambdabot>  OK, passed 500 tests.
22:32:49 <dibblego> why can't the compile make a [Char] act as if it were a ByteString?
22:32:52 <dibblego> *compiler
22:33:11 <dcoutts__> the semantics is too different
22:33:25 <Cale> It does do some optimisation, but there's a limit to what can be done.
22:33:28 <dons> though ndm's writing such a compiler, i've heard
22:33:51 <dcoutts__> it doesn't use packed strings for String does it ?
22:34:11 <dons> not yhc, he has some analysis derived from Views that he wants to write a PhD on...
22:34:12 <Cale> As soon as you have code which operates on a String by pattern matching recursively, you've ruined your performance.
22:34:19 <dons> maybe i've got the details wrong.
22:34:21 <dcoutts__> even if each Char is not boxed, the list still has to be I'd think
22:34:44 <dcoutts__> Cale: well a compiler could do a view
22:34:50 <dcoutts__> a special case
22:35:01 <skew> you could have separate records indexing into the data segment of a string
22:35:11 <Cale> dcoutts__: Would it be able to translate that code into a loop? Maybe.
22:35:31 <skew> reminds me of eager evaluation, doing some levels of recursion strictly, but cutting things off at some point to avoid nontermination
22:35:43 <dcoutts__> Cale: ghc can already generate loops for list code
22:35:47 <dcoutts__> tail recursion
22:36:02 <Cale> well, yeah, I suppose it can :)
22:36:20 <dons> dcoutts__: I might tag the stable repo as fps 0.8 this weekend
22:36:22 <skew> after all, flatteing String = Char : String | [] out for a few thousand levels is nothing on modern hardware, just an infinite number of times gets you into trouble
22:36:23 <weitzman> I wonder how tail recursion interacts with laziness though
22:36:30 <dons> and then move unstable over to the stable branch
22:36:31 <dcoutts__> dons: ok cool
22:36:41 <Cale> weitzman: poorly, usually
22:37:16 <lispy> Cale: why poorly?
22:37:50 <Cale> lispy: outermost first evaluation
22:38:28 <Cale> so in particular, things in the parameters are not getting compressed, and you're building up large unevaluated expression graphs
22:38:49 <lispy> oh
22:38:57 <Cale> also, if all the function does is call itself, then it's not producing a constructor
22:39:21 <Cale> and it will continue to do so until it does
22:39:40 <Cale> (because presumably, something has demanded to know at least what the top level constructor is)
22:39:49 <dolio> Laziness turns tail recursion into regular recursion. :)
22:40:19 <lispy> that strikes me as ironic...
22:40:24 <dons> dibblego: you were looking at the 'Example code' page?
22:40:26 <Cale> Well, you still get a nice tight loop, it's just that all it does is to build up work for the future ;)
22:40:34 <Cale> and usually get you into a stack overflow
22:40:35 <dibblego> dons, yes I am still
22:40:44 <Cale> > foldl (+) 0 [1..1000000]
22:40:47 <lambdabot>  Exception: stack overflow
22:40:47 <dons> do you have any comments on that page? is it useful? could it be improved?
22:40:52 <weitzman> Does Haskell use genuine stacks?
22:40:52 <dolio> That was actually in one of the SICP lectures I watched today.
22:41:01 <Cale> The solution is to force the parameters as you go
22:41:03 <dons> its quite new, and I'm still working out how it should be presented
22:41:04 <Cale> > foldl' (+) 0 [1..1000000]
22:41:05 <lambdabot>  500000500000
22:41:06 <dibblego> I think some simpler examples would be good
22:41:16 <dons> hmm, yes ok.
22:41:21 <dons> good idea.
22:41:22 <Cale> (that is, to add some more strictness)
22:41:34 <dolio> Abelson commented about how lazy languages "like Miranda" turn "iteration" into something with the same space behavior as recursion.
22:42:05 <dibblego> dons, so, take a list of int from a file and do this and that, then write to this file or something
22:42:18 <dons> ok, yes.
22:42:48 <Korollary> They do? I thought tail-recursion did that.
22:43:14 <Cale> dolio: The problem comes when you're going from a composite structure down to an atomic structure, and using all (or most) of the parts of the composite one.
22:43:26 <Cale> This is where you really want strictness.
22:43:36 <Cale> In all other cases, laziness is fine.
22:44:08 <dolio> Right.
22:45:02 <Cale> sometimes it can be tricky to recognise that this is really happening though :)
22:45:10 <weitzman> > foldl (+) 0 [1..1000000]
22:45:13 <lambdabot>  Exception: stack overflow
22:45:19 <dolio> Korollary: If you're always lazy, then an accumulator turns into a bunch of nested function applications, just like recursion without an accumulator.
22:45:36 <dibblego> ?index second
22:45:36 <lambdabot> Control.Arrow
22:47:53 <vincenz> re
22:54:41 <vincenz> dons: ping
22:54:56 <dons> yes?
22:55:04 <vincenz> what distro do you use?
22:55:21 <dons> openbsd
22:55:51 <vincenz> preferred language besides haskell?
22:56:31 <dons> C, sh, sed
22:56:33 <dons> :)
22:56:46 <dons> is this an interview?
22:56:51 <vincenz> yeah
22:56:54 <vincenz> no
22:56:56 <vincenz> was just curious
22:57:05 <vincenz> trying to find out what language to use besides haskell
22:57:18 <vincenz> the distro was an orthogonal issue (ubuntu ships with old ghc's)
22:57:22 <dons> I used to write a lot more perl, but have pretty much just written haskell and C since around 2002
22:57:38 <skew> what are you trying to do?
22:57:44 <vincenz> stop bitrot
22:57:54 <Cale> Heh, we should have a syntax like [a,b,c..] which generates the recurrence x_0 = a, x_(n+1) = r x_n + k, where r = (b - c)/(a - b) and k = (ac - b^2)/(a - b)
22:58:21 <vincenz> Cale: o.O
22:58:21 <dons> how very MP Jones-ish/Gofer circa. 1992
22:58:32 <shapr> hi skew
22:58:33 <dons> recurrence patterns, anyone?
22:58:40 <skew> hi shapr
22:58:48 <shapr> Nice to meet you in person.
22:58:57 <skew> yeah
22:59:30 <dons> vincenz: if you want languages to really ponder: try epigram, twelf or Isabelle
22:59:40 <dons> they're the ones I'd most like to get really good at.
22:59:40 <vincenz> dons: more looking for a reasonable dyntyped lang
22:59:51 * vincenz is torn between ruby and scheme atm
22:59:56 <kosmikus> skew: oh, I always thought your name sounded familiar, but I didn't make the connection that you're on irc, too ...
23:00:07 <vincenz> ruby: cleaner (lexical) syntax, scheme: power of macros
23:00:25 * shapr accidentally discovers the connection between the name "tonk" and proof theory.
23:01:47 <vincenz> anyways
23:01:50 <vincenz> right now I have to hack ocaml
23:01:51 <vincenz> blegh
23:02:00 <vincenz> It used to be pretty, haskell made it ugly :/
23:02:06 <skew> kosmikus = ?
23:02:08 <dons> heh
23:02:18 <skew> vincenz: hack some C and it will get pretty again
23:02:31 <dons> ?remember vincenz [Ocaml] used to be pretty, Haskell made it ugly
23:02:36 <shapr> Tonk is a nonsensical expression that's disallowed by Dummet's http://en.wikipedia.org/wiki/Logical_harmony
23:03:13 <vincenz> dons: anyways, I'm not a type-guru, so haskell's typing's fine for me :)
23:03:23 <vincenz> dons: was more looking for smoething where static typing won't hack it
23:04:03 <dons> I've not ever needed to avoid the static typing.
23:04:08 <skew> are you looking for things where ZF won't hack it?
23:04:16 <dons> do you have some app that you feel doesn't work nicely with static typing?
23:05:12 <vincenz> nothing specific, more some fuzzy domains
23:05:16 <dons> dibblego: I added this for you: http://www.cse.unsw.edu.au/~dons/data/Basics.html
23:05:18 <lambdabot> Title: Haskell basic unix tools, http://tinyurl.com/zq2lk
23:05:19 <dons> dibblego: comments?
23:05:24 <vincenz> that and the fact that it's possible to write a scheme compiler :)
23:05:49 <dibblego> dons, excellent!! especially that I can easily see the meaning because they are unix tools
23:05:50 <vincenz> btw, read dan piponi's blog?
23:06:01 <shapr> Piponi's blog is great fun.
23:06:02 <vincenz> I found it rather interesting :) the whole concept of you get differentials for free
23:06:04 <dibblego> ?type interact
23:06:05 <lambdabot> (String -> String) -> IO ()
23:06:09 * shapr boings
23:06:20 <vincenz> and conceptually the trick isn't difficult, just have to think of it ;)
23:07:20 <dibblego> "Written for clarity, not speed. " -- why must they exist in contradiction?
23:07:43 <Korollary> Sufficiently smart compilers have not arrived.
23:07:46 <dons> they may be fast too, but avoid things like using Data.ByteString (i.e. if you needed to beat C)
23:07:53 <dons> s/but I avoid/
23:08:12 <dolio> The world is already rife with scheme compilers/interpreters, though. :)
23:08:22 <dolio> You should write a Ruby compiler. I'm sure you'd get lots of fame.
23:08:28 <dons> i'll amend that line. since its probably still going to be faster than php, ruby and perl combined :)
23:08:36 <dibblego> exactly
23:08:50 <dibblego> I understand the need to be conservative, but it's not really good marketing to the noobs
23:09:00 <dons> yes.
23:09:50 <dons> you have to remember that I've just spent 6 months working Data.ByteString, so "just" C++ performance doesn't do it for me anymore ;)
23:10:16 * dcoutts__ grins
23:10:24 <dibblego> I have a similar problem in other areas - I am conservative in my arguments but appear to be the opposite to my audience (of noobs on the topic)
23:10:52 <vincenz> anyone remember of the tope of their head what the utility is that is used to read .ps's ?
23:11:16 <dons> gv?
23:11:33 * vincenz shakes
23:12:09 <sjanssen> vincenz: a printer? ;)
23:12:20 <dons> heh
23:12:32 <vincenz> aha! evince
23:13:01 <Korollary> that's a wrapper around gv and xpdf
23:13:40 <vincenz> dons: btw, lazy bottoms get mentioned quite a lot in the icfp presentation \o/
23:13:45 <vincenz> (sadly we didn't get TOO far :/ )
23:14:34 <dons> vincenz: yes, I know! well done. (you'll be in the HWN next week :)
23:14:55 <dons> and there was a brief mention of edwarkd's jitting-ghc UM implementation
23:15:00 <vincenz> :)
23:15:25 <dolio> Heh.
23:16:48 * Korollary likes popcorn with c-like syntax.
23:17:04 <dons> :D wasn't that a great idea.
23:17:09 <dons> I must remember to do that for my upcoming talks
23:17:21 <dons> (instead of blagging on about whatever window manager or tool I'm using at that time)
23:17:46 <vincenz> yeah that was a funny comment :)
23:20:14 <skew> "Stop thinking about bottoms when writing programs" http://www.cs.nott.ac.uk/~txa/talks/bctcs06.pdf
23:20:19 <lambdabot> http://tinyurl.com/fx5ap
23:22:40 <Korollary> Interesting point
23:22:42 * Korollary reads on
23:23:44 <skew> if they could just figure out how to make Epigram Turing-complete, we'd be set!
23:25:07 <vincenz> skew: what is nuX.1
23:25:39 <roconnor> Doesn't epigram have general recursion?
23:25:50 <skew> nuX.(1 + A x X)
23:25:59 <skew> like letrec X = 1 + A * X
23:25:59 <vincenz> oh
23:26:11 <vincenz> . binds less tight than the rest
23:26:13 * vincenz nods
23:26:44 <skew> then nu is greatest fixpoint (infinite structures), and mu is least (only finite ones)
23:26:59 <roconnor> skew: why would we want a language to be Turing-complete?
23:27:13 <skew> so we could write a compiler for itself in it
23:27:23 <skew> and throw away the rest
23:27:33 * vincenz nods at skew
23:27:56 <vincenz> skew: why the 1+  ?
23:27:57 <skew> there's a slide in the middle about that
23:28:01 <vincenz> why not something else than 1?
23:28:09 <skew> 1 = (), used for nil
23:28:17 <skew> + = Either, * = (,)
23:28:18 * vincenz nods
23:28:27 <vincenz> yeah + I knew about, didn't know 1 = () was std practice
23:28:29 <skew> wouldn't be lists otherwise
23:28:30 <vincenz> thx
23:28:43 <roconnor> skew: You don't need it to be Turing-complete to write a complier for itself
23:28:47 <Korollary> ask.com is not bad. Hmm.
23:28:55 <roconnor> for an interpreter, yes, but not a complier
23:29:14 <skew> typechecking epigram is turing-complete
23:29:17 <shapr> skew: I think the plan for Epigram is to develop with strong normalization and then allow fix for 'production' use.
23:29:33 <roconnor> typechecking is turing complete!!!
23:29:35 <skew> I think these slides may be the new plan
23:29:40 <shapr> oh?
23:29:52 <skew> well, something tricky about epigram is turing complete
23:29:55 <vincenz> skew: could you explain the slide of "Can we always avoid _|_" with the SK and @ stuff?
23:30:23 <skew> that says interpreters (for non-total languages) might not terminate
23:30:50 <skew> I think it's more that any function defined in epigram terminates, but you can't prove that in epigram because of some diagonalization argument
23:31:13 <dibblego> why cat = interact id instead of cat = interact ?
23:31:25 <dons> ?type interact
23:31:26 <lambdabot> (String -> String) -> IO ()
23:31:27 <roconnor> skew: that sounds about right.
23:31:36 <skew> I need some help with types: http://paste.lisp.org/display/26506
23:31:42 <vincenz> skew: I take it that that SK :@ is wel known in your world?
23:31:52 <dibblego> ?type interact id
23:31:54 <lambdabot> IO ()
23:32:06 <roconnor> vincenz: I didn't understand SK and @ at all ;)
23:32:22 <vincenz> skew: ah nice, indirect composite :)
23:32:30 <vincenz> skew: it's a hassle tho :/
23:32:36 <vincenz> skew: go for a tagging based system, less hassle
23:32:52 <shapr> Partiality is an effect?
23:32:54 <shapr> wtf?
23:33:07 <roconnor> vincenz: oh, this is S and K combiniators with application
23:33:48 <skew> hmm, the indirect composite was not such a problem for me - the function opens up the wrapper once, then it has a helper that does a case over the Exp type, and recurses back to the top
23:33:51 <vincenz> skew: could you amplify on your question?  I use a similar system, with type-inference and all
23:34:19 <vincenz> I found that after a while, however, indirect composite gets nasty (if you have several stages) so for the lowered version of the AST, I use a tagged system
23:34:30 <skew> tagged?
23:35:04 <vincenz> yeah
23:35:18 <vincenz> data Exp ann = .... | ETag ann
23:35:26 <skew> oh, hmm
23:35:28 <vincenz> I even reuse some of bringert's stuff
23:35:31 <vincenz> let me fish up the file :)
23:35:38 <skew> well, the annotations are part of the syntax, only show up on lambdas
23:35:40 <vincenz> from his icfp paper this yea r:)
23:36:07 <vincenz> @where paste
23:36:07 <lambdabot> http://paste.lisp.org/new/haskell
23:36:22 <lisppaste2> vincenz pasted "ANF -- tagging with Compos " at http://paste.lisp.org/display/26507
23:37:03 <vincenz> it uses an extended version than his compos in his ICFP paper
23:37:09 <vincenz> cause my GADT has two parameter,s not one
23:37:19 <roconnor> skew: there is no proof of false in peano arithmetic, althought you can't prove that in peano arithmetic ;)
23:37:22 <vincenz> one of which, the annotation, is phantom for most datacons
23:39:03 <vincenz> skew: heh, your paper lost me :/
23:39:13 <Korollary> astrolabe!
23:39:22 <vincenz> skew: but look at that paste
23:39:30 <astrolabe> Hi Korollary :)
23:39:33 <skew> the slides are not mine
23:39:52 <skew> Thorsten Altenkirch
23:39:54 <vincenz> skew: well I'm not a CSer, nor a type-theorist, so it's easy to lose me on these sorts of topics
23:41:42 <skew> what is that "a" for?
23:41:48 <vincenz> skew: what 'a'?
23:42:06 <skew> oh, you can tag something without changing the sort
23:42:17 <vincenz> right
23:42:20 <skew> I was considering a similar tag, to separate out the let constructor
23:42:21 <vincenz> so you can tag exp's
23:42:24 <vincenz> or tag vars
23:42:31 <vincenz> basically your GADT encodes your entire AST
23:42:38 <vincenz> but not all of them may be combineable at all times (hence a GADT)
23:42:46 <skew> was that the tagging you were talking about? there's also making that Tag constructor
23:42:54 * vincenz nods
23:43:02 <vincenz> yes, having it in your AST
23:43:13 <skew> so I just have this one Exp type, but I suppose I could still use a tag to set Let apart
23:43:16 <vincenz> I doubt you need a GADT tho
23:43:32 <skew> I did more complicated tagging on my types.
23:44:13 <vincenz> such as?
23:44:48 <skew> so a few constructors can only appear in the surface syntax, and should be translated away, those get marked with Surface
23:45:06 <skew> others get marked just with (Internal a)
23:45:29 <skew> some more are completely polymorphic, and that parameter of Internal is used to refine the internal types a bit more
23:45:52 * vincenz doesn't see that in your paste
23:45:57 <vincenz> notice that the ANF is already lowered
23:46:00 <vincenz> before that I have my AST
23:46:00 <skew> I didn't include that stuff
23:46:10 <vincenz> which was with the system you used
23:46:11 <skew> I'm just interested in the type checker
23:46:14 <vincenz> (indirect composite)
23:47:50 <skew> I'll see if I can work something up with a GADT for Exp as well
23:48:17 <skew> these things are really handy for getting the types just right
23:48:18 <vincenz> lemme know how it goes :)
23:48:29 <skew> Generally Awesome Data Types.
23:48:37 * vincenz gets back to his c++ stuff
23:48:55 * vincenz sighs
23:49:07 <vincenz> copy-paste-programming at it's best :/
23:56:57 <dons> some people might be interested (beginners) http://haskell.org/haskellwiki/Simple_unix_tools
23:56:59 <lambdabot> Title: Simple unix tools - HaskellWiki, http://tinyurl.com/hekpb
23:58:38 <skew> how about timing them with ByteString?
23:59:21 <skew> how much of that would work with an import Prelude hiding (..) and import ByteString
