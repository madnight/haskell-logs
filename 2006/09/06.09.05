00:00:59 <jrmole> all right, ttyl
00:02:19 <foxy> anyone know the LaTeX symbol for the set of natural numbers |N ? (It's not in LaTeX user's guide)
00:03:46 <dolio> One of the packages has a command for blackboard bold letters.
00:03:58 <dolio> That's what I usually use.
00:03:59 <edwardk> \mathds{N} isn't it?
00:04:17 <sieni> foxy: something like {\mathbb N} or something?
00:05:39 <sieni> foxy: with \usepackage{amsfonts}
00:06:41 <sieni> well, that gave more like |\\| rather than ||\|
00:07:01 <edwardk> i think mathds
00:07:08 <sieni> tetex doesn't seem to have dsfonts available hmm...
00:07:13 <sieni> extreme suckery
00:07:41 <edwardk> \usepackage{dsfont} =)
00:07:54 <edwardk> no s in my boilerplate here
00:08:01 <sieni> argh
00:09:24 <sieni> foxy: so \documentclass{scrreprt}\usepackage{dsfont}\begin{document}$\mathds N$\end{document} appears to work with tetex at least
00:10:10 <sieni> foxy: use your document class of choice instead of scrreprt :-)
00:10:16 <edwardk> heh
00:11:22 <dolio> Ooo: \mathrm{I\!N}
00:11:25 <dolio> Build your own. :)
00:11:39 <foxy> sieni, thanks!
00:11:58 <edwardk> dolio: cheap =)
00:12:02 <sieni> dolio: do that with Q ;-)
00:12:08 <edwardk> hehehehehe
00:12:58 <foxy> \usepackage{amsfonts} $\mathbb N$ is what I was after :)
00:13:00 <dolio> Hehe. I found an example doc with several methods. No Q, though.
00:15:54 <edwardk> ok, now i need to find a linear lolli operator in latex ;)
00:16:09 <edwardk> ah multimap
00:16:10 <edwardk> duh
00:49:15 <kzm> Do ByteStrings support mmap?
00:49:24 * kzm coulda sworn..
00:49:51 <beelsebob> @type mmap
00:49:53 <lambdabot> Not in scope: `mmap'
00:49:57 <beelsebob> @hoogle mmap
00:49:57 <lambdabot> No matches found
00:50:42 <kzm> I know :-)
00:51:16 <kzm> @hoogle PS
00:51:17 <lambdabot> Text.PrettyPrint.HughesPJ.PStr :: String -> TextDetails
00:51:17 <lambdabot> GHC.Conc.pseq :: a -> b -> b
00:51:17 <lambdabot> Data.PackedString.appendPS :: PackedString -> PackedString -> PackedString
00:51:30 * kzm doesn't think ByteStrings are in hoogle yet.
01:03:21 <kzm> fps-0.4 docs refer to mmapFile, but I can't seem to find it.
01:04:23 <Itkovian> kzm: isn't fps at 0.7?
01:04:43 <kzm> Yep.  So it has been removed.
01:04:56 <wkh> i swear to god getting Hudak's code in his book is a pain in the ass
01:04:59 <kzm> (or I guess dons is at 0.8 or so)
01:05:23 <wkh> what does "Last generator in do {...} must be an expression" in Hugs mean?
01:05:33 <kzm> mmapFile went away on Apr 29, it seems.
01:06:18 <kzm> I'm having some serious performance issues here...but I suppose mmap wouldn't have helped.  Is the 6.5 GC more shaky than it used to be?
01:06:19 <dcoutts__> kzm: if we can do it portably we'll put it back in, that's the plan
01:06:40 <kzm> Is there much to gained?
01:06:43 <int-e> wkh: the last item can't be a binding (x <- y)
01:06:50 * tibbe thinks functional languages should come with a warning label
01:07:15 <Cale> wkh: that's often caused by layout problems
01:07:19 <dcoutts__> kzm, if you're using strict bytestring there is, for lazy you get much the same effect automatically as you'd get with mmap
01:07:20 <int-e> wkh: it must be a plain expression. like   return x   or  print "foo"
01:07:27 <wkh> layout? what layout? what are the layout rules for haskell
01:07:28 <dcoutts__> unless you're using random access
01:09:01 <kosmikus> wkh: in this case: all statements in a "do" construct must be indented equally
01:10:52 <wkh> already i don't like paul hudak
01:11:04 <edwardk> wkh: !?
01:12:23 <wkh> his unreasonable belief that (ugly, programmer) graphics and multimedia are inherently interesting and neat and better than making, say, compilers and interpreters (which is what i want to use haskell for) is as annoying as SICP's fetish for boring numerical examples
01:13:03 <kosmikus> wkh: then you're using the wrong book, maybe
01:13:10 <wkh> i think so.
01:13:19 <kosmikus> wkh: I like compilers and interpreters, and I liked the book by Bird very much.
01:13:27 <kzm> dcoutts__, I'm running some profiling atm.  I suspect the GC is really the culprit.
01:14:05 <dcoutts__> if it's doing a lot of GC it's usually because you're allocating & discarding a lot
01:14:31 <kosmikus> wkh: also, you could have a look at http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html ... I've hear positive things about it, although I never did it myself
01:14:34 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
01:14:54 <wkh> kosmikus: yes, i was going to read through that after i got sick of the book in my lap.
01:14:55 <wkh> thanks
01:16:11 <edwardk> wkh: are you talking about functional reactive programing and stuff? =)
01:16:29 <edwardk> wkh: i admit most (all?) of those examples do look like ass ;)
01:22:40 <kzm> dcoutts__ I am (alloc & discard).  Partly by concatenating lines minus whitespace.  I'll try to slice out whitespace, and storing it as an LPS instead (keeping the original).
01:24:21 <dcoutts__> kzm, if you've got an example that runs much slower than you expect and you think it might be a problem with fps then you can show it to me and dons
01:24:51 <dons> yep, definitely
01:25:25 <kzm> dcoutts__, the profiling is (STILL!) not finished, but the .hp file is currently at 120 seconds, while top shows 120 minutes.  So I'm fairly sure it's GC.
01:25:42 <dons> huh
01:25:59 <dons> so you might need to tune some things ... :)
01:26:13 <kzm> I'm probably copying around too much as well - I know there's at least one "filter" I can approximate with a slice...
01:26:53 <kzm> What's the recommended one-liner for dropSpaceEnd?
01:27:32 <dons> the old implementatoin of dropSpaceEnd from the src?
01:27:37 <kzm> (the old implementation was a bit nasty)
01:27:54 <dons> well it was fast :)
01:27:55 <kzm> unsafePerformIO $ withForeignPtr $ mumbo $ jumbo
01:28:26 <dons>     +dropSpaceEnd :: ByteString -> ByteString
01:28:26 <dons>     +dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
01:28:26 <dons>     +    i <- lastnonspace (p `plusPtr` s) (l-1)
01:28:26 <dons>     +    return $ if i == (-1) then empty else PS x s (i+1)
01:28:26 <dons>     +{-# INLINE dropSpaceEnd #-}
01:28:36 <kzm> I can probably just use span (not . isSpace) or something like that.
01:28:44 <kzm> Gesundheit!
01:28:53 <dons> its good to take a slice from the end of the string though
01:28:57 <dons> if its speed you need
01:29:08 <kzm> If it is fast, I'd vote to keep it in there.
01:29:22 <dons> we'll be adding triml and trimr in its place
01:29:30 <dons> or something like that
01:30:43 <kzm> Okay.
01:33:30 <kzm> May I suggest 'filter' be renamed to 'unsafeDontEvenThinkAboutItFilter'?
01:33:50 * kzm got a nice speedup from a small change.  :-)
01:33:55 <dons> its not that bad :)
01:33:59 <dcoutts__> what was that?
01:34:04 <wkh> do haskell people write long names the way smalltalk people do?
01:34:16 <dons> > let f x y = x + y in f 1 2
01:34:17 <lambdabot>  3
01:34:23 <dons> ^^ i thought we liked short names :)
01:34:36 <wkh> in smalltalk, you don't call a method 'readLines', you call it 'readEntireContentsOfFileAsArray'
01:34:46 <dons> hehe, including the type?
01:34:52 <dcoutts__> dons: didn't we have some cunning rules to make foo . reverse = fooEnd ?
01:35:02 <dons> we do, yes
01:35:12 <dons> let me see...
01:35:31 <dcoutts__> so dropSpaceEnd should be easy to implement outside of fps
01:35:40 <dons> ah no, not for the End case
01:35:44 <dcoutts__> span (something) . reverse
01:35:46 <dons> we do have,
01:35:47 <dons> {-# RULES
01:35:47 <dons>     "FPS specialise dropWhile isSpace -> dropSpace"
01:35:47 <dons>         dropWhile isSpace = dropSpace
01:35:47 <dons>   #-}
01:35:55 <dons> but didn't get around to the reverse case
01:35:59 <dcoutts__> ah ok
01:36:00 --- topic: set to 'FUCK ALL' by Teakwood
01:36:06 --- topic: set to 'YOU NIGGERS' by Teakwood
01:36:06 <dons> sigh
01:36:13 <kzm> wkh - long names are only used for inadvisable stuff.  Well - at least the ones starting with 'unsafe'
01:36:15 --- topic: set to 'FUCK ALL' by Teakwood
01:36:18 --- topic: set to 'YOU NIGGERS' by Teakwood
01:36:28 --- topic: set to 'FUCK ALL' by Teakwood
01:36:36 --- topic: set to 'YOU NIGGERS' by Teakwood
01:36:42 <beelsebob> kzm: 'unsafe' functions are not inadvisable
01:36:44 <wkh> um, anyone can set the topic?
01:36:46 <kzm> And a very good morning to you too, Teakwood.
01:36:48 --- mode: ChanServ set +o dons
01:36:50 --- topic: set to 'FUCK ALL' by Teakwood
01:36:51 --- topic: set to 'YOU NIGGERS' by Teakwood
01:36:57 --- mode: dons set +b *!*n=train@*.dhcp.stls.mo.charter.com
01:36:57 --- kick: Teakwood was kicked by dons (dons)
01:37:29 --- topic: set to 'Paul Hudak writes mediocre, poorly typeset books' by wkh
01:37:37 <wkh> >:/
01:37:39 <dons> ?topic #haskell []
01:37:40 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
01:37:53 <dons> ?topic-null #haskell
01:37:54 --- topic: set to '[]' by lambdabot
01:38:10 <wkh> haha, topic-cons
01:38:11 <dons> ?topic-cons Join us as we move forward toward the Age of the Lambda
01:38:11 <lambdabot> I do not know the channel Join
01:38:12 <beelsebob> @topic-cons Doom! There's no topic!
01:38:13 <lambdabot> I do not know the channel Doom!
01:38:13 <kzm> beelsebob, well - the name serves as a warning, at any rate.  I think it works nicely.
01:38:23 <dons> ?topic-cons #haskell Join us as we move forward toward the Age of the Lambda
01:38:23 --- topic: set to '["Join us as we move forward toward the Age of the Lambda"]' by lambdabot
01:38:26 <beelsebob> @topic-cons "Doom! There's no topic!"
01:38:27 <lambdabot> I do not know the channel "Doom!
01:38:30 <beelsebob> bah
01:38:32 <beelsebob> oh... I see
01:38:41 <beelsebob> @topic-cons #haskell Doom! There's no topic!
01:38:41 --- topic: set to '["Doom! There's no topic!","Join us as we move forward toward the Age of the Lambda"]' by lambdabot
01:38:47 <kalven> I hear chanmode +t is nice.
01:38:48 <dons> do we have to do this?
01:39:10 <dons> ?topic-tail #haskell
01:39:10 --- topic: set to '["Join us as we move forward toward the Age of the Lambda"]' by lambdabot
01:39:14 <beelsebob> kzm: yes, it serves as a warning, but not to "not use this" rather to "think before you use this
01:39:21 <kzm> Ok.
01:39:24 <dons> ?topic-snoc #haskell Logs: http://tunes.org/~nef/logs/haskell/
01:39:24 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/"]' by lambdabot
01:39:45 * kzm sighs. My profiling run has run for so long, I no longer remember which changes I've made subsequently.
01:39:47 <kzm> :-)
01:40:04 <beelsebob> @topic-snoc #haskell Haskell - The language of choice for discriminating hackers
01:40:04 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/","Haskell - The language of choice for discriminating hackers"]' by lambdabot
01:40:22 <beelsebob> rofl
01:40:42 <beelsebob> yay for tracers that make you forget what you were trying to fix in the first place
01:41:33 <wkh> what makes haskell the language of choice for discriminating hackers
01:41:43 <dons> check http://haskell.org
01:41:45 <lambdabot> Title: Haskell - HaskellWiki
01:41:49 <beelsebob> hehe
01:41:50 <kzm> Several ICFP announcemnts.
01:41:55 <kzm> It's official.
01:42:00 --- mode: ChanServ set -o dons
01:42:45 <kzm> Of course, they don't tell what kind of discrimination.
01:43:03 <wkh> what kind of discrimination do you think is implied
01:43:12 <beelsebob> by the evidence of the topic earlier discrimination against blacks :/
01:43:36 <beelsebob> I like to think discrimination against shit programming languages though
01:43:37 <wkh> there exist hackers who used nice languages like lisp and smalltalk but decided that c++ and java were far superior with respect to getting $$$
01:43:49 <kzm> I'm not quite convinced Teakwood was the typical Haskell hacker...
01:43:58 <beelsebob> no, somehow I think not
01:44:20 <wkh> i have a pre-conceived notion of haskell people as the propellerhead MIT wizard people
01:44:35 <kzm> I'm was seriously considering - just for a second - to push to use Java in a project instead of Python, due to post-project marketing value.  (My job runs out February)
01:44:48 <beelsebob> If my phone battery wasn't flat I would give you a photo of what a room full of "haskell people" look like
01:45:36 * drrho is away: cinema
01:47:32 <wkh> what in god's name is category theory and do i need to know it to do advanced stuff in haskell?
01:47:57 <beelsebob> wkh: no, but define "advanced stuff"
01:48:25 <wkh> do haskell wizard stuff, make the most of what the language has to offer, whatever that might be.
01:48:28 <beelsebob> are you thinking "I can't use monads if I don't know the underlying maths"
01:48:38 <kzm> BTW, dons & dcoutts__ - my fps mistake was (concat . filter p) - isn't this a fusion candidate?
01:48:43 <wkh> i'm wondering if that kind of thing is the case
01:48:51 <dons> you certainly don't need to know category theory to hack haskell, any more than you do for ML or Erlang :)
01:48:54 <beelsebob> wkh: well, it isn't
01:48:56 <beelsebob> but...
01:49:08 <beelsebob> I've not yet found an "advanced feature" I needed to use
01:49:16 <dons> kzm, concat's bad, and not fusible yet
01:49:26 <dons> beelsebob: fmap ?
01:49:35 <wkh> hudak's book talks about embedding domain-specific langugaes into haskell
01:49:43 <kzm> Okay.
01:49:50 <wkh> how do you do that when haskell doesn't have macros like lisp
01:49:58 <dons> higher order functions
01:50:23 <wkh> so it's not really syntactic extensions?
01:50:26 <dons> ?type let foreach = flip mapM_ in foreach [1..10] $ do print "yes" -- for example
01:50:28 <lambdabot>   Couldn't match `a -> m b' against `IO ()'
01:50:28 <lambdabot>    Expected type: a -> m b
01:50:40 <dons> ?type let foreach = flip mapM_ in foreach [1..10] $ \_ -> do print "yes" -- for example
01:50:41 <lambdabot> IO ()
01:50:54 <kzm> See?  Higher order functions give as interesting error messages as macros!
01:50:56 <kzm> QED
01:50:59 <int-e> @index forM
01:50:59 <kzm> :-)
01:51:00 <lambdabot> bzzt
01:51:08 <dons> you don't need to syntactically extend, when you can just define new syntax directly as functions
01:51:37 <wkh> you can define syntax as functions in haskell but not other languages?
01:51:50 <dons> its easier with laziness and good higher order functions
01:51:58 <dons> since control structures are just normal functions
01:52:20 <int-e> and haskell has many infix operators, which is another plus.
01:52:23 <dons> secondly, you have flexible operator syntax, so you can define ---<<>---- some wacky operator easily
01:52:56 <dons> that's the main 3 points: laziness, higher order functions, flexible lexical defn
01:53:22 <kzm> You could do that in lisp too, I think - but IMHO this is where the type system makes a difference.
01:53:32 <dons> yeah, you could do it in lisp
01:53:37 <dons> but you don't want to need a macro system
01:53:48 <dons> since you can just stay in the language and have it work anyway
01:53:55 <wkh> has Paul Graham used Haskell? :)
01:54:15 <kzm> Well - you need laziness too for control structures.
01:54:20 <gds> @google paul graham haskell
01:54:23 <lambdabot> http://www.paulgraham.com/accgen.html
01:54:23 <lambdabot> Title: Accumulator Generator
01:54:39 <kzm> Ah.  As a bad example, no doubt :-)
01:55:17 <dons> that's not very nice haskell, why'd he write it like that?
01:55:42 <wkh> i dunno, email him with an improved form
01:56:26 <tibbe> dons, what would be better?
01:56:36 <dons> wouldn't you just do it purely with closures?
01:56:46 <dons>             The problem: Write a function foo that takes a
01:56:47 <dons>             number n and returns a function that takes a
01:56:47 <dons>             number i, and returns n incremented by i.
01:57:36 <kzm> \n -> (+n)?
01:57:40 <int-e> (+)
01:57:48 <dons> exactly
01:58:07 <dons> so of course, being broken in the head, he used mutable variables... :)
01:58:25 <dcoutts__> doh!
01:58:29 <dons> whereas we'd write something like: (defun foo (n)
01:58:29 <dons>                                     (lambda (i) (incf n i)))
01:58:56 <dons> i.e. (+)
01:58:58 <int-e> because he wanted to call it several times
01:59:34 <dons> > let f n i = n + i in let g = f 7 in (g 1 , g 2 , g 3, g 4)
01:59:35 <lambdabot>  (8,9,10,11)
01:59:37 <therp> dons: he wants to use mutable variables
01:59:52 <kzm> How about \n -> (\i -> (i+n,\i' -> i+n+i')
01:59:53 <therp> dons: I misunderstood the exersice myself reading it for the first time
02:00:01 <int-e> he wants that to return 8, 10, 13, 17.
02:00:03 <kzm> (or State)
02:00:11 <int-e> sort of
02:00:12 <dons> oh, it requires mutable variables?
02:00:17 <dons> that's what he means by "that's incremented by, not plus" ?
02:00:29 <therp> dons: yes, reading the CL code and the other stuff that's intended..
02:00:44 <therp> dons: the task description is a bit ambigious
02:00:49 <dons> meaningless then, since you _just wouldn't do it like that_
02:00:50 <bringert> credits: ... Haskell, Malcolm Wallace and Tom Pledger
02:00:50 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
02:01:29 <gds> "Please don't send may any new submissions for the time being; I don't have time to look at them.":(
02:01:47 <wkh> he's too busy not working on Arc
02:01:50 <gds> No date on the page, of course...
02:02:08 * therp isn't sure if he will like arc.
02:02:18 <gds> http://www.paulgraham.com/icad.html : May 2002
02:02:20 <lambdabot> Title: Revenge of the Nerds
02:02:20 <bringert> many of the examples on that page are broken
02:02:27 <gds> That's the original challenge, I think...
02:02:33 <dons> ?type let f = (+) ; g = f 7 in g -- I think would be the canonical haskell soln
02:02:35 <lambdabot> forall a. (Num a) => a -> a
02:04:01 <bringert> hmm, maybe not
02:04:07 <bringert> weird spec
02:04:24 <int-e> ?type let f n = get >>= put . (n+) in f
02:04:26 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => s -> m ()
02:04:39 <dons> yeah, that'd be better.
02:04:43 <int-e> ?type let f n = get >>= put . (n+) in f >> get
02:04:44 <lambdabot> forall s (m :: * -> *) s1. (MonadState s1 ((->) s), MonadState s m, Num s) => s -> s1
02:05:05 <dons> but that's just using closures anyway :)
02:05:34 <int-e> I know. IORefs are just too much effort for the purpose.
02:09:36 <falconair> can someone help me understand the 'unfold' function? as i understand it, the fold function can be thought of as a function which replaces the 'cons' constructor of a list with some operation, thereby reducing the list to a single value (and map/filter can be implemented on top of fold by replacing the cons with another cons)....
02:09:45 <falconair> as I understand the unfold function does the opposite, it takes a 'seed' and cons it together with the value of some operation...but how can such a list be created out of nothing in haskell...isn't that against referential integrity?
02:10:11 <dons> no :)
02:10:13 <dons> ?type unfoldr
02:10:15 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:10:23 <wkh> why does haskell have to have so much syntax
02:10:29 <dons> > unfoldr (\c -> Just c) 1
02:10:30 <lambdabot>    Occurs check: cannot construct the infinite type: b = (a, b)
02:10:30 <beelsebob> falconair: suppose you did foldr (*) 1 xs
02:10:30 <lambdabot>    Expec...
02:10:39 <beelsebob> you could unfold it by sequentially dividing
02:10:47 <dcoutts__> wkh: because people get tired looking at lisp code :-)
02:10:47 <dons> > unfoldr (\c -> Just (c,c+1)) 1
02:10:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:10:59 <int-e> > let f 0 = Nothing; f n = Just ((), (n-1)) in unfoldr f 5
02:11:00 <lambdabot>  [(),(),(),(),()]
02:11:11 <wkh>  > 2+3
02:11:14 <wkh> > 2+3
02:11:15 <lambdabot>  5
02:11:18 <wkh> woot.
02:11:26 <int-e> > let f 0 = []; f n = () : f (n-1) in f 5
02:11:28 <lambdabot>  [(),(),(),(),()]
02:11:28 <dons> welcome to haskell
02:12:24 <int-e> falconair: these two are equivalent; the unfoldr interprets Nothing as [] and Just (a,b) as a : <recursive call to list creator with argument b>
02:12:57 <dons> > unfoldr (\n -> if n == 5 then Nothing else Just ((), n+1)) 0
02:12:58 <lambdabot>  [(),(),(),(),()]
02:13:06 <beelsebob> > let life = 5; universe = 5; and (a,b) c = a + b + c; everything = 32 in (life, universe) `and` everything
02:13:07 <lambdabot>  42
02:13:26 <int-e> > let x = x where x = 42 in x
02:13:28 <lambdabot>  42
02:13:36 <beelsebob> hehe
02:14:27 <falconair> ok, i found the unfoldr function in GHC's source...looks simple enough, I guess I need to understand how a function can keep returning a cons and incrementally build up a list...need to sit with paper and a pencil i think :)
02:14:46 <dons> yeah, that's a good idea
02:14:49 <beelsebob> falconair: I suggest using hat-anim
02:14:58 <beelsebob> it saves a lot of the mundane work of doing such a thing
02:15:04 <Cale> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
02:15:05 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
02:15:06 <falconair> what's hat-anim?
02:15:15 <beelsebob> falconair: it's one of the hat tools
02:15:17 <beelsebob> @where hat
02:15:18 <lambdabot> http://haskell.org/hat
02:15:30 <wkh> woha.
02:15:32 <wkh> woah.
02:15:33 <Cale> > fix ((0:) . scanl (+) 1)
02:15:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
02:15:43 <wkh> woah.
02:16:15 <beelsebob> > let fibs x y = x:(fibs y (x+y)) in fibs 1 1
02:16:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:16:31 <wkh> that's some good motivation to learn more, i think
02:16:46 <wkh> "you had me at ((0:) . scanl (+) 1)"
02:16:50 <Cale> heh
02:17:02 <beelsebob> @type scanl
02:17:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
02:17:04 <Kahdloc> the scanl one looks nicer.
02:17:06 <dons> have a look at yaht, if you're learning.
02:17:12 <dons> ?where yaht <-- wkh
02:17:12 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
02:17:20 <falconair> what i'd really like to know is if something like an MVar can be made a tail to a list, 'hook up' the MVar to an external feed such as stock prices, as new data comes in, an unfold function 'adds' it to the list, while a fold function at the other end of the list consumes it (real-time database?)
02:17:28 <wkh> dons: ok
02:17:43 <dons> falconair: sounds like a Chan
02:18:00 <dons> ?docs Control.Concurrent.Chan
02:18:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
02:18:15 <falconair> beelsebob, hat looks interesting, i'll try it, thanks
02:18:22 <beelsebob> np
02:18:29 <beelsebob> just ask if you have any problems
02:19:41 <falconair> dons: Control.Concurrent.Chan describes itself as unbounded channels...might actually be what i wanted, cool, thanks
02:20:16 <wkh> haskell was designed by committee? and it doesn't suck?!
02:20:29 <dons> falconair: it's what I use when I want to pipe some external source into a haskell program concurrently, as a list
02:20:54 <dblhelix> wkh: yes, it was; and, indeed, it doesn't :)
02:21:29 <beelsebob> well, that's debatable, a lot of people would say it falls far short of what is needed
02:21:36 <beelsebob> I am not one of these people, but hey
02:21:43 <wkh> who says it falls short?
02:21:48 <wkh> and what do they propose instead
02:21:53 <Cale> > fix (("a":) . scanl (\x y -> concat ["(f ", x, " ", y, ")"]) "b")
02:21:54 <lambdabot>  ["a","b","(f b a)","(f (f b a) b)","(f (f (f b a) b) (f b a))","(f (f (f (f ...
02:21:54 <beelsebob> anyone who uses the extensions
02:22:03 <beelsebob> (which is a lot of people)
02:22:15 <beelsebob> I've met very few people who actually use Haskell 98
02:22:47 <dblhelix> beelsebob, wkh: at least, haskell 98 provides a firm ground to implement extensions and experiment with those
02:22:55 <beelsebob> true this
02:22:56 <wkh> "extensions" are like, template haskell?
02:23:02 <int-e> multiparameter type classes are used by the monad transformer library which is essential for any nontrivial program to work (I think)
02:23:14 <beelsebob> wkh: extensions like MPTCs, UTs, FDs...
02:23:20 <wkh> buh?
02:23:21 <dblhelix> wkh: multiparam classes, fds, gadts, rank-n, etc.
02:23:22 <dons> wkh, beelsebob's making a distinction between haskell98, the last standard language revision, and haskell+exts, which is what we use day to day (and is to become Haskell')
02:23:24 <wkh> ok
02:23:37 <int-e> so that's one widely used extensions. functional dependencies make mptcs more usable.
02:23:37 <wkh> i hav eno idea what the hell that stuff is
02:23:41 <int-e> so that's another.
02:23:45 <beelsebob> dons: I really don't agree with you - I use Haskell 98 every day
02:23:57 <dons> i know. you and ndm :) it's a conspiracy!
02:24:06 <int-e> wkh: don't worry about it then.
02:24:15 <beelsebob> I get really irritated when people use extensions and somehow expect that all the tools should magically work with non-standart stuff
02:24:18 <wkh> rank as in linear algebra?
02:24:22 <beelsebob> it's like using internet explorer :P
02:24:29 * dblhelix hasn't yet used glasgow extensions today
02:24:30 <int-e> wkh: they'll get to you sooner or later.
02:24:35 <Cale> wkh: Well, the easiest of those to understand would probably be multiparameter typeclasses. If you know what typeclasses are, it's just those, but you're allowed to have the functions depend on the type of more than one thing.
02:25:06 <beelsebob> Cale: the easiest to understand, but one of the most contraversial
02:25:13 <Cale> beelsebob: hm?
02:25:21 <dons> beelsebob: you don't even use hier libs?
02:25:22 * mux is eager to get better records in Haskell
02:25:24 <Cale> I don't think MPTCs are controversial at all
02:25:28 <dblhelix> wkh: rank-n as in functions taking polymorphically typed arguments
02:25:28 <beelsebob> well... how do you choose to implement the choice of which function to use
02:25:32 <beelsebob> do you use FDs?
02:25:34 <Cale> It's functional dependencies which are.
02:25:37 <beelsebob> do you use ATs?
02:25:42 <mux> non-strict and possibly also records that don't spam namespace
02:25:49 <beelsebob> Cale: MPTCs *rely* on having something like FDs
02:25:55 <int-e> FDs are implemented in ghc. so what do you think people use?
02:26:11 <Cale> I don't think they do. There are plenty of perfectly good MPTCs without FDs
02:26:26 <Cale> Look at the array library
02:26:35 <beelsebob> Cale: how do you decide what function to call
02:26:41 <dblhelix> the mtl, for instance
02:26:47 <Cale> by ensuring that all the types are determined
02:26:51 <beelsebob> int-e: yes, but which one do you think is going to end up in Haskell'
02:26:58 <int-e> the array library is more useful when restricted to a few array types depending on the monad, using fds.
02:27:00 <int-e> imho
02:27:22 <Cale> But it's not unusable without.
02:27:41 <int-e> beelsebob: I don't really know how assoiciated types in haskell would look like.
02:27:43 <Cale> beelsebob: I don't even think ATs are allowed to get into Haskell'
02:27:44 <beelsebob> it's not unusable certainly... but it's not very useful at all
02:27:49 <Cale> why?
02:27:53 <Cale> not useful?
02:28:06 <dons> they may get in. there's no decision yet.
02:28:17 <beelsebob> Cale: there's currently a *very* large discussion over whether MPTCs should be allowed in, and if so whether to add FDs or ATs
02:28:26 <Cale> beelsebob: The current array libraries aren't useful?
02:28:39 <Cale> IArray is certainly useful.
02:28:41 <beelsebob> Cale: I've not looked at them, I couldn't comment
02:28:48 <dons> really, more experience with ATs are needed before a decision can be made
02:28:53 <Cale> They're fine
02:28:57 <mux> what are ATs?
02:29:04 <Cale> mux: associated types
02:29:20 <Cale> (specifically, class-associated types)
02:29:22 <mux> mmm, I'll go document on that on the haskell' wiki
02:29:22 <wkh> where do you guys learn this stuff?
02:29:24 <int-e> Cale: MonadState is something that couldn't work without FDs
02:29:25 <ThreeQ> > fix (([1]:) . scanl (++) [0])
02:29:26 <lambdabot>  [[1],[0],[0,1],[0,1,0],[0,1,0,0,1],[0,1,0,0,1,0,1,0],[0,1,0,0,1,0,1,0,0,1,0,...
02:29:28 <Philippa_> Cale: lack of an implementation in common use seems a good reason to rule it out given the intentions of haskell'
02:29:30 <beelsebob> wkh: here
02:29:35 <Cale> Philippa_: right
02:29:40 <dons> wkh, http://haskell.org
02:29:41 <Cale> int-e: I agree
02:29:41 <lambdabot> Title: Haskell - HaskellWiki
02:29:58 <Cale> int-e: But I don't agree with the claim that multiparameter typeclasses are useless without fundeps.
02:30:04 <dons> that's a nice little function, ThreeQ
02:30:14 <int-e> Cale: I wouldn't go that far. I don't think I said that.
02:30:14 <Philippa_> I wouldn't say useless, I think crippled would be a fair complaint though
02:30:21 <Cale> int-e: beelsebob did
02:30:29 <dons> perhaps, "limited"
02:30:35 <beelsebob> Cale: if I did, I think I was misinterpretted
02:30:54 <beelsebob> I was attempting to say that you rule out a very large proportion of uses for MPTCs
02:31:05 <beelsebob> not that they are totally useless without FDs or ATs
02:31:11 <Cale> Well, at least from the current libraries.
02:31:31 <mux> http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
02:31:34 <lambdabot> Title: AssociatedTypes - Haskell Prime - Trac, http://tinyurl.com/fnvly
02:31:35 <Cale> Usually the lack of MPTCs just makes things more awkward to use rather than impossible to use.
02:31:47 <gds> wkh: I lurk in here in order to try to "learn this stuff" ;)
02:31:50 <int-e> > concatMap show . concat $ fix (([1]:) . scanl (++) [0])
02:31:51 <lambdabot>  "100101001001010010100100101001001010010100100101001010010010100100101001010...
02:31:53 <fasta> How can I express if foo then return Bar and else do nothing (continue execution) ?
02:32:32 <int-e> you can't really.   if foo then return Bar else do <all the rest>
02:32:41 <fasta> I don't want to nest the code for nothing, since it makes it more complex.
02:33:16 <edwinb> @type Monad.when
02:33:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:33:22 <edwinb> that might help...
02:33:28 <fasta> I already thought so, well then I will just have to invent arbitrary names.
02:33:31 <int-e> there is no nonlocal return in monads. there can't be, really, because inlining in Haskell is always safe (disregarding unsafe stuff)
02:33:36 <int-e> err
02:33:42 <int-e> return.
02:33:44 <fasta> edwinb: Return type is different
02:33:51 <int-e> return with function scope.
02:33:52 <edwinb> curses!
02:34:42 * beelsebob pokes edwinb from across the room
02:34:45 <fasta> Doesn't the continuation monad help here?
02:34:56 * edwinb reads over beelsebob's shoulder
02:35:01 <edwinb> I should listen to the talk ;)
02:35:04 <Cale> fasta: you could use something like an Error transformed IO
02:35:16 <Cale> fasta: I suppose
02:35:27 <fasta> Cale: I suppose I don't understand
02:35:41 <int-e> I suspect the continuation monad will add more obscurity rather than improve readability.
02:36:06 <beelsebob> edwinb: I can't say I'm impressed with the current one
02:36:14 <Cale> You could do something like
02:36:30 <int-e> fasta: how about f = g where g = do ... if foo then return () else g2; g2 = do ...
02:36:47 <int-e> fasta: that avoids the nesting problem by dividing the stuff you do into phases.
02:36:58 <Cale> yeah, something like that :)
02:37:09 <Cale> Or using let
02:37:34 <fasta> That's introducing arbitrary names, which I also pointed out as a solution.
02:37:41 <Cale> Usually I just nest.
02:37:48 <Cale> If that even comes up
02:38:45 * fasta supposes 80 characters is too little 
02:39:01 <Cale> Somehow it's become a little odd to me to want to halt the computation early and return something from the middle of it :)
02:39:12 <Cale> What's being returned?
02:39:18 <Cale> Is it an error condition?
02:39:19 <int-e> yes, Either would make a neat monad for that purpose if it wasn't for that Error e requirement.
02:39:32 <beelsebob> > let what x = happens x; happens x = whatx
02:39:32 <lambdabot>  Parse error
02:39:34 <beelsebob> bah
02:39:43 <beelsebob> > let what x = happens x; happens x = what x in what x -- if I do this
02:39:44 <lambdabot>  Not in scope: `x'
02:39:52 <beelsebob> > let what x = happens x; happens x = what x in what 5 -- if I do this
02:39:53 <lambdabot>  Add a type signature
02:39:59 <Cale> int-e: You can just write the monad instance yourself too :)
02:40:01 <tibbe> dons, alright so I'm lagging a little, about Graham's accumelator, he required update not additon in the problem statement, he didn't motivate it though
02:40:10 <beelsebob> > let what :: Int -> Int; what x = happens x; happens x = what x in what 5 -- if I do this
02:40:12 <int-e> Cale: I should.
02:40:14 <lambdabot> Terminated
02:40:18 <beelsebob> ah, I see
02:40:38 <mux> for others who wonder what ATs are, this paper is nice : http://www.cse.unsw.edu.au/~chak/papers/assoc.ps.gz
02:40:49 <fasta> Cale: I want to implement an early out.
02:41:04 <mux> this is really nice
02:41:06 <Cale> fasta: is this the IO monad?
02:41:10 <fasta> Cale: no
02:41:13 <tibbe> dons, I saw the rest of your comments, n/m
02:41:14 <Cale> which monad?
02:41:20 <fasta> Cale: state
02:41:21 <mux> so if I get it correctly, with ATs we wouldn't need the separate IntMap type
02:41:23 <Cale> okay
02:41:45 <mux> since we could define specialized algorithms for Map when keys are Int's
02:41:54 <beelsebob> yep
02:41:54 <mux> specially optimized, even
02:41:59 <Cale> mux: yeah. We should already be able to do without it in GHC but the solution would be messier and lower-level
02:42:12 * mux goes back finishing reading the paper
02:42:17 <beelsebob> and to do with GHC rather than haskell
02:42:28 <beelsebob> remember that ghc is not the only compiler out there
02:43:09 <Cale> fasta: I *suppose* you could construct something with the Continuation monad transformer if you really wanted to
02:48:31 <lokadin> wow you know today i have truly noticed the true power of haskell
02:50:04 <lokadin> but yea, i'm really impressed and happy that i wasn't just wasting my time and yours
02:50:12 <lokadin> kk well i g2g to sleep
02:50:14 <lokadin> so cya
02:50:15 <lokadin> fe'o
02:50:18 <lokadin> (over and out)
02:53:23 <ThreeQ> > map ($ 1) $ fix (((*2):) . scanl (.) (+1))
02:53:24 <lambdabot>  [2,2,3,5,9,25,89,857,23385,7035737,49046838105,120873073139997529,1767098574...
02:53:52 <ThreeQ> I have no idea what I'm doing, but it sure looks cool!
02:54:00 <beelsebob> rofl
02:56:31 * mux learns about Clean and sees it looks a *lot* like Haskell
02:56:42 <mux> does Clean have monads? can't see them listed in the features page
02:56:55 <xs> why does it need them? it has uniqueness types
02:57:01 <beelsebob> if it has type classes it has monads
02:57:02 <Cale> It doesn't use monads for IO, but you could certainly use them
02:57:10 <Cale> xs: Monads aren't just for IO
02:57:44 <norpan> monads is not inherent in haskell apart from some syntactic sugar either
02:57:49 <xs> Cale, true.
02:57:50 <mux> ok
02:57:50 <norpan> you can easily do monads in clean if you like
02:58:10 <beelsebob> all you need is a class containing bind and return
02:58:23 <mux> Clean seem to outperform Haskell in a wide range of cases performance-wise
02:58:34 <sieni> probably you can easily implement an io monad on top of the uniqueness types thingie in clean
02:58:47 <beelsebob> is your source for that by any chance clean's web page?
02:59:18 <Philippa_> mux: monads aren't a language feature, they're a consequence of having sufficient other features
02:59:20 <fasta> The largest difference between Clean and Haskell are non-technical from my POV.
02:59:41 <sieni> beelsebob: or maybe the shootout page?
02:59:44 <Philippa_> beelsebob: it's also fairly clearly true. It lets you implement the world-passing model of IO
02:59:57 <Philippa_> (and safely)
03:00:00 <beelsebob> I didn't say it wasn't true - I was just querying the source
03:00:23 <sieni> http://www.bcs.org/server.php?show=ConWebDoc.5231
03:01:15 <mux> Philippa_: yes, I was only considering the availability of Monads in the base libraries
03:01:55 <beelsebob> mux: it's not hard to implement monads
03:02:01 <mux> beelsebob: yes, I said that based on benchmarks I saw on the shootout benchmark page
03:02:08 <ThreeQ> > map ($ 0) $ fix ((pred:) . scanl (.) succ)
03:02:08 <mux> beelsebob: I know, didn't say they were
03:02:10 <lambdabot>  Exception: stack overflow
03:02:13 <ThreeQ> damn
03:02:42 <sieni> I recall dons having an opinion of the benchmarks, maybe a library issue in ghc or something?
03:02:47 <mux> the shootout page seems down now
03:03:11 <mux> I'd be pleased to hear that these results are unjustified
03:05:17 <sieni> Maybe something like fast packed strings library not in the ghc installation (http://www.cse.unsw.edu.au/~dons/fps.html), so it can't be used in the benchmarks or something
03:06:02 <ThreeQ> > take 25 $ map ($ 0) $ fix ((pred:) . scanl (.) succ)
03:06:03 <lambdabot>  [-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1...
03:06:07 <mux> maybe yes - but that would only be relevant if Clean, on the other side, has such packed strings in its standard libs
03:06:38 <dons> yeah, Clean has nice fast packed IO, I think
03:06:49 <dons> which we're missing (well, not anymore ...)
03:06:51 <mux> so that would explain some of the speed differences, good to know
03:07:13 <dons> yep, i expect things to really pick up once ghc 6.6  is on the shootout box
03:07:16 <Cale> > map ($ 0) $ fix ((id:) . scanl (.) succ)
03:07:18 <lambdabot>  Exception: stack overflow
03:07:20 <mux> dons: so FPS is in 6.5.x which is development versions and will be in 6.6?
03:07:23 <dons> maybe we can take the lead back again
03:07:26 <mux> cool
03:07:28 <dons> mux, yup
03:07:29 <Cale> > take 25 $ map ($ 0) $ fix ((id:) . scanl (.) succ)
03:07:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:07:31 <mux> very pleased to hear that :-)
03:07:49 <dons> you can try out the 6.6 release candidate now
03:07:57 <ThreeQ> Cale: but mine is so much slower!
03:08:09 <mux> dons: does it boast other runtime performance improvements?
03:08:25 <dons> yeah, there are other improvements
03:08:30 <mux> yummy
03:08:45 <mux> @karma+ dons -- the strings master
03:08:45 <lambdabot> dons's karma raised to 55.
03:09:45 <beelsebob> @index fix
03:09:46 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
03:09:59 <sieni> does darcs ignore http_proxy environment variable?
03:10:42 <eivuokko> sieni, darcs uses libcurl (or external tool), so depends on that.
03:10:59 <sieni> oh, it works, it was just so damn slow ;-)
03:11:44 <beelsebob> @type fix
03:11:45 <lambdabot> forall a. (a -> a) -> a
03:11:52 <beelsebob> @hoogle fix
03:11:52 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
03:11:53 <lambdabot> Control.Monad.Fix :: module
03:11:53 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
03:14:10 <lokadin> how do i see if a certain String exists in a list of [String]
03:14:18 <beelsebob> wow, that fixed point version creates a *nasty* computation
03:14:52 <Cale> lokadin: elem
03:14:57 <lokadin> thanks :)
03:18:16 <beelsebob> doom... http://www.cs.kent.ac.uk/people/rpg/tatd2/FibWeird.pdf
03:18:59 <fasta> Is darcs being maintained anyway? I had encountered a bug, but that was already in the tracking system for 7 months.
03:19:20 <kzm> Hmm..no hPut* in Lazy bs?
03:20:17 <dons> hmm should be
03:20:30 <dons>         hPut,                   -- :: Handle -> ByteString -> IO ()
03:20:58 <dons> no         hPutStr,                -- :: Handle -> ByteString -> IO ()
03:20:58 <dons>         hPutStrLn,              -- :: Handle -> ByteString -> IO ()
03:20:59 <dons> though
03:21:01 <kzm> Ah.
03:21:26 <dons> hPutStr = hPut
03:22:06 <kzm> Okay.  I'm using 0.7 from a 6.5 snapshot, so some rough edges are to be expected, I guess :-9
03:24:02 <edwardk> dumb question, what is the a@b notation called again?
03:24:57 <kzm> What does hGet do?  hGetLine or hGetContents?
03:25:20 <beelsebob> gets data from a handle
03:25:21 <edwardk> i.e. let a@(x,y) = b in ...?
03:25:24 <dons> as patterns
03:25:29 <edwardk> k
03:25:30 <xs> labels?
03:25:38 <int-e> kzm: hGet takes an Int argument which I suppose is the length
03:25:55 <dons> like hGetbuf
03:26:00 <kzm> Ah, of course.  Missed that.
03:26:04 <edwardk> looking for a fancy shmancy term for them coz they are my only way to do contraction in my calculus ;)
03:26:33 <kzm> But no hGetLine.  Guess I can use hGetLine from regular BS, and wrap it with LPS []
03:26:39 <dons> yeah, there's hGetLine
03:26:45 <dons> oh, .Lazy ?
03:27:13 <dons> no, seems like .Lazy is missing some IO stuff, only the basics there :)
03:28:43 <kzm> Right.  Ideally, it would be a drop-in replacement before 6.6 ships.
03:32:16 <edwardk> Anyone know how to get an upside down & in latex? =)
03:33:01 <edwardk> ? if that pasted
03:34:08 <edwardk> found it
03:34:22 <Cale> edwardk: http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf may be useful, if you don't have it already :)
03:35:17 <kzm> dons: there's no simple way to work with 6.5 and darcs fps?  I must replace base?  (Otherwise, I'd rather add the missing stuff to Lazy, than roll my own outside it)
03:39:10 <Cale> edwardk: \invamp, right?
03:41:06 <fasta> I have a current state in the State monad, and I have a stateful computation. I would like to do that stateful computation with different inputs while all using that current state. Should I just use runState for that?
03:41:11 <edwardk> cale: using bindnasrempa
03:42:43 <dons> fps and ghc 6.5 should be identical. what ghc are you using?
03:42:51 <dons> an older one?
03:43:08 <edwardk> Ok. hrmm. since its actually faster in the underlying code i'm using data and case rather than all of the crufty traditional linear logic connectives. does anyone think that will make a lambda calculus hard to read?
03:43:46 <edwardk> The only reason I could think to to have tradition \otimes, \oplus and par and with connectives is er.. tradition.
03:43:57 <edwardk> er traditional
03:44:22 <edwardk> the end result should be fairly familiar to haskellites
03:44:51 <edwardk> data Foo = Bar | Baz Int; case f of Bar -> ... ; Baz a -> ...
03:44:54 <tuomov> ~/src/GSLHaskell$ runhaskell Setup.hs configure --prefix=$HOME/opt
03:44:54 <tuomov> *** Exception: Line 34: Unknown field 'ghc-prof-options'
03:45:03 <tuomov> What could be causing that?
03:45:15 <int-e> too old cabal version
03:45:38 <tuomov> ghc642 is the latest available on fc4
03:46:18 <edwardk> with contraction noted case f of f'@f'' -> ...; weakening case f of _ -> ...; tensor as case f of (a,b) -> ... or case f of Tensor a b -> ... even...
03:46:43 <edwardk> and the only change being that terms are by default linear, unless they are annotated as not being so (and thereby allowing contraction/weakening
03:47:09 <tuomov> hmm.. installing ghc642 did not change the links from older ghc64... stupid fc
03:48:15 <dolio> f'@f'' meaning binding to multiple symbols?
03:48:20 <Cale> edwardk: Hey, cool, another way to get it would be with the graphicx package: \rotatebox[origin=c]{180}{\&}
03:48:38 <edwardk> dolio: yeah. by the way its written here case actually consumes its argument.
03:48:51 <edwardk> at least if its linear
03:49:00 <dolio> Yeah, okay.
03:49:33 <dons> hey tuomov
03:49:54 <edwardk> i may allow the variable to live on in its case branches if its relevant/unrestricted but its strictly unnecesary coz i can use case f of f'@f'' to split it before hand or during the rest of the cases. thoguh all cases will just desugar to simple cases.
03:50:12 <edwardk> cale: neat =)
03:50:21 <edwardk> cale: useful if i have to turn something else on its head
03:50:29 <Cale> yeah
03:50:42 <edwardk> should have used that on \ddots.
03:50:57 <Cale> yeah, you could really get the angle right then :)
03:50:59 <edwardk> rather than construct the crufty ascending sequence =)
03:51:56 <edwardk> so do you think the data/case thing is too weird for a core-style intermediate language?
03:52:20 <int-e> you could adapt the tex definition: \def\ddots{\mathinner{\mkern1mu\raise7\p@\vbox{\kern7\p@\hbox{.}}\mkern2mu\raise4\p@\hbox{.}\mkern2mu\raise\p@\hbox{.}\mkern1mu}}
03:52:22 * int-e grins
03:52:35 <edwardk> i seemed to recall core having a similar built in pattern matcher, so it seemed to not be too far from practice.
03:53:37 <edwardk> case forces its target into WHNF, etc.
03:53:42 * beelsebob wonders if chris forgot the point of his talk
03:54:11 <tuomov> dons: hi
03:54:11 <Philippa_> case is potentially important for core-level optimisations, as well
03:54:15 <edwardk> or in the case of autolifted values or strict ones just uses their contents. since its know via the type system if it has to look inside.
03:54:36 <edwardk> k. then its settled, down with the crufty linear logic connectives.
03:55:09 <edwinb> beelsebob: oh?
03:55:22 <edwardk> up with data, case and er... 'Not' to flip between values and continuations.
03:55:46 <beelsebob> edwinb: I was expecting him to give a lot more detail about how he's implementing the slicing, and type-reliant-refactorings
03:56:08 <edwinb> aha...
03:56:17 <edwinb> the refactoring stuff looks impressive
03:56:35 <edwardk> phillipa: i just didn't want to implement a fairly useless intermediate lang, this way i can package as many values up into a term as needed
03:56:53 <beelsebob> yeh, it's coming across more as an advert than as an actual implementation of functional languages talk though
03:56:54 <beelsebob> oh well :?
03:56:57 <beelsebob> it's fun stuff
03:56:58 <beelsebob> :)
03:58:47 <edwinb> at least he hasn't managed to paste a quote from the easyjet website into his demo ;)
03:59:00 <beelsebob> hehe
03:59:26 <beelsebob> look at it this way... it could have been a quote from some porn :P
03:59:42 <edwinb> no it couldn't.
03:59:42 <edwinb> :)
03:59:44 <beelsebob> haha
04:00:05 <beelsebob> you never know what I could have done with your mac :P
04:00:44 * edwinb will remember that for next time
04:01:12 * beelsebob notes to check the paste buffer before his talk
04:01:14 <edwardk> ok, notational ugliness time. i am debating about whether i should go with 'pretypes' or a bunch of comonads, the latter gives a nice theory, the former might be easier parameterize over
04:02:03 <edwardk> in clean you can make a type either uniqueness or normal. if its unique it has a * decorating the type before it (you can show this * is a comonad actually)
04:03:08 <edwardk> they let you abstract over whetehr the type is unique by saying foo :: u:Bar -> u:Baz  to make a function that takes either unique bars and generates a unique Baz or takes Bars that have been contracted/weakened and return 'weak' Bazs.
04:03:36 <edwardk> not sure i have a generic way to say this if i use the comonad approach
04:04:48 <edwardk> coz * is a comonad, and linear logic's ! is also one, they compose as *! where you can strip the ! to get a linear unique type which is equivalent to a linear type, or strip the * to start allowing copying
04:05:06 <tibbe> what's an (list) anamorphism
04:05:07 <tibbe> ?
04:05:14 <tibbe> s/an/a
04:05:16 <edwardk> not sure if using the haskell style way of indicating a monad or comonad makes sense. in this context
04:05:26 <edwardk> tibbe: it builds a list out of more or less nothing.
04:06:00 <edwardk> goes in the opposite direction of a catamorphism that walks down the list, it walks up.
04:06:25 <tibbe> what's a catamorphism? don't say it's the opposite to anamorphism ;)
04:07:07 <tibbe> so a function that builds a list from a seed is an anamorphism?
04:07:32 <dolio> foldr is a list catamorphism.
04:07:45 <tibbe> dolio, ok
04:08:00 <Cale> tibbe: the terms don't just apply to lists
04:08:02 <edwardk> http://citeseer.ist.psu.edu/meijer91functional.html
04:08:24 <edwardk> they are general terms that apply to all tree like structures
04:08:43 <tibbe> so they create or destruct such structures?
04:08:47 <edwardk> that paper is where the term was introduced
04:09:31 <edwardk> map, length, filter, all sorts of things are catamorphisms.
04:09:36 <Baughn> An anamorphism would presumably create a tree that contains no more information than the original seed?
04:10:12 <edwardk> baughn: while a catamorphism creates something that has no more information than the original tree.
04:10:23 <edwardk> baughn: yeah
04:10:34 <tibbe> I've printed the paper
04:10:36 <Cale> edwardk: though really foldr is "the" list catamorphism
04:10:36 <Baughn> edwardk: I think we can assume that catamorphisms usually remove information
04:10:39 * tibbe runs to the printer
04:10:45 <edwardk> cale: sure
04:11:09 <edwardk> baughn: well, you can have an identity catamorphism or anamorphism (which is in that case both)
04:11:21 <edwardk> or one that transforms in a reversible manner
04:12:37 <edwardk> tibbe: meijer's thesis is also a good reference for this sort of thing, but its more focused on using them to calculate compilers.
04:12:51 <Baughn> Can an anamorphism create something with /less/ information than the seed?
04:12:54 <edwardk> tibbe: and it includes this paper almost verbatim as a chapter.
04:13:10 <edwardk> baughn: sure. why not. i can make one that just returns a constant value or something
04:13:31 <Baughn> edwardk: In that case the cat/ana-morphism distinctions seems a bit artificial
04:14:19 <edwardk> they are a restriction on how you will use or construct the data/codata.
04:14:55 <edwardk> catamorphism tears down starting from the leaves, anamorphism builds down towards the leaves.
04:16:04 <edwardk> catamorphisms may run forever on codata trying to reach the tree leaves to start deconstructing, anamorphisms will always return you something you can start to use lazily right away
04:16:36 <Cale> hm?
04:16:46 <Cale> I suppose so
04:17:12 <edwardk> CHARITY draws this distinction in how it uses them and between data/codata if you haven't see it its informative.
04:18:04 <Cale> Are you ignoring laziness there?
04:18:27 <Cale> foldr gives something you can work with immediately under normal circumstances
04:18:43 <Baughn> That's because finding the first leaf of a list is a rather trivial operation
04:18:50 <Cale> > take 10 $ foldr (:) [] [1..]
04:18:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:19:46 <Cale> hmm
04:20:28 <Cale> data Tree a = Leaf a | Branch (Tree a) (Tree a)
04:20:48 <Cale> foldTree l b (Leaf x) = l x
04:20:58 <waern> does anyone know why make clean in the ghc sources removes all source files under /libraries ?
04:21:02 <Baughn> > let foo = 1 : foo in take 1 foo
04:21:04 <lambdabot>  [1]
04:21:16 <Cale> foldTree l b (Branch t1 t2) = b (foldTree l b t1) (foldTree l b t2)
04:21:21 <dons> waern: sounds like a bug crept in?
04:21:31 <dons> it certainly wasn't doing it last week
04:21:36 <Cale> If b isn't strict, that could return something immediately.
04:21:40 <waern> dons, it's been this way for quite a while for me
04:22:04 <edwardk> hrmm
04:22:05 <SamB> waern: it is overzealous, and removes sources from other packages?
04:22:22 <dons> oh very intersting. you could report it, include a transcript of what you did and what its results were
04:22:32 <edwardk> did say 'can' =)
04:22:41 <Baughn> let foo = foo : foo in take 1 foo
04:22:43 <Cale> okay
04:22:43 <edwardk> remember length is also a valid catamorphism ;)
04:22:45 <Baughn> > let foo = foo : foo in take 1 foo
04:22:46 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
04:22:46 <lambdabot>    Expected...
04:23:07 <SamB> Baughn: heh
04:23:08 <Baughn> ..right. Anyway, a catamorphism would choke on that sort of structure.
04:23:08 <edwardk> and i don't think anyone will argue for
04:23:11 <edwardk> > length [1..]
04:23:15 <lambdabot> Terminated
04:23:15 <edwardk> =)
04:23:38 <waern> samB, actually it only removes the source files for some packages
04:23:42 <waern> like Cabal and Base
04:23:51 <SamB> waern: oh! how odd!
04:23:59 <Cale> I think of a catamorphism as a function which replaces the data constructors in the structure with other functions.
04:24:03 <SamB> I'm glad I didn't run "make clean"!
04:24:04 <edwardk> coz a catamorphism may not return a structure.
04:24:11 <edwardk> yeah
04:24:19 <SamB> is foldl a catamorphism?
04:24:25 <edwardk> in your case that data structure was being replaced with another structure,
04:24:38 <Cale> In some sense, it returns a call graph which is isomorphic to the original structure.
04:24:39 <edwardk> samb: it can be constructed as such, foldl can be defined in terms of foldr which is.
04:24:43 <SamB> hmm
04:24:46 <edwardk> cale: yeah
04:24:56 <SamB> what is the proper name for it, though?
04:25:10 <edwardk> samb: it would be a catamorphism.
04:25:29 <dblhelix> SamB: it's also a left reduction (or crush, if you like)
04:25:30 <edwardk> samb: just with a particularly ugly function being applied.
04:25:35 <Cale> just not a very natural one :)
04:25:45 <dblhelix> SamB: I guess I have to say "left reducer"
04:26:05 <SamB> okay...
04:28:24 <SamB> hmm, does anyone know where the gdk source is?
04:28:28 * Baughn decides to lobby for teaching Haskell to first-year students
04:28:56 <SamB> Baughn: yes, they absolutely love that ;-P
04:29:17 <Baughn> SamB: The theory is... survival of the fittest
04:29:49 <SamB> yeah ;-)
04:30:32 <SamB> hopefully the rest don't hold a grudge, but just decide to go into something easier like electrical engineering... oh, wait, that isn't easier is it?
04:30:49 <gds> When I was a first year, the only language we coded in for the first term was haskell. My tutor told me that the point was to break my mind :)
04:31:17 <SamB> which is a good idea if everyone is coming in with an imperative mind!
04:31:45 <gds> indeed :)
04:32:02 <Baughn> New students rarely have imperative minds. Now, the "hackers"...
04:32:14 <gds> That was in 1999 - I'm only now starting to feel that I'm able to think HOF...
04:32:46 <SamB> or maybe if people are coming in with, say, really fuzzy minds!
04:33:21 <edwardk> i only wish i could indoctrinate my poor first year students this time around with Haskell. Poor bastards get to have their minds debased by Java.
04:33:39 <SamB> hmm, now that *really* breaks your mind
04:33:44 <edwardk> exactly.
04:34:02 <profmakx> i recall how i was ranting about the strictness of modula3 in my first year
04:34:03 <edwardk> typically leaves them drooling on their keyboards with their eyes glazed over ;)
04:34:09 <SamB> now do they do this to *all* students, or only students in particular departments?
04:34:17 <edwardk> samb: all.
04:34:22 <SamB> wow!
04:34:36 <edwardk> samb: why do you think they euphemistically call Eastern a 'teaching college' ;)
04:34:47 <SamB> too bad I'm not going to be a first year student after this semester, finally!
04:34:54 <Cale> > let foldl f z xs = foldr (\x g n -> g (f n x)) id xs z in foldl (flip (:)) [] [1,2,3,4,5]
04:34:55 <lambdabot>  [5,4,3,2,1]
04:35:12 <SamB> edwardk: a teaching college ? sounds like a place you go to learn to teach.
04:35:13 * gds prefers java to most other "mainstream" languages...
04:35:19 <SamB> I should send my calculus teacher there ;-)
04:35:23 <edwardk> samb: exactly
04:35:39 <Cale> I'm not sure if that quite counts though :)
04:35:54 <edwardk> samb: though i will confess thhe teaching cirriculum at most colleges is like the watered down version of whatever discipline its supposed to be.
04:35:55 <SamB> Cale: hmm
04:36:02 <edwardk> it was particularly horrible in math while i was there.
04:36:03 <Cale> seeing as I had to apply the result of the foldr to a value
04:36:17 <edwardk> they throw in history classes with the same number level as fourier analysis, etc.
04:36:22 <Cale> then again, everything is curried anyway :)
04:36:23 <SamB> Cale: hold on...
04:36:40 <edwardk> cale: lemme check my back log i have one
04:36:45 <SamB> let me at something in GHC.List...
04:36:46 <Cale> also, I don't think that easily translates to eliminate xs
04:36:56 <SamB> s/let me/let me look/
04:37:45 <edwardk> foldl f v l = foldr (\x -> \g -> \v' -> g $ f v' x) id l v
04:37:49 <edwardk> is the one i had
04:38:12 <Cale> yeah, that's basically what i have
04:38:25 <edwardk> yeah =)
04:38:27 <Cale> I'm not entirely satisfied with it
04:38:59 <dolio> I have a paper her somewhere that writes foldl in terms of foldr...
04:39:13 <psnl> dolio: thats not new
04:39:54 <dolio> Right, but they're trying to do it without using haskell's declarative syntax, right?
04:40:06 <Cale> Really we want an answer to: do there exist functions c and n such that foldl = foldr c n ?
04:40:24 <Cale> Filling in extra function parameters is cheating :)
04:41:13 <SamB> I really don't get the point of the and/build and or/build rules...
04:41:46 <Cale> Or I suppose if you want, functions c' and n' such that foldl f z = foldr (c' f z) (n' f z)
04:41:55 <dolio> Oh, well, damn, it just does what you're doing.
04:42:22 <boliver> Cale: I don't think that is possible (foldl = foldr c n)
04:42:28 <Cale> It may not be possible to do better.
04:42:51 <boliver> foldr captures structural recursion (without currying and tupling)
04:43:03 <dons> SamB, why?
04:43:06 <Cale> right
04:43:13 <dolio> ?pl \f v xs -> foldr (\x g -> (\a -> g (f a x))) id xs v
04:43:14 <lambdabot> flip . flip foldr id . (flip (.) .) . flip
04:43:18 <dons> fusing and and or are among the first things you want to do :)
04:43:20 <dolio> Yikes.
04:43:20 <SamB> oh, wait...
04:43:29 <boliver> but it gives you more with currying
04:43:33 <SamB> dons: I was assuming they were already defined with foldrs...
04:43:39 <SamB> or do I mean foldls...
04:43:40 <boliver> and I think you need that for foldl
04:43:47 <dons> no good if its foldl
04:43:55 <SamB> no, foldrs...
04:44:06 <dons> "and/build" forall (g::forall b.(Bool->b->b)->b->b) .
04:44:07 <dons>         and (build g) = g (&&) True
04:44:07 <dons> "or/build"  forall (g::forall b.(Bool->b->b)->b->b) .
04:44:07 <dons>         or (build g) = g (||) False
04:44:14 <SamB> foldrs work fine for booleans ;-)
04:44:18 <dons> good rule
04:44:44 <SamB> because boolean operations are short circuiting...
04:46:38 <dons> in the ndp branch we have:
04:46:40 <dons> andU :: UArr Bool -> Bool
04:46:40 <dons> andU = foldU (&&) True
04:46:40 <dons> -- |
04:46:40 <dons> orU :: UArr Bool -> Bool
04:46:42 <dons> orU = foldU (||) False
04:47:04 <dons> foldlU :: UA a => (b -> a -> b) -> b -> UArr a -> b
04:47:05 <dons> {-# INLINE foldlU #-}
04:47:06 <dons> foldlU f z = foldS f z . streamU
04:47:17 <dons> which is nice and cean
04:47:21 <dons> clean
04:47:30 <kosmikus> boliver: are you going to icfp/hw?
04:47:48 <boliver> nop, writting my thesis :)
04:48:35 <dons> SamB, oh, regarding <nick>++ , can we just have ^nick++ ?
04:48:44 <SamB> ???
04:48:47 <dons> would that cover most cases?
04:48:54 <dons> ^ -- start of line
04:48:56 <SamB> oh, that. I suppose so.
04:49:10 <dons> and ignore C++ :)
04:49:16 <SamB> hehe
04:49:20 <Igloo> ^nick++($| .*)
04:49:24 <wolverian> why ^?
04:49:32 <dons> Igloo: yeah.
04:49:40 * dons hacks this in
04:49:46 <wolverian> Igloo, \b
04:50:09 <wolverian> or well, maybe not. anyway, sleep. :)
04:50:17 <kosmikus> boliver: but jeremy is going?
04:53:12 <SamB> hmm, why are these functions in reverse order in the interface file...
04:53:46 * SamB wonders how something can be lazy in an unboxed argument
04:54:06 <dolio> Man, this bananas, lenses, envelopes and barbed wire paper is typeset in sans-serif.
04:54:10 <dolio> How bold of them.
04:54:15 <Igloo> SamB: Do you mean in something like Int#?
04:54:21 <SamB> Igloo: yes!
04:54:24 <dons> dolio: they were wacky times
04:54:33 <Igloo> SamB: If so, it's not, it just shows as L in the interface file/simpl output
04:54:39 <SamB> I guess the compiler is just silly
04:54:56 <dons> oh, reminds me we meant to write a strictness plugin
04:55:15 <kzm> shouldn't (null (LPS [pack ""]) == True)?
04:55:27 <SamB> dons: were you going to read the hi file or were you going to have GHC or hs-plugins do it for you?
04:55:44 <kzm> > Data.ByteString.Char8.pack ""
04:55:45 <lambdabot>  Not in scope: `Data.ByteString.Char8.pack'
04:55:50 <dons> I was going to read the .hi files once, and stick it in a b
04:55:53 <dons> db
04:56:07 <dons> kzm, that's 'empty'
04:56:16 <SamB> it occurs to me that it would be neat to have that for supplied functions too
04:56:20 <kzm> ?
04:56:32 <dons> ?type Data.ByteString.Char8.empty
04:56:33 <lambdabot> Data.ByteString.Base.ByteString
04:56:51 <dons> SamB: definitely
04:57:16 <kzm> So - can I use == against empty, then?  Or what are you suggesting?
04:57:26 <SamB> kzm: hmm?
04:57:29 <dons> using == against empty would be recommended
04:57:36 <dons> since then it'll test against nullPtr#
04:57:42 <kzm> I want to check if a lazy BS is the null string.
04:57:52 <dons> oh, use 'null'
04:57:55 <kzm> But it fails if I have LPS [""]
04:57:57 <dons> ?type Data.ByteString.null
04:57:58 <lambdabot> Data.ByteString.Base.ByteString -> Bool
04:58:11 <kzm> Perhaps I should check lenght?
04:58:14 <dons> you can't have that LPS-- it's illegal
04:58:26 <SamB> dons: heh
04:58:31 <dons> there should never be a LPS [""]
04:58:44 <kzm> Don't blame me - I didn't design the Show instance.
04:58:58 <dons> hmm?
04:59:03 <SamB> I don't think that was what dons meant
04:59:23 <kzm> Oh.  I thought I was the one with the question.
04:59:28 <dons> anyway, use 'null' and 'empty' to test for emptiness
04:59:29 <dons> null :: ByteString -> Bool
04:59:29 <dons> null (LPS []) = True
04:59:29 <dons> null (_)      = False
04:59:44 <kzm> Guess what: that's what I did.  Except that it doesn't work.
04:59:45 <dons> and we have:
04:59:46 <dons> _invariant (LPS []) = True
04:59:47 <dons> _invariant (LPS xs) = L.all (not . P.null) xs
04:59:55 <dons> i.e. you can't build a LPS [""]
05:00:31 <kzm> Hmm... except by using the constructor, I presume.
05:00:50 <dons> if you muck around inside, and don't preserve the invariant, the standard functions won't work..
05:01:09 <kzm> *something* did produce one.  I'll go check.
05:01:09 <dons> maybe we should put that in capitals
05:01:21 <fasta> Why are there no rules for inclusion in the standard libraries?
05:01:22 <kzm> Or not export the constructor?
05:01:27 * Igloo wonders why the parens around _
05:01:45 <dons> Igloo: I think that's a duncan-ism
05:01:58 <Igloo> fasta: The rules are that if you can get a concensus on libraries@ then it can go in
05:02:23 <SamB> Igloo: looks prettier?
05:02:37 <kzm> Funny - the only place I use FPS has been commented out... will check some more.
05:02:44 <Stinger__> http://xkcd.com/c32.html hehe
05:02:46 <dons> dcoutts__: any idea why the LPS constructor is exported?
05:02:46 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - COMPLY
05:02:49 <dons> (other than testing?)
05:03:14 <SamB> dons: ... for people such as yourself who are not you?
05:03:39 * dons tries to typecheck that sentence
05:03:51 <fasta> Igloo: I'd rather have everything documented before it gets widely distributed, instead of as a user figuring out the semantics.
05:03:54 <dons> Occurs check: cannot construct the infinite type: dons
05:04:23 <SamB> dons: umm
05:04:28 <Igloo> Things in stable libraries are supposed to have docs and tests. Hasn't worked out that way in practice, unfortunately.
05:04:32 <boliver> kosmikus: Jeremy is going
05:04:45 <dcoutts__> dons: oops, hide it
05:04:57 <kosmikus> boliver: ok. good luck with your thesis. are you making good progress?
05:04:59 <dons> that's what I thought.
05:05:20 <SamB> do you have a function that takes a list of bytestrings and returns a lazy bytestring?
05:05:35 <boliver> its going, slowly but going
05:05:46 <dons> no. though there should be one.
05:05:57 <SamB> that would be why LPS is exported ;-)
05:06:12 <dons> possibly
05:07:14 <kzm> Ah, found it!  Bug in my hGetLines.
05:07:17 <SamB> fromList = LPS . filter (not . B.null)
05:07:39 <dons> yes
05:07:39 <SamB> toList (LPS xs) = xs
05:08:04 <SamB> dunno if they should have longer names or not
05:08:41 <Igloo> I don't like List there personally, as the fact it is Bytestrings internally is just an implementation detail, isn't it?
05:08:53 <mux> dons: will the FPS functions be the standard ones at some point? I mean if you use hGetLines for instance, you get the FPS version by default
05:08:59 <SamB> Igloo: is it?
05:09:09 <Igloo> Hmm, maybe not
05:09:20 <Igloo> No, ignore thta  :-)
05:09:23 <kzm> mux: FPS is part of base now, so it just depends on your imports.
05:09:37 <mux> I know that
05:10:06 <dcoutts__> SamB: we might provide something for constructing a lazy byte string from a list of strict ones, but LPS constructo should not be exported
05:10:21 <dcoutts__> since there is an invariant to check/preserve
05:10:31 <dons> people shouldn't be mixing and matching the two bytestring types anyway, imo
05:10:37 <tuomov> hmm.
05:10:48 <dcoutts__> yeah, it's probably just confusing
05:10:49 <SamB> dcoutts: notice the functions  Ijust wrote up
05:10:56 <tuomov> GSL seemed like a nice alternative to matlab, but it appears that scalar multiplication etc. is too complicated
05:11:07 <dcoutts__> SamB: aye, those would work
05:11:18 <SamB> dons: I know, but efficient conversion might be important from time to time
05:11:24 <dcoutts__> I'd name them differently
05:11:40 <dcoutts__> toChunks, fromChunks
05:11:42 <SamB> yeah, I didn't spend much time on the names ;-)
05:11:58 <dcoutts__> since toList fromList would be for conversion to from [Word8]
05:12:07 <dcoutts__> except we use pack unpack for that
05:12:13 <mux> mmm, maybe I should create a FreeBSD port for Clean
05:14:34 <dons> can you do that? or are there license issues?
05:14:47 <SamB> .. license issues?
05:14:59 <SamB> a FreeBSD port is just a makefile isn't it?
05:15:07 <mux> no license issues - it's LGPL but that doesn't prevent us from creating a port
05:15:12 <mux> it's a Makefile and a few other files
05:15:26 <SamB> ah
05:15:31 <SamB> what are the other files?
05:15:35 <dons> oh, I thought it used to require a bunch of weird agreements.
05:15:37 <mux> optinally patches, a (optional too since you can create this dynamically) plist file containing the files to be installed, a description file
05:15:47 <mux> and a checksum one
05:15:50 <dons> it was even closed src at first?
05:16:01 <mux> we even have ports for closed-source stuff
05:16:50 <mux> it's quite similar to pkgsrc if you know this
05:17:50 <mux> though with more software :-)
05:17:54 <dons> yeah, the java port is like that, I suppose. "go and download some weird Sun thing. type 'make'"
05:18:06 <mux> yes
05:18:18 <mux> some binary only stuff doesn't require you to go download files though, it all depends on the licence
05:18:54 <SamB> ... I would think it would depend on how easy it was to automatically download the files...
05:19:04 <mux> not really
05:19:22 <mux> sometimes the licence prevents you from automatically downloading the files, such as for java, as dons said
05:19:35 <mux> we could fecth them automatically, technically speaking
05:19:41 <SamB> how could that be illegal?
05:19:42 <mux> the licence just forbids it
05:19:59 <mux> you have to go say "Ok!" to Sun's EULA
05:20:01 <dons> bow before the mightly license!
05:20:06 <SamB> yeah, sure
05:20:21 <SamB> but couldn't you have it pop up the EULA and then automatically download it for you?
05:20:28 <SamB> after you say "Ok!"?
05:20:36 <fasta> SamB: that's what Gentoo does
05:20:41 <mux> I doubt this pretty much, or we would have done it this way
05:20:54 <mux> yes but Linux has a licence agreement with Sun, that we don't have (anymore)
05:20:56 <fasta> (No, I don't use Gentoo anymore)
05:21:01 <mux> though we're supposed to get it back someday
05:21:11 <fasta> mux: FreeBSD?
05:21:13 <SamB> I'm pretty sure that the law would not consider the computer to be doing anything
05:21:13 * mux grumbles at Sun
05:21:16 <mux> fasta: yes
05:21:22 <fasta> mux: lost it again? Why? A year ago you had it
05:21:27 <tibbe> I need an introductory paper on category theory, I'm reading another paper that uses words such bi-functors which I don't understand :) Can someone recommend a good one?
05:21:28 <SamB> but rather the user that commands the computer
05:21:29 <mux> they removed it from us
05:21:38 <mux> talks are ongoing to get it back
05:22:04 <mux> SamB: I think the people who take care of this are fully aware of all the possible legal issues and if it's done this way, that's for a reason
05:22:14 <fasta> mux: How annoying
05:22:19 <mux> isn't it :)
05:22:25 <SamB> maybe it is a technical issue ;-)
05:22:38 <mux> that's not even conceivable
05:23:01 <SamB> well, I mean, maybe ports aren't supposed to demand user interaction
05:23:17 <mux> ports can do this perfectly well
05:23:22 <mux> and do it quite often these days.
05:23:31 <mux> (since we moved to the OPTIONS framework)
05:23:38 <mux> you really should trust me on that..
05:23:44 <SamB> okay, so maybe they are just covering their collective ass...
05:23:54 * mux shrugs
05:24:05 <SamB> or maybe I really have no clue
05:24:17 <fasta> mux: that's the ncurses interface right with a number of, well, options to choose from?
05:24:25 <mux> fasta: yep, exactly
05:24:35 <SamB> presumably the ncurses interface is one of several?
05:24:38 <mux> using dialog(1) and stuff
05:24:42 <SamB> or it wouldn't be called a framework?
05:24:44 <fasta> mux: I wrote one when I used FreeBSD
05:24:48 <mux> SamB: err, what the hell are you talking about?
05:25:01 <SamB> or not...
05:25:15 <fasta> mux: You probably wrote hundreds ;)
05:25:15 <Baughn> Is TCP/UDP in the haskell standard somewhere?
05:25:27 <mux> fasta: not hundreads, I'm more on the src front than the ports one
05:25:34 <mux> but I wrote and maintain a few
05:25:35 <SamB> Baughn: don't think so...
05:25:50 <mux> I had to do the FPS port because it was unbearable to not have it in FreeBSD :-)
05:26:34 <Baughn> SamB: A library, then? (Or do I need to use FFI?)
05:26:57 <mux> Haskell has some kind of socket interface
05:27:00 <Lemmih> @docs Network
05:27:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
05:27:03 <mux> @index connect
05:27:05 <lambdabot> Network.Socket
05:27:09 <SamB> Baughn: a lot of things aren't in the standard ;-)
05:27:12 <tibbe> @where category theory
05:27:13 <lambdabot> I know nothing about category.
05:27:27 <SamB> the standard *is* like 7 years old...
05:27:27 <mux> @index setsockopt
05:27:27 <lambdabot> bzzt
05:27:32 <mux> hmm, no good
05:27:43 <Baughn> TCP/IP isn't /that/ new. :/
05:27:45 <SamB> @index socketoption
05:27:46 <lambdabot> bzzt
05:27:52 <mux> there is not {set,get}sockopt() support in haskell?
05:27:52 <dons> Baughn: the standard package 'network' does what you want.
05:27:57 <Baughn> Ah well. If it's in ghc, it'll do.
05:27:59 <dons> use -package network
05:28:02 <mux> @index TCP_NDELAY
05:28:02 <lambdabot> bzzt
05:28:06 <mux> @index TCP_NODELAY
05:28:07 <lambdabot> bzzt
05:28:10 <mux> mmmm
05:28:26 <dons> how else does one imagine lambdabot talks to the world? :)
05:28:29 <dons> ?version
05:28:29 <lambdabot> lambdabot 4p124, GHC 6.5 (OpenBSD i386 )
05:28:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:28:32 <SamB> hehe
05:28:44 <Baughn> dons: The FFI comes to mind
05:28:45 <mux> dons: what about socket options?
05:29:01 <tibbe> bottom is the symbol with a horizontal line with a vertical line on top of it right? does it mean non termination?
05:29:03 <SamB> Baughn: how do you suppose the library is implemented?
05:29:08 <dons> Baughn: seriously, I'm glad we don't each have to roll our own network binding :)
05:29:10 <SamB> though actually, maybe it isn't
05:29:14 <dons> there's several network libs out there
05:29:27 <dons> -package network, alt-network, fastcgi, ...
05:29:38 <dons> check haskell.org under 'libraries and tools'
05:29:41 <Baughn> SamB: Not, I hope, with direct system calls. I'd rather not write FFI code myself - because I'd have to /rewrite/ it on different platforms.
05:29:46 <SamB> hmm, I guess it uses FFI for some stuff and the basic IO stuff for other stuff...
05:29:47 <Baughn> But this looks good - thanks
05:30:45 <kzm> groupBy: shouldn't it use compare elements pairwise?
05:31:01 <SamB> @type groupBy
05:31:03 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
05:31:11 <SamB> kzm: what do you mean?
05:31:14 <kzm> ...so that two consequtive elements are fed to the "compare" function.
05:31:22 <dons> that's 'group'
05:31:34 <kzm> if I want to feed it something else than an equivalence relation.
05:31:37 <dons> oh, you want groupBy compare ?
05:31:53 <dons> and wrap it in a Bool of some kind
05:31:59 <SamB> groupBy is supposed to be given an equivalence predicate
05:32:00 <ski> tibbe : yes, and it means that no real value is returned
05:32:05 <kzm> Basically, I have lines of text, and want to group them with a specific starting line.
05:32:19 <dons> is that a sortBy then?
05:32:29 <tibbe> ski, what does "real value" mean in a mathematical (ie category theory) sense?
05:32:32 <kzm> No, I don't want to sort.
05:32:33 <dons> maybe you'll just have to write your own mixture of sortBy and groupBy
05:32:52 <dons> i.e. taking an (a -> a -> Ordering)
05:32:54 <dons> but grouping
05:32:55 <SamB> kzm: "group them with a specific starting line"?
05:33:04 <kzm> I think I want break/span/split/something, really.
05:33:10 <kzm> SamB, right.
05:33:19 <kzm> Ah.  It's a question. :-)
05:33:20 <ski> tibbe : perhaps you can look at Asperti, Andrea, & Longo, Giuseppe (1991). Categories, Types and Structures, ftp://ftp.di.ens.fr/pub/users/longo/CategTypesStructures/book.pdf
05:33:26 <ski> (for bifunctor, etc)
05:33:36 <tibbe> ski, I'll print it, thanks
05:33:39 <kzm> I have records that consist of multiple lines, the first line of each record starts with a '#'
05:33:49 <SamB> oh
05:34:00 <ski> (tibbe : it's a whole book)
05:34:00 <kzm> so I thought:
05:34:06 <kzm> >  List.groupBy (\ a b -> head a /= '#') ["#foo","bar","#zot","quux"]
05:34:07 <tibbe> ski, xD
05:34:07 <lambdabot>  [["#foo"],["bar","#zot","quux"]]
05:34:12 <kzm> >  List.groupBy (\ a b -> head b /= '#') ["#foo","bar","#zot","quux"]
05:34:13 <lambdabot>  [["#foo","bar"],["#zot","quux"]]
05:34:20 <kzm> Which is what I want.
05:34:40 <kzm> The first behavior puzzled me a bit, until I thougth about the implementation of groupBy.
05:36:04 <kzm> I guess List will be augmented with more splitting functions - which I guess is the righter tool for the job.
05:36:44 <kzm> Anyway: possibly groupBy would be more intuitive if it compared consecutively, without compromising supposedly-used equivalence relations.
05:36:52 <kzm> Problem solved, thank you for listening :-)
06:00:27 <Limbic_Region> what incantation do I need to cast to specify an installation directory to Cabal?
06:00:49 <Limbic_Region> I am trying to build the GHC extralibs
06:00:54 <Igloo> --prefix=/foo to the configure command
06:01:01 <Limbic_Region> thanks Igloo
06:01:10 <Limbic_Region> I see that the binary snapshots of Win32 stopped on the 1st
06:01:15 <Limbic_Region> is that while issues are resolved?
06:02:54 <Igloo> Hmm, no nightly build logs either
06:03:51 <Limbic_Region> prior to bringing my issues to the channel, I had sent an email to Simon Marlow in response to the "extralibs" being separate and all you need to do to include them is ...
06:03:58 <Limbic_Region> as that process doesn't work for binary Win32
06:04:15 <Limbic_Region> He CC'd me on an email requesting that they be included in the nightly build
06:04:28 <Igloo> What was that process?
06:04:43 <Limbic_Region> just include in the source directory and the build will take care of it for you
06:04:48 <Limbic_Region> that email was off the list
06:05:02 <Limbic_Region> to which I am not subscribed btw - I found it googling
06:05:49 <foxy> anyone know a reference with a proof that all lambda terms can be written using combinators K and S?
06:06:11 <Limbic_Region> Igloo - I was just going to test whatever the latest was to see if any/all the issues had been resolved
06:06:16 <Limbic_Region> I will check daily and report back
06:06:27 <Limbic_Region> or rather, report back when something has changed
06:06:49 <magnus-> Hi. Is there any software for printing haskell with syntax highlighting?
06:07:33 <Igloo> Limbic_Region: Simon's asking the Windows builder guy what's going on, BTW
06:07:50 <bringert> magnus-: yes, hscolour
06:07:56 <magnus-> bringert: cheers
06:07:58 <Limbic_Region> well, I really don't want to stick my nose where it doesn't belong but it seems these issues were unknown till I brought them up
06:08:23 <bringert> magagr, there are also editing modes for many text editors and IDEs
06:08:30 <bringert> eh, that was for magnus-
06:08:37 <lisppaste2> jberg pasted "problem with what to return" at http://paste.lisp.org/display/25441
06:08:39 <Igloo> Limbic_Region: Yes, please don't be shy about bringing up issues  :-)
06:08:39 <Limbic_Region> and I really feel like a fish out of water since I haven't written a single line of haskell
06:08:39 <magnus-> bringert: yes, I usually use emacs
06:09:08 <magnus-> bringert: I just want it to look attractive when I print it on paper and show to others :)
06:09:20 <bringert> ah
06:09:20 <magnus-> 'cause I'd be so much happier if I could use haskell on this project instead of C
06:09:32 <bringert> doesn't emacs do that if you have syntax highlighting on?
06:09:49 <bringert> anyway, you could certainly use hscolour for that sort of thing
06:09:52 <magnus-> I've never printed from emacs... I didn't know you can do that
06:10:07 <bringert> you can, but I'm hardly an expert
06:10:28 <bringert> dunno if the syntax highlighting works when printing
06:10:49 <bringert> there's also a bunch of tools for using haskell code in LaTeX that typeset the code nicely
06:11:49 <magnus-> that's an interesting idea too
06:12:33 <kowey> in case anybody finds this useful for bibtex... http://www.loria.fr/~kow/download/FixBibTeX.lhs
06:12:50 <kowey> converts your keys into something like author2004ftl
06:16:39 <dcoutts__> dons: we'll have to make something low-level available to access the chunks in a lazy byte string
06:17:08 <dcoutts__> dons: I'm just writing gzip, gunzip :: ByteString -> ByteString
06:17:21 <dcoutts__> and of course for that we need the chunks
06:18:03 <dcoutts__> like we've got the Base module that exposes the PS constructor
06:18:40 <mux> plugging to zlib?
06:18:42 <fasta> I wish I had goto.
06:18:46 <dcoutts__> mux: yes
06:18:48 <mux> the zlib interface is so horrible :-(
06:18:55 <dcoutts__> it's not too bad
06:18:59 <dcoutts__> same for bzip2
06:19:12 <mux> I've seen worse, but I've seen much, much better too
06:19:29 <mux> I hate it everytime I have to use zlib
06:19:33 <dcoutts__> it's basically the right thing
06:19:43 <dcoutts__> it doesn't get involved with files etc
06:19:49 <dcoutts__> just blocks of memory
06:19:55 <mux> there are high-level wrapper for dealing with files
06:20:02 <dcoutts__> which are useless for me
06:20:08 <mux> but yes, basic inflate() and deflate() deal with chunks of memory
06:20:15 <dcoutts__> which is good
06:20:25 <mux> that's the absolutely minimal requirement
06:20:39 <mux> it would be completely braindead if it wasn't providing memory-level interfaces
06:20:52 <dcoutts__> well we'll see how nasty my code is when I'm done :-)
06:20:59 <mux> and it wouldn't be used that much if it wasn't, I guess
06:21:06 <mux> yeah, good luck :-)
06:21:09 <dcoutts__> ta
06:21:24 <dcoutts__> mux: you've used zlib in Haskell or in something else?
06:21:28 <mux> no, in C
06:21:32 <dcoutts__> right
06:21:37 <mux> I'm still a noob haskeller
06:21:52 * dcoutts__ is using this as a reference: http://www.zlib.net/zlib_how.html
06:21:53 <lokadin> > isUpper "b"
06:21:53 <lambdabot>  Couldn't match `Char' against `[Char]'
06:21:54 <lambdabot> Title: zlib Usage Example
06:22:00 <lokadin> > isUpper "bo"
06:22:01 <lambdabot>  Couldn't match `Char' against `[Char]'
06:22:02 <mux> dcoutts__: I use zlib.h mostly :-)
06:22:05 <lokadin> > isUpper 'b'
06:22:06 <lambdabot>  False
06:22:12 <lokadin> > isUpper 'B'
06:22:13 <mux> it's quite well documented
06:22:13 <lambdabot>  True
06:22:15 <dcoutts__> hia xerox
06:22:20 <xerox> Hello dcoutts__
06:22:27 <dcoutts__> mux: yes I've seen that, it is quite good
06:22:41 <lokadin> > filter isUpper "TBB"
06:22:42 <lambdabot>  "TBB"
06:22:43 <mux> the actual code is an absolute mess though
06:22:45 <dcoutts__> xerox: I'm just writing gunzip, then tar...
06:22:52 <mux> convoluted piece of shit
06:23:01 <int-e> tar?
06:23:04 <xerox> dcoutts__: oh great.
06:23:07 <mux> littered with #ifdef's for MS-DOS and such
06:23:07 <xerox> @karma+ dcoutts__
06:23:08 <lambdabot> dcoutts__'s karma raised to 1.
06:23:10 <lokadin> > filter isUpper "tbb"
06:23:11 <lambdabot>  ""
06:23:22 <int-e> @karma+ dcoutts
06:23:23 <lambdabot> dcoutts's karma raised to 23.
06:23:25 <xerox> Ops, filthy underscores.
06:23:28 <dcoutts__> :-)
06:23:35 <int-e> @karma- dcoutts__
06:23:36 <lambdabot> dcoutts__'s karma lowered to 0.
06:23:38 <int-e> ;)
06:23:41 <dcoutts__> this is my .se persona
06:23:55 <xerox> Are you experiencing personality splits?
06:24:11 <int-e> _n_o_
06:24:21 <dcoutts__> my .uk persona is in suspension
06:24:32 <dcoutts__> hia dcoutts!
06:24:41 <dcoutts__> see, no response
06:24:55 <xerox> The cold is making Duncan go nuts.
06:25:06 <dcoutts__> no, it's warm here
06:25:14 * xerox shackes dcoutts__ 
06:25:20 <dcoutts__> eek!
06:25:23 <lokadin> if i have type Parser String, how do i return with a negative exitcode?
06:25:24 <mux> 26C and a nice sun in Paris
06:25:40 <mux> too bad i'm at work :-)
06:25:40 <xerox> My computer says 43C, but I think that's the CPU.
06:25:42 <tibbe> is a monad with a plus and zero a monoid?
06:25:48 <lokadin> or one that would indicate parsing didn't work
06:25:58 <dcoutts__> lokadin: fail
06:26:05 <xerox> tibbe: nope, it's a MonadZero and MonadPlus.
06:26:08 <lokadin> cool thanks :)
06:26:14 <dcoutts__> @type fail
06:26:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:26:33 <mux> I think parsec has a higher-level error handling function though
06:26:40 <dcoutts__> yeah, I think so too
06:27:10 <lokadin> dcoutts__: doesn't complain
06:27:21 <lokadin> complier anyways
06:27:31 <lokadin> compiler *
06:27:56 <tibbe> xerox, so what's a monoid then? :D
06:28:11 <mux> lists and ++ is a monooid
06:28:19 <xerox> ?docs Data.Monoid
06:28:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
06:28:26 <mux> Int and + is a monoid
06:28:27 <mux> etc
06:28:35 <mux> well, Integer rather, I guess
06:28:37 <xerox> That!
06:28:43 <mux> Int's are limited I think
06:28:54 <lokadin> nm, i guess it doesn't work
06:29:12 <mux> (with [] and 0 for the neutral element respectively, of course)
06:29:21 <xerox> Functions are Monoids too.
06:29:31 <xerox> Endofunctions or whatever you want to call them.
06:29:48 <xerox> ?instances Monoid
06:29:49 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
06:30:07 <profmakx> hmm
06:31:08 <tibbe> hmmm
06:32:36 <kzm> Does using '+RTS -s' incur any runtime costs?
06:34:12 <SamB> probably not much
06:35:33 <SamB> likely the RTS tracks those stats unconditionally
06:35:59 <xerox> ?users
06:36:00 <lambdabot> Maximum users seen in #haskell: 221, currently: 217 (98.2%), active: 42 (19.4%)
06:36:11 <ski> (tibbe : a monad is already a monoid, of sorts)
06:36:12 <int-e> 42!
06:37:28 <Baughn> Sadly, that is no longer true
06:38:08 <tibbe> I read some article about the number 42, some relation to primes and quantum physics
06:39:55 <mux> oh yes I read that one too
06:40:15 <SamB> Baughn: what? the answer isn't 42 anymore?
06:40:15 <mux> they were trying to find prime numbers in some measurements of atoms or something
06:40:24 <mux> they'd better concentrate on proving the RH :-)
06:40:47 <Baughn> SamB: They've recalculated, and it turns out that seven times five is not, in fact, forty-two.
06:40:53 <SamB> oh
06:40:55 <SamB> how sad
06:40:56 <Baughn> SamB: The universe made a mistake.
06:40:59 <SamB> > 7 * 5
06:41:01 <lambdabot>  35
06:41:06 <xerox> Anybody has a minute to try out installing cabal-get with a script?
06:41:08 <SamB> > 7 * 6
06:41:09 <lambdabot>  42
06:41:16 <SamB> but seven times six is!
06:41:47 <Baughn> But then you're assuming that the /question/ is mistaken
06:41:50 <SamB> why is FreeTheorem in DOS format?
06:42:11 <SamB> Baughn: I never heard of the question before, but I'd heard of the answer ;-)
06:42:23 <xerox> Well, not installing, just darcsgetting and compiling.
06:42:37 <mux> you can't possibly know both the question and the answer in the same space-time continuum
06:43:05 <mux> or if you do, the universe is quickly changed to something more complicated
06:43:13 <SamB> heh
06:43:14 <mux> (some people suspect this has already happened several times)
06:43:30 * mux hearts douglas adams
06:43:36 <Stinger__> haha what if someone gets too clever :)
06:43:55 <Baughn> Then the universe gets changed so they are no longer sufficiently clever
06:44:04 <int-e> "Nobody writes jokes in base 13." (this is a futile attempt to shortcut the following discussion somewhat)
06:44:21 <Baughn> It is believed that several iterations of this led to the last universe, in which a planet-sized computer was required to compute the Question.
06:44:35 * mux nods
06:45:10 <Baughn> At which point, of course, it got turned into an even more complex universe where the last one was reduced to a /book/. Humans.
06:46:06 <xerox> Somebody has got Cabal-non-darcs ?
06:46:19 <xerox> I.e. the cabal shipped with some official GHC installation?
06:46:29 <xerox> (....and a spare minute?)
06:46:47 <SamB> Baughn: what book?
06:47:02 <Baughn> xerox: Any darcs repository whose address starts with http:// can be downloaded with wget
06:47:29 <Baughn> SamB: HHGttG, of course
06:47:42 <SamB> oh
06:47:44 <xerox> Baughn: right... hmm?
06:47:57 <SamB> that universe is simpler than ours?
06:48:01 <SamB> I haven't read the book...
06:48:12 <Baughn> xerox: I think my assumption was that you wanted a non-darcs version because you didn't have darcs installed
06:48:33 <SamB> heh
06:48:41 <Baughn> SamB: It's simpler, yes. I'm not sure why, or even how, but it must be simpler.
06:48:42 <SamB> Baughn: what a silly idea ;-)
06:48:42 <xerox> Baughn: nope, I would like someone to try out a very little shell script on a different environment than mine. And with a different Cabal version.
06:48:48 <SamB> of course xerox has darcs installed
06:49:02 <xerox> (!)
06:49:06 <Baughn> You're going to say something like "he wrote it" now, aren't you?
06:49:11 <SamB> no!
06:49:18 <Baughn> Oh, good
06:49:54 <SamB> just that xerox has been around long enough to know it should be installed, so that rather than ask for a non-darcs version he would be trying to install darcs.
06:50:00 <SamB> assuming it was his computer...
06:50:27 * xerox uploads the lil script...
06:51:05 <xerox> http://hackage.haskell.org/~paolo/tmp/get-cabal-install.sh
06:51:18 <xerox> It assumes you use `sudo' for administration operations.
06:51:29 <xerox> ...and that you have got darcs.
06:51:35 <xerox> ...and runghc.
06:52:06 <Baughn> Well, I don't use sudo. Oh well..
06:52:11 <xerox> What do you use?
06:52:12 <tibbe> let me too upload a little script, it required root permission to run...
06:52:22 <Baughn> xerox: su.
06:52:37 <xerox> Baughn: what's the syntax? I bet su is more widespread than sudo.
06:52:40 <Baughn> xerox: Might be good to allow that as an alternative - it's /always/ around
06:52:42 <xerox> su - -c '..' ?
06:52:47 <Baughn> Yep
06:52:52 * xerox fixes
06:53:06 <Baughn> xerox: Mind you, su won't work by default on OS X and sudo will
06:53:12 <xerox> Argh.
06:53:33 <norpan> maybe you can do sudo su
06:53:39 <Baughn> Nope
06:53:49 <xerox> What's the problem on OS X?
06:53:57 <Baughn> root is passwordless by default
06:54:00 <Igloo> xerox: Do you need it done by root, rather than a user and --prefix?
06:54:02 <Baughn> - so you can't login as root
06:54:18 <xerox> Igloo: the latter is good enough
06:54:21 <norpan> you don't need a password to "su" when you are root
06:54:40 <xerox> Igloo: but the script needs to be changed to do that. Hmm.
06:54:49 <Baughn> On the other hand, you don't need to su when you are root...
06:55:05 <norpan> Baughn: no, but i thought you might be able to do "sudo su"
06:55:07 <dylan> unless you want to become less privledged.
06:55:23 <dylan> sudo -i is generally better than sudo su.
06:55:25 <Baughn> norpan: sudo often isn't installed, and anyway that would only work if sudo let you call su as root
06:55:26 <Limbic_Region> norpan - the normal way of doing that is sudo sh
06:55:26 <xerox> Igloo: I might even do all of it in /tmp and adjust PATH?
06:55:34 <norpan> oh
06:55:37 <norpan> sudo sh then
06:55:38 <Limbic_Region> norpan - effecitively becoming root
06:55:45 <Baughn> norpan: In which case yuu wouldn't need su
06:55:47 <norpan> and run the script
06:55:47 <Limbic_Region> and then whatever needs to be done
06:55:56 <norpan> sudo id
06:55:56 <Igloo> xerox:
06:55:57 <Igloo> % runghc Setup.lhs configure --user --prefix=/tmp/b/inst
06:55:57 <Igloo> Setup.lhs: cabal-install.cabal:6: Unknown field 'data-files'
06:56:08 <Igloo> xerox: That's 6.4.1
06:56:21 <xerox> Igloo: a-ha. It needs newer Cabal... thanks much.
06:56:21 <Limbic_Region> coming into the conversation late - it may be better to use setuid then to be throwing around root privs
06:56:41 * Limbic_Region may not know Haskell but he certainly knows *nix and security
06:57:02 <Baughn> Sadly, setuid won't fit well in a tarball.
06:57:16 <Limbic_Region> for good reason
06:57:24 <xerox> Igloo: what could be a good way to write this script then? I'd like to post it to haskell-cafe and have people reporting bugs.
06:57:32 <Limbic_Region> you could just give yourself setuid on a machine you have root and move it over to a machine you don't
06:57:41 <Limbic_Region> again, came into the conversation late - so I will shut up now
06:57:42 <xerox> It could update Cabal, and then install cabal-install.
06:57:46 <Baughn> xerox: I'm inclined to say the Right Thing to do here is to use the distribution's package manager
06:58:03 <xerox> Baughn: that's not possible... I think.
06:58:37 <Baughn> xerox: Well, it'd depend on someone packaging your script.. or cabal... for every distribution out there. It's lots of work.
06:58:56 <xerox> Baughn: I want people to try out cabal-install!
06:58:58 <int-e> gentoo does package cabal
06:59:42 <Baughn> xerox: Then I suggest you just let the /user/ choose between su and sudo, with sudo as default on osx and su otherwise
06:59:49 <Igloo> xerox: Personally, I think it should either Just Work with 6.4.x or be advertised as requiring 6.6
07:00:25 <Igloo> xerox: In the first case, making a .cabal file that is backwards compatible (if possible)
07:00:26 <int-e> (thanks dcoutts for the gentoo packages btw)
07:00:33 <Baughn> xerox: Where did you put the script again?
07:00:41 <xerox> http://hackage.haskell.org/~paolo/tmp/get-cabal-install.sh
07:00:58 <xerox> Igloo: now cabal-install lives inside Cabal/
07:01:54 <xerox> Igloo: if you take that entry away from the .cabal file, does it compile?
07:01:54 <Baughn> xerox: Maybe you could have the script clean up after itself afterwards, or at least mention the new directory
07:02:14 <Baughn> xerox: Works, thogh
07:02:21 <xerox> Baughn: oh cool.
07:02:26 <xerox> Baughn: then try cabal-install update
07:02:32 <xerox> ...and cabal-install list.
07:03:12 <xerox> Baughn: argh, the script doesn't make the /etc/cabal-install dir and doesn't copy serv.list there, sorry.
07:03:28 <xerox> Baughn: which is needed before using cabal-install.
07:04:28 <Baughn> Chasing modules from: CabalInstall.hs
07:04:28 <Baughn> Could not find module `Network.Hackage.CabalInstall.Main'
07:04:37 <Baughn> Yeah, I was a bit premature about the "it works"
07:04:43 <xerox> Ow.
07:05:21 <xerox> Allright, it needs newer Cabal, the one you just darcs-got
07:05:56 <xerox> Which Cabal do you have now?
07:07:03 <waern> If you push using SSH directly to e.g GHC head, do the patches go to a moderation list or are they applied directly?
07:07:14 <Baughn> xerox: 1.1.4
07:07:19 <xerox> waern: I think you can use darcs send ?
07:07:23 <xerox> Baughn: thank you.
07:07:39 <Baughn> xerox: Hang on... that was preinstalled, before I ran your script. Hmm..
07:07:41 <waern> xerox, ok
07:08:10 <xerox> Baughn: yes right. For unknown reason Network/Hackage/CabalInstall is inside Cabal/ and not cabal-install/src/.
07:09:30 <xerox> Baughn: I'll try to fix it now and be back to you in a moment.
07:10:14 <Igloo> xerox: That works
07:10:35 <Igloo> xerox: Using runghc Setup.lhs configure --user --prefix=/tmp/b/inst; runghc Setup.lhs build; runghc Setup.lhs install
07:11:00 <waern> xerox, if I do that, they will get to some kind of moderation list?
07:11:16 <xerox> Igloo: oh nice. Then one has to do something like export PATH="/tmp/b/inst:$PATH" ?
07:11:31 <Igloo> xerox: Yup
07:18:16 <fasta> I get this error message: Missing field in record construction in FooModule.recordaccessor. Does this mean I can't create values by not specifying all members?
07:18:47 <fasta> E.g. MyState has records foo, bar and baz, and I only supply foo and bar.
07:19:45 <fasta> Never mind
07:20:07 <xerox> emptyState = MyState { foo = "", bar = 0, baz = undefined }
07:20:07 <xerox> someState = emptyState { foo = "initial", bar = 1 }
07:20:08 <xerox> If you want.
07:21:31 <fasta> xerox: I think emptyState = MyState {foo=""} also works
07:21:53 <xerox> fasta: and what is inside the others, undefined?
07:22:18 <fasta> xerox: I think some special marker value "uninitialized" in GHC.
07:22:33 <fasta> xerox: semantically undefined, I think
07:25:45 <Stinger__> wow #haskell quote on userfriendly, small .. er internet
07:26:08 <shapr> What's the quote?
07:26:24 <Stinger__> http://ars.userfriendly.org/cartoons/read.cgi?id=20060904&tid=2188602
07:26:27 <lambdabot> Title: UserFriendly Strip Comments, http://tinyurl.com/zw28v
07:26:47 <shapr> That's pretty funny.
07:26:58 <shapr> @seen dcoutts__
07:26:58 <lambdabot> dcoutts__ is in #haskell-overflow, #haskell-blah, #haskell and #gentoo-haskell. I last heard dcoutts__ speak 46m 49s ago.
07:27:18 <shapr> @users
07:27:19 <lambdabot> Maximum users seen in #haskell: 221, currently: 212 (95.9%), active: 41 (19.3%)
07:27:30 <shapr> Oh cool, it shows activity as well, smart!
07:28:12 <shapr> bringert: I really need something like ZPT for Hope, any ideas how to approach that?
07:31:53 <shapr> Sure is quiet today.
07:33:35 <Stinger__> *tumbleweed*
07:35:13 <Lemmih> Hi shapr.
07:36:19 <bringert> hi shapr
07:36:22 <bringert> welcome back
07:36:31 <bringert> shapr: what's ZPT?
07:36:55 <lispy> shapr: hi
07:37:08 * wkh is present
07:37:11 <bringert> ah, page templates
07:37:13 <wkh> i like coffee
07:37:20 <wkh> and huggable, snuggable kitty cats.
07:37:24 * lispy goes for a jog
07:38:25 <bringert> shapr: the students in the webapps project implemented something that you could probably use
07:39:02 <shapr> Greetings to all!
07:39:07 <shapr> bringert: Cool, is it online?
07:39:18 <NoGoodNik> Good morning.
07:39:29 <bringert> shapr: there's some documentation here: http://csmisc14.cs.chalmers.se/haskellwebapps/dokument/slutrapport.pdf
07:39:47 <shapr> Och den r i svensk ocks
07:39:56 <shapr> Bra att jag kan lsa det.
07:40:10 <deadbeef> shapr: o rly ?
07:40:18 <bringert> shapr: the technical stuff is in english actually
07:40:23 <shapr> Oh ok
07:40:29 <bringert> shapr: I think the code for the template stuff is here: http://csmisc14.cs.chalmers.se/haskellwebapps/darcs/xml/
07:40:31 <lambdabot> Title: Index of /haskellwebapps/darcs/xml, http://tinyurl.com/kwdag
07:40:52 <bringert> does lambdabot create those tinyurls on the fly
07:41:05 <xerox> Yep.
07:41:22 * bringert is coding in java
07:41:26 * shapr is coding in python
07:41:28 <bringert> mutability sucks
07:41:31 * shapr agrees!
07:41:39 * xerox is coding ... Haskell
07:41:51 <wkh> today i will code in python
07:41:54 <shapr> In-container J2EE unit testing software is hysterically funny.
07:41:56 * norpan is coding c++
07:42:06 <wkh> poor bastard
07:42:08 <bringert> you have to be careful to copy everything, so that you don't happen to modify something that someone else is also using
07:44:30 <xerox> Is there an automatic way to let Cabal pick a .cabal file depending on the compiler version number?
07:44:42 <Lemmih> Nope.
07:45:23 <xerox> Lemmih: is there a particular reason why Network/Hackage/CabalInstall was in Cabal/ and not cabal-install/src/ ?
07:45:40 <bringert> xerox: there will be stuff like that when configurations get implemented
07:45:49 <bringert> JaffaCake has started working on it
07:46:05 <Lemmih> xerox: I don't think so.
07:46:14 <Lemmih> xerox: Feel free to move it.
07:46:22 <xerox> Lemmih: yeah I moved it now, I am trying to make it self-contained.
07:46:27 <tibbe> ?hoogle [a] -> [(Int,a)]
07:46:28 <lambdabot> No matches, try a more general search
07:46:42 <xerox> Lemmih: there aren't any reason why it should live in Cabal/ beside being handy to have it in the same repo...
07:46:54 <Lemmih> tibbe: zip [1..]?
07:47:09 <tibbe> Lemmih, that's it :)
07:47:18 <tibbe> I blame Java
07:47:35 <xerox> Don't mess with Java's @karma.
07:47:55 <tibbe> :D
07:48:44 <int-e> @karma- java
07:48:45 <lambdabot> java's karma lowered to -2.
07:49:04 <int-e> it's fixed ;)
07:49:10 <cjeris>  @karma+ tikal
07:49:16 <xerox> int-e: phew :)
07:49:27 <cjeris> no love?
07:49:27 <int-e> xerox: karma+ is still a bad idea though
07:49:35 <xerox> Indeed.
07:49:36 <int-e> cjeris: too many spaces
07:50:17 <cjeris> @karma+ tikal
07:50:17 <lambdabot> tikal's karma raised to 1.
07:50:27 <tibbe> > let mapWithIndex f xs = map f (zip [1..] xs) in mapWithIndex (\i e -> show i ++ ": " ++ show e) ["one", "two", "three"]
07:50:28 <lambdabot>  Add a type signature
07:50:29 <cjeris> int-e: gotcha, thanks
07:50:35 <tibbe> :(
07:50:38 <Lemmih> (re-@users) When is a user active?
07:50:46 <tibbe> > let mapWithIndex f xs = map f (zip [1..] xs) in mapWithIndex (\i e -> show i ++ ": " ++ show e) ["one", "two", "three"] :: [String]
07:50:47 <lambdabot>    The lambda expression `\ i e -> ...' has two argumentss,
07:50:47 <lambdabot>   but its typ...
07:51:06 <int-e> @help users
07:51:07 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in last 4 hours
07:51:17 <int-e> 4 hours is long.
07:51:37 <inv2004> hi all
07:51:40 <Lemmih> > let mapWithIndex f xs = map f (zip [1..] xs) in mapWithIndex (\(i, e) -> show i ++ ": " ++ show e) ["one", "two", "three"]
07:51:41 <lambdabot>  ["1: \"one\"","2: \"two\"","3: \"three\""]
07:51:46 <inv2004> I'm newnie in haskell
07:52:03 <xerox> inv2004: welcome!
07:52:07 <inv2004> question: case Data.HashTable.lookup base "asd" of ... doesn't work
07:52:16 <tibbe> Lemmih, ah, a tupple
07:52:17 <xerox> ?docs Data.HashTable
07:52:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
07:52:29 <inv2004> should I do do v<- .... case v of ... ?
07:52:31 <inv2004> thx
07:52:40 <inv2004> I saw it
07:52:46 <xerox> inv2004: I'm watching it now hehe
07:52:53 <Lemmih> > let mapWithIndex f xs = map (uncurry f) (zip [1..] xs) in mapWithIndex (\i e -> show i ++ ": " ++ e) ["one", "two", "three"]
07:52:54 <xerox> inv2004: yeah, lookup is an action.
07:52:54 <lambdabot>  ["1: one","2: two","3: three"]
07:53:10 <inv2004> ok
07:53:17 <inv2004> but it doesn't work too
07:53:28 <inv2004> base = Data.HashTable.fromList hashString [("one", Enum 1)]
07:53:35 <inv2004> do v <- Data.HashTable.lookup base "asd"
07:53:39 <inv2004> case v of ...
07:53:47 <xerox> @paste
07:53:48 <lambdabot> http://paste.lisp.org/new/haskell
07:53:51 <xerox> Paste the whole code there
07:53:51 <inv2004> HUGS: ERROR "e3.hs":129 - Last generator in do {...} must be an expression
07:53:54 <inv2004> ok
07:54:06 <tibbe> Lemmih, Martin Fowler wrote a piece on Ruby with collections and closures and I wanted to see how much code was required to implement one of his examples in Haskell
07:54:33 <lisppaste2> inv2004 pasted "hashtable problem" at http://paste.lisp.org/display/25450
07:54:42 <inv2004> wow, cool bot
07:55:00 <Igloo> You need to indent the case 3 spaces, and the Just an Nothing more than that but the same as each other
07:55:00 <xerox> inv2004: you got to indent the case three spaces more
07:55:09 <xerox> Right.
07:55:14 <wkh> tibbe: what article?
07:55:17 <Lemmih> > let mapWithIndex = (. zip [1..]) . map . uncurry in mapWithIndex ((. (": " ++)) . (++) . show) ["one", "two", "three"]
07:55:19 <lambdabot>  ["1: one","2: two","3: three"]
07:55:28 <inv2004> ow
07:55:33 <tibbe> wkh, http://www.martinfowler.com/bliki/CollectionClosureMethod.html
07:55:36 <lambdabot> Title: MF Bliki: CollectionClosureMethod, http://tinyurl.com/qzfo8
07:55:56 <inv2004> xerox: haven't help
07:56:04 <inv2004> ERROR "e3.hs":129 - Last generator in do {...} must be an expression
07:56:06 <wkh> oh yeah, ruby/smalltalk collection methods are some good stuff
07:56:07 <xerox> inv2004: doing like Igloo says?
07:56:19 <wkh> it's how they make up for not having functional stuff in them
07:56:26 <inv2004> I'll repost
07:56:34 <tibbe> Lemmih, heh, @pointless style is nice ;)
07:57:00 <xerox> inv2004: you can annotate the same paste
07:57:03 <Lemmih> inv2004: You may wanna look into Monads, specifically the IO monad.
07:57:33 <lisppaste2> inv2004 pasted "hashtable" at http://paste.lisp.org/display/25451
07:57:43 <Lemmih> inv2004: 'base' isn't actually a HashTable. It's an action that will create a HashTable when it's executed.
07:57:54 <xerox> inv2004: you didn't indent the 'case' 3 spaces more
07:58:07 <inv2004> hm
07:58:10 <xerox> inv2004: it ought to be in the same column as the 'v <-'
07:58:26 <inv2004> ow
07:58:27 <xerox> do { foo ; bar } is equivalent to
07:58:32 <xerox> do foo
07:58:33 <xerox>    bar
07:58:34 <inv2004> insede do .. ? or inside <- ?
07:58:41 <inv2004> ok
07:58:45 <inv2004> thx
07:58:50 <xerox> You're welcome.
07:59:22 <bortzmeyer> I'm looking for a convenient constructor for CalendarTime, to build a CalendarTime from just year, month and day, without having to specify the Wday, Yday, etc
07:59:36 <xerox> bortzmeyer: there's one cool package for that I believe
07:59:49 <lisppaste2> inv2004 pasted "hastable" at http://paste.lisp.org/display/25453
07:59:55 <inv2004> doesn't work
08:00:07 <inv2004> ERROR "e3.hs":129 - Last generator in do {...} must be an expression
08:00:08 <bortzmeyer> xerox: a name for the package so I can search it?
08:00:10 <xerox> bortzmeyer: does this <http://www.cs.chalmers.se/~bringert/darcs/parsedate/doc/api/System-Time-Parse.html> look like what you need?
08:00:30 <xerox> inv2004: hang on
08:00:36 <int-e> Aldaron: hi
08:00:48 <Lemmih> inv2004: Your layout is still messed up.
08:00:51 <Aldaron> int-e: hi
08:00:52 <bortzmeyer> xerox: no, I do not need a parser (I oarse myself) but the conbstructor, once I obtained YYYY-MM-DD
08:01:05 <Aldaron> int-e: I thought maybe I can absorb some understanding -_-
08:01:21 <inv2004> could smone post an example ?
08:01:40 <lisppaste2> xerox annotated #25453 with "Correct versions" at http://paste.lisp.org/display/25453#1
08:01:49 <inv2004> thx
08:01:56 <xerox> bortzmeyer: I am not sure then.
08:02:07 <kowey> inv2004: maybe this would help - http://en.wikibooks.org/wiki/Haskell/Indentation
08:02:38 <bortzmeyer> xerox: thx anyway, I can always build the string and submit it to the parser
08:02:52 <inv2004> so the case should be on the same level like v <- ?
08:02:53 <xerox> bortzmeyer: you're welcome.
08:03:16 <inv2004> ok, thx for help, but it doesn't work: ERROR "e3.hs":130 - Syntax error in expression (unexpected `}', possibly due to bad layout)
08:03:42 <Lemmih> inv2004: GHC(i) usually gives better error messages than Hugs.
08:04:34 <bringert> bortzmeyer: you can steal epoch from http://www.cs.chalmers.se/~bringert/darcs/parsedate/System/Time/Parse.hs
08:04:45 <bringert> use record update syntax to set y m d
08:04:52 <inv2004> looks not luck today :)
08:05:05 <Lemmih> inv2004: (btw, once you get the layout right, your code is still wrong)
08:05:10 <bringert> and go to ClockTime and back to get weekday etc. set correctly if you care about that
08:05:27 <xerox> @karma+ bringert !
08:05:27 <lambdabot> bringert's karma raised to 9.
08:05:41 <bringert> 9?
08:05:45 <lisppaste2> inv2004 pasted "hashtable" at http://paste.lisp.org/display/25456
08:05:46 <xerox> 9.
08:05:46 <bortzmeyer> bringert: No, if I set some fields in a CalendarTime, any attempt to use the object will create errors "invalid time"
08:06:21 <bringert> bortzmeyer: even toClockTime?
08:07:06 <bringert> what have I done to deserve that?
08:07:06 <bortzmeyer> bringert: I did not try using ClockTime yet, I'll try
08:07:15 <bringert> it's a hack
08:07:25 <Lemmih> inv2004: Try using Data.Map instead of Data.HashTable.
08:07:43 <bringert> bortzmeyer: if you have GHC 6.6 (RC) or 6.5, try using the time package instead
08:07:55 <inv2004> the same
08:07:56 <bringert> it has separate types for dates and times
08:08:10 <bringert> and does not keep weekday etc in the date value
08:08:31 <Lemmih> inv2004: Are you getting a type error?
08:08:44 <inv2004> no
08:08:45 <inv2004> ERROR "e3.hs":130 - Syntax error in expression (unexpected `}', possibly due to bad layout)
08:09:05 <Lemmih> inv2004: 130 lines? Try something smaller/simpler.
08:09:09 <inv2004> it was type error, before I've come here
08:10:27 <inv2004> ok
08:10:45 <lisppaste2> inv2004 pasted "example" at http://paste.lisp.org/display/25458
08:10:53 <inv2004> look here, plz
08:11:02 <inv2004> ERROR "test.hs":5 - Last generator in do {...} must be an expression
08:11:10 <Lemmih> > let base = M.fromList [("one",1)] in M.lookup "asd" base :: Maybe Int
08:11:11 <lambdabot>  Nothing
08:11:48 <Lemmih> inv2004: Try 'return True' and 'return False'.
08:12:11 <inv2004> ERROR "test.hs":5 - Last generator in do {...} must be an expression
08:12:15 <inv2004> havn't help
08:12:35 <inv2004> ...Just a -> return True\n...Nothing -> return False
08:13:09 <inv2004> big broblem with simple thing :)
08:13:16 <Lemmih> > let get n = do v <- M.lookup n (M.fromList []); case v of Just () -> return True; Nothing -> return False in get "two" :: Maybe Bool
08:13:17 <lambdabot>  Nothing
08:14:45 <inv2004> ERROR "test.hs":1 - Syntax error in input (unexpected keyword "let")
08:15:39 <inv2004> ups
08:15:48 <lisppaste2> Lemmih annotated #25458 with ""fixed" version" at http://paste.lisp.org/display/25458#1
08:16:35 <inv2004> is M = map ?
08:16:39 <inv2004> Map
08:16:53 <inv2004> ok, will try it home, bb
08:16:54 <Lemmih> inv2004: Haskell isn't like all the other mainstream languages. You really need to read a tutorial.
08:17:13 <xerox> ?remember Lemmih inv2004: Haskell isn't like all the other mainstream languages. You really need to read a tutorial.
08:17:15 <inv2004> Lemmih: ok, there wasn't a problem in ocaml :)
08:17:24 <Lemmih> inv2004: M in lambdabot is Data.Map
08:17:33 <inv2004> and in apl/lisp/... and others :)
08:17:47 <xerox> ...modulo runtime errors? :D
08:17:57 <Lemmih> inv2004: They're not that different from C/C++/Java.
08:18:44 <inv2004> I understand, I just tried  examples
08:18:48 <inv2004> bb
08:21:49 <wkh> i know this isn't #ocaml but no one is there. is there a way to use SSE/SSE2 in haskell/ocaml/lisp/any nice language?
08:21:54 <wkh> processor extensions, that is
08:22:36 <shapr> If your compiler supports it, it should get used automatically.
08:22:46 <ValarQ> hello shapr
08:22:50 <shapr> hej ValarQ
08:22:53 <lispy> xerox: are you calling haskell mainstream?
08:23:02 <wkh> shapr: what compilers support it?
08:23:03 <xerox> Blame Lemmih.
08:23:09 <lispy> heh
08:23:33 <shapr> wkh: Don't know, but you could look at the GHC source and see if amd64 has any specific support.
08:24:17 <xerox> ?quote gaal
08:24:17 <bringert> shapr: if you get something going with the template suff, let me know
08:24:17 <lispy> wkh: with ghc you can link to C quite easily.  So in the worst case you could write special asm that used the instructions and link to it via C
08:24:17 <lambdabot>  (ghc predicted a cpu death on my computer once.)
08:24:23 * xerox giggles
08:24:33 <bringert> shapr: how's your hope project working out?
08:24:52 <shapr> I've been stopped by lack of templates and lack of time.
08:25:57 <shapr> The nice thing about ZPT is that I can write code to complicated stuff and then export the result as a sequence that html using people can then exploit.
08:26:16 <bringert> right
08:26:41 <bringert> I think that the stuff that joel wrote would let you do that
08:26:56 <shapr> Ok, I'll try it when I have time. No ETA on spare time though :-)
08:32:29 <Cale> shapr: hehe, you should make me an op since I'm always around, and so I don't have to go calling IRCops in here every time there's some idiot repeatedly replacing the topic with something obscene :)
08:32:59 <int-e> (which happened earlier today)
08:33:01 -ChanServ(ChanServ@services.)- shapr!n=user@adsl-147-71-76.bhm.bellsouth.net ACCESS [#haskell] ADD cale 39
08:33:11 <Cale> cool :)
08:33:37 <xerox> !
08:33:49 <shapr> xerox: You want ops too?
08:33:57 <xerox> It'd be cool, thank you!
08:34:17 -ChanServ(ChanServ@services.)- shapr!n=user@adsl-147-71-76.bhm.bellsouth.net ACCESS [#haskell] ADD xerox 39
08:34:19 * xerox hugs shapr
08:34:22 * shapr hugs xerox 
08:34:30 <int-e> congrats ;)
08:34:33 <ValarQ> oh no, xerox is an op!
08:34:44 * ValarQ hides
08:34:53 * xerox stares at ValarQ 
08:34:55 <int-e> @yarr
08:34:55 <lambdabot> Yo ho ho, and a bottle of rum!
08:35:06 <int-e> @arr!
08:35:07 <lambdabot> I'll crush ye barnacles!
08:35:23 <ValarQ> xerox: don't give me that hungry look!
08:37:57 <psnl> so how many ops are there?
08:39:11 <shapr> try /msg chanserv #haskell access list
08:41:04 <xerox> Who's dennisb? :)
08:41:41 <psnl> half the channel has ops, it seems
08:41:49 <xerox> ?users
08:41:50 <lambdabot> Maximum users seen in #haskell: 221, currently: 213 (96.4%), active: 36 (16.9%)
08:42:09 <psnl> 17*2=34
08:42:19 <psnl> only two out
08:42:27 <xerox> > 213/17
08:42:29 <lambdabot>  12.529411764705882
08:43:17 <psnl> xerox: I was going by active people
08:43:33 <xerox> Then count active ops :)
08:43:56 <psnl> good point
08:44:03 * shapr grins
08:44:21 <psnl> of course, an op only ops up when needed, very haskelly
08:45:46 <Daveman> xerox :D
08:46:04 <xerox> Hey Daveman :)
08:47:50 <Daveman> Hello :)
09:04:25 <shapr> Oh, I read a bunch more papers recently, I found some great stuff.
09:04:35 <psnl> ooh, go on
09:04:56 * shapr scurfles around
09:05:39 <shapr> Realize that I'm biased because proof programming (generating a program from a proof) is one of my long term goals for programming...
09:06:35 * psnl shrugs
09:06:44 <shapr> I'm trying to find the urls..
09:06:46 <psnl> same difference, really
09:07:28 <psnl> between taking a proof and getting a program and getting a program and seeing a proof
09:10:44 <shapr> slc.math.ist.utl.pt/lcf/pubs/paper6.pdf - A Large-Scale Experiment in Executing Extracted Programs
09:12:24 * psnl frowns at that
09:13:06 <shapr> It seems that the commonly used (only) way to turn a proof into a program right now is Coq to Ocaml or Haskell.
09:13:23 <shapr> I've heard that NuPRL can do something like this as well, but I haven't investigated enough to know what exactly it can do.
09:15:09 <shapr> In any case, the paper lays out the biggest problem involved with this... being that the most abstract proofs are the best (they can then be applied elsewhere) but for efficient programs you want the most concrete.
09:16:14 <shapr> For example, the first version of the derived Haskell/Ocaml source used Peano numbers, was not aware that 0 < 1 and all sorts of other things that slowed down the resulting program.
09:16:22 <psnl> its the normal complier problem really
09:17:52 <shapr> I ended up with a bunch of questions that I'd like to ask about this, but I suspect I'll only understand the answers if I pursue them myself.
09:18:43 <xerox> Can Cabal perform post-install actions?
09:18:45 <psnl> I'ld like to hear your questions, since I can't answer them
09:19:16 <xerox> Namely, I want to do a cp -R.
09:29:06 <deadbeef> http://eclipsefp.sourceforge.net/
09:29:07 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
09:34:55 <xerox> deadbeef: yes?
09:37:57 <deadbeef> > [ chr x | x <- [119, 104, 97, 116, 63] ]
09:37:59 <lambdabot>  "what?"
09:39:47 <deadbeef> the plugin detected the ghc path by itself
09:39:48 <esap> What's the (categorical) limit of a diagram that has two objects and one non-identity arrow between the objects? Is it the exponential object?
09:39:49 <deadbeef> ooh <3
09:46:16 <glguy_> @paste
09:46:16 <lambdabot> http://paste.lisp.org/new/haskell
09:46:47 <lisppaste2> glguy pasted "Reads issue" at http://paste.lisp.org/display/25467
09:46:59 <glguy_> could someone tell me why that can parse "9C" but not "TC" ?
09:47:19 <glguy_> for some reason none of the ranks "TJQKA" parse when I call readCard
09:47:36 <glguy_> but all of the ranks ['2'..'9'] do
09:47:47 <glguy_> and they all work when I just call readRank
09:48:00 <shapr> psnl: Seems to me that turning a thoroughly abstract program into a concrete and efficient program would just be another proof that's of type proof -> proof, it'd be just an optimizer, right?
09:48:05 <Igloo> lex thinks TC is a single lexeme
09:48:07 <xerox> I never used reads so I don't know :(
09:49:49 * araujo back
09:50:30 <glguy_> Igloo: why does it think "KC" is one lexeme and "9C" isn't, also, how do I do this correctly?
09:52:02 <Igloo> Because that's what it does. Just write the code by hand, pattern matching on the string
09:52:15 <xerox> Or use Parsec?
09:52:53 <Igloo> Probably overkill if this is all the parsing needed
09:53:05 <glguy_> I'll match by hand, I'm just surprised the Reads stuff can't handle this
09:53:07 <xerox> But easily extendable.
09:57:05 <glguy> What's the command to get the URL of the source code for lex?
09:57:11 <glguy> lambdabot command
09:57:19 <xerox> ?index lex
09:57:19 <lambdabot> Text.Read, Prelude, Text.Read.Lex
09:57:23 <xerox> ?fptools Text.Read
09:57:23 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read.hs
09:57:26 <xerox> ?fptools Text.Read.Lex
09:57:26 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read/Lex.hs
09:58:40 <glguy> ahh, a lexChar exists
10:00:19 <Syzygy-> What does the notation $= mean?
10:00:24 <dsacode> Hello! Maybe someone had seen DNF\CNF transformation algorithm in Haskell?
10:01:11 <Adamant> @karma++ Scheme
10:01:12 <lambdabot> Scheme's karma raised to 1.
10:01:33 <xerox> Syzygy-: where did you see it?
10:01:33 <Adamant> Lisp in Small Pieces is a wonderful book.
10:01:40 <Syzygy-> http://www.tfh-berlin.de/~panitz/hopengl/skript.html
10:01:47 <Syzygy-> Intro tutorial to hopengl
10:01:55 <Syzygy-> More specifically:
10:01:56 <Syzygy->   displayCallback $= clear [ColorBuffer]
10:02:09 <xerox> http://www.tfh-berlin.de/~panitz/hopengl/skript.html#tthFtNtAAE
10:02:30 <xerox> Syzygy-: see 2.1.1 on that page
10:02:46 <Syzygy-> Ah. Thanks.
10:02:50 <xerox> You're welcome.
10:04:13 <ventonegro> $= is an infix function?
10:04:59 <Syzygy-> Ayup
10:05:07 <Syzygy-> Defined in some OpenGL module.
10:05:10 <glguy> all functions that begin with a symbol are
10:06:18 <ventonegro> i didn't even know it was a function
10:06:27 <ventonegro> thought it was part of the language
10:27:18 * xerox screams
10:27:29 * deadbeef runs through the code naked
10:27:36 <xerox> hahaha
10:27:41 <xerox> You liked that eh.
10:27:48 <deadbeef> i like you <3
10:27:52 <xerox> I was just trying to break the silence.
10:28:00 <deadbeef> (when you run naked through the code)
10:28:20 <xerox> In fact I first saw that joke on #emacs I think, it was bojohan probably.
10:28:30 <xerox> Pretty funny :)
10:40:29 <deadbeef> doccia + esco
10:40:30 <deadbeef> \o
10:40:46 <xerox> ?babel it en doccia + esco
10:40:48 <lambdabot>  shower + I exit
10:40:51 <xerox> Right :)
10:40:58 <deadbeef> ahaha
10:40:59 <deadbeef> bella
10:41:33 <deadbeef> lol sorry wrong chan
10:49:40 <astrolabe> I've finally finished implementing an algorithm at work in haskell
10:49:51 <astrolabe> It took me 2 weeks for 190 lines
10:50:19 <astrolabe> Today I looked at the earlier implentation, which is C++
10:50:30 <astrolabe> it's 10 times as long.
10:50:48 <tibbe> and took you how long to write?
10:50:58 <astrolabe> Someone else did it
10:51:04 <tibbe> ok
10:51:08 <xerox> astrolabe: my gosh.
10:51:12 <xerox> > 190 * 10
10:51:13 <lambdabot>  1900
10:51:14 <astrolabe> About 1 week apparently, but I think he's extrodinary.
10:51:18 <xerox> Yes I counted right...
10:51:41 <astrolabe> And the program is soooo cool!
10:51:43 <tibbe> those factors of ten are difficult, 2^are better
10:52:05 <astrolabe> surely e^x is the most sensible.
10:52:05 <tibbe> astrolabe: what does it do?
10:52:26 <xerox> astrolabe: if you were to invent it instead of translating it maybe it would have taken a different time...
10:52:31 <ventonegro> is there any easier version of lex?
10:52:32 <tibbe> actually I heard that e^x is just a biproduct and it's ln x that's interesting
10:52:49 <ventonegro> one that does not return lists but a single pair
10:52:57 <tibbe> ventonegro: um, you mean alex? there's parsec for parsers
10:52:58 <astrolabe> It works out probabilities of independent random variables subject to the constraint that they don't share values.
10:53:25 <tibbe> ventonegro: oh, I think I missinterpreted you
10:53:57 <astrolabe> where 'subject' means 'conditional on'
10:53:59 <tibbe> astrolabe: even if it took some more time to write it might be more correct and easier to maintain
10:54:00 <xerox> Cale: you around?
10:54:17 <ventonegro> it's just that reading a list of integers from a string should be easier
10:54:19 <astrolabe> tibbe: Absolutely, I'm sure it is.
10:54:53 <astrolabe> ventonegro: what does the string look like?
10:55:19 <ventonegro> "20 100 34 56 12"
10:55:30 <xerox> ventonegro: and what do you need from that?
10:55:53 <ventonegro> [20, 100, 34, 56, 12]
10:55:55 <ventonegro> @paste
10:55:55 <xerox> > map read . words $ "20 100 34 56 12" :: [Int]
10:55:55 <lambdabot> http://paste.lisp.org/new/haskell
10:55:56 <lambdabot>  [20,100,34,56,12]
10:56:32 <ventonegro> words? didn't know this one :-)
10:56:47 * ventonegro is a noob
10:56:52 <xerox> > unwords ["oh","now","you","do"]
10:56:53 <lambdabot>  "oh now you do"
10:57:01 <xerox> There's also lines and unlines.
10:57:07 <Syzygy-> Cooool.
10:57:12 <xerox> !
10:57:30 <astrolabe> xerox would have done my code in a week :(
10:57:40 <xerox> astrolabe is too kind.
10:57:50 <Syzygy-> > read "3.25"
10:57:51 <lambdabot>  Add a type signature
10:58:03 <Syzygy-> > read "3.25" :: Float
10:58:04 <lambdabot>  3.25
10:58:09 <lisppaste2> ventonegro pasted "my string splitter :-)" at http://paste.lisp.org/display/25471
10:58:18 <Syzygy-> Doubly nice. :)
10:58:22 <xerox> :D
10:58:32 <xerox> unwords = concat . intersperse " "
10:58:48 <xerox> But words...
10:59:15 <tibbe> ?hoogle implode
10:59:16 <lambdabot> No matches found
10:59:19 <tibbe> hmm
10:59:31 <tibbe> why isn't there a more generic version of unwords?
10:59:36 <xerox> hehe
10:59:41 <Syzygy-> ?hoogle unwords
10:59:42 <lambdabot> Prelude.unwords :: [String] -> String
10:59:43 <lambdabot> Data.PackedString.unwordsPS :: [PackedString] -> PackedString
10:59:54 <Syzygy-> I'm starting to LIKE lambdabot. :P
11:00:06 <tibbe> give her a hug
11:00:09 <tibbe> @hug
11:00:10 <lambdabot> Maybe you meant: msg run
11:00:15 <tibbe> bah
11:00:23 * Syzygy- hugs lambdabot
11:00:27 <ventonegro> ?hoogle lex
11:00:28 <lambdabot> Prelude.lex :: ReadS String
11:00:28 <lambdabot> Text.Read.Lex.lex :: ReadP Lexeme
11:00:28 <lambdabot> Text.Read.Lex :: module
11:00:29 <tibbe> she can be cold at times
11:00:42 <ventonegro> @cool
11:00:43 <lambdabot> Unknown command, try @list
11:00:48 <ventonegro> :-)
11:00:49 <sieni> @dance
11:00:49 <lambdabot> unexpected end of input: expecting number
11:00:54 <sieni> @dance 7
11:00:55 <lambdabot> 7 => 7
11:01:02 <sieni> wtf?
11:01:03 * tibbe is thinking about writing a CBC library
11:01:24 <Syzygy-> CBC? As in chained block cipher?
11:01:27 <tibbe> writing a crypto library should be much faster now with ByteString, yes?
11:01:28 <xerox> Hmmm.
11:01:30 <tibbe> Syzygy-: yes
11:01:35 <xerox> @dice 3d6
11:01:35 <lambdabot> 3d6 => 11
11:01:37 <xerox> ^- sieni
11:01:47 <Syzygy-> Ye gods. This ghc compile is taking forever...
11:02:31 <lucca> @dice 3d3
11:02:31 <lambdabot> 3d3 => 6
11:02:49 <tibbe> @dice 3d6
11:02:49 <lambdabot> 3d6 => 6
11:03:09 <lucca> d3 is interesting as it's harder to physically construct
11:03:19 <tibbe> I should try to compile latest GHC on gentoo
11:03:27 <tibbe> lucca: :D
11:03:42 <Syzygy-> lucca: You mean ignoring relabeling a d6 as a possibility?
11:03:48 <tibbe> perhaps a somewhat oval dice?
11:04:09 <lucca> Syzygy-: yeah, that's no fair!
11:04:32 <xerox> Got it!
11:04:37 <xerox> If you are still interested...
11:04:53 <tibbe> got what?
11:05:04 <sieni> beer?
11:05:08 <ventonegro> infix functions have higher precedence?
11:05:09 <sieni> milk?
11:05:18 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:); words = splitBy ' ' in words "foo bar baz"
11:05:19 <lambdabot>  ["foo","bar","baz"]
11:05:20 <xerox> More or less
11:05:27 <xerox> (In fact words works even better.)
11:07:10 <tibbe> xerox: do you the reason for having less generic functions suchas lines/words & co ?
11:07:35 <xerox> tibbe: lines/words & duals are handy.
11:07:39 <sieni> how do i shot web?
11:07:55 <tibbe> xerox, should but they could by words = splitBy ' '
11:08:02 <tibbe> s/by/be
11:08:05 <xerox> tibbe: not exactly.
11:08:10 <xerox> > words "foo   bar baz"
11:08:11 <lambdabot>  ["foo","bar","baz"]
11:08:22 <tibbe> alright so it throws away empty lists, but still
11:08:27 <sieni> > words "foo \t bar baz"
11:08:28 <lambdabot>  ["foo","bar","baz"]
11:08:29 <bringert> tibbe: yeah a generic splitBy has been proposed
11:08:35 <sieni> > words "foo \t bar  \n\rbaz"
11:08:36 <lambdabot>  ["foo","bar","baz"]
11:08:41 <bringert> see mailing list archives
11:08:44 <xerox> ?index words
11:08:45 <lambdabot> Data.List, Prelude
11:08:50 <xerox> ?fptools Data.List
11:08:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:09:00 <tibbe> splitBy :: a -> Bool -> [a] -> [[a]]
11:09:07 <tibbe> plus some parens
11:09:16 <xerox> Hmm.
11:09:19 <sieni> >words "a\vb"
11:09:24 <sieni> > words "a\vb"
11:09:26 <lambdabot>  ["a","b"]
11:09:33 <xerox> sieni: what's \v ?
11:09:37 <xerox> Vertical tab?
11:09:41 <sieni> yes
11:09:49 <xerox> Never seen it used... hehe :)
11:10:39 <tibbe> \v = 8 \n ?
11:11:09 <mauke> > map fromEnum "\a\b\n\r\t\v"
11:11:10 <lambdabot>  [7,8,10,13,9,11]
11:11:20 <sieni> > words "a\fb"
11:11:21 <lambdabot>  ["a","b"]
11:11:24 <sieni> ^_^
11:11:37 <sieni> there are lots of whitespace characters ^_^
11:11:41 <inv2004> hi
11:12:07 <tibbe> 6.5 haven't made it into gentoo yet, anyone have an overlay?
11:12:44 <inv2004> main =
11:12:44 <inv2004>   let get n = do
11:12:44 <inv2004>     v <- M.lookup n (M.fromList [])
11:12:44 <inv2004>     case v of
11:12:44 <inv2004>       Just () -> return True
11:12:45 <inv2004>       Nothing -> return False
11:12:47 <inv2004>   in
11:12:49 <inv2004>     get "two"
11:12:51 <inv2004> ups, sorry
11:12:58 <inv2004> it doesn't work
11:13:09 <inv2004> ERROR "test.hs":3 - Unresolved top-level overloading
11:13:09 <inv2004> *** Binding             : main
11:13:09 <inv2004> *** Outstanding context : Monad b
11:14:10 <tibbe> @paste
11:14:11 <lambdabot> http://paste.lisp.org/new/haskell
11:14:12 <twanvl> inv2004: "v <-"  --->  "let v = "
11:14:42 <tibbe> twanvl: why? :)
11:15:32 <xerox> brb
11:15:58 <inv2004> twanvl: let v = do return M.lookup ... in ?
11:18:49 <inv2004> @monads
11:18:49 <lambdabot> Unknown command, try @list
11:18:52 <inv2004> @list
11:18:53 <lambdabot> list [module|command]. Where modules is one of:
11:18:53 <lambdabot> babel base bf compose dice dict djinn drhylo dummy elite eval fact free fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system
11:18:53 <lambdabot> tell todo topic type undo unlambda url version vixen where
11:20:45 <tibbe> @vixen
11:20:46 <lambdabot> there are a lot of weirdos on here
11:21:52 <tibbe> > concat $ repeat "I need 6.6! "
11:21:54 <lambdabot>  "I need 6.6! I need 6.6! I need 6.6! I need 6.6! I need 6.6! I need 6.6! I n...
11:22:52 <int-e> > cycle "6.5 is not enough? "
11:22:54 <lambdabot>  "6.5 is not enough? 6.5 is not enough? 6.5 is not enough? 6.5 is not enough?...
11:23:17 <ventonegro> just typed repeat 42 in ghci :-)
11:23:18 <tibbe> > reverse "on"
11:23:19 <lambdabot>  "no"
11:23:30 <xerox> > fix ("probably not... "++)
11:23:31 <lambdabot>  "probably not... probably not... probably not... probably not... probably no...
11:23:35 <int-e> cycle is so neat.
11:23:41 <Syzygy-> > repeat 42
11:23:42 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
11:23:46 <xerox> cycle = fix . (++)
11:23:55 <ventonegro> had to kill it
11:23:58 <int-e> obviously
11:24:10 <ventonegro> ?hoogle fix
11:24:11 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:24:11 <lambdabot> Control.Monad.Fix :: module
11:24:11 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
11:24:19 <inv2004> lambdabot: monads ?
11:24:25 <int-e> ventonegro: are you on windows?
11:24:28 <xerox> inv2004: hmm?
11:24:29 <tibbe> read the paper on cata/ana/hylo-morphism earlier, the category theory killed me half way through
11:24:33 <inv2004> lament: data.datatable
11:24:39 <ventonegro> int-e: unfortunately
11:24:42 <xerox> ?remember inv2004 lambdabot: monads ?
11:24:43 <twanvl> inv2004: you are using v as type Maybe (), if you use v <- M.lookup then the do block will become of the monad type, while v is the same type as the elements of the map. Although, on second thought, that could be what you want...
11:24:43 <xerox> hehe
11:24:48 <inv2004> xerox: steel doen't work
11:24:54 <int-e> I see
11:25:06 <int-e> data.debatable?
11:25:09 <Syzygy-> tibbe: Link to the paper?
11:25:20 * Syzygy- thinks he may be able to handle the CT... :P
11:25:41 <tibbe> Syzygy-: have it at work, it's in the #haskell logs of today
11:25:49 <inv2004> ups
11:25:51 <inv2004> hashtable :)
11:25:59 <tibbe> Syzygy-: search my name, although I spam alot so it can be a bit difficult to find ;)
11:27:17 <xerox> http://citeseer.ist.psu.edu/meijer91functional.html
11:27:29 <xerox> Was it this one?
11:27:44 <tibbe> xerox: yes, I actually got the CT up to a certain point
11:28:01 <tibbe> xerox: then I got overwhelmed by the definitions
11:28:10 <Syzygy-> tibbe: Welcome to algebra. :P
11:28:16 <tibbe> I'm human, I can keep 6-9 things in my mind at once
11:29:02 <tibbe> Read the first chapter of a CT book after, now my mind need to absorb it
11:29:06 <sieni> argh, I _hate_ darwinports
11:35:26 <chandler> Is Kristof Bastiaensen here?
11:38:07 <chandler> well, thanks to Kristof (whoever he is), there is now Haskell syntax support for lisppaste
11:38:20 <chandler> It's the default for any new pastes here.
11:38:24 <kuribas`> chandler: is there?
11:38:27 <xerox> chandler: great!!
11:38:54 <chandler> kuribas`: ah, there you are. Yes, I just added it.
11:39:07 <chandler> kuribas`: you can view some of the recent pastes to #haskell to see it in action
11:39:12 <chandler> http://paste.lisp.org/list/haskell
11:39:36 <xerox> Nice :)
11:39:43 <xerox> @karma+ kuribas`
11:39:44 <lambdabot> kuribas`'s karma raised to 1.
11:40:44 <chandler> anyway, that's all I had :-)
11:41:21 <kuribas`> Well, if there is a problem please notify me.
11:42:44 <swiert> tibbe: if you're trying to learn about all the cata/hylo/anamorphisms, you might like this paper:http://citeseer.ist.psu.edu/rd/0%2C118236%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/3492/http:zSzzSzalfa.di.uminho.ptzSz~afp98zSzPAPERSzSzLex.pdf/augusteijn98sorting.pdf
11:42:57 <swiert> Hmm, I pasted that twice somehow.
11:44:27 <tibbe> swiert: could you repaste it please?
11:45:02 <kuribas`> Oh, old pastes are highlighted to :)
11:45:35 <ndm> has anyone tried out the SPOJ puzzles?
11:45:40 <ndm> http://www.spoj.pl/problems/MUL/
11:45:42 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem MUL
11:45:51 <ndm> can anyone write a solution to that in Haskell that runs fast enough?
11:46:04 <ndm> @paste
11:46:04 <lambdabot> http://paste.lisp.org/new/haskell
11:46:13 <lisppaste2> ndm pasted "SPOJ MUL" at http://paste.lisp.org/display/25480
11:46:30 <ndm> thats what i tried, and that takes too long - but i'd have thought Haskell would be pretty fast at that
11:47:07 <swiert> tibbe: http://citeseer.ist.psu.edu/rd/0%2C118236%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/3492/http:zSzzSzalfa.di.uminho.ptzSz~afp98zSzPAPERSzSzLex.pdf/augusteijn98sorting.pdf
11:47:15 <swiert> That's odd.
11:47:18 <swiert> Hang on.
11:47:52 <swiert> It's just one really long link.
11:49:11 <tibbe> swiert: got it, thanks
11:49:48 <Philippa_> ndm: read is pretty slow
11:50:08 <ndm> Philippa_: that slow?
11:50:10 <ndm> to time out?
11:50:23 <Philippa_> oh, wait, read the problem properly
11:50:26 <Philippa_> no, not that slow
11:50:33 <Philippa_> did you compile with optimisations?
11:50:57 <ndm> i don't compile, they do
11:51:09 <ndm> i am half suspecting the answer is no
11:51:20 <ndm> can i turn on -O wiht # OPTIONS_GHC ?
11:51:29 <Philippa_> dunno
11:52:23 <Philippa_> if they're compiling without optimisations, you'll get potentially asymptotically worse performance :-(
11:53:20 <ndm> ah well, have resubmitted with -O
11:53:48 <ndm> Philippa_: time limit exceeded, again
11:54:30 <Philippa_> do you know what the time limit is?
11:54:34 <int-e> 6.4.1 still had naive code for show - that could matter, too.
11:54:50 <Philippa_> and that it's not the compilation that's timing out, or worse yet RTS overhead?
11:54:52 <ndm> 12 seconds time limit
11:54:54 <irgs> ndm: do you know how haskell multiplys large numbers?
11:55:00 <ndm> irgs: GMP
11:55:01 <int-e> uses gmp
11:55:13 <ndm> its not compilation, its at runtikme
11:57:26 <Philippa_> 2s, looking at that page
11:58:14 <irgs> hmm, ok so that shouldn't be the issue.. ;)
11:58:39 <Philippa_> try using getLine repeatedly rather than mapMing?
11:58:48 <Philippa_> I suspect getLine is faster than lines
11:58:53 <ndm> its easy enough to register :)
11:59:02 <Philippa_> especially when interacting with read
11:59:04 <mauke> ACODE, ONP, ACT, DELCOMM, JULKA, FCTRL2, CANTON and FOOL are definitely solvable in haskell :-)
12:03:02 <lisppaste2> ndm pasted "Still too slow" at http://paste.lisp.org/display/25481
12:08:11 <lispy> @type map return
12:08:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> [m a]
12:08:25 <lispy> sort of unsequence
12:08:34 <lispy> @type fmap return
12:08:35 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Functor f, Monad m) => f a -> f (m a)
12:08:45 <lispy> @type mapM return
12:08:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
12:10:13 <sjanssen> hmm, maybe I should go through and convert some of my C++ entries to Haskell
12:12:15 <shapr> @users
12:12:17 <lambdabot> Maximum users seen in #haskell: 225, currently: 221 (98.2%), active: 37 (16.7%)
12:14:01 <araujo> yay!
12:14:04 <araujo> @yarr!
12:14:04 <lambdabot> I want me grog!
12:15:29 <Syzygy-> Ummmm. There is this one mode where you feed the Haskell compiler a file wiht lots and text, and the actual code prepended with >, right? Do I have to do anything to trigger this behaviour?
12:16:11 <Syzygy-> Or in other words - I just wrote a bunch of lines expecting this behaviour, and get "Flow.hs:1:22: parse error on input `of'" referring to my commenting text
12:16:37 <araujo> @where literal haskell
12:16:38 <lambdabot> I know nothing about literal.
12:16:51 <Igloo> Call it Flow.lhs
12:16:54 <araujo> @google literal haskell
12:16:56 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2002-March/002907.html
12:16:57 <lambdabot> Title: literal haskell mode (nice :)
12:17:23 <Syzygy-> Ooooooh! And the emacs mode immediately stopped highlighting my text! :)
12:17:32 <dcoutts__> shapr: :-(
12:17:56 <dcoutts__> shapr: where do you live now? sounds a bit dramatic
12:18:20 <Igloo> dcoutts__: Where's the context/
12:18:49 <dcoutts__> pm
12:19:17 <Igloo> Oh, OK
12:19:25 <lispy> Syzygy-: M-x haskell-mode RET
12:19:37 <Syzygy-> lispy: I alreadyt have the haskell-mode loaded.
12:19:39 <dcoutts__> @seen shapr
12:19:40 <lambdabot> shapr is in #haskell. I last heard shapr speak 7m 24s ago.
12:19:44 <Syzygy-> The issue was naming it .lhs not .hs
12:27:07 <Pupeno_> PHP is a minor evil perpetrated and created by incompetent amateurs, whereas Perl is a great and insidious evil, perpetrated by skilled but perverted professionals.
12:27:17 <Pupeno_> Jon Ribbens
12:30:05 <glguy> I just saw that linked from Digg
12:30:29 <glguy> is there a better way to do this: fromJust $ foldl1 mplus myListOfMaybes
12:30:59 <glguy> head $ fromJust $ sequence myListOfMaybes
12:31:05 <glguy>  but better than that
12:31:31 <glguy> (actually, the last one breaks
12:31:32 <tibbe> msum something perhaps?
12:31:41 <tibbe> @hoohle msum
12:31:42 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
12:31:42 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
12:31:46 <glguy> msum, perfect
12:31:47 <glguy> thanks
12:31:48 <tibbe> lambdabot is too smart
12:31:52 <tibbe> you're welcome
12:32:04 <tibbe> it doesn't do fromJust though
12:32:11 <glguy> yeah, I saw that :)
12:32:11 <sjanssen> glguy: you probably don't want foldl -- foldr is usually better
12:32:15 <tibbe> msum [Nothing, Nothing]
12:32:22 <tibbe> > msum [Nothing, Nothing]
12:32:24 <lambdabot>  Add a type signature
12:32:29 <tibbe> > msum [Nothing, Nothing] :: Maybe
12:32:30 <lambdabot>    `Maybe' is not applied to enough type arguments
12:32:30 <sjanssen> I mean, foldr is better in this case
12:32:30 <lambdabot>   Expected kind `?', b...
12:32:36 <tibbe> > msum [Nothing, Nothing] :: Maybe Int
12:32:38 <lambdabot>  Nothing
12:33:09 <sjanssen> > foldl1 mplus $ repeat (Just 'a')
12:33:13 <lambdabot> Terminated
12:33:18 <sjanssen> > foldr1 mplus $ repeat (Just 'a')
12:33:20 <lambdabot>  Just 'a'
12:33:42 <xerox> > catMaybes [Just 1, Nothing, Just 2, Nothing]
12:33:43 <lambdabot>  [1,2]
12:33:45 <xerox> :)
12:40:11 <Syzygy-> Is there a way to get Haskell to forget something earlier defined?
12:40:25 <xerox> Redefine it, it has lexical scoping... if that's what you mean.
12:40:50 <mauke> haskell does not forget nor forgive
12:41:33 <Syzygy-> Well... I'm trying to write myself a tutorial on HOpenGL, using a tutorial, as a lexical source file, and with incrementingly more complex handling of stuff. So, in my second iteration, ghc complains about me declaring Main.main multiply.
12:41:38 * xerox screams
12:41:45 <xerox> Never do your hacking in /tmp
12:41:48 <xerox> :(
12:42:03 <Syzygy-> xerox: Huh?
12:42:22 <xerox> I have lost my stuff when I moved the computer (turning it off). Silly me.
12:42:48 <Syzygy-> xerox: Doh .Yah, that's kinda silly. :)
12:43:09 <xerox> http://hackage.haskell.org/~paolo/darcs/cabal-install
12:43:12 <lambdabot> Title: Index of /~paolo/darcs/cabal-install, http://tinyurl.com/mlbx5
12:43:22 <xerox> Oh! I've uploaded it!
12:43:22 <glguy> I'm doing some sweet Maybe monad hackery for my poker hand comparer
12:43:27 * xerox congratulates himself
12:43:30 <xerox> Phew...
12:43:56 <tibbe> xerox: yeah!
12:45:56 <lisppaste2> glguy pasted "solveHand function abusing Maybe" at http://paste.lisp.org/display/25489
12:47:57 <glguy> allowing magic like: tryStraightFlush = guard flush >> fmap StraightFlush straight
12:48:14 <sjanssen> @hoogle accumArray
12:48:15 <RobHu> Why do I get Test3.hs:5:5: Malformed LHS to type of class declaration with
12:48:15 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
12:48:15 <lambdabot> Data.Array.accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
12:48:15 <lambdabot> Data.Array.IArray.accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
12:48:20 <RobHu> data my_Maybe a = Nothing
12:48:20 <RobHu> | Just a
12:48:27 <RobHu> Where the | is lined up with the =
12:48:45 <mauke> type names must start with a capital letter
12:48:50 <glguy> for one thing, you might need to use my_Nothing and my_Just
12:48:52 <RobHu> oops
12:48:53 <RobHu> Stupid me
12:50:44 <cwenner> do you know of any browser-runable interactive haskell 'compilers'?
12:51:58 <glguy> You want a java applet?
12:52:27 <dcoutts__> Haskell interpreter in JavaScript!
12:52:32 * dcoutts__ runs away
12:52:51 <dcoutts__> xerox: do we have some summary of the SoC results? how many people finished ok?
12:53:09 <glguy> cwenner: I'm pretty sure what you are looking for does not exist
12:54:07 <glguy> closest thing to it might be lambdabot (for one-liners)
12:54:42 <tibbe> if I knew how boring this internship would turn out if would have participated in SoC
12:55:13 <ndm> dcoutts__, not the Yhc guy, apparently
12:55:30 <dcoutts__> oh yeah, of course
12:55:48 <cwenner> i was thinking something like a port ghci session to a page
12:56:07 <dcoutts__> and the compiler itself is in that bytecode too
12:56:12 <ndm> cwenner: Lambdabot is going to be ported to a web page (hopefully), so that would do it
12:56:22 <dcoutts__> so yhi should work in a javascript page :-)
12:56:36 <dcoutts__> heh, cool
12:57:06 <cwenner> okay, thanks, kind of need it now so i'll go tweak a bit
12:57:30 <xerox> dcoutts__: not yet. The survey will be finished on the 8th.
12:57:39 <dcoutts__> ok, cool
12:57:58 <xerox> dcoutts__: I was thinking about mailing the Haskell.org people involved for some feedback thouch
12:58:00 <xerox> *though
12:58:02 <RobHu> could someone please suggest why this simple example from page 50 of the YAHT fails ? http://www.cyrius.com/debian/cobalt/sarge.html
12:58:05 <RobHu> oops
12:58:11 <RobHu> http://rafb.net/paste/results/Q83HZd12.html
12:58:17 <dcoutts__> xerox: it'd be nice to know
12:58:33 * xerox didn't complete the sourvey yet ..cough.
12:58:47 <waern> I completed it pretty quickly
12:58:57 <xerox> waern: what did you work on?
12:59:00 <xerox> It's pretty long.
12:59:08 <waern> yeah, maybe I was too quick with it :)
12:59:14 <waern> xerox, haddock
12:59:21 <xerox> How did go?
12:59:37 <waern> xerox, it went fine..
12:59:49 <waern> xerox, still lots of things to work on though
13:00:04 <xerox> waern: same here :)
13:00:13 <xerox> mauke: ping
13:00:18 <waern> right now I'm looking at the cabal sources and trying to figure out where to insert haddock 2 support
13:00:30 <RobHu> Is it something I'm doing wrong or is the YAHT example wrong?
13:00:47 <xerox> waern: cabal has got haddock support right? One can do cabal-setup doc
13:00:51 <xerox> (or docs..)
13:01:09 <mauke> xerox: pong
13:01:13 <ndm> waern: make sure you keep the hoogle/haddock stuff in cabal working :)
13:01:13 <waern> yeah.. but haddock 2's interface is not the same as the old one
13:01:18 <xerox> mauke: do you have a moment for a perl issue?
13:01:31 <waern> ndm, ehehe..
13:01:45 <mauke> xerox: try it and see :-)
13:02:02 <waern> my thought was just to check for "haddock 2" and then do something specific
13:02:17 <waern> so you shouldn't worry about it
13:03:08 <waern> xerox, how did you project go?
13:03:17 <xerox> waern: still moving
13:03:26 <xerox> waern: I'm about asking haskell-cafe people to try it out though
13:03:27 <waern> it's cabal-install right?
13:03:35 <RobHu> Hello
13:03:43 <RobHu> Can anyone help me please?
13:03:47 <RobHu> I just can't figure this out
13:04:20 <mnislaih> go ahead RobHu
13:04:36 <RobHu> thankyou :-)
13:04:40 <RobHu> My problem is here: http://rafb.net/paste/results/Q83HZd12.html
13:04:43 <xerox> waern: right.
13:04:45 <RobHu> perhaps I'm using it wrong
13:04:48 <RobHu> I am just learning
13:05:21 <waern> xerox, it's using hackage, right?
13:05:28 <xerox> waern: ENOHACKAGE
13:05:36 <waern> hm?
13:05:37 <xerox> waern: there is no "smart server" anymore, that is.
13:05:51 <RobHu> mnislaih: Its a quoted example from YAHT
13:05:59 <xerox> waern: the packages are kept in a directory hierarchy, the index is a tarball of all the .cabal files in the hierarchy.
13:06:03 <RobHu> mnislaih: I assume I'm just calling it incorrectly
13:06:13 <mnislaih> RobHu: sorry, I know YAHT but  haven't read it myself
13:06:28 <mnislaih> RobHu: as first argument you are passing it  3, maybe it should be (==3) ?
13:06:31 <waern> xerox, hm okay
13:06:44 <RobHu> mnislaih: Thats it!
13:06:46 <RobHu> mnislaih: Thankyou
13:06:53 <xerox> waern: it's pretty handy
13:06:57 <waern> xerox, I bet =)
13:07:03 <RobHu> mnislaih: Thats wierd, the tutorial has never shown (==3) although I understand what it means
13:07:03 <mnislaih> RobHu: it is clear from its type that findElement expects a predicate as first argument
13:07:15 <xerox> waern: this way, like darcs repositories, "hackage" repositories are just movable with a tarball, a wget, a cp, or something
13:07:33 <mnislaih> RobHu: (==3) is the same as (\x->x==3)
13:07:34 <RobHu> mnislaih: Which bit makes that clear? The (a -> Bool) ?
13:07:37 <waern> xerox, okay...
13:08:03 <mnislaih> RobHu: yay. ut now
13:08:05 <waern> xerox, sounds good
13:08:08 <mnislaih> RobHu: yay. But now that I think, I don't see an Eq type constraint
13:08:24 <RobHu> mnislaih: The (a -> Bool) confuses me
13:08:39 <xerox> waern: yeah! If you want to give it a try, stay tuned on haskell-cafe. I will need bug reports.
13:08:52 <mnislaih> RobHu: why? It's the type of the functions that take an a and return a Bool
13:08:59 <waern> xerox, ok.. I'll probably try it out
13:08:59 <xerox> (And it'd be handy to have them from IRC people because it's easier to talk with them and debug if needed)
13:09:02 <xerox> Thanks!
13:09:23 <RobHu> mnislaih: Ah I see
13:10:55 <RobHu> mnislaih: so... myFunc :: [a] -> b -> (c -> Bool) -> a, would be a function that takes a list of a's, a b, and a function that takes a c and returns a bool, and then returns an a?
13:11:26 <mnislaih> RobHu: yep
13:11:51 <RobHu> mnislaih: Awesome
13:11:57 <RobHu> mnislaih: Thank you so much :-)
13:12:15 <mnislaih> RobHu: nop
13:12:24 <tibbe> > cycle "this compile will never end... "
13:12:26 <lambdabot>  "this compile will never end... this compile will never end... this compile ...
13:17:02 <shapr> @seen SyntaxNinja
13:17:03 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 2d 21h 23m 7s ago, and .
13:17:11 <inv2004> @post
13:17:12 <lambdabot> Maybe you meant: list part paste
13:17:26 <inv2004> @parte
13:17:27 <lambdabot> Maybe you meant: part paste
13:17:31 <inv2004> @paste
13:17:31 <lambdabot> http://paste.lisp.org/new/haskell
13:17:51 <lisppaste2> inv2004 pasted "1st example" at http://paste.lisp.org/display/25494
13:18:29 <inv2004> it's the first example from A Gentle Introduction, but it doesn't work in HUGS!
13:18:42 <tibbe> inv2004: some import needed?
13:19:15 <inv2004> where's nothing about it
13:19:33 <mnislaih> inv2004: what's your error
13:19:56 <inv2004> ERROR "test.hs":6 - Last generator in do {...} must be an expression
13:20:22 <mnislaih> ah. make sure that you don't use tabs
13:20:33 <mnislaih> in your .hs file
13:20:39 <mnislaih> tabs = problems
13:20:49 <inv2004> thx
13:20:55 <inv2004> it was a problem :)
13:24:37 <kzm_> I just discovered that ghc 6.4.1 is much more efficient than 6.5 - GC time for my test case is 20% and 50%, respectively.
13:25:05 <kzm_> However, I suspect this could be due to a newer FPS for 6.4.1 (0.8 vs 0.7 shipped with ghc 6.5).
13:25:20 <kzm_> Is that plausible?
13:27:30 <shapr> kzm_: yes
13:28:20 <kzm_> Is there a newer fps in recent ghc's?
13:29:04 <kzm_> Or do I have to choose between a curren fps and a current ghc? :-(
13:31:11 <sjanssen> kzm_: one alternative is to remove Data.ByteString from the base package and then install fps separately
13:32:01 <kzm_> Hm. Yes.  I'd rather not muck with base, but perhaps that is the easiest way.
13:32:34 <kzm_> Anyway, I'm compiling 0.7 with 6.4.1, to see if I get the same poor GC behavior.
13:32:48 <inv2004> lambdabot: Data.HashTable
13:33:10 <kzm_> Que?
13:33:21 <inv2004> lambdabot: Data.HashTable
13:33:21 <sjanssen> or you could just merge the code from fps 0.8 to base, I'm surprised that nobody has done that yet
13:35:42 <shapr> inv2004: privet!
13:38:02 <inv2004> shapr: PREVED!
13:38:25 <kzm_> Hmm... how do I specify version in build-depends in cabal?
13:40:37 <vincenz> shapr is back \o/
13:40:54 <profmakx> Syzygy-_ stole my favorite nick
13:41:02 <dmhouse> Evening all.
13:41:20 <dmhouse> ?tell kowey holidays are over, so work should restart on the wikibook promptly.
13:41:21 <lambdabot> Consider it noted.
13:41:27 <dmhouse> ?seen kowey
13:41:28 <lambdabot> I saw kowey leaving #haskell and #darcs 3h 31m 1s ago, and .
13:41:38 <inv2004> lambdabot: M.fromList
13:42:52 <Syzygy-> profmakx: I did?
13:42:54 <big> list
13:42:57 <profmakx> nope Syzygy-
13:43:03 <profmakx> but i like that word ;)
13:43:06 <Syzygy-> :)
13:43:28 <dmhouse> profmakx, Syzygy-: it's an actual word?
13:43:35 <profmakx> yeah
13:43:50 <profmakx> hilbert used it iirc
13:44:07 <dmhouse> What does it mean?
13:44:39 <profmakx> i only know it from my invariant theory lectures
13:45:34 <profmakx> for a tuple of polynomials (f_1,...,f_n) a syzygy is another tuple (g_1,...,g_n) such that f_1*g_1+...+f_n*g_n = 0
13:45:37 <profmakx> (iirc)
13:46:35 <Syzygy-> More generally, it's a measure of relations between defining relations for an algebraic entity.
13:47:16 <Syzygy-> So, for instance, for an ideal defining an algebraic curve/variety, the first order syzygies are relations between the generators of thta ideal
13:47:44 <Syzygy-> Repeated syzygies give free resolutions - which are cool things in homoogical algebra; and this in turn is why I like them.
13:48:09 <profmakx> free as in beer or free as in free group?
13:48:34 <Syzygy-> as in free over the ring.
13:48:43 <Syzygy-> Not necessarily as in beer
13:48:56 <profmakx> so more like in free group ;)
13:49:05 <Syzygy-> Ayup
13:49:10 <profmakx> can one use it in computational algebra?
13:50:03 <kzm_> Sigh.  Apparently it isn't sufficient to ghc-pkg hide later versions, they must be unregister'ed...
13:50:12 <Syzygy-> I did my M.Sc. building a program calculating the growth of the thingies in a very specific case, using a specific theorem. Other than that, you can calculate it using Grobner bases - and you can use it to tell you other stuff about the algebra.
13:50:30 <profmakx> hmm
13:50:47 <profmakx> seems like the application we had in invariant theory of finite groups
13:51:18 <profmakx> -seems+sounds
13:51:29 <Syzygy-> Yah
13:52:17 <tibbe> alright, how many of you don't have a phd? hand up
13:52:21 * tibbe raises a hand
13:53:04 <Syzygy-> Not yet... I'm working on it.
13:53:04 <Oejet> Hehe.
13:53:37 * tibbe feels a bit underqualified
13:53:41 * shapr too
13:54:07 <shapr> tibbe: I never took any CS courses.
13:54:17 <shapr> And I don't have any sort of degree at all.
13:54:18 <tibbe> perhaps we should change the title to #haskell - You'll feel dumb ;)
13:54:22 <CosmicRay> shapr!
13:54:30 <shapr> I was vaguely close to an art degree at one point.
13:54:38 <shapr> hiya CosmicRay! Your blog post worked, I've been converted.
13:54:39 <tibbe> shapr: that gives a glimmer of hope
13:54:43 <CosmicRay> tibbe: I don't have a degree either
13:54:45 <CosmicRay> shapr: hehe
13:54:46 <Oejet> Bah, a Ph.D. is just means some extra letters to type on your name tag in prison.
13:54:52 <shapr> I now prefer SIP over gtalk or skype
13:55:02 <CosmicRay> shapr: oh, woohoo ;-)
13:55:12 <tibbe> CosmicRay: what blog post?
13:55:15 <CosmicRay> shapr: I thought you were referring to my recent Haskell-related posts
13:55:20 <shapr> CosmicRay: and I spent $30 on voxee because you recommended them.
13:55:29 <shapr> And it's already saved me three times that in phone costs.
13:55:34 <CosmicRay> nice
13:56:06 <CosmicRay> tibbe: I suspect he means: http://changelog.complete.org/posts/375-Google-Talk-And-Skype-Are-Boring,-And-Heres-Why.html
13:56:11 <lambdabot> Title: Google Talk And Skype Are Boring, And Here's Why - The Changelog, http://tinyurl.com/fp784
13:56:12 <shapr> yup that's it
13:56:29 <shapr> CosmicRay: You wrote that post because I was advocating gtalk and skype on #haskell
13:56:47 <CosmicRay> shapr: wow, I had forgotten that part.
13:56:50 <shapr> So I investigated, and discovered that you were absolutely correct.
13:57:05 <shapr> In fact, I have a sip client for my Nokia 770.
13:57:18 <CosmicRay> shapr: cool
13:57:19 <shapr> This way I can make phone calls to anywhere in the world from a wifi hotspot.
13:57:35 <CosmicRay> that's pretty slick.  We have some wifi SIP phones here but I haven't tried that yet
13:59:00 <CosmicRay> shapr: do you have an Asterisk box as well?
13:59:08 <kzm_> Hmm...I still get better performance with 6.4.1 than with 6.5.
13:59:40 <Dino_> shapr: Speaking of, I recently got a n770.
13:59:40 <tennin> who will be in Portland next week?
14:00:14 <CosmicRay> shapr: is hugs running on that 770? ;-)
14:00:30 * xerox is also very much interested in the SIP Thing.
14:00:38 <xerox> No time to investigate today, though.
14:00:45 <tibbe> CosmicRay: is there a good and easy to setup windows client software for SIP?
14:01:21 <CosmicRay> tibbe: Yes, just a sec...
14:01:52 <tibbe> cause my girl friend need to be able to install it herself as she's in Sweden and I'm in France
14:01:58 <tibbe> I'll need a linux client as well
14:02:16 <CosmicRay> tibbe: there are several linux clients (kphone, linphone -- linphone is probably the best)
14:02:32 <tibbe> does ekiga do SIP?
14:02:38 <CosmicRay> tibbe: there are evern more windows clients.  The *good* part of the question is the more complicated part.
14:02:57 <CosmicRay> tibbe: yes
14:03:03 <tibbe> ease of use is probably the most important part for me as she's not very tech savvy
14:03:05 <Oejet> tibbe: Poor you, that is a long way to your girlfriend.
14:03:32 <tibbe> Oejet: yes, very poor me indeed :'(
14:03:36 <CosmicRay> tibbe: http://www.voip-info.org/tiki-index.php?page=VOIP+Phones#id363973
14:03:39 <lambdabot> Title: VOIP Phones - voip-info.org, http://tinyurl.com/kfxxo
14:04:02 <CosmicRay> shapr: I wrote an Asterisk article for Free Software Magazine recently: http://www.freesoftwaremagazine.com/articles/asterisk_intro
14:04:04 <lambdabot> Title: Asterisk, http://tinyurl.com/zxp3d
14:04:17 <tibbe> CosmicRay: that's quite a long list, could you recommend something?
14:04:33 <Dino_> I'd actually like to be able to build gui software written in H for the 770.
14:05:21 <CosmicRay> pulver communicator is said to be good.  also sjphone is a very nice one, IIRC, that works on both Windows and Linux (Java)
14:05:27 <CosmicRay> http://www.sjlabs.com/
14:05:29 <lambdabot> Title: SJ Labs, the softphone factory
14:06:19 <CosmicRay> oh, sipxphone too, I think.
14:06:29 <CosmicRay> disclaimer: I don't do Windows, so this is just what I've heard from memory.
14:06:38 <bringert> tennin: I will
14:06:52 <Syzygy-> tibbe: Please tell me if you find something worthwhile. I'll probably swap once I callde off my current Skype balance.
14:07:12 <Syzygy-> Have almost exactly the same problem. I'm in Germany, she's in Sweden, and she's very much not tech-savvy.
14:07:19 <tibbe> Syzygy-: sure
14:07:37 <Oejet> Syzygy-: Poor you too.
14:07:44 <tennin> are there any plans for Haskell people to meet before the conference?
14:07:58 <Syzygy-> What conference? where?
14:08:01 <CosmicRay> to just get started with calling over the net, though, just go to fwdnet.net and download their communicator
14:08:05 <tennin> ICFP in Portland
14:08:09 <Syzygy-> Ah
14:08:11 * tibbe doesn't understand how software vendors can not put screenshots on their product pages.
14:08:20 <tibbe> CosmicRay: ok
14:09:11 <bringert> tennin: well, there's Haskell Workshop, that's before ICFP  :-)
14:09:17 <bringert> and the ghc hackathon
14:10:38 <bringert> ndm: who's doing the lambdabt to web port?
14:10:51 <ndm> bringert: dons, he just doesn't know it yet :)
14:10:53 <tennin> something less formal?
14:11:01 <ndm> bringert: or rather he does, and i'm trying to persuade him
14:11:11 <kosmikus> tennin: when do you arrive?
14:11:19 <bringert> tennin: I don't know of anything, but of course we should do that
14:11:29 <tennin> I'm there now
14:11:32 <kosmikus> during the hackathon would be best for me
14:11:35 <CosmicRay> that's the nice thing about dons.  he never turns down a haskell project.
14:11:44 <glguy> @hoogle a -> [a] -> [b] -> b
14:11:45 * bringert has already promised to buy beer for kosmikus
14:11:46 <lambdabot> No matches, try a more general search
14:12:17 <kosmikus> I might have plans on saturday and sunday night already ...
14:12:18 <bringert> ndm: I might give it a shot if I find some time
14:12:24 <int-e> hah. got the fast multiplication to work with Haskell. (but the code is not pretty)
14:12:54 <ndm> bringert: cool
14:13:00 <ndm> int-e: care to paste it?
14:13:04 <ndm> int-e: and did you BCD?
14:13:13 <glguy> let f a xs ys = findIndex (==a) >>= \index -> ys !! index in f 2 [1..5] ['a'..'e']
14:13:20 <glguy> > let f a xs ys = findIndex (==a) >>= \index -> ys !! index in f 2 [1..5] ['a'..'e']
14:13:20 <lambdabot>  Couldn't match `Int' against `Maybe Int'
14:13:31 <glguy> > let f a xs ys = findIndex (==a) xs >>= \index -> ys !! index in f 2 [1..5] ['a'..'e']
14:13:32 <lambdabot>  Couldn't match `Maybe b' against `Char'
14:13:36 <int-e> ndm: no bcd. I only tuned read and show
14:13:47 <glguy> > let f a xs ys = findIndex (==a) xs >>= \index -> return (ys !! index) in f 2 [1..5] ['a'..'e']
14:13:49 <lambdabot>  Just 'b'
14:13:53 <dcoutts__> shapr: things ok?
14:13:55 <ndm> int-e: what does it reduce the time by?
14:13:58 <glguy> is there a library function that does something like that?
14:14:38 <int-e> ndm: factor of 5? anyway by crazy amounts
14:14:44 <int-e> @where paste
14:14:44 <lambdabot> http://paste.lisp.org/new/haskell
14:15:09 <lisppaste2> int-e pasted "'fast multiplication'" at http://paste.lisp.org/display/25497
14:15:48 <int-e> note that the jtos code is exactly what is in the base libs since 6.4.2 but SPOJ uses 6.4.1
14:15:50 <glguy> > let f a b c = fmap (c !!) (findIndex (==a) b) in f 3 [2..6] ['a'..'e']
14:15:51 <lambdabot>  Just 'b'
14:16:05 <ndm> wow
14:16:17 <mauke> @pl \ k xs ys -> fmap snd $ lookup k (zip xs ys)
14:16:18 <lambdabot> ((fmap snd .) .) . (. zip) . (.) . lookup
14:16:37 <int-e> the divide and conquer read seems to be a good idea.
14:16:44 <mauke> > (((fmap snd .) .) . (. zip) . (.) . lookup) 3 [2..6] ['a'..'e']
14:16:45 <lambdabot>  Couldn't match `(a, b)' against `Char'
14:16:47 <ndm> so is read that fast in 6.4.2?
14:16:56 <int-e> no, but show is.
14:17:06 <ndm> why isn't read that fast?
14:17:12 <ndm> can that be contributed as a patch to GHC?
14:17:14 <int-e> because it's still the naive code.
14:17:15 <mauke> argh
14:17:34 <int-e> yes. I will think about it some more and clean it up.
14:17:45 <ndm> if cleaned up, could it be submitted to GHC?
14:17:50 <int-e> yes
14:17:55 <ndm> go for it!
14:18:07 <ndm> Data.ByteString has a fast readInt as well, I think
14:18:20 <ndm> pretty much all the tests require read/show, so those things might really speed it up
14:18:31 <dcoutts__> aye it does, but it's a rather special case
14:18:40 <dcoutts__> we need a more general read/show really
14:19:02 <ndm> there is not that much wrong with a special read for integers
14:19:17 <ndm> since all people end up doing anyway is read x :: Int
14:19:28 <ndm> if we had readInt/readInteger would be very handy
14:19:41 <int-e> ndm: there's a 'not so fast multiplication' problem (TMUL) where you can time solutions that are faster than 12 seconds
14:20:02 <mauke> > ((. zip) . (.) . lookup) 3 [2..6] ['a'..'e']
14:20:04 <lambdabot>  Just 'b'
14:20:04 <lispy> would be interesting if GHC moved to Data.ByteString
14:20:11 <mauke> glguy: ^
14:20:14 <lispy> for it's internal rep
14:20:19 <ndm> but pretty much every single problem in that list requires read/show of Int/Integer
14:20:32 <ndm> so a really fast readInt/showInt as a page on the wiki would be most useful#
14:20:41 <tibbe> is there any plans to make String into a TC instead of [Char] ?
14:21:08 <glguy> readCard [r,s] = Card (parseRank r) (parseSuit s)
14:21:08 <glguy>  where parseSuit = translate "SHDC" [Spades .. Clubs]
14:21:08 <glguy>        parseRank = translate (['2'..'9']++"TJQKA") [Two .. Ace]
14:21:09 <glguy>        translate xs ys a = fromJust $ fmap (ys !!) (findIndex (==a) xs)
14:21:10 <tibbe> would it be a good idea?
14:21:23 <ndm> tibbe: probably not...
14:21:40 <ndm> tibbe: a lot of work, removes pattern matching on strings etc
14:21:55 <mauke> translate xs ys a = lookup a (zip xs ys)
14:21:55 <tibbe> ndm: hmm, yes the pattern matching :/
14:21:56 <ndm> strings are a good default - being useful - bytestrings are a good optimisation, being more opaque but faster
14:22:15 <ndm> give people something easy, if thats too slow, allow them to make it faster
14:22:27 <tibbe> I want easy and fast ;)
14:22:41 <ndm> then make GHC better at optimising strings
14:22:52 <ndm> it could, in theory, replace some with ByteStrings - if it was clever enough
14:23:01 <ndm> if you had literal strings default to ByteString
14:23:07 <int-e> ndm: the standard read ought to be ok for Int actually. it's the big multiplications that hurt.
14:23:19 <ndm> then you can replace all operations on a literal bytestring with the bytestring versions
14:23:31 <ndm> int-e: how did you speed up that?
14:23:32 <dcoutts__> it has different complexities and semantics
14:23:56 <int-e> ndm: divide and conquere - basically combine digits in pairs, then the pair in pairs, and so on.
14:23:58 <tibbe> not a drop in replacement then
14:24:02 <dcoutts__> nope
14:24:09 <dcoutts__> and no pattern matching
14:24:13 <int-e> ndm: it's actually the same idea that I used for show.
14:24:14 <ndm> dcoutts__, on arbitrary strings, yes, on given user literal strings it has some overlap for some algorithms
14:24:37 <dcoutts__> ndm: we could do some of that automatically with rules
14:24:47 <ndm> int-e: oh, you mean the big multiplies in the read, not in the actual multiply test :)
14:24:54 <int-e> ndm: right.
14:24:55 <ndm> dcoutts__, i know :)
14:24:56 <tibbe> dcoutts__: couldn't pattern matching in theory be defined so that the user could given a function that for example pulled apart a list like structure
14:25:11 <tibbe> dcoutts__: so that (x:xs) could be possible on ADTs
14:25:28 <dcoutts__> tibbe: see views and transformational patterns
14:25:49 <tibbe> @wiki
14:25:50 <lambdabot> http://www.haskell.org/haskellwiki/
14:25:53 <dcoutts__> ie the answer is yes, but the feature has to be added to the language
14:25:53 <tibbe> @wiki views
14:25:54 <lambdabot> http://www.haskell.org/haskellwiki/views
14:26:16 <int-e> ndm: oh, the other thing that makes it faster is the missing error check. the reads stuff is probably slowing read down a lot.
14:26:34 <ndm> int-e: indeed, hence a specialised readInt/readInteger would be nice
14:26:58 <ndm> int-e: could you benchmark readInteger vs read, show some amazing benchmarks, then submit a patch to the base libraries?
14:27:00 <Cale> tibbe: the problem with that is that writing algorithms in terms of pattern matching like that generally precludes making lower level optimisations because you're constantly decomposing the structure into single characters
14:28:07 <Cale> tibbe: For optimisation, you sort of want to work in terms of higher level operations than pattern matching, where it will be more apparent that optimisations can take place to not decompose the structure and do lots of allocation :)
14:28:17 <dcoutts__> Igloo: ping
14:28:25 <tibbe> Cale: like fusion?
14:28:28 <Cale> Right
14:28:48 <Igloo> dcoutts__: pong
14:28:50 <dcoutts__> Igloo: current ghc snapshots cannot be built without alex and happy installed
14:28:54 <int-e> ndm: yes, I'm going to do that.
14:29:03 <ndm> @karama+ int-e
14:29:03 <lambdabot> int-e's karma raised to 18.
14:29:05 <tibbe> I was more thinking along the lines of keeping a nice interface (ie [Char]) but providing a faster implementation
14:29:10 <dcoutts__> Igloo: even though the tarball contains the .hs files for the .x and .y files
14:29:21 <dcoutts__> Igloo: this makes bootstrapping a bit more tricky.
14:29:27 <Cale> However, it might be possible for a compiler to rewrite functions written with pattern matching in terms of these higher level operations, but that's tricky
14:29:44 <dcoutts__> Igloo: I note that there used to be logic in the aclocal.m4 that checked this
14:29:44 <Igloo> dcoutts__: Can you easily test if just touching the .hs files first works?
14:29:59 <dcoutts__> Igloo: the logic has been removed
14:30:15 <dcoutts__> compare aclocal.m4 FPTOOLS_HAPPY or _ALEX
14:30:23 <dcoutts__> in 6.4.2 and current HEAD
14:30:48 <dcoutts__> it used to test the files
14:30:52 <dcoutts__> it doesn't anymore
14:31:16 <dcoutts__> this is bad. :-)
14:31:54 <dcoutts__> someone did a bit of over-zelous pruning in aclocal.m4 methinks
14:37:10 <xerox> Aha!
14:37:21 <xerox> Now people with access on monk can upload their own cabal-install cabal packages!
14:37:27 <xerox> Happy happy joy joy.
14:39:33 <tibbe> xerox: great work
14:39:36 <Igloo> dcoutts__: I'm not sure I follow
14:39:44 <xerox> Thanks tibbe!
14:40:02 <Igloo> dcoutts__: The test on the file only does anything if the .hs isn't there
14:40:22 <dcoutts__> Igloo: right
14:40:46 <dcoutts__> which is the right thing
14:41:07 <dcoutts__> in aclocal.m4 in ghc 6.4.2 it requires happy if the Parser.hs file is missing
14:41:12 <Igloo> dcoutts__: OK, so you aren't complaining about missing functionality, just a missing error?
14:41:28 <dcoutts__> no, I'll try and be clear...
14:41:37 <dcoutts__> in ghc 6.4.2 it's perfect
14:41:58 <xerox> Igloo: do you have some package to try cabal-put on monk, in some minutes?
14:42:05 <dcoutts__> since in a tarball the Parser.hs file is present, then happy will not be required to build ghc from the tarball
14:42:21 <dcoutts__> Igloo: however, fast forward to current HEAD...
14:42:35 <dcoutts__> now look at the AC_DEFUN([FPTOOLS_HAPPY]
14:42:51 <dcoutts__> note how it doesn't test for the presence/abcense of Parser.hs
14:42:56 <Igloo> Oh, I see, it's configure that's failing when you don't want it to?
14:43:07 <dcoutts__> and how it unconditaionally requires happy (and indeed alex)
14:43:09 <Igloo> xerox: How many minutes?
14:43:20 <xerox> Igloo: say 20, I need to figure how some things
14:43:31 <Igloo> Should do, then
14:43:33 <dcoutts__> so indeed, now configure fails when building from a tarball if I don't have alex & happy installed
14:43:35 <lispy> ?tell dons i know you like to make pretty charts of things like project activity, have you seen this library? http://dockerz.net/software/chart.html
14:43:36 <xerox> Good.
14:43:36 <lambdabot> Consider it noted.
14:43:40 <dcoutts__> these are new build time deps
14:43:44 <dcoutts__> and unnecessary ones
14:43:49 <dcoutts__> the old logic was fine
14:43:52 <xerox> lispy: great lib! cairo powered!
14:44:09 <lispy> i'm looking for a layout combinator library to steal ideas from
14:44:18 <lispy> xerox: the output is very attractive
14:44:25 <xerox> lispy: yeah right!
14:44:31 <lispy> xerox: better looking than gnuplot that i think dons uses now
14:44:48 <xerox> lispy: port it yourself.. ?
14:44:55 <lispy> port what?
14:45:14 <xerox> To use cairo-chart
14:45:16 <Igloo> dcoutts__: OK, I'll look into it, thanks
14:45:21 <dcoutts__> Igloo: cheers muchly
14:45:28 <xerox> lispy: I presume you are talking about darcs-graph
14:45:31 <lispy> xerox: i got lost....what are we talking about right now?
14:45:49 <lispy> xerox: oh, i don't use darcs-graph althought it seems neat
14:45:58 <lispy> xerox: i just want a layout combinator library right now :)
14:46:33 <lispy> my output format in excel spreadsheets and i want to layout cells...i'll need to build my own library but i was hoping someone else had a done a lot of the brain work about which combinators work best
14:47:12 <lispy> doesn't have to be complex...maybe i should just start prototyping and see what i come up with
14:47:49 * lispy killed the conversation...he just knows it...
14:47:56 <lispy> sorry! ;)
14:51:58 <Igloo> Hmm, I can't convince ghci to use things from my package
14:53:21 <Igloo> Oh, I think cabal is calling the wrong ghc-pkg
14:53:56 <Igloo> Bah
14:55:01 <Igloo> Doh, forgot to tell it to use ghc 6.5
14:55:36 <dcoutts__> Igloo: I've got a cabal patch to make specifying that easier
14:55:50 <xerox> lispy: I was just afk to get a glass of ice+water+mint syrup :D
14:55:50 <dcoutts__> but I'm not sure if I'm allowed to put it in this late
14:56:10 <dcoutts__> it makes configure --with-compiler=ghc-6.5  work
14:56:28 <Igloo> dcoutts__: that wasn't the problem, I just forgot to tell it anything
14:56:45 <dcoutts__> (so you don't have to specify absolute path to ghc or have to additionally specify ghc-pkg)
14:57:17 <dcoutts__> Igloo: I had another Q, have you tried ghc with gcc-4.1.x on ppc? we seem to be getting mangler problems
14:57:33 <Igloo> Hmm, that still didn't work
14:57:42 <dcoutts__> http://bugs.gentoo.org/show_bug.cgi?id=145466
14:57:44 <lambdabot> Title: Bug 145466 - dev-lang/ghc-6.4.2 won't compile using gcc-4.1.1 on PPC64
14:57:46 <Igloo> ppc isn't registerised on Debian
14:57:50 <dcoutts__> ah
14:58:12 <Igloo> And ppc is one of a number of buildds that didn't bother to return any output to me, unfortunately
14:58:19 <Igloo> I'll try again without -threaded ASAP
14:59:11 <dcoutts__> and I've got a sparc linux mangler bug too :-)
14:59:27 <dcoutts__> Igloo: you should make your debian ports registerised! :-)
14:59:39 <Igloo> This is exactly why the Debian ports are no longer registerised  :-)
14:59:48 <dcoutts__> heh
15:00:16 <dcoutts__> I've been getting quite a bit of help from a sparc guru
15:01:27 <Igloo> Hmm, my iconv package doesn't seem to provide a way to actually get the result
15:01:55 <Igloo> It exports ConversionResult without the constructors
15:03:33 <Igloo> xerox: Do packages need to be ghc 6.4-compatible for hackage to accept them?
15:04:05 <xerox> Igloo: hmmmm, no policy whatsoever is enforced now, except naming issues
15:04:20 <Igloo> OK
15:04:45 <Igloo> Ultimately it would be nice if the checking was done by a standalong cabal-lint, BTW, so people can run it on their own packages
15:05:00 <xerox> Igloo: cabal-put does check!
15:05:08 <xerox> I'm working on the last two lines of it right now.
15:05:22 <Igloo> xerox: Right, but cabal-put should check by calling cabal-lint
15:05:27 <xerox> Alright.
15:05:32 <xerox> I'd like that too in fact.
15:05:41 <xerox> ...and I'd like that to be an haskell software :)
15:05:48 <xerox> OK, in fact I should write it.
15:06:42 <tibbe> how many hours does a GHC compile with -O usually take?
15:06:50 <ndm> xerox: libraries or software as well?
15:07:08 <xerox> ndm: both
15:07:19 <Igloo> tibbe: Do you mean compiling GHC itself?
15:07:21 <xerox> ndm: the requirement is that it is cabalized, and names are consistent
15:07:25 <ndm> xerox: any chance of it automatically building windows binaries :)
15:07:42 <xerox> ndm: I don't know :)
15:07:45 <Igloo> ndm: Of what doing?
15:07:52 <shapr> yargh!
15:07:56 <shapr> Dino_: How do you like your 770?
15:08:33 <ndm> Igloo: i just mean compile the binary of the package that is uplaoded, so windows users can download it
15:08:41 <tibbe> Igloo: yes
15:08:54 <tibbe> Igloo: I'm compiling 6.5 and my knee is getting very hot
15:09:12 <Igloo> ndm: Then you have to worry about arbitrary Haskell being executed on the server. Plus you'd have to cross-compile it somehow
15:09:33 <ndm> Igloo: ah, i forgot the arbitrary execution issue
15:09:34 <Igloo> ndm: cabal-install should make it simple enough there's no real gain, anyway
15:09:49 <Igloo> tibbe: Around 2 hours on a reasonable machine
15:09:57 <ndm> Igloo: of course it all goes away if you were to compile the Setup file with Yhc in sandbox mode, then create Yhc .hbc files for universal download...
15:10:32 <ndm> xerox: is there a remote way to query which packages are in teh database?
15:10:47 <xerox> ndm: yep.
15:10:50 <ndm> xerox: i'll want to generate hoogle docs for everything in that pile, automatically, and put them in hoogle
15:11:26 <xerox> ndm: what informations you want from the server exactly?
15:11:38 <xerox> (That's doable if you are willing to fetch all the tarballs.)
15:11:39 <ndm> xerox: i'll want a list of the packages, and date they last changed
15:11:54 <ndm> i expect to have to fetch all the tarballs
15:11:56 <xerox> No date information is available. Just version numbers.
15:12:04 <xerox> (As now, at least.)
15:12:10 <ndm> as long as the version number always has to change for a new release?
15:12:17 <xerox> Yep, I think that's the case.
15:12:31 <ndm> hmm, that scares me slightly actually
15:12:39 <ndm> i'll want to automatically generate all hoogle databases
15:12:49 <xerox> I am thinking about having foo-darcs packages, that would be handy.
15:12:52 <ndm> but don't want someone to root my machine by uploading a malicious setup.hs
15:13:03 <ndm> is there anyway round that?
15:13:18 <xerox> Not do this stuff as root? :D
15:13:24 <ndm> windows :)
15:13:31 * xerox shakes head...
15:13:40 <Igloo> What does hoogle need to do?
15:13:59 <ndm> run: runhaskell Setup haddock --hoogle
15:14:13 <ndm> I can try blanking the Setup.hs for a default one
15:14:19 <ndm> with a special whitelist for those that need it
15:14:28 <ndm> but that sucks, since then Hoogle wouldn't even get documented
15:15:00 <Igloo> Ideally we'd do that and make haddock docs on hackage.haskell.org, but we need to worry about the security side for that too
15:15:14 <ndm> Indeed...
15:15:22 <ndm> what if you had GHC --sandbox ?
15:15:28 <Igloo> We could whitelist by Setup.hs text or parse tree or something
15:15:37 <ndm> thats uber eek though
15:15:47 <ndm> it would be great if you generated hoogle databases
15:15:56 <ndm> esp. if you could dump them in haskell.org/hoogle/databases
15:16:23 <Igloo> xerox: Ready when you are, BTW
15:16:52 <ndm> can you run things in a jail thing on Unix?
15:16:55 <ndm> so it can't interfere
15:17:00 <ndm> or maybe a virtual machine
15:17:44 <alexny> I'm trying to write the fibonacci sequence with accumulated parameter and I need some hints, first of all, I need to get rid of the tree structure of it all and make the call-tree like a single line right?
15:18:02 <Igloo> Oh, wait, aren't you gong to have to install dependent packages for this to work?
15:18:51 <dfranke> lispy: I just added yesterday's conversation about Sweeney to my .plan file.
15:19:09 <alexny> (I guess what i mean by accumulated parameter is tail recursion)
15:20:12 <xerox> Igloo: are you in the darcs group?
15:20:31 <Igloo> Yes
15:22:07 <dcoutts__> ndm: you could always just ignore the setup.hs and assume it's using a default one
15:22:15 <dcoutts__> almost all packages do
15:23:20 <ndm> dcoutts__, and watch as hoogle can't even generate a hoogle database for itself :(
15:23:28 <ndm> since hoogle requires a custom one
15:23:36 <dcoutts__> heh
15:23:42 <ndm> and gtk2hs...
15:23:46 <dcoutts__> what for btw?
15:23:50 <Igloo> dcoutts__: configure won't succeed if the deps aren't installed, will it?
15:23:52 <ndm> haskell-source-extensions
15:24:07 <dcoutts__> Igloo: if you mean happy & alex, yes.
15:24:26 <Igloo> I mean Haskell packages that the package we want to haddock depends on
15:24:53 * dcoutts__ tries to parse Igloo's comment
15:25:11 <Igloo> Suppose foo depends on bar
15:25:18 <dcoutts__> aye
15:25:22 <Igloo> We want to haddock (or haddock --hoogle) foo
15:25:30 <Igloo> We first need to run Setup.hs configure
15:25:37 <Igloo> => bar needs to be installed
15:25:37 <lucca> grammatical but arduous
15:25:43 <dcoutts__> yep
15:26:21 <ndm> so, is there something that can be done about unsafe cabal packages?
15:26:34 <dcoutts__> don't install them? :-)
15:26:48 <ndm> can you run them in a virtual machine? some permission restricted cell? with some protecting compiler falg?
15:27:01 * dcoutts__ obvously arrived late to this discussion
15:27:11 <ndm> dcoutts__, if I have to install them to run --hoogle, that sucks, as it means my machine is going to get rooted :)
15:27:37 <Igloo> dcoutts__: This is auto-haddocking and auto-hoogling thingss put into hackage
15:27:40 <xerox> Igloo: oh heck.. I can't chgrp darcs unstable without being in the darcs group :(
15:27:46 <dcoutts__> ndm: you don't need to install as root
15:27:46 <ndm> or the other option is to make everyone run hoogle themselves, which looses many of the advantages of hackage
15:27:53 <ndm> dcoutts__, windows :)
15:28:21 <xerox> Igloo: I'll make things globally read/writeable for now
15:28:35 <dcoutts__> well you can be rooted by the package you're building hoogle info for, let alone deps
15:28:48 <dcoutts__> due to Setup.hs
15:29:02 <ndm> dcoutts__, yeah, thats what we established. now the question is what to do about it
15:29:13 <dcoutts__> use a lower priviledged account
15:29:20 <ndm> not feasible on windows
15:29:28 <dcoutts__> sure it is, technically
15:29:32 <Igloo> But for deps we need the package to actually be buildable, and are also exposed to TH attacks
15:29:34 <xerox> Igloo: you should be able to do "~paolo/bin/cabal-put foo-1.0.tar.gz" now.
15:31:03 <ndm> dcoutts__, sounds like way too much effort
15:31:56 <dcoutts__> ndm: is creating an account on windows really that hard?
15:32:06 <Igloo> xerox: perl -c ~paolo/bin/cabal-put
15:32:16 <xerox> Igloo: right.
15:32:21 <ndm> dcoutts__, no, but logging out, running it, etc, all too much work
15:32:27 <dcoutts__> run as
15:32:31 <xerox> Oooops sorry Igloo
15:32:31 <dcoutts__> windows has that
15:32:31 <Igloo> xerox: The package is ~igloo/iconv-0.2.tar.gz if you want to try yourself
15:32:45 <ndm> yeah, i know, but its still a lot of effort
15:32:53 <dcoutts__> easier than a VM
15:32:54 <xerox> Igloo: try again.
15:32:59 <dcoutts__> or a "safe mode"
15:33:09 <Igloo> xerox: It's still not valid perl
15:33:31 <xerox> Igloo: argh, I missed a ;
15:33:37 <dcoutts__> an account + setting restrictive permissions can be done programatically
15:34:23 <xerox> Igloo: nevermind, I'll fix it and try myself
15:35:21 <Igloo> OK. I should really do a 6.6 pass over all my packages some time
15:35:39 <xerox> Igloo: mind to try now? :D
15:35:52 <xerox> (I'd like to know if there are permission issues.)
15:36:01 <Igloo> mkdir /home/paolo/projects/packages//iconv: Permission denied at /home/paolo/bin/cabal-put line 43
15:36:06 <xerox> As I said... hehe
15:36:25 <dcoutts__> Igloo: I'm going to bump the Cabal version number in the main Cabal repo and the ghc-6.6 snapshot
15:36:26 <xerox> That's also a wrong path.
15:36:42 <dcoutts__> Igloo: probably 1.1.5.9 or something, seem reasonable?
15:36:52 <dcoutts__> then we'll bump to 1.1.6 for ghc 6.6 final
15:37:05 <Igloo> xerox: Setting other bots but not group bits is rarely what you want, BTW (although it shouldn't matter when the group is paolo)
15:37:09 <xerox> Igloo: now?
15:37:22 <dcoutts__> or maybe it should be 1.1.5.9.1, 1.1.5.9.2 etc for RC1,2 etc
15:37:26 <dcoutts__> I'll make a tarball too
15:37:49 <Igloo> dcoutts__: Can you make sure the release notes agree with the version number too please?
15:38:09 <Igloo> Use of uninitialized value in concatenation (.) or string at /home/paolo/bin/cabal-put line 57, <$fh> line 24.
15:38:14 <dcoutts__> Igloo: ok
15:38:18 <Igloo> But it might have worked
15:38:28 <dcoutts__> Igloo: I'll make it 1.1.6 in the release notes
15:38:48 <xerox> paolo@monk:~/projects/packages/unstable$ tail -f log
15:38:48 <xerox> Tue Sep  5 15:37:35 2006 ---  adds package "iconv" version "0.2".
15:38:49 <xerox> hehe
15:39:01 <xerox> Didn't print the user information but it seem to have worked yes
15:39:44 <xerox> paolo@monk:~/projects/packages/unstable$ ls iconv/
15:39:45 <xerox> iconv-0.2.cabal  iconv-0.2.tar.gz
15:39:46 <xerox> Yeah!
15:40:34 <Igloo> xerox: You're going to need to get umasks and +s bits right for the permissions to stay correct
15:41:09 <xerox> Igloo: hmmm +s?
15:41:38 <dcoutts__>  hah :-)
15:41:47 <Igloo> You'll want g+s on the directories - it means the same group is used for things created in that directory
15:41:50 <dcoutts__> oops wrong channel
15:42:15 <xerox> Igloo: chmod -R g+s unstable/ ?
15:42:17 <dcoutts__> though you also need your umask
15:42:31 <xerox> I don't know this stuff too well.
15:42:36 <dcoutts__> to be 002 or is it 022, I think the former.
15:43:07 <Igloo> The former, yeah
15:43:41 <xerox> I should do "umask(022);" in the script?
15:43:51 <dcoutts__> or in your ~/.bashrc
15:44:04 <Igloo> You'll probably also need locking
15:44:09 <xerox> dcoutts__: monk users will be running cabal-put
15:44:14 <dcoutts__> shapr: I can't pm from this nick :-(
15:44:16 <xerox> Not just me
15:44:17 <Igloo> In the script is easier if lots of people will use it
15:44:17 <shapr> oh
15:44:27 <Igloo> But 022 is the latter, not the former...
15:44:27 <xerox> Igloo: hmm right
15:44:32 <xerox> Yeah :)
15:44:39 <shapr> dcoutts__: You could register your alternate nicknames and link them to dcoutts.
15:44:40 <xerox> I am sorry but it's
15:44:44 <xerox> @localtime xerox
15:44:45 <lambdabot> Local time for xerox is 2006-09-06 00:44:33 +0200
15:44:51 <Igloo> Is there a plan for a way for people without monk accounts to upload packages?
15:44:57 <xerox> And I'll have my first university test tomorrow, so I'd better stop hacking now and sleep
15:45:06 <Igloo> upload by anonftp and a cronjob or somesuch?
15:45:11 <xerox> Yep, probably a cgi or something
15:45:13 <Igloo> good luck
15:45:17 <Igloo> OK
15:45:18 <xerox> Thank you!
15:45:19 <dcoutts__> shapr: oh, I didn't know I could do that, know how?
15:45:28 <xerox> I'll mail Isaac about that
15:49:52 <Igloo> eivuokko: ping?
15:49:53 <dcoutts__> xerox: I think we decided not to include cabal-setup or cabal-install in this immediate version of cabal, right?
15:50:05 <xerox> dcoutts__: that's the case I think
15:50:09 <dcoutts__> ie version 1.1.6, to go with ghc 6.6
15:50:10 <dcoutts__> ok
15:50:26 <dcoutts__> I'll update that in the ghc release notes too then Igloo
15:50:27 <Igloo> They can be easily distributed as standalone cabal packages
15:50:35 <dcoutts__> currently it mentions those features
15:50:43 <xerox> Igloo: yes indeed
15:50:44 <Igloo> OK
15:50:45 <dcoutts__> but we're not going to include them
15:50:48 <xerox> Igloo: I have a standalone repo now
15:51:03 <xerox> http://hackage.haskell.org/~paolo/darcs/cabal-install/
15:51:06 <lambdabot> Title: Index of /~paolo/darcs/cabal-install, http://tinyurl.com/fzpo9
15:51:14 <xerox> It's not bound to the Cabal/ repo anymore
15:52:05 <xerox> It'd be cool if cabal could do cp etc-cabal-install /etc/cabal-install as last step
15:52:07 <xerox> Can it?
15:52:46 <dcoutts__> no
15:52:53 <dcoutts__> not so far as I know
15:53:00 <xerox> :(
15:53:57 * xerox >>= bed
16:00:05 <astrolabe> @learn
16:00:06 <lambdabot> http://www.haskell.org/learning.html
16:00:59 <dcoutts__> ndm: feel like contributing a description of runghc Setup.hs haddock --hoogle  option in the Cabal docs?
16:01:10 <dcoutts__> the user guide I mean
16:02:08 <ndm> Generates a hoogle .hoo database file, in the html directory, named <package>.hoo
16:02:19 <ndm> thats pretty much all there is to it
16:02:33 <ndm> (if the user guide was a wiki it would be really easy to do, hint hint)
16:03:52 <ndm> dcoutts__ ^^
16:03:58 <dcoutts__> it's in darcs, all we need is a patch :-)
16:04:06 <ndm> against docbook?
16:05:18 * dcoutts__ should enforce no new features without user guide documentation
16:05:57 <ndm> dcoutts__, really, if a manual isn't on a wiki, its a sin against open cooperation and open source
16:06:07 <dcoutts__> heh
16:06:14 <dcoutts__> the source code isn't on a wiki
16:06:34 * dcoutts__ doesn't like docbook either
16:06:41 <dcoutts__> but that isn't an excuse!
16:06:46 <ndm> true, but if people change the source code you'd like them to test it
16:06:48 <ndm> and compile it
16:06:50 <ndm> and think about it
16:06:55 <ndm> and be hackers
16:06:57 <dcoutts__> and document it
16:06:59 <dcoutts__> :-)
16:07:08 <ndm> whereas for someone to change documentation, you want them to speak english to some level
16:07:09 * dcoutts__ is just as guilty
16:07:18 <ndm> i can't build docbook on this machine
16:07:26 <dcoutts__> doesn't matter to much
16:07:26 <ndm> i can sometimes build the hugs docbook on my work machine
16:07:32 <ndm> but really, wiki it!
16:07:57 <ndm> we had a Yhc manual in darcs for about 3 weeks, experimented with a wiki, and never looked back
16:08:03 <ndm> ditto for Hoogle
16:08:06 <dcoutts__> hmm, I'll check with SyntaxNinja
16:08:19 <dcoutts__> but it means we can only have a single version of the docs
16:08:23 <ndm> it means that individuals document stuff
16:08:27 <dcoutts__> you can't use it offline
16:08:35 <ndm> just take a snapshot at release time, and bundle that
16:08:44 <dcoutts__> can you even do that?
16:08:52 <dcoutts__> as an html bundle?
16:08:53 <ndm> its easier than building docbook :)
16:09:01 <ndm> just download the appropriate pages
16:09:04 <dcoutts__> you want the docs for the version you've got, not the current dev version
16:09:10 <ndm> or wiki in, extract the markup
16:09:24 <ndm> if the end user docs change that much between releases, you're screwed
16:09:37 <dcoutts__> they get new stuff
16:09:44 <Igloo> I much prefer darcs too, FWIW
16:09:44 <dcoutts__> some names get changed
16:09:46 <ndm> should be easy enough to have one online reference, with a couple of (Note to pre 1.6.2 users, this doesn't work)
16:09:53 <dcoutts__> at least they have done in the past
16:10:07 <ndm> fair enough, i much prefer wiki
16:10:15 <ndm> and docbook is the nastiest thing on this planet
16:10:19 <dcoutts__> true
16:10:25 <ndm> if you had raw HTML, you'd be more likely to get a patch
16:10:30 <dcoutts__> there are simpler formats
16:10:39 <dcoutts__> like txt2tags
16:10:45 <dcoutts__> it's trivial
16:10:46 <ndm> teh hugs docbook thing has a few grep commands, to prod things, download files etc - its horrible
16:11:00 <dcoutts__> and converts to (x)html, ps, pdf
16:11:00 <musasabi> Providing patches to docbook is scary as it is usually hard to see whether the patch is correct or not.
16:11:13 <ndm> html is trivial (if done properly), and can be viewed on every computer
16:11:21 <Igloo> musasabi: Why is it harder than any other structured format?
16:11:23 <musasabi> (that is documentation done in docbook)
16:11:28 <dcoutts__> doesn't give pdf
16:11:42 <ndm> dcoutts__, yes it does, i can convert HTML to pdf easily :)
16:11:52 <musasabi> Igloo: because the docbook toolset is so complex that 90% of the time building docs for a random project will fail ;)
16:12:03 <dcoutts__> ndm: tell your prowser to print you mean :-)
16:12:08 <dcoutts__> p/b
16:12:15 <musasabi> Thus it goes back to "I hope this is correct".
16:12:27 <ndm> dcoutts__, indeed - which is a perfectly valid pdf convertor - it even goes via ps first!
16:12:33 <dcoutts__> heh
16:13:52 <ndm> anyway, i'm happy to give you a paragraph of text
16:13:57 <dcoutts__> ta
16:14:00 <ndm> but have no chance of producing valid docbook
16:14:14 <ndm> give me a sec and i'll just double check the semantics
16:14:20 <dcoutts__> I'll let you off, this once... ;-)
16:14:23 <irgs> uhm, could someone point me to documentation about what "~" does?
16:14:35 <Igloo> If it's a paragraph of text then just put <para> and </para> at either end  :-)
16:14:50 <ndm> @where cabal
16:14:50 <lambdabot> http://www.haskell.org/cabal
16:14:57 <ndm> @darcs cabal
16:14:58 <lambdabot> cabal not available
16:15:04 <ndm> @help darcs
16:15:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:15:10 <Igloo> irgs: ~pat always matches any expression, and it is only when you try to use a variable inside pat that the matching is attempted
16:15:22 <musasabi> http:://darcs.haskell.org/packages/Cabal
16:15:25 <ndm> @tell dons any chance of an @darcs, like @where but only for valid darcs repo's ?
16:15:26 <lambdabot> Consider it noted.
16:15:58 <irgs> Igloo: something like lazy pattern-matching?
16:16:06 <Igloo> > (\ ~(Just x) -> 4) Nothing
16:16:08 <lambdabot>  4
16:16:13 <Igloo> > (\ ~(Just x) -> x) Nothing
16:16:13 <lambdabot>  Add a type signature
16:16:31 <Igloo> irgs: Yes
16:16:33 <irgs> hmm, k
16:17:57 <ndm> grr, installing all the dependancies is going to take forever...
16:18:04 <ndm> @paste
16:18:05 <lambdabot> http://paste.lisp.org/new/haskell
16:18:33 <emu> doesn't ghc do tail-call opt?
16:19:38 <irgs> has anyone read "arrows and computation" by ross paterson? he introduces a product of functions as (f `x` g)~(a,b) = (f a, g b) -- why would you want that product to be non-strict on the matching of the tuple?
16:20:39 <ndm> irgs: (,) always matches, so being non-strict and improve the space
16:20:45 <irgs> hmm so the function is still a first-order type i guess?
16:20:46 <ndm> as it doesn't have to demand the (,) first
16:21:08 <irgs> improve the space?
16:21:43 <Cale> All that it means is that it won't unnecessarily force the (,) constructor
16:21:54 <irgs> i just don
16:21:58 <Igloo> I'd guess that you end up with a long chain of them, and if it was a strict match then it would have to evaluate the whole spine before doing anything, but I'm not familiar with that paper
16:22:09 <Igloo> emu: What's your problem?
16:22:22 <irgs> hmmm
16:22:32 <Cale> emu: yes, it does do tail call optimisation
16:22:36 <lisppaste2> ndm pasted "--hoogle docs for dcoutts__" at http://paste.lisp.org/display/25503
16:22:42 <emu> Igloo: i have a tail recursive problem and yet it says for some values "Stack overflow"
16:22:46 <emu> er function
16:22:49 <irgs> ok so it's just tuning and does not have any theoretical meaning?
16:22:56 <deadbeef> hi dear friends
16:22:56 <deadbeef> sup
16:23:00 <Cale> emu: you're building up a large expression which isn't getting evaluated until too late
16:23:06 <jrmole> hi deadbeef
16:23:18 <deadbeef> hi jrmole
16:23:20 <dcoutts__> ndm: ta
16:23:54 <ndm> dcoutts__, eek, missed some info...
16:23:59 <emu> hm i suppose it could be building up (g n) + (g (n - 1)) + (g (n - 2)) ...
16:24:08 <dcoutts__> ndm: ok
16:24:14 <Cale> emu: yeah, for example
16:24:23 <Cale> > foldl (+) 0 [1..100000000]
16:24:27 <lambdabot> Terminated
16:24:30 <Cale> > foldl (+) 0 [1..1000000]
16:24:32 <lambdabot>  Exception: stack overflow
16:24:46 <Cale> foldl (+) 0 [1..1000000]
16:24:50 <deadbeef> excuseme guys
16:24:59 <deadbeef> how would you implement sqrt x in haskell ?
16:24:59 <Cale> = foldl (+) (0 + 1) [2..1000000]
16:25:11 <Cale> = foldl (+) ((0 + 1) + 2) [3..1000000]
16:25:16 <deadbeef> i've seen it done easy using "minimalization operator" (i don't know how you call it)
16:25:37 <deadbeef> (it's an operator that makes the difference between the RP class and the R one)
16:25:37 <Cale> deadbeef: I'd probably just use Newton's method to find the positive root of x^2 - a
16:25:40 <jrmole> deadbeef, you mean like http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.7 ?
16:25:56 <Cale> deadbeef: (or use the Prelude version :)
16:26:10 <emu> Cale: my function looks something like: u' r n = u' (r + n) (n - 1)  with a base case at n = 0
16:26:22 <musasabi> deadbeef: the sqrt x = e^(0.5 * ln x) way.
16:26:37 <deadbeef> i've seen it written like:
16:26:41 <Cale> emu, yeah, that's your problem then. You probably want to seq the +n and -1
16:26:46 <Cale> so it would be like:
16:27:04 <Cale> u' r n = u' $! (r+n) $! (n-1)
16:27:10 <Cale> or:
16:27:17 <lisppaste2> ndm pasted "for dcoutts__" at http://paste.lisp.org/display/25504
16:27:22 <deadbeef> sqrt x = u t(x - t^2 = 0)
16:27:26 <deadbeef> or something like that
16:27:44 <Cale> u' r n = let r' = r + n; n' = n - 1 in r' `seq` n' `seq` u' r' n'
16:28:04 <dcoutts__> ndm: ok
16:28:40 <emu> that first version doesnt work
16:28:49 <deadbeef> Cale: thanks a lot
16:28:49 <emu> thinks its an infinite type
16:28:59 <Cale> er, hmm
16:29:37 <Cale> odd
16:30:46 <emu> i did (u' $! (r+n)) $! (n-1) is ok
16:30:47 <Cale> u' r n = (u' $! (r+n)) $! (n-1) -- how is this?
16:30:50 <Cale> yeah
16:31:08 <Cale> It's annoying that $ and $! are right-associative
16:31:13 <emu> yea
16:31:19 <emu> well
16:31:26 <emu> $ is supposed to do nothing else but be rightassoc, no?
16:31:34 <Cale> $ is function application
16:31:44 <emu> yes, right-assoc app
16:31:45 <dolio> No, it's supposed to be low precedence.
16:31:54 <Cale> It's mostly just low-precedence
16:31:59 <dolio> Left associative would probably work in most cases, too.
16:32:07 <emu> hmm
16:32:17 <Cale> Some people (ab-)use the fact that it's right associative to use it like composition
16:32:26 <Cale> but we already have (.) :)
16:33:25 <irgs> i guess i do ;)
16:33:31 <emu> oh i was using it for things like: truncate $ logBase x y
16:33:32 <lispy> ?pl \c -> maybe 1 read (SML.cellSs'MergeAcross (SML.cell_Attrs c))
16:33:32 <lambdabot> maybe 1 read . (SML .) . cellSs'MergeAcross . (SML .) . cell_Attrs
16:33:44 <lispy> ?pl \c -> maybe 1 read (cellSs'MergeAcross (cell_Attrs c))
16:33:44 <lambdabot> maybe 1 read . cellSs'MergeAcross . cell_Attrs
16:33:55 <Cale> emu: that's fine :)
16:33:59 <lispy> meh, i like the pointy version better i think
16:34:35 <Cale> It's the   f $ g $ h x, where you have more than one $ that's troubling :)
16:35:21 <irgs> hm could i write that as f . g . h x ?
16:35:35 <Igloo> lispy: If you don't like that pointfree example then you aren't likely to like any of them
16:35:41 <Cale> f . g $ h x or f . g . h $ x, or (f . g . h) x
16:35:42 <dolio> f . g . h $ x, I think.
16:36:05 <jrmole> @where paste
16:36:05 <lambdabot> http://paste.lisp.org/new/haskell
16:36:15 <dolio> ?pl f $ g $ h x
16:36:16 <lambdabot> f (g (h x))
16:36:19 <sjanssen> I don't see what's wrong with f $ g $ h x
16:36:24 <dolio> Heh.
16:36:24 <lispy> Igloo: i think it's because of the maybe
16:36:39 <dolio> ?pl f . g $ h x
16:36:40 <lambdabot> f (g (h x))
16:36:41 <lispy> Igloo: it has enough going on already without the extra abstraction of the pointfree form
16:36:41 <Cale> sjanssen: It abuses the fact that $ has the wrong associativity :)
16:36:49 <Igloo> Fair enough  :-)
16:37:13 <Igloo> Cale: ($) has that associativity precisely so you can do that, though
16:37:38 <sjanssen> Cale: in which cases would left associativity help?
16:37:42 <Cale> Igloo: yeah, but that trick is unnecessary, because (.) is available, and can always replace all but 1 of them.
16:37:55 <lisppaste2> keegan pasted "finding square roots in Haskell, SICP style" at http://paste.lisp.org/display/25505
16:38:00 * Igloo dislikes mixing odd infix operators without parens
16:38:15 <Cale> sjanssen: When you're applying complicated arguments to a function, or in the case of $!, when you're applying more than one
16:38:53 <Cale> You could write u' $! (r+n) $! (n-1) instead of (u' $! (r+n)) $! (n-1)
16:38:56 <dolio> The associativity can force you to write f $ g $ h x instead of f . g . h $ x in some cases, as well.
16:39:08 <sjanssen> hmm, yeah I really loathe $!
16:39:23 <Cale> dolio: hm?
16:39:43 <dolio> Or, at least, force you to use more $ than ., I think.
16:40:02 <Cale> I think you should always be able to remove all but one of the $'s
16:40:06 <dolio> Unless you like parentheses.
16:40:13 <dcoutts__> $ is great :-)
16:40:15 <Cale> (without introducing parens)
16:40:19 <dcoutts__> (.) is better
16:40:23 <Cale> f $ g $ h x = f . g $ h x
16:40:37 <Cale> f $ g $ h x y = f . g $ h x y
16:40:56 <Igloo> Cale: Note that your way works whatever the associativity of $, incidentally
16:41:09 <Cale> Igloo: right, I try not to rely on it :)
16:41:39 <Cale> also, writing things as compositions is nice because moving to point free form is easy :)
16:42:22 <Cale> and that also improves editability, because due to associativity of (.), middle sections of composition chains are still type correct.
16:42:30 <dolio> I suppose you can even write f $ g $ h x y as f . g . h x $ y
16:43:00 <Pseudonym> You could.
16:43:07 <Cale> That is, if you have f . g . h . k, you can factor out g . h by cutting and pasting and define it as its own function if you want.
16:43:11 <Pseudonym> And whether or not it's a good idea depends on how important y is.
16:43:17 <Pseudonym> Relative to x.
16:44:09 <Cale> yeah, the difference between f . g . h x $ y and f . g $ h x y is purely one of emphasis.
16:45:02 <Pseudonym> In general, in a two-argument function, one of two cases apply.
16:45:19 <shapr> g'day Pseudonym
16:45:21 <Pseudonym> Either the two arguments are roughly symmetric, or the _second_ argument is an induction argument.
16:45:22 <Pseudonym> G'day.
16:45:47 <Pseudonym> Long time no... uh... IRC.
16:45:57 <shapr> Yup, I was moving.
16:46:08 <Pseudonym> h, fair enough.
16:46:21 <shapr> How's code?
16:46:39 <Pseudonym> ?free id :: a -> a
16:46:40 <lambdabot> f . id = id . f
16:46:44 <Pseudonym> Played with that?
16:46:57 <shapr> nope
16:46:59 <Pseudonym> ?free sortBy
16:47:00 <lambdabot> g x y = h (f x) (f y) => $map f . sortBy g = sortBy h . $map f
16:47:04 <Pseudonym> Free theorem generator.
16:47:08 <shapr> Oh, theorems for free.
16:47:09 <shapr> neato
16:47:14 <Pseudonym> sortBy is particularly nice.
16:47:15 <shapr> I read something about that recently.
16:47:35 <Pseudonym> Oh, so is this:
16:47:46 <Pseudonym> ?free naturalTransformation :: F a -> G a
16:47:46 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
16:48:02 <Pseudonym> Yeah.
16:48:06 <shapr> Um, something about combining that with QuickCheck for theorems that may not be true.
16:48:18 <Pseudonym> Well, if it's a theorem, it's true.
16:48:50 <Cale> > let sqrt x = sqrt' 0.00000000000001 x 1 where sqrt' e a x = if abs (x^2 - a) < e then x else sqrt' e a (x - (x^2 - a)/(2*x)) in sqrt 2
16:48:51 <lambdabot>  1.4142135623730951
16:49:12 <Pseudonym> My local copy of the free theorem generator also supports arrows.
16:49:30 <Pseudonym> The free theorem for idA :: A a a is arr f >>> idA = idA >>> arr f
16:49:35 <Pseudonym> In case you were curious.
16:49:41 <shapr> whoa nifty
16:50:08 <Pseudonym> And you know how some of the arrow axioms are very poorly motivated?
16:50:27 <shapr> Pseudonym: No, I mean I read about something that generated possible theorems, I forget the details. Then someone else suggested using QuickCheck to test them.
16:50:31 <shapr> Yeah?
16:50:37 <Pseudonym> They're not axioms.
16:50:46 <shapr> wah?
16:51:01 <shapr> Ahem, want to write a TMR article about this?
16:51:04 <Pseudonym> Two of the "axioms" for first are in fact consequences of the free theorem for first.
16:51:25 <shapr> Someone recently suggested a TMR issue that coincides with ICFP, and I think it's a good idea.
16:51:29 * Pseudonym nods
16:51:37 <Pseudonym> Well, I'm writing something about this.
16:51:44 <Pseudonym> It'll either end up in TMR or JFP. :-)
16:51:46 <Pseudonym> Not sure which.
16:51:50 <shapr> Cool, think it'll be ready by ICFP?
16:52:02 <Pseudonym> When is that?
16:52:04 <shapr> um
16:52:12 <shapr> next week?
16:52:14 <Cale> > let sqrt a = head . dropWhile (\x -> abs (x^2 - a) > 1e-14) $ iterate (\x -> x - (x^2 - a)/(2*x)) 1 in sqrt 2
16:52:16 <lambdabot>  1.4142135623730951
16:52:17 <Pseudonym> Ah.
16:52:20 <jrmole> > let sqrt x = head $ filter ((< 0.001) . abs . subtract x .  (**2)) $ iterate improve 1 where improve g = (g + (x / g)) / 2 in sqrt 2
16:52:21 <lambdabot>  1.4142156862745097
16:52:24 <Cale> deadbeef: check it out :)
16:52:25 <Pseudonym> Well, I'll put something in TMR.
16:52:28 <Igloo> 18-20 for ICFP itself, I think
16:52:39 <deadbeef> nice
16:52:42 <deadbeef> thanks a lot
16:52:45 <Pseudonym> Maybe I'll deal with monads in TMR because I understand that better.
16:53:05 <Pseudonym> Anyway, need coffee.
16:53:08 <Pseudonym> BBS
16:56:30 <Cale> > let nthrt n a = head . dropWhile (\x -> abs (x**n - a) > 1e-14) $ iterate (\x -> x - (x**n - a)/(n*x**(n-1))) 1 in nthrt 3 64
16:56:31 <lambdabot>  4.0
16:56:35 <Cale> > let nthrt n a = head . dropWhile (\x -> abs (x**n - a) > 1e-14) $ iterate (\x -> x - (x**n - a)/(n*x**(n-1))) 1 in nthrt 4 64
16:56:39 <lambdabot> Terminated
16:56:48 <Cale> > let nthrt n a = head . dropWhile (\x -> abs (x**n - a) > 1e-13) $ iterate (\x -> x - (x**n - a)/(n*x**(n-1))) 1 in nthrt 4 64
16:56:50 <lambdabot>  2.82842712474619
16:57:38 <Cale> > 64**(1/4)
16:57:39 <lambdabot>  2.82842712474619
16:58:03 <Cale> > let nthrt n a = head . dropWhile (\x -> abs (x**n - a) > 1e-13) $ iterate (\x -> x - (x**n - a)/(n*x**(n-1))) 1 in nthrt 0.5 2
16:58:05 <lambdabot>  4.0
16:58:06 <Cale> :)
16:59:05 <sjanssen> @pl \x -> (x, ())
16:59:06 <lambdabot> (,)
16:59:09 <sjanssen> duh
16:59:10 <Cale> but it does have some problems when used that way:
16:59:14 <Cale> > let nthrt n a = head . dropWhile (\x -> abs (x**n - a) > 1e-13) $ iterate (\x -> x - (x**n - a)/(n*x**(n-1))) 1 in nthrt 0.5 (-2)
16:59:15 <lambdabot>  -5.0
16:59:42 <Cale> sjanssen: heh, that's wrong :)
16:59:50 <sjanssen> Cale: yeah, just caught that
16:59:50 <Cale> flip (,) ()
16:59:59 <sjanssen> and I'm sad to see you can partially apply (,)
17:00:20 <Cale> sad?
17:00:40 <sjanssen> s/can/can't
17:00:53 <sjanssen> > (3,) 4 -- it'd be neat if this worked
17:00:53 <lambdabot>  Parse error
17:01:04 <Cale> ah
17:01:05 <Cale> yeah
17:01:37 <jrmole> @type \x -> (x, ())
17:01:39 <lambdabot> forall a. a -> (a, ())
17:01:40 <jrmole> @type (,)
17:01:41 <lambdabot> forall b a. a -> b -> (a, b)
17:02:24 <jrmole> sjanssen, you can partially apply (,), you just can't use section syntax
17:02:44 <jrmole> and i remember a proposal to make (3,?) sugar for \x -> (3,x)
17:03:34 <jrmole> @pl flip (,) ()
17:03:34 <lambdabot> flip (,)
17:03:41 <jrmole> @pl \x -> x ()
17:03:41 <lambdabot> id
17:03:56 <jrmole> :)
17:03:58 <Cale> why the ?
17:04:02 <Cale> ?
17:04:08 <jrmole> @pl 3 + 4 ()
17:04:08 <lambdabot> 7
17:04:18 <dolio> > 3 + 4 ()
17:04:18 <Cale> (3,) should be sugar for (,) 3
17:04:19 <lambdabot>  add an instance declaration for (Num (() -> a))
17:04:32 <Cale> and (,3) should be sugar for flip (,) 3
17:05:16 <Cale> though I must admit, they do look a little odd :)
17:06:12 <jrmole> > let (+.) = (,) in (3 +.) 4
17:06:13 <lambdabot>  (3,4)
17:06:13 <dolio> ?pl \x y -> (x, 3, y)
17:06:13 <Cale> > ap (zipWith subtract) tail $ iterate (\x -> x - (x**2 - 2)/(2*x) 1
17:06:14 <lambdabot> flip (,,) 3
17:06:14 <lambdabot>  Parse error
17:06:19 <Cale> > ap (zipWith subtract) tail $ iterate (\x -> x - (x**2 - 2)/(2*x)) 1
17:06:21 <lambdabot>  [0.5,-8.333333333333326e-2,-2.450980392156854e-3,-2.123899820016817e-6,-1.59...
17:06:23 <jrmole> so you have to use funny-looking commas ;)
17:06:26 <sjanssen> Cale: we could even have [1, , 3] 2 == [1, 2, 3] for maximum obfuscation ;)
17:06:35 <Cale> sjanssen: hehe
17:06:43 <jrmole> sjanssen, iirc the last time this came up, it failed because of nesting issues
17:07:05 <sjanssen> jrmole: I figured there's a good reason
17:07:30 <jrmole> ((x, ?), y) could be (\z -> (x, z), y) or \z -> ((x, z), y)
17:07:49 <Cale> oh, that silly ? syntax :)
17:07:54 <jrmole> the latter is usually what you want, but the former is the only reasonable way to define it
17:07:59 <Cale> yeah, that's problematic
17:08:20 <Cale> I wouldn't bother with it :)
17:08:37 <Cale> But (x,) and (,x) sections would be okay.
17:09:01 <Cale> heh, you could extend it to higher tuples :)
17:09:02 <jrmole> but ((x,), y) is still fairly useless then
17:09:05 <jrmole> which might be okay
17:09:11 <Cale> that's fine
17:09:20 <Cale> let them use a lambda
17:10:00 <jrmole> people will complain about it though
17:10:02 <jrmole> *shrug*
17:10:05 <Cale> why?
17:10:16 <dolio> People always complain. :)
17:10:19 <Cale> It's not like (+1) * 2 works
17:10:49 <Cale> (at least, it doesn't mean \x -> (x + 1) * 2
17:10:51 <Cale> )
17:11:43 <Cale> So I don't think I'd ever expect ((,1),2) to mean \x -> ((x,1),2)
17:12:00 <jrmole> what actually makes the ? syntax more problematic than (x,) sections, assuming you accept that same limitation?
17:12:14 <Cale> nothing
17:12:30 <Cale> It just steals a perfectly good operator symbol
17:12:46 <sjanssen> it isn't particularly useful at that point either
17:12:51 <jrmole> indeed
17:12:55 <jrmole> we already have sections :)
17:13:02 <Cale> and lambdas
17:13:11 <sjanssen> 1 + ? * 3 === 1 + (*3)
17:13:13 <jrmole> right, but this is all a lambda-avoidance scheme :)
17:13:29 <Cale> I don't think that it's worth it here
17:13:48 <jrmole> yeah
17:13:53 <Cale> It's not like you actually have to type 'lambda' like you do in some languages :)
17:14:25 <Cale> \x -> is only 4 or 5 characters :)
17:14:35 <dolio> Eh, scheme people will just alias it anyway.
17:14:45 <dolio> Does anyone type call-with-current-continuation more than once a program?
17:14:56 <lispy> ?pl zipWith (++)
17:14:57 <lambdabot> zipWith (++)
17:14:57 <dolio> If it's too long, that is.
17:15:03 <tennin> yeah, operator symbols are a precious resource in Haskell I think
17:15:50 <Cale> @pl \xs -> zipWith subtract xs (tail xs)
17:15:51 <lambdabot> ap (zipWith subtract) tail
17:15:53 <Cale> :)
17:16:27 <Cale> ap in the reader monad is surprisingly useful
17:18:20 <dons> yeah, I like ? as an operator, and ?? and ??? and ????
17:18:20 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:18:41 <dolio> @hoogle ?
17:18:42 <lambdabot> Test.HUnit.Base.(
17:18:42 <lambdabot> Test.HUnit.Base.(
17:18:42 <lambdabot> Test.HUnit.Base.(~=?) :: (Eq a, Show a) => a -> a -> Test
17:19:02 <dons> http://www.cse.unsw.edu.au/~dons/pretty.html
17:19:03 <lambdabot> Title: pretty.hs
17:19:03 <dons> ;)
17:19:25 <dolio> Wow.
17:19:45 <dons> I should write a tool to automatically generate that code from arbitrary haskell src one day
17:20:01 <dons> since all the transformations are mechanical
17:23:13 <lispy> could be a lambdabot plugin! ;)
17:23:30 <lispy> @obfusticate ...
17:23:30 <lambdabot> Unknown command, try @list
17:23:39 <dolio> Sort?
17:23:45 <lispy> @pretty
17:24:20 <dolio> No, that's not it.
17:25:23 <lispy> dons: and if you do write a program that does that, make sure and run it on itself
17:29:18 <newsham> > let f x = if x `mod` 2 == 0 then x `div` 2 else 3*x + 1 in iterate f 45
17:29:20 <lambdabot>  [45,136,68,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,...
17:29:38 <lispy> interesting
17:30:12 <lispy> > let f x = if x `mod` 2 == 0 then x `div` 2 else 3*x + 1 in iterate f 45 !! 10000
17:30:13 <lambdabot>  1
17:30:25 <lispy> > let f x = if x `mod` 2 == 0 then x `div` 2 else 3*x + 1 in drop 1000 $ iterate f 45
17:30:26 <lambdabot>  [1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4...
17:30:27 <newsham> > let f x = if x `mod` 2 == 0 then x `div` 2 else 3*x + 1 in iterate f 231
17:30:28 <lambdabot>  [231,694,347,1042,521,1564,782,391,1174,587,1762,881,2644,1322,661,1984,992,...
17:31:15 <lispy> > let f x = if x `mod` 2 == 0 then x `div` 2 else 3*x + 1 in drop 1000 $ iterate f 231
17:31:16 <lambdabot>  [1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4...
17:31:19 <dons> lispy: oh, got your comment about rob's charts lib
17:31:31 <dons> do you find the gnuplot ones ugly ? :)
17:31:36 <Cale> lispy: It's an unsolved problem whether iterating that function always ends up giving 1.
17:31:44 <lispy> dons: not until i saw Rob's :)
17:31:46 <newsham> collatz
17:31:53 * dons looks
17:31:58 <Cale> http://en.wikipedia.org/wiki/Collatz_conjecture
17:32:04 <lispy> Cale: ah
17:32:13 * lispy is glad he didn't just go work on it
17:32:13 <dons> Cale, do you have any conjectures?
17:32:23 <newsham> awww. dons spoiled all the fun
17:33:16 <newsham> isnt there some prize for solving collatz' conjecture?
17:33:36 <Cale> Personal ones? Hmm... I'd have to think about if there was anything I came up with that I through was true but I didn't manage to eventually prove. Probably something :)
17:34:00 <Cale> and whatever it was is likely to have been solved by someone else :)
17:34:06 <lispy> oh, i have a conjecture, but we didn't end up sumbitting the paper to any sort of journal
17:34:42 <dons> oh, lispy I see rob's stuff does nicer antialiasing and dots than gnuplot
17:35:24 <dons> oh, it's Tim Docker  not Rob Dockins. silly me
17:35:40 <lispy> The genus of a plane curve is always less
17:35:42 <lispy> than or equal to the unknotting number of the alternating knot corresponding to the plane curve.
17:35:56 <newsham> don dokken?
17:36:00 <lispy> that was the conjecture i came up with...but i never tried to prove it
17:36:14 <lispy> sudoku?
17:36:17 <lispy> oh wait...
17:37:32 <dolio> Hmm. Evidently there is Erlang hype. Who knew?
17:38:50 <lispy> heh, it's funny to go back and read this paper we wrote...i'm not really sure what it's talking about now :)
17:42:01 <dons> ?users
17:42:01 <lambdabot> Maximum users seen in #haskell: 225, currently: 203 (90.2%), active: 26 (12.8%)
17:42:40 <sjanssen> I seem to remember talk about allowing module names to overlap in GHC, did this happen for 6.6?
17:43:02 <dons> maybe?
17:43:16 <dons> (you wondering what I'm wondering, about this guy buiding fps 0.8?)
17:43:47 <sjanssen> dons: how do you hack on fps?  Do you still cut out Data.ByteString before you build GHC
17:44:13 <dons> i have been, yes.
17:44:20 <dons> but I wish I didn't have to
17:44:38 <dons> so how did this guy even manage to build fps externally with the release candidate?
17:44:44 <sjanssen> me too
17:46:41 <dons> I wish X had vim-like cut-n-paste registers
17:47:04 <dons> so i could hold multiple things. or is there some way to do that?
17:47:20 <newsham> what in X are you cutting and pasting from?
17:48:10 <dons> rxvt mostly, sometimes firefox
17:48:15 <dons> sometimes vim
17:49:58 <lisppaste2> syntaxfree pasted "I don't understand!!" at http://paste.lisp.org/display/25509
17:51:06 <syntaxfree> w00t! paste.lisp.org now has Haskell syntax colouring!
17:51:20 <sjanssen> syntaxfree: you don't understand what the error means?
17:51:31 <syntaxfree> I don't understand why it comes up.
17:51:33 <jrmole> syntaxfree, by the way, you don't need to put multiple fields of a data type in a tuple
17:51:42 <lispy> dons: there is a way to do that, at least in sawfish
17:51:46 <syntaxfree> jrmole: what do you mean?
17:51:54 <jrmole> you can say NP LayerPos NeurPos rather than NP (LayerPos, NeurPos)
17:52:04 <lispy> dons: sawfish was really neat-o like that, but never popular
17:52:15 <syntaxfree> (Haskell syntax colouring, but no javascript parens matching)
17:52:29 <sjanssen> syntaxfree: perhaps you can add an additional pattern: connected x y = error (show x ++ show y), that should help you hunt the bug
17:52:32 <jrmole> syntaxfree, i get js parens matching
17:52:33 <syntaxfree> ah, I see. Yes, I knew that, I just forgot.
17:52:38 <dons> hmm, sawfish eh? maybe wmii can handle it
17:52:48 <syntaxfree> sjanssen: I'll try that.
17:52:59 <syntaxfree> Who contributed Haskell syntax highlighting to paste.lisp.org?
17:53:02 <lispy> dons: sawfish could do it because someone wrote some lisp to add that :)
17:53:09 <dons> ah
17:53:34 <jrmole> also, are the type parameters to NeurPlace, etc going to be used for something eventually?
17:53:38 <lispy> sawfish was the emacs of WM
17:53:52 <syntaxfree> jrmole: what do you mean?
17:54:15 <jrmole> data NeurPlace lp np = NP (LayerPos, NeurPos) deriving (Show, Eq)
17:54:18 <jrmole> you don't use lp or np on the RHS
17:55:03 <syntaxfree> wel, I use them in areInLayer and isLayer
17:55:22 <jrmole> not the type variables
17:55:51 <syntaxfree> you mean I should use data NeurPlace lp np = NP (Int, Int) ?
17:56:03 <jrmole> no, i mean that you're not parametrizing over different types
17:56:13 <jrmole> you might use data NeurPlace lp np = NP (lp, np)
17:56:23 <jrmole> in which case a NeurPlace LayerPos NeurPos would be like what you have now
17:56:41 <jrmole> but you'd only do that if you want to be able to represent NeurPlaces with different types for the layer/neur pos
17:57:04 <jrmole> if not, you can just use data NeurPlace = NP LayerPos NeurPos
17:57:30 <syntaxfree> ah, yes. I'm not going for much polymorphism, I want the data types to restrict what the user can do with them.
17:57:48 <jrmole> then you can drop the unused type variables
17:57:48 <syntaxfree> for example, I have data NeurState = NS Double
17:58:23 <jrmole> syntaxfree, you can use newtype instead of data there, for better performance
17:58:32 <syntaxfree> ah.
17:58:32 <syntaxfree> I think I don't understand where type variables are required yet.
17:58:32 <syntaxfree> I was getting annoyed with the humongous type signatures, though.
17:58:47 <jrmole> type variables are used for polymorphism, as you said earlier
17:58:55 <syntaxfree> What's the difference between newtype and data again?
17:59:07 <newsham> question: i have QuickCheck-1.0 in my ghc-pkg -list, but when I "import QuickCheck" it dont work.  how do I use quickcheck?
17:59:12 <jrmole> they act the same, but newtype is restricted to one constructor and one field in that constructor
17:59:21 <syntaxfree> oh.
17:59:24 <emu> is there a better way with ghc to read many lines from input other than "looping" over getLine?
17:59:27 <dons> newsham: wrong import
17:59:31 <syntaxfree> newtype Color = Red | Green | Blue is not allowed.
17:59:32 <dons> ?hoogle QuickCheck
17:59:32 <lambdabot> Test.QuickCheck :: module
17:59:33 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
17:59:34 <jrmole> right
17:59:35 <syntaxfree> but newtype is faster. That?
18:00:06 <dons> emu: lines =<< getContents -- ?
18:00:11 <jrmole> because the compiler then knows if newtype Foo = Bar Baz, it can typecheck it as if it were a data, but then basically substitute for a simple type synonym, i.e. type Foo = Baz
18:00:12 <dons> or: interact $ some code
18:00:15 <syntaxfree> or is newtype NeurPlace = NP LayerPos NeurPos wrong too?
18:00:28 <dons> emu, 'interact' will do all the line looping for you
18:00:37 <dons> ?type interact
18:00:38 <lambdabot> (String -> String) -> IO ()
18:00:40 <jrmole> also not allowed
18:00:56 <emu> dons: well also concerned about efficiency
18:00:58 <newsham> dons: whats the right import?  the online manual says to import module QuickCheck
18:01:04 <dons> see above.
18:01:08 <dons> 10:59  lambdabot:: Test.QuickCheck :: module
18:01:16 <dons> hoogle knows all
18:01:20 <syntaxfree> I don't understand when type variables are obligatory.
18:01:26 <jrmole> you can use newtype NeurPlace = NP (LayerPos, NeurPos), but then the tuple's constructor is doing what NP "should" be doing anyway, so it's pointless
18:01:39 <jrmole> syntaxfree, you know C++ templates, Java generics, or anything like that?
18:01:39 <dons> well, you get a new type
18:01:43 <newsham> perfect.  thanks.
18:01:51 <syntaxfree> nope. I know Scheme.
18:01:52 <dolio> ?pl return ()
18:01:52 <lambdabot> return
18:02:06 <dons> bug
18:02:15 <syntaxfree> newtype NeurPlace = NP LayerPos NeurPos
18:02:15 <dons> submit a patch, dolio !
18:02:17 <syntaxfree> is that valid?
18:02:20 <jrmole> syntaxfree, no
18:02:22 <dolio> Heh.
18:02:26 <jrmole> only one field is allowed in a newtype
18:02:29 <syntaxfree> ok!
18:02:40 <jrmole> sorry, i wasn't clear earlier
18:02:45 <syntaxfree> newtype NeurState nv = NS Double
18:02:50 <syntaxfree> now that's valid.
18:02:50 <dons> syntaxfree: you should just look up the haskell98 report :)
18:03:00 <jrmole> newtype is basically a typechecked type synonym
18:03:07 <dons> rather than trying to approach valid haskell in the limit ;)
18:03:08 <dolio> dons: sjanssen discovered it originally.
18:03:09 <jrmole> syntaxfree, yes, but nv is useless
18:03:15 <syntaxfree> I see.
18:03:19 <dolio> dons: So thank him, not me.
18:03:21 <syntaxfree> When do I need type variables?
18:03:29 <jrmole> because i can create a NeurState T for any type T, but that type T is never used in the definition of what NeurState is
18:03:32 * syntaxfree is glad he can cut out type variables.
18:03:34 <dons> thanks sjanssen :)
18:04:07 <jrmole> syntaxfree, it's just like a function foo x = 5
18:04:36 <syntaxfree> data Synapse = Syn NeurPlace NeurPlace NeurPlace
18:04:37 <jrmole> except a polymorphic data type is a "function" on types rather than a function on values
18:04:40 <syntaxfree> is that valid?
18:04:45 <jrmole> yes
18:05:02 <sjanssen> I'd consider porting @pl to Language.Haskell, but Language.Haskell ignores operator precedences, and I'm not sure how to get around that
18:05:17 <syntaxfree> Oh, most of the time I don't need type variables.
18:05:28 <jrmole> in fact, since type constructor and interface constructor namespaces are disjoint, you can say data Synapse = Synapse NeurPlace NeurPlace NeurPlace
18:05:29 <syntaxfree> I must say that's refreshing. Code was getting cumbersome.
18:05:33 <jrmole> but that's just a style thing
18:05:38 <syntaxfree> yes, I know.
18:05:53 <jrmole> syntaxfree, yeah, you only need them when some field of the constructor has variable type
18:05:57 <syntaxfree> I prefer shorter data constructor names for shorter function types.
18:06:36 <syntaxfree> so, I could have data Synapse w = Syn NeurPlace NeurPlace (Num w) ?
18:06:46 <jrmole> well, if Num were a type constructor, yes
18:07:03 <deadbeef> debian doesn't seem to have ghc >= 6.4
18:07:08 <deadbeef> only got 6.2.2
18:07:22 <jrmole> deadbeef, debian stable?
18:07:36 <deadbeef> yes
18:07:40 <syntaxfree> oh, Num is a type class.
18:07:43 <jrmole> stable is very stale, i've got 6.4.1 here through testing
18:07:50 <jrmole> and "testing" is rock-solid in my experience
18:08:17 <syntaxfree> um, what's an example on that Synapse data type where you have a variable type "w"?
18:08:33 <jrmole> data Synapse w = Syn NeurPlace NeurPlace w
18:08:44 <syntaxfree> (I remember starting out without type variables and having GHC balk)
18:09:06 <jrmole> hmm, take them out and see what the error is?
18:09:34 <syntaxfree> I'm taking out. I also need to rewrite all my functions for the new data types though.
18:10:59 <jrmole> syntaxfree, yeah, this is why putting typesignatures in unfinshed code is annoying, i think it's worth it to help me think though
18:11:23 <jrmole> i should see if i can find an IDE with good type inference
18:11:25 <syntaxfree> jrmole: yeah. I'm mostly doing this to learn about abstract data types and the like.
18:11:36 <jrmole> cool
18:11:42 * syntaxfree does his actual neural net stuff multiplying matrices, as far from ADT as possible.
18:11:55 <syntaxfree> I work out what the code will do on paper, and convert it to matrix-type operations.
18:11:56 <jrmole> well, abstract data types != algebraic data types (which is something i missed for a while)
18:12:02 <syntaxfree> (Sometimes involving constructing matrices).
18:12:17 <jrmole> it's not abstract until you put it in a module and hide the constructors, so the only way to get things in/out are your ADT methods
18:12:25 <syntaxfree> ah, I see.
18:12:35 <jrmole> it's a good exercise in algebraic data types though ;)
18:12:42 <syntaxfree> Anyway, I'm used to a very concrete approach to programming.
18:12:54 <syntaxfree> Mostly because I arrived to "serious" programming from Matlab and numerics.
18:13:02 <jrmole> ah
18:13:34 <syntaxfree> You're basically encouraged to transform stuff into matrix multiplication because there's a lot of knowledge in numeric analysis about performance, stability, etc. of such processes.
18:14:06 * syntaxfree still writes loops as matrix multiplications in GNU R sometimes)
18:15:27 <lisppaste2> syntaxfree pasted "is this correct? I can't test it until I've changed my functions" at http://paste.lisp.org/display/25511
18:15:55 * dons is happy to see so much AT activity 
18:16:17 <syntaxfree> AT?
18:16:22 <dons> I see lots of fun code to write in the future of Haskell
18:16:27 <dons> associated types
18:16:34 <syntaxfree> what's that?
18:16:52 <dons> ?where haskell-exts
18:16:52 <lambdabot> I know nothing about haskell-exts.
18:16:55 <dons> ?where haskellexts
18:16:56 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
18:17:07 <dons> ?where+ haskell-exts http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
18:17:07 <lambdabot> Done.
18:17:29 <syntaxfree> type theory is interesting.
18:17:37 <dons> ?where+ ATs http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
18:17:37 <lambdabot> Done.
18:17:38 <syntaxfree> a lot of code becomes very general and even somewhat self-documenting.
18:18:04 <dons> the types are machine checked documentation
18:18:10 <syntaxfree> most of my code, you can't understand without the pieces of paper with mostly-hollow matrix shapes that document it.
18:18:37 <syntaxfree> Most errors are "nonmatching matrix sizes", and you have to shuffle the pile of pieces of paper with mostly-hollow matrix shapes untll you find what's wrong.
18:19:01 <emu> is there a better way to read a string into an integer than (read s)::Int?
18:19:23 <dons> nope
18:19:33 <dons> > read "42" :: Int
18:19:34 <lambdabot>  42
18:20:09 <jrmole> emu, what kind of better?
18:20:39 <syntaxfree> you could try something like
18:20:40 <jrmole> syntaxfree, your types look good
18:20:43 <dons> there is a faster way, if speed is immportant
18:20:47 <emu> yes
18:21:01 <dons> Binary + ByteString, but I doubt that's what you're looking for.
18:22:02 <syntaxfree> > rread s = zipWith (*) [10** x | x<-[1..length s] (map (\x->read [x]) s) in rread 42
18:22:02 <lambdabot>  Parse error
18:22:14 <syntaxfree> > rread s = zipWith (*) [10** x | x<-[1..length s]] (map (\x->read [x]) s) in rread 42
18:22:14 <lambdabot>  Parse error
18:22:26 <syntaxfree> ?
18:22:49 <jrmole> forgot a let
18:22:50 <Igloo> Your parens don't match
18:22:51 <syntaxfree> > rread s = zipWith (*) [10** x | x<-[1..(length s)]] (map (\x->read [x]) s) in rread 42
18:22:51 <lambdabot>  Parse error
18:22:58 <Igloo> Oh, yes they do, sorry
18:23:02 <syntaxfree> > let rread s = zipWith (*) [10** x | x<-[1..(length s)]] (map (\x->read [x]) s) in rread 42
18:23:03 <lambdabot>  add an instance declaration for (Num [Char])
18:23:22 <syntaxfree> > let rread s = zipWith (*) [10** x | x<-[1..(length s)]] (map (\x->read [x]) s) in rread "42"
18:23:23 <lambdabot>  add an instance declaration for (Floating Int)
18:23:23 <lambdabot>   In the result of a list ...
18:23:30 <syntaxfree> argh!
18:25:19 <lispy> (Floating Int) usualy means you need a fromIntegral
18:25:51 <emu> trying to figure out why: main = interact (show . (read::String->Integer)) -- gives an error after the first line
18:25:52 <syntaxfree> > let rread s = zipWith (*) [10^ x | x<-[1..(length s)]] (map (\x->read [x]) s) in rread "42"
18:25:53 <lambdabot>  [40,200]
18:26:21 <syntaxfree> > let rread s = sum (zipWith (*) [10^ ((length) s - x) | x<-[1..(length s)]] (map (\x->read [x]) s) in rread "42")
18:26:22 <lambdabot>  Parse error
18:26:30 <lispy> > let rread s = zipWith (*) [10** fromIntegral x | x <- [1..(length s)]] (map (\x -> read [x]) s) in rread "42"
18:26:31 <lambdabot>  [40.0,200.0]
18:26:39 <syntaxfree> > let rread s = sum (zipWith (*) [10^ ((length s) - x) | x<-[1..(length s)]] (map (\x->read [x]) s) in rread "42")
18:26:39 <lambdabot>  Parse error
18:26:52 <syntaxfree> yes, I used the wrong exponentiation operator.
18:26:55 <Igloo> emu: You probably mean interact (unlines . map (show . read :: ...) . lines)
18:27:05 <syntaxfree> It's actually interesting that they're different, because they're defined differently in mathematics.
18:27:38 <syntaxfree> > let ls = length s;  rread s = sum (zipWith (*) [10^ (ls - x) | x<-[1..ls]] (map (\x->read [x]) s) in rread "42")
18:27:38 <lambdabot>  Parse error
18:27:44 <emu> aye
18:27:46 <jrmole> syntaxfree, yeah, haskell's numeric class system is fairly algebraic
18:27:56 <jrmole> there are even more algebraic versions with classes for Group, Ring, etc.
18:28:27 <syntaxfree> what's wrong? :(
18:28:43 <lispy> i hope haskell' does them a bit more algebraicly in terms of which properties are in which classes (don't care if they change the names though)
18:29:07 <SamB> lispy: I think I read that that needs more work
18:29:24 <SamB> and probably won't make it in to this haskell'
18:29:47 <syntaxfree> > let rread = sum $ zipWith (*) [10^(ls -x) | x<-[1..ls]] (map (\x->read [x]) s) where ls = length s in rread "42"
18:29:48 <lispy> > let { ls = length s; rread s = sum (zipWith (*) [10^(ls-x) | x<-[1.. ls]] (map (\x-> read [x]) s))} in rread "42"
18:29:49 <lambdabot>  Not in scope: `s'
18:29:49 <lambdabot>  Not in scope: `s'
18:30:37 <lispy> syntaxfree: what are you trying to do anyway?
18:30:45 <syntaxfree> I'm trying to write "read".
18:30:54 <syntaxfree> rread "42" should eventually return 42.
18:31:01 <lispy> oh
18:31:11 <syntaxfree> It reads each character and multiplies it by the correct 10^x.
18:31:49 <lispy> x <- reverse [1..ls] is probably a bit easier
18:32:09 <syntaxfree> lispy: > let { ls = length s; rread s = sum (zipWith (*) [10^(ls-x) | x<-[1.. ls]] (map ((-48) . ord))} in rread "42
18:32:11 <syntaxfree> oops.
18:32:19 <syntaxfree> oh, true.
18:33:33 <syntaxfree> > let { ls = length s; rread s = sum (zipWith (*) [10^x | x<- reverse [1..ls]] [(ord x) - 48 | x<-s])} in rread "42"
18:33:34 <lambdabot>  Not in scope: `s'
18:33:39 <lispy> @type [ (^x)  | x <- reverse [1.. ls]]
18:33:40 <lambdabot> Not in scope: `ls'
18:33:46 <lispy> @type [ (^x)  | x <- reverse [1.. 4]]
18:33:48 <lambdabot> forall a. (Num a) => [a -> a]
18:34:01 <syntaxfree> > let { rread s = sum (zipWith (*) [10^x | x<- reverse [1..(length s)]] [(ord x) - 48 | x<-s])} in rread "42"
18:34:02 <lambdabot>  420
18:34:14 <lispy> [0 .. (length s)]
18:34:19 <syntaxfree> > let { rread s = sum (zipWith (*) [10^(x-1) | x<- reverse [1..(length s)]] [(ord x) - 48 | x<-s])} in rread "84"
18:34:20 <lambdabot>  84
18:34:25 <syntaxfree> YEAH!
18:34:26 <lispy> er length s - 1
18:34:36 <lispy> ah oka'y
18:34:40 <lispy> i see where you subtract one
18:35:07 <lispy> [(ord x) - 48 | x <- s] is a bit hackish
18:35:19 <lispy> > [(ord x) - ord '0' | x <- s]
18:35:20 <lambdabot>  Not in scope: `s'
18:35:22 <syntaxfree> 10:18 PM  <emu> is there a better way to read a string into an integer than (read s)::Int?
18:35:31 <syntaxfree> there you are.
18:35:34 <lispy> > [(ord x) - ord '0' | x <- "0123456789"]
18:35:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
18:35:35 <syntaxfree> ok, true.
18:35:49 <syntaxfree> > let { rread s = sum (zipWith (*) [10^(x-1) | x<- reverse [1..(length s)]] [(ord x) - (ord 0) | x<-s])} in rread "84"
18:35:50 <lambdabot>  add an instance declaration for (Num Char)
18:36:03 <syntaxfree> > let { rread s = sum (zipWith (*) [10^(x-1) | x<- reverse [1..(length s)]] [(ord x) - (ord '0') | x<-s])} in rread "84"
18:36:04 <lambdabot>  84
18:36:18 <syntaxfree> @pl (\x->(ord x) - (ord '0'))
18:36:18 <lambdabot> subtract (ord '0') . ord
18:36:36 <syntaxfree> @pl rread s = sum (zipWith (*) [10^(x-1) | x<- reverse [1..(length s)]] [(ord x) - (ord '0') | x<-s])
18:36:36 <lambdabot> rread = sum . ap (zipWith (*) . return . (10 ^) . (((x - 1) | x) <-) . reverse . enumFromTo 1 . length) (return . (-) (ord x) . ((ord '0' | x) <-))
18:37:03 <syntaxfree> pl should have converted my list comprehensions into maps.
18:37:23 <lispy> > let { rread s = sum (zipWith (*) [10^x | x <- reverse [0..((length s)-1)]] (map (subtract (ord '0')) s) in rread "84"
18:37:23 <lambdabot>  Parse error
18:37:45 <lispy> > let rread s = sum (zipWith (*) [10^x | x <- reverse [0..((length s)-1)]] (map (subtract (ord '0')) s) in rread "84"
18:37:46 <lambdabot>  Parse error
18:37:52 * lispy doesn't see it
18:38:24 <lispy> > let rread s = sum (zipWith (*) [10^x | x <- reverse [0..((length s)-1)]] (map (subtract (ord '0')) s)) in rread "84"
18:38:24 <lambdabot>  Couldn't match `Int' against `Char'
18:39:01 <syntaxfree> @pl doesn't convert list comprehensions into maps and zips!
18:39:02 <lambdabot> (line 1, column 56):
18:39:02 <lambdabot> unexpected end of input
18:39:02 <lambdabot> expecting white space or simple term
18:39:09 <syntaxfree> man, I wish I could compile lambdabot to hack on itl.
18:40:39 <jrmole> > let rread s = sum $ zipWith (*) (iterate (*10) 1) $ map (subtract 48 . ord) $ reverse s in rread "84"
18:40:40 <lambdabot>  84
18:40:59 <syntaxfree> @pl rread s = sum $ zipWith (*) (iterate (*10) 1) $ map (subtract 48 . ord) $ reverse s
18:40:59 <lambdabot> rread = sum . zipWith (*) (iterate (10 *) 1) . map (subtract 48 . ord) . reverse
18:41:13 <syntaxfree> makes sense. no ap and fix ;)
18:41:52 <jrmole> iterate is my new friend :)
18:42:18 <syntaxfree> I like scanl.
18:42:37 <lispy> @pl \xs _> sum $ zipWith (*) xs
18:42:38 <lambdabot> (line 1, column 6):
18:42:38 <lambdabot> unexpected ">"
18:42:38 <lambdabot> expecting pattern or "->"
18:42:48 <lispy> @pl \xs -> sum $ zipWith (*) xs
18:42:49 <lambdabot> sum . zipWith (*)
18:43:14 <wkh> so lambdabot is a way to show off your leet haskell skillz?
18:43:32 <syntaxfree> wkh: lambdabot is a way to get simple code written collaboratively.
18:43:47 <syntaxfree> This channel once turned a 15-line program of mine into ONE LINE.
18:44:29 <jrmole> syntaxfree, my favorite code compression example was on haskell-cafe, coming up with shorter ways to do what turned out to just be 'sequence' in the List monad
18:44:34 <jrmole> wkh, that also :)
18:45:05 <wkh> when you compress things, is it to idiomatic, maintainable/readable code?
18:45:15 <jrmole> wkh, often
18:45:15 <lispy> usually yeah
18:45:18 <wkh> it sounds like you can fit an immense amount of intent and information on one screen, tremendous density
18:45:43 <SamB> syntaxfree: what did the line say?
18:45:45 <lispy> the more standard lib functions you use the more idiomatic it becomes, i think
18:46:10 <SamB> yeah, the number one compression technique is to use library functions ;-)
18:46:19 <jrmole> and each of those only needs to be learned once ;)
18:46:23 <syntaxfree> so, programming golf. What's the shortest way to write Newton-Raphson's algorithm for finding the root of functions? No stopping criteria, result is an infinite list, derivative f x = 100*(f(x+0.01)- (f x))
18:46:31 <SamB> sometime people abuse them, though
18:46:35 <jrmole> there are excessive cases though
18:46:35 <jrmole> yeah
18:47:02 <syntaxfree> SamB: main = do args <- System.getArgs; texts <- mapM readFile args; (putStr . unlines . map concat . List.transpose . map lines) texts
18:47:03 <SamB> a great example of this is the ((->) e) Monad
18:47:07 <jrmole> i don't know, do you think the following is maintainable / readable?
18:47:14 <jrmole> > sequence [[1,2,3],[4,5,6]]
18:47:15 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
18:47:16 <syntaxfree> SamB: the use of "ap" and "join" is usually a case of abuse.
18:47:25 <syntaxfree> @type ap
18:47:27 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
18:47:38 <dons> lambdabot's making ap , join ... more acceptable though
18:47:41 <jcreigh> > sequence [[1,2],[3,4],[5,6]]
18:47:42 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
18:47:46 <SamB> syntaxfree: yeah, I don't think I've ever had a legitimate use of ap...
18:47:50 <dons> since we understand (-> a) monad a _lot_ better now :)
18:47:59 <jrmole> ap is used non-abusively to build liftM(n)-like functions
18:48:04 <lispy> lambdabot, changing the way Haskllers think since 2003
18:48:07 <SamB> jrmole: can be
18:48:10 <SamB> but it need not be
18:48:12 <jrmole> lambdabot will one day take all of our jobs
18:48:18 <dons> ?remember lispy lambdabot, changing the way Haskllers think since 2003
18:48:26 <dons> hehe
18:48:27 <jrmole> SamB, non-exclusive "is"
18:48:28 <syntaxfree> jrmole: true. But @pl will produce ap code like crazy.
18:48:43 <SamB> yes!
18:48:47 <SamB> @pl is very abusive
18:48:47 <lambdabot> is very abusive
18:48:57 <Cale> join isn't abuse :)
18:48:58 <lispy> that's because ap is so dang useful when you want pointless code...
18:49:00 <SamB> it also is not very smart
18:49:08 <Cale> and ap is pretty handy
18:49:11 <SamB> lispy: heh
18:49:18 <Cale> ap f g x = f x (g x)
18:49:19 <lispy> > ap (*) (+1) 3
18:49:20 <lambdabot>  12
18:49:23 <SamB> @free ap
18:49:25 <lambdabot> Expected variable or '.'
18:49:30 <SamB> oh right, no type classes
18:49:54 <syntaxfree> I think ears are a sign of pointless abuse.
18:50:00 <jrmole> @free [a -> b] -> [a] -> [b]
18:50:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:50:01 <lispy> ears?
18:50:06 <Cale> @free (a -> b -> c) -> (a -> b) -> a -> c
18:50:07 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:50:08 <jrmole> how do i make it take types?
18:50:16 <syntaxfree> ears = .). -like stuff.
18:50:18 <Cale> @free forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
18:50:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:50:24 <lispy> @free blah (a -> b -> c) -> (a -> b) -> a -> c
18:50:24 <lambdabot> Extra stuff at end of line
18:50:24 <SamB> @free foo :: (a -> b -> c) -> (a -> b) -> a -> c
18:50:25 <lambdabot> h . k x = p (f x) . g => g . q = f1 . f => h . foo k q = foo p f1 . f
18:50:29 <jrmole> syntaxfree, but (.) . (.) is so useful!
18:50:33 <jrmole> and needs a better name imo
18:50:45 <lispy> :t (.) . (.)
18:50:47 <SamB> see, you always need to pass in a function name
18:50:50 <lispy> ?type (.) . (.)
18:50:51 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:50:59 <Cale> @free ap :: (a -> b -> c) -> (a -> b) -> a -> c
18:51:00 <lambdabot> h . k x = p (f x) . g => g . q = f1 . f => h . ap k q = ap p f1 . f
18:51:02 <SamB> if it isn't in scope, you'd better give it a type signature too
18:51:06 <lispy> @type flip (.) . (.)
18:51:07 <lambdabot> forall c b c1 a. (b -> c1) -> ((a -> c1) -> c) -> (a -> b) -> c
18:51:18 <jrmole> i see
18:51:21 <lispy> @type flip $ (.) . (.)
18:51:22 <lambdabot> forall a b c a1. (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c
18:51:31 <lispy> @pl flip $ (.) . (.)
18:51:31 <lambdabot> flip ((.) . (.))
18:51:35 <SamB> I believe I was here when @free was introduced
18:51:39 <SamB> I could be wrong though
18:51:39 <Cale> Now which way are those =>'s associated?
18:51:45 <syntaxfree> jrmole: (.) . (.)  is ok.
18:52:02 <syntaxfree> > ap (*) (+1) 3
18:52:03 <lambdabot>  12
18:52:05 <syntaxfree> how does that work?
18:52:14 <Cale> ap f g x = f x (g x)
18:52:15 <SamB> @. djinn type (.) . (.)
18:52:17 <lambdabot> f a b c d = a (b c d)
18:52:23 <SamB> @. pl . djinn type (.) . (.)
18:52:25 <lambdabot> f = (.) . (.)
18:52:27 <syntaxfree> why is the type of ap
18:52:28 <jrmole> good djinn
18:52:29 <syntaxfree> @type ap
18:52:31 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
18:52:32 <syntaxfree> ?
18:52:33 <Cale> so  ap (*) (+1) 3 = (*) 3 ((+1) 3)
18:52:35 <syntaxfree> how did monads come up?
18:52:35 <Cale> ap :: (a -> b -> c) -> (a -> b) -> a -> c
18:52:40 <jrmole> syntaxfree, in this case we're using the (-> r) monad
18:52:50 <syntaxfree> what is the (->r) monad?
18:52:55 <jrmole> so it specializes to (r -> a -> b) -> (r -> a) -> (r -> b)
18:52:58 <lispy> also known as reader monad
18:53:08 <SamB> jrmole: you've spellt it wrong
18:53:10 <syntaxfree> Oh. Okay.
18:53:15 <dolio> :), You mean the (r ->) monad.
18:53:15 <syntaxfree> Will learn soon.
18:53:21 <SamB> it is ((->) r)
18:53:28 <jrmole> my bad
18:53:35 <SamB> you can't take sections of types, dolio!
18:53:37 <jrmole> it should be the (r ->) monad, but we don't have type sections :/
18:53:58 <SamB> there is a good reason for that
18:54:02 <jrmole> @kind ((->) r)
18:54:04 <lambdabot> Not in scope: type variable `r'
18:54:10 <SamB> we don't have type lambdas either
18:54:23 <Lemmih> @kind (->)
18:54:24 <syntaxfree> there are type functions?
18:54:25 <lambdabot> ?? -> ? -> *
18:54:30 <SamB> or those!
18:54:32 <jrmole> yeah, but sections never introduce abstraction that you didn't have before
18:54:38 <syntaxfree> ah, yes, kinds. I never understood what kinds are.
18:54:40 <SamB> jrmole: sure they do!
18:54:42 <jrmole> @kind Maybe
18:54:44 <lambdabot> * -> *
18:54:47 <SamB> thats what I heard they were translated into!
18:54:58 <SamB> now, sure *that* section is reasonable enough
18:55:02 <jrmole> syntaxfree, that means that Maybe takes a type to another type
18:55:19 <syntaxfree> Kinds are like type types?
18:55:21 <jrmole> SamB, okay, then we only allow sections of the form (r ->) not (-> r)
18:55:24 <jrmole> syntaxfree, exactly
18:55:27 <syntaxfree> @kind [a]
18:55:29 <lambdabot> Not in scope: type variable `a'
18:55:33 <jrmole> @kind [Int]
18:55:34 <SamB> @kind []
18:55:35 <lambdabot> *
18:55:36 <lambdabot> * -> *
18:55:37 <syntaxfree> @kind (Num a)=>[a]
18:55:39 <lambdabot> *
18:55:57 <SamB> @kind forall a. a
18:55:59 <lambdabot> *
18:55:59 <jrmole> hmm, it will implicitly quantify but only with a bound?
18:56:01 <SamB> ooooooh
18:56:03 <SamB> neato!
18:56:09 <SamB> didn't know you could do that
18:56:12 <jrmole> which?
18:56:23 <SamB> quantify type variables in @kind
18:56:30 <dolio> @kind forall e. ((->) e)
18:56:32 <lambdabot>   `(->) e' is not applied to enough type arguments
18:56:32 <lambdabot>   Expected kind `*', but `(->) e' has kind `? -> *'
18:56:33 <lispy> @kind forall a. Maybe a
18:56:34 <lambdabot> *
18:56:44 <lispy> @kind forall a. Maybe
18:56:45 <lambdabot>   `Maybe' is not applied to enough type arguments
18:56:45 <lambdabot>   Expected kind `*', but `Maybe' has kind `* -> *'
18:56:46 <jrmole> mm, there are subtleties to the GHC kind system that i don't understand
18:56:50 <SamB> hmm
18:56:53 <jrmole> something about lifted and unlifted kinds
18:56:57 <SamB> I think it needs work!
18:57:00 <lispy> @kind Maybe
18:57:01 <lambdabot> * -> *
18:57:01 <jrmole> which is where kind '?' comes in
18:57:10 <lispy> SamB: yeah, odd
18:57:15 <SamB> @kind forall a b. a -> b
18:57:16 <lambdabot> *
18:57:22 <jrmole> @kind forall a b. a
18:57:23 <lambdabot> *
18:57:33 <lispy> @kind forall a b c. a -> b -> c
18:57:34 <lambdabot> *
18:57:40 <SamB> actually most likely quite useless
18:57:57 <jrmole> any type has kind *
18:58:14 <jrmole> where by 'type' i mean 'thing you can actually have expressions type to'
18:58:15 <lispy> @kind undefined
18:58:17 <lambdabot> Not in scope: type variable `undefined'
18:58:26 <SamB> there are also type constructors
18:58:38 <lispy> type constructors?
18:58:41 <jrmole> yes
18:58:44 <lispy> like 'data' ?
18:58:48 <jrmole> Maybe is a type constructor
18:58:53 <SamB> maybe they include partially applied type contstructors?
18:58:55 <lispy> oh right
18:59:01 <jrmole> or a type function if you like
18:59:04 <lispy> @type Arrow
18:59:05 <lambdabot> Not in scope: data constructor `Arrow'
18:59:09 <jrmole> @kind Arrow
18:59:10 <lambdabot> Class `Arrow' used as a type
18:59:10 <SamB> so perhaps ((->) ()) is one
18:59:15 <lispy> er yeah, meant kind
18:59:16 <SamB> @kind ((->) ())
18:59:17 <lambdabot> ? -> *
18:59:27 <lispy> hmm...
18:59:38 <lispy> so what is something of type ((->) ()) ?
18:59:44 <SamB> nothing!
18:59:47 <lispy> that's functions which return () ?
18:59:51 <SamB> that isn't a type
18:59:58 <SamB> perhaps it is a type constructor
18:59:59 <jrmole> it's not a type, since it has kind other than *
19:00:01 <lispy> @kind (->)
19:00:02 <lambdabot> ?? -> ? -> *
19:00:03 <newsham> @pl foldr (:) []
19:00:04 <lambdabot> foldr (:) []
19:00:06 <SamB> I'm not sure
19:00:16 <jrmole> it's a type constructor in the same way that (+ 3) is a function, not an int
19:00:23 <SamB> @kind Int#
19:00:24 <lambdabot> Not in scope: type constructor or class `Int#'
19:00:26 <SamB> hmm
19:00:31 <SamB> @kind GHC.Base.Int#
19:00:32 <lambdabot> #
19:00:32 <jrmole> or rather, it's a type function
19:00:40 <lispy> okay
19:00:42 <newsham> > foldr (:) [] "foo bar"
19:00:44 <lambdabot>  "foo bar"
19:00:51 <SamB> jrmole: is Int# not a type either?
19:00:58 <SamB> it doesn't have kind * ;-P
19:01:04 <jrmole> SamB, in a pure sense it does
19:01:07 <lispy> @kind (() (->) ())
19:01:08 <lambdabot> Kind error: `()' is applied to too many type arguments
19:01:20 <SamB> but you can't pass it to most tycons
19:01:22 <jrmole> GHC's kind system extends the type-theoretic one to some implementation-level stuff
19:01:28 <dolio> @kind ((->) () ())
19:01:30 <lambdabot> *
19:01:34 <emu> if using -prof (ghc) is causing this error: "Failed to load interface for `Prelude':" does that mean i need to install sources?
19:01:49 <jrmole> emu, you need the ghc6-prof package
19:01:52 <lispy> so then what ((->) () ()) as a type?  () -> () ?
19:01:53 <jrmole> or whatever your distro calls it
19:01:58 <jrmole> lispy, exactly
19:01:58 <lispy> @kind () -> ()
19:01:59 <lambdabot> *
19:02:09 <jrmole> it's analogous to (+) 3 5  == 3 + 5
19:02:13 <SamB> @type id :: (->) () ()
19:02:15 <lambdabot> (->) () () :: () -> ()
19:02:15 <emu> ok
19:02:33 <lispy> so then, what is ((->) r), that's functions from r to something?
19:02:33 <jrmole> heh, another lambdabot bug?
19:02:33 <dolio> (->) is just prefix notation for the function type constructor.
19:02:37 <lispy> if so i've been reading it backwards
19:02:44 <jrmole> lispy, it's not a type
19:02:46 <dolio> Like (+) is prefix for the + infix operator.
19:02:53 <jrmole> but yes, it's from r to something
19:02:58 <jrmole> that something is whatever your next type argument is
19:03:16 <jrmole> so since Monads have kind * -> *, we can define a monad instance for ((->) r), which also has kind * -> *
19:03:17 <Cale> It's too bad we can't write it like (r ->)
19:03:42 <lispy> jrmole: oh, i'm starting to see it
19:03:45 <lispy> thanks
19:03:48 <Cale> Sections should work at the type level, at least on that side :)
19:03:52 <emu> @kind
19:03:53 <lambdabot> parse error (possibly incorrect indentation)
19:03:55 <emu> @kind (->)
19:03:56 <lambdabot> ?? -> ? -> *
19:04:21 <Cale> I wish they'd give the kinds more sensible names
19:04:32 <lispy> @kind (\x -> (->))
19:04:33 <lambdabot> parse error on input `\'
19:04:52 <jrmole> lispy, there's no type level lambda
19:04:55 <lispy> :)
19:05:04 <lispy> had to try it anyway :)
19:05:04 <jrmole> although some languages have it :)
19:05:15 <dolio> Heh, we need some higher order type functions.
19:05:19 <lispy> they sacrifice compile time termination?
19:05:33 <jrmole> yes
19:05:33 <Cale> @kind RWST
19:05:34 <lambdabot> Not in scope: type constructor or class `RWST'
19:05:43 <Cale> @kind Control.Monad.RWST.RWST
19:05:45 <lambdabot> Couldn't find qualified module.
19:05:50 <dons> no 'T'
19:05:53 <jrmole> F^omega embeds a copy of the simply-typed lambda calculus at the type level
19:05:59 <Cale> @kind Control.Monad.RWS.RWST
19:06:00 <dons> @kind Control.Monad.RWS.RWST
19:06:01 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:06:02 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:06:06 <lispy> whoa
19:06:07 <Cale> yeah :)
19:06:12 <dons> referentially transparent kinds!
19:06:29 <Cale> that's probably the largest kind in the GHC libraries
19:06:36 <dons> I think so, yes.
19:06:41 <lispy> why is it so large?
19:06:50 <lispy> what do you use RWST for?
19:07:00 <dons> it grew fast feeding on types and values
19:07:05 <Cale> It's a reader, writer, state monad.
19:07:08 <dolio> I was attempting to write a monad transformer combinator type a couple weeks ago. That had a pretty large kind.
19:07:09 <dons> s/fat/
19:07:11 <Cale> transformer.
19:07:15 <Cale> hehe
19:07:26 <SamB> it takes an environment type, an output type, a state type, and a monad to base off of
19:07:29 <Cale> @kind Control.Monad.Cont.ContT
19:07:31 <lambdabot> * -> (* -> *) -> * -> *
19:07:53 <lispy> so (* -> *) is a transformer?
19:07:55 <jrmole> all the monad transformers have kinds ... -> (* -> *) -> * -> *
19:08:05 <Cale> lispy: (* -> *) is for the monad itself
19:08:10 <lispy> ah
19:08:16 <lispy> right
19:08:32 <SamB> and, the * -> * at the end is to take the return type
19:08:34 <dolio> CombaintorT :: ((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> (* -> *) -> * -> *, I think.
19:08:52 <SamB> @kind Reader
19:08:53 <Cale> awesome :)
19:08:54 <lambdabot> * -> * -> *
19:08:59 <jrmole> @kind ReaderT
19:09:01 <lambdabot> * -> (* -> *) -> * -> *
19:09:07 <SamB> ah, yeah, I meant to say that...
19:09:27 <lispy> @kind WriterT
19:09:28 <lambdabot> Not in scope: type constructor or class `WriterT'
19:09:35 <jrmole> if Foo :: k -> * -> * then FooT :: k -> (* -> *) -> * -> *
19:09:37 <jrmole> at least by convention
19:09:47 <Cale> Hehe, we should complain that there's no IdentityT
19:09:54 <SamB> um
19:09:55 <SamB> no
19:10:03 <lispy> @kind IO
19:10:05 <lambdabot> * -> *
19:10:06 <SamB> I can implement it for you!
19:10:23 <Cale> hehe, yeah, it's pretty easy :)
19:10:32 * lispy needs to go back and do examples with monad transformers
19:11:00 <SamB> type IdentityT m a = m a
19:11:15 <SamB> there, thats all
19:11:25 <SamB> and guess what!
19:11:29 <SamB> nobody will use it!
19:11:36 <SamB> because it doesn't do a thing!
19:11:43 <jrmole> SamB, you need a constructor name
19:11:46 <SamB> it doesn't even terminate a chain of monad transformers!
19:11:48 <jrmole> err
19:11:50 <SamB> jrmole: its a type alias!
19:11:52 <dolio> Ah, but you can't declare that as a monad transformer, because it'd be partially applied. :)
19:11:54 <jrmole> right
19:12:03 <SamB> dolio: you don't need to!
19:12:17 <jrmole> i always thought the name 'type' for that keyword was misleading, since it /doesn't/ create a type
19:12:17 <SamB> it would be fully applied before use!
19:12:25 <dolio> Heh.
19:12:30 <SamB> perhaps
19:12:41 <Cale> SamB: no, what about if you want to pass it as a type constructor function to something higher-order?
19:12:47 <SamB> but nobody complains about C's typedef not creating a type...
19:13:07 <Cale> Like to dolio's CombinatorT :: ((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> (* -> *) -> * -> *
19:13:08 <SamB> oh, right...
19:13:10 <jrmole> hehe
19:13:13 <SamB> okay, so maybe I could say...
19:13:35 <newsham> does ghc have "observe"?
19:13:42 <SamB> type IdentityT (m :: * -> *) = m?
19:13:47 <Cale> newsham: 'observe'?
19:14:05 <Cale> SamB: You can't use type to define it
19:14:09 <Cale> You need newtype
19:14:11 <SamB> Cale: what!
19:14:13 <SamB> why not!
19:14:16 <newsham> discussed in http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/Testing%20and%20Debugging.ppt , lets you observe computations for debugging
19:14:27 <Cale> Because type won't get you a new type, only a type synonym
19:14:36 <SamB> who cares!
19:14:57 <Cale> You can't partially apply type synonyms
19:15:22 <jrmole> hmm, i can define type S x y z = x z (y z); type K x y = x
19:15:30 <SamB> I'd still like to see an actual example...
19:15:31 <Cale> So if I have a monad-transformer transformer, I wouldn't be able to pass your IdentityT to it.
19:15:55 <Cale> also, it can't be an instance of MonadTrans
19:16:09 <SamB> true...
19:16:18 <jrmole> does this mean we have the entire simply-typed lambda calculus on one type (the kind *)?
19:16:19 <SamB> but I was mainly just ridiculing the idea that it was needed
19:16:29 <SamB> jrmole: no!
19:16:37 <SamB> I told you, no type functions!
19:17:02 <jrmole> we don't have type lambda, but neither does combinatory logic
19:17:20 <SamB> we don't have type functions either
19:17:26 <Cale> SamB: hehe, when I went into #lisp at one point, I was ridiculed for wanting to have an identity function. (Before someone more useful came along and told me how to get rid of the compiler warnings)
19:17:42 <SamB> well.
19:17:46 <dfranke> uh, lisp *does* have an identity function.
19:17:51 <Cale> yes, I know
19:17:55 <dfranke> two of them, in fact.
19:18:05 <dfranke> since values is just a generalized version of identity.
19:18:09 <SamB> I thought you were kidding about IdentityT!
19:18:10 <Cale> It was actually something more complicated which was ignoring a parameter
19:18:16 <jrmole> SamB, how are S and K above not type functions?
19:18:18 <newsham> being ridiculed on irc is like being called a doodoo-head by a preschooler.
19:18:33 <SamB> hehe
19:18:38 <SamB> jrmole: well, try and see...
19:18:41 <syntaxfree> Lisp is the original multi-paradigm language.
19:18:44 <lispy> newsham: you just think that because you're an idiot ;)
19:18:49 <jrmole> i'm not sure myself if they are; i'm trying to figure out why they aren't
19:18:50 <Cale> dfranke: (but the same error message)
19:18:54 <jrmole> SamB, try what?
19:18:57 <newsham> lispy: clever.
19:19:04 <SamB> jrmole: defining and using those combinators
19:19:11 <lispy> newsham: oh i know....
19:19:20 <newsham> so nobody knows re: "observe" and ghc?
19:19:31 <dfranke> newsham: http://holtz.org/Library/Images/Novelty/arguing%20on%20internet%202.jpg
19:19:31 <lispy> nope, but i didn't see it either
19:21:31 <Cale> newsham: no, it doesn't.
19:21:47 <syntaxfree> as long as we're in informal mode...
19:21:50 <Cale> newsham: Though it does have things like Debug.Trace
19:21:56 <syntaxfree> what's your favorite music to code/work to?
19:21:58 <jrmole> mm, the problem is that type variables have explicit kinds
19:22:06 <jrmole> which default to * if not specified
19:22:11 <newsham> that was my next question..  how does Debug.Trace differ form "observe"?  is it substantially similar?
19:22:15 <jrmole> and thus i can define S/K, but they're somewhat useless
19:22:19 <sjanssen> dd if=/dev/urandom of=/dev/dsp
19:22:20 <dfranke> syntaxfree: Guillaume Dufay
19:22:26 <syntaxfree> no longer in informal mode, I see.
19:22:34 * syntaxfree moves over to #haskell-blah
19:23:31 <Cale> syntaxfree: John Scofield, Steely Dan, Little Feat, Stuff.
19:23:40 <lispy> Stuff?
19:23:41 <Cale> syntaxfree: and lots of others :)
19:23:44 <lispy> @kind Stuff
19:23:45 <lambdabot> Not in scope: type constructor or class `Stuff'
19:23:46 <newsham> scofield+metheney == mmm
19:24:33 <dons> oh, I wonder if I could submit something to NWPT'06 just to get a trip to Reykjavik
19:24:54 <syntaxfree> I can't work with Steely Dan.
19:25:05 <syntaxfree> It makes me feel cool.
19:25:14 <Cale> http://www.allmusic.com/cg/amg.dll?p=amg&sql=11:kefqoauabijb
19:25:21 <syntaxfree> I mostly work with non-dancey variations of electronic music.
19:25:29 <lambdabot> Title: allmusic ((( Stuff > Overview ))), http://tinyurl.com/q6sdz
19:25:44 <syntaxfree> Ambient-techno or IDM, if not too drilly.
19:25:45 * lispy likes Wesely Willis while working
19:26:14 <Cale> Eric Gale is a great guitar player
19:27:01 <newsham> i prefer other non-dancey electronic music.
19:27:03 <syntaxfree> WOW. Billy Cobham played for Stuff.
19:27:12 <syntaxfree> newsham: what kind?
19:27:34 <newsham> ie. download, haujobb, male or female, ...
19:27:37 <syntaxfree> you meant avant-garde/ electronic classical stuff?
19:27:41 <Cale> The reviewer on AMG is sort of negative about Stuff, but I think at least their first two albums were really good.
19:27:45 <syntaxfree> I know Haujobb.
19:27:49 <syntaxfree> I never heard Download, though.
19:28:00 <newsham> download is a cevin key side project (skinny puppy)
19:28:12 <syntaxfree> haha. Skinny Puppy is the cause of my demise as a DJ.
19:28:22 <newsham> if you like IDM stuff, you'd dig their later stuff.
19:28:24 <syntaxfree> I was invited to DJ at a party. People expected, like, poppy house.
19:28:32 <newsham> the earlier stuff was more aggressive
19:28:42 <syntaxfree> I like Squarepusher's first album.
19:28:50 <newsham> mmm squarepusher
19:28:51 <Cale> syntaxfree: yeah, Mahavishnu Orchestra is pretty great too, but it's a little busy for music to think by :)
19:29:06 <syntaxfree> Not the drillier stuff, not the wanna-be-Miles-Davis-circa-On-the-corner either.
19:29:22 <syntaxfree> Mahavishnu Orchestra makes me want to drive fast to the sunset.
19:29:29 <jcreigh> > 36 ^ 5
19:29:30 <lambdabot>  60466176
19:29:47 <jcreigh> Hmm...tinyurl probably won't run out of 5 character ids soon...
19:30:05 <syntaxfree> > log (36^5)
19:30:07 <lambdabot>  17.91759469228055
19:30:10 <syntaxfree> uhh.
19:30:15 <dfranke> that's ln.
19:30:23 <syntaxfree> @pl f x = (log x)/(log 10)
19:30:23 <lambdabot> f = (/ log 10) . log
19:30:34 <dfranke> > log(36^5) / log(10)
19:30:35 <lambdabot>  7.781512503836435
19:30:46 <Cale> log is usually the natural log, unless you're an engineer, or French :)
19:30:52 <syntaxfree> yes, yes. My statistics teacher had a very good argument against "ln".
19:31:08 <syntaxfree> I forgot what it was though.
19:31:35 <syntaxfree> newsham: do you know of any good internet radios?
19:31:47 <syntaxfree> ambient/IDM stuff.
19:32:04 <Korollary> di.fm has some ambient stuff
19:32:22 <AStorm> Hey people, I know that's a dumb question, but well...
19:32:45 <Cale> syntaxfree: Oh yeah, Herbie Hancock too :)
19:32:55 <AStorm> I'm starting to learn Haskell, and just can't define any name. What the hell is wrong with me? :
19:33:04 <syntaxfree> define a name?
19:33:05 <syntaxfree> like,
19:33:08 <syntaxfree> two = 2 ?
19:33:08 <jcreigh> AStorm: Define "define"
19:33:09 <AStorm> (in the interpreter, hugs98 actually)
19:33:09 <Cale> AStorm: perhaps you're supposed to be putting things into a file?
19:33:13 <AStorm> Like the variable.
19:33:15 <AStorm> :P
19:33:20 <Thomas2_> are you using capitals unnecessarily?
19:33:21 <syntaxfree> AStorm: nowadays, most people prefer ghci
19:33:28 <lispy> AStorm: it's just an expression evaluator, not a full blown interpreter
19:33:30 <AStorm> Ugh, I mean using interpreter.
19:33:32 <Cale> AStorm: hugs will only evaluate expressions for you, you have to put declarations into a file
19:33:39 <AStorm> Ack.
19:33:45 <AStorm> So it's ghci
19:33:46 <dons> > let f x = x * 2 in f 3
19:33:46 <Cale> lispy: well, it is an interpreter :)
19:33:47 <lambdabot>  6
19:33:54 <lispy> but with ghci you can easily reload a file with :r
19:34:00 <dons> or else use ghci, where you can declare new names: let f x = x * 2
19:34:07 <dons> or, just write stuff in a file :)
19:34:08 <lispy> Cale: not if you're coming from lisp/python :)
19:34:21 <AStorm> So I have to write literate haskell, hmm?
19:34:24 <AStorm> Ah.
19:34:29 <dons> literate? no.
19:34:32 <Cale> AStorm: in ghci, you can temporarily declare new names, but they tend to die if your file gets reloaded, and you can't save them
19:34:35 <Korollary> it's a bit awkward to define functions in python's repl, too.
19:34:36 <dons> tht's just for irc :)
19:34:47 <SamB> lispy: but writing those classes in the interpreter is a pain
19:34:56 <syntaxfree> Python is nice, but I refuse to use it out of spite for Guido van Rossum.
19:34:59 <Thomas2_> python's interpreter is fine if you get it right the first time
19:35:03 <SamB> whenever you need to change the class, you have to type it in from scratch!
19:35:12 <Thomas2_> once you're trying to edit your function it's time to use a file
19:35:20 <syntaxfree> Guido van Rossum seems to know less about CS than I do.
19:35:22 <AStorm> those let statements are necessary in the interpreter, yes?
19:35:24 <AStorm> Fun.
19:35:30 <syntaxfree> Also,  Python's interpreter only works well when under rlwrap
19:35:32 <SamB> syntaxfree: heh
19:35:32 <syntaxfree> @google rlwrap
19:35:33 <Cale> AStorm: So here's what you do. Create a file like MyModule.hs, and load it into ghci/hugs by passing it on the command line or using :l MyModule
19:35:36 <lambdabot> http://utopia.knoware.nl/~hlub/rlwrap/
19:35:36 <dons> its a bit complex in Haskell, because we have mutual recursion, and dependency analysis. a decl can reference other values anywhere in the file
19:35:36 <lambdabot> Title: rlwrap, Emacs midi-input and p5httpd
19:35:49 <Cale> Then whenever you save new stuff into the file, type :r in ghci/hugs
19:35:51 <dons> so typing things in top-to-bottoms is only going to work in limited cases
19:35:54 <Cale> and it'll reload the new defs
19:36:00 <AStorm> Cale: Thanks.
19:36:29 <AStorm> I can read that, just didn't know I have to use a file in the interpreter (?!? :P )
19:36:44 <dons> you don't _have_ to, its just easier for developing large things
19:36:55 <ziggy> AStorm: the short answer is that if you want to define 'square x = x * x' within the interpreter
19:36:56 <dons> shorter things, just use local bindings with 'let'
19:37:07 <ziggy> you need to do it as 'let square x = x * x'
19:37:14 <syntaxfree> use a file, it's easier.
19:37:21 <syntaxfree> I recently had to relearn that lesson for GNU R.
19:37:28 <ziggy> generally if you want to play around with stuff interactively
19:37:33 <AStorm> dons: hmm well anyway.
19:37:43 <syntaxfree> I used to mess with GNU R typing in stuff and defining functions in the interpreter then going around the awkward way of pasting them to a file  when they were good.
19:38:05 <AStorm> So I'll have to have 2 apps side by side. Blah.
19:38:21 <syntaxfree> And my statistics teacher had to tell me "Why are you doing that?", as if I didn't know the first thing about turning a computer on.
19:38:22 <dons> here's the idea:
19:38:23 <AStorm> Ah no, :edit
19:38:24 <dons> $ ghci
19:38:25 <dons> Prelude> let square x = x * x
19:38:25 <dons> Prelude> :t square
19:38:25 <dons> square :: (Num a) => a -> a
19:38:26 <AStorm> :-)
19:38:27 <dons> Prelude> square 3
19:38:29 <dons> 9
19:38:32 <dons> Prelude> let square x = x + 1
19:38:34 <Cale> I tried to learn to use GAP for 3 years on and off, and never really got anywhere close to comfortable with it until I started treating it as a proper programming language.
19:38:35 <dons> Prelude> square 3
19:38:37 <dons> 4
19:38:40 <dons> for short things
19:38:42 <AStorm> dons: I know enough of that, thanks :-)
19:38:53 <lispy> GAP?
19:38:55 <dons> ok. so no problems then. get hacking!
19:38:59 <AStorm> That let tripped me off (nobody mentioned that :P)
19:39:10 <Cale> http://www-gap.mcs.st-and.ac.uk/
19:39:18 <Cale> AStorm: Which tutorial are you using?
19:39:37 <lispy> Cale: cool
19:39:39 <Cale> YAHT is good, and I think it mentions that (though it's easy to miss if you skip the initial section) :)
19:39:56 <dons> AStorm, check "3.4.Interactive evaluation at the prompta" in the ghc user's guide.
19:39:59 <AStorm> Cale: classic. :>
19:40:00 <Cale> @where yaht
19:40:01 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
19:40:08 <AStorm> YAHT seems unavailable with 403
19:40:14 <dfranke> I think Gentle Introduction is better if you already understand the lambda calculus.
19:40:20 <Cale> uh, try again?
19:40:23 <Cale> It works for me
19:40:26 <AStorm> I do somewhat :-)
19:40:32 <dons> the above url works
19:40:48 <AStorm> See the /whois and you know where I'm coming from.
19:40:59 <Cale> dfranke: The gentle introduction isn't the least bit gentle :)
19:41:09 <AStorm> But it's fine enough for me.
19:41:12 <lispy> AStorm: tor?
19:41:19 <syntaxfree> the Gentle Introduction is written as a research paper, not as a tutorial.
19:41:20 <AStorm> That too, the channels.
19:41:29 <Korollary> Gentle intro is as gentle as an intro can get. YAHT is not an intro; it's almost a book.
19:41:31 <syntaxfree> damn annoying.
19:41:40 <sjanssen>  /whois astorm
19:41:48 <syntaxfree> @whois astorm
19:41:49 <lambdabot> Unknown command, try @list
19:41:59 <Cale> Korollary: I suppose it's gentler than just reading the Report :)
19:42:01 <sjanssen> wow, Gaim is really annoying
19:42:02 <dfranke> Cale: it's gentle if you're a masochist.
19:42:11 <Cale> dfranke: heh
19:42:19 <Cale> sjanssen: yeah, don't use Gaim for IRC
19:42:26 <dons> sjanssen: gaim? come on... try irssi ;)
19:42:33 <NoGoodNik> dudes, it's fine!
19:42:35 <Cale> X-Chat is decent
19:42:37 <NoGoodNik> perfectly gentle.
19:42:44 * syntaxfree uses Conversation
19:42:52 <syntaxfree> @google Conversation "OS X"
19:42:54 <lambdabot> http://homepage.mac.com/philrobin/conversation/
19:42:54 * lispy uses emacs
19:43:02 <dfranke> lispy: rcirc?
19:43:04 <jrmole> Korollary, gentle intro is most understandable if you have previous FP experience
19:43:09 -Cale(n=cale@bas4-kitchener06-1167938156.dsl.bell.ca)- this is a notice which will be misrendered as a dialog box by some clients.
19:43:17 <lispy> dfranke: ERC Version 5.0 $Revision: 1.743 $
19:43:19 <Dino_> Question about hmake: Can it be made to remove the compiled binary as well (like a -reallyrealclean)?
19:43:20 <syntaxfree> gentle intro is most understandable if you have previous programming experience.
19:43:31 <syntaxfree> uh, typeful programming experience.
19:43:35 <Cale> syntaxfree: In functional languages
19:43:43 <syntaxfree> I came from a dynamic typing background.
19:43:47 <dfranke> read: have experience in ML.
19:43:49 <sjanssen> Cale: oh that was very very annoying when lambdabot used notices
19:43:52 <Korollary> jrmole: that goes for every tutorial
19:43:55 <syntaxfree> the type stuff at the beginning seemed esoteric, so I skimmed through it.
19:43:57 <dons> sjanssen: heh
19:43:59 <syntaxfree> Soon I was lost.
19:44:01 <AStorm> Well, I come from even the oldest BASIC and Pascal :P
19:44:06 <jcreigh> Cale: What is that? Some sort of CTCP message sent to the channel?
19:44:07 <Cale> sjanssen: yeah, but only because of how stupid people's IRC clients are :)
19:44:12 <AStorm> And C, C++ and Python :P
19:44:13 <Cale> jcreigh: it's a /notice.
19:44:20 <AStorm> So well.
19:44:25 <AStorm> It should be enough for basics.
19:44:26 <Cale> It's supposed to be rendered much the same as an ordinary message from me
19:44:31 <NoGoodNik> syntaxfree, does Conversation mark off the point at which you switch away from the app so that you know where to start reading from when you Cmd+Tab back to it?
19:44:34 <syntaxfree> I didn't'get it.
19:44:46 <Cale> With the only difference being that IRC bots should ignore it.
19:44:49 <syntaxfree> dunno. Maybe it does.
19:44:58 <dfranke> actually if you read the protocol, it's supposed to be of less significance than a regular message.
19:45:00 <syntaxfree> I have irssi, it's  just that OS X's terminal  kinda breaks it, and xterm looks ugly.
19:45:04 <Cale> However, lots of IRC clients do very annoying things with notices.
19:45:14 <AStorm> Cale: you sent me a notice, huh
19:45:22 <Cale> AStorm: not you personally
19:45:22 <lispy> irssi had some things really annoying
19:45:24 <AStorm> No dialog box fortunately (weechat)
19:45:28 <Cale> I sent the channel a notice.
19:45:33 <dfranke> I'm using irssi and it just rendered like this:
19:45:38 <AStorm> Huh, yes.
19:45:40 <lispy> like, i tells you a number when a channel has unread stuff, but not any hint of the channel name
19:45:41 <syntaxfree> I didn't get the notice.
19:45:58 <AStorm> You did, check the server window.
19:46:07 <syntaxfree> nothing.
19:46:12 <AStorm> (or tab)
19:46:19 <dfranke> -Cale:#haskell- this is a notice...
19:46:31 <lispy> and in emacs i can just hit C-r lispy to find the last time i spoke and read from there...irssi didn't seem to have anything nice like that
19:46:33 <Cale> dfranke: yeah, that's basically appropriate :)
19:46:33 -syntaxfree(n=dnavarro@201.12.102.188)- sorry.
19:46:41 <Cale> -syntaxfree/#haskell- sorry.
19:46:57 <AStorm> I got two actually: one from ChanServ, the other from Cale.
19:47:12 <AStorm> Now the "sorry" one :P
19:47:27 <jcreigh> lispy: As in, trying to find where you've read up to in the scrollback?
19:47:38 <AStorm> But w/o the #haskell, weird.
19:47:49 <lispy> jcreigh: yes and to see if anyone was trying to talk to me
19:47:49 <AStorm> Guess I'll have to bash the client a bit more to show that.
19:47:55 <Cale> I think I'll remove the #haskell from my notice messages :)
19:48:11 <Cale> (or #whatever)
19:48:29 <syntaxfree> I should learn emacs.
19:48:38 <Cale> In X-Chat, that's configurable in Settings -> Advanced -> Text Events
19:48:50 <syntaxfree> I'm very proficient with vim (though I use subethaedit nowadays), but emacs seems to have nice IDE features.
19:49:32 <dfranke> I use emacs for damned near everything.
19:49:34 * lispy couldn't stand subethaedit
19:49:49 <emu> i use emacs and haskell-mode along with the inferior hasell mode thing
19:50:12 <syntaxfree> is there a good emacs tutorial from an IDE-ish point of view?
19:50:15 <syntaxfree> I also want to use it for latex.
19:50:18 <dfranke> is there anything besides emacs that supports haskell indentation?
19:50:41 <syntaxfree> I used TeXShop for a while, which is damn nice, but I couldn't set it to a dark background.
19:50:50 <syntaxfree> (And I can't be productive without a dark background)
19:50:53 <emu> syntaxfree: start with C-h t, the tutorial
19:50:59 <lispy> dfranke: the best i've seen besides emacs is when editors assume the next line should start where the previous one started
19:51:02 <emu> you can set that, i hate light backgrounds too syntaxfree
19:51:13 <emu> say, if you want, take a look at my emacs init stuff
19:51:14 <Korollary> syntaxfree: I don't know of any and it depends on the language you develop in. There may be some docs at emacswiki.org.
19:51:16 <lispy> syntaxfree: i had that problem with texshop too
19:51:17 <syntaxfree> I use light backgrounds for IRC, web browsing, etc.
19:51:22 <lispy> and eclipse
19:51:26 <syntaxfree> But when I wanna concentrate...
19:51:48 <dfranke> I usually go all-out angry-fruit-salad mode.
19:51:51 <AStorm> dfranke: buhehehe
19:52:03 <emu> syntaxfree: http://mapcar.org/~mrd/emacs/
19:52:05 <lambdabot> Title: Emacs Info
19:52:18 <syntaxfree> lispy: OS X's reverse screen mode turns things into B&W.
19:52:23 <syntaxfree> lispy: so you lose syntax highlighting.
19:52:24 <dfranke> the best thing would actually be just to have two colors and alterate each token.
19:52:28 <AStorm> Nice bot you have there. In Haskell, right? :-)
19:52:46 <dons> yep
19:52:52 <dons> ?version
19:52:52 <lambdabot> lambdabot 4p124, GHC 6.5 (OpenBSD i386 )
19:52:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:53:01 <dons> > map (+1) [1..10]
19:53:02 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
19:53:03 <dons> ?type map
19:53:04 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:53:10 <dons> ?hoogle (a -> b) -> [a] -> [b]
19:53:11 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:53:11 <lispy> dons: how was that thing with fps in darcs going?
19:53:12 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
19:53:12 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
19:53:27 <dons> lispy, just sitting on it atm, got distracted
19:53:33 <lispy> dons: i got a .cabal file working
19:53:34 <dons> ?docs Data.List
19:53:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:53:40 <dons> lispy, oh good
19:53:53 <dons> I think you should do what you can toget concensus on the darcs list
19:54:04 <araujo> yay!
19:54:04 <lispy> dons: kinda...it's specific to my system, and i didn't replace all the autotools nonsense
19:54:07 <araujo> hi all
19:54:08 * araujo back
19:54:15 <dons> you can keep that with cabal though
19:54:21 <dons> hey araujo !
19:54:26 <syntaxfree> dons: will darcs get lambdabot get all dependencies?
19:54:34 <dons> no, not fps.
19:54:38 <Pseudonym> ?botsnack
19:54:38 <dons> but you might have that already
19:54:45 <lispy> dons: it would be nice to be rid of it actually...i mean, why bother with cabal if you have a perfectly good build system already?
19:54:47 <Pseudonym> Errr...
19:54:55 <dons> someone running a @list?
19:55:02 <Pseudonym> Not me.
19:55:11 <AStorm> Ugh... my bad :P
19:55:13 <dons> yes :)
19:55:16 <Pseudonym> OK. :-)
19:55:18 <dons> no, I should really fix that
19:55:24 <AStorm> You should've said it's slow :P
19:55:26 <lambdabot> :)
19:55:27 <dfranke> yuppers...
19:55:28 <dfranke> wc .emacs
19:55:40 <Pseudonym> ?todo dons Make @list multi-threaded.
19:55:40 <lambdabot> todo module failed: IRCRaised @todo has no args, try @todo-add or @list todo
19:55:43 <dons> I think I'll just have @list point to the url of a page listing the stuff
19:55:46 <AStorm> Finished.
19:55:48 <syntaxfree> dons: I have fps, but I'm afraid it's an old version.
19:55:55 <Pseudonym> Good idea.
19:56:01 <dons> don't be afraid, syntaxfree
19:56:03 <syntaxfree> I'm also afraid I don't  have a recent version of hs-plugins.
19:56:08 <dons> you don't need it
19:56:13 <dons> lambdabot only needs fps
19:56:15 <Pseudonym> dons, while you're there, new version of freetheorems in darcs.
19:56:23 <dons> ah yes, i pulled, but didn't record
19:56:25 <dons> let me do so
19:56:26 * Pseudonym nods
19:56:29 <sieni> gaa, it's difficult to install gnucash on mac os x
19:56:45 <dons> I'm instituting a policy of resyncing the bot once per week though
19:56:55 <sieni> maybe I'll hack an accounting software myself in haskell and hdbc
19:57:03 <syntaxfree> sieni: uh, have you ever installed gtk apps before?
19:57:05 <dons> i.e. on Saturdays, i'll rebuild and apply that week's patches.
19:57:11 <Pseudonym> Cool.
19:57:16 <sieni> syntaxfree: yes, gtk isn't a problem
19:57:32 <syntaxfree> I see. I hate it when Unix apps are linuxistic.
19:57:33 <sieni> syntaxfree: slib-guile refuses to build apparently because of a broken portfile
19:57:41 <lispy> dons: good idea
19:57:57 <sieni> My problem seems to be macports-specific
19:58:15 <sieni> but I'll try to fix that when I have time
19:58:36 <araujo> dons, hi hi! :-)
19:59:39 * araujo tries to get some coding before going to bed ...
20:00:32 <emu> is ghc 6.2.2 considered really badly out of date?
20:00:37 <sieni> 6am here, just woke up
20:00:50 <lispy> emu: i'd say so, but i might be in a minority
20:01:33 <dons> emu, hmm. no. not really
20:01:36 <Pseudonym> Actually, looks like there's another bug in freetheorems, now that I read my mail.
20:01:39 <dons> plenty of apps actively support 6.2.2
20:01:42 <dons> e.g. darcs
20:01:46 * Pseudonym might fix that first
20:02:02 <dons> and unless you need, hmm, GADTs? the language is the same
20:05:26 <sieni> hot porridge <3
20:08:03 <newsham> anyone participate in the icfp this year?
20:08:23 <lispy> sieni: i really like oatmeal in the morning personally..especially after a morning jog
20:08:32 <lispy> newsham: ask that in #oasis :)
20:08:33 <emu> i'm just trying to puzzle out why a particular function is fairly sluggish; it's doing some mathematical operations in a loop, which i don't think should ever run that long, but still
20:08:44 <emu> i guess i can paste it somewhere
20:08:46 <emu> lisppaste2: url
20:08:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:10:29 <lisppaste2> emu pasted "code" at http://paste.lisp.org/display/25516
20:11:06 <TomMD> If you have a data structure: "Data St = St { a :: Int, b :: Int }"
20:11:17 <dons> looks a bit convoluted, emu. let me see..
20:11:37 <TomMD> and have an instance: blah :: Maybe St
20:11:50 <emu> it's implementing the function Z from http://mathworld.wolfram.com/Factorial.html
20:11:52 <lambdabot> Title: Factorial -- from Wolfram MathWorld
20:12:13 <TomMD> Then is there a good way to have the predefined functions 'a' and 'b' deal with the "Maybe St" in the obvious manner?
20:12:27 <dons> way too many parens, btw, emu :)
20:12:39 <dons> ?docs Data.Maybe
20:12:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
20:12:39 <emu> yea
20:12:48 <emu> i lost confidence in my ability with the $ operator
20:12:50 <emu> heh
20:13:04 <emu> actually i found the parentheses necessary when using the $! operator, /shrug
20:13:10 <dons> is this right:
20:13:11 <dons> z' r k n = z' a (k-1) n
20:13:12 <dons>     where a = r + floor (n / 5^k)
20:13:29 <jrmole> @type maybe
20:13:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:13:32 <dons> modulo strictness (there are nicer ways for that than $!.. as I'll now write)
20:13:42 <TomMD> ?where paste
20:13:43 <lambdabot> http://paste.lisp.org/new/haskell
20:14:15 <emu> dons: yes
20:14:16 <jrmole> so what you want might be maybe Nothing a, or a . fromJust
20:14:19 <dons> emu, now you want these over Integer?
20:14:22 <dons> or Int?
20:14:36 <emu> i'm not sure yet, i tried to do Int but it wouldn't let me
20:14:51 <emu> does 1 billion fit in Int?
20:15:07 <dons> > maxBound :: Int
20:15:08 <lambdabot>  2147483647
20:15:20 <sieni> > 1000000000 :: Int0
20:15:21 <lambdabot>  Not in scope: type constructor or class `Int0'
20:15:25 <sieni> > 1000000000 :: Int
20:15:27 <lambdabot>  1000000000
20:15:30 <sieni> yes
20:17:32 <dons> emu, what's an example that runs slowly?
20:17:58 <emu> it was a total time of running it on a lot of inputs
20:18:04 <emu> hmm
20:18:11 <dons> I just want an example to play with
20:18:30 <dons> (oh, and if you care about speed, you better compile it to native code :)
20:19:05 <emu> i am doing ghc -O ...
20:19:17 <dons> seems very fast for me.
20:19:25 <dons> can you give me an example to try that runs slowly?
20:20:16 <emu> oen sec
20:20:30 <lisppaste2> dons annotated #25516 with "clean up a bit" at http://paste.lisp.org/display/25516#1
20:20:49 <dons> i haven't looked at the speed yet, since it seems to run fine for the examples i've used
20:21:22 <emu> how can i force it to evaluate map z someList and not display the result whihc will be huge
20:21:33 <dons> take the length of the result
20:21:37 <dons> and display that instead
20:22:31 <dons> some ideas for writing very fast recursive math loops : http://haskell.org/hawiki/RecursiveEntry
20:22:32 <lambdabot> Title: RecursiveEntry - The Haskell Wiki
20:22:36 <dons> if you really care about maximum speed
20:22:52 <dons> also, http://haskell.org/hawiki/PartialSumsEntry
20:22:54 <lambdabot> Title: PartialSumsEntry - The Haskell Wiki
20:23:03 <emu> hm, maybe it is the I/O which is slow
20:23:12 <dons> probably
20:23:21 <emu> i thought i had settled that at about 30% of the total
20:23:24 <dons> (it has to create a big [Char] remember)
20:23:48 <lisppaste2> emu annotated #25516 with "more" at http://paste.lisp.org/display/25516#2
20:24:18 <emu> i ran it with prof and it put z' at 65% and invokeF at 35% ish
20:24:38 <dons> note that you don't need 'module Main where' for the main module
20:24:46 <dons> nor the extra parens around main = do getLine
20:24:47 <dons>           interact (unlines . (map invokeF) . lines)
20:24:47 <dons>                                                     
20:24:53 <dons> sorry,
20:25:01 <dons> around , (show . f . (read::String->Integer))
20:25:20 <lisppaste2> TomMD pasted "maybeEq for Haskell'?" at http://paste.lisp.org/display/25518
20:25:21 <dons> and if you need fast String -> Int, there are better ways. let me see...
20:25:49 <dons> what's that getLine on its own for?
20:25:52 <lisppaste2> emu annotated #25516 with "prof" at http://paste.lisp.org/display/25516#3
20:25:52 <dons> throwing away a line?
20:25:58 <emu> yea
20:26:12 <TomMD> That should be a little more clear.  I know I can get data out of a Maybe container, but I want to be as lazy as my language and have the compiler folks do the work for me.
20:26:59 <Pseudonym> dons: OK, bug fixed now.
20:29:39 <jrmole> @type maybe False id $ liftM2 (==)
20:29:40 <lambdabot>   Expecting a function type, but found `a'
20:29:41 <lambdabot>    Expected type: Maybe Bool
20:30:05 <jrmole> err
20:30:58 <jrmole> > maybe False id $ liftM2 (==) (Just 3) (Just 5)
20:30:59 <lambdabot>  False
20:31:01 <jrmole> > maybe False id $ liftM2 (==) (Just 3) (Just 3)
20:31:02 <lambdabot>  True
20:31:05 <jrmole> > maybe False id $ liftM2 (==) (Just 3) Nothing
20:31:06 <lambdabot>  False
20:31:48 <dons> emu, what's the point of running 'lines' on the string provided by interact?
20:31:53 <dons> interact already has broken things up on lines
20:32:19 <emu> dons: hmm, for some reason it wasn't working; it would error out after 1 line
20:32:22 <emu> someone here suggested lines
20:32:29 <dons> not mixed with interact
20:33:23 <sjanssen> @type interact
20:33:25 <lambdabot> (String -> String) -> IO ()
20:33:30 <jrmole> > Nothing == Nothing
20:33:31 <lambdabot>  Add a type signature
20:33:37 <dons> oh silly me
20:33:39 <sjanssen> I don't think interact splits things into lines
20:33:39 <jrmole> > (Nothing == Nothing) :: Bool
20:33:40 <lambdabot>  Add a type signature
20:33:42 <dons> why do I always things that :)
20:33:45 <jrmole> sigh
20:33:51 <jrmole> > ((Nothing :: Int) == Nothing)
20:33:52 <lambdabot>  Couldn't match `Int' against `Maybe a'
20:33:57 <jrmole> > ((Nothing :: Int) == (Nothing :: Int))
20:33:58 <lambdabot>  Couldn't match `Int' against `Maybe a'
20:34:34 <jrmole> Data.Maybe claims to have an (Eq a) => Eq (Maybe a) instance
20:34:39 <jrmole> err, i'm a retard
20:34:45 <jrmole> > ((Nothing :: Maybe Int) == (Nothing :: Maybe Int))
20:34:46 <lambdabot>  True
20:35:04 <jrmole> is there some way of hiding instances from a module?
20:35:22 <emu> dons: i don't know why, but if i do just "interact invokeF" it only accepts 1 line, but if i do "interact id" it works fine
20:35:57 <dons> here', i've written a nice and fast version
20:35:58 <dons> let me see
20:36:21 <lisppaste2> dons annotated #25516 with "about as fast as we get without reading Core" at http://paste.lisp.org/display/25516#4
20:36:56 <dons> runs in constant space, which is nice
20:37:46 <sjanssen> emu: is this for a SPOJ problem?
20:38:21 <emu> yes you found me out lol; i'm using it for examples to learn haskell
20:38:41 <sjanssen> emu: that's cool
20:38:50 <sjanssen> I think the IO here is the tricky part
20:39:05 <emu> yea
20:39:11 <emu> my z function runs plenty fast from the repl
20:39:13 <sjanssen> also, you don't have to use floating point division -- integer div. works fine
20:39:24 <dons> yeah, that'll be much faster
20:39:28 <emu> i'm having trouble with that ByteString module
20:39:33 <emu>     Can't find module `Data.ByteString.Char8'
20:39:42 <emu> does this need a certain package installed?
20:39:46 <dons> its in fps
20:39:47 <dons> ?where fps
20:39:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
20:40:04 <dons> and my example uses bang patterns (the !), which you can removeo, or replace with seq
20:40:39 <emu> i really should update to 6.4
20:41:21 <dons> the ! is in 6.6 :)
20:41:56 <monochrom> You should update to 6.4.2 anyway :)
20:42:31 <dolio> So, dons, I don't know if this helps you any, but...
20:42:41 <dolio> ?pl \_ -> ()
20:42:42 <lambdabot> id
20:42:45 <dolio> ?pl \x -> ()
20:42:45 <lambdabot> const ()
20:42:54 <sjanssen> the strictness doesn't matter much, the recursion gets O(log n) deep, which is small for any reasonable input
20:43:14 <dolio> It's going to be a while before I understand Pl enough to write you a patch. :)
20:43:21 <dons> I was hoping it would unbox the Int#
20:43:35 <emu> dons: well thanks for the effort; i'll have to download it tomorrow most likely
20:43:55 <emu> but i did have a question w/regard to the 6.2 compat code: how could i make it work with Ints
20:44:41 <dons> ok, a pure h98 version wouldn't be hard. let's see
20:45:13 <emu> hmm fromIntegral helped
20:45:21 <Pseudonym> ?pl \_ -> 2
20:45:22 <emu> i'm still getting used to these to* from* functions
20:45:22 <lambdabot> const 2
20:45:35 <Pseudonym> ?pl \_ -> (1,2)
20:45:36 <lambdabot> const (1, 2)
20:45:38 <Pseudonym> Hmm.
20:45:55 <dolio> Pseudonym: () is the problem.
20:45:59 <Pseudonym> Right.
20:46:00 <dolio> ?pl return ()
20:46:01 <lambdabot> return
20:46:08 <dolio> ?pl 2 () ()
20:46:09 <lambdabot> 2
20:46:14 <Pseudonym> That's weird.
20:46:25 <Pseudonym> ?pl \() -> ()
20:46:25 <lambdabot> (line 1, column 3):
20:46:25 <lambdabot> unexpected ")"
20:46:25 <lambdabot> expecting pattern
20:46:37 <Pseudonym> ?pl \(1) -> ()
20:46:38 <lambdabot> const ()
20:46:47 <Pseudonym> ?pl \(1) -> 2
20:46:47 <lambdabot> const 2
20:46:51 <Pseudonym> That's not correct either.
20:46:57 <dolio> Yeah.
20:47:08 <Pseudonym> ?pl \(a,b) -> a
20:47:09 <lambdabot> fst
20:47:48 <dolio> ?pl \(a,b,c) -> a
20:47:49 <lambdabot> (line 1, column 6):
20:47:49 <lambdabot> unexpected ","
20:47:49 <lambdabot> expecting letter or digit, operator or ")"
20:47:49 <lambdabot> ambiguous use of a non associative operator
20:49:54 <Pseudonym> Definitely evidence that we need to all agree on a parser.
20:52:31 <lisppaste2> dons annotated #25516 with "keepin' it h98" at http://paste.lisp.org/display/25516#5
20:52:33 <dons> emu, here you go ^^
20:54:36 <AStorm> Oh, another probably basic question.
20:54:41 <AStorm> What's the bignum type in Haskell?
20:54:44 <emu> print prints a readable format?
20:54:47 <emu> Integer
20:54:55 <wkh> god dammit, fuck Squeak! fuck Smalltalk!
20:54:55 <AStorm> Integer one.
20:54:57 <AStorm> No, it isn't.
20:55:07 <AStorm> At least it seems it isn't.
20:55:16 <AStorm> I'll recheck :>
20:55:18 <jrmole> AStorm, Integer is arbitrary precision
20:55:21 <Pseudonym> wkh: God has already damned Smalltalk.
20:55:22 <jrmole> Int is machine-size
20:55:27 <Pseudonym> You don't need to ask again.
20:55:32 <AStorm> Ah damn.
20:55:36 <AStorm> Not an alias :-)
20:57:40 <emu> dons: very nice
20:57:52 <AStorm> And infinite precision floating point?
20:58:16 <Pseudonym> Nope.
20:58:19 <emu> dons: yea I see how you did Int division and used the IO monad stuff directly
20:58:22 <Pseudonym> Rational might help, though.
20:58:30 <AStorm> Hmm.
20:58:42 <AStorm> I'll see.
20:58:49 <jcreigh> wkh: Why? What's so bad about Smalltalk?
20:59:03 <AStorm> Those are probably described in Prelude docs, right?
20:59:16 <jrmole> think so
20:59:26 <jrmole> aren't Rational and infinite-precision-floating conceptually the same?
20:59:45 <AStorm> More or less.
20:59:51 <Pseudonym> Smalltalk is the Lisp of OO programming.
20:59:56 <AStorm> If it's true mathematical Rational.
20:59:56 <dfranke> rationals can be repeating as well as terminating.
20:59:58 <Pseudonym> We have newer languages.
21:00:10 <emu> newer isn't always better
21:00:16 <Pseudonym> Eiffel, Sather, Modula-3, even Ada are much better.
21:00:33 <Pseudonym> IMO of course.
21:00:46 * araujo doesn't agree
21:01:14 <araujo> Pure languages tend to be more clean and rich of expressiveness
21:01:51 <AStorm> Tell that to Python <rotfl> - but Haskell indeed is expressive.
21:01:57 * araujo got to Haskell from Smalltalk
21:01:59 <emu> dons: does supplying the explicit typing help z'?
21:02:07 <dons> it forces things to be Int, yep
21:02:20 <dons> there'd be other ways, default (Int), for example
21:02:21 <emu> retricting  from the general
21:02:30 <Pseudonym> Haskell is expressive because it has syntax to simulate impurity.
21:02:34 <Pseudonym> Without actually being impure.
21:02:46 <araujo> uh?
21:02:49 <AStorm> Smalltalk lacks it.
21:02:53 <Pseudonym> Amongst other things.
21:02:54 <dons> without the Int you get z' :: forall a t. (Integral t, Integral a) => a -> a -> t -> a
21:03:01 <araujo> Pseudonym, that argument is so wrong
21:03:23 <araujo> Haskell expressiveness is because of its purity.
21:03:39 <jrmole> araujo, it's correct among other things
21:03:52 <araujo> And actually, whenever you try to emulate imperative stuff, you end up with more messy stuff.
21:04:00 <Pseudonym> It depends what you're doing.
21:04:04 <jrmole> araujo, there are some things that can't be done cleanly
21:04:17 <Pseudonym> The thing I like about Haskell is it has nice ways to do ugly things.
21:04:19 <araujo> jrmole, i don't talk about other things atm
21:04:25 <araujo> i am talking in a general sense.
21:04:27 <dons> emu, you could also write:
21:04:28 <dons> main = do getLine
21:04:28 <dons>           mapM_ (print . z . read) . lines =<< getContents
21:04:28 <dons> z n = z' 0 n (floor (logBase 5 (fromIntegral n)))
21:04:28 <dons> z' r _ 0 = r
21:04:30 <wkh> my frustration with Smalltalk is not the lanugage bht the community, the lack of documentation and help, and the confusing environment
21:04:30 <dons> z' r n k = z' a n (k-1 :: Int)
21:04:33 <dons>     where a = r + n `div` (5^k) :: Int
21:04:33 <Pseudonym> Some problems are just plain ugly.
21:04:51 <emu> just read by itself?
21:04:53 <araujo> Pseudonym, Yes, that's right. It is because of its purity mainly.
21:04:56 <Pseudonym> Right.
21:05:07 <dons> emu, yes, the other types already constrain read
21:05:17 <Pseudonym> IMO, the best languages give you ways to implement what you need to in the style that you need to do it.
21:05:24 <Pseudonym> If you need imperative code in Haskell, you can simulate that.
21:05:30 <Pseudonym> But it's still pure.
21:05:33 <jrmole> haskell allows you to use imperative (what many people call "impure") style without sacrificing purity, ever
21:05:35 <jrmole> yes
21:05:43 <Pseudonym> And that's my argument.
21:05:45 <Korollary> I don't subscribe to smalltalk's "+" is a message you send to a number object argument
21:05:52 <dons> heh
21:05:53 <Pseudonym> That it lets you simulate ugliness.
21:05:57 <Pseudonym> If you need it.
21:06:12 <dons> ?remember Korollary I don't subscribe to smalltalk's "+" is a message you send to a number object argument
21:06:13 <araujo> Korollary, that's what OO is all about :-P
21:06:23 <dons> yay for the land of verbs
21:06:26 <araujo> In the same way, (+) is a function in Haskell.
21:06:49 <AStorm> This Rational type is decimal maths, nice :-)
21:06:53 <araujo> And, it is precisely _that_ what purity offers us among many other things.
21:07:05 <jrmole> AStorm, it's precisely a ratio of two Integers
21:07:07 <Korollary> How is that in the "same" way?
21:07:11 <Pseudonym> The fact that "+" is a message proves, IMO, what's wrong with _pure_ OO.
21:07:13 <emu> cool, yea the z' explicit type really helps a lot
21:07:41 <araujo> Korollary, Haskell purely functional , Smalltalk OO pure
21:07:41 <Pseudonym> All good general-purpose languages let you think you're programming multi-paradigm.
21:07:49 <AStorm> jrmole: well yes
21:07:56 <Korollary> araujo: The two "pure"s are not the same pures.
21:08:05 <Korollary> It's terminology clash.
21:08:24 <Pseudonym> Right.
21:08:33 <Pseudonym> Haskell is pure functional in the sense of functional and purely declarative.
21:08:45 <Pseudonym> Smalltalk is OO and nothing else.
21:08:47 <jrmole> AStorm, you can import module Ratio and get ratios of other things too :)
21:09:11 <araujo> Korollary, They are , in the same you have most of the structures/methods/types... represented as first class citizens adopted in the programming model. And that is my point about purity in this case.
21:09:19 <AStorm> thanks, First I have to read the library doc.
21:09:25 <dons> emu: you mean in terms of performance?
21:09:42 <araujo> I am not saying Haskell == Smalltalk please
21:09:53 <jcreigh> @pl \x -> x*x
21:09:54 <lambdabot> join (*)
21:09:56 <jrmole> the defining property of a functional language (functions are first-class) states the existence of a capability, whereas the defining property of an OO language (everything must be used as an object) forces certain capabilities and the absence of others
21:10:22 <dons> mm. i like that point, jrmole
21:10:38 <jrmole> thanks, i'm not actually sure it's correct though :)
21:10:43 <jrmole> not knowing "theoretical" OO like smalltalk well enough
21:10:56 <jrmole> but it sounded good and i thought i'd throw it out there
21:11:07 <araujo> Korollary, For example , your first class functions way of thinking from Haskell work pretty well into the Smalltalk model too.
21:11:07 <dons> sounds plausible
21:11:23 <araujo> But now through an OO methodology of course.
21:11:32 <jcreigh> hmm...where is "join" defined?
21:11:34 <araujo> Andn it is because of both languages being pure.
21:11:49 <Cale> jcreigh: in Control.Monad
21:12:02 <jrmole> or just Monad in haskell98
21:12:12 <Cale> jcreigh: and in that case, the instance for Monad is the one for ((->) r)
21:12:34 <jrmole> @pl \f x -> f x x
21:12:34 <lambdabot> join
21:12:57 <jrmole> i like to think of an imperative language as the subset of a functional language where your values happen to never be functions
21:12:59 <Cale> @pl \f g x -> f x (g x)
21:12:59 <lambdabot> ap
21:13:33 <Cale> jrmole: but in an imperative language, you consider the order in which things occur a lot more than in a functional language too
21:14:00 <Cale> I suppose it depends on which functional language you're talking about.
21:14:05 <jrmole> Cale, in a functional language with side effects you have to consider order too
21:14:09 <Cale> yeah
21:14:27 <jrmole> i guess another small but important FP property is tail recursion
21:14:39 <jrmole> without which you end up using loops
21:14:46 <Cale> Though mostly even in such languages, the accepted style is to avoid having things depend on order as much as possible
21:14:47 <jrmole> which are inherently more procedural than declarative
21:14:54 <emu> dons: yes
21:14:55 <jrmole> this is true
21:14:59 <emu> dons: halves my running time for one
21:15:32 <dons> cool
21:16:23 <dons> imperative programming is just a specialised form of FP anyway, where for some (silly ;) reasons you program in terms of changes to a single state value.
21:16:29 <dons> what a strange, restricted way to program
21:17:00 <Cale> "single"
21:17:10 <emu> i agree, imperative languages assume a monad =)
21:17:13 <dons> RealWorld#
21:17:30 <emu> dons: i think the real stickler here is the '98 I/O
21:17:49 <dons> they assume the IO monad. why you'd restict yourself to just that in a language is beyond me :)
21:18:10 <dons> imperative == crippled subset of FP
21:18:23 <emu> i'm assuming you have to go beyond H98 for serious IO perf?
21:18:24 <Cale> I actually dislike the approach that IO = State RealWorld#, even if it's implemented in a manner similar to that.
21:18:37 <Cale> It's really implemented like that, plus cheating :)
21:18:45 <dons> emu, well, i use Data.ByteString for serious IO stuff, which is h98+ ffi +cpp
21:19:11 <dons> if its large strings you need to throw around
21:19:58 <dons> its similar to the way dynamic typing is just a crippled subset of static typing, where you do all your checks at runtime, and have a single static type
21:20:00 <emu> in this line-at-a-time SPOJ stuff, i dunno
21:20:19 <dons> so you can always add imperative or dynamic types to a purely function, statically typed lang, but not the other way around
21:20:33 <emu> there are a few things dynamic typing can do which i haven't seen in any static typed language, though i don't see why not
21:21:04 <emu> you can't redefine types at runtime in a static language
21:21:08 <dons> > [toDyn 'x', toDyn "foo", toDyn (1.0 :: Float), toDyn (Just ()) ]
21:21:10 <lambdabot>  [<<Char>>,<<[Char]>>,<<Float>>,<<Maybe ()>>]
21:21:14 <Cale> 'eval' is a good example of something you don't really see often in statically typed languages, and (thanks dons!) we have that now :)
21:21:19 <jrmole> @type toDyn 'x'
21:21:21 <lambdabot> Dynamic
21:21:39 <newsham> could one make an efficient implementation of a strict functional language with side effects (ie. ocaml) on something like the spineless-taggless g machine?
21:21:40 <emu> whereas languages like Common Lisp actively allow you to do that
21:21:51 <emu> as well as supply optional static types where you want
21:22:02 <jrmole> newsham, g-machine is unnecessary in strict languages
21:22:09 <jrmole> as you don't need to do graph reduction
21:22:21 <dons> emu, but do you still have to deal with the runtime checks? or are they tossed out?
21:22:25 <jrmole> since you never have the notion of "keep this unevaluated now, but if it gets evaluated save it for later uses"
21:22:27 <Cale> well, you are doing graph reduction still, but it's just trivial :)
21:22:29 <emu> they can be tossed out if desired
21:22:31 <dons> i.e. do you pay for runtime checks you've already statically proven aren't needed?
21:22:42 <jrmole> Cale, yes, since everything stays a tree
21:23:00 <newsham> jrmole: does that mean that it wouldn't be as efficient on such a machine?
21:23:12 <emu> cmucl and sbcl contains a pretty strong type inference system which, when permitted, will remove runtime checks and output lots of static type notes and warnings
21:23:18 <jrmole> newsham, it at least means you wouldn't use many of the machine's features
21:23:23 <newsham> it would be nice at times to have a language like ocaml with nicer haskell-like syntax.
21:23:38 <Cale> newsham: It would be at least a constant factor waste of efficiency.
21:23:47 <jrmole> yeah, aren't there some strict haskell projects?
21:23:50 <Cale> (to use STG)
21:24:05 <jrmole> i think at least some nicer sugar for adding strictness annotations would be good
21:24:19 <Cale> jrmole: We're going to get some :)
21:24:26 <jrmole> pragmas to say "in this chunk of code, all applications should be $!", that sort of thing
21:24:35 <jrmole> Cale, how close is it, and what form does it take?
21:24:35 <Cale> bang-patterns
21:24:44 <dolio> Weren't bang patterns slated for 6.6?
21:24:45 <newsham> not just strictness.. also side effects.
21:24:52 <Cale> dolio: They'll be in there
21:25:02 <Cale> jrmole: It's just some sugar for extra seq's
21:25:05 <emu> i dunno if it was just SML, but i got annoyed at the inflexibility of data structures in ML, something which isn't the case in Haskell
21:25:22 <Cale> http://hackage.haskell.org/cgi-bin/haskell-prime/trac.cgi/wiki/BangPatterns
21:25:26 <lambdabot> Title: BangPatterns - Haskell Prime - Trac, http://tinyurl.com/oau5m
21:25:50 <jrmole> emu, Haskell's type system is in many ways more flexible than ML's
21:25:56 <emu> oh it's waay more flexible
21:26:26 <emu> i remember one peeve i had while writing a sizable SML program was the complete lack of the "functional update" mechanism
21:26:37 <emu> taking a record type adn returning a new value with one slot updated
21:28:02 <emu> yea like (p {pointx=2}) in Haskell
21:30:08 <NoGoodNik> is it possible to make a type that represents non-empty lists?
21:30:45 <Cale> data NEList a = One a | Cons a (NEList a)
21:31:13 <NoGoodNik> is it possible to make a type that represents non-empty lists?
21:31:15 <NoGoodNik> err
21:31:39 <NoGoodNik> is possible to substitute such a list wherever a regular list is expected?
21:31:43 <Cale> no
21:31:48 <NoGoodNik> (keyboard malfunction)
21:31:50 <Cale> it's a separate type altogether
21:32:51 <emu> i mean, it would break all sorts of things about list functions
21:33:01 <NoGoodNik> yeah, now that I think about it
21:33:09 <emu> length [] = 0; length (_:xs) = 1 + length xs
21:34:44 <Cale> But it's certainly possible to write a function NEList a -> [a], so you can throw away that guarantee as soon as it's inconvenient. :)
21:35:06 <emu> hmm how about using monads
21:35:15 <emu> (Monad NEList)
21:35:18 <Cale> sure
21:35:25 <Cale> return x = One x
21:35:33 <NoGoodNik> ... you're joking, right?
21:35:34 <monochrom> It is just not a MonadZero.
21:35:41 <emu> not at all
21:35:45 <emu> monads are a means of abstraction
21:35:51 <Cale> fmap f (One x) = One (f x)
21:35:58 <jrmole> represents functions which nondeterministically return one or more results
21:35:59 <monochrom> But I doubt the utility of a specialized non-empty list type.
21:36:05 <Cale> fmap f (Cons x xs) = Cons (f x) (fmap f xs)
21:36:23 <Cale> and then you have join, which is essentially the same as concat
21:36:32 <Pseudonym> Oleg's paper on capabilities is quite nice.
21:36:36 <Cale> you end up with something a lot like the list monad, just without failure.
21:36:38 <jrmole> you can't define fail nicely, but that's okay
21:36:46 <Pseudonym> It explains another approach.
21:36:50 <Cale> fail is stupid and should die anyway
21:36:59 <jrmole> fail is nice sugar
21:37:01 <Pseudonym> fail is a necessary evil
21:37:08 <Pseudonym> Evil, but necessary.
21:37:13 <Cale> I consider it unnecessary
21:37:21 <jrmole> of course it's unnecessary
21:37:27 <jrmole> so is the do notation in general
21:37:34 <Pseudonym> How would you handle pattern match failure?
21:37:36 <lispy> i'd say seq is probably eviler but we need it...
21:37:41 <Cale> A simple way to remove the need for it is to disallow refutable patterns on the lhs of <-
21:37:56 <jrmole> Cale, it's not a matter of "need"
21:38:00 <jrmole> fail provides extra expressiveness
21:38:14 <Cale> A more complicated way is to have those refutable patterns generate a MonadZero constraint.
21:38:23 <monochrom> But I really love "(x:xs) <- yay"
21:38:45 <Cale> and in the right monads, that would still be available, with my second suggestion
21:38:48 <monochrom> Oh, MonadZero for my "(x:xs) <- yay" I have no problem with.
21:38:52 <Cale> yeah
21:38:57 <jrmole> yeah, that's fine
21:39:22 <lispy> will that be the case in haskell'?
21:39:32 <Pseudonym> Yeah, that's not bad.
21:39:40 <Cale> I would like it to be that way
21:39:54 <Cale> but there seem to be a few people who vehemently defend fail
21:39:59 <Pseudonym> I'd suggest one more thing to augment that.
21:40:19 <Pseudonym> commit :: (MonadZero m, Monad n) => m a -> n a
21:40:19 <monochrom> The Arrows desugaring procedure already adds constraints like ArrowChoice, ArrowApply, etc., as it goes.  E.g., it adds ArrowApply iff you mention "-<<".
21:40:24 <Pseudonym> Which calls error.
21:40:34 <Pseudonym> Hmmm.
21:40:37 <Cale> Sure, that'd work.
21:40:38 <Pseudonym> Actually, that doesn't work.
21:40:42 <Pseudonym> But something like that.
21:40:47 <Cale> Well, okay
21:40:52 <lispy> why is fail evil?
21:41:05 <Cale> lispy: It's not part of the definition of a monad :)
21:41:05 <monochrom> We need assassins to deal with those few vehement people :)
21:41:25 <Cale> lispy: and so ends up being defined in stupid ways for many monads
21:41:32 <Cale> like  fail = undefined
21:41:41 <jrmole> commit :: (MonadCommit m n) => m a -> n a ?
21:41:57 <monochrom> How about this?  We ditch monads and use arrows instead.  Things are done quite right there. :)
21:42:00 <Cale> I think we should avoid having class members which go unimplemented in general.
21:42:13 <Pseudonym> What you kind of want here is a failure wrapper.
21:42:13 <Cale> jrmole: yeah, that's more like it
21:42:22 <jrmole> fail = error is sensible though, it's what normally happens in pattern match failure
21:42:22 <Pseudonym> A failure transformer.
21:42:29 <lispy> Cale: and the rest of the time, file = mzero?
21:42:37 <jrmole> you can't really expect pattern match failure to have some sensible recovery by default
21:42:46 <Cale> lispy: yeah, that happens a lot too, ignoring the string parameter
21:42:48 <Pseudonym> Actually, here's an idea.
21:42:58 <Pseudonym> Make a MonadFail class.
21:43:05 <Pseudonym> Similar to MonadZero.
21:43:06 <Cale> yes indeed!
21:43:14 <lispy> Cale: well, i meant to type fail = mzero, but you seemed to understand what i meant :)
21:43:19 <Pseudonym> class (MonadFail m) => MonadZero m where
21:43:22 <jrmole> i like being able to attach extra information to failure, as with the string in fail
21:43:24 <Pseudonym>     mzero = fail "zero"
21:43:25 <Cale> lispy: of course :)
21:43:41 <jrmole> Pseudonym, you could parametrize on the error type
21:43:49 <jrmole> so it's not just strings
21:44:00 <Pseudonym> That doesn't help with pattern match failures.
21:44:11 <jrmole> Pseudonym, true
21:46:46 <lispy> Cale: i wish Num was made into a proper ring regardless of what theyh want to name it
21:47:19 <Cale> lispy: Well, abs and signum don't belong there regardless
21:47:33 <lispy> agreed
21:47:45 <lispy> some of the other number classes don't make a lot of sense
21:47:56 <Pseudonym> Disagreed in part.
21:47:59 <Cale> lispy: The main problem with improving the numeric and functor hierarchies is that fine-graines class hierarchies kind of suck in Haskell.
21:48:03 <Cale> grained*
21:48:05 <lispy> i wanted to make my data type for excel formulas into rationals and i couldn't
21:48:15 <Pseudonym> Num should be a subclass of a bunch of stuff.
21:48:30 <Pseudonym> What constitutes a "Num" is somewhat arbitrary.
21:48:37 <Cale> Pseudonym: but not Eq and Show :)
21:48:39 <Cale> hehe
21:48:47 * Pseudonym laughs
21:49:29 <lispy> i was surprised taht i could make my forumals an instance of Floating but not fractional
21:49:37 <lispy> and it had to do with some stupid thing like Enum
21:50:24 <lispy> although, i'll probably never miss fractional
21:50:45 <Cale> Unless you want to use them with Rational
21:50:59 <emu> i like Rational
21:51:33 <lispy> but, it's so cool that i can say, show $ sum xs -- where xs are a bunch of formulas and then, it actually shows the Excel formula that is them added together
21:54:05 <lispy> i was trying to follow the example created by the pretty printer and define things like ($$) and (<>) for my cells to help lay them out in a grid...but it's a complete pain the ass
21:54:09 <lispy> not sure what i should do about that
21:54:24 <monochrom> "data Stack a = a :> (Stack a) | (:||)"  Is this a joke?  I mean all those emoticons.  7 :> 8 :> 2 :> (:||)  :O
21:54:58 <lispy> actually, i thought the notation was cute :)
21:55:01 <jrmole> monochrom, infix constructors have to start with :
21:55:14 <jrmole> if you like cute datastructures...
21:55:30 <lispy> too bad the bottom constructor has to have parens
21:55:31 <jrmole> i used some C++ text in high school that illustrated a stack as a bunch of stick people standing on each other's heads
21:55:48 <lispy> 2 :> 3 :|| -- would have looked so much better
21:55:50 <monochrom> That's sad.
21:56:26 <lispy> actually, if i were implementing a stack in haskell i'd just use a list :)
21:56:37 <lispy> data Stack a = Stack [a]
21:56:40 <newsham> 8-) 3  >
21:57:41 <lispy> pop = tail
21:57:54 <lispy> actualy, i guess you could do it better
21:58:09 <lispy> pop (x:xs) = (x, xs)
21:58:35 <sjanssen> @pl \xs -> (head x, tail xs)
21:58:36 <lambdabot> (,) (head x) . tail
21:58:40 <lispy> or go with pop = tail and define peek (x:xs) = x
21:58:43 <sjanssen> bleh
21:59:22 <lispy> push = (:)
21:59:36 <lispy> ?pl \xs -> (head xs, tail xs)
21:59:36 <lambdabot> liftM2 (,) head tail
22:00:31 <newsham> > (\avg -> (avg 2 ((+) 3 5))) (\a b -> ((/) ((+) a b) 2))
22:00:33 <lambdabot>  5.0
22:00:50 <lispy> um
22:00:54 <monochrom> > let shoulder xs = tail xs in (head &&& shoulder) "abc"
22:00:56 <lambdabot>  ('a',"bc")
22:01:04 <lispy> hehe
22:01:15 <lispy> newsham: doing lisp in haskell?
22:01:24 <newsham> thats lisp?
22:01:43 <lispy> well, lisp syntax isn't far off from lambda calc notation
22:01:56 <jrmole> you're using math operators in prefix instead of infix
22:02:35 <newsham> >(\avg -> (avg 2 (3 + 5))) (\a b -> (a + b) / 2)
22:02:44 <newsham> > (\avg -> (avg 2 (3 + 5))) (\a b -> (a + b) / 2)
22:02:45 <lambdabot>  5.0
22:25:54 <lokadin> i need to make a conditional statement like when, but returning an actual value not just (), i'd use if, but i don't know what to put in the else
22:26:16 <emu> the actual value
22:26:26 <lokadin> hmm
22:26:32 <lokadin> one sec let me look it up
22:26:49 <Korollary> if you don't really care, you can put undefined.
22:27:01 <lokadin> what will that do?
22:27:09 <lokadin> and how do i put it
22:27:15 <Korollary> if the else branch runs, it'll give a runtime error
22:27:24 <Lemmih> > if True then () else undefined
22:27:25 <lambdabot>  ()
22:27:28 <Lemmih> > if False then () else undefined
22:27:29 <lambdabot>  Undefined
22:27:37 <lokadin> well it runs lots, actually, that's the problem i'm having
22:28:08 <lokadin> currently it's set to fail, but it shouldn't actually, it should just fail parsing or what not, but i have no idea how to signify that
22:28:38 <Korollary> The error handling strategy there depends on what you're trying to do.
22:29:32 <lokadin> well, i don't want it to throw an error, that's the thing, i just don't want it to think the string has been parsed
22:30:38 <lokadin> hmmm
22:30:42 <lokadin> here i'll just paste the line
22:30:59 <lokadin> jvo1 = do {rafsi -> abu; if abu == filter isUpper abu then do {rafsi -> by; return (abu ++ by)} else return ""}
22:31:32 <lokadin> the else return "" i just added now and it doesn't work, makes it seem like a success every time
22:32:05 <Lemmih> What monad are you using?
22:32:23 <lokadin> Parsec ?
22:32:32 <Lemmih> How about using 'fail' or returning a Maybe?
22:33:03 <Lemmih> @type fail
22:33:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:33:11 <lokadin> i tried fail, but it stops anything that comes after it as well
22:33:13 <lokadin> er
22:33:51 <lokadin> >lujvo = do {try (jvo1) >>= return} -- try first lujvo variant: second last rafsi upper case
22:33:52 <Lemmih> Well, yeah. I guess I don't quite get what you want.
22:33:55 <lokadin> >    <|> do {try (jvo1h)>>= return}
22:33:55 <lambdabot>  Parse error
22:34:04 <lokadin> i don't believe with fail it doesn't get to the second line
22:34:07 <lokadin> er
22:34:10 <lokadin> i believe 8
22:34:33 <lokadin> i tried it, didn't give me any compile time errors, but it would never ever be true for lujvo
22:36:48 <Lemmih> lokadin: fail <|> b === b, for me at least.
22:37:48 <lokadin> so just to put that in the else?
22:38:42 <lokadin> says not in scope b === b
22:38:42 <Lemmih> Yeah.
22:39:13 <lokadin> hmmm
22:39:24 <Lemmih> I was trying to say that 'fail <|> b' equals 'b' for any 'b'.
22:39:50 <lokadin> i thought that meant, try to fail, if that doesn't work then b === b
22:40:43 <lokadin> if i'm nwell i know i'm supposed to return something like GenParser tok st a
22:40:58 <lokadin> can i do anything with that?
22:41:11 <tibbe> good morning
22:41:30 <Lemmih> Just call 'fail' and you'll be fine.
22:41:37 <lokadin> tibbe: good morning
22:42:25 <lokadin> Lemmih: fail with a string..?
22:42:34 <Lemmih> lokadin: Yes.
22:42:54 <Cale> Why not mzero?
22:43:28 <Lemmih> Cale: I'd prefer something like 'fail "abu should be uppercase"'.
22:44:57 <Lemmih> lokadin: Btw, 'all isUpper abu' would probably be better.
22:45:09 <lokadin> oh okay thanks :)
22:45:48 <Cale> @docs Text.ParserCombinators.Parsec.Error
22:45:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Error.html
22:46:05 <Cale> That provides a lot of tools for controlling parse errors.
22:47:52 <lokadin> cool, thanks :) i think i'm good for now
22:58:14 <NoGoodNik> is it possible to write concurrent programs with GHC?
23:01:29 <lokadin> is there any way of making an empty char?
23:01:35 <tibbe> NoGoodNik: yes
23:01:55 <tibbe> @docs Control.Concurrent
23:01:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
23:02:07 <NoGoodNik> thanks
23:02:12 <tibbe> You're welcome
23:19:31 * tibbe is off to work
23:24:52 <NoGoodNik> is it possible to write a function that flattens arbitrarily nested lists?
23:25:13 <Pseudonym> Kind of.
23:25:22 <NoGoodNik> I get Occurs check: cannot construct the infinite type: a = [a]
23:25:42 <NoGoodNik> Am I doing something wrong?
23:25:48 <Pseudonym> Well, it's possible to write such a function, but it's not possible to create an object which has lists of different nesting depths.
23:25:52 <NoGoodNik> I'm not sure what the type of such a function would be.
23:26:01 <_velco> umm, what wopuld be the type of an "arbitrarily nested list" ?
23:26:02 <Pseudonym> class Flatten a where
23:26:14 <Pseudonym> Hang on.
23:26:22 <Pseudonym> class Flatten a b | a -> b where
23:26:26 <Pseudonym>     flatten :: a -> b
23:26:27 <NoGoodNik> good question, _velco ...
23:26:34 <Pseudonym> instance Flatten [a] a where
23:26:40 <Pseudonym> Erm.
23:26:54 <Pseudonym> Anyway, you can do it with type classes.
23:27:03 <Pseudonym> And Glasgow extensions.
23:27:07 <Pseudonym> Like overlapping instances.
23:27:16 <Pseudonym> So it's not really a function, it's a family of functions.
23:27:25 <NoGoodNik> Getting hairy.
23:27:29 <Pseudonym> Yeah.
23:27:51 <Pseudonym> If you really want this, you might be better off making your own type.
23:28:02 <_velco> a tree
23:28:14 <NoGoodNik> is that what one calls these things.
23:28:25 <Pseudonym> data NestedList a = Nil | Obj a | NestedList a :+: NestedList a
23:28:33 <Pseudonym> We call them "s-expressions", actually.
23:29:09 <NoGoodNik> Fine.
23:29:28 <Pseudonym> @foldoc s expression
23:29:31 <lambdabot> *** "s" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:29:32 <lambdabot> S
23:29:32 <lambdabot>  
23:29:32 <lambdabot>     <language> A statistical analysis language from {AT&T}.
23:29:32 <lambdabot>  
23:29:33 <lambdabot> [37 @more lines]
23:29:36 <Pseudonym> @foldoc "s expression"
23:29:38 <lambdabot> No match for ""s expression"".
23:29:42 <Pseudonym> @foldoc "s-expression"
23:29:43 <lambdabot> No match for ""s-expression"".
23:29:45 <Pseudonym> Hmm.
23:29:51 <NoGoodNik> I heard of them, thanks :-)
23:29:52 <Pseudonym> ?google "s expression"
23:29:55 <lambdabot> http://en.wikipedia.org/wiki/S-expression
23:29:56 <Pseudonym> Right. :-)
23:33:59 <lokadin> is there any way of making an empty char?
23:34:01 <lokadin> oops
23:39:49 <lokadin> can i have a do construct inside a case?
23:40:02 <monochrom> Yes absolutely
23:41:10 <Pseudonym> You can have an anything inside an anything.
23:41:19 <Pseudonym> Except a where clause.  But let is fine.
23:43:21 <emu> geez spoj runs on a PIII 700MHz
23:43:24 <emu> no wonder
23:47:04 <lokadin> cool
23:47:05 <lokadin> :)
23:47:06 <lokadin> thanks
23:48:52 <dibblego> how does one observe a system state change in a purely functional environment?
23:50:18 <lokadin> well it won't be purely functional if there is a change
23:50:31 <lokadin> kinda like a rock
23:50:37 <dibblego> then you cannot write software where there is system state change
23:50:49 <dibblego> state change requires mutable time
23:51:08 <lokadin> well with no siedeffects programs are pretty useless
23:51:20 <lokadin> that's right
23:51:25 <dibblego> well I argue that they aren't - only in a practical sense
23:51:34 <dibblego> I could pass the entire universe as a function argument
23:51:49 <dibblego> it is a pure function always
23:51:54 <lokadin> true, it's just they aren't usefull to whoever is outside the functional environment
23:52:12 <dibblego> right, so I am trying to formalise this barrier
23:52:22 <dibblego> or at least, try to find someone/thing who already has
23:52:36 <dolio> That's one way of interpreting IO.
23:52:44 <dolio> IO = State Universe
23:52:52 <lokadin> i wonder, if you can take into account state, could you have a next to purely functional computer?
23:53:10 <lokadin> er well state of just say the computer
23:53:18 <lokadin> and network or w/e matters
23:54:08 <dibblego> what criteria is used to draw the distinction between pure functional and a world with state change?
23:55:06 <lokadin> i was actually thinking of getting a server that keeps track of system state and tries to correlate it to functions that are state dependant, so it could eventually predict their output, allows for you to substitute in new functions, and check their input output, to make sure it's not a malicous piece of software
23:55:08 <jrmole> dibblego, i would say referential transparency
23:55:27 <dibblego> jrmole, yes, but when you decide not to use it
23:55:31 <jrmole> but then it's just a matter of passing the world, as was said, and as the IO monad (conceptually) does
23:55:43 <dibblego> jrmole, for example, I could pass the file system as a function argument - then we no longer need the IO monad
23:55:55 <lokadin> how about the monitor
23:56:03 <dibblego> since this is impractical, we decide not to
23:56:08 <dibblego> when do we stop?
23:56:12 <jrmole> that's a step backwards -- all of the explicit state-passing is precisely what the IO monad makes implicit
23:56:13 <dibblego> what formal criteria exists?
23:57:00 <dibblego> I see no problem with an immutable file system, except that no such thing exists today
23:57:06 <lokadin> wouldn't a haskell function that, say does addition, not be stateless in a bash shell?
23:57:28 <jrmole> dibblego, i don't think there is a formal criterion
23:57:48 <dibblego> jrmole, well at least there might exist an informal one that "most people use"
23:57:49 <jrmole> as you said, you can always just pass the world as an extra argument -- and the IO monad is basically just sugar for this
23:58:03 <dibblego> ok I'll read up some more, thanks
23:58:21 <dolio> Clean passes the world as an argument.
23:58:24 <jrmole> informally i think people would say that only IO types can have "side effects"
23:59:02 <dibblego> dolio, are you saying that there are only pure functions?
23:59:10 <jrmole> because, even if you were to invent your own system of passing filesystem values or whatever around, eventually something outside the Haskell system, in your compiler or interpreter, has to take those values and actually make them happen
23:59:19 <dolio> In Clean? I suppose.
23:59:24 <jrmole> and the only way to do that in standard Haskell is through the IO monad
23:59:30 <jrmole> dibblego, no, it's actually the opposite
