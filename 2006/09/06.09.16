00:00:02 <wolverian> I always run the automatic scaling mode.
00:00:30 <glguy> deadbeef: What operating system would you expect something as fine as lambdabot to run on?
00:00:47 <deadbeef> FreeBSD/Solaris/Linux
00:01:27 <deadbeef> http://bulk.fefe.de/scalability/
00:01:29 <lambdabot> Title: Benchmarking BSD and Linux
00:01:35 <dons> that's old old old..
00:01:40 <weitzman> QNX?
00:01:42 <weitzman> Plan 9?
00:01:49 <weitzman> Inferno?
00:01:50 <wolverian> heh, that's a 404 without the trailing /.
00:01:53 <deadbeef> weitzman: i used qnx for a while on my laptop
00:02:01 <weitzman> Far out
00:02:01 <wolverian> @karma- badly configured servers
00:02:01 <lambdabot> badly's karma lowered to -1.
00:02:11 <deadbeef> it's awesome
00:02:17 <wolverian> er
00:02:22 <dons> my openbsd boxes run haskell just as nicely as on linux :)
00:02:23 <weitzman> I don't think it was intended to be used on laptops
00:02:38 <dons> sure. what do you think the openbsd devs use on their laptops?
00:02:38 <deadbeef> i used neutrino
00:02:42 <deadbeef> the developement enviroment
00:02:50 <weitzman> Then again, windows wasn't intended to be used as a workstation client on a network
00:02:51 <deadbeef> with it you get eclipse and stuff
00:03:02 <lispy> okay, runs in restricted mode now
00:03:14 <dons> its just a unix. why wouldn't it be "intended" to run on laptops?
00:03:35 <weitzman> QNX is a fault-tolerant realtime OS, right?
00:03:38 <dons> i.e. all my laptop stuff works. suspend, magic thinkpad keys, wifi ...
00:03:39 <weitzman> Micro-kernel
00:03:57 <deadbeef> weitzman: it's one more reason to use it on embedded enviroment
00:04:14 <weitzman> I don't consider a laptop an embedded environment
00:04:39 <deadbeef> now it isn't anymore
00:04:50 <deadbeef> btw QNX Neutrino is pretty advanced right now
00:04:59 <dons> openbsd isn't just for embedded systems -- anymore than freebsd or linux are.
00:05:02 <deadbeef> and microkernel is ok almost everywhere
00:05:05 <glguy> OpenBSD is designed to be free, functional, and secure operating system. those things are necessary on laptops, servers, and workstations all the same :)
00:05:49 <dons> really, it's just like a linux or freebsd system. it doesn't come with any special restrictions to embedded devices...
00:05:52 <glguy> This OpenBSD box is located 90 minutes away from me, I wouldn't run any other operating system on it... I don't intend on visiting it unless it has a harddrive failure
00:05:52 <deadbeef> microkernel architectures improve debugging, object-oriented design of the operating systems and stuff
00:06:05 <deadbeef> the whole enviroment is easier to mantain and adapt
00:06:20 <glguy> dons: If by "just like" you mean better integrated and documented, then no, it's not ;)
00:06:29 <weitzman> Microkernel's are nice, but I think I'm persuaded by the exokernel camp
00:06:40 <lispy> deadbeef: does it actually improve debuggability?  linus says no and from the looks of projects like hurd it's not easier
00:06:41 <dons> yeah. the integration is really nice.
00:06:57 <lispy> exokernel looked neat, but then they disappared
00:07:11 <dons> lispy: so that patch you sent handles the no-output-in-goa issue?
00:07:19 <lispy> no, sorry
00:07:28 <lispy> that was no-output in cgi
00:07:35 * glguy places huge value on consitency in his programming languages, operating systems, and everything in general
00:07:36 <deadbeef> lispy: consider Linux was born because "GNU/Hurd has still to be released (maybe in the next 3-4 months) and i want something to use in this period"
00:07:41 <lispy> it forces the cgi script to always output at least one character
00:07:44 <dons> ok
00:07:52 <weitzman> Xen-like stuff and library-assisted virtualization are related to exokernels
00:08:10 <weitzman> Abstract the hardware, leave the rest in the air
00:08:20 <deadbeef> btw GNU/Mach is a pain in the ass
00:09:10 <weitzman> @google synthesis operating system
00:09:11 <glguy> NetBSD is the king of hardware abstraction :)
00:09:13 <lambdabot> http://citeseer.ist.psu.edu/massalin92synthesi.html
00:09:14 <deadbeef> i hope the things to get better with Hurd/L4
00:09:16 <lispy> well, so forget GNU/Mach.  the next two microkernels would be macosx and winnt right?
00:09:19 <dons> lispy: now my goa is really borken
00:09:28 <lispy> dons: oh?
00:09:29 <deadbeef> lispy: macosx hasn't a microkernel
00:09:32 <Adamant> they aren't real microkernels
00:09:33 <glguy> WinNT is more of a hybrid kernel than a true microkernel
00:09:45 <dons> it just exits ghci immediately now on any command
00:09:46 <dons> weird
00:09:47 <arcatan> what's goa?
00:09:57 <dons> a lambdabot binding for ghci
00:10:02 <deadbeef> lispy: XNU is based on Mach, but everything is into the kernelspace, so there are less mode-switchings for the cpu
00:10:04 <lispy> dons: then setLambdabotFlags has a bad value
00:10:10 <deadbeef> lispy: so it can't be called a "microkernel" imho
00:10:19 <dons> ah
00:10:22 <deadbeef> btw L4 seems to outperform most of the unices
00:10:31 <Adamant> L4 does?
00:10:33 <lispy> dons: what value does it have?
00:10:36 <weitzman> Well, l4linux outperforms linux on x86
00:10:36 <dons> lispy: should there be a setLambdabotFlag in the .ghci file?
00:10:42 <Adamant> that's a new one on me.
00:10:43 <deadbeef> Adamant: i've read it on tanenbaum's book
00:10:47 <lispy> dons: i wouldn't think so, but maybe
00:10:54 <dons> []
00:11:13 <Adamant> Linux is moving towards user-space drivers
00:11:15 <glguy> dons: any progress with getting a new OpenBSD snapshot installed?
00:11:16 <lispy> > show [[]] :: [String]
00:11:16 <lambdabot>  Couldn't match `String' against `Char'
00:11:21 <Adamant> which is interesting.
00:11:25 <dons> glguy: working towards it
00:11:26 <deadbeef> Adamant: it's ok
00:11:32 <lispy> > show ([[]] :: [String])
00:11:32 <deadbeef> Adamant: it's more fault-tolerant and stuff
00:11:33 <lambdabot>  "[\"\"]"
00:11:40 <deadbeef> DragonFlyBSD also is going in that direction
00:11:45 <deadbeef> (it's a FreeBSD 4.x fork)
00:11:46 <wolverian> glguy, NT is hardly a hybrid kernel. it's just marketing.
00:12:08 <Adamant> wolverian, it was, but they ended up stuffing everything back in Ring 0 for performance.
00:12:20 <wolverian> heh
00:12:21 <lispy> dons: i bet the problem is that when lambdabotFlags is null that runInteractiveProcess has garbage on the commandline
00:12:23 <weitzman> Then they took a lot of it out again
00:12:29 <dons> ah maybe
00:12:31 <weitzman> Vista does GUI in userspace again
00:12:35 <lispy> dons: sorry
00:12:46 <lispy> dons: i thought i tested it, but my goa must not run wakeup
00:13:17 <dons> tyring that.
00:13:30 <dons> yep that was it
00:13:33 <dons> patching...
00:14:05 <lispy> i'll pull when you record
00:14:12 <lispy> actually i think i'll sleep for now
00:14:17 <lispy> i don't see any new logging
00:14:17 <weitzman> That paper I googled a short while ago is pretty interesting
00:14:21 <lispy> but i just ugraded lambdabot
00:14:24 <weitzman> It's about an OS that uses runtime code generation
00:14:32 <dons> lispy: in State/log ?
00:14:43 <lispy> dons: right
00:14:51 <dons> type in some commands? anything appear?
00:14:54 <dons> and you rebuilt it ..
00:15:05 <Adamant> deadbeef, DragonFly is interesting.. it looks like they are going for a Unix version of VMS
00:15:15 <dons> its working fine here. even logs goa stuff
00:15:16 <lispy> dons: can you cd to this dir? /var/www/dagit/codersbase/lambdabot
00:15:26 <Adamant> highly reliable, cluster-friendly OS
00:15:30 <lispy> dons: i rebuilt it yeah, and run vixen
00:15:35 <glguy> BSD really isn't "UNIX" as much as "POSIX" is it?
00:15:40 <dons> -bash: cd: /var/www/dagit/codersbase/lambdabot: Permission denied
00:15:47 <Adamant> "genetic UNIX"
00:15:48 <glguy> *BSD rather
00:15:58 <glguy> "UNIX-clone" ?
00:16:01 <weitzman> I don't get why plan 9 couldn't get enough developer interest to sustain itself
00:16:13 <Adamant> I think that community was pretty toxic.
00:16:25 <_velco> like every OS - no drievrs
00:17:04 <_velco> besides, isn;t it superseded by Inferno ?
00:17:15 <weitzman> Well, inferno has some rather significant restrictions
00:17:19 <weitzman> Like only running bytecode
00:17:25 <weitzman> Which is a good idea, of course
00:17:32 <weitzman> But not a popular one
00:17:51 <_velco> virtual machine with dynamic tranlation seems the right way to make runtimes these days
00:18:15 <Adamant> glguy, BSD was built on top of AT&T Unix... it only seperated from it later on
00:18:28 <_velco> true
00:18:42 <glguy> I thought that BSD was originally the IP stack of AT&T Unix
00:18:52 <glguy> and then they rewrote all fo the AT&T stuff
00:18:56 <glguy> so that it could all be free
00:19:05 <lispy> dons: logout/login and try again
00:19:18 <lispy> dons: i added you to the same group that apache runs with
00:19:27 <dons> yep works
00:19:43 <dons> log file appears to be working?
00:19:50 <lispy> it's there now?
00:19:54 <dons> yep
00:20:01 <dons> /var/www/dagit/codersbase/lambdabot/State/log
00:20:07 <lispy> oh
00:20:11 <lispy> i was looking in Log
00:20:21 <dons> ah right. that's the nice pretty log
00:20:36 <lispy> well, cool
00:20:41 <lispy> nice to see it
00:20:50 <lispy> and now you have access
00:20:53 <lispy> so that's all good
00:20:54 <Adamant> glguy, BSD started out as the work of Berkeley coders, students and profs, that extended AT&T Unix and/or replaced some of the code
00:21:15 <Adamant> one project was the IP stack and sockets.
00:21:33 <lispy> but, i really should sleep now
00:23:28 <newsham> thats why you shouldnt let students work on important code (no offense to the students in the room)
00:23:51 <Adamant> heh, software engineers would say the same thing about professors.
00:24:24 <glguy> What is why you should not let students work on code?
00:24:27 <newsham> fine by me.  leave the coding to ritchie, thompson and pike ;-)
00:24:33 <newsham> glguy: bsd sockets.
00:24:46 <Adamant> what is your problem with sockets, btw?
00:25:01 <newsham> sockets break the unix abstraction.
00:25:16 <newsham> notice that the research unix never had sockets and never will
00:25:18 <weitzman> Professors have spent all their lives in the twisted world of academia. I generally don't expect nice code from them
00:25:32 <glguy> Welp, better reboot to the new kernel while the users are sleeping!
00:25:43 <newsham> (unless you count compat libraries)
00:25:56 <weitzman> Half the theory guys haven't written code in 10 years, and the systems guys are...systems guys
00:26:19 <Adamant> the fundamental problem is that the Internet breaks the Unix abstraction.
00:26:59 <weitzman> My OS prof mentioned that it was a problem when networked filesystems came about and the close() call had no way to fail
00:27:10 <weitzman> Not that anybody would know what to do on failure
00:27:15 <newsham> "there is a saying that the problem with engineers is that they cheat in order to get results, the problem with mathematicians is that they work on toy problems in order to get results and the problem wit hprogram verifiers is that they cheat on toy problems in order to get results"
00:27:25 <Adamant> lol, nice!
00:27:32 <lispy> dons: that new patch isn't working for me, lol :)
00:27:42 <lispy> (goa patch)
00:27:47 <newsham> "OS Verification - Now!" tuch, klein, heiser.
00:28:00 <Adamant> CoyotOS!
00:28:03 <glguy> It's always nice when the remote box comes back up after having a new kernel installed
00:28:04 <Adamant> (someday)
00:28:28 <newsham> adamant: this is from the sel4/se verified guys.
00:28:33 <newsham> err l4 verified
00:28:43 <dons> lispy: yeah, there's still issues. working on it.
00:28:52 <dons> oh, you mean your goa doesn't launch?
00:29:00 <Adamant> ah, I thought you were talking about Common Criteria stuff for a second
00:29:14 <lispy> the cgi wrapper is broken now, so when sending --restricted it now breaks
00:29:17 <weitzman> I'm suspicious of the CoyotOS project. They're writing the OS in a programming language that doesn't quite exist
00:29:27 <lispy> dons: looking atthe code i can't see why
00:29:31 <Adamant> you could say the same about Unix
00:29:44 <newsham> unix was written in assembler.  it definitely existed.
00:29:51 <Adamant> well, when C existed.
00:30:17 <glguy> C still exists...
00:30:18 <newsham> i dont see how its the same.
00:30:30 <Adamant> newsham, C was ad hoc and informally verified
00:30:35 <dons> i'll see if i can set restricted
00:30:47 <glguy> This program is brought to you by the language C and the letter F.
00:30:47 <newsham> weitz didnt say anything about ad hoc or informal.
00:30:47 <Adamant> when they first wrote Unix in it
00:30:52 <glguy> err number F
00:30:59 <Adamant> ok, maybe I am missing something.
00:31:10 <Adamant> are they just writing the code on paper?
00:31:19 <weitzman> If BitC were ad hoc, it would kinda default the entire point of the language
00:31:31 <weitzman> It's supposed to let you prove properties
00:31:34 <Adamant> or are they designing the language + building the OS at the same time.
00:31:50 <newsham> they have a lot of code in C, some docs on their new proposed language BitC and maybe 2 or 3 files n the tree using the language BitC
00:32:03 <dons> lispy: setting --restricted seems to work here in goa/ghci
00:32:09 <Adamant> ah, well, that's something at least.
00:32:17 <newsham> the latter, designing and (re)building simultaneously
00:32:23 <dons> lispy, also, just pushed another patch to fix empty output
00:32:30 <lispy> dons: so my test is
00:32:42 <dons> hmm. maybe it isn't fixed hmm
00:32:44 <lispy> 1) setLambdabotFlags "--restricted"
00:32:48 <lispy> 2)  wakup
00:32:50 <gour> dons: what about building lambda on gentoo with ghc-6.6 ?
00:32:56 <lispy> 3) lambdabot "vixen" ""
00:33:18 <dons> ok, i'll try that.
00:33:33 <dons> gour: well, we know the fix is to tweak the .cabal file for haskell-src
00:34:00 <gour> dons: put the module under exposed?
00:34:22 <dons> yes, I've submitted a patch to ghc to do this
00:34:30 <dons> i'm not sure if its been comitted though
00:34:38 <gour> ok, thanks
00:36:25 <lispy> dons: hmm...i broke sometihng else
00:36:31 <lispy> dons: i hada flaw in my test case
00:36:38 <lispy> dons: i was using the wrong lambdabot binary
00:37:35 <dons> ok
00:38:36 <lispy> but it's odd
00:38:43 <lispy> i can run from goa, it works
00:38:52 <lispy> i can run from ./lambdabot, it works
00:38:57 <lispy> but from the web it fails
00:39:47 <lispy> oh, sudo su www-data
00:39:52 <lispy> now i get permission errors
00:40:44 <lispy> okay
00:40:46 <lispy> backup
00:40:50 <lispy> er it's back up
00:41:06 <dons> ok. good. i'm still chasing down this last goa + no output isue
00:41:16 <lispy> hmm..
00:41:16 <lispy> okay
00:41:21 <lispy> i sleep :)
00:41:25 <lispy> ?localtime lispy
00:41:26 <lambdabot> Local time for lispy is Sat Sep 16 00:41:01 2006
00:41:35 <dons> get some sleep.
00:41:37 <bourbaki> moin
00:41:41 <lispy> moin
00:41:49 <lispy> dons: but there are bugs!
00:41:55 <lispy> i can't sleep when there arebugs...
00:41:59 <bourbaki> hehe
00:42:18 <bourbaki> lispy did you tell your psychatrist about the bugs ;)?
00:42:25 <lispy> noo....
00:42:32 <lispy> she would make the bugs go away...
00:42:44 <lispy> the bugs keep me company
00:42:58 <bourbaki> :)
00:42:59 <lispy> bourbaki: but she might like this
00:43:05 <lispy> ?where lambdaweb
00:43:05 <lambdabot> I know nothing about lambdaweb.
00:43:07 <bourbaki> do you know naged lunch?
00:43:11 <Adamant> I saw a medical program with a crazy homeless woman who kepy worms in large cuts in her body.
00:43:16 <lispy> http://lambdabot.codersbase.com/
00:43:17 <lambdabot> Title: Lambdabot Web Interface
00:43:18 <Adamant> kept.
00:43:30 <lispy> Adamant: ugh...
00:43:32 <lispy> bourbaki: no
00:44:31 <bourbaki> dons are you available :)?
00:45:04 <bourbaki> why are you hacking all day and night on lispbot these days?
00:45:17 <dons> lispbot??!
00:45:21 <yacstud> rofl
00:45:24 <bourbaki> er :)
00:45:29 <bourbaki> lambdabot
00:45:46 <bourbaki> it was a combination of lispy and bot :)
00:45:47 <lambdabot> I AM NO LISP BOT!
00:45:52 <lispy> lolo
00:45:57 * lispy used to havea lisp bot
00:46:07 <dons> just taking a break after finishing my paper last week
00:46:10 <lispy> it was just a wrapper around the megahal binary though
00:46:18 <dons> and this web lambdabot seems like fun
00:46:25 <bourbaki> :)
00:46:29 <lispy> and i keep conning him into working on lambdaweb with me :)
00:46:29 <bourbaki> dons what paper?
00:46:31 <weitzman> Would it be sacrilegious for lambdabot to have a scheme interpreter plugin?
00:46:44 <lispy> weitzman: nah, it would be cool
00:46:48 <dons> ?google Rewriting Haskell Strings
00:46:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
00:46:50 <lambdabot> Title: Rewriting Haskell Strings
00:46:53 <dons> that one.
00:46:53 <bourbaki> ah
00:47:05 <bourbaki> dons did you read the esap.txt i send you?
00:47:09 <Adamant> dons, what are the plans for yi?
00:47:17 <lispy> weitzman: esp. if you did it as an exercise in the 48 hour scheme tutorial that is up (haskell tutorial to create scheme interpreter)
00:47:45 * lispy disappears
00:47:48 <Adamant> I've been thinking about emacs lately... it's powerful, but it is old.
00:48:15 <sieni> and emacs lisp sucks
00:48:29 <Adamant> well, it's not a modern Lisp, that's for sure.
00:48:32 <dons> lispy: ok, I think I fixed the goa issue
00:48:33 <sieni> and it has lots of basic dysfunctionalities
00:48:37 <dons> needs a small lambdabot patch
00:48:37 <lispy> sweet!
00:48:41 <Adamant> sieni, what don't you like?
00:48:45 <glguy> I always thought that SLIME was badass tho... (some seem to disagree)
00:48:50 <dons> (we always print a newline, that seems to help)
00:48:53 <Adamant> SLIME is awesome.
00:48:58 <lispy> dons: cool
00:49:17 <Adamant> I am going to be hacking together a SLIME interface for Mosquito Lisp.
00:49:17 <lispy> dons: pull for both projects and recompile?
00:49:35 <dons> GOA> :id x
00:49:35 <dons> x
00:49:35 <dons> GOA> :id
00:49:36 <dons> GOA> :id
00:49:44 <dons> lispy: yep. both goa and lambdabot
00:49:53 <dons> and that's all outstanding issues that i know of (?)
00:50:06 <lispy> list?
00:50:13 <dons> oh that.
00:50:37 <sieni> most state should be window-specific. now it has lots of annoying stuff, like cursor position is only partly window-specific (open a buffer in two windows and put the cursors into separate positions. switch to another buffer
00:50:56 <sieni> in one of the windows and back. now the cursor is positioned in the same place as in the other window)
00:50:57 <Adamant> @bf @elite
00:50:57 <lambdabot> Done.
00:51:19 <lispy> @. bf elite is this a bf program?
00:51:19 <lambdabot> Done.
00:51:29 <dons> heh
00:51:38 <Adamant> @bf @elite ++++++\
00:51:39 <lambdabot> Done.
00:51:41 <sieni> minibuffer should be window-specific, so that in the middle of doing stuff you could switch to another buffer and do some editing and resume what you were doing in the first buffer
00:52:08 <sieni> very fundamental things are completely wrong so it's not surprise that the whole thing is a big piece of shit
00:53:23 <Adamant> ah.
00:54:02 * weitzman sleeps
00:54:27 <lispy> dons: my goa still hangs on lambdabot "id" ""
00:54:41 <lispy> oh
00:54:48 <dons> ?
00:54:58 <lispy> my lambdabot binary iddn't update...
00:55:01 <dons> ah
00:55:34 <lispy> oh
00:55:40 <lispy> the 'reconfigure' killed me
00:55:46 <lispy> it doesn't remember my --bindir
00:55:47 <dons> ah
00:55:54 <dons> oops
00:56:22 <glguy> Did anyone ever hear if SPOJ updated it's Haskell toolkit?
00:56:32 <bourbaki> i wonder if lambdabot would perform better if you make it listen to classical music like plants and such do
00:56:38 <lispy> dons: easy enough to hardcode in the one i want
00:56:47 <dons> heh. she listens to lot in my house
00:56:53 <dons> lispy: ok.
00:57:15 <bourbaki> dons and did you perceive any performance difference :)?
00:57:23 <dons> she quite likes Bach, but also is a fan of Steve Reich -- seems to sync with her lambdas
00:57:48 <bourbaki> as long as its not Reich the third ;)
00:57:50 <dons> it think she had a calmer outlook
00:57:55 <dons> not that one.
00:58:00 <lispy> > L.fibs !! 300
00:58:00 <lambdabot>  Not in scope: `L.fibs'
00:58:01 <lispy>         * 359579325206583560961765665172189099052367214309267232255589801
00:58:07 <dons> cool
00:58:09 <lispy> sweet!
00:58:28 <bourbaki> ?
00:58:43 <lispy> dons: i think that's all the bugs
00:58:47 <glguy> lispy: > ()
00:58:52 <lispy> dons: everything else should be improvements
00:58:59 <lispy> er...
00:59:04 <lispy> well, new features
00:59:08 <dons> lispy: yeah, seems to run nicely now
00:59:40 <dons> logging is reasonable, for now
01:00:24 <lispy> night
01:00:27 <lispy> (forreals)
01:00:32 <dons> night lispy
01:00:40 <bourbaki> just out of personal interest would you think that a bot like lambdabot would gain anything form using a "brain" architecture?
01:01:00 <glguy> ?yow
01:01:00 <lambdabot> RHAPSODY in Glue!
01:01:17 <glguy> I don't think that lambdabot is going ot have to worry about having a brain ;)
01:01:18 <dons> bourbaki: i can imagine some fun AI-based plugins
01:01:27 <dons> also, taking over the world
01:02:03 <bourbaki> dons this graph stuff targets at exactly this, these memory models from cognitive psychology and brakeing it all down in data flow and such
01:02:17 <bourbaki> :) taking over the world is mice work
01:03:17 <bourbaki> and another thing i thought about is if the arrow notation thingy would gain something if it was embued with notions form semiotics
01:03:24 <glguy> How kind of speed difference is there between STUArray and DiffUArray?
01:06:31 <glguy> (I meant what kind of, but I don't see too many people jumping on the question anyway)
01:07:05 <dolio> Is it a drop-in replacement for STUArray? I could bench it with the rad sieve I wrote for mathschallenge.
01:07:34 <glguy> DiffUArray is just a normal Array drop-in
01:07:39 <glguy> I believe
01:07:54 <dolio> Ah, yeah, I guess that makes sense, since it wouldn't require the ST monad.
01:08:09 <glguy> I don't know if it's an MArray or not (checking)
01:08:47 <glguy> type DiffUArray = IOToDiffArray Data.Array.IO.Internals.IOUArray
01:09:20 <glguy> I think that IO arrays have gone our of favor when an ST array will do...
01:09:48 <dolio> So it's a wrapped IOUArray?
01:10:53 <glguy> apparently..
01:11:28 <glguy> dolio: have you made any mathschallenge progress?
01:12:24 <dolio> Nah, I've been slacking the past couple days.
01:12:37 <bourbaki> what kind of challenge?
01:12:54 <glguy> It's called mathschallenge.net - Project Euler
01:13:24 <bourbaki> whats it about?
01:13:38 <glguy> programming problems based around solving a math problem
01:13:41 <glguy> usually
01:13:54 <bourbaki> ah
01:14:18 <glguy> most of the math isn't actually too hard, but the problems usually require you to realize something about the math behind the problem to optimize your solution to run in the time limit
01:14:21 <bourbaki> do you know planetmath?
01:14:25 <glguy> nope
01:14:28 <glguy> should I?
01:14:30 <bourbaki> yes
01:14:47 <bourbaki> http://planetmath.org/
01:14:49 <lambdabot> Title: PlanetMath
01:16:56 <dolio> I should probably have done a couple instead of reading dumb comments in the "there are no longer any beginner languages as wonderful as Basic was on my commodore64," but it's hard to resit rubbernecking.
01:17:12 <dolio> Er, the slashdot story by that description, that is.
01:17:28 <glguy> yeah... that was a dumb article
01:17:39 <glguy> there are plenty of ways for kids interested in programming to get their hands into it
01:17:42 <dolio> Posted twice, no less. :)
01:17:50 <glguy> especially with the advent of the "Intarweb"
01:19:28 <dolio> Yeah. I'm pretty sure Basic isn't a fantastic first language, either, despite the fact that a lot of people like to closely associate "learning how to program" with "learning exactly what kind of steps the computer uses to execute my program."
01:20:11 <glguy> dolio: and they equate to learning to use Linux with following 12 pages of Gentoo install instructions... but what are you going to do?
01:20:24 <dolio> Heh.
01:20:27 * glguy notes that he likes Gentoo as an operating system, but doesn't care for most of its userbase
01:20:51 <dolio> Yeah, it does attract its share of nuts.
01:23:57 <glguy> There's an article on digg about the pope linking violence with Islam and Muslims demanding an appology / threatening a violent reaction
01:25:14 <bourbaki> i just heared on the radio that the turkish guy who wanted an appology admitted that he didnt read the speach of the pope and neither did he read the speach the pope referred to the one of an old byzantinian king
01:25:15 <dolio> Heh.
01:25:32 <dolio> They have a keen instinct for irony.
01:25:38 <glguy> I haven't read the whole thing yet, but you just can't script comedy like this
01:26:09 <glguy> what would compell you to admit that you didn't read what you are bitching about??
01:27:01 <glguy> If you are going to be an ignorant SOB... I can't see how announcing that would your task easier..
01:27:08 <bourbaki> no idea but thats what all these ppl do they dont listen and then brag around
01:27:17 <dolio> Yeah. Typically they'd just continue saying things that clearly indicate that they didn't read it, rather than just say it.
01:27:29 <bourbaki> not that i like the pope but the ppl should quite makeing a fuzz on religion
01:28:07 <bourbaki> i think the pope tries to polarize to get more ppl in the western world interested in the church again
01:28:55 <glguy> Well... in order to be an effective mind control organization... you actually have to have members..
01:29:01 <glguy> so I can't blame him
01:29:20 <bourbaki> true :) but he totally fails in my case :)
01:29:26 <bourbaki> im religion resistent
01:30:28 * glguy thinks to shelve the conversation... not looking to drag politics into the channel
01:31:06 <bourbaki> :)
01:31:09 <glguy> sorry for the misstep anyone :)
01:31:41 <dolio> So, this problem on Lychrel numbers says nobody's proven they exist, but we're supposed to find all of them below 10,000? :)
01:31:52 <glguy> which number?
01:32:11 <glguy> ah, I found it
01:32:11 <dolio> Nubers where you iterate adding them and their reverse until you get a palindrome.
01:32:47 <dolio> I mean, clearly, you'd never know simply by checking a bunch of iterations.
01:33:00 <dolio> Because you could always do one more.
01:33:09 <glguy> dolio: however, if it forms a loop...
01:33:24 <glguy> I don't really remember how I addressed that problem
01:33:31 <glguy> I don't really remember doing it at all actually
01:33:44 * glguy did a lot of the problems right before bed
01:33:45 <dolio> Well, they give "the first number to take 50 iterations."
01:33:51 <dolio> So you only have to check 50.
01:34:06 <glguy> ah
01:34:06 <dolio> But I assume that's an unproven property.
01:34:58 <dolio> Unless there are 0 Lychrel numbers below it.
01:35:30 <glguy> I'll tell you that the answer is not zero (c:
01:35:34 <dolio> :)
01:39:34 <dolio> > (ap (==) reverse) [1, 2, 3]
01:39:35 <lambdabot>  False
01:39:38 <dolio> > (ap (==) reverse) [1, 2, 1]
01:39:39 <lambdabot>  True
01:40:06 <dolio> @karma- monomorphism-restriction
01:40:07 <lambdabot> monomorphism-restriction's karma lowered to -1.
01:40:52 <bourbaki> whats this karma thing all about?
01:41:28 <glguy> determines what you will be in the next life
01:41:40 <glguy> ?karma glguy
01:41:41 <lambdabot> You have a karma of 0
01:41:49 <glguy> I will be the same as I am now ;)
01:41:54 <glguy> ?karma emertens
01:41:54 <lambdabot> emertens has a karma of 2
01:42:01 <bourbaki> wheres the table that shows me how much karma i need?
01:42:03 <glguy> My alternate nick, however, will not
01:42:12 <glguy> bourbaki: you just ask me, and I tell you
01:42:26 <bourbaki> ok then shoot
01:42:36 <glguy> ?karma bourbaki
01:42:36 <lambdabot> bourbaki has a karma of 0
01:42:40 <glguy> not enough
01:42:48 <bourbaki> for what?
01:42:58 <glguy> eternal happiness...
01:43:07 <glguy> it doesn't *mean* anything
01:43:23 <glguy> people make other people happy and other people boost their karma
01:43:37 <glguy> they do dumb stuff... and other people decrement it
01:43:41 <bourbaki> then why dont i have a high karma value :)?
01:43:54 <glguy> You haven't done much in channel?
01:44:05 <glguy> or been really really useful?
01:44:08 <glguy> ?karma lambdabot
01:44:08 <lambdabot> lambdabot has a karma of 26
01:44:19 <glguy> ?karma dons
01:44:19 <lambdabot> dons has a karma of 68
01:44:19 <bourbaki> no but i could and i dont thats enough to make ppl happy i suppose :)
01:44:36 <ValarQ> ?karma
01:44:37 <lambdabot> You have a karma of 1
01:45:13 <glguy> I guess it's a quantified popularity contest
01:49:46 <therp> where would I report errors in "gentle introduction to haskell"? I doubt that the original editors would take the effort to correct minor errors. maybe the hosting haskell.org?
01:50:05 <glguy> what did you find?
01:51:06 <Adamant> error: it's not frickin' gentle
01:51:25 <dolio> ?type range
01:51:26 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
01:51:44 <glguy> > range ((0,0),(2,3))
01:51:45 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
01:52:21 <therp> minor errors in the types, http://www.haskell.org/tutorial/haskell-98-tutorial.pdf Page 59, index is missing an "->" in its type. Page 61, "(Ix a) =>" instead of "(Ix a) ->" in the type of accumArray
01:52:23 <lambdabot> http://tinyurl.com/quc6j
01:52:44 <glguy> ?type accumArray
01:52:45 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
01:53:04 <therp> ?type index
01:53:05 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
01:53:16 <dolio> Ix is a typeclass, not a type.
01:53:43 <dolio> So "(Ix i) =>" specifies that i is in the class Ix.
01:53:49 <therp> dolio: did anybody say anything contrary?
01:54:13 <glguy> You statement was not clear as to what the original text was
01:54:21 <dolio> Oh, I was looking in the wrong place.
01:54:33 <dolio> You meant it has -> where it should be =>
01:54:43 <dolio> Not the reverse.
01:54:51 <therp> dolio: right, was my statement ambigious?
01:55:21 <glguy> Kind of... it wasn't clear if you were describing the fix or the error
01:55:26 <glguy> but yeah, you're right
01:55:33 <therp> x instead of y isn't ambigious, isn't it? meaning every occurance of y should be replaced by x (just to improve my english)
01:55:55 <therp> glguy: ah ok :)
02:00:03 <glguy> > let ap' as bs = do { a <- as; b <- bs; return (a b) } in (ap [(+1)] [3], ap (==) reverse [1,2,3,2,1])
02:00:04 <lambdabot>  ([4],True)
02:00:53 <glguy> lol...
02:00:59 <glguy> > let ap' as bs = do { a <- as; b <- bs; return (a b) } in (ap' [(+1)] [3], ap' (==) reverse [1,2,3,2,1])
02:01:01 <lambdabot>  ([4],True)
02:01:12 <glguy> not much sense in writing the long version of a function if you aren't going to use it
02:02:38 <glguy> ?pl \as bs -> as >>= \a -> bs >>= \b -> return (a b)
02:02:38 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
02:11:03 <TakeOut{u}>  all languages must have some relationship to ASM ?
02:11:32 <ValarQ> TakeOut{u}: why?
02:11:42 <TakeOut{u}> i dunno
02:11:50 <TakeOut{u}> i was in java and someone said to say that in haskell
02:12:03 <TakeOut{u}> i was interested in what the answer to that would be
02:12:23 <glguy> not a very well-formed question :-p
02:12:28 <TakeOut{u}> [19:04] <dibblego> pbelau, /j #haskell then say all languages must have some relationship to ASM
02:12:35 <TakeOut{u}> i was wondering what the answer was :P
02:12:37 <ValarQ> the short answer is that it's wrong
02:12:43 <dibblego> it's a troll, don't take the bait
02:12:55 <dibblego> TakeOut{u}, we'll discuss it in a minute
02:13:00 <TakeOut{u}> ahh ok :)
02:13:01 <TakeOut{u}> thankyou
02:14:07 <ValarQ> TakeOut{u}: welcome to the channel btw :)
02:14:15 <TakeOut{u}> thankyou ValarQ
02:14:21 <TakeOut{u}> i can't actually program in Haskell though :P
02:14:22 <dibblego> TakeOut{u}, you will learn lots in this channel, much more than ##java
02:14:39 <TakeOut{u}> i haven't really being programmind for long
02:14:47 <TakeOut{u}> *ming
02:15:19 <dibblego> best to start off on the right foot :)
02:15:23 <ValarQ> if you're interested there shouldn't be a problem
02:17:52 <TakeOut{u}> i was going to ask you a question in java dibblego, but i saw you with the troll, and decided to be a bit quiet
02:18:24 <dibblego> he is just a little misguided
02:19:20 <glguy> java is a language written for average programmers, nothing wrong with that (creators words not mine)
02:19:58 <dibblego> I think that's a little optimistic
02:21:36 <ValarQ> theres nothing wrong to go with average? :)
02:22:47 <TakeOut{u}> bbiab
02:23:26 <basvandijk> Does anybody know what the LISP function for concat is?
02:24:50 <dcoutts__> basvandijk: heh, wrong channel
02:25:17 <dolio> > concat [[1,2],[3],[4,5]]
02:25:18 <lambdabot>  [1,2,3,4,5]
02:25:21 <dolio> Something similar, I imagine.
02:25:35 <glguy> concatentate
02:25:42 <glguy> concatenate
02:26:00 <basvandijk> dcoutts__: :-) I'm customizing haskell-mode file and trying to set haskell-ghci-program-args
02:26:15 <dcoutts__> basvandijk: ah, ok, you're forgiven ;-)
02:26:20 <basvandijk> :-)
02:28:01 <basvandijk> I wish Lisp had something like Hoogle...
02:28:23 <glguy> (concatenate 'string "test" "this")
02:29:13 <basvandijk> glguy: Emacs complains: (void-function concatenate)
02:29:37 <glguy> I don't know anything about elisp
02:29:45 <basvandijk> me to
02:30:20 <glguy> neither?
02:31:24 <glguy> (append '(1 3) '(4 7))
02:31:29 <glguy> (1 3 4 7)
02:32:12 <basvandijk> yes append works, but only for two lists
02:33:10 <glguy> > foldr (\x y -> x ++ y) [] [[1],[2,3],[4]]
02:33:12 <lambdabot>  [1,2,3,4]
02:33:25 <glguy> Does LISP have an equivalent of fold?
02:33:36 <dolio> reduce
02:33:46 <glguy> there you go... reduce yoru list of lists with append
02:34:18 <dons> > foldr (++) [] [[1],[2,3],[4]]
02:34:19 <lambdabot>  [1,2,3,4]
02:34:39 <basvandijk> Mmm right... but my emacs doesn't know reduce :-(
02:34:51 <glguy> That was an unfair shot dons, I'm not playing haskell golf right now
02:35:02 <glguy> dons, and furthermore:
02:35:10 <glguy> > join [[1],[2,3],[4]]
02:35:11 <lambdabot>  [1,2,3,4]
02:35:22 <dons> :)
02:35:29 <glguy> > join[[1],[2,3],[4]]
02:35:30 <lambdabot>  [1,2,3,4]
02:35:31 <glguy> beat you to it!
02:35:47 <glguy> ?let j = join
02:35:48 <lambdabot> <local>:14:4:     Ambiguous type variable `m' in the constraint:       `Monad...
02:35:51 <dons> heh
02:35:53 <glguy> :(
02:35:55 <glguy> ?let j = concat
02:35:57 <lambdabot> Defined.
02:36:02 <glguy> > L.j[[1],[2,3],[4]]
02:36:03 <dons> go glguy , go!
02:36:03 <lambdabot>  [1,2,3,4]
02:36:07 <Svrog> has anyone used JoinHs?
02:36:11 <glguy> !!
02:36:14 <glguy> > [1..4]
02:36:15 <lambdabot>  [1,2,3,4]
02:36:27 <glguy> ?undefine j
02:36:28 <lambdabot> Undefined.
02:36:34 <glguy> (c:
02:39:23 <glguy> (reduce #'append '((1 2)(3)(4 5))) -- for reference
02:39:47 <glguy> the whole variable namespace separate from function namespace thing is such an eyesore to me
02:42:11 <glguy> dons: I'm building 6.5 from source right now... is there a way to test if ghci works in it without make install?
02:42:29 <dons> yep, compiler/stage2/ghc-inplace --interactive
02:43:14 <glguy> I'm guessing that stage2/ will be created when the build process gets that far :)
02:43:22 <dons> its not a true functional language if functions aren't just as first class as variables ..
02:43:23 <glguy> oh, it just did
02:43:28 <dons> yep
02:43:35 <dons> wait till it finishes, then see what happens
02:43:44 <glguy> buut I'm impatient...
02:43:58 <glguy> I don't think anyone ever accused LISP of being functional ;)
02:44:12 <dcoutts__> @hoogle assert
02:44:12 <lambdabot> Control.Exception.assert :: Bool -> a -> a
02:44:13 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
02:44:13 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
02:44:25 * dcoutts__ hacks on zlib bindings
02:44:27 <glguy> "a little bit of everything" just didn't sound right either
02:46:12 <glguy> so stage1 isn't built for interactive use (in case anyone wondered)
02:46:46 <dons> that's right.
02:47:34 <therp> just for reference, common lisp is the only a variant of lisp that separates function/variable namespace. functions are first class but are separated by syntax. scheme (also variant of lisp) is different, variable/functional in the same namespace.
02:48:15 <glguy> yeah, I knew that scheme didn't make a distinction
02:49:42 <glguy> "Oh Baxter, you are my little gentleman"
02:50:23 <ozone> glguy++
02:50:56 * glguy is watching Anchorman if anyone else didn't get that
02:51:29 <Adamant> the Lisps are functional if you want them to be.
02:51:41 <Adamant> and they're imperative if you don't want them to be.
02:51:50 <glguy> kind of like C ;)
02:51:57 <Adamant> lol, come on.
02:52:13 <Adamant> not a valid comparison.
02:52:36 <glguy> from what I've seen of CL, and my view might be somewhat limited, a lot of things depend of global variables
02:52:50 <Adamant> don't have to. but they can.
02:52:51 <glguy> and the dynamic binding of them
02:52:59 <glguy> even for library functions
02:53:00 <Baughn> Environmental variables, more like. Stdin, stdout, that sort of thing.
02:53:08 <Adamant> CL has lexical binding as well.
02:53:13 <glguy> I'm aware
02:53:16 <Adamant> Scheme is lexical by default.
02:53:17 <glguy> but not for globals
02:53:22 <glguy> is all that I meant
02:53:25 <Adamant> ah.
02:53:30 <glguy> I wasn't speaking generally
02:53:38 <Adamant> ah, ok, I misunderstood you.
02:53:45 <glguy> lisppaste2 is having none of this converstaion
02:53:49 <glguy> conversation*
02:54:19 <glguy> "Milk was a bad choice"
02:54:34 <Adamant> anyway. Both the Lisps and Haskell have to deal with the fact that you can't do everything natural in a conventional functional style.
02:54:43 <Adamant> naturally.
02:55:03 <dibblego> I believe that to not be true
02:55:04 <Adamant> Haskell uses monads to subvert these limitations
02:55:29 <Adamant> well, iteration and recursion are functional equivalent
02:55:41 <Adamant> functionally equivalent
02:55:45 <glguy> Monads are defined within the functional language of Haskell, they are not some special case that allows Haskell to do these things
02:55:48 <dibblego> some say files are "real world" state and yet we have revision control systems that contain immutable filesystems
02:55:57 <dibblego> I believe an immutable database is easy to write
02:56:18 <dibblego> that pretty much leaves networking, which is a more difficult problem
02:56:53 <Adamant> (I should be clear my knowledge of Haskell is limited right now, I know more about the Lisps)
02:56:56 <dibblego> a file is just some addressable unique identifier to some sequence of bytes
02:57:06 <dibblego> that is easy to write as an immutable structure
02:57:37 <Adamant> well, you can always keep something immutable, if you have space to hold the old thing + replacement new thing
02:57:48 <Adamant> until the old thing gets gc'ed
02:57:49 <dibblego> the space is the same
02:58:02 <Adamant> ?
02:58:17 <Adamant> how so?
02:58:21 <dibblego> assuming you don't want to keep the pre-delta application
02:58:22 <Svrog> what about the arguments such as the one presented here: http://lambda-the-ultimate.org/classic/message9361.html
02:58:24 <lambdabot> Title: LtU Classic Archives, http://tinyurl.com/ezcl6
02:59:00 <Svrog> "Here is a simple example to show the difference between true state and threaded state. Consider a system consisting of modules A, B, C, D, and E, all written in a purely functional way. Module A calls B, which calls C, which calls D, which calls E."
02:59:23 <Svrog> "Now let's say I want to instrument E, to count how many times it is performing some operation, and I want to observe this from A. If I want to program this in a purely functional way (e.g., in the pure subset of Haskell), then I am obliged to change the interfaces of all the modules A, B, C, D, and E (*). If I have true state, then I can get by with changes in just A and E. In other words, instead of changing everything on the path, I can get by
03:00:40 <dibblego> I think it's wrong :)
03:01:11 <Svrog> well i suspect that it might be - but i'm also open to the possibility it isn't wrong
03:01:12 <dibblego> nuff said? :)
03:01:25 <dibblego> sorry, I just have sore fingers
03:01:35 <dibblego> and I'm missing a couple too
03:02:58 <glguy> He says that adding instrumentation into a module would force you to add all sorts of extra plumbing to your other modules to get that data back
03:03:08 <Svrog> yes
03:03:10 <glguy> and that this is bad because the instrumentation has nothing to do with the point of the code
03:03:13 <glguy> but
03:03:30 <glguy> by that logic, since the instrumentation doesn't belong in the code anyway, you shouldn't be adding it to "module E" in the first place
03:03:42 <glguy> but should be either doing it with some kind of profiling tool
03:03:50 <glguy> or something to that effect
03:04:43 <yip> maybe something like TH
03:05:29 <Svrog> not necessarily - it would indicate the code base isn't flexible - instrumentation was just one example - it could be something else (i can't think of anything off the top of my head - i only remembered this because i came across the post earlier today)
03:06:42 <Svrog> i'm not convinced the problem cannot be solved in a purely functional way but i'm also not convinced it can be easily solved in haskell
03:06:50 <dibblego> time is mutable - an axiom of software - given time as the frame of reference, the world is immutable, this is why FP languages model reality well
03:07:49 <dibblego> you might introduce threads or something to try to make this appear wrong, but it doesn't - just makes it harder - two threads are just two superficial "times" that try to make "time is mutable" appear false
03:09:01 <glguy> further more, with that example, if module A knows that it is calling module E and expect certain behaviors from it, then you don't have modularity at all anyway..
03:09:18 <glguy> A is already bound through B-D to E
03:09:38 <Svrog> that's true
03:09:55 <glguy> so cut out the middle men, and the change becomes a lot easier to make
03:10:18 <Svrog> how? you'd still have the same problem?
03:10:44 <glguy> now you have two modules A and E and you've decided to bind them together tightly, so just change the code to do what you want
03:10:53 <glguy> because what you want isn't modularity
03:11:15 <Svrog> but all you've really done is merged the modules
03:11:36 <glguy> I'm saying that that is what the person describing the problem has already done
03:11:37 <Svrog> you still have the same code
03:11:45 <Svrog> and you still have to make the same modifications
03:12:28 <glguy> so?
03:12:54 <glguy> you've changed the functionality of the different parts of the code
03:13:04 <glguy> of course you are going ot have to change code
03:13:22 <glguy> not only the functionality, but the purpose
03:14:03 <Svrog> yeah but the problem is that you wouldn't have had to change as much if you had true state
03:14:24 <glguy> that doesn't mean that the outcome would be better, just that it would be easier to get that bad outcome
03:14:34 <glguy> if you write a module and say "this module sorts lists"
03:14:42 <Svrog> yeah that's a good point
03:14:56 <glguy> and then come back later and say "this module actually sorts lists and connects to IRC"
03:15:12 <glguy> code that uses those functions will have ot change
03:15:45 <glguy> since Haskell's type system tells you what a fuction does
03:15:57 <glguy> in addition to what value it returns
03:16:58 <glguy> true state is really dangerous, and I'm learning all about this at work
03:17:13 <glguy> someone writes a function called LoadUser on the UserObject class
03:17:15 <Svrog> no argument there
03:17:34 <glguy> little do I know that that function actually logs the user in as a the current user and updates their timestamps
03:17:46 <dibblego> Java?
03:17:50 <glguy> C#
03:18:01 <dibblego> same thing :)
03:18:03 <glguy> and it does that in addtion to rehydrating the object I wanted
03:19:12 <glguy> but since there is true state, I can't treat the code modularly
03:19:24 <glguy> I have to dig through it and understand everything that it does
03:19:27 <glguy> so that it doesn't break something else
03:19:34 <dibblego> OO prevebts reuse
03:19:52 <glguy> so there you go... true state make modularity impossible
03:19:55 <glguy> :-p
03:20:20 <dibblego> I am putting together a formal proof, rather than just cases such as yours
03:20:22 <glguy> dons: ghc takes too long to compile, can you resolve that?
03:20:38 <glguy> dibblego: good deal :)
03:20:55 <Svrog> a formal proof of what?
03:21:12 <Svrog> oo preventing reuse?
03:21:14 <dibblego> that OO and software are mutually exclusive
03:21:15 <glguy> OO preventing reuse?
03:21:17 <Svrog> ah
03:21:19 <dibblego> yes that is one aspect
03:21:25 <Svrog> http://www.sics.se/~joe/bluetail/vol1/v1_oo.html
03:21:27 <lambdabot> Title: Test Page, http://tinyurl.com/gl3m9
03:22:30 <glguy> arg, it's soo late
03:22:35 <glguy> goodnight everyone
03:22:38 <Svrog> night
03:22:40 <dibblego> seeya
03:23:12 <dibblego> I hope to be a bit more formal than that :)
03:23:24 <dibblego> it is 15 pages so far, and I expect it to be a few hundred
03:23:29 <Svrog> hehe yeah probably - still i thought you might find it interesting
03:23:54 <dibblego> :)
03:24:18 <dons> glguy: yeah, its faster if you build from pregenerated .hc src
03:24:27 <dons> so that's how the port builds, for example
03:24:34 <dons> then you invoke only gcc for a large part of the build
03:25:26 <AstralStorm> Hey guys. How does one make a ffi declaration of anonymous structs?
03:26:39 <AstralStorm> I have to use the struct later on.
03:26:41 <dcoutts__> AstralStorm: assuming you're passing via reference, you use a Ptr Thing
03:26:54 <Svrog> so has anyone played with join calculus much? or tried JoinHS - haskell with join calculus?
03:26:57 <AstralStorm> Exactly, but I'd like to mangle it later :>
03:27:13 <dcoutts__> AstralStorm: and then you make your Thing an instance of the Storable class so you can convert it to/from a Haskell value
03:27:14 <AstralStorm> That's why I'd love to have a full implementation.
03:27:19 <Svrog> or rather haskell with join patterns
03:27:45 <AstralStorm> Well, how does one combine Storable with Ptr then?
03:28:17 <dcoutts__> AstralStorm: there's basically two choices, keep it allocated as the foreign struct and just peek/poke individual bits, or you can peek/poke the whole structure - copying to a haskell value
03:28:57 <dcoutts__> ie you either go by reference or by value
03:28:59 <AstralStorm> I can do that "individual bits"
03:29:14 <AstralStorm> There's not too many of them.
03:29:25 <dcoutts__> the by value is often preferable as then you don't have to worry about allocation lifetimes
03:30:02 <dcoutts__> you just copy a Haskell value into a temporarily allocated C struct, and call the foreign stuff
03:30:05 <AstralStorm> I have to do by reference, because the struct is allocated somewhere in the kernel memory :P
03:30:14 <dcoutts__> ah ok
03:30:34 <dcoutts__> then you're stuffed since you can't get a reference to it anyway right?
03:30:41 <dcoutts__> it's not in your address space?
03:31:31 <AstralStorm> No no, it is in the userspace part of kernel space.
03:31:53 <AstralStorm> The structure is copied on some operations.
03:34:03 <dcoutts__> AstralStorm: well if you can use it by copying it each time then look at the Storable class
03:34:30 <dcoutts__> if you have to keep it at the same address then you'll want just a Ptr or ForeignPtr
03:34:45 <dcoutts__> and then peek/poke just individual fields perhaps
03:34:56 <dcoutts__> though you can still use Storable to copy info out of the struct
03:35:50 <AstralStorm> Hmm... interesting then. That'd be a ForeignPtr, but how does one dereference it and poke/peek then?
03:36:36 <dcoutts__> withForeignPtr allows you to get at the Ptr inside the ForeignPTr
03:36:51 <dcoutts__> the point of a ForeignPtr is to be able to attach a finaliser to a foreign object
03:37:00 <dcoutts__> eg if you need to do something to deallocate it
03:37:09 <AstralStorm> I know, and it's good.
03:37:21 <AstralStorm> Because the struct has both an allocator and a finaliser.
03:37:58 <AstralStorm> Though I'd have to modify ForeignPtr a bit to support initialisers.
03:38:46 <AstralStorm> But that'll be better done in the high-level wrapper :>
03:39:03 <AstralStorm> So a ForeignPtr will suffice.
03:42:17 <dcoutts__> AstralStorm: no need to modify ForeignPtr for an initialiser, you just initialise when you allocate
03:42:32 <dcoutts__> and when you wrap the ptr in the FroeignPtr you attach the finaliser
03:42:41 <dcoutts__> @hoogle newForeignPtr
03:42:42 <lambdabot> Foreign.Concurrent.newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
03:42:42 <lambdabot> Foreign.ForeignPtr.newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
03:42:42 <lambdabot> Foreign.ForeignPtr.newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
03:42:48 <AstralStorm> What I thought.
03:43:00 <dcoutts__> see, you can attach the finaliser at the point you wrap the Ptr
03:43:01 <AstralStorm> I just need the finaliser.
03:43:35 <AstralStorm> Anyway, all pointers of this kind must have a finaliser, so...
03:43:58 <dcoutts__> AstralStorm: I'll show you my zlib bindings when they're done
03:44:09 <dcoutts__> they use a ForeignPtr for the zlib stream state
03:44:37 <AstralStorm> Oh, I'm currently writing a libcap bindings.
03:45:46 <dcoutts__> nice
03:49:04 <AstralStorm> Blah, their cap_free takes a void*, which can be a cap_to_text string or a cap_t structure :/
03:49:20 <AstralStorm> And it returns an int, so can't use that as a finaliser :/
03:49:47 <dcoutts__> what is the int return?
03:50:02 <dcoutts__> you can make your own C wrapper that discards the return value
03:50:09 <dcoutts__> assuming it's safe to do that
03:50:36 <AstralStorm> Error marker :P
03:50:47 <AstralStorm> Ignoring that will kill me.
03:51:00 <AstralStorm> I'll have to act on the value.
03:52:16 <dcoutts__> it's possible for freeing a cap* to fail?
03:52:17 <AstralStorm> So I'll wrap it in Haskell function returning a proper FunPtr.
03:52:20 <AstralStorm> Yes.
03:52:29 <AstralStorm> EINVAL or ENOMEM
03:52:43 <AstralStorm> EINVAL is mostly impossible, but ENOMEM is a possibility.
03:52:45 <dcoutts__> you can run out of memory when trying to free something!?
03:52:48 <lennart> but won't thap happen only if you give a bad argument to free?
03:52:52 <AstralStorm> It's weird.
03:53:06 <AstralStorm> Shouldn't happen, but...
03:53:17 <AstralStorm> That's the POSIX definition.
03:53:29 <dcoutts__> how are you supposed to deal with it anyway?
03:53:42 <lennart> yeah, but I bet those error code only occur if you misuse free
03:53:53 <AstralStorm> I hope so, then I could ignore it.
03:54:11 <AstralStorm> Still, I have to cast the FunPtr through a thin wrapper so that it fits as a finaliser.
03:54:51 <dcoutts__> you can cheat
03:54:59 <dcoutts__> just declare it to return void
03:55:07 <dcoutts__> the C calling convention allows that I think
03:55:15 <AstralStorm> -> IO () you mean? :>
03:55:16 <lennart> it does
03:55:51 <lennart> but i'd pick up the error code and abort if it's non-0.  just in case
03:55:56 <dcoutts__> I've seen libs tat claim to remain ABI compatible but change a prototype from returning void to returning int
03:56:36 <sieni> how can free() return a value? I thought it was void free(void *);
03:56:57 <dcoutts__> ie the old progs would be discarding the int with no bad consequence
03:57:21 <lennart> yes, switching to a void return value is harmless
03:58:01 <lennart> what i mean is, if a function returns something, changing the proptotype to void return is harmless
03:58:38 <lennart> return values are always returned in such a way that you don't need to do anything to them if you don't want to
03:58:49 <lennart> typically in a register
03:59:34 <AstralStorm> sieni: it's cap_free
04:01:01 <AstralStorm> lennart: how would I wrap that? I need a FunPtr returning IO ()
04:01:16 <AstralStorm> And I get a FunPtr with CInt return.
04:01:47 <lennart> so write a small wrapper that aborts if the CInt is non-0 and then returns ()
04:02:08 <AstralStorm> Mhm, thanks, just as I thought :>
04:03:17 <dcoutts__> or just ignore it
04:03:33 <dcoutts__> say in the FFI decl that it returns IO ()
04:04:04 <dcoutts__> I do that for zlib's inflateEnd
04:04:34 <dcoutts__> foreign import ccall unsafe "zlib.h &inflateEnd"
04:04:34 <dcoutts__>   c_inflateEnd :: FinalizerPtr ZStream
04:04:48 <AstralStorm> Mhm, "unsafe" means something special?
04:04:53 <dcoutts__> and ignore the fact the it really returns CInt
04:05:08 <dcoutts__> it does, but it's not related to the current question
04:05:12 <AstralStorm> Ah.
04:31:02 <AstralStorm> Hmm, I'll use one trick of hsffig - __quote__
04:32:33 <AstralStorm> Othewise I can't get accurate sizeof and alignment of structs.
04:41:44 <dcoutts__> AstralStorm: you can use a .hsc file
04:42:22 <dcoutts__> sizeOf _ = #{const sizeof(cap_t)}
04:42:41 <dcoutts__> alignmentOf _ = #{const __alignof(cap_t)}
04:49:03 <norpan> dcoutts__: Storable instances for tuples would be great
04:49:27 <dcoutts__> giving you a linear layout?
04:50:04 <norpan> giving you the layout that the c compiler would give for the corresponding struct
04:50:16 <dcoutts__> I suppose you could work out the size and alignment from those of the components
04:50:23 <dcoutts__> norpan: write it :-)
04:50:32 <dcoutts__> it's probably not that hard
04:50:32 <norpan> i've been thinking about it
04:50:58 <dcoutts__> if it works and you think it's useful then post the code somewhere
04:51:16 <norpan> i was hoping somebody else would write it :)
04:51:20 <dcoutts__> heh
04:53:48 <norpan> and deriving Storable for non-recursive data types
04:54:00 <bartw> so, where do i start reading to learn haskell ?
04:54:11 <norpan> @where yaht
04:54:11 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
04:54:35 <norpan> bartw: that one is one suggestion
04:54:50 <AstralStorm> Ok guys, anyone care to check out if I'm on the right track?
04:55:31 <bartw> thanks
04:55:44 <ndm> anyone know where ICFP 2007 is going to be?
04:55:45 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:55:47 <AstralStorm> http://wklej.org/id/c710234c2f
04:56:20 <ndm> @tell dons lambdabot is giving me messages multiple times
04:56:20 <lambdabot> Consider it noted.
04:56:26 <bartw> are ther epeople going to popl besides icfp ?
04:57:09 <dcoutts__> bartw: some will certainy go to both
04:57:42 <bartw> i'm looking if it might be intresting for me to go
04:58:13 <dcoutts__> AstralStorm: you're using hsffig?
04:58:27 <AstralStorm> dcoutts: no, I can't get at cap_t definition :P
04:58:45 <dcoutts__> AstralStorm: I reccoment hsc2hs for this probably
04:58:49 <AstralStorm> I'd have to do major bit-banging there then. I'll just create the substructs :>
04:59:00 <dcoutts__> as a bonus cabal knows about .hsc files
04:59:15 <AstralStorm> dcoutts: See that link: http://wklej.org/id/c710234c2f
04:59:18 <AstralStorm> :>
04:59:32 <dcoutts__> I was looking there already :-)
04:59:48 <yip> why are the ghc libraries so huge?
04:59:55 <AstralStorm> I don't like the "quote" thingy, but still...
04:59:58 <dcoutts__> which is why I was wondering what ffi preprocessor you were using
04:59:59 <bartw> dcoutts__: just can't figure how to signup for those conferences :)
05:00:19 <AstralStorm> dcoutts: hsc2hs :>
05:00:22 <AstralStorm> And it works.
05:00:23 <dcoutts__> bartw: sorry, can't help there. I'm not going this year
05:00:27 <norpan> yip: because they contain a lot of goodies? :)
05:00:36 <dcoutts__> AstralStorm: oh, ok, not standard syntax, that's all
05:00:37 <AstralStorm> That __quote__ hack is also used by hsffig
05:00:45 <dcoutts__> you don't need it i think
05:01:05 <dcoutts__> AstralStorm: just #import <pcap.h> or whatever
05:01:19 <yip> noclouds: they are hundreds of megabytes! :o
05:01:26 <AstralStorm> dcoutts: it's libcap, not libpcap
05:01:40 <dcoutts__> ok, #import <sys/capability.h>
05:01:44 <AstralStorm> And those structs are anonymous, I can only get the pointers.
05:02:14 <dcoutts__> AstralStorm: you mean you can't get the size?
05:03:18 <AstralStorm> dcoutts: not only that - to poke into it I'd have to know the alignment probably.
05:03:27 <AstralStorm> I think I still do - how to declare it properly?
05:03:39 <dcoutts__> indeed, so how are you expected to do it in C ?
05:03:57 <AstralStorm> In C you just resolve the pointer you're given.
05:03:57 <dcoutts__> if you don't have the definition of the struct?
05:04:12 <dcoutts__> sure, but is it opaque?
05:04:13 <AstralStorm> Yes, you don't, you get a typedefed pointer.
05:04:17 <AstralStorm> Somewhat.
05:04:29 <AstralStorm> I'd like to deopaquise it.
05:04:29 <dcoutts__> are you expected to access the content at all?
05:04:32 <AstralStorm> No :P
05:04:39 <dcoutts__> then there's no problem
05:04:43 <dcoutts__> you don't need the size
05:04:43 <AstralStorm> Though it's useful :P
05:04:46 <dcoutts__> or alignment
05:04:52 <AstralStorm> Or any peek/poke :P
05:04:57 <dcoutts__> right
05:04:59 <AstralStorm> Just a ForeignPtr
05:05:02 <dcoutts__> yep
05:05:04 <AstralStorm> That's what is below.
05:05:46 <AstralStorm> The problem is I have to give the Ptr some type :/
05:05:50 <AstralStorm> How to bypass it?
05:06:09 <AstralStorm> Because I have no definition of _cap_struct too.
05:06:17 <AstralStorm> (AKA opaque pointer)
05:06:23 <bartw> norpan: how can a tutorial be 192 pages ? :) i'm lookinf dor somethign a bit more 'shorter' i guess
05:06:40 <AstralStorm> bartw: Well, YAHT is a book
05:06:41 <dibblego> bartw, Haskell for C Programmers
05:06:49 <dcoutts__> AstralStorm: the usual trick is: newtype Capability = Capability (ForeignPtr Capability)
05:07:02 <norpan> bartw: well, don't read all of it then
05:07:06 <norpan> then it'll be shorter
05:07:06 <AstralStorm> Isn't that circular?
05:07:10 <dcoutts__> nope
05:07:23 <dcoutts__> well, perhaps, but in an ok way :-)
05:07:36 <dibblego> norpan, it will be the same size - he needs to cut pages out to make it shorter :)
05:07:49 <AstralStorm> And I have to give it a finaliser. I hope it'll work.
05:07:53 <bartw> dibblego : thanks
05:08:21 <dcoutts__> AstralStorm: that's the wrong syntax btw "data cap_t = ForeignPtr cap_free (Ptr cap_struct)"
05:08:34 <norpan> bartw: just print out the first six chapters then
05:08:39 <AstralStorm> Huh? By the cookbook still :P
05:08:55 <dcoutts__> AstralStorm: data types need capital letters and you specify the finaliser when you make a new ForignPtr, not in the type decl
05:09:46 <norpan> bartw: the yaht points to some other tutorials too
05:09:48 <AstralStorm> Hmm, I'd like it to be added to every instance of the type by default. A do statement?
05:10:19 <norpan> use a constructor function
05:10:40 <bartw> norpan : yaht is good too, i was just looking for something i can grok in an afternoon
05:10:42 <AstralStorm> Mhm, called cap_t...
05:10:52 <dcoutts__> AstralStorm: newCap <- newForeignPtr  cap_free_ptr =<< cap_init
05:10:55 <AstralStorm> bartw: you can't grok haskell in one afternoon :>
05:11:03 <AstralStorm> dcoutts: hehe, thanks.
05:11:07 <dcoutts__> you specify the finaliser to newForeignPtr
05:11:07 <bartw> a
05:11:17 <AstralStorm> I'll call it cap_t instead
05:11:23 <dcoutts__> AstralStorm: and you only need to do it once
05:11:24 <yip> dcoutts__: hey, how's it going? any news?
05:11:32 <dcoutts__> yip: not yet
05:11:51 <yip> ok, cool beans
05:14:17 <Sal> #join
05:15:21 <AstralStorm> dcoutts: something like: cap_t <- newForeignPtr Cap_t =<< cap_free
05:15:30 <AstralStorm> Right?
05:16:06 <AstralStorm> Ah, wrong, blah.
05:16:08 <AstralStorm> :P
05:24:25 <dcoutts__> AstralStorm: look at the types
05:24:44 <dcoutts__> @type Foreign.ForeignPtr.newForeignPtr
05:24:45 <lambdabot> forall a. GHC.ForeignPtr.FinalizerPtr a -> GHC.Ptr.Ptr a -> IO (GHC.ForeignPtr.ForeignPtr a)
05:25:25 <dcoutts__> it needs the FinalizerPtr as it's first arg and the raw ptr as it's second
05:25:54 <dcoutts__> you alloc the raw pointer by calling the C function cap_init()
05:25:58 <dcoutts__> eg:
05:27:17 <dcoutts__> cap_t <- cap_init
05:27:17 <dcoutts__> capability <- newForeignPtr cap_free cap_t
05:27:18 <dcoutts__> return (Capability capability)
05:27:33 <dcoutts__> so cap_t there is just a Ptr, capability is a ForeignPtr and the final result wraps that in the Capability newtype constructor
05:28:16 <dcoutts__> assuming you're using: newtype Capability = Capability (ForeignPtr Capability)
05:30:29 <AstralStorm> I just don't want that init :>
05:30:43 <AstralStorm> the pointer is initialised by many more functions than cap_init.
05:30:46 <AstralStorm> E.g. cap_get_proc
05:31:20 <AstralStorm> So I'll make the autofinish_cap_t function which will add the finaliser.
05:31:55 <AstralStorm> E.g. the call will be: mycaps = autofinish_cap_t cap_get_proc
05:32:36 <AstralStorm> Of course I'll provide some nicer wrappers too.
05:36:51 <AstralStorm> Hmm, now, I have to handle a function returning char*, but allocating it internally.
05:36:59 <AstralStorm> And add a nice finaliser there too.
05:37:02 <xerox> ?yarr
05:37:02 <lambdabot> This is the END for you, you gutter-crawling cur!
05:41:24 <Sal> ?yarr
05:41:25 <lambdabot> Get out o' me way, yeh landlubber
05:43:37 <dcoutts__> AstralStorm: you can still call other functions with that capabaility after it's been wrapped in the ForeignPtr
05:43:42 <dcoutts__> oh, I see yes if there are other functions that return a cap_t then you need to wrap them too
05:47:14 <AstralStorm> dcoutts: yes I know :>
05:47:42 <AstralStorm> I'll provide a high-level wrapper. Right now doing low-level one.
05:49:20 <dcoutts__> right'o
05:49:25 <Rasp> i cant get my ghci too work properly on windows
05:50:24 <Rasp> when i load in the modules where i have written my commandos I cant use my commandos "variable not in scope"
05:50:39 <Rasp> i guess its because somhove i end up in *Main>
05:51:15 <ndm> Rasp: how did you load the files, and what was the contents of the files?
05:51:19 <Rasp> And I have written a class Pattern.hs that it says that it has loaded
05:51:29 <ndm> can you @paste your Pattern.hs ?
05:51:31 <ndm> @paste
05:51:31 <lambdabot> http://paste.lisp.org/new/haskell
05:52:01 <ndm> if you having problems with this, WinHugs might be an easier route in - its much more user friendly
05:53:13 <Rasp> ok, but it worked fine for me in school at linux, i write :load c:\haskell\Pattern.hs c:\haskell\ utilities.hs
05:53:34 <Rasp> and it says ok, loaded modules but i cant use any of the command i have written
05:53:49 <dcoutts__> Rasp: try :browse Main
05:54:03 <dcoutts__> to see what values/functions are defined in the module
05:54:33 <Rasp> my code is pritty much empty right now, the only command i have written is hello = "hej" in a sceleton that i got from school so i know it should work
05:55:42 <ndm> try introducing a deliberate error into your code
05:55:49 <ndm> to check your code is really really really being loaded
05:55:58 <ndm> i.e. put a ( at the end of the file
05:56:10 <lisppaste2> Rasp pasted "Problem" at http://paste.lisp.org/display/26157
05:56:30 <dcoutts__> (or if your module isn't called Main then use whatever the module name is)
05:56:31 <Rasp> there is my code
05:56:37 <dcoutts__> Rasp: so what happens when you type hello at the ghci command prompt
05:56:41 <Rasp> but its pritty much empty
05:56:45 <dcoutts__> that looks fine
05:56:54 <ndm> try in WinHugs, it'll be much easier :)
05:57:09 <ndm> try that, and it should just work, then you can at least do your work
05:57:12 <dcoutts__> Rasp:  so when you run ghci.exe Pattern.hs, what does ghci say?
05:57:12 <Rasp> WinHugs, where can i find it?
05:57:17 <ndm> @where hugs
05:57:17 <lambdabot> http://haskell.org/hugs
05:57:28 <ndm> http://cvs.haskell.org/Hugs/downloads/2006-05/WinHugs-May2006.exe
05:57:30 <lambdabot> http://tinyurl.com/z75kl
05:57:59 <Sal> @where pugs
05:57:59 <lambdabot> http://www.pugscode.org/
05:58:16 <ndm> you'll also find its got auto-reload, which is absolutely fanatstic for something like this
05:58:52 * dcoutts__ skulks back to his cumudgenly unix cave
05:59:01 * xerox pats dcoutts
05:59:27 <dcoutts__> ta :-)
05:59:50 <ndm> dcoutts__, as soon as you figure out Gtk2Hs + GHC + Windows, you can have this goodness too :)
05:59:52 <AstralStorm> dcoutts: How can I force one parameter to always be a NULL? :>
06:00:14 <Rasp> when i write ghci.exe C:\haskell\inlup1\Pattern.hs it says that it cant find Utilites so i write a long parameterlist end then it ends up in Main
06:00:16 <AstralStorm> A type defin of -> nullPtr is wrong :/
06:00:42 <dcoutts__> Rasp: start in C:\haskell\inlup1\ and then it'll be fine
06:00:48 <dcoutts__> ie cd C:\haskell\inlup1\
06:00:58 <dcoutts__> ghci Pattern.hs
06:01:26 <Rasp> but then it wont find ghci.exe since its in another map
06:01:30 <xerox> Or even ghci -i C:\haskell\inlup1 Pattern.hs ?
06:01:41 <dcoutts__> Rasp: when ghci sees you trying to import Utilites it looks for a file Utilities.hs in the *current* directory
06:01:59 <xerox> You have to add ghci.exe's path to the PATH environment variable.
06:02:05 <ndm> Rasp: WinHugs just does all this junk automagically... (plus it creats a nice desktop shortcut ;)
06:02:10 <dcoutts__> unless, as xerox says, you tell ghci to look in a specific direcory by using -i
06:02:24 <Rasp> allright, i'll have a look at this winhug
06:02:32 <Sal> ?winhug
06:02:33 <lambdabot> Unknown command, try @list
06:02:38 <ndm> @where winhugs
06:02:38 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
06:02:39 <Sal> @winhug
06:02:40 <lambdabot> Unknown command, try @list
06:02:47 <Sal> @list
06:02:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
06:02:56 <dcoutts__> ndm: so it searches in the dir where the .hs file is rather than where you're building from?
06:03:04 <dcoutts__> hugs doesn't do that too does it?
06:03:20 <ndm> dcoutts__, the windows version silently cd's to the directory you load from
06:03:25 <dcoutts__> cheeky
06:03:30 <ndm> but uber useful!
06:03:38 <dcoutts__> great for one dir projects
06:03:50 <ndm> yhc does it properly, resolving directories relative to your path etc.
06:03:58 <dcoutts__> I don't think I have any of those any more :-)
06:04:04 <dcoutts__> ndm: ok good.
06:04:13 <ndm> i.e. c:\random\path\File.hs, gets the right dependancies
06:04:31 <Rasp> winhug works fine:D
06:04:51 <ndm> it even does clever things, like if Data.Map imports List.Stuff, it will hop up a directory from that file before hopping into List - much much nicer than GHC
06:05:20 <ndm> dcoutts__, WinHugs also works perfectly for multi-directory stuff as well, since it looks for things with the module name and the relative to the cd
06:05:30 <ndm> Rasp: good good :)
06:05:48 <dcoutts__> Rasp: hugs is fine and quick for development. If you ever find your progs are running too slowly, you can go back to ghc as it's an optimising compiler rather than a simple interpreter.
06:06:24 <ndm> dcoutts__, if you ever find your programs are compiling too slowly, you can go back to hugs ;)
06:06:34 <dcoutts__> heh, that's true too
06:06:35 <Rasp> yeah
06:06:45 <dcoutts__> hugs compiles very quickly
06:06:52 <Rasp> :)
06:06:59 <ndm> or you can flip to Yhc, which is (going to) have the fastest compiler and the fastest runtime
06:07:06 <dcoutts__> :-)
06:07:07 <ndm> (maybe...)
06:07:24 <dcoutts__> I await the results with anticipation :-)
06:07:28 <ndm> me too...
06:07:44 <yacstud> yhc is focusing on good performance of generated code ?
06:07:44 <Rasp> yes well, i better get started, youl probably here from me soon, this is my last trie before i give up this language:S
06:07:55 <ndm> yacstud: somewhat, its now one of my phd topics
06:07:56 <AstralStorm> dcoutts: heh, how would one specify a ForeignPtr to void* as a function type declaration?
06:08:30 <AstralStorm> I mean "any ForeignPtr" really.
06:08:34 <dcoutts__> AstralStorm: ForeignPtr (). but usually you invent a type for it
06:08:42 <dcoutts__> oh, for that use ForeignPtr a
06:08:50 <AstralStorm> Which doesn't work :P
06:09:04 <AstralStorm> ForeignPtr a won't work :/
06:09:20 <dcoutts__> then you don't really mean any foreign ptr
06:09:28 <dcoutts__> if it's a type error that is
06:09:58 <dcoutts__> btw, saying it doesn't work with no context doesn't help :-)
06:10:42 <yacstud> ndm, great :-)
06:11:16 <dcoutts__> ndm: oh? what direction are you looking in for performance ?
06:11:26 <ndm> yacstud: http://www-users.cs.york.ac.uk/~ndm/yhc/graph-primes.png - this is the graph where we're hoping to whoop everyone
06:11:29 <lambdabot> http://tinyurl.com/mcd5j
06:11:41 <ndm> dcoutts__, making things faster, using my transformation system and my compiler analysis stuff
06:12:12 <dcoutts__> ndm: so high level optimising but targeting the same byte code ?
06:12:25 <ndm> dcoutts__, nope - C output
06:12:29 <dcoutts__> oh right
06:12:39 <ndm> i already have C output in my system, and can beat GHC on some benchmarks
06:12:48 <ndm> (usually because of startup time, on small benchmarks)
06:13:00 <dcoutts__> ah, you're counting compiling time too
06:13:06 <ndm> nope, just runtime
06:13:11 <dcoutts__> ah just startup
06:13:25 <ndm> yep, initialising the GC heap etc
06:13:28 <dcoutts__> right
06:13:49 <ndm> unfortunately i can't try larger benchmarks because my tail call stuff isn't done yet, so i blow the C call stack
06:14:55 <dcoutts__> I've never noticed that to be significant
06:14:55 <dcoutts__> right
06:14:56 <dcoutts__> ie when profiling against C versions of things I never noticed the gcc vs ghc generated progs have significantly different startup times
06:15:00 <AstralStorm> I wonder why ghc complains about the lack of CString, when I've imported Foreign.C.String
06:15:25 <AstralStorm> Ah, it looks for a data constructor, my mistake :P
06:15:27 <AstralStorm> Easy to fix.
06:15:28 <ndm> yep, i noticed that GHC has almost no overhead too - but i still win on small benchmarks, and can't compete on bigger ones because of stack overflow
06:15:42 <ndm> so its *possible* that i am beating GHC on raw speed, rather that start
06:15:45 <dcoutts__> ndm: how do you hope to do tail calls with C ?
06:16:04 <ndm> dcoutts__, computed goto's with GCC - not really C, more high level assembler
06:16:16 <dcoutts__> aye, ok
06:16:46 <mux> C *is* a high level assembler :)
06:16:50 <dcoutts__> and GC of local variables? or will they always be kept on the heap?
06:16:56 <dcoutts__> mux: just not a very good one
06:17:04 <ndm> mux: once you add computed goto's, its a lot closer
06:17:04 <dcoutts__> too little control
06:17:13 <mux> I suppose that depends on your criterions
06:17:17 <ndm> dcoutts__ - GC of local variables? you mean region inference stuff?
06:17:34 <ndm> i have my own stack, which the GC can examine, and a heap
06:17:49 <dcoutts__> ndm: ah, ok you manage your own stack
06:18:02 <ndm> yep, i already do that, even though i'm using procedures
06:18:06 <dcoutts__> so things can't be kept in registers too much
06:18:15 <ndm> once i move to only copmuted goto's, there will be basically nothing else
06:18:21 <ndm> i am going to have unboxing of some stuff
06:18:33 <dcoutts__> unboxing can be a massive win
06:18:35 <ndm> so int's etc will never make it into the heap, if used directly
06:18:43 <ndm> yep, i guessed as much :)
06:18:55 <ndm> but i have a different unboxing strategy
06:18:57 <dcoutts__> for ByteString is makes a huge difference
06:18:58 <AstralStorm> Uh, blah, can't properly do those autofinishing functions.
06:19:14 <ndm> so for example, Bool will be unboxed, Char, Nothing (but not Maybe) etc
06:19:26 <ndm> *(but not Just)
06:19:28 <AstralStorm> Ah, now I know :>
06:19:36 <dcoutts__> ndm: using extra bits in the pointer ?
06:19:41 <ndm> dcoutts__, yep
06:19:43 <dcoutts__> nice
06:19:52 <ndm> although static analysis will sometimes eliminate those extra bits
06:20:12 <ndm> i.e. in some cases i'll have raw C style int's, with no mask or anything, that never see the heap
06:20:42 <dcoutts__> I though you'd only need extra bits on pointers into the heap
06:20:46 <dcoutts__> not on ints
06:21:10 <ndm> yep, but if int's get into the heap
06:21:13 <ndm> they need tagging
06:21:27 <ndm> since i unbox all int's, even those which are computed lazily
06:21:35 <dcoutts__> ndm: ah ok
06:22:30 <ndm> how much is the cost of a string in GHC?
06:22:35 <ndm> i.e. a normal one
06:22:40 <dcoutts__> 12 bytes  per char
06:22:41 <ndm> you said 12 bytes per char?
06:22:49 <dcoutts__> it would be 20
06:23:02 <dcoutts__> but the actual char boxes are preallocated for the first 256 values
06:23:09 <ndm> ah
06:23:13 <ndm> which makes it 12?
06:23:43 <dcoutts__> so 4 for the heap box header, 4 for the element pointer, 4 for the next pointer
06:23:49 <dcoutts__> or double that for 64bit arch
06:24:01 <ndm> well for my system it will be 8 per char
06:24:12 <dcoutts__> no header word
06:24:13 <ndm> and thats even for unicode char
06:24:16 <ndm> nope :)
06:24:35 <ndm> [Int], will also be 8 bytes per item
06:24:37 <dcoutts__> oh because the char is unboxed
06:24:40 <ndm> yep
06:25:10 <dcoutts__> so the pointer to the thunk and the evaluated int/char are aliased onto each other
06:25:19 <dcoutts__> with a tag bit to indicate
06:25:35 <ndm> yes, basically
06:25:45 <dcoutts__> how does the GC know how big each heap box is?
06:25:53 <ndm> it has separate heaps for each size
06:25:58 <dcoutts__> ah
06:25:59 <ndm> 1-n
06:26:08 <dcoutts__> and for variable ones, they have headers
06:26:11 <ndm> and then above n you can incurr an extra word
06:26:13 <ndm> yep
06:26:21 <ndm> but thats unlikely to be very common
06:26:23 <dcoutts__> interesting idea
06:26:36 <dcoutts__> well, byte arrays etc
06:26:43 <dcoutts__> arrays in general
06:27:03 <dcoutts__> so you need N heap pointers
06:27:21 <ndm> but those having a header word are greater than a certain size, so as a percentage, its very little
06:27:42 <ndm> i.e. for a big array, an extra N pointers is nothing :)
06:28:07 <dcoutts__> right, in terms of number of objects there are few big ones
06:28:12 <ndm> actually, for mine, Array Int ~= Array Int# - just without strictness
06:28:15 <AstralStorm> Hmm, YAHT is a bit inaccurate wrt GHC 6.5
06:28:37 <AstralStorm> There's no FiniteMap anymore.
06:28:46 <dcoutts__> good point
06:29:22 <dcoutts__> ndm: eliminating indirections is quite important for modern cpus, you might get some big wins
06:29:36 <dcoutts__> ndm: eliminating indirect gotos is similarly important
06:29:39 <ndm> dcoutts__, i know :)
06:29:57 <ndm> my scheme makes everything entirely first order - so map head doesn't pass head around
06:30:11 <ndm> its only laziness that causes indirections
06:30:27 <dcoutts__> how do you avoid passing functions about?
06:30:33 <ndm> dcoutts__, magic :)
06:30:36 <dcoutts__> hah hah
06:30:40 <ndm> dcoutts__, mainly specialisation
06:30:41 <dcoutts__> expanding etc
06:30:50 <ndm> map head ==> map<head>
06:31:00 <dcoutts__> right, are you sure it's possible in all cases?
06:31:01 <ndm> map with head frozen in at compile time
06:31:09 <ndm> i'm sure its not possible in all cases
06:31:13 <dcoutts__> polymorphic recursion etc
06:31:15 <ndm> but it is in almost all
06:31:22 <dcoutts__> yes, I can believe that
06:31:30 <ndm> and if not, you can do reynold's style defunctionalisation
06:31:31 <dcoutts__> in most code that people actually write
06:31:40 <ndm> which makes it possible in absolutely all cases
06:31:45 <ndm> indeed
06:31:57 <dcoutts__> or in most code that people write where they care about speed
06:32:05 <ndm> i'd actually say pretty much all code
06:32:11 <ndm> even when not written for speed
06:32:19 <dcoutts__> ndm: is it possible to do a goto to a function label, without having to do a computed goto?
06:32:33 <ndm> dcoutts__, with gcc - yep
06:32:36 <dcoutts__> ie a direct jump not a computed jump
06:32:45 <ndm> goto label
06:32:48 <ndm> :label
06:32:57 <ndm> (or label: is C, right - the other is VB)
06:33:06 <dcoutts__> and that label can be in another function?
06:33:19 <ndm> i will only have one function in my output
06:33:24 <dcoutts__> ah ok
06:33:28 <ndm> but no, you can't hop between functions
06:33:38 <dcoutts__> whole prog to one C function
06:33:42 <ndm> yep :)
06:33:46 <dcoutts__> that'll make gcc cry ;-)
06:33:50 <ndm> yep :)
06:34:00 <dcoutts__> you'll expose all te O(n^2) bits
06:34:01 <ndm> i might try to do some analysis to split it up a bit
06:34:14 <ndm> or convert goto's into loops
06:34:23 <dcoutts__> it'll still hurt
06:34:24 <ndm> yeah, i fully expect C compile time to suck
06:34:34 <dcoutts__> gcc converts loops into gotos anyway
06:34:35 <ndm> but meh, get a faster computer, or compile to bytecode
06:34:42 <dcoutts__> it's all the same at the lower level
06:34:47 <ndm> ah, thats nice to know
06:35:05 <dcoutts__> in thingie form
06:35:09 <dcoutts__> SSA
06:35:11 <ndm> although would be nice to use loops, so Visual Studio can come to play as well
06:35:41 <dcoutts__> you're not interested in targeting C--
06:35:54 <ndm> not really
06:36:07 <ndm> i'm 100% certain that GCC is finished
06:36:08 <dcoutts__> well, it sounds fun
06:36:16 <ndm> C-- looks like a moving target...
06:36:20 <dcoutts__> true
06:36:23 <dcoutts__> I'm sure you'll keep us posted
06:36:23 <yip> does c-- have builtin support for multithreading?
06:36:29 <dcoutts__> yip: sort of
06:36:30 <ndm> i am tempted to target ASM
06:36:39 <dcoutts__> ndm: share the ghc NCG perhaps
06:36:49 <ndm> dcoutts__, again, moving targets scare me...
06:36:55 <dcoutts__> it doesn't move much
06:37:06 <ndm> i only have a very small number of concepts
06:37:16 <xerox> http://www.irregularwebcomic.net/96.html
06:37:17 <ndm> so might pass them via my ASM programming friend and get templates for them
06:37:17 <lambdabot> Title: Irregular Webcomic!
06:37:21 <AstralStorm> yip: sort of broken, but yes
06:37:25 <xerox> (Bad math joke)
06:38:59 <mux> heh, gcc is finished?
06:40:26 <ndm> i am pretty sure they will continue to support C for the forseeable future
06:40:34 <Rasp> as I understand it the way you program haskell is recursive right=
06:40:35 <Rasp> ?
06:40:41 <mux> ndm: I hope so :-).
06:40:48 <ndm> Rasp: yes
06:41:49 <lisppaste2> spookylukey pasted "sum overflows" at http://paste.lisp.org/display/26158
06:42:54 <Rasp> its really difficult too think recursive
06:43:02 <spookylukey> Can anyone tell me why 'sum' is stupid like this?
06:43:20 <int-e> for historical reasons
06:43:42 <lisppaste2> basvandijk pasted "error emerge ghc-6.5_pre20060912" at http://paste.lisp.org/display/26159
06:43:47 <int-e> changing it to foldl' would change the behaviour in some obscure places.
06:43:50 <AstralStorm> Rasp: know math recursive function definitions?
06:43:51 <ndm> Rasp: depends, once you get the hang of it its easier, since you can abstract over the recursive bits with common patterns
06:44:04 <AstralStorm> That's recursion for ya.
06:44:30 <spookylukey> OK, thanks int-e.  But basically I will usually want to use my own foldl version?
06:44:39 <int-e> spookylukey: yes
06:45:30 <mux> looks like Hugs handles sum "correctly"
06:45:35 <mux> Hugs> sum [0..1000000]
06:45:36 <mux> 500000500000
06:45:52 <AstralStorm> Uh?
06:46:07 <AstralStorm> Why would GHC overflow?
06:46:15 <mux> seems weird, yeah
06:46:18 <mux> but it does here too
06:46:18 <spookylukey> So it's a GHC specific known bug?
06:46:24 <mux> and it's apparently expected according to int-e
06:46:28 <AstralStorm> Maybe it tries to fit the result in an Int?
06:46:59 <int-e> I suspect that compiled code usually behaves fine, depending on the strictness analysis pass.
06:46:59 <spookylukey> If you try with 100000000 it uses up all available RAM
06:47:12 <ndm> hmm, maybe thats the foldr build issues?
06:47:20 <ndm> i know length had that issue for a brief period of time
06:47:33 <dcoutts__> I don't know why it's happening
06:47:51 <dcoutts__> the code in the base lib is defined to use foldl'
06:47:53 <AstralStorm> @type sum
06:47:55 <lambdabot> forall a. (Num a) => [a] -> a
06:48:02 <AstralStorm> Hmm, no ints...
06:48:16 <ndm> dcoutts__, sure they haven't foldr/build'ed it?
06:48:17 <int-e> with ghci it's definitely expected.
06:48:20 <mux> compiled code overflows similarly here
06:48:21 <AstralStorm> Maybe 0 becomes an int.
06:48:29 <dcoutts__> sum     l       = sum' l 0
06:48:31 <dcoutts__>   where
06:48:31 <dcoutts__>     sum' []     a = a
06:48:31 <dcoutts__>     sum' (x:xs) a = sum' xs (a+x)
06:48:35 <mux> pentane% ./sum
06:48:35 <mux> Stack space overflow: current size 8388608 bytes.
06:48:35 <mux> Use `+RTS -Ksize' to increase it.
06:48:35 <int-e> dcoutts__: sum is just a tight ... exactly
06:48:40 <dcoutts__> from ghc/libraries/base/Data/List.hs
06:49:05 <AstralStorm> Now that's overflowy.
06:49:07 <int-e> it's not strict, but should get inlined, so it's up to the strictness analysis.
06:49:07 <dcoutts__> that sum is tail recursive, should be no problem
06:49:27 <dcoutts__> ah, hmm yes
06:49:34 <int-e> naa, it's the thunks built (the (+)) that cause a stack overflow when the sum is forced.
06:49:39 <dcoutts__> {-# SPECIALISE sum     :: [Int] -> Int #-}
06:49:43 <int-e> oh
06:49:46 <dcoutts__> but that only helps with -O
06:50:04 <mux> I justtried with -O and it overflowed too
06:50:21 <AstralStorm> Uh, sum will run out of stack due to tons of recursion - and it doesn't look tail-recursive to me.
06:51:05 <int-e> the version dcoutts__ just pasted is tail recursive
06:51:18 <AstralStorm> But it isn't the default sum, right?
06:51:19 <int-e> but it's not strict, which is the problem.
06:51:26 <AstralStorm> Huh. Right.
06:51:30 <lisppaste2> basvandijk annotated #26159 with "mk/package.mk" at http://paste.lisp.org/display/26159#1
06:51:40 <int-e> it is the default sum for ghc. the prelude definition is in terms of foldl.
06:51:48 <int-e> (which also isn't strict)
06:52:06 <int-e> but tail recursive.
06:52:22 <AstralStorm> So shouldn't overflow. Now, why does it?
06:53:04 <int-e> because it builds a big term, tail-recursively, then forces its value (which is not tail-recursive).
06:53:36 <int-e> the term built is l1 + (l2 + (l3 + (l4 + (...))) where l1 and so on are the list elements.
06:53:53 <int-e> err, wrong way
06:53:57 <int-e> that would be foldr, sorry.
06:54:07 <int-e> but you get the idea. the term is built, not evaluated.
06:55:33 <SamB> ndm: wouldn't it make more sense to tail call functions taking no arguments than to have one huge function?
06:56:00 <ndm> SamB: will GCC reliably optimise that away?
06:56:03 <yip> dcoutts__: what about gtk2hs-update-for-ghc-6.6.patch?
06:56:35 <SamB> as long as you compile with optimization, it should...
06:56:37 <ndm> SamB: tail call is only in later GCC's, and itsn't reliable
06:56:51 <SamB> what are these "later GCCs"?
06:56:55 <AstralStorm> 3.4+
06:57:05 <SamB> ... seriously?
06:57:13 <ndm> i think so, yes
06:57:28 <dcoutts__> yip: I'm reviewing that
06:57:46 <yip> dcoutts__: if i apply it to latest darcs repos, is there a good chance that it will work?
06:58:07 <dcoutts__> yip: you'll need yo unapply it later when I fix it differently.
06:58:19 <dcoutts__> or you'll get conflicts
06:58:33 <yip> dcoutts__: right, but will it work for me right now?
06:58:38 <dcoutts__> but you're welcome to try it
07:00:10 <mux> tail call optimizations are in since GCC 3
07:00:17 <SamB> one big function seriously sounds like a bad idea...
07:01:38 <AstralStorm> mux: but non-broken since 3.4 :P
07:01:52 <SamB> what was broken before 3.4?
07:01:54 <AstralStorm> In others they're not enabled at all.
07:02:01 <int-e> @free run :: a -> b -> (b, a)
07:02:02 <lambdabot> g ($fst (run x y)) = $fst (run (f x) (g y)) && f ($snd (run x y)) = $snd (run (f x) (g y))
07:02:03 <AstralStorm> In 3.4 enabled in -O2
07:02:10 <SamB> ... really?
07:02:11 <ndm> i'm going to try it, and if it doesn't work, then i'll look at getting tail calls going
07:02:24 <mux> AstralStorm: yes
07:02:25 <SamB> ndm: it will probably work
07:02:26 <AstralStorm> They were exponential, read: broken :P
07:02:27 <ndm> since its a more reliable way of encoding the semantics i'm after
07:03:01 <AstralStorm> Enabling them <3.4 means your app will compile in some years :P
07:03:02 <SamB> but it will probably be slow as molassas to run through GCC...
07:03:17 <SamB> AstralStorm: exponential?
07:03:25 <AstralStorm> Unfortunately. :P
07:03:32 <SamB> how do you mean?
07:03:39 <AstralStorm> n^x
07:03:48 <AstralStorm> Where x is something damn large :P
07:04:02 <SamB> what did they do that had the slightest thing to do with exponentials?
07:04:09 <AstralStorm> exp n x
07:04:26 <AstralStorm> Even better definition of that.
07:04:28 <SamB> explain yourself!
07:04:44 <AstralStorm> It has time of n^x, where x depends on n
07:05:29 <SamB> you seriously need to invest in some big Os
07:05:35 <mux> yeah :)
07:05:38 <AstralStorm> Yep.
07:06:04 <SamB> also, what kind of code does it generate that is so slow?
07:06:12 <SamB> and what are n and/or x?
07:06:21 <mux> algorithms are often qualified as sub-linear (O(log n) for instance), linear (O(n)) or exponential (O(n^x))
07:06:33 <ndm> AstralStorm: exponential at compile time, or runtime?
07:07:33 <AstralStorm> compile time
07:07:59 <SamB> did you know that O(n) = O(n^2)? but not O(n^2) = O(n).
07:08:11 <SamB> oh, compile time?
07:08:15 <AstralStorm> SamB: use Omega(sth) and be happy :P
07:08:27 <ndm> O(n^2) /= O(n)
07:08:31 <AstralStorm> SamB: except the x depend on the number of functions or something.
07:08:33 <ndm> = is reflexitve
07:08:38 <int-e> mux: sublinear is just o(n), isn't it?
07:08:39 <SamB> ndm: not according to my book!
07:08:41 <AstralStorm> Exactly.
07:08:46 <AstralStorm> O(n^2) -> O(n)
07:08:49 <ndm> SamB: buy a better book!
07:08:56 <AstralStorm> Or better =>
07:09:04 <bartw> :)
07:09:05 <mux> int-e: o(n) is another notation for it, but I most often see big O's
07:09:06 <SamB> ndm: what is a better book than Knuth Vol. 1?
07:09:09 <AstralStorm> Blah, the other way around.
07:09:18 <AstralStorm> O(n) => O(n^2)
07:09:19 <mux> a better book than Knuth's ?!
07:09:30 <ndm> SamB: really? Knuth says that = is not reflexive? i find that hard to believe...
07:09:36 <bartw> try something not a few decades out of date
07:09:40 <mux> heresy!
07:09:45 <AstralStorm> Yep. Cormen/Leiserson/Rivest/Stein
07:09:45 <mux> :-)
07:09:49 <int-e> AstralStorm: just realize that O(n) is a set of functions and use subset notation
07:10:04 <AstralStorm> int-e: hehe
07:10:07 <int-e> AstralStorm: O(n) \subset O(n^2)
07:10:14 <ndm> SamB: i'm willing to read =>, subset, but not =
07:10:24 <ndm> maybe he got his typesetting wrong ;)
07:10:47 <bartw> could be worth 256 $ ?
07:10:48 <AstralStorm> Tex bit him? :P
07:10:55 <SamB> ndm: hmm, maybe he chose a bad way to write it!
07:11:03 <ndm> SamB: probably
07:11:22 <Tobsan> is there any good editor for windows with haskell-highlighting?
07:11:25 <mux> don't you guys the equal sign with a third bar?
07:11:28 <ndm> Tobsan: Textpad
07:11:34 <mux> congruancy or whatever it's called in english
07:11:37 <mux> err
07:11:37 <Tobsan> :o link pls
07:11:42 <ndm> @where TextPad
07:11:42 <lambdabot> I know nothing about textpad.
07:11:43 <mux> s/guys/ guys mean/
07:11:46 <SamB> anyway
07:11:49 <AstralStorm> mux: That's ===
07:11:50 <ndm> @where+ Textpad www.textpad.com
07:11:51 <lambdabot> Done.
07:11:54 <int-e>  \equiv
07:12:08 <mux> AstralStorm: it's not written that way at least
07:12:12 <mux> by hand
07:12:13 <ndm> Tobsan: ^^
07:12:19 <Tobsan> thanks
07:12:26 <AstralStorm> mux: usually not :> But in printed form, sometimes.
07:12:27 <ndm> Tobsan: you need to download a separate Haskell mode, but its on the syntax hilighting page
07:12:35 <Tobsan> :o ok
07:12:41 <SamB> AstralStorm: what are n and x, though?
07:13:01 <mux> n usually denotes the number of elements you deal with
07:13:01 <AstralStorm> n is the number of function calls
07:13:18 <AstralStorm> x is something less than n - dependent on other optimisation phases
07:13:27 <mux> uh?
07:13:48 <SamB> mux: we are talking about a specific case
07:13:54 <mux> oh, sorry
07:14:04 <AstralStorm> mux: did I say you'd wait a year until it compiles with tail-opt phase enabled in GCC <3.4?
07:14:28 <mux> AstralStorm: you lost me here again
07:14:37 <mux> what's your point ?
07:14:56 <AstralStorm> Tail-opt is not broken since GCC 3.4
07:15:02 <SamB> AstralStorm: what was it doing that made it so slow?
07:15:07 <AstralStorm> Earlier than that, it takes just too long time.
07:15:19 <AstralStorm> I don't know - maybe the phase was too late in the chain...
07:15:30 <SamB> so, could you tell me what kind of effect using one big function for the whole program would have on compilation time?
07:15:48 <AstralStorm> SamB: even in one func you have a lot of function calls :>
07:16:14 <SamB> instead of tail-calls, I mean.
07:16:24 <SamB> with gotos, you know?
07:16:30 <ndm> if you compiled say 1000 lines into one function, with computed goto's
07:16:33 <AstralStorm> Now that'd would work - computed gotos
07:16:44 <ndm> even with 1000 lines in one function?
07:16:44 <AstralStorm> *s/would//
07:16:49 <AstralStorm> Most likely.
07:16:56 <SamB> but, are there a lot of optimizations that are superlinear in function size or something like that?
07:17:34 <AstralStorm> SamB: superlinear, maybe quadratic - and it's not that bad.
07:17:40 <bartw> winhugs doesn't eat the examples from "Haskell for C Programmers"
07:17:48 <ndm> 1000^2 = 1000,000 = bad
07:17:49 <AstralStorm> Much better than enabling tail-opt in old 3.x GCC
07:17:53 <ndm> bartw: give us an example?
07:18:04 <AstralStorm> ndm: 100^75  = worse :P
07:18:06 <SamB> but... wouldn't that mean it would tike four times as long to compile your program if it was twice as long?
07:18:20 <ndm> i can get over that, buy a bigger processor
07:18:31 <ndm> although might limit it in the end
07:18:35 <ndm> then i can flip to ASM
07:18:39 <bartw> ndm: bar :: Int -> Int
07:18:48 <SamB> AstralStorm: but, the tailcall thing -- it would not really be a problem if your functions were small enough would it?
07:18:51 <ndm> bartw: winhugs can do that easy
07:18:54 <bartw> ndm: Undefined variable "bar"
07:18:59 <AstralStorm> SamB: yes.
07:19:04 <Tobsan> ndm do you happen to have the .syn-file for haskell?
07:19:13 <AstralStorm> The exponential behaviour will hit you when you least expect it.
07:19:17 <SamB> hmm
07:19:19 <ndm> bartw: what are you typing, and at the prompt or in source code
07:19:24 <mux> ndm: output RTL :-)
07:19:25 <Cale> bartw: are you making sure to put declarations into a file, which you load in hugs?
07:19:40 <bartw> ndm: prompt, i guess its not interactive then ?
07:19:48 <AstralStorm> Even 10^8 > 1000^2
07:20:03 <ndm> Tobsan: http://www.textpad.com/add-ons/files/syntax/haskell2.zip
07:20:05 <lambdabot> http://tinyurl.com/hjpbv
07:20:06 <Cale> bartw: It's only interactive in the sense that it lets you type expressions and have them evaluated
07:20:17 <Cale> bartw: You can't define new things at the hugs prompt
07:20:17 <ndm> bartw: it is, but not like that - you can't define new functions
07:20:26 <ndm> mux: can gcc read in RTL?
07:20:39 <mux> ndm: RTL is gcc's intermediate language
07:20:46 <SamB> ndm: I think so but, can you write it?
07:20:47 <bartw> Cale. ndm: ah, too bad, so i need an adtional editor and source file then
07:21:02 <SamB> bartw: yeah!
07:21:13 <ndm> mux: i know, can it read it though? i remember GCC was against that, as you could splat a proprietory front end on it
07:21:14 <Tobsan> ndm i downloaded and installed that archive, but i don't get no highlighting for my haskell-files
07:21:35 <AstralStorm> WTF? Someone can actually write RTL?
07:21:44 <SamB> AstralStorm: heh
07:21:45 <AstralStorm> <gah>
07:21:47 <ndm> Tobsan: you then have to setup Haskell syntax colouring, Configure -> New Document Class...
07:21:49 <SamB> I doubt it
07:21:57 <SamB> I don't think ndm knows what he is talking about
07:22:00 <mux> ndm: hmmm, dunno, maybe you need to integrate your thing with GCC for it to work
07:22:08 <Cale> bartw: Yeah. In GHCi, you can use "let f x = x + x" at the prompt to define a new tempoorary function f, but for anything more complicated, you still need a file
07:22:18 <ndm> Tobsan: after putting the .syn file in the appropriate place - c:\program files\Textpad 4\something... (look for the other .syn files)
07:22:27 <Tobsan> yes
07:22:29 <SamB> trust me... you don't *want* to write RTL...
07:22:34 <Cale> bartw: there are good reasons for this -- the alternative would likely be more confusing than it's worth
07:22:35 <araujo> morning!
07:22:58 <Cale> morning
07:23:01 <mux> hahaha
07:23:08 <ndm> SamB: i was under the impression that you can't read it in easily, or athat its deliberately not separated, to stop outside (commerical) projects dumping RTL - but might be wrong
07:23:33 <ndm> it certainly was at one point, but that may have been a while ago
07:23:34 <SamB> I don't think they have anything to worry about
07:23:35 <SamB> they'
07:23:38 <SamB> er.
07:23:54 <Tobsan> ndm what's the name of the .syn-file? i cant find anyone saying anything near haskell
07:23:55 <bartw> Cale, partially defined functions, not yet bound identifiers, i can imagine :)
07:24:00 <SamB> they'd probably break compatability with said commercial projects with every release anyway ;-)
07:24:10 <Cale> bartw: yeah :)
07:24:29 <ndm> Tobsan: extract the .zip into the TextPad directory for syntax files, then it shows up at Haskell2.syn
07:24:39 <Tobsan> no it doesnt
07:24:54 <ndm> you may need to do Configure -> New Document Class... again, since its doesn't refersh
07:25:20 <Tobsan> well...i dont have the file Haskell2.syn...it wasnt in the zip
07:25:32 <bartw> haskell is pretty clear sofar, nothign as bad as advertised, yet atleast
07:25:37 <ndm> Tobsan: oh, it is when i downloaded it...
07:25:46 <Tobsan> can you send it?
07:25:50 <SamB> bartw: advertised?
07:25:51 <ndm> Tobsan: http://www.textpad.com/add-ons/files/syntax/haskell2.zip - this zip?
07:25:53 <lambdabot> http://tinyurl.com/hjpbv
07:25:58 <ndm> Tobsan: of course, if you need it
07:26:18 <Tobsan> ndm no seems like i got the wrong zip
07:26:26 <ndm> Tobsan: http://www-users.cs.york.ac.uk/~ndm/temp/Haskell2.syn
07:26:28 <lambdabot> http://tinyurl.com/rf9g4
07:26:34 <Tobsan> i have it now =)
07:26:35 <ndm> if that makes it any easier
07:26:38 <ndm> good good
07:26:53 <Cale> bartw: "As bad as advertised"? Have you heard a lot of negative press?
07:27:54 <bartw> Cale: not really negative, more that you shouldn't try it unless you're pretty sure you want to
07:28:14 <Tobsan> ndm, ah, now it works ^^ Thanks a lot
07:28:29 <ndm> Tobsan: good good, no problem
07:28:42 <ndm> bartw: from where?
07:29:04 <Tobsan> ndm actually i downloaded three editors before textpad haha, and noone seemed to have highlight for haskell
07:29:28 <bartw> ndm: people who don't use haskell i guess :)
07:29:30 <ndm> Tobsan: Textpad is the best editor for Windows, so you should be happy now forever more :)
07:29:40 <Tobsan> ndm can you use tabs in it?
07:29:43 <ndm> yep
07:29:51 <Tobsan> :o gotta find that
07:29:56 <ndm> Tobsan: View -> Document Tabs
07:30:00 <yip> vim is the best editor in all the land
07:30:02 <Tobsan> found it
07:30:26 <ndm> and Options -> Preferences -> View lets you put the tabs where you want
07:31:08 <Tobsan> NICE!
07:32:43 <AstralStorm> yip: almost - it has no good indentation detection.
07:32:45 <ndm> Tobsan: now get WinHugs, and you'll find it automatically integrates with TextPad
07:32:59 <ndm> openning files, jumping to error locations etc.
07:33:01 <Tobsan> ndm :O i have winhugs....*configuring*
07:33:28 <ndm> Tobsan: if you restart WinHugs, it should spot TextPad is installed and use it automaticalcly
07:33:48 <Tobsan> ndm i made it work...now i'm happy ever after
07:34:03 <yip> AstralStorm: maybe it doesn't have good automatic indentation for haskell, but when you get good at vim you won't need or want automatic language indentation
07:34:10 <ndm> Tobsan: good to hear! (TextPad + WinHugs is how I develop things :) )
07:34:21 <bartw> ndm: but the yearly icfpcontest shows that the haskell people do great stuff, I want to end some higher next time so i guess 'iycbtjt' might be in order
07:34:43 <AstralStorm> yip: I don't mean the autoindent. I mean the indentation detector: tabs vs spaces - and the amount
07:35:34 <yip> AstralStorm: that is highly configurable
07:37:09 <AstralStorm> I know.
07:37:12 <AstralStorm> But no autodetection.
07:37:31 <AstralStorm> Which is a PITA when working on someone else's code.
07:38:51 <AstralStorm> I have one project - vim indent detect plugin in Haskell.
07:39:07 <AstralStorm> I've seen some implementation in Perl, unfortunately broken.
07:39:16 <yip> that's why there is the vi comment line
07:39:40 <dons> AstralStorm: you can start here ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/indent/
07:39:40 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
07:39:41 <AstralStorm> yip: yeah, tell that to the other devs :P
07:39:52 <AstralStorm> Heh.
07:41:05 <AstralStorm> dons: I actually thought about a filter returning proper set options.
07:41:14 <AstralStorm> Heuristic of course, with some params.
07:41:49 <AstralStorm> And your .vim is for autoindent, not general indent detection.
07:42:01 <dons> a good start would be to get indenting on layout-tweaking keywords to work, following the h98 report
07:42:17 <dons> oh, what's the difference?
07:43:01 <AstralStorm> Major - general has to work for all langs.
07:43:07 <dcoutts__> g'morning dons :-)
07:43:25 <dcoutts__> dons: my zlib code is starting to become comprehensible :-)
07:43:28 <dons> cool
07:43:33 <AstralStorm> great
07:44:02 <dcoutts__> the abstraction & invariants are getting clearer
07:44:10 <ndm> dcoutts__, are you interfacing to zlib, or writing zlib in Haskell?
07:44:34 <dcoutts__> ndm: interfacing to zlib
07:44:34 <dons> ndm, had a play with the new lambdaweb interface to lambdabot?
07:44:48 <dcoutts__> ndm: and then bzlib2
07:44:58 <ndm> dcoutts__, have you seen bluezip? about 30Kb and zlib compatible, with a nicer interface
07:45:04 <ndm> dcoutts++
07:45:11 <ndm> dons: yep, its cool!
07:45:24 <dcoutts__> ndm: zlib has a reasonable interface actually and it's totally standard
07:45:45 <ndm> dcoutts__, fair enough - a definately useful binding for Haskell to have!
07:45:58 <ndm> dons: how long til its "ready" (TM)
07:46:23 <dons> pretty soon I reckon. seems to be "bug free" (TM). just needs docs, pretty colors and such
07:46:41 <ndm> what would be really nice is (more..) buttons
07:46:46 <dons> yeah
07:46:55 <ndm> and syntax colouring for haskell expressions
07:47:06 <dons> that too. need to talk to bringert about the best way
07:47:18 <dons> i'd like to tweak lambdabot to spit out hscolored-html
07:47:18 <ndm> and hoogle colouring - but that might be best to wait for Hoogle 4 (then i can make it sane for you)
07:47:23 <xerox> dons: concat ["foo","++"] for adjusting karma does work on a per-channel basis?
07:47:27 <ndm> yeah, that would be nice
07:47:38 <dons> xerox: no. it works globally
07:47:59 <dons> and the regex is : "^([a-zA-Z0-9_']+)(\\+\\+|--)($| )"
07:48:02 <xerox> dons: #perl6 has a bot that says concat ["foo","++"] for each line on commit messages!!
07:48:17 <dons> oh, you mean automatically
07:48:18 <dons> fun
07:48:39 <xerox> dons: I was thinking that that is going to pollute the karma-space very much :)
07:50:45 <dons> oh, well. probably its ok
07:51:40 <xerox> Alright.
07:54:16 <sek> http://xkcd.com/comics/sandwich.png heh
07:54:23 <Sal> @yet another tutorial
07:54:29 <lambdabot>  Parse error
07:54:40 <Sal> ? yet another tutorial
07:55:07 <xerox> @where yhat
07:55:07 <lambdabot> I know nothing about yhat.
07:55:10 <xerox> @where yaht
07:55:10 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
07:55:17 <Sal> where can i find "ye another tutorial"?
07:55:35 <dons> ^^ at that url
07:57:59 <Sal> i find it a bad link in "www.haskell.org"
08:01:47 <dons> fixed.
08:02:07 * xerox is tempted to do the nth concat ["dons","++"].
08:04:07 <AstralStorm> map (\x -> concat ["dons","++"]) [1..]
08:04:18 <xerox> Yuuuuck.
08:04:47 <AstralStorm> Hhehe.
08:05:10 <AstralStorm> map (\x -> print concat ["dons","++"]) [1..]
08:05:13 <AstralStorm> Better?
08:05:22 <xerox> Beside being a type error...
08:05:45 <AstralStorm> Wrong way around? :P
08:05:58 <xerox> print $ ...
08:06:03 <AstralStorm> Uh, right :>
08:09:06 <AstralStorm> or print (concat ["dons","++"])
08:10:40 <AstralStorm> And don't forget about turning off buffering, or it won't work.
08:14:55 <Rasp> do you have too write this stuff for your methods "match :: Eq a => a -> [a] -> [a] -> Maybe [a]"
08:14:58 <Rasp> ?
08:15:26 <Rasp> because I have no id hove
08:16:29 <dons> you don't need to write types, if they can be inferred by the compiler
08:16:48 <dons> but its a good idea to learn them - -since they document the behaviour of your function for the compiler to check
08:17:07 <dons> ?let f x = x ^ 2
08:17:08 <lambdabot> Defined.
08:17:15 <dons> > L.f 8 -- no type signature
08:17:16 <lambdabot>  64
08:17:40 <dons> ?undefine
08:17:41 <xerox> dons: do L.(ambdabot) bindings (radio-actively) decay in time?
08:17:41 <lambdabot> Undefined.
08:17:49 <dons> ?let f x = x ^ 2  :: Int -> Int -- or with one
08:17:50 <lambdabot> <local>:1:8:     No instance for (Num (Int -> Int))       arising from use of...
08:18:09 <dons> well, when they're correct :}
08:18:14 <dons> ?type let f x = x ^ 2 in f
08:18:15 <lambdabot> forall a. (Num a) => a -> a
08:18:35 <xerox> Yeah you are doing f x = (x ^ 2 :: Int -> Int) I think.
08:18:40 <dons> ?let f :: Int -> Int ; f x = x ^ 2
08:18:41 <lambdabot> Defined.
08:18:42 <dcoutts__> dons: oh, here's a buglet: the show instance for lazy bytestring adds an LPS [...]
08:18:55 <dons> oh hmm
08:18:59 <mux> ?check \x -> x^2 > x :: Int
08:19:00 <lambdabot>  Couldn't match `Int' against `Bool'
08:19:21 <dcoutts__> dons: compare Data.ByteString.Char8.pack "foobar" with Data.ByteString.Lazy.Char8.pack "foobar"
08:20:25 <mux> ?check \x::Int -> x^2 > x
08:20:25 <lambdabot>  Parse error
08:20:33 <dons> that's no h98, mux
08:20:52 <mux> I figured as much :)
08:20:55 <dons> ?check (\x -> x^2 > x) :: Int -> Bool
08:20:56 <lambdabot>  Falsifiable, after 0 tests: 0
08:21:01 <mux> cool
08:21:05 <mux> thanks
08:21:16 <xerox> QuickCheck++
08:21:26 <dons> dcoutts__: right.
08:23:49 <araujo> nice, other lambdabot feature to (ab)use
08:23:55 <araujo> :-)
08:24:12 <xerox> ?quote
08:24:13 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
08:24:13 <lambdabot> you should have cited.
08:24:44 <dons> heh
08:24:58 <araujo> haha
08:26:05 <ndm> I prefer "cite your friends once, your enemies twice and the reviewers/editors three times"
08:26:31 * SamB tests GCC 3.3 with -foptimize-sibling-calls and various numbers of calls...
08:26:38 <dons> yeah, that's a good one ndm.
08:27:06 <araujo> 3.3? , that's soo old
08:27:07 <ndm> SamB: do keep me updated on your results, its very relevant for me!
08:27:13 <araujo> :-)
08:27:26 <SamB> ndm: okay ;-)
08:32:28 <SamB> hmm, what is a good way to analyse the results?
08:33:37 <ndm> time ?
08:33:40 <fnord123> gcc is finished as a product or finished as in done for?
08:34:10 <ndm> fnord123: as in they are still going to support C for a while to come
08:34:21 <SamB> huh?
08:34:22 <ndm> fnord123: its not a moving target, as far as C goes
08:34:28 <SamB> oh, right.
08:34:36 <fnord123> c99?
08:35:13 <ndm> i just meant that if i rely on GHC, they might break my stuff quite quickly (esp if my benchmarks beat them ;) ) - while GCC is a stable target
08:36:36 <yip> when c++ support was still developing, gcc used to break things all the time
08:37:02 <SamB> just FYI, GHC people are not spiteful -- they would only do that as a byproduct of attempting to improve their own benchmarks...
08:37:19 <ndm> i really was emphasising the ;)
08:37:26 <SamB> okay ;-)
08:37:40 <ndm> i am well aware they aren't spiteful, and have even sent them patches etc.
08:37:59 <SamB> and, of course, it is quite possible that GHC would break your performance, or depending how you fed it, the input format...
08:38:10 <ndm> indeed, its a very bleeding edge target
08:38:22 <ndm> once they have C-- split off, and stable, then that would be wonderful
08:38:44 <ndm> but for the moment, i'd end up debugging/implementing C-- as much as my own back end
08:45:52 <SamB> how far along is C-- now anyway?
08:47:35 <ndm> getting there
08:47:45 <ndm> I think Simon Marlow wants to make it the main thing
08:50:19 <SamB> I mean, how close is it to the C-- spec?
08:50:37 <SamB> does it at least have a compatible syntax now?
08:51:07 <ndm> don't think thats relevant to the use in GHC, so my guess is "no" - but thats only a guess
08:56:28 <SamB> ack
08:59:59 <ndm> dons: did you put out a HWN - last time i talked it was going out the next day - did i miss it?
09:05:02 <bartw> is an enum always of an Ord type ?
09:06:53 <AstralStorm> Hey guys, what's wrong with this?
09:06:55 <AstralStorm> data Space n = Space n
09:06:55 <AstralStorm> Space n :: Num n => n -> (' ',n)
09:07:34 <yacstud> bartw i don't think so : http://upload.wikimedia.org/wikipedia/commons/e/ee/Classes.png
09:07:36 <lambdabot> http://tinyurl.com/jggum
09:07:38 <AstralStorm> Uh, I know now, blah :P
09:07:41 <bartw> ' ' isn't a type i guess ?
09:08:46 <dons> AstralStorm: that's not hsakell :) Space n :: Num n => n -> (' ',n)
09:08:52 <ndm> AstralStorm: what exactly is Space? you can't define Constructor's?
09:08:56 <yip> woohoo, that shit compiled!
09:09:03 <yip> @seen dcoutts
09:09:03 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
09:09:11 <yip> @seen dcoutts__
09:09:11 <lambdabot> dcoutts__ is in #gentoo-haskell, #haskell, #haskell-blah, #haskell-overflow and #ghc. I last heard dcoutts__ speak 49m 49s ago.
09:09:19 <dons> ndm, not yet. i'll see if I can get it done tomorrow
09:09:47 * dons listens to newish portishead track and wonders why they can't get an album done
09:10:00 * ndm thinks we need a dons support mechanism
09:10:04 <dons> ah i know. same reason there's no hwn issue this week
09:10:04 <bartw> dons: which ?
09:10:15 <dons> requiem for anna
09:10:17 <ndm> i live just near portishead, people are always stealing the road signs
09:10:22 <dons> heh
09:10:32 <bartw> dons: where can i get that ?
09:10:52 <dons> google's blog search  page, search for 'requiem for anna' mp3
09:11:13 <ndm> bartw: iTunes, allofmp3, shareaza - usually :)
09:11:14 <dons> also, they've a (wacky) blog on myspace, portisheadalbum3
09:12:03 <AstralStorm> dons: I know - fixed it :P
09:12:40 <bartw> last year they said they would release somethign this year, i'd buy it
09:12:50 <dons> me too.
09:13:02 <dons> been waiting what 8 years?
09:13:04 <dons> ah well
09:13:32 <dons> bartw, did you find the file?
09:13:36 <SamB> hmm
09:14:01 <bartw> browsing around a bit still
09:14:25 <dons> if you can handle the weird wait and popups, http://d.turboupload.com/d/892522/Portishead_-_Requiem_For_Anna.mp3.html
09:14:28 <lambdabot> Title: TurboUpload - Portishead - Requiem For Anna.mp3, http://tinyurl.com/kz5bh
09:14:39 <yip> *** Exception: user error (initGUI: Gtk2Hs does not currently support the threaded RTS
09:14:39 <yip> see http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
09:14:39 <yip> Please relink your program without using the '-threaded' flag.)
09:14:41 <lambdabot> Title: Gtk2Hs  Blog Archive  Writing multi-threaded GUIs, http://tinyurl.com/j7dxw
09:14:57 <ndm> yip: don't pass -threaded when you compile
09:15:25 <SamB> AstralStorm: huh, I had no idea GCC did this much optimization of tail recursion...
09:16:15 <yip> ndm: i don't, i get this error when i try to use runhaskell
09:16:33 <yip> ndm: or when i try to use ghci
09:16:35 <SamB> though it looks kind of stupid to have the same two instructions repeated about 500 times
09:16:46 <ndm> yip: what is your command line for compilation?
09:17:17 <SamB> they should have cbbe
09:17:30 <flux__> hmm.. is it difficult to write interface with a haskell-library from some other language?
09:17:35 <SamB> or maybe I mean cbb
09:18:03 <SamB> flux__: you export them to C from Haskell, usually...
09:18:25 <yip> ndm: i'm not compiling, i am trying to run straight under "runhaskell" or ghci
09:18:34 <yip> ndm: i used to be able to do this with ghc 6.4
09:18:43 <yip> ndm: but now i'm using ghc 6.6 and it doesn't work anymore :(
09:18:47 <ndm> yip: but you don't get this error with runhaskell or ghci
09:18:54 <ndm> how do you compile it with GHC ?
09:19:03 <ndm> its a new feature of gtk2hs
09:19:03 <yip> i do get the error with runhaskell and i do get the error with ghci
09:19:10 <yip> i don't get the error if i compile with ghc
09:19:16 <ndm> ah, with 6.6 yes, but not with 6.4?
09:19:25 <yip> with 6.4 i never got this error
09:19:25 <ndm> i guess then 6.6 turned on threading in GHCi
09:19:30 <ndm> solution: touch luck
09:19:55 <ndm> * tough
09:20:03 <ndm> ping dcoutts__
09:20:49 <SamB> AstralStorm: does this not work if I do tailcalls to the same function or something?
09:23:35 <lisppaste2> mux pasted "Figlet module for lambdabot" at http://paste.lisp.org/display/26164
09:26:34 <glguy> dons: in case you wondered, the latest source snapshot of GHC fails on my computer
09:26:37 <glguy> (ghci)
09:30:08 <apfelmus> int-e: ping
09:30:17 <int-e> pong
09:31:38 <apfelmus> int-e: nice to meet you! i got a separation between structure and values implemented. where's the pasteplace?
09:31:50 <int-e> @paste
09:31:50 <lambdabot> http://paste.lisp.org/new/haskell
09:32:38 <ndm> SamB: so does it seem GCC has good tail call support then?
09:32:57 <lisppaste2> apfelmus pasted "SplitSeq with blueprint and data separated" at http://paste.lisp.org/display/26166
09:33:16 <ndm> i still might have to use labels, since i do indirect tail calls, which i doubt GCC optimises (might not even be possible...)
09:33:29 <SamB> indirect?
09:33:42 <ndm> call a function indirectly, via a function pointer
09:33:47 <SamB> oh right
09:33:51 <SamB> it shouldn't matter
09:33:58 <ndm> i would have thought it would...
09:34:09 <SamB> it would prevent some stuff
09:34:09 <apfelmus> int-e: though it is not as useful as i expected :)
09:34:55 <SamB> you aren't going to make a habbit of gratuitous indirect calling I hope?
09:34:57 <apfelmus> int-e: and i use a tab width of 4 spaces :-/
09:36:12 <int-e> apfelmus: I'm playing around with this: http://paste.lisp.org/display/26161
09:36:23 <SamB> well, it definately ain't linear in the number of calls in a single function, when you compile with GCC 3.3 and pass it -O and -foptimize-sibling-calls
09:40:25 <int-e> apfelmus: hmm, separating structure and values is an interesting abstraction, but probably quite unefficient in practice.
09:40:28 <SamB> well, heres what I have so far: http://naesten.dyndns.org:8080/gcc_tailbench/
09:40:30 <lambdabot> Title: Directory listing for /gcc_tailbench/
09:42:55 <apfelmus> int-e: with -O2, perftest () runs in ~ 1s, so it works at least.
09:42:56 <apfelmus> but i realized that just inverting the pattern match is *much* more convenient than the Left/Right boilerplate :)
09:44:47 <apfelmus> although it's straightforward to code: on the lhs one writes where a value is in the old pattern and on the right hand side one fiddles out where it is found in the new structure.
09:45:05 <SamB> @tell ndm heres what I have so far: http://naesten.dyndns.org:8080/gcc_tailbench/
09:45:05 <lambdabot> Consider it noted.
09:45:38 <apfelmus> int-e: so the 'direction of data flow' is preserved
09:46:52 <SamB> AstralStorm: so, what bug number is that tailcall issue?
09:50:13 <apfelmus> int-e: the main problem is that the function is not memoized for different parameters. so reading the contents of a second channel duplicates all the restructuring work of (MapPath -> a).
09:59:49 <AstralStorm> SamB: uh... don't know anymore
10:00:04 <AstralStorm> Search yourself.
10:00:05 <SamB> any tips for finding it in bugzilla?
10:13:48 <apfelmus> int-e: Inv is more powerful than the interface offers because the "standard" invertible arrow would be newtype StdInv = StdInv (a->b, b->a). there is clearly an injection StdInv -> Inv, but the other way round? i wonder wether the defining property could give one
10:14:31 * SamB wonders where maxima went
10:15:12 <int-e> apfelmus: hmm, invertible arrows aren't too nice either. look at http://paste.lisp.org/display/26167
10:15:12 <apfelmus> @djinn (a->b,b->a) -> (a -> b -> (b,a))
10:15:13 <lambdabot> f (a, b) c d = (d, b (a c))
10:16:09 <int-e> @djinn (a -> b -> (b,a)) -> (a->b,b->a)
10:16:10 <lambdabot> -- f cannot be realized.
10:16:21 <int-e> that's the point. I need the additional power :)
10:17:05 <apfelmus> int-e: but there is no way to tell djinn about the defining property
10:17:22 <int-e> apfelmus: djinn works nicely for invertible functions ;)
10:17:32 <int-e> apfelmus: well, many of them
10:17:41 <int-e> @djinn (a, a) -> (a, a)
10:17:41 <lambdabot> f a = a
10:20:33 <Tela> I have a newbie question about type classes. Is there a way to define a class that just minimally extends show -- such that it defaults to show if there isn't a defined instance and everything already in show is automatically instantiated into it?
10:21:51 <apfelmus> int-e: huh? f = id is easy but how do you incorporate the defining property?
10:21:51 <apfelmus> @djinn (a,b) -> (a,b)
10:21:52 <lambdabot> f a = a
10:22:11 <int-e> @djinn (a,b) -> (b,a)
10:22:12 <lambdabot> f (a, b) = (b, a)
10:22:44 <int-e> @djinn Either (a, c) (b, c) -> (Either a b, c)
10:22:44 <lambdabot> f a =
10:22:44 <lambdabot>   case a of
10:22:44 <lambdabot>   Left (b, c) -> (Left b, c)
10:22:44 <lambdabot>   Right (d, e) -> (Right d, e)
10:22:56 <SamB> Tela: you are trying to break my head, aren't you!
10:23:09 <Tela> Heh. Let me describe more specifically :)
10:23:21 <apfelmus> > let f (a, b) = (b, a); (a',b') = f('a',a') in b'
10:23:26 <lambdabot>  'a'
10:23:36 <Cale> Tela: not without GHC extensions
10:23:41 <SamB> Tela: I think I get the idea but when I try to think how it could be done without all kinds of nastyness...
10:23:48 <Tela> I want to make a Disp class, which gives me a human readable string and extends the Show class. This way show and read can remain inverses and I can print to the user easily.
10:25:10 <Tela> Hmm. I'm fine with using GHC extensions though I'm not totally familiar with them. What're the options there? :)
10:25:19 <SamB> also, even if it could be done it wouldn't necessarily work too well if there are intervening non-Disp-aware datastructures...
10:25:44 <Cale> actually, I think that doing it will not get you quite what you want
10:25:48 <SamB> and those extensions confuse me...
10:26:08 <Cale> You need -fallow-overlapping-instances and -fallow-undecidable-instances
10:26:11 <Tela> Hmm... I'm willing to default to show for anything that doesn't know about disp.
10:26:18 <Cale> okay
10:26:25 <Cale> That's what you'll get :)
10:26:33 <Cale> lisppaste2: url
10:26:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:26:35 <SamB> it might not do what you were expecting!
10:26:47 <Tela> Hmm.
10:26:53 <xerox> SamB: he's expecting it to act unespectedly.
10:26:59 <SamB> heh
10:27:04 <SamB> I said might not
10:27:09 <SamB> so I'm covered either way ;-)
10:27:19 <xerox> This is #haskell, eh..
10:27:33 <Tela> Aye. Thanks for the disclaimer. If it explodes in my face, I'll just give it up and do things the harder way, heheh
10:27:33 <SamB> did you forget?
10:27:47 <SamB> Tela: it won't do that.
10:27:51 <SamB> it might just be ugly.
10:27:59 <SamB> that is, the output might be.
10:28:01 <xerox> Blame SamB if it actually explodes!!
10:28:06 <Tela> I will!
10:28:09 <lisppaste2> Cale pasted "disp" at http://paste.lisp.org/display/26168
10:28:18 <SamB> I will blame the OS and/or hardware!
10:28:35 <Cale> actually, no, you do get the more specific Disp instance
10:29:04 <Tela> Hmm. Then this blamechain will go directly to Jobs. I think he'll be used to it
10:29:07 <SamB> just gotta be careful to make sure the instances you want are known in every module you want them in...
10:29:17 <xerox> Cale: if you get the more specific, it's quite good.
10:29:28 <Cale> xerox: yeah, but I wouldn't count on it :)
10:29:44 <Cale> This sort of thing really scares me :)
10:30:06 <Cale> Tela: what problem is it that you're trying to solve?
10:30:07 <xerox> :D
10:30:19 <xerox> Extra olegs of pure fun.
10:30:20 <SamB> Cale: human readable output without doing much work
10:30:32 <Cale> human readable output?
10:30:37 <Tela> Yeah, ditto SamB
10:30:46 <Tela> I want to maintain show and read so that they're invertible
10:30:52 <Tela> But throw something nicer at the user
10:30:55 <lightstep> use Typable, and compare the type to String. that's safer (works with polymorphism)
10:31:01 <Cale> Is it that you want disp to show strings without quoting them?
10:31:19 <Tela> No, more complex than that
10:31:42 <SamB> why isn't it invertable?
10:31:44 <Tela> I have a datum with slot values. I want it to be interpreted into a nicely readable string
10:31:45 <Cale> That case, I find that to be unnecessary, since you almost always know when something is a string
10:32:06 <Cale> Show/Read aren't perfectly invertible anyway
10:32:19 <SamB> half-invertible!
10:32:26 <SamB> the half that really matters!
10:32:30 <gmh33__> what's the logical "or" statement in haskell?
10:32:35 <SamB> for *most* types
10:32:41 <gmh33__> || ?
10:32:44 <Cale> ||
10:32:46 <SamB> yah
10:32:51 <Cale> xor is /=
10:33:12 <gmh33__> I though /= was 'not equal'
10:33:22 <xerox> Which is equivalent to xor
10:33:25 <SamB> hehe
10:33:28 <gmh33__> I suppose
10:33:48 <xerox> > [x /= y | x <- [True,False], y <- [True,False]
10:33:48 <lambdabot>  Parse error
10:33:57 <xerox> Hrmpf.
10:34:01 <xerox> > [x /= y | x <- [True,False], y <- [True,False]]
10:34:02 <gmh33__> you're missing a ]
10:34:02 <lambdabot>  [False,True,True,False]
10:34:34 <Cale> A special xor operator is only required in languages with no specific boolean type.
10:34:50 <SamB> what about...
10:34:53 <SamB> @type xor
10:34:53 <Cale> (or in those with no polymorphic not equal to :)
10:34:54 <lambdabot> forall a. (Bits a) => a -> a -> a
10:34:59 <xerox> > [Data.Bits.xor x y | x <- [0,1], y <- [0,1]] :: [Int]
10:35:00 <lambdabot>  [0,1,1,0]
10:35:12 <SamB> of course, that is a *bitwise* xor operator ;-)
10:35:56 <Cale> and [True, True, False]
10:35:57 <Cale> > and [True, True, False]
10:35:58 <lambdabot>  False
10:36:02 <Cale> > or [True, True, False]
10:36:03 <lambdabot>  True
10:36:32 <Cale> and = foldr (&&) True; or = foldr (||) False
10:36:34 <SamB> hmm, it is confusing that the CMUCL compiler is called Python...
10:36:46 <Cale> SamB: really?
10:36:49 <xerox> o_O
10:36:53 <SamB> it really is
10:37:09 <Tela> Bring it up to them and they'll immediately remind you it's been out for a million years before Python-the-language
10:37:33 <Cale> I used CMUCL for a while, and never noticed that
10:37:51 <SamB> I'm not blaming anyone
10:38:21 <SamB> I'm just saying that it might be confusing if you were trying to talk about CMUCL and Python at the same time
10:40:02 * SamB wonders what this is about:
10:40:09 <SamB> ;   (SIN OMX)
10:40:09 <SamB> ; Note: Unable to avoid inline argument range check
10:40:09 <SamB> ; because the argument range (DOUBLE-FLOAT) was not within 2^64
10:40:48 <Cale> SamB: it's an efficiency warning
10:41:05 <SamB> yes, I understand that much
10:41:30 <SamB> ... but ought not the argument of SIN to be a floating point number?
10:43:05 <Cale> actually, it can take any sort of number
10:43:12 <SamB> hmm
10:43:22 * SamB just doesn't see why anyone would pass in a bignum
10:43:35 <Cale> because they can?
10:43:51 <SamB> I suppose...
10:44:05 <SamB> ah, the wonders of dynamic typing...
10:44:43 <SamB> I suppose the range check should be trivial in the case of non-bignums...
10:45:23 <lightstep> actually, you won't care about range check is you're sume the arguments is a flonum for x fixnum
10:45:31 <lightstep> s/for x/or a/
10:45:51 <Cale> I love how the glossary has things like  non-simple adj. not simple.
10:46:05 <Cale> (In the CL hyperspec)
10:46:16 <SamB> I suppose, since this is maxima, it is possible that somehow a bignum *would* get passed in...
10:47:41 <Cale> http://www.lisp.org/HyperSpec/Body/sec_1-1.html -- this page is awesome :)
10:47:41 * SamB starts slime up in order to find out more about range checks
10:47:43 <lambdabot> Title: CLHS: Section 1.1, http://tinyurl.com/zx984
10:48:22 <Cale> Especially when you consider that 1.1.1 is a single short paragraph.
10:50:03 <heatsink> They should have put that on two pages.  The first sentence is clearly the purpose, and the second sentence is just as clearly the scope.
10:53:11 <xerox> Cale: but `simple' seem to have a well-defined meaning: ``simple adj. 1. (of an array) being of type simple-array. 2. (of a character) having no implementation-defined attributes, or else having implementation-defined attributes each of which has the null value for that attribute.''
10:55:01 <Tela> The third sentence is a disclaimer. It should have its own page as well.
10:57:57 <apfelmus> int-e: why do you have decodeMap and encodeMap? i'd guess  invert decodeMap = encodeMap
10:58:32 <int-e> apfelmus: yes, that's true. but they're both one line functions.
10:59:26 <int-e> apfelmus: I added an annotation
10:59:36 <apfelmus> int-e: with :: InvArrow a => a b c -> a c c -> a b b
10:59:36 <apfelmus> with f g = f >>> g >>> invert f
11:00:02 <int-e> yes, I know
11:02:16 <glguy> That sounds like J's &. (under) function. given (+/ % #) is artithmetic mean, (+/ % #) &. % is geometric mean (mean under reciporcal)
11:04:52 <therp> samb: It is a rumor among the CL community that CMUCL's naming for it's compiler is much older than the programming lanuage.
11:06:54 <int-e> apfelmus: join #haskell-overflow. it's a bit quieter there
11:07:36 <Cale> glguy: are you sure it's not the harmonic mean?
11:08:19 <glguy> yeah, it is
11:08:21 <Cale> The geometric mean is the nth root of the product
11:08:27 <glguy> right
11:09:29 * SamB wonders if there is a way to start SLIME from the CL side
11:10:05 <Tela> You can start the Swank server-thing from CL
11:10:06 <xerox> You start swank on the CL side
11:10:43 <int-e> xerox: oh, regarding the bot, I think the karma only accepts xxx ++ at the beginning of the line now; the #perl6 bot has a revision number there.
11:10:48 <therp> cale: well, the hyperspec is the automatic conversion of the original tex documents of dpANS3. usually the dpANS3 contains so much information on its subsubsection that its justified to put it on a separate page. in this case it's not of course.
11:11:30 <Cale> therp: I figured it was being autogenerated somehow.
11:12:48 <glguy> No one ever answered my question though (c: is what I was talking about in J similar to that InvArrow example?
11:17:25 <bartw> what encoding is default for haskell characters and strings ?
11:17:27 <bartw> unicode ?
11:18:48 <monochrom> probably iso-latin-1 for the moment.  will change.
11:19:18 <heatsink> > fromEnum (maxBound :: Char)
11:19:19 <lambdabot>  1114111
11:19:41 * heatsink wonders why
11:19:41 <bartw> heatsink : unicode then
11:19:57 <astrolabe> I'd have guess ascii
11:20:43 <bartw> 1114111 is a prime too
11:21:34 <bartw> a prime number of unicode chars, now that won't be an accident :)
11:24:25 <astrolabe> http://www.haskell.org/onlinereport/char.html
11:24:26 <lambdabot> Title: The Haskell 98 Library Report: Character Utilities
11:24:54 <astrolabe> Perhaps no encoding is specified.
11:27:10 <heatsink> the bit pattern of 1114111 looks suspiciously unicodeish.
11:30:23 <bartw> that too, but ! for it being prime :)
11:31:04 <heatsink> but not? but strict? but bang?
11:31:05 <dottedmag> heatsink: 0x10FFFF
11:31:12 <Cale> > map (`mod` 2) .takeWhile (/= 0) . iterate (`div` 2) $ 1114111
11:31:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1]
11:31:52 <mauke> > 2^24-1
11:31:53 <lambdabot>  16777215
11:32:02 <ski> > showHex 1114111 ""
11:32:03 <lambdabot>  "10ffff"
11:32:24 <bartw> 17 * 2^16 -1
11:32:34 <ski> welcome
11:33:04 <bartw> what i don't get is why did thgey limit themselves to that, why not go to 31 bit or somethign, 640kb should be neough for anyone ?
11:33:33 <Lemmih> @users
11:33:33 <lambdabot> Maximum users seen in #haskell: 236, currently: 236 (100.0%), active: 29 (12.3%)
11:33:40 <Lemmih> Woot.
11:33:56 <ski> hasn't theree been something like 250 at leaast, in the past ?
11:34:12 <heatsink> nift.
11:34:20 <Cale> ski: I think the data for the seen module got reset
11:34:22 <monochrom> Currently, if you putChar '\xe1' (that's ), you'll get the iso-latin-1 representation of  rather than the utf-8 representation of .  Work is done to produce utf-8 output.  Similarly getChar.  Internally, Haskell Char is unicode.
11:35:28 <bartw> ah so the language does the right thing, but milegae may vary because of the vm and shells ?
11:35:36 <bartw> eh no prob
11:39:45 <monochrom> Char does the right thing.  putChar and getChar should be configurable (there should be a global variable saying which encoding to assume, and it doesn't have to be utf-8), but currently ghc hardwires to iso-latin-1 for putChar and getChar.
11:42:04 <monochrom> However, someone has written routines to read and write utf-8 and put it in some library.
11:42:11 <monochrom> I forgot which library.
11:43:20 <glguy> When using .lhs files and LaTeX, you have to use "\begin{code}" and "\end{code}" blocks instead of ">", right?
11:43:21 <xerox> @google UTF8.hs
11:43:23 <lambdabot> http://repetae.net/john/repos/jhc/UTF8.hs
11:43:36 <xerox> (Just guessing.)
11:43:38 <bartw> it is not a requirement for me
11:43:45 <bartw> but i prefer to be unicode clean
11:43:49 <Cale> glguy: yeah
11:44:48 <monochrom> If you want to use .lhs files and XHTML, I have written a routine to recognize ">" but not "\begin/end{code}". :)
11:46:26 <glguy> interesting :)
11:46:32 <glguy> is it on the wiki?
11:47:09 <monochrom> http://www.vex.net/~trebla/haskell/xlhs.xhtml
11:49:11 <xerox> monochrom: Safari gives to me the message ``This page contains the following errors: error on line 56 at column 378: Entity 'nbsp' not defined, error on line 102 at column 522: Entity 'nbsp' not defined, error on line 106 at column 589: Entity 'nbsp' not defined'' for that page.
11:50:10 <bartw> reading some tutorials, im supprised integer overflow doesn't throw an error
11:52:58 <monochrom> I am not sure that is my problem.  validator.w3.org is happy.
11:53:41 <xerox> Alright!
11:54:10 <monochrom> The web server correctly gives it the media type of application/xhtml+xml so that much is so-far-so-good.
11:57:31 <monochrom> The xmllint program (I run with xmllint --valid --noout xlhs.xhtml) is also happy.  It actually goes download the DTD and check, so it must be happy with &nbsp; too.
11:59:09 <monochrom> I hope it is just that XHTML 1.1 is not yet fully understood by all browsers.
12:02:33 <monochrom> Conjecture: Safari goes into pure XML mode, so &nbsp; is undefined a priori.  Now &nbsp; is actually defined by the DTD, but Safari, like most browsers, skips the DTD, and so misses the definition.
12:02:43 <AstralStorm> @djinn Maybe (Char, Int) -> Bool
12:02:43 <lambdabot> f a =
12:02:43 <lambdabot>   case a of
12:02:43 <lambdabot>   Nothing -> False
12:02:43 <lambdabot>   Just _ -> True
12:03:40 <bartw> how oes Just _ evaluate to a ?
12:04:02 <mauke> bartw: huh?
12:04:06 <monochrom> Just _ doesn't evaluate to a.
12:04:29 <heatsink> @djinn Ordering -> Maybe a
12:04:29 <lambdabot> f _ = Nothing
12:04:38 <heatsink> @djinn Maybe a -> Ordering
12:04:38 <lambdabot> -- f cannot be realized.
12:05:44 <AstralStorm> You can replace the last with e.g. Just (a,b) -> do something with a, maybe even b
12:07:16 <bartw> ah right _ is used the same as in prolog then ?
12:07:31 <AstralStorm> It's a wildcard.
12:07:52 <bartw> right, get it
12:08:51 <AstralStorm> Ok, I've got most basic building blocks of an indentation detector ready.
12:09:07 <AstralStorm> Now I have to assign probabilities of certain tabulation system.
12:09:20 <AstralStorm> (much like Emacs' indentation detector)
12:12:12 <Tela> Huh. Is there any convenient way to write a function updateCD, which takes a CD type with slot values and returns a new CD with one of the slots changed?
12:12:31 <Tela> Something like... updateCD :: CD -> (CD -> a) -> a -> CD
12:12:43 <xerox> Yeah.  Using records.
12:13:42 <lispy> Cale: that spec is a nightmare, IMHO
12:14:03 <Tela> xerox: Mmm... Records? :)
12:14:14 <monochrom> Record >> CD
12:14:26 <xerox> data CD = CD { artist :: String, title :: String, tracks :: [Track] }
12:14:26 <xerox> Then you can define |updateArtist name cd = cd { artist = name }|.
12:14:30 * monochrom turns on his phonograph
12:14:42 <xerox> @slap monochrom
12:14:42 * lambdabot smacks monochrom about with a large trout
12:14:50 <monochrom> haha
12:14:55 <lispy> CDCase >>= Player >>= Ear
12:15:23 <xerox> @docs
12:15:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:16:10 <xerox> Hm, nothing there...
12:16:32 <Tela> would that work generically though, viz. updateCD f name cd = cd {f = name}
12:16:47 <xerox> @oldwiki UsingRecords
12:16:47 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
12:17:00 <xerox> Nope, you can't do that, unfortunately.
12:17:30 <Tela> Hm. Alright, I'll play around a little then :)
12:18:15 <bartw> im starting to understand the functions list comprehensions and pattern matching a bit, what i don't get is how you use complex data structures
12:19:11 <xerox> bartw: UsingRecords might be nice to read for you too then :)
12:19:17 <bartw> do i need to pass the 'whole world' around if i want to have some long livin shared datastructures
12:19:27 <mux> ?seen dons
12:19:27 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 2h 57m 55s ago.
12:20:51 <zarvok> so who went to the GHC hackathon and how was it?  I'm super jealous
12:21:48 <glguy> for serious?
12:22:21 <zarvok> which part?  I've been absent from the channel for a few days while I try to be productive before I fly to portland tomorrow
12:22:38 <Cale> bartw: yes, basically, but there are structures like the State monad which make it easier
12:23:07 <Cale> bartw: If it's particularly large and parts of it need separate mutation, there's the ST monad
12:23:36 <Cale> (or just plain IO, but then you lose the ability to turn the thing into an ordinary function on data)
12:28:41 <bartw> i'm wondering, anyone using a haskell irc client or editor ?
12:31:02 <AstralStorm> Hey guys. Any better way to constantly read stdin than this? http://wklej.org/id/da97ab6151
12:31:46 <AstralStorm> huh "word
12:31:57 <AstralStorm> Should be called more like "item"
12:32:06 <heatsink> AstralStorm, hGetContents
12:32:32 <AstralStorm> heatsink: will that finish correctly on EOF?
12:32:37 <heatsink> yea
12:32:45 <AstralStorm> Is that lazy too
12:32:47 <AstralStorm> ?
12:33:00 <heatsink> it is lazy.
12:33:23 <glguy> The internet is not a truck you can just dump stuff on!
12:33:24 <AstralStorm> An I recon it returns a list of strings?
12:33:31 <heatsink> It returns a string.
12:33:39 <AstralStorm> Uh, so bad for me.
12:33:42 <heatsink> It also closes the file when it reaches EOF.
12:33:45 <AstralStorm> I need a list of lines.
12:34:03 <heatsink> liftM lines hGetContents
12:34:09 <AstralStorm> Ah right.
12:34:10 <AstralStorm> :>
12:34:16 <heatsink> (:
12:34:28 <AstralStorm> Why I always forget about liftM...
12:34:50 <bartw> because teh name doesn't speak it purpose ?
12:34:57 <edwardk> hey, who is in portland already =)
12:35:00 <AstralStorm> Probably.
12:35:02 <glguy> if you forget about liftM, you could just: do { xs <- hGetContens; let ys = lines xs }
12:35:17 <edwardk> er ? on the end of that =)
12:35:41 <glguy> and of course you'd have to have an argument on hGetContents
12:36:04 <AstralStorm> Hmm. Let's see what I get then.
12:37:15 <bartw> it returns somethign weird
12:37:54 <bartw> ehmz, no thats just me i guess
12:39:13 <AstralStorm> I think that liftM will become remembered with practice.
12:42:10 <hyrax42> @type hGetContents
12:42:11 <lambdabot> Not in scope: `hGetContents'
12:42:31 <hyrax42> @type IO.hGetContents
12:42:32 <edwardk> gah, liftM = map = fmap, with different motivations. they should have just made Monad an instance of functor and forgotten about it ;) namby pamby newbies wanting a list specific function ;)
12:42:32 <lambdabot> GHC.IOBase.Handle -> IO String
12:42:50 <edwardk> er made Monad subclass functor
12:43:02 <edwardk> then we would just have one of those instead of three names for the same thing
12:44:22 <astrolabe> edwardk: It is hard to see why they didn't
12:45:10 <astrolabe> Also why they dropped comprehensions for general monads.
12:45:32 <Philippa> because the error messages were awful, especially in the list case
12:46:31 <edwardk> bah
12:46:38 <edwardk> who needs usable error messages for newbies =)
12:46:47 <SamB> how about for oldbies?
12:46:52 <astrolabe> At the moment GHC tells you that there was an error in a list comprehension.  Why can't that be generalised?
12:47:09 <SamB> um, the type errors?
12:47:43 * xerox pokes astrolabe 
12:47:51 <edwardk> bah =)
12:47:56 <edwardk> who needs types =)
12:48:05 * astrolabe has armor plating, and is made of brass anyway.
12:48:24 <Philippa> the generalisation can be done, yes. It's not particularly readable until you really understand everything well though
12:48:42 <Philippa> you have to teach monad comprehensions as a whole because if you just teach list comprehensions then the errors don't make sense
12:49:05 <astrolabe> Do you mean compile time errors?
12:49:15 <edwardk> so no love for adding a -fmonad-comprehensions? =)
12:49:22 * glguy would love it
12:49:43 <glguy> newbs could always use that Mercury, or whatever the teaching language was
12:49:46 <glguy> if Haskell was too hard
12:50:06 <AstralStorm> Blah, and newbs which want to use Haskell? :P
12:50:07 <glguy> or there could be a -fnewb flag (c:
12:50:29 <heatsink> ffaHAHAHA
12:50:34 <edwardk> heh, didn't they call that Helium? =)
12:50:39 <glguy> yeah, that's it
12:50:42 <AstralStorm> glguy: a flag nobody would ever set?
12:51:03 <glguy> AstralStorm: there would be a stigma associated with not learning hte material... people would be encouraged t olearn quickly
12:51:14 <glguy> so that they would write haskell and not use the training wheels flag
12:51:40 <AstralStorm> ]:->
12:52:00 <glguy> even ViM has an easy mode
12:52:00 <edwardk> -ftraining-wheels
12:52:02 <edwardk> i like it
12:52:30 <AstralStorm> -fim-a-newb-and-im-proud-of-it :P
12:53:42 <glguy> I'm not critisizing people that wouldn't understand Monad comprehensions, I just don't like the idea of limiting the language because it might be a little bit harder to learn, and not for a technical reason
12:54:10 <glguy> If there was a reason like "Monad comprehensions cause the compiler to cry"
12:54:20 <glguy> I'd be more likely to understand the concern
12:54:52 <SamB> its more like "Monad comprehensions with type errors cause the compiler to cry incomprehensibly"
12:54:54 <int-e> glguy: Monad comprehensions cause all list comprehensions to be polymorphic and make the compiler cry.
12:55:04 <int-e> ;)
12:55:08 <SamB> oh, and that too
12:55:31 <SamB> compiler doesn't much like ambiguous types
12:56:45 <AstralStorm> Monad is not ambiguous with non-monad, usually...
12:58:03 <astrolabe> Is that amiguity really a problem?
12:58:19 <astrolabe> I find it hard to imagine writing ambiguous code.
12:58:21 <heatsink> Can the defaulting system be used to default to list type?
12:58:31 <glguy> int-e: monad comprehensions are just another way of writing do-notation... so the same logic could be applied ot remove do-notation
12:58:33 <int-e> astrolabe: have you ever coded with arrays in ST?
12:58:46 <glguy> right?
12:58:51 <astrolabe> int-e I don't think so :o
12:59:14 <astrolabe> But we are talking newbies?
12:59:19 <int-e> astrolabe: I see, you should try it so you can understand the outcry of frustration of having too polymorphic types
12:59:48 <SamB> I once tried to write a collection framework
12:59:56 <SamB> I ran into that problem quite quickly ;-)
13:00:02 <astrolabe> can't you fix it with type signatures?
13:00:12 <SamB> ... that isn't much of a fix
13:00:17 <int-e> partly
13:00:17 <SamB> it is very awkward
13:00:29 <SamB> and in fact it can't always be done
13:00:35 <AstralStorm> True.
13:00:43 <int-e> in haskell 98, you can't, really. you need helpers like asTypeOf
13:00:47 <int-e> which is horrible.
13:00:56 <astrolabe> hmmmm
13:01:14 <int-e> (the problem here is the lack of scoped type variables)
13:01:24 <SamB> and anyway, its nicer to be able to just write code that the compiler can figure out the types for ;-)
13:02:01 <edwardk> St is a special case though, its got that nested forall that mucks with type inference, so you can hardly compare a monad comprehension to the ST case.
13:02:39 <glguy> int-e: do you agree that the same arguments against monad comprehensions could be made against do-notation?
13:02:49 <SamB> edwardk: what has ST to do with it?
13:03:05 <SamB> oh, int-e brought it up
13:03:09 <edwardk> I was replying
13:03:12 <int-e> I'm not strongly opposed to monad comrehensions, but lists are special enough to deserve their own syntax.
13:03:31 <int-e> And it's certainly bad to change it now.
13:03:42 <edwardk> heh, whereas I am sitting here trying to do everything I can to avoid special casing lists in my toy language =)
13:04:00 <int-e> Because however unlikely it seems, some code *will* break or at least run abysmally slow due to lack of specialization.
13:04:06 <edwardk> *nods*
13:04:07 <SamB> well, it turns ought that special cases for lists give wins all around
13:04:45 <glguy> join (xs :: [Int]) will compile down to concat xs, right?
13:04:53 <edwardk> well, the thing is the things that special case lists could be used on any type with a similar shape though.
13:04:54 <int-e> yes.
13:05:07 * SamB thinks that the [ ] around list comperehensions strongly imply that they are for lists alone
13:05:11 <glguy> at compile time, all the types are known
13:05:19 <int-e> but put [a | b <- c] in one module and use it in another and make sure the first function is complicated enough not to be inlined
13:05:19 <int-e> ...
13:05:26 <xerox> ?type join (undefined :: [Int])
13:05:27 <lambdabot>   Couldn't match `[a]' against `Int'
13:05:27 <lambdabot>    Expected type: [[a]]
13:05:30 <xerox> ;)
13:05:39 <SamB> edwardk: what do you mean?
13:05:44 <edwardk> samb: heh, well, I want to reclaim [] too =)
13:05:56 <int-e> top level type signatures are a good idea though so it's maybe not that much of a problem.
13:05:58 * int-e shrugs
13:06:08 <edwardk> well, most of the fusion techniques that work for list work because it has a pair of constructors, one of which chains back to itself.
13:06:17 <SamB> certainly it would be nice, if we had views, to at least look at generalizing some of the list sugar
13:06:29 <glguy> What are views?
13:06:33 <int-e> edwardk: don't call it Haskell and you have my blessing (not that you need it :o) )
13:06:39 <edwardk> int-e: hehehe
13:07:04 <astrolabe> views == opinions I expect
13:07:49 <AstralStorm> Laziness of Haskell is sometimes funny :>
13:07:53 <edwardk> int-e: well, i'm doing mostly an intermediate language at the moment, just keeping my eye open for things where haskell zigged instead of zagged and made a more irregular programming landscape.
13:09:34 <int-e> for regularity, sure, get rid of list comprehensions.
13:09:55 <int-e> on that level you probably have all the types already anyway so no information is lost.
13:09:58 <edwardk> I'm ok with multiple forms of surface sugar
13:10:17 <edwardk> well, once i have the intermediate language I want to see about building something over it =)
13:10:31 <xerox> > join . transpose $ let evens = map (+1) odds; odds = 1:map (+1) evens in [odds,evens]
13:10:37 <edwardk> I think haskell's penchant for surface syntax is great.
13:10:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:11:07 <edwardk> xerox: i'll save you some time...
13:11:12 <edwardk> > [1..]
13:11:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:11:15 <edwardk> =)
13:11:19 * xerox chuckles
13:11:30 <bartw> hehe
13:15:38 <AstralStorm> infinite + something = infinite :P
13:16:03 <yip> > id
13:16:04 <lambdabot>  Add a type signature
13:16:19 <yip> > (+)
13:16:20 <lambdabot>  Add a type signature
13:16:27 <AstralStorm> @type (+)
13:16:29 <lambdabot> forall a. (Num a) => a -> a -> a
13:16:47 <glguy> > (+) :: Int -> Int -> Int
13:16:48 <lambdabot>  <Int -> Int -> Int>
13:17:08 <AstralStorm> > (+)
13:17:09 <lambdabot>  Add a type signature
13:17:12 <AstralStorm> > L.(+)
13:17:13 <lambdabot>  Not in scope: data constructor `L'
13:17:18 <AstralStorm> Hmm...
13:17:26 <heatsink> (L.+)
13:17:34 <yip> > toUpper
13:17:35 <lambdabot>  <Char -> Char>
13:17:41 <AstralStorm> > (L.+)
13:17:42 <lambdabot>  Not in scope: `L.+'
13:17:51 <AstralStorm> heatsink: uh, noes
13:18:00 <yip> > let foo x = x + 1 in foo
13:18:01 <lambdabot>  Add a type signature
13:18:17 <heatsink> I don't think there's an L module.
13:18:19 <glguy> yip: what exactly are you trying to do?
13:18:23 <yip> > let foo x = x : ['a'] in foo
13:18:24 <lambdabot>  <Char -> [Char]>
13:18:32 <yip> discover lambdabot
13:18:43 <AstralStorm> yip: use /msg lambdabot for that
13:18:48 <AstralStorm> :-)
13:19:01 <heatsink> Yea, you should discover her in private.
13:19:09 <AstralStorm> @yarr
13:19:09 <lambdabot> Yo ho ho, and a bottle of rum!
13:19:22 <yip> @yow
13:19:22 <lambdabot> The appreciation of the average visual graphisticator alone is worth
13:19:23 <lambdabot> the whole suaveness and decadence which abounds!!
13:19:29 <AstralStorm> How appriopriate.
13:20:08 <AstralStorm> Is there a channel Dissiocated Press plugin for lambdabot?
13:20:17 <AstralStorm> *Dissociated
13:20:49 <mauke> AstralStorm: http://haskell.org/hawiki/MegaMonad
13:20:50 <lambdabot> Title: MegaMonad - The Haskell Wiki
13:23:19 <glguy> I need to learn how to refract my code
13:24:09 <AstralStorm> Phunny.
13:24:10 <int-e> poor code.
13:24:49 <AstralStorm> Is that just DP or is it some tree AI algorithm?
13:25:43 <AstralStorm> Looks like funny Elisa-like AI.
13:26:42 <LiquidEngineer> glguy?
13:26:49 <LiquidEngineer> glguy: refactor?
13:27:15 <glguy> LiquidEngineer: I'm way past simple refactoring!
13:27:27 <LiquidEngineer> Sorry. :)
13:27:34 <LiquidEngineer> I've never heard of refracting before
13:27:49 <glguy> I don't believe that it means anything (c:
13:28:15 <LiquidEngineer> then what are you trying to do?
13:28:28 <mauke> see http://megahal.alioth.debian.org/
13:28:30 <lambdabot> Title: MegaHAL
13:28:37 <glguy> I'm trying to make random comments in the channel to get the ghosts to come out..
13:29:21 <LiquidEngineer> MegaHAL! :)
13:32:00 <SamB> oooh
13:32:12 <SamB> I don't need -fglasgow-exts to get pattern guards?
13:32:21 <AstralStorm> Hmm, only 4-th order Markov chain? Too short for proper conversation probably :>
13:32:42 <AstralStorm> I'd pick 5-th or 6-th order - these are very successful in spam filtering.
13:32:53 <AstralStorm> (when combined with proper weighting)
13:35:52 <bartw> monads try to eat my brain
13:36:49 <glguy> Monads are why I get up in the morning
13:37:22 <glguy> (though I also wake up to turn the sun on)
13:38:49 <bartw> if io is so difficult why not go imperative for that part ;)
13:39:00 <SamB> bartw: um, we do!
13:39:09 <SamB> that is what monads are for!
13:40:20 <mauke> IO is simple; you don't even have to know about monads to understand it
13:40:20 <bartw> ah here i thought it was functional
13:40:22 <glguy> Monads give Haskell the finest first-class imperative programs ;)
13:40:53 <glguy> Monads are functional
13:41:00 <SamB> bartw: so it is!
13:41:06 <SamB> monads are for making it BOTH
13:41:27 <xerox> ...and a lot MORE
13:41:28 <profmakx> in a clean way
13:41:52 <bartw> so haskell is adding some implicit code for passing a copy of 'the world' after a getLine ?
13:42:30 <mauke> that's one way of looking at it
13:42:56 <SamB> no, it is explicit
13:43:14 <SamB> ... somewhere
13:43:19 <xerox> The famous wave/particle Monad duality.
13:43:41 <bartw> give me a minute, i still have to read about the 'do' thingy
13:43:44 <SamB> (but it doesn't bother to actually pass the world because that would be too much work)
13:43:58 <mauke> bartw: "do" provides syntactic sugar for calls to >>= and >>
13:44:05 <SamB> the world is very heavy, you know!
13:44:22 <bartw> :)
13:44:38 <bartw> why wouldn't a list do for io ?
13:44:48 <SamB> well.
13:44:51 <mauke> SamB: http://www.pbfcomics.com/?cid=PBF088AD-Punch_Bout.gif#157
13:44:53 <lambdabot> Title: The Perry Bible Fellowship, http://tinyurl.com/eg3l5
13:45:02 <SamB> once IO was done with two lists.
13:45:18 <SamB> one for incoming data and one for requests/output.
13:45:24 <SamB> however, it was too hard to use that...
13:45:25 <zarvok> mauke: haha, awesome
13:46:00 <xerox> :O
13:46:00 <SamB> (the type looked like main :: [Input] -> [Request], or something like that...)
13:56:59 <edwardk> bartw: they did originally.
13:57:17 <edwardk> bartw: then the io monad came along and code became much easier to write
14:05:01 <SamB> hmm, I didn't know you didn't need to implement ** or sqrt if you implement exp and log... guess it makes sense though
14:05:20 * SamB doesn't even try to implement the trig functions for ranges
14:07:49 <Cale> a^b = exp(b log a) by definition :)
14:08:25 <SamB> yeah
14:09:01 <SamB> I wonder if this thing actually works?
14:09:10 <SamB> anyway, it seems to...
14:09:31 <SamB> I don't so much like the way my Show instance works though...
14:09:39 <SamB> *Range> sqrt ((0.89+-0.01) / 4.9)
14:09:39 <SamB> 0.4261770996313046+-2.3943289401239243e-3
14:10:31 <norpan> interesting
14:11:43 <bartw> ehmz
14:11:52 <bartw> thats seems roundabound
14:12:13 <SamB> what does?
14:12:16 <SamB> starting with lists?
14:12:21 <SamB> and going to monads?
14:12:39 <bartw> no, defining sqrt from exp and lo
14:12:50 <SamB> oh, but I didn't have to!
14:13:07 <SamB> the sqrt and ** have default implementations
14:13:12 <bartw> SamB: is that the way haskell defines imaginary numbers ?
14:13:20 <LiquidEngineer> Damn.
14:13:28 <LiquidEngineer> I went into #scheme to get some help
14:13:32 <SamB> bartw: what do you mean?
14:13:45 <LiquidEngineer> now I'm in a holy war about how my use of CamelCase makes me evil and the anti-christ
14:13:58 <bartw> SamB: those 1+-2 numbers
14:14:02 <SamB> oh, no
14:14:04 <SamB> those are mine
14:14:07 <mauke> LiquidEngineer: it does
14:14:30 <mauke> the haskell naming conventions are seriously weird
14:14:31 <bartw> LiquidEngineer : lowerCamelCase maybe ?
14:15:09 <bartw> atleast haskell doesn't support identifiers with spaces in them
14:15:10 <SamB> the +- means 
14:15:18 <SamB> but I dunno how to type that
14:15:30 <bartw> an error indication ?
14:15:33 <SamB> and I don't think my GHC would parse it anyway
14:15:37 <SamB> pretty much, yeah
14:15:57 <bartw> defined as infix +- operator that constructos a custom type ? neato
14:16:26 <SamB> it isn't stored the way it looks
14:17:23 <SamB> 1+-2 would look like "Range -1 3" if I used a derived Show instance, but I wrote my own
14:17:34 <SamB> er.
14:17:39 <SamB> with parens around the -1
14:18:03 <SamB> probably my show instance is broken
14:18:05 <bartw> ehmz
14:18:13 <SamB> but I don't even have a Read instance so...
14:18:17 <LiquidEngineer> bartw: yes, lower.  It's what i use
14:18:31 <LiquidEngineer> and I don't even want to KNOW what the haskell naming conventions are
14:18:45 <bartw> they seem to be lowerCamelCase so far
14:18:56 <bartw> altough to mean abrvs for my taste
14:19:45 <SamB> well.
14:20:02 <SamB> like what abbreviations don't you like?
14:20:06 <LiquidEngineer> lowerCamelCase!  THank God!
14:20:10 <bartw> foldr'
14:20:21 <LiquidEngineer> So you guys won't be mean to me when I post my code in the pastebin
14:20:27 <SamB> oh, well, that stands for "alternate fold to the right"
14:20:46 <SamB> is there a foldr' function anyway?
14:20:50 <SamB> @type foldr'
14:20:51 <lambdabot> Not in scope: `foldr''
14:20:53 <bartw> IComeFromTheLandWhereIdentifiersLookLikeThis
14:20:59 <SamB> @hoogle foldr'
14:20:59 <lambdabot> No matches found
14:21:04 <SamB> bartw: what land is that?
14:21:14 <norpan> where_i_come_from_we_separate_our_words_by_spaces
14:21:17 <bartw> java/c#/delphi
14:21:21 <SamB> ah.
14:21:34 <bartw> atleast for the paycheck
14:21:52 <SamB> well. Haskell doesn't make you stick everything in classes. and you don't have to use the class names much outside of types anyway.
14:22:15 <bartw> ow but i don't dislike classes at all
14:22:33 <SamB> that, and Haskell classes are different.
14:22:49 <SamB> -- you don't name methods that way I hope?
14:23:10 <SamB> one of my favorite methods is the (+) method ;-)
14:23:37 <SamB> aka +
14:23:48 <bartw> you need to define it on the class OperatorAdd and it isn't reflexsive by default
14:23:51 <SamB> I also like the >>, >>=, and return methods ;-)
14:24:37 <ValarQ> seems we lost lilo :(
14:24:43 <SamB> and the language knows nothing about + being, uh, ...
14:24:47 <glguy> C# MethodNames PropertyNames localVariableNames ClassNames
14:24:52 * SamB looks in abstract algebra book
14:25:05 <bartw> glguy : yes but #C is horrible :)
14:25:17 <SamB> glguy: ick
14:25:35 <bartw> types Upper and the rest lowerCamelCase is my choise
14:25:47 <SamB> bartw: that is how it works in Haskell, pretty much, too
14:25:49 <glguy> Given the alternatives to C#, I'll stick with C# at work
14:27:08 <bartw> so, how often do people write map with a lambda to get somethign forstatement like ?
14:27:47 <SamB> I need a better abstract algebra book...
14:27:48 <LiquidEngineer> bart: agreed on the style prefs. :D
14:28:01 <magnus-> bartw: mapM_ you mean?
14:28:18 <bartw> magnus- : why the M_ ?
14:28:56 <int-e> flip mapM_ [1..10] $ \n -> do <something>
14:28:57 <magnus-> bartw: If you are in a monad, I think mapM_ is the closest thing to a for loop
14:29:09 <int-e> or, with recent ghc 6.5, forM_ [1..10] $ \n -> do ...
14:29:12 <glguy> the function that best emulates ``for'' seems like it would be unfoldr
14:29:48 <int-e> map, fold, unfold, scan, are all loops.
14:30:08 <bartw> yes this is perverse enough to be alot of fun ;)
14:30:56 <glguy> I say unfoldr because you can determine stopping cases during the looping like you can in for
14:31:11 <norpan> unfoldr is more like while
14:31:32 <norpan> or do you mean the c for
14:31:40 <glguy> the C for
14:31:57 <glguy> I didn't figure that bartw was linking of forM_
14:32:00 <SamB> bartw: I suppose there is an assumption that addition and so on are commutative, though it is not expressed in the language or anything
14:32:01 <glguy> (c:
14:33:09 * SamB goes back to using Haskell to make his physics homework harder
14:33:13 <glguy> a lot of the time when i was first learning Haskell, I would try to solve problems using a for-like construct, because that's how I would have done it in C++
14:33:35 <glguy> but now I usually find that there are better ways to express what I was previously doing with a for loop
14:33:40 <bartw> i saw a little project for another functional language, miranda, that had a function that returned a function that was the reverse of the function provided, anything liek that in haskell ?
14:34:05 <glguy> I think that goes back to the InvArrow class that people were talking about earlier
14:34:11 <glguy> but it is not widely used
14:34:25 <bartw> i rarely use a for loop in my imperative code, whiel loops however are very common with an iterator
14:34:47 <norpan> java 5 for loops rock
14:34:51 <glguy> I use tons of foreach in C#, very little for
14:35:20 <bartw> foreach is a much cleaner for loop luckily
14:35:27 <glguy> Lisp loops are the cadillac of loops (c:
14:35:53 <bartw> if recursion wasn't as expensive in imperative languages it wouldn't be frowned upon so much
14:36:15 <glguy> most languages handle tail recursion properly tho
14:36:21 <glguy> which is the main thing that you need
14:37:02 <bartw> writing your code so that i can use tail recursion is hard
14:37:29 <SamB> not in Haskell
14:37:34 <bartw> also often introduces additional meaningless parameters
14:37:40 <SamB> and usually you want to use a pre-written recursion anyway
14:37:41 <mauke> meh, gcc can do that for you
14:38:51 <glguy> What I have a problem with is the unnecessary 3-way mutal recursion that the consultant was using to do something that could have been done cleanly with a single loop
14:38:58 <glguy> mutual*
14:39:08 <glguy> (@ work)
14:39:36 <SamB> glguy: what kind of 3-way mutual recursion?
14:39:44 <SamB> and anyway, a decent compiler should rewrite that as a loop
14:39:50 <SamB> ;-P
14:39:54 <glguy> so?
14:40:06 <glguy> that doesn't mean that you should write unreadable code :-p
14:40:08 <SamB> (GHC, by the way, wasn't a decent compiler by that metric, last I heard)
14:40:17 <SamB> oh, well, if it was unreadable that is another story.
14:40:18 <Cale> actually, tail recursion isn't always the best thing in Haskell
14:40:25 <SamB> Cale: true
14:40:29 <Cale> foldl is often a lot worse than foldr
14:40:35 <edwardk> glguy: unfortunately outside of the functional programming community, not many languages are really tail-call-optimized and a lot of the scripting languages aren't tail recursive
14:40:36 <SamB> but it is great when you are doing something...
14:40:59 <yip> anyone know where to find that paper where they describe various issues with fruit?
14:41:15 <SamB> oh, you mean the widget system
14:41:25 <SamB> not the thing with *morphisms...
14:41:34 <glguy> Cale: foldl is bad, but is foldl' typically similar?
14:41:55 <Cale> glguy: foldl' has the problem that it breaks in the infinite case
14:42:06 <glguy> Sure
14:42:24 <Cale> It's good when you're computing something that's an atomic value
14:42:30 <glguy> but if you are doing something that can't work on infinite lists
14:42:31 <bartw> meh, finally i have same nice coroutine code, and now im in a laguage that does need it ;p
14:43:04 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
14:43:05 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:43:28 <int-e> bartw: isn't that great? :)
14:44:40 <bartw> Cale: thats seriously impresive
14:45:04 <bartw> > [0, 2 ...]
14:45:04 <lambdabot>  Parse error
14:45:08 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
14:45:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:45:09 <bartw> hmz
14:45:13 <int-e> two dots
14:45:13 <mauke> > [0, 2 ..]
14:45:14 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:45:15 <yip> guys, rob levin is dead
14:45:35 <Cale> > fix ((0:) . scanl (+) 1)
14:45:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:46:05 <glguy> > let f n xs = let (d:ds) = (delete n xs) in n : f (n + d) ds in take 10 $ f 1 [1..]
14:46:06 <lambdabot>  [1,3,7,12,18,26,35,45,56,69]
14:46:20 <edwardk> the attorney, the glassblower, or the freenode guy?
14:46:25 <mauke> ?index delete
14:46:25 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
14:46:34 <bartw> seeing that we're on freenode i guess teh latter
14:46:47 <int-e> > scanl1 (+) [1..]
14:46:48 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
14:47:02 <int-e> hmm.
14:47:13 <edwardk> heh
14:47:19 <AstralStorm> Hmm, any builtin function to reduce duplicates in a list to (item, count)?
14:47:30 <edwardk> i just googled the name and started trying to figure out who he was talking about in order ;)
14:47:51 <edwardk> > nub [1,2,2,3,4,2,1]
14:47:52 <lambdabot>  [1,2,3,4]
14:47:57 <AstralStorm> No no, that's not it.
14:48:00 <norpan> AstralStorm: that sounds like the first part of the "histogram" homework assignment :)
14:48:00 <edwardk> oh you want a count
14:48:01 <AstralStorm> I want the counts :>
14:48:03 <glguy> > liftM2 (,) length head $ group $ sort [1,2,4,2,1,3,2]
14:48:04 <lambdabot>  (4,[1,1])
14:48:04 <mauke> ?type map (liftM2 (,) head length) . group . sort
14:48:05 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
14:48:10 <AstralStorm> norpan: more or less :P
14:48:13 <mauke> hahahaha
14:48:14 <int-e> > [(length l, head l) | l <- group . sort $ [1,2,1,3]]
14:48:15 <lambdabot>  [(2,1),(1,2),(1,3)]
14:48:18 <glguy> > liftM (liftM2 (,) length head) $ group $ sort [1,2,4,2,1,3,2]
14:48:19 <lambdabot>  [(2,1),(3,2),(1,3),(1,4)]
14:48:21 <AstralStorm> Yes, I can do that :P
14:48:35 <AstralStorm> glguy: now that's ultra-terse :P
14:48:56 <glguy> I guess... int-e's looks a lot better tho :)
14:49:16 <mauke> > map (liftM2 (,) head length) . group . sort $ "where is your god now"
14:49:16 <lambdabot>  [(' ',4),('d',1),('e',2),('g',1),('h',1),('i',1),('n',1),('o',3),('r',2),('s...
14:49:17 <int-e> > map (length &&& head) . group . sort $ [1,2,4,2,1,3,2]
14:49:18 <lambdabot>  [(2,1),(3,2),(1,3),(1,4)]
14:49:19 <edwardk> > [(head l, length l) | l <- group . sort $ [1,2,1,3] ]
14:49:20 <lambdabot>  [(1,2),(2,1),(3,1)]
14:49:30 <AstralStorm> @type (&&&)
14:49:31 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:49:37 <AstralStorm> Uhhh... arrows.
14:49:42 <int-e> (->) is an arrow
14:50:05 <int-e> so read it at (b -> c) -> (b -> c') -> b -> (c, c') for this case
14:50:06 <mauke> ok, so (&&&) = liftM2 (,)
14:50:06 * xerox escapes before seeing irresistible arrow haskell golf
14:50:15 <edwardk> heheh
14:50:41 <AstralStorm> Blah, I'm not ready for such intense Haskell yet.
14:50:42 <AstralStorm> :P
14:50:44 <AstralStorm> Too newb.
14:51:05 <glguy> > (&&&) [1,2,3] [4,5,6]
14:51:06 <lambdabot>  Couldn't match `a b' against `[]'
14:51:20 <glguy> > liftM2 (,) [1,2,3] [4,5,6]
14:51:21 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:51:28 <mauke> @jinn (b -> c) -> (b -> c') -> b -> (c, c')
14:51:28 <lambdabot> f a b c = (a c, b c)
14:51:44 <bartw> i'm kind of lost in as to how you can keep your algo's to the same O(1) or O(n) order as the imperative variants in some cases
14:51:51 <glguy> there needs to be a ?golf for times like that
14:51:59 <glguy> so that lambdabot can score the responses ;)
14:52:09 <AstralStorm> Huh?
14:52:43 <AstralStorm> I like the list comprehension one best.
14:52:55 <bartw> how would you build a hashdictionary in haskell :)
14:53:02 <mauke> Data.Map
14:53:08 <AstralStorm> Exactly.
14:53:10 <mauke> it's not a hash, though
14:53:13 <edwardk> the arrow based solutions will grow on you with time =)
14:53:19 <AstralStorm> Or Data.HashTable?
14:53:41 <twanvl> test t = runFreshT $ interactLoop $ mkZipper (t, Hole)
14:53:44 <twanvl> oops
14:54:02 <edwardk> bartw: I also have one if you really want to use a hash in STM as well.
14:54:38 <mauke> > liftM (liftM (head &&& length)) group `liftM` sort $ "where is your god now"
14:54:39 <lambdabot>  [(' ',4),('d',1),('e',2),('g',1),('h',1),('i',1),('n',1),('o',3),('r',2),('s...
14:54:51 <edwardk> depends on the monad you want to work in. the problem is copying array assignments suck and are slow so there is no pure functional hash imp floating around.
14:55:14 <glguy> > (\xs -> do { x <- xs; return $ (do { f <- head; g <- length; return (f,g) }) x }) . group . sort $ "does this crazy thing work"
14:55:15 <lambdabot>  [(' ',4),('a',1),('c',1),('d',1),('e',1),('g',1),('h',2),('i',2),('k',1),('n...
14:55:23 <edwardk> thats a lot of lifting
14:56:00 <mauke> @redo liftM f x
14:56:00 <lambdabot> liftM f x
14:56:03 <mauke> aww
14:56:15 <AstralStorm> Except lifting won't work, because it's already a list :P
14:56:23 <AstralStorm> So map instead :P
14:56:23 <glguy> just think if we had Monad comprehensions: [(f,g) | f <- head, g <- length]
14:56:29 <edwardk> @. pl undo  (\xs -> do { x <- xs; return $ (do { f <- head; g <- length; return (f,g) }) x }) . group . sort $ "does this crazy thing work"
14:56:31 <lambdabot> ((`fmap` length) . (,) =<< head) `fmap` group (sort "does this crazy thing work")
14:56:41 <edwardk> > ((`fmap` length) . (,) =<< head) `fmap` group (sort "does this crazy thing work")
14:56:42 <lambdabot>  [(' ',4),('a',1),('c',1),('d',1),('e',1),('g',1),('h',2),('i',2),('k',1),('n...
14:56:53 <edwardk> hehehe
14:56:58 <AstralStorm> Almost.
14:56:59 <mauke> awesome, it uses fmap for .
14:57:05 <SamB> do f <- head; g <- length; return (f,g)
14:57:10 <SamB> @type do f <- head; g <- length; return (f,g)
14:57:11 <lambdabot> forall a. [a] -> (a, Int)
14:58:29 <SamB> (do f <- head; g <- length; return (f,g)) sort $ "where is your god now"
14:58:39 <SamB> > (do f <- head; g <- length; return (f,g)) sort $ "where is your god now"
14:58:39 <lambdabot>    Expecting a function type, but found `t_a1Pu'
14:58:40 <lambdabot>    Expected type: a -> ...
14:58:42 <SamB> hmm.
14:58:52 <SamB> I didn't write any types...
14:58:53 <AstralStorm> :P
14:58:57 <bartw> so, how do i put a type i efined into a class ?
14:58:59 <SamB> > (do f <- head; g <- length; return (f,g)) $ sort $ "where is your god now"
14:59:00 <lambdabot>  (' ',21)
14:59:55 * SamB don't get what it is supposed to do
15:00:02 <David_Feuer> hmm
15:00:03 <glguy> > map (sequence [ord . head,length]) $ group $ sort "does this crazy thing work"
15:00:04 <lambdabot>  [[32,4],[97,1],[99,1],[100,1],[101,1],[103,1],[104,2],[105,2],[107,1],[110,1...
15:00:45 <glguy> > map (sequence [return . head,show . length]) $ group $ sort "does this crazy thing work"
15:00:46 <lambdabot>  [[" ","4"],["a","1"],["c","1"],["d","1"],["e","1"],["g","1"],["h","2"],["i",...
15:01:03 <edwardk> glguy is getting bored now =)
15:01:09 <glguy> )-:
15:01:17 <AstralStorm> Give me something usable, explainable and less crazy please :>
15:01:35 <mauke> my first solution is totally simple
15:01:36 <glguy> int-e's list comprehension would probably be your best bet
15:01:58 <mauke> SamB: that's just liftM2 (,) head length
15:01:59 <bringert> bartw: instance MyClass MyType where ...
15:01:59 <AstralStorm> Except it's not a monad, but a list :P
15:02:11 <AstralStorm> So I can't liftM2 it
15:02:11 <mauke> huh? list is a monad
15:02:15 <SamB> mauke: true
15:02:25 <AstralStorm> Why then the compiler complain?
15:02:37 <mauke> besides, that liftM2 uses ((->) e), not []
15:02:38 <AstralStorm> *does complain
15:02:43 <yip> he saved our ass a few times from some mass floodings :(
15:02:45 <glguy> > let f xs = [(head x, length x) | x <- group $ sort xs] in f "does this crazy thing work"
15:02:46 <lambdabot>  [(' ',4),('a',1),('c',1),('d',1),('e',1),('g',1),('h',2),('i',2),('k',1),('n...
15:02:55 <mauke> AstralStorm: probably because you didn't import Control.Monad.Reader
15:02:58 <edwardk> AstralStorm: import Control.Monad.Reader into your code
15:03:01 <AstralStorm> Uh, blah :P
15:03:12 <glguy> crazy liftM2 solutions require import Control.Monad.Reader
15:03:17 <monochrom> What is the question?
15:03:24 <AstralStorm> I had Control.Monad, but not the .Reader. Thanks! :P
15:04:06 * glguy want monad comprehensions for : [(f,g) | f <- head, g <- length] )-:
15:04:12 <glguy> wants*
15:04:14 <SamB> > (liftM2 (,) head length) $ group $ sort $ "where is your god now"
15:04:15 <lambdabot>  ("    ",13)
15:04:21 <SamB> hmm
15:04:24 <glguy> SamB: missing the map
15:04:26 <AstralStorm> Broken.
15:04:27 <SamB> ah
15:04:30 <glguy> s/^/map
15:04:32 <SamB> > map (liftM2 (,) head length) $ group $ sort $ "where is your god now"
15:04:33 <lambdabot>  [(' ',4),('d',1),('e',2),('g',1),('h',1),('i',1),('n',1),('o',3),('r',2),('s...
15:05:00 <bartw> add a little sort on the count for flavoring and your done :)
15:05:18 <mauke> SamB: good, now replace the intermediate $'s by ., then replace map and . by liftM
15:05:34 <glguy> > let comparing f a b = f a `compare` f b in sortBy (comparing snd)
15:05:34 <lambdabot>  Add a type signature
15:05:35 <SamB> mauke: and make it ... longer?
15:05:40 <glguy> adding the > was dumb :)
15:05:42 <mauke> no, more lifty
15:05:54 <SamB> oh.
15:05:58 <glguy> and then replace the . by `fmap`
15:06:00 <glguy> ;)
15:06:04 <edwardk> heh
15:06:09 <mauke> liftM is more lifty than fmap!
15:06:32 <glguy> ah, ok
15:06:42 <SamB> bartw: sometimes we need to cheat to get the same O(f(n)) as the imperative peoples.
15:06:42 <edwardk> and people wonder why i think map, fmap, and liftM should be forcibly merged into one thing and the other concepts purged ;)
15:07:02 <SamB> like for instance we could add factors of n to theirs.
15:07:05 <mauke> edwardk: you should also include (.)
15:07:09 <edwardk> heh
15:07:12 <AstralStorm> edwardk: except list comprehensions :P
15:07:38 <edwardk> astralstorm: i'm ok with surface syntax. =)
15:07:47 <SamB> edwardk: I think it is useful to have a listy one and a non-listy one
15:08:00 <mauke> huhu, class Functor f where (.) :: (a -> b) -> f a -> f b
15:08:16 <SamB> uh. no.
15:08:20 <mauke> yes!
15:08:35 <edwardk> hrmm
15:08:40 <bartw> ooh, that looks evil
15:08:50 <edwardk> tis very pretty =)
15:09:03 <glguy> Agreed, it would be better to generalize composition than to merge to `fmap`
15:09:17 * edwardk is easily lured by sparkly ideas
15:09:20 <AstralStorm> Oh, how would one invert a sort? :P
15:09:27 <mauke> reverse . sort
15:09:30 <AstralStorm> Blah.
15:09:30 <glguy> id
15:09:32 <AstralStorm> Too simple.
15:09:36 <edwardk> of course then <<< should go away too =)
15:09:38 <edwardk> @type (<<<)
15:09:39 <lambdabot> forall d b (a :: * -> * -> *) c. (Arrow a) => a c d -> a b c -> a b d
15:09:44 <mauke> sortBy (flip compare)
15:09:44 <SamB> mauke: is that efficient?
15:09:49 <glguy> the inverse function on a sorted list is id :)
15:10:00 <SamB> @type compare
15:10:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:10:09 <SamB> there should be a function that flips an Ordering
15:10:10 <glguy> sort = sortBy compare
15:10:16 <glguy> SamB: like flip?
15:10:25 <SamB> @type flip
15:10:26 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
15:10:35 <glguy> > sortBy (flip compare) [1,2,5,3,21,3]
15:10:36 <SamB> that flips a compare...
15:10:36 <lambdabot>  [21,5,3,3,2,1]
15:10:40 <SamB> I suppose that works well enough
15:10:43 <glguy> > sortBy (compare) [1,2,5,3,21,3]
15:10:44 <lambdabot>  [1,2,3,3,5,21]
15:11:01 <mauke> > map fromEnum [LT,EQ,GT]
15:11:02 <lambdabot>  [0,1,2]
15:11:25 <bartw> enoug haskell for one day, laters
15:11:53 <mauke> > map (toEnum . negate . (flip (-) 1) . fromEnum) [LT,EQ,GT]
15:11:54 <lambdabot>  Add a type signature
15:11:57 <AstralStorm> Now that's too nifty for mee to pass by :>
15:12:00 <mauke> > map (toEnum . negate . (flip (-) 1) . fromEnum) [LT,EQ,GT] :: [Ordering]
15:12:01 <lambdabot>  Exception: Prelude.Enum.Ordering.toEnum: bad argument
15:12:03 <AstralStorm> I mean the "flip" function.
15:12:09 <AstralStorm> Have to remember it.
15:12:16 <mauke> > map (toEnum . (1 +) . negate . (flip (-) 1) . fromEnum) [LT,EQ,GT] :: [Ordering]
15:12:16 <edwardk> flip is really handy
15:12:17 <lambdabot>  [GT,EQ,LT]
15:12:23 <mauke> SUCCESS
15:12:36 <SamB> @lisppaste
15:12:36 <lambdabot> Unknown command, try @list
15:12:41 <SamB> @paste
15:12:42 <lambdabot> http://paste.lisp.org/new/haskell
15:12:46 <monochrom> sort [GT,EQ,LT]
15:12:50 <monochrom> > sort [GT,EQ,LT]
15:12:51 <lambdabot>  [LT,EQ,GT]
15:13:06 <glguy> dinner thyme
15:13:06 <edwardk> you'll find you use it in places when you need to map in place a long function or something, etc. instead of map (something really really long) (itty bitty list)   you can (flip map) (itty bitty list) $ something really really long, etc.
15:13:07 <yip> > LT
15:13:08 <lambdabot>  LT
15:15:03 <int-e> > (-1+) 2
15:15:04 <lambdabot>  1
15:15:25 <mauke> oh, I have to remember that
15:16:02 <AstralStorm> Hmm, that sorting almost always gives the preferred indentation amount :>
15:16:19 <AstralStorm> Now, just some more probability mangling :>
15:17:02 <AstralStorm> I mean heuristics.
15:19:58 <SyntaxNinja> xerox: y0
15:20:13 <AstralStorm> Do you think I should give tabs higher probability if they're detected in the file? :>
15:20:32 <xerox> Hey.
15:22:53 <SyntaxNinja> xerox: did you get my patches?
15:22:56 <SyntaxNinja> xerox: I have some more for you.
15:23:03 * xerox checks
15:23:29 <SyntaxNinja> xerox: sent you two more.  just use the 2nd email, it has all 4
15:23:36 <xerox> OK!
15:23:49 <SyntaxNinja> xerox: can you please create a combined repository again?  I will work on the makefiles so that we can get cabal + cabal-install together
15:24:05 <SyntaxNinja> the problem reports I'm getting are mostly to do w/ an incomaptible cabal (no FilePath)
15:24:05 <xerox> I'll do it now.
15:24:14 <SyntaxNinja> thanks
15:24:30 <edwardk> heya SyntaxNinja. Made it out here, just don't know where anybody is ;)
15:24:42 <AstralStorm> Hmm... I think I should ignore indentation settings and go with user defaults if the ratio of lines-with-indent/lines is too small...
15:25:33 <SyntaxNinja> edwardk: where are YOU?
15:25:48 <edwardk> in the marriott
15:26:06 <edwardk> got here, checked in, loaded up my computer and started trying to find folks ;)
15:26:25 <SyntaxNinja> I don't know where folks are right now. I know most ppl are staying there,
15:26:29 <edwardk> been here for about 3 hours now waiting for someone in the area to log into IRC =)
15:26:36 <edwardk> *nods*
15:26:47 <SyntaxNinja> bringert, Igloo, and kosmikus are all there. you should just call the front desk and ask to be connected to their rooms
15:26:57 <SyntaxNinja> and email them
15:27:04 <bringert> edwardk: I'm here
15:27:06 <edwardk> I'm up in room 711. If anyone wants to swing by I'm more than happy to go with whatever srt of group plans arise
15:27:10 <SyntaxNinja> leave them voicemail and I'm sure they'll call you back :)
15:27:14 <SyntaxNinja> heya bringert
15:27:22 <bringert> and Igloo is sitting right here too
15:27:30 <bringert> we're in the PSU student union building
15:27:36 <bringert> there's wifi!
15:27:39 <SyntaxNinja> WIFI!
15:27:43 <edwardk> though, shapr is on his way out here and will crash in my room tonight, so I told him I'd be in my room at 5:30, other than that, I'm totally open to suggestions.
15:27:46 <bringert> there's also free wifi in the hotel lobby
15:27:55 <monochrom> Oh, you people are at ICFP?
15:28:04 <edwardk> yeah
15:28:08 <yip> sweet
15:28:08 <bringert> yep
15:28:10 <SamB> which people?
15:28:17 <zarvok> you guys go to the hackathon?
15:28:32 <bringert> yes
15:28:41 <zarvok> I can't come out until tomorrow, and am sad to have missed it.  How was it?
15:28:58 <lisppaste2> SamB pasted "Range arithmetic" at http://paste.lisp.org/display/26179
15:28:58 <edwardk> I missed it =(
15:29:20 <SyntaxNinja> this pub has live music tonight, fwiw. anyone want to figure out what time? http://www.kellsirish.com/portland/index.php
15:29:21 <lambdabot> Title: Kells Irish Restaurant & Pub - Portland, Oregon
15:29:46 <SamB> zarvok: I don't suppose your talk is going to be recorded?
15:30:02 * SyntaxNinja wonders why the hell they wouldn't put the time down
15:30:18 <bringert> they want you to get there early and drink lots of beer
15:30:19 <SyntaxNinja> I don't want to stay out too late, but would be up for joining folks if there's some plan
15:30:58 <zarvok> SamB: I don't think so, we're goign to try for an audio recording, but it may not happen
15:31:00 <SamB> when did we get syntax highlighting for lispaste?
15:31:07 <SamB> zarvok: just audio?
15:31:11 <zarvok> SamB: we will be distributing a tech report which will be online
15:31:15 <SamB> oh, okay.
15:31:26 <zarvok> SamB: We just don't have a camera, if someone has one and wants to record us, that's fine
15:31:34 <SamB> good. I was afraid all that would be left would be some incomprehensible slideshow ;-)
15:32:17 <zarvok> heh
15:32:22 <zarvok> the talk is going to be great
15:32:29 <bringert> edwardk: we should meet up for dinner after shapr gets here
15:32:29 <SamB> so, that thing I just pasted is what I used to make my physics homework take like 6 hours instead of ten minutes...
15:32:38 <zarvok> heh
15:32:44 <bringert> edwardk: is he coming at 5:30?
15:32:47 <edwardk> bringert: definition. he and frederik happen to be on the same flight
15:32:52 <SamB> well, actually, some of that time was spent trying to figure out if R was appropriate
15:32:54 <edwardk> er definitely
15:32:57 <SamB> I decided it was too complicated
15:32:57 <bringert> heh
15:33:14 <bringert> edwardk: what flight is that?
15:33:24 * bringert pulls out his flight tracking widget
15:33:30 <edwardk> coming out of chicago, not sure of the #
15:33:43 <bringert> ah, chicago, he might be late then
15:33:50 <bringert> they're having some problems there
15:34:06 <SyntaxNinja> I'm not sure if I should use slides for my 10 minute talk tomorrow.
15:34:06 <bringert> at least the had a few days ago when I was flying in
15:34:15 <bringert> and there's crappy wifi at O'Hare
15:34:23 <ezraburgh> perl6
15:34:33 <bringert> yes?
15:34:41 <ezraburgh> sorry wrong window!
15:34:43 <SyntaxNinja> ezraburgh: haskell!
15:34:53 <bringert> edwardk: what time are the supposed to land?
15:34:56 <bringert> they
15:35:04 <edwardk> i think its the one landing at 4:58
15:35:17 <edwardk> that fits the timing from my discussion with shapr
15:35:38 <edwardk> he was going to land, hop in the red line and meet me here
15:35:50 <int-e> SamB: 11 days ago Haskell syntax coloring (thanks to Kristof Bastiaensen!)
15:35:51 <SyntaxNinja> ahh, the red line
15:36:36 <edwardk> yeah wasn't so bad, dropped me off a few blocks from the hotel, nice walk, got here, then... boredom ;)
15:36:56 <xerox> SyntaxNinja: use those takahashi-style slides, big lonely words white-on-black, black-on-white, and flashy red.
15:37:19 <xerox> (darcs is giving me conflicts, gnarf!)
15:37:21 <edwardk> though i kinda figured that people were elsewhere, I couldn't find a reference to where the haskell workshop is being held tomorrow, etc.
15:37:43 <edwardk> only saw a link talking about the saturday workshops
15:37:52 <bringert> edwardk: HW is in the hotel
15:38:06 <bringert> edwardk: Igloo and I will drop by your room at 5:30
15:38:11 <edwardk> kk
15:39:08 <astrolabe> takahashi as in the telescope?
15:39:29 <xerox> astrolabe: have you evere seen audreyt's xul slides?
15:39:42 <astrolabe> no
15:39:58 <edwardk> brb running down the street to get something to drink
15:40:06 * SamB wonders how you quickcheck range arithmetic
15:40:12 <bringert> edwardk: there are vending machones
15:40:23 <edwardk> yeah
15:40:48 <edwardk> but I don't like paying the hotel here their rates when there is a subway a block away ;)
15:40:56 <bringert> ah
15:40:59 <xerox> Oops.
15:41:03 <bringert> ok, see you later
15:41:19 <xerox> astrolabe: needs firefox: <http://piro.sakura.ne.jp/xul/applications/takahashi-r/takahashi.xul#page1>
15:41:19 <lambdabot> http://piro.sakura.ne.jp/xul/applications/takahashi-r/takahashi.xul#page1>
15:48:57 <newsham> ?seen dons
15:48:58 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 6h 27m 25s ago.
15:49:03 <newsham> ?localtime dons
15:49:05 <lambdabot> Local time for dons is Sun Sep 17 08:48:42 2006
15:49:10 <SamB> hmm, I can't raise negative numbers to powers with my Range module...
15:49:21 <SamB> well, not with ** anyway
15:55:16 <edwardk> back
15:55:52 <edwardk> samb: i should give you some old interval arithmetic code of mine that handles trig functions etc.
15:56:01 <edwardk> i don't think I have it with me though
15:56:58 <edwardk> the trig functions make it a little tricky coz they aren't monotone
15:57:54 <SyntaxNinja> wow, lilo died :(
15:58:32 <SyntaxNinja> http://linux.slashdot.org/linux/06/09/16/2152243.shtml
15:58:34 <lambdabot> Title: Slashdot | Rob Levin, lilo of FreeNode, Passes, http://tinyurl.com/sxjqu
15:58:52 <lispy> any students in PDX that have an apple discount they can spare?
15:58:54 <wolverian> xerox, (any firefox/xulrunner-based browser works, actually.)
15:59:27 <lispy> (I know someone that wants to buy a macbook because they are so much cheaper in portland)
16:00:17 <edwardk> SyntaxNinja: *bad joke filter off* long live grub? *bad joke filter on*
16:01:44 <lispy> whoa, i just heard about lilo
16:01:50 <lispy> that sucks... :(
16:01:58 <beelsebob> indeed
16:02:02 <edwardk> yeah
16:03:25 <edwardk> I just realized lilo had been lurking on channel here the entire time I'd been coming to this channel.
16:04:11 <lispy> i think he come in recently and started lurking because of teekwod
16:04:22 <lispy> but i could be wrong
16:06:09 <newbcoder> what's so good about software transactional memory?
16:06:31 <xerox> newbcoder: do you want SPJ directly explaning it to you?
16:06:36 <xerox> (I'm not kidding.)
16:06:49 <newbcoder> sure
16:06:54 <newbcoder> who's spj?
16:07:03 <xerox> Yuck.
16:07:04 <yip> simon peyton jones
16:07:17 <yip> from microsoft
16:07:17 <xerox> A second...
16:07:33 <xerox> http://channel9.msdn.com/ShowPost.aspx?PostID=231495
16:07:35 <edwardk> Nah, I saw him in my log back July 17 a few days after I showed up here. Teekwod was recent.
16:07:36 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory, http://tinyurl.com/hk54p
16:07:38 <xerox> :)
16:08:15 <lispy> newbcoder: wikipedia explains it pretty wel too
16:08:58 <lispy> newbcoder: it's an optimistic way for threads to share resources which means in practice you waste less time dealing with contension
16:09:06 <lispy> even though in theory it could be much worse...
16:09:14 <xerox> That video is pretty nice. SPJ explains well :)
16:09:17 <edwardk> software transactional memory is great when you have a lot of objects and proportionally few actors and a low chance of collision. It avoids explicit locks for the vast majority of operations in exchange for the fact that you can get some pretty bad log jams going if you have a high reader/writer to resource count.
16:09:21 <newbcoder> in theory the worst case can be much worse?
16:10:12 <edwardk> yeah, the worst case can be pretty bad =)
16:10:16 <lispy> newbcoder: yeah, if you purposefully designed your system to exploit the weaknesses of STM it would have much worse performance than traditional semaphore based approach
16:11:22 <edwardk> coz you can go through almost the entire transaction then have to start it over. so you can lose forward progress unlike with a traditional lock model
16:12:47 <edwardk> however, as long as you can't have one thread grab a resource and take a nap, (in a sense that can be made more rigorous by reading the STM papers) you at least get some forward progress.
16:13:06 <edwardk> but you can still get total starvation situations
16:13:33 <edwardk> especially in the face of long transactions and lots of eager little threads doing writing
16:14:24 <edwardk> the long transaction may have to keep restarting and may never finish
16:15:34 * xerox nods
16:21:15 * araujo looks around
16:29:21 <lennart> so, is everyone in Portland yet? :)
16:30:10 <SamB> zarvok probably is not
16:30:25 <lispy> i'm not in portland yet
16:30:27 <SamB> considering he just left the channel 18 minutes ago
16:30:28 <lispy> i'm still in Corvallis
16:30:35 <SamB> I am not going to be in portland :-(
16:30:46 <lispy> i'll be up there tomorrow bright and early
16:30:55 <lispy> and i want to meet everyone
16:31:18 <lispy> even if i have to stand on a chair and go, "If you're from freenode, I'm lispy and I want to say hi and shake your hand!"
16:31:19 <lennart> we'll be here :)
16:32:32 <bringert> I, Igloo, edwardk, SyntaxNinja, JaffaCake and lots of other people are in Portland. shapr should be landing in 30 min
16:33:27 <lispy> cool
16:33:49 <lispy> bringert: i tried to write to stderr as per an apache doc i found but nada in the logs...i'm baffled but i'd love to get it it working
16:34:41 <bringert> lispy: I think I have had that working with fastcgi on apache
16:34:54 <bringert> so it just disappears?
16:35:00 <lispy> as far as i can tell
16:35:10 <bringert> maybe there's a setting in httpd.conf
16:35:12 <lispy> it doesn't show up in the main apache log or the custom logs i set for that webdir
16:35:35 <lispy> bringert: yeah, i tried asking in #apache but on one really paid attention :)
16:36:34 <lispy> bringert: i'm going to go eat now, but i wanted to mention it :)
16:36:48 <lispy> bringert: love the ajax interface...it's great but i fonud a few bugs too
16:36:59 <lispy> bringert: bf programs get munged by the url encodeing
16:37:07 <bringert> yeah, I don't know what it could wrong with the logging but let me know I should fix something
16:37:16 <SyntaxNinja> hey bringert, can you call me when you guys are done w/ dinner?
16:37:24 <SyntaxNinja> maybe we can all have a drink
16:37:41 <lispy> bringert: okay ,well a sequence of plus signs seems to be changed into one plus sign followed by psaces
16:38:02 <edwardk> lispy: try kill -s SIGUSR1 to kick it into a more verbose logging mode if you just need to do it temporarily, SIGUSR2 to turn it back down
16:38:08 <lispy> SyntaxNinja: thta sounds fun!
16:38:14 <lispy> SyntaxNinja: wish i was there right now...
16:38:24 <lispy> edwardk: hmm...to apache?
16:38:28 <edwardk> yeah
16:38:29 <bringert> SyntaxNinja: will do
16:38:39 <lispy> edwardk: i've already got it logging at the 'debug' level
16:38:41 <edwardk> ah
16:38:58 <bringert> lispy: hmm, ok
16:38:59 <edwardk> whats it not doing? you can't see the stderr of your code?
16:39:01 <bringert> will check it out
16:39:14 <bringert> is there an echo command for lambdabot
16:39:26 <lispy> edwardk: i want to log some things from a fastcgi program, and our logging function writes to stderr which apache claims should end up in the log
16:39:28 <bringert> to see what it's getting from me?
16:39:33 <bringert> @echo foo
16:39:34 <lambdabot> echo; msg:IrcMessage {msgPrefix = "bringert!n=bringert@host-203-37.pubnet.pdx.edu", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo foo"]} rest:"foo"
16:39:40 <lispy> bringert: that might work
16:40:10 <lispy> bringert: i was going to turn it off soon though :)  But i'll leave it up now that i see it can be good for debugging
16:40:27 <bringert> lispy: I've got a local one running
16:40:34 <lispy> bringert: i created a list of things i'd like to fix before it's 'live'
16:40:41 <bringert> ok, I've reproduced the + thing
16:40:51 <bringert> lispy: great
16:40:53 <lispy> bringert: with the latest patches to goa and lambdabot?  dons and i patched a lot latsinght
16:40:58 <bringert> nope
16:41:11 <lispy> well, if you can reproduce it i wouldn't worry then
16:41:31 <bringert> lispy: where's that list?
16:41:46 <lispy> bringert: i sent a patch to dons, i can forward it to you if you like
16:41:55 <lispy> not sure if it's in lambdabot yet..if it is it will be in TODO
16:42:01 <bringert> will look
16:42:02 <xerox> SyntaxNinja: http://hackage.haskell.org/~paolo/darcs/Cabal
16:42:04 <lambdabot> Title: Index of /~paolo/darcs/Cabal
16:44:28 <SyntaxNinja> xerox: cool. does that have asingle makefile that'll install everything?
16:44:41 <xerox> Nope
16:44:50 <lispy> bringert: but i think only one of them was a bug in the webshell...so it might not be that interesting of a list :)
16:44:50 <xerox> SyntaxNinja: hmmm in fact it might
16:45:04 <xerox> SyntaxNinja: standard Cabal makefile had something about cabal-install
16:45:11 <bringert> lispy: was it the + thing, or something else?
16:45:21 <lispy> the + thing
16:45:44 <bringert> I can't rebuild bot.fcgi right now, hacking GHC, and I don't have one with all the libs installed around
16:46:07 <lispy> bringert: otherwise we need a logo, some directons how to use lambdabot, a list of example commands, maybe a way to login to get extra features, and possible a listing of popular commands
16:46:35 <bringert> it would be nice to have a mode where you could see what everyone writes
16:46:41 <bringert> like it is in here
16:46:55 <bringert> I guess that would basically be an AJAX IRC client
16:47:04 <lispy> oh, could you put a scroll bar in the history?  so that it doesn't just go away?
16:47:08 <lispy> heh
16:47:27 <lispy> (these are just ideas)
16:47:34 <bringert> lispy: there was some messiness with that
16:47:48 <lispy> hmm...okay, we'll keep in on the todo list
16:47:55 <bringert> I can get a scroll bar, but the the text starts at the top, and doesn't scroll down when more is added
16:47:56 <lispy> er wishlist rathe
16:48:08 <lispy> ah, lame
16:48:18 <lispy> oh
16:48:22 <bringert> there might be a way to do it
16:48:27 <lispy> so you'd have to start with a full screen of blank lines..?
16:48:59 <bringert> heh
16:49:03 <lispy> it does everything i wanted as it is now, the rest is just icing on the cake :)
16:49:11 <sm> hi all
16:49:30 <lispy> bringert: i'm very happy with what we (#haskell) pulled off in just a few days of tinkering
16:49:35 <bringert> one easy way to get it working would be do have the history go backwards, but that's a bit weird
16:49:44 <sm> how do I pass -fallow-overlapping-instances when using runhaskell ? it uses the -f argument for ghc path
16:49:58 <lispy> sm: you can put it in the source code
16:50:17 <sm> ah, thanks
16:50:17 <lispy> put, at the top of the code {-# OPTIONS_GHC -fallow-overlapping-instances #-}
16:50:29 <bringert> lispy: when are you coming here?
16:50:36 <lispy> in the morning
16:50:40 <lispy> just for the workshop
16:50:51 <lispy> i don't know if we'll stick around much after it
16:50:51 <bringert> going back tomorrow evening?
16:50:54 <bringert> ok
16:51:06 <lispy> yeah, the full conference was a bit much for out of pocket
16:51:06 <bringert> would be fun to hang out here hacking for a bit
16:51:11 <lispy> yes!
16:51:17 <lispy> i'm carpooling though
16:51:30 <lispy> we'll see how it works out
16:51:54 <edwardk> bringert: you can refocus on the bottom of the text with a little html/javascript trickery, so you can have an html session with a scrollbar and recent-at-bottom behavior
16:52:18 <lispy> edwardk: have you seen what he has so far?
16:52:19 <bringert> ah, focus() works on things other than form elements?
16:52:24 <lispy> @where lambdaweb
16:52:25 <lambdabot> I know nothing about lambdaweb.
16:52:37 <lennart> all right!  time to check out the hotel bar and have a beer :)
16:52:43 <lispy> @where+ lambdaweb http://lambdabot.codersbase.com/
16:52:43 <lambdabot> Done.
16:52:45 <edwardk> you don't need to focus, you can actually tell it to scroll ;)
16:52:52 <bringert> lennart: are you at the marriott?
16:52:56 <lennart> yes
16:53:09 <bringert> wanna join us for dinner later?
16:53:12 <edwardk> ah cool. another one for the list =)
16:53:20 <lennart> i'm having dinner with a friend tonight
16:53:28 <edwardk> I'm up in 711 if you want to swing by
16:53:57 <lennart> i'll head to the bar
16:54:05 <lennart> i need a beer :)
16:54:26 <bringert> the bar is full of TVs showing american football and the like
16:54:32 <bringert> and retired pilots
16:54:36 <lispy> bringert: welcome to the US :)
16:54:37 <edwardk> heh
16:54:39 <bringert> they are having a conference
16:54:39 <lennart> lol
16:54:50 <bringert> I'm not kidding
16:55:06 <lispy> bringert: many people here watch (are addicted?) to TV but i can't fathom why :)
16:55:18 <lennart> i don't care.  i can handle it for a little while now.  i've lived in NYC for 8 months
16:55:23 <lispy> and we have TV everywhere...
16:55:44 <edwardk> if you see a tall guy in a blue shirt, with long hair and a goatee, thats me, or probably another haskeller. few professional pilots fit that description at least ;)
16:55:55 <lennart> but if they only have Bud Light I'll exit at once
16:55:57 <lispy> in cars, at the bars, on trains, buses any time you're in a queue...TV TV TV!
16:56:00 <bringert> those are *retired* pilots
16:56:17 <SamB> lispy: it sucks out your brains
16:56:19 <bringert> lennart: they have better beer than that
16:56:22 <edwardk> yeah
16:56:24 <mux> ?seen dons
16:56:24 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 7h 34m 52s ago.
16:56:26 <bringert> pretty good IPA
16:56:27 <sm> lispy: there are many files involved, is there an alternative ?
16:56:31 <SamB> I found this out in my youth by watching several movies in a row
16:56:33 <lennart> I figured
16:56:36 <lennart> this is Portland
16:56:39 <sm> GHCFLAGS env var is ignored
16:56:51 <lispy> sm: hmm...
16:56:52 <bringert> edwardk: did you mean srolling the whole window?
16:56:55 <lennart> later...
16:57:03 <lispy> sm: you use runghc with many files?
16:57:24 <edwardk> bringert: well, you can css style a piece of it with overflow and scroll that, or scroll the whole window, etc.
16:57:29 <edwardk> bringert: depends on what you want
16:57:37 <sm> well.. I have figured out how to build most of them with ghc --make
16:57:42 <edwardk> i've used this kind of trick for logging, etc. its not that hard
16:57:59 <lispy> sm: you cabal :)
16:58:00 <sm> then I runhaskell (aka runghc) hpodder.hs
16:58:05 <bringert> edwardk: what's the javscript function called?
16:58:05 <lispy> sm: er, i mean use cabal
16:58:08 <bringert> if you remember
16:58:36 <sm> there is a cabal file which builds a setup binary which builds things in a separate dist dir
16:58:42 <lispy> sm: and runhaskell doesn't take the parameter?  i'm surprised
16:58:44 <edwardk> its not a function, its a css property. you measure it and scroll. hrmm one sec. i might have a cheesy example of something that scrolls around here from a fund drive page
16:58:50 <sm> but I want to build in place, so I can make changes and run again quickly
16:58:57 <lispy> i se
16:59:03 <lispy> sm: not sure then :(
16:59:05 <sm> runhaskell uses -f for it's own purposes
16:59:11 <lispy> sm: i'd have to search the ghc manual
16:59:16 <sm> ok doke.. thanks
16:59:28 <lispy> sm: good luck! :)
16:59:56 <edwardk> http://linguistlist.org/donation/fund-drive2006/room.cfm , scroll to the bottom, click 'Fund Drive Team' and that page uses a 5 second hack-job javascript based scrolling trick
16:59:58 <lambdabot> Title: Welcome Aboard!, http://tinyurl.com/khrng
17:00:57 <edwardk> ah, woops
17:01:02 <edwardk> that one isn't the way you want to do it
17:01:07 <edwardk> i'll have to find another one
17:01:58 <edwardk> that one just measures the length of the div and gradually slides it up. you can do it with offsets and scrollTop, etc.
17:06:22 <edwardk> the portable solution would be something like put a div in an outer div that is overflow: auto, measure the height of the internal div, and scrollTop the outer div to that minus its height on output, adding output to the inner div via javascript or what have you
17:07:44 * bringert shudders
17:07:56 <edwardk> its not so bad really. like 20 lines of code.
17:08:27 <edwardk> its not something i'd play haskell golf with, but its not a total terror ;)
17:09:20 <edwardk> you want a hack job, I have an almost entire reimplementation of CSS2 lying around somewhere that uses just basic divs and javascript as building blocks and draws everything itself to work around crappy old browsers ;)
17:10:24 <edwardk> almost completely unnecessary these days, thank god.
17:10:52 <edwardk> well, almost
17:12:07 <bringert> edwardk: we're taking off from here now, we'll try to be at your room around 5:30
17:12:11 <bringert> 711 right?
17:12:19 <edwardk> only thing I miss when I'm at a hotel is having a printer handy and an extra monitor
17:12:21 <edwardk> yeah
17:12:34 <bringert> kowey showed up here to, he's joining us
17:12:47 <edwardk> cool
17:13:38 <xerox> So no pictures available of the event yet?
17:13:40 <xerox> :(
17:14:17 <edwardk> didn't bring a camera
17:15:29 <araujo> @pl f file = readFile file >>= return . lines
17:15:29 <lambdabot> f = (lines `fmap`) . readFile
17:17:49 <edwardk> why is pointless deliberately obfuscating these days?
17:17:59 <xerox> I find it very nice.
17:17:59 <edwardk> hrmm
17:20:24 <edwardk> just not sure why it did lines `fmap` rather than
17:20:31 <edwardk> f = (fmap lines) . readFile
17:20:38 <edwardk> @type (fmap lines) . readFile
17:20:39 <lambdabot> FilePath -> IO [String]
17:20:45 <edwardk> @type (lines `fmap) . readFile
17:20:46 <lambdabot> parse error on input `)'
17:20:47 <edwardk> er
17:20:54 <edwardk> @type (lines `fmap`) . readFile
17:20:55 <lambdabot> FilePath -> IO [String]
17:21:08 <edwardk> pointless is slacking ;)
17:21:15 <xerox> To use it as combinator?
17:21:51 <edwardk> i figured it had something to do with the binary () thing but I don't see the merit in this particular case
17:22:18 <Cale> Yeah, with (`fmap` x) it would make sense to use that form
17:25:31 <edwardk> hrm, it should be able to take that all the way down to
17:25:37 <edwardk> @type fmap lines . readFile
17:25:38 <lambdabot> FilePath -> IO [String]
17:26:45 <OD> there seems to be a theme on this server. I noticed that there is alot of similar topics on this server. Is it me or is that true.
17:28:17 <monochrom> It is you.
17:29:15 <SyntaxNinja> edwardk: where's shapr?!
17:30:18 <edwardk> well, he was going to call me around 5:30. so i'll give him a few
17:30:45 <edwardk> he's should have made it in around 5:00, so i figure he'll get here some time after everyone else shows up on my doorstep
17:30:46 <Cale> OD: similar in what sense?
17:31:44 <int-e> Cale: they're probably sequences of words made up from letters, mostly.
17:36:27 <dmwit> @seen dibblego
17:36:27 <lambdabot> dibblego is in #haskell. I don't know when dibblego last spoke.
17:36:39 <dibblego> hello dmwit
17:37:00 <dmwit> Hey.  Were you the one working on the Haskell exercises from chalmers?
17:37:24 <dibblego> I was working on exercises from somewhere
17:37:32 <dibblego> I found some on google
17:37:49 <dmwit> Did you do one about a Towers of Hanoi on four pegs?
17:37:56 <dibblego> no don't think so
17:38:16 <dmwit> Okay.  Never mind, then... =P
17:38:21 <dibblego> ok :)
17:40:22 <vincenz> If you wanna see a pure management salespitch for a technical product nad laugh
17:40:24 <vincenz> http://www.microsoft.com/net/basics_faq.mspx
17:40:26 <lambdabot> Title: .NET Frequently Asked Questions
17:43:55 <vincenz> read and laugh
17:46:19 <int-e> scary
17:48:58 <vincenz> what's scary is that you can pitch products based on pure fluff
17:49:16 <vincenz> nothing in there is inherently easer with .net
17:49:17 <vincenz> not to mention
17:49:29 <vincenz> webservices are not inherently better than other applications
17:49:53 <int-e> well, take a clueless manager who reads that - he gets everything he needs. buzzwords, and a business strategy ;)
17:50:14 <vincenz> yeap
17:50:28 <vincenz> I especially like the figure
17:50:34 <vincenz> This illustration shows the relationship between the core technology components of .NET.
17:50:40 <vincenz> the figure says absolutely nothing
17:50:42 <vincenz> all it says is
17:50:45 <vincenz> we communicate with xml
17:50:57 <int-e> 'we can draw pretty pictures, too'
17:51:06 <vincenz> which a) ain't the best, and b) ain't .NET specific
17:54:02 <int-e> . o O ( A "smart client" is someone who asks relevant questions that you cannot answer. )
17:57:13 <AstralStorm> Uh, this might sound stupid...
17:57:27 <AstralStorm> How would one round some Fractional to n places?
17:58:11 <AstralStorm> Blah, I know now.
17:58:15 <AstralStorm> Stupid me :>
18:05:37 * Patterner puts the Dunce Cap an AstralStorm's head
18:11:10 <vincenz> Hey it's not a stupid question, he found the answer
18:11:13 <vincenz> It's called Rubberduckin
18:12:54 <AstralStorm> Type conversion galore :>
18:13:17 <AstralStorm> (mostly because I wanted roundToPrec to take two floats :>)
18:13:32 <SamB> oh no! now Patterner is going to be charged higher prices in the stores unless he can get a Remove Curse...
18:13:52 <SamB> er, wait.
18:13:54 <SamB> AstralStorm.
18:14:00 <SamB> I must be confused.
18:14:22 <SamB> good thing I'm not trying to do read any scrolls!
18:17:35 <AstralStorm> Any way to make it look shinier? (pasting)
18:17:36 <AstralStorm> roundToPrec x eps = fromIntegral (round (x * denom)) / denom
18:17:36 <AstralStorm>       where denom = fromIntegral $ denominator eps
18:20:15 <AstralStorm> Uh, it'll break badly with some weirder fractions :P
18:21:05 <AstralStorm> Or maybe not.
18:21:16 <AstralStorm> Unless somebody gives it 1%23 :>
18:22:49 <dmwit> ?hoogle (a -> b) -> (a -> [b])
18:22:50 <lambdabot> No matches, try a more general search
18:22:51 <AstralStorm> Uh. It will work - dumb me - hand me that duncecap
18:23:16 <AstralStorm> (just will return some weirder fractional)
18:23:56 <dmwit> ?type (:[]) .
18:23:57 <lambdabot> parse error (possibly incorrect indentation)
18:24:05 <dmwit> ?type ((:[]) .)
18:24:06 <lambdabot> forall b a. (a -> b) -> a -> [b]
18:24:22 <weitzman> @type (:[])
18:24:23 <lambdabot> forall a. a -> [a]
18:24:32 <dmwit> Isn't there a better name for that having to do with the list monad?
18:24:58 <xerox> box = (:[])
18:24:58 <AstralStorm> It won't work as expected with 0.03 for instance. It'll round to one hundredth.
18:25:05 <xerox> @oldwiki LicensedPreludeExts
18:25:06 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
18:25:09 <xerox> At least here -^
18:26:03 <dmwit> ?hoogle Monad m => (a -> b) -> (a -> m b)
18:26:04 <lambdabot> No matches, try a more general search
18:26:19 <dmwit> k...
18:26:21 <dmwit> Thanks.
18:26:50 <weitzman> @type (return .) (.)
18:26:52 <lambdabot> forall (m :: * -> *) b c a. (Monad m) => (b -> c) -> m ((a -> b) -> a -> c)
18:27:02 <weitzman> @type (return .)
18:27:04 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
18:27:40 <weitzman> > (return .) (+ 1) 0 :: [Int]
18:27:41 <lambdabot>  [1]
18:27:50 <AstralStorm> xerox: any idea how to avoid the dumb effect on 0.03 and like floats?
18:28:03 <AstralStorm> (or on rationals e.g. 3%10)
18:28:43 <AstralStorm> Hmm... Maybe I'll separate the "rounder" and "precision cutter"
18:28:50 <dmwit> Now we're talking... thanks weitzman. =)
18:29:09 <weitzman> dmwit: Yes, we're talking!
18:29:21 <Sal> #join
18:29:38 <xerox> AstralStorm: sorry?
18:30:17 <weitzman> @djinn Monad m => (a -> b) -> (a -> m b)
18:30:18 <lambdabot> Cannot parse command
18:30:51 <weitzman> I guess if djinn can't handle lists, odds aren't good for handling typeclasses
18:30:54 <AstralStorm> xerox: simple stuff really - I can't think :P
18:32:01 <xerox> AstralStorm: what do you want to do?
18:32:13 <xerox> Anyway...
18:32:15 <xerox> @localtime xerox
18:32:16 <lambdabot> Local time for xerox is Sun Sep 17 03:31:57 2006
18:32:36 <xerox> I'll leave you the `think' homework, and go to sleep :)
18:32:59 <Sal> @lacaltime
18:33:24 <weitzman> I decided today that if I'm ever homeless and jobless and don't know where to turn, I can just come back to campus and wear a sign, "Will help with Principles of Programming homework for food"
18:33:31 <Sal> @lacaltime Sal
18:33:33 <lambdabot> Local time for Sal is Sun Sep 17 09:33:10 2006
18:33:52 <zarvok> heh, weitzman, where do you go to school?
18:33:57 <weitzman> Same place as you!
18:34:08 <weitzman> Any we're even the same year, apparently
18:34:18 <weitzman> According to finger
18:34:25 <zarvok> heh, well, I occasionally hear people talk about a weitzman, so I thought it might be the case
18:34:31 <weitzman> Ah
18:34:40 <weitzman> I'm legendary!
18:34:59 <zarvok> heh, well, I am friends with {marina, joe, dan} who occasionally mention you
18:35:00 <weitzman> Although you're apparently more hardcore with Haskell than me
18:35:25 <weitzman> Oh. Yeah, I used to see those guys a lot freshman year
18:36:00 <zarvok> heh, well, I do enjoy my haskell, but I don't yet consider myself particularly hardcore
18:36:20 <weitzman> My stalking shows you to be a 212 TA and a Bob Harper research aid
18:36:38 <weitzman> Did you know Sridhar?
18:36:53 <zarvok> yeah, it's his fault I am here
18:36:57 <weitzman> Oh, well
18:36:59 <weitzman> I guess that's odd
18:37:04 <weitzman> I would blame him in part for me being here
18:37:12 <weitzman> And we can blame Tim Sweeny for him
18:37:16 <zarvok> he is the only reason anyone at CMU uses haskell
18:37:22 <weitzman> Strange world
18:37:40 <zarvok> yeah, I once TA'd 212 and now work for Harper (which is sweet)
18:37:42 <weitzman> The Haskell community should thank Tim Sweeny for starting a weird chain of Haskell interest
18:38:07 <weitzman> I'm in HOT compilation, which is pretty interesting, but that's about as intense as I've gotten
18:38:21 <zarvok> heh, I'm just impressed he bothered to respond to an e-mail from some random fanboy and that his answer to the question "how can I be sweet like you" was "learn haskell"
18:38:44 <weitzman> I also partly blame Ryan for me being here
18:38:53 <weitzman> Who you might also know
18:39:03 <Sal> @graph
18:39:03 <lambdabot> Unknown command, try @list
18:39:05 <weitzman> He worked for Pfenning though, I think
18:39:39 <zarvok> I vaguely know him, but didn't know he was a haskeller.  Crary (he's teaching HOT right?) is actually doing some latex related project in haskell.  He was thinking of going to the hackathon, but I'm not sure he made it
18:39:59 <weitzman> He's not a Haskeller, as far as I know. But he told me Haskell was where all the interesting PL research was going on
18:40:09 <weitzman> He's an OCaml and LISP guy
18:40:22 <weitzman> Yeah, Crary's teaching hot. He's pretty cool
18:40:32 <zarvok> haha, well, the CMU folks don't use it, and I'm not sure we can describe "all interesting PL research" without talking about CMU
18:40:42 <weitzman> True, true
18:40:54 <weitzman> I'm sure Harper does all his stuff with ML. Gotta have pride
18:41:16 <zarvok> Harper has me working on some really cool stuff actually - implementing monads and typeclasses for ML.  he was nice enough to consider my (deviant) interest in haskell
18:42:13 <weitzman> There's a decent probability I'm going to end up working at MS on Visual Studio, which will make the type-theorist part of me very sad
18:42:29 <zarvok> well, just hack on the f# part :)
18:42:32 <weitzman> No more singleton kinds and monads
18:42:45 <weitzman> I would actually be working on the debugger/profiler/related stuff
18:42:53 <weitzman> So it might not be so bad
18:43:38 <zarvok> perhaps
18:43:51 <AstralStorm> xerox: the thinking went better than expected - both rounding and cutting places work fine :>
18:44:03 <zarvok> well, I have a bunch of grading to finish before I head to ICFP, so I'm going to hvae to go back to idling.  Later
18:44:07 <weitzman> later
18:44:13 <hyrax42> did time sweeny actually tell someone to learn haskell
18:44:16 <weitzman> Yes
18:44:35 <weitzman> A friend of mine and apparently zarvok emailed him many years ago
18:44:54 <weitzman> Don't know what exactly the question was, but the answer was, "learn Haskell"
18:45:09 <weitzman> And he went off to college and became a PL person
18:45:17 <weitzman> A happy story :)
18:45:21 <zarvok> the question was along the lines of "how can I become a great game designer like you"
18:45:31 <zarvok> (couldn't resist the urge to share the story)
18:46:27 <zarvok> as a result, our friend became a very serious haskell hacker and has passed the goodness on to a number of current CMU undergrads
18:46:59 <weitzman> Another CMU person I've seen around here is nuffer
18:47:17 <weitzman> He would be a sophmore now, I think
18:47:22 <weitzman> Don't know if you know him
18:48:18 <tennin> hi
18:49:19 <lispy> SamB: this is irc not nethack :)
18:54:31 <hyrax42> hm
18:54:31 <hyrax42> gah crappy wireless reception
18:54:51 <AstralStorm> Hey, it's pesky me again. I want to restrict one argument of a function to be non-negative. How to do that, so it works during compile and not runtime?
18:55:11 <weitzman> Dependent types?
18:55:21 <weitzman> Wait, does Ix do that?
18:55:39 <weitzman> > 3 :: Ix n => n
18:55:40 <lambdabot>  add (Num n) to the expected type of an expression
18:55:40 <lambdabot>   In the expression: 3 ...
18:57:14 <AstralStorm> weitzman: nope.
18:57:38 <AstralStorm> Ix only is for continuous subranges - which may include negative numbers too.
18:58:09 <AstralStorm> I'd like something like CUInt
18:58:49 <AstralStorm> Except only with a lower bound.
19:00:25 <AstralStorm> Do I have to create another class?
19:00:44 <dmwit> ?type %
19:00:45 <lambdabot> parse error on input `%'
19:00:52 <dmwit> > 3%10
19:00:53 <lambdabot>  3%10
19:00:56 <weitzman> @type (%)
19:00:57 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:01:41 <dmwit> ?index (%)
19:01:42 <lambdabot> Data.Ratio
19:02:00 <dons> AstralStorm: restrict your function to Word32 ?
19:02:21 <dons> otherwise, you need either a smart constructor, or a type level Nat
19:02:24 <AstralStorm> dons: I'd prefer it working on Integer too.
19:02:51 <dons> and you don't want to write: f x | x > 0 = .... ?
19:03:02 <AstralStorm> dons: that's runtime-only.
19:03:22 <dons> then you can start here: http://haskell.org/haskellwiki/Smart_constructors
19:03:24 <AstralStorm> Anyway, this may be the way.
19:03:24 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
19:03:32 <AstralStorm> :D
19:03:43 <AstralStorm> Thanks for the link.
19:03:45 <dmwit> ?type div
19:03:46 <dons> you need to find a type to encode what you're looking for, if you wish to do the check statically
19:03:46 <lambdabot> forall a. (Integral a) => a -> a -> a
19:05:13 <araujo> lilo is dead
19:05:15 <araujo> :-(
19:05:55 <AstralStorm> araujo: old news, but yeah, bad
19:06:22 <araujo> old news?, it was today :-P
19:07:35 <AstralStorm> But Freenode sent a notice to everybody.
19:10:22 <dmwit> ?type (!!)
19:10:24 <lambdabot> forall a. [a] -> Int -> a
19:10:46 <dmwit> Ah, that's where the finite integer is coming from... =)
19:13:36 <hyrax42> I believe a lot of the list operation use Int rather than Integral a => a
19:13:36 <hyrax42> for efficiency
19:13:40 <hyrax42> there are generic versions
19:13:47 <hyrax42> but not sure about !!
19:13:57 <AstralStorm> ?type (!!!)
19:13:58 <lambdabot> Not in scope: `!!!'
19:14:09 <AstralStorm> Hmm. Could've been called like that :>
19:14:42 <hyrax42> @hoogle Integral a => [b] -> a -> b
19:14:42 <hyrax42> @type (!!)
19:14:43 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
19:14:43 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
19:14:43 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
19:14:44 <lambdabot> forall a. [a] -> Int -> a
19:15:03 <hyrax42> there ya go
19:15:03 <hyrax42> genericInde
19:15:03 <hyrax42> x
19:15:03 <AstralStorm> genericIndex = _verbose_
19:15:16 <hyrax42> (!!!) = genericIndex
19:15:16 <hyrax42> and you're set
19:15:20 <AstralStorm> Yep.
19:15:22 <hyrax42> ?
19:15:34 <hyrax42> or even import Prelude hiding (!!)
19:15:52 <AstralStorm> I know :>
19:16:00 <hyrax42> and you can call (!!) = genericIndex
19:16:34 <hyrax42> what are you trying to do that you want the bounded-below integer type thingy
19:16:37 <hyrax42> (just curious)
19:17:26 <dmwit> hyrax42: I was using indices into a factorial array...
19:17:44 <dmwit> But it was defined in terms of itself...
19:17:50 <AstralStorm> hyrax42: various.
19:18:11 <dmwit> Which doesn't work quite right when you can't use an infinite index.
19:18:16 <AstralStorm> Esp. blocking x^y with negative y.
19:18:24 <hyrax42> @index assert
19:18:25 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
19:18:34 <hyrax42> @type Control.Exception.assert
19:18:34 <AstralStorm> Assert is one, it's runtime.
19:18:35 <lambdabot> forall a. Bool -> a -> a
19:18:49 <hyrax42> oh I know I'm just reading that smart constructors like
19:18:50 <AstralStorm> I'd prefer something compile-time maybe.
19:18:51 <hyrax42> link
19:18:58 <hyrax42> I think you need epigram for that
19:19:20 <AstralStorm> These seem hard to implement correctly for UInteger
19:19:24 * hyrax42 not sure though
19:19:42 <hyrax42> @index UInteger
19:19:42 <lambdabot> bzzt
19:19:57 <hyrax42> you are defining UInteger?
19:20:07 <AstralStorm> UInteger x | x >= 0 = Integer x
19:20:27 <AstralStorm>      | otherwise = error "eat my shorts"
19:20:48 <AstralStorm> (yes, it's not correct Haskell, but you get the idea)
19:21:00 <hyrax42> the thing is you have problems
19:21:17 <AstralStorm> Except I want it to act at compile time :/
19:21:17 <hyrax42> for e.g. definition of (-)
19:21:31 <hyrax42> @type (-)
19:21:32 <lambdabot> forall a. (Num a) => a -> a -> a
19:21:44 <AstralStorm> No no, not that. For _truly_ negative values.
19:21:49 <AstralStorm> @type (-1)
19:21:50 <lambdabot> forall a. (Num a) => a
19:21:53 <hyrax42> in that you need the second argument to be no greater than the left
19:22:14 <hyrax42> and you'd want it enforced statically, it sounds
19:22:53 <AstralStorm> Yes, I'd prefer that. Although I don't know how to implement it. Peano numbering sounds scary...
19:23:42 <AstralStorm> Something like class Bounded, but w/o the upper boundary.
19:24:00 <hyrax42> it looks like it needs a goddamned mess of code (the type-hackery peano stuff)
19:24:06 <AstralStorm> And with constant lower one.
19:24:10 <hyrax42> just plain hideous
19:24:20 <hyrax42> clever, but ugly
19:24:21 <AstralStorm> Yes, that's lower-level than assembler :/
19:24:38 <AstralStorm> It's direct use of lambda calculus for numbers. Bleh.
19:25:15 <hyrax42> no, that'd be church numerals
19:25:15 <hyrax42> ;)
19:25:39 <AstralStorm> Ah right :>
19:25:40 <hyrax42> anyway, what you want is (I think) possible in epigram
19:25:46 <hyrax42> but I know next to nothing about the language
19:26:22 <AstralStorm> So I'll drop the idea for now.
19:26:29 <hyrax42> I guess if you used TH to do the peano code for you ( assume it's possible )
19:26:31 <AstralStorm> Maybe future Haskell versions will support that :>
19:26:39 <tennin> hmm, I didn't actually find type-level Peano numbers to be that ugly
19:27:05 <hyrax42> *I assume
19:27:25 <tennin> at least as used in Oleg's HList and OOHaskell papers
19:27:53 <hyrax42> condolences notice?
19:27:59 <AstralStorm> Yes...
19:28:10 <SamB> peano isn't so ugly
19:28:12 <hyrax42> huh?
19:28:32 <tennin> the only really ugly part was the workaround needed to avoid overlapping instances
19:28:38 <hyrax42> undefined :: S (S (S (S (S (S Z)))))
19:28:38 <SamB> oh?
19:28:39 <hyrax42> ?
19:29:03 <SamB> hyrax42: you don't even have to have values of that type, as far as I know...
19:29:33 <SamB> tennin: what workaround?
19:32:03 <SamB> one of our number did type-level twos complement numbers (or was it fours or eights?)
19:32:19 * SamB can never remember where to put the apostrophes
19:32:26 <dylan> hehe
19:32:32 <dylan> funny story related to haskell.
19:32:36 <dylan> sort of...
19:33:05 <SamB> dylan: oh?
19:33:21 <dylan> it's software freedom day here, and we've been giving out different open source / free software things. Linux distros, but also "the open CD" and such
19:34:04 <dylan> when we were packing up, to go to our second location, I took one of the organge plastic table clothes and worse it as a cape.
19:34:14 <dylan> (I am still wearing it)
19:34:29 <dylan> and ran around acting rather odd. I'm software freedom day man, you see.
19:34:36 <SamB> heh
19:34:48 <dmwit> > let bot = bot in or [True, bot]
19:34:49 <AstralStorm> How that's related to Haskell?
19:34:52 <dylan> so, my comrades asked me if I was crazy enough yet to try haskell. :)
19:34:55 <lambdabot>  True
19:35:00 <SamB> you didn't run around reversing and pirating software I hope?
19:35:01 <AstralStorm> @type bot
19:35:02 <lambdabot> Not in scope: `bot'
19:35:04 <SamB> dylan: heh
19:35:20 <SamB> didn't know you were a skeller eh?
19:35:34 <AstralStorm> Haskell crazy? What the... :P
19:35:41 <tennin> SamB: It's in section 6 of the HList paper
19:35:43 <AstralStorm> It's the sanest language out there :>
19:35:47 <SamB> tennin: oh
19:35:50 <SamB> AstralStorm: yes.
19:36:03 <dons> we should have haskell cd isos for people to distribute
19:36:03 <SamB> but it *does* seem insane to those who are unused to sane languages.
19:36:18 <dons> with ghc, hugs, haddock, alex, happy, lambdabot, darcs ,... on them
19:36:24 <SamB> dons: with nice tutorial PDFs and software?
19:36:24 <AstralStorm> My first impression: "it looks like math"
19:36:29 <dons> yeah
19:36:32 <SamB> and fun papers?
19:36:44 <dons> all the tutes, and apapers and all. everything you'd need for a couple of years of haskell work
19:37:04 <dylan> well, I'm also responsible for a general knowledge of haskell here.  From before I officially started learning it.
19:37:04 <SamB> should have the funnest beginning papers sorted out maybe, though ;-)
19:37:25 <dylan> I gave a rather large presentation on O'Caml once, and mentioned haskell a few times...
19:37:31 <SamB> do we have an official registry of haskell learners?
19:37:37 <SamB> because I never was registered.
19:37:53 <dylan> SamB: well, I was a haskell admirerer for a while.
19:38:32 <hyrax42> haskell doesn't seem too well-known here
19:38:32 <hyrax42> my ai teacher though I said pascal
19:39:00 <dylan> anyway, this has lead to a conversation I'm still having now curry-howard isomorphism.
19:39:08 <SamB> I started learning it because exarkun (from #twisted and #python before that) had started, and I had had a hard time with the idea that a purely functional language was any good
19:39:08 <dylan> (is that hte right phrase?)
19:39:24 <SamB> I suppose I originally had the misconception that all the data was pure functions...
19:39:44 <SamB> yes, yes, I know lambda calculus is like that too...
19:39:44 <hyrax42> as did another guy, but he's a softeng phd teaching a low-level comp class
19:39:44 <hyrax42> it's not so surprising softeng guys don't know about it
19:39:44 <hyrax42> anyway, I think I'm going to attempt the ai project (a game-playing agent) in haskell
19:39:44 <hyrax42> there's a competition :p
19:39:55 <dylan> I only didn't learn haskell because ocaml had impure I/O. :)
19:40:16 <dons> you were tempted by the dark side?
19:40:16 <AstralStorm> Huh, why this doesn't fail when n<0?
19:40:19 <AstralStorm> cutPlaces x n = assert (n >= 0) $ (fromIntegral (truncate (x*10^n)) / 10^n)
19:40:21 <dylan> which in retrospect is lame
19:40:27 <SamB> sometime after I got fully hooked, I found out that exarkun had given up!
19:40:29 <AstralStorm> It fails with ^ error
19:40:32 <AstralStorm> not with assertion
19:40:51 <dons> asserts are removed with -O
19:40:56 <AstralStorm> Uh, bad me :P
19:41:01 <AstralStorm> Forgot that, buehehe.
19:41:05 <SamB> hyrax42: a lot of people think you say PASCAL
19:41:23 <SamB> especially if you mumble like me ;-)
19:41:34 <SamB> I have gotten into the habbit of spelling it ;-)
19:41:39 <dons> i just tried to read my email in hmp3, and wondered why all the mail subject lines looked like spam
19:41:43 * dons drinks coffee
19:41:52 <SamB> dons: hmp3 reads mail now?
19:42:01 <dons> nope
19:42:05 <SamB> dons: and mail usually consists mostly of spam
19:42:08 <dons> but for a moment I thought i was in mutt
19:42:16 <dons> not mine :)
19:42:19 <dons> procmail++
19:42:23 <SamB> its just that if you have a good setup the spam gets filtered out before you look at it
19:42:39 <dylan> My mail server rejects spam at connect time
19:42:42 <SamB> incidentally, I wonder what happened to gmail
19:42:55 <dmwit> There was an explanation around today...
19:43:02 <dons> did it go down?
19:43:17 <SamB> no!
19:43:30 <SamB> its just that the spam rates have been going up!
19:43:34 <dons> ah
19:43:37 <dmwit> http://ericfarraro.com/?p=6
19:43:39 <lambdabot> Title: software.dev  Blog Archive  Phising Exploit Discovered in &#8216;Google Publ ...
19:43:59 <dmwit> Or maybe that isn't what you were talking about...
19:44:12 <dmwit> If you mean spam. =P
19:44:25 <dmwit> I'm 0 for 3 tonight, maybe I should just go to bed. ;-)
19:45:22 <dmwit> ?hoogle [a] -> [a] -> [a]
19:45:23 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
19:45:23 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:45:23 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
19:45:38 <dmwit> ?hoogle alternate
19:45:38 <lambdabot> No matches found
19:45:56 <AstralStorm> ?hoogle assert
19:45:56 <lambdabot> Control.Exception.assert :: Bool -> a -> a
19:45:57 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
19:45:57 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
19:46:52 <Tela> Hmm. What's the big deal with data and newtype. Why would I use one or the other?
19:48:48 <AstralStorm> Read the doc, it will be obvious :>
19:49:35 <Tela> hoogle sent me to a page that says "newtype: please write this" :)
19:50:07 <SamB> Tela: use newtype when you can and otherwise use data ;-)
19:51:58 <vincenz> This rocks
19:51:59 <vincenz> http://lazyrussian.com/2006/09/15/freaky-friday-episode-3-teddy/
19:52:02 <lambdabot> Title: Lazyrussian Productions  Freaky Friday - Episode #3 - T.E.D.D.Y., http://tinyurl.com/husk8
19:52:03 <SyntaxNinja> edwardk: got shapr yet?
19:52:34 <SyntaxNinja> if ICFP folks like Igloo, shapr, edwardk, kosmikus or bringert show up, I'm not going to go out tonight, want to put finishing touches on my talk.
19:52:59 <SyntaxNinja> kosmikus: I'll try to show up around 7:30 tomorrow, we should talk a little bit about session-chairhood and such.
19:53:18 <SyntaxNinja> to those of you NOT in portland, we wish you were here :)
19:53:39 <dmwit> > (x,) z
19:53:40 <lambdabot>  Parse error
19:53:45 <dmwit> > (,) x z
19:53:45 <lambdabot>  Not in scope: `z'
19:53:53 <dmwit> > (1,) 2
19:53:53 <lambdabot>  Parse error
19:53:59 <dmwit> > ((,) 1) 2
19:54:00 <lambdabot>  (1,2)
19:54:41 <dons> Tela: check here http://haskell.org/haskellwiki/Keywords
19:54:42 <lambdabot> Title: Keywords - HaskellWiki
19:54:45 <dons> its an updated page.
19:55:24 <Tela> Ah, sweet. Thanks
19:56:28 <dons> hoogle will point to this new page soon
19:56:36 * SyntaxNinja &
19:56:44 <SyntaxNinja> dons: you not coming this year?
19:57:14 <dons> no wasn't able to get there. pacific is just too big :/
19:57:18 <SyntaxNinja> :(
19:57:22 <SyntaxNinja> ok ttyl
19:57:22 * SyntaxNinja &
19:57:25 <dons> night
19:58:05 <dons> heh, we cracked 300k views of the haskell.org page, for the year so far, today
19:58:26 <dons> some 1.5M page views all up this year
20:00:04 * stepcut is confused
20:00:44 <dons> 1.5M page views across the whole wiki, 300k of just the front page: people typing "haskell.org"
20:00:51 <stepcut> ah
20:00:53 <stepcut> cool
20:01:44 <stepcut> Some one posted states for the different monad tutorials a while ago -- they page views where much higher than I would have imagined
20:05:15 <araujo> writing monads papers is a branch of functional programming
20:12:14 <vincenz> Damn
20:12:27 <vincenz> :(
20:19:13 <dons> ?yow!
20:19:13 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
20:19:31 <vincenz> This is sad news
20:19:33 <vincenz> :(
20:19:36 <vincenz> dons: you hear?
20:19:52 <vincenz> @localtime dons
20:19:54 <lambdabot> Local time for dons is Sun Sep 17 13:19:30 2006
20:20:43 <dons> yes?
20:20:58 <dons> what's wrong, vincenz ?
20:21:04 <lispy> dons: he means, did you hear about lilo?
20:21:23 * vincenz nods :/
20:21:23 <dons> :(
20:21:24 <lispy> dons: he was hit by a bike on the 12th and passed away on the 16th
20:21:33 <lispy> sad sad sad
20:21:36 <dons> terrible.
20:21:48 <vincenz> I talked to him once, briefly, cause he was always so cheerful helping when things went wrong
20:21:51 <vincenz> that was one friendly gu
20:21:52 <vincenz> guy
20:22:19 <lispy> yeah, even i was really pissed about something he was really nice to me
20:22:53 <dons> he helped us out in here for many years, way back to the early days of #haskell
20:23:04 <vincenz> @karma+ lilo
20:23:05 <lambdabot> lilo's karma raised to 1.
20:23:39 <stepcut> lilo++
20:24:04 <lispy> lilo++
20:27:19 <Adamant> lilo++
20:29:07 <araujo> lilo++
20:30:14 <Lemmih> lilo++
20:32:38 <dons> he had been helping us in just the past few days too, with Cale's troll. so sad
20:32:42 <dons> lilo++
20:36:36 * araujo knew lilo since this network was openprojects
20:37:39 <araujo> And around 2 weeks ago he was helping me to fix some problems :-(
20:58:35 <zarvok> vincenz: you coming to ICFP?
21:01:05 <vincenz> zarvok: nope
21:01:13 <zarvok> too bad
21:01:34 <zarvok> I may not make it either, if I can't get this grading done ;)
21:01:38 <vincenz> zarvok: :/
21:01:42 <vincenz> zarvok: too far for me
21:01:49 <vincenz> zarvok: when are results coming out?
21:01:54 <vincenz> and the toolset!
21:01:57 <zarvok> vincenz: yeah, I guess it is quite a ways
21:02:30 <zarvok> vincenz: The results are announced at the talk tuesday, at that point we'll make available a tech report with loads of details
21:02:49 <zarvok> vincenz: the code will be made available then or shortly after depending on whether or not we can get our act together :)
21:03:34 <vincenz> :)
21:03:56 <zarvok> lots of cleanup left ot be done, plus we're adding a few things for the final release
21:04:03 * vincenz nodnods
21:04:08 <vincenz> when will the slides for the talk be online?
21:04:23 <zarvok> Tuesday night, PDT, I think
21:04:59 <zarvok> unless we start drinking too early
21:05:16 <zarvok> :)
21:05:46 <zarvok> but yeah, we'll be distributing hard copies of a tech report and I think it should be online during or after the talk
21:05:57 <vincenz> cool
21:07:07 <dons> great work zarvok
21:07:34 <zarvok> dons: thanks, we're really happy with how it all turned out
21:07:37 <dons> the cmu guys have done a good job this year
21:07:54 <dons> yep. its been really well organised and run.
21:08:36 <zarvok> we're excited for the talk, it should be a lot of fun
21:08:53 <Sal> #join
21:09:41 <zarvok> you coming, dons?
21:09:56 <zarvok> I guess it's not exactly close for you either
21:10:36 <dons> no unfortunately. first i'll miss since starting my phd.
21:10:47 <zarvok> ah, too bad
21:10:49 <dons> good incentive to write more papers for next year's icfp :)
21:10:53 <zarvok> heh
21:11:24 <dons> yeah, basically the only way I can get to these things is by getting a paper in
21:11:39 <zarvok> yeah, I imagine most people are in that boat
21:11:51 <hyrax42> hm
21:11:58 <hyrax42> where is that nifty fold/scan png
21:12:03 <hyrax42> that shows the effects
21:12:18 <dons> hyrax42: hmm, was it mentioned in this channel recently?
21:12:29 <dons> i could check the logs quickly for you, if you give me some keyword to grep for :)
21:12:34 <hyrax42> oh no no
21:12:42 <hyrax42> I think I bookmarked it
21:12:49 <hyrax42> just I think I came across a situation wherfe I want a scan
21:12:53 <hyrax42> for the first time
21:13:06 <dons> well, its like a fold, but you see all the intermediate results too
21:13:11 <dons> so good for things like fibs
21:13:39 <dons> scanl is under appreciated
21:13:57 <hyrax42> ok yeah that's what I want
21:14:23 <hyrax42> @type (id *** (+))
21:14:24 <lambdabot> forall b b'. (Num b') => (b, b') -> (b, b' -> b')
21:15:13 <hyrax42> @index date
21:15:14 <lambdabot> bzzt
21:15:23 <hyrax42> @index time
21:15:24 <lambdabot> bzzt
21:16:36 <hyrax42> there was this relaly cool png
21:16:47 <hyrax42> that showed how the scans and folds acted on a list
21:16:49 <hyrax42> ah well
21:19:24 <hyrax42> hm a google shows it did exist on cale.yi.org
21:19:28 <hyrax42> but doesn't anymore
21:19:34 <hyrax42> aanyroad
21:20:21 <hyrax42> @type max *** (+)
21:20:22 <lambdabot> forall b b'. (Ord b, Num b') => (b, b') -> (b -> b, b' -> b')
21:21:33 <hyrax42> hm I wanted (b,b') -> (b,b') -> (b,b')
21:21:47 <dons> ?pl \n -> (n+1, n)
21:21:48 <lambdabot> (,) =<< (1 +)
21:23:24 <hyrax42> reader?
21:24:17 <dons> ?type (,) =<< (1 +)
21:24:18 <lambdabot> forall b. (Num b) => b -> (b, b)
21:24:31 <dons> looks like reader, yeah.
21:40:59 <vincenz> dons: you use bsd or linux?
21:42:43 <dons> bsd
21:42:53 <vincenz> dons: which flavour
21:43:00 <dons> ?version
21:43:01 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
21:43:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:43:05 <vincenz> ah
21:43:06 <vincenz> why?
21:43:23 <dons> i found the system a lot simpler, cleaner and easier to understand than linux or freebsd
21:43:30 <vincenz> does it come with good packages?
21:43:32 <vincenz> up to date?
21:43:39 <dons> the user land is developed concurrently with the kernel, keeping everything in good shape
21:43:52 <dons> it has many pakcages, though some notable linux-only stuff doesn't run
21:43:55 <dons> skype, for one.
21:43:57 <vincenz> which version of ghc does it ship with
21:44:18 <dons> it comes with 6.2.2 atm, but they any ghc should build out of the box
21:44:28 * vincenz nods
21:44:32 <vincenz> Maybe I'll give it a try
21:44:45 <vincenz> I got a windows partition to empty
21:45:02 <dons> its _not_ an ubuntu or gentoo -- you can expect to be editing files in /etc to do configuration. however, mosty the default set up "just works"
21:45:09 * vincenz nods
21:45:13 <vincenz> Well I'm on a laptop o.O
21:45:20 <dons> me too :)
21:45:28 <vincenz> ah good :0
21:45:30 <vincenz> Anyawys
21:45:33 * vincenz ships off to lalaland
21:45:49 <dons> don't forget your visa and passport
21:45:58 <vincenz> And cavity search?
21:46:03 <dons> that too
21:46:15 <vincenz> check this out, it's really neat
21:46:17 <vincenz> http://lazyrussian.com/2006/09/15/freaky-friday-episode-3-teddy/
21:46:19 <lambdabot> Title: Lazyrussian Productions  Freaky Friday - Episode #3 - T.E.D.D.Y., http://tinyurl.com/husk8
21:46:21 <vincenz> the video
21:46:27 <vincenz> they also link to a site with the java app
21:46:52 * vincenz &
21:50:02 <gmh33__> @bf .+[.+].
21:50:02 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
21:51:50 <hyrax42> whic of the scans can return lazily
21:51:55 <hyrax42> scanr or scanl
21:51:59 * hyrax42 thinks r
21:52:08 <dons> scanr is going to try to get to the end of the list though ....
21:52:10 <mauke> I think l
21:52:24 <hyrax42> oh ok
21:52:29 <hyrax42> hm
21:52:33 <hyrax42> @type scanl
21:52:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:52:42 <deadbeef> omg
21:52:46 <deadbeef> lilo has passed away
21:53:18 <dolio> > fix ((1:) . scanl (+))
21:53:19 <lambdabot>    Expecting a function type, but found `b'
21:53:19 <lambdabot>    Expected type: a1 -> [a]
21:53:19 <lambdabot> ...
21:53:25 <dolio> > fix ((1:) . scanl (+) 1)
21:53:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:53:29 <dolio> > fix ((1:) . scanr (+) 1)
21:53:30 <lambdabot>  Exception: <<loop>>
21:53:41 <hyrax42> @type fix
21:53:42 <lambdabot> forall a. (a -> a) -> a
21:54:32 <hyrax42> :?
21:54:47 <hyrax42> what does that do
21:54:47 <dolio> fix f = f (fix f)
21:55:03 <dolio> It's the y combinator for recursion.
21:55:34 <dons> > fix (:1)
21:55:35 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
21:55:35 <lambdabot>    Expected...
21:55:41 <dons> > fix (1:)
21:55:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:56:00 <dons> every language should have a recursion combinator
21:56:11 <mauke> wait, is that the same as fix f = let x = f x in x?
21:56:15 <dons> yep
21:56:29 <dons> fix :: (a -> a) -> a
21:56:29 <dons> fix f = let x = f x in x
21:56:36 <Tela> I like how available the y combinator is in Haskell.. It's a pain to write in a lisp.
21:56:57 <dons> > mfix (1:)
21:56:58 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
21:56:58 <lambdabot>    Expected...
21:57:10 <dolio> "fix f = let ..." is how it's actually defined in Control.Monad.Fix, right?
21:57:15 <dons> yep
21:57:20 <dons> i just pasted the src above
21:57:29 <mauke> whoa
21:57:33 <dons> ?source Control.Monad.Fix
21:57:33 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
21:57:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:57:35 <dolio> Yeah, i figured that's what you were doing.
21:57:38 <dons> doh i'll fix that.
21:57:45 <dolio> Heh.
21:57:51 <hyrax42> ok so dolio's ends up being equivalent to
21:58:07 <hyrax42> > scanl (+) 1 $ repeat 1
21:58:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:58:10 <mauke> ((a -> b) -> a -> b) -> a -> b with a' = a -> b
21:58:12 <hyrax42> nope
21:58:15 <hyrax42> poop
21:58:19 <hyrax42> ohh
21:58:25 <dolio> What's mfix? mfix f = let x = x >>= f in x?
21:58:36 <dons>     mfix :: (a -> m a) -> m a
21:58:40 <dolio> Or is it tied to the monad?
21:58:40 <dons> instance MonadFix [] where
21:58:41 <dons>     mfix f = case fix (f . head) of
21:58:41 <dons>                []    -> []
21:58:41 <dons>                (x:_) -> x : mfix (tail . f)
21:58:48 <dons> instance MonadFix IO where
21:58:48 <dons>     mfix = fixIO
21:58:48 <dons> instance MonadFix ((->) r) where
21:58:48 <dons>     mfix f = \ r -> let a = f a r in a
21:58:51 <dolio> Ah, yeah.
21:59:30 <dons> > mfix (\a -> return a)
21:59:31 <lambdabot>  add an instance declaration for (Show (m a))
21:59:34 <hyrax42> > fix ((1:) . scanl1 (+))
21:59:35 <lambdabot>  [1,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072...
22:00:11 <hyrax42> ugh too late for this
22:00:13 <hyrax42> night all
22:00:29 <dolio> Hmm...
22:00:30 <mauke> basically, it feeds the result back into the function
22:00:53 <mauke> this works because the first element is always 1
22:01:05 <dolio> > fix (scanl (+) 1)
22:01:06 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
22:02:29 <Tela> There's some clever way to define a "pure lambda-calculus" factorial using it. It's totally too late for me to figure it out though.
22:03:11 <mauke> > fix (\f x -> if x < 2 then 1 else x * f (x - 1)) 5
22:03:12 <lambdabot>  120
22:03:41 <Tela> bingo. :)
22:04:21 <Tela> Now to do it with church numerals...
22:04:46 <dolio> Yeah, that works for self recursive functions in general. Add a function argument to the start, and call said function instead of yourself recrusively.
22:04:51 <dolio> Then use Y to make it recursive.
22:06:10 <dolio> Plus, if you write all your recursive functions that way, you can substitute in dp from memoizing recursion on the haskell wiki, and get a free dynamic programming solution. :)
22:07:09 <Tela> @wiki memoizing recursion
22:07:09 <lambdabot> http://www.haskell.org/haskellwiki/memoizing recursion
22:07:24 <Tela> pah
22:09:15 <mauke> dolio: url?
22:09:32 <Tela> http://www.haskell.org/hawiki/MemoizingRecursion
22:09:35 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki, http://tinyurl.com/gjxoc
22:09:38 <dolio> The one lambdabot just gave is correct, except for the space.
22:09:54 <Tela> it's on the old wiki, though
22:12:02 <dons> ?google site:haskell.org memoizing recursion
22:12:04 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-July/010715.html
22:12:05 <lambdabot> Title: [Haskell-cafe] Re: Coin changing algorithm
22:12:08 <dons> bah
22:15:03 <Tela> On the topic of memoization... How "automatic" is it due to laziness?
22:15:19 <mauke> awesomely automatic
22:15:35 <mauke> oh, you mean completely automatic ...
22:16:01 <Tela> well, the dp example wouldn't exist, I'd hope, if it was completely, totally, ineffably automatic
22:16:18 <Tela> unless I'm just not looking at it closely enough
22:16:18 <dolio> You have to set up self-referrential data structures.
22:16:34 <mauke> AFAIK there is no automatic memoizing
22:17:25 <dolio> But it's nice to not have to explicitly loop up to your solution in a dynamic programming algorithm.
22:17:45 <Tela> Ah :)
22:18:29 <dolio> It'd be nicer if the compiler could automatically rewrite a naive fibonacci implementation into a memoized one though. :)
22:18:41 <dolio> I've heard stories of compilers that can do that. :)
22:19:25 <dolio> That has fairly obvious shared sub graphs, though, so I don't know how effective/useful such a facility would be in general.
22:20:48 <dolio> I seem to remember hearing that Clean had some support for that kind of thing, but I don't know if that's true or not.
22:26:20 <glguy> If the compiler always memoized function calls... performance would take a hit
22:26:29 <glguy> that's my two cents (c:
22:26:44 <dolio> Yeah, I don't think it's always worthwhile.
22:27:16 <dolio> The idea is that the compiler looks at the call graph for the functions, and combines common sub-graphs.
22:27:35 <dolio> So since fib (n - 2) occurs in fib (n - 1), you combine those into one graph.
22:28:28 <glguy> What that business in Clean that has a graph rewriting syntax? (what's a graph rewriting syntax)
22:29:34 <dolio> I don't really recall the specifics. This was a few years ago when I was first flirting with functional programming in general.
22:30:58 <dolio> I imagine it's a lot like the idea that all purely functional code can automatically be parallelized because it's referrentially transparent. Sounds good in theory, but it turns out to not be feasible/useful in practice.
22:31:40 <Tela> Ack! You're ruining my delusions! ;)
22:32:04 <mauke> hmm, how can CSE cause space leaks?
22:32:13 <dolio> :) Well, there's still parallel haskell and evaluation strategies. That's better than writing it all out explicitly.
22:35:52 <dons> for fun, colorised prelude and list libraries. any comments?  --> first 3 items listed in http://haskell.org/haskellwiki/Example_code
22:35:54 <lambdabot> Title: Example code - HaskellWiki
22:36:07 <dons> is it useful to see that code colorised?
22:44:31 <Tela> I just have to say... "Prelude" is the best name for a core feature set I've ever heard of. That just dawned on me.
22:45:26 <dons> heh
23:29:35 <dons> ?users #haskell
23:29:37 <lambdabot> Maximum users seen in #haskell: 236, currently: 207 (87.7%), active: 19 (9.2%)
23:30:29 <gour> is there some lib for generating pdfs (eg. database reports) ?
23:32:51 <gour> ..like reportlab (http://www.reportlab.org) in haskell
23:32:53 <lambdabot> Title: ReportLab - Open Source Software
23:33:37 <dons> not that I know of. there' was one in the past (check haskell.org's libraries and tools page)
23:33:47 <dons> there maybe be a new one now, or you could write a binding to xpdf's lib
23:34:29 <gour> is it possible to eg. use missingpy to interface reprotlab?
23:35:46 * gour has to dive in writing some bindings with c2hs, finally
23:42:12 <gour> does anyone use missingpy to interface haskell with python?
23:43:09 <sieni> gour: I don't know, but I'd say that my guess is "no"
23:43:09 <dons> CosmicRay does, I think
23:43:22 <dons> not widely used though
23:43:50 <sieni> doesn't python have a relatively nice c interface? can't you just use ffi to call that?
23:43:58 <gour> sieni: why not? python has many libs that are haskell missing here
23:44:35 <gour> sieni: probably, i jsut want to hear some experience
23:45:04 <gour> reportlab looks like a good lib
23:46:01 <dcoutts__> I expect that in many cases it's easier to bind to an equivalent C lib or to just port to Haskell
23:46:19 <dons> and you'll get faster code as a result..
23:47:03 <dcoutts__> btw, I've got some zlib compression & decompression working :-)
23:47:08 <gour> dcoutts__: do you know for some equivalent?
23:47:21 <dcoutts__> gour: I don't know what reportlib does
23:47:34 <gour> http://www.reportlab.org
23:47:35 <lambdabot> Title: ReportLab - Open Source Software
23:48:32 <sieni> dcoutts__: well, when I looked at it, importing python libraries from c was relatively easy, so I see a point of calling them directly (as opposed to perl, whose ffi is a insane)
23:49:21 <dcoutts__> fair enough
23:51:16 <sieni> and anyway, if you find that a c library that has been bound to haskell does the job for you, you might be more motivated to provide haskell bindings
23:55:28 <bourbaki> moin
23:56:04 <Bott1> Does "The Haskell School of Expression: Learning Functional Programming through Multimedia" have exercises?
23:57:16 <Bott1> of the sort that might convince my programming teacher that I am actually doing something
23:57:30 <Bott1> (VB, and he's not good at it at all)
23:57:37 <dcoutts__> I think it does have exercises
23:57:46 <Bott1> cool
