00:01:24 <goltrpoat> who was that rational trigonometry guy
00:01:40 <jrmole> C has no rational trigonometry!
00:02:00 <goltrpoat> that guy took trolling to like.. international level.
00:02:00 <Adamant> I thought it was real time.
00:02:15 <dolio> Norman Wildberger?
00:02:19 <dolio> Says wikipedia.
00:02:29 <goltrpoat> dolio:  yeah him.
00:02:48 <Adamant> international level trolling
00:03:01 <Adamant> anyone remember Abel of Iowa State?
00:03:14 <dolio> I wasn't too impressed with the chapter I read of his book.
00:03:26 <Adamant> he trolled the science newsgroups for years.
00:03:33 <Adamant> and math.
00:03:42 <dolio> It might make trig easier, but once you get to calculus, you need all the trig functions anyway.
00:03:42 <goltrpoat> what about the archimedes guy
00:03:51 <goltrpoat> archimedes uh.. can't remember what his "last name" was
00:03:57 <dolio> Plutonium.
00:03:59 <goltrpoat> yes!
00:04:02 <Adamant> plutonium? people think is really like that, not trolling.
00:04:02 <goltrpoat> that was classic.
00:04:09 <dolio> I have his wikipedia entry bookmarked. :)
00:04:15 <Adamant> net.kook, not troll.
00:05:00 <goltrpoat> http://groups.google.com/group/sci.math/msg/b16c0857d09ccb6f (note he's replying to john baez :) )
00:05:03 <lambdabot> Title: Google Groups: sci.math, http://tinyurl.com/qlwby
00:05:50 <goltrpoat> i think wiles is in the thread as well
00:06:05 <goltrpoat> "instead i pity them for i realize well that they will never amount to anything important in physics or math"
00:06:05 <goltrpoat> hehe
00:06:32 <goltrpoat> i don't know what baez or wiles were doing in 93, but they're doing fairly well for themselves these days.
00:06:47 <Adamant> was Andrew Wiles on that thread too?
00:06:51 <Adamant> lol, hot damn!
00:12:52 <dibblego> wasn't that the guy that proved Fermat's thereom?
00:17:00 <goltrpoat> indeed.
00:17:40 <lispy> wiles is interesting
00:17:53 <lispy> he's tried to prove that theorem and failed many times
00:17:58 <lispy> or at least several
00:18:20 <Adamant> he got interested in math because he wanted to solve that theorem.
00:18:35 <lispy> but this most recent time seems to have stuck, although i tried to find the proof (reportedly very long) and i couldn't find it an my uni's library
00:18:43 <Adamant> at least according to the hivemind Wikipedia.
00:18:50 <lispy> lol
00:18:55 <lispy> nice description of wikipedia
00:19:02 * therp read the "fermant's last theorem" book. nice read.
00:21:50 <lispy> therp: url?
00:22:07 <dibblego> it is written by Somin Singh
00:22:09 <dibblego> *Simon
00:22:18 <dibblego> it is a bit sensationalist - I've read all of his books
00:22:30 <Adamant> Simon's "The Code Book" is also good, if you're into crypto.
00:22:40 <lispy> hmm... had a friend in HS by the surname of Singh...doubt he was related tohugh :)
00:23:06 <lispy> recently (meaning tonight) i've been into information theory
00:23:13 <Adamant> Singh is a common Sikh and non-Sikh Indian name.
00:23:15 <lispy> an the applications to journalism
00:23:18 <therp> lispy: http://www.amazon.com/Fermats-Last-Theorem-Simon-Singh/dp/1841157910
00:23:28 <lispy> therp: thanks
00:24:19 * lispy feels he needs to read the one by hardey about the appology
00:27:15 <lispy> i need to read the apology and GEB
00:27:35 <lispy> and i should go to sleep soon :)
01:41:30 <RobHu> newbie question... Using the IO monad I can get strings with  str <- getLine
01:41:39 <RobHu> how can I turn that into something other than a string?
01:41:41 <RobHu> I've tried
01:41:48 <RobHu> let thing = read str
01:41:50 <RobHu> but it doesnt like that
01:41:55 <dons> yep, that's how you do it
01:42:05 <RobHu> hmm
01:42:18 <dons> ?type do s <- getLine ; let y = read s :: Int ; return y
01:42:19 <lambdabot> parse error (possibly incorrect indentation)
01:42:44 <dons> ?type do s <- getLine ; let y = (read s :: Int) in return y
01:42:46 <lambdabot> IO Int
01:42:57 <dons> ?type do s <- getLine ; let y = (read s :: Int) ; return y
01:42:59 <lambdabot> parse error (possibly incorrect indentation)
01:43:03 <Stinger_> lambda bot didnt like the let syntax at one point yeah
01:43:14 <dons> yeah, seems like the Language.Haskell parser is a bit silly
01:43:18 <Stinger_> lambdabot*
01:43:28 <dons> ?. pl undo do s <- getLine ; let y = (read s :: Int) ; return y
01:43:29 <lambdabot> (line 1, column 21):
01:43:29 <lambdabot> unexpected "{"
01:43:29 <lambdabot> expecting variable, "(", operator or ")"
01:43:37 <dons> ?undo do s <- getLine ; let y = (read s :: Int) ; return y
01:43:37 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 53}) "Parse error"
01:44:00 <dons> ?undo do s <- getLine ; return (read s)
01:44:01 <lambdabot> getLine >>= \ s -> return (read s)
01:44:06 <dons> ?. pl undo do s <- getLine ; return (read s)
01:44:06 <lambdabot> read `fmap` getLine
01:44:09 <dons> :)
01:44:17 <dons> RobHu: makes sense?
01:44:25 <Stinger_> heh
01:44:41 <dons> ?. type . pl undo do s <- getLine ; return (read s)
01:44:43 <lambdabot> forall a. (Read a) => IO a
01:45:00 <RobHu> dons: Yes thats great thanks
01:48:21 * edwardk waves hello.
01:49:20 <ski> ?type do s <- getLine; let {y = read s :: Int}; return y
01:49:22 <lambdabot> Int}; return y :: IO Int
01:49:31 <ski> ?type (do s <- getLine; let {y = read s :: Int}; return y)
01:49:32 <lambdabot> IO Int
01:50:19 <ski> (problem with not using layout there, is that 'let' wants to eat as many declaration items as possible)
01:50:24 <Cale> @type readLn
01:50:26 <lambdabot> forall a. (Read a) => IO a
01:51:06 <ski> (and apparently, that bug in lambdabot 'type' isn't fixed, yet ..)
01:51:18 <dons> :)
01:51:21 <dons> yay for regexes
01:51:25 <dons> ski, submit a patch!
01:51:46 <dons> it's easy! it's fun!
01:52:09 * ski doesn't like regices
01:52:50 <dons> so commit some regicide then...
01:53:54 <lambdabot> you can't kill my regicies! I am the QUEEN of the FINITE STATE!
01:54:23 <therp> do I need to deal with infinite/recursive types when thinking about haskell typing?
01:54:42 <dons> hmm, you mean like [a] ?
01:54:51 <Cale> therp: Infinite types aren't allowed. Infinite values are.
01:55:00 <therp> I mean like data List a = Nil | Cons a (List a)
01:55:02 <dons> data [] a = [] | a : [a]
01:55:07 <Cale> yes
01:55:11 <Cale> that's allowed :)
01:55:14 <dons> a recursive type, for an infinite structure
01:55:40 <dons> infinite _types_ are bad on the compiler ;)
01:55:41 <therp> dons: yes, I just recognized that [a] is "equal" to what I have given.
01:55:43 <Cale> @type [1..]
01:55:45 <lambdabot> forall a. (Num a, Enum a) => [a]
01:55:57 <Cale> > [1..]
01:55:57 <therp> ok, then remove infinite from my question :)
01:55:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:56:15 <Cale> yes, recursive types are all over the place
01:56:35 <dons> ?type let f g = g f in f
01:56:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1) -> t1
01:56:36 <lambdabot>    Expected type: t
01:56:49 <therp> I haven't found any special treatment of recursive types in the typing haskell in haskell paper, although chapter 20/21 of types and programming languages (pierce's book) seems to require a bit of theory when using recursive types
01:57:05 <dons> therp: Bob Harper's book is also good on recursive types
01:57:08 <dons> let me see....
01:57:28 <dons> here, http://www-2.cs.cmu.edu/~rwh/plbook/
01:57:30 <lambdabot> Title: Index of /~rwh/plbook
01:57:30 <therp> ah another reference! a gift from heaven
01:57:35 <dons> ?where+ plbook http://www-2.cs.cmu.edu/~rwh/plbook/
01:57:35 <lambdabot> Done.
01:57:54 <dons> and up to date, 31-Aug-2006 15:31   904k
01:58:31 <edwardk> therp: they use equirecursive, not isorecursive types at first in TAPL, haskell uses the latter.
01:58:47 <therp> dons: sounds very good (skimming over the TOC)
01:59:45 <dons> check chapter 18, Recursive Types
01:59:47 <therp> edwardk: I was just wondering because I haven't made it through the theory of TAPL about recursive types but would have expected to found some of it in the typing haskell in haskell paper
01:59:50 <dons> though you'll want to read all of it :)
01:59:55 <therp> dons: spotted already
02:00:19 <dons> Cale, have you read Bob's book?
02:00:26 <Cale> Bob?
02:00:30 <therp> dons: I got my neat new kyocera duplex printer last week. harhar, /me pressed the print button
02:00:33 <dons> harper, above.
02:00:40 <dons> heh
02:00:44 <therp> dons: thanks :)
02:00:55 <dons> Cale, http://www-2.cs.cmu.edu/~rwh/plbook/ <-- I meant.
02:00:57 <lambdabot> Title: Index of /~rwh/plbook
02:00:58 <Cale> sorry, I've only been watching the channel intermittently :)
02:01:00 <Cale> yeah
02:01:01 <dons> :)
02:01:05 <dons> ah good
02:02:20 <Cale> Oh, I don't mean that I've read it
02:02:22 <Cale> hehe
02:02:41 <Cale> It looks like a decent book though
02:02:59 <dons> oh, maybe its worth peeking at, a bit mathy-er than your usual PL book
02:03:49 <dons> and how many other textbooks talk about both concurrency and curry-howard
02:06:56 <edwardk> printing it now
02:06:58 <Pupeno> hello.
02:06:59 <lambdabot> Pupeno: You have 1 new message. '/msg lambdabot @messages' to read it.
02:08:46 <Pupeno> Cale: thanks.
02:08:55 <Cale> Pupeno: no problem
02:12:09 <edwardk> say i needed to keep a tight leash on allocation and deallocation of certain things but wanted to implement the code in haskell anyways out of perversity, what would you advise?
02:12:21 <dons> explicitly malloc/free?
02:12:34 <dons> or use Foreign.Ptr and friends
02:12:37 <edwardk> can i malloc/free and then use the space as a haskell memu-thunk?
02:12:45 <edwardk> er memo
02:12:53 <dons> you can malloc and attach a free finaliser
02:13:07 <edwardk> but i can't control deallocation then?
02:13:15 <dons> you can if you explicitly free, yes
02:13:24 <dons> but what, you want a thunk in there?
02:13:28 <edwardk> yeah
02:13:53 <dons> not sure. I _suppose_ if your type is storable there's some ffi support for this kind of stuff
02:14:00 <edwardk> it did preface this with 'out of perversity' =)
02:14:03 <eivuokko> Is there?
02:14:38 <eivuokko> As, out of perversity, I wanted to build thunks myself when playing with asm generation, and I couldn't see cool way to do that.
02:14:39 <edwardk> was trying to see if i could model the linear stuff in haskell, now that i have the AST and stuff there, rather than generating code
02:14:43 <eivuokko> (This is with ghc)
02:15:10 <edwardk> wonder if unsafecoerce could be used with knowledge of how the STG stores the actual thunk
02:15:51 <edwardk> i will probably have to give up and generate c/c++
02:15:53 <eivuokko> You need to build infotables and alloc memory so that gc can handle it, and while buildin the block, you have to be sure there's no gc.  I think.
02:16:10 <edwardk> yeah
02:16:44 <goltrpoat> dons:  thanks for the link btw
02:16:46 <edwardk> well, these items in particular would need no gc, i can guarantee their access patterns, even w.r.t call-by-need
02:17:20 <edwardk> they might interact strangely with the root set if i allow them to hold normal haskell references though
02:17:49 <edwardk> guess it isn't worth it
02:17:53 <edwardk> but it would have been fun
02:18:03 <edwardk> seeing real linear types in haskell
02:19:13 <edwardk> i'll just generate c
02:19:46 <edwardk> my efforts at dynamically producing haskell have been dodgy at best anyways ;)
02:23:08 <goltrpoat> i wrote this compiler a while back for a DSL that i designed for a fairly specific and fairly important task, right.  i ended up with this c++ subset meets call/cc and first-order functions for a specific function type.  compiles to this x86 subset that i wrote a vm for, this was about two and a half years ago.
02:23:16 <goltrpoat> trouble is, i had absolutely no clue about languages when i wrote it
02:23:46 <edwardk> i was curenty planning on using a VM close to the ABC machine for charity
02:23:57 <goltrpoat> so ive been trying to figure out a way to spring on my partners the fact that i could probably rewrite it from scratch in about a week, and make it ten times more powerful
02:24:16 <edwardk> since i need approximately equal support for CBV and CBneed evaluation
02:24:32 <edwardk> heh
02:24:36 <goltrpoat> i actually wrote the compiler in c++.
02:25:00 <goltrpoat> i pulled up the code a few weeks ago, it was somewhat amusing.
02:25:04 <edwardk> every compiler you write you learn more about the process
02:25:18 <edwardk> i have buried almost all of my early efforts in this arena for that reason ;)
02:26:42 <edwardk> i found one of my first interpreters the other day, for a variation on m4 with dbm manipulation capabilities that i used to run my video store off of
02:26:47 <edwardk> scary scary stuff =)
02:28:08 <edwardk> old school C, turned off buffering on the IO so using it to serve pages brought the server to its knees, gigantic case statements... er.. that latter one i guess i tend to still do =(
02:28:23 <goltrpoat> i think the first interpreter i tried to write, i was 12 or so, and i picked up charles wetherell's 'etudes for programmers', right.  speaking of which, i hope they reissue that book at some point, it was freaking brilliant.  anyway, one of the exercises was a PL/I compiler, which i couldn't pull off, but that gave me the idea to write a BASIC interpreter.
02:28:30 <goltrpoat> that didn't go too well, but was fun while it lasted.
02:29:01 <edwardk> i wrote a basic intepreter in asm back in the c64 days.
02:29:17 <edwardk> but that was coz one of the first big programs i got my head around was the c64 basic rom's internals.
02:29:31 <edwardk> so it seemed like a natural evolution to write a better basic
02:29:33 <goltrpoat> several interpreters and compilers for small DSLs afterwards, and then the beast came along.
02:30:11 <goltrpoat> of course then i ended up writing a bunch of toy compilers in haskell once i picked it up, which is why writing one in c++ seems somewhat funny now
02:30:23 <Bluelive> never really tried interpretters, only compilers
02:30:40 <therp> edwardk: you said that haskell uses isorecursive types, have I understood you correctly?
02:30:53 <edwardk> after that it was some bbs internal scripting language, the horrible m4 thing, my ai script for a mud, and several computer algebra systems and would be programming languages. though the latter were mostly compiled.
02:31:02 <edwardk> therp: i did
02:31:24 <goltrpoat> oh, if you wrote an ai script for a mud, then that's probably fairly close to what i did for cinematix/eidos back in 99 or so
02:31:39 <goltrpoat> er.  ai scripting language, rather
02:31:48 <therp> edwardk: how does it come that no explicit unfold/fold is necessary then? I always thought that this is mandatory for iso-recursive types
02:32:52 <edwardk> therp: In { out :: f (Fix f) a } you have to pull stuff out with out
02:32:57 <goltrpoat> edwardk:  wait, are you saying you *wrote* m4?
02:32:58 <edwardk> you can view out/In as playing that role
02:33:06 <goltrpoat> or are we talking about a different m4
02:33:07 <edwardk> goltr: no, i wrote a variant =)
02:33:11 <goltrpoat> oh ok
02:33:37 <goltrpoat> cause that'd make you either kernighan or ritchie
02:33:38 <goltrpoat> haha
02:33:42 <edwardk> goltr: the goltr: lol
02:33:43 <goltrpoat> and that'd be just weird.
02:33:49 <edwardk> goltr: heh, not that old =)
02:34:29 <therp> edwardk: ah ok thanks :)
02:34:40 <edwardk> gah, one thing about functional programming is you start to write one language and you have to write 3.
02:35:02 <goltrpoat> or none, depending on how you look at it
02:35:13 <edwardk> i have a surface syntax, a intermediate language to desugar to, and i guess i'll need the abstract machine and compilation step.
02:35:21 <edwardk> *sigh*
02:35:30 <edwardk> all because i wanted to write the intermediate language =)
02:35:58 <goltrpoat> it still weirds me out that gcc uses a lisp-style rtl as an il
02:36:42 <edwardk> yeah
02:36:48 <therp> edwardk: ah, I'm trying to design a simple/minimalistic desugared language for program synthesis purposes. what do you have in mind for your intermediate language? I have looked a bit at GHC Core
02:38:04 <therp> I've let for polymorphism/lambda/function application/algebraic types and case for flow control and data type selection.
02:38:09 <edwardk> therp: well, in my case i'm doing all sorts of substructural type things, so no existing model really fits
02:38:09 <goltrpoat> that was another thing that was bad about my compiler.  it went source to bytecode.  i made a lot of effort to make the backend swappable, and it'd be easy to port it to certain platforms, but very hard to port it to others (if we ever decide we need a native backend)
02:38:32 <edwardk> therp: so what i have can be pretty much described as a reformulation of a pure type system over linear logic with an extra uniqueness comonad.
02:38:48 <edwardk> if that sentence parses at all =)
02:39:21 <Bluelive> edwardk : what is the goal of the result ?
02:39:23 <edwardk> i've kinda burned out on bytecode
02:39:31 <therp> edwardk: maybe I can tell, when I finished looking up all unfamiliar terms :)
02:40:08 <edwardk> bluelive: getting linear/relevant/affine/unrestricted types, uniqueness types, and linear regions to play nice.
02:40:35 <Bluelive> i can tell the paper will be popular on LtU
02:40:37 <edwardk> bluelive: 'blazingly fast' functional programming with good memory management characteristics without gc
02:40:47 <edwardk> in otherwords =)
02:41:41 <Bluelive> without gc ? only local values and explicit deallocation ?
02:41:53 <edwardk> in place updates allowed while maintaining referential transparency, enforcable strictness annotations via relevant typing to enforce the space
02:42:22 <edwardk> bluelive: i do region based allocation, but the region capabilities are linear so i can show all regions get deallocated. i allocate substructural types in regions so my regions need not grow monotonically.
02:43:04 <Bluelive> so it does use gc, just not something lazy like mark-and-sweep
02:43:05 <edwardk> er and to finish that first sentence, 'to enforce the space usage characteristics the end-user expects'
02:43:30 <edwardk> bluelive: it explicitly allocates and deallocates pages in lists so it can do all collection in O(1) time
02:43:50 <edwardk> and the linear types clean up after themselves and need not be allocated via regions.
02:44:23 <Bluelive> i barely understand half of it, i like it :)
02:44:29 <edwardk> a region is like allocating a stack of things you can throw away all at once.
02:44:57 <edwardk> it just grabs another page from the freelist. think of it as mallocing in 4k chunks. and threading the chunks on a freelist.
02:45:04 <Bluelive> my goals are a bit lower, make a java-ish subset to try out a refcounting gc that works well
02:45:10 <edwardk> when you discard the region you just return the entire list of chunks to the global freelist.
02:45:18 <edwardk> i abhor reference counting
02:45:43 <gour> @where jhc
02:45:43 <lambdabot> http://repetae.net/john/computer/jhc/
02:45:49 <edwardk> the implications on caching and forced write throughs all over memory destroy performance pretty badly
02:45:51 <Bluelive> ah thats something i call 'lcokallocation' my linkedlists and hashsets us that to avoid loading the memorymanager
02:45:51 <gour> @where yhc
02:45:52 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
02:47:33 <Bluelive> edwardk : yes that is an issue, however the forced write throughs can be limited through threadlocal counters
02:48:13 <edwardk> when i have to gc i tend to do one of two things, either a simple generational copying collector if i control the whole language, or a forking mark-and-sweep collector, where i just fork the process at a consistent point and run the mark-sweep in one fork while the other executes, then tell the first process what pages to kill via IPC when done. the latter suffers some CoW overhead, but its pretty good in practice, and with mprotect w
02:48:34 <edwardk> and you can maintain a small grey set
02:49:16 <Bluelive> that is a pretty good scheme, i used an inline MaS but that kept thrashing the cache
02:50:00 <edwardk> generational copying works better for most purposes but you have to control the whole system.
02:50:23 <Bluelive> i want to play with refcounting, everybody says it's bad, but i want to look for myself, the eager dealloc is especially interresting
02:50:32 <edwardk> can't just drop into c for a quick bit and come back without complicated position locking
02:50:58 <edwardk> blue: thats what i use linear/affine for. i can say there is only a single reference and deallocate on first use.
02:51:09 <edwardk> with uniqueness i can update in place coz there is only a single reference as well
02:51:34 <edwardk> (slightly different semantics in all 3 cases though)
02:51:56 <Bluelive> well by using widereferences some immutbles dont get allocated, most other object kinds wont work with 1-bit refcouting
02:52:12 <edwardk> linear should be eager to update, affine should update lazily, uniqueness should also update lazily unless its a uniqueness relevant type, etc.
02:52:34 <Bluelive> it definitly sounds like an interresting project
02:52:47 <edwardk> doing the 1-bit refcount to avoid refcounting single use objects?
02:53:21 <Bluelive> ah sorry i thought you used that, you keep track of it by inferencing then ?
02:53:55 <edwardk> blue: in my case its all in the type system
02:53:59 <edwardk> blue: no runtime impact
02:54:29 <Bluelive> yeah that works better
02:54:30 <edwardk> blue: my type system forces in explicit weakening to discard the value
02:54:35 <edwardk> when i weaken i free
02:55:04 <edwardk> the only thigs that won't work for are unrestricted and relevant types,  and those rely on the region they are in being linear to get freed
02:55:14 <Bluelive> other thing im trying out is 'widereferences'
02:55:26 <edwardk> widereferences being references with baked in ref counts?
02:55:33 <Bluelive> no
02:55:39 <edwardk> explain?
02:55:55 <Bluelive> normally a reference is a pointer to a dynamcly allocated space starting with a pointer to a vmt
02:56:05 <edwardk> yeah
02:56:18 <edwardk> moving the vtable into the reference?
02:56:22 <Bluelive> however with wide references i pull the vmt pointer into the reference
02:56:29 <edwardk> actually did that before
02:56:32 <edwardk> it works ok.
02:56:36 <edwardk> good for modern cpus
02:56:42 <Bluelive> yes that allows me to use the rest of the reference either as a a pointer to a normal object, or as a 32bit storage
02:56:43 <edwardk> because you dont have a double dereference
02:57:28 <Bluelive> so immutable (value like) objects with 32bit or less storage don't need any allocation
02:57:35 <edwardk> you pay a pretty big memory footprint impact for it though
02:57:54 <edwardk> *nods*
02:58:03 <Bluelive> edwardk : the removal of the double deref also means the cache is loaded less
02:58:14 <edwardk> in my case i have no vmt in most cases, a stronger type system gets me by
02:58:43 <edwardk> without any gc in the system i need not worry about explicit type info being carried around to mark pointers either.
02:59:10 <Bluelive> edwardk : im not sure if the memory size really will increase, you reduce the size of objects with the same amount as the references increase, so only references that are unassigned or multiple reference to the same object are more expensive
02:59:17 <edwardk> in your case you can bake info if the reference's primary field a pointer or not into your vmt, so gc in your situation is fine
03:00:08 <Bluelive> the vmt pointer in the referece can be optimized away if it is clear there is only one possible value
03:00:16 <edwardk> every pointer in the system carries around its vtable, so even those stuffed in other objects. so a simple object with 4 pointers grows from 16 bytes to 32.
03:00:38 <Bluelive> yes
03:00:43 <edwardk> blue: but then you have to mix fat and thin references, fun fun =)
03:01:04 <Bluelive> anyways its all just toying about
03:01:06 <edwardk> not too painful, just a pita ;)
03:01:32 <Bluelive> the big reward is that i can have integers as 'real' objects without heapallocation
03:01:40 <edwardk> yeah
03:01:42 <edwardk> agreed
03:01:48 <edwardk> its very useful in your model
03:02:07 <edwardk> in my case i have no vtables coz i'm in functional programming land.
03:02:17 <Bluelive> could give me a very clean toplevel model, every value is an object
03:02:28 <edwardk> *nods*
03:02:43 <Bluelive> yes, maybe haskell will be my next project
03:03:49 <dons> hmm, did I just see Larry Wall talking to lambdabot in the lambdabot logs?
03:03:57 <edwardk> er i guess i do have something like a vtable in the codata (lazy) case.
03:03:59 <edwardk> hah
03:04:04 <edwardk> what'd he have to say? =)
03:04:10 <dons>  TimToady is the guy, right?
03:04:21 <edwardk> think so
03:04:25 <dons> seems so
03:04:28 <integral> dons: yep
03:04:29 <dons> cool :)
03:05:29 <Bluelive> of Perl fame ?
03:05:42 <dons> the very same.
03:06:01 <edwardk> blue: yeah
03:06:08 <edwardk> and yeah, it is the right nick
03:06:10 <Bluelive> i see famous people
03:08:27 <RobHu> Is there a paste bing page thing for Haskell? or should I just use rafb.net/paste?
03:08:39 <edwardk> lambdabot is the first irc bot i ever added to my buddy list in trillian ;)
03:08:42 <edwardk> @paste
03:08:42 <lambdabot> http://paste.lisp.org/new/haskell
03:09:15 <edwardk> dons: is there any way to tell the ratio of requests  that lambabot gets off channel to the ones she gets on?
03:09:25 <edwardk> kinda curious how much of her traffic is in /msg s
03:09:37 <edwardk> not user specific info, just overall %age
03:09:41 <tibbe> would be nice with a paste bin with syntax highlighting
03:09:43 <lisppaste2> robhu pasted "What is bad about this?" at http://paste.lisp.org/display/25217
03:09:50 <dons> edwardk: the way involves grep and sed
03:10:18 <edwardk> dons: *nods*
03:10:20 <dons> ?remember edwardk lambdabot is the first irc bot i ever added to my buddy list
03:10:47 <edwardk> heh i spend about as much time talking to lambdabot as i do to channel some days ;)
03:10:57 <edwardk> faster than starting ghci
03:11:11 <RobHu> I'm wondering if I'm doing recursion properly
03:11:14 <RobHu> I mean... it works :-)
03:11:25 <edwardk> ghci needs @pl and @undo =)
03:11:30 <RobHu> I also have to return /something/ but I dont know if returning [] is the ideal
03:11:36 <RobHu> any comments appreciated :)
03:11:42 <tibbe> perhaps () ?
03:12:08 <int-e> () is common
03:12:09 <edwardk> ()
03:12:12 <int-e> @type mapM_
03:12:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
03:12:27 <RobHu> thats an empty tuple right?
03:12:38 <int-e> mapM_ does pretty much what you do there - apply a monad action to each element of a list, then return ().
03:12:41 <RobHu> Is the way I'm using the if ok?
03:12:55 <RobHu> int-e: Oh ok, I've not got that far in YAHT yet :P
03:12:56 <edwardk> no need for the word do in each case
03:13:05 <edwardk> since you only do one statement
03:13:28 <int-e> RobHu: I'd prefer pattern matching: printFactorials (n:ns) = ...; printFactorials [] = return ()
03:13:34 <edwardk> you can also use a when guard instead of the if if you want
03:13:35 <edwardk> to be clearer
03:13:55 <edwardk> when (length list > 1) $ printFactorials (tail list)
03:13:56 <int-e> RobHu: I'd also write the if in terms of   null  because that works with infinite lists (and is also more efficient)
03:14:18 <int-e> RobHu: oh, and your function fails of the list is empty.
03:14:29 <gour> @where c2hs
03:14:29 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
03:14:40 <RobHu> int-e: Thanks for that - not using pattern matching is what I think was making it smell bad
03:15:28 <RobHu> int-e: How can I make it not fail if the the list is empty?
03:15:29 <araujo> morning!
03:15:32 <edwardk> rob-hu: also, if your list is monotonically increasing you can share work across your my_fact calls ;)
03:15:40 <edwardk> ut you'd have to change the signature of it
03:15:45 <RobHu> edwardk: What do you mean?
03:16:03 <RobHu> I know my_fact is bad but thats as advanced as things are in the tutorial so far :P
03:16:03 <int-e> RobHu: do the check first. pF list = if null list then return () else do ...
03:16:04 <edwardk> robhu: when (not $ null list) $ printFactorials tail list
03:16:13 <int-e> or just use when, yes.
03:16:24 <edwardk> er (tail list)
03:16:50 <edwardk> er even better
03:16:59 <RobHu> edwardk: Thankyou for that, but I'll wait until I get further in the tutorial to adopy that I think
03:17:04 <edwardk> unless (not $ null list) $ printFactorials $ tail list
03:17:11 <edwardk> kk
03:17:12 <RobHu> edwardk: I havent got to $ yet
03:17:22 <RobHu> thanks guys, you've been stellar
03:17:27 <edwardk> $ equals wrapping ()'s around the rest of the text
03:17:45 <RobHu> ah
03:17:45 <edwardk> foo $ bar baz == foo (bar baz)
03:17:47 <int-e> but pattern matching is the way to go I think (if you don't want to use mapM_)
03:17:50 <RobHu> Thats usefykl
03:18:00 <edwardk> avoid lispyness =)
03:18:12 <int-e> note that $ is just another infix operator. not syntax.
03:18:16 <sieni> shouldn't that be "lispiness"?
03:18:18 * edwardk nods.
03:18:20 <edwardk> yeah
03:18:35 <edwardk> unless you want to avoid being like lispy.
03:18:54 <lisppaste2> robhu annotated #25217 with "So this is much better, right?" at http://paste.lisp.org/display/25217#1
03:20:02 <edwardk> where did the guard on the printfactorial statement go?
03:20:10 <edwardk> ah
03:20:12 <edwardk> i see it
03:20:17 <edwardk> with the two function defs
03:20:19 <edwardk> yeah
03:20:25 <RobHu> the guard? What is a guard ? Oh you mean for [] ?
03:20:33 <edwardk> though you can clean it up further
03:20:35 <edwardk> and do
03:21:06 <edwardk> printFactorials (x:xs) = do { putStrLn ... ; printFactorials xs }
03:22:39 <RobHu> awesome
03:22:41 <edwardk> or even printFactorials = mapM_ (\elem -> putStrLn $ "Factorial of " ++ (show elem) ++ " is " ++ (show (my_fact elem)))
03:22:50 <RobHu> You love mapM_ don't you?
03:22:54 <RobHu> I need to like... get further :P
03:22:58 <edwardk> yeah =)
03:23:10 <edwardk> well, the favorite sport around here is 'programming golf'
03:23:13 <lisppaste2> robhu annotated #25217 with "Now even better!" at http://paste.lisp.org/display/25217#2
03:23:36 <edwardk> yeah
03:23:38 <RobHu> Why doesnt this paste page support colouring for Haskell?
03:23:45 <RobHu> and why is it double spacing?
03:23:48 <edwardk> thats about as good as you'll get without mapM_
03:24:08 <dons> edwardk: but we have automated super programmign golf clubs
03:24:12 <dons> making it a bit unfair
03:24:17 <edwardk> dons: heh
03:24:24 <dons> its more a game of tuning the pl machine
03:24:37 <edwardk> hrmm, what are some of @pl's weakenesses?
03:25:36 <edwardk> and why did your statement make me feel like rodney dangerfield in caddyshack?
03:25:50 <edwardk> er caddyshack 2 was it?
03:27:15 <edwardk> i love how haskell offers like 5 syntaxes for everything. they are like training wheels for pointless =)
03:27:41 <edwardk> only other language this fun to golf in is perl
03:28:00 <RobHu> In YAHT I kinda wish they'd left monads until the end. Its like I've filled up all the space in my brain with pure FP then I have to load in monads which causes lots of swapping
03:28:32 <edwardk> robhu: yeah. for right now you can think of the IO monad as a 'cute little embedded functional programming language'
03:28:33 <sieni> edwardk: speaking of training wheels: http://tnx.nl/php_small.jpg
03:28:54 <edwardk> hahhaha
03:29:05 <RobHu> I really hate PHP
03:29:11 <RobHu> The only thing worse is ASP (VB)
03:29:47 <edwardk> php is a less useful perl that also lacks CPAN ;)
03:30:05 <RobHu> php just seems ugly as a language
03:30:10 <edwardk> *nods*
03:30:14 <int-e> PHP is a programming language like penguins are birds. And people try to make it fly.
03:31:22 <Bluelive> great mudslinging quote :)
03:31:43 <RobHu> I'm putting that in my sig
03:31:50 <edwardk> robhu: with your print factorials are you printing all factorials up to a given number or just a fairly random list?
03:32:11 <RobHu> edwardk: its like printFactorials [1,2,99,4]
03:32:16 <edwardk> ah k
03:32:25 <RobHu> It's one of the YAHT exercises
03:33:13 <edwardk> you know i probably should have read YAHT at somepoint
03:36:55 <Philippa_> RobHu: most people seem to prefer to be introduced to monads earlier, so that they know how to write "real programs"
03:37:18 <Philippa_> not introducing IO early enough's been one of the biggest criticisms of the older tutorials...
03:38:22 <gour> Philippa_: can one write "real programs" just with IO, ie. without mastering monads in general?
03:38:43 <RobHu> Philippa_: My intent is to not write a "real program" until I've completed the tutorial ;-)
03:39:17 <Philippa_> yeah, but you need IO to write even most common toy programs
03:39:38 <Philippa_> gour: yes, though it loses you some important tools IMO
03:39:42 <RobHu> s/programs//
03:39:51 <gour> Philippa_: to me it looks, that haskell has a steeper learning curve, ie. the 'initial' package is much bigger to grok than with some other pl
03:40:42 <Philippa_> there's some truth to that, yeah. Though I think monads are pretty much it
03:40:57 <Philippa_> aside from that, I don't think there's much in it if you're truly starting from scratch
03:41:08 <gour> this is encouraging :-)
03:41:13 <edwardk> yeah, as a math professor of mine would say, learning the core of haskell is one of those 'narrow mountain passes' you have to get through to see the grand vistas on the other side.
03:41:15 <int-e> data types, pattern matching, recursion, lazyness ...
03:41:41 <edwardk> once you manage to get through all that junk, the view is amazing.
03:41:52 <sieni> gour: that might be useful for understanding monads: http://www.nomaware.com/monads/html/analogy.html
03:41:55 <lambdabot> Title: A physical analogy for monads, http://tinyurl.com/osvs6
03:42:17 <gour> that's why python folks (who wants to bring me in their camp) advertie thatr haskell needs months, while oen can hack python in one hour ;)
03:42:25 <pejo> edwardk, php has pear, but probably not as comprehensive as CPAN.
03:42:38 <sieni> gour: but the advantage of haskell is that it doesn't suck
03:42:46 <int-e> and with python you can see the feet of people climbing the mountain?
03:42:50 <dons> ?remember sieni the advantage of haskell is that it doesn't suck
03:42:59 <int-e> I like Python btw.
03:43:01 <gour> sieni: i have that in archive, but have to cover some more things from the Craft book
03:43:10 <edwardk> pejo: yeah, but it seems the perl community is built entirely around cpan, whereas the php community has pear as an afterthought.
03:43:16 <Philippa_> int-e: you don't really need to learn laziness to get started. Pattern matching and recursion're equivalent to the control flow structures in other languages, and most other languages' data structures are more complex, not less
03:43:40 <edwardk> note to self, if i ever design a language i want to be popular, build in a public module repository from the get-go =)
03:43:42 <int-e> Philippa_: You still need to learn the type system.
03:43:51 <gour> int-e: what haskell brings (to you) over python?
03:44:14 <edwardk> gour: i think you can be productive in haskell in 3-4 days
03:44:15 <Philippa_> true, but you need to learn it to some extent in any language. Haskell98's type system is a bit more complicated than most, but only due to type classes
03:44:30 <int-e> gour: the two don't really compare.
03:44:35 <edwardk> gour: a type system =)
03:44:45 <gour> int-e: i got so many urls comparing the two
03:44:49 <Philippa_> I guess currying can be confusing at first
03:45:34 <_Codex> function call syntax is confusing too...
03:45:42 <gour> and i met people complaining that haskell's syntax is not clean (btw, i like it...)
03:45:55 <dons> that's a funny one
03:46:00 <Philippa_> I don't think it's at all confusing. It's just different to C et al's syntax
03:46:09 <dons> its hard to imagine what's _not_ clean about: f x
03:46:22 * edwardk <<3 the function call syntax and currying. it actually makes going back and thinking about mathematical operators a lot easier
03:46:38 <edwardk> i wish i had learned haskell before i learned linear operators
03:46:44 <Philippa_> dons: presumably the complaint's really about currying...
03:46:57 <int-e> Haskell's syntax is a bit sticky from all the syntactic sugar. But it's also very sweet.
03:47:02 <edwardk> f(x) + 4 is so ambiguous
03:47:09 <edwardk> (f x) + 4 is perfectly clear
03:47:13 <edwardk> no overloading of ()'s
03:47:20 <dcoutts__> good point
03:47:24 <sieni> too much syntactic sugar causes cancer of the semicolon
03:47:45 <sieni> -- Alan Perlis
03:48:09 <gour> python is given as example of clean syntax
03:48:17 <int-e> gour: Haskell is great with algebraic datatypes like trees. I happen to use them quite a lot.
03:48:43 <edwardk> what should change is the way they teach algebra, coz that bad f(x) convention sticks with you and pollutes your thinking for life.
03:48:48 <gour> int-e: i like haskell (so far) and want to go further ;)
03:49:13 <edwardk> but thats a bit of a tough fight =)
03:50:04 <int-e> bah, people should just get used to the idea that syntax changes with context.
03:50:21 <Philippa_> sure. Types and terms are different
03:50:33 <Philippa_> Patterns and expressions are different
03:50:52 <Philippa_> but those're differences with a constructive synergy to them
03:51:06 <dons> data structures aren't really first class in a language till you have pattern matching
03:51:22 <dons> equality for data structures! use haskell!
03:51:26 <dcoutts__> dons: we would want views for ByteString
03:51:30 <dons> :)
03:51:35 <int-e> it's all about pattern matching, higher order functions, and lazyness for me
03:51:39 <musasabi> Is there is no unsafeInterleaveIO based combinator in Data.ByteString.Lazy?
03:51:45 <dcoutts__> to use case thing of (_:x:xs) ->
03:51:55 <dcoutts__> musasabi: huh?
03:52:04 <dons> you want some IO, musasabi ?
03:52:05 <dcoutts__> you mean in the implementation or in the interface?
03:52:13 <int-e> oh, and type safety that allows me to do wacky stuff and trust to find the compiler find 99% of my mistakes.
03:52:13 <dcoutts__> we've got lazy IO
03:52:21 <edwardk> well, throw in a pure type system and types and terms can be the same thing, why get used to them being different? you get ~22 sequent rules, with them the same you get 7 and a free understanding of dependent types.
03:52:30 <Philippa_> *sigh* Views bad, transformational patterns good. And presumably you've already got a ByteString -> String func?
03:52:38 <musasabi> dons: things like http://youzen.b2.fi/~musasabi/lmm.hs
03:52:56 <dcoutts__> Philippa_: we do of course but it's not going to be effecient unless done well
03:53:09 <Philippa_> sure, but neither's the View
03:53:16 <Philippa_> it'll amount to the same thing
03:53:20 <dcoutts__> Philippa_: we'd want to translate into uses of head/tail, not list unpack
03:53:31 <dons> hmm musasabi.  interesting
03:54:04 <dcoutts__> Philippa_: I don't care what the mechanism is, so long as one can use pattern matching and it effeciently uses ByteString head/tail
03:54:19 <Philippa_> edwardk: because keeping types terminating when terms might not is good?
03:54:46 <musasabi> I don't mind writing combinators like that, but I don't know whether it should be optimized in some way to make it fit with the rest of the ByteString things.
03:55:09 <int-e> Data.Sequence has ViewL and ViewR types, hmm.
03:55:24 <int-e> for aiding with pattern matching.
03:55:38 <dcoutts__> musasabi: you want a way to operate on the chunks directly? and do it in IO? and also lazily defer it?
03:55:54 <Philippa_> dcoutts: you still need the EOS check each time round, right? Really the hard bit's getting it to skip the indirection whenever it matches on the rest of the string
03:56:32 <musasabi> dcoutts__: yes. I don't mind using unsafePerformIO if needed - it is a pure transformation (encryption) done via FFI.
03:56:39 <dcoutts__> Philippa_: EOS? sorry I don't follow what you mean about skipping the indirection
03:56:50 <int-e> end of string
03:56:53 <dcoutts__> musasabi: or gziping or etc
03:57:02 <edwardk> philippa: we seem to have given up terminating type inference once you turn on all the bells and whistles in ghc anyways, haven't we?
03:57:05 <Philippa_> End Of String. The indirection's the one that happens when case forces a thunk - in practice the compiler should be able to work it out
03:57:09 <dcoutts__> musasabi: we'll try some examples first and then see about providing something
03:57:18 <Philippa_> edwardk: most of us don't use /all/ the bells and whistles though
03:57:28 * edwardk is a feature addict
03:57:37 <Philippa_> MPTCs + fundeps're pretty powerful without going undecidable
03:57:48 <musasabi> thanks.
03:57:56 <dcoutts__> musasabi: so yes, if people do block based stuff like encoding changing via iconv, gziping, encrypting etc we can see if there's a helpful abstraction
03:58:33 <Philippa_> I would've thought block-level maps'd be a start?
03:59:10 <musasabi> it would be very nice for such stuff to switch to ByteStrings.
03:59:11 <edwardk> yeah, but you wind up having to use -fallow-undecidable-instances to do a lot of real work once you try to do mptcs for anything big.
03:59:51 <dcoutts__> musasabi: yes, I'm really looking forward to: gzip :: ByteString -> ByteString and similar things
04:00:00 <Philippa_> define "big"
04:00:01 <dcoutts__> then we can do nice pipelines
04:00:13 <goltrpoat> zlib is pretty nasty.
04:00:17 <edwardk> well, i have a type level 2s complement arithmetic library that can't seem to exist without it
04:00:39 <Philippa_> yep, could've told you that one for free
04:00:42 <edwardk> sure
04:00:48 <dcoutts__> lines . iconv utf8 . gunzip =<< readFile f
04:01:12 <Heffalump> gaah, why is haskell-prime full of a pointless argument about subject tags?
04:01:13 <edwardk> but add any sort of type level logical connectives and you run into similar problems.
04:01:25 <dcoutts__> Heffalump: bikesheads
04:01:29 <edwardk> when you start to use the type system like a poor man's prolog you're stuck turning it on ;)
04:01:43 <Heffalump> bikesheads?
04:02:02 <goltrpoat> by nasty i mean, the top level interface was written by a rhesus monkey on crack.  i don't think anyone's ever used it in production without rewriting large chunks of it.
04:02:16 <edwardk> heff: its a reference to the pointlessness of the argument increasing its likelihood
04:02:32 <Heffalump> ah
04:02:35 <dcoutts__> Heffalump: google for bikeshead and group discussions
04:03:13 <RobHu> We need to paint the bike shed blue
04:03:16 <edwardk> the color of the bike shed takes on a disproportional amount of the conversation
04:03:23 <edwardk> no, yellow!
04:03:24 <Heffalump> ok, I get the general idea :-)
04:03:33 <RobHu> Blue is clearly superior to yellow
04:03:46 <edwardk> ok, well, how about we compromise and use green?
04:04:01 <edwardk> but it should be a yellowish-green
04:04:02 <RobHu> Sure. As long as the door is blue.
04:04:16 <RobHu> I don't think you can have a truly functioning bike shed without a blue door
04:04:17 <edwardk> i might give you blue polkadots, but no blue door. we shouldn't even have a door anyways
04:04:26 <edwardk> its only a bike
04:04:34 <edwardk> nothing else will go in the shed
04:04:39 <edwardk> =)
04:04:45 <RobHu> Yeah, but its a /blue/ bike
04:04:54 <dcoutts__> my bike is too cool to be seen in a blue bike shead
04:05:15 <RobHu> lol http://www.bikeshed.org/
04:05:17 <lambdabot> Title: Why Should I Care What Color the Bikeshed Is?
04:05:20 <edwardk> so the shed should be yellow! since you got your way with the bike already =)
04:05:21 <musasabi> Why don't people just rewrite mailing list subjects adding/removing the list tag automatically and be done with it...
04:05:32 <RobHu> musasabi: Yeah I was wondering about that
04:05:40 <dcoutts__> musasabi: because they use impoverished mail readers
04:05:40 <RobHu> I only started with Haskell yesterday
04:05:48 <dcoutts__> like Gmail
04:05:49 <RobHu> So I was kinda surprised that 99% of the discussion is about the list tag
04:05:55 <edwardk> heh
04:05:55 * RobHu uses gmail :-(
04:06:00 <Philippa_> doing the removing part's a lot trickier than the adding
04:06:13 <Heffalump> do it manually, then
04:06:39 <Philippa_> I've still not seen a good argument against having the tags in the first place
04:06:57 <Heffalump> YM you've dismissed all the arguments other people have made
04:07:08 <goltrpoat> you mean the subject tag?
04:07:09 <RobHu> ijones doesnt like them does he, and he's the maintainer? Or are you not as despotic as that in the Haskell community? ;-)
04:07:24 <Heffalump> for something this trivial he really ought to just decide :-)
04:07:38 <musasabi> Philippa_: not really. procmail is a friend. The MUA does not need to be intelligent.
04:08:01 <Philippa_> I mean that the only argument I've specifically seen is "it takes up subject line space", and that's both rarely a real issue and fixable by exactly the measures I'm being told I should happily accept having to use
04:08:06 * musasabi likes to have tags, but I don't think it is very important.
04:08:10 <RobHu> Its the standard everywhere for /some reason/... I don't think adding [haskell-cafe] would really make the title that unreadable as some think (saying the title would scroll off screen... do they have a terminal width of 10?!)
04:08:21 <goltrpoat> why is this a topic for discussion
04:08:22 <goltrpoat> hehe
04:08:30 <goltrpoat> tags, no tags, who the fuck cares.
04:08:32 <edwardk> with 1440x900 or better monitors in common use when is the amount of subject line space an issue? ;)
04:08:39 <musasabi> With terminal width 80 that can be a real problem.
04:08:47 <RobHu> There should be a RFC about this ;-)
04:08:57 * Heffalump isn't particularly bothered either way, but is really pissed off about the amount of traffic on the list about it
04:09:06 <RobHu> then we can say "Yes but if we used a tag it would not be RFC 2932 compliant"
04:09:09 <edwardk> musa: sure, but i haven't used pine on an 80 column screen in 10 years
04:09:22 <goltrpoat> i haven't seen *any* of this, btw.
04:09:28 <goltrpoat> i wonder if my client is just filtering it all as spam
04:09:29 <RobHu> Even with 80 characters [haskell-cafe] is still probably going to let you read the title
04:09:32 <Philippa_> that's because it's on the haskell-prime list, not the haskell one
04:09:33 <goltrpoat> and leaving me happily oblivious.
04:09:40 <RobHu> We need a bikeshed bayensian filter
04:09:50 <goltrpoat> oh.. that'd explain it.
04:10:00 <musasabi> I still have a text terminal in bedroom with 80-chars of width ;)
04:10:55 <edwardk> musa: heh, my mom's attic is still stuffed with old vt220 terminals. maybe i should visit her one of these days and reclaim one for nostalgia's sake
04:11:31 <pejo> RobHu, you usually have some other information too though, like who sent hte mail and such, so 80 characters aren't available.
04:11:40 <RobHu> thats true
04:11:41 <goltrpoat> i strongly suspect my parents tossed my old boxes about ten years ago.  if they didn't, that'd be a trip.
04:11:44 <goltrpoat> should ask.
04:11:54 <RobHu> why not make it [hp] then?
04:12:01 <RobHu> 4 characters cant hurt that much
04:12:46 <goltrpoat> subject tags are nice because i'd like to be able to filter personal replies -- so if i filter it by subject, both the list traffic and the personal replies go into the same folder, where i want them
04:12:49 <edwardk> robhu: coz someone who works at HP might object about that hue of the bikeshed.
04:12:53 <goltrpoat> but..  good god is this a non-issue.
04:13:07 <tibbe> gmail does all the filtering I need for me
04:13:17 <RobHu> goltrpoat: You can do that with the headers
04:13:51 <tibbe> I don't want subjects tags on my network bill!
04:13:56 <tibbe> subject*
04:13:57 <RobHu> lol
04:14:00 <goltrpoat> -nod- the tubes might get clogged.
04:14:09 <goltrpoat> it's not a dump truck, you see.
04:14:14 <RobHu> Think of all the extra wear on my cpu by having a longer subject line to process
04:14:20 <RobHu> I hope all these people are going to reimburse me
04:14:35 <Heffalump> :-)
04:14:48 <goltrpoat> someone ought to be held accountable.
04:14:59 <tibbe> if we have subject tags I'll start all my subject lines with s/^[haskell-cafe]/
04:15:02 <RobHu> We ought to form a committee to investigate it
04:15:52 <int-e> yes, spread the blame.
04:16:04 <RobHu> perhaps there could be two mailing lists?
04:16:07 <RobHu> One with tags and one without
04:16:12 <RobHu> and an intelligent bridge between them
04:16:18 <Heffalump> :-)
04:16:35 <Heffalump> presumably with cleverer mailing list software you could just make it a subscription option
04:16:45 <musasabi> hmm. Mailman could be in theory hacked to remove the tags for the ones not wishing to see them.
04:16:46 <int-e> RobHu: that won't help you for replies, will it? hmm.
04:16:48 <Philippa_> yes, that's probably the best fix
04:17:16 <goltrpoat> i think i managed to generalize my earlier question.  imagine writing a generic version of branch and bound.  we want to be able to toss in user-defined bound functions, and user-defined branch decisions.  (still driving at customizable alpha-beta, as the folks here who have had the bad sense to keep up with my inane bullshit might recall)
04:17:17 <tibbe> alright, not tags get added until those who want those hack mailman
04:17:23 <RobHu> int-e: Why not? Essentially traffic would be mirrored between them, the subject line and to lines would be munged based on the list you were on
04:17:37 <RobHu> goltrpoat: Can't you see we have far more important things to discuss here ? ;-)
04:17:49 <Philippa_> RobHu: presumably int-e means off-list replies
04:17:50 <goltrpoat> sorry.  ok, imagine a green bike shed.
04:17:59 <RobHu> Philippa_: Ah I see
04:18:02 <RobHu> lol
04:18:30 <Heffalump> what I want to know is, why have a bike shed at all? Why not individual stalls?
04:18:40 <RobHu> Imagine the offense of sending someone a reply with the tag in the header if they weren't part of that movement :-O
04:18:42 <musasabi> Subject lines in off-list replies are a quite small issue if things would work for 90% of posts.
04:18:59 <int-e> Philippa_: I didn't but I wasn't thinking clearly enough.
04:18:59 <RobHu> What's really funny about this is now how much /we're/ discussing it ;-)
04:19:12 <goltrpoat> anyway, so this is fairly trivial to code for a specific case, right.  i pasted some pseudocode earlier.  the idea is, that we want to be able to compose the search function out of little building blocks.  trouble is, that monads really don't seem to make any sense here.
04:19:15 <tibbe> > forever "[haskell-cafe] Re: "
04:19:16 <lambdabot>  Not in scope: `forever'
04:19:19 <RobHu> The only sensible solution is a mailing list fork
04:19:23 <tibbe> > repeat "[haskell-cafe] Re: "
04:19:25 <lambdabot>  ["[haskell-cafe] Re: ","[haskell-cafe] Re: ","[haskell-cafe] Re: ","[haskell...
04:19:30 <edwardk> ah neat. found a more appropriate abstract machine to compile to something like for my intermediate language http://research.microsoft.com/Users/simonpj/papers/not-not-ml/index.htm
04:19:33 <lambdabot> Title: Haskell is not not ML, http://tinyurl.com/luwrd
04:19:33 <tibbe> > concat $ repeat "[haskell-cafe] Re: "
04:19:34 <Heffalump> goltrpoat: how long ago did you start discussing this, so I can read scrollback?
04:19:34 <lambdabot>  "[haskell-cafe] Re: [haskell-cafe] Re: [haskell-cafe] Re: [haskell-cafe] Re:...
04:20:00 <Heffalump> edwardk: that paper is cool, but it does mention lots of "todo" items at the end
04:20:10 <edwardk> heff: yeah
04:20:13 <goltrpoat> heffalump:  hours ago.. i did sign off for a while though, so it's close enough for me.  lemme paste the relevant parts somewhere.
04:20:23 <edwardk> heff: reading through it now after a preliminary skim
04:20:44 <Heffalump> goltrpoat: can you say how many hours, roughly?
04:20:55 <Heffalump> I can dig in logs then
04:20:56 <int-e> goltrpoat: you're probably better off creating a paste with a summary then.
04:20:58 <int-e> @where paste
04:20:58 <lambdabot> http://paste.lisp.org/new/haskell
04:21:05 <Heffalump> ok, or do that
04:21:12 <edwardk> heff: mostly my intermediate language looks like this one mashed togehter with a linear term calculus and linear regions
04:21:25 <edwardk> heff: was just amused at the close relationship
04:21:35 <edwardk> heff: so the AM seemed like a decent target model to evaluate
04:22:26 <goltrpoat> http://www.rafb.net/paste/results/m05qNb48.html
04:23:29 <Heffalump> is there any way to get the lines to wrap?
04:23:43 <edwardk> goltr: hrmm, you could probably do a simple alpha-beta or MTD(f) monad.
04:24:34 <RobHu> In YAHT :t 5 :: Int is suppoed to return 5 :: Int  but it actually returns  5 :: Int :: Int  ... why is that?
04:24:56 <Heffalump> hmm, pasting as plain text doesn't work :-(
04:25:19 <goltrpoat> edwardk:  well, alpha-beta/negascout/MTDf/whatever, there's going to be a lot of random stuff done inbetween
04:25:36 <edwardk> goltr: *nods* been there
04:25:49 <goltrpoat> null moves, transposition table lookup, sorting (any number of strategies there, sort of hit and miss), quiescence, etc
04:25:51 <edwardk> goltr: did mine using c++ templates to abstract over the strategy last time
04:26:14 <edwardk> goltr: but a replacable monad indicating the choice of algorithm shouldn't be hard.
04:26:24 <Heffalump> isn't this a list monad?
04:26:33 <goltrpoat> yeah, i just wanted to come up with a way to *compose* the algorithm, basically.
04:27:09 <edwardk> goltr: well, you can do mtdf over another strategy etc
04:27:12 <goltrpoat> out of component parts -- since we're basically working with you know.. 8-10 different things, the main issue is putting them together in a particular order, and tweaking them.
04:27:14 <RobHu> A number of things in YAHT are wrong. I guess ghci has moved on
04:27:20 <edwardk> so perhaps a specialized form of monad transformer?
04:27:44 <edwardk> Strategy a , then StrategyT m a, etc.
04:27:54 <Philippa_> is there a particular reason not to just have a HOF and use function composition to dictate orders?
04:27:55 <goltrpoat> right, but then what's the monad?  :)
04:28:01 <Cale> RobHu: It prints the whole expression you typed and then a type sig
04:28:06 <Cale> RobHu: try  :t 5
04:28:06 <RobHu> Ah its because I had the glashow extensions turned on
04:28:07 <Heffalump> what sort of things will cause new strategies to be chosen?
04:28:13 <Cale> RobHu: ah
04:28:19 <RobHu> actually
04:28:21 <RobHu> hmm
04:28:23 <explicitjelly> damn. i'm having a serious problem here with something that should be simple.
04:28:33 <Cale> Well, :t 5 will give  5 :: (Num a) => a
04:28:47 <edwardk> goltr: what game, first off? i realize its irrelevant to the monad
04:28:54 <goltrpoat> oh, chess, sorry
04:28:57 <edwardk> ah
04:29:02 <RobHu> :t 5 :: Int gives "5 :: Int :: Int" whereas YAHT says it should just be "5 :: Int"
04:29:03 <edwardk> doh you mentioned in the paste
04:29:15 <explicitjelly> I'm trying to implement my own monad, with somewhat own interfaces, to understand them better, but I fail.
04:29:48 <goltrpoat> edwardk:  if you know what MTDf is, then im guessing you've done this?
04:29:54 <edwardk> goltr: hrmm. you can probably bolt all this over a list if you had to
04:30:07 <edwardk> goltr: yeah i've used all of them a fair bit
04:30:24 <edwardk> goltr: usually some form of MTD(f) w/ iterative deepening, etc.
04:30:30 <goltrpoat> this is like..  the one thing that is, to a large degree, easier to write in an imperative language, and that's sort of bothering me
04:30:36 <edwardk> not sure
04:30:49 <edwardk> actually i'm sitting here trying to juggle the translation to haskell now =)
04:30:56 <goltrpoat> yeah, likewise.
04:30:56 <edwardk> just to get my head around it
04:31:16 <gour> how do yhc & jhc compare?
04:31:16 <xs> i'm using data.bytestring. say i have, (B.replicate 10 0, B.replicate 10 0), the compiler can optimise this to let a = B.replicate 10 0 in (a,a)? if so, doesn't this lead to all kinds of problems with data.bytestring and useAsCString?
04:31:22 <explicitjelly> let's say I have to functions: f :: a -> Mystate -> (b, Mystate) and g :: c -> Mystate -> (a, Mystate)
04:31:31 <explicitjelly> obviously I can't just compose them using f . g
04:31:37 <goltrpoat> i wrote a half-decent chess program in c++, then decided to port it to haskell as an exercise, and figured it'd probably benefit everyone involved if i were to port it back to c++ once i was done.
04:31:52 <edwardk> hrmm
04:32:03 <Heffalump> explicitjelly: that's what monads are for
04:32:06 <goltrpoat> i can very easily port the program the way it is, but it'll be a bitch to modify it in any algorithmically significant way.
04:32:13 <explicitjelly> Heffalump, yes, that's what I'm trying to build.
04:32:13 <edwardk> yeah.
04:32:34 <Heffalump> explicitjelly: have you managed to define the (>>=) operator for that monad?
04:32:35 <explicitjelly> so I write a bind function, which gives me a new function based on f, which I can compose with g.
04:32:40 <edwardk> the last thing i did all this for was checkers. since you only usually make about 14 moves in checkers before you get in sight of the closing move library
04:32:44 <Heffalump> ok
04:32:58 <explicitjelly> Heffalump, no, right now, I'm doing my own interface (the function is named "bind") to understand things better
04:32:59 <goltrpoat> oh seriously?  7 ply is all you need?
04:33:04 <goltrpoat> before endgame tables i mean
04:33:07 <edwardk> its JUST on the other side of the horizon as a 'solved' problem
04:33:10 <goltrpoat> or do you mean 14 ply
04:33:17 <Heffalump> goltrpoat: can you explain the kind of thing you would want to change?
04:33:29 <edwardk> 14 ply i should say for most games
04:33:53 <edwardk> heff: basically he'd need to be able to swap out alpha-beta for more advanced but functionally identical techniques.
04:33:59 <explicitjelly> so I really thought, that since bind f must be of type (a, Mystate) -> (b, Mystate), the bind function must be of type (a -> Mystate -> (b, Mystate)) -> (a, Mystate) -> (b, Mystate)
04:34:03 <explicitjelly> obviously, it's not.
04:34:19 <edwardk> they run faster memoize some things and look at less stuff
04:34:22 <goltrpoat> edwardk:  and the branching factor is tiny compared to chess, i would guess
04:34:27 <Heffalump> explicitjelly: bind isn't a composition function
04:34:30 <Heffalump> not quite, anyway
04:34:33 <edwardk> goltr: yeah, WAY smaller
04:34:39 <Heffalump> it's of type m a -> (a -> m b) -> m b
04:35:03 <edwardk> goltr: did chess about 6 years ago, but never release the engine. probably should have
04:35:07 <explicitjelly> Heffalump, hmm. maybe I should just stick with that definition. but I really want to understand why.
04:35:27 <Heffalump> understand why what?
04:35:35 <explicitjelly> and right now, I'm having a function f which takes to arguments, an a and a Mystate, and returns a tuple of a b and a Mystate.
04:35:54 <edwardk> i was stuck with checkers for a class assignment, so i went and did all the extra stuff to keep it interesting
04:35:57 <explicitjelly> and for it to be composable with g, it must take one argument, a tuple of a and Mystate and return the same thing as before. no?
04:36:40 <Heffalump> explicitjelly: there's actually a theoretical difference between what you're describing and a monad
04:36:46 <Heffalump> what you're describing is an arrow
04:36:57 <edwardk> goltrpoat: join #chess
04:36:59 <explicitjelly> i'm describing an arrow. aha.
04:37:04 <explicitjelly> but why doesn't it work? :)
04:37:04 <edwardk> less traffic =)
04:37:13 <explicitjelly> Test> :t (bind f) . g
04:37:13 <explicitjelly> ERROR - Type error in application
04:37:13 <explicitjelly> *** Expression     : bind f . g
04:37:13 <explicitjelly> *** Term           : bind f
04:37:13 <explicitjelly> *** Type           : (Char,Mystate) -> (Double,Mystate)
04:37:15 <Heffalump> sorry, I still didn't quite follow what goes wrong :-)
04:37:16 <explicitjelly> *** Does not match : (Mystate -> (Char,Mystate)) -> (Double,Mystate)
04:37:29 <Heffalump> you need to redefine the composition operator
04:37:47 <dcoutts__> xs: the useAsCString makes a copy, so it doesn't matter if the C code modifies it.
04:38:14 <dcoutts__> xs: so it's pure and there is no problem with your example
04:38:29 <explicitjelly> I read this article: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
04:38:31 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
04:38:39 <xs> dcoutts__, ooh, i see. so i must then re-pack the resulting ptr! aha, thank you :)
04:39:08 <dcoutts__> xs: it doesn't repack anything, it's just for going out to C code
04:39:14 <explicitjelly> Heffalump, in this article, the function called "bind" just "upgraded" your function so that you can compose it with g.
04:39:55 <xs> dcoutts__, sorry, yes, i meant, i'm interested in the changes that the c code makes, so i must pack the ptr inside the IO block rather than use the original bytestring
04:40:05 <dcoutts__> xs: right
04:40:19 <Heffalump> explicitjelly: hmm, ok. It's a little confusing, cos normally bind is another name for (>>=) with the type I gave above
04:40:25 <xs> dcoutts__, thank you :)
04:40:28 <dcoutts__> xs: there's an usafe version but with that the C code must not modify the buffer
04:40:37 <dcoutts__> the unsafe version doesn't copy
04:41:03 <explicitjelly> Heffalump, let's just pretend it wasn't a monad right now and just... why doesn't it work?
04:41:29 <Heffalump> could you paste all your code somewhere?
04:41:35 <Heffalump> or put it on the web
04:42:02 <explicitjelly> ok
04:47:03 <explicitjelly> http://www.rafb.net/paste/results/D3ltW581.html
04:47:10 <explicitjelly> that's my code.
04:47:25 <explicitjelly> which drives me crazy.
04:47:31 <explicitjelly> it should be *so simple*.
04:51:05 <xs> explicitjelly, :t \x -> bind f . g x
04:51:09 <apfelmus> explicitjelly: your bind is just curry. you can do composition the following way then:
04:51:11 <xs> (bind == uncurry)
04:51:12 <apfelmus> @type \f g -> uncurry (curry f . curry g)
04:51:13 <lambdabot> forall c b c1 a b1. ((b -> c1, b1) -> c) -> ((a, b) -> c1) -> (a, b1) -> c
04:52:06 <apfelmus> mh? maybe not...
04:52:10 <apfelmus> @type curry
04:52:12 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
04:52:50 <apfelmus> sorry, it's just the other way round
04:52:50 <apfelmus> @type \f g -> curry (uncurry f . uncurry g)
04:52:52 <lambdabot> forall a b c a1 b1. (a -> b -> c) -> (a1 -> b1 -> (a, b)) -> a1 -> b1 -> c
04:53:31 <apfelmus> explicitjelly: your bind is uncurry i mean
04:53:44 <Heffalump> surely you need bind f . bind g?
04:53:55 <Heffalump> because both of them need "upgrading" before you can compose them
04:54:12 <explicitjelly> Heffalump, why both?
04:54:36 <araujo> bind = uncurry f
04:54:41 <explicitjelly> Heffalump, I can pass an a (or whatever) and a Mystate to g, I don't need to pass it as a tuple.
04:54:43 <Heffalump> because otherwise the types don't match :-)
04:54:52 <Heffalump> but bind f returns a tuple result
04:55:14 <Heffalump> oh, I see what you mean
04:55:18 <Heffalump> (.) is the wrong operator for this
04:55:24 <Heffalump> @type (.)
04:55:26 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
04:55:30 <explicitjelly> yes, but do we care what f returns? shouldn't we care about what g returns and what f takes?
04:55:42 <Heffalump> yes, you're right, I was getting confused briefly
04:55:50 <Heffalump> but we also need to care about what g takes as input
04:56:03 <xs> explicitjelly, but after taking one argument, it returns a function. which does not match the input of bind f.
04:57:04 <explicitjelly> xs, what is "it"? sorry, I'm just terribly confused right now.
04:58:06 <xs> g :: a -> b -> c == g :: a -> (b -> c). so with bind f . g, the input to f should be a function of type (b -> c)
04:58:38 <explicitjelly> ah. now we're getting to it.
04:59:07 <xs> but you what you actually meant, was f takes c of a -> b -> c, so you must either provide b explicitly, or uncurry/bind g
04:59:22 <xs> (if you wish to use (.) that is)
04:59:48 <explicitjelly> by the way, the correct solution is bind f x s = let (x',s') = x s in f x' s'
04:59:53 <explicitjelly> now I just have to fully understand why
05:00:04 <Heffalump> I don't think that is the correct solution at all
05:00:10 <Heffalump> it won't scale to the next problem
05:00:14 <explicitjelly> it's the solution that undoubtly works.
05:00:15 <Heffalump> you're just hacking around it
05:00:22 <Heffalump> what would you do to compose three functions?
05:00:28 <explicitjelly> and that is described in http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
05:00:32 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
05:00:35 <explicitjelly> Heffalump, I think "you don't" :)
05:00:42 <Heffalump> ok, that sounds completely wrong then :-)
05:00:55 <Heffalump> there is a nice simple solution which does scale, and involves calling bind on both sides of the composition
05:01:09 <Heffalump> though to be honest I don't see the point of any of this
05:01:46 <explicitjelly> Heffalump, could you read the article? and then tell me, if it's having some problems?
05:03:13 <explicitjelly> hmm. my bind is really just uncurry.
05:03:22 <explicitjelly> and there I though I could then do
05:03:25 <explicitjelly> uncurry f . g
05:03:45 <explicitjelly> I must be really confused for not figuring out why this doesn't work :(
05:04:08 <Heffalump> explicitjelly: I did skim the article, and I don't quite understand what the point is.
05:04:15 <Heffalump> monads are actually simpler than that, IMO :-)
05:04:20 <Heffalump> and easily explained by (>>=)
05:04:41 <explicitjelly> Heffalump, it's an interesting article.
05:04:44 <apfelmus> explicitjelly: mh, the 'correct' solution uses the fact that x is a *function*. they should have named it g
05:05:13 <explicitjelly> apfelmus, ...
05:05:15 <explicitjelly> apfelmus, oh. yes.
05:05:18 <explicitjelly> apfelmus, now I see it.
05:06:03 <explicitjelly> and now I understand why uncurry f . g doesn't work.
05:06:24 <apfelmus> explicitjelly: you probably want something like    bind f (g 237)
05:07:02 <explicitjelly> apfelmus, no, I really want something which allows me to do bind f . g, but now I see the problem.
05:07:13 <Heffalump> explicitjelly: it just confuses me more than it enlightens me :-)
05:09:19 <explicitjelly> ah, I think I got it now.
05:09:20 <apfelmus> explicitjelly: not quite. bind takes two *function* and it's bind who combines them in the end. you think of (.) as the "combiner", but with monads, bind takes approximately the role of (.)
05:09:21 <explicitjelly> thanks a lot.
05:10:03 <apfelmus> @google tackling haskell awkward squad
05:10:05 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
05:10:05 <lambdabot> Title: Simon Peyton Jones: papers
05:10:08 <explicitjelly> apfelmus, well, it seems in that article that . is the composer and bind just upgrades the function: "Yet again, define f * g = bind f . g and lift f = unit . f. "
05:10:47 <ndm> whats the difference between a propostion and a predicate?
05:10:51 <explicitjelly> apfelmus, but putting monads completely aside, I just had problems with coming up with my own "bind" (perhaps a silly name, then?) which does that
05:12:03 <Heffalump> in general, using (.) as the composer is a bad way to think about it
05:12:05 <Heffalump> IMO
05:12:32 <explicitjelly> so if it's true that in reality, bind works different than what is presented here... well, great, now I'm stuck with a completely wrong definition of bind in my head :)
05:14:38 <Heffalump> this is why I think that article is confusing and unhelpful :-)
05:15:51 <apfelmus> explicitjelly: a, i finally see the role of (.) in your case. explicitjelly, please reead another tutorial :) bind combines monadic actions (a -> m b) -> (m a) -> m b    (btw the 'standard' bind has arguments flipped).
05:15:55 <apfelmus> what \f g -> bind f . g does is like \f g -> \x -> bind f (g x) and amounts to (a -> m b) -> (b -> m c) -> (a -> m c)
05:17:14 <apfelmus> it's some kind of (.) with monads. ("arrow composition" for those familiar)
05:18:07 <explicitjelly> apfelmus, okay, will do, thanks :) it's still important for me to solve that simple problem with coming up with a "bind" (or "notreallybind") which allows me to do bind f . g in that case, but I will try to forget that it has anything to do with monads
05:18:17 <explicitjelly> apfelmus, and it seems like I'm getting to that solution, now.
05:19:07 <apfelmus> explicitjelly: ok. personally, i got monads from http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
05:19:09 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/jl2rm
05:19:48 <explicitjelly> apfelmus, thanks. I think that I actually "got" monads earlier, but now I probably lost them again due to that :( I need some practice.
05:20:43 <explicitjelly> oh, and now a really silly question: -> in types is really associative? so (a -> b) -> c is always the same as a -> (b -> c)? or is that wrong?
05:21:13 <ibid> that's wrong
05:21:14 <lambdabot> ibid: You have 1 new message. '/msg lambdabot @messages' to read it.
05:21:35 <explicitjelly> ibid, ok.
05:21:41 <Stinger_> -> is right associative no?
05:21:42 <ibid> lambdabot: hrm, do you need to yell it on the channel? :)
05:22:02 <ibid> lambdabot: there's the freenode notes system, too :)
05:22:05 <apfelmus> explicitjelly: it's "right associative" which means not associative at all (but unparenthesised expression like a -> b -> c get their parens nested rightmost a -> (b -> c))
05:25:03 <dons> ibid: you find it embarassing?
05:25:13 <dons> if you want to patch, to use notes, that'd be good :)
05:25:23 <ibid> dons: nope, just strange
05:25:42 <dons> we considered just privmsg, but people thought that was too confronting
05:26:03 <ibid> dons: i was actually wondering why lambdabot has the feature at all
05:26:21 <dons> ah yes. I see.
05:26:22 <explicitjelly> apfelmus, ok, that's consistent with what I thought it was earlier, but all the confusion led to some strange things.
05:26:27 <dons> someone sent a patch :)
05:26:32 <explicitjelly> aaah, I think I really got it now. I'll try it out.
05:26:56 <ibid> lispy: best to send me email
05:28:59 <dons> here's a fun game, how many lines of C in gnu tac.c is this equivalent to: main = B.putStr . B.reverse =<< B.getContents
05:29:02 * apfelmus1 uses a dialup line and strongly believes in error correction signal transmission
05:29:55 <araujo> dons, 1000 ?
05:29:59 <dons> close. 757
05:30:03 <araujo> hah
05:30:16 <dons> think of the productivity gains to be had!
05:30:32 <ndm> dons: really? what do they do that you don't
05:30:45 <dons> they do all the lazy io manually
05:30:58 <audreyt> dons: how's the paper going? is it possible to get an early preview? :)
05:31:02 <ndm> thats not 757 lines
05:31:13 <dons> ndm, http://www.koders.com/c/fid7BF314A5F0B3A30EADEADCD93C79D5771191FF2C.aspx
05:31:16 <lambdabot> Title: Koders - tac.c, http://tinyurl.com/rh9pd
05:31:33 <dons> ;)
05:31:35 <dons> audreyt: certainly
05:31:42 <dons> shall I mail you the early edition?
05:31:47 <audreyt> sure!
05:31:54 <audreyt> audreyt at audreyt dot org -- or /msg me a url :)
05:31:58 <dons> right
05:32:00 <audreyt> (latter is preferred)
05:32:08 <dons> ok. let me see..
05:32:10 <audreyt> (as I'm still rebuilding my workspace following macbook crash)
05:32:24 <audreyt> the physical kind, not the software kind
05:32:28 <ndm> dons: that does option handling, license block etc - its hardly 757 lines of code
05:32:36 <dons> yes :)
05:32:50 <ndm> although of course i realise that haskell is much much shorter :)
05:33:34 <xs> also it can deal with files that will not fit in memory?
05:33:35 <explicitjelly> Heffalump, apfelmus: puh, I finally made it. you know what the biggest problem was? I should really stop of thinking of f :: a -> b -> c as "f takes two arguments". that sometimes leads you to serious trouble :)
05:33:47 <audreyt> perl -0777pe $_=reverse
05:33:52 <audreyt> that's all :)
05:33:57 <dons> the haskell version does, xs, yes.
05:34:04 <dons> since it usees lazy io , it runs in constant space
05:34:35 <apfelmus> explicitjelly: in fact, there are *no* functions that take two arguments :)
05:34:41 <explicitjelly> so now to the *real* definition of bind. what was its type? m a -> (a -> m b) -> m b?
05:34:46 <explicitjelly> apfelmus, right :)
05:35:08 <apfelmus> explicitjelly: that's the type
05:35:32 <explicitjelly> apfelmus, they all take one argument and maybe return a new function. I always knew that, but I always also automatically oversimplified it. wrongly.
05:36:05 <xs> dons, reverse runs in constant space?
05:36:10 <apfelmus> explicitjelly: even f :: (a,b) -> c takes only one argument
05:36:19 <ndm> dons, how can it run in constant space?
05:36:19 <dons> xs, oh hmm :)
05:36:22 <ndm> @pl runIdentity . (return . f)
05:36:22 <lambdabot> runIdentity . return . f
05:36:22 <dons> hehe
05:36:26 * dons should get some sleep
05:36:34 <ndm> @pl \ f -> runIdentity . (return . f)
05:36:34 <lambdabot> ((runIdentity . return) .)
05:36:36 <xs> :)
05:37:16 <explicitjelly> apfelmus, a tuple. as I said, illegal oversimplifying
05:37:23 <audreyt> it can run in constant space by making a fusion that does a reverse seek/getc ;)
05:37:42 <dons> it could i suppose, yes.
05:37:54 <dons> we'd need readIOUp and readIODown
05:37:57 <audreyt> it's probably not as silly as it looks
05:37:59 <dons> not a bad idea...
05:38:12 <dons> we've pondered fusible io
05:38:21 <audreyt> esp on mmapped files
05:38:31 <audreyt> where there's no hard disk spin bias
05:39:10 <audreyt> I mean, there's no reason why a "reverse view" has to malloc...
05:39:59 <dons> right, we could have custom readIO and writeIO, that build streams directly
05:40:07 <audreyt> yup
05:40:27 <ibid> lispy: also, note that had you used this method, i would have noticed your question much earlier :)
05:40:38 <ibid> lispy: (i don't talk as often as i write)
05:40:44 <ibid> dons: note ^ too :)
05:40:49 <ibid> gah
05:40:55 <ibid> lispy: (i don't talk as often as i read)
05:40:58 <ibid> ^that
05:41:14 <dons> yeah that's a good idea
05:41:32 <ibid> what's a good idea?
05:41:40 <ibid> but anyway...
05:42:11 <ibid> lispy: there is no connection between your irc persona and that blog. email me instead :)
05:42:14 <dons> using notes instead
05:42:27 <ibid> dunno if notes work any better
05:42:53 <ibid> i find that putting stuff in peoples' backlog works better than either method
05:42:57 <ibid> (what i just did to lispy:)
05:43:03 <dons> yeah, quite possibly
05:43:23 <ndm> dons, why can't @tell prompt you both the first time you talk, and when you log on?
05:43:40 <dons> its not smart enough.
05:43:46 <dons> it could be though...
05:43:47 <ibid> wouldn't have helped here
05:44:14 <dons> ok, i'll add: case user of "ibid" -> yellReallyLoudly msg ; _ -> tell msg
05:44:28 <ibid> heh :)
05:45:24 <ibid> dons: the point being that i'm "in irc" all the time, and reconnect only when something goes wrong, and that i read this channel regularly, but write to it only when i have something to say
05:45:58 <dons> oh, i agree. i prefer people to back log me too
05:46:06 <dons> for the same reasons
05:46:13 <kpreid> Is there an xor for Bool?
05:46:20 <ibid> dons: so a lambdabot message meant for me could sit for days without me seeing it, when backlogging would have caught me in hours tops
05:46:37 <ibid> (this one sat for one day and 8 hours)
05:46:41 <dons> tell is really more for people who aren't connected at all
05:46:47 <ibid> yes
05:47:13 <ibid> dons: lambdabot could say "ibid is on irc; backlog him instead" :)
05:47:33 <dons> it could
05:47:54 <dons> "tell him yourself. he's in the room"
05:47:58 <ibid> :)
05:48:00 <ndm> it could even backlog him directly
05:48:14 <ibid> yeah
05:48:15 <norpan> huh, backlog?
05:48:27 <dons> hmm. that's an idea
05:48:31 <ndm> or you could klet people associate an email with their username, and lambdabot could email off the @tell if they don't pick it up in 12 hours
05:48:45 <dons> oh, good. lambdabot spam :)
05:48:51 <ibid> norpan: either msging someone or putting stuff on a channel they are in, with their nick as the tag so that it gets highlighted
05:48:53 <Heffalump> does lambdabot track people by their registered nicks?
05:49:06 <dons> it tracks nicks
05:49:10 <dons> it doesn't know what people are
05:49:17 <Heffalump> If I quit freenode and someone comes along with nick Heffalump, they'll get to use it until I come back and use NickServ to boot them off
05:49:18 <norpan> ok, but what if that person doesn't keep logs
05:49:19 <ndm> yet :)
05:49:27 <norpan> otoh they should not idle then
05:49:27 <ndm> you can only do it for registered users
05:49:30 <ndm> can it figure that out?
05:49:35 <Heffalump> so that person would be able to use my super-lambdabot powers
05:49:43 <ibid> norpan: they lose :)
05:49:49 <norpan> they do indeed
05:49:57 <dons> Heffalump: yeah, so you better register and identify
05:50:02 <ibid> msging is probably the most robust method short of email
05:50:06 <Heffalump> I have registered and I do identify.
05:50:18 <Heffalump> But that doesn't stop someone else using my nickname while I'm not here, does it?
05:50:25 <dons> it does, doesn't it?
05:50:26 <edwardk> dons: can you get lambdabot to join @chess for a minute?
05:50:29 <ndm> it means they can't identify
05:50:30 <edwardk> er
05:50:32 <edwardk> #chess
05:50:33 <kpreid> dons: it doesn't
05:50:33 <Heffalump> ndm: right.
05:50:35 <dons> they gett foo' don't they?
05:50:39 <ibid> dons: lambdabot should probably msg immediately and at every rejoin until messages are cleared
05:50:53 <ndm> and every 5 minutes as well :)
05:51:04 <kpreid> dons: registration doesn't prevent others using the nick unless you have a hostmask and some option
05:51:08 <Heffalump> oh, I'm identified by my hostname
05:51:09 <dons> ah
05:51:14 <dons> me too, that's the issue
05:51:46 <Cale> dons: hmm, the example corresponding to formula 1.17 in that book is a little odd
05:52:00 <ibid> i provide identity password at connect time (not as a msg to chanserv)
05:52:11 <Cale> I'd think that 1.17 is still consistent, it's just that its inclusion would prove "junk nat"
05:52:17 <dons> in Harper's book, Cale?
05:52:22 <Cale> yeah
05:52:52 <Cale> oh, nevermind
05:53:10 <Cale> He has a very particular definition of admissible
05:53:25 <dons> ah yes, on the next page?
05:53:41 <Cale> on the same page actually
05:54:16 <dons> ah yes
05:54:55 <Cale> Currently there's no sense of negation at all, so the sort of admissibility I was thinking of doesn't really make sense here either, I suppose :)
05:56:23 <Cale> anyway, time for sleep
05:56:35 <Cale> the sun is rising :)
05:57:27 <int-e> the daystar!
06:01:59 <musasabi> What was the right way to combine bracket and unsafeInterleaveIO ?
06:02:15 <explicitjelly> hah. I implemented my first Monad. it's a "Counter monad".
06:02:36 <musasabi> i.e. be lazy but don't forget to close the resources.
06:03:28 <musasabi> My current aproach looks like 1) open resource, 2) use it, 3) unsafeInterleaveIO, 4) close it, 5) evaluate lazily -> use it, 6) segfault
06:03:52 <explicitjelly> and it totally rocks your world by counting the computations you do!
06:04:01 <Heffalump> cool :-)
06:04:14 <apfelmus> musasabi: ah, closing is difficult. you have to put this inside the interleaved stuff
06:04:21 <musasabi> I would like to omit the step 6.
06:04:40 <musasabi> apfelmus: but how to do that safely with exceptions?
06:05:04 <apfelmus> musasabi: step 4) has to come after step 5)
06:05:04 <musasabi> or simply discarding the lazy thunk.
06:05:15 <musasabi> I know :-)
06:05:45 <apfelmus> intervleaveIO (catch (intelligent work) (close close close))
06:06:30 <musasabi> does not really help if the caller does not evaluate the thing.
06:06:38 <musasabi> Perhaps ForeignPtr could work.
06:07:51 <apfelmus> musasabi: ah. the caller goes bang and the lazy resource hangs around unused.
06:22:22 <tibbe_> @quote
06:22:22 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
06:22:53 <tibbe_> @quote
06:22:54 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
06:22:54 <lambdabot> godawful construct?
06:25:00 <tibbe_> @quote
06:25:01 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
06:25:10 <tibbe_> I'm awfully strict today
06:25:46 <tibbe_> can't change my nick either :/
06:44:50 <ndm> how do i get round the following cabal error?
06:44:56 <ndm>    conflict: module `System.Posix.Signals' belongs to the current program/libray
06:44:57 <ndm>    and also to package base-1.0
06:45:12 <ndm> I want to use the one from the current program, and not from base-1.0
06:49:39 <Lemmih> ndm: Rename it or hide base.
06:50:12 <ndm> Lemmih: i can't rename it, and if I hide base, what happens to things like Prelude/Data.List ?
06:50:30 <Lemmih> Why can't you rename it?
06:51:11 <ndm> Lambdabot uses System.Posix.Signals
06:51:28 <ndm> On windows, that module exports nothing, so I want to write a replacement with the appropriate stubs
06:51:31 <Lemmih> And it includes its own copy?
06:51:38 <ndm> nope, it uses the one in base
06:51:44 <ndm> which is massively broken (as in empty!)
06:52:09 <Lemmih> Then you have to use CPP.
06:52:40 <ndm> :(
06:53:04 <ndm> fair enough though, i blame base for providing a broken API
06:56:46 <Igloo> ndm: Which version of GHC?
06:56:58 <ndm> Igloo: all
06:57:06 <Igloo> Including 6.6 snapshots?
06:57:29 <ndm> As far as I know - i only bought it up a week ago, and Simon said it would get done after 6.6
06:57:51 <ndm> on Unix it defines a complete API, on Windows its entirely empty apart from a module header
06:58:05 <ndm> hence guaranteeing its impossible to create a windows stub even
06:58:48 <Igloo> ndm: Works for me with a recent 6.5
06:59:19 <ndm> Igloo: on Windows? System.Posix.Signals?
06:59:44 <Igloo> Compiling   module System.Posix.Signals (foo) where\nimport Data.List\nfoo = Data.List.unfoldr
07:00:14 <ndm> Igloo: using Cabal?
07:00:27 <Igloo> With GHC, on Linux
07:00:41 <ndm> ghc --make, or cabal build ?
07:00:46 <Igloo> ghc -c
07:01:48 <ndm> yeah, Lambdabot builds with Cabal, so was hoping to keep that going
07:02:02 <ndm> GHC overrides packages with local copies, i seem to remember, where available
07:02:09 <goltrpoat> how optimized is Data.Word64?
07:02:47 <Igloo> It doesn't work with GHC 6.4.1. I don't know, but I don't think cabal would be doing anything that would break it
07:03:20 <goltrpoat> eg, ceg, complement 0::Word64 -- am i looking at two nots on a 32 bit machine, or a function call?
07:03:20 <Lemmih> goltrpoat: Operations are still performed with slow C calls on 32bit machines.
07:03:30 <goltrpoat> yikes.
07:04:46 <ndm> Igloo: ah well, will wait for 6.6 and then have another go at compilnig lambdabot i guess - thanks for your help
07:06:01 <Igloo> ndm: If you have time, it would be useful to know if it doesn't work with an RC
07:06:23 <lisppaste2> nadar pasted "wormnet" at http://paste.lisp.org/display/25237
07:06:30 <ndm> Igloo: will do, when i get back to York - I'm going to upgrade to 6.6 RC and use that as my main compiler
07:06:53 <Igloo> ndm: I'm running a couple of GHC compiles with buildbot now, BTW. I was worried that it wouldn't allow us to split up the testsuite output nicely, but actually it seems it does that very well
07:06:59 <Igloo> Cool
07:07:07 <ndm> neat :)
07:07:36 <eivuokko> Igloo, Cool!
07:07:53 <Igloo> Although as I say that, the Windows build falls over
07:08:06 <eivuokko> Heh
07:08:38 <eivuokko> Have you got a Windows build or know if someone else has for RC?  Do others get same failures as JaffaCake?
07:09:06 <Igloo> Oh, I forgot it needs special configure flags
07:10:59 <Igloo> eivuokko: I got http://urchin.earth.li/~ian/wts.txt (conc036 deadlocked IIRC) with ghc-6.5.20060831-src.tar.bz2 from http://www.haskell.org/ghc/dist/current/dist/
07:11:54 <Igloo> ndm: Do you know if sighupping the master will cause the other slave to restart?
07:12:26 <eivuokko> Igloo, Those failures look normal (if you didn't build all the libs)
07:12:29 <ndm> Igloo: no idea
07:12:46 <eivuokko> Igloo, And deadlocking ffi calls...well, I think I have seen that once...but not sure
07:12:57 <eivuokko> Wait...stableptr fail, hmmm
07:13:40 <eivuokko> Igloo, hard to say...don't seem like the alloc failures JaffaCake got...
07:22:03 <Igloo> eivuokko: Bother, it seems the answer is yes
07:22:05 <Igloo> Ooops
07:22:13 <Igloo> s/eivuokko/ndm/
07:22:42 <ndm> Igloo: what exactly is sighupping the master?
07:22:44 <eivuokko> Igloo, conc036 is Sleep ffi iirc, I think the problem might be that during Sleep there could be spurious wake ups...
07:22:52 <Igloo> ndm: Telling it to reload the config file
07:24:13 <gour> any python programmer here with some free time?
07:26:04 <Igloo> eivuokko: I'll hopefully do another run soon with a more up-to-date tree
07:27:11 <gour> (who can say something in regards python vs. haskell)
07:27:14 <eivuokko> Igloo, Could you do few extra runs in concurrent dir and see if any tests fail with VirtualAlloc MEM_COMMITs, please?
07:27:40 <eivuokko> I'm sort of out of options because none of the tests fail on machines I have access to.
07:27:52 <eivuokko> Atleast that fail that way...
07:29:12 <Igloo> OK, I'll try that with a more up-to-date tarball later today
07:33:52 <xs> gour, such as?
07:35:12 <gour> xs: i have (again) some discussion with python folks in #sandbox over python vs. haskell issue. i like (and learn) haskell, but since i never used python, i cannot explain them what are the merits of haskell over python
07:36:05 <gour> xs: if you have some time, you can quickly jump into #sandbox
07:39:35 <vincenz> sandbox?
07:39:54 <gour> vincenz: channel on freenode - #sandbox
07:42:46 <vincenz> I realized that, just find it an odd name :)
07:43:02 <gour> vincenz: well...
07:46:33 <audreyt> @hoogle a -> ()
07:46:35 <lambdabot> No matches, try a more general search
07:48:02 <xerox> ?type const ()
07:48:04 <lambdabot> forall b. b -> ()
07:48:15 <Igloo> Can I make cygwin ps show me command arguments?
07:50:32 <audreyt> xerox: I know, I just wantto see ifthere's anything ->()
07:50:33 <gour> ndm: xs is fighting in #sandbox
07:50:37 <audreyt> which is very pointless
07:54:39 <Igloo> audreyt: Did you fix your segfaulting problems, BTW?
07:55:44 <edwardk> http://channel9.msdn.com/Shows/Going_Deep
07:55:46 <lambdabot> Title: Channel 9
07:55:49 <edwardk> bit about STM
07:55:52 <edwardk> if anyone cares
07:57:55 <lisppaste2> nadar pasted "echat" at http://paste.lisp.org/display/25246
07:58:20 <audreyt> Igloo: JaffaCake noted an obviously wrong part in RTS shutdown code
07:58:25 <audreyt> and fixed it promptly
07:58:33 <Igloo> audreyt: I mean the coercing stuff
07:58:39 <audreyt> oh.
07:58:48 <audreyt> under -O, [] still doesn't like to be coerced to Word#
07:58:52 <audreyt> so I did an explicit typerep test
07:58:56 <audreyt> sad but true
07:59:03 <audreyt> I don't quite know what's going on
07:59:06 <audreyt> -O0 works just fine
08:00:43 <Igloo> Hmm, it works for me
08:01:13 <Igloo> With just   main = print (W# (unsafeCoerce# [] :: Word#))
08:11:57 <audreyt> let me reproduce a simple case
08:12:00 <audreyt> (yes that works for me too)
08:16:56 <Igloo> Hmm, GHC's char-at-a-time printing doesn't play well with buildbot: <span class="stdout">c</span><span class="stdout">a</span><span class="stdout">n</span><span class="stdout">n</span><span class="stdout">o</span><span class="stdout">t</span><span class="stdout">
08:17:19 <Heffalump> hehe
08:17:33 <audreyt> Igloo: it defeats simplification
08:18:02 <audreyt> and worst yet, adding -g causes compilation to not terminate
08:18:03 <audreyt> -optc-g that is
08:18:10 <audreyt> so I'll go with my workaround for now
08:18:20 <audreyt> instead of delaying your release engineering :)
08:21:09 <binary42> Can someone help me get happy built on my MacBook?
08:21:49 <binary42> I get "Unrecognised platform: i686-apple-darwin8.7.1" from configure and have no ddesire to muck around in auto-tools to figure it out brute force.
08:24:04 <Igloo> binary42: Search for darwin in configure, copy the 9 lines and change all powerpc's to i386
08:24:26 * binary42 tries that.
08:24:28 <Igloo> binary42: Oh, except the first one which should be i[3456]86
08:24:52 <Igloo> the one on a line ending in ')'
08:26:26 <binary42> thanks.
08:26:39 <ndm> who is in charge of haskell.org mailing lists?
08:27:19 <Igloo> Simon Marlow I think
08:27:53 <ndm> Igloo: cheers :)
09:07:19 <gour> ndm: what would be the main difference between yhc's & jhc's objective?
09:07:40 <ndm> gour: portable and simple vs fast
09:07:57 <ndm> oh, and Yhc has a massive focus on debugging support, jhc has none
09:08:12 <ndm> and Yhc is going to be massively faster at compile time
09:08:22 <gour> so, yhc will be more suited for some linux-based pdas?
09:08:37 <ndm> probably, yes
09:08:45 <gour> ndm: thank you for sandboxing help.
09:08:55 <ndm> although jhc always has good points to it for linux-based pda's
09:09:07 <ndm> gour: on problems, i think they are still dynamic types people though
09:09:15 <ndm> java and c were their languages with types, hehe
09:09:29 <gour> ndm: true. they cannot see farther from the nose
09:10:10 <ndm> very few people know the joys of haskell :)
09:10:23 <gour> sad, but true...
09:10:37 <gour> ndm: there is no ebuild for yhc in gentoo-haskell ?
09:10:48 <ndm> gour: Yhc hasn't been released yet
09:11:08 <ndm> gour: still a few fatal bugs floating around, just requires time to fix up
09:11:12 <gour> ndm: same as yhc, but there is jhc-darcs ebuild?
09:11:19 <gour> ndm: ahh, ok
09:11:31 <Pupeno> @help where+
09:11:32 <lambdabot> where+ <key> <elem>. Define an association
09:11:54 <Pupeno> @where+ folds http://cale.yi.org/index.php/Fold_Diagrams
09:11:55 <lambdabot> Done.
09:12:06 <Pupeno> @where+ "fold diagrams" http://cale.yi.org/index.php/Fold_Diagrams
09:12:07 <lambdabot> Done.
09:12:19 * gour would like to see yhc compiling gtk2hs...
09:12:31 * ndm would too, but itwill take a while...
09:12:32 * dcoutts__ would too
09:12:38 <ndm> although once it happens, we'll suddenly eliminate link time!
09:12:49 <dcoutts__> heh
09:13:05 <gour> ndm: how?
09:13:19 <ndm> gour: runtime linking, lightening fast
09:13:53 <gour> ndm: any tradeoff?
09:14:09 <ndm> gour: slower than GHC, doesn't produce a static .exe
09:14:42 <gour> ndm: what about portability on win32 then?
09:15:10 <ndm> 100% portable, double click a .hbx (haskel bytecode executable), and off it runs
09:15:35 <gour> so bytecode interpreter is needed
09:15:43 <ndm> indeed, and we haev one
09:16:02 <ndm> or you can splat your bytecode file at the endo f the bytecode interpetter (200Kb), and have a static .exe which does it all as one file
09:16:54 <cpatrick> That's cool
09:17:22 <cpatrick> Why doesn't GHC support dynamic linking? Is there are technical reason or do the ABIs just change too fast for it to be sane yet?
09:17:44 <Heffalump> I think it's technically difficult, though people do do it - see hs-plugins
09:18:19 <cpatrick> yeah. But no offense to dons, hs-plugins is more than a little bit evil :-)
09:18:32 <cpatrick> It's not as straightforward dlopen() in C, e.g.
09:18:36 <cpatrick> or gcc -shared
09:18:49 <Heffalump> well, dlopen provides a C interface
09:19:33 <gour> ndm: i sounds great
09:19:47 <ndm> it will be, when its finished...
09:22:13 <gour> ndm: all the best
09:23:57 <audreyt> cpatrick: System.Posix.DynamicLinkder
09:24:09 <audreyt> DynamicLinker, even.
09:52:57 <ihope_> > sequence ["([{",")]}"]
09:53:02 <lambdabot>  ["()","(]","(}","[)","[]","[}","{)","{]","{}"]
10:07:40 <ihope_> @hoogle lookup
10:07:41 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:07:41 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
10:07:41 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
10:08:16 <ndm> has anyone got any statistics on teh most used modules?
10:08:30 <ndm> i.e. in that above example, Data.Map.lookup should be 2nd
10:09:05 <ihope_> What's the shortest way to turn "foo=bar:baz" into "foo", "bar", and "baz"?
10:09:32 <ndm> let foo@(bar:baz) = x in ...
10:09:45 <ndm> ihope_: or f foo@(bar:baz) = etc..
10:10:25 <ihope_> The string "foo=bar:baz", not foo which is equal to bar consed onto baz.
10:11:17 <ndm> (a,'=':b) = break (== '=') xs
10:11:30 <ndm> (c,':':d) = break (== ':') b
10:16:21 <ihope_> Thanks.
10:17:43 <vincenz> > break (== 'a') "xaz"
10:17:44 <lambdabot>  ("x","az")
10:17:48 <vincenz> > break (== 'a') "xaza"
10:17:49 <lambdabot>  ("x","aza")
10:20:28 <ihope_> Server name (PortNumber (fromInteger (read prt)))
10:20:38 <ihope_> I think I need more parentheses.
10:21:43 <xerox> ?type fromInteger
10:21:45 <lambdabot> forall a. (Num a) => Integer -> a
10:21:47 <xerox> ?type read
10:21:49 <lambdabot> forall a. (Read a) => String -> a
10:21:52 <eivuokko> Any wxhaskell devels here?  Is there plans to move to use Cabal?  Good chance now that ghc 6.6 package system breaks the build...
10:22:35 <xerox> ihope_: What sense do "fromInteger . read" mean?
10:23:00 <ihope_> It reads something as an integer, then un-integers it.
11:03:42 <explicitjelly> so, let's check out HList.
11:05:15 <Pupeno_> while taking a shower I realized that Haskell might be a good language for web programming... after all, web programming seems almost functional (the function defined by the url or set of url and everything else a parameter, you give back an html).
11:06:03 <dolio> ?where hsp
11:06:03 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
11:06:56 <musasabi> Any good idea how to make haddock differentiate between Data.ByteString.ByteString and Data.ByteString.Lazy.ByteString in the generated documentation?
11:07:36 <dcoutts__> musasabi: well it links to different targets
11:08:06 <dcoutts__> perhaps haddock should use whatever import qualifier is used in the module
11:08:08 <dolio> Haskell equivalent of ASP/PHP/etc. with first-class XML fragments. :)
11:09:06 <musasabi> hm. type LazyByteString = BL.ByteString in the module worked.
11:10:00 <dcoutts__> mm
11:11:19 <musasabi> except it has to be in export lists and if many modules define it.. (of course I could make a new module for defining that, but it would be ugly)
11:12:07 <Pupeno_> dolio: I'd like to see Haskell equivalent of Django.
11:12:59 <dolio> Pupeno_: :) That might be a little more work.
11:13:31 <Pupeno_> dolio: I know.
11:14:18 <dolio> Hehe, a couple folks over in the #D room are marveling over the new 'lazy syntax'. So you can write "parallel(foo(), bar(), baz());" and foo, bar and baz don't get called strictly. :)
11:14:49 <Korollary> how are they called?
11:15:03 <ndm> dolio: their lazy syntax is quite impressive, for an imperative strict language
11:15:43 <dcoutts__> ml has something sensible iirc
11:15:49 <dcoutts__> suspend and force iirc
11:16:05 <dcoutts__> which really are magic, but are used like normal functions
11:16:08 <dolio> ndm: I was surprised to hear of it. I wouldn't have thought it'd be easy in such a language.
11:17:07 <dolio> But then, I guess it's not just C already. They have closures and such.
11:17:40 <Pupeno_> dolio: is D lazy by default now ?
11:17:52 <ndm> no, only very small lazy
11:18:26 <jrmole> the lazy stuff in SICP is done with no magic
11:18:36 <jrmole> just throwing zero-argument lambdas around things
11:18:42 <Pupeno_> obziously you can write code that in a lazy environment works and in a strict environment doesn't. Is the reverse possible ?
11:19:05 <jrmole> Pupeno_, not in a pure sense
11:19:36 <Korollary> jrmole: that doesnt work if you want to save the result for later, does it?
11:19:48 <jrmole> Korollary, what do you mean?
11:19:53 <dolio> Memoizing.
11:20:29 <jrmole> it doesn't implement graph reduction, if that's what you mean
11:20:35 <dolio> They do that in some part of SICP, too...
11:21:23 <dolio> You just need an if and a set!, as I recall.
11:21:29 <Korollary> R5RS implements it as a macro with a flag that specifies whether the result's been calculated before.
11:23:51 <dolio> I guess it does memoizing when it implements full lazy evaluation, though, not on just force/delay.
11:24:23 <Pupeno_> can I redifine foldr for othe types ?
11:30:42 <jrmole> Pupeno_, what sort of types?
11:31:00 <musasabi> Pupeno_: e.g. in a pure language lazy>strict, but if there is unsafePerformIO mixed then not all strict programs work when evaluated in a lazy fashion.
11:32:09 <musasabi> For custom folds Data.Foldable (GHC 6.5/6.6) is quite nice if a typeclass is wanted.
11:33:22 <jrmole> in theory all the list ops should be in some Sequence typeclass
11:33:32 <jrmole> but there's all kinds of implementation problems with that, as has been discussed on the list
11:33:53 <Pupeno_> jrmole: for my binary tree type.
11:41:40 <Pupeno_> I am reading the section on continuation-passing-tyle in YAHT and all it is, in fact, is higher-order-functions... right ? am I missing something ? I can't find anythnig like scheme's call/cc.
11:42:18 <Korollary> CPS doesn't require call/cc iirc
11:43:43 <JosephRivers> Hi, I used an import like this: import Data.Set as Set, and now when I try to use the map function I get a namespace collision--what's going on?
11:44:01 <Korollary> you left out qualified I think
11:44:24 <JosephRivers> how do you add in the qualified?
11:44:28 <Korollary> import qualified ...
11:45:07 <beschmi> Pupeno_: if you use CPS, you can capture the current continuation since it's just an ordinary argument to your function
11:45:07 <JosephRivers> so: import qualified Data.Set as Set?
11:45:11 <Korollary> JosephRivers: yes
11:45:16 <JosephRivers> okay, thanks
11:46:28 <beschmi> if your language supports callcc (or you use something like the Cont monad in haskell), you can get the contnuation even if you write the code in direct style
12:12:17 <jrmole> Pupeno_, there's a Cont monad
12:12:29 <jrmole> which may provide something more like what you want
12:12:34 <vincenz> JosephRivers: or "import qualified Data.Set as S"
12:12:55 <jrmole> and yeah, CPS is specifically a way to emulate call/cc in languages without it, iirc
12:14:08 <vincenz> jrmole: and a good way to compile it :)
12:14:12 <vincenz> well ... easy way
12:14:21 <jrmole> yeah
12:36:05 <Baughn> I'm looking to write a simple webapp, and learn some Haskell along the way. So.. I'll need a mysql/odbc library, and either cgi or http-server. Any suggestions for those, or anything CCLAN-like?
12:36:11 <Pupeno_> weird that or is not an infix function... kinda nice actually.
12:37:27 <Pupeno_> Baughn: have you went through some kind of tutorial yet ?
12:38:09 <jrmole> Pupeno_, there's (||)
12:38:20 <Baughn> Pupeno_: A few, yes. I'm having a bit of trouble actually /compiling/ my code, but nothing that won't clear up eventually - I'm familiar with the language type already
12:38:21 <Pupeno_> jrmole: oh!
12:38:33 <Pupeno_> Baughn: oh, ok then.
12:40:15 <Korollary> Baughn: seen http://haskell.org/haskellwiki/Libraries_and_tools/Web_programming ?
12:40:18 <lambdabot> Title: Libraries and tools/Web programming - HaskellWiki, http://tinyurl.com/h6rer
12:40:54 <Baughn> Korollary: Nope, but that looks like the CCLAN-like thing I was looking for. Thanks!
12:44:17 <Pupeno_> using case  ... of, can I test for more than one pattern in the same clause ?
12:45:54 <Korollary> to do what?
12:46:24 <Pupeno_> lisppaste2: url?
12:46:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:46:48 <lisppaste2> Pupeno pasted "to reduce repetition here." at http://paste.lisp.org/display/25271
12:47:08 <Igloo> dcoutts__: What's the relationship between the -s argument to xargs and the time taken by ar again?
12:47:42 <Igloo> dcoutts__: And do you know a definitely-safe value for Windows?
12:48:48 <Korollary> Pupeno_: you could bind the common putStrLn to something and use it. alternatively, you can go for logical or with ==.
12:50:39 <eivuokko> Igloo, Are you talking about real ar (used perhaps via makefile) or Cabal xargs functionality?  If the paths are absolute, there is no definetely safe.  Otherwise, go for about 30k characters long commandlines.
12:51:06 <Igloo> eivuokko: Nothing to do with cabal
12:51:19 <Igloo> Just | xargs c:/ghc/ghc-6.4.2/bin/ar
12:51:56 <eivuokko> Ok, 30k is the guesstimate dcoutts used in Cabal, which seems to work for me.  Theoretically it's 32k commandlines, but that didn't work for me.
12:52:49 <Igloo> OK, thanks
12:53:02 <eivuokko> (I was talking about characters, not files, btw)
12:55:28 <Igloo> *nod*
12:56:34 <dcoutts__> Igloo: it's quadratic
12:56:52 <dcoutts__> using ar in bigger chunks is much faster
12:57:04 <dcoutts__> Igloo: so if unix can do >32k then it's worth it
12:57:22 <dcoutts__> though you won't notice unless you cabalise base
12:57:25 <Igloo> dcoutts__: So the length of each run is linear?
12:57:42 <dcoutts__> I think so, roughly
12:58:03 <dcoutts__> it's at least linear
12:58:07 <dcoutts__> it rebuilds the index each time
13:00:58 <beschmi> anyone familiar with getArgs and unicode on windows? does it break every character into multiple word8 like on unix?
13:04:16 <eivuokko> I haven't checked, but I think ghc's getArgs goes via 8bit conversion, ie unicode is lost via unicode -> 8bit characters conversion.
13:04:55 <thetallguy> Anyone know about ghci's loading mechanisms?
13:05:06 <eivuokko> Windows commandlines are not transferred as bytes (like in unix), but they are assumed to be either unicode or 8bit codepage characters, depending API via which they are given.
13:07:06 <eivuokko> thetallguy, Just ask the question, maybe with help from pastebin.
13:07:59 <thetallguy> file a.hs references a C function written in c.c, file b.hsc is processed by hsc2hs
13:08:26 <thetallguy> When compiled, the program runs fine
13:08:56 <thetallguy> if I load a.hs in ghci and try to evaluate a function f in a.hs, it failes to find the function defined in c.c
13:09:13 <thetallguy> It's a .o
13:09:19 <thetallguy> Do I have to get it into a library?
13:09:45 <beschmi> eivuokko: ok, do you know if the behaviour is the same for filePath (e.g. getDirectoryContents)
13:09:52 <beschmi> i'm trying to fix a darcs bug
13:10:00 <Igloo> thetallguy: You can give .o files on the ghci commandline
13:10:37 <eivuokko> And in this case must give the .o file in commandline, as ghci won't know the right file otherwise.
13:11:12 <eivuokko> beschmi, I certainly hope it isn't!  It shouldn't be, getArgs might be a bit special because ghc parses RTS options from it.
13:11:23 <eivuokko> beschmi, That is to say: I don't know.
13:12:08 <thetallguy> igloo: that worked, except apparently now I have to recurse through the libraries it brings in as well.
13:15:54 <eivuokko> beschmi, http://darcs.haskell.org/packages/base/System/Directory.hs If I read that file correctly, uhm, yes, no unicode via getDirectoryContents
13:15:58 <eivuokko> That's nasty!
13:17:14 <eivuokko> Argh.
13:18:12 <musasabi> Is there a good and postable way to do unicode for filepaths - that really works?
13:19:00 <eivuokko> Isn't that just peekUnicodeFilepath and withUnicodeFilepath per system?
13:19:00 <musasabi> as different operating systems use different normalization conventions for filenames...
13:19:26 <eivuokko> I believe you can't do normalisation portably and conviently.
13:20:13 <thetallguy> Igloo: thanks, working now.
13:22:40 <beschmi> eivuokko: oh, thanks for the info. seems like the encode :: [Char] -> [Word8] used for FilePath in darcs is just there in case this changes
13:35:19 <Itkovian> @seen vincenz
13:35:20 <lambdabot> vincenz is in #oasis and #haskell. I last heard vincenz speak 1h 21m 9s ago.
13:35:29 <vincenz> hi
13:35:35 <Itkovian> hi
13:35:36 <lambdabot> Itkovian: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:36:00 <Itkovian> can we talk about the 'tool' sometime tomorrow? on irc or skype?
13:36:03 <vincenz> sure
13:36:05 <vincenz> what time?
13:36:27 <Itkovian> difficult to tell, i'm working at home and my timing is arranged by my kid
13:36:33 <vincenz> well
13:36:36 <vincenz> hmm
13:36:44 <vincenz> more or lessish
13:36:47 <Itkovian> say around 10:30 or so, should be possible
13:36:49 <vincenz> ok
13:36:57 <vincenz> my skype is
14:22:18 <ihope_> Can guard go in case statements?
14:23:10 <kosmikus> yes
14:26:47 <dolio> ?pl \xs -> [ x + y | x <- xs, y <- xs]
14:26:48 <lambdabot> ap ((:) . (x +) . ((y | x) <-)) (return . (y <-))
14:28:07 <dolio> ?pl \xs -> do { x <- xs ; y <- xs ; return (x + y) }
14:28:08 <lambdabot> (line 1, column 11):
14:28:08 <lambdabot> unexpected "{"
14:28:08 <lambdabot> expecting variable, "(", operator or end of input
14:28:10 <tibbe> @pointlessform repeat [1..]
14:28:11 <lambdabot> Unknown command, try @list
14:29:31 <dolio> ?pl \xs -> xs >>= \x -> xs >>= \y -> return (x + y)
14:29:31 <lambdabot> ap (>>=) (flip (fmap . (+)))
14:36:46 <vincenz> dolio: doesn't work for comprehensions
14:36:54 <dolio> :) I noticed.
14:37:34 <vincenz> @pl ap (>>=) (flip (fmap . (+)))
14:37:34 <lambdabot> ap (>>=) (flip (fmap . (+)))
14:41:02 <dolio> @. pl undo ap (>>=) (flip (fmap . (+)))
14:41:03 <lambdabot> ap (>>=) (flip (fmap . (+)))
14:50:52 <sjanssen> @. pl undo \xs -> do { x <- xs ; y <- xs ; return (x + y) }
14:50:53 <lambdabot> ap (>>=) (flip (fmap . (+)))
14:51:39 <dolio> Oh, well.
14:51:51 <dolio> @. pl ap (>>=) (flip (fmap . (+)))
14:51:51 <lambdabot> compose module failed: IRCRaised Parse error: "ap"
14:52:12 <dolio> @. pl do ap (>>=) (flip (fmap . (+)))
14:52:13 <lambdabot> compose module failed: IRCRaised Parse error: "do"
14:52:33 <dolio> I'm lost, apparently. :)
14:52:42 <sjanssen> dolio: @. is the compose plugin -- sends the result of the second command to the first
14:52:56 <dolio> Oh, okay.
14:53:04 <sjanssen> @undo  \xs -> do { x <- xs ; y <- xs ; return (x + y) }
14:53:04 <lambdabot> \ xs -> xs >>= \ x -> xs >>= \ y -> return (x + y)
14:53:18 <dolio> @undo ap (>>=) (flip (fmap . (+)))
14:53:18 <lambdabot> ap (>>=) (flip (fmap . (+)))
14:53:31 <dolio> Ah, undo is removing do notation?
14:53:36 <sjanssen> @redo \ xs -> xs >>= \ x -> xs >>= \ y -> return (x + y)
14:53:36 <lambdabot> \ xs -> do { x <- xs; y <- xs; return (x + y)}
14:53:39 <sjanssen> dolio: yes
14:53:49 <dolio> Okay, I see.
14:54:23 <dolio> How do you reverse pl?
14:54:34 <dolio> Or is there such a thing?
14:54:34 <lispy> we don't have that yet
14:54:45 <lispy> would be nice to have @pointy though
14:54:48 <dolio> I see.
14:54:21 --- topic: '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]'
14:54:21 --- topic: set by lambdabot on [Thu Aug 31 22:39:56 2006]
14:54:48 <sjanssen>  @pointy would be tricky, you'd need type information to do it right
15:01:36 <lispy> you'd need at least the arity right?
15:02:20 <lispy> @pl flip flip flip flip flip flip flip flip
15:02:21 <lambdabot> flip flip flip
15:02:53 <Heffalump> @pl flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
15:02:54 <lambdabot> flip flip flip
15:03:00 <Heffalump> @pl flip flip flip flip
15:03:00 <lambdabot> flip flip flip
15:03:06 <Heffalump> @pl flip flip
15:03:06 <lambdabot> flip flip
15:03:11 <Heffalump> that's pretty cool
15:03:12 <dylan> @pl flip flip flip
15:03:13 <lambdabot> flip flip flip
15:03:18 <lispy> yeah, it's trippy
15:03:22 <dylan> @pl flip flip flip @flip
15:03:22 <lambdabot> flip flip flip @ flip
15:03:27 <dolio> ?type flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip
15:03:27 <dylan> err
15:03:28 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
15:03:32 <lispy> @pl flip flip flip (const . const)
15:03:33 <lambdabot> const
15:03:33 <dylan> @pl flip flip flip flip
15:03:34 <lambdabot> flip flip flip
15:03:59 <lispy> @pl flip flip flip (+)
15:03:59 <lambdabot> (flip +)
15:04:17 <profmakx> o.O
15:04:20 <sjanssen> @type flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip flip `asTypeOf` flip flip flip
15:04:22 <lambdabot> forall c c1 a a1 b. (a -> ((a1 -> b -> c) -> b -> a1 -> c) -> c1) -> a -> c1
15:05:06 <lispy> ?free flip
15:05:08 <lambdabot> f . k x = p (g x) . h => f . flip k y = flip p (h y) . g
15:06:50 <dolio> I must say, trying to understand how ap works on the lightweight reader monad tends to tie my brain in knots.
15:06:53 <lispy> ?pl flip flip (+)
15:06:53 <lambdabot> flip flip (+)
15:07:36 <lispy> > flip flip (-) 2 3
15:07:37 <lambdabot>  add an instance declaration for (Num (a -> (a1 -> a1 -> a1) -> c))
15:07:41 <Cale> ?pl (flip . flip) (+)
15:07:42 <lambdabot> (+)
15:08:08 <lispy> ?pl flip . flip
15:08:09 <lambdabot> id
15:08:25 <lispy> ?free id
15:08:26 <lambdabot> f . id = id . f
15:09:02 <dylan> @pl flip subtract
15:09:02 <lambdabot> (-)
15:09:10 <dolio> Perhaps I should learn J, since apparently that makes it all clear. :)
15:09:41 * lispy always advocates learning unusual programming languages
15:09:46 <Cale> dolio: In that monad, ap x y z = x z (y z)
15:10:00 <Cale> > ap (,) (+1) 5
15:10:01 <lambdabot>  (5,6)
15:10:21 <lispy> Cale: is that the same as (x z) (y z) ?
15:10:26 <Cale> yes
15:10:39 <lispy> hmm...
15:10:45 <lispy> i see
15:10:49 <Cale> > (,) 5 ((+1) 5)
15:10:50 <lambdabot>  (5,6)
15:10:58 <dolio> Yeah, I managed to puzzle out something of that sort.
15:11:12 <Cale> Thus, it's the same as the classical S combinator.
15:11:26 <Cale> (From the SK calculus)
15:11:50 <lispy> so then, x :: z -> y z -> a (of course abusing type notation a bit)
15:12:05 <Cale> hm?
15:12:17 <Cale> er, maybe? :)
15:12:41 <lispy> x :: a -> b -> c, where z :: a and  y z :: b  :)
15:12:57 <lispy> well, y :: a -> b
15:13:15 <Cale> ap :: (a -> b -> c) -> (a -> b) -> a -> c
15:13:30 <lispy> oh hm...i wrote a function very recently with a type sig. like that...i could probably use ap
15:15:29 <lispy> oh hmm..in my case i need to apply x to (x z) and then some new value, say, w
15:15:41 <lispy> er not x to x z but x to y z
15:17:09 <lispy> > ap (+) (+1) 4
15:17:11 <lambdabot>  9
15:17:23 <lispy> > ap (*) id 5
15:17:24 <lambdabot>  25
15:17:51 <lispy> ah, so now i see why @pl likes ap so much
15:18:26 <dolio> Yeah, it's good for duplicating arguments.
15:19:15 <lispy> > ap (const . id) id 4
15:19:16 <lambdabot>  4
15:19:33 <dolio> @pl \e -> f e (g e)
15:19:34 <lambdabot> ap f g
15:19:35 <lispy> ?pl ap (const . id) id
15:19:35 <lambdabot> id
15:19:44 <dolio> @pl \e -> f (g e) e
15:19:44 <lambdabot> f =<< g
15:20:17 <lispy> @pl \x y -> f (g x) y
15:20:17 <lambdabot> f . g
15:20:47 <lispy> @pl \x y -> (f (g x)) y
15:20:48 <lambdabot> f . g
15:20:58 <lispy> that just seems odd to me...
15:21:10 <lispy> oh, n/m
15:21:15 <ihope_> "No one has yet shown a method to well order the real numbers."
15:21:42 <ihope_> I guess defining Ord a with functions a -> Ord and Ord -> a is a bad idea, then.
15:22:04 <lispy> what does the 'well' in well ordered mean again?
15:23:18 <ihope_> It means that every set of whatevers has a lowest element.
15:23:46 <lispy> "Roughly speaking, a well-ordered set is ordered in such a way that its elements can be considered one at a time, in order, and any time you haven't examined all of the elements, there's always a unique next element to consider."
15:23:52 <lispy> (from wikipedia)
15:24:25 <ihope_> The "normal" order of real numbers doesn't work, because the set of all real numbers has no lowest element.
15:24:29 <lispy> so, intuitively the reason well-ordering fails for the reals would be this lack of knowing the unique next element
15:24:40 * lispy nods
15:25:11 <ihope_> It's all about well-ordering infinite streams, I guess, maybe.
15:26:33 <dolio> Yeah, there's really no next element in the real numbers.
15:26:40 <dolio> Between any two, there are infintely many.
15:26:49 <dolio> Infinitely, even.
15:27:05 <sjanssen> are rationals well ordered?
15:27:25 <lispy> "The well-ordering theorem, which is equivalent to the axiom of choice, states that every set can be well-ordered. " (also from wikipedia)
15:27:34 <dolio> I don't know. If that's part of the definition, I guess the answer is no.
15:27:35 <ihope_> sjanssen: yep.
15:27:57 <lispy> sjanssen: but your ordering relation might look funny
15:28:08 <ihope_> You can map the rationals onto a subset of the natural numbers.
15:28:19 <dolio> Oh, I suppose that's true.
15:28:29 <ihope_> And every subset of the natural numbers is well-ordered.
15:29:12 <lispy> ihope_: so it's interesting that the well-ordering theorem implies we should be able to find a well-ordering on the reals...but then i guess that's why it's equivalent to the axiom of choice :)
15:29:20 <dolio> In that case, the problem would be that the reals are uncountable, I guess.
15:48:19 <lispy> does anyone else here have the problem that you can think of so many cool projects that you get paralyzed with not knowing which one to work on?
15:48:41 <lispy> looking at my book shelf just makes it worse too
15:52:48 <SamB> lispy: I think shapr has that problem
15:52:52 <SamB> I think I do too
15:53:01 <SamB> only I forget about at least half of them
15:53:56 <dons> ?users
15:54:01 <lambdabot> Maximum users seen in #haskell: 221, currently: 205 (92.8%), active: 31 (15.1%)
15:54:07 <dons> ?uptime
15:54:07 <lambdabot> uptime: 19h 14m 4s, longest uptime: 1d 21h 35m 42s
15:54:32 <Igloo> What's the definition of active?
15:55:25 <SamB> Igloo: talked in the last n minutes?
16:00:39 <ihope_> What's n?
16:00:55 <ihope_> ?users
16:00:55 <lambdabot> Maximum users seen in #haskell: 221, currently: 204 (92.3%), active: 31 (15.2%)
16:01:39 <LiquidEngineer> Hello.
16:02:36 <LiquidEngineer> I'm having a problem with the DarwinPorts version of ghc
16:02:44 <lispy> LiquidEngineer: how so?
16:02:48 <LiquidEngineer> (6.4.2)
16:03:05 <LiquidEngineer> When I type in ghci at the console, I get a strange bug message
16:03:16 <LiquidEngineer> (It worked perfectly when I tried to use it before...this is new.)
16:03:24 <lispy> can you paste it?  G4, G5 or x86?
16:03:27 <johnnowak> LiquidEngineer: i'm compiling it as we speak.
16:03:29 <LiquidEngineer> G4.
16:03:54 <johnnowak> taking for fucking ever. spends 75% of its time sitting around.
16:04:01 <lispy> my ghci (6.4.2 on G4) works great, but emacs won't run :(
16:04:06 <LiquidEngineer> It took FOREVER to compile on my 867 MHz G4.  The message is as follows.
16:04:27 <LiquidEngineer> ( I ended up leting it compile overnight after watching it for 4 hours...I don't know how long it actually took.)
16:04:45 <lispy> LiquidEngineer: it takes 6+ hours on my G4 1.2 Ghz
16:04:59 <LiquidEngineer> internal error: scavenge_stack: weird activation record found on stack: 459
16:05:00 <LiquidEngineer>     Please report this as a compiler bug.
16:05:07 <LiquidEngineer> It probably took longer than that, then.
16:05:25 <LiquidEngineer> I wonder why.  It didn't take that long to compile postgres, and I'd think that was a more complex system....
16:05:27 <johnnowak> that's a funny error.
16:05:38 <LiquidEngineer> Yes.
16:05:44 <johnnowak> LiquidEngineer: ghc is written in haskell
16:06:07 <LiquidEngineer> johnowak: is that what causes the slow compile times?
16:06:27 <johnnowak> seems it. takes about 10x as long as plt scheme it seems.
16:06:33 <lispy> haskell requires a lot more work to be turned into something machine executable :)
16:06:37 <johnnowak> which i'd think is about on the same size
16:06:53 <LiquidEngineer> any idea what's causing the error?
16:06:58 <lispy> type checking isn't the cheapest thing and then there are tons of optimizations
16:07:07 <lispy> LiquidEngineer: no idea, that's an odd error
16:07:17 <alec> optimizing takes a while; the ghc trac page suggests how to speed up compiles
16:07:20 <LiquidEngineer> It says to file a bug report ....
16:07:25 <LiquidEngineer> I need this for class. :(
16:07:43 <LiquidEngineer> (And I'm not gonna sit through compiling it again.  Especially since I don't know how to get rid of the version I've got.
16:07:53 <lispy> LiquidEngineer: i think you can get a 6.4.1 binary off the ghc home page
16:07:56 <eivuokko> When you compile ghc, you also compile the libraries few times, for normal use and profiling, as well as compiling the compiler twice for bootstrap.
16:08:08 <LiquidEngineer> bootstrap?
16:08:23 <LiquidEngineer> Is there a huge difference between 6.4.1 and .2?
16:08:34 <lispy> no, just some bug fixs
16:08:38 <eivuokko> Lots of bugs were fixed.
16:09:22 <LiquidEngineer> Like, crucial bugs though?
16:09:42 <LiquidEngineer> Is it stable?
16:09:57 <lispy> probably nothing you'd run into using it for a class...but then i skipped from 6.4 to 6.4.2
16:10:11 <lane> LiquidEngineer: I've been using it for some time and haven't run in to any troubles.
16:10:32 <eivuokko> Isn't -threaded on for ghci in 6.4.2, and caused probs on some platforms?
16:10:42 <lispy> the unstable branch has odd numbering, like 6.3, 6.5, so on...so 6.4.1 was meant to be stable, but it had some bugs so they released 6.4.2 :)
16:11:38 <lispy> LiquidEngineer: here is another way to look at it. Working but with some minor bugs is better than activation record problems on start up :)
16:12:15 <lispy> LiquidEngineer: and if i recall correctly, you can uninstall the one you have with 'sudo port uninstall ghc'
16:13:10 * johnnowak will be cranky if his ghci ends up the same
16:13:14 <LiquidEngineer> Hmm.... cool.
16:13:31 <LiquidEngineer> what's supposed to happen if you just run GHC (the compiler) with no arguments?
16:13:35 <LiquidEngineer> I think *it* might be working.
16:13:46 <lispy> $ ghc
16:13:46 <lispy> ghc-6.4.2: no input files
16:13:46 <lispy> Usage: For basic information, try the `--help' option.
16:13:52 <LiquidEngineer> YES.
16:13:56 <LiquidEngineer> well, at least that much works. :D
16:14:19 <johnnowak> LiquidEngineer: what class is this?
16:15:16 <SamB> ooooh, I like this:
16:15:19 <SamB>     ,"i think i know what code does but code looks to simple to actually do it"
16:15:24 <LiquidEngineer> johnnowak: I love my Powerbook...it's not terribly slow for almost everything I do, except programming.  Using port to get anything is always a nightmare, and I harbor a strong dislike of Eclipse because it brings my system to a crawl.
16:15:34 <LiquidEngineer> johnnowak: Artificial Intelligence.
16:15:35 <SamB> Haskell is a bit like that sometimes, isn't it?
16:15:56 <johnnowak> LiquidEngineer: Same deal here. Eyeing a new iMac when they get the core 2 duos.
16:16:07 <LiquidEngineer> johnnowak: I heard they're going for Merom.
16:16:16 <LiquidEngineer> We'll find out on Tuesday, I think.
16:16:20 <SamB> I have a 450 MHz PII
16:16:26 <johnnowak> really? hm. would be nice.
16:16:38 <carp_> LiquidEngineer: did you have 6.4.1 before?
16:18:51 <SamB> hmm, why does GHC 6.4.1 only come with Cabal 1.0?
16:19:10 <LiquidEngineer> I had no haskell before at all.
16:19:10 <eivuokko> Because that's what was ready at 6.4 time
16:19:15 <LiquidEngineer> at least not on this computer.
16:19:26 <SamB> but... it won't build lambdabot!
16:20:04 <ndm> SamB: upgrading cabal is pretty easy
16:20:12 <LiquidEngineer> johnnowak: I'm going to wait till next summer before finally retiring my ancient laptop
16:20:54 <SamB> why isn't there instructions for that in lambdabot's README?
16:21:03 <eivuokko> Because you didn't send a patch.
16:21:09 <johnnowak> LiquidEngineer: why?
16:21:16 <SamB> oh
16:21:18 <SamB> well.
16:21:20 <SamB> hmm.
16:21:29 <SamB> you are probably right, I probably did do it before...
16:22:30 <SamB> but, if dons wants me to implement that filter...
16:22:33 <beschmi> ndm: do you think it would be hard to support searching by input instead of type, eg "aaa.bbbb" -> ','  -> ("aaa",",bbbb")
16:22:51 <LiquidEngineer> johnnowak: because I have one more year as an undergrad, and this computer will get me by till then.
16:22:54 <ndm> beschmi: yes :)
16:22:57 <beschmi> read somewhere that sqeak supports something like that
16:23:00 <LiquidEngineer> johnnowak: then I can justify getting myself a graduation present. :P
16:23:06 <johnnowak> LiquidEngineer: ah, i have two more and i can't quite make it :)
16:23:06 <SamB> beschmi: yeah it does
16:23:11 <ndm> essentially takes too much computation power
16:23:18 <LiquidEngineer> and also, I found this about my error.
16:23:21 <LiquidEngineer> http://www.haskell.org/pipermail/glasgow-haskell-bugs/2005-August/005529.html
16:23:24 <lambdabot> Title: internal error: scavenge_stack: weird activation record found on stack: 0, http://tinyurl.com/p76rq
16:23:35 <LiquidEngineer> he's got the same setup I do (dp on a 10.4 mac.)
16:23:37 <ndm> plus evaluation, which something like lambdabot is probably better for
16:23:52 <LiquidEngineer> you might want to look at it in case your install goes wiggy
16:24:07 <dons>  @pl provides something ike this
16:24:21 <dons> if you're careful
16:24:51 <LiquidEngineer> never mind...it looks like he hasn't gotten any responses yet
16:25:31 <beschmi> ndm: ic, a lambdabot plugin could probably use hoogle to find the functions with the right type
16:25:44 <musasabi> LiquidEngineer: what kind of program + architecture do you have?
16:25:56 <ndm> beschmi: indeed, run an @type, then an @hoogle, then a @eval
16:26:19 <ndm> beschmi: although in your example the answer is break (== x) xs
16:26:33 <ndm> which its unlikely to find - with higher order functions thereaer too many options
16:26:49 <beschmi> yeah, higher order functions make it really hard
16:27:18 <musasabi> I think known things to produce that are 1) corrupting the memory behing your back (FFI/unsafe array ops/...), 2) real problem with GHC - typically non-386 profiling/debug, 3) something I am forgetting.
16:28:41 <LiquidEngineer> musasabi: Hmm?
16:29:11 <LiquidEngineer> I haven't even run any code with it yet
16:29:21 <LiquidEngineer> I just installed it, and ran it once to make sure it compiled
16:29:25 <LiquidEngineer> then I quit the terminal
16:29:32 <LiquidEngineer> I didn't quit GHCi proper
16:29:38 <LiquidEngineer> I wonder if I corrupted something.
16:29:39 <musasabi> ah. thought you had run across it.
16:29:57 <falconair> i've been trying to understand set theory/relations through the book "Haskell road to logic" .. unfortunately it doesn't mention anything about n-ary relations, functional dependencies, etc. (the stuff used by relational databases), is there any material available which teaches n-ary relations, functional dependencies, 'extracting' a set of relations from a single relation, etc. through haskell examples?
16:29:58 <LiquidEngineer> It bugs out when i try to call ghci up
16:30:27 <LiquidEngineer> It gets so far as
16:30:29 <LiquidEngineer> Loading package base-1.0 ... linking ... done.
16:30:29 <LiquidEngineer> ghc-6.4.2: internal error: scavenge_stack: weird activation record found on stack: 459
16:31:09 <explicitjelly> falconair, there are books which help you understand mathematical topics with haskell?
16:31:52 <lispy> LiquidEngineer: but ghc proper works? just ghci that is broken?
16:32:06 <LiquidEngineer> lispy
16:32:08 <LiquidEngineer> err.
16:32:12 <LiquidEngineer> lispy: looks that way
16:32:20 <LiquidEngineer> I haven't tried to actually compile anything yet.
16:32:20 <falconair> explicitjelly: try this one: http://www.amazon.com/Haskell-Road-Logic-Maths-Programming/dp/0954300696/sr=8-1/qid=1157326296/ref=pd_bbs_1/002-0321247-3806429?ie=UTF8&s=books
16:32:56 <explicitjelly> falconair, wow, thanks a lot.
16:33:01 <lispy> LiquidEngineer: try, ghc -e "putStrLn \"hello, world!\""
16:33:05 <falconair> no prob.
16:33:21 <LiquidEngineer> what's the e flag?
16:33:27 <lispy> LiquidEngineer: evaluate
16:33:44 <lispy> LiquidEngineer: it should print hello world :)
16:33:54 <LiquidEngineer> ghc -e "putStrLn \"hello, world!\""
16:33:54 <LiquidEngineer> -bash: !\"": event not found
16:34:02 <LiquidEngineer> I think I'm doing something wrong.
16:34:12 <mauke> omit the !
16:34:27 <mauke> or use single quotes, that should help
16:34:41 <lispy> yeah, that's just a shell interaction issue not a ghc problem
16:34:47 <lispy> bad example on my part :)
16:35:33 <LiquidEngineer> Oh crud
16:35:43 <LiquidEngineer> I got another wierd activation thingie.
16:35:54 <LiquidEngineer> different number this time
16:35:56 * johnnowak kills the build and downloads the 6.4.1 binary
16:36:23 <LiquidEngineer> What's the progress on the Mac 6.4.2 binary?
16:37:14 <falconair> explicitjelly, i just found these on google: http://www-ala.doc.ic.ac.uk/~yg/Discrete/course.html , check out the first pdf link, 48 pages of haskell+discrete math goodness :)
16:37:18 <lambdabot> Title: Discrete Mathematics, http://tinyurl.com/zposs
16:37:57 <johnnowak> cp: share/*.ps: No such file or directory
16:37:57 <johnnowak> make: *** [install-docs] Error 1
16:38:01 <johnnowak> whee
16:38:06 <explicitjelly> falconair, exactly what I need!
16:38:24 <lispy> johnnowak: why?
16:38:33 <falconair> lambdabot already know about it...how can i ask it if it knows more about descretemath+haskell?
16:38:36 <lispy> johnnowak: ghc 6.4.2 works fine on my machine, you might as well try it
16:39:23 <johnnowak> eh, this 6.4.1 package won't install.
16:39:30 <johnnowak> lispy: i'll ... yeah.
16:39:38 <LiquidEngineer> wha?
16:39:44 <LiquidEngineer> I just blew out the dp version
16:39:52 <LiquidEngineer> I wish hugs was a compiler
16:39:55 <LiquidEngineer> I know it works on my system. :P
16:41:14 <dylan> I wonder how writing about the differences between mesopotamian and egyption culture is supposed to prepare for a career in mathematics / CS....
16:41:16 * johnnowak gets to manually prune /usr/local
16:42:05 <LiquidEngineer> I know I'm gonna sound like a n00b, but why bother building from source with darwin ports if there's a binary available?
16:42:14 <LiquidEngineer> (assuming the binary and source versions match)
16:42:38 <johnnowak> well, in this case, the versions didn't match
16:43:27 <LiquidEngineer> Yes.
16:43:31 <LiquidEngineer> But if they did?
16:44:02 <lispy> i dunno, but since the osx binary is never as recent as darwinports it hasn't really come up for me :)
16:45:08 <johnnowak> why is the OS X version lagging?
16:47:48 <falconair> explicitjelly: last link, I just found this as well: http://www.amazon.com/Discrete-Mathematics-Using-a-Computer/dp/1846282411/sr=8-1/qid=1157327111/ref=pd_bbs_1/002-0321247-3806429?ie=UTF8&s=books
16:48:58 <explicitjelly> falconair, also nice. do you think this covers more topics than the other book?
16:49:00 <lispy> johnnowak: no  idea
16:49:08 <lispy> johnnowak: less popular?
16:50:15 <falconair> explicitjelly: from the table of contents it looks like it includes more logic, but i'm not sure...i'm ordering it anyway
16:50:21 <LiquidEngineer> wha?
16:50:29 <LiquidEngineer> one of the screws is coming out of my powerbook
16:50:38 <explicitjelly> falconair, well, I will write it down and order it as well.
16:51:11 <explicitjelly> falconair, the good thing about books, especially about those kind of books, you can always use them to look things up. forever.
16:51:46 <lispy> LiquidEngineer: i've see that happen several times on powerbooks :(
16:52:11 <falconair> explicitjelly: exactly, i print out a bunch of papers, but within a week they get lost under a pile of more papers, books make a much easier reference (not to mention that they are much more self contained)
16:53:43 <explicitjelly> falconair, yes, exactly
17:02:46 <LiquidEngineer> lispy: I've had it 4 years or more.
17:02:52 <LiquidEngineer> Guess it is time for the falling apart. :P
17:03:03 <LiquidEngineer> Screwed it back in with my finger nail.
17:03:05 <LiquidEngineer> no big deal
17:06:26 <dmwit> Okay, so, if I have
17:06:32 <dmwit> expensiveFunction :: a -> (b, b)
17:06:37 <dmwit> constantValue :: a
17:06:43 <dmwit> Then I say
17:06:57 <dmwit> left = fst (expensiveFunction constantValue)
17:07:05 <dmwit> right = snd (expensiveFunction constantValue)
17:07:19 <dmwit> Is it smart enough to evaluate expensiveFunction only once?
17:07:27 <Pseudonym> That depends.
17:07:42 <dons> better to explicitly float it out to a 'where'
17:07:42 <Pseudonym> If the value is large, then that could be a memory leak./
17:07:53 <Pseudonym> It's almost always a smart idea, though.
17:07:57 <dons> if you want to guarantee the sharing
17:08:19 <dmwit> So, instead, something like:
17:08:36 <dmwit> returnValue = expensiveFunction constantValue
17:08:40 <dmwit> left = fst returnValue
17:08:44 <dmwit> right = snd returnValue
17:08:55 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) combinations xs ++ combinations xs } in length (combinations 10)
17:08:56 <lambdabot>    The function `map' is applied to three arguments,
17:08:56 <lambdabot>   but its type `(a -...
17:08:57 <irgs> why not (left,right) = expensiveFunct constVal ?
17:09:09 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations 10)
17:09:10 <lambdabot>  add an instance declaration for (Num [a])
17:09:22 <dmwit> irgs: is that allowed?
17:09:24 <Pseudonym> Errr...
17:09:38 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..10])
17:09:39 <lambdabot>  1024
17:09:45 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..16])
17:09:47 <lambdabot>  65536
17:09:52 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..32])
17:09:53 <dmwit> > let (a, b) = (10, 20) in a:b:[]
17:09:55 <lambdabot>  [10,20]
17:09:57 <lambdabot> Terminated
17:10:00 <dmwit> Nice.
17:10:24 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = let xs = combinations xs in map (x:) cs ++ cs } in length (combinations [1..16])
17:10:25 <lambdabot>  Not in scope: `cs'
17:10:34 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = let cs = combinations xs in map (x:) cs ++ cs } in length (combinations [1..16])
17:10:35 <lambdabot>  65536
17:10:38 <irgs> dmwit: yes it is ;)
17:10:54 <Pseudonym> See how much longer the sceond version took?
17:11:00 <Pseudonym> second
17:11:08 <Pseudonym> In that case, sharing is a BAD idea.
17:11:17 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..20])
17:11:20 <lambdabot>  1048576
17:11:30 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = let cs = combinations xs in map (x:) cs ++ cs } in length (combinations [1..20])
17:11:30 <dmwit> Hmmm...
17:11:32 <lambdabot>  1048576
17:11:37 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = let cs = combinations xs in map (x:) cs ++ cs } in length (combinations [1..24])
17:11:41 <lambdabot> Terminated
17:11:45 <Pseudonym> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..24])
17:11:49 <lambdabot> Terminated
17:11:52 <Pseudonym> Hmm.
17:12:04 <Pseudonym> Anyway.
17:12:30 <SamB> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..20]
17:12:31 <lambdabot>  Parse error
17:12:33 <SamB> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..20])
17:12:36 <lambdabot>  1048576
17:12:41 <SamB> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..22])
17:12:45 <lambdabot> Terminated
17:12:50 <SamB> > let { combinations [] = [[]]; combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs } in length (combinations [1..21])
17:12:53 <lambdabot> Terminated
17:13:03 <Pseudonym> Unfortunately, it's a time thing.
17:13:19 <Pseudonym> There's a point where one version will complete (eventually) and the other will blow the heap.
17:27:38 <lispy> Pseudonym: i had a question about the free theorems
17:28:11 <lispy> Pseudonym: is it possible (without using _|_) to violate the theorem when you're implementing a function with a given type?
17:28:54 <lispy> Pseudonym: i was basically wondering if 'free' could be used to generate test cases
17:29:11 <Cale> @pl ap const const
17:29:11 <lambdabot> id
17:29:30 <lispy> > ap const const map
17:29:31 <lambdabot>  Add a type signature
17:29:54 <lispy> > ap const const (map :: (a -> b) -> [a] -> [b])
17:29:55 <lambdabot>  Add a type signature
17:29:55 <Cale> > ap const const map (+1) [1..10]
17:29:56 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:31:20 <lispy> > id map
17:31:21 <lambdabot>  Add a type signature
17:33:38 <tonySoprano> 1+1
17:33:45 <tonySoprano> > 1+1
17:33:46 <lambdabot>  2
17:33:51 <tonySoprano> interesting
17:35:43 <ski> @type let f <@< g = (>>= f) . g in (<@<)
17:35:44 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (a1 -> m a) -> a1 -> m b
17:35:50 <ski> @type (.)
17:35:51 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
17:36:10 <ski> explicitjelly : compare with your '(bind f) . g'
17:36:30 <lisppaste2> syntaxfree pasted "type class question" at http://paste.lisp.org/display/25293
17:36:37 <explicitjelly> ski, hm?
17:37:54 <lispy> ?free fmap
17:37:56 <lambdabot> Expected variable or '.'
17:38:01 <ski> <explicitjelly> Test> :t (bind f) . g
17:38:01 <lispy> ?free map
17:38:02 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
17:38:39 <explicitjelly> @type bind f g s = let (x', s') = g s in f x' s'
17:38:40 <lambdabot> parse error on input `='
17:39:00 <ski> @type let bind f g s = let (x', s') = g s in f x' s'
17:39:01 <lambdabot> not an expression: `let bind f g s = let (x', s') = g s in f x' s''
17:39:18 <ski> @type let bind f g s = let (x', s') = g s in f x' s' in bind
17:39:19 <lambdabot> forall a b t t1. (a -> b -> t) -> (t1 -> (a, b)) -> t1 -> t
17:39:23 <SamB> hmm, so I can only build lambdabot with Cabal or load in GHCi?
17:39:37 <explicitjelly> ski, wait. i have to write it in a file because i don't have it anymore. but i have written it down since i was doing it on paper.
17:39:39 <syntaxfree> did my paste get through?
17:39:43 <lispy> SamB: what?
17:40:17 <SamB> lispy: well... the README doesn't tell me how to build without cabal, or install a new enough version of cabal to build it...
17:40:30 <explicitjelly> Test> :t bind
17:40:30 <explicitjelly> bind :: (a -> b -> c) -> (d -> (a,b)) -> d -> c
17:40:44 <ski> @type let bind f g s = (let (x, s') = g s; (y, s'') = f x s' in (y, s'')) in bind
17:40:46 <lambdabot> forall a b a1 b1 t. (a -> b -> (a1, b1)) -> (t -> (a, b)) -> t -> (a1, b1)
17:40:50 <explicitjelly> ski, do you also want to have the type of (bind f) . g?
17:40:51 <lispy> SamB: let's get your cabal upgraded then...that part is easy
17:41:06 <SamB> should be in the lambdabot README, if it is needed!
17:41:11 <ski> hm
17:41:24 <explicitjelly> ski, by the way, what are you doing=
17:41:27 <explicitjelly> ski, ?
17:41:27 <lispy> SamB: send a patch :)
17:41:30 <SamB> (and it is, if the GHC requirement is >=6.4, which is what the README says)
17:41:46 <SamB> lispy: how about you tell me how and I send the patch after?
17:41:51 <ski> explicitjelly : just pondering your issue from before
17:41:56 <lispy> SamB: sure
17:42:07 <explicitjelly> ski, ah. (you know that it's already solved?)
17:42:22 <lispy> SamB: grab the source from here: http://www.haskell.org/cabal/code.html
17:42:24 <lambdabot> Title: Getting the Code
17:42:38 <ski> explicitjelly : i was just thinking i possibly had something to add
17:42:58 <lispy> SamB: then in the cabal source run: runghc -cpp Setup.lhs configure && runghc -cpp Setup.lhs build && runghc -cpp Setup.lhs install
17:43:07 <explicitjelly> ski, i'm still open for that topic
17:43:32 <SamB> hmm, I wonder what the Cabal requirement is?
17:43:58 <lispy> i think the cabal file format just keep evolving is all
17:44:47 <ski> explicitjelly : (i skimmed through the conv., but) i was thinking doing '(bind f) . g' is not a bad idea
17:45:14 <ski> explicitjelly : only think being that that 'bind' takes arguments in opposite order, compared to '(>>=)'
17:45:21 <ski> s/think/thing/
17:45:22 <explicitjelly> ski, yes. it seems that it's pretty good for some things.
17:45:58 <explicitjelly> ski, yup
17:46:01 <ski> so your 'bind' would have type something like
17:46:48 <ski> (a -> s -> (b,s)) -> (s -> (a,s)) -> s -> (b,s)
17:47:35 <ski> (only you got a slighty more general type)
17:47:59 <dolio> ?type (=<<)
17:48:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
17:48:04 <ski> yes
17:48:51 <explicitjelly> ski, cool. that's exactly what i have written down about the type that my bind function should have :)
17:49:30 <ski> :)
17:49:43 <explicitjelly> ski, only that ir reads bind :: (a -> Mystate -> (b,Mystate)) -> (Mystate -> (a,Mystate)) -> (b,Mystate) because I was thinking of a concrete application
17:50:09 <ski> i think your 'bind', (i.e. '(>>=)' with flipped two first args) is often called 'extend' in the literature
17:50:20 <ski> yes
17:50:32 <explicitjelly> ski, and Mystate is a misleading name, it doesn't really behave like that
17:50:46 <explicitjelly> extend? good to know.
17:51:18 <ski> (though i think you're missing an 'Mystate -> ' there, just before the return type)
17:51:23 <explicitjelly> ski, is your name a reference to SKI combinators?
17:51:29 <ski> indeed
17:52:19 <explicitjelly> hmm... yes... seems like that's missing
17:52:42 <ski> sometimes 'f `extend` m' is written like 'f * m' and sometimes like 'f^* m' ('f^*' being 'f' "raised to star", in notation)
17:53:24 <ski> (so if 'f :: a -> s -> (b,s)' then 'f^* :: (s -> (a,s)) -> s -> (b,s)')
17:54:15 <explicitjelly> ah! it's like this in monadic theory, or is that a haskell specific notation?
17:54:59 <ski> (the book "Haskell: The Craft of Functional Programming" defines an operator for your '(bind f) . g', ("monadic composition") only"going in the opposite direction
17:55:22 <ski>  (>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
17:55:23 <ski> )
17:55:47 <ski> explicitjelly : in "monadic theory"
17:55:49 <Pseudonym> ?free (a -> M b) -> (b -> M c) -> (a -> M c)
17:55:49 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
17:56:01 <Pseudonym> ?free op :: (a -> M b) -> (b -> M c) -> (a -> M c)
17:56:02 <lambdabot> $map_M g . k = p . f => $map_M h . q = f1 . g => $map_M h . op k q = op p f1 . f
17:58:05 <explicitjelly> ski, so "monadic theory" doesn't actually exist? :) ok, cathegory theory then
17:58:25 <ski> i don't think i've heard that specific term, no
17:59:38 <ski> but some of the papers about monads, (e.g. with examples in haskell) use that above for "mathy" notation
17:59:59 <ski> (s/cathegory/category/ :)
18:00:22 <explicitjelly> ski, sorry, english's not my native language :) but, yes, category looks much better.
18:00:49 <explicitjelly> ski, thanks for your help! it's really good to know
18:01:13 <ski> np
18:01:13 <ski> yw
18:03:55 <explicitjelly> @type get
18:03:56 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
18:04:17 <explicitjelly> @undo let getAny = do g <- get in getAny
18:04:17 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
18:05:05 <explicitjelly> @undo let getAny = do { g <- get } in getAny
18:05:06 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 28}) "Parse error"
18:05:17 <ski> a 'do'-expression must end with a command, not a binding
18:05:38 <explicitjelly> @undo let getAny = do { g <- get; return x } in getAny
18:05:38 <lambdabot> let { getAny = get >>= \ g -> return x} in getAny
18:05:39 <jrmole> do notation is unnecessary for a single command anyway
18:05:44 <ski> @undo let getAny = do { g <- get; return () } in getAny
18:05:45 <lambdabot> let { getAny = get >>= \ g -> return ()} in getAny
18:06:09 <ski> @undo let getAny = do { get } in getAny
18:06:09 <lambdabot> let { getAny = get} in getAny
18:06:23 <jrmole> @undo let getAny = get in getAny
18:06:24 <lambdabot> let { getAny = get} in getAny
18:06:27 <jrmole> ;)
18:07:27 <ski> (and a 'do'-expression will monadically return the same thing as the last item (which is a command) inside it)
18:07:52 <jrmole> yeah, do { ...; x <- foo; return x } == do { ...; foo }
18:08:18 <explicitjelly> ok
18:08:19 <ski> (that's one of the monadic laws, actually :)
18:08:34 <ski> foo >>= return  =  foo
18:08:41 <jrmole> hey, cool
18:08:52 <jrmole> are the monad laws spelled out in do notation anywhere?
18:09:02 <jrmole> easy enough to translate but it might be nice for teaching monads
18:09:21 <ski> or ..  bar >@> return  =  bar
18:09:29 <jrmole> @type (>@>)
18:09:30 <lambdabot> Not in scope: `>@>'
18:10:05 <ski> jrmole : see 15 minutes back in log
18:10:26 <jrmole> ah, guess i'm late to the party
18:10:32 <ski> bar >@> return  =  bar
18:10:42 <ski> return >@> bar  =  bar
18:11:16 <ski> (bar0 >@> bar1) >@> bar2  =  bar0 >@> (bar1 >@> bar2)
18:11:28 <moha> sa
18:11:45 <moha> salam
18:12:05 <dolio> ?pl return =<< bar
18:12:05 <lambdabot> bar
18:12:13 <dolio> ?pl bar >>= return
18:12:13 <lambdabot> bar
18:12:35 <ski> @pl return x >>= bar
18:12:35 <lambdabot> bar x
18:13:01 <jrmole> hmm, those aren't enforced in the language, right?
18:13:11 <ski> right
18:13:14 <fariss> ba
18:13:29 <ski> hello fariss
18:13:36 <explicitjelly> @localtime explicitjelly
18:13:39 <lambdabot> Local time for explicitjelly is Mon Sep  4 03:13:14 2006
18:13:51 <explicitjelly> ... which really means i have to sleep now. good night
18:13:56 <fariss> hello  ski
18:14:07 <fariss> ca va
18:14:07 <ski> explicitjelly : night
18:14:08 <jrmole> good night explicitjelly
18:15:09 * ski wonders what 'ca va' means
18:15:15 <fariss> ???? ????
18:17:17 * ski should probably head in direction of bed, too, though
18:18:25 <Cale> @babel fr en Comment a va?
18:18:29 <lambdabot>  How does a go?
18:18:32 <Cale> heh
18:18:38 <Cale> not quite :)
18:18:47 <lispy> ?a ?
18:18:48 <lambdabot> Maybe you meant: all-dicts arr ask . v
18:19:06 <lispy> er didn't mean to trigger lambdabot
18:19:11 <Cale> c-cedilla
18:22:47 * SamB sends dons some patches
18:32:59 * edwardk waves ello.
18:39:24 <dons> does anyone use Data.ByteString in their projects, and would like to be included in the list of ByteString users?
18:40:17 <edwardk> I'm using it now, but i'll pass coz I probably won't release the project for quite a while.
18:41:23 <dcoutts__> dons: musasabi is working on gcrypt bindings so you can have aes128 and similar on lazy bytestring
18:41:45 <dcoutts__> I'm sure musasabi will tell us more as it progresses
18:42:00 <dons> musasabi: do we have a url?
18:42:09 <musasabi> I will probably release things next week.
18:42:11 <dons> (or any other projects of yours that use bytestrings?)
18:42:21 <dons> oh, doesn't hIDE use fps?
18:43:21 <musasabi> Since it is crypto code I like to audit it before releasing.
19:03:49 <SamB> dons: you should apply my patches!
19:04:20 <lispy> SamB: what do the do?
19:04:44 <SamB> lispy: one of them fixes the logo at the top of README, the other adds the instructions for updating Cabal...
19:04:49 <dons> SamB, busy with paper deadline in hour or so
19:04:52 <dons> later today
19:04:57 <SamB> oh
19:05:16 <dons> kfish, do you have a url for your mpeg decoder in haskell?
19:16:04 <thetallguy> dons: regarding ByteString usage
19:17:06 <thetallguy> Jeremy Shaw of Linspire wrote a parser for Debian control files using Parsec
19:17:34 <thetallguy> Only thing wrong was that it was too slow.
19:18:42 <thetallguy> He converted it to ByteString and reduced memory and runtime by a significant amount.  I think one figure was down by a factor of 10, but I don't remember which.
19:18:51 <dons> yep, i know about that one. thanks :)
19:20:29 <thetallguy> D'oh!
19:36:53 <edwardk> is there any haskell based crypto stuff other than cryptol?
19:37:25 <dons> ?where crytpo
19:37:26 <lambdabot> I know nothing about crytpo.
19:37:31 <dons> ?where crypto
19:37:32 <lambdabot> I know nothing about crypto.
19:37:35 <edwardk> hrm
19:37:37 <dons> ?google haskell crypto
19:37:40 <lambdabot> http://www.haskell.org/pipermail/libraries/2006-February/004893.html
19:37:40 <lambdabot> Title: Haskell Crypto Cabal
19:37:54 <dons> I think http://www.haskell.org/crypto
19:37:56 <lambdabot> Title: The Haskell Cryptographic Library
19:37:59 <dons> ah
19:38:08 <dons> ?where+ crypto http://www.haskell.org/crypto
19:38:09 <lambdabot> Done.
19:38:34 <edwardk> ah k
19:38:54 <edwardk> i should port some of my old JCE/JCA algorithms to that
19:40:33 <edwardk> ah it has a fairly neat ASN.1 library i like
19:40:48 <edwardk> tons cleaner than my java version
19:42:50 * edwardk wanders off to slap together a SHA2-256/384/512 implementation for them if nothing else
19:43:31 <sieni> make it simple, make it fast :-)
19:43:47 <edwardk> i'll take a look at their existing SHA-1
19:43:52 <edwardk> and mimic the structure
19:46:01 <edwardk> heh, i basically was excavating a harddrive the other day after someone on here was talking about lsystems and found my crypto stuff and felt nostalgic
19:47:06 <edwardk> wow, they don't do any strictness annotations?
19:47:23 <musasabi> edwardk: I have some Haskell based libgcrypt wrappers + OpenPGP code.
19:47:44 <edwardk> musasabi: well, i was kinda wanting to do the stuff in haskell, not wrap =)
19:49:19 <musasabi> edwardk: parts of the Haskell crypto library are GPL so linking against it can be problematic. (of course if you want to implement fast BSD3 licensed RSA in Haskell...)
19:49:29 <edwardk> hrmm
19:49:36 <edwardk> that might not suck
19:50:07 <edwardk> i have java code for p1363 hyperelliptic curve cryptosystems around here somewhere too
19:50:50 <edwardk> I wrote and maintained one until java 1.4 was released and Sun slit my throat basically by not giving me a key
19:51:19 <edwardk> er maintained a JCE/JCA implementation
19:51:33 <musasabi> edwardk: the other problem is keeping keys in secure memory and thus no Integers at least.
19:51:52 <edwardk> fed the bits of it that I could to GNU Crypto, and forgot about it basically.
19:51:59 <edwardk> yeah ouch.
19:52:26 <edwardk> and as i recall its awkard using GMP from something bound to haskell isn't it?
19:53:06 <musasabi> one could build custom bigints on ByteStrings and write operations for them etc, but that sounded too painful for my tastes.
19:53:14 <edwardk> dons and I and someone else were trying to figure out how to hook into exponentiation mod a print from ghc on Integers
19:53:37 <edwardk> yeah and i'm not entirely sure how thats any more secure than the integer approach
19:53:48 <edwardk> er mod a prime
19:54:12 <musasabi> edwardk: ByteString = ForeignPtr (which can point to something allocated in a secure location etc)
19:54:25 <edwardk> got it
19:54:46 <edwardk> sounds like a pain in the ass ;)
19:55:19 <edwardk> anyways, i think i will pass on dumping into the gpl encumbered haskell crypto project.
19:55:50 <edwardk> which i note does all of its digest and other crypto code seemingly in normal haskell variables.
19:56:22 <edwardk> and i winced when i saw that it wasn't even using strictness annotations in the core sha loop
19:56:45 <beschmi> perhaps you can get around some of the problems by using blinding for the rsa calculations
19:56:55 <musasabi> well the GPL parts could be replaced.
19:57:10 <musasabi> But it is a lot of work.
19:57:22 <edwardk> *nods*
19:57:40 <edwardk> and blinding might work there, but may have some problems if i ever did some of the p1363 stuff
19:58:02 <edwardk> there isn't a clear multiplicative property always involved
20:00:23 <SamB> @karma java
20:00:24 <lambdabot> java has a karma of -1
20:00:37 <dolio> Seems high.
20:00:43 <SamB> don't try to lower it!
20:00:51 <SamB> you'll lose karma yourself.
20:01:00 <dolio> :)
20:01:00 <SamB> I think it may be a bug
20:01:24 <dfranke> @karma COBOL
20:01:24 <lambdabot> COBOL has a karma of 0
20:01:28 <dolio> Does it stop you from adding karma to yourself?
20:01:35 <edwardk> yeah
20:01:36 <dfranke> now that's just wrong.  Java's not THAT bad.
20:01:38 <SamB> @karma+ SamB
20:01:38 <lambdabot> You can't change your own karma, silly.
20:02:12 <edwardk> @karma SamB
20:02:12 <lambdabot> SamB has a karma of 11
20:02:43 <SamB> you *can* lower COBOL's karma if you like ;-)
20:02:59 <edwardk> @karma- COBOL -- i want those years of my life back
20:02:59 <lambdabot> COBOL's karma lowered to -1.
20:03:07 <edwardk> @karma- COBOL -- i want those years of my life back
20:03:07 <lambdabot> COBOL's karma lowered to -2.
20:03:11 <edwardk> there =)
20:03:15 <edwardk> @karma FORTRAN
20:03:15 <lambdabot> FORTRAN has a karma of 0
20:03:23 <dolio> @karma haskell
20:03:24 <lambdabot> haskell has a karma of 4
20:03:24 <edwardk> @karma- FORTRAN -- from you too
20:03:24 <lambdabot> FORTRAN's karma lowered to -1.
20:03:40 <dfranke> @karma- COBOL -- SUBTRACT 1 FROM COBOLKARMA GIVING COBOLKARMA
20:03:40 <lambdabot> COBOL's karma lowered to -3.
20:03:58 <edwardk> hahahaha
20:04:29 <edwardk> wonder how far one could get in a cobol style DSL in haskell.
20:05:42 <SamB> hmm... how to detect #perl6-style nick++/nick-- stuff...
20:05:56 <edwardk> so, basically the only thing in haskell crypto that is GPL'd is the RSA implementation?
20:05:57 <edwardk> hrm
20:06:01 <edwardk> that could be fixed
20:06:07 <Adamant> @karma Python
20:06:07 <lambdabot> Python has a karma of 0
20:06:16 <Adamant> @karma Scheme
20:06:16 <lambdabot> Scheme has a karma of 0
20:06:16 <Pseudonym> ?hoogle (a -> a) -> IORef a -> IO ()
20:06:17 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
20:06:18 * edwardk continues his quest to stamp out needless GPLness
20:06:21 <Pseudonym> Perfect.
20:06:32 <Pseudonym> modifyIORef Scheme (+1)
20:06:48 <Pseudonym> That's the Haskell equivalent, surely.
20:07:00 <SamB> does lambdabot have decent regexes on hand?
20:07:37 <edwardk> hrmm, lambdabot needs a z-machine.
20:08:00 * edwardk continues dusting off random old code and seeing what would make good haskell ;)
20:08:21 <SamB> hah!
20:08:23 <SamB> I have one!
20:08:27 <edwardk> oh?
20:08:27 <SamB> you can have it if you like!
20:08:32 <edwardk> nice
20:08:55 <SamB> it will need some refitting, I'm sure ;-)
20:08:57 <edwardk> how bad do you think it would be to transform into a hsplugin and what versions of z? only really need 3, but 4,5 are good
20:09:10 <SamB> oh, rats, I think mine does only 5
20:09:14 <dfranke> I want this one.  http://en.wikipedia.org/wiki/Z_machine
20:09:16 <Pseudonym> ?type \x f -> (return x) >>= f
20:09:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> (a -> m b) -> m b
20:09:22 <SamB> but, well, you can feel free to do what you like with it ;-)
20:09:32 <edwardk> checking my code to see what the bytecode differences are
20:09:34 <SamB> @where Z-machine
20:09:34 <lambdabot> I know nothing about z-machine.
20:09:37 <SamB> @where Zmachine
20:09:37 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
20:09:44 <SamB> okay, there it should be!
20:09:46 <edwardk> hahaha
20:10:07 <SamB> what? using lambdabot to find URLs on my own machine?
20:11:17 <edwardk> its all part of dons' plan to control the world and build lambdanet, sit back and relax and don't worry about it... lambabot will take care of you ;)
20:11:21 <SamB> anyway, probably wouldn't take too much work to get it to work on v3... now getting it to work on BOTH might be trickier...
20:11:35 <edwardk> *nods*
20:11:44 <edwardk> i cant seem to connect to it
20:11:48 <SamB> oh rats
20:12:06 <edwardk> and its not that bad to get a zmachine to run just about all versions
20:12:17 <SamB> patches welcome!
20:12:27 <edwardk> i have just about every z-based game around here somewhere as well
20:12:33 <SamB> though if you send me any it would be nice if you would either tell me or leave a message with lambdabot
20:12:34 <kfish> dons: i haven't written an mpeg decoder, stepcut was working on a libmad wrapper or so
20:12:37 <edwardk> could make for some interesting lambdabot time.
20:12:46 * edwardk nods,
20:12:52 <SamB> let me check on my server...
20:13:14 <edwardk> checking to see if i have a z5 zork of some sort
20:13:22 <dons> kfish: right ok. cheers
20:13:26 <kfish> dons: i've been working on an ogg implementation (the encapsulation format, not vorbis), currently at (darcs) http://snapper.kfish.org/~conrad/software/hogg
20:13:28 <lambdabot> Title: Index of /~conrad/software/hogg, http://tinyurl.com/rja7s
20:13:39 <SamB> oh great
20:13:44 <dons> does it use Data.ByteString?
20:13:48 <kfish> dons: of course!
20:13:53 <dons> of course! :)
20:14:00 <kfish> Data.ByteString rulez0rs!
20:14:10 <edwardk> ah good zork1 solid gold is z5
20:14:11 <dons> you mind if I add it to our list of users of Data.ByteString?
20:14:11 <edwardk> =)
20:14:27 <edwardk> though zorks 2 and 3 are z3s
20:14:38 <kfish> dons: sure, go for it :)
20:14:44 <edwardk> so to really get it general enough i should patch
20:14:48 <SamB> my Twisted seems to have bitrotted or something...
20:14:59 <kfish> dons: is it to put in a paper? if so i'll make a nicer url for it
20:15:16 <dons> to go here: http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
20:15:17 <lambdabot> Title: Rewriting Haskell Strings, http://tinyurl.com/eobse
20:15:23 <edwardk> samb: did you ever play jigsaw?
20:15:32 <SamB> edwardk: some
20:15:47 <SamB> I did cheat some though
20:15:49 <edwardk> kinda figured. most people who slapped together a z-machine lookedfor new games ;)
20:15:50 <edwardk> heh
20:15:59 <edwardk> yeah its HARD to get the good ending without cheating =)
20:16:12 <SamB> I mean, I used a decompiler on it ;-)
20:16:16 <edwardk> heh
20:16:19 <SamB> which was incidentally written in Haskell...
20:16:27 <SamB> though not by me
20:16:44 <SamB> though probably I did use it with some of my own tweaks in place...
20:16:56 <edwardk> is there a good haskell library for reading zip files?
20:17:30 <Heffalump> dons: are the ps and pdf links deliberately broken?
20:17:35 <dons> yes :)
20:17:40 <dons> gimme 60 minutes...
20:17:59 <Heffalump> I should be asleep, I just woke up randomly :-)
20:18:01 <edwardk> the nice thing is i actually bought every infocom game ever released, so i guess i'm in fair use territory ;)
20:19:01 <SamB> hmm...
20:19:23 <SamB> I apparantly need the Python "profile" module...
20:19:29 <edwardk> no luck on getting your machine up?
20:21:08 <SamB> working on it...
20:21:14 <edwardk> kk
20:22:25 <Korollary> hmm. infocom
20:23:28 <edwardk> just think it would be fun to have something else to sit around and bug lambdabot about ;)
20:23:54 <edwardk> @zork-on
20:23:54 <lambdabot> Unknown command, try @list
20:24:47 <SamB> okay, I will go with quick and dirty solution of modifying my working copy of Twisted...
20:25:09 <SamB> its not like I have been tracking SVN lately or anything... (and it is still the SVN working copy...)
20:25:16 <edwardk> *nods*
20:25:28 <Korollary> I could use a @larry command
20:26:07 <edwardk> lambdabot needs a built in xclient so we can do graphical apps ;)
20:26:22 <SamB> you mean server?
20:26:32 <edwardk> no, in x the terminology is reversed.
20:26:38 <edwardk> the xserver displays, the client serves.
20:26:45 <SamB> eh
20:26:49 <edwardk> its stupid but traditional
20:26:54 <SamB> the client is the app
20:27:01 <SamB> the server has the screen
20:27:01 <edwardk> yeah
20:27:22 <SamB> however lambdabot is not authorized to connect to my display!
20:27:47 <edwardk> well, that would be a condition for using the fancy apps wouldn't it ;)
20:27:48 <SamB> anyway, it should work now...
20:27:51 <edwardk> yay
20:28:06 <SamB> don't shoot me for the terrible GTK interface!
20:28:18 <edwardk> kk
20:28:33 <edwardk> timed out
20:28:41 <SamB> hrmm
20:30:50 <SamB> don't suppose you could tcptraceroute me?
20:31:43 <edwardk> i can do an oldschool traceroute if you want
20:32:17 <edwardk>  
20:32:17 <edwardk> 12  ge6-1.aggr1.phdl.pa.rcn.net (207.172.15.53)  33.127 ms  88.097 ms  80.819 ms
20:32:17 <edwardk> 13  upd-ubr7.trpr-upd.pa.cable.rcn.net (209.122.64.211)  40.540 ms  124.682 ms  34.173 ms
20:32:17 <edwardk> 14  * * * ...
20:33:14 <edwardk> no love from a ping either
20:33:19 <SamB> maybe I should just tarball it and send it to you via DCC?
20:33:34 <edwardk> that might work, but firewalled
20:33:40 <edwardk> one sec
20:34:16 <edwardk> msging solution
20:36:16 <kfish> dons: cool ... are the paper links (.ps.gz, .pdf) supposed to work yet?
20:36:47 <dons> almost....
20:40:08 <dons> ok, yes. done! http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
20:40:10 <lambdabot> Title: Rewriting Haskell Strings, http://tinyurl.com/eobse
20:40:44 <musasabi> Congratulations
20:41:08 <dons> *relief*
20:44:47 <kfish> dons: heh :)
20:45:24 * syntaxfree points musasabi to #haskell-blah
20:48:59 <syntaxfree> oh! dons and dcoutts = teh celebs.
20:53:28 <syntaxfree> umm. this Data.ByteString stuff looks like black magic.
20:53:55 <dons> magic?
20:55:38 <SamB> syntaxfree: what did you expect from dons?
20:55:53 <SamB> at least it comes in a box!
20:56:25 <dons> magic in a box?
20:56:28 <syntaxfree> you're basically saying I can have these really fast strings, lazily, with minimal code adaptation? Where's the price to be paid?
20:56:39 <SamB> syntaxfree: it isn't a list no more!
20:56:42 <int-e> compile time ;)
20:56:48 <dons> heh, yes
20:56:54 <syntaxfree> ah, yes, polymorphism.
20:56:58 <dons> and umm, dcoutts and I wrote nearly 1k patches in 3 months :)
20:57:02 <musasabi> @karma+ dons ByteString
20:57:03 <lambdabot> dons's karma raised to 53.
20:57:07 <lispy> damn
20:57:08 <musasabi> @karma+ dcouttsByteString
20:57:08 <lambdabot> dcouttsByteString's karma raised to 1.
20:57:12 <syntaxfree> @karma+ dons Black magic
20:57:13 <lambdabot> dons's karma raised to 54.
20:57:13 <musasabi> @karma+ dcoutts ByteString
20:57:14 <lispy> dons: you guys rock :)
20:57:14 <lambdabot> dcoutts's karma raised to 21.
20:57:19 <syntaxfree> @karma+ dcoutts Black magic
20:57:20 <lambdabot> dcoutts's karma raised to 22.
20:57:26 <lispy> @karma-list
20:57:26 <lambdabot> Unknown command, try @list
20:57:33 <lispy> @karma
20:57:34 <lambdabot> You have a karma of 5
20:57:39 <lispy> hmm...
20:57:43 <dons> yeah, compile time does slow down, int-e: you should see ghc 6.6 try to churn through lambdabot
20:57:48 <int-e> write lambdabot patches ;)
20:57:56 <dons> all those rewrite rules firing away
20:57:58 <int-e> (lispy)
20:58:05 <dons> ?karma-all
20:58:05 <lambdabot>  dons                   54
20:58:05 <lambdabot>  dcoutts                22
20:58:05 <lambdabot>  shapr                  21
20:58:05 <lambdabot>  xerox                  21
20:58:05 <lambdabot>  Lemmih                 20
20:58:07 <lambdabot> [228 @more lines]
20:58:10 <lispy> dons: so what aspects of ghc give the biggest performance boost?
20:58:28 <lispy> int-e: i wrote the tiny-url thing :)
20:58:35 <lispy> int-e: and got some karma for that :)
20:58:54 <dons> hmm. there's a bunch of things. its great handling of strict functions, and unpacking. the rewrite rules, obviously. the new fast ForeignPtr and mutable byte array support
20:58:56 <musasabi> How optimized is the rewrite-rule processing? Maybe it could be optimized to improve compile-times.
20:59:08 <dons> i'm not sure how much the compile time cost is due to rewrite rules
20:59:29 <dons> though it'd be worth looking at now there's so much work being done in user-supplied rules
20:59:36 <lispy> it would be interesting to profile ghc on large projects
21:00:42 <syntaxfree> @hoogle ByteString->String
21:00:43 <lambdabot> No matches, try a more general search
21:01:03 <musasabi> unpack
21:01:14 <syntaxfree> @type Data.ByteString.unpack
21:01:16 <lambdabot> Data.ByteString.Base.ByteString -> [Word8]
21:01:21 <syntaxfree> cool.
21:01:42 <syntaxfree> dons: you rock. Come over to Rio and I shall show you the party.
21:01:47 <lispy> dons: what about unicode?
21:02:02 <lispy> \m/
21:02:03 <dons> further work.
21:02:13 <dons> got to port sjanssen's stuff into the main branch
21:02:15 <lispy> did old fps support unicode?
21:02:23 <dons> sort of
21:02:31 <dons> the way darcs does
21:02:44 <lispy> which is? (some aspects of darcs i know 0 about)
21:02:50 <SamB> but not really... it wasn't in the types or anything...
21:02:50 <dons> there's some C gunk of hacking at things
21:02:52 <lispy> s/some/most/
21:02:56 <SamB> right?
21:02:56 <dons> right
21:03:09 <SamB> also wasn't mandatory
21:03:15 <lispy> hmm...
21:03:28 <lispy> well, it will be interesting to upgrade darcs to Data.ByteString
21:03:39 <SamB> it had too sets of pack/unpack functions, one that did utf8 and one that did latin1
21:03:45 <SamB> er, two
21:03:47 <dons> yeah
21:03:56 <lispy> ah
21:04:10 <SamB> potentially quite error prone!
21:04:29 <lispy> yeah, everyone that uses darcs must be doing mostly ascii?
21:04:32 <SamB> didn't that deadline pass yet?
21:04:50 <lispy> which deadline? getting into 6.6?
21:04:57 <SamB> no, dons had a deadline
21:05:01 <lispy> oh
21:05:05 <SamB> he said it was in an hour a while back...
21:05:23 <dons> yes. done :)
21:05:27 <dons> you want me to patch lambdabot now?
21:05:34 <SamB> yes please!
21:05:36 * dons patches lambdabot
21:05:38 <int-e> So you didn't use US west coast time after all?
21:05:48 <dons> well, we got done early
21:05:55 <SamB> huh?
21:05:57 <dons> ?localtime lispy
21:05:58 <lambdabot> Local time for lispy is Sun Sep  3 21:05:34 2006
21:06:03 <dons> yeah, heaps to spare
21:06:31 <lispy> heh
21:06:43 <lispy> your deadline was in my timezone?
21:06:46 <dons> you're on the west coast?
21:06:52 <lispy> yup
21:06:54 * araujo back
21:06:56 <lispy> oregon
21:06:58 <int-e> the deadline failed to specify a time zone
21:07:05 <dons> yeah, the deadline was "Sunday 3rd"
21:07:11 <dons> so I figure west coast is ok
21:07:15 <SamB> couldn't you have used alaskan time?
21:07:20 <dons> or hawaii
21:07:23 <SamB> aren't they another zone over?
21:07:25 <dons> or samoa
21:07:28 <lispy> hell, india!
21:07:32 <dons> no no.
21:07:34 <lispy> oh wait...
21:07:39 <dons> india is already gone
21:07:40 <SamB> what, hawaii is this side of the international date line?
21:07:47 <dons> yup
21:07:58 <dons> the date line's not that far from sydney, about 3 hours or 2
21:08:01 <lispy> what about thailand? /me goes to look it up
21:08:10 <dons> so most of the pacific is in yesterday-land
21:08:12 <SamB> where by "this side" I am referring to *my* side, not *your* side
21:08:15 <dfranke> where did "fold" get its name?  Every other language calls it "reduce".
21:08:25 <dons> lisp?
21:08:32 <SamB> dfranke: maths, maybe!
21:08:43 <SamB> don't ask me where the maths got it from!
21:08:46 <dfranke> dons: lisp calls it reduce.
21:08:54 <dons> ah
21:08:59 <dons> ?foldoc fold
21:09:00 <lambdabot> No match for "fold".
21:09:03 <dons> ?foldoc foldl
21:09:03 <lispy> but in lisp it's just one fold
21:09:04 <lambdabot> No match for "foldl".
21:09:08 <dolio> :) Ruby calls it inject.
21:09:08 <dons> ?foldoc reduce
21:09:09 <lispy> iirc, it's foldl == reduce
21:09:10 <lambdabot> *** "reduce" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:09:10 <lambdabot> REDUCE
21:09:10 <lambdabot>  
21:09:10 <lambdabot>     <language, mathematics> A {symbolic mathematics} language with
21:09:10 <lambdabot>     {ALGOL}-like {syntax}, written in {Lisp} by Anthony Hearn in
21:09:12 <lambdabot> [15 @more lines]
21:09:16 <dons> ?more
21:09:16 <lambdabot>     1963.
21:09:18 <lambdabot>  
21:09:20 <lambdabot>     Reduce 2 is a version based on {Portable Standard LISP}.
21:09:22 <lambdabot>  
21:09:24 <lambdabot>     {Home (http://www.rrz.uni-koeln.de/REDUCE/)}.
21:09:25 <SamB> hmm...
21:09:26 <lambdabot> [10 @more lines]
21:09:30 <SamB> not very related...
21:09:32 <dons> foldoc is annoying.
21:09:39 <syntaxfree> I kinda don't understand =<<
21:09:50 <dfranke> lispy: in CL, if you supply :from-end 't it'll act like foldr.
21:09:55 <SamB> syntaxfree: same as >>= only backwards
21:10:07 <SamB> what lovely symmetry!
21:10:10 <syntaxfree> I know.
21:10:27 <SamB> oh, but you don't get >>= yet either?
21:10:33 <lispy> oh, i see, new zealand is about as close to the date line as you can get
21:10:38 <syntaxfree> I get >>=
21:10:41 <int-e> if we had reduce, what would unfoldr be called?
21:10:41 <dons> ok, SamB, your critical patches are applied.
21:10:43 <syntaxfree> I don't get its inverse!
21:10:49 <dons> explode?
21:10:56 <dolio> g >>= f === f =<< g
21:11:18 <SamB> I said "backwards" because the arguments are reversed...
21:11:26 <dylan> @pl flip (>>=)
21:11:26 <lambdabot> (=<<)
21:11:29 <SamB> that is why it has the same symbol, only backwards!
21:11:36 <int-e> flipped :)
21:11:54 <SamB> @pl flip (>>>>>>>)
21:11:54 <lambdabot> flip (>>>>>>>)
21:12:03 <int-e> Hmm, =>> would be my version of '>>= backwards' actually.
21:12:08 <SamB> doesn't work on arbitrary symbols though, unfortunately...
21:12:16 <SamB> int-e: you are silly
21:12:16 <int-e> @pl flip (+)
21:12:17 <lambdabot> (+)
21:12:22 <int-e> SamB: I know.
21:12:23 <SamB> you do not flip bracket-like things!
21:12:24 <lispy> but, the arrows point ot the accepting monadic function
21:12:40 <lispy> so =>> still looks like it's going the first direction
21:12:41 <SamB> @pl flip (>>)
21:12:41 <lambdabot> flip (>>)
21:12:46 <dylan> @pl flip (-)
21:12:46 <lambdabot> subtract
21:12:53 <SamB> @type (<<)
21:12:54 <lambdabot> Not in scope: `<<'
21:12:57 <SamB> what!!!!
21:13:00 <SamB> there is no << function?
21:13:08 <int-e> what for?
21:13:09 <dolio> @hoogle <<
21:13:10 <lambdabot> Text.Html.(<<) :: HTML a => (Html -> b) -> a -> b
21:13:10 <lambdabot> Control.Arrow.(<<<) :: Arrow a => a c d -> a b c -> a b d
21:13:10 <lambdabot> Control.Arrow.(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
21:13:15 <int-e> =<< is just there to work with <-
21:13:23 <SamB> I suppose
21:13:32 <SamB> I have never missed it before in my life...
21:13:35 <int-e> it does the computations in reverse order so it's harder to read in most other contexts.
21:13:44 <SamB> not that I used Haskell before 2003...
21:15:43 <syntaxfree> The other day someone here was saying there used to be monad comprehensions.
21:15:57 <syntaxfree> that sounds cool.
21:16:15 <syntaxfree> folds/maps/filters over lists of monads = yummy.
21:16:18 <musasabi> The problem was with type errors being too general.
21:17:45 <musasabi> But having them back would be very nice. Maybe by making the PArr comprehension syntax into the generic one and keeping the normal for lists could work.
21:19:18 <syntaxfree> many type errors are too general.
21:19:24 <syntaxfree> by the way, simple typing question.
21:19:28 <lispy> it seems that people who understand type errors think monad comps. would be cool and everyone else is afraid of them :)
21:20:03 <dolio> One of the papers I have on parser combinators used monad comprehensions a bunch.
21:20:14 <dolio> It threw me off when I typed in the code and it didn't work. :)
21:20:57 <syntaxfree> Many papers have invalid code, in my experience.
21:21:11 <dolio> Yeah.
21:21:15 <syntaxfree> It took me half an hour to get the Dual type class code from Jones (1995) to work.
21:21:45 <dolio> Many like to use type synonyms that are illegal (because they're partially applied in type classes).
21:22:17 <syntaxfree> so let's say I have this type class Dual.
21:22:29 <syntaxfree> then I have dual :: Dual -> Dual
21:22:29 <SamB> lispy: I understand type errors but I think I'd rather not have to do so every time I used a comprehension and messed up the type...
21:22:51 <syntaxfree> and then I have a lot of things like instance Dual Bool where dual = not
21:22:53 <syntaxfree> etc. etc.
21:23:03 <syntaxfree> instance Dual Int where dual = negate
21:23:15 <syntaxfree> I'd like to  have something like
21:23:15 <SamB> you can't have functions like that
21:23:22 <SamB> Dual is a class, not a type!
21:23:54 <syntaxfree> yeah. Actually, (Dual a)=>a->a
21:24:03 <syntaxfree> anyway.
21:24:16 <syntaxfree> I have instance Dual Int where dual = negate
21:24:53 <syntaxfree> I'd like to have instance (Dual a,  Num a)=>(Dual a) where dual = negate
21:25:12 <syntaxfree> in other words, I'd like to somehow Num to be a subclass (if that's the term) of Dual.
21:25:28 <syntaxfree> or create a class DualNum that does the trick.
21:25:35 <syntaxfree> (that's a subclass of Dual and Num)
21:25:53 <dons> ?uptime
21:25:53 <lambdabot> uptime: 1d 45m 50s, longest uptime: 1d 21h 35m 42s
21:26:42 <Korollary> lambdabot is not even as good as windows 98.
21:26:50 <dolio> Heh.
21:27:10 <dons> :P
21:27:23 <dons> i think the longest i've seen it up for is around 30 days
21:27:32 <dons> but it always gets patched for features
21:28:04 <dolio> ... "141M    .xsession-errors"
21:28:13 <Korollary> ugh
21:28:31 <dons> oh, interesting, $ du -hs .xsession-errors
21:28:32 <dons> 480K    .xsession-errors
21:28:43 <dons> why do these even got logged to my home dir. stupid
21:29:15 <syntaxfree> Mingus:~ syntax$ du -hs .xsessionerrors
21:29:15 <syntaxfree> du: .xsessionerrors: No such file or directory
21:29:22 <syntaxfree> Darwin Mingus.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc
21:29:26 <dolio> KDE seems to be dumping 5 - 10 lines of logs per second into that file.
21:29:28 * syntaxfree boasts.
21:30:41 <int-e> what's KDE? ;-) *ducks and runs*
21:31:25 <syntaxfree> KDE is the Kool Desktop Environment.
21:31:41 <dons> $ pkg_info kde
21:31:41 <dons> $
21:31:43 <dons> hehe
21:31:51 <syntaxfree> It's actually very pretty, even from an OS X user point of view, and has kind of cool geeky features.
21:31:57 <foxy> dons: hey, you've finished your paper now haven't you!! ;P
21:32:18 <syntaxfree> You can access a lot of the objects in the GUI from the command-line and, say, move the address bar of the browser to the bottom with a command.
21:32:33 <SamB> you can?
21:32:40 <foxy> dons: got time to look at yi+gtk 'C-x C-f <filename>'?
21:32:43 <syntaxfree> ask in #kde.
21:32:44 <SamB> that sounds like TV geeky!
21:32:47 <dons> hehe. soon soon
21:32:51 <dons> i should have some breakfast
21:33:16 <SamB> dons: ... why did you not start on breakfast immediately after patching lambdabot?
21:33:29 <syntaxfree> http://dot.kde.org/1001577974/
21:33:32 <lambdabot> Title: Two New DCOP Tutorials
21:33:40 <dons> i felt the need to double check the paper :)
21:33:41 <syntaxfree> DCOP is KDE's answer to CORBA/COM/etc.
21:33:58 <SamB> ... COM?
21:34:13 <SamB> whatever...
21:34:18 <syntaxfree> well, so I've heard.
21:34:27 <SamB> I really don't understand COM...
21:34:58 <SamB> I mean, having pointers to things that really don't even reside in the same process?
21:35:05 <syntaxfree> I thought it was this big box of object interfaces.
21:35:18 <syntaxfree> so you pick up an excel spreadsheet and just put it in your program.
21:35:47 <SamB> maybe you can do that too, if you write in VB...
21:36:04 <SamB> .. and have excel!
21:36:18 <syntaxfree> I remember using VB as this big drag'n drop glue as a teen.
21:36:39 <SamB> I never figured out what to do with it, thankfully ;-)
21:36:40 <syntaxfree> Like for gluing things together for my parents' workflow.
21:37:01 <Korollary> some things normally don't reside in the same process.
21:37:18 <Korollary> gnome uses corba iirc
21:37:25 <SamB> Korollary: yeah...
21:37:37 <SamB> corba, though, is probably quite quite horrid
21:37:51 <SamB> also, I haven't the foggiest what GNOME uses it FOR
21:37:59 <syntaxfree> is GNUStep in the same category of Corba, COM, etc.?
21:38:06 <SamB> nope
21:38:23 <SamB> I have no idea what GNUStep uses for that sort of thing...
21:38:48 <dolio> Are there Gnome apps that embed others? I can't say I've encountered many on my brief flirts with it.
21:38:56 <SamB> but GNUStep itself is just the *Step implementation
21:39:06 <Cale> dolio: yes, the panel does
21:39:07 <dolio> As opposed to KDE, which seems to do it all the time.
21:39:16 <dolio> Ah, okay.
21:39:32 <SamB> panal applets count as apps now?
21:39:37 <SamB> er. penel?
21:39:39 <SamB> er.
21:39:44 <dolio> Heh.
21:39:44 <SamB> *PANEL*...
21:39:46 <SamB> sleep needed...
21:40:13 <syntaxfree> SamB well, I mean, is *Step in the category of Corba, COM, etc?
21:40:20 <Pupeno_> dolio: yes, there are, using bonobo, which uses Corba, but very rarely.
21:40:26 <SamB> as far as I can tell, no.
21:40:36 <SamB> but it might contain technology of that sort for all I know...
21:40:40 <Pupeno_> dolio: KDE's kpart is much more mature and much more used, I love it.
21:41:07 <Pupeno_> GNUStep is in the same category as Gtk+ and Qt+.
21:41:31 <syntaxfree> I  thought it contained an object interface library of sorts.
21:42:01 <dolio> It is designed for that to be easy, I think.
21:42:12 <Pupeno_> syntaxfree: GNUStep is a set of libraries to build (GUI) applications. In that sense it is closer to Qt than Gtk+, which is only a toolkit.
21:42:22 <dolio> Graphical GUI design, like in the old Steve Jobs NextSTEP video.
21:42:32 <Pupeno_> syntaxfree: I don't know what you mean by "object interface library".
21:42:47 <syntaxfree> Oh. GNUStep is the GNU equivalent of OS X's Interface Builder.
21:42:53 <SamB> syntaxfree: no!
21:43:04 <SamB> it is the equivalent of OS X! except missing everything!
21:43:06 <syntaxfree> (plus Cocoa)
21:43:11 <Pupeno_> syntaxfree: no, it is the equivalent of Cocoa (If I understand correctly what Cocoa is).
21:43:21 <Pupeno_> syntaxfree: the other way.
21:43:22 <syntaxfree> yes, I forgot to add "Plus Cocoa".
21:43:37 <SamB> it isn't the equivalent of IB
21:43:41 <SamB> it has an IB though
21:44:15 <syntaxfree> I should learn how to hack an Obj-C GUI at some point.
21:44:18 <Pupeno_> The main here is Cocoa/GNUStep, both implementations of the OPENSTEP standard. A standard for a set of libraries to build (GUI) applications using objective-c.
21:45:25 <Pupeno_> there are two programs in GNUStep to build GUIs graphically. One creates an XML that is readed and the GUI is created on the fly, like Gtk+'s glade or Qt's .ui files when loaded dynamically.
21:46:11 <syntaxfree> wow. The naive code with Data.ByteString is fast!
21:46:18 <Pupeno_> The other creates the objects and do some kind of marshalling to a file, then the file is opened and the objects re-instantiated in memory... something like that (Gorm is this program).
21:46:22 <dons> you tried it out, syntaxfree ?
21:46:24 * syntaxfree goes and adapts his simple text manipulation scripts.
21:46:33 <syntaxfree> I read this: http://haskell.org/haskellwiki/Wc
21:46:35 <lambdabot> Title: Wc - HaskellWiki
21:46:40 <dons> heh.
21:46:40 <Pupeno_> syntaxfree: you can write objc guis in Gtk+
21:47:16 <syntaxfree> Pupeno: well, I mean, I should learn minimal Obj-C that enables me to hack together a GUI in Interface Builder and call Haskell programs somehow.
21:47:23 <syntaxfree> (Even if it's through unix pipes)
21:47:36 <SamB> syntaxfree: it is supposed to do that!
21:47:40 <SamB> I mean, be fast!
21:47:50 <SamB> that is why they came up with all those RULES
21:47:51 <syntaxfree> I'll test it with hcat.
21:48:04 <syntaxfree> hcat is horizontal cat.
21:48:27 <dons> you should get good results. for best resuts though, you'l want fps-unstable and a ghc less than 2 weeks old
21:48:28 <syntaxfree> main = do args <- System.getArgs; texts <- mapM readFile args; (putStr . unlines . map concat . List.transpose . map lines) texts
21:48:31 <syntaxfree> I use it all th e time.
21:48:44 <dons> however, if you just care about rough numbers, any ghc with fps 0.7 would be fine
21:48:48 <SamB> dons: less than two weeks?
21:48:54 <dons> yep
21:49:00 <dons> if you really feel the need for speed
21:49:05 <syntaxfree> my GHC 6.4.1 seems to ship Data.ByteString
21:49:20 <SamB> syntaxfree: ... you sure you didn't build it yourself by accident?
21:49:26 <dons> hmm. doubt it.... ;) maybe you installed it..
21:49:41 <syntaxfree> I probably installed it attempting to compile lamdabot.
21:49:44 <dons> or else fps has teamed up with skynet to start the Rise of the Lambdas
21:49:54 <SamB> syntaxfree: oh, see the new-and-improved README!
21:50:05 <dons> heh
21:50:20 <SamB> for lambdabot
21:51:34 <Pupeno_> YAHT says that return () doesn't return (in C's sense), but, what does it do ?
21:51:46 <dons> it evaluates to () in a monad
21:52:07 <SamB> well, not much if you do something else after
21:52:11 <SamB> pretty much it does nothing
21:52:14 <int-e> do return (); return 1  evaluates both returns.
21:52:15 <Cale> return () is the computation which does nothing and returns the value ()
21:52:17 <Heffalump> the key point is that do { return 1 ; return 2 } returns 2.
21:52:46 <Pupeno_> in a sense, it is semantically similar to id () ?
21:52:53 <int-e> yes.
21:52:57 <SamB> huh?
21:53:02 <syntaxfree> oh. hcat uses unlines.
21:53:11 <Cale> @type return
21:53:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
21:53:18 <syntaxfree> that means it needs rewriting for ByteStrings.
21:53:23 <int-e> return a >>= b  ===  b a    and   a >>= return  ===  a
21:53:28 <Cale> So in the case of IO, for example,  return :: a -> IO a
21:53:33 <int-e> in that sense it's something like an identity.
21:53:33 <dons> syntaxfree: why? you've got unlines if you need it
21:53:48 <dons> ?type Data.ByteString.Char8.unlines
21:53:50 <lambdabot> [Data.ByteString.Base.ByteString] -> Data.ByteString.Base.ByteString
21:53:53 <syntaxfree> Prelude Data.ByteString> :t Data.ByteString.unlines
21:53:53 <syntaxfree> <interactive>:1:0: Not in scope: `Data.ByteString.unlines'
21:53:58 <dons> see above
21:54:02 <Cale> it's just a way to produce a do-nothing action that returns a specified value. In a do-block, the value returned is the value returned by the action in the last line.
21:54:05 <syntaxfree> not in the fps I have!
21:54:06 <Pupeno_> it's a monadifing identity.
21:54:15 <dons> syntaxfree: its in .Char8
21:54:19 <Pupeno_> ok.
21:54:21 <dons> unless your fps is super old
21:54:25 <syntaxfree> but readFile  isn't!
21:54:30 <syntaxfree> (it's in .Char8, true)
21:54:49 <dons> try a new fps then. i recommend the house specialty, fps 0.7, on the rocks.
21:54:49 <syntaxfree> I should have two import qualified lines then, right?
21:55:03 <syntaxfree> one for .Char8, one for plain.
21:55:25 <SamB> dons: what does that have to do with house?
21:55:28 <dons> yup, if you want to use stuff from Char8 and from normal
21:55:42 <dons> nono, that'd be the House specialty
21:55:51 <dons> case is significant in #haskell
21:55:54 <SamB> oh
21:56:05 <SamB> so if I say cabal it doesn't mean the same as Cabal?
21:56:14 <dons> right.
21:56:19 <SamB> and I can't go around saying gtk all the time?
21:56:21 <dons> there's a cabal Cabal, for example
21:56:24 <dons> or otherway around
21:56:42 <dons> possibly, if let gtk = GTK
21:57:10 <SamB> huh
21:57:22 <SamB> strange!
21:57:38 <syntaxfree> why is there a ByteString getArgs?
21:58:07 <dons> a) because. b) its been removed from head
21:58:08 <SamB> in case there are a lot of Args?
21:58:22 <dons> yes, specifically it was for an early version of hmp3
21:58:30 <dons> that read file names on the command line
21:58:34 <SamB> heh
21:58:49 <SamB> so why does that mean you remove it when hmp3 supports recursion?
21:58:51 <Pupeno_> is there any cheat-sheet to haskell syntax ? containing a list of keywords for example ?
21:59:02 <SamB> Pupeno_: you mean like a lexer?
21:59:05 <dons> yeah. let me see.
21:59:13 <dons> Pupeno_: check on the haskell.org wiki
21:59:37 <dons> here, http://www.haskell.org/haskellwiki/Reference_card
21:59:40 <lambdabot> Title: Reference card - HaskellWiki, http://tinyurl.com/ku8mb
21:59:41 <dons> there's other refs too
22:00:07 <dfranke> woot, my first Haskell program works.
22:00:08 <Pupeno_> dons: thank.s
22:00:23 <SamB> dfranke: nice ;-)
22:00:29 <Cale> @google tour haskell syntax
22:00:31 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
22:00:31 <lambdabot> Title: Tour of the Haskell Syntax
22:00:34 <SamB> that is kinda usual after fixing type errors though ;-)
22:01:12 <syntaxfree> dfranke:  w00t. What does it do? :)
22:01:33 <dons> ?where+ syntax http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
22:01:34 <lambdabot> Done.
22:02:22 <dfranke> I think I may have written this program in 50 languages by now.
22:02:37 <dfranke> syntaxfree: solves a tower of hanoi.
22:02:49 <syntaxfree> oh. coo.
22:04:22 <dfranke> Jury's still out as to whether I want to switch from CL though.
22:05:21 <syntaxfree> Haskell attracts more chicks.
22:05:26 <syntaxfree> ?vixen-on
22:05:26 <lambdabot> Not enough privileges
22:05:30 <syntaxfree> ?vixen
22:05:30 <lambdabot> stop being racist!
22:05:52 <dfranke> Lazy evaluation is awesome but I tend to prefer dynamically-typed languages.
22:06:34 <dfranke> and I'm going to have to play with template Haskell some to see if it makes a suitable substitute for defmacro.
22:09:23 <syntaxfree> have you read "The Evolution of a Haskell Programmer"?
22:09:24 <Cale> dfranke: I think you'll find Haskell's type system to be addictive :)
22:10:04 <Cale> It's really nice once you realise that it's cut out most of the time you would have spent debugging :)
22:10:59 <dfranke> syntaxfree: yup
22:12:29 <dfranke> the last time I tried out a similar type system was with ML and I got frustrated with the shitty ad-hoc polymorphism.  Haskell seems be better at that though.
22:13:02 <dons> types are so much nicer than unit tests :)
22:13:07 <Cale> yeah, there's no ad-hoc polymorphism, we have typeclass bounded polymorphism which is much nicer :)
22:16:18 <dfranke> in Haskell, my jaw dropped when I typed 'natnums = 0 : map (1 +) natnums' and it actuall worked.
22:16:27 <dons> :)
22:16:29 <dons> that's cool
22:16:54 <dfranke> and yes, I know there are better ways of doing that, but this one is deliciously perverse.
22:17:39 <dons> > fix ((1 :) . map (1 +))
22:17:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:18:09 <dons> nono, I think that's rather a nice definition :)
22:18:14 <dons> reminds me of fib
22:18:31 <dons> > let fibs = 1 : 1 : zipWith (+) fibs (tail  fibs) in fibs
22:18:32 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:19:20 <Pseudonym> lispy: I just noticed that you asked me a question about free theorems earlier.
22:19:36 <Cale> > fix ((0:) . scanl (+) 1)
22:19:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:19:38 <Pseudonym> Whether bottom-free programs can violate the theorem.
22:19:43 <Pseudonym> The answer is no.
22:19:57 <Pseudonym> So it's no good for generating test cases.
22:20:05 <Cale> or
22:20:07 <Cale> > fix ((1:) . scanl (+) 1)
22:20:08 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:20:33 <Pseudonym> It _is_, however, good for generating axioms.
22:20:53 <dons> the scanl version is super nice
22:20:56 * Pseudonym has started a paper with the tentative title "Axioms for free!"
22:20:59 <dons> ?karma+ scanl
22:21:00 <lambdabot> scanl's karma raised to 1.
22:21:02 <dons> Pseudonym: oh nice.
22:21:06 <jrmole> yeah, that's hot
22:21:11 <Pseudonym> If anyone who knows a thing or two about category theory wants to co-author, please drop me a line.
22:21:14 <dons> btw, did you see Voigtlander's free theorems tool?
22:21:26 <Pseudonym> Yes, I did.
22:21:31 <Pseudonym> And it handles the fix model, too!
22:21:34 <dons> I talked to him about it, he was quite interested
22:21:36 <dfranke> I know a thing or two, but I probably don't know three things.
22:21:47 <dfranke> I just started reading Mac Lane a couple days ago.
22:22:33 <Pseudonym> Successful applicants would have to have an inkling as to why, categorically speaking, the parametricity theorem is true.  Or at least to be able to bluff it well enough to fool me.
22:22:46 <Pseudonym> Which isn't hard, hence the need for a co-author.
22:23:35 <dons> I can write you some code that breaks build/foldr because of seq, if that helps :)
22:23:47 <dfranke> don't think I can help you.
22:23:55 <jrmole> @pl f n = if odd n then 3*n + 1 else n `div` 2
22:23:55 <lambdabot> f = ap (liftM2 if' odd ((1 +) . (3 *))) (`div` 2)
22:24:15 <dfranke> bed.
22:24:54 <Pseudonym> @pl f n = if n == 1 then 1 else f (if odd n then 3*n+1 else div n 2)
22:24:54 <lambdabot> f = fix (ap (flip if' 1 . (1 ==)) . (. ap (liftM2 if' odd ((1 +) . (3 *))) (flip div 2)))
22:58:01 <Pupeno> Do you think a syntax highlighting should distinguish between floats an integers ?
22:58:34 <abz> no
22:59:11 <abz> why should it?
22:59:15 <Pupeno> that seems the sane thing...
22:59:16 <jrmole> in haskell you'd need heavy type inference to do that anyway
23:00:07 <dons> probably you just mean token-based syntax highlighting?
23:00:11 <dons> 1.0 v 1
23:00:16 <Pupeno> jrmole: indeed... Kate highligting can separate integers from floats by the presence of a dot (.), but if I can't separate floats from doubles and ints from integers, it doesn't make much sense to make any distintion at all.
23:00:21 <Pupeno> dons: right.
23:00:32 <dons> so yeah, maybe its useful. if you use lots of floats
23:00:33 <jrmole> well, and you can just as easily have
23:00:35 <jrmole> > 2 :: Double
23:00:36 <lambdabot>  2.0
23:01:14 <Pupeno> jrmole: we could argue that "2" is still integer there.
23:01:27 <dons> yeah, so whether you care about accuracy, or just want a visual hint
23:01:35 <jrmole> we could argue, but Haskell's type system would disagree, and i think it gets the final word ;)
23:01:38 <jrmole> but it is a visual hint, yeah
23:05:45 <Pupeno> lisppaste2: url
23:05:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:06:40 <lisppaste2> Pupeno pasted "line comments" at http://paste.lisp.org/display/25306
23:07:41 <Pupeno> Is there any preference to start the one-line comments at the end of the line or at the end of the code ? (see the paste)
23:08:57 <dons> neither :)
23:08:59 <dons> do x
23:09:03 <dons>     -- some comment
23:09:06 <dons>     the rest
23:09:12 <dons> oh, modulo layout :)
23:09:24 <dons> so your second case, but not with --somethingElse
23:09:29 <dons> you want a space after --
23:10:37 <Pupeno> dons: ok.
23:12:43 <dons> ?quit new code
23:13:25 <Pseudonym> ?free f :: a -> a
23:13:56 <lambdabot> g . f = f . g
23:13:59 <Pseudonym> Cool.
23:14:04 <dons> ?free sortBy
23:14:14 <lambdabot> g x y = h (f x) (f y) => $map f . sortBy g = sortBy h . $map f
23:14:16 <dons> (did you see this patch?)
23:14:20 <Pseudonym> No, I didn't.
23:14:21 <Pseudonym> Very cool.
23:14:22 <dons> (it calls ?type)
23:14:33 <Pseudonym> Oh, I have an issue.
23:14:45 <Pseudonym> I wanted to replace $map_Functor with fmap.
23:14:47 <Pseudonym> However.
23:14:55 <Pseudonym> ?free return :: a -> M a
23:14:55 <lambdabot> $map_M f . return = return . f
23:14:59 <Pseudonym> That'd work, but:
23:15:07 <dons> oh, is it the kind annotations?
23:15:08 <Pseudonym> ?free naturalTransformation :: F a -> G a
23:15:08 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
23:15:14 <dons> ?free fmap
23:15:15 <Pseudonym> That wouldn't make any damn sense.
23:15:16 <lambdabot> Expected variable or '.'
23:15:19 <dons> 6^
23:15:30 <dons> interesting
23:15:34 <Pupeno> lambdabot is indeed the most impresive bot I've ever seen.
23:15:40 <dons> ?uptime
23:15:41 <lambdabot> uptime: 2m 55s, longest uptime: 1d 21h 35m 42s
23:15:49 <dons> ?remember Pupeno lambdabot is indeed the most impresive bot I've ever seen
23:16:06 <lambdabot> Why thank you :)
23:16:22 * lambdabot preens
23:16:29 <edwardk> ll you have to do to get ?remembered is to say something nice about lambdabot =)
23:16:33 <edwardk> er All
23:16:41 <dons> hehe
23:16:56 <int-e> @ask
23:16:57 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
23:16:57 <dons> lambdabot allows herself that vanity
23:17:03 <edwardk> heh
23:17:32 <dons> that looks like a bug
23:18:37 <Pseudonym> Incidentally, the fact that the free theorem for naturalTransformation is actually the category definition of a natural transformation is the coolest thing ever.
23:18:47 <Pseudonym> IMO
23:19:04 <int-e> @free invert :: (a -> b) -> b -> a
23:19:05 <lambdabot> g . h = k . f => f . invert h = invert k . g
23:19:08 <dons> huh. yeah. that's nice
23:19:09 <edwardk> yeah =)
23:19:26 <audreyt> wow, Scala has monad comprehension.
23:19:34 * audreyt is very impressed
23:19:54 <int-e> @free Control.Monad.Fix.fix
23:19:55 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
23:20:04 <dons> ?type Control.Monad.Fix.fix
23:20:05 <lambdabot> forall a. (a -> a) -> a
23:20:07 <audreyt> is there preprocessor or some kind of rewriter
23:20:11 <dons> ?free fix
23:20:12 <audreyt> that restores monad comprehension to haskell?
23:20:13 <lambdabot> f . g = h . f => f (fix g) = fix h
23:20:14 <edwardk> hrmm, wonder what one would have to do to make a @free that took into account seq blowing up free theorems
23:20:26 <dons> audreyt: if there isn't, there should be :)
23:20:27 <Pseudonym> Did I mention that the type parser can't handle qualified names?
23:20:50 <edwardk> audreyt: not yet. we were looking through the code a week or two back trying to figure out what it would take to get them back in ghc at least as an option though
23:20:50 <audreyt> # http://scala.epfl.ch/intro/comprehensions.html
23:20:52 <dons> edwardk: a bunch of papers by Janis Voightlaender
23:20:54 <lambdabot> Title: The Scala Programming Language: Sequence Comprehensions, http://tinyurl.com/zcv6o
23:20:59 <edwardk> dons: read em
23:21:09 <Pseudonym> ?google fast and loose reasoning is morally correct
23:21:11 <audreyt> the syntax makes Scala/Java programs read positively like haskell
23:21:12 <lambdabot> search module failed: IRCRaised Lib/Url.hs:150:6-51: Irrefutable pattern failed for pattern Data.Maybe.Just ctype
23:21:18 <Pseudonym> Huh?
23:21:19 <dons> huh
23:21:28 <dons> ?google is the network ok?
23:21:28 <Pseudonym> edwardk: Anyway, google that.
23:21:31 <lambdabot> http://www.linuxquestions.org/questions/showthread.php?t=182416
23:21:36 <dons> hehe
23:21:36 <Pseudonym> LOL!
23:21:40 <dons> linux question heh
23:21:48 <Pseudonym> ?google more evil than satan himself
23:21:50 <lambdabot> http://www.cnn.com/TECH/computing/9911/15/search.engine.ms.idg/
23:21:51 <lambdabot> Title: CNN - Search engines gang up on Microsoft - November 15, 1999
23:21:56 <dons> ?google fast and loose reasoning is morally correct
23:22:00 <lambdabot> http://www.citeulike.org/user/msakai/article/665357
23:22:05 <Pseudonym> That's the one.
23:22:12 <dons> well that was obviously a glitch in the matrix
23:22:16 <int-e> I'm feeling lucky returns a broken link for that one ;)
23:22:49 <edwardk> audrey: anyways there are three sets of code in the comprehension desugarer one for array comprehensions, and two for lists, one of which sets up for fusion, the other is more general. that latter one could probably be morphed back into a onad comprehension
23:23:19 <int-e> hmm, at least it's broken here right now. strange ...
23:24:52 <edwardk> ?google recovering free theorems in the presence of seq
23:24:53 <audreyt> edwardk: are you talking about GHC core?
23:24:56 <lambdabot> http://crab.rutgers.edu/~pjohann/popl04.pdf
23:24:58 <edwardk> audreyt: yeah
23:25:08 <audreyt> ooooh.  -fmonad-comprehension anyone?
23:25:17 <edwardk> audreyt: thats what i was hoping for =)
23:25:25 * dons raises hand
23:25:56 <audreyt> then we can have ByteString comprehension
23:26:02 <audreyt> which would be a Huge Win (tm)
23:26:06 <edwardk> audrey: coz to paraphrase dons, we already gave up easy to read error messages in the name of features, so the 'its hard to understand' excuse doesn't hold much water any more
23:26:08 <lambdabot> Yes, dons?
23:26:20 <audreyt> edwardk: and in any case it's a -f
23:26:24 <audreyt> so you asked for it
23:26:24 <edwardk> yeah
23:27:17 <dons> ?vixen oh, I raised my hand to vote for -fmonad-comprehensions
23:27:18 <lambdabot> yeah
23:27:31 <dons> i wish we had a megamonad plugin
23:27:32 <edwardk> audrey: compiler/deSugar/DsListComp.lhs
23:27:32 <audreyt> edwardk: are you going to GHC hackathon?
23:27:37 <edwardk> audrey: when is it?
23:27:40 <audreyt> if not, we should bribe a hackathoner
23:27:43 <dons> i've got these 17 years of mailing list archives, and 5 years of irc,to feed to it
23:27:51 <edwardk> i will be at icfp from 16th to the end of the conference
23:27:54 <audreyt> Sep 14, 15
23:27:58 <edwardk> ah crap
23:28:00 <jrmole> i too vote for monad comprehensions
23:28:03 <edwardk> nah thats rightbefore i get there
23:28:08 <audreyt> http://hackage.haskell.org/trac/ghc/wiki/Hackathon
23:28:11 * Pseudonym shudders at the thought of being visited by the ghost of IRC logs past
23:28:12 <lambdabot> Title: Hackathon - GHC - Trac, http://tinyurl.com/f5y5y
23:28:27 <audreyt> edwardk: but neverthrless l the right peopole are there
23:29:02 <audreyt> I stalked^Wfollowed SPJ for 3 days in last year's ICFP to hack in object notation
23:29:09 <edwardk> audrey: yeah. i took a peek under the hood, established it seemed feasible, then backed away to read more papers on how ghc was structured
23:29:24 <Heffalump> audreyt: is it still there?
23:29:26 <audreyt> so if you can do the same, that'd be wonderful
23:29:30 <edwardk> hehe
23:29:30 <Pupeno> any particular piece of code to test syntax highlighting in Haskell ?
23:29:33 <audreyt> Heffalump: sure, part of 6.6 no
23:29:36 <audreyt> *now
23:30:27 <audreyt> http://haskell.org/hawiki/Existentially_20quantified_20record_20constructors
23:30:30 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki, http://tinyurl.com/lgos2
23:31:24 <edwardk> audrey: saw those. its a step in the right direction, but it still doesn't solve the need to be able to expand those when you want to subclass and extend the interface. either requires some form of tail pointer to another struct or a head pointer into the superclass's struct, etc and gets mesy
23:31:46 <audreyt> edwardk: perl6 doesn't use the usual form of inheritance
23:31:54 <audreyt> inheritance is emulated by delegation
23:32:00 <audreyt> so the notation is good enough for my use
23:32:06 <edwardk> it seems any conventional OO fix really needs a better form of record
23:32:07 <edwardk> yeah
23:32:35 <audreyt> that also solves the icky cross-language inheritance protocol problem
23:32:57 <audreyt> and in any case inheritance that depends on knowledge of private layout is imho a broken pattern.
23:33:57 <edwardk> I just would like to be able to extend a record { foo :: a, bar :: b } to { foo :: a, bar :: b, baz :: c } and use the latter as the former when needed
23:34:21 <audreyt> but you can
23:34:25 <edwardk> ?
23:34:40 <audreyt> either unify them into the sametype
23:34:43 <audreyt> and use two constructors
23:35:03 <edwardk> yeah but this blows any concept of separate compilation and later extensibility and all the traditional OO stuff out the window
23:35:04 <audreyt> or write a typeclass that proxies for methods and make both types an instance of it, and put them in an existntial box
23:35:12 <audreyt> the latter survives separate compilation
23:35:18 <edwardk> the latter is the solution that i have to use now
23:35:25 <audreyt> as long as you can do .hs-boot reliably
23:35:27 <audreyt> and put instances into them
23:35:33 <audreyt> which is why Pugs will very soon depend on GHC 6.6.
23:35:37 <audreyt> (6.4's support is broken)
23:35:40 <edwardk> but it feels remarkably heavy weight in a language that prides itself on elegant syntax =)
23:36:27 <Heffalump> it's a shame record constructors can't be used as typeclass members
23:37:21 <audreyt> actually, the "data family" stuff can perhaps be used to solve this
23:37:36 <audreyt> iirc I've seen an encoding somewhere
23:37:40 <audreyt> but can't quite remember now
23:37:41 <edwardk> thats all the sytem Fc stuff right?
23:37:48 <audreyt> yes
23:37:52 <audreyt> TyFuns
23:37:53 <edwardk> chakravarty down by where dons is
23:38:58 <edwardk> is that slated to merge into ghc-proper? someone here posted a link to the code the other day
23:39:06 <dons> yeah, soonish
23:39:09 <dons> I think
23:39:16 <kosmikus> good morning
23:39:27 <edwardk> good. thats also needed to be able to support, class-associated types, right?
23:39:36 <dons> morning kosmikus. thanks for the help with the paper :)
23:39:37 <edwardk> i seem to recall a mailing list post saying something to that effect
23:39:44 <kosmikus> dons: you're welcome
23:39:47 <dons> edwardk: yup
23:39:50 <edwardk> I really want class-associated types.
23:39:54 <kosmikus> dons: is it submitted now?
23:40:01 <dons> yep :)
23:40:09 <kosmikus> dons: congratulations then
23:40:21 <edwardk> the moment those work i'll probably vanish for a week doing monad-independent data structures. =)
23:40:21 <dons> here, http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
23:40:23 <lambdabot> Title: Rewriting Haskell Strings, http://tinyurl.com/eobse
23:40:25 <dons> cheers :)
23:40:55 <edwardk> no more 6 parameter types, gah
23:41:27 <audreyt> edwardk: wow, I crave for those so much
23:41:40 <Heffalump> what's it submitted to?
23:41:48 <dons> PADL
23:42:22 <edwardk> audrey: i tried to take that STM hash code and ake it generic across IO, STM, and ST s. the result was way hideous to use from the end-user perspective and required explicitly passing a bunch of parameters that they shouldn't care about.
23:43:04 <Heffalump> what kind of things need passing?
23:43:05 <edwardk> too much implementation detail was exposed coz i couldn't simplify the type signature because the type needed to know about a class and some of its fundeps. so i had to specify everything as a parameter on the type
23:43:12 <edwardk> heff: in that case?
23:43:25 <Heffalump> yes
23:43:55 <edwardk> heff: the monad, the array type for an array of lists of [(key,value)] pairs, the reference type that monad used, the key type and value type for the hash
23:43:57 <audreyt> edwardk: was there, burned similarily, ended up writing a SIO monad that unifies IO and STM
23:44:14 <Heffalump> oh, right, yes. I remember trying to do that kind of thing and giving up.
23:44:19 <edwardk> the array type is TOTALLY internal, but i had to expose it
23:44:27 <audreyt> data SIO a = MkSTM !(STM a) | MkIO !(IO a) | MkSIO !a
23:44:33 <audreyt> but that of course cannot unify ST
23:44:38 <Heffalump> you can't existential it away?
23:44:39 <edwardk> crap like that, made me feel like coding in c++ without typedef
23:44:54 <edwardk> heff: not without an efficiency impact
23:45:07 <edwardk> heff: the whole point was a fast datastructure
23:45:11 <audreyt> Heffalump: that would require repeated boxing that can't be optimized away
23:45:52 <Heffalump> ah, yes
23:46:24 <Heffalump> so how do you think the problem should be solved?
23:46:29 <edwardk> but with a class associated type i should be able to associate an appropriate hash with the STM/ST/IO monads and the usage should be transparent
23:46:42 <edwardk> similarly for other data types
23:47:18 <edwardk> then you can just call up a hash and it'll work in the monad you're in.
23:48:16 <edwardk> there are other mutable data structures that a similar approach would be a big win for
23:50:07 * edwardk shrugs. in the meantime i'll continue playing with other stuff.
23:50:07 <Heffalump> With fundeps, if you have class Foo a b | a -> b, does the type checker not understand that if you know a there is only one value for b?
23:50:20 <sjanssen> what will the data decl. for the multi-monad monad hash table look like with associated types?
23:50:27 <Pseudonym> Heffalump: Yes and no.
23:50:32 <edwardk> heff: thats fine, the problem isn't the class, its that i can't use those fundeps to build a type =)
23:50:32 <Pseudonym> It doesn't understand, for example:
23:50:37 <Pseudonym> class Foo a b | a -> b
23:50:46 <Pseudonym> f :: (Foo Int a) => a
23:50:51 <edwardk> heff: i can build classes all day long
23:50:54 <Pseudonym> That's not a valid type for f.
23:51:09 <Pseudonym> Even though it's a concrete type./
23:51:22 <Heffalump> can you have f :: Foo a b => a b ?
23:51:23 <edwardk> Pseudonym: ah interesting. hadn't run into that one.
23:51:46 <edwardk> i know you can have f :: Foo a b => a -> b at least
23:51:47 <Pseudonym> Heffalump: Sure, if that's kind correct.
23:52:09 <edwardk> how does it differ for the single case?
23:52:19 <Heffalump> so the point is that you can't even write class contexts with non-free variables?
23:54:19 <edwardk>  
23:54:19 <edwardk> Wtf.hs:6:0:
23:54:19 <edwardk>     Couldn't match the rigid variable `b' against `Double'
23:54:19 <edwardk>       `b' is bound by the type signature for `f'
23:54:19 <edwardk>       Expected type: Double
23:54:20 <edwardk>       Inferred type: b
23:54:22 <edwardk>     When using functional dependencies to combine
23:54:24 <edwardk>       Foo Int Double, arising from the instance declaration at Wtf.hs:4:0
23:54:26 <edwardk>       Foo Int b, arising from the type signature for `f' at Wtf.hs:5:0-18
23:54:28 <edwardk>     When generalising the type(s) for `f'
23:54:48 <edwardk> so i guess it wants you to explicitly name the type regardless of if its known via fundep
23:55:55 <edwardk> so maybe how fundeps and dictionary passing work together needs to be looked at?
23:56:20 <edwardk> that should be inferrable
23:58:39 <int-e> It infers Double. Did you give f a more polymorphic type signature?
23:58:47 <edwardk> yeah
23:58:50 <edwardk> Foo Int a
23:58:55 <edwardk> like was suggested
23:59:08 <int-e> f :: (Foo Int a) => a ?
23:59:11 <edwardk> since Foo is fundep'ed a isn't really free despite appearances
23:59:47 <edwardk> @paste
23:59:47 <lambdabot> http://paste.lisp.org/new/haskell
23:59:59 <lisppaste2> edwardk pasted "fundep" at http://paste.lisp.org/display/25310
