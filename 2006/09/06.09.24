00:00:38 <lispy> > fix $ scanl (*) 1.00001
00:00:39 <lambdabot>  [1.00001,1.0000200001000001,1.0000400006000043,1.0000800028000567,1.00016001...
00:00:45 <lennart> > fix $ scanl (^) 2
00:00:50 <lambdabot> Terminated
00:00:52 <vincenz> Anyone here us pmwiki?
00:01:02 <vincenz> s/us/use
00:01:05 <therp> vincenz: yes, not regularly
00:01:06 <lispy> vincenz: no :(
00:01:16 <ThreeQ> take 5 $ fix $ scanl (^) 2
00:01:28 <ThreeQ> > take 5 $ fix $ scanl (^) 2
00:01:32 <lambdabot> Terminated
00:01:38 <lispy> > take 1 $ fix $ scanl (^) 2
00:01:40 <lambdabot>  [2]
00:01:46 <lispy> > take 3 $ fix $ scanl (^) 2
00:01:47 <lambdabot>  [2,4,256]
00:01:50 <ThreeQ> > take 4 $ fix $ scanl (^) 2
00:01:52 <lambdabot>  [2,4,256,3231700607131100730071487668866995196044410266971548403213034542752...
00:01:57 <lispy> nice!
00:01:59 <vincenz> therp: good, question about it... I'm getting spam on my guestbook.  It is using the format for the entries, so at first I thought they were spamming that funcitonality.  The webpage is write-protected except for guestbook.  I have since removed the guestbook-functionality from said page, and I'm still getting spam.  Checking in the history, it's not even in there, so I think I'm getting hacked there
00:02:05 <vincenz> therp: any clues?
00:02:08 <lispy> > join (^) 256
00:02:09 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
00:02:24 <lennart> get's kinda big :)
00:03:24 <dolio> Heh.
00:03:26 <therp> vincenz: no sorry, I'm not that intimate with pmwiki
00:03:30 <lispy> > take 1 $ fix $ scanl (\x -> x ^ (x ^ x)) 2
00:03:30 <vincenz> :/
00:03:31 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
00:03:31 <lambdabot>    Expe...
00:03:38 <ThreeQ> > take 3 $ fix $ (2:) . scanl (^) 2
00:03:39 <lambdabot>  [2,2,4]
00:03:49 <ThreeQ> > take 5 $ fix $ (2:) . scanl (^) 2
00:03:50 <lambdabot>  [2,2,4,16,65536]
00:04:07 <ThreeQ> > fix $ (2:) . scanl (*) 2
00:04:08 <lambdabot>  [2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269013...
00:04:27 <ThreeQ> > fix $ (2:) . scanl (*) 3
00:04:28 <lambdabot>  [2,3,6,18,108,1944,209952,408146688,85691213438976,34974584955819144511488,2...
00:04:40 <lispy> > take 1 $ fix $ scanl (\x y -> x ^ (y ^ y)) 2
00:04:41 <lambdabot>  [2]
00:04:47 <lispy> > take 2 $ fix $ scanl (\x y -> x ^ (y ^ y)) 2
00:04:48 <lambdabot>  [2,16]
00:05:01 <lispy> > take 3 $ fix $ scanl (\x y -> x ^ (y ^ y)) 2
00:05:02 <lennart> > fix $ ([2,2,2,2]++) . scanl (*) 2
00:05:06 <lambdabot> Terminated
00:05:06 <lambdabot>  [2,2,2,2,2,4,8,16,32,64,256,2048,32768,1048576,67108864,17179869184,35184372...
00:06:15 <lennart> getting into ackermann territory :)
00:07:11 * lispy tries it locally
00:07:38 <dolio> ?type scanl
00:07:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:07:44 <lispy> ?hoogle fix
00:07:45 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
00:07:45 <lambdabot> Control.Monad.Fix :: module
00:07:45 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
00:08:10 <dolio> > 16^(16^16)
00:08:14 <lambdabot> Terminated
00:08:15 <lennart> do the 3 argument ackermann function, ack x 1 y = x+y; ack x 2 y = x*y; ack x 3 y = x^y; ...
00:08:20 <dolio> > 16^16
00:08:21 <lambdabot>  18446744073709551616
00:08:29 <lispy> hahah
00:08:34 <lispy> it's not terminating...
00:08:47 <dolio> That's going to take forever.
00:08:52 <lispy> even though i'm hitting ctrl+c
00:08:58 <dolio> Heh.
00:10:02 <lispy> lug
00:10:03 <lispy> oops
00:12:34 <Stinger_> lispy ghc windows?
00:12:44 <dolio> ?pl \n -> fix $ scanl (const ((/2) . ap (+) (n/))) 1
00:12:44 <lambdabot> fix . flip scanl 1 . const . ((/ 2) .) . ap (+) . (/)
00:13:05 <dolio> > fix . flip scanl 1 . const . ((/ 2) .) . ap (+) . (/) $ 3
00:13:07 <lambdabot>  [1.0,2.0,1.75,1.7321428571428572,1.7320508100147274,1.7320508075688772,1.732...
00:13:15 <dolio> > fix . flip scanl 1 . const . ((/ 2) .) . ap (+) . (/) $ 4
00:13:16 <lambdabot>  [1.0,2.5,2.05,2.000609756097561,2.0000000929222947,2.000000000000002,2.0,2.0...
00:13:21 <dolio> > fix . flip scanl 1 . const . ((/ 2) .) . ap (+) . (/) $ 5
00:13:23 <lambdabot>  [1.0,3.0,2.3333333333333335,2.238095238095238,2.2360688956433634,2.236067977...
00:14:29 <lispy> Stinger_: no, debian
00:14:31 <lispy>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
00:14:32 <lispy> 27601 dagit     25   0  920m 646m  32m R 96.8 64.5   0:47.95 ghc-6.4.2
00:15:09 <lispy> it's amazing how much memory it needs
00:17:04 <lispy> > (fix . flip scanl 1 . const . ((/ 2) .) . ap (+) . (/)) 5 !! 100
00:17:05 <lambdabot>  2.23606797749979
00:17:13 <lispy> > sqrt 5
00:17:15 <lambdabot>  2.23606797749979
00:17:37 <ThreeQ> > fix (([1]:) . scanl (++) [0])
00:17:38 <lambdabot>  [[1],[0],[0,1],[0,1,0],[0,1,0,0,1],[0,1,0,0,1,0,1,0],[0,1,0,0,1,0,1,0,0,1,0,...
00:18:43 <lispy> > map length $ groupBy (== ) $ fix (([1]:) . scanl (++) [0])
00:18:48 <lambdabot> Terminated
00:18:55 <lispy> > take 10 $ map length $ groupBy (== ) $ fix (([1]:) . scanl (++) [0])
00:18:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
00:19:07 <lispy> that doesn't seem right
00:19:14 <ThreeQ> > fix (([[],[]]:) . scanl (++) [[]])
00:19:15 <lambdabot>  Add a type signature
00:19:27 <lispy> > take 10 $ map length $ map (groupBy (==)) $ fix (([1]:) . scanl (++) [0])
00:19:29 <lambdabot>  [1,1,2,3,4,7,10,17,26,43]
00:19:39 <ThreeQ> > fix (([[],[]]:) . scanl (++) [[]]) :: [[[Int]]]
00:19:40 <lambdabot>  [[[],[]],[[]],[[],[],[]],[[],[],[],[]],[[],[],[],[],[],[],[]],[[],[],[],[],[...
00:19:47 <lispy> ah, i was hoping we'd see a fibonacci sequence
00:20:17 <Stinger_> probably is almost
00:20:31 <glguy> > take 10 $ fix (([]:).scanl (++) [[]])
00:20:31 <lambdabot>  Add a type signature
00:20:39 <glguy> > take 10 $ fix (([]:).scanl (++) [[]]) :: [[()]]
00:20:40 <lambdabot>  Couldn't match `()' against `[a]'
00:20:43 <lispy> > take 10 $ map (groupBy (==)) $ fix (([1]:) . scanl (++) [0])
00:20:44 <lambdabot>  [[[1]],[[0]],[[0],[1]],[[0],[1],[0]],[[0],[1],[0,0],[1]],[[0],[1],[0,0],[1],...
00:20:47 <glguy> > take 10 $ fix (([]:).scanl (++) [()]) :: [[()]]
00:20:48 <lambdabot>  [[],[()],[()],[(),()],[(),(),()],[(),(),(),(),()],[(),(),(),(),(),(),(),()],...
00:21:04 <glguy> > take 10 $ fix (([()]:).scanl (++) [()])
00:21:06 <lambdabot>  [[()],[()],[(),()],[(),(),()],[(),(),(),(),()],[(),(),(),(),(),(),(),()],[()...
00:21:14 <glguy> > take 10 $ map length $ fix (([()]:).scanl (++) [()])
00:21:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
00:21:23 <glguy> there you go :-p
00:22:14 <lispy> #haskell is brought to you today by scanl and fix!
00:22:26 <lispy> heh, nice
00:22:31 <glguy> this program was brought to you by the language C and the number F ;)
00:23:46 <lispy> i shall conclude that fix is neat
00:35:43 <pierre-> haskell.org down again?
00:36:13 <lispy> pierre-: ya
00:36:29 <lispy> pierre-: it's a good weekend for it
00:44:30 <Stinger_> fix hurts my brain :P
00:53:28 <therp> no, fix is beautiful, the only one instance of computational trouble without self-reference
01:00:31 <lispy> therp: what do you mean?
01:03:55 <therp> lispy: I just recognized that this was a bit brief. If there wouldn't be fix, lambda calculus would be a "straight-forward" (in terms of termination) deduction scheme. In most other examples where uncomputability/undecidability arises you have some kind of self-reference, like in "set of all sets that do not include itselfs", or for the halting problem you have to have a programming handing itself to the halting decision function
01:03:56 <therp> to just do the opposite, here again a self-reference. "fix" is the only instance I have seen so far where no explicit self-reference is necessary to cause uncomputability issues
01:04:51 <therp> that is just a random observation.. but I found fix to be a bit different from the others.
01:04:52 <lispy> hmm...
01:05:19 <lispy> even though we said, fix f = f (fix f)
01:05:26 <lispy> doesn't that reference itself?
01:05:53 <therp> lispy: that's a law we require fix to hold. but it's not part of fix itself, I think
01:06:42 <lispy> hmmm
01:06:46 <lispy> i'll think about this more
01:06:49 <Stinger_> how would you define it without referencing itself then?
01:06:55 <ThreeQ> what would be another way to define fix then?
01:07:09 <therp> stinger: the Y combinator doesn't reference itself. just a sec.
01:07:46 <therp> http://en.wikipedia.org/wiki/Y_combinator - here haskell curry's variant
01:08:21 <therp> wasn't there a recent posting on planet haskell about fix containing just this definition?
01:10:29 <ThreeQ> haskell's type checker seems to have trouble with the y combinator
01:10:35 <dons> [ghc head] Shall I pull this patch? (1/218)
01:10:57 <therp> threeq: http://r6.livejournal.com/95963.html - here is more
01:10:58 <lambdabot> Title: r6: Y Combinator in Haskell
01:10:59 <dons> ThreeQ: no, the simplifer loops simplifying it
01:11:32 <dons> iirc.. details in the 'known bugs and infelicities' sectoin of the ghc user's guide
01:11:44 <lispy> heh
01:11:45 <lispy>     Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
01:11:45 <lispy> where:
01:11:48 <lispy>     L =
01:11:50 <lispy> ah
01:12:03 <lispy> L = \abcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
01:12:09 <therp> lispy :)
01:12:29 <therp> just seen that too
01:13:00 <therp> lisp in small pieces has an exercise in chapter 2 that asks the reader to determine whether the given expression is a fixed point combinator or not
01:13:10 <therp> that was a hard one :)
01:13:22 <lispy> i bet
01:13:42 <therp> lispy: is your nick somehow related to lisp btw?
01:15:12 <lispy> therp: yes
01:15:22 <Stinger_> no way :)
01:15:35 <lispy> therp: i used to program a lot more lisp
01:15:44 <lispy> therp: but then i learned about static type checking...
01:15:55 <lispy> therp: i haven't done much lisp since
01:16:19 <therp> lispy: i recently start thinking about whether ghc could be modified to read a lisp-like syntax (sexps) via another frontend
01:16:39 <therp> lispy: same here. CL before, learning about typing, now more interested in haskell
01:18:00 <lispy> therp: you'd like ghc to type check your lisp or you want to compile it for other reasons?
01:18:27 <lispy> therp: i see some problems with using ghc to generate code...with type checking i'm not sure but it seems problematic too
01:18:38 <therp> lispy: I want a haskell with a more lisp like input syntax, as the only thing that turns me of is syntax sugar
01:18:52 <lispy> therp: did you know both sbcl and cmucl can do type inference, but they exploit it more for code generation than error checking?
01:19:02 <lispy> ah
01:19:36 <lispy> i go back and forth about syntax
01:19:44 <therp> lispy: I know, but I want static typing for other reasons, iirc the correct term would be (perferably strong) normalizing code.
01:19:49 <lispy> lisp was nice in that you don't have to know anything to parse it
01:20:04 <lispy> but, i think haskell becomes a bit more readable in practice
01:20:29 <therp> maybe
01:21:26 <therp> but the merits of sexps don't come from readibility alone, but from macro transformations. I'm more interested whether that would be possible
01:21:40 <lispy> ah
01:21:44 <lispy> yes
01:21:50 <therp> the power of lisp imho rests mainly with its macro facility/meta programming capabilities
01:22:00 <lispy> therp: have you looked into the work that has been done with template haskell?
01:22:00 <therp> I have seen template haskell, but that's not a good approach imho
01:22:20 <therp> yes, but it feels even more unnatural with that curly brackets and dollars over the code
01:23:01 <lispy> i found the top level splice restriction to be unweildy
01:23:26 <lispy> also, i wanted to write code walkers for a module not just piece of a syntax tree
01:23:34 <lispy> but, you can't refiy a module
01:23:40 <therp> true
01:24:19 <therp> so that's why the idea of lisp syntax for haskell pops up. actually lisp syntax just means full-parenthesized dump/reading of the AST.
01:24:36 <lispy> yes
01:25:11 <therp> I was about to look at the developer docs of ghc today, but haskell.org is down at the moment.. and I haven't found it in the ghc-src tarball yet..
01:28:36 <therp> ah it's called ghc commentary
01:40:00 <roconnor> >  fix $ scanl (const ((/2) . ap (+) (2/))) (1::Rational)
01:40:02 <lambdabot>  [1%1,3%2,17%12,577%408,665857%470832,886731088897%627013566048,1572584048032...
01:40:59 <dons> mmm
01:41:19 <dons> so what do we call this? (/2) . ap (+) (2/)
01:41:31 <dons> looks like a nice candidate for the @pl-found combinator list
01:44:30 <Cale> It's a rational function
01:46:20 <Bourbaki> moin
01:46:44 <Cale> (\x -> 1/x + x/2) seems clearer to me :)
01:47:56 <Bourbaki> moin ski
01:49:11 <sieni> therp: how would macros be useful in haskell? since you have lazy evaluation, you can define many things that need macros in scheme or lisp as regular functions (e.g. if-then-else, &&, ||)
02:03:44 <foxy> > mdo { x <- (x,"is","false") }
02:03:44 <lambdabot>  Parse error
02:04:38 <foxy> @help
02:04:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:05:19 <foxy> @hoogle mdo
02:05:20 <lambdabot> No matches found
02:05:28 <Cale> foxy: mdo is syntax
02:05:41 <Cale> You'll find a description in the GHC user's guide
02:05:49 <foxy> > mdo { x <- return (x,"is","false") }
02:05:50 <lambdabot>  Parse error
02:05:57 <Cale> that's a type error too
02:06:29 <foxy> why is it a parse/type error?
02:06:45 <Cale> It would lead to an infinite type
02:06:57 <Cale> a = (a, [Char], [Char])
02:07:42 <Cale> It's a parse error because dons doesn't have mdo in his preparser
02:08:06 <Cale> The bot parses everything before passing it to ghc to prevent code injection attacks
02:10:42 <foxy> @paste
02:10:42 <lambdabot> http://paste.lisp.org/new/haskell
02:11:23 <lisppaste2> foxy pasted "mdo" at http://paste.lisp.org/display/26613
02:11:36 <foxy> why does this not parse (at '<-')
02:13:22 <lisppaste2> foxy annotated #26613 with "added return" at http://paste.lisp.org/display/26613#1
02:16:49 <Cale> It does?
02:17:19 <Cale> It's the monomorphism restriction
02:18:04 <Cale> If you give a typesignature to test, or use -fno-monomorphism-restriction, you won't get the error about an ambiguous type variable
02:18:42 <dons> google's posted about their icfp results, http://googleresearch.blogspot.com/2006/09/and-awards-go-to.html
02:18:46 <lambdabot> Title: Official Google Research Blog: And the Awards Go To ..., http://tinyurl.com/mandj
02:18:54 <dons> and that the winning team did use haskell.....
02:18:56 <dons> yay!!
02:19:16 <Bourbaki> moin dons
02:19:27 <dons> dons-- must reply to email!
02:20:55 <Bourbaki> hehe :) i by now guess that the idea isnt so good as i though so itd suffice to qickly look at it
02:31:42 <astrolabe> ha  'assembler is not too shabby'   :)
02:32:44 <vincenz> dons++
02:34:47 <dons> heh, this guy reckons one of the tricks for getting an article to the top of reddit.com's list is to ensure it talks about haskell! http://blog.brettkelly.org/?p=168
02:34:49 <lambdabot> Title: blog.brettkelly.org Â» How To Get Up-Mods at Reddit
02:35:11 <dons> of course "Mention Paul Graham anywhere in the post title - this is by far the most effective option"
02:35:21 <vincenz> dons: which reddit?/
02:35:29 <dons> I assume programming.*
02:38:26 <foxy> This sentence, which has twelve words, is both semantically and syntactically self-referential.
02:39:08 <vincenz> I recently got started on reddit
02:39:11 <vincenz> gotta admiit
02:39:15 <vincenz> much more interesting than /.
02:39:21 <vincenz> slashdot is a lot of useless spam
02:40:04 <dons> yeah, I agree.
02:40:20 <dons> reddit is somewhere between LtU and Slashdot, i think
02:43:55 --- mode: ChanServ set +o dons
02:44:27 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/", "Haskell - the language of ICFP winners 3 years running"]' by dons
02:44:33 --- mode: ChanServ set -o dons
02:44:38 <dons> haskell.org is back up ... :)
02:47:58 <foxy> dons, is there a reason that 'bot doesn't parse 'mdo' ?
02:48:17 <dons> yeah, it uses Language.Haskell, which is an h98-only parser
02:48:30 <foxy> ah
02:48:42 <dons> we'd need to use a haskell parser that supported mdo (or other glasgow exts)
02:50:34 <foxy> is there a way to define datatypes for lambdabot?
02:50:40 <foxy> (at the user level)
02:51:37 <dons> not yet.
02:51:45 <dons> it would be possible, i've a prototype that works
02:51:51 <vincenz> dons: I agree :)
02:52:01 <dons> but for one you can always encode the fix point with a new type
02:52:05 <dons> causing ghc to diverge...
02:52:19 <dons> so i'd need to add a halting mechanism to wrap ghc with
02:52:43 <foxy> couldn't you just check for programs that don't terminate!?
02:52:46 * foxy ducks
02:52:59 <foxy> 8)
02:53:15 <bartw> hehe
02:53:16 <dons> I could check yeah. but that'd keep me busy , and I want to finish my phd one day
02:53:48 <foxy> maybe we should ban you from #haskell until you've submitted
02:54:01 <dons> boo
02:54:19 <dons> no, irc doesn't drain my time. things are progressing pretty well.
02:54:57 <foxy> bringert helped me solve my conjunction problem, now I just need a way to load polymorphic types at run-time...
02:55:01 <dons> i just switched my console to use Verdana anti-alised font, mmm. everything looks so pretty now.
02:55:08 <vincenz> )
02:55:18 <dons> foxy: hmm. interesting.
02:56:39 <foxy> I've been looking at the GHC source code, it seems that it would be reasonable to typecheck an expression, get type, wrap type + hvalue, then do type-checking at run-time and unwrap with cast :: a -> Type -> b
02:57:17 <dons> right, so take a full type rep (like that in the .hi file), wrap it with an HValue, and then what, call ghc-api to actually check the splic epoint at runtime/
02:57:27 <dons> (roughly how i've thought to do it)
02:57:30 <foxy> yeah
02:58:50 <foxy> I think there's an issue about 'Type' being a programmer guarantee and not actually checkable
02:59:05 <dibblego> ?type map
02:59:06 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:59:17 <foxy> i.e. in a -> Type -> b, if the programmer makes a mistake Type might not be the same as b
03:03:28 <foxy> I think the important thing is that (Dynamic $ Dynamic) (i.e. (a -> b) b) is fully type-checkable, so dynamic application is no problem, it's just getting the function/value out of dynamic land into static code that is problematic.
03:03:41 <foxy> Can you get the type-representation of a function using TH?
03:04:29 <foxy> s/(a -> b) b/(a -> b) a/
03:07:53 <vincenz> woah
03:08:02 <vincenz> dons: want to read a message that starts as interesting but slowly turns into trollbait?
03:08:06 <vincenz> they're bashing haskell
03:08:23 <vincenz> I agree with his point of view, but then he sells CL as the end all be all, being somewhat hypocritical
03:08:26 <vincenz> http://groups.google.com/group/comp.lang.lisp/msg/28cb9d4217fe6dc3?dmode=source
03:08:29 <lambdabot> Title: Google Groups: comp.lang.lisp, http://tinyurl.com/ooj3h
03:09:29 <vincenz> bit old but it was on reddit
03:12:57 <foxy> @type (.)
03:12:59 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
03:13:35 <foxy> @type flip (.)
03:13:36 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
03:13:39 <arcatan> everybody _loves_ those _underscores_
03:15:49 <foxy> arcatan = x - x^3/3 + x^5/5 - x^7/7 + ...
03:16:11 <dons> i think it rapidly turns into troll bait, if its the one i think it is...
03:16:16 <deadbeef> hi dear friends
03:16:17 <deadbeef> sup
03:16:26 <dons> hey deadbeef
03:16:33 <deadbeef> hi dons
03:16:35 <dons> vincenz: yeah, that's the one.
03:16:46 * vincenz nods
03:16:53 <foxy> what task does the guy think Haskell is designed for?
03:16:58 <vincenz> dons: he makes some valid points early on, then abuses them to claim that CL solves them all
03:17:03 <vincenz> dons: I hate language zealots like that
03:17:03 <dons> sounds like the lispers are getting titchy about things...
03:17:07 <vincenz> I was having the same discussion
03:17:11 <vincenz> in #squeak
03:17:15 <vincenz> saying how every language has a niche
03:17:20 <vincenz> they disagreed
03:17:30 <qz> what is haskell niche?
03:17:42 <vincenz> algorithmical/compiler oriented I'd say
03:17:44 <dons> writing programs?
03:17:49 <dons> winning the icfp contest?
03:17:50 <foxy> qz: beautiful programs
03:17:58 <vincenz> foxy: that's zealoutous
03:18:00 <dons> writing haskell compilers?
03:18:01 <qz> foxy, nah
03:18:12 <vincenz> dons: no seriously, haskell isn't good at everything
03:18:14 <qz> dons, writing haskell compilers in haskell? nice niche.
03:18:21 <dons> sure, i agree. but this is #haskell :)
03:18:21 <vincenz> dons: I wouldn't write a dynamic system in haskell, nor a business app or a web-service
03:18:27 <dons> I don't think its a niche language
03:18:31 <vincenz> niche is the wrong word
03:18:36 <dons> its a general purpose language
03:18:39 <vincenz> every language has a problem domain it's more expressive at
03:18:42 <dons> so it solves a wide range of things nicely
03:18:44 <vincenz> (pareto-optimal languageS
03:18:48 <dons> but not everything, of course
03:18:52 <vincenz> right but every general purpose language has a flavour
03:18:58 <vincenz> it's a multi-objective problem space
03:19:01 <vincenz> that has inherent tradeoffs
03:19:10 <vincenz> haskell is defintely on the pareto curve
03:19:15 <dons> yeah, people have argued that 'structure hacking' was haskell's area.
03:20:19 <qz> haskell is really useful for twisting mind in free time ;)
03:20:53 <dons> yeah, its a fun irc language :)
03:21:01 * vincenz grins
03:21:10 <vincenz> haskell is great tool for writing analysis tools and compilers and such
03:21:18 <vincenz> ...great language
03:21:24 <dons> you have to have certain characteristics to be a good irc language: brevity, safety, expressiveness
03:21:26 <qz> how many compilers are written in haskell?
03:21:32 <qz> except haskell compilers
03:21:32 <vincenz> my compileris
03:21:38 <dons> so that it can fit on a single line, be safe, and be able to solve useful things
03:21:45 <dons> qz, hmm, 100s?
03:21:47 <vincenz> it compiles a miniml, type-inference et al
03:21:50 <dons> i've written 3
03:22:00 <dons> lots and lots of research compilers are written in haskell
03:22:06 <qz> dons, i'm not talking about homebrew "compilers" for own "languages"
03:22:19 <vincenz> qz: heh... then most compilers are written in C
03:22:20 <qz> i'm talking about production quality compilers that are actually useful
03:22:24 <qz> vincenz, yeh :|
03:22:32 <vincenz> so that's hardly a valid mesure
03:22:35 <vincenz> measure
03:22:39 <dons> ah, real world. hmm, pugs (perl6), epigram, ghc, nhc, yhc, jhc, helium, ..
03:22:41 <Cale> qz: But Haskell is *good* at it.
03:22:44 <qz> what makes haskell good for writing compilers?
03:22:46 * vincenz nods at Cale 
03:22:51 <ValarQ> vincenz: usefull compilers that isn't haskell compilers?
03:22:53 <dons> qz, pattern matching
03:23:03 <qz> dons, alright. anything else?
03:23:06 <ValarQ> er, that was aimed for qz...
03:23:06 <vincenz> qz: I personally think it's the strong typing that leads to less bugs, and then pattern matching as dons mentions
03:23:12 <vincenz> as well as higher ordered data types
03:23:16 <vincenz> they're great for buildign similar AST types
03:23:21 <dons> strong typing, exhaustive case analsysi, and first class data :)
03:23:39 <foxy> I think pugs is a real coup for haskell ("Haskell, the language _behind_ perl")
03:23:42 <Cale> not to mention the nice parsing libraries :)
03:23:47 <qz> what about ml, it has similar properties?
03:23:53 <vincenz> qz: it does, I used to use ocaml
03:24:00 <dons> similar, but its a bit older, and lacks some modern features
03:24:00 <vincenz> qz: however it is simply less expressive in certain areas
03:24:06 <vincenz> qz: and it has some warts
03:24:23 <qz> i think that haskell is nice proof-of-concept. like showing that pure-fp can be actually useful
03:24:24 <vincenz> a) no first class data-cons, b) less support for higher ordered types, c) no monads
03:24:32 <dons> haskell is a child of ML, and learnt from its mistakes
03:24:38 <vincenz> those would be the main problems with ML in my pov
03:24:43 <qz> what kind of mistakes?
03:24:50 <vincenz> a) no first class data-cons, b) less support for higher ordered types, c) no monads
03:24:53 <dons> syntax :)
03:24:56 <qz> heh
03:24:57 <Cale> qz: those which vincenz just listed
03:25:03 <Cale> and yeah, syntax
03:25:09 <foxy> using :: for cons
03:25:12 <vincenz> I don't mind ocaml syntax so much
03:25:22 <vincenz> I'm still using it for my tool
03:25:26 <vincenz> haskell's sadly too slow for that :/
03:25:33 <dons> i'm still surprised...
03:25:38 <vincenz> yeah well
03:25:41 <dons> if you baited me some more, i'd even have a look at it ...
03:25:54 <vincenz> it's proprietary
03:25:59 <dons> ah well
03:26:06 <vincenz> the main problem was allocation in readword8
03:26:08 <vincenz> which makes no sense
03:26:19 <dons> and the solution is to read blocks of bytestrings
03:26:20 <vincenz> I got a 58% allocation count in that function alone
03:26:27 <dons> as we suggested yesterday
03:26:44 <qz> is there a list of compilers implemented in haskell somewhere?
03:26:46 <dons> you don't want to allocate and lock on every single byte.
03:26:50 <vincenz> dons: true, but then I'll most likely hit lazyness in the butt somewhere else
03:26:53 <qz> i'd like to take a look at source for few
03:26:54 <vincenz> dons: it's too much effort
03:27:04 <dons> vincenz: there's no reason to think that.
03:27:17 <vincenz> `seq` ...
03:27:27 <dons> something like Data.byteString.lazy should just work. (I shouldn't have show you that getWord8 it seems...)
03:27:37 <vincenz> I mean in other areas of the program
03:27:43 <vincenz> for instance the centralized state
03:27:52 <Cale> vincenz: what kind of computation is it doing?
03:27:55 <dons> works fine in yi, hmp3, ...
03:28:06 <dons> state is no problem, why would it be one?
03:28:15 <vincenz> Cale: a lot of hashmap-stuf
03:28:29 <dons> hashes could be an issue, if they're mutable 9/)
03:28:33 <vincenz> dons: case if you don't spend time profiling etc...you won't know where to `seq`
03:28:55 <vincenz> not to mention that fps makes it harder for me to distribute the tool
03:29:02 <vincenz> I have people in several affiliated universities using it
03:29:02 <Cale> A lot of it is kind of obvious though.
03:29:19 <Cale> (where to put seqs)
03:29:35 <vincenz> ghc 6.6 will solve that
03:29:39 <vincenz> but ghc 6.6 is a bit late in the game for me
03:29:45 <vincenz> especially before it becomes a std package
03:30:32 <dons> anyway, i'd start with Data.ByteString.Lazy, if you want C speed for sucking in gigabytes. it's the only sane option
03:30:38 <vincenz> yeah I know
03:30:45 <vincenz> but since I'm not the only one using the tool
03:30:55 <vincenz> I'd rather keep the dependencies on extra things to fiddle and install low
03:31:03 <dons> yep
03:31:23 <vincenz> sorry :/
03:31:25 <dons> (you could of course include the bytestring source (4 files) in your code)
03:31:41 <vincenz> dons: it's partially c...
03:32:11 <vincenz> not sure how well that'd go on windows
03:32:19 <dons> hmm?
03:35:27 <foxy> @hoogle trace
03:35:28 <lambdabot> Debug.Trace.trace :: String -> a -> a
03:35:29 <lambdabot> Debug.Trace :: module
03:35:29 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
03:37:18 <vincenz> dons: btw, for bytestring, hGetContents gets the file lazily from a handle
03:37:22 <vincenz> dons: when yo do close the handle then?
03:38:05 <dons> it goes into a semi closed state, and on eof is closed
03:38:13 <dons> like normal lazy Handle reads
03:38:13 <vincenz> oh right
03:38:43 * vincenz does a quick epxeriment
03:38:54 <vincenz> can I close it earlier ?
03:39:13 <dons> you can hClose, yep
03:39:20 <dons> you can strict read if you want too
03:39:24 <vincenz> what happens to the bytestring then?
03:39:26 <vincenz> if you close it
03:39:55 <dons> like normal lazy IO, if you close it before demanding all of it, you get what you've demanded
03:40:12 <vincenz> alriht
03:40:13 <vincenz> thanks
03:40:21 * vincenz hasn't used lazy io yet
03:41:28 <dons> vincenz: you might be interested in http://www.imperialviolet.org/binary/bitsyntax/BitSyntax.hs
03:41:30 <lambdabot> http://tinyurl.com/ewusf
03:41:37 <dons> for nicely pulling binary data from bytestrings
03:42:08 <dons> looks interesting, anyway
03:42:41 <vincenz> :)
03:43:03 <vincenz> dons: btw, for taking and dropping
03:43:14 <vincenz> some way of doing both at the same time?
03:43:20 <vincenz> on a LBS
03:43:48 <vincenz> nm
03:44:41 <dons> break? splitAt? let substring n m = take n (drop m) -- ?
03:45:00 <vincenz> > let f (h@(_:_:_:_):t = h in f [1..10]
03:45:00 <lambdabot>  Parse error
03:45:04 <vincenz> > let f (h@(_:_:_:_):t) = h in f [1..10]
03:45:04 <lambdabot>  add an instance declaration for (Num [a])
03:45:05 <lambdabot>   In an arithmetic sequence: [1...
03:45:53 <vincenz> dons: basically I'm often getting 2-4 bytes from the top and then advancing obviously
03:45:56 <vincenz> (gonna use a MonadState for that)
03:46:20 <vincenz> (or would MonadState be a bad idea?)
03:46:42 <dons> might even just thread the value explicitly. not sure how your app works.
03:46:52 <vincenz> would be annoying
03:47:02 <vincenz> I have a rathre large case expression
03:47:05 <vincenz> on the header of a packet
03:47:16 <vincenz>   case log_type of
03:47:16 <vincenz>     0 -> return VarRead           `ap` next32 `ap` next32 `ap` next32
03:47:22 <vincenz> this is the current system with the IO monad
03:47:34 <vincenz> there's a bunch of these lines
03:47:43 <dons> does next32 read from the Handle?
03:47:46 <vincenz> yeah
03:47:55 <vincenz> next32 = getWord32 h
03:48:12 <dons> so it would be maybe 1000x faster to read the next 4 bytes off a bytestring in the state monad :)
03:48:12 <vincenz> the idea is to make a state monad
03:48:37 <vincenz> so what would be the fastest function to take off a few bytes
03:48:46 <dons> take 4 s
03:48:47 <vincenz> and keep the remainder
03:48:54 <dons> splitAt 4 s
03:48:54 <vincenz> no cause that requires two traversals
03:49:05 <vincenz> which allocs a tuple
03:49:13 * vincenz ponders
03:49:20 <dons> you could just return the int offsets
03:49:51 <vincenz> we're talking 2GB read in portions of 16 and 32 bytes
03:49:52 <dons> store an offset and a bytestring in the state?
03:50:11 * vincenz coughs
03:50:15 <vincenz> 2-4 bytes
03:50:17 <dons> i'd imagine you'd do it the same as you would in C
03:50:17 <vincenz> 16-32 bits
03:50:21 <dons> how would you do it in C?
03:50:32 <dons> or OCaml?
03:50:39 * vincenz checks
03:50:42 <vincenz> been a while since I wrote that
03:51:03 <vincenz> in ocaml I just read bytes from the file
03:51:08 <vincenz> I'd do the same in C
03:51:11 <vincenz> they have internal buffering
03:51:28 <dons> right, like a lazy bytestring I suppose
03:51:41 <dons> it's pulling in buffers of 32 k at a time, as you require them
03:51:51 * vincenz nods
03:51:55 <dons> i don't see what the problem with just doing a 'take' on that is?
03:51:56 <vincenz> so the magic number is 32k?
03:52:04 <vincenz> dunno
03:52:06 <vincenz> drop 4
03:52:07 <dons> that's how stepcut does his debian package parser
03:52:08 <vincenz> take 4
03:52:08 <vincenz> drop 4
03:52:10 <vincenz> take
03:52:24 <vincenz> I'll try it
03:52:45 <dons> splitAt is pretty quick, btw,
03:52:46 <dons> splitAt n ps@(PS x s l)
03:52:46 <dons>     | n <= 0    = (empty, ps)
03:52:46 <dons>     | n >= l    = (ps, empty)
03:52:46 <dons>     | otherwise = (PS x s n, PS x (s+n) (l-n))
03:53:00 <vincenz> that's a tuple alloc
03:53:04 <vincenz> on each call
03:53:13 <vincenz> meaning 1G tuple allocs for nothing
03:53:28 <dons> hmm... how do you know ghc doesn't clean it up?
03:53:34 * vincenz shrugs
03:53:47 <dons> once you access do something with the 2nd part, it can be thrown away
03:53:58 <dons> i think you're over estimating the effect of laziness
03:54:10 <dons> bytestrings are mostly strict
03:54:22 <vincenz> I'll use drop and take
03:54:26 <dibblego> ?index Maybe
03:54:27 <lambdabot> Data.Maybe, Prelude
03:55:04 <dibblego> can you get a URL to the reference from lambdabot ?
03:55:20 <dons> hmm?
03:55:34 <dons> ?source Data.Maybe
03:55:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
03:55:36 <dibblego> like ?blah Maybe will give me the URL to Maybe
03:55:42 <dons> ?docs Data.Maybe
03:55:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
03:55:53 <dons> you want the docs or the source?
03:55:54 <vincenz> dons: and... sorry about being so irritating :P
03:56:01 <dons> no no. its fine :)
03:56:03 <dibblego> the docs
03:56:17 <dons> ?docs Data.Maybe
03:56:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
03:56:18 <dons> then :)
03:56:36 <dibblego> ah thanks
03:58:01 * vincenz sighs at all the ''' in his code
03:59:27 <vincenz> http://rafb.net/paste/results/5iwzdS36.html
03:59:42 <vincenz> that should obviously be LBS.take and LBS.drop
04:00:15 <vincenz> but suggestions against all the ' are welcome :)
04:02:22 <clanehin> when I have several stages of computation and want to name them, I often use x0,x1,x2, and then label the final computation x', although I try not to often do this
04:03:22 * vincenz nods
04:03:47 * vincenz uses splitAt
04:03:53 <vincenz> it's only done once and would obviously clean code here
04:13:26 <vincenz> dons: oh, on a positive note, I talked to my supervisor about giving an introductory session to the power of haskell to coworkers and he was interested in the idea
04:13:29 <vincenz> ;)
04:16:44 <bartw> sounds interrestin
04:16:49 <vincenz> hints from anyone and everyone are welcome
04:17:08 <bartw> reminds me, i still need to give an optimization and assembly presentation to coworkers
04:17:10 <vincenz> I don't think that teaching the language would be a good idea
04:17:21 <vincenz> ideally it would be more a motivational presentation
04:17:23 <qz> vincenz, which task you gonna show power of haskell on?
04:17:26 <vincenz> with a highlighting of some features
04:17:34 <vincenz> qz: compilers and tools
04:18:04 <bartw> vincenz : try to find a usecase that haskell shines in
04:18:18 <vincenz> bartw: not sure abot that
04:18:20 <qz> qsort? :)
04:18:22 * qz giggles
04:18:35 <vincenz> bartw: the problem with a usecase is that you easily get lost in details
04:18:41 <mux> I'd say the qsort example is not good at al
04:18:49 <bartw> thats true..
04:18:57 <qz> mux, yeh. but every time haskell is mentioned, there's that qsort example
04:19:29 <vincenz> ideally the presentation would lead to a) an interest n haskell, b) a crude understanding
04:20:31 <bartw> hard to both show the power while not needing to explain lazy eval ?
04:21:04 <vincenz> most of the attendees will most likely not be experienced with FP
04:21:19 <bartw> include the example that defines odd and even in terms of the other with the 0 bootstrap
04:21:33 <vincenz> that's a good example to show specific features
04:21:38 <bartw> nice example of infinite lists too
04:21:39 <musasabi> bartw: the ByteString examples might be good.
04:21:39 <vincenz> but hardly motivates it as a choice for the sort of tools they write
04:21:59 <qz> vincenz, what languare are they using?
04:22:02 <bartw> musasabi : do you hve a link ?
04:22:25 <vincenz> qz: I'm guessing C and c++
04:22:37 <vincenz> maybe some perl/python
04:22:41 <bartw> what kinds of applicatons ?
04:22:54 <vincenz> like I said, compilers, optimization tools
04:23:09 <bartw> nice area
04:23:14 <vincenz> yep :)
04:23:16 <Philippa_> mmm, in that case Haskell should go down a treat
04:23:23 <bartw> ye
04:23:29 <vincenz> well yes and no
04:23:31 <bartw> which company is it if i might ask ?
04:23:33 <vincenz> it's how you present it
04:23:35 <vincenz> bartw: imec
04:23:41 * vincenz is in the DESICS team of imec
04:23:46 <qz> is there anything in compilers/optimization tools area that was written in haskell and made it into mainstream?
04:23:51 <vincenz> and specifically in the DT group of designs (design technology)
04:24:02 <vincenz> though I'm on the prealpha team (phd)
04:24:22 <roconnor> They found an ancient stone tablet during excavation in north america: http://www.sciencemag.org/cgi/content/abstract/313/5793/1610
04:24:25 <lambdabot> Title: Oldest Writing in the New World -- del Carmen Rodr&iacute;guez Mart&iacute;nez e ..., http://tinyurl.com/znu88
04:24:26 <vincenz> though the specific group names got shuffled as of late
04:24:36 <roconnor> A block with a hitherto unknown system of writing has been found ...
04:24:44 <Philippa_> presenting it right matters, yeah. But in a lot of places Haskell does The Right Thing for that class of work which is a good start
04:24:47 <roconnor> I bet I know what it is
04:24:51 <roconnor> :D
04:24:52 <musasabi> bartw: dons has the relevant links.
04:25:04 <vincenz> Philippa_: the problem is that if I start beating them senseless with FP is -the- thing, they'll become skeptical
04:25:15 <vincenz> Philippa_: mind you, the main focus in this company is electronics and embedded systems
04:25:38 <bartw> vincenz : i hope to work on exactly that subject in a few years
04:25:53 <vincenz> well it depends on the audience, however the first audience I plan, (5-7 people) have admitted a partial interest
04:26:01 <vincenz> bartw: should look into it then
04:26:01 <Philippa_> you can do it with "looks like -the- thing for a significant class of apps", that doesn't look like an insane claim generally
04:26:06 <vincenz> bartw: you've heard of imec before?
04:26:23 <Philippa_> and hey, it /is/ true that compilers, optimisers and other language manipulation have been the main thing FP's been historically good at
04:26:32 <vincenz> Philippa_: I would rather appeal to their intellect in showing haskell, it's main features and how one might benefit from it
04:26:47 <vincenz> Philippa_: the focus isn't language manipilation
04:26:47 <Philippa_> well yes, you don't tell them it looks like the thing, you show them why
04:26:48 <bartw> vincenz : havn't heard of them before
04:26:56 <vincenz> Philippa_: it's mostly the middle and back end of compilers
04:27:05 <vincenz> bartw: largest institute in europe in that field
04:27:07 <Philippa_> which're still manipulating terms in a language
04:27:08 <vincenz> bartw: www.imec.be
04:27:33 * vincenz thinks
04:27:38 <vincenz> 1500 employeses
04:27:38 <Philippa_> even if it's an IR - but then, not having a concrete syntax makes life easier, not harder
04:28:29 <vincenz> not so much rearranging as more analysis
04:28:32 <bartw> vincenz : i'll thin about it, altough they seem to be the sort of company that is very stricy on educational requirements
04:28:33 <vincenz> Cale: ping
04:28:47 <vincenz> bartw: depends what you want to do
04:28:51 <vincenz> bartw: we've got all sorts of people
04:29:21 <vincenz> bartw: what's your background?
04:29:30 <Philippa_> mmm, I was including analysis under manipulation
04:29:49 <Philippa_> showing our answers to the visitor pattern helps, anyway
04:29:55 <vincenz> Philippa_: in analysis, IR isn't the main issue, but yes, IR manipulation is definitely sellable and that's what I plan to mention
04:30:05 <vincenz> but I'll need more than just patternmatching and data types
04:30:10 <vincenz> IMEC is Europe's leading independent research center in the field of micro- and nanoelectronics, nanotechnology, enabling design methods and technologies for ICT systems.
04:30:13 <vincenz> from the website
04:30:20 <bartw> vincenz : unfinished CS study, hobby compiler projects, working as programmer mostly related to framework design and optimizations
04:30:46 <vincenz> bartw: I'd definitely contact them
04:30:53 <vincenz> bartw: they're mostly looking for motivated people
04:31:11 <vincenz> it's a very nice place to work at :)
04:31:47 <bartw> vincenz : i'll keep it in mind, i have no hurry leaving my current job
04:32:07 <Philippa_> will pattern-matching+datatypes (including allusions to theoretical stuff and properties - catamorphisms, etc etc etc) plus the ease of telling when code doesn't interact make a good start?
04:32:25 <vincenz> bartw: whom do you work for?
04:32:32 <vincenz> Philippa_: oy. forget the catamorphisms and stuff
04:32:36 <Philippa_> they might well go a bundle on the type system if you show them GADTs being used to enforce invariants they couldn't do statically otherwise
04:32:46 <Philippa_> I did say "allusions to" for a reason :-)
04:32:55 <vincenz> Philippa_: forget theory
04:32:59 <vincenz> it's about pragmatics
04:33:05 <vincenz> if I can, I'll even avoid monads
04:33:10 <Philippa_> we're talking FP, they tend to be the same thing
04:33:35 <xerox> haha
04:34:07 <xerox> @remember Philippa <vincenz> Philippa: forget theory, it's about pragmatics <Philippa> we're talking FP, they tend to be the same thing
04:35:15 <Philippa_> what I mean by this is: talk about a "Fold design pattern" or a similar notion. Maybe mention that there's some rather more solid maths involved than in most patterns and this can do shiny things on occasion, but don't use mathematical terms
04:35:52 <Philippa_> they're working in this field, they've /seen/ folds. All over the damn place.
04:36:15 <Bourbaki> moin
04:36:25 <vincenz> Philippa_: seen folds?
04:36:54 <Philippa_> yeah. Not necessarily recognised them as such, but they'll have written them over and over
04:37:12 * vincenz ponders
04:37:17 <Philippa_> most visitors are long-hand ways of writing folds, for example
04:38:43 <Philippa_> parsing combinators're probably worth a show too - but with an additional note that "you can write similar things that work on data structures rather than strings"
04:39:59 <dmhouse> ?where cabal-get
04:40:00 <lambdabot> cabal-get is now cabal-install, and is in Cabal's source tree
04:40:12 <Philippa_> that not only can you, but if you know a little about parsing and have a basic understanding of FP then it's not actually that hard to do.
04:40:13 <dmhouse> ?where cabal
04:40:14 <lambdabot> http://www.haskell.org/cabal
04:40:35 <vincenz> Philippa_: I fear that would aim in the wrong direction
04:40:47 <Philippa_> mmm. What direction do you want to aim in?
04:40:49 <dmhouse> xerox: is your cabal stuff working now, then?
04:40:51 <vincenz> you're thinking too much like a CSer
04:41:00 <xerox> dmhouse: it works for me.
04:41:09 <Philippa_> (see, if I show off parsing combinators, what I'm going to show is "look how readable this parser is!")
04:41:12 <dmhouse> xerox: is there any documentation for it? I want to use it to install Hope.
04:41:16 <xerox> dmhouse: didn't get enough people to try it out yet I think.
04:41:18 <vincenz> Philippa_: I know, wrong problem domain however
04:41:23 <xerox> dmhouse: is Hope cabalized now?
04:41:34 <vincenz> Philippa_: and it's hard to show it's readable unless they know the language
04:41:42 <Philippa_> 'k. What sorts of problems do you think're worth showing solutions to?
04:41:47 <vincenz> Philippa_: my aim is not to teach it, YAHT can do that much better than me
04:41:53 <Philippa_> I've walked people who'd never seen Haskell code before through source
04:41:59 <dmhouse> xerox: oh, not sure, but shapr said your stuff can now 'install everything but Hope itself'.
04:42:00 <xerox> dmhouse: http://darcs.haskell.org/cabal-with-install/
04:42:02 <lambdabot> Title: Index of /cabal-with-install
04:42:19 <vincenz> Philippa_: still trying to flesh that out, to be honest
04:42:25 <vincenz> Philippa_: so brainstorming is good :)
04:43:02 <Philippa_> the "structure parsing combinators" I see as an analysis tool, FWIW. Easy, readable analyses that look like the spec
04:43:40 <xerox> dmhouse: that's right, darcsget it, cd cabal-install, sh test-cabal-install-user
04:43:55 <Philippa_> or sometimes the front-end of an analysis when you munge into another, more appropriate structure, but hey
04:43:55 <vincenz> Philippa_: I'll keep it in miind
04:44:45 <dmhouse> xerox: that's a newer version than my current 1.1.4, I assume?
04:45:01 <xerox> dmhouse: Cabal 1.1.4 is fine to build and use cabal-install I believe
04:45:18 <dmhouse> Do I not need to reinstall my Cabal?
04:45:24 <xerox> Nope, you don't.
04:45:41 <xerox> Also, I think current Cabal Makefile nastily tries to build cabal-install in the wrong way.
04:45:54 <dmhouse> Okay, so I'll just follow what you said.
04:45:57 <xerox> (Resulting to a broken makefile...)
04:55:00 <vincenz> damn
04:55:03 <vincenz> that was some awful lag
04:58:21 <dmhouse> So what web platforms are available for Haskell?
04:59:36 <dmhouse> HAppS, Hope...? I'm sure there are a couple I've forgotten.
05:01:19 <vincenz> wash?
05:03:07 <dmhouse> http://justasloud.org/2006/haskell/ interesting post.
05:04:04 <integral> "developed at MIT"?
05:06:03 <dmhouse> integral: heh, I missed that. Leave a comment.
05:19:46 <dmhouse> xerox: ping
05:20:17 <xerox> Pong.
05:20:59 <lisppaste2> dmhouse pasted "cabal-install install failure" at http://paste.lisp.org/display/26627
05:21:02 <bartw> @yar
05:21:03 <lambdabot> Where d' all t' pirates come from?
05:21:03 <lambdabot> Great Yarrmouth!
05:21:21 <xerox> Err...
05:21:22 <dmhouse> xerox: test-cabal-install-user fails with that.
05:21:33 <xerox> So 1.1.4 isn't enough :/
05:21:48 <dmhouse> (Cabal-1.1.4 also isn't a hidden package.)
05:22:11 <xerox> It's just that 1.1.4 doesn't export that module
05:22:34 <xerox> If you add -i.. to the ghc-options field of the cabal file it will work I think.
05:22:57 <xerox> But maybe you just want to upgrade cabal.  I'm just a bit unconfortable with its makefile.
05:23:16 <dmhouse> Right.
05:23:27 <dmhouse> What would you advise?
05:23:43 <xerox> Asking me to provide a working Cabal hehe.
05:24:15 <xerox> Let me try it before.
05:24:22 <dmhouse> Hehe :) Okay.
05:24:42 <xerox> Lots of patches, it'll take some time.
05:24:50 <dmhouse> I've got time.
05:29:05 <bartw> how come that a function with no arguments has the same type as a value ?
05:29:58 <dmhouse> bartw: they're indistinguishable in Haskell.
05:30:41 <bartw> ah right ofc
05:31:00 <bartw> only possible for 'pure' functions
05:31:15 <dmhouse> Yeah. Which in Haskell is all functions.
05:31:18 <xerox> dmhouse: you ought to comment the lines 49 and 54 of cabal-with-install/Makefile and it should work.
05:31:27 <xerox> dmhouse: `it' = installing Cabal.
05:31:48 <xerox> Then, test-cabal-install-user
05:32:21 <dmhouse> xerox: so, upgrade Cabal?
05:32:25 <bartw> so hypotheticly, what should be the type of a non pure function ?
05:32:28 <xerox> dmhouse: right
05:32:53 <dmhouse> xerox: thanks.
05:33:23 <xerox> dmhouse: I suppose one can ask Cabal's Makefile to say `make' in cabal-install/ but I don't know how to do it in a reliable way..
05:34:06 <xerox> dmhouse: cabal-install makefile also takes care of setting up /etc/cabal-install or ~/.cabal-install, that's why just building and installing the binary isn't enough.
05:34:20 <xerox> (Which is what Cabal makefile does, apparently.)
05:44:04 <bartw> i guess (Int) would be usuable for something impure ;)
05:44:13 <xerox> Sorry?
05:46:42 <bartw> sorry, im just musing of that the type would be of a function with no arguments and an int return type in an impure language
05:48:43 <bartw> thinkig of types, gives me a headache sometimes
05:49:08 <Philippa> try not to worry too much about the concrete syntax of types in hypothetical languages until you need it
05:49:21 <Philippa> the abstract syntax is where you derive the meanings from anyway
05:49:35 <bartw> being busy with a hobby compiler it is kind of what i do
05:49:36 <Philippa> does it matter whether it's int () or () -> Int?
05:49:53 <Philippa> there's a difference between a hobby compiler and a hobby language :-)
05:50:18 <bartw> this type thing is infact internl to the compiler
05:55:00 <bartw> thanks :) it did give me a clue
05:55:12 <Philippa> internally, you shouldn't be using strings as a representation
05:55:16 <Philippa> it's slow :-)
05:55:26 <Philippa> (and error-prone)
05:56:47 <bartw> i noticed, i is currently an xmldom
05:57:02 <bartw> a typed ast isn't an endall either though
05:57:37 <psi> how do I make sure a cabalized package is compiled with -fvia-C?
05:58:17 <xerox> ghc-options: -fvia-C ?
05:59:54 <psi> where do I put this? it's not something I've made. I was I could control it via Setup.hs, or something.
06:02:11 <psi> found it, thanks
06:02:37 <Lemmih> psi: Why do you want to use -fvia-c?
06:03:16 <psi> Lemmih: it appears that debian's ghc for ppc does not contain a native code generator.
06:03:40 <psi> so I got an error without it.
06:04:25 <Philippa> a typed AST buys you a surprising amount of tools that're "just there" though
06:05:00 <Philippa> and a lot more that're "just there" bar a moment to write out an implementation that you could write a program to generate for you
06:09:24 <psi> hmp3 is pretty :)
06:12:28 <bartw> Philippa : i'll probably do that for the selfhosting compiler if i get to that point
06:16:52 <psi> dons: would it be hard to modify hmp3 into supporting ogg123?
06:21:24 <dons> psi, last time I checked it didn't have a 'remote control' ability, like mpg321,123.
06:21:28 <dons> has that changed?
06:21:43 <dons> if so, if it does have the 'remote control' mode (a bit like a shell), then it wouldn't be hard.
06:25:12 <psi> not as far as I can see
06:25:50 <bartw> hmz, alan cox's laptop exploded
06:25:55 <MarcWebe1> What does the ~ mean in this line: (***) f g ~(x,y) = (f x, g y)  (it has been copied from Control.Arrow)
06:26:03 <bartw> seems very hip
06:26:23 <dons> MarcWebe1: it applies f and g to x and y, returning a typle
06:26:40 <dons> the ~(x,y) is an irrefutable pattern match, which matches lazily
06:27:08 <ValarQ> irrefutable?
06:27:13 <bartw> why wouldn't (***) f g = (f x, g y) work ?
06:27:27 <dons> > (toUpper *** toLower) ('x', 'A')
06:27:29 <lambdabot>  ('X','a')
06:27:40 <dons> it has just slightly different semantics
06:28:09 <MarcWebe1> dons: I'll have a look at ghc documentation in the first place now. ;)
06:28:13 <dons> (check the h98 report on these patterns)
06:28:35 <dons> ?where h98
06:28:35 <lambdabot> http://haskell.org/onlinereport/
06:28:54 <dons> would be in the section on 'patterns'
06:28:56 <MarcWebe1> Yeah its haskell98
06:29:55 <dmhouse> ~ is a 'lazy pattern'. Normally, if you pattern match on a constructor, you have to evaluate any argument passed into that function to make sure it matches the pattern.
06:30:08 <dmhouse> Therefore a normal pattern match is strict (it forces evaluation).
06:30:26 <dmhouse> ~ delays the evaluation of the value until the component parts are actually used.
06:30:48 <dmhouse> But you run the risk that the value might not match the pattern -- you're telling the compiler 'Trust me, I know it'll work out'.
06:31:19 <dmhouse> (If it turns out it doesn't match the pattern, I believe you get a runtime error.)
06:31:23 <twanvl> > let f (x,y) = 1 in f undefined
06:31:25 <lambdabot>  Undefined
06:31:26 <dons> ah yes, there are a few other kinds of 'irrefutable patterns', such as _
06:31:30 <twanvl> > let f ~(x,y) = 1 in f undefined
06:31:31 <lambdabot>  1
06:31:41 <dmhouse> You can see the difference in what twanvl just pasted.
06:31:55 <bartw> why would y want to turn of typechecking like that ?
06:32:13 <dons> that's a good example, twanvl
06:32:21 <dmhouse> In the first example, the value is evaluated because it has to match the tuple pattern. You evaluate undefined and get undefined, which stops the preceedings.
06:32:46 <dmhouse> In the latter example, you don't bother evaluating the parameter until it's needed, which turns out to be never, so it doesn't matter you passed it undefined.
06:33:27 <kpreid> > (const 1 *** const 2) undefined
06:33:29 <lambdabot>  (1,2)
06:33:45 <kpreid> if the pattern weren't irrefutable, that would have failed
06:33:50 <bartw> so how can you keep compiletime safety and still late evaluation ?
06:34:06 <kpreid> bartw: the type system is not lazy
06:34:48 <Philippa> in general, lazy typing doesn't work even if it's still a separate pass
06:34:51 <kpreid> the difference here is all in values, not types
06:34:57 <psi> dons: maybe cplay does seeking by restarting plackback using the --skip option
06:35:02 <dons> > let f ~(x,y) | x == y = 1 in f (undefined :: ((),())) -- guards can force eval too
06:35:03 <lambdabot>  Undefined
06:35:19 <dons> psi: yeah, I think that's right, last time I looked at the cplay source
06:36:58 <MarcWebe1> So pattern matching is teh reason why using continuation  passing style forces evaluation (unless you use ~) ?
06:38:14 <dmhouse> http://en.wikibooks.org/wiki/Haskell/Laziness_revisited#Lazy_pattern_matching Hope nobody minds.
06:38:17 <lambdabot> http://tinyurl.com/f3wcp
06:39:50 <x3m> hmm what default dir does ghci look in, i copy a .hs file to ..\ghc-6.4.2\bin and try to load it but it cant find the file
06:40:25 <dons> ghci looks in the current directory only
06:40:33 <dons> unless you specify an alternate path
06:40:54 <dons> ghci a.hs -- should just work, no need to put things in some strange plage.
06:40:57 <dons> place
06:41:11 <x3m> ghc-6.4.2\bin should be the currect directory since thats where ghci.exe is located
06:41:14 <dmhouse> Hmm.
06:41:19 <dmhouse> > let f x = 1 in f undefined
06:41:21 <lambdabot>  1
06:41:29 <dons> x3m, ghci looks in the _current_ directory
06:41:41 <dmhouse> Cool, so the compiler is smart enough to know when it can evaluate the argument lazily.
06:42:08 <x3m> dons: and that is?
06:42:11 <Philippa> no, it's lazy by default
06:42:25 <dons> dmhouse: it wouldn't be haskell if f x = 1 demanded 'x' :)
06:42:31 <x3m> dons: im using win
06:42:35 <dmhouse> dons: of course.
06:42:40 <dons> x3m, you need to be in the same directory as your .hs file
06:42:54 <dons> or, load it by passing the full path to ghci. i.e.: ghci \a\b\c\A.hs
06:43:02 <Philippa> x3m: presumably you're both using win and not familiar with DOS?
06:43:05 <dmhouse> dons, but, for example, if you had f (x, y) = 1, it'd evaluate the argument even if neither x nor y were needed.
06:43:06 * dons doesn't use windows, does it show?
06:43:10 <dmhouse> Actually, why is that?
06:43:27 <Philippa> where would it do that?
06:43:32 <Philippa> it'd match against the tuple, yes
06:43:39 <dons> > let f (x,y) = 1 in f undefined
06:43:41 <lambdabot>  Undefined
06:43:41 <Philippa> because that's effectively a constructor pattern
06:43:50 <Philippa> (_|_, _|_) != _|_
06:43:55 <dons> > let f z = case z of (x,y) -> 1 in f undefined
06:43:56 <lambdabot>  Undefined
06:44:08 <Philippa> okay, yes. ISWYM. What I said
06:44:15 <Philippa> tuple patterns're effectively constructor patterns
06:44:22 <dons> the 'case' that the pattern match translates to forces eval.
06:44:23 <Philippa> constructor patterns force
06:44:38 <dmhouse> Philippa: yeah, that's what I'm asking.
06:44:40 <Philippa> yes, even when there's only one constructor in the type...
06:44:53 <dmhouse> Why do constructor patterns force if you don't use the components?
06:44:53 <dons> > let f z = case z of () -> 1 in f undefined
06:44:55 <lambdabot>  Undefined
06:45:03 <Philippa> they don't force the components
06:45:07 <Philippa> just the constructor
06:45:10 <Philippa> to check it's the right one
06:45:12 <dons> > let f z = case z of ~() -> 1 in f undefined
06:45:13 <lambdabot>  1
06:45:20 <dons> mm. never tried that before
06:45:21 <Philippa> consider True and False...
06:45:34 <dmhouse> Ah, fair point.
06:46:09 <dons> ?users #haskell
06:46:10 <lambdabot> Maximum users seen in #haskell: 238, currently: 219 (92.0%), active: 26 (11.9%)
06:46:21 <x3m> Philippa: presumably i am familiar with it, but ghci dont find it
06:46:25 <Philippa> ~(x,y) is thus an entirely sensible thing to write, because when forced you're always going to get that constructor if anything
06:46:36 <dons> x3m, can you change into the same directory as your .hs file?
06:46:44 <dons> and then run: ghci Foo.hs
06:46:53 <Philippa> x3m: ghci'll run wherever the shortcut or config tells it to unless you run it from a prompt
06:47:24 <Philippa> ~True is, of course, dangerous...
06:47:28 <x3m> Philippa: yes.. i try to run it from the ghci prompt
06:47:40 <bartw> but isn't the tuple itself the value ? hoe can it parts not be evaluated at the same time ?
06:47:41 <Philippa> you can't run ghci from the ghci prompt...
06:47:58 <Philippa> bartw: the components of the tuple don't have to be evaluated when the tuple is
06:47:59 <dmhouse> > let f ~(Just x) = 4 in f Nothing
06:48:01 <lambdabot>  4
06:48:07 <dmhouse> > let f ~(Just x) = x + 1 in f Nothing
06:48:09 <lambdabot>  Irrefutable pattern failed for pattern (Data.Maybe.Just x)
06:48:10 <x3m> the ghci prompt is an instance of ghci
06:48:10 <Philippa> consider (1,2) and (1+2,3)...
06:48:15 <dons> > let f ~True = 1 in f False
06:48:16 <lambdabot>  1
06:48:20 <dons> mm tasty :)
06:48:41 <Philippa> if you force <thunk (1,2)>, you get (<thunk 1>, <thunk 2>)
06:48:53 <dmhouse> bartw: imagine you have a value. You know nothing about it, only that it has the type 'Maybe Int'.
06:49:16 <dmhouse> You can evaluate the 'top level' to find out whether it's 'Just xxx' or 'Nothing', without evaluating the component (in this case the xxx).
06:49:30 <bartw> Philippa : i guess a thunk is an evaluation still to be executed ?
06:49:32 <dmhouse> It's the same principle with tuples but you only have a single constructor for the type.
06:49:35 <Philippa> bartw: right
06:50:09 <dmhouse> > let f (Just x) = 1 in f (Just undefined)
06:50:11 <lambdabot>  1
06:50:19 <dmhouse> ^^ the component isn't evaluated.
06:50:41 <bartw> ah ok
06:50:53 <xerox> Right, weak head normal form?
06:51:05 <Philippa> yep. The head's just the constructor
06:54:46 <x3m> :load "C:\Program Files\ghc\ghc-6.4.2\bin\dhs\test3.hs" dont work from inside ghci
06:55:12 <x3m> "C:\Program Files\ghc\ghc-6.4.2\bin\dhs\test3.hs" works from the command prompt though
06:55:13 <bartw> fun stuff
06:55:19 <dons> x3m, how doesn't it work?
06:55:30 <dons> i think you are not supposed to use quotes in ghci
06:55:52 <x3m> dons: Philippa said it was DOS commands
06:56:07 <x3m> thats how you can type a path
06:56:18 <dons> x3m, what error does ghci give you?
06:56:56 <Philippa> dons: I hope you're allowed to use quotes in filenames in ghci under windows, because that's the correct way to write LFNs with spaces in them
06:56:57 <x3m> Could not find module '"C:\Program Files\ghc\ghc-6.4.2\bin\dhs\test3.hs"'
06:57:13 <Philippa> OK, try without the quotes
06:57:31 <Philippa> note that I did *not* tell you GHCi uses DOS commands
06:58:06 <x3m> you said im probably not familiar with DOS, therefor implying my way of typing in a path would be wrong
06:58:18 <dons> does removing the quotes work?
06:58:36 <x3m> naah, then the space ruins it
06:58:40 <dons> otherwise, change into C:\Program Files\ghc\ghc-6.4.2\bin\dhs\, and just :load test3.hs
06:59:02 <bartw> try something like c:/program\ files/...
06:59:12 <bartw> i have had that work for some apps
06:59:23 <dmhouse> What do people think of http://en.wikibooks.org/wiki/Haskell/Laziness_revisited#Lazy_pattern_matching ?
06:59:30 <lambdabot> http://tinyurl.com/f3wcp
06:59:59 <Philippa> x3m: you inferred the wrong thing
07:00:01 <dons> hmm.
07:00:01 <dons> *Main> :load "x y/A.hs"
07:00:02 <dons> *Main> :t x
07:00:02 <dons> x :: Integer
07:00:10 <dons> quotes seem to work on unix, anyway
07:00:17 <Philippa> did you *try* removing the quotes?
07:00:52 <dons> dmhouse: is the wikibook easily findable from haskell.org?
07:01:12 <dons> under, say, 'Books and tutorials', and in some obvious place?
07:01:27 <x3m> Philippa: yes wrong thing? and yes i tried to remove the,
07:01:49 <bartw> dmhouse: pretty clear, expcept that i was wondering after reading it why it would be a good idea
07:02:18 <dmhouse> dons: perhaps not.
07:02:28 <dmhouse> dons: it's not very complete for now.
07:02:30 <Philippa> x3m: the concept of 'current directory' is somewhat messier under windows-as-a-GUI than from a command prompt
07:02:49 <bartw> chdir does work
07:02:57 <Philippa> starting ghci from a command prompt's thus often easier than working out how to talk windows into starting it in the right dir
07:03:38 <Philippa> (plus you might not want it in what looks like the obvious dir to windows - maybe you double-clicked on a module a couple of levels into a hierarchy and want the current dir to be a couple of levels out?
07:03:40 <Philippa> )
07:03:58 <x3m> maybe not
07:10:24 <MarcWebe1> Thanks. Had to ate some cakes with my parents. I'm still  struggling understanding the definition of this function. http://www.rafb.net/paste/results/0KYR5e92.html
07:12:08 <Philippa> MarcWebe1: instantiate a to ->
07:12:42 <Philippa> then you get the result_type (b, b') -> (c, c')
07:13:05 <Philippa> imagine the definition was (equivalently):
07:13:14 <bartw> i can't grok that type declaration
07:13:36 <Philippa> (***) f g = foo where foo ~(x,y) = (f x, g y)
07:14:21 <Philippa> basically, due to a special case the return value's a function and you're getting confused by a currying hiccup
07:14:30 <xerox> Philippa: oh, it's ~ really?
07:14:55 <Philippa> I'm modifying the code in the pastebin :-) But I could believe it
07:15:14 <xerox> ?source Control.Arrow
07:15:14 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
07:15:21 <Philippa> as haskell functions're normally lazy, it'd make sense for the Arrow instance to retain that laziness
07:15:25 <bartw> wouldn't this be the type ? (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:16:19 <xerox> (***) :: (Arrow (~>)) => (a ~> c) -> (b ~> d) -> ((a,b) ~> (c,d))
07:16:43 <MarcWebe1> Philippa: Thanks got it. (***)  f g = \c-> d  is  equal to  (***) f g c = d
07:17:47 <bartw> xerox: whats the difference between -> and ~> ?
07:18:04 <xerox> Mine is a valid type from GHC 6.5 thereafter.
07:18:12 <xerox> Hmm.
07:18:33 <xerox> ?type ((***) :: (a -> c) -> (b -> d) -> ((a,b) -> (c,d)))
07:18:34 <lambdabot> forall a c b d. (a -> c) -> (b -> d) -> (a, b) -> (c, d)
07:18:36 <xerox> Yuck.
07:18:40 <xerox> Okay.
07:20:50 <bartw> xerox: what should i read to grok that ~> ?
07:21:06 <fasta> Hmm, nano does not scale to long lines.....
07:21:37 <fasta> nor emacs
07:21:40 <xerox> bartw: it's just a way to make 'a b c -> a d e -> a (b,d) (c,e)' look nice, i.e. (~>) is really a type variable, just like `a' there.
07:21:59 <xerox> bartw: it was introduced for this very reason, nothing else.
07:22:03 <Philippa> not just look nice but make more immediate sense
07:22:19 <bartw> xerox: ah thats why i could not read his original
07:22:24 <xerox> hehe
07:22:41 <xerox> Note the `Arrow (~>)' constraint at the beginning of the type.
07:22:43 <akemp> @seen
07:22:44 <lambdabot> Lately, I have seen akemp, audreyt, bartw, fasta, marcwebe1, nothingmuch, philippa and xerox.
07:22:52 <akemp> @seen dons
07:22:53 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 21m 40s ago.
07:24:00 <bartw> xerox: intresting that ~> can be used infix even though it is a type variable, fun stuff
07:25:49 <dons> akemp: ?
07:27:22 <akemp> dons: random non-Haskell question: I was reading your blog (!!) and wondered what graphing package you used to generate the FPS graphs?  I've never gotten GNUPlot to do anything clean...
07:27:38 <mathewm> anyone know how to rollback the last 128 patches in a darcs repo?
07:28:34 <dons> akemp: i use darcs-graph for things like this, http://www.cse.unsw.edu.au/~dons/images/commits/ (which wraps gnuplot), and for other things i just use gnuplot
07:28:36 <lambdabot> Title: Project Activity, http://tinyurl.com/rh58u
07:29:36 <fasta> I made a zero line file of size >100KB, shouldn't it have one line then?
07:29:44 <fasta> wc -l <the file> gives zero
07:30:04 <pianodogg> wc -l probably just counts \n
07:30:20 <cinema> dons, don't you think it would give a huge performance boost to use fps/ByteString in Happy and especially in Alex ?
07:30:42 <akemp> dons: thanks.  Reading through darcs-graph right now.
07:30:53 <cinema> dons, I experience bid memory consumption in them at present
07:31:02 <cinema> s/bid/big/
07:31:30 <Lemmih> cinema: GHC has been doing that for years.
07:31:52 <dons> yeah. it's not too hard to plug in a packed string type to alex and happy, as ghc does
07:32:11 <dons> so you could try it, rather than reading [Char]
07:32:18 <cinema> but maybe some internals have to be changed too
07:32:32 <bartw> fasta: and wc -c ?
07:32:40 <dons> I pinged Simon M about it , and he said it should 'just work'
07:32:43 <dons> let me find the mail
07:32:44 <cinema> I am going to try to read the file with fps
07:32:58 <dons> I recommend the 'readFile' function in that case :)
07:33:07 <fasta> bartw: gives a large number, probably correct.
07:33:20 <bartw> fasta: you probably want a hexeditor  then, or reformat your data
07:33:36 <fasta> bartw: how on earth do you make that leap?
07:34:30 <bartw> fasta: text data usually doesn't use a single line for such a large document, so i assume it binary data so hench a hexeditor
07:34:58 <fasta> bartw: I created the document by writing the "show" of a value to a file.
07:35:20 <dons> you can safely add a newline if you wish
07:35:31 <dons> read will be able to deal with it (assuming you want to 'read' it back)
07:35:57 <bartw> s/,/,\n/g or something like that
07:36:00 <fasta> dons: It is impossible to read it back in
07:36:05 <dons> I'm not even sure fasta is asking a question (?)
07:36:10 <fasta> dons: I am not
07:36:13 <dons> ok :)
07:36:21 <dons> just a stmt: I made a zero line file of size >100KB
07:36:23 <fasta> dons: I was just amazed by the the wc -l output
07:36:32 <dons> funny, I'm surprised too
07:36:52 <fasta> dons: and I did mean to ask whether that was correct.
07:37:03 <dons> seems reasonable
07:37:09 <bartw> cat | wc -l : ^D does return zero
07:38:39 <fasta> Ok, I get a stack overflow. How can I profile?
07:40:00 <dons> compile with -O -prof -auto-all, run with +RTS -p -RTS arguments to your program
07:40:15 <dons> (and install profiled haskell libraries if you've not done so already)
07:40:43 <fasta> dons: I installed ghc from darcs and I didn't enable it explicitly.
07:40:53 <fasta> dons: does that mean I don't have profiled libraries?
07:41:04 <dons> hmm, I think they're built by default
07:41:07 <dons> you'll know soon enough
07:41:26 <dons> you can check:
07:41:27 <dons> $ ls lib/ghc-6.5/*p.a
07:41:27 <dons> lib/ghc-6.5/libHSCabal_-p.a                        lib/ghc-6.5/libHSreadline_-p.a
07:41:38 <dons> p == profiling
07:42:26 <dons> if you don't have them installed, when you try to compile with -prof -auto-all, you'll get a msg about base libraries not found (since ghc can't find the *-p.a versions)
07:44:13 <fasta> Is -O the most optimization I can get?
07:44:38 <dons> nope,
07:44:48 <dons> you can, for some problems, get better with:
07:44:59 <x3m> c++
07:45:09 <dons> -O2 -optc-O3 -funbox-strict-fields -optc-ffast-math -fexcess-precision .....
07:45:09 <pianodogg> x3m: touche
07:45:12 <dons> there's heaps
07:45:15 <x3m> ;)
07:45:29 <dons> yeah, make sure you're not using C++, that'll slow things down
07:45:33 <fasta> Where is the profile report generated?
07:45:44 <dons> foo.prof, where 'foo' is your binary
07:46:03 <Igloo> dons: Is it really called libHSCabal_-p.a for you?
07:46:12 <dons> all this and more can be found in the ghc user's guide, which is much easier and faster to search than the contest of my brain
07:46:29 <dons> Igloo: just noticed that, yes. that's a ghc of last week, head branch
07:46:40 <x3m> dons: hardly, c++ speed things up
07:46:44 <fasta> dons: yeah, sorry.
07:47:08 <Igloo> dons: pre-FC-merge?
07:47:12 <dons> yep
07:47:16 * Igloo doesn't get that
07:47:18 <pianodogg> x3m: sure the compiler is faster but not necessarily the code
07:47:59 <dons> Igloo: , GhcLibWays      = -p
07:48:02 <dons> oops, I think
07:48:05 <x3m> pianodogg: not necessarily, but if its a good programmer it will almost always result in faster code
07:48:09 <Philippa> there's a reason GHC messes with the output of GCC afterwards
07:48:35 <Philippa> x3m: you haven't seen enough of what good optimised haskell looks like to really be making that comment
07:48:36 <Igloo> dons: Is that something you wrote, e.g. in build.mk?
07:48:46 <dons> Igloo: yes :)
07:48:51 <dons> I think that's one - too many
07:48:53 <Igloo> OK, cool  :-)
07:48:54 <Philippa> especially not in a number of task areas where C++ gets in its own ways
07:48:58 <Philippa> *way
07:49:17 <pianodogg> Philippa: what's a good example so i can refute this argument to other folks too
07:49:43 <Philippa> pianodogg: pick something where immutability gets used for more than just safety...
07:50:01 <Philippa> by the time you're encoding laziness and persistant data structures in C++, haskell has good odds on doing well
07:50:03 <x3m> Philippa: i have, you obviously hasent seen good optimised c/c++. I asked a friend who works just at optimizing code for game companies to make some programs and compare them to haskell. they beat the shit out of them
07:50:21 <Philippa> x3m: you're wrong, I used to be a gamedev geek
07:50:42 <dons> x3m, here's one state of things, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
07:50:45 <lambdabot> http://tinyurl.com/lepfo
07:50:59 <dons> though the haskell benchmarks are slower than they need to be, since its an old compiler missing some fast libraries
07:51:00 <x3m> Philippa: no you are wrong, you being a gamedev geek has nothing to do with it. He worked for almost 10 years as it
07:51:07 <pianodogg> but if you're encoding those things why the heck are you programming in c++ to begin with?  sounds like you're not using c++ correctly at that point
07:51:12 <Philippa> x3m: you're telling me I haven't seen fast C++. You are *wrong*.
07:51:33 <Philippa> pianodogg: if it's the natural solution to a problem, algorithmically speaking, there's not much you can do about it
07:51:38 <x3m> dons: i think it was some of those tests he rewrite the c/c++ code for, they all beat the haskell samples
07:51:42 <Philippa> there've been some *big* commercial uses of lazy evaluation
07:52:03 * fasta leans back as the language war continues
07:52:05 <x3m> Philippa: since you are implying haskell is faster thats the conclusion
07:52:23 <Philippa> x3m: you've already demonstrated you're good at misreading what I'm "implying"
07:52:25 <pianodogg> they are faster at different things
07:52:43 <pianodogg> geez.  why must languages compete like this?
07:52:57 <bartw> can't we all get along ?
07:53:27 <x3m> Philippa: no, you've allready demonstrated you imply wrong.. saying that i would lack DOS skills just cause ghci dont accept quotes around a file path .
07:53:27 <dons> I'm glad I don't have to code in C++ all day.
07:53:32 <Philippa> I am not telling you that Haskell is a faster language than C++. I *am* telling you that C++ is not always faster than haskell
07:53:44 <dons> e.g. here http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
07:53:47 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ..., http://tinyurl.com/ncjpk
07:53:48 <Philippa> x3m: go reread, FFS
07:53:52 <dons> 1.0	Haskell GHC 	1.16	1,916	372
07:53:53 <dons> 1.1	C++ g++ #2 	1.22	1,480	363
07:53:55 <x3m> Philippa: i havent said its always faster, go reread
07:53:57 <dons> :)
07:53:59 <pianodogg> compilers are bound to emit great binaries for idiomatic, natural code in the language
07:54:10 <pianodogg> not every problem is easily expressed in every language
07:54:26 <bartw> i've seen alot of slow c++ code, it's a matter of investment, true for any context
07:54:31 <x3m> dons: yeah, but the c/c++ code for all those examples aint optimiesed at all
07:54:35 <dons> x3m, did you get your ghci code working?
07:54:48 <Philippa> x3m: quit being a fuckwit. I didn't say you /did/ say that. You *did* say well-optimised C++ is, when you said C++'ll speed things up
07:54:51 <x3m> dons: ye
07:55:03 <dons> x3m "modified by bearophile for speed and size, 31 Jan 2006"
07:55:06 <dons> I think they've been optimised
07:55:11 <x3m> Philippa: in general yes
07:55:57 <x3m> dons: yeah but that they have been optimized dont mean they are fully optimized or not even close to it
07:56:22 <Philippa> x3m: in general, microbenchmarks are misleading...
07:56:45 <x3m> Philippa: sure they can be
07:56:47 <pianodogg> that haskell code is so unnatural
07:56:51 <pianodogg> for nsieve
07:56:59 <fasta> C++ has a rather strong point going for it that lots of games are already written in it. OTOH lots of projects also fail (using C++).
07:57:02 <dons> not too bad though, I think.
07:57:13 <Philippa> fasta: that, and games aren't typical apps
07:57:14 <dons> some of the other programs are better written with fps
07:57:20 <pianodogg> someone remind me what that `seq` hack does?
07:57:25 <pianodogg> force evaluation of arguments?
07:57:37 <Philippa> evaluates the LHS before returning the RHS
07:57:39 <x3m> but games are typical just for the purpose of needing optimisation
07:57:39 <dons> nope, just let's the compiler know it's ok to unbox that value
07:57:41 <MarcWebe1> What are your experiences with cabal-install? Are  gentoo ebuild supposed to use this system in some time, too?
07:57:44 <Philippa> x3m: no, they're not
07:57:48 <dons> it's better written in ghc 6.6 as :  f !x = ....
07:57:57 <pianodogg> dons: oh thank goodness
07:58:02 <dons> :)
07:58:08 <pianodogg> i've seen that idiom a few times before and it's so hackish
07:58:10 <Philippa> games typically need optimisation, but that's not the same thing
07:58:12 <x3m> Philippa: they sure are, a notepad dont need the optimisation that a 3d game does
07:58:14 <pianodogg> nice to see a language addition
07:58:21 <MarcWebe1> x3m: That depends..Isn't the interface of WarCraft written in lua? (Or a similar game)..
07:58:23 <Philippa> x3m: you just repeated the same error
07:58:33 <Philippa> many games use lua, yes
07:58:37 <pianodogg> MarcWebe1: sure the interface, not the backend
07:58:56 <pianodogg> but then again hot code in the backend is probably rewritten in asm
07:59:01 <x3m> MarcWebe1: lua is a script language written in C, and yes its use to generate some objects and stuff in WoW
07:59:30 <dons> x3m, so you're learning haskell?
07:59:40 <Philippa> games, for example, don't currently wander into the space where lazy evaluation is an optimisation. It's not at all easy to make lazy evaluation go as fast in C++ as it does in GHC output on an architecture where it does the relevant mangling post-GCC
07:59:52 <x3m> Philippa: no, there was no error. like ALL big game has needed optimisation pretty much to generate a good performance
08:00:06 <x3m> dons: im looking into it a bit yes
08:00:13 <Philippa> x3m: But games are not a typical example of an application that needs optimisation. They are a specific one.
08:00:21 <dons> pianodogg: this is a nice one, http://shootout.alioth.debian.org/debian/benchmark.php?test=pidigits&lang=all
08:00:23 <lambdabot> Title: pidigits benchmark | Debian : AMD&#8482; Sempron&#8482; Computer Language Shooto ..., http://tinyurl.com/gtjcb
08:00:26 <Philippa> compare and contrast with databases...
08:00:38 <fasta> Hmm, I think I have a space-leak the size of a jumbo-jet.
08:00:47 <dons> you have to write some pretty nasty C (and use 3rd party libs) to get lazy eval and arbitrary precision math
08:01:02 <dons> fasta: should be pretty easy to kill then.
08:01:06 <dons> the big ones are the easy ones
08:01:22 <dons> fasta: you've seen the 'performance' resource on haskell.org?
08:01:27 <fasta> dons: I have little to zero expertise in this area.
08:01:29 <fasta> dons: no
08:01:32 <x3m> Philippa: well a high percentage of them needs it at a high level, its one of the typical examples. another one could be real time apps and so on
08:01:47 <x3m> if you wanna call them specific.. sure up to you
08:01:51 <Philippa> RT apps don't typically need optimisation so much as they need a complete awareness of worst cases
08:01:55 <pianodogg> dons: that's a lot better than nsieve
08:02:00 <fasta> @where performance
08:02:00 <lambdabot> I know nothing about performance.
08:02:05 <Philippa> you simply do not structure an RT app the same way you would a game
08:02:07 <dons> here, http://haskell.org/haskellwiki/Performance
08:02:09 <lambdabot> Title: Performance - HaskellWiki
08:02:09 <pejo> x3m, nobody sane will refute your claim that it is hard to reason about time and space properties of lazy evaluation.
08:02:11 <x3m> dons: yep i know
08:02:12 <dons> ?where performance http://haskell.org/haskellwiki/Performance
08:02:12 <lambdabot> I know nothing about performance.
08:02:13 <pianodogg> is there a performance hit with boxing/unboxing F's ?
08:02:16 <dons> ?where+ performance http://haskell.org/haskellwiki/Performance
08:02:16 <lambdabot> Done.
08:02:30 <dons> x3m, i'm was passing that on to pianodogg
08:02:39 <Philippa> games have very few high-level constraints until a significant way through development, too
08:03:01 <dons> pianodogg: nope, it's all unboxed
08:03:02 <x3m> ah well
08:03:31 <pianodogg> dons: the fields of F are strict; so the packaging of F's gets optimized away in some sense?
08:03:48 <dons> yep
08:03:54 <dons> exactly that.
08:04:27 <pianodogg> so a datatype with all strict fields becomes a "record" and has no indirections?
08:04:49 <x3m> but rt apps still need optimisation
08:04:50 <dons> the fields can be unpacked into the constructor, yep.
08:05:06 <pianodogg> well, i mean that the constructor itself sort of gets optimized away
08:05:17 <Philippa> x3m: Not necessarily
08:05:18 <dons> yeah, in this case, even that happens
08:05:22 <fasta> If something has the same semantics when written in a tail-recursive way, but currently it isn't, is that transformation automatically done by the compiler? It would be a rather non-trivial transformation, so I guess not.
08:05:31 <dons> all the integers are passed as unboxed arguments
08:05:41 <SimonRC> Could a hash table with a fixed set of keys be a functor?
08:05:43 <pianodogg> well yes
08:05:56 <Philippa> depending on the size of your product run, just using a faster processor can turn out to be more economic than putting the time in
08:05:57 <dons> fasta: nope, you'll need to rewrite the function to be tail recursive
08:05:58 <xerox> fasta: nope
08:05:59 <dons> shouldn't be too hard
08:05:59 <x3m> Philippa: im not talking about necessarily, i mean in general
08:06:15 <Philippa> and I'm also talking about in general
08:06:25 <x3m> same with games, not all need optimisation, but most.. and like all big ones(3d) does
08:06:26 <fasta> My "show<datatype>" function takes the most time ;)
08:06:42 <pejo> x3m, a surprising amount of real time systems has "more than enough" performance, they're really more worried about WCET as Philippa has already pointed out.
08:06:44 <Philippa> in general, *you don't know*. In general, you need additional constraints beyond needing to be RT before you need optimisation
08:07:12 <Philippa> quite, in a day and age of gigahertz processors it's not that hard to poll and respond 100 times a second
08:07:18 <x3m> pejo: ofc i know that, and i havent said anything against it.. what now came up with you thinking that
08:07:40 <Philippa> because you're arguing as if it's irrelevant and you must be right
08:08:09 <pejo> x3m, you keep claiming that rt applications need optimisations.
08:08:31 <x3m> Philippa: no i havent arguing that it would be irrelevant.. i didnt even mention it, you did
08:08:38 <pianodogg> dons: it is exactly these sorts of optimizations that c++ compilers have a hard time doing :)
08:08:56 <Philippa> and as your app gets bigger, the balance between going fast and being able to readily prove or demonstrate correctness becomes rather non-trivial
08:08:58 <dons> pianodogg: yeah, you gain a lot of interesting abilities if you can control side effects
08:09:16 <fasta> dons: I went the "easy" way to use the O(n^2) (++) in this part. Is there a simple solution for that or should I rewrite it such that it builds one large function consisting of lazy (:) applications?
08:09:16 <x3m> for games gigahertz processors dont really matter. much of the speed depends on the gpu and they wanna cream out as much fps as possible, therefor they do optimisation
08:10:04 <Philippa> newsflash: physics, simulation, AI etc etc all need CPU power. Run a current game with your CPU underclocked to 10% of normal speed and it *will* stink.
08:10:07 <dons> fasta: yes, avoiding ++ is a good idea. pass an accumulator, perhaps?
08:10:16 <dons> there's a fair few tricks for dealing with this
08:10:29 <SimonRC> fasta: IIRC, concatenate is O(n).
08:10:37 <SimonRC> @type concatenate
08:10:39 <lambdabot> Not in scope: `concatenate'
08:10:43 <SimonRC> @type concat
08:10:44 <dons> ?type concat
08:10:45 <lambdabot> forall a. [[a]] -> [a]
08:10:46 <lambdabot> forall a. [[a]] -> [a]
08:10:56 <dons> referentially transparent !
08:11:02 <SimonRC> :-)
08:11:11 <es> my little mind is not smart enough to fully understand 'forall' from GHC user's guide. Any other document out there to learn about GHC's 'forall'?
08:11:11 <fasta> Oh, you mean building lots of lists and then in the end concat them together?
08:11:15 <Philippa> if that weren't the case, the amount of optimisation necessary would be much smaller. As it is, it's not just getting polys to the GPU that people discuss
08:11:24 <pianodogg> good to know lambdabot utilizes equational reasoning
08:11:35 <Philippa> oh, sorry, strips and fans and generalised geometry. Showing my age a bit, there
08:11:58 <dons> es, it appears in the haskell98 report, and here, http://www.haskell.org/haskellwiki/Keywords
08:11:59 <lambdabot> Title: Keywords - HaskellWiki
08:12:02 <Philippa> nor is all the work going into making shaders run faster
08:12:34 <Philippa> hell, most of that would, in the long run, be better solved with a brute force approach - the programs're tiny anyway, let a computer figure out the fastest way to do it given the relevant constraints
08:13:03 <es> dons: Oh, I thought the implementation is GHC specific. I'll check that. Thanks.
08:13:39 <pianodogg> es: there are ghc extensions with some wicked types with foralls in interesting places
08:14:21 <pianodogg> or is higher order polymorphism in haskell98:
08:14:42 <ndm> pianodogg: no, its not
08:16:17 <Philippa> 'lo Binkley
08:16:23 <Binkley> hey
08:16:27 <Binkley> guess i missed the fun :-)
08:16:39 <Philippa> for now. Most of the other sort happens in #haskell-blah, btw
08:17:00 <fasta> I do think that using ++ is more "high-level" than restructuring the code to something for efficient.
08:17:31 <Philippa> I think that's only true if you really mean to say you don't care about that detail, though
08:17:44 <fasta> er to something else for efficiency.
08:17:44 <Philippa> oh, or if you got the associativity right :-)
08:22:56 <Philippa> I think often acknowledging your code needs a restructuring and doing it in a principled manner makes it easier to get things fast cheaply
08:25:05 <dmhouse> es, http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types might help as well.
08:25:09 <lambdabot> http://tinyurl.com/f9umb
08:33:20 <bartw> \
08:39:45 <lohmi123> hi
08:40:04 <lohmi123> can anyone help me configure emacs for haskell mode ?
08:40:30 <dylan> how come lambdabot sometimes shows a title, and other times doesn't?
08:41:22 <lohmi123> i downloaded emacs and haskell mode with synaptic packet browser
08:42:32 <lohmi123> when editing haskell files, i have now a declaration menu showing variable names. so it works a bit. but, i cant run the ghci compiler out of emacs. i tried Ctrl-c , Ctrl - l.
08:42:46 <lohmi123> and i also found, that i dont have a .emacs file.
08:44:46 <psi> make one, and try putting (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci) there
08:45:43 <xerox> dylan: she's smart
08:45:50 <psi> you can type M-x turn-on-haskell-ghci, just to test it
08:46:09 <lohmi123> in that command line
08:46:44 <musasabi> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
08:46:44 <musasabi> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
08:46:44 <musasabi> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
08:46:58 <musasabi> (are there others?)
08:47:33 <lohmi123> where do i write that M-x turn-on .. to test
08:47:57 <psi> lohmi123: in emacs. M-x means Meta-x, usually Alt-x
08:48:11 <xerox> I.e. you chord with the Alt key and the x one.
08:48:15 <Bourbaki> moin
08:49:04 <gour> ndm: hi, you were preparing some release yesterday? did i miss something?
08:49:12 <psi> lohmi123: it should enable the C-c C-l keybinding
08:49:20 <ndm> gour: dr haskell is out :)
08:49:51 <gour> ndm: it needs yhc?
08:50:16 <ndm> gour: yep, if you are on windows the prebuild snapshot is plenty, if not you need to compile Yhc first
08:50:41 <gour> ndm: i'm on linux, but didn't know yhc is released?
08:50:53 <lohmi123> says loading haskell-ghci source .. done
08:51:00 <ndm> gour: not really, but grab the darcs, install python and scons, then just type scons
08:51:11 <ndm> gour: if that doesn't work, email yhc -at- haskell
08:51:23 <gour> ndm: you like scons?
08:51:38 <ndm> gour: not massively, but our build engineer does
08:51:57 <gour> ndm: let me try (to build yhc :-)
08:52:08 <gour> @where yhc
08:52:08 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
08:52:10 <psi> lohmi123: does it work now, then?
08:52:11 <ndm> gour: good good :)
08:52:13 <es> dmhouse: I've seen this one. Thanks.
08:52:30 <ndm> gour: darcs get http://www.cs.york.ac.uk/fp/darcs/yhc-devel
08:52:32 <lambdabot> Title: Index of /fp/darcs/yhc-devel
08:52:52 <lohmi123> i did Ctrl-c Ctrl-l. Symbols value as  variable  is void. ghci haskell ...
08:52:53 <ndm> gour: --partial :)
08:53:16 <gour> ndm: 584 patches :-}
08:54:13 <ndm> gour: we've been busy :)
08:54:55 <gour> ndm: yes, but better add '--partial' to the web site in order to save bandwidth
08:55:27 <lohmi123> where shell i store that .emacs file ?
08:55:29 <ndm> i've just filed a bug to sort that out, we're hopefully moving to haskell.org soon anyway
08:56:57 <dmhouse> es, okay then. Pass on any comments you might have about that to me, I wrote it.
08:57:15 <psi> lohmi123: in your home directory.
08:57:15 <dmhouse> lohmi123: if you get that error message, just use C-c C-l again and it normally works.
08:57:53 * gour is building yhc
08:58:30 <lohmi123> it says: symbols function definition is void. inferior -haskell-load file. and the pc speaker beeps.
08:58:45 <lohmi123> does that mean haskell mode is installed properly ?
08:59:05 <psi> when does it say that?
08:59:15 <fasta> lohmi123: symbol function definition is void means that the function is not defined.
08:59:16 <dons> dylan: if the title doesn't appear in the first 512 bytes of the file, lambdabot doesn't bother printing one
08:59:24 <lohmi123> when i say C-c C-l.
09:01:37 <psi> does it really say "inferior -haskell-load file"?
09:01:55 <lohmi123> yes
09:04:05 <lohmi123> i have to admit that im new to linux and emacs and only have abstact knowledge about functional programming.
09:04:13 <lohmi123> abstract
09:04:44 <psi> so it doesn't in fact say haskell-ghci-load-file?
09:04:59 <fasta> Is it possible to see from a profile whether it crashed?
09:05:17 <fasta> "it" being the program that was run
09:05:45 <lohmi123> psi: no
09:06:18 <psi> okay, then I have no idea.
09:06:46 <lohmi123> in the manual, they say, that a minibuffer window will show up. i only see this command line on the bottom of the emacs window.
09:07:08 <psi> that's the minibuffer
09:07:50 <lohmi123> ok
09:08:49 <psi> do you have hugs installed? it might work better.
09:09:12 <lohmi123> i should better use ghc.
09:09:20 <roconnor> @seen shapr
09:09:20 <lambdabot> I saw shapr leaving #haskell 1d 16h 42m 36s ago, and .
09:11:27 <lohmi123> i put the .emacs file into /usr/share/emacs
09:12:08 <lohmi123> is that ok ? or where do i have to put that file ?
09:12:48 <pierre-> lohmi123: it's better to put it in ~
09:13:23 <fasta> lohmi123: Did you already do C-h t in Emacs?
09:13:38 <ndm> gour: success/failure? it doesn't take that long to bulid
09:13:56 <gour> ndm: yhc is built, now some problems with drhaskell
09:14:42 <fasta> 99.1   99.9 This is %time and %alloc
09:14:47 <ndm> gour: compiling it?
09:15:04 <gour> ndm: invoking build line from batch file
09:15:05 <fasta> Is this a good profile?
09:15:28 <ndm> gour: you'll need to do ghc --make Main -i<path to yhc/src/compiler98>
09:15:39 <ndm> it requires some of the Yhc libraries
09:15:46 <xerox> http://www.opensky.ca/~jdhildeb/arctan/arctan_diff.html
09:15:51 <lambdabot> Title: The Derivatives of Arctan(x)!, http://tinyurl.com/kj6km
09:15:51 <xerox> O_o
09:15:51 <ulfdoz_> keine Ahnung.
09:16:07 <gour> ndm: but i pit some paths wrong
09:16:37 <ndm> gour: have you managed to compile drhaskell?
09:16:50 <gour> ndm: not (yet)
09:16:55 <xerox> dons: ping
09:17:13 <ndm> the next version will be released as a single .hbc file, which won't depend on the source for yhc, just the binary
09:17:25 <ndm> unfortunately things didn't move fast enough, so it does require it this way
09:17:42 <roconnor> @hoogle RWS
09:17:44 <gour> i get: ghc-6.5.20060917: error: directory portion of "obj" does not exist (used with "-odir" option.)
09:17:44 <lambdabot> Control.Monad.RWS :: module
09:17:44 <lambdabot> Control.Monad.RWS.RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
09:17:44 <lambdabot> Control.Monad.RWS.RWS :: newtype RWS r w s a
09:18:09 <ndm> gour:
09:18:16 <ndm> gour: md obj first
09:18:21 <ndm> mkdir obj, i mean
09:18:33 <ndm> it wants to shove all the .obj files in a special place
09:18:45 <ndm> although i wasn't really intending linux users to use the make.bat
09:18:52 <ndm> since i doubt it will work on anything but windows
09:19:33 <fasta> I only have one cost centre with %time 99.1 and %alloc 99.9
09:19:34 <gour> ndm: hmm...now it's build, but: drhaskell: Hints.ycr: openBinaryFile: does not exist (No such file or directory)
09:19:48 <gour> ndm: something must be in PATH or what?
09:20:05 <ndm> gour: if you type yhc Hints.hs -corep what happens?
09:20:06 <fasta> What does that mean?
09:20:36 <lohmi123> oh it seems to work now. i put the .emacs file into ~ . good tip.
09:20:38 <ndm> gour: you must run it from the dr haskell directory at the moment, i.e. move your code into that directory (which admitedly sucks)
09:21:09 <gour> ndm: bash: yhc: command not found, i run in drhaskell dir
09:21:39 <ndm> gour: you'll need to set inst\bin from yhc to your path
09:22:04 <fasta> I did make html;make install-docs, but I didn't get a user guide built. Why?
09:23:01 <gour> ndm: Warning: the environment variable YHC_BASE_PATH is not set
09:23:01 <gour> yhc: lib/yhc/packages: getDirectoryContents: does not exist (No such file or directory)
09:23:12 <gour> ndm: this is pretty complex :-)
09:23:19 <ndm> @wiki Yhc/Snapshot
09:23:20 <lambdabot> http://www.haskell.org/haskellwiki/Yhc/Snapshot
09:23:36 <ndm> gour: that explains how to set up your YHC_BASE_PATH
09:23:51 <ndm> gour: yep, we really need proper linux distributions, or a make install that does this magic
09:23:53 <gour> ndm: (There is currently no text in this page)
09:24:03 <gour> ndm: why not cabal?
09:24:14 <ndm> gour: http://www.haskell.org/haskellwiki/Yhc/Snapshots
09:24:16 <lambdabot> Title: Yhc/Snapshots - HaskellWiki, http://tinyurl.com/oy5st
09:24:25 <ndm> gour: Cabal is unsuitable for installing a Haskell compiler, i think
09:24:34 <ndm> gour: but its definately what should be used for Dr Haskell
09:25:32 <gour> ndm: ../inst/bin is in the PATH. why he wants more?
09:25:58 <ndm> gour: good question, i still don't understand why more is wanted, but it is - i'll file a bug
09:26:06 <gour> ndm: i.e. i can invoke yhc...
09:26:33 <gour> ndm: gour@gaura-nitai ~/repos/drhaskell $ yhc -v
09:26:33 <gour> Warning: the environment variable YHC_BASE_PATH is not set
09:26:33 <gour> yhc version XP
09:27:03 <ndm> gour: set YHC_BASE_PATH as described in the above Snapshots wiki page
09:27:18 <ndm> gour: and i'll go knee-cap who ever introduced it :)
09:27:29 <ndm> so by the build in a weeks time, you won't need it
09:27:45 <gour> that page speaks about YHC_INST_PATH only
09:28:05 <ndm> oh, crap
09:28:09 <gour> :-)
09:28:13 <ndm> i've listed the wrong environment variable!
09:28:28 <ndm> use the one the compiler suggests, not my docs
09:28:32 * ndm edits the docs
09:29:16 * gour thinks yhc needs some more linux-love :-)
09:31:31 --- topic: '["Join us as we move forward toward the Age of the Lambda","Logs: http://tunes.org/~nef/logs/haskell/", "Haskell - the language of ICFP winners 3 years running"]'
09:31:31 --- topic: set by dons on [Sun Sep 24 02:44:05 2006]
09:31:31 --- names: list (clog_ dcoutts__ Psyche^ lucas42 cods hyrax42 jak roconnor mauke sad0ur binary42 crm-114 bortzmeyer swiert Muad_Dib Bourbaki lhz lohmi123 gour camster Deformative-II jtoy_ erider fwd dmhouse ihope es pianodogg zarvok fasta astrolabe akemp quetzal Twigathy matthew-_ therp mathewm crem_ MarcWebe1 starfruit ndm sslow Philippa ski kpreid twanvl der_eq kombinator nnunley_ integral Narrenschiff lokadin vincenz cptchaos mathrick Prip arjanb ramkrsna)
09:31:31 --- names: list (chris2 BCoppens abcde` ValarQ dottedmag iblechbot x8nyl madpickle MarcWeber triple_ foxy Jaak slipstream-- pierre- scsibug_ ThreeQ falconair jgrimes thetallguy mhfan dfeuer svens lambdabot Krooga bran_ fnordus chrisb__ dfranke stepcut Averell MikeJS psi perspectiva1 x3m Tobsan SamB magnus- ulfdoz_ tessier_ Korollary Patterner Trixsey lisppaste2 nick8325 Lemmih Bobstopper kaol sethk woggle dgoldsmith petekaz mattam macron-work StoneNote newsham)
09:31:31 --- names: list (shawn_ tessier edwardk saccade lennart profmakx sris johs Teron_ Betovsky clog kosmikus juhp epiphone Spark Codex_ arcatan wilx tmoertel moonlite sieni df_ dcoutts arguile Syzygy- inferno- cschneid boliver sjanssen pandres cmeme lispy GeoBesh ex_nor Cale glguy Pupeno Nioate_ kzm_ TwigEther lucca masak mlh irgs scw catrpillar Adamant xerox tic piggybox Revision17 vegai Eidolos nothingmuch Plareplane Baughn norpan aleator khaladan Igloo gds)
09:31:31 --- names: list (ksandstr_ eno-away dylan mob moleris ozone ibid Khisanth Kahdloc eyck gaal nattfodd xinming_ gkr dany2k bartw _frederik_ zamez Lunar^ rafl cpatrick deadbeef pingu drbean liyang kpk bdash orbitz ohub dons flux__ mux jbalint kzm dwm noj kalven rycee Thomas2_ resiak qwr Azmo_ carp explicitjelly Maddas kolmodin SimonRC pejo wli mornfall emu dvekravy WillKW dcoutts_ carp_ psnl sudoer magagr musasabi nomeata jmob audreyt gdsx wolverian shrimpx)
09:32:12 <ndm> fair enough, i've openned bugs for everything you've said
09:32:22 <ndm> after setting YHC_____PATH it should all be over
09:32:47 <gour> ndm: to what should point YHC_PATH?
09:33:16 <gour> i mean, YHC_BASE_PATH ?
09:33:18 <ndm> gour: as per the snapshot page, the inst directory
09:33:39 <ndm> i.e. set YHC_BASE_PATH=.......\inst
09:34:36 <gour> ok, now it did
09:35:15 <ndm> does drhaskell Test.hs work?
09:36:31 <gour> ndm: great - I can apply box_append in check_elem (5:10-6:80)
09:36:31 <gour> I can apply concat_map in substitute2 (8:1-12:31)
09:36:31 <gour> I can apply concat_map in subst4 (17:1-17:54)
09:37:15 <ndm> woohoo!
09:37:19 <ndm> now its basically working :)
09:37:26 <gour> ndm: now i'll take a short rest and then read what drhaskell is all about :-)
09:37:34 <roconnor> can I export imported modules in my module?
09:37:37 <SamB> ndm: Cabal should, in my opinion, be made suitable for installing a Haskell compiler... Though it need not be able to do 100% of what should be done, it should do all the hard parts...
09:38:02 <ndm> gour: thanks for trying it, i've got an additional 4 bugs in the bug tracker, to make it a lot easier next time
09:38:16 <ndm> roconnor: module Blah(module Data.Map, module Blah) for example
09:38:23 <SamB> I mean, I'd like to know that it could scale up that high...
09:38:26 <ndm> SamB: its not though, it doesn't even have dependancy analysis
09:38:31 <gour> ndm: thank you for thanking me for producing bug reports ;)
09:38:42 <SamB> ndm: quite!
09:39:14 <ndm> SamB: its a lovely theoretical idea, but the compiling of C, getting sizes and endians etc are all way out of Cabal's teritory
09:39:47 <ndm> SamB: of course, we'd love it if the base library could be compiled with Cabal, thats a big chunk of the work, and Cabal is perfectly suited to it
09:40:06 <roconnor> ndm: I should do this more often!
09:40:21 <SamB> eh. I don't think it would be so hard to get it to do such things, or at least drive them...
09:40:34 <ndm> SamB: then by all means give it a whirl :)
09:40:46 <SamB> hmm
09:40:59 <SamB> I think I want to wait until cabal-install works ;-)
09:41:03 <ndm> Cabal is an ugly mess, the compilation process for base is an ugly mess....
09:41:39 <dcoutts__> hmm
09:42:01 <SamB> yeah, well, I just think cabal shouldn't be an ugly mess, thats all ;-)
09:42:01 <ndm> i meant the code inside Cabal, rather than Cabal from the outside
09:42:08 <SamB> oh, hehe
09:42:51 <SamB> I'd also like if it could be used to build lambdabot without linking in all the plugins... (without cheating, and with buildimg Boot.hs)
09:42:57 <ndm> i agree, if someone had the time to work on it, it could be made into something special
09:43:05 <ndm> well have you seen lambdabot's cabal file?
09:43:13 <SamB> yes!
09:43:22 <SamB> and it links everything statically!
09:43:27 <ndm> its not a declarative description of how to build lambdabot, its a shell script with a .cabal extension
09:43:38 <SamB> also true!
09:43:52 <SamB> except it doesn't do all that a shellscript would be able to do!
09:44:02 <ndm> i would like cabal to be more declarative, as thats the only way to get Windows + Cbala stuff working
09:44:52 <SamB> if we can't even get it to build lambdabot without cheating, how can we expect it to be good enough for much but toys?
09:45:16 <SamB> also I haven't enough RAM to link lambdabot
09:45:38 <ndm> indeed, but it really needs someone to step up and fix it
09:45:46 <ndm> but its much easier just to cheat for one individual tool
09:45:50 <ndm> hence it never gets done
09:46:35 <SamB> maybe if I swiped some of dons' RAM...
09:49:10 <Igloo> I don't know if this is related to what you're talking about, but there are a number of issues blocking compiling base with cabal with GHC. I'll put more details in a bug report later
09:49:48 <ndm> Igloo: in base, Cabal or GHC?
09:50:00 <Igloo> All 3
09:50:06 <ndm> :)
09:50:30 <ndm> any idea on roughly the amount of work its going to be?
09:51:05 <Igloo> None of the problems should be huge, but they need to be done
09:51:26 <ndm> oh, do you have anything to do with the windows installer in GHC?
09:51:32 <Igloo> No
09:51:33 <ndm> or is that something done entirely separate from you
09:52:04 <ndm> so is Cabal for base a definate intention for 6.8
09:52:08 <Igloo> I could do the builds if someone gave me the installer source, but AFAIK no-one has/will
09:52:21 <Igloo> I'd certainly like it to be
09:52:39 <ndm> is there much chance of getting the installer source?
09:52:53 <ndm> it kind of sucks to have a open source project that can't even build an installer on its own...
09:52:55 <Igloo> My vague memory is that it can't be given out for some reason
09:53:05 <ndm> yeah, i had that memory
09:53:11 <ndm> i've offered to do an alternative installer
09:53:15 <ndm> based on the WinHugs one
09:53:19 <Igloo> It would be great if yhc/nhc could be supported by cabal too, so we can lose the Makefile.nhc98 files
09:53:36 <ndm> yhc is now a fork of nhc, we'll definately move to Cabal, nhc is unlikely to
09:56:07 <SamB> why so?
09:56:21 <ndm> because no one works on nhc much anymore
09:56:25 <SamB> ah
09:56:29 <SamB> thats a good reason ;-)
09:56:34 <gour> ndm: how much is yhc source-compatible with hugs/ghc for simple stuff?
09:56:46 <Igloo> Is there a plan for rank-2/rank-n types in yhc, BTW?
09:56:49 <ndm> gour: its compatible with Haskell 98, so yeah, pretty much
09:56:50 <SamB> gour: it should be totally compatible for simple stuff ;-)
09:56:59 <ndm> gour: once we get haskell.org base libraries, then substantially more so
09:57:06 <gour> great
09:57:24 <ndm> Igloo: there was, the SoC project went stone dead, but Tom picked up a few papers on rank-N types and went home for the weekend, so who knows
09:57:37 <Igloo> Heh, OK  :-)
09:57:55 <ndm> would be nice to kill the front and of Yhc, and replace it, just a question of time
09:58:00 <SamB> does this have anything to do with Data.Dynamic?
09:58:14 <ndm> no, we have Data.Dynamic already pretty much
09:58:19 <SamB> oh really?
09:58:28 <ndm> just in a different form, YHC.something
09:58:35 <ndm> just need a little bit of work to map the API's over
09:58:40 <ndm> since ours is more powerful :)
09:58:52 <SamB> where does it get types?
09:59:14 <ndm> no idea :)
09:59:15 <SamB> oh, is there a yhci?
09:59:20 <ndm> i think we have Data.Dynamic
09:59:47 <ndm> there is a yhe (which is what yhci would be), but its not been touched in a while
09:59:51 <ndm> basically does a yhc, yhi
10:00:18 <ndm> we even have gyhe, the graphical version of that
10:00:39 <ndm> http://www.haskell.org/haskellwiki/Yhc/Yhe
10:00:40 <lambdabot> Title: Yhc/Yhe - HaskellWiki
10:02:19 <SyntaxNinja> dcoutts dcoutts_ dcoutts__: alive?
10:02:28 <dcoutts__> @yarr!
10:02:28 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
10:02:33 <dcoutts__> ahem
10:02:37 <dcoutts__> hia SyntaxNinja :-)
10:02:40 <SyntaxNinja> hi!
10:03:00 <SyntaxNinja> Heya, I'm wondering how you're doing the cabal branch management.  are you just tagging trunk, or do you have another branch?
10:03:14 <dcoutts__> I've just been tagging the trunk
10:03:17 <SyntaxNinja> I was thinking of reorganizing it like an svn repo w/ cabal/branches cabal/trunk
10:03:32 <SyntaxNinja> dcoutts__: OK. maybe it would be better to have a "stable" or "release" branch or somethihng
10:03:40 <dcoutts__> aye, could do
10:03:41 <SyntaxNinja> but the problem is, how does GHC pick it up? just from the packages directory, 'eh?
10:03:58 <SyntaxNinja> that way we could commit the cabal-install stuff to the trunk
10:04:01 <dcoutts__> it's just cp
10:04:26 <dcoutts__> SyntaxNinja: actually ghc has a copy of the repo
10:04:36 <dcoutts__> and I've been pushing appropriate patches to both
10:04:58 <dcoutts__> they've already got one difference
10:05:03 <fasta> I only have one cost centre with %time 99.1 and %alloc 99.9 in my profile. What does that mean?
10:05:22 <ndm> fasta: you haven't inserted enough cost centres, or something is doing everything
10:05:26 <SamB> fasta: you need to add more cost centers!
10:05:29 <dcoutts__> SyntaxNinja: ghc has a copy under ghc-6.6/packages I think
10:05:38 <fasta> ndm: something is doing everything
10:05:43 <fasta> ndm: I do know that
10:06:10 <SamB> fasta: *everything*?
10:06:14 <dcoutts__> SyntaxNinja: on the other hand I think we're only talking a matter of a few days
10:06:21 <fasta> SamB: was that supposed to be a joke?
10:06:30 <SamB> no.
10:06:31 <dcoutts__> SyntaxNinja: so we can prepare the cabal-install integration in a branch
10:06:36 <dcoutts__> SyntaxNinja: is it ready then?
10:06:41 <fasta> SamB: ok, then how do I add more cost centers?
10:06:59 <fasta> SamB: dividing the function up in smaller pieces, I presume
10:07:05 <SamB> {-# SCC nameForCostCenter #-} before the expression, iirc...
10:07:06 <ndm> fasta: what command line did you use to compile for profiling
10:07:19 <ndm> and did you clean your .obj files before doing the profile build?
10:07:29 <fasta> ndm: +RTS -p
10:07:32 <SamB> and, yeah, there is an option to make a lot of cost centers...
10:07:43 <ndm> fasta: i meant to compile it, ghc ...
10:07:44 <SamB> fasta: that is for runtime!
10:08:08 <fasta> ndm: ghc --make -O -prof -auto-all Main.hs
10:08:19 <ndm> fasta: why -O ?
10:08:20 <fasta> SamB: I knew that, I was sleeping.
10:08:41 <ndm> fasta: -O changes your code loads, probably easier to profile without it
10:09:18 <SyntaxNinja> dcoutts__: see darcs/cabal-with-install :)
10:09:28 <dcoutts__> SyntaxNinja: ok cool
10:09:38 <SyntaxNinja> I don't know if "ready" is quite the term, but it would be good to have it in trunk.
10:09:43 <dcoutts__> right
10:09:49 <SyntaxNinja> but it can wait a few days, surely.
10:10:12 <dcoutts__> SyntaxNinja: It'd be useful to get an ETA on ghc-6.6 anyway
10:10:30 <dcoutts__> there's a bit of doc cleanups we could do with & release notes etc
10:10:36 <SamB> ndm: what does YHC_BASE_PATH need to be to get yhe working in-place?
10:11:08 <ndm> SamB: a pointer to the inst directory, after you've compiled yhc
10:11:26 <SamB> ndm: I am not a idiot! I know to compile before running!
10:11:27 <ndm> SamB: but i honestly doubt that yhe has any chance of working, its been quite a while
10:11:39 <dcoutts__> SyntaxNinja: that repo could do with tagging/ checkpiointing
10:11:41 <SamB> its doing remarkably well so far!
10:11:51 <ndm> SamB: i more meant that the inst directory isn't created until after :)
10:11:54 <dcoutts__> SyntaxNinja: get --partial still wants to pull in >700 patches
10:12:02 <dcoutts__> SyntaxNinja: I'm not sure my wifi can cope ;-)
10:12:07 <SyntaxNinja> dcoutts__: oh, btw, what's your name on monk?
10:12:21 <dcoutts__> SyntaxNinja: I'm duncan on darcs.h.o
10:12:28 <SyntaxNinja> dcoutts__: so what do you want me to do with it?
10:12:41 <dcoutts__> SyntaxNinja: darcs optimise --checkpoint
10:12:49 <SamB> @paste
10:12:50 <dcoutts__> SyntaxNinja: or actually I could do that
10:12:50 <lambdabot> http://paste.lisp.org/new/haskell
10:13:01 <fasta> This is my result of replacing calls to (++) with concat: http://pastebin.com/793453 Unfortunately, it's _way_ too slow.
10:13:13 <SyntaxNinja> dcoutts__: OK I added you to the 'hackage' group
10:13:20 <dcoutts__> oh, ta
10:14:02 <lisppaste2> SamB pasted "yhe screenshot" at http://paste.lisp.org/display/26635
10:14:55 <ndm> SamB: wow, that surprises me massively, what did you type make yhe ?
10:15:11 <ndm> i don't think scons is capable of building it, will file a bug for that
10:15:22 <fasta> Could any of you "efficiency gurus" take a look at that code?
10:15:43 <SamB> ndm: I cd'd into the directory, typed make, got some kind of an error about GTK types or something, looked at Makefile, and typed "make cmdline"
10:16:24 <ndm> SamB: neat :)
10:17:51 <SamB> then I typed ls, didn't see anything green, looked at Makefile again, and figured out it was in inst/bin already ;-)
10:18:30 <ndm> ah, yep, thats where it goes
10:18:41 <x3m> > let r = 25.0
10:18:41 <lambdabot>  Parse error
10:19:54 <roconnor> @type read
10:19:58 <lambdabot> forall a. (Read a) => String -> a
10:21:56 * SamB checks out YHC.Dynamic
10:22:56 <ndm> there are some other nice and completely unique API's in there
10:23:24 <SamB> hmm
10:23:54 <SamB> I notice that yhc doesn't have :b
10:24:06 <SamB> er, yhe, rather
10:24:11 <fasta> dons: ping
10:24:22 <ndm> SamB: Yhe has very little...
10:24:32 <SamB> ndm: point
10:25:21 <ndm> SamB: once we have Yhc.Bytecode in the repo, and move to binary .hi files inside the .hbc files, we'll get :b for free
10:25:23 <SamB> I suppose you can't write a proper interpreter until you get Yhc boostrapped...
10:25:58 <ndm> we can, its just a question of time
10:26:06 <SamB> hmm?
10:26:10 <SamB> you can which?
10:26:13 <ndm> and whether its worth it, we might just hop in with GuiHaskell, get everything for free
10:26:22 <ndm> we can write a proper interpeter, its just a question of time
10:26:29 <ndm> it doesn't need bootstrapping first
10:26:35 <SamB> hmm
10:26:40 <SyntaxNinja> dcoutts__: do you know anything about the cabal-put script?
10:26:46 <dcoutts__> SyntaxNinja: nope
10:27:32 * SyntaxNinja pokes xerox
10:28:40 <SamB> hmm
10:28:58 <SamB> what is this interleave doing at the bottom of YHC/Dynamic.hs?
10:29:06 <SamB> it doesn't seem to be used...
10:29:21 <ndm> SamB: no idea...
10:29:32 <ndm> SamB: never looked at that code ever :)
10:30:15 * SyntaxNinja wonders why in the heck xerox wrote it in perl
10:31:22 <xerox> Hey!
10:31:42 <xerox> Now you make it sound like a silly decision...
10:32:11 <monochrom> everyone has a past
10:33:03 <astrolabe> xerox is a perl coder?
10:33:06 * dcoutts__ is shocked that xerox knows perl
10:33:13 * xerox hides
10:33:30 <SamB> ndm: I think it is fairly new
10:33:57 <SamB> SyntaxNinja: what would *you* use?
10:34:00 <SamB> honestly?
10:34:11 <xerox> SyntaxNinja: I was trying to do it as a simple shell script, but it was not so simple, and I started using perl because it did some of the things the shell wasn't doing.
10:34:20 <SamB> dcoutts__: or you?
10:34:55 <dcoutts__> SamB: that's a silly question, Haskell of course
10:35:17 <dcoutts__> oh honnestly, I might use bash
10:35:33 <xerox> dcoutts__: right, it was becoming complex with bash
10:36:08 <dcoutts__> I can't really comment/criticise I don't understand the task
10:37:24 <SamB> I probably would have started with bash or zsh myself...
10:38:25 * SamB adds a function to YHC.Internal and YHC.Dynamic
10:38:29 <pianodogg> is there some prejudice against perl?
10:38:33 <dcoutts__> yes
10:38:44 <pianodogg> that was fast :)
10:38:53 <dcoutts__> it's an easy question :-)
10:39:31 <pianodogg> what is its basis?
10:39:37 <ndm> SamB: feel free to send patches over to the yhc@ list
10:39:42 <SamB> the Evil Mangler is disappointing
10:39:45 <dcoutts__> does prejudice need any basis?
10:39:50 <SamB> it does not live up to its name very well
10:40:01 <roconnor> yay, my article complies!
10:40:01 <ndm> @quote ndm
10:40:02 <lambdabot>  outside of haskell i know roughly as many satan worshipers as christians.
10:40:04 <ndm> @quote ndm
10:40:04 <lambdabot>  i once had a boss who complained because some code someone had written crashed, and yet "it clearly says in the company coding guidelines not to write code that crashes"
10:40:06 <ndm> @quote ndm
10:40:06 <lambdabot>  This was not said by me
10:40:11 <ndm> @quote ndm
10:40:11 <lambdabot>  it needs a rewrite to support the wacky features i want to add, at amazing speed
10:40:18 <ndm> boo, i can't get the right quote
10:40:24 <ndm> there needs to be some quote and search mode
10:40:25 <xerox> SyntaxNinja: I think Cabal Makefile does not the right thing in trying to compile cabal-install now.  It tries to use `setup' built from Setup.hs, while it should use the makefile.  But I don't know how to do it cleanly.
10:40:31 <ndm> since in one i explain the reasons why perl is wrong
10:40:38 <SyntaxNinja> SamB: I use Haskell for this kinda thing all the time.
10:40:41 <SamB> ndm: you can add it easily ;-)
10:40:48 <xerox> SyntaxNinja: not that now it does it cleanly, namely it doesn't `make clean' cabal-install/ on `make clean' in Cabal/.
10:40:57 <ndm> SamB: but its much nicer to have other people committing stuff :)
10:40:59 <pianodogg> SamB: what does that mean?
10:41:00 <xerox> SyntaxNinja: and neither does for cabal-setup if I understand correctly.
10:41:01 <Korollary> ndm: Then it doesn't sound like prejudice. Perhaps informed opinion?
10:41:12 <xerox> SyntaxNinja: can I push to that new repo yet?
10:41:13 <pianodogg> you mean it's not particularly practical at extracting and reporting?
10:41:16 <ndm> Korollary: true
10:41:21 <SyntaxNinja> xerox: should be able to, yeah.
10:41:23 <SamB> pianodogg: the Evil Mangler is also known as ghc-asm
10:41:27 <SamB> and it is written in PERL
10:41:28 <xerox> SyntaxNinja: OK.
10:41:31 <ndm> pianodogg: no, its ugly and crap :)
10:41:38 <SyntaxNinja> xerox: you're talking abou the cabal-with-install one?
10:41:41 <SyntaxNinja> hi bringert
10:41:53 <SyntaxNinja> xerox: cabal-put doesn't seem to work for me at all..
10:41:55 <SamB> pianodogg: actually I heard that PERL no longer officially stands for anything
10:42:00 <bringert> hi SyntaxNinja
10:42:05 <SyntaxNinja> $ cabal-put hnop-0.1.tgz
10:42:05 <SyntaxNinja> syntax error at /usr/local/bin/cabal-put line 9, near "my "
10:42:05 <SyntaxNinja> Global symbol "$in_file" requires explicit package name at /usr/local/bin/cabal-put line 9.
10:42:05 <SyntaxNinja> Global symbol "$in_file" requires explicit package name at /usr/local/bin/cabal-put line 12.
10:42:06 <SyntaxNinja> (etc)
10:42:12 <xerox> SyntaxNinja: yes, cabal-with-install
10:42:17 <SamB> goes to show how out of date Debian packages are ;-)
10:42:41 <SyntaxNinja> xerox: what's wrong w/ using 'setup' built from Setup.hs?
10:42:43 <pianodogg> perl is fine if you just need shell-script + sanity
10:42:44 <bringert> SyntaxNinja: did you recover from meeting all those weird people yet?
10:43:00 <pianodogg> where sanity is some data structures and ways of slinging them around
10:43:03 <SamB> hehe
10:43:05 <SyntaxNinja> bringert: yeah, but anna is still scared ;)
10:43:06 <xerox> SyntaxNinja: it needs to be called "foo-ver.tar.gz" we said
10:43:17 <xerox> Strangely it doesn't tell you that, but it have should
10:43:23 <SamB> the evil mangler uses a *bit* more, I think, than shell + sanity
10:43:25 <SyntaxNinja> xerox: ah, so sdist needs fixed.
10:43:27 <SamB> but not a whole lot
10:43:27 <bringert> SyntaxNinja: nerd overload?
10:43:40 <dcoutts__> xerox, ideally we should not need the Makefile to build cabal-install, we should just be able to build it using the main Cabal.cabal file
10:43:45 <SyntaxNinja> xerox: I got the same error
10:43:56 <xerox> dcoutts__: there is the configuration directory to be set up
10:44:02 <SyntaxNinja> dcoutts__: you mean as an .exe?
10:44:07 <xerox> dcoutts__: that's why SyntaxNinja asked for a Makefile in first place
10:44:21 <dcoutts__> SyntaxNinja: right (I think)
10:44:40 <dcoutts__> xerox, so we can add that to the Setup.hs right ?
10:44:53 <dcoutts__> Makefiles are no good for non-unix
10:45:03 <dcoutts__> ndm: see I'm being good! :-)
10:45:05 <SyntaxNinja> the makefile is strictly for bootstrapping; generating the initial setup executable
10:45:07 <SamB> dcoutts: how do you add that?
10:45:22 <xerox> SyntaxNinja: it works for me (i.e. cabal-put asdasd says the name is wrong.)
10:45:30 <ndm> dcoutts++
10:45:33 <SamB> does Cabal support config dirs?
10:45:43 <xerox> $ cabal-put hnow-1.5.tgz
10:45:43 <xerox> Invalid format - require PACKAGE-VERSION.tar.gz (foo-1.0.tar.gz) at /home/paolo/bin/cabal-put line 13.
10:45:44 <dcoutts__> SyntaxNinja: yep, I know. and it even works now to use runhaskell Setup.hs
10:45:48 <xerox> dcoutts__: it can do so?  How?
10:45:48 <fasta> How much less is the amount of storage of an Int than an Integer?
10:46:07 <dcoutts__> fasta: depends on the size of the Integer
10:46:16 <ndm> fasta: Int is 32 bits, Integer is big enough, plus some overhead
10:46:19 <pianodogg> why is the mangler evil then, precisely
10:46:29 <pianodogg> besides having been expressed in perl
10:46:31 <dcoutts__> pianodogg: see the ghc commentary
10:46:32 <SamB> ndm: uh
10:46:38 <SamB> ndm: not in *most* systems...
10:46:44 <fasta> dcoutts__: assuming the Integer value fits in the Int.
10:46:47 <SamB> Int has some overhead too
10:46:50 <dcoutts__> xerox, so what do you need to do exactly ?
10:47:05 <SamB> anyway, it'll probably be three words of overhead to use an Integer?
10:47:21 <dcoutts__> xerox, and what's wrong with sdist ?
10:47:23 <SamB> or if it has a strict field, maybe one word
10:47:25 <xerox> dcoutts__: cp -r etc-cabal-install /etc/cabal-install
10:47:30 <ndm> dcoutts__, i hope that we'll get a new Gtk2hs for windows release the same day as GHC comes out?
10:47:39 <dcoutts__> ndm: hah hah. no.
10:47:53 <xerox> dcoutts__: or cp -r etc-cabal-install ~/.cabal-install depending upon what the user needs
10:47:53 <dcoutts__> ndm: but some time.
10:48:08 * SamB checks :i Integer
10:48:09 <xerox> Otherwise is just creating such directory and copy serv.list in it.
10:48:16 <dcoutts__> xerox, how many files are there ? is it just one ?
10:48:19 <xerox> Yes.
10:48:27 <dcoutts__> xerox, you can do that already
10:48:42 <dcoutts__> xerox, though you can't put that in /etc by that method
10:48:45 <pianodogg> ugh
10:48:50 <xerox> How do I decide wethere to use the sistem-wide or the local?
10:48:52 <pianodogg> such evilness is not perl's fault
10:49:06 <xerox> Right..
10:49:38 <dcoutts__> xerox, not sure if you can find out if you're doing a --user or --global install, ask SyntaxNinja
10:49:42 <pianodogg> well it is perl's fault in the sense that it does not mandate sound software engineering
10:50:14 <xerox> Boing boing..
10:50:28 <pianodogg> but the very nature of this mangler is "big fat hack" so i'm not sure that it is perl that makes it evil
10:50:54 <dcoutts__> pianodogg: right, it's evil because it's a big fat hack, not because of perl
10:51:26 <dcoutts__> though it being perl means noone understands it
10:51:50 <pianodogg> short of the author... and even that's questionable, i suppose.  perl is write-only
10:52:16 <pianodogg> perl is great for tasks requiring roughly < 200 lines of perl code.  above that perl is just not the way to go imho
10:52:26 <xerox> Yes.  It was meant as a short-term mean of adding packages to my short-term unstable local package hierarchy.
10:52:32 <xerox> So I thought it was okay.
10:52:50 <dcoutts__> SyntaxNinja: do we have any way to install a user config file? it doesn't obey the prefix system well
10:53:09 <dcoutts__> SyntaxNinja: since it has to be ~/.blah not $PREFIX/.blah
10:53:35 <dcoutts__> SyntaxNinja: ie data-files isn't quite enough I think
10:53:48 <SyntaxNinja> xerox: he's talking about the evil mangler, not your cabal-put :)
10:54:15 <SamB> fasta: actually, yeah, the only overhead on Int-sized Integers in GHC should be the tag field that says which constructor it is...
10:54:19 <SyntaxNinja> lemmy switch to wifi...
10:54:51 <SyntaxNinja> > print "hmm"
10:54:53 <lambdabot>  Pervert!
10:55:04 <SamB> hahaha
10:55:16 <SyntaxNinja> oh yeah
10:55:17 <dmhouse> Heh, is that the new 'No IO' message?
10:55:23 <SamB> lambdabot: you have been watching too much Anime!
10:55:26 <dmhouse> > putStrLn "foo"
10:55:28 <lambdabot>  Pervert!
10:55:31 <dmhouse> Love it.
10:55:36 <Korollary> That is so newbie friendly.
10:56:00 <monochrom> This is truely perverted.
10:56:11 <SyntaxNinja> xerox: we're not knocking your perl script :)
10:56:12 <SamB> trying to establish lambdabot's gender more firmly, eh?
10:56:54 <SamB> pianodogg: I still say the evil mangler is disappointing
10:56:58 <SyntaxNinja> > "newbie friendly"
10:57:02 <lambdabot>  "newbie friendly"
10:57:07 <monochrom> Am I alone in thinking that so-called "obscure" error messages are to the point, and so-called "user-friendly" error messages are meaningless?
10:57:18 <SyntaxNinja> > let question="are you newbie friendly" in "yes"
10:57:20 <lambdabot>  "yes"
10:57:20 <SamB> monochrom: you are!
10:57:28 <dmhouse> monochrom: sometimes.
10:57:34 <pianodogg> SamB: oh i agree, but that's a design problem, not a language problem
10:57:43 <sieni> monochrom: yes, error messages like "lp1 is on fire" are fun
10:57:44 <dmhouse> You often have to understand quite a lot of Haskell theory to get the most basic of error messages, though.
10:57:52 <dmhouse> So newbies are easily confused.
10:57:52 <xerox> monochrom: no I'm with you!
10:57:59 <SyntaxNinja> dcoutts__: it would be handy to have such a thing. do we even have a sense of 'global config directory" is that what 'data-files' is? does that stuff go in /etc?
10:58:02 <florenz> hi
10:58:19 <florenz> is there a possibility to get a backtrace out of ghc?
10:58:23 <SamB> monochrom: the user-friendly error messages are just non-discriminatory
10:58:30 <Lemmih> florenz: Not really.
10:58:36 <dmhouse> florenz: not GHC directly, but you can try something like Hat.
10:58:37 <SyntaxNinja> xerox: hm. I actually moved it to /usr/local/bin, so maybe that's why I'm getting the errors.  is there more than one file? does it need to live in a aparticular place?
10:58:38 <florenz> something similair?
10:58:49 <dcoutts__> SyntaxNinja: no, data-files goes in share somewhere on unix and somewhere else on win32. it's not for /etc style config though
10:58:51 <dmhouse> ?where Hat
10:58:52 <lambdabot> www.haskell.org/hat/
10:58:54 <SyntaxNinja> xerox: when I run it from your dir I get a different result (can't make directory)
10:58:56 <sieni> florenz: is similair a lair for simis?
10:59:07 <xerox> SyntaxNinja: hehe yuck, /home/paolo/bin/cabal-put
10:59:11 <SyntaxNinja> dcoutts__: ok, didn't think so.  so there's nothing for /etc style configs
10:59:18 <xerox> Hm, which directory, SyntaxNinja?
10:59:19 <florenz> sieni: no, it's similar
10:59:22 <dcoutts__> SyntaxNinja: not so far as I know.
10:59:22 <SyntaxNinja> xerox: yeah, that's the one I tried. is the script immovable?
10:59:22 <SamB> xerox: what? you don't like ~/bin?
10:59:30 <SyntaxNinja> xerox: /usr/local/bin/cabal-put
10:59:32 <xerox> SamB: I do.
10:59:49 <dcoutts__> SyntaxNinja: one could implement it in Setup.hs but I fear it might not work.
10:59:57 <florenz> does hat work with ghc 6.4.2?
11:00:01 <SamB> pianodogg: I was more disappointed by the *lack* of evil than by the evil
11:00:07 <dcoutts__> SyntaxNinja: not work with setup copy that is, ie it'll not work for distros.
11:00:22 <pianodogg> SamB: ? elaborate
11:00:33 <xerox> SyntaxNinja: it wasn't meant to be used like that, I am not sure it makes a difference, though
11:00:41 <ndm> florenz: windows or linux?
11:00:42 <SyntaxNinja> xerox: does it work for you?
11:00:50 <florenz> ndm: linux
11:00:58 <ndm> florenz: yes, you need hmake though
11:01:01 <dcoutts__> SyntaxNinja: I see people sometimes trying to install files in Setup.hs, this rairly works correctly because they don't think about the installing into a temp dir issue. Hence for gentoo we often have to patch them.
11:01:08 <SamB> pianodogg: I was expecting it to be harder to work with
11:01:10 <ndm> florenz: if it doesn't work email hat -at- haskell.org
11:01:10 <xerox> Nope, SyntaxNinja
11:01:16 <florenz> ndm: ok, thanks, i'll try.
11:01:20 <SyntaxNinja> xerox: wanna fix it? :)
11:01:35 <pianodogg> SamB: to justify rewriting it in something other than perl? : )
11:01:36 <SyntaxNinja> dcoutts__: yeah, it seems like a good idea.
11:02:05 <xerox> can you delete it SyntaxNinja ?
11:02:27 <SamB> I changed it once to keep the code/data indicators that get used by objdump to determine whether to disassemble or hexdump in, instead of dropping them on the floor...
11:02:28 <SyntaxNinja> xerox: yeah, sure, but I gave you write permission to it so you could mod it.
11:02:36 <SamB> and it was surprisingly simple to do this
11:02:50 <xerox> SyntaxNinja: I was going to ln my ~bin which is a bit different
11:03:04 <xerox> SyntaxNinja: I'll trying copying it over
11:03:10 <SyntaxNinja> xerox: thanks
11:03:12 <SamB> I lost the changes though, I'm pretty sure
11:03:14 <xerox> Done.
11:03:21 <pianodogg> still it is insanely brittle to depend on the precise output syntax of something as insane as gcc
11:03:21 <SamB> because I didn't think it was very useful
11:03:31 <SamB> yeah, I guess
11:03:38 <SamB> but it works pretty well considering ;-)
11:03:42 <pianodogg> right
11:03:53 <xerox> SyntaxNinja: hope it works for you, it worked for Igloo.
11:03:55 <SyntaxNinja> xerox: I'm moving stuff to //srv/www/hackage.haskell.org/public_html/packages/unstable
11:04:00 <SamB> and the code is surprisingly simple considering, too...
11:04:02 <SyntaxNinja> xerox: can you update that?
11:04:05 <xerox> Then I need to adjust the put
11:04:34 <SyntaxNinja> Lemmih: alive?
11:05:02 <SamB> hmm...
11:05:03 <xerox> SyntaxNinja: done, hopefully.
11:05:31 <SyntaxNinja> I find that it's rarely worthwhile to write in perl or bash. once it gets above a few lines, I always want to create some kind of abstraction.
11:05:39 <SyntaxNinja> xerox: Couldn't create "/srv/www/hackage.haskell.org/public_html/packages/unstable/hnop":  at /usr/local/bin/cabal-put line 43, <$fh> line 10.
11:05:47 <xerox> SyntaxNinja: :(
11:05:49 <SyntaxNinja> I think you have to fix the case where the directory already exists.
11:07:43 <pianodogg> SyntaxNinja: you can design abstractions in perl; perl just doesn't enforce them very well
11:08:23 <SamB> pianodogg: I think it is also a lot of work?
11:09:08 <SyntaxNinja> pianodogg: of course, you can build abstractions in any language; Haskell is just the best for it :)  so when I say "I want to create some kind of abstraction" it's obvious that I want Haskell ;)
11:10:42 <pianodogg> yes of course.  for all of perl's methods of hurling data around, one thing it lacks is a real notion of datatype
11:13:34 <SyntaxNinja> xerox: are you hacking at that?
11:14:45 <xerox> Yes
11:14:47 <xerox> Does it work now?
11:15:04 <SyntaxNinja> cabal-put hnop-0.1.tar.gz
11:15:04 <SyntaxNinja> Not enough arguments for opendir at /usr/local/bin/cabal-put line 44, near ""$pkgdir")"
11:15:04 <SyntaxNinja> Execution of /usr/local/bin/cabal-put aborted due to compilation errors.
11:15:15 * SyntaxNinja does the type-checking dance ;)
11:15:35 <dmhouse> ?remember SyntaxNinja * SyntaxNinja does the type-checking dance ;)
11:17:08 <pianodogg> if he's type-checking haskell, that dance probably resembles voodo
11:17:14 <pianodogg> voodoo even
11:17:44 <xerox> SyntaxNinja: try now
11:18:41 <SyntaxNinja> xerox: no output! :)
11:19:29 <xerox> For one time I have a good answer!
11:19:30 <SyntaxNinja> yay works!
11:19:31 <xerox> cat /srv/www/hackage.haskell.org/public_html/packages/unstable/log
11:19:35 <xerox> Eh!
11:19:47 <xerox> Tue Sep  5 15:37:35 2006 --- igloo adds package "iconv" version "0.2".
11:19:47 <xerox> Sun Sep 24 11:18:12 2006 --- ijones adds package "hnop" version "0.1".
11:20:26 <xerox> But I think tar should not put the log in the index tarball, yuck :P
11:20:30 <SyntaxNinja> dcoutts__, bringert: got anything to upload
11:20:54 <bringert> SyntaxNinja: cabal packages? sure, lots of them
11:21:02 <xerox> I've put many of bringert
11:21:06 <dcoutts__> SyntaxNinja: my zlib & bzlib packages
11:21:16 <xerox> dcoutts__: those would be nice indeed
11:21:23 <SyntaxNinja> dcoutts__: could you try it out?
11:21:24 <bringert> yeah, xerox probably did most of mine already
11:21:44 <SyntaxNinja> the problem right now is that the version of ghc on hackage has cabal 1.0, which calls things .tgz instead of .tar.gz
11:21:44 <dcoutts__> SyntaxNinja: sure, how?
11:22:06 <SyntaxNinja> dcoutts__: on your ocmputer, ./setup sdist, copy the tarball to monk, ssh to monk and run "cabal-put foo-1.0.tar.gz"
11:22:14 <dcoutts__> ok
11:22:16 <xerox> cgi, exif, fast-cgi, gd, hask-home, http?, parsedate, rss, xhtml, from bringert
11:22:24 <SyntaxNinja> thanks bringert ;)
11:22:38 <SyntaxNinja> I just emailed Lemmih asking him to resurrect the web interface :)
11:22:48 <xerox> In fact I had to a bit of manual work.
11:23:03 <SyntaxNinja> xerox: can you link your packages/unstable directory over to the new global one?
11:23:17 <xerox> SyntaxNinja: sure.
11:23:30 <SyntaxNinja> I just pushed a patch to make that the default.
11:23:37 <xerox> Right.
11:23:50 <bringert> xerox: did you have to hack my cabal files for it to work? I don't think I have enough other-files and such
11:23:54 <SyntaxNinja> does anyone else have any cabal packages they want to try uploading?
11:24:12 <musasabi> is there an automated script that could be used for that?
11:24:42 <SyntaxNinja> musasabi: right now you have to run it on monk.haskell.org, but eventually you could run it on your own machine. we just want to get started w/ the fewest moving parts :)
11:25:46 <SamB> ndm: oh, I'm not on the YHC list exactly. Is my mail still going to get through?
11:25:48 * musasabi does not have a monk.h.o account
11:26:03 <ndm> SamB: maybe, maybe not
11:26:12 <ndm> it might get caught in the spam trap...
11:26:22 <SyntaxNinja> musasabi: that's the main problem w/ this approach, but maybe xerox can upload your package for you?
11:26:22 <ndm> i'm not a list admin though, so can't let it through :(
11:26:27 <SamB> patches don't usually look much like spam do they?
11:27:05 <ndm> SamB: i think the haskell.org auto moderates everything from people not on the list
11:27:05 <bringert> whoa, my ghc tree is 1.7 GB?
11:27:13 <ihope> > 59 + 95
11:27:15 <lambdabot>  154
11:27:21 <ihope> > 59 + 451
11:27:24 <lambdabot>  510
11:27:29 <SamB> ndm: it has a good spam filter though right?
11:27:34 <ihope> > 154 + 451
11:27:36 <lambdabot>  605
11:27:36 <SamB> because if it doesn't I'm sunk
11:27:41 <ndm> SamB: not really :(
11:27:44 <musasabi> SyntaxNinja: that is useful for once in a time things, but seems painful for the future.
11:27:51 <dcoutts__> SyntaxNinja, xerox: cabal-put asks me "rm: remove write-protected regular file `/srv/www/hackage.haskell.org/public_html/packages/unstable/00-index.tar.gz'?"
11:27:53 <ndm> SamB: send it to me too, ndmitchell -at- gmail -dot- com
11:28:06 <ndm> SamB: if it doesn't get through instantly, i'll resend it
11:28:27 <SyntaxNinja> dcoutts__: xerox: the script should make sure that everything is owned by group hackage and writable by group
11:28:34 <xerox> dcoutts__: umask problems :(
11:28:44 <musasabi> I am interested to get various packages there, but I'd like to make it a solution that works upon new releases - otherwise there will be old releases there as I keep forgetting to bug people to upload new versions.
11:28:49 <dcoutts__> SyntaxNinja: that'll be becasue it's owned by you and your group  too
11:28:53 <xerox> dcoutts__: we discussed it by I wasn't sure about how to fix it
11:29:01 <dcoutts__> -rw-rw-r--  1 ijones ijones
11:29:44 <dcoutts__> xerox, the directory needs to be group hackange with the sticky bit set
11:29:56 <dcoutts__> then any files created there will have the same group
11:29:59 <xerox> Alright, SyntaxNinja is the one that can do it I think
11:30:32 <SyntaxNinja> OK fixed ownership
11:30:43 <SyntaxNinja> can someone give me hte comand to set the sticky bit so I don't haveto look it up? :)
11:30:47 <dcoutts__> SyntaxNinja: oops, just unfixed it
11:31:03 <dcoutts__> SyntaxNinja: by "cabal-put"ting another package
11:31:38 <SyntaxNinja> hehe
11:31:55 <dcoutts__> SyntaxNinja: so what we need to do is set the group sticky bit on everything
11:32:44 <dcoutts__> SyntaxNinja: ie: chmod -R g+s unstable
11:32:54 <SamB> ndm: did it get through?
11:33:03 <SamB> the gmane web interface is down...
11:34:01 <SyntaxNinja> ok
11:34:34 <SyntaxNinja> xerox: where does cabal-install hide away the package tarballs?
11:35:02 <xerox> SyntaxNinja: good question.
11:35:07 <SamB> heh
11:35:16 <SamB> xerox: you don't know?
11:35:29 <xerox> I'm not sure, I didn't write that code.
11:35:36 <SamB> ah
11:35:58 <_deepfire> leave
11:35:59 <xerox> Ah, the tarballs!
11:36:07 <SyntaxNinja> bringert: is haskell-home yours?
11:36:10 <xerox> The tarballs are just in config-dir/packages/ SyntaxNinja.
11:36:15 <xerox> SyntaxNinja: yep.
11:36:35 <SyntaxNinja> bringert, xerox: can you show me example output from haskell-home?
11:36:46 <araujo> hi!
11:36:47 <bringert> SyntaxNinja: yes
11:37:03 <bringert> SyntaxNinja: http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/doc/
11:37:10 <lambdabot> http://tinyurl.com/o92b9
11:39:37 <x3m> !paste
11:39:46 <x3m> @paste
11:39:46 <lambdabot> http://paste.lisp.org/new/haskell
11:39:50 <dmhouse> ?where paste
11:39:51 <lambdabot> http://paste.lisp.org/new/haskell
11:39:58 <xerox> Dinner! BBL.
11:40:00 <mauke> ?why paste
11:40:01 <lambdabot> Maybe you meant: ghc what wn
11:40:18 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26636
11:40:34 <SyntaxNinja> bringert, xerox: Hmm. maybe we can make a web interface for hackage-uploaded packages from haskell-home.
11:40:45 <dmhouse> x3m: indent the lines x1..e
11:41:05 <araujo> yay!,
11:41:08 <araujo> h.o back
11:41:30 <SyntaxNinja> araujo: does anyone know why it was down?
11:41:35 <x3m> ah ok
11:41:43 <Bourbaki> moin
11:41:54 <dcoutts__> SyntaxNinja, xerox: ok both my packages are up
11:42:00 <araujo> SyntaxNinja, i have been asking that for these last two days here, but apparently nobody (in here) knew
11:42:02 <lisppaste2> dmhouse annotated #26636 with "correct layout" at http://paste.lisp.org/display/26636#1
11:42:10 <dmhouse> x3m: try something like that.
11:42:32 <SyntaxNinja> dcoutts__: coolness. does the permissions look right?
11:42:40 <dcoutts__> araujo: if it's the same reason as before then it's due to hung connections, but I don't know why they happen.
11:42:42 <araujo> SyntaxNinja, it'd be nice if we could get a mirror
11:42:45 <SyntaxNinja> bringert: does haskell-home need just a .cabal file for input?
11:42:52 <dcoutts__> SyntaxNinja: lemme check...
11:43:16 <ndm> SamB: I got a copy, have forwarded it on to the yhc list
11:43:30 <araujo> dcoutts__, i see, well, the box seemed to be up, it looked like it was a problem with the web service.
11:43:34 <bringert> SyntaxNinja: as far as I remember, yes. It also uses a DESCRIPTION file if there is one, in hmarkup format
11:43:49 <dcoutts__> araujo: yes, hung connections to the web server preventing new connections.
11:43:58 <bringert> it makes some assumptions about directory layout and darcs I think
11:43:58 <araujo> ya
11:44:05 <bringert> but that should be easy to fix
11:44:07 <x3m> dmhouse: thx, gonna go and shop some food before continuing
11:44:24 <bringert> it was a quick hack for me to avoid the work of keeping up to date home pages for each package
11:44:41 * araujo goes and gets some food
11:44:55 * dmhouse wonders what the easiest way of installing Hope is
11:45:11 <dmhouse> cabal-install requires that I upgrade my Cabal.
11:45:12 <SyntaxNinja> xerox: should a user be able to run update/ mayb I broke that?
11:45:23 <dcoutts__> SyntaxNinja: yes. Though I don't know what g+s means on files.
11:45:26 <SyntaxNinja> dmhouse: what cabal version do you have?
11:45:30 <dmhouse> SyntaxNinja: 1.1.4
11:45:41 <SyntaxNinja> dmhouse: is it the problem with FilePath being hidden or what?
11:46:01 <dmhouse> SyntaxNinja: something like that. I'll find the paste.
11:46:11 <SyntaxNinja> dcoutts__: sweet. I see the libs :)
11:46:58 <dmhouse> SyntaxNinja: http://paste.lisp.org/display/26627
11:48:05 <SyntaxNinja> dmhouse: yeah, you'll need a version where it's not hidden :( you could grab cabal head if you want: http://darcs.haskell.org/cabal-with-install/
11:48:08 <lambdabot> Title: Index of /cabal-with-install
11:48:51 <SyntaxNinja> dcoutts__: while installing zlib:
11:48:51 <SyntaxNinja> Stream.hsc:258:26: Not in scope: `nullForeignPtr'
11:48:51 <SyntaxNinja> Stream.hsc:258:41: Not in scope: `nullForeignPtr'
11:49:03 <dmhouse> SyntaxNinja: is cabal-install stable enough to warrant me upgrading my Cabal now?
11:49:40 <SyntaxNinja> dmhouse: depends on your standards, of course.  if you want to help beta test it.
11:51:01 <dmhouse> SyntaxNinja: Tbh I'd just like to get Hope installed at the moment. :) Although if you desperately need more beta testers...
11:51:37 <dcoutts__> SyntaxNinja: oh, hmm. I need to be more specific about what version of fps I need.
11:53:30 <bringert> dmhouse: let me know if there are problems with any of my packages along the way
11:56:00 <Igloo> g+s on files is the same as u+s, but it defines the group the program runs as
12:05:00 <defcon8> do haskell interpreters customise recursive code?
12:05:33 <dmhouse> Customise in what way?
12:11:39 <defcon8> dmhouse, dunno :|
12:11:48 * SamB wonders how long it will take tom shackell to figure out that dynamic typing requires you to pass types around
12:12:42 <SamB> defcon8: give an example?
12:12:45 <dmhouse> defcon8: why do you ask?
12:12:55 <defcon8> don't know that either
12:13:34 <dmhouse> You don't know why you asked that question?
12:13:37 <SamB> if you don't know what the question means or why you ask...
12:13:50 <SamB> well, you don't really want an answer do you?
12:15:11 * SamB wishes he could use a compacting garbage collector with his UM...
12:16:21 <dmhouse> SamB: still hacking on ICFP contest stuff?
12:16:38 <dmhouse> Hi waern, finished with Haddock?
12:16:46 <x3m> dmhouse: in the code from the paste before with quadeq, how can we have like: d = b * b - 4 * a * c  after x2 = e - sqrt d / (2 * a) in the code?
12:16:51 <emu> haskell compilers apply special customization tricks which take a function and compute the answer1
12:16:54 <SamB> dmhouse: bartw showed me his method to bypass the censory engine
12:17:05 <SamB> and I'm trying it out
12:17:07 <x3m> that is, use d before it has been assigned a value
12:17:18 <SamB> its taking forever though
12:18:14 <waern> dmhouse, I think there'll always be more work to do :)
12:18:23 <dmhouse> SamB: did you see the video dons emailed a link to on one of the mailing lists?
12:18:53 <SamB> dmhouse: hmm, the one from the ICFP presentation of the results?
12:18:58 <dmhouse> SamB: right.
12:19:03 <SamB> I looked at it
12:19:07 <SamB> but it was SOOO JERKY
12:19:08 <dmhouse> x3m: order of bindings in a let block doesn't matter.
12:19:12 <dmhouse> Yeah, same here.
12:19:27 <dmhouse> Glad that wasn't a problem with my cache then :)
12:19:36 <dmhouse> The audio also gets properly out of sync later on.
12:19:38 <SamB> your cache?
12:19:50 <dmhouse> Really, they should just publish a PDF of the slides and an audio file.
12:20:01 <SamB> there was audio?
12:20:17 * SamB should try downloading it on his other computer
12:20:22 <dmhouse> I figured my video program wasn't using enough memory to cache the video.
12:20:26 <dmhouse> Yeah.
12:20:52 <dmhouse> waern: good stuff, I'll have to check out your work at some point.
12:20:55 <SamB> FWIW, its 15 fps with an obsene time between keyframes
12:21:13 <SamB> only spelled better...
12:22:25 <dmhouse> An obscene time? As in, not 1/15 seconds?
12:22:25 <waern> dmhouse, I'd be glad if you did that.. it's quite easy as well.. just grab ghc.haddock and haddock.ghc and compile them in the right order ;)
12:22:40 <waern> dmhouse, you also need a Cabal patch that isn't in yet
12:22:56 <SamB> keyframes are the frames which are encoded independent of all other frames
12:23:11 <dmhouse> Oh, sorry.
12:23:15 <SamB> so if the player gets behind, it can skip to the next one
12:23:28 <dmhouse> waern: sure.
12:23:36 <SamB> (or, if the user clicks on the seek bar, etc.)
12:23:37 <dmhouse> waern: when I find time, thne.
12:23:43 <dmhouse> SamB: right, that makes sense.
12:23:57 <dmhouse> So who filmed it?
12:24:03 <SamB> I forget
12:24:18 <dmhouse> I think it was a Haskell guy, they zoomed in on the word 'Haskell' at one point and laughed an SPJ-related joke in the intro.
12:24:34 <SamB> google the URL with site:tunes.org
12:24:45 <SamB> yes, it was one of ours ;-)
12:24:53 <SyntaxNinja> xerox: could you mod the cabal-install script to take another (optional?) param?  the sub-directory to install stuff into; ie "unstable" or "testing-6.6"
12:25:07 <SamB> anyway, the first reference in the logs of this channel should be by him
12:25:21 <dmhouse> Ah, it was Malcolm Wallace.
12:25:28 <dmhouse> (From dons's email.)
12:26:18 <dmhouse> Does he IRC?
12:26:28 <SamB> he announced it here
12:26:36 <SamB> so, sometimes yes ;-)
12:27:06 <SamB> he also asked about interest before doing it
12:27:48 <dmhouse> The URL doesn't have any hits.
12:28:01 <SamB> you must have extra stuff on it?
12:28:30 <SamB> @google ICFP contest results google video
12:28:31 <dmhouse> I'll try going via meme's search rather than Google.
12:28:34 <lambdabot> http://programming.reddit.com/info/jbho/comments/cjbis
12:28:34 <lambdabot> Title: ICFP programming contest 2006 results: video stream (reddit.com)
12:28:42 <SamB> hmm
12:28:54 <SamB> @google ICFP contest results google video site:mailarchive.com
12:28:56 <lambdabot> No Result Found.
12:29:02 <SamB> @google ICFP contest results google video site:haskell.org
12:29:04 <lambdabot> http://www.haskell.org/pipermail/haskell/2006-May.txt
12:29:18 <SamB> hmm, Google needs more inteligence...
12:29:18 <roconnor> @where icfp-video
12:29:19 <lambdabot> I know nothing about icfp-video.
12:29:36 <roconnor> @where contest-video
12:29:36 <lambdabot> I know nothing about contest-video.
12:29:45 * SamB forgets what the URL is...
12:29:53 <roconnor> lambdabot knows
12:29:55 <SamB> and I think gmane web interface is down too?
12:30:02 <SamB> @help where
12:30:04 <lambdabot> where <key>. Return element associated with key
12:30:05 <roconnor> @where icfpcontest-video
12:30:06 <lambdabot> I know nothing about icfpcontest-video.
12:30:09 <roconnor> @where icfp-contest-video
12:30:10 <lambdabot> I know nothing about icfp-contest-video.
12:30:16 <SamB> @what-key ICFP results
12:30:17 <lambdabot> Unknown command, try @list
12:30:44 <roconnor> @where programmingcontest-video
12:30:44 <lambdabot> I know nothing about programmingcontest-video.
12:30:45 <SyntaxNinja> ghc gets built nightly on darcs.haskell.org, right?
12:30:55 <dmhouse> meme's search is timing out.
12:31:03 <roconnor> @where icfp2006-video
12:31:04 <lambdabot> I know nothing about icfp2006-video.
12:31:05 <roconnor> bah
12:31:06 <SamB> dmhouse: what URL do you have?
12:31:27 <roconnor> http://video.google.com/videoplay?docid=6419094369756184531&q=icfp&hl=en
12:31:29 <lambdabot> Title: ICFP programming contest 2006 results - Google Video, http://tinyurl.com/hrqls
12:31:41 <SamB> take out everything after the docid and try again?
12:32:05 <SamB> i.e., use http://video.google.com/videoplay?docid=6419094369756184531
12:32:07 <lambdabot> Title: ICFP programming contest 2006 results - Google Video, http://tinyurl.com/oshpp
12:32:53 <SamB> hmm
12:32:59 <SamB> google not finding it
12:33:22 <x3m> who won the ICFP, any people from here?
12:33:45 <dolio> The winners were all from Google.
12:34:08 <x3m> ok
12:34:16 <dolio> The two teams below that were a mix of people from various places.
12:34:40 <dmhouse> ?google video.google.com icfp results site:tunes.org inurl:haskell inurl:06.09
12:34:43 <lambdabot> No Result Found.
12:34:51 <x3m> wasnt the a team participating from here?
12:34:58 <dmhouse> ?google icfp results site:tunes.org inurl:haskell inurl:06.09
12:35:00 <lambdabot> No Result Found.
12:35:08 <dmhouse> x3m: yeah, one or two.
12:35:12 <dolio> Lazy Bottoms had people from here. They got mentioned a lot.
12:35:17 <x3m> how did they do?
12:35:33 <SamB> I think google is confused...
12:35:58 <SamB> that is, I think there must be a hole in its index, into which our logs have fallen...
12:36:08 <dolio> Not sure. Not in the top 3, at least. :)
12:36:29 <SamB> http://tunes.org/~nef/logs/haskell/
12:36:32 <lambdabot> Title: Index of /~nef/logs/haskell
12:36:38 <SamB> okay, so the directory is there
12:36:46 <dmhouse> Final scoreboard: http://icfpcontest.org/scoreboard.shtml
12:36:47 <dolio> But they solved a lot of problems first, so they got mentioned a lot in the video.
12:36:48 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
12:37:13 <dmhouse> Got it.
12:37:15 <SamB> (_|_) -- gotta love the logo ;-)
12:37:27 <dmhouse> http://tunes.org/~nef/logs/haskell/06.09.20
12:37:37 <dmhouse> Then grep/find-as-you-type for 'video.google.com'.
12:39:38 <sieni> SamB: yes, looks like a bottom
12:40:12 <SamB> easy to memorize and type, too ;-)
12:41:38 <sieni> is there a special symbol for a bottom of a bottom?
12:42:07 <SamB> huh?
12:42:53 <sieni> maybe -blah material
12:43:24 <sieni> a bottom refers to a submissive person in s/m-context
12:44:07 <SamB> eek
12:44:11 <SyntaxNinja> dcoutts_, dcoutts: You've got Mail!
12:44:26 <roconnor> ah, the s-n-m theorem.
12:44:30 <SamB> Oh no! Its the AOL mailer daemon!
12:44:59 <x3m> how do you pass in a newline to putStrLn?
12:45:12 <roconnor> putStrLn "\n"
12:45:22 <mauke> that's the same as putStr "\n\n"
12:45:28 <SamB> > putStrLn "\n"
12:45:29 <lambdabot>  Pervert!
12:45:33 <SyntaxNinja> heh
12:45:36 <dmhouse> SamB: No IO ;)
12:45:41 <SamB> dmhouse: I know
12:45:55 <SamB> I just wanted to demo the new error message
12:46:07 <int-e> that's not nice.
12:46:16 <SamB> int-e: what?
12:47:56 <SamB> what do *you* think a girl should say if you try to mess with her input/output facilities?
12:48:09 <dmhouse> Eww, O'Caml is ugly. 'let () = set_max_boxes 1000'
12:48:21 <ndm> SamB: yes, go ahead, i am able to give consent and i do so :)
12:48:54 <SamB> well, you can go and add the safety checker ;-)
12:49:02 <int-e> SamB: it's too much of an in-joke for my taste.
12:49:06 <x3m> http://paste.lisp.org/display/26640 this compiles and works.. is it proper code(layout) or should i change anything?
12:49:07 <dmhouse> That's some ugly side-effects there.
12:49:34 <dmhouse> x3m: indent all the lines beginning 'putStrLn'.
12:49:36 <SamB> so that she only does that when you say stuff like readFile "/etc/passwd"?
12:49:49 <ndm> I have to agree with int-e, what if we changed unsafePerformIO to gropeWithoutConsent, no one would understand it...
12:50:02 <ndm> and i don't see why putStrLn isn't allowed
12:50:05 <dmhouse> x3m: in general, if something is a part of something else, you indent that something. So your 'putStrLn' lines are part of the do-block, so you should indent them.
12:50:08 <ndm> since the output can come to the IRC channel
12:50:12 <SamB> ndm: because it is of an IO type
12:50:15 <x3m> okay
12:50:21 <SamB> @type putStrLn
12:50:22 <SamB> er.
12:50:23 <lambdabot> String -> IO ()
12:50:29 <SamB> @type putStrLn "Hi!"
12:50:30 <dmhouse> ndm: if you allow putStrLn you presumably allow runInteractiveCommand?
12:50:31 <lambdabot> IO ()
12:50:34 <ndm> SamB: yes, i understand the way its restricted, but its safe, hence could safely be allowed
12:50:53 <ndm> dmhouse: no, make a distinction between putStrLn (safe) and others (unsafe)
12:51:01 <ndm> i.e. not everything in the IO monad is evil in this context
12:51:17 <x3m> should the "where" be on a new line or just like: module Main where?
12:51:24 <SamB> ndm: you want to go and hardcode the imports so that only "safe' things are importing?
12:51:29 <SamB> er, *imported
12:51:29 <dmhouse> x3m: either work. The latter is more common.
12:51:38 <ndm> SamB: yes, i guess
12:51:40 <x3m> oki
12:51:53 <ski> module Main
12:51:55 <SamB> ndm: be my guest! but its really ugly already!
12:51:55 <ski>   where
12:51:57 <ski>   ..code..
12:52:10 <ndm> SamB: i couldn't care enough to do so
12:52:27 <SamB> ndm: so stop bitching!
12:52:31 <Philippa> ndm: putStrLn could be used to spam the chan
12:52:45 <SamB> ah, yes, true
12:53:04 <ski> so can '> ', no ?
12:53:05 <SamB> ... except that the output of RunPlugs is already filtered...
12:53:10 <ndm> Philippa: not really, we already have limiting on everything else
12:53:13 <Syzygy-> Unless you make sure that putStrLn only reacts in direct msg to the one who runs it.
12:53:26 <SamB> yeah, actually,
12:53:35 <SamB> look
12:53:38 <Philippa> okay. If I map putStrLn across an infinite list, how far'd it get without further input?
12:53:55 <int-e> I don't want IO support in lambdabot, I want a clear and polite error message.
12:54:01 <SamB> Philippa: it would time out
12:54:19 <SamB> because RunPlugs sets a time limit on computation
12:54:24 <int-e> and "Pervert!" is obscure and insulting.
12:54:33 <Philippa> int-e: agreed
12:54:37 <SamB> int-e: anime is obscure?
12:54:45 <dmhouse> SamB: but in which time, thousands of lines would have been sent to the channel.
12:54:49 <Philippa> the I/O reference is obscure
12:54:51 <dmhouse> int-e: patch it up, then.
12:54:54 <SamB> dmhouse: nope
12:54:56 <SamB> see this:
12:55:09 <SamB> hmm
12:55:11 <Syzygy-> int-e: We can change it into "Hentai!" :)
12:55:36 <ski> (even more obscure)
12:55:39 <mauke> HentIO
12:55:39 <Syzygy-> (but yeah, something like "Pervert! That's not pure functional programming!" would make it easier on you)
12:55:40 <SamB> whats a good false quickcheck-style property...
12:56:04 <dmhouse> forall x. x > 5
12:56:17 <Philippa> except that it is. The problem is it's /also/ IO, so "Pervert! stop trying to play with my IO ports!" or similar
12:56:21 <SamB> how about one involving a function passed as argument?
12:56:37 <dmhouse> forall f. f 5 = 5
12:56:37 <int-e> @check not . (42 :: Int `elem`)
12:56:38 <lambdabot>  Parse error
12:56:48 <int-e> @check not . ((42 :: Int) `elem`)
12:56:50 <lambdabot>  Falsifiable, after 82 tests: [-26,-28,26,-34,-2,-38,1,-41,-24,22,-12,39,42,-...
12:56:52 <SamB> @scheck \(f :: I -> I) x -> f x = x
12:56:53 <lambdabot>  Parse error in pattern
12:57:09 <SamB> @scheck \f x -> f x = (x :: I)
12:57:10 <lambdabot>  Parse error
12:57:18 <SamB> @scheck \f x -> f x == (x :: I)
12:57:20 <lambdabot>   Failed test no. 2. Test values follow.: {-1->-1;0->-1;1->-1;2->-1;3->-1}, 0
12:57:24 <SamB> hmm
12:57:38 <Syzygy-> Philippa: The fact that I have no idea what Pervert! really is supposed to mean only strenghtens the argument for a clear error msg.
12:57:39 <int-e> @check not . ((4711 :: Int) `elem`)
12:57:40 <lambdabot>  OK, passed 500 tests.
12:57:42 <ski> @check False
12:57:43 <lambdabot>  Falsifiable, after 0 tests:
12:57:45 <SamB> @scheck \f g x -> f (g x) == g (f x) :: I
12:57:46 <lambdabot>  Couldn't match `I' against `Bool'
12:57:50 <SamB> @scheck \f g x -> f (g x) == (g (f x) :: I)
12:57:52 <lambdabot>   Failed test no. 11. Test values follow.: {-1->-1;0->-1;1->-1;2->-1;3->-1},...
12:57:54 <x3m> is the anything like functionpointers in haskell?
12:58:07 <dmhouse> x3m: you can just pass functions around, like in JavaScript.
12:58:12 <basti_> x3m: functions are first class citizens in haskell. you don't need to point to them.
12:58:14 <SamB> anyway.
12:58:44 <Syzygy-> x3m: Why do you think you need function pointers?
12:58:53 <mauke> s/function //
12:59:08 <SamB> *if* RunPlugs let you do mapM_ print [1..], it wouldn't actually produce a whole lot of output...
12:59:53 <x3m> could i do something like: "functionname <- getLine" let the user type in 'sqrt' and then "functionname 5"?
12:59:54 <dolio> What about 'sequence . repeat $ putStrLn "Spam"'?
13:00:04 <ski> @type getLine
13:00:04 <SamB> x3m: nope
13:00:06 <lambdabot> IO String
13:00:20 <SamB> x3m: you'd have to play with hs-plugins or something like that
13:00:22 <ski> x3m : no, since that would make 'functionname' a 'String'
13:00:43 <x3m> ski: thats why i wondered about functionpointer..
13:00:49 <Philippa> which also wouldn't do that
13:00:51 <mauke> x3m: that has nothing to do with function pointers
13:00:55 <SamB> x3m: you can't do that in C
13:01:11 <mauke> (well, you can if you dlopen yourself or something)
13:01:17 <x3m> SamB: i can do that in c++.. with some more code
13:01:22 <mauke> x3m: show me
13:01:25 <Philippa> and you can do it in Haskell with some more code
13:01:27 <SamB> x3m: me also show!
13:01:28 <xerox> SamB: where does I come from?
13:01:35 <SamB> xerox: hmm
13:01:36 <Philippa> hell, writing interpreters in Haskell is incredibly easy
13:01:46 <sieni> x3m: how would you do that in c? except with something like dlsym()
13:01:48 <sieni> ?
13:01:59 <SamB> boilerplate in the scripts for running quickcheck/smallcheck tests?
13:02:00 <Philippa> sieni: he's talking about looking it up in a map
13:02:08 <Syzygy-> functionName <- getLine; f = case functionName of {"sqrt" -> (sqrt); "sin" -> (sin); }
13:02:12 <Syzygy-> Something like that.
13:02:14 <xerox> SamB: how did you know it? :)
13:02:36 <xerox> (Syzygy-: the parens aren't necessary.)
13:02:40 <SamB> I saw dons using it
13:02:51 <xerox> shapr!
13:02:51 <shapr> Good Morning #haskell!
13:02:54 <Syzygy-> xerox: In order to get a section stored in f? Hmmm. Maybe not.
13:02:57 <shapr> Hiya Heffalump, how's code?
13:03:01 <roconnor> shapr: morning
13:03:01 <Syzygy-> Good Morning (hrm. Evening) shapr!
13:03:05 <shapr> Greetings xerox, how's life?
13:03:09 <dmhouse> Hi shapr.
13:03:10 <sieni> Philippa: I thought he was thinking about converting strings to function pointers
13:03:11 * shapr boings cheerfully
13:03:15 <xerox> shapr: university starts tomorrow, I'm very excited.
13:03:19 <shapr> y0 dm in da house!
13:03:20 <roconnor> shapr: were you able to create a Monad Reader account for me?
13:03:22 <ski> > let functionName ="sqrt" in (case functionName of {"sqrt" -> (sqrt); "sin" -> (sin); }) 9
13:03:24 <lambdabot>  3.0
13:03:26 <Philippa> sieni: sure, just not by casting
13:03:29 <xerox> shapr: first course will be two hours of C++, but well...
13:03:32 <Heffalump> hi shapr, not bad
13:03:33 <ski> x3m : there you go
13:03:35 <shapr> roconnor: Sadly I got distracted, I shall do so immediately.
13:03:38 <dmhouse> Anyone catch my email concerning Haskell forum software?
13:03:38 <Syzygy-> > sin 9
13:03:40 <lambdabot>  0.4121184852417566
13:03:44 <x3m> sieni: samb, mauke, sieni: just store a functionpointer and a string with the same name in a std::map for example, then just compare the inputstring with the functionnamestring in the map and run the functionpointer
13:03:51 <stepcut> dmhouse: I saw it
13:03:51 <shapr> dmhouse: Yes, I saw it. I'd suggest Hope's comment plugin.
13:04:01 <mauke> x3m: you can do that in haskell except you'd store the function itself
13:04:01 * stepcut hopes for a nntp feed
13:04:02 <roconnor> shapr: I got my article to compile.  Still, it needs a bit more work
13:04:03 <Syzygy-> x3m: In that case, see the example that's been breezing by.
13:04:22 <shapr> roconnor: Some > None
13:04:35 <SamB> mauke: which happen to be just about indistinguishable except the pesky * in the type of the map
13:04:38 <sieni> x3m: ahh, c++ not c
13:04:38 <xerox> stepcut: the rss/atom feed of some nntp group?
13:04:42 <sieni> vittu
13:04:50 <shapr> roconnor: What name would you like, RussellOconnor or something else?
13:04:52 <stepcut> xerox: no, a nntp feed for the web forum
13:04:52 <xerox> @babel fi en vittu
13:04:52 <Philippa> same difference though, you could build your own map implementation in C
13:04:53 <lambdabot> babel module failed: IRCRaised Error: Language fi not supported
13:04:53 <dmhouse> x3m: oh, well if you don't want it to work for arbitrary functions, it's easy.
13:04:57 <shapr> sieni: paskaa!
13:04:59 <sieni> x3m: well, you can of course map a string to a function
13:04:59 <xerox> stepcut: yuck.
13:05:03 <dmhouse> You use exactly the same strategy as in C.
13:05:09 <roconnor> shapr: that will do
13:05:16 <x3m> sieni: that can be done as easily in c as in c++, you dont have to use a map, you could use char arrays or whatever
13:05:26 <shapr> xerox: Vittu is a derogatory Finnish word for genitalia.
13:05:29 <stepcut> xerox: :p
13:05:37 <mauke> > Data.Map.fromList
13:05:38 <lambdabot>  Not in scope: `Data.Map.fromList'
13:05:43 <mauke> :(
13:05:52 <shapr> stepcut! I didn't get to meet you in Portland!
13:05:53 <xerox> > M.fromList [(1,"mauke")] -- I think?
13:05:54 <sieni> x3m: I thought you were asking if you have direct access with the environment, like string->symbol and eval in scheme
13:05:54 <lambdabot>  {1:="mauke"}
13:06:17 <stepcut> shapr: yeah, because I was in San Diego :(
13:06:22 <shapr> too bad
13:06:26 <Philippa> sieni: that's because that's precisely what the example we were shown tries to do...
13:06:30 <xerox> shapr: that was my bet... heh
13:06:32 <x3m> sieni: well my question might have been abit cloudy, and i havent used scheme.
13:06:39 <shapr> roconnor: Ok, create that account and you have admin privs now.
13:06:45 <stepcut> i'll probably go next year though
13:06:57 <shapr> To ICFP/HW?
13:07:01 <stepcut> yeah
13:07:08 <ski> > let table = [("sqrt",sqrt),("sin",sin)]; unsafeLookup tab key = fromJust $ lookup key tab in unsafeLookup table "sqrt" 9
13:07:09 <lambdabot>  3.0
13:07:17 <mauke> > let funcs = M.fromList [("sqrt", sqrt), ("sin", sin)] in (funcs M.! "sqrt") 9
13:07:18 <shapr> I don't know if I'll attend. I didn't really expect to attend this one.
13:07:19 <lambdabot>  3.0
13:07:31 <ndm> where is the next one?
13:07:44 <shapr> Galois flew me up there, I only had to pay the HW entrance fee myself.
13:07:49 <stepcut> :p
13:08:05 <Heffalump> you're applying to Galois or something?
13:08:09 <xerox> mauke: nice idea, maybe you could write an accessor function whose name is as short as M.! but it defines a default function which either is `error', or `id' !
13:08:22 <Lemmih> shapr: Wow, neat.
13:08:36 <mauke> xerox: M.findWithDefault
13:08:48 <xerox> mauke: yup, that's what I mean.
13:08:50 <shapr> Heffalump: Yup, I had an interview. Not sure if they'll hire me or not. But I'm fine either way really. If they hire me I get paid to write Haskell, if not I get to renew my relationships with my family.
13:09:16 <stepcut> shapr: maybe they'll fly you to next year's also :)
13:09:30 <ndm> stepcut, shapr: where is the next ICFP/HW?
13:09:38 <shapr> I really missed my family when I was in .fi and .se so I'm happy to be back in Birmingham where I get to spend time with them regularly.
13:09:45 <newsham> hi
13:09:48 * stepcut has no idea
13:10:08 <stepcut> http://www.informatik.uni-bonn.de/~ralf/icfp07.html
13:10:09 <stepcut> ;)
13:10:10 <lambdabot> Title: 12th ACM SIGPLAN International Conference on Functional Programming (ICFP 2007), http://tinyurl.com/nwpqd
13:10:12 <shapr> I think it alternates europe/usa so probably in the EU
13:10:22 <stepcut> Freiburg, Germany
13:10:29 <ndm> ah, neat, fairly close for travel
13:10:37 <ndm> i'm already writing my ICFP 2007 paper :)
13:11:04 <stepcut> I should write one -- might be the cheapest way to get there :)
13:11:07 <Jamie> anybody have time for some newbie questions?
13:11:14 <mauke> Jamie: sure, just ask
13:11:15 <shapr> stepcut: truly
13:11:20 <shapr> Jamie: yes!
13:11:41 <Jamie> I want to do some graphical stuff but the docs I've found seem like they're all out of date
13:11:54 <shapr> What sort of graphical stuff? OpenGL?
13:12:03 <shapr> Or image processing, or GUI interface, or ?
13:12:04 <Jamie> OpenGl works.  Whatever's canonical.
13:12:18 <Jamie> A vector library with colors would be fine.
13:12:24 <SamB> cairo?
13:12:49 <Jamie> I'd probably be most comfortable with opengl - if I could get it up and running.
13:13:03 <SamB> whats the trouble?
13:13:41 <Jamie> let's see...this one tutorial suggested using GLUT...but GLUT didn't come with my install of GHC seems like
13:14:05 <shapr> dons: So, you're to blame for the Haskell webserver going out? Because your wiki page was too popular?
13:14:06 <SamB> what OS?
13:14:16 <Jamie> Winxp
13:14:23 <SamB> huh
13:15:07 <shapr> Does the standard Windows GHC installer include OpenGL and/or GLUT?
13:15:19 <shapr> @users
13:15:26 <lambdabot> Maximum users seen in #haskell: 241, currently: 240 (99.6%), active: 43 (17.9%)
13:15:28 <Jamie> the docs say it has OpenGL but doesn't mention Glut
13:15:34 <dmhouse> Ooh, wow, we're active.
13:15:35 <SamB> Jamie: what saith ghc-pkg?
13:16:12 <newsham> ghc6.4.2 glut-2.0 on my winxp
13:16:24 <Jamie> opengl-2.0 is there
13:17:23 <Jamie> I don't know how to even open a window without glut - is there some sample code somewhere?
13:17:49 <newsham> http://www.haskell.org/HOpenGL/examples/Planet.hs   ?
13:17:51 <lambdabot> http://tinyurl.com/n85c7
13:17:52 <shapr> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
13:17:58 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
13:18:08 <Jamie> planet.hs imports glut
13:18:10 <shapr> Didn't Syzygy- write a tutorial blog post recently?
13:18:14 <xerox> Yep.
13:18:18 <xerox> Even a second part.
13:18:24 <shapr> Syzygy-: Got the url handy?
13:18:45 <Jamie> ah, that looks good, I'll read that
13:18:50 <Jamie> 2006, thank god
13:18:56 <xerox> 09 too :)
13:18:57 <SamB> Jamie: and "ghc-pkg list" doesn't mention a "GLUT" package?
13:19:26 <Jamie> C:/ghc/ghc-6.4.1\package.conf:
13:19:27 <Jamie>     rts-1.0, base-1.0, haskell98-1.0, template-haskell-1.0, Cabal-1.0,
13:19:27 <Jamie>     parsec-1.0, haskell-src-1.0, network-1.0, QuickCheck-1.0,
13:19:27 <Jamie>     HUnit-1.1, mtl-1.0, fgl-5.2, Win32-1.0, HGL-3.1, OpenGL-2.0,
13:19:27 <Jamie>     stm-1.0, objectio-1.0, (lang-1.0), (concurrent-1.0), (util-1.0),
13:19:27 <Jamie>     (data-1.0), (text-1.0), (net-1.0), (hssource-1.0), (win32-1.0)
13:19:55 <newsham> c:/ghc/ghc-6.4.2\package.conf:
13:19:55 <newsham>     Cabal-1.1.4, GLUT-2.0, HGL-3.1, HUnit-1.1, OpenGL-2.0,
13:19:55 <newsham>     QuickCheck-1.0, Win32-1.0, base-1.0, (concurrent-1.0), (data-1.0),
13:19:55 <newsham>     fgl-5.2, fps-0.8, haskell-src-1.0, haskell98-1.0, (hssource-1.0),
13:19:55 <newsham>     (lang-1.0), mtl-1.0, (net-1.0), network-1.0, objectio-1.0,
13:19:55 <newsham>     parsec-1.0, readline-1.0, rts-1.0, stm-1.0, template-haskell-1.0,
13:19:57 <newsham>     (text-1.0), (util-1.0), (win32-1.0)
13:20:13 <newsham> maybe didnt come with 6.4.1?
13:20:24 <SamB> maybe!
13:20:36 <SamB> you might be able to build it from darcs or something?
13:20:43 <SamB> the snapshot, I guess...
13:21:00 <newsham> how do I build this stuff?  its complaining about the GLU import
13:21:06 * shapr realizes that Mikael Johansson == Syzygy-
13:21:12 <Jamie> I'll install 6.4.2 see what happens
13:21:49 * shapr boings
13:22:09 <SamB> newsham: whats the exact module name ?
13:22:21 <newsham> Failed to load interface for `GL'
13:22:29 <SamB> ah
13:22:36 <SamB> perhaps some ancient example?
13:22:42 <newsham> yah was wondering.
13:22:52 <x3m> functionName <- getLine; f = case functionName of {"sqrt" -> (sqrt); "sin" -> (sin); } when you type something like this... do you actually use ';' in haskell like in C or do you just imply it should be a newline?
13:23:25 <Jamie> I also might have done 'typical' instead of 'complete' install last time
13:23:26 <astrolabe> You can choose
13:23:47 <newsham> know of a modern example?
13:23:49 <x3m> can i do both?
13:23:53 <mauke> yes
13:24:00 <astrolabe> If you use ';', you use braces too, otherwise you use the indentation.
13:24:27 <x3m> oh
13:25:49 <astrolabe> described in section 2.7 of http://www.haskell.org/onlinereport/lexemes.html
13:25:51 <lambdabot> Title: Haskell 98 Lexical Structure, http://tinyurl.com/otdnu
13:26:10 <SamB> astrolabe: you can use ; without {}
13:26:18 <SamB> it can get confusing though
13:26:23 <astrolabe> oh?
13:26:28 * astrolabe looks
13:27:29 <alexny> It appears when I have an 'IO [Char]', I can't use simple functions like length on it, do I need to rewrite those function to take an IO [Char] myself?
13:27:36 <newsham> if you use normal indentation styles you wont need to use {} and ;
13:27:56 <SamB> > let x = y; y = x in x
13:27:57 <lambdabot>  Add a type signature
13:28:05 <newsham> alexny: if you have a function on [Char] and you want to have a similar function on IO [Char]  you can use a liftM function
13:28:17 <xerox> a.k.a. fmap
13:28:18 <newsham> ?type liftM
13:28:19 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
13:28:29 <astrolabe> alexny: but you can't get the result out of the IO Monad
13:28:44 <xerox> astrolabe: how else should it work ? :)
13:29:00 <astrolabe> I think it is ideal in every way
13:29:04 <mauke> an IO [Char] isn't some kind of list; it's an action that (when executed) returns a [Char]
13:29:06 <newsham> alternately, you can do somethin glike:      l <- functionMakingIOChar; let x = length l
13:29:10 <xerox> ?pl \f xs -> xs >>= return . f
13:29:10 <lambdabot> fmap
13:30:55 <x3m> putStrLn show ((let functionname = "sqrt" in (case functionname of { "increment" -> (increment); "sqrt" -> (sqrt); }) 9)) getting error, The function 'putStrLn' is applied to two arguments,..
13:31:39 <mauke> x3m: putStrLn x y applies putStrLn to two arguments
13:31:44 <astrolabe> put more brackets in
13:31:46 <newsham> putStrLn (show ...  )
13:31:51 <mauke> print (...)
13:31:52 <newsham> or putStrLn $ show ...
13:31:52 <xerox> x3m: print = putStrLn . show
13:31:56 <x3m> ah ofc
13:31:58 <astrolabe> he he
13:31:59 <newsham> or print :)
13:32:27 <astrolabe> You sort of get used to interpreting compile errors after a bit.
13:32:35 <alexny> mauke: I'm rather new to haskell but I see what you mean, what I really just am doing here is c <- getLine, and want to do length c, is there a way to "force" an evaluation to get the [Char] ?
13:33:05 <astrolabe> alexny: what do you want to do with the length?
13:33:18 <newsham> if "getLine" returns IO [Char], then  c will be [Char]
13:33:25 <newsham> when you do c <- getLine
13:33:29 <newsham> so you can do "length c"
13:34:05 <Jamie> Woo!  We have a window.  Thanks.
13:34:22 <newsham> do { ln <- getLine; let l = length ln; print l }
13:35:15 <xerox> Jamie: cool.
13:35:20 <xerox> Jamie: what did you use? :)
13:35:25 <newsham> inside the do block, whenever you have  x <- ..   the x can be processed as if its not an IO Something
13:35:50 <xerox> It's helpful to know how the `do' sugar desugars to.
13:35:56 <alexny> newsham: ok thanks
13:35:57 <xerox> s/ to././
13:36:15 <newsham> xerox: depends, if you're just starting that can be a little confusing too :)
13:36:42 <Jamie> 6.4.2 - complete install
13:36:53 <xerox> I think it provides a good mean of understanding, because you can get dirty with the actual combinators.
13:37:15 <newsham> i think you can understand and use the IO monad without understanding the combinators.
13:37:27 <newsham> which might be a good starting point
13:37:52 <astrolabe> I like the method of learning to use the IO monad before you understand what a monad is.
13:38:00 <mauke> I think it's easier to start with IO, >>, return, and >>=
13:38:10 <newsham> (my opinion is that people should probably be taught how to use "IO" without ever talking about monads, and then tell them about the combinators, and only after all that tell them about monads)
13:38:14 <mauke> then learn do-notation, then generalize to monads
13:38:20 <mauke> yeah
13:38:24 <xerox> Namely, it is desugared as follows:
13:38:24 <xerox> do { let { bindings }; ... } ==> let { bindings } in do ...
13:38:24 <xerox> do { x <- amb; ... }         ==> amb >>= \x -> do ...
13:38:24 <xerox> do { amb; ... }              ==> amb >> do ...
13:38:27 <xerox> do amb                       ==> amb
13:38:47 <astrolabe> xerox has a different opinion :)
13:38:58 <newsham> may a thousand flowers bloom.
13:39:23 <xerox> Why do not talk about monads?
13:39:35 <mauke> so you can finish hello world first
13:39:41 <xerox> @wiki Monads_as_Containers
13:39:41 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
13:39:56 <xerox> That's a good way of talking about Monads.
13:40:02 <mauke> you don't have to know anything about monads to understand haskell's IO system
13:40:05 <newsham> xerox: two things, #1) they're difficult to understand,  #2) they're a lot easier to understand if you already know about a few of them (maybe without knowing they are monads) and then shown how they unify.
13:40:10 <xerox> mauke: that's true.
13:40:29 <newsham> so why not teach people how to use IO (easy to use, really!) and Maybe (easy!) and lists (easy!) and the ntell them later that its all monads..
13:41:20 <mauke> yeah, Maybe and [] and ((->) e) :-)
13:41:23 <roconnor> lists aren't easy
13:41:43 <dolio> Heh. Yeah. (->) e right off the bat.
13:41:44 <mauke> unifying return and const makes a lot of sense
13:41:46 <newsham> i thikn lists are fairly simple and an easy transition from Maybe
13:41:53 <roconnor> hmmm
13:42:14 <newsham> quadratic equation is a good example case for list monad.
13:42:20 <newsham> also NFAs if people already know about those
13:42:41 <xerox> You should write a tutorial :)
13:42:42 <roconnor> I'm not so convinced
13:42:59 <newsham> i did.  it was ok, but in the end i didnt like it as much as some of the others
13:43:04 <roconnor> none the less, IO and Maybe and Either String and MonadRandom are all good!
13:43:06 <newsham> so i didnt really publicize it
13:43:41 <xerox> @quote samc
13:43:42 <lambdabot>  monads are hard, let's go shopping
13:43:43 <xerox> @quote inv2004
13:43:44 <lambdabot>  lambdabot: monads ?
13:43:55 <xerox> @quote Gahhh
13:43:55 <lambdabot>  monads are usually a personal experience.
13:44:01 <newsham> haskell programmers have monad fixation :)
13:44:15 <roconnor> haskell programmers do it in a monad.
13:44:15 <astrolabe> > let tails [] = []; tails x = x ++ tails (tail x) in tails "lists aren't easy"
13:44:17 <lambdabot>  "lists aren't easyists aren't easysts aren't easyts aren't easys aren't easy...
13:45:17 <xerox> Now there was a very good one..
13:45:19 <weitzman> > concat $ tails "lists aren't easy"
13:45:20 <lambdabot>  "lists aren't easyists aren't easysts aren't easyts aren't easys aren't easy...
13:46:33 <astrolabe> I didn't know lambdabot remembered.
13:46:52 <mauke> > let foo x = do { _:y <- [x]; x ++ tails y } in foo "lists aren't easy"
13:46:53 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
13:46:53 <lambdabot>    Expected...
13:46:58 <vincenz> astrolabe: tails is an existing function
13:47:01 <mauke> > let foo x = do { _:y <- [x]; return $ x ++ tails y } in foo "lists aren't easy"
13:47:03 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
13:47:05 <lambdabot>    Expected...
13:47:15 <vincenz> astrolabe: but yes it remembers, but -not- like that
13:47:17 <vincenz> @let ...
13:47:21 <lambdabot>  Parse error
13:47:32 <astrolabe> uh weird, I guessed an existing function.
13:47:40 <dmhouse> What would be a nice way of doing the following?
13:48:06 <dmhouse> I need to apply a Maybe-function to the second element of every element in a list of pairs. Should any of the functions return nothing, the result should be Nothing.
13:48:39 <dmhouse> Otherwise, the result should be MyConstr list', where list' = the list with all the pairs' second elements being the new ones computed by the function.
13:48:52 <xerox> Ah that's it
13:48:56 <xerox> @quote DanPiponi
13:48:57 <lambdabot>  Writing introductions to monads seems to have developed into an industry
13:49:02 <mauke> what's MyConstr and how does it have the same type as Nothing?
13:49:22 <dmhouse> Sorry, Just (MyConstr list')
13:49:26 <dmhouse> it's just a constructor.
13:50:06 <weitzman> @type (a -> b) -> (c, a) -> (c, b)
13:50:07 <lambdabot> parse error on input `->'
13:50:13 <weitzman> @hoogle (a -> b) -> (c, a) -> (c, b)
13:50:14 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:50:14 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:50:32 <twanvl> dmhouse: liftM MyConstr . mapM (mapSndM f)
13:50:55 <weitzman> @type mapSndM
13:50:56 <lambdabot> Not in scope: `mapSndM'
13:50:57 <dmhouse> twanvl: yeah, that's what I'm thinking.
13:50:58 <xerox> weitzman: second
13:51:02 <twanvl> Where: mapSndM f (x,y) = liftM ((,) x) . f
13:51:05 <lennart> dmhouse: something like mapM (\ (x,y) -> do y' <- f y; return (x, y') ) l
13:51:19 <dmhouse> And I'll just use a lambda for mapSndM.
13:51:33 <xerox> ?type (second :: (Arrow (~>)) => (b ~> c) -> ((a,b) ~> (a,c)))
13:51:35 <lambdabot> forall (~> :: * -> * -> *) b c a. (Arrow ~>) => ~> b c -> ~> (a, b) (a, c)
13:51:44 <twanvl> er, I mean: mapSndM f (x,y) = liftM ((,)x) (f y)
13:51:47 <mauke> @type \f -> foldr (\x z -> do { z' <- z; x' <- f x; return (x' : z')) (return []) . map snd
13:51:48 <lambdabot> parse error on input `)'
13:51:58 <astrolabe> @djinn (a -> b) -> (c,a) -> (c,b)
13:51:59 <lambdabot> f a (b, c) = (b, a c)
13:52:05 <mauke> @type \f -> foldr (\x z -> do { z' <- z; x' <- f x; return (x' : z')}) (return []) . map snd
13:52:06 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (b -> m a) -> [(a1, b)] -> m [a]
13:52:07 <weitzman> @type secondM
13:52:08 <lambdabot> Not in scope: `secondM'
13:52:11 <xerox> twanvl: what's the type of mapSnd ?
13:52:13 <dmhouse> fmap TmRecord $ mapM (\(lbl, t) -> fmap ((,) lbl) $ evalStep cxt t) fs -- there we go
13:52:36 <astrolabe> @pl f a (b,c) = (b,a c)
13:52:36 <lambdabot> f = (`ap` snd) . (. fst) . flip ((.) . (,))
13:52:41 <twanvl> mapSndM :: (b -> m c) -> (a,b) -> m (a,c)
13:52:42 <astrolabe> heh
13:52:50 <mauke> or am I thinking too imperatively?
13:52:50 <xerox> astrolabe: second! :D
13:53:01 <astrolabe> @type second
13:53:03 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
13:53:05 <weitzman> That's a very complex way of implementing second!
13:53:12 <Stinger_> jeez that haskell competition was nuts by the look of that video
13:53:16 <xerox> weitzman: sorry?
13:53:17 <twanvl> you could also call it secondM
13:53:32 <xerox> Nope.
13:53:40 <weitzman> xerox:  f = (`ap` snd) . (. fst) . flip ((.) . (,))
13:53:43 <astrolabe> Stinger: link?
13:53:52 <xerox> weitzman: hehe yeah.
13:54:01 <weitzman> >  (`ap` snd) . (. fst) . flip ((.) . (,)) $ (+ 1) (4, 4)
13:54:02 <lambdabot>  Couldn't match `a -> b' against `(a1, b1)'
13:54:06 <xerox> weitzman: but it is points-free.
13:54:09 <Stinger_> erm not haskell competition
13:54:14 <Stinger_> sorry my brain isnt working
13:54:28 <xerox> > ((`ap` snd) . (. fst) . flip ((.) . (,))) (+1) (1,1)
13:54:29 <lambdabot>  (1,2)
13:54:34 <weitzman> xerox: I think this would be a case where it's point-less
13:54:39 <dmhouse> ?type guard
13:54:40 <lennart> Stinger_: Yes, it was pretty ambitious
13:54:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:54:45 <xerox> weitzman: I agree, but that's fixable.
13:54:59 <weitzman> Ba-da-ching
13:55:08 <xerox> That is, lambdabot's result, integrated in time, isn't point-less.
13:55:11 <xerox> Yuck :P
13:55:44 <Stinger_> astrolabe : yeah I meant the ICPF one, sorry bout that
13:56:17 * dmhouse copies SyntaxNinja's "It typechecks!" dance
13:56:51 * basti_ just did the "coq says Proof Completed" dance
13:57:09 <xerox> basti_: which Clay problem have you solved?
13:57:27 <dmhouse> Hehe :)
13:57:39 <basti_> I'm doing an exercise around the equivalence of certain charactirisations of classical logic
13:58:51 <basti_> modulo typoes
14:11:41 <dibblego> xerox, are you around?
14:12:14 <dibblego> is it right that http://paolo.is-a-geek.com/mu/entry gives me nothing?
14:12:36 <dibblego> how long has Hope been around for?
14:12:49 <emu> ever since Pandora opened a box
14:12:55 <dmhouse> dibblego: not that long.
14:15:34 <Lemmih> xerox: ping.
14:16:28 <Lemmih> xerox: n/m.
14:17:28 <xerox> dibblego: it's down now, I have got to fix some resources problems
14:17:31 <xerox> Lemmih: alright?
14:18:15 <dibblego> xerox, ok just checking
14:21:10 <Lemmih> xerox: I was looking for the cabal-install repo. Found it.
14:21:18 <Lemmih> (the package repo, that is)
14:21:38 <xerox> Okay.
14:22:03 <cathper> Say I have `type Price = int' which are in cents and I want to output it as "$3.43". Should I do something like "instance Show Price"?
14:24:47 <mauke> no, you can't instance types
14:25:07 <emu> `type's are just aliases
14:25:17 <emu> newtype actually makes a "new type" like `data' does
14:25:18 <sylvan> cathper, do newtype Price.. etc.
14:25:24 <sjanssen> cathper: the usual thing to do is write: newtype Price = Price Int
14:25:46 <sjanssen> you can even use newtype deriving in GHC to derive all the instance behavior you don't need to override
14:25:47 <Lemmih> I wouldn't use show for pretty printing at all.
14:26:12 <emu> show should return a read-able string i'd say
14:26:22 <emu> if possible
14:26:39 * cathper is learning, thanks for inputs!
14:27:04 <cathper> Lemmih: How'd you do it then? Make a specific "showDollar" function?
14:27:12 <Lemmih> cathper: Yes.
14:28:09 <weitzman> What happens when two typeclasses support the same function and some type is an instance of both classes?
14:28:31 <weitzman> I assume you have to explicitly add :: Class1 a => a or something
14:28:31 <sjanssen> weitzman: that can't happen
14:28:36 <weitzman> Also a good answer
14:29:00 <int-e> you'll have to use the function name qualified (by the module which defines the type class in question)
14:29:02 <cathper> Lemmih: When would you change "show Price" then? Never?
14:31:16 <sjanssen> cathper: also note that using Int won't allow you to sell things that are more than about 21.5 million dollars
14:31:34 <sjanssen> on a 32 bit machine
14:32:08 <cathper> sjanssen: I know.
14:32:48 <dibblego> sjanssen, isn't an Int 32 bits regardless of underlying architecture?
14:33:26 <weitzman> "A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]"
14:33:34 <weitzman> "The exact range for a given implementation can be determined by using  minBound and maxBound from the Bounded class."
14:33:41 <dibblego> ah ok
14:34:20 <weitzman> > maxBound :: Int
14:34:21 <lambdabot>  2147483647
14:35:55 <weitzman> Foreign.C.Types.CUInt is the best approximation of an unsigned int?
14:36:21 <sjanssen> weitzman: it is an unsigned int
14:36:38 <weitzman> Data.UInt would be a good unsigned Int
14:37:30 <weitzman> > maxBound :: CUInt
14:37:31 <lambdabot>  Not in scope: type constructor or class `CUInt'
14:37:52 <weitzman> > maxBound :: Foreign.C.Types.CUInt
14:37:53 <lambdabot>  Not in scope: type constructor or class `Foreign.C.Types.CUInt'
14:40:18 <Igloo> Word/Word8/Wrd16/Word32/Word64 are the Haskell unsigned integer types
14:46:09 <weitzman> > maxBound :: Word
14:46:10 <lambdabot>  4294967295
14:46:13 <weitzman> Hooray
14:46:39 <weitzman> > (-1) :: Word
14:46:40 <lambdabot>  4294967295
14:56:25 <emu> > maxBound :: Word64
14:56:27 <lambdabot>  18446744073709551615
14:57:48 <emu> actually, is there a Money library floating around for haskell which handles the issues
15:00:30 <sjanssen> emu: there is this: http://www.n-heptane.com/nhlab/repos/Decimal/
15:00:32 <lambdabot> Title: Index of /nhlab/repos/Decimal
15:03:47 <emu> fixed point decimal?
15:10:09 <stepcut> yes
15:11:04 <stepcut> the rounding routine is not quite right though
15:12:31 <stepcut> I should really finish that library -- it is 95% done, I just need to fix rounding and add the types for different levels of precision :-/
15:12:34 <xerox> > fix ((2:) . scanl1 (const ((/2) . ap (+) (2/)))) !! 1000
15:12:35 <lambdabot>  1.414213562373095
15:12:45 <xerox> fixpoint sqrt 2!
15:12:49 <xerox> G'night :)
15:14:46 <Jamie> I need more help
15:15:04 <Jamie> Trying the sample code from Michi's blog:  http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
15:15:06 <lambdabot> Title: Michi&#8217;s blog Â» Blog Archive Â» OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
15:15:50 <Jamie> and with this line:  myPoints = map (k -> (sin(2*pi*k/12),cos(2*pi*k/12),0.0)) [1..12]
15:16:16 <Lemmih> That should probably be: map (\k -> ...
15:16:35 <Jamie> ok
15:17:00 <Lemmih> Same with the mapM_.
15:19:19 <Jamie> Ok - thanks - it compiles.  My second problem is it doesn't seem to be calling the displayCallback... or the displayCallback isn't working ... or something
15:19:37 <Jamie> I'm still just getting an empty window
15:25:01 <Lemmih> Jamie: Hm, try adding the reshape callback.
15:25:17 <cathper> Uhm, where do I find out how List.intersectBy is implemented?
15:25:43 <Lemmih> @fptools Data.List
15:25:44 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
15:25:55 <cathper> Nice!
15:26:23 <cathper> Just found it in /usr/lib/hugs/libraries/List.hs though.
15:26:43 <cathper> Hmm, not.
15:27:32 <ndm> cathper: using Hugs/WinHugs?
15:27:53 <cathper> ndm: Hugs, yes.
15:28:10 <cathper> I'm just playing around and having a little fun :-)
15:28:22 <ndm> cathper: type ":f intersectBy", and it will hop you to that function in your editor
15:29:05 <ndm> cathper: do :l Data.List first though, to get the real definition
15:29:48 <cathper> Oh, yes, thanks for reminding me about it!
15:30:09 <ndm> if you are in WinHugs, its really really really useful, not sure about plain Hugs, since that doesn't have as good editor support
15:30:38 <cathper> It works like a charm with vim. That's good enough for me.
15:31:32 <ndm> :)
15:35:07 <Jamie> huh, ok - now that the reshape's in, after I resize the window I get the display...so...what's going on?
15:37:47 <ndm> Jamie: windows?
15:37:57 <Jamie> yeah
15:38:28 <ndm> Windows fires a WM_PAINT only after its redrawn, i.e. after a WM_RESIZE, not after a WM_INITDIALOG, which usually does the drawing as well
15:38:49 <ndm> how that relates to whatever library you're using I have no idea, but thats some info for you :)
15:39:25 <ndm> although it usually fires a WM_PAINT as well, but sometimes bfeore some internal data structures are set up
15:39:42 <ndm> suggestion: hook into whatever creation interface you have as well as the paint/resize one
15:40:00 <Jamie> gotcha.  I'm using glut.
15:40:10 <ndm> never used it
15:40:25 <ndm> and am the one who is responsible for it not being in WinHugs...
15:40:41 <Jamie> what do you use?
15:40:48 <ndm> for GUI stuff?
15:40:53 <ndm> Gtk2Hs
15:40:59 <ndm> although don't do much GUI stuff
15:41:04 <ndm> and never 3d rendering stuff
15:44:54 <hygge> i am going to build a random number genrator to use with randomr, but how should it look? i see in :t randomr that it only says 'b'?
15:49:24 <dibblego> who's that guy from Microsoft that is right into FP and has a blog, etc.?
15:49:55 <Jamie> Joel Spolsky used to be from Microsoft
15:50:14 <dibblego> is he into FP?
15:50:31 <Jamie> he wrote an article on how important map & reduce are but he's not a zealot
15:52:27 <ndm> dibblego: not really, he showed Javascript as his functional language :)
15:52:41 <dibblego> ndm, now that sounds more like Joel Spolsky :)
15:52:53 <dibblego> Simon Jones is who I was thinking of
15:53:03 <Patterner> WASABI FOR ALL!
15:53:03 <ndm> although, seriously, Javascript is a _great_ language
15:53:28 <x3m> @paste
15:53:28 <lambdabot> http://paste.lisp.org/new/haskell
15:53:32 <dibblego> ndm, I don't have much regard for what Spolsky writes
15:53:36 <cathper> Does SPJ have a blog?
15:53:50 <ndm> Patterner: wasabi is backwards compatible with vbscript, can you imagine how horrid it is...
15:54:10 <dibblego> cathper, no, sorry, I made that bit up it seems
15:54:12 <ndm> dibblego: i've found his writing to be accurate and informative, compared to Paul Graham who is just wrong and annoying...
15:54:21 <cathper> dibblego: Hehe, okay :-)
15:54:30 <ndm> cathper: not at all, planet.haskell.org would carry it if he did
15:54:38 <ndm> Phil Waddler does though
15:54:57 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26653
15:55:09 <Patterner> some Joel essays were worth reading
15:55:26 <dibblego> I've yet to see anything accurate
15:55:36 <ndm> the joel test has at least 9 or 10 accurate points in it
15:55:38 <dibblego> perhaps "appealing"
15:55:53 <Jamie> Joel's good for management - works for teams up to around 10-20.
15:55:55 <x3m> can someone take a look at this: http://paste.lisp.org/display/26653?
15:56:27 <Patterner> "eat your own dog food" wasn't coined by Joel, right?
15:56:36 <ndm> x3m: explain what you are trying to do
15:56:38 <dibblego> Jamie, a manager by definition is someone who can make an appeal with an inaccurate statement :)
15:56:42 <ndm> Patterner: no, not by a long way
15:57:25 <x3m> ndm: a function that takes 2 arguments, a string and a float. if the string matches the functionnames sqrt or increment it should use those functions with the parameter of the float
15:57:39 <ndm> x3m: higher order functions will probably do whatever it is you are trying to do, without all these ugly names
15:57:51 <x3m> ndm: im totally new to haskell
15:58:06 <x3m> i doubt what i even written is correct syntax
15:58:09 <ndm> x3m: explain what you are trying to do at a higher level
15:58:15 <Jamie> So that's what I am.
15:58:31 <x3m> ndm: higher level? i try to accomplish what the first line of that paste does
15:58:50 <x3m> but so it looks/gets encapsulated as a function
15:58:59 <ndm> x3m: but why? i'm pretty sure you can avoid introducing names, and pass the functions themselves around
15:59:32 <x3m> why? not sure, im just trying to learn, im used to c/c++ and their functionpointers and stuff
15:59:53 <ndm> its not really "idiomatic haskell" - it can be done, but its ugly
16:00:25 <ndm> x3m: what project are you trying to write?
16:00:30 <x3m> isnt the function i tried to write.. at least "almost correct"
16:00:49 <x3m> no project.. im pretty much abit after "hello world" :)
16:00:50 <ndm> x3m: describe to me your function, exactly what you want to give in, and what you want to get out
16:01:07 <ndm> (bare in mind that i'm drunk right now, as a disclaimer :) )
16:01:27 <x3m> > let functionName ="sqrt" in (case functionName of {"sqrt" -> (sqrt); "sin" -> (sin); }) 9
16:01:28 <lambdabot>  3.0
16:01:57 <ndm> x3m: the first step in haskell is to decide on the type of yoru function
16:01:59 <ndm> i am guessing:
16:02:08 <x3m> something like that. but you pass 2 arguments to a function..(in this case sqrt and 9) it should run another function with the name of sqrt with 9 as argument
16:02:08 <ndm> String -> Float -> Float
16:02:15 <Lemmih> > let apply f val = f val in (apply sqrt 9, apply sin 9)
16:02:17 <lambdabot>  (3.0,0.4121184852417566)
16:02:39 <ihope_> apply "sqrt" x = sqrt x; apply "increment" x = x + 1
16:02:43 <ndm> i.e., you give a string, and it gives you back a function from a flaot to a float
16:03:12 <ihope_> > let apply "sqrt" x = sqrt x; apply "increment" x = x + 1 in apply "sqrt" 9
16:03:13 <Lemmih> x3m: Why not pass on the function itself instead of its name?
16:03:14 <lambdabot>  3.0
16:03:17 <x3m> ndm: i give it a string and a float it gives back a function from a float to float i guess
16:03:22 <ihope_> > let apply "sqrt" x = sqrt x; apply "increment" x = x + 1 in apply "increment" 9
16:03:23 <lambdabot>  10.0
16:03:54 <ndm> x3m: not with sqrt or increment, that doesn't require the first float, its just a function from float to float - and see ihope_'s answer, its exactly what you want :)
16:04:31 <x3m> lemmih: i might want to do something like: functionname <- readLine and then execute the function the user types in or something
16:05:00 <ndm> x3m: thats pretty rare, but yes, thats an option
16:05:06 <Lemmih> x3m: Oh, but we have ghci/hugs for that.
16:05:27 <x3m> Lemmih: yeah but no if you compile it to an exe file, right?
16:05:44 <ihope_> The moral of the story: use pattern matching :-)
16:05:50 <Lemmih> Executables are overrated (:
16:06:02 <x3m> gah im not getting the help i want :P
16:06:19 <ndm> x3m: ihope solved it for you at least 15 messages ago :)
16:06:49 <x3m> "[01:02am] <ihope_> > let apply "sqrt" x = sqrt x; apply "increment" x = x + 1 in apply "increment" 9" this?
16:06:57 <ndm> yep :)
16:07:10 <x3m> that looks nothing like a function that i wanna do to me
16:07:11 <ihope_> More like just apply "sqrt" x = sqrt x; apply "increment" x = x + 1
16:07:45 <ihope_> Put those into a Haskell file, load it up into something, and see what happens.
16:07:52 <x3m> yep i will
16:08:08 <lisppaste2> ndm annotated #26653 with "Fix for x3m" at http://paste.lisp.org/display/26653#1
16:08:18 <x3m> the thing is it probably does the same as let functionname = "sqrt" in (case functionname of { "increment" -> (increment); "sqrt" -> (sqrt); }) 9
16:08:26 <x3m> but thats not what i wanna do, that code allready works
16:08:29 <ndm> x3m: what ihope_ has done is untuple your arguments, then using curring
16:08:37 <ndm> both very haskell style things to do
16:09:08 <ndm> in haskell you don't pass function (x, y) - you do function x y
16:09:22 <ihope_> Well, you can do "function (x,y)" instead of "function x y" if you want.
16:09:29 <ihope_> But everybody does "function x y".
16:09:37 <ndm> but its the wrong way to do it :)
16:09:49 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26654
16:09:53 <ndm> (x,y) is only for people who came from C and never learnt :)
16:10:09 <x3m> http://paste.lisp.org/display/26654 this looks like a function to me :)
16:10:21 <x3m> well im from C
16:10:31 <ndm> hehe, most of us were originally :)
16:10:32 <ihope_> Yep, that's a nice function.
16:11:03 <ihope_> Now implement the cubic and quartic equations.
16:11:23 <x3m> nope, now i gonna do my functionpointer :)
16:11:39 <sjanssen> yuck, "functionpointer"
16:11:52 <emu> Does Not Compute
16:11:52 <sjanssen> x3m: you really are from C, aren't you ;)
16:11:58 <x3m> ^^
16:12:24 <mauke> x3m: there are no pointers in haskell
16:12:32 <emu> @type \f x -> f f x
16:12:33 <Patterner> is that an insult..?
16:12:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
16:12:34 <lambdabot>    Expected type: t
16:12:43 <sjanssen> @hoogle Ptr
16:12:43 <lambdabot> Foreign.Ptr :: module
16:12:44 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
16:12:44 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
16:12:46 <ihope_> @hoogle Ptr
16:12:47 <lambdabot> Foreign.Ptr :: module
16:12:47 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
16:12:47 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
16:12:50 <x3m> mauke: i know, i just call this function like that
16:12:51 <mauke> pointers conflate the concepts of indirection, mutability and optionality
16:13:02 <ihope_> @docs Foreign.Ptr
16:13:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
16:13:24 <emu> > zipWith (+) [1..10] [10,9..1]
16:13:25 <lambdabot>  [11,11,11,11,11,11,11,11,11,11]
16:14:10 <mauke> > sum $ zipWith (+) [1,2..50] [100,99..51]
16:14:11 <lambdabot>  5050
16:14:20 <emu> > fix (\f -> [1,1] ++ zipWith (+) f (tail f))
16:14:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:15:10 <ihope_> > [10..1]
16:15:12 <lambdabot>  []
16:15:15 <ihope_> Hmm...
16:15:18 <emu> > [10,9..1]
16:15:19 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:15:26 <ihope_> I see.
16:15:30 <emu> i dunno why
16:15:44 <ihope_> What's bigger than 10 and smaller than 1?
16:16:04 <wkh> icfp winners this year used haskell?
16:16:26 -banb0t4lyf(n=banb0t4l@adsl-69-228-206-104.dsl.pltn13.pacbell.net)- lol g, join #2600 and get hugs visit http://lilo.on.nimp.org/?u=bantown for more info. #haskell SUCKS
16:16:46 <emu> we already have hugs
16:16:57 <mauke> > filter (liftM2 (&&) (> 10) (< 1)) [0 ..]
16:17:01 <lambdabot> Terminated
16:17:05 <x3m> ihope: i looked at your code now, but i want it to look like a function that takes a string(the functionname" as an argument
16:17:26 <sjanssen> wkh: yeah, they used Haskell among other languages
16:18:55 <ihope_> x3m: yeah, it takes the string as an argument...
16:19:25 <x3m> ihope: whats the functionname in that code?
16:19:51 <ihope_> x3m: apply.
16:19:56 <dannnn> anyone giving code help?
16:19:57 <ThreeQ> x3m: it doesn't have to have a name to be an argument
16:20:06 <ihope_> Or... oh.
16:20:47 <ndm> dannnn: give code questions, then we might be able to give code help :)
16:22:14 <x3m> ihope: can you write in that code in a paste with tabs instead?
16:22:16 <dannnn> hehe alright
16:22:24 <dannnn> i'm doing a project that involves therom resolution
16:22:38 <dannnn> and i'm having trouble coming up with a workable representation for logic sentances in haskell
16:23:10 <dannnn> i have an ml version of simple logic stuff
16:23:19 <dannnn> but i don't readily see how to port it to haskell
16:23:19 <sjanssen> x3m: tabs are generally considered a no-no in Haskell
16:24:13 <x3m> they are? maybe im using the wrong word.. the replacement for ; {} (multiple spaces) or what its called
16:24:41 <int-e> layout
16:24:50 <mauke> indentation
16:24:55 <x3m> indentation i meant
16:24:58 <ihope_> apply "sqrt" x = sqrt x
16:24:59 <ihope_> apply "increment" x = x + 1
16:25:01 <x3m> is that same as tabs?
16:25:03 <emu> no
16:25:06 <x3m> ok
16:25:17 <emu> tab is a character which is often interpreted by various different programs in different ways
16:25:20 <x3m> ooh, so this is some sort of function overloading?
16:25:29 <ihope_> x3m: sort of.
16:25:33 <ThreeQ> x3m: you could think of it that way, yeah
16:25:33 <emu> this is pattern matching
16:25:42 <ThreeQ> except it's overloading on VALUES, not TYPES
16:25:54 <ihope_> The first means 'skip over this one if the first argument isn't "sqrt"'.
16:25:58 <ihope_> Same for the second.
16:26:12 <sjanssen> x3m: do you know the "case" expression?  what ihope_ wrote is rewritten into case expressions
16:26:13 <mauke> x3m: it's just a switch statement, really
16:26:25 <ihope_> Yeah. This is just like case.
16:26:54 <x3m> let functionname = "sqrt" in (case functionname of { "increment" -> (increment); "sqrt" -> (sqrt); }) 9 this looks more like a case expression to me
16:27:18 <x3m> and also nicer.. (in my oppinion) cause it dont look like function overloading
16:27:21 <sjanssen> x3m: same concept, just different syntax
16:27:40 <emu> x3m: case expressions and function pattern matching are really the same
16:27:54 <sjanssen> x3m: I think you'll appreciate function pattern matching once you get used to it
16:27:56 <mauke> haskell lets you define a single function in multiple equations
16:28:11 <mauke> it's not related to overloading
16:28:17 <emu> i find pattern matching to be one of the most powerful expressive tools available
16:29:36 <defcon8> x3m, opinion*
16:29:43 <defcon8> doesn't*
16:30:30 <emu> dannnn: why not?
16:30:54 <x3m> now i managed to do what i wanted
16:31:08 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26656
16:31:19 <x3m> http://paste.lisp.org/display/26656 like that :)
16:31:25 <ihope_> Yep, that works.
16:31:50 <mauke> why are there parens around sqrt and increment?
16:31:51 <emu> what's your motivation for this function?
16:32:00 <x3m> emu: learning
16:32:17 <mauke> why isn't increment succ?
16:32:17 <emu> here's a tidbit then
16:32:22 <x3m> mauke: no idea, someone else made like that in a example here
16:32:34 <mauke> (x) is the same as x
16:32:54 <emu> let increment x = x - 1 in (functionpointer "increment") ... which version of increment will be returned, x3m ?
16:33:38 <x3m> emu: no idea, rewrite that in C++ code and i'll give an answer ;)
16:34:01 <emu> you need to learn about Lexical Scope
16:34:06 <emu> this is a good example
16:34:15 <emu> C++ doesn't have that
16:34:29 <emu> well, sorta
16:34:34 <x3m> are you implying my function is bad?
16:34:40 <x3m> or just testing me
16:34:47 <emu> not in that sense
16:34:53 <emu> this is something you need to understand about scope
16:35:22 <x3m> okay, well since im just a few hours past hello world i've probably not reached that really yet
16:36:55 <ThreeQ> > let x = 1
16:36:56 <emu> > "Hello World!"
16:36:56 <lambdabot>  Parse error
16:36:57 <lambdabot>  "Hello World!"
16:37:21 <x3m> does haskell has some standard way of dealing with errors? like if the argument in this function dont equal to an existing function?
16:37:45 <ThreeQ> you could have an empty pattern
16:37:51 <ThreeQ> _
16:38:09 <ThreeQ> functionpointer _ = <whatever function>
16:38:16 <sjanssen> x3m: there is there error function
16:38:27 <sjanssen> s/there/the
16:38:44 <x3m> ThreeQ: like: "functionpointer_ = " it dont do anything?
16:39:06 <ThreeQ> well it has to equal something
16:39:11 <ThreeQ> or else what will be returned
16:39:21 <ThreeQ> but you could say "functionpointer _ = id"
16:39:22 <ThreeQ> and it will return a function that does nothing
16:39:25 <sjanssen> x3m: put a space before _
16:39:36 <x3m> ofc
16:39:48 <ThreeQ> @type id
16:39:49 <lambdabot> forall a. a -> a
16:39:50 <sjanssen> and you need something on the RHS, like error "invalid function name"
16:40:13 <x3m> could i also write it like this: ... "sqrt" -> sqrt; _ -> ;?
16:40:21 <x3m> inside a case
16:40:22 <emu> gotta supply something
16:40:30 <emu> _ -> id
16:40:36 <x3m> whats id?
16:40:39 <emu> or even undefined, but hey
16:40:40 <emu> > id 1
16:40:42 <lambdabot>  1
16:40:45 <ThreeQ> > id "asdfasdgawrehaern"
16:40:47 <lambdabot>  "asdfasdgawrehaern"
16:40:51 <x3m> thats good enough
16:40:53 <emu> > undefined
16:40:54 <lambdabot>  Add a type signature
16:41:02 <emu> @type undefined
16:41:03 <lambdabot> forall a. a
16:41:39 <ThreeQ> > id id id id id id id id id 1
16:41:41 <lambdabot>  1
16:41:52 <x3m> but what does id stand for
16:41:56 <emu> > id . id . id . id . id 1
16:41:57 <lambdabot>  add an instance declaration for (Num (a -> b))
16:41:58 <ThreeQ> "identity"
16:41:58 <emu> identity
16:42:03 <x3m> ok
16:42:08 <emu> > id . id . id . id . id $ 1
16:42:09 <lambdabot>  1
16:43:50 <ThreeQ> you could also use error, if you just want it to stop where it is
16:43:57 <ThreeQ> > error "this is an error!"
16:43:58 <lambdabot>  Add a type signature
16:44:18 <ThreeQ> > error "this is an error!" :: (Float -> Float)
16:44:19 <lambdabot>  <Float -> Float>
16:44:28 <ThreeQ> hmm
16:44:37 <ThreeQ> well it works in real life :)
16:49:54 <ihope_> > error "Error" + 3
16:49:56 <lambdabot>  Exception: Error
16:50:10 <ihope_> > ['a'..error "Another error"]
16:50:11 <lambdabot>  Exception: Another error
16:50:30 <ihope_> > error (error "lambdabot doesn't like it when you do this")
16:50:31 <lambdabot>  Add a type signature
16:50:34 <ihope_> > error (error "lambdabot doesn't like it when you do this") :: Int
16:50:36 <lambdabot>  Exception: lambdabot doesn't like it when you do this
16:50:39 <ihope_> Oh.
16:50:52 <ihope_> > fix error
16:50:53 <lambdabot>  Exception: <<loop>>
16:50:58 <ihope_> You get the idea.
16:57:15 <x3m> why isnt putStrLn in IO and in Import IO?
16:57:24 <vincenz> @hoogle putStrLn
16:57:25 <lambdabot> Prelude.putStrLn :: String -> IO ()
16:57:25 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
16:57:42 <x3m> that tells me nothing
16:57:54 <vincenz> was just checking
16:58:14 <vincenz> prolly history and politics
16:58:15 <vincenz> anyways
16:58:17 * vincenz >>= bed
16:58:57 <sjanssen> x3m: it's used often enough that it is in the Prelude -- which is implicitly imported in all Haskell modules
16:59:10 <x3m> okay
17:00:37 <x3m> afunction :: Int -> Float, is it takes an int as argument and gives out a float, but what is: afunction :: Handle -> String -> IO (), and the "()" at the end there?
17:01:33 <sjanssen> x3m: IO () means the IO action that returns nothing
17:01:45 <ThreeQ> afunction takes a handle and returns a function that takes a string and returns an io action that returns nothing :)
17:01:56 <ihope_> IO action that returns (), to be more accurate.
17:02:07 <x3m> okay, like void
17:02:11 <ihope_> Yep.
17:02:37 <ihope_> C function that takes no arguments and returns void = IO ()
17:03:08 * ihope_ suddenly disappears
17:12:42 <x3m> @hoogle putStr
17:12:42 <lambdabot> Prelude.putStr :: String -> IO ()
17:12:42 <lambdabot> Prelude.putStrLn :: String -> IO ()
17:12:42 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
17:13:15 <x3m> whats the difference between putStrLn and putStr, a newline?
17:14:41 <Igloo> Yes
17:15:51 <x3m> @hoogle localhost
17:15:51 <lambdabot> No matches found
17:21:05 <dfranke> What's the appropriate place to put .h files in a cabal spec?  Just extra-source-files, or somewhere else?
17:26:01 <Igloo> dfranke: includes
17:26:39 <Igloo> Hmm, maybe extra-source-files if you don't need it installed, actually
17:27:24 <dfranke> putting it in includes doesn't even seem to get it into the distribution tarball.
17:28:54 <glguy> h.o's up
17:31:09 <dfranke> also... if I generate a FunPtr from a wrapper stub, is it safe to pass it into C and free it using free() rather than using freeHaskellFunPtr?
17:32:53 <x3m> @paste
17:32:53 <lambdabot> http://paste.lisp.org/new/haskell
17:34:28 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26657
17:34:45 <x3m> why doesnt this work?
17:35:26 <sjanssen> x3m: compile with --make or the appropriate -package flag
17:36:18 <x3m> oh, i missed the --make part
17:41:02 <dfranke> gah... ok: I'm allocating a C structure and storing several function pointers allocated by a wrapper stub into the structure.  I'm creating a ForeignPtr to the C structure and adding a finalizer that frees it.  How do I make sure the function pointers get freed when the structure does?
17:43:11 <dfranke> The obvious thing to do is just free() the function pointers from C but I have no idea if that's safe.
17:44:28 <dfranke> and the FFI spec says specifically that it's not OK to call back into haskell from the finalizer.
17:44:46 <sjanssen> dfranke: call freeHaskellFunPtr in your finalizer?
17:45:02 <dfranke> sjanssen: but the finalizer is a C function.
17:45:39 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26659
17:45:56 <dfranke> and if the finalizer is another pointer allocated from a wrapper stub then I've got some serious chicken-and-egg problems.
17:45:57 <x3m> isnt that enough to connect?
17:49:01 <sjanssen> dfranke: could you use a finalizer like this? \p -> do freeHaskellFunPtr foo; finalizerInC p
17:49:56 <dfranke> sjanssen: ok, but then I need to make a wrapper stub for that function and allocate a pointer to it.  When does that get freed?
17:50:27 <sjanssen> mmm, good point
17:52:26 <dfranke> Ok, I think I need to RTFCS and see if I can get away with using free().
17:57:00 <dfranke> oh, this is so wonderfully helpful.
17:57:05 <dfranke> errorBelch("freeHaskellFunctionPtr: not for me, guv! %p\n", ptr);
17:57:45 <sjanssen> dfranke: I found that while grepping too
17:57:51 <dfranke> and the answer to my question appears to be no.
17:57:52 <sjanssen> wonder what it's supposed to mean
18:09:22 <dfranke> ah, ok... I think System.Mem.Weak will help me out.
18:10:39 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26662
18:10:43 <dfranke> I can box the ForeignPtr in an abstract type, and then pass the abstract object to addFinalizer with a procedure that fetches the function pointers and frees them.
18:10:53 <x3m> http://paste.lisp.org/display/26662 why dont this connect to here?
18:11:55 <sjanssen> x3m: the Haskell code looks right, I don't know the IRC protocol though
18:12:22 <sjanssen> also, it's probably bad manners to do tests like that on a public IRC server/channel
18:12:25 <x3m> ok, yeah it compiles but not much happens
18:13:08 <x3m> eh no it aint, it could be if it spams a channel
18:16:54 <sjanssen> x3m: I think you want chat.freenode.net instead of irc.freenode.net
18:17:33 <x3m> naah the later one should be correct
18:29:36 <x3m> http://haskell.org/ghc/docs/latest/html/libraries/ why dont i see IO there or is it the same as System.IO?
18:29:39 <lambdabot> http://tinyurl.com/hxrk7
18:30:40 <sjanssen> x3m: you should use System.IO instead of IO
18:33:19 <x3m> umm why?
18:34:29 <sjanssen> I guess it isn't a big deal either way
18:37:39 <sjanssen> IO predates the hierarchical modules extension (basically allows modules to have dots in their name), after that extension many modules were relocated to more descriptive locations
18:37:49 <Bobstopper> is GHC smart enough to recognise a (reverse . reverse) pattern and take it out?
18:37:51 <sjanssen> List -> Data.List, IO -> System.IO, etc.
18:38:02 <sjanssen> Bobstopper: I'd bet against it
18:38:18 <Bobstopper> k, thanks
18:40:48 <x3m> sjanssen: would that mean IO and System.IO is the same thing
18:43:10 <sjanssen> System.IO is essentially a superset of IO
18:56:37 <lennart> Bobstopper: I doubt very much that it removes (reverse . reverse) since it's not valid in general.
18:57:02 <glguy> the correct result of (reverse . reverse) on a stream should be bottom
18:57:52 <hyrax42> I was just about tos ay that :/
19:10:49 <Cale> otoh, if an identity holds for all finite cases, is it really that harmful to make that replacement?
19:11:53 <Cale> Should we be worried about increasing definedness of terms when the manner in which we're doing so is natural?
19:13:19 <x3m> Cale: can you check my latest paste?
19:15:47 <sjanssen> Cale: I think there are other problem cases, like (1:undefined)
19:16:35 <sjanssen> plus strictness properties
19:16:55 <NamelessOne> > let x = -2147483648 :: Int in -x == x
19:16:57 <lambdabot>  True
19:18:02 <dons> ?scheck (\s -> -s /= s) :: Int -> Bool
19:18:03 <lambdabot>   Failed test no. 2. Test values follow.: 0
19:18:15 <dons> ?check (\s -> -s /= s) :: Int -> Bool
19:18:16 <lambdabot>  Falsifiable, after 0 tests: 0
19:18:51 <dons> ?check (\s -> s /= 0 ==> -s /= s) :: Int -> Property
19:18:53 <lambdabot>  OK, passed 500 tests.
19:18:59 <dons> ?scheck (\s -> s /= 0 ==> -s /= s) :: Int -> Property
19:19:00 <lambdabot>  Completed 10 test(s) without failure.  But 1 did not meet ==> condition.
19:19:10 <dons> they should include maxBound
19:19:11 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:19:17 <sjanssen> hmm, should http://darcs.haskell.org/1 really be there?
19:23:33 <Bobstopper> > (reverse . reverse) [1,2,3,4]
19:23:36 <lambdabot>  [1,2,3,4]
19:23:43 <dons> ?quit wibble
19:24:00 <dons> seems a bit odd, sjanssen , doen't it
19:24:09 <sjanssen> > head . reverse . reverse $ (1:undefined)
19:24:17 <sjanssen> > head (1:undefined)
19:24:26 <x3m> dons: http://paste.lisp.org/display/26662 can you see why this dont work?
19:25:05 <Bobstopper> Ohhhh I getcha. it won't work on an infinite list...
19:25:11 <dons> looks ok. let me try it
19:26:18 <sjanssen> dons: yeah, that file doesn't have anything important in it.  But it is worrying that a user on d.h.o decided to cp /etc/passwd $httproot
19:26:29 <dons> hmmm...
19:27:10 <dons> x3m, the main thread is going to exit .....
19:27:19 <dons> you need to wait on the result of your forked child, I think
19:27:34 <dons> for example
19:27:38 <x3m> might be correct, how do i fix that?
19:27:38 * dons hacks ....
19:32:18 <x3m> @paste
19:32:18 <lambdabot> http://paste.lisp.org/new/haskell
19:32:32 <lisppaste2> test pasted "." at http://paste.lisp.org/display/26671
19:32:39 <es> I'm reading haskell98 report. What is "type environment"? Is it what type signature defines?
19:32:51 <x3m> i found that code, i dont really understand all of it though
19:33:28 <x3m> ooh, yours connected
19:34:27 <dons> :)
19:34:30 <dons> i'll paste it in a second
19:35:34 <dons> there we go
19:35:39 <dons> PRIVMSG #haskell :there we go
19:36:13 <lisppaste2> dons pasted "working irc bot" at http://paste.lisp.org/display/26672
19:37:49 <x3m> dons: thx but look at this code: http://paste.lisp.org/display/26671 how come his main dont exit?
19:38:30 <lisppaste2> dons annotated #26672 with "cleaner" at http://paste.lisp.org/display/26672#1
19:39:11 <dons> x3m, because of the lazy getContets
19:39:20 <dons> input <- getContents
19:39:20 <dons>     sequence_ $ map ( \a -> do
19:39:21 <dons> ...
19:39:33 <dons> is a loop that maps 'putStr' over all input coming on stdin
19:39:36 <x3m> oh, is that a good way to solve it?
19:39:44 <dons> so as long as stdin stays open, you can keep typing in commands to the bot
19:39:45 <lennart> is hackage working?  is anyone using it?
19:39:53 <x3m> that might be good
19:39:55 <dons> x3m, well, its one way of doing it, I suppose.
19:40:06 <dons> a shell interface would be another
19:40:23 <x3m> what is that?
19:40:40 <dons> x3m, you know, print a prompt, and read a command in.
19:41:01 <x3m> yeah but isnt that what his code does also
19:41:06 <profmakx> @time dons
19:41:07 <lambdabot> Local time for dons is Mon Sep 25 12:40:44 2006
19:41:09 <dons> like lambdaweb, http://lambdabot.codersbase.com/
19:41:10 <lambdabot> Title: Lambdabot Web Interface
19:41:31 <dons> yeah, but its a little bit obfuscated, I'd say
19:41:34 <Bobstopper> How might I find out a machine architecture's endianness using haskell?
19:41:50 <dons> Bobstopper: how would you do it in C?
19:42:40 <dons> you could start with,
19:42:41 <dons> Prelude> System.Info.os
19:42:42 <dons> "openbsd"
19:42:42 <dons> Prelude> System.Info.arch
19:42:42 <dons> "i386"
19:42:53 <dons> but I suspect you'll need to be smarter than that :)
19:43:05 <Bobstopper> Yeah, I was originally going to do it that way, but wanted to do it smarter :)
19:43:26 <lennart> well, you can always allocate a few bytes and poke&peek
19:43:50 <Bobstopper> Ah, poke & peek might be it...
19:44:15 <Bobstopper> alas it means IO  but I suppose it's better than nothing :(
19:44:15 <lennart> well, that's what you'd do in C if you didn't get it from a header file or system call
19:44:40 <lennart> it's also IO where unsafePerformIO is perfectly safe
19:45:11 <Bobstopper> Oh good, that was another thing I was going to ask: IO for which there are no side effects is fine to use unsafePerformIO on, yes?
19:45:47 <lennart> that's the general rule, yes
19:46:07 <lennart> no observable effects
19:46:40 <Bobstopper> One more Q: Storable objects require Ptr objects - how does one go about getting a Ptr object from within haskell? I found GHC.Exts.Ptr but that doesn't sound too portable, and it still requires a Addr# which I don't know how to construct.
19:47:03 <lennart> alloca would be a good way
19:47:14 <sjanssen> Bobstopper: or with
19:47:18 <x3m> cool it works
19:47:38 <x3m> dons: my msg recv loop is abit odd though, the text it prints out looks strange
19:47:39 <sjanssen> Foreign.Marshal.Utils.with that is
19:48:02 <Bobstopper> Loverly. Thanks for all your helps
19:59:55 <glguy> LOL at news media, critisizing local town for making it illegal to employ and house illegal immigrants
20:00:32 <sjanssen> glguy: what country are you in?
20:00:48 <glguy> The United States
20:00:55 <wkh> america, the country that isn't allowed to protect its sovereignty
20:01:19 <sjanssen> it is already illegal to employ immigrants, anyway, right?
20:01:20 <glguy> it is racist to enforce laws if a particular race is more likely to violate the law
20:01:25 <glguy> at least that's the case in the USA
20:01:51 <wkh> sjanssen: it's unenforced because businesses get rich by exploiting illegal labor
20:01:56 <sjanssen> s/immigrants/illegal immigrants
20:02:05 <sjanssen> wkh: right
20:03:07 <glguy> sjanssen: yes, it's illegal at the national level
20:03:46 <glguy> and now in Vally Park, it's illegal locally(which, apparently, is a terrible thing)
20:04:18 <sjanssen> seems odd to reiterate a federal law
20:04:28 <glguy> it allows local enforcement to deal with it
20:04:50 <glguy> since the federal government isn't doing its job
20:05:13 <glguy> in this case specifically
20:05:27 <glguy> I'm not attempting to make a general statement
20:06:01 <dons> mmm. #haskell-blah ?
20:06:20 <glguy> I shut up when something #haskell related comes along
20:06:35 <dons> > map (+1) [1..10]
20:06:37 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:06:39 <dons> haskell!
20:06:45 <Patterner> correct.
20:06:47 <glguy> and I use irssi, so multiple channels isn't exactly feasible ;)
20:06:54 <dons> hmm?
20:07:10 <dons> you know about /win n ?
20:07:18 <glguy> I don't like having to switch back and forth, and the /win stuff never works well for me
20:07:47 <glguy> but teaching me about irssi seems more like an #irssi thing (c:
20:08:28 <hyrax42> what are the differences between Data.Array and Data.Array.IArray arrays?
20:08:33 <glguy> > [id] <*> [()]
20:08:34 <lambdabot>  Not in scope: `<*>'
20:09:14 <sjanssen> hyrax42: IArray is an overloaded interface so you can use several array types, like DiffArray and UArray
20:09:20 <hyrax42> oh
20:09:25 <hyrax42> I want a UArray anyway I just realised
20:09:29 <hyrax42> U = unboxed right?
20:09:36 <glguy> yeah
20:09:58 <Patterner> all you need for irssi is alt-a
20:10:06 <sjanssen> Data.Array.IArray is the way of the future
20:10:11 <glguy> what is alt-a
20:10:21 <hyrax42> so I would import Data.Array.IArra
20:10:21 <hyrax42> y
20:10:27 <hyrax42> and Data.Array.UArray?
20:10:36 <sjanssen> hyrax42: yep
20:10:47 <glguy> write your function to work on IArrays and explicitly type the thing that generates your array
20:10:49 <hyrax42> or .Unboxed rather
20:11:03 <hyrax42> sjanssen, glguy: thanks
20:13:19 <hyrax42> also, is there any particular reason to use say a UArray (Word8, Word8) Word8 over a UArray (Int,Int) Word8?
20:13:24 <hyrax42> will they end up compiled to same?
20:14:45 <hyrax42> (my array bounds will be ((0,0),(6,6))
20:14:46 <x3m> dons: still here?
20:14:49 <dons> es.
20:14:50 <hyrax42> or 1,1 7,7
20:15:29 <sjanssen> hyrax42: there is no large advantage between either
20:15:44 <hyrax42> kk
20:15:46 <sjanssen> go with whichever is more convenient to write
20:16:09 <hyrax42> and I should hold off the unsafe stuff until I see it might give a performance increase
20:16:13 <hyrax42> ?
20:16:26 <x3m> dons: I get this: ":port80a.se.quakenet.org 451 nick nick :Register first." http://www.mirc.net/raws/?view=451 this shows i probably send the join command to fast, how could i fix that.. with a sleep function or something?
20:16:50 <dons> you could threadDelay for a second, perhaps
20:17:00 <dons> or perhaps register first?
20:17:00 <sjanssen> hyrax42: probably.  Bounds checking overhead usually isn't too bad
20:17:07 <dons> ?hoogle threadDelay
20:17:08 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
20:17:13 <hyrax42> sjanssen: ok
20:17:26 <hyrax42> oh and finally, does hugs have UArray?
20:19:08 <wkh> i can never bring myself to be anything but a fighter/barbarian in rpgs
20:19:15 <wkh> i wonder if that says something about my personality.
20:19:22 <stepcut> wkh: seal clubber ?
20:19:29 <dons> x3m: i.e.
20:19:29 <dons>         putStrLn "Sent user"
20:19:30 <dons>         threadDelay (1000 * 1000)
20:19:30 <dons>         hPutStr handle "join #haskell-overflow\r\n"
20:19:30 <dons>         putStrLn "Sent join"
20:19:42 <dfranke> Oh my god! It typechecked!
20:19:44 <dons> (1 sec delay)
20:19:51 <hyrax42> wkh: me typically mage types
20:19:57 <dons> stepcut: heh
20:21:24 <dons> x3m, I might turn this irc bot idea into a short tutorial on writing network code in haskell
20:21:30 <dons> any thoughts on that?
20:22:02 <dfranke> It typechecked to the CORRECT TYPE!
20:22:22 <x3m> well it would have been a help, on the other hand when you are done its probably to late for me :)
20:22:46 <dons> sure :) seems like a useful thing for beginners trying to pick up the language
20:22:50 <dons> everyone wants to write network clients
20:23:06 <x3m> yes, its probably not a bad idea
20:23:06 <stepcut> dons: and rpgs
20:23:21 <dons> that too
20:23:28 <x3m> making people think they have accomplished something advanced when they begin with haskell
20:23:41 <x3m> like in c++ this takes pretty much code
20:24:06 <stepcut> It would be great to make some sort of extensible RPG that newbies could add new quests to or something
20:24:26 <stepcut> but, that is about all I have figured out about that idea so far :)
20:24:32 <x3m> bad thing would be you could get this channel overflowed with bots ;)
20:25:09 <hyrax42> ahhhh
20:25:19 <hyrax42> I always wondered why people ran hugs with -98 as arg
20:25:27 <hyrax42> cos I thought that would insist on Haskell 98
20:25:32 <hyrax42> rather the - is to turn that off
20:25:56 <hyrax42> stay tuned; more obvious proclamations to follow!
20:25:58 <sjanssen> hyrax42: I find -98 confusing also
20:26:17 <hyrax42> it had me confused for aaaages
20:26:50 <hyrax42> till just now I did man hugs to find out why the . in an existential type was making hugs complain
20:26:58 <hyrax42> in ST.hs
20:27:55 <dons> x3m, right. I think i'll not put in #haskell as the bot target chan
20:29:06 <hyrax42> dfranke: what is "it"?
20:29:25 <x3m> dons: :O)
20:29:36 <scsibug_> could someone enlighten me as to what version of fps i should be using with HAppS?
20:29:55 <dons> fps 0.7 ?
20:30:17 <dons> scsibug_: do you get a build error, or are you just wondering?
20:30:53 <scsibug_> yes, i get an error on the build
20:30:59 <dons> what error?
20:31:07 <dons> and with which fps version?
20:32:21 <scsibug_> I've got 0.7 installed
20:32:30 <dons> and the error msg?
20:32:38 <scsibug_> and when i run the build on HAppS, I get "Could not find module `Data.FastPackedString':"
20:32:40 <dons> or should I try to guess? :)
20:32:51 <dons> oh, looks like a very old fps dependency
20:33:00 <dons> let me see ...
20:33:01 <scsibug_> right
20:33:09 <x3m> dons: try if you can connect to: irc.quakenet.org 6667 with your bot
20:33:11 <dons> I think there are newer HAppS than that.
20:33:21 <scsibug_> this is 0.8
20:33:28 <scsibug_> I thought it was the latest
20:33:44 <dons> musasabi: around?
20:33:50 <dons> scsibug_: check with musasabi
20:33:59 <scsibug_> k, thanks
20:34:06 <scsibug_> i'll try grabbing the dev version
20:34:47 <dons> x3m: 451 donstesths donstesths :Register first
20:34:54 <dons> i.e. you need to register the nick first
20:35:05 <dons> you'll have to do that, I think, x3m
20:35:08 <dons> and then identify
20:35:48 <x3m> dons: well, i dont do that with the bot i wrote in c++ nor im i doing it in mirc
20:35:53 <dons> x3m, it might be someting like: nickserv identify passwd
20:37:32 <dons> try joining after its connected properly
20:38:50 <x3m> dons: thats what im trying to, with the threadsleep
20:40:14 <dons> still asks to register first, even when I have it correctly wait
20:40:54 <dons> ?paste
20:40:55 <lambdabot> http://paste.lisp.org/new/haskell
20:41:11 <x3m> dons: maybe have to reply to the ping
20:41:46 <lisppaste2> dons pasted "forkIO reader thread" at http://paste.lisp.org/display/26676
20:41:49 <dons> yeah, that's another thing.
20:42:16 <dons> the above let's you type in "join #chan" on stdin after you've seen it conect
20:42:39 <x3m> ah that helps abit
20:43:59 <lisppaste2> dons pasted "fmt" at http://paste.lisp.org/display/26677
20:44:05 <dons> ^^ just some formatting clean ups
20:47:13 <x3m> dons: that was it, had to reply to the ping, was a stupid message from the server
20:47:43 <dons> cool
20:48:25 <dons> you reply with a pong?
20:49:42 <x3m> yeah
20:50:07 <x3m> i just typed in: PONG :thenumber
20:50:41 <x3m> should make a function for that though
20:50:53 <x3m> that automatically responds to pings
20:51:22 <dons> yeah, that's easy enough. let me paste one ...
20:51:28 <hyrax42> can DiffArrays be used outside of IO?
20:51:46 <dons> huh "No hosts from Asia-pacific on this server, thanks."
20:51:49 <dons> boo!
20:51:59 <x3m> heh
20:52:05 <dons> ?paste
20:52:05 <lambdabot> http://paste.lisp.org/new/haskell
20:52:59 <x3m> i wonder if it would be hard to implement eval in this
20:53:15 <lisppaste2> dons pasted "writer thread tweaks" at http://paste.lisp.org/display/26678
20:53:30 <dons> that gives a hint on how to insert processing of pings and other things into the writer thread
20:54:06 <hyrax42> anyone?
20:54:29 <dons> then you can add 'quit' handling to the reader thread
20:54:38 <dons> which , when you type "quit" will close the socket and exit
20:57:23 <x3m> ('P':'I':'N':'G':' ':':':n)
20:57:31 <x3m> why 3 of ':' those?
20:57:36 <x3m> or aha
20:57:38 <x3m> nvm
20:57:44 <dons> > 'P':'I':'N':'G':' ':':'
20:57:45 <lambdabot>  Couldn't match `[Char]' against `Char'
20:57:50 <dons> you could use `isPrefixOf` though
20:57:59 <dons> > 'P':'I':'N':'G':' ':':':[]
20:58:00 <lambdabot>  "PING :"
20:58:29 <dons> > "PING :" `isPrefixOf` "PING :123"
20:58:30 <lambdabot>  True
21:00:51 <x3m> hmm
21:01:09 <hyrax42> ok another quick diffarray question... if the older versions are no long referenced, will the diffs be gc'ed?
21:01:11 <x3m> what does it stop the extract at, numbers?
21:01:32 <dons> end of line, in this case
21:01:43 <dons> it's just pattern matching, and extracting the end of the line
21:02:01 <x3m> oh ok
21:02:31 <hyrax42> is there not more elegant way to match that PING case?
21:03:00 <dons> yeah, you can match the ping in a nicer way
21:03:51 <dons> > (\s -> case () of _ | "PING" `isPrefixOf` s -> drop 6 s) "PING: 123"
21:03:52 <lambdabot>  "123"
21:04:04 <dons> > (\s -> case () of _ | "PING" `isPrefixOf` s -> "PONG :"++ drop 6 s) "PING: 123"
21:04:05 <lambdabot>  "PONG :123"
21:04:38 <hyrax42> kk
21:04:55 <hyrax42> handy cos I'll have some network protocol coding of my own to do soon
21:06:42 <hyrax42> sorry for the barrage, but another q
21:07:16 <hyrax42> if I have a datatype with all nullary constructors and it derives Enum, will it be equivalent, performance-wise to using an Int in its place?
21:07:40 * hyrax42 thinks he should stop worrying about performance
21:07:46 <hyrax42> (for now)
21:08:40 <lisppaste2> dons annotated #26678 with "nicer, and handle quit" at http://paste.lisp.org/display/26678#1
21:09:04 <x3m> dons; do we have to hClose handle?
21:09:19 <x3m> for a proper shutdown that is
21:10:34 <dons> can't hurt, anyway
21:10:54 <dons> sending quit seems to do the job though
21:12:10 <x3m> (foldr (++) "" (map (\x -> (show x) ++ "\n") (lines x))) what does this crypting thing do?
21:12:25 <x3m> foldr (++) should be for concatenating strings i guess
21:12:45 <dons> > let x = "abc\ndef\ghi" in (foldr (++) "" (map (\x -> (show x) ++ "\n") (lines x)))
21:12:45 <lambdabot>  Illegal escape sequence
21:12:57 <dons> > let x = "abc\ndef\nghi\n" in (foldr (++) "" (map (\x -> (show x) ++ "\n") (lines x)))
21:12:59 <lambdabot>  "\"abc\"\n\"def\"\n\"ghi\"\n"
21:13:08 <weitzman> > (\x -> case x of "PING":_ -> "blah") "PING: 123"
21:13:09 <lambdabot>  Couldn't match `[Char]' against `Char'
21:13:26 <dons> ?type "PING":_
21:13:27 <lambdabot> Pattern syntax in expression context: _
21:13:44 <dons> ?type let f ("PING":_) = 1 in f
21:13:45 <lambdabot> forall t. (Num t) => [[Char]] -> t
21:13:51 <weitzman> > (\x -> case x of "PING":_\rest -> rest) "PING: 123"
21:13:52 <lambdabot>  Parse error
21:14:18 <dons> "foo:_ :: [String], not String
21:14:24 <weitzman> > (\x -> (case x of ("PING":_) -> "blah") "PING: 123"
21:14:24 <lambdabot>  Parse error
21:14:35 <weitzman> I'm not completely satisfied
21:14:36 <dons> > "foo":"bah:[]
21:14:36 <lambdabot>  Improperly terminated string
21:14:41 <dons> > "foo":"bah":[]
21:14:41 <weitzman> What with my code not parsing
21:14:42 <lambdabot>  ["foo","bah"]
21:14:52 <weitzman> Oh
21:14:53 <weitzman> Yeah
21:14:57 <weitzman> That makes sense
21:15:19 <weitzman> There should be some happy solution
21:15:20 <dons> > (\x -> (case x of "PING":_ -> "blah")) ["PING:","123"]
21:15:22 <lambdabot>  Non-exhaustive patterns in case
21:15:28 <ThreeQ> > (concat . map ((++ "\n") . show) . lines) "abc\ndef\nghi"
21:15:29 <dons> > (\x -> (case x of "PING":_ -> "blah")) ["PING","123"]
21:15:29 <lambdabot>  "\"abc\"\n\"def\"\n\"ghi\"\n"
21:15:30 <lambdabot>  "blah"
21:16:00 <hyrax42> newtypes can't derive Integral or Bits?
21:16:12 <weitzman> > (\x -> (case x of ('P':'I':'N':'G':_) -> "blah") "PING: 123"
21:16:13 <lambdabot>  Parse error
21:16:27 <weitzman> > (\x -> (case x of ('P':'I':'N':'G':_) -> "blah")) "PING: 123
21:16:28 <lambdabot>  Improperly terminated string
21:16:33 <weitzman> > (\x -> (case x of ('P':'I':'N':'G':_) -> "blah")) "PING: 123"
21:16:35 <lambdabot>  "blah"
21:16:38 <weitzman> Ha! I win!
21:16:45 <weitzman> Take that, lambdabot
21:19:31 <shapr> @yow !
21:19:32 <lambdabot> This PORCUPINE knows his ZIPCODE ... And he has "VISA"!!
21:19:43 <shapr> hey dons, who's going to Googleplex?
21:20:39 <shapr> @users
21:20:40 <lambdabot> Maximum users seen in #haskell: 241, currently: 214 (88.8%), active: 20 (9.3%)
21:21:49 <dons> shapr: don't know? exciting though
21:22:00 <dons> hey nice, shapr's almost in my timezone now
21:22:07 <shapr> @timein shapr
21:22:09 <lambdabot> Local time for shapr is Sun Sep 24 23:21:46 2006
21:22:12 <shapr> @timein dons
21:22:14 <lambdabot> Local time for dons is Mon Sep 25 14:21:51 2006
21:22:19 <shapr> Much closer, I agree.
21:24:01 <dons> shapr, yeah saw your comment. maybe it was that little tut that brought down haskell.org -- though that's a bit scary
21:24:01 <magnus-> @timein lambdabot
21:24:02 <lambdabot> I live on the internet, do you expect me to have a local time?
21:24:12 <dons> ?time lambdabot
21:24:12 <lambdabot> I live on the internet, do you expect me to have a local time?
21:24:21 <dons> timein is actually a typo ;)
21:24:27 <shapr> I know :-)
21:24:59 <dons> in fact, the original 'timein' plugin was the last bit of perl i've written
21:25:21 <dons> #!/usr/bin/perl
21:25:21 <dons> #
21:25:21 <dons> # author : Don Stewart
21:25:21 <dons> # Tue Oct  5 12:24:58 EST 2004
21:25:23 <dons> :)
21:25:46 <shapr> I'm looking around for free+legal movies to watch, some of this stuff is just terrible, like "Bride of the Gorilla" - http://www.publicdomaintorrents.com/nshowmovie.html?movieid=44
21:25:47 <dons> "Hi, I'm Don. And its been 100 weeks since I last wrote perl"
21:25:50 <lambdabot> Title: Bride of the Gorilla, http://tinyurl.com/gufwq
21:25:55 <shapr> Welcome Don!
21:26:05 <dons> :)
21:28:13 <shapr> A few people at HW mentioned that they were waiting for Fermat's Last Margin to be released so I'm putting some time into that..
21:28:21 <dons> good!
21:28:36 <shapr> What are you working on today?
21:28:47 <dons> i've a paper review to finish
21:28:56 <dons> and then more work on my polymer chem simulator
21:29:02 <shapr> Sounds very cool.
21:29:26 <dons> hey, john hughes is writing up some notes on CUFP for this week's HWN
21:29:36 <shapr> Cool, I wish I could have been there.
21:29:45 <svref> augh!  Will someone please noogie the genius who decided "-1" should NOT be the numeric literal negative one?
21:29:47 <dons> maybe we can try to get an insider at all the big conferences now, for the communit news letter.
21:30:02 <shapr> svref: try (-1)
21:30:08 <dons> > -1
21:30:09 <lambdabot>  -1
21:30:11 <dons> > (-1)
21:30:13 <lambdabot>  -1
21:30:23 <shapr> > (- 1)
21:30:23 <dons> noogie?
21:30:25 <lambdabot>  -1
21:30:34 <shapr> (-) 1
21:30:38 <shapr> > (-) 1
21:30:38 <dons> ?type subtract 1
21:30:39 <lambdabot>  Add a type signature
21:30:40 <lambdabot> forall a. (Num a) => a -> a
21:30:56 <dons> > subtract 1 0
21:30:57 <lambdabot>  -1
21:31:06 <svref> > id -1
21:31:07 <lambdabot>  add an instance declaration for (Num (a -> a))
21:31:13 <dons> > id (-1)
21:31:14 <lambdabot>  -1
21:31:23 <dons> > id (\x -> subtract 1 x)
21:31:24 <lambdabot>  Add a type signature
21:31:33 <dons> > id (\x -> subtract 1 x) :: Int
21:31:33 <lambdabot>    The lambda expression `\ x -> ...' has one arguments,
21:31:34 <lambdabot>   but its type `...
21:31:42 <dons> oh
21:31:54 <dons> > id ((\x -> subtract 1 x) 0)
21:31:55 <lambdabot>  -1
21:32:09 <svref> I submit that when Haskell requires more ()s than the equivalent expression in Lisp, that Haskell has dropped the ball.
21:32:19 <weitzman> @type (iterate id) subtract
21:32:20 <lambdabot> forall a. (Num a) => [a -> a -> a]
21:32:26 <dons> prefix - is commonly recognised as a wart, yes.
21:32:30 <weitzman> @type iterate
21:32:31 <lambdabot> forall a. (a -> a) -> a -> [a]
21:32:35 <dons> but I think it's unlikely to go away. it's easy to remember ()
21:32:50 <weitzman> @type fix id $ subtract
21:32:51 <lambdabot> forall b. b
21:32:54 <dons> > id $ -1
21:32:56 <lambdabot>  -1
21:33:02 <dons> look ma! no parens
21:33:03 <svref> every other language tokenizes -21.0 as a numeric literal with negative sign.
21:33:29 <dons> svref: you should personally write to wadler, hudak, spj et al, and complain in person :)
21:33:44 <dons> > read "-21.0" :: Float
21:33:46 <lambdabot>  -21.0
21:33:52 <svref> okay, I'll do that!
21:34:04 <weitzman> > read "(+ 1)" :: (Int -> Int)
21:34:05 <lambdabot>  add an instance declaration for (Read (Int -> Int))
21:34:05 <lambdabot>   In the expression: ...
21:34:09 <dons> haskell tokenises it as a numeric literal too :)
21:34:19 <dons> wilx: that'd be fun..
21:34:27 <svref> maybe if its really well recieved, it will become a langauge feature in Haskell 2025... :P
21:34:39 <dons> ?where haskell-prime
21:34:39 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
21:34:47 <dons> its on the board for this year's haskell revision
21:35:50 <dons> here, http://hackage.haskell.org/trac/haskell-prime/ticket/50
21:35:54 <lambdabot> Title: #50 (get rid of unary '-' operator) - Haskell Prime - Trac, http://tinyurl.com/zwdny
21:37:43 <x3m> http://paste.lisp.org/display/26679 parse error on input 'exitWith'
21:38:02 <dons> indenting
21:38:11 <Patterner> Haskell Prime sounds like a planet from Star Trek
21:38:11 <dons> you need to line up the statements after the 'do'
21:38:25 <dons> x3m
21:38:26 <dons>                 "quit" -> do msg h "QUIT"
21:38:26 <dons>                              exitWith ExitSuccess
21:38:38 <x3m> yeah
21:38:51 <x3m> aha
21:39:05 <dons> it's part of the layout rule. when you line them up, the compiler can insert the ; for you
21:39:17 <dons> instead of: do msg ... ; exitWith ; ...
21:39:18 <x3m> im not sure i like all this indenting stuff :P
21:39:26 <dons> well, you can use { ;;; } if you wish
21:39:29 <dons> it's just butt-ugly ;)
21:39:41 <x3m> yeah but i like the ;
21:39:48 <dons> > let { x = 1 ; y = 2 } in x + y
21:39:49 <lambdabot>  3
21:40:08 <x3m> indenting should be to make code look nicer, not to make it work :)
21:40:17 <dons> the use of ; is a hack to work around broken compilers though
21:40:28 <dons> since it doesn't add anything for the human reader
21:40:47 <x3m> for us c++ coders it does
21:40:49 <dons> and most languages written since 1985 don't need ; everywhere, I think
21:41:04 <dons> x3m, see comment about "broken" grammars ;)
21:41:05 <svref> x3m: I think that subtle bugs are introduced when indenting doesn't match the parse tree.  I've seen ssnastiess when if-then-elses line up one way in the grammar and another way on the page.
21:41:55 <dons> not in haskell, though. the type system catches any layout issues like this. they quickly lead to nonsensical expressions
21:41:58 <x3m> svref: well it works perfectly in c++
21:42:07 <x3m> doh i still get an error
21:42:11 <svref> x3m: no, that's what I'm talking about
21:42:21 <dons> x3m, did I put up my version?
21:42:30 <x3m> the function ircmsg is applied to four arguments, but its typ..... only has two
21:43:03 <dons> sounds like a layout error
21:43:07 <x3m> dons: think so, but im not a fan of copying code, i rewrite it.. might getting some indenting errors or something
21:43:09 <dons> i.e. do f x g y
21:43:14 <dons> instead of f x ; g y
21:43:49 <dons> just for reference: http://paste.lisp.org/display/26679#1
21:46:05 <x3m> http://paste.lisp.org/display/26680 looks almost like mine
21:46:30 <dons> no it doesn't :)
21:46:40 <dons>                         "quit" -> do ircmsg h "QUIT"
21:46:41 <dons>                                         exitWith ExitSuccess
21:46:56 <dons> looks like ircmsg is applied to 4 arguments: h , "QUIT", exitWith, and ExitSuccess
21:47:11 <dons> if you indent to the right, its considered part of the previous lines' expression
21:47:22 <dons> if you line them up, you get ; inserted, and it starts a new statement
21:47:35 <dons> so, line up the two statements.
21:47:51 <dons> ?where h98
21:47:51 <lambdabot> http://haskell.org/onlinereport/
21:48:33 <dons> here, http://haskell.org/onlinereport/lexemes.html#sect2.7
21:48:36 <lambdabot> Title: Haskell 98 Lexical Structure, http://tinyurl.com/rofj2
21:49:09 <dons> x3m, you getting a feel for the layout rule?
21:50:07 <x3m> well yes, but it creates problem, havent to use alot of spaces and stuff in the editor to get it right
21:50:13 <x3m> having*
21:50:58 <dons> can you change your tab key to insert spaces by default?
21:51:20 <dons> does your editor do syntax highlighting of haskell? that can help also
21:51:47 <dons> it's like python though, and ruby to some extent. layout is the way of the future
21:51:57 <araujo> Kind error: Expecting kind `* -> *', but `Object' has kind `*'
21:51:57 <araujo>     In the instance declaration for `Monad Object'
21:52:05 <araujo> Any idea about that error message?
21:52:07 <dons> Object needs to be a container
21:52:11 <dons> i.e. Object a
21:52:16 <dons> but its not?
21:52:22 <dons> ?instances Monad
21:52:23 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:52:24 <araujo> oh, mm ... indeed
21:52:28 * araujo checks
21:52:31 <dons> see, they're all paramaterised on an element type
21:52:45 <dons> [] a, Maybe a, Either e, ...
21:53:08 <weitzman> @type (\x -> 1) :: ((->) Bool)
21:53:09 <lambdabot>   `(->) Bool' is not applied to enough type arguments
21:53:10 <lambdabot>   Expected kind `?', but `(->) Bool' has kind `? -> *'
21:53:10 <dons> (same reason there's no Monad ByteString -- since its not a true container type)
21:53:11 <araujo> Indeed, indeed.
21:53:27 <ThreeQ> @pl \x -> (++ "ay") $ take (length x) $ dropWhile (`notElem` "aeiou") $ cycle x
21:53:28 <lambdabot> (++ "ay") . liftM2 take length (dropWhile (`notElem` "aeiou") . cycle)
21:53:29 <araujo> @beat-me-with-a-big-bat
21:53:30 <lambdabot> Unknown command, try @list
21:53:43 <dons> weitzman: values must be types, not type constructors (or partially applied type constructors)
21:53:45 <weitzman> @type (\x -> 1) :: ((->) Bool Int)
21:53:46 <lambdabot> ((->) Bool Int) :: Bool -> Int
21:53:49 <dons> i.e. they must have kind * or #
21:54:11 <weitzman> dons: Check
21:54:17 <dons> > undefined :: Either Int -- :: * -> *
21:54:18 <lambdabot>    `Either Int' is not applied to enough type arguments
21:54:18 <lambdabot>   Expected kind `...
21:54:23 <weitzman> What's #?
21:54:31 <dfranke> Hmm.  I need to interface to a C function that manipulates global state, so I need the wrapper to wait on a global-scoped semaphore.  Is there a better way than `unsafePerformIO $ newQSem 1' to obtain one?
21:54:37 <dons> the unboxed kind. strict, unboxed types (a ghc extension)
21:55:05 <dons> you can distinguish strict unboxed types from normal haskell types, based on the kind # or the kind * (ghc and jhc only, I think)
21:55:19 <SyntaxNinja> w00t
21:55:28 <dons> heya SyntaxNinja
21:55:52 <weitzman> @kind Int32
21:55:54 <lambdabot> *
21:56:04 <weitzman> @kind Foreign.C.Types.CUInt
21:56:05 <lambdabot> *
21:56:06 <x3m> case () of
21:56:06 <x3m> 			_ | "PING :" `isPrefixOf` recvmsg -> ircmsg h $ "PONG :" ++ (drop 6 recvmsg)
21:56:06 <x3m> 			  | otherwise			  -> return ()
21:56:10 <dons> ?kind Int#
21:56:11 <x3m> this looks cryptic
21:56:11 <lambdabot> Not in scope: type constructor or class `Int#'
21:56:17 <dons> ?kind GHC.Base.Int#
21:56:18 <lambdabot> #
21:56:21 <x3m> whats the | for?
21:56:34 <ThreeQ> why don't you just use an if?
21:56:42 <ThreeQ> rather than that strange case thing
21:56:46 <dons> it's a trick to write a switch (I was imagining you'd want to add even more cases)
21:56:54 <dons> you could just use 'when'
21:56:58 <x3m> dons: i sure do :)
21:57:02 <weitzman> @type when
21:57:04 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:57:09 <dons>   > when "PING :" `isPrefixOf` recvmsg $ ircmsg h $ "PONG :" ++ (drop 6 recvmsg)
21:57:34 <dons> x3m, so its a little idiom to let you insert arbitrary tests in a multi-way switch
21:57:42 <weitzman> @type \x -> when x (Just 3)
21:57:43 <lambdabot>   No instance for (Num ())
21:57:43 <lambdabot>    arising from the literal `3' at <interactive>:1:19
21:57:48 <dons> rather than just using pattern matching, it lets you use both patterns and boolean tests
21:57:48 <hyrax42> hm
21:58:01 <weitzman> @type \x -> when x (Just ())
21:58:02 <lambdabot> Bool -> Maybe ()
21:58:03 <hyrax42> how can you get haddock to link to online docs for standard modules?
21:58:34 <hyrax42> I just got: Warning: Types: the following names could not be resolved:
21:58:35 <hyrax42>     Eq Enum Show Int Word8 UArray DiffUArray
21:59:39 <dons> SyntaxNinja: is www.haskell.org  still hosted at yale? but darcs.haskell.org is at galois?
22:00:22 <x3m> case () of
22:00:22 <x3m> 			_ | "PING :" `isPrefixOf` recvmsg -> ircmsg h $ "PONG :" ++ (drop 6 recvmsg)
22:00:22 <x3m> 			  | otherwise			  -> return ()
22:00:22 <x3m> 			"hoop" -> ircmsg h "privmsg #c++.se att"
22:00:26 <ThreeQ> ?yhjulwwiefzojcbxybbruweejw
22:00:26 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
22:00:27 <x3m> is that wrong?
22:00:41 <x3m> i guess i should add that last line in some other way
22:00:45 <dons> the otherwise case matches everything though
22:01:08 <x3m> well it dont even compile
22:01:14 <ThreeQ> ?help yhjulwwiefzojcbxybbruweejw
22:01:15 <lambdabot> V RETURNS!
22:01:16 <dons> so you want to extra the single line "hoop" from the channel stream?
22:01:23 <dons> extract
22:01:52 <x3m> well yeah, just see if it has been typed
22:01:59 <x3m> and then just send something back
22:02:50 <dons>             case x of
22:02:50 <dons>                 "hoop"                      -> ircmsg h "privmsg #c++.se att"
22:02:50 <dons>                 _ | "PING :" `isPrefixOf` x -> ircmsg h $ "PONG :" ++ (drop 6 x)
22:02:53 <dons>                   | otherwise               -> return ()
22:03:09 <dons> note that we were using case () before, but now you actually want to scrutinise the 'x' value
22:03:15 <x3m> oki
22:03:36 <dons> this requires that a single line of "hoop" is entered, though
22:03:43 <dons> you might want to be more flexible than that,
22:03:52 <dons> isi | "hoop" `isPrefixOf` x -> ...
22:04:01 <dons> i.e.
22:05:14 <dons> x3m, if it gets significantly complex, you'll want to write a little lexer or parser
22:06:44 <SyntaxNinja> lalalala
22:06:52 <SyntaxNinja> dons: yeah, that's right.
22:07:14 <SyntaxNinja> does anyone know why it was down?
22:08:25 <dons> there is some suspicion it went down under load, after a wiki page went to the top of reddit, and a number of other blog/url aggregation sites
22:08:40 <dons> but that's not been confirmed yet
22:09:17 <x3m> dons: well what i recieve is like: ":anick!none@81-229-125-50-no50.tbcn.telia.com PRIVMSG #c++.se :hoop" so what i need to do before the case matching(or inside but before is probably better) is extract what comes after: "PRIVMSG #c++.se :" that is hoop
22:09:45 <dons> ?paste
22:09:46 <lambdabot> http://paste.lisp.org/new/haskell
22:10:14 <lisppaste2> dons pasted "factor out the matching code" at http://paste.lisp.org/display/26681
22:10:24 <dons> ^^ moves the pattern matching into its own function. should be easier to add more that way
22:10:26 <x3m> might wanna extract it if it comes after "PRIVMSG #whatever :" though
22:10:36 <hyrax42> @hoogle (a -> Bool) -> [a] -> [[a]]
22:10:37 <lambdabot> No matches, try a more general search
22:10:58 <x3m> yeah, i havent really done any pattern matching yet, but it should ofc be its own function
22:10:59 <hyrax42> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
22:11:00 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
22:11:22 <dons> x3m, its approaching being almsot parse worthy
22:11:24 <dfranke> is unsafePerformIO typesafe as long as its argument is monomorphic?
22:11:43 <dons> I _think_ so yes.
22:11:46 <x3m> heh
22:11:51 <dons> of course, type safe and runtime safe are two different things ;)
22:12:33 <dons> its the polymorphic reference issue that causes segfaults though. same as in ML
22:12:39 <dfranke> I need to make a top-level declaration of `foo = unsafePerformIO $ newQSem 1'.  I'm trying to figure out everything I need to do to make that not break.
22:12:58 <dons> {-# NOINLINE foo #-}
22:13:06 <dons> (don't want the compiler duplicating the value)
22:13:20 <dfranke> yeah, got that.  Is -fno-cse necessary?
22:13:21 <x3m> dons: an annoying thing is that you cant hardly write a message if you recives messages during that time(our fork that makes that i think)
22:13:35 <SyntaxNinja> dons: what wiki page?
22:13:38 <dons> oh, you're not using -threaded?
22:14:02 <x3m> hmm, whats that?
22:14:24 <dons> use the threaded runtime system (I'm guessing at what you are looking for..)
22:14:34 <SyntaxNinja> dons: have you uploaded packages to hackage?
22:14:36 <dons> you can certainly do async IO, and I think only -threaded is needed here
22:14:47 <x3m> it is threaded with the fork i guess, but since the command prompt read/writes on the lame line it messes up
22:14:47 <SyntaxNinja> dons: log into hackage.haskell.org, run "cabal-put foo-1.0.tar.gz" :)
22:14:50 <dons> SyntaxNinja: bizarrely, http://haskell.org/haskellwiki/Simple_unix_tools
22:14:54 <lambdabot> Title: Simple unix tools - HaskellWiki, http://tinyurl.com/hekpb
22:14:58 <dons> SyntaxNinja: ok, will do.
22:15:21 <x3m> where would i put -threaded?
22:15:22 <SyntaxNinja> that is a pretty sweet wiki page :)
22:15:30 <dons> x3m, when compiling
22:15:35 <SyntaxNinja> er, not necessarily accurate, but whateer
22:15:38 <x3m> aha
22:15:38 <dons> since you don't want all threads to block on io
22:15:48 <dons> SyntaxNinja: accurate ? :)
22:15:57 <x3m> or rather its blocking i want them to do
22:16:02 <x3m> i think
22:16:20 <x3m> or i can rephrase that
22:16:31 <x3m> when im typing a message i dont want to recieve one during that time
22:16:51 <SyntaxNinja> grep is somewhat less capable than the grep on my machine at least ;)
22:16:56 <dons> yes :)
22:17:09 <dons> should use the new regex-pcre lib
22:17:27 <dons> SyntaxNinja: my favourite is, io $ zipWith (printf "%3d %s") [(1::Int)..]
22:17:37 <dons> just think of all the magic happening there, for the outsider
22:18:49 <x3m> "ghc --make test5 -o -threaded test5" like that?
22:19:01 <dons> I'd add a -O too
22:19:03 <SyntaxNinja> yeah, it's pretty sweet :)
22:19:14 <x3m> whats that, optimize?
22:19:18 <dons> yep
22:19:28 <dons> x3m, you'll want it eventually, so may as well learn about it now.
22:19:35 <x3m> ooj so its case sensitivt
22:19:42 <x3m> what is -o doing then?
22:19:44 <SyntaxNinja> OK I'm off to bed. l8r al
22:19:49 <SyntaxNinja> er
22:19:49 <SyntaxNinja> all
22:19:56 <dons> -o says write the object to '-threaded' in this case....
22:20:08 <dons> ghc --make -o test5 -O test5.hs -threaded
22:20:26 <dons> will compile, with -O -threaded test5.hs into the binary 'test5'
22:21:34 <hyrax42> @hoogle (a -> b) -> b -> [a] -> [b]
22:21:35 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
22:21:35 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
22:21:56 <hyrax42> @type scanl1
22:21:57 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
22:25:20 <scsibug_> dons:  I'd like to suggest adding hs-plugins to the list of requirements for building lambdabot in the README... It took me a minute to figure out what the "plugins" dependency referred to
22:26:58 <x3m> would it be hard to add the eval from hs-plugins to this bot dons?
22:29:12 <dons> scsibug_: you don't need hs-plugins to build the bot though
22:29:24 <dons> only if you want the quickcheck and runplugs extra plugins
22:29:53 <dons> x3m, nope. you could just copy the 'Eval.hs' plugin from lambdabot
22:30:38 <dons> here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Eval.hs
22:30:40 <lambdabot> http://tinyurl.com/eweha
22:30:55 <dons> which uses http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs
22:30:56 <lambdabot> http://tinyurl.com/z7nbx
22:32:08 <scsibug> dons: my mistake then... I read the message as a fatal error, when I guess I could have gone ahead with the build, nevermind then
22:32:13 <x3m> now ive copied Eval.hs to the same dir as the bot we made
22:32:36 <dons> right. so you'll need to tweak it a bit, and install hs-plugins, and build the runplugs binary
22:32:55 <dons> (it uses Process.hs, also found in lambdabot's source
22:33:10 <x3m> ouch that was abit
22:33:22 <dons> yes.
22:33:34 <dons> you can probably do it on the cheap with just a call to ghci, but it won't be type safe
22:33:51 <dons> (the user would be able to run arbitrary IO code on your machine)
22:34:02 <x3m> btw i tried to run eval.hs though ghci, maybe it cant be run alone. Could not find module 'Data.ButeString.Char8'
22:34:24 <dons> let me see if I can whip this up for you.
22:34:36 <x3m> dons: it probably better be type safe
22:34:39 <x3m> ok cool
22:34:41 <dons> yes :)
22:38:54 <hyrax42> there are no instances of Eq defined for array types?
22:39:25 <hyrax42> hm there are
22:39:29 <dons> ?instances Eq
22:39:30 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
22:39:31 <hyrax42> why can't my newtype derive Eq then
22:39:37 <dons> ?instances-importing Data.Array Eq
22:39:39 <lambdabot> (), Array i e, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
22:39:53 <hyrax42> ?instances-importing Data.Array.Diff
22:39:53 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
22:40:09 <dons> buglet
22:40:14 <hyrax42> ?instances-importing Data.Array.Diff Eq
22:40:15 <lambdabot> (), Array i e, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
22:40:40 <hyrax42> what is the deal with deriving and newtypes
22:41:02 <hyrax42> I have newtype Bla = Blah (DiffArray ...)
22:41:22 <hyrax42> or maybe Eq is ot defined for DiffArray
22:41:23 <hyrax42> hm
22:44:03 <x3m> dons: are you writing an howto for the eval?
22:44:40 <dons> yes . just doing it now...
22:44:47 <x3m> okay
22:45:02 <x3m> how come you need hs.plugins for the eval to work?
22:45:26 <dons> it provides runtime evaluation and type checking for haskell
22:45:45 <dons> note that adding runtime eval to this thing is non-trivial
22:45:50 <x3m> oh, so that aint included in the eval.hs then
22:45:51 <dons> but once its done, its pretty neat :)
22:46:07 <x3m> ok cool :)
22:46:15 <x3m> yeah its a nice feature
22:51:58 <dons> !eval map (+1) [1..10]
22:52:24 <dons> bug in there . let me see....
22:52:45 <hyrax42> does a function such as the following
22:52:45 <hyrax42> arrayFromArray :: (IArray a e, IArray a' e, Ix i) => a i e -> a' i e
22:52:52 <hyrax42> exist in the libs?
22:54:54 <dons> ?hoogle a i e -> a' i e
22:54:55 <lambdabot> Did you mean: a i e -> A' i e
22:54:55 <lambdabot> Prelude.id :: a -> a
22:54:55 <lambdabot> Prelude.asTypeOf :: a -> a -> a
22:55:02 <dons> ?hoogle a i e -> b i e
22:55:03 <lambdabot> Prelude.id :: a -> a
22:55:04 <lambdabot> Prelude.asTypeOf :: a -> a -> a
22:55:04 <lambdabot> Prelude.const :: a -> b -> a
22:55:11 <dons> ?docs Data.Array
22:55:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
22:55:32 <vincenz> hey dons
22:55:47 <dons> hey
22:57:05 <hyrax42> ok I'm calling it a night
22:57:12 <x3m> @hoogle find
22:57:13 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
22:57:13 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
22:57:13 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
22:57:16 <hyrax42> see y'all later
22:57:35 <x3m> cya
22:58:45 <dons> !eval map (+1) [1..10]
22:58:58 <dons> argh close.
22:59:10 <dons> gotta send a priv msg back
23:00:35 <x3m> > find "hest" in "gronhest"
23:00:36 <lambdabot>  Parse error
23:00:59 <dons> > find "hest" "gronhest"
23:01:00 <lambdabot>  Couldn't match `a -> Bool' against `[Char]'
23:01:19 <dons> doesn't work like that anyway
23:01:26 <dons> check the type of find, find :: (a -> Bool) -> [a] -> Maybe a
23:01:26 <x3m> obviously
23:01:32 <dons> > find (=='x') "hskelxelxx"
23:01:33 <lambdabot>  Just 'x'
23:01:41 <dons> > findElem 'x' "hskelxelxx"
23:01:42 <lambdabot>  Not in scope: `findElem'
23:01:55 <dons> ?hoogle elem
23:01:56 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
23:01:56 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
23:01:56 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
23:02:09 <dons> > elemIndex 'x' "hskelxelxx"
23:02:11 <lambdabot>  Just 5
23:02:48 <ThreeQ> is there any tool for haskell like smalltalk's method finder?
23:02:57 <ThreeQ> where you give it the arguments, and it tells you the applicable functions?
23:03:00 <vincenz> dons: read the story piponi blogged?
23:03:05 <dons> ?hoogle a -> b -> a
23:03:06 <lambdabot> Prelude.const :: a -> b -> a
23:03:07 <lambdabot> Prelude.seq :: a -> b -> b
23:03:07 <lambdabot> Control.Parallel.par :: a -> b -> b
23:03:12 <ThreeQ> not types, values
23:03:29 <dons> can you give an example?
23:03:43 <dons> !eval map (+1) [1..10]
23:03:47 <donstesths>  [2,3,4,5,6,7,8,9,10,11]
23:03:51 <dons> aya!
23:03:55 <x3m> yaya!!
23:03:56 <ThreeQ> for example, in the method finder, you could give it:
23:03:59 <ThreeQ> 1. 2. 3
23:04:01 <ThreeQ> and it would say
23:04:03 <ThreeQ> #+
23:04:10 <dons> x3m, want to have a look at the source ... :)
23:04:17 <x3m> you bet :)
23:04:22 <vincenz> dons: what source?
23:04:31 <x3m> theee source
23:04:40 <dons> (note that i inlined a haskell parser and some lambdabot utils, also it expects the 'runplugs' binary from lambdabot to be in the current directory)
23:04:42 <vincenz> x3m: what source?
23:05:09 <x3m> some dons just wrote
23:05:26 <dons> here, http://www.cse.unsw.edu.au/~dons/tmp/Bot.hs
23:05:28 <ThreeQ> or #(1 2 3). 1
23:05:34 <ThreeQ> and it would give you "first"
23:05:46 <dons> oh, we could write such a thing
23:05:49 <dons> it's almost @pl
23:06:00 <dons> ?pl f (x:xs) = x
23:06:00 <lambdabot> f = head
23:06:05 <dons> yes?
23:06:08 <ThreeQ> oh, yes
23:06:35 <dons> x3m, so note that it's just the same code, except it extracts the string "!eval", and then calls lambdabot's eval plugin
23:06:39 <dons> (which i'ved inlined)
23:06:59 <ThreeQ> except being equal at just a single point
23:07:05 <ThreeQ> instead of equivalent in general
23:07:30 <dons> x3m, so you can imagine everything from 'popen' down should be in a separate library module
23:07:50 <ThreeQ> how does hoogle generate its database of functions?
23:08:02 <dons> it uses a tool to build them from haddock files
23:08:24 <ThreeQ> hmm
23:09:32 <x3m> dons: from "popen".. shouldnt all that you added -- And support for running haskell evaluation...
23:09:41 <x3m> below that be the separate module?
23:09:44 <dons> yes.
23:09:58 <dons> I thought i'd just stick it in a single module to make it easy to copy and get running
23:10:08 <x3m> yeah
23:10:09 <dons> in practice you use a umm. ..build system :)
23:10:38 <dons> if you look at the lambdabot source there's 3 modules, the haskell parser, the popen code, and the eval plugin
23:10:42 <x3m> im not that familiar with those. Visual Studio handles most of that implicit :)
23:11:02 <lispy> x3m: then you will like visual haskell
23:11:10 <x3m> {-# OPTIONS -fglasgow-exts -cpp #-} is this compilation flags?
23:11:18 <lispy> x3m: it's a visual studio plugin for using haskell
23:11:22 <lispy> x3m: yes
23:11:28 <lispy> ?where visualhaskell
23:11:28 <lambdabot> I know nothing about visualhaskell.
23:11:36 <x3m> lispy: yeah, i havent tried it yet, i will later
23:11:36 <lispy> ?google visual haskell
23:11:39 <lambdabot> http://www.haskell.org/visualhaskell/
23:11:39 <lambdabot> Title: Visual Haskell
23:11:52 * lispy uses it at work
23:12:05 <dons> yeah, since it uses the Lib.Haskell.Parser module (inlined) which uses some ghc extensions
23:12:07 <x3m> i really like VS, its awesome
23:12:11 <lispy> other than being forced to use a special ghc version it's nice
23:12:16 * JKnecht installed but hasn't used.
23:12:16 <sjanssen> wow, the code happy generates sure uses unsafeCoerce# a whole lot
23:12:39 <dons> that's with the -c flag (coerce). you can get pure h98 without all the magic extra flags
23:13:27 <dons> x3m, so you could stick everything from 'eval' down into an Eval.hs module, and the parser stuff at the end into 'Parser.hs'
23:13:39 <lispy> i'd rather have code automatically generated that goes unsafe things, than have to write it by hand and check that it's actually safe in whatever case i use it
23:14:02 <vincenz> buddhist thought of sunday: The purpose of a fish trap is to catch fish, and when the fish are caught, the trap is forgotten. The purpose of a rabbit snare is to catch rabbits. When the rabbits are caught, the snare is forgotten. The purpose of words is to convey ideas. When the ideas are grasped, the words are forgotten. Where can I find a man who has forgotten words? He is the one I would like to talk to. -Chuang
23:15:45 <dons> x3m, is that enough to get you started? I realise that's a huge chunk of code with lots of wacky stuff in it
23:16:08 <dons> maybe write your own little expression evaluator function, and call that from !eval ?
23:16:28 <sjanssen> 260 uses of unsafeCoerce# does approach wacky ;)
23:16:44 <dons> inlining a happy-generated module of some 5k loc is wacky too :)
23:16:56 <dons> ah well, nice that once it type checkd everything just worked eh?
23:17:03 * dons writes 8k loc in 5 mintues :)
23:17:28 <dons> typesystem++
23:17:48 <dons> and they say that static typing is bad for exploratory coding.. bah!
23:19:45 <dons> I should package up the eval function into a library
23:19:52 <lispy> yes!
23:19:59 <dons> (with the haskell src checking, and timeouts and so on)
23:20:07 <sjanssen> no!
23:20:11 <sjanssen> erm, yes!
23:20:13 <dons> -package safe-eval or something
23:20:14 <lispy> dons: in theory could your eval take more than one line?
23:20:22 <dons> yes.
23:20:24 <dons> of course.
23:20:40 <lispy> dons: what about top level definitions?
23:20:48 <dons> could be done.
23:21:02 <lispy> as long as we agree on a name for the top level?
23:21:06 <lispy> er entry point i mean
23:21:40 * lispy has been thinking about the interactive haskell tutorial
23:23:06 <dons> mmm. yes.
23:24:16 <dons> x3m: do you grok the code?
23:25:26 <x3m> im testing it first, then i gonna rewrite to a module also
23:25:44 <x3m> http://paste.lisp.org/display/26689 getting a parse error on input '<-'
23:26:27 <dons> you're missing a 'where' clause
23:26:29 <x3m> fixed the dO to do
23:26:41 <dons> and the definitions of 'tail' don't lie up
23:26:43 <dons> line up
23:28:07 <dons> http://paste.lisp.org/display/26689#1
23:28:40 <x3m> looks like this takes time to compile
23:28:54 <dons> it does. that parser at the end is highly optimised
23:29:04 <dons> ghc thinks really hard about how to pack it down
23:29:21 <dons> (hence its a good idea to stick it in a separate module, so you only have to compile it once)
23:29:27 <x3m> hs:8345:8: Warning: Pattern match(es) are overlapped In a case alternative: _ -> ...
23:29:32 <dons> that's ok.
23:29:42 <dons> there's always a default case in the parser generated code
23:30:00 <dons> do you have the 'runplugs' binary built?
23:30:06 <dons> from lambdabot?
23:30:37 <x3m> ./runInteractiveProcess: does not exist (No such file or directory)
23:30:44 <x3m> i have nothing built :)
23:30:53 <dons> you could built it by grabbing lambdabot, installing hs-plugins, and then typing:  ghc -O --make scripts/RunPlugs.hs -o runplugs
23:31:04 <dons> from the lambdabot directory
23:31:14 <dons> then copy the 'runplugs' program to your bot's directory
23:32:01 <dons> and if you get  that working you get some serious haskell hacker points... :)
23:32:35 <x3m> heh
23:32:40 <dons> oh, and you'll also need 3 other modules from lambdabot (teensy ones). ShowFun.* ShowQ.* and F.*
23:32:47 <dons> sorry, L.*
23:32:51 <x3m> yikes
23:32:58 <dons> look at the 'build' script in lambdabot to see how to build them
23:33:12 <dons> they're just small helps for runplugs
23:33:21 <x3m> first i gotta make one thing clear
23:33:22 <dons> (you could even remove them from RunPlugs.hs without problems)
23:33:37 <x3m> how do you load a module from the main file, just import modulename?
23:33:45 <dons> yep
23:33:52 <dons> "import Eval"
23:33:53 <dons> for example
23:33:56 <x3m> yeah
23:34:20 <dons> let me see if I can make a quick little runplugs source without the extra dependencies
23:34:23 <musasabi> scsibug: the old stable version of HAppS uses older fps. The new darcs version is probably released very soon. (in a few days)
23:34:32 <x3m> ah nice
23:35:21 <scsibug> musasabi: thanks, I tried with the latest version from darcs and made some progress.  I'll try again in a few days after the new release.
23:35:34 <scsibug> really looking forward to playing with it
23:35:40 <dons> x3m, here, now you don't need lambdabot, http://www.cse.unsw.edu.au/~dons/tmp/RunPlugs.hs
23:35:42 <lambdabot> http://tinyurl.com/zfekk
23:35:47 <dons> just grab that, and also install hs-plugins
23:35:59 <dons> then compile it with:
23:35:59 <dons> $ ghc -O --make RunPlugs.hs
23:36:09 <dons> $ ./a.out
23:36:09 <dons> map (+1) [1..10]
23:36:09 <dons> [2,3,4,5,6,7,8,9,10,11]
23:36:11 <dons> :)
23:36:23 <x3m> 1.0-rc0?
23:36:27 <dons> yep
23:36:51 <dons> we'll see how well this goes on windows...
23:36:57 <dons> (you still doing this on windows?)
23:37:26 <x3m> yeah
23:37:27 <dons> the main benefit of using runplugs is that you get timeouts and other safety checks, such as:
23:37:31 <dons> $ ./a.out
23:37:33 <dons> last [1..]
23:37:36 <dons> zsh: killed     ./a.out
23:37:46 <dons> $ ./a.out
23:37:46 <dons> writeFile "hack" "I hacked you good"
23:37:46 <dons> <irc>:2:18:
23:37:46 <dons>     No instance for (Show (IO ()))
23:37:47 <x3m> how do i install hs-plugins, i extract the zip file.. and?
23:38:11 <dons> unzip it yes, then chdir into hs-plugins/ and read the README
23:38:30 <musasabi> scsibug: did the darcs version cause problems for you?
23:38:46 <x3m> required Cabal?
23:38:52 <dons> comes with ghc 6.4 and later
23:38:54 <x3m> k
23:38:57 <dons> so you should already have it
23:39:04 * musasabi is currently in the find out some bugs and push 10-20 changes before release
23:39:27 <JKnecht> mode
23:39:39 <x3m> i hope i dont need cygwin for this
23:40:20 <lisppaste2> scsibug pasted "HAppS build" at http://paste.lisp.org/display/26690
23:40:25 <dons> x3m, no. should be ok with mingw
23:40:38 <dons> though I'm a bit suspicious of the RunPlug.hs timeout code
23:40:45 <dons> (it's only 3 lines, but I think its posix only)
23:40:51 <scsibug> musasabi: I just pasted the build I did from a darcs checkout, it had an error finding a module during the install
23:40:52 <dons> you might need to hack that a bit
23:41:05 <x3m> mingw.. i dont got that either
23:41:25 <dons> well, can you build the code or not ? :)
23:41:28 <dons> then we'll know.
23:41:37 <x3m> w8, reading :)
23:43:33 <musasabi> scsibug: that is old ByteString.
23:44:02 <vincenz> re
23:44:25 <x3m> (e.g., "c:/cygwin/usr/local") in the ./configure --prefix=foo/bar
23:44:34 <x3m> what is that path supposted to be
23:44:52 <dons> some path, yes. pick one :)
23:45:04 <x3m> where it will be installed to?
23:45:13 <dons> yeah.
23:45:18 <dons> just the library file
23:45:29 <x3m> putting it under ghc then
23:45:29 <dons> you can leave it off and cabal will pick some reasonable default
23:45:55 <musasabi> scsibug: you might want to use the ByteString version that ships with GHC 6.6 / is in the darcs repo.
23:46:27 <musasabi> scsibug: unfortunately the latest fps stable release (0.7) does not seem API compatible with 6.6.
23:46:41 <dons> yes, there's a small number of changes.
23:46:45 * musasabi made Cabal complain about that and pushed it into HApPS
23:46:49 <dons> i'll be tagging fps stable branch this week probably
23:47:01 <scsibug> musasabi: OK, I'm upgrading to the darcs version of fps... I just barely got 6.4.2 running on OS X, not sure I'm up for upgrading to 6.6 yet ;)
23:47:28 <dons> yeah, the darcs version is the same as the ghc 6.6 version
23:47:34 <scsibug> excellent
23:47:43 <musasabi> 6.4.2 with darcs fps is a supported configuration.
23:48:20 <musasabi> There are regular testers on Linux+6.5.20060902, NetBSD+6.4.2 and Windows+6.4.2.
23:48:30 <dons> musasabi: huh, cool.
23:48:35 <dons> how big is the tester base?
23:48:45 <dons> and the user base?
23:48:56 <x3m> Setup.lhs configure --prefix="C:Program Files/ghc/" like that?
23:49:13 <musasabi> dons: alex is more aware of those numbers, I try to concentrate on the technical side of things.
23:49:21 <dons> x3m, perhaps: runhaskell Setup.lhs configure --prefix="C:Program Files/ghc/"
23:49:31 <dons> musasabi: fair enough.
23:51:14 <x3m> "Setup.lhs configure --prefix="C:Program Files/ghc/"" this just loaded it into ghci
23:51:34 <dons> ok, perhaps type 'main' then
23:51:45 <dons> into ghci, to run the Setup.hs program
23:52:09 <dons> x3m, do you have the 'runhaskell' program on your system?
23:52:15 <x3m> no
23:52:21 <x3m> dont think so at least
23:52:25 <dons> x3m, alternatively, you can just compile Setup.lhs
23:52:26 <x3m> i just have the newest ghc
23:52:33 <dons> ghc --make Setup.lhs -o setup
23:52:42 <dons> then run: ./setup configure --prefix= ....
23:53:05 <newsham> hi
23:53:08 <goltrpoat> cool book (so far anyway), a draft is available online, case anyone cares:  http://www.google.com/search?hl=en&q=%22practical+foundations+for+programming+languages%22&btnG=Google+Search
23:53:10 <lambdabot> Title: "practical foundations for programming languages" - Google Search, http://tinyurl.com/pdp8g
23:54:44 <x3m> ok now i've compiled it
23:56:22 <x3m> from ghc-6.4.2\bin> setup configure --prefix="C:Program Files/ghc"
23:56:44 <dons> shouldn't you be in the hs-plugins directory?
23:56:58 <x3m> setup: No description file found, please create a cabal-formatted description file with the name <pkgname>.cabal
23:57:16 <dons> the 'setup' program needs to be in the same directory as the hs-plugins source
23:57:23 <x3m> alright
23:57:36 <dons> (i.e. the same directory as the .cabal file)
23:58:25 <x3m> grr
23:58:39 <x3m> setup: Cannot find compiler for ghc
23:58:54 <x3m> now im in bin\dhs\hs-plugins>
23:58:55 <dons> it's not in your path?
23:59:07 <x3m> ghc lies in bin\
23:59:42 <x3m> in my path?
23:59:50 <newsham> set path=%path%;c:\ghc\ghc-6.4.2\bin
