00:01:02 <mnislaih> heh good tip, too late. Next time I'll be a tomb
00:01:11 <dons> :)
00:13:39 <kzm> Is it "impossible" to get an exception on arithmetic overflow?
00:14:08 <kzm> (For e.g. Int, that is.  The current wraparound behavior isn't always, shall we say, ideal)
00:14:42 <Korollary> I dont think the report specifies a way.
00:15:01 <dons> use Integer ;) but maybe there's some operations that will toss an exception, ghc primop that is. the problem would be that exceptions in their general form are newer than h98
00:15:11 <Korollary> I don't know how to do that in C, either.
00:15:40 <dons> e.g.
00:15:40 <dons> primop   IntAddCOp   "addIntC#"    GenPrimOp   Int# -> Int# -> (# Int#, Int# #)
00:15:41 <dons>      {Add with carry.  First member of result is (wrapped) sum;
00:15:41 <dons>           second member is 0 iff no overflow occured.}
00:16:01 <dons> primop   IntMulMayOfloOp  "mulIntMayOflo#"
00:16:01 <dons>    Dyadic   Int# -> Int# -> Int#
00:16:01 <dons>    {Return non-zero if there is any possibility that the upper word of a
00:16:01 <dons>     signed integer multiply might contain useful information.
00:16:09 <dons>   Return
00:16:09 <dons>     zero only if you are completely sure that no overflow can occur.
00:16:42 <dons> kzm, so for particular operations, using GHC primops, you could at least check
00:16:50 <dons> i.e. + - * on Int
00:18:14 <Heffalump> the basic problem is that Int is intended to be implemented with the machine type, and most machines don't trap integer overflow
00:18:16 <wilx> Isn't overflow on int undefined?
00:18:18 <wilx> At least in C?
00:18:27 <Heffalump> it's undefined on signed ints
00:18:30 <kzm> What's the performance of that?
00:18:37 <Heffalump> its defined to wrap on unsigned ints IIRC
00:18:40 <dons> > (maxBound :: Int) + 1
00:18:41 <lambdabot>  -2147483648
00:18:45 <wilx> Yeah, exactly.
00:18:58 <dons> > (maxBound :: Word64) + 1
00:19:00 <lambdabot>  0
00:19:17 <dons> kzm, you can't use Integer?
00:19:40 <wilx> So, if GCC generates C code that uses int overflow it basically generates broken code.
00:19:54 <kzm> dons, sure.  Int is faster, though.  It'd be nice to have the application crash, instead of happily producing wrong results.
00:19:59 <wilx> Recently GCC has been getting very smart about using the fact in optimization.
00:21:09 <dons> kzm, yeah, it can help to strictify your Integer s though. If it was important , I'd not hesitate to choose correct-and-Integer over Int though.
00:21:15 <Heffalump> wilx: DYM if GHC generaets such code?
00:21:19 <Heffalump> s/generaets/generates/
00:21:51 <wilx> DYM?
00:21:55 <wilx> @wtf DYM
00:21:56 <lambdabot> Maybe you meant: bf ft wn
00:22:07 <Heffalump> "do you mean"
00:22:16 <wilx> Ah, yeah, if it does it is broken :)
00:22:21 <Heffalump> (you said GCC)
00:22:25 <kzm> dons - currently I have both Int and Integer code.  Checking consistency between them sounds like QC-fodder.
00:22:32 <wilx> Oh, right.
00:22:42 <Heffalump> but they won't be consistent if the inputs can cause overflow
00:22:45 <wilx> Yeah, I meant GHC.
00:22:53 <Heffalump> they'll be consistent mod 2^32
00:23:23 <kzm> Heffalump, exactly.  So if the results are inconsistent, I have a bug, possibly overflow.
00:24:14 <Klaus83> Hei, what problem here ?? iterate (3*n+1) n
00:24:25 <Heffalump> so it's a bug for your code to overflow on any input?
00:24:28 <kzm> So while overflow isn't trapped by the running program, I can at least test (automatically) for it.
00:24:37 <Heffalump> even if the input values are very large Ints?
00:24:56 <dfranke> Does this look ok? http://paste.lisp.org/display/26351
00:24:59 <mnislaih> Klaus83: iterate (\x->3*x+1) n
00:25:53 <kzm> Heffalump, yes, more or less.  (Input is a text file, Int(egers) represent subwords from the text)
00:26:17 <Klaus83> mnislaih, but here ? iterate (n`div`2) n
00:27:02 <dons> ?type iterate
00:27:03 <lambdabot> forall a. (a -> a) -> a -> [a]
00:27:04 <mnislaih> Klaus83: the first arg. to iterate is a function
00:27:26 <dons> Klaus83: so there's some programming assignment to compute log2 in haskell going on?
00:27:53 <Klaus83> erm ?
00:28:01 <dons> seems like we've had this (n `div` 2) question asked 3 times in the last 24 hours :)
00:28:09 <dons> I was wondering if it was in a tutorial or something?
00:28:28 <norpan> dons: you go get 'em!
00:29:06 <dons> maybe its just a conincidence, not sure.
00:29:55 <dons> both aes2 and deadbeef were trying to write log2 using iterate yesterday :)
00:30:38 <dons> > iterate (\n -> n `div` 2) 100
00:30:39 <lambdabot>  [100,50,25,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
00:30:48 <dons> ?pl iterate (\n -> n `div` 2) 100
00:30:49 <lambdabot> iterate (`div` 2) 100
00:30:50 <norpan> length . takeWhile (>0) . iterate (`div` 2)
00:30:59 <norpan> or something?
00:31:27 <dons> > findIndex (<= 0) . iterate (`div` 2) $ 100
00:31:28 <lambdabot>  Just 7
00:31:42 <dons> > length . takeWhile (>0) . iterate (`div` 2) $ 100
00:31:43 <lambdabot>  7
00:31:57 <dons> > logBase 2 100
00:31:59 <lambdabot>  6.643856189774725
00:32:05 <dons> > ceiling $ logBase 2 100
00:32:06 <norpan> close enough :)
00:32:07 <lambdabot>  7
00:32:17 <dons> good enough for government work
00:32:43 <norpan> > length . takeWhile (>0) . iterate (`div` 2) $ 128
00:32:45 <lambdabot>  8
00:32:56 <norpan> ungood
00:33:37 <norpan> > (1-) . length . takeWhile (>0) . iterate (`div` 2) $ 128
00:33:38 <lambdabot>  -7
00:33:45 <norpan> > (- 1) . length . takeWhile (>0) . iterate (`div` 2) $ 128
00:33:47 <lambdabot>  add an instance declaration for (Num (Int -> c))
00:33:49 <norpan> bah
00:34:03 <dons> subtract.
00:34:09 <norpan> i knooooow
00:34:33 <dons> well write it then. ;)
00:34:44 <norpan> > subtract 1 . length . takeWhile (>0) . iterate (`div` 2) $ 128
00:34:45 <lambdabot>  7
00:35:02 <norpan> > subtract 1 . length . takeWhile (>0) . iterate (`div` 2) $ 64
00:35:03 <lambdabot>  6
00:35:06 <norpan> > subtract 1 . length . takeWhile (>0) . iterate (`div` 2) $ 65
00:35:08 <lambdabot>  6
00:35:11 <norpan> > subtract 1 . length . takeWhile (>0) . iterate (`div` 2) $ 63
00:35:12 <lambdabot>  5
00:35:14 <norpan> good
00:35:30 <norpan> time to work
00:36:46 <Klaus83> erm
00:36:48 <Klaus83> takeWhile (>0) . iterate (`div`2) 70
00:37:02 <dons> > takeWhile (>0) . iterate (`div`2) $ 70
00:37:03 <lambdabot>  [70,35,17,8,4,2,1]
00:37:10 <dons> > takeWhile (>0) . iterate (/2) $ 70
00:37:12 <lambdabot>  [70.0,35.0,17.5,8.75,4.375,2.1875,1.09375,0.546875,0.2734375,0.13671875,6.83...
00:37:14 <Klaus83> What this $ makes ?
00:37:22 <dons> instead of parenthesis:
00:37:31 <dons> > takeWhile (>0) (iterate (/2) 70)
00:37:32 <lambdabot>  [70.0,35.0,17.5,8.75,4.375,2.1875,1.09375,0.546875,0.2734375,0.13671875,6.83...
00:48:08 <Klaus83> Hmm ? takeWhile (n`mod`2 == 0) (iterate (`div`2) $ n)
00:59:12 <dons> ?remember MikeChampion With the help of our friendly local ex-professors and Haskell geeks Dr. Meijer and Dr. LÃ¤mmel, I have learned to stop worrying and love monad comprehensions
00:59:28 <ValarQ> @quote
00:59:29 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
01:01:51 <hellish> @pointless truncatePair (char,frac) = (char,(truncate frac))
01:01:51 <lambdabot> truncatePair = second truncate
01:03:31 <dons> mmm Control.Arrow
01:03:38 <dons> ?hoogle second
01:03:39 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
01:03:56 <hellish> Tuples are Arrows?
01:04:11 <dons> Arrows are layered over tuples
01:04:21 <dons> and provide some nice tuple hacking mgaic
01:04:31 <hellish> Hmm...
01:04:59 <dons> > second toUpper $ ('x','y')
01:05:01 <lambdabot>  ('x','Y')
01:05:11 <dons> > first toUpper $ ('x','y')
01:05:12 <lambdabot>  ('X','y')
01:05:44 <Klaus83> How can i recursively do the same 'lisamine' ? http://paste.lisp.org/display/26352
01:05:54 <wolverian> that works well infix.
01:09:42 <dons> Klaus83: http://paste.lisp.org/display/26352#1
01:09:54 <dons> not recursive though. you'll have to figure it out a bit more first
01:11:56 <nomeata> dons: ping
01:12:04 <dons> yes
01:13:07 <nomeata> I just read your blog entry about a wiki
01:13:21 <nomeata> I happend to have just yesterday started to program a wiki that is based on SVN
01:13:36 <nomeata> And uses a haskell program to process the wiki page to produce the output
01:14:04 <nomeata> It is meant to be used as a LaTeX wiki (allowing full latex documents to be edited in a wiki manner9
01:14:33 <nomeata> but of course it supports regular wiki pages, and more formats should easily be additable
01:14:41 <nomeata> (is additable a word :-))
01:14:56 <nomeata> Also, it should probably not be too hard to switch to darcs instead of svn.
01:15:42 <nomeata> I was planning to hack a bit more before I show it around, but if you are interested I can open the websvn view.
01:16:34 <dons> mmm!
01:16:56 <dons> well, with a good generic backend, it would be possible to export via darcs, svn, ...
01:17:08 <dons> (as pugs and some other projects do already)
01:17:10 <nomeata> I am currently using about the same system using a hacked up kwiki, see lkwiki.nomeata.de
01:18:08 <nomeata> My plan for this one (dubbed latexki) is this: Static pagees are created using a haskell program that just checks out the tree and processes any updated files in a Make-like manner
01:18:39 <nomeata> And editing is done by a relatively simple CGI script. I was planning on using python for that, because of the svn bindings, to access the repository directly.
01:18:57 <nomeata> The processing is started by a post-commit hook in SVN.
01:22:01 <dons> cool, so you imagine being able to use version control to access the wiki, as well as via the web?
01:22:24 <nomeata> that's what I do currently, even
01:22:35 <dons> nice.
01:22:44 <nomeata> The involved members edit their latex files in SVN, bypassers can fix stuff in the wiki
01:22:56 <nomeata> I just want to rewrite the thing and put it on a more solid base
01:24:23 <nomeata> The setup is similar to ikiwiki, actually, just that I didn't like the way they handle web edits. (They work on a checked out copy they commit, and I plan on directly acessing the repository from the CGI script)
01:24:32 * mux waves hello
01:24:56 * nomeata waves a sine curve
01:25:16 <dons> is that safe? I'd think checking out and commiting would be more fault tolerant?
01:26:29 <nomeata> Well, that the bindings are for, I thought. I'd expect easier handling of conflicts, and no temporary files laying around anywhere.
01:26:54 <nomeata> I think it would still technically be a checkout and a commit, but not on the disk but in one program run.
01:27:04 <nomeata> Also, no extra processes would have to be spawned.
01:27:04 <dons> ah I see.
01:27:21 <nomeata> But that's theory, I'm working on the wiki processor part right now :-)
01:27:22 <dons> yep, good
01:28:04 <nomeata> If you happen to read planet debian, you'll read if I ever get it to a useable state :-)
01:28:49 <nomeata> Or I even might drop a note to haskell-cafe, as it contains a relevant part written in haskell.
01:29:20 <dons> yeah, they'd be interested, I think
01:30:15 <nomeata> great! cu later then.
01:30:26 * mux reads the new entry dons wrote on w3m and vim
01:30:47 <mux> I'm a user of these piece of software too :-) do you use w3mman?
01:32:31 * mux pokes dons 
01:32:50 <dons> not w3mman, what's that?
01:33:13 <mux> comes with w3m, it's cool - it's a pager for reading man pages and let you use hypertext links in those
01:33:23 <mux> like in the SEE ALSO sections
01:33:33 <dons> mux++
01:33:34 <dons> nice!
01:33:37 <mux> ;-)
01:33:42 <dons> I have a new toy to play with :)
01:42:49 <Klaus83> how can i do random choise     1 or 0 ?
01:42:51 <bourbaki> moin
01:47:51 <Klaus83> anyone ?
01:50:36 <Syzygy-> @type random
01:50:37 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
01:53:33 <Syzygy-> > let x <- getStdRandom $ randomR (0,1)
01:53:33 <lambdabot>  Parse error
01:53:55 <Syzygy-> > let r' <- newStdGen(b,r); (b,r) = randomR (0,1) r'
01:53:55 <lambdabot>  Parse error
01:54:39 <Syzygy-> @type getStdRandom
01:54:41 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
01:55:10 <Syzygy-> > let x <- getStdRandom $ randomR (0,1) in x
01:55:10 <lambdabot>  Parse error
01:55:42 <Syzygy-> > let x <- choose (0,1) in x
01:55:42 <lambdabot>  Parse error
01:56:04 <Syzygy-> > [x | x <- choose(0,1) ]
01:56:05 <lambdabot>  Not in scope: `choose'
01:56:22 <Syzygy-> > [x | x <- getStdRandom $ randomR (0,1) ]
01:56:23 <lambdabot>  Couldn't match `IO a' against `[a1]'
01:56:32 <Syzygy-> > head [x | x <- getStdRandom $ randomR (0,1) ]
01:56:32 <lambdabot>  Couldn't match `IO a' against `[a1]'
01:58:41 <Klaus83> getStdRandom (randomR (x,y)) ?
01:59:12 <Klaus83> Syzygy
01:59:13 <mux> ?version
01:59:14 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
01:59:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:02:15 <Syzygy-> Klaus83: Still trying to figure out the precise syntax...
02:02:30 <Syzygy-> @type (getStdRandom (randomR (0,1)))
02:02:31 <lambdabot> forall a. (Random a, Num a) => IO a
02:02:54 <Syzygy-> This should, I guess, indicate that if we read from getStdRandom randomR (0,1), we'd get a random 0 or 1 out of it.
02:10:23 <Syzygy-> What does it indicate if lambdabot shouts Pervert! at me?
02:15:57 <dcoutts__> that you're doing something disgusting
02:15:58 <dcoutts__> > readFile "/etc/passwd"
02:15:59 <lambdabot>  Pervert!
02:16:01 <dcoutts__> see
02:16:23 <dcoutts__> something disgusting and imperitive
02:16:28 <dcoutts__> (ie using IO)
02:17:31 <Syzygy-> Ah.
02:17:44 <Syzygy-> dcoutts__: How DO you get hold of a single random number?
02:17:53 <Syzygy-> I always end up stuck inside the IO monad...
02:18:23 <dcoutts__> you have to start from the IO monad to get a genuine random number
02:18:31 <dcoutts__> from there everything else can be pure
02:18:50 <Syzygy-> dcoutts__: So, suppose I want lambdabot to answer with a random number; is there a oneliner I can do?
02:18:52 <dcoutts__> so in particular you can test it using a constant seed
02:19:01 <dcoutts__> no
02:21:09 * roconnor doesn't like tla
02:21:12 <Syzygy-> dcoutts__: And if I want to get my ghci to give me a random number?
02:21:32 <dcoutts__> @hoogle getstdgen
02:21:33 <lambdabot> Random.getStdGen :: IO StdGen
02:21:34 <Syzygy-> @hoogle IO a -> a
02:21:35 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
02:21:35 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
02:21:35 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
02:21:47 <dcoutts__> Syzygy-: no not that way!
02:21:57 <Syzygy-> ok...
02:22:00 <dcoutts__> @hoogle StdGen
02:22:01 <lambdabot> System.Random.StdGen :: data StdGen
02:22:01 <lambdabot> Random.getStdGen :: IO StdGen
02:22:01 <lambdabot> Random.mkStdGen :: Int -> StdGen
02:22:15 <dcoutts__> @docs Random
02:22:16 <lambdabot> Random not available
02:22:23 <dcoutts__> hmm
02:22:27 <Syzygy-> Ah!
02:22:29 <bartw> > t: Quasi
02:22:29 <lambdabot>  Not in scope: data constructor `Quasi'
02:22:32 <Syzygy-> This one worked.
02:22:38 <bartw> > :t Quasi
02:22:38 <lambdabot>  Parse error
02:22:41 <Syzygy-> > randomR (0,1) $ mkStdGen 3
02:22:42 <lambdabot>  (1,160056 40692)
02:22:45 <Syzygy-> > randomR (0,1) $ mkStdGen 15
02:22:46 <lambdabot>  (1,640224 40692)
02:23:02 <Syzygy-> > randomR (0,1) $ mkStdGen 64022440692
02:23:03 <lambdabot>  (0,1579552053 40692)
02:23:04 <roconnor> @type randomR
02:23:06 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
02:23:14 <bartw> @type Quasi
02:23:15 <lambdabot> Not in scope: data constructor `Quasi'
02:23:25 <Syzygy-> And the one asking the question to begin with is gone.
02:23:48 <dcoutts__> Syzygy-: yes, that's making a standard PRNG from a seed. getStdGen does the same bug gets the seed from an external source of genuine random numbers
02:23:48 <Syzygy-> > fst $ randomR (0,1) $ mkStdGen 64022440692
02:23:49 <lambdabot>  0
02:23:58 <dcoutts__> bug/but
02:24:06 <roconnor> > randomR (0,1) =<< getStdGen
02:24:07 <lambdabot>  Couldn't match `(,) a' against `IO'
02:24:08 <Syzygy-> dcoutts__: And this external source is what puts it all inside IO?
02:24:21 <dcoutts__> yep
02:24:24 <roconnor> > (randomR (0,1)) =<< getStdGen
02:24:25 <lambdabot>  Couldn't match `(,) a' against `IO'
02:24:54 <Syzygy-> So, suppose I want to print it - is there some way to take my random IO Int and dump it out on the screen?
02:24:58 <dcoutts__> as I said, it can all be done purely except getting an initial ganrom seed
02:25:17 <dcoutts__> Syzygy-: use print
02:25:26 <Syzygy-> Something along the lines of do x <- randomR (0,1) $ getStdGen; print x ?
02:26:05 <dcoutts__> do { gen <- getStdGen; let x = randomR (0,1); print x }
02:26:07 <Syzygy-> That won't work. Gives the same error roconnor was getting a few lines up.
02:26:17 <dcoutts__> the randomR bit is pure
02:26:30 <dcoutts__> so uses let, not <-
02:26:31 <roconnor> ah
02:26:45 <dcoutts__> > return . (randomR (0,1)) =<< getStdGen
02:26:46 <lambdabot>  Pervert!
02:26:52 <dcoutts__> roconnor: like so
02:27:05 <Syzygy-> Ah.
02:28:03 <roconnor> print =<< fmap (fst . randomR (0,1)) getStdGen
02:28:13 <roconnor> anyhow, that's awful
02:29:04 <dcoutts__> print . fst . randomR (0,1) =<< getStdGen
02:29:05 <roconnor>  print =<< randomRIO (0,1)
02:29:33 <roconnor> do {r <- randomRIO (0,1); print r}
02:29:41 <roconnor> that's a bit more clear
02:29:56 <Syzygy-> Bwahahaha! This works!
02:30:12 <Syzygy-> let flipCoin = getStdRandom $ randomR (0,1) in print =<< flipCoin
02:31:39 <roconnor> Syzygy-: that's pretty good
02:32:23 <mux> dons: ping?
02:32:41 <dcoutts__> Syzygy-: don't try repeating that a lot, you'll get the same result I think
02:32:46 <dcoutts__> hence you should get the StdGen once and then use the Random class function
02:33:11 <Syzygy-> dcoutts__: Repeating print <<= flipCoin, however, does get me sane results.
02:33:21 <dcoutts__> that's what I said
02:33:29 <Syzygy-> Ah, right.
02:33:35 <dcoutts__> oh sorry, sane
02:33:48 <dcoutts__> I don't think it's guaranteed to do so
02:33:57 <Syzygy-> let flipCoin = getStdRandom $ randomR (0,1) in do print =<< flipCoin; print =<< flipCoin; print =<< flipCoin  (something like this)
02:34:16 <dcoutts__> so generally your program should getStGen once and then do it purely
02:34:32 <Syzygy-> Yah.
02:34:36 <dcoutts__> that also means your prog doesn't get infected with IO everywhere
02:35:28 <roconnor> Isn't there a random monad kicking around somewhere?
02:35:43 <Syzygy-> roconnor: Oh yes, that's what we're kinda using all the time methinks...
02:35:44 <roconnor> @old-wiki RandomMonad
02:35:45 <lambdabot> http://www.haskell.org/hawiki/RandomMonad
02:36:24 <roconnor> @wiki MonadRandom
02:36:24 <lambdabot> http://www.haskell.org/haskellwiki/MonadRandom
02:36:32 <Syzygy-> Or ... maybe it isn't...
02:36:48 <Syzygy-> @type getRandom
02:36:50 <lambdabot> Not in scope: `getRandom'
02:36:50 <roconnor> bah
02:36:52 <roconnor> http://haskell.org/haskellwiki/NewMonads/MonadRandom
02:36:55 <lambdabot> Title: NewMonads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
02:37:24 <roconnor> Hmm, that page isn't clear at all
02:37:31 <Syzygy-> Very much not so.
02:39:38 <roconnor> Well, if you load that module, you can use (Rand StdGen) as a monad I believe.
02:40:09 <roconnor> the (Rand StdGen) monad gives you getRandom and getRandomR primatives
02:41:55 <roconnor> then, on the outer level you can do {g<-getStdGen; print (evalRand (your_monad_command_here) g)}
02:46:32 <roconnor> there should be an evalRandIO command on that page
02:46:34 <roconnor> I'll add one
02:46:42 <Syzygy-> > take 7 $ cycle [3]
02:46:43 <lambdabot>  [3,3,3,3,3,3,3]
02:46:47 <Syzygy-> > take 7 $ cycle [3,4]
02:46:48 <lambdabot>  [3,4,3,4,3,4,3]
02:46:50 <Syzygy-> > take 7 $ cycle [3,4,5]
02:46:51 <lambdabot>  [3,4,5,3,4,5,3]
02:46:54 <Syzygy-> > take 7 $ cycle [3,4,5,6]
02:46:55 <lambdabot>  [3,4,5,6,3,4,5]
02:46:57 <Syzygy-> Ah.
02:53:42 <dons> glguy: patch seems to work on 3.8 :)
02:53:49 <dons> i'll double check and push it in the morning
02:54:17 <bourbaki> hidiho dons
02:57:33 <roconnor> better
02:58:13 <roconnor> now you can do print =<< (evalRandIO $ do {getRandomR (0,1)})
03:00:07 <roconnor> basically you do all your work in the Random monad, using getRandom and getRandomR.
03:00:24 <roconnor> then at the very end you use evalRandIO to convert the random monad into the IO monad.
03:03:10 <araujo> morning!
03:04:25 <araujo> icfp contest results posted?
03:05:27 <ValarQ> the icfp site seems to have been down for quite some time now
03:05:39 <araujo> icfpcontest.org?
03:06:09 <ValarQ> icfp06.cs.uchicago.edu
03:07:09 <araujo> ye, seems down
03:08:52 <araujo> off to univ!
03:13:49 <dons> results seem to be up, http://icfpcontest.org/scoreboard.shtml
03:13:50 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
03:14:56 <dcoutts__> 12th for my team
03:14:56 <dcoutts__> damn, beaten by the Caml riders
03:15:41 <dons> well done, we came in 33rd.
03:15:45 <dons> oh just behind the dylan hackers
03:16:28 <gds> Is haskell still "The language of choice"...?
03:16:38 <dcoutts__> not this year
03:16:44 * gds looks for info on these "Smartass" people...
03:16:56 <dons> a rumours has it that they work at google
03:17:38 <bourbaki> the dylan hackers?
03:18:23 <dons> some weird guys who've one it a few years back, iirc, and got the judges prize last year
03:18:28 <dons> s/won/
03:18:38 <dons> -> dinner time!
03:21:03 <nomeata> Shoudn't the topic be changed then?
03:22:37 <russo> the topic is quite funny though :D
03:22:45 <russo> you guys have a good nerdy sense of humor :)
03:23:36 <SamB> as do all good nerds.
03:23:52 <SamB> of course, some will refer to it as a bad sense of humour,
03:23:54 <SamB> I'm sure...
03:26:54 <russo> i dunno it really made me chuckle after i hit /topic :D
03:27:04 <russo> though i'm a nerd too
03:27:55 <russo> lol i just got a crumpler case for my notebook
03:28:04 <russo> have you guys seen how rediculous the site is?
03:28:10 <russo> www.crumpereurope.com
03:28:23 <SamB> though I guess *anyone* would laugh about "the Age of the Lambda", if they knew what one was...
03:28:55 <nomeata> russo: I'm talking about "discriminating..", it seems that is actually the name of an award, and haskell did not make it this year.
03:28:56 <SamB> so basically they'd need to either be a mathemetician, or a computer geek of some kind (perhaps a computer scientist)
03:29:25 <SamB> tis the prize for the ICFP competition
03:30:37 <SamB> @topic-init
03:30:38 <lambdabot> I do not know the channel
03:30:42 <SamB> @topic-init #haskell
03:32:19 <roconnor> @type runIdentity
03:32:21 <lambdabot> Not in scope: `runIdentity'
03:32:26 <roconnor> @hoogle runIdentity
03:32:28 <lambdabot> Control.Monad.Identity.runIdentity :: Identity a -> a
03:40:25 <roconnor> @pl getStdRandom (\g -> runIdentity ((runStateT . unRT . unRand $ x) g))
03:40:26 <lambdabot> getStdRandom (runIdentity . runStateT (unRT (unRand x)))
03:47:01 <roconnor> weee, runIdentity, runStateT, unRT, and unRand are all constructors for newtype
03:47:19 <roconnor> so those functions are all no-ops
03:47:22 <SamB> hmm?
03:47:29 <SamB> you mean unconstructors!
03:47:36 <xerox> ?yow!
03:47:37 <lambdabot> Adopt my lifestyle or I'll have to press charges.
03:47:38 <roconnor> yes, unconstructors.
03:47:57 <roconnor> oh wait, that means they are identity functions?
03:48:10 <SamB> at runtime yes
03:48:15 <xerox> In the case of newtype yes.
03:48:20 <roconnor> hopefully the optimizer will is smart enought to optimise id away.
03:48:30 <xerox> That's the whole point of newtype :)
03:48:33 <SamB> at compile time, they do alter the types ;-)
03:48:55 <roconnor> getStdRandom (id . id (id (id x)))
03:49:44 <SamB> but yes, seeing as they do nothing besides that, they should be inlined out if you compile with -O
03:50:57 <SamB> dunno what happens if you map with them...
03:52:27 <xerox> Maybe that's part of the `better newtype' change in 6.6-Changes.
03:53:48 <bartw> :( only #92 on icfp contest
03:54:15 <roconnor> bartw: how many team members?
03:55:02 <bartw> just me
03:55:21 <roconnor> seems pretty good to me
03:55:31 <roconnor> we had like 6 or so people on our team.
03:55:46 <bartw> which one are you ?
03:56:13 <roconnor> I was on Team Roflcopter.
03:56:43 <bartw> nice 34
04:00:19 <musasabi> What was the correct way to throw an Exception inside STM?
04:00:30 <SamB> I didn't get my UM working before the contest ended
04:00:38 <musasabi> @index Exception -> STM a
04:00:39 <SamB> but then, I wasn't seriously trying to compete
04:00:39 <lambdabot> bzzt
04:00:48 <SamB> @hoogle Exception -> STM a
04:00:49 <lambdabot> No matches, try a more general search
04:01:11 <SamB> @hoogle Exception -> a
04:01:12 <lambdabot> Control.Exception.throw :: Exception -> a
04:01:21 <SamB> musasabi: how's that look?
04:01:43 <musasabi> yes..
04:01:53 * musasabi goes to fetch some caffeine
04:02:20 <musasabi> (to not make silly questions with obvious answers)
04:04:22 <dons> roconnor: looks like we sneaked in about 20 points ahead of your team :) close!
04:04:58 * dons thinks haskell -- for a 1-percenter language -- seems to be rather common in the top end of the icfp results
04:05:17 <dcoutts__> do we know which langages teams used?
04:05:20 <roconnor> what is a 1-percenter language?
04:05:30 <SamB> that is because it is a very very smart 1%
04:05:55 <SamB> roconnor: I think it means "relatively unpopular"
04:06:14 <roconnor> I suspect the ICFP attracts a lot of functional programmers, even if it isn't restricted to functional programming languages.
04:06:19 <dons> roconnor: oh, just speculating, based on a recent language poll by OReilly which had Haskell, OCaml and Erlang used in around 1% of projects
04:06:22 <vegai> did this year's ICFP winner team use Java?
04:06:34 <dons> roconnor: yep
04:06:37 <SamB> wow!
04:06:55 <SamB> hats off to them, if they managed to do all that in Java!
04:06:58 <SamB> well, hats off anyway
04:07:07 <SamB> not that I have a hat to take off
04:07:11 <dmwit> vegai: I think the winners wrote in 2D
04:07:21 <dons> I don't think they really did, dmwit ;)
04:07:24 <SamB> dmwit: what!
04:07:29 <dmwit> Oh...
04:07:32 <roconnor> we could change the topic to: Java - The language of choice for discriminating hackers
04:07:41 <SamB> 2D is crazy!
04:07:48 <dons> 2-d being this language: http://www.cse.unsw.edu.au/~dons/code/icfp06/puzzles/CIRCS/raytrace_complete.2d
04:07:50 <lambdabot> http://tinyurl.com/jxc7h
04:07:51 <SamB> I still haven't finished the raytracer
04:08:01 <dmwit> Rats, I was really hoping the ridiculous language could have won. =)
04:08:08 <roconnor> is 2D crazier than OCult?
04:08:09 <dons> if they did it in 2d, well HATS OFF!!
04:08:16 <SamB> roconnor: ... maybe
04:08:19 <dons> roconnor: hmm. maybe yes.
04:08:42 <SamB> I know it is harder to pretty-print ;-)
04:09:12 <xerox> Is malcom's video onlinr?
04:09:14 <xerox> *e
04:09:18 <SamB> I think it is more predictable though.
04:09:38 <vegai> "Can't Spell Awesome without ASM" came in third?
04:09:54 <dons> I doubt they wrote in asm though .... there's a lot of jokes around :)_
04:10:10 <dmwit> I HATE JOKES
04:10:14 <dmwit> ;-)
04:10:33 <roconnor> @yarr
04:10:34 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
04:10:45 <vegai> The team names are much cooler this year, it seems
04:11:35 <mux> dons: here?
04:22:33 <fasta> What do you think of GHC adding postfix operators to GHC Haskell?
04:32:45 <bartw> first year i don't use java as main language for icfp and java wins it....
04:33:56 <fasta> bartw: where are the results?
04:34:05 <bartw> http://icfpcontest.org/scoreboard.shtml
04:34:09 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
04:34:52 <fasta> bartw: Where is the correspondence team<->language?
04:35:10 <bartw> they haven't updated the site with that yet it seems
04:35:48 <fasta> bartw: I heard it was Java too, but hearing is not the same as knowing.
04:36:41 <bartw> i don't "know" it either
04:37:24 <bourbaki> can anyone please tell me what the task for the contest was? i dont understand what they try to tell me there
04:38:00 <bartw> the first challenge is to build an interpreter/vm
04:38:19 <bartw> the vm runs a provided unix like os
04:38:26 <bartw> which contains problems and games
04:39:24 <bourbaki> are we talking about the stone tablet thingy
04:40:41 <bartw> the stone tablet thingy was a selfcompressing vm image
04:40:53 <bartw> de-
04:41:40 <bourbaki> and why didnt they just say what they wanted? :)
04:42:02 <AstralStorm> That's the funny thing about those contests: you have to read mind :P
04:42:06 <bartw> because the story really made it one of the greatest contests
04:43:47 <roconnor> bourbaki: ``Should you encounter any such publications, we humbly request that you submit them to us via our web site.''
04:44:04 <roconnor> I guess it is a bit buried in the task description
04:44:19 <bourbaki> yes
04:44:20 <xerox> More challenging!
04:44:39 <roconnor> The zeroth challenge is to read and understand the task.
04:45:12 <roconnor> dons: How many people on your team?
04:45:58 <bourbaki> good that i fell out so early :)
04:46:21 <bartw> this one was great, not much coding though
04:46:45 <bartw> bourbaki : if you have spare time it is really funny to try it again, you can still do this challenge without points
04:47:07 <bourbaki> if i had spare time :) ...
04:47:18 <bourbaki> id rather write a paper or so
04:47:50 <bartw> really ?
04:47:54 <bourbaki> sure
04:48:19 <bartw> i much rather write an compiler then write a paper personally
04:48:38 <roconnor> @seen shapr
04:48:39 <lambdabot> I saw shapr leaving #HASKELL 1d 14h 33m 2s ago, and .
04:48:45 <bourbaki> hehe :)
04:48:58 <bourbaki> anyway im afk now
04:49:02 <bartw> later
04:49:04 <roconnor> bourbaki: you remind me that I wrote a paper.
04:49:10 <roconnor> I should do something with it.
04:50:32 <bartw> put it on a website and spam us with it ?
04:52:02 <roconnor> Well, I need to put it on the monad reader, and then edit it a bit more
04:55:49 <xerox> roconnor: do it!
04:57:58 <roconnor> I need an account on the Monad Reader
04:59:06 <Syzygy-> If I want an unwords, but with some other character than space as separator, is there a neat way to do that?
05:00:36 <xerox> You have to roll it up from scratch I believe.
05:01:29 <gour> @where jhc
05:01:30 <lambdabot> http://repetae.net/john/computer/jhc/
05:02:38 <Syzygy-> xerox: Gotcha. :)
05:02:58 <xerox> Syzygy-: break :: (Eq a) => a -> [a] -> [[a]]  or break :: (Eq a) => [a] -> [a] -> [[a]] ?
05:03:20 <Syzygy-> sumString (x:y:xs) = sumString ((x ++ "+" ++ y) : xs)  <== this did it neatly with the base cases separately...
05:03:55 <Syzygy-> Next question. I have a [String], and want to print each element out on a line, to an external file, with a lot of .. embellishments. Any good way to do it?
05:05:23 <xerox> let contents = unlines . map embellishments $ strings in do writeFile contents
05:05:43 <xerox> > intersperse '+' "is this what you were doing there?"
05:05:44 <Syzygy-> Thanks.
05:05:45 <lambdabot>  "i+s+ +t+h+i+s+ +w+h+a+t+ +y+o+u+ +w+e+r+e+ +d+o+i+n+g+ +t+h+e+r+e+?"
05:06:05 <Syzygy-> > intersperse '+' ["a","b","c*d","r"]
05:06:06 <lambdabot>  Couldn't match `Char' against `[Char]'
05:06:17 <Syzygy-> > intersperse "+" ["a","b","c*d","r"]
05:06:18 <lambdabot>  ["a","+","b","+","c*d","+","r"]
05:06:24 <Syzygy-> > unwords $ intersperse "+" ["a","b","c*d","r"]
05:06:25 <lambdabot>  "a + b + c*d + r"
05:06:28 <Syzygy-> That'd work.
05:06:30 <xerox> :D
05:06:40 <sieni> > intersperse ' ' "this is a stupid way of emphasizing a sentence."
05:06:41 <lambdabot>  "t h i s   i s   a   s t u p i d   w a y   o f   e m p h a s i z i n g   a  ...
05:07:37 <Syzygy-> Background: I'm using Haskell to generate testcases for my current research. Basically taking an entire fixed-degree slice of a specific ring and testing each element for a certain property. Since the ring is over the field of two elements, the elements of the ring are easy to build, and I just need subsets of the generators, and a way to convert a subset to a polynomial.
05:09:15 <Syzygy-> > ['"']
05:09:16 <lambdabot>  "\""
05:12:36 <zzctb> hi, im looking for a way to take two integers say 1 and 10 and return a random value between 1-10... i have looked at randomR, but im puzzled by it returning a (a, b) value. any advice? thanks.
05:15:43 <Syzygy-> Hey - we did this a while ago... :)
05:16:27 <dons> Prelude System.Random> getStdRandom (randomR (0,1)) >>= print
05:16:27 <dons> 1
05:16:27 <dons> Prelude System.Random> getStdRandom (randomR (0,1)) >>= print
05:16:27 <dons> 0
05:16:58 <Syzygy-> zzctb: Early on in your program, do: g <- getStdGen; Then whenever you need a random number between a and b: do { x=randomR (a,b); whatever_you_want x;}
05:18:41 <roconnor> > concat (intersperse ["+"] ["a","b","c*d","r"])
05:18:42 <lambdabot>  Couldn't match `[Char]' against `Char'
05:18:46 <xerox> dons: it'd be fun to eventually write Lambdabot.Safe.IO sometimes...
05:18:53 <xerox> "+"
05:19:15 <roconnor> > concat (intersperse "+" ["a","b","c*d","r"])
05:19:16 <lambdabot>  "a+b+c*d+r"
05:19:19 <dons> a newtype SafeIO perhaps, with some careful wrappers of things that we know are safe.
05:19:19 <Syzygy-> zzctb:
05:19:20 <Syzygy-> Prelude System.Random> let getRand = getStdRandom $ randomR (0,10)
05:19:26 <Syzygy-> Prelude System.Random> print =<< getRand
05:19:26 <Syzygy-> 5
05:19:26 <Syzygy-> Prelude System.Random> print =<< getRand
05:19:26 <Syzygy-> 1
05:19:31 <Syzygy-> Prelude System.Random> print =<< getRand
05:19:31 <Syzygy-> 7
05:19:31 <Syzygy-> Prelude System.Random> print =<< getRand
05:19:31 <Syzygy-> 10
05:19:39 <xerox> dons: right.  With random numbers too? :D
05:22:18 <mux> @dice 1d10
05:22:18 <lambdabot> 1d10 => 8
05:22:23 <mux> @dice 1d10
05:22:24 <lambdabot> 1d10 => 4
05:22:48 <roconnor> dice should output 4 <- 1d10
05:22:59 <roconnor> that would look more like a monad operation.
05:23:13 <mux> that's easily doable
05:23:17 <sieni> xerox: safe io is easy, just keep references to the old states of the world inside the io monad, so you can revert changes at any time
05:23:58 <xerox> sieni: go for it then?
05:25:00 <AstralStorm> Hey, is there some way to make Haskell program not overflow when computing bignums?
05:25:59 <sieni> xerox: there just seems to be a problem in the garbage collector of the world, since I've tried to keep a reference to a previous state, but it somehow gets lost anyway
05:27:02 <xerox> sieni: in this limited applications there's just IRC-I/O, something like putStrLn = show, &co.
05:27:46 <roconnor> @hoogle [m a] -> ([a]->b) -> m b
05:27:47 <lambdabot> Foreign.Marshal.Utils.withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
05:27:53 <zzctb> Syzygy-: thanks that worked well. but why is the print =<< needed? is there a way to get around it?
05:28:08 <xerox> ?type mapM
05:28:10 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
05:28:13 <dons> AstralStorm: use Integer?
05:28:34 <Syzygy-> zzctb: The print =<< is just to make it -do- something.
05:28:54 <xerox> ?type (. (=<<)) . sequence
05:28:56 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => [(m a -> m b) -> a1] -> (a -> m b) -> [a1]
05:28:59 <xerox> Ooops
05:29:04 <Syzygy-> zzctb: You need to read out the actual random numbers in something. I used print.
05:29:09 <dons> AstralStorm: like this:
05:29:11 <dons> > let fac 0 = 1 ; fac n = n * (fac $! n-1) in fac 42 :: Integer
05:29:13 <lambdabot>  1405006117752879898543142606244511569936384000000000
05:29:14 <dons> you mean?
05:29:48 <sieni> > product [1...100]
05:29:49 <lambdabot>  Not in scope: `...'
05:29:52 <sieni> > product [1..100]
05:29:53 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
05:29:54 <sieni> oops
05:29:57 <dons> or that :)
05:30:04 <pianodogg> thems a big number
05:30:17 <dons> > product [1..1000]
05:30:19 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
05:30:22 <dons> > product [1..100000]
05:30:24 <lambdabot>  out of memory (requested 2097152 bytes)
05:30:27 <dons> heh
05:30:30 <xerox> ?type flip liftM . sequence -- roconnor
05:30:31 <roconnor> *MonadRandom> let x `d` y = fmap sum $ sequence $ replicate x (getRandomR (1,y))
05:30:31 <roconnor> *MonadRandom> print =<< evalRandIO (1`d`10)
05:30:31 <roconnor> 1
05:30:32 <lambdabot> forall r (m :: * -> *) a. (Monad m) => [m a] -> ([a] -> r) -> m r
05:30:34 <dons> > product [1..10000]
05:30:38 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
05:30:41 <dons> good bot.
05:31:02 <dons> would that be simpler in any other language?
05:31:05 <roconnor> @botsnack
05:31:06 <lambdabot> :)
05:31:10 <pianodogg> how much memory in the box that runs lambdabot?
05:31:45 <roconnor> *MonadRandom> print =<< evalRandIO (1`d`10)
05:31:45 <roconnor> 3
05:33:32 <roconnor> > product [0..10000]
05:33:33 <lambdabot>  0
05:33:36 <roconnor> > product [0..100000]
05:33:38 <lambdabot>  0
05:33:43 <roconnor> :)
05:34:10 <pianodogg> shocking!
05:34:31 <roconnor> > product [100000,99999..0]
05:34:33 <lambdabot>  out of memory (requested 2097152 bytes)
05:34:58 <dons> the list construction isn't fusing with product properly. I should probably switch on -O
05:35:59 <dons> or , how big is that output String?
05:36:44 <pianodogg> > log (product [1..10000]
05:36:45 <lambdabot>  Parse error
05:36:49 <pianodogg> > log (product [1..10000])
05:36:50 <lambdabot>  Infinity
05:36:59 <pianodogg> really
05:37:05 <pianodogg> > log 100
05:37:07 <lambdabot>  4.605170185988092
05:37:19 <wilx> >length $ product [1..10000]
05:37:26 <roconnor> dont't trust floating point.
05:37:36 <dons> > length .show . product $ [1..10000]
05:37:40 <lambdabot>  35660
05:37:51 <pianodogg> log [1..10000] / log 10
05:37:51 <wilx> Ooops.
05:37:54 <pianodogg> > log [1..10000] / log 10
05:37:56 <lambdabot>  add an instance declaration for (Floating [a])
05:38:03 <profmakx> -.
05:38:09 <profmakx> you forgot product
05:38:19 <pianodogg> > log (product [1..10000]) / log 10
05:38:21 <lambdabot>  Infinity
05:38:23 <pianodogg> > log (product [1..1000]) / log 10
05:38:24 <lambdabot>  Infinity
05:38:30 <pianodogg> right, floating point
05:38:33 <pianodogg> big numbers
05:38:40 <roconnor> Infinity ~ 35660
05:38:49 <pianodogg> length . show . product $ [1..30000]
05:38:52 <pianodogg> > length . show . product $ [1..30000]
05:38:55 <lambdabot>  out of memory (requested 1048576 bytes)
05:38:58 <pianodogg> > length . show . product $ [1..20000]
05:39:01 <lambdabot>  out of memory (requested 2097152 bytes)
05:39:04 <pianodogg> > length . show . product $ [1..15000]
05:39:07 <lambdabot>  out of memory (requested 1048576 bytes)
05:39:10 <pianodogg> > length . show . product $ [1..10000]
05:39:13 <lambdabot>  35660
05:39:25 <pianodogg> surprisingly low
05:40:31 <mnislaih> any HSP.Clientside programmer around ?
05:54:25 <ventonegro> what happens if in ' case n of' none of the cases match?
05:55:01 <wilx> Runtime error.
05:56:09 <gds> Is there a compile time warning that the cases aren't exhaustive?
05:56:28 <norpan> gds: yes
05:56:28 <ventonegro> nope
05:56:39 <norpan> maybe it's not on by default
05:56:43 <norpan> not sure
05:57:08 <ventonegro> when I add '_ -> return ()' I get warning of overlapped patterns
05:58:17 <pianodogg> then you're already covering all the cases
06:00:03 <ventonegro> aha! haskell must know because it knows all the constructors of my data type
06:00:07 <ventonegro> doh
06:00:45 <ventonegro> so it can't be anything else, hence _ is unnecessary
06:01:32 * gds has often wondered how close ghc is to sentience...
06:01:47 <gds> Smart compiler.
06:02:17 <ventonegro> indeed
06:02:30 * ventonegro likes more and more of haskell as him learns it
06:02:35 * roconnor has often wondered how close ghc is to omiscience
06:02:42 <ventonegro> s/him/he/
06:04:00 <gds> :)
06:04:43 <ventonegro> i've spoken too early
06:04:57 <ventonegro> i added another constructor but ghc is not complaining
06:06:42 <ventonegro> but adding '_ -> return ()' stopped giving me 'overlapped pattern' warnings
06:07:05 <arjanb> the coverage detection thing is a bit bugged
06:09:05 <norpan> ventonegro: no, you need to enable -fwarn-incomplete-patterns
06:09:32 <ventonegro> ah, ok
06:10:11 <norpan> http://web.mit.edu/ghc/www/users_guide/options-sanity.html for a lot of warnings that can be enabled
06:10:14 <lambdabot> Title: 4.7. Warnings and sanity-checking, http://tinyurl.com/ljpwm
06:10:26 <ventonegro> now it's complaining
06:10:29 <ventonegro> thanks
06:26:21 * Syzygy- generates Singular scripts with a bunch of haskell commands, and then executes them through ssh. I'm falling in love with 'ssh server command < input' :)
06:31:13 <pianodogg> Syzygy-: it's a good way to get your ssh public key into the remote machine's authorized keys file in one shot
06:31:41 <pianodogg> ssh remote bash -c 'cat - >> .ssh/authorized_keys' < .ssh/id_rsa.pub
06:32:10 <Syzygy-> That one's neat. Thanks. :)
06:35:10 <mcnster> morning
06:35:13 <kzm> Tired of my GC problems yet?  I think I've solved it now :-)
06:36:48 <mcnster> q:  how do i test for an eof condition prior to using an fdRead?  its too early in the day to be getting unhandled exceptions... :-)
06:37:15 <roconnor> @hoogle eof
06:37:16 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
06:37:17 <lambdabot> Text.Read.EOF :: Lexeme
06:37:17 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
06:37:35 <roconnor> @type fdRead
06:37:37 <lambdabot> Not in scope: `fdRead'
06:37:44 <roconnor> @hoogle fdRead
06:37:45 <lambdabot> No matches found
06:38:04 <mcnster> hmmm
06:38:35 <roconnor> @hoogle hread
06:38:36 <lambdabot> IO.hReady :: Handle -> IO Bool
06:38:36 <lambdabot> Data.Graph.Inductive.Internal.Thread :: module
06:38:36 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
06:38:52 <roconnor> oooh, hReady sounds promising
06:38:57 <roconnor> @docs hReady
06:38:58 <lambdabot> hReady not available
06:39:04 <roconnor> @docs IO
06:39:05 <lambdabot> IO not available
06:39:11 <roconnor> @docs
06:39:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:39:16 <dons> ?index hReady
06:39:17 <lambdabot> System.IO
06:39:23 <dons> ?docs System.IO
06:39:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
06:39:28 <dons> ?. docs index hReady
06:39:29 <lambdabot> System.IO
06:39:29 <lambdabot>  not available
06:39:57 <roconnor> This operation may fail with:
06:39:57 <roconnor>     * isEOFError if the end of file has been reached.
06:40:06 <Syzygy-> Oooooooooh. I like our double core calculation server. I get a processor all to my self! :)
06:40:24 <mcnster> @hoogle hIsEof
06:40:24 <roconnor> @hoogle Handle -> IO Bool
06:40:25 <lambdabot> IO.hIsEOF :: Handle -> IO Bool
06:40:26 <lambdabot> IO.hIsClosed :: Handle -> IO Bool
06:40:26 <lambdabot> IO.hIsEOF :: Handle -> IO Bool
06:40:26 <lambdabot> IO.hIsOpen :: Handle -> IO Bool
06:40:30 <mux> dons: any idea why using this: "filter ((/= "more") . fst)" as my filter transformation function wouldn't work?  I don't see the more filter kicking in, even with a very large number of lines
06:41:03 <mcnster> humph.  i was all set to use Posix this trip... :(
06:41:41 <Syzygy-> > 2^7
06:41:42 <lambdabot>  128
06:41:50 <roconnor> mcnster: what is fdRead?
06:42:28 <mcnster> roconnor, see System.Posix.IO
06:42:44 <mcnster> (equiv. to unix read())
06:43:48 <mcnster> maybe i can convert a Fd to Handle
06:44:00 <mcnster> ... but that seems inelegant
06:44:00 <roconnor> fdToHandle :: Fd -> IO Handle
06:44:14 <roconnor> this function has the side effect of putting the Fd  into non-blocking mode
06:44:25 <mcnster> double
06:44:44 <ventonegro> SIDE-EFFECT?
06:44:52 <ventonegro> no, oh God, no!
06:44:59 <mcnster> heh
06:45:37 <mcnster> maybe i'll just skip reading the file and construct the dataset randomly....
06:46:12 <roconnor> how is hIsEof implemented?
06:47:20 <roconnor> and why would fdRead throw an EOF exception?
06:47:33 <mcnster> roconnor, good q
06:47:36 <roconnor> shouldn't it just return ("",0)
06:47:47 <mcnster> that's what i coded for... but nooooo
06:48:06 <roconnor> sounds like a bug in fdRead
06:48:12 <roconnor> but what do I know
06:48:41 <roconnor> Programmers using the fdRead and fdWrite API should be aware that EAGAIN exceptions may occur for non-blocking IO!
06:48:49 <roconnor> EAGAIN?
06:49:10 <roconnor> @hoogle EAGAIN
06:49:10 <pianodogg> eagain
06:49:11 <lambdabot> Foreign.C.Error.eAGAIN :: Errno
06:49:18 <pianodogg> your system call blocked
06:49:21 <Syzygy-> It is very common to get this error when your application is doing non-blocking operations on files or network sockets. For example, you can open a file/socket/fifo for reading with the O_NONBLOCK flag. If you subsequently do a read(2) call and there is no data waiting, instead of blocking and waiting until there is data ready and returning that data, the read() call will return an error (EAGAIN) to let your application know that there is no data 
06:49:29 <Syzygy-> (first hit on google:eagain)
06:49:35 <pianodogg> well there you go
06:50:01 <pianodogg> or if you did a system call, it blocked, but then your process got a signal or something which cancelled your syscall
06:50:12 <pianodogg> so the kernel is telling you, "try again"
06:50:56 <mcnster> .... one of the design flaws of unix
06:51:34 <roconnor> House will fix everything
06:51:41 <mux> most unices have restartable syscalls now
06:52:01 <mcnster> anyone give me a clue on how to catch the eof exception generated by fdRead?
06:52:10 <mux> ?hoogle bracket
06:52:11 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:52:11 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
06:52:11 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
06:52:23 <mux> ?hoogle catch
06:52:24 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
06:52:24 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
06:52:24 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
06:53:57 <mcnster> mux, hmm.  guess i have to hunt down a constructor of IOError or Exception that represents eof?
06:54:28 <mux> there is an isEOF thing, IIRC
06:54:31 <mux> ?hoogle isEOF
06:54:32 <lambdabot> IO.isEOF :: IO Bool
06:54:32 <lambdabot> IO.isEOFError :: IOError -> Bool
06:54:32 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
06:54:39 <mux> ah, isEOFError ?
06:54:51 <mux> would that do what you want?
06:55:23 <mux> catch (\e -> if isEOFError e then ... else ...) foo
06:55:39 <roconnor> else throw e
06:55:56 <mux> yeah
06:56:13 <mux> I suppose you could write a catchEOF function too
06:56:34 <mux> that would probably be more readable
06:57:10 <mcnster> hmm
06:57:40 <nomeata> speaking of HOUSE, are there any special things that a compiled Haskell binary could do in House, compared to a "normal" binary? E.g. lazy evaluation even across the OS/app border?
06:58:46 <mcnster> thanks mux.  i think this'll work
06:58:56 <mux> np
06:59:29 <Syzygy-> Oh, by the way. This is for help earlier today.
06:59:31 <Syzygy-> xerox++
06:59:47 <roconnor> @karma+ xerox
06:59:47 <lambdabot> xerox's karma raised to 23.
06:59:55 <mux> yeah, they make good photocopiers :-)
06:59:59 * mux grins
07:00:05 <Syzygy-> mux: pbbtbtbtbtbtbt
07:00:15 <mux> what does that mean?
07:00:18 <Syzygy-> mux: Your name reminds me of a fun anecdote.
07:00:25 <mux> shoot!
07:00:46 <Syzygy-> pbtbtbtb is the sound you make when you put the mouth between lower lip and teeth, and then blow, letting lips and tongue vibrate.
07:00:56 <mux> heh ok.
07:01:01 <mux> what about the anecdote?
07:01:06 * Syzygy- had a job - just before starting University - in Germany writing C and assembler for mobile phones. 
07:01:20 <Syzygy-> More specifically, implementing fast modular exponentiation for their crypto libraries.
07:01:36 <Syzygy-> Before I started, I got sent to a workshop held by Texas Instruments Training in order to learn that dialect of assembler.
07:01:37 <bartw> oooh
07:02:03 <Syzygy-> I introduced myself as just having graduated, by mistake - I wasn't certain enough in my German to see the difference between Abschluss and Abitur.
07:02:12 * macron is back (gone for 07:00.10)
07:02:46 <Syzygy-> And so, I was sitting there, in a room full with fully educated civil engineers with signal processing majors: one teacher at a Technical University, a couple of TI salespeople, and a bunch of active engineers. And I was having problems with the lingo.
07:02:57 <bartw> i always say i 'went to' university myself
07:03:09 <bartw> never completed anything
07:03:18 <Syzygy-> At the point where I asked for an explanation of the word "mux", the teachers started to question my competence, and ask me why the flying fuck I didn't know what a mux was if I was in this workshop.
07:03:33 <mux> heh
07:03:38 <bartw> hehe
07:03:57 <Syzygy-> The point where I really blew them away, though, was when I offhand optimized their algorithm by a factor 2 - complete with proof why the optimization worked. They spent about half an hour arguing with me about it until they got convinced.
07:04:06 <bartw> no quick google for wikipeida in the offline world :(
07:04:26 <Syzygy-> I must have left some hell of an impression with the people there - I didn't know basic signal handling, but damn did I get a grip of the code I saw....
07:04:55 <bartw> what was the nature of the optimization ?
07:05:44 <Syzygy-> A symmetric filter was supposed to be applied to a data stream, and they did it by running something across all of the datawindow. I observed that it was enough running it across half and then doubling the result, then spent a few moments fuzzing about how it would work with even contra odd length windows.
07:08:38 <bartw> and that is possible because the second halve is an inverse of the first halve ?
07:09:38 <mux> I can't seem to be able to get a hold on dons
07:09:46 <mux> he's such a moving target :)
07:11:31 <malcolm> http://video.google.com/videoplay?docid=6419094369756184531
07:11:34 <lambdabot> Title: mymovie12.mov - Google Video, http://tinyurl.com/oshpp
07:11:52 <malcolm> hmm, they haven't changed the title yet
07:12:00 <malcolm> it's the ICFP programming contest video
07:12:49 <dons> malcolm: would you like me to stick a link in the HWN for next week?
07:13:14 <malcolm> 120Mb download (1hr 4mins), and unfortunately it doesn't seem to stream
07:13:33 <malcolm> so download only
07:14:04 <bartw> it is streaming here, but not very fluently
07:14:05 <malcolm> dons: well, haskell didn't win any prizes
07:14:28 <dons> true.
07:15:35 <dons> ah, seems to have changed the name now
07:15:37 <dons> " ICFP programming contest 2006 results"
07:16:21 <dons> yep, streaming here. nice!
07:16:40 <malcolm> ok, cool
07:17:17 <Syzygy-> @type sort
07:17:22 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:17:30 <Syzygy-> Hmmm. How do I sort a list according to length?
07:17:35 <roconnor> malcolm: where's the torrent?
07:17:47 <Lemmih> Syzygy-: sortBy (comparing length)
07:17:48 <Syzygy-> Hrm. A [String] according to length of each string in the list.
07:17:56 <Syzygy-> @type sortBy
07:17:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:18:19 <roconnor> @type comparing
07:18:20 <lambdabot> Not in scope: `comparing'
07:18:38 <roconnor> let comparing f a b = compare (f a) (f b)
07:18:44 <Lemmih> @type Data.Ord.comparing
07:18:46 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:18:55 <roconnor> that's awsome!
07:19:01 <roconnor> is that haskell 98?
07:19:17 <sjanssen> sortBy (comparing length) will be real slow for longish strings
07:19:30 <Lemmih> sjanssen: But it's just /so/ pretty (:
07:19:31 <malcolm> roconnor: what's a torrent? ;-)
07:19:38 <Syzygy-> > let comparing f a b= compare (f a) (f b) in sortBy (comparing length) ["ab","c","def"]
07:19:39 <lambdabot>  ["c","ab","def"]
07:19:43 <roconnor> @google bittorrent
07:19:43 <Syzygy-> Wonderful!
07:19:59 <lambdabot> search module failed: IRCRaised thread killed
07:20:07 <roconnor> Syzygy-: apparently comparing is in Data.Ord
07:20:08 <sjanssen> @type map snd . sortBy (Data.Ord.comparing fst) . map (\s -> (length s, s))
07:20:10 <lambdabot> forall a. [[a]] -> [[a]]
07:20:21 <sjanssen> @pl \s -> (length s, s)
07:20:21 <lambdabot> (,) =<< length
07:20:38 <Syzygy-> @where sortBy
07:20:38 <lambdabot> I know nothing about sortby.
07:20:43 <Syzygy-> @hoogle sortBy
07:20:43 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:20:58 <roconnor> > sortBy (Data.Ord.comparing length) ["ab", "c", "def"]
07:21:00 <lambdabot>  Not in scope: `Data.Ord.comparing'
07:21:37 <sjanssen> @let comparing f a b = compare (f a) (f b)
07:21:37 <lambdabot> Defined.
07:21:40 <xerox> Syzygy-: thanks!
07:22:24 <roconnor> > sortBy (comparing length) ["ab", "c", "def"]
07:22:25 <lambdabot>  Not in scope: `comparing'
07:22:52 <Lemmih> > sortBy (L.comparing length) ["ab", "c", "def"]
07:22:53 <lambdabot>  ["c","ab","def"]
07:23:38 <malcolm> I gave a copy of the video to the ICFP contest organisers, so it will appear on the official website at some point as well (http://icfpcontest.org/)
07:23:41 <lambdabot> Title: ICFP Programming Contest, 2006
07:24:54 <sjanssen> did anybody record the talks at the GHC hackathon?
07:26:16 <jgrimes> malcolm, thanks for the ICFP video
07:26:42 <malcolm> sjanssen: yes, me
07:26:56 <sjanssen> malcolm: neato
07:27:07 <malcolm> sjanssen: but they will require more post-processing than my laptop can handle, so not uploaded anywhere yet
07:27:19 <AstralStorm> @type ($!)
07:27:20 <lambdabot> forall b a. (a -> b) -> a -> b
07:27:24 <AstralStorm> @type ($)
07:27:26 <lambdabot> forall b a. (a -> b) -> a -> b
07:27:35 <AstralStorm> What's the difference?
07:28:47 <Syzygy-> @docs prelude
07:28:47 <lambdabot> prelude not available
07:28:50 <Syzygy-> @docs Prelude
07:28:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:29:40 <Syzygy-> $ is function application. $! is used to avoid unneeded laziness.
07:29:46 <Syzygy-> seq :: a -> b -> b
07:29:46 <Syzygy-> The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness.
07:29:49 <Syzygy-> ($!) :: (a -> b) -> a -> b
07:29:51 <Syzygy-> Strict (call-by-value) application, defined in terms of seq.
07:31:01 <AstralStorm> Ah, so it's strict.
07:31:02 <AstralStorm> :-)
07:31:46 <int-e> a $! b = b `seq` a b
07:32:21 <AstralStorm> @type seq
07:32:23 <lambdabot> forall b a. a -> b -> b
07:32:29 <AstralStorm> Hehe.
07:32:34 <AstralStorm> Nice.
07:32:50 <malcolm> Does someone want to email the haskell-cafe with the location of the ICFP video?  My webmail access is a bit flaky
07:34:04 <dons> yep, i'll pass it on now.
07:37:38 <bourbaki> moin
07:38:18 <AstralStorm> moin
07:40:18 <dons> malcolm: sent to haskell-cafe
07:42:22 <malcolm> dons: cheers
07:44:04 <ndm> dons/dcoutts__ ?
07:44:10 <dcoutts__> @arr
07:44:10 <lambdabot> I'll keel haul ya fer that!
07:44:14 <ndm> how do i put data (String) into ByteString?
07:44:21 <dcoutts__> ndm: hoogle!
07:44:22 <dons> ?type Data.ByteString.pack
07:44:24 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
07:44:28 <dons> ?type Data.ByteString.Char8.pack
07:44:29 <lambdabot> String -> Data.ByteString.Base.ByteString
07:44:41 <ndm> does hoogle have ByteString yet?
07:44:46 <dcoutts__> dunno :-)
07:44:47 <AstralStorm> ?type Data.ByteString.unpack
07:44:49 <lambdabot> Data.ByteString.Base.ByteString -> [Word8]
07:44:51 <dcoutts__> it should :-)
07:44:55 <AstralStorm> ?type Data.ByteString.Char8.unpack
07:44:55 <ndm> pack :: [Word8] -> ByteString
07:44:57 <lambdabot> Data.ByteString.Base.ByteString -> [Char]
07:44:58 <dons> have you generated the index from a recent base libraries?
07:45:02 <fasta> I suppose there's no way to do foo (_ (Bar x) (Zork y)) = x?
07:45:18 <sjanssen> fasta: where the _ is any constructor?
07:45:19 <ndm> i'll update it at some point, its in limbo - hoogle 4 has bytestring in it
07:45:23 <fasta> sjanssen: yes
07:45:27 <ndm> what about [Word8] vs Char?
07:45:28 <sjanssen> I don't think so
07:45:40 <fasta> sjanssen: Annoying
07:45:42 <AstralStorm> ndm: Word8 = 8 bits :>
07:45:53 <AstralStorm> Unsigned Char
07:45:56 <ndm> AstralStorm: i guessed that, but i want String -> ByteString
07:46:08 <AstralStorm> [Char] == String
07:46:11 <ndm> AstralStorm: in C, yes, but not in Haskell
07:46:14 <sjanssen> AstralStorm: Chars are not necessarily 8 bits in Haskell
07:46:19 <AstralStorm> yes.
07:46:37 <ndm> so i probably want Data.ByteString.Char8 then ?
07:46:41 <dcoutts__> yes
07:46:41 <AstralStorm> Yes.
07:46:49 <dcoutts__> but do note that it is Char8 not Char
07:47:05 <ndm> am just testing the new release of WinHugs, before it goes live
07:47:35 <dcoutts__> does ByteString work with (Win)Hugs ?
07:47:41 <bartw> asm as judges choice :)
07:47:57 <dcoutts__> I've never tried it, though I think dons made sure that it compiled
07:48:05 <ndm> dcoutts__, of course :)
07:48:08 <dcoutts__> we were optimising for ghc-6.5 of course
07:48:32 <ndm> yeah, but since its written in C (to an extent), its probably more of a win of ByteString vs String in Hugs
07:48:41 <dcoutts__> not necessarily
07:48:48 <dcoutts__> there;s not that much C
07:49:07 <dcoutts__> and a lot of code forms that ghc optimises away but hugs will not
07:49:10 <ndm> ah well, it works at least, so who cares
07:49:18 <dcoutts__> aye, that's more important
07:50:08 <jgrimes> what is the status on unicode ByteString?
07:50:18 <dcoutts__> jgrimes: ask sjanssen
07:51:33 <sjanssen> jgrimes: there is a data structure that can hold the full range of Char, but no IO routines yet
07:51:45 <jgrimes> sjanssen, mm cool
07:52:08 <dcoutts__> sjanssen: no need for that if you can convert to/from a ByteString in UTF8/16/32
07:52:17 <dcoutts__> that gives the IO for free
07:52:36 <sjanssen> yeah, I should say no translation routines yet
07:52:44 <ndm> dons: are you going to add Yhc bytecode compiling to lambdabot then?
07:52:45 <dcoutts__> right
07:53:05 <dcoutts__> sjanssen: so we could do IO for UTF32
07:53:16 <sjanssen> native endian UTF32
07:53:29 <dcoutts__> ah yes, right
07:53:39 <dcoutts__> I was thinking of doing an iconv binding after the gzip
07:53:53 <dcoutts__> since it's the same data flow scheme
07:54:16 <dcoutts__> that'd do ByteString -> ByteString charset transformations
07:54:24 <dcoutts__> eg UTF32 -> UTF8
07:54:30 <dcoutts__> and coutless others
07:55:46 <syntaxfree> @pl \x->x+1
07:55:47 <lambdabot> (1 +)
07:56:05 <syntaxfree> @pl \x->x:"y"
07:56:06 <lambdabot> (: "y")
07:56:20 <dcoutts__> malcolm: what format is that video in? I can't play it it seems.
07:56:25 <syntaxfree> @pl \x->"a":b:"c"
07:56:25 <lambdabot> const ["a", b, 'c']
07:56:39 <mauke> whoa
07:56:50 <xerox> Video! Where is it, dcoutts?
07:57:20 <dcoutts__> malcolm: oh, maybe I can download it rather than stream it since that seems to need flash or some other browser plugin
07:57:23 <xerox> Oh on the page.
07:57:38 <dcoutts__> http://video.google.com/videoplay?docid=6419094369756184531
07:57:41 <lambdabot> Title: ICFP programming contest 2006 results - Google Video, http://tinyurl.com/oshpp
08:00:02 <jgrimes> @pl (\x -> (\y -> y) (\z -> z)) (\u -> u)
08:00:04 <lambdabot> id
08:00:15 <malcolm> dcoutts__: QuickTime, encoded with H.264 and Mpeg-4 audio
08:00:31 <dcoutts__> malcolm: ok, thanks
08:00:47 <yacstud> hi, is there a library to parse yaml in haskell ?
08:00:49 <xerox> malcolm: does google re-encode it? I.e. does the quality drop down on video.g.c =
08:00:52 <xerox> s/=/?/
08:00:52 <dons> dcoutts__: I'm just downloading and playing with mplayer from disk, as the file is downloaded
08:00:54 <malcolm> dcoutts__: should be hinted for streaming, but might take a minute or two to buffer up at the start
08:01:03 <dons> good on Team Lazy Bottoms!
08:01:16 <dcoutts__> it's still 120M
08:01:18 <malcolm> xerox: no idea about re-encoding
08:01:24 <dcoutts__> dons: oh?
08:01:51 * dcoutts__ is on a slow wireless connection so hasn't got it downloaded yet
08:02:05 <dons> just start playing it before its done?
08:02:10 <xerox> I'm downloading the ipod/psp file
08:02:18 <malcolm> OK, I'm off to the conference hotel now.  (the video took me 15 minutes to upload using the wireless at the hotel
08:02:27 <dcoutts__> dons: my player doesn't like that :-(
08:02:49 <dons> playing the .part file? (or maybe you don't get one?)
08:03:07 <dons> i've got a .avi.part file which plays nicely in mplayer
08:03:07 <dcoutts__> it's an .avi
08:03:19 <dons> which is creating a final .avi file, once all done
08:03:43 <syntaxfree> @pl topborder b x = ("" : b) : x
08:03:43 <lambdabot> topborder = (:) . ([] :)
08:03:48 <xerox> dons: you're downloading it from..
08:03:48 <syntaxfree> where did the empty string go?
08:03:48 <xerox> ?
08:04:07 <norpan> "" == []
08:04:11 <syntaxfree> oh ok.
08:04:41 <norpan> at least almost
08:04:51 <dons> ?where+ icfpcontest-video http://video.google.com/videoplay?docid=6419094369756184531
08:04:52 <lambdabot> Done.
08:05:10 <dons> oh goggle switching. doh.
08:08:15 <jgrimes> what artificial intelligence work has been done using haskell?
08:08:48 <deadbeef> jgrimes: i've seen an alpha-beta algorithm
08:08:50 <deadbeef> done in haskell
08:09:05 <dons> we wrote an alpha-beta search for last years icfp contest in haskell :)
08:09:26 <edwinb> There was a lot of natural language processing work done in Haskell in Durham in the 90s
08:09:40 <edwinb> I suppose there must still be a bit done somewhere
08:10:09 <bourbaki> a planner in haskel would be fun i guess
08:11:43 <Lemmih> dons: What good news on Team Lazy Bottoms?
08:12:33 <dons> oh, they seem to have been the first to have hacked into several of the problems
08:12:39 <dons> i.e. the fastest
08:13:04 <Lemmih> Yay. (:
08:13:14 <dons> yeah!
08:13:46 <norpan> the contest seems to have been a bit different this year
08:15:19 <mux> dons: did you see my earlier question?
08:15:53 <Lemmih> Woot. #18 place.
08:16:25 <xerox> Haskell is big in the tag cloud :D
08:23:19 <jgrimes> dons, did you start on the dwm c to haskell conversion?
08:23:29 <marcot> What are the pros from wxhaskell if compared with gtk2hs?
08:25:07 <xerox> haha
08:25:12 <xerox> they are *crazy*
08:26:25 <gds> dons: re your blog post - are you aware of: http://en.wikipedia.org/wiki/Wikipedia:Text_editor_support  ?
08:26:28 <lambdabot> http://tinyurl.com/gxh9d
08:28:28 <roconnor> Oh, the winners are Chris and Derek.
08:28:34 <roconnor> That makes sense
08:29:02 <roconnor> Those two are probably the best contest programmers in the world.
08:29:10 <int-e> Hah. I made the top 50 :)
08:29:23 <xerox> int-e++ !!
08:29:28 <roconnor> Maybe even the best programmers in the world.
08:30:08 <int-e> xerox: barely. I'm 50th ;)
08:30:16 <gds> roconnor: and are they (as in the rumour mentioned earlier) google folk?
08:30:26 <xerox> int-e: cool :)
08:30:54 <xerox> Lazy bottoms first for the second problem too. Wee!
08:31:38 <dcoutts__> marcot: there's an issue with memory management with wxwidgets: http://haskell.org/gtk2hs/archives/2005/07/15/automatic-memory-management/
08:31:40 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» What do we mean by automatic memory management? How do ..., http://tinyurl.com/l77pr
08:31:49 <dcoutts__> oh he left
08:32:05 <fasta> Is there a function which applies the given function to a list of arguments? thus f g [x1:x2:x3:[]] = g x1 x2 x3, but then f should work for arbitrary lists. I don't think it's going to work though, and only Scheme can express these things.
08:32:17 <roconnor> gds: that is what they said on the video, although I wasn't aware they were working at google.
08:32:23 <fasta> s/Scheme/languages like Scheme
08:32:38 <dcoutts__> fasta: yes having variable number of args is tricky with typing
08:32:47 <dcoutts__> fasta: one can pass lists of course
08:32:48 <gds> Ah - cheers :) No sound at work, so I guess I'll have to watch the vid at home ;)
08:33:49 <fasta> dcoutts__: yes, but the function doesn't expect a list as it is a constructor (not that constructors can't work on lists)
08:34:31 <fasta> dcoutts__: making it a list will destroy the fact that the constructors only need a specific amount of arguments.
08:34:49 <dcoutts__> fasta: right, so it can only be done for fixed numbers of args
08:35:39 <roconnor> I'm confused, does f take a fixed number of arguments, or a variable number of arguments?
08:35:44 <dons> oh, the jit-compiler for the UM, I think that was edwardk :)
08:35:48 <fasta> dcoutts__: I can hack up a specific "apply", indeed. I don't like the approach, but it's the best I can do.
08:35:51 <dons> using hs-plugins :D
08:36:03 <dcoutts__> fasta: generally it's not needed
08:36:07 <dcoutts__> dons: :-)
08:36:30 <fasta> dcoutts__: In this case I need uniform treatment of nodes in my tree.
08:36:41 <dcoutts__> fasta: since whereever you use f you will know the number of parameters of g
08:39:42 <marcot> Do I have to use allow-overlaping-instances to use haskelldb
08:39:43 <marcot> ?
08:40:45 <dcoutts__> marcot: there's an issue with memory management with wxwidgets: http://haskell.org/gtk2hs/archives/2005/07/15/automatic-memory-management/
08:40:47 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» What do we mean by automatic memory management? How do ..., http://tinyurl.com/l77pr
08:41:07 <dcoutts__> marcot: otherwise the advantages/disadvantages are similar to those of Gtk+ vs wxWidgets
08:41:08 <marcot> dcoutts__: thanks.
08:41:23 <dcoutts__> Gtk2Hs is currently a bit easier to build I think
08:41:35 <marcot> hum... I tend to prefer gtk than wxwidgets.
08:41:41 <dcoutts__> me too :-)
08:41:50 <marcot> But I thought that maybe in haskell one could be better.
08:42:13 <dcoutts__> well I think one is better but I'm obviously biased
08:43:11 <marcot> hum...
08:43:14 <roconnor> what happend to fuggets?
08:43:24 <dcoutts__> it died
08:43:28 <roconnor> :'(
08:43:34 <marcot> Are the other gui options good?
08:43:43 <dcoutts__> marcot: what other ones?
08:44:02 <marcot> http://www.haskell.org/haskellwiki/Libraries_and_tools/GUI_libraries
08:44:05 <marcot> These.
08:44:05 <lambdabot> Title: Libraries and tools/GUI libraries - HaskellWiki, http://tinyurl.com/gn7tc
08:44:10 <roconnor> any particular reason for it's demise?  Not enough wigets?  Not enough compatiability?
08:44:12 <dcoutts__> fudgets is a nice idea, it might be worth updating it to a modern toolkit
08:44:32 <dcoutts__> it used raw X11 and bitrotted severely
08:44:35 <roconnor> some sort of java awt vs java swing like problem?
08:44:48 <dcoutts__> it used internals of ghc 2.x something
08:45:48 <marcot> hum...
08:47:30 <marcot> I'm getting an overlapping instance error with haskelldb...
08:47:46 <dcoutts__> try using -fallow-overlapping-instances
08:47:53 <marcot> And I'm doing something very similar to the tutorial.
08:48:13 <dons> heya zarvok
08:48:23 <sek> @type find
08:48:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:48:35 * zarvok waves
08:48:52 <marcot> dcoutts__: It worked... But in the doc this is not described, I'm afraid I'm doing something wrong.
08:48:55 <zarvok> I saw you posted the video
08:49:16 <dons> yep. malcolm did all the work
08:49:24 <zarvok> yeah, I spoke with him about it
08:49:25 <dcoutts__> marcot: sorry, I'm not sufficiently familar with haskelldb
08:49:30 <marcot> hum...
08:49:42 <marcot> So about guis, you think that the best option is gtk2hs?
08:49:57 <dcoutts__> marcot: yes, I do. But as I said, I'm biased. :-)
08:50:08 <zarvok> in case your curious, smartass listed haskell as a language they used
08:50:12 <zarvok> *you're
08:50:23 <dons> oh!
08:50:37 <dons> very good :D
08:50:38 <dcoutts__> oh so Haskell is still the language of choice for descriminating hackers?
08:51:01 <zarvok> no, they picked 2D (a contest language) as their language of choice
08:51:03 <marcot> dcoutts__: About db access options do you know what are the best options?
08:51:13 <marcot> It semeed to me that haskelldb was the most high level one.
08:51:14 <dons> yeah, so they in fact use haskell and others?
08:51:21 <dcoutts__> zarvok: so merely *a* language of choice :-)
08:51:34 <zarvok> dons: yeah, they used haskell, c++, python, and maybe some others
08:51:37 <dcoutts__> marcot: I think haskelldb + hdbc is good
08:51:37 <zarvok> :)
08:51:48 <dons> nice.
08:51:49 <marcot> dcoutts__: better than haskelldb + hsql?
08:52:34 <dcoutts__> marcot: my impression is that hdbc is better, but hsql has been used more with haskelldb before, so might be smoother to get it to work
08:52:42 <marcot> hum..
08:52:45 <marcot> Ok, thanks a lot.
08:53:01 <zarvok> dons: we were pretty happy with the 2D choice, of course :)
08:53:11 <dons> true. but it mystified many :)
08:53:19 <zarvok> In fact, I guess I have written the only implementation of the language of choice of discriminating hackers
08:53:21 <zarvok> :)
08:53:27 <dons> hehe!
08:53:30 <dons> zarvok++
08:53:31 <marcot> I'm going to lunch now, c'ya.
08:53:37 <zarvok> yeah, lots of people at the time were very confused
08:54:00 <dons> are the actual languages used by the winning teams up somewhere?
08:54:10 <dons> i'd like to write some summary for the haskell weekly news next week.
08:55:05 <dons> s/a list of the actual languages used/ :)
08:55:20 <zarvok> dons: We haven't decided how much of the individual team data we should make available, but the talk slides will be up soon and it has counts of how many times each language was used
08:55:36 <zarvok> I think haskell is 4th after c++, c, python
08:55:57 <dons> ah good. yes. I saw that in the video. though it seems the list of languages actually used by the winners is a valuable resource :)
08:57:32 <zarvok> yeah, I'm hoping we'll put most of it up, but it's not entirely up to me
08:57:50 <dons> yep, fair enough.
09:02:50 <zarvok> [11:52am|zarvok> dons: we were pretty happy with the 2D choice, of course :)
09:02:56 <zarvok> oops
09:03:01 <zarvok> man I do that too much
09:03:23 <dons> [01:52|dons:: true. but it mystified many :)
09:03:46 <dons> deja vu!
09:03:49 <zarvok> heh
09:04:07 <dons> ?localtime dons
09:04:11 <lambdabot> Local time for dons is Thu Sep 21 02:03:46 2006
09:04:14 <dons> bedtime. night!
09:04:21 <zarvok> night
09:12:55 <ventonegro> @index Maybe
09:12:55 <lambdabot> Data.Maybe, Prelude
09:14:03 <ventonegro> what does mplus for Maybes do?
09:14:18 <ventonegro> mplus Nothing (Just a) = ?
09:14:37 <kpreid> @fptools Data.Maybe
09:14:38 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
09:15:04 <ventonegro> > mplus Nothing (Just 100)
09:15:05 <lambdabot>  Just 100
09:15:15 <kpreid> @fptools Control.Monad.Plus
09:15:15 <lambdabot> Control.Monad.Plus not available
09:15:20 <ventonegro> > mplus (Just 50) (Just 100)
09:15:21 <lambdabot>  Just 50
09:16:01 <glguy> > liftM2 (+) (Just 50) (Just 100)
09:16:02 <lambdabot>  Just 150
09:17:41 <ventonegro> > liftM2 (+) Nothing (Just 100)
09:17:42 <lambdabot>  Nothing
09:18:36 <ventonegro> no good
09:19:21 <int-e> > sum $ catMaybes [Nothing, Just 100]
09:19:22 <lambdabot>  100
09:20:02 <ventonegro> yes, catMaybes, that's it
09:20:18 <glguy> ventonegro: I don't actually know what you were trying to do, I just came back to my terminal and saw mplus
09:20:36 <ventonegro> glguy, i know, i didn't explain it properly :-)
09:21:13 <ventonegro> it's a Maybe where i need f Nothing (Just a) = Just a
09:21:25 <ventonegro> i thought mplus would do that
09:21:39 <ventonegro> but catMaybes is even better for me
09:22:16 <glguy> ventonegro: mplus does what you just said
09:22:24 <glguy> > mplus Nothing (Just 1)
09:22:26 <lambdabot>  Just 1
09:22:40 <ventonegro> glguy, yep
09:22:44 <glguy> ok
09:23:00 <ventonegro> but it's a tree, i can use catMaybes . flatten
09:24:17 <ventonegro> glguy, actually, mplus (Just 50) (Just 100) = Just 50
09:24:22 <ventonegro> no good for me
09:24:34 <ventonegro> so catMaybes is the way to go
09:27:03 <wilx> > mplus [1,2]
09:27:05 <lambdabot>  Add a type signature
09:27:08 <wilx> > mplus [1::Int,2]
09:27:10 <lambdabot>  <[Int] -> [Int]>
09:27:22 <kpreid> > msum [1::Int,2]
09:27:23 <lambdabot>  Couldn't match `m a' against `Int'
09:27:34 <kpreid> er, never mind
09:28:03 <glasser> what's the status of ghc on intel macs?
09:28:36 <xerox> Fast! :)
09:29:22 <shapr> @yow !
09:29:23 <lambdabot> Are we having fun yet?
09:29:37 <shapr> @users
09:29:45 <shapr> lambdabot: @hello
09:29:49 <roconnor> zarvok: when can we expect a permanent puzzle web site?
09:29:50 <lambdabot> Maybe you meant: help hylo tell
09:29:52 <glasser> 6.4 doesn't work though, right?
09:29:52 <lambdabot> seen module failed: IRCRaised thread killed
09:30:01 <shapr> yargh, what's wrong with lambdabot?
09:30:01 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
09:30:25 <shapr> malcolm: Of course he would show up the day I fly away :-)
09:30:32 <roconnor> shapr: I have a pre-print of my Monad Reader article.
09:30:34 <shapr> hiya edwardk!
09:30:39 <edwardk> heya
09:30:39 <shapr> roconnor: ooh! I want to read it!
09:30:50 <shapr> edwardk: Thanks for letting me sleep in the other bed in your room.
09:30:54 <zarvok> roconnor: www.boundvariable.org is up now
09:31:06 <shapr> edwardk: Nice to meet you in person!
09:31:07 <zarvok> roconnor: a final version of the codex will be released within a week or so
09:31:24 <shapr> @users
09:31:33 <shapr> foo
09:31:56 <lambdabot> Maximum users seen in #haskell: 237, currently: 231 (97.5%), active: 43 (18.6%)
09:32:26 <roconnor> zarvok: I assume the final codex won't require registration?
09:32:50 <roconnor> shapr: I was thinking I should upload it to the monad reader wiki, and wikify it.
09:33:09 <dcoutts__> hia shapr
09:33:29 <zarvok> roconnor: we haven't worked out the details yet, but I imagine registration will be available if you want to compete on a permanent scoreboard and we'll also post a key anyone can use
09:33:59 <xerox> malcolm: great video, thanks much.
09:34:04 <shapr> roconnor: Yes please!
09:34:08 <shapr> dcoutts__: hiya!
09:34:10 <roconnor> zarvok: oh interesting.  I'm itching to get my friends to play, but I think I will wait for the final codex.
09:34:14 * shapr boings cheerfully
09:34:18 <dcoutts__> :-)
09:34:22 <shapr> I had lots of fun at Haskell Workshop!
09:34:24 <roconnor> shapr: I suppose I will need a wiki account.
09:34:34 <dcoutts__> shapr: oh you went? cool.
09:34:35 <shapr> roconnor: Good point, just a moment...
09:34:43 <shapr> dcoutts__: Yeah, it was a blast.
09:35:00 <dcoutts__> shapr: I'm sad I missed it. I'll be there next year I expect.
09:35:05 <shapr> I also took my copy of TaPL in hopes of getting it autographed, but Pierce wasn't there while I was.
09:35:09 <dcoutts__> shapr: I hear Lemmih was ill :-(
09:35:09 <zarvok> roconnor: well, much of what is there will stay the same if you want to get started.  we'll be making some problems harder to game probablistically and adding a few extra puzzles in some of the problems, but otherwise it will be similar
09:35:16 <shapr> Yeah, that was sad :-(
09:35:32 <dcoutts__> nice paper though, I'm eager to try it out
09:35:48 <shapr> I haven't read it yet, though it's on my list.
09:35:55 <dcoutts__> nice and short :-)
09:36:04 <dcoutts__> 3.1 pages
09:36:06 <ick> hi!
09:36:09 <shapr> I read Andy Gill's 2000 paper about debugging via examining intermediate data structures.
09:36:14 <ick> im in need of some help
09:36:16 <roconnor> zarvok: It seems like a great set of puzzles for teenagers learning to code to work on.
09:36:17 <shapr> hej ick, hur mår du?
09:36:20 <zarvok> roconnor: but I'm glad to hear you're so excited about it :)
09:36:34 <roconnor> and use ``grown-ups'' too
09:36:35 <shapr> ick: You're at Lund, right?
09:36:39 <roconnor> s/use/us/
09:36:44 <ick> shapr: yeah
09:36:54 <shapr> ick: Have you been to #haskell before?
09:37:09 <ick> shapr: one time, i just cant get the maybe type right :S
09:37:09 <zarvok> roconnor: yeah, thanks, we're hopeful it will appeal to a variety of people
09:37:25 <shapr> ick: Welcome to #haskell, where people are friendly!
09:37:35 <shapr> data Maybe a = Nothing | Just a
09:37:38 <shapr> Is that what you want?
09:37:38 <ick> shapr: but they talk in strange languages :D
09:37:45 <shapr> kanske, SVENSKA?
09:37:50 <ventonegro> today is the Maybe day
09:37:54 <ValarQ> ick: try #haskell.se then ;)
09:37:57 <ick> ventonegro: haha :D
09:38:04 <ick> nono, its not THAT language
09:38:08 <ick> its haskell...
09:38:09 <shapr> I'm having trouble finding Swedish speakers in Alabama.
09:38:16 <dcoutts__> shapr: odd that
09:38:30 <ick> shapr: you're from Sweden?
09:38:33 <ValarQ> ick: haskell is one of the few languages that isn't strange :o)
09:38:38 <dcoutts__> I bet there were plenty in Portland at HW
09:38:39 <roconnor> shapr & ick: Did you vote for the Pirate Party?
09:38:49 <shapr> I did hear that the local swim team is primarily composed of Swedish females, but I'm not sure my girlfriend would find that an acceptable way to practice my Swedish.
09:38:52 <dcoutts__> @arr
09:38:52 <lambdabot> Yo ho ho, and a bottle of rum!
09:39:02 <shapr> roconnor: Nah, I left 12 days before the vote happened :-(
09:39:15 <shapr> ick: No, I'm from Birmingham, Alabama. Isn't it normal to speak Swedish here?
09:39:25 <ick> roconnor: no, i changed my mind and voted for a "real" party
09:39:41 <shapr> dcoutts__: I only met four or five Swedish speakers at HW.
09:39:59 <shapr> Piratpartiet Ã¤r en riktigt parti!
09:40:00 <dcoutts__> shapr: well it's a long way to go
09:40:18 <shapr> Surprisingly two of the Swedish speakers were from .nl / .au
09:40:29 <shapr> Johan Jeuring and Andy Adams-Moran
09:40:36 <ick> shapr: i didnt want my vote to be counter-productive
09:40:53 <ick> shapr: as much as i love freedom of information, i really wanted a new government
09:40:59 * ValarQ voted on the communistic party
09:41:06 <shapr> I think Piratpartiet is a productive thing, but I'm often considered a zealot.
09:41:17 <shapr> hoi fasta, hoe gaat het?
09:41:41 <shapr> Oh, I met Daan Leijen and Doaitse Swierstra again, and Wouter Swierstra for the first time.
09:41:56 <fasta> Why doesn't this work? apply (:>>:) [a,b] = a :>>: b
09:42:00 <xerox> ?google parsec haskell
09:42:02 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
09:42:07 <roconnor> wikipida says that the existance of Piratpartiet changed the copyright policies of other parties.
09:42:11 <xerox> ^- that daan, shapr ?
09:42:16 <shapr> And Rebekah Leslie is way cool in person. Her L4 kernel work in Haskell is cool all by itself of course.
09:42:22 <shapr> xerox: Yup, that's the Daan.
09:42:24 <ick> you all seem like nice people, could you set me straight regarding a function im trying to implement?
09:42:26 <xerox> Woo!
09:42:29 <ValarQ> roconnor: that might be true
09:42:38 <fasta> shapr: good, you?
09:42:43 <xerox> ick: sure, ask!
09:42:51 <shapr> fasta: Doing quite well, I just got back from Haskell Workshop!
09:42:53 * shapr boings furiously
09:42:57 <shapr> Man it was FUN
09:42:59 <xerox> I'm sure you'll have some nice haskell golf starting.
09:43:08 <fasta> shapr: It was?
09:43:17 <ick> i have this function foo :: [String] -> [String]
09:43:30 <shapr> Definitely. I broke down and bought Okasaki's book and read most of it on the flights back as well.
09:43:37 <ick> and in it im calling a function returning a Maybe String
09:43:54 <shapr> fasta: Have you ever been to a Haskell Workshop?
09:44:01 <fasta> shapr: no
09:44:06 <roconnor> :type concatMaybes
09:44:07 <ick> now, i want to concat that result to a recursive call to foo, if the maybe isnt Nothing
09:44:16 <roconnor> @type concatMaybes
09:44:18 <lambdabot> Not in scope: `concatMaybes'
09:44:20 <roconnor> @type concatMaybe
09:44:21 <shapr> There were Scheme, Erlang, OCaml, etc workshops as well, maybe one of those would have thrilled you more?
09:44:22 <lambdabot> Not in scope: `concatMaybe'
09:44:23 <xerox> catMaybes roconnor
09:44:26 <roconnor> damn
09:44:30 <shapr> Anyway, ICFP is a blast, I just wish I'd had time and funds to go to all of it.
09:44:32 <ValarQ> @type fromMaybe
09:44:32 <ick> roconnor: :D
09:44:34 <lambdabot> forall a. a -> Maybe a -> a
09:44:42 <roconnor> @hoogle [Maybe String] -> [String]
09:44:43 <lambdabot> No matches, try a more general search
09:44:47 <shapr> @index Maybes
09:44:48 <lambdabot> bzzt
09:44:49 <roconnor> what!
09:44:52 <ick> it has to be a Prelude function
09:44:53 <shapr> @index concatMaybe
09:44:54 <lambdabot> bzzt
09:44:57 <roconnor> @hoogle [Maybe a] -> [a]
09:44:58 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
09:45:00 <shapr> hiya tmoertel!
09:45:01 <xerox> ick: you want [Maybe String] -> [String] ?
09:45:19 <ick> Maybe String -> String
09:45:31 <xerox> ick: Maybe a -> a is ill-defined
09:45:36 <shapr> tennin: hiya! nice to meet you in person! Sorry I didn't have more time to talk to you.
09:45:38 <xerox> ?type fromMaybe
09:45:40 <lambdabot> forall a. a -> Maybe a -> a
09:45:46 <xerox> That's better, I'll show you why:
09:45:50 <xerox> ?type fromJust
09:45:52 <lambdabot> forall a. Maybe a -> a
09:45:54 <xerox> > fromJust Nothing
09:45:56 <lambdabot>  Add a type signature
09:46:00 <xerox> > fromJust Nothing :: ()
09:46:02 <lambdabot>  Exception: Maybe.fromJust: Nothing
09:46:07 <fasta> shapr: Do you know why doesn't this work? apply (:>>:) [a,b] = a :>>: b
09:46:18 <fasta> why this, even
09:46:22 <glguy> ?type (:>>:)
09:46:23 <roconnor> xerox: ick needs [Maybe String] -> [String]
09:46:24 <lambdabot> Not in scope: data constructor `:>>:'
09:46:34 <xerox> ick: fromMaybe :: a -> Maybe a -> a, insted, provides a default value for the Nothing case.
09:46:35 <fasta> er nm
09:46:35 <shapr> Speaking of which, Smerdyakov was at Haskell Workshop and I didn't get to talk to him.
09:46:52 <xerox> roconnor: I think so too, but he got to understand why :)
09:46:58 <roconnor> oh
09:46:58 <fasta> shapr: he is into formal methods, right?
09:46:59 <glguy> ?type apply
09:47:02 <lambdabot> Not in scope: `apply'
09:47:02 <shapr> Yup, he is.
09:47:20 <glguy> oh, duh, you are defining apply, but what is :>>:
09:47:45 <xerox> ick: if you want we could go over #haskell-overflow since the discussions are overlapping.
09:47:50 <shapr> fasta: But also, I perm-banned him from #haskell long ago and wanted to talk to him in person and see if maybe face to face would be a better communication medium.
09:47:53 <fasta> glguy: :>>: is a constructor of type SomeType->SomeType->SomeType
09:48:00 * ventonegro loves pattern matching
09:48:06 <edwardk> back
09:48:14 <ick> xerox: sure
09:48:20 <edwardk> shapr: Pierce was here yesterday acually.
09:48:30 <shapr> edwardk: Yeah, but I was flying home :-(
09:48:30 <tennin> are you still in Portland, shapr?
09:48:35 <tennin> oh... guess not
09:48:42 <shapr> I'm back in Birmingham now.
09:49:01 <shapr> So, no autograph for me.
09:49:11 <edwardk> Alas
09:49:19 <shapr> I wonder if I could bribe someone to get their copy of TaPL autographed and then swap copies with them....
09:50:03 <roconnor> @what TaPL
09:50:04 <lambdabot> I know nothing about tapl.
09:50:09 <shapr> @where tapl
09:50:10 <lambdabot> I know nothing about tapl.
09:50:11 <shapr> hmm
09:50:17 <tennin> I meant to suggest you try visiting this very interesting computer recycling outfit/community technology center: http://www.freegeek.org while you were here
09:50:18 <zarvok> shapr: heh, do you think many people carried tapl with them to icfp?
09:50:18 <lambdabot> Title: FREE GEEK: HOME
09:50:20 <fasta> Why can't I pattern match on a constructor?
09:50:25 <roconnor> @what == @where
09:50:26 <lambdabot> I know nothing about ==.
09:50:32 <shapr> @where+ tapl http://www.cis.upenn.edu/~bcpierce/tapl/
09:50:32 <lambdabot> Done.
09:50:42 <shapr> zarvok: No, but I brought mine :-)
09:50:46 <zarvok> :)
09:51:16 <shapr> fasta: Can you show specifically what's not working?
09:51:29 <shapr> zarvok: Were you at haskell workshop?
09:52:02 <zarvok> shapr: no, sadly I couldn't get away for enough time to do both HW and the conference
09:52:15 <fasta> data Foo = Foo :>>: Foo| Empty; apply (:>>:) [a,b] = a :>>: b
09:52:29 <bourbaki> moin
09:53:00 <araujo> Hi!
09:53:08 <shapr> zarvok: I thought I saw your nametag go past once but I wasn't sure.
09:53:08 <zarvok> shapr: how was it?
09:53:14 <shapr> It was a blast!
09:53:42 <zarvok> yeah, I bet.  I've been having a great time at ICFP proper
09:53:43 <fasta> apply c [a,b] | c== :>>: = a :>>: b works however
09:54:19 <shapr> I tend to read the papers ahead of time if they interest me, so the social side of the conference is my favorite. But sometimes presentations get me interested in the paper.
09:54:30 <glguy> fasta: can you ever pattern match on a raw constructor?
09:54:51 <fasta> glguy: you should be able to do that, imho. Probably it is impossible
09:55:05 <glguy> > let f Just = 1; f _ = 2 in f Just
09:55:05 <shapr> Oh and TMR has a probably co-editor now!
09:55:06 <lambdabot>    Constructor `Just' should have 1 argument, but has been given 0
09:55:07 <lambdabot>   When...
09:55:12 <shapr> Wouter Swierstra volunteered!
09:55:15 * shapr boings
09:55:28 <glguy> > let f (Just) = 1; f _ = 2 in f (Just)
09:55:29 <lambdabot>    Constructor `Just' should have 1 argument, but has been given 0
09:55:29 <lambdabot>   In t...
09:55:46 <zarvok> shapr: cool
09:55:52 <fasta> shapr: what was the most interesting talk in your opinion?
09:56:10 <zarvok> shapr: yeah, it's been neat to meet the people here, I had not previously met SPJ and many other greats that were here
09:56:45 <edwardk> zarvok: where are you at in the room?
09:57:12 <zarvok> edwardk: maybe 8 rows from the back on the right, I'll stand up
09:57:45 * araujo throws sugar lambdas at everyone
09:57:54 <shapr> fasta: It's hard to say, Dana Xu's ESC/Haskell talk has potential to change daily usage of Haskell.
09:58:09 <shapr> Andy Gill's talk excited me the most because I have a long standing interest in refactoring browsers.
09:58:11 <fasta> shapr: Are his slides online?
09:58:25 <shapr> Dana Xu == female, and not sure.
09:58:36 <shapr> I saw her talk at AngloHaskell and spoke to her more about it then.
09:59:02 <fasta> shapr: I didn't know females existed in that world ;) Other than Philippa.
09:59:03 <shapr> I'm always a bit wary of things that require a preprocessor.
09:59:19 <shapr> But "extended static checking" is a great thing.
09:59:33 <zarvok> edwardk: where are you?
09:59:44 <shapr> Of course, you could say that refactoring browsers are the ultimate in preprocessors...
10:00:08 <glguy> Does anyone know why I might be able to compile a snapshot of ghc without Happy, but not the darcs repository?
10:00:31 <shapr> fasta: Silva's CoddFish is quite impressive, bringert has expressed interest in implementing that for HaskellDB
10:00:36 <ndm> shapr: its not really a preprocessor for Esc/Haskell is it? More an entirely separate way of "executing" the code
10:00:54 * shapr thinks about that.
10:01:02 <dcoutts__> glguy: the ghc tarballs don't need happy, building ghc from the darcs repo does.
10:01:31 <tennin> there were about 5-6 women at HW as I recall, 2 presenting
10:01:35 <dcoutts__> glguy: because the tarballs include the output from happy. Is that what you meant?
10:01:40 <glguy> yeah
10:01:43 <glguy> just making sure
10:02:15 <dcoutts__> shapr: you need to bully the HaskellDB folk to do a release with tarballs so we can package it.
10:02:26 <shapr> tennin: Yup, Silva & Xu presented and Weirech and several others were in the audience.
10:02:46 <dcoutts__> shapr: it's still far too hard to get HaskellDB + (hsql / hdbc) installed
10:02:48 <fasta> shapr: Can you explain me the difference by having a type-level encoding of some property or having the same program in a dynamically typed language? Since the types _still_ don't tell you the semantics of the program. It seems that you are only moving the problem, not solving it.
10:03:04 <shapr> I'm glad the Haskell community does not discriminate against anything other than crappy code =)
10:03:15 <ndm> is Andy Gill's thing online?
10:03:22 <ndm> i saw the screenshot and want to play :)
10:03:27 <shapr> It wasn't online two days ago.
10:03:35 <dcoutts__> ndm: where's the screenshot ?
10:03:40 <shapr> ndm: Wait till you see the .mov file he played, it's awesome!
10:04:03 <ndm> @google haskell equational reasoning assistant
10:04:06 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Equational_Reasoning_Assistant
10:04:06 <lambdabot> Title: Haskell Equational Reasoning Assistant - HaskellWiki
10:04:16 <ndm> dcoutts__ ^^^ - its been online for months
10:04:22 <dcoutts__> oh right
10:04:23 <shapr> fasta: I agree that type level encodings are much like moving the problem into an untyped language.
10:04:36 <fasta> shapr: fantastic :)
10:04:39 <ndm> shapr: you then have kind's, to type your types
10:04:46 <shapr> Right, there are meta-types
10:05:36 <shapr> But even in idiomatic Haskell you can use types as a skeleton to structure your program, or you can ignore them and do your own mostly unchecked thing. That's always been true.
10:06:22 <shapr> fasta: Have you read about dependent types as used in Epigram?
10:06:38 <fasta> shapr: I read part of the Epigram paper, yes.
10:07:14 <shapr> Once types are values and vice versa, the language becomes something else entirely. I like that something btw :-)
10:07:24 <glguy> I like when the lead singer of Muse sings into the little bullhorn
10:07:53 <glguy> mt
10:08:57 <ndm> shapr: why don't you prefer something like ESC/Haskell, where you write the properties in the langauge you know - rather than learining two languages, one for type-time and one for run time?
10:08:59 <shapr> fasta: Have you tried to write a program in Epigram? It's very nifty.
10:09:14 <shapr> ndm: I'd rather have one that's both type time and run time.
10:09:17 <fasta> shapr: no, I am currently doing more interesting things, imho.
10:09:20 <lisppaste2> ick pasted "haskhell" at http://paste.lisp.org/display/26378
10:09:28 <shapr> fasta: Ok, good to do what you like :-)
10:09:29 <ndm> shapr: indeed, thats what ESC/Haskell is
10:09:49 <shapr> Hm, I'll read the paper again and keep that idea in mind.
10:09:51 <ndm> one language for writing assertions which can be checked at compile time, which matches the language you write in perfectly :)
10:10:24 <ndm> its also a much nicer flow - from a property you write you can quickcheck then ESC-check it
10:10:34 <fasta> shapr: r6rs draft is out in case you are interested r6rs.org
10:10:51 <shapr> fasta: Yeah, I saw that announcement on ll1-discuss, I'll get to it when I have time.
10:10:57 <dwm> ?type maybe
10:10:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:11:00 <fasta> shapr: it's long ;)
10:11:02 <vincenz> nickserv is down?
10:11:06 <shapr> I read fast!
10:11:26 <shapr> Oh, I met Graham Hutton as well.
10:11:36 <ndm> yeah, he's a nice guy
10:11:38 <shapr> He has a new Haskell book coming out soon.
10:11:50 * shapr roots around for the advertisement.
10:12:00 <dwm> vincenz: nickserv just responded to me
10:12:02 <ndm> i thought it was already out - it's in the last HCAR
10:12:33 <shapr> dwm: Are you the guy I spoke to at the Galois evening?
10:12:42 <shapr> About Gentzen etc?
10:12:43 <vincenz> dwm: ah, yeah wrong /ignore
10:13:37 <darinm> what's that about Gentzen?
10:13:46 <dwm> shapr: No. I recently grabbed this nick (maybe about a week ago). I was Dino_ for a while here.
10:14:07 <shapr> That explains it. This guy said he was dwm but then that nick was taken recently.
10:14:07 <dwm> You people have been helping me quite a bit since May, actually.
10:14:24 <darinm> shapr: that would have been me :)
10:14:29 <darinm> the other night at Henry's, right?
10:14:30 <shapr> aha!
10:14:34 <shapr> Yes!
10:14:46 <shapr> Nice to meet you again across the wire.
10:14:53 <darinm> yeah :)
10:14:57 <fasta> http://pastebin.com/790671   Illegal instance declaration for
10:14:59 <darinm> how was your trip back?
10:15:07 <shapr> And I want to get that list of books you mentioned.
10:15:21 <darinm> ok... I will put something together, probably tonight
10:15:34 <shapr> It was long but I bought Okasaki's book from the Cambridge University Press table so I read most of it on the flights.
10:15:40 <fasta> Could anyone have a look there? I thought I did something like that earlier a few years ago.
10:15:48 <xerox> fasta: it doesn't load
10:15:49 <xerox> @paste
10:15:50 <lambdabot> http://paste.lisp.org/new/haskell
10:15:53 <xerox> Oh wait, it does.
10:16:02 <darinm> shapr: yeah, that's a good book
10:16:15 <glguy> anyone know what flag to use to skip the stage1 build and use the existing compiler to do the stage2 build?
10:16:22 <shapr> Philippa mentioned something about complexity of laziness on LtU a few weeks back and it's been running around in my head ever since. I think that amortization analysis might be the tool that everyone is missing.
10:16:41 <mauke> you're trying to make (->) X Y an instance of Eq where X and Y aren't variables
10:16:48 <shapr> glguy: It's something like make stage=2 but I don't think that's exactly it.
10:17:03 <shapr> hiya kowey!
10:17:13 <fasta> mauke: ok, and how can I make it work?
10:17:17 <kowey> shapr! (hi)
10:17:22 * shapr boings!
10:17:37 <mauke> fasta: I don't think you should be able to make that work :/
10:17:37 <shapr> kowey: Did you see that I wrote something on IRC during your presentation? :-)
10:17:43 <mauke> it feels wrong
10:17:48 <kowey> yeah, i noticed :-)
10:18:01 <fasta> mauke: I want to pass the constructor in a function.
10:18:18 <fasta> mauke: seems like a useful thing to do.
10:18:44 <mauke> not really
10:19:04 <mauke> why do you need to compare functions?
10:19:19 <vincenz> fasta: you're trying to filter data cons?
10:19:28 <shapr> Oh, I'm going to canvas Stephanie Weirech to put a nickname field on future ICFP nametags.
10:19:46 <vincenz> shapr: ?
10:19:47 <roconnor> fasta: You cannot pattern match on function types.
10:19:57 <shapr> There were several people that weren't associated from/to nick/realname until hours later.
10:19:59 <vincenz> roconnor: he's patternmatching on datacons
10:20:14 <vincenz> shapr: ICFP is done?
10:20:15 <shapr> David Roundy shaved off his beard and no one would have noticed him without his nametag.
10:20:16 <fasta> I could also just pass 1 for the one function and a 0 for the other, but it feels a bit low-level.
10:20:23 <shapr> vincenz: Nah, but I only went to Haskell Workshop.
10:20:30 <roconnor> what is the type of :>>: ?
10:20:32 <vincenz> shapr: ah, was hoping for info on icfpc
10:20:41 <fasta> roconnor: SomeType->SomeType->SomeType
10:20:53 <vincenz> woot
10:20:53 <vincenz> top 20
10:20:55 <roconnor> oh
10:21:30 <roconnor> still, when pattern matching, you need to assing variables to the parameters of the constructor.
10:21:36 <roconnor> or more patterns
10:22:11 <shapr> darinm: Anyway, I'll send you an email so you have my address.
10:22:38 <darinm> shapr: ok, great
10:23:00 <roconnor> if you really want do make an Eq instance then you can make a newtype for SomeType -> SomeType -> SomeType
10:23:24 <vincenz> roconnor: look at the code-sample he pasted
10:23:25 <roconnor> however, I suspect that you don't really want to solve whatever problem you have this way.
10:23:28 <vincenz> roconnor: it's not Eq for function types
10:23:36 <vincenz> roconnor: he wants to compare data-cons without comparing their args
10:23:43 <vincenz> erm unapplied datacons
10:23:46 <roconnor> instance Eq (SomeType -> SomeType -> SomeType)
10:23:51 <vincenz> look at what's in it
10:23:51 <mauke> in other words, functions
10:23:56 <roconnor> see, equality for function types.
10:23:57 <vincenz> more specifically in this case
10:23:58 <vincenz> datacons
10:24:06 <mauke> doesn't make a difference
10:24:13 <vincenz> it's a subproblem
10:24:27 <vincenz> and it does make a difference, cause this one is solvebable with TH
10:24:34 <roconnor> vincenz: can't pattern match on constructors without patterns or variables for all the arguments.
10:24:34 <vincenz> apply to fake args, then compare ignoring args
10:25:08 <roconnor> one could do (_ :>>: _) == (_ :>>: _) = True  (I think).
10:25:15 <kpreid> a == b = (a junk1 junk2) == (b junk1 junk2)
10:25:15 <vincenz> yep
10:26:57 <fasta> But you can't make it an instance of Eq via this way.
10:27:21 <vincenz> ooh
10:27:24 <vincenz> fasta: sadly no
10:27:31 <vincenz> shapr: want a nice quote?
10:27:41 * vincenz has buddhist thought of the day on his personalized google homepage
10:27:46 <vincenz> Holding onto anger is like grasping a hot coal with the intent of throwing it at someone else; you are the one who gets burned.
10:27:53 <vincenz> -- the man himself
10:28:03 <musasabi> Something like http://pybots.org/ would be nice to have for Haskell.
10:28:05 <lambdabot> Title: Welcome to Pybots, the Python Community Buildbots
10:28:51 <vincenz> musasabi: seems dangerous
10:29:01 <vincenz> well less so in haskell, just disallow IO
10:30:14 <dolio> "Today we're going to do something horrible. We're going to add an assignment statement. And since we can do all these wonderful things without it, why should we add it?"
10:30:22 <dolio> Why indeed.
10:30:38 <roconnor> Is this the same as HUnit?
10:32:40 <vincenz> I think it's more the framework around that
10:32:51 <musasabi> vincenz: it is dangerous if it is open for anonymous things, but if there is enough trust it should work.
10:33:03 <vincenz> true
10:33:29 <vincenz> well that or virtualized servers :)
10:33:44 <roconnor> dolio: who are you quoting?
10:34:04 <dolio> Sussman from the SICP lectures.
10:34:30 <vincenz> this is scary: http://www.sciam.com/article.cfm?chanID=sa006&articleID=00068F43-E189-150E-A18983414B7F0000&ref=rss
10:34:31 <xerox> dolio: and then he says?
10:34:35 <lambdabot> Title: Science & Technology at Scientific American.com: Darwin on the Right -- Why Chri ..., http://tinyurl.com/hhf24
10:38:00 <dolio> "The only reason we ever add a feature to our language ... is going to boil down to the ability ... to break a problem into pieces that are different sets of pieces than you could  have without that."
10:40:08 <fasta> I like Sussman's lectures. He reminds me of some other good teachers.
10:41:17 <dolio> Yeah. I don't always agree with everything he says, but the lectures are interesting and entertaining.
10:42:18 <fasta> If I would have known about them 5 years ago I would have already watched them all.
10:45:22 <Tela> If your module exports a Datatype which has a constructor of the same name, do importing modules get access to the constructor or just the datatype?
10:45:44 <dolio> It's hard to believe this is an intro to computer science course. :)
10:46:26 <dolio> In the first four weeks they got up to building a symbolic differentiation/algebraic simplification program...
10:46:36 <dolio> All while using a purely functional subset of scheme.
10:47:04 <dolio> And now on week 5, he's introducing assignment, and 15 minutes in, he's showing why assignment causes all kinds of problems. :)
10:47:36 <marcot> Hello there.
10:47:42 <fasta> dolio: I read the book already
10:48:16 <marcot> In haskelldb, how do I access a value in a CalendarTime?
10:48:36 <dolio> Yeah, I like the book, too.
10:49:51 * fasta writes 5 different instantions of cdr in Haskell due to lack of expresiveness....
10:50:52 <glguy> funniest thing I've seen all day: http://www.youtube.com/watch?v=QBvKD4ZONNw&NR
10:50:54 <lambdabot> Title: YouTube - Adult Swim - Cyber-Bullying
10:52:06 <lisppaste2> Kurley pasted "html" at http://paste.lisp.org/display/26381
10:57:09 * bringert exhales
10:57:21 <edwardk> heh
10:57:25 <edwardk> good job
10:57:40 <shapr> hej bringert
10:57:49 <bringert> hej shapr
10:57:54 <shapr> Wassup?
10:57:55 * bringert just held his icfp talk
10:57:59 <shapr> cool!
10:58:09 <bringert> edwardk: thanks
10:58:13 <shapr> lennart: Sadly I didn't get to meet you at Haskell Workshop.
10:58:13 <lennart> and a good talk it was :)
10:58:25 <shapr> bringert: Is your paper online :-)
10:58:25 <bringert> lennart: thanks!
10:58:30 <edwardk> so was that one classified as a pearl? =)
10:58:49 <bringert> (lennart sits to chairs away from me)
10:59:14 <bringert> shapr: http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf
10:59:14 <edwardk> and right behind igloo and me
10:59:16 <lambdabot> http://tinyurl.com/poma6
10:59:29 <bringert> edwardk: nope, not a pearl
10:59:37 <bringert> those don't get in :-)
10:59:46 <bringert> eh, s/to/two/
10:59:47 <edwardk> heh
10:59:49 <edwardk> noted
10:59:55 <lennart> it has java (and c++), it could not be a pearl ;)
10:59:58 <edwardk> hehe
11:00:03 <bringert> :-)
11:00:08 <bringert> maybe a perl?
11:00:19 <lennart> heh
11:00:22 <edwardk> function perl is hard to read =)
11:00:28 <edwardk> er functional
11:00:37 <shapr> hah
11:00:46 * bringert tries to implement john hughes' suggestion
11:02:04 <astrolabe> Is anyone here familiar with a quotation, I think from before functional languages, talking about the possibility of freeing programming from the yoke of imperative languages or state or something?
11:02:32 <edwardk> I was able to talk to Alex Nanevski and Amal Amed over the break. I thank that means I've talked to just about everyone whose work my current project is based on during the course of my visit here.
11:02:36 <xerox> Like QUOTE in Scheme, astrolabe?
11:02:47 <shapr> astrolabe: Isn't that from the original FP language talk?
11:03:02 <edwardk>  think he is looking for the origin of the quite. wasn't that by Backus?
11:03:06 <shapr> I think so.
11:03:07 <astrolabe> shapr possibly
11:03:14 <edwardk> er quote
11:03:14 <astrolabe> ah backus, I think that's right
11:04:02 <astrolabe> http://www.stanford.edu/class/cs242/readings/backus.pdf
11:04:06 <lambdabot> http://tinyurl.com/easkf
11:04:08 <astrolabe> Thanks a lot all
11:04:17 <edwardk> glad to help
11:06:47 <lennart> bringert: I'd love to start using compos, but I don't want to use GADTs (I like them, but I think it's a too non-standard Haskell extension).  Is there hope for me?
11:07:07 <bringert> lennart: use a single syntactic category :-)
11:07:08 <lennart> Some encoding with type classes, perhaps?
11:07:32 <bringert> lennart: I'm playing with John's suggestion, not sure how to do it yet
11:08:00 <bringert> that still uses GADTs, but hidden in just one place
11:08:23 <glguy> dons: Could lambdabot support Control.Applicative?
11:08:25 <lennart> not good enough
11:08:31 <lisppaste2> amn pasted "example" at http://paste.lisp.org/display/26384
11:08:59 <bringert> with type classes, you probably wouldn't get nice pattern matching, but I'll think about it
11:12:25 <bringert> hmm, maybe with pattern guards
11:19:14 <kosmikus> I don't see how John's suggestion would work
11:19:52 <kosmikus> lennart: using a GADT to define a mutually recursive family of ADTs seems actually more natural to me than defining them separately, but I can see your point
11:20:28 <lennart> I love GADTs (I suggested them in 1992 after all), but I want to keep things pretty standard
11:20:55 <bringert> kosmikus: yes, I seem to have concluded the same now
11:21:07 <bringert> (re your first point)
11:21:29 <lennart> well, that's why John posed it as a question, he wasn't sure how to do it :)
11:21:42 <bringert> I'm playing with type classes now, and thinking about existentials
11:21:44 <kosmikus> lennart: there's still a chance for GADTs in Haskell' ;)
11:22:04 <lennart> existentials are ok with me
11:22:13 <lennart> everyone implements those
11:24:15 <bringert> is unsafeCoerce ok? :-)
11:24:39 <kosmikus> bringert: heh
11:24:47 <lennart> nope :)
11:24:57 <lennart> it's unsafe
11:25:06 <shapr> edwardk: Have you already heard of the Ego programming language? http://www.cs.cmu.edu/~aldrich/ego/ ?
11:25:07 <SamB> but so is unsafePerformIO!
11:25:07 <lambdabot> Title: Ego: Controlling the Power of Simplicity
11:25:28 <lennart> unsafeCoerce is unsafe in a different way
11:25:29 <SamB> lennart: I think it ought to be allowed on existentials which actually do have the type indicated
11:25:41 <shahn> Hi!
11:25:57 <shapr> Has anyone read the papers that split monads into possibility and necessity? I think that system might allow readFile to be lazy without using unsafePerformIO.
11:25:57 <shahn> sorry, is there a modulo operator for Float?
11:26:15 <SamB> shapr: how would that be safe?
11:26:55 <shapr> I think you'd get to safely do the same thing that happens now. That is, read little chunks from the file.
11:29:58 <shapr> Syzygy-: Hey, I like your OpenGL tutorials.
11:33:45 <ventonegro> @index Vertex3
11:33:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Graphics.Rendering.OpenGL.GL.VertexSpec, Graphics.Rendering.OpenGL.GL, Graphics.
11:33:46 <lambdabot> Rendering.OpenGL, Graphics.UI.GLUT
11:38:06 <edwardk> shapr: yeah
11:38:13 <edwardk> shapr: i;ve read them
11:39:41 <Limbic_Region> when you are building ghc from source (but not bootstrapping) and you get a make error unknown package <pkg name>
11:39:55 <araujo> Hi hi
11:39:55 <Limbic_Region> that is referring to the existing ghc correct?
11:39:57 <araujo> @yarr!
11:39:58 <lambdabot> I heard andersca is a pirate
11:40:06 <araujo> any news about the icfp contest?
11:40:15 <edwardk> yeah team smartass won
11:40:19 <edwardk> all google folks
11:40:21 <Igloo> Results are on the web page
11:40:37 <edwardk> they named '2d' the language from the contest as their language of choice =)
11:40:42 <xerox> There's even a video of the talk!
11:40:48 <Igloo> Limbic_Region: That depends where in teh compilation process you are
11:40:50 <xerox> (On Google Video.)
11:41:02 <SamB> edwardk: it is because they are smartasses
11:41:03 <araujo> agh
11:41:05 <Limbic_Region> very early
11:41:06 <edwardk> heh
11:41:07 <araujo> No Haskell?
11:41:08 <araujo> :-(
11:41:20 <Limbic_Region> Igloo - as in it just finished making the stage1 directories
11:41:26 <Igloo> Limbic_Region: You should be able to see which ghc is being called
11:41:33 * SamB tried to do @topic-init, but it didn't work...
11:41:34 <edwardk> no haskell. Though, I did talk to one of them and he said they wrote one of their tools in Haskell. (The theorem prover for adventure IIRC)
11:41:37 <SamB> @help topic-init
11:41:37 <lambdabot>  @topic-init #chan -- Remove the last topic item from the topic list
11:41:47 <SamB> @topic-init #haskell
11:41:52 <Limbic_Region> ok - so I was correct, it is the existing ghc
11:41:58 <edwardk> And its more or less the same team from last year (about half the same group of er... smartasses)
11:42:00 <roconnor> ?where icfpcontest-video
11:42:01 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
11:42:04 * Igloo disappears
11:42:06 <Limbic_Region> Igloo - this is bad than
11:42:32 <araujo> So, the prophecy was true
11:42:38 <edwardk> shutting down
11:46:36 <Patterner> compiling darcs with a 6.5pre version is probably not a good idea, right?
11:47:17 <dcoutts__> depends on the version of darcs you use
11:47:24 <dcoutts__> 1.0.8 doesn't build without a patch
11:47:35 <dcoutts__> I think the current dev version builds ok
11:50:02 <Limbic_Region> where do I find packages that are not part of the core and are not bundled in extra-libs ?
11:50:53 <Limbic_Region> nevermind - found it
12:28:24 <shapr> @yow !
12:28:25 <lambdabot> I'm into SOFTWARE!
12:28:30 <shapr> me too!
12:31:03 <bartw> @yar
12:31:03 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
12:31:37 <shapr> hoi bartw
12:32:55 <SamB> bartw: that was yesterday!
12:39:16 <bartw> yes, well i still like it, yar!
12:39:32 <bartw> :)
12:45:03 <bartw> ehmz, did i wtch the wrong movie or did they declare 2d the winning language with icfp ?
12:46:21 <roconnor> that is correct
12:46:37 <bartw> isn't 2d build into the challenge ?
12:46:43 <roconnor> that is correct
12:46:55 <roconnor> but you still have to program in it
12:47:14 <bartw> that is correct
12:47:21 <dolio> Someone said they just asked the winning teams which language they liked best, and declared that the winner.
12:47:30 <dolio> So google chose 2d.
12:47:35 <dolio> Or something like that.
12:47:36 <bartw> that makes sense
12:47:53 <glguy> how very diplomatic of them
12:47:57 <roconnor> they asked all teams to pick among the languages they used.
12:48:27 <bartw> this challenge did not really require teams to bring their own languages, so i guess it makes some sort of sense
12:49:06 <Igloo> Limbic_Region: What version were you compiling with, what versino were you compiling and what package wasn't found?
12:52:15 <vincenz> wait
12:52:18 <vincenz> where is this google video
12:52:50 <xerox> @where icfpcontest-video
12:52:51 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
12:53:10 <vincenz> crap
12:53:11 <vincenz> no audio
12:54:18 <vincenz> LOL
12:54:23 <vincenz> "Try our Delicious" PopCorn
12:54:30 <vincenz> Where's Wadler
13:07:00 <vincenz> BWAHA
13:07:13 <xerox> It's pretty funny :)
13:07:15 <xerox> All of it!
13:07:29 <vincenz> "Note the logarithmic scale, just to embarass python"
13:08:38 <bartw> :)
13:08:44 <bartw> i'm at that point rightnow :)
13:09:50 <vincenz> damn
13:09:54 <vincenz> I thought lazy bottoms was first in!
13:10:00 <vincenz> I was pretty sure we were first
13:10:22 <xerox> You were first in many challenges!
13:11:11 <vincenz> woo!
13:11:13 <vincenz> he mentions us
13:11:26 <vincenz> Team Lazy Bottoms!
13:11:48 <Lemmih> Neat.
13:13:28 <bartw> i really need a team for the next one
13:13:45 <vincenz> WOO
13:13:47 <vincenz> he mentions us again
13:14:13 <vincenz> "First solved by Team Lazy Bottom again, they really liked to solve the problems first"
13:14:16 <vincenz> \o/
13:19:13 <bartw> !?!?!?!
13:19:23 <bartw> i didnt know you could switch goggles
13:19:31 <vincenz> you didn't?
13:19:34 <SamB> bartw: you didn't read the note?
13:19:41 <bartw> argh, i spend hours parsing those statements
13:19:53 <SamB> well, the lisp goggles weren't much better
13:19:59 <SamB> they gave bad trees!
13:20:03 <bartw> auch
13:20:05 <vincenz> I used the MLL goggles
13:20:07 <vincenz> a few haskell commands
13:20:11 <vincenz> and the only thing I had to do was
13:20:14 <vincenz> s/::/:/
13:20:17 <vincenz> and it was pure haskell :)
13:20:22 <vincenz> I just imported it as a haskell module
13:20:29 <vincenz> Woo, Team Lazy bottoms again!
13:20:31 <bartw> argh, so where was the note with the goggles thing ?
13:20:38 <vincenz> he mentions us 3 times already \o/
13:20:39 <SamB> near the beginning
13:20:49 <bartw> owwell
13:21:04 <bartw> who else bypassed the censory engine before killing it ?
13:21:14 <SamB> I never did!
13:21:21 <SamB> I don't have enough RAM
13:21:35 <bartw> hmz
13:21:43 <SamB> it took too long to try new programs
13:22:07 <bartw> i managed to extract the text from stuf one +1 per char at a time
13:22:20 <SamB> I did make it into the museum though
13:22:36 <SamB> I suppose I might have been able to manage that, but I wouldn't have had the patience...
13:22:58 <bartw> i wasnt getting anywhere with black or plink so i went 100% on adventure
13:23:13 <SamB> what is plink again?
13:24:16 <SamB> who's um.c is that?
13:35:05 <int-e> plink = black
13:35:12 <vincenz> yep
13:36:04 <bartw> i was so happy when i finally had uploaded a nice new brain in adventure that allowed jumpig anywhere and reading censored stuff
13:36:30 <vincenz> bartw: I didn't know how to uncensor :/
13:36:32 <SamB> int-e: I thought they were the same...
13:36:45 <SamB> bartw: yours can read censored stuff?
13:36:48 * SamB wants to see!
13:36:54 * SamB never got that to work!
13:37:17 * vincenz neither
13:37:21 <int-e> I did have the right idea but didn't finish implementing it.
13:37:37 <SamB> I was working on it after the contest
13:37:42 <int-e> and somehow after the contest was over it seemed pointless :/
13:37:49 <vincenz> Team Lazy bottoms again :)
13:37:52 <int-e> So it's still unimplemented.
13:38:08 <SamB> but I got frustrated with all the swapping
13:38:14 <SamB> I only have 256 MB of RAM
13:38:23 <int-e> ow, that hurts
13:38:55 <SamB> I wrote a lint utility to save time
13:39:15 <int-e> it's slow enough without swapping
13:39:43 <SamB> I expect so
13:40:20 <SamB> I was treating it like a videogame or something ;-)
13:40:41 <SamB> except since it wasn't real-time, it didn't matter that I had a horrible framerate ;-)
13:41:00 <SamB> (except for adventure)
13:41:36 <SamB> I mean, none of the other things took so long to restart...
13:42:19 <SamB> does that thing leak, or does it just fragment memory horribly?
13:42:49 <SamB> (it doesn't seem to actually lose track of blocks, according to valgrind...)
13:43:22 <SamB> if it did, I probably would have got libgc on the job...
13:55:31 <genneth> has anyone here got a mac os x version of ghc?
13:55:42 <malcolm>  yes, on powerpc
13:56:24 * bringert has intel
13:56:30 <bringert> genneth: which are you looking for
13:57:44 <bartw> SamB: yes mine uncensorred
13:58:04 <vincenz> \o/ finished watching the presentation
13:58:57 <lispy> bringert: does it run well in tho mac intel?
13:59:24 <genneth> i'd prefer an intel-ised version
13:59:31 <bringert> lispy: yes, but it's a bit of a pain to compile ghc on os x/intel
13:59:35 <genneth> but powerpc is fine
13:59:37 <fasta> Achievement feels good :)
13:59:40 <bringert> and you need 6.5
14:00:02 <genneth> bringert: i've got about 3 weeks with nothing else to do
14:00:04 <genneth> ;)
14:00:08 <bringert> genneth: http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
14:00:11 <lambdabot> Title: X86OSXGhc - GHC - Trac, http://tinyurl.com/fnmrx
14:00:22 <genneth> cool
14:00:22 <bartw> SamB: if you want i might be able to recover the brainscript that did that
14:00:35 <SamB> bartw: "recover"?
14:00:53 <bartw> SamB: i'm hoping it is still on my usb drive, but that is at work
14:01:35 <bartw> ill send you a link tomorrow if i find it
14:01:37 <bartw> later
14:18:54 <gmh33__> anyone know much about the top teams of this years ICFP ?
14:21:10 <wilx> OMG, I just finished watching the ICFP video.
14:21:25 <malcolm> winners all from google
14:21:31 <wilx> The problem was really hard, this time.
14:21:32 <malcolm> number 2 all from tokyo
14:21:48 <malcolm> number 3 from a mixture, poland, harvard, google
14:22:03 <malcolm> judges prize went to carl witty
14:25:01 <mileswu> has anyone got any good ideas for a haskell project i could start, bearing in mind that i'm a bit of a beginner coming from an evil imperative language?
14:26:25 <sjanssen> mileswu: writing a lambdabot plugin is a popular thing to do around here
14:26:49 <mileswu> sjanssen: ok. but what kind of plugin does the lambdabot want/need?
14:27:00 <sjanssen> hmm
14:27:10 <SamB> @vixen what kind of plugin do you want?
14:27:11 <lambdabot> any kind
14:27:31 <sjanssen> there was some talk about a plugin that let's you wager karma on a bet -- that'd be cool and not too tricky
14:27:41 <SamB> hrmm,
14:27:42 <mileswu> sjanssen: ideally i'd like some practice at state monads, cos they confuse sometimes
14:27:55 <SamB> wouldn't that work better as part of the karma plugin?
14:27:56 <Cale> Puzzle solvers are nice. I'd like to see a solver (or better yet, a generator) for Nurikabe puzzles.
14:27:59 <sjanssen> also, "any kind" is a pretty good answer, we have all kinds of stuff in lambdabot
14:28:18 <SamB> its almost as if lambdabot understood the question!
14:28:24 <xerox> Cale: what about your puzzles? :)
14:28:26 <SamB> except the answer was too quick for that
14:28:31 <Cale> xerox: hehe :)
14:28:36 <sjanssen> @bf [.+]
14:28:37 <lambdabot> Done.
14:28:45 <vincenz> @bf +[.+]
14:28:46 <sjanssen> hmm, shouldn't that print something?
14:28:46 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
14:28:50 <vincenz> sjanssen: no, it starts at 0
14:28:51 <xerox> sjanssen: is that what I think it is?
14:28:55 <sjanssen> oh duh
14:29:04 * xerox groans
14:29:22 <SamB> @bf ,[.,]
14:29:23 <lambdabot> Done.
14:29:25 <SamB> hmm
14:29:28 <SamB> no input huh?
14:29:29 <vincenz> @bf +,[.,]
14:29:34 <vincenz> f
14:29:36 <vincenz> whoops
14:29:37 <sjanssen> I though input was ?
14:29:39 * vincenz coughs
14:29:39 <lambdabot> Done.
14:29:45 * vincenz peers at lambdabot 
14:29:48 <vincenz> lambdabot: done what?
14:30:01 <xerox> Done.
14:30:09 <vincenz> @bf ,>,>,>,>,>,>,>,>,.<.<.<.<.<.<.<
14:30:10 <lambdabot> Done.
14:30:19 <vincenz> heh
14:30:23 <Limbic_Region> when was the last time someone attempted to build ghc on Cygwin using bootstrap from Win32 MinGW?
14:30:29 <vincenz> @bf +[,+]
14:30:30 <lambdabot> Done.
14:30:32 <vincenz> @bf +[,+.]
14:30:33 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
14:30:40 <vincenz> it doesn't do input
14:30:42 <xerox> @bf ,.
14:30:43 <lambdabot> Done.
14:31:08 <xerox> Now @whitespace is the next?
14:31:22 <xerox> I bet edwinb would be pleased.
14:31:42 <dolio> How about @2D?
14:32:07 * genneth has a thought; this is rare
14:32:17 <genneth> does hugs have hopengl support under mac os x?
14:33:10 <xerox> No idea..
14:36:36 <mileswu> gaal:
14:36:44 <mileswu> genneth: i think so. u just use X11
14:39:10 <shapr> @yow !
14:39:11 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
14:39:11 <lambdabot> PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
14:39:18 <shapr> @users
14:39:28 <lambdabot> Maximum users seen in #haskell: 239, currently: 228 (95.4%), active: 35 (15.4%)
14:39:46 <lispy> dolio: how would you entry a @2d program though?
14:41:22 <dolio> lispy: I don't know. You'd have to do something like... @begin-2d @2d ... @end-2d and concatenate the lines.
14:42:18 <SamB> that wouldn't work too well
14:42:32 * shapr boings
14:42:35 <SamB> someone else might interrupt it
14:42:44 <shapr> Why not embed \n or something?
14:42:56 <shapr> uuencode it? =)
14:43:00 <SamB> 'tis worse!
14:43:07 <shapr> Let us just observe that the IRC protocol sucks butt.
14:43:15 <shapr> And then we can all switch to XMPP aka Jabber.
14:43:16 <kowey> could use a graphviz style syntax?
14:43:25 <SamB> heh
14:43:46 <shapr> Whatever happened to the jabber binding for Haskell?
14:43:47 <SamB> I suppose lambdabot could format it and then run the program, eh?
14:44:52 <shapr> One of the Dmitrys was doing Jabber right? Golubvsky?
14:45:57 <fasta> shapr: I don't care where #haskell is, as long as there is quality software to access it, and it doesn't take more than 5 minutes to set it up.
14:46:01 <dcoutts__> we nearly had a SOC project on it
14:46:12 <shapr> fasta: I can assure you, that will always be the case.
14:46:15 <bringert> does anyone want to add an --xml flag for lambdabot, which allows plugins that support it to output XML
14:46:18 <lispy> shapr: i'm not sure, but it looks like lambdabot still supports jabber...or else the code has just bit rotted
14:46:32 <shapr> er, still supports? It's had jabber support for some time/
14:46:35 <lispy> bringert: i think that sounds like a good idea :)
14:46:37 <shapr> yeesh, I am *so* out of touch.
14:46:41 <bringert> e.g. haskell code with marked spans for highlighting, urls as hyperlinks etc.
14:46:46 <bringert> lispy: :-)
14:47:30 <bringert> lispy: can you send me your current patches for lambdaweb?
14:47:51 <bringert> or put your own repo online somewhere where I can pull from
14:48:03 <bringert> I want to hack the examples etc.
14:48:04 <lispy> bringert: um...*blush* lambdaweb.html is not under version control the way i edited it currently :)
14:48:24 <lispy> bringert: BUT, you could just download the file and put it in the repo
14:48:37 <bringert> lispy: so your only changes are in lambdaweb.html?
14:48:39 <bringert> will do
14:48:49 <lispy> yeah, i got lazy and just hacked it in place
14:49:05 <lispy> i need to setup symlinks to use a version that is in a darcs repo
14:49:33 <lispy> well, i guess i could write an install script too
14:49:39 <lispy> like a one liner
14:49:54 <lispy> use a posthook to call the script
14:50:03 <lispy> and then auotmatically install each new version
14:50:37 <shapr> lambdabot is poised on the precipice of becoming an IDE
14:50:45 <bringert> lispy: sounds good
14:51:19 <lispy> bringert: do you recommend any books or websites for learning CSS+javascript?  I know i can google, but quality varies so much...
14:51:42 <lispy> or maybe we have combinators to write them for us?
14:51:58 <shapr> What about HSP.ClientSide?
14:52:00 <lispy> or maybe something like google web tool kit...except in Haskell
14:52:07 <bringert> lispy: javascript + DOM I don't know, I'm just using the W3C DOM spec, and the ECMAScript standard once in a while
14:52:39 <lispy> shapr: i'll look at it
14:52:41 <bringert> for CSS, I recently bought "Designing with Web Standards", but I havn't finished it yet, didn't bring it to icfp
14:52:42 <lispy> bringert: okay
14:52:59 * lispy makes a note
14:53:13 <lispy> i heard about one...Zen of something...do you think that one is good?
14:54:07 <dolio> CSS Zen Garden?
14:54:19 <bringert> lispy: I haven't read the book, but CSSZen Garden is nice
14:54:25 <bringert> @google css zen garden
14:54:28 <lambdabot> http://www.csszengarden.com/
14:54:28 <lambdabot> Title: css Zen Garden: The Beauty in CSS Design
14:55:00 <bringert> lispy: I mostly use the W3C specs for xhtml and css too
14:55:22 <lispy> good to know
14:55:47 <lispy> i haven't really sat down and tried to learn any of this 'web' stuff since about 1999
14:55:52 <lispy> and back then it was all broken...
14:56:05 <lispy> you did every thing the hacky way and it was annoying
14:56:20 <bringert> yeah
14:56:22 <lispy> i think that's part of why i stayed away from it after then :)
14:56:36 <bringert> today I feel that I can do most of what I want with standards
14:56:41 <lispy> HSPClientSide is interesting, but i don't think it will help us much
14:56:55 <shapr> bringert: Except that Flash > SVG still
14:57:21 <bringert> shapr: right, I'm not that advanced
14:57:37 <shapr> I can only hope that Moz 2 will change that.
14:57:38 <lispy> maybe i shouldn't say that...HSP could probably help quite a bit if we actually tried to build an editor in a webpage...but i'm not sure
14:58:01 <lispy> on the other hand, that would probably require lots of javascript
14:58:06 <bringert> with HSPClientSide you still pretty much need to know javascript, right?
14:58:16 <shapr> I think so.
14:58:25 <lispy> i think so, i think it just makes it easier to get data from the server
14:58:38 <shapr> lispy: Hey, it was nice to meet you in person!
14:58:42 <lispy> you can weave server side computations into your html right?
14:58:45 <lispy> shapr: yeah
14:58:52 <lispy> shapr: i'm so glad to meet everyone in person
14:58:56 <lispy> it was really cool
14:59:01 <shapr> I agree, I had a lot of fun.
14:59:07 <lispy> i feel like i'm much more a part of the community
14:59:18 <lispy> everyone is real! ;)
14:59:24 <shapr> I think you become an official part of the community when you contribute to lambdabot =)
14:59:30 <lispy> hehe
14:59:37 <lispy> ?quote dons
14:59:38 <lambdabot>  <xerox> Those youngsters with their djinn tools... <dons> back in xerox's day, he'd walk barefoot 10 kms to school in the snow to learn about pointfree style. the kids these days are spoilt rotten
14:59:38 <lambdabot> with their lambda-whatsits and djinn-amyjiggs
14:59:47 * shapr laughs
14:59:48 <ihope> Is Haskell good for writing paravitualization software? I'm guessing not.
14:59:54 <lispy> i wonder how many times i'd have to quote dons to get the quote i want...
14:59:56 <shapr> ihope: Why not?
14:59:59 <xerox> hehe
15:00:09 <SamB> @quote dons
15:00:09 <lambdabot>  ihope reaches level 4 hacker
15:00:12 <SamB> @quote dons
15:00:12 <lambdabot>  boegel, stop polluting the quote-space please
15:00:19 <SamB> @quote dons
15:00:19 <lambdabot>  boegel, stop polluting the quote-space please
15:00:22 <shapr> @quote dons
15:00:23 <lambdabot>  I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
15:00:30 <lispy> @quote dons
15:00:31 <lambdabot>  note to self: grep only works on disks
15:00:35 <shapr> @quote dons
15:00:35 <lambdabot>  Haskell: The language that never sells out!
15:00:41 <lispy> @quote dons
15:00:42 <lambdabot>  so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses since most people don't understand bug theory ;)
15:00:44 <shapr> @users
15:00:45 * SamB wonders what dons tried to grep
15:00:45 <lambdabot> Maximum users seen in #haskell: 239, currently: 226 (94.6%), active: 33 (14.6%)
15:00:46 <lispy> @quote dons
15:00:46 <lambdabot>  boegel, stop polluting the quote-space please
15:00:55 * lispy tries to find the quuote in /msg
15:00:57 <shapr> @quote SyntaxNinja
15:00:58 <lambdabot>  You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean I'll keep doing
15:00:58 <lambdabot> what I'm doing." ;)
15:01:05 <shapr> @quote SyntaxNinja
15:01:06 <lambdabot>  I think that the compiler authors will fly here from England just to kill me if I did that
15:01:18 <ihope> shapr: can you set up traps and things with Haskell?
15:01:35 <ihope> Or does that require C or (gasp!) assembler?
15:01:49 <SamB> ihope: I hear largo is liking to use cardboard boxes...
15:02:08 <shapr> You just want to replace a particular call with something else, yeah?
15:02:20 <ihope> shapr: something like that, maybe.
15:02:41 <shapr> That doesn't sound hard to do in any language.
15:02:52 <lispy> lambdabot seems to have forgotten the quote i awnt
15:03:03 <ihope> Running through the machine code and replacing everything with something else, you mean?
15:03:08 <SamB> @google lambdabot quotes
15:03:10 <lambdabot> http://haskell.org/hawiki/MegaMonad
15:03:10 <lambdabot> Title: MegaMonad - The Haskell Wiki
15:03:22 <SamB> @google url:dons lambdabot quotes
15:03:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/_darcs/inventory
15:03:46 <SamB> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
15:03:48 <lambdabot> http://tinyurl.com/ep55a
15:04:00 <lispy> shapr: the first time i got lambdabot running in cgi: 20:40:27 <dons> note down this date, people, 13-09-2006. today lambdabot == skynet
15:04:19 <shapr> ihope: Isn't that pretty much a trap? The address is more like a symbolic name, yeah?
15:04:42 <SamB> @remember dons note down this date, people, 13-09-2006. today lambdabot == skynet
15:04:53 <shapr> lispy: That's a good quote.
15:05:04 <ihope> shapr: ...what?
15:05:07 <qz> ihope, i think you dont have lots of options for your task :)
15:05:13 <qz> C and assembly and that's about it
15:05:35 <ihope> Isn't x86 at least semi-hard to paravirtualize anyway?
15:05:52 <SamB> paravirtualize?
15:06:04 * shapr suspects he is totally lost anyway...
15:06:10 <ihope> Like virtualization, but requiring stuff in a different format.
15:06:31 <SamB> ???
15:06:32 <shapr> hiya kwertii, do you know tvorakk?
15:06:33 <ihope> I.e. you can't use paravirtualization to boot from a disk and expect it to work.
15:06:34 <qz> like virtualization, but requires os patched to work on hypervisor
15:06:39 <lispy> ihope: are you paraexplaining it right now? ;)
15:06:47 <qz> lispy, lol
15:06:49 * shapr is metachuting out of this discussion
15:06:50 <SamB> lispy: I think so!
15:06:57 <ihope> I'm paraexplaining virtualization.
15:07:15 <qz> ihope, are you developing hypervisor or making certain os to work on it?
15:07:21 * SamB metaphrases shapr
15:07:35 <newsham> so no strong haskell showing in icfp contest?
15:07:35 * shapr parasploits SamB 
15:07:39 <xerox> @quote adept
15:07:39 <lambdabot>  I think I need cobrain to understand coeffects
15:07:49 <xerox> About paraexplaining...
15:08:02 <ihope> qz: planning on developing one.
15:08:06 <SamB> what does adept call himself now?
15:08:10 <lispy> newsham: haskell is old hat, i think this year people wanted to try something less main stream, like asm ;)
15:08:12 <xerox> @quote adept
15:08:12 <lambdabot>  I think I need cobrain to understand coeffects
15:08:14 <xerox> @quote adept
15:08:15 <lambdabot>  I think I need cobrain to understand coeffects
15:08:17 <qz> ihope, then C and assembly. rest is too high for that :|
15:08:19 <xerox> Ufff there's a better one.
15:08:21 <SamB> it has a strange mix of caps and lowercase...
15:08:33 <xerox> ADEpt?
15:08:36 <ihope> I more-or-less have to use some degree of compilation and stuff to do any virtualization on the x86, right?
15:08:45 <ihope> @quote ihope
15:08:45 <lambdabot>  Oops, I forgot that Djinn doesn't do GADT's.
15:08:51 <SamB> xerox: probably
15:08:58 <xerox> <lambdabot>  Tried to co-read and co-understand comonads, but got co-re dump
15:09:00 <SamB> ihope: hahaha
15:09:00 <xerox> That's the one.
15:09:18 <qz> ihope, huh? if you mean that certain instructions on x86 are not easily virtualizeable, you are right
15:09:36 <SamB> qz: which ones/
15:09:37 <newsham> ring -1
15:09:39 <SamB> er, which ones?
15:09:43 <Cale> The @quote module should keep track of how many times it's used each quote, and pick one at random from those with a minimal count.
15:09:44 <qz> SamB, sidt for example
15:09:59 <newsham> see also: pacifica, vanderpool
15:10:29 <ihope> http://www.usenix.org/events/sec2000/full_papers/robin/robin_html/index.html <- big long paper explaining it
15:10:32 <SamB> qz: hmm
15:10:33 <lispy> Cale: or cycle instead of random?
15:10:34 <lambdabot> Title: 9th USENIX Security Symposium Paper, http://tinyurl.com/j3lpj
15:10:48 <shapr> ihope: I think I was just being clueless about traps.
15:10:57 <qz> SamB, also sgdt (ofcourse), smsw, lsl, lar.. :|
15:11:00 <qz> there's dozen
15:11:07 <SamB> lsl?
15:11:11 <SamB> isn't that one easy?
15:11:12 * qz sighs
15:11:15 <SamB> you just use an lsl!
15:11:23 <Cale> lispy: that would work too. My way just makes it produce the concatenation of random permutations of the list.
15:11:25 <ihope> http://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements <- Wikipedia, with a nice little list
15:11:28 <lambdabot> http://tinyurl.com/gzpgc
15:11:41 <SamB> qz: I suppose you meant to virtualize it on something else?
15:11:45 <ihope> lambdabot: sheesh, those links were pretty much of the same length.
15:11:59 <xerox> Cale yeah! And when all the quotes are reaching n, with the minimum being m < n, set m = n - m, ever other k to n - k, and n = 0.
15:12:04 <SamB> oh, wait.
15:12:07 * SamB is mixed up
15:12:11 <qz> no
15:12:20 <newsham> all mixed up and nowhere to go
15:12:27 <SamB> qz: what sort of virtualization did you have in mind?
15:12:38 <qz> SamB, what sorts of virtualizations do you know? ;)
15:12:54 <Cale> xerox: actually, you could flag each quote with a boolean, and reset all the flags to false when there were none left
15:13:06 <xerox> Cale: you always beat me.
15:13:14 <SamB> that does sound tricky to do from usermode...
15:13:58 <xerox> Cale: you should also do it, it's very nice :)
15:14:16 <ihope> What sounds tricky to do from user mode?
15:14:17 <qz> SamB, problem with those instructions is that they do not trigger exception when called from r3, yet can expose unwanted stuff to target OS
15:14:25 <bringert> yay, ChilliX pushed the FC stuff to HEAD
15:14:39 * bringert gets conflicts ...
15:14:44 <lispy> heh
15:14:51 <lispy> of course you get conflicts :)
15:15:52 <SyntaxNinja> audreyt: alive?
15:16:07 <audreyt> no, undead
15:16:07 <newsham> if only someone would make cpu extensions to support hardware virtualization
15:16:18 * audreyt just woke up and feels rather reanimated
15:16:18 <pianodogg> newsham: ha ha
15:16:20 <qz> newsham, intel and amd did
15:16:21 <ihope> newsham: I thought somebody had done that.
15:16:30 <SyntaxNinja> hello audreyt
15:16:38 <SyntaxNinja> audreyt: not at ICFP/CUFP this year?
15:16:55 <audreyt> no, my travel budget is lomited and I was invited to OOPSLA/DLS
15:16:58 <qz> newsham, IVT and AMD-V are there. sadly, they are not compartible.
15:16:59 <audreyt> limited, even
15:17:12 <audreyt> sad to miss the Hackathon though :/
15:17:17 <SyntaxNinja> audreyt: how do you put together your takahashi slides? do you have software for it, or ppt, or what?
15:17:22 <SyntaxNinja> yeah, the hackathon was fun
15:18:09 <audreyt> the software is simple... see http://svn.jifty.org/svn/jifty.org/jifty/trunk/doc/talks/
15:18:12 <SyntaxNinja> btw, audreyt, here's a blog entry from a blog I read on this topic: http://presentationzen.blogs.com/presentationzen/2005/09/one_presenters_.html
15:18:13 <lambdabot> Title: Revision 1989: /jifty/trunk/doc/talks, http://tinyurl.com/qtzkq
15:18:14 <lambdabot> http://tinyurl.com/mfm7l
15:18:18 <audreyt> get the .css, and .js
15:18:25 <audreyt> and http://svn.jifty.org/svn/jifty.org/jifty/trunk/doc/talks/oscon-europe.2006.xul
15:18:27 <lambdabot> http://tinyurl.com/my2q4
15:18:44 <audreyt> and then modify xul as needed. it's very simple syntax.
15:21:42 <perspectival> and it's made by Sunbeam?
15:21:43 <perspectival> never heard of it ;-)
15:22:45 <SyntaxNinja> audreyt: cool. thanks
15:23:07 * SyntaxNinja wonders if he should wait for the monad combinator version
15:23:27 <dcoutts__> I'm pleased to announce zlib and bzlib bindings: http://haskell.org/~duncan/zlib and http://haskell.org/~duncan/bzlib
15:23:29 <lambdabot> Title: Index of /~duncan/zlib
15:23:40 <dcoutts__> use darcs get
15:23:45 <lispy> dcoutts__: is that part of bytestring or standalone?
15:23:51 <dcoutts__> standalone
15:23:56 <dcoutts__> using lazy bytestring
15:24:12 <dcoutts__> if you're using ghc-6.5 you need to edit the .cabal file to remove the fps dependency
15:24:15 <lispy> dcoutts__: but you plan to use bytstring right? is that in memory compression or just transparently from a file?
15:24:28 <SyntaxNinja> dcoutts: cool. is this what xerox was planning to use for cabal-get?]
15:24:41 <dcoutts__> lispy: (de)compress :: ByteString -> ByteString
15:24:47 <dcoutts__> SyntaxNinja: lets ask him
15:24:55 <lispy> dcoutts__: okay, nice
15:24:58 <shapr> hiya SyntaxNinja!
15:25:10 <dcoutts__> lispy: so can be in memory or easily done to/from disk
15:25:20 <SyntaxNinja> y0 shapr
15:26:11 <SyntaxNinja> ICFP is over!
15:26:20 <bringert> do you guys also get make: *** No rule to make target `types/Kind.lhs', needed by `stage1/types/Kind.o'.  Stop.
15:26:25 <bringert> with new HEAD
15:26:32 <malcolm> SyntaxNinja: yes, just a minute or two ago
15:26:36 <bringert> SyntaxNinja: party tonight?
15:26:59 <malcolm> name the place and time
15:27:18 * bringert looks around
15:27:33 <audreyt> dcoutts__: what do you think about a version that bundles zlib?
15:27:36 <malcolm> they are clearing this room pretty quick
15:27:37 <audreyt> and/or bzlib
15:27:48 <dcoutts__> audreyt: for systems without zlib?
15:27:50 <audreyt> for win32 folks, that is
15:27:52 <audreyt> and aix
15:27:56 <dcoutts__> ah
15:27:59 <dcoutts__> could do
15:27:59 <audreyt> which is my two main haskell deploymenet platform
15:28:00 <audreyt> :)
15:28:12 <dcoutts__> I don't know how easy it'd be to build
15:28:26 <dcoutts__> you can get zlib.dll easily for windows of course
15:28:36 * malcolm thinks he'd better move before he gets picked up and taken to a store cupboard
15:28:37 <hitodama> how can I change a char into a number?
15:28:44 <audreyt> dcoutts__: but you need .h too no?
15:28:52 <dcoutts__> audreyt: no
15:28:53 <lispy> hitodama: try hoogle!
15:28:54 <audreyt> or is it using dlopen?
15:29:01 <lispy> ?hoogle Char -> Int
15:29:02 <lambdabot> Char.digitToInt :: Char -> Int
15:29:02 <lambdabot> Char.ord :: Char -> Int
15:29:15 <hitodama> wow, cool
15:29:20 <dcoutts__> audreyt: it links using the standard method
15:29:29 <SyntaxNinja> they're kicking us out
15:29:33 <lispy> > ord 'a'
15:29:34 <SyntaxNinja> gotta go
15:29:34 <lambdabot>  97
15:29:35 <SyntaxNinja> l8r
15:29:40 <lispy> > digitToInt '1'
15:29:40 <audreyt> I see a #include <zlib.h>
15:29:41 <lambdabot>  1
15:29:45 <audreyt> in Stream.hsc
15:29:51 <dcoutts__> audreyt: I don't know if that needs a .lib file on win32, I thought you could link with just the .dll
15:29:55 <audreyt> which seems tome implies that zlib.h needs to be present
15:29:57 <dcoutts__> audreyt: that's to build it, yes
15:30:03 <audreyt> *nod*
15:30:11 <audreyt> *ponder*
15:30:25 <bringert> ChilliX says to make depend etc again
15:34:08 <dcoutts__> audreyt: sorry I was confusing, my point was that zlib.h isn't needed by clients of the binding but to build it from source it needs it.
15:34:27 <dcoutts__> so a binary version of the binding only needs to come with the zlib.dll, not the .h
15:34:56 <audreyt> *nod*
15:35:20 <Limbic_Region> audreyt - do you happen to know where I could get my hands on a cygwin ghc binary?
15:35:33 <Limbic_Region> and you are either up awfully late or awfully early
15:35:56 <audreyt> early
15:35:58 <Limbic_Region> turns out I *apparently* can't cross compile cygwin32 using mingw32
15:36:09 <audreyt> latest build is 6.0
15:36:12 <audreyt> http://loreley.ath.cx/cygwin/haskell/ghc/
15:36:15 <audreyt> 6.0.1, even.
15:36:15 <lambdabot> Title: Index of /cygwin/haskell/ghc
15:36:19 <audreyt> 6.2 no longer builds
15:36:24 <audreyt> have fun :)
15:36:28 <Limbic_Region> oh, I misunderstood then
15:36:52 <Limbic_Region> I was happy to cross compile
15:37:03 <Limbic_Region> but mingw32 will not allow the unix package to be installed
15:37:22 <audreyt> k
15:38:01 <matthew-> hi there. can anyone help me out with hdbc, haskelldb, postgresql and the fun of timestamps?
15:38:28 <lispy> i'm using hdbc with MS access...but maybe i can help
15:38:34 <Limbic_Region> audreyt - I signed up to the ghc dev mailing list and asked for pointers though (there is an open ticket asking for cygwin binaries)
15:38:43 <lispy> matthew-: what seems to be the problem?
15:38:51 <matthew-> Wiki.fcgi: fromSql: Cannot read "2006-09-20 21:33:50.423023+01" as Integer.
15:39:11 <audreyt> Limbic_Region: cool! may the pointers be stable and not null :)
15:39:33 <matthew-> that is the problem. and from googleing, it looks like haskelldb wants dates in one format and hdbc wants dates in another format
15:40:29 <lispy> hmm..
15:40:52 <lispy> matthew-: how did you get your .fcgi to log anything...I can't seem to get that working on my system :)
15:41:06 <lispy> matthew-: what fastcgi implementation and webserver do you use?
15:41:10 <matthew-> heh, unknown. It just blows up in apache error log
15:41:20 <matthew-> fastcgi mod, apach2
15:41:37 <lispy> hmm..i'm using mod_fcgid maybe that's the problem
15:41:53 <lispy> matthew-: as for your problem i'm not sure...that's certainly not an integer
15:42:06 <matthew-> indeed. that's the string that's coming out of postgres
15:42:09 <lispy> matthew-: that value looks like it was from a datetime field
15:42:13 <matthew-> yes
15:43:00 <lispy> do you know which layer is failing?  is it hdbc that throws an error or haskelldb?  oh, maybe you could wrap something in Control.Exception.catch?
15:43:06 <hitodama> is there anything like cond from lisp in haskell, instead of using nested if-thens?
15:43:16 <lispy> hitodama: case foo of
15:43:58 <SamB> lispy: you left out the guards
15:43:59 <lispy> > let foo n = case n of {1 -> "one"; 2 -> "two"; 3 -> "three"} in map foo [1..3]
15:44:01 <lambdabot>  ["one","two","three"]
15:44:10 <matthew-> lispy: fromsql is defined in hdbc
15:44:37 <Limbic_Region> audreyt - well, I don't mind failing but I would hate to think that the only reason why there isn't a cygwin build is because no one is willing to beat themselves about the head
15:44:52 <lispy> hitodama: note that i only needed the {} and ; because i wanted it all on one line
15:44:53 <Limbic_Region> I for some reason like inflicting pain upon myself
15:44:55 <SamB> lispy: not case, cond!
15:45:05 <lispy> Oh
15:45:08 * lispy slaps self
15:45:30 <lispy> hitodama: SamB is right, i'm thinking of pattern matching not cond...
15:46:04 <SamB> hitodama: if you paste your code we can give you some pointers ;-)
15:46:09 <lispy> foo n | n > 4 = ...; | n == 0 = ...
15:46:23 <lispy> but usually you start a newline when you place the |
15:46:31 <lispy> foo n
15:46:36 <lispy>   | n > 4 = ..
15:46:40 <matthew-> lispy: yup, it's hdbc that's throwing the error
15:46:47 <hitodama> ahh
15:46:50 <hitodama> okay, I'll try that
15:47:28 <lispy> matthew-: okay, then maybe we just have a wrong type somewhere...me goes to stare at some hdbc code
15:48:53 <hitodama> I want to write code that has a constant number picked out  and it checks if you are above, below, or equal to that number
15:49:00 <audreyt> Limbic_Region: *applaud*
15:49:34 <matthew-> lispy: oh, wait, in haskelldb/hdbc/Database/HDBC/Types.hs: read' :: (Typeable a,Read a) => String -> a
15:49:37 <matthew->                   _ -> error $ "fromSql: Cannot read " ++ show s
15:50:00 <matthew-> so that's the hdbc backend for haskelldb right?
15:50:05 <lispy> looks like
15:50:47 <matthew-> hah! I beg to differ with the comment above the function:
15:50:47 <matthew-> -- | Read a value from a string, and give an informative message
15:50:47 <matthew-> --   if it fails.
15:51:02 <lispy> heh
15:51:05 <hitodama> I can only put in IO related commands into a do sequence right?
15:51:16 <lispy> matthew-: i can't use haskellDB so i defined this in my code
15:51:17 <lispy> -- | Converts rows from the database into haskell types
15:51:18 <lispy> convert :: (Monad m, HDBC.SqlType a) => m [[HDBC.SqlValue]] -> m [[a]]
15:51:19 <lispy> convert xs = xs >>= return . (map (map HDBC.fromSql))
15:51:30 <hitodama> I start out with "do putStr "Enter Number
15:51:40 <hitodama> "
15:51:45 <int-e> matthew-: informative and useful aren't quite the same :)
15:51:55 <hitodama> then s <- getline
15:52:11 <hitodama> let's say this code is under a function called input
15:52:11 <lispy> ?pl \xs -> xs >>= return . (map (map fromSql))
15:52:12 <lambdabot> (map (map fromSql) `fmap`)
15:52:17 <matthew-> int-e: sure, I guess the message has /some/ information content!
15:52:21 <lispy> oh...that is nice
15:52:32 <hitodama> how would I call input from another function to do the checks on entered value?
15:52:40 <hitodama> or can I just start putting if and thens under the do?
15:52:48 <SamB> matthew-: what does it say? "something bad happened!"?
15:53:01 <matthew-> Wiki.fcgi: fromSql: Cannot read "2006-09-20 21:33:50.423023+01" as Integer.
15:53:19 <matthew-> is what it says
15:55:02 <lispy> matthew-: i think something is up with your haskelldb specification
15:55:24 <matthew-> I've checked what DBDirect did, it looks fine to me
15:55:34 <matthew-> the column is marked as CalendarTime
15:55:38 <lispy> it's expecting datetime in that column?
15:55:40 <lispy> hmm...
15:56:02 <matthew-> ahh, from some document:
15:56:04 <matthew-> The default representation of time values is an integer number of seconds.
15:56:15 <matthew-> Databases such as PostgreSQL with builtin timestamp types can will see
15:56:16 <matthew-> automatic conversion between these Haskell types to local types.  Other
15:56:16 <matthew-> databases can just use an int or a string.
15:56:40 <matthew-> mmm. it's got upset somewhere...
15:57:44 <matthew-> I wonder if I try to convert it to a string first, and then reparse it out...
16:02:53 <dibblego> unzip            =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) -- what does the ~ mean exactly?
16:03:12 <xerox> dibblego: lazy pattern match.
16:03:43 <dibblego> is there a document explaining what that means?
16:04:21 <xerox> It's just what you espect.  Pattern match is not lazy in functions definitions and case statements, because the system has to go through the various cases to pick the one to run.
16:04:40 <dibblego> so what happens in the lazy case?
16:04:47 <xerox> Late binding.
16:04:57 <xerox> I mean, it's lazy :)
16:05:48 <kpreid> > (\(a, b) -> False) undefined
16:05:49 <lambdabot>  Undefined
16:05:55 <kpreid> > (\~(a, b) -> False) undefined
16:05:56 <lambdabot>  Parse error
16:06:05 <kpreid> > (\(~(a, b)) -> False) undefined
16:06:07 <lambdabot>  False
16:06:16 <xerox> (Or just a whitespace.)
16:06:23 <dibblego> http://www.haskell.org/tutorial/patterns.html#tut-lazy-patterns I found that
16:06:25 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns, http://tinyurl.com/m752j
16:06:58 <kpreid> lazy patterns are a bit like fromJust: "proceed and don't bother checking"
16:07:07 <kpreid> (well, that's not really true)
16:07:36 <kpreid> (\ ~(Just a) -> [a]) == (\a -> [fromJust a])
16:09:09 <astrolabe> So  why do you need a lazy match in that unzip definition?
16:09:46 <dibblego> I don't - I found it somewhere I think
16:10:07 <astrolabe> I don't mean you dibblego :)
16:10:09 <kpreid> I think it's because the foldr would be stricter if it wasn't there
16:10:14 <xerox> astrolabe: to make it lazy?
16:10:59 <kpreid> > let unzip =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) in take 10 $ unzip $ repeat (1,2)
16:10:59 <lambdabot>  Couldn't match `[a]' against `([a1], [a2])'
16:11:46 <kpreid> @type foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
16:11:47 <lambdabot> forall a a1. [(a, a1)] -> ([a], [a1])
16:12:07 <kpreid> @type repeat
16:12:08 <lambdabot> forall a. a -> [a]
16:12:22 <astrolabe> odd
16:12:43 <astrolabe> @type unzip $ repeat (1,2)
16:12:45 <lambdabot> forall a b. (Num a, Num b) => ([a], [b])
16:12:59 <kpreid> oh
16:13:00 <astrolabe> ah
16:13:03 <astrolabe> heh
16:13:35 <kpreid> > let unzip =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) in (\(as,bs) -> (take 10 as, take 10 bs)) $ unzip $ repeat (1,2)
16:13:36 <lambdabot>  ([1,1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2,2])
16:13:55 <kpreid> > let unzip =  foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) in (\(as,bs) -> (take 10 as, take 10 bs)) $ unzip $ repeat (1,2)
16:13:56 <lambdabot>  Exception: stack overflow
16:14:02 <kpreid> there
16:14:04 <lispy> > zipWith (+) $ unzip $ repeat (1,2)
16:14:05 <lambdabot>  Couldn't match `[b]' against `([a], [b1])'
16:14:08 <astrolabe> I think I get it
16:14:47 <astrolabe> It seems to be easy to confuse lists of pairs and pairs of lists
16:14:57 <kpreid> astrolabe: if the (as,bs) isn't lazy, then it's required to check that every later unzip-of-tail of the list does yield a tuple
16:14:59 <lispy> right
16:15:14 <astrolabe> kpreid: thanks
16:15:18 <lispy> wel, right to astrolabe
16:15:23 <lispy> kpreid: interesting...
16:16:00 <lispy> > zipWith (+) $ uncurry $ unzip $ repeat (1,2)
16:16:01 <lambdabot>  Couldn't match `a -> b -> c' against `([a1], [b1])'
16:16:04 <kpreid> instance GeneralTake ([a],[b]) where gtake n (xs,ys) = (gtake n xs,gtake n ys) -- :-)
16:16:44 <lispy> ?type uncurry $ zipWith (+)
16:16:45 <lambdabot> forall b. (Num b) => ([b], [b]) -> [b]
16:17:01 <lispy> > uncurry $ zipWith (+) $ unzip $ repeat (1,2)
16:17:02 <lambdabot>  Couldn't match `[b]' against `([a], [b1])'
16:17:05 <lispy> bleh
16:17:11 * lispy stops spamming everyone :)
16:17:33 <Cale> @type zip
16:17:34 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
16:17:42 <Cale> @type curry zip
16:17:43 <lambdabot>   Couldn't match `[a]' against `(a1, b)'
16:17:44 <lambdabot>    Expected type: (a1, b) -> c
16:17:52 <Cale> @type uncurry zip
16:17:54 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
16:17:57 <Cale> rather
16:18:12 <Cale> there's the function for your confusion :)
16:19:09 <Cale> @type unzip
16:19:11 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
16:20:07 <kpreid> @pl foldr (:) []
16:20:08 <lambdabot> foldr (:) []
16:21:06 <Cale> @check \(xs :: [(Int, Int)]) -> (unzip . uncurry zip) xs == xs
16:21:06 <lambdabot>  Parse error in pattern
16:21:18 <Cale> @check \xs -> (unzip . uncurry zip) xs == (xs :: [(Int, Int)])
16:21:19 <lambdabot>  Couldn't match `[(Int, Int)]' against `([a], [b])'
16:21:24 <Cale> er :)
16:21:41 <Cale> @check \xs -> (uncurry zip . unzip) xs == (xs :: [(Int, Int)])
16:21:42 <lambdabot>  OK, passed 500 tests.
16:22:20 <Cale> however,
16:22:33 <Cale> @check \xs -> (unzip . uncurry zip) xs == (xs :: ([Int], [Int]))
16:22:34 <lambdabot>  Falsifiable, after 1 tests: ([],[2,1])
16:22:46 <Cale> @scheck \xs -> (unzip . uncurry zip) xs == (xs :: ([Int], [Int]))
16:22:47 <lambdabot>   Failed test no. 2. Test values follow.: ([],[-1])
16:23:52 <Cale> @scheck \x -> x == (100 :: Int)
16:23:53 <lambdabot>   Failed test no. 1. Test values follow.: -1
16:23:57 <Cale> @scheck \x -> x == (-1 :: Int)
16:23:58 <lambdabot>   Failed test no. 2. Test values follow.: 0
16:24:08 <kpreid> @help scheck
16:24:09 <lambdabot> scheck <expr>
16:24:09 <lambdabot> You have SmallCheck and 3 seconds. Test something.
16:24:11 <Cale> @scheck \x -> x `elem` [-1 :: Int, 0]
16:24:12 <lambdabot>   Failed test no. 3. Test values follow.: 1
16:24:16 <Cale> @scheck \x -> x `elem` [-1 :: Int, 0, 1]
16:24:17 <lambdabot>   Failed test no. 4. Test values follow.: 2
16:24:18 <ihope> @help check
16:24:18 <lambdabot> check <expr>
16:24:18 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
16:24:19 <Cale> @scheck \x -> x `elem` [-1 :: Int, 0, 1,2]
16:24:20 <lambdabot>   Failed test no. 5. Test values follow.: 3
16:24:37 <ihope> @check \x -> x `elem` [-1 :: Int, 0, 1,2]
16:24:38 <lambdabot>  Falsifiable, after 1 tests: -3
16:24:44 <Cale> heh, shouldn't it say "Test" as well?
16:24:56 <ihope> @check \x -> x `elem` [-300..300]
16:24:57 <lambdabot>  Add a type signature
16:25:08 <ihope> @check \x -> x `elem` [-300..300 :: Int]
16:25:10 <lambdabot>  OK, passed 500 tests.
16:25:16 <Cale> haha
16:25:18 <ihope> That's nice.
16:25:22 <Cale> @check \x -> x `elem` [-300..300 :: Int]
16:25:23 <lambdabot>  OK, passed 500 tests.
16:25:24 <Cale> @check \x -> x `elem` [-300..300 :: Int]
16:25:25 <lambdabot>  OK, passed 500 tests.
16:25:28 <Cale> wow
16:25:30 <Cale> @check \x -> x `elem` [-300..300 :: Int]
16:25:31 <ihope> Stupid bot.
16:25:31 <lambdabot>  OK, passed 500 tests.
16:25:32 <Cale> @check \x -> x `elem` [-300..300 :: Int]
16:25:33 <lambdabot>  OK, passed 500 tests.
16:25:36 <Cale> @check \x -> x `elem` [-100..100 :: Int]
16:25:37 <lambdabot>  Falsifiable, after 239 tests: -103
16:25:46 <ihope> @scheck \x -> x `elem` [-100..100 :: Int]
16:25:47 <lambdabot>  Completed 10 test(s) without failure.
16:25:48 <lispy> @scheck \x -> x `elem` [-10..10 :: Int]
16:25:49 <lambdabot>  Completed 10 test(s) without failure.
16:25:56 <ihope> Ten?
16:25:56 <lispy> @check \x -> x `elem` [-10..10 :: Int]
16:25:58 <lambdabot>  Falsifiable, after 43 tests: -11
16:25:58 <Cale> only 10?
16:26:08 <lispy> @scheck \x -> x `elem` [-10..10 :: Int]
16:26:09 <lambdabot>  Completed 10 test(s) without failure.
16:26:13 <lispy> hmm...
16:26:14 <matthew-> lispy: well I made it work. I made hdbc/haskelldb return the timestamp as a string and then parsed it with system.time.parse.parsecalendartime; but it's not really an ideal solution...
16:26:20 <Cale> @check \x -> x `elem` [-100..100 :: Integer]
16:26:21 <lambdabot>  Falsifiable, after 259 tests: -124
16:26:24 <Cale> @scheck \x -> x `elem` [-100..100 :: Integer]
16:26:24 <lambdabot>  add an instance declaration for (Serial Integer)
16:26:25 <lambdabot>   In the definition of `...
16:26:34 <ihope> Serial?
16:26:36 <Cale> sigh
16:26:54 <ihope> @check \x -> x /= 0 :: Int
16:26:55 <lambdabot>  Couldn't match `Int' against `Bool'
16:27:00 <ihope> @check \x -> x /= (0 :: Int)
16:27:01 <lambdabot>  Falsifiable, after 0 tests: 0
16:27:14 <ihope> It didn't even have to try 0?
16:27:29 <Cale> heh, that's bizarre
16:27:32 <SamB> perhaps it has a wierd concept of time
16:27:39 <matthew-> or off-by-one error!
16:27:49 <ihope> Off-by-one error is nice.
16:27:51 <SamB> yeah, or that...
16:28:00 <dibblego> is there a convention to start the next line after 'where' with an indent relative to the where?
16:28:08 <SamB> see, it had 0 successful tests and failed one
16:28:32 <Cale> dibblego: yeah
16:28:33 <SamB> dibblego: what meanest thou?
16:28:38 <ihope> dibblego: it's not required?
16:28:52 <dibblego> I see it all the time, but it doesn't seem to be needed - nor do  I think it looks any better
16:28:57 <dibblego> where
16:28:58 <ihope> That's a bug, then. Everything must be required. No freedom is allowed.
16:29:04 <dibblego> --indent--> blah blah
16:29:06 <SamB> dibblego: paste some code!
16:29:13 <dibblego> I prefer:
16:29:14 <dibblego> where
16:29:16 <dibblego> blah blah
16:29:28 <Cale> dibblego: Usually I put the first line after the where on the same line as the where, and then indent the next line to line it up with that.
16:29:28 <SamB> sometimes I do that, I think
16:29:32 <SamB> other times:
16:29:39 <SamB> where blah
16:29:43 <SamB>       more blah
16:29:48 <Cale> right, like that
16:29:50 <dibblego> !paste
16:29:53 <dibblego> @paste
16:29:54 <lambdabot> http://paste.lisp.org/new/haskell
16:30:24 <lisppaste2> dibblego pasted "where" at http://paste.lisp.org/display/26406
16:30:40 <dibblego> ah ok
16:31:14 <newsham> anyone know what language witrala used in icfp contest?
16:32:09 <scsibug> i've got the contest report here, let me check if it says....
16:33:29 <newsham> also the announcer said one of the winners used "2D" ?
16:33:36 <newsham> isnt that a made up problem in the contest?
16:33:42 <scsibug> that was just the "language of choice"
16:33:44 <scsibug> it was a joke
16:34:02 <scsibug> although....someone was claiming to have almost finished a UM interpreter written in 2D, so maybe not ;)
16:34:16 <sek> hmm, where on earth can i get a FULL source distribution of ghc for an intel mac?
16:34:19 <scsibug> you could put whatever you wanted as the "language of choice"
16:34:42 <matthew-> gah, silly haskell with its lack of unification...
16:34:48 <sek> there doesnt seem to be any binary packages
16:35:03 <sek> and the source given on the website seems to require older versions..
16:35:12 <dolio> Heh. Wouldn't you need a UM to run the 2D UM? Just like the UM reference implementation written in UM machine code?
16:35:16 <newsham> sek: ghc is needed to build itself.
16:35:55 <Patterner> ghc as cross-compiler?
16:36:08 <scsibug> dolio: you could write a 2D compiler outside of UM :)
16:36:29 <dolio> You could, but did anyone do that?
16:36:38 <dolio> Seems like it'd be a pain to parse.
16:36:40 <scsibug> the contest organizers did...in ML
16:36:49 <scsibug> source code should be forthcoming
16:36:51 <sek> i downloaded ghc-6.5.20060526-i686-apple-darwin8.tar, 36mbs
16:37:28 <sek> it installed fine, but it doesnt run, it tried to find /usr/lib/ghc-.... which doesnt exist
16:38:18 <newsham> try the 6.4 release?
16:38:42 <matthew-> how do I convert a list to a tuple?
16:39:02 <newsham> an arbitrary list to an arbitrary tuple?
16:39:13 <matthew-> yeah
16:39:15 <newsham> that doesnt work in th etype system
16:39:26 <matthew-> oh great.
16:39:31 <matthew-> can map work on tuples?
16:39:33 <newsham> [a] -> () or (a) or (a,a) or (a,a,a) or (a,a,a,a,....) ?
16:39:43 <matthew-> fair point.
16:39:53 <newsham> no map on tuples
16:39:54 <matthew-> I'm still in Erlang mode...
16:40:08 <sek> k, found it. its in http://www.haskell.org/ghc/dist/ but this link isnt really given anywhere on the downloads page
16:40:08 <lambdabot> Title: Index of /ghc/dist
16:40:14 <newsham> why do you want to go from lists to tuples or back?
16:41:01 <newsham> if you want to iterate/map/etc you prob want lists.
16:41:10 <matthew-> yeah, I think you're right
16:41:11 <newsham> tuples are good for holding values of different types
16:41:27 <matthew-> ok, I have a list of fields
16:41:29 <xerox> If you want both, you want HList :)
16:41:38 <scsibug> newsham:  the official ICFP-C report doesn't say what Carl Witty (Witrala) used...and none of the example code was from him
16:41:55 <xerox> scsibug: brain? :P
16:42:02 <scsibug> very possible
16:42:32 <matthew-> then I want to do !field on every record for each field, and end up with [(f1,f2,f3...)]
16:43:22 <newsham> i dont know what !field is
16:43:40 <lispy> matthew-: that's not ideal at all :)
16:43:47 <lispy> matthew-: there must be a more standard fix
16:43:51 <matthew-> no, I'm not sure either! value!function
16:44:04 <matthew-> what does that do anyway?
16:45:03 <newsham> array indexing is   <arr> ! <idx>   i think
16:45:11 <matthew-> I thought that was !!
16:45:17 <matthew-> [1,2,3] !! 1
16:45:19 <newsham> that's list indexing
16:45:23 <matthew-> oh
16:45:48 <matthew-> bizarre. I'm deeply confused now... haskelldb...
16:46:30 <matthew-> ahh, it's a haskelldb function
16:46:30 <matthew-> (!) :: Select f r a => r -> f -> a
16:46:55 <matthew-> anyway, I'm trying to solve the wrong problem. ignore me
16:54:18 <araujo> Both fromEnum/toEnum needs to be defined for new instances?
16:54:28 <araujo> Of the Enum typeclass that is it.
16:56:22 <resiak> @where HList
16:56:23 <lambdabot> http://homepages.cwi.nl/~ralf/hlist/
16:57:06 <dibblego> I am using read which sometimees fails to parse, in which case I want to evaluate to Nothing -- can you somehow catch the parse error then express Nothing?
16:57:35 <mauke> ?type reads
16:57:37 <lambdabot> forall a. (Read a) => ReadS a
16:57:40 <dibblego> or perhaps I might use Either instead of Maybe and evaluate with the "parse error"
16:58:02 <lispy> > read "aoeu" :: Int `catch` (\e -> show e)
16:58:03 <lambdabot>  Parse error
16:58:17 <lispy> > (read "aoeu" :: Int) `catch` (\e -> show e)
16:58:18 <lambdabot>  Couldn't match `IO a' against `Int'
16:58:28 <lispy> ?type catch
16:58:30 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:58:31 <dibblego>  > read "aoeu" :: Int `catch` (\e -> Right e)
16:58:47 <dolio> ?type catchException
16:58:48 <lambdabot> Not in scope: `catchException'
16:58:57 <mauke> > reads "a"
16:58:58 <lispy> dibblego: yes you can catch it, the question is which catch to use...i'd try Control.Exception.catch if Prelude.catch doesn't work
16:58:58 <lambdabot>  Add a type signature
16:59:19 <mauke> > (reads :: ReadS Int) "a"
16:59:21 <lambdabot>  []
16:59:27 <mauke> > (reads :: ReadS Int) "123"
16:59:28 <lambdabot>  [(123,"")]
16:59:34 <mauke> > (reads :: ReadS Int) "123xyz"
16:59:35 <lambdabot>  [(123,"xyz")]
16:59:47 <lispy> > read "123" :: Int
16:59:48 <lambdabot>  123
16:59:59 <lispy> ?tye reads
17:00:01 <lambdabot> forall a. (Read a) => ReadS a
17:06:29 <lisppaste2> dibblego pasted "How do I get parseLine to return Nothing if any of those reads fail to parse? or with reads" at http://paste.lisp.org/display/26407
17:08:51 <shapr> @users
17:08:57 <lambdabot> Maximum users seen in #haskell: 239, currently: 215 (90.0%), active: 33 (15.3%)
17:09:07 <sjanssen_> @quote
17:09:08 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
17:09:48 <nich> what defines 'active' for the bot?
17:10:06 <shapr> Probably "spoke in the last N minutes"
17:10:20 <nich> oh
17:10:23 <nich> probably, indeed
17:10:26 <shapr> Not sure what N is.
17:10:37 <xerox> > pi
17:10:39 <lambdabot>  3.141592653589793
17:10:54 <lispy> i think N is pretty big
17:11:06 <lispy> as in, bigger than i would have guessed
17:11:45 <dons> ?help users
17:11:46 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in last 4 hours
17:11:59 <lispy> ?. ++ . read . show . state ?. ++ . read . show . state
17:12:00 <lambdabot> compose module failed: IRCRaised Parse error: "++"
17:12:18 <lispy> ah, yeah 4 hours is huge compared to what i would have guessed
17:12:22 * lispy was thinking 30 min
17:13:21 <matthew-> \quit many thanks for all your help...
17:13:32 <shapr> bye matthew-!
17:13:36 <matthew-> gah!
17:13:38 * shapr grins
17:13:52 <matthew-> will ppl please make up their minds which slash to use?!!
17:14:00 <shapr> \ pi
17:14:30 <shapr> I've seen some sed code from dons, that's real slasher literature.
17:14:52 <dons> heh
17:15:02 <shapr> G'day dons, how's code?
17:15:22 <dons> hey, did people see zarvok's casual announcement yesterday. the winning team at the icfp contest used haskell, python and C++
17:15:50 <dons> so maybe haskell is stil the language used by the winning team: 3 years running
17:16:09 <dibblego> was it just haskell the 2 years before?
17:16:20 <dons> yep
17:16:24 <shapr> How about "Each winning team for the last three years was familiar enough with Haskell to use it to write part or all of their solution."
17:16:33 <dons> i presume they wrote their VM with C++
17:16:49 <dons> and then at least some of the problems on top got solved in haskell or python
17:17:32 <shapr> dons: btw, thanks for all your work on ByteString, it really makes commercial Haskell users happier.
17:17:41 <dons> oh, interesting!
17:17:46 <dons> you went to CUFP?
17:18:26 <shapr> No, but I know that speedy ops have long been decried as Haskell's biggest lack.
17:18:36 <dons> yep
17:19:06 <dcoutts__> shapr: it makes non-comercial users happier too :-)
17:19:16 <shapr> I wish I could have gone to CUFP. I would have had much to say.
17:19:23 <dons> it makes lambdabot happier
17:19:56 <dcoutts__> content <- fmap GZip.decompress (readFile "foo.gz")
17:20:01 <dcoutts__> @yarr!
17:20:01 <lambdabot> Avast!
17:20:15 <dcoutts__> easy peasy
17:20:18 <dons> mmm tasty
17:20:25 <dcoutts__> next up, iconv perhaps
17:20:34 <shapr> Yeah, we need unicode support soon.
17:20:54 <dons> I say forkIO that compression thread, dcoutts__ , and run it on the spare cpu :)
17:21:02 <shapr> Oh, I've been reading Okasaki's book and I think amortization may be the perfect way to describe laziness to the layman.
17:21:20 <dcoutts__> shapr: aye
17:21:37 <dcoutts__> and as an easy way of writing incremental algorithms
17:21:45 <dibblego> Just (read $ commaSplit a !! 0, read $ commaSplit a !! 1, read $ commaSplit a !! 2) -- can I make that evaluate to Nothing if any of use of read fails?
17:21:57 <dcoutts__> content <- fmap (iconv utf32 utf8) (readFile "foo.gz")
17:22:04 <dons> dcoutts__: you going to release zlib soon?
17:22:15 <dcoutts__> dons: it's released.
17:22:20 <dons> dibblego: use reads
17:22:28 <dcoutts__> what more do you want? an announcement!?!
17:22:31 <dons> dibblego: and perhaps: map read (take 3 a)
17:22:32 <dcoutts__> :-)
17:22:39 <dons> dcoutts__: yes!
17:22:57 <dcoutts__> dons: I'll send an email to various lists in the morning
17:23:03 <dons> good stuff
17:23:07 <scsibug> is anybody here actually going to CUFP (it's tomorrow)?  (I'll be there)
17:23:09 <dibblego> I actually have a guard: (length $ commaSplit a) == 3 = Just (read $ commaSplit a !! 0, read $ commaSplit a !! 1, read $ commaSplit a !! 2)
17:23:15 <dcoutts__> dons: #haskell gets a sneek preview :-)
17:23:26 <dons> so --- we're living in the age of associated typed ghc now..
17:23:34 * shapr sneeks over
17:23:53 <dcoutts__> dons: as for forkIO, it'd only help if you want to decompress eagerly
17:23:59 <shapr> scsibug: Not me, I only wish :-)
17:24:15 <SamB> dons: we are???
17:24:24 <SamB> they released it at ICFP?
17:24:30 <shapr> ATs are in 6.7, yeah?
17:24:30 <dons> dcoutts__: thinking of some kind of server that runs the compression thread in parallel... or on the gpu..
17:24:35 <scsibug> shapr: did you bring your uni to portland?
17:24:46 <dibblego> where is ICFP 2007 going to be held?
17:24:48 <dons> yeah, _massive_ push last night. i think ATs are in
17:24:50 <dcoutts__> dons: yeah, you can buy dedicated zlib hardware
17:24:51 <SamB> it doesn't count as those days until the even-numbered release!
17:24:54 <dibblego> where in Australia?
17:24:55 <scsibug> dibblego: germany
17:25:13 <shapr> scsibug: Nah, not this time. My flight wasn't confirmed until Friday and I left on Saturday.
17:25:14 <dons> dibblego: it alternates between the US and Europe.
17:25:24 <dibblego> ah ok
17:25:54 <dcoutts__> g'night folks
17:25:57 * dcoutts__ -> bed
17:26:08 <SamB> remind me of that in 2008
17:26:21 <dibblego> I'm going to Germany
17:26:33 <scsibug> don't think i'll be able to make it to germany unless my company picks up the tab
17:26:40 <dons> night dcoutts__
17:26:47 <shapr> g'nite dcoutts__
17:27:24 <nuffer> can anyone point me to a profiler for haskell (ghc)?
17:27:43 <dons> yes, it comes with ghc. using ghc -O -prof -auto-all
17:27:49 <dons> then run your haskell programs with +RTS -p
17:27:57 <dons> the profiling info goes into a.out.prof file
17:28:00 <xerox> I think that thanks to lexical scoping we're going to lose the reference to dcoutts's bed... sorry.
17:28:03 * xerox -> bed
17:28:06 <nuffer> dons - thanks
17:28:07 <SamB> but, you need the libs built properly first
17:28:15 <lennart> i think it's time for a beer
17:28:23 <SamB> xerox: hahaha
17:28:34 <dons> nuffer: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
17:28:38 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
17:28:58 <nuffer> odd that google doesn't find that for "ghc profiler"
17:29:50 <dons> ?google profiling haskell site:haskell.org
17:29:54 <lambdabot> http://www.haskell.org/ghc/docs/2.10/users_guide/user_56.html
17:29:54 <lambdabot> Title: User's Guide - profiling
17:30:05 <dons> heh that's an old man page
17:30:12 <nuffer> "profiler" not "profiling", an honest mistake
17:30:15 <dons> SamB: yeah, we have a new flag, Introduced the switch -findexed-types
17:30:47 <SamB> dons: 2.1
17:30:49 <SamB> !!!!
17:31:02 <SamB> I didn't know GHC ever had such low version numbers!
17:31:10 <dons> so, extensions to Core to support System Fc, a new implementation of GADTs, indexed data types and indexed newtypes (generalised associated types)
17:31:23 <lisppaste2> scsibug pasted "HaXml make install" at http://paste.lisp.org/display/26409
17:31:26 <dons> SamB: what about 0.06 -- the first public release?
17:31:36 <SamB> hmm
17:31:40 <scsibug> could someone take a look at this error i'm getting from make install on HaXml?
17:31:46 <SamB> I guess I just sort of figured that had nothing to do with me ;-)
17:31:58 <SamB> anyway the first non-zero digit is 6 ;-)
17:35:26 <sjanssen_> oh wow, I gotta build this Fc stuff tonight
17:35:30 <dibblego> > reads "True"
17:35:31 <lambdabot>  Add a type signature
17:36:01 <dibblego> > reads "True" :: Bool
17:36:01 <lambdabot>  Couldn't match `Bool' against `[(a, String)]'
17:36:02 <dibblego> > reads "True" :: [(Bool, String)]
17:36:02 <lambdabot>  [(True,"")]
17:36:15 <gmh33> @users #haskell
17:36:17 <lambdabot> Maximum users seen in #haskell: 239, currently: 216 (90.4%), active: 35 (16.2%)
17:36:28 <gmh33> >bf .+[.+].
17:36:51 <xerox> dons: I just had an idea!
17:37:12 <sek> ive been trying to install lambdabot for 3 hours now, heh im giving up for today
17:37:12 <gmh33> @bf .+[.+].
17:37:12 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
17:37:12 <nuffer> so uh, out of curiousity, should that .prof file be empty?
17:37:17 <xerox> dons: what if lambdabot commands were really just command under L. ? Wouldn't it solve many problems? And open new possibilities?
17:39:06 <nuffer> like, absolutely nothing in it
17:40:46 <dons> nuffer: did you run the program with +RTS -p ?
17:40:52 <nuffer> yes
17:40:54 <dons> and did the program terminate normally
17:40:56 <nuffer> yes
17:41:01 <nuffer> well, it's a GLUT program
17:41:10 <nuffer> but beyond that I think it terminated normally
17:41:11 <dons> seems strange. you used -prof -auto-all ?
17:41:19 <nuffer> yes
17:41:29 <nuffer> -O too
17:41:36 <dons> maybe it didn't terminate normally. if it fails, you need a newer ghc (which produces profiling info even when failing)
17:41:49 <dons> otherwise, hmm, post a transcript?
17:42:17 <nuffer> a transcript of..?
17:42:26 <nuffer> I'm running ghc 6.4.1
17:42:38 <dons> of what you typed and did?
17:43:07 <dons> perhaps write a small test program to confirm profiling works on your box
17:43:51 <nuffer> hmm, I'll get on that
17:44:03 <dons> mmm, the Fc/ATs commit is a bit of a spike in ghc activity: http://www.cse.unsw.edu.au/~dons/images/commits/community/
17:44:05 <lambdabot> Title: Haskell Community Project Activity, http://tinyurl.com/phosp
17:45:47 <nuffer> okay, it was the GLUT that wasn't making it happy
17:50:19 <SamB> shouldn't HWN be per-week?
17:51:11 <dons> yes
17:52:30 <dons> i added some historical details for the emergence of ghc, http://haskell.org/haskellwiki/News/1989
17:52:32 <lambdabot> Title: News/1989 - HaskellWiki
17:57:19 <sjanssen_> dons: out of curiousity, what WM do you use lately?
17:58:29 <dons> I'm using dwm, but i'm not 100% sure its the best for the job yet
17:58:41 <dons> I seem to have to leave it in floating mode to get what I want
17:58:57 <dons> I just worry that wmii isn't being maintained now, so dwm will be the solution in the end
17:59:06 <dons> though its still a little raw
18:00:27 <dons> that said, its very fast and light, and I like it, dwm.
18:01:02 <sjanssen_> yeah, I've been using dwm, and it is about 90% what I want
18:01:12 <sjanssen_> it needs a ion style tabing/tiling mode
18:01:52 <dons> yeah, I keep it in maximised floating mode, which approachs the tiling mode of ion and wmii
18:02:20 <dons> i'm encouraged by the rapid development by Anselm. he's getting out a new reease each week
18:02:41 <dons> I think i'm running dwm 1.6 now, so i'm hoping that all issues will be solved soon enough
18:04:08 <moonlite> what does fail in control.monad really do? Is it defined for State and StateT? Could i do an evalState and kindof catch the error?
18:05:22 <lispy> ?type fail
18:05:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:05:55 <lispy> > fail "ack!" :: [Int]
18:05:57 <lambdabot>  []
18:06:24 <lispy> > fail "ack!" :: State Int Int
18:06:25 <lambdabot>  add an instance declaration for (Show (State Int Int))
18:06:47 <sjanssen_> moonlite: fail is a function defined for all Monads
18:06:54 <dibblego> the values of laziness break down in a non-pure FP environment - comments?
18:07:11 <lispy> dibblego: what are the values of laziness?
18:07:28 <moonlite> sjanssen_: yeah but what does it really do?
18:07:50 <dibblego> lispy, I find it difficult to put into words, so good point
18:08:06 <lispy> > [1,2,3] ++ fail "ack!" ++ [3,4]
18:08:07 <lambdabot>  [1,2,3,3,4]
18:08:08 <dolio> Can you do laziness in a non-pure FP environment?
18:08:15 <lispy> moonlite: does that help? ;)
18:08:16 <dolio> Wouldn't that screw up your sequencing?
18:08:18 <dibblego> lispy, certainly it feels more natural to me so I may be bias
18:08:22 <moonlite> lispy: nopes not at all :/
18:08:22 <dons> > fail "help" :: Either String String
18:08:24 <lambdabot>  Left "help"
18:08:25 <dibblego> dolio, I don't know - would it?
18:08:55 <audreyt> dons: sure, see http://www.ccs.neu.edu/scheme/pubs/fdpe05-bc.pdf
18:08:57 <audreyt> er
18:08:58 <lambdabot> http://tinyurl.com/z97ky
18:09:00 <audreyt> dolio: sure, see www.ccs.neu.edu/scheme/pubs/fdpe05-bc.pdf
18:09:01 <lispy> moonlite: each monad defines fail differently and you have to know how that monad 'thinks' before it makes sense...
18:09:12 <lispy> moonlite: the list monad is all about non-determinstic computations
18:09:16 <moonlite> lispy: ah i get your point now
18:09:20 <lispy> moonlite: so, failure just means you didn't produce anything options
18:09:39 <audreyt> dolio: sequencing is screwed up only if you use it in a way akin to unsafePerformIO
18:09:39 <moonlite> list monad => [] and either monad []
18:09:47 <moonlite> -[] + left str
18:09:57 <lispy> moonlite: in either you get left because that's an error and either is the error monad :)
18:09:58 <lispy> right
18:10:24 <lispy> to be honest, i don't know what it means to fail in the state monad
18:11:04 <lispy> > runState (do { x <- fail "blah"; return x } ::State Int Int) 0
18:11:06 <lambdabot>  Exception: blah
18:11:20 <lispy> so, apparently failure in the state monad throws an exception
18:11:41 <moonlite> hm ok
18:11:41 <lispy> > runState (do { x <- fail "blah"; return x } ::State Int Int) 0 `Control.Exception.catch` (\e -> show e)
18:11:43 <lambdabot>  Not in scope: `Control.Exception.catch'
18:12:38 <moonlite> what i want is a state and error so i guess i should just use a StateT with some error monad
18:13:05 <dons> or use MonadError for your type
18:13:18 <dons> ?hoogle MonadError
18:13:19 <lambdabot> Control.Monad.Error.MonadError :: class Monad m => MonadError e m
18:13:22 <dolio> audreyt: Right, but isn't that basically saying that you have to make sure all your lazy code is pure/safe by hand, rather than having the language enforce it?
18:13:51 <lispy> ?instances MonadError
18:13:52 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
18:14:04 <lispy> we seem to have lots of instances there
18:15:28 <audreyt> dolio: yes, but not all people like monadic bondage and type discipline.
18:16:05 <dons> they don't know its for their own good.
18:16:44 <audreyt> yeah, also they don't seem to know that Haskell is a talented mistress :)
18:16:46 <dons> and given enough time, they'l develop a healthy case of Stockholm Syndrome, and love their type checker
18:16:58 <dons> heh
18:17:20 <audreyt> speaking of typechecker, chak's FC/AT landed and I'm rubbing my hands waiting for it to compile (after chekcing in a buildfix) :)
18:17:40 <dons> yeah. lots of freaky fun
18:17:58 <dons> its like candy day in Toy Town!
18:18:36 <audreyt> <spj> it's like throwing raw meat to hyenas...
18:18:57 <dolio> dibblego: In other words, if code depends on the correct sequencing of side effects, lazy evaluation can be dangerous, because the laziness may cause those side effects to be executed in an arbitrary order, or not at all.
18:19:02 <dons> heh or that. I prefer candy though :)
18:19:22 <dibblego> dolio, ok, I thought there might be more to it
18:19:46 <dons> so you've got a plan to add ATs as a fundamental structuring mechanism to pugs yet, audreyt ?
18:20:23 <audreyt> why, yes.
18:20:32 <audreyt> but... is it landing for 6.6?
18:20:37 <dons> nope.
18:20:43 <audreyt> then the plan is shelved :)
18:20:46 <dolio> dibblego: If you can just sprinkle side effects anywhere, like in a non-pure language, that is. Haskell isolates them in strict monads, like IO and ST.
18:20:51 <dons> heh
18:21:57 <dibblego> dolio, I am having this conversation in #ocaml :)
18:21:57 <audreyt> pugs seems to be just my excuse to apply each and every one technique from the GHC changelogs...
18:22:05 <dibblego> dolio, they are my thoughts exactly
18:22:12 <dons> hehe
18:22:45 <dolio> dibblego: There is lazy ML. I don't know what they do about that sort of thing, though.
18:24:47 <sjanssen_> audreyt: did you have trouble with a stray comma too?
18:25:02 <audreyt> sjanssen_: I'm checking in fixes as I go
18:25:19 <audreyt> another seem to arive on TypeRep.lhs
18:25:21 <audreyt> arise, even
18:26:45 <audreyt> committed a fix for that too
18:28:32 <pianodogg> dolio: you can definitely do lazy programming around side effects
18:28:41 <pianodogg> scheme has delay/force
18:28:56 <pianodogg> you just have to be careful about those zany side effects
18:29:22 <pianodogg> haskell has the advantage that all the discipline you need is in the type system (modulo unsafe*IO hacks)
18:31:59 <SamB> well, those are, I think, fairly effectively discouraged
18:32:04 <SamB> I mean, for the most part
18:32:22 <dolio> Yeah, but if there are advantages to be gained by having ubiquitous laziness, then explicit delay/force makes that rather cumbersome.
18:32:39 <pianodogg> well sure.  depends on what you're trying to do
18:32:41 <dolio> Assuming there are such advantages, which I'm certainly not prepared to argue for. :)
18:32:46 * SamB is talking about the unsafePerformIO hacks
18:32:52 <pianodogg> sometimes ubiquitous laziness is annoying when you want everything strict
18:32:53 <shapr> I like ubiquitous laziness.
18:32:53 <SamB> and whatnot
18:33:07 <SamB> pianodogg: ... *everything*?
18:33:12 <SamB> how about just *something*?
18:33:22 <dolio> It certainly does cause its quirks.
18:33:24 <SamB> that argument is easier
18:33:40 <dolio> > foldl1 (+) [1..10000000]
18:33:43 <lambdabot> Terminated
18:33:54 <SamB> because you won't have so much trouble convincing people to believe in the premise
18:34:05 <SamB> (that you want something to be strict)
18:34:10 <pianodogg> well sure
18:34:29 <SamB> I mean, if you wanted everything strict, surely you'd be using ML or something!
18:34:29 <pianodogg> but there are classes of programs where laziness isn't really buying you anything
18:34:36 <pianodogg> yes, that's my point
18:34:55 <pianodogg> it depends on your problem domain... languages make different things simple to express
18:34:59 <SamB> I think it generally buys you something
18:35:18 <pianodogg> sure
18:35:28 <shizzy0> I found out something neat today in Haskell, and this seems like the only place I can share it.
18:35:33 <SamB> I mean, tossing infinite lists around with abandon is nice ;-)
18:35:43 <SamB> shizzy0: tell us!
18:35:44 <pianodogg> shizzy0: oh do tell
18:36:01 <shizzy0> I've been using the ghci, and it's kind of bothered me that I can't define functions there.
18:36:02 <pianodogg> sure it is, but that's not always the natural way to think about a problem
18:36:16 <pianodogg> well you can, with a slightly different syntax
18:36:24 <pianodogg> let f x = x * 2
18:36:25 <shizzy0> but I found out you can, but using monads: f <- return (\x -> x + 1)
18:36:35 <dolio> Generating infinite/too large data structures lazily and then consuming only what's needed is an interesting way of doing certain problems.
18:36:36 <shizzy0> oh, that'll work?
18:36:38 <pianodogg> you can do that too
18:36:40 <pianodogg> shizzy0: you bet
18:36:49 <shizzy0> oh, even nicer!
18:36:51 <pianodogg> you can do that within any do { } block too
18:37:18 <pianodogg> actually you can use let = ... for any non-monadic computation you need to do with some values you got earlier from within the monad
18:37:42 <shizzy0> very cool.  I love this channel.  :)
18:37:42 <sjanssen_> > do let {f = \x -> x + 1}; Just (f 2)
18:37:43 <lambdabot>  Just 3
18:37:45 <shapr> me too!
18:37:50 <pianodogg> like do { x <- getChar; let y = ord x; putChar (chr (y+1)) }
18:37:50 <jgrimes> wow, jhc is really killing my cpu/memory
18:38:00 <pianodogg> or something
18:38:06 <shapr> jgrimes: Does it build the libs for you?
18:38:15 <jgrimes> shapr, thats what I'm doing at the moment
18:38:18 <sjanssen_> pianodogg: you need {} around y = ord x
18:38:33 <pianodogg> since when?
18:38:33 <int-e> to put it on a single line.
18:38:37 <pianodogg> oh okay
18:38:43 <shapr> I haven't been able to build the libs with the darcs checkout from a week ago.
18:39:17 <jgrimes> shapr, any idea as to the problem?
18:39:33 <shizzy0> ou, that's kind of weird.  I can say, let f x = x + 1, then say let f x = x + 2.
18:39:35 <jgrimes> or source of the problem, rather :)
18:39:48 <shapr> I'm guessing JohnMeacham forgot to check something into the darcs repo.
18:40:12 <lispy> shizzy0: the second one shadows the first
18:40:12 <jgrimes> fair enough :)
18:40:30 <lispy> shizzy0: if you run ghci with -Wall -Werror i don't think it will let you do that
18:41:08 <SamB> shapr: people will do that sometimes
18:41:13 <shizzy0> lispy, you are right:     Warning: This binding for `f' shadows an existing binding
18:41:17 <shapr> Hiya thetallguy, didn't I meet you at lunch day before yesterday?
18:41:34 <SamB> you could check to see if the files are there in the http copy
18:41:46 <shizzy0> lispy, okay, weird question.  Suppose I do shadow f x, is there any way unshadow it?
18:42:12 <SamB> shapr: sometimes poeple forget to add things to repos but rsync their working dir up to a server...
18:42:27 <shapr> hm
18:44:22 <lispy> shizzy0: well, you'd have to "go up" a level in scope
18:44:31 <lispy> shizzy0: given the way ghci works, i think no
18:45:29 <shizzy0> lispy: [nods] ok, that's cool.  Just curious about what you can do in there.
18:45:36 <jgrimes> shapr, where does it fail when compiling the libs for you?
18:46:03 <shapr> jgrimes: I don't remember, haven't tried it since I got another 512mb and am now up to 1gb of ram.
18:46:17 <lispy> shapr: on your nokia?? :)
18:46:35 <jgrimes> shapr, yeah, I'm at 1gb of RAM and it is using 75% of it
18:46:37 <shapr> :-P
18:46:41 <Korollary> ?users
18:46:43 <lambdabot> Maximum users seen in #haskell: 239, currently: 212 (88.7%), active: 31 (14.6%)
18:46:47 <shapr> lispy: My 770 has 1gb of storage :-)
18:46:54 <lispy> shapr: dawn
18:46:55 <lispy> er damn
18:47:08 <lispy> turn that upside down w into an m
18:47:09 <SamB> once I tried to compile JHC's libs and it exhausted all 1GB of my swap!
18:47:10 <Korollary> that's a graphical typo
18:47:28 <jgrimes> oh..
18:47:30 <shapr> lispy: 2gb rs-mmc cards are out, but I'm okay with my 1gb for the moment.
18:47:40 <lispy> well, on dvorak m and w are side by side...
18:47:41 <jgrimes> it is using 1.5gb of swap...
18:47:47 <Korollary> ah
18:47:50 <shapr> aoeuhtns!
18:47:56 <jgrimes> maybe I should uh, cancel that until I don't want to use this workstation
18:48:07 <shapr> _frederik_ uses dvorak too, how many others here?
18:48:11 <jgrimes> that would explain why everything suddenly slooowwwwed down
18:48:19 <lispy> i'm using a ',.pyf keyboard but in dvorak mode... :)
18:48:22 <pianodogg> shizzy0: save yourself the trouble and name the second thing something other than f :)
18:48:29 <shapr> jgrimes: JohnMeacham suggests 2gb of ram when building libs.
18:48:51 <lispy> shapr: kowey uses dvorak also
18:49:00 <shapr> nifty
18:49:04 <weitzman> Is there any particular reason that (foldl1 (+) [1..10000000]) doesn't get optimized to run instantly?
18:49:06 <jgrimes> shapr, sounds like a job for campus computing
18:49:14 <dons> weitzman: its' not a foldl1' ?
18:49:29 <dons> or you don't have -O on?
18:49:36 <dolio> Do you mean like converting it to n(n+1)/2?
18:49:38 <weitzman> I don't have anything on
18:49:41 <shizzy0> pianodogg, will do.  :)  thanks for the tip on 'let'.  That makes the ghci _usable_ for me now.
18:49:43 <SamB> dolio: heh
18:49:44 <weitzman> I was looking at the #haskell history
18:49:49 <weitzman> And someone said that to lambdabot
18:49:50 <lispy> > foldl1' (+) [1..10000000]
18:49:52 <weitzman> > Terminated
18:49:55 <lambdabot> Terminated
18:49:55 <lambdabot>  Not in scope: data constructor `Terminated'
18:50:05 <weitzman> Yeah
18:50:07 <SamB> weitzman: that means it ran out of CPU time
18:50:10 * scsibug is a dvorak user
18:50:16 <SamB> or memory
18:50:18 <SamB> or something
18:50:21 <dons> Time.
18:50:24 <dolio> Actually, when I typed that in, I was trying to get it to blow the stack, but apparently I thought wrong.
18:50:25 <dons> memory is a different error
18:50:35 <pianodogg> scsibug: how do you keep your head on straight when you use somebody else's computer?
18:50:37 <dons> > foldl1 (+) [1..10000000]
18:50:41 <lambdabot> Terminated
18:50:45 <SamB> its not so easy to blow the stack in the time limit, is it?
18:50:45 <dons> good bot
18:50:55 <dolio> I thought we were doing it the other day.
18:51:04 <pianodogg> @snack
18:51:04 <lambdabot> Unknown command, try @list
18:51:09 <dons> no, you have to try really hard:
18:51:10 <dons> > scanr (*) 1 [1..]
18:51:11 <weitzman> Seems like that should be a prime candidate for optimizer trickiness
18:51:12 <dolio> > sum [1..10000000]
18:51:13 <pianodogg> hrm, i thought i saw somebody do that
18:51:13 <SamB> well, the obvious methods don't seem to have time
18:51:13 <lambdabot>  Exception: stack overflow
18:51:17 <lambdabot> Terminated
18:51:17 <scsibug> pianodogg:  the real question, is how do *they* keep their head on straight after they get their computer back, and their keyboard is "broken"
18:51:21 * dons wins
18:51:28 <SamB> dons: scanr huh
18:51:35 <dons> a lazy foldr, of sorts.
18:51:40 <SamB> what is that good for besides blowing the stack?
18:51:46 <SamB> @type scanr
18:51:47 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
18:51:48 <dons> unlike, say, sum which will with the list enumerator
18:51:49 <SamB> @type foldr
18:51:51 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
18:51:58 <pianodogg> scsibug: nice; use the mouse till switching the keys over :)
18:52:00 <dolio> > sum [1..1000000]
18:52:00 <dons> scanr is a generliased foldr
18:52:01 <lambdabot>  Exception: stack overflow
18:52:06 <pianodogg> saves you the pain
18:52:06 <SamB> oh
18:52:07 <dolio> Ah, there we are.
18:52:15 <scsibug> I used qwerty until about 4 years ago, so I can still deal with it
18:52:27 <dolio> 10 million takes too long to build the accumulator, I guess.
18:52:40 <weitzman> Does code fed to lambdabot not get optimized?
18:52:41 <pianodogg> i gave it a shot once but it was just too much effort to keep it up
18:52:48 <dons> weitzman: nope.
18:52:56 <pianodogg> > scanr (+) 1 [1..10000000]
18:52:59 <lambdabot>  Exception: stack overflow
18:53:02 <dons> but it's a one line change to enable it
18:53:04 <dons> maybe I should
18:53:17 <SamB> @scheck \f z xs -> last (scanr f) z xs == foldr (f :: I -> I) z xs
18:53:18 <lambdabot>    Expecting a function type, but found `[a]'
18:53:18 <lambdabot>    Expected type: [t -> t1...
18:53:21 <SamB> hmm
18:53:26 <SamB> @scheck \f z xs -> last (scanr f) z xs == foldr (f :: I -> I -> I) z xs
18:53:27 <lambdabot>    Expecting a function type, but found `[a]'
18:53:27 <lambdabot>    Expected type: [t -> t1...
18:53:42 <weitzman> Can GHC with optimization turned on run an infinite loop in a few seconds?
18:53:54 <scsibug> HApps is turning into a headache to build... the ghc package mechanisms aren't terribly mature are they?
18:53:54 <sjanssen_> weitzman: yes, sometimes
18:54:06 <SamB> @type \f z xs -> last (scanr f) z xs == foldr (f :: I -> I -> I) z xs
18:54:07 <weitzman> I'm partially serious
18:54:07 <lambdabot> Not in scope: type constructor or class `I'
18:54:08 <lambdabot>  
18:54:08 <lambdabot> <interactive>:1:51: Not in scope: type constructor or class `I'
18:54:10 <lispy> scsibug: you mean cabal?
18:54:13 <sjanssen_> weitzman: ever seen a program dump out "<<loop>>"?
18:54:19 <weitzman> Oh, yeah
18:54:21 <SamB> > fix id
18:54:22 <weitzman> Snap
18:54:22 <lambdabot>  Add a type signature
18:54:22 <dons> > let f = f in f :: ()
18:54:23 <lispy> > let x = x
18:54:23 <lambdabot>  Exception: <<loop>>
18:54:24 <lambdabot>  Parse error
18:54:27 <SamB> > fix id :: ()
18:54:28 <lambdabot>  Exception: <<loop>>
18:54:36 <weitzman> > fix id
18:54:37 <lambdabot>  Add a type signature
18:54:41 <SamB> dons: your code is too long!
18:54:46 <dons> seems like
18:54:49 <scsibug> lispy: I guess I'm not even sure...whatever ghc-pkg falls into
18:54:51 <weitzman> Oh, you beat me to what I was trying to do, and did it better
18:54:55 <weitzman> I feel slow
18:55:00 <SamB> weitzman: I did it the same way as you!
18:55:08 <weitzman> I see
18:55:13 <dons> we've been in heavy bot training for 4 years though
18:55:18 <SamB> only I started sooner so I got to give a type signature sooner ;-)
18:55:48 <weitzman> So that's a genuine exception
18:55:54 <weitzman> You could catch it?
18:56:01 <sjanssen_> weitzman: yes
18:56:03 <weitzman> Neat
18:56:24 <SamB> @scheck \f z xs -> last (scanr f z xs) == foldr (f :: I -> I -> I) z xs
18:56:28 * SamB feels silly
18:56:30 <lambdabot>   Failed test no. 623532. Test values follow.: -1->
18:56:30 <lambdabot>  {-1->-1;0->-1;1->-1;2-...
18:56:47 <sjanssen_> though I would look very sceptically at any code that explicitly catches a nontermination exception
18:56:48 <SamB> dons: you need to up the limit on output length for scheck, methinks...
18:57:03 <SamB> well, maybe that wouldn't help for this case
18:57:04 <dons> sjanssen_: heh.
18:57:14 <SamB> sjanssen_: me too
18:57:34 <SamB> because the halting problem exists
18:57:38 <dons> unless you were testing for blackholing programs
18:57:45 <SamB> so those can't be reliable
18:57:50 <scsibug> maybe my cabal issues are with ghc 6.4.1, and i should upgrade to 6.4.2
18:57:57 <SamB> scsibug: hmm?
18:58:00 <SamB> cabal issues?
18:58:05 <SamB> what are you doing?
18:58:15 <scsibug> trying to install HAppS
18:58:28 <SamB> have you built lambdabot yet?
18:58:31 <scsibug> Just finished installing HaXml
18:58:34 <scsibug> no, I haven't
18:58:52 <SamB> the README has instructions for updating Cabal
18:59:16 <scsibug> ghc-pkg tells me that Text.XML.HaXml.Verbatim is exposed through HaXml, but HAppS complains about not being able to find that
18:59:30 <scsibug> I'll take a look at lambdabot then, thanks
18:59:41 <SamB> @scheck \f z xs -> last (scanr f z xs) == foldr (f :: B -> B -> B) z xs
18:59:41 <lambdabot>  Not in scope: type constructor or class `B'
18:59:51 <SamB> @scheck \f z xs -> last (scanr f z xs) == foldr (f :: Bool -> Bool -> Bool) z xs
18:59:52 <lambdabot>   Failed test no. 513. Test values follow.: {True->{True->True;False->True};...
19:00:37 <pianodogg> SamB: you'll get it.  keep trying :)
19:01:16 <dons> ?scheck \f z xs -> head (scanr f z xs) == foldr (f :: Bool -> Bool -> Bool) z xs
19:01:18 <lambdabot>  Completed 16352 test(s) without failure.
19:01:27 <SamB> dons: oh
19:01:56 <SamB> > scanr (:) [1..]
19:01:57 <lambdabot>  Add a type signature
19:02:03 <SamB> > scanr (:) [1..] :: [[Int]]
19:02:04 <lambdabot>    Expecting a function type, but found `[[Int]]'
19:02:04 <lambdabot>    Expected type: [[In...
19:02:06 <SamB> hmm
19:02:13 <SamB> > scanr (:) [] [1..] :: [[Int]]
19:02:14 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:02:25 <SamB> > reverse (scanr (:) [] [1..])
19:02:29 <lambdabot> Terminated
19:02:39 * SamB didn't think that was going to work
19:02:42 <dons> heh
19:02:59 <SamB> > (scanr (:) [] [1..]) !! 2
19:03:00 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
19:03:04 <SamB> > (scanr (:) [] [1..]) !! 1
19:03:05 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:03:24 <SamB> so whats it good for?
19:03:37 <dibblego> for what cases with reads return a list with more than one element?
19:03:42 <dibblego> s/with/will
19:03:45 <dons> scanr? computing partial prefixes of results?
19:04:06 <SamB> dons: what partial prefixes?
19:04:22 <dibblego> I can only get reads to return a null list or one element list
19:04:34 <weitzman> > heads [1..] !! 5
19:04:35 <lambdabot>  Not in scope: `heads'
19:04:35 <SamB> dibblego: feed it ambiguous input!
19:04:40 <weitzman> > tails [1..]
19:04:42 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:04:49 <SamB> > inits [1..]
19:04:49 <dibblego> SamB, such as?
19:04:50 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
19:05:01 <weitzman> Aw. It should be heads and tails
19:05:01 <SamB> dibblego: I dunno!
19:05:11 <SamB> I haven't heard of it!
19:05:16 <sjanssen_> > tail $ inits [1..]
19:05:17 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
19:05:19 <dibblego> SamB, my point exactly
19:05:20 <SamB> > iterate head [1..]
19:05:20 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:05:21 <lambdabot>    Expected...
19:05:33 <weitzman> > inits $ tails [1..]
19:05:34 <lambdabot>  [[],[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
19:05:38 <SamB> dibblego: but that is the only concievable reason for it returning a list!
19:05:47 <SamB> > iterate tail [1..]
19:05:48 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:05:48 <dons> oh, I don't know,
19:05:49 <dons> > scanr (\a b -> b/2) 1000 [1..10]
19:05:51 <lambdabot>  [0.9765625,1.953125,3.90625,7.8125,15.625,31.25,62.5,125.0,250.0,500.0,1000.0]
19:05:52 <SamB> hmm.
19:06:02 <SamB> > iterate init
19:06:03 <lambdabot>  Add a type signature
19:06:07 <SamB> > iterate init [1..]
19:06:08 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:06:10 <dons> its like a fold, but you can get the intermediate results
19:06:10 <SamB> nope
19:06:17 <SamB> > reverse (iterate init [1..])
19:06:20 <lambdabot> Terminated
19:06:32 <SamB> if that worked you'd get inits [1..] ;-)
19:07:06 <dibblego> is it true to say that it is impossible to get reads to return a list with more than one element?
19:07:13 <SamB> dibblego: no!
19:07:22 <SamB> for I could write an ambiguous Read instance!
19:07:41 <SamB> I dunno in what way, but I'm sure it is possible!
19:07:58 <dibblego> ah I see
19:08:21 <dibblego> I think it only holds true for specific instances of ReadS
19:09:55 <SamB> I could have told you that only some instances would be ambiguous
19:10:15 <dibblego> but you didn't :)
19:10:33 <SamB> I didn't realize that you did not know this ;-)
19:10:43 <dibblego> I didn't either until I did
19:13:58 <dons> > sum [1..1000000]
19:14:00 <lambdabot>  500000500000
19:14:04 <dons> -O turned on :)
19:14:22 <dons> so the sum will fuse with the enumFromTo producer, and it runs in constant space
19:14:30 <dons> > sum [1..1000000000]
19:14:34 <lambdabot> Terminated
19:15:12 <br1> can I simplify kk >>= return . aa ?
19:15:50 <dons> yes
19:15:51 <dons> ?pl kk >>= return . aa
19:15:52 <lambdabot> aa `fmap` kk
19:16:33 <pianodogg> oh that's nice
19:16:49 <pianodogg> so why does the bigger sum die?
19:17:07 <pianodogg> it's not like the result is so big.  is it a time limit?
19:17:11 <dolio> lambdabot kills it after 3 seconds.
19:17:15 <dons> yep
19:17:15 <pianodogg> ah
19:17:17 <Plareplane> did haskell win the contest again this year
19:17:19 <br1> dons: thx
19:17:29 <dons> Plareplane: it was one of the languages used by the winners, yes.
19:17:32 <pianodogg> ?type fmap
19:17:34 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
19:17:40 <dons> and also the language used by the team that solve most of the puzzles first
19:17:55 <pianodogg> ?type liftM
19:17:57 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
19:18:05 <dons> the winners also used C++ and Python.
19:18:42 <pianodogg> well don't those two look similar
19:18:44 <SamB> they declared 2d as the language of choice, or were they just being smartasses?
19:19:06 <dons> 2d is a language from one of the puzzles. so I think the latter :)
19:19:26 <SamB> well, given the name of the team, I'm inclined to agree
19:19:32 <SamB> and I know that it is from the puzzles!
19:19:38 <dolio> Balance was obviously the superior language, anyway.
19:19:57 <dons> there's a video of the results
19:20:03 <dons> ?where icfpcontest-video
19:20:04 <lambdabot> http://video.google.com/videoplay?docid=6419094369756184531
19:20:09 <dolio> Much more like malbolge.
19:20:29 <sjanssen_> so, do we have to take our "discriminating hackers" banner down?
19:20:56 <dons> not sure...
19:21:08 <dons> considering the winners really did use haskell.
19:21:49 <Plareplane> dons: odd, i get a video not available from that link
19:22:25 <dons> works for me
19:22:57 <sjanssen_> how many people attend a conference like ICFP?
19:23:09 <dons> a few hundred?
19:23:52 <sjanssen_> @where wadler
19:23:53 <lambdabot> I know nothing about wadler.
19:24:00 <pianodogg> ?pl liftM a b
19:24:01 <lambdabot> fmap a b
19:24:16 <pianodogg> lambdabot, that's shocking
19:24:35 <pianodogg> you owe a lot to wadler
19:25:03 <pianodogg> ?pl liftM
19:25:04 <lambdabot> fmap
19:25:07 <pianodogg> ha ha
19:25:19 <pianodogg> alrighty then.  i fail to see any reason for liftM to even exist
19:25:38 <dolio> Because monads are not required to be declared as instances of Functor.
19:25:53 <dolio> So that won't always work.
19:25:59 <pianodogg> then why does lambdabot do that reduction?
19:26:10 <pianodogg> ?info Monad
19:26:11 <lambdabot> Monad
19:26:18 <pianodogg> erm
19:26:18 <sjanssen_> pianodogg: lambdabot is wrong
19:26:18 <SamB> it is assuming your monads are nice?
19:26:38 <pianodogg> well maybe it should go talk to wadler?  :)
19:26:38 <dons> because all monads are functors
19:26:39 <SamB> all monads are functors.
19:26:43 <dolio> I imagine it works for all the monads in the standard library.
19:26:57 <SamB> its just that Haskell's Monad and Functor classes do not reflect this
19:26:58 <dolio> But you could write a monad of your own and not declare it a functor.
19:27:09 <dons> but then it wouldn't be a monad
19:27:11 <SamB> but, if you did, you could fix it easy
19:27:12 <dons> it'd be broke
19:27:17 <SamB> dons: it would not
19:27:23 <SamB> it just wouldn't be good style
19:27:32 <scsibug> sjanssen: I believe the organizers said there were exactly 200 registrants to ICFP this year
19:28:02 <pianodogg> indeed, i have declared monads without bothering with functor
19:28:19 <dons> ah, we don't even require Functor => Monad, just:
19:28:20 <dons> Instances of both 'Monad' and 'Functor' should additionally satisfy the law:
19:28:21 <dons> > fmap f xs  ==  xs >>= return . f
19:28:22 <lambdabot>  Not in scope: `f'
19:28:59 <SamB> @scheck \f xs -> fmap f (xs :: [Bool]) == xs >>= return . f
19:29:00 <lambdabot>  Couldn't match `m a' against `Bool'
19:29:03 <pianodogg> i.e fmap == liftM
19:29:07 <dons> ?check \f xs -> fmap (f :: I -> I) (xs :: T)  ==  xs >>= return . f
19:29:08 <lambdabot>  Couldn't match `m a' against `Bool'
19:29:15 <pianodogg> @sheck fmap == liftM
19:29:16 <lambdabot> Maybe you meant: check scheck
19:29:17 <dons> ah
19:29:29 <pianodogg> @scheck fmap == liftM
19:29:30 <lambdabot>  add an instance declaration for (Eq ((a1 -> b) -> f a1 -> f b))
19:29:30 <lambdabot>   In the ...
19:29:51 <pianodogg> indeed i must add one in the ...
19:30:00 <dons> or apply it to something..
19:30:15 <pianodogg> sorry, i'm just having fun with the bot
19:30:16 <SamB> @scheck \f p -> fmap f p == liftM f p
19:30:17 <lambdabot>  add an instance declaration for (Serial (m a1), Show (m a1))
19:30:17 <lambdabot>   In the def...
19:30:23 <pianodogg> Serial?
19:30:34 <SamB> @scheck \f p -> fmap f (p :: [B]) == liftM f p
19:30:35 <lambdabot>  Not in scope: type constructor or class `B'
19:30:39 <SamB> @scheck \f p -> fmap f (p :: [Bool]) == liftM f p
19:30:39 <lambdabot>  Add a type signature
19:31:09 <dolio> Anyhow, there's a thread on the haskell-prime list from about a month ago discussing whether it should be Functor m => Monad m, or whether that's too much work.
19:31:17 <SamB> @scheck (\f p -> fmap f p == liftM f p) :: (Bool -> Bool) -> [Bool] -> [Bool]
19:31:17 <lambdabot>  Couldn't match `[Bool]' against `Bool'
19:31:28 <dons> @check (\f xs -> fmap f xs == liftM f (xs :: T)) :: (I -> I) -> T -> Bool
19:31:31 <lambdabot>  OK, passed 500 tests.
19:31:32 <dolio> And whether you could have something that automatically declares fmap for all your monads.
19:31:41 <SamB> @scheck (\f p -> fmap (f :: Bool -> Bool) p == liftM f p)
19:31:42 <lambdabot>  add an instance declaration for (Serial (m Bool), Show (m Bool))
19:31:42 <lambdabot>   In the...
19:31:55 <SamB> @scheck (\f p -> fmap (f :: Bool -> Bool) (p :: [Bool]) == liftM f p)
19:31:56 <lambdabot>  Completed 2044 test(s) without failure.
19:32:03 <SamB> @type (\f p -> fmap (f :: Bool -> Bool) (p :: [Bool]) == liftM f p)
19:32:05 <lambdabot> (Bool -> Bool) -> [Bool] -> Bool
19:32:13 <SamB> oh right ;-)
19:32:32 <SamB> I need sleep
19:44:45 <dons> ?tell glguy openbsd-4.0/ghci patch committed
19:44:45 <lambdabot> Consider it noted.
19:46:22 <sjanssen_> I don't understand why there are complicated proposals to make fmap declared automatically with a Monad instance
19:46:46 <sjanssen_> you're talking about two lines of boilerplate for Fmap when you've already instanced Monad
19:47:00 <sjanssen_> s/Fmap/Functor
19:47:30 <dolio> Apparently people are writing all sorts of monads all over the place, and it's too much work to make them functors, too. :)
19:47:36 <dons> yeah, i don't think we'll see random complications like this adopted.
19:47:56 <dons> it's hard to get any feature adopted without at least 2 research papers on the area :)
19:48:06 <sjanssen_> I wonder how many instance Monad there are in the world
19:48:22 <dons> we need a @google-hits command...
19:48:35 <dons> ?google-hits instance Monad
19:48:36 <lambdabot> Unknown command, try @list
19:49:21 <dons> sjanssen_: .... want a little lambdabot hacking before bed? :)
19:51:27 <sjanssen_> @help google
19:51:27 <lambdabot> google <expr>. Search google and show url of first hit
19:52:52 <dibblego> can you use a logical and in a guard expression?
19:53:21 <br1> dibblego: How so?
19:53:29 <dons> dibblego: two ways:
19:53:36 <dibblego> br1, dunno, you tell me
19:53:47 <dons> > let x | True && (True || True) = 1 in x
19:53:49 <lambdabot>  1
19:53:55 <dons> or using pattern guards:
19:54:13 <dons> let x | Just _ <- some expr , and something else = 1 in x
19:54:22 <dibblego> ok ta
19:54:23 <br1> dibblego: Sorry, I misparsed you :)
19:59:49 <lisppaste2> dibblego pasted "Why is this broken?" at http://paste.lisp.org/display/26418
20:01:16 <dibblego> > length $ reads "7"
20:01:17 <lambdabot>  Add a type signature
20:01:19 <dibblego> > length $ reads "7" :: Int
20:01:20 <lambdabot>  Add a type signature
20:01:34 <pianodogg> @type reads
20:01:35 <lambdabot> forall a. (Read a) => ReadS a
20:01:45 <pianodogg> @type ReadS
20:01:47 <lambdabot> Not in scope: data constructor `ReadS'
20:02:01 <dibblego> > length $ reads "7" :: [(Int, String)]
20:02:01 <lambdabot>  Couldn't match `[(Int, String)]' against `Int'
20:02:22 <weitzman> > length $ (reads "7" :: [(Int, String)])
20:02:24 <lambdabot>  1
20:03:06 <dibblego> > length $ (reads "7" :: [(Int, String)]) == 1
20:03:06 <lambdabot>  Couldn't match `[a]' against `Bool'
20:03:12 <dibblego> > (length $ (reads "7" :: [(Int, String)])) == 1
20:03:13 <lambdabot>  True
20:05:10 <lisppaste2> dibblego pasted "What's the difference?" at http://paste.lisp.org/display/26419
20:06:28 <dibblego> oh got it
20:06:35 <dibblego> I was assuming it could be inferred
20:13:46 <dons> ?uptime
20:13:46 <lambdabot> uptime: 3d 1h 8m 38s, longest uptime: 3d 1h 8m 38s
20:16:11 <glguy> Has anyone here implemented the UM?
20:16:11 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:17:35 <sjanssen_> glguy: I bet at least a dozen people in here have (I'm one of them)
20:17:51 <dibblego> let f a = (length $ (reads a :: [(Int, String)])) == 1 && length (snd ((reads a :: [(Int, String)]) !! 0)) == 0 in f "abc"
20:17:57 <dibblego> gotta be a better way of writing that
20:17:57 <glguy> Is the sandmark supposed to take a long time to go from 100 to 99?
20:18:16 <sjanssen_> it all depends on how fast your UM is, of course
20:18:34 <glguy> sjanssen_: I wrote it in C++ using STL vectors
20:18:44 <dibblego> @pl let f a = (length $ (reads a :: [(Int, String)])) == 1 && length (snd ((reads a :: [(Int, String)]) !! 0)) == 0 in f "abc"
20:18:45 <lambdabot> length (reads "abc" :: [(Int, String)]) == 1 && length (snd (reads "abc" :: [(Int, String)] !! 0)) == 0
20:18:54 <glguy> and it gets through to 100 pretty fast
20:19:04 <glguy> but then I've not seen it hit 99
20:19:11 <glguy> (I haven't waited long enough maybe)
20:19:37 <sjanssen_> glguy: http://www.cse.unsw.edu.au/~dons/um.html
20:19:37 <lambdabot> Title: Haskell UM
20:19:44 <sjanssen_> some example runtimes
20:20:18 <dibblego> > let f a = length (reads a :: [(Int, String)]) == 1 && length (snd (reads a :: [(Int, String)] !! 0)) == 0 in f "7"
20:20:18 <lambdabot>  Parse error
20:21:07 <glguy> Hmm, I just got to 99
20:21:12 <glguy> wonder what I'm diong that is taking soo long
20:21:43 <dibblego> @pl let f a = (length $ (reads a :: [(Int, String)])) == 1 && length (snd ((reads a :: [(Int, String)]) !! 0)) == 0
20:21:43 <lambdabot> (line 1, column 112):
20:21:44 <lambdabot> unexpected end of input
20:21:44 <lambdabot> expecting digit, variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`", "&&", ";" or "in"
20:22:53 <dibblego> @pl let f a = (length $ (reads a :: [(Int, String)])) == 1 && length (snd ((reads a :: [(Int, String)]) !! 0)) == 0 in f "7"
20:22:54 <lambdabot> length (reads "7" :: [(Int, String)]) == 1 && length (snd (reads "7" :: [(Int, String)] !! 0)) == 0
20:23:07 <br1> Can I construct a Handle from a String?
20:23:25 <dibblego> @pl let f a = length (reads a :: [(Int, String)]) == 1 && length (snd (reads a :: [(Int, String)] !! 0)) == 0 in f "7"
20:23:26 <lambdabot> length (reads "7" :: [(Int, String)]) == 1 && length (snd (reads "7" :: [(Int, String)] !! 0)) == 0
20:23:29 <araujo> br1, ?
20:23:30 <dibblego> > let f a = length (reads a :: [(Int, String)]) == 1 && length (snd (reads a :: [(Int, String)] !! 0)) == 0 in f "7"
20:23:30 <lambdabot>  Parse error
20:23:44 <dibblego> get stuffed
20:24:10 <br1> I want to read from an in memory buffer
20:26:11 <Cale> br1: err... why?
20:26:38 <dons> br1, you could read a file into a memory buffer..
20:26:44 <dons> ?hoogle hGetBuf
20:26:45 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
20:26:45 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
20:26:45 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
20:26:59 <dons> ?type Data.ByteString.readFile -- same thing ;)
20:27:01 <lambdabot> FilePath -> IO Data.ByteString.Base.ByteString
20:27:09 <shapr> Yay, Haskell is mentioned in the most recent Linux Weekly News in the Perl6 section.
20:27:16 <dons> shapr: url?
20:27:41 <shapr> http://lwn.net/Articles/199432/ (requires lwn subscriber status)
20:27:47 <dons> boo
20:27:52 <br1> I want to write a test for a funtion that normally reasd from stdin
20:27:57 <dons> shapr, why do they do that?
20:28:42 <shapr> You mean why does LWN make some content subscriber only for the first week?
20:28:50 <dons> yeah. I see, they need the funds
20:28:56 <Cale> br1: and there's no way to more cleanly separate I/O from what the function is actually doing?
20:29:08 <dons> though it seems a bit unlinuxy. ah wel
20:29:23 <shapr> Yeah, Corbet does Linux kernel dev work and excellent reporting work, and he's written Linux Kernel Device Drivers which is also free in PDF format.
20:29:35 <shapr> dons: I can handle something being pay only for the first week. I only wish ACM et al would do that.
20:29:43 * dons carries on with the and-always-free HWN
20:29:50 <dons> yeah, stupid ACM monopolists
20:30:04 <shapr> ACM et al take copyright and make most of their stuff always pay-only.
20:30:27 <br1> Cale: I think not.  I'm reading the first n chars that satisfy a condition.
20:30:33 <dons> I intend to keep linking to papers directly on home pages in the hwn :)
20:30:41 <shapr> I'm glad to hear that :-)
20:30:48 <shapr> But I suspect you'll run across cases where you can't
20:30:57 <dons> yes, unfortunately
20:31:07 <shapr> Of course, my extremist approach is to pretend those papers just don't exist and refuse to discuss them with anyone.
20:31:13 <shapr> With luck, that'll kill off the monopolies.
20:31:18 <Cale> You can if you illegally copy them to your server.
20:31:24 <Cale> :)
20:31:30 <dons> :)
20:31:35 <shapr> I'd rather change the system from inside.
20:31:48 <dons> handing over copyright really really annoys me
20:31:58 <shapr> Or publically protest via civil disobedience.
20:32:01 <shapr> dons: Me too
20:32:05 <sjanssen_> can you record a dramatic rendition of the paper and distribute that?
20:32:15 <shapr> sjanssen_: Monads as interpretive dance?
20:32:15 <dons> the publisher does _nothing_ anymore. its very 19th century
20:32:36 <shapr> Yeah, I complained about that at Haskell Workshop as well.
20:32:40 <shapr> I paid $130 for what?
20:33:14 <shapr> I think we should push the FreeHaskell series and The Monad.Reader
20:33:22 <dons> yeah. the authors and so on write the papers, their peers review it, the universities host it, and the attendees pay for the privledge. and where does the publisher fit in?? oh -- they get the copyright.
20:33:31 * shapr has decided that EuroHaskell and AngloHaskell were part of the FreeHaskell series of gatherings.
20:33:47 * shapr does an Amen Brother! to dons
20:34:13 <shapr> dons: I've thought about a zero publisher system and I have some ideas.
20:34:43 <shapr> Did you see my recent blog post linking to a writeup of the problems with the current system?
20:34:48 <dons> yeah.
20:34:50 <dons> it was good
20:35:05 <sjanssen_> so, I don't really know how this works.  Say I submit a paper to ICFP and it is accepted, am I required to assign copyright to the ACM?
20:35:08 <shapr> He had the brilliant idea to reverse the anonymity, make the reviewers publically announced and the papers anonymous.
20:35:19 <dons> I wonder if the research paper archive on haskell.org is more popular than looking for haskell papers on acm yet?
20:35:40 <dons> sjanssen_: to the publisher, yes.
20:35:46 <dons> normally they also let you post a version on your website
20:35:54 <sjanssen_> how gracious!
20:35:55 <shapr> We could do this zero-journal system already with TMR.
20:36:00 <jgrimes> I don't like looking for papers on acm
20:36:01 <dons> some publishers ask that you put up a disclaimer saying that ACM or others have the copyright
20:36:20 <shapr> And the author website papers are only for timely dissemination of information
20:36:40 <shapr> Because print journals take time to go from camera ready to being in the hands of readers.
20:36:42 <dibblego> why is it that sometimes I :load File.hs then try to find the type of a function in that file only to be told the function doesn't exist?
20:36:57 <dons> dibblego: becaues its been compiled, and not in the export list?
20:37:14 <dibblego> I don't use any exports or modules
20:37:15 <dons> in which case, you need to "touch File.hs" to have it reinterpreted (and have the export list exposed)
20:37:21 <shapr> dons: You think TMR would be a good place to experiment with a zero-journal system?
20:37:35 <shapr> Wouter Swierstra volunteered to be co-editor of TMR in order to get it moving again.
20:37:42 <dibblego> well that worked, for some reason
20:38:10 <dons> my concern is that unless it has proper peer review status, it will essentially remain amateur
20:38:32 <dons> i.e. an author needs to be sure that a submission to TMR will count as a "publication" for it to fly, no?
20:39:18 <dons> or, if we don't aim for that kind of rigour. instead it could be more like a technical report status
20:39:43 <jgrimes> how are amateur papers generally viewed (if at all?) in academia?
20:40:01 <dons> so just ensure there's a persistent url for every article, and an ISBN. there may be some other requirements for getting technical report status
20:40:11 <dons> jgrimes: depends on the area.
20:40:21 <dons> probably not well in maths
20:40:38 <lisppaste2> dibblego pasted "Is it possible to write this function without being specific to Int?" at http://paste.lisp.org/display/26420
20:40:40 <shapr> dons: Yes, I'd want a submission to TMR to count as a 'publication'
20:41:09 <dons> shapr: if that was the case, then the haskell author out there could legitimately devote serious time to the articles
20:41:45 <dons> you might want to talk to guys like SPJ or people who've worked on the HW for more info on how to lift TMR this way.
20:41:56 <dons> since they set up things like the journal of FP back in the early 90s
20:41:59 <shapr> hm, right
20:42:03 <weitzman> I think if you remove all the ":: [(Int, String)]" and give readInt a forall type, it'll work for any time
20:42:49 <dibblego> wtf is a forall type?
20:42:51 <weitzman> The type inference would see that you're returning the same type you get from read
20:42:57 <dons> dibblego: polymorphic type
20:43:07 <dons> ?type id -- polymorphic
20:43:09 <lambdabot> forall a. a -> a
20:43:14 <dons> ?type id :: Int -> Int -- monomorphic
20:43:15 <dibblego> readT :: ReadS t => String -> Maybe t ?
20:43:16 <lambdabot> Int -> Int :: Int -> Int
20:43:22 <weitzman> Yeah
20:43:26 <weitzman> You don't want a forall
20:43:28 <weitzman> I'm being stupid
20:43:31 <weitzman> Yay
20:43:40 <weitzman> Anyway, I think that's all you need to do
20:43:47 <dibblego> the compiler complains when I try that
20:43:54 <dibblego> Type constructor `ReadS' used as a class
20:44:06 <weitzman> Try "Read" instead of ReadS
20:44:29 <lisppaste2> sjanssen annotated #26420 with "there you go" at http://paste.lisp.org/display/26420#1
20:45:09 <dibblego> that's not the same, but thanks
20:45:27 <weitzman> [(x, "")]::_ would be the same, I think
20:45:32 <dons> possibly,
20:45:33 <dons> readM :: (Monad m, Read a) => String -> m a
20:45:33 <dons> readM s = case [x | (x,t) <- reads s , ("","")  <- lex t] of
20:45:33 <dons>         [x] -> return x
20:45:33 <dons>         []  -> fail "Serial.readM: no parse"
20:45:35 <dons>         _   -> fail "Serial.readM: ambiguous parse"
20:45:39 <dons> (used in lambdabot)
20:45:43 <weitzman> Although in Haskell :: isn't cons
20:45:45 <dons> returns failure in whatever monad you want.
20:45:46 <weitzman> :
20:45:48 <sjanssen_> dibblego: it does the same thing
20:46:02 <weitzman> Wait, yeah
20:46:06 <weitzman> You check for length == 1
20:46:09 <dibblego> sjanssen, actually I think it does
20:46:35 <dibblego> I was trying to think of how to do that - case was the solution
20:46:58 <dibblego> why is the Read a in parentheses?
20:47:22 <dons> shapr: oh, you actually get payed real monies to write for LWN. huh
20:47:31 <weitzman> @type Read a => String -> Maybe a
20:47:33 <lambdabot> parse error on input `=>'
20:47:42 <weitzman> @type (Read a) => String -> Maybe a
20:47:43 <lambdabot> parse error on input `=>'
20:47:51 <weitzman> Wait
20:47:55 <weitzman> That's not how @type works
20:48:01 <weitzman> @type x :: Int
20:48:02 <lambdabot> Not in scope: `x'
20:48:08 <weitzman> @type fix id :: Int
20:48:10 <lambdabot> Int :: Int
20:48:23 <weitzman> @type (fix id) :: Read a => String -> Maybe a
20:48:25 <lambdabot> Read a => String -> Maybe a :: forall a. (Read a) => String -> Maybe a
20:48:28 <dibblego> in order to use a function in ghci, I have to save the file, :load the file, change the file and save it again, then :load it again
20:48:42 <dibblego> s/change the file and save it again/touch it
20:49:09 <Korollary> :r reloads
20:49:21 <dibblego> oh I tried :reload
20:49:36 <kpreid> I use this for some kinds of work:
20:49:38 <kpreid> :def lr \f -> return (":load " ++ f ++ "\nmain")
20:50:12 <dibblego> ok thanks
20:50:42 <dibblego> case/of cannot be replaced with pattern matching right?
20:51:00 <dons> sure.
20:51:14 <dons> what do you think pattern matching is? its sugar for case statements
20:51:32 <dibblego> I can't think of how to express that readR without a case/of
20:51:36 <weitzman> In that case you're matching on the result of an expression
20:51:54 <weitzman> So I don't think you can pattern match at the function definition level
20:51:57 <dibblego> reads [(x, "")] -> Just x -- ?
20:52:11 <dibblego> er
20:53:00 <dibblego> I think it can't be replaced because it is "case reads s" but if it were "case s" then it could be
20:56:15 <kpreid> sure it can.
20:56:28 <kpreid> reads s -> case s of [(x, "")] -> ...
20:56:42 <dons> shapr: interesting, http://herdrick.blogspot.com/2006/09/schemers-in-haskell-country.html
20:56:46 <lambdabot> Title: Ethan Herdrick: Schemers in Haskell country, http://tinyurl.com/fp5jn
20:57:22 <dibblego> kpreid, do you mind annotating that paste with what you are saying - I'm not clear on how that works
20:57:46 * shapr looks
20:58:06 <kpreid> dibblego: wait, I'm confused
20:58:20 <kpreid> annotation 1 on that paste is exactly what I meant
20:58:29 <kpreid> do you mean replacing case with =?
20:58:35 <kpreid> (they're both pattern matching)
20:59:02 <dibblego> I mean using pattern matching without the case/of cannot be achieved
20:59:13 <shapr> dons: And at the same time, amateurs are flooding into the Haskell research world via #haskell ;-)
20:59:27 <dibblego> I am a bit confused too - I didn't think of case/of as pattern matching
20:59:41 <dons> shapr: yep.
20:59:55 <dibblego> shapr, I am here because I inadvertantly reinvented Haskell when I writing my own language
20:59:56 <dons> dibblego: case _is_ pattern matching. its the pattern matching primitive
21:00:06 <kpreid> dibblego: maybeRead s = let { sub [(x, "")] = Just x; sub _ = Nothing } in sub (reads s)
21:00:08 <dibblego> dons, ok I didn't see that straight away
21:00:45 <shapr> dibblego: I'm here because I started writing Python that looked and felt like Haskell and a friend pointed me in this direction.
21:01:34 <shapr> But that was more than five years ago and I nearly chose Scheme instead.
21:02:02 <shapr> But my fiancee at the time had already purchased Haskell books and gave them to me for my birthday. So I started reading them and never got into the Scheme community.
21:02:23 <dibblego> I purchased Haskell books 3 weeks ago - still haven't arrived
21:02:31 <dibblego> from the US
21:03:29 <dons> dibblego: you should be able to get a good range of haskell books from a local university bookshop?
21:03:33 <dibblego> I am astonished every time I learn of something in Haskell only to find it was something I was going to do myself
21:03:41 <dibblego> dons, Amazon is cheaper :) I bought 5
21:03:55 <Korollary> It's quite preposterous to claim that the current FP work done in haskell was done 15 years ago by schemers. Haskellers of today *were* schemers (Wadler, Hudak, etc.)
21:04:02 <dibblego> work paid for them, but the price was much higher at universities
21:04:21 <dibblego> beyond the justification for quick delivery
21:04:21 <dons> Korollary: yeah and there's a lot of things that just don't make sense in scheme. GADTs, theorem proving, dependent types?
21:04:28 <shapr> There's a lot of cool Haskell research that I never would have discovered myself. Arrows as hyperoperators, deriving reverse programs via arrows, etc
21:05:39 <dolio> I don't think it's particularly surprising that presentations are more haskelly than schemey, either.
21:05:43 <shapr> Lots of FP researchers are clearly members of both the Scheme and Haskell communities.
21:06:05 <shapr> Felleisen (sp?), Dybvig, etc
21:06:20 <dolio> Even if you wrote your findings in some kind of pseudo code/mathematics, it'd probably look a lot more like Haskell than Scheme.
21:06:44 <dibblego> well I have only been using FP language for a couple of weeks - I reinvented some parts of it as a solution to the Java/.NET trash that is prolific in the industry
21:06:51 <dibblego> dolio, agreed
21:07:07 <shapr> Personally, I want to steal the features from languages that will be popular 100 years from now and get them into my lifetime so I don't have to invest in cryogenics to get amazing new programming toys.
21:07:36 <shapr> So I don't care if it's Haskell, Scheme or Epigram as long as it's closer to spiffy future toys.
21:07:37 <dolio> Although Sussman does amuse me whenever he talks about how mathematical notation for (say) derivatives is so ugly, and Scheme does it much better. :)
21:07:44 <dibblego> that I reinvented FP by applying critical reasoning to existing trash gives me confidence that FP is a next step
21:08:10 <shapr> I had the same experience with Python, I wanted pure evaluation instead of side effects.
21:08:28 <dibblego> yes I should qualify with pure FP
21:10:09 <dibblego> I reinvented CPS with Java
21:10:16 <dibblego> and the Maybe monad
21:10:31 <dibblego> and function currying
21:10:43 <dolio> CPS and currying?
21:10:44 <dibblego> but it was all horribly contrived
21:10:51 <dibblego> yes, continuation passing
21:10:53 <dolio> That sounds like it'd be un-fun to do in Java.
21:11:03 <dibblego> yes unfun, but I was determined
21:11:31 <dibblego> they both require 1.5 features to do properly
21:11:45 <dibblego> s/properly/less contrived than otherwise
21:13:40 <dolio> I suppose that'll get another boost if/when they add proper closures and higher-order functions.
21:14:25 <dibblego> closures is proposed for Java 7
21:14:33 <dibblego> but it's all still horribly contrived
21:14:55 <dibblego> it bothers me that they just market these concepts that languages like Haskell have already done much better
21:14:59 <dolio> They're kind of a pain when you have to annotate them with types.
21:15:12 <dibblego> that's a minor issue - there are others
21:15:26 <dibblego> that you cannot access a local non-final is quite limiting
21:15:41 <dibblego> and CPS against an imperative API becomes pretty annoying
21:16:25 <dolio> Yes, well, you can't access a local non-final in Haskell, either. :)
21:16:44 <dolio> Although you can in Scheme and Ruby and such.
21:16:55 <dibblego> you will be able to in Java 7
21:17:11 <dibblego> I hope someone stabs it in the fact before then :)
21:17:21 <dibblego> *face too
21:17:46 <dolio> The proposal, or Java?
21:17:55 <dibblego> Java
21:17:58 <dolio> There are plenty of people arguing against the closures proposal.
21:18:08 <dibblego> there are for any Java feature
21:18:34 <dolio> Yeah. I find the arguments they use amusing.
21:18:39 <dibblego> in fact, those who base their arguments on logic can be used to predict the outcome - which is the inverse of the logical argument
21:18:54 <dibblego> amusing because the premise is flawed on both sides of the argument?
21:19:32 <dolio> Amusing because it's typically, "people are too stupid to figure out X, and I need to use lots of such stupid people to build my Java projects."
21:19:48 * emertens realizes that his UM implementation was too slow because of his array allocation strategy
21:19:54 <dibblego> they might say that inadvertantly, but I'm not sure they know that are saying that
21:20:17 <dolio> There are others, of course.
21:20:37 <dolio> "X is just syntactic sugar for stuff we can already do, and should be rejected."
21:20:38 <dibblego> I think they are just selective of what they want to observe
21:21:01 <dibblego> deliberately restricting what they can see so that it appears to be what they want
21:21:01 <dons> ibid, Geoff Washburn has a Haskell blog, http://existentialtype.net/...
21:21:44 <dibblego> I find the "checked versus unchecked exception" debate amusing
21:22:16 <dolio> And, of course, there's the other side with, "X shouldn't be added to Java, because X is useful, and I'd rather have Java die, and languages that do X better take its place."
21:22:43 <dibblego> well that too is selective
21:22:47 <dolio> Which I can sympathize with to some dgree.
21:22:56 <dolio> Although it's probably a pipe dream.
21:23:00 <dibblego> "rather have Java die" must be replaced with a solution
21:23:14 <dibblego> I can't walk into a bank and say "turn off your Java application, Haskell is here"
21:23:23 <dolio> Heh.
21:23:32 <dibblego> there needs to be a migration path
21:23:51 <dibblego> I can walk in and say "turn off your Java application, the solution is already available and offers no disadvantages"
21:24:11 <dibblego> Haskell on its own is not a solution
21:25:44 <dolio> Anyhow, I used to be interested in Java back when generics were a hot issue, and it was the exact same thing.
21:25:51 <dolio> Same arguments, really.
21:25:55 <dibblego> yep
21:26:45 <dibblego> once I know Haskell (or any FP language) well enough I will formulate a strategy to replace the existing gumph
21:27:03 <dibblego> I will find a refutation to every possible argument
21:27:12 <dolio> Heh.
21:27:12 <dibblego> and I will have evidence to support it
21:27:26 <dibblego> then my life's mission is complete :)
21:28:00 <Adamant> I hope Java doesn't get closures
21:28:07 <dibblego> has anyone written an Apache module to Haskell?
21:28:10 <Adamant> so it will die sooner.
21:28:19 <weitzman> I think Gosling already said Java's getting closures
21:28:39 <Adamant> Java is unworthy
21:29:03 <dibblego> it is certainly halting progress
21:29:09 <weitzman> As a platform, Java is about as good as you can hope for today
21:29:28 <Adamant> no
21:29:31 <weitzman> In terms of writing apps that will run on an arbitrary computer
21:29:39 <Adamant> ah, ok
21:29:40 <dolio> It does have gobs of libraries.
21:30:07 <dibblego> yeah but most of those libraries bind you into the Java way - which is often in contradiction with what is required
21:30:15 <br1> It doesn't have a function to escape html... (grrrrr)
21:30:19 <dibblego> and so people/marketers/etc. skew reality to hide this
21:30:49 <monochrom> Languages don't die so easily.
21:30:51 <dibblego> I rewrote all the Java collections
21:31:05 <dibblego> with lazy evaluation (unwittingly)
21:31:10 <Adamant> Java should be relegated to the next COBOL
21:31:40 <dibblego> all you need is a solution that can supersede it and be demonstrably better
21:31:40 <Adamant> C# is interesting.
21:31:50 <dibblego> C# is as bad as Java
21:31:57 <dibblego> I want to stab it in the face too
21:31:57 <Adamant> with type inference, it might not be too awful.
21:32:19 <Adamant> C# 3.0 is adding lots of functional-derived language goodies
21:32:19 <dibblego> I'm going home, bye
21:32:23 <Adamant> night
21:32:51 <Adamant> don't stab for the face, go for the compiler
21:32:53 <weitzman> My only concern with .NET is that it hear stories of strange/stupid bugs in it
21:32:58 <weitzman> *it -> I
21:33:16 <weitzman> I like the idea of letting languages talk to each other
21:33:17 <Adamant> there are bugs in I? ;)
21:33:18 <dolio> I suppose you can at least work with something like F# when you choose .Net.
21:33:28 <weitzman> Helps with forward compat
21:33:35 <Adamant> can you do Haskell in CLR?
21:33:49 <Adamant> or is it like trying to do a Lisp
21:34:03 <weitzman> You can do Haskell in Visual Studio and right COM components, but I'm not aware of any way to compile Haskell to .NET IL
21:34:07 <weitzman> *right -> write
21:34:10 <weitzman> I'm apparently tired
21:34:21 <weitzman> I should be, getting up early day after day
21:34:23 <Adamant> yeah, the IL is what I meant.
21:34:25 <Bobstopper> Hey. I'm implementing a UDP protocol in Haskell. I need the software to be able to send NAK packets after expected packets timeout. Where should I look for such timeout functionality in Haskell?
21:34:41 <sjanssen> Adamant: I think there is a YHC bytecode -> .NET bytecode compiler, but I'm not real sure
21:35:05 <sjanssen> @hoogle sleep
21:35:06 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
21:35:11 <sjanssen> @hoogle timeout
21:35:12 <lambdabot> Network.Socket.RecvTimeOut :: SocketOption
21:35:12 <lambdabot> Network.Socket.SendTimeOut :: SocketOption
21:35:22 <sjanssen> @hoogle wait
21:35:23 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
21:35:23 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
21:35:23 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
21:35:40 <Bobstopper> Tah, I'll have a look
21:35:42 <sjanssen> apparently I suck at this
21:35:52 <sjanssen> I don't think you want any of those
21:35:52 <Bobstopper> I should use hoogle more myself I suppose
21:36:43 <bdash> weitzman: a friend of mine wrote a Haskell -> .NET IL compiler for his masters thesis
21:36:45 <foxy> @seen ibid
21:36:45 <lambdabot> ibid is in #haskell. I last heard ibid speak 2d 18h 5m 2s ago.
21:36:59 <weitzman> I stand corrected
21:37:25 <sjanssen> bdash: did he release it?
21:37:27 <ibid> foxy: ?
21:37:28 <weitzman> I am now aware of a Haskell -> IL compiler
21:37:40 <foxy> ibid, congruence of triangles is an equivalence relation that is not equality, therefore refl, sym, trans don't imply equality!
21:38:17 <ibid> foxy: note that i frequently don't write here even if i am on irc, so away times are more useful than @seen
21:38:20 <ibid> foxy: huh?
21:38:24 <bdash> sjanssen: not that I'm aware of
21:38:33 <ibid> foxy: what are you talking about?
21:39:01 <foxy> ibid, we were talking about barendregt's definition of equality over lambda types as refl, symm, trans...
21:39:05 <Bobstopper> no, doesn't look like they are what I was after..
21:39:17 <foxy> on 4/9/06
21:39:23 <ibid> foxy: ah
21:39:39 <ibid> foxy: but you still seem to fail to understand axiomatic definitions
21:40:23 <foxy> ibid, well, I fail(ed) to see how defining equality as refl, sym, and trans picks out one single relation :)
21:40:35 <sjanssen> Bobstopper: you want Control.Concurrent.threadDelay
21:40:39 <foxy> ibid, witness congruence of triangles
21:40:52 <bdash> sjanssen: I would suggest emailing him to ask if he would consider releasing it, but I don't know his email address
21:40:57 <ibid> foxy: it doesn't, and it doesn't matter
21:41:05 <ibid> foxy: if you want to get technical about it, you can think of the definition defining l-terms as equivalence classes over any equivalence relation where those axioms hold
21:41:06 <foxy> ibid, I'll understand axiomatic definitions better by this time next year :P
21:41:17 <sjanssen> bdash: well, I'm not personally interested in it.  Just curious
21:41:26 <ibid> foxy: a course?
21:41:35 <foxy> ibid, yeah, pure maths
21:41:46 <bdash> sjanssen: fair enough then :)
21:42:23 <Bobstopper> sjanssen: ok. I suppose I can't get the thread signalled by incoming packets before then and will need to just delay at 0.01s increments or something until the timeout occurs?
21:43:08 <foxy> ibid, they don't teach about axiomatic logic in molecular biology
21:43:19 <sjanssen> Bobstopper: oh, then you want System.IO.hWaitForInput
21:43:20 <foxy> (which is my background)
21:44:54 <ibid> foxy: the point is, an axiomatic theory defines a language and a set of inference rules for proving theorems about the theory. the theory usually has many models (a technical term meaning "a real thing that the theory can be mapped to in such a way that theorems of the theory are true for it")
21:45:36 <Bobstopper> sjanssen: ah! Yes, that looks like what I'm after. Thanks :D
21:46:08 <foxy> ibid, ok
21:46:16 <ibid> foxy: in the beginning of the 20th century, mathematicians thought that maths could be defined as an axiomatic theory unambiguously, but gÃ¶del's famous incompleteness theorem proves that for any sufficiently strong theory there are always at least two different models
21:47:03 <ibid> foxy: the axiomatic approach is still a useful technique when you don't care about what things are exactly, and instead care about how the things behave
21:47:44 <foxy> ibid, so the fact that B. doesn't completely specify what equality is isn't important?
21:48:01 <ibid> foxy: yeah. think of it as underspecification :)
21:48:21 <ibid> foxy: the important thing is what facts about it you can derive from the "definition"
21:48:21 <foxy> ibid, ok, I think I get it.
21:50:55 <ibid> foxy: after the gÃ¶del result, mathematicians (except for analysis people) have generally liked to define very underspecified theories that capture some particular behaviors of a large class of things
21:51:20 <ibid> (before, too, but it's been the major stuff of maths since:)
21:51:45 <ibid> foxy: for example, consider abstract algebra.  what is "the group" or "the ring"? :)
21:52:03 <ibid> (point being, there is no *the* group or *the* ring)
21:53:03 <ibid> (many analysis people still pretend as if the reals was a well-specified *single* thing:)
21:53:27 <ibid> (note: i'm a former maths student, emphasis on former:)
21:54:01 <foxy> ibid, ah... and what do you do now?
21:54:57 <weitzman> If I were an ex-math student, I would abandon the bottomless pit of math and devise ways to beat the stock market
21:55:10 <ibid> foxy: i try to get a phd in programming languages
21:55:17 <foxy> weitzman: RBF
21:55:29 <foxy> ibid, do you do work on Haskell?
21:55:34 <tessier> Encasing people in concrete is always the best solution to the problem.
21:55:36 <ibid> weitzman: what's ex-math?
21:55:44 <foxy> like ex-smoker
21:55:48 <ibid> :)
21:56:16 <ibid> foxy: i've studied and taught haskell
21:56:16 <weitzman> I'm still trying to figure out what RBF means
21:56:26 <ibid> foxy: but i'm not directly working on haskell, no
21:56:30 <foxy> weitzman: radial basis function
21:56:52 <foxy> ibid, do you have a dissertation topic?
21:57:25 <weitzman> Gah. Calculus. I have no love of continuous mathematics.
21:57:46 <ibid> foxy: i've had several. i'm currently writing a proposal again, but i'd rather not talk about it yet
21:57:51 <foxy> :)
21:57:52 <weitzman> Although I'll confess I enjoyed my intro Real Analysis course
21:57:58 <weitzman> But not Calc in 3D
21:58:44 <ibid> foxy: my msc thesis was commended by the official reviewers for the use of haskell :)
21:58:53 <foxy> nice!
21:59:04 <emu> now c'mon, calc in 3d is not hard
21:59:18 <emu> just generalize!
21:59:30 <weitzman> Calc in 1d isn't hard, but I have no love of that either
21:59:40 <foxy> does anyone know if John Meacham's Linear Algebra stuff (as reported in HWN) is available for general use?
22:01:32 <dons> foxy: i think it's on the haskell.org 'libraries and tools/math' page
22:01:43 <weitzman> I also have some misgivings about statistics and its evil offspring, AI
22:01:49 <foxy> dons, hiya, thanks
22:01:56 <weitzman> Seems a bit half-hazard
22:02:11 <weitzman> "Let's define the standard deviation to be...hmm..what's easy to do calculus with?"
22:02:18 <foxy> weitzman, there are three ways of doing things...
22:03:24 <shapr> hei ibid
22:03:47 <ibid> shapr: pong
22:04:19 <shapr> ibid: I want to pursue the semi-formalization of TMR, but I'm too tired to discuss it further right now.
22:04:34 <shapr> I was going to ask what keywords I can google in the logs so I can find our previous discussion.
22:04:55 <shapr> Do you remember?
22:05:09 <ibid> issn? :)
22:05:22 <shapr> Ok, I'll try that.
22:05:44 <shapr> ah, that does work.
22:05:47 <shapr> thanks!
22:06:07 <foxy> dons, not there yet, is it possible to do rewrite rules on e.g. matrix dimensions, so that the order of matrix multiplication can be optimised?
22:07:18 <dons> possibly, yes.
22:09:29 <foxy> dons, had a chance to look at yi+gtk yet? :P
22:24:00 <emertens> ugh, adventure gets unwieldily very quickly
22:25:46 <dons> are you parsing the constraints list?
22:26:08 <emertens> I, I just got outside of the locked door
22:26:16 <emertens> I just started playing with this tonight
22:26:19 <dons> ah ok. :)
22:26:23 <dons> lots lots more to go ...
22:26:43 <emertens> I'm extremely impressed with this competition tho
22:27:02 <dons> its pretty awesome. nearly 1M lines of code written (?)
22:27:07 <dons> by the organisers
22:27:23 <qz> what language did they make compiler for?
22:27:38 <emertens> qvbasic?
22:28:30 <qz> :|
22:29:16 <emertens> I've got 4 of the passwords, so right now I'm just checking out the problems
22:29:23 <emertens> I'll have to actually start working them tomorrow
22:32:34 <emertens> dons: do you know what language UMIX was written in before it was compiled down to a .UM?
22:33:50 <bringert> wasn't it their own hacked-up SML or something?
22:33:56 <bringert> I can't remember
22:35:35 <dons> yep, an SML compiler. Hemlock
22:35:46 <dons> modified to emit UM instructions
22:36:57 <emertens> So are you ready to give up on Haskell and move on to O'Cult?
22:52:13 <foxy> who (or more importantly, what language) won the ICFP programming contest?
22:55:41 <dons> Team Smartass, programming in Haskell, C++ and Python
22:56:08 <foxy> what language did they choose to honour?
22:56:13 <gour> @where yhc
22:56:13 <dons> 2D :)
22:56:14 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
22:56:52 <dons> which is this, if you've not seen it, http://www.cse.unsw.edu.au/~dons/code/icfp06/puzzles/CIRCS/raytrace_complete.2d
22:56:54 <lambdabot> http://tinyurl.com/jxc7h
22:56:58 <Korollary> I don't like this multi-language approach.
22:57:43 <Korollary> It's ok for industry projects, but the aim here is experimenting.
22:58:12 <dons> Korollary: needs to start the "Choose your language NOW!" contest
23:08:02 <newsham> kor: why?
23:08:50 <emertens> Just to be clear, you said that the aim was to experiment, but not with different languages
23:11:52 <Korollary> Use 3-4 languages, which make up for each other's deficiencies. Perfect formula for competent programmers to execute and win. Bad for analyzing the results.
23:12:15 <emertens> of who the most competent programmers are?
23:12:25 <Korollary> ?
23:12:40 <emertens> the people are the ones competing... not the languages... right?
23:13:37 <lispy> i've seen several studies comparing languages...and a common thread is that one explanation of the results is almost always, the difference in programmers is just as big (maybe bigger?) than the difference in languages
23:13:54 <Korollary> Of course, but I think the focus has always been on languages/paradigms as languages were also praised for the results.
23:13:57 <lispy> otoh, i know i do better with haskell than i do with, say, python
23:17:04 <Korollary> The number of participants are not high enough. But, if you had hundreds of teams for each language, you could indeed conclude certain things.
23:17:30 <shapr> I'm not convinced
23:18:28 <shapr> I mentioned a paper by Alistair Cockburn that basically says "people are the most important factor in software engineering" - http://www.scannedinavian.com/hope/entry/37
23:18:28 <newsham> i can crank out python faster than just about anything
23:18:38 <emertens> am I missing something with these nested expressions in Advise? I can't pattern match against the parenthesis... so how am I supposed to unnest?? (hints / telling me to deal is preferred to being told the answer outright)
23:18:38 <newsham> and thats counting more than a decade experience coding in C
23:19:01 <shapr> I can crank out haskell faster than anything, and that counts more than a decode coding python.
23:19:09 <shapr> er "decade"
23:19:15 <vegai> Hmm, what was Team Smartass again? Not Java?
23:19:20 <newsham> was python around in 1996?
23:19:27 <Korollary> People are very important. That's why you need many many teams. The likelihood of not having top quality X-language programmers among 100 X-language teams is very low.
23:19:32 <shapr> Yeah, it's been around since 1989.
23:19:39 <newsham> huh..  i only started in 2001.
23:19:50 <shapr> I started with Python 1.4
23:19:58 <Korollary> python wasn't very good before 2.0
23:20:08 * shapr shrugs
23:20:14 <shapr> I liked the simplicity of 1.5
23:20:40 <shapr> I always felt that += and friends were unecessarily complex and no good for teaching.
23:20:49 <shapr> Before that sort of extra syntax I could teach Python to someone in an hour.
23:20:59 <shapr> someone meaning a Java programmer for example.
23:21:03 <Korollary> Guido throws syntax around too much
23:21:09 <Korollary> like the stuff in 2.5
23:21:13 <newsham> shapr: you dont find that a dynamically typed language is quicker?
23:21:24 <newsham> (as in, quick to hack something together)
23:21:38 <shapr> Nowadays when people say Python has simple syntax I ask them to describe the decorator syntax.
23:21:40 <shapr> newsham: heck no
23:21:57 <newsham> @staticmethod   ?
23:21:57 <lambdabot> Unknown command, try @list
23:22:03 <shapr> Haskell lets me put the pieces together correctly the first time.
23:22:26 <sieni> newsham: why would a dynamically typed language be quicker?
23:23:01 <newsham> sieni: beause you can be freer with your interfaces between functions/objects/etc..
23:23:30 <Korollary> If you write it correctly the first time, it doesn't matter whether it's typed or untyped.
23:23:39 <shapr> In my opinion Haskell has better minimal pieces (map, fold, etc) to start with. Python is just missing a bunch of what I now consider traversal essences.
23:23:41 <Muad_Dib> newsham: thus making mistakes more easy, and thus spending hours to find puny bugs (involving types)
23:24:04 <lispy> i think dynamic languages get you to a 'compiling' (or interpreting) version faster but then you spend more time later with bugs
23:24:17 <emertens> Muad_Dib: not if you spend hours writing unit tests;)
23:24:42 <sieni> newsham: how?
23:24:43 <shapr> emertens: Or you could write QuickCheck tests, which are better than unit tests.
23:24:46 * lispy tries to use lots of unit tests with his haskell code too
23:24:48 <newsham> *shrug* i understand the utility of compile time type checking, but for small programs I just about never chase down typing bugs.
23:25:00 <dons> unit tests are just approximations of a type system anyway
23:25:04 <emertens> shapr: I guess you missed the implied joke
23:25:16 <shapr> emertens: Ah sorry
23:25:19 <shapr> I'm past bedtime
23:25:30 <emertens> I'll try harder, it's late
23:25:33 <emertens> (for most people)
23:25:41 <lispy> dons: i think you mean, unit tests can be used as an approximation, but i think..they can do more than the type system in some cases
23:25:57 <newsham> *shrug* i'm not trying to convince anyone, i just found that true in my experience and was wondreing if i'm the only one.
23:26:00 <shapr> Anyway, I still write Python as quickly as I did before, but my Haskell output is faster and higher quality.
23:26:02 <emertens> sure, they can also test functionality
23:26:06 <Korollary> newsham: You're not the only one.
23:26:06 <dons> they're used as an approximation, but yes, can test runtime things that you'd need dependent types for.
23:26:27 <newsham> shapr: i hope some day thats true for me :)
23:26:29 <bringert> lispy: current lambdaweb at http://darcs.haskell.org/lambdaweb/ adds scrolling history
23:26:30 <lambdabot> Title: Index of /lambdaweb
23:26:36 <lispy> bringert: cool
23:26:40 <dons> so a type check + unit tests for what remains, is always going to be less work than writing only unit tests to check the same thing
23:26:40 <shapr> Actually, my Python is better because of Haskell, I can do fun stuff with nested list comprehensions these days :-)
23:26:43 <lispy> bringert: i need some downtime to get caught up
23:27:04 <lispy> bringert: i've been busy since last night...but probably tomorrow evening i'll get synced up
23:27:18 <newsham> shapr: yah, i learned a lot jus tlearning haskell and much of it translated back to my python code
23:27:22 <dons> bringert, lispy: I notce that the ruby website has an embedded 'try ruby in your browser' page ....
23:27:24 <lispy> dons: definitely
23:27:37 <dons> maybe we could have a try haskell online page too? using just the #run interface
23:27:48 <lispy> dons: that's a good idea
23:27:56 <bringert> lispy: no problem, just thought I'd let you know since you said you wanted it
23:27:56 <shapr> newsham: One thing that made a big difference for me was to write a chunk of Haskell on my own, and then drop by #haskell and asking the gurus to critique my code. I often ended up with a quarter of the beginning line count after those sessions.
23:28:14 <bringert> dons: yeah, that would be really nice
23:28:20 <lispy> dons: do you think we could extend run to take multiline input and possibly allow function definitions (so sort of like editing a file with an implicit main)
23:28:21 <newsham> shapr: yah, several people have helped me out in that way.
23:28:23 <emertens> Fore!!
23:28:28 <lispy> bringert: yeah, very cool
23:28:31 <shapr> newsham: Another thing that helped was to read rabhi & lapalme's functional algorithms book.
23:28:35 <lispy> bringert: i can't wait to get it up and working
23:28:37 <Korollary> newsham: One should also ask "Why am I writing these *small* programs?"
23:28:55 <lispy> bringert: i emailed SimonM and asked if he could set me up with the ability to push patches
23:28:57 <newsham> kor: I am not sure I understand what you're saying
23:29:15 <bringert> lispy: great. I told him today that you would
23:29:24 <lispy> bringert: heh, cool
23:29:33 <shapr> Rabhi & Lapalme describe the Burstall & Darlington rewriting system. I was totally unfamiliar with such system before reading that book. Afterwards both my Haskell and Python outputs were more efficient.
23:29:54 <bringert> lispy: I haven't tested it in all browsers, since my local bot.fcgi isn't cooperating (some GHC HEAD / hs-plugins interaction or something), but it probably works
23:29:55 <Korollary> newsham: Most small programs are also not so important. I think what matters is languages that help writing large programs.
23:30:09 <lispy> bringert: okay
23:30:21 <lispy> bringert: i wonder if i should give you shell on the codersbase server
23:30:59 <bringert> lispy: if you want, it's up to you.
23:31:16 <lispy> bringert: i was just thinking it might help when you want to test things
23:31:38 <lispy> but i should really go to bed...
23:31:46 <shapr> Korollary: I dunno, sysadmins write a bunch of small programs that get a lot of use.
23:31:57 <shapr> And users tend to write small utilities as well.
23:32:07 <newsham> kor: depends on what you do.   I don't often write large applications.
23:32:09 <bringert> it would yeah, my web host doesn't have ghc. no hurry though, I won't have time to do anything with it until monday at the earliest I think
23:32:16 <lispy> Korollary: i've thought about that recently...I wonder if large programs are only large because the language describing them is not well suited (or tailored) for describing them
23:32:19 <newsham> I write a lot of one-off utility and a few small tools
23:32:29 <newsham> i very occasionally work on larger applications
23:32:56 <Korollary> lispy: I didn't mean accidentally large. I meant inherently large, like browsers, editors, OS, etc.
23:32:57 <lispy> bringert: okay, if i set you up is bringert  your preferred username?
23:33:11 <lispy> Korollary: so do it
23:33:29 <bringert> lispy: yes
23:33:29 <Korollary> lispy: Heh. I am, in C++.
23:33:35 <newsham> browsers and large editors are pretty stupid things to write anyway ;-)
23:33:35 <lispy> Korollary: maybe we should bring our languages up to problem domain more often
23:33:49 <lispy> Korollary: er, i meant "so do i" ;)
23:33:58 <Korollary> oh ok
23:33:59 <newsham> i'm not a big fan of large all-inclusive programs.
23:34:05 <Korollary> dvorak doesn't seem to like you.
23:34:13 <newsham> i'm a devotee of the unix philosophy of composable tools
23:34:16 <shapr> Though you could say that an OS is an all-inclusive program.
23:34:34 <shapr> I'd like to try an exokernel system.
23:34:40 <newsham> shapr: not all OS's are large or all-inclusive.
23:35:03 <shapr> Yeah, but an exokernel would give you the best of both worlds.
23:35:09 <shapr> Aanyway, I should be sleeping.
23:35:24 <shapr> lispy: I agree with you, I think DSLs are the solution to large programs.
23:35:27 <lispy> shapr: i once got access to the cvs repo for the exo kernel...but i couldn't get it installed
23:35:37 * lispy should sleep as well
23:35:44 <newsham> isnt the cvs repo still up?
23:35:56 <lispy> probably, but i remember it taking me a lot of searching to find it
23:36:20 <lispy> they also never fixed a lot of theortical problems
23:36:28 <newsham> :pserver:anoncvs@cvs.pdos.lcs.mit.edu:/cvs
23:36:36 <lispy> so as i understand it, no one knows if it's really possible to use it for real work
23:36:46 <newsham> repository "exopc"
23:36:57 <lispy> i see your search-fu is strong
23:37:07 <newsham> nah, i just have it checked out on my drive already
23:37:16 <newsham> more /path/expoc/CVS/R*
23:37:35 <lispy> haha
23:37:49 <lispy> anyway, good night!
23:37:57 <newsham> so where can I read about this Burstall Darlington rewriting system?
23:42:09 <dons> SamB: around?
23:42:32 <dons> xerox, SamB, where's the Parsec+ByteString stuff kept these days?
23:43:32 <dons> newsham: how'd the fuzzing stuff go?
23:45:31 <newsham> dons: they're being slow putting it up, but should be up soon
23:45:55 <dons> so you've managed to sell the haskell solution to your coworkers?
23:46:50 <newsham> well, we'll see if people use it,  i've been using it regularly myself.
23:47:10 <gour> newsham: http://www.iro.umontreal.ca/~lapalme/Algorithms-functional.html is the book B-D r.s.
23:47:14 <lambdabot> Title: Algorithms: A Functional Programming Approach, http://tinyurl.com/gqjxq
23:47:53 <newsham> gour: no papers or wikipedia or anything i can read no for free?
23:48:44 <gour> newsham: don't know. i have a book, although it is still on my todo. ask shapr. he should know
