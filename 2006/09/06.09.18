00:00:03 <dons> i.e. as a preprocessor or something?
00:00:14 <edwardk> not yet i don't think.
00:00:15 <lispy> no
00:00:25 <edwardk> from the sounds of it she doesn't have it even type checking, etc.
00:00:43 <lispy> dons: it needs a syntax extension, in needs to propagate and it needs a theorem prover
00:00:46 <edwardk> so it sounds like it needs a bit of work to attach to an existing framework
00:01:18 <edwardk> but it is totally worth hacking on when it becomes available, IMHO
00:01:41 <edwardk> is right up there with quickcheck to me
00:01:47 <dons> wkh: most known haskell code is in http://haskell.org under 'libraries and tools' that's a good place to start looking
00:01:50 <lambdabot> Title: Haskell - HaskellWiki
00:02:03 <dons> there's some examples just for looking at on the 'Example code' link from the front page too
00:02:18 <edwardk> ok, for the hpc talk, they covered how you can use it to interactively control quickcheck
00:02:28 <dons> an good
00:02:39 <edwardk> and get it to run some cases, and check to see how much coverage you have had, and then have it run more cases if thats not enough, etc.
00:02:50 <dons> nice
00:03:10 <dons> now, do we have anything better than "someone stood up and talked about the galois haskell program coverage tool" ?
00:03:12 <edwardk> and the notion of looking at the difference in the coverage sets between a good run and a bad run to try to isolate bugs
00:03:18 <lispy> it was really cool to get a lecture from Oleg showing a proof by example that the haskell type system is turing complete
00:03:28 <edwardk> oh yeah
00:03:33 <dons> oh, Oleg gave a demo?
00:03:38 <edwardk> oleg gave a 5 line type system lambda calculus
00:03:48 <edwardk> and a 6 line type level fibonacci, etc.
00:03:53 <edwardk> to help plug the gap
00:04:08 <dons> ok. using the stuff he sent to the mailing list a couple of days ago?
00:04:15 <edwardk> basically covered a bunch of stuff he said he sent out thursday
00:04:20 <dons> right ok.
00:04:24 <edwardk> yeah
00:04:36 <edwardk> was funny watching the audience stare like deer caught in headlights ;)
00:04:53 <edwardk> oleg has a funny effect on a crowd =)
00:05:01 <dons> hehe
00:05:02 <dons> he's fun
00:05:07 <edwardk> yeah
00:05:13 <edwardk> talked to him about my type level stuff
00:05:22 <dons> ah right, any insights?
00:05:50 <edwardk> he explained the weird bug i had with moving one of my type annotations changing the compilability of my code
00:06:01 <edwardk> so that was good. =)
00:06:07 <lispy> it seemed like oleg was annoyed by people making 'claims' about what you cannot express with typeclasses...and he just wanted to set the record straight
00:06:12 <edwardk> otherwise he basically confirmed my intuition
00:06:16 <edwardk> yeah
00:06:44 <lispy> it was very fascinating to hear him explain it
00:06:50 <dons> i.e. that you can do anything on the type level :)
00:06:55 <lispy> yeah
00:07:07 <lispy> his type level code looked a lot like lisp to me :)
00:07:07 <dons> if you possess enough meta-olegs
00:07:13 <edwardk> hehehe
00:07:40 <edwardk> this is why i prefer pure type systems, type level programming is too hard
00:07:45 <lispy> he made the point that if it compiles then you know  your program will terminate :)
00:07:48 <edwardk> it shouldn't be harder than coding normally
00:07:49 <edwardk> heheh
00:07:50 <edwardk> yeah
00:08:03 <edwardk> that was cc shan's comment
00:08:15 <edwardk> that it seemed that programmers should prefer to
00:08:25 <edwardk> check everything at compile time
00:08:27 <dons> bring on the type functions, I say.
00:08:46 <dons> i think its an emerging consensus that we want normal functional style on the type level
00:08:48 <edwardk> so you should code entirely in the type level (somewhat tngue in cheek) only going down to the term level when absolutely necessary
00:08:58 <dons> mm. interesting
00:09:01 <lispy> someone commented that programming at the type level is untyped though...
00:09:16 <dons> yeah, not enough kind richness
00:09:17 <edwardk> so oleg cracked a joke that it gave a very nice property that you know that then if your program compiles, it will terminate ;)
00:09:26 <dons> heh
00:09:35 <edwardk> and yeah, the type level is fairly basically typed, only kind annotations and those are pretty weak
00:10:08 <edwardk> (* -> *) -> (* -> *) -> * and its ilk are not all that great as building blocks ;)
00:10:35 <lispy> ah, the poor man's prolog as you called it edwardk
00:10:40 <edwardk> yeah
00:11:01 <edwardk> i think that was original audrey or dons here on channel. I just stole it ;)
00:11:47 <lispy> geez...it's late
00:11:51 <edwardk> yeah
00:11:53 <lispy> stupid working in the morning...
00:12:10 <lispy> > join (*) 2
00:12:11 <lambdabot>  4
00:12:31 <lispy> ?type ap
00:12:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
00:12:45 <lispy> ?type ap (*)
00:12:46 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
00:12:55 <lispy> ?type ap (*) (+) 2
00:12:57 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
00:12:57 <lambdabot>    Expected type: (t -> t1) -> t -> t1
00:13:13 <lispy> > ap (*) (+1) 2
00:13:15 <lambdabot>  6
00:13:31 <edwardk> trying to get some sleep
00:13:32 <edwardk> so
00:13:36 <edwardk> have a nice night folks
00:14:25 <lispy> night
00:20:20 <dcoutts__> dons: I've got working zlib and bzlib bindings now :-)
00:20:37 <dcoutts__> dons: lack of wireless has some advantages, fewer distractions
00:21:16 <dons> nice!
00:21:27 <dcoutts__> I need some advice on naming etc
00:21:50 <dcoutts__> both libs have some naming confusion
00:22:22 <dcoutts__> they're called zlib & bzlib(2) but they provide the gzip and bzip(2) compression formats
00:22:34 <dons> hmm ok
00:22:36 <dcoutts__> and zlib provides two other formats too
00:22:40 <dons> oh
00:22:50 <dcoutts__> zlib provides "zlib" and "raw" deflate formats
00:23:16 <dcoutts__> zlib and gzip formats are header + checksum wrappers around a raw deflate data stream
00:24:36 <dons> hmm ok.
00:24:37 <dcoutts__> so I thought the packages should perhaps be "zlib" and "bzlib" and the modules Codec.Compression.(GZip,Zlib,Zlib.Raw,BZip)
00:25:54 <dons> that sounds ok.
00:26:10 <dons> oh, what's the diff between GZip and Zlib?
00:26:16 <dons> is that zip versus gzip?
00:26:21 <dcoutts__> no
00:26:30 <dcoutts__> zlib format is a minimal header + checksum
00:26:38 <dcoutts__> 8 bytes overhead or so
00:26:40 <dons> ah
00:26:53 <dcoutts__> gzip has a much bigger header
00:27:10 <dcoutts__> including original file name, OS, comment etc
00:27:16 <dcoutts__> it's the .gz format
00:27:32 <dcoutts__> zlib is usually used in memory or in network protocols
00:28:09 <dcoutts__> eg http can use either gzip or zlib wrappers around deflate
00:28:23 <dons> hmm in memory eh?
00:28:26 <dcoutts__> (though apparently MS mis-implemented the zlib one as raw)
00:28:26 <dons> sounds _useful_
00:28:40 * dons imagines transparently compressed ByteStrings...
00:28:59 <dcoutts__> hmm
00:29:12 <dons> and a NewBinary that is Binary + compressed
00:29:23 <dcoutts__> aye, that's certainly useful
00:29:34 <dcoutts__> though no random access
00:30:03 <dcoutts__> which means lazy deserialisation is less easy
00:33:29 <dcoutts__> the other api decision is if there should be one zlib/gzip module with the format as a parameter, or if there should be the 3 modules for the three formats
00:33:47 <dcoutts__> currently I've got 3 modules which call one internal function with a format parameter
00:34:14 <dcoutts__> the internal module is exposed too and allows more control over compression/decompression parameters
00:35:00 <dcoutts__> but I expect each of the three should provide a compression function with an extra compression level parameter
00:35:37 <dcoutts__> so I've currently just got compress, decompress :: ByteString -> ByteString
00:36:09 <dcoutts__> so one could add compressThingie :: CompressionLevel -> ByteString -> ByteString
00:36:17 <dcoutts__> and what should that be called ?
00:37:41 <kzm> mkCompressor?
00:37:58 <dons> mm. compressWith :: Int -> ....
00:38:09 <dons> compresWith :: Level -> ...
00:40:42 <dons> does anyone know who presented the Haskell Program Coverage demo at the workshop today?
00:41:04 <lispy> mallcom wallace maybe?
00:41:15 <lispy> tall thin guy with long hair
00:41:28 <dons> the one that interactively controls QuickCheck?
00:41:49 <dons> hmm. there's lots of tall thing guys with long hair the haskell community :)
00:42:50 <dcoutts__> heh heh
00:43:00 <dcoutts__> compressWith, aye, that'll do
00:43:22 * dons points at dcoutts, for example
00:43:34 <dcoutts__> who me?
00:43:50 <dcoutts__> @arr
00:43:51 <lambdabot> Aye
00:44:07 <dons> the bot knows all
00:47:25 <lispy> it was fun to be standing around poeple not knowing them, then tell someone i'm lispy and have one or two people go, "Oh!  hi.  i'm..."
00:47:55 <dons> heh
00:48:02 <lispy> dons: i think it was a tall thin guy from galois with long hair :)
00:48:53 <lispy> anyway, i'm asleep :)
00:48:57 <lispy> ttyl
00:49:27 <dons> night
01:48:37 <bartw> hmz, nobody at work seems to know what haskell is
01:52:23 <bartw> i think they will be even less pleased with haskell then with the asm :)
01:56:02 <dons> oh hmm
01:56:10 <dons> you need to enlighten them. its the way of the future
01:56:36 <dons> they'll surely be pleased if you can write tools and get the job done faster, and with less bugs, then before..
01:56:46 <dons> (results speak for themselves)
02:14:05 <musasabi> given "data T Int Bool" and "unT f (T a b) = f a b" how do I infer the type of "f" from T+unT?
02:15:42 <dons> ?type let unT f ((,) (a::Int) (b::Bool)) = f a b in unT
02:15:44 <lambdabot> forall t. (Int -> Bool -> t) -> (Int, Bool) -> t
02:16:21 <musasabi> dons: with a fundep.
02:17:08 <dons> ah
02:17:16 <dcoutts__> dons: can you think of any case where transparently compressing a bs would actually be beneficial?
02:17:30 <dcoutts__> perhaps some kind of in-memory db
02:17:32 <dons> I was thinking of some kind of tight limit small heap system
02:17:37 <dons> yeah, ram disk?
02:17:40 <musasabi> The end type of unT is problematic.
02:18:03 <dons> dcoutts__: or say, a crypto file system..
02:18:19 <dcoutts__> mm, compress then encrypt
02:19:07 <dcoutts__> I was looking to see if it's possible to use ghc's heap to allocate the zlib structures
02:19:21 <dons> haskell weekly news out, http://sequence.complete.org/
02:19:21 <dcoutts__> both zlib and bzlib allow you to use your own allocation functions
02:19:25 <dcoutts__> oh cool
02:19:32 <musasabi> encryption is usually in IO because of using random stuff.
02:20:11 <dcoutts__> musasabi: but surely one just needs a seed or entropy pool, then it's pure
02:20:28 <musasabi> Thus decrypt/encrypt = id, but encrypt x /= encrypt x.
02:21:09 <musasabi> dcoutts__: I don't think that using System.Random is a good way for random numbers suited for crypto.
02:21:37 <dcoutts__> musasabi: I can believe that, but the point about purity is independent
02:22:13 <mux> hello
02:22:29 <musasabi> But given identical random sources encryption is pure.
02:23:07 <mux> dons: got time to look at those patches?
02:23:12 <dcoutts__> dons: broken link in the SOE news item
02:23:33 <dcoutts__> "available" link
02:24:32 <dons> oops
02:26:31 <dons> mux, I wrote a reply, did you get it?
02:26:55 <dcoutts__> oh Lemmih was ill and couldn't talk at the HW :-( that's a shame
02:26:57 <dcoutts__> poor Lemmih
02:29:27 <dcoutts__> dons: nice HWN :-)
02:29:31 <dcoutts__> lots of fun stuff
02:30:14 <dons> :)
02:30:40 <dons> just a bit late. but now the whole process is fulling automated, so it _should_ be easier to get it out weekly now
02:32:16 <mux> dons: didn't see it yet, let me browse my ~90k mails inbox
02:32:20 <dons> heh
02:32:32 <mux> I have it indeed
02:32:38 <mux> didn't know your name was actually Donald!
02:32:44 <Lunar^> Igloo: congrats!
02:33:05 <dons> why do people keep saying that?
02:33:16 <dons> Igloo was at me about my middle name last week. very weird
02:33:47 * dons changes name to 'dons of the lambda'
02:33:51 <Lunar^> dons: because he's going full time to work on debian better packages? ;)
02:34:10 <bartw> blegh, integers with additional meanings
02:34:15 <Lunar^> dons: btw, talking about Debian packages, we have a problem with hs-plugins
02:34:20 <dons> oh yes?
02:34:39 <Lunar^> dons: currenly, you are using tex2page to generated an html version of your TeX report
02:34:44 <Lunar^> -d
02:35:04 <Lunar^> dons: tex2page is part of mzscheme which does not build on all Debian architecture
02:35:06 <dons> right. but there's no need to do that.
02:35:11 <mux> dons: so, you like the idea of having a function to transform the IRC output filters?
02:35:19 <dons> Lunar^, don't build the docs then?
02:35:24 <dons> mux, yes.
02:35:27 <Lunar^> dons: Do you think it is possible to use latex2html or hevea instead?
02:35:49 <dons> I think we could just keep the haddock docs
02:35:54 <dons> and point people to the website for more info
02:36:05 <dons> yeah, or maybe just run latex2html over the src
02:36:10 <mux> dons: as for the name of the method, I'm always lame to find good names so if you have any suggestion I'll take it
02:36:11 <dons> if you really need the website docs
02:36:42 <Lunar^> dons: think about it for the next release... maybe include the generated doc directly or something similar
02:36:51 <dons> yep I will
02:36:57 <dons> (its switching to haddock anyway)
02:36:59 <Lunar^> thanks :)
02:37:10 <Lunar^> oh :) haddock is fine then
02:37:12 <mux> dons: also, you say you're not sure about ircPrivmsgFilters - which I can certainly understand, how would you suggest doing this in that case?
02:37:41 <dons> I was thinking we just apply whatever function, id, or otherwise, a module registers as its output filter.
02:38:37 <mux> yes, but we don't want to do this for any irvPrivmsg in the code, do we? that's why I created a separate function to call once we got the output of a module through process or processs_
02:38:57 <dcoutts__> Lemmih's beakpoint paper looks cool, I've got to try it out. It work now in current ghc-6.5 versions right?
02:39:08 <dons> yeah I think so
02:39:36 <mux> and since we don't have access to the module in ircPrivmsg...
02:40:00 <mux> we wouldn't be able to actually call the appropriate method
02:40:35 <dons> no, ircPrivmsgs are essentially unfiltered
02:45:17 <mux> dons: you got me lost here, ircPrivmsg applies the output filters from the state
02:45:36 <dons> ah do I mean ircPrivmsg' ?
02:45:44 <mux> yeah, ircPrivmsg' is unfiltered
02:47:47 <mux> so this is why I created ircPrivmsgFilters
02:48:13 <mux> it allows to apply the module filters tranformation function when we're going to send some output from a module
02:49:12 <mux> in Plugin/Base.hs
02:50:11 <dons> right ok.
02:50:23 <mux> not particularly pretty but I couldn't think of a better way
02:50:28 <dons> so any changes you want to make to the patch you sent me?
02:50:36 <dons> otherwise i'll apply them, and proceed from there.
02:50:45 <mux> we should rename moduleWithOF
02:50:47 <mux> the name really sucks
02:50:51 <mux> moduleFiltersAdjust ?
02:51:51 <mux> that and the (\_ -> []) in the Figlet module could advantageously be renamed to const []
02:52:14 <dons> moduleFilters is ok with me
02:52:51 <mux> it does not make it explicit that this is a transformation functions and not just a method to supply some module's filter(s)
02:53:03 <mux> but I don't mind that if that's OK with you
02:53:33 <mux> do you want me to re-send an updated patch with the rename or is it OK?
02:53:47 <dons> no its ok. if that's it, i'll just apply the patches you sent me.
03:00:12 <mux> dons: cool, thanks
03:00:21 * mux can't wait to send figlet commands to lambdabot :-)
03:01:11 <bartw> how do you avoid causing lambdabot to run a too long task ?
03:08:40 <SamB> bartw: it kills them if they run too long
03:08:56 <SamB> well, in the case of @run
03:09:43 <SamB> some other things, like @pl, have a limited amount of "gas"...
03:09:57 <bartw> i remeber bots on other channels, they were allways very vunerable too too long running tasks
03:10:30 <bartw> hwo do you do async interupts in haskell ?
03:11:01 <SamB> @google "RunPlugs.hs"
03:11:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/lambdabot.cabal.ghc-6.6
03:11:06 <SamB> h,,
03:11:08 <SamB> er, hmm
03:11:34 <SamB> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
03:11:36 <lambdabot> http://tinyurl.com/h7nko
03:11:45 <SamB> bartw: look at that ;-)
03:12:17 <bartw> letssee
03:13:31 <bartw> hmz, so the monad limits it ?
03:14:32 <SamB> actually I think that is just a call to setrlimit
03:14:56 <bartw> ah you let the os handle it ?
03:15:22 <SamB> uh huh ;-)
03:15:33 <bartw> thats almost cheating :)
03:19:02 <SamB> @pl uses a different technique
03:19:03 <lambdabot> uses a different technique
03:19:07 <SamB> heh
03:25:22 <ibid> dons:
03:25:22 <ibid>   17. http://haskell.org/~duncan/gtk2hs/SOE-cairo.png
03:25:22 <ibid>      * The experimental GHCi debugger . Pepe [18]announced the results of
03:25:24 <lambdabot> http://tinyurl.com/zvqry
03:25:32 <ibid> gag!
03:25:42 <ibid> i only tried to paste the 17. line :)
03:26:01 <ibid> gah again
03:26:08 <ibid> 16. line is what i tried
03:26:14 <ibid> i see it has been discussed already
03:26:20 <ibid> please forget i said anything :)
03:28:54 <dons> ibid: yeah, there was a borken link
03:28:59 <dons> i need a tool to check those things :)
03:30:52 * SamB hears heavy disk activity, that sounds like swapping, but is happy to see that it is probably just the locatedb being rebuilt...
03:31:46 <ibid> dons: what tools do you currently use ?
03:33:20 * mux repeatedly calls darcs pull waiting for his patches to appear in the lambdabot repository :-)
03:33:56 <dons> ibid: scripts to spell check, type set and some other things, but not link checking
03:34:07 <dons> mux, having dinner now. maybe after that, else in the morning
03:36:18 <mux> dons: ok :)
03:37:25 <SamB> but this *is* the morning!
03:38:36 <dons> i've told you before about this round earth issue, SamB
03:38:49 <SamB> hehe ;-P
03:39:06 <tomshackell> hi dons
03:39:42 <dons> hey tomshackell
03:40:07 <tomshackell> dons: it might be useful to have a conversation about Yhc and hsplugins at some point, since i think Yhc now has the necessary features.
03:40:16 <dons> ah right. I saw the email
03:40:21 <dons> looked very interesting
03:40:48 <tomshackell> was that cedric's email?
03:41:02 <dons> one last night or yesterday?
03:41:04 * SamB supposes this would involve less hacks than with GHC has in the past?
03:41:21 <dons> yeah, i reckon.
03:42:00 <tomshackell> his email reminded me of it and I remember that you needed concurrency and runtime reflection, both of which Yhc now has.
03:43:34 <dons> ah hmm!
03:45:52 <tomshackell> the only problem is likely to be if you're using a lot of non-haskell98 ...
03:46:44 <dons> shouldn't be a lot no. just concurrency mostly (not type system things)
03:46:58 <tomshackell> it should be fine then :-)
03:51:45 <SamB> does Yhc have Data.Dynamic?
03:52:50 <tomshackell> not as yet, it's a bit of a problem because for my own work I actually need more than Data.Dynamic can provide (in particular allowing polymorphism). So I haven't decided whether to implement Data.Dynamic+ or implement something else and write Data.Dynamic with it ...
03:53:42 <SamB> I'd think the latter...
03:54:48 <tomshackell> *nods* it seems the more sensible option. Has anyone written an "extended Data.Dynamic" for GHC, which just hasn't made it into the base yet?
03:55:00 <SamB> I've looked at Typeable's interface and it didn't seem like it would be at all simple to add polymorphism...
03:55:25 <dons> its not simple at all.
03:55:45 <dons> there's a lot of research on the problems of polymporphic dynamics in statically typed langs
03:55:47 <tomshackell> no the problem is it's written as a class.
03:56:08 <tomshackell> if you had getType :: a -> TypeRep as a builtin function, it'd be easier.
03:56:08 <SamB> oh
03:56:22 <dons> yeah, you need runtime support
03:56:36 <dons> and to do it properly you've got to invoke the type checker to compare TypeReps
03:56:45 <SamB> true enough!
03:56:46 <dons> (i.e. to handle tyvars, classes, existentials, GADTs ...
03:56:55 <SamB> oh wow
03:57:14 <tomshackell> *nods* it's a bit of a nightmare :-)
03:57:15 <dons> just doing TypeRep "Int" == TypeRep "Int" at runtime only works so far .. :)
03:57:23 <SamB> wouldn't you need to get the compiler in there too to glue things together?
03:57:33 <dons> yeah, splicing becomes an issue
03:57:53 <dons> though Clean does it: using a imited runtime type checker, and bytecode with fully type reps
03:58:11 <dons> s/full type reps/, including tyvars and class constraints
03:58:52 <tomshackell> *nods* I was going to add typereps to the Yhc bytecode ... though there are still some issues ... consider
03:58:52 <tomshackell> let x = undefined :: Int -> Int
03:58:52 <tomshackell> type <- getTypeRep x
03:58:52 <tomshackell> do you get (Int -> Int) or a (the type of undefined)?
04:00:47 <SamB> good point -- heap objects don't have types, expressions do...
04:01:19 <tomshackell> *nods* an if you just look at an undefined node in the heap it'll tell you it was declared with type 'a', but that might not be what you want.
04:03:03 <tomshackell> in which case if you want Int -> Int then you have to get the compiler to generate the type of it for you (and not the runtime).
04:03:45 <SamB> don't forget newtypes!
04:04:44 <SamB> anyway... I don't think even *trying* to pull stuff off the heap is a good idea...
04:04:50 <tomshackell> exactly ... nightmare!
04:05:10 <SamB> perhaps hacking in a wierd typeclass that everything is an instance of would work better?
04:06:00 <SamB> ... or, something to somehow give you an excuse to get stuff from the typechecker...
04:07:20 <tomshackell> *nods* a warped typeclass it probably easiest, but it's still horrible.
04:07:23 <SamB> in any case Data.Dynamic would not be too hard to port fairly directly, afaict.
04:08:06 <SamB> not that it would help you or anything.
04:09:53 <tomshackell> *nods* I guess you really end up wanting a typeof operator (a bit like sizeof in C).
04:10:08 <SamB> hmm
04:10:26 <SamB> yeah.
04:11:02 <SamB> but how?
04:11:51 <tomshackell> hack it into the compiler as a keyword, just like 'case' or 'if then else'
04:11:53 <SamB> oh, and would it work on stuff that got passed to polymorphic functions?
04:12:17 <tomshackell> and it's meaning would be "calculate the type of this at compile time and give me a representation of it".
04:12:42 <SamB> its all very dizzying
04:12:45 <tomshackell> indeed.
04:13:09 <tomshackell> anyhow I'll give it a try and let you know how it goes ;-)
04:13:40 <SamB> ... which is probably why nobody has done it yet
04:14:30 <tomshackell> well it's not *too* bad ... the compiler does know the type of everything so you just need it to replace 'typeof x' with a bunch of constructor code that builds the right type rep ..
04:14:42 <SamB> mmm
04:14:57 <SamB> what happens if I write, say...
04:15:57 <SamB> f :: [a] -> TypeRep
04:16:34 <SamB> f xs = typeof# xs
04:17:20 <tomshackell> always returns [a]
04:17:24 <SamB> but.
04:17:35 <SamB> usually you haven't passed one of those in!
04:17:51 <SamB> say, what happens if I pass in a String?
04:17:57 <tomshackell> [a]
04:18:08 <SamB> ... doesn't that seem kind of dangerous to you?
04:18:52 <tomshackell> perhaps but whatever you choose it's wrong in some circumstance, since there's a choice: do you want the compile time type or the runtime type?
04:20:07 <SamB> hmm
04:21:33 <SamB> anyway, only having it work on monomorphic types isn't much of a price to pay for sanity...
04:22:12 * SamB wonders what the difference between the type of xs in that function and the type of [] is...
04:23:10 <tomshackell> lol :-)
04:23:25 <SamB> there is one, but, I don't know how to express it
04:23:59 <tomshackell> one what?
04:24:15 <SamB> difference between the type of xs in that function and the type of []...
04:26:09 <bartw> so what is the type of [] ?
04:26:15 <bartw> [] ?
04:27:05 <tomshackell> data [a] = [] | a : [a]
04:27:34 <tomshackell> the type of [] is thus, surely, [a]
04:27:54 <bartw> shouldn't the type be concrete ?
04:28:32 <tomshackell> ghci: :t []
04:28:32 <bartw> [] being a value and [a] being the type ?
04:28:32 <tomshackell> [] :: [a]
04:28:38 <bartw> right
04:29:04 <bartw> so it matches any actaul [x] type like [Int]
04:29:10 <tomshackell> indeed :-)
04:29:28 <bartw> nice, now how do i get this to work in an imperative oo environment ;)
04:29:48 <bartw> the type of 'nil' allwasy bothered me
04:30:16 <tomshackell> in an imperative oo environment you just fudge your type system so that it "works" ;-)
04:30:33 <bartw> this seems like a potential bit of 'unfudge'
04:31:07 <xerox> And you haven't seen typeclasses yet! (Have you?)
04:31:21 <bartw> i haven't
04:31:29 <tomshackell> fun for all the family ...
04:31:39 <xerox> A.k.a. polymorphism done right.
04:31:57 <bartw> meh, i might have to delay work on my compiler till i know some more haskell it seems
04:33:54 <tomshackell> bartw: what's your preferred OO language?
04:34:06 <zapilla> i miss writing haskell!
04:34:13 <zapilla> maybe i should take it up again
04:34:37 <bartw> tomshackell : i guess java minus alot of those new libs
04:35:14 <xerox> ?karma Java
04:35:14 <lambdabot> Java has a karma of -2
04:35:16 <bartw> something to be said for a simple eveyrhting is a ref to an object thing
04:35:55 <tomshackell> right in Java isn't it plain annoying that suppose you create an new interface Wibbler and you want to say that java.lang.String is a Wibbler and define how it 'wibbles' ... but you can't ...
04:36:02 <bartw> altough a bit lacking in the power department imho
04:36:49 <bartw> yes it is annoying that those api's are so 'closed'
04:36:58 <tomshackell> but with Haskell typeclasses you can ...
04:37:12 <lisppaste2> dibblego pasted "is there a cleaner way?" at http://paste.lisp.org/display/26240
04:37:15 <bartw> but in it's defence alot of other lib's also don't provide virtual methods
04:38:06 <tomshackell> instance Wibbler String where
04:38:06 <tomshackell>    wibble s = "String's wibble with "++s
04:38:06 <tomshackell> instance Wibbler Int where
04:38:06 <tomshackell>   wibble i = "Int's wibble with "++show i
04:38:06 <tomshackell> ... and so on ...
04:38:21 <bartw> to mitigate some of those issues i intend to add somethign i call strict aliasses and decorators to my own language
04:39:14 <bartw> tomshackell : your problem with String is explicitly added to the string class by it's developers, if you make your own non final string class that iddue goed away.
04:39:28 <lisppaste2> dibblego pasted "is there a cleaner way?" at http://paste.lisp.org/display/26241
04:39:31 <bartw> s/d/s/
04:41:49 <bartw> ugh, and now to get some wisdom tooth pulled
04:43:17 <tomshackell> a Wibbler isn't much use but consider doing IO, suppose you're writing a new library that writes data to a file in some special way. Now it'd be nice to say anything that is an instance of "SpecialWritable" can be written to your file, but sadly you will never make java.lang.String or java.lang.int SpecialWritable .. and it doesn't help to say you can create a new class that does have the propety, because people want to write java.lang.Str
04:43:17 <tomshackell>  
04:49:42 <bartw> i intend to use decorators for something like this
04:50:36 <tomshackell> decorators?
04:51:49 <yacstud> a design pattern
04:55:06 * mux reads the new R6RS 5.91 report on the Scheme language
04:55:35 <tomshackell> *reads wikipedia* mmm but perhaps a nicer way is to say that defining what a type is an defining what you can do with a type are separate. It makes sense given OO's love for "modelling the real world". In the real world the properties of a piece of paper (it's size, it's weight, it's color) are well defined but the things you can do with a sheep of paper are infinite. You can fold a piece of paper into an aeroplane, but at the moment if yo
04:55:50 <tomshackell> s/sheep/sheet
04:56:20 <xerox> Cut at '..but at the moment if yo'
04:56:43 <tomshackell> gah useless gaim ..
04:56:51 <tomshackell> You can fold a piece of paper into an aeroplane, but at the moment if your Paper class designed didn't add a "fold into aeroplane" method then your paper will never be an aeroplane.
04:58:18 <tomshackell> s/designed/designer
04:58:22 <roconnor> newtype Mu a = Roll { unroll :: Mu a -> a } is totally awsome
04:58:45 <roconnor> let's hear it for non-monotonic data types.
05:00:27 <dons> roconnor: :D
05:01:19 <Ironmonk3y> http://yourprxy.com/TDOA.html
05:01:22 <Ironmonk3y> woops dont go there
05:01:32 <Ironmonk3y> NO that was meant to be my secret directoy
05:01:37 <Ironmonk3y> i work on stuff there damn
05:01:41 <tomshackell> lol
05:01:42 <Ironmonk3y> admin delete that message
05:01:49 <xerox> Admin?
05:01:53 <dons> hmm :/
05:01:58 <Ironmonk3y> isnt there one
05:02:14 <xerox> It's an irreversible process :(
05:02:19 <Ironmonk3y> well atleast theres not much content
05:02:20 <tomshackell> no plus it's in the history of everyone here ...
05:02:25 * deadbeef deletes that message
05:02:27 <deadbeef> Ironmonk3y: done
05:02:32 --- mode: ChanServ set +o dons
05:02:36 <deadbeef> now noone can read it
05:02:37 <Ironmonk3y> just a really good adsense ebook
05:02:38 <deadbeef> except you
05:02:42 <Ironmonk3y> LOL
05:02:43 <Ironmonk3y> funny
05:03:17 <xerox> dons got it right, I think.
05:03:20 --- kick: Ironmonk3y was kicked by dons (spammer)
05:03:26 --- mode: ChanServ set -o dons
05:03:33 <xerox> :(
05:03:36 <dons> just had to consider it for a sec
05:04:25 <xerox> ?keal
05:04:25 <lambdabot> and yes that was with zero formal training in all realms
05:04:30 <roconnor> oh, this bug makse GHC's _compiler_ diverge, not the generated code.  Wow
05:04:47 <xerox> hehe
05:04:55 <dons> hmm
05:05:08 --- mode: ChanServ set +o xerox
05:05:53 --- mode: xerox set +b *!*eversuns@*.au
05:06:06 --- kick: Ironmonk3y was kicked by xerox (xerox)
05:06:14 <dons> ok.
05:06:49 --- mode: xerox set -o xerox
05:06:59 <xerox> :-/
05:07:08 <roconnor> I wonder if non-monotonic data types are an underused programming idiom...
05:07:18 <xerox> Non-monotonic meaning what?
05:07:19 <dons> shrug. we're a big channel these days, xerox. in the top 10-20 on freenode
05:07:43 <xerox> ?users
05:07:49 <lambdabot> Maximum users seen in #haskell: 224, currently: 224 (100.0%), active: 20 (8.9%)
05:07:55 <xerox> hehe
05:09:13 <AstralStorm> Heh, max :>
05:09:15 <xerox> dons: beside these things, that's cool!
05:09:40 <dons> nah, not really. we hit 245 last week, but I zapped lambdabot's memory by accident
05:10:00 <xerox> I mean being in the top 10-20, hehe.
05:10:22 <dons> yeah, its pretty cool. something's working, thD[Dat's for sure.
05:10:26 <xerox> Even #haskell.it has a new peak ``Maximum users seen in #haskell.it: 5, currently: 5 (100.0%), active: 3 (60.0%)''
05:10:33 <dons> cool!
05:10:35 <xerox> :D
05:11:02 <dons> ?users #haskell.es
05:11:03 <lambdabot> Maximum users seen in #haskell.es: 7, currently: 5 (71.4%), active: 0 (0.0%)
05:11:07 <dons> ?users #haskell.it
05:11:08 <lambdabot> Maximum users seen in #haskell.it: 5, currently: 5 (100.0%), active: 3 (60.0%)
05:11:09 <xerox> Argh!
05:11:11 <dons> ?users #haskell.se
05:11:11 <lambdabot> Maximum users seen in #haskell.se: 9, currently: 8 (88.9%), active: 1 (12.5%)
05:11:24 <dons> those swedes. it's a conspiracy!
05:11:27 <xerox> .se > .es > .it ... I need to do more recruiting.
05:11:28 <dons> ?users #haskell_ru
05:11:29 <lambdabot> Maximum users seen in #haskell_ru: 1, currently: 1 (100.0%), active: 0 (0.0%)
05:11:43 <gmh33__> ?users haskell
05:11:44 <lambdabot> Maximum users seen in haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
05:11:51 <xerox> Nan% haha
05:11:52 <gmh33__> ?users #haskell
05:11:53 <lambdabot> Maximum users seen in #haskell: 224, currently: 224 (100.0%), active: 21 (9.4%)
05:12:15 <dons> ?users #gentoo-haskell
05:12:16 <lambdabot> Maximum users seen in #gentoo-haskell: 16, currently: 16 (100.0%), active: 3 (18.8%)
05:19:38 * Lemmih wonders when 'cabal-setup configure -w anyghc' started to fail.
05:20:05 <mux> dons: so, to get runplugs, I need hs-plugins which needs HSX, which in turn needs happy?
05:20:17 <dons> no no. no HSX.
05:20:28 <dons> you just need hs-plugins (grab the 1.0 release candidate)
05:20:31 <mux> hs-plugins was whining about a missing Hsx module or something
05:20:32 <mux> ah
05:20:36 <mux> I tried with 0.9.10 iirc
05:20:56 <mux> are you now using the Parsec module for parsing Haskell?
05:21:02 <mux> did you cabal-ize hs-plugins as well?
05:21:07 * mux goes to give the rc a try
05:21:28 <dons> its cabalised, yes.
05:21:31 <mux> cool
05:21:39 <dons> it parses with Language.Haskell, or HSX optionally
05:21:54 * mux rejoices
05:23:34 <mux> ah, great
05:23:58 <dons> it builds?
05:24:05 <mux> builds and installs OK
05:24:13 <dons> great
05:24:28 <mux> where am I supposed to find plugs/runplugs for lambdabot now?
05:27:55 <Lemmih> Anyone around got time to test if 'runhaskell Setup.lhs configure -w ghc' works with GHC <6.6?
05:29:19 <mux> for any package?
05:29:45 <gour> Lemmih: you mean something like 6.4.x or eg. 6.5_pre2006090x is ok?
05:29:46 <Lemmih> Yes.
05:29:56 <Lemmih> gour: Yes.
05:30:01 <mux> pentane% runhaskell Setup.lhs configure -w ghc             ~/haskell/hs-plugins
05:30:01 <mux> The field "hs-source-dir" is deprecated, please use hs-source-dirs.
05:30:01 <mux> Configuring plugins-1.0...
05:30:01 <mux> Setup.lhs: Cannot find package tool: ghc-pkg
05:30:09 <mux> GHC 6.4.2 FreeBSD/i386
05:30:22 <gour> Lemmih: i've ghc-6.5.20060912
05:30:43 <mux> presumably it's not looking for ghc-pkg in the correct place
05:32:52 <Lemmih> mux: What version of Cabal? (you can check with: /path/to/ghc-pkg field Cabal version)
05:33:01 <mux> 1.1.4
05:33:08 <Lemmih> Hm.
05:33:12 <bourbaki> moin
05:36:39 <gour> Lemmih: i tried with hdbus & cabal-1.1.5.9.3 and it works
05:37:38 * Lemmih is dumbfounded.
05:38:43 <gour> @where paste
05:38:44 <lambdabot> http://paste.lisp.org/new/haskell
05:39:10 <lisppaste2> gour pasted "runhaskell Setup.lhs configure output" at http://paste.lisp.org/display/26244
05:39:21 <gour> Lemmih: see ^^^
05:41:39 <sris> is there a function in the standard prelude that given an element can return it's index in a list?
05:41:56 <Cale> findIndex?
05:42:02 <Cale> @type findIndex
05:42:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
05:42:21 <xerox> @type findIndices -- also
05:42:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
05:42:38 <Cale> also, elemIndex, elemIndices
05:42:58 <Cale> actually, none of these are in the Prelude
05:43:02 <sris> is this prelude functions?
05:43:04 <Cale> they're all in Data.List :)
05:43:21 <Cale> (or just List in Haskell 98)
05:48:39 <dons> > findIndex (=='x') ['\0'..]
05:48:40 <lambdabot>  Just 120
05:51:38 <edwardk> Anyone awake yet in ICFP land?
05:54:49 <zapilla> it's a little early, no?
05:54:52 <Cale> > elemIndex 'x' ['\0'..]
05:54:53 <lambdabot>  Just 120
05:55:27 <zapilla> 6am?
05:55:40 <mux> dons: so, where can I find the runplugs binary for lambdabot?
05:56:02 <dons> build lambdabot with the lambdabot.cbal.plugins file, and it will be dumped into the `pwd`
05:56:12 <mux> oh, neatr
05:56:14 <mux> thanks
05:56:21 <dons> i.e. mv lambdabot.cabal.plugins to lambdabot.cabal, and ./bulid
05:56:29 <dons> modulo typos
05:56:51 <edwardk>  zap: yeah
05:57:27 <edwardk> zap: there is this thing called sleep. I confess to being only distantly familiar with it. I was wondering if anyone else out here was similarly afflicted ;)
05:57:49 <dolio> Heh. Too excited to get more than 6 hours?
05:58:15 <edwardk> Well, ...and my internal clock is still about 3 hours ahead.
05:58:21 <edwardk> but yeah
05:59:11 <edwardk> I've found surprisingly few people who know much about pure type system stuff though.
05:59:20 <edwardk> somewhat surprised by that
06:00:14 <mux> dons: mmm, I now have the runplugs binary, but lambdabot prints an error when trying to do a > command
06:00:20 <mux> 14:59 < lambdabot>    Failed to load interface for `ShowQ':
06:00:20 <mux> 14:59 < lambdabot>     Could not find module `Sho...
06:01:05 <mux> what am I missing again?
06:03:51 <profmakx> are you running it inside "bin"?
06:04:55 <mux> no, I copied everything I wanted to some specific place
06:05:05 <mux> but that doesn't look like a problem trying to find some binary anymore
06:05:08 <mux> this looks different.
06:06:41 <profmakx> I had the same problem
06:06:50 <profmakx> but i cannot remember how i solved it damn
06:07:28 <spookylukey> Can anyone tell me what this means: class Foo a b | a -> b   .  In English preferably ;-) tia
06:11:17 <spookylukey> anyone?
06:11:59 <sek_> > let nonEmpty = \Eq a => a -> (a/=[]) in nonEmpty [1]
06:12:00 <lambdabot>  Parse error
06:12:03 <AstralStorm> Hmm.
06:12:25 <sek_> where am i meant to put the Eq a here?
06:13:03 <spookylukey> sek_: do you need to put it in?
06:13:12 <sek_> its complaining
06:13:36 <sek_>     Ambiguous type variable `a' in the constraint:
06:13:36 <sek_>       `Eq a' arising from use of `/=' at PepaRateEquations.hs:658:27-28
06:13:37 <AstralStorm> > let nonEmpty = \a => Eq a -> (a/=[])   in nonEmpty [1]
06:13:37 <lambdabot>  Parse error
06:13:56 <xerox> sek_: nonempty = not . null
06:14:05 <AstralStorm> > let nonEmpty = \a (:: Eq a -> Bool) -> (a/=[])   in nonEmpty [1]
06:14:05 <lambdabot>  Parse error
06:14:08 <sek_> xerox yeah, this was just a test
06:14:10 <AstralStorm> > let nonEmpty = \a :: Eq a -> Bool) -> (a/=[])   in nonEmpty [1]
06:14:11 <lambdabot>  Parse error
06:14:37 <AstralStorm> > let nonEmpty = (\a -> (a/=[])) :: Eq a => a -> Bool   in nonEmpty [1]
06:14:38 <lambdabot>  a
06:14:38 <lambdabot>    Inferred type: [a1]
06:14:43 <profmakx> @version
06:14:44 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
06:14:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:15:26 <AstralStorm> No go :>
06:15:32 <sek_> heh
06:16:01 <AstralStorm> > let nonEmpty = (\a -> (a/=[])) :: Eq a => [a] -> Bool   in nonEmpty [1]
06:16:02 <lambdabot>  True
06:16:07 <AstralStorm> Now it's correct.
06:16:19 <mux> AstralStorm: nonEmpty = not . null
06:16:24 <AstralStorm> mux: I know P
06:16:29 <dcoutts__> @yarr!
06:16:30 <lambdabot> Yo ho ho, and a bottle of rum!
06:16:31 * dcoutts__ notes that tomorrow is International Talk A Pirate Day!
06:16:35 <mux> okay :)
06:16:37 <sek_> thanks AstralStorm
06:16:43 <mux> wanted to make your life easier!
06:16:55 <AstralStorm> Thanks :P
06:17:08 <AstralStorm> > let nonEmpty = not . null in nonEmpty 2
06:17:09 <lambdabot>  add an instance declaration for (Num [a])
06:17:14 <AstralStorm> > let nonEmpty = not . null in nonEmpty [2]
06:17:16 <lambdabot>  True
06:17:18 <AstralStorm> > let nonEmpty = not . null in nonEmpty []
06:17:20 <lambdabot>  False
06:17:22 <AstralStorm> :P
06:17:40 <AstralStorm> > let nonEmpty = (\a -> (a/=[])) :: Eq a => [a] -> Bool   in nonEmpty 2
06:17:41 <lambdabot>  add an instance declaration for (Num [a])
06:18:12 <AstralStorm> Everybody loves "descriptive" messages from ghc :P
06:18:32 <AstralStorm> Instead of saying "expected a list"
06:21:08 <sek_> is it bizzare that it pleases me to write complicated and incomprihensible code just so as to write 3 lines into 1?:p
06:21:36 <gds> sek_: You know about perl golf, right? ;)
06:21:51 <dcoutts__> sek_: it's a common afliction :-)
06:22:04 <sek_> gds just google'd it
06:22:37 <dcoutts__> one liners are particularly nice to stick in papers
06:22:52 * gds thinks this is another great advantage of the lambdabot - if we can sate our "complicated and incomprihensible" urges on one-liners in here, than none of it need ever get into production code ;)
06:23:01 <dcoutts__> heh
06:23:27 <sek_> im terribly in the mood for lambda functions today, heh
06:23:29 <profmakx> damn
06:23:56 <profmakx> is there any way to get more log out of lambdabot on connect?
06:25:38 <AstralStorm> @type .
06:25:40 <lambdabot> parse error on input `.'
06:25:44 <AstralStorm> @type (.)
06:25:45 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
06:27:09 <AstralStorm> Now that's perverse :>
06:27:38 <profmakx> -.-
06:27:54 <Cale> AstralStorm: hm?
06:28:12 <Cale> AstralStorm: it's exactly what you'd expect
06:30:09 <edwardk> spookylukey: did you ever get a response? saw your fundep question in scrollback
06:31:56 <edwardk> ' class Foo a b | a -> b' is a multiparameter type class with functional dependencies, in this case a -> b states that its second argument is uniquely determined by the first. This allows it to be used to describe a type level 'function' from a to b.
06:34:19 <spookylukey> > let
06:34:19 <lambdabot>  Parse error
06:42:18 <dons> mux, you need to ensure ShowQ.{hi,o} is in the same dir as lambdabot
06:42:56 <dons> the ./build script is supposed to take care of this, but if you copy things around, then some things break. lambdabot's not very good at out-of-tree living yet
06:45:45 <mux> dons: thanks!
06:45:53 <mux> @karma+ dons -- for being so helpful
06:45:54 <lambdabot> dons's karma raised to 69.
06:46:01 <mux> 69 is a good karma number.
06:46:20 <mux> what the
06:46:26 <mux> it didn't build ShowQ.hs
06:46:44 <dons> do you see the line in ./bulid ?
06:46:47 <dons> --> ghc -v0 -c -O2 -odir . -hidir . scripts/ShowQ.hs
06:46:51 <mux> yep
06:46:55 <dons> try running it by hand
06:46:55 <mux> was reading that
06:46:58 * mux nods
06:47:59 <mux> I need the same for L.hs too, it works now :-)
06:48:01 <mux> thanks again
06:48:04 <dons> ok good
06:49:11 <deadbeef> http://www.laureateci.it/public/data/Tencar/geni2.jpg
06:49:13 <lambdabot> http://tinyurl.com/ggf7h
06:49:16 <deadbeef> http://www.laureateci.it/public/data/Tencar/geni6.png
06:49:18 <lambdabot> http://tinyurl.com/mux3g
06:50:38 <dons> deadbeef: heh
07:00:41 <AstralStorm> I prefer cafe to deadbeef :>
07:07:19 <AstralStorm> Ok, I've a tiny question.
07:07:27 <AstralStorm> splitOn _ [] = []
07:07:27 <AstralStorm> splitOn delim x | null rest = [token]
07:07:27 <dolio> @pl \(x,y) -> (x, tail y)
07:07:27 <lambdabot> second tail
07:07:37 <AstralStorm>                 | otherwise = [token] ++ (splitOn delim (tail rest))
07:07:37 <AstralStorm>         where (token,rest) = break (== delim) x
07:07:56 <AstralStorm> This unfortunately skips the last separator if its empty
07:08:01 <AstralStorm> E.g. "abc,def,"
07:08:24 <AstralStorm> splitting that will return ["abc","def"] and not ["abc","def",""]
07:09:23 <AstralStorm> Any way to simply avoid it?
07:09:54 <Cale> So you have to make sure that when it finds a delimiter, it must give at least one more element
07:10:14 <Cale> (splitOn delim (tail rest)) might be empty
07:11:04 <Cale> but in this case, you know that the delimiter was there, so if it's empty, you'll want to replace its result with [[]]
07:13:01 <AstralStorm> Yes, so one if more?
07:13:46 <AstralStorm> Something like
07:13:47 <AstralStorm>                 | rest == [delim] = [token] ++ [[]]
07:14:07 <AstralStorm> Huh, it even works :>
07:14:31 <Cale> yeah, you could do that
07:14:37 <AstralStorm> A nasty hack IMO :P
07:15:03 <AstralStorm> Then, the "null rest" part is useless...
07:15:40 <Cale> are you sure?
07:15:46 <dolio> @pl \(x,y) -> (read x, read y)
07:15:46 <lambdabot> read *** read
07:15:47 <AstralStorm> Ah no, still required :P
07:16:09 <mux> any way to do multi-lines defines with lambdabot and ?let ?
07:16:30 <Cale> @help let
07:16:30 <lambdabot> let <x> = <e>. Add a binding
07:16:34 <Cale> oh, interesting
07:17:08 <Cale> @let fac 0 = 1; fac n = n * fac (n-1)
07:17:09 <lambdabot> Defined.
07:17:13 <Cale> > fac 5
07:17:14 <lambdabot>  Not in scope: `fac'
07:17:18 <Cale> er, hmm
07:17:25 <Cale> defined in which scope? :)
07:17:28 <Cale> > L.fac 5
07:17:29 <lambdabot>  120
07:17:30 <Cale> aha
07:17:40 <resiak> > L.fac -1
07:17:41 <lambdabot>  add an instance declaration for (Num (a -> a))
07:17:47 <resiak> bah :(
07:17:48 <AstralStorm> > L.fac (-1)
07:17:48 <Cale> > L.fac (-1)
07:17:50 <lambdabot>  Exception: stack overflow
07:17:51 <lambdabot>  Exception: stack overflow
07:17:54 <resiak> much better :)
07:17:57 <AstralStorm> Because you're buggy :>
07:18:11 <Cale> I consider that correct behaviour :)
07:18:19 <AstralStorm> Nope.
07:18:24 <AstralStorm> You need a guard :>
07:18:46 <Cale> Factorials of negative values aren't defined. Stack overflow is a kind of undefined :)
07:18:53 <AstralStorm> Not really.
07:19:00 <AstralStorm> Stack overflow = gobbling all memory :P
07:19:05 <Cale> Sure it is. It's still bottom.
07:19:17 <Cale> No, you hit it pretty quickly.
07:19:18 <AstralStorm> Yes, bottom, but with a nasty side effect :P
07:19:26 <AstralStorm> Yeah, after 8M of data
07:19:27 <Cale> whatever, the program terminates
07:19:39 <AstralStorm> Add an assert instead.
07:20:00 <Cale> (with failure)
07:20:17 <AstralStorm> But with a nasty incoprehensible failure :P
07:20:29 <AstralStorm> Assert is much better :>
07:20:46 <nomeata> ?check assert True = id
07:20:47 <lambdabot>  Parse error
07:21:06 <Cale> Who actually debugs their programs anyway? You just prove that your program never passes negative values to fac :)
07:21:10 <AstralStorm> ?hoogle assert
07:21:11 <lambdabot> Control.Exception.assert :: Bool -> a -> a
07:21:11 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
07:21:11 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
07:21:36 <Cale> > (L.fac . length) [1,2,3]
07:21:37 <lambdabot>  6
07:21:39 <Cale> > (L.fac . length) []
07:21:40 <lambdabot>  1
07:21:42 <AstralStorm> Cale: you can't prove that in some cases.
07:22:00 <Cale> You know I'm half-joking, right?
07:22:01 <AstralStorm> ?hoogle random
07:22:01 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
07:22:02 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
07:22:02 <lambdabot> Random :: module
07:22:15 <zybreak> Hi. Im wondering how i can convert a type of "Maybe [a]" to "[a]"?
07:22:21 <Cale> Obviously, better error messages are better :)
07:22:28 <Cale> @type maybeToList
07:22:29 <lambdabot> forall a. Maybe a -> [a]
07:22:36 <AstralStorm> zybreak: fromJust
07:22:40 <AstralStorm> Or fromMaybe
07:22:41 <AstralStorm> :>
07:22:46 <AstralStorm> @type fromMaybe
07:22:47 <nomeata> ?hoogle Maybe [a] -> [a]
07:22:47 <lambdabot> forall a. a -> Maybe a -> a
07:22:48 <lambdabot> No matches, try a more general search
07:22:53 <zybreak> okay :)
07:22:53 <Cale> noo... fromJust is definitely not what's wanted
07:22:59 <zybreak> ok?
07:23:06 <Cale> maybeToList
07:23:07 <nomeata> ?hoogle mapMaybe
07:23:08 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:23:09 <int-e> fromMaybe [] = concat . maybeToList
07:23:32 <Cale> int-e: huh?
07:23:32 <nomeata> ?type (mapMaybe id)
07:23:34 <lambdabot> forall b. [Maybe b] -> [b]
07:23:34 <AstralStorm> It's not [Maybe a] -> [a]
07:23:43 <AstralStorm> It's Maybe [a] -> [a]
07:23:44 <AstralStorm> :P
07:23:44 <zybreak> wait, i'll look up the function definitions
07:23:53 <zybreak> so i can describe my problem more in depth
07:23:59 <AstralStorm> So Maybe a -> a fits Maybe [a] -> [a]
07:24:04 <int-e> > maybeToList (Just [1])
07:24:06 <lambdabot>  [[1]]
07:24:21 <AstralStorm> > fromMaybe (Just [1])
07:24:22 <lambdabot>  Add a type signature
07:24:23 <int-e> > (concat $ maybeToList (Just [1]), fromMaybe [] (Just [1]))
07:24:25 <lambdabot>  ([1],[1])
07:24:30 <sek> in my main function, i have let file = "temp.dizzy" in do {writeFile file somestring} and it hangs when i call main. any ideas why?
07:24:31 <zybreak> you see, i have these two functions "match :: Eq a => a -> [a] -> [a] -> Maybe [a]" and "substitute :: Eq a => a -> [a] -> [a] -> [a]
07:24:34 <zybreak> "
07:24:36 <int-e> Cale: convinced?
07:24:45 <AstralStorm> > fromMaybe (Just [1]) :: [a]
07:24:46 <lambdabot>    Expecting a function type, but found `[a]'
07:24:46 <lambdabot>    Expected type: [a]
07:24:46 <lambdabot>   ...
07:24:50 <AstralStorm> > fromMaybe (Just [1]) :: [Int]
07:24:51 <lambdabot>    Expecting a function type, but found `[Int]'
07:24:51 <lambdabot>    Expected type: [Int]
07:24:51 <lambdabot> ...
07:24:54 <bartw> oh no, now with thre out of four wisdamteeth gone, will i still beable to learn haskell
07:25:21 <glguy> bartw: not with that fourth one left behind
07:25:30 <zybreak> :P
07:25:37 <bartw> oh good that one is scheduled for over 2 weeks
07:25:42 <bartw> 3 actually
07:25:47 <int-e> AstralStorm: fromMaybe takes a default value as its first argument
07:25:52 <Cale> @type maybeToList
07:25:53 <lambdabot> forall a. Maybe a -> [a]
07:26:01 <glguy> I got my wisdom teeth taken out on New Years Eve
07:26:07 <glguy> and was recovered enough to party
07:26:09 <glguy> by the evening
07:26:09 <int-e> > (concat $ maybeToList (Just [1]), fromMaybe [] (Just [1]))
07:26:10 <lambdabot>  ([1],[1])
07:26:17 <bartw> ooh thats pretty nice
07:26:26 <Lemmih> sek: That sounds odd.
07:26:30 <bartw> altough i get explicit advice not to use alchohol for a week
07:26:52 <sek> Lemmih: FilePath is of type String, right?
07:27:01 <zybreak> Cale: do you have 2 minutes to help me out :)
07:27:05 <Lemmih> sek: Yes.
07:27:15 <zybreak> could i paste two definitions to you private?
07:27:25 <zybreak> i dont wanna litter the public room
07:27:26 <AstralStorm> > fromMaybe [] (Just [1])
07:27:27 <lambdabot>  [1]
07:27:35 <AstralStorm> > fromMaybe [] (Just [1024,45131])
07:27:37 <lambdabot>  [1024,45131]
07:27:46 <AstralStorm> > fromMaybe [] ()
07:27:47 <lambdabot>  Couldn't match `Maybe [a]' against `()'
07:27:50 <AstralStorm> > fromMaybe [] (Nothing)
07:27:50 <lambdabot>  Add a type signature
07:27:57 <AstralStorm> Huh?
07:28:04 <glguy> > fromMaybe [] () :: [()]
07:28:05 <lambdabot>  Couldn't match `Maybe [()]' against `()'
07:28:09 <int-e> @type fromMaybe [] (Nothing)
07:28:10 <lambdabot> forall a. [a]
07:28:20 <sek> main :: Somedatatype -> String -> IO() \n main x file = let ... file = file++".dizzy" in do {writeFile file string}    to be more precise
07:28:21 <glguy> > fromMaybe [] Nothing :: [()]
07:28:22 <lambdabot>  []
07:28:32 <AstralStorm> > fromMaybe [] (Just [1024,45131]) :: [()]
07:28:34 <lambdabot>  add an instance declaration for (Num ())
07:28:34 <lambdabot>   In the list element: 45131
07:28:37 <Lemmih> sek: Ah.
07:28:50 <glguy> AstralStorm: [()] is a list of units
07:28:52 <AstralStorm> Why it isn't that polymorphic?
07:28:55 <Lemmih> sek: 'let file = file ++ ".dizzy"'   is a bad idea.
07:29:03 <AstralStorm> I'd like fromMaybe [] Nothing
07:29:06 <AstralStorm> return []
07:29:09 <glguy> AstralStorm: the problem is that it is polymorphic
07:29:17 <sek> Lemmih: ok,ill go through an intermediate string
07:29:20 <glguy> AstralStorm: and you didn't give it enough information to know what it polymorphs into
07:29:24 <Lemmih> sek: Try 'let newFile = file ++ ".dizzy"'.
07:29:30 <AstralStorm> Into an empty list?
07:29:37 <glguy> AstralStorm: and empty list of what?
07:29:40 <glguy> an*
07:29:45 <AstralStorm> Of emptyness :P
07:29:52 <AstralStorm> Blah, there's no such concept
07:29:56 <mux> hahaha
07:29:57 <mux> http://img.thedailywtf.com/images/200609/zero.jpg
07:29:58 <sek> yup, that was it. thanks
07:30:02 <lambdabot> http://tinyurl.com/fptg6
07:30:17 <AstralStorm> Empty list of anything
07:30:33 <glguy> AstralStorm: how would it know how to show that?
07:30:39 <AstralStorm> It doesn't.
07:30:43 <AstralStorm> :/
07:30:43 <zybreak> hrm, im still stuck on the maybe problem. the thing is i have two functions, one returns a maybe. i want to run the second func. on the first if it doesnt return Nothing
07:30:44 <glguy> it has to
07:31:07 <zybreak> i believe this should be easy, but im all out of ideas
07:31:11 <glguy> zybreak: bind?
07:31:12 <AstralStorm> What about a list of Int then?
07:31:22 <glguy> zybreak: fmap?
07:31:25 <AstralStorm> > fromMaybe [] (Nothing) : [Int]
07:31:26 <lambdabot>  Not in scope: data constructor `Int'
07:31:28 <AstralStorm> > fromMaybe [] (Nothing) :: [Int]
07:31:30 <glguy> > fmap (+1) (Just 1)
07:31:30 <lambdabot>  []
07:31:31 <lambdabot>  Just 2
07:31:38 <glguy> > fmap (+1) Nothing
07:31:40 <lambdabot>  Nothing
07:31:41 <AstralStorm> > fromMaybe [] (Just [1,2,3]) :: [Int]
07:31:42 <zybreak> glguy: hrm. haveto check those functions out
07:31:43 <lambdabot>  [1,2,3]
07:32:10 <zybreak> glguy: heres the function which returns a maybe "match :: Eq a => a -> [a] -> [a] -> Maybe [a]"
07:32:13 <AstralStorm> It should be able to infer "empty list of what" from the type Maybe [Int]
07:32:29 <AstralStorm> But lambdabot can't read mind :>
07:32:38 <glguy> AstralStorm: [1] is a [Int] because of the 1
07:32:38 <zybreak> and the function which i want to run if match /= Nothing is "substitute :: Eq a => a -> [a] -> [a] -> [a]"
07:32:47 <AstralStorm> glguy: I know :>
07:32:52 <glguy> zybreak: did you see my fmap example?
07:33:01 <AstralStorm> @let SomeType = Maybe [Int]
07:33:02 <lambdabot> <local>:5:0: Not in scope: data constructor `SomeType'  <local>:5:11: Not in ...
07:33:04 <zybreak> but will fmap work on my example
07:33:06 <AstralStorm> Hmm.
07:33:07 <glguy> > (fmap (+1) Nothing, fmap (+1) (Just 2))
07:33:08 <lambdabot>  (Nothing,Just 3)
07:33:15 <araujo> morning!
07:33:16 <zybreak> there are more arguments than one
07:33:21 <AstralStorm> @let SomeType = Maybe [Int] in SomeType
07:33:22 <lambdabot>  Parse error
07:33:32 <AstralStorm> @data SomeType = Maybe [Int]
07:33:33 <lambdabot> Unknown command, try @list
07:33:42 <AstralStorm> @type SomeType = Maybe [Int]
07:33:44 <lambdabot> parse error on input `='
07:33:52 <glguy> zybreak: then use lambda expressions in the first argument of fmap
07:33:53 <Syzygy-> I have data generated elsewhere that almost looks like a [[SomeType]], where the things occurring in SomeType either is [Int,Int,Int], or [Int,fail,Int], or [Int,"abelian"], or fail - where fail is a keyword in the other context.
07:34:07 <zybreak> glguy: whats a lambda expression? :$
07:34:08 <AstralStorm> Hmm, how can one define new datatypes with Lambdabot?
07:34:20 <glguy> zybreak: (\x y -> x + y)
07:34:22 <Syzygy-> I'm prepared to do some generic searches and replaces, and want to be able to hack this using haskell. Any ideas on what things may be worth doing?
07:34:36 <AstralStorm> glguy: or just (+)
07:34:57 <zybreak> glguy: im gonna google on that :=
07:35:06 <Syzygy-> The things I'm going to do with the data once I can handle it is mainly finding indices k,l such that a certain inequality holds between the first and second integer in (myList !! k) !! l
07:35:37 <AstralStorm> How would one define new datatypes with Lambdabot?
07:35:59 <Syzygy-> @type Maybe [Int]
07:36:00 <lambdabot> Not in scope: data constructor `Maybe'
07:36:01 <lambdabot>  
07:36:01 <lambdabot> <interactive>:1:7: Not in scope: data constructor `Int'
07:36:08 <Syzygy-> @type (Maybe [Int])
07:36:09 <lambdabot> Not in scope: data constructor `Maybe'
07:36:09 <lambdabot>  
07:36:09 <lambdabot> <interactive>:1:8: Not in scope: data constructor `Int'
07:37:04 <int-e> @type (undefined :: Maybe [Int]) -- you need to give an expression
07:37:05 <lambdabot> Maybe [Int]
07:37:50 <AstralStorm> Huh, but can one define datatypes with Lambdabot?
07:38:28 <sjanssen> AstralStorm: no
07:41:01 <AstralStorm> Hmm, with glasgow-exts you could do:
07:42:15 <AstralStorm> > Even w/o.
07:42:16 <lambdabot>  Parse error
07:43:36 <AstralStorm> > fromMaybe [] (Just [1,2,3]) :: [a]
07:43:37 <lambdabot>  add (Num a) to the expected type of an expression
07:43:37 <lambdabot>   In the list element: 3
07:44:00 <AstralStorm> > fromMaybe [] (Just [1,2,3]) :: Maybe [a] -> [a]
07:44:01 <lambdabot>  Couldn't match `Maybe [a] -> [a]' against `[a1]'
07:44:15 <AstralStorm> > fromMaybe [] (Just [1,2,3]) :: (Maybe [a] -> [a])
07:44:15 <lambdabot>  Couldn't match `Maybe [a] -> [a]' against `[a1]'
07:44:23 <AstralStorm> > (fromMaybe [] (Just [1,2,3])) :: (Maybe [a] -> [a])
07:44:24 <lambdabot>  Couldn't match `Maybe [a] -> [a]' against `[a1]'
07:44:27 <AstralStorm> Blah.
07:45:13 <AstralStorm> @let (deMaybe x = fromMaybe [] x) :: Maybe [a] -> [a] in deMaybe Nothing
07:45:14 <lambdabot>  Parse error
07:45:34 <AstralStorm> @let ((deMaybe x = fromMaybe [] x) :: Maybe [a] -> [a]) in deMaybe Nothing
07:45:35 <lambdabot>  Parse error
07:45:42 <AstralStorm> Lambdabot hates me :>
07:45:59 <mux> > fromMaybe [] (Just [1,2,3])
07:46:00 <lambdabot>  [1,2,3]
07:46:02 <mux> ,
07:46:05 <mux> ?
07:46:09 <mux> what were you trying to do?
07:46:10 <AstralStorm> I can't convert:
07:46:10 <AstralStorm> deMaybe :: Maybe [a] -> [a]
07:46:10 <AstralStorm> deMaybe x = fromMaybe [] x
07:46:17 <AstralStorm> To lambdabot-allowed form
07:46:50 <mux> ?let deMaybe x = fromMaybe [] x
07:46:51 <lambdabot> Defined.
07:46:59 <mux> > L.deMaybe Nothing
07:47:00 <lambdabot>  Add a type signature
07:47:05 <AstralStorm> mux: blah :P
07:47:09 <mux> hum.
07:47:17 <Lemmih> > let deMaybe :: Maybe [a] -> [a]; deMaybe = fromMaybe [] in deMaybe (Just [1,2,3])
07:47:18 <lambdabot>  [1,2,3]
07:47:20 <Lemmih> > let deMaybe :: Maybe [a] -> [a]; deMaybe = fromMaybe [] in deMaybe Nothing :: [Int]
07:47:22 <lambdabot>  []
07:47:42 <AstralStorm> > let deMaybe :: Maybe [a] -> [a]; deMaybe = fromMaybe [] in deMaybe Nothing
07:47:43 <lambdabot>  Add a type signature
07:47:56 <AstralStorm> Should return an empty list of whatever :P
07:48:04 <AstralStorm> We have to add Show a :>
07:48:10 <AstralStorm> > let deMaybe :: Show a => Maybe [a] -> [a]; deMaybe = fromMaybe [] in deMaybe Nothing
07:48:11 <lambdabot>  Add a type signature
07:48:20 <AstralStorm> Balh.
07:48:43 <AstralStorm> > let deMaybe :: Show a => Maybe [a] -> [a]; deMaybe x = fromMaybe [] x in deMaybe Nothing
07:48:45 <lambdabot>  Add a type signature
07:48:46 <Lemmih> AstralStorm: Printing an empty list of X can be different from print an empty list of Y.
07:48:52 <AstralStorm> Unfortunately :P
07:48:56 <AstralStorm> Can't work it around.
07:49:40 <AstralStorm> Printing empty list of showables should be same, uh...
07:51:04 <glguy> All lists have a type, and that type must be determined beore show can be called
07:51:05 <Lemmih> > ([] :: [Int], [] :: [Char])
07:51:07 <lambdabot>  ([],"")
07:51:28 <glguy> *bodyslam*
07:51:59 <Syzygy-> How do I flatten?
07:52:01 <Syzygy-> a list
07:52:06 <Syzygy-> Is there something in Prelude to do it?
07:52:07 <glguy> Syzygy-: concat?
07:52:08 <Lemmih> Syzygy-: concat?
07:52:19 <glguy> jynx!
07:52:35 <glguy> You can't talk until you buy me a soda!
07:53:34 <Syzygy-> o.O
07:53:46 <glguy> Syzygy-: do you mean:
07:53:50 <Syzygy-> length mylist fails with *** Exception: Prelude.(!!): index too large
07:53:54 <glguy> > concat [[1],[3],[4,5]]
07:53:56 <lambdabot>  [1,3,4,5]
07:53:59 <Syzygy-> glguy: Yah, I got that now.
07:54:09 <Lemmih> Syzygy-: Hurrah for lazy evaluation (:
07:54:10 <Syzygy-> Only, I cannot find out the size of my bloody list now... :P
07:54:21 <Syzygy-> Lemmih: Yah. But I want to work through the bloody thing anyway.
07:56:09 <Lemmih> (I meant that lazy evaluation causes such exceptions to be delayed and difficult to locate)
07:56:38 <glguy> Syzygy-: look for places that you use (!!) and figure out why you are calling numbers >= the length of the list
08:03:23 <Templar> ?paste
08:03:24 <lambdabot> http://paste.lisp.org/new/haskell
08:04:21 <Syzygy-> glguy: How about filter (\(x,y) -> let el = (depthData2 !! x !! y) in first el < second el) smallList
08:04:28 <Syzygy-> This gives me that error, and I cannot figure out why.
08:04:45 <Syzygy-> first and second return first and second elements of a list respectively.
08:04:55 <lisppaste2> Templar pasted "maxFour" at http://paste.lisp.org/display/26249
08:05:00 <Syzygy-> And depthData2 is a list of lists of 3-element lists.
08:05:59 <glguy> Syzygy-: You'll have to at that list and figure it out (I'm not going to be able to tell you myself) but obviously its overflowing somewhere... don't forget that on a 3 element list the last index is 2 tho
08:06:18 <Syzygy-> Oh, things are 0-indexed? Blech.
08:06:26 <Templar> any ideas?.
08:07:46 <musasabi> Templar: maximum
08:08:13 <musasabi> > let maxFour a b c d = maximum [a,b,c,d] in maxFour 5 9 13 2
08:08:14 <lambdabot>  13
08:08:47 <glguy> Templar: when you use the same name for a function argument as an existing function, you hide the existing function and turn the name into a variable
08:09:02 <Templar> ok, but I am suppoed to make it with 2 other functions to learn inplent it(or whats it now called)..
08:09:06 <glguy> Templar: so your maxFour is just max2 with a different name
08:09:37 <glguy> Templar: and I think that your maxThree should call max2 twice instead of recreating the functionality
08:09:54 <musasabi> maxFour a b c d = max2 a b `max2` max2 c d
08:10:24 <glguy> maxThree a b c = a `max2` (b `max2` c)
08:10:30 <Templar> glguy: yea, true. But I think its right there Im having problem. Dont know how to call it
08:11:51 <lisppaste2> glguy annotated #26249 with "max 2 3 4" at http://paste.lisp.org/display/26249#1
08:12:43 <Templar> glguy:  aha, nice. Thanks. Now I understand!
08:12:52 <Templar> =)
08:13:39 <Syzygy-> > a+b where a=4, b=3
08:13:39 <lambdabot>  Parse error
08:13:44 <glguy> try a ;
08:13:50 <Syzygy-> > a+b where a=4; b=3
08:13:50 <lambdabot>  Parse error
08:13:50 <glguy> > a + b where a = 4; b = 3
08:13:51 <lambdabot>  Parse error
08:13:53 <glguy> hm
08:14:00 <glguy> > let a = 4 ; b = 3 in a + b
08:14:02 <lambdabot>  7
08:14:14 <glguy> > a + b ; where a = 3; b = 4
08:14:15 <lambdabot>  Parse error
08:14:15 <Syzygy-> It's not just me who thinks where was a way to not start with the declarations?
08:14:27 <Syzygy-> > a where a = 3
08:14:28 <lambdabot>  Parse error
08:14:31 <Syzygy-> > a; where a = 3
08:14:31 <lambdabot>  Parse error
08:14:44 <glguy> there's a way to do it (c: I just don't remember how
08:14:57 <Syzygy-> > do a where a = 3
08:14:58 <lambdabot>  Parse error
08:15:00 <Syzygy-> No...
08:15:09 <glguy> > a ; where ; a = 3
08:15:10 <lambdabot>  Parse error
08:17:00 <Syzygy-> A where clause is only allowed at the top level of a set of equations or case expression. The same properties and constraints on bindings in let expressions apply to those in where clauses.
08:17:04 <Syzygy-> These two forms of nested scope seem very similar, but remember that a let expression is an expression, whereas a where clause is not---it is part of the syntax of function declarations and case expressions.
08:17:09 <Syzygy-> (Gentle introduction to haskell)
08:17:10 <xerox> `let ... in ...' i an expression; `... where ...' is not :(
08:17:12 <Syzygy-> Ah.
08:17:55 <glguy> > let f = a where a = 3 in f
08:17:56 <lambdabot>  3
08:18:00 <glguy> huzzah!
08:19:25 <xerox> > let (a,b,c) = (b,c,1) in a
08:19:27 <lambdabot>  1
08:20:09 <glguy> > fix (\~ (a,b,c) -> (b,c,1) )
08:20:10 <lambdabot>  Parse error
08:20:14 <glguy> > fix (\ ~(a,b,c) -> (b,c,1) )
08:20:16 <lambdabot>  (1,1,1)
08:26:00 <deadbeef> hey glguy, enlight me
08:26:05 <deadbeef> what ~ does ?
08:26:11 <glguy> lazy pattern matching
08:26:27 <glguy> > fix (\ (a,b,c) -> (b,c,1) )
08:26:29 <lambdabot>  Exception: <<loop>>
08:26:40 <glguy> Pattern matching is eager
08:26:41 <deadbeef> thanks
08:27:42 <dolio> It's not always eager, though, right?
08:28:00 <dolio> let <pattern> = <function> in foo doesn't match unless you use something in pattern.
08:28:09 <_Stinger_> so when does lazy pattern matching occur?
08:28:25 <dolio> But it is eager in case and function definition.
08:29:24 <glguy> I believe that the eagerness kicks in when you try to use the values
08:29:29 <dolio> > fix (\x -> let (a,b,c) = x in (b,c,1))
08:29:30 <lambdabot>  (1,1,1)
08:30:03 <dolio> It's eager in case and function definition because it needs to execute the match to figure out which branch to take.
08:30:46 <Syzygy-> Gleh.
08:31:07 <Syzygy-> I want to dump strings to a file in ghci. I cannot seem to load modules from the command line however.
08:31:18 <dolio> Whereas in where and let, the match only needs to be made if you use something within the pattern.
08:31:58 <Syzygy-> Ah! :module + IO
08:32:20 <musasabi> > let a = b where b = 1 : a in take 10 a
08:32:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:32:40 <musasabi> thus one can get "where" in lambdabot too.
08:33:02 <musasabi> grah. and it was already in the backlog.
08:33:08 <glguy> (c:
08:33:22 <glguy> I didn't have the heart to tell you
08:33:30 <dolio> > let a = b ; b = 1 : a in take 10 a
08:33:31 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:33:55 <glguy> sure, but the scoping of b is different :-p
08:34:02 <dolio> :)
08:34:13 <dolio> > let a = b ; b = 1 : a in take 10 b
08:34:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:34:20 <dolio> > let a = b where b = 1 : a in take 10 b
08:34:20 <lambdabot>  Not in scope: `b'
08:34:26 <glguy> > [1,1..]
08:34:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:35:01 <dolio> fix (1:)
08:35:09 <dolio> > fix (1:)
08:35:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:35:14 <glguy> > [1..10] >>= const [1]
08:35:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:35:29 <glguy> > [1..10] >> [1]
08:35:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:37:12 <xerox> At some point I remember I was able to do `@plugs foo where bar', maybe in the old days.
08:38:02 <glguy> > replicate 10 1
08:38:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
08:38:11 <Syzygy-> How did I get the library reference page for a module out of lambdabot?
08:38:35 <xerox> Using @docs
08:38:41 <Syzygy-> @docs IO
08:38:41 <lambdabot> IO not available
08:38:46 <xerox> @docs System.IO
08:38:47 <Syzygy-> o.O
08:38:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
08:38:49 <Syzygy-> Ah.
08:38:53 <xerox> @docs
08:38:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:38:56 <xerox> The hierarchy -^
08:40:29 <Syzygy-> Huh?
08:40:48 <glguy> He's explaining to you how to find things like IO -> System.IO
08:41:01 <Syzygy-> I get a file handle by h = openFile blah. Then I do hPutStrLn h string and it fails.
08:41:08 <Syzygy-> What am I supposed to do to use the handle I got?
08:41:29 <Syzygy-> (the error is a "obvious" type mismatch: the handle is a IO Handle, and the function takes a Handle)
08:41:41 <xerox> do { h <- openFile "blah"; hputStrLn h "blah" }
08:41:49 <Syzygy-> Ah.
08:42:02 <xerox> Which desugars to: openFile "blah" >>= \h -> hPutStrLn h "blah".
08:42:39 <Syzygy-> do han <- openFile "superduflot.tex"; map (hPutStrLn han) list_of_strings
08:42:45 <Syzygy->     Couldn't match `Handle' against `IO Handle'
08:42:48 <xerox> Since you are playing with IO actions, the order is important.  Hence you need to sequence them, either in a do block, or with bind.
08:42:55 <Syzygy-> Ah.
08:42:59 <xerox> Right.
08:43:11 <Syzygy-> So how do I easiest print an entire list of strings, one after the other, with linebreaks..
08:43:16 <Syzygy-> Hmmm. unlines possibly?
08:43:17 <glguy> Syzygy-: check out mapM and mapM_
08:44:06 <xerox> do { contents <- readFile "blah"; mapM_ putStrLn (lines contents) } -- If I am not mistaken.
08:44:55 <Syzygy-> glguy: Ah. That's what they're used for.
08:45:07 <Syzygy-> unlines gave me a string that I could writeout however.
08:45:16 <xerox> ?type unlines
08:45:18 <lambdabot> [String] -> String
08:45:23 <gour> dons: i emerged ghc-6.5.20060917, but Language.Haskell.ParseUtils is still hidden
08:45:34 <xerox> Oh well... you can just: readFile "file" >>= putStrLn
08:46:04 <Syzygy-> AT LAST!
08:46:06 <xerox> ?type readFile "foo" >>= putStrLn
08:46:07 <Syzygy-> Got my data!
08:46:07 <Syzygy-> :)
08:46:07 <lambdabot> IO ()
08:46:08 <glguy> in that case you'd probably just want putStr since the file would have the trailing read lines
08:46:12 <glguy> trailing newline
08:46:15 <glguy> maybe
08:46:23 <Syzygy-> Right.
08:46:33 <_Stinger_> humm how do you get (-1) as a slice?
08:46:38 <xerox> (subtract 1)
08:46:39 <glguy> (+(-1))
08:47:05 <xerox> ?pl \x -> x - 1
08:47:05 <lambdabot> subtract 1
08:47:13 <glguy> > (+(-1)) 3
08:47:15 <lambdabot>  2
08:47:25 <glguy> ?index subtract
08:47:25 <lambdabot> Prelude
08:47:38 <glguy> ? index add
08:47:40 <glguy> ?index add
08:47:41 <lambdabot> bzzt
08:47:54 <glguy> ?pl \x -> x + 1
08:47:54 <lambdabot> (1 +)
08:47:57 <_Stinger_> just a syntax anomaly then fair enough
08:48:12 <xerox> Yeah.  `subtract' comes to help in the (-foo) case.
08:48:21 <glguy> J gets around that issue by using _ for negative numbers
08:48:23 <glguy> _1
08:48:54 <_Stinger_> J is that perl for functional languages was it? :)
08:49:09 <Patterner> J is APL in ascii
08:50:02 * glguy will have a field-week when ?j is added to lambdabot
08:51:38 <Syzygy-> > ord '%'
08:51:39 <lambdabot>  37
09:11:03 <dolio> @pl \f g x -> (f x, g x)
09:11:03 <lambdabot> liftM2 (,)
09:11:23 <glguy> or (&&&)
09:11:34 <dolio> Yeah, I know.
09:11:38 <dolio> I was testing.
09:11:53 <dolio> @pl \x y -> (foo x, bar y)
09:11:53 <lambdabot> (. bar) . (,) . foo
09:12:15 <dolio> @pl \x y -> (foo x, foo y)
09:12:15 <lambdabot> (. foo) . (,) . foo
09:12:24 <xerox> (f *** g) (x,y) = (f x, g y)
09:12:42 <dolio> Hmm...
09:12:59 <glguy> xerox: why does that do that?
09:13:05 <glguy> is that the purpose of ***?
09:13:08 <dolio> @pl \(x,y) -> (f x, g y)
09:13:08 <lambdabot> f *** g
09:13:12 <dolio> Ah, there we go.
09:13:25 <xerox> glguy: for the (->) Arrow, yes, it is.
09:13:33 <glguy> ?type (***)
09:13:35 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:13:55 <dolio> Has it always used ***, or is that recent?
09:14:16 <glguy> ?instances Arrow
09:14:18 <lambdabot> (->), Kleisli m
09:14:38 <glguy> What is Kleisli m then?
09:15:05 <roconnor> f *** g looks kinda crude to me
09:15:11 <xerox> (f *** g) is pretty.
09:15:19 <xerox> glguy: Keisli... Kleisli...
09:15:20 <ValarQ> glguy: monadwrapper
09:15:25 <xerox> That.
09:15:25 <dolio> Kleisli m a b is something like a -> m b
09:15:39 <xerox> ?index Kelisli
09:15:40 <lambdabot> bzzt
09:15:43 <int-e> with f >>> g = f >>= g
09:15:47 <xerox> ?fptools Control.Monad
09:15:47 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
09:16:04 <ValarQ> hmm, where does the name Kleisli come from?
09:16:07 <roconnor> @pl \(x y) -> (f x, ing y)
09:16:08 <lambdabot> (line 1, column 5):
09:16:08 <lambdabot> unexpected "y"
09:16:08 <lambdabot> expecting operator or ")"
09:16:22 <roconnor> @pl \(x, y) -> (f x, ing y)
09:16:23 <lambdabot> f *** ing
09:16:24 <dolio> Dude's name?
09:16:42 <glguy> > pure (+1)
09:16:43 <lambdabot>  add an instance declaration for (Show (a b b))
09:16:51 <ValarQ> dolio: what dude?
09:16:52 <glguy> > pure (+1) 1 2
09:16:53 <lambdabot>  add an instance declaration for (Num (t -> a))
09:16:58 <glguy> > pure (+1) 1 2 3
09:16:59 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
09:17:01 <glguy> > pure (+1) 1
09:17:03 <lambdabot>  2
09:17:12 <glguy> > arr (+1) 1
09:17:14 <lambdabot>  2
09:17:19 <dolio> ValarQ: Not sure. It was a guess. :)
09:18:08 <ValarQ> dolio: ok, to my knowledge none of the arrow guys where named kleisli :/
09:18:24 <ndm> @seen dons
09:18:25 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 2h 27m 46s ago.
09:18:27 <ValarQ> ndm: welcome
09:18:40 <ndm> hi ValarQ
09:18:41 <roconnor> @google kleisli category
09:18:43 <dolio> ValarQ: Kleisli comes from category theory, I think, not arrows.
09:18:44 <lambdabot> http://www.tac.mta.ca/tac/volumes/15/2/15-02abs.html
09:18:44 <lambdabot> Title: Reflective Kleisli subcategories of the category of Eilenberg-Moore algebras for ...
09:19:04 <ValarQ> dolio: ok
09:21:10 <int-e> Well, Kleisli m is the Kleisli category of m. And I think it's a name, too.
09:21:58 <glguy> > first (Kleisli return) ([1],[2])
09:21:59 <lambdabot>  Couldn't match `(->)' against `Kleisli m'
09:22:43 <glguy> ?type Kleisli return
09:22:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => Kleisli m a a
09:23:20 <int-e> 'is a category' in the sense that given two objects a and b, Kleisli m a b is the homset [a,b] (was that the notation?).
09:23:43 <glguy> > runKleisli (Kleisli return) 1
09:23:44 <lambdabot>  add an instance declaration for (Show (m a))
09:23:55 <glguy> > runKleisli (Kleisli return) [1]
09:24:39 <glguy> ?ver
09:24:52 <profmakx> @version
09:24:59 <profmakx> o.o
09:25:31 <lambdabot>  add an instance declaration for (Show (m [a]))
09:25:33 <lambdabot> Maybe you meant: vera version
09:25:37 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
09:25:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:25:47 <glguy> > runKleisli (Kleisli return) 1 :: [Int]
09:25:48 <lambdabot>  [1]
09:26:16 -MesMers(i=node@gateway/tor/x-27696f7722c241db)- Somebody has sent you a message, to read it type: /server read 1
09:27:03 <int-e> MesMers: ?!
09:27:15 <glguy> I reported it to a server op
09:27:34 <int-e> what does that command do?
09:27:41 <glguy> disconnects you
09:27:47 <glguy> and trys to connect to a server called read
09:27:53 <glguy> which obviously doesnt' exist
09:27:57 <int-e> ah, of course.
09:28:07 <int-e> thanks.
09:28:15 * glguy tries something
09:29:01 <glguy> hmm, nvm
09:29:23 <glguy> I think on efnet if you did a /join #0 it was actually a part all or something
09:34:03 <therp> there was such a thing yes.. but maybe with a comma? I remember #2,600..
09:34:20 <therp> but was about 6 years ago..
09:34:21 <glguy> I think that freenode just doesn't support that command
09:34:36 <glguy> probably because people would use it like that thing mesmers did
09:34:45 * therp just realizes that he is "on irc" since 10 years.
09:34:59 <roconnor> Uptime: 2 days and 35 minutes
09:35:49 <glguy> My uptime is surprisingly low as well
09:36:03 <glguy> I wonder what those kids at the fraternity that this server lives are have been up to
09:36:07 <roconnor> Long way to go to get to 10 years
09:39:48 <dylan> actually
09:40:00 <dylan> sending 'JOIN 0' to an IRC server parts all channels
09:40:04 <dylan> it's part of the RFC even
09:40:22 <glguy> right, but I don't think that this server follows that part of the RFC
09:40:37 <dylan> let's test.
09:41:13 <dylan> well, freenode follows it
09:41:16 <glguy> wtf did you type
09:41:23 <glguy> I use the same irc client as you
09:41:26 <dylan> /quote join 0
09:41:28 <glguy> bah
09:41:33 <glguy> makes sense
09:41:35 <glguy> irssi is too smart
09:41:38 <dylan> irssi is magical with /join
09:41:47 <dylan> you never need to write a '#'
09:41:52 <glguy> right
09:42:00 <glguy> or even oin
09:42:52 <glguy> and in my case, you don't have to write /j haskell at all (autojoin)
09:42:58 <roconnor> @join 0
09:42:59 <lambdabot> Not enough privileges
09:43:07 <roconnor> >join 0
09:43:12 <roconnor> > join 0
09:43:13 <lambdabot>  add an instance declaration for (Show (m a))
09:43:15 <glguy> > join [0]
09:43:17 <lambdabot>  add an instance declaration for (Num [a])
09:43:17 <lambdabot>   In the list element: 0
09:43:21 <glguy> > join [[0]]
09:43:23 <lambdabot>  [0]
09:43:28 <roconnor> :)
09:43:35 <glguy> itworked
09:43:37 <glguy> :-p
09:43:58 <roconnor> > join Just Just 0
09:43:59 <lambdabot>  Couldn't match `a -> t -> t1' against `Maybe a'
09:44:08 <roconnor> > join Just (Just 0)
09:44:09 <lambdabot>  Couldn't match `a1 -> a' against `Maybe a1'
09:44:11 <glguy> > join (Just (Just 0))
09:44:12 <lambdabot>  Just 0
09:44:13 <roconnor> bah
09:44:25 <glguy> > join (+) 2
09:44:26 <lambdabot>  4
09:44:38 <roconnor> > join (+) 0
09:44:39 <lambdabot>  0
09:44:53 <roconnor> joing (Left (Left 0))
09:44:56 <roconnor> > join (Left (Left 0))
09:44:57 <lambdabot>  add an instance declaration for (Monad (Either (Either a b)))
09:44:57 <lambdabot>   In the de...
09:45:09 <roconnor> > join (Right (Right 0))
09:45:10 <lambdabot>  add an instance declaration for (Monad (Either a))
09:45:11 <lambdabot>   In the definition of...
09:45:14 <glguy> not a monad, tho you can use it to define your own error monad
09:45:22 <roconnor> oh
09:45:26 <xerox> ?instances Monad
09:45:27 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:45:33 <mux> ?let nerdize = \x -> if x == 'a' then '4' else if x == 'e' then '3' else x
09:45:37 <lambdabot> Defined.
09:45:45 <mux> > map nerdize "hello gang!"
09:45:46 <lambdabot>  Not in scope: `nerdize'
09:45:51 <mux> > map L.nerdize "hello gang!"
09:45:53 <lambdabot>  "h3llo g4ng!"
09:46:08 <glguy> ?elite "hello gang!"
09:46:08 <roconnor> @eleet hello gang!
09:46:09 <lambdabot> "HE110 94nG!"
09:46:09 <lambdabot>  Parse error
09:46:26 <mux> heh
09:46:37 <glguy> I guess nerds aren't elite
09:46:40 <dylan> ?let nerdize2 'a' = '4'; nerdize2 'e' = '3'; nerdize2 x = x
09:46:41 <lambdabot> Defined.
09:47:03 <dylan> map L.nerdize2 "hello gang!"
09:47:11 <dylan> > map L.nerdize2 "hello gang!"
09:47:13 <lambdabot>  "h3llo g4ng!"
09:47:19 <glguy> xerox: I don't know why Either e shows up in the instances of Monad when you can't use it as one
09:49:51 <dolio> > (Left "error") >>= return
09:49:52 <lambdabot>  add an instance declaration for (Monad (Either [Char]))
09:50:33 <glguy> instance Error e => Monad (Either e)
09:50:45 <dolio> Ah.
09:50:58 <glguy> instance Error [Char]
09:51:15 <dolio> @instances Error
09:51:16 <lambdabot> IOError, [Char]
09:51:25 <glguy> > Left "1" :: Either String String
09:51:26 <lambdabot>  Left "1"
09:51:33 <glguy> > Left "1" >>= return :: Either String String
09:51:34 <lambdabot>  add an instance declaration for (Monad (Either [Char]))
09:51:46 <dolio> > Right 1 >>= return
09:51:47 <lambdabot>  add an instance declaration for (Monad (Either a))
09:52:02 <dolio> > (Right 1 :: Either String Int) >>= return
09:52:02 <lambdabot>  add an instance declaration for (Monad (Either String))
09:52:04 <glguy> > Left "1" >>= return :: Control.Monad.Error.Either String String
09:52:05 <lambdabot>  Not in scope: type constructor or class `Control.Monad.Error.Either'
09:52:17 <glguy> ?index noMsg
09:52:17 <lambdabot> Control.Monad.Error
09:52:28 <glguy> strMsg "test"
09:52:30 <glguy> > strMsg "test"
09:52:31 <lambdabot>  Not in scope: `strMsg'
09:52:39 <glguy> Control.Monad.Error.strMsg strMsg "test"
09:52:43 <glguy> Control.Monad.Error.strMsg "test"
09:52:45 <glguy> > Control.Monad.Error.strMsg "test"
09:52:46 <lambdabot>  Not in scope: `Control.Monad.Error.strMsg'
09:52:53 <glguy> I think that's why this examples don't work
09:53:09 <glguy> these*
09:54:14 <dolio> Yeah. Left "1" >>= return works in ghci if you import Control.Monad.Error.
09:54:27 <dolio> Lambdabot must not have that set up.
10:02:12 <_Stinger_> You can't go to IO [a] to [IO a] can you?
10:02:29 <_Stinger_> s/to/from/
10:03:18 <_Stinger_> cause you'd be taking length info out of the IO monad
10:03:36 <int-e> right.
10:04:15 <twanvl> @type return . liftM head :: IO [a] -> [IO a]
10:04:17 <lambdabot> IO [a] -> [IO a] :: forall a. IO [a] -> [IO a]
10:04:25 <twanvl> But that is probably not what you want :)
10:04:34 <_Stinger_> wonder if you could transfer a circular structure in/out of the IO monad :)
10:04:36 <int-e> rrrrright. :)
10:07:15 <psi> I forgot what the other way around is called.
10:08:06 <psi> @djinn [IO a] -> IO [a]
10:08:07 <lambdabot> -- f cannot be realized.
10:08:13 <int-e> mapM
10:08:17 <int-e> hmm
10:08:20 <dolio> sequence
10:08:23 <psi> ah!
10:08:24 <int-e> right.
10:12:44 <ndm> @hoogle [IO a] -> IO [a]
10:12:46 <lambdabot> No matches, try a more general search
10:12:58 <ndm> (bad hoogle!)
10:13:11 <glguy> @hoogle Monad m => [m a] -> m [a]
10:13:11 <ndm> @hoogle [m a] -> m [a]
10:13:13 <lambdabot> Prelude.head :: [a] -> a
10:13:13 <lambdabot> Prelude.last :: [a] -> a
10:13:13 <lambdabot> Prelude.head :: [a] -> a
10:13:13 <lambdabot> Prelude.last :: [a] -> a
10:13:13 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
10:13:25 <glguy> ?type sequence
10:13:26 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
10:13:34 <glguy> ?. hoogle type sequence
10:13:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *). ('
10:13:48 <ndm> glguy: Hoogle doesn't like higher kinded type classes, Monad m is actually further away from hoogle than IO in relation to sequence :)
10:14:01 <glguy> ?hoogle sequence
10:14:02 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
10:14:02 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
10:14:02 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
10:29:22 <fasta> C's / is Haskell's `div` assuming operations on fixnums?
10:31:05 <xerox> ?type ((/),div)
10:31:06 <lambdabot> forall a a1. (Fractional a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
10:31:18 <int-e> for positive integers it is; for negative integers it's a bit more complicated.
10:32:28 <twanvl> For negative integers div rounds down (which is in my experiency most often what you want)
10:37:08 <AstralStorm> Uh.
10:37:19 <AstralStorm> Rounds down = to negative infinity?
10:38:10 <AstralStorm> Or to 0
10:39:10 <AstralStorm> Is there no "hoogle-describe"?
10:41:00 <SamB> AstralStorm: hah
10:41:32 <SamB> types are easier to obtain than actual documentation ;-)
10:45:30 <zarvok> > (-4) `div` 3
10:45:32 <lambdabot>  -2
10:45:38 <zarvok> Negative infinity, I guess :)
10:46:42 <Lunar^> CosmicRay: there?
10:46:42 <AstralStorm> Bad.
10:46:43 <AstralStorm> :>
10:46:55 <AstralStorm> I'd prefer to 0
10:47:11 <int-e> > (-4) `quot` 3
10:47:13 <lambdabot>  -1
10:47:23 <zarvok> yeah, quot is what you want
10:47:36 <AstralStorm> Mhm.
10:48:14 <int-e> > (-4) `quotRem` 3
10:48:15 <lambdabot>  (-1,-1)
10:48:27 <AstralStorm> And it even works properly.
10:48:36 <zarvok> > (-4) `divMod` 3
10:48:38 <lambdabot>  (-2,2)
10:49:13 <CosmicRay> Lunar^: hi
10:51:10 <Lunar^> CosmicRay: Do you know what's the following of debbugs #384514?
10:51:41 <CosmicRay> Lunar^: ian lynagh is going to try reporting ghc to alpha
10:51:52 <CosmicRay> he believes that older ghc has a bug that is tickled when trying to compile newer ghc
10:52:03 <Lunar^> CosmicRay: uh...
10:53:10 <Lunar^> CosmicRay: maybe he should send that information to the BTS, this ghc RC bug prevent a lot of package from migrating
10:53:30 <Lunar^> CosmicRay: but you already know that
10:54:04 <CosmicRay> yup
10:58:24 <ndm> mini announcement of drhaskell - http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php
10:58:26 <lambdabot> Title: Neil Mitchell - Dr Haskell, http://tinyurl.com/lszw4
10:58:27 <ndm> what do people think?
10:59:27 <ndm> @where+ drhaskell http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php
10:59:28 <fasta> ndm: I think your name implies a tool similar to drscheme.
10:59:28 <lambdabot> Done.
10:59:40 <ndm> fasta: oh, hadn't thought of that
10:59:45 <ndm> @google dr scheme
10:59:47 <lambdabot> http://www.drscheme.org/
10:59:48 <lambdabot> Title: DrScheme
11:00:20 <ndm> well, its not similar in any way :)
11:00:25 <fasta> ndm: yours seems to be education too, so you share that with drscheme.
11:00:27 <ndm> but i do like the name...
11:00:43 <ndm> well the idea is education, but i'm hoping it might get a bit cleverer than that
11:00:50 <ndm> so its useful for normal programmers
11:02:22 <fasta> s/education/educational
11:03:17 <fasta> ndm: is it an interesting algorithm? Or do you have hardcoded that concat.map == concatMap?
11:03:37 <ndm> fasta: http://www.cs.york.ac.uk/fp/darcs/drhaskell/Hints.hs
11:03:37 <xerox> (concat .) . map == concatMap
11:03:41 <lambdabot> http://tinyurl.com/ghxqc
11:03:54 <ndm> its hardly hardcoded - it compiles that file at compile time
11:03:58 <ndm> * at runtime
11:04:14 <ndm> but its not computing it from any basic concepts
11:04:18 <SamB> Igloo could just send the ticket's URL to the BTS...
11:04:50 <ndm> fasta: additional hints welcome :)
11:05:04 <fasta> ndm: I would find computing it from basic concepts more interesting, but maybe less practical :)
11:05:30 <ndm> fasta: would be cool, but much much harder - currently its 50 lines of code :)
11:06:01 <fasta> ndm: 50 lines, I better not tell you what I am doing.
11:06:19 <ndm> what are you doing?
11:07:31 <fasta> ndm: yesterday I had one function of length about 100 lines (and yes, that was a sane way to define it).
11:07:54 <ndm> i regularly have massive functions
11:08:23 <ndm> its just that this time, since Yhc does this well, its very nice to do
11:08:34 <ndm> my phd project is now 26,000 lines...
11:09:25 <Igloo> Lunar^: I don't have any real information
11:09:29 <apfelmus> "broken code? dr. haskell treats it with a cast!
11:09:29 <apfelmus> broken head? dr. haskell calls emergency!
11:09:29 <apfelmus> your mind just exploded? well, for risks and adverse effects, you should have asked dr. haskell beforehand!"
11:09:31 <fasta> ndm: cool
11:10:10 <Lunar^> Igloo: you could just add your intentions :)
11:16:12 <emu> lawl
11:16:14 <emu> oops
11:16:58 <Igloo> Lunar^: rebootstrapping above, rather than the English word reporting, BTW
11:17:27 <Lunar^> Igloo: do you mind if I do the wording then?
11:18:03 <Igloo> What wording?
11:18:23 <Lunar^> send that you are working on rebootstraping the compiler to the BTS
11:18:45 * Igloo doesn't think that belongs in the BTS
11:19:23 <SamB> Igloo: where does it belong?
11:19:40 <Lunar^> Igloo: the last message in the BTS is CosmicRay's failure... You seem to have a solution in mind, I think that's a good idea to write that in the BTS
11:20:09 <Lunar^> Igloo: the scheduled release date is getting close, and a lot of other DD (and non-DD) are trying to get RC bugs fixed
11:20:15 <SamB> this is not a rhetorical question, but rather, after you told me the URL, I was going to suggest that you put that on the BTS...
11:20:50 <Igloo> Send it to the BTS if you want, but it's just the next thing I'm going to try. I have no particular reason to believe it'll work
11:21:14 <Lunar^> I'll do that, then
11:21:19 <DISTORTION> hello
11:21:30 <SamB> well, if it doesn't work, doesn't that mean that GHC is totally b0rk on alpha?
11:22:10 <SamB> isn't there some package for burning trees or something?
11:23:20 <Igloo> If it doesn't work then something needs to be fixed, yes
11:25:55 <fasta> SamB: it's called a matchbox.
11:26:42 <SamB> fasta: I thought it was called tinderbox ;-)
11:29:56 <zarvok> @users
11:29:56 <lambdabot> Maximum users seen in #haskell: 237, currently: 236 (99.6%), active: 41 (17.4%)
11:30:00 <zarvok> almost at max
11:30:59 <lscd> What libraries would people here use to parse c code using Haskell?  Various tools for c/Haskell interfaces have parsers, and there's c2hs (what happened to language.c, the soc project?) - are any of these known to be particularly good/bad/limited?
11:31:28 <fasta> lscd: why should your parser be written in Haskell?
11:31:38 <zarvok> I thought that didn't get approved as a soc project?
11:31:49 <lscd> fasta: for ease of manipulating the parse tree later on, also using haskell?
11:32:00 <lscd> zarvok: ah, didn't it?  That would explain it.
11:32:13 <SamB> I would use Language.C
11:32:26 <zarvok> no, I'm wrong, it's on the list
11:32:33 <SamB> if it is out
11:32:36 <zarvok> wonder why I thought otherwise
11:32:37 <fasta> lscd: what exactly do you want a parse tree or an AST?
11:32:41 <SamB> if it isn't, I would complain loudly
11:32:49 <SamB> zarvok: because you were confused!
11:33:19 <lscd> fasta: for adding assertions based on a custom language for security properties to aid static verification
11:33:25 <zarvok> looks like shapr was the mentor, you might bug him
11:33:38 <lscd> SamB: if it's out, i'm not finding it; and http://code.google.com/soc/haskell/about.html isn't listing it, confusingly
11:33:39 <lambdabot> Title: Google Code - Google Summer of Code - Organization Information
11:34:01 <zarvok> This page lists it as succesful:
11:34:04 <zarvok> http://hackage.haskell.org/trac/summer-of-code/
11:34:06 <fasta> lscd: so you assume correct input? In that case you only need an AST, and any parser can do that. You don't need a Haskell parser.
11:34:10 <lambdabot> Title: Haskell.org Google Summer of Code - Trac, http://tinyurl.com/pcog5
11:34:21 <SamB> lscd: perhaps because it is not being worked on anymore?
11:35:09 <lscd> fasta: true
11:35:43 <lscd> zarvok: good catch
11:36:02 <fasta> lscd: so, I suggest you take the most stable C parser in the world, and think of a suitable AST yourself or reuse the one outputted by the parser.
11:36:35 <lscd> fasta: ok.... any suggestions on the most stable c parser in the world?
11:36:45 <SamB> fasta: but how would you use an AST that wasn't Haskell?
11:36:59 <fasta> lscd: C Front is a nice parser, I think, but I don't know whether it's the most stable. I do know it works for some people in France, IIRC.
11:37:14 <fasta> SamB: wouldn't the data definitions be trivial?
11:37:21 <lscd> fasta: hm, ok - i've only spent time looking at gcc and ctool (avoid the latter like the plague)
11:37:32 <SamB> fasta: um. what mean you?
11:37:35 <fasta> SamB: parsing an AST is orders of magnitudes easier than the real thing.
11:37:52 <SamB> oh. you mean like printing out the AST and parsing it again?
11:37:55 <lscd> fasta: but most tools aren't obliging about dumping out their ASTs
11:38:01 <fasta> SamB: right, using pipes, or similar
11:38:10 <SamB> I thought you meant by doing FFI
11:38:13 <fasta> lscd: C front is designed for that.
11:38:25 <SamB> which would be an absolute PITA considering FFI doesn't support struct access
11:38:52 <lscd> SamB: ouch, why doesn't it?
11:39:12 <SamB> lscd: dunno!
11:39:18 <SamB> lack of demand maybe.
11:39:21 <lscd> hmm, ok
11:39:32 <SamB> or maybe they figure you could do that in C or something...
11:39:47 <SamB> or maybe it was too much work
11:39:51 <lscd> fasta: ok, sorry for the dumb question, but where's the c front homepage?  I'm finding a lot of stuff about front-ends for c, but I don't think I'm finding the specific one you mentioned.
11:40:14 <SamB> in any case, FFI is obviously quite useful even without direct support for struct access...
11:40:14 <fasta> lscd: It's written in Stratego, if I am not mistaken.
11:40:21 <fasta> lscd: Just like JavaFront
11:41:15 <SamB> okay, what is with all the tickets in japanese or chinese on this page: http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&order=priority
11:41:18 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/mgbuo
11:41:33 <lscd> Hm.  Searching for "'c front' parser stratego" doesn't seem to turn it up, unless it's http://nix.cs.uu.nl/dist/stratego/strategoxt-manual-0.16/manual/ref-parse-c.html
11:41:35 <lambdabot> Title: parse-c, http://tinyurl.com/l8at3
11:42:18 <SamB> what about http://darcs.haskell.org/SoC/Language.C/ ?
11:42:20 <lambdabot> Title: Index of /SoC/Language.C
11:42:26 <lscd> SamB: it's spam, in chinese
11:42:49 <SamB> lscd: I was wondering more along the lines of "why hasn't someone zapped it all?"
11:43:06 <fasta> lscd: parse-c is used to parse textual C files and obtain an abstract syntax tree in the ATerm format. It is not a fully featured C front-end. In particular, it does not do pre-processing.
11:43:07 <SamB> it is obviously spam ;-)
11:43:10 <lscd> SamB: because they find a zen refreshment in the "peacful led" messages? :)
11:43:14 <fasta> lscd: http://nix.cs.uu.nl/dist/stratego/strategoxt-manual-unstable-latest/manual/one-page/index.html
11:43:18 <lambdabot> Title: Stratego/XT Manual, http://tinyurl.com/qtb7u
11:43:22 <SamB> if it wasn't spam, it wouldn't be talking about LEDs so much ;-)
11:43:34 <SamB> also, it wouldn't be so repetetive
11:43:38 <lscd> fasta: hm. I could rig together gcc for preprocessing, then c front, then haskell code, but it seems like a somewhat complicated chain
11:44:00 <SamB> lscd: observe http://darcs.haskell.org/SoC/Language.C/
11:44:01 <lambdabot> Title: Index of /SoC/Language.C
11:44:20 <lscd> SamB: yeah - i'd found that, but thank you - I will give it a spin
11:44:36 <fasta> lscd: good luck
11:45:01 <lscd> fasta: thanks.  If it utterly fails, I may try the stratego route
11:45:32 <SamB> hmm, apparantly that repo does not actually contain Language.C...
11:45:52 <lscd> Though I have absolutely no experience with term-rewriting languages, so I doubt I could hack meaningfully on c front if needed
11:46:01 <sris> if i have a sequence, and e.g. three indexes, and want to create a "sublist" with the elements from the list at those indices? is there an easy wat to do that?
11:46:53 <Lemmih> sris: [lst!!idx1, lst!!idx2, lst!!idx3]?
11:47:01 <SamB> Lemmih: you fail!
11:47:04 <lscd> SamB: hm, what about under http://darcs.haskell.org/SoC/Language.C/lc/ ? There's a lexer and a parser there
11:47:05 <lambdabot> Title: Index of /SoC/Language.C/lc
11:47:08 <lscd> hey Lemmih :)
11:47:14 <Lemmih> Hiya lscd.
11:47:23 <Lemmih> SamB: I do?
11:47:26 <SamB> lscd: yes but the module names do not begin with Language.C ;-P
11:47:50 <SamB> Lemmih: you are supposed to take two sequences as input
11:48:27 <Lemmih> SamB: I am?
11:48:53 <SamB> > let f xs is = map (xs!!) in f [1..] [1, 5, 7]
11:48:54 <lambdabot>  Add a type signature
11:49:05 <SamB> hmm
11:49:15 <SamB> > let f xs is = map (xs!!) is in f [1..] [1, 5, 7]
11:49:16 <lambdabot>  [2,6,8]
11:49:32 * SamB suppose 'is' is not a good name for a variable...
11:50:54 <musasabi> (i:is) makes some sense when pattern matching (but other letters make more sense)
11:51:15 <SamB> is looks too much like a word ;-)
11:51:47 <musasabi> as is even worse.
11:51:53 <SamB> true
11:59:06 <lscd> SamB: well, I tried Language.c ... I ran a darcs get, ran the setup stuff, installed it..
11:59:31 <SamB> I think at this point you have to steal the code
11:59:38 <SamB> judging by the cabal file
11:59:40 <lscd> unfortunately, Main.hs is short enough that I can paste it here
11:59:48 <lscd> -- Testcode
11:59:48 <lscd> main :: IO ()
11:59:48 <lscd> main = putStr "Just some string for now."%
11:59:55 <lscd> eh, yeah
12:00:28 <lscd> on the good side, the results of running it are really predictable
12:01:03 <SamB> heh
12:03:04 <SamB> it looks as if someone will need to fix it up before it can actually be used as a library...
12:03:37 <SamB> you know, move things around, zap what isn't needed, stuff like that...
12:04:07 <SamB> make it build as a library...
12:22:16 <newsham> hi
12:30:46 <ndm> hi newsham
12:31:06 <ndm> @where drhaskell
12:31:07 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php
12:31:14 <ndm> @tell dons http://www-users.cs.york.ac.uk/~ndm/projects/drhaskell.php :)
12:31:15 <lambdabot> Consider it noted.
12:35:25 <glguy> is that Haskell for DrScheme?
12:36:14 <glguy> hmm, nvm
12:37:50 <lispy> ndm++
12:37:52 <lispy> ndm: neat-o
12:38:08 <glguy> why does it rely on YHC?
12:38:29 <ndm> glguy: it uses Yhc Core
12:38:47 <ndm> glguy: which is much much nicer than GHC core for this particular task (if its even possible in GHC core)
12:38:55 <glguy> ah
12:38:57 <ndm> with yhc you can compile a file with
12:39:08 <ndm> yhc -core - and it spits out some nice Core file that it can work with
12:39:17 <ndm> which means that the code ends up being 50 lines :)
12:39:17 <glguy> ah
12:39:47 <ndm> hopefully more projects will start to work with Yhc core - its Core for humans, not Core for the internal of lambda calculus machines :)
12:40:05 <ndm> lispy: thanks, its still very early on
12:43:45 <Philippa> how does Yhc Core actually differ, JOOI?
12:44:13 <Philippa> (I can't help thinking that it's hard to have a really good explicitly typed IR that's really human-friendly just due to the sheer quantity of typing)
12:48:14 <newbcoder> how do I open a file for io?
12:49:53 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#4
12:49:56 <lambdabot> http://tinyurl.com/kpt7m
12:50:40 <newbcoder> cool; thanks;
12:54:55 <ndm> Philippa: nicer names, which correspond more closely to the original
12:55:06 <ndm> Philippa: simpler structure - no complex let-recs
12:55:26 <ndm> Philippa: some beautiful properties, like you can splat many Yhc Core files together and end up with one Yhc Core file
12:55:39 <ndm> more predictable compiling - i.e. less "playing" with the Core
12:55:45 <ndm> position information for the source of items
12:56:07 <ndm> based on Haskell, i.e. let/case, not with a brand new GHC specific syntax
12:56:13 <ndm> easier parsing - "read" does the job
12:56:32 <ndm> much much smaller data structure - even ignoring the fact that types aren't included
12:57:04 <ndm> (we would have put types in, but by that stage of Yhc, they're all totally wrong!)
12:57:26 <newbcoder> is there a good haskell cookbook out there anywere?
12:58:29 <mauke> http://haskell.org/hawiki/CommonHaskellIdioms - kind of
12:58:30 <lambdabot> Title: CommonHaskellIdioms - The Haskell Wiki
13:19:28 <lscd> ndm++
13:25:34 <ndm> thank you lscd :)
13:26:27 <lscd> naw, thank you; the drscheme/haskell thing looks cool from what's been said in the chan; i may take a look when i get my head out of the dragon book :/
13:27:57 <ndm> its nothing like drscheme, just to be clear
13:29:15 <lscd> ohhhhhhh, that's what it is
13:29:21 <lscd> the newbie 'you should consider using...' thing
13:29:24 <lscd> excellent! :)
13:29:26 <lscd> ndm++
13:30:08 <ndm> yep - although hopefully for more than just beginners
13:30:46 <glguy> Do you have the rules listed anywhere on the site?
13:30:47 <SamB> ndm: your core has totally wrong types?
13:30:56 <glguy> or would someone have to just root through each of the hints files?
13:30:59 <ndm> glguy: in hints.hs
13:31:00 <lscd> eh, hopefully
13:31:22 <ndm> glguy: but yeah, basically you have to go through hints, until someone documents them all :)
13:31:23 <lscd> glguy: that should just be a matter of prettifying the output, ne?
13:31:45 <ndm> SamB: yep, its been desugared, so the Core's type has chganged
13:31:51 <SamB> ndm: why does Yhc's core not have an internally consistant type system?
13:32:27 <ndm> SamB: because :) - thats not the way its designed
13:32:39 <SamB> that sounds scary!
13:32:48 <ndm> SamB: GHC was one of the first to maintain types through the compiler, its actually pretty rare (or was when nhc was written)
13:33:01 <SamB> remind me not to hack Yhc's optimizer...
13:33:07 <lscd> it still sounds scary
13:33:07 <Syzygy-> @docs
13:33:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:33:44 <SamB> ndm: I have my doubts as to whether the design actually precludes adding types...
13:34:13 <lscd> ndm: I don't think you were around when I asked before, so on the off chance... do you know any good c parsers, preferably which are either in haskell or which can dump to a format which is significantly easier to parse than the original c was?
13:34:38 <ndm> SamB: it doesn't - but remember desugared haskell needs rank-2 types, and Yhc doesn't have them
13:34:48 <ndm> SamB: and there is no optimiser (yet) - i'm writing it now
13:35:03 <twanvl> lscd: http://cvs.haskell.org/darcs/SoC/Language.C/
13:35:04 <ndm> lscd: nope, other than the SoC project...
13:35:04 <lambdabot> Title: Index of /darcs/SoC/Language.C
13:35:52 <lscd> ndm: i've already grabbed it; unfortuanately, the binary it builds only prints out "Just some string for now."
13:36:21 <SamB> @tell dcoutts please clean up Language.C for general use or find someone to do it ;-)
13:36:22 <lambdabot> Consider it noted.
13:36:22 <lscd> (main is two lines, 3 if you count the '-- Testcode' comment, so it's not just a matter of giving it the right arguments either.)
13:36:46 * dcoutts__ wonders why SamB thinks it's his responsability
13:37:00 <lscd> there are a huge number of _bad_ c parsers, but those are of limited help :/
13:37:05 <glguy> dcoutts__: not you, dcoutts
13:37:09 <SamB> dcoutts: I think you might have an idea how much of that code should be in there
13:37:11 <ndm> i'm going to write a C parser
13:37:13 <lscd> glguy: heh.
13:37:25 <lscd> ndm: cool; for what parts of c, in what language, and when?
13:37:26 <ndm> but i'm going to write a parser generator first, so don't hold your breath...
13:37:29 <lscd> ack
13:37:31 <SamB> because it seems like a lot of it is just from c2hs
13:37:36 <ndm> all, of course
13:37:39 <dcoutts__> ndm: ha ha ha
13:37:59 <lscd> ndm: right, I'm assuming you mean k&r, c89/90, and c99; but what about compiler-specific extensions?
13:38:18 <SamB> lscd: what?
13:38:23 <SamB> you want compiler-specific extensions?
13:38:30 <SamB> you better add them yourself!
13:38:30 <dcoutts__> ndm: btw, if you can get the C type/ident grammer problem nailed then please tell me how
13:38:41 <lscd> SamB: if you're verifying code from a system that uses gcc, good luck doing anything without them :/
13:38:47 <ndm> lscd: i'm going to write an awesome parser generator, then an awsome parser - and it will be trivial to add extensions
13:38:52 <SamB> dcoutts__: must parse headers first ;-)
13:39:07 <SamB> lscd: verifying?
13:39:14 <SamB> verifying isn't something you do with C code!
13:39:17 <dcoutts__> SamB: huh?
13:39:22 <lscd> SamB: eh - i'm working with some model checking people, and they're not convinced
13:39:27 <SamB> its called praying ;-)
13:39:30 <lscd> i'm increasingly thinking you're right, but ssssh
13:39:56 <SamB> well, I mean, you could probably manage somehow if you are willing to rewrite the code
13:39:58 <dcoutts__> SamB: where is this standard Language.C that you're talking about? I wasn't aware that there was one.
13:40:06 <dcoutts__> but if there is, starting with c2hs is a good idea
13:40:07 <lscd> regardless, the parser we're using right now is so bad that the principle author has a project going to make standard headers that are parseable by it, since the ones on actual systems aren't
13:40:35 <dcoutts__> c2hs can actually parse most system headers
13:40:39 <SamB> dcoutts: note exactly standard, but... http://darcs.haskell.org/SoC/Language.C/
13:40:39 <lambdabot> Title: Index of /SoC/Language.C
13:40:46 <lscd> dcoutts: it was a soc project, and it's at ... where SamB said
13:40:49 <SamB> er, not
13:40:57 <dcoutts__> SamB: ah that, I don't know how far it got
13:41:08 <lscd> dcoutts: hm. which suggests that it's definitely where I should look next
13:41:12 <dcoutts__> c2hs does have occasional problems with parsing system headers on some systems
13:41:18 <dcoutts__> but generally it's pretty good
13:41:26 <lscd> how decent is the code of c2hs itself?
13:41:43 <dcoutts__> it's enough to parse all the Gtk+ headers on linux,windows,*bsd, solaris and OSX
13:42:00 <dcoutts__> it's currently choking on glibc-2.4 system headers
13:42:07 <dcoutts__> probably some new gnu extension
13:42:15 <dcoutts__> lscd: not too bad
13:42:24 * lscd downloads
13:42:28 <dcoutts__> lscd: the C lexer and parser are quite good :-)
13:42:33 * dcoutts__ wrote them
13:42:39 <lscd> excellent. :)
13:42:42 <dcoutts__> they use alex & happy
13:42:47 <lscd> ahh, cool
13:42:52 <dcoutts__> but there is a problem with our grammar
13:43:05 <dcoutts__> though it doesn't crop up in practice much
13:43:06 <lscd> any particular reason they use those instead of parsec? (this isn't a criticism or anything, i'm just curious)
13:43:12 <lscd> hm. what's the problem?
13:43:18 <SamB> lscd: parsec is too unpredictable
13:43:27 <SamB> and doesn't cooperate well with lexers
13:43:29 <lscd> SamB: howso?
13:43:35 <dcoutts__> speed and knowing when we are free of shift/reduce conflicts
13:43:43 <dcoutts__> you can't know that with parsec
13:43:46 <SamB> also knowing WTH the grammar is
13:44:07 <lscd> yeah... i wondered if that was why; the roskind grammar docs were saying essentially the same thing, though they predate parsec by about a decade
13:44:16 <dcoutts__> where conflicts is some weak proxy for absense of ambiguity
13:44:22 <glguy> found in GHC rts/Linker.c: ASSERT(2+2 == 5);
13:44:39 <dcoutts__> glguy: nice
13:44:53 <lscd> dcoutts: hm. so, what's the problem in your grammar?
13:45:21 <dcoutts__> lscd: one of the problems we used to have with c2hs was that it was too slow, when it's got to parse Mb of headers that's important
13:45:27 <dcoutts__> lscd: let me find the email...
13:45:46 <syntaxfree> so.
13:45:57 <syntaxfree> Either is supposed to be an instance of the Functor class.
13:46:18 <ndm> @seen psnl
13:46:19 <lambdabot> psnl is in #darcs, #haskell-blah and #haskell. I don't know when psnl last spoke.
13:46:28 <lscd> ack - fast is good, but unless slow is 10s of minutes for fairly standard system headers in barely-beyond-hello-world apps (ie, some basic networking, string handling, etc), it'll probably be fast enough for me to play with
13:46:48 <ndm> @tell psnl any updates on how your hat work is going? i'm still looking forward to it :)
13:46:49 <lambdabot> Consider it noted.
13:47:10 <dcoutts__> lscd: gtk2hs uses c2hs to compile about 100 files, I can assure you it got boring when each run of c2hs took >10sec
13:47:26 <dcoutts__> actually it was considerably worse than that
13:47:26 <lscd> one run per file?
13:47:30 <dcoutts__> aye
13:47:48 <syntaxfree> why doesn't
13:47:51 <lscd> ack... yeah, that would be a bit painful; on the good side, with model checking, most examples are a _lot_ smaller than gtk
13:47:53 <syntaxfree> > fmap (+1) (Left a)
13:47:54 <lambdabot>  Not in scope: `a'
13:47:57 <syntaxfree> er
13:47:57 <dcoutts__> it took several minutes + many hundeds of Mb
13:48:01 <syntaxfree> > fmap (+1) (Left 2)
13:48:02 <lambdabot>  add an instance declaration for (Functor (Either a))
13:48:02 <lambdabot>   In the definition ...
13:48:09 <lscd> dcoutts: any idea why it's so slow?
13:48:15 <syntaxfree> yet, from the Data.Either documentation..
13:48:42 <syntaxfree> Instances
13:48:43 <syntaxfree> Typeable2 Either
13:48:43 <syntaxfree> Functor (Either a)
13:48:47 <syntaxfree> @instances Data.Either
13:48:48 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:48:54 <dcoutts__> lscd: two, the lexer was slow and it was doing a nasty thing to modify the token stream after parsing each top level decleration
13:48:59 <syntaxfree> @instances Functor
13:49:00 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:49:09 <syntaxfree> there it is.
13:49:18 <lscd> dcoutts: and this is hard to change?
13:49:37 <dcoutts__> lscd: that's how slow it was before I rewrote it to use alex + happy. Now it's quick.
13:49:43 <dcoutts__> very quick
13:49:48 <lscd> oh, excellent. you had me worried :)
13:50:01 <dcoutts__> lscd: parsing C is tricky because the grammar distinguishes normal identifiers vs type identifiers
13:50:27 <dcoutts__> and you don't find out if it's a type or normal 'til you parse preceding bits
13:50:33 * SamB wants a double-buffered PDF viewer
13:50:33 <lscd> dcoutts: yeah; i've spent the last several hours reading about it, and there are some extremely nasty corners
13:50:38 <cjeris> dcoutts__: so, if "not making the grammar clear" and "ambiguity" are disadvantages of parsec vs alex/happy, are there any major advantages?
13:50:55 <dcoutts__> cjeris: it's quick and easy
13:51:10 <lscd> dcoutts: well, for values of quick and easy - once you have your head around it, maybe
13:51:26 <lscd> i haven't used alex/happy, but i've used lex/yacc, and i've used parsec, and parsec was way, way harder to get my head around for basic use
13:51:39 <dcoutts__> lscd: that was the reason for the fiddling with the token stream between parsing bits in the old parser
13:51:47 <SamB> I never got my head around lex or yacc in the first place
13:51:56 <ndm> cjeris: when i did it for hoogle queries, Parsec had some amazing advantages - http://neilmitchell.blogspot.com/2006/08/parsec-and-hoogle.html
13:51:58 <lscd> dcoutts: ahh, yeah
13:51:59 <lambdabot> Title: Neil Mitchell's Haskell Blog: Parsec and Hoogle, http://tinyurl.com/mlh47
13:52:09 <SamB> happy ain't so bad though
13:52:22 <SamB> it is amazing what a typesystem will do for your understanding
13:52:29 <lscd> SamB: yeah
13:54:24 <dcoutts__> lscd: http://www.haskell.org/pipermail/c2hs/2005-December/000534.html
13:54:27 <lambdabot> Title: [C2hs] A problem parsing a C header, http://tinyurl.com/ffqxf
13:55:10 <lscd> dcoutts: have you seen http://c-faq.com/resources/grammars.html btw?
13:56:54 <lscd> the roskind grammar it mentions comes in an archive that talks at some length about similar problems
13:58:19 <glguy> HAHAHA GHCI working on OPENBSD
13:58:43 <lscd> glguy: why HAHAHA?
13:58:46 <SamB> glguy: what is so funny about that?
13:58:52 <SamB> is it strange in some way?
13:58:57 <SamB> isn't that what dons uses?
13:59:10 <lscd> is that a laugh of triumph, because you just got it working?
13:59:13 <glguy> ?tell dons dl_libc_handle was not being initialized, initializing it allows ghci to work again, I am now searching for what #if was breaking this
13:59:14 <lambdabot> Consider it noted.
13:59:30 <glguy> yeah, ghci broken on current versions of openbsd
13:59:34 <lscd> ahhh
13:59:35 <lscd> congrats!
13:59:41 <glguy> but not on mine ;)
13:59:49 <SamB> does dons use a non-current version, or was he behind?
13:59:56 <glguy> he's way behind
13:59:59 <SamB> behind in GHC versions I meant
14:00:00 <glguy> ?version
14:00:00 <lambdabot> lambdabot 4p200, GHC 6.5 (OpenBSD i386 )
14:00:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:00:06 <glguy> his openbsd version is behind
14:00:10 <SamB> ah
14:00:50 <lscd> dcoutts: anyhow, if you haven't, http://www.cs.utah.edu/research/projects/mso/goofie/grammar5.txt
14:00:53 <lambdabot> http://tinyurl.com/zg5r5
14:02:51 <glguy> ?tell dons rts/Linker.c : initLinker() : #if defined(openbsd_HOST_OS) needs to be unnested from the previous #if, OpenBSD defines RTLD_DEFAULT now
14:02:51 <lambdabot> Consider it noted.
14:04:39 <lispy> people were talking about C parsers today...do we have one i can use?
14:05:04 <SamB> lispy: if you'd like to clean up http://darcs.haskell.org/SoC/Language.C/ ;-)
14:05:05 <lambdabot> Title: Index of /SoC/Language.C
14:05:16 <lispy> anything wrong with it?
14:05:18 <SamB> and make it build as a library package
14:06:09 <SamB> well, the module names don't start with Language.C, the cabal file doesn't build it as a library, and I think there is a lot of unneeded code left from c2hs
14:06:10 <lscd> lispy: if you find one, tell me; and if it's within the  next say, 3 days, extra credit
14:06:17 <SamB> no idea what else is wrong with it
14:06:38 <lispy> lscd: what it your SoC project?
14:06:38 <lscd> SamB: the actual binary built only prints a constant string; i think that counts too
14:06:43 <lispy> er was*
14:06:45 <lscd> lispy: nope
14:06:47 <SamB> lscd: that is immaterial
14:06:49 <lscd> i didn't participate in soc
14:06:55 <SamB> you don't want it to build a program, you want a library
14:07:05 <lscd> SamB: secondary, yes, immaterial, questionable; it could be useful as a program too
14:07:43 <SamB> well, it would be reasonable to have a nice utility, but the main thing is for it to be a library!
14:07:54 <lscd> agreed!
14:07:57 <lispy> hmm..it doesn't parse comments does it?
14:08:04 <SamB> why would it?
14:08:11 <SamB> I mean, beyond skipping them
14:08:12 <lispy> compilers like ghc do it :)
14:08:15 <Syzygy-> Huh?
14:08:19 <SamB> there isn't any structure to comments you know ;-)
14:08:25 <SamB> not in C, anyway...
14:08:25 <Syzygy-> How do I compile a module and link it into a program I work on?
14:08:35 <SamB> Syzygy-: ghc --make
14:08:37 <Syzygy-> I tried compiling the module with ghc -c module.hs
14:08:39 <Syzygy-> Ah.
14:08:42 <lscd> SamB: not that that stops people from encoding magic in them and hoping things don't break
14:08:46 <SamB> just run that on your main file
14:08:49 <lispy> Syzygy-: start using cabal :)
14:08:52 <SamB> and it should build your program
14:08:59 <lispy> Syzygy-: it's worth the 10-15 minutes to learn it
14:09:25 <SamB> lispy: is it worth hours linking lambdabot?
14:09:42 <lscd> hours linking lambdabot?
14:09:54 <SamB> well, I think it might take that long if I let it finish
14:09:57 <lispy> SamB: i'm confused
14:10:11 <lispy> SamB: just use lambdaweb :)
14:10:15 <lispy> @where lambdaweb
14:10:16 <lambdabot> I know nothing about lambdaweb.
14:10:17 <SamB> lispy: well, thanks to Cabal, it is no longer easy to build the dynamic version
14:10:19 <lispy> gah
14:10:34 <lispy> does dons delete the @where+ things if he doesn't like them?
14:10:40 <lispy> i've added that one about 3 times now
14:10:41 <SamB> also, that doesn't do a good job of replacing lambdabot when lambdabot conks out
14:10:56 <SamB> maybe lambdabot conked out again without saving its junk properly?
14:11:06 <SamB> it does that sometimes
14:11:11 <Syzygy-> lispy: Right-o.
14:11:20 <SamB> there ought to be a @sync command
14:12:13 <lispy> SamB: hmm....i think some of the plugins flush their state whenever it changes
14:12:23 <SamB> oh really?
14:12:25 <lispy> SamB: maybe @where just doesn't flush often enough
14:15:34 <SamB> I didn't know google had a BTS for public use...
14:17:51 <lispy> so did this SoC student not finish?
14:18:00 <lispy> this code doesn't seem to be ready for much of anything
14:18:19 <SamB> lispy: well, supposedly this student succeeded...
14:18:41 <SamB> see that soc trac
14:18:45 <lscd> lispy: this was apparently a 'successful' project
14:19:10 <lispy> odd
14:19:15 <lscd> quite
14:19:28 <lispy> it doesn't seem ready...and i don't see any tests
14:19:29 <dcoutts__> the Lang.C one was not sucessful
14:19:36 <dcoutts__> sadly
14:19:39 <lispy> dcoutts__: okay :(
14:20:17 <lispy> dcoutts__: yeah, i'd like to (as a toy) make a C compiler, but i always get stuck in the parser phase :)
14:20:46 <SamB> dcoutts: someone should fix the trac page!
14:22:06 <Syzygy-> Hah. Look at that. I got a HSL->RGB function together.
14:22:22 <lispy> Syzygy-: cool
14:22:29 <SamB> oookay...
14:22:58 <SamB> Yhc build failed because Yhc couldn't find Data.Ratio...
14:23:36 <gmh33__> don't use YHC ? :P
14:24:00 <SamB> gmh33__: I was only trying to build Yhc itself!
14:24:10 <SamB> not with Yhc either
14:24:10 <gmh33__> then yell at them ! D:<
14:24:21 <SamB> I was going to try and figure out what was wrong ;-)
14:25:00 <gmh33__> I wonder why YHC isn't ported to os x since it's ansi c
14:25:02 <gmh33__> it should compile fine..
14:25:18 <SamB> why don't you darcs get it and try typing scons?
14:25:23 <SamB> assuming you have SCons installed
14:25:41 <dcoutts__> I don't think yhc is self-hosting yet
14:25:50 <dcoutts__> though it's close I believe
14:26:05 <SamB> dcoutts__: I wasn't trying to build it with itself... not yet anyway!
14:26:13 <dcoutts__> ok :-)
14:26:15 <gmh33__> ghc is good enough for me :P
14:26:42 <gmh33__> and by "ported to os x" I meant the VM
14:26:48 <gmh33__> not the compiler
14:27:21 * SamB wonders why he has to show up as naesten on Google Code
14:28:08 <lscd> why wouldn't you?
14:28:39 <SamB> well, what if I wanted to show up as "Samuel Bronson <naesten@gmail.com>" or something?
14:28:59 <lscd> ahh, right
14:29:50 <SamB> oh well, I included my IRCnick in the comment I just made anyway... almost by accident...
14:30:41 <lscd> url?
14:31:02 <SamB> http://code.google.com/p/yhc/issues/detail?id=2
14:31:04 <lambdabot> Title: yhc - Google Code, http://tinyurl.com/h9oe7
14:37:28 <lscd> I'm surely missing something obvious, but the use of c2hs is documented as "c2hs Lib.chs" "where Lib.chs is the Haskell binding module defining the Haskell interface to a C library together with the required marshalling code." - but where does the .chs file come from?  Ie, is it hand-generated?
14:37:52 <SamB> yes!
14:38:14 <SamB> you obviously aren't going to be able to use c2hs itself...
14:38:36 <lscd> Sure.. I wasn't expecting c2hs to be the source of that file, since you'd have a wee bit of a bootstrapping problem
14:38:51 <nomeata> Hi. Is there a wiki software written in haskell?
14:38:54 * edwardk waves hello.
14:40:38 <bringert> nomeata: yes, flippi
14:40:53 * lscd waves hi to edwardk 
14:41:25 <bringert> I also have a very basic wiki in haskell, but it's the solution for lab in a course I'm teaching, so I can't release it, at least not atm
14:42:24 <dcoutts__> lscd: the .chs file is what you write, yes
14:42:51 <dcoutts__> lscd: it's a normal .hs file but with some extra syntax, like {# call gtk_foo_bar #}
14:43:17 <dcoutts__> which c2hs expands into an ffi decl of the correct type
14:43:26 <Syzygy-> Ooooh.
14:43:53 <dcoutts__> lscd: gtk2hs uses .chs files for almost everything
14:44:21 <dcoutts__> lscd: interesting paper on the ambiguities in C/C++ bte
14:44:23 <lscd> ahh, cool; so this complements ffi code like greencard? (newbie question; I've done basically no ffi stuff)
14:44:24 <dcoutts__> bte/btw
14:44:38 <dcoutts__> lscd: I've never used greencard, so dunno
14:44:56 <lscd> dcoutts: yeah; it was what convinced me i would be in serious pain if I tried to write my own parser
14:45:04 <dcoutts__> it's good because it ensures that you're using the right types for the C code
14:45:21 <lscd> hm? the chs file?
14:45:32 <dcoutts__> c2hs ensures it
14:45:55 <dcoutts__> because it generates haskell code that's the right type
14:46:09 <lscd> ah, yeah; that's a win
14:46:33 <dcoutts__> especially if the C api you're using isn't totally stable
14:46:48 <dcoutts__> c2hs will notice when the .h files change in incompatible ways
14:47:02 <dcoutts__> so you never need to maintain .idl files
14:48:51 <lscd> as in the omg thing?
14:57:01 <SamB> hmm
14:58:49 <malcolm> c2hs starts with some C header file and generates Haskell for it.  Greencard starts with some Haskell code + inlined C and generates the necessary links from there.  So yes, they are kind of duals.
14:59:42 * SamB tries updating scons, to see if Yhc will build then...
15:00:16 <lscd> malcolm: thanks for the explanation
15:10:34 <cinema> bringert, you were right about haskelldb and hs-plugins. My problem was with hs-plugins
15:10:50 * syntaxfree waves nonchalantly
15:11:07 <cinema> bringert, I have written a test program using static drivers. It could be of some use as an example
15:11:39 <syntaxfree> > (sequence . repeat) (getLine >>= print . sum . (map ord))
15:11:41 <lambdabot>  Pervert!
15:12:02 <lscd> Why does lambdabot say pervert to that?
15:12:03 <glguy> ?
15:12:07 <syntaxfree> I know.
15:12:08 <glguy> because you used IO?
15:12:18 <syntaxfree> or because it was infinite?
15:12:26 <glguy> > getLine
15:12:27 <lambdabot>  Pervert!
15:12:28 <lscd> > getLine
15:12:29 <lambdabot>  Pervert!
15:12:29 <lscd> eh.
15:12:34 <lscd> looks like IO is enough
15:12:43 <glguy> I kind of prefered the NO IO message myself
15:13:14 <lscd> > let fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)]
15:13:15 <lambdabot>  Parse error
15:13:25 <lscd> > fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)]
15:13:25 <lambdabot>  Parse error
15:13:29 <lscd> hm.
15:13:30 <glguy> let
15:13:34 <lscd> i said let the first time
15:13:38 <glguy> in
15:13:41 <glguy> let ... in ...
15:13:44 <lscd> right, oops
15:14:39 <lscd> >let fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)] in fibs!!30
15:14:55 <Patterner> Parse error
15:15:04 <lscd> works in ghci
15:15:11 <int-e> > {- <-- note the space -} 1+1
15:15:12 <lambdabot>  2
15:15:14 <lscd> Do I need a space after the '>'?
15:15:14 <Patterner> > let fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)] in fibs!!30
15:15:15 <lambdabot>  832040
15:15:16 <lscd> .... guess so
15:15:28 <bringert> cinema: great! feel free to post it to the haskelldb mailing list
15:15:29 <lscd> hm. so it looks like infinity is fine, as usual, glguy
15:15:48 <glguy> ?
15:15:52 <cinema> bringert, OK, I'll do it
15:16:43 <syntaxfree> simpler test:
15:16:44 <syntaxfree> > [1..]
15:16:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:16:53 <syntaxfree> yes, infinity is fine ;)
15:16:59 <glguy> who said inifite lists are bad?
15:17:03 <syntaxfree> > zipWith (+) [1..] [2..]
15:17:05 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
15:17:33 <glguy> what is the syntax for parallel list comprehensions?
15:17:39 <glguy> I never use it and always forget
15:18:02 <int-e> multiple |
15:18:05 <araujo> > zipWith (+) [1, 2 ..] [3, 5 ..]
15:18:07 <lambdabot>  [4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79...
15:18:07 <glguy> > [a + b | a <- [1..] | b <- [2..]]
15:18:08 <lambdabot>  Parse error
15:18:24 <lscd> glguy: no one, but you wondered if the 'pervert' was due to infinity or io, ne?
15:18:28 <int-e> > [a + b | (a, b) <- zip [1..] [2..]]
15:18:29 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
15:18:35 <glguy> lscd: nope, I noticed it was because of IO
15:18:44 <int-e> I think explicit zips are much clearer
15:18:58 <glguy> sure, but I'm asking about parallel list comprehensions :)
15:18:59 <lscd> glguy: sure; but just for the heck of it, i decided to confirm on infinity anyhow
15:19:04 <MarcWeber> > [a + b | a<-[1..3], b<-[1..4]]
15:19:06 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7]
15:19:06 <lscd> glguy: parallel how? multiple vars?
15:19:17 <int-e> glguy: I think that's the syntax, but lambdabot doesn't accept it
15:19:35 <lscd> int-e: looks good in ghci - i think you're right
15:19:48 <glguy> lscd: ah , winhugs buys it
15:21:40 <glguy> works outside of lambdabot: let fibs = 1:1:[a+b|a<-fibs|b<-tail fibs] in take 10 fibs
15:21:44 <MarcWeber> Thanks. didn't knew that. I was using zip all the time .. ;-) Much nicer to type/read
15:21:58 <glguy> MarcWeber: your example didn't use parallel list comprehension
15:22:32 <MarcWeber> I know. But the not working example did. ^^ The hint that it works in ghci was enough to try ..
15:22:41 <glguy> ah, ok
15:23:31 <glguy> > let fibs = 1:1:[a+b | (a:b:_) <- tails fibs] in take 10 fibs
15:23:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
15:25:59 <glguy> time to head home
15:26:03 * glguy &
15:27:38 <int-e> > let gen g i = l where l = i ++ [sum (zipWith (*) g t) | t <- tails l] in take 11 $ gen [1,1] [0,1]
15:27:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55]
15:27:51 <int-e> > let gen g i = l where l = i ++ [sum (zipWith (*) g t) | t <- tails l] in take 11 $ gen [1,1,1] [0,0,1]
15:27:52 <lambdabot>  [0,0,1,1,2,4,7,13,24,44,81]
15:31:09 <SamB> hmm, anyone know how to use buildbot?
15:31:38 <Igloo> I've played with it a bit, why?
15:31:55 * Igloo may get distracted by a talk in a minute
15:32:08 <SamB> oh, at ICFP are you>
15:32:13 <SamB> s/>//
15:32:19 <Igloo> Yup
15:32:35 <Limbic_Region> Igloo - I have had recent build failures on Win32 with something in libraries
15:32:39 <SamB> nevermind, I'm struggling with dpkg/apt
15:32:50 <Limbic_Region> known?
15:33:01 <Igloo> Limbic_Region: Don't think so - what in libraries?
15:33:20 <SamB> oh, zopeinterfaces problem...
15:33:20 <Limbic_Region> don't know - I just did a make clean and am going to build from scratch
15:33:30 <Limbic_Region> just cause I am paranoid and have a few hours to kill
15:33:34 <SamB> er,s/s$//
15:34:42 <SamB> I may have installed that manually...
15:34:57 <SamB> which is a stupid thing to do, obviously
15:35:44 * SamB just hopes the Twisted he has in his personal PYTHONPATH won't screw things up
15:39:56 * edwardk waves hello.
15:48:19 <edwardk_> j #coq
15:48:20 <edwardk_> er
15:50:12 * dcoutts__ notes that today is international talk like a pirate day
15:50:14 <dcoutts__> @yarr!
15:50:14 <lambdabot> Prepare to be boarded!
15:50:24 <edwinb> 12 minutes to go yet!
15:50:33 <dcoutts__> not where I am :-)
15:50:38 <edwinb> sorry; there be 12 minutes to go yet, ya scurvy lubber
15:50:45 <dcoutts__> arr
15:50:54 <pianodogg> so the pirates are on utc, eh?
15:51:01 <edwinb> @yarr!
15:51:01 <lambdabot> Gangway!
15:51:09 <dcoutts__> not where I be they don't be
15:51:17 <edwinb> where be you?
15:51:34 <dcoutts__> I be in .se I be
15:53:14 <sjanssen_> alas, it's still International International Talk Like A Pirate Day's Eve in my timezone
15:53:29 <sjanssen_> minus an international
15:54:07 <dcoutts__> dons: so I be 'avin a plan...
15:54:17 * dcoutts__ moves to #haskell-overflow
15:56:23 <syntaxfree> "Tackling the awkward squad" is such a great paper.
15:56:30 <syntaxfree> It's on my top 5 paper list.
16:00:38 <edwardk_> this current talk is making me happy that I code in Haskell. (its all modules/units/complicated importing stuff in ML)
16:03:05 <nomeata> I want to modify the result of an IO action before saving it. what is considered nicer, "file = liftM head getArgs" or "file = getArgs >>= return.head", or is there something even better?
16:03:37 <ndm> why not (x:xs) <- getArgs ?
16:03:45 <syntaxfree> I like the second better.
16:03:52 <syntaxfree> pattern-matching is even better, though.
16:04:05 <nomeata> ok, works in this case, but not every function has an inverse that can be implemented in pattern matching :-)
16:04:20 <syntaxfree> I like the plain use of bind.
16:04:28 <syntaxfree> liftM makes me queasy.
16:05:15 <araujo> you could also use
16:05:21 <nomeata> bind?
16:05:22 <araujo> fmap head getArgs
16:05:26 <erider> hi araujo
16:05:31 <araujo> hello erider
16:05:35 <syntaxfree> bind is >>=
16:05:37 <erider> como ta todo
16:05:46 <nomeata> oh, ok :-)
16:05:47 <araujo> erider, bien :-)
16:05:52 <araujo> erider, yourself?
16:06:01 <erider> q bien toy bien
16:06:13 <araujo> erider, how your haskell hacking going?
16:06:14 <nomeata> araujo: fmap and liftM are the same for IO, right?
16:06:21 <araujo> nomeata, pretty much
16:06:29 <syntaxfree> @type fmap
16:06:31 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
16:06:32 <pianodogg> how about return . head =<< getArgs
16:06:36 <syntaxfree> @type liftM
16:06:38 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
16:06:38 <erider> slow for now I'm on vacation
16:06:53 <pianodogg> that way the head and getArgs are close to each other... easier for a human to get it
16:06:59 <araujo> erider, :-)
16:07:00 <nomeata> pianodogg: also nice
16:07:13 <erider> araujo: how is yours?
16:07:15 <syntaxfree> return . head =<< getArgs
16:07:16 <araujo> erider, i read somebody was working on a haskell<->lua layer of some sort
16:07:19 <syntaxfree> happier?
16:07:42 <araujo> erider, mine were over two weeks ago .. so i am now a bit more busy
16:07:43 <syntaxfree> I had a computer graphics course that used Lua.
16:07:45 <pianodogg> arr, stealing my treasure, matey?
16:07:55 <syntaxfree> (Lua was developed at my uni.)
16:08:04 <nomeata> ok, thanks for the hints everybody
16:08:06 <dcoutts__> audreyt: got an idea for a fast StringBuffer for you, and pure too!
16:08:18 <pianodogg> oh do share
16:08:21 <dibblego> can you pass a lambda expression as the first argument to filter when the type of a is a tuple?
16:08:30 <erider> araujo: I bored I'm at my grandmother's and I'm tried of the novelas
16:08:39 <sjanssen_> dibblego: yes
16:08:46 <syntaxfree> erider: where does your grandmother live?
16:08:46 <dibblego> sjanssen, how does it look?
16:08:52 <araujo> erider, good time for hacking then!
16:08:58 <erider> lol
16:09:08 <sjanssen_> > filter (\(x, y) -> x == 4) [(1, 3), (4, 2)]
16:09:10 <erider> syntaxfree:  maryland
16:09:10 <lambdabot>  [(4,2)]
16:09:19 <dibblego> ah thanks
16:09:24 <syntaxfree> erider: why is she watching the soaps?
16:09:28 <dibblego> the type of x is inferred there right?
16:09:38 <xerox> Eq a => a
16:09:38 <_frederik_> what is the 'unsafe' in "foreign import ccall unsafe"?
16:09:45 <erider> retired syntaxfree
16:09:48 <sjanssen_> dibblego: all the types were inferred there ;)
16:10:00 <syntaxfree> I never thought of pattern-matching in lambda expressions.
16:10:02 <dibblego> ok cheers
16:10:12 <pianodogg> oh it is most useful
16:10:14 <syntaxfree> > (\(x:xs)-> xs ++ [x]) "Hello"
16:10:16 <lambdabot>  "elloH"
16:10:20 <syntaxfree> !
16:10:33 <pianodogg> when you already know exactly what your data will look like
16:10:50 <pianodogg> much better than a \x -> case x of
16:10:51 <dcoutts__> audreyt: assuming the only operations you need are to be able to append char(s) to the buffer, never mutating existing chars and to convert the state of the buffer into a ByteString. If so I think I can do all those in O(1) time and with a pure API.
16:11:08 <dcoutts__> audreyt: ie append char, or append string
16:11:22 <dibblego> dcoutts, of course, it's a linked list
16:11:24 <dcoutts__> char/byte whatever
16:11:38 <pianodogg> big old stack of characters
16:11:44 <sjanssen_> dibblego: append is O(n) with Haskell lists
16:11:45 <dcoutts__> dibblego: you can't convert a linked list to a ByteString in O(1)
16:11:50 <syntaxfree> What is a fast stack-like structure like in Haskell?
16:11:57 <dibblego> sjanssen, wtf?
16:11:58 <syntaxfree> (Assuming all you want is "push" and "pop")
16:12:03 <dibblego> sjanssen, why?
16:12:04 <pianodogg> um, just a list?
16:12:07 <sjanssen_> dibblego: because lists are singly linked
16:12:11 <pianodogg> push = (:)
16:12:17 <dibblego> sjanssen, any particular reason?
16:12:20 <dcoutts__> syntaxfree: []
16:12:56 <sjanssen_> dibblego: so they can share the tails
16:13:36 <dibblego> print $ filter (\(x y z) -> x) [True, False, True, False]
16:13:37 <sjanssen_> which allows us to have O(1) cons
16:13:39 <dibblego> what's wrong with that?
16:13:43 <dibblego> sjanssen, right
16:13:50 <dibblego> gah
16:14:06 <pianodogg> well the byte string could just be backwards :)
16:14:18 <dibblego> print $ filter (\(x y z) -> x) [(True, "", ""), (False, "", ""), (True, "", ""), (False, "", "")]
16:14:44 <dcoutts__> pianodogg: aye, so it doesn't matter if we're talking about append or prepend
16:14:55 <dibblego> why won't that compile?
16:15:12 <sjanssen_> dibblego: because it's wrong ;)
16:15:20 <dcoutts__> dibblego: (\(x y z) -> x) isn't right
16:15:21 <newsham> filter's function takes a single arg?
16:15:22 <dibblego> sjanssen, I don't see it
16:15:24 <sjanssen_> dibblego: commas
16:15:32 <dcoutts__> > (\(x y z) -> x)
16:15:32 <lambdabot>  Parse error in pattern
16:15:37 <dcoutts__> > (\(x, y, z) -> x)
16:15:38 <lambdabot>  Add a type signature
16:15:44 <dibblego> oh
16:15:46 <dcoutts__> > (\(x, y, z) -> x) (1,2,3)
16:15:48 <lambdabot>  1
16:15:55 <newsham> > filter (\(x,y,z) ->x) [[(True, "", ""), (False, "", ""), (True, "", ""), (False, "", "")]
16:15:56 <lambdabot>  Parse error
16:16:03 <pianodogg> too many [
16:16:10 <newsham> > filter (\(x,y,z) ->x) [(True, "", ""), (False, "", ""), (True, "", ""), (False, "", "")]
16:16:11 <lambdabot>  [(True,"",""),(True,"","")]
16:16:13 <pianodogg> yay!
16:16:17 <dibblego> thanks
16:16:47 <newsham> ?hoogle (a,b,c) -> a
16:16:48 <dylan> wouldn't a list comprehension be easier to read in that case?
16:16:48 <lambdabot> No matches, try a more general search
16:17:32 <newsham> > [y,z | (True, y, z) <- [(True, "", ""), (False, "", ""), (True, "", ""), (False, "", "")] ]
16:17:32 <lambdabot>  Parse error
16:17:40 <pianodogg> need parens
16:17:53 <newsham> > [(y,z) | (True, y, z) <- [(True, "", ""), (False, "", ""), (True, "", ""), (False, "", "")] ]
16:17:54 <lambdabot>  [("",""),("","")]
16:18:38 <pianodogg> i generally find explicit function calls easier to parse than list comprehensions
16:18:43 <pianodogg> that's just me
16:19:12 <dibblego> can you declare the type of a function that is in a where?
16:19:16 <pianodogg> yes
16:19:22 <pianodogg> sometimes you need to
16:19:30 <pianodogg> sometimes it helps debugging some diagnostic
16:19:32 <dibblego> just line after line with the right indentation?
16:19:36 <newsham> yup
16:19:39 <dibblego> ok ta
16:20:52 <pianodogg> so what's up with these packed strings?
16:21:00 <sjanssen_> pianodogg: they rock
16:21:10 <pianodogg> how do you support O(1) for all those operations
16:21:22 <pianodogg> when you can't allocate all the space apriori
16:21:35 <dcoutts__> cunning
16:21:44 <dcoutts__> @arr
16:21:45 <lambdabot> Avast!
16:21:47 <pianodogg> indeed
16:21:50 <newsham> fst3 (a,b,c) = a  ;    filter fst3 ...
16:21:58 <sjanssen_> there should be logs for #haskell-overflow
16:22:20 <dcoutts__> pianodogg: O(1) is easy on a packed representation
16:22:36 <pianodogg> for arbitrary append when we might not have the space?
16:22:37 <AstralStorm> Hehe, GHC 6.5+ is great...
16:22:40 <AstralStorm> "GHCi already does more defaulting than Haskell 98 so that, for example, reverse [] shows a result rather than giving an ambiguous type variable error. There is now a flag -fextended-default-rules to use these defaulting rules with GHC too. More details are in Section 3.4.5, Type defaulting in GHCi."
16:22:47 <dcoutts__> pianodogg: you just double the space when you run out
16:22:58 <pianodogg> but that's not O(1)
16:23:02 <dcoutts__> yes it is
16:23:05 <pianodogg> necessarily.  depends on your allocator
16:23:14 <glguy> ?yow
16:23:15 <lambdabot> It's OBVIOUS ... The FURS never reached ISTANBUL ... You were an EXTRA
16:23:15 <lambdabot> in the REMAKE of "TOPKAPI" ... Go home to your WIFE ... She's making
16:23:15 <lambdabot> FRENCH TOAST!
16:23:24 <sjanssen_> it is O(1) amortized with the appropriate growth function
16:23:30 <sjanssen_> (doubling is appropriate)
16:23:35 <dcoutts__> pianodogg: yes, it's O(1) amortized
16:23:36 <pianodogg> okay, sure
16:23:46 <dcoutts__> not worst case
16:23:52 <pianodogg> sorry, i wasn't in amorization land
16:23:55 <AstralStorm> tripling is sometimes better.
16:23:56 <dcoutts__> it's the same thing every other vector type does
16:24:00 <pianodogg> yes, of course
16:24:10 <dcoutts__> AstralStorm: fib is sometimes better
16:24:12 <pianodogg> i always just hesitate slinging "O(1)" around
16:24:15 <dibblego> @pl f1 a = filter (\(x, y, z) -> x) . f2 $ f3 a
16:24:16 <lambdabot> (line 1, column 6):
16:24:16 <lambdabot> unexpected "="
16:24:16 <lambdabot> expecting variable, "(", operator or end of input
16:24:17 <AstralStorm> Fib, yes, too :>
16:24:29 <dcoutts__> pianodogg: that's fair enough :-)
16:24:39 <dibblego> @pl filter (\(x, y, z) -> x) . f2 $ f3 a
16:24:40 <lambdabot> (line 1, column 15):
16:24:40 <lambdabot> unexpected ","
16:24:40 <lambdabot> expecting letter or digit, operator or ")"
16:24:40 <lambdabot> ambiguous use of a non associative operator
16:24:51 <dibblego> ah get stuffed
16:25:07 <pianodogg> perhaps you need a paren around your lambda and f2
16:25:07 <sjanssen_> dibblego: pl doesn't support pattern matching on tuples
16:25:16 <dibblego> f1 a = filter (\(x, y, z) -> x) . f2 $ f3 a
16:25:27 <dibblego> the 'a' feels as if it is redundant
16:25:34 <dcoutts__> pianodogg: so the cunning bit is how can it be made pure, since it's easy to just mutate & grow a buffer impurely
16:26:05 <dcoutts__> pianodogg: and the trick is that it's only O(1) when used non-persistently ie single-threaded
16:26:28 <dcoutts__> it still works when used persistently but is no longer O(1), it becomes O(n)
16:26:40 <pianodogg> okay
16:26:49 <dcoutts__> but since we assume that most people are using string buffers persistently then it's ok
16:26:57 <dcoutts__> err non-persistently
16:27:11 <newsham> fst3 (x,y,z) = x
16:27:12 <pianodogg> ha ha assumptions always bite you eventually... :) arrrrrrrr!
16:27:13 <dcoutts__> in a single threaded mannerr, to accumulate some output
16:27:27 <dcoutts__> pianodogg: it still works, it's just slower
16:27:33 <pianodogg> alright
16:27:45 <dcoutts__> those are the performace charactiersitcs that can be provided
16:27:51 <pianodogg> so if i have some (pure) PS which is inevitably pointing to some storage
16:27:52 <dcoutts__> it's still better than the imperitive ones
16:27:59 <pianodogg> and i need to double/reallocate
16:27:59 <dcoutts__> where you can't have persistence at all
16:28:25 <pianodogg> do i not have persistence in a single thread
16:28:36 <pianodogg> i.e. pointers to both the long and short
16:29:00 <dcoutts__> you can use the old ones, just not append to them in O(1) time
16:29:16 <dcoutts__> but yes you can still use the old ones to convert to a normal ByteString
16:29:20 <dibblego> is it just me or does it suck coming up with function names?
16:29:21 <dcoutts__> from this StringBuffer type
16:29:31 <pianodogg> how are you maintaining the old pointers without duplication
16:29:45 <AstralStorm> dibblego: you always have lambdas :>
16:30:01 <pianodogg> way to punt on the problem :)
16:30:02 <dcoutts__> data StringBuffer = StringBuffer ByteString Int (IORef Int)
16:30:05 <dibblego> AstralStorm, yeah but then it gets unwieldly
16:30:17 <AstralStorm> dibblego: where you don't have to come up with names?
16:30:26 <dcoutts__> pianodogg: I don't think I understand the problem
16:30:28 <dibblego> AstralStorm, with lots of lambdas that is
16:30:35 <pianodogg> no i was talking about lambda naming :)
16:30:37 <pianodogg> anyway
16:30:40 <dcoutts__> oh ok
16:30:48 <scsibug> this icfp talk is making me hungry again (pickles)
16:31:25 <pianodogg> i do not have my brain completely wrapped around haskell yet so pardon my ignorance
16:31:26 <sjanssen_> dcoutts__: there are problems with the representation you proposed, race conditions and the like
16:31:38 <dcoutts__> sjanssen_: can you see where?
16:32:01 <dcoutts__> the tricky bit is all in the append
16:32:14 <dcoutts__> you need to atomically reserve space
16:32:31 <Adamant> @fear
16:32:32 <lambdabot> Maybe you meant: faq keal learn read
16:32:52 <Adamant> hmm. lambdabot needs some FaL quotes.
16:33:08 <dcoutts__> sjanssen_: I think atomicModifyIORef or an MVar should be ok, no?
16:33:12 <sjanssen_> dcoutts__: nevermind, the issue was only imagined
16:33:21 <pianodogg> i did not read your representation; do you realloc (move) or just allocate another chunk keeping the old
16:33:35 <dcoutts__> pianodogg: could do either actually
16:33:58 <dcoutts__> pianodogg: depending on if we're using a strict or lazy byte string underneath
16:34:14 <pianodogg> guess the issue is that i don't fully understand the semantics of byte strings
16:34:17 <sjanssen_> I wonder if the fast mutable ints that Bulat has support atomic updates
16:34:27 <dcoutts__> pianodogg: a lazy bytestring is represneted in chunks, rather than a contiguous block
16:34:39 <pianodogg> and that is your underlying rep?
16:34:55 <dcoutts__> data StringBuffer = StringBuffer ByteString Int (IORef Int)
16:35:00 <dcoutts__> that's the rep ^^
16:35:04 <pianodogg> alright alright
16:35:05 <pianodogg> :)
16:35:11 <dcoutts__> and the ByteString there could be strict or lazy I think
16:35:53 <dcoutts__> probably simpler with a strict one
16:36:02 <dcoutts__> but might be faster with a lazy one
16:36:30 <dcoutts__> hmm, the lazy case is trickier, I'll have to think about that a bit more
16:36:36 <pianodogg> okay, my issue is that i didn't know about your ByteString data structure
16:36:56 <SamB> pianodogg: maybe you don't *want* to know
16:36:58 <dcoutts__> aye, it's just a contiguous block of bytes
16:37:09 <dcoutts__> with an offset and length
16:37:23 <dcoutts__> so it supports O(1) substring
16:37:30 <dcoutts__> and it's always immutable
16:37:39 <pianodogg> what about "a lazy bytestring is represented in chunks, rather than a contiguous block"
16:37:54 <dcoutts__> and a lazy ByteString is just a list of strict ones
16:38:02 <pianodogg> okay, sure
16:38:56 <sjanssen_> dcoutts__: will you keep free space at both the front and the end?
16:39:19 <dcoutts__> sjanssen_: no, probably not, so only support one of append or prepend
16:40:25 <dibblego> @paste
16:40:25 <lambdabot> http://paste.lisp.org/new/haskell
16:40:32 <sjanssen_> the typical associativity of ++ is a problem there
16:40:43 <lisppaste2> dibblego pasted "I'll bet there's a better way" at http://paste.lisp.org/display/26272
16:41:34 <dcoutts__> sjanssen_: we don't have a ++ for ByteString of course
16:41:52 <dcoutts__> just append & concat etc
16:42:58 * dcoutts__ -> bed
16:43:02 <dcoutts__> g'night folks
16:43:24 <lisppaste2> dibblego pasted "I'll bet there's a better way" at http://paste.lisp.org/display/26273
16:43:31 <dibblego> oops sorry
16:45:24 <ndm> x !! 0 -> head
16:46:04 <dibblego> why use head? why is one better than the other?
16:46:18 <ndm> head is often considered nicer
16:46:36 <ndm> although when there is x !! 0 and x !! 1, i prefer the symetry of x !! 0
16:46:45 <dibblego> same :)
16:47:10 <int-e> and when there's !! 2 I start thinking about arrays.
16:47:22 <dibblego> I'll get to that another day
16:47:36 <dibblego> I acknowledge the performance problem that might exist
16:47:44 <dibblego> the O(n) seek on a list
16:48:15 <sjanssen_> dibblego: head is typically faster than (!!0)
16:48:33 <dibblego> so tell me how far off from a typical solution I am - that's my first unassisted Haskell program
16:48:42 <dibblego> except for the tidbits from here of course
16:48:58 <pianodogg> if you know you have a first and second element
16:49:13 <pianodogg> do something like let (x:y:therest) = mylist in ...
16:49:17 <dibblego> sjanssen, I don't understand why if it is a singly linked list
16:49:45 <ndm> sjanssen_, you are assuming GHC isn't that good - it probably is exactly the same
16:49:46 <pianodogg> they should probably optimize out the same way
16:50:02 <pianodogg> but head is standard practice
16:50:04 <sjanssen_> dibblego: only a very small bit faster, because (!! i) needs to check whether i is zero
16:50:10 <dibblego> isn't the "singlyness" of a list an implementation detail or does the language mandate it?
16:50:25 <pianodogg> yes but that can be optimized out statically if it's (!!0)
16:50:26 <sjanssen_> ah yes, maybe inlining would make the difference disappear
16:50:45 <SamB> dibblego: it ain't!
16:51:00 <dibblego> SamB, it ain't? which one is right?
16:51:02 <SamB> data [a] = [] | a : [a]
16:51:18 <SamB> thats pretty much what the standard says about that
16:51:21 <dibblego> ah right
16:51:49 <SamB> I may be paraphrasing
16:52:21 <dibblego> I think I won't care for now anyway
16:57:50 <sjanssen_> GHC doesn't remove the 0 comparison, but gcc might
16:58:25 <pianodogg> why wouldn't it when it's constant?
16:58:36 <pianodogg> the compiler should immediately know which case to run
16:58:39 <pianodogg> no need to do the comparison
16:58:41 <sjanssen_> pianodogg: I guess the compiler just isn't quite smart enough
17:00:14 <pianodogg> well that's surprising, since it's just inlining
17:00:58 <glguy> ?tell dons OpenBSD's linker has an --export-dynamic option for the linker that exports symbols that are not linked to so that RTLD_DEFAULT should be able to see them (this would remove the special cases for OpenBSD if my idea is correct) I'm going to try this as soon was my recompile finishes
17:00:58 <lambdabot> Consider it noted.
17:01:13 <dons> glguy: hmm
17:01:14 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
17:01:25 <dons> --export-dynamic is a bit scary, but if it works, then good!
17:01:26 <glguy> dons: read my messages, I got ghci working
17:01:37 <dons> I saw in the logs! yay1
17:01:41 <dons> glguy++
17:02:09 <glguy> dons: would you prefer export-dynamic, or would you prefer to special case dlopen("libc.so"?
17:02:38 <dons> hmm. does that mean we'd have to compile all objects with --export-dynamic ?
17:02:49 <dons> in which case, I prefer "libc.so", I think
17:03:06 <glguy> I don't think so... I think it just means that we'd have to link ghc-6... with that flag
17:03:11 <glguy> it's not a compiler flag
17:03:27 <dons> no, its the linker. so you think just ghc needs to be linked with it? hmm
17:03:46 <dons> should be doable with a 1 line entry in the compiler/Makefile
17:03:52 <glguy> dons: man dlsym, search for export-dynamic and see if you interrpett that the same way I do
17:03:54 <dons> is that what you're trying now?
17:04:06 <dons> well, I've used it before for various symbol tricks
17:04:07 <glguy> dons: yeah, but it's going to take a while, I had to kill my source dir
17:04:18 <dons> ah ok
17:05:11 <glguy> dons: as the intermediate fix, i just unnested that dlopen for dl_libc_handle like I mentioned in the note, and that works well enough (that I imagine it's a better solution)
17:05:35 <sjanssen_> pianodogg: the way the !! operator is written prevents the inlining we need to optimize (!! 0)
17:06:02 <dons> glguy: ok. that sounds good. so what changed? RTLD_Default works properly now??
17:06:17 <glguy> dons: I'm suggesting that adding the export-dynamic would allow it to work
17:06:28 <glguy> but I can't test until the hours long compile runs :)
17:06:52 <glguy> for now I'm just using the corrected #if statements to read it from dl_libc_handle
17:07:04 <pianodogg> sjanssen_: you serious?
17:07:07 <glguy> once that worked, I immediately gmake install 'd
17:07:18 <sjanssen_> pianodogg: yeah, I think so
17:07:39 <dons> right ok. so why was ghci broken? due to RTLD_DEFAULT now being defined?
17:07:41 <sjanssen_> !! is an alias to a recursive helper function, and that helper is not inlined
17:07:42 <pianodogg> well fortunately most people don't do that, right?  :)
17:07:44 <glguy> dons: but openBSD has RTLD_DEFAULT now
17:07:55 <dons> ah ok. good.
17:08:10 <glguy> dons: correct, the #if nesting said that if RTLD_DEFAULT was there don't bother with dlopen("libc.so
17:08:36 <glguy> RTLD_DEFAULT on openbsd appears to behave differently than on other operating systems
17:08:43 <dons> ah heh ok.
17:09:28 <glguy> actually, I wrote a stub C program to test some of the dl- functions... lets see if I can make that linker flag work
17:12:09 * dons -> uni
17:15:16 <glguy> ?tell dons Using --export-dynamic aka -E on the linker works like the charm, this is also documented in man 1 ld
17:15:18 <lambdabot> Consider it noted.
17:25:11 <Pseudonym> @arr
17:25:11 <lambdabot> Har de har har!
17:32:59 <Limbic_Region> exit
17:33:05 <glguy> bye
17:33:35 <newsham> 100,000+ downloads could be wrong.
17:33:40 <glguy> lol, i was about to say
17:33:54 <glguy> hell, Windows XP has been downloaded that many times easy
17:33:55 <glguy> ;)
17:34:05 <SamB> hah
17:34:35 <SamB> the RIAA would agree
17:34:51 <glguy> what does IRSSI say when you exit?
17:35:08 <AstralStorm> Zilch.
17:35:22 <glguy> That's what makes a quality client
17:35:33 <AstralStorm> Well, a quality client has that configurable :>
17:35:36 <mauke> depends on your settings and how you exit
17:35:47 <glguy> what is the default setting tho
17:35:52 <SamB> hmm, I don't much like mpg321's behaviour on errors...
17:36:35 <mauke> I don't remember, it might be "Quit"
17:37:42 <mauke> going to the moon brb
17:38:52 <SamB> even NASA don't go there anymore...
17:38:57 <SamB> how you going to be right back?
17:41:33 <mauke_> glguy: it's "leaving"
17:42:22 <SamB> mauke: that is an awful quick trip to the moon
17:43:08 <AstralStorm> I didn't know T-Online is already on the moon... :>
17:46:45 <ndm> dons: i pushed out dr haskell, half released - i'm going to do a full release tomorrow
17:59:58 * lispy waves
18:01:27 <lispy> SamB: but the question is...did NASA *ever* go there?
18:01:36 * jgrimes waves to lispy 
18:02:00 <SamB> lispy: would they ever have tried to fake apollo 13?
18:02:23 <lispy> SamB: apollo 13 was the one that had trouble entering right?
18:02:31 <lispy> SamB: i bet that part was real
18:02:43 <lispy> SamB: but did it happen on the way back from the moon?
18:02:45 <lispy> i dunno....
18:03:21 <SamB> didn't they have trouble (supposedly) on the way *to* the moon?
18:03:26 <dolio> According to the film, the problems happen on the way there.
18:03:26 <lispy> actually, i haven't seen any convincing arguments that it's a hoax, just lots of weak arguments
18:03:37 <dolio> And they have to sling-shot themselves around the moon to get back, among other things.
18:03:45 <SamB> yeah
18:03:48 <lispy> i haven't seen the film, i only remember learning about it in science class
18:04:01 * lispy checks wikipedia
18:04:08 <SamB> are you implying that the movies are not an accurate depiction of reality?
18:04:17 <SamB> seriously now?
18:04:27 <SamB> ;-P
18:04:32 <lispy> SamB: i know....it's crazy...but just maybe... :)
18:04:33 <xerox> @slap SamB
18:04:34 * lambdabot smacks SamB about with a large trout
18:04:56 <sjanssen_> Apollo 13 never went to the moon
18:05:01 <xerox> G'night.
18:06:07 <SamB> sjanssen_: we know
18:06:33 <SamB> I think
18:06:42 <SamB> we are discussing whether NASA ever went at all
18:07:10 <sjanssen_> I wonder what moon landing hoax theorists would say to that Apollo 13 argument, I've never thought of that one before
18:07:37 <newsham> someone should start a blog for internet denyers
18:07:43 <dibblego> they would say that the earth is flat
18:08:00 <SamB> the internet does not exist!
18:08:06 <newsham> samb: i know.
18:08:12 <dibblego> IRC especially doesn't
18:08:21 <newsham> its turtles all the way down..
18:08:31 <SamB> newsham: is that what you meant by "internet denyers"?
18:08:36 <newsham> yes
18:08:44 <SamB> aww
18:08:48 <dibblego> newsham doesn't exist
18:08:50 <SamB> I was trying to misinterpret you!
18:08:53 <jcreigh> newsham: lol, that's awesome.
18:09:08 <SamB> newsham: dude, this isn't Zork
18:09:42 <dolio> I think the conspiracy theorists I've heard of mainly think that the first landing was faked, and that they actually made it there sometime afterward.
18:09:43 <newsham> is it "deniers" or "denyers" ?
18:09:45 <lispy> hmm...this wikipedia page is long
18:10:00 <lispy> i'm not sure what the verdict is, but it looks like they came back to earth early on
18:10:29 <lispy> i don't see the part about manually piloting the entry where they had a very percise angle to make or else they would bounce off or burn up
18:11:23 <sjanssen_> that detail doesn't seem encyclopedia worthy
18:12:17 <dibblego> if you pattern match a function say: f [] = ... and f(x:xs) = ... is it generally considered better to place the f(x:xs) first because it will match more often and so a performance benefit is to be gained?
18:12:18 <glguy> moon landing conspiracy theorists should take up a hobby, like haskell, and stop wasting their time
18:12:34 <lispy> yeah, i mean...it was extremely lucky that they made that angle which saved their lives...why would you record it in an encyclopedia :)
18:13:04 * lispy checks if any of the astronaughts blogged about the experience :)
18:13:05 <dolio> Because it's much better recorded in a 2+ hour dramatization. :)
18:14:15 <sjanssen_> dibblego: it's best to place them in whatever order is most natural to you.  Any possible performance gain is incredibly small
18:14:33 <sjanssen_> unless the patterns you are matching are very complex
18:14:50 <dibblego> sjanssen, what is natural to me is not necessarily conventional
18:14:54 <sjanssen_> like (x1:x2:x3:x4:x5:x6:x7:xs) or something ridiculous
18:14:59 <newsham> http://groups.google.com/group/internetdeniers
18:15:03 <lambdabot> Title: Google Groups, http://tinyurl.com/rtoat
18:15:08 <lispy> http://liftoff.msfc.nasa.gov/Academy/History/APOLLO-13/mission-report.html check the section, "Ingenuity At Work"
18:15:11 <lambdabot> Title: Apollo 13 - A Successful Failure, http://tinyurl.com/8743q
18:15:44 <dolio> I think convention would put the [] case first and (x:xs) after.
18:15:54 <dolio> More like a base and inductive case.
18:16:07 <lispy> if you put (x:xs) first i think it always matches
18:16:16 <glguy> (x:xs) doesn't match []
18:16:17 <lispy> er...no i wouldn't would it
18:16:19 <newsham> (x:xs) cant match []
18:16:23 <dibblego> dolio, that's what I consider "natural" - but I know many Java programmers who consider something that is horribly contrived to be natural - and they never learn about it either
18:16:45 <dibblego> lispy, not according to this tutorial - it only matches if the list has at least one element
18:16:59 <lispy> > let { lispyIsSilly (x:xs) = 1; lispyIsSilly [] = 2 } in lispyIsSilly [1,2]
18:17:00 <lambdabot>  1
18:17:08 <lispy> > let { lispyIsSilly (x:xs) = 1; lispyIsSilly [] = 2 } in lispyIsSilly []
18:17:09 <lambdabot>  2
18:17:15 <lispy> ah, and there is proof!
18:17:25 <lispy> proof we never went to the moon!
18:17:42 <newsham> (x:xs) = (CONS x xs),    [] dont have no CONS
18:17:45 <glguy> > let f (x:xs) = 1 in f []
18:17:46 <lambdabot>  Non-exhaustive patterns in function f
18:17:56 <dibblego> > let weNeverWentToTheMoon = True in weNeverWentToTheMoon
18:17:57 <lambdabot>  True
18:18:03 <dibblego> it compiles!! it must be true!!
18:18:12 <glguy> dibblego: you are correct, no one in this channel has been to the moon!
18:18:17 <dibblego> ask any IBM developer
18:18:36 <newsham> ?check \p -> p == np where n = 0
18:18:36 <lambdabot>  Parse error
18:18:43 <lispy> ?check \weNeverWentToTheMoon -> (weNeverWentToTheMoon :: Bool)
18:18:45 <lambdabot>  Falsifiable, after 3 tests: False
18:18:49 <newsham> ?check \p = p == np where n = 0
18:18:50 <lambdabot>  Parse error
18:18:56 <newsham> grr, what's the ?check syntax again?
18:18:57 <Pseudonym> glguy: I think you're underestimating the influence of Haskell on aging astronauts.
18:19:10 <dolio> 3 tests?
18:19:10 <lispy> ?check \weWentToTheMoon -> (weWentToTheMoon :: Bool)
18:19:11 <lambdabot>  Falsifiable, after 0 tests: False
18:19:26 <lispy> hmm...so it takes 0 tests to disprove going to the moon
18:19:27 <glguy> I've only known one astronaut, one of my college math profs
18:19:28 <newsham> ?check \p -> let n = 0 in (p :: Int) == n * p
18:19:29 <lambdabot>  Falsifiable, after 0 tests: 2
18:19:30 <sjanssen_> newsham: no where on lambda expressions
18:19:31 <dolio> I guess that's what you get with randomization.
18:19:32 <lispy> and 3 tests to disprove never going to the moon
18:19:40 <newsham> ?check \p -> let n = 1 in (p :: Int) == n * p
18:19:41 <lambdabot>  OK, passed 500 tests.
18:19:59 <lispy> ?small \weWentToTheMoon -> weWentToTheMoon :: Bool -- comprehensive testing
18:20:09 <lispy> hmm...
18:20:12 <lispy> is small broken?
18:20:14 <lispy> ?uptime
18:20:15 <lambdabot> uptime: 23h 15m 4s, longest uptime: 2d 8h 20m 7s
18:20:16 <dolio> scheck?
18:20:19 <lispy> ah
18:20:25 <lispy> ?scheck \weWentToTheMoon -> weWentToTheMoon :: Bool -- comprehensive testing
18:20:27 <lambdabot>   Failed test no. 2. Test values follow.: False
18:20:44 <lispy> looks like we never went to the moon
18:20:46 <lispy> :(
18:25:26 <lispy> ?scheck \s -> map (> 1000) (s::[Int])
18:25:27 <lambdabot>  add an instance declaration for (Testable [Bool])
18:25:27 <lambdabot>   In the definition of ...
18:25:43 <lispy> ?scheck \s -> any $ map (> 1000) (s::[Int])
18:25:44 <lambdabot>  Couldn't match `a -> Bool' against `[b]'
18:26:53 <lispy> ?scheck \s -> and $ map (> 1000) (s::[Int])
18:26:54 <lambdabot>   Failed test no. 2. Test values follow.: [-1]
18:27:07 <lispy> ?scheck \s -> or $ map (> 1000) (s::[Int])
18:27:09 <lambdabot>   Failed test no. 1. Test values follow.: []
18:27:12 * lispy goes back to basic logic...
18:27:50 <lispy> ?scheck \s -> any (==True) $ map (> 1000) (s::[Int])
18:27:51 <lambdabot>   Failed test no. 1. Test values follow.: []
18:28:11 <lispy> ?scheck \s -> none (==True) $ map (> 1000) (s::[Int])
18:28:12 <lambdabot>  Not in scope: `none'
18:28:24 <lispy> ?scheck \s -> not $ any (==True) $ map (> 1000) (s::[Int])
18:28:28 <lambdabot>  Completed 623530 test(s) without failure.
18:28:33 * lispy loves the grammar
18:28:41 <lispy> Not Any TRUE!
18:29:01 <lispy> ?pl not $ any (==True) $ map (> 1000)
18:29:02 <lambdabot> not (any (True ==) (map (> 1000)))
18:29:30 <lispy> ?scheck \s -> not $ any (==True) $ map (> 100) (s::[Int])
18:29:34 <lambdabot>  Completed 623530 test(s) without failure.
18:29:40 <lispy> ?scheck \s -> not $ any (==True) $ map (> 10) (s::[Int])
18:29:44 <lambdabot>  Completed 623530 test(s) without failure.
18:29:51 <lispy> ?scheck \s -> not $ any (==True) $ map (> 1) (s::[Int])
18:29:52 <lambdabot>   Failed test no. 37. Test values follow.: [-1,-1,-1,-1,-1,2]
18:29:54 <AstralStorm> What does this do?
18:30:14 <lispy> it generates random values and tries to exhaustively test something
18:30:28 <lispy> (contrasted with quickcheck that doesn't try to be exhaustive but also uses random values)
18:30:38 <lispy> ?scheck \s -> not $ any (==True) $ map (> 5) (s::[Int])
18:30:40 <lambdabot>   Failed test no. 60623. Test values follow.: [-1,6]
18:30:51 <lispy> ?scheck \s -> not $ any (==True) $ map (>= 10) (s::[Int])
18:30:55 <lambdabot>  Completed 623530 test(s) without failure.
18:31:02 <lispy> amazing...
18:31:05 <SamB> @help scheck
18:31:05 <lambdabot> scheck <expr>
18:31:05 <lambdabot> You have SmallCheck and 3 seconds. Test something.
18:31:11 <SamB> @help check
18:31:11 <lambdabot> check <expr>
18:31:11 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
18:31:17 <SamB> what?
18:31:17 <dons> :)
18:31:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:31:28 <SamB> dons: QuickCheck is not a prover!
18:31:28 <lispy> dons: um...that shouldn't say "Prove something" should it :)
18:31:31 <dons> glguy: hmm nice!
18:31:39 <dons> lispy: well, you can prove _some_ things in QuickCheck :}
18:31:47 <dons> I.e. that your assumptions are wrong ;)
18:32:01 <SamB> should say "Disprove something"
18:32:04 <dons> also, there's the option of proof by exhaustion in QuickCheck too
18:32:10 <dons> ?check True -- i.e.
18:32:12 <lambdabot>  OK, passed 500 tests.
18:32:19 <lispy> dons: but small check is more likely to prove something than quick check is :)
18:32:20 <SamB> ?scheck True
18:32:21 <lambdabot>  Completed 1 test(s) without failure.
18:32:27 <SamB> neeeeat
18:32:28 <dons> yep
18:32:31 <dons> SmallCheck rocks
18:32:41 <SamB> @where SmallCheck
18:32:41 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.1.tar
18:32:49 <SamB> ... that is not a webpage!
18:33:11 <lispy> ?scheck \s -> not $ any (==True) $ map (\x -> (-10) <= x && x <= 10) (s::[Int])
18:33:12 <lambdabot>   Failed test no. 2. Test values follow.: [-1]
18:33:27 <dons> yeah, we just have to convince colin to start using darcs ... and hmm. html
18:33:29 <AstralStorm> What values does it generate when asked for strings?
18:33:45 <SamB> well. HTML is a plus.
18:33:54 <lispy> ?scheck \s -> not $ any (==True) $ map (\x -> (-10) <= x || x >= 10) (s::[Int])
18:33:56 <lambdabot>   Failed test no. 2. Test values follow.: [-1]
18:33:57 <SamB> but at least darcs you can go to in your browser, maybe look at the README file
18:34:04 <dons> glguy: sounds good.
18:34:15 * dons -> meeting
18:34:16 <lispy> ?scheck \s -> not $ any (==True) $ map (\x -> x <= (-10) || x >= 10) (s::[Int])
18:34:21 <lambdabot>  Completed 623530 test(s) without failure.
18:34:48 <lispy> but tar is more widely available than darcs....
18:35:29 <SamB> lispy: ... so?
18:35:35 <lispy> well, actually Colin says, it's a single module around 350 lines so he hasn't bothered with version control and tar files are more widely known and used than darcs
18:35:38 <SamB> C is more widely available than Haskell, too...
18:35:55 * lispy has already encouraged Colin to provide a darcs repo...
18:36:01 <SamB> maybe he should just stick the docs in the file and skip the tar
18:36:08 <lispy> yeah
18:36:11 <lispy> i think so too
18:36:17 <lispy> actually, i think cabal + darcs rocks
18:36:21 <lispy> and that's really what he should do
18:36:38 <lispy> but...failing that, tar seems excessive given the project
18:36:53 <SamB> its not even gzipped!
18:36:57 <SamB> messing up my reflexes!
18:36:58 <lispy> at least with darcs i can easily contribute
18:37:07 <lispy> tar xvzf -- oh, wait!
18:37:29 <mwc> What's the story with GHC 6.6. Last I heard it was supposed to be out early-mid Sept.
18:37:40 <sjanssen_> ziggurat?  no thanks, I don't smoke
18:37:48 <lispy> mwc: ICFP is happening this week...maybe they will announce it during the conference
18:37:55 <SamB> mwc: about two weeks ;-)
18:38:18 <SamB> er, wait about two weeks, I mean
18:38:22 <mwc> Yay, so I should lay in a supply of redbull and soda crackers
18:38:35 <SamB> no guarentees
18:38:48 <SamB> I just heard someone say it wasn't likely to be out before then
18:39:16 <lispy> getting it out mid sept. was a rush job and they admitted that, so not surprising they are pushing the deadline back a bit
18:42:45 <SamB> @check (\f g xs -> (sortBy f . sortBy g) xs == (sortBy g . sortBy f) xs)
18:42:46 <lambdabot>  Add a type signature
18:42:50 <glguy> ?hoogle showBase
18:42:51 <lambdabot> No matches found
18:42:58 <glguy> ?hoogle showDigitInBase
18:42:59 <lambdabot> No matches found
18:43:06 <glguy> anyone know what I'm looking for?
18:43:44 <SamB> @check (\f g xs -> (sortBy f . sortBy g) xs == (sortBy g . sortBy f) (xs :: [Int]))
18:43:45 <lambdabot>  Falsifiable, after 12 tests: <Int -> Int -> Ordering>, <Int -> Int -> Orderi...
18:43:53 <SamB> @scheck (\f g xs -> (sortBy f . sortBy g) xs == (sortBy g . sortBy f) (xs :: [Int]))
18:43:54 <lambdabot>     instance (Serial a, Show a, Show b) => Show (a -> b) -- Imported from ...
18:44:01 <SamB> hmm
18:44:06 <SamB> something isn't right here!
18:44:08 <glguy> why would you expect that to work?
18:44:19 <glguy> the check that is
18:44:22 <SamB> * display counter-examples of functional type?
18:44:27 <sjanssen_> SamB: can smallcheck generate functions like quickcheck can?
18:44:33 <SamB> glguy: it is boring if the property is true!
18:44:39 <glguy> heh
18:44:39 <glguy> ok
18:44:53 <SamB> I specifically found one that isn't!
18:45:55 * SamB guesses problem
18:45:56 <audreyt> dcoutts__: sorry, what's the layout?
18:46:06 <jgrimes> glguy, showIntAtBase ?
18:46:28 <audreyt> dcoutts__: i.e. what's the "data" definition of such fastconcatstring?
18:46:45 <SamB> dons: WTH do you still have all these Run* scripts duplicating import boilerplate?
18:46:59 <SamB> can't you write a .h file for it or something?
18:47:14 <SamB> or doesn't cabal deal with .h files well?
18:48:37 <sjanssen_> audreyt: I think he went to sleep, but I can paste relevant conversation from #haskell-overflow if you want
18:51:34 <aFlag> I don't understand very well what does it mean for a function to be a first-class object. I've read it means that, among other properties like passing it as a parameter and returning it from a function, you should be able to create them dinamically at runtime. I can't see how that's possible in haskell
18:52:33 <glguy> jgrimes: that was it
18:53:57 <jgrimes> glguy, cool deal
18:54:30 <SamB> aFlag: well.
18:54:46 <mwc> aFlag, f y = let g x = x + y in g
18:54:49 <SamB> what do you suppose happens if you do "map (+) [1..]"
18:55:11 <glguy> ?index showIntAtBase
18:55:12 <lambdabot> Numeric
18:55:20 <mwc> the framework or code is more or less fixed at compile, but the data that fully "closes" it can be provided at runtime
18:55:45 <SamB> and you can arrange the code however you like, too ;-)
18:56:15 <SamB> and if you had a nice JIT, the code could be optimized at runtime too...
18:56:23 <aFlag> SamB, it partially applies each number on the list to the (+) function
18:56:25 <audreyt> sjanssen_: please do
18:56:29 <AstralStorm> aFlag: it's really simple - you _can_ create functions at runtime.
18:56:30 <audreyt> I'm highly interested :)
18:56:37 <SamB> dons: oh sweet
18:56:38 <AstralStorm> And pass them as arguments.
18:56:48 <AstralStorm> Except they're not some "objects"
18:56:52 <SamB> I got cabal to stop trying to link lambdabot ;-)
18:56:52 <sjanssen_> lisppaste2: url
18:56:52 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:56:55 <aFlag> mwc, i don't understand how  that's creating a function during runtime
18:57:02 <SamB> or something along those lines
18:57:06 <aFlag> AstralStorm, could you give me an example?
18:57:13 <AstralStorm> E.g.
18:57:24 <AstralStorm> > (\x y -> x + y)
18:57:25 <lambdabot>  Add a type signature
18:57:36 <AstralStorm> > (\x y -> x + y) :: Int -> Int -> Int
18:57:37 <lambdabot>  <Int -> Int -> Int>
18:57:56 <AstralStorm> > let x = (\x y -> x + y) :: Int -> Int -> Int    in x 10 11
18:57:58 <lambdabot>  21
18:58:20 <AstralStorm> Or even:
18:58:24 <AstralStorm> @type ($)
18:58:25 <lambdabot> forall b a. (a -> b) -> a -> b
18:58:27 <lisppaste2> sjanssen_ pasted "dcoutts describing StringBuffer" at http://paste.lisp.org/display/26282
18:59:05 <aFlag> AstralStorm, I don't get how that's creating a function during runtime, how does that differ from, say f x y = x+y ?
18:59:41 <AstralStorm> Actually, everything in the functional language happens at runtime.
18:59:45 <AstralStorm> Except type definition.
18:59:51 <AstralStorm> :>
18:59:54 <SamB> AstralStorm: and whatever the compiler optimizes out
19:00:00 <AstralStorm> Yes.
19:00:06 <SamB> (assuming it does that before runtime)
19:00:17 <aFlag> hum, now I'm confused hehe
19:00:18 <sjanssen_> aFlag: you can compose arbitrary functions at runtime
19:00:25 <SamB> aFlag: that is good ;-)
19:00:34 <SamB> oh, yeah, see my BF interpreter
19:00:50 <SamB> @oldwiki ShortExamples/BFInterpreter
19:00:51 <lambdabot> http://www.haskell.org/hawiki/ShortExamples/BFInterpreter
19:00:54 <weitzman> > let func x = (+ x) in (func 2) 4
19:00:55 <lambdabot>  6
19:01:09 * SamB wonders if he got it right?
19:01:13 <aFlag> when you write f x y = x+y doesn't it generate some code somewhat equivalent to int f(int x, int y) { return x + y; }?
19:01:46 <SamB> aFlag: not necessarily
19:01:47 <sjanssen_> aFlag: more complicated, x and y can be thunks
19:01:56 <SamB> and not whole lot in any case
19:02:20 <AstralStorm> It may actually put x+y at the right place :>
19:02:35 <weitzman> (f x y = x+y) is the same as (f = (+))
19:02:41 <AstralStorm> Yes.
19:02:48 <SamB> for instance, you could later write let z = f 1 in z `seq` 2
19:02:49 <weitzman> > let f = (+) in f 1 2
19:02:50 <lambdabot>  3
19:02:55 <jgrimes> aFlag, when you write f x y = x + y, it is really creating two functions and currying them together
19:02:56 <weitzman> > let f = (-) in f 1 2
19:02:58 <lambdabot>  -1
19:02:59 <int-e> weitzman: beware of the monomorphism restriction though
19:03:09 <SamB> jgrimes: you mean a function that returns an argument?
19:03:15 <SamB> er, another function
19:03:22 <lispy> beware the monomorphism!
19:03:23 <weitzman> int-e: I'm going to pretend I know what that is and nod
19:03:24 <int-e> hmm. f is polymorphic, so it takes a dictionary where the (+) needs to get looked up ...
19:03:25 * SamB whacks his english module
19:03:45 <int-e> @type (+)
19:03:46 <lambdabot> forall a. (Num a) => a -> a -> a
19:03:49 <lispy> ?pl f x = x
19:03:50 <lambdabot> f = id
19:03:58 <lispy> ?hylo f x = x
19:03:59 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
19:03:59 <lambdabot>  where g (x) = x
19:03:59 <lambdabot>     h x = (x)
19:04:00 <AstralStorm> @type id
19:04:02 <lambdabot> forall a. a -> a
19:04:04 <AstralStorm> :>
19:04:11 <AstralStorm> Now that's a function too.
19:04:15 <jgrimes> SamB, well, yes
19:04:28 <AstralStorm> ?help hylo
19:04:28 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
19:04:29 <lambdabot> Uses the Pointless.Combinators from:
19:04:29 <lambdabot>  http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
19:04:29 <lambdabot> Mirrored:
19:04:31 <lambdabot>  http://www.cse.unsw.edu.au/~dons/Pointless/
19:04:38 <AstralStorm> Huh...
19:04:38 <SamB> anyway.
19:04:53 <lispy> ah, those pointless combinators...
19:05:05 <SamB> "map (+) [1..]" returns a list of functions that add various numbers to things
19:05:11 <int-e> pointfree code is full of dots.
19:05:21 <int-e> I still find that very ironic
19:05:25 <SamB> being a lazy list, the functions are generated at runtime
19:05:28 <SamB> int-e: yes it is ;-)
19:05:30 <lispy> > map (+) [1..4]
19:05:31 <lambdabot>  Add a type signature
19:05:43 <lispy> > map (+) [1..4] :: [Int -> Int]
19:05:45 <lambdabot>  [<Int -> Int>,<Int -> Int>,<Int -> Int>,<Int -> Int>]
19:05:45 <SamB> lispy: you can't Show a polymorphic thing ;-)
19:05:52 <araujo> > 2 + 2
19:05:54 <lambdabot>  4
19:05:54 <weitzman> > map (+) ([1...4] :: [Int])
19:05:55 <lambdabot>  Not in scope: `...'
19:05:56 <aFlag> hum, the function is created during runtime because you don't know its exactly definition until the runtime?
19:06:03 <weitzman> >  map (+) ([1..4] :: [Int])
19:06:05 <lambdabot>  [<Int -> Int>,<Int -> Int>,<Int -> Int>,<Int -> Int>]
19:06:16 <araujo> > map (+ 1) [1 .. ]
19:06:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:06:18 <SamB> aFlag: pretty much
19:06:22 <lispy> > map 1 (map (+) [1..4])
19:06:23 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
19:06:27 <SamB> now, the code is not generated at runtime very often...
19:06:30 <int-e> aFlag: not at all. *g*
19:06:41 <weitzman> > let makeFuncs = map (+ 1) in makeFuncs [3..4]
19:06:42 <lambdabot>  [4,5]
19:06:45 <aFlag> I mean f x y = x+y, it would be one + definition if x and y are integers and it would be other definition if they were floats
19:06:52 <SamB> int-e: insofar as the definition includes already-passed parameters, yes ;-)
19:06:56 <int-e> aFlag: the story is really very complicated.
19:06:59 <weitzman> > let makeFuncs = map (+) in makeFuncs [3..4]
19:07:00 <aFlag> hum
19:07:00 <lambdabot>  Add a type signature
19:07:11 <AstralStorm> aFlag: no, much more complex
19:07:32 <araujo> Don't scare him off :-P
19:07:34 <SamB> aFlag: if you do that...
19:07:36 <AstralStorm> It is a polymorphic definition.
19:07:38 <weitzman> @type (+)
19:07:39 <lambdabot> forall a. (Num a) => a -> a -> a
19:07:46 <int-e> aFlag: in the easiest form, that code corresponds to a piece of code that takes a dictionary and two thunks, looks up the (+) function in that dictionary and passes control to it.
19:07:53 <SamB> yeah, you might as well have just not written it
19:07:58 <weitzman> You can create type that's a Num
19:08:02 <lispy> > map ($1) (map (+) [1..4])
19:08:04 <lambdabot>  [2,3,4,5]
19:08:04 <AstralStorm> And it assumes the dictionaries are of class "Num"
19:08:05 <araujo> aFlag, It is an operator defined through a type-class for implementing polymorphism
19:08:09 <int-e> aFlag: that is, if the function wouldn't get inlined
19:08:20 <glguy> This was a neat problem: https://www.spoj.pl/problems/NEG2/
19:08:21 <int-e> aFlag: which probably every Haskell compiler would do.
19:08:24 <SamB> woooo
19:08:32 <SamB> I got the right address for my BF interpreter
19:08:41 <SamB> I wonder how much it has changed since I wrote it ;-)
19:08:46 <lispy> SamB: you have a bf interpreter?
19:09:00 <SamB> @oldwiki ShortExamples/BFInterpreter
19:09:00 <lambdabot> http://www.haskell.org/hawiki/ShortExamples/BFInterpreter
19:09:10 <weitzman> > foldl (.) id [(* 2), (+1)] 3
19:09:12 <lambdabot>  8
19:09:14 <int-e> many people have brainfuck interpreters :)
19:09:22 <weitzman> > foldr (.) id [(* 2), (+1)] 3
19:09:23 <lambdabot>  8
19:09:28 <lispy> SamB: wow, that's much shorter than mine
19:09:31 <SamB> mine is probably scarier than yours!
19:09:59 <lispy> SamB: but mine optimizes: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/BF.hs
19:10:02 <lambdabot> http://tinyurl.com/emoay
19:10:03 <aFlag> int-e, so that dictionary is indexed by the function (or operator) name and the values are the definition of the function?
19:10:06 <glguy> weitzman: foldl1 (.)?
19:10:15 <SamB> lispy: mine goes for feature use density, actually ;-)
19:10:28 <weitzman> glguy: Shhhh!
19:10:31 <int-e> aFlag: if you're really interested, try the STG paper. (for example, here: http://citeseer.ist.psu.edu/peytonjones92implementing.html)
19:10:31 <SamB> use as many features in as little code as possible!
19:10:35 <lambdabot> http://tinyurl.com/geuhe
19:10:46 <jcreigh> lispy: "optimizes"?
19:10:47 <int-e> aFlag: that tells you a somewhat outdated story about how ghc does all this.
19:10:58 <lispy> jcreigh: yes
19:11:08 <lispy> jcreigh: 3 phase optimizer for the input programs :)
19:11:32 <lispy> SamB: heh, it's nice
19:11:33 <SamB> jcreigh: you know, turns certain kinds of loops into arithmetic ops and stuff
19:11:35 <dibblego> the function is created at compile-time given some axiomatic data types, then the composition of higher-order functions comes into existence at runtime through function currying
19:11:56 <aFlag> int-e, ok, thanks.
19:11:57 <lispy> SamB: yes, i don't transform loops much other than making them an absolute jmp
19:11:59 * glguy tries to think of ways to make the GHC compile process take longer...
19:12:24 <dibblego> glguy, travel away from it at some velocity
19:12:28 <weitzman> glguy: GHC could be pretty slow if it generated typed assembly
19:12:34 <SamB> lispy: oh, I you mean you don't undo multiplication loops?
19:12:42 <lispy> SamB: but changing loops that only inc or dec into a single instruction might be nice...right now i take runs of incs/decs and make them one instruction but i don't optimize the loop out
19:13:10 <jcreigh> My guess is that the dirt-simple BF -> C translation along with gcc -O3 is probably among the faster ways to do it.
19:13:12 <SamB> I wrote a compiler in Python that did that too
19:13:30 <SamB> it also deferred pointer update till the end of a loop
19:13:56 <lispy> jcreigh: maybe, but mine is an interpreter
19:14:05 <SamB> to avoid stalls on the adds to the register...
19:14:09 <dibblego> ?index Maybe
19:14:09 <lambdabot> Data.Maybe, Prelude
19:14:18 <SamB> jcreigh: dirt simple isn't the fastest way
19:14:29 <SamB> BF is just *too* dirt simple for that to be so
19:14:36 <lispy> jcreigh: which means it's safe and hence dons let me add it to lambdabot
19:14:38 <jcreigh> SamB: gcc optimizes a ton of stuff away.
19:14:41 <dibblego> why is there two of everything?
19:14:48 <dibblego> ?index readFile
19:14:49 <lambdabot> System.IO, Prelude
19:14:53 <dibblego> why two?
19:14:57 <lispy> ?index map
19:14:57 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
19:15:06 <SamB> jcreigh: it does not optimize BF
19:15:11 <lispy> dibblego: reexported?
19:15:23 <dibblego> why would I use System.IO.readFile and not Prelude.readFile or vice versa?
19:15:30 <SamB> dibblego: um
19:15:32 <lispy> SamB: but i think jcreigh means you translate each program to C and compile it
19:15:33 <SamB> no reason at all!
19:15:39 <lispy> SamB: in which case gcc would then optimize it
19:15:41 <SamB> lispy: sure!
19:15:54 <SamB> but GCC is lousy at optimizing directly translated BF programs!
19:15:55 <dibblego> SamB, how does one typically decide? a two sided coin?
19:16:08 <SamB> dibblego: you don't!
19:16:11 <AstralStorm> ?dice 1d2
19:16:11 <lambdabot> 1d2 => 1
19:16:13 <SamB> you just type "readFile"
19:16:17 <AstralStorm> Use the Prelude one :>
19:16:25 <SamB> and forget that System.IO has it too
19:16:27 <dibblego> SamB, then that would use the Prelude one
19:16:35 <AstralStorm> ?dice 1d2
19:16:36 <lambdabot> 1d2 => 1
19:16:37 <AstralStorm> ?dice 1d2
19:16:38 <lambdabot> 1d2 => 2
19:16:41 <lispy> SamB: in that example program you don't do your arthemitic modulo the machine types...do you?
19:16:52 <SamB> dibblego: are you implying that they are different functions?
19:16:54 <lispy> ah i see you use word8
19:16:56 <jcreigh> SamB: I mean like this: http://rafb.net/paste/results/iwj8Ff73.html
19:17:03 <lispy> perhaps that would be better in my implementation
19:17:07 <AstralStorm> ?type System.IO.readFile
19:17:09 <lambdabot> FilePath -> IO String
19:17:15 <SamB> lispy: Int is valid enough too
19:17:15 <dibblego> SamB, no, the contrary, but you decided which one to use - the Prelude one - even if it were not explicit
19:17:17 <AstralStorm> ?type Prelude.readFile
19:17:19 <lambdabot> FilePath -> IO String
19:17:33 <SamB> dibblego: not if you imported System.IO!
19:17:41 <SamB> then it only works if they are the same one!
19:17:42 <dibblego> SamB, why didn't you import System.IO?
19:17:56 <dibblego> why are there two of the same thing?
19:18:03 <SamB> good question!
19:18:05 <SamB> I dunno!
19:18:06 <dibblego> only to be differentiated by their module
19:18:07 <lispy> SamB: actually i see that either dons or i have switched to word8
19:18:09 <dibblego> OK!
19:18:11 <SamB> but it is the same exact one
19:18:45 <SamB> you could ask the same about maybe half of what is in Data.List
19:18:46 <dibblego> so is Data.Maybe.Maybe the same as Prelude.Maybe?
19:18:47 <SamB> maybe less
19:18:52 <SamB> yes!
19:19:03 <SamB> Prelude and other modules often share exports
19:19:20 * lispy should go home
19:19:29 <weitzman> @type undefined
19:19:31 <lambdabot> forall a. a
19:19:48 <lispy> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
19:19:49 <lambdabot>  HelloWorld!
19:20:01 <weitzman> @type \1 -> undefined
19:20:03 <lambdabot> forall a a1. (Num a) => a -> a1
19:20:08 <lispy> ?bf ++++[>++++++++<-]>[.+]
19:20:09 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
19:20:23 <SamB> actually, the reason I use a Ptr is twofold: (1) tradition and (2) to show off FFI
19:20:25 <lispy> that program optimizes down to 11 instructions
19:20:30 <araujo> ?bf +++++[]
19:20:34 <lambdabot> Done.
19:20:47 <weitzman> ?bf [
19:20:48 <lambdabot>  bf:Ix{Int}.index:Index(2)outofrange((0,1))
19:20:56 <araujo> ?bf +++++[++++.----]
19:20:59 <lispy> (well 12 if you count my explicit halt that i append)
19:21:03 <lambdabot> Done.
19:21:50 <SamB> lispy: that [>++++++++<-] could be replaced with something like p[1] += p[0]*8
19:22:12 <int-e> ?bf ++++[>++++++++<-]>+...[-]++++++++++.
19:22:12 <lambdabot>  !!!
19:22:33 <lispy> SamB: yeah
19:22:49 <SamB> er, well, you'd need to zero p[0]
19:22:59 <SamB> but you get the picture ;-)
19:23:09 <lispy> i zero the machine's memory before i start
19:23:33 <lispy> or do you mean, every time you hit the loop?
19:24:00 <int-e> @bf >>>>++++<<+[-[>>+<<-]+++++[>+++++<-]>[<+++++>-]>]<<[--.++<+<[<<]>[->.>]>]
19:24:01 <lambdabot> Done.
19:24:08 <int-e> @bf >>>>++++<<+[-[>>+<<-]+++++[>+++++<-]>[<+++++>-]>]<<[--.++<+<[<<]>[->.>]>]++++++++++.
19:24:08 <lambdabot> Done.
19:24:11 <int-e> hmm.
19:24:22 <weitzman> > undefined 1
19:24:23 <lambdabot>  Add a type signature
19:24:29 <int-e> should print {{}{{}}{{}{{}}}{{}{{}}{{}{{}}}}} :-/
19:24:31 <lispy> int-e: what should those output?
19:24:39 <weitzman> > undefined 1 :: Int
19:24:40 <lambdabot>  Undefined
19:24:48 <lispy> it's possible i have bugs :)  I've seen a few programs not run on my interpreter
19:24:50 <mauke> int-e: works here
19:24:51 <weitzman> > undefined 1 2 3 :: Int
19:24:52 <lambdabot>  Undefined
19:25:01 <gmh33__> is ! logical not?
19:25:10 <mauke> > not True
19:25:10 <lispy> ?type (!)
19:25:11 <lambdabot>  False
19:25:12 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
19:25:17 <gmh33__> > !False
19:25:17 <lambdabot>  Parse error
19:25:28 <lispy> gmh33__: it's for indexing arrays
19:25:33 <gmh33__> ooo
19:25:37 <gmh33__> like !! is for lists
19:25:40 <gmh33__> I guess ?
19:25:43 <lispy> yup
19:25:45 <gmh33__> cool
19:25:52 <gmh33__> > not False
19:25:53 <lambdabot>  True
19:25:56 <gmh33__> oki doki
19:25:58 <weitzman> @check liftM2 (==) (not . not) id :: Bool -> Bool
19:26:00 <lambdabot>  OK, passed 500 tests.
19:26:16 <weitzman> QuickCheck has decided that classical logic is correct
19:26:20 <SamB> @check (\f g xs -> (sortBy f . sortBy g) xs == (sortBy g . sortBy f) (xs :: [Int]))
19:26:21 <lambdabot>  Falsifiable, after 4 tests: <Int -> Int -> Ordering>, <Int -> Int -> Orderin...
19:26:26 <int-e> @bf >+>+<[<]>++++++++++++++++++++++++++++++++.
19:26:26 <lambdabot>  !
19:28:27 <lispy> int-e: if you find a bug let me know, i've suspected for a while that some programs are not interpreted correctly but i have yet to see the bug
19:28:41 <weitzman> @hoogle (a -> y -> z) -> (i -> j -> a) -> (i -> j -> y) -> i -> j -> z
19:28:43 <lambdabot> No matches, try a more general search
19:28:56 <weitzman> @djinn (a -> y -> z) -> (i -> j -> a) -> (i -> j -> y) -> i -> j -> z
19:28:57 <lambdabot> f a b c d e = a (b d e) (c d e)
19:29:03 <SamB> @scheck liftM2 (==) (not . not) id :: Bool -> Bool
19:29:04 <lambdabot>  Completed 2 test(s) without failure.
19:29:07 <SamB> heh
19:29:17 <Cale> @. pl djinn (a -> y -> z) -> (i -> j -> a) -> (i -> j -> y) -> i -> j -> z
19:29:17 <lispy> ?pl f a b c d e = a (b d e) (c d e)
19:29:18 <lambdabot> f = (liftM2 ap .) . (.) . (.)
19:29:18 <lambdabot> f = (liftM2 ap .) . (.) . (.)
19:29:30 <weitzman> Hmm
19:29:31 <Cale> heh
19:29:33 <weitzman> That's not pretty
19:29:42 <weitzman> @type ((.) . (.))
19:29:44 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:29:49 <Cale> Just use a lambda :)
19:29:54 <weitzman> Noo!
19:30:05 <SamB> @. pretty . pl djinn (a -> y -> z) -> (i -> j -> a) -> (i -> j -> y) -> i -> j -> z
19:30:05 <lambdabot>  f = (liftM2 ap .) . (.) . (.)
19:30:23 <SamB> hmm, that really isn't any prettier
19:30:32 <mauke> @. pl djinn (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c
19:30:32 <lambdabot> f = liftM2
19:30:35 <lispy> @. pretty pl djinn (a -> y -> z) -> (i -> j -> a) -> (i -> j -> y) -> i -> j -> z
19:30:35 <lambdabot> "Parse error" at column -17
19:30:45 <lispy> nice parse error column
19:30:58 <lispy> ?redo (liftM2 ap .) . (.) . (.)
19:30:58 <lambdabot> (liftM2 ap .) . (.) . (.)
19:31:43 <mauke> @. pl djinn (a -> b -> c) -> (a -> b) -> a -> c
19:31:43 <lambdabot> f = ap
19:32:30 <lispy> @.free . pl djinn (a -> b -> c) -> (a -> b) -> a -> c
19:32:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:32:45 <lispy> @. ft . pl djinn (a -> b -> c) -> (a -> b) -> a -> c
19:32:47 <lambdabot>  There was an error in the type: (line 1, column 7):
19:32:48 <lambdabot>  unexpected "e"
19:32:48 <lambdabot>  expecting "->" or end of input
19:32:59 <lispy> ?ft ap
19:33:00 <lambdabot>  There was an error in the type: (line 1, column 8):
19:33:01 <lambdabot>  unexpected "b"
19:33:01 <lambdabot>  expecting "::"
19:33:02 <weitzman> @. ftl djinn (a -> b -> c) -> (a -> b) -> a -> c
19:33:03 <lambdabot> compose module failed: IRCRaised Parse error: "ftl"
19:33:13 <lispy> ?free ap
19:33:15 <lambdabot> Expected variable or '.'
19:33:25 <weitzman> Lambdabot needs the ability to understand people's intent
19:34:36 <mauke> @dwim
19:34:37 <lambdabot> Unknown command, try @list
19:38:24 <glguy> dons: you there?
19:40:43 <SamB> dons: if I wanted to add things that should be in SmallCheck, where should I add them?
19:41:07 <int-e> lispy: you don't skip nested loops when resolving the [ jumps.
19:41:30 <SamB> hahaha
19:42:18 <int-e> @bf [[[+.]+]+]
19:42:22 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl...
19:42:31 <int-e> this shouldn't output anything at all.
19:43:26 <int-e> [[.]+] is probably a minimal example with output.
19:44:20 <lispy> int-e: hm...maybe i was too literal when interpreting the spec
19:44:22 <int-e> lispy: I'm curious, why didn't you introduce a Loop [Command] alternative in the parsed data?
19:44:43 <int-e> hmm.
19:44:58 <lispy> Jump forward past the matching ]  if the byte at the pointer is zero.
19:45:03 <int-e> 'matching'
19:45:08 <mauke> MAT-CHING
19:45:10 <lispy> i think i read that as 'to the next'
19:45:28 <glguy> is there a way to tell ghc to pass flags to the linker?
19:45:31 <lispy> so that makes sense that nested loops don't work :)
19:45:50 <SamB> glguy: most likely
19:46:02 <SamB> it is probably in the manpage, as well as the HTML docs
19:46:36 <gmh33__> @check (\h -> hPutStrLn h contents)
19:46:37 <lambdabot>  Not in scope: `contents'
19:46:46 <SamB> gmh33__: uh
19:47:17 <gmh33__> I copied that out of yaht from an example and ghc is giving me The last statement in a 'do' construct must be an expression
19:47:31 <gmh33__> sorry, it's giving me : "The last statement in a 'do' construct must be an expression"
19:47:56 <SamB> gmh33__: that isn't the offending part, I'm pretty sure...
19:48:02 <gmh33__> oops
19:48:04 <gmh33__> it's..
19:48:11 <SamB> the lack of a do is kinda a tipoff ;-)
19:48:12 <gmh33__> putStrLn (take 100 contents)
19:48:13 <gmh33__> :/
19:48:23 <mauke> unpossible
19:48:23 <gmh33__> that's the last part of the do
19:48:25 <glguy> ugg, there doesn't seem to be a linker flag passthrough flag
19:48:29 <mauke> is your indentation borked?
19:48:37 <gmh33__> my indentation is good me thinks
19:48:40 <SamB> mauke: exactly what I was wondering ;-)
19:48:53 <gmh33__> 1 indent more indented than the do
19:48:56 <SamB> gmh33__: it is important that the Haskell compiler agree with you on this
19:49:03 <mauke> gmh33__: show code
19:49:06 <glguy> oh, -optl
19:49:20 <int-e> lispy: actually the translation to C is the better specification, in my opionion.
19:49:27 <gmh33__> what's the paste?
19:49:35 <int-e> @paste
19:49:36 <lambdabot> http://paste.lisp.org/new/haskell
19:50:13 <lisppaste2> gmh33 pasted "yaht file example" at http://paste.lisp.org/display/26289
19:50:34 <gmh33__> there you go
19:52:51 <lispy> so i guess one way to fix this is for the Jmps to record how nested they are
19:53:11 <lispy> then i can basically keep my logic as long as i keep matching nesting levels
19:53:40 <gmh33__> any ideas mauke/SamB? :\
19:54:17 <mauke> gmh33__: yes, always start a new line after "do"
19:54:20 <mauke> or use { }
19:54:53 <gmh33__> still borked
19:55:12 <gmh33__> but it's pointing at much differnt things
19:55:13 <gmh33__> lol
19:55:33 <gmh33__> "28:24: parse error on input `doRead'"
19:55:38 <gmh33__> after adding the newline after the do
19:55:54 <mauke> compiles for me
19:56:14 <gmh33__> o_o
20:00:28 <SamB> @yarr
20:00:28 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
20:00:33 <SamB> @arr
20:00:34 <lambdabot> I'll keel haul ya fer that!
20:00:35 <SamB> @arr
20:00:36 <lambdabot> Swab the deck!
20:00:38 <SamB> @arr
20:00:38 <lambdabot> Arrr!
20:00:50 * SamB is brushing up for tomarrow
20:06:25 <hyrax42> are enumerated datatypes compiled down to ints?
20:07:45 <gmh33__> ok I got it finally
20:07:46 <gmh33__> lol
20:07:48 <gmh33__> thanks
20:12:12 <gmh33__> I love this language lol
20:12:25 <hyrax42> it's strangely addictive
20:12:32 <gmh33__> yes
20:12:46 <gmh33__> and a strange mix of efficient + high level
20:12:53 <hyrax42> there's something about the type system
20:12:59 <hyrax42> and the really nice clean syntax
20:13:11 <gmh33__> that second thing you mentioned is nice :P
20:13:23 <gmh33__> easy to read/comprehend quickly
20:13:59 <araujo> gmh33__, you already got it?
20:14:06 <hyrax42> easy partial application is really nice
20:14:13 <hyrax42> sections, infix
20:14:17 <hyrax42> guards
20:14:19 <hyrax42> all of it
20:15:15 <dons> SamB: did you sort your smallcheck issue? you sending me a patch for the run* boilerplate?
20:15:40 <dons> (the boilerplate is duplicated because I'm lazy, btw)
20:18:11 <dons> ?users #haskell
20:18:15 <lambdabot> Maximum users seen in #haskell: 237, currently: 216 (91.1%), active: 25 (11.6%)
20:18:33 <dibblego> I am using read on data that comes from a file - if the file is malformed I get a parse error - how can I ignore it?
20:18:52 <lispy> dibblego: catch?
20:18:54 <dons> you'll need to write a preprocessor or your own parser
20:19:03 <dons> or catch the exception :)
20:19:17 <dibblego> ok, I'll figure that out, thanks
20:22:17 <glguy> ?tell dons I added the following flags to compile/Makefile.ghcbin to get things working after removing the special cases for openbsd from rts/Linker.c: -optl-Xlinker -optl-E. after this things seem to work fine (last message about this, I promise)
20:22:17 <lambdabot> Consider it noted.
20:22:42 <dons> yes?
20:22:43 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:23:03 <dons> are you at the point you want to send me a darcs patch, to test on a non-4.0 box?
20:23:30 <glguy> dons: could you check your non-4.0 manpage for ld? and see what -E / --export-dynamic says?
20:23:31 <dons> maybe i should install a 4.0 snapshot this week...
20:23:56 <dons>            If you do not use  this  option,  the  dynamic  symbol
20:23:57 <dons>            table  will  normally contain only those symbols which
20:23:57 <dons>            are referenced by some dynamic object mentioned in the
20:23:57 <dons>            link.
20:24:13 <glguy> and does man dlsym say that RTLD_DEFAULT exists?
20:24:25 <glguy> you know what... i can look this on up openbsd.org
20:24:29 <dons>      If dlsym() is called with the special handle RTLD_DEFAULT, all the shared
20:24:30 <dons>      objects will be searched in the order they were loaded.
20:24:34 <dons> :) yes.
20:24:42 <glguy> oh, so then it's got the same functionality that 4.0 has
20:24:59 <dons> well, at least the same man page ;)
20:25:02 <glguy> heh
20:25:04 <glguy> right
20:25:17 <glguy> I do remember seeing changelog entries regarding this issue
20:25:20 <glguy> when I was searching google
20:26:44 <dibblego> is 'otherwise' a keyword or a constant function of type Bool?
20:26:47 <glguy> I'm testing with openbsd_HOST_OS check around the Makefile change
20:26:54 <glguy> before I try to submit
20:26:59 <mauke> it's a constant
20:27:05 <mauke> defined as otherwise = True
20:27:07 <dons> > otherwise
20:27:09 <lambdabot>  True
20:27:16 <dons> glguy: submit?
20:27:21 <glguy> send it to you
20:27:24 <dons> ah :)
20:27:24 <glguy> make a patch
20:27:26 <glguy> do whatever
20:27:29 <dons> good.
20:27:29 <dibblego> ?index otherwise
20:27:30 <lambdabot> Data.Bool, Prelude
20:27:33 <glguy> I've never used darcs...
20:27:39 <glguy> so that could be as much a challenge aas anhything
20:27:40 <dons> darcs whatsnew -s
20:27:45 <dons> darcs record Makefile
20:27:49 <dons> darcs send -o /tmp/bsd.patch
20:27:56 <glguy> I got this from a snapshot, will that hurt?
20:28:00 <dons> mail -s "Patch" dons < /tmp/bsd.patch :)
20:28:08 <dons> hmm, so you're not in darcs then?
20:28:15 <dons> you'll have to diff -u then
20:28:20 <glguy> kk
20:28:23 <glguy> sorry
20:28:28 <dons> 'sok
20:29:19 <dibblego> can you replace guards with if/else?
20:29:28 <dons> yes.
20:29:30 <sjanssen_> dibblego: mostly
20:29:40 <dons> > f x | x > 0 = True | otherwise = False in f 8
20:29:41 <dibblego> it's just not as pretty?
20:29:41 <lambdabot>  Parse error
20:29:51 <mauke> ELET
20:29:52 <dons> > let f x | x > 0 = True | otherwise = False in f 8
20:29:54 <lambdabot>  True
20:30:00 <sjanssen_> it's different when you have other patterns to fall through to
20:30:03 <dons> > let f x = if x > 0 then True else False in f 8
20:30:05 <lambdabot>  True
20:30:11 <dons> and you don't get to use pattern guards
20:30:12 <sjanssen_> so you can end up rewriting quite a bit
20:34:15 <glguy> dons: what is the correct way to say if defined(openbsd_HOST_OS) in the Makefile?
20:34:48 <dons> something like:
20:34:48 <dons> ifeq "$(TargetOS_CPP)" "openbsd"
20:34:49 <dons> SRC_HC_OPTS += -optc-fno-stack-protector
20:34:49 <dons> endif
20:43:23 <jakeluck> aaah, hackathon
20:51:19 <dibblego> ?type (zipWith (-))
20:51:21 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
20:52:20 <dibblego> yet when I declare in a source file: f = zipWith (-) then :l ThatFile.hs then :t f I get [Integer] -> [Integer] -> [Integer]
20:52:22 <dibblego> why come?
20:53:45 <dibblego> and f2 a b = zipWith (-) a b then :t f2 is (Num b) => [b] -> [b] -> [b]
20:54:15 <araujo> @type zipWith (-)
20:54:17 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
20:54:28 <araujo> @type let f = zipWith (-) in f
20:54:29 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
20:54:30 <monochrom> Monomorphism
21:15:09 <lispy> ?hoogle [a] -> Int -> a -> [a]
21:15:10 <lambdabot> No matches, try a more general search
21:16:47 <dibblego> I don't understand what extra information in zipWith (-) a b is provided to change the type
21:17:19 <dons> hmm?
21:17:58 <dibblego> and why the type changes depending on whether it is a source file that I :load into ghci or if I just use :t at ghci
21:18:32 <dons> to do with other constraints
21:18:39 <dons> ?type zipWith (-)
21:18:41 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
21:18:50 <dons> ?type zipWith (- :: Int -> Int)
21:18:51 <lambdabot> parse error on input `::'
21:18:53 <dons> ?type zipWith ((-) :: Int -> Int)
21:18:54 <lambdabot>   Expecting a function type, but found `Int'
21:18:54 <lambdabot>    Expected type: Int -> Int
21:19:02 <dons> ?type (-)
21:19:03 <lambdabot> forall a. (Num a) => a -> a -> a
21:19:09 <dons> ?type zipWith ((-) :: Int -> Int -> Int)
21:19:11 <lambdabot> [Int] -> [Int] -> [Int]
21:19:29 <dons> ?type zipWith id
21:19:30 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
21:19:56 <lisppaste2> dibblego pasted "expected and actual misalignment" at http://paste.lisp.org/display/26296
21:20:00 <araujo> dibblego, on ghci here, :t zipWith (-) , shows the variable type signature
21:20:18 <araujo> It's just when i assign it to a variable that makes it specific
21:20:23 <araujo> not sure why either
21:21:25 <dibblego> I cannot see how that makes sense
21:21:38 <araujo> me neither really ...
21:21:51 <dons> I think that's ghci's extended defaulting, perhaps?
21:21:56 <araujo> mmm ... probably is because of the default function?
21:21:59 <dibblego> and why Integer? why not any other type? like Int?
21:22:00 <araujo> ya
21:22:13 <dons> dibblego: because Integer is what the language specifies Num constraints default to
21:22:17 <dons> ?let f1 = zipWith (-)
21:22:18 <lambdabot> Defined.
21:22:28 <dons> ?let f2 a b = zipWith (-) a b
21:22:30 <lambdabot> Defined.
21:22:33 <dons> > L.f1
21:22:34 <lambdabot>  <[Integer] -> [Integer] -> [Integer]>
21:22:35 <araujo> @type let f = zipWith (-)
21:22:36 <lambdabot> not an expression: `let f = zipWith (-)'
21:22:37 <dons> > L.f2
21:22:38 <lambdabot>  Add a type signature
21:22:43 <araujo> @type f = zipWith (-)
21:22:44 <dons> f2 is polymorphic
21:22:44 <lambdabot> parse error on input `='
21:22:58 <araujo> @type let f = zipWith (-) in f
21:23:00 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
21:23:03 <dibblego> ok, I'll just nod for now and keep reading
21:23:15 <dons> you can look up 'defaulting' in the H98 spec
21:23:27 <dons> Num types default to Integer, and to Double
21:23:29 <dibblego> is it the output of :t (zipWith (-)) at ghci that you mean when "I think that's ghci's extended defaulting, perhaps?"?
21:23:37 <dons> ?type (zipWith (-))
21:23:38 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
21:23:47 <dons> no, that's the expected result
21:23:50 <araujo> yeah, it's more likely because of defaulting
21:24:02 <dons> ?let f1 = zipWith (-)
21:24:03 <lambdabot> <local>:10:0:     Multiple declarations of `L.f1'     Declared at: <local>:8:...
21:24:08 <dons> > L.f1 -- that's defaulting
21:24:10 <lambdabot>  <[Integer] -> [Integer] -> [Integer]>
21:24:19 <dibblego> mk thanks
21:28:05 <dibblego> my boss and I have been arguing over 'encapsulation' for the last 2 days - I argue that since the objectives of encapsulation are violated in performing what *appears* to be encapsulation, it not in fact encapsulation, where he argues that since he and others believe it is encapsulation and that the context (in this case Java) calls it encapsulation, it is encapsulation
21:29:49 <dibblego> then I argue that since that particular context - Java - quite often creates illogical definitions that not only shift the old definition, but in fact, negate it, then it is Java that is the flaw in logic and should be eliminated from the discussion
21:30:04 <dibblego> otherwise, we may as well start calling green red and red green
21:30:32 <dibblego> simply because some illegitimate authority "said so"
21:30:33 <Cale> dibblego: sorry, what?
21:30:39 <Patterner> you are right. and your boss should raise your pay.
21:30:57 <dibblego> Patterner :)
21:31:04 <Cale> "the objectives of encapsulation are violated in performing what *appears* to be encapsulation"
21:31:08 <Cale> huh?
21:31:12 <dibblego> Cale, yes, this happens all the time
21:31:14 * wkh didn't understand either
21:31:23 <Cale> Could you give an example?
21:31:39 <dibblego> Cale, starting with a basic premise - the opposite of encapsulation is requirement leak - where one leaks beyond what is required
21:32:10 <dibblego> so, you might ask for a tennis ball, but instead you are given a tennis court that contains a tennis ball
21:32:25 <dibblego> you can "hide" the tennis court and expose only the tennis ball
21:32:32 <dibblego> by reducing requirement leak
21:32:41 <dibblego> this is the objective of encapsulation
21:32:47 <Cale> Well, yes
21:32:52 <dibblego> ok, starting there....
21:33:14 <dibblego> I argue that it is an intrinsic property of Java (and in fact OO) to violate the objectives of encapsulation
21:33:27 <dibblego> this much is true (despite common belief) and my boss understands that (after many hundreds of hours)
21:33:57 <dibblego> in other words, you cannot use OO without violating encapsulation - it is provably impossible
21:34:13 <Cale> Could you prove that?
21:34:14 <Pseudonym> I disagree with that in part.
21:34:15 <dibblego> which of course appears to be in contradiction with lots of makreting literature
21:34:23 <dibblego> and the resulting masses that follow
21:34:26 <dibblego> yes I can prove it
21:34:31 <dibblego> but let's not digress
21:34:38 <Pseudonym> If it's true, it's _only_ true of pure OO.
21:34:54 <Pseudonym> Java only supports objects as an abstraction mechanism.
21:35:13 <Pseudonym> Any language which supports something else in addition might disprove your theorem.
21:35:18 <Cale> Hm, why should it be necessary to violate encapsulation? You can always move more things into the requirements if needed.
21:35:22 <Pseudonym> Well, alleged theorem, since I haven't seen the proof.
21:35:22 <dibblego> the argument is now that since "Java has soome definition  of encapsulation" even if it violates the objectives of encapsulation - even negating them (as we both agree but very few people understand why that is the case)
21:35:38 <dibblego> Pseudonym, I am writing it in between learning Haskell
21:35:44 <Pseudonym> What are the objectives of encapsulation?
21:35:54 <dibblego> Pseudonym, paraphrased above
21:36:00 <Cale> That is, it seems to me that if you're forced to break encapsulation, then you've underestimated what the requirements of your interface are, no?
21:36:04 <Patterner> "Don't touch my privates"
21:36:10 <dibblego> Cale, let's not digress
21:36:50 <Cale> dibblego: Is this related to downcasting?
21:36:51 <dons> heh.
21:37:00 <dibblego> the problem is that since lots of people think that since Java provides this new and contradictory (even though it's not popular knowledge that it is contradictory) definition of encapsulation, then this definition is in fact legitimate
21:37:19 <dibblego> Cale, no - it's much deeper than that and is a very long discussion
21:37:26 <Cale> dibblego: welcome to the English language :)
21:37:33 <dibblego> Cale, English sucks :)
21:37:40 <Pseudonym> dibblego: You can't make assertions like that and not justify them. :-)
21:38:04 <Cale> dibblego: I really don't agree that in a general OO setting, one is always forced to break encapsulation.
21:38:05 <dibblego> Pseudonym, it is an assumption required for the sake of the argument - albeit not a popular accepted assumption
21:38:12 <Pseudonym> My counter-assertion is that any example you can give can be simply explained by poor engineering practices, not OO itself.
21:38:16 <dons> there's established structures for reasoning about the semantics of language constructs.. why not use them?
21:38:18 <dibblego> Cale, I can understand that and I hope to change that - before I die
21:38:33 <Cale> dibblego: So I don't understand your previous remark that it is.
21:38:44 <Pseudonym> It's certainly true that a LOT of "OO developers" don't understand OOAD.
21:38:55 <Pseudonym> And probably the overwhelming majority of Java programmers.
21:38:59 <dibblego> OOAD contains an inherent underlying contradiction
21:39:07 <dibblego> therefore, I reject the legitimacy of the term even
21:39:17 <dibblego> I udnerstand it, since I know it doesn't exist - is the best case for that term
21:39:28 <dibblego> but that's a digression
21:39:29 <Pseudonym> You are suggesting that OOAD is not OO, doesn't do analysis and/or doesn't do design, or some combination thereof?
21:39:50 <dibblego> I am suggesting that OO and software are mutually exclusive entities that cannot co-exist since they are in contradiction
21:39:56 <dibblego> and of course, this requires a definition of software
21:40:01 <dibblego> all of which I am writing about
21:40:03 <Pseudonym> Indeed it does.
21:40:32 <dibblego> at the very least, my boss agreed that his definition of encapsulation and software cannot co-exist - which is fine by me
21:40:39 <Pseudonym> It also requires a definition of object-orientedness.
21:40:43 <dibblego> right
21:40:50 <dibblego> it's funny that there is no formal definition :)
21:40:59 <dibblego> and still alarm bells aren't ringing for anyone :)
21:41:08 <Pseudonym> No, the definition is Alan Kay's Intuitive Explanation(tm).
21:41:13 <dibblego> I propose a formal definition that is very broad and should be accepted by most
21:41:18 <glguy> what example of Java breaking encapsulation are you people debating?
21:41:18 <dibblego> right, I touch on that
21:41:27 <dibblego> glguy, many :)
21:41:32 <dibblego> s/Java/OO
21:41:32 <glguy> but right now
21:41:37 <Cale> Is this just Java breaking encapsulation?
21:41:43 <dibblego> no, it is OO
21:41:44 <Pseudonym> glguy: Nobody is coming up with any specific examples.  Which is what makes this so unenlightening a discussion.
21:41:48 <dibblego> I can provide one trivial example
21:41:52 <Cale> okay
21:41:53 <Pseudonym> Please do.
21:41:58 <Cale> I'd like to see the example :)
21:42:05 <dibblego> have you read Stephen Hawking, Brief History of Time?
21:42:20 <dibblego> the biggest single problem I find is that time is not understood
21:42:25 <Cale> er, yes, quite a while ago
21:42:32 <dibblego> there is a chapter in that book titled The Arrow of Time
21:42:40 <dons> somewhere, somehow #haskell got wacky
21:42:41 <dibblego> I think it is concise and to the point
21:42:41 <Pseudonym> Vague memories here.
21:42:47 <dibblego> anyway, you're all smart enough
21:42:56 <dibblego> it is quite simple
21:42:56 <glguy> dons: the testsuite I ran has different tests than the one on the nightly snapshot
21:43:02 <Cale> Well, it's not understood in that we're still considering alternate models for it
21:43:14 <dons> glguy: ah ok.
21:43:15 <dibblego> that we observe software in a linear and unidirectional arrow is an axiom of software
21:43:22 <dibblego> do you agree?
21:43:24 <Cale> Time in relativity and time in quantum mechanics are well understood.
21:43:26 <glguy> dibblego: does this go back to your time is immutable kick?
21:43:33 <dibblego> we do not observe computers cmputing backwards in time?
21:43:33 <dons> heh
21:43:45 <dibblego> glguy, I forget that kick - must have had sugar that day :)
21:43:54 <Pseudonym> dibblego: That's an artifact of how we design computers.
21:43:59 <dons> when you use a backwards monad, you do..
21:44:11 <Pseudonym> Reversible logic is very much an active research area.
21:44:19 <Cale> dibblego: I suppose not, although one can easily simulate it, though it's easy to write bad software that way.
21:44:23 <glguy> lol @ 2 unexpected passes
21:44:28 <dibblego> ok, we do not travel away from our software at some speed approaching the speed of light?
21:44:47 <Cale> dibblego: no, I mean, you can have the reverse state monad :)
21:44:56 <Pseudonym> I don't even understand that question.
21:45:00 <dons> see, at this point warning bells go off in my head...
21:45:06 <dibblego> I don't know that monad, but linear computational progression is itself an axiom of software is the point
21:45:07 <Pseudonym> And I know quite a bit about Mionkowski space.
21:45:11 <glguy> dibblego: remember we are asking you to give an example of why OO can't do encapsulation
21:45:15 <Pseudonym> Including how to spell it.  "Minkowski"
21:45:18 <Cale> I don't understand what any of this has to do with OO though.
21:45:19 <dibblego> glguy, yes I am trying to state the basic premise
21:45:32 <glguy> and time doesn't matter in software if there are no race conditions ;)
21:45:39 <dibblego> time matters a lot
21:45:52 <dibblego> one need only say "referential transparency"
21:45:56 <Pseudonym> I can buy "time matters a lot" as a premise.
21:46:05 <dibblego> let's try another tact
21:46:10 <Pseudonym> Please.
21:46:22 <Cale> Give me an example of a useful program which it is not possible to write in an OO fashion without breaking encapsulation somwhere in the design.
21:46:27 <dibblego> the definition of referential transparency is such that a function behaves in some constant way from inception until the collapse of space/time itself
21:46:29 <glguy> When you "argue" with your boss do you make any "arguments"?
21:46:38 <dibblego> glguy, he started it :)
21:46:50 <Pseudonym> dibblego: Phil Wadler would disaghree with you in part.
21:46:55 <dibblego> glguy, I had doing it verballly since it undermines the whole point - it leaves open too many holes
21:47:00 <glguy> the definition of referential transparency doesn't have ot do with "time" just that for any inputs the outputs would be the same
21:47:04 <Pseudonym> It's impossible to envisage a universe where logic doesn't hold.
21:47:10 <dibblego> glguy, yes but time is required for that to exist
21:47:14 <dons> in general its a bad idea to bring space/time into discussions of programming languages..
21:47:33 <dibblego> it's bad because it's widely misunderstood, not bad because it's a basic premise of software
21:47:35 <Cale> Yeah, this isn't physics.
21:47:47 <dibblego> show me a referentially transparent function without acknowledging time
21:47:49 <Cale> This is a much simpler formal system
21:47:54 <glguy> dibblego: I don't see where time factors into a mathematical concept
21:48:00 <Pseudonym> I don't either.
21:48:07 <Cale> dibblego: sure, the identity function on the natural numbers
21:48:18 <Cale> dibblego: that has nothing at all to do with time
21:48:25 <dibblego> if I were to reverse the arrow of time, then the function that you said is referentially transparent is no longer that
21:48:31 <Cale> Or how about the empty function?
21:48:43 <Cale> dibblego: no, it changes nothing
21:48:43 <Pseudonym> Any isomorphism is, by definition, reversible.
21:48:49 <dibblego> gah
21:48:55 <dibblego> this is all one level above
21:49:01 <Cale> dibblego: There is no time in mathematics
21:49:03 <dibblego> ok, forget all that
21:49:13 <jcreigh> lol
21:49:16 <glguy> Your argument or ours?
21:49:20 <Cale> There is no concept of time where we're defining these things
21:49:23 <dibblego> the misunderstanding
21:49:29 <Pseudonym> Your problem, dibblego, is that you're taking the concept of a referentially transparent function and viewing it as some kind of physical machinery.
21:49:34 <dibblego> there is, but I won't continue to argue for it
21:49:35 <Pseudonym> It's not.  It's an abstract relation.
21:49:46 <Cale> A function is a set of pairs
21:49:53 <dibblego> no I am not - I am stating it's basic premise - it requires time to exist
21:49:57 <Pseudonym> Cale: No, that's a representation of a function.
21:50:09 <Pseudonym> But do go on. :-)
21:50:09 <dibblego> there is simply no such thing without time - time is part of its definition
21:50:10 <glguy> hey! we're on the same team
21:50:14 <dibblego> anyway, forget it
21:50:28 <dibblego> let's try this:
21:50:32 <Cale> Pseudonym: It's the set theoretic definition, and I'm willing to be the local ZFC propagandist.
21:50:33 <dibblego> ------------------------------------------> time
21:50:39 <dibblego> is that sensible enough?
21:50:46 <Cale> (well, part of the set theoretic definition :)
21:50:52 <Pseudonym> Cale: Fine.  Axiom of choice or not?
21:50:54 <Cale> dibblego: not at all
21:51:08 <Cale> Pseudonym: I'm pro choice
21:51:27 <dibblego> maybe I will have to get Stephen Hawking to help me
21:51:32 <Cale> Though that shouldn't matter too much here
21:51:39 <dibblego> I found that chapter very good for explaining the arrow of time
21:51:40 <glguy> programs that operate over the course of time are just a specific implementation of the logic defined by a program
21:51:44 * Patterner throws Zorn's Lemon at Pseudonym 
21:52:01 <Cale> dibblego: the problem is that you're talking about time with respect to systems where it doesn't make sense to do so.
21:52:05 <glguy> the program itself exists outside of time
21:52:05 * Pseudonym splits it into two, equally massive lemons
21:52:27 <dibblego> Cale, do you agree that when two events occur that one might happen at a different time?
21:52:28 <Cale> dibblego: Time in computing is not (unless you design hardware) the same thing as time in reality.
21:52:43 <Pseudonym> dibblego: That depends on your frame of reference, surely.
21:52:44 <Cale> Or, that is, time in a physical model of the universe
21:52:55 <dibblego> no, it's a simplification because certain higher-level assumptions can be made
21:52:58 <Cale> Events are not occurring.
21:53:07 <dibblego> Pseudonym, my point exactly, but you have rejected that complex definition
21:53:09 <Cale> Mathematics doesn't have events.
21:53:14 <dibblego> forget mathematics
21:53:16 <Pseudonym> Sorry?
21:53:20 <Pseudonym> Where did I reject that?
21:53:34 <dibblego> I am just trying to simplify it
21:53:38 <Cale> The systems that we're talking about are formal mathematical constructions.
21:54:03 <dibblego> a client of software observes that software in linear time
21:54:04 <glguy> Cale: forget about "programs"
21:54:13 <dons> heh
21:54:21 <glguy> Cale: this is bigger than that
21:54:30 <dibblego> you can't just introduce a term "mathematics" and use that as a refutation
21:54:39 <Pseudonym> dibblego, how about this?
21:54:50 <Pseudonym> Object-oriented systems do have a concept of "events" and "time".
21:54:57 <dibblego> I am simplifying the point only because it is clear that a true definition of time is unacceptable
21:54:59 <Cale> When we talk about functions being referentially transparent, we're not talking about the physical systems that implement them as being referentially transparent.
21:55:11 <Pseudonym> Because OO is defined in terms of subsystems doing message passing.
21:55:13 <Cale> In fact, they're not.
21:55:18 <dibblego> Pseudonym, I don't mean to suggest anything of the sort - only suggest a basic premise that is requried for software to exist
21:55:27 <dibblego> I haven't even mentioned OO, computers, mathematics, nothing
21:55:40 <dons> at some point I need to write @dibblego
21:56:05 <Pseudonym> Well the thing is, "software" exists in the world of logic.
21:56:06 <dibblego> does a client observe software in linear time? if not, then it is not software?
21:56:08 <glguy> there really needs to be a /unlaslog
21:56:23 <Pseudonym> Which, as far as we can tell, is probably independent of a physical universe.
21:56:34 <dibblego> I can see why physicists get frustrated with mathematicians
21:56:50 <Pseudonym> The feeling is mutual, I can assure you.
21:56:51 <glguy> I can see why computer scientists get frustrated with dibblego
21:56:56 <dibblego> I'll bet
21:57:01 <Cale> Pseudonym: It's independent of any physical model, which is good enough for me, since I don't believe in an objective reality :)
21:57:18 <Pseudonym> Cale: I believe in objective reality up to isomorphism.
21:57:31 <dibblego> so next you hand me a peice of software and you say "it will do this then that", then I will say "sorry, that is wrong"
21:57:33 <glguy> dibblego: are you just trying to get to: requirements change over time?
21:57:34 <dibblego> *piece
21:57:42 <dibblego> glguy, yes
21:57:49 <dibblego> glguy, but not even get to requirements
21:57:49 <Cale> Pseudonym: but how are you going to use that assumption? :)
21:57:54 <dibblego> just state a simple basic premise of software
21:58:14 <Cale> I suppose it would be better to say that I'm objective-reality agnostic :)
21:58:21 <dibblego> glguy, software is a function of requirements and requirements change over time - is another way to say it, but in a more complex (indirect) manner
21:59:00 <dibblego> I find it amusing that we are using software, observing it over time, yet failing to acknowledge it
21:59:21 <glguy> "it" is a bit ambiguous there
21:59:28 <Cale> glguy: indeed
21:59:29 <dibblego> the software
21:59:39 <dibblego> time is not ambiguous
22:00:09 <dibblego> it is linear and in one direction - relative to software observed from a client of that software
22:00:09 <Cale> dibblego: By "software", do you mean "the actual arrangements of electrons in the computer's memory"?
22:00:23 <Cale> Or do you mean the abstract programs?
22:00:30 <Pseudonym> dibblego, how about we concentrate on some model of computation that explicitly mentions time.
22:00:32 <dibblego> Cale, perhaps, but not necessarily - it is the thing we are creating with programming languages
22:00:34 <Pseudonym> Like automata.
22:00:43 <glguy> and what do you mean by "acknowledge"
22:00:48 <Cale> One of them is something that it makes sense to physically model, the other has nothing at all to do with physics.
22:00:52 <Pseudonym> That way we can avoid getting stuck.
22:01:02 <dibblego> glguy, time, the illusion provided for our feeble minds, being taken for granted
22:01:18 <Cale> dibblego: Let's define time
22:01:20 <dibblego> Pseudonym, I am trying to simplify as best I can, but when I do, a hole is pointed out
22:01:27 <glguy> and remember that we are talking about encapsulation
22:01:31 <dibblego> Cale, why? it's been done by far greater than you or I
22:01:50 <Cale> dibblego: In many many many completely different and separate ways
22:01:52 <dibblego> Pseudonym, I can even start with -----------------------> time but that is rejected
22:01:57 <monochrom> Rather than saying "requirement changes", I say "there are many versions of requirements, each static".  Rather than saying "software changes", I say "there are many versions of software, each static."  And, above all, rather than saying "mutable variable changes", I say "there are many versions of this variable, each static".
22:02:06 <dibblego> Cale, let's start with a pre-school child version
22:02:23 <dibblego> Cale, then later, we can see if a proper definition makes it all fall apart or if it still holds
22:02:25 <Cale> dibblego: Are you talking about *physical* time, or *abstract model of computation* time
22:02:27 <Cale> ?
22:02:46 <glguy> when I compile ghc, that takes a lot of time
22:02:52 <Cale> glguy: hehe
22:02:55 <dons> hah!
22:02:58 <dibblego> glguy, does it produce output, then you compile?
22:03:04 <dibblego> Cale, computation if you will
22:03:05 <glguy> yeah
22:03:09 <glguy> lazy evaluation
22:03:15 <dibblego> glguy, I'll bet you compile then it produces output
22:03:20 <Pseudonym> When you get down to it, of course, a compiler is a pure function.
22:03:28 <Cale> dibblego: okay, then we can be sure that things like relativity are not a concern
22:03:32 <Pseudonym> Which maps valid programs to "my brain just exploded".
22:03:36 <dibblego> glguy, it didn't happen the other way around relative to you
22:03:44 <sjanssen> @yarr! -- it be International Talk Like A Pirate Day fer' me
22:03:44 <lambdabot> Drink up, me 'earties
22:03:45 <Cale> Pseudonym: haha
22:03:48 <glguy> dibblego: it's debatable as I was drinking
22:04:06 <Cale> dibblego: how would he know if he didn't look?
22:04:07 <dibblego> Cale, ok, so the example I used was this:
22:04:08 <Pseudonym> sjanssen: Arrr!  It been Talk Like a Pirate Day fer some time now, me hearty!
22:04:08 <glguy> (kidding)
22:04:36 <dibblego> in Java, class X{private int x;int get(){return x;}void set(int x){this.x = x;}}
22:04:50 <Pseudonym> Let's continyer this discussion like a pirate!  Arr!
22:05:05 <Pseudonym> dibblego: With you.
22:05:18 <Pseudonym> An example of poor design, I might add.
22:05:18 <dibblego> exposing both get and set operations at the same point in time
22:05:20 <dibblego> yet this is absurd
22:05:31 <monochrom> @remember glguy when I compile ghc, that takes a lot of time [audience question: does it produce output, then you compile?] yeah, lazy evaluation
22:05:35 <dibblego> since you must set before you can get
22:05:48 <dibblego> in Java, the hack to this is a dynamically typed placeholder for everything called null
22:05:55 <dibblego> you can rewrite it:
22:06:00 <monochrom> Is that the right way to use the "remember" command?
22:06:09 <dibblego> interface Get{int get();}interface Set{Get set(int x);}
22:06:18 <dibblego> then Get will only exist after Set
22:06:19 <glguy> ?quote glguy
22:06:19 <lambdabot>  that's odd, mine is this big : |-----------------------------|
22:06:25 <dons> monochrom: yep.
22:06:28 <Cale> dibblego: So? Just make get return a Maybe-like value.
22:06:32 <dibblego> but then most people would argue "that's not OO"
22:06:36 <Pseudonym> dibblego: In other languages you may be required to construct before either getting or setting.
22:06:37 <sjanssen> @quoth glguy
22:06:37 <lambdabot>  when I compile ghc, that takes a lot of time [audience question: does it produce output, then you compile?] yeah, lazy evaluation
22:06:43 <Cale> or yeah, have set return a getter.
22:06:44 <monochrom> OK!
22:06:55 <dibblego> Cale, Maybe is a better solution - whether or not it is correct is another debate
22:07:03 <Pseudonym> ?remember TheRaven Nevermore
22:07:17 <glguy> *denied*
22:07:29 <dibblego> the point is, both get and set were exposed when it was absurd
22:07:38 <Cale> So?
22:07:43 <dibblego> since we are able to apply a filter, the cost is not so high
22:07:46 <dibblego> so requirement leak occurred
22:07:52 <glguy> Cale: I think that he's arguing for MVars
22:08:00 <Pseudonym> What were the requirements here?
22:08:04 <dibblego> actually I'm arguing for FP eventually
22:08:14 <dibblego> it's funny that this discussion is how I even landed in this channel
22:08:16 <Cale> Yeah, another solution would just be to have get not terminate until the variable x was set.
22:08:27 <Pseudonym> Right.
22:08:27 <dibblego> since when I invalidated OO, I then said "what is the solution" then found I had reinvented Haskell
22:08:31 <Cale> Then it could never violate the interface.
22:08:50 <glguy> dibblego: how's that sound, the get function is blocking
22:09:01 <dibblego> I might just wait til I write it all down
22:09:06 <dibblego> I intend to be thorough
22:09:06 <Cale> The fact that it's possible to design incoherent interfaces isn't surprising.
22:09:12 <Cale> I don't see how it's forced.
22:09:26 <Pseudonym> An OO purist would also point out that get/set wrappers around data is stupid.
22:09:35 <dibblego> yes, all these points I could cover
22:09:35 <Pseudonym> If you want a struct, buy one.
22:09:52 <glguy> Pseudonym: they would say, use get set accessors so that if you store the data differently, no one has to know
22:09:57 <Cale> cover them then, or else you'll sound like a quack :)
22:10:00 <dibblego> I must also bring up the point of the static composition of operations to refute some of the points
22:10:06 <dibblego> which goes on and on as well
22:10:15 <Cale> I think you're just choosing really inappropriate words for saying what you're trying to say.
22:10:18 <Pseudonym> glguy: Or, even more likely, don't expose it at all.
22:10:42 <dibblego> I think I am being misunderstood, just like my boss did one day when I said "guess what, I think you're very wrong"
22:10:50 <Cale> So far, all that's been shown is "It's possible to write software which has bugs."
22:10:55 <dibblego> and it may well be my ability to communicate
22:11:04 <Pseudonym> And "it's possible to write software which is poorly designed".
22:11:06 <dibblego> certainly I hate these discussions on IRC - I have limited digits
22:11:07 <Cale> yeah
22:11:17 <Pseudonym> Even imperative programming 101 teaches you to initialise data.
22:11:26 <dibblego> no, I am retracting my attempt to point out anything
22:11:29 <Pseudonym> Object have to get constructed at one point.
22:11:42 <dibblego> simply because it is going down the road that I have trodden thousands of times before
22:11:44 <Pseudonym> Most OO languages enforce it.
22:11:47 <Cale> class X{private int x = 0; int get(){return x;}; void set(int x){this.x = x;}}
22:11:49 <dibblego> and I really don't want to right now
22:11:56 <Pseudonym> o/~ And I walk alone... o/~
22:11:58 <dibblego> yes I understand all those points
22:12:00 <Cale> problem solved by defaulting :)
22:12:08 <dibblego> no it's not - there is an article on that actually
22:12:12 <dibblego> the problem remains
22:12:19 <dibblego> written by a friend in #jtiger
22:12:23 <Cale> In this case, the problem is gone.
22:12:28 <glguy> the reqiurements leak?
22:12:38 <dibblego> it's not gone entirely
22:12:50 <Cale> I don't see how there's a requirements leak in the interface.
22:12:59 <dibblego> I know, and I take it all back
22:13:03 <glguy> dibblego: did you ever come to a solution tho?
22:13:15 <dibblego> glguy, yes, like I said, I ended up reinventing Haskell
22:13:18 <dibblego> or Clean actually
22:13:30 <dibblego> glguy, that's exactly the reason I am here
22:13:44 <glguy> because Clean doesn't have a freenode channel?
22:13:55 <glguy> ;)
22:14:17 <dibblego> no, because Haskell solves so many of the problems that the ones that it might not solve are far less relevant
22:14:31 <dibblego> just that those problems have never been formalised from what I have seen
22:15:02 <dibblego> glguy, I actually started working on my own programming language
22:15:06 <dibblego> glguy, three of us in #jtiger
22:15:09 <Cale> You can do what I would call OO programming in Haskell using existential types.
22:15:53 <Cale> There are no downcasts though.
22:15:55 <dibblego> but then I realised after changing around and arguing with myself and others, than I'm just reinventing FP in a new light
22:16:05 <dibblego> downcasts can be avoided in Java at all times
22:16:12 <Cale> and no implementation defaulting
22:16:33 <Cale> dibblego: Unless you want to use the standard libraries :)
22:16:49 <glguy> Have you guys played with the Castle Project's Windsor Container?
22:16:56 <dibblego> Cale, there is a systematic workaround when a third party dependency forces a requirement defect/leak
22:17:01 <dibblego> Cale, I have documented them all
22:17:26 <Cale> dibblego: I'm talking about things like the List type only working with values of type Object.
22:17:26 <dibblego> glguy, no
22:17:41 <dibblego> Cale, it doesn't @since 1.5, but you're right otherwise
22:17:51 <dibblego> Cale, you can workaround that problem
22:18:01 <dibblego> Cale, it will involve one cast
22:18:07 <Cale> Yeah, now they have parametric polymorphism
22:18:14 <glguy> Java has generics now
22:18:14 <Cale> yeah, a downcast
22:18:18 <dibblego> I wouldn't go so far as to call it that
22:18:19 <glguy> right?
22:18:23 <dibblego> there are some real nasties in there
22:18:30 <dibblego> glguy, I don't even call it that - that's a marketing term
22:18:41 <glguy> I don't care what kind of term it is
22:18:47 <Cale> You're saying it's not parametric polymorphism?
22:19:11 <dibblego> Cale, that implies it is something useful and is a tool that aids the development of software
22:19:22 <dibblego> under that pretense, no it is not
22:19:30 <dibblego> since it does not fit that definition
22:19:54 <Pseudonym> Parametric polymorphism is what it is.
22:19:55 <Cale> glguy: For some reason, your mention of the Castle Project's Windsor Container made me think of Windsor Salt. http://www.windsorsalt.com/
22:19:57 <lambdabot> Title: Windsor Salt
22:20:01 <dibblego> when I used to work on the Java implementation
22:20:02 <Pseudonym> Regardless of how useful it is.
22:20:07 <dibblego> I pointed out some of the defects in JSR-14
22:20:20 <dibblego> I was told essentially to "get back in my box"
22:20:27 <dibblego> when I was working the IBM filth
22:20:30 <Pseudonym> Who told you that?
22:20:33 <Cale> dibblego: Nothing in the definition of "parametric polymorphism" says "must be useful and a tool that aids the development of software"
22:20:42 <dibblego> members of the JSR team - that is not verbatim
22:20:55 <dibblego> every time I tried to make sense I was told that  - so I left the filth
22:21:08 <dibblego> Cale, then I would call it a subset of what I assume you are referring to
22:21:16 <glguy> dibblego: you didn't try to draw the time arrow, did you?
22:21:30 <dibblego> glguy, no, I never assume intelligence when I speak to an IBM employee
22:21:42 <glguy> ok, good
22:21:44 <dibblego> glguy, I talk to my 5 year old in more abstract levels
22:22:13 <dibblego> I actually found some IBM code lying about in my source code repository the other week
22:22:19 <dibblego> i could have fun with it :)
22:22:41 <dibblego> in my 7 years teaching at uni, I haven't found a student who produced worse code than IBM
22:23:20 <dibblego> let me find some broken bits of generics for you
22:23:30 <dibblego> in simple IBM terms
22:23:47 <Korollary> that ought to be a good uni
22:24:05 <dibblego> or a bad IBM
22:24:10 <dibblego> given interface I<T>{void m(T t);} and method(I<?> i), it is impossible (error) to invoke method m on reference i without knowing the concrete type parameter of the type of i (best case warning)
22:24:12 <Korollary> consultant code?
22:24:16 <dibblego> no, JDK 1.5 code
22:24:28 <dibblego> the IBM implementation of course
22:24:33 <Korollary> sad
22:24:47 <dibblego> funny, now I don't work there anymore :)
22:25:14 <dibblego> given List<X<Y>> list - where Y is in some way bounded - it is
22:25:14 <dibblego> impossible to call list.toArray without (at best) a warning
22:25:33 <Korollary> I don't know anything about java generics. What am I looking at?
22:25:42 <dibblego> given a reference of type X<Y>[] x - where Y is in some way bounded - it is impossible (error) to assign x to anything but literal null
22:25:46 <Korollary> "some way bounded" sounds weird.
22:25:58 <dibblego> just some problems - two of them I pointed out before generics was public
22:26:13 <dibblego> I am just trying to make it clear that there is a reason why "generics" is a marketing term and nothing more
22:26:34 <dibblego> "some way bounded" means it is not <?> (unbounded)
22:26:48 <dibblego> <? extends T> (partially bounded)
22:27:05 <Korollary> I heard about claims that java's generics design was fundamentally flawed.
22:27:17 <dibblego> I'll bet not from Sun/IBM
22:27:25 <Korollary> Of course
22:27:38 <glguy> do these arguments translate to C#'s implementation?
22:27:42 <dibblego> it is the duty of an IBM employee to internalise the legitimacy of such constructs or be forever burned at the stake
22:27:58 <dibblego> glguy, I don't know for sure, but last I looked at C# there were fundamental differences
22:28:00 <Korollary> glguy: I didn't hear anything negative about c#.
22:28:21 <glguy> I've only used C#'s "generics" and C++'s "templates"
22:28:33 <dibblego> and you say "java's generics design was fundamentally flawed"
22:28:35 <Cale> dibblego: Isn't that rather like how you can't call "show" on something in Haskell if its type is not completely determined?
22:28:45 <dibblego> in fact, I have seen no product of a JSR team that is not fundamentally flawed
22:29:05 <dibblego> Cale, from my meagre understanding of type classes, I think it is very different
22:29:18 <dibblego> just the generics gets the spotlight more than all other JSRs
22:29:23 <Cale> I might be misinterpreting your Java syntax though, since I haven't used Java since version 1.3
22:29:25 <lscd> dibblego: let's take it as a given that IBM produces bad software; that doesn't have so much to do with Haskell
22:29:28 <dibblego> I wrote a JSR-115 implementation for WebSphere
22:29:43 <dibblego> lscd, well no, only in a very indirect way
22:29:43 <Korollary> I believe there was a compromise where they wanted to keep the VM backwards compatible, which in turn hurt their design. But don't listen to me.
22:30:02 <dibblego> Korollary, right, but they still screwed it up
22:30:04 <lscd> Korollary: there were quite a few ugly compromises... and the java type system is still unsound, but hey
22:30:15 <dibblego> Korollary, the point is, they broke reverse compatibility anyway
22:30:31 <Korollary> Awesome
22:30:34 <dibblego> there is a reason why -source 1.5 *requires -target 1.5
22:30:51 <dibblego> the compiler won't run otherwise
22:30:59 <dibblego> and that's because of another JSR - 175
22:31:10 <dibblego> it's all a monkey cage and I found the key anyway
22:31:13 <dibblego> </rant>
22:31:27 <Korollary> When are the icfp results going to be announced?
22:31:44 <dibblego> results? as in reports?
22:31:49 <Korollary> the contest results
22:31:55 <glguy> WHOA, did you guys know that vim had a completion dropdown? example: vim test.html, type <a and then ^X^O
22:31:55 <dibblego> oh
22:32:27 <lscd> dibblego: anyhow - I'm not convinced that non-pure programming with mutable state and a lack of referential transparency necessarily violates encapsulation (I'm not arguing it's _good_)
22:32:44 <dibblego> lscd, I'm not convinced of that either
22:32:56 <lscd> so why would oo, then?
22:33:03 <Cale> glguy: ^X^O? Are you sure you're not in emacs by mistake? :)
22:33:07 <glguy> did you know vim had tables?
22:33:09 <dibblego> lscd, haven't we decided not to go there?
22:33:09 <glguy> tabs*
22:33:11 <lscd> Cale: heh
22:33:23 <lscd> dibblego: oh, did you?  I wasn't exactly here for that part
22:33:29 <dibblego> lscd, yes I pulled out
22:33:35 <lscd> ah, ok; sorry, then
22:33:39 <dibblego> no worries
22:33:41 <lispy> what is the undo of set -e in bash?
22:34:17 <lscd> unset?
22:34:24 <glguy> set +e?
22:34:39 <lscd> though undoing the shell exiting might be tough
22:35:09 <lispy> oh, i tihnk it is +e
22:35:10 <lscd> cloning features from ocaml's back-in-time debugger might be one way
22:35:10 <Cale> dibblego: most of the criticism I'm finding of generics in Java have to do with the fact that it erases types, which makes certain seemingly reasonable casts unsafe.
22:35:26 <Cale> s/have/has/
22:35:55 <dibblego> Cale, yes, I think that's another problem - you cannot write java.util.ArrayList without a compile-time warning - someone must have known by then surely
22:36:01 <Korollary> My mathematical analysis software predicts that lennart will time out and rejoin in five minutes.
22:36:43 <lscd> Cale: you can also have code that compiles with a warning, and then gives you an entirely wrong type
22:37:31 <Cale> lscd: yeah
22:38:04 <lscd> (there's also no way to disable the warning if the code always gives you the right type in that situation; though I forget the details, and I can't look it up right now)
22:38:07 <Cale> Though if it involves casting, I'm not sure I can feel all that sorry for them
22:38:12 <lscd> no, no casting
22:38:42 <dibblego> my first point above is quite devastational - given a type T pre-1.5, it is now written T<?> if it is parameterised - and now you cannot call a method on it if it accepts a parameter whose type is inferred by the type parameter
22:39:25 <glguy> ?all-dicts devastational
22:39:27 <lambdabot> No match for "devastational".
22:39:33 <dibblego> brokeen
22:39:39 <monochrom> devastating
22:39:43 <glguy> ?all-dicts brokeen
22:39:44 <lambdabot> No match for "brokeen".
22:39:46 <dibblego> ?all-dicts brokeen
22:39:47 <lambdabot> No match for "brokeen".
22:39:52 <dibblego> knew you'd do that
22:40:01 <glguy> i beat you to it (c:
22:40:11 <monochrom> Korollary: you're amazing!
22:40:18 <glguy> devastational, is that like automagical?
22:40:32 <monochrom> it's like devastating, man
22:40:39 <dibblego> it's funny - I'm sure I've heard that word used in media
22:40:43 <monochrom> or denotational
22:40:49 <dibblego> I'll remember next time I hear it
22:41:14 <Korollary> monochrom: Markov chains work!
22:41:23 * Korollary hits the stock market
22:41:24 <monochrom> Oh you don't want to hear me rant about how the media is flawed.
22:41:41 <glguy> Someone would have to disagree with you to make it worth it
22:41:50 <Cale> dibblego: it seems a mistake to not name the type parameters
22:41:58 <dibblego> I know it is and I hate to think I have been unwittingly influenced with poor grammar, but it appears that this is the case
22:42:03 <Cale> that is, they should be proper variables
22:42:24 <monochrom> Hmm should it be "the media are flawed"?
22:42:28 <dibblego> Cale, but then they are not assignable to earlier versions (the attempt at reverse compatibility)
22:42:56 <glguy> monochrom: I believe that would be the british way to say that
22:42:59 <dibblego> a List is now a List<?> for example
22:43:16 <dibblego> a List and a List<Object> are different
22:43:46 <dibblego> given a List<?> l, I challenge anyone to call l.add - it cannot be done
22:44:00 <glguy> since I know that the British say things like "Parliment are debating the issue."
22:44:01 <dibblego> of course, the marketing literature makes a justification for this
22:44:02 <Cale> and it shouldn't!
22:44:23 <dibblego> if it shouldn't, then you should not be able to call l.add given List l either
22:44:41 <Cale> dibblego: right, you shouldn't
22:44:44 <dibblego> you see the contradiction
22:44:52 <dibblego> I agree you "shouldn't"
22:44:59 <Korollary> glguy: Yes. Collective nouns, even when obviously plural, are treated as singular in US english.
22:45:02 <Cale> How do you call it with just List?
22:45:09 <dibblego> l.add(anything);
22:45:29 <dibblego> s/anything/anyReferenceType
22:45:31 <Cale> Are you sure that List is not List<Object> ?
22:45:34 <monochrom> The joy of dynamic type checking
22:45:35 <dibblego> positive
22:46:18 <dibblego> if it were, then there would be yet a different problem
22:46:29 <dibblego> http://java.sun.com/j2se/1.5/pdf/generics-tutorial.pdf section 3 points it out
22:46:32 <lambdabot> http://tinyurl.com/3heps
22:46:34 <Cale> So what, can you break things like that, by referring to a List<Integer> as a List and then adding a String to it?
22:46:36 <Korollary> Does anyone have a clear definition of a semantic type (as opposed to syntactic type)?
22:46:40 <dibblego> Cale, right
22:46:59 <Cale> Okay, that's broken. They should just remove the parameterless versions.
22:47:09 <dibblego> but then there is no reverse compatibility
22:47:13 <Cale> Who cares?
22:47:19 <dibblego> my point exactly
22:47:25 <dibblego> clearly marketing departments care
22:47:40 <Korollary> It reduces synergy.
22:47:41 <dibblego> given the available choices, I think they made the worst choice
22:47:44 <Cale> Just keep providing old versions of Java.
22:47:59 <monochrom> I don't have a definition but I have examples.  Dana Scott is a semantic type, and whoever invented the do-notation is a syntactic type.  *duck*
22:48:06 <dibblego> Cale, get back in your box and stop trying to create problems :)
22:48:38 <Korollary> monochrom: You can joke! Have you been drinking?
22:48:49 <Cale> dibblego: Then you could say, you don't like generics? Use Java 1.1!
22:48:54 <monochrom> No.  Just refusing to go to bed will do. :)
22:49:15 <glguy> C# makes a distinction between System.Collections.IList and System.Collections.Generics.IList<T>
22:49:20 <glguy> they are unrelated types
22:49:21 <dibblego> Cale, I was supporting an application that ran on Java 1.1 just 9 months ago
22:49:31 <Korollary> Then you should try out oxygen masks. Euphoria in Fight Club style.
22:49:33 <dibblego> an application that comes with the JDK as an extension
22:49:38 <Cale> dibblego: sure, why not? :)
22:50:05 <dibblego> the day I resigned felt like I lost 50 tons of weight
22:50:20 <dibblego> "no more idiots!!" I cried as I ran down the stairs
22:50:30 <Korollary> dibblego: Did you smash the printer with a baseball bat too?
22:50:40 <dibblego> the fact that you can even analyse generics at the level that you did means you cannot work for IBM
22:50:45 <monochrom> The printer is innocent.
22:50:54 <dibblego> Korollary, no I just quietly left
22:51:16 <dibblego> I'd been there for enough years
22:51:33 <dibblego> I was working on WebSchmear before the JDK
22:52:10 <Korollary> IBM wouldn't hire me when I had just graduated as a foreigner without a GC, which was weird because everyone else would. It sounded like a braindead preference to me. Oh well.
22:52:37 <dibblego> I once went for a job interview with an intelligence agency
22:52:59 <dibblego> apparently I got the highest score on the knowledge test but failed the psych test
22:53:19 <dibblego> critical analysis skills are the enemy
22:53:26 <Korollary> What was the psych test like, if you are allowed to talk about it?
22:54:09 <dibblego> asking questions about "extremeties", like "what's the hardest thing you did?" and "what's the most dangerous thing you did?"
22:54:19 <dibblego> and then "what was the feeling?" and stuff flike that
22:54:24 <Korollary> Bleh
22:54:25 <dibblego> the problem was that I just told the truth
22:54:59 <dibblego> the most dangerous thing I do is something I do every day - I use a public road
22:55:01 <lispy> dons: i've narrowed the problem with 'index map' down to goa
22:55:07 <lispy> dons: but still not sure why it's happening
22:55:35 <Korollary> dibblego: That's probably true.
22:56:26 <dibblego> Korollary, I think the risk mitigation skills are warped when I watch them avoid something with low probability of occurring and low consequences, then they'll go get in a car and drive down a road
22:56:35 <dibblego> *of people I should say
22:56:58 <Korollary> dibblego: However, I tend to think that they must have collected a ton of stats on those questions.
22:57:07 <Korollary> So the test may not be as bad.
22:57:28 <dibblego> Korollary, at the time I had no idea what answer they wanted to hear - I jsut said it as I saw it
22:57:58 <dibblego> they asked "how fast do you go on your motorcycle?" I said "well 250kph" or something, then I said that is not dangerous
22:58:03 <dibblego> which I still think is true
22:58:16 <dibblego> on race track I mean
22:59:01 <dibblego> I had a court charge dropped against me recently - for holding a sign that reads "Police Speed Trap Ahead"
22:59:08 <dibblego> they are chicken shits
22:59:11 <Korollary> lol
22:59:19 <Korollary> where is this?
22:59:33 <dibblego> after I entered my plea, I mounted a defence, then they tried to milk it from me on the phone, then they shat and pulled it
22:59:37 <dibblego> Brisbane, Australia
22:59:43 <dibblego> I have the television appearance somewhere
22:59:56 <dibblego> the local rant shows wanted to hear about it
23:00:15 <lispy> dons: apparently when you give extra spaces at the end to index it fails
23:00:19 <lispy> ?index map
23:00:20 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
23:00:25 <lispy> heh
23:00:29 <lispy> but from irc
23:00:34 <lispy> er but not from irc
23:01:06 <dibblego> they alleged a breach of sect444 PPRA2000 "Obstruction or assault of a police officer in the execution of duty"
23:01:47 <Korollary> heh
23:02:14 <dibblego> I also demanded a receipt for seizure of evidence (PPRA2000) then they failed to return it after dropping the case
23:02:29 <dibblego> so it is they who broke the law, not me
23:02:34 <dibblego> this world is crazy
23:06:27 <Korollary> Hey, you could be living in the US.
23:07:34 <dibblego> the US is not as bad as Australia in speed law enforcement
23:07:40 <dibblego> the order is UK, Australia, US
23:07:49 <dibblego> I study this stuff in my spare time :)
23:07:59 <Korollary> I think you have an agenda, sir.
23:08:02 <dibblego> I am a member of a road safety initiative
23:08:05 <dibblego> yes I do
23:08:05 <glguy> UK has all of those automated traps setup, don't they?
23:08:06 <Korollary> I knew it!
23:08:28 <glguy> s/setup/set up
23:08:41 <dibblego> yes UK speed enforcement propaganda is the most prolific
23:08:47 <dibblego> we have automated traps as well
23:09:00 <dibblego> my agenda is to stop killing road users at the expense of profit
23:09:35 <dibblego>  driving in the US is much nicer than here I find
23:10:09 <dibblego> but I haven't done much of that
23:11:17 <lispy> ?help url
23:11:17 <lambdabot> url <key>. Return element associated with key
23:24:07 <dfranke> arrr.
23:27:31 <lispy> ?seen edwardk
23:27:32 <lambdabot> I saw edwardk leaving #haskell 7h 42m 38s ago, and .
23:29:38 <lispy> ?seen bringert
23:29:39 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 5h 21m 33s ago, and .
23:31:35 <monochrom> ?seen lennart
23:31:36 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
23:32:37 <lispy> ?seen dons
23:32:38 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 26m 12s ago.
23:33:34 <glguy> bored?
23:34:14 <Pseudonym> ?seen glguy
23:34:15 <lambdabot> glguy is in #haskell. I last heard glguy speak 40s ago.
23:34:51 <lispy> no
23:34:54 <lispy> just looking for people
23:35:19 <lispy> i wanted bringert or edwardk because they both know javascript...
23:35:28 <lispy> and for dons i have patches!
23:35:33 <lispy> lots and lots of patches
23:35:40 <lispy> he's probably getting sick of them by now :)
23:35:53 <glguy> I gave dons two patchs today (c:
23:36:05 <lispy> but lambdaweb now does bf
23:36:21 <glguy> where is lambdaweb? publicly accessible?
23:36:24 <monochrom> I keep decoding bf as boyfriend.
23:36:31 <lispy> i sent him at least 2 (or is it three) emails with lambdabot patches and two emails with GoA patches :)
23:36:36 <lispy> http://lambdabot.codersbase.com/
23:36:37 <lambdabot> Title: Lambdabot Web Interface
23:36:51 <lispy> ?where+ lambdaweb http://lambdabot.codersbase.com/
23:36:52 <lambdabot> Done.
23:37:48 <lispy> glguy: if you want to play with it, it's a combo of lambdabot + goa
23:38:27 <glguy> Where does gtk2hs install the examples (*nix filesystem)
23:38:39 <lispy> the website could use some work...functionally it's pretty much sound, but then it needs instructions, examples and a logo
23:38:53 <lispy> glguy: no idea, that sounds like a dcoutts_ question
23:39:08 <monochrom> probably nowhere, glguy.  but they're in the tarball somewhere
23:39:33 <lispy> anyone here have graphic art skills?
23:39:49 <lispy> for lambdaweb we need a logo...maybe a lambda sitting in a web?
23:48:05 <dons> re.
23:48:12 <lispy> re re re, yo!
23:48:14 <glguy> > let fibs = 1:1:[a+b | (a:b:_) <- tails fibs] in take 10 fibs
23:48:16 <lispy> dons in the hizzy
23:48:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
23:48:21 <dons> yo!
23:48:24 <glguy> why does lambdaweb say parse error
23:48:27 <dons> lispy: patches!
23:48:39 <lispy> glguy: good question
23:48:45 <dons> I'm adding moduleHotFlush :: m -> Bool right now :)
23:48:45 <lispy> glguy: let me check the log
23:48:52 <glguy> lispy: ah, i need an extra >
23:48:52 <lispy> hot flush?
23:48:54 <lispy> ah
23:49:01 <glguy> lispy: the one in the output is decorative
23:49:03 <lispy> oh
23:49:03 <dons> yeah, if you set it, the state for that module is flushed on write
23:49:26 <glguy> that's cool
23:49:29 <lispy> dons: fixes a problem with @where+ ?
23:49:36 <lispy> glguy: so it works now?
23:49:41 <glguy> yeah
23:49:45 <dons> for things like @quote and @where, that we don't want to lose entries on
23:50:17 <lispy> dons: after int-e explained a bug in @bf i'm kinda surprised it ever ran any programs correctly before :)
23:50:21 <monochrom> @quote monochrom
23:50:21 <lambdabot>  [monochrom] I prove my programs correct. [sjanssen] my programs are more correct than you deserve
23:50:24 <lispy> dons: appears to be 100% patched now that
23:50:27 <lispy> er though
23:50:58 <dons> good
23:51:05 <dons> heh
23:51:07 * lispy wants to drive up to portland to just turn off lennart's laptop :)
23:51:21 <dons> :)
23:51:48 * glguy is building gtk2hs on os x with gtk 2.10... here goes nothing :)
23:51:58 <lispy> noting at all
23:52:03 <lispy> nothing*
23:52:34 <glguy> It was already installed but was somehow not doing anything
23:52:49 <glguy> so I'm trying again (lots of packages changed recently for me)
23:53:08 <glguy> hopefully it will be done in the morning time
23:53:13 <glguy> good night moon
23:56:14 <lispy> dons: what do you think of the log lambdabot is generating?
23:57:18 <lispy> dons: i wish it had the date in it
23:57:39 <dons> yeah, I should just move the log module stuff into Base.hs
23:57:40 <lispy> dons: and the user isn't so useful since it's always null
23:57:44 <dons> so its tagged by day and so on
23:57:46 <dons> and channel
23:58:04 <lispy> i wish apache was logging...
23:58:07 <lispy> i should check that gain
