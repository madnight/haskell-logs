00:06:36 <kzm> lispy: (!)?
00:07:04 <kzm> (I guess you need unsafeFreeze first as well)
00:09:46 <lispy> kzm: eh?
00:10:00 <lispy> what is that and why do i need it?
00:11:43 <kzm> Isn't it the non-monadic equivalent of readArray?
00:12:39 <lispy> i dunno, i just put things into the IO monad and replaced ! with unsafeRead and // with unsafeWrite
00:12:44 <kzm> Perhaps I misunderstood - I just woke up, and haven't gotten through my email or my coffee yet.
00:13:29 * lispy should be asleep, fwit
00:13:32 <lispy> er fwiw
00:13:41 <kzm> But if you're in IO, then reading is a monad action as well.
00:14:27 <kzm> Anyway - can we do efficient linear algebra operations without resorting to IO/ST?
00:14:54 <kzm> Currently, I do a lot of conversion back and forth between arrays and lists.
00:25:40 <dolio> Open data types/functions seem like they overlap a lot with type classes...
00:28:11 <edwardk> kzm: not really. you're presently stuck with an IO or ST monad (i have an array implementation built over STM if you really want another option though)
00:28:23 <edwardk> but its not much better
00:35:19 <falconair> is there an estimated release date for GHC yet?
00:35:51 <dolio> I seem to recall someone saying they wanted it released before the hackathon.
00:36:05 <falconair> the one in the middle of september?
00:36:18 <dolio> I believe so.
00:36:23 <dolio> Unless there's another soon after that.
00:37:01 <kzm> edwardk, well - I have functions for extracting columns and rows from matrices - presumably, they could be 'sliced' directly from the array.
00:37:11 <falconair> second question: a build for OS X (intel) is part of that release, right? :)
00:38:26 <kzm> I.e. a type like (Vector array offset step) should be able to slice the array in the desired way.  Maybe.
00:38:48 <edwardk> kzm: i've mostly been looking at block decomposition for the last day or so.
00:39:12 <edwardk> kzm: not so big on slicing down rows and columns for most real world operations
00:39:17 <kzm> Anyway, I'm currently happy with the list performance (but haven't tried to tackle bigger problems yet)
00:39:21 <edwardk> bad cache locality
00:39:36 <dolio> I don't know about the OSX question, although they've been working on it furiously, if the mailing list volume is any indication.
00:39:56 <falconair> dolio: thanks
00:40:03 <kzm> My matrices aren't that big (neural networks, not discretized continous domains :-)
00:40:19 <edwardk> kzm: heh then you should be fine
00:40:28 <kzm> But you could probably do blocking via slicing as well, if the slicing is general enough.
00:40:33 <kzm> Save you copying.
00:40:42 <edwardk> kzm: heck for neural nets you might just sparsely connect each layer to the next
00:40:49 <kzm> Isn't that what F90 (or so) does?
00:41:09 <kzm> edwardk, I think the linear algebra model is much neater.
00:41:25 <kzm> I read some tutorials building objects representing nodes etc in C++.
00:41:27 <kzm> Yuk.
00:41:30 <edwardk> fortran has lots of ways to carve up arrays, check out your local BLAS ;)
00:41:51 <kzm> Right.  And presumably without copying them?
00:42:05 <edwardk> yeah i'm not a big fan of it, but it fits haskell's model fairly well. its not monolithic and weights can propagate via catamorphism.
00:42:37 <edwardk> kzm: sure, but that relies on properties that you can't mimic in a pure setting. so you need to switch to a cruft old io or st monad.
00:42:44 <edwardk> er crufty
00:43:03 <edwardk> hence why the digraph model is so nice in functional land
00:43:40 <kzm> Well - if implemented correctly, I suppose the amount of calculation is the same.
00:44:03 <edwardk> yeah. just thinking about zipping and mapping to apply weights, etc.
00:44:03 <kzm> Linear algebra is pretty concise, though.
00:44:11 <edwardk> nice high order folds in haskell code
00:44:27 <edwardk> er zipwith even
00:45:02 <edwardk> at least its really clean for fully connected layers
00:45:20 <edwardk> would get a little funky for partially connected layers
00:45:31 <kzm> You wouldn't have any code for this, would you?
00:45:34 <edwardk> but that plays havoc with some propagation models.
00:45:57 <edwardk> hrmm. no, but i guess i could bang some up to at least apply the weights, hrmm.
00:46:28 <kzm> I think my linear algebra using code is working now (at least, I managed to train a simple net to do boolean AND :-)
00:46:45 <kzm> I'd be interested to compare with other approaches.
00:47:30 <edwardk> whats a good set of perceptron weights, hrmm
00:48:57 <kzm> Well - I can train some for you, but then you'd get nonzero weights.
00:49:20 <edwardk> > foldr (+) 0 $ zipWith (*) [1,0,1] [1,1,1]
00:49:21 <lambdabot>  2
00:49:39 <edwardk> gives you a simple linear weight application of weights [1,0,1] to inputs [1,1,1] for a single node taking its inputs
00:49:49 <kzm> Anyway: since my matrices and vectors are converted to lists, I think you'd end up with the same code.  Perhaps you can derive the correct folds and zips from it?
00:50:06 <edwardk> the next step is to support n nodes, so you just make a list and map this function.
00:50:54 <kzm> > let dotproduct x y = foldr (+) 0 . zipWith (*) x $ y
00:50:54 <lambdabot>  Parse error
00:51:00 <kzm> Yeah, whatever :-)
00:51:17 <edwardk> heh
00:51:18 <kzm> See where this is leading? :-)
00:51:21 <edwardk> yeah but the same idea =)
00:52:34 <kzm> so for n nodes, you'd get 'map (dotproduct input) nodeweights', which you might as well name 'matrix_vector_product'
00:52:41 <edwardk> yeah =)
00:53:17 <kzm> So at the current stage, I think the difference is one of terminology :-)
00:53:18 <edwardk> but its done purely in terms of lists, no ugly io based arrays around
00:53:31 <edwardk> lists are something that haskell is good at
00:53:47 <dolio> Then you can port it to Data.ByteString. :)
00:54:13 <kzm> Sure.  I stored things as arrays - this is mental baggage from thinking in linear algebra terms.  It does make it easier to check bounds, though.
00:54:50 <kzm> Origially, I wanted to use phantom types to encode bounds, but...
00:54:51 <edwardk> *nods*
00:54:53 <falconair> edwardk, i just skimmed through the paper you suggested a few hours ago: "Pure Type Systems for Functional Programming" ... now I'm going through "Henk: a typed intermediate language" ... do you know if haskell plans on incorporating PTS or lambda-cube? (afaik, it doesn't right now)
00:54:56 * kzm checks who's in the audience...
00:55:06 <kzm> ..it turned out to be too much hassle.
00:55:17 <kzm> Now it's pretty ugly with dynamic checks all over :-(
00:55:38 <edwardk> falconair: well, the kinda use the 'left side' of the cube, they just don't add dependent types in a meaningful way, though the gadts are arguably a limited form
00:55:41 <dolio> jhc is based on lambda-cube, is it not?
00:56:07 <edwardk> jhc has a pts in its internal representation, but it only uses the type dependent type part
00:56:17 <edwardk> it doesn't do term dependent types
00:56:26 <edwardk> or at least doesn't use it
00:57:18 <edwardk> kzm: hrm. yeah i wrote a bunch of type level 2s complement integers primarily to use for that same purpose
00:57:29 <falconair> doesn't 'generic' haskell come for free if lambda-cube is used? (dependent types as well for that matter) ... if lambda-cube is indeed used, then are these limitation artificial or is there a good reason for not having them?
00:57:47 <edwardk> faconair: well, dependent types fuck with compilers ability to get anything done
00:57:54 <edwardk> when you get done you just wind up with an interpreter =)
00:58:09 <edwardk> coz everything can depend on anythig and its hard to erase types
00:58:13 <dons> ?remember edwardk well, dependent types fuck with compilers ability to get anything done
00:58:23 <edwardk> heh
00:58:29 <kzm> edwardk, if you want to have a look, I can put my NN module on the net.  It's about one or two pages.
00:58:48 <dons> having helped write a dependently typed IR for a compiler, I agree :)
00:58:50 <edwardk> kzm: i'll pass. stared at enough ai crud to last me a lifetime ;)
00:58:57 <edwardk> dons: hehehe
00:59:04 <kzm> Sure.
00:59:28 <kzm> But it ain't crud, it's Haskell.
00:59:42 <edwardk> dons: kind of leaning towards a type tower model with runtime compilation allowed for my toy projects
00:59:43 <falconair> "...wind up with an interpreter" ... by that do you mean that the run-time becomes larger than it is in non-dependent code?
01:00:54 <dons> the compiler ends up with a runtime
01:00:59 <kzm> edwardk, let me just ask this: is it correct that training (backpropagation) will always reduce the sum-square error for that datum?
01:01:03 <edwardk> falconair: well, if you have dependent types, then your types now depend on terms, the whole thing becomes an impredicative mess. your type inference becomes undecidable in general so you wind up having to use some form of System F-based heavily annotated syntax, hindley milner doesn't work in general, the runtime has so many cases to deal with it literally becomes an interpreter over the AST, etc.
01:02:04 <kzm> edwardk, and while I'm at it: perceptrons require a fixed additive input in addition to the "real" input (typically x0==1, and w0 adjusts it), but neural nets don't need this?  If they do, it's glossed over pretty good.
01:02:07 <edwardk> kzm: back prop can oscillate coz its not a continuous transformation as i recall
01:02:18 <falconair> hm...i think i understand, i need to read more :)
01:02:31 <kzm> Right - if the nu parameter (training step lenght) is too large.
01:02:45 <edwardk> kzm: yeah, so you can't say much about convergence of a discrete process
01:03:09 <kzm> But there exists a limit for it, so that if it is small enough, you will get a better result?
01:03:23 <kzm> (Thinking about QuickCheck properties to verify backpropagation here)
01:03:28 <edwardk> kzm: neural nets are a black art, not a science. =) like genetic algorithms, etc. they work pretty well at exploring the problem space, but they have lots of divergent cases.
01:03:55 <lispy> is (!) O(1) ?
01:03:58 <dons> yep
01:04:01 <kzm> edwardk, oh.  There goes my faith in AI.
01:04:02 <edwardk> falconair: i'll happily talk about pure type systems with anyone who cares =)
01:04:02 <lispy> ah, good :)
01:04:11 <kzm> Marvin Minsky - I take it all back!
01:04:14 <kzm> :-)
01:04:23 <edwardk> kzm: did a graduate certificate on the subject and walked away never to look back ;)
01:05:06 <edwardk> kzm: i occasionally fall back on a GP technique or something, but its only when the problem space is huge and i only need a better local optimum than i can get by greedy means.
01:05:07 <kzm> Probably saved you a lot of time, too.
01:05:08 <falconair> edwardk: by the way, I just found that the Henk language is one of the examples that comes with the parsec parser (at least the parser and the pretty printer)...makes it easier for newbies such as my self!
01:05:14 <edwardk> i tend to prefer simulated annealing solutions.
01:05:22 <edwardk> falconair: nice!
01:05:36 <lispy> dons: if i want to store something in an IOUArray do i need to evaluate it first or does it get evaluated when it's inserted?
01:05:43 <kzm> don't you get that by reducing the training parameter as you go?
01:05:52 <lispy> dons: or does it even matter in practice..
01:06:23 <edwardk> kzm: well, ga-style amoeba searching techniques made me a LOT of money about 10 years ago, that i promptly sunk into a dot-com and lost ;)
01:06:44 <edwardk> kzm: so its hard to say that nn/ga/gp stuff is useless
01:06:56 <edwardk> kzm: but its not a panacea iho
01:06:57 <dons> lispy, its a strict type, so it'll be forced when you insert a value
01:07:00 <edwardk> er imho
01:07:09 <dons> (there's no way to create an unboxed value without it being forced first)
01:07:42 <kzm> I suppose marketing is the *really* important part of everything in comp.sci.  Many of the AI techniques are being used, though.
01:07:44 <dolio> "Neural networks are the second best way to do anything"
01:07:48 <lispy> dons: okay, i'm sort of running out of ideas on how to optimize this...i wonder if it's having non-termination problems...
01:07:53 <kzm> "All models are wrong, but some are useful"
01:08:00 <edwardk> not that, as people here can attest, i hold back my opinions on much of anything ;)
01:08:53 <edwardk> kzm: yeah. well, GP/GAs do have some nice theoretical underpinning in terms of multi-armed bandit statistical models.
01:09:29 <kzm> We may get a student here who has written a program to detect fish in rivers - from submerged cameras.  I'm very eager to hear more about how he did it.
01:09:57 <falconair> edwardk: how easy/difficult is it to do GP in haskell?  I did some lilGP back in college, would love to get back into it with haskell
01:10:25 <falconair> by easy/difficult, i mean compared to C based implementations
01:10:41 <kzm> edwardk, I'm wondering if I should write a spam filter with my NNs.  It seems it should be able to perform better than the bayesian models currently used, at any rate.  I think there is a good argument that a linear discriminator is insufficient.
01:11:21 <edwardk> and back-propagation neural nets can be viewed as an iterative approximation of an nth degree polynomial regression model
01:11:38 <edwardk> falconair: haven't tried yet
01:11:58 <kzm> Are we distinguishing GP and GA?  I remember one talk with some guy permuting and evolving a lisp program, referring to it as GP - while GA would just permute some fixed set of parameters.
01:12:17 <edwardk> falconair: i would say you don't get much of a win in haskell because so many of the models update in place.
01:12:56 <edwardk> kzm: i tend to distinguish the two. GP evolving s-expression type structures and GA evolving bits in a fixed length genome
01:13:10 <kzm> edwardk, okay, that was my interpretation as well.
01:13:26 <edwardk> GP allows for unbounded intron accumulation, while GAs can't accumulate introns meaningfully to protect genetic information across generations.
01:14:05 <kzm> I'm not sure why you'd update in place - especially GP which involves trees sounds suitable to haskell.
01:14:18 <edwardk> so GPs tend to converge in a more stable fashion, you get a structure that accumulates cruft but can pass on its key genetic legacy, partially as an artifact of most GP algorithms doing a fixed mutation rate regardless of program size
01:14:26 <kzm> edwardk, interesting - I hadn't thought of that (introns)
01:14:26 <edwardk> well, GP is amazingly suitable to haskell =)
01:15:07 <edwardk> kzm: yeah, most people look at GP and see the introns as useless sideeffects
01:15:39 <kzm> edwardk, similar to 'junk' DNA :-)
01:15:48 <edwardk> to the gene being expressed they aren't useless., they increase the chance than a random change will occcur outside of the meaningful code. so they increase the odds of passing on the genetic legacy to succeding generations
01:16:29 <edwardk> this doesn;t matter as much if you perform 'highlander' selection, where the current winner gets to live forever across subsequent populations, but its still a subtle selective pressure.
01:16:48 <falconair> is it true that if one has an interpreter for PTS/lambda-cube (like in the PTS or Henk papers), something like haskell can be implemented on top of it simply in terms of syntactic sugar (other than things like foreign function interface I suppose)
01:16:57 <edwardk> you can compensate if you want nice explanatory adequacy by putting downward pressure on program size in your evaluation function, but its hard to tune that enough
01:17:15 <dons> falconair: sort of. check the 'henk' paper on the haskell.org website
01:17:19 <edwardk> falconair: jhc implements on top of 'E' which is basically henk on steroids.
01:17:30 <dons> ?google henk site:haskell.org
01:17:34 <lambdabot> http://darcs.haskell.org/packages/parsec/examples/Henk/
01:17:34 <lambdabot> Title: Index of /packages/parsec/examples/Henk
01:17:37 <dons> nope
01:17:38 <edwardk> falconair: and simon pj wanted henk as an intermediate language for haskell
01:17:44 <dons> for a while
01:17:51 <falconair> yup, my printer is printing the henk paper as we speak :)
01:18:04 <dons> ?wiki Research_papers/Type_systems#Pure_type_systems
01:18:05 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Pure_type_systems
01:18:31 <edwardk> falconair: heh, my biggest problem with PTSs is they bake in contraction and weakening, so i've had to go back to square 1 in order to add substructural types, THEN build up the PTS foundations over that.
01:18:54 <falconair> so why isn't it used by SPJ yet?  I mean is it because of theoretical problems or mundane things like lack of time?
01:18:55 <edwardk> also, you'll need to find a lot of journals physically to read the early PTS papers that establish their theoretical underpinnings.
01:19:32 <edwardk> more like the current approach is good enough, and the direction has shifted towards system Fc and other neat ideas
01:19:37 <dons> and if you do that, could you scan them in for us :)
01:19:47 <edwardk> dons: heh i have them all, but i don't have a scanner =)
01:20:39 <falconair> edwardk: speaking of which, where can i learn more about substructural types (what they mean)...I came across them when reading about logic programming and single assignment variables...ATAPL mentions them, but it is never really explained in simple terms
01:20:49 <edwardk> dons: journal of functional programming i, has a really good paper by henk barendregt on PTSs, also a couple issues later there is a nice modular proof of strong normalization for functional PTSs by geuvers that subsumes the more readily accessible results by coquand
01:21:07 <yip> hey guys, is ghc 6.6 going to be very different from the latest 6.5, or is it just going to be bug fixes and minor changes?
01:21:16 <edwardk> falconair: well, heh, i gave a pretty long winded explanation a couple of days ago, so skimming the logs here might be a good start ;)
01:22:14 <edwardk> kzm: heh, now i want to slap together a simple GP engine in haskell =)
01:22:39 <edwardk> yip: aren't even versions just stable releases?
01:22:47 <falconair> edwardk: i think i found it, your response to _frederik_ :) google rocks
01:22:53 <dons> yip, 6.6 =~ 6.5
01:22:53 <edwardk> heh
01:23:01 <dons> but 6.6 > 6.4
01:23:01 <edwardk> what search terms?
01:23:02 <edwardk> =)
01:23:12 <kzm> edwardk, go for it
01:23:35 <falconair> "edwardk" "substructural typing" =>  "01:56:06 <_frederik_> what are substructural types?"
01:23:51 <yip> dons: ok thanks :)
01:23:58 <edwardk> fal: i'm more than happy to ramble on at length about them, since i'm still firming up my current intermediate language for them
01:24:11 <edwardk> so having someone to bounce ideas off is good
01:24:27 <edwardk> i pretty much cause most people's eyes to glaze over on the subject
01:24:34 <edwardk> so a willing audience is welcome ;)
01:24:35 <yip> dons: is it possible that 6.5 might currently be completely broken or something?
01:24:41 <dons> its possible
01:24:46 <falconair> edwardk: you're not in the new york area are you?  i'm trying to learn this stuff on my own, royal pain in the ass
01:24:48 <dons> though i didn't notice anything?
01:24:56 <edwardk> falconair: michigan actually
01:25:03 <falconair> no kidding, where in michigan?
01:25:08 <edwardk> falconair: will be at ICFP if you go this year
01:25:14 <edwardk> ypsilanti
01:25:25 <edwardk> a little outside of detroit basically
01:25:43 <edwardk> right next to  ann arbor if you know the area at all
01:25:49 <falconair> edwardk: no, i barely know the ABCs of functional prog, I'll just be looking at people's faces, besides, I'm job hunting these days
01:26:11 <falconair> edwardk: hehe, I graduated from UMICH in 2000 (undergrad)...I went to high school near Kalamazoo, MI
01:26:16 <edwardk> falconair: heh likewise. i'm currently lecturing and programming random linguistics projects for a living.
01:26:44 <dons> ?seen Pseudonym
01:26:44 <lambdabot> I haven't seen Pseudonym.
01:26:48 <edwardk> falconair: ah. =) been collecting as many degrees from EMICH as i can in as short of time as possible ;)
01:27:10 <edwardk> i was going to go back to UMICH and they wanted me to sit on my ass and take my classes at a normal person's pace.
01:27:21 <edwardk> switched to eastern and burned through them at 28 credits a semester.
01:27:29 <edwardk> much more satisfying
01:27:59 <falconair> edwardk: I'll probably visit my parents in MI in the next couple of weeks, I'd love to sit down with you for an afternoon, let me know if you have time: shahbazcATgmailDOTcom
01:28:28 <RobHu> How feasible would it be for someone who has never used Haskell before to aim to a proof of concept SQL database in 3 days (including learning Haskell) ?
01:28:50 <edwardk> sure. i leave for ICFP on the 16th, but i'll be around until then
01:29:09 <falconair> edwardk: to be honest, i don't think i even heard of lambda calculus in college, I feel like i wasted four years...if i could go back now I would love to learn logic, PLT, etc.
01:29:19 <edwardk> yeah, thats pretty much how i felt
01:29:31 <edwardk> i've been diving into the functional side of things for the last couple months now
01:29:32 <RobHu> aim to write that was meant to say :-)
01:30:05 <edwardk> falconair: if you shoot me an email at ekmett@gmail.com i'll reply with address and contact info
01:30:25 <falconair> will do
01:30:51 <falconair> edwardk: let me ask you this about ICFP, is there any point in a newbie going to such a conference?
01:31:19 <edwardk> falconair: well, i think the haskell workshop will be cool. =)
01:31:31 <edwardk> falconair: i'm still getting my feet wet in functional land
01:31:36 <edwardk> though i kinda dove in the deep end
01:31:50 <kowey> RobHu: apparantly, a Perl programmer Yuval managed to learn Haskell enough to write a Forth interpreter in just a few days
01:32:01 <RobHu> so its possible
01:32:11 <kowey> RobHu: three days for me would be very tight... took me 2 weeks to learn Haskell... but you might be faster :-)
01:32:17 <RobHu> :P
01:32:21 <falconair> edwardk: man, if you call this 'getting your feet wet,' I'm scared shitless of this water
01:32:34 <edwardk> falconair: hehe
01:32:57 <RobHu> kowey: Just from the background he looks... impressive ;-) http://www.stat.berkeley.edu/~peres/PERES.jpg
01:33:44 <JaffaCake> dumb IRC question: I created #ghc, but it doesn't appear in the channel list - why?
01:34:00 <edwardk> did you register with chanserv?
01:34:08 <JaffaCake> yup
01:34:11 <edwardk> hrmm
01:34:13 <falconair> edwardk: ok, the sun is about to rise here in new york, which means it is time for me to enjoy my unemployment and go to sleep, I'll shoot you an email, thanks for all your help!
01:34:15 <edwardk> no idea then =)
01:34:33 <edwardk> falconair: heh, not a problem. if you use AIM: i'm EdwardAllanKmett there
01:35:03 <falconair> thanks
01:35:23 <edwardk> and i'm more than willing to raise the median IQ of my friends list by adding #haskell'ers ;)
01:39:25 <edwardk> wow conversation died.
01:39:41 * edwardk is a little hopped up on caffiene atm.
01:40:01 <dons> ?yow!
01:40:01 <lambdabot> I selected E5 ... but I didn't hear "Sam the Sham and the Pharoahs"!
01:40:48 <edwardk> so where did the yow quotes come from?
01:40:55 <dons> emacs
01:41:09 <edwardk> oh yeah =)
01:41:12 <dons> (or the fortunes file, whichever came first)
01:43:01 <edwardk> a lot of those are getting pretty dated =)
01:43:19 <dons> ?brain --more gen Y for you?
01:43:19 <lambdabot> Umm, I think so, Brain, but what if the chicken won't wear the nylons?
01:43:29 <edwardk> heh
01:45:30 <edwardk> so do you just load all of this cruft into memory with lambdabot or does it pull from disk?
01:45:52 <dons> from disk
01:45:57 <edwardk> ah good =)
01:46:06 <dons> but yeah, it gets sucked in on demand
01:46:27 <dons> it might be better to leave some things all on disk
01:46:37 <dons> there's even a couple of plugins, i.e. vixen that have the data _compiled_ in
01:46:43 <dons> ah well
01:47:03 <edwardk> yeah thats kinda what i thought might be going on
01:47:36 <dons> though doesn't hurt too much using ByteStrings, 17M   17M sleep    poll     0:02  0.00% lambdabot
01:47:59 <dons> which is ok for a 100-plugin, 15k loc app I reckon
01:51:09 <edwardk> true
01:51:19 <xerox> ?yow!
01:51:20 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
01:51:42 <dons> I'd like to get BOAS quotes in
01:51:47 <edwardk> ?. elite yow!
01:51:47 <dons> ?googla BOASAS
01:51:47 <lambdabot> compose module failed: IRCRaised Parse error: "yow!"
01:51:50 <lambdabot> http://www.boasas.com/
01:51:51 <lambdabot> Title: [Boy on a Stick and Slither]
01:51:54 <xerox> dons: haha do it
01:52:04 <edwardk> aw.. . won't concatenate !'d function names?
01:52:13 <edwardk> @compose elite yow
01:52:13 <lambdabot> \/\/0R1D \/\/4R +HrEe (an bE A\/ErT3D by adhErEnC3 70 a $+RI(TlY enFoRc3D dREsz cOde!
01:52:46 * int-e proposes that the use of @elite be banned from this channel.
01:52:52 <edwardk> there, like @. elite photontorpedo the syntactic and semantic quality of that statement have achieved parity
01:53:02 <dons> a lot of typing...
01:55:37 <boegel> int-e: why's that?
01:55:39 <edwardk> hrmm. wonder what other chat filters could be inserted. @jive would be about as dated as the fortune file ;)
01:55:45 <int-e> boegel: it makes my head hurt.
01:56:07 <int-e> boegel: and I'm assuming I'm not alone with that.
01:56:08 <boegel> we banned @moo already, stop the censorship!
01:56:17 <boegel> int-e: then just don't read it?
01:56:20 <edwardk> @moo?
01:56:25 <astrolabe> Are there any haskell compilers that produce code for multi-core machines?
01:56:31 <int-e> I see it, I read it. Bad habit, I know.
01:56:39 <boegel> edwardk: @moo was cool, showing a cow with some message :)
01:56:43 <edwardk> hah
01:57:15 <JaffaCake> astrolabe: yes, GHC 6.6
01:57:20 <Adamant> @quote fear
01:57:21 <lambdabot> fear hasn't said anything memorable
01:57:27 <ValarQ> astrolabe: i got a multicore machine and ghc seems to generate executable code for my machine
01:57:33 <edwardk> @quote lambdabot
01:57:33 <lambdabot>   lambdabot hasn't said anything memorable
01:57:36 <edwardk> awww
01:57:38 <xerox> hehe
01:57:42 <xerox> That's a quote edwardk.
01:57:51 * xerox giggles
01:57:55 <edwardk> heh
01:58:04 <ValarQ> :)
01:58:04 <edwardk> i was just about to make it one ;)
01:58:14 <astrolabe> ValarQ: I mean parallelized code :)
01:58:24 <edwardk> astrolabe: well, look up DPH
01:58:33 <edwardk> astrolabe: not sure of its current status
01:58:40 <astrolabe> @where DPH
01:58:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/dph
01:58:47 <xerox> unsw.. :)
01:59:02 <edwardk> its down dons' way so he probably knows more about it than the rest of us mere mortals
01:59:09 <astrolabe> edwinb: thanks
01:59:13 <JaffaCake> astrolabe: GHC 6.6 can run code in parallel on a multicore
01:59:18 <astrolabe> er edwardk: thanks
01:59:24 <JaffaCake> it's almost released, too :)
01:59:24 <astrolabe> edwinb: unthanks
01:59:41 <astrolabe> JaffaCake: Cool!
01:59:55 <xerox> JaffaCake: hiya. I got caught in maths and didn't got time to finish the patch yesterday, sorry.
02:00:11 <JaffaCake> xerox: no problem
02:00:23 <lispy> ?tell dons i've fixed all the bugs i can find with @bf and optimized it about as well as i know how.  Let me know if you have any problems with it
02:00:23 <lambdabot> Consider it noted.
02:01:37 <boegel> ?tell Itkovian hiya, long time no see!
02:01:38 <lambdabot> Consider it noted.
02:01:47 <boegel> just a mind-fuck thingie for Itkovian :)
02:09:44 <lispy> ?tell dons one of your last 5 updates broke lambdabot on my machine: internal error: getMBlock: mmap: Invalid argument
02:09:45 <lambdabot> Consider it noted.
02:10:22 <eivuokko> lispy, That's ghc rts error.
02:10:39 <lispy> eivuokko: yeah, but it only happens when i get the latest patches from dons
02:10:52 * lispy is narrowingit down now
02:10:54 <eivuokko> How new ghc you got?  It happens to be very similar to bug JaffaCake is seeing on Windows...
02:11:16 <lispy> 6.4.2, debian amd64
02:11:54 <eivuokko> Ah, then probably unrelated to bug in ghc 6.5.
02:14:11 <nothingmuch> kowey: that's not accurate
02:14:24 <nothingmuch> i learned it over the course of a long while
02:14:34 <nothingmuch> initially hacking on simple pugs stuff
02:14:55 <nothingmuch> i think the first time i actually read/edited haskell was pugs' subroutine parameter binding stuff
02:15:01 <nothingmuch> that was weeks before the forth thing
02:15:08 <nothingmuch> the forth thing was to make sure i grokked monads
02:15:19 <kowey> oh... i was just paraphrasing hwn
02:15:30 <nothingmuch> hwn?
02:16:00 <kowey> http://sequence.complete.org/hwn?from=30
02:16:09 <nothingmuch> oh wow! i'm famous
02:18:03 <kzm> JaffaCake: is the output from GHC 6.4.1 and 6.4.2 incompatible?
02:18:38 <kzm> Potential incompatibility between versions is blocking backporting of 6.4.2 for Ubuntu Dapper.
02:19:11 <kzm> ..since it would mean updating all libraries as well.
02:21:24 <apfelmus> does somebody know of a layout engine written in haskell?
02:21:34 <kzm> (Or if anybody else knows - I'd like to know before responding to the backport rejection)
02:21:35 <lispy> what sort of layout engine?
02:21:52 <apfelmus> i mean some kind of layout combinators as wxHaskell provides
02:22:06 <apfelmus> but i'd like to have HTML output
02:23:02 <lispy> i don't know of anything like that :(
02:23:31 <apfelmus> lispy: :(
02:24:53 <apfelmus> with a layout engine, generating well layouted HTML from cgi scripts would be a breeze. no more <div> aligning and shadow <table>s
02:26:33 <lispy> ?tell dons your patch "add some more stuff to version control" is one that gives me the error about getMBlock: mmap, not sure why but maybe the update to State/seen is bad?
02:26:33 <lambdabot> Consider it noted.
02:27:21 <yip> apfelmus: have you seen
02:27:55 <xerox> Any cabal hacker around?
02:27:58 <apfelmus> yip: seen what?
02:28:23 <yip> apfelmus: http://www.cse.ogi.edu/~andy/html/intro.htm
02:28:24 <lambdabot> Title: Here are some notes on using the HTML libraries
02:31:40 <Lemmih> xerox: Kinda.
02:32:28 <apfelmus> yip: yeah, the table combinators are very nice, but not powerful enough. layout something like wikipedia is out of reach.
02:32:38 <apfelmus> s/layout/layouting
02:33:07 <bringert> apfelmus: isn't it better to output plain simple html and use CSS? I probably misunderstood what you want to do
02:38:54 <apfelmus> bringert: something like that. i would have to (1) write a template html page with all content areas (2) layout this page with CSS (different browsers produce different crap...) by iterating a test and write cycle (3) translate the HTML into haskell code
02:38:58 <apfelmus> now if i want to change some layout, i'm doomed to redo those steps. if steps (3) would become step (1') use the layout combinators to align content, then everything would be much nicer.
02:43:19 <apfelmus> the Text.Html table combinators are a good start, but tables are not general enough. imho they cannot produce a "3 against 2" layout. i mean that there is no table with two rows which are divided in 3 and 2 *equally spaced* columns respectively.
02:46:29 <apfelmus> i'm particulary unsure about the interface of a supposed to be combinator library, that is the box model behind. if someone knows where to steal this from, i'd be very happy.
02:48:06 <apfelmus> TeX is to much oriented towards typesetting consecutive lines. <table>s are not powerful enough.
02:50:46 <lightstep> apfelmus, why not use just css for layout?
02:51:11 <bringert> apfelmus: why don't you produce the HTML with the Haskell combinators in the first step, and the tweak the Haskell and CSS until you get it right?
02:51:45 <bringert> there are some CSS combinators too
02:52:25 <apfelmus> lightstep, bringert: tiresome test cycle. and i'm quite sure i have to change the layout multiple times.
02:53:09 <bringert> so what you want is something where you can write declarative layout code in haskell, and have the library generate html + css?
02:53:25 <lightstep> even better: use multiple style links in the head, and allow the user to pick the best
02:53:45 <apfelmus> bringert: exactly.
02:54:13 <bringert> apfelmus, there is no such beast that I know of, but it would be great to have one, built on to of Text.XHtml and the CSS combinators
02:54:34 <bringert> and it could hide all the nasty browser hacks
02:54:57 <apfelmus> bringert: indeed.
02:55:00 <gour> @where hope
02:55:00 <lambdabot> http://hope.bringert.net/
02:55:29 <bringert> some of our students wanted to do that, but didn't have time. the made the CSS combinators and some other cool stuff
02:56:19 <bringert> apfelmus, maybe there are good box model APIs in other languages GUI libraries
02:56:24 <apfelmus> my main concern is a suitable box model. writing a html+css backend is not that much of a problem.
02:56:39 <bringert> yeah
02:57:08 <bringert> there must be good APIs out there
02:57:13 <apfelmus> bringert: CSS combinators? where?
02:57:40 <apfelmus> bringert: though i doubt there are good APIs for imperative languages ...
02:58:15 <bringert> I think Java's box model is not that imperative
02:58:21 <bringert> though I haven't used it much
02:58:32 <bringert> eh, by Java I meant Swing
02:58:35 <bringert> try http://csmisc14.cs.chalmers.se/haskellwebapps/darcs/css-base/
02:58:39 <lambdabot> Title: Index of /haskellwebapps/darcs/css-base, http://tinyurl.com/r8kh3
02:59:50 <bringert> magagr, moonlite: is that correct?
03:00:41 <bringert> I'm not sure that that's the right repo
03:00:55 <gour> is there any application written with WASH?
03:02:13 <bringert> gour: I haven't seen any larger ones, but there probably are some
03:02:28 <gour> bringert: some python folks ask me about it
03:03:07 <gour> bringert: what is, btw, the future if hajax?
03:04:17 <xerox> Your last sentence looks like perl :P
03:04:39 <bringert> gour: I don't know, I haven't been involded in that
03:05:56 <gour> xerox: ahh; i swear i'm not perl hacker :-)
03:06:39 <apfelmus> bringert: thx. though, as far as i see, the CSS combinators are just for appending CSS entries together (like \x y -> [(x,y)] and ++ for an association list [(Name,Value)])
03:09:02 <bringert> apfelmus: yes, I think it's fairly low-level. For a description, see http://www.cs.chalmers.se/~d00nibro/hsp/thesis.pdf
03:09:09 <bringert> around page 60
03:31:57 <Lemmih> bringert: Do you have a version of haskell-fastcgi for ghc-6.6?
03:32:46 <yip> Lemmih: hi! i'm installing ghc 6.5 now and i'm gonna try out hIDE
03:33:04 <gour> yip: there is something new?
03:33:37 <bringert> Lemmih: no, but I think the only change needed is one import
03:35:05 <yip> gour: i haven't tried hIDE yet
03:35:12 <Lemmih> yip: Hide is currently in the stage between a larva and a butterfly. It's a bunch of unconnected pieces waiting to be re-assembled.
03:35:16 <gour> yip: ahh, ok
03:35:30 <yip> Lemmih: but is it usable?
03:35:40 <gour> Lemmih: does larva mediates to become a butterfly?
03:35:51 <gour> s/mediates/meditates
03:36:14 <Lemmih> yip: I'm not even sure it's compilable.
03:37:09 <yip> Lemmih: but will i be able to understand the source?
03:37:38 <ValarQ> @where hIDE
03:37:38 <lambdabot> http://haskell.org/haskellwiki/HIDE
03:38:58 <Lemmih> yip: There isn't much to understand.
03:44:49 <llama32> is there any reason Haskell would not be suitable for writing an entire desktop environment & application framework? i'm sure it'll never end up happening, but i've been thinking a lot about doing a windowing system, widget toolkit, file manager, etc. for a while in either D, scheme, obj-c or [compiled] java, but none are quite ideal [respectively: lack of support, speed, crapiness, crapiness]
03:46:44 <SamB> would you believe it wasn't ready?
03:47:16 <SamB> you could write a bunch of apps in it, I suppose, but I would hold off on trying to write a GUI framework in it...
03:47:21 <Pupeno> llama32: I've been thinking of doing it as well, except that currently I am trying in Python. Since I want a document oriented desktop, object orientation seemed to be usefull. Nevertheless, I've starting reading about Fruit for a pure-Haskell-Gui.
03:47:35 <SamB> thats just me, though
03:48:20 <SamB> there are a few GUI toolkits written in Haskell, though...
03:48:32 <SamB> Fruit huh?
03:48:37 <johnnowak> we don't need another windowing system and widget toolkit. write me something fun.
03:48:37 <SamB> @where Fruit
03:48:38 <lambdabot> I know nothing about fruit.
03:48:51 <SamB> johnnowak: amen!
03:49:10 <Pupeno> anyway, I believe no mono-language environment really stands a chance against a multi-language environment no matter how bad it is.
03:49:18 <Pupeno> @where wxFruit
03:49:18 <lambdabot> I know nothing about wxfruit.
03:49:21 <Pupeno> oops.
03:49:38 <llama32> Pupeno: i'm very interested in document oriented stuff too, but i find OO doesn't apply anywhere [hence labeling java as too "crappy"], and i'd like to check out prototype-based OO for GUI elements, so scheme's ability to define your own OO is rather interesting
03:49:46 <SamB> pagefault in ZSNES thinks it might be nice if there was some kind of standard X menubar in X, but I think it wouldn't look right...
03:50:06 <Pupeno> wxFruit is at http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
03:50:09 <lambdabot> Title: wxFruit, http://tinyurl.com/g8y4e
03:50:15 <SamB> I think OO applies fairly well to widgets
03:50:35 <SamB> and Haskell can fairly easily model the OO in *external* widget libraries
03:51:14 <SamB> I'd love to see how you do that sort of thing in Haskell, if you can, but I'm doubting if it would really work...
03:52:19 <Pupeno> SamB: me too, that's why I was interested in Fruit.
03:52:48 <yip> llama32: i have thought a lot about such a project
03:53:40 <Pupeno> yip: any enlightening conclutions ?
03:54:54 <yip> Pupeno: it's an excellent idea. a fruit-like system for the gui seems to be the best option. the only potential problem i see is performance, but this is a general problem of haskell
03:54:58 <SamB> oh, I should try to reimplement Self again soonish...
03:55:13 <yip> Pupeno: i think that some sort of experimental implementation could be done right now though, and i think it could be really cool
03:55:55 * llama32 would like to have something like a combination of RISCOS [never actually used it, but judging by Rox Filer, it seems very user-friendly and clean], MacOSX [in terms of smooth effects and application consistency] and KDE [lots of cool stuff available via file manager, also general usability]
03:56:25 <yip> the system i am thinking of would definetely not be file/file-system based
03:56:29 <yip> anyway, gtg! bbiab
03:56:55 <SamB> but notice how wxFruit still uses wxWidgets, so it doesn't us full bragging rights
03:57:06 <SamB> er, doesn't give us full bragging rights
03:58:11 <llama32> i probably won't end up using Haskell for my thing... no language seems quite right... scheme would be great, but i can't find benchmarks for anything but Stalin [which is incredibly fast, but too rigid for a desktop environment]
03:58:55 <SamB> Stalin would be rigid, wouldn't it? I mean, just from the name you can tell...
04:00:39 <llama32> also i doubt anything but C/C++/obj-c or possibly Java would get taken seriously by a large enough community
04:01:18 <kowey> llama32: a large enough community to find co-hackers?
04:01:41 <SamB> I would avoid using the JVM
04:02:00 <llama32> yeah, definitely GCJ - JVM would be a real bitch for running like 20 apps at once
04:02:51 <SamB> you'd think the JIT would be good for something, but I suppose with memory bandwidth the way it is, that might not work so well...
04:02:53 <llama32> kowey: im sure i could find a couple of people interested enough to help out in Scheme or D, but i doubt it could take off like KDE/Gnome without a much more well known language like C
04:03:24 <kowey> llama32: maybe this is relevant then, droundy's experiences using haskell for darcs - http://darcs.net/cufp_2005.pdf
04:04:40 <llama32> my main problem with Java is that i don't get it at all. i mean smalltalk is 100% OO too and i can work in it, but with java i try to do something and just end up writing a purely procedural program jammed into a class
04:05:43 <SamB> the problem may be that Java isn't dynamically typed
04:06:17 <SamB> or it may be something entirely other
04:06:23 <SamB> I dunno...
04:06:47 <llama32> i like the idea of optional typing, but yeah it gets a tad annoying... i really don't understand why i am so bad with java
04:06:52 * johnnowak 's window manager is 1950 lines of C. You don't need 20 people to write a decent piece of software when it comes to user interfaces.
04:07:23 <SamB> you just need some people that actually know how to do UIs...
04:07:26 <johnnowak> I'd adore a tiny SchemeUI. :)
04:07:28 <llama32> johnowak's window manager probably doesn't replace X and a toolkit, but only complements them
04:07:29 <dbremner> llama32 - you could always start with scwm and see where you go from there.
04:07:31 <johnnowak> SamB: yes, that's the hard part.
04:07:45 <johnnowak> llama32: Don't replace X then. :)
04:08:37 <johnnowak> or just do write me a new file manager for OS X so I can ditch the finder. that'll work too. :)
04:08:43 <SamB> WMs typically don't use a full GUI toolkit...
04:09:02 <johnnowak> SamB: you'd hope not.
04:09:05 <bringert> Lemmih: I made a new fastcgi release which should work with GHC 6.6. Yo will need to remove the fps dependency from the cabal-file though
04:09:18 <SamB> johnnowak: yeah
04:09:30 <llama32> i don't so much mind X, but i don't like any available toolkits, and i feel that learning X11 would be harder than writing a Quartz-like windowing system myself, plus i'd get the benefit of understanding it better and having it integrate better, plus maybe some extra eye-candy
04:09:36 <SamB> johnnowak: it would have to be one heck of a toolkit to be any good for a WM anyway
04:10:39 <SamB> llama32: this is going to piggyback on X and GL?
04:12:52 <llama32> SamB: not GL [i wouldn't be able to test it really... with my unsupported onboard graphics]... i'll start off using SDL [testing it on X], and hopefully keep it small enough so i can do a clean implementation on top of linux framebuffer
04:13:06 <SamB> uh...
04:13:10 <Pupeno> SamB: wxFruit is a re-make of Fruit, which was pure Haskell.
04:13:19 <Pupeno> llama32: I have some different ideas.
04:13:23 <SamB> you really shouldn't try to do something like quartz without 3D
04:13:38 <Pupeno> lambdabot: help
04:13:55 <Pupeno> how do you tell lambdabot to remember the location of something ?
04:14:46 <SamB> the @where+ command
04:14:58 <SamB> @help where+
04:14:58 <lambdabot> where+ <key> <elem>. Define an association
04:16:59 <Pupeno> @where+ wxFruit http://zoo.cs.yale.edu/classes/cs490/03-04b/bartholomew.robinson/
04:17:00 <lambdabot> Done.
04:17:16 <Pupeno> @where Fruit http://haskell.org/fruit/
04:17:16 <lambdabot> I know nothing about fruit.
04:17:21 <Pupeno> @where+ Fruit http://haskell.org/fruit/
04:17:21 <lambdabot> Done.
04:17:49 <Pupeno> @help what
04:17:50 <lambdabot> what <key>. Return element associated with key
04:17:54 <Pupeno> @help what+
04:17:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:20:39 <int-e> @help why
04:20:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:41:22 <qwr> !learn plt scheme = Windowsi jaoks on PLT päris hea
04:41:40 <qwr> sorry, wrong channel
04:45:49 <sieni> sounds estonian ^_^
04:46:16 <qwr> yes, it was ;)
05:22:25 <musasabi> Should the bugs in GHC 6.6 RC be tagged in a special way?
05:36:11 <Igloo> There should probably be a version number for it
05:37:08 <Igloo> Hmm, but it's something of a moving target
05:37:08 <araujo> morning!
05:37:37 <musasabi> mmh. I reported on 6.5. (#886)
05:38:23 <Igloo> That's probably best
05:38:41 <musasabi> *884
05:51:03 <xerox> @slap paolino
05:51:03 <lambdabot> why on earth would I slap paolino
05:51:46 * paolino slap lambdadot
06:06:59 <araujo> @yarr!
06:07:00 <lambdabot> Yeh scurvy dog...
06:34:26 <musasabi> Igloo: would it be possible to provide an empty package called fps with GHC 6.6 ?
06:35:06 <boegel> @slap xerox
06:35:07 * lambdabot slaps xerox
06:35:14 <boegel> just for the fun of it :)
06:35:21 <boegel> @quote shapr
06:35:22 <lambdabot>  I am hexed and vexed ;-)
06:35:24 <boegel> @seen shapr
06:35:25 <lambdabot> I haven't seen shapr.
06:35:33 <boegel> dude, that's scary !
06:43:58 <Cale> hehe
06:44:19 <Cale> > can you please say in 2 words - what is the current state of this?
06:44:19 <Cale> "not" "yet"
06:44:19 <Cale> (well that was about all I could say in 2 words :-).
06:44:19 <lambdabot>  Parse error
06:44:42 <Cale> (Simon Marlow, responding to Bulat)
06:45:53 <Philippa_> heh
06:46:05 <Philippa_> what was the "this"?
06:46:34 <Cale> http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
06:47:44 <Cale> this is the exceptions thread on Haskell-prime
06:48:33 <CosmicRay> Igloo: ping
06:49:32 <Philippa_> I'm generally in favour, but doing it right gets complicated
06:49:55 <Philippa_> not least because every time I look at it I end up wanting something resembling a subtyping relationship
06:50:19 <Philippa_> which okay, we'll probably end up encoding another way, but hey
06:51:02 <Igloo> CosmicRay: pong
06:51:11 <Cale> Looks like existentials are a fairly reasonable way to go
06:51:24 <Philippa_> for most stuff, yeah
06:51:37 <CosmicRay> Igloo: your patch didn't fix the problem, unfortunately
06:51:38 <Igloo> musasabi: We think that's a pretty ugly hack to put in ghc itself, but you can of course distribute such a library yourself
06:51:46 <Igloo> Bah
06:51:48 <Philippa_> really we can't look at it any further than that without also looking at a redone record system
06:52:00 <Philippa_> which is way out of scope at the moment
06:52:04 <CosmicRay> however the error message is slightly different
06:52:08 <CosmicRay> ghc-6.4.2: /home/jgoerzen/t/ghc6-6.4.2/ghc/driver/package.conf.inplace:1:1:
06:52:09 <CosmicRay>     lexical error
06:52:24 <CosmicRay> note that it's now complaining about the first character on that line, instead of something farther down
06:52:43 <CosmicRay> err actually, never mind, it was doing that all along on stable.
06:52:55 <CosmicRay> so it's still behaving in the same way.
07:12:19 <musasabi> Igloo: yes, distributing something like that seems like the easiest solution (don't want to have multiple .cabal files)
07:14:22 <yip> what is ghc 6.6 RC?
07:14:41 <yip> llama32: why do you think haskell would not be appropriate for your project?
07:16:02 <llama32> yip: well i'm not very familiar with haskell
07:16:12 <llama32> yip: not familiar with it at all actually...
07:19:23 <yip> llama32: i guess that could be a problem :P
07:39:30 <ricky_clarkson> @where yaht
07:39:30 <lambdabot> http://www.cs.utah.edu/~hal/htut/
07:40:04 <ricky_clarkson> I thought yaht's link was fixed yesterday.
07:41:40 <ricky_clarkson> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf if anyone wants to fix it better.
07:44:46 <ihope> @help where
07:44:46 <lambdabot> where <key>. Return element associated with key
07:44:52 <ihope> Mmh.
07:44:59 <ihope> @help where-add
07:44:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:45:07 <timbod> I'm attempting to build ghc for the first time, but get a failure very early in the process. Anyone about who can answer a question?
07:45:20 <psnl> whats your error?
07:45:29 <xerox> @where+ yaht http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
07:45:40 <xerox> @where yaht
07:45:53 <psnl> timbod: do you have a working ghc on the box already?
07:45:57 <xerox> @bot
07:46:10 <ricky_clarkson> > 5/3
07:46:15 <timbod> configure works ok, then almost the first thing after "make":
07:46:20 <timbod> Cabal/Distribution
07:46:20 <xerox> zZzZ
07:46:26 <lambdabot> Done.
07:46:28 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
07:46:32 <lambdabot> :)
07:46:36 <lambdabot>  1.6666666666666667
07:46:39 <timbod> sorry: Distribution/Compat/FilePath.hs:2: error: Cabal/Distribution/Compat/FilePath.hs: No such file or directory
07:46:40 <xerox> yee.
07:46:42 <ricky_clarkson> Why does it smile?
07:46:47 <ihope> @bot
07:46:48 <xerox> @botsnack
07:46:48 <lambdabot> :)
07:46:48 <lambdabot> :)
07:46:51 <psnl> timbod: is the file there?
07:46:52 <ricky_clarkson> Ah.
07:46:56 <mnislaih> timbod: did you do ./darcs-all get ?
07:47:01 <timbod> psnl: yes, I have 6.4.2 running fine
07:47:06 <ihope> Methinks @list should be threaded and stuff.
07:47:21 <timbod> mnislaih: yes
07:47:29 <psnl> timbod: what are you upgrading to? last time I looked 6.4.2 was as good as it got
07:48:06 <timbod> psnl: wanting to play with the almost 6.6 release candidate
07:48:40 <mnislaih> timbod: check if you have a libraries/Cabal dir
07:49:54 <timbod> mnislaih: yes, but it's empty???
07:50:18 <mnislaih> something went wrong with your "darcs-all get", try to do it again
07:50:54 <jak> Hi. If I gave you the list generated by [(i * 102797) `mod` 1500 | i <- [1..1500]], do you think it would be easy to guess the code that generated it?
07:51:31 <timbod> I'll do that, curiously the Cabal directory has a _darcs subdir, and I can do a "darcs changes" in it, but there's no working visible copy...
07:51:38 <integral> > 102797 `mod` 1500
07:51:39 <lambdabot>  797
07:52:26 <jak> (102797 is a prime)
07:52:50 <jak> but I was just wondering how hard, given a sequence of 1500 numbers generated in this fashion it would be to guess the prime that generated it
07:53:00 <jak> probably not that hard if you knew the algorithm
07:53:05 <jak> just search up the primes, I suppose
07:53:19 <xerox> So you need a BIG prime :D
07:53:23 <jak> lol
07:53:24 <xerox> dcoutts__: !!!
07:53:42 <dcoutts__> @yarr!
07:53:42 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
07:53:52 <xerox> Hi D. ! How's life ?
07:54:02 <xerox> .se I see!
07:55:03 <dcoutts__> yep
07:55:03 <dcoutts__> finally got wifi working
07:55:03 <dcoutts__> ugg
07:55:16 <xerox> Cool.
07:55:23 <xerox> What do you these days
07:55:52 <timbod> mnislaih: thanks, the darcs get of Cabal only had failed with a network error. It's building as I write.
07:55:54 <sris> could some one give me a tip of a good ide/editor for Haskell-programming?
07:56:06 <xerox> sris: emacs works for the most
07:56:11 <timbod> sris: on what platform
07:56:15 <sris> linux
07:56:27 <sris> and and windows ;)
07:57:03 <timbod> sris: don't think you've got much choice with linux - (x)emacs + haskell mode + ghc/ghci
07:57:11 <vincenz> vim
07:57:23 <timbod> It's not much of an IDE if you are coming from a windows world, however
07:58:00 <sris> i like emacs, just not that good at it, i haven figured out how to "add" extensions like that yet ;)
07:58:09 <dylan> unix is an IDE.
07:58:13 <vincenz> and don't forget lambdabot!
07:58:15 <timbod> yep, or vi(m) if you prefer of course
07:58:18 <vincenz> @type ap
07:58:19 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
07:58:22 <vincenz> @hoogle return
07:58:23 <lambdabot> Prelude.return :: Monad m => a -> m a
07:58:23 <lambdabot> Control.Arrow.returnA :: Arrow a => a b b
07:58:23 <lambdabot> Language.Haskell.TH.Syntax.returnQ :: a -> Q a
07:58:31 <vincenz> @pl \x -> f x x
07:58:32 <lambdabot> join f
08:00:41 <cjeris> jak: the obvious regularity in all sequences of that form (kp mod m | k <- [1,...]) is that the difference between one entry and the next is always either p mod m, or (p mod m) - m.  that, combined with the fact that all entries lie in [0..m), might lead an adversary to guess that it's an arithmetic sequence mod some number, and then m is clear, and then you have p mod m, if not p.
08:04:04 <jak> cjeris, thanks
08:12:15 * ihope feels an odd urge to say "join id"
08:14:32 <vincenz> > join id const
08:14:33 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> a1
08:14:33 <lambdabot>    Expe...
08:14:37 <vincenz> > join id
08:14:38 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> a1
08:14:38 <lambdabot>    Expe...
08:15:03 <vincenz> > join const
08:15:04 <lambdabot>  Add a type signature
08:15:33 <vincenz> join const is a nonpolymorphic id
08:15:37 <vincenz> > join const 1
08:15:38 <lambdabot>  1
08:18:21 <ValarQ> > join (flip const) 1
08:18:22 <lambdabot>  1
08:24:52 <jeroeng_> dblhelix: I'm trying to make a simple Vector-implementation in Haskell, can you check if I'm thinking in the right direction?
08:25:19 <vincenz> jeroeng_: one with iterators?
08:25:21 * vincenz made one like that
08:25:24 <timbod> @where paste
08:25:24 <lambdabot> http://paste.lisp.org/new/haskell
08:26:24 <lisppaste2> timbod pasted "ghc build error" at http://paste.lisp.org/display/25106
08:26:24 <jeroeng_> vincenz: should I paste the code there?
08:27:03 <vincenz> sure
08:27:08 <vincenz> well on an @paste
08:27:22 <lisppaste2> jeroenp pasted "Vector-thing" at http://paste.lisp.org/display/25107
08:27:39 <timbod> any suggestions on how/why there's no configure script in rts when doing an initial top level ghc make?
08:28:05 <arcatan> how do I find first occurence of character in a string?
08:28:52 <jeroeng_> arcatan: What would you like it to return?
08:29:15 <arcatan> position
08:29:17 <timbod> mnislaih: got a hint for me?
08:29:21 <ChilliX> List.findIndex
08:30:54 <arcatan> thank you
08:31:00 <jeroeng_> vincenz: Does it look good?
08:31:39 <vincenz> oh
08:31:41 <vincenz> that kind of vector
08:32:15 <jeroeng_> Sorry to disappoint ypu
08:32:27 <vincenz> looks good yeah
08:32:53 <lisppaste2> timbod annotated #25106 with "fixed (?)" at http://paste.lisp.org/display/25106#1
08:42:07 <dcoutts__> hia ChilliX, thanks for the advice on the paper, I've just got back and I'm just reviewing dons's changes now
08:42:42 <ChilliX> dcoutts: ok, great
08:44:02 <ndm> @pl func3 f l = l ++ map f l
08:44:03 <lambdabot> func3 = ap (++) . map
08:46:43 <ndm> @pl func3 l = l ++ tail l
08:46:44 <lambdabot> func3 = ap (++) tail
08:48:05 <ndm> @pl func2 f g l = filter f (map g l)
08:48:05 <lambdabot> func2 = (. map) . (.) . filter
08:49:41 <explicitjelly> @pl
08:49:42 <lambdabot> (line 1, column 1):
08:49:42 <lambdabot> unexpected end of input
08:49:42 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
08:49:52 <explicitjelly> @pl func3 f l = l ++ map f l
08:49:52 <lambdabot> func3 = ap (++) . map
08:50:10 <explicitjelly> hello, by the way :)
08:52:04 <ndm> hello
08:52:29 <ndm> were you just asking about pointfree stuff on the mailing list?
08:52:44 <explicitjelly> yes, that's me. so you're neil? thanks for your help!
08:53:00 <ndm> no problem, although its not really my help, its all the work of @pl!
08:53:07 <ndm> yep, i'm neil
08:53:20 <explicitjelly> nice thing, that @pl.
08:53:34 <ndm> lambdabot has many many goodies besides @pl
08:53:49 <explicitjelly> although that (. map) . (.) . filter bit is really giving me a headache ;)
08:53:58 <ndm> yeah, i don't have a clue what that means
08:54:17 <ndm> or the ap variant, i'm not entirely sure wehther the monad in ap is list or function
08:54:44 <explicitjelly> i'll check that out. i really want to know.
08:56:36 <explicitjelly> . (.) . is evil.
08:59:46 <ndm> @type . (.) .
08:59:51 <lambdabot> parse error on input `.'
09:00:06 <ndm> @type \x y -> x . (.) . y
09:00:08 <lambdabot> forall c b c1 a a1. (((a -> b) -> a -> c1) -> c) -> (a1 -> b -> c1) -> a1 -> c
09:00:39 <sjanssen> @. elite uptime
09:00:39 <lambdabot> Up7ime: 10 |-|OUR5, 1 /\/\INU73 4Nd 5 zECOnDs, LoNge5t Up7imE: 10 hoUrs, 1 mINU+E 4nd 5 53conD5
09:03:45 <apfelmus> @.elite elite
09:03:46 <lambdabot> ElITE
09:03:54 <apfelmus> @. elite elite
09:03:54 <lambdabot> say A9aiN?
09:04:01 <apfelmus> @. elite . elite elite
09:04:02 <lambdabot> $4y 4gAIn?
09:04:12 <apfelmus> @. elite . elite . elite . elite elite
09:04:13 <lambdabot> s4y 494in?
09:04:21 <apfelmus> i wonder if it converges
09:04:43 <ndm> @fixp elite
09:04:43 <lambdabot> Unknown command, try @list
09:05:58 <ValarQ> @. elite vixen hello
09:05:59 <lambdabot> hiY4
09:06:32 <ValarQ> @. elite vixen are you a haxx0r yet?
09:06:32 <lambdabot> Y3$, i aM
09:06:40 <ValarQ> :)
10:04:23 <CosmicRay> Igloo: ping?
10:05:02 <Igloo> CosmicRay: pong
10:05:11 <CosmicRay> Igloo: did you get the alpha stuff?
10:05:19 <CosmicRay> (the email I sent you)
10:05:26 <Igloo> Haven't looked at it yet
10:05:30 <CosmicRay> ok.
10:13:54 <esap> Is it possible to apply a functor to a hom-set?
10:16:29 <lispy> ?dict-all imobvious
10:16:29 <lambdabot> Unknown command, try @list
10:16:34 <lispy> ?dict imobvious
10:16:35 <lambdabot> Supported dictionary-lookup commands:
10:16:35 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
10:16:35 <lambdabot> Use "@dict-help [cmd...]" for more.
10:16:42 <lispy> ?all-dicts imobvious
10:16:43 <lambdabot> No match for "imobvious".
10:16:52 <lispy> that's what i thought...
10:17:55 <jeroeng_> When I have class C a b, and I want (a,a,a) be to an instance of C, how could I do that?
10:18:30 <ihope> jeroeng_: what's the class C?
10:18:48 <ihope> You probably want to make either C a (a,a,a) or C (a,a,a) a an instance of that class.
10:19:08 <jeroeng_> I tried that ihope
10:19:19 <ihope> What was the error?
10:19:24 <jeroeng_> Kind error: Expecting kind `* -> *', but `(a, a, a)' has kind `*'
10:19:39 <ihope> Well, what's the definition of C?
10:20:19 <jeroeng_> It's Vector in http://paste.lisp.org/display/25107
10:20:58 <dcoutts__> xerox: you had a Q that I didn't answer which I have now forgotten
10:21:06 <ihope> type Triple a = Triple a a a
10:21:13 <ihope> instance X Triple a where...
10:21:33 <ihope> Er, sorry. instance Vector a Triple where...
10:21:51 <ihope> ...No, instance Vector Triple a.
10:22:07 <ihope> Now, if I have an infinite list, and I use takeWhile to grab increasingly large portions of it, will GHC try to keep the increasingly large portions in memory?
10:24:55 <LordBrain> takeWhile is lazy.. so not unless you are actually requesting the elements of the list be evaluated
10:25:22 <ihope> Well, it's the Sieve of Eratosthenes.
10:25:57 <ihope> The list primes uses itself an infinite number of times, and it uses increasingly large portions of itself everytime it uses itself.
10:26:51 <LordBrain> hmm
10:27:19 <jeroeng_> ihope: it didn't work
10:28:30 <ihope> jeroeng_: what's the error?
10:29:30 <jeroeng_> If I write 'type Triple a = Triple a a a' I get a 'Cycle in type synonym declarations:' error
10:30:25 <ihope> Oh, sorry, I meant "data", not "type".
10:30:26 <jeroeng_> And when I write 'type Triple a = (,,) a a a' I get ' Type synonym `Triple' should have 1 argument, but has been given 0 In the instance declaration for `Vector Triple a''
10:31:10 <jeroeng_> But then, ihope, I'd get exactly what Vect3 gives me
10:31:29 <ihope> Isn't that what you want?
10:31:50 <jeroeng_> No :-)
10:33:47 <jeroeng_> Thanks for the advice though
10:42:42 <LordBrain> do the sockets in the network Module defualt to have the option SO_KEEPALIVE ?
10:42:53 <LordBrain> hmm
10:49:04 <jak> Hi, i'd like to make a program that takes an integer argument (to main), what's the easiest way to do that?
10:49:34 <heatsink> jak: read the argument with getArgs; then convert it to an integer with read
10:49:42 <jak> heatsink, thanks very much
10:52:28 <xerox> @arrrr
10:52:29 <lambdabot> Swab the deck!
10:52:49 <Daveman> xerox :D
10:53:05 <xerox> ãã¯ããDaveman.
10:54:10 <Daveman> :p
10:54:14 <Daveman> Yes, greetings :)
10:55:17 <xerox> How's code?
10:56:24 <Daveman> Good :D
10:58:25 <Daveman> xerox, trying to work past some bugs right now, and testing :)
10:58:42 <xerox> The funniest activities of a programming life.
10:59:03 <heatsink> @engrish
10:59:03 <lambdabot> Unknown command, try @list
10:59:16 <xerox> @franglish
10:59:16 <lambdabot> Unknown command, try @list
10:59:19 <ValarQ> @get-shapr
10:59:19 <lambdabot> shapr!!
10:59:28 <xerox> ValarQ - don't panic!
10:59:36 <Daveman> o.O
10:59:37 <ValarQ> @get-shapr-now!
10:59:38 <lambdabot> Unknown command, try @list
10:59:55 * ValarQ runs around in circles
11:11:59 <ihope>  @tell shapr GET YOUR LAZY *** IN HERE NOW YOU ****ING IDIOT!!!!!!!!!
11:12:01 <ihope> :-P
11:12:32 <ihope> !babel ja en ãã¯ãã
11:12:40 <ihope> @babel ja en ãã¯ãã
11:12:42 <lambdabot>  can't parse this language
11:12:50 <ihope> @babel jp en ãã¯ãã
11:12:51 <lambdabot> babel module failed: IRCRaised Error: Language jp not supported
11:13:27 <heatsink> it's a conjugation of "early"
11:14:20 <BCoppens> ãæ©ã: ãã¯ãã (int,n) (abbr) Good morning; Common
11:14:20 <heatsink> I think the root is 'hayai'
11:14:26 <BCoppens> yeah
11:14:58 <musasabi> dcoutts__: you might want to tag the c2hs repo at some time. (172 patches with --partial)
11:15:16 <musasabi> (or darcs optimize it if it is tagged)
11:15:18 <dcoutts__> musasabi: right'o
11:24:23 <musasabi> dcoutts__: you wouldn't have an idea why c2hs complains like this: http://youzen.b2.fi/~musasabi/p.txt ?
11:25:02 <dcoutts__> musasabi: not off the top of my head, no
11:25:49 <Daveman> :D
11:26:12 <musasabi> ok. I can live with "..., id `Ptr ()', ..." for the few affected functions.
11:27:24 <xerox> dcoutts__ - how's life in .se!
11:27:41 <dcoutts__> xerox: good so far :-)
11:27:49 <xerox> Yarrr!
11:27:52 <dcoutts__> @arr
11:27:53 <lambdabot> Aye Aye Cap'n
11:27:58 <xerox> Is it a vacation?
11:28:02 <dcoutts__> it was
11:28:08 <dcoutts__> now I'm working :-)
11:28:15 <xerox> ah-ha
11:28:19 <xerox> Hence on IRC....
11:28:25 <dcoutts__> hah hah
11:28:30 <dcoutts__> I just got back today from the artic circle
11:28:35 <dcoutts__> it was nice and warm
11:28:37 <xerox> Awesome!
11:28:58 <dcoutts__> yeah, it was great
11:29:16 <xerox> I gave up on url-named dir! yarr
11:29:23 <Daveman> yarr
11:29:50 <xerox> I cleaned the code too. I'm pretty satisfied by this patch so far.
11:29:54 <Igloo> dcoutts__: Is the right thing for http://hackage.haskell.org/trac/ghc/ticket/703 to make that .section appear in the .S files?
11:29:57 <lambdabot> Title: #703 (all binaries built by ghc have executable stacks) - GHC - Trac, http://tinyurl.com/krwcw
11:30:31 <xerox> Like Knuth, though, I've proved my code is correct via GHC, but haven't tested it yet :D
11:30:56 <dcoutts__> Igloo: yes, I think so. Do you think otherwise?
11:31:15 <dcoutts__> Igloo: we don't actually use executables stacks at all I think.
11:31:22 <Igloo> dcoutts__: I just wasn't sure as the Gentoo bug shows people using -Wa and -Wl optins instead
11:31:30 <dcoutts__> that's a hack
11:31:35 <Igloo> OK
11:31:37 <Igloo> Thanks
11:31:45 <dcoutts__> to override stuff when it's not done automagically
11:32:00 <dcoutts__> we currently use that hack in the gentoo ghc ebuild
11:32:40 <dcoutts__> it's not right to do it that way in case you link in some external .o file that really does need an executable stack
11:33:22 <dcoutts__> Igloo: the harder bit is making the splitter copy that bit into every split .s file if it occured in the input .s file
11:33:35 <Igloo> Ooops, alt-F4 is a silly key binding for "switch to VT 4" on Windows
11:33:46 <dcoutts__> heh
11:33:55 <dcoutts__> Igloo: I'm not sure yet if that line gets past the mangler
11:34:07 <dcoutts__> but that bit should be easy
11:34:24 <Igloo> dcoutts__: Yeah, I just didn't want to spend time on it if it was the wrong way to solve the problem  :-)
11:34:28 <dcoutts__> right
11:34:40 <dcoutts__> I think it's the "Right Thing"tm.
11:35:24 <ramserver> wow i jsut read about happs
11:35:30 <ramserver> holy cow itlooks powerful
11:35:48 <ramserver> does common lisp or scheme have any such thing?
11:41:00 <xerox> @karma+ ghc
11:41:00 <lambdabot> ghc's karma raised to 1.
11:41:03 <xerox> @karma+ Haskell
11:41:03 <lambdabot> Haskell's karma raised to 8.
11:41:05 <xerox> OK.
11:50:57 <tibbe> ?users
11:50:58 <lambdabot> Maximum users seen in #haskell: 211, currently: 203 (96.2%), active: 31 (14.7%)
11:54:24 <tibbe> @quote
11:54:25 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
11:54:59 <sjanssen> so, if hylo fusion can express both foldr and foldl, why doesn't GHC use it?
12:00:51 <emu> ramserver: about a million and a half such things, plus more interesting.  i'd kinda expect haskell to have a continuation based framework, which happs does not appear to be
12:00:55 <emu>  but i could be wrong
12:04:09 <wilx> Framework?
12:15:35 <Limbic_Region> salutations all.  I am trying to build pugs (http://pugscode.org) using the latest Win32 binary snapshot.  Unfortunately, some of the libs have been removed and there is no binary for the extralibs.  Could someone help me build the extralibs?
12:15:37 <lambdabot> Title: Pugs - pugscode
12:15:54 <Limbic_Region> specifically, the mtl library
12:16:04 <Limbic_Region> I have the latest ghc.exe and assume that's all that is needed
12:16:31 <Limbic_Region> but running nmake.exe or mingw32-make or the make that comes with msys all complain about missing .mk files
12:17:16 <Limbic_Region> anyone?
12:18:36 <musasabi> emu: continuations seem very cool until one starts thinking about reliabity.
12:18:54 <musasabi> *reliability
12:19:30 <emu> tell me all about it
12:20:21 <emu> i'm curious to hear how automatically maintained program state has issues with reliability
12:23:20 <musasabi> emu: when one has to version things (new code is loaded) having the user state as continiations (= code) can cause problematic issues.
12:24:20 <tibbe> emu: it could also be interesting if a new thread picks up the continuation each time
12:25:40 <emu> new code being loaded shouldn't cause an issue if there is some way to define behavior for this
12:26:38 <tibbe> emu, I guess the REST camp would argue that using continuation frameworks would be too stateful an approach
12:26:46 <tibbe> @google REST
12:26:49 <lambdabot> http://en.wikipedia.org/wiki/Representational_State_Transfer
12:27:31 <tibbe> I read an article about how very difficult it could be to write correct continuation based web apps, I don't have the link though :/
12:28:03 <emu> haskell seems like a good platform for being able to write correct continuation based web apps
12:28:12 <tibbe> but basically it talked about threading issues, "calls" not returning (i.e. rendering a page that the user doesn't click), etc
12:28:21 <musasabi> emu: the practical issue with GHC is that one cannot serialize continuations to disk at all. (but this is a limitation of GHC)
12:28:22 <tibbe> emu, certainly better than imperative ones
12:28:28 <emu> it's rather difficult to argue against it in a theoretical sense since it exists and works, and is used
12:29:22 <tibbe> emu, I must say I'm not to familiar with web sites running continuation based apps since I mostly used Rails. although since something is used doesn't neccesarly mean it's a good idea
12:29:29 <tibbe> s/to/too
12:29:38 <tibbe> s/used/use
12:29:40 <tibbe> argh
12:29:50 <emu> i'm coming from the perspective of someone who's written production web apps using continuation based frameworks like UCW
12:30:02 <tibbe> I've seen a bit of UCW
12:30:39 <musasabi> @google UCW
12:30:41 <lambdabot> http://www.undercoverwear.com.au/
12:30:41 <lambdabot> Title: UnderCover Wear Online Collection
12:30:44 <emu> lol
12:30:46 <tibbe> haha
12:30:51 <emu> http://common-lisp.net/project/ucw/
12:30:53 <tibbe> @google uncommon web
12:30:53 <lambdabot> Title: UnCommon Web
12:30:55 <lambdabot> http://common-lisp.net/project/ucw/
12:30:55 <lambdabot> Title: UnCommon Web
12:31:45 <tibbe> I've written production web apps in most frameworks and they all suck more or less
12:31:48 <musasabi> emu: how do they handle serialization?
12:32:36 <emu> serialization of what?
12:32:43 <musasabi> continuations?
12:33:13 <emu> maybe I don't understand the question, but I don't see the relevance
12:34:03 <musasabi> ok. When I want to upgrade the application (to new code with fixes) I need to save the sessions before reloading the code.
12:34:10 <musasabi> (so I don't lose them all)
12:34:22 <emu> this is an issue for haskell, but not common lisp
12:34:48 <emu> Common Lisp is specified to be able to handle application upgrades and compilation while running continuously
12:35:14 <emu> actually, I've been wondering how GHC handles that stuff
12:35:27 <musasabi> which is impossible with Haskell's view of functions as opaque things.
12:35:42 <emu> and with the type system's generativity
12:35:51 <emu> if I recall the terminology correctly
12:37:27 <musasabi> I think it could be done with making sessions suitable datatypes and using threads. But that seemed quite hacky if a stable system is wanted.
12:38:07 <sjanssen> dcoutts__: what do you think about porting Streams from ByteString to lists?
12:38:11 <emu> it seems to me that you could define some kind of transition from one development version to the next such that the compiler could analyse this automatically and incorporate the new changes safely
12:39:02 <dcoutts__> sjanssen: yep, should work easily. We say as much in our paper.
12:39:12 <sjanssen> I see
12:39:24 <dcoutts__> sjanssen: and it'd make fusing String<->ByteString trivial
12:39:34 <dcoutts__> but we can't yet effeciently fuse ++
12:39:59 <tibbe> emu, the points raised here might still be of some relevance to functional languages: http://www.interact-sw.co.uk/iangblog/2006/05/21/webcontinuations
12:40:01 <mahogny> VRML-loader for haskell anyone?
12:40:05 <sjanssen> but wouldn't producing a Step for each element you traverse be about as expensive as producing a cons cell?
12:40:21 <tibbe> emu, although it was a while since I read it so I'm not 100% sure if I agreed with the points raised or not
12:40:27 <dcoutts__> sjanssen: not sure I follow, are you talking about ++ ?
12:40:44 <sjanssen> dcoutts__: I'm talking about foldr/build vs. streams
12:40:55 <sjanssen> the whole point of list fusion is to get rid of the cons cells, right?
12:41:06 <dcoutts__> sjanssen: right
12:41:17 <dcoutts__> sjanssen: usually the Step construcors get eliminated
12:41:58 <sjanssen> I see, are the strictness annotations in that data type key to making that happen?
12:41:59 <dcoutts__> by careful coding of the stream producers/consumers/transformers and by ghc's amazing optimiser
12:42:09 <dcoutts__> not sure actually
12:42:29 <dcoutts__> it'd be interesting to try
12:43:02 <dcoutts__> if we could fuse ++ well then I'd say we should definately consider moving list fusion to streams
12:43:16 <dcoutts__> if only because it allows fusion over any sequence
12:43:25 <sjanssen> what is the problem with (++)?
12:43:45 <dcoutts__> try writing ++ in terms of fold and unfold.
12:44:04 <dcoutts__> it's quite possible
12:44:19 <dcoutts__> but you have to remember which state you're in
12:44:34 <dcoutts__> are you returning element from the first or second list
12:45:00 <dcoutts__> hmm, actually it's not quite like writing ++ in terms of fold and unfold. It's harder.
12:45:21 <dcoutts__> so you need a boolean state to tell you which one you're looking at
12:45:35 <emu> tibbe: I'm sorry, but this guy seems to base his objections on his inability to program in a language using full continuations
12:45:42 <dcoutts__> and that makes it slow, checking which state you're in each time round the loop
12:45:47 <emu> and to understand the full implications of this
12:47:05 <sjanssen> dcoutts__: maybe Step needs a new constructor: NextStream Stream
12:47:24 <dcoutts__> sjanssen: that's one possability, yes
12:47:28 <emu> he also seems to be coming from the Imperative world
12:47:32 <tibbe> emu, from what I remember his objection was that modelling user movement through continuations didn't match the way users moved through web sites
12:47:34 <heatsink> dcoutts, would it be feasible to move the boolean decision out of the loop by duplicating the consumer of the (x ++ y) list?
12:47:56 <tibbe> emu, he's certainly talking about imperative programming
12:48:05 <emu> tibbe: his problem is that he thinks code execution is a linear thing
12:48:16 <emu> it's not, and continuations and backtracking are natural
12:48:18 <dcoutts__> sjanssen: there are some ways of pulling the decision out of the loop, but they require new compiler optimisations/transformations
12:48:32 <dcoutts__> heatsink: err I meant that to you
12:49:01 <emu> he has sufficiently convinced me that this style of web apps is not something to do in Java or C# though!
12:50:08 <heatsink> hmm, ok.  I should read up on the haskell loop fusion work sometime.  Is it 'hylo'?
12:50:48 <emu> if I had the time or inclination, I could write an article tearing this apart
12:50:54 <emu> too bad i'm a lazy bastard
12:51:24 <tibbe> emu, I still think the REST guys are mostly right though, use of state in web apps should be minimized and to me continuations looks to me to be the opposite approach
12:51:38 <tibbe> emu, I would read it
12:51:50 <emu> however it is possible, even in a continuation based app, to create REST-like stateless URLs
12:52:40 <emu> also if the REST folks really want to get worked up, they should take a gander at AJAX techniques
12:52:45 <tibbe> emu, the thing that's hard (not possible) in REST like apps is login and user interface customization
12:53:08 <tibbe> emu, AJAX isn't neccesarly in opposition to REST
12:53:33 <tibbe> emu, as long as the server returns representation those representation can surely use AJAX
12:54:02 <emu> it certainly complicates things more than having just a URL though
12:54:13 <tibbe> use, as long as what is sent from the client can be interpreted without knowing the state of the JavaScript things
12:55:02 <tibbe> emu, I've seen many Rails apps moving towards CRUD and I believe they're much better for it
12:56:27 <tibbe> I'm at the opposite end of the spectrum right now as I'm doing a stateful WS-* implementation for a company, it's much fun at all I must say
12:57:03 <Limbic_Region> ok - since the channel seems a little more busy, I will ask one more time - does anyone have any idea how I might build the extra-libs on Win32 using the lastest 6.6 RC snapshot?
12:57:14 <tibbe> I could be wrong though, I haven't played very much with continuation based frameworks
12:58:02 <heatsink> Limbic_Region, I don't know the windows distributions, sry
12:58:16 <Limbic_Region> no worries heatsink
12:58:50 <Limbic_Region> the issue is that the windows build is binary but there is no binary distro of the extra libs
12:59:16 <Limbic_Region> the instructions for inclusion and building of the extra libs for other platforms is just to untar them and the build will take care of it
12:59:46 <Limbic_Region> that won't work for Win32.  I assumed that since I had ghc.exe, all I would need to do is run make; make install in each lib dir
12:59:54 <Limbic_Region> but it complains about missing .mk files
13:00:10 <Limbic_Region> so since I don't even know how to spell haskell, I figured I would ask here
13:00:24 <Limbic_Region> unfortunately it appears everyone has a strong aversion to Win32
13:01:16 <Limbic_Region> and while I prefer *nix machines myself, I don't have much of a choice on my $work machine
13:01:29 <Limbic_Region> well - happy weekend anyway, I am headed home
13:05:41 <LordBrain> maybe he needed autoconf or something?
13:06:35 <musasabi> Was there any way to get at #defined things from a C2HS wrapper?
13:07:35 <stepcut> Lemmih: I see you had a patch 'fixing' HAppS to not depend on breakFirst. But the patch was then reverted. Is that because it did not work ?
13:08:18 <Lemmih> I don't recall.
13:08:20 <dcoutts__> heatsink: hylo fusion is quite nice, basically the same as fold/unfold fusion and again closely related to stream fusion
13:08:26 <musasabi> stepcut: http://www.cs.helsinki.fi/u/ekarttun/haskell/happs-fps.patch is for recent happs
13:08:26 <stepcut> :)
13:08:42 <stepcut> musasabi: thanks!
13:08:55 <musasabi> I think it will probably get integrated when 6.6 is released.
13:09:20 <stepcut> cool
13:14:28 <vegai> is anyone thinking of writing a book on HAppS?
13:14:35 <stepcut> not yet
13:14:36 <vegai> or perhaps even writing one
13:26:55 <ndm> @seen dons
13:26:55 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 11 hours, 33 minutes and 35 seconds ago.
13:30:05 <ramserver> what is so good about continuations/
13:30:16 <ramserver> why are the fun to have in an appserver
13:30:19 <ramserver> ?
13:30:43 <ndm> ramserver: who said they were good to have in an app server?
13:31:10 <cm_> e.g. felleisen, for a suggestive definition of "app server"? ;)
13:31:45 <ndm> they are sometimes useful, but i rarely find my self programming with continuations
13:31:58 <ndm> they can be helpful for storing state in an intuative way on a client
13:33:14 <cm_> (not necessarily on the client, of course9
13:33:43 <ndm> true, but if its not on the client, and you have a web server, how long does a user session stay alive?
13:34:18 <ndm> (my suggestion, buy a bigger disk, and store them for 10 years)
13:34:18 <cm_> just define a timeout
13:34:28 <ndm> but thats the traditional reason for saying put the state on a client
13:34:51 <ndm> cm_: the national rail train site times sessinos out after 20 mins, i want to go kill their developers, one by one
13:34:57 <cm_> i think you should rather design your application that "expired" URLs still make sense
13:35:18 <cm_> instead of uploading your callstack onto the client :-)
13:36:09 <yip> hm... you either store the state on the client or you store it on the server and have it timeout. i don't see any option that could be "in between"
13:36:25 <cm_> yip, there is the option to store it on the server and don't have it timeout :)
13:36:28 <ndm> store it on the server forever
13:36:43 <cm_> yip, like amazon does for your shopping cart
13:36:49 <ndm> Google never times anything out, or throws anything away
13:37:24 <ramserver> oh
13:37:47 <cm_> I wouldn't want to persist continuations directly
13:37:55 <ndm> yeah, i don't like continuations
13:37:59 <xerox> eivuokko: ping
13:38:16 <ndm> they have some uses, but often, if you want continuations, you pick a higher abstraction, and then underneath the runtime uses continuations
13:38:20 <yip> yeah, well there's really no such thing as "forever"... only a really long timeout :)
13:38:25 <ndm> i.e. monads are continuations
13:38:27 <ramserver> so why would one prefer haskell to say clisp or smalltalk?
13:38:28 <cm_> ndm, yup
13:38:33 <ramserver> is it fun to program in haskell?
13:38:44 <mahogny> ramserver, yes, fun. and safer than lisp
13:38:47 <ndm> ramserver: yes! static typing, fun community, nice people, better language
13:39:01 <ramserver> how about the ability to add features to the language
13:39:07 <cm_> yip, forever as in "until the Google booble crashes" (hopefully never ;)
13:39:08 <ramserver> lisp claims to be able to do that
13:39:25 <ndm> define what you mean as a "feature"
13:39:30 <ndm> if lisp is meaning macros
13:39:35 <ramserver> well i was asking on lisp google group
13:39:46 <ndm> then Haskell obliviates that pretty much, by having laziness and higher order
13:39:56 <ramserver> and they said basically any feature of another language can be put into lisp
13:40:05 <ndm> I learnt lisp first, haskell second, i picked haskell
13:40:06 <ramserver> so u cna have whateer u want
13:40:08 <ndm> typing?
13:40:26 <ndm> a (syntax (that doesnt) (require) (lots of (brackets)))
13:40:34 <ramserver> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
13:40:36 <ramserver> heh
13:40:39 <ramserver> direct wuote
13:40:41 <mauke_> ndm: you can do that, you just have to write a parser for it
13:40:42 <ramserver> quote
13:40:46 <ndm> Paul Graham is wrong
13:40:51 * vegai gasps.
13:40:57 <lucca> ramserver: use each tool for where it is appropriate
13:41:04 <ndm> its quite obvious when you read his writings
13:41:14 <ramserver> ok
13:41:25 <lucca> if you think rapidly in lisp, use lisp for rapid prototyping.  Haskell's type system will generally result in safer production code, however.
13:41:26 <ramserver> what is the best way to learn haskell and programming
13:41:39 <ndm> he says you should always use a programming language at the top of the tree, and everyone says that you just "wouldn't need" anything more powerful
13:41:40 <cm_> and note that "where it is appropriate" includes yourself (e.g. wrt your "way of thinking/programming" (which isn't fixed either, ofc))
13:41:42 <ramserver> Im really only a bash person and even then Im tin
13:41:45 <ramserver> thin
13:41:55 <ndm> he uses lisp, and says, exactly as he says he would, that he doesn't want lazy or types
13:42:10 <vegai> I wonder if he uses any programming language these days
13:42:23 <ramserver> interesting
13:42:29 <cjeris> his "better lisp" ('Arc') has been moribund nearly 5 years
13:42:31 <ramserver> ok i have a win xp box
13:42:41 <ndm> ramserver: do you have WinHugs downloaded yet?
13:43:02 <ramserver> about to
13:43:12 <ramserver> does huge or ghc have more stuff?
13:43:18 <vegai> no silver bullets, just lot of wooden ones, some iron ones and few made out of steel
13:43:21 <ramserver> I think ghc has more stuff for it eh?
13:43:32 <vegai> actually, steel bullets should be better than silver bullets, no? ;P
13:43:39 <vegai> except in the case of werewolves
13:43:49 <cjeris> what approach would you take to embed an extension language in a large haskell program?
13:43:54 <ndm> ramserver: for learning, WinHugs is perfectly fine - i still use it now
13:44:13 <ndm> cjeris: read up on Lava, thats an example, where Haskell fits very neatly
13:44:16 <cjeris> i'm toying with the idea of writing a roguelike.  i'd like to do it in haskell, but i'd also like player and monster behavior to be extensible by the player to some extent.
13:44:30 <ndm> cjeris: or hs-plugins
13:45:14 <ramserver> do things like happs the haskell app server run on hugs?
13:45:22 <cjeris> ndm: can the latter approach work without the player needing a haskell compiler?
13:45:30 <ramserver> is ghc bad for learning?
13:45:56 <mauke_> I think ghc is fine for learning
13:45:57 <kosmikus> no
13:46:01 <ndm> ramserver: the bigger programs - darcs/ghc/haspps probably won't run on Hugs
13:46:09 <ndm> cjeris: no, requires a haskell compiler
13:46:23 <ndm> cjeris: requires GHC more specifically
13:47:10 <cjeris> i know lisp and haskell about the same degree (not that well - my best languages are ocaml and perl5) and the examples of emacs and langband made lisp attractive for this kind of project.
13:47:39 <cjeris> but, but, no type checking magic!  runtime bugs!
13:47:51 <cjeris> no learning about monadic toys!
13:48:11 <ndm> its realtively easy to ship GHCi with your stuff though
13:48:16 <ndm> ask dons for more details
13:48:29 <ndm> lambdabot even uses hs-plugins, so you can evaluate code at runtime
13:48:38 <ndm> @eval reverse "clever lambdabot"
13:48:58 <ndm> @bot
13:48:59 <lambdabot> :)
13:49:04 <ndm> > reverse "clever lambdabot"
13:49:07 <lambdabot>  "tobadbmal revelc"
13:49:16 * heatsink has been wanting to do a roguelike.
13:49:45 <cjeris> i don't suppose anybody has a "baby lisp in haskell for extension" analogous to libguile for C?
13:49:49 <mauke_> @help eval
13:49:50 <lambdabot> eval. Do nothing (perversely)
13:50:07 <heatsink> not that I'm aware of.
13:51:08 <musasabi> ramserver: HAppS doesn't work with hugs. Too many advanced features. It uses e.g. GADTs and Template Haskell.
13:51:27 <cm_> what's HAppS, btw? :-)
13:51:31 <cm_> (can't google atm)
13:51:40 <ndm> ramserver: but Hugs is more than capable for developing most things
13:51:43 <cm_> arrow madness?
13:51:44 <ndm> @google happs haskell
13:51:45 <musasabi> cm_: haskell web application server thingy.
13:51:48 <lambdabot> http://happs.org/
13:51:48 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
13:51:52 <cm_> ah, okay
13:52:01 <cm_> is it cool? :-)
13:52:04 <ndm> cm_: you can always google when on IRC :)
13:52:11 <cm_> i see :>
13:53:18 <heatsink> cjeris: Haskell definitely has less strength in the scripting and dynamic loading arena.  I think hs-plugins is the only tool available for that.
13:54:10 <Philippa_> yeah, although for shell scripting style tasks it's not as bad as you'd think
13:54:16 <yip> heatsink: wrong, ghc-api is also available
13:54:51 <yip> heatsink: and it's better dynamic loading then you see in most other languages
13:55:13 <ramserver> so should I then use GHC from the get go?
13:55:24 <ramserver> is it hard to set up n ready my pc for programming?
13:55:32 <ramserver> do i ned other stuff?
13:56:29 <cjeris> ramserver: if haskell is your first functional language, you will need a bucket, for your head to explode into :D
13:56:42 <yip> i only briefly used hugs before moving to ghc
13:57:23 <yip> ghc has nice things like a built in make system, support for dozens of language extensions, and lots of libraries that come with it
13:57:42 <tibbe> what's the tool that helps you recompile stuff that depends on the kernel called?
13:57:55 <ramserver> no its my first language at all
13:57:56 <ramserver> :)
13:58:14 <ramserver> make?
13:58:16 <ramserver> gcc?
13:58:30 <tibbe> ooops, wrong chan, sorry
13:58:47 <tibbe> :p
13:59:01 <cjeris> ramserver: ok, maybe a big bucket.
13:59:19 <mauke> ramserver: a text editor, ghc
13:59:41 <heatsink> Preferably a text editor with syntax highlighting.
14:00:21 <tibbe> preferrably emacs
14:00:34 <mauke> vim!
14:00:38 <ValarQ> elvis!
14:00:39 <Pupeno_> kate!
14:00:40 <heatsink> oh no!
14:00:50 <heatsink> @yow
14:00:50 <lambdabot> Like I always say -- nothing can beat the BRATWURST here in DUSSELDORF!!
14:00:54 <tibbe> you're lost myc children
14:01:15 <tibbe> oh well, I need to reboot
14:01:17 <tibbe> :qwa
14:01:19 <tibbe> :qwd
14:01:21 <tibbe> :q!
14:01:24 <mauke> :xa
14:01:24 <tibbe> :q!!!!!!!"!11
14:01:28 <heatsink> C-x C-c
14:01:29 <tibbe> :qdanjdsaoinhdsaoihcsacas
14:01:31 <mauke> (actually works)
14:01:37 <ValarQ> :exec telinit 6
14:02:00 <cjeris> :!kill -9 -1
14:02:13 <cjeris> (or am i misremembering?)
14:02:21 <Igloo> CosmicRay: /query CosmicRay
14:02:23 <Igloo> Doh
14:03:00 <heatsink> cjeris: want to team up on the roguelike project?
14:04:10 <cjeris> heatsink: it really is "toying with" at this point.  i could get to it this month or next year.
14:04:17 <ValarQ> heatsink: what rougelike project?
14:04:49 <heatsink> There should be a roguelike engine written in haskell.  I'm pretty sure none exists.
14:05:14 <ValarQ> sounds like a lot of fun
14:05:16 <ValarQ> tibbe: wb
14:05:41 <tibbe> ValarQ: :D
14:06:00 <cjeris> heatsink: I had thought to start by wrapping Ben Harrison's z-term.c from Angband, since he dealt with a lot of the icky platform dependent issues already, and I really like Angband's multiple screen interface (although my favorite roguelike is Crawl, easily)
14:06:46 * Pupeno_ has quit his job... (under particular circumstances).
14:06:54 <Pupeno_> Now I can continue my study of Haskell.
14:07:10 <heatsink> yea, the window interface seems like the most appropriate place to start.
14:09:08 <heatsink> Pupeno_, particular circumstances?  Was it a conditional quit?
14:09:46 <Pupeno_> heatsink: I am living the country.
14:09:48 * heatsink downloads angband for research purposes
14:10:04 <heatsink> leaving?
14:10:13 <Pupeno_> yes, leaving.
14:10:39 <ValarQ> my favorite rouge-alike is ToME, to bad it doesn't work very well on my current arch :(
14:10:50 <cjeris> ValarQ: ?
14:11:13 <ValarQ> cjeris: yes?
14:11:21 <cjeris> what architecture?
14:11:29 <ValarQ> cjeris: amd64
14:12:01 * cjeris is totally ignorant of current developments in processors since he stopped building his own pcs
14:12:39 <ValarQ> cjeris: you can get software problems without building own PC computers
14:13:11 <tibbe> ValarQ: PC computer is a funny word ;)
14:13:17 <tibbe> or two rather
14:13:23 <tibbe> expression, whatever
14:13:38 <ValarQ> tibbe: im a funny guy :o)
14:13:40 <cjeris> ValarQ: i know -- it's just that there's the windows P4s we have at work, and the mac we have at home, and it's all so much simpler :)
14:14:01 <cjeris> except for windows sucking, but it will do that anywhere.
14:14:26 <ValarQ> cjeris: until on of your apps have some glitch on ppc (or whatever arch your macs uses)
14:15:43 <cjeris> ValarQ: i don't say it doesn't happen, but it hasn't happened to me.
14:20:53 <wilx> @index bounds
14:20:54 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff, Data.Array
14:25:09 <spiffy> D'oh
14:25:25 * spiffy forget to list least specific pattern last
14:25:54 <stepcut> heh
14:27:24 <spiffy> well, thats 5 minutes of my life i dont get back ;-)
14:27:36 <heatsink> heh
14:31:34 * heatsink goes home to eat and play angband.  But not eat angband.
14:41:45 <dcoutts__> hia SyntaxNinja
14:42:05 <dolio> ?type pair
14:42:07 <lambdabot> Not in scope: `pair'
14:45:39 <dolio> ?pl \f l -> l ++ map f l
14:45:40 <lambdabot> ap (++) . map
14:48:50 <araujo> hi hi
14:49:05 <SyntaxNinja> heya
14:50:47 <araujo> hello SyntaxNinja
14:51:10 * araujo wonders if anyone knows a website for blogs
14:51:25 <ndm> araujo: blogger.com ?
14:51:50 <araujo> ndm, something more haskellish :-P
14:52:03 <ndm> araujo: shapr uses Hope
14:52:03 <CosmicRay> araujo: sequence.complete.org
14:52:25 <araujo> ok, i check CosmicRay (hi!)
14:52:31 <CosmicRay> hello ;-)
14:52:31 <xerox> araujo: wordpress.com too
14:53:13 <ndm> araujo: use blogger.com, cause google will be redoing it soon, and then (without doubt) it will be the best one on the internet
14:54:06 <araujo> xerox, yeah, i have been looking at that one too
14:54:18 <SyntaxNinja> araujo: planet.haskell.org is the aggregation, get a blog on sequence, though!
14:54:40 <araujo> SyntaxNinja, yeah, sequence looks nice :-)
14:54:55 <SyntaxNinja> araujo: CosmicRay will hook you up ;)
14:55:44 <araujo> Thanks CosmicRay :-)
14:56:21 <CosmicRay> glad to help ;-)
14:56:37 <CosmicRay> actually you can just create a sequence account and then you can jump right in
14:56:40 <CosmicRay> no need to me to do anything
14:56:57 <CosmicRay> and with that, it's time for me to sign off
14:57:16 <araujo> haha, goodie
14:57:20 <ndm> @hoogle Int -> Char
14:57:21 <lambdabot> Char.chr :: Int -> Char
14:57:21 <lambdabot> Char.intToDigit :: Int -> Char
14:57:21 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
14:57:32 <ndm> > intToDigit 45
14:57:34 <lambdabot>  Exception: Char.intToDigit: not a digit 45
14:57:51 <eivuokko> xerox, pon
14:58:14 <xerox> eivuokko: Limbic_Region has a problem with the win32 build of GHC, mind to look at it?
14:58:30 <Limbic_Region> actually, I am building from source to get around it
14:58:32 <Limbic_Region> but yes
14:58:41 <Limbic_Region> the binary build of 6.6rc is b0rk
14:58:45 <eivuokko> o.O
14:58:52 <Limbic_Region> for 2 reasons I believe
14:59:19 <Limbic_Region> well - b0rk for 1 reason and inconvenient for another
14:59:21 <eivuokko> Sure.  I don't know if I can help, but I'd like to know of problems, atleast.
14:59:27 <Limbic_Region> ok - first the problem
14:59:44 <Limbic_Region> root_dir/include doesn't include the header files like in previous binary builds
14:59:54 <Limbic_Region> they are in root_dir/lib/$platform/include
15:00:23 <Limbic_Region> that caused several problems when trying to build happy and pugs
15:00:32 <Limbic_Region> but whatever - easy to just copy
15:00:47 <Limbic_Region> second issue is that the extralibs have no binary distro
15:00:59 <eivuokko> You mean gcc-lib/lib/include contents should be in include?
15:01:10 <Limbic_Region> so on Win32 it is seemingly impossible to get the extralibs without compiling from source
15:01:19 <Limbic_Region> no eivuokko
15:01:41 <eivuokko> I don't have root_dir/lib/$platform
15:01:53 <Limbic_Region> I mean the ghc header files that used to be in /include are actually in lib/i386-mingw-unknown/include
15:02:15 <Igloo> Limbic_Region: Which is b0rk and which is inconvenient?
15:02:24 <Limbic_Region> Igloo - the header files are b0rk
15:02:28 <eivuokko> Ok, let's s start again, is that mingw-distro location of ghc distro location?
15:02:34 <Limbic_Region> the inability to get the extralibs is the inconvenience
15:02:37 <carp_> how does one get on planet.haskell.org? is it invitation only?
15:02:51 <Limbic_Region> eivuokko - ok, let me start even further back than that
15:03:03 <carp_> i'm wondering if a couple of the nottingham blogs might be worthy things to be there
15:03:06 <Limbic_Region> the last binary distro that I was successfully able to download an use was from the 19th
15:03:13 <Limbic_Region> beyond that, ghc.exe was missing
15:03:23 <Limbic_Region> then on the 29th - it mysteriously came back
15:03:29 <xerox> dcoutts__: ping
15:03:36 <Limbic_Region> so I decide to try the current build - 6.6rc as of today
15:03:49 <Limbic_Region> when I tried to build pugs, it complained about header files missing
15:04:01 <Igloo> carp_: You probably want to e-mail the contact address (or suggest the bloggers do)
15:04:05 <eivuokko> (Builds were failing, probably, and distro was partial because of that)
15:04:12 <Limbic_Region> so when I went to look for the header files - they were in c:\ghc\lib\i386-mingw-unknown\include
15:04:23 <Limbic_Region> when I checked where they were on the snapshot from the 19th
15:04:29 <Limbic_Region> they were in c:\ghc\include
15:04:33 <eivuokko> Ok.
15:04:38 <ramserver> ok i got haskell installed ghc
15:04:41 <Limbic_Region> so I copied them (as a quick check)
15:04:41 <ramserver> woo hooooo
15:04:49 <ramserver> where are the labs or howtos?
15:04:50 <Limbic_Region> and pugs moved forward in the build
15:04:58 <Limbic_Region> next it was missing a library dependency
15:05:05 <Limbic_Region> that happened to be part of the extralibs
15:05:11 <Limbic_Region> unfortunately, the extralibs are source only
15:05:26 <Limbic_Region> so I figured I could just build them since I had mingw/msys/ghc
15:05:30 <Limbic_Region> couldn't get it to work
15:05:34 <eivuokko> Limbic_Region, The problems here are: It's sof at galois who controls the build.  Also diffnret mingw versions have radically diffrent locations for some of the libs.
15:05:37 <Limbic_Region> so I just decided to build from source
15:05:43 <eivuokko> Did you try using Cabal?
15:05:48 <carp_> Igloo: ok, thanks
15:05:54 <Limbic_Region> but these aren't mingw headers
15:06:06 <Limbic_Region> these are coming from the snapshot tarball
15:06:14 <eivuokko> Eh, then it's some quirk...can't see it in my local builds
15:06:34 <Limbic_Region> let me give you the exact link I downloaded from
15:07:30 <Limbic_Region> last known working binary snapshot (confirmed by myself and several others at #perl6) - http://www.haskell.org/ghc/dist/current/dist/ghc-6.5.20060819-i386-unknown-mingw32.tar.gz
15:07:42 <eivuokko> Igloo, Any idea about that?  Nightly builds put include dirs with mingw into wrong place...make install apparently doesn't.  Did someone add some special dirs lately?
15:07:45 <Limbic_Region> that includes the ghc.exe where as the ones following it up to the 29th did not
15:08:04 <Limbic_Region> http://www.haskell.org/ghc/dist/current/dist/ghc-6.5.20060901-i386-unknown-mingw32.tar.gz is today's snapshot
15:08:14 <Limbic_Region> untarring the two reveals the difference in the location of the header files
15:08:24 <Limbic_Region> the other difference is the extralibs
15:08:27 <Igloo> eivuokko: I don't remember seeing any commits talking about that
15:08:44 <Limbic_Region> ok - so with that explained, I am not even experienced enough with Haskell to be considered a neophyte
15:08:52 <Igloo> eivuokko: Should I be installing msys if I already have cygwin, BTW?
15:08:53 <Limbic_Region> so I don't know how to use Cabal to build the extralibs
15:09:28 <Igloo> Limbic_Region: FWIW I think we're hoping that an installer with the extralibs included will appear at some point
15:09:33 <Limbic_Region> oh, and is there a real reason why 6.6rc requires alex 2.0 and happy 1.15?
15:09:42 <eivuokko> Igloo, Unfortunately I know almost nothing of cygwin.  I'd say you don't.  You do need mingw, tho.
15:09:44 <Limbic_Region> I couldn't get binary versions of them for Win32 - so I just lied to configure
15:09:50 <Limbic_Region> and it still seems to be building ok
15:10:08 <Limbic_Region> Igloo - unless you have the Cygwin mingw package
15:10:11 <Limbic_Region> yes, you need to
15:10:25 <Limbic_Region> even if you have the Cygwin mingw package, you likely still want to
15:10:34 <Igloo> Limbic_Region: http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html has cabal building instructions (the 3 lines in example 5)
15:10:35 <Limbic_Region> because you don't want to accidently introduce a dependency on cygwin1.dll
15:10:36 <lambdabot> Title: 3. Building and installing a package, http://tinyurl.com/ox63q
15:10:37 <eivuokko> I don't think make install will work with cygwin mingw package easily.
15:10:49 <ndm> Igloo: Cygwin produced binaries tend to only run on Cygwin, mingw ones run on Windows
15:10:59 <Limbic_Region> eivuokko - neither do I based on my experience with other things
15:11:17 <Limbic_Region> thanks Igloo - will check that out if my source build fails
15:11:31 <Limbic_Region> so about the happy and alex version requirements - are they legit?
15:12:12 <eivuokko> Unicode handling might have changed.
15:12:14 <Limbic_Region> does this channel have a nopaste?
15:12:19 <Limbic_Region> k
15:12:22 <Limbic_Region> sounds reasonable
15:12:22 <xerox> @paste
15:12:23 <lambdabot> http://paste.lisp.org/new/haskell
15:12:39 <Limbic_Region> ok, will paste everything because I seem to be rambling
15:13:10 <ndm> @where paste
15:13:10 <lambdabot> http://paste.lisp.org/new/haskell
15:13:19 <Igloo> Limbic_Region: They probably are. Simon was saying he thought alex 2.0.1 was necessary, actually
15:13:19 <ndm> ah, someone fixed the paste command :)
15:13:41 * Igloo decides just to install everything in sight for now
15:13:53 <eivuokko> Thanks for telling about the header problem, there probably is easy fix.
15:15:00 <eivuokko> Maybe it wouldn't be bad to have another nightly build machine...I was hoping buildbot would make it easier...
15:15:07 <eivuokko> (Windows machine that is)
15:15:35 <Igloo> eivuokko: I'll be looking into setting that up soon
15:15:58 <eivuokko> I don't really understand why my mingw is so diffrent from Sof's.  My local bin dists are so diffrent from the nightly builds.
15:16:48 <eivuokko> Maybe using cygwin for sh has some quirks...
15:17:13 <lisppaste2> Limbic_Region pasted "Win32 Issues" at http://paste.lisp.org/display/25120
15:17:57 <eivuokko> Extra libs certainly won't be buildable with makefiles.
15:17:59 <Limbic_Region> ok - that explains everything as best as I can explain it
15:18:08 <Limbic_Region> I am willing to try anything to test
15:18:34 <eivuokko> The makefiles depend on ghc build system to be there, and configured.  And probably only easy way to get them to build is to have stage1 ghc.
15:18:40 <Limbic_Region> and thanks for taking the time to listen to someone who can't spell haskell
15:19:30 <Limbic_Region> it is on my list of things to torture myself with though ;-)
15:19:41 <eivuokko> No, thank you for bringing issues up. :)
15:20:13 <Limbic_Region> actually - I brought them up here when I first noticed the binary distros broke (19th)
15:20:36 <Limbic_Region> but I got silence because apparently most folks in here have a deep aversion to Win32
15:20:41 <eivuokko> Probably nobody cared because nightly builds just were failing.
15:20:58 <Limbic_Region> well, I am not complaining
15:21:12 <Limbic_Region> I don't know the proper venue for reporting issues so I figured I was just doing it wrong
15:21:35 <eivuokko> glasgow-haskell-users@haskell.org is a good place.  Or hackage.haskell.or/trac/ghc
15:22:07 <Limbic_Region> eivuokko: are you indicating that you don't believe the extralibs will build from source with Cabal and it isn't worth my time to try?
15:22:38 <eivuokko> No, I mean that they probably only build by using Cabal.
15:22:48 <Limbic_Region> ah
15:22:51 <eivuokko> (Except when you're building ghc as well)
15:23:02 <eivuokko> Most of the makefiles are not standalone.
15:23:10 <Limbic_Region> ok - there is no ../mk/*.mk though
15:23:25 <eivuokko> Cabal doesn't need those.
15:23:29 <Limbic_Region> ahh
15:23:30 <Limbic_Region> ok
15:23:32 <eivuokko> Or if it does, it's sort of bug.
15:23:35 <Igloo> Bah, "Windows is complaining I may not have the appropriate permissions to access the item" when I try to run the MSYS installer
15:23:44 <eivuokko> There are few exception probably, like opengl and openal
15:24:00 <eivuokko> Igloo, Errr...
15:24:00 <Limbic_Region> ok, will try to build them concurrently with the source build
15:24:11 <Limbic_Region> since I will likely need to throw away that build even if it does finish
15:24:30 <Limbic_Region> Igloo - that's usually indicative of attrib +r on a file - or more likely, in use by another process
15:25:11 <eivuokko> Yeah, I don't think msys installer does anything fancy...just copy files and run postinstaller script.
15:25:19 <Igloo> If I make a copy of it I can run that, though. Is there a way to find out which processes have a file open?
15:25:36 <eivuokko> sysinternals have "handle" program
15:25:36 <musasabi> Has anyone had success with C2HS and a hierarchical module?
15:26:21 <Limbic_Region> Igloo - fuser ;-)
15:26:36 <Limbic_Region> Igloo - not with standard MS tools but yes
15:26:38 <musasabi> It creates FFI declarations like 'foreign import ccall unsafe "Codec/Encryption/LibGCrypt.h gcry_md_enable"' and the path in the header-file specification causes problems for GHC.
15:28:16 <Limbic_Region> what directory do I do the Cabal magic in?
15:28:24 <Limbic_Region> the libraries/
15:28:28 <Limbic_Region> or each subdir?
15:28:33 <eivuokko> Each subdir
15:28:37 <Limbic_Region> grrr
15:28:38 <Limbic_Region> ok
15:28:48 <eivuokko> Basically do: runghc Setup configure; runghc Setup build; runghc Setup install
15:28:50 <Limbic_Region> let me start with just the one pugs is whining about
15:29:08 <eivuokko> And you have to do it in correct order vs dependencies.
15:29:10 <Limbic_Region> mtl btw
15:29:20 <Limbic_Region> what does mtl depend on?
15:29:37 <eivuokko> You can see that by looking into mtl.cabal
15:29:44 <Limbic_Region> k
15:30:02 <eivuokko> There should be a line with build-depends:
15:30:04 <Limbic_Region> just base so I assume
15:30:06 <Limbic_Region> nothing
15:30:09 <Limbic_Region> but ghc
15:30:21 <eivuokko> Hmmm.
15:30:28 <eivuokko> Should depend on base, I think
15:30:43 <Limbic_Region> just "base" so I assume...
15:30:44 <Limbic_Region> yeah
15:31:04 <Limbic_Region> except there is no setup.hs
15:31:17 <Limbic_Region> so am I supposed to get that from somewhere else?
15:31:24 <eivuokko> That's right, mtl doesn't have one...wierd
15:31:52 <eivuokko> http://darcs.haskell.org/packages/Win32/Setup.hs <- that's the simple std one
15:31:54 * Limbic_Region has a tendency to hit the weird and hard things whenever he ventures into the unknown
15:32:07 <eivuokko> You're just first to do this :)
15:32:27 <ndm> Limbic_Region: i'm too scared to do what you are doing, so you have my respect :)
15:33:02 <Limbic_Region> eivuokko, ok, that seemed to work - thanks
15:33:22 <eivuokko> It should be enough for all projects that don't have Setup.hs or Setup.lhs
15:33:42 <eivuokko> ndm, hugs build does some magic to get these std Setup.hs out of thin air?
15:33:50 <Limbic_Region> ok, so let's see if that is enough to get Pugs to compile
15:33:51 <Limbic_Region> bbiab
15:33:56 <Igloo> hugs probably doesn't build mtl
15:34:02 <ndm> eivuokko: i understand nothing about Hugs
15:34:07 <ndm> Igloo: i'm pretty sure it does
15:34:22 <Igloo> Oh, yes, it's nhc that probably doesn't
15:34:25 <Igloo> So that is very odd
15:34:25 <ndm> eivuokko: but it does use cabal, so i guess it must do at some level
15:34:33 <Limbic_Region> good thing hugs his Pugs but avoids Hugs
15:34:43 <Limbic_Region> err
15:34:44 <eivuokko> Igloo, Well, anyway, it would have needed to get those Setup.hs out of thing air for other packages before they were added.
15:34:52 * Limbic_Region hugs his Pugs but avoids Hugs
15:35:02 <Limbic_Region> so if I do get this to work
15:35:04 <ndm> why not just add Setup.hs to the base package etc?
15:35:14 <Limbic_Region> should I bother writing up the instructions for the other Pugs Win32 users
15:35:21 <Limbic_Region> or is it all going to be fixed before I can finish?
15:35:45 <Limbic_Region> we are all excited about 6.6 btw
15:35:57 <eivuokko> Limbic_Region, writing and email to glasgow-haskell-users@ or cvs-ghc@ would be appreciated, as a todo list.  Or opening ticket at hackage.haskell.org/trac/ghc
15:35:58 <ndm> Limbic_Region: why are you excited?
15:36:27 <Pupeno_> @where Fruit
15:36:27 <lambdabot> http://haskell.org/fruit/
15:36:42 <Limbic_Region> ndm - in order to explain that, I would need to know how much you know about Perl 6 and Pugs
15:37:24 <eivuokko> Still need that Typeable -> Int function for pugs?
15:37:34 <Limbic_Region> dunno - I know nothing about Pugs internals
15:37:46 <Limbic_Region> audreyt or gaal or nothingmuch should be able to answer that though
15:37:47 <ndm> Limbic_Region: bits and pieces, i know what both are, i have read a few of Larry's chapters and a few of Damien's rewrites (can't remembmer their names), and know plenty of haskell
15:38:19 <Limbic_Region> ndm - in a nutshell, the most complete Perl 6 implementation right now is Pugs and the Haskell backend
15:38:37 <Limbic_Region> improving Haskell improves our ability to continue that implementation
15:38:39 <ndm> yep, i know that, but thats complete with 6.4.2?
15:38:51 <ndm> ah, is there anything in particular that 6.6 brings to the table?
15:38:54 <Limbic_Region> ndm - you have any idea the performance diff between 6.4.x and 6.5
15:39:00 <ndm> nope :)
15:39:05 <Limbic_Region> big time - night and day
15:39:09 <ndm> i didn't realise it was that great...
15:39:15 <Limbic_Region> for pugs it is
15:39:24 <ndm> i guess bytestring went through the roof, and a few foreignptr stuff did too
15:39:48 <Limbic_Region> and I overheard some of the things audreyt wanted to do would either only work or work better with 6.6
15:40:05 <dcoutts__> ndm: yep, bytestring goes way faster with 6.6
15:40:12 <ndm> ah, GADT's with records, he was hacking that while he was at ICFP :)
15:40:27 <Limbic_Region> audreyt?
15:40:29 <ndm> yep
15:40:35 <Limbic_Region> she prefers to be referred to as she
15:41:09 <ndm> ah yes, was he when i met him
15:41:28 <ndm> * her
15:41:32 <Limbic_Region> ok
15:41:32 <dcoutts__> partly due to the fusion rules working and partly due to ghc's impoved optimiser
15:41:39 <ndm> gah, gender specific words are annoying
15:41:58 <ndm> dcoutts__, what effect will that have on ordinary code?
15:42:10 <dcoutts__> not sure
15:42:14 <ndm> i.e. where you don't want to write a paper on your rewrite rules :)
15:42:24 <xerox> dcoutts__ hey
15:42:30 <dcoutts__> hia xerox
15:42:37 <Limbic_Region> so about writing up these instructions (assuming it works) - is it worth it or is this going to be fixed in short order?
15:42:45 <xerox> dcoutts__: could you find the ar code ? if it is not too complicated from your position in the world now :)
15:42:55 <eivuokko> For -threaded stuff we got smp...which gives the 5% or so disadvantage unless really using multiple threads.
15:43:00 <dcoutts__> ndm: it's only the optimiser stuff that ordinary programs would notice, the rules improvements are for lib authors who use rules
15:43:16 <eivuokko> (5% quoted from benchamrks other claim to have done, I didn't measure)
15:43:38 <dcoutts__> ndm: and I'm not exactly sure what the optimiser changes are in a nutshell, I just know they make a big improvement to the tight loops in Data.ByteString
15:43:56 <ndm> oh, neat - although sometimes its one small thing that makes a big change in those circumstances
15:44:07 <ndm> i.e. results are not consistent for all apps
15:44:12 <dcoutts__> xerox: arr
15:44:13 <ndm> but any speed up is welcome, of course :)
15:45:10 <dcoutts__> that's always the way with compiler optimisations, they can make a dramatic difference in specific cases and nothing elsewhere
15:45:38 <Limbic_Region> eivuokko, great news
15:45:41 <Limbic_Region> pugs is compiling
15:45:47 <Limbic_Region> that's not to say it won't die later on
15:45:50 <xerox> dcoutts__: hehe I mean ar(1) THIS time!
15:45:56 <Limbic_Region> but it appears that it is going to work
15:46:03 <eivuokko> Limbic_Region, Doesn't it precheck for packages it needs?
15:46:13 <dcoutts__> xerox: I know ;-)
15:46:18 <xerox> :D
15:46:20 <dcoutts__> I'm looking now
15:46:22 <Limbic_Region> eivuokko, well, yes
15:46:25 <xerox> Thank you.
15:46:38 <Limbic_Region> but just because the packages are there doesn't mean something else it assumed about ghc won't fail later on
15:46:50 <Limbic_Region> pugs internals change faster than you can think sometimes
15:47:00 <eivuokko> Heh :)
15:48:07 <dcoutts__> xerox: http://haskell.org/~duncan/Ar.hs
15:48:30 <Limbic_Region> will let you know
15:48:58 <Limbic_Region> and since no one indicated if this would be fixed in short order I will write up the instructions and share it with #perl6 and #haskell
15:49:06 <Limbic_Region> in case some other dufas comes in asking
15:49:49 <eivuokko> Limbic_Region, So you copied includes and built mtl with Cabal?
15:50:22 <Limbic_Region> mtl and network
15:50:31 <eivuokko> Ok.  Good to know.
15:50:37 <Limbic_Region> but also had to create Setup.hs for mtl
15:51:17 <Limbic_Region> when you put it that way, it seems awfully simple
15:51:40 <Limbic_Region> and in retrospect - it is
15:51:53 <Limbic_Region> I guess all the false leads I followed clouded my judgement
15:52:08 <eivuokko> Yes, that's the way it often is :-(
15:52:13 <Limbic_Region> which btw - my source compile is still compiling - how long does it usually take?
15:53:01 <Limbic_Region> oops, pugs blew up
15:53:24 <Limbic_Region> src/DrIFT/YAML.hs:40:12:
15:53:31 <Limbic_Region> rather, let me paste this
15:53:42 <eivuokko> bounds?
15:54:14 <Igloo> Limbic_Region: Thanks for spending the time trying out the RC, BTW. Hopefully it'll make the release that much nearer perfection  :-)
15:54:18 <lisppaste2> Limbic_Region pasted "Pugs Issue - any insight" at http://paste.lisp.org/display/25121
15:55:03 <Limbic_Region> eivuokko - no, but I did get a bounds problem trying to build Happy which is why I just lied to configure
15:55:07 <Igloo> Limbic_Region: Did that file come with the compiler you're using?
15:55:22 <Limbic_Region> Igloo - sorry, you are going to have to be more explicit
15:55:24 <eivuokko> Limbic_Region, Ah, new happy doesn't build with new ghc?
15:55:35 <Limbic_Region> eivuokko, no
15:55:40 <Limbic_Region> at least not on Win32
15:55:51 <Igloo> Limbic_Region: Is C:/ghc\imports/GHC/Exception.hi from the RC?
15:55:51 <Limbic_Region> igloo - that file being ?
15:55:55 <Limbic_Region> ahh
15:55:57 <Limbic_Region> let me see
15:56:47 <Limbic_Region> yes Igloo
15:57:09 <Limbic_Region> eivuokko, I just assumed that was also something I was doing wrong
15:57:21 <Limbic_Region> I used the binary build from the 19th (working) to try and build it
15:57:25 <Limbic_Region> and I got a bounds issue
15:57:37 <Limbic_Region> Igloo - does that mean anything to you?
15:57:43 <Igloo> Limbic_Region: What does ghc --show-iface C:/ghc\imports/GHC/Exception.hi say?
15:58:00 <Igloo> Does what mean anything to me?
15:58:09 <Limbic_Region> the paste
15:58:19 <Limbic_Region> I would be happy to provide the YAML.hs if that would help
15:58:29 <eivuokko> Limbic_Region, the bounds-issue is because an Array interface changed, and lots of old programs broke.
15:58:55 <lisppaste2> Limbic_Region pasted "output of ghc --show-iface C:/ghc\imports/GHC/Exception.hi" at http://paste.lisp.org/display/25122
15:58:56 <Igloo> Actually, I should be able to prod this myself
15:59:06 <Limbic_Region> Igloo - there is the output you asked for
15:59:46 <Limbic_Region> eivuokko - well, happy 1.15 is one of them
15:59:50 <xerox> ?yow!
15:59:51 <lambdabot> Now my EMOTIONAL RESOURCES are heavily committed to 23% of the SMELTING
15:59:51 <lambdabot> and REFINING industry of the state of NEVADA!!
16:00:25 <Igloo> Limbic_Region: It looks very broken to me. Possibly it is from the compiler used to compile the RC rather than the RC itself
16:00:54 <Limbic_Region> Igloo - do you have a copy of that particular file
16:00:57 <Limbic_Region> I can do a diff on it
16:01:01 <Limbic_Region> oh wait
16:01:05 <Limbic_Region> that is .hi not .hs
16:01:07 <Limbic_Region> nevermind
16:01:30 <Limbic_Region> well, that would be another thing that is b0rk in the Win32 binary distro
16:01:37 <Limbic_Region> since that's where the file came from - straight from the tarball
16:01:45 <Cale> @Yow. If you can't dance by now, the Raelettes will show you how.
16:01:45 <lambdabot> Laundry is the fifth dimension!!  ... um ... um ... th' washing machine
16:01:45 <lambdabot> is a black hole and the pink socks are bus drivers who just fell in!!
16:02:58 * Limbic_Region leans on Igloo and eivuokko at this point as he has no idea how to fix a broken Exception.hi
16:03:15 <Igloo> Limbic_Region: Can you also give the output of ghc --show-iface C:/ghc\imports/Prelude.hi please?
16:03:21 <Limbic_Region> sure
16:03:26 <eivuokko> If it's bad...nightly build is just plain broken at galois.
16:04:27 <lisppaste2> Limbic_Region pasted "output of ghc --show-iface C:/ghc\imports/Prelude.hi" at http://paste.lisp.org/display/25123
16:05:02 <mikepence_> hello all
16:05:07 <Igloo> Hmm, you're sure this compiler is the one that comes with C:/ghc?
16:05:10 <mikepence_> I have the all-too-typical question
16:05:17 <mikepence_> should I learn Erlang or Haskell?
16:05:22 <ndm> Limbic_Region: how did you extract the tarball?
16:05:26 <Limbic_Region> Igloo - here, let's do this
16:05:34 <Limbic_Region> shouldn't take me anytime at all to start from scratch
16:05:39 <Limbic_Region> now that I know what to do
16:05:44 <Limbic_Region> I will wipe out the current c:\ghc
16:05:47 <Cale> mikepence_: What sort of programs are you going to write?
16:05:48 <Limbic_Region> untar the tarball
16:05:58 <Limbic_Region> Cabal build the two libraries I need
16:06:01 <Limbic_Region> start with a fresh pugs
16:06:03 <mikepence_> Cale, social networking sites
16:06:05 <Limbic_Region> and then let you know
16:06:08 <mikepence_> with some specific twists
16:06:09 <Limbic_Region> give me 10 minutes
16:06:09 <ndm> Limbic_Region: are you sure it didn't get Windows/Unix line end corrupted in the process?
16:06:13 <mikepence_> but typical web development
16:06:27 <mikepence_> I do Ruby on Rails
16:06:29 <ndm> mikepence_: haskell has static typing, so more reliable
16:06:30 <Limbic_Region> ndm - how would I do that - I just untar the files
16:06:33 <mikepence_> but am looking to learn functional
16:06:39 <Limbic_Region> anyway - I am off
16:06:51 <ndm> mikepence_: but erlang has better threads, or did at least, and can be upgraded dynamcially
16:07:03 <Igloo> Limbic_Region: Don't worry, I've just got the same magic number
16:07:04 <mikepence_> ndm, what about database access?
16:07:06 <ndm> Limbic_Region: various ways, just check the text files are UNIX newlines, not Windows
16:07:26 <mikepence_> there seems to be move from OOP to functional
16:07:30 <mikepence_> they both look intriguing
16:07:37 <mikepence_> and I love the idea of provable software
16:07:40 <ndm> mikepence_: I don't know, Haskell's has a good api, but can be a bit rough - from what i've heard
16:08:11 <Limbic_Region> ndm - unless something in the tarball broke the line endings - I have been following the same process for over a year without a problem
16:08:13 <mikepence_> thanks, ndm
16:08:46 <Cale> mikepence_: There are some database connectivity libraries. http://gopher.quux.org:70/devel/hdbc
16:08:47 <lambdabot> Title: Gopher: hdbc
16:08:52 <mikepence_> do you all think it is worth the time to learn functional programming if you are from an OOP background?
16:08:58 <Cale> (see the API docs there)
16:08:59 <mikepence_> thanks, cale
16:09:03 <ndm> yes, since we all did :)
16:09:16 <mikepence_> cool
16:09:19 <ndm> or i guess most of us did, i certainly did
16:09:27 <xerox> You can install them with cabal-install too! (hdbc)
16:09:33 * xerox hops
16:09:43 <Cale> mikepence_: Oh, it's definitely worth it. I'm not sure I'd really use Haskell for web development, though I'm also not sure how much web development I'd really be up for in the first place :)
16:09:45 <ndm> xerox: is that out yet?
16:10:01 <mikepence_> sweet
16:10:04 <mikepence_> you guys are great
16:10:06 <xerox> FSVO out. I posted to the cabal-devel mailing list some times.
16:10:09 <mikepence_> thanks for the affirmation
16:10:46 <eivuokko> xerox, it'd be cool if ghc' extra libs were available in cabal-install...or are they? :)
16:11:15 <xerox> I'm working out how to let people add their own packages if they have access to monk right now.
16:11:29 <Igloo> Cool!
16:11:46 <ndm> is this what will become hackage?
16:12:35 <xerox> cabal-put needs to do some quality assurance, I don't know how much though.
16:12:56 <xerox> So I can't decide wether a shell script is enough or wether I should go for an Haskell app.
16:13:09 <ndm> since i want a database of haskell packages for hoogle :)
16:13:22 <eivuokko> As long as it's easy...but haskell app is easier to port Windows later on...maybe.
16:13:31 <Igloo> That's an impl detail you can change later, anyway
16:13:39 <Igloo> Just don't give it a .sh or .hs extension
16:13:52 <xerox> That's true too.
16:14:21 <xerox> It's just that one has to make sure of some consistency.
16:14:27 <mikepence_> darn
16:14:37 <mikepence_> no one active in the erlang room
16:14:42 <mikepence_> I don't like that
16:14:45 <xerox> Case-sensitive match of names.
16:14:59 <xerox> ...and version numbers in proper places.
16:15:05 <mikepence_> well, wtf
16:15:14 <mikepence_> I am going to learn Haskell to learn Haskell
16:15:19 <mikepence_> just for the hell of it
16:15:27 <mikepence_> nevermind applicability to my line of work
16:15:30 <eivuokko> It's probably worth it :)
16:15:44 <mikepence_> perhaps it will make me a better ruby programmer
16:15:54 <mikepence_> or a happier person
16:16:01 <mikepence_> of I will lose weight
16:16:03 <mikepence_> get taller
16:16:05 <mikepence_> whatever
16:16:23 <xerox> Go for it!
16:16:36 <mikepence_> what to read first?
16:16:41 <Limbic_Region> Igloo, eivuokko - almost finished starting over
16:16:42 <xerox> ?where yaht
16:16:42 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
16:17:07 <mikepence_> I am there
16:17:10 <mikepence_> thanks
16:17:11 <mikepence_> !
16:17:15 <Igloo> Limbic_Region: Do you have another ghc installed?
16:17:17 <xerox> You're welcome!
16:17:18 <lispy> or
16:17:21 <lispy> oops
16:17:30 <Limbic_Region> Igloo - not currently
16:17:38 <Limbic_Region> I wiped out all the GHC installs
16:17:43 <Igloo> OK
16:17:50 <Limbic_Region> but the only one I know works 100% is from the 19th
16:18:02 <Limbic_Region> ok, building pugs now
16:18:21 <ihope> "A compact prime sieve  - 52 lines of portable ANSI C."
16:18:40 <ihope> I guess ANSI C isn't good at compactness.
16:18:48 <Limbic_Region> heh
16:18:51 <eivuokko> Limbic_Region, I'm going to get some sleep.  If you write up notes or something, could you email me a copy or link, please?  ei at vuokko dot info  Thanks for brining all those issues here.
16:19:13 <Limbic_Region> will do
16:19:28 <Limbic_Region> though I am not hopeful of getting it 100% working
16:20:16 <Limbic_Region> Igloo - one question
16:20:33 <Limbic_Region> the binary distro I am using for ghc is dated today (2006-09-01)
16:20:51 <Limbic_Region> the source distro I am building the libs from is 2006-08-31
16:20:56 <Limbic_Region> that wouldn't pose a prob would it?
16:21:14 <Igloo> Shouldn't do
16:21:23 <Limbic_Region> ok
16:21:28 <Limbic_Region> wait and see game then
16:21:37 <Limbic_Region> oh wait
16:21:42 <Limbic_Region> it made it past YAML
16:22:13 <Limbic_Region> I think this is going to work!!!!!
16:22:19 <Igloo> OK, you probably compiled some files with a different GHC last time somehow
16:22:25 <Igloo> :-)
16:22:35 <Limbic_Region> except the only thing I compiled was the two libraries
16:22:55 <Limbic_Region> though who knows
16:23:08 * Limbic_Region starts writing up some instructions
16:33:27 <lisppaste2> Limbic_Region pasted "Win32 Binary anomolies" at http://paste.lisp.org/display/25124
16:35:43 <Igloo> Limbic_Region: Do you know what commandline was used that failed with teh includes in the wrong place?
16:37:13 <Limbic_Region> Igoo - no, it is part of the configure/compile/build process
16:37:20 <Limbic_Region> though if you want to see it for yourself
16:37:26 <Limbic_Region> try building happy
16:37:33 <Limbic_Region> happy whined about the same thing
16:37:41 <Igloo> OK, ta
16:44:18 <Limbic_Region> ok, I am sufficiently tired of this for now
16:44:23 <Limbic_Region> TTFN and thanks all
16:46:08 <Lemmih> What the deal with blocking C functions in GHC-6.6? Do they still block all threads?
16:47:38 <Igloo> Unless you have the threaded RTS, yes
16:48:40 <Lemmih> But with -threaded it shouldn't be a problem?
16:49:01 <Igloo> No, but the same is true with 6.4.3
16:50:02 <xerox> G'night!
16:50:19 <Igloo> If I leave Windows compiling GHC, is it going to hibernate after a while?
16:51:12 <ndm> Igloo: depends on yoru system settings
16:51:16 * Lemmih wonders why fastcgi blocks with ghc-6.6 ant not with ghc-6.4.1.
16:51:56 <ndm> Igloo: control pannel, power options, then set it up appropriately
16:52:02 <Igloo> ndm: my settings say to hibernate after x hours of "inactivity", but I can't see a definition of what that is
16:52:10 <Igloo> Lemmih: A binary, or in ghci?
16:52:16 <Lemmih> Igloo: Binary.
16:52:18 <ndm> Igloo: the user moving the mouse or pressing the keyboard
16:52:35 <ndm> Igloo: certain programs like powerpoint acn also say they are being "active"
16:52:40 <ndm> but compiling GHC doesn't count
16:52:42 <Igloo> ndm: OK, so I need to set them to never then
16:52:51 <ndm> Igloo: Presentation mode
16:53:03 <amoe> would it be possible to write (normally very stateful) neural network code in a functional style?
16:53:59 <amoe> in general, are there good tactics for elegantly translating stateful tasks to non-mutating ones?
16:54:07 <Igloo> Lemmih: That sounds like a bug to me, if they're being compiled in the same way
17:15:35 <ndm> @paste
17:15:35 <lambdabot> http://paste.lisp.org/new/haskell
17:16:08 <lisppaste2> ndm pasted "Hugs on Windows" at http://paste.lisp.org/display/25126
17:37:27 <lennart> @pl  \ f l -> l ++ map f l
17:37:27 <lambdabot> ap (++) . map
17:37:56 <Cale> @pl \l -> l ++ map f l
17:37:57 <lambdabot> ap (++) (map f)
17:40:43 * kpreid considers @pl-without-reader-monad
17:41:26 <Cale> The reader monad is pretty nice though
17:41:51 <Cale> But it does take getting used to :)
17:42:09 <Cale> I think some things would be impossible to point-free without it.
17:42:27 <Cale> Currently, it takes care of basically all replication of parameters
17:43:32 <kpreid> hm.
17:44:04 <kpreid> you know, I should have known that's what it was doing, but having that said makes it a lot clearer
17:44:09 <kpreid> @type ap
17:44:10 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:45:14 <kpreid> it's still confusing :)
17:45:22 <Cale> ap is s
17:45:25 <kpreid> @type ap (++)
17:45:26 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a]
17:45:34 <Cale> ap f g x = f x (g x)
17:46:35 <kpreid> @pl \l -> map g l ++ map f l
17:46:36 <lambdabot> ap ((++) . map g) (map f)
17:46:57 <Cale> hehe
17:47:30 <kpreid> @. pl djinn Maybe (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
17:47:30 <Cale> I wonder if there's a more symmetric way
17:47:31 <lambdabot> (line 3, column 13):
17:47:31 <lambdabot> unexpected ">" or "-"
17:47:31 <lambdabot> expecting variable, "(", operator or end of input
17:47:39 <explicitjelly> ah, you're discussing my problem? :)
17:47:55 <Cale> explicitjelly: hm?
17:47:57 <kpreid> @djinn Maybe (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
17:47:57 <lambdabot> f a b c =
17:47:57 <lambdabot>   case a of
17:47:57 <lambdabot>   Nothing -> Nothing
17:47:57 <lambdabot>   Just d -> case b of
17:47:57 <lambdabot>        Nothing -> Nothing
17:47:59 <lambdabot>        Just e -> case c of
17:48:01 <lambdabot>             Nothing -> Nothing
17:48:03 <explicitjelly> Cale, I posted that on the mailing list.
17:48:03 <lambdabot>             Just f -> Just (d e f)
17:48:18 <kpreid> hm
17:49:11 <kpreid> @. pl undo \a b c -> do a' <- a; b' <- b; c' <- c; return $ a' b' c'
17:49:11 <lambdabot> (. ((. ((. ((return .) .)) . (.) . (>>=))) . (.) . (>>=))) . (.) . (>>=)
17:49:24 <kpreid> ow
17:49:57 <Igloo> liftM3 id   has the type above, if you really wanted something
17:51:09 <kpreid> clever
17:51:43 <explicitjelly> hmm. my subject "Exercise in point-free style" kind of sounds like the title to a sociological article.
17:51:45 <kpreid> @pl liftM2 id
17:51:46 <lambdabot> ap
17:52:39 <Cale> yeah, that exercise isn't really meant to be completely points-free-ised
17:52:58 <Cale> This exact discussion has come up before a couple of times already :)
17:53:12 <explicitjelly> I'm Julien, btw (in case it wasn't already clear by now)
17:53:15 <Cale> yah
17:53:18 <Cale> e*
17:53:20 <explicitjelly> Cale, oh, sorry, should have looked at the archives
17:53:39 <Cale> That's fine, I'm not sure if it was on the mailing list, but I know we've talked about it on IRC.
17:53:57 <explicitjelly> ah. well now it's there for others to see :)
17:54:14 <kpreid> @type ap (,)
17:54:15 <lambdabot> forall a a1. (a1 -> a) -> a1 -> (a1, a)
17:55:50 <Cale> I think that in actual programming, the best thing is to have a good mixture of pointful and point-free styles. It's a little hard to express exactly what that mixture is though. :)
17:55:51 * kpreid now sees how ap ((++) . map g) (map f) works
17:55:58 <Cale> kpreid: :)
17:56:59 <kpreid> lousy question: when does one use ap, outside of @pl?
17:57:55 <Cale> Well, it's originally sort of there as an apology for not being able to generalise liftMn
17:58:01 <kpreid> I mean, obviously, "when the function to be applied is in the monad too", but when does that happen?
17:58:41 <Cale> return f `ap` x1 `ap` x2 `ap` x3 `ap` ... `ap` xn = liftMn f x1 x2 ... xn
17:58:51 <Cale> But only up to liftM5 are in the library.
17:59:10 <kpreid> that's, uh, interesting
17:59:12 <kpreid> oooohhhhh
18:07:31 <lennart> ap sometimes improves readability.  I've used it, e.g., with parsing combinators
18:09:50 <kpreid> @type ap
18:09:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
18:09:56 <kpreid> @type liftM2 ($)
18:09:57 <lambdabot> forall b a2 (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
18:13:01 <lennart> yeah, like most things in haskell you can do it more than one way :)
18:13:29 <explicitjelly> lennart, so haskell is basically the same thing as perl.
18:13:54 <ndm> explicitjelly: definately not!
18:14:01 <explicitjelly> (just kidding. really.)
18:14:44 <lennart> it's like perl, but with types :)
18:15:07 <Cale> and almost no side effects of any kind
18:15:18 <Cale> $_ is so evil :)
18:15:20 <explicitjelly> and totally different anyway.
18:15:28 <explicitjelly> I mean, it's readable. most of the time, at least.
18:15:40 <Cale> Sometimes sublimely so
18:16:06 <Cale> I don't think I really understood what quicksort was doing until I saw the quicksort written in Haskell.
18:16:09 <kpreid> I wonder if you could define a hide-the-monad library for Haskell
18:16:19 <kpreid> all the functions, including (+), would be liftM*'d
18:16:21 <explicitjelly> Cale, hah, same thing here!
18:16:31 <explicitjelly> Cale, quicksort in haskell is just beautiful.
18:16:46 <ndm> i use quicksort in haskell to teach quicksort in Ada
18:16:52 <Cale> hehe
18:17:17 <lennart> Cale: but haskell quicksort is so much less clever than the original update-in-place :)
18:18:31 <Cale> lennart: sure. I wonder if we'll ever have clever enough compilers that they'll write the in-place version from the functional description (assuming some knowledge about uniqueness)
18:19:49 <ndm> Cale: i beleive Clean can do a pure update in place quicksort
18:20:03 <Cale> ndm: Without programmer help? :)
18:20:08 <ndm> not automatically, but its possible to express
18:20:15 <lennart> it will take a lot of cleverness to turn the list version into Hoare's version
18:30:58 <Korollary> It's friday, dammit.
18:31:27 <ndm> saturday here
18:31:38 <explicitjelly> here, too. 3:27 am.
18:32:07 <Korollary> I suppose you don't have monday off, either.
18:33:30 <dons> moin!
18:33:30 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:34:08 <explicitjelly> nah, but my bosses all have monday off, so...
18:34:16 <explicitjelly> I'll actually be "there", I guess, but...
18:37:59 <dons> ?users
18:38:00 <lambdabot> Maximum users seen in #haskell: 220, currently: 196 (89.1%), active: 18 (8.2%)
18:38:07 <dons> ?uptime
18:38:07 <lambdabot> uptime: 19 hours, 38 minutes and 19 seconds, longest uptime: 19 hours, 38 minutes and 19 seconds
18:54:15 <dons> ?seen lennart
18:54:16 <lambdabot> I saw lennart leaving #haskell 17 minutes and 23 seconds ago, and .
18:54:18 <dons> doh
19:10:05 <lispy> http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
19:10:08 <lambdabot> Title: dagit.o Â» Blog Archive Â» Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
19:18:08 <sjanssen> is there a function like par, but in the IO monad?
19:18:16 <lispy> @hoogle par
19:18:17 <lambdabot> Control.Parallel.par :: a -> b -> b
19:18:17 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
19:18:17 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
19:18:28 <sjanssen> something like parIO :: IO a -> IO b -> IO (a, b)
19:18:47 <sjanssen> and the compiler can decide whether or not to run the two actions in parallel
19:18:53 <lispy> @type liftM2 Control.Parallel.par
19:18:54 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a2
19:19:11 <heatsink> !type seq
19:19:14 <heatsink> @type seq
19:19:15 <lambdabot> forall b a. a -> b -> b
19:20:43 * heatsink can't figure out what par does
19:20:46 <sjanssen> hmm, maybe I could write one with unsafeInterleaveIO
19:21:02 <lispy> heatsink: iirc, parallel execution
19:21:33 <heatsink> lispy: but it only returns b, what's the point of executing a?
19:21:38 * lispy can't stand his blog software....
19:21:54 <sjanssen> heatsink: you'll keep a in a let or something
19:22:01 <sjanssen> same idea as seq
19:22:09 <heatsink> oh, okay.
19:23:45 <thetallguy> ?seen stepcut
19:23:45 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 4 hours, 57 minutes and 47 seconds ago.
19:23:56 <dons> lispy: is your blog sindicated to planet.haskell.org ?
19:24:05 <lispy> dons: nope, how do i do that?
19:24:17 <dons> you ping ibid, and he adds your rss feed
19:24:21 <heatsink> sjanssen: You could write it with threading.
19:25:00 <lispy> ?tell ibid if my blog is planet haskell worthy would you please add my rss feed? http://blog.codersbase.com/ thanks!
19:25:01 <lambdabot> Consider it noted.
19:25:11 <lispy> dons: okay, it's not always about haskell, but maybe that's okay?
19:25:19 <sjanssen> heatsink: sure, but calling forkIO too often is expensive.  It'd be neat if the RTS could notice that a CPU is idle and choose to execute the actions in parallel
19:25:45 <dons> lispy, that's fine
19:26:09 <ndm> lispy: you can send the RSS feed of a haskell tag, if you want, so it only gets your haskell stuff
19:26:20 <lispy> ndm: good idea
19:26:55 <lispy> not sure how to do that though...this is wordpress if that helps
19:28:52 <lispy> oh gees, i should be reading planet.haskell.org it looks nice
19:29:38 <ndm> lispy: it looks like wordpress doesn't have the feature - just shove all of your feedon their anyway
19:31:46 <lispy> scene graphs are a popular way to do opengl scene rendering these days, but no one seems to have made a scene graph library in haskell yet (I bet it would be relatively easy and nice to have)...
19:31:55 <lispy> not saying i'll get to it...but it would be a fun project
19:34:31 <dons> lispy: did you work out your mmap issue?
19:34:40 <dons> (I suspect it was the change to the seen state... )
19:41:20 <foxy__> @free (>>=)
19:41:21 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
19:41:32 <dons> hmm
19:41:36 <foxy__> @free map
19:41:37 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
19:41:38 <dons> ?free sortBy
19:41:39 <lambdabot> g x y = h (f x) (f y) => $map f . sortBy g = sortBy h . $map f
19:41:43 <dons> ?free >>=
19:41:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
19:41:51 <dons> ?free (Control.Monad.>>=)
19:41:52 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
19:41:52 <foxy__> @yow
19:41:52 <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with
19:41:53 <lambdabot> MISSILES!!
19:41:54 <dons> ah well
19:41:58 <dons> ?free fmap
19:41:59 <lambdabot> Expected variable or '.'
19:42:04 <dons> (breaks due to kind annotation)
19:42:29 <foxy__> @free (+)
19:42:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
19:42:37 <dons> maybe it just doesn't like syms?
19:43:09 <foxy__> cool idea, though
19:44:51 <foxy__> @free foldl
19:44:53 <lambdabot> f . h x = k (f x) . g => f . foldl h y = foldl k (f y) . $map g
19:52:08 <dmwit> Note to self: reading the backlog in reverse order is like carrying a two-by-four through a door sideways.
19:52:34 <lispy> lol
19:52:37 <lispy> it really is
19:52:42 <dmwit> The only problem with that note is, by the time I get to it next time, it's too late.
19:52:48 <dmwit> =P
19:53:26 <lispy> nice
19:54:41 <dons> http://www.cs.mu.oz.au/~bjpop/timeline/timeline.5.png
19:54:44 <dons> updated
19:55:30 <dylan> anyone know of a library for reading (possibly compressed) tarballs, and/or zip files, etc?
19:56:00 <dons> you want gzip / tar binding?
19:56:30 <dylan> yes, and other formats if possible. XD
19:56:54 <dons> there's a gzip binding or two out there. but i don't know of anything for tar
19:57:12 <dylan> hmm. looks like I'll have to shell-out then.
19:57:39 <lispy> still missing lambdabot which is arguably a tools since some people (like myself) keep it handy to help code
19:58:05 <ndm> i don't think dons can add lambdabot, its a bit of a conflict of interest
19:58:17 <ndm> and dons, i think you really really really need a web interface to lambdabot
19:58:20 <dons> i'm not the one writing it :)
19:58:23 <dons> bernie is.
19:58:29 <dons> ndm, I agree.
19:58:41 <dons> busy writing a paper atm, but I'm thinking about how best to do it
19:58:43 <ndm> dons: i wouldn't have included visual haskell though
19:58:54 <dons> neither :/ seems a bit weird.
19:59:01 <dons> it was useful in that we got ghc-api out of it
19:59:19 <lispy> maybe there has to be a paper associated with it for it to get listed?
19:59:22 <ndm> dons: well let me know what you want from hoogle - i'll give you a proper backend to hoogle, so you can output correctly coloured and styled hoogle
19:59:33 <lispy> iirc, VH has a paper but i didn't see on on lambdabot yet
19:59:35 <dons> lispy: if you think lambdabot should be there, add a note to the Timeline page of haskell.org's History of Haskell page
19:59:36 <ndm> i'd hope more people use hoogle than visual haskell :)
19:59:56 <dons> lispy: (since lambdabot's even mentioned in the paper itself, it probably should appear in the timeline)
20:00:04 <dons> lispy: there are two papers about lambdabot remember ;)
20:00:06 <lispy> @google site:haskell.org history of haskell
20:00:09 <lambdabot> http://haskell.org/haskellwiki/History_of_Haskell
20:00:09 <lambdabot> Title: History of Haskell - HaskellWiki
20:00:31 <dons> here, http://haskell.org/haskellwiki/Talk:History_of_Haskell/Timeline
20:00:34 <lambdabot> Title: Talk:History of Haskell/Timeline - HaskellWiki, http://tinyurl.com/mr9bm
20:00:39 <ndm> no anglo haskell?
20:00:45 <dylan> yay! pugs-HsSyck builds with fps, even though the cabal file says it needs pugs-fps
20:00:55 <dons> that's cool!
20:00:57 <dons> which fps?
20:01:00 <dons> 0.7?
20:01:06 <dylan> latest one from darcs get
20:01:17 <dons> right. i think that's the same as pugs-fps roughly
20:01:41 <dons> not sure why pugs-fps was created. I suppose I broke something for them (maybe the cbits?), and didn't get out 0.7 fast enough?
20:01:44 <dons> audreyt: ^^ is that right?
20:02:17 <lisppaste2> Dylan pasted "result of ./Setup.hs build for pugs-HsSyck" at http://paste.lisp.org/display/25132
20:02:48 <dons> probably harmless
20:02:58 <dylan> well, definitely harmless.
20:03:00 <dons> the implicit declaration means they're missing a .h imporot
20:03:13 <dylan> I've been using it since several hours ago
20:03:19 <dons> and the config.h is a path issue were they miss ghcconfig.h
20:03:23 <dons> where
20:03:58 <audreyt> dons: that is right
20:04:10 <dylan> Of course, I did have to explain what ghc was, and why it was installed on the dev server at work... but I didn't have any real work to do. ;)
20:04:11 <dons> both issues, or the first?
20:04:14 <audreyt> we just dummy'd pugs-fps on a 6.6 build
20:04:31 <audreyt> making it an empty pkg, as it is
20:04:38 <audreyt> pugs-fps is just pristine 0.7
20:04:39 <Cale> dons: what about your own projects? :)
20:04:40 <dons> ah good. so you just use the baes fps?
20:04:44 <Cale> (on the chart)
20:04:51 <audreyt> yes, on 6.6 I just use base.
20:05:05 <dons> Cale: not my chart. I leave it up to Messrs. Hughes, Jones,  Hudak and Wadler to decide
20:05:08 <audreyt> their API differ though
20:05:15 <audreyt> base lacks .tokens
20:05:18 <dons> is that a problem?
20:05:27 <audreyt> so I had to avoid it
20:05:33 <audreyt> otherwise no, it all basically works
20:05:35 <dons> we decide that we shouldn't commit to tokens yet-  the design space is too big and we haven't thought properly about it
20:05:45 <dons> what was there was just legacy from darcs
20:05:46 <audreyt> once 6.6 binbuild is up for the usual platforms
20:05:53 <dons> ok good
20:05:55 <audreyt> I'll just kill 6.4 support
20:05:56 <audreyt> and drop pugs-fps
20:06:01 <dons> great
20:06:04 <audreyt> but for now it's essential for compat
20:06:07 <dons> yep
20:06:38 * audreyt has been pining for checking in her GADT+Rec (aka OOP) refactoring to pugs...
20:06:48 <dons> ooh
20:06:54 <audreyt> ...which simply cannot be made to work on 6.4, no matter how much DrIFT magick we apply.
20:06:56 <dons> sounds funky
20:07:00 <dons> heh
20:07:07 <audreyt> it's just standartd existential record types...
20:07:41 <dons> :)
20:08:12 <audreyt> lunch, bbiab :)
20:08:17 <dons> good idea.
20:08:22 * dons gets some lunch
20:09:22 <dylan> kell]
20:09:31 <dylan> Wcssss
20:09:36 <freeone3000> There is no funk in function...
20:09:46 * dylan slaps his network latency
20:09:56 <dylan> freeone3000: there is in German.
20:10:35 <freeone3000> Oh. Cool.
20:10:36 <dylan> freeone3000: http://de.wikipedia.org/wiki/Funktion_%28Mathematik%29
20:10:38 <freeone3000> I don't speak german.
20:10:57 <freeone3000> Just English, and spanish like a white person who took it in high school as his friendly foreign language.
20:11:09 <dylan> me neither, but that doesn't stop me from reading it. ;)
20:13:43 <dylan> I speak spanish somewhat-well, due to 3 semesters in college.
20:15:08 <freeone3000> I'm taking it as my friendly foriegn language.
20:15:20 <freeone3000> Third year of differentiating between estas and esos.
20:15:49 <dylan> eew.
20:16:03 <dylan> they should've at least taught your the present progressive. :P
20:16:07 <dylan> *you
20:16:31 <freeone3000> Estoy hablando de espanol.
20:17:08 <freeone3000> Ã±... Ooh! Deadkeys work here!
20:27:22 * edwardk waves hello.
20:28:50 * ndm waves back
20:28:56 <edwardk> how goes?
20:29:46 <edwardk> i am discovering that a linear type system play havoc with most traditional monads. a lot of monads in a normal system are not monads in a system that also allows linear types =(
20:30:40 <edwardk> so now i need a class of monads defined over a subset of my structural types, etc. very strange.
20:30:44 <dons> :)
20:30:59 <ndm> i can check over 60% of my examples for catch
20:31:15 <ndm> only skipping 2, and those are because they scare me, rather than technical limitations
20:32:05 <edwardk> i can't seem to figure out how to get STM and linear types to play nice. by the time you know you need to roll back, yer fucked ;)
20:33:36 <edwardk> I figured STM was a good example of a non-trivial monad to test out
20:34:00 <edwardk> ndm: catch examples?
20:34:43 <ndm> edwardk: http://www.cs.york.ac.uk/fp/darcs/catch/src/Example/
20:34:47 <lambdabot> Title: Index of /fp/darcs/catch/src/Example, http://tinyurl.com/gmdau
20:34:55 <ndm> edwardk: my tool Catch, the pattern match checker, on that set of examples
20:35:07 <edwardk> ah
20:35:16 <ndm> oh, lambdabot does tinyurl;s :)
20:35:26 * lispy nods
20:35:34 <edwardk> http://slipwave.info/
20:35:43 <edwardk> heh it didn't bother
20:35:53 <lispy> has to be > 45 chars
20:36:06 <edwardk> yeah but it didn't even do the title
20:36:12 <lispy> oh hmm...
20:36:22 <edwardk> bug not feature? =)
20:36:28 <jrmole> linear types ?= uniqueness types
20:36:32 <lispy> ?url-title http://slipwave.info/
20:36:50 <lispy> ?tiny-url http://slipwave.info/
20:36:51 <lambdabot> http://tinyurl.com/hmlb6
20:36:52 <edwardk> jrmole: different. linear = won't contract or weaken in the future. uniqueness = haven't contracted or weakened in the past.
20:37:00 <lispy> @list url
20:37:01 <lambdabot> url provides: url-title tiny-url
20:37:24 <lispy> edwardk: maybe the page doesn't have a valid title according to the heuristics for finding the title
20:37:31 <edwardk> hrmm possible
20:37:59 <jrmole> what do contract/weaken mean, if you can explain briefly?
20:38:01 <ndm> it does have a reasonable title
20:38:29 <edwardk> jrmole: \x -> (x,x) needs to contract x to use it twice, \_ -> 12 needs to weaken its argument to throw it away
20:38:38 <lispy> yeah, not sure why url-title gives up
20:38:41 <edwardk> linear types are neither contracted or weakened, so they will be used exactly once.
20:39:00 <edwardk> uniqueness types haven't been contracted or weakened, so there is only a single reference to them, hence they can be updated in place.
20:39:15 <ndm> lispy: its not that near the top of the page, maybe url-title only searches a given amount of text?
20:39:21 <edwardk> the former is sufficent to say you can use it strictly and always throw it away when done using it
20:39:38 <edwardk> the latter is enough for in place updates, BUT not enough to claim strict evaluation.
20:39:40 <lispy> ndm: i can't remember...i didn't look at fetchTitle much
20:39:56 <edwardk> so unlike most people i see them as complementary
20:40:07 <lispy> ndm: but i wonder if the script messes up teh parse
20:40:50 * edwardk wonders if by now dons' eyes start to glaze over when the linear types thing comes up ;)
20:41:11 <jrmole> so in the context of doing IO: you would give a linear type to the RealWorld value itself, whereas you would give a uniqueness type to the computation's result (as in Clean)
20:41:22 <jrmole> is that correct?
20:42:40 <edwardk> jrmole: clean just has uniqueness types. on the idea that its easier to work with types you can transform into traditional unrestricted types, that it is to work with something that forever after becomes a ticking time bomb waiting to explode on first use.. but a linear world is probably the correct model, yes
20:43:07 <edwardk> at least w.r.t the substructural logic options we have so far
20:43:51 <jrmole> interesting
20:43:58 <lispy> edwardk: nothing your saying makes any sense to me :)
20:43:59 <edwardk> you can thread a linear capability through a bunch of methods to get ST style coordination or in the case of IO, world wide organization, etc.
20:44:56 <edwardk> jrmole: i'm writing up a paper on mixed substructural typing as an engineering problem, not a research probem. all the right research has been done, people just only care about their little piece of it ;)
20:45:48 <edwardk> though, for pragmatic reasons i'm mixing in a region allocator and some other stuff, but again, thats engineering, not research.
20:46:49 <edwardk> linear capabilities for regions let you avoid the tofte-talpin stack discipline and still be safe, so the pieces all fit together nicely
20:48:08 <edwardk> and introducing them nicely sidesteps the whole non-commutative-linear-logic-makes-a-crappy-stack problem
20:48:46 <edwardk> but i think i'm getting ahead of myself and that probably doesn't make much sense without more context.
20:49:54 <jrmole> it gives me many things to google for, at least
20:50:02 <edwardk> my main goal right now is to put it all together and see what the frankenstein monster looks like when i stare it in the face.
20:51:48 <edwardk> jrmole: look up jean yves girard, he has some stuff on linear logic, some is accessible, some isn't, the rest follows via curry-howard isomorphism, dana harrington has a really good thesis on uniqueness types, the first paper in ATTaPL dives into some of the substructural types, but without a good categorical or logical motivation though
20:52:33 <edwardk> actually the wikipedia article on linear logic is pretty readable too
20:53:28 <edwardk> but you have to be careful to read all the sequents as types and to ignore the non-intuitionistic fragment (anything with more than one thing on the right of the \vdash)
20:54:04 * edwardk lapses into silence.
20:54:05 <edwardk> ;)
20:55:38 <jrmole> i'm digesting it now
20:57:35 <edwardk> as most people have noticed if you mention one of a few buzzwords i'll fill a few screens here ;)
20:58:10 * lispy just doesn't have any training in the area and so it sounds like gibberish :)
20:58:28 <edwardk> lispy: its mostly a matter of reading the papers in the right order
20:58:55 * lispy doesn't know where the sequence starts
20:59:06 <lispy> LtU?
20:59:15 <edwardk> hrmm
20:59:27 <edwardk> well what do you know about the simply-typed lambda calculus?
20:59:58 <lispy> if i know anything about it, i don't know it by that name...i only know the untyped lambda calc
20:59:58 <edwardk> or the curry howard correspondence?
21:00:07 <jrmole> what are the type-theoretical interpretations of additive/multiplicative conjunction/disjunction
21:00:25 <lispy> i've seen the description of the curry-howard isomorphism but i didn't spend enough time with it to get it yet
21:00:38 <jrmole> as a beginning student i recommend _types and programming languages_ by pierce
21:00:40 <edwardk> jrmole: they don't map cleanly onto haskell types. coz they are linear, so you kow that all pieces they reference are used once.
21:00:46 <edwardk> jrmole: yeah i agree
21:00:49 <jrmole> but i haven't seen many other texts
21:00:56 <lispy> oh, i have that under my bed but i haven't been reading it much
21:01:43 <jrmole> as an aside, reading ML when you know Haskell is like reading portuguese when you know spanish ;)
21:02:11 <lispy> heh
21:02:30 <edwardk> jrmole: multiplicative conjunction/tensor/(*) can be viewed as a pair, additive conjunction can be viewed as a pair of functions you can use only one of, additive disjunction can be viewed as an Either, multiplicative disjunction is a little harder to see in haskell.
21:02:54 <edwardk> the relationships are approximate though
21:03:26 <edwardk> but you could map them onto linear types with that mindset and it would hod, and you'd be able to do the things you expect with the answers.
21:03:30 <edwardk> er hold
21:04:12 <edwardk> jrmole: ML looks horrible to me after Haskell.
21:04:48 <jrmole> yeah, i have to use it for a class next year...
21:04:57 <edwardk> jrmole: you're better off trying to keep the vending machine metaphor in mind (from wikipedia) while playing with linear types.
21:05:26 <edwardk> you can then think of affine types as types where you are allowed to throw away your change or candy.
21:06:45 <jrmole> sorry, what's an affine type?
21:06:55 <edwardk> er sorry got ahead of myself
21:08:10 <edwardk> linear types disallow both th \x -> (x,x) contraction and \x->12 weakening case. affine disallows just the contraction. relevant disallows just the weakening. so you know affine types will be used at MOST once, and relevant types will be used at LEAST once. they are tied pretty closely to the haskell concepts of non-updating thunks in STG and strictness analysis respectively.
21:08:50 <edwardk> er, though i guess the former concept is a little obscure.
21:09:06 <jrmole> i'm somewhat familiar, enough to see the connection
21:10:01 <freeone3000> What file extenstion do haskell files normally have?
21:10:22 <edwardk> .hs
21:10:36 <lispy> freeone3000: but also .lhs
21:10:40 <freeone3000> Thanks.
21:10:59 <edwardk> ah true, but the latter ones follow the literate syntax, so be careful
21:14:22 <edwardk> you know you've been in haskell too long when you start adding sexy types and sexy type inference to an intermediate language because its too verbose...
21:15:53 <lispy> you might be a haskeller if ...
21:15:54 <freeone3000> ...Improper indentation. Of course, I missed the part in the gentle introduction about its whitespace significance...
21:16:23 <lispy> yeah, once you get the haskell layout it's handy...but until then it's just this nightmare that keeps rearing it's head :(
21:16:33 <edwardk> hehehe
21:16:59 <edwardk> layout == python done right
21:17:07 <freeone3000> Is there a good reason it's whitespace significant?
21:17:32 <lispy> freeone3000: it lets you get rid of a lot of special syntax for bracketing code blocks
21:17:35 <edwardk> freeone3000: yeah, its a hell of a lot easier to read =)
21:17:35 <_dolio> You can program without whitespace significance if you want.
21:17:47 <freeone3000> _dolio: Please tell.
21:17:55 <lispy> { ... ; ... }
21:18:20 <edwardk> freeone3000: you can use { } wherever layout would kick in,and separate statements with ;'s inside it
21:18:23 <_dolio> f m n o = do { a <- m ; b <- n ; c <- o ; return a + b + c }
21:18:27 <lispy> > let { foo 0 = 1; foo 2 = 3; foo 3 = 4} in foo 2
21:18:28 <lambdabot>  3
21:18:57 <freeone3000> Nevermind. That's worse.
21:19:00 <jrmole> i think one of haskell's minor advantages is that the code looks cool in layout form, especially with colored syntax highlighting :)
21:19:04 <_dolio> :)
21:19:14 <edwardk> jr: yeah =)
21:19:21 <jrmole> and i've occasionally heard comments by non-haskellers to that effect
21:19:24 <_dolio> Yikes, how did I become _dolio?
21:19:29 <edwardk> hrmm. thats what i need to add to the toy language, LAYOUT! =)
21:20:03 <edwardk> yay for making the language nigh-unparsable by traditional grammars!
21:20:10 <jrmole> also has anyone done a proper "you might be a haskeller if ..." list?
21:20:22 <lispy> jrmole: i've sent haskell snippets to non-programmers asking for clarification about the spec. before.  "If I do the following definitions is this correct?"  and they look at it thniking it's just me asking formally and they're really doing a code review :)
21:20:28 <jrmole> i always assumed layout was handled with a special lexer
21:21:26 <edwardk> can be i guess, i used to do that for python style indentation before i learned the wonders of layout
21:22:04 <freeone3000> For a function `indexof :: [Char]->Char->Integer->Integer` why does it error on `indexof [x:xs] c i` at the []?
21:22:39 <lispy> @type ['a':"bc"]
21:22:40 <lambdabot> [[Char]]
21:22:46 <edwardk> indexof (x:xs) c i
21:22:57 <freeone3000> Ah. Thanks.
21:23:00 <foxy__> edwardk, I wrote a natural language parser which is essentially a very simple sub-structural theorem prover
21:23:17 <edwardk> foxy: lambek calculus style?
21:23:31 <foxy__> categorial grammar
21:23:34 <foxy__> yeah
21:23:42 <edwardk> foxy: *nods*
21:23:52 * edwardk <<- works with linguists all day
21:24:26 <foxy__> edwardlk, I like it because you write types and terms, the types are my own and the terms are haskell code loaded at runtime with hs-plugins
21:24:29 <edwardk> funny how much of the substructural stuff has linguistic roots
21:24:33 <freeone3000> ...I bet calculas is coming in handy, but... nah.
21:24:34 <jrmole> lispy, http://haskell.org/papers/NSWC/jfp.ps mentions the "haskell looks like high-level specs" feature/issue in the context of naval surface warfare :)
21:24:35 <edwardk> heh
21:24:54 <lispy> nice
21:25:09 <lispy> issue? so they had problems with it?
21:25:20 <jrmole> the quote "too cute for its own good" comes up
21:25:24 <edwardk> heh
21:25:25 <lispy> huh
21:25:39 <edwardk> miltary folks think everything should look like ada ;)
21:25:45 <jrmole> section 7
21:26:05 <jrmole> i had the same reaction reading quicksort in haskell for the first time
21:26:30 * lispy sits down to read it
21:26:31 <edwardk> haha haskell LOC 85, c++ 1105, ada9x: 800. lines of documentation haskell 465, c++ 130
21:26:34 <lispy> thanks, bbiab
21:27:55 <jrmole> this is in contrast to the responses i get from pure maths people with no programming experience
21:28:08 <jrmole> which is usually... "there are languages that *aren't* like that? why would you ever use one of those?"
21:28:23 <edwardk> haskell typically does what a mathematician thinks it should do, thats always neat ;)
21:28:30 <jrmole> yeah
21:28:51 <freeone3000> Quicksort in haskell is three lines. Nice.
21:29:02 <freeone3000> What's wrong with http://pastebin.ca/158474 ?
21:29:02 <edwardk> heh, i had to explain call by reference to a mathematician who had only really used scheme before, it hurt
21:29:07 <jrmole> haskell makes it easy to write code that is self-evidently correct and has inscrutable performance
21:29:10 <freeone3000> As in, it doesn't compile.
21:29:27 <jrmole> whereas, as many have commented, C programmers don't care so much if things are wrong as long as they're fast
21:29:30 <edwardk> what do you mean this method returns a new object, and that one modifies in place. i asked for the difference of my two sets each time just with different methods...
21:29:32 <freeone3000> ...And I should specifiy the error too, shouldn't I.
21:30:21 <edwardk> jrmole: heh, thats  why i'm obsessed with the substructural stuff. if i can prove relevance in the type level then i know it'll evaluate strictly. the trick will be not crufting up the syntax too much
21:30:40 <freeone3000> http://pastebin.ca/158477 then.
21:30:49 <jrmole> can you infer relevance generally?
21:31:01 <dolio> I seem to recall seeing a web page a while back claiming to have written quicksort in 4 lines of C.
21:31:22 <jrmole> freeone3000, function application isn't written that way
21:31:22 <edwardk> jrmole: seems so so far, possibly with an occasional type annotation
21:31:23 <dolio> But the third line was left blank as an exercise for the reader, and the rest didn't do much interesting.
21:31:29 <jrmole> it's (f x y z) rather than f(x y z)
21:31:46 <dolio> And I was never able to find the page after the author was allegedlly going to release the third line.
21:32:12 <freeone3000> jrmole: Ah. Thanks.
21:32:31 <edwardk> freeone3000: putStr $ indexof "foo" 'o' 0     or   putStr (indexof "foo" 'o' 0)
21:32:32 <jrmole> there are probably IOCCC-level ways to write quicksort in 4 lines of C, but the remarkable thing about the haskell version is that, if you choose certain natural readings of Haskell syntax, it's basically how you'd explain the algorithm in words
21:32:46 <edwardk> yeah =)
21:32:54 <dolio> That's true.
21:33:11 <jrmole> so it's not only concise, but clear, whereas C can rarely do both and often neither
21:33:22 <edwardk> though its harder to get a good median of three randomm selecting implementation that works over an array like a fast c++ one.
21:33:44 <edwardk> unfortunately haskell's array syntax is shit
21:33:53 <jrmole> yeah
21:34:14 <jrmole> functional arrays are kind of dodgy, anyway
21:34:50 <edwardk> well, the imperative IO(U)Array and ST(U)Array ones have to rely on some pretty bloated function names to get anything in or out
21:35:05 <jrmole> maybe some magical syntax / type voodoo will someday allow us to treat arrays, tree-backed finite maps, and "real" (lambda-abstracted) functions with the same syntax
21:35:07 <edwardk> there the C/Haskell impedence mismatch swings in the other languages favor for terseness
21:35:32 <jrmole> so Array i e becomes just i -> e
21:36:00 <edwardk> hrmm, some sort of Array as Arrow concept?
21:36:17 <jrmole> hmm, not really
21:36:32 <jrmole> just reflecting on the fact that an array is, semantically, a function from its index type to its element type
21:36:37 <edwardk> would almost work as an arrow, except the input has to be of type Ix, oh well
21:36:43 <edwardk> sre
21:36:46 <edwardk> er sure
21:36:57 <edwardk> hence why i was thinking about it as an arrow for a second there
21:37:14 <jrmole> yeah, but it's not as general as an arrow, as you said
21:37:22 <edwardk> but the bubble burst when i realized the Ix requirement
21:37:38 <freeone3000> How would I print the Integer?
21:37:56 <edwardk> heh,  i'll let someone else field the IO question ;)
21:38:32 <jrmole> @type print
21:38:34 <lambdabot> forall a. (Show a) => a -> IO ()
21:38:57 <jrmole> since a Show instance is defined for Integer, you can pass one to print, and get an IO action which prints that integer
21:39:13 <freeone3000> ...
21:39:14 <dons> there's a nice array preprocessor tool though
21:39:18 <freeone3000> Can I copy-paste that?
21:39:31 <dons> that let's us write: f[|x|] := y or something similar
21:39:34 <jrmole> freeone3000, what do you mean?
21:39:43 <edwardk> dons: yeah i looked at it, but its yet another dependency
21:39:43 <freeone3000> jrmole: I have no idea what that meant...
21:39:57 <jrmole> sorry
21:39:57 <dons> edwardk: sure
21:40:11 <freeone3000> As opposed to putInteger(x), which doesn't exist, I should do Show x => x -> IO()?
21:40:11 <dons> ?wiki Modern_array_libraries#The_Haskell_Array_Preprocessor_.28STPP.29
21:40:12 <lambdabot> http://www.haskell.org/haskellwiki/Modern_array_libraries#The_Haskell_Array_Preprocessor_.28STPP.29
21:40:27 <edwardk> dons: and it seemed to have a lot of baggage associated with it in terms of other array libraries, etc
21:40:38 <jrmole> it means that print is a function, which takes a "showable" type, and does some IO on it (namely printing it)
21:40:45 <edwardk> its existence seems more like an excuse NOT to solve the problem than a solution  ;)
21:40:49 <jrmole> you would just write (print x)
21:41:00 <jrmole> that's a type signature, not an expression
21:41:03 <freeone3000> Oh. Wow. That's simpler than I would've thought. Thanks.
21:41:13 <jrmole> no prob
21:41:34 <freeone3000> Yay! I wrote a string processing function!
21:41:41 <freeone3000> indexof().
21:41:53 <freeone3000> (I bet it's already done. I don't care. It's good practice.)
21:41:57 <dons> yes. a nice cabalised library providing a better interface would be _very_ useful
21:41:59 <jrmole> Haskell is great for prototyping because it makes printing / parsing basic types, and ones derived from those such as tuples, lists, etc, fairly trivial
21:42:11 <edwardk> dons: now now =)
21:42:43 <jrmole> whereas in C you'd need many lines of char* arithmatic with lurking overflow / corner-case bugs, and in perl it would be only one line, but that line would be a regexp indistinguishable from linenoise :)
21:43:00 <Eidolos> Be nice to Perl. :(
21:43:11 <jrmole> hey, i like perl
21:43:21 <freeone3000> I like python. Python and haskell shall be my new languages.
21:43:27 <edwardk> dons: i still think that [<operator symbols> <operator symbols] should be an honorary binary operator to make array type stuff easier to work with.
21:43:34 <freeone3000> Perl is for those unused keys.
21:43:42 <freeone3000> For instance, your zip-operator key.
21:44:03 <jrmole> for example, it's great for ugly string processing, which has no theoretically "right" solution
21:44:20 <edwardk> so you could then define ([. .]) to get an operator foo [.a.]     or one for foo[|bar|]
21:44:46 <Eidolos> Perl has the CPAN too.
21:45:10 <edwardk> heh, i program in CPAN, perl is just surface syntax ;)
21:45:25 <Eidolos> hehe
21:45:32 <Eidolos> That's the whole idea isn't it.
21:45:36 <edwardk> yeah
21:45:50 <edwardk> moving to other languages i always feel crippled by the lack of cpan
21:46:00 <freeone3000> What's CPAN good for?
21:46:11 <jrmole> freeone3000, everything ;)
21:46:14 <Eidolos> freeone3000: Depends, what do you need to do? Actually, it doesn't depend.. hehe
21:46:18 <edwardk> well, if you need to do it there are typically 8 sets of modules for doing it in CPAN already written
21:46:22 <jrmole> if it can be interfaced to, Perl has a module that does it
21:46:36 <freeone3000> Ah. So it's like the Java standard library, minus the idioticy.
21:46:44 <Eidolos> Times a thousand.
21:46:44 <freeone3000> (Is that last one spelled right?)
21:46:49 <Eidolos> idiocy
21:46:52 <freeone3000> Thanks.
21:46:57 <freeone3000> ...Wow, they must have some hard drive space.
21:46:59 <edwardk> freeone: its like every piece of glue to every api you could want
21:47:00 <jrmole> freeone3000, it has a lot more specific things too
21:47:05 <jrmole> like interfaces to specific webapp's APIs
21:47:23 <jrmole> would be good for a lot of "Web 2.0"-type stuff
21:47:29 <edwardk> freeone: all rolled up into a public repository
21:47:31 <jrmole> gluing google maps onto the side of a dead cat or something
21:47:48 <edwardk> yeah, too bad the current javascript JSAN isn't nearly up to snuff by comparison
21:47:49 <lispy> omg, the analysis in this paper is terrible :)
21:47:59 <edwardk> lispy: which?
21:48:01 <lispy> rapide didn't even have an implementation!
21:48:09 <edwardk> ahh
21:48:09 <lispy> the naval one
21:48:10 <jrmole> yeah, well, they gave it 0 points ;)
21:48:10 <edwardk> that one
21:48:22 <lispy> yeah, i mean the authors did a good job
21:48:28 <lispy> but the study was very poorly conducted
21:48:52 <jrmole> yeah, i have a language which can solve their problem in one line, which is also five lines of documentation, but i'm not quite done with the interpreter :)
21:50:06 <lispy> eheh
21:50:18 <edwardk> lispY; yeah its basically heh, look we wrote this really short code in haskell, and no one believed it was code. 'morons', the end. ;)
21:50:24 <lispy> "import geo-server; run server"
21:51:34 <edwardk> lisp nah you got it wrong, the CPAN version would be "use GEO::Server; run_server()" =)
21:52:31 <lispy> ah, what is cpan?
21:52:52 <edwardk> perl's cabal-get ;)
21:53:28 <lispy> ah
21:54:22 <glguy> what is this study you guys are talking about?
21:55:07 <jrmole> http://haskell.org/papers/NSWC/jfp.ps
21:55:42 <edwardk> hrmm i should slap together a pdf title reader for lambabot
21:55:54 <glguy> that's not a pdf tho :)
21:55:56 <edwardk> yeah
21:56:01 <edwardk> ps is harder =)
21:56:30 <edwardk> but pdf has a nice set of annotations i could seek to with a couple of short partial gets via http/1.1
21:56:37 <edwardk> so it wouldn't be so bad on most web servers.
21:56:48 <edwardk> no need to download the whole paper to get its title
21:57:05 <dolio> I like how the fresh graduate who learned haskell in the 8 days before the project has the second most concise solution.
21:57:19 <edwardk> heh
21:57:20 <dolio> Beaten only by one of the authors, also using Haskell. :)
21:58:04 <dolio> He slacked on the documentation, though, apparently.
21:58:22 <edwardk> the haskell one?
21:58:39 <dolio> #10: 112 lines of documentation.
21:58:40 <Stinger_> they were both haskell werent they?
21:58:48 <edwardk> ah missed that one in the list
21:58:57 <dolio> As opposed to 465 for the first haskell one, or 714 for the ada one.
21:59:12 <dolio> Although, the relational lisp guy only wrote 12 lines of documentation.
21:59:18 <dolio> I wonder why he bothered.
22:00:07 <lispy> this paper makes me lol
22:00:20 <edwardk> lispers count ()'s towards their documentation character count ;)
22:00:35 <jrmole> i wonder if the haskell guys counted typesignatures as documentation
22:00:41 <edwardk> everything in ()'s is self explanatory didn't ya know?
22:01:13 <dolio> I think they said that type signatures were counted as code, at least in the first one.
22:01:25 <lispy> yeah, they counted it as optional code
22:01:37 <Cale> jrmole: no. If you remove the type signatures and synonyms, it was only 39 lines of code for doing real work, and 20 for encoding the input data usefully.
22:01:38 <jrmole> docu-code
22:01:52 <dolio> "29 [of the 85 lines] were either type synonyms or type signatures."
22:03:12 <jrmole> i guess they're more like compile-time assertions
22:03:25 <Cale> yeah
22:03:32 <lispy> i like how dons puts it, machine checkable documentation
22:03:37 <jrmole> yeah
22:04:10 <edwardk> i like haskell's types, its like taking eiffel's design by contract to the logical extreme.
22:04:45 <edwardk> er they're
22:04:49 <Stinger_> oh good lord, an awk solution?
22:04:54 <jrmole> it's pretty difficult to explain why haskell's types are more useful than the standard minimalist C type system
22:05:09 <jrmole> but it seems to come naturally after working with the language for a short period of time
22:05:13 <edwardk> until you use them
22:05:17 <jrmole> yeah
22:05:37 <lispy> i think it's because algebraic types are harder in C, a lot more manual effort is required
22:05:38 <edwardk> well, to me it all comes down to ; in c. just about anything can come before it and anything can come after it.
22:05:51 <jrmole> i guess a good example would be to take some messy C code with unioned structs, tagged by their first element or something
22:05:56 <edwardk> you get that with monads and do-notation, but its more contained.
22:05:59 <edwardk> you use it less
22:06:22 <jrmole> and show how in haskell, the compiler checks it for you, and disassembles the structs  through pattern matching for free :)
22:06:28 <lispy> yeah, when you enter the IO monad things can get scary, but otherwise it feels so safe
22:06:54 <edwardk> heh i love how to a haskeller the IO monad is a scary dark place no one like to go.
22:07:50 <edwardk> you want to leap out of the dark treacherous imperative parhways of main into the bright sunny pastures of function-land where referential transparency and light and sunshine are
22:08:23 <lispy> @karma+ referential_transparency
22:08:24 <lambdabot> referential_transparency's karma raised to 1.
22:08:32 <lispy> oh, that should be much higher
22:08:50 <edwardk> @karma- scary_IO_monad
22:08:51 <lambdabot> scary_IO_monad's karma lowered to -1.
22:09:01 <dolio> Man, I really wonder what those 12 lines of documentation were.
22:09:06 <edwardk> hahahaa
22:09:08 <dfeuer> @karma- monomorphism_restriction
22:09:09 <lambdabot> monomorphism_restriction's karma lowered to -1.
22:09:13 <dolio> I hope they were something like "add 1 to x".
22:09:22 <dfeuer> @karma- Haskel98modules
22:09:23 <lambdabot> Haskel98modules's karma lowered to -1.
22:09:34 <jrmole> i hope they were a synthesis for LSD, or a poem about the end of the world
22:09:59 <lispy> reading that makes me wonder if i should switch to literate haskell for my current prototype, but i don't really have latex (yet) on my work computer so it wouldn't buy me much :)
22:10:15 <lispy> which one had 12 lines of documentation?
22:10:22 <edwardk> lispY; lisp =)
22:10:23 <dolio> Relational lisp.
22:10:42 <edwardk> lisp + relational crap
22:10:53 <lispy> oh
22:10:58 <vincenz> edwardk: regarding ; in haskell, this is not true, you can only perform actions of the same monadic type
22:11:25 <edwardk> vincenz: sure. there is still some type checking, but the divide is wider
22:11:58 <ndm> hmm, its 6am, i think i should go to bed...
22:12:00 <jrmole> it still typechecks the flow of values from one imperative statement to the next
22:12:14 <edwardk> vincenz: its really useful for mixing operations on different monads, and making you think about where you are, but then nested monads can be a bit of a mis-feature when it comes to getting code written.
22:12:42 <dfeuer> What are you people talking about?
22:12:47 <jrmole> IO isn't annoying because of lack of types, it's annoying because of lack of referential transparency
22:12:51 <audreyt> Igloo: regarding http://paste.lisp.org/display/25124
22:13:06 <edwardk> jr: yeah
22:13:21 <audreyt> Igloo: is there plan to add back C:\ghc\lib\i386-mingw-unknown\include to incpath? also, will the final .msi build include extra libraries?
22:13:21 <dfeuer> IO is annoying because it's the part that has to meet management's specs :-P
22:14:16 <audreyt> I don't think IO is annoying... it's a pretty sweet fast OO language
22:14:25 <audreyt> it's the small language within Javascript that struggles to get out...
22:14:43 <vincenz> :D
22:14:47 <vincenz> audreyt: they mean the IO monad
22:14:56 <audreyt> I know :)
22:15:01 <edwardk> hehehe
22:15:30 <dfeuer> Does GHC have call/cc in the IO monad?
22:15:41 <dfeuer> (do any Haskells?)
22:15:55 <jrmole> dfeuer, there's a Cont monad (which doesn't answer your question, i know)
22:15:57 <lispy> not sure, but there is a call/cc monad and a monad transformer
22:15:58 <edwardk> it has a Cont monad for it
22:16:01 <jrmole> i think it has an associated transformer
22:16:10 <edwardk> you can wrap a ContT around IO to get them
22:16:11 <dfeuer> Meaning....
22:16:20 <vincenz> meaning no
22:16:24 <vincenz> cause ContT is layered OVER IO
22:16:30 <vincenz> if I get it right
22:16:34 <edwardk> yeah
22:16:44 <audreyt> hmm? ContT IO works
22:16:48 <dfeuer> ....
22:16:50 <vincenz> contT is one of those few monads that's non commutable
22:17:00 <dfeuer> vincenz, explain?
22:17:02 <vincenz> audreyt: your io actions are not in the continuation, however
22:17:16 <vincenz> dfeuer: ReaderT StateT IO == StateT ReaderT IO
22:17:17 <vincenz> for instance
22:17:26 <vincenz> and a lot of other monad transformers are commutable as well
22:17:30 <edwardk> sure, its arguablly a 'partial' continuation w.r.t. world effects.
22:17:34 <vincenz> stateT contT != contT statT
22:17:36 <dfeuer> eeeenteresting.
22:17:38 <jrmole> vincenz, i thought that was always true, at least on the type level
22:17:39 <audreyt> vincenz: define :in the continuation: ?
22:17:47 <jrmole> by "==" do you mean isomorphism?
22:17:50 <vincenz> jrmole: it is never true on the typelevel
22:17:58 <edwardk> jrmole: well, some monads have commuting semantics, even if the types are distinct
22:17:59 <vincenz> but usually on the semantical level
22:18:02 <jrmole> yeah, that's what i meant... read the !=
22:18:17 <jrmole> the semantics commute because of classes like MonadState, etc.
22:18:55 <thetallguy> ?type map
22:18:57 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:19:07 <edwardk> well, even in the absence of those, the choice to lift one over the other is arbitrary in some cases. the type classes just make that obvious
22:19:10 <thetallguy> ?type (++)
22:19:12 <lambdabot> forall a. [a] -> [a] -> [a]
22:19:19 <thetallguy> ?type ap
22:19:21 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:19:21 <edwardk> and less painful
22:19:28 <jrmole> the type classes exhibit the isomorphism, then
22:19:31 <dfeuer> How's it work out that the semantics commute in useful cases?  Just luck?
22:19:31 <edwardk> yeah
22:19:48 <dfeuer> humph.
22:19:48 <jrmole> dfeuer, it means the two monads do orthogonal things
22:19:55 <jrmole> which is often the case in useful cases
22:20:05 <edwardk> dfeuer: wadler has a nice paper on composing monads that can be mostlly read in the context of the current monad stuff without losing any thing.
22:20:14 <jrmole> the only time i've used a monad transformer so far was StateT Error, which does not commute
22:20:15 <edwardk> @google wadler composing monads
22:20:19 <lambdabot> http://citeseer.ist.psu.edu/steele94building.html
22:20:25 <edwardk> woops
22:20:27 <edwardk> not that one =)
22:21:59 <edwardk> http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.ps is the one i meant, but http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf  is also good
22:22:59 <edwardk> they are a little dated in the examples, and i think he makes a misclaim that you can make a strictness monad and the bag and set examples don't follow the laws, etc.
22:23:03 <edwardk> but the ideas are right
22:23:30 <edwardk> wow i guess thats a lot of caveats
22:23:41 <thetallguy> ?type ap (++) . map
22:23:43 <lambdabot> forall b. (b -> b) -> [b] -> [b]
22:24:22 <Cale> > (ap (++) . map) (+10) [1,2,3,4,5]
22:24:24 <lambdabot>  [1,2,3,4,5,11,12,13,14,15]
22:24:43 <edwardk> cute
22:24:54 <thetallguy> The question is, why doesn't that work on my system?
22:25:00 <dolio> > (\f l -> l ++ map f l) (+10) [1..5]
22:25:01 <lambdabot>  [1,2,3,4,5,11,12,13,14,15]
22:25:02 <Cale> import Control.Monad.Reader
22:25:21 <Cale> or Control.Monad.Instances, I think, if you're using development GHC.
22:25:26 <thetallguy> Ahah
22:25:38 <thetallguy> I was using Control.Monad
22:25:48 <thetallguy> which also as ap defined.
22:25:50 <thetallguy> Thanks.
22:25:53 <edwardk> yeah that got you ap, but not the appropriate monad =)
22:25:55 <Cale> right, it's that ap
22:26:08 <Cale> it's just that the monad that's in use is the transparent version of the reader monad
22:26:16 <Cale> instance Monad ((->) e)
22:27:43 <lispy> shouldn't that be the function or application monad?
22:28:16 <Cale> > (do x <- (+1); y <- (+2); (*) (x+y)) 5
22:28:18 <lambdabot>  65
22:28:28 <Cale> it behaves exactly like Reader :)
22:28:39 <lispy> what does that mean?
22:28:57 <Cale> hm?
22:28:59 <Cale> that code?
22:29:09 <lispy> "it behaves exactly like Reader :)"
22:29:15 <Cale> ah
22:29:24 <Cale> The Reader monad in Control.Monad.Reader
22:29:32 <glguy> > concat $ sequence [id, map (+10)] [1..5] -- closest I could come ;)
22:29:33 <lambdabot>  [1,2,3,4,5,11,12,13,14,15]
22:29:34 <dolio> Reader is: newtype Reader r a = Reader {runReader :: (r -> a)}
22:29:40 <Cale> right
22:29:52 <dolio> So the reader monad Reader r is equivalent to (->) r
22:29:59 <Cale> dolio: yeah
22:30:11 <edwardk> yeah it just requires the crufty runReader stuff
22:30:18 <Cale> http://www.nomaware.com/monads/html/readermonad.html
22:30:23 <lambdabot> Title: The Reader monad, http://tinyurl.com/gplhc
22:31:12 <lispy> so you'd use reader to manage "global" state?
22:31:24 <jrmole> global non-mutable state perhaps
22:31:28 <glguy> Cale: After programming in J, using ap in (r ->) becomes a lot more intuitive
22:31:43 <jrmole> i can see why lambdabot's @pl likes it
22:33:12 <dons> glguy: heh
22:33:58 <jrmole> @pl a 0 n = n+1; a m 0 = a (m-1) 1; a m n = a (m-1) (a m (n - 1))
22:33:58 <lambdabot> (line 1, column 12):
22:33:58 <glguy> tacit programming in J makes Reader monad programming seem way too verbose :)
22:33:59 <lambdabot> unexpected ";"
22:33:59 <lambdabot> expecting digit, variable, "(", operator, "+", "-" or end of input
22:34:12 <edwardk> i want an untyped non-strict impure programming language... just to plug the hole in the language chart ;)
22:34:15 <jrmole> @pl { a 0 n = n+1; a m 0 = a (m-1) 1; a m n = a (m-1) (a m (n - 1)) }
22:34:15 <lambdabot> (line 1, column 1):
22:34:15 <lambdabot> unexpected "{"
22:34:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
22:34:18 <jrmole> aww
22:35:13 <lispy> edwardk: and call the language undef?
22:35:21 <dons> ?pl let a 0 n = n+1; a m 0 = a (m-1) 1; a m n = a (m-1) (a m (n - 1)) in undefined
22:35:21 <lambdabot> undefined
22:35:22 <jrmole> i'm sure you can write perl code that executes that way
22:35:26 <lispy> edwardk: because so many things will have undefined results? :)
22:35:29 <edwardk> lispy: heh.
22:35:37 <jrmole> ?pl let a 0 n = n+1; a m 0 = a (m-1) 1; a m n = a (m-1) (a m (n - 1)) in a
22:35:38 <lambdabot> ap ((.) . ap id (subtract 1)) ((. subtract 1) . join id)
22:35:41 <jrmole> there we go
22:35:52 <jrmole> not as bad as i expected
22:35:58 <dons> wow, pl did a pretty good job there
22:36:09 <edwardk> lispy: well, even a dynamicly typed non-strict programming language would be fun
22:36:33 <jrmole> strictness and static typing seem pretty orthogonal to me
22:36:35 <edwardk> bitch to code in =)
22:36:50 <edwardk> jr: sure
22:36:59 <jrmole> it would be annoying because your type errors would sometimes be lazed away
22:37:09 <jrmole> but runtime type errors are already plenty annoying
22:37:13 <edwardk> jr: yeah that i hink is why no one is there in the space now.
22:38:51 * dfeuer returns.
22:38:54 <dfeuer> Sorry I vanished.
22:39:44 * edwardk binds dfeuer and passes him to the next function.
22:40:34 <dolio> Wow, J is quite something.
22:40:42 <dolio> "quicksort =: ($:@(}.#~{.>:}.),{.,[:$:}.#~{.<}.)`]@.(2:>#)"
22:40:52 <glguy> OMG
22:41:00 <glguy> I put that in the wikipedia
22:41:19 <glguy> that's my example of a tacit implementation of quicksort in J
22:41:24 <dylan> looks like cartoons swearing.
22:41:31 <glguy> small friggin world :)
22:41:39 <glguy> I guess in all fairness I did bring up J
22:41:44 <glguy> but still :)
22:41:47 <thetallguy> looks like perl
22:41:49 <dolio> :)
22:41:49 <edwardk> glguy: heh
22:41:58 <dons> very pointfree-ish
22:42:06 <glguy> it's totally point-free
22:42:09 <glguy> that function is at least
22:42:18 <glguy> I'll explain it if anyone wants
22:42:24 <dfeuer> So J is not a practical programming language, apparently.
22:42:25 <vegai> that indeed is quite something
22:42:35 <thetallguy> Not sure I have the hour to spend listening.
22:42:40 <glguy> lol
22:42:42 <glguy> it's simple
22:42:42 <edwardk> perl -e '($:@(}.#~{.>:}.),{.,[:$:}.#~{.<}.)`]@.(2:>#)"'
22:42:42 <edwardk> Array found where operator expected at -e line 1, at end of line =)
22:42:53 <thetallguy> lol
22:42:54 <glguy> most J isn't that bad
22:43:01 <glguy> I just crammed the whole thing on one line
22:43:14 <dfeuer> Is it actually intended to be used, or is it a joke language?
22:43:17 <thetallguy> What's that 2 doing in there?
22:43:30 <glguy> it's very popular in new york
22:43:36 <thetallguy> Is that part of splitting the list?
22:43:38 <glguy> financial modeling and stuff
22:44:20 <glguy> 2:># means, if the length is greater than do, then do the first part
22:44:21 <dfeuer> Seriously?
22:44:25 <glguy> otherwise do the second
22:44:31 <glguy> ` separates the parts
22:44:34 <lispy> ?bf ($:@(}.#~{.>:}.),{.,[:$:}.#~{.<}.)`]@.(2:>#)
22:44:34 <lambdabot> Done.
22:44:42 <dfeuer> Why would anyone ever want to write in such a language?
22:44:59 <glguy> @. is the switch statement
22:44:59 <lambdabot> compose module failed: IRCRaised Parse error: "is"
22:45:03 <edwardk> dfeuer: easier than brainf*ck? =)
22:45:05 <glguy> the ] next to it is the "id" function
22:45:35 <glguy> $:@(}.#~{.>:}.)     ,{.    ,[:$:}.#~{.<}.
22:45:39 <dfeuer> edwardk, I'm trying to determine whether people actually /use/ this thing, not whether they write programs in it to challenge themselves.
22:45:53 <glguy> stuff less than pivot,   pivot,   stuff greater than pivot
22:45:57 <thetallguy> Sounds like it really needs some unicode
22:46:05 <thetallguy> or just plain typesetting.
22:46:19 <jrmole> ugh, it's like APL in ASCII
22:46:34 <dolio> Wiki does say it's "a synthesis of APL".
22:46:34 <edwardk> jr: very much so, inspired by even
22:46:35 <glguy> jrmole: it is the successor to APL, actually
22:46:36 <jrmole> thetallguy, APL had a boatload of special characters
22:46:44 <jrmole> yeah, i read that, 's why I said it ;)
22:46:58 <dolio> :)
22:47:14 <lispy> is using the Writer monad for logging actually useful in practice?  all the logging i see in real apps is done via putStrLn in the IO monad
22:47:29 <glguy> [: $: }. #~ {. < }.   means recurse on the tail of the list (not the pivot) filtered by things greater than the pivot
22:47:42 <lispy> moreover, besides using a list (which has slow append) how do you get the writer monad to collect up the log?
22:48:02 <glguy> cap self-reference tail reversed-copy pivot less-than tail
22:48:19 <lispy> what language is that?
22:48:22 <glguy> J
22:48:27 <lispy> ah
22:48:33 <jrmole> you can use a ShowS-like function composition
22:48:59 <jrmole> "The follow is an implementation of quicksort demonstrating tacit programming. Tacit programming involves chaining functions together into trains and not refering explicitly to any variables. J's support for forks and hooks dictate rules on how arguments applied to this function will be applied to its component functions."
22:49:16 <glguy> in J, (f g h) x where f g h were functions and x is a value means: (f x) `g` (h x)
22:49:42 <jcreigh> glguy: But seriously, do you ever reach the point where you can look at all that (*&$% and say immediately, "Oh, that's quicksort!"? Do it ever become *readable*?
22:49:44 <glguy> and (f g) x means  x `f` (g x)
22:49:57 <glguy> jcreigh: yeah, it does, and when you type it into the interpreter, it can box it for you
22:49:59 <jrmole> it's almost like they found the concept of "higher-order function" and decided to give it three different, bizarre names
22:50:26 <glguy> it nests everything correctly so that it makes sense
22:51:25 <glguy> arithmetic means is simply   (sum divide length) or (+/ % #)
22:51:40 <glguy> as an example of (f g h) x
23:00:22 <dolio> Wow, it has an opengl binding.
23:01:09 <dfeuer> glguy, in what sense is this readable?
23:01:23 <dfeuer> And do people use it for real programming?  And if so, why?
23:01:28 <glguy> it's a serious programming language, my one-line quick sort is just a gross example of how far you can take it
23:01:38 <glguy> do people actually use perl in real life?
23:01:42 <newsham> "sum divide length" does have an elegance to it
23:01:59 <dolio> There's another quicksort on the wikipedia page that isn't nearly as ridiculous.
23:02:16 <jrmole> it's still fairly bad though
23:02:24 <jrmole> in what ways is this language better than the alternatives?
23:02:26 <glguy> newsham: or geometric mean (aritmetic mean under reciporcal) (+/ % #) &. %
23:02:41 <jrmole> in particular, why are all of the built-ins chunks of punctuation?
23:02:53 <glguy> all of the primitives are either 1 or 2 characters
23:03:05 <glguy> some have letters, like   i.   for example
23:03:11 <glguy> i. 5   returns 0 1 2 3 4
23:04:07 <lispy> glguy: can you build a J interpreter in haskell?
23:04:15 <lispy> you could make it partof lambdabot
23:04:49 <glguy> it would probably be easiest to just have lambdabot pass it off to the cli version of J
23:04:58 <lispy> ah yup
23:04:59 <glguy> and have it strip out the Foreign function
23:05:00 <lispy> that wouldn't be hard
23:05:02 <glguy> and the Do function
23:05:18 <glguy> without the foreign function and do functions, you could not do system level access
23:05:23 <newsham> irc bots executing external programs..  always a good idea!
23:05:26 <newsham> what could possibly go wrong?
23:05:33 <jcreigh> lol
23:05:53 <int-e> there are worse things
23:06:02 <int-e> like using tcl for irc bots.
23:06:35 <jcreigh> @remember newsham irc bots executing external programs..  always a good idea! what could possibly go wrong?
23:06:35 <lispy> what about just making a bot that hands everything off to bash and then prints the output in irc?
23:08:06 <jcreigh> Hmm... lambdabot doesn't give a confirmation anymore...
23:08:28 <dons> right.
23:08:33 <lispy> ?vixen not feeling chatty?
23:08:34 <lambdabot> i think you know the answer to that one, silly
23:08:37 <dons> do you miss that?
23:08:46 <dons> too bad!
23:09:22 <jcreigh> dons: Ummm...what was wrong with it?
23:09:30 <dons> oh, just too noisy, I thought
23:09:42 <dons> I'm willing to revert it, if its important
23:10:19 <lispy> @dice 1d2
23:10:19 <lambdabot> 1d2 => 2
23:10:28 <freeone3000> @dice 5d12+5
23:10:28 <lambdabot> 5d12+5 => 33
23:10:51 <freeone3000> Skill check succeeds. :)
23:10:55 <glguy> but people use J because you can very quickly implement various math functions.  this function fit =.(%.(^/~>:)&i.&#)p.1+#   finds the smallest degree polynomial that fits a list of points and approximates the next one
23:11:08 <dons> obviously
23:11:17 <lispy> what is more clear?
23:11:20 <freeone3000> Of course not obviously.
23:11:23 <freeone3000> It comes from APL.
23:11:35 <jcreigh> dons: Well, IMO the confirmation is nice because then you know you got the command right, but that's just my 2 cents.
23:11:38 <freeone3000> Be grateful you can type it with a standard keyboard.
23:11:57 <dons> jcreigh: ok. i'll revert it in a day or two
23:11:58 <int-e> @wrongcommand
23:11:59 <lambdabot> Unknown command, try @list
23:12:08 <dons> int-e, you want that quiet too?
23:12:25 <dons>  i might switch it off
23:12:27 <int-e> lambdabot usually complains when things go wrong.
23:12:34 <int-e> naaa, I don't mind it at all.
23:12:37 <dons> maybe it shouldn't?
23:12:43 <lispy> it should
23:12:45 <dons> ok :)
23:13:09 <lispy> dons: one idea is to have some of the commands /msg people for confirmation
23:13:10 <int-e> you could turn off all lambdabot output and then let her silently go away. I'd miss her though.
23:13:29 <glguy> turn off lambdabot??
23:13:39 <lispy> yeah, do you use it?
23:13:40 <dons> now int-e is just getting wacky
23:13:41 <int-e> I was extrapolating.
23:13:52 <glguy> well... stop :)
23:13:58 <dons> you're scaring glguy
23:14:08 <glguy> > "don't kill me"
23:14:09 <lambdabot>  "don't kill me"
23:14:12 <dons> it's ok. lambdabot's not going away any time soon
23:14:45 <glguy> dons definitely can't kill lambdabot before he fixes ghci on openbsd
23:14:45 <lispy> or so you think...
23:14:46 <jrmole> lambdabot is female?
23:15:01 <lispy> ?vixen are you female?
23:15:02 <lambdabot> i truely am
23:15:06 <foxy__> @vixen
23:15:07 <lambdabot> you seem like the type of guy that would be into child porn... are you?
23:15:16 <jrmole> also, you should add an option that sings "daisy, daisy"
23:15:23 <freeone3000> @vixen
23:15:24 <lambdabot> Sex is the mysticism of materialism and the only possible religion in a materialistic society.
23:15:26 <dons> $ ghci
23:15:27 <dons> Prelude> putStrLn System.Info.arch >> putStrLn System.Info.os
23:15:27 <dons> i386
23:15:27 <dons> openbsd
23:15:30 <dons> works for me :P
23:15:40 <glguy> you are out-of-date
23:15:42 <glguy> ew, yuck
23:15:49 <glguy> old people, go back where you came from!
23:15:52 <jrmole> also, you can use notice instead of msg so the confirmation is private, but shows up in the channel window
23:16:03 <dons> maybe you're accidentally in the wrong period of history?
23:16:08 <glguy> what is this confirmation business you people are talking about
23:16:11 <dons> so it is _you_ who is out of date?
23:16:13 <jrmole> > System.Info.arch
23:16:14 <lambdabot>  Not in scope: `System.Info.arch'
23:16:18 <dons> ?version
23:16:18 <lambdabot> lambdabot 4p109, GHC 6.5 (OpenBSD i386 )
23:16:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:16:20 <newsham> is that why lambdabot is always nagging me?
23:16:53 <lispy> does lambdabot keep you awake at nighT?
23:17:06 <glguy> dons: i don't follow how I could be out-dated and you wouldn't be, regardless of what time period we are in
23:17:24 <newsham> only when I havent done the dishes
23:17:31 <glguy> are you proposing that I'm travelling the wrong direction through time?
23:17:34 <int-e> @localtime glguy
23:17:37 <lambdabot> Local time for glguy is Wed Aug 30 02:24:53 2006
23:17:38 <dons> glguy: exactly that.
23:17:43 <int-e> @localtime dons
23:17:43 <dons> @localtime dons
23:17:47 <lambdabot> Local time for dons is Sat Sep  2 16:13:34 2006
23:17:47 <lambdabot> Local time for dons is Sat Sep  2 16:13:34 2006
23:17:48 <dons> oh, tis me in the future it seems
23:17:55 <int-e> dons is way ahead of you.
23:17:57 <lispy> dang, big time diff
23:18:01 <glguy> I'm pretty sure that no timezone is going to put you back a year ;)
23:18:01 <dons> and ghci works where I am
23:18:08 <dons> here in the future
23:18:12 * dons waves from the future
23:18:15 <int-e> glguy: you're outdated. That time isn't real.
23:18:16 <newsham> its practically october in .au
23:18:38 <dons> he's in some kind of swirly time vortex
23:18:50 <dons> or maybe on the moon?
23:18:52 <glguy> I told my client to lie about my local time
23:18:57 <dons> where in moon time is still august
23:19:14 <dons> glguy: that's what you'd say if you were stuck in a time vortex, and didn't want us to know...
23:19:37 <lispy> glguy: remember in our time we already know you were stuck in a time vortex
23:20:14 <lispy> glguy: oh, and don't forget your sunscreen...
23:20:20 <lispy> you'll need it
23:20:37 <glguy> @localtime glguy
23:20:41 <lambdabot> Local time for glguy is Fri Sep  1 01:16:11 2006
23:20:49 <glguy> still wrong
23:21:02 <glguy> @localtime glguy
23:21:05 <lambdabot> Local time for glguy is Sat Sep  2 01:16:07 2006
23:21:09 <glguy> there we go
23:21:13 <dons> you can't move through time that fast without serious dislocation!
23:21:15 <dons> WARNING!
23:21:24 <jcreigh> glguy: Just run ntpd and be happy. :)
23:21:46 <glguy> I do run ntpd, actually, so i have no idea what is happening
23:22:04 <glguy> this computer seems to lose track of everything when the power goes out (i've replaced the battery)
23:22:07 <lispy> @localtime lispy
23:22:08 <lambdabot> Local time for lispy is Fri Sep  1 23:17:57 2006
23:22:16 <glguy> and the power went out this week
23:22:24 <lispy> booh! to the power
23:22:26 <glguy> and I don't live near this computer, so i had to wait for someone to turn it on
23:23:25 <int-e> hmm, if the time is too far out of sync, ntpd refuses to correct it, I believe.
23:23:29 <jcreigh> glguy: You might want to check if ntpd is actually running, because IME ntpd barfs and quits if the system clock is wildly off of what its peers are saying.
23:24:04 <glguy> 11981 ntpd
23:24:04 <glguy> 26318 ntpd
23:26:22 <glguy> actually, it looks like ntp had almost caught the clock up
23:26:35 <glguy> it was doing jumps every couple minute
23:26:36 <newsham> you could manually help the time daemon out by setting the clock
23:26:43 <glguy> i did
23:27:12 <lispy> you could write a program in J to get out and push :)
23:27:35 <glguy> J probably has a simple command tha tdoes what I want
23:27:36 * lispy had to get out and push today to get some file transfers to go over FTP
23:27:38 <glguy> I can't remember right now ;)
23:32:39 <dfeuer> The J command probably looks like line noise.
23:33:03 <glguy> it's probably  ?"   or something
23:33:05 <glguy> ;)
23:33:08 <dfeuer> You  could probably configure NTPD not to quit when the system clock is way off.
23:33:18 <glguy> my ntpd didn't quit
23:33:28 <glguy> it was just slowly adjusting the time :)
23:33:43 <newsham> meanwhile time marches on
23:33:47 <dfeuer> Right.
23:33:54 <dfeuer> Make it go quicker.
23:33:55 <dfeuer> yo
23:34:28 <glguy> i did
23:35:18 <dfeuer> Your mom!
23:35:57 <lispy> your mom went to college!
23:36:04 <newsham> she's still sleeping, want me to wake her, dfeuer?
23:36:14 <glguy> nudge her for me ;)
23:36:55 <dfeuer> Yeah, newsham, wake up your mom for me.  I wanna show her what toothpaste looks like.
23:37:27 <glguy> wth, are there a whole bunch of unemployed gay aspiring-scientologists watching TV at this time of night?
23:37:31 <newsham> i thought we were talking about glguy's mom
23:37:33 <glguy> these commercials are insane
23:37:36 <newsham> my mom's at home.
23:38:32 <dolio> I'm trying to figure out what sort of commercial would appeal to that demographic.
23:38:46 <newsham> something involving tom cruise, no doubt.
23:38:54 <glguy> lol, you're right
23:39:00 <dfeuer> glguy, they're trying to recruit gays to Scientology?
23:39:00 <glguy> i just described him to a 'T'
23:39:21 <dfeuer> No, I don't think a lot of gay guys would be drawn by Tom Cruise.  He's too damn scary.
23:39:22 <dolio> Hey, he's not gay, he's married to Katie Holmes! :)
23:39:23 <glguy> gay scientologist who just got fired
23:40:19 <glguy> the Katie Holmes thing is just a marketing gimic
23:40:52 <dolio> The real quality programming on this time of night are the infomercials.
23:41:14 <dfeuer> Cruise is just a nut.
23:41:27 <dolio> I like the one where you can get $1000 checks every week. All you have to do is call in and sign up for some part time job the specifics of which they won't reveal on the commercial.
23:41:43 <dfeuer> Riiiiight.
23:41:55 <dolio> And if you trick your friends into doing it, too, you can get $500 checks on a regular basis!
23:42:03 <dfeuer> But it always looks like they have you doing something sketchy like running a spam machine.
23:42:24 <glguy> the sad thing is that people actually buy stuff from those infomercials
23:42:47 <glguy> its one thing that the commercials are that bad, but then there are actually people that call in
23:43:05 <glguy> i wonder if such people are just so lonely that the prospect of talking to the operator makes it worth it...
23:43:07 <dolio> Hey, it must be legit, there's some girl with an extremely low-cut shirt telling you so.
23:43:36 <glguy> but wait, there's more!
23:43:59 <dolio> The one for the knives is pretty good, too.
23:44:19 <glguy> I've always wondered if when they say "if you call in the next 10 minutes we'll..."
23:44:26 <dolio> "I know all you guys in the audience are always borrowing your wives' kitchen knives to saw things."
23:44:40 <dolio> Co-host: "I'm certainly guilty of that!"
23:44:42 <dfeuer> haaaaaa
23:44:44 <glguy> lol
23:44:51 <dons> ?users
23:44:52 <lambdabot> Maximum users seen in #haskell: 220, currently: 189 (85.9%), active: 24 (10.9%)
23:44:55 <dons> ?uptime
23:44:55 <lambdabot> uptime: 1 day, 45 minutes and 14 seconds, longest uptime: 1 day, 45 minutes and 14 seconds
23:44:57 <vincenz> woo
23:44:58 <vincenz> active :)
23:44:59 <vincenz> @users
23:44:59 <lambdabot> Maximum users seen in #haskell: 220, currently: 189 (85.9%), active: 24 (10.9%)
23:45:06 <vincenz> how is active defined?
23:45:11 <dfeuer> I've been tempted a couple times by TV gadgets.  Some of them look like good ideas.  Unfortunately, I doubt very many of them are made well.
23:45:13 <glguy> but can I use it to install my tile floor?
23:45:19 <dons> if you've spoken in the last 4 hours you end up in the list
23:45:25 <vincenz> > return "lambda" >>= replicate 189
23:45:26 <lambdabot>  ["lambda","lambda","lambda","lambda","lambda","lambda","lambda","lambda","la...
23:46:25 <glguy> > ["lambda"|a<-[1..189]]
23:46:27 <lambdabot>  ["lambda","lambda","lambda","lambda","lambda","lambda","lambda","lambda","la...
23:46:29 <dfeuer> list?
23:46:47 <glguy> yeah, in that case return is a -> [a]
23:46:47 <dfeuer> ommmm
23:48:15 <vincenz> dfeuer: meditating?
23:48:25 <int-e> > ["lambda" | True]
23:48:26 <lambdabot>  ["lambda"]
23:48:28 <dfeuer> Pretending to.
23:48:37 <vincenz> > ["lambda"| False]
23:48:38 <piggybox> glguy, I've heard about J recently and am surprised to know K, J's big brother is widely used in financial industry
23:48:38 <lambdabot>  []
23:48:44 <glguy> > map(const "lambda")[1..189]
23:48:46 <lambdabot>  ["lambda","lambda","lambda","lambda","lambda","lambda","lambda","lambda","la...
23:49:17 <glguy> > map(\_->"lambda")[1..189]
23:49:18 <lambdabot>  ["lambda","lambda","lambda","lambda","lambda","lambda","lambda","lambda","la...
23:49:37 <glguy> haskell golf :)
23:50:07 <dolio> ?pl \_ -> "lambda"
23:50:07 <lambdabot> const "lambda"
23:50:29 <glguy> dolio: see above :)
23:50:32 <int-e> > take 189$repeat"lambda"
23:50:33 <lambdabot>    The function `take' is applied to three arguments,
23:50:34 <lambdabot>   but its type `Int...
23:50:35 <dolio> Oh, right, but \_-> is one letter shorter.
23:50:40 <dolio> :)
23:50:44 <int-e> > take 189$ repeat"lambda"
23:50:46 <lambdabot>  ["lambda","lambda","lambda","lambda","lambda","lambda","lambda","lambda","la...
23:50:46 <vincenz> @pl \n -> return "lambda" >>= replicate n
23:50:46 <lambdabot> flip replicate "lambda"
23:50:52 <int-e> I hate template Haskell.
23:50:54 <int-e> grr :)
23:50:55 <vincenz> wow
23:51:01 <vincenz> it can unmonad stuf :)
23:51:21 <lispy> @undo do { x <- foo; return x}
23:51:22 <lambdabot> foo >>= \ x -> return x
23:51:31 <glguy> |:189#"0'lambda'
23:51:36 <jrmole> yeah, no reason it shouldn't
23:51:37 <lispy> @redo foo >>= \x -> return x
23:51:38 <lambdabot> do { x <- foo; return x}
23:52:14 <vincenz> jrmole: well that depends, I think the logic for it is more complicated
23:52:19 <glguy> 'lambda'"0 i.189
23:52:54 <glguy> there ya go... beat J's 16 char solution ;)
23:53:13 <jrmole> once it knows what monad you're in, there's no reason return :: a -> [a] and (>>=) :: [a] -> (a -> [b]) -> [b] are different from any other list-manipulation functions
23:53:43 <jrmole> in fact they're both fairly natural list-manip functions, singleton and concatMap
23:54:41 <glguy> singleton?
23:56:28 <foxy__> @redo foo >>= return
23:56:29 <lambdabot> return
23:56:38 <lispy> singleton x = [x]
23:56:40 <glguy> redo?
23:57:46 <lispy> @redo return 1 >>= return 2
23:57:46 <lambdabot> return 2
23:57:54 <jrmole> ooh, dead code elimination :)
23:57:59 <lispy> @type return 1 >>= return 2
23:58:00 <lambdabot> forall (m :: * -> *) b. (Monad m, Num (m b)) => m b
23:58:07 <jrmole> @redo print 1 >>= print 2
23:58:07 <lambdabot> print 2
23:58:24 <lispy> > return 1 >>= return 2 :: [Int]
23:58:24 <jrmole> err, that dosen't even type
23:58:25 <lambdabot>  add an instance declaration for (Num [Int])
23:58:29 <jrmole> @redo print 1 >> print 2
23:58:30 <lambdabot> do { print 1; print 2}
23:58:38 <jrmole> @type print 1 >>= print 2
23:58:39 <lambdabot>   Expecting a function type, but found `IO ()'
23:58:40 <lambdabot>    Expected type: () -> IO b
23:59:02 <lispy> > (return 1 >>= return 2) :: [Int]
23:59:03 <lambdabot>  add an instance declaration for (Num [Int])
23:59:09 <jrmole> @redo print 1 >>= \_ -> print 2
23:59:09 <lambdabot> do { _ <- print 1; print 2}
23:59:35 <jrmole> weird that it accepts badly-typed terms
23:59:45 <dons> why is that weird?
23:59:49 <glguy> @redo [a+1|a<-[1..]]
23:59:49 <lambdabot> [a + 1 | a <- [1 ..]]
23:59:49 <dons> its a syntactic transform
