00:00:36 <int-e> okay, but it assumes the code will make sense without knowing the instances.
00:00:54 <edwardk> sure. but the fundeps are known, so perhaps it should take those into account =)
00:00:59 <edwardk> thats all
00:01:14 <int-e> I see.
00:01:32 <edwardk> coz otherwise, you can't put the fundeps one place and make a bunch of generic code that doesn't depend on the particular type the fundep can infer
00:01:50 <edwardk> you instead have to pollute your code globally
00:01:59 <int-e> if that could work that would make fundeps more useful (maybe together with declaring certain type classes final, to borrow a javaism)
00:02:22 <edwardk> the final type class thing isn't that necessary you can make a closure and not give it away
00:02:52 <edwardk> then inherit from that class modulo the closure. you get an unexpandable set of members
00:03:18 <int-e> And how is the compiler supposed to reason about that?
00:03:45 <edwardk> int-e: well, it doesn't help the compiler, but it sure helps protect you from idiot users trying to expand  your type level boolean class =)
00:04:00 <int-e> I'm not worried about the idiots, I want to help the compiler.
00:04:13 <edwardk> and i guess it could inspect the fact that he closure isn't exported from the module, but yeah that would be a pain in the ass ;)
00:04:57 <edwardk> i.e. once a module is compiled any types that depend on a type that isn't exported can be viewed as closed.
00:08:58 <edwardk> data Closure; class Closed a | -> a | instance Closed Closure; {- now the closure can't be expanded -} class TCFoo c a | a -> c; instance TCFoo Closure whatever ...; {- you can then strip the closure -} class TCFoo Closure a => TFoo a; instance TCFoo Closure a => TFoo a {- then if you don't export Closed, TCFoo can never have another member defined -}
00:09:12 <edwardk> er instance
00:09:40 <edwardk> requires a crapton of ghc'isms though, but then fundeps typically do
00:10:38 <Pupeno> it is totally illegal to have two "module Something where" in the same file, right ?
00:10:39 <edwardk> wonder how to prove to the compiler that the class is closed though. coz it relies on the inaccessibility of Closed.
00:11:04 <edwardk> there should be able to be a general statement to that effect
00:12:29 <edwardk> parse error on input module, yeah =)
00:20:35 <musasabi> Pupeno: having multiple modules in one file is not supported by the mainstream Haskell implementations.
00:20:43 <musasabi> I think hbc supported it?
00:20:50 <Pupeno> musasabi: but, is it valid Haskell 98 ?
00:21:54 <musasabi> Pupeno: iirc haskell98 does not comment on that - the module -> file mapping is left to the compiler. (but this is a hazy memory, I haven't looked at the standard recently)
00:22:49 <tibbe> can anyone come up with a better word for an unwordsWith function?
00:22:54 <tibbe> something more general
00:23:23 <lispy> tibbe: intersperse?
00:23:24 <musasabi> How is it different from List.intersperse ?
00:23:37 <musasabi> + concat
00:23:55 <lispy> implode?
00:24:04 <lispy> joinWith?
00:24:22 <kowey> concatIntersperse?
00:24:55 <tibbe> > concat $ intersperse "+" ["seg1", "seg2"]
00:24:56 <lambdabot>  "seg1+seg2"
00:25:03 <tibbe> ah good
00:25:15 <lispy> intersperse is very nice
00:25:35 <Pseudonym> ?type intersperse
00:25:37 <lambdabot> forall a. a -> [a] -> [a]
00:25:50 <Pseudonym> Same type as cons.
00:25:59 <Pseudonym> ?free intersperse
00:26:01 <lambdabot> $map f . intersperse x = intersperse (f x) . $map f
00:26:33 <lispy> Pseudonym: oh did you see my question about free earlier?
00:26:42 <Pseudonym> Yes.  Did you get my answer?
00:26:42 <tibbe> I needed it for a Java project at work xD
00:26:53 * lispy checks the scroll back
00:26:55 <Pseudonym> I answered somewhat late.
00:27:13 <Pseudonym> The short answer is that a free theorem is a theorem.
00:27:15 <Pseudonym> It's true.
00:27:16 <lispy> hmm...let me check the log so you don't have to retype it
00:27:24 <Pseudonym> So you can't violate it.
00:27:26 <lispy> @where log
00:27:27 <lambdabot> I know nothing about log.
00:27:37 <lispy> ah, so it's not useful for creating types
00:27:39 <lispy> er tests
00:27:45 <lispy> @where logs
00:27:45 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
00:27:47 <Pseudonym> Right.
00:27:48 <Pseudonym> However.
00:27:54 * tibbe whines about how Java's: public static final String makes his code right aligned
00:28:05 <Pseudonym> I also noted that some things that are considered axioms are really consequences of the free theorem.
00:28:26 <Pseudonym> Phil Wadler noted this for the monad axioms in "Comprehending Monads", briefly.
00:28:47 <Pseudonym> We of course use the basis fmap/return/bind.
00:28:59 <Pseudonym> If you use the basis fmap/return/join, then the monad axioms are:
00:29:05 <Pseudonym> ?free return :: a -> M a
00:29:06 <lambdabot> $map_M f . return = return . f
00:29:15 <Pseudonym> ?free join :: M (M a) -> M a
00:29:16 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
00:29:20 <Pseudonym> Where map_M == fmap
00:29:35 <Pseudonym> Those are the axioms!  They're actually theorems!
00:30:06 <Pseudonym> You need to prove that your data structure is a Functor (i.e. that the fmap laws apply).
00:30:07 <lispy> oh hmm...
00:30:17 <lispy> ah right
00:30:23 <Pseudonym> Once you've done that, ANY type-correct definition of return and join (and bind, for that matter) makes a 100% compliant monad.
00:31:02 <tibbe> what does something being a functor mean?
00:31:09 <Pseudonym> ?hoogle Functor
00:31:10 <lambdabot> Prelude.Functor :: class Functor f
00:31:10 <lambdabot> Data.FunctorM :: module
00:31:10 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
00:31:14 <Pseudonym> Hmmm.
00:31:21 <Pseudonym> class Functor f where
00:31:28 <Pseudonym>     fmap :: (a -> b) -> (f a -> f b)
00:31:34 <Pseudonym> The laws of Functor are:
00:31:35 <Pseudonym> fmap id = id
00:31:42 <Pseudonym> fmap f . fmap g = fmap (f . g)
00:31:45 <Pseudonym> That's it.
00:32:02 <tibbe> but what does it mean? in plain english
00:32:07 <tibbe> or not so plain...
00:32:22 <Pseudonym> Do you know any introductory category theory?
00:32:29 <tibbe> no
00:32:43 <Pseudonym> Basically, then, it means that fmap preserves id and function composition.
00:32:48 <lispy> tibbe: fmap f . fmap g = fmap (f . g) means that the fmap preserves the transformations f and g
00:33:11 <Pseudonym> > map (+1) . map (*2) $ [1,2,3]
00:33:12 <lambdabot>  [3,5,7]
00:33:17 <tibbe> um, like some kind of linear transformation thing in linear algebra?
00:33:19 <Pseudonym> > map ((+1) . (*2)) $ [1,2,3]
00:33:20 <Pseudonym> Right?
00:33:21 <lambdabot>  [3,5,7]
00:33:22 <Pseudonym> yes!
00:33:24 <Pseudonym> Exactly like that.
00:33:28 <tibbe> :)
00:33:43 <tibbe> alright, I think I understand
00:33:46 <Pseudonym> A linear map is a homomorphism of linear spaces.
00:33:57 <Pseudonym> And a functor is a homomorphism of function spaces.
00:34:03 <Pseudonym> Actually, it's a homomorphism of categories.
00:34:22 <lispy> oh
00:34:34 <lispy> cool
00:35:07 <tibbe> could you give an example of something that has the type signature of fmap and isn't a functor?
00:35:31 <tibbe> and what does homorphism mean?
00:35:40 <Pseudonym> ?foldoc homomorphism
00:35:42 <lambdabot> *** "homomorphism" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
00:35:42 <lambdabot> homomorphism
00:35:42 <lambdabot>  
00:35:42 <lambdabot>     A map f between groups A and B is a homomorphism of A into B
00:35:42 <lambdabot>     if
00:35:44 <lambdabot> [4 @more lines]
00:35:48 <Pseudonym> @more
00:35:49 <lambdabot>     	f(a1 * a2) = f(a1) * f(a2)  for all a1,a2 in A.
00:35:49 <lambdabot>  
00:35:50 <lambdabot>     where the *s are the respective group operations.
00:35:52 <lambdabot>  
00:35:57 <Pseudonym> OK, that's true of group homomorphisms.
00:36:13 <Pseudonym> The group operations are multiplication, inverse and identity.
00:36:19 <Pseudonym> Each group has those three operations.
00:36:32 <Pseudonym> A homomorphism f : G1 -> G2 between two groups satisfies:
00:36:38 <Pseudonym> f(ab) = f(a) f(b)
00:36:44 <Pseudonym> f(a^-1) = f(a)^-1
00:36:47 <Pseudonym> f(1) = 1
00:36:55 <Pseudonym> It respects the structure of the group.
00:37:13 <lispy> well, f(1_G1) = 1_G2 is how i would write that :)
00:37:23 <Pseudonym> Right.
00:37:31 <Pseudonym> In fact, for groups, it's sufficient to prove:
00:37:38 <Pseudonym> f(ab^-1) = f(a) f(b)^-1
00:37:41 <tibbe> um, I'll try to get my head around that
00:37:56 <lispy> Pseudonym: because we only need to see how it behaves on the generators?
00:38:10 <lispy> (or am i thinking of a different result...)
00:38:11 <Pseudonym> lispy: No, because the other cases follow.
00:38:25 <Pseudonym> e.g. a = b gives the identity case.
00:38:27 <lispy> oh right, if a = b
00:39:31 <Pseudonym> As for fmap, let me think about that one for a moment.
00:39:32 <tibbe> I need to read up on some math I think, like groups, is that a part of discrete math?
00:39:42 <Pseudonym> Algebra.
00:39:44 <dolio> Abstract algebra.
00:39:52 <jrmole> Dummit & Foote is a good intro text
00:40:30 * tibbe thinks it's great when one takes a field of math and puts abstract in front of it, then you know it's abstract alright!
00:40:39 <Pseudonym> :-)
00:40:40 <dolio> :)
00:40:43 <jrmole> yeah, it's also called modern algebra
00:40:48 <Pseudonym> Unfortunately, "algebra" is an overloaded term.
00:40:50 <dolio> Even better is universal algebra.
00:40:58 <jrmole> or just algebra, among people who know you're not talking about high-school algebra
00:40:59 <Pseudonym> An "algebra" is also a vector space with a vector product.
00:41:08 <jrmole> even better is model theory :)
00:41:24 <tibbe> So I've taken basic courses in discrete math, linear algebra and calculus (i.e. the basics for a CS degree), would that book suit me?
00:41:44 <jrmole> tibbe, it's worth a try
00:41:50 <jrmole> and you'll probably get something out of it
00:41:58 <jrmole> a few chapters in it gets pretty dense though
00:42:02 <Pseudonym> I liked Saunders Mac Lane's "Algebra".
00:42:08 <jrmole> still good for an intro text, just that algebra is dense by nature
00:42:10 <Pseudonym> I don't know if it's introductory or not, though.
00:42:22 <tibbe> I usually try to read a book a month or so but I'm out of books and thinking on picking up something on math
00:42:24 <jrmole> to be fair, i haven't surveyed many algebra texts, as i don't really like much of the subject
00:42:27 <Pseudonym> Personally, I'd actually pick a good introduction to X theory, where X is one algebraic structure.
00:42:31 <Pseudonym> Group theory is a good choice.
00:42:32 <dolio> I think I've forgotten most of the stuff from the algebra courses I took.
00:42:37 <jrmole> Pseudonym, the first bit of D&F is group theory
00:42:43 <Pseudonym> Right.
00:42:52 <jrmole> the next section is rings, then fields, then some loose ends
00:43:08 <Pseudonym> An intro to group theory will introduce you to treating things as abstract, homomorphisms and other nice things.
00:43:11 <Pseudonym> Ideals.
00:43:11 <jrmole> err, modules & friends are in there somewhere
00:43:14 <Pseudonym> That sort of thing.
00:43:17 <tibbe> I remember reading something about rings when I took a course in crypthography
00:43:22 <jrmole> yeah, D&F unifies everything pretty nicely
00:43:25 * Pseudonym nods
00:43:31 <jrmole> though it doesn't use category-theoretic terms until the very end
00:43:32 <Pseudonym> Not having read D&F, I can't comment.
00:43:53 <lispy> tibbe: for a books like we're recommending mathematical maturity is more important than background knowledge, e.g., not the easist thing to read but they will explain the concepts you need
00:44:17 <jrmole> tibbe, do you just want a cool maths book to read in general, or do you specifically want to study algebra?
00:44:21 <tibbe> lispy, perhaps I should try to improve my overall math skills then
00:44:43 <tibbe> lispy, I think I would like to become better at math in general
00:44:48 <lispy> tibbe: okay, i recommend you start by getting a text book on abstract algebra :)
00:45:10 <lispy> tibbe: http://blog.codersbase.com/2006/08/17/learn-math-10-tips/
00:45:12 <lambdabot> Title: dagit.o ¬ª Blog Archive ¬ª Learn Math (10 tips), http://tinyurl.com/g4ddd
00:45:17 <bourbaki> moin
00:45:21 <lispy> moin
00:45:29 <bourbaki> is the haskell.net guy active in this channel?
00:46:14 <lispy> what is haskell.net?
00:46:18 <dons> jun mukai? sometimes
00:46:29 <lispy> like .NET but with haskell or do you mean http://haskell.net?
00:46:29 <jrmole> tibbe, do you know much automaton / computability / complexity theory?
00:46:41 <bourbaki> http://php.cin.ufpe.br/~haskell/haskelldotnet/hsharp.php?m=home
00:46:46 <lambdabot> Title: H#: The Haskell.net Project, http://tinyurl.com/zq7cs
00:47:04 <tibbe> jrmoel, don't think so
00:47:06 <lispy> bourbaki: cool
00:47:07 <Pseudonym> OK, tibbe, here we are:
00:47:14 <Pseudonym> newtype F a = F (a -> a)
00:47:18 <bourbaki> dons do you happen to know if theres a pre version available by now?
00:47:26 <Pseudonym> instance Functor F where
00:47:29 <dons> well, there's the SoC arhive
00:47:29 <Pseudonym>     fmap f m = F id
00:47:40 <Pseudonym> That violates the Functor laws.
00:47:45 <lispy> Latest
00:47:45 <lispy> News
00:47:45 <lispy> 2003-12-13
00:47:45 <lispy> Haskell.NET website released
00:47:49 <dons> and I think he's announced the work anyway, check haskell.org
00:47:52 <lispy> that's a bit disturbing
00:48:24 <tibbe> Pseudonym, thanks
00:48:30 <Pseudonym> fmap id /= id in that case
00:48:33 <jrmole> tibbe, then i suggest you push Introduction to the Theory of Computation by Sipser onto your book queue
00:48:36 <dons>    Domain Name: HASKELL.NET
00:48:37 <dons>    Registrar: TUCOWS INC.
00:48:53 <dons>    Creation Date: 15-Nov-1997
00:48:54 <jrmole> it's one of my favorite books ever, very self-contained and great style
00:49:08 <jrmole> imho any CS major should know most of the stuff in that book backwards and forwards
00:49:13 <tibbe> jrmole, oh wait, I took a course in finite automatas and formal languages (or that's how I would translate the course name)
00:49:19 <jrmole> ah
00:49:46 <Pupeno> strings can't span more than one line, can they ?
00:49:52 <tibbe> jrmole, took me a while to register the word automaton, I'm a bit slow in the morning
00:49:55 <jrmole> hehe
00:49:59 <dons> Pupeno: yep, they can
00:50:10 <dons> > "some \    \string"
00:50:11 <lambdabot>  "some string"
00:50:18 <lispy> i find that i either suck at computability theory or a suck at explaining it...every class i've taken on it i've done horrible in, and yet i feel like i get it (and it's the only math type study i feel that way about)
00:50:36 <dons> > unlines ["some", "more", "strings"
00:50:36 <lambdabot>  Parse error
00:50:39 <dons> > unlines ["some", "more", "strings"]
00:50:40 <lambdabot>  "some\nmore\nstrings\n"
00:50:43 <tibbe> ‚ÄúI wish I could remember and pickup more math‚Äù
00:50:50 <tibbe> that's how I feel
00:51:02 <tibbe> stressing the word remember
00:51:04 <jrmole> i also recommend Computational Complexity by Papadimitriou
00:51:13 <Pupeno> lisppaste2: url
00:51:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:51:15 <jrmole> it's where i learned a lot of formal logic, oddly enough
00:51:41 <lispy> tibbe: i totally agree...but i also wrote that :)
00:51:48 <lisppaste2> Pupeno pasted "2:1: lexical error in string/character literal" at http://paste.lisp.org/display/25311
00:51:59 <Pupeno> dons: I get that error, what am I doing wrong ?
00:52:16 <lispy> Pupeno: i think you have to put in in quotes
00:52:51 <dons> you're missing the \ quote at the start
00:53:06 <dons> x = "my\
00:53:06 <dons>     \string\
00:53:06 <dons>     \with a gap"
00:53:12 <lispy> ah
00:53:18 <Pupeno> oh!
00:53:21 <lispy> so does it get the newline characters too?
00:53:34 <dons> x = unlines
00:53:35 <dons>         ["my"
00:53:35 <dons>         ,"string"
00:53:35 <dons>         ,"with a gap"]
00:53:42 <dons> lispy: if you put a \n in
00:53:44 <lispy> "my\nstring\nwith a gap?
00:53:59 <lispy> yeah, i miss that from lisp
00:54:06 <tibbe> jrmole, the intro to comp books, is it more of an algorithms book or a math kinda book, I just read introduction to algorithms
00:54:08 <Pseudonym> Gotta go.  Nytol!
00:54:15 <lispy> every character was in the string until the closing quote
00:54:21 <jrmole> they're both very mathy
00:54:26 <jrmole> in particular, discrete mathy
00:54:42 <lispy> it was very nice for documentation strings
00:55:07 <lispy> and then you can browse documentation strings from the interpreter...so it was like having the documentation right there whenever you're coding
00:55:25 <lispy> it would be like being able to browse the haddock comments from ghci
00:55:36 <jrmole> for example in the first 2/3 of sipser you only care whether an algorithm exists, and in the last 1/3 you only care (roughly) whether it's polynomial
00:55:39 <lispy> oh hm...that would be a nice add-on for ghci...
00:55:57 <jrmole> there's none of the O(this), O(that) grunge from a book like CLRS (which, to be fair, is good to know too)
00:56:55 <tibbe> jrmole, does it explicitly teach math or is it more of: lets use math to explain computability?
00:57:01 <jrmole> computability is math :)
00:57:02 <lispy> i find that my gfs have thought big-O was something definitely not related to maths :)
00:57:29 <dons> heh
00:57:46 <jrmole> what, asymptotic analysis isn't sexy enough?
00:57:57 <tibbe> jrmole, let me rephrase that, I think my discrete math has degenerated to the point that I feel I might need to retake some basics (and really understand them) before moving on to something that uses those basics
00:58:18 <jrmole> tibbe, it will probably help you (re)learn the basics then
00:58:48 <jrmole> it's very self-contained... someone smart enough to follow proofs but with no prior knowledge of maths could follow everything
00:58:53 <lispy> tibbe: go through with the new learning, just remember to take time to relearn things as you need it... it will actually stick better this way than retaking the old stuff without the new context where you need it
00:59:30 <jrmole> all notation and terms are defined in the book, down to things like sets
00:59:48 <jrmole> and if you need additional help on the basics, there's wikipedia and mathworld, and you can ask people on IRC too
00:59:51 <tibbe> jrmole, alright, I'll order it
00:59:56 <jrmole> :)
01:00:07 <lispy> or check your library
01:00:12 * tibbe thinks it's a bit dangerous to be able to purchase things so easily
01:00:19 * lispy nods
01:00:25 <jrmole> i think Sipser was where i got a lot of "mathematical maturity"
01:00:34 <lispy> but...it's probably just as easy to check the website of a local library :)
01:00:39 <tibbe> lispy, I'm in France right now on an internship, all the library's books are encrypted with some sort of ceasar cipher
01:00:59 <lispy> adobe?
01:01:06 <tibbe> ?
01:01:10 <jrmole> @babel en fr caesar cipher
01:01:11 <lambdabot>  chiffre de CÈsar
01:01:31 <lispy> oh i thought maybe it was a reference to the dmca violation by dmitry a few years back
01:01:31 <explicitjelly> I speak french.
01:01:35 <jrmole> lispy, i'm pretty sure he means french ;)
01:01:45 <lispy> ah
01:01:57 <explicitjelly> you could type the sentences in the books in, line by line, and I could tell you wether it was a relevant sentence for what you're looking for.
01:02:05 <jrmole> that will be efficient
01:02:06 <tibbe> explicitjelly, I don't :p
01:02:19 <jrmole> hey, french and computability theory are mostly orthogonal
01:02:25 <jrmole> that means you can learn both at the same time, right?
01:02:29 <lispy> hehe
01:02:39 <jrmole> i tried this with algebra and german... didn't work
01:02:51 <lispy> lots of interesting math has been originally authored in french...so it might be worth it to learn french :)
01:02:51 <explicitjelly> algebra and german aren't orthogonal?
01:03:02 <explicitjelly> <- french/german in germany
01:03:20 <jrmole> but i did learn how to say "abelian pants" and a couple of other things
01:03:29 <lispy> lol
01:03:55 <lispy> pantelones de abelian?
01:04:02 <lispy> or maybe that's spanish
01:04:03 <jrmole> sure, why not
01:04:17 <jrmole> and not quite grammatical anyway
01:04:27 <jrmole> probably pantalones abelianos or something like that
01:04:35 <lispy> good point
01:04:43 <explicitjelly> pantalons abelien. perhaps.
01:04:47 * lispy writes that one down for his next trip to mexico
01:05:19 <lispy> "Me gusteria pantalones abelianos, por favor"
01:05:34 <explicitjelly> me gusta pantalones, me gusta tu!
01:05:57 <dolio> Abelian pants?
01:06:06 <dolio> Work the same forwards and backwards?
01:06:25 <lispy> maybe they are cross gender?
01:06:32 <lispy> as in unisex
01:07:07 <explicitjelly> @label de en getragen
01:07:09 <lambdabot>  carried
01:07:34 <lispy> @babel de en lemma
01:07:36 <lambdabot>  lemma
01:07:48 <lispy> oh hm...i thought lemma was german
01:07:48 <explicitjelly> i thought if you wear two of them, but the second one inside out, then you're naked?
01:07:58 <explicitjelly> no, it's not
01:08:00 <jrmole> no, that's true of all pants
01:08:23 <explicitjelly> jrmole, even if you wear underpants *between* them?
01:08:39 <lispy> ?type pants
01:08:41 <lambdabot> Not in scope: `pants'
01:08:54 <tibbe> lispy, point 7 of your math tips doesn't work very well for me atm :/ although I know it's so important
01:09:10 <lispy> pants :: Leg -> Leg -> Clothed Body
01:09:23 <jrmole> lispy, perhaps it's german for "lemma"
01:09:27 <lispy> which was 7?
01:09:45 <lispy> oh right
01:09:51 <lispy> that's the hardest one i think
01:09:51 <explicitjelly> actually, it IS german for lemma.
01:10:29 <lispy> or maybe, pants :: Leg -> Leg -> Clothed (Leg, Leg)
01:10:40 <lispy> the Clothed monad is a tricky one
01:12:44 <tibbe> lispy, I find it hard to get people exited enough about a subject to get to the point where they want to discuss it outside a "have to" situation
01:12:47 <explicitjelly> ah, the Clothed Monad. that was my favourite bedtime story.
01:13:17 <vincenz> hoi boegel
01:15:01 <lispy> explicitjelly: hah!
01:15:30 <explicitjelly> http://www.amazon.com/exec/obidos/tg/detail/-/0833030477?v=glance
01:15:46 <lispy> tibbe: have you been to #math on freenode or maybe efnet?  I heard those are pretty good and maybe some of usnet style newsgrousp...or maybe planetmath...if you find a forum  you like, please, let me know about it :)
01:16:04 <lispy> i should sleep soon...
01:16:06 <lispy> @localtime lispy
01:16:07 <lambdabot> Local time for lispy is Mon Sep  4 01:15:42 2006
01:16:58 <kosmikus> moin teggy
01:17:33 <ibid> lispy: did you see my response? :)
01:17:53 <ibid> general notice: just upgraded planet. please let me know if it breaks :)
01:18:43 <boegel> hi vincenz
01:21:21 <lispy> ibid: oh, i missed your response, but i'll check the planet
01:22:28 <ibid> lispy: point being, there is no connection between the blog and your irc persona. i'd prefer an email in this case, though some way for me to know that it's your blog makes me feel much more warm and fuzzy :)
01:22:35 <tibbe> lispy, I'll shop around
01:23:02 <lispy> ibid: oh okay
01:23:04 <ibid> lispy: at least as currently implemented, the lambdabot message system made the message take longer time to reach me than otherwise necessary
01:23:05 <vincenz> ibid: there was one blog that when clicked was unreadable
01:23:09 <vincenz> ibid: required a password
01:23:13 <ibid> vincenz: hm?
01:23:24 <vincenz> Dan Piponi's
01:23:33 <ibid> that's not supposed to happen
01:23:35 <ibid> let me see
01:23:46 <vincenz> I have planet on my personalized homepage of google
01:23:56 <lispy> ibid: could you /msg me with an email addy and (if you like) some sort of cookie that i can include in the email to help you link lispy with me non-lispy self?
01:23:57 <vincenz> if I click on the dan piponi link it asks a pw and username for that blogger
01:24:14 <ibid> vincenz: i can't reproduce it
01:24:24 <ibid> vincenz: doesn't happen for me
01:24:32 <vincenz> odd
01:24:45 <vincenz> dons: ping
01:24:54 <ibid> lispy: well, even saying somewhere "lispy" on the blog, or mailing me from an email address i can connect with the blog...
01:25:28 <ibid> vincenz: does it happen if you go to planet au naturel (sp?)?
01:25:28 <lispy> ibid: right, i can do that easily enough, my address has the same domain name
01:25:38 <vincenz> ibid: no
01:25:45 <ibid> vincenz: weird
01:25:56 <vincenz> ibid: only when you use the rss feed, as I do, in google personalized (though I bet other places where you use the rss would give the same)
01:26:14 <ibid> hm
01:26:17 <ibid> let me see...
01:26:25 <vincenz> ah
01:26:38 <vincenz> the feed au naturel
01:26:39 <vincenz> and the rss
01:26:41 <vincenz> give different links
01:26:51 <dons> vincenz: yes?
01:27:03 <vincenz> from google: http://www.blogger.com/feeds/11295132/posts/full/115699923292640924     from au naturel: http://sigfpe.blogspot.com/2006/08/geometric-algebra-for-free_30.html
01:27:13 <vincenz> dons: in your community papers are not blindly reviewed/?
01:27:25 <dons> yes, they are. why?
01:27:42 <vincenz> cause you put your paper online ..
01:27:46 <vincenz> and it's a draft
01:28:05 <vincenz> anyone that does a related work check through google will run into it!
01:28:14 <dons> yep. its pretty common to put the draft up.
01:28:20 <vincenz> but then it's not blind review
01:28:33 <ibid> vincenz: rss20?
01:28:38 <vincenz> hmm
01:28:47 <vincenz> ibid: I think so, the plain [rss] button on planet
01:28:48 <dons> ah. i see. i certainly am blind to who the reviewers are though.
01:29:18 <vincenz> dons: ah, we have to take our names out and some conferences either require  third person linkage to related work, or also blinding out references to our own work
01:29:21 <vincenz> until final submission
01:29:37 <dons> oh, that's interesting.
01:29:39 <Itkovian> I think vincenz means a double blind review
01:29:44 <dons> yeah
01:29:44 <ibid> vincenz: ah ok. the rss20 generated by planet has that password link as guid, and the real link as link
01:29:52 <vincenz> Itkovian: right, my terminology ...
01:29:53 <vincenz> :/
01:30:03 <Itkovian> vincenz: that generally depends on what conference/journal you are submitting to
01:30:04 <ibid> vincenz: need to check the spec but i'd say the feed reader is using the wrong link source
01:30:13 <Itkovian> vincenz: skype?
01:30:16 <vincenz> Itkovian: DATE
01:30:31 <vincenz> Itkovian: hmm sure, not sure how much time I have, got a meeting soon with my supervisor so I could be interrupted
01:30:48 <Itkovian> well, we can talk up to then
01:31:02 <Itkovian> I can be interupted too, a 22 month old kid likes to do so
01:31:11 <ibid> vincenz: the closest to a double-blind reviews i've been has been from watching colleagues :)
01:31:30 <vincenz> Itkovian: not hearng anything
01:31:33 <Itkovian> me neither
01:31:36 <vincenz> damn
01:31:45 <vincenz> just a sec
01:31:55 * Itkovian checks settings
01:31:59 * vincenz launches as Aoss skype
01:32:19 <ibid> hmm
01:32:27 <vincenz> and that is the interrupt
01:32:27 <psnl> morning world
01:32:28 <ibid> i should probably mark the guid as non-permalink
01:32:31 <vincenz> Itkovian: bbl
01:32:42 <Itkovian> ok
01:33:18 <ibid> actually it is
01:33:38 <Itkovian> vincenz: I just skyped with somebody else and it went well.
01:33:42 <ibid> vincenz: looks to me like google is misusing the guid. it cannot assume that it is a valid uri that will show the entry
01:33:57 <ibid> vincenz: see the rss 2.0 spec for more info :)
01:50:42 <tibbe> woa
01:51:40 <Baughn> I think I'm beginning to understand this language. I just defined 1+1=3.
01:55:11 <jrmole> @remember Baughn I think I'm beginning to understand this language. I just defined 1+1=3.
02:03:25 <dons> > let 1 + 1 = 3 in 1 + 1
02:03:26 <lambdabot>  3
02:04:06 <ibid> hah
02:04:13 <ibid> > let 1 + 1 = 3 in 2 + 5
02:04:14 <lambdabot>  Non-exhaustive patterns in function +
02:04:18 <ibid> :)
02:04:22 <Bluelive> my head just exploded ;)
02:04:26 <jrmole> you can redefine (+)?
02:04:29 <ibid> sure
02:04:32 <dblhelix> jrmole: yes, you can
02:04:35 <boegel> > let 1+1 = 3 in (1+1)+1+(1+1)
02:04:36 <lambdabot>  Non-exhaustive patterns in function +
02:04:39 <jrmole> what kind of magic is lambdabot doing to hide the prelude definition?
02:04:41 <boegel> > let 1+1 = 3 in (1+1)+1
02:04:43 <lambdabot>  Non-exhaustive patterns in function +
02:04:52 <boegel> > let 1+1 = 3 in 1+(1+1)
02:04:53 <lambdabot>  Non-exhaustive patterns in function +
02:04:56 <boegel> argh
02:04:56 <ibid> jrmole: no magic, just normal variable shadowing
02:05:02 <dblhelix> > let 1 + 1 = 1 in (1 + 1) + 1 + (1 + 1)
02:05:03 <lambdabot>  1
02:05:19 <boegel> :D
02:05:20 <jrmole> ah, since it's within a let
02:05:24 <jrmole> but it won't work at top level
02:05:24 <ibid> jrmole: yes
02:05:32 <jrmole> got it
02:05:33 <ibid> true, unless you hide it
02:05:37 <dons> > 7 + (let 1+1=3 in 1+1)
02:05:38 <lambdabot>  10
02:05:41 <ibid> (the prelude one, that is)
02:05:56 <dons> Haskell is fun!
02:06:18 <velco> > let { 1 + 1 = 3; 3 + 3 = 5 } in 1 + 1 + 3
02:06:19 <lambdabot>  5
02:06:24 <ibid> and, due to symmetry, fun is Haskell!
02:06:44 <velco> > let { 1 + 1 = 3; 3 + 3 = 11 } in 1 + 1 + 3
02:06:45 <lambdabot>  11
02:07:03 <dons> ?pl Fun `is` Haskell == Haskell `is` Fun
02:07:03 <lambdabot> Fun `is` Haskell == Haskell `is` Fun
02:07:16 <dons> ah well
02:07:24 <ibid> no variables there :)
02:07:30 <dons> yeah
02:07:37 <dons> ?pl \is -> Fun `is` Haskell == Haskell `is` Fun
02:07:37 <lambdabot> ap ((==) . flip ($ Fun) Haskell) (flip ($ Haskell) Fun)
02:07:41 <ibid> ?pl fun `is` Haskell == Haskell `is` fun
02:07:42 <lambdabot> fun `is` Haskell == Haskell `is` fun
02:07:47 <ibid> bah :)
02:07:50 <dblhelix> ibid: no *bound* variables ;)
02:07:55 <ibid> ?pl \fun -> fun `is` Haskell == Haskell `is` fun
02:07:56 <lambdabot> liftM2 (==) (`is` Haskell) (Haskell `is`)
02:08:19 <ibid> dblhelix: it should implicitly bind free variables ;)
02:08:22 <dons> ?pl \fun is -> fun `is` haskell == haskell `is` fun
02:08:22 <lambdabot> ap (ap . ((==) .) . flip flip haskell . flip id) (flip ($ haskell))
02:08:34 <ibid> but, it's lunchtime.
02:08:39 <dons> clearly, flip flip haskell . flip id) (flip ($ haskell))
02:08:48 <ibid> flip haskell!!!
02:09:01 <dons>  $ haskell!!
02:09:10 <norpan> nerds
02:09:22 <dons> heh
02:09:32 <ibid> norpan: thank you :)
02:10:38 <dons> ?type \fun is haskell -> fun `is` haskell == haskell `is` fun
02:10:40 <lambdabot> forall t a. (Eq a) => t -> (t -> t -> a) -> t -> Bool
02:11:00 <dons> ?. free type \fun is haskell -> fun `is` haskell == haskell `is` fun
02:11:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
02:11:05 <dons> arg
02:11:27 <dons> ?free t -> (t -> t -> a) -> t -> Bool
02:11:27 <lambdabot> Extra stuff at end of line
02:11:32 <dons> heh
02:11:32 <tibbe> dons, reading your paper now, I like :)
02:11:38 <dons> :)
02:11:41 <vincenz> Itkovian: back
02:12:27 <vincenz> heh
02:12:30 <vincenz> lilo is a good admin :)
02:12:39 <ibid> as i said, 12:08  <ibid> but, it's lunchtime.
02:12:41 <ibid> bbl :)
02:12:50 <vincenz> @whereis ibid
02:12:51 <lambdabot> Maybe you meant: where where+
02:13:09 <vincenz> dons: think that would be possible? get a location of a person?
02:13:25 <dons> hmm
02:13:42 <dons> there are ways and means
02:15:19 <musasabi> What is a good approach of making a record with large number of fields with several variant types that each allow a different overlapping subset of the fields?
02:16:29 <ibid> it seems to be everyone else's lunchtime too. i'll retry in a half an hour :)
02:17:42 <ibid> vincenz: /me is located at http://www.jyu.fi/erillis/agora/en
02:17:44 <lambdabot> Title: Agora - A Meeting Place for Humanity and Technology &mdash; Jyv√§skyl√§n yliopis ...
02:18:22 <musasabi> data Foo variant = Foo { f1 :: Int allways present, f2 :: Bool present if (IsBar variant), f3 :: Char present if (isC variant), ... }
02:24:55 * dons thinks planet.haskell.org may be doing TMR's job, in some ways
02:25:07 <dons> but with cheaper commit bits
02:49:46 <tibbe> @quote
02:49:46 <lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
02:55:00 <foxy> @free zip
02:55:02 <lambdabot> ( ( g ($proj_2_1 z) = $proj_2_1 u     &&     f ($proj_2_2 z) = $proj_2_2 u   )  =>   h z = u ) => $map h (zip x y) = zip ($map g x) ($map f y)
02:56:53 <mauke> @help free
02:56:54 <lambdabot> free <id :: a -> a>. Generate theorems for free
03:03:01 <sek> is there anyway to define something only if a condition holds? otherwise leave it undefined
03:03:26 <sek> ex_nor: bla = if cond then 1 else error
03:03:35 <sek> errm, i meant ex there
03:04:18 <gds> I think there are errors/exceptions in haskell - it's been a /long/ time since I've played with them though - I don't know if anything's changed...
03:04:42 <sek> error "error" works in cases when you call if from functions
03:04:54 <sek> but not in if statements, in if it expects the type you;'re defining
03:05:17 <gds> Ah :)
03:05:38 <ProfTeggy> sek, let x = if (cond) then 42 else undefined
03:05:47 <sek> ah, undefined
03:06:27 <sek> ProfTeggy: would haskell's lazy evaluation "skip" the evaluation of the variable if it is uneeded
03:07:01 <ProfTeggy> ProfTeggy, expression are evaluated on demand, so yes
03:07:13 <sek> i mean for exampe  | cond = ....(no use of k)    | !cond = ...use k...     where  k = (something illegal if cond holds)
03:07:14 <ProfTeggy> hehe
03:07:17 <ProfTeggy> I mean sek there
03:07:18 <sek> heh
03:07:46 <sek> wouldnt that throw an interpreter error?
03:07:57 <ProfTeggy> This should work as you wish, sek
03:08:04 <sek> great
03:08:08 <sek> i love lazy evaluation
03:08:16 <sek> it suites my programming ideology
03:08:17 <sek> heh
03:08:27 <araujo> morning!
03:12:06 <Pupeno> A set of module exports is like this: (identifier, identifier, Type(Constructor, Constructor), Type(Constructor, Constructor)), any case that I am missing ?
03:13:56 <musasabi> Class(something)
03:14:08 <musasabi> Type(..)
03:14:18 <musasabi> module Mid
03:14:55 <musasabi> and of course plain Type
03:17:16 <musasabi> Why is this not allowed by GHC 6.5:
03:17:17 <musasabi> data F t where A { foo :: Int } :: F Bool; B { foo :: Int } :: F ()
03:23:50 <ski> musasabi : hm, type of 'foo' selector would be ?
03:24:36 <musasabi> foo :: F a -> Int ?
03:25:15 <musasabi> the update would be "foo<update> :: Int -> F a -> F a"
03:25:38 <ski> hm
03:26:22 <ski> (iirc audreyt did some extension re GADTs and fields .. dunno how related that was to your issue, though)
03:26:39 <musasabi> yes, I think she contributed most of the code.
03:26:43 <ski> seems to me the selector (in any case) should be ok
03:26:51 <musasabi> audreyt: ping
03:53:15 <Pupeno> can an import span more than one line ?
03:54:06 <musasabi> Pupeno: yes.
03:54:30 <Pupeno> musasabi: can you give me an example ? how do you know where it ends then ?
03:55:42 <musasabi> "import List\n (map)"
03:56:38 <vincenz> re
03:56:48 <ski> layout, methinks
03:56:51 <Pupeno> musasabi: only the indentation shows where the module ends ?
03:56:52 <vincenz> Anyone know an irc client that tunnels over http-proxy?
03:57:44 <musasabi> Pupeno: yes, but remember that the indentation rules are quite complex. You might be better of just taking a parser.
03:58:18 <vincenz> Pupeno: you're missing
03:58:20 <vincenz> Type(...)
03:58:36 <vincenz> as well as className
03:58:51 <musasabi> if the code is controlled by you then limiting the set of import-declarations to nicely egreppable is easy.
03:58:55 <vincenz> tho the second flls under identifier
04:00:14 <ibid> uh, layout has nothing to do with imports
04:00:22 <ibid> it's just that it ends when it ends :)
04:00:37 <ibid> there is no ambiguity
04:00:56 <ski> so "import List\n(map)" is ok ?
04:01:08 <ibid> should be
04:01:19 <vincenz> (map) matches nothing else so
04:01:23 <ski> and "  import List\n(map)" ?
04:01:32 <ibid> well, you may need to indent it if you are using layout for module ... where
04:01:41 <ibid> hm, yes
04:01:55 <ibid> let me check
04:02:28 <ibid> yes
04:02:31 <ski> ok
04:02:31 <ibid> i was wrong
04:02:50 <ski> former allowed or not ?
04:02:51 <ibid> imports are separated by ';'s, which are usually added by layout
04:03:19 <ibid> ski: if using layout for module ... where, then (map) needs to be indented so no ; is inserted there
04:03:21 <musasabi> "import List\n(map)" is invalid. "import List\n (map)" is valid.
04:03:28 <ibid> exactly
04:03:43 <ski> (as i thought, then)
04:04:03 <ibid> my mistake was to forget that module ... where is usually layout-active :)
04:04:42 <ibid> but there is no (further) layout involvement inside the import directive
04:04:53 <ski> m, right
04:05:34 <ski> so 'import' doesn't do layout by itself, then
04:06:01 <audreyt> musasabi: pong
04:06:03 <ibid> yes
04:06:24 <audreyt> F a -> Int
04:06:27 <audreyt> is not consistent
04:06:29 <ibid> there are only a couple of keywords that are layout-active
04:06:35 <ibid> in, where (are there others?)
04:06:47 <ski> 'do'
04:06:48 <audreyt> as it won't correctly feed into inferencer food
04:06:53 <ibid> do, yes
04:07:24 <audreyt> musasabi: each selector must share the same type; I guess I can see if you'd like to unify based on least shared supertype
04:07:28 <audreyt> but haskell has no supertyping
04:07:30 <ibid> hm, not in but let
04:08:00 <ibid> let, where, do, of
04:08:09 <ibid> that's the complete list for h98
04:08:26 <ski> k
04:14:13 <musasabi> audreyt: true. I was thinking of just unifying to where all the types match.
04:14:29 <musasabi> audreyt: btw I think one can express it without unification in ghc-fc2
04:16:29 <audreyt> consider
04:16:30 <audreyt> data D a where C1 { l :: a } :: C a C2 { l :: a } :: C Int
04:16:34 <audreyt> sorry
04:16:37 <audreyt> data D a where
04:16:40 <audreyt>     C1 { l :: a } :: C a
04:16:43 <audreyt>     C2 { l :: a } :: C Int
04:17:04 <audreyt> how would you express it in -fc2?
04:17:20 <audreyt> l :: ?
04:17:44 <audreyt> s/data D a/data C a/
04:18:12 <musasabi> that won't work.
04:18:34 <musasabi> note that the fields in my examples have been monomorphic.
04:18:42 <audreyt> *nod* so to deduce a "C a" selector is actually nontrivial
04:19:07 <audreyt> yup
04:19:14 <audreyt> so you can write a helper function for the selecting
04:19:47 <audreyt> if you have an algorithm for this relaxed selector
04:20:00 <audreyt> I think it can go into GHC, maybe :)
04:20:15 <musasabi> so we could get more specific selectors with fc-2 "C a -> Foo" -> "(a == A || a == B) => C a -> Foo" (modulo syntax)
04:20:54 <audreyt> ah.
04:20:58 <audreyt> yes.
04:22:14 <foxy> how is equality on lambda terms in the untyped lambda-calculus defined?
04:28:38 <ibid> foxy: which equality? there are several possible
04:29:41 <foxy> Well, in Barendregt intro they define the equality axioms (refl, symm, trans) but I would have thought they could be proven from some (unknown to me) definition of equality
04:29:54 <foxy> ibid, what different kinds are there?
04:30:52 <ibid> foxy: i mean, alpha equality, beta equality, or some equality function?
04:32:40 <foxy> ibid, um I know about alpha-conversion and bera-reduction and so forth, but the reason I was asking was that B just state these equality axioms without defining equality (Unless I find out otherwise I'm assuming that if M \rightarrow_\alpha N then M = N) *shrug*
04:33:27 <ibid> foxy: well, that's alpha-equality
04:34:29 <foxy> @google Barendregt Introduction
04:34:31 <lambdabot> http://ling.ucsd.edu/~barker/Lambda/barendregt.94.pdf
04:35:12 <foxy> definition 2.7 pg 11
04:35:30 <foxy> (subsection (ii)) :D
04:37:03 <ibid> oh, no
04:37:22 <ibid> they're using simple syntactic equality, not alpha-equality
04:37:51 <ibid> hm sorry
04:38:06 <ibid> 2.8. remark says they're using alpha-equality
04:40:11 <foxy> OK, are they defining equality in terms of alpha-conversion or are they noticing that if one term alpha-converts to another they fulfil the (unspecified) requirements of equality?
04:41:03 <foxy> because surely an unreduced term could be equal to a normal form term (I appreciate that this is hard to determine in practice)
04:41:04 <ibid> they're using equality as an undefined symbol in an axiom system
04:41:44 <foxy> ibid, OK, that's what I suspected, thanks, so what would a workable definition of equality be?  Some handwaving about meanings of terms?
04:41:58 <ibid> uh, what do you mean by "definition"?
04:42:14 <ibid> are you familiar with axiomatic theories in logic?
04:42:48 <vincenz> ibid: erm, why are there more entries in the RSS than on planet haskell?
04:43:00 <vincenz> ibid: I see two entries by "Jason Dagit" in the rss but not in the webpae
04:43:21 <vincenz> ibid: not to mention he's not on the list on the rightside of the planet homepage
04:43:55 <SamB> censorship!
04:44:07 <ibid> vincenz: there are two entries by dagit in the web page, they're just sorted by date
04:44:17 <foxy> ibid, sort of, I guess I can't see why there isn't a workable definition of equality at about that point in the intro...
04:44:20 <ibid> vincenz: yes he is
04:44:21 <vincenz> oh!
04:44:31 <vincenz> odd, they weren't there before
04:44:33 * vincenz is seeing things
04:44:33 <vincenz> :/
04:44:50 <ibid> or *not* seeing things?
04:44:55 <ibid> foxy: sort of meaning?
04:45:01 <vincenz> ah I see now
04:45:21 <Philippa> foxy: because there isn't one equality, so you want to specify which you're using
04:45:24 <ibid> foxy: 2.7. is the definition
04:45:31 <vincenz> Philippa: hi :) thx for the support on haskell'
04:45:35 <Philippa> to put it another way, because there's one equality and it's boring, and then many equivalences
04:45:41 <ibid> foxy: it's just coughed up as a formal axiom system
04:48:04 <foxy> Philippa, ok, what's the definition of the boring equality?
04:48:47 <foxy> I would normally expect to be given a definition of equality and then a theorem that it is an equivalence relation
04:48:53 <Philippa> foxy: it's the obvious one. Two variables are equal if the symbols're equal. Two applications are equal if the subterms're equal. Two lambdas're equal if they bind the same variable and yield equal terms
04:49:08 <vincenz> ast matching :)
04:49:11 <Philippa> right
04:49:13 <vincenz> on a lexical level
04:49:22 <ibid> foxy: what they are doing is give you axioms and you can then prove that it behaves in certain ways
04:49:34 <ibid> syntactic, rather
04:49:48 <psnl> Philippa: what do you mean by "workflow"?
04:49:54 <Philippa> right. You don't need a specific notion of equality
04:50:18 <Philippa> psnl: in which context? More or less "the pattern by which I get work done", but it gets more detailed if you're talking about the LtU subthread about IDEs
04:50:19 <ibid> foxy: you clearly need to read more logic ;)
04:50:37 <foxy> So they're saying that there is some notion of equality with these properties and we're not actually going to define it?
04:50:50 <ibid> foxy: uh, they JUST DID define it
04:50:59 <ibid> foxy: you definitely need to read more logic ;)
04:51:15 <Philippa> if we're talking mailing lists, my work (in this case reading emails) ceases to 'flow' if I organise things the way I'm being told I should
04:51:28 <foxy> but saying something is reflexive, symmetric, and transitive isn't defining it!!
04:51:38 <ibid> foxy: yes it is
04:51:39 <foxy> or is it? hm...
04:51:43 <vincenz> woo
04:51:45 <Philippa> it is if you say it's the least relation satisfying those properties
04:51:49 <vincenz> someone is enjoying spamming my guestbook on my pmwiki
04:52:08 <ibid> foxy: clearly, the students for who the lecture notes are intended, have a lot more experience in axiomatic theories than you :) (no insult intended)
04:52:13 <foxy> OK, well then that's the bit I was missing... that these three properties pick out a relation
04:52:21 <foxy> Thanks ibid and Phillipa :)
04:53:13 <foxy> ibid, I know about sequent calculi &c...
04:53:33 <psnl> Philippa: oh, it was the ML thing on haskell'
04:54:37 <Philippa> basically it's a fancy way of talking about how something affects how productive I am, with intentional resonances with the concept of flow that's sometimes called being in the zone
04:55:03 <psnl> cool
04:55:28 <psnl> I'm in completely the other camp, which seems to work for me
04:56:18 <Philippa> that's fine, completely not my problem :-)
04:56:32 <Philippa> I can see how a more structured approach would work for many people, it just doesn't for me
04:57:13 <psnl> I was just thinking that of all the people who have used the term "workflow", a haskell hacker would be the best to give it a meaning ;-)
04:57:53 <Philippa> heh
04:58:24 <Philippa> often it's used in the context of organisations rather than individuals, I think there's a reasonably sensible and intuitive definition there
04:58:54 <Philippa> I don't know if it gets used in manufacturing, possibly I should ask someone who'd know
05:07:19 <dcoutts__> Igloo: do you think there' any chance we could not kill off Data.FiniteMap api just yet? see email to ghc-users list
05:07:37 <dcoutts__> ie postpose killing it for one release
05:08:21 <SamB> I think I usually hear about workflows in connection with doing art on the computer...
05:08:33 <Igloo> You realise "one release" means until 6.8?
05:08:46 <SamB> (or perhaps finishing art on the computer)
05:09:28 <SamB> where they have to first do some stuff in one program, then go to another, etc...
05:10:20 <Igloo> dcoutts__: You can provide your own Data.FiniteMap wrapper outside of GHC, you know? I think Malcolm Wallace has written one
05:11:09 <SamB> eh, wouldn't it have to be something like what lambdabot did?
05:11:19 <musasabi> Just having a finitemap-compat cabal package will work. Of course it needs Cabal that supports optional/versioned dependencies.
05:11:32 <SamB> a module that would import either Data.Map or Data.FiniteMap, depending on GHC version?
05:11:56 <SamB> (and export the same interface either way?)
05:12:05 <SamB> then again, maybe that is nasty...
05:12:37 <SamB> I too think that it was too soon to take out the deprecated one...
05:13:43 <musasabi> SamB: it is not really that bad a problem. Also one can provide a compat-data-map package and just use Data.Map (and 6.2 users intstall compat-data-map and problems go away)
05:13:47 <SamB> if GHC had used Data.FiniteMap, this would not have happened
05:13:58 <SamB> musasabi: hmm.
05:14:04 <Igloo> GHC does use FiniteMap
05:14:07 <SamB> well if you can do that based on GHC version...
05:14:12 <SamB> Igloo: but not from the library!
05:14:34 <SamB> or else they would have had to leave it in, so that GHC could continue to build!
05:14:43 <dcoutts__> Igloo: true but that doesn't help with breaking progs
05:14:53 <Igloo> No, GHC does the same backwards-compatibility contortions that you're talking about doing
05:14:59 <Itkovian> vincenz: have another try?
05:15:17 <SamB> Igloo: wouldn't it have been easier to just keep Data.FiniteMap than do those contortions?
05:15:29 <SamB> or is Data.Map faster or something?
05:15:35 <dcoutts__> yes and nicer api
05:15:41 <SamB> hmm.
05:15:46 <SamB> curses!
05:16:07 <dcoutts__> Igloo: we can do it outside but for existing progs it means adding extra conditional deps etc, which we can't do with cabal currently
05:16:18 * Igloo thinks the Haskell community should move faster, so isn't going to fight for keeping it
05:16:23 <dcoutts__> and for non-cabalised things it's possible but just a pain
05:16:30 <vincenz> Itkovian: sure
05:16:36 <dcoutts__> ghc 6.2 is not that old
05:16:40 <SamB> Igloo: well, its easier to move if stuff still builds!
05:16:59 <vincenz> Itkovian: I hear nothing
05:17:03 <Igloo> 6.4.1 is almost a year old; I don't have a date for 6.4 handy
05:17:06 <Itkovian> crap
05:17:09 <Itkovian> this sucks
05:17:09 <dcoutts__> Igloo: when did ghc -6.4.x go stable in debian? within the last year?
05:17:13 <vincenz> Itkovian: do you hear me?
05:17:17 <Itkovian> nope
05:17:17 <dcoutts__> 6.4 didn't work
05:17:18 <vincenz> hmm
05:17:20 <vincenz> let's do phone
05:17:21 <SamB> I'll look...
05:17:23 <vincenz> pm me your number
05:17:27 <musasabi> That is just extra motivation to get better Cabal :-)
05:17:39 <musasabi> Igloo: is Cabal frozen for the whole 6.6 time ?
05:17:42 <dcoutts__> so places that hadn't upgraded in a year (like unis) are using 6.2.2
05:17:44 <SamB> oh wait, I don't think the package headers contain that info...
05:17:45 <Itkovian> hmm, better sometime tomorrow then, I'm at home, and the phone line should stay open, as I expect a call
05:17:52 <Igloo> musasabi: Cabal is probably an exception
05:17:56 <Itkovian> an important one
05:18:00 <vincenz> Itkovian: or non-voice
05:18:03 <vincenz> Itkovian: via skype
05:18:12 <Itkovian> suits me fine
05:18:12 * SamB wonders if packages.debian.org can help
05:18:22 <sieni> what was the preferred way for interacting with a pgsql database from haskell?
05:18:36 <sieni> haskelldb?
05:18:37 <Igloo> dcoutts__: Getting GHC backports for Debian stable done faster is one of the things I'd like to see happen, and hopefully it will now I don't have a thesis to worry about  :-)
05:18:43 <dcoutts__> sieni: HDBC with the postgresql backend
05:18:44 <musasabi> hdbc / haskelldb
05:19:19 <kzm> Hmm.. no dropSpaceEnd in Data.ByteString.Lazy.Char8?
05:19:41 <dcoutts__> kzm: no, neither in Data.ByteString
05:19:57 <dcoutts__> it's easy to implement in terms of things we've already got
05:20:03 <dcoutts__> we didn't want to start out with a fat api
05:20:11 <SamB> hmm...
05:20:18 <dcoutts__> Igloo: we went stable with ghc-6.4.1 at about the same time as you, the point being it took ages for it to stabilise
05:20:21 <SamB> how do you find out when a package went into testing anyway?
05:20:23 <kzm> Hmm...you must inform my GHCi, then: dropSpaceEnd :: ByteString -> ByteString
05:20:26 <SamB> or stable?
05:20:27 <kzm> :-)
05:20:37 <dcoutts__> kzm, you're using fps-0.7
05:20:55 <dcoutts__> the version in base now has a slimmer api
05:20:56 <kzm> Whatever's shipped with ghc-6.5 something, yes.
05:21:08 <SamB> 6.4.1 isn't even *in* stable yet...
05:21:19 <dcoutts__> really!
05:21:27 <dcoutts__> wow you move slowly :-)
05:21:46 <dcoutts__> ghc-6.4.2 is only just in the last few weeks stable in gentoo
05:21:57 <SamB> I think those of us who want software that isn't ancient usually use testing...
05:21:58 * kzm sighs.
05:22:03 <dcoutts__> and 6.4.1 was stable less than a year ago
05:22:22 <dcoutts__> so many people not on the bleeding edge will have 6.2.2
05:22:26 <kzm> So I need to upgrade ghc again, I take it.  Or go back to 6.4.2, and install a separate FPS.
05:22:45 <dcoutts__> kzm: or write dropSpaceEnd, it's a one-liner
05:23:06 <kzm> Right.
05:24:50 <SamB> hmm...
05:25:46 * SamB wants to add #perl6 style karma changing to lambdabot, wonders how to find the "nick++"s...
05:26:42 <audreyt> match \w+ and check channel userlist
05:26:52 <kzm> What's the simples way to convert from a lazy BS to a strict one?
05:27:25 <SamB> xs will probably get insanely high karma
05:27:36 <SamB> or well, maybe not
05:27:38 <audreyt> convert (LPS xs) = B.concat xs
05:27:47 <kpreid> Is it possible to use a UTF-8 encoded source file (that uses above-ASCII characters in identifiers) with GHC?
05:27:51 <audreyt> yes.
05:28:01 <SamB> kpreid: in identifiers?
05:28:12 <audreyt> oh wait
05:28:12 <kzm> Ah, it's just a list of regular ones.  Of course.  Thanks, audreyt.
05:28:22 <audreyt> in strings, sure
05:29:15 <kpreid> > let a ‚à© b = nub $ a ++ b in A ‚à© b
05:29:15 <lambdabot>  Illegal character ''\136''
05:29:17 <kpreid> like that
05:29:35 <vincenz> > nub [1,2,1]
05:29:36 <lambdabot>  [1,2]
05:29:54 <kpreid> er, I meant ‚à™, but never mind :)
05:30:53 <SamB> kpreid: even if it works in GHC, lambdabot's parser won't parse it...
05:31:04 <kpreid> it's only GHC I actually care about
05:31:11 <SamB> @type let a ‚à© b = nub $ a ++ b in A ‚à© b
05:31:12 <lambdabot> lexical error
05:31:14 <kpreid> or, is there another haskell implementation that does?
05:31:22 <SamB> okay, so GHC doesn't seem to like it either...
05:31:39 <SamB> dunno! JHC uses utf-8 in its output!
05:33:40 <vincenz> > maxBound :: Integer
05:33:41 <lambdabot>  add an instance declaration for (Bounded Integer)
05:33:41 <lambdabot>   In the expression: ma...
05:33:45 <vincenz> > maxBound :: Int
05:33:46 <lambdabot>  2147483647
05:34:56 <SamB> hmm hmm
05:35:27 <SamB> how come lambdabot's Lib.Regex.regexec takes a Ptr CChar, not a bytestring?
05:35:57 <dcoutts__> coz' no one's fixed it yet
05:41:42 <vincenz> @hoogle int
05:41:43 <lambdabot> Text.PrettyPrint.HughesPJ.int :: Int -> Doc
05:41:43 <lambdabot> Data.Int :: module
05:41:43 <lambdabot> Prelude.Int :: data Int
05:41:46 <vincenz> @hoogle Int64
05:41:47 <lambdabot> Data.Int.Int64 :: data Int64
05:42:48 <vincenz> > 1 :: Int64
05:42:48 <lambdabot>  1
05:42:59 <vincenz> @fptools Data.Int
05:42:59 <lambdabot> http://darcs.haskell.org/packages/base/Data/Int.hs
05:52:25 <tibbe> > lines "bla\nbla\n\nbla3\n\n\n"
05:52:26 <lambdabot>  ["bla","bla","","bla3","",""]
05:53:03 <tibbe> > filter (/="") $ lines "bla\nbla\n\nbla3\n\n\n"
05:53:04 <lambdabot>  ["bla","bla","bla3"]
05:56:29 <tibbe> > lines "bla\nbla"
05:56:30 <lambdabot>  ["bla","bla"]
05:56:55 <foxy> \136
05:57:48 <foxy> SamB: how did you enter a \cap and have it display?
05:57:58 <ValarQ> seems like lambdabot has gotten into politics
05:58:38 <dottedmag> foxy: utf-8 prolly
05:58:51 <dottedmag> foxy: 'cause I've got it as two cyrillic characters
06:05:33 <kzm> ghci-6.5 question: why are the result of IO actions printed directly (even if I ask to store the result in a variable)?  And completion seems broken...(known problem?)
06:06:48 <RobHu>  /join #emacs
06:06:51 <RobHu> oops :P
06:07:14 <dons> kzm, completion works for me.
06:07:41 <vincenz> dcoutts: why all the nicks?
06:08:00 <dcoutts__> vincenz: many machines in different countries
06:08:02 <dons> he's got a split personality, but he likes to keep us informed of that
06:08:08 <dcoutts__> heh
06:08:14 <kzm> dons, it seems too eager to complete with functions, but I want to complete a filename (in a quoted string).  I suppose this is possibly a more accurate definition of "works" than the one I prefer in this case :-)
06:08:38 <dons> does it even do file name completion?
06:08:48 <kzm> 6.4.1 did.
06:08:59 <dons> oh, didn't know that.
06:09:06 <dcoutts__> only by accident
06:09:09 <dons> what has been added is this variable name completion
06:09:14 <dons> was it an artifact of readline?
06:09:16 <dcoutts__> because readline does file completion by default
06:09:17 <kzm> Possibly, it was just by accident from readline's default behaviour.
06:09:18 <dons> right
06:09:20 <kzm> Ah.
06:09:23 <kzm> :-)
06:09:36 <kzm> If it ain't the truth, at least it's the consensus.
06:09:43 <eivuokko> Should there be completion at Windows, too?
06:09:54 <dons> is readline used on windows/
06:10:09 <eivuokko> Eh.  No
06:10:19 <kzm> that IO results are echoed is worse, though.  Any way around that?
06:10:37 <dons> so that was added (to avoid annoying 'print's)
06:10:39 <kzm> (Generally I test with 'x <- parseLargeFile "100Gb"'
06:10:42 <dons> yeah
06:10:54 <dons> really, 100Gb?
06:11:00 <kzm> And then run some functions on x
06:11:06 <kzm> Well, maybe not really.
06:11:10 <dons> 100Gb in ghci? :)
06:11:19 <eivuokko> Is the command history in ghci (in Windows) command prompt service or builtin?
06:11:31 <kzm> I only have 2.1Gb, but that's before I gunzip it.
06:12:10 <kzm> And I expect I'll compile my program before I attack that - but I'd like to check that things work, especially laziness in streaming over the files.
06:12:24 <kzm> So it kind of sucks that ghci just evaluates it for me.
06:12:26 <kzm> :-)
06:12:34 <dons> yeah, it seems like we should be able to turn off the printing behaviour
06:12:48 <dons> mailing list?
06:13:04 <kzm> Anyway, 134Mb worked like a charm (knock on wood), so I have high hopes.
06:13:23 <musasabi> Does that make it impossible to return an infinite list in the IO monad and bind to it easily?
06:13:28 <SamB> dons: how would *you* go about finding stuff like "nick++"?
06:13:35 <kzm> I can file a report - just wondered if it was a known issue.
06:13:45 <dons> hmm. in the seen plugin, SamB, we have all the known nicks
06:13:55 <dons> so you could look up words in that tabel, if they end in ++
06:14:23 <musasabi> "(val,_) <- liftM (\v -> (v,somethingNotShowable) $ createInfiniteListInIO" is ugly
06:14:45 <dons> :set quiet -- should be possible :)
06:15:04 <dons> or -v0 should turn off printing, perhaps
06:15:10 <vincenz> musasabi: yeah it is
06:15:19 <vincenz> liftM (flip (,) notShowable) is better
06:15:22 <SamB> dons: what is a nice way to find them in the first place?
06:15:52 <SamB> I don't see any decent regexes about...
06:16:05 <dons> \w+\+\+ ?
06:16:16 <SamB> dons: I meant, decent support for regexes...
06:16:29 <dons> oh, we have Text.Regex...
06:16:34 <dons> look in Eval.hs for examples
06:16:40 <vincenz> dons: why spaces prior to ++
06:16:40 <dons> pattern guards help
06:16:48 <vincenz> \<\+\+\>
06:16:49 <dons> oh, is \w \W
06:18:22 * tibbe really hates Java's everything is an object philosophy
06:18:23 * dons evaporates into the air
06:18:28 <SamB> why isn't there a function that returns the matched groups?
06:18:49 <SamB> regexec does not count, because you need to pass it a Ptr and stuff
06:19:04 <tibbe> MyContainerOfFunctions.aFuntionThatCertainlyIsn'tAnObject.run(arg)
06:19:12 <vincenz> tibbe: even worse is the fact is that it is not true
06:19:38 <SamB> the function *is* an object, but doesn't want to be...
06:19:40 <tibbe> vincez, you mean the int, boolean guys or on a more general element that syntactic elements aren't objects?
06:19:46 <vincenz> tibbe: both
06:20:03 <vincenz> "abc".method()
06:20:41 <vincenz> tibbe: and you orgot
06:21:14 <vincenz> ((MySpecialFunctionObject)MyContainerOfFunctions.AFunctionThatCertainlyIsntAnObject()).run(arg)
06:21:21 <SamB> dons: so how do I get info from Seen?
06:21:44 <vincenz> @seen samb
06:21:44 <lambdabot> samb is in #perl6 and #haskell. I last heard samb speak 23s ago.
06:22:11 <tibbe> on top of that I have to use 1.4 so I can't even get away with some static imports so I don't have to prefix my functions
06:22:17 <tibbe> - generics
06:22:17 <SamB> vincenz: dons suggested that I use some stuff that Seen has to do that nick++ style of karma...
06:22:42 <SamB> so I kinda want to know about inter-module communication
06:22:51 <vincenz> ah
06:22:56 <vincenz> SamB: no idea :/
06:23:18 <SamB> oh, did he go to bed?
06:23:32 <vincenz> yah
06:23:34 <vincenz> he evaporated
06:33:53 <SamB> @hoogle prefix
06:33:54 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
06:33:54 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
06:33:54 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
06:34:04 <SamB> @hoogle start
06:34:05 <lambdabot> Text.Html.start :: Int -> HtmlAttr
06:34:05 <lambdabot> Test.HUnit.Base.ReportStart :: type ReportStart us
06:34:05 <lambdabot> Text.ParserCombinators.Parsec.Language.commentStart :: LanguageDef st -> String
07:01:55 <Pupeno> lisppaste2: url?
07:01:55 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:02:09 <lisppaste2> Pupeno pasted "Examples of import" at http://paste.lisp.org/display/25340
07:02:38 <Pupeno> Can anybody give me more examples of import (for my syntax highlighting testing file) ?
07:03:17 <Lemmih> Pupeno: import qualified M; import qualified M as A; import M hiding (...)
07:03:40 <SamB> nick++
07:03:55 <Lemmih> Or all together: import qualified M as A hiding (...)
07:04:02 <_SamB_bot> nick's karma raised to 1.
07:05:33 <kpreid> Lemmih: also, renaming?
07:08:00 <alar> where can I find IRC library that lambdabot is based on?
07:08:09 <int-e> @version
07:08:09 <lambdabot> lambdabot 4p124, GHC 6.5 (OpenBSD i386 )
07:08:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:08:14 <SamB> library?
07:08:16 <fasta> (null.nodes.preprocess.buildGraphFromData) (normalizeEdges [(1,2),(2,3)])
07:08:27 <int-e> lambdabot is its own library
07:08:28 <SamB> there is no library.
07:08:33 <fasta> I get a complaint because I haven't specified the exact graph type.
07:08:45 <alar> libirc or how is it called
07:08:50 <SamB> well, I mean, the library is the program...
07:09:06 <fasta> Where do I need to put the annotation to make it work without changing how the code is written?
07:09:52 <SamB> well, you could annotate buildGraphFromData with a type...
07:09:53 <fasta> The graph type should be  Gr () ()
07:10:54 <alar> oh, it talks to sockets directly
07:11:04 <alar> no intermediate IRC layer
07:11:23 <alar> if I understand sources right
07:11:33 <int-e> right
07:11:50 <fasta> SamB: Could you be more specific?
07:12:24 <lisppaste2> Pupeno annotated #25340 with "Any more ?" at http://paste.lisp.org/display/25340#1
07:12:26 <fasta> Never mind
07:12:40 <Pupeno> Any more differnts way to write imports ?
07:12:55 <fasta> (I had forgotten about my EdgeLabel )
07:13:58 <int-e> Pupeno: explicit import lists are missing. import Data.Array (array)
07:14:16 <fasta> Pupeno: you could also add import Prelude, since that's a special case
07:14:53 <Pupeno> fasta: this is only to test syntax highlighting, is "import Prelude" in any way special form that point of view.
07:14:57 <Pupeno> int-e: thanks.
07:15:05 <fasta> Pupeno: no
07:21:53 <lennart> pupeno: I don't see the mist common of them all 'import Hello(world)'
07:22:01 <lennart> s/mist/most/
07:22:12 <Pupeno> lennart: thanks.
07:22:39 <lennart> and what about the different things you can put in the import list?
07:23:04 <lennart> Foo, Bar(..), Baz(glurph)
07:24:15 <bringert> Lemmih: sweet! (regarding fastcgi concurrency working in GHC 6.6)
07:24:36 <bringert> Lemmih: is that with Apache, or something else?
07:24:43 <fasta> Pupeno: The Haskell report is pretty clear on all the possibilities.
07:24:45 <Lemmih> bringert: lighttpd.
07:24:47 <ventonegro> 6.6?
07:25:04 <Lemmih> bringert: Yeah, it's great. I wonder what was wrong in ghc-6.4, though.
07:27:02 <Pupeno> All imports highlighted correctly :)
07:28:11 <fasta> Pupeno: on what editor are you working?
07:28:16 <Pupeno> fasta: Kate.
07:28:26 <bringert> I wonder if the threadsafe version works correctly under Apache and GHC 6.6 when uses single-threaded
07:28:45 <fasta> Pupeno: are you only making a style file?
07:29:02 <fasta> (or whatever it is how you can specify styles)
07:29:08 <vincenz> hiya bringert
07:29:16 <bringert> hi vincenz
07:30:43 <Pupeno> fasta: so far, yes. Latter on if I continue to code Haskell, my roadmap would be: indentation profile, language support in KDevelop, then interpreter support in KDevelop and project (Cabal) support in KDevelop.
07:31:02 <vincenz> bringert: haven't had time yet to think of more use-cases (working on a paper atm
07:31:26 <Pupeno> maybe the interpreter support might be usefull for Kate itself... but thinking about it, it might be a waste of time to invest to much on KDE 3 with KDE 4 "around the corner".
07:31:32 <TomMD> Whats the most popular haskell program outside the haskell community?
07:31:48 <int-e> darcs I suppose
07:32:39 <vincenz> yep
07:32:40 <vincenz> darcs
07:36:20 <Pupeno> it also does folding.
07:38:50 <dcoutts__> @seen shapr
07:38:50 <lambdabot> I haven't seen shapr.
07:38:55 <dcoutts__> !!
07:39:04 <dcoutts__> @summon shapr
07:39:04 <lambdabot> Unknown command, try @list
07:39:26 <sieni> hahaaa :-)
07:39:27 <alar> @get-shapr
07:39:27 <lambdabot> shapr!!
07:40:14 <Pupeno> @get-bleh!!
07:40:14 <lambdabot> Unknown command, try @list
07:50:31 <SamB> arg, why does GHCi mess with my terminal settings so?
07:50:55 <SamB> the damn enter key doesn't work right if I try to run darcs from inside it!
07:51:10 <SamB> wait, I'm not even in it anymore...
07:51:14 <SamB> maybe lambdabot did it...
07:51:34 <ValarQ> @slap lambdabot
07:51:35 * lambdabot beats up lambdabot
07:51:48 <mauke> $ reset
07:51:57 <lambdabot> I didn't do it, I swear!
07:52:06 <SamB> haha!
07:52:14 <SamB> lambdabot: not you. my copy!
07:53:29 * SamB wonders how dons was expecting him to access the stuff in Seen from Karma
08:09:06 * lambdabot smacks Valarq
08:15:33 <Pupeno> the comma separated lists at the imports, is there any case where I can have a sublist ?
08:16:51 <Lemmih> import X (D (Y,Z))
08:17:59 <int-e> for type classes and algebraic data types
08:23:21 <nattfodd> hi
08:23:38 <nattfodd> I was just wondering if it was possible to get a copy of http://en.wikibooks.org/wiki/Haskell
08:23:55 <nattfodd> in another way than mirroring the website
08:24:36 <nattfodd> I don't have much internet connectivity
08:25:12 <kowey> nattfodd: perhaps you could ask on the Staff Lounge that somebody create a PDF for it
08:25:31 <kowey> i've seen some PDF'ed wikibooks floating around, but don't know how they get made
08:26:02 <nattfodd> I think it's easy to do with wikimedia
08:27:40 <kowey> the haskell wikibook, btw, is one of the wikibooks hot picks... it doesn't mean much, just a big (rotated) list of largish wikibooks
08:29:29 <apfelmus> nattfodd: partly negative answer from http://en.wikibooks.org/wiki/Help:Readers%27_FAQ and http://en.wikibooks.org/wiki/Wikibooks:Print_versions
08:29:32 <apfelmus> you could try to setup a printable haskell book by editing the wikibook somehow
08:29:45 <vincenz> @seen ibid
08:29:46 <lambdabot> ibid is in #haskell. I last heard ibid speak 3h 37m 38s ago.
08:30:03 <CosmicRay> Igloo: ping
08:30:44 <ibid> pong
08:30:56 <ibid> that was to vincenz  :)
08:31:08 <CosmicRay> heh
08:31:10 <ibid> vincenz: looking at my idle time on whois is abetter guide :)
08:31:18 <vincenz> ibid: yep, it's a low priority issue, but when you have nothing to do, if you could change my blog-link
08:31:25 * vincenz switched to blogger.com
08:31:35 <ibid> vincenz: email me
08:31:38 <vincenz> ok
08:32:00 <ibid> i suppose i should publish planet as a darcs sendable repo
08:32:01 <ibid> :)
08:33:42 <vincenz> ibid: yeah :)
08:34:10 * ibid got a new laptop :)
08:34:16 <ibid> it's an amd64 :)
08:34:20 <vincenz> congrats
08:35:11 * ibid waits for the install disk image download to finish
08:36:35 <Igloo> CosmicRay: pong
08:37:51 <CosmicRay> Igloo: two questions for you: 1) how's the alpha stuff, and 2) the link on your blog to your source code for lars' benchmark is broken
08:38:00 <CosmicRay> err
08:38:06 <CosmicRay> never mind on #2, that was syntaxninja.
08:38:15 * CosmicRay kicks self
08:38:58 <Igloo> still working on the alpha stuff, I'm afraid
08:39:02 <CosmicRay> ok
08:44:39 <CosmicRay> Igloo: anything else I can do to help?
08:45:36 <Igloo> CosmicRay: Don't think so
08:49:47 <musasabi> Does anyone know a graph implementation on top of STM?
08:54:22 <Korollary> I don't. I think edwark is working on a STM hashtable or something, though.
08:58:57 <fasta> Is there a way to curry if expressions?
08:59:09 <velco> what is STM >
08:59:15 <musasabi> there is at least some STM BTree(+) code around.
08:59:27 <musasabi> velco: software transactional memory
08:59:35 <velco> thanks
08:59:57 <musasabi> http://www.haskell.org/haskellwiki/Software_transactional_memory
08:59:59 <lambdabot> Title: Software transactional memory - HaskellWiki, http://tinyurl.com/gbh69
09:01:54 <sieni> state transition matrix? :-)
09:03:50 <SamB> @where ZMachine
09:03:50 <lambdabot> http://naesten.dyndns.org:8080/repos/ZMachine
09:07:00 <SamB> ack...
09:07:03 <SamB> no ports
09:07:10 <SamB> or, well, not that one..
09:08:17 <SamB> wait wait
09:08:20 <SamB> it isn't that!
09:08:23 * SamB sighs
09:08:40 <fasta> When I use (liftM foo?) where in a context where foo? is defined, I get that foo can't be found...
09:08:42 * SamB upgrades ddclient
09:08:51 <SamB> stale DNS ;-)
09:08:54 <fasta> This seems a bug in ghc-6.4.2
09:09:17 <Korollary> fasta: paste the code?
09:09:21 <Korollary> @paste
09:09:21 <lambdabot> http://paste.lisp.org/new/haskell
09:10:01 <fasta> Korollary: I will see whether I can make a simple example
09:11:02 <nattfodd> apfelmus: I just created a crude version: http://en.wikibooks.org/wiki/Haskell/Print_version
09:12:21 <Korollary> fasta: btw, ? is not allowed in identifiers in haskell.
09:12:45 <fasta> Korollary: GHC allows it appararently
09:13:07 <Korollary> I got a parse error. Hm.
09:13:14 <Korollary> > let a? = 1 in a?
09:13:15 <lambdabot>  Parse error
09:13:34 <xs> > let ?a = 1 in ?a
09:13:35 <lambdabot>  Parse error
09:14:07 <xs> ah, no -fglasgow-exts..
09:14:37 <musasabi> Aren't ?foo reserved for implicit parameters?
09:14:52 <xs> yes.
09:16:04 <apfelmus> nattfodd: nice :) so you assembled all things by hand? what's when content of the hyperlinked version is changed?
09:16:44 <nattfodd> apfelmus: no, it uses wikipedia template
09:16:51 <nattfodd> so content is automatically modified
09:16:58 <nattfodd> there are some missing sections though
09:17:51 <bringert> Igloo: are extralibs also subject to the RC API-freeze?
09:19:03 <Igloo> bringert: No
09:19:52 <bringert> when the release happens, what versions of will be bundled with the binary distributions?
09:20:09 <bringert> of extralibs that is
09:20:27 <Igloo> Whatever's in the HEAD at the time, I guess
09:20:54 <bringert> so it could differ between different platforms, for example
09:21:00 <apfelmus> nattfodd: ah, phew. it's a bit big, maybe you could break it into three-four parts (basic, advanced, practice,appendix)
09:21:19 <bringert> it should be easy enough to upgrade though
09:21:39 <Igloo> I think they'll all probably come from a tarball made on the day of the release
09:21:58 <SamB> does this tarball include the .svn data?
09:22:07 <SamB> I guess it is unlikely...
09:22:26 <bringert> Igloo: great, thanks. that means I can keep hacking away
09:22:31 <SamB> wait, we use darcs
09:22:40 <SamB> ... which is worse
09:23:33 * SamB wonders how you would handle specify what versions the various packages were supposed to be... guesses you'd need to tag them all for the release...
09:24:18 <Igloo> I'll probably try to tag then inc the version number of them all
09:25:10 <Igloo> The tarballs don't include _darcs
09:26:15 <SamB> yeah, I figured
09:26:31 <SamB> that would waste even more space than .svn...
09:27:06 <SamB> (which doesn't store patches, just pristine copies of files in whatever revision the working copies are based on)
09:29:36 <SamB> @tell edwardk that the problem was that ddclient hadn't updated my DNS entry, and seems to be fixed ;-)
09:29:36 <lambdabot> Consider it noted.
09:31:21 <sjanssen> @seen sjanssen
09:31:22 <lambdabot> You are in #haskell. I last heard you speak just now.
09:34:02 <SamB> @messages
09:34:02 <lambdabot> You don't have any new messages.
09:38:46 <SamB> @tell #haskell hello
09:38:46 <lambdabot> Consider it noted.
09:38:50 <irgs> @arr
09:38:51 <lambdabot> Arrr!
09:48:49 <TomMD> @where galois
09:48:49 <lambdabot> I know nothing about galois.
09:48:57 <TomMD> @where hackathon
09:48:57 <lambdabot> I know nothing about hackathon.
09:49:18 <Igloo> 12725 SW Millikan Way, Suite 290, Beaverton, OR 97005
09:50:41 <Igloo> No, I tell a lie, it's moved
09:50:47 <TomMD> Really?
09:50:54 <TomMD> Where to?
09:50:54 <Igloo> 1900 SW 4th Avenue, Room 10 according to http://hackage.haskell.org/trac/ghc/wiki/Hackathon
09:53:34 <TomMD> @where hackathon http://hackage.haskell.org/trac/ghc/wiki/Hackathon
09:53:59 <Igloo> Good thing I didn't go for a hotel near the Hackathon for those nights!
09:54:29 <TomMD> lol, yeah, that would be an unfortunate surprise.  What brings you to the hackathon?
09:55:04 <Igloo> I'm a GHC Support Engineer, or something
09:55:18 * Igloo -> food
09:55:20 <TomMD> "Interested in all parts"  Ok then.
10:35:53 <apfelmus> @arr
10:38:30 <sieni> I was wondering why my laptop was making such a noice, but it was just ghc compiling
10:39:27 <norpan> it wasn't noise then? :)
10:41:06 <TomMD> Did I break lambdabot?
10:41:27 <Lemmih> @bot
10:42:52 <sieni> oops typo
11:00:52 <vincenz> re
11:01:12 <ValarQ> hi vincenz
11:02:43 <vincenz> hi
11:02:52 <vincenz> that's odd, it didn't highlight
11:15:14 <sieni> maybe I should have asked for a more verbose output from darwinports
11:15:35 <sieni> now there has just been "--->  Building ghc" for several hours.
11:16:36 <psi> on what kind of cpu?
11:17:07 <sieni> 1 GHz G4 <3
11:17:21 <Pupeno> what does <3 mean ?
11:17:27 <psi> heart
11:17:32 <sieni> its a heart emoticon
11:18:03 <psi> I think it took about 10 hours on my 1.2 GHz. No kidding.
11:18:49 <sieni> well, I'm at least so wise nowadays so as to put all software installations run under screen, so I can log out in the mean time
11:20:38 <ValarQ> psi: it's ‚ô° nowadays
11:21:50 <ValarQ> psi: and be sure to tell jagular ;D
11:22:30 <vincenz> Pupeno: smaller than 3
11:22:54 <vincenz> or failing that, if you read it in the proper direction of smileys, an ass with a hat on it
11:23:20 <psi> ValarQ: hehe, nice
11:24:01 <vincenz> -‚ô°->
11:24:01 <psi> „ÉÑ
11:24:10 <vincenz> psi: chinese?
11:24:18 <psi> japanese
11:24:21 <vincenz> prolly means bastard :)
11:24:25 <vincenz> even though it looks like a smiley
11:25:24 <psi> I think it's just a sound
11:30:04 <Pupeno> o<--3=|
11:30:21 <Pupeno> o3->=
12:05:01 <dgoldsmith> It's katakana, pronounced "tsu".
12:06:07 <dgoldsmith> katakana are used for foreign words and emphasis
12:06:15 <vincenz> o „ÉÑ
12:06:17 <vincenz> sun tsu?
12:06:29 <dgoldsmith> e.g. „Ç≥„É≥„Éî„É•„Éº„Çø„Éº
12:06:47 <dgoldsmith> "KONPYUUTAA"  == computer
12:07:32 <dgoldsmith> Sun Tsu is a Chinese name and would be written in Chinese characters.
12:08:40 <vincenz> I was joking... the little 'o' looks like a sun... I doubt that in either chinese or japanese the word "sun" would translate to sound like "sun"
12:09:21 <nuffer> hey, I
12:09:25 <nuffer> oops, sorry
12:10:17 <dgoldsmith> I know you were joking. :-)
12:10:20 <nuffer> hi, I'm trying to install GreenCard (to install HOpenGL), but I get "Could not find module PrettyUtils" when I try to make it
12:10:30 <nuffer> why is this?
12:10:42 <dgoldsmith> http://en.wikipedia.org/wiki/Sun_Tsu
12:13:54 <nuffer> "locations searched: PrettyUtils.hi PrettyUtils.hi-boot"
12:13:59 <nuffer> but not in PrettyUtils.lhs?
12:14:41 <Igloo> GHC is expecting it to already be compiled
12:15:56 <nuffer> is this a bug in the makefile
12:18:22 <Igloo> Probably
12:18:32 <nuffer> well, I compiled them by hand
12:18:35 <nuffer> so hopefully make will work now
12:32:11 <nuffer> "ghc-6.4.1: unrecognised flags: -fno-prune-tydecls"?
12:32:13 <nuffer> what should I do about that?
12:32:59 <musasabi> GreenCard is quite old and might be bitrotted.
12:33:20 <nuffer> meaning...?
12:33:48 <nuffer> hm...
12:33:58 <nuffer> well how am I to get HOpenGL working?
12:33:59 <musasabi> perhaps try omitting that flag
12:34:19 <nuffer> the makefile is putting it in... and I can't seem to find where in the makefile that's specified
12:34:45 <musasabi> nuffer: btw the normal GHC binary distributions ship with opengl prebuilt.
12:34:58 <nuffer> they do?
12:35:21 <nuffer> then why does "import GLUT" cause an error?
12:35:41 <Lemmih> Because it's Graphics.UI.GLUT.
12:35:55 <nuffer> ohhhhh
12:35:57 <nuffer> wow, thanks
12:37:16 <nuffer> and where does GL live?
12:37:23 <nuffer> oh nevermind
12:37:23 <nuffer> found it
12:41:49 <vincenz> hey Lemmih
12:42:00 <Lemmih> Yoyo.
12:42:04 <nuffer> um, how do I link the library in, or whatever, so that I don't get "/usr/bin/ld: Undefined symbols:
12:42:04 <nuffer> ___stginit_GraphicsziRenderingziOpenGL_"...
12:42:31 <nuffer> -package OpenGL?
12:43:02 <nuffer> yes, that was it, excellent
12:43:05 <eivuokko> Yeah.  (Or whatever the package name is).  Or use ghc --make
12:46:01 <Igloo> eivuokko: No sign of MEM_COMMIT in any of my concurrent testsuite runs so far
12:47:03 <Igloo> eivuokko: but conc049(threaded1) just broke to the extent that cygwin's kill blocked trying to kill it; process explorer managed to kill it off, though
12:48:01 <eivuokko> Igloo, cygwin is weak. ;)
12:48:58 <eivuokko> Igloo, Thanks for testing.
12:49:37 <musasabi> @seen edwardk
12:50:23 <Korollary> bot is down
12:51:49 <eivuokko> Igloo, I have seen STM and some QSem stuff break before.  But I thought JaffaCake fixed those... I guess not all bugs got squished, then.
12:53:42 <lectus> Hi! I'm a begginer to Haskell. What is the best online tutorial to learn it? Should I start with Haskell or O'Haskell? What compiler should I use? Is there a GUI toolkit for it? (Tk?)... Lots of questions... hehe... it's because I need to learn this language for a work... thanks
12:55:03 <Korollary> for work? cool.
12:56:11 <Igloo> Hmm, now I can't log off and conc033(opt) has seemingly deadlocked
12:56:17 <lectus> Yes... a university project
12:56:29 <Korollary> lectus: http://haskell.org/haskellwiki/Learning_Haskell
12:56:42 <sh10151> lectus: You're learning it for work? Fascinating
12:56:44 <Korollary> lectus: Yet Another Haskell tutorial, mentioned on that page, is possibly the most popular.
12:57:02 <sh10151> Lindows?
12:57:12 <sh10151> or Linspire or whatever it is
12:57:13 <Lemmih> lectus: Read yaht, O'Haskell is yacky, you can use GTK and GHC is the Haskell compiler/interpreter of choice.
12:58:03 <Igloo> eivuokko: Is there some connected between my rdesktop login and things I run by SSHing into cygwin?
13:03:50 <eivuokko> Igloo, What do you mean?  I suspect cygwin uses hacks to simulate login, not terminal services like Ms things do.
13:04:08 <nuffer> setInitialWindowSize (WindowSize 640 480)
13:04:17 <Igloo> eivuokko: Logging out of rdesktop causes processes run by SSHing to cygwin to deadlock, and logging out doesn't finish until they've been killed
13:04:36 <nuffer> anyone know why I get not in scope errors for both setInitialWindowSize and WindowSize, even though I imported Graphics.UI.GLUT and Graphics.UI.GLUT.Initialization?
13:04:48 <eivuokko> Igloo, Uhhuh!
13:05:03 <eivuokko> Igloo, No idea.  These are sort of reasons I don't use cygwin :)
13:05:46 <Igloo> eivuokko: Can you SSH to MSYS?
13:05:53 <eivuokko> Igloo, Probably not.
13:06:07 <dfranke> can someone point me to a good introduction to concurrent programming with Haskell?
13:06:27 <eivuokko> It's very hard to make console progs work correctly over ssh, necause piped stdin/stdout/stderr don't work like console window.
13:06:32 <eivuokko> (In Windows)
13:07:17 <dfranke> (seems like a referentially transparent language should make concurrency pretty much a no-brainer)
13:08:01 <emu> there's the concurrent module
13:09:13 <nuffer> anyone?
13:10:00 <lectus> Anyone got the link to "Yet another haskell tutorial"? The one I found isn't working...
13:10:33 <eivuokko> @where yaht
13:10:50 <Lemmih> nuffer: Try: :b Graphics.UI.GLUT.Initialization
13:10:53 <eivuokko> I think lambdabot had new address.
13:10:53 <dfranke> www.cs.utah.edu/~hal/docs/daume02yaht.pdf
13:10:59 <nuffer> other functions like getArgsAndInitilialize, createWindow and such are there
13:11:01 <nuffer> okay
13:11:08 <Igloo> nuffer: setInitialWindowSize isn't exported
13:11:27 <nuffer> so I need the full path to it?
13:11:42 <Igloo> No, you can't use it
13:11:49 <Igloo> WindowSize doesn't seem to exist
13:12:02 <nuffer> then how am I suppose to set what size I want my windows?
13:12:14 <Igloo> With initialWindowSize, I assume
13:12:35 <emu> dfranke: http://haskell.org/haskellwiki/GHC/Concurrency
13:13:00 <nuffer> http://www.haskell.org/HOpenGL/documentation/GLUT/Graphics.UI.GLUT.Initialization.html this sure makes it seem like I should be able to use setInitialWindowSize
13:15:02 <Igloo> nuffer: Use http://www.haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT-Initialization.html instead
13:15:30 <nuffer> ah, I suppose that was the source of my confusions
13:19:50 <nuffer> now I get "initialWindowSize not in scope"
13:20:22 <nuffer> but it is listed under :b for that module
13:20:53 <Lemmih> Did you import the module?
13:20:55 <nuffer> eh, I'll work this out eventually
13:21:26 <nuffer> oh, got it, it was just a typo this time
13:21:33 <nuffer> (sorry for jumping the gun)
13:23:05 <yozora> anyone know what the final word was on side-effects and the OI comonad?
13:23:28 <SamB> I heard OI was not really safe...
13:23:57 <yozora> yeah, cuz you can clone the OI context or something
13:24:01 <SamB> but I have no idea what a comonad even *is*, so don't press me for more info
13:24:03 <nuffer> can I use GLUT without using its event loop?
13:24:15 <musasabi> I think it needs linear types or something equivalent.
13:24:46 <yozora> that's what it looked like, which was quite a surprise to me
13:26:28 <yozora> i'm still not quite with data=initial algebra and codata=ADT=terminal coalgebra though
13:26:30 <musasabi> And there is very litle support for that in Haskell world
13:27:06 <yozora> yeah, since we use monads over uniqueness types
13:28:27 <yozora> wikipedia says an F-algebra is an endofunctor C->C with f:FA->A where A is an object of C
13:28:53 <yozora> and supposedly data types are F-algebrae
13:29:25 <yozora> is that when we define some sort of foldr-like for them?
13:29:52 <yozora> sorry, foldr-like catamorphism for them
13:32:41 <yozora> since it brings the data-structured type FA down to something homomorphic?
13:34:49 <yozora> a completely different question then
13:35:10 <yozora> why in an instance declaration, does a concrete type in the context make it undecidable?
13:35:28 <nuffer> hey Lemmih, are you still around?
13:35:53 <SamB> yozora: does it?
13:35:56 <yozora> eg Relation a Bool => Relation (Blah a) Bool
13:36:13 <yozora> for some reason, you aren't allowed to use concrete types before the =>
13:36:21 <SamB> what was the error?
13:36:24 <yozora> I just made up the line there, so it could be wrong
13:36:30 <yozora> it says undecideable instance
13:36:35 <SamB> hmm
13:36:43 <yozora> i read the paper on typeclasses and the expression problem
13:36:50 * SamB doesn't get it
13:36:54 <yozora> and tried to write a typed interpreter
13:36:58 <SamB> that doesn't look very hard to decide!
13:37:12 <yozora> class Eval a r where eval :: a -> r
13:37:17 <yozora> and then I got to if
13:37:17 <SamB> are you sure that was the only instance?
13:37:43 <yozora> just a sec, I'll find the code
13:38:42 <SamB> Its not like you could have an infinite type or anything...
13:39:22 <yozora> instance (Eval a b, Eval c Bool) => Eval (IfExp c a) b
13:39:42 <yozora> i'll just fire up GHC to check it's the same code i was trying
13:40:02 <yozora> "Non-type variables in constraint: Eval c Bool"
13:40:13 <yozora> "(Use -fallow-undecidable-instances to permit this)"
13:40:22 <yozora> and when I do allow undecideable instances, it works
13:40:30 <yozora> but I'd rather not do weird things
13:40:45 <nuffer> does anyone know if SDL bindings work on OS X?
13:41:29 <Lemmih> They almost work.
13:41:54 <yozora> the idea is IfExp takes type params c and a, c should eval to Bool
13:41:57 <SamB> yozora: I suppose the Bool was the problem...
13:42:01 <yozora> and a can evaluate to b
13:42:03 <yozora> yeah it was
13:42:16 <yozora> there's like a throwaway line in the haskell spec about it
13:42:26 <vincenz> Heh
13:42:26 <thetallguy> Has anyone used hstags in a coons age?
13:42:34 <vincenz> why do people always beat down others on /.
13:42:51 <vincenz> every time some guy is discussed, like someone leaving debian, or some guy with a hack he presented somewhere
13:42:59 <vincenz> people are all over, beating him into the ground
13:43:10 <thetallguy> vicenz: because it's easier to criticize than to create
13:43:47 <vincenz> it's pretty sad
13:43:54 <yozora> 7.4.4.3 Undecidable instances part 2 in http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/type-extensions.html
13:43:55 * Korollary criticizes vincenz for bringing this topic up.
13:43:57 <vincenz> most comments on /. articles are so terribly inane
13:43:58 <thetallguy> it is also easier to feel superior if you don't get the facts
13:44:19 <thetallguy> Yup.
13:44:31 <vincenz> well most articles are as well
13:44:39 <vincenz> any better news sources?
13:44:44 <yozora> i don't really know anything about GHC/haskell context reduction so the restriction feels kind of out-of-the-blue
13:44:47 <thetallguy> I've got a lot of experience with uninformed flaming there.
13:44:56 <sjanssen> yozora: you probably want something like: class HasBoolType a; instance HasBoolType Bool; instance (Eval a b, Eval c x, HasBoolType x) => Eval (IfExp c a) b;
13:44:57 <thetallguy> Yes, sciencedaily.com
13:45:16 <thetallguy> Read the original sources for the slashdot links
13:45:25 <thetallguy> and then start reading those sources.
13:45:33 <SamB> sjanssen: wouldn't that not let you do anything with the Bool, though?
13:45:43 <thetallguy> The Register has a biting wit, but the check their facts.
13:45:45 <vincenz> thetallguy: sadly most articles are rather from crappy sources, hardly well-written
13:46:08 <thetallguy> Trace them back to the original source
13:46:14 <sjanssen> SamB: hmm, yeah.  You'd probably put toBool and fromBool methods in the HasBoolType class
13:46:50 <yozora> hmm
13:47:06 <vincenz> thetallguy: yeah but it's mostly something to read casually... see for interesting tidbits but hardly as research, got better things to do o.O
13:47:20 <sjanssen> yozora: so this type class mixes type checking and evaluation?
13:47:21 <thetallguy> I used to think so
13:47:32 <yozora> yeah,
13:47:41 <thetallguy> but then I wound up on the wrong end of /.
13:47:45 <vincenz> thetallguy: blegh, the register is a bit spammy for my tastes, or flashy at least
13:47:48 <vincenz> thetallguy: oh?
13:48:04 <yozora> I figured might as well put as much information into the type as possible
13:48:11 <thetallguy> and I decided I owed it to myself to be more diligent about tracking down info before making decisions.
13:48:19 <vincenz> thetallguy: ex-flamer?
13:48:27 <thetallguy> Heh.
13:48:30 <vincenz> thetallguy: following the 14 steps?
13:48:33 <thetallguy> v: I work for Linspire.
13:48:47 * vincenz switches back from octal
13:48:52 <vincenz> that's the linux that looks like windows, right?
13:48:52 <yozora> ooh, does this link mean the constraint is dropped: http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/13500 ?
13:48:55 <sjanssen> yozora: have you seen GADTs?  They're a GHC only extension, but they make for pretty nice typed interpreters like you're doing
13:49:08 <thetallguy> v: See?
13:49:16 <vincenz> thetallguy: see what?
13:49:23 <thetallguy> v: Your impression of Linspire comes entirely from flames on /.
13:49:36 <thetallguy> lol
13:49:39 <vincenz> thetallguy: yeah but I'm not criticizing
13:49:51 <SamB> > 014
13:49:53 <vincenz> I was trying to identify, that is all, one identifies by common labels
13:49:53 <yozora> yeah, I know the normal way is to use GADTs, I just wanted to try out the
13:50:05 <thetallguy> v: yes, we're a Debian based distro
13:50:21 <yozora> "extensible" way of doing things - I didn't know haskell could solve the expression problem
13:50:23 <SamB> thetallguy: oh, we actually have heard good things about linspire ;-)
13:50:26 <yozora> so I wanted to try it out
13:50:26 <thetallguy> with focus on desktop polish needed for the general consumer makret
13:50:28 <vincenz> thetallguy: I se
13:50:28 <SamB> or at least flattering things ;-)
13:50:34 <thetallguy> lol
13:50:41 <thetallguy> It's been getting better.
13:50:49 <vincenz> thetallguy: how do you differentiate from ubuntu?
13:50:57 <SamB> I heard you are using Haskell for your tools?
13:51:03 <thetallguy> See freespire.org   codecs
13:51:13 <thetallguy> Yes.
13:51:24 <thetallguy> We've used both O'Caml and Haskell for years.
13:51:29 <vincenz> neat )
13:51:30 <vincenz> :)
13:51:33 <vincenz> oh yeah I heard about that
13:51:34 <SamB> see, this leads us to think that you are smart ;-)
13:51:35 <thetallguy> But we're all switching to Haskell
13:51:36 <vincenz> haskell filesystem talk
13:51:59 <vincenz> thetallguy: so erm, apologies about my lack of knowledge, how are you debian based if you write it in haskell?
13:51:59 <thetallguy> and our management has moved to a fully open system.
13:52:16 <SamB> vincenz: they write their *own* tools in Haskell
13:52:23 <SamB> they don't write the Debian tools in Haskell...
13:52:25 <thetallguy> So we're looking to finish/polish/publish our tools so people who use Debian can pick them up.
13:52:27 <SamB> those work okay as it is...
13:52:32 <SamB> well, mostly.
13:52:48 <thetallguy> v: we import Debian, add/modify packages
13:52:53 <SamB> anyway it would be *far* too much work for lazy programmers ;-)
13:53:01 <vincenz> SamB: yeah but what tools?
13:53:05 <SamB> vincenz: I dunno
13:53:09 <velco> admin tools
13:53:15 <thetallguy> Our hardware detector is in ocaml
13:53:18 <SamB> oooh
13:53:19 <SamB> cool
13:53:27 <thetallguy> We are making a Debian autobuilder in Haskell
13:53:32 * vincenz nods
13:53:32 <velco> guess written not by lazy programmers
13:53:35 <vincenz> so slowly swapping in parts?
13:53:35 <SamB> neato
13:53:43 <SamB> velco: its a Haskell joke ;-)
13:53:51 <thetallguy> John Goerzen, a debian developer, is redoing all of his tools in Haskell.  No relation to us
13:53:54 <velco> yeah
13:54:00 <SamB> all good programmers are lazy ot a certain extent
13:54:05 * vincenz isn't very aware of linux distros
13:54:09 <SamB> er, *to
13:54:09 <thetallguy> he seems to have gone Python -> ocaml -> haskell
13:54:10 <vincenz> afaik it was mostly just a packaging issue
13:54:17 <vincenz> thetallguy: heh, sounds like me
13:54:28 <thetallguy> v: like many of us
13:54:29 <vincenz> thetallguy: cut-python,paste-scheme
13:54:38 <SamB> I skipped ocaml ;-)
13:54:49 <vincenz> thetallguy: o'caml has some missing bits that make it annoying after a while, lack of first class data-constructors, lack of TCs
13:54:58 <sehute> hi brilliant people
13:54:59 <thetallguy> I went from C -> C++ -> Tcl/TK -> (considered Python) -> Scheme -> O'Caml -> Haskell
13:55:02 <vincenz> not to mention writing "Show" derivations by hand when testing lexers
13:55:09 <SamB> sehute: hello nice person!
13:55:13 <sehute> :-)
13:55:17 <vincenz> thetallguy: me too, though replace tcl/tk by ruby
13:55:21 <thetallguy> v: that's why we're moving away from it too.
13:55:34 <vincenz> thetallguy: what client do you use?
13:55:40 <vincenz> ah gaim
13:55:41 <thetallguy> ByteString
13:55:55 <vincenz> it has tab-completion, I use it at work due to http-proxy
13:55:58 <thetallguy> Was the final tipping point, really
13:56:17 <thetallguy> There just aren't any more excuses.
13:56:18 <thetallguy> ;-)
13:56:18 <vincenz> @karma+ dons
13:56:23 <sehute> > (((+)4) . ((+)4)) 10
13:56:26 <vincenz> @karma+ dcoutts
13:56:36 <vincenz> lambdabot: @bot
13:56:36 <vincenz> @bot
13:56:38 <vincenz> erm
13:56:42 <vincenz> lambdabot: @help
13:56:45 <vincenz> @quit
13:56:55 <SamB> hmm...
13:56:55 <pandres> lambdabot: @help
13:57:00 <SamB> this isn't too accurate...
13:57:07 <SamB> > take 5 [ sin (n * pi / 2) | n <- [1..] ]
13:57:15 <vincenz> lambdabot has crashed
13:57:19 <thetallguy> We had decided long before that...
13:57:20 <SamB> oh
13:57:22 <sehute> lamdabot, we miss you
13:57:30 <vincenz> RIP lambdabot
13:57:37 <vincenz> lambdabot is kind of like google, you just can't function without her
13:57:38 <SamB> > take 5 [ sin (n * pi / 2) | n <- [1..] ]
13:57:47 <thetallguy> ...but it really filled in the performance gap.
13:58:12 <_SamB_bot>  [1.0,1.2246063538223773e-16,-1.0,-2.4492127076447545e-16,1.0]
13:58:19 <vincenz> @quit
13:58:31 * vincenz grins at SamB 
13:58:33 <SamB> oookay...
13:58:36 <SamB> it crashed...
13:58:38 <vincenz> changedt he admin list, hmm?
13:58:38 <pandres> thetallguy: hello, I'm curious, what filled the performance gap besides ByteString?
13:58:39 <thetallguy> Anyone use hstags
13:58:48 <SamB> vincenz: hmm?
13:59:00 * vincenz coughs
13:59:11 <thetallguy> pandres: I'm not sure what you mean
13:59:18 <SamB> oh, I see...
13:59:23 <vincenz> SamB: you just compiled lambdabot without modifying anything besides the name?
13:59:23 <thetallguy> ghc is, in general, fast enough
13:59:28 <SamB> vincenz: what did you do that for?
13:59:39 <sehute> (((+)4) . ((+)4)) 10 returns 18. Why doesn't (((+)4) . ((-)4)) 10 return 10 ?
13:59:43 <pandres> mmm, is there some critical new feat bewsides ByteString that improves the performance?
13:59:44 <vincenz> SamB: I didn't think it'd work
14:00:02 <SamB> hey, I figure that it is important for the powers that be to be able to terminate it if I leave it running and lambdabot is revived!
14:00:12 <thetallguy> the recent work on the alioth charts showed that
14:00:13 <vincenz> SamB: sorry! won't do it again!
14:00:28 <SamB> so I add myself at the end of the list
14:00:28 <thetallguy> We don't use it for all tasks yet.
14:01:11 <thetallguy> But our libraries of debian  tools are improving steadily
14:01:39 <thetallguy> and I feel like they will not need any re-working after this next revision.
14:03:12 <sehute> ahh, it's interpreted like (4-10)+4
14:04:15 <sehute> for some reason
14:04:25 <SamB> > (add 4 . sub 4) 10
14:04:29 <_SamB_bot>  Not in scope: `sub'
14:04:33 <SamB> hmm
14:04:38 <SamB> > (add 4 . subtract 4) 10
14:04:41 <_SamB_bot>  Not in scope: `add'
14:04:46 <SamB> okay...
14:04:55 <SamB> > ((+ 4) . subtract 4) 10
14:05:02 <_SamB_bot>  10
14:05:06 <SamB> why did it complain about sub first???
14:05:44 <sehute> > 10 `subtract` 3
14:05:49 <_SamB_bot>  -7
14:05:56 <sehute> a bit unintuitive, ey? ;)
14:07:29 <sehute> SamB: both sub and add is not known to neither my hugs nor my ghci
14:07:45 <sehute> %s/is/are/
14:08:13 <SamB> sehute: yes, but if you were a compiler, wouldn't you give scope errors in left-to-right order?
14:09:10 <sehute> SamB: that might be, I've never lived out any of my emotions through the percieved eyes of a compiler
14:09:21 <sehute> SamB: (didn't think of that)
14:09:33 <SamB> sehute: more to the point, if you *wrote* a compiler, wouldn't it ... ?
14:10:17 <sehute> SamB: hm, if I were a compiler, I would give errors in the same order as I would evaluate expressions
14:10:41 <SamB> sehute: but that isn't the compilers job ;-)
14:11:56 <sehute> SamB: well, I'm happy that I get any error-messages at all ;)
14:12:05 <Korollary> I am happy that I am not a compiler.
14:12:14 <sehute> well, it's a safe job
14:12:31 <sehute> and you interact with a lot of interesting stuff, if you're lucky
14:14:19 <SamB> sehute: yeah, but you tend not to understand it
14:14:47 <sehute> that's true as well :D
14:14:56 <ffranzosi> hi guys... During the summer of code submissions I proposed a work http://hackage.haskell.org/trac/summer-of-code/ticket/80 which is basically a simple parallel processing library... Since I had finish it I would like to publish it but I would like to know the best way to do it so the community could know about my project and contribute whenever seem proper.
14:14:57 <_SamB_bot> Title: #80 (BSPHlib - A parallel programming library based on BSP model) - Haskell.org  ..., http://tinyurl.com/jqs6c
14:17:54 <Igloo> ffranzosi: Make a darcs repo and announce it on the haskell-cafe or libraries list
14:18:22 <ffranzosi> ok...
14:18:33 <ffranzosi> lgloo: thanks for the advice
14:18:44 <ffranzosi> lgoo: I'll do it today
14:18:54 <Igloo> eivuokko: The results of 9 runs of the concurrent test under Windows are at http://urchin.earth.li/~ian/conc/all.txt (more detail in the other files in that directory)
14:19:53 <SamB> @tell dons lambdabot needs a decent way to test "contextual" stuff
14:19:54 <_SamB_bot> Consider it noted.
14:21:09 <kuribas> Still no syntax coloring for lisppaste...
14:24:54 <eivuokko> Igloo, Cool.  Thanks.
14:29:54 <newsham> http://www.cmcrossroads.com/content/view/6504/120/
14:29:56 <_SamB_bot> Title: CM Crossroads - Learning GNU Make Functions with Arithmetic, http://tinyurl.com/emngg
14:30:09 <newsham> tinyurl == nice addition.
14:33:22 <lisppaste2> nomeata pasted "gtk weirdness (PropLang issue)" at http://paste.lisp.org/display/25367
14:33:45 <nomeata> hmm. ndm does not seem to be here
14:39:55 <vincenz> @seen ndm
14:39:55 <_SamB_bot> I haven't seen ndm.
14:41:40 <newsham> @seen nothin'
14:41:41 <_SamB_bot> I haven't seen nothin'.
14:42:25 <sehute> Anybody into O'Haskell? Is it any good? Is it "future-proof"?
14:43:35 <norpan> nothing is future-proof
14:43:54 <sehute> noradio: nothing is future-proof, but some things are "future-proof" ;)
14:44:20 <sehute> noradio: in this particular connection, I was wondering if O'Haskell would be worth learning and using
14:44:51 <sehute> noradio: more specific, if the trends indicated that it would be more widespread instead of dead in the course of a few years
14:45:34 <norpan> it's hard to predict the market fluctuations you know
14:45:51 <norpan> but it's time to sleep
14:46:28 <newsham> options traders seem to predict the future market fluctuations pretty well
14:47:07 <Korollary> not a lot of people are into oohaskell
14:47:28 <sehute> norpan: well, any answers here would still be a good indication
14:47:28 <sehute> norpan: if you told me: "O'Haskell is crap, it has flaw x and flaw y, the developers are grumpy and we all hate it, so far", it would be good indication that it wasn't exactly "a language for the future", however unscientific this conclusion might be :)
14:47:52 <kuribas> Isn't haskell already OO?
14:47:53 <newsham> 3 out of 4 scientists agree
14:48:30 <kuribas> At least it has typeclasses...
14:48:31 <norpan> haskell is not, and will hopefully never be, oo
14:48:42 <dfranke>  kuribas: depends upon how you define object: http://paulgraham.com/reesoo.html
14:48:43 <_SamB_bot> Title: Rees Re: OO
14:49:23 <newsham> dont discriminate on the basis of orientation
14:50:02 <dfranke> Haskell has 1, 2, 3, 4, 7, and 8.
14:50:11 <sehute> I would guess that you could use all the oo concepts in the current Haskell standard, but not as elegant as if it was built more directly into the language
14:50:37 <norpan> the core of oo to me is stateful objects, something i loathe :)
14:51:03 <norpan> but it's bed time
14:51:06 <sehute> newsham: I'm into discriminating on the basis of random polls on IRC ;)
14:51:08 <norpan> need to sleep before midnight
14:51:14 <sehute> norpan: sleep well
14:51:31 <norpan> (or i will turn into a furry monster)
14:51:31 <Korollary> dfranke: where's 7 in haskell?
14:51:50 <dfranke> Korollary: type classes
14:52:07 <Korollary> dfranke: that's not it.
14:52:46 <kuribas> norpan: Why do they have to be statefull?  Objects can be stateless too.
14:53:09 <dfranke> Korollary: how so?  What can java interfaces do that Haskell type classes can't?
14:54:22 <lispy> can java interfaces do inheritance?
14:54:37 <newsham> interfaces can inherit, but not the implementations
14:55:00 <newsham> there is only single-inheritance for implementation in java, and its outside the interface realm
14:55:20 <lispy> can type classes do inheritance?
14:55:32 <Korollary> dfranke: Type classes and subtyping are different things. See this http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf
14:55:54 <newsham> in haskell?  yup, you can define things like ">>" generically for all Monads and have it inherited
14:56:02 <newsham> (or overriden)
14:56:41 <dfranke> Korollary: oif, I'm not optical-grepping a 76-page paper.  Page number please?
14:57:17 <Korollary> dfranke: The first sentence of the abstract, then.
14:57:21 <lispy> optical-grepping...can you see in regular expressions? ;)
14:58:05 <sehute> searching works with pdf-documents as well?
14:58:08 <newsham> surely a brain is a finite state machine
14:58:13 <newsham> q.e.d. regex.
14:58:38 <deadbeef> @list
14:58:38 <_SamB_bot> list [module|command]. Where modules is one of:
14:58:39 <_SamB_bot> babel base bf compose dice dict djinn drhylo dummy elite eval fact free fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system
14:58:39 <_SamB_bot> tell todo topic type undo unlambda url version vixen where
14:58:45 <lispy> newsham: how about this, if haskell can do inheritance why does the wxhaskel use such weird type hacks to simulate inheritance?
14:59:02 <newsham> lispy: i'm sorry lispy, I cant answer that.
14:59:12 <sehute> I feel like a local declaration, in this huge function we all live in
14:59:32 <lispy> sehute: i live in a big monad under the sea
14:59:39 <sehute> :D
15:00:01 <newsham> lispy: beware stingrays.
15:00:23 <lispy> yeah, that was really sad :(
15:00:31 <sehute> yes
15:00:45 <newsham> yah, who would have thought a guy who makes his living taunting and harassing dangerous animals would have gone out so violently.
15:01:30 <dfranke> newsham: the ironic thing is that after all the insane stupid shit that he pulled and survived, he died doing some that I've done myself and would have no qualms about doing again.
15:01:42 <sehute> did he taunt the stingray?
15:02:04 <newsham> dfranke: payback is a bitch.
15:02:36 <newsham> dfranke: luckily the animals havent entered a death pact against you
15:02:44 <sehute> I had the impression that he was good at judging risk, in connection with animals
15:04:01 <dfranke> I live in Florida, swimming with stingrays is a big tourist attraction here.  I wonder what this will do to the industry.
15:04:10 <lispy> what i found sad was that his children are now out a loving, caring, involved father...those aren't easy to find
15:04:27 <newsham> i've never seen a stingray in the water.. saw an eagle ray once.. that was pretty cool
15:04:47 <newsham> and slightly unnerving (looks a little like a shark from a distance)
15:05:02 <dfranke> sharks and rays are closely related.
15:05:08 <newsham> this is true.
15:05:45 <deadbeef> > let fibonacci 0  = 1; fibonacci 1  = 1; fibonacci(x) = fibonacci (x-1) + fibonacci (x-2) in fibonacci 50
15:05:57 <_SamB_bot> Terminated
15:06:44 <lispy> > let fibs = 1:1:zipWith (+) fibs (tail fibs)
15:06:44 <_SamB_bot>  Parse error
15:06:56 <lispy> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 50
15:06:58 <sehute> > let x = 1
15:06:58 <_SamB_bot>  Parse error
15:07:06 <_SamB_bot>  20365011074
15:07:17 <SamB> this ain't ghci ;-)
15:07:35 <sehute> > [1,2,3]
15:07:39 <lispy> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 10 fibs
15:07:53 <_SamB_bot>  [1,2,3]
15:07:58 <lispy> um....
15:08:01 * lispy waits for it
15:08:39 <sehute> not the sharpest knife in the drawer, that bot ;)
15:08:54 <newsham> > [1,1,2,3,5,8,13,21,34,55]
15:08:59 <_SamB_bot>  [1,1,2,3,5,8,13,21,34,55]
15:09:04 <newsham> smart bot
15:09:21 <SamB> hmm...
15:09:27 <SamB> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 10 fibs
15:09:32 <_SamB_bot>  [1,1,2,3,5,8,13,21,34,55]
15:09:47 <SamB> oh, its just slow...
15:11:04 <sehute> I'm trying to learn the typesystem in Haskell. If I have this: data Color = Red | Green | Blue
15:11:13 <sehute> What's the easiest way to test that it's working
15:11:36 <newsham> > map toEnum $ reverse [116,111,98,32,116,114,97,109,115] :: [Char]
15:11:39 <sehute> Something like x = Red; if x == Green then putStrLn "yes" else putStrLn "no"
15:11:41 <_SamB_bot>  "smart bot"
15:12:15 <Baughn> sehute: Define "check that it's working". As in, the type erroring properly?
15:12:35 <Baughn> sehute: ..or you could do what you just suggested, sure
15:12:48 <sehute> Baughn: as in "just show me the simplest possible example of a self-defined type in action", please :)
15:13:04 <newsham> x = Red
15:13:09 <SamB> is there some way to get runplugs to spend less time compiling?
15:13:38 <SamB> @hoogle unsafeEval
15:13:40 <newsham> main = print Red  -- assuming deriving Show
15:13:43 <_SamB_bot> No matches found
15:14:17 <SamB> see, this is what happens when you run lambdabot on a Pentium II ;-P
15:14:26 <ihope_> @docs Network.Socket
15:14:27 <_SamB_bot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
15:14:37 <ihope_> Wait, what?
15:14:50 <dfranke> ihope_: hi
15:14:51 <SamB> ihope_: wait what what?
15:14:55 * dfranke == archnerd
15:14:56 <ihope_> Ello.
15:15:03 <newsham> samb: so ghc compiled code is too inefficient for anything less than a pentium III class cpu?
15:15:11 <SamB> newsham: not necessarily
15:15:11 <ihope_> SamB: _SamB_bot.
15:15:23 <SamB> ihope_: oh, well, lambdabot crashed
15:15:33 <SamB> now I'm running it on a PII ;-)
15:15:34 <Baughn> sehute: Don't know if this is what you had in mind, but check http://paste.lisp.org/display/25373 anyway
15:15:45 <sehute> Baughn: *checking*
15:16:32 <SamB> > "isn't this slow?"
15:16:42 <_SamB_bot>  "isn't this slow?"
15:16:43 <Baughn> sehute: Oh, and imagine that there's a separate type somewhere that defines Turqoise
15:16:44 <sehute> Baughn: ah, thank you! Exactly what I was looking for
15:16:51 <ihope_> > [1..10]
15:16:56 <_SamB_bot>  [1,2,3,4,5,6,7,8,9,10]
15:17:25 <sehute> > take 5 [1..]
15:17:30 <_SamB_bot>  [1,2,3,4,5]
15:17:34 <ihope_> > filter (\x -> even (floor (sqrt x))) [1..10]
15:17:40 <_SamB_bot>  [4.0,5.0,6.0,7.0,8.0]
15:17:56 <SamB> > ()
15:18:00 <_SamB_bot>  ()
15:18:07 <ihope_> > filter (\x -> even (floor (sqrt x))) [1..100]
15:18:10 <SamB> see, it takes like 5 seconds whatever you do
15:18:14 <_SamB_bot>  [4.0,5.0,6.0,7.0,8.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,36.0,37.0,...
15:18:15 <nomeata> @type (,,,,,,,,,,,)
15:18:16 <Baughn> > let { fib = 2 } fib
15:18:16 <_SamB_bot>  Parse error
15:18:22 <_SamB_bot> forall l k j i h g f e d c b a. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a, b, c, d, e, f, g, h, i, j, k, l)
15:18:33 <ihope_> > let fib = 2 in fib
15:18:34 <SamB> except for parse errors ;-)
15:18:44 <_SamB_bot>  2
15:18:49 <nomeata> I could do @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) now, but that would not be nice :-)
15:18:54 <Baughn> I've hardly even mastered layout mode yet, let alone braces. ;)
15:19:00 <ihope_> > let fib = 1 : 1 : zipWith sum fib (tail fib)
15:19:01 <_SamB_bot>  Parse error
15:19:03 <ihope_> > let fib = 1 : 1 : zipWith sum fib (tail fib) in fib
15:19:07 <_SamB_bot>    Occurs check: cannot construct the infinite type: a = [a -> c]
15:19:07 <_SamB_bot>    Exp...
15:19:16 <SamB> Baughn: your braces were fine
15:19:21 <SamB> but you forgot an "in"
15:19:27 <Baughn> ..doh
15:19:39 <ihope_> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
15:19:44 <Baughn> > [1..]
15:19:53 <_SamB_bot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:19:56 <SamB> also, your braces were superfluous, the layout mode would have inferred them ;-)
15:19:56 <_SamB_bot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:20:20 <Baughn> Maybe. I've always had a \n there before, though.
15:20:59 <Baughn> Haskell's syntax is definitely /not/ simple
15:21:03 <SamB> no indeed!
15:21:08 <SamB> but it *looks* simple
15:21:13 <SamB> which counts for a lot
15:21:18 <sehute> Baughn: ERROR "mydata3.hs":7 - Instance of Eq Color required for definition of bar
15:21:28 <sehute> Baughn: bar color = if color == Yellow then Red else Green
15:21:37 <sehute> Baughn: I'm unable to fix up that line
15:21:42 <ihope_> sehute: data Color = ... deriving Eq?
15:21:50 <SamB> I mean, don't you read a lot more code than you write?
15:22:03 <Baughn> sehute: Right. There's no equivalence class defined for Color, and I haven't gotten through that part of the "gentle" introduction yet
15:22:11 <sehute> ihope_: data Color = Red | Yellow | Green | Turqoise
15:22:16 <ihope_> Now, if you like syntax that's simple but doesn't look like it, try Unlambda.
15:22:27 <SamB> hah
15:22:29 <dfranke> heh.
15:22:39 <ihope_> sehute: data Color = Red | Yellow | Green | Turqoise deriving Eq
15:22:41 <Baughn> I'm mostly afraid that the syntax will look easy to read but actually not be
15:23:08 <SamB> what do you mean?
15:23:14 <SamB> "look easy to read"?
15:23:50 <Baughn> Haskell looks like it's easy to read. But I don't fully understand its syntax, so I don't know if there's something like sticking ; just after the for (and before an indented line) in C
15:24:05 <sehute> ihope_: what does it take for this simple example to work: http://paste.lisp.org/display/25375
15:24:07 <Baughn> Lisp has the advantage that /anyone/ can understand the syntax. Three-year-olds especially so.
15:24:08 <ihope_> Like a password that seems easy to remember?
15:24:16 <SamB> indeed not
15:24:24 <SamB> you cannot stick a ; there...
15:24:34 <Baughn> SamB: ..... -_-
15:24:42 <ihope_> sehute: main = print (bar Yellow)
15:24:45 <SamB> nevermind the lack of fors...
15:24:53 <SamB> well, I don't think you can anyway...
15:25:14 <Baughn> sehute: main is supposed to return something of type IO. bar returns a Color, not IO, so...
15:25:29 <sehute> ihope_: Type error in application
15:25:46 <SamB> well anyway, there is no null statement...
15:25:47 <ihope_> Oh...
15:25:50 <Baughn> Oh. By the way - I was going to look this up, but does anyone have a quick link to show me how do works in terms of other operators?
15:25:55 <SamB> > do ;
15:25:56 <_SamB_bot>  Parse error
15:26:00 <ihope_> sehute: data Color = Red | Yellow | Green | Turqoise deriving (Eq, Show)
15:26:10 <SamB> link?
15:26:35 <Baughn> Well, unless it's simple enough to type into IRC..
15:26:44 <sehute> ihope_: still Type error in application
15:26:54 <ihope_> sehute: what's the error?
15:27:12 <SamB> "do var <- exp; stmts" becomes "exp >>= \var -> do stmts"
15:27:31 <sehute> *** Expression     : print bar Yellow, *** Term           : print, *** Type           : d -> IO (), *** Does not match : a -> b -> c
15:27:32 <SamB> "do exp; stmts" becomes "exp >> do stmts"
15:27:57 <ihope_> sehute: print (bar Yellow), not print bar Yellow
15:28:25 <sehute> ihope_: thank you! :)
15:28:27 <SamB> "do let bindings; stmts" becomes let bindings in do stmts
15:28:28 <sehute> ihope_: it works
15:28:42 <SamB> thats all I can think of...
15:29:00 <SamB> the report probably says it better, but it is quite simple...
15:29:04 <sehute> ihope_: the "deriving" keyword really feels like using inheritance
15:29:09 <Baughn> sehute: Function calls are left-associative, so you were trying to pass Yellow to the function print doesn't return
15:29:16 <sehute> ihope_: and interfaces
15:29:34 <SamB> sehute: you talkin about newtype derivings?
15:29:49 <sehute> Baughn: just didn't see it
15:30:23 <Baughn> Haskell's nice, but reading its errors is somewhat of an IQ test. I suppose that comes with experience too..
15:30:31 <sehute> SamB: I'm trying to learn types, just wanted a working tiny example, and have no idea about newtypes, oldtypes or derivings. But, if I must guess, I think I'm talking about newtype derivings.
15:30:58 <SamB> Baughn: that is the reason they got rid of monad comprehensions (which are now list comprehensions)
15:31:04 <SamB> sehute: we don't have oldtypes
15:31:07 <SamB> just newtypes
15:31:10 <sehute> SamB: ok :)
15:31:23 <Baughn> SamB: Monad compreh... hmm, sounds interesting
15:31:45 <sehute> Sounds brainmunchingly hard to grasp in a minute
15:32:00 <Baughn> That's just because it mentions "monad". ;)
15:32:17 <SamB> a newtype is either (a) a statement defining a new type that has the same representation as another, with a single constructor, or (b) the type thereby defined
15:32:57 <sehute> SamB: okay, then I guess I am talking about a newtype
15:33:17 <SamB> er, actually I don't mean statement...
15:33:23 <SamB> but whatever you call those things
15:34:08 <SamB> I suppose it would make sense to call it a statement, but for some reason a statement is now something that is supposed to be done ;-)
15:35:02 <Baughn> I'm fine with "type declaration", really
15:37:41 <SamB> ah, yeah, thats what you call it ;-)
15:39:22 <sehute> uncurry is the hotness
15:40:08 <Cale> uncurry is to pairs what foldr is to lists
15:40:32 <SamB> it isn't very similar in use though
15:40:47 <Cale> Well, pairs aren't a recursive type :)
15:41:03 <Cale> @type uncurry
15:41:09 <_SamB_bot> forall c b a. (a -> b -> c) -> (a, b) -> c
15:41:26 <Cale> It's replacing the (,) constructor with another function
15:41:32 <dolio> _SamB_bot? :)
15:41:38 <SamB> dolio: lambdabot broke!
15:41:50 <SamB> Cale: oh, did you have folds.svg lying around?
15:41:54 <SamB> someone was looking for it...
15:41:58 <Cale> oh, okay
15:42:05 <Cale> why the svg?
15:42:10 <SamB> dunno!
15:42:25 <dolio> Yikes. More hardware problems, or something else?
15:44:23 <Baughn> Reality bites. It seems to me that such rarified heights as lamdabot shouldn't have to worry about hardware issues.
15:44:28 <SamB> well, I tihnk it just froze actually
15:44:37 <SamB> because it seems to be in the channel still
15:44:49 <dolio> Ah.
15:44:52 <lispy> oh, my lambdabot instance did that the other had
15:44:53 <lispy> er day
15:45:13 <lispy> i hit ctrl+c in the controlling terminal and it caught up with reality
15:45:40 <lispy> which makes me wonder if there is a bug with the signal delivery
15:46:09 <ihope_> @type ($ (,))
15:46:15 <_SamB_bot> forall a b b1. ((a -> b -> (a, b)) -> b1) -> b1
15:46:40 <ihope_> (forall c. (a -> b -> c) -> c) -> (a,b)?
15:46:43 <lispy> ($ (,)) (,) 3
15:46:48 <lispy> > ($ (,)) (,) 3
15:46:51 <_SamB_bot>  Add a type signature
15:46:59 <ihope_> But more general, of course.
15:47:07 <dolio> Wow, either not many people from the US use sphere online judge, or we're a bunch of dummies.
15:47:27 <lispy> sphere online judge?
15:47:34 <ihope_> dolio: both! :-)
15:47:34 <lispy> never heard of it
15:47:41 <dolio> Hehehe.
15:47:55 <SamB> a bunch of dummies and a few okay people...
15:47:58 <dolio> It was recommended in haskell-cafe for someone wanting practice problems for haskell learning.
15:49:18 <dibblego> does the haskell.org web server run with Apache or HWS?
15:49:31 <lispy> apache iirc
15:49:49 <lispy> i don't know that anyone uses hws for real work...probably someone somewher...
15:50:10 <dibblego> I am reading an article that says that it is hoped to move haskell.org off Apache to HWS
15:50:23 <ihope_> @type ($ (,)) ($ (,))
15:50:28 <_SamB_bot> forall b a b1. b -> (a -> b1 -> (a, b1), b)
15:50:31 <ihope_> @type ($ (,)) ($ (,)) ($ (,))
15:50:33 <lispy> yeah and someday the wiki will be written in haskell too :)
15:50:36 <_SamB_bot> forall a b a1 b1 b2. (a -> b -> (a, b), ((a1 -> b1 -> (a1, b1)) -> b2) -> b2)
15:50:42 <ihope_> @type ($ (,)) ($ (,)) ($ (,)) ($ (,))
15:50:43 <Baughn> @type ($)
15:50:47 <_SamB_bot>   Couldn't match `t -> t1' against `(a -> b1 -> (a, b1), b)'
15:50:47 <_SamB_bot>    Expected type: ((a -> b1 -> (a, b1)) -> b -> (a -> b1 -> (a, b1), b))
15:50:50 <ihope_> Whee.
15:50:51 <_SamB_bot> forall b a. (a -> b) -> a -> b
15:51:34 <lispy> ?free ($)
15:51:35 <_SamB_bot> Pattern match failure in do expression at ./Plugin/Free/FreeTheorem.hs:57:20-34
15:51:41 <lispy> ?free (,)
15:51:41 <_SamB_bot> Pattern match failure in do expression at ./Plugin/Free/FreeTheorem.hs:57:20-34
15:51:47 <dolio> ?free id
15:51:52 <_SamB_bot> f . id = id . f
15:52:00 <ihope_> free?
15:52:07 <SamB> hmm? free now can get types from somewhere?
15:52:08 <lispy> yeah, as in free theorems
15:52:11 <dolio> ?pl f `id` x
15:52:12 <_SamB_bot> f x
15:52:19 <SamB> where does it get them?
15:52:24 <ihope_> @free id
15:52:28 <lispy> ?pl x `seq` f x
15:52:29 <_SamB_bot> f . id = id . f
15:52:29 <_SamB_bot> x `seq` f x
15:52:30 <SamB> @free ()
15:52:31 <_SamB_bot> Pattern match failure in do expression at ./Plugin/Free/FreeTheorem.hs:57:20-34
15:52:33 <SamB> aww
15:52:35 <ihope_> @free seq
15:52:40 <SamB> hah!
15:52:40 <_SamB_bot> f . seq x = seq (g x) . f
15:52:52 <ihope_> ...What?
15:53:05 <ihope_> @free const
15:53:06 <SamB> seq is wierd!
15:53:11 <lispy> iirc, seq and bottom are sort of broken with ?free
15:53:14 <_SamB_bot> f . const x = const (f x) . g
15:53:19 <SamB> @free error
15:53:24 <_SamB_bot> ( g z = z  =>   $map g x = y ) => f (error x) = error y
15:53:29 <ihope_> @pl f . const x
15:53:29 <_SamB_bot> f . const x
15:53:34 <ihope_> @pl const (f x) . g
15:53:35 <_SamB_bot> const (f x)
15:53:41 <ihope_> Hmm.
15:53:46 <SamB> that free theorem looks excessively verbose...
15:53:53 <SamB> the one for error...
15:53:56 <lispy> ($!) f x = x `seq` f x, right?  i guess @pl doesn't know that one
15:54:36 <lispy> > (+1) $! 1
15:54:40 <_SamB_bot>  2
15:54:48 <SamB> @free Foreign.unsafePerformIO
15:54:49 <_SamB_bot> Pattern match failure in do expression at ./Plugin/Free/FreeTheorem.hs:57:20-34
15:54:50 <ihope_> > const 3 $! undefined
15:54:51 <SamB> aww
15:54:54 <_SamB_bot>  Undefined
15:54:59 <SamB> @free unsafePerformIO
15:55:02 <ihope_> @free ap
15:55:04 <_SamB_bot> Extra stuff at end of line in retrieved type "Not in scope: `unsafePerformIO'\n\n"
15:55:06 <dibblego> I am also reading that there is an implementation of exceptions - from what I understand the Maybe monad solves the issues that exceptions solve - but much better
15:55:08 <_SamB_bot> Expected variable or '.'
15:55:21 <ihope_> @free fix
15:55:25 <dibblego> certainly in imperative programming I don't use exceptions (much to everyone's disgust/lack of understanding)
15:55:26 <_SamB_bot> f . g = h . f => f (fix g) = fix h
15:55:27 <lispy> dibblego: well, Maybe and Either, but there are also exceptions
15:55:29 <SamB> dibblego: not a whole lot better
15:55:44 <SamB> dibblego: well, depends what problem you are solving really
15:55:56 <lispy> @type lookup
15:55:57 <SamB> there are a ton of different ways to go, depending on what you want
15:56:00 <_SamB_bot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
15:56:15 <dibblego> I "reinvented" the Maybe monad in Java before I knew what Maybe was - there is a specific reason I did this
15:56:15 <lispy> in that case, lookup could throw an exception when a is not found
15:56:16 <SamB> @free M.fromList
15:56:17 <_SamB_bot> Pattern match failure in do expression at ./Plugin/Free/FreeTheorem.hs:57:20-34
15:56:22 <Baughn> dibblego: Maybe certainly does the if(foo!=null) pattern nicely, but there's a lot more to exceptions than that
15:56:29 * SamB thinks free needs to support qualified names
15:56:33 <SamB> and error messages
15:56:37 <dibblego> Baughn, like what? the 'finally' part?
15:56:38 * lispy wishes Java used Maybe
15:56:43 <SamB> instead of these pattern match errors
15:56:54 <dibblego> lispy, it is emulable, but very verbose
15:57:04 <lispy> so many things in java return null to mean a null value or not found
15:57:13 <dibblego> lispy, I refuse to use null, ever
15:57:21 <Baughn> dibblego: No, the "raise error, look through error-handlers until you find one that fits, have the error-handler select one of the restarts that the error-raising code had established"
15:57:25 <dibblego> lispy, the other alternative is continuation-passing style
15:57:30 <SamB> Baughn: we have exception handling monads...
15:57:34 <Baughn> dibblego: Though I'll admit that's only in CL, not standard languages
15:57:37 <SamB> I don't know how to use 'em though
15:57:42 <Cale> Well, Maybe doesn't exactly model exceptions, it models failue. 'Either' does a better job.
15:57:51 <Cale> failure*
15:57:59 <Baughn> SamB: I figured you would, really. ;)
15:58:08 <dibblego> ok thanks
15:58:24 <SamB> I haven't had any great desire to implement a language that had them yet ;-)
15:58:36 <SamB> or at least haven't gotten that far
15:58:42 <Baughn> SamB: Still, having the option is nice
15:58:54 <SamB> nor do I write programs like that...
15:59:03 <SamB> IO has exceptions too, but those are kinda nasty
15:59:10 <Cale> For any type of errors e, (Either e) is a monad in which computations may fail, throwing values of e. These exceptions can also be reliably caught, because they're just values of the form Left (x :: e)
15:59:11 <SamB> because you need to be in IO to catch 'em...
15:59:54 <lispy> well, not all exceptions are that simple...when i use HDBC i have to use the IO monad to catch ngis
15:59:56 <dibblego> I see a problem with the use of exceptions - I can't think of what is Haskell (which I am largely ignorant of at the moment) would validate them
16:00:00 <lispy> things*
16:00:35 <dibblego> I'll plod on anyway - cheers
16:00:46 <Cale> Using exceptions as a mechanism for control flow and not to handle errors seems dubious to me :)
16:01:06 <SamB> dibblego: either they are in a monad, so the monad has to deal with them, or they are the catch-all global IO exceptions...
16:01:12 <dibblego> using exceptions for anything but to demonstrate what not to do seems dubious to me - but I'm prepared to be proven wrong
16:01:17 <ihope_> Oh, yeah. What happened to that thing where flow control consisted entirely of exceptions?
16:01:29 <Cale> dibblego: Well, it's good to handle error conditions somehow.
16:01:33 <SamB> ihope_: what thing?
16:01:46 <dibblego> Cale, I'll clue up on Haskell before I respond to that :)
16:01:47 <SamB> well, the IO exceptions are reasonable for actual IO situations...
16:01:49 <ihope_> Some language idea.
16:01:54 <Baughn> dibblego: Have a look at http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html
16:01:55 <Cale> dibblego: However, we tend to do that by matching on every constructor that a function could return.
16:01:55 <_SamB_bot> Title: ``Condition Handling in the Lisp Language Family'' c by Kent Pitman (2001), http://tinyurl.com/e5ev3
16:02:28 <dibblego> Baughn, thanks
16:02:28 <Baughn> _SamB_bot: ...you're being overly helpful
16:02:51 <SamB> hmm
16:03:03 <Cale> Apart from those IO exceptions, the implementations of exceptions in terms of monads like (Either e) or Maybe, are essentially just that, handling the failure cases in a consistent way.
16:03:07 <SamB> is it a good thing or a bad thing that my client highlights things people say to my bot?
16:03:12 <Baughn> Well. At least, the tinyurl seems pointless as a response to an url
16:03:31 <Cale> SamB: uh, that's up to you?
16:03:32 <SamB> Baughn: that must have been in the <title> tag
16:03:36 <Baughn> SamB: Good, good. It lets me direct my opinions at the true mastermind. ;)
16:03:42 <SamB> Cale: yeah, I know ;-)
16:04:01 <Cale> SamB: no, lambdabot constructs tinyurls for all urls over a given length now.
16:04:08 <SamB> oh really?
16:04:10 <Cale> yeah
16:04:11 * SamB had no idea
16:04:34 <SamB> I don't think we'd seen such a long URL before...
16:04:35 <sehute> I like the title+tinyurl functionality
16:04:56 <Cale> Title is good, I'm not sure what I'd do with the tinyURLs
16:05:02 <SamB> @. read run "http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html"
16:05:08 <_SamB_bot>  http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html
16:05:09 <SamB> Cale: good for typing in
16:05:14 <SamB> hmm.
16:05:22 <ihope_> @help read
16:05:23 <_SamB_bot> read "<foo>". Print <foo>
16:05:30 <ihope_> @read "foobar"
16:05:30 <_SamB_bot>  foobar
16:05:31 <ihope_> How useful.
16:05:36 <ihope_> @read "foo\"bar"
16:05:37 <_SamB_bot>  foo"bar
16:05:42 <SamB> so lambdabot doesn't try to deal with the URLs in its own output?
16:05:47 <Cale> right
16:05:48 <ihope_> @read "\1ACTION foobar\1"
16:05:48 <_SamB_bot>  ACTION foobar
16:05:49 <SamB> oh yeah, I guess I knew that...
16:05:59 <ihope_> ...
16:06:01 <SamB> ihope_: what were you expecting to happen?
16:06:06 <Cale> In general, lambdabot doesn't listen to any of its own output
16:06:09 <SamB> why did you type in those \1s?
16:06:20 <ihope_> SamB: I was expecting the bot to do a /me foobar.
16:06:23 <Cale> If it did, what if a page title had a url in it? :)
16:06:36 <SamB> Cale: well there is that
16:06:39 <SamB> some do
16:06:58 <SamB> I guess lambdabot can't tell WTH is going on anyway
16:07:10 <sehute> everytime someone said "is" in a sentance, lamdabot could collect the definitions and make a overview of what's what at #haskell. I've done something similar in python+an irc bot, and it works very well
16:07:12 <dfranke> ihope_: it seems to be prefixing its output with a space.
16:07:13 <SamB> but this means someone hacked up my @google to add title showing!
16:07:23 <ihope_> Oh yeah.
16:07:27 <SamB> sehute: huh
16:07:37 <lispy> sehute: i've seen that too, it's nice
16:07:42 <lispy> sehute: wouldn't be hard to do either
16:07:44 <SamB> what about the vague answers?
16:07:44 <ihope_> But still, it could send gibberish...
16:07:54 <sehute> lispy: no, it's really easy, that's the best part :)
16:08:00 <ihope_> @read "\85"
16:08:01 <_SamB_bot>  U
16:08:08 <ihope_> @read "\33"
16:08:09 <_SamB_bot>  !
16:08:13 <ihope_> @read "\30"
16:08:13 <_SamB_bot>  
16:08:18 <ihope_> Woot.
16:08:33 <lispy> sehute: you just need to make a plugin that uses context and scans for the word is
16:08:34 <SamB> @read "\x1e"
16:08:35 <_SamB_bot>  
16:08:35 <sehute> SamB: like, if you said "Apples are green", and ihope_ said "Apples are red", lambdabot could collect it, and present it as something like this: "Apples are: red, green"
16:08:56 <sehute> SamB: or a bulleted list on a html-page
16:08:59 <dfranke> why not make it a prolog system?
16:09:07 <SamB> newtypes are kinda like types, except with constructors and they actually define types...
16:09:10 <deadbeef> http://www.youtube.com/watch?v=uzhj-1qUeV0
16:09:12 <_SamB_bot> Title: YouTube - Anal sex
16:09:42 <ihope_> Guessing by the title there, that gets deadbeef an instaban.
16:09:44 <sehute> lispy: does lambdabot support plugins?
16:10:01 <lispy> sehute: oh yeah!
16:10:04 <dolio> :) lambdabot is plugins.
16:10:09 <lispy> sehute: everything lambdabot is a plugin
16:10:11 <SamB> pretty much, yeah!
16:10:19 <sehute> I've never looked at the source, or read much about it :)
16:10:24 <SamB> there is a toplevel around here somewhere!
16:10:46 <sehute> If I wrote a plugin for lambdabot, can the code be "plugged in" while it's running?
16:10:57 <lispy> sehute: well, dons created this thing called hs-plugins, using that he created lambdabot and yi to both be plugin based applications
16:11:00 <ihope_> sehute: I think so.
16:11:32 <sehute> lispy: that's cool. What's yi?
16:11:37 <sehute> ihope_: great
16:11:40 <lispy> like vi, but written in haskell
16:11:46 <lispy> @where yi
16:11:46 <_SamB_bot> http://www.cse.unsw.edu.au/~dons/yi.html
16:12:03 <sehute> @version
16:12:03 <_SamB_bot> lambdabot 4p122, GHC 6.4.1 (Linux i686 (Deschutes))
16:12:03 <_SamB_bot> darcs get /home/naesten/hacking/haskell/lambdabot/base
16:12:52 <dfranke> I don't quite comprehend the purpose of rewriting programs in new languages other than to add support for plugins written in that language.
16:13:20 <dfranke> If I'm just a user of vi I don't really care what it's written in.
16:14:30 <lispy> what if you're a researcher and you can get a paper out of it?
16:14:40 <rue> I can see the point if it takes fraction of the code vi does
16:14:45 <lispy> dons mentions yi in at least one paper and i think he said he has two about lambdabot
16:15:12 <sehute> dfranke: you do when you wish to use vi as the editor of an e-mail program. Vi is known to be a tangle of c-code that is like a house of cards
16:15:38 <lispy> rue: it also faster than vi in a lot of cases...i remember some graphs in the paper that showed it was way faster some times
16:15:45 <dfranke> sehute: why not just invoke it as a subprocess?
16:15:59 <sehute> dfranke: they've tried it, but it's a buggy and in-elegant approach
16:16:09 <dfranke> works great in mutt.
16:16:10 <sehute> dfranke: see also: the motivation behind yzis (vim in kde)
16:16:26 <Korollary> I think dons did it for the fun of it.
16:17:57 <Korollary> g'day
16:18:08 <dfranke> wth... http://haskell.org/gtk2hs/gallery/HRay/HRayScreenShot6
16:18:09 <_SamB_bot> Title: 34 Gtk2Hs Screenshot Gallery :: HRay :: HRayScreenShot6 b, http://tinyurl.com/f7bz8
16:18:16 <dfranke> look at the stats and the render time.
16:18:17 <Korollary> sad day for aussies and animal lovers all over
16:21:40 <sehute> Invalid repository:  /home/naesten/hacking/haskell/lambdabot/base
16:22:10 <sehute> the command in @version doesn't work; bug in the documentation of lambdabot
16:22:12 <Pseudonym> G'day.
16:22:13 <Pseudonym> Finally.
16:22:59 <sehute> trying: darcs get http://www.cse.unsw.edu.au/~dons/lambdabot/
16:23:00 <_SamB_bot> Title: Index of /~dons/lambdabot
16:23:11 <SamB> sehute: eh, sorry about that...
16:23:26 <sehute> SamB: seems to work now :)
16:24:39 <SamB> @version
16:24:39 <_SamB_bot> lambdabot 4p122, GHC 6.4.1 (Linux i686 (Deschutes))
16:24:39 <_SamB_bot> darcs get /home/naesten/hacking/haskell/lambdabot/base
16:24:48 <SamB> hmm...
16:28:21 <Cale> Dave Letterman should have a guy on his show who predicts how things will smell. He'll be called Nostrildamus.
16:28:33 <Korollary> I will sue
16:28:48 * Korollary checks into rehab
16:32:27 <Adamant> @quote Cale
16:32:27 <_SamB_bot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
16:32:50 <SamB> @quote
16:32:50 <_SamB_bot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
16:35:17 <dons> ?uptime
16:35:17 <_SamB_bot> uptime: 2h 35m 9s, longest uptime: 2h 35m 9s
16:35:27 <dons> oh?
16:35:27 <_SamB_bot> dons: You have 1 new message. '/msg _SamB_bot @messages' to read it.
16:36:43 <dons> _SamB_bot, @quit thanks!
16:36:54 <dons> ?uptime
16:37:22 <lambdabot> uptime: 47s, longest uptime: 1d 21h 35m 42s
16:38:52 <sehute> "./Setup.hs configure --bindir=`pwd`" gives "cannot satisfy dependency fps>=0.7". Anyone knows what fps is?
16:39:02 <SamB> @where fps
16:39:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:39:15 <SamB> ah, what a nice shade of blue ;-)
16:39:23 <sehute> thanks
16:40:01 <SamB> dons: so how was I supposed to use Seen's info from Karma?
16:40:43 <dons> two ways. you can statically import it, or you can write a Lambdabot.hs wrapper that lets you dynamically call functions in other plugins
16:40:50 <SamB> also, the #perl6 people don't like having karma changes produce output...
16:40:51 <dons> neither is great, I admit
16:40:57 <SamB> dons: but it doesn't export anything!
16:41:07 <dons> SamB: well patch that then.
16:41:13 <dons> SamB: right.
16:41:16 <SamB> and what help would it be if it did?
16:41:37 <dons> you could call from one plugin to another, as we do for @.
16:41:51 <dons> then plugins only dynamically depend on each other
16:42:04 <SamB> @. is rather textual...
16:42:05 <lambdabot> compose module failed: IRCRaised Parse error: "is"
16:42:23 <SamB> hey, you typed it with an @!
16:42:38 <SamB> aren't you one of those ? people?
16:42:58 * lispy worries that SamB is arguing with himself
16:43:18 <SamB> no, I meant dons did!
16:43:33 * lispy nods nervously
16:43:45 <lispy> wha-whatever you sa-say man
16:48:18 <SamB> ick!
16:48:25 <SamB> ------------------------------------------------------------------------
16:48:25 <SamB> -- | Lookup the `process' method we're after, and apply it to the dummy args
16:48:25 <SamB> -- Fall back to process_ if there's no process.
16:48:25 <SamB> --
16:48:25 <SamB> lookupP :: Message a => (a, String) -> String -> LB (String -> LB [String])
16:48:40 <SamB> shouldn't this logic be ... elsewhere?
16:48:47 <SamB> the fallback logic, I mean?
16:49:07 <dons> possibly
16:49:18 <dons> i'll decide when you show me the code :)
16:49:22 <SamB> I presume the same logic appears in at least one other place!
16:49:31 <dons> it does
16:49:35 <SamB> oh, that was in the Compose module
16:49:48 <dons> yep. bottom of Base.hs
16:51:19 <SamB> doRPL_MOTDSTART :: Callback
16:51:19 <SamB> doRPL_MOTDSTART _msg = return ()
16:51:19 <SamB> doRPL_ENDOFMOTD :: Callback
16:51:19 <SamB> doRPL_ENDOFMOTD _msg = return ()
16:51:19 <SamB> -}
16:51:28 <SamB> maybe another Base.hs?
16:55:20 <dons> scroll up a bit
16:55:24 <sehute> darcs seems very nice, clear, dependable and robust, but slow
16:55:42 <dons> should be ok if you're using the latest branch?
16:55:50 <dons> 1.0.8 (release) /
16:55:58 <SamB> sehute: yup!
16:56:03 <dons> is fine for me with some >1k patch repos
16:56:14 <SamB> dons: you have crazy fast CPU and memory!
16:56:20 <dons> oh maybe
16:56:40 <dons> pentium M laptop isn't so fast...
16:56:54 <sehute> the speed is tolerable here too, but waiting for 1000+ patches (download+apply) sure took some time :)
16:57:09 <dons> ah, downloading takes a while :) but that's not darcs fault
16:57:16 <SamB> dons: it isn't?
16:57:22 <dons> applying is different. not sure what the issues are there
16:57:30 <SamB> dons: it wasn't when I was on dialup, sure...
16:57:31 <sehute> subversion is quicker
16:57:33 <dons> SamB: its up to libcurl to do pipelining and things.
16:57:49 <dons> maybe the patches should have been bzip2'd
16:57:53 <SamB> dons: it is up to darcs to have a workflow amenable to that
16:57:56 <dons> lispy: has anyone looked at that?
16:58:08 <sehute> but I
16:58:13 <sehute> I've got a better feeling for darcs
16:58:14 <dons> SamB: --partial?
16:58:22 <SamB> dons: well, that isn't the point
16:58:34 <dons> isn't that the darcs soln to the slow get issue?
16:58:56 <SamB> darcs is supposed to download patches and *then* get stuck munching them...
17:00:08 <dons> ?karma+ SamB -- karma patch
17:00:08 <lambdabot> SamB's karma raised to 12.
17:00:41 <SamB> dons: did I mention that somehow that needs to not make noise in #perl6?
17:00:49 * sehute is compiling lambdabot right now
17:01:57 <lispy> dons: looked at what? bzip2?
17:02:23 <lispy> iirc, someone on the mail list said, "Hey, darcs should use bzip2" and that was sort of the end of the dicussion...like much on the darcs list
17:02:53 <sehute> dons: Judging from your homepage and what you've created, you deserve todays Clever Guy (TM) award. Congratulations.
17:03:05 <sehute> dons: seriously, well done :)
17:03:10 <SamB> iirc, one of the worst parts of darcs on dialup is downloading the inventory left and right...
17:03:19 <lispy> like when someone said, "No one is to use haddock markup in the source until there is a consensus."  So I said, "who's in favor and who is not?"...no one said anything...
17:04:13 <SamB> you should have said, "we should use haddock"
17:04:24 <lispy> i tried that a couple times before
17:04:37 <SamB> or maybe "we shouldn't use haddock"
17:04:54 <dons> sehute: cheers :)
17:05:03 <lispy> but i'm in favor of haddock...i even created a patch that added a target to the make file for generating haddock output
17:05:12 <sehute> :)
17:05:37 <lispy> which reminds me i wonder if darcs can use cabal now...
17:06:05 <SamB> reverse psychology!
17:06:16 <SamB> antagonize the others who like haddock!
17:06:26 <lispy> heh
17:06:26 <SamB> (and get them to say something!)
17:06:48 <lispy> or just use the powers of darcs and maintain my own branch with haddock support :)
17:09:42 <SamB> lispy: and slyly use haddock in your comments?
17:10:04 <lispy> heh, Juliusz rejected some of kowey's patches because he did that :)
17:10:35 * lispy doesn't like the way Juliusz maintains the unstable branch
17:11:19 <lispy> imo, an unstable maintainer should be more accepting than rejecting
17:11:34 <lispy> it's the stable maintainer that should go, "Oh, wait a sec, you gotta clean that up first..."
17:12:11 <xs> hum. does anyone know what the "Contexts differ in length" error means? i've got two functions that ghc seems to think are mutually recursive... yet if i remove either definitions it works fine (this is using template haskell)
17:19:31 <jrmole> does http://www.haskell.org/pipermail/glasgow-haskell-users/2005-July/008786.html help?
17:19:33 <lambdabot> Title: Contexts differ in length, http://tinyurl.com/gbb2j
17:22:00 <SamB> lispy: I agree
17:22:19 <SamB> I really like how lambdabot is always on the bleeding edge ;-)
17:22:28 <SamB> I look forward to seeing it bleed in #perl6
17:22:34 * sehute is still compiling lambdabot on his long overdue 450mhz laptop
17:23:17 <SamB> sehute: is that slower than a 450 MHz PII desktop?
17:23:53 <SamB> lispy: how can haddock in comments hurt?
17:23:55 <jrmole> hmm, is there anything working right now with regards to running Haskell code on Windows Mobile?
17:23:57 <SamB> it doesn't do anything
17:24:00 <sehute> SamB: well, it's a PIII, but I really don't know
17:24:04 <SamB> unless you run hadock
17:24:09 <SamB> sehute: oh, that might be slower
17:24:11 <sehute> SamB: how many flops've you got? :)
17:24:27 <SamB> how many flops does a compiler need?
17:24:47 <xs> jrmole, it is interesting, but i do not have any mutual recursion. the code is here: http://rafb.net/paste/results/3r9vBP31.html
17:25:10 <Pseudonym> SamB: Good question, but you can store a 32 bit integer losslessly in a double precision float.
17:25:24 <Pseudonym> So in theory you can use a FPU for extra registers.
17:25:24 <SamB> hint: almost none...
17:25:31 <SamB> Pseudonym: heh
17:25:36 <Pseudonym> So I guess it depends how good the compiler is!
17:25:36 <sehute> SamB: 897 bogomips here, how many've you got?
17:25:46 <SamB> sehute: about the same
17:25:49 <sehute> SamB: (I really meant bogomips)
17:25:51 <jrmole> hmm, somehow TH is making it mutually recursive maybe?
17:25:53 <SamB> but I bet your cache is smaller
17:25:53 <jrmole> i don't know TH, sadly
17:26:09 <jrmole> Pseudonym, is that ever actually done?
17:26:15 <SamB> cache size      : 512 KB
17:26:16 <deadbeef> > let id = (-1) . (+1) in id 5
17:26:17 <xs> me neither really :( it is strange.
17:26:18 <lambdabot>  add an instance declaration for (Num (a -> c))
17:26:28 <deadbeef> > let id x = ((-1) . (+1)) x in id 5
17:26:29 <Pseudonym> jrmole: Yes.  I'm not sure if it's done on the x86 though.
17:26:29 <lambdabot>  add an instance declaration for (Num (a -> c))
17:26:30 <SamB> bogomips        : 884.73
17:26:30 <lambdabot>   In the definition of `ww...
17:26:43 <sehute> If they sold compiler-expansion-boards for computers (like 3D-cards, only for compilers), Gentoo might get a new reviwal ;)
17:26:45 <Pseudonym> I've seen it done on the SPARC.
17:26:45 <xs> > let id = (subtract 1) . (+1) x in id 5
17:26:47 <lambdabot>  Not in scope: `x'
17:26:48 <jrmole> Pseudonym, on what archs is it done?
17:26:56 <xs> > let id = (subtract 1) . (+1) in id 5
17:26:57 <lambdabot>  5
17:26:58 <xs> bleh
17:27:07 <jrmole> sehute, FPGA cards for the masses!
17:27:15 <Pseudonym> I've occasionally done it manually. :-)
17:27:21 <sehute> jrmole: exactly :)
17:27:30 <jrmole> do any SPARC compilers generate code like that?
17:27:31 <Pseudonym> If I need a discriminated union type that includes both integers and doubles.
17:27:48 <Pseudonym> That I don't know.  Was the code written by hand or compiled?
17:28:03 <jrmole> i guess it depends on how ALU<->FPU bandwidth on SPARC compares to ALU<->mem
17:28:27 <Pseudonym> Well, ALU <-> FPU compared with ALU <-> L1 cache.
17:28:38 <Pseudonym> But I think it was because of limitations of register windows.
17:28:46 <jrmole> ah
17:28:52 <jrmole> sehute, they already make FPGAs that plug into a CPU socket on a multi-Opteron board
17:29:11 <SamB> what do they do?
17:29:19 <jrmole> anything you program them to do :)
17:29:27 <SamB> what can you program them to do?
17:29:49 <jrmole> basically anything you can implement in hardware with the number of gates you're given
17:30:23 <SamB> but... how does it interface with other things?
17:30:28 <jrmole> field-programmable gate array
17:30:38 <jrmole> though the HyperTransport bus, like an Opteron does
17:30:57 <dibblego> there are many articles that state that FP ina commercial environment is implicitly successful for some enumerated set of reasons, but few (none?) that exhibit the opposite statement - where can I find some that make an attempt to present a initially neutral perspective?
17:34:13 <jrmole> SamB, it can talk to memory directly too
17:34:28 <SamB> well, FP encompasses imperative programming, doesn't it?
17:35:42 <dibblego> does it?
17:35:57 <SamB> well, okay, so maybe not so well
17:36:04 <jrmole> depends on how you define those terms
17:36:09 <dibblego> indeed
17:36:13 <SamB> but functional programmers often know when to write an imperative program, anyways
17:36:18 <jrmole> Haskell can implement most constructs from imperative languages
17:36:21 <jrmole> Unlambda, not so much
17:36:32 <SamB> and unlambda isn't even pure
17:36:42 <jrmole> yeah
17:36:44 <tessier> Purity Of Essence
17:36:53 <jrmole> for that matter, unlambda can't easily implement most constructs from functional languages ;)
17:37:01 <jrmole> such as lambda
17:37:03 <dibblego> suppose a small business that has been using the common languages for some time has learned of the disadvantages of its technologies through critical analysis - it now wants to move on and sees FP as attractive - there are some obvious risks involved to the business and they are very difficult to assess accurately
17:37:12 <tessier> imperative programming is a commie plot to sap our precious bodily fluids!
17:38:00 <dibblego> it is very risky to the business given no prior stories of commercial success
17:38:15 <dons> dibblego: ericsson's work on switching back and forward between erlang might be useful
17:38:35 <dons> or you could look at galois or aetion
17:38:36 <dibblego> dons, yes I saw mention of Ericsson/Erlang in the CUFP reports
17:38:43 <dibblego> haven't heard of aetion
17:39:03 <jrmole> linspire uses Haskell for package management
17:39:45 <dons> the most common pattern I see is that someone starts writing the peripheral tools in haskell, and they just work, and get done faster. slowly more and more new tools are written in .hs
17:39:47 <dibblego> I don't even own the business - but I have convinced my boss through formal reasoning that the approaches that we take are flawed in terms of correctness (not necessarily commercially flawed)
17:40:15 <jrmole> you can also point to major open-source successes of Haskell -- pugs, darcs, ghc itself
17:40:17 <dibblego> dons, "someone" meaning - a business
17:40:34 <SamB> I'd say if your boss listens to formal reasoning, he should like FP ;-)
17:40:38 <tessier> "major" open source successes? Hardly
17:40:45 <dibblego> jrmole, yes I have those, but I'd like to see unsuccessful stories as well and perhaps an assessment of why failure occurred
17:40:46 <jrmole> major as in, they're real projects
17:40:48 <jrmole> not toys
17:40:50 <dons> yes, I mean, in this channel I see people working in companies, who just start writing new tools in .hs, and as they work, it starts appearing in more core components
17:41:01 <dibblego> SamB, he certainly does - but we have a business to consider as well
17:41:04 <tessier> Microsoft Bob was a real project. It was hardly a success.
17:41:08 <jrmole> wasn't Miranda supposed to be popular in industry?
17:41:15 <SamB> tessier: what was that done in?
17:41:47 <jrmole> probably C
17:41:54 <dibblego> it could be as simple as "the alternative strategy that was taken  by the business was not marketed appropriately"
17:42:13 <dibblego> our competitors are using techniques that we once used - but now view as flawed
17:42:30 <dibblego> but there is the danger of being idealistic and selectively focused
17:42:34 <SamB> dibblego: anyway, probably most failures are either a failure to be fast enough or a failure to figure out how to start writing the program...
17:43:01 <jrmole> there's lots of ways a project can fail, but in most cases you'll never hear about it
17:43:02 <SamB> oh, and failure to run in a reasonable amount of RAM...
17:43:24 <SamB> yeah, unsuccessful projects tend to lurk on hard drives ;-)
17:43:30 <dibblego> there is also the danger that I personally would like to see an approach that is not so flawed as the typical approaches and observe commercial success as a result (not for the love of money, but for validation of my reasoning)
17:43:36 <jrmole> i mean, i can't think of a canonical bad Java project
17:43:39 <jrmole> and i know there must be loads of them
17:43:43 <dons> but there's no reason for that to be the case -- speed or ram -- short of lack of programming proficiency
17:44:00 <SamB> dons: :-P
17:44:07 <SamB> we aren't all you, you know, dons ;-)
17:44:10 <jrmole> dons, it takes a lot of programming proficiency to fix subtle time/space problems in functional code
17:44:11 <dibblego> dons, that in itself is a potential danger - perhaps not everyone possesses the ability to use FP effectively
17:44:47 <jrmole> i think in the end, businesses that get three really smart guys who know Haskell inside and out will do better than businesses that get twenty mediocre programmers who know the usual (Java and C#, probably)
17:44:49 * tessier once had a time/space problem and now I am my own great uncle!
17:44:51 <dons> we have standard tools now to fix this stuff. it was an issue for the early 90s. i.e. -prof -auto-all, and a host of fast data types, as well as an FFI
17:44:51 <jrmole> but i have no evidence for that
17:44:57 <SamB> you could use it for prototyping anyway
17:45:17 <dibblego> jrmole, have you seen that for yourself or is that your thought experiment?
17:45:21 <dibblego> jrmole, ok
17:45:27 <jrmole> dons, it still takes a lot of insight to look at a big chunk of code which uses 100M of RAM, say "put a `seq` here", and have it use 1M
17:45:34 <dibblego> jrmole, I think that as well, but there is always The Unknown
17:45:36 <jrmole> dibblego, it's my wishful thinking mostly
17:45:41 <dibblego> jrmole, mine as well :)
17:45:45 <dons> not insight. profiling
17:45:59 <jrmole> dons, maybe i don't know how to use the profiler effectively then
17:46:02 <SamB> okay, so it takes a lot of compiling!
17:46:09 <dons> but yes, it helps to understand the semantics of the language too :)
17:46:12 <SamB> ... to get profiling builds of everything
17:46:22 <jrmole> maybe that's a legitimate concern, too.  where can j. random coder learn how to use the ghc profiler effectively?
17:46:30 <dibblego> I am about to order 5 books: 0201342758 0521644089 0521663504 0954300696 0262660717 -- see if that helps
17:46:31 <jrmole> (not rhetorical, i'd like to read such a document actually)
17:46:34 <dons> read the profiling documentation?
17:46:40 <SamB> we should have a profiling game!
17:46:47 <dons> SamB: nice idea!
17:46:48 <SamB> but keeping it up to date would be a bitch...
17:46:49 <dons> a contest
17:47:00 <jrmole> dons, is there a case study or a tutorial anywhere?
17:47:01 <SamB> dons: I meant more like a single-player game
17:47:14 <dons> jrmole: a number of them. check haskell.org's Performance resource
17:47:15 <SamB> or you could play in teams, of course...
17:47:17 <dons> ?wiki Performance
17:47:18 <lambdabot> http://www.haskell.org/haskellwiki/Performance
17:47:27 <jrmole> dibblego, i also have the anecdotal evidence that i'm personally a much more effective programmer after learning Haskell
17:47:39 <dibblego> if you could see a chunk of code that uses 10M and make it use 1M have you bettered or equalled your competitors who are using typical approaches?
17:47:52 <jrmole> and that the best programmers I know (from a fairly small sample of undergrads at a good school) know and use Haskell regularly
17:47:57 <SamB> dibblego: probably!
17:48:05 <SamB> at least in terms of RAM
17:48:08 <dibblego> jrmole, agreed - even if you apply it to imperative programming - I certainly believe that you cannot lose by investing time in learning FP
17:48:09 <jrmole> dibblego, depends... in an imperative language it might have taken 1M to begin with
17:48:13 <SamB> anyway, what are you trying to beat them at?
17:48:22 <dibblego> SamB, in this case, performance
17:48:31 <SamB> oh, in that case, Haskell is a dangerous game
17:48:52 <dons> I really think this performance issue is overrated. hello, look at the shootout
17:48:53 <dibblego> the industry does not revolve around being "correct", but "being better than the other guy" -- the low expectations of industry ensure that any old monkey can be at least moderalty successful
17:49:10 <SamB> hmm
17:49:10 <dons> people bet the company on C++ or Java with sucky performance
17:49:15 <jrmole> my general philosophy is: FP wins, because a proof of correctness and some general testing of performance is better for most things than a proof of performance and some general testing of correctness
17:49:18 <SamB> we ought to try hiring out monkeys as consultants
17:49:30 <jrmole> the latter being how most things, even critical stuff like OSes, are done
17:49:41 <jrmole> but i acknowledge that this is a very academic position to take
17:49:42 <dibblego> SamB, I've met few consultants who do not graze on bananas consistently
17:50:00 <jrmole> and that in industry, sometimes being fast most of the time makes up for blowing up occasionally
17:50:02 <SamB> dibblego: not everything that eats bananas is a monkey
17:50:24 <SamB> I mean, if you left them within reach (or even where I'd need to climb on a shelf!) I'd probably eat them...
17:50:25 <dibblego> SamB, sure, but they certainly demonstrate the wish to be one
17:50:36 <vincenz> SamB: but you are a monkey
17:50:38 <vincenz> SamB: a code monkey
17:50:45 <SamB> hmm
17:50:47 <SamB> possibly
17:50:52 <SamB> but I'm a very exalted monkey!
17:50:56 <dibblego> SamB, agreed, bananas have gone 5x in price since a recent weather incident - they are considered a delicacy these days
17:50:59 <vincenz> :D
17:51:13 <vincenz> dibblego: curious how money can make something common a delicacy, don't you think?
17:51:14 <dibblego> a banana costs the same as a litre of fuel
17:51:17 <SamB> I mean, most monkeys are PHP monkeys, no?
17:51:21 <vincenz> dibblego: makes you wonder if caviar would bea delicacy if it were cheap
17:51:21 <dibblego> vincenz, indeed
17:51:40 <vincenz> tho salmon will always be a delicacy
17:51:40 <SamB> I bet bananas taste better than caviar
17:51:41 <vincenz> mmmm
17:51:44 <dibblego> vincenz, there is the example of the BMW that wouldn't sell until they doubled the price
17:51:45 <vincenz> smoked salmon
17:51:51 <vincenz> dibblego: :D
17:51:54 <jrmole> vincenz, this is why synthetic diamonds have a lot of rich people very scared
17:52:41 <dibblego> what monkeys they are
17:52:45 <dibblego> I am a monkey
17:52:53 <lispy> diamonds are significantly more common than jewelers pretend
17:53:12 <SamB> lispy: but can you get 'em that easy?
17:53:20 <lispy> nope
17:53:26 <SamB> I heard the cartels keep a tight grip on the supply
17:53:29 <jrmole> lispy, and they'd be very common without artificial scarcity being imposed by the diamond cartel
17:53:31 <lispy> someone has been very careful about that :)
17:53:36 <SamB> or whatever you call those shadowy organizations
17:53:47 <jrmole> yeah, which is why the cartels are basically resorting to kneecap tactics against the synthetic diamond people
17:54:06 <SamB> the synthetic people knew that would happen
17:54:13 <SamB> do they have an army yet?
17:54:20 <jrmole> yeah, doesn't make it a good thing
17:54:35 <jrmole> doubtful it's good enough to take on the diamond cartels
17:56:25 <Korollary> diamonds sell at that price because no one argues as they think they are rare.
17:56:39 <jrmole> Korollary, and because of marketing by the cartels
17:56:56 <Korollary> well, cartels certainly would like to see that line of reasoning continue.
17:58:03 <SamB> anyway, won't the cartels get in trouble if synthetic people start disappearing?
17:58:07 <jrmole> http://en.wikipedia.org/wiki/De_Beers#Marketing
17:58:36 <lispy> SamB: just like coke when they killed union workers?
17:59:00 <jrmole> SamB, i think intimidation works well enough
17:59:01 <SamB> lispy: coke union workers, or pepsi union workers?
17:59:48 <jrmole> the big marketing scam is that you're a horrible person if you don't spend n times your monthly salary on an engagement ring, where n keeps increasing
17:59:58 <SamB> heh
18:00:03 <SamB> that is stupid
18:00:06 <jrmole> and they want people to think this is an age-old tradition, when in fact it's a 20th-century invention iirc
18:00:10 <SamB> sounds like dating sim logic
18:01:25 <jrmole> well, the way many people approach dating in US culture is basically what you'd expect in a fucked-up dating sim
18:01:29 <sehute> good night, I'm off to get some sleep
18:01:30 <jrmole> so it shouldn't be too surprising
18:01:32 <jrmole> nite sehute
18:02:12 <SamB> I don't really think I like this whole "dating" concept
18:02:32 <jrmole> yeah, "A diamond is forever" is from 1948
18:02:43 <SamB> that means they steal it off you when you die
18:02:49 <SamB> and sell it again
18:03:04 <SamB> for 10 times as much
18:03:10 <jrmole> oh, re cartels:
18:03:11 <jrmole>     * A marketing campaign will be aimed at convincing potential customers that laboratory diamonds are "fake" (even though they are real diamonds, and potentially may be of higher quality than natural diamonds).
18:03:11 <jrmole>     * All natural diamonds will be imprinted with a serial number and registered, to prevent laboratory diamonds from being sold as natural diamonds.
18:03:39 <jrmole> i like the first one... "your diamond is only authentic if a bunch of underpaid africans busted their asses to dig it out of the ground"
18:04:33 <jrmole> though i guess that's just the same sort of superstition regarding material origins that plays well in many cultures
18:04:35 <SamB> may I point out that natural imperfections may be considered desirable?
18:04:49 <Cale> SamB: no.
18:04:51 <Cale> hehe
18:05:12 <SamB> also, wouldn't the serial number make the natural diamonds look funny?
18:05:20 <jrmole> it's really small or something
18:05:33 <SamB> who cares if it is really small?
18:05:33 <jrmole> using the magic of laser
18:05:40 <SamB> than again, who cares if it is a real diamond?
18:05:57 <Cale> I'm sure that natural imperfections could be simulated
18:05:58 <jrmole> well, the laboratory diamonds *are* real diamonds, too
18:06:40 <Cale> but generally, I don't think that they would help with appearances
18:07:00 <sm> hi all.. I'm building Yi and got gcc: dist/build/./yi-tmp/cbits/YiUtils.o: No such file or directory
18:07:12 <Cale> dons!
18:07:13 <Cale> hehe
18:07:54 <dons> that's a bug in Cabal
18:08:05 <dons> it puts the .o files in cbits/cbits/ or something
18:08:18 <dons> you should be able to find where they really are, and ln -s to them from the expected location
18:08:56 <sm> I'm not sure how to get the cbits/* compiled
18:09:09 <dons> gcc -c -O *.c
18:09:32 <syntaxfree> @hoogle (a->a->Bool)->[a]->Bool
18:09:33 <lambdabot> No matches, try a more general search
18:09:42 <dons> ten copy them into dist/build/./yi-tmp/cbits/ for example
18:09:51 <dons> @hoogle a->a->a
18:09:52 <lambdabot> Prelude.asTypeOf :: a -> a -> a
18:09:52 <lambdabot> Prelude.const :: a -> b -> a
18:09:52 <lambdabot> Prelude.seq :: a -> b -> b
18:10:14 <syntaxfree> There's this useful recursion pattern I can't find in Haskell.
18:10:41 <dons> could you hack it up as a one liner?
18:10:49 <sm> dons, thanks.. I see it did get compiled already but it's down in dist/build/yi-tmp/cbits/cbits/
18:11:01 <emu> bool? some kind of filter or comparison?
18:11:31 <syntaxfree> if p:: (a->a->Bool),  boolFold p [x] = True; boolFold p (x:y:xs) = (p x y) && (boolFold ys)
18:12:05 <jrmole> @pl let { boolFold p [x] = True; boolFold p (x:y:xs) = (p x y) && (boolFold ys) } in boolFold
18:12:05 <lambdabot> (line 1, column 5):
18:12:05 <lambdabot> unexpected "{"
18:12:05 <lambdabot> expecting natural, identifier or "in"
18:12:16 <jrmole> grr
18:12:21 <dons> is that 'all' ?
18:12:24 <emu> er why not use foldr
18:12:25 <syntaxfree> um, wrong. boolFold p (x:y:ys) = (p x y) && (boolFold ys)
18:12:30 <syntaxfree> anyway, you get the idea.
18:12:31 <dons> oh, not quite
18:12:45 <emu> oh
18:12:49 <emu> you want to skip by two
18:13:07 <emu> i thought you meant something like (x:xs@(y:ys)) but typoed
18:13:14 <dons> so its a bit like a sortBy comparison, or a filter
18:13:16 <syntaxfree> there's this list. Say, [1,2,4,8,16]
18:13:27 <syntaxfree> there's this predicate, double a b = (b == 2*a)
18:13:36 <SamB> there should be a function like
18:13:43 <sm> dons, very cool.. fyi I got Prelude.read: no parse with -l emacs
18:13:58 <dons> --as=emacs
18:13:59 <syntaxfree> it should tell me if 2 == double 1, 4 == double 2, 8 == double 3, etc.
18:14:04 <SamB> asPairs [1..] = zip [1,3..] [2,4..]
18:14:06 <dons> but you might want: --as=mg
18:14:25 <sjanssen> @type \f xs -> and $ zipWith (uncurry f) xs $ tail xs
18:14:27 <lambdabot> forall a b. (a -> b -> (a, b) -> Bool) -> [(a, b)] -> Bool
18:14:44 <SamB> oh, what?
18:14:49 <SamB> syntaxfree: you wrote it wrong
18:14:53 <sjanssen> @type \f xs -> and $ zipWith f xs $ tail xs
18:14:55 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> Bool
18:14:55 <jrmole> @type \p -> all $ uncurry p $ zip xs $ tail xs
18:14:56 <lambdabot> Not in scope: `xs'
18:14:57 <lambdabot>  
18:14:57 <lambdabot> <interactive>:1:38: Not in scope: `xs'
18:15:02 <syntaxfree> this is the original context.
18:15:14 <syntaxfree> (as it came up in my code)
18:15:15 <syntaxfree> areInLayer (NR (NP (lp, _), _)) (NR (NP (lp1, _), _)) = lp == lp1
18:15:23 <syntaxfree> isLayer [n] = True
18:15:23 <syntaxfree> isLayer (n:m:ns) = (areInLayer n m) && (isLayer ns)
18:15:34 <syntaxfree> d'oh,  that makes no sense without the data declarations. duh.
18:16:12 <sm> doh!
18:16:13 <lisppaste2> syntaxfree pasted "probably too contrived to be worth examining, but here it goes" at http://paste.lisp.org/display/25385
18:16:14 <sjanssen> syntaxfree: do you need to check m `areInLayer` head ns, also?
18:16:48 <jrmole> syntaxfree, for [a, b, c, d] do you check (a,b), (b,c), (c,d) or only (a,b), (c,d) ?
18:17:04 <dons> great way to get a question answered: "there's this recursion pattern that I can't find in Haskell" .. :)
18:17:06 <syntaxfree> I need to check (a,b), (b,c), (c, d)
18:17:19 <sjanssen> @pl \f xs -> and $ zipWith f xs $ tail xs -- use this
18:17:20 <lambdabot> (and .) . (`ap` tail) . zipWith
18:17:28 <dons> nice
18:17:38 <Cale> what's the question?
18:17:55 <dons> oh, that was syntaxfree's query for the above problem
18:18:09 <syntaxfree> well, in the beginning I used to be constantly rewriting stuff like zipWith, so I thought I'd check.
18:19:12 <syntaxfree> Is there such a thing as the concept of "transitive" predicates?
18:19:31 <syntaxfree> Say, if (p a b) == True and (p b c) == True then (p a c) == True.
18:19:43 <Cale> yes
18:19:47 <jrmole> syntaxfree, that's one of the axioms for a partial order
18:19:50 <Cale> that's exactly the term for them
18:20:25 <SamB> like, == is one ;-)
18:20:28 <jrmole> the other two being (p a a) == True and ((p a b) && (p b a)) implies (a == b)
18:20:53 <syntaxfree> oh, those are the rational preference axioms.
18:21:04 <SamB> hmm...
18:21:09 <jrmole> syntaxfree, because the rationals are partially ordered by simplicity
18:21:10 <syntaxfree> Gah, I bet economists have been duplicating proofs.
18:21:14 <Cale> rational preference?
18:21:14 <jrmole> if that's what you refer to
18:21:18 <syntaxfree> yes.
18:21:29 <jrmole> oh, or did i take the wrong definition of "rational"? ;)
18:21:37 <syntaxfree> rational as in economic rationality :)
18:21:38 <Cale> http://en.wikipedia.org/wiki/Partial_order
18:21:55 <jrmole> okay, all is clear
18:22:08 <SamB> syntaxfree: sounds like a partial order yeah!
18:22:19 <syntaxfree> http://en.wikipedia.org/wiki/Rational_choice_theory
18:22:55 <jrmole> syntaxfree, by "every item is ranked" do they mean that for all A,B either A <= B or B <= A?
18:23:03 <jrmole> because that would make it a total order
18:23:15 <syntaxfree> jrmole A = B is a possibility.
18:23:20 <syntaxfree> It's called "indifference".
18:23:30 <syntaxfree> you can prefer B to A, A to B or be indifferent.
18:23:41 <jrmole> meaning that A and B are distinct choices, but one is indifferent between them?
18:23:42 <Cale> but you can't say that A and B are incomparable?
18:23:49 <syntaxfree> you can't.
18:23:50 <jrmole> in math you'd reserve A = B for A and B representing the same choice
18:23:52 <Cale> okay
18:23:58 <jrmole> and say they're incomparable in the case of indifference
18:23:58 <syntaxfree> jrmole we use A ~ B.
18:24:11 <Cale> http://en.wikipedia.org/wiki/Total_order
18:24:16 <Cale> then it's a total order
18:24:21 <syntaxfree> or, say, u(A) = u(B), for some continuous function  representing the preference relation.
18:24:48 <jrmole> yeah, that makes it a total order
18:24:54 <Cale> If for all pairs a,b, you have  a <= b or b <= a, and <= is a partial order, then <= is a total order.
18:25:17 <Cale> Note that if a = b, then a <= b as well.
18:25:24 <syntaxfree> Interesting fact: According to Arrow's impossibility theorem, there is no preference aggregation mechanism that preserves rationality.
18:25:36 <syntaxfree> Save for a dictatorship.
18:25:43 <Cale> right, I've seen that one
18:25:47 <jrmole> syntaxfree, you didn't state all the axioms, but yes
18:25:49 <Pseudonym> That's controversial, actually.
18:25:56 <Pseudonym> One of the axioms is disputed.
18:26:14 <syntaxfree> Indifference to irrelevant alternatives?
18:26:17 <Pseudonym> Right.
18:26:27 <Pseudonym> Because if it's not indifferent to them, they're not irrelevant.
18:27:36 <Cale> It says that if A is preferred to B out of the choice set {A,B}, then introducing a third alternative X (thus expanding the choice set to {A,B,X} ) should not make B preferred to A.
18:27:38 <jrmole> there are more reasonable weaker versions
18:28:16 <syntaxfree> Ah, yes, that's one of the axioms of revealed preference.
18:28:35 <Cale> That's the independence of irrelevant alternatives axiom.
18:28:51 <syntaxfree> I keep on thinking that revealed preference theory could prove very useful in AI.
18:29:01 <syntaxfree> If a computer is to learn my tastes, I mean.
18:29:44 <SamB> that isn't true, though!
18:30:14 <SamB> I mean, maybe if X is compatbile with B, but better than either one, you might want B so you can run the same software!
18:30:39 <syntaxfree> SamB: my undergrad thesis was about the economics of compatibility.
18:30:51 <SamB> oh cool
18:31:13 <syntaxfree> I dealt with the case of Apple Computer.
18:31:43 <syntaxfree> I basically argued that Apple held a partial compatibility strategy, connecting somewhat with the Unix world but keeping its niche.
18:32:06 <SamB> that is fairly accurate
18:32:21 <jrmole> hmm, they have it even better now
18:32:27 <jrmole> macs can easily run windows but not the converse
18:32:30 <SamB> they can run our stuff but they still have a bunch of pretty stuff that we can't run here
18:32:36 <syntaxfree> well, I had mathematical models and quotations from their communication with investors.
18:32:46 <SamB> where by here I mean on free Unix...
18:33:09 <syntaxfree> Mingus:~ syntax$ uname -a
18:33:09 <syntaxfree> Darwin Mingus.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc
18:35:17 <syntaxfree> anyway, SamB; to deal with compatibility, you have to define your bundles properly.
18:35:41 <syntaxfree> you had {A, B}. Introducing X with some interaction means you now have {A, B, AX, BX}
18:35:44 <syntaxfree> It's perfectly feasible that B>=A and AX>=BX.
18:37:42 <SamB> I was figuring that A and B were, like, calculators or something
18:38:04 <syntaxfree> A and B are things from which you derive utility.
18:38:04 <SamB> and X was a better one...
18:38:23 <SamB> anyway, what are these AX and BX things?
18:38:23 <dons> ?where+ fc http://www/~chak/project/fc/
18:38:24 <lambdabot> Done.
18:38:32 <dons> ?where+ fc http://www.cse.unsw.edu.au/~chak/project/fc/
18:38:33 <lambdabot> Done.
18:38:35 <syntaxfree> Ok. A and B are calculators.
18:38:39 <syntaxfree> X is a better calculator.
18:38:47 <syntaxfree> X also interoperates better with A.
18:39:03 <syntaxfree> In the absence of X our choice set is {A, B}  and we have B>=A
18:39:12 <SamB> okay...
18:39:23 <syntaxfree> (in economics one uses the curvy greater-than symbol to distinguish it from an ordering on numbers)
18:39:44 <SamB> whatever
18:39:49 <syntaxfree> when you introduce X, you have three new possibilities from which you can derive utility.
18:39:54 <syntaxfree> Utility include s pleasure.
18:39:55 <SamB> lots of maths use the regular ones for partial orderings...
18:40:04 <dons> SamB: so  what needs to be done with perl6 karma++ ?
18:40:19 <dons> just cross check against the seen state?
18:40:34 <SamB> that, and the #perl6 folks were complaining about the noise
18:40:58 <syntaxfree> there's X stand-alone, X interoperating with B and X interoperating with A.
18:40:58 <syntaxfree> so your new choice set is {A, B, X, AX, BX}
18:40:58 <syntaxfree> and B>=A, AX>=BX and possibly x>=b
18:41:03 <SamB> nick++
18:41:04 <dons> were? are?
18:41:07 <dons> oh, you tried it out on them?
18:41:14 <SamB> dons: not exactly
18:41:20 <araujo> any idea = http://pastebin.com/783826 ?
18:41:23 <SamB> remember how I had _SamB_bot filling in for lambdabot?
18:41:35 <dons> yes. you tried that out on them?
18:41:49 <SamB> well, it happened to have that, and it happened to join #perl6
18:41:55 <dons> ah
18:42:14 <dons> we really don't want to be noisy
18:42:34 <dons> so what was the noise problem?
18:42:43 <dons> the printing of a 'Done' line or what was it?
18:42:45 <SamB> so when they complained I just told it to leave #perl6. I figured I didn't need to go that far out of my way to replace lambdabot...
18:42:58 <dons> :)
18:43:26 <SamB> they don't like it to say something everytime someone (or the svn bot) does, say, SamB++ or whatever...
18:43:52 <dons> ok
18:44:01 <dons> ?karma+ lambdabot -- so not this:
18:44:02 <lambdabot> lambdabot's karma raised to 20.
18:44:17 <SamB> they don't care about the @karma commands, no...
18:44:26 <dons> oh, just nic++ should be quiet/
18:44:38 <SamB> they don't even care if karma is tracked by lambdabot in there, I expect...
18:44:42 <dons> yes
18:44:49 <SamB> I mean it hasn't been thus far
18:44:52 <dfranke> oooowww.
18:45:06 <dfranke> I think I finally just grokked natural transformations.
18:45:36 <SamB> maybe we should just add a Set of channels to pay attention to for that?
18:45:43 <SamB> or not to pay attention to for that...
18:45:50 <dfranke> my brain now feel like a balloon that popped after I tried to overinflate it.
18:47:38 <SamB> but I suppose making it silent would work fine for that...
18:49:02 <syntaxfree> why is Perl6 interesting?
18:49:31 <SamB> who cares if it is interesting? we just don't want to bother the people in #perl6
18:49:46 <syntaxfree> I'm just asking, in a general sense.
18:50:03 <SamB> well, it is easy to get commit access to pugs...
18:50:09 <SamB> pugs is written in Haskell...
18:50:25 <SamB> and if you are a perl junkie you want to follow the future of the community ;-)
18:50:30 <dons> i'd like a general mechanims for disabling plugins on a perl channel basis
18:50:37 <SamB> heh
18:50:39 <dibblego> even I have commit access
18:50:40 <dfranke> I don't think it is, especially.  I'd characterize it as a cleanup of perl5 to help it catch up with Ruby, plus something along the lines of template haskell.
18:50:46 <dons> i.e. like ?url-on/-off, but per-channel and for all plugins
18:50:47 <SamB> me too
18:51:04 <SamB> I committed maybe three times
18:51:06 <SamB> maybe more
18:51:07 <SamB> I dunno
18:51:30 <dons> i've got a perl6 tshirt :)
18:51:37 <SamB> I committed once today to change a perl script for evalbot, to make the purpose of the mysterious changing number less mysterious
18:51:37 <dons> but no haskell ones. how can this be!?
18:51:49 <SamB> well. Perl6 makes better pictures out of source?
18:51:56 <SamB> or is more puzzling?
18:52:05 <dfranke> it really strikes me as a reinvention of Dylan.
18:52:08 <SamB> or has more unicode symbols!
18:52:11 <syntaxfree> dons: I have no programming tshirt.
18:52:19 <SamB> me either!
18:52:22 <dons> this is very sad syntaxfree
18:52:28 <SamB> the closest thing I've got is a PGSIT t-shirt
18:52:39 <syntaxfree> In fact, the only tshirts with letters in them I own are a Strokes tshirt and a Franz Ferdinand one.
18:52:44 <SamB> with something like an SQL query session on the back
18:53:09 <SamB> and an ascii art drexel dragon on the front
18:53:11 <syntaxfree> gifts from my indie rocker girlfriend.
18:53:11 <syntaxfree> dfranke: what strikes you at a reinvention of Dylan?
18:53:12 * syntaxfree though Dylan was just Lisp with syntax
18:53:18 <dfranke> syntaxfree: perl6
18:53:20 <SamB> syntaxfree: maybe it is!
18:53:32 <SamB> but perl6 might be quite similar!
18:53:35 <araujo> anybody knows about my problem?
18:54:05 <syntaxfree> According to wikipedia: "Dylan is essentially a cleaned-up and simplified version of CLOS, an object-oriented programming system built on Common Lisp. "
18:54:31 * araujo wishes there existed a good Dylan compiler
18:54:39 <SamB> so why do you assume that PERL6 doesn't use the same sort of object system?
18:55:15 <dylan> aaah, people talking about me.
18:55:25 <SamB> araujo: the first tuple doesn't match the others?
18:55:39 <syntaxfree> araujo: why not just use scheme or lua or something?
18:55:56 <dfranke> the UNIX languages and the lisps seem fated for convergent evolution.
18:56:06 <SamB> maybe not...
18:56:12 <dfranke> awk->perl5->python->ruby->perl6
18:56:22 <SamB> @type ([("left", 2), ("up", 3)], 1, 'a', [("right", 2)])
18:56:24 <lambdabot> forall b b1 b2. (Num b, Num b1, Num b2) => ([([Char], b)], b1, Char, [([Char], b2)])
18:56:31 <SamB> @type ([], 2, 'b', [("down", 3)])
18:56:33 <lambdabot> forall a b b1. (Num b, Num b1) => ([a], b, Char, [([Char], b1)])
18:56:36 <dfranke> mccarthy lisp -> maclisp -> common lisp -> dylan
18:56:43 <araujo> I have been so dissapointed at current OO languages , that i am getting to the conclusion Haskell could be a good OO language too.
18:56:53 <SamB> @type ([], 3, 'c', [])
18:56:55 <lambdabot> forall a b a1. (Num b) => ([a], b, Char, [a1])
18:57:31 <syntaxfree> OOP just doesn't fit inside my head.
18:57:49 <araujo> I think i got some space for it through a 'functional' style :-)
18:57:51 <syntaxfree> @google haskell's overlooked object system
18:57:59 <lambdabot> http://www.cwi.nl/~ralf/OOHaskell/
18:57:59 <lambdabot> Title: Haskell's overlooked object system
18:58:08 <emu> it seems like a non-issue in a referentially transparent language
18:58:17 <emu> type classes are neat but a different thing
18:58:43 <syntaxfree> @google object oriented programming versus abstract data types
18:58:47 <lambdabot> http://citeseer.ist.psu.edu/context/1738/0
19:00:39 <araujo> SamB, mm... i can't see it :-|
19:01:05 <SamB> araujo: me either!
19:01:14 <syntaxfree> "First, Perl will support multiple syntaxes that map onto a single semantic model. Second, that single semantic model will in turn map to multiple platforms."
19:01:16 <SamB> I thought I could at first but I think I miscounted
19:01:21 <syntaxfree> they're reinventing combinator libraries?
19:01:28 <SamB> syntaxfree: nope...
19:01:33 <SamB> just macros ;-)
19:01:43 <araujo> SamB, And that is apparently the type of a Graph
19:02:15 <syntaxfree> Sometimes I feel the leaders of some programming languages know  even less than I do.
19:02:36 <syntaxfree> Guido van Rossum is a complete idiot about functional programming. He seems to think it's a matter of syntax.
19:02:52 <dons> them's fightin' words
19:02:52 <SamB> I think TimToady would admit as much, though... that he doesn't know what he is doing ;-)
19:03:02 <dons> heh :)
19:03:17 <syntaxfree> He seems to think every programming issue, innovation or paradigm is a matter of syntax, by the way./
19:03:25 <SamB> yeah, GvR doesn't get FP at all
19:03:32 * lispy wonders if it's time to sit down and replace darcs's FPS with Data.ByteString
19:03:35 <vincenz> syntaxfree: point him ot scheme :)
19:03:41 <SamB> heh
19:03:55 <SamB> lispy: oh, you should start an "experimental" branch ;-)
19:04:21 <lispy> SamB: like this? http://projects.codersbase.com/repos/darcs-unofficial/
19:04:21 <syntaxfree> vincenz: he'll just say it's unnatural syntax or something.
19:04:24 <lambdabot> Title: Index of /repos/darcs-unofficial, http://tinyurl.com/hceyf
19:04:26 <dons> lispy, its a great idea. i'm inclined to help out.
19:04:41 <lispy> SamB: i'd also like to cabalize it
19:04:42 <vincenz> syntaxfree: tell him the language must be very simple cause it only has one syntax-type
19:04:47 <jcreigh> syntaxfree: Well, language adoption seems to be a case of "worse is better", so it's quite possible.
19:05:02 <lispy> and start using a heiarchy of instead of having 50 .hs files in one directory
19:05:18 <syntaxfree> you tell him :)
19:06:31 <syntaxfree> Richard Gabriel's worse-is-better is not a ocmprehensive theory of the evolutionary path of network externality-prone technologies.
19:06:53 <syntaxfree> it's just a special case of what economists call "switching costs".
19:07:09 <syntaxfree> http://en.wikipedia.org/wiki/Switching_costs
19:07:33 <SamB> its also a case of what we call "taking too long to write the damn system"
19:07:53 <lispy> just look at this list: http://projects.codersbase.com/repos/darcs-unofficial/api-doc/
19:08:03 <SamB> on the part of the folks who are trying to do "better"
19:08:07 <lispy> seems like it should be possible to factor that list of modules better
19:08:21 <lispy> DarcsArguments
19:08:21 <lispy> DarcsCommands
19:08:21 <lispy> DarcsFlags
19:08:21 <lispy> DarcsIO
19:08:21 <lispy> DarcsRepo
19:08:22 <lispy> DarcsURL
19:08:24 <lispy> DarcsUtils
19:08:27 <lispy> that could be Darcs.Foo instead
19:08:33 <dons> lispy, do you want to have a go at removing FastPackedString in favour of ByteString? I'll help
19:08:52 <lispy> dons: okay, installing darcs locally real quick then i'll get to it
19:08:57 <SamB> and now most of the lispers run UNIX ;-)
19:09:06 <dons> if you set up a repo, i'll send you patches
19:09:18 <lispy> dons: http://projects.codersbase.com/repos/darcs-unofficial/
19:09:20 <lambdabot> Title: Index of /repos/darcs-unofficial, http://tinyurl.com/hceyf
19:09:29 * dons gets
19:09:40 <glguy_> SamB: they run SCO?
19:10:07 <dons> I think we should be able to replace FastPcakedSTring with a compat module providing just the missing bits
19:10:12 <lispy> @where fps
19:10:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:10:23 <dons> or even just reexport ByteString from FastPackedString, under a new name
19:10:27 <dons> that'd get things working fastest
19:10:45 <dons> since we then just throw out everything in FastPackedString that is subsumed by ByteString
19:11:02 <dons> grab the darcs fps
19:11:07 <dons> it's the one in ghc base
19:11:09 <Igloo> Do your words/unwords match FPS's?
19:11:13 * lispy nods, still waiting for darcs to build
19:11:14 <dons> no, for example
19:11:18 <dons> no lines/unlines
19:11:21 <dons> nor
19:11:58 <dons> does this sound like a reasonable idea, Igloo?
19:12:31 <Igloo> IMO, yes
19:13:32 <syntaxfree> @karma- LarryWall
19:13:32 <lambdabot> LarryWall's karma lowered to -1.
19:13:40 <lispy> geez
19:13:44 <sjanssen> here's a totally reasonable function name from darcs fps: is_funky
19:13:50 <dons> heh
19:14:07 <sjanssen> not a single comment about it either
19:14:23 <Igloo> That's shocking
19:14:26 <lispy> sjanssen: are you looking at the haddock?
19:14:29 <Igloo> It should clearly be isFunky!
19:14:34 <sjanssen> lispy: the source
19:14:35 <lispy> sjanssen: the haddock has no coments....
19:14:37 <lispy> ah
19:14:45 <jcreigh> Igloo: lol...that's just what I was thinking...
19:14:47 <syntaxfree> "I admit to being prejudiced on this one -- I was unduly influenced at a tender age by the rationale for the design of Ada, which made a good case, I thought, for leaving multiline comments out of the language."
19:14:47 <syntaxfree> what is the rationale for leaving multiline comments out, btw?
19:14:48 <lispy> oh, yeah that's another thing...some consistency of variable naming would be nice
19:16:04 <SamB> glguy_: SCO doesn't own the name UNIX, silly!
19:16:13 <SamB> SCO just claims to own the code...
19:16:41 <dons> lispy: ok, i'll just pull out of FastPackedString all the stuff duplicated by bytestring
19:16:48 <dons> and reexport them instead
19:16:56 <lispy> dons: okay
19:16:57 <dons> that way the internal modules don't have to change at first
19:17:05 <lispy> dons: i still haven't been able to install darcs and fps yet :)
19:17:05 <vincenz> SamB: that's like microsoft, they also claim to own very little, only the 0s and the 1s
19:17:12 <jrmole> SamB, i don't think the ownership of actual UNIX code is in dispute
19:17:16 <jrmole> but rather whether Linux contains any of it
19:17:20 <SamB> jrmole: well, yeah
19:17:31 <lispy> dons: maybe i'll work on the cabal part if you can get that much working quick
19:17:35 <dons> would it be better to work on darcs-unstable?
19:17:45 <dons> why the -unofficial branch?
19:17:45 <lispy> dons: depends...
19:17:48 <vincenz> syntaxfree: where did you get that
19:17:54 <SamB> but, well, novell seemed to not think that SCO could do that...
19:17:54 <glguy_> I think that SCO is the only person that makes a product called "UNIX" today (OS X is just "built on UNIX" or something)
19:17:58 <lispy> dons: i have about 3 matches that haven't been accepted to unstable
19:18:04 <glguy_> oh well
19:18:04 <syntaxfree> http://dev.perl.org/perl6/doc/design/apo/A02.html
19:18:05 <glguy_> just asking
19:18:05 <lispy> dons: otherwise it's just plain unstable
19:18:08 <lambdabot> Title: Apocalypse 2: Bits and Pieces -, http://tinyurl.com/ec6sv
19:18:13 <dons> ok hmm
19:18:18 <jrmole> glguy_, does BSD call itself UNIX?
19:18:18 <SamB> glguy_: actually I believe novell gave the name to some standards body
19:18:20 <lispy> dons: one of my patches adds a target for 'make api-doc' to generate haddock
19:18:34 <lispy> dons: which means it should be orthogonal to what you're doing
19:18:47 <SamB> so that only obsolete OSes can be called UNIX
19:19:05 <SamB> or, at least, aging
19:19:17 <SamB> (too much work to get the certification again and again)
19:19:24 <SamB> and money...
19:19:28 <SamB> too much money too...
19:20:30 <syntaxfree> OS X is UNIX.
19:20:48 <syntaxfree> apple.com even has an UNIX CERTIFIED gif image.
19:21:02 <SamB> oh really?
19:21:09 <SamB> they put up the money for that?
19:21:57 <syntaxfree> Macs are used in the military, I think.
19:22:03 <syntaxfree> funny quotation:
19:22:05 <syntaxfree> "To me, one of the most agonizing aspects of language design is coming up with a useful system of operators. To other language designers, this may seem like a silly thing to agonize over. After all, you can view all operators as mere syntactic sugar -- operators are just funny looking function calls. Some languages make a feature of leveling all function calls into one syntax. As a result, the so-called functional languages tend to wear out your pare
19:22:36 <SamB> well, Haskell goes the other way ;-)
19:22:38 <vincenz> syntaxfree: should get a blog ;)
19:22:47 <lispy> syntaxfree: i'd say that was against lisp/scheme
19:22:50 <syntaxfree> the rest of the funny quotation:
19:22:52 <SamB> offering to let you use either syntax for any function call ;-)
19:22:56 <Cale> wear out your par...
19:22:57 <syntaxfree> "But while your computer really likes it when everything looks the same, most people don't think like computers. People prefer different things to look different. They also prefer to have shortcuts for common tasks. (Even the mathematicians don't go for complete orthogonality. Many of the shortcuts we typically use for operators were, in fact, invented by mathematicians in the first place.)"
19:23:06 <vincenz> syntaxfree: enough quotes tho
19:23:07 <lispy> syntaxfree: where you have (admittedly) annoying things like (+ 1 2 3)
19:23:17 <syntaxfree> (+ 1 2 3) is fine for me.
19:23:23 <Cale> syntaxfree: the first quote was cut off there
19:23:36 <lispy> it's okay until you start building more complex math expressions
19:23:41 <syntaxfree> In Scheme, I even made a point of doing (define f (lambda (x) (*2 x)))
19:23:55 <vincenz> yeah
19:23:56 <vincenz> or even better
19:24:04 <syntaxfree> Cale: "(...) As a result, the so-called functional languages tend to wear out your parenthesis keys, while OO languages tend to wear out your dot key."
19:24:06 <jrmole> where do these quotes come from?
19:24:17 <vincenz> (define f (lambda () (lambda (x) (* 2 x)) ()))
19:24:19 <syntaxfree> http://dev.perl.org/perl6/doc/design/apo/A03.html
19:24:22 <lambdabot> Title: Apocalypse 3: Operators -, http://tinyurl.com/rmn8b
19:24:54 <araujo> yay!
19:24:57 <araujo> lambda!
19:24:58 <dolio> Heh. So programming directly in ASTs is a characteristic of functional languages? :)
19:25:00 <araujo> @yarr!
19:25:01 <lambdabot> Shiver me timbers!
19:25:17 <Cale> I don't really think that operators should be given much special treatment at all, apart from the usual considerations of precedence and associativity.
19:25:33 <Cale> Haskell has it right :)
19:25:39 <araujo> SamB, just worked .. needed to add explicit type signatures and force the correct applicative order
19:25:53 <SamB> well, yeah, the LISP and JAVA people don't even seem to think operators should be given that much...
19:25:55 <syntaxfree> I like the fact that Scheme does away with precedence and associativity.
19:26:01 <SamB> araujo: ack
19:26:13 <vincenz> (1 . + . 2)
19:26:15 <jrmole> Cale, yeah, but that just moves operator design out of the domain of the language designer and into that of the programmers
19:26:18 <jrmole> it's still an issue though
19:26:25 <SamB> true
19:26:38 <lispy> @type (. + .)
19:26:39 <lambdabot> parse error on input `+'
19:26:41 <SamB> but library issues make for faster turnaround than language issues
19:26:47 <Cale> jrmole: Right, but then nobody can really complain when they don't like the operators ;)
19:26:47 <araujo> i was assuming (&) was right associative :-|
19:26:50 <jrmole> syntaxfree, funny how Scheme requires parens around everything, yet with prefix notation (assuming fixed arity everywhere) you never need parens at all
19:26:51 <lispy> @type . + .
19:26:53 <lambdabot> parse error on input `.'
19:27:00 <vincenz> lispy: that ain't haskell
19:27:05 <vincenz> it's mzscheme
19:27:09 <vincenz> plt scheme
19:27:09 <lispy> oh
19:27:13 <Cale> However, you will tend to have societal issues about it anyway
19:27:14 <vincenz> they allow infix through double dot notation
19:27:26 <syntaxfree> well, many scheme functions are variadic.
19:27:32 <jrmole> this is true
19:27:35 <Cale> Like I don't think that most Haskell users are going to switch . for composition to anything else anytime soon.
19:27:36 <lispy> in the lisp world i might mistake that for some sort of dotted list...
19:27:46 <SamB> Cale: yeah
19:27:48 <vincenz> lispy: the syntax is -ONE- dot
19:27:51 <vincenz> (a . b
19:27:54 <SamB> those unicode things are too hard to type!
19:27:55 <vincenz> (a . (b . c))
19:27:56 <jrmole> Cale, if you wanted to, you could though
19:28:00 <Cale> jrmole: right
19:28:10 <araujo> I don't have anything against parens (after all, i used Lisp pretty much before) , but instead what i miss is the type system in those languages.
19:28:11 <Cale> jrmole: and you can do it module-locally
19:28:27 <jrmole> araujo, agreed
19:28:32 <vincenz> araujo: I disagree
19:28:37 <SamB> Cale: no matter how much they want it for qualified names and records, I mean, which do you do more?
19:28:38 <vincenz> some things can simply not be done with a typesystem
19:28:46 <Cale> SamB: indeed
19:28:47 <SamB> composition or record access?
19:28:51 <jrmole> vincenz, but for those you can at least make the type system get out of your way
19:28:56 <araujo> I think that the type system is a very powerful mechanism. I practically can't live with itnow :-)
19:28:58 <jrmole> in a well-designed language
19:28:59 <Cale> SamB: I think we should use | for qualified names and records, personally.
19:29:10 <Cale> though there may be some issues with guards :)
19:29:12 <SamB> what to use for guards then?
19:29:16 <vincenz> jrmole: like defining a unification system that handles multiple data-types with holes
19:29:21 <lispy> Cale: i wouldn't mind !
19:29:27 <SamB> ! seems nice
19:29:28 <lispy> Cale: or the old school OO, #
19:29:28 <araujo> vincenz, none of the things i use to do i suppose.
19:29:30 <jrmole> languages like Lisp and Scheme are so syntactically bare, i make a lot of stupid mistakes
19:29:35 <Cale> Just enforce that guards have a space after them, and | for qualification doesn't.
19:29:35 <SamB> though then you need to find something new for arrays
19:29:36 <jrmole> and not having a typechecker to find those is fatal
19:29:51 <SamB> jrmole: yeah
19:29:54 <vincenz> araujo: I'm just saying I rediscovered the beauty of scheme
19:29:58 <syntaxfree> Scheme taught me that syntax isn't important.
19:30:00 <Cale> Like Data | List is invalid
19:30:03 <SamB> I can't *find* anything in CL, actually
19:30:07 <Cale> It must be  Data|List
19:30:09 <araujo> vincenz, And who is saying is ugly?
19:30:09 <SamB> nevermind have type errors in my code
19:30:13 <jrmole> scheme is beautiful, and a great way to learn CS
19:30:25 <jrmole> it's also a pain in the ass to do anything real with
19:30:39 <SamB> Cale: how is that an improvement over dots? well, I suppose because | isn't an identifier...
19:30:42 <vincenz> araujo: you said you missed the typesystem
19:30:48 * syntaxfree casually mentions monad comprehensions.
19:30:52 <araujo> vincenz, yes i do
19:31:02 <SamB> syntaxfree: messed up type errors!
19:31:08 <SamB> I mention those casually too
19:31:09 <vincenz> araujo: seen the reasoned schemer?
19:31:13 <araujo> Now how can you translate that into = scheme is ugly?
19:31:18 <syntaxfree> Monad comprehensions!
19:31:19 <jrmole> one consideration is just how easily code can be mentally parsed... i have a lousy memory so i need to be able to look at code and quickly reconstruct its structure in my mind
19:31:23 <araujo> No, i don't see it.
19:31:28 <vincenz> araujo: huh?
19:31:29 <jrmole> and i can't do that with just parens :)
19:31:37 <vincenz> araujo: I asked if you've seen it, not if you see it
19:31:42 <vincenz> araujo: it's a nice book :)
19:31:58 <vincenz> araujo: anyways, regarding the "Scheme is ugly" to me typically lacking implies ugly
19:32:08 * vincenz sees typeless and typeful systems as just different pareto points
19:32:13 <vincenz> while C, for instance
19:32:17 <araujo> vincenz, ah, the book, n, i have only read SICP and Scheme Programming
19:32:19 <vincenz> clearly does not reside on the pareto-curve
19:32:39 <jrmole> yeah, you get the inflexibility of static typing and the runtime errors of dynamic typing
19:32:45 * vincenz nods
19:32:49 <vincenz> if you do something, do it good
19:33:02 <syntaxfree> I don't understand the wild popularity of C.
19:33:10 <vincenz> history
19:33:12 <jrmole> syntaxfree, it's related to the wild popularity of UNIX
19:33:18 <jrmole> which i suspect is related to some sort of brain damage
19:33:19 <araujo> vincenz, That is a very wrong assumption.
19:33:20 <vincenz> jrmole: yeah and that dumb thing called linux
19:33:25 <vincenz> araujo: which part?
19:33:28 <syntaxfree> UNIX isn't even wildly popular.
19:33:32 <SamB> jrmole: I suspect that it is related to the fact that unix allows people to do things
19:33:41 <jrmole> i agree that weak, dynamically typed languages are good for some things... that said, the more i use Haskell, the fewer things i place in that category
19:33:42 <SamB> syntaxfree: compared to its contemporaries, yes!
19:33:45 <araujo> vincenz, the lacking part , you can easily mis-interpret other people words
19:33:46 * vincenz peers at araujo 
19:33:50 <araujo> Like you did with mine.
19:33:57 <vincenz> araujo: no
19:33:57 <SamB> consider that its early contemporaries are mostly forgotten
19:34:00 <araujo> vincenz, yes
19:34:04 <vincenz> araujo: I said, to me if something is lacking then typically it's ugly
19:34:07 <syntaxfree> is Data.Dynamic any good?
19:34:14 <jrmole> SamB, the fact that UNIX allows people to do things is very unfortunate
19:34:20 <SamB> jrmole: oh?
19:34:27 <araujo> vincenz, if you ony explained to me how my statement translate into "scheme is ugly" , i would accept your point, otherwise not.
19:34:29 <jrmole> because it doesn't allow people to do them well, or without shooting themselves in the foot
19:34:34 <jrmole> but it works just well enough to retard progress
19:34:40 <vincenz> araujo: why are you being so fascetious
19:34:44 <SamB> but, Windows is worse
19:34:49 <jrmole> SamB, so is herpes
19:34:53 <araujo> vincenz, because you are twisting my words!
19:34:59 <vincenz> araujo: grr, I didn't intendo
19:35:01 <vincenz> intend to
19:35:02 <jrmole> but it's irrelevant to my point
19:35:07 <araujo> vincenz, ok, no problem :-)
19:35:10 * vincenz turns his attention from araujo and turns elsewhere
19:35:10 <SamB> well, have you seen a better OS lately?
19:35:13 <jrmole> which isn't so much a point as a vague disgruntledness
19:35:22 <araujo> SamB, House :-)
19:35:29 <SamB> oh, I'm vaguely disgruntled with UNIX myself
19:35:32 <jrmole> SamB, no.  that's exactly why UNIX is bad for progress in OSes
19:35:37 <vincenz> SamB: squeak :)
19:35:40 <araujo> i agree
19:35:51 <SamB> vincenz: but squeak doesn't run Haskell!
19:35:57 <SamB> at least, not well!
19:36:02 <vincenz> SamB: you mean not yet :)
19:36:04 <araujo> which makes it useless :-P
19:36:12 <SamB> it only works by the magic of UNIX, iirc!
19:36:15 <jrmole> i use UNIX-like systems because they're better than the alternatives.  but i hope that doesn't continue to be the case for the next 30 years as it has been for the past 30
19:36:16 * araujo admits he has had some fun with squeak
19:36:28 <vincenz> araujo: anyways, what did you mean by "I miss the type system"
19:36:31 <vincenz> I thought you meant it as a flaw
19:36:50 <vincenz> we should get a UMIX backend for ghc
19:37:01 <SamB> well, I look forward to seeing ReactOS and UNIX compete ;-)
19:37:03 <jrmole> http://www.eng.uwaterloo.ca/~ejones/writing/systemsresearch.html
19:37:04 <araujo> And it is undoubtely one of the best IDEs to get kids into interesting concepts.
19:37:07 <lambdabot> Title: Systems Software Research is Irrelevant, http://tinyurl.com/gn8ft
19:37:15 <lispy> dons: hehe, my poor little g4 can barely compile fps-0.8 :)
19:37:46 <SamB> I don't think I like squeak as an IDE... you need so many windows if you have ADD...
19:38:08 <SamB> and it is hard to fit them all on the screen
19:38:16 <jrmole> SamB, if ReactOS is our only alternative to UNIX, then we are truly doomed ;)
19:38:18 <lispy> windows?
19:38:27 <araujo> vincenz, i like Haskell, because its type system allows me to think in terms of 'types' , practically for _anything_ i going to do.
19:38:28 <vincenz> If you claim that's not innovation, but copying, I reply that Java is to C++ as Windows is to the Macintosh: an industrial response to an interesting but technically flawed piece of systems software. -- Talk about troll-bait
19:38:31 <dibblego> "one advantage of FP is lazy evaluation" -- how do you gain an advantage specifically?
19:38:36 <lispy> in windows i can scarely get work done because i need so many windows
19:38:41 <SamB> jrmole: I'm assuming that ReactOS will overtake Windows first...
19:38:50 <lispy> dibblego: composability is one way
19:38:52 <vincenz> araujo: me too, though I do like different pareto points, as long as they're extremes, read prior comment regarding C not meeting any good spot
19:38:57 <vincenz> ... as well
19:39:00 <vincenz> I like them ... as well
19:39:03 <dibblego> lispy, I'm not sure what you mean exactly
19:39:39 <lispy> dibblego: for instance, fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- laziness lets me define this, and laziness lets me use it meaningfully, eg., fibs !! 50
19:39:48 <glguy_> hey, I walked away from the computer, did you guys mention if anyone is selling UNIX today?
19:39:52 <dibblego> vincenz, fwiw, I am largely supporting of that opening paragraph
19:39:57 <SamB> jrmole: what kind of OS would you prefer?
19:40:12 <SamB> anyway, an OS that doesn't let people do things may not continue to be very useful...
19:40:14 <dibblego> lispy, but how is that an advantage over possible alternatives?
19:40:21 <jrmole> for starters, the central metaphor of "everything in the world is a sequence of numbers between 0 and 255" is rather limiting
19:40:21 <dibblego> lispy, simply that no alternative exists?
19:40:31 <vincenz> dibblego: skimming right now, and actually skipped itnro, I'll get back to you :)
19:40:33 <dolio> HP and IBM were/still are.
19:40:34 <jrmole> how about an OS where files are strongly-typed trees (ala XML with Schema) rather than sequences of bytes?
19:40:39 <lispy> dibblego: how would you implement fibs with memoization in c?
19:40:44 <jrmole> that alone would take care of so many bugs
19:40:50 <SamB> that metaphor has pervaded computing ever since the 8-bit days, jrmole!
19:40:54 <dibblego> lispy, I guess I have to find out what memoization means
19:40:57 <SamB> it isn't just a UNIX thing!
19:41:00 <jrmole> SamB, so have a lot of terrible things
19:41:05 <araujo> vincenz, Though, seriously talking, if everything was static this could be a very boring world :-)
19:41:20 <lispy> dibblego: oh, well that's this, let's say you have an expensive function to compute
19:41:23 <SamB> you aren't seriously trying to blame the 8-bit days on UNIX?
19:41:29 <jrmole> not at all
19:41:32 <lispy> dibblego: but ti's a function so given the same input it always produces the same output
19:41:42 <jrmole> i'm just saying, we should maybe move past the 8-bit days ;)
19:41:43 <dibblego> lispy, right
19:41:47 <lispy> dibblego: so you dynamically build a lookup table as you compute the values
19:41:53 <SamB> anyway, how would you get at these trees?
19:42:00 <lispy> dibblego: so then when  you need the value again you just look it up... you trade space for run-time
19:42:05 <dibblego> lispy, ok, so the ultimate benefit is then performance
19:42:07 <jrmole> SamB, with system calls, like you get at files now
19:42:13 <lispy> dibblego: in this case
19:42:14 <jrmole> only your system calls return trees rather than byte buffers
19:42:15 <SamB> wouldn't it be rather hard to get a multiplicity of languages to work with this model?
19:42:17 <dibblego> "lazy evaluation has a positive impact on software performance"
19:42:24 <jrmole> SamB, not really
19:42:26 <dons> lispy: barely compile?
19:42:31 <dons> what happens?
19:42:37 * araujo would like to have a way to get associative order of an operator from ghci 
19:42:40 <dons> (fps does kick ghc around a bit)
19:42:42 <lispy> dons: heeh, yeah i thought i'd have to get out and push....it was just really slow :)
19:42:52 <jrmole> as long as each language has the equivalent of Read and Show instances for the appropriate types
19:43:14 <vincenz> araujo: the reason I got refascinated with scheme was the beauty of some of the code in kanren, granted not main-stream use, but it was pretty neat  (mini-kanren = system from "The Reasoned Schemer" by some people and Oleg Kiselyov).  And relooking at scheme, well you can do a lot of nifty things with macros :)
19:43:21 <dibblego> lispy, there seems to be some general consensus that FP has performance problems -- I cannot see a substantiated reason about why that is, or whether that if there is, it is solvable
19:43:29 <lispy> dibblego: laziness lets you define things that would appear to be inifinite and then manipulate some finite subset of them quite naturally
19:43:29 <SamB> especially considering that mosteverything only supports streams of text and/or bytes for file I/O, except specialized things...
19:43:38 <vincenz> dibblego: what opening paragraph?  The fact that it's a polemic?
19:43:48 <jrmole> SamB, that's the metaphor that i want to discard
19:43:50 <dibblego> lispy, ok so clarity of expression is another benefit
19:43:55 <dibblego> vincenz, the one that you quoted
19:43:58 <lispy> dibblego: right
19:43:59 <vincenz> oh
19:44:03 <SamB> jrmole: you will have to discard all of the existing users too
19:44:08 <jrmole> sure, hard drives still deal with bytes physically.  but the OS is the only program which can talk to the hard drive -- this was decided a long time ago
19:44:09 <SamB> the computer will not work
19:44:18 <jrmole> SamB, no, you can implement all of UNIX as a compatibility layer on top of this
19:44:24 <jrmole> where every file happens to have type [Char]
19:44:26 <SamB> o rly!
19:44:27 <madpickle> ya rly!
19:44:39 <jrmole> and you can gradually convert to tree-aware programs
19:44:49 <dibblego> doesn't type Char imply some encoding from bytes to char? wouldn't it then be [Byte]?
19:44:54 <vincenz> dibblego: he makes his essay hard to swallow however, by shooting down those people that might be interested in collaborating and working on a new systsem, shooting down mac, praising windows, shooting down c++, praising java (granted in 2000 it was the new hot thing), shooting down linux...
19:44:55 <araujo> vincenz, i wouldn't mind looking (or even using!) at scheme , my comment is that i usually end up getting back to my mon-adiction  :-P
19:44:57 <jrmole> dibblego, fair enough
19:45:05 <SamB> hmm, didn't they tell you that [Char] is an inefficient type?
19:45:17 <vincenz> araujo: it's nice for experimentation, but yeah, haskell does solve many headaches
19:45:17 <jrmole> what do you mean by that?
19:45:28 <SamB> Data.ByteString has a much faster one!
19:45:29 <dibblego> vincenz, agreed, but sometimes there is some truth in those kind of expressed perspectives
19:45:43 <vincenz> dibblego: yeah, but there's way of formulating that won't turn away your reader
19:45:46 <jrmole> SamB, i'm speaking abstractly
19:45:54 <jrmole> in Haskell you might read such a file into a Data.ByteString, whatever
19:45:59 <dibblego> vincenz, I know many people who prefer to create a reality than acknowledge the existing one right before them
19:46:01 <vincenz> +s
19:46:05 <dibblego> vincenz, I am one of them
19:46:12 <SamB> representing that as a tree can't be a good idea, though
19:46:15 <vincenz> dibblego: pink elephants?
19:46:19 <araujo> vincenz, what i do give to the dynamic system , is that they are usually better for scripting stuff. I used scheme/lisp for that kind of tasks mainly.
19:46:19 <vincenz> :P
19:46:20 <jrmole> SamB, ?
19:46:28 <SamB> jrmole: you said these were trees!
19:46:34 <dibblego> vincenz, no, sometimes I catch myself out - I often wonder how many times I let it go unnoticed
19:46:46 <SamB> oh, and how does this do backwards compatability?
19:47:00 <vincenz> araujo: sadly my scheme at the moment is too rusty even for that, one thing that scheme naad lisp do is move everything from syntax to ... library... meaning that the language requires more looking around for things
19:47:13 <vincenz> dibblego: "sometimes I catch myself out" /
19:47:14 <vincenz> ?
19:47:19 <jrmole> i didn't specify trees of what -- a UNIX-legacy file would be a single node containing a list of bytes.  more refined file formats would use more nodes, and put less in each node
19:47:28 <dibblego> vincenz, confusing a preferred reality for the actual I mean
19:47:32 <jrmole> such that the tree structure is meaningful, and thus can be used to enforce safely-typed storage / IPC
19:47:36 <araujo> vincenz, saddly, most static system just doesn't fit well into this model of programming. So i think dynamic languages will enjoy the top on this for quite a while.
19:47:51 <dibblego> vincenz, it would be much easier to make up some refutation to that article that is more appealing
19:47:58 <vincenz> dibblego: oh!
19:48:03 <jrmole> and i already explained backwards compatibility -- UNIX programs run as usual, make UNIX fs calls as usual, and can only access files with the UNIX-legacy type
19:48:19 <araujo> vincenz, one of the reasons i am looking at this perl6 thingy. It is apparently a (semi-)functional scripting language.
19:48:25 <SamB> jrmole: I meant, once you are using thse typed trees
19:48:25 <jrmole> araujo, perl5 is functional even
19:48:25 <dibblego> vincenz, two equally plausible but contradicting theories where one is generally more preferred - that one will win
19:48:33 <vincenz> dibblego: trust me, I'm not that much of a linux fan that I'm offended by hsi statements :)  Was just commenting, I'm very atheistical in all computer holy wards
19:48:39 <jrmole> SamB, then your legacy code can't touch them
19:48:40 <araujo> jrmole, don't like it :-/
19:48:43 <SamB> what if you add to your program a new type of node?
19:48:47 <jrmole> or maybe can, through a wrapper that preserves safety
19:48:51 <SamB> how will that fit in the tree?
19:49:02 <vincenz> araujo: pugs right?
19:49:06 <jrmole> SamB, probably need extensible records or something
19:49:18 <SamB> thats not what I meant
19:49:23 <vincenz> araujo: you're the main maintainer, no?
19:49:25 <SamB> you'd need extensible TYPES
19:49:32 <dibblego> vincenz, I think formal reasoning with a given set of agreed axioms can solve most of those - the paradox is of course, that axiology is not taught at school - in fact, quite the opposite
19:49:33 <araujo> jrmole, i don't like many things of it ... things like no proper arguments list are some of the details that kept me away from it.....
19:49:52 <araujo> vincenz, pugs yes, me?.. main maintaner? , no :-)
19:49:56 <jrmole> SamB, okay, then let's have extensible types ;)
19:50:04 * araujo hopes to cooperate a bit wiht it though
19:50:09 <SamB> jrmole: but how"?
19:50:18 <vincenz> dibblego: well that and that sadly most of the times, the discussions turn into disagreements on axioms, hence all the holy and flaming wars on MLs and /.
19:50:26 <jrmole> that's out of my area of knowledge
19:50:33 <vincenz> araujo: I thought it was you tht was doing pugs in haskell
19:50:33 <SamB> and what if you want to read such a tree in an older copy of the program, which doesn't have that kind of nodes?
19:50:36 * dibblego bombs vincenz :)
19:50:43 <araujo> vincenz, oh, it is audreyt
19:50:44 <SamB> jrmole: see, this is the problem
19:50:45 * vincenz disagrees with dibblego's bomb
19:50:47 <vincenz> araujo: oh!
19:50:49 <araujo> :-)
19:50:51 <vincenz> araujo: then what do you do?
19:50:53 <jrmole> SamB, then you need to provide a conversion
19:51:00 <vincenz> oh wait, you're the gentoo man?
19:51:02 <SamB> nobody knows how to answer these questions, and so we are stuck with something that is basically UNIX
19:51:04 <sieni> cool, building of ghc had finished while I was sleeping <3
19:51:09 <araujo> vincenz, i just _use_ it (for now) ;-)
19:51:19 <araujo> vincenz, yup
19:51:21 <vincenz> :)
19:51:24 <araujo> :-)
19:51:25 <jrmole> SamB, i am not the smartest person who thinks about these things
19:51:30 <SamB> true
19:51:32 <dibblego> http://www.mathematik.uni-marburg.de/~eden/?content=parfctworkshop "Lazy evaluation can easily lead to very poor performance for very counter-intuitive reasons"
19:51:35 <vincenz> araujo: do you maintain ghc on gentoo?
19:51:36 <lambdabot> Title: Eden: Parallel Functional Programming, http://tinyurl.com/hm5kr
19:51:36 <jrmole> and i rather hope that whoever is the smartest person can solve these problems
19:51:43 <SamB> I mean, the probability would rather low even if you weren't sure
19:52:00 <SamB> but you must consider human factors
19:52:02 <SamB> and change
19:52:06 <araujo> vincenz, yes, i help maintaining the haskell packages
19:52:07 <dibblego> what are those reasons?
19:52:09 <SamB> change is an essential consideration in any system
19:52:19 <jrmole> SamB, indeed, and i'm not saying this is easy
19:52:27 <jrmole> i'm just saying it's not so hard it shouldn't be tried
19:52:52 <SamB> I would *really* like it if someone came up with a usable solution and actually got people started migrating to it
19:53:05 <SamB> it would be especially great if you could use it in legacy OSes too...
19:53:16 <jrmole> if we can produce languages like Haskell, and countless other elegant systems with well-thought-out design, and for that matter many cool research OSes that don't catch on commercially, we should be able to do this
19:53:21 <vincenz> dibblego: or right above it " Caliban has proven a difficult language to implement (it took 10 years!)"
19:53:24 <vincenz> o.O
19:53:28 <jrmole> SamB, i agree
19:53:30 <SamB> Haskell isn't that well thought out yet
19:53:30 <vincenz> araujo: along with dcoutts ?
19:53:38 <dibblego> vincenz, I don't know what to infer from that
19:53:48 <jrmole> SamB, it's better than any other language i've seen, by a huge margin
19:53:55 <vincenz> dibblego: yeah, me neither, I wonder who the hell would design a language if they could not even get a basic compiler done
19:54:03 <vincenz> in a reasonable aomunt of time
19:54:03 <jrmole> and it's getting better with time, quickly too
19:54:36 <SamB> well, you still have to recompile all of your libraries and programs whenever you get a new compiler, in GHC and JHC...
19:54:41 <SamB> maybe YHC can do better
19:54:46 <SamB> and JHC can't even build itself
19:54:47 <dibblego> vincenz, I'd like to evaluate the foundations for performance problems in FP -- no doubt there are knowledgable people who reject most of the claims (like the many myths about Java and performance that *still* propagate)
19:54:47 <vincenz> dibblego: it's like "and why are you using caliban then, instead of taliban of colibon"
19:54:54 <deadbeef> hi there, i started to learn haskell a few days ago
19:54:57 <jrmole> i was specifically looking at YHC for this OS thing
19:54:58 <deadbeef> wtf is a monad !?!?!
19:55:02 <vincenz> s/of/or
19:55:03 <SamB> well, actually you don't *need* to recompile your programs
19:55:05 <araujo> vincenz, yes, and kosmikus && kolmodin
19:55:11 <SamB> but when you do you need to recompile them from the beginning
19:55:24 <araujo> vincenz, now you know all the gentoo mafia :-)
19:55:26 <dibblego> deadbeef, it is part of male physiology -- every male has 2 of them
19:55:26 <Korollary> @where learning
19:55:27 <lambdabot> I know nothing about learning.
19:55:32 <Korollary> ok
19:55:32 <vincenz> araujo: my sniper is ready
19:55:36 <araujo> hah
19:55:38 <dolio> @where learn
19:55:38 <lambdabot> I know nothing about learn.
19:55:40 <SamB> yes, it sounds like YHC will be a good candidate for JIT
19:55:40 <deadbeef> dibblego: nice
19:55:46 <jrmole> SamB, it already has a nice VM
19:55:54 <jrmole> which can probably be JITed, or even precompiled
19:55:59 <jrmole> deadbeef, it's the hardest part of Haskell ;)
19:56:00 <dibblego> deadbeef, use them wisely -- evaluate before using a monad in your programming years
19:56:11 <jrmole> http://www.nomaware.com/monads/html/introduction.html
19:56:15 <lambdabot> Title: Introduction, http://tinyurl.com/kd7xj
19:56:15 <deadbeef> dibblego: sure, i've only 2..
19:56:20 <SamB> I heard that it isn't referentially transparent ;-)
19:56:23 <deadbeef> jrmole: thanks a lot
19:56:25 <SamB> but neither is GHC, of course
19:56:26 <jrmole> deadbeef, have you read any monad tutorials yet?
19:56:37 <vincenz> jrmole: those come after sexp ed?
19:56:42 <dibblego> deadbeef, I am no expert, but it is worth looking into category theory and the problems presented by an "immutable world" (implied by pure FP)
19:56:51 <SamB> well, that is, I heard you can take apart a value and serialize it over a wire...
19:56:51 <deadbeef> jrmole: i've yaht and a gentle introduction of..
19:57:01 <jrmole> i like that one, but monads are one of those things where you end up reading like 17 tutorials and somehow one of them clicks
19:57:17 <jrmole> also, don't try to understand monads by understanding the IO monad... it's the ugliest one ;)
19:57:20 * vincenz agrees with jrmole 
19:57:25 <vincenz> monads it needs to click
19:57:28 <SamB> hmm
19:57:30 <vincenz> monads need to click
19:57:35 <SamB> I dunno if they clicked for me or not!
19:57:36 <jrmole> the Maybe monad is a great one to learn -- All About Monads starts there
19:57:46 <SamB> I think I just sorta grew into them...
19:57:47 <Korollary> @google you could have invented monads
19:57:51 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
19:57:51 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
19:57:56 <jrmole> that one's also very good
19:58:13 <dibblego> @google purple gatorade
19:58:17 <jrmole> deadbeef, feel free to ask questions here too
19:58:18 <lambdabot> http://www.medhelp.org/forums/gastro/messages/35942.html
19:58:18 <lambdabot> Title: Green stool
19:58:25 <deadbeef> jrmole: thanks
19:58:50 * vincenz decouples himself from his keyboard and heads to bed
19:58:52 <deadbeef> btw fp is pretty different from all the other paradimgs i've seen
19:58:53 <dibblego> I found out what was causing my symptoms at the very moment of swallowing the last of a bottle of purple gatorade
19:58:58 <deadbeef> (imperative, logic and oop)
19:59:12 <jrmole> deadbeef, yeah, getting a good grip on "pure" Haskell is a good idea before starting to learn monads
19:59:33 <dolio> Wow, logic before functional.
19:59:41 <jrmole> even though monads are just ways of structuring what is essentially pure code (except for weird ones like IO)
19:59:54 <dibblego> a file system should be immutable
20:00:17 <dibblego> FileSystem -> FileSystemDelta -> FileSystem
20:00:23 <SamB> dibblego: okay...
20:00:25 <dibblego> or whatever it is
20:00:27 <SamB> whatever you say!
20:00:33 <jrmole> dibblego, i like the idea of keeping every copy of every file
20:00:39 <SamB> but I dunno how you can use an immutable filesystem
20:00:41 <jrmole> though you need lots of storage :)
20:00:43 <dibblego> jrmole, so does a revision control system :)
20:00:58 <jrmole> SamB, every data structure in Haskell is immutable
20:00:59 <dibblego> I'm surprised nobody has invented a revision controlled database yet
20:01:03 <SamB> it sounds sorta like an immutable RAM
20:01:07 <jrmole> how do you use them? ;)
20:01:18 <dibblego> jrmole, storage is cheap(er)
20:01:25 <SamB> jrmole: every datastructure?
20:01:40 <jrmole> SamB, except for stuff like IORefs
20:01:40 <SamB> anyway, I do like the idea of keeping a copy of every file
20:01:46 <SamB> however I lack the diskspace to do it
20:01:52 <jrmole> you can't take a Data.Map and destructively change the value at some key
20:01:59 <dibblego> Windows Vista and MacOS "keep every copy a file" from what I've seen (hype)
20:02:13 <jrmole> you can take a Data.Map and produce a *new* Data.Map with some difference from the original
20:02:19 <dibblego> or take a snapshot per save or something
20:02:19 <lispy> what package holds Monad?
20:02:21 <jrmole> and then discard the original, by way of GC
20:02:23 <SamB> also clearly the UNIX file IO primitives have to be tossed to do it
20:02:43 <dibblego> we need a new file system that is immutable and do away with the IO monad
20:02:46 <SamB> lispy: base!
20:02:55 <jrmole> SamB, no, you can emulate them on top
20:02:56 <SamB> @hoogle Monad
20:02:56 <lispy> hmm...i put that one in already...
20:02:57 <lambdabot> Control.Monad :: module
20:02:57 <lambdabot> Data.Graph.Inductive.Monad :: module
20:02:57 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
20:03:05 <deadbeef> look like monads are used to give to fp some capabilities of oop
20:03:06 <SamB> jrmole: that sounds iffy
20:03:14 <deadbeef> modularity, flexibility and stuff
20:03:15 <jrmole> SamB, of course, but implementing UNIX on bare metal is also iffy
20:03:16 <SamB> because you'd keep too many copies that way
20:03:19 <lispy> Could not find module `Monad':
20:03:19 <lispy>   use -v to see a list of the files searched for
20:03:19 <lispy>   (imported from ./FastPackedString.hs)
20:03:29 <SamB> hmm
20:03:31 <dibblego> deadbeef, oop gives you the opposite of that
20:03:36 <jrmole> SamB, i'm not saying there aren't problems, or that i can solve them
20:03:36 <deadbeef> lol
20:03:39 <SamB> Prelude> :i Monad
20:03:40 <SamB> ...
20:03:42 <jrmole> but i do believe that they can be solved
20:03:44 <SamB>         -- Imported from GHC.Base
20:03:44 <dibblego> deadbeef, don't take the bait - I am writing a book about it as we speak
20:04:28 <Korollary> dibblego: a book?
20:04:32 <jrmole> you can also only store revision information for "new"-type files, if you like
20:04:43 <dibblego> Korollary, yes, among other things I have been tasked to do
20:04:51 <jrmole> in fact, you could select for each file how much revision info you want
20:04:59 <lispy> SamB: Build-Depends: fps >= 0.8, QuickCheck, parsec, base, unix, mtl
20:05:05 <jrmole> and it will be transparently made available at whatever resolution is wanted, provided the data is there
20:05:10 <lispy> SamB: then i did a clean, configure and build and i get the same error...
20:05:27 <SamB> oh, Monad ain't a module is it?
20:05:32 <SamB> isn't Monad a class?
20:05:41 <SamB> oh, wait, you maybe want Control.Monad
20:05:52 <SamB> Monad is from Haskell 98 ;-P
20:05:54 <jrmole> there's a haskell98 module called Monad
20:06:08 <SamB> that is so 7 years ago
20:06:15 <lispy> oh, i'll add haskell98 and see what happens
20:06:17 <deadbeef> dibblego: why you say so ? about the oop thing
20:06:19 <NoGoodNik> is Haskell 98 the current version?
20:06:27 <jrmole> i think in ghc it just imports Control.Monad
20:06:36 <jrmole> NoGoodNik, it's the current standardized version
20:06:39 <deadbeef> NoGoodNik: nop, the current one is Haskell XP
20:06:45 <SamB> NoGoodNik: but a lot of people don't use that anymore
20:06:46 <dibblego> deadbeef, I'll send you a copy when I am done :) I like to be thorough in answering that question
20:06:48 <jrmole> but there are many very useful extensions which are de facto standards
20:06:52 <deadbeef> soon there will be Haskell Vista
20:06:54 <lispy> oh, that didi it
20:07:01 <lispy> now i'm missing Control.Monad.Reader
20:07:01 <SamB> we at least tend to add the FFI and Heirarchical addendums
20:07:08 <NoGoodNik> what's the current stable / main one then?
20:07:10 <deadbeef> dibblego: thanks
20:07:11 <Korollary> NoGoodNik: Officially, yes. But the extensions to the standard are commonly used.
20:07:13 <SamB> lispy: mtl
20:07:33 <SamB> and if you are using Control.Monad.Reader, you don't need to use the old Monad module...
20:07:33 <lispy> oh, i had that but removed it because it hought it was unneded :)
20:07:34 <lispy> thanks
20:07:39 <jrmole> NoGoodNik, there's Haskell 98 (officially standard, but rather limiting), and there's informally "Haskell you can always get away with using" (Haskell 98 + extensions supported everywhere)
20:07:46 <jrmole> and then there's GHC vorpal space Haskell
20:07:55 <SamB> you could just use Control.Monad instead of Monad
20:08:02 <SamB> Control.Monad being in base
20:08:32 <lispy> SamB: dons is removing fps for Data.ByteString so i'm not too worried about it
20:08:33 <jrmole> NoGoodNik, in practice, there are only a few Haskell implementations (GHC and Hugs being the primary two)
20:08:40 <lispy> but that's good to know
20:09:02 <NoGoodNik> so whatever is common between them is the defacto current Haskell?
20:09:07 <SamB> lispy: fps *is* Data.ByteString!
20:09:08 <jrmole> more or less
20:09:23 <jrmole> hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
20:09:40 <SamB> NoGoodNik: why settle for the commonality?
20:09:53 <jrmole> people talk about Haskell' (Haskell Prime), which is the working name for the next standardized version
20:09:55 <SamB> anyway, the current state of affairs can be seen as a mess
20:10:08 <jrmole> which will incorporate some but not all of the cool stuff that the GHC / Hugs people have implemented experimentally
20:10:09 <lispy> SamB: but darcs's fps is not fps
20:10:15 <SamB> lispy: oh
20:10:18 <lispy> SamB: and i wasn't clear but i meant darcs's fps
20:10:24 <SamB> you are darcs hacking, right ;-)
20:10:31 <lispy> yup
20:10:46 <NoGoodNik> SamB, I'm just looking for a current starting place
20:10:58 <SamB> NoGoodNik: how about a tutorial ;-)
20:11:12 <jrmole> NamelessOne, to learn Haskell in general?
20:11:18 <jrmole> err...
20:11:20 <jrmole> NoGoodNik, i meant
20:11:23 <SamB> everything in Haskell 98 but the module names is still good
20:11:26 <NamelessOne> heh
20:11:26 * jrmole kicks his tab key
20:11:29 <NoGoodNik> I'm currently at http://www.haskell.org/tutorial/classes.html
20:11:31 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
20:11:42 <deadbeef> ?type fix
20:11:44 <lambdabot> forall a. (a -> a) -> a
20:11:51 <NoGoodNik> Gentle sounded good at the time :-)
20:12:00 <deadbeef> this is another function i don't think i've got it good
20:12:03 <deadbeef> (fix)
20:12:08 * syntaxfree softly whispers  "monad comprehensions"
20:12:15 <syntaxfree> NoGoodNik: looking for a gentle tutorial?
20:12:19 <SamB> syntaxfree: are you just trying to confuse people?
20:12:28 <SamB> there is no such thing!
20:12:29 <jrmole> he's the ghost of features past
20:12:34 <NoGoodNik> I'm doing well with that one
20:12:38 <NoGoodNik> or so I think
20:12:43 <syntaxfree> why remove features?
20:12:50 <jrmole> syntaxfree, because it confused people
20:12:52 <SamB> syntaxfree: because nice type errors are good
20:12:59 <jrmole> doing lists of other monadic values, etc
20:13:00 <Korollary> deadbeef: You need to become familiar with lambda calculus to understand fix. It's not really necessary to know.
20:13:12 <jrmole> was hard to know which monad you were actually working in, especially if you thought that comprehensions were for lists only
20:13:31 <jrmole> to quote a friend of mine, "If this is gentle, then I'd imagine the regular introduction to Haskell dispatches a team of ninjas to my location to batter me about the head."
20:13:53 <deadbeef> Korollary: is it about least-fixed-point ?
20:13:54 <NoGoodNik> this one isn't bad, given I had a little bit of experience with ML
20:14:02 <SamB> and really the square brackets do kinda give the impression that you are in the safe company of ordinary lists ;-)
20:14:03 <jrmole> but if it works for you, it will teach things better than most
20:14:21 <jrmole> ah, that's good -- most people coming at Haskell have no FP experience, or maybe only Scheme
20:14:22 <Korollary> deadbeef: Yes.
20:14:37 <sieni> yes, the "gentle introduction" is nice if you already have some experience with scheme or ml.
20:14:43 <deadbeef> (i'm a cs student but i'vent seen any real world fp)
20:14:44 <SamB> isn't least-fixed-point a *maths* thing?
20:14:47 <NoGoodNik> yeah ... Scheme didn't click for me but ML did
20:14:54 <NoGoodNik> so I decided to try the next step
20:15:03 <SamB> well, Haskell is like applied CS ;-)
20:15:04 <jrmole> SamB, lambda calculus is a maths thing
20:15:24 <SamB> I suppose you could say that all hardcore FP is a maths thing
20:15:28 <jrmole> lambda calculus existed before computers did, in fact before Turing machines
20:15:33 <SamB> except the performance tweaking
20:15:41 <SamB> which is more of a black art
20:15:50 <Korollary> deadbeef: This guy has written a few nice introductory tutorials on LC: http://scienceblogs.com/goodmath/2006/08/why_oh_why_y.php
20:15:53 <SamB> which likes to pretend to be a science
20:16:49 <deadbeef> Korollary: yes, i've had a course on that
20:16:50 <jrmole> SamB, if you want a really mathy interpretation of Haskell, it's a proof language for a logic which happens to be curry-howard-isomorphic to the Haskell type system ;)
20:17:02 <jrmole> and it's a miraculous coincidence that our proofs happen to give executable programs too
20:17:19 <deadbeef> i have some knowledge of lc, kleene's theorems (smn, recursion and stuff) etc.
20:17:19 <SamB> which would be a pretty lousy logic
20:17:25 <SamB> if you ask me
20:17:31 <jrmole> SamB, why do you say that?
20:17:31 <SamB> all those bottoms...
20:17:47 <syntaxfree> sieni: I had plenty of experience with Scheme, and yet the Gentle Introduction didn't click because it started out with types, and types in Scheme are secondary.
20:17:53 <syntaxfree> So I skipped types, and soon I was lost.
20:18:00 <SamB> I mean, you can prove *anything* with error...
20:18:14 <jrmole> well, there are some reasonable subsets of Haskell's type system that can be useful as logics
20:18:15 <SamB> @free undefined
20:18:17 <lambdabot> f undefined = undefined
20:18:33 <SamB> @free error
20:18:35 <lambdabot> ( g z = z  =>   $map g x = y ) => f (error x) = error y
20:18:39 <SamB> @free fail
20:18:41 <lambdabot> Expected variable or '.'
20:18:48 <jrmole> @free \x -> x
20:18:48 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
20:18:54 <SamB> @free map
20:18:56 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
20:19:01 <Adamant> Yet Another Haskell Tutorial is pretty gentle
20:19:07 <SamB> jrmole: it only works on named functions.
20:19:11 <Adamant> so far, at least.
20:19:12 <syntaxfree> YAHT is way better than the Gentle INtroduction.
20:19:16 <SamB> it used to require you to type the type as well
20:19:30 <jrmole> SamB, yeah, i made a stupid mistake anyway
20:19:45 <SamB> @free id
20:19:46 <lambdabot> f . id = id . f
20:19:55 <SamB> see, it works better if you use the name
20:20:00 <NoGoodNik> syntaxfree, in what way?
20:20:10 <syntaxfree> it's gentler :)
20:20:19 <SamB> instead of writing your own id ;-)
20:20:39 <syntaxfree> it's also a lot longer, though. The Gentle Introduction is more concise.
20:20:53 <NoGoodNik> I like concise, even if I have to read parts twice
20:22:15 <syntaxfree> I think the Gentle Introduction supposes you already know why you want Haskell.
20:22:30 <syntaxfree> Most people begin with Haskell without really knowing why they want it.
20:22:48 <NoGoodNik> heh, I'm vague on that too.
20:22:50 <NoGoodNik> so are instances like common OO classes but without state?
20:23:09 <SamB> ... maybe.
20:23:12 <syntaxfree> instances are types belonging to a class.
20:23:24 <jrmole> Haskell classes are like interfaces
20:23:25 <NoGoodNik> and classes are like OO interfaces?
20:23:29 <jrmole> yes
20:23:40 <SamB> interfaces are a very good idea
20:23:47 <syntaxfree> What really helped  me to grok Haskell was to think of it as a category of types with functions as arrows.
20:24:09 <SamB> and we like them so much we have figured out how to make interfaces that involve multiple types!
20:24:12 <jrmole> instance MyClass MyType where ... -- here you give implementations for the class's methods on your type
20:24:21 <SamB> though we aren't sure which way is best, yet
20:24:53 <NoGoodNik> multi-type classes?
20:25:06 <SamB> yeah, we have those!
20:25:29 <dfranke> syntaxfree: I'm going in the opposite direction... learning Haskell to help me learn Category Theory.
20:25:35 <jrmole> in that case, a class is less an interface over single types, and more a relation on types
20:25:36 <SamB> someone also came up with some scheme to put types in the interface next to methods
20:25:53 <dfranke> syntaxfree: or really, learning the two simultaneously.
20:26:14 <NoGoodNik> jrmole, so that's like a static version of multiple dispatch?
20:26:23 <SamB> NoGoodNik: not really...
20:26:25 <jrmole> NoGoodNik, these are fairly esoteric extensions though... you don't need to learn them immediately if you'd rather not
20:26:41 <jrmole> it's somewhat like how in java you might have T1 implements Comparable<T2>
20:26:44 <lispy> so when i run "./Setup.lhs build" i get a lexical error on this one file, but when i run "ghc --make Context.hs" it compiles cleanly...any ideas?
20:26:46 <jrmole> only here we'd just say instance Comparable T1 T2
20:26:52 <lispy> the lex error happens on a multiline string
20:26:54 <jrmole> so it's not attached to one or the other type
20:27:02 <SamB> jrmole: but not if we were using that other system
20:27:07 <dfranke> syntaxfree: trying to work my way up to grokking monads.  Looks like I'm about half way there: need to get from categories, to functors, to natural transformations, to universals, to adjoints, to monads.
20:27:10 <syntaxfree> a type class  is a set of types with common operations.
20:27:13 <NoGoodNik> jrmole, right ... I thought that's what multiple dispatch did, but dynamicaly
20:27:16 <jrmole> SamB, you mean associated types?
20:27:23 <dfranke> syntaxfree: and I think I just figured out natural transformations.
20:27:23 <SamB> jrmole: is that what it is called?
20:27:32 <syntaxfree> I stopped at functors.
20:27:45 <jrmole> SamB, you mean instance Foo Bar where { type Baz ... } ?
20:27:48 <jrmole> those are associated types iirc
20:27:49 <Korollary> ?users
20:27:52 <lambdabot> Maximum users seen in #haskell: 221, currently: 206 (93.2%), active: 28 (13.6%)
20:28:06 <SamB> NoGoodNik: well, we don't have any inheritance to screw things up, though ;-)
20:28:17 <jrmole> they're far less standard than MPTC/FD
20:28:18 <SamB> jrmole: that sort of thing, yes ;-)
20:28:40 <SamB> well, if you read the Haskell' stuff it looks like they don't think so!
20:28:49 <jrmole> it's used a lot less, anyway
20:29:00 <SamB> with the minor detail of lack of implementation in GHC
20:29:04 <jrmole> some really essential libraries like Control.Monad.State use MPTC
20:29:06 <syntaxfree> dfranke: I have a vague idea of natural transformations.
20:29:13 <SamB> then again, some people want to take out classes entirely, or so it seems!
20:29:24 <SamB> jrmole: I know!
20:29:25 <jrmole> SamB, how can you do that?
20:29:32 <SamB> I was kinda horrified!
20:29:45 <SamB> but, they did say "believe it or not" or something like that...
20:29:53 <dfranke> syntaxfree: the hand-wavey version is that natural transformations are the arrows of a category where functors are objects.
20:29:57 <deadbeef> > let f x = if (x < 5) then (x + 1) else x; f (fix f)
20:29:58 <lambdabot>  Parse error
20:29:58 <SamB> @google "haskell prime" removal candidates
20:30:04 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/ticket/66
20:30:04 <lambdabot> Title: #66 (make sure removal candidates are added as proposals) - Haskell Prime - Trac
20:30:09 * syntaxfree mumbles "monad comprehensions"
20:30:09 * syntaxfree = the monad comprehension troll
20:30:14 <deadbeef> > let f x = if (x < 5) then (x + 1) else x; f 4
20:30:15 <lambdabot>  Parse error
20:30:30 <SamB> http://hackage.haskell.org/trac/haskell-prime/wiki/RemovalCandidates
20:30:32 <NoGoodNik> SamB, I thought there was inheritance of type classes
20:30:34 <lambdabot> Title: RemovalCandidates - Haskell Prime - Trac, http://tinyurl.com/eso8h
20:30:36 <syntaxfree> dfranke: oh, I understood it differently, I think.
20:30:43 <jrmole> > let f x = if (x < 5) then (x + 1) else x; in f 4
20:30:44 <lambdabot>  5
20:30:47 <SamB> NoGoodNik: yes, but remember typeclasses are like interfaces
20:30:57 <NoGoodNik> you meant implementation inheritance?
20:31:02 <SamB> you don't dispatch *on* them...
20:31:09 <deadbeef> > let f x = if (x < 5) then (x + 1) else x in f (fix f)
20:31:10 <lambdabot>  Exception: <<loop>>
20:31:15 <SamB> yeah, Haskell doesn't have instances inheriting from eachother
20:31:27 <deadbeef> > let f x = if (x < 5) then (x + 1) else x in fix f
20:31:27 <NoGoodNik> right
20:31:28 <lambdabot>  Exception: <<loop>>
20:32:00 <SamB> the closest thing would be GHC's newtype deriving extension, and that only carries over particular things
20:32:04 <deadbeef> what's wrong ?
20:32:10 <SamB> you could just as well write it all out by hand
20:32:19 <SamB> > fix id 1
20:32:20 <lambdabot>  Add a type signature
20:32:26 <SamB> @type fix id 1
20:32:27 <lambdabot> forall t. t
20:32:34 <SamB> hmm
20:32:41 <SamB> @free fix
20:32:43 <lambdabot> f . g = h . f => f (fix g) = fix h
20:33:30 <jrmole> SamB, you can do instance (Foo a) => Bar a with the right GHC exts
20:33:53 <jrmole> isn't that instance inheritance?
20:33:56 <SamB> no
20:34:09 <SamB> because Foo and Bar don't share methods...
20:34:31 <dfranke> syntaxfree: anyway, I've been working my way through Mac Lane.  I've just about finished chapter 2.  Monads are chapter 6.
20:34:44 <SamB> though it has probably a lot of similar problems...
20:34:51 <syntaxfree> MacLane? As in, Cat Theory for the Working Mathematician!
20:35:02 <dfranke> yup.
20:35:05 <syntaxfree> s/!/?
20:35:06 <syntaxfree> WOW.
20:35:06 <SamB> http://hackage.haskell.org/trac/haskell-prime/ticket/90
20:35:10 <lambdabot> Title: #90 (solve the MultiParamTypeClassDilemma) - Haskell Prime - Trac, http://tinyurl.com/nmjvs
20:35:16 <dfranke> syntaxfree: wow?
20:35:19 <SamB> jrmole: see that ticket!
20:35:37 <SamB> if you want to know what I'm talkin' about WRT associated types and MPTCs/fundeps
20:35:37 <syntaxfree> I'm picking it up from Freyd's book.
20:36:14 * edwardk waves ello.,
20:36:32 <deadbeef> > let f x = if (x < 5) then (x + 1) else x in fix f
20:36:34 <lambdabot>  Exception: <<loop>>
20:36:38 <deadbeef> i don't get what's wrong here
20:36:44 <deadbeef> the result should be '5'
20:36:59 <Cale> why?
20:37:06 <lispy> so how do you use cabal to build on windows if the unix version need posix but the windows version doesn't?
20:37:10 <deadbeef> because 5 is the least fixed point of f
20:37:10 <jrmole> deadbeef, fix isn't that smart
20:37:13 <Cale> fix f = f (fix f)
20:37:24 <lispy> are you forced to have multiple .cabal files?
20:37:31 <SamB> deadbeef: maybe you are using a different definition of least...
20:37:42 <deadbeef> least = minimum ?
20:37:48 <SamB> yes
20:37:50 <Cale> least defined
20:37:58 <SamB> but which ordering are you using?
20:38:06 <deadbeef> the one on naturals
20:38:09 <deadbeef> <=
20:38:11 <SamB> hah!
20:38:14 <edwardk> least is not with respect to the numerical ordering, but instead with respect to the CPO of function definedness
20:38:25 <lispy> CPO?
20:38:28 <lispy> like 3CPO?
20:38:33 <edwardk> heh
20:38:34 <SamB> Complete Partial Order?
20:38:37 <edwardk> not qite =)
20:38:45 <SamB> whats it really than?
20:38:48 <deadbeef> i don't get it
20:38:51 <SamB> continuous partial order?
20:38:59 <edwardk> complete partial order
20:39:02 <lispy> why are we talking about star wars all the sudden?
20:39:06 <SamB> thats what I said!
20:39:21 <SamB> oh, also, C3PO has the C before the 3 ;-P
20:39:22 <lispy> ?hoogle force
20:39:22 <lambdabot> Control.Parallel.Strategies.force :: NFData a => a -> a
20:39:23 <lambdabot> System.Console.Readline.forcedUpdateDisplay :: IO ()
20:39:23 <lambdabot> Control.Parallel.Strategies.sforce :: NFData a => a -> b -> b
20:39:34 <lispy> ah, typo
20:39:59 <NoGoodNik> is it possible to write an in-place quicksort in Haskell? would that involve monads? or does Haskell in general not concern itself with such issues?
20:40:00 <Cale> > let f g x = if (x < 5) then g (x + 1) else x in fix f 0
20:40:01 <lambdabot>  5
20:40:12 <jrmole> NoGoodNik, the latter
20:40:13 <Cale> deadbeef: that's probably what you meant to write
20:40:16 <lispy> NoGoodNik: you could od it with monads
20:40:22 <SamB> NoGoodNik: sure! but you'd need to use a few extensions
20:40:26 <edwardk> nogoodnik: you can do it on an array or something in the IO or ST monad, but basically no
20:40:32 <Cale> The ST monad would be sufficient
20:40:36 <Cale> You wouldn't need IO
20:40:39 <SamB> Cale: eh
20:40:54 <jrmole> data structures in pure Haskell cannot be destructively updated
20:41:09 <Cale> NoGoodNik: but the non-inplace one does have some cool nice things about it
20:41:10 <SamB> either way you'd need an unsafe* to get it to work right with unboxed arrays...
20:41:17 <SamB> of polymorphic type...
20:41:25 <lispy> i wonder how fast inplace quicksort would be in haskell compared to some typical C implementation
20:41:27 <NoGoodNik> Cale, it does?
20:41:27 <jrmole> NoGoodNik, have you seen the standard (non-inplace) haskell quicksort?
20:41:28 <Cale> NoGoodNik: For example, if you only use the first element of the sorted list, you get it in O(n) time
20:41:28 <edwardk> you'd need to defect to clean or something to get in-place referentially transparent updates
20:41:29 <syntaxfree> don't mention unsafePerformIO again or I'l throw a hissy fit.
20:41:39 <NoGoodNik> jrmole, I am looking at one right now
20:41:44 <deadbeef> Cale: looks like minimalization operator
20:41:47 <SamB> jrmole: quicksort isn't the best for lists is it?
20:41:49 <deadbeef> btw thanks a lot
20:41:55 <SamB> isn't the one in Prelude better?
20:42:09 <lispy> syntaxfree: we're in the ST monad in this hypothetical example so calm down :)
20:42:20 <edwardk> hehehe
20:42:21 <jrmole> iirc there's a mergesort optimized for sequential access
20:42:34 <SamB> lispy: have you tried to use runSTUArray at a polymorphic type?
20:42:51 <lispy> SamB: no, what's that like?
20:42:53 <jrmole> NoGoodNik, this one: http://haskell.org/haskellwiki/Why_Haskell_matters#Elegance ?
20:42:57 <lambdabot> Title: Why Haskell matters - HaskellWiki, http://tinyurl.com/egeye
20:43:02 <SamB> lispy: not possible!
20:43:04 <lispy> egeye!
20:43:15 <SamB> that is why I'd rather just use unsafePerformIO!
20:43:27 <lispy> sshh...
20:43:32 <lispy> syntaxfree will hear you....
20:43:33 <SamB> its not like I can hide an IORef in my array by accident anyways!
20:43:36 <deadbeef> let f g x = if (x < 5) then g (x + 1) else x in fix f 1
20:43:43 <deadbeef> > let f g x = if (x < 5) then g (x + 1) else x in fix f 1
20:43:44 <lambdabot>  5
20:43:48 <deadbeef> > let f g x = if (x < 5) then g (x + 1) else x in fix f 6
20:43:49 <lambdabot>  6
20:44:03 <deadbeef> oh ok
20:44:07 <lispy> SamB: right, and given the same input it should always sort the same...
20:44:10 <jrmole> which is equivalent to just
20:44:14 <jrmole> > let f x = if (x < 5) then f (x + 1) else x in f 1
20:44:15 <lambdabot>  5
20:44:27 <SamB> lispy: unsafePerformIO just means "make sure you don't do anything stupid, kid!"
20:44:43 <SamB> or I suppose I should be telling this to syntaxfree
20:44:50 <lispy> s/anything stupid,kid/anything, stupid kid/
20:45:11 <NoGoodNik> jrmole, no, the one on slide 65 of Tim Sweeney's presentation
20:45:15 <SamB> what in the ... ?
20:45:27 <NoGoodNik> similiar but without the filter or where
20:45:28 <lispy> what in the elipse?
20:45:28 <SamB> Tim Sweeney is interested in Haskell?
20:45:32 <lispy> SamB: yeah
20:45:36 <SamB> coool
20:45:37 <edwardk> samb: sorta
20:45:44 <lispy> SamB: and seems to be fairly well educated on the features
20:45:46 <SamB> he's the guy who lost the source to ZZT right?
20:45:46 <edwardk> samb: he likes purity and STM, hates the syntax.
20:45:48 <edwardk> =)
20:45:50 <syntaxfree> unsafePerformIO is against the Spirit of Haskell.
20:45:50 <syntaxfree> the Tangled Gnomes would not approve of unsafePerformIO
20:45:53 <edwardk> samb: yeah
20:46:00 <lispy> SamB: guy in charge of unreal at epic
20:46:17 <jrmole> syntaxfree, are those like machine elves?
20:46:23 <NoGoodNik> what's STM?
20:46:24 <SamB> I haven't really played any of his games since SuperZZT, and that wasn't very good compared to ZZT
20:46:28 * lispy fears the magnent gnomes
20:46:43 <SamB> mostly for lack of interest in FPS games
20:46:43 <dfranke> lispy: does he have a dual who is charge of Real at Monic?
20:46:56 <SamB> perhaps because you have to buy them
20:47:03 <syntaxfree> @quote syntaxfree
20:47:03 <lambdabot>  Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional programming conference,
20:47:04 <lambdabot>  some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the
20:47:04 <lambdabot> Tangled Gnomes gave them the S
20:47:07 <SamB> and you need a graphics card too
20:47:10 <lispy> dfranke: are you suggesting the existenc of a co-Sweeny?
20:47:21 <syntaxfree> ecret of Haskell!
20:47:30 <edwardk> nogoodnik: software transactional memory, its a way to do multithreaded programming without explicit locks everywhere in a manner than composes well
20:47:37 <NoGoodNik> ah yes, that
20:47:45 <SamB> I looked that one up once when lambdabot mentioned it before
20:48:14 <musasabi> morning
20:48:42 <SamB> oh, I better go to bed now if it is morning already!
20:48:55 <lispy> @localtime dons
20:48:57 <lambdabot> Local time for dons is Tue Sep  5 13:48:33 2006
20:49:02 <musasabi> edwardk: what kind of STM datastructures do you have? looking for a graph/B+tree/hashtable
20:50:08 <Cale> Yeah, it'll be cool to have a decent library of STM structures in the hierarchy :)
20:50:12 <edwardk> musasabi: i have a hashtable
20:50:21 <edwardk> musasabi: http://slipwave.info/haskell/thash
20:50:25 <lambdabot> Title: Index of /haskell/thash
20:50:48 <edwardk> didn't get around to building more general stuff coz i'm waiting for class-associated types before i do any more data structures.
20:51:35 <musasabi> good point
20:52:07 <edwardk> once we have CATs i can go back and make generic data structures that work over ST, STM or IO
20:52:12 <edwardk> then i'll go nuts
20:52:32 <NoGoodNik> STM requires referential transparency, right?
20:52:49 <edwardk> nogoodnik: at least within the transaction, yeah. otherwise all sorts of bad things could happen
20:53:36 <NoGoodNik> heh ...
20:53:50 <syntaxfree> CATs?
20:53:57 <edwardk> class associated types
20:54:12 <edwardk> class Foo a where type Bar b = Bar a b or something like that
20:54:45 <edwardk> right now there is no good way to make types depend on classes in any meaningful way
20:56:45 * edwardk dances a little jig as he finally gets his paraconsistency proof done.
20:59:12 <NoGoodNik> Have any GUI programs or web apps been done with Haskell? How do they deal with user interaction?
20:59:54 <edwardk> nogoodnik: look at fudgets, there are some others too
21:00:48 <edwardk> though i think it safe to say that fudgets UI's are still in the real of 'programmer art' =)
21:01:34 <NoGoodNik> meh :-)
21:03:51 <Teekwod> i was done
21:03:51 <Cale> NoGoodNik: There's Gtk2Hs
21:03:53 <Teekwod> unban me in #math cale
21:03:58 <Cale> Teekwod: no
21:04:43 <Teekwod> ok
21:04:45 <Cale> NoGoodNik: Which is a pretty full featured binding to Gtk2
21:04:54 <edwardk> never knew #math existed ;)
21:04:55 --- topic: set to 'NIGGERS!' by Teekwod
21:05:08 <edwardk> @topic
21:05:09 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
21:05:14 <edwardk> @topic-init
21:05:15 <lambdabot> I do not know the channel
21:05:19 <edwardk> @topic-init #haskell
21:05:20 <lambdabot> Topic does not parse. Should be of the form ["...",...,"..."]
21:05:23 <edwardk> ah
21:05:31 <edwardk> hrmm
21:05:40 <Teekwod> I WILL STOP WHEN THIS DIPSHIT UNBANS ME FROM #MATH
21:06:15 <edwardk> will someone bother to assume ophood? =)
21:06:32 <Cale> I'm not an op here
21:06:46 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by NoGoodNik
21:06:50 --- topic: set to 'NIGGERS!' by Teekwod
21:06:51 <Cale> But lilo might come to k-line this annoyance.
21:07:02 <Cale> If he doesn't I'll page him.
21:07:09 <edwardk> k
21:07:19 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by Cale
21:07:21 --- topic: set to 'NIGGERS!' by Teekwod
21:07:21 <edwardk> in the meantime, whats the major topic of discussion over in #math
21:07:25 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by Cale
21:07:26 --- topic: set to 'NIGGERS!' by Teekwod
21:07:33 <pingu> Grow up Teekwod.
21:07:45 <Cale> Teekwod: please grow a second brain cell.
21:07:55 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by Cale
21:07:56 --- topic: set to 'NIGGERS!' by Teekwod
21:08:02 <NoGoodNik> reminds me of that bash.org quote about electrocuting people over the internet.
21:08:06 --- topic: set to '' by Cale
21:08:10 --- topic: set to 'NIGGERS!' by Teekwod
21:08:35 <pingu> Perhaps that paging of lilo is a decent idea.
21:08:45 --- topic: set to 'blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl' by Teekwod
21:09:00 <dibblego> what a sick sad world we live in
21:09:20 <Teekwod> dibblego: the sick, sad thing is cale was getting off on his power in #math to ban me for no reason.
21:09:32 <Cale> Teekwod: not for no reason
21:09:33 <Teekwod> once the unjust ban is lifted, i will leave you guys alone :)
21:09:35 <Teekwod> nothing personal
21:09:44 <pingu> Trolling isn't going to help you.
21:09:46 <dibblego> Teekwod, and that you whinge and bitch about it? my 5 year old stopped doing that a couple of years ago - my 3 year old is nearly there
21:09:51 <edwardk> teek, we don't care aout your little power trip, it'll all come to an end soon enough
21:09:54 <Cale> Teekwod: You were irritating people. I had a few requests to ban you.
21:10:05 <Cale> Teekwod: and I agreed with them
21:10:14 <jrmole> wow, he was irritating people? you don't say
21:10:28 <dibblego> even if cale was completely out of order, is your response in any way rational
21:10:29 <dibblego> ?
21:10:33 <Teekwod> jrmole: mol
21:10:34 <Teekwod> lol
21:10:37 <sjanssen> @teekwod
21:10:38 <lambdabot> Unknown command, try @list
21:10:40 <Teekwod> dibblego: nope.
21:10:43 <sjanssen> hmm, maybe tomorrow
21:10:54 --- topic: set to '' by pingu
21:10:54 <edwardk> well, it looks like at this rate he'll get two-for-one on that channel  ban thing ;)
21:11:06 <Cale> I should get shapr to make me an op here, since I'm basically always around :)
21:11:20 <lispy> Cale: i was thinking the same thing
21:11:23 <edwardk> where is shapr?
21:11:29 <dibblego> Teekwod, I am wronged by "someone on a power trip" each day - there are some well known responses that are effective
21:11:33 <Cale> I'm not sure, haven't seen too much of him lately.
21:11:37 <edwardk> he's been off in lala-land for the last couple of weeks. very strange without him
21:11:43 --- topic: set to 'blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl' by Teekwod
21:11:52 <dibblego> Teekwod, you will only isolate yourself with this response and contribute adversely to an overall preferred outcome
21:12:17 <lispy> why lose the battle when you can just loose the war...
21:12:19 <edwardk> Anyways, back to Haskell =)
21:13:07 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by araujo
21:13:10 <dibblego> we should throw bombs at each other
21:13:19 <dibblego> we are such idiots
21:14:19 --- topic: set to 'blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl' by Teekwod
21:14:32 <nalioth> Teekwod: is there a purpose for this activity?
21:15:44 <nalioth> Teekwod: please think and answer the question, i'm interested.
21:15:46 <int-e> he's just taking out his frustration of being kicked on another channel here. which is one of the worst possible things to do, but oh well.
21:15:55 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by dibblego
21:15:58 --- topic: set to 'blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbl' by Teekwod
21:16:01 <pingu> I think he's trying to proove that he's a dick.
21:16:01 <Teekwod> nalioth: paste question, i was looking at something else.
21:16:05 <Cale> NoGoodNik: check out http://haskell.org/gtk2hs/screenshots/ :)
21:16:07 <lambdabot> Title: Gtk2Hs ¬ª Screenshots
21:16:09 <edwardk> so, been playing with my substructural types some more and noticed a few oddities in the notation. if you let + be relevance (1 or more usage) and ? be affinity (0 or 1 usage) then the combination of the two should be * for unrestricted (commonly the ! comonad/modallity) and uniqueness (commonly *) should be ! instead. ;)
21:16:22 <NoGoodNik> Cale, sweet :-)
21:16:30 <dolio> ?where nymphaea
21:16:31 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
21:16:37 <dolio> There, too.
21:16:38 <edwardk> that way ?+ becomes * like you would expect if you used a regular expression
21:16:43 <dibblego> Teekwod, nalioth asked if there was a purpose for your activity
21:16:52 <Cale> yeah, nymphaea is the project that Paolo and I were working on :)
21:17:33 <dibblego> IRC channels should be immutable - then we could all revert to a particular revision and leave Teekwod on the HEAD revision
21:17:45 <Teekwod> the purpose is to get unbanned in #math
21:17:49 <NoGoodNik> Cale, but I'm more interested in what approach such libaries take on integrating user interaction with functional purity rather than UI prettyness
21:17:50 <dibblego> if only time were bidirectional
21:17:52 <Teekwod> failing that, to annoy the hell out of cale
21:17:57 <rue> Good luck with that.
21:18:02 --- mode: nalioth set +b *!*@ool-4574f884.dyn.optonline.net
21:18:04 <edwardk> teekwod: i think the more likely result is that you will succeed in getting banned from #haskel
21:18:08 <int-e> Teekwod: you'll fail on both accounts.
21:18:44 <nalioth> Teekwod: i really do think that you've chosen the wrong tactic to persue.  Trolling on multiple channels brings one into the category of "network problem"
21:18:47 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by dibblego
21:18:56 <Cale> NoGoodNik: hmm, there have been some interesting approaches to the construction of dialogs
21:19:23 <edwardk> thx: nalioth
21:21:32 <NoGoodNik> anyway, I'm probably not ready for all that yet, have to get the basics of the language itself before looking into how it tries to fit into the rest of the world.
21:22:03 <Cale> http://www.sandr.dds.nl/FunctionalForms/index.html
21:22:07 <lambdabot> Title: FunctionalForms, http://tinyurl.com/p98ls
21:22:40 <NoGoodNik> ugh, I've been clicking on URLs too much, when will I ever be able to go through them all.
21:22:47 <Cale> hehe
21:23:04 <NoGoodNik> Cale, tell me you're not an undergrad student.
21:23:21 <Cale> NoGoodNik: I'm no longer an undergrad student?
21:23:24 <Cale> hehe
21:23:26 <NoGoodNik> thx
21:23:30 <dons> hmm. what's happening
21:23:40 <Cale> I just finished my pure mathematics degree.
21:23:43 <edwardk> hey dons, you missed some fireworks with Teekwod being an idiot
21:23:46 * dfranke hopes to be in that classification very soon
21:23:54 <dons> do i need to take any action?
21:23:59 <Cale> dons: nope
21:24:04 <NoGoodNik> I just finished my Bachelor of Soft Eng ... for what that's worth.
21:24:05 <edwardk> dons: nalioth stepped in to +b him
21:24:09 <audreyt> weird topic
21:24:11 <dons> ok great
21:24:11 <lispy> oh nice
21:24:14 <Cale> BMath here
21:24:16 <audreyt> "Haskell is still the language of choice for discriminating"
21:24:17 <lispy> nalioth: thanks!
21:24:25 <audreyt> I mean, that's true, but :)
21:24:32 <dons> line break/
21:24:33 <dons> ?
21:24:51 <edwardk> dons: someone manually reset it
21:24:56 <jrmole> looks fine here
21:25:19 <audreyt> ah, indeed, extra linebreak.
21:25:26 <lispy> well, i was just able to build darcs using cabal...
21:25:29 <dfranke> Double math/CS, hopefully going on grad school for CS
21:25:37 <dons> crikey. that was a pretty wacky 30 minutes
21:25:46 <NoGoodNik> Cale, did you take CS 442? or didn't bother with it?
21:26:03 <edwardk> dons: we were stumbling around looking for an op, with you presumed asleep and shapr gone, was kinda weird ;)
21:26:14 <dons> eating sushi in the sun
21:26:24 <Cale> NoGoodNik: I didn't take any CS past 241, being in PMath.
21:26:34 <NoGoodNik> good job :-)
21:26:39 <dfranke> for what uni are these course numbers?
21:26:55 <edwardk> yeah, kinda wondering the same, course #'s are far from universal ;)
21:27:01 <NoGoodNik> University of Waterloo
21:27:08 <sellout> Oooh, Waterloo.
21:27:16 <dibblego> dons asleep? at GMT+10?
21:27:39 <edwardk> why do i always think of bill and ted's excellent adventure when someone mentions waterloo? =)
21:28:12 <NoGoodNik> heh, I remember somebody asking me what university I was from, I said "Waterloo" they were like "Oooh Waterloo!!" I was like "yeah! heard of it?!" they were like "no!" ...
21:28:14 <edwardk> dib: kinda fuzzy on the whole aussie timing thing
21:28:30 <dons> it's like your time, only tomorrow
21:28:32 <dibblego> edwardk, 1428 here mate (east coast)
21:28:35 <edwardk> dons: heh
21:28:36 <sellout> I didn't hear about it until I started at Amazon ... it's where a lot of our top people come from.
21:29:06 <NoGoodNik> a classmate of mine just started there a month ago
21:29:06 <Cale> NoGoodNik: haha
21:29:13 <edwardk> ok, so now +3 hours swapping am & pm =)
21:29:15 <NoGoodNik> another is finishing up his internship
21:29:22 <sellout> Better hire/candidate rate than MIT.
21:29:22 <Cale> NoGoodNik: What mathematics courses have you taken?
21:29:38 <Cale> and what's 442 anyway?
21:29:39 <NoGoodNik> uh ......... Calc 3 for Enigneers?
21:29:47 <NoGoodNik> 442 is intro to PLs
21:29:47 <sellout> NoGoodNik: Is the intern guy Kevin?
21:29:51 <Cale> ah, okay
21:29:59 <NoGoodNik> sellout, Anton
21:30:14 <sellout> Don't know him. Who was the one who just started?
21:30:19 <Cale> I was slightly involved with that course, helping some people with the Haskell parts at a few points :)
21:30:24 <NoGoodNik> Cale, there were few choices in th eng faculty
21:30:40 <NoGoodNik> Cale, by the time I got to it, there wasn't any Haskell in it
21:30:42 <NoGoodNik> not directly
21:30:45 <Cale> NoGoodNik: right, you said you were Soft Eng
21:30:47 <NoGoodNik> we still went over lazyness
21:30:48 <lispy> dons: it would appear that multiline strings are not compatible with -cpp
21:30:55 <Cale> Odd
21:30:58 <dons> right, you have to add an extra ' ' to the line
21:31:06 <dons> or use cpphs :)
21:31:08 <Cale> I think they should use Haskell for the initial programming courses
21:31:26 <NoGoodNik> sellout, John
21:31:28 <lispy> dons: how do you add the extra ' '?
21:31:35 <edwardk> lispy: makes sense, coz if it uses the real C preprocessor, that doesn't ike them
21:31:37 <int-e> after the \
21:31:39 <Cale> Of course, that would make using other languages for the later courses a painful experience for the students, but whatever :)
21:31:44 <NoGoodNik> Cale, hahahaha sure :-)
21:31:47 <lispy> dons: better yet, is there a way to turn off -cpp per source file?
21:31:52 <sellout> Hrmm, I¬† know a John from Waterloo, but he started like two years ago ... or was it one?
21:31:56 <Cale> NoGoodNik: It really is decent as a first language
21:32:15 <Cale> NoGoodNik: I helped teach Haskell to some elementary school kids
21:32:17 <NoGoodNik> I'd understand Scheme or Python, but why Haskell
21:32:20 <Cale> and it worked well :)
21:32:30 <sellout> Why Python?
21:32:33 <NoGoodNik> maybe the type system is not necessary in the very beginning
21:32:34 <dfranke> Cale: IMACS program?
21:32:35 <jrmole> Cale, how well did they understand types?
21:32:41 <sellout> I understand Scheme or Haskell ;)
21:32:41 <Cale> jrmole: well enough
21:32:47 <edwardk> nogoodnik: haskell gets you into a lot of good habits
21:32:55 <Cale> jrmole: We even got them using monads to some extent
21:32:59 <edwardk> nice
21:33:01 <jrmole> cool
21:33:17 <jrmole> i wish i'd learned Haskell in elementary school
21:33:18 <Cale> Which is where my monads as containers article came about :)
21:33:31 <NoGoodNik> jrmole, me too ....
21:33:40 <edwardk> i'm going to start teaching my nephew haskell in the near future, coz he wants to learn to program
21:33:53 <edwardk> but he's in the ~6 year old range, so i have to start slow =)
21:33:54 <NoGoodNik> they should have separate schools for the weirdos who can't grep Monads
21:34:17 <Cale> NoGoodNik: have you seen my Monads as Containers article?
21:34:23 <edwardk> nogoodnik: they do, they send people to them on 'the short bus' =)
21:34:25 <NoGoodNik> probably not
21:34:26 <Cale> @wiki Monads_as_Containers
21:34:27 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
21:34:30 <NoGoodNik> unless it was pasted here since I joined
21:34:40 <Cale> read it, and probably monads will make more sense :)
21:34:54 <NoGoodNik> I'll add it to my queue :-P
21:34:54 <edwardk> cale and his boxes of boxes of apples.
21:34:59 <Cale> and it recommends some other stuff from there :)
21:35:04 <Cale> hehe
21:35:12 <Cale> edwardk: it works well though :)
21:35:27 <edwardk> i'll just start calling you johnny appleseed ;)
21:35:29 * int-e wonders if giving Monads a less scary name would help.
21:35:40 <edwardk> yeah
21:35:46 <NoGoodNik> yeah, WarmFuzzyThings
21:35:51 <dfranke> int-e: nuclear waste containers?
21:35:55 <dfranke> int-e: or is that more scary?
21:35:56 <Cale> Probably not too much, we just need to make sure that people don't mention that they're scary.
21:35:59 <sellout> edwardk: That's when I¬†started learning to program, kind of ... my Dad taught me the material for his BASIC class, to reinforce the lesson in himself.
21:36:05 <edwardk> You wrap this object up in this 'fuzzy blanket' and then you pass it to this other function...
21:36:13 <int-e> once you've mentioned Monads and Category Theory, half of your audience has probably already given up.
21:36:21 <Cale> There's been a stigma about them since the early times when they were less well-understood.
21:36:27 <NoGoodNik> sellout, is there a PL interest group in Seattle?
21:36:49 <Cale> People don't need to know that monads have anything to do with category theory to use them in programming :)
21:36:55 <edwardk> sellout: yeah, i learned from my uncle when i was 5-6, and then from there on my own.
21:37:05 <sellout> NoGoodNik: There's SeaFunc ... "Get out of your C funk and into SeaFunc. It's Seattle, it's Functional ..." something like that.
21:37:09 <sellout> Meeting tomorrow.
21:37:15 <int-e> Cale: right.
21:37:18 <NoGoodNik> hah
21:37:48 <sellout> But definitely Haskelites there.
21:37:59 <Cale> heh, "adjoint functors!" "natural transformations!"
21:38:01 <sellout> Lisp is probably dominant, though, and some O'Caml guys.
21:38:07 <Cale> and all that :)
21:38:25 <edwardk> cale: they are great ways to scare off people.
21:39:06 <NoGoodNik> I think we need more abstract math taught earlier in schools. That'll make it easier to get people into Monads later.
21:39:24 <dfranke> NoGoodNik: well, part of the "new math" movement was to teach set theory before arithmetic.
21:39:27 <lispy> dons: i tried to add that space, but i get all these warnings about backslash and then it doesn't work anyway (still get the lexical error)
21:39:35 <dfranke> NoGoodNik: I'd like to see them try to substitute category theory.
21:39:36 <jrmole> or any FP, for that matter
21:39:46 <dons> bad cpp
21:40:03 <edwardk> dfranke: hehehe
21:40:03 <lispy> yeah, so what i really need is to turn off -cpp for this one file
21:40:12 <int-e> dfranke: I'm not sure I agree. What good is category theory without an arsenal of examples to make sense of it?
21:40:13 <NoGoodNik> how did new math go?
21:40:19 <edwardk> dfranke: category theory isn't all that hard, its just so alien by the time you get to it
21:40:36 <dfranke> int-e: I was being sarcastic.
21:41:19 <NoGoodNik> I did grade 6 in US, we covered sets at that time, it rocked
21:41:44 <NoGoodNik> probably went over easier than when we covered them again in Canada in high school or first year university
21:42:06 <dfranke> dunno, I actually got a proper math education.  I slipped through after new math and before the present new new math.
21:42:16 <edwardk> you build up all of this complicated machinery for reasoning, then you throw it all away, tie your hands behind your back and try to chase objects around a diagram with your nose. ;)
21:43:08 <NoGoodNik> dfranke, I must have totally missed on the proper part
21:43:16 <Cale> NoGoodNik: don't get me started on the deficiency of the pre-university mathematics curriculum.
21:43:26 <edwardk> i got fucked over pretty badly by my mathematical education and mostly picked things up later on my own.
21:43:33 <musasabi> edwardk: THash question. There is one top-level TVar. All transactions read (and mutating ones write it) - doesn't that become a bottleneck?
21:43:40 <NoGoodNik> hehe, coming from PMath you must have some pointed things to say :-)
21:43:45 <int-e> learning rules instead of understanding them, that's my biggest complaint.
21:44:00 <Cale> It's so terrible, and it could be so good.
21:44:12 <edwardk> musasabi: thats probably an issue.
21:44:18 <Cale> NoGoodNik: Have you seen Spivak's "Calculus"?
21:44:20 <NoGoodNik> A pattern that repeats itself in so many things.
21:44:26 <musasabi> Have you seen Thomas Conway's STM tree code?
21:44:27 <NoGoodNik> Spivak?
21:44:34 <Cale> NoGoodNik: Michael Spivak
21:44:36 <edwardk> musasabi: in my case i was designing it so i could have lots of these and update different ones across the system at the same time
21:44:41 <edwardk> musasabi: think javascript hashes
21:44:49 <Cale> They use it for the advanced section Calc 1-2 courses
21:44:55 <edwardk> musasabi: so for my usage pattern, not a problem. for yours? maybe =)
21:45:05 <NoGoodNik> Cale, no ...
21:45:09 <Cale> I really highly recommend picking up a copy of it and reading it
21:45:14 <NoGoodNik> we had 'Calculus for Engineers'
21:45:16 <Cale> especially as an engineer :)
21:45:22 <NoGoodNik> which was an abomination.
21:45:28 <Cale> yes, it's terrible
21:45:46 <dfranke> as a general rule "a for b majors" always sucks if a != b.
21:46:06 <NoGoodNik> you know what's worse than Calculus for Engineers though? Quantum Mechanics for Engineers.
21:46:10 <int-e> 'for engineers' - that sounds like making the same mistake again, give recipes, give rules to learn. maybe add one or two proofs to spice it up.
21:46:10 <Cale> My friend Adeel was in engineering for his first year. He failed Calc 1 for engineers. He transfered into honours math, and went from 30% to 90% :)
21:46:12 <edwardk> dfranke: hehehe
21:46:15 * sellout liked DSP for Engineers and Scientists ...
21:46:22 <Cale> Because things actually made sense :)
21:46:25 <sellout> or Scientists and Engineers.
21:46:52 <int-e> (so engineers are scared away from 'real' math)
21:46:57 <Cale> He graduated with a pure/applied math double major, and is now working on his PhD.
21:47:15 <sellout> It's particularly bad when b = Dummies.
21:47:17 <edwardk> the problem is the 'for engineers' calculus classes are usually taught BY engineers, who never made it to real analysis and never really got around to understanding the underpinnings of calculus ;)
21:47:17 <Cale> The point is that math doesn't get easier when you water it down.
21:47:41 <NoGoodNik> edwardk, in my case actually the calc for eng profs were really good ... they just took a crappy approach to it.
21:47:54 <Cale> By removing the proofs and the good examples, you're essentially removing all of the explanations, and taking something which is perfectly logical and mangling it.
21:48:00 <NoGoodNik> they had to use the texts they were given too.
21:48:09 <Cale> NoGoodNik: Seriously, pick up Spivak :)
21:48:15 <edwardk> Though, I guess I really like knowing the why's. For instance, I would just as soon have had real analysis before calc III.
21:48:31 <Cale> NoGoodNik: even if you don't care much about Calculus, you'll probably have fun with it.
21:48:35 <int-e> Cale: and that forms the public image of math.
21:48:39 <Cale> int-e: indeed
21:48:41 <dfranke> I'm taking real analysis this semester and my prof doesn't understand set theory.  That's REALLY annoying.
21:48:45 <NoGoodNik> uhm, I really don't care much for Calculus.
21:48:47 <edwardk> dfranke: ouch
21:48:55 <NoGoodNik> I'd rather pick up a text on Category Theory or something like that
21:49:26 <Cale> NoGoodNik: Well, it's a good introduction to mathematics in general. I often still pick it up and read it just to see the way in which he approaches things.
21:49:34 <dfranke> He taught an introductory unit on countable versus uncountable sets, and kept on confusing the notions of ordinal and cardinals numbers.
21:49:35 <Cale> and the problems are decent :)
21:49:48 <NoGoodNik> ok, perhaps. when I'm done with everything else :-)
21:50:00 <edwardk> nogoodnik: calculus/real analysis exists as a good arena to explore set theory and the consequences of the axiom of choice, etc. once you get to the higher parts of mathematics you always have it there to reference back to for a concrete example of where things can go wrong, etc.
21:50:02 <dfranke> I kept asking for clarification as to which he was talking about and kept getting incoherent answers.
21:50:19 <Cale> NoGoodNik: Here's a good example of what a Calc 1 assignment problem looks like in the advanced section:
21:50:36 <NoGoodNik> oh no :-)
21:51:01 <Cale> Prove that if f is integrable on [a,b], then for any e > 0 there are continuous functions g <= f <= h with (integral from a to b of f) - (integral from a to b of g) < e.
21:51:22 <Cale> I only had to do 8 symbolic integrals (that weren't polynomials) in my entire undergrad.
21:51:30 <dfranke> and then instead of defining the reals in terms of Cauchy sequences, he just assumed the existence of the reals and defined Cauchy sequences in terms of them.
21:51:31 <edwardk> dfranke: i had a prof like that for fourier analysis (and also had him for real analysis in the same semester for that matter)
21:51:35 <Cale> One of them was integral of sec^5 x
21:51:51 <Cale> I think the basic point was to teach us to hate symbolic integration
21:52:03 <Cale> Without wasting too much time on it :)
21:52:26 <NoGoodNik> hmm :-)
21:53:12 <Cale> According to mathematica, that integral is (-6*Log[Cos[x/2] - Sin[x/2]] + 6*Log[Cos[x/2] + Sin[x/2]] + (7 + 3*Cos[2*x])*Sec[x]^3*Tan[x])/16
21:53:15 <edwardk> cale: nice. my undergrad was rather more like grunt work for the first half. integrate this, now this over there, and that, and the other thing. ;)
21:53:40 <Cale> They did give us some pretty cool definite integrals to do
21:53:56 <NoGoodNik> see, although math for engineers was bad, it was physics for engineers that made me switch programs. so math isn't getting the shortest end of the stick.
21:54:22 <Cale> one of my favourites is to integrate the function f such that f(x) = 0 if x is irrational, and f(p/q) = 1/q if p/q is a rational number in lowest terms, over the interval [0,1]
21:54:27 <edwardk> i lived a physics-free existence on college.
21:54:37 <dfranke> I did terribly in Calc III because I had really laid-back professors for I and II and then an incredibly demanding one for III.
21:55:06 <Cale> In order to alleviate any sense of suspense, the integral of this function is 0.
21:55:16 <Cale> But it's nonzero at infinitely many points.
21:55:18 <Cale> :)
21:55:20 <edwardk> heh yeah
21:55:27 <lispy> so how do you put GHC_OPTIONS into a .lhs latex file?
21:55:34 <edwardk> countably many though
21:55:37 <Cale> yeah
21:55:46 <lispy> % {-# OPTIONS_GHC -cpp #-}
21:55:53 <lispy> is that how you do it?
21:56:00 <dfranke> Cale: yeah, that's not much different from Dirichlet's function.
21:56:12 <Cale> dfranke: It is Dirichlet's function :)
21:56:12 <edwardk> more fun to use cantor's dust ;)
21:56:17 <edwardk> heh
21:56:28 <lispy> oh, i see, first non-empty, non-literate line
21:57:05 <araujo> yay!
21:57:06 <NoGoodNik> man, I need a bigger screen to let IRC scroll on the side next to my real work.
21:57:13 * araujo got it worked and jumps around
21:58:59 <dfranke> Cale: I've learned Dirichlet's function as just 0 if irrational, 1 if rational.
21:59:37 <Cale> dfranke: I usually call that the characteristic function of the rationals, but perhaps it's also attriuted to Dirichlet.
22:01:46 <edwardk> http://mathworld.wolfram.com/DirichletFunction.html gives both versions
22:01:49 <lambdabot> Title: Dirichlet Function -- from Wolfram MathWorld, http://tinyurl.com/ff2o3
22:02:16 <NoGoodNik> Mathematica is somewhat awe inspiring
22:08:23 <glguy_> Does anyone know the programming problems site where you submit your code and it compiles and tests it. this site supports haskell submissions
22:09:02 <sjanssen> glguy_: http://www.spoj.pl ?
22:09:08 <lambdabot> Title: Sphere Online Judge (SPOJ)
22:09:13 <glguy_> yeah
22:09:13 <glguy_> that
22:09:25 <glguy_> thanks :)
22:11:48 <deadbeef> wondering where it compiles/runs it
22:11:59 <deadbeef> maybe it's a chroot
22:12:07 <dottedmag> nemerle in chroot?
22:12:22 <NoGoodNik> in a VM hopefully, if they alow you to run C
22:12:54 <dottedmag> AFAIR, acm.uva.es just compiles C code with cut-down standard library.
22:13:06 <dottedmag> To avoid OS access.
22:13:18 <deadbeef> you could embed asm code
22:13:44 <dottedmag> That's interesting. Worth checking. Probably they also check for asm inlines :)
22:13:56 <edwardk> dotted: not exactly secure, considering you could jump into an array of assembled code
22:14:04 <NoGoodNik> it doesn't have to be asm, could be a binary array
22:14:08 <sjanssen> dottedmag: I believe SPOJ's security measures are at the OS level, a chroot or some such
22:14:13 <deadbeef> ok, you could save opcodes of asm instructions in a buffer and then jump to that buffer like it's a function
22:14:24 <deadbeef> yes
22:14:49 <NoGoodNik> does chroot protect against privelege escalation attacks?
22:14:58 <deadbeef> it should
22:15:09 <Korollary> It could be a virtual host.
22:15:44 <NoGoodNik> "a (hopefully) exploit-secure online judge program" ...
22:15:58 <deadbeef> lol
22:16:24 <deadbeef> so what if you create a binary array, cast it like a function and call it ?
22:16:51 <lispy> deadbeef: better start using C :)
22:17:11 <sjanssen> lispy: I bet we could do that in Haskell too
22:17:19 <deadbeef> with a monad ?
22:17:39 <NoGoodNik> heh, is there anything these mythical monads can't do?
22:17:48 <deadbeef> dunno
22:17:52 <deadbeef> i don't even know what a monad is
22:17:55 <deadbeef> but it sound good
22:18:03 <deadbeef> "how to xxx ?"
22:18:05 <deadbeef> "use a monad."
22:18:15 <Korollary> well, it's not quite the silver bullet.
22:18:21 <deadbeef> d'oh
22:18:22 <NoGoodNik> between me and you we are some haskellites.
22:19:17 <edwardk> kor: yes it is, don't crush their spirits, just yet. let them learn what a monad IS, then tell them it won't solve everything. ;)
22:19:23 <Korollary> heh
22:19:30 <Korollary> It is weird.
22:19:59 <lispy> a monad is like a butterfly
22:20:05 <lispy> but without the wings
22:20:11 <lispy> or the antenni
22:20:20 <lispy> no larval stage either
22:20:26 <NoGoodNik> you're mocking us newbies, aren't you
22:20:29 <lispy> in fact...never mind...
22:20:45 <NoGoodNik> it's boxes of boxes of apples, don't confuse me
22:20:51 <lispy> the haskellers get a lot of flak for monads being confusing
22:20:51 <Korollary> heh
22:21:08 <int-e> right, and join takes the boxes of boxes and fills all these boxes into one big box
22:21:11 <int-e> there you go.
22:21:22 <NoGoodNik> gotcha
22:21:29 <lispy> and bind takes an apple out of one box and puts it in the next
22:21:33 <deadbeef> http://www.kheper.net/topics/Theosophy/monad.gif
22:21:47 <jrmole> A monad is a snowmobile racing across the tundra and then suddenly it flips over, pinning you underneath. At night, the ice weasels come.
22:21:56 <foxy> NoGoodNik, try implementing a state-passing monad, good way of understanding it
22:21:56 <lispy> heeh
22:22:06 <lispy> jrmole: that's a matt groening quote!
22:22:09 <NoGoodNik> foxy, soon enough :-)
22:22:10 <lispy> jrmole: but he was talking about lone
22:22:11 <Korollary> A monad is what makes you say "That's it?" after you finally grokked it.
22:22:12 <lispy> er love
22:22:16 <jrmole> lispy, indeed
22:22:39 <NoGoodNik> Korollary, a lot of things are like that
22:22:45 <foxy> You really should read Leibniz to understand Monads
22:22:51 * Korollary is taking recommendations for classical music cd's, especially piano pieces.
22:23:11 <lispy> Korollary: Wesely Willis
22:23:26 <lispy> Korollary: technically he played a keyboard, but pretty close
22:23:42 <int-e> Actually I never understood monads before I asked myself what you could do with return and bind alone ... which is very little. you can implement pure functions and wrap them in a monad, and never get them back again. Big deal.
22:23:54 <Korollary> "Wesley Willis was a schizophrenic street singer who built up a small cult following with his bizarre, three-chord rants about trivial everyday items, music, and people he knew." This guy?
22:24:04 <jrmole> Wesley Willis may be safely said to be the exact opposite of classical music
22:24:13 <lispy> Korollary: that guy is awesome
22:24:37 * lispy is a huge fan of "The Vultures ate my dead ass up"
22:24:45 <int-e> So what is it that makes them useful? It's not return, it's not bind. Every monad comes with some additional operations that you can sequence using bind and return. bind and return is just the glue. And this glue has a name, it's called a Monad.
22:25:14 <glguy_> I rarely do IO... could someone remind me of a clean way to turn "1 2" into [1,2]?
22:25:49 <NoGoodNik> hey Haskell is #7 on that problems site
22:25:57 <Korollary> glguy_: something like map read . words ?
22:26:06 <lispy> interesting, i came to the conclusion that bind was the thing that makes monads so useful...in different monads bind means something else and that's what gives it power...the sort of power that writes bytes to an array and then jumps the instruction pointer te the beginning of the array...
22:26:10 <glguy_> yeah, words!
22:26:11 <foxy> > map read $ words "1 2"
22:26:12 <glguy_> duh
22:26:13 <lambdabot>  Add a type signature
22:26:25 <foxy> map read $ words "1 2" :: [Integer]
22:26:35 <glguy_> yeah yeah, I just needed words
22:26:41 <glguy_> It's late :)
22:27:24 <NoGoodNik> does it make sense to use two monads at the same time? is that possible?
22:27:27 <int-e> lispy: I associate that power with the actual primitives that do this stuff.
22:27:28 <Korollary> I am not sure what makes anything useful. My observation is that bind, return and what is implied by monad laws exists in a lot of computations, and monads are one way of capturing the commonality.
22:27:29 <sjanssen> > (map read $ words "1 2") `asTypeOf` [1]
22:27:30 <lambdabot>  [1,2]
22:27:31 <lispy> > fmap read $ words "1 2" :: [Integer]
22:27:31 <jrmole> NoGoodNik, look up monad transformers
22:27:32 <lambdabot>  [1,2]
22:27:36 <NoGoodNik> k
22:27:40 <jrmole> requires a bit of trickery though
22:27:51 <int-e> lispy: otherwise bind seems to be too magical and it really isn't, in most monads.
22:28:11 <lispy> int-e: yeah and Korollary just made a good point
22:28:14 <jrmole> yeah, bind/return are usually very obvious
22:28:31 <foxy> don't forget fail
22:28:34 <lispy> i wouldn't say obvious so much as very logical
22:28:53 <jrmole> true
22:29:23 <lispy> it's a bad sign when i have to switch back to old glasses to do a lot of reading...
22:30:21 <jrmole> NoGoodNik, if you want to combine monads, http://www.nomaware.com/monads/html/introIII.html is a good place to start
22:30:23 <lambdabot> Title: Part III - Introduction, http://tinyurl.com/pw6k8
22:30:43 <dottedmag> Introduction is part3??
22:30:51 <glguy_> I know that I'm tired... not only did I forget "words" I didn't even remember to @hoogle String -> [a]
22:30:51 <jrmole> introduction to part 3
22:30:59 <NoGoodNik> part 3 of the introduction?
22:31:01 <jrmole> which is monad transformers
22:31:09 <lispy> @hoogle String -> [a]
22:31:10 <lambdabot> No matches, try a more general search
22:31:19 <glguy_> oh
22:31:23 <lispy> glguy_: yeah, too bad you forgot...
22:31:23 <jrmole> @hoogle String -> [String]
22:31:24 <glguy_> String -> [String]
22:31:25 <lambdabot> Prelude.lines :: String -> [String]
22:31:25 <lambdabot> Prelude.words :: String -> [String]
22:31:25 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
22:31:33 <lispy> :)
22:31:36 <glguy_> I caught it :-p
22:31:48 <glguy_> Now I know I'm *really* tired
22:31:52 <jrmole> so by "more general" it meant "less general" ;)
22:32:04 <lispy> heh
22:32:14 <jrmole> or i guess it's kinda contravariant
22:32:17 <lispy> that reminds me of ben stiller in mysterymen when gets mad at the sphinx
22:32:33 <glguy_> what's bogging spoj.pl down??
22:32:35 <glguy_> shesh
22:32:37 <Korollary> you are
22:32:42 <glguy_> heh
22:34:55 <NoGoodNik> in haskell and in ml function names are share the namespace and that's why the often get prefixes, right? I like how in OO languages each type gets its own 'namespace' for its methods.
22:35:07 <glguy_> Haskell has namespaces
22:35:30 <glguy_> "modules" if I'm not too tired to be correct
22:36:49 <NoGoodNik> do they have to be selected or opened into the current space? in the common languages the 'class namespace' is inferred from the type of the type of the zeroeth parameter
22:37:48 <jrmole> NoGoodNik, it's all static in Haskell
22:37:51 <jrmole> you can import modules
22:38:00 <NoGoodNik> there it can be static too
22:38:24 <NoGoodNik> in Haskell, can two classes have methods with the same name?
22:38:34 <jrmole> NoGoodNik, if so, they can't both be imported at once
22:38:50 <araujo> NoGoodNik, What is the point of that?
22:38:55 <jrmole> this is somewhat of a sore spot, and there are periodic discussions about fixing it
22:39:15 <araujo> You only need to overload methods functionalities on instances.
22:39:23 <araujo> Which you can do with Haskell
22:39:37 <jrmole> araujo, what if you and i both decide to use the same name?
22:39:50 <jrmole> it's nice for method names to be simple
22:39:58 <NoGoodNik> araujo, I guess the canonical example is a gun class and a shape class that both have the method draw
22:40:13 <jrmole> NoGoodNik, you can import a module qualified
22:40:32 <jrmole> import qualified Foo.Bar.Baz as B
22:40:35 <NoGoodNik> so one will have to be used with a prefix or something like that? oh well.
22:40:39 <jrmole> from there on you can use B.function
22:40:47 <jrmole> yeah, but you can locally declare a shorter prefix
22:41:08 <jrmole> it's a clean ad-hoc solution to the problem, at least
22:41:21 <araujo> jrmole, uh? .. i am refering to his comments about two methods with the same name inside a 'class'
22:41:43 <NoGoodNik> araujo, I meand two methods with same name in different classes
22:41:59 <jrmole> the draw example is good :)
22:42:27 <Korollary> it's the poster child example for duck typing opponents.
22:43:04 <jrmole> i want a world where all ducks have "DUCK" painted on the side
22:43:07 <NoGoodNik> I dunno if it's a big enough issue to hurt duck typing but I'd rather not clutter my source with needless prefixes.
22:43:18 <araujo> NoGoodNik, if you don't do that through the inheritance model of the class system, you would practically be breaking the main idea.
22:43:31 <araujo> Which, as i stated before, it doesn't make sense.
22:44:01 <jrmole> NoGoodNik, it's sometimes nice to have the annotations anyway... in code which mixes Data.Map and Data.Set, you want it to be clear whether singleton refers to a singleton map or set
22:44:03 <NoGoodNik> araujo, I don't understand that.
22:44:08 <jrmole> though that case doesn't even deal with classes
22:45:36 <araujo> NoGoodNik, The main idea of the concept of 'classes' is supposed to be 'code-reusing' .. and you are saying about having two methods with the same name in two different classes.
22:46:06 <araujo> Just declare the name from a top class, and inherite/specialize over instances (through sub-classes if you like)
22:46:21 <NoGoodNik> the meanings could be very different. the names may match by accident or by ambiguity in implementer's native tongue
22:46:31 <araujo> that's what polymorphism is all about. And.. you can do that on Haskell.
22:47:16 <jrmole> araujo, just suppose i wrote a class for things which can be put on the screen, and had a method called draw
22:47:27 <jrmole> and you wrote a class for things which can be removed from a hoster, and had a method called draw
22:47:35 <jrmole> there's no common functionality, it's just a linguistic accident
22:47:56 <jrmole> but it's kinda annoying that one can't import both of these at once, without a qualifier
22:48:02 <araujo> it shouldn't be a problem for a proper class system.
22:48:05 <jrmole> though i maintain that the qualifier is not that big of a deal
22:48:15 <jrmole> araujo, it shouldn't be a problem that people think of similar names for stuff?
22:48:33 <araujo> The method that will be invoked is the one belonging to the instance.
22:48:46 <araujo> The right method should be called from a technical point of view.
22:48:47 <NoGoodNik> coming from a place where such qualifiers were usually not needed, it is a slight sore
22:49:07 <jrmole> araujo, that's not how it works in Haskell
22:49:07 <araujo> jrmole, That's precisely the point of polymorphism. To help with that issue.
22:49:12 <jrmole> whoops
22:49:59 * araujo is refering in this case to OO languages
22:50:46 <araujo> In Haskell, we deal with it using type classes+modules
22:51:38 <araujo> NoGoodNik, So, you could think about a Haskell module as an object with a name-space and such
22:52:31 <NoGoodNik> but in C++, C#, and Java the member names don't conflict, and in Haskell I'm being told they can and prefixes may be necessary
22:52:50 <jrmole> in java, what happens if you try to implement two interfaces which each define a method with the same name?
22:53:14 <NoGoodNik> dunno, I'm rusty in my Java :-) I know about C# though ...
22:53:31 <jrmole> araujo, class Foo1 a where { foo :: a }; class Foo2 a where { foo :: a -> a }
22:53:38 <wilx> Well, guess what, Haskell is not C++ or Java :)
22:53:46 <araujo> amen
22:53:50 <jrmole> even if those are in different modules, you can't import both of those modules without qualifying one
22:53:53 <Korollary> In Java you have to annotate the types explicitly anyways
22:53:54 <dibblego> jrmole, nothing
22:54:02 <NoGoodNik> wilx, well, I want it to be at least as good or better in all respects :-)
22:54:19 <araujo> jrmole, yup, qualifying is pretty much a valid module technique
22:54:26 <dibblego> jrmole, unless the methods have different return types
22:54:30 <wilx> Import as qualified module is the best what you can do here.
22:54:36 <araujo> which i like i gotta say
22:54:44 <jrmole> yeah, it's very simple
22:55:12 <jrmole> it just sounded like you were trying to say you should never have to qualify methods unless you're using typeclasses "wrong"
22:55:23 <jrmole> which is just not true, unless you can get the entire world to agree on who can use what names ;)
22:55:27 <Pseudonym> Yikes!
22:55:31 <Pseudonym> Errr...
22:55:39 <araujo> jrmole, no :-|
22:55:45 <Pseudonym> Hmmm.
22:56:05 <jrmole> fortunately the "qualifying" mechanism discourages ugly ad-hoc namespaces where people slam a couple random characters in front of all their exported symbol names
22:56:25 <NoGoodNik> :-)
22:56:30 <jrmole> in haskell it's even considered fine module ettiquite to name things after prelude symbols with similar functionality
22:56:52 <NoGoodNik> and just rely on people to use prefixes?
22:57:09 <araujo> I think qualifying is nice ... it makes the code easier to read imho
22:57:15 <NoGoodNik> it's odd that so much of the typing is inferred but in this manner there is a step back :-)
22:57:29 <NoGoodNik> some people claim that about explicit static typing as well
22:57:29 <dolio> In Java, all your functions are qualified by object names (or implicitly by the enclosing object). Qualifying with modules isn't that bad, is it?
22:57:37 <jrmole> yes, e.g. "This module is intended to be imported qualified, to avoid name clashes with Prelude functions." -- Data.Map documentation
22:57:58 <jrmole> i don't think this is a step back -- the whole point of typeclasses was to avoid ad-hoc polymorphism
22:58:00 <NoGoodNik> dolio, they can be implicitly qualified by the type of the variable on which the method is being invoked.
22:58:59 * araujo gotta be up within 3hrs
22:59:03 <jrmole> if you're going to allow ad-hoc resolution of typeclass method conflicts, you might as well drop the typeclass system
22:59:17 <NoGoodNik> uh really?
22:59:23 <Korollary> No
22:59:52 <Cale> dons! Mentioning C++ increases C's karma!
22:59:53 <jrmole> what if i use an ad-hoc-overloaded method in a function of polymorphic argument type?
23:00:10 <Korollary> This is something that can be a feature request. However, not many (perhaps any?) people have been bothered by it yet.
23:00:35 <jrmole> Korollary, imo it destroys a lot of the purity of the typeclass system
23:00:54 <Korollary> jrmole: If there is ambiguity, the compiler can force you to annotate, which it does already for some other things.
23:01:03 * araujo off to bed
23:01:04 <araujo> night
23:01:33 <jrmole> it will still cause fewer errors to be caught by the typechecker
23:01:55 <jrmole> because you might miscode something such that the wrong method is used, but unambiguously
23:02:31 <NoGoodNik> then the whole thing gets a type inferred wrong, and is likely to get caught further up, no?
23:02:44 <Korollary> Not necessarily
23:02:51 <jrmole> depending on the type of the class method, maybe not
23:03:05 <NoGoodNik> ok, I think I see
23:03:51 <jrmole> even if it's caught further up, the error message will be less useful
23:04:29 <NoGoodNik> are GHC error messages typically very useful?
23:04:35 <jrmole> and haskell type errors are pretty befuddling already
23:04:54 <jrmole> NoGoodNik, learning to interpret them is a major part of the Haskell learning curve
23:04:58 <NoGoodNik> so far the only one I've seen was No instance for (Show (a -> a))
23:05:20 <NoGoodNik> I heard there was a type debugger somewhere for some language or other :-)
23:05:38 <jrmole> a good way to track down type errors is to use :t in GHCi / Hugs
23:05:49 <jrmole> to examine smaller chunks of your expressions
23:06:29 <NoGoodNik> ooh nifty
23:06:36 <jrmole> i'm often annoyed by the fact that i can't have ghci enter the environment of a let or where clause, though
23:07:56 <Cale> NoGoodNik: I've had very deep algorithmic bugs caught by the type system
23:08:16 <Cale> They're usually pretty informative, sometimes you can spend a while figuring out exactly what's causing them.
23:08:16 <jrmole> yeah, i generally assume that haskell's type system is smarter than i am
23:08:43 <NoGoodNik> I'm surprised by how strong the parallels are to interfaces and classes
23:08:57 <jrmole> NoGoodNik, they're very similar indeed
23:09:12 <NoGoodNik> then what makes Haskell's type system so much better :-)
23:09:41 <jrmole> NoGoodNik, it encourages the use of very expressive types
23:09:46 <NoGoodNik> I'm not at all arguing that it's not, I'm just curious about what makes it special
23:09:54 <jrmole> which will allow the typechecker to find more of your erros
23:12:08 <jrmole> also, note that typeclasses are not the "core" of Haskell's type system, merely what distinguishes it from other languages like ML
23:12:14 <kowey> NoGoodNik: one useful difference between Java interfaces and typeclasses is that you can define your instances separately from the 'objects'
23:12:36 <falconair> while googling for 'relational algebra' and 'haskell', i keep coming across 'relation algebra' with stuff about category theory, is this relation algebra different from the relational algebra of databases?
23:13:19 <dblhelix> the problem with category theory is that it's not different from anything
23:13:53 <jrmole> NoGoodNik, algebraic data types (especially parametrized over other types) are a large part of why Haskell's type system is cool
23:13:53 <NoGoodNik> kowey, is this the separation between data definitions and class instance definitions?
23:14:22 <NoGoodNik> what exactly are algebraic data types? the ones defined by the 'data' keyword?
23:14:25 <jrmole> yes
23:14:33 <kowey> NoGoodNik: uhh... yes... in the sense that you don't have to say that your Java class implements an interface when you're defining it
23:14:43 <jrmole> you can define things like lists and binary trees for arbitrary element types in one line
23:14:54 <falconair> dblhelix,  so is relation algebra category theory view of relational algebra, or is it something else entirely?
23:15:01 <jrmole> then pattern-match against their structure in function definitions, so you get your accessors and such in a couple more lines
23:15:21 <kowey> less red tape, Haskell
23:15:24 <dblhelix> falconair: afik, something completely different
23:15:26 <jrmole> and it's all typesafe, unlike doing the same thing with pointers in C
23:15:44 <NoGoodNik> C is a straw man
23:15:54 <jrmole> i know, unfortunately it's a very popular straw man
23:16:16 <jrmole> i mean, it's popular as a language, not just for burning
23:16:22 <NoGoodNik> haha
23:16:33 <dblhelix> falconair: relation algebra is an extension of boolean algebra
23:16:47 <dblhelix> falconair: it studies binary relations
23:16:55 <NoGoodNik> most people I come accross it like it just fine and have no desire to burn it ...
23:17:03 <jrmole> well, C is fine as a portable assembler
23:17:23 <jrmole> but people don't realize that portability hasn't made a language high-level since the 70's
23:17:40 <jrmole> i still hear "C is a high-level language" all the time
23:17:58 <NoGoodNik> now, doesn't C++ make a better portable assembler?
23:18:08 <int-e> @quote int-e
23:18:09 <lambdabot>  PHP is a programming language like penguins are birds. And people try to make it fly.
23:18:12 <int-e> hmm
23:18:17 <int-e> who added that?
23:18:22 <jrmole> only if you want an object-oriented assembler
23:18:36 <jrmole> which i'd assume you usually don't
23:18:43 <NoGoodNik> beats procedural as far as I'm concerned
23:18:43 <falconair> dblhelix, what i am interested in is writing a small query engine in haskell (perhaps hook it up to monetdb for actually storing data)...i am specifically interested in how to decompose sql 'tables' into a set of binary relations automatically, is this something 'relation' algebra can help with?
23:18:55 <NoGoodNik> or whatever family C belongs to
23:18:55 <jrmole> NoGoodNik, sure, but you're not writing in  this language
23:19:00 <jrmole> you're writing a compiler which compiles to it
23:19:06 <dblhelix> falconair: I don't thinks so...
23:19:19 <NoGoodNik> ah, as an intermediate step in compilation ...
23:19:21 <jrmole> and if you're writing a compiler, you've probably already factored out all of the complex things in your language, and keeping the object system to that level is a little silly
23:19:30 <jrmole> NoGoodNik, this is what i meant by "portable assembler"
23:19:39 <NoGoodNik> don't people compile to Java or CLR VMs now? :-)
23:19:49 <jrmole> yeah
23:20:07 <jrmole> but people don't write much in JVM or CLR assembly language
23:20:16 <jrmole> and i personally think writing high-level code in C is about the same level
23:20:34 <NoGoodNik> hey now, at least C has variables.
23:20:37 <falconair> dblhelix, thanks, i need to continue my google quest
23:20:42 <dblhelix> falconair: have you ever had a look at daan leijen's dsel for database queries? there's a lot of relational algebra stuff there...
23:20:49 <jrmole> NoGoodNik, so does any symbolic assembler worth its salt
23:21:02 <jrmole> i'm not saying C isn't nicer to program in, just that it's not very nice to program in
23:21:12 <NoGoodNik> those VMs are stack based ...
23:21:37 <jrmole> indeed
23:22:39 <falconair> dblhelix, i have seen that, as far as i remember that system is not a query engine by itself...I started going through "Strong Types for Relational Data Stored in Databases or Spreadsheets,' this one looks closer to what i need...although the type class stuff is a bit complicated for me right now
23:22:47 <NoGoodNik> heh, many arguments can be reduced to a common bashing of C
23:23:14 <dblhelix> falconair: well, I'm pretty sure you'll manage... good luck...
23:23:34 <dblhelix> falconair: and---more importantly---have fun :)
23:23:43 <falconair> dblhelix: :) thanks
23:24:35 <dblhelix> @hoogle ap
23:24:36 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
23:24:36 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
23:24:36 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
23:25:09 <dblhelix> @type liftM2 ($)
23:25:12 <lambdabot> forall b a2 (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
23:25:28 <jrmole> NoGoodNik, well, i guess i kinda went on a rant there ;)
23:26:02 <NoGoodNik> it's just too easy to trash C, I admit
23:26:37 <jrmole> and oh so fun
23:26:41 <int-e> C is great.
23:28:52 <NoGoodNik> oh field names go into the global scope too ...
23:29:17 <dolio> I don't mind C. It feels very pure in it's paradigm.
23:29:31 <dolio> It's like the smalltalk of imperative languages.
23:29:37 <jrmole> NoGoodNik, that's pretty annoying too
23:30:03 <jrmole> there were some proposals on the list to fix that
23:30:11 <jrmole> but it's not clear how to do it without breaking stuff
23:30:41 <NoGoodNik> dolio, the minimalism of Smalltalk or Scheme put C to shame
23:31:04 <NoGoodNik> jrmole, people are concerned about source backward compatibility? :-)
23:31:14 <jrmole> NoGoodNik, yes
23:31:16 <jrmole> among other things
23:31:50 <jrmole> dolio, a more pure language would have dynamic memory management
23:32:02 <jrmole> since that essentially provides more abstraction and less visible system interface
23:32:52 <dolio> Nah. The thing about C is that everything is a library call.
23:33:01 <dolio> You can't print anything without libraries.
23:33:04 <dolio> You can't allocate memory.
23:33:06 <dolio> :)
23:33:12 <dolio> Well, other than on the stack.
23:33:13 <NoGoodNik> you can, on the stack :-)
23:33:39 <jrmole> and no two operating systems provide exactly the same libraries ;)
23:34:06 <NoGoodNik> I was at a place once where they wrote their own crossplatform C libraries
23:34:15 <jrmole> the standard C library is fairly portable, but also has a lot of limitations
23:34:17 <NoGoodNik> threading, memory allocation, and so on
23:34:20 <jrmole> and beyond that you're hosed
23:34:21 <NoGoodNik> file io ...
23:34:29 <jrmole> also, there's no standard C data structure library
23:34:40 <jrmole> and indeed people end up re-re-re-inventing the wheel every time
23:35:05 <dolio> That's true. Every program has a custom-designed linked list.
23:35:08 <dolio> Possibly several.
23:35:10 <NoGoodNik> can there even be such a thing given the lack of parametric polymorphism?
23:35:20 <jrmole> NoGoodNik, void * is the poor man's polymorphism ;)
23:35:35 <jrmole> which is actually used a whole lot in C
23:35:41 <NoGoodNik> one is a very poor man when one only has C
23:35:56 <jrmole> hmm, i think a more pure language would also have type safety
23:36:05 <jrmole> because in C it's very easy to expose yourself to how the machine represents things
23:37:01 <NoGoodNik> couldn't C have parametric polymorphism and more type safety while keeping it optional and staying close to the hardware?
23:37:13 <jrmole> optional type safety is no type safety ;)
23:37:31 <jrmole> in C you're safe if you never use pointers, but then it's more or less impossible to get anything done
23:37:32 <NoGoodNik> it is compared to void* being the only option.
23:37:33 <dolio> Java had a collection library before parametric polymorphism.
23:37:38 <dolio> Just cast everything to object!
23:37:51 <NoGoodNik> they had runtime checking on upcasts
23:37:57 <NoGoodNik> or downcasts, whichever
23:38:12 <jrmole> dynamic typing is better than no typing
23:38:29 <NoGoodNik> optional typing is better than no typing too.
23:38:35 <Pupeno> Good morning.
23:38:38 <dolio> What does D do?
23:38:45 <dolio> They have templates of some sort, no?
23:38:53 <jrmole> hi Pupeno
23:40:01 <jrmole> C++ has no memory management (though you at least can keep pointer-type-safety while allocating stuff), but it has parametric polymorphism and a standard data structure library
23:40:33 <NoGoodNik> and that makes it so much better in my eyes.
23:40:38 <jrmole> indeed
23:40:42 <NoGoodNik> together with exceptions and destructors.
23:41:24 <jrmole> but it's still sort of a pointless middle ground, when you might as well be using Java or C# and have those with memory management, portable bytecode, etc
23:41:35 <jrmole> (though portable bytecode is more of an implementation thing)
23:41:50 <NoGoodNik> and the valye of the memory management is questionable
23:41:50 <jrmole> i don't think C++ dominates any niche
23:42:26 <Pupeno> NoGoodNik: really ?
23:42:27 <jrmole> NoGoodNik, how do you mean?
23:42:37 <dolio> You mean explicit memory allocation?
23:42:44 <qz> jrmole, that's why there's so few software written in c++. yeah.
23:42:54 <NoGoodNik> there are still plenty of memory leaks when someone forgets to unset some reference and you keep a whole object graph in memory because of that
23:43:08 <jrmole> qz, i'm saying there's no good technical reason why there's a lot of software written in c++, at least any more
23:43:26 <NoGoodNik> except that people are less focused on looking out for such things in these languages because they expect the language to take care of all memory related things
23:43:35 <qz> jrmole, i cant see any language that can replace c/c++ in system programming for example
23:43:43 <NoGoodNik> and then there's the issue of memory being just one of many types of precious resources
23:43:59 <jrmole> qz, maybe C, but what's the value of C++ in systems programming?
23:44:30 <jrmole> NoGoodNik, you can waste memory in a language with memory management, but you can't accidentally use memory you're not entitled to use
23:44:35 * Pupeno still thinks about memory when working in garbage collected languages, something like "would this object, that I don't need anymore, have any references anywhere ? otherwise it won't be garbage collected".
23:44:36 <NoGoodNik> jrmole, C++ is an improved C and therefore is superior in low level system programming :-)
23:44:37 <jrmole> you have guarantees of safety, though not resource usage
23:44:38 <qz> jrmole, same, but more convenient. c++ is not all about template metaprogramming and boost libraries. it can be used as C with nice features
23:45:28 <Pupeno> If I have to code at the C level I would pick plain C or Objective-C.
23:45:36 <NoGoodNik> jrmole, often people do tend to assume they can fire and forget memory allocations.
23:45:49 <qz> Pupeno, you cant pick objective-c unless you are on mac ;)
23:45:57 <Pupeno> qz: why not ?
23:46:09 <NoGoodNik> they have OpenSTEP, don't theey
23:46:17 <qz> Pupeno, well. try to code windows driver in objective C and find out ;)
23:46:19 <Pupeno> qz: I've coded on objective-c and I've never touched the keyboard of any mac.
23:46:21 <jrmole> doesn't gcc support objective-c?
23:46:28 <Pupeno> qz: windows ? what's that ?
23:46:34 <qz> Pupeno, okay.
23:46:42 <jrmole> and can't it link to regular C pretty easily?
23:46:52 <Pupeno> jrmole: yes and yes.
23:47:10 <jrmole> so there's no good reason you couldn't write (most of) a device driver in objective C, on any C-ish platform
23:47:12 <Pupeno> jrmole: even calling objc methods from plain C is simple, ugly but simple.
23:47:29 <qz> C is fine, but C++ has it all and some more features are available when you need them. only reason to pick C is faster compilation speed imho
23:47:37 * Pupeno remembers an article about someone writting a device driver in C++ for Linuxp
23:47:48 <jrmole> does the runtime bloat of C++ go away if you're not using classes?
23:47:51 <NoGoodNik> LinuVISTA.
23:47:56 <qz> jrmole, ofcourse
23:48:10 <NoGoodNik> jrmole, you can use classes without bloat too.
23:48:14 <qz> jrmole, wait.. what bloat are you referring too?
23:48:32 <NoGoodNik> probably vtables?
23:48:53 <jrmole> i don't know much about implementation of C++
23:49:22 <qz> vtables are hardly a bloat
23:49:24 <Pupeno> you can even mix objc and c++ these days with objc++ which seems to be present in gcc (4.1 at least).
23:49:26 <Cale> > fix ((0:) . scanl (+) 1)
23:49:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:49:48 <Cale> hmm, perhaps that bug has been removed? :)
23:49:52 <Cale> C++
23:50:12 <Cale> dons: mbot will increment C's karma when C++ is mentioned :)
23:51:06 <Pupeno> hehe.
23:51:42 <NoGoodNik> qz, a call through a vtable is a bit slower and less likely to be inlined.
23:52:05 <qz> NoGoodNik, sure. but noone forces you to use virtual functions everywhere
23:52:24 <NoGoodNik> right, don't pay for what you don't use and all that.
23:54:45 <int-e> @karma C
23:54:46 <lambdabot> C has a karma of 0
23:58:00 <NoGoodNik> hey I got to the monad part of the gentle introduction. time to go to sleep. thanks to all for the discussion and the pointers.
