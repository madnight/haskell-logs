00:07:07 <JakeS> http://paste.lisp.org/display/26947
00:07:23 <JakeS> can someone look at that and tell if I have understood what the code does
00:10:41 * lispy reads oleg's response to his 'duplicate instance' problem and boggles
00:10:58 <lispy> i have this odd feeling like i should understand it, but it's just outside of my grasp at the moment
00:11:43 <wilx> Question.
00:12:05 <wilx> How do you pronounce Haskell'?
00:12:27 <vegai> "Haskell pilkku" :P
00:12:27 <Korollary> haskell prime
00:12:31 <Syzygy-> Most probably with your tongue and lips playing a prominent role. :P
00:12:59 <GomoX> I'm outty
00:13:00 <wilx> Prime?
00:13:02 <GomoX> Thanks for the help
00:13:04 <GomoX> Bye
00:15:20 * edwardk__ returns
00:15:29 <edwardk__> that was strange. my machine just up and died. no warning
00:26:25 <noj> macbook?
00:26:56 <edwardk__> pc actually
00:27:04 <noj> oh
00:27:16 <edwardk__> *shrug* if it happens again i'll worry
00:27:31 <edwardk__> but this is my old junky laptop anyways while i wait for my powersupply to arrive for my normal one
00:38:15 <edwardk__> so if i can make the typeclasses all work out how, i'm debating about whetrher or not its worth making a nice interface for the assembler that abuses the crap out of typeclasses to get a syntax like:
00:38:18 <edwardk__> add al ah
00:38:21 <edwardk__> add al 12
00:38:22 <edwardk__> etc
00:38:27 <edwardk__> add eax [eax]
00:39:30 <edwardk__> kinda wasteful in the [] for addressing case, but i think its a reasonably clean surface syntax if i can offer it
00:39:54 <int-e> how would you encode 2*eax+ebx+3 ?
00:40:18 <int-e> hmm, tuples could work.
00:40:42 <edwardk__> currently looking at: add eax [2 .* eax .+ 3 .+ ebx]
00:40:53 <edwardk__> and abusing the typeclasses further =)
00:41:02 <int-e> aha
00:41:21 <int-e> with further abuse, 2*eax+ebx+3 would actually work. hah.
00:42:21 <edwardk__> coz right now you have to say something like: Arith Add (Reg Eax) (Address $ MkAddress 3 (Just EBX) (Just (2,EAX))
00:42:32 <edwardk__> and i'd really like a nicer surface syntax
00:42:58 <edwardk__> er Reg EAX
00:43:18 <edwardk__> and then you have to remember to use Arithb Add for the 8 bit case
00:43:20 <edwardk__> and worse
00:43:33 <int-e> I think a preprocessor would be cleaner, but it's probably harder to use :/
00:43:52 <edwardk__> 016 $ Arith Add (Reg EAX) (Address $ MkAddress 3 (Just EBX) Nothing)   in order to load into AX
00:44:20 <edwardk__> coz i only support 16 bit ops through an explicit O16 prefix
00:44:23 <int-e> eww. does it have A16?
00:44:34 <edwardk__> only for LOOP/LOOPE/LOOPN/LOOPNZ
00:44:55 <edwardk__> my code emitter isn't smart enough to know what case its in
00:45:00 <int-e> ok.
00:45:07 <edwardk__> and technically my O16 isn't safe for immediate values
00:45:15 <edwardk__> same problem
00:45:46 <edwardk__> this is why i'm trying to find a cleaner surface syntax with type classes so i can make the underlying constructors more opaque and closer to the hardware
00:46:16 <edwardk__> if i can get a good enough typeclass system then I can encode in the types the fact that you can't do general addition of r/m to r/m in x86
00:46:32 <edwardk__> right now i have a couple of hacks for it
00:46:56 <edwardk__> so do you think the singleton lists are too wasteful?
00:47:18 <int-e> hmm, I'd expect them to disappear while inlining the code
00:47:22 <edwardk__> yeah
00:47:27 <edwardk__> thats what i was hoping for
00:48:24 <edwardk__> the thing that is currently baking my noodle is how to get relative address computations to work. right now i have my instructions parameterized over the type i am using to store immediate values and relative addresses in
00:48:51 <edwardk__> that way i can define an assembly pass over the opcodes that takes some form of labeled address and does in place replacement
00:49:03 <edwardk__> emitting a finalized form.
00:49:21 <edwardk__> that way i can also use it to generate ELF patch lists when i compile
00:49:53 <edwardk__> though presently i'm mostly intending this to be used live like a jit, i'd like to retain the option to generate binaries
00:51:44 <int-e> hmm, maybe that'd make a good execise in tying knots. *g*
00:52:15 <edwardk__> heh, yeah but then i have to be able to traverse and flatten. so having cyclic structures can be problematic
00:52:39 <edwardk__> i would really like to just hold onto instructions as lists in memory and have them link off to other lists
00:52:48 <edwardk__> but i think to do so i have to put some identifier in place on each list
00:53:08 <edwardk__> or hash them so i can only emit unique ones into the binary
00:53:19 <edwardk__> lest i get stuck in infinite loops
00:53:46 <edwardk__> of course that means people have to find fix points to compile loops =)
00:53:55 <edwardk__> hrmm
00:53:58 <edwardk__> hashing wouldn't be too bad
00:54:28 <edwardk__> hash backwards from jmp/hlt /end of list
00:56:31 <edwardk__> then emitting code would be just traversing the structure, adding chains of codes to a binary. and adding every jump target to a todo list with a patchup task or jump to a compiled address
00:56:37 <edwardk__> not optimal but not terrible
00:57:09 <edwardk__> would have to carry around some sort of hash table state
00:57:34 <edwardk__> but could foldr to generate the hashes
00:57:41 <Bourbaki> moin
00:57:46 <edwardk__> mornin
01:02:40 <edwardk__> hrmm. so the question is should i work in a monad so then the statements could be like do $ add eax eax; sbb eax 12
01:03:04 <edwardk__> I was originally building it up over a list, but then my code emitter doesn't really care. it just takes an instruction
01:39:21 <dons> mm. tricky. running a firewall on a halted machine, http://www.samag.com/documents/s=1824/sam0201d/0201d.htm
01:39:24 <lambdabot> Title: Sys Admin > Halted Firewalls, http://tinyurl.com/dhkvt
01:39:35 <dons> pretty easy, it seems.
01:43:25 <dons> ?remember HamiltonRichards It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing arithmetic in Roman numerals.
01:44:57 <mnislaih> ?where ajax-lambdabot
01:44:58 <lambdabot> I know nothing about ajax-lambdabot.
01:45:08 <dons> ?where lambdaweb
01:45:08 <lambdabot> http://lambdabot.codersbase.com
01:45:23 <mnislaih> thanks dons
01:45:26 <Maddas> ?quote
01:45:27 <lambdabot> madpickle says: Stuff costs more than it used to.
01:47:40 <matthew-_> lambdadot should do semantic analysis of the conversion(s) to pick the most aposite quote possible
01:48:01 <dons> it could take a regex, at least...
01:48:09 <matthew-_> lol, that'll do!
01:48:10 <dons> but yeah, a megamonad-ish plugin would be nice
01:49:04 <matthew-_> hey dons, did you look at hikij yesterday?
01:49:16 <mnislaih> omg. the ajax lambdabot interface is awesome.
01:49:23 <dons> mnislaih: :)
01:49:51 <dons> mnislaih: do you have some ideas for improving it? or just wanted to have a look?
01:50:00 <dons> matthew-_: hikij?
01:50:15 * dons practices vi keys
01:50:16 <mnislaih> nah, I recalled hearing about it a few days ago and just wanted to play
01:50:22 <matthew-_> dons: http://hikij.wellquite.org/
01:50:45 <matthew-_> dons: firefox / moz only though ;(
01:51:22 <dons> firefox + something?
01:51:31 <dons> i get a blank page in firefox
01:51:46 <matthew-_> oddd. you have javascript enabled?
01:52:17 <matthew-_> mmm. I see the requests for the javascript go through the logs...
01:52:17 <dons> yep. all i see is ' -- main area --' ?
01:52:35 <matthew-_> eek. Oh wait, you're on firefox 1.0.6
01:52:38 <matthew-_> no wonder!
01:52:40 <dons> and 'Double click article to edit.'
01:52:42 <dons> ah
01:53:09 <dons> why does that matter, in this case?
01:53:16 <JakeS> just a quick question
01:53:18 <matthew-_> missing javascript features I think
01:53:19 <JakeS> (sum [product [1..4], product [2..4], 1])
01:53:26 <JakeS> is = 49 right?
01:53:33 <dons> > (sum [product [1..4], product [2..4], 1])
01:53:34 <lambdabot>  49
01:53:43 <JakeS> k thanks
01:53:47 <dons> > [product [1..4], product [2..4], 1]
01:53:49 <lambdabot>  [24,24,1]
01:53:56 <dons> > sum [24,24,1]
01:53:57 <lambdabot>  49
01:54:29 <JakeS> ty just had a sudden doubt
01:54:46 <Patterner> > product [1.._] == product [2.._]
01:54:47 <lambdabot>  Pattern syntax in expression context: _
01:55:00 <dons> > product [1..] == product [2..]
01:55:04 <lambdabot>  out of memory (requested 1048576 bytes)
01:55:06 <matthew-_> lol!
01:55:13 <dons> the bot cares not.
01:55:19 <matthew-_> > product [1..]
01:55:23 <lambdabot>  out of memory (requested 2097152 bytes)
01:55:31 <dons> > last [1..]
01:55:35 <lambdabot> Terminated
01:55:43 <Patterner> Bot Abuse!
01:55:44 <matthew-_> > first [1..]
01:55:45 <lambdabot>  Couldn't match `a b' against `[]'
01:55:49 <matthew-_> > head [1..]
01:55:50 <lambdabot>  1
01:55:53 <matthew-_> good
01:55:54 <dons> I should probably rewrite the out of memory error to just "Terminated"
01:56:19 <Patterner> You should probably rewrite the "Terminated" error to sonk it's just the fact that I came to it from Java which has very precise requirements about closures / anonymous inner classes
05:33:18 <SamB> mmm
05:33:35 <matthew-_> That's interesting. I didn't know Python did the same as JS
05:33:50 <SamB> what happens in Java if you have an inner class in them middle of a for loop, and it closes over the loop variable?
05:34:11 <matthew-_> it can only use a variable if that variable is declared final
05:34:15 <SamB> oh
05:34:27 <SamB> that does sound like a good way to prevent mistakes...
05:34:33 <SamB> but it also sounds really annoying...
05:34:44 <matthew-_> so you would have to do for (int x : myList) { final int y = x; ...closure on y here... }
05:34:52 <SamB> yeah
05:35:28 <matthew-_> a lot of the decisions behind Java seem to be about not allowing programmers to make silly mistakes, often at the cost of conciseness
05:36:05 <matthew-_> which I guess would be similar for haskell were it not for type inference
05:38:04 <musasabi> Is there a way for eager top level IO actions that are executed as soon as the module is loaded?
05:41:52 <dons> musasabi: there's some thread from a couple of years ago about this
05:42:17 <dons> now, what was it? hmm. module initialisation? it was related to getArgs, iirc
05:42:35 <dons> and oleg had some ideas (after the implicit configuration paper0
05:44:36 <musasabi> dons: just need a way to register deserializing functions with a global registry (for the classic "decoding a Typeable" problem)
05:45:37 <dons> what kind of module loading are you doing?
05:45:45 <musasabi> which are generated by TH, but I need a way to register when the program execution begins.
05:46:06 <musasabi> just plain old executable with modules coming from library and some from the user.
05:47:09 <dons> you could have a hook in main that traverses a list of module imports represented with a typeclass, like lambdabot, running the associated registering function
05:47:48 <musasabi> dons: except that the main should be aware of the set of modules.
05:48:04 <dons> right. you'd have to duplicate the import list on the value level
05:48:15 <dons> i.e. a list of Module existentials or some such
05:48:28 <dons> (you know the Module type in lambdabot?)
05:48:36 <musasabi> and the main function doing the work comes from a library and each user would need to manually remember to list each module/type they want to support there.
05:48:47 <dons> ah
05:49:16 <dons> could be a good question for haskell-cafe@ ?
05:50:43 <musasabi> sending a mail.
05:51:28 <hugoh> is there a function that takes a string, a string with \n-chars, and split this string to a list with of strings, where each element is a row in the first string.
05:52:10 <dons> > unlines "abc\ndef\nghi\hjik"
05:52:11 <lambdabot>  Illegal escape sequence
05:52:16 <dons> > unlines "abc\ndef\nghi\nhjik"
05:52:16 <lambdabot>  Couldn't match `String' against `Char'
05:52:23 <dons> > lines "abc\ndef\nghi\nhjik"
05:52:24 <lambdabot>  ["abc","def","ghi","hjik"]
05:52:43 <dons> not sure about the other part of your question though. could you clarify?
05:54:17 <hugoh> exactlu! :)
05:54:49 <dons> ah ok :)
05:55:32 <dons> heh, I read this as defining a function taking 2 strings: "takes a string, a string with \n-chars" :)
05:55:53 <Syzygy-> @type unlines
05:55:54 <lambdabot> [String] -> String
05:56:04 <Syzygy-> @type lines
05:56:05 <lambdabot> String -> [String]
05:56:19 <Syzygy-> @commands
05:56:20 <lambdabot> Unknown command, try @list
05:56:22 <Syzygy-> @list
05:56:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:57:17 <Syzygy-> How did you run tests again?
05:57:29 <dons> ?check True -- ?
05:57:30 <lambdabot>  OK, passed 500 tests.
05:57:44 <dons> ?check \s -> (reverse . reverse) s == id (s :: T)
05:57:45 <lambdabot>  OK, passed 500 tests.
05:58:02 <Syzygy-> ?check \x -> unlines . lines x == id (x :: String)
05:58:03 <lambdabot>    Expecting a function type, but found `[String]'       Expected type: a -...
05:58:08 <dons> missing parens
05:58:15 <Syzygy-> ?check \x -> (lines . unlines) x == id (x :: String)
05:58:16 <lambdabot>  Couldn't match `Char' against `String'
05:58:25 <Syzygy-> ?check \x -> (unlines . lines) x == id (x :: String)
05:58:27 <lambdabot>  Falsifiable, after 0 tests: "\21148"
05:58:40 <dons> ?scheck \x -> (unlines . lines) x == id (x :: String)
05:58:42 <lambdabot>  add an instance declaration for (Serial Char)
05:58:42 <lambdabot>   In the definition of `wio...
05:58:48 <dons> ah scheck missing an instance
05:58:54 <Syzygy-> Heh
05:58:56 <hugoh> dons: is that using Debug.Quickquick? :)
05:59:03 <dons> ?check \x -> (unlines . lines) x == id x
05:59:04 <lambdabot>  Falsifiable, after 3 tests: "\858212"
05:59:08 <dons> hugoh: Test.QuickCheck, yep
05:59:24 <Syzygy-> Shouldn't that test pass?
05:59:24 <dons> the other, @scheck, uses Test.SmallCheck
05:59:32 <hugoh> dons: our teacher, koen cleassesn and john hughes have written it :)
05:59:46 <dons> yeah! its really cool.
05:59:50 <Syzygy-> What the flying f*** does @yhjulwwiefzojcbxybbruweejw do!?!?
05:59:52 <SamB> @check (lines . unlines) x == id x
05:59:53 <lambdabot>  Not in scope: `x'
05:59:58 <SamB> @check \x -> (lines . unlines) x == id x
05:59:58 <hugoh> :)
06:00:01 <Syzygy-> (looking at the command list)
06:00:02 <lambdabot>  OK, passed 500 tests.
06:00:02 <hugoh> it sure is! :)
06:00:12 <SamB> @yhjulwwiefzojcbxybbruweejw
06:00:13 <lambdabot> Just 'J'
06:00:20 <Syzygy-> @check \x -> (lines . unlines) x == id x
06:00:23 <lambdabot>  Falsifiable, after 381 tests: ["\595541\891738\214923\208716\270865\534585\2...
06:00:29 <Syzygy-> It hates me.
06:00:34 <Syzygy-> @check \x -> (lines . unlines) x == id x
06:00:40 <lambdabot> Terminated
06:00:43 <Syzygy-> o.O
06:00:48 <vegai> @check \x -> (lines . unlines) x == id x
06:00:50 <lambdabot>  Falsifiable, after 184 tests: ["\1108360\1029044\764847\513573\72541\710408\...
06:00:57 <vegai> likes me even less.
06:01:05 <Syzygy-> @yhjulwwiefzojcbxybbruweejw
06:01:05 <lambdabot> "\""
06:01:11 <dons> yay for randoms
06:01:11 <SamB> what is with that...
06:01:14 <SamB> oh.
06:03:36 <SamB> no wait...
06:05:00 <sieni> > unlines ["a","\n","b"]
06:05:01 <lambdabot>  "a\n\n\nb\n"
06:05:04 <SamB> @check \xs -> not (any ('\n' `elem`) xs) ==> (lines . unlines) x == id x
06:05:05 <lambdabot>  Not in scope: `x'
06:05:10 <SamB> @check \xs -> not (any ('\n' `elem`) xs) ==> (lines . unlines) xs == id xs
06:05:14 <sieni> > lines  "a\n\n\nb\n"
06:05:16 <lambdabot>  OK, passed 500 tests.
06:05:16 <lambdabot>  ["a","","","b"]
06:05:40 <SamB> @type endsWith
06:05:41 <lambdabot> Not in scope: `endsWith'
06:05:49 <SamB> @hoogle suffix
06:05:50 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
06:05:51 <lambdabot> Distribution.PreProcess.knownSuffixHandlers :: [PPSuffixHandler]
06:05:51 <lambdabot> Distribution.PreProcess.ppSuffixes :: [PPSuffixHandler] -> [String]
06:06:57 <SamB> @check \x -> not ("\n" `isSuffixOf` x) ==> (unlines . lines) xs == id xs
06:07:03 <lambdabot>  Not in scope: `xs'
06:07:09 <SamB> @check \x -> not ("\n" `isSuffixOf` x) ==> (unlines . lines) x == id x
06:07:11 <lambdabot>  Falsifiable, after 1 tests: "\185373"
06:07:16 <SamB> hmm.
06:07:39 <Syzygy-> > lines ["a\n\n\nb\n"]
06:07:39 <lambdabot>  Couldn't match `Char' against `[Char]'
06:07:41 <SamB> @check \x -> ==> (unlines . lines) (x ++ "\n") == x ++ "\n"
06:07:42 <lambdabot>  Parse error
06:07:46 <Syzygy-> > lines "a\n\n\nb\n"
06:07:47 <lambdabot>  ["a","","","b"]
06:07:50 <SamB> @check \x -> (unlines . lines) (x ++ "\n") == x ++ "\n"
06:07:52 <lambdabot>  OK, passed 500 tests.
06:08:00 <Syzygy-> @check \x -> (unlines . lines) (x ++ "\n") == x ++ "\n"
06:08:01 <lambdabot>  OK, passed 500 tests.
06:08:18 <SamB> lines and unlines aren't very good half-inverses are they?
06:08:21 <Syzygy-> @check \x -> (lines . unlines) (x ++ "\n") == x ++ "\n"
06:08:22 <lambdabot>  Couldn't match `String' against `Char'
06:08:41 <SamB> Syzygy-: that isn't going to work
06:09:12 <SamB> because if there are any '\n' chars in any of the input strings, they will be split in the result...
06:09:29 <hugoh> > @check \x -> (unlines . lines) (x ++ "\n") == x ++ "\n"
06:09:29 <lambdabot>  Parse error
06:10:34 <hugoh> i thought of this with invers. i have a function, and i want to do exactly what it does, but inverted. as haskell is a functional language, are there any smart keyword to make an invers easy?
06:11:00 <dons> inverted?
06:11:25 <dons> like, f x = (x,x) , and g (x,x) = x -- ?
06:11:46 <dons> do you have an example?
06:11:56 <ropine> you mean some function g so that if f x = y, then (g f) y = x?
06:12:09 <hugoh> yeah ropine
06:12:21 <ropine> no can do
06:12:31 <hugoh> g (f(x)) == x
06:12:49 <dons> ?check \f g x y -> f x == y ==> (g f) (y :: I) == (x :: I)
06:12:50 <lambdabot>  Falsifiable, after 1 tests: <Int -> Int>, <(Int -> Int) -> Int -> Int>, 0, -3
06:12:56 <dons> :]
06:13:45 <dons> ?check \f g x y -> let y = f x in (g f) (y :: I) == (x :: I)
06:13:46 <lambdabot>  Add a type signature
06:14:11 <dons> anyway, there's no magic keyword :)
06:14:31 <ropine> counterexample: if f _ = 0, how could you invert it?
06:15:03 <dons> ?type const 0
06:15:04 <lambdabot> forall a b. (Num a) => b -> a
06:15:13 <dons> ?djinn b -> Int
06:15:14 <lambdabot> -- f cannot be realized.
06:15:26 <gds> ropine: in a language where everything was sets, I guess you could return the set of things that were valid inputs....
06:15:38 <gds> or nondet over them ;)
06:15:46 <ropine> that's just scary
06:15:49 <gds> :)
06:16:39 * gds quite likes the philosophy that nondet should be explicit in a language - then at least you can see it ;)
06:25:43 <humasect> may one use list comprehensions in place of mapM/mapM_ ?
06:26:36 <dons> yep, when combined with sequence or sequence_
06:26:49 <dons> ?type mapM_ print
06:26:50 <lambdabot> forall a. (Show a) => [a] -> IO ()
06:27:05 <dons> ?type \xs -> sequence_ [ print x | x <- xs ]
06:27:06 <lambdabot> forall a. (Show a) => [a] -> IO ()
06:28:20 <dons> would be easier  with monad comprehensions, i suppose
06:28:28 <humasect> oh !
06:29:00 <humasect> monad comprehensions?
06:29:58 <dons> a generalisation of list comprehensions to arbitrary monads ([a] is a monad after all) that used to be in Haskell 1.4, disappeard from H98, but still has a strong underground following
06:30:19 <humasect> ahh
06:39:55 <vegai> musasabi: hey. Your supplied user.hs seems to have some minor bugs
06:40:14 <vegai> @paste
06:40:15 <lambdabot> http://paste.lisp.org/new/haskell
06:41:11 <lisppaste2> vegai pasted "trying http://happs.org/HAppS/examples/user.hs" at http://paste.lisp.org/display/26965
06:42:52 <vegai> it's just that one pattern
06:47:49 <musasabi> vegai: it will probably have some bugs since I did it at 4AM when I couldn't sleep :-)
06:50:04 <vegai> debugging other peoples' Haskell code isn't fun ;/
06:50:14 <vegai> does it get easier?
06:50:16 <musasabi> but I think it did compile. looking at it.
06:50:21 <dons> vegai: yeah
06:50:39 <dons> it helps if you have editor support (i.e. to insert type signatures, and look up defns)
06:50:59 <vegai> hmm, I wonder why it doesn't compile here
06:51:08 <dons> or you can convince the author there's a bug, and they fix it themselves ;)
06:52:30 <musasabi> vegai: do we have the same versions of things?
06:52:31 <musasabi> e@yui:~/work/HAppS/HAppS$ md5sum examples/user.hs src/HAppS/Agents/Users.hs
06:52:31 <musasabi> 24303d641a8b1ce8a1c861be50f3e6a1  examples/user.hs
06:52:31 <musasabi> 304534d87020b85420c03114ff30d07c  src/HAppS/Agents/Users.hs
06:53:43 <vegai> yeah, we do.
06:54:30 <vegai> I'll try cleaning rebuilding HAppS
06:55:04 <musasabi> ghci -ignore-package HAppS -isrc examples/user.hs (faster)
06:55:22 <vegai> ah
06:55:55 <vegai> same thing.
06:56:07 <vegai> I'll try rm -rf and darcs get
06:56:58 <vegai> same thing..
06:57:50 <vegai> Fascinating. But I have to go now. Tell me if you have any clues
06:57:51 <musasabi> let me paste a script that works for me.
06:58:29 <musasabi> darcs get --partial http://happs.org/HAppS && cd HAppS && ghci -ignore-package HAppS -isrc examples/user.hs
06:58:40 <vegai> yes, that's what I did
06:58:45 * musasabi suspects GHC
06:58:48 <vegai> Yeah.
06:58:54 <vegai> Mine's 6.5.20060924
06:58:57 <musasabi> 6.5.20060902
06:59:09 <musasabi> I'll look into 0924.
06:59:16 <vegai> but I'll go now, really ;:)
06:59:19 <musasabi> (or more recent)
06:59:23 <musasabi> see you later.
07:14:22 <ozone> irc
07:14:28 <ozone> oops
07:14:41 <mauke> re
07:14:50 <ozone> sup
07:25:53 <fasta> My university does not have access to some article on scitation.aip.org Could anyone assist me in getting the PDF for an article?
07:29:28 <musasabi> which article.
07:30:23 <musasabi> seems to not work from here.
07:32:31 <fasta> musasabi: http://link.aip.org/link/?SMJCAT/5/704/1
07:32:37 <lambdabot> Title: Cookies Required
07:32:46 <fasta> funny title ;)
07:34:37 <mauke> my title says The Planar Hamiltonian Circuit Problem is NP-Complete
07:35:10 <fasta> mauke: mine too, must be a lambdabot failure.
07:35:18 <fasta> mauke: can you access it?
07:35:40 <matthew-_> mmm. what do they reduce to it in order to show NPC? Presumeably HCP itself?
07:35:49 <dons> lambdabot doesn't talk cookies
07:35:50 <mauke> fasta: nope :/
07:35:58 <dons> it eats them
07:36:08 <matthew-_> lambdabot will get fat
07:36:27 <fasta> matthew-_: I have computers and intractibility next to me. They say it's a complex construction.
07:36:31 <dons> with the increasing amount of cookies in the diet, i suspect so.
07:36:47 <fasta> matthew-_: I'd expected it to be in that book, but it isn't :(
07:37:04 <sieni> when does lambdabot become self-aware? any estimates?
07:37:23 <dons> ?vixen are you self-aware yet?
07:37:23 <lambdabot> i truely am
07:37:24 <matthew-_> fasta: ahh. I don't know what the planar hcp is - I was just guessing
07:37:27 <dons> there you go.
07:37:43 <matthew-_> @vixen prove that you are self-aware
07:37:43 <lambdabot> ain't it just like a man?
07:38:01 <fasta> matthew-_: oh, yes, they reduce to HCP.
07:38:43 <matthew-_> fasta: and the proof it's in NP is the standard "guess and check" arguement?
07:39:12 <fasta> matthew-_: probably, but that's not interestng.
07:39:16 <matthew-_> sure
07:39:18 <fasta> interesting, even
07:39:40 <fasta> I hate that: some guys made up something worth to read, and then I can't easily read it.
07:40:01 <dons> fasta: could it be findable on the web via scholar.google.com ?
07:40:04 <dons> or citeseer?
07:40:04 <fasta> I hope our physical library has it.
07:40:05 <fasta> dons: no
07:40:08 <fasta> dons: both no
07:40:27 <dons> ah well, the authors want to disappear without a trace then? :/
07:40:32 <fasta> dons: everyone cites it, but this website is the only one having it.
07:40:35 <fasta> dons: probably
07:40:50 <dons> grr. how 20th century
07:41:25 <fasta> Micheal R Garey also seems to have so personal homepage since 1999, or so.
07:41:27 <dons> btw, if anyone reads any interesting haskell papers, be sure to add them to http://haskell.org/haskellwiki/Research_papers
07:41:40 <dons> so we can avoid this situation at least in the haskell world
07:41:49 <fasta> The first hit is something from Bell Labs where he left X years ago.
07:42:04 <lambdabot> Title: Research papers - HaskellWiki, http://tinyurl.com/0
07:42:08 <fasta> There's still an e-mail address... but well.... I don't know.
07:42:28 <dons> yeah, you can sometimes get authors to email/mail you a copy
07:42:46 <dons> or even authors who appear in the same proceedings
07:43:57 <matthew-_> dons: you might want to borrow the software that runs http://pubs.doc.ic.ac.uk/ for the papers - I know he'll let you have it, and it's probably going to be nicer than a standard wiki page.
07:44:00 <lambdabot> Title: Publications from Computing - Imperial College London
07:44:21 <dons> oh maybe. cheers, i'll have a look
07:44:33 <Igloo> Do you know about http://haskell.readscheme.org/ ?
07:44:36 <lambdabot> Title: Online Bibliography of Haskell Research
07:44:46 <dons> i do.
07:44:52 <dons> (seems a bit out of date?)
07:45:09 <dons> (we link to it from our wiki too)
07:45:10 <ozone> dons: you're in night owl mode lately :)
07:45:17 <dons> yeah :/
07:45:18 <roconnor> I hate it when I try to prove a lemma, only to find out that it isn't provable.
07:45:33 <matthew-_> try harder! ;)
07:45:35 <dons> ozone: how's the QuickTime stuff going?
07:45:39 <ozone> i decided to go with C++ for my project btw, sorry.  too many libraries that C++ has that are proving too useful...
07:45:44 <dons> ah well
07:46:10 <dons> i'll be sure to send you the aniseed lollipops for xmas then
07:46:41 <ozone> heh, i'm actually thinking of doing a haskell implementation after i finish the C++ anyway
07:46:45 <ozone> just for kicks
07:46:56 <dons> yeah, good idea. use C++ as the prototyping language
07:47:06 <ozone> ahahaha
07:47:11 <ozone> @quote dons yeah, good idea. use C++ as the prototyping language
07:47:11 <lambdabot> dons yeah, good idea. use C++ as the prototyping language hasn't said anything memorable
07:47:19 <ozone> grr
07:47:23 <dons>  @remember...
07:ite
09:07:28 <lambdabot> elite
09:07:33 <xerox> @yow
09:07:33 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
09:08:17 <guest_> @elite lambdabot is cool
09:08:18 <lambdabot> |4/\/\BdabO7 iz (0o|
09:08:47 <guest_> @. elite elite lambdabot is cool
09:08:48 <lambdabot> |a/\/\BDaB0+ iZ0RZ (O0l
09:09:13 <Syzygy-> @ . elite . elite . elite elite lambdabot is cool
09:11:38 <matthew-_> well that's got it thinking...
09:12:22 <glguy> Syzygy-: I think that your space between @ and .
09:12:22 <guest_> or is the space after the @ not allowed?
09:12:27 <glguy> has it not thinking at all
09:12:43 <Syzygy-> @. elite . elite . elite elite lambdabot is cool
09:12:43 <lambdabot> |4/\/\8d480+ Iz0Rz0Rz (0O|
09:12:44 <guest_> not even answering anything?
09:12:52 <Syzygy-> Ah. There it is.
09:13:02 <Syzygy-> guest_: Probably managed to sneak by the almighty regexps... :)
09:14:03 <matthew-_> it uses regexps? Not a full parser?
09:14:34 <Syzygy-> matthew-_: Do I look like I know what I'm talking about? :)
09:14:38 <matthew-_> yes!
09:14:41 <matthew-_> ;)
09:14:43 <Syzygy-> Oh GODS!
09:14:50 <Syzygy-> What do I need to do to get rid of that??
09:15:22 <matthew-_> start every conversation with "a/s/l?"!
09:15:37 <weitzman> @vixen a/s/l
09:15:38 <lambdabot> 19/f/California
09:15:43 <Syzygy-> @vixen a/s/l
09:15:43 <lambdabot> 19/f/California
09:15:46 <Syzygy-> Awww.
09:15:49 <weitzman> I win
09:15:50 <Syzygy-> matthew-_: a/s/l?
09:15:57 <matthew-_> better.
09:16:15 <guest_> @help vixen
09:16:17 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
09:16:55 <matthew-_> @vixen, you do know that Haskell B. Curry most likely didn't invert "currying" right?
09:16:56 <lambdabot> Ooh, functional programmers are so hot!
09:17:08 <matthew-_> that's neither here nor there...
09:18:07 <guest_> if he didn't invert currying, does that mean he didn't invent uncurrying?
09:18:36 <matthew-_> I've no idea. But I remember looking it up last year...
09:19:34 <matthew-_> it's normally credited to Schonfinkel in: M. Sch√∂nfinkel. √úber die bausteine der mathematischen logik. Mathematische Annalen, 92:305‚Äì316,
09:19:43 <matthew-_> 1924.
09:19:54 <beelsebob_> @vixen is matthew-_ hot?
09:19:54 <lambdabot> let me answer that later, okay?
09:20:11 <ventonegro> how does uniqueness types compare to monads?
09:20:17 <ventonegro> ops
09:20:28 <ventonegro> uniqueness typing
09:22:06 <shapr> musasabi: Yay for HAppS user management!
09:22:11 <shapr> Binkley: greetings!
09:25:02 <dylan> So, some random person in ireland is stealing my bandwidth, by using an image from my server as their background image.
09:25:18 <glguy> ventonegro: uniqueness typing just prevents one value from being used more than once
09:25:27 <dylan> err, wrong channel.
09:25:42 <glguy> ventonegro: Monads describe an interface for computation
09:25:58 <ventonegro> glguy: i'm sorry I wasn't clear
09:26:13 <ventonegro> in the Great Language Shootout Clean beats GHC
09:26:37 <shapr> dylan: Check the referrer
09:27:17 <ventonegro> is it because of the Clean approach to I/O or is it a better compiler overall?
09:27:29 <glguy> neither?
09:28:09 <glguy> the programmers that wrote the clean submissions just included more tweaks in their code to run everything as strictly as possible
09:28:23 <shapr> Yeah, that's the way to get a good score on the Shootout.
09:28:46 <ventonegro> glguy: are you asking me? :-)
09:28:54 <Binkley> hey shapr
09:28:58 <dylan> shapr: I replaced the picture with an IRA poster, given that the person seems to be too religious and also in Ireland. ;)
09:29:04 <glguy> clean's uniqueness types are (from my limited experience) generally more awkward than monads once you understand monads
09:29:15 <shapr> I'd rather have a "code as communication" shootout where people who know the language but not the program have to make changes to the submissions. I think that'd be more interesting.
09:29:15 <matthew-_> dylan: lol!
09:29:16 <glguy> dylan: well played
09:29:23 <shapr> dylan: yikes!
09:29:34 <dylan> http://www.xanga.com/Cornelius23
09:29:35 <lambdabot> Title: Cornelius23's Xanga Site
09:29:54 <dylan> original background: http://hardison.net/irish-tux-flag.png
09:29:55 <Binkley> haha, that's fantastic
09:30:00 <shapr> Some weenies on myspace used 70% of my bandwidth one month.
09:30:02 <dylan> I am an evil, evil man.
09:30:06 <ventonegro> glguy: once I grasped the monads concept I found it very cool
09:30:26 <ventonegro> dylan: hahahahahaha
09:30:30 <matthew-_> dylan: brilliant. You may get shot, but really brilliant
09:30:39 <shapr> dylan: Wow, I like your evil nature.
09:30:50 <dylan> matthew-_: personally, I like the concept of the IRA.
09:31:14 <Cale> Has xanga just turned into a caricature of itself?
09:33:17 <dylan> I dunno, never heard of it before
09:33:24 <shapr> dylan: I like the idea of the IRA, but I don't like their execution.
09:33:47 <dylan> shapr: yes, well, they didn't like the executions either. </devils-advocate>
09:35:13 <dylan> I just hope that 16 year old doens't get in too much trouble for the IRA poster on his xanga account. XD
09:36:12 <Binkley> well, i'm sure xanga doesn't like people using others' bandwidth, in the first place
09:36:24 <shapr> That's the risk of leeching off of others.
09:36:55 <Binkley> he's just lucky you chose to go for the IRA poster and not goatse
09:38:00 <dylan> I've avoided every viewiing goatse, so... no need to make someone else see it
09:38:04 <dylan> *ever.
09:38:50 <dylan> I'm having trouble figuring out how to model chat users / channels / channel list in haskell.
09:39:39 <glguy> dylan: goatse is just a joke
09:39:41 <dylan> in ocaml, I used objects and subtyping (channels and users share many attributes).
09:40:29 <dylan> haskell doesn't do subtyping, so I was considering an 'ChatEntity' type class.
09:41:20 <dylan> so I could have instances of 'name', 'attributes', etc for both users and channels.
09:41:25 <audreyt> you can use a single type with two constructors
09:41:58 <dylan> there's actually about five different types of things
09:42:01 <audreyt> MakeUser :: { name :: Striing } -> Entity ChatUser
09:42:16 <dylan> 'users' and 'channels' is just a simplification for the sake of talking about it.
09:42:36 <audreyt> *nod*
09:42:49 <audreyt> typeclass is perhaps sane, then
09:43:06 <dylan> Right now I have a single type with a single constructor. I'd like some gurantee that I can't put a channel inside a user.
09:43:48 <dylan> only problem is implementing 'lobbys', which is an object that holds users, channels, and other things.
09:45:47 <dylan> the problem there is that channels can become lobbys. (the server can essentially 'chroot' users...)
09:48:00 <sek> does anyone know of a good vim plugin for .hs files?
09:49:21 <psi> exploring quickcheck a bit: prop_RevRev xs = length xs > 5 ==> reverse (reverse xs) == xs -- why are the arguments exhausted after 0 tests?
09:49:50 <dylan> dons had a vim indentation file, he was supposed to publish a whiel ago
09:49:51 <psi> generating a list larger than 5 shouldn't be tough?
09:51:10 <sek> i tried lhaskell.vim and hs.vim but they both throw errors
09:52:35 <shapr> psi: most lists will be trivial
09:53:34 <Cale> @check \xs -> length (xs :: [Int]) > 5
09:53:36 <lambdabot>  Falsifiable, after 0 tests: []
09:53:43 <shapr> psi: You can 1. create a custom generator that gives a higher likelihood of larger lists 2. create a generator that annotates generated lists so you can see that 50% or more of the built-in generator's lists are trivial 3. read the paper original where it explicitly mentions this problem :-)
09:53:48 <Cale> @check \xs -> length xs > 0 ==> length (xs :: [Int]) > 5
09:53:50 <lambdabot>  Falsifiable, after 0 tests: [1,2]
09:53:55 <Cale> @check \xs -> length xs > 1 ==> length (xs :: [Int]) > 5
09:53:57 <lambdabot>  Falsifiable, after 0 tests: [-1,3]
09:54:00 <Cale> @check \xs -> length xs > 2 ==> length (xs :: [Int]) > 5
09:54:02 <lambdabot>  Falsifiable, after 0 tests: [-2,-1,3]
09:54:06 <Cale> @check \xs -> length xs > 3 ==> length (xs :: [Int]) > 5
09:54:08 <lambdabot>  Arguments exhausted after 0 tests.
09:54:21 <Cale> @scheck \xs -> length xs > 3 ==> length (xs :: [Int]) > 5
09:54:23 <lambdabot>   Failed test no. 5. Test values follow.: [-1,-1,-1,-1]
09:54:29 <Cale> @scheck \xs -> length xs > 4 ==> length (xs :: [Int]) > 5
09:54:30 <lambdabot>   Failed test no. 6. Test values follow.: [-1,-1,-1,-1,-1]
09:55:03 <shapr> Does scheck allow custom generators?
09:55:13 <psi> shapr: oh, thanks :)
09:56:10 <ndm> shapr: yep
09:56:27 <shapr> psi: QuickCheck is the coolest testing tool around.
09:56:27 <ndm> shapr: and they are really really really easy to define, much easier than for QuickCheck
09:56:32 <shapr> hm
09:56:34 <shapr> I gotta see that.
09:56:46 <ndm> you literally say:
09:56:58 <shapr> If it's easier that QuickCheck, I gotta steal it for QuickCheck3
09:57:05 <ndm> Ctor1 `also` Ctor2
09:57:07 <ndm> or something
09:57:26 <ndm> yep, I keep suggesting to Colin that he makes those work in QuickCheck as well
09:57:50 <ndm> I think its really the very best thing about small check, generators that are trivial and don't require (explicit) use of monad machinery
09:57:59 <psi> shapr: I don't fully understand, though, why verboseCheck on the same property, but without the contraint, shows plenty of large lists.
09:58:44 <shapr> psi: Because you need both large lists and something that fails the property, and your property won't fail.
09:59:44 <shapr> psi: take out one of those two reverse calls and see what happens.
10:02:07 <psi> shapr: Okay, it still seems to generate smaller lists than without the condition.
10:02:40 <shapr> ?
10:03:05 <shapr> ==> just says "for all the outputs of the random generator, filter out the ones that don't match this condition"
10:03:14 <shapr> The original paper uses an ordered lists filter.
10:03:36 <psi> what I mean is, without the condition, I get plenty of lists that are larger than 5.
10:03:44 <psi> with the condition, none of them are larger.
10:04:26 <shapr> that's weird
10:04:38 <shapr> does not compute?
10:05:17 <guest_> there is some increasing size trickery, maybe it doesn't get increased when the precondition is not satisfied?
10:05:37 <shapr> hiya guest_, who are you?
10:06:01 <guest_> Christian Sievers
10:06:05 <psi> guest_: I'd guess so
10:06:16 <shapr> Hiya Christian Sievers, my name is Shae Erisson. How's Haskell treating you today?
10:06:57 <shapr> I was going to say I'm the guy responsible for #haskell, but that's not true as of yesterday.
10:07:03 <Cale> shapr: hm?
10:07:13 <Cale> shapr: who's in charge now?
10:07:14 <guest_> I had that problem when I tried to implement QuickCheck ideas somewhere else - zero was no good value, but I didn't get any other...
10:07:18 <shapr> Cale: dons
10:07:56 <Cale> shapr: That's not inappropriate, I suppose. Are you abdicating due to the fact that you can't be around as much?
10:08:38 <waern> did you guys see the Quark framework thing?
10:08:57 <shapr> Cale: More because my community organization efforts have been fruitful to the community, but not to me personally.
10:09:19 <guest_> shapr, I"ve seen that name before.  I'm not doing much Haskell today, but using IRC for the first time...
10:13:56 <shapr> You may have seen my name in relation to the #haskell channel, The Monad Reader, the IOHCC or other fun activities.
10:17:08 <guest_> IOHCC?
10:17:56 <shapr> International Obfuscated Haskell Code Contest
10:19:04 <guest_> Oh, I see.  I guess it was just in the haskell mailing list, or -cafe.
10:24:26 <bringert> dcoutts, dcoutts_, kolmodin: you here?
10:27:08 <marcot> I'm compiling a code that imports a function from a module and don't use it with -Wall, but no warning is shown.
10:27:15 <marcot> I'm wondering if that's a ghc bug.
10:27:37 <sieni> that's not perhaps obfuscated enough, byt at least I tried: http://www.hurmio.org/~ville/SiteswapValidator2.hs
10:27:41 <guest_> I'll leave now, bye
10:27:43 <lambdabot> http://tinyurl.com/zsjlp
10:28:06 <Lemmih> marcot: Are you sure it isn't used or re-exported?
10:28:44 <marcot> Lemmih: yes.
10:28:52 <marcot> Lemmih: grep on the file returns nothing.
10:30:47 <marcot> When I try to add something from Prelude import, it gives the warning.
10:31:21 <marcot> But with _max from Database.HaskellDB.Query it doesn't complains.
10:32:21 <Lemmih> Ah, the compiler ignores unused functions if they start with an underscore.
10:32:28 <marcot> hum...
10:32:33 <marcot> I didn't knew that.
10:32:34 <marcot> Why?
10:33:01 <shapr> Leading underscore almost always means "this is a system function, don't assume anything."
10:33:03 <marcot> Is there another pattern of functions that are ignored by the compiler?
10:33:24 <shapr> That's true in Python, Haskell, not sure about C
10:33:36 <Lemmih> Hiya shapr.
10:33:44 * shapr hugs Lemmih 
10:33:47 <shapr> hiya!
10:34:08 <marcot> ok.
10:34:10 <shapr> I was just telling someone about speaking swedish/danish with you at AngloHaskell
10:34:23 <Syzygy-> In C it doesn't need to mean that, however, many compilers store their internal symbols by prepending a _
10:34:27 <shapr> Lemmih: Do you have a microphone yet?
10:34:28 <Syzygy-> shapr: Pratar du svenska?
10:34:48 <Lemmih> shapr: Ah no /-:
10:35:10 <shapr> Syzygy-: Nej, jag har ingen aning vad do pratar om, men har √§r kanin med pannkaka p√• huvudet
10:35:18 <Syzygy-> ......
10:35:20 * shapr looks for the pic
10:35:35 <Syzygy-> Ah. "...h‰r ‰r en kanin..." (nitpicking)
10:35:44 <Syzygy-> also "...vad du pratar om..."
10:36:01 <shapr> See? I told you I don't speak Swedish.
10:36:04 <Syzygy-> (sorry about that. A compulsion of mine :)
10:36:10 <Syzygy-> Right.
10:36:12 <shapr> Plus you're using latin-1
10:36:26 <shapr> Ah, here it is - http://www.scannedinavian.com/~shae/blog/images/knn.jpg
10:36:27 <Syzygy-> Well .. yes .. you want me to swap to utf8?
10:36:31 <lambdabot> http://tinyurl.com/o534b
10:36:39 <shapr> yes!
10:37:07 <shapr> It seems that most Swedes use latin-1 on irc, thus the inertia is there to stick with it. But I prefer utf-8 myself.
10:37:13 <Syzygy-> √•√§√∂ - this better?
10:37:40 <shapr> jo
10:38:05 <shapr> Syzygy-: Are you at Chalmers?
10:38:11 * Syzygy- LOVES the modern irssi recode features
10:38:22 <Syzygy-> shapr: Nope. At Friedrich-Schiller-Universit√§t Jena :P
10:38:30 <shapr> I hate the fact that IRC doesn't specify a charset.
10:38:39 <Syzygy-> I did my M.Sc. in Stockholm at Stockholm University though...
10:38:46 <shapr> Neato
10:39:01 <shapr> I lived in H√§sselby Strand for a coupla months.
10:39:12 <Syzygy-> O.O
10:39:15 <shapr> And in Boden for years before that.
10:39:20 <Syzygy-> I grew up in Backlura, in H√§sselby Villastad!!!!
10:39:26 <shapr> Cool!
10:39:38 <Syzygy-> Had quite a lot of school friends in H√§sselby Strand...
10:39:45 <Syzygy-> That one hit close to home... :)
10:39:58 <shapr> It's a nice place. Quiet, friendly, and it has a beach for unicycling!
10:40:04 <Syzygy-> (btw - I get an internal server error from http://www.scannedinavian.com/hope/entry )
10:40:08 <shapr> uh?
10:40:16 <shapr> ack!
10:41:08 <shapr> argh, stupid ISP
10:42:01 <psi> shapr: are you using rcirc? I have both utf-8 and latin-1 chars working properly.
10:42:07 <shapr> I'm using ERC
10:42:15 <psi> mkay
10:42:16 <shapr> But I'd rather switch to yi+lambdabot!
10:42:23 <psi> :)
10:43:31 <endra> hey
10:43:32 <endra> how can I loop from 1 to 10?
10:44:01 <psi> depends on what you mean by loop
10:44:32 <endra> how do I output 1 to 10
10:44:33 <endra> lol
10:44:50 <cjeris> A monk asked Simon, "How can I loop from 1 to 10?" Simon replied, "In Soviet Haskell, loops iterate you!"
10:44:52 <Syzygy-> endra: map f [1..10] is one neat way.
10:44:54 <defcon8> [1..10]
10:44:59 <psi> mapM_ print [1..10]
10:45:08 <endra> what if I wanted to skip 2? each time
10:45:15 <endra> so 1 3 5 etc
10:45:25 <wolverian> filter the list
10:45:25 <Syzygy-> mapM_ print [1,2..10]
10:45:26 <shapr> > take 5 [1,3..]
10:45:28 <lambdabot>  [1,3,5,7,9]
10:45:30 <Syzygy-> mapM_ print [1,3..10]
10:45:31 <wolverian> or that
10:45:32 <Syzygy-> sorry
10:45:45 <endra> what weird language
10:45:45 <endra> lol
10:45:53 <shapr> I say that when I write C.
10:46:27 <shapr> It's like, everything's in the IO monad!
10:47:54 <endra> > test
10:47:55 <lambdabot>  Not in scope: `test'
10:48:20 <endra> > print [1,3..10]
10:48:22 <lambdabot>  No IO allowed
10:49:13 <endra> what can you do with haskell?
10:50:10 <ventonegro> endra: what can't you do?
10:50:21 <shapr> Yeah, anything you can do with other languages.
10:50:39 <endra> you guys have guis?
10:51:00 <ventonegro> @where gtk2hs
10:51:01 <lambdabot> http://haskell.org/gtk2hs/
10:51:20 <ventonegro> @where wxHaskell
10:51:21 <lambdabot> http://wxhaskell.sourceforge.net/
10:51:23 <shapr> Yeah, wxWidgets and gtk2
10:53:02 <shapr> endra: Do you have experience programming in other languages?
10:53:06 <endra> yes
10:53:14 <endra> plenty.. and I've gotta say.. this is a weird one
10:53:22 <abcde`> hey!
10:53:36 <ventonegro> I once thought so
10:53:40 <abcde`> who are you calling weird
10:53:51 <ventonegro> until I had a satori
10:53:55 <shapr> endra: Learning Haskell will change the way you write code.
10:54:19 <endra> Tell you what, you convince me of switching and I will
10:54:52 <shapr> I don't think you should switch, I think you should try everything and try to see the good points in each thing.
10:55:02 <shapr> And then use whichever tool fits the task.
10:55:11 <ventonegro> endra: don't try to learn from the "gentle introduction", it's not gentle
10:55:12 <shapr> If you know how to use many tools, you'll always have a good solution for any task.
10:55:41 <ropine> "A language that doesn't affect the way you think about programming, is not worth knowing." --Alan Perlis
10:55:50 <ventonegro> search for "Yet Another Haskell Tutorial"
10:56:03 <shapr> @oldwiki HaskellDemo
10:56:03 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
10:56:11 <shapr> That's the bite-sized introduction I wrote long ago.
10:56:57 <shapr> endra: What languages do you use now?
10:57:39 <endra> c/c++/php/mysql/vb6/vb.net/c#/few others
10:57:42 <shapr> I started with BASIC on the Sinclair, then some BASIC on the C=64, then years later I bought an IBM XT and learned asm.
10:58:00 <shapr> Professionally I started with Visual Basic, then Java, then Python, and now Haskell.
10:58:09 <endra> oh and Java
10:58:15 <endra> I keep forgetting the slow one
10:58:42 <shapr> For fun I've played with Oberon, Self, Joy, and other little known languages.
10:58:59 <shapr> I found Oberon to be Wirthwhile.
10:59:01 * shapr grins
10:59:11 <ropine> does c# have higher-order functions?
10:59:37 <glguy> yes, but they aren't as natural to use as they are in Haskell
11:02:12 <shapr> endra: So, have you looked at some of the introductory literature?
11:02:12 <glguy> even C has higer-order functions
11:02:30 <shapr> Would you like a pamphlet advocating type inference?
11:02:48 <ropine> let me rephrase that: does c# have not-totally-brain-damaged higher-order functions?
11:03:00 <glguy> yeah
11:03:41 <shapr> endra: Would you like to see some real code in order to get a better feel for Haskell?
11:04:10 <ventonegro> shapr: take care to not scare him forever
11:04:12 <ventonegro> :-)
11:04:13 <Codex_> what does it require to "have higher-order functions"?
11:04:31 <shapr> oh well
11:04:43 <glguy> A higher order function is one that takes at least one function as an argument, or returns a function as a result
11:04:44 <shapr> I could advocate Haskell for endra's irc client.
11:04:48 <ventonegro> functions that have others as arguments?
11:05:05 <shapr> C isn't that good at catching errors ahead of time.
11:05:08 <ropine> perhaps I should just say "closures"
11:05:16 <glguy> ropine: yeah, C# has closures
11:06:29 <shapr> rehi endra
11:06:30 <endra> meh, internet is being lame these past few days
11:06:33 <endra> rehi yourself
11:06:46 <shapr> Did you see our suggestions?
11:07:03 <endra> last I saw was something about C# high order functions
11:07:10 <x3m> sharp where are you working with haskell professionaly?
11:07:21 <endra> what is a high order function, ropine?
11:07:32 <glguy> A higher order function is one that takes at least one function as an argument, or returns a function as a result
11:07:54 <endra> well there are pointers
11:08:11 <endra> its how the events work
11:08:18 <shapr> x3m: Mina klienter vill att n√•nting fungerar. Det mesta av dem s√§ger att det spelar ingen roll(?) vilken spr√•k jag anv√§nder.
11:08:29 <shapr> eller role som i engelska?
11:08:32 <endra> You give it a function to launch as soon as something occurs
11:08:40 <shapr> Yeah, but a pointer isn't the function itself.
11:08:56 <shapr> The simplest higher order function in Haskell is flip
11:09:21 <shapr> It swaps the order of arguments for a two argument function.
11:09:37 <glguy> It swaps the first two arguments of a multiple argument function :-p
11:09:53 <shapr> and it looks like: flip f a b = f b a
11:09:53 <dolio> What about $?
11:10:00 <dolio> It takes a function and returns... that function.
11:10:15 <glguy> "simplest" is pretty subjective
11:10:19 <shapr> Well, ok.. $ is simpler, but it's not as easily understandable by non-haskellers I suspect.
11:10:31 <dolio> :)
11:11:02 <shapr> endra: Do you understand that?
11:11:20 <shapr> I think endra's internet flaked again.
11:11:20 <endra> gimme a sec to read :P
11:11:27 <shapr> ah, ok
11:11:29 <ropine> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.1 has an example (using Scheme)
11:11:30 <lambdabot> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3.1
11:11:46 <resiak> that's most helpful, lambdabot
11:11:49 <shapr> x3m: talar du svenska?
11:12:11 <shapr> I'm guessing yes from the telia hostname.
11:12:17 <endra> yup.  I understand that
11:12:22 <shapr> mutta... puhutko suomea?
11:12:32 <endra> so if I did flip f a b = f a b, it wouldn't flip it?
11:12:49 <shapr> That's right, it wouldn't flip the arguments. It would still be a higher order function though.
11:13:07 <ventonegro> @translate sv -> en
11:13:08 <lambdabot> Unknown command, try @list
11:13:09 <shapr> It wouldn't be a useful higher order function, but you might learn something from it :-)
11:13:19 <lispy> i need zipWithList :: (a -> a -> a) -> [[a]] -> [a]
11:13:32 <lispy> but it doesn't appear to be in the standard libs
11:13:36 <shapr> ventonegro: I was just saying that many of my clients don't care what language I use as long as the resulting program works.
11:13:44 <lispy> also not sure how to write it...
11:13:49 <shapr> lispy: Explain?
11:13:59 <ventonegro> shapr: that's a fortunate situiation
11:14:05 <ventonegro> situation
11:14:09 <shapr> ventonegro: It's surprisingly common as well.
11:14:11 <glguy> ?type zipWith
11:14:12 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:14:21 <glguy> lispy: I think you still want zipWith
11:14:25 <lispy> instead of [a] and [a] i have [[a]] and i want to sum the lists in parallel
11:14:29 <ventonegro> shapr: not where I work :-(
11:14:39 <shapr> If you wander around and talk to people who need programs written, most of them are not programmers and don't care as long as the result works for them.
11:14:56 <shapr> I'm self employed and I find my own clients. (Or I get really hungry)
11:15:35 <monochrom> Do they worry about finding maintainers in the future?
11:15:40 <shapr> endra: The next most interesting higher order function is based on the idea that if you can apply a function to one item, you can apply that function to a whole list of items and get the resulting list.
11:15:53 <ventonegro> shapr: that's the way I'd like to live, work at home, choose my own tools
11:15:58 <monochrom> Then again they can always find you again.
11:16:04 <ventonegro> but I have a day job
11:16:15 <x3m> shapr: fick besˆk. Vad fˆr sorts grejer dÂ.. softvaruutveckling .. dvs smÂprogram eller?
11:16:18 <monochrom> You can quit your day job :)
11:16:40 <shapr> > map (+1) [1,2,3]
11:16:41 <lambdabot>  [2,3,4]
11:16:42 <glguy> lispy: can I see an examlpe of inputs and outputs
11:16:45 <shapr> endra: Makes sense?
11:16:59 <lispy> oh
11:17:02 <ventonegro> monochrom: but here in Brazil it's not as easy to find people in the streets hungry for softwares :-)
11:17:03 <endra> yup
11:17:04 <shapr> ventonegro: It gets boring. I've been working at home by myself for seven years now and I'm lonely!
11:17:12 <lispy> my versino of (+) can take a list
11:17:16 <endra> so lets see if I got this right
11:17:22 <ventonegro> people usually resort to piracy
11:17:40 <endra> If I want 2, 5, 8, 11, ... I would do:
11:17:42 <shapr> ventonegro: You never know, I've heard that J2ME and SymbianOS phones are popular in Brazil, so why not write a Haskell framework to make that sort of program?
11:17:50 <glguy> > take 4 [2,5..]
11:17:50 <lispy> so actually i need zipWithList :: ([a] -> a) -> [[a]] -> [a]
11:17:51 <lambdabot>  [2,5,8,11]
11:17:52 <endra> > (+1) [3,1..11)
11:17:53 <lambdabot>  Parse error
11:17:58 <endra> > (+1) [3,1..11]
11:17:59 <lambdabot>  add an instance declaration for (Num [a])
11:18:26 <ventonegro> shapr: yeah, cell phones are scaringly popular here
11:18:41 <shapr> ventonegro: So the people on the streets *are* hungry for software.
11:18:49 <shapr> hiya tmoertel!
11:18:49 <lispy> i'm not sure how to define it with other functions but i can now see how to write it recursively...
11:18:55 <tmoertel> hi, shapr!
11:19:00 <shapr> How's code?
11:19:05 <ventonegro> shapr: you got a point :-)
11:19:10 <glguy> lispy: you still want zipWith, it's an a->b->c
11:19:10 <endra> Why isn't that working, shapr?
11:19:17 <glguy> lispy: where a is -> [d]
11:19:24 <abcde`> endra: you need a function; in this case, map
11:19:24 * vincenz snickers http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=386363
11:19:29 <lambdabot> Title: #386363 - [noop] important priority for non-necessary tool - Debian Bug report l ..., http://tinyurl.com/ht87z
11:19:47 <shapr> endra: the .. syntax uses an enumeration, so [1..11] will be from one to elevent, and [1,3..11] will be every other number from one to eleven.
11:19:53 <tmoertel> shapr: pretty good.  I'm just about to get back to Haskell-land after a sojourn in Perl Land for http://pghwpw.org/
11:19:55 <shapr> s/elevent/eleven
11:19:58 <abcde`> > map (+1) [1,4,7,10]
11:19:59 <lambdabot>  [2,5,8,11]
11:20:01 <ventonegro> endra: you where applying a Num a => a -> a function to [a]
11:20:28 <glguy> > zipWith (\a b -> map (+b) a) [[1]] [1]
11:20:29 <abcde`> > map (\x -> x * 3 - 1) [1,2,3,4]
11:20:29 <lambdabot>  [[2]]
11:20:30 <shapr> endra: If you prefer, you could repeatedly apply a function that adds two.
11:20:30 <lambdabot>  [2,5,8,11]
11:20:30 <glguy> lispy ^^^
11:21:04 <glguy> > take 4 $ fix ((2:) . map (+2))
11:21:05 <lambdabot>  [2,4,6,8]
11:21:09 <glguy> > take 4 $ fix ((2:) . map (+3))
11:21:11 <lambdabot>  [2,5,8,11]
11:21:18 <shapr> > take 4 (iterate (+2) 1)
11:21:19 <lambdabot>  [1,3,5,7]
11:21:36 <endra> thats why I think I'll stick to other languages :p
11:21:41 <shapr> endra: why?
11:21:47 <endra> too.. different
11:21:50 <lispy> glguy: i have to think about that, i'm not sure it sums in the direction i want to sum
11:21:57 <shapr> endra: C'mon, don't you want to learn new stuff?
11:22:00 <ventonegro> endra: don't be affraid of "different"
11:22:04 <lispy> glguy: because that map looks suspicious
11:22:04 <glguy> lispy: the point is that you don't need anything more than zipWith
11:22:06 <abcde`> where is your sense of adventure !
11:22:10 <shapr> I promise you that learning Haskell will improve the code you write in C#
11:22:16 <ventonegro> endra: you'll see how it's gonna open your mind
11:22:31 <endra> lol
11:22:36 <shapr> endra: In fact, I would bet you $100 that you will agree with that after you learn Haskell.
11:22:37 <endra> You guys sure a pursuasive
11:22:37 <abcde`> also chicks dig it
11:22:38 <glguy> endra: what's the point of learning a new language if you use it in the same way as all of the other languages that you know??
11:22:47 <endra> lmao abcde` im sure they do
11:23:20 <glguy> endra: If all you want is a replacement for if and while in the form of If and While, Haskell won't be what you are looking for
11:23:21 <endra> glguy: whats the point of using a different one when you can do one with the ones that you current know? one
11:23:28 <ventonegro> abcde`: all the chicks i know only dig Java
11:23:34 <abcde`> :(
11:23:37 <vincenz> ventonegro: or lattes
11:23:38 <shapr> endra: Why do you use C# instead of assembly?
11:23:40 <glguy> endra: some people enjoy learning new things, and finding new ways to solve problems
11:23:56 <endra> cause assembly takes 10 lines to do what I can do in a couple in C#
11:24:07 <shapr> And Haskell takes one line to do what C# takes 10 lines.
11:24:09 <ventonegro> endra: exactly! hehehe
11:24:19 <endra> and perl takes 1 line to do what haskell does in 10 lines
11:24:22 <ventonegro> think sane APL
11:24:24 <endra> but I still dislike perl
11:24:29 <lispy> glguy: zipwith simply doesn't work here
11:24:31 <glguy> endra: not really
11:24:36 <lispy> glguy: the type is just wrong
11:24:37 <shapr> endra: Do you realize that Pugs, the Perl6 implementation is being written in Haskell?
11:24:41 <glguy> lispy:
11:24:44 <glguy> ?type zipWith
11:24:45 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
11:24:50 * shapr grins evilly
11:24:51 <glguy> a can be [Int]
11:24:51 <endra> I don't know what Pugs is, because I am not a perl programmer :-)
11:24:55 <lispy> glguy: i need ([a] -> a) -> [[a]] -> [a]
11:25:01 <glguy> lispy: a can be [Int] and b can be Int
11:25:28 <vincenz> endra: what do you program in
11:25:34 <shapr> endra: Like I said I promise you that learning Haskell will improve your C# skills. If that's not interesting to you, I'll stop bothering you :-)
11:25:39 <glguy> ?type (zipWith :: ([a] -> a -> a) -> [[a]] -> [a] -> [a])
11:25:41 <lambdabot> forall a. ([a] -> a -> a) -> [[a]] -> [a] -> [a]
11:25:47 <glguy> lispy: see ^^
11:25:59 <shapr> I got into Haskell from the Python world.
11:26:02 <lispy> glguy: you're not listening :)
11:26:12 <shapr> I'm always looking for better and more powerful tools.
11:26:15 <glguy> lispy: oh, you want:
11:26:32 <glguy> ?type (map :: ([a] -> a) -> [[a]] -> [a]
11:26:34 <lambdabot> parse error (possibly incorrect indentation)
11:26:35 <glguy> ?type (map :: ([a] -> a) -> [[a]] -> [a])
11:26:36 <lambdabot> forall a. ([a] -> a) -> [[a]] -> [a]
11:26:40 <ropine> endra: when you write programs, what problems are you trying to solve? ("implement shopping-cart Web sites" and "pay the mortgage" are both acceptable answers)
11:26:59 <ventonegro> > concat $ repeat "perl sucks "
11:27:01 <lambdabot>  "perl sucks perl sucks perl sucks perl sucks perl sucks perl sucks perl suck...
11:27:08 <shapr> ventonegro: Hey, Perl 6 doesn't suck.
11:27:12 <shapr> Have you tried it?
11:27:32 <shapr> Much like the latest version of Visual Basic doesn't suck... because it's picked up a lot of the good points of Haskell.
11:27:41 <glguy> > map sum [[1,2],[3,4]]
11:27:43 <lambdabot>  [3,7]
11:27:45 <spiffy> of course perl 6 doesnt suck, its currently written in haskell ;-)
11:27:51 <spiffy> or was
11:27:52 <shapr> This is how the mainstream improves... good ideas migrate into the most popular languages.
11:27:57 <lispy> glguy: i want roughly, zipWithList f aas = f (map head aas) : zipWithList f (map tail aas)
11:28:04 <Cale> > print 5
11:28:06 <lambdabot>  No IO allowed
11:28:08 <Cale> okay
11:28:17 <ropine> "Perl est un esprit LISP dans un corps C, n'est-ce pas?" --Philippe Verdret
11:28:21 <endra> Your bot called me a pervert
11:28:32 <shapr> Languages that have picked up good ideas from Haskell include Python, Perl, and Visual Basic. I can't think of others...
11:28:40 <glguy> lispy: then use: map (zipWith f as) bs
11:28:42 <shapr> ropine: hah!
11:28:44 <abcde`> Perl is lisp's ghost in C's corpse?
11:28:51 <abcde`> that guy is weird
11:28:56 <shapr> Lisp's spirit in a body made of C
11:29:00 <tmoertel> Learning Haskell certainly improves one's Perl skills.  For example, all of my Perl code now looks like this:  perl -e'system(q[ ghc -e"<<haskell code here>>" ])'
11:29:07 * shapr laughs!
11:29:11 * vincenz grins at tmoertel 
11:29:43 <lispy> glguy: i don't think that's right either
11:29:45 <ventonegro> shapr: i think the syntax sucks
11:30:00 <ventonegro> shapr: i know nothing of the internals, just used perl twice
11:30:03 <lispy> glguy: because i need to sum the litss in parallel
11:30:13 <glguy> lispy: do you know about transpose?
11:30:22 <glguy> > transpose [[1,2],[3,4]]
11:30:24 <lambdabot>  [[1,3],[2,4]]
11:30:31 <shapr> ventonegro: I believe that Perl has ideas, approaches and features that make it worth learning. I think that's even more true of Perl 6.
11:30:50 <glguy> > transpose [[1,2,3],[4,5,6]]
11:30:52 <lambdabot>  [[1,4],[2,5],[3,6]]
11:30:55 <vincenz> shapr: ack
11:30:58 <vincenz> shapr: you're nuts
11:31:04 <glguy> > map sum $ transpose [[1,2,3],[4,5,6]]
11:31:05 <lambdabot>  [5,7,9]
11:31:18 <ventonegro> shapr: don't know nothing about the 6.0 version
11:31:21 <glguy> > map sum $ transpose [[1,2,3],[4,5,6],[]7,8,9]
11:31:22 <lambdabot>    The function `[]' is applied to one arguments,
11:31:22 <lambdabot>   but its type `[a]' ha...
11:31:25 <lispy> > transpose [[1..4], [5..9], [10..14]]
11:31:26 <glguy> > map sum $ transpose [[1,2,3],[4,5,6],[7,8,9]]
11:31:26 <lambdabot>  [[1,5,10],[2,6,11],[3,7,12],[4,8,13],[9,14]]
11:31:27 <lambdabot>  [12,15,18]
11:31:29 <ventonegro> s/nothing/anything/
11:31:40 <shapr> vincenz: Nuts? How so?
11:31:56 <vincenz> blegh
11:31:59 * vincenz is going to take a shower
11:32:02 <lispy> > transpose [[1..4], [5..8], [9..12]]
11:32:03 <lambdabot>  [[1,5,9],[2,6,10],[3,7,11],[4,8,12]]
11:32:13 <vincenz> shapr: introduce some into the beauty of haskell, and then with the same voice, recommned perl
11:32:18 <vincenz> shapr: go wash your mouth out
11:32:22 <lispy> ah yes, transpose might work
11:32:29 <ValarQ> @get-shapr
11:32:30 <lambdabot> shapr!!
11:32:31 * tmoertel actually likes Perl
11:32:40 <shapr> vincenz: Dude, have you tried Perl6?
11:32:55 <lispy> glguy: thanks for the transpose idea
11:33:00 <glguy> welcome :)
11:33:19 <ValarQ> shapr: have you tried haskell-mode with 'pretty symbols'?
11:33:31 <shapr> Yes, once or twice. It's pretty!
11:33:48 <shapr> I never got around to mixing .lhs with preview-latex. Do you know if that actually works?
11:34:03 <ValarQ> nope, i'm trying to get it working at all
11:34:19 <shapr> I have some preview-latex screenshots.
11:34:23 <ValarQ> firstly im not sure what code to throw together to get it to work
11:34:24 * spiffy just quit
11:34:25 <spiffy> w00t
11:34:41 <astrolabe> @seen ndm
11:34:43 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 49m 15s ago, and .
11:34:44 <shapr> endra: Anyways, if you have any questions I'd be happy to answer them, but I won't push you (not anymore at least ;-) to try Haskell.
11:34:51 <astrolabe> argggh
11:34:57 <shapr> You screamt?
11:35:07 <ropine> shapr: what languages other than haskell do you use, and what kinds of circumstances make you choose one or the other?
11:35:12 <astrolabe> I just missed ndm :(
11:35:18 * tmoertel pens "screamt" into his dictionary
11:35:28 <shapr> tmoertel: Isn't that a great word?
11:35:34 <shapr> I made it up years ago.
11:35:52 * ropine thinks English needs more strong verbs
11:35:53 <tmoertel> shapr: fabulous word.  For extra emphasis, can you add a "p"?: screampt?
11:35:55 <glguy> sounds british
11:36:03 <ventonegro> somebody make a @dict plugin for lambdabot
11:36:11 <tmoertel> hahaha!
11:36:14 <glguy> ?all-dicts
11:36:34 <glguy> ?versio
11:36:34 * tmoertel laughs because it's true
11:36:34 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
11:36:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:36:44 <ValarQ> shapr: do you have a complete config for it?
11:36:50 <shapr> tmoertel wrote a dictd plugin for lambdabot years ago.
11:36:59 <shapr> ValarQ: Not sure
11:37:08 <glguy> ?dicts
11:37:08 <lambdabot> Supported dictionary-lookup commands:
11:37:08 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
11:37:08 <lambdabot> Use "dict-help [cmd...]" for more.
11:37:21 <glguy> ?devils religion
11:37:24 <lambdabot> *** "RELIGION" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
11:37:24 <lambdabot> RELIGION, n.  A daughter of Hope and Fear, explaining to Ignorance the
11:37:24 <lambdabot> nature of the Unknowable.
11:37:24 <lambdabot>   "What is your religion my son?" inquired the Archbishop of Rheims.
11:37:24 <lambdabot>   "Pardon, monseigneur," replied Rochebriant; "I am ashamed of it."
11:37:26 <lambdabot> [4 @more lines]
11:37:38 <glguy> @more
11:37:39 <lambdabot>   "Then why do you not become an atheist?"
11:37:39 <lambdabot>   "Impossible!  I should be ashamed of atheism."
11:37:39 <lambdabot>   "In that case, monsieur, you should join the Protestants."
11:37:39 <lambdabot>  
11:38:16 <ventonegro> @devils god
11:38:18 <lambdabot> No match for "god".
11:38:19 <shapr> ropine: I mostly get paid to build websites, sometimes I do one shot gigs as well. For websites I mostly build on top of Plone/Zope. Zope is written in Python, so I use it most. I use Haskell for testing via xmlrpc, prototyping of just about everything, and most of my one shot gigs.
11:38:34 <ventonegro> interesting
11:38:48 <shapr> If Haskell had all the libraries that Python had, I'd use it for more of my commercial gigs.
11:39:28 <glguy> ?devils hope
11:39:30 <lambdabot> *** "HOPE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
11:39:30 <lambdabot> HOPE, n.  Desire and expectation rolled into one.
11:39:30 <lambdabot>  
11:39:30 <lambdabot>   Delicious Hope! when naught to man it left --
11:39:30 <lambdabot>   Of fortune destitute, of friends bereft;
11:39:32 <lambdabot> [8 @more lines]
11:39:45 <chessguy> heh
11:39:47 <monochrom> Godawful.
11:39:54 <chessguy> lambdabot quotes poetry now?
11:40:11 <glguy> ?devils children
11:40:12 <lambdabot> No match for "children".
11:40:21 <glguy> ?devils government
11:40:22 <lambdabot> No match for "government".
11:40:33 <shapr> One client wanted 45mb of ms.doc files turned into a custom XML format. Their in-house guy spent more than a month trying to do that with java, javascript and xslt. When he gave up they asked me. I did it in three days by stuffing the files into OpenOffice, and then converting OOo's native xml DTD to their custom DTD with HXmlToolbox.
11:40:58 <dmhouse> Java, Javascript and XSLT?!
11:41:06 <glguy> so you cheated?
11:41:08 <glguy> shameful
11:41:12 <chessguy> shapr, would you like a cookie?
11:41:21 <shapr> No, my client just wanted the resulting XML files, they didn't care about how those files were produced.
11:41:25 <ventonegro> @devils chess
11:41:26 <glguy> cheater
11:41:27 <lambdabot> No match for "chess".
11:41:35 * chessguy slaps lambdabot with a large smelly trout
11:41:37 <dmhouse> What was the Javascript for?
11:41:48 <tmoertel> shapr was smart to leverage OOo as a Word-to-open-format conversion engine.
11:41:50 <shapr> It was used inline amongst the xslt
11:41:53 * lambdabot kicks chessguy in the nuts
11:42:00 * ropine winces
11:42:06 <chessguy> d'oh, Bart!
11:42:19 <ventonegro> lambadot will arrive at sentience sohrtly
11:42:23 <ventonegro> shortly
11:42:28 * glguy forgets that some need explicit <sarcasm> tags
11:42:41 <dmhouse> shapr: any kind of automation for the 'stick it into OOo Writer' section/
11:42:48 <dmhouse> s#/#?#
11:43:25 <ventonegro> has OOo a comand line interface
11:43:27 <ventonegro> ?
11:43:31 <shapr> Yeah, OOo is easy to script with Python, so I wrote a five line thingy that grabbed the files in the named directory and then saved them into another directory in native format.
11:43:57 <shapr> Recently I've been considering a Haskell scripting plugin for OOo so I could autogenerate my monthly bills.
11:44:46 <dmhouse> Wow, there's some amazing piano playing on BBC4.
11:45:29 <ventonegro> someone asked about a haskell DLL in haskell-cafe
11:45:37 <ventonegro> such DLLs come with the RTS?
11:45:58 <SamB> shapr: most people would prefer to do away with their monthly bills...
11:45:59 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
11:46:12 <SamB> @messages
11:46:14 <lambdabot> ndm said 2h 42m 10s ago: Thanks for the patches, most appreciated :)
11:46:51 <shapr> SamB: No I mean the bills I send out to my clients.
11:46:56 <SamB> shapr: ah
11:47:21 <shapr> I'd like to clock in and clock out on a particular project and have everything else done for me.
11:47:38 <SamB> so you would write a combinator language for Word-style documents?
11:47:56 <shapr> I don't know, hadn't gotten that far.
11:47:57 * tmoertel uses Perl/LaTeX to autogenerate invoices from his work logs
11:48:03 <shapr> hmmm
11:48:16 <shapr> Is LaTeX to PDF easy?
11:48:20 <SamB> indeed
11:48:21 <dmhouse> pdflatex :)
11:48:23 <SamB> pdflatex
11:48:30 <tmoertel> shapr: pdflatex is the one-step answer.
11:48:38 <dmhouse> ... is a program you can install from all good package managers.
11:48:52 <chessguy> @messages
11:48:53 <lambdabot> You don't have any new messages.
11:48:56 <chessguy> awwwww.
11:49:02 <dmhouse> ?tell chessguy now you do :)
11:49:03 <lambdabot> Consider it noted.
11:49:08 <SamB> hehe
11:49:09 <shapr> My biggest client also wants an xls file describing the project & hours spent on each.
11:49:47 <chessguy> lambdabot: do i have any messages?
11:49:49 <tmoertel> shapr: I trust that a CSV file would suffice.
11:50:01 <shapr> hm, maybe so
11:50:01 <chessguy> @messages
11:50:02 <lambdabot> dmhouse said 59s ago: now you do :)
11:50:52 <SamB> lambdabot: http://haskell.org
11:51:12 <SamB> hmm. I don't think lambdabot's filters get run on text addressed to lambdabot, command or otherwise?
11:51:22 <SamB> http://haskell.org
11:51:24 <lambdabot> Title: Haskell - HaskellWiki
11:51:58 <hn> yey, first time using mirc!
11:52:05 <shapr> hej hn!
11:52:07 <SamB> @ask dons why lambdabot's filters don't get run on text addressed to it, as in: <chessguy> lambdabot: do i have any messages?
11:52:08 <lambdabot> Consider it noted.
11:52:12 <hn> hej
11:52:19 <hn> svensk?
11:52:29 <shapr> Nej, Jag √§r Alabamsk!
11:52:48 <hn> ofan! men du ‰r r‰tt bra pÂ svenska i alla fall!
11:53:03 <shapr> Jag √§r Amerikansk och bor i Alabama :-)
11:53:03 <hn> nÂn jag k‰nner?
11:53:10 <hn> oj dÂ =)
11:53:22 <dmhouse> What's the Parsec primitive for a character [a..z]?
11:53:48 <glguy> alpha?
11:54:07 <chessguy> dons developed lambdabot?
11:54:12 <glguy> correct
11:54:18 <shapr> hn: Or you could use #haskell.se
11:54:37 <hn> aha ok!
11:54:40 <glguy> http://cvs.haskell.org/Hugs/pages/libraries/parsec/Text-ParserCombinators-Parsec-Char.html
11:54:41 <SamB> chessguy: he started it, he maintains it
11:54:43 <lambdabot> http://tinyurl.com/kjhda
11:55:05 <chessguy> nice
11:55:07 <SamB> at least, I assume he started it ;-)
11:55:11 <chessguy> i thought it was Cale's baby
11:55:25 <shapr> No way
11:55:34 <shapr> Pseudonym started lambdabot years ago
11:55:35 <glguy> lower               = satisfy (isLower)     <?> "lowercase letter"
11:55:39 <dmhouse> Cale runs the #math mbot, which is a lambdabot invocation.
11:55:40 <shapr> And then I was maintaner for years
11:55:42 <glguy> dmhouse: ^^
11:55:44 <shapr> and then passed it on to dons
11:55:50 <chessguy> aha
11:55:54 <dmhouse> glguy: thanks, that's probably what I want.
11:56:01 <dmhouse> mbot: botsnack
11:56:09 <glguy> letter              = satisfy (isAlpha)     <?> "letter"
11:56:27 <chessguy> i wondered why lambdabot didn't go down a few minutes ago when mbot did. i thought they were the same bot
11:56:38 <chessguy> that makes sense though
11:56:45 <dmhouse> mbot: ?botsnack
11:56:57 <dmhouse> Hrm. I thought one could do that.
11:57:05 <dmwit> There's no mbot here...
11:57:28 <SamB> mbot is Cale's, but it is built on lambdabot
11:57:53 <dmhouse> Oh, hehe. Emacs emboldens words it recognises as nicks, but of course, it pulls the list from all the open channels, not just the current one.
11:58:18 <chessguy> so whenever you ask mbot to do a calculation, it really asks lambdabot and then passes on the result?
11:58:29 <vincenz> no
11:58:35 <vincenz> the code of mbot is based on lambdabot
11:58:36 <dmhouse> lambdabot is a program.
11:58:48 <dmhouse> You can download it and run it yourself.
11:58:50 <chessguy> oh, so it's a clone
11:59:07 <dmhouse> mbot and lambdabot are both invocations of lambdabot connected to different channels.
12:00:09 <sjanssen> quiz time:  first person to answer this question without using a Haskell interpreter gets karma
12:00:22 <SamB> so, I can use a compiler then?
12:00:23 <chessguy> 43
12:00:27 <SamB> heh
12:00:27 <sjanssen> what does this snippet do: filterM (const [False, True])
12:00:36 <SamB> mmm
12:00:36 <sjanssen> SamB: no, you may not ;)
12:00:39 <SamB> @type filterM
12:00:41 <glguy> sjanssen: nothing?
12:00:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:00:45 <ropine> [True] ?
12:00:47 <tmoertel> sjanssen:  takes every other element?
12:00:58 <sjanssen> no correct answers yet . . .
12:01:02 <SamB> @type filterM (const [False, True])
12:01:04 <lambdabot> forall a. [a] -> [[a]]
12:01:26 <SamB> oooh
12:01:31 <dmhouse> There's the (a->) monad
12:01:32 <SamB> generates all subsets?
12:01:42 <sjanssen> @karma+ SamB
12:01:43 <lambdabot> SamB's karma raised to 17.
12:01:50 <dmhouse> No way.
12:01:58 <glguy> > filterM (const [False,True]) [1..4]
12:01:59 <chessguy> > filterM (const [False, True])
12:02:00 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
12:02:00 <lambdabot>  Add a type signature
12:02:19 <dmhouse> Oh, right, the sequence, of course.
12:02:32 <sjanssen> I would have also accepted generates every subsequence
12:02:35 <tmoertel> add that one to the wiki
12:03:04 <SamB> ah, subsequence is a better word ;-)
12:03:14 <dmhouse> Sublist?
12:03:20 <ThreeQ> > filterM (const [True, False]) [1..4]
12:03:22 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
12:03:23 <glguy> power-set?
12:03:33 <dmhouse> glguy: lists aren't sets.
12:03:42 <chessguy> > filterM (const [False, True]) [1..2]
12:03:43 <lambdabot>  [[],[2],[1],[1,2]]
12:04:15 <chessguy> > filterM (const [False, True]) [1..3]
12:04:16 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:04:22 <chessguy> interesting order
12:04:34 <sjanssen> next one: \n -> replicateM n [False, True]
12:05:18 <SamB> gives you a list of all lists of n Bools?
12:05:18 <lightstep> ?type replicateM
12:05:20 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
12:05:31 <glguy> > flip replicateM [False,True] 2
12:05:32 <lambdabot>  [[False,False],[False,True],[True,False],[True,True]]
12:05:39 <sjanssen> SamB wins again
12:05:44 <sjanssen> @karma+ SamB
12:05:44 <lambdabot> SamB's karma raised to 18.
12:05:54 <sjanssen> list monad rocks
12:06:11 <SamB> its almost harder to figure out how to say what it does than what it does, sometimes...
12:06:30 <glguy> > mapM (const [True,False]) [1,2]
12:06:31 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
12:06:58 <glguy> > sequence (replicate 2 [True,False])
12:06:59 <chessguy> lol SamB
12:07:00 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
12:07:05 <glguy> that one makes sense
12:07:17 <glguy> and that is why the filter works
12:10:57 <sjanssen> > [0..] >>= flip replicateM "abc" -- now to generate every string composed of a, b, or c
12:10:58 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
12:11:44 <psi> > let gnu s = "GNU's Not Unix" ++ (drop 3 s) in iterate gnu "GNU"
12:11:46 <lambdabot>  ["GNU","GNU's Not Unix","GNU's Not Unix's Not Unix","GNU's Not Unix's Not Un...
12:12:25 <sjanssen> @pl \alpha -> [0..] >>= flip replicateM alpha
12:12:25 <lambdabot> ([0..] >>=) . flip replicateM
12:12:35 <dmhouse> psi, nice :)
12:13:41 <dmhouse> > let god s = s ++ " Over Djinn" in iterate s "GOD"
12:13:43 <lambdabot>  Not in scope: `s'
12:13:54 <dmhouse> > let god s = s ++ " Over Djinn" in iterate god "GOD" -- oops :)
12:13:57 <lambdabot>  ["GOD","GOD Over Djinn","GOD Over Djinn Over Djinn","GOD Over Djinn Over Dji...
12:14:34 <psi> :)
12:14:55 <dmhouse> For any fans of GEB. :)
12:15:15 <psi> ah, I recall something like that.
12:15:26 <svref> do you think its worth while rejiggering recursive calls to be tail-recursive, ala the fasion in Scheme?
12:15:55 <chessguy> GEB?
12:16:09 <psi> g√∂del escher bach
12:16:35 <sjanssen> svref: depends on whether you can benefit from laziness
12:16:52 <psi> chessguy: book by doglas hofstadter about all sorts of cool things
12:17:09 <psi> logic, etc
12:17:20 <svref> sjanssen: hm...I don't know what that means, could you illustrate it maybe using the classic example of defininig "length" for lists?
12:17:37 <sjanssen> svref: you'll want to make length tail recursive
12:17:48 <astrolabe> http://en.wikipedia.org/wiki/Godel_escher_bach
12:17:51 <lambdabot> http://tinyurl.com/e5px3
12:18:46 <sjanssen> > let len' [] acc = acc; len' (x:xs) acc = len' xs (acc + 1) in len' [1, 2, 3] 0
12:18:47 <lambdabot>  3
12:19:03 <svref> sjanssen: okay, so ... you hint there's a case where tail recursion isn't worthwhile...wanna talk about that?
12:19:41 <sjanssen> svref: okay.  consider the function or, which has type [Bool] -> Bool
12:19:48 <lightstep> > foldl' (\x y-> seq x (x+1)) 0 [1,2,3]
12:19:50 <lambdabot>  3
12:20:00 <sjanssen> that returns true if any of the elements are true
12:20:09 <lightstep> > foldl' (\n _ -> n+1) 0 [1,2,3]
12:20:12 <lambdabot>  3
12:20:56 <glguy> or isn't tail recursive?
12:21:00 <sjanssen> > let or [] = False; or (x:xs) = x || or xs in or (True : repeat False) -- see how this terminates
12:21:02 <svref> sjanssen: okay, so you're saying: don't run all the way to the end of the list there, because you'll end up instantiating a really long list
12:21:02 <lambdabot>  True
12:21:51 <sjanssen> > let or [] acc = acc; or (x:xs) acc = or xs (x || acc) in or (True : repeat False) False -- see how this doesn't terminate
12:21:55 <lambdabot> Terminated
12:22:02 <glguy> tail recursion doesn't imply an accumulator, does it?
12:22:11 <monochrom> No.
12:22:37 <sjanssen> glguy: not necessarily, but when you have a choice between tail recursive or not, you're almost always talking about an accumulator
12:22:39 <glguy> then wasn't the first example tail recursive (of or)
12:22:41 <monochrom> But I'm answering literally.  Most of the time you need an accumulator.
12:22:43 <svref> got it.  Thanks.  That was some pretty nice IRC support you gave there.  :)
12:22:46 <ropine> How can I tell from the syntax if a Haskell function is tail-recursive or not?
12:23:00 <sjanssen> glguy: no, the first version was not tail recursive
12:23:06 <glguy> sjanssen: why not?
12:23:19 <glguy> sjanssen: the result depended solely on the last function call
12:23:25 <monochrom> "f args = f (stuff stuff stuff)"  tail recursive
12:23:37 <svref> because the old activation frame had to stick around to perform the '||' after the recursive call to 'or' terminated.
12:23:46 <sjanssen> because the top most application in 'or' wasn't 'or'
12:23:52 <glguy> ok
12:24:20 <ropine> ah
12:25:10 <svref> So I haven't seen ANY discussions of efficiency in Haskell yet...which gets me thinking that maybe this language is good.
12:25:32 <monochrom> Glad you like it that way.
12:25:46 <svref> well it gets me thinking...
12:25:56 <dmwit> Or that people aren't interested in efficiency. ;-)
12:25:58 <Syzygy-> svref: I have seen such discussions. And also, it may possibly be a case of a language being academic enough for the question to be moot - see the lack of discussions of the efficiency of brainfuck. :P
12:25:59 <svref> For example, it took me some time to realize that zip wasn't horrible.
12:26:29 <chessguy> why would you think zip was horrible?
12:26:54 <svref> because in a non-lazy language, it would malloc O(n)
12:28:19 <svref> whereas with lazyness, it may have to malloc as much, but the head of the list might be reclaimed by GC before the customer of zip gets to the tail of the list.  :)
12:28:43 <svref> (do Haskell programmers say "malloc" or "cons"?)
12:28:52 <araujo> http://rafb.net/paste/results/RmuXfV77.html
12:28:55 <araujo> Idea?
12:29:03 <araujo> svens, neither :-P
12:29:05 <dmwit> svref: Maybe allocate?
12:29:33 <Binkley> i'd say "allocate"
12:29:42 <sjanssen> svref: there are special cases where a list that is lazily produced and consumed doesn't have to allocate *any* cons cells
12:30:03 <monochrom> I say "allocate".
12:30:04 <svref> sjanssen: I was hoping to hear that.  Care to name names of compilers?
12:30:19 <sjanssen> svref: GHC does it
12:30:22 <glguy> fusion?
12:30:27 <svref> quick poll: does anyone here not know what I mean when I say "cons"?
12:30:45 <sjanssen> glguy: yeah, it's often called fusion or deforestation
12:30:48 <glguy> (:)
12:31:03 <dylan> Darn convicts! freeing all those mallocs... Arg.
12:31:13 <monochrom> That's an undecidable question, you know.  I know what "cons" means; I may be unaware of what you mean by "cons" if it's different.
12:32:07 <araujo> svref, no "cons" here
12:32:33 <araujo> neither allocate, we don't care of that stuff :-P
12:32:45 <svref> in the old-school lisp world, saying something is 'consy' means it allocates a lot of GC'd heap space.
12:33:23 <araujo> old-school
12:33:40 <glguy> I'm more middle school
12:33:40 <svref> its a handy adjective, and rolls off the tounge better than its C equivalent: "mallocy".
12:34:02 <araujo> read what i said
12:34:48 <ropine> does learning Scheme in the late '80s make me "old-school"?
12:35:15 <dmhouse> _Using_ Scheme is rather old-school in itself.
12:35:42 <ropine> I'm just glad I don't have to use Java these days
12:35:52 <svref> I donno, I learned Lisp at the knees of old Symbolics Lisp machine programmers...they're still thinking of Scheme as "this new ivory tower language" not suitable for real-world use.
12:36:26 <araujo> svref, well, the hting is that we don't often (need to?) use that terminology here
12:36:39 <araujo> we are "free" from it
12:36:43 <dmhouse> (Not saying Scheme is outdated, it's just old. Hell, I'm writing this from Emacs. That's nothing if not old-school.)
12:36:49 <monochrom> araujo: does "instance Val [Char]" work?
12:37:07 <araujo> monochrom, Tried that and nothing :-(
12:37:12 <araujo> I thought it would make it
12:37:20 <svref> araujo: I guess I'm like a depression baby ... can't stop thinking about it.
12:37:31 <monochrom> I'm wondering how "instance Show String" was possible to begin with.
12:37:36 <ropine> well, Scheme doesn't have TAGBODY and GO, so obviously it's not a fully-developed language :-)
12:37:41 <svref> araujo: I recognise that its a waste of time.
12:37:45 <araujo> monochrom, good point
12:37:53 <araujo> monochrom, i admit i wasn't _at_ all aware of this
12:38:32 <araujo> svref, it might have been useful before, but i think we now can live safely free without it.
12:38:52 <monochrom> dmhouse is truely old school.  The only time I saw people IRC in Emacs was 12 years ago.
12:39:16 <dmhouse> But ERC is so convenient!
12:39:24 <glguy> burn!
12:39:29 <dmhouse> Besides, I think shapr uses ERC.
12:39:46 <SamB> indeed he does
12:39:53 <SamB> for CTCP VERSION tells me so
12:40:02 <glguy> PermGen space
12:40:02 <glguy> The server encountered an internal error or misconfiguration and was unable to complete your request.
12:40:05 <glguy> Please contact the server administrator, noc@cpicorp.com and inform them of the time the error occurred, and anything you might have done that may have caused the error.
12:40:08 <glguy> More information about this error may be available in the server error log.
12:40:11 <glguy> Additionally, a 500 Internal Server Error error was encountered while trying to use an ErrorDocument to handle the request.
12:40:14 <glguy> hmm, sorry
12:40:37 <glguy> PuTTY makes is way to easy to paste
12:40:41 <glguy> too*
12:40:48 <glguy> it*
12:40:53 <glguy> .
12:40:58 <monochrom> araujo: for a quick fix, -fglasgow-exts may work
12:41:30 <araujo> oh, nice
12:41:32 <araujo> thanks monochrom
12:41:34 <araujo> mm....
12:41:44 <svref> araujo: I think it will never go fully out of style, since often programs computational complexity can go up a factor of n or more by sloppy heap usage.  But its best to program for clarity first and optimize only if needed.  Nevertheless, I can't help thinking about it as I'm implementing first time... :*(
12:43:56 <monochrom> When I write a program in Haskell, I am aware of its running cost.  I may opt to reduce it immediately, or later, or never.
12:44:43 <araujo> svref, i wouldn't go _that_ far as saying it is going to  disappear any time soon (like assembly) , but we can move (both practically and theoretically) into a new way of looking at programs where we don't have to worry anymore about that to a certain extent. I also think FP (Haskell) is a big step toward that.
12:45:14 <araujo> Even more than other paradigms , such as OO.
12:46:13 <svref> araujo: yes, you're right.  I mean the audacity of strings as linked lists!  Turns out, the world hasn't caught fire yet.
12:47:34 <glguy> but it did get hot enough to inspire Data.ByteString
12:47:55 <monochrom> Ha. OO is most popular among web developers.  Thus we are talking about let's say the customer asks to see his shopping cart and your program needs to sort its items.  Well the shopping cart has 10 items so no one feels bad if you use an EXPONENTIAL time sorting algorithm!
12:48:29 * glguy wonders what named sorting algorithm is bounded by exponential time
12:48:40 <Cale> glguy: try all permutations
12:48:54 <dmhouse> Hah. :)
12:49:00 <glguy> well played
12:49:14 * ropine never ceases to be amazed at what kind of code some people can get paid for
12:49:15 <svref> but I think that's only factorial time
12:49:24 <Cale> Factorial time is exponential time
12:49:37 <svref> Cale: oh yeah.
12:49:43 <ropine> my sense is that programming systems that encourage a more declarative style (going back to SQL) make life drastically easier for the programmer 99.9% of the time, and then 0.1% of the time the optimizer makes a really bad judgement and you need to call in a true wizard to sort things out
12:49:52 <monochrom> Wait, n! is like n^n
12:50:50 <Cale> sqrt(2pi) n^(n+1/2) e^(-n) < n! < sqrt(2pi) n^(n+1/2) e^(-n + 1/12 n)
12:50:59 <svref> for any base b, after b items (!) grows faster than (b^), so ! is faster than exponential.
12:51:41 <monochrom> And who says we don't talk about efficiency?  Hell we *analyse* efficiency!
12:51:57 <norpan> but do we do it effiently?
12:52:00 <norpan> efficiently
12:52:11 <Cale> sqrt(2pi) n^(n+1/2) e^-n is an asymptotic approximation to n!
12:52:59 <norpan> who cares, exponential is bad enough :)
12:53:09 <Cale> > (\n -> (2*pi)**(1/2) n**(n+1/2) exp(-n)) 10
12:53:11 <lambdabot>    Occurs check: cannot construct the infinite type: a = (a2 -> a2) -> a ->...
12:53:18 <Cale> > (\n -> (2*pi)**(1/2) * n**(n+1/2) * exp(-n)) 10
12:53:20 <lambdabot>  3598695.6187410355
12:53:29 <Cale> > product [1..10]
12:53:31 <lambdabot>  3628800
12:55:33 <dmhouse> Scenario: I'm parsing a type in my LC interpreter, based on a small but recursive grammar, which is basically "Top", "Bool", record types like "{x:Bool,y:Top,z:Top}" and arrow types like "Top->Bool".
12:55:48 <dmhouse> With the exception of the last one, that's an L1 grammar. Any sneaky ways of getting around that?
12:55:57 <Spark> has anyone used http://coq.inria.fr/
12:55:59 <lambdabot> Title: The Coq proof assistant
12:56:18 <monochrom> The following is fiction - for now, I'm sure in 5 years it will become a true story featured on dailywtf.com.  Some monkey codes a sorting algorithm (nevermind the fact that you should just call the library), and it "sometimes sort funny".  His solution: throw in a randomization and keep trying, i.e., while the list is not sorted, permute randomly, sort.
12:56:43 <Spark> i wish it was named differently, at the moment it sounds like a cross between a new experimental class A drug and a phallus
12:57:20 <ropine> http://en.wikipedia.org/wiki/Bogosort
12:57:50 <monochrom> It makes me think of Cod fish.  Fish and chips yummy.
12:57:59 <dmhouse> The way I'm currently parsing is using 'choice [ string "Top", string "Bool", etc. ]', but that strategy isn't going to work for the arrow types.
12:58:09 <Spark> the next proof i will do, i will try using it :)
12:58:11 <dmhouse> Another thing worth mentioning is that there are no spaces in the grammar.
12:58:16 <glguy> I knew bogosort sucked, but it's time complexity can not be tightly bound
12:58:31 <dmhouse> Finally, I can change the grammar if necessary, but those four types need to be supported.
13:00:19 <astrolabe> Spark: basti was talking about it the other day
13:00:47 <monochrom> Suppose I have a language { "5", "5+5" }.  How do I parse it?
13:01:32 <monochrom> I'll first write the grammar like this.  Exp ::= Add.  Add ::= Num {"+" Num}.  Num ::= "5".
13:02:05 <monochrom> Then it is easier to see how I can map that to say Parsec.
13:02:33 <dmhouse> Right.
13:02:47 <dmhouse> Where { ... } indicates an optional part?
13:02:51 <monochrom> Yes.
13:03:08 <dmhouse> That'll work, I guess. Thanks :)
13:04:11 <monochrom> I learned this from the back of K&R.
13:09:20 <chessguy> what is K&R? i've heard several references to this lately
13:10:02 <ropine> Kerninghan & Richie (sp?), the classic C manual
13:10:16 <chessguy> ah, thanks
13:10:26 <chessguy> SO 20th century
13:12:25 <defcon8> if I do "data Pair a a = Pair aa", would they have to have the same type?
13:12:48 <monochrom> Yes.
13:12:50 <dmhouse> defcon8: Assume you mean 'data Pair a a = Pair a a', and I believe it'd be a syntax error.
13:13:05 <defcon8> dmhouse, yeah, sorry
13:13:06 <dmhouse> You probably mean 'data Pair a b = Pair a b'
13:13:11 <defcon8> oh
13:13:17 <defcon8> but how do I infer they must be the same type?
13:13:23 <monochrom> Or "data Pair a = Pair a a"
13:13:34 <Syzygy-> Hmmm. Is it at all possible to define new types in ghci?
13:13:37 <dmhouse> monochrom's version would force the components to be the same type.
13:13:46 <monochrom> No, not in ghci.
13:13:52 <Syzygy-> Dangit...
13:13:59 <defcon8> I'm reading yaht atm
13:14:01 <monochrom> Very unfortunate.
13:14:02 <dmhouse> Syzygy-: import a file?
13:14:20 <Syzygy-> Wouldn't > data Pair a b = Pair a b < be a pair of possibly different types?
13:14:33 <monochrom> With SML or OCaml you can manually type in a whole module at the prompt :)
13:14:34 <Syzygy-> dmhouse: I know that route, but I couldn't be bothered creating a file to play around with this now.
13:15:39 <glguy> Syzygy-: yes it would be
13:15:56 <monochrom> I use Emacs, so that process is less bothersome.
13:16:07 <defcon8> okay from what I have read, for both a and b to be the same type it'd be "Pair a = Pair a b"
13:16:12 <defcon8> well
13:16:17 <defcon8> data Pair a = Pair a b
13:16:17 <glguy> Pair a a
13:16:24 <monochrom> "data Pair a = Pair a a" for the second time.
13:16:51 <glguy> the 'a' in Pair a a represents the type of the argument, not the name
13:16:53 <defcon8> so why isn't it Pair a a = Pair a a?
13:16:54 <norpan> maybe it's easier to understand if you have different identifiers for the type and the constructor
13:17:06 <glguy> defcon8: a is a type variable, not a name
13:17:13 <norpan> err, for the type constructor and the data constructor
13:17:32 <monochrom> Suppose you want a function that takes a number x and returns x+x.  How would you write it?
13:17:36 <monochrom> 1. f x = x+x
13:17:40 <monochrom> 2. f x x = x+x
13:17:50 <defcon8> 1
13:17:58 <monochrom> That answers your question.
13:18:07 * glguy doubts that ;)
13:18:17 <defcon8> but I want two different values of the same type
13:18:35 <glguy> the 'a' in data Pair a isn't a value! it's a type
13:18:39 <monochrom> At the type level you worry about types not values.
13:18:47 <norpan> i think you are confused because the name is Pair
13:18:57 <norpan> try Pair a = PairConstructor a a
13:19:16 <norpan> the type is Pair a, a value of type Pair Int is PairConstructor 1 2
13:19:33 <monochrom> Do you know C++?
13:19:36 <defcon8> kind of
13:19:58 <defcon8> oh I get it now
13:20:14 <monochrom> In C++ it is not going to be template<class A, class A> struct Pair { ...
13:20:51 <defcon8> how do I only let ints be put in the pair?
13:21:04 <norpan> data Pair = Pair Int Int
13:21:14 <monochrom> No wonder C++ is so popular and fervantly defended.  It's a magic spell!  You cast it and everyone understands everything!
13:23:06 <chessguy> stroustrup must have sold his soul to the devil
13:24:37 <defcon8> how do I define a data structure on ghci?
13:24:59 <kpreid> put it in a file and :load it
13:25:14 <kpreid> oh, actually...
13:25:20 <monochrom> Very unfortunately.
13:25:20 <kpreid> 'scuse me while I test something...
13:28:26 <defcon8> kpreid, ping
13:29:02 <kpreid> defcon8: enter this into ghci:
13:29:09 <kpreid> :def data \t -> do writeFile "Datai.hs" ("module Datai where data " ++ t); return ":load Datai.hs"
13:29:28 <kpreid> :data Pair a = Pair a a deriving (Read, Show, Eq)
13:29:41 <kpreid> that'll work :)
13:29:58 <monochrom> Godawful
13:32:50 <kpreid> defcon8: this is just defining a new ghci command which puts a data declaration in a file and loads it
13:33:10 <defcon8> I have haskell-mode on emacs, I just remembered
13:33:49 <monochrom> Yeah use Emacs :)
13:46:18 <svref> data X = Foo | Bar -- how come I can't export Foo or Bar in my module declaration?
13:47:18 <defcon8> would "data Pair a b c = Pair d e f" be valid?
13:48:06 <kpreid> defcon8: try it.
13:49:25 <wilx> svref?
13:49:47 <svref> Ah, I see "export (X(Foo,Bar))"
13:49:48 <wilx> module Mod (X(..))?
13:50:08 <wilx> Two dots export whole type.
13:50:10 <svref> wilx: thanks
13:51:34 <monochrom> module Mod (X(Foo,Bar))
13:55:03 <defcon8> data Quadruple a b = Quadruple a a b b
13:55:03 <defcon8> quadrupleFst (Quadruple a b c d) = [a,b]
13:55:07 <defcon8> what's wrong with this?
13:55:57 <monochrom> First line good.
13:56:00 <astrolabe> confusing variable/type names?
13:56:20 <kpreid> defcon8: nothing
13:56:27 <defcon8> why will it not work?
13:56:29 <kpreid> that ghc cares about
13:56:30 <monochrom> Second line good.
13:56:37 <defcon8>     The function `quadrupleFst' is applied to five arguments,
13:56:38 <defcon8>     but its type `Quadruple a b -> [a]' has only one
13:56:38 <defcon8>     In the definition of `it': it = quadrupleFst Quadruple 2 4 [1] [7]
13:56:53 <kpreid> ah, see, the definition is fine, your usage is wrong
13:57:12 <defcon8> how do you mean?
13:57:14 <monochrom> Use parentheses, obviously.
13:57:25 <defcon8> oh yeah
13:57:42 <kpreid> defcon8: whenever GHC tells you about argumrnt counts, assume you need some parentheses
13:57:48 <kpreid> Or some $.
13:58:22 <defcon8> actually
13:58:28 <defcon8> what's wrong with the parentheses?
13:58:29 <kpreid> > let quadrupleFst (a,b,c,d) = [a,b] in quadrupleFst $ (,,,) 2 4 [1] [7]
13:58:30 <lambdabot>  [2,4]
13:58:46 <defcon8> yaht hasn't told me about $ yet
13:58:52 <kpreid> defcon8: don't worry about $ then
13:58:58 <defcon8> so what should I do?
13:59:03 <kpreid> what's wrong is that Quadruple is a function like any other
13:59:10 <kpreid> (besides being a constructor)
13:59:20 <kpreid> therefore, you are not applying it to any arguments
13:59:42 <kpreid> look at the definition of quadrupleFst; put parentheses in the same place in using it
14:00:10 <cge> defcon8: $ is mainly for convenience. a $ b c is the same as a (b c)
14:00:48 <defcon8> I'm just doing what's in the book
14:01:38 <defcon8> I don't see what could be wrong here
14:02:03 <glguy> > filterM (\x -> guard (x < 5) >> Just True) [1..10]
14:02:05 <lambdabot>  Nothing
14:02:14 <glguy> > filterM (\x -> guard (x < 11) >> Just True) [1..10]
14:02:16 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10]
14:02:18 <defcon8> oh
14:02:20 <defcon8> usage
14:02:40 <defcon8> so why aren't there parens around the inside-most set?
14:02:43 <defcon8> of arguments
14:03:11 <kpreid> defcon8: parens don't go around arguments, they go around applicatioons
14:03:26 <defcon8> around things that need to be evaluated?
14:03:53 <kpreid> um, no
14:04:02 <astrolabe> g (f x) rather than g(f(x))
14:04:46 <kpreid> the expression "a b c" is equivalent to "(a b) c". so we put parentheses when we want to apply b to c, rather than applying (a b) to c.
14:05:23 <kpreid> and you want to apply Quadruple to some arguments, rather than applying quadrupleFst to Quadruple and some more arguments
14:07:36 <defcon8> how do I do comments?
14:07:38 <ndm> @seen SamB
14:07:39 <lambdabot> SamB is in #perl6 and #haskell. I last heard SamB speak 1h 27m 45s ago.
14:07:45 <SamB> ndm: hi
14:07:47 <ndm> defcon8: -- comment, {- comment -}
14:07:49 <SamB> you want some more?
14:07:51 <defcon8> thanks
14:07:56 <ndm> hi SamB, just wanted to say thanks for the patches
14:08:07 <SamB> I got your message ;-)
14:08:20 <ndm> if you have more patches, of course send them over :) - i can't apply them for another 12 hours, but will do as soon as i get into the office
14:08:55 <ndm> i'm not sure if you realised this or not, but some of the functions are not even in the haddock at all
14:09:03 <ndm> since they don't have explicit type signatures
14:09:07 <SamB> yeah
14:09:10 <SamB> I have a patch for that too
14:09:14 <ndm> ah, neat :)
14:09:31 <ndm> you can open Yhc in Hugs easily enough - just specify a few extra include directories
14:09:38 <ndm> then its just a case of :t on all the functions
14:09:44 <SamB> mmhmm
14:10:37 <SamB> I have a patch to Sconstruct that adds -fwarn-missing-signatures to HSFLAGS ;-)
14:10:55 <ndm> incidentally, thats how i review your patches - check they hit the right places, then open in WinHugs and check it still loads :)
14:11:21 <ndm> that would be interesting, does it only warn on missing signatures that are exported?
14:11:33 <SamB> I'm not quite sure
14:12:16 <ndm> i'll just check...
14:15:08 <defcon8> Write a datatype Tuple which can hold one, two, three or four elements,
14:15:10 <defcon8> depending on the constructor (that is, there should be four constructors, one for each
14:22:32 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
14:22:32 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
14:22:44 <defcon8> am I wrong?
14:23:05 <cge> defcon8: I don't know what you mean by it holding a structure and not the actual elements.
