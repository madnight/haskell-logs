00:00:25 <dons> index
00:00:39 <dons> @type (Data.Array.!)
00:00:40 <lambdabot> forall e i.
00:00:40 <lambdabot>       (GHC.Arr.Ix i) =>
00:00:40 <lambdabot>       GHC.Arr.Array i e -> i -> e
00:00:51 <dons> ^^ maybe that syntax should be changed for haskell'
00:00:56 <dons> so we can write: Data.Array.(!)
00:01:35 <dons> the type tells you :) you give an array of i's to e's and i, and it gives you back an 'e' :)
00:01:42 <Saulzar> Also for Foo.`bar`?
00:01:53 <dons> you think? not so sure about that one
00:02:27 <Saulzar> Well, it seems consistant to go one way or the other
00:02:35 <dons> as `` are a kind of parens in some sense
00:03:03 <dons> yeah. hmm. the current system is more consistent in that sense
00:03:28 <dons> but there's some association between () and symbols, not alpha numerics
00:04:12 <dons> people seem to get it wrong fairly often, anyway
00:04:22 <dons> which makes me wonder if it is the right thing :)
00:06:57 <kzm> I always felt it was somehow unnatural to parenthesize the alpha qualifiers.
00:07:19 <kzm> (Of course, it [Data.Array.(!)] is an error you only do once)
00:07:58 <kzm> The question is what to do when you have a symbol for a module name :-)
00:08:25 <kzm> Data.(#).foo ?  `Data`.#.`foo`? :-)
00:08:49 <dons> but you can't have a symbol :) if only !
00:09:37 <dons> since we now have infix and symbol tycons , maybe its time for infix and symbol module names :)
00:10:58 <rizzix> is there something like liftM2 for non monadic types?
00:11:06 <kzm> import (foo) Data.#  (bar) 
00:11:16 <kzm> ^- infix module name
00:11:30 <dons> @type Monad.liftM2
00:11:31 <lambdabot> forall r (m :: * -> *) a2 a1.
00:11:31 <lambdabot>       (Monad m) =>
00:11:31 <lambdabot>       (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:11:49 <dons> @hoogle (a -> b -> c) -> a -> b -> c
00:11:51 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
00:11:59 <int-e> id
00:12:13 <rizzix> can't be id
00:12:26 <rizzix> @pl \n -> g (x n) (y n)
00:12:28 <lambdabot> liftM2 g x y
00:12:32 <rizzix> >.<
00:12:35 <int-e> @type id :: (a->b->c)->a->b->c
00:12:37 <lambdabot> (a->b->c)->a->b->c :: forall a b c.
00:12:37 <lambdabot>           (a -> b -> c) -> a -> b -> c
00:13:01 <int-e> @type (+) :: (a->b->c)->a->b->c
00:13:02 <lambdabot>   Couldn't match the rigid variable `a' against `a -> b -> c'
00:13:02 <lambdabot>   `a' is bound by the polymorphic type `forall a b c.
00:14:14 <davidhouse> rizzix, that will work anyway
00:14:27 <davidhouse> > liftM2 (&&) even odd 10
00:14:28 <lambdabot> False
00:14:37 <rizzix> ic
00:14:47 <davidhouse> because functions of type (->a) form a monad.
00:15:01 <adu> how would you format something like "let a = b; c = d in e"?
00:15:08 <dons> @djinn (a -> b -> c) -> a -> b -> c
00:15:09 <lambdabot> f a = a
00:15:12 <adu> on multiple lines?
00:15:21 <davidhouse> adu, yeah.
00:15:21 <dons> djinn?
00:15:33 <adu> how would you format it on multiple lines?
00:15:47 <adu> like:
00:15:48 <davidhouse> put the c underneath the a. use spaces.
00:15:49 <adu> let
00:15:52 <adu>   a = b
00:15:54 <adu>   c = d
00:15:56 <adu> in
00:15:57 <adu>   e
00:15:58 <adu> ?
00:16:07 <davidhouse> no.
00:16:11 <davidhouse> let a = b;
00:16:13 <davidhouse> c = d
00:16:13 <dons> I'd put a = b on the same line as the let, and e on the line as the 'in
00:16:14 <davidhouse> in e
00:16:20 <adu> ok
00:16:20 <dons> right
00:16:27 <dons> and no ; :)
00:16:41 <davidhouse> @where pastebin
00:16:42 <lambdabot> I know nothing about pastebin.
00:16:48 <adu> sorry
00:16:53 <davidhouse> dons, you need one when using lets, don't you?
00:17:06 <dons> nope
00:17:18 <dons> you never need ;
00:17:50 <dons> ah, I see, djinn wanted to use 'id' too :) good djinn
00:18:39 <dons> @djin a -> a
00:18:39 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-
00:18:39 <lambdabot> ver
00:18:43 <dons> @djinn a -> a
00:18:43 <lambdabot> f a = a
00:18:55 <dons> \djinn-add id :: a -> a
00:20:18 <dons> \djinn a -> a
00:20:18 <lambdabot> f = id
00:21:14 <dons> @hoogle (a -> b -> c) -> (a -> b -> c)
00:21:15 <lambdabot> No matches, try a more general search
00:21:31 <dons> bah
00:22:01 <Cale> @djinn (a -> b -> c) -> (a -> b -> c)
00:22:02 <lambdabot> f a = a
00:22:20 <dons> djinn not so smart :) doesn't know how to unify
00:23:50 <rizzix> btw.. liftM2 (&&) even odd 10 gives me an error with ghci 6.4.1
00:24:30 <rizzix> no instance for (Monad ((-)) a)  ...
00:25:11 <Saulzar> It's hidden in Control.Monad.Reader
00:28:37 <dons> good point. it really is hidden away, considering how @pl resorts to -> a all the time :)
00:30:14 <dons> instance Monad ((->) r) where should really be in the standard Control.Monad. it feels more important than its current location would suggest.
00:30:53 <dons> it's out of place in Reader, too. strange.
00:31:03 <Cale> hm?
00:31:08 <Saulzar> Lambdabot makes more use of it than most I think :)
00:31:15 <Cale> The reason that it's in Reader is that it's isomorphic to the Reader monad
00:31:24 <Cale> but I agree
00:31:30 <Cale> it ought to be in the prelude :)
00:32:26 <dons> well... maybe :)
00:32:51 <dons> anything that looks this beautiful should be in the base libs, for sure:
00:32:52 <dons> instance Functor ((->) r) where
00:32:58 <dons>     fmap = (.)
00:33:24 <dons> instance Monad ((->) r) where
00:33:25 <dons>     return  = const
00:33:26 <dons>     m >>= k = \r -> k (m r) r
00:33:36 <dons> and that's it. definitely Prelude-ish
00:33:37 <JohnMeacham> dons: indeed. and the Monad instance from Control.Monad.Reader too. a real reason they should be included is to avoid the antimatter problem if two independent libraries declare the same instance.
00:34:13 <dons> ah, the antimatter problem, very true.
00:34:43 <JohnMeacham> which is surprisingly not as much of an issue as one would think. I believe it is because haskell types and classes tend to be based on solid foundations which pretty much limit the instance to a single obvious one.
00:34:55 <dons> yep
00:34:57 <JohnMeacham> solid theoretical foundations I mean.
00:35:22 <dons> exactly.
00:36:34 <dons> Monad [] is in GHC.Base, probably Monad (-> a) should be too, then. the latter is shorter and more elegant :)
00:37:31 <JohnMeacham> GHC really needs general recursive modules so everything doesn't keep migrating to GHC.Base.
00:37:48 <dons> maybe we can gather a couple of extra arguments, and submit a patch to, say, Control.Monad, lambdabot would be very happy.
00:38:25 <dons> people would be able to copy obscure @pl results without type errors :)
00:38:27 <JohnMeacham> is that a valid haskell 98 instance?
00:38:58 <mwc> Sigh, this is *almost* tail recursive, and I just don't know how to push it the rest of the way, could somebody take a look? http://www.nomorepasting.com/paste.php?pasteID=59102
00:38:58 <JohnMeacham> well, putting it in GHC.Base would mean people would get it in haskell 98 mode. which is probably not wanted.
00:39:27 <JohnMeacham> but -fglasgow-exts could also import an extended prelude that just includes new instances.
00:39:48 <JohnMeacham> in any case, you might want to create a ticket on the haskell-prime wiki.
00:40:14 <dons> I would think it would go into Control.Monad, or maybe even Control.Monad.Function, rather than any GHC.* module
00:42:48 * shapr boings
00:43:37 <JohnMeacham> Isn't it already there?
00:43:42 <JohnMeacham> Control.Monad.Reader
00:43:50 <JohnMeacham> s/^/in 
00:48:01 <dons> it's in the mtl lib, in Control.Monad.Reader, which is a bit obscure
00:48:22 <dons> the argument is that it feels like a far more fundamental monad
00:48:29 <dons> and should be with Maybe and [a]
00:49:26 <JohnMeacham> mtl is pretty fundamental for everything I do :) but yeah, the reason it is probably not somewhere else is haskell 98 compatability.
00:50:46 <JohnMeacham> we can probably move it in for haskell-prime.
00:51:05 <dons> yeah, i'l create a ticket
00:54:19 <Saulzar> mwc, instead of return $ (x1,n) : rest you might add another parameter and accumulate the result eg. countAtoms (x2:xs) ((x1, n) : accum)
01:02:20 <adu> how do you compose a function from a list?
01:03:07 <adu> like turn [a, b, c] into \x -> f a (f b (f c x))
01:04:26 <Oeje1> adu: Perhaps with foldr?
01:04:42 <adu> lol, i'm always forgetting about that
01:05:25 <adu> thanxx
01:11:31 <adu> yey
01:11:41 <adu> i think i figured out how to doit
01:12:24 <adu> how to do a row-reduction:
01:12:26 <adu> foldr oneize (foldr zeroize a zeroizelist) oneizelist
01:12:35 <adu> :)
01:47:19 <shapr> lisppaste2: url
01:47:19 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:47:54 <maus> hello anyone
01:48:05 <adu> hi
01:48:15 <maus> does anybody know, can i capture sound using openAL binding?
01:49:43 <Lemmih> Can OpenAL capture sound?
01:49:51 <maus> yes
01:50:12 <maus> but binding seems lack several functions
01:51:20 <maus> http://www.haskell.org/HOpenGL/newAPI/OpenAL/Sound-OpenAL-ALC-Capture.html
01:52:52 <maus> compared to
01:52:56 <maus> http://openal.org/openal_webstf/specs/OpenAL1-1Spec_html/AL11Spec6.html
01:53:34 <Saulzar> Maybe they've been combined with another interface somewhere
01:53:45 <adu> somewhere...
01:54:07 <maus> the question is where :)
01:55:52 <maus> in sources of ghc-6.4.1 i dont evan see libraries/OpenAL/Sound/OpenAL/ALC/capture.hs
01:56:30 <Lemmih> It's good to know that the testsuite is keeping GHC bug-free: "1384 total tests, which gave rise to 5053 test cases, of which 4595 caused framework failures [and] 1037 were skipped."
01:56:43 <Lemmih> maus: The OpenAL bindings aren't in 6.4.1.
01:57:24 <Saulzar> Haha, what? Are there any which don't fail?
02:00:47 <maus> but online documentation states it must be where
02:00:59 <maus> Lemmih: what's covered by these tests?
02:01:05 <dcoutts> mauke, the OpenAL bindings are in 6.4.1
02:01:35 <dcoutts> I've built them (we had to patch it to make it build)
02:01:49 <maus> dcoutts: i know, i did see it in sources
02:02:15 <dcoutts> maus, oh sorry, it's Lemmih who's confused
02:02:39 <Lemmih> Hm, yeah, I guess I am.
02:03:17 <maus> dcoutts: so is it functional in 6.4.1 without patches?
02:03:36 <dcoutts> didn't compile for recent versions of OpenAL for us
02:03:45 <dcoutts> you can grab the gentoo patch
02:04:31 <dcoutts> http://www.gentoo.org/cgi-bin/viewcvs.cgi/*checkout*/dev-lang/ghc/files/ghc-6.4.1-openal.patch?rev=1.1
02:10:24 <maus> i'm compiling using portage
02:10:24 <maus> i saw this patch was applyed
02:10:24 <maus> now i just have to wait..
02:12:27 <dcoutts> maus, yep, you want ghc-6.4.1-r2
02:12:35 <dcoutts> with USE="openal"
02:13:04 <dcoutts> we're about mark ghc-6.4.1 stable in gentoo on x86, amd64, sparc & ppc
02:17:05 <maus> dcoutts: i'm building it now. But does it include capturing facilities?
02:17:34 <dcoutts> mauke, capturing facilities?
02:17:37 <dcoutts> oh OpenAL
02:17:39 <dcoutts> no idea
02:17:48 <dcoutts> check the api
02:21:42 <maus> OpenAL does include it. But where is something strange with haskell binding. According to http://www.haskell.org/HOpenGL/newAPI/OpenAL/Sound-OpenAL-ALC-Capture.html it is half-complete
02:28:55 <adu> i'm getting a wierd error
02:29:24 <adu> it says: Program error: {add_skew [[],cross_product_v1472 instNum_v33 m_0 (m_divn 2 [1] [0,9])] ++ map_v622 (cross_product_v1472 instNum_v33 m_0) (m_div (m_subcarry [1] (m_times (m_divn 2 [1] [0,9]) [0,9])) [Num_fromInt instNum_v33 0,0,9])}
02:31:20 <lisppaste2> adu pasted "superlog" at http://paste.lisp.org/display/17858
02:31:31 <adu> oh wow that was cool
02:33:51 <adu> i think its an error coming from BigFloat
02:34:00 <adu> http://medialab.freaknet.org/bignum/
02:47:15 <dcoutts> mwc, thanks for the patch
02:52:21 <ski> (adu : 'let compose = foldr (.) id in compose . map f' ? (for the compose over list))
02:54:10 <adu> oh
02:54:12 <adu> ok
02:54:13 <adu> thanx
02:54:34 <ski> @type foldr (.) id
02:54:35 <lambdabot> forall a. [a -> a] -> a -> a
02:55:28 <ski> @type flip (foldr ($))
02:55:29 <lambdabot> forall b. [b -> b] -> b -> b
02:56:19 * ski sometimes defines 'compose' and 'composeMap'
03:21:44 <ski> (adu : did you figure that error out ?)
03:27:00 <sowhat> hello! anyone familar with runhaskell / runghc? i would like to have a sort of runghci, which can i specify the code to run and then return in a interpreter (ghci) setting.
03:29:07 <Saulzar> sowhat, Well you can just run ghci Somefile.hs and it will load it
03:30:25 <sowhat> yes, but it would 'autoload' and evaluate my 'start code'
03:31:17 <sowhat> i would like to wrap my app around ghci
03:31:37 <Lemmih> ghc -e 'expr'?
03:31:56 <sowhat> passing is some cmd line argument if possible, giving it a starting state and then letting the user interact with an ghci style
03:32:24 <sowhat> Lemmih, that only evaluate an expression and exits. i would like to stay in ghci mode
03:32:40 <sowhat> and ghc -e --interactive doesnt work
03:32:59 <sowhat> i mean ghc -e 'expr' --interactive 
03:33:40 <Lemmih> Why do you want that?
03:38:01 <sieni> I have always wondered, why many people answer "Why do you want to do that?" when they are really saying "I don't know".
03:39:31 <Saulzar> Often you can do much better when you know the motivation...
03:40:40 <Saulzar> Is it possible to write a shell script to run ghci and pass some input via stdin? (ie. run main or something)
03:41:17 <pierre-> hello
03:42:03 <MarcWeber> I get this error when trying to compile ghc. unkown package: readline. When trying to make it manually it can't find module Prelude. But I don't have the prelude (fptools/ghc/lib/prelude.. ) Do I have to get it, then?
03:44:35 * MarcWeber has to restart his computer
03:44:38 <sowhat> Lemmih, Si\Uni, Saulzar: i would like to a ghci like interface to my combinator library. without needing to write an complete interpreter. i would be fun to have the option to preset some often used item, like outdirectory.
03:45:47 <eivuokko> I played around with win32 debugging functions, and had fairly similar problem
03:46:09 <eivuokko> ghci is sort of ok interface to debugger.
03:52:07 <sowhat> echo ":l Main" | ghci , does load Main.hs but quit right away
03:53:32 <sowhat> my idea is to get a sort of plugs (from the hs-plugins paper)
03:54:44 <sieni> of course it exits immediately, since your echo command emits end-of-file to the pipe after giving the load command.
03:56:40 <sieni> sowhat: it might work better if you put your initial input into a file and then say "cat file /dev/stdin | ghci"
03:57:42 <sieni> although then the ghci doesn't understand that you are chatting with it from the console, so the line editing features are fubar
04:00:31 <MarcWeber> Does anyone know how to compile ghc on linux?
04:01:18 <sowhat> sieni, yes that is getting me somewhere
04:02:04 <sieni> sowhat: you probably need a pty or something in between, so that ghci thinks it's connected to a terminal
04:07:17 <sieni> sowhat: a program called "expect" probably can do exactly what you need
04:20:27 <sowhat> sieni, thanks seems to be useful (but only on linux).
04:23:28 <dons> Saulzar, yes you can pass ghci input from stdin. but it's not that useful. what are you trying to do? run a haskell script as a shell script?
04:23:42 <dons> MarcWeber, yes, to compile ghc you type: make :)
04:23:54 <dons> better for linux is to just download a binary though..
04:25:30 <MarcWeber> dons I want to try the latest ghc.. Because I want to compile wash.. And there has been a bug which causes ghc to take endless time compiling one file (>30min).. 
04:27:44 <sowhat> dons, i was actually asking for it.
04:28:38 <sowhat> dons,  i would like to wrap ghci in my own app, creating a sort of interpreter for working with my small combinator lib.
04:29:43 <sowhat> so the user can start of with a preset ghci environment, with some preloaded/parsed values and a nice startup logo (the latter can be done in a shell script, i know)
05:05:25 <kaydara> can someone tell why this dont work ?
05:05:27 <kaydara>         | x == "&"      =       0
05:05:28 <kaydara>         |otherwise      =       1 + indexOf xs
05:06:42 <dcoutts> you'll have to tell us the error message
05:06:42 <tromp_> indexOf needs 2 args?
05:06:50 <dcoutts> @type indexOf
05:06:51 <lambdabot> Not in scope: `indexOf'
05:07:02 <tromp_> and ""&" shld be '&' ?
05:07:29 <dcoutts> if x is a Char rather than a String
05:07:48 <kaydara> was the '' that was missing
05:08:43 <tromp_> i mean it's nicer to define indexOf c string and then use indexOf '&'
05:08:57 <kaydara> thkx tromp_ and dcoutts 
05:09:10 <kaydara> humm
05:09:33 <kaydara> you are right
05:09:36 <tromp_> there's also List.elemIndex
05:09:44 <tromp_> doing the same
05:09:59 <kaydara> school work, trying not to use the functions
05:18:32 <shapr> sowhat: Hey, I spoke to one of the guys involved in Haskell' about the FilePath module, did you have any specific requests?
05:19:43 <sowhat> not really, mostly that there are functions for the obvious platform (in)dependent path handling
05:19:55 <sowhat> split path, concat path etc
05:21:03 <SamB> man, IDA Pro is cool
05:21:13 <shapr> sowhat: ok
05:21:16 <shapr> SamB: what's that?
05:21:27 <shapr> oh, disasm?
05:23:25 <dons> \y0w!
05:23:26 <lambdabot> Catsup and Mustard all over the place!  It's the Human Hamburger!
05:23:55 <SamB> yeah, that
05:24:02 <SamB> I downloaded the trial version
05:24:42 <SamB> my version of WINE doesn't seem to handle it too well, but well enough for me to go "sweeeet"
05:24:57 <kaydara> http://www.rafb.net/paste/results/SMPqF866.html <-- can someone help me on this one
05:26:43 <dons> sowhat, I'd launch ghci over a pipe, and talk to it that way
05:26:56 <dons> i.e. a pipe connected to stdin and stdout on ghci
05:27:16 <shapr> g'day dons
05:27:20 <shapr> @timein dons
05:27:23 <lambdabot> Local time for dons is Wed Mar 15 00:27:30 2006
05:30:18 <tre_> Can somebody explain to me the notion of a 'point' ... I am trying to get a reading knowledge of Haskell and I feel OK about it except I run into concepts such as "point free", "pointwise application", etc.
05:30:51 <tromp_> point is like element
05:31:01 <tromp_> or argument
05:31:17 <SamB> point-free code is code with lots of dots in it ;-)
05:31:24 <tromp_> pointfree is a way of defining functions without mention of the argument
05:32:49 <tre_> The dot is the composition operator?
05:33:01 <dcoutts> tre_, the "points" are the named values between function applications
05:33:38 <dcoutts> I think the term point in this context comes from a mathematcal semantics
05:33:43 <dcoutts> eg:
05:33:59 <dcoutts> let tmp1 = f x in g tmp1
05:34:03 <dcoutts> tmp1 is a point
05:34:14 <dcoutts> this is pointed code
05:34:29 <dcoutts> g . f
05:34:35 <SamB> hmm. I wonder if the full version offers that timeout feature?
05:34:37 <dcoutts> is the equivalent point free code
05:35:10 <dcoutts> tre_, so yes, amusingly, point free code has lots of dots in it
05:35:37 <dcoutts> a point free style encourages the use of function composition and higer order functions
05:35:48 <SamB> I thought the semantics of which you spake was "denotational"
05:36:00 <dcoutts> SamB, yep
05:36:00 <sowhat> dons, can you give an example?
05:36:32 <dcoutts> it encourages you to think at the level of connecting processes rather than what is happening to the values that are being acted upon
05:36:50 <SamB> combinators and all that jazz
05:37:02 <dcoutts> and often it is a nice style
05:37:05 <SamB> yes
05:37:24 <dcoutts> when having to name intermediate values in a computation seems unnecessary or unnatural
05:37:39 <tre_> Yea, I can imagine that
05:37:44 <sowhat> shapr, i would be nice to have a good interface to your platform, in an independent way. it surely would give haskell / ghc a more matured glance, if you ask me.
05:37:51 <dcoutts> on the other hand for some problems you can make the code clearer by giving names to intermediate values (or functions)
05:38:20 <SamB> which is why point-free code is sometimes referred to as "pointless" code
05:38:34 <dcoutts> heh, yeah
05:38:44 <sowhat> sieni, is works: expect -c "spawn ghc --interactive -v0; expect \">\"; send \":l Main\n\"; send \"main\n\"; interact"
05:39:06 <sieni> sowhat: cool :-)
05:44:47 <sowhat> now only i could strip some of the lines out
05:45:50 <tre_> i guess point-free code relies on higher order functions that have well-thought out argument orderings
05:46:05 <dcoutts> tre_, yeah
05:46:17 <lennart> that makes it look nicer, yes
05:46:20 <dcoutts> or one needs to fix them with lambdas
05:46:24 <araujo> morning
05:46:42 <lennart> but with lambda it's no longer point-free
05:47:03 <dcoutts> right
05:47:11 <dcoutts> or use flip const etc
05:47:35 <dcoutts> tre_, lambdabot has a "pl" pluging that converts code to point free style
05:47:49 <dcoutts> it's somewhat of a joke however, though quite cool
05:47:56 <lennart> very cool!
05:48:09 <dcoutts> it often produces code that people wouldn't really write
05:48:23 <Saulzar> Quite useful too, though clearly you want to be critical of it's output :)
05:48:49 <lennart> it's inspired me :)
05:49:06 <lennart> @pl \ x -> x * x
05:49:06 <dcoutts> anyone got a good example?
05:49:07 <lambdabot> join (*)
05:49:25 <dcoutts> @type join
05:49:26 <lambdabot> Not in scope: `join'
05:49:49 <dcoutts> @pl let tmp1 = f x in g tmp1
05:49:50 <lambdabot> g (f x)
05:49:51 <lennart> lambdabot should have more modules in scope
05:50:01 <dcoutts> @pl \x -> let tmp1 = f x in g tmp1
05:50:02 <lambdabot> g . fix . const . f
05:50:28 <lennart> huh?
05:50:37 * dcoutts doesn't get that either
05:51:02 <lennart> pl seems to have gone for overkill with fix
05:51:12 <dcoutts> and const?
05:51:35 <bolrod> :)
05:52:41 <xerox> hi!
05:52:49 <dcoutts> g'afternoon xerox 
05:53:09 <bolrod> true.. damn.. I wasted my day
05:53:29 <tre_> I'll probably end up buying a book on Haskell, are there any you can recommend? I have some experience with Scheme, but not much outside of that language. Laziness and types are my primary source of confusion.
05:54:51 <xerox> tre_: did you try "Yet Another Haskell Tutorial"?
05:55:47 <tre_> no I didn't, thanks for pointing it out to me
05:57:58 <xerox> @where yaht
05:57:59 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
05:58:53 <xerox> Talking of books, I liked ``The Haskell Road to Math, Logic and Programming.''
05:59:41 <shapr> I still need to read that...
06:00:12 <tromp_> that's written by my colleague jan van eijck
06:01:04 <tromp_> i proofread it:)
06:02:10 <tre_> that sounds like a cool book
06:02:56 * xerox high-fives tre_ 
06:03:04 <xerox> err, tromp_, too :-)
06:12:26 * shapr yawns
06:14:33 * bolrod 2nds that
06:20:26 <Lemmih> Yak. I keep causing silly bugs. *sigh*
06:38:40 <shapr> SQL_Error: Try HaskellDB
06:39:13 <dcoutts> poor Lemmih :-)
06:47:40 <SQL_Error> is it good?
06:47:49 <SQL_Error> i use postgeres
06:47:52 <SQL_Error> postgres
06:49:54 <twobitsprite> why do I see variable names with single quotes (') after them with out them being matched? i.e. case s of '/':s' -> ...
06:50:25 <twobitsprite> is s' just a valid token, or does it have meaning?
06:50:48 <tromp_> token
06:51:37 <twobitsprite> I see... /me scans around the website for token rules...
07:00:48 <SQL_Error> shapr: what is special about HaskellDB?
07:07:34 <Lemmih> SQL_Error: It's a library for generating type-safe SQL.
07:07:43 <musasabi> How should I handle the following: given a monad m that has IO inside but cannot be run in a stacked fashion - how should one wrap functions that have a type signature like "foo :: (a -> IO (a,b)) -> IO b"
07:08:05 <musasabi> Lifting the IO to my monad is easy, but the handler seems to require the monad to be runnable.
07:08:46 <shapr> SQL_Error: HaskellDB would mean you wouldn't get anymore SQL errors.
07:10:01 <SQL_Error> haha
07:10:04 <SQL_Error> well 
07:10:10 <SQL_Error> i don think so
07:10:11 <SQL_Error> ;-
07:10:16 <SQL_Error> ;-)
07:12:11 * SamB wishes the mangler would announce info blocks as data...
07:12:49 <musasabi> or in other words - how do I use atomicModifyIORef with the action as STM a instead of IO a.
07:13:02 <SamB> musasabi: evilly
07:13:19 <musasabi> SamB: how is it possible?
07:13:33 <SamB> oh, wait
07:13:37 <SamB> misunderstood
07:14:00 <SamB> er, you aren't trying to run an STM action from an IO action from an STM action?
07:14:39 * yaargy makes his new .signature "Python programmer. Haskell evangelist."
07:15:02 <musasabi> I am trying to find a way to do that for the atomicModifyIORef and I know about the no nested-transactions rule.
07:15:17 <SamB> where did scannedinavian.org go?
07:15:49 <musasabi> maybe I should use MVars + write my own modifyMVarSTM :: MVar a -> (a -> STM (a,b)) -> STM b
07:16:00 <SamB> don't try to nest them
07:16:04 <SamB> they don't nest
07:17:34 <musasabi> some evil ways involving threads to make that tick, but I think the MVar route + rewriting modifyMVar/withMVar for STM should work.
07:17:44 <Lemmih> musasabi: Why do you wanna modify an MVar from STM?
07:18:02 <SamB> or an IORef
07:18:03 <musasabi> Lemmih: because I need to retain the modifications even if the transaction fails.
07:18:15 <SamB> huh?
07:18:23 <dcoutts> that doesn't sound like a transaction
07:18:33 <Lemmih> Doesn't that defeat the purpose of transactions?
07:18:50 <SamB> that sounds like you actually want to end the transaction...
07:19:27 <musasabi> Lemmih: there are multiple kinds of data, some of it like cache and statistics should be recorded irrelevant of whether the transaction is successful or not.
07:19:41 <SamB> okay
07:20:15 <SamB> and why do you need to run an STM action to modify this cache stuff?
07:21:45 <SamB> anyway, any attempt to nest STM could have catastrophic results
07:22:31 <musasabi> the STM bit is inside the main DSL monad and the updating stuff uses the reader-like features of that monad.
07:23:02 <musasabi> of course I could add an another monad for the cases where STM is not allowed, but that would make the code less clean.
07:23:15 <Lemmih> musasabi: What are you hacking, OOI?
07:24:04 <SamB> well, never ever think you can nest STM. because even if you can, it probably won't do what you want.
07:24:22 <musasabi> Lemmih: Trying to start using STM for a small transaction processing thing.
07:24:43 <shapr> SamB: scannedinavian.{com,net,org} server has moved, and I haven't setup the .org and .net DNS yet. Do you need something specific?
07:24:56 <SamB> shapr: 
07:24:58 <SamB> ahg
07:25:00 <SamB> er.
07:25:04 * SamB tries again.
07:25:10 <SamB> shapr: ah ;-)
07:25:18 <SamB> okay, so I will use .com
07:25:26 <musasabi> SamB: until the Simons implement nested transactions? ;)
07:25:50 <SamB> musasabi: until and if...
07:26:39 <SamB> anyway, I read somewhere (probably one of the modules, maybe GHC.STM) that it would segfault...
07:26:56 <SamB> or something equally bad
07:29:01 * SamB now gets a 404
07:29:11 <SamB> or other HTTP error
07:30:10 <shapr> What are you looking for?
07:30:11 <SamB> darcs failed:  Failed to download URL http://scannedinavian.com/~lemmih/conjure/_darcs/inventory
07:30:12 <SamB> libcurl: HTTP error (404?)
07:30:51 <shapr> I have a whole new server, currently not hosting anyone except me.
07:31:14 <SamB> ah
07:31:20 <musasabi> SamB: the segfault was fixed. The paper says that they are broken at the moment, but should be implemented in future iirc.
07:31:40 <SamB> oh?
07:31:44 <SamB> interesting.
07:32:20 <SamB> so what are you doing with all this, anyway?
07:33:23 <kaydara> if i make: take 2 "abcd"
07:33:29 <kaydara> is returns me a String right ?
07:34:33 <Paltas> aha
07:34:42 <Paltas> "ab"
07:35:24 <kaydara> i have this error
07:35:25 <kaydara> *** Type           : Formula -> ([Char],[Char],[Char])
07:35:26 <kaydara> *** Does not match : Formula -> (Formula,Formula,Char)
07:35:35 <cpatrick> @hoogle index
07:35:36 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
07:35:36 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.Index :: Int
07:35:36 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec.Index :: Index a
07:35:52 <kaydara> splitF x = (a,b,c)
07:35:52 <kaydara>         where
07:35:53 <kaydara>         a = take 2 x
07:35:58 <kaydara> b and c are equal atm
07:36:17 <kaydara> b = take 2 x
07:36:21 <kaydara> c = take 2 x
07:36:32 <kaydara> i was just testing at the momente
07:36:38 <kaydara> moment*
07:37:21 <kaydara> http://www.rafb.net/paste/results/SMPqF866.html <-- beter
07:37:24 <kaydara> better*
07:38:41 <kaydara> cant figure out the error
07:44:38 <sjanssen> @type take 1
07:44:40 <lambdabot> forall a. [a] -> [a]
07:44:59 <sjanssen> eh, that isn't as helpful as I meant
07:45:40 <sjanssen> take returns a list (string in your case), but the type signature you give says c should be a char
07:45:45 <Lemmih> kaydara: 'take 1 "string") doesn't return a Char.
07:45:46 <sjanssen> @type head
07:45:48 <lambdabot> forall a. [a] -> a
07:47:55 <kaydara> well but in my first ones should be Formula ( String ) and not [Char] right ? the only that could be wrong was the last
07:48:09 <kaydara> but i get the type [Char] in the first two too
07:48:14 <SamB> type String = [Char]
07:48:21 <kaydara> ah
07:48:26 <kaydara> so the last one is the only wrong
07:51:10 <kaydara> if i know the index of a char that i want how cant i get him ? only noob questions i know
07:51:46 <kaydara> im looking at zvon in Char and List
07:51:51 <kaydara> and dont find anything to do this
07:53:18 <tromp_> what is it you want?
07:53:22 <Lemmih> > "Hello world" !! 3
07:53:23 <lambdabot> 'l'
07:54:21 <kaydara> thats it Lemmih 
07:54:53 <tromp_> > ""!!1
07:54:54 <lambdabot> Exception: Prelude.(!!): index too large
07:55:14 <tromp_> > "h"!!1
07:55:15 <lambdabot> Exception: Prelude.(!!): index too large
07:55:23 <kaydara> 0 :P
07:55:28 <kaydara> i understend
07:55:28 <bolrod> > map ("Hello World!"!!) [0..11]
07:55:30 <lambdabot> "Hello World!"
07:55:41 <tromp_> > "h"!!(-)
07:55:42 <lambdabot> Couldn't match `Int' against `t -> t1'
07:55:51 <tromp_> > "h"!!(-1)
07:55:52 <lambdabot> Exception: Prelude.(!!): negative index
07:59:13 <bolrod> let doit string =map (string!!) [0..11] ++ doit string  in take 100 (doit "Yar! ")
07:59:19 <bolrod> > let doit string =map (string!!) [0..11] ++ doit string  in take 100 (doit "Yar! ")
07:59:20 <lambdabot> Exception: Prelude.(!!): index too large
07:59:37 <bolrod> > let doit string =map (string!!) [0..(length string)] ++ doit string  in take 100 (doit "Yar! ")
07:59:38 <lambdabot> Exception: Prelude.(!!): index too large
07:59:48 <bolrod> > let doit string =map (string!!) [0..(length string-1)] ++ doit string  in take 100 (doit "Yar! ")
07:59:49 <lambdabot> "Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar! Yar!
07:59:49 <lambdabot> Yar! Yar! Yar! Yar! Yar! Yar! "
08:00:01 <bolrod> very usefull
08:00:32 <tromp_> > take 100 $ cycle "Har "
08:00:33 <lambdabot> "Har Har Har Har Har Har Har Har Har Har Har Har Har Har Har Har Har Har
08:00:33 <lambdabot> Har Har Har Har Har Har Har "
08:00:48 <Lemmih> > map ("hello world"!!) [1..]
08:00:50 <lambdabot> Exception: Prelude.(!!): index too large
08:01:10 <Lemmih> > zipWith (!!) "Hello world" [1..]
08:01:11 <lambdabot> Couldn't match `[a]' against `Char'
08:03:05 <dblhelix> > zipWith (!!) (repeat "Hello world") [0..]
08:03:06 <lambdabot> Exception: Prelude.(!!): index too large
08:03:21 <bolrod> :)
08:03:43 * Lemmih tries to remember where he left his brain.
08:03:46 <dblhelix> > zipWith (!!) (repeat "Hello world") [0.. length "Hello world" - 1]
08:03:47 <lambdabot> "Hello world"
08:04:46 <bolrod> Lemmih: is that possible without a brain?
08:06:33 <Lemmih> bolrod: You know, that's probably why I haven't found it yet (:
08:06:55 <bolrod> I guess so..
08:07:30 <bolrod> maybe you can find a new brain on eBay
08:08:38 <dblhelix> zipWith (flip (!!) . flip mod (length "Hello world")) (repeat "Hello world") [0..]
08:08:52 <dblhelix> :)
08:09:00 <dblhelix> > zipWith (flip (!!) . flip mod (length "Hello world")) (repeat "Hello world") [0..]
08:09:01 <lambdabot> Couldn't match `Int' against `[Char]'
08:09:18 <dblhelix> mmm
08:09:32 <Lemmih> bolrod: No need. Stumbled over a Y-combinator: fix (\brain -> findBrainWith brain)
08:10:40 <bolrod> urh.. and what brain will you be using for that?
08:11:14 <dblhelix> Lemmih: of course I do not know how you intend to implement findBrainWith... but chances are that your solution will diverge ;)
08:11:52 <bolrod> if you believe in reincarnation.. just kill yourself
08:11:55 <bolrod> no need to search
08:12:04 <Lemmih> @karma
08:12:05 <lambdabot> You have a karma of 13
08:12:13 <Lemmih> Hm, it may be worth it.
08:12:52 <bolrod> :)  who needs a brain anyway
08:13:09 <bolrod> You could even become president without one
08:25:42 <twobitsprite> @karma
08:25:43 <lambdabot> You have a karma of 0
08:25:47 <twobitsprite> damn
08:26:16 <bolrod> haha
08:26:24 <twobitsprite> @karma
08:26:25 <lambdabot> You have a karma of 0
08:26:28 <bolrod> yep
08:26:36 <bolrod> @karma
08:26:37 <lambdabot> You have a karma of 0
08:26:38 <bolrod> same
08:26:46 <twobitsprite> how does lambdabot calculate karma?
08:26:50 <bolrod> not
08:26:57 <vlcak> @karma
08:26:58 <lambdabot> You have a karma of 0
08:27:06 <vlcak> I see! :)
08:27:27 <bolrod> it increases your karma when someone does something like @karma <nick> + 1 or something?
08:27:30 <bolrod> @ka
08:27:31 <lambdabot> Maybe you meant: karma karma+ karma- . faq id keal lam map pl wn
08:27:35 <bolrod> @karma+
08:27:36 <lambdabot> You have a karma of 0
08:27:45 <bolrod> @karma+ twobitsprite 
08:27:46 <lambdabot> twobitsprite's karma raised to 1.
08:27:48 <bolrod> :)
08:27:51 <twobitsprite> sweet
08:27:57 <twobitsprite> @karma+ bolrod 
08:27:58 <lambdabot> bolrod's karma raised to 1.
08:27:59 <bolrod> \o/
08:28:00 <lambdabot> Maybe you meant: . id pl wn yow
08:28:03 <bolrod> lambdabot: shut up
08:28:06 <twobitsprite> lol
08:28:14 <twobitsprite> yow
08:28:17 <twobitsprite> @yow
08:28:18 <lambdabot> ... I have read the INSTRUCTIONS ...
08:28:24 <bolrod> @yar
08:28:24 <lambdabot> Maybe you meant: arr faq lam map part yow
08:28:27 <bolrod> @yarr
08:28:28 <lambdabot> Drink up, me 'earties
08:28:30 <bolrod> @arr
08:28:31 <lambdabot> Shiver me timbers!
08:28:36 <bolrod> :D
08:28:43 <twobitsprite> @map
08:28:43 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
08:28:50 <bolrod> @fortune
08:28:51 <lambdabot> Hackathon Moose (or other Ex-Magnificent-Forest-Creature) Barbecue
08:28:51 <lambdabot>  
08:28:51 <lambdabot> 30 cups oil
08:28:51 <lambdabot> 15 cups Soy sauce
08:28:51 <lambdabot> 5 cups Worcestershire Sauce
08:28:51 <twobitsprite> @lam
08:28:53 <lambdabot> [19 @more lines]
08:28:55 <lambdabot> lShell module failed: Prelude.init: empty list
08:29:02 <bolrod> ... O_o
08:29:04 <bolrod> what I do?
08:29:12 <twobitsprite> @fortune
08:29:13 <lambdabot> Hackathon Moose (or other Ex-Magnificent-Forest-Creature) Barbecue
08:29:13 <lambdabot>  
08:29:13 <lambdabot> 30 cups oil
08:29:13 <lambdabot> 15 cups Soy sauce
08:29:13 <lambdabot> 5 cups Worcestershire Sauce
08:29:15 <lambdabot> [19 @more lines]
08:29:23 <bolrod> @mor
08:29:24 <lambdabot> 40 tsp dry mustard
08:29:24 <lambdabot> 20 tsp black pepper
08:29:24 <lambdabot> 10 cups lemon juice
08:29:24 <lambdabot> 10 cups white vinegar
08:29:25 <lambdabot> 80 cloves crushed garlic
08:29:27 <lambdabot> [14 @more lines]
08:29:28 <bolrod> @more
08:29:29 <lambdabot>  
08:29:31 <lambdabot> About 75 pounds of boneless meat (moose, deer, elk, beef - try chicken
08:29:33 <lambdabot> too).  For reference this is roughly an entire large dressed (Alberta
08:29:35 <lambdabot> size) whitetail deer, with some moose and beef thrown in for good
08:29:37 <lambdabot> measure. I've never tried finding enough chickens for a hackathon.
08:29:39 <lambdabot> [9 @more lines]
08:29:43 <bolrod> @more
08:29:43 <lambdabot>  
08:29:43 <lambdabot> Mix all of the above together, and marinate meat for a few hours
08:29:45 <lambdabot> before grilling. Dribble marinade over meat while grilling.  Also
08:29:47 <lambdabot> works well with vegetables on the grill, or meat and vegetable
08:29:49 <lambdabot> kebabs. The above proportions will require about 50 bell peppers and
08:29:51 <lambdabot> [4 @more lines]
08:29:57 <bolrod> @more
08:29:57 <lambdabot> 25 large onions to make decent kebabs (for a large family meal, divide
08:29:57 <lambdabot> everything by about 20, and leave out the drunk Germans providing
08:29:57 <lambdabot> the
08:29:58 <Lemmih> @no-more-please
08:29:59 <lambdabot> ambience while you grill).
08:30:01 <lambdabot> Unknown command, try @listcommands.
08:30:20 <bolrod> 17:29:03 < lambdabot> 80 cloves crushed garlic
08:30:22 <bolrod> IS HE MAD?
08:30:36 * twobitsprite always invisioned lambdabot as a she...
08:30:42 <kosmikus> just fully nerd
08:30:43 <bolrod> oh
08:31:06 <bolrod> why is that twobitsprite ?
08:31:14 * twobitsprite shrugs
08:31:19 <bolrod> ?
08:31:19 <dblhelix> twobitsprite: lambdabot is a she! see  http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html.
08:31:21 <Lemmih> @vixen Are you a girl?
08:31:22 <lambdabot> yup, i'm all woman
08:31:24 <bolrod> ;o
08:31:28 <twobitsprite> I guess I always see bots as female... like cars...
08:31:55 <dblhelix> and then http://www.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html.
08:32:32 <nothingmuch> luqui: you arse, join #perl6
08:32:46 <nothingmuch> we *NEED* you
08:32:49 <luqui> right now?
08:32:51 <luqui> or in general?
08:32:56 <nothingmuch> in general
08:33:02 <bolrod> scary
08:33:07 <luqui> ahh.  I'll be there within the next couple of days.
08:33:12 <nothingmuch> heh
08:33:13 <nothingmuch> okies
08:33:17 <nothingmuch> what have you been up to?
08:33:23 <bolrod> South park is cool :)
08:33:33 <luqui> midterms and personal projects
08:33:40 <luqui> had to put off perl 6 to get other projects done
08:33:52 <audreyt> p6 too addictive eh :)
08:33:58 <luqui> audreyt, yep :-)
08:34:03 <audreyt> you've been missing out all the Pugs::Compiler::* dual perl5/6 module stuff
08:34:09 <luqui> audreyt, yeah I heard
08:34:11 <luqui> sounds very cool
08:34:18 <audreyt> also I'm working on AbsPIR
08:34:22 <luqui> ?
08:34:23 <audreyt> which should make you a lot happier
08:34:36 <audreyt> TH-based DSL for typed (and correct and analyzable) PIR
08:34:41 <luqui> neato
08:34:41 <audreyt> like AbsIL for CLR
08:34:42 <twobitsprite> what's connection between haskell and perl besides hugs?
08:34:49 <tromp_> pugs
08:34:55 <twobitsprite> er, yeah
08:35:00 <luqui> twobitsprite, you can't really say "besides pugs"
08:35:10 <luqui> that is the only connection, but it's a very big one
08:35:11 <audreyt> twobitsprite: AntiBuddha? :)
08:35:32 <twobitsprite> ahh... It just seems like the communities tend to generally overlap
08:35:42 <luqui> twobitsprite, not until pugs
08:35:48 <twobitsprite> right on
08:35:55 <Cale> There's the evil mangler :)
08:35:58 <luqui> so anyway, I came in here to ask a haskell questoin
08:36:10 <Cale> Depending on what you mean by 'connection' :)
08:36:15 <nothingmuch> luqui: have fun with whatever projects and be sure to tell us about them too ;-)
08:36:21 * nothingmuch is off to do something non computery
08:36:29 <twobitsprite> so... if parrot out the window because pugs rules, or it pugs a temporary solution until parrot gains momentum?
08:36:32 <luqui> can I make a monad that will dispatch messages on demand
08:36:58 <Cale> luqui: what do you mean by dispatch?
08:37:19 <luqui> like, say, do { say "foo";  bar <- ask "bar"; say "baz";  if bar then say "quux" else say "quixote" }
08:37:38 <luqui> and it will say "foo" "bar" "baz", but then wait for the "bar" to come back before doing anything else
08:37:45 <luqui> this is very sketchy
08:37:55 <luqui> I'm trying to design architecture, not solve a small-scale problem
08:38:28 <luqui> know what I'm getting at?
08:38:31 <Cale> hmm
08:38:51 <Cale> Would this be doing IO?
08:38:59 <luqui> Cale, yes
08:39:05 <Cale> okay
08:39:26 <luqui> would I need to dive into unsafeLand to do it?
08:39:38 <luqui> because I would rather use a different algebraic structure than do that
08:39:39 <Cale> well, it'd be a monad over IO
08:39:43 <luqui> clearly
08:40:44 <twobitsprite> so... after toiling over monads for too long now, it just seems to me that monads are just an arrow syntax to distinguish between "functions" and "actions"... no?
08:41:06 <luqui> twobitsprite, that seems like a pretty good conceptual model
08:41:13 <Cale> Well, you can obviously do things like this from the IO monad already, with  say = putStrLn  and  ask x = do putStrLn x; getLine
08:41:25 <luqui> Cale, but then all the sequencing is explicit
08:41:26 <twobitsprite> luqui: am I incorrect?
08:41:49 <Cale> twobitsprite: there's a bit more to it than that
08:41:52 <luqui> twobitsprite, well, it's a little bit narrow, but it is a good way to think about it
08:42:05 <luqui> twobitsprite, that is an excellent way to think of the IO monad
08:42:19 <Cale> twobitsprite: have you read MonadsAsContainers?
08:42:24 <luqui> twobitsprite, but when you get into "purer" monads, say, Reader, it's a bit different
08:42:36 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
08:42:50 <Cale> > do x <- [1,2,3]; y <- [5,6]; return (x + y)
08:42:51 <lambdabot> [6,7,7,8,8,9]
08:43:04 * luqui loves the list monad so much
08:43:13 <Cale> It's a wonderful monad :)
08:43:48 <luqui> so, Cale, is what I want even possible from a pure standpoint?
08:44:24 <Cale> Well, you want to do IO, but you don't want to control the ordering of computations at all?
08:44:28 <luqui> it seems like it would cause evaluating "bar" to have a side effect, in a manner of speaking, which would imply that it is not
08:44:55 <luqui> Cale, well, it's more like the ordering wouldn't matter when you get back to the rest of the program
08:45:05 <lambdabot> EVIL STRIKES!
08:45:12 <bolrod> ...\
08:45:42 <luqui> Cale, the architecture is for AI scripting in a strategy game.  all the actions that are independent will be dispatched at the same time.
08:45:44 <bolrod> ~~~~~~~~~~~~~~/\~~~~~\o/~~~~~~   tam tam tam tam tamtam.... o/~
08:45:51 <luqui> but then some frames pass until the information is available to continue
08:45:57 <luqui> but you're not sure when the information will get there
08:46:06 <luqui> or in what order it will arrive
08:46:26 <shapr> callbacks?
08:46:41 <luqui> shapr, yes, but I want it to look more linear than that
08:46:46 <sjanssen> luqui: what you're saying reminds me of threads, with MVar's
08:46:56 <luqui> sjanssen, yes, it's something like that
08:47:20 <luqui> but I'd rather not get into hardware threads
08:47:29 <luqui> but maybe i'm just being paranoid
08:47:34 <Cale> hardware threads?
08:47:47 <luqui> aren't threads in ghc fairly unportable?
08:47:53 * luqui doesn't remember
08:48:07 <Cale> forkIO gives you a lightweight thread which the OS doesn't even know aout
08:48:17 <luqui> oh, that's cool
08:48:52 <luqui> anyway, the reason I wanted to do it in a monad is more for linguistic than implementaiton reasons
08:49:03 <luqui> the person who is writing the AI shouldn't have to worry about what is parallel, etc.
08:49:11 <luqui> s/AI/AI script/
08:49:47 * luqui looks at MVars etc.
08:49:48 <Cale> hmm... while a monad might be appropriate there, I'd think for different reasons :)
08:50:22 <sjanssen> luqui: I think you could do something like this if, instead of using if for conditional execution, you used your own waiting primitive
08:50:35 <Cale> Monads are quite good for constructing EDSLs, but they do force the person writing in them to think about the order of computation
08:50:36 <luqui> sjanssen, that is a pretty good ide
08:50:37 <luqui> a
08:50:43 <shapr> GHC threads are the best I've ever used. You get the whole range from coroutines up to OS-based thread local state.
08:50:43 <luqui> didn't think of that
08:51:20 <shapr> Why not STM?
08:51:33 * luqui drools at STM
08:51:40 <shapr> Or am I confused totally? I missed the beginning of this conversation.
08:51:50 <luqui> if I ever did any parallel programming it would have to be in Haskell because of STM
08:52:00 <luqui> shapr, I think you missed the point
08:52:18 <luqui> I'm going to try sjanssen's idea
08:52:21 <luqui> thanks
08:52:23 <Cale> STM isn't really for parallel programming. It's for concurrency.
08:52:31 <twobitsprite> hmm.... I think I understand that page on monads... I think it's just that my brain collapses when I see the word "monad"... Is there a more descriptive term I can replace it with in my head maybe?
08:52:32 <Cale> (though I suppose you could do both)
08:52:37 <luqui> Cale, uh, yeah, semantics
08:52:44 <shapr> twobitsprite: abstractions
08:52:56 <twobitsprite> shapr: how... abstract.... :P
08:53:07 <sjanssen> twobitsprite: container?
08:53:09 <shapr> twobitsprite: the monadic interface is just an abstraction like the object abstraction.
08:53:17 <sjanssen> though, that's not really descriptive all the time
08:53:17 <eivuokko> Uhm...I usually replace word monad with word container if it gets tough..
08:53:19 <luqui> twobitsprite, I'd say that for the moment you should try to understand each individual monad you are using separately
08:53:30 <luqui> twobitsprite, then your brain will eventually see the similarities
08:53:38 <luqui> twobitsprite, and that's what you call a "monad"
08:54:02 <twobitsprite> luqui: I was thinking that when I saw mention of the "list monad" in here a second ago...
08:54:14 <twobitsprite> any good (simple) usage examples of monads?
08:54:27 <luqui> twobitsprite, other than the list monad one?
08:54:39 <_Codex> twobitsprite: maybe monad use is pretty simple.
08:54:41 <shapr> Maybe
08:54:46 <luqui> aye
08:54:55 <shapr> I think Maybe is the best way to start.
08:54:56 <twobitsprite> lets stick with the list monad for now, I think I can grok lists...
08:55:04 <twobitsprite> er, Maybe?
08:55:05 <shapr> twobitsprite: Want my short tutorial?
08:55:11 <twobitsprite> shapr: sure
08:55:18 <shapr> ok.. you know the Maybe type?
08:55:27 <twobitsprite> I think... like maybe from OCaml?
08:55:32 <shapr> I dunno OCaml.
08:55:39 <shapr> data Maybe a = Nothing | Just a
08:55:39 <ski> (twobitsprite : if you have ever done any prolog, then list monad is a bit similar to some things there)
08:55:48 <twobitsprite> type 'a Maybe = Some 'a | None
08:55:58 <shapr> The Maybe type represents failure, yeah?
08:56:26 <twobitsprite> ski: nope, no prolog... that's next on my list of obscure programming languages to learn :)
08:56:35 <twobitsprite> shapr: yes
08:56:49 <shapr> I like to say that a monad takes the significance of a type, and makes a pipeline with the same significance.
08:56:53 <twobitsprite> shapr: well... not necessarily... just absense of data
08:57:07 <shapr> So the maybe monad works like a bunch of nested if/then/else chunks would in an imperative language.
08:57:31 <shapr> I talk about a webshop where you'd have a bunch of computations that should succeed, or everything should fail.
08:57:45 <twobitsprite> shapr: I see
08:57:53 <shapr> doesClientExist >>= doesClientHaveMoney >>= doesItemExist >>= isItemInStock
08:58:00 <twobitsprite> so, like a big &&
08:58:20 <shapr> The importpart part of the Maybe monad is:
08:58:25 <Cale> with results going from one part of the && to the next
08:58:43 <shapr>     Nothing  >>= f = Nothing
08:58:43 <shapr>     (Just x) >>= f = f x
08:58:48 <twobitsprite> Cale: so like && with carry :)
08:59:04 <twobitsprite> shapr: ahhh... I see
08:59:12 <twobitsprite> like a pipeline
08:59:18 <shapr> That means, if a previous computation failed, the result is Nothing, otherwise pass it on.
08:59:19 <shapr> Exactly
08:59:19 <_Codex> if you have f :: a -> Maybe b, then you can always make it f :: (Monad m) :: a -> m b.
08:59:21 <twobitsprite> (did someone use that term a second ago?)
08:59:37 <_Codex> err f::(Monad m) => a ->m b
08:59:38 <shapr> Yeah, I said it's the significance of a type, put into a pipeline with the same significance.
08:59:45 <Cale> _Codex: hm?
09:00:01 <Cale> _Codex: not quite, since some monads don't have a zero
09:00:13 <ski> (e.g Identity monad)
09:00:21 <twobitsprite> Cale: shh.... I'm onto something, don't confuse me! :P
09:00:25 <shapr> So the next step up is built on the type "data Either a b = Left a | Right b"
09:00:47 <shapr> The error monad carries along the correct result from Right (by convention Right == Correct)
09:01:03 <shapr> or the monad returns the first Left error message, just like the Maybe code above.
09:01:04 <twobitsprite> (damn right-handed prejudice :P)
09:01:08 <ski> throw :: err -> Either err a
09:01:12 <shapr> Yeah, I'm a lefty myself.
09:01:12 <ski> throw err = Left err
09:01:52 <Cale> There's a reason for the prejudice here: Haskell doesn't have type lambdas, so there's no way to write the instance of Monad for the other convention.
09:02:16 <shapr> So, when you want to understand a monad, just think, "what does the type represent?" and then "how is that type passed around?"
09:02:19 <ski> instance Monad (Either err)
09:02:22 <shapr> and then, you pretty much got it.
09:02:26 <twobitsprite> so... the error monad would be like "Right x >>= f = f x" and "Left x >>= f = some error"?
09:02:33 <sjanssen> so what Cale is saying there isn't anything . . . . "underhanded" about the bias
09:02:59 <Cale> Left x >>= f = Left x
09:02:59 <_Codex> cale: well, there is monad instance of Maybe and thus all uses of f will work if you change the signature (and impl) from Maybe a to m a.
09:03:08 <ski> another viewpoint is asking "what is there in the monad, apart from returning a single value of the 'a' type"
09:03:17 <Cale> _Codex: no, that only goes the other way around.
09:03:26 <Cale> > Nothing :: Maybe Integer
09:03:27 <lambdabot> Nothing
09:03:30 <shapr> twobitsprite: You got it, see http://www.nomaware.com/monads/html/errormonad.html
09:03:30 <Cale> > Nothing :: m Integer
09:03:31 <lambdabot>  m Integer
09:03:31 <lambdabot>   Inferred type: Maybe a
09:03:31 <lambdabot>   In the expression: Nothing :: m Integer
09:03:38 <Cale> > Nothing :: (Monad m) => m Integer
09:03:39 <lambdabot>  m Integer
09:03:39 <lambdabot>   Inferred type: Maybe a
09:03:39 <lambdabot>   In the expression: Nothing :: (Monad m) => m Integer
09:03:44 <ski> in 'Maybe' monad, answer is : instead of returning a single (wrapped) 'a', it can also return 'Nothing'
09:03:59 <Cale> > mzero :: Maybe Integer
09:04:00 <lambdabot> Nothing
09:04:12 <Cale> > mzero :: (Monad m) => m Integer
09:04:13 <lambdabot>  add (MonadPlus m) to the expected type of an expression
09:04:13 <lambdabot>   In the expression: mzero :: (Monad m) => m Integer
09:04:13 <lambdabot>   In the definition of `xgb': xgb = mzero :: (Monad m) => m Integer
09:04:16 <Cale> > mzero :: (MonadPlus m) => m Integer
09:04:16 <lambdabot>  add an instance declaration for (Show (m Integer))
09:04:29 <twobitsprite> I think it's starting to clear up for me...
09:04:32 <Cale> well, that typechecks at that point anyway :)
09:04:38 <shapr> twobitsprite: See, monads are scary at all. They're just pipelines that let you sweep all that repeated code under the rug.
09:04:43 <shapr> er "are NOT scary"
09:04:52 <twobitsprite> shapr: I think I just needed to see some explained examples, thanks :)
09:04:56 <shapr> :-)
09:05:06 <Cale> You can embed Maybe in any MonadZero, but not in any Monad
09:05:24 <vincenz> ??
09:05:25 <lambdabot> Not enough arguments to @.
09:05:29 <_Codex> cale: other way around, you mean like: f :: (Monad m) => m a -> b?
09:06:06 <ski> embed :: MonadZero m => Maybe a -> m a
09:06:22 <twobitsprite> I can't tell if I like how punctuation intgensive Haskell is or not... I'll probably learnt o love it when I understand all that punctuation...
09:06:22 <ski> embed Nothing = mzero
09:06:24 <shapr> twobitsprite: For more examples, check out part II of http://www.nomaware.com/monads/html/index.html and of course, feel free to ask questions when you get some. Combining monads gets way nifty.
09:06:31 <ski> embed (Just a) = return a
09:06:36 <Cale> I mean that you can treat values of type (forall m a. (Monad m) => m a) as if they were values of type (forall a. Maybe a), but not the other way
09:07:15 <ski> Cale : s/Monad/MonadZero/ ?
09:07:18 <Cale> (just due to polymorphism)
09:07:35 <ski> (err, no, forget that)
09:07:53 * ski leaves
09:08:48 <Cale> @type \x -> case x of Nothing -> Control.Monad.mzero; Just x -> return x
09:08:50 <lambdabot> forall a
09:08:50 <lambdabot>                           (m :: * -> *).
09:08:50 <lambdabot>                         (Control.Monad.MonadPlus m) =>
09:08:50 <lambdabot>                         Maybe a -> m a
09:09:28 <Cale> Unfortunately, that says MonadPlus and not MonadZero because Haskell98 removed MonadZero for some stupid reason.
09:10:07 <shapr> twobitsprite: btw, once you understand monads, there's even more cool and powerful stuff. As compared to monads, arrows are more trouble, but more powerful too.
09:10:19 <vincenz> shapr: haven't found their use yet
09:10:26 <_Codex> cale: do you know what reason?
09:10:43 <shapr> vincenz: You know the Swierstra & Duponcheel parsers?
09:10:47 <Cale> _Codex: there were a lot of 'simplifications'
09:11:23 <Cale> _Codex: I think that when they removed monad comprehensions, they thought they wouldn't need the MonadZero class anymore.
09:12:04 <vincenz> shapr: nope
09:12:13 <Cale> but it's annoying, because you've removed that whole distinction between monads which have a mechanism for failure, and monads which have a mechanism for nondeterminism
09:12:41 <shapr> vincenz: Have you read http://www.haskell.org/tmrwiki/ArrowsIntroduction ?
09:12:46 <vincenz> yes
09:13:00 <shapr> Did you understand the part about the shortcut parsers?
09:14:05 <vincenz> er
09:14:09 <vincenz> I hadn't seen taht page
09:14:10 <vincenz> looking now
09:14:15 <shapr> ok
09:14:39 <shapr> vincenz: Please solicit clarifications and extensions, I know it's not done, but I've sort of lost motivation. Interested readers will likely motivate me.
09:14:41 <vincenz> but it doesn't have a lot of info
09:15:21 * _Codex thinks arrows are very much like functions.
09:15:41 <shapr> Yeah, but functions that can have static values attached.
09:16:08 <shapr> And those bits work concatenatively as well.
09:16:08 <tromp_> exercise:
09:16:17 <tromp_> define the thue morse sequence
09:16:40 <shapr> thue?
09:16:56 <xerox> morse "thue" :: Morse
09:17:05 <_Codex> I mean, (>>>) is pretty much like (.) for functions. And many other properties are exactly same as in functions.
09:17:45 <vincenz> shapr: static bits?
09:17:55 <xerox> _Codex: I think there's a lot more because of the laws involved.
09:18:14 <shapr> vincenz: Have you gotten down to "Meanwhile, back to parsers" in that page?
09:18:43 <tromp_> it's 0110100110010110... bit n is the parity of n ion binary
09:19:13 <shapr> hiya SyntaxNinja 
09:19:22 <SyntaxNinja> y0
09:19:33 <tromp_> you can also get it by starting with 0 and repeatedly appending the complement of what you have
09:19:56 <vincenz> shapr: yep 
09:19:56 <xerox> "parity of n *ion* binary" ?
09:20:05 <tromp_> in binary
09:20:17 <xerox> ah, sorry.
09:20:39 <shapr> vincenz: Ok, think of monads with the ability to stick value onto them. You could then shortcut parsing when you know it'll fail. Otherwise, everything has to fail in turn, yeah?
09:21:02 <vincenz> still not seeing it
09:21:09 <vincenz> stick values in to them?
09:21:28 <xerox> onto!
09:21:31 <vincenz> I see the limitation you describe, just not how it fits
09:21:41 <vincenz> or solves it
09:21:44 <shapr> nums = do two <|> three could be do 't' and then do "wo" <|> "hree" right?
09:21:58 <vincenz> yes
09:22:01 <shapr> But you can't 'factor' parsers like that with monads.
09:22:04 <vincenz> you're describing a solution
09:22:09 <shapr> You can factor arrows that way.
09:22:10 <vincenz> you're not describing why arrow fix this
09:22:31 <vincenz> how?/
09:22:49 <shapr> Arrows can have static information stuck onto them.
09:23:40 <shapr> So they could export what they could possibly parse, and then a single top level arrow composed of many sub arrows would be able to fail way ahead of time.
09:24:04 <ibid> hmm. should i mention LLParser here?
09:24:08 <ibid> probably not
09:24:21 * ibid unsays the above
09:24:48 <shapr> Also, arrows are not just recursive calls like monads, so they let you garbage collection earlier, and get bindings out of scope sooner.
09:25:01 <xerox> shapr: how would you describe the electronic-scheme-likeish view of Arrows?
09:25:23 <shapr> You mean the wiring approach?
09:25:27 <xerox> Yep!
09:25:38 <shapr> Arrows really do feel like building circuits. You connect all the wires and stuff happens.
09:26:09 <_Codex> that sounds like category theory diagrams :)
09:26:21 <shapr> Arrows really are much closer to category theory than monads.
09:26:25 <_Codex> diagram commutes :)
09:27:13 <ibid> it seems to me that arrows would work better with a visual sugaring instead of the current proc-do :)
09:27:14 <shapr> That's pretty much how they work. If you can see that a computation is unnecessary, you just don't have to do it.
09:27:21 <shapr> ibid: like what?
09:27:30 <ibid> shapr: diagrams :9
09:27:32 <xerox> ibid: metoo!
09:27:52 <shapr> The big downside of arrows is that you lose that transparency the moment you lift a boring Haskell function into an arrow.
09:28:01 <shapr> Because it's a black box.
09:28:02 <ibid> shapr: it seems to me that when i'm writing arrows code, i'm transcribing diagrams. it would probably be better to be able to draw the diagrams directly
09:28:17 <shapr> (This realization courtesy of musasabi, thanks for many long discussions on arrows =)
09:28:30 <shapr> ibid: Yeah, I think it's pretty much dataflow programming.
09:28:42 <shapr> And that's one reason it makes so much sense for reactive programming like Yampa.
09:28:47 <ibid> yeah
09:29:00 <ibid> which reminds me, my fp course finished last week
09:29:09 <shapr> Is your arrows code public now?
09:29:30 <ibid> shapr: well, it never was private, in itself, it's just not polished :)
09:29:32 <shapr> How did the students like course?
09:29:38 <shapr> er "like the course"
09:29:42 * shapr is thinking in Swedish
09:29:48 <shapr> kursen
09:29:51 <ibid> those who stayed on the course seemed to like it
09:30:00 <shapr> How many started, and how many stayed?
09:30:14 <ibid> i think i had ten people on the first lecture
09:30:15 <twobitsprite> what does '$' mean in haskell?? I see it mentioned as a grouping expression here: http://merd.sourceforge.net/pixel/language-study/syntax-across-languages/Vrs.html
09:30:24 <xerox> f $ x = f x
09:30:33 <ibid> there were about five people who came to lectures regularly
09:30:35 <shapr> twobitsprite: low precedence function application
09:30:38 <xerox> It's just more loose than plain juxtaposition function application.
09:30:46 <ibid> four people took the first exam last friday, of which three passed
09:30:58 <ibid> i expect to pass one or two more in subsequent exams
09:31:00 <shapr> That's pretty good for a course that mentions arrows :-)
09:31:13 <twobitsprite> so f $ g x == f (g x) ?
09:31:14 <ibid> (this is the "functional programming 2" course, not my introductory one)
09:31:19 <xerox> In brief you imagine a '(' in place of the '$', and a ')' at the end of the line.
09:31:26 <xerox> Yep, twobitsprite.
09:31:32 <twobitsprite> k
09:31:46 <twobitsprite> sounds like ugly style... I'll stick with parens..
09:31:46 <Cale> Really, it's just defined like  f $ x = f x
09:32:01 <shapr> vincenz: Arrows now make more sense as to why and how?
09:32:05 <xerox> Cale: yeah, he/she used  '=='  :-)
09:32:12 <Cale> and it's set to bind very weakly
09:32:13 <ibid> shapr: actually, i have a rewritten LLParser on my laptop
09:32:16 <Cale> I know
09:32:20 <shapr> ibid: ooh I wanna see!
09:32:45 <shapr> I've picked up a bunch of nifty arrows trivia while studying the subject.
09:32:45 <ibid> shapr: it's completely untested
09:33:07 <Cale> twobitsprite: Composition (.) is preferable when it applies
09:33:32 <shapr> I asked John Hughes how he got the inspiration to turn monads into arrows. and he just pointed to (a -> m b) and said, "Well it just fit, you know?"
09:33:36 <twobitsprite> Cale: for purely stylistic reasons, or...?
09:34:09 <ibid> shapr: http://antti-juhani.kaijanaho.fi/tmp/LLParser.hs
09:34:10 <Cale> twobitsprite: mostly. Also, the associativity of ($) might change at some point
09:34:29 <shapr> John Hughes is an amazingly smart guy... you see it in his code, his papers, and his ideas. He's shockingly modest though. I'm not sure he things he's particularly brilliant.
09:34:37 <shapr> s/things/thinks
09:34:49 <Cale> $ is an important part of many Haskell idioms, but you should try to stick to using at most one of them per line
09:35:19 <xerox> @type (($),flip id)
09:35:20 <lambdabot> forall a b b1 c.
09:35:20 <lambdabot>       ((a -> b) -> a -> b, b1 -> (b1 -> c) -> c)
09:35:20 <Cale> which you can always do by forming a composition with (.) and then applying it with ($)
09:35:32 <Cale> ($) is id
09:35:35 <vincenz> hmm
09:35:40 <shapr> ibid: Mind if I blog it?
09:36:01 <xerox> Right.
09:36:01 <ibid> Cale: that's one of the less inspired style rules i've heard
09:36:15 <cptchaos> @index load
09:36:16 <lambdabot> bzzt
09:36:19 <cptchaos> h
09:36:20 <ibid> shapr: go ahead, but if you want to link to it, copy it to your own server :)
09:36:31 <ibid> shapr: and mention that that version is untested :)
09:37:52 <Cale> ibid: well, the benefits are sort of subtle -- it becomes a bit easier to edit code which is written like that
09:38:13 <ibid> Cale: my short experience says just the opposite
09:38:28 <ibid> (short experience with the proposed style, that is)
09:38:35 <Cale> If you take a bunch of code which has a bunch of ($)'s stuck in between, you can't just grab some portion from the middle and copy it somewhere else.
09:38:50 <Cale> (or pull it out into its own definition directly)
09:39:12 <ibid> yes, you can
09:39:23 <Cale> It likely won't typecheck
09:39:26 <ibid> of course, you have to mind the types, but you always have to do that
09:39:47 <Cale> Well, with composition, you don't have to worry, because (.) is associative.
09:40:19 <ibid> hrm, can you give me an example of this difference?
09:40:44 <Cale> Suppose I have  f $ g $ x
09:40:45 <ibid> shapr: where's your blog?
09:41:20 <shapr> http://www.ScannedInAvian.com/~shae/blog/
09:41:21 <Cale> I can't refactor u = f $ g , and write the expression u $ x, because $ doesn't associate
09:41:43 <ibid> shapr: ok, what happened to .org?
09:41:45 <xerox> u = f . g, right?
09:41:50 <Cale> I right
09:41:52 <Cale> right*
09:42:11 <shapr> ibid: Haven't gotten around to setting up the DNS for .org and .net, that's all.
09:42:12 <ibid> Cale: but you can write u x = f $ g x
09:42:17 <shapr> I'll fix it tonight.
09:42:28 <eivuokko> I find it easier to edit code with $ then with ., as $ is larger symbol ;)
09:42:29 <ibid> shapr: the problem is that most of your google results refer to .org
09:42:34 <shapr> oh
09:43:10 <twobitsprite> eivuokko: I usually stray from large symbols as they overshadow the surrounding tokens...
09:43:11 <Cale> ibid: of course, it's just extra editing and thinking about the extra parameter
09:43:15 <ibid> shapr: well, at least many enough that i've tripped on that several separate times
09:43:25 <shapr> I'll fix it in a few hours.
09:43:30 <tromp_> how do you make a pattern irrefutable again?
09:43:34 <Cale> tromp_: ~
09:43:37 <tromp_> ah yes, ~
09:43:38 <ibid> Cale: but you have to think of the types in all cases anyway, so it's no extra effort
09:43:43 <xerox> I'd never write f x = g $ h x, I think, if I don't have to use x anywhere else in that expession.
09:44:01 <Cale> ibid: If you have a composition, then any substring of the components is well-typed.
09:44:06 <xerox> (E.g. in a where clause.)
09:44:12 <Cale> (any contiguous substring)
09:44:29 <ibid> Cale: yes, but it's a special case you have to actively recognize. no saved work there :)
09:44:37 <Cale> hm?
09:45:13 <Cale> I'm saying that if you write your code that way, then that rule makes it easier to edit, and has no disadvantages over using lots of $'s.
09:45:24 <ibid> Cale: it's not in general true in haskell that you can just pull out any substring and make it a defined name, and replace the substring in the original with the name
09:45:40 <Cale> well, it's true of compositions.
09:45:49 <shapr> That is one of the claimed advantages of referential transparency though. 
09:45:55 <Cale> You can always use a single $ at the end to apply too, so there's no extra notational baggage.
09:46:19 <ibid> shapr: no, the claimed advantage of reftrans is that you can take any sub_expression_. what cale's taking out in the $ case is not a subexpression
09:47:09 <Cale> Well, using composition effectively increases the number of subexpressions you have to work with.
09:47:17 <shapr> Ok, I see your point.
09:47:31 <ibid> Cale: i find it much easier to work with a "pipe" where all the piping is of the same kind; i use . where the whole expression is of function type, and $ otherwise
09:48:14 * twobitsprite will just use ( and )... :P
09:48:17 <Cale> Instead of f $ g $ h $ x, you can write f . g . h $ x, and it's essentially the same, but has nicer properties wrt refactoring.
09:48:19 <defcon8> hello
09:48:26 <defcon8> what do students normally use haskell for?
09:48:32 <sili> everything
09:48:33 <Cale> defcon8: programming
09:48:33 <ibid> Cale: i frequently write a "pipe" using . and then replace all the .s with $s after i find that i can't make the expression be a natural function
09:48:51 <Cale> ibid: you only have to replace the last one
09:48:54 <defcon8> Cale :)
09:49:03 <defcon8> programming what kinds of things though
09:49:07 <ibid> Cale: you've said that many times, i don't agree that it's a good option
09:49:16 <defcon8> i know its ambiguous but you know
09:49:33 <shapr> defcon8: I've written a mailing list archive searcher, parts of an irc bot, some software testing programs, and a bunch of other stuff in Haskell.
09:49:43 * twobitsprite is a student of life and uses haskell to entertain himself
09:49:51 <Cale> defcon8: Raytracers, compilers, fractal generators
09:49:53 <defcon8> shapr so youve written very useful stuff?
09:50:03 <defcon8> right so lots of mathematical stuff
09:50:05 <Cale> I've written a pipeline scheduler in Haskell
09:50:17 <Cale> not necessarily mathematical
09:50:20 <shapr> defcon8: Most definitely. I got paid to spend three days writing Haskell to replace a month of failed Java code by someone else.
09:50:31 <sili> shapr: cool!
09:50:32 <defcon8> wow great
09:50:34 <shapr> I didn't tell them I used Haskell, and they didn't care once they had results.
09:50:35 <twobitsprite> shapr: nice
09:50:41 <defcon8> sounds like a fun language haskell does
09:50:45 <defcon8> very different to python
09:50:47 <shapr> Haskell kicks butt.
09:50:54 <defcon8> and i know they are based on totally different concepts
09:51:03 <shapr> Yeah, but it's worth knowing both of them.
09:51:05 <Cale> ibid: so why do you prefer using $ throughout?
09:51:08 <shapr> I came from Python to Haskell.
09:51:28 <defcon8> can you access mysql and stuff from haskell?
09:51:30 <shapr> I still make most of my income from Python, but I'd rather be doing Haskell, because I'd get more done with less work required.
09:51:39 <shapr> Sure, HSQL
09:51:42 <Cale> defcon8: sure, there's a nice database library now
09:51:47 <shapr> or hdbc
09:51:55 <defcon8> you amek money with python?
09:51:58 <defcon8> that is CooL!
09:52:00 <ibid> Cale: as i said, i prefer having the whole "pipe" have the same piping operator. i tried your way once or twice, and i tripped on it frequently enough to know i dislike it
09:52:15 <shapr> Yeah, last six years I've been mostly paid for Python work.
09:52:24 <Cale> http://darcs.complete.org/hdbc/doc/Database-HDBC.html
09:52:27 <sili> what industry?
09:52:42 <shapr> Webmonkey work, but I get to do other stuff occasionally.
09:53:15 <vincenz> webmonkey is a high capabality maturity framework standard for intra-internet peer-cooperation multinational development
09:53:35 <ibid> Cale: $ also has the same mental model as (>>=), only it's right-to-left
09:53:53 <twobitsprite> vincenz: eww... marketing-speech... :P
09:53:57 <shapr> My three day Haskell job was to convert 45mb or so of ms.doc files to a custom XML flavor. So I saved them all as openoffice xml files, and used HXmlToolbox to convert that to their custom flavor.
09:53:58 <Cale> ibid: which I find is a tougher mental model than function composition :)
09:54:07 <earthy> ummmm... $ has the same mentel model als (>>=) ??
09:54:14 <xerox> Haskell was my summer job, woopee :-)
09:54:14 <Cale> as =<<
09:54:14 <earthy> not with me it doesn't!
09:54:20 <ibid> Cale: well, to each his or her own :)
09:54:31 <Cale> sort of
09:54:34 <shapr> The failed month of Java code I replaced was trying to use MSXML, Javascript, XSLT, and a bunch of other stuff.
09:54:36 <Cale> @type (=<<)
09:54:37 <earthy> $ doesn't have a side-channel, =<< does
09:54:38 <lambdabot> forall b (m :: * -> *) a.
09:54:38 <lambdabot>    (Monad m) =>
09:54:38 <lambdabot>    (a -> m b) -> m a -> m b
09:54:41 <Cale> @type ($)
09:54:42 <lambdabot> forall b a. (a -> b) -> a -> b
09:54:43 <earthy> *big* *huge* difference
09:54:54 <ibid> Cale: i don't have a problem with you doing what you like, what i dislike is selling my way as something one should not do :)
09:55:25 <Cale> ibid: well, there's been talk of changing $'s associativity
09:55:28 <ibid> earthy: no side channel in the Identity monad :)
09:55:39 <earthy> ibid: true enough
09:55:42 <ibid> Cale: which will break a lot of existing code
09:55:50 <Cale> ibid: to match the associativity of function application
09:55:53 <vincenz> huh?
09:56:01 <earthy> but you could also state that as 'empty side channel in the Identity monad'
09:56:03 <shapr> defcon8: In my opinion, Haskell is the most powerful production quality language available today. But you should try it yourself and see if you like it.
09:56:09 <vincenz> > (+1) =<< 1
09:56:10 <lambdabot>  add an instance declaration for (Num (m (m b)))
09:56:17 <earthy> anyway, it's 7 already
09:56:20 <earthy> time to go home and make dinner
09:56:21 <ibid> Cale: i actually agree that a left-associative explicit application operator is a good idea
09:56:22 <shapr> Time for CODE!
09:56:41 <ibid> Cale: i'm just not comfortable with changing such established operator so profoundly
09:56:50 <xerox> Noo.
09:57:34 <defcon8> oh i had something to ask
09:57:34 <vincenz> something like
09:57:42 <defcon8> how do i define an integer in ghci?
09:57:49 <ibid> earthy: actually, the abstract level where i view (=<<) and ($) as similar is one where the difference of a side channel is abstracted away :)
09:57:51 <Cale> let a = 5
09:57:52 <defcon8> what was in the yaht didnt seem to work
09:57:54 <vincenz> > let (...) = flip ($) in [1..10]...reverse
09:57:55 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
09:58:06 <Cale> defcon8: you really need to write your declarations into a file
09:58:14 <Cale> defcon8: and load that file in ghci
09:58:22 <defcon8> hmm :|
09:58:32 <Cale> defcon8: you can easily reload the file with  :r
09:58:41 <defcon8> does haskell-mode come with emacs?
09:58:53 <ValarQ> defcon8: nope
09:59:02 <Cale> (though it exists)
09:59:07 <ibid> Cale: i also recognize that the old, original reason for right-associativity of ($) is dead, but that doesn't change the fact that there's probably a lot of code out there that assumes it
09:59:07 <defcon8> i did let int a = 1
09:59:12 <defcon8> then
09:59:14 <defcon8> a
09:59:16 <defcon8> and i got an error
09:59:17 <vincenz> > let (...) = flip ($) in [1..10]...reverse...(map (+2))
09:59:18 <lambdabot> [12,11,10,9,8,7,6,5,4,3]
09:59:27 <vincenz> > let (...) = flip ($) in [1..10]...reverse...(map (+2))...(map (`div` 2))
09:59:28 <lambdabot> [6,5,5,4,4,3,3,2,2,1]
09:59:41 <ibid> shapr: so are you going to blog about it soon? :)
09:59:45 <vincenz> and haskell has OO syntax :P
09:59:45 <Cale> defcon8: what error?
09:59:51 <xerox> > (+1) >>= (+) $ 1
09:59:52 <lambdabot> 3
10:00:05 <xerox> > (+1) >>= (*) $ 2
10:00:06 <lambdabot> 6
10:00:07 <defcon8> out of scope error
10:00:09 <vincenz> xerox: yicky
10:00:12 <xerox> ^_^
10:00:19 <vincenz> what is that?
10:00:30 <xerox> Black Monad magic!
10:00:44 <xerox> s/Black/Reader/, s/magic//
10:00:59 <Cale> vincenz: the PLEAC haskell code does that, hiding the composition operator
10:01:00 <ibid> > (id >>> id) 4
10:01:02 <lambdabot> 4
10:01:11 <Cale> vincenz: the result doesn't look anything much like Haskell anymore
10:01:17 <vincenz> Cale: :D
10:01:18 <ibid> > (first (+2) >>> id) (4,4)
10:01:19 <lambdabot> (6,4)
10:01:29 <luqui> is there a way to do an "impure" show?
10:01:41 <luqui> that is, can I write foo :: a -> String
10:01:42 <ibid> luqui: you mean the print function?
10:01:45 <eivuokko> print?
10:01:50 <ibid> @type print
10:01:51 <lambdabot> forall a. (Show a) => a -> IO ()
10:01:56 <Cale> vincenz: which is sort of terrible, since people will probably try it, and then wonder what's wrong.
10:02:05 <luqui> ibid, not quit
10:02:06 <luqui> e
10:02:08 <vincenz> DOH
10:02:08 <ibid> luqui: foo is pure, the problem is it's unimplementable
10:02:10 <vincenz> just died
10:02:11 <luqui> I want to take off the (Show a) constraint
10:02:25 <ibid> luqui: well then just write foo _ = "Hei!"
10:02:26 <ibid> :)
10:02:38 <luqui> ibid, thanks so much, that's exactly what I was looking for :-/
10:02:41 <Cale> vincenz: it also shadows !! with an operator which takes a list of indices to look up
10:02:43 <ibid> luqui: what you want done cannot be done (how would you show a function?)
10:02:55 <luqui> ibid, by saying "Can't show this"
10:03:07 <xerox> Hence you'll need a typeclass, and make instances.
10:03:09 <ibid> luqui: why do you want something like that?
10:03:12 <luqui> but printing it, not dying with a compile error
10:03:24 <luqui> ibid, so I can stick it inside an arrow
10:03:41 <ibid> hmm, ok that's a better reason :)
10:03:42 <luqui> because arrows don't let you have typeclass constraints
10:04:23 <xerox> Oh.
10:04:43 <luqui> ibid, could I do it by implementing my own Showesque class
10:04:48 <luqui> with a default implementation?
10:04:49 <xerox> Is the reason the fact that you can't "extend" the typelcass tree upwards?
10:04:54 <xerox> *typeclasses
10:04:58 <luqui> (it's okay if I can't show everything that can be shown)
10:05:04 <vincenz> Cale: oy
10:05:06 <luqui> oh wait, no, that doesn't work
10:05:09 <ibid> luqui: the problem is, your function foo will essentially get a pointer to (the thunk generating) the value, but it has no idea what type it is
10:05:28 <ibid> luqui: and no way to discover it
10:05:34 <luqui> right, I understand now
10:06:09 <luqui> hmmm...
10:06:32 <luqui> seems like i need to step up a level in what I want to do, because this way isn't happening
10:06:41 <ibid> luqui: the class constraint gets translated into a hidden parameter to the function, (simplified:) providing the actualy function that implements show for that type
10:06:44 <Cale> what is it that you're trying to do?
10:07:10 <luqui> Cale, allow for a type of function that asks the user what to do
10:07:28 <luqui> but, in line with my previous question, allow the user to answer the questions in whatever order he likes
10:07:30 <Cale> that would be something like  a -> IO b
10:07:39 <Cale> that would involve a GUI
10:07:47 <Cale> (probably)
10:07:50 <luqui> Cale, or a crude console interface
10:08:01 <ibid> or Kleisli IO a b, given that we're talking about arrows :)
10:08:04 <luqui> (1) what is 1+1.   (2) what is 2+2
10:08:15 <luqui> I choose to answer question (2)
10:08:17 <Cale> luqui: sure
10:08:34 <Cale> That's not hard to set up :)
10:08:47 <luqui> and an arrow looks like the right structure, except that i can't ask all questions because i cannot print all values
10:09:11 <ibid> luqui: where do you get the value you want to print?
10:09:22 <luqui> ibid, as the input to the arrow
10:09:25 <ibid> luqui: as input to the arrow or from the arrow "side channel"?
10:09:29 <shapr> ibid: Yeah, I'll have an entry up in a few hours. Right now I have to finish some paying work first.
10:09:38 <luqui> ibid, hmm, side channel?
10:09:50 <Cale> data Option a = Option Integer String (IO a)
10:09:50 <luqui> Cale, it isn't?  give me a pointer then?
10:10:17 <ibid> luqui: ok, if it's the input, why can't you just have an arrow showMeArrow :: Show i => MyArrowType i o
10:10:17 <Cale> write a function of type  [Option a] -> IO a
10:10:20 <ibid> or something
10:10:27 <sjanssen> what is the type of a question?
10:10:31 <luqui> ibid, I'm not sure that is possible
10:10:37 <ibid> luqui: why?
10:10:44 <Cale> which prints the menu, asks for a number, looks it up, and then runs the associated action for a result
10:10:44 <sjanssen> whoa, I'm ten minutes behind, disregard
10:10:52 <Cale> you could also use a more sophisticated type
10:11:05 <araujo> Hello
10:11:07 <defcon8> how did you load files in ghci?
10:11:08 <luqui> Cale, I want to be able to pipe the computations together and such
10:11:16 <luqui> composing and whatnot...
10:11:25 <Cale> luqui: sure, you get back the result
10:11:35 <araujo> There exist a function in the prelude to remove duplicated elemente in a list?
10:11:36 <Cale> you can still chain things onto it
10:11:42 <araujo> (*in the prelude*)
10:11:46 <luqui> Cale, and determine which new things to ask before receiving all answers
10:11:47 <luqui> ?
10:11:49 <ibid> luqui: i mean, the constraint ought to be carried along when you combine that arrow with other arrows
10:11:55 <shapr> defcon8: I use C-c C-l in emacs, but you can also use :load ModuleName
10:11:56 <luqui> ibid, let me give it a try
10:12:05 <defcon8> ok thanks shapr
10:12:11 <ibid> luqui: what you can't do is require every input to every arrow of your type be in Show
10:12:21 <Cale> luqui: well, you get just one answer -- I suppose you should also pass back the index of the question that was answered
10:12:22 <defcon8> shapr how do i make emacs use ghci?
10:12:27 <defcon8> instead of hugs
10:12:32 <ibid> luqui: which is, as i understand it, the problem the CGI arrow ran into
10:12:39 <luqui> Cale, it's a loop
10:12:55 <Cale> luqui: not a problem
10:13:06 <araujo> anyone?
10:13:11 <luqui> but it seems like it would get very complicated and micromanagey
10:13:23 <Cale> araujo: not in the Prelude, in Data.List
10:13:26 <Cale> araujo: nub
10:13:27 <luqui> but let me try ibid's arrow suggestion
10:13:29 <eivuokko> araujo, You mean Data.List.nub isn't an answer? :) (Or in H98, List.nub)
10:13:38 <Cale> luqui: you could use a state monad
10:13:49 <araujo> Thansk Cale 
10:13:58 <luqui> Cale, I don't think you're understanding
10:14:17 <Cale> luqui: well, it sounds like you want to have a system of menus
10:14:18 <defcon8> shapr do you know?
10:14:39 <Cale> which may be altered as the user answers them
10:14:44 <luqui> Cale, just a list of "pending questions", asking new questions as soon as what question it is is known
10:14:51 <araujo> @hoogle nub
10:14:52 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
10:14:52 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
10:14:55 <luqui> but it's all to a underlying computation
10:15:04 <luqui> which is complex, and I don't want to have to manage all the dependencies myself
10:15:30 <Cale> hmm
10:15:43 <Cale> the questions are affecting some computation?
10:15:55 <defcon8> anyone?
10:16:04 <luqui> brb
10:16:11 <luqui> I think I might have figured this out
10:16:14 <Cale> defcon8: I thought it did
10:16:25 <luqui> but let me encode it into haskell, so it can tell me if I did
10:16:40 <luqui> (that's the great thing about Haskell: you can't even finish writing it if you don't know what you're doing)
10:17:28 <kosmikus> I have this program:
10:17:35 <kosmikus> module Main where; import System; main = putStrLn "Hello" >> system "echo world" >> return ()
10:17:37 <Cale> luqui: is this multithreaded?
10:17:43 <twobitsprite> defcon8: just use vim and an xterm...
10:17:44 * twobitsprite ducks
10:17:51 <kosmikus> if I compile it and run it, I get "Hello\nworld" on the screen
10:17:56 <luqui> Cale, it's kind of pseudomultithreaded
10:17:56 <Cale> twobitsprite: good suggestion :)
10:18:00 <defcon8> Twigathy i want to use emacs
10:18:07 <kosmikus> if I compile it and run it and redirect the output into a file, I get "world\nHello"; why?
10:18:10 <defcon8> Cale it is trying to search for hugs
10:18:12 <Cale> defcon8: then emacs and an xterm :)
10:18:16 <defcon8> maybe i need tyo put ghci in the path
10:18:17 <Cale> (or gnome-terminal :)
10:18:22 <ibid> kosmikus: buffering
10:18:23 <shapr> defcon8: M-x turn-on-haskell-ghci
10:18:27 <twobitsprite> (or konsole)
10:18:33 <kosmikus> ibid: can you explain?
10:18:34 <ibid> kosmikus: terminal is line-buffered, files are fully buffered
10:18:55 <ibid> kosmikus: when you're writing to a terminal, '\n' flushes the buffer
10:19:17 <ibid> kosmikus: but when you're writing to a file, it waits until you've written enough (4k or so) or until the end of the program until it flushes the buffer
10:19:35 <ibid> kosmikus: flushing is, obviously, the place where the stuff becomes visible in the actual file
10:19:43 <twobitsprite> ibid: is there a way to force a flush?
10:19:50 <Cale> hFlush
10:19:51 <kosmikus> I'll try, thanks
10:19:53 <kosmikus> hFlush
10:19:54 <ibid> twobitsprite: yes
10:20:03 <Cale> @type System.IO.hFlush
10:20:04 <lambdabot> GHC.IOBase.Handle -> IO ()
10:20:15 <vincenz> sounds like a toilet
10:20:20 <vincenz> pull the handle...and down it goes
10:20:26 <twobitsprite> heheh
10:20:58 <twobitsprite> vincenz: then maybe the type should be GHC.IOBase.Handle -> IO (_|_)
10:21:08 <vincenz> hehe
10:21:23 <vincenz> input out of type bottom
10:21:31 <vincenz> > _|_
10:21:31 <lambdabot>  parse error on input `|'
10:21:33 <tromp_> @index fix
10:21:34 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.
10:21:34 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.
10:21:34 <lambdabot> Error
10:22:06 <vincenz> twobitsprite: and you'd have transformers
10:22:16 <vincenz> (_(_) -> (_|_)
10:22:23 <vincenz> hShake
10:22:29 <ibid> oh, and stderr is always unbuffered by default
10:23:07 <vincenz> obviously
10:24:25 <kosmikus> ibid: that seems to work so far, thanks; I do, however, still not really understand why this buffering affects the order of the output
10:24:53 <kosmikus> ok, different processes use different buffers probably
10:24:54 <ibid> kosmikus: the echo subprocess that you launch flushes its buffers before you flush yours when you're writing to a file
10:25:03 <twobitsprite> vincenz: lmao
10:25:13 <defcon8> int a = 1;
10:25:13 <defcon8> show (a+2)
10:25:18 <defcon8> why is that not working when i run it
10:25:23 <defcon8> oh i forgot the semicolon
10:25:36 <ibid> defcon8: what language is that supposed to be?
10:25:36 <defcon8> that doesn't solve it either
10:25:51 <ibid> looks like C, but the show is strange
10:25:51 <defcon8> haskell :|
10:25:57 <ibid> defcon8: that's not haskell :)
10:25:58 <shapr> defcon8: http://www.haskell.org/hawiki/HaskellDemo
10:26:07 <ibid> defcon8: let a = 1 in show (a+2)
10:26:21 <defcon8> naah im running this from a file
10:26:22 <Cale> > let a = 1 in show (a + 2)
10:26:23 <lambdabot> "3"
10:26:44 <Cale> defcon8: you'll have to define a main if you're compiling a program
10:26:47 <ibid> defcon8: a file is a collection of definitions
10:26:58 <Cale> (and not just loading the file in ghci to evaluate expressions)
10:27:07 <defcon8> okay then
10:27:22 <Cale> main = print (a + 2)
10:27:32 <Cale>   where a = 1
10:27:40 <ibid> a = 1
10:27:46 <ibid> main = print (a + 2)
10:27:48 <xerox> a = 1 :: Int
10:27:52 <Cale> or as a separate binding, sure
10:28:20 <ibid> or
10:28:22 <ibid> a :: Int
10:28:24 <ibid> a = 1
10:28:27 <ibid> (etc)
10:28:29 <ibid> :)
10:29:14 <xerox> data Nat = Zero | Succ Nat -- hihi...
10:29:20 <defcon8> hmm
10:29:30 <defcon8> can i just put main?
10:29:45 <Cale> defcon8: hm?
10:29:48 <ibid> defcon8: i don't understand the question
10:30:08 <Cale> defcon8: put main where?
10:30:21 <defcon8> on the demo they never start a mainm
10:30:38 <Cale> defcon8: that's because the file is intended to be loaded in ghci
10:30:50 <Cale> where you can play around with the extra definitions
10:30:58 <defcon8> yeah
10:31:04 <defcon8> how do
10:31:19 <Cale> If you want to write a program which does something on its own, then you have to define a main for it.
10:31:21 <defcon8> ok how would i make a = 1 work in a normal haskell file then?
10:31:28 <defcon8> how is that done?
10:31:33 <Cale> Just write  "a = 1" somewhere
10:31:39 <Cale> and load the file in ghci
10:31:46 <Cale> (in your file)
10:31:57 <defcon8> id rather just work it from emacs
10:31:57 <xerox> Haskell, and you'll not read Just as before.
10:32:32 <Cale> defcon8: well, same principle applies
10:32:41 <ibid> kosmikus: the buffers are handled generally by the runtime system (or C libraries, depending), so yeah, each process has its own for each file open
10:32:59 <Cale> defcon8: you save your file, and get the ghci to reload it
10:33:03 * xerox laughs alone for the pun, hah.
10:33:09 <ibid> data Maybe a = Yup a | Nope
10:33:18 <ibid> xerox: :)
10:33:40 <luqui> how do I turn on arrow syntax?
10:33:43 <ibid> "Just" never made any sense to me
10:33:47 <ibid> luqui: -farrows
10:35:05 <defcon8> http://pastebin.com/601769
10:35:06 <twobitsprite>  I like how Ocaml uses "type 'a maybe = None | Some x"
10:35:07 <defcon8> why isnt that working?
10:35:26 <defcon8> whoops i made another mistake
10:35:37 <twobitsprite> er... "type 'a maybe = None | Some a"
10:35:40 <defcon8> the add a should be adder a
10:35:43 <defcon8> but it doesnt work still
10:36:49 <twobitsprite> I don't think "show" actually displays things to the screen... it just converts it to a string... you'll need to actually print it
10:37:35 <defcon8> still doesnt work
10:38:00 <defcon8> do i need to do print (adder a) or print show(adder a)
10:42:22 <twobitsprite> defcon8: sorry... I new to Haskell too.. but I think it should be "print (show x)"
10:42:34 <twobitsprite> you'll have to wait until the others unidle
10:42:50 <Igloo> print x == putStrLn (show x)
10:43:11 <Igloo> print (adder a) is probably right, but I haven't been following
10:44:08 <kosmikus> ibid: I have another problem which might be related to buffering and which I don't understand. perhaps you can help me there, too ;)
10:44:12 <defcon8> Igloo is is an int
10:44:26 <kosmikus> the program is the following:
10:44:37 <kosmikus> module Main where import System; main = getArgs >>= system . head
10:44:47 <kosmikus> i.e., it's just a simple wrapper around the system command
10:44:57 <defcon8> kosmikus do you know what i could do?
10:45:12 <kosmikus> defcon8: ?
10:46:28 <kosmikus> anyway, if I call "./Sys "yes | head -n 20000000 | tee /dev/null", my program quits with "tee: write error". why?
10:47:19 <defcon8> http://pastebin.com/602039 kosmikus can you make that work?
10:47:30 <kosmikus> defcon8: the last line isn't a declaration
10:47:56 <defcon8> should it be?
10:48:09 <kosmikus> defcon8: a Haskell file can only contain declarations
10:48:34 <kosmikus> defcon8: load the file into ghci (with the last line removed), and then type in the last line at the prompt
10:48:42 <defcon8> thanks
10:48:59 <kosmikus> but you'll get a type error
10:49:24 <defcon8> still didnt work
10:49:51 <kosmikus> what error do you get?
10:50:04 <defcon8> new.hs:2:3: parse error on input `;'
10:50:04 <defcon8> Failed, modules loaded: none.
10:50:36 <kosmikus> I can't see an error in line 2 of your example
10:50:42 <defcon8> cant?
10:50:52 <kosmikus> anyway, I have to catch my bus; will be back online in about 15 minutes
10:50:57 <kosmikus> ibid: any ideas?
10:51:03 <defcon8> thanks for the help
10:54:15 <SyntaxNinja> hm. is it not possible to build ghc 6.2 using ghc 6.4?
10:54:49 <defcon8> why dont you try?
10:57:32 <defcon8> anyone else help?
10:59:21 <twobitsprite> defcon8: try reading a tutorial
10:59:39 <twobitsprite> defcon8: haskell.org has a lot of good info
10:59:41 <defcon8> thats a point
11:00:41 <bolrod> thats a site
11:08:44 <kosmikus> SyntaxNinja: no, afaik it's not.
11:09:16 <kosmikus> defcon8: paste again the file that you tried to load into ghci, please.
11:10:17 <defcon8> kosmikus http://pastebin.com/602126
11:12:01 <defcon8> kosmikus you know what to do?
11:12:35 <kosmikus> defcon8: that loads into ghci without errors
11:12:41 <kosmikus> I just tried it
11:12:50 <defcon8> what the crap :|
11:13:06 <bolrod> defcon8: that looks like imperative programming :/
11:13:27 <bolrod> :)
11:13:41 <defcon8> wanna show me how i should do it in haskell style?
11:14:18 <defcon8> kosmikus doesnt bloody word
11:14:24 <defcon8> i need to use :load dont i?
11:14:50 <SyntaxNinja> kosmikus: darn
11:14:51 <kosmikus> yes, or just use "ghci MyFile.hs" to start ghci
11:15:11 <kosmikus> SyntaxNinja: what's the problem?
11:15:43 <defcon8> nope didnt work
11:16:09 <SyntaxNinja> kosmikus: well, my version of ghc 6.2.1 has bitrotted because of some libraries changing on sid, but I still need that version for some stuff, and I'm having trouble recompiling it.
11:16:36 <defcon8> what the hell is wrong with this
11:17:06 <SyntaxNinja> defcon8: calm down and try it step by step.  use "less" or something to make sure that the file you're loading into ghci is the same as the one you're pasting.  
11:17:07 * defcon8 kicks ghci
11:17:12 <SyntaxNinja> what'st he error you get? 
11:17:13 <bolrod> what do you want to do ?
11:17:18 <defcon8> SyntaxNinja it is the same one
11:17:43 <defcon8> parse error on input ';'
11:17:55 <bolrod> if you want a function that increases something with one
11:18:04 <bolrod> increment = (+1)  
11:18:06 <bolrod> would work
11:18:17 <defcon8> yeah but that isnt what im trying to do
11:18:18 <bolrod> so then you do  q = increment y
11:18:19 <SyntaxNinja> defcon8: what ghc vefrsion?
11:18:22 <bolrod> then q = y+1
11:18:23 <defcon8> im trying to learn about using functions
11:18:30 <defcon8> 6.4.1 for windows
11:18:43 <kosmikus> bolrod: all that doens't explain why defcon cannot load a syntactically correct file
11:18:51 <bolrod> hmm
11:19:24 <kosmikus> SyntaxNinja: can't you just download a new debian package?
11:19:38 <bolrod> that in the pastebin loads fine for me
11:19:39 <bolrod> :/
11:19:54 <SyntaxNinja> kosmikus: a new debian package of 6.2.1?
11:20:07 <SyntaxNinja> kosmikus: I want both 6.4 and 6.2 on this machine?
11:20:21 <SyntaxNinja> that's not a question, actually.
11:20:51 <defcon8> i think ill dl hugs
11:21:08 <bolrod> ghci works fine 
11:21:15 <mwc> Wha?!
11:21:21 <mwc> I just wrote a pure haskell program
11:21:25 <mwc> it segfaulted
11:21:29 <bolrod> urh
11:21:33 <bolrod> haha
11:21:37 <bolrod> on linux?
11:21:41 <mwc> yes
11:21:47 <bolrod> hmm
11:21:51 <SyntaxNinja> #haskell has entered the twilight zone
11:22:03 <bolrod> you installed a weird kernel lately?
11:22:04 <mwc> there was an array of 10^6 elements involved
11:22:06 * twobitsprite plays some creepy music
11:22:07 <kosmikus> SyntaxNinja: ok, but you'll have to download a new binary package from somewhere
11:22:08 <bolrod> ;o
11:22:09 <SyntaxNinja> defcon8: I wouldn't spend much time blaming the compiler if I were you.  Something else is wrong, and you should invest some energy in figuring that out.
11:22:16 <mwc> no, arch linux standard kernel
11:22:33 <bolrod> defcon8: what is the code you trying to load?
11:22:38 <bolrod> weird..
11:22:46 <bolrod> maybe set the parameter so it can use more memory?
11:22:57 <mwc> I got a stack overflow when I had a 2D array this size
11:23:03 <mwc> strange a 3D array this size is so much worse
11:23:07 <mwc> yeah, I'll do that
11:23:12 <mwc> 16 MB ought to be plenty for a stack
11:23:14 <bolrod> 10^6 is alot
11:23:25 <mwc> er, 10^5
11:23:27 <bolrod> hmm
11:23:28 <SyntaxNinja> mwc: was it a seg fault, or it ran out of stack? that's totally different
11:23:38 <mwc> SyntaxNinja, it was segfault
11:23:40 <defcon8> SyntaxNinja well it shouldnt be wrong
11:23:42 <SyntaxNinja> y0w
11:23:49 <bolrod> upgraded gcc lately?
11:23:54 <bolrod> maybe it does something totally weird
11:24:04 <mwc> not using -fvia-c
11:24:15 <mwc> or does -O2 imply that?
11:24:28 <bolrod> doesn't it always go to .c first?
11:24:43 <mwc> Not on x86 where there's a native code generator
11:24:47 <twobitsprite> when in doubt, twiddle your compiler flags...?
11:25:33 <mwc> lisppaste2, url?
11:25:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:25:49 <sieni> mwc: well, running out of (c-)stack should cause a segfault as far as I know
11:26:10 <bolrod> erh
11:26:12 <lisppaste2> mwc pasted "Segfault!" at http://paste.lisp.org/display/17872
11:26:15 <SyntaxNinja> kosmikus: good idea, I'll try a binary build and see how that goes...
11:26:19 <bolrod> or it just says stack overflow..
11:26:25 <bolrod> at least.. thats what it said here
11:26:26 <mwc> sieni, maybe that's it?
11:26:29 <mwc> I'll try a giant stack
11:26:33 <SyntaxNinja> kosmikus: I was stuck thinking just that a debian binary package wouldn't work, but those generic ones might.
11:26:58 <bolrod> debian stable packages that not work?
11:27:01 <mwc> What does thsi mean:
11:27:02 <mwc> [matt@iron assn4]$ ./assn4 +RTS -K16000000
11:27:02 <mwc> assn4: <<loop>>
11:27:02 <mwc> [matt@iron assn4]$ ./assn4 +RTS -K8000000
11:27:02 <mwc> Segmentation fault
11:27:08 <bolrod> ;o
11:27:13 <bolrod> yes\
11:27:18 <mwc> must be a stack issue
11:27:30 <bolrod> must be some function that loops untill it overflows stack?
11:27:53 <mwc> yeah, must be
11:28:00 <bolrod> you have a function called assn4 ?
11:28:07 <mwc> no, that's the executable
11:28:12 <bolrod> ah
11:28:18 <sieni> bolrod: I don't know about internals of GHC, but of course it is possible that with some compiler options it can handle stack overflows gracefully by checking the amount of stack in use on every function call, but if you have optimizations on it might blow the stack without warning
11:28:35 <mwc> I'll try disabling all optimizations
11:28:38 <bolrod> aha
11:28:51 <mwc> This was on -O1
11:28:52 <SyntaxNinja> mwc: which ghc?
11:28:56 <mwc> 6.4.1
11:29:06 <mwc> x86 Linux
11:29:19 <xerox> Anybody knows about GHC and the Intel Core Duo?
11:29:38 <sjanssen> what about them?
11:29:44 <bolrod> I thought ghc makes c-code.. and lets gcc compile it.. so it uses the optimalisation of gcc.. not sure though
11:29:44 <mwc> Nope, with no optimzatoi
11:29:54 <mwc> with no optimization flags, I still segfault
11:29:56 <SyntaxNinja> kosmikus: eh, the ones online are linked against the wrong version of libreadline. 
11:30:00 <twobitsprite> does haskell have keyword or optional arguments?
11:30:07 <mwc> no
11:30:24 <kosmikus> SyntaxNinja: 4 instead of 5?
11:30:34 <xerox> sjanssen: is it ported on those processors?
11:30:44 <SyntaxNinja> kosmikus: ja
11:30:53 <mwc> xerox, afaik, core due is vanilla x86, so it should just work
11:30:54 <SyntaxNinja> or at least the one I tried does, I guess the other one does too.
11:31:01 <kosmikus> SyntaxNinja: try to make a symlink of 5 to 4. that should work for bootstrapping, actually.
11:31:02 <sjanssen> xerox: there is work being done on an SMP version of GHC
11:31:12 <mwc> there might not be much cpu specific optimization
11:31:26 <xerox> Ah, I see.  Interesting.
11:32:07 <flux__> sjanssen, so that it would compile single files with multiple threads or just multiple files?
11:32:14 <SyntaxNinja> kosmikus: you are right! w00w00
11:32:18 <flux__> (which is great already, of course)
11:32:37 <xerox> sjanssen: what's the good part about GHC on SMP?
11:32:53 <sjanssen> flux__: I'm talking about a GHC that can run several threads simultaneously (ie reap the benefits of dual processors)
11:33:01 <flux__> oh, right
11:33:15 <sjanssen> xerox: pretty much what I just said to flux__
11:33:29 <flux__> sjanssen, so smp gc and all that?
11:33:45 <xerox> Oh-kay.
11:33:46 <flux__> hmh, s/smp/concurrent, thread-safe/
11:33:47 <sjanssen> I think GC is single threaded
11:34:10 <mwc> So I changed the array to a 16x16x16, and it still segfaults
11:34:13 <flux__> the threads would stop when gc is run?
11:34:14 <sjanssen> there is a very interesting paper by the Simons, I'll look it up
11:34:18 <mwc> I must have really screwed something up
11:35:32 <sjanssen> flux__: http://research.microsoft.com/%7Esimonpj/papers/parallel/index.htm
11:36:20 <flux__> I think I've read that..
11:36:26 <mwc> I think I screwed up an implemantation of Ix for an indexing class, let me see if that's it
11:37:31 <xerox> Cool, thanks for the link.
11:38:59 <mwc> xerox, just get a lappy with a core duo?
11:39:16 <xerox> mwc: nope, an iMac (the BIG one, <evil laugh>)
11:39:45 <bolrod> ;o
11:41:32 * xerox got bored of small displays, foo!
11:41:52 <bolrod> then why get an iMac?
11:42:29 <bolrod> the biggest is 20"
11:42:53 <bolrod> you could get a 24" screen if you buy the powermac with intel duo  when it comes out
11:42:56 <bolrod> :)
11:44:36 <bolrod> why is the iMac G5 still this expensive...
11:44:40 <sjanssen> bolrod: 24" screen + new powermace = about 5 billion dollars ;)
11:44:44 <xerox> I have a finite amount of funds.
11:44:50 <xerox> Exactly :-)
11:44:53 <sjanssen> haha, powermace would be way better than a powermac
11:45:03 <twobitsprite> what's an easy way to create a list of repeated elements?
11:45:15 <sjanssen> > cycle "ab"
11:45:17 <lambdabot> "ababababababababababababababababababababababababababababababababababababab
11:45:17 <lambdabot> abababababababababababababababababababababababababababababababababababababa
11:45:17 <lambdabot> bababababababababababababababababababababababababababababababababababababab
11:45:17 <lambdabot> abababababababababababababababababababababababababababababababababababababa
11:45:17 <lambdabot> bababababababababababababababababababababababababababababababababababababab
11:45:17 <xerox> Yup.  repeat.
11:45:19 <lambdabot> [23 @more lines]
11:45:29 <xerox> @type repeat
11:45:30 <lambdabot> forall a. a -> [a]
11:45:33 <bolrod> @more
11:45:33 <bolrod> !
11:45:37 <bolrod> arg
11:45:46 <xerox> What was the other one...
11:45:52 <sjanssen> @type cycle
11:45:54 <lambdabot> forall a. [a] -> [a]
11:45:59 <twobitsprite> so... take 10 (cycle 0)
11:46:05 <twobitsprite> >take 10 (cycle 0)
11:46:09 <twobitsprite> > take 10 (cycle 0)
11:46:10 <lambdabot>  add an instance declaration for (Num [a])
11:46:10 <sjanssen> type error
11:46:10 <xerox> @hoogle Int -> a -> [a]
11:46:11 <lambdabot> Data.List.replicate :: Int -> a -> [a]
11:46:11 <lambdabot> Prelude.replicate :: Int -> a -> [a]
11:46:11 <lambdabot> Data.List.repeat :: a -> [a]
11:46:12 <bolrod> ;p
11:46:29 <jethr0_> > take 10 $ cycle [0]
11:46:30 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
11:46:40 <twobitsprite> > take 10 (cycle [0])
11:46:41 <bolrod> take 10 $ repeat 0
11:46:41 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
11:46:42 <sjanssen> twobitsprite: what you really want is replicate
11:46:46 <bolrod> > take 10 $ repeat 0
11:46:46 <xerox> replicate 10 0  ==> [0,0,0,0,0,0,0,0,0,0]
11:46:47 <lambdabot> [0,0,0,0,0,0,0,0,0,0]
11:47:08 <bolrod> @arr
11:47:09 <lambdabot> This is the END for you, you gutter-crawling cur!
11:47:17 <bolrod> :)
11:47:32 <xerox> @pl (. repeat) . take
11:47:33 <lambdabot> (. repeat) . take
11:47:55 <xerox> @pl \n x -> take n $ repeat x
11:47:56 <lambdabot> (. repeat) . take
11:47:59 <xerox> Hmpf.
11:48:10 <sjanssen> xerox: what are you trying to do?
11:48:19 <bolrod> > take 10 $ iterate (0:) []
11:48:20 <lambdabot> [[],[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],
11:48:20 <lambdabot> [0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]]
11:48:23 <xerox> Get replicate.
11:48:23 <bolrod> hmm
11:48:42 <xerox> > iterate (0:) [] !! 11
11:48:43 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0]
11:48:48 <bolrod> yes
11:49:32 <bolrod> > take 10 $ until ([]) (0:) [0]
11:49:33 <lambdabot> Couldn't match `[a]' against `t -> t1'
11:49:36 <bolrod> awh
11:49:54 <bolrod> > take 10 $ until (length == 0) (0:) [0]
11:49:55 <lambdabot> Couldn't match `Bool' against `t -> t1'
11:50:02 <bolrod> ^.0
11:50:12 <bolrod> > take 10 $ until (0==length) (0:) [0]
11:50:13 <lambdabot> Couldn't match `Bool' against `t -> t1'
11:50:33 <bolrod> this can't work?
11:50:37 <sjanssen> > take 10 $ until (\x -> 0== length x) (0:) [0]
11:50:37 <bolrod> blah
11:50:41 <lambdabot> Terminated
11:50:43 <bolrod> ah yes
11:50:51 <bolrod> so much for lazy evaluation
11:50:53 <bolrod> :P
11:51:51 <mwc> I 've traced the segfault business to a bad implementation of inRange for an Ix instance
11:51:52 <mwc> go figure
11:52:22 <bolrod> hm.. maybe it wants to take the first 10.. but it can never get the first 10 because the list is infinite from the start?
11:52:31 <bolrod> so ... the list essentially never begins but it does end?
11:52:32 <bolrod> haha
11:52:34 <bolrod> weird 8)
11:52:42 <bolrod> sooo
11:53:00 <bolrod> > take 10 $ reverse(until (\x -> 0== length x) (0:) [0])
11:53:04 <lambdabot> Terminated
11:53:07 <sjanssen> @type until
11:53:07 <bolrod> hmm
11:53:08 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
11:53:15 <bolrod> weird..
11:53:23 <sjanssen> it makes total sense
11:53:29 <sjanssen> > length [0]
11:53:31 <lambdabot> 1
11:53:34 <bolrod> yes
11:53:42 <bolrod> it starts making an infinite list
11:53:46 <bolrod> then you take the first 10 out of it
11:53:59 <bolrod> so with lazy evaluation.. it 'should' end.. right?
11:54:03 <sjanssen> no
11:54:09 <bolrod> becuase?
11:54:45 <sjanssen> "until" doesn't return anything until it finds something that satisfies it's predicate, right?
11:54:59 <bolrod> hmm
11:55:01 <bolrod> yes
11:55:29 <bolrod> iterate does that...
11:55:44 <twobitsprite> can someone show me an example of a tail recursive function with an accumulator in haskell?
11:56:14 <bolrod> eh?..  fibonacci sequence?
11:56:41 <twobitsprite> I'm just trying to get an idea of how to do that with good style in haskell...
11:56:58 <sjanssen> > let afac 0 acc = acc; afac n acc = afac (n-1) (n*acc) in afac 10
11:57:00 <lambdabot>  add an instance declaration for (Show (a -> a))
11:57:10 <sjanssen> > let afac 0 acc = acc; afac n acc = afac (n-1) (n*acc) in afac 10 1
11:57:12 <lambdabot> 3628800
11:57:18 <bolrod> let fib = 1:1:[a+b|(a,b)<-zip fib (tail fib)] in take 100 fib
11:57:26 <bolrod> > let fib = 1:1:[a+b|(a,b)<-zip fib (tail fib)] in take 100 fib
11:57:27 <lambdabot> [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,
11:57:27 <lambdabot> 17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
11:57:27 <lambdabot> 2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,
11:57:27 <lambdabot> 102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,
11:57:27 <lambdabot> 2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,
11:57:29 <lambdabot> [12 @more lines]
11:57:55 <twobitsprite> sjanssen: now, how would you "hide" the accumulator such that the API to the function doesn't require the user to state the obvious
11:58:24 <sjanssen> @wiki WorkerWrapper
11:58:25 <lambdabot> http://www.haskell.org/haskellwiki/WorkerWrapper
11:58:37 <sjanssen> oh wait, how do I get the old wiki?
11:58:47 <sjanssen> @oldwiki WorkerWrapper
11:58:47 <twobitsprite> yeah, that's empty
11:58:49 <lambdabot> http://www.haskell.org/hawiki/WorkerWrapper
11:58:51 <sjanssen> there
11:59:25 <sjanssen> twobitsprite: I usually use a "where" definition like one of the examples
12:00:42 <twobitsprite> ahh... that's what I wanted to know
12:01:00 <twobitsprite> in ocaml you just use an internal let...in definition
12:01:10 <twobitsprite> thanks
12:03:28 <twobitsprite> are the arguments to the wrapper in scope during the where?
12:04:03 <sjanssen> twobitsprite: yep
12:04:08 <twobitsprite> > let f x = g 2 where g y = x + y
12:04:09 <lambdabot>  parse error on input `}'
12:04:16 <twobitsprite> > let f x = g 2 where g y = x + y in f 4
12:04:18 <lambdabot> 6
12:04:21 <vincenz> > let g y = x + y in let f x = g 2
12:04:22 <lambdabot>  parse error on input `}'
12:04:31 <vincenz> > let g y = x + y in let f x = g 2 in f 4
12:04:31 <lambdabot>  Not in scope: `x'
12:04:38 <vincenz> whoops
12:04:59 <vincenz> let f x = let g y = x + y in g 2 in f 4
12:05:03 <vincenz> > let f x = let g y = x + y in g 2 in f 4
12:05:04 <lambdabot> 6
12:05:08 <vincenz> just like ocaml
12:05:15 <twobitsprite> > 4 mod 2
12:05:16 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
12:05:16 <lambdabot>   In the definition of `pfi': pfi = 4 mod 2
12:05:16 <lambdabot>   In the definition of `v': v = let pfi = 4 mod 2 in take 2048 (show pfi)
12:05:19 <twobitsprite> > 4 % 2
12:05:20 <lambdabot> 2%1
12:05:25 <sjanssen> > 4 `mod` 2
12:05:26 <vincenz> > 4 `mod` 2
12:05:26 <lambdabot> 0
12:05:28 <lambdabot> 0
12:05:31 <twobitsprite> ahh
12:05:32 <vincenz> > mod 4 2
12:05:33 <lambdabot> 0
12:05:34 <sjanssen> (%) makes fractions
12:05:39 <twobitsprite> I see
12:05:45 <twobitsprite> :t (%)
12:05:54 <twobitsprite> er... I guess this isn't my repl
12:05:58 <twobitsprite> @type (%)
12:05:59 <lambdabot> Not in scope: `%'
12:06:09 <sjanssen> @type Data.Rational.(%)
12:06:11 <lambdabot> Couldn't find qualified module.
12:06:11 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:06:11 <lambdabot> \\)?
12:06:11 <bolrod> yo..  the 'more efficient'  reverse in that wiki isn't really more efficient :/
12:06:12 <twobitsprite> @type 4%5
12:06:13 <lambdabot> Not in scope: `%'
12:06:25 <sjanssen> @type (Data.Rational.%)
12:06:26 <lambdabot> Couldn't find qualified module.
12:06:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
12:06:26 <lambdabot> \\)?
12:06:41 <sjanssen> I HATE qualified operators
12:07:22 <musasabi> back
12:08:20 <twobitsprite> integer division is just "div" rihgt?
12:08:33 <twobitsprite> > div 3 4
12:08:34 <lambdabot> 0
12:08:44 <bolrod> guess so
12:08:44 <twobitsprite> > div 5 4
12:08:45 <lambdabot> 1
12:10:20 <twobitsprite> http://pastebin.com/602244
12:10:26 <twobitsprite> does that look like good haskell style?
12:10:35 <twobitsprite> or am I missing some funner way to do it?
12:10:55 <xerox> fold.
12:11:23 <sjanssen> actually, unfold
12:11:36 <sjanssen> twobitsprite: it looks good
12:11:38 <twobitsprite> oohh.... unfold sounds fun
12:11:48 <twobitsprite> @type unfold
12:11:49 <lambdabot> Not in scope: `unfold'
12:11:51 <twobitsprite> asd;lfkjaslk
12:11:59 <sjanssen> @hoogle unfold
12:12:00 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
12:12:00 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
12:12:00 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
12:12:02 <xerox> I'd say fold anyway.
12:12:16 <twobitsprite> xerox: doesn't fold only work on lists?
12:12:51 <xerox> Oh uhm, maybe I misinterpreted the meaning of your function,.
12:13:27 <xerox> Right, it's an unfold.
12:13:28 <twobitsprite> xerox: accepts two ints, the first is a radix (base) the second is expanded into it's numeral representation with each digit in the given redix
12:13:44 <twobitsprite> i.e. "from_int 3 14" => "[1,1,2]"
12:14:13 <xerox> @pl concatMap return
12:14:14 <lambdabot> id
12:14:17 <xerox> Urgh.
12:14:36 * twobitsprite is trying to understand how unfold would be used...
12:15:49 <twobitsprite> ack... time to head home... I might get on when I get there
12:15:49 <Igloo> > List.unfoldr (\xs -> if null xs then Nothing else Just (splitAt 3 xs)) [1..8]
12:15:50 <lambdabot> [[1,2,3],[4,5,6],[7,8]]
12:16:14 <sjanssen> @pl \(x, y) -> (y, x)
12:16:19 <lambdabot> uncurry (flip (,))
12:16:19 <bolrod> you want the [1,1,2]  to become 112 ?
12:16:34 <twobitsprite> bolrod: no... I want to keep it a list
12:16:45 <bolrod> ;o
12:16:47 <xerox> > let f n r = unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` r,n `div` r)) n in f 14 3
12:16:48 <lambdabot> [2,1,1]
12:16:53 <twobitsprite> bolrod: I'm making a list of the digits of a number in a given base
12:17:38 <twobitsprite> heh.. now it's little-endian
12:17:40 <xerox> stick a reverse at the end.
12:17:51 <twobitsprite> xerox: bleh
12:18:01 <xerox> Okay.
12:18:01 * twobitsprite hates reversing lists
12:18:13 <bolrod> its not efficient anyway
12:18:17 <twobitsprite> but I get your point... thanks :)
12:18:21 * twobitsprite has to go
12:19:09 * shapr boings cheerfully
12:20:44 <xerox> Hmm.
12:23:15 * shapr throws a lambda at xerox 
12:24:05 <defcon8> :O
12:24:20 <defcon8> |\
12:24:30 <defcon8> thats the nearest thing to lambda i could do on irc
12:25:01 <sjanssen> y
12:25:08 <sjanssen> now everybody, turn your monitors upside down
12:25:20 <defcon8> oh yeah
12:25:28 <sjanssen> oh, and look at them through a mirror
12:25:52 * shapr grins
12:26:36 * ValarQ hit shaprs left foot
12:26:41 <ValarQ> s/hit/hits/
12:26:44 <shapr> ow!
12:26:47 <bolrod> sjanssen: I dont have a mirror
12:26:57 <defcon8> who here is l33t (left handed)
12:27:03 <sjanssen> bolrod: you'll just have to use your imagination then
12:27:09 <bolrod> thats hard!
12:27:19 <shapr> defcon8: I'm left handed, but it's generally a pain.
12:27:24 <defcon8> why shapr?
12:27:27 <defcon8> i think it is cool
12:27:31 <bolrod> to find a left handed mouse?
12:27:31 <bolrod> ;p
12:27:39 <shapr> Measuring cups are marked on the right hand side, scissors are designed for right handers, most of life is right handed.
12:27:39 <defcon8> no such thing
12:27:53 <defcon8> you just left click with your middle fingert
12:27:55 <defcon8> it is easy
12:27:58 <shapr> Left hand trackballs were built my logitech in the early 90s, but they're very hard to find these days.
12:28:03 <bolrod> I have scissors that are for left handed people... only.. I'm right handed
12:28:04 <defcon8> but i use my mouse with both hands
12:28:04 <shapr> s/my/by
12:28:12 <defcon8> shapr who uses trackballs?
12:28:15 <shapr> I have left handed scissors also.
12:28:22 <shapr> defcon8: People who like to prevent RSI.
12:28:27 <bolrod> logitech MX700 fits left hand nicely
12:28:29 <defcon8> i can cut with my right hand aswell
12:28:52 <shapr> Suspending your arm to move a pointer on your screen wears your joints to no real purpose. That's my opinion anyway.
12:28:53 <bolrod> you could ofcourse get a symetrical mouse...
12:29:09 <defcon8> you dont suspend it
12:29:15 <shapr> I use a unisex logitech trackball these days.
12:29:16 <defcon8> you rest it on the table :|
12:29:24 <ValarQ> shapr: i'm right handed and all my scissors are for left-handed for some stupid reason!
12:29:32 <shapr> defcon8: ok, but you suspend your forearm and move your wrist, yeah?
12:29:39 <shapr> ValarQ: mail them to me!
12:29:40 <defcon8> no
12:29:42 <xerox> > let f n r = map snd $ take size $ iterate (\(n,_) -> divMod n r) (divMod n r) where size = (+1) $ round $ log (fromIntegral n) / log (fromIntegral r) in f 14 3
12:29:43 <lambdabot> [2,1,1]
12:29:47 <sjanssen> wow. how does a person accidentally end up with left hand scissors
12:29:49 <defcon8> oh yeah shapr i do
12:29:55 <bolrod> xerox: erh
12:29:57 <shapr> defcon8: You can move your mouse without lifting the base of your hand even?
12:30:02 <defcon8> well i dont move my wrist
12:30:02 <ValarQ> shapr: i'm thinking about doing it...
12:30:15 <defcon8> i actually pivot my arm on the edge of the table
12:30:15 <bolrod> sjanssen: accidentally walk into flanders store?
12:30:36 <xerox> grmbl.
12:30:44 <bolrod> I actually have a trackpad
12:31:12 <defcon8> what are they?
12:31:15 <shapr> defcon8: Oh, I think I understand. Thing is, arms are mostly designed to grasp, like a hug. Holding your arm up in the air isn't really good for long term arm usage. or something... I hope that was understandable :-)
12:31:26 <bolrod> they are those litle things.. on laptops.. to move your mouse?
12:31:32 <defcon8> right i get it shapr
12:31:38 <defcon8> oh ok bolrod
12:31:44 <defcon8> i never knew what they were called
12:31:51 <bolrod> hehe
12:31:55 <defcon8> what and trackpads are great for your fingers?
12:32:00 <shapr> For the same sort of reason I remapped my keyboard to put all of my shift-type keys under my thumbs.
12:32:14 <bolrod> well..  they're great for laptops. 
12:32:23 <bolrod> but mouse is better at a desk
12:32:33 <shapr> Holding down the shift key with my pinky hurts after a few years.
12:32:48 <defcon8> why shapr?
12:32:51 <bolrod> :/
12:32:57 <bolrod> weird... no problem with that
12:32:57 <defcon8> play the classical guitar or something
12:33:01 <shapr> Because chording is designed for thumbs.
12:33:02 <bolrod> bah
12:33:06 <bolrod> piano! :P
12:33:13 <defcon8> classical guitar is better
12:33:17 <bolrod> no its not
12:33:17 <bolrod> :p
12:33:21 <defcon8> yes it is
12:33:25 <bolrod> piano is way more coool
12:33:37 <defcon8> im 15 atm. i really hope my fingers dont fuck up when im like 30 or something
12:34:01 <defcon8> well i have a stratocaster aswell but i rather classical
12:34:09 <bolrod> hehe try playing some piano chords.. every guitar player I seen grab some chords.. grabbed them really weird
12:34:18 <shapr> I'm 34...
12:34:19 <bolrod> like with fingers 1-2-3-4 on th left hand
12:34:26 <shapr> I learned all this the hard way.
12:34:27 <bolrod> instead of using the thumb
12:34:33 <defcon8> shapr when did you start seriously using the ocmputer?
12:34:34 <shapr> My left arm was unusable for nine months.
12:34:38 <defcon8> fuck
12:34:42 * defcon8 dies
12:34:52 <shapr> defcon8: But it doesn't have to happen to you... 
12:34:56 <defcon8> yeah
12:35:02 <defcon8> and i have very big hands
12:35:06 <shapr> use a trackball, don't chord with anything but your thumbs, don't keep static joint positions, etc
12:35:08 <shapr> Me too
12:35:08 <defcon8> so i guess i dont have to stretch my fingers too much
12:35:13 <shapr> Yeah, it helps.
12:35:21 <bolrod> just dont feel tense when you're behind a computer
12:35:22 <shapr> I'd also suggest you try dvorak, it helps.
12:35:22 <xerox> AH.
12:35:27 <bolrod> relax etc. :)
12:35:33 <xerox> > let (.>.) = flip id; xs = [(3:),(2:),(1:)] in foldl (.>.) ([]) xs
12:35:34 <lambdabot> [1,2,3]
12:35:38 <bolrod> ahyes.. dvorak..
12:35:41 <defcon8> yeah id convert my keyboard if its enter key were of the small type
12:35:43 <bolrod> still have to learn that
12:35:47 <xerox> Then...
12:36:02 <bolrod> my logitech doens't support dvorak layout >:/
12:36:19 <defcon8> this is a shytey microsoft multimedia
12:36:22 <bolrod> for some very weird reasons the F and J have a slightly different connector to the keyboard
12:36:38 <shapr> defcon8: I wrote a bit about my keyboard layout here - http://www.scannedinavian.com/~shae/blog/2005-11-03.html
12:36:52 <bolrod> I know dvorak can make you type faster
12:36:55 <xerox> > let f n r = foldl (flip id) [] $ List.unfoldr (\n -> if n == 0 then Nothing else Just (((n `mod` r):),n `div` r)) n in f 14 3
12:36:56 <shapr> My kinesis doesn't support dvorak layout, but my kernel does!
12:36:57 <lambdabot> [1,1,2]
12:36:59 <defcon8> and none of my other keyboards support dvorak
12:37:00 <xerox> AH.
12:37:47 <bolrod> :)
12:37:56 <xerox> Okay?  Gurgle.
12:38:02 <sjanssen> shapr: when did you begin having serious trouble with RSI?
12:38:02 <bolrod> you could just put some stickers over the keys though
12:38:17 <shapr> sjanssen: About three years ago
12:38:17 <defcon8> yeah bolrod but there is one extra key
12:38:22 <defcon8> my enter key is big
12:38:26 <defcon8> the enter key needs to be small for dvorak
12:38:33 <bolrod> http://daskeyboard.com/  << no need for any layout
12:38:33 <bolrod> :p
12:38:40 <shapr> sjanssen: I kept on going though, and it got worse.
12:38:46 <bolrod> defcon8: you sure?
12:39:05 <bolrod> dvorak and qwerty have the same amounts of keys I think.....
12:39:09 <shapr> Part of my problem was playing tribes, counterstrike, etc where my joints and muscles stayed in the same position for hours and had lots of tension.
12:39:10 <bolrod> just positioned really different
12:39:47 <shapr> defcon8: You can change your keyboard layout to dvorak in your OS settings. Windows, Linux, MacOS X, etc can all switch in the settings.
12:39:54 <defcon8> yes i know
12:40:03 <defcon8> im talking about my keyboard having a big enter key
12:40:09 <bolrod> that doesn't matter
12:40:17 <bolrod> they have the same amount of keys
12:40:35 <defcon8> ok
12:40:42 <bolrod> http://www.mwbrooks.com/dvorak/layout.html
12:40:46 <defcon8> let me dig out my english keyboard
12:40:52 <bolrod> you mean the  |\ wont fit above your enter?
12:40:56 <defcon8> atm im using us layout on turkish :|
12:41:02 <bolrod> you can just place it one down.. 
12:41:19 <bolrod> iBook has a weird layout
12:41:26 <bolrod> to the left of the Z 
12:41:30 <bolrod> I have ~ `  key
12:41:38 <bolrod> and where that key normally is.. there is  
12:41:48 <defcon8> yeah the |\ key isnt there
12:41:56 <bolrod> indeed.. its one down
12:41:56 <defcon8> bolrod what happens if i put it down?
12:41:59 <bolrod> nothing
12:42:02 <bolrod> its just the same key
12:42:05 <bolrod> on a different position
12:42:18 <bolrod> I have the same
12:42:24 <defcon8> with a big enter key?
12:42:28 <defcon8> can you take a picture of it please?
12:42:36 <bolrod> with the big enter key they just replaced the |\ key.. 
12:42:42 <bolrod> its not like its a totally different key...
12:43:03 <defcon8> what?
12:43:04 <bolrod> I dont have dvorak layout. but you can easilly put it that way.. if your keys support it
12:43:05 <defcon8> i dont get it
12:43:21 <shapr> defcon8: I also suggest an ergonomic keybooard. I use kinesis - http://www.scannedinavian.com/~shae/blog/images/elan-black.jpg
12:43:22 <bolrod> well.. with some keyboards. the |\ key is next to the ][ right?
12:43:51 <bolrod> with a big enter key.. they just filled up that space with enter.. and put the |\ key besides the "' key
12:43:56 <bolrod> right?
12:44:02 <defcon8> it is under
12:44:10 <bolrod> or under the enter key... 
12:44:13 <bolrod> its still the same key
12:44:34 <defcon8> right
12:44:38 <bolrod> it is the same size as the other keys right?
12:44:45 <defcon8> yes
12:44:50 <bolrod> well.. no problem then
12:44:53 <defcon8> but the enter key is an upside down l
12:45:07 <bolrod> the enter key doesn't matter
12:45:09 <bolrod> :)
12:45:15 <bolrod> do you see an enter key on that dvorak layout?
12:45:24 <defcon8> the |\ key is right of '
12:45:28 <bolrod> indeed
12:45:29 <defcon8> no :|
12:45:35 <bolrod> well.. since you have no place there
12:45:41 <defcon8> okay then ill start dismantling this old compaq
12:45:44 <bolrod> put it in the place that is left when you put in all the other keys ;)
12:45:53 <bolrod> it will still work
12:45:55 <shapr> sjanssen: Anyway, my left shoulder, elbow, wrist, and knuckles started hurting all the time. They stopped hurting when I took a week off keyboard use entirely. I started again and it was far worse. About a month later I decided I had to stop using my left arm completely, mostly because I just couldn't.
12:47:08 <shapr> sjanssen: So I learned to touch type right-hand dvorak, and held my left arm close to my chest for about nine months. Since I couldn't use my arm, it was a good time to learn unicycling :-)
12:48:20 <bolrod> hehe
12:48:40 <shapr> Nowadays I change my posture a lot while typing. I have a foldout futon couch thingy that I can splay myself over while I type.
12:49:16 <sjanssen> splaying is always good
12:49:54 <gzl> you splay while typing?
12:49:58 <shapr> RSI mostly comes from the tendon sheaths getting worn in one particular spot, because joints are used lots at the same angle.
12:50:06 <shapr> gzl: Yeah, but only behind closed doors.
12:50:11 <shapr> You know I'd never splay in public.
12:50:17 <gzl> just checking.
12:50:30 <sjanssen> gzl: my trees usually do the splaying
12:51:08 <gzl> I enjoy splaying. but I haven't found a way to combine it with typing.
12:52:22 <defcon8> GHEYNESS
12:52:38 <shapr> defcon8: eh?
12:52:40 <defcon8> different keys from different rows wont fit
12:52:52 <shapr> defcon8: So remap your keyboard and learn to touchtype =)
12:53:08 <defcon8> only seems to be the j key only
12:53:10 <defcon8> ill write over it
12:53:38 <xerox> <http://en.wikipedia.org/wiki/Illegal_prime>
12:54:04 <bolrod> hehe
12:54:14 <bolrod> yeah.. my other keyboard had that as well
12:54:14 <xerox> Urgh :-)
12:54:19 <shapr> gzl: If you code from a futon it'll work :-) I turned the drawer parts of my desk on their side, and put the table part back on. Now it's just the right height for a futon.
12:54:24 <bolrod> the keys on the lowest row were a bit smaller
12:54:27 <bolrod>  / thinner
12:55:30 <gzl> huh
12:55:31 <gzl> interesting.
12:55:42 <gzl> I guess if the table was low enough, typing from a futon could work.
12:56:39 <sjanssen> gzl: I think the trick is a semi reclined state, perhaps with pillows in the mix
12:57:15 <bolrod> bwah.. in 25 years we possible dont even have keyboards and mouses
12:57:30 <bolrod> we just put some weird helmet on.. and think about what you want to type
12:57:33 <gzl> wait, are you lying on your stomach or your back?
12:57:56 <bolrod> which might not be the best thing on irc
12:58:48 <sieni> bolrod: I've been using computers for more than 25 years and still I'm using the keyboard
13:00:28 <sieni> It's just quite efficient to use a keyboard
13:06:43 <defcon8> fkn lost a key
13:08:19 <defcon8> ill just steal the f12 key thgen
13:10:02 <bolrod> sieni: but you're not using the mouse 25 years
13:10:13 <bolrod> mouse is also quite efficient given the right context
13:10:39 <sieni> For what?
13:11:36 <defcon8> fuck one of the keys isnt coming back up
13:11:45 <neologism> sieni: navigating the web
13:11:45 <sieni> Well, I actually have a touchpad and trackball, which are better, but I like e.g. the concept of Ion, which tuomov is probably more than happy to do marketing for
13:13:15 <sieni> I usually have full screen web browsers and then different workspaces split in half in the middle vertically containing an emacs window or one or possibly two terminal windows
13:14:05 <sieni> Ion works nicely (and also sawfish)
13:16:10 <dons> moin
13:16:29 <kosmikus> hi dons
13:16:38 <dons> hey kosmikus :)
13:20:25 <defcon8> yes i am so damn l33t
13:20:38 <defcon8> nothing a bit of filing cant do
13:21:00 <defcon8> even though i totally fucked the key up
13:21:17 <zellyn> Hi folks.  Quick question.
13:21:30 <zellyn> @type liftM2
13:21:31 <lambdabot> Not in scope: `liftM2'
13:21:43 <zellyn> @type ($)
13:21:44 <lambdabot> forall b a. (a -> b) -> a -> b
13:22:13 <zellyn> damn.  Just figured it out.
13:22:17 <zellyn> thanks!
13:22:24 <sieni> BTW:
13:22:24 <dons> \type Monad.liftM2 -- wasn't this a question yesterday?
13:22:26 <lambdabot> forall r (m :: * -> *) a2 a1.
13:22:26 <lambdabot>       (Monad m) =>
13:22:26 <lambdabot>       (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:22:27 <sieni> > (++) "WTF" $ snd $ splitAt 13 "What The Fuck is 'moin'?"
13:22:29 <lambdabot> "WTF is 'moin'?"
13:22:58 <dons> \msg lambdabot \dict moin
13:23:21 <zellyn> @type Monad.liftM2
13:23:22 <lambdabot> forall r (m :: * -> *) a2 a1.
13:23:22 <lambdabot>       (Monad m) =>
13:23:22 <lambdabot>       (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:23:36 <zellyn> What's the difference between @ and \ ?
13:23:39 <dons> nothing
13:23:41 <dons> synonyms
13:23:44 <zellyn> cool
13:23:46 <zellyn> thanks!
13:25:10 <sieni> dons: is "moin" of the same origin as "moi", which is a very common greeting in Finland?
13:26:08 <dons> sieni, it's from "moin moin", which is fromm a region of germany, iirc, but is also a common irc greeting :)
13:26:56 <xerox> @wikipedia moin
13:26:59 <lambdabot> No Result Found.
13:27:04 <xerox> @wikipedia moin moin
13:27:06 <lambdabot> No Result Found.
13:27:44 <sieni> We use "moi" and "hei" practically interchangeably and I know that "hej" is a common greeting in sweden (an also similar greetings exist in English), but I didn't know that one of our most common greetings come from Northern Germany
13:28:54 <dons> yeah, that's interesting that it would spread as far as finland
13:29:00 <musasabi> hei is from germanic roots I think.
13:29:07 <musasabi> from moi I don't know
13:29:48 <sieni> dons: do you think that northern germany is far from finland? :-)
13:30:13 <shapr> Nah...
13:30:28 <dons> ah, well it seems far for me :) but I guess it isn't really, is it.
13:31:08 <dons> all of europe fits inside .au, so it can't be too far :)
13:31:13 <sieni> I think the baltic sea has been a pretty active trade route and it's not that far by land either
13:31:32 <shapr> I'd like to live way inland in .au.
13:31:38 <musasabi> most contact was via trading by sea or indirectly via Sweden.
13:31:57 <dons> shapr has long had dreams of his desert oasis :)
13:32:14 <sieni> In Finnish we call Germany "Saksa", so we probably have had some connections, since we haven't just modified the term "Germany" to fit our language
13:33:44 <kosmikus> saksamaa on ilus maa
13:34:37 <musasabi> sieni: you might want to find "etymologinen sanakirja" it is quite nifty for finding things about words.
13:34:59 <shapr> mailmaa
13:35:03 <sieni> Wasn't there a pretty recent one?
13:35:10 <shapr> Finnish is sooo cool.
13:35:16 <sieni> Maybe I'll buy one
13:36:09 <shapr> dons: I could be the Internet Hermit.
13:36:10 <sieni> shapr: yes, in finnish, the "earth" or "world" is "maailma", which is just "earth air" or "ground air"
13:36:12 * shapr snickers
13:36:30 <adu> hi
13:36:36 <shapr> greetings adu 
13:37:24 <shapr> sieni: Min en puhu suomea. Min haluan hampurilainen. Min olen amerikalainen! I learned so much during my three years living in Tornio...
13:37:36 <jlenor1_> >;o
13:37:37 <jlenor1_> hello
13:37:40 <musasabi> hello
13:37:44 <shapr> salut jlenor1_ 
13:37:47 <palomer_> HELLO
13:37:50 <adu> hello shapr
13:37:54 <sieni> shapr <3
13:37:55 <palomer_> anyone else having problems with gmail?
13:38:11 <musasabi> shapr: that is very good :-)
13:38:14 <adu> i'm having problems with FreeServers
13:38:27 <musasabi> shapr: but I think it should be hampurilaisen.
13:38:32 <shapr> whoops
13:38:53 <palomer_> woe is I, gmail is down
13:39:53 <araujo> Hello
13:39:56 <araujo> @yay!
13:39:58 <lambdabot> Unknown command, try @listcommands.
13:40:57 <dons> gmail is down, really? isn't that one of the signs of the apocalypse?
13:41:09 <adu> why is it that !! takes a 1-D index and ! takes a 2-D index, isn't that backwards?
13:41:44 <palomer_> dons, it may be that it's currently blocked at my school
13:41:45 <Igloo> ! takes the index appropriate for the array you are indexing
13:41:46 <araujo> oh, now i see why it isn't connecting to gmail :-)
13:41:52 <integral> @type Data.IArray.(!)
13:41:53 <lambdabot> Couldn't find qualified module.
13:41:53 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
13:41:53 <lambdabot> \\)?
13:42:03 <adu> oh
13:42:03 <integral> o_O
13:42:16 <dons> lambdabot is so smart
13:42:21 <adu> i guess i haven't used enough arrays then
13:42:31 <adu> i was just using arrays for matrix stuff
13:42:40 <shapr> palomer_: looks broke alright
13:42:50 <integral> @type ( (!!), (Data.IArray.!) )
13:42:51 <lambdabot> Couldn't find qualified module.
13:42:51 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
13:42:51 <lambdabot> \\)?
13:43:04 <integral> oh, it's a misleading error message.
13:43:13 <integral> @type ( (!!), Data.Array.IArray.(!) )
13:43:14 <lambdabot> Not in scope: data constructor `Data.Array.IArray'
13:43:14 <lambdabot>  
13:43:14 <lambdabot> <interactive>:1:26: Not in scope: `!'
13:43:19 <dons> yes, it just guesses based on a certain ghc error message
13:43:25 <dons> usually it is right :)
13:43:40 <palomer_> how can this be?
13:44:35 <integral> @type ( (!!), (Data.Array.!) )
13:44:36 <lambdabot> forall a i e.
13:44:36 <lambdabot>           (GHC.Arr.Ix i) =>
13:44:36 <lambdabot>           ([a] -> Int -> a, GHC.Arr.Array i e -> i -> e)
13:46:16 <defcon8> hello
13:46:35 <shapr> hi
13:46:47 <defcon8> i am now on dvorak
13:47:25 <defcon8> and it took me that long to type it
13:47:54 <dons> cool :)
13:48:07 <adu> dvorak is awsome
13:48:20 <adu> but not everywhere
13:48:56 <defcon8> i broke 2 keys so i put screws in their place
13:49:39 <defcon8> this is so damn hard
13:50:46 <adu> when i was learning dvorak, I really enjoyed typing at home more, but when I tried typing at the computers at school I had almost forgotten qwerty
13:51:08 <dons> adu, how long did that process take?
13:52:21 <tic> Took me about a year to write 1.5x faster than on qwerty.
13:52:31 <tic> or maybe less. depends on how much coding you do.
13:52:51 <tic> I've been on dvorak (well, svorak actually) since '99. best decision evar. :) Really good for your wrists.
13:53:23 <tic> annoying in the beginning, but it's good for learning how to type properly. (that was my goal, at least.)
13:56:54 <defcon8> well good night people
14:06:20 <adu> what is the difference between ":%" and "%"
14:06:43 <Igloo> :% is a constructor, % is a function
14:06:52 <adu> oh
14:07:12 <twobitsprite> @type (:%)
14:07:13 <lambdabot> Not in scope: data constructor `:%'
14:07:14 <adu> well don't functions construct stuff?
14:07:48 <adu> hm
14:07:54 <adu> @kind (:%)
14:07:55 <lambdabot> Not in scope: type constructor or class `:%'
14:08:13 <adu> @kind Ratio.:%
14:08:14 <twobitsprite> what are the rules for breaking a line in the middle of an expression?
14:08:15 <lambdabot> parse error on input `Ratio.:%'
14:08:25 <adu> @kind Ratio.(:%)
14:08:26 <twobitsprite> @kind Ratio.(:%)
14:08:27 <lambdabot> parse error on input `.'
14:08:27 <lambdabot> parse error on input `.'
14:08:36 <adu> @kind (Ratio.:%)
14:08:37 <lambdabot> Not in scope: type constructor or class `Ratio.:%'
14:10:01 <dons> twobitsprite, the correct rules? well, you can always break as long as you indent further to the right 
14:10:02 <twobitsprite> anyways... I can't find line-breaking rules anywhere...
14:10:18 <dons> check the section on 'layout' in the start of the h98 report
14:10:26 <twobitsprite> don: i.e. after the -> in a lambda?
14:10:32 <dons> of course
14:10:35 <twobitsprite> cool
14:10:36 <dons> _anywhere_
14:10:48 <twobitsprite> (expect for in the middle of a token, I imagine :P)
14:10:54 <twobitsprite> except*
14:11:04 <dons> well, it's not a token if it has a \n in the middle, is it?
14:11:10 <twobitsprite> heh, true
14:11:22 <twobitsprite> well... it becomes two tokens, right?
14:11:26 <dons> yeup
14:11:52 <dons> being familiar with the rules of layout in haskell will make you a better hacker :)
14:13:12 <dons> \where h98
14:13:12 <lambdabot> I know nothing about h98.
14:13:18 <dons> \where haskell98
14:13:19 <lambdabot> http://haskell.org/onlinereport/
14:13:41 <MarcWeber> My compiled ghc can't find module IO... adding -v shows that ghc finds /usr/lib/ghc-6.5-.../imports/IO.hi.. What is missing then?
14:14:15 <dons> the rules are here: http://haskell.org/onlinereport/lexemes.html#sect2.7
14:14:28 <dons> MacrWeber, hmm.. have you installed it?
14:14:34 <dons> or are you running ghc-inplace?
14:14:37 <MarcWeber> I have done make install in the fptools/ghc and fptools/libraries/{base,unix} directories
14:14:46 <dons> hmm
14:14:52 <dons> you're supposed to do 'make install' at the top level
14:15:01 <dons> otherwise it won't register packages, I suspect
14:15:06 <MarcWeber> the sound library doesn't compile..
14:15:33 <twobitsprite> are there any standard conventions for indentation?
14:15:48 <dons> you can remove libs from the installation by editing libraries/Makefile
14:15:56 <dons> twobitsprite, yes :)
14:16:01 <dons> @wiki 
14:16:01 <lambdabot> http://www.haskell.org/haskellwiki/
14:16:05 <dons> now let me find the page
14:17:13 <dons> some of them are documented in the Idioms section of the new wiki, and there's a style page on the old wiki
14:17:31 <dons> another good way to get style is to download the src for the standard libraries, and have a read
14:18:00 <dons> \fptools
14:18:01 <lambdabot>  not available
14:18:11 <dons> \where fptools
14:18:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
14:18:19 <dons> \darcs
14:18:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:18:22 <dons> hmm
14:18:28 <dons> \libsrc
14:18:28 <lambdabot>  not available
14:18:49 <dons> \fptools Data.List
14:18:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
14:18:51 <dons> forr example
14:19:19 <dons> \where+ style http://haskell.org/haskellwiki/Programming_guidelines
14:19:20 <lambdabot> Done.
14:19:22 <dons> ^^6 there
14:19:32 <MarcWeber> dons:  Do you also know how to tell make to use ghc-inplace again?
14:20:01 <dons> in mk/config.mk HC=/foo/ghc/compiler/ghc-inplace, iirc
14:20:21 <dons> MarcWeber, it's easier to install a linux binary snapshot :)
14:20:29 <dons> but then again, bulding ghc is good for you karma
14:21:38 <xerox> dons!
14:22:07 <dons> xerox!!
14:22:19 <xerox> dons: do you know if there are any issues about GHC on Intel Core Duo (the new mac dual core processor, that is.)
14:22:33 <dons> umm.. that it's never been done before?
14:22:39 <dons> so have a go!
14:22:46 <xerox> As soon as it'll arrive :-)
14:22:55 <dons> but it just looks like an x86, does it? or something weirder?
14:22:59 <palomer_> ok, guys, if you say "you gave yourselves cookies", do you interpret that as "you gave each other cookies" ?
14:23:09 <xerox> I think it is fair to say that it looks like an x86...
14:23:22 <xerox> But I don't know the exact details now.
14:23:24 <dons> should be no issues then, except the usual mac urgh-isms
14:23:44 <dons> i guess it's not going to use elf binaries, right?
14:24:02 <xerox> Beats me.  Is there a place where I can read about those urgh-isms?
14:24:13 <adu> wow
14:24:28 <gzl> dons: correct.
14:24:29 <adu> there are at least 14 numeric things
14:24:39 <gzl> it still uses Mach-O. all the OS stuff is exactly the same.
14:25:22 <adu> Num, Complex, Double, Int, Integer, Integral, Float, Floating, Fractional, Ratio, Rational, Real, RealFrac, RealFloat
14:25:27 <dons> I'd say then thats just like running ghc on linux/x86 or linux/ppc then. no issues once the arch is supported -- which x86 is.
14:25:28 <MarcWeber> dons: Can you tell me which binary version is able to compile wash?
14:25:32 <adu> not to mention Ord
14:25:51 <dons> MarcWeber, don't know. Did you ask the wash authors, perhaps?
14:25:56 <adu> its too confusing
14:26:27 <xerox> Ooh-kay.
14:26:33 <gzl> dons: so the main hurdles in running GHC on OS X had to do with PPC and not OS X itself?
14:26:46 <dons> no, the main issue was OS X
14:26:59 <dons> using mach-o, and having weird linkers 
14:27:25 <gzl> ok.
14:27:33 <dons> but since in the case of the core duo, both the cpu and the os are already supported, then ghc should "just work" (for some definition ..)
14:27:52 <gzl> right.
14:28:07 <dons> presumably you could run linux/x86 binaries under a os syscall translation (?)
14:28:16 <adu> i don't think mach-o is that much different than other BDF formats
14:28:19 <dons> like I can run linux binaries on my x86/openbsd box?
14:28:34 <xerox> Sounds interesting.
14:28:41 <MarcWeber> dons: then I also have to adjust ghc version in mk/configk.mk... because I know get interface mismatch (hi files)
14:28:47 <dons> well, it needs lots of magic support in the ghc linker for ghci to work, adu
14:29:19 <adu> oh
14:29:58 <dons> does a core duo look like an smp machine?
14:30:12 <MarcWeber> When invoking make in the fptools top dir.. make first creates ghc-inplace to use it to compile everything else.. When does make stop using ghc-inplace?
14:30:26 <dons> it never stops :)
14:30:37 <dons> make uses your installed ghc to build ghc-inplace
14:30:57 <dons> it then installs ghc-inplace, but with flags changed to point to the standard libs
14:31:23 <dons> ghc-inplace is a script that points to compiler/stageN/ghc 
14:31:36 <dons> it's this that you're building and going to install
14:32:27 <adu> whats SMP?
14:32:28 <dons> MarcWeber, building ghc on linux should be as simple as grabbing the src, typing './configure ; make ; make install' at the top level.
14:32:41 <jyp> symetrics mutiprocessing
14:32:48 <adu> dons: its not that simple on MacOSX?
14:33:07 <dons> oh, isn't that the mac os x slogan?
14:33:18 <adu> no
14:33:20 <dons> ;)
14:33:35 <adu> mac os x makes lots of things easy
14:33:41 <jyp> http://en.wikipedia.org/wiki/Symmetric_multiprocessing
14:33:52 <dons> for developers, the macc seems so much harder. for the users it looks easier though.
14:33:53 <adu> everything except making programs that make "it" easy
14:34:06 <dons> yep
14:34:46 <adu> i agree, mac is not the best development platform, but then again, I don't think there is a good development platform
14:35:28 <dons> well, i would never give up my clean, simple bsd OS, vim and ion. what more do you need?
14:35:44 <adu> the Optimal development platform would haveto involve Unix, XML, and MDA
14:36:01 <adu> but not neccessarily the things usually associated with them
14:36:06 <dons> xml? bah
14:36:24 <SyntaxNinja> I actually program in XML and have a script to convert it to Haskell.
14:36:32 <adu> SyntaxNinja : go you!
14:36:37 <dons> seriously?
14:36:51 <dons> is it april 1?
14:36:54 <adu> to me or SyntaxNinja ?
14:37:05 <MarcWeber> dons: Ok another try. i'm checking out fptools. cd fptools; ./configure; make .. Without using --with-src-tree-{alex,happy} ... Lets try
14:37:17 <SyntaxNinja> <let><variable>x</variable><value>3</value><in>x+1</let>
14:37:21 <SyntaxNinja> it's great.
14:37:24 <dons> I'm just not sure. Maybe galois has some weird policy that menas this could just be plausible...
14:37:29 <dons> hehe :)
14:37:33 <kosmikus> has anybody here tried lhs2tex-1.11_pre4?
14:37:34 <Igloo> SyntaxNinja: That's not well formed XML
14:37:37 <adu> SyntaxNinja : it should be <in/>
14:37:39 * dons sighs with relief
14:37:49 <SyntaxNinja> d'oh
14:37:51 <adu> :)
14:37:55 * Igloo demotes SyntaxNinja to SyntaxAmateur
14:38:02 * xerox laughs
14:38:02 <dons> hehe
14:38:14 <adu> i love XML and Unix, but the way they're usually used is not Optimal in my opinion
14:38:35 <stepcut> Unixml
14:38:38 <xerox> Hunt the troll!
14:38:50 <SyntaxNinja> XML is fine and convenient as long as no human has to read it.
14:39:19 <jyp> XML is not meant to be edited as text, I guess.
14:39:21 <adu> I want to do something to allow that Optimal usage, but what exactly that is I'll probably work on for another decade or so
14:39:48 <adu> jyp : ya editing XML as text should be a last-resort
14:40:00 <stepcut> OT: Has anyone generalized arrows to anything else yet? Cuz I think that's what I need ...
14:40:08 * Igloo was hand-writing XML for a music database, until I wanted to have song authors connected across different CDs, at which point the universe exploded
14:40:32 <adu> lol
14:40:39 <SyntaxNinja> stepcut: that's some intense generalization.
14:40:42 * MarcWeber is going to sleep while checking out/ trying to compile ghc...
14:41:04 <adu> i thought Arrays were the most general thing in the entire universe?
14:41:12 <adu> er Arrows
14:41:16 <Igloo> MarcWeber: It'll almost certainly take more than an hour, possibly several, depending on your machine
14:41:44 <dons> stepcut, yeah, shapr generlised them to spears several years aago
14:41:53 <stepcut> SyntaxNinja: Arrows are good for constructing graphs-like networks at compile time -- but I want to construct and modify the network at runtime in `arbitrary' ways... :-/
14:42:01 <jethr0_> i guess generalizing arrows to "anything else" would yield the Grand Unified Theory
14:42:20 <dons> stepcut, so why not use a graph then :)
14:42:22 <jethr0_> stepcut: you can do that with arrows (to an extent)
14:42:36 <stepcut> I needs Arrows with real introspection i think...
14:42:42 <jethr0_> stepcut: are you familiar with dSwitch, rSwitch from yampa/afrp?
14:43:08 <stepcut> jethr0_: yes -- those seems a bit limited still though
14:43:09 <MarcWeber>  Igloo Thanks.. i know.. It's my 5th attempt.. addint those trys on windows it will be some some more.. ;)
14:43:36 <jethr0_> stepcut: well, they aren't arbitrary per se... what would you like to do with arrows?
14:44:53 <adu> did Moggi start the Monad thing?
14:45:44 <stepcut> jethr0_: I want to make a 'circuit' of signal processors -- where each signal processor has an arbitrary number of ins and outs. Arrows are good for wiring the circuit up in code -- but I want to also be able to make an interactive version that lets you add, remove, and rewire circuits while it is running
14:45:47 <jethr0_> stepcut: i think having the network change in input events is already pretty generalized. how does that limit you?
14:46:03 <jethr0_> hmm
14:46:28 <jethr0_> does it make sense to have a fixed signal processor with arbitrary inputs and outputs?
14:47:28 <stepcut> there are a lot of different types of signal processors that do different things -- which is why they have different numbers of ins and outs
14:47:33 <jethr0_> i think what you're trying to do might be accomodates with switches (big maybe), but i'm critical about the semantics of introducing/removing components from a running circuit... that would have to be pretty well-defined
14:48:15 <jethr0_> stepcut: i think doing it yampa-style is doable, but i'm not sure it would be the easiest way. you should write some of your own combinators :)
14:48:58 <stepcut> jethr0_: I am working on it ... Been trying to solve this problem for 4 years now ;)
14:49:17 <jethr0_> hmm, that's quite a while. doesn't that predate some of the work on arrows ^_^
14:50:10 <jethr0_> stepcut: but what were your _specific_ problems with switches? as i said, i think it's doable with them, because in yampa you build a new circuit on every iteration while preserving the state of existing arrows
14:50:49 <lesshaste> hi.. what is the simplest way to do binary search in O(log(n)) time on an ordered list?
14:50:59 <twobitsprite> when you compose two functions, which one is applied first?
14:51:01 <lesshaste> presumably construct a binary search tree and search in there?
14:51:41 <sjanssen> lesshaste: yeah, use Data.Map
14:51:47 <jethr0_> lesshaste: lists are inherently O(n)... how about putting the list into a Map, although conversion would obviously be more expensive than log(n)
14:52:09 <lesshaste> sure.. but I would like to do it by hand as it were
14:52:31 <lesshaste> so I make something with type data Tree a = Leaf | Branch (Tree a) a (Tree a) ?
14:52:49 <sjanssen> lesshaste: yep
14:52:54 <jethr0_> twobitsprite: i think the answer to what you mean is "the right one first", but lazyness puts a different aspect on top
14:53:03 <jethr0_> (f . g) x = f (g x)
14:53:07 <stepcut> jethr0_: I have not completely ruled out yampa switches yet -- they seemed like they may have required you to have some idea of where you wanted the switch to happen and what you wanted to switch to
14:53:23 <sjanssen> lesshaste: but if you really want to guarantee O(log n), you must do balancing
14:53:32 <sjanssen> which is a whole other can of worms . . .
14:53:37 <norpan> if you're not modifying the list and do a lot of searches, convert it to an array
14:53:40 <lesshaste> sjanssen: there will be no insertions or deletions after the initial construction
14:53:53 <lesshaste> norpan: ok.. I don't know about arrays in Haskell :(
14:54:03 <lesshaste> only lists
14:54:03 <stepcut> jethr0_: but I am currently looking at the yampa code to remember how it actually works and see if I can modify it 
14:54:04 <jethr0_> stepcut: well, they aren't "switches" in the normal sense of the word. rather controlling a dynamic collection of signal transformers
14:54:16 <tic> lesshaste http://www.zvon.org/other/haskell/Outputarray/array_f.html
14:54:47 <lesshaste> tic: thx!
14:55:06 <lesshaste> now.. back to my binary search tree :)  If I just want to construct it once that be ok right?
14:55:15 <tic> (I hope that works, it was more or less a google lucky strike)
14:55:15 <stepcut> jethr0_: i think part of my problem is how to describe the action of hooking in the new components
14:55:32 <lesshaste> how would I construct the tree of type data Tree a = Leaf | Branch (Tree a) a (Tree a)  ?
14:55:38 <lesshaste> from an ordered list?
14:55:52 <jethr0_> stepcut: yup, you'd have to describe in between which "old" components a new one should be put
14:56:51 <jethr0_> and god forbid you'd introduce more than one at once in a complex way
14:56:51 <jethr0_> lesshaste: you could just split the list in half
14:56:52 <jethr0_> lesshaste: and recursively call your treebuilding function with the halves
14:57:08 <bolrod> yes
14:57:23 <lesshaste> jethr0_: ok.. but I do want the whole construction to take linear time
14:57:36 <jethr0_> lesshaste: sorting is super-linear
14:57:44 <lesshaste> jethr0_: it is already sorted
14:57:51 <sjanssen> lesshaste: it is possible, but the code is rather tricy
14:57:55 <sjanssen> *tricky
14:58:23 <bolrod> whats tricky about building a tree?
14:58:24 <lesshaste> sjanssen: oh ok.. so the approach that doesn't take advantage of the order of the data is easier?
14:58:34 <stepcut> jethr0_: yeah, and part of the problem is the new component is not really 'in-between' other things -- it gets inputs from a couple places and sends outputs to a couple other devices
14:58:39 <jethr0_> lesshaste: linear in what? halving and recursing shouldn't be much slower than linear in the number of elements (or am i being dull again?)
14:58:43 <stepcut> its more of a big web 
14:58:57 <lesshaste> jethr0_: I am not sure as I can't quite imagine the code
14:58:58 <jethr0_> lesshaste: halving _does_ take advantage of the order!
14:59:03 <sjanssen> lesshaste: maybe a little bit
14:59:24 <sjanssen> actually, I think jethr0_'s approach is linear too
14:59:33 <sjanssen> yes, it is
14:59:47 <bolrod> I have the code right here
14:59:58 <bolrod> maybe not super optimal.. but works..
15:00:20 <bolrod> now where is a pastebin for haskell :)
15:00:45 <jethr0_> f [x] = Leaf x; f xs = let (x1,x2) = halve xs in Branch (f x1) (f x2)
15:00:47 * stepcut goes to make a phone call
15:00:48 <jethr0_> oh, sry, you need elements in the branches for lookup. but you get the gist :)
15:01:08 <lesshaste> sorry to be dumb.. what would the program look like that did this construction?
15:01:08 <lesshaste> the jethr0_ way :)
15:01:26 <lesshaste> pasebin.com will do fine ;)
15:02:14 <bolrod> http://pastebin.com/602596
15:02:16 <bolrod> yes :)
15:02:18 <bolrod> like that?
15:02:52 <bolrod> Blad = Leaf
15:02:52 <lesshaste> thx.. just translating :)
15:03:04 <bolrod> Tak = Branch
15:03:05 <drakioned> createZoekboom?
15:03:07 <lesshaste> Boom?
15:03:11 <bolrod> createSearchTree
15:03:17 <lesshaste> Boom  = tree :)
15:03:18 <bolrod> its in dutch :/
15:03:22 <bolrod> yes
15:03:25 <drakioned> aw. and here I was thinking you were making a game.
15:03:33 <lesshaste> Tak?
15:03:38 <bolrod> Branch
15:03:52 <lesshaste> cool
15:03:55 <jethr0_> i guess so. although i don't see the benefit of empty leaves. and (center:right') won't work for list length 1
15:03:56 <lesshaste> thx bolrod 
15:04:04 <jethr0_> for initial list length 1
15:04:26 <bolrod> jethr0_: thats why I have a createZoekboom for an empty list
15:04:36 <bolrod> like I said.. its not optimal
15:04:44 <bolrod> and doesn't look really pretty..
15:04:47 <bolrod> but it should work
15:04:48 <jethr0_> no, i'm talking about createZoekboom [x]
15:04:50 <xerox> Goodnight chaps!
15:04:53 <jethr0_> night
15:04:57 * jyp waves
15:04:59 <bolrod> gnite
15:05:00 <lesshaste> I only want occurs :)
15:05:06 <lesshaste> so I think all is well
15:05:12 * lesshaste waves back
15:05:17 <bolrod> dividing by 2 also makes the tree somewhat lean to one side
15:05:27 <jethr0_> bolrod: might even work ;)
15:05:35 <bolrod> what might work?
15:05:44 <jethr0_> for [x]
15:05:56 <newsham> how closely does today's GHC line up with petyon's STG paper?
15:06:18 <jethr0_> let (left, (center:right)) = splitAt 0 [1] in (left,center,right)
15:06:22 <jethr0_> > let (left, (center:right)) = splitAt 0 [1] in (left,center,right)
15:06:23 <lambdabot> ([],1,[])
15:06:26 <newsham> (or is that jones' STG paper)
15:06:28 <Cale> newsham: almost exactly, afaict
15:06:30 <jethr0_> yup, it magically does
15:06:43 <newsham> cale: is C still the targetted "assembler" ?
15:06:58 <Cale> newsham: if you compile via C
15:07:17 <newsham> meaning?  there are also other more direct targets?
15:07:29 <Cale> yeah, GHC can compile to native code
15:07:32 <bolrod> what magically does work?... I dont see something special... 
15:07:34 <Cale> as well as via C
15:07:44 <bolrod> hmm
15:07:56 <newsham> does it emit objects directly or make use of assemblers?
15:08:15 <sethk> newsham, c compiler and then, of course, assembler
15:08:22 <jethr0_> bolrod: never mind. i was just unsure how the case of "[x]" would work. but the `div` takes care of it
15:08:31 <Cale> It uses assemblers I'm fairly sure.
15:10:39 <bolrod> in some lecture my teacher probably has some better algorythm..
15:10:41 <bolrod> lets see
15:10:49 <lesshaste> still shocked that haskell has arrays :)
15:10:56 <Cale> lesshaste: why?
15:11:00 <lesshaste> bolrod: better algorithsm for that problem?
15:11:12 <lesshaste> Cale: because I am old and there were no arrays in my day :)
15:11:34 <jethr0_> lesshaste: that must be a _long_ time ago. even assembly has arrays (to some extent)
15:11:35 <Cale> ah, they've been there since Haskell '98 at least.
15:11:48 <Philippa> jethr0_: doesn't quite work like that
15:11:48 <lesshaste> jethr0_: oh yes.. but haskell only since 98.. see above
15:11:50 <jethr0_> ah, you mean in your _haskell_ day :)
15:11:54 <lesshaste> :)
15:12:00 <lesshaste> yes.. it was Miranda in fact
15:12:12 <jethr0_> Philippa: what doesn't? the code above was just for inspiration :)
15:12:53 <dons> newsham, there''s also the bytecode backend, via ghci. so 3 backends. 4 if you count the C-- backend that's 3/4 done
15:13:09 <dons> but the runtime system is all STG machine
15:13:22 <dons> a few details have changed, but nothing major
15:13:36 <lesshaste> while I am making trouble.. how about a version of quicksort that runs in O(nlogn) on average?
15:13:40 <lesshaste> is that doable in haskell?
15:13:56 <bolrod> lesshaste: yes.. there was a nifty algorythm ...  though I dont know if its in the slides.. or he just drew it on the board
15:14:00 <newsham> lesshaste: as opposed to O(?) 
15:14:07 <dons> yeah, funny question
15:14:21 <Philippa> lesshaste: it's doable in-place for some structures
15:14:21 <Cale> lesshaste: how about the usual one?
15:14:48 <jethr0_> "average" is not "O" calculus
15:15:15 <Cale> jethr0_: it can be treated that way
15:15:21 <dons> or just use 'List.sort' (a merge sort) which is n log n worst case
15:15:31 <lesshaste> Cale: the usual one takes linear time for each concatenation
15:15:36 <lesshaste> that's the problem
15:15:43 <jethr0_> Cale: i thought it was called sth else then. wasn't it "o" or omega, or sth
15:15:44 <Philippa> jethr0_: you can give O() on any speed function, not just the worst-case one
15:15:50 <lesshaste> jethr0_: average is 'O' calculus ;)
15:16:10 <Cale> lesshaste: that's not going to spoil the complexity in the average case
15:16:15 <lesshaste> newsham: as opposed to O(n^2) which is caused by the time needed to concatenate two lists in haskell
15:16:19 <jethr0_> *grumble*, i seem to always say the wrong things
15:16:23 <dons> anyway, "is that doable in haskell" -- yes, of course
15:16:42 <Cale> xs ++ ys takes O(length xs) time.
15:16:45 <Philippa> lesshaste: these days you can give horrible too-literal translations of C code
15:16:50 <lesshaste> Cale: I am afraid it will as it makes it O(n^2) in *every* case
15:17:03 <dons> if such an algorithm exists, then you can always code the C version fairly directly into haskell
15:17:11 <lesshaste> Philippa: ah.. not I just meant an elegant O(nlogn) haskell implementation :)
15:17:15 <dons> or use difference lists, for exapmle, of O(1) ++
15:17:23 <Philippa> for what value(s) of elegant? :-)
15:17:40 <Cale> lesshaste: it doesn't copy what it can share though
15:17:43 <lesshaste> Philippa: :)
15:17:47 <newsham> philippa: got a set of values to choose from?
15:18:05 <Philippa> newsham: "but that can't be elegant, it uses the IO monad!" is one...
15:18:12 <lesshaste> Cale: I think in the basic quicksort implementation it has to copy... although I could be wrong of course
15:18:29 <Cale> lesshaste: it only has to copy the left argument to (++)
15:18:33 <lesshaste> Cale: but xs ++ ys takes O(length xs) time is my understanding
15:18:41 <lesshaste> Cale: yes.. that is too much
15:18:41 <jethr0_> Philippa: from wikipedia: "Big O notation is a mathematical notation used to describe the asymptotic behavior of functions. More precisely, it is used to describe an asymptotic upper bound"
15:19:13 <dons> lesshaste, if ++ is the problem, you can use a difference list representation, allowing O(1) append
15:19:14 <gzl> jethr0_: wait, what are you disagreeing about?
15:19:16 <Cale> jethr0_: sure, you can put an asymptotic upper bound on the average case complexity
15:19:21 <jethr0_> ah, i see i'm not even disagreeing with anyone :'(
15:19:25 <Philippa> jethr0_: right. The function being described might be the average case, for example :-)
15:19:29 <gzl> ah, that. yeah, what Cale said.
15:19:45 <newsham> averae upper bound?
15:19:48 <jethr0_> let's all sing in unison
15:19:54 <lesshaste> dons: right.. that sounds clever
15:19:57 <newsham> is that like a randomly generated number?
15:20:09 <lesshaste> jethr0_: :)
15:20:21 <drakioned> jethr0_, singing in unison is what we have the #haskell-blah room for ;)
15:20:28 <bolrod> ;o
15:20:31 <lesshaste> newsham: upper bound on the average case
15:20:35 <newsham> my upper bound is more average than yours
15:20:50 <lesshaste> newsham: e.g. the average time is n^2 + n...therefore the average case is O(n^2)
15:20:52 <drakioned> my upper bound is more bounded than yours
15:20:55 <newsham> which parts of the bell curve are the average cases found on?
15:21:03 <jethr0_> newsham: average as in amortized complexity. i.e. paying for rebalancing a tree during cheaper lookup iterations
15:21:18 <lesshaste> jethr0_: that's something slightly different
15:21:23 <lesshaste> jethr0_: but also interesting :)
15:21:34 <wchogg> Would anyone mind if I asked about how to convert some c++ code to Haskell?
15:22:01 <lesshaste> newsham: well.. the median is in the middle :)
15:22:07 <drakioned> of course not, people always like C++ people jumping ship ;)
15:22:15 <jethr0_> *damnit*. but i've never been to happy with average upper bounds. chances are the "proof" is flawed somewhere because someone just wanted to get a nice "average" value :)
15:22:21 <lesshaste> dons: do you know how to do that though? :)
15:22:45 <lesshaste> jethr0_: no no :) the problem is only that you have to make assumption about the input distribution.. like that it is uniform
15:22:51 <drakioned> how does someone prove an average...?
15:22:53 <lesshaste> jethr0_: your real data may not be like that of coure
15:22:54 <lesshaste> course
15:23:00 <jethr0_> lesshaste: i know. but that's often stupid
15:23:09 <lesshaste> drakioned: probability theory :)
15:23:17 <dons> lesshaste, yes. at the bottom of this file: http://www.cse.unsw.edu.au/~dons/code/yi/Yi/Lexers.hs
15:23:31 <newsham> i imagine the "average upper bound" people are the ones preaching O(1) hash tables
15:23:31 <lesshaste> jethr0_: right... you mean your real data may not be distributed the way you assumed?
15:23:37 <jethr0_> yes
15:23:46 <lesshaste> dons: ok thx
15:23:48 <lesshaste> jethr0_: all true
15:24:19 <jethr0_> wchogg: you mean like "literally converting"??
15:24:21 <lesshaste> jethr0_: however.. sometimes you can randomise your data so you don't have to worry.. so for quicksort you can randomise the order of the input then you really do have the right distribution to analyse the algorithm
15:24:45 <newsham> why do functional languages always have Cons cells?
15:24:51 <lesshaste> jethr0_: i.e. there will be no really bad input cases any more
15:24:53 <wchogg> jethr0-I mean how to idiomatically write the same algorithm in Haskell as c++.  It *should* be straightforward, but there's something that bugs me.
15:25:06 <lesshaste> wchogg: it might not be straightforward :)
15:25:10 <jethr0_> lesshaste: i'm not saying average upper bounds are not usefull, just that often that instrument is used to hide a bad worst-case one.
15:25:10 <drakioned> wchogg, paste it somewhere?
15:25:23 <lesshaste> jethr0_: well that is bad if people do that
15:25:23 <wchogg> Yeah, I'm reformatting it for the paste.
15:25:42 <lesshaste> jethr0_: quicksort is useful however in practice :)
15:25:49 <lesshaste> jethr0_: despite having a bad worst case
15:25:52 <dons> it would be fairly straight forward  (almost mechanical) but you might need IORefs or mutable arrays
15:25:57 <drakioned> lesshaste, I think complexity of conversion may depend on whether you want it pure
15:26:15 <lesshaste> drakioned: are you talking about wchogg's c++?
15:26:20 <drakioned> lesshaste, yeah
15:26:31 <lesshaste> I am not really in a good position to comment
15:26:34 <lesshaste> my haskell is weak
15:26:36 <newsham> dont mutable arrays provide a functional interface (and just hide the efficient mutations)?
15:26:55 <drakioned> lesshaste, mine too
15:26:59 <dons> they're in the IO monad, since sequencing matters, newsham
15:27:05 <newsham> ahh
15:27:43 <dons> you might be thinking of unboxed (pure) arrays that aren't mutable
15:27:50 <lesshaste> http://en.wikibooks.org/wiki/Transwiki:Quicksort_implementations#Haskell may be a bit better
15:27:51 <dons> but have an efficient representation hiddne 
15:27:58 <lesshaste> drakioned: :)
15:28:24 <newsham> i'm not sure what i'm thinking of.. i've never used em, just a vague recollection hearin people talk of such things here 
15:28:29 <newsham> <- still pretty green
15:28:37 <lisppaste2> wchogg pasted "Stupid Iteration" at http://paste.lisp.org/display/17885
15:28:37 <dons> lesshaste, why not use thhe quicksort implementation in the standard libraries
15:29:12 <drakioned> are there any really small Haskell projects that newbies can contribute to?
15:29:20 <Philippa> Flippi!
15:29:24 <wchogg> drakioned-I'd like to find one.
15:29:25 <Philippa> go write me some plugins, bitch :-)
15:29:43 <drakioned> lol
15:29:46 <wchogg> I'm not your plugin-bitch!
15:29:48 <drakioned> wchogg, me too
15:29:49 <Philippa> though I've a sneaking suspicion the darcs repo's down
15:30:02 <dons> and the're cleaner qsorts around, anyway. here, for example, 
15:30:03 <dons>  qsort []     = []
15:30:03 <dons>  qsort (x:xs) = qsort less ++ [x] ++ qsort more
15:30:03 <dons>      where less = filter (<x)  xs
15:30:03 <dons>            more = filter (>=x) xs
15:30:18 <Philippa> semi-seriously, you'd at the least get rapid feedback and a feeling you're building a useful system that way
15:30:36 <drakioned> what's Flippi?
15:30:43 <Philippa> a wiki clone I wrote
15:31:09 <Philippa> the version in the darcs repo has a plugin model that led to SyntaxNinja stating that "Flippi has a pluggable back end"
15:31:15 <dons> so, I wonder, who's posting these ugly  qsorts on wikipedia?
15:31:31 <dons> I mean, even the miranda one looks good. why not just use that?
15:31:47 <Philippa> (because a plugin can take over the implementation of the page IO API and eg run it all out of a database instead of the filesystem)
15:32:09 <newsham> if filter is O(N) and ++ is O(N), how does the ++ make qsort O(n^2)?
15:32:20 <newsham> <- too lazy to do the math
15:32:25 <Igloo> dons: Not only ugly, but incorrect from teh looks of it
15:32:47 <jethr0_> newsham: are you saying you're even lazier than haskell?
15:32:56 <newsham> jethro: quite possibly
15:33:01 <newsham> not to detract from haskell
15:33:06 <dons> Igloo, hehe. it gets even better. call the haskell-conspiracy police
15:33:07 <wchogg> Philippa, do you have a link about your Flippi project?
15:33:33 <newsham> anti-haskellites seeding the wiki with bad haskell?
15:33:52 <lesshaste> hmm.. you know I might be wrong about the complexity of naive quicksort in haskell
15:33:54 <jethr0_> newsham `seq` getAnswerFrom newsham
15:33:59 <drakioned> newsham, I think it's a bit harsh calling us noobs anti-haskellites :P
15:34:24 <Cale> lesshaste: I'm testing with random lists, and it really looks O(n log n) to me
15:34:24 <wchogg> Anyway, if anyone knows how to properly express that iteration I pasted it would be appreciated.  The problem with the ordering has been driving me crazy.
15:34:54 <drakioned> wchogg, umm, presumably you're doing something like that inside an IO Monad?
15:35:00 <Cale> lesshaste: just doing a larger run of tests, and we'll see what it looks like :)
15:35:07 <lesshaste> Cale: I think it is very slow but maybe O(nlogn) on average... as the concatenation takes the same time complexity as the partitioning....
15:35:24 <Cale> right
15:35:27 <lesshaste> Cale: it's just very inefficient
15:35:28 <Cale> It's actually not so bad
15:35:33 <lesshaste> Cale: as it repeats itself
15:35:51 <newsham> lesshaste: thats what I was trying to say.
15:35:57 <drakioned> wchogg, and also, I don't suppose you have some example output?
15:36:00 <jethr0_> wchogg: i can't seem to find the url to your paste
15:36:20 <newsham> (not quite repeat itself..  the partitioning happens before recursion, the splicing happens post recursion)
15:36:22 <wchogg> http://paste.lisp.org/display/17885 <- that's it
15:36:23 <drakioned> jethro : http://paste.lisp.org/display/17885
15:36:40 <wchogg> Why would it need to be in the IO Monad?  There's no input or output, right?
15:36:47 <newsham> but if there was an optimized tail-insertion it would definitely be faster
15:36:53 <jethr0_> thx
15:37:11 <wchogg> It's just creating a list.  The array can be initialized with the list later.
15:37:18 <lesshaste> Cale:  and it needs lots of stack space...
15:37:42 <lesshaste> newsham: it goes over each half twice right?
15:37:51 <lesshaste> newsham: once to concatenate and once to partition?
15:38:12 <dons> lesshaste, what about the standard qsort I posted above? from http://www.haskell.org/haskellwiki/Why_Haskell_Matters
15:38:19 <lesshaste> which is where http://en.wikibooks.org/wiki/Transwiki:Quicksort_implementations#Haskell  comes in
15:38:24 <dons> it's a lot more elegant
15:38:47 <lesshaste> dons: yes.. that's the really slow one
15:38:51 <lesshaste> dons: the replicates work
15:38:56 <lesshaste> dons: and needs far too much stack space :)
15:39:08 <lesshaste> that replicates
15:39:19 <dons> it's beautiful though. 
15:39:23 <dons> so it should be on the wiki
15:39:26 <dons> shouldn't it?
15:39:29 <lesshaste> dons:  but it beautifl.. there is no denying it
15:39:34 <lesshaste> isn't it there?
15:40:01 <lesshaste> dons: http://en.wikipedia.org/wiki/Quicksort#Functional_programming_language_.28Haskell.29
15:40:20 <lesshaste> thx all.. this was important as the lecture notes had binary seach and quicksort in haskell
15:40:36 <Cale> http://cale.yi.org/autoshare/sorttimes.png
15:40:41 <lesshaste> binary search does *not* have O(logn) time in haskell but it seems quicksort does have the right complexity
15:40:42 <Cale> times are in picoseconds :)
15:40:55 <newsham> less: it goes over the whole thing twice (once to filter one set, once to filter the other), then later it goes over the first half once to do the concatenation
15:41:01 <lesshaste> Cale: very pretty :)
15:41:20 <jethr0_> wchogg: why doesn't [map (\m -> (m+0.5)*a) [x,y,z], x <- [0..n-1], y <- [0..n-1], z <- [0..n-1]] work?
15:41:21 <lesshaste> newsham: that's right.. you put it much more clearly than me.. I need to sleep :)
15:41:36 <jethr0_> s/z],/z]|/
15:41:59 <newsham> binary search is O(log n) if you have a tree.
15:42:06 <newsham> (and its balanced)
15:42:14 <lesshaste> newsham: his.. but not if you don't.. which the notes don't
15:42:17 <wchogg> Phillipa - I am reading what you're saying, but I never registered my nick so I can't actually reply.  
15:42:18 <jethr0_> newsham: binary search is O(log n) on a sorted array too
15:42:31 <Philippa> wchogg: ah. You could, uh, register your nick? :-)
15:42:32 <lesshaste> yes... but not on a sorted list
15:42:40 <wchogg> Well I know that *now*. :-P
15:43:00 <Philippa> does what I wrote about plugins sound scary, or does it make sense?
15:43:05 <lesshaste> so I only need to change that part :)
15:43:07 <lesshaste> thx very much
15:43:11 <lesshaste> good night
15:43:23 <drakioned> should I ask about the plugins or should I just ask tomorrow?
15:43:27 <wchogg> I'd have to think about it for it to make more sense.  Not scary though.  Just need to think.
15:43:42 <Philippa> ask tomorrow and bring pen'n'paper with you?
15:43:43 <newsham> lesshaste: but also bin search wont be O(log n) in C if you use a linked list.
15:43:50 <drakioned> ok
15:44:01 <lesshaste> newsham: I know that.. the C is an array.. the haskell was a list.. hence the haskell was wrong :)
15:44:17 <lesshaste> actually java and haskell but you get my point :)
15:44:24 <jethr0_> wchogg: why doesn't [map (\m -> (m+0.5)*a) [x,y,z]| x <- [0..n-1], y <- [0..n-1], z <- [0..n-1]] work?
15:44:31 <jethr0_> how does that muddle up the order?
15:44:44 <TuringTest> hi dons
15:44:52 <dons> this seems more efficient than the basic version, using difference lists:
15:44:53 <dons> qsort []     = []
15:44:54 <dons> qsort (x:xs) = close $ (open $ qsort less) `join` unit x `join` (open $ qsort more)
15:44:56 <dons>    where less = filter (<x)  xs
15:44:58 <lesshaste> newsham: one day I will learn how to use arrays in haskell :)
15:44:59 <dons>          more = filter (>=x) xs
15:45:00 <wchogg> Let me try it, but I thought it wasn't right.
15:45:04 <dons> runs a few times faster on my box
15:45:12 <lesshaste> dons: that looks cool.. I have to go sadly
15:45:33 <TuringTest> dons: I just joined -- what are 'open' and 'close' ?
15:45:34 <newsham> less: when you do feel free to tell me about them :)
15:45:51 <jethr0_> > [(x,y) | x <- [1,2], y <- [3,4]]
15:45:52 <lambdabot> [(1,3),(1,4),(2,3),(2,4)]
15:46:32 <dons> TuringTest, open and close are the introductoin and elimination forms for difference lists -- lists represented as functions, providing O(1) append
15:47:13 <dons> full version here: http://www.cse.unsw.edu.au/~dons/tmp/QSort.hs
15:47:29 <drakioned> dons, is there a reason why the standard ++ isn't written in that manner..?
15:47:34 <wchogg> jethr0 - Well damn, it looks like perhaps I was completely wrong and list comprehensions work fine.
15:47:54 <dons> because it isn't a difference list :) we like to use cons'ing, not -> and (.) 
15:47:57 <dons> :)
15:48:16 <drakioned> ok
15:48:16 <TuringTest> dons: Did you look at the new alpha-shootout-bechmark ?
15:48:17 <jethr0_> wchogg: glad to help
15:48:25 <dons> TuringTest, no, didn't see it
15:48:26 <wchogg> Yeah, thanks.  I do appreciate it alot.
15:48:30 <TuringTest> http://haskell.org/hawiki/HealthcareEntry
15:48:32 * drakioned still doesn't understand list comprehensions.
15:48:38 <TuringTest> Alson started a wiki page
15:48:52 <jethr0_> drakioned: which part don't you understand?
15:49:05 <dons> ah, but this has been around for a year or so now, TuringTest, and no progress has been made on the benchmakr
15:49:06 <TuringTest> And I have spent much of today turning the OCaml entry into a Haskell entry that does not suck
15:49:11 <dons> has it?
15:49:12 <TuringTest> dons: Ah
15:49:24 <TuringTest> Silly me
15:49:27 <drakioned> how people can seemingly pack so many things into it and have it still work.
15:49:28 <dons> i think this is mentioned in the forum
15:50:15 <ski__> (dons : does the rec. calls there get optimised ?)
15:50:27 <kosmikus> lhs2tex-1.11 is quasi-released; testing, feedback, flames welcome
15:50:50 <jethr0_> drakioned: that's a different issue... but it's generally just nested "map"s and "filter"s
15:51:51 <drakioned> ok
15:52:02 <wchogg> I don't know if I mentioned this, but I might actually get to use haskell in writing code for my research.  
15:52:42 <jethr0_> drakioned: so [x+1, x <- [1,2,3], x /= 2] would translate to "map (+1) . filter (/=2) $ [1,2,3]"
15:53:12 <drakioned> um.. does that not need a x| somewhere?
15:53:30 <jethr0_> damnit! "x+1|"
15:53:35 <drakioned> ah
15:53:49 <drakioned> okay, that makes more sense
15:54:36 <drakioned> wchogg, I'm trying to learn it because everything else seems to make less sense
15:55:06 <newsham> hmm.. so ghc overwrites code with new code when forcign a thunk?
15:55:11 <jethr0_> drakioned: anything else i can (hopefully) help with?
15:55:33 <wchogg> What, learning Haskell itself?  I think it does make alot of sense.  It reads like math.
15:56:08 <wchogg> Is there a good primer for doing FFI in Haskell?  Is it just part of the report?
15:56:13 <drakioned> with that last function you wrote, could you take the map outside and have map (\m -> (m+0.5)*a) [[x,y,z]| x <- [0..n-1], y <- [0..n-1], z <- [0..n-1]] ?
15:56:38 <newsham> wchogg: i mostly went off the FFI .pdf and asked some questions here when I was playing with it
15:56:50 <newsham> it wasnt too hard.  I have some code but I dont think I can share it :(
15:56:55 <drakioned> wchogg, that's kinda my point, it makes more sense than anything else out there to me, like C++ just looks like gibberish to me
15:56:55 <dons> newsham, it overwrites a ptr to code with a result, or a ptr to the result
15:56:58 <jethr0_> drakioned: no, because the list comprehension returns a list of lists
15:57:16 <jethr0_> "map (map (\m -> (m+0.5)*a))" should work though
15:57:29 <drakioned> ah
15:57:36 <newsham> dons: does new code ever get written out and executed, or is all code statically generated?
15:57:43 <wchogg> I cut my teeth on c++, because I work in physics.  It's not the nicest language.  I'm still having to write alot in it before I end up changing advisors.
15:57:45 <jethr0_> > [[x,y]| x <- [1,2], y <- [3,4]]
15:57:46 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
15:58:10 <dons> it's all static.
15:58:39 <dons> thunks are more like objects in the java sense, with hidden fields and method ptrs
15:58:40 <wchogg> By FFI pdf you mean http://www.cse.unsw.edu.au/~chak/haskell/ffi/ ?
15:59:56 <newsham> yes
16:00:01 <wchogg> Cool.
16:00:02 * vincenz just saw Syriana
16:00:33 <drakioned> umm, just as a check, would map (\m -> map (\x -> (x+0.5)*a) m) [[x,y,z]| x <- [0..n-1], y <- [0..n-1], z <- [0..n-1]] work?
16:00:35 <lisppaste2> TuringTest pasted "for dons" at http://paste.lisp.org/display/17888
16:00:38 <newsham> its actually not very complicated, but it might seem so at first
16:00:40 * jethr0_ liked syriana
16:00:47 <vincenz> it was a bit confusing
16:00:59 <jethr0_> drakioned: yes
16:01:08 <drakioned> ok
16:01:10 <TuringTest> dons: Isn't the version I pasted simpler?
16:01:27 <vincenz> > let (...) = flip ($) in [1..5]...filter (/=2)...map (+1)
16:01:28 <lambdabot> [2,4,5,6]
16:01:30 <jethr0_> @pl map (\m -> map (\x -> (x+0.5)*a) m)
16:01:31 <lambdabot> map (map ((a *) . (0 . 5 +)))
16:01:37 <newsham> although if you have to marshall structs, and you're not using a package like c2hs, you'll have to do some tedious translations
16:02:50 <jethr0_> i was about confused that structs are treated as pointers and struct-pointers as pointers to pointers... not the most intuitive concept
16:05:56 <lisppaste2> TuringTest annotated #17888 with "both versions" at http://paste.lisp.org/display/17888#1
16:07:44 <dons> TuringTest, yep, that's exactly how I rewrote it too :) http://www.cse.unsw.edu.au/~dons/tmp/QSort.hs
16:08:18 <dons> then it's clear that's it's (.) joining everything together.
16:14:38 <ihope> Though type inference is good, so are type annotations.
16:15:33 <ihope> pt x = all (\y -> y `mod` x /= 0) (takeWhile (\y -> y*y <= x) pl)
16:15:47 <ihope> pl = 2 : filter pt [3..]
16:16:12 <ihope> pl is supposed to be a list of primes. However, it seems to be [2..].
16:16:25 <ihope> As far as I know, not every element of [2..] is prime. ;-)
16:16:43 <vincenz> how do you know?
16:16:46 <dons> \pl \y -> y*y <= x
16:16:46 <lambdabot> (<= x) . join (*)
16:16:53 <dons> not bad, lambdabot
16:17:03 <vincenz> \o/
16:17:03 <lambdabot> Maybe you meant: . id pl wn yow
16:17:06 <jgrimes> So, Haskell School of Expression is a pretty good book for learning Haskell?
16:17:07 <vincenz> :(
16:17:09 <dons> \pl \y -> y `mod` x /= 0
16:17:10 <lambdabot> (0 /=) . (`mod` x)
16:17:12 <dons> even better
16:17:31 <vincenz> @pl \x -> x
16:17:31 <lambdabot> id
16:17:39 <dons> vincenz shouldn't use funny \o/ smilies
16:17:40 <vincenz> perfection
16:17:46 <vincenz> dons: they're not smileys
16:17:47 <ihope> I just realized... that's lambdabot removing lambdas.
16:17:47 <vincenz> they're happies
16:18:02 <vincenz> as in yay \o>
16:18:04 <dons> oh, it's an unlambdabot :)
16:18:21 <dons> speaking of which, why don't we have an unlambda plugin!
16:18:21 <vincenz> @botsnack
16:18:22 <lambdabot> :)
16:18:25 <ihope> No, it doesn't do anything with Unlambda.
16:18:33 <dons> who wants to add the haskell unlambda interpreter as a plugin?
16:18:39 <dons> it's only 40 or so loc from memory
16:18:45 <vincenz> unlambda?
16:18:51 <dons> then we'd really have an unlambdabot
16:18:57 <ihope> Yeah!
16:19:00 <vincenz> que es unlambda?
16:19:03 <ihope> @google unlambda
16:19:04 <lambdabot> http://www.madore.org/~david/programs/unlambda/
16:19:24 <dons> sounds like a fun little game. i'll write the plugin now
16:19:32 <vincenz> oh
16:19:32 <vincenz> ski
16:19:50 <dons> ski :)
16:19:56 <ihope> S.
16:19:58 * dons wakes up ski
16:20:23 * dons notes that he's been hacking lambdabot for 3 years now
16:20:48 <ihope> vincenz: dynamic typing, eager evaluation, side effects, simple syntax... you can't say you don't love it!
16:21:07 <Pseudonym> Cool!  That means I've NOT been hacking lambdabot for 3 years now.
16:21:14 <dons> :)
16:21:18 <ihope> @quote
16:21:19 <lambdabot> JaffaCake says: not all IOError -> String functions are created equal :)
16:21:19 <SyntaxNinja> <--- not hacking lambdabot for the last 26+ years
16:21:33 <dons> since i was born!
16:21:36 <ihope> <- Not hacking lambdabot for 13 years.
16:21:49 <ihope> Yes, only 13. Eep.
16:22:17 * SyntaxNinja hands ihope a cookie
16:22:33 <Pseudonym> Now there's an existential quandry.  Can you said to be not hacking lambdabot at a time when lambdabot does not exist?
16:22:37 <ihope> Yes.
16:22:45 <Pseudonym> Personally, I haven't been building time machines for the next 5 years.
16:23:01 <ihope> Apparently, however, I'm not counting the years before I was born.
16:23:03 <wchogg> No, you *will* have not been building time machines for the next 5 years.
16:23:23 <ihope> @remember Pseudonym Personally, I haven't been building time machines for the next 5 years.
16:23:24 <lambdabot> Done.
16:23:31 <ihope> @quote ihope
16:23:32 <Pseudonym> :-)
16:23:32 <lambdabot>  Laziness is free, but it doesn't always pay off.
16:23:48 <jethr0_> write-only languages have a certain charme. who'd have thought that writing a program could be easier than reading, without ever experiencing it themselves :)
16:24:30 <vincenz> ihope: what is that supposed to mean
16:24:35 <vincenz> ihope: I was never a fan of dynamic typing
16:24:48 * vincenz smacks ihope with a recursive tailcall
16:24:50 * jethr0_ puts on his flame suit
16:25:14 <Pseudonym> > unsafeFlame# jethr0_
16:25:15 <lambdabot>  Not in scope: `jethr0_'
16:25:16 <ihope> vincenz: well, I'm not saying Unlambda's a good language ;-)
16:25:28 <wchogg> Dynamic typing *can* be nice because there's no strong restrictions.  With a good enough type system you don't really notice restrictions either.
16:25:31 <ihope> I need my Unlambda programs to be extremely well commented, i.e. bundled along with a Haskell program doing the same thing and a detailed explanation of how I translated it.
16:25:58 <vincenz> > pours diesel into ihope's gasoline-fueled car
16:25:58 <lambdabot>  Not in scope: `car'
16:26:17 <vincenz> lambdabot: try cdr then
16:26:25 * ihope wonders what's happening
16:26:26 <ihope> > let pt x = all (\y -> y `mod` x /= 0) (takeWhile (\y -> y*y <= x) pl); pl = 2 : filter pt [3..] in pl
16:26:27 <wchogg> Stop confusing the lambdabot, yo!
16:26:27 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
16:26:27 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
16:26:27 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
16:26:27 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
16:26:27 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
16:26:29 <lambdabot> [24 @more lines]
16:26:36 <ihope> See? 4's a prime number!
16:26:41 <ihope> I KNEW it!
16:27:37 <newsham> > map toEnum [115,116,111,112,32,99,111,110,102,117,115,105,110,103,32,109,101] :: [Char]
16:27:38 <lambdabot> "stop confusing me"
16:27:43 <jethr0_> let pt x = all (\y -> y `mod` x /= 0) [2..10] in pt 11
16:27:45 <jethr0_> > let pt x = all (\y -> y `mod` x /= 0) [2..10] in pt 11
16:27:47 <lambdabot> True
16:27:54 <jethr0_> > let pt x = all (\y -> y `mod` x /= 0) [2..10] in pt 12
16:27:55 <lambdabot> True
16:28:20 <jethr0_> ihope: you mean "x `mod` y"
16:28:31 <ihope> I do?
16:28:35 <vincenz> > map fromEnum [105,104,111,112,101,32,105,115,32,115,112,97,109,109,105,110,103,32,109,101] :: [Char]
16:28:36 <jethr0_> yes
16:28:36 <lambdabot> Couldn't match `Char' against `Int'
16:28:42 <vincenz> > map toEnum [105,104,111,112,101,32,105,115,32,115,112,97,109,109,105,110,103,32,109,101] :: [Char]
16:28:43 <lambdabot> "ihope is spamming me"
16:28:50 <kosmikus> hah. it's finally done.
16:28:58 <jethr0_> _FINALLY_
16:29:02 <kosmikus> :)
16:29:06 <vincenz> AT LAST <insert evil laugh>
16:29:28 <jethr0_> i especially love the blaming-ihope when it was someone else aspect
16:29:33 <ihope> @karma jethr0
16:29:33 <lambdabot> jethr0 has a karma of 1
16:29:47 <vincenz> @karma lambdabot 
16:29:48 <lambdabot> lambdabot has a karma of 11
16:29:57 <kosmikus> SyntaxNinja: so, lhs2tex-1.11 is cabalized, but it requires 1.1.4 ;)
16:30:02 <ihope> @karma dons
16:30:02 <lambdabot> dons has a karma of 23
16:30:04 * vincenz is off to bed
16:30:05 <ihope> @karma ihope
16:30:06 <lambdabot> You have a karma of 1
16:30:10 <ihope> @karma+ ihope
16:30:10 <lambdabot> You can't change your own karma, silly.
16:30:13 <ihope> :-)
16:30:16 <jethr0_> ihope: and, do your primes work now?
16:30:20 <ihope> Aye.
16:30:23 * vincenz thinks that increasing your own karma should decrease
16:30:43 <ihope> vincenz: and the other way around, too, right?
16:30:50 <vincenz> noe that would decrease twice
16:31:00 <vincenz> and asking your own karma removes half a point
16:31:05 <ihope> Why?
16:31:07 <vincenz> it's like zen buddhism, the less you try, the more you gain
16:31:17 * vincenz remembers this mud zenmooo
16:31:18 <jethr0_> vincenz: then i'd use the old simcity trick and try to get my karma below -32000
16:31:20 <vincenz> sadly it went to bitrot 
16:31:28 <vincenz> if ANYONE has a link to it, I would love it!
16:33:10 <newsham> i thought mud/moo people and irc people dont mix
16:33:13 <ihope> jethr0_: what simcity trick?
16:33:22 <wchogg> Why wouldn't they, newsham?
16:33:28 <ihope> @google zenmooo
16:33:30 <newsham> wchogg: worlds colliding
16:33:30 <lambdabot> http://www.52lg.com/archiver/?tid-8071-page-22.html
16:33:37 <vincenz> ihope: all google links are old links that are stale
16:33:39 <newsham> jethr0: integer underflow?
16:33:48 <vincenz> tje original site is gone
16:33:58 <wchogg> It seems like they're pretty similar worlds:  people geeking out on Teh Intarnet.
16:34:00 <ihope> Where was it?
16:34:13 <newsham> wchogg: yah, which is why there was so much hostility.
16:34:20 <newsham> similarity breeds contempt
16:34:21 <jethr0_> don't you people remember?
16:34:36 * Philippa is tempted to point wchogg at the fur sections of Second Life. Bit more than geeking out there...
16:34:46 <jethr0_> getting into huge debt to be king after 16bit signed integer underflow?
16:35:17 <newsham> we're not all evil hax0rs, jethro.
16:35:21 <ihope> -32768 simmies before It Happens?
16:35:26 <wchogg> Whoah now, furries?  Oh hell no.
16:35:36 <jethr0_> simmies? yes sth like that
16:35:52 <jethr0_> newsham: :)
16:35:58 <Philippa> wchogg: the ones I know in person're alright
16:36:09 <Philippa> though as I'm playing with one I may have a biased opinion
16:36:23 <jethr0_> newsham: that's one of the first CS things i ever learnt ^_^
16:36:25 <wchogg> Eh, I believe that.  But I've also seen some pretty scary crap.
16:37:01 <Philippa> oh, I know of a lot of stuff going on that'd scare most people...
16:37:02 <newsham> i do computer security.  i deal w/ finite precision overflows often
16:37:16 <wchogg> You are the keeper of the dark secrets of the internet?
16:37:24 * dons adds lhs2TeX to next weeks hwn
16:37:36 <newsham> int *arr = malloc(n * sizeof *arr);   for(i = 0; i < n; i++) arr[i] = readVal();
16:37:52 <newsham> oops!   n >= 0x40000000 bad things happen
16:38:19 <Philippa> wchogg: not quite. No few dark secrets IRL though
16:38:41 <wchogg> And that's where the topic will drop awkwardly.
16:38:46 <Philippa> :-)
16:38:54 <Philippa> there's #haskell-blah for that ;-)
16:39:03 <jethr0_> k, good night
16:39:18 <SyntaxNinja> #haskell-philippas-dark-not-so-secrets
16:39:21 * vincenz sighs
16:39:24 * vincenz wants zenmoo back
16:39:58 <drakioned> ===	#haskell-philippas-dark-not-so-secrets Nick/channel is temporarily unavailable
16:40:05 <kosmikus> dons: thanks
16:40:06 <Philippa> SyntaxNinja: trust me, there's as much if not more stuff you don't know :-)
16:40:41 <SyntaxNinja> Philippa: ahh, but those aren't on #haskell-blah, right ;)
16:40:49 <Philippa> indeed :-)
16:41:04 <Philippa> and these days more than half of the conversations /aren't/ about that...
16:41:13 <SyntaxNinja> someone is slacking off
16:41:30 <Philippa> nah, spending more time doing instead of talking :-)
16:42:28 <ihope> @where ihope
16:42:28 <lambdabot> I know nothing about ihope.
16:42:35 <ihope> Gasp.
16:42:38 <ihope> Oh, right.
16:42:38 <dons> \pl parse h >>= \e1 -> parse h >>= \e2 -> return (App e1 e2)
16:42:39 <lambdabot> (`fmap` parse h) . App =<< parse h
16:42:40 <ihope> @seen ihope
16:42:40 <lambdabot> You are in #haskell-blah and #haskell. Last spoke just now.
16:42:53 <SyntaxNinja> :P
16:47:05 <newsham> what's a "saturated" operation?
16:47:20 <dons> all arguments are availabel
16:47:26 <dons> unlike, say, (+) 1
16:49:18 <ihope> <interactive>:1:0: Not in scope: `+'
16:49:55 <newsham> can ghc be instructed to emit STG code?
16:50:04 <ihope> What's STG?
16:50:13 <Philippa> Spineless Tagless G-Machine
16:50:22 <ihope> Cmo?
16:50:33 <Philippa> can't read your unicode 'mafraid
16:51:11 <ihope> Upside-down question mark, C, lowercase o with acute accent, mo?
16:51:12 <dons> newsham, -ddump-stg , iirc
16:51:28 <ihope> No instance for (GHC.Show.Show (t -> t)) arising from the use of `System.IO.print' at Top level
16:52:17 <newsham> danke
16:52:29 <newsham> can lambdabot dump stg?  ;-)
16:52:56 <ihope> @set
16:52:57 <lambdabot> Lately, I have seen dons, drakioned, ihope, jethr0_, kosmikus, myrkraverk,
16:52:57 <lambdabot> newsham, philippa, pseudonym, sarah, syntaxninja, vincenz and wchogg.
16:53:01 <dons> \pl \dat cont -> cont dat a
16:53:02 <lambdabot> flip flip a . flip id
16:53:05 <dons> hehe
16:53:22 <ihope> not (isRight that)
16:54:06 <ihope> @djinn-add type Nxor a b = Either a b -> (a,b)
16:54:26 <ihope> @djinn Not (Nxor Void Void)
16:54:27 <lambdabot> -- f cannot be realized.
16:54:30 <ihope> @djinn Not (Nxor Void ())
16:54:31 <lambdabot> f a =
16:54:31 <lambdabot>   case a (Right ()) of
16:54:31 <lambdabot>   (b, _) -> b
16:54:39 <ihope> @djinn Not (Nxor () Void)
16:54:39 <lambdabot> f a =
16:54:39 <lambdabot>   case a (Left ()) of
16:54:39 <lambdabot>   (_, b) -> b
16:54:42 <ihope> @djinn Not (Nxor () ())
16:54:43 <lambdabot> -- f cannot be realized.
16:57:05 <dons> \pl \_ a -> return a
16:57:06 <lambdabot> const return
17:01:43 <ihope> Fish fight, fish fight. Roly-poly fish fight. Fish fight, fish fight. Beat them up, yum.
17:03:15 <ihope> > 800/30
17:03:16 <lambdabot> 26.666666666666668
17:03:45 <TuringTest> > (\f -> (foldr (flip (foldr (:)).f) [])) (\x -> [2^x,3^x] [[1],[2,3],[4]]
17:03:46 <lambdabot>  parse error on input `}'
17:04:09 <TuringTest> > (\f -> (foldr (flip (foldr (:)).f) [])) (\x -> [2^x,3^x]) [1,2,3,4]
17:04:11 <lambdabot> [2,3,4,9,8,27,16,81]
17:04:32 <TuringTest> @pl (\f -> (foldr (flip (foldr (:)).f) [])) 
17:04:32 <lambdabot> flip foldr [] . (flip (foldr (:)) .)
17:06:31 <ihope> @pl foldr (:) []
17:06:31 <lambdabot> foldr (:) []
17:06:34 <TuringTest> I usually don't like @pl, but for concatMap it works well.
17:06:35 <ihope> Aww.
17:07:09 <ihope> > sequence [[(),()],[(),()]]
17:07:10 <lambdabot> [[(),()],[(),()],[(),()],[(),()]]
17:07:19 <ihope> > sequence [[(),()],[(),()],[(),()],[(),()]]
17:07:20 <lambdabot> [[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[()
17:07:20 <lambdabot> ,(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),
17:07:20 <lambdabot> (),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),()],[(),(),(),(
17:07:20 <lambdabot> )]]
17:07:32 <TuringTest> don't -- stop!
17:07:57 <greg> Is it possible to create a typeclass like Functor that has a function fmap that works for list, lists of lists, etc. ...
17:08:01 <greg> class Funct f where f_map :: (a -> b) -> f a -> f b
17:08:05 <greg> instance Funct [] where f_map = map
17:08:10 <greg> instance Funct a => Funct [a] where f_map f = map (f_map f)
17:08:17 <greg> ...or somesuch?
17:10:22 <ihope> Well, you got a kind mismatch there.
17:10:44 <ihope> [] would have to have the same kind as [a], which... well, it doesn't/
17:11:22 <ihope> Maybe you could try ListT.
17:11:25 <ihope> @index ListT
17:11:25 <lambdabot> Control.Monad.List, Control.Monad.List, Language.Haskell.TH.Syntax,
17:11:25 <lambdabot> Language.Haskell.TH
17:11:30 <greg> Right, I'm weak on my typeclass-fu.
17:11:38 <ihope> @kind Control.Monad.List.ListT
17:11:39 <lambdabot> (* -> *) -> * -> *
17:12:02 <ihope> ListT [] = list of list, I think
17:12:19 <ihope> @hoogle [m a] -> ListT m a
17:12:20 <lambdabot> No matches, try a more general search
17:12:30 <ihope> @hoogle [a] -> ListT b c
17:12:31 <lambdabot> Data.List.head :: [a] -> a
17:12:31 <lambdabot> Data.List.last :: [a] -> a
17:12:31 <lambdabot> Prelude.head :: [a] -> a
17:13:36 <ihope> Um.
17:13:43 <ihope> @hoogle ListT
17:13:44 <lambdabot> Control.Monad.List.ListT :: ListT m a
17:13:44 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
17:13:44 <lambdabot> Language.Haskell.TH.Lib.listT :: TypeQ
17:13:54 <ihope> Aha!
17:14:36 <ihope> So just apply Control.Monad.List.ListT to the list of lists, and I think fmap will work two "layers" in.
17:15:37 <greg> Does that generalize to lists of lists of lists...
17:15:44 <ihope> Um...
17:15:56 * ihope thinks
17:15:57 <greg> I'll probably have to start learning about ListT
17:16:11 <ihope> Possibly applying ListT multiple times.
17:16:23 <ihope> @type Control.Monad.List.ListT . Control.Monad.List.ListT
17:16:24 <lambdabot> forall a
17:16:24 <lambdabot>                      (m :: * -> *).
17:16:24 <lambdabot>                    m [[a]]
17:16:25 <lambdabot>                    -> Control.Monad.List.ListT (Control.Monad.List.ListT
17:16:27 <lambdabot> m)
17:16:29 <lambdabot>                             a
17:16:31 <ihope> Yes, it works.
17:17:25 <ihope> You'll want to put "import Control.Monad.List" somewhere, I think.
17:17:55 <ihope> Then you can use ListT instead of Control.Monad.List.ListT.
17:18:11 <ihope> To get a ListT thing back to a list, use (\(ListT x) -> x).
17:18:49 <Pseudonym> You should probably be aware that ListT isn't actually a true monad transformer.
17:19:02 <greg> But it probably won't seamlessly "Just Work" with fmap (+1) [[[[1,2,3]]]], right?
17:19:29 <ihope> Well, you'll have to do the ListT'ing, I think.
17:19:36 <Pseudonym> It doesn't preserve the order of lift operations correctly.
17:19:49 <ihope> And maybe LiftM instead of fmap.
17:20:01 <ihope> @index runListT
17:20:02 <lambdabot> Control.Monad.List
17:20:55 <ihope> So (runListT . runListT . runListT) (liftM (+1) ((ListT . ListT . ListT) [[[[1,2,3]]]])), I think.
17:21:05 <ihope> 'Tis ugly, but it should work.
17:22:50 <greg> Oh, I know I can get it to work, but typeclasses should provide me with an infinite family of "fmap"s to make it look pretty.
17:23:17 <greg> If only I was as smart as Oleg K.
17:24:04 <ihope> Maybe you can, like...
17:24:06 <ihope> Oh, yeah!
17:24:12 <ihope> Just apply fmap multiple times!
17:24:16 * ihope feels stupid
17:24:35 <ihope> > fmap (fmap (+1)) [[1,2,3],[4,5,6],[7,8,9]]
17:24:36 <lambdabot> [[2,3,4],[5,6,7],[8,9,10]]
17:27:25 <ihope> > (fmap . fmap . fmap . fmap) (+1) [[[[1,2,3]]]]
17:27:26 <lambdabot> [[[[2,3,4]]]]
17:31:18 <greg> Ignoring my previous Funct class for the moment, how do you make an instance of [[]] for Functor?
17:31:21 <greg> instance Functor [[]] where fmap
17:31:33 <greg> ...fails with a kind error.
17:31:36 <ihope> Well...
17:31:42 <ihope> type ListList a = [[a]]
17:31:48 <ihope> Make ListList a functor.
17:35:31 <greg> I must be screwing it up...
17:35:33 <greg> funct.hs:9:0:
17:35:37 <greg>     Type synonym `ListList' should have 1 argument, but has been given 0
17:35:41 <greg>     In the instance declaration for `Functor ListList'
17:35:48 <greg> Failed, modules loaded: none.
17:35:56 <ihope> Oh...
17:36:04 <ihope> newtype ListList a = ListList [[a]]
17:36:12 <ihope> Make *that* a Functor.
17:39:00 <greg> If I do that won't I need to write my own version of map that works with ListLists?
17:40:44 <ihope> Well, it should be pretty easy.
17:41:03 <ihope> fmap f (ListList x) = ListList (fmap (fmap f) x)
17:41:06 <ihope> That, I think.
17:48:35 <greg> Oh, well, dinner calls.  Thanks, though.
17:49:35 <ihope> Oh, how nice. REDIRECT ads.
17:59:13 <drakioned> moo
18:00:40 <Pseudonym> mu
18:01:03 <ihope> 
18:01:22 <drakioned> I think we should replace all the functions called foo with moo
18:01:32 <Pseudonym> @moo
18:01:33 <lambdabot> Maybe you meant: map more msg todo yow
18:01:42 <Pseudonym> Damn, who removed @moo?
18:02:18 <ihope> Moo and car?
18:02:31 <ihope> Moo, car, caz... pux!
18:03:07 <ihope> Wait a minute. Functor is to monad as foo is to moo, so...
18:03:27 <ihope> Nah.
18:03:47 <drakioned> > repeat "x"
18:03:49 <lambdabot> ["x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","
18:03:49 <lambdabot> x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x"
18:03:49 <lambdabot> ,"x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","
18:03:49 <lambdabot> x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x"
18:03:49 <lambdabot> ,"x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","
18:03:51 <lambdabot> [23 @more lines]
18:04:51 <drakioned> didn't it use to be like @eval?
18:05:00 <ihope> > cycle "x"
18:05:01 <lambdabot> "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
18:05:01 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
18:05:01 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
18:05:01 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
18:05:01 <lambdabot> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
18:05:03 <lambdabot> [23 @more lines]
18:05:16 <drakioned> @type cycle
18:05:17 <lambdabot> forall a. [a] -> [a]
18:05:30 <drakioned> what's the definition of cycle?
18:06:29 <ihope> concat . repeat
18:06:43 <ihope> > take 50 $ cycle "foobar"
18:06:45 <lambdabot> "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfo"
18:08:13 <drakioned> > everywhere (mkT toUpper) "test"
18:08:14 <lambdabot>  Not in scope: `mkT'
18:08:42 <ihope> @index mkT
18:08:42 <lambdabot> Data.Generics.Aliases, Data.Generics
18:08:45 <ihope> @index everywhere
18:08:46 <lambdabot> Data.Generics.Schemes, Data.Generics
18:09:01 <dons> ah ha!!
18:09:04 <dons> \unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
18:09:06 <lambdabot> *
18:09:06 <lambdabot> *
18:09:06 <lambdabot> **
18:09:06 <lambdabot> ***
18:09:06 <lambdabot> *****
18:09:08 <lambdabot> [156 @more lines]
18:09:12 <ihope> GASP@!
18:09:19 <ihope> > Data.Generics.everywhere (Data.Generics.mkT toUpper) "test"
18:09:20 <lambdabot>  Not in scope: `Data.Generics.mkT'
18:09:36 <ihope> @unlambda 
18:09:36 <lambdabot> unlambda: <stdin>: hGetChar: end of file
18:09:36 <lambdabot>  
18:09:39 <ihope> @unlambda `
18:09:39 <lambdabot> unlambda: <stdin>: hGetChar: end of file
18:09:39 <lambdabot>  
18:09:44 <ihope> @unlambda iii
18:09:48 <dons> ok, so maybe I should fix that.
18:09:56 <dons> iii doesn't do anything in unlambda
18:10:04 <ihope> I know.
18:10:06 <ihope> @unlambda ```sii``sii
18:10:17 <Excedrin> \ not @
18:10:33 <ihope> \unlambda ```sii``sii
18:10:38 <ihope> ;-)
18:10:43 <dons> so it should terminate at some point
18:10:46 <dons> it's got a cut off
18:10:51 <dons> (like @eval)
18:11:05 <ihope> \unlambda `````cccccc
18:11:05 <dons> hmm. but it doesn't seem to be working. weird...
18:11:19 <ihope> \unlambda ``````cccccc.n
18:11:19 <lambdabot> n
18:11:27 <dons> now, why isn't the posix rlimit kicking in.
18:11:44 <dons> \bot
18:11:45 <lambdabot> :)
18:11:51 <dons> ah, no output.
18:11:56 <dons> but also no message saying "Terminated"
18:12:23 <dons> so the cutoff is working fine
18:12:41 <dons> ihope, can you write a hello world one-liner?
18:13:02 * dons has come to the conclusion that this impure unlambda isn't as nice as the original lambda)
18:13:09 <ihope> > length ".H.e.l.l.o.,. .w.o.r.l.d.!"
18:13:10 <lambdabot> 26
18:13:27 <ihope> \unlambda ````````````.H.e.l.l.o.,. .w.o.r.l.d.!
18:13:28 <lambdabot> Hello, world
18:13:40 <ihope> \unlambda `````````````.H.e.l.l.o.,. .w.o.r.l.d.!
18:13:40 <lambdabot> unlambda: <stdin>: hGetChar: end of file
18:13:40 <lambdabot>  
18:13:45 <ihope> Hmm.
18:13:54 <ihope> Oh, right.
18:13:56 <ihope> \unlambda `````````````.H.e.l.l.o.,. .w.o.r.l.d.!i
18:13:56 <lambdabot> Hello, world!
18:14:18 <dons> cool
18:14:22 <dons> \karma+ ihope
18:14:23 <lambdabot> ihope's karma raised to 2.
18:14:59 <dons> Ii actually rewrote the unlambda interpreter in haskell for this plugin :)
18:15:04 <ihope> :-)
18:15:19 <ihope> I wrote an Unlambda interpreter in Haskell once... minus the c.
18:15:23 <ihope> It didn't work.
18:16:01 <dons> it's pretty short: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/Unlambda.hs
18:16:11 <dons> but the nice computation monad was already there
18:17:53 <ihope> What's with the ? ;-)
18:18:20 <dons> I can't read that unicode.
18:18:39 <ihope> rjan Johansen
18:18:57 <dons> ah. you mean 
18:20:06 <ihope> Yes, I do mean.
18:24:01 <ihope> Oh, was there supposed to be another character at the end of that line?
18:24:08 <ihope> <dons> ah. you mean 
18:24:21 <dons> i think your terminal is not speaking what mine is spekaing
18:24:30 <dons> I pasted a O with a / through it
18:24:34 <dons> but you see nothing
18:24:51 <dons> and yours looks to me like an A with a ~, and an X
18:25:24 <ihope> Yep. They be different.
18:25:25 <dons> the wonders of character encodings
18:25:31 <ihope> :-)
18:25:47 <ihope> Hey, at least most of them are ASCII-printable-compatible.
18:25:56 <ihope> If they weren't, then there'd be much oh noes.
18:30:43 <ihope> Oh, it's pi day.
18:30:49 <newsham> yup
18:31:05 <newsham> you missed 1:59:27 though
18:31:20 <ihope> Aww.
18:31:22 <ihope> @pi
18:31:23 <lambdabot> (line 1, column 1):
18:31:23 <lambdabot> unexpected end of input
18:31:23 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
18:31:23 <lambdabot> expression
18:31:28 * ihope laughs
18:33:53 <dons> \dynamic-reload unlambda
18:33:54 <lambdabot> dynamic module failed: unknown or static module
18:34:10 <dons> \dynamic-load unlambda
18:34:11 <lambdabot> module loaded
18:34:19 <dons> \unlambda ```sii``sii
18:34:29 <dons> \quit silly bot
18:34:42 <dons> \bot
18:34:59 <lambdabot> :)
18:35:03 <dons> \unlambda ```sii``sii
18:35:05 <lambdabot> Done.
18:35:10 <dons> \unlambda `
18:35:10 <ihope> !
18:35:11 <lambdabot> Done.
18:35:23 <ihope> \unlambda hehehe
18:35:23 <lambdabot> Done.
18:35:26 <dons> the timeout is kicking in, and we actually detect it
18:35:35 <dons> so failure now says "Done."
18:35:35 <ihope> \unlambda `.ki
18:35:36 <lambdabot> k
18:35:40 <dons> as does finishing with no output
18:35:47 <ihope> \unlambda i
18:35:47 <lambdabot> Done.
18:35:52 <ihope> Hmm.
18:35:53 <dons> I'm too lazy to distinguish failure and empty success :)
18:36:04 <ihope> :-)
18:36:05 <newsham> success is often empty
18:36:05 <dons> (actually, for some reasonn handling exit status didn't work)
18:36:18 <dons> \unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
18:36:20 <lambdabot> *
18:36:20 <lambdabot> *
18:36:20 <lambdabot> **
18:36:20 <lambdabot> ***
18:36:20 <lambdabot> *****
18:36:21 <lambdabot> [156 @more lines]
18:37:22 <ihope> So where's me Unlambda program that prints the lambdabot thingy that runs it?
18:37:39 <dons> you wnat a quine?
18:37:41 <newsham> @more
18:37:41 <lambdabot> ********
18:37:41 <lambdabot> *************
18:37:41 <lambdabot> *********************
18:37:41 <lambdabot> **********************************
18:37:41 <lambdabot> *******************************************************
18:37:43 <lambdabot> [151 @more lines]
18:37:48 <ihope> S.
18:38:30 <newsham> @more
18:38:31 <lambdabot> **************************************************************************
18:38:31 <lambdabot> ***************
18:38:31 <lambdabot> **************************************************************************
18:38:31 <lambdabot> **********************************************************************
18:38:31 <lambdabot> **************************************************************************
18:38:33 <lambdabot> [146 @more lines]
18:38:36 <sili_> :(
18:38:46 <ihope> @more
18:38:46 <lambdabot> **************************************************************************
18:38:46 <lambdabot> **************************************************************************
18:38:46 <lambdabot> ***********
18:38:46 <lambdabot> **************************************************************************
18:38:46 <lambdabot> **************************************************************************
18:38:48 <lambdabot> [141 @more lines]
18:38:52 <dons> please...
18:38:53 <dons> no need
18:39:10 <newsham> @nomore
18:39:10 <lambdabot> **************************************************************************
18:39:10 <lambdabot> **************************************************************************
18:39:10 <lambdabot> **************************************************************************
18:39:10 <lambdabot> *******
18:39:10 <lambdabot> **************************************************************************
18:39:12 <lambdabot> [136 @more lines]
18:39:22 * ihope goes bang bang bang
18:39:26 <newsham> sorry, i asked it not to
18:46:02 <Pseudonym> \unlambda .*
18:46:03 <lambdabot> Done.
18:47:59 <Pseudonym> \unlambda .*i
18:48:00 <lambdabot> Done.
18:55:18 <dons> \unlambda `.*i
18:55:19 <lambdabot> *
18:55:36 <dons> silly explict application. unlambda is very unhaskelish :)
18:55:51 <Pseudonym> yeah.
18:58:26 <Pseudonym> \unlambda `.a`.bi
18:58:27 <lambdabot> ba
18:58:31 <Pseudonym> Hmmm.
18:59:46 <dons> \unlambda ``.b.ai
18:59:47 <lambdabot> ba
19:14:32 <Pseudonym> \unlambda ````s``si`k`k.1`k.0`kii
19:14:33 <lambdabot> 0
19:14:50 <Pseudonym> \unlambda ````s``si`k`k.1`k.0ii
19:14:51 <lambdabot> 1
19:14:53 <Pseudonym> Got it.
19:18:30 <palomer> what's ` ?
19:20:32 <palomer> ho hum
19:20:35 <palomer> system F is very neat
19:21:18 <dons> ` is application
19:21:30 <dons> ` e1 e2
19:21:36 <dons> ugly, eh?
19:22:21 <palomer> very
19:22:41 <palomer> so ` is a node
19:22:48 <palomer> or, rather, creates a node
19:22:57 <palomer> with 2 branches
19:24:09 <Pseudonym> \unlambda ````s``si`k.0`k`k.1ki
19:24:10 <lambdabot> 0
19:24:21 <Pseudonym> \unlambda ````s``si`k.0`k`k.1```s`kk``s`k`sikki
19:24:23 <lambdabot> 1
19:27:15 <palomer> jot is especially nice
19:45:06 <Pseudonym> \unlambda `````s``s`ks``s`kk```s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`ki``s`k`s`kk``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sik`k``s``s`ks``s`k`s`ks`s`kk`k`k``s``si`kk`k`k``si`kkk`k``s``si`k.0`k`k.1i
19:45:08 <lambdabot> Done.
19:47:34 <dons> maybe the timeout is too low
19:47:48 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1i
19:47:49 <lambdabot> Done.
19:47:55 <Pseudonym> No, it's a bug in my program.
19:48:11 <Pseudonym> I'm probably assuming lazy evaluation somewhere.
19:48:59 <dons> ah :)
19:49:51 <dons> I think it might be a syntax error, unlambda: <stdin>: hGetChar: end of file
19:50:01 <dons> which iis a parse failure, I think
19:50:07 <palomer> lambdabot is great because it gets us to put those fun little algorithms we write to good use
19:50:22 <dons> true!
19:50:30 <palomer> instead of simply discarding them
19:50:34 <palomer> which I've done many, many times
19:50:47 <palomer> god, I'm changing my speech/chat patterns
19:51:03 <palomer> The disadvantage of spending lots of time with a person
19:51:04 <Saulzar> He already knew
19:51:59 <palomer> there's one thing I don't understand about system F
19:52:41 <palomer> if you only allow big lambdas at let bindings, and only for those variables not in the context, then how do  you figure out what types to apply (since it should be decidable)
19:53:10 <palomer> ie, how do you go from standard HM to system F?
19:53:12 <palomer> what's the morphism
19:54:08 <Pseudonym> \unlambda ```s``s``s`ksk`k``sii``s``s`ksk`k``siii
19:54:09 <lambdabot> Done.
19:54:34 <palomer> is there a reason why we don't merge case and lambda together?
19:54:52 <palomer> ie, have something of the sort \{0->1;1->2}
19:55:15 <Pseudonym> \unlambda ````s``si`k.0`k`k.1ki
19:55:16 <lambdabot> 0
19:55:30 <Pseudonym> ````s``si`k.0`k`k.1`k``si`kki
19:55:36 <Pseudonym> \unlambda ````s``si`k.0`k`k.1`k``si`kki
19:55:37 <lambdabot> 1
19:55:45 <palomer> case x of {0 -> 1 ; 1 ->2} would turn into \{0->1;1->2} x
20:03:02 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1i
20:03:04 <lambdabot> Done.
20:03:21 <Pseudonym> There must be something wrong with my recursive part.
20:05:15 <palomer> unlambda evaluates?
20:06:39 <dons> Pseudonym, it's a parser error. the parser is expecting another char in there somewhere
20:06:45 <dons> i'm fixing the error message to make that clear
20:06:54 <dons> palomer, of course
20:07:27 <Pseudonym> Ah, OK.
20:08:19 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1i
20:08:21 <lambdabot> Done.
20:08:26 <Pseudonym> Right.
20:09:44 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1ii
20:09:45 <lambdabot> Done.
20:09:48 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1iii
20:09:50 <lambdabot> Done.
20:10:51 <dons> ah, now that I think is timing out.
20:11:16 <dons> yep. it runs to completion, no output
20:11:28 <Pseudonym> No output?
20:11:30 <Pseudonym> Hmmm.
20:11:34 <Pseudonym> It should output either 0 or 1.
20:11:37 <dons> but the timeout currently icks in just before then.
20:11:54 <dons> why? I see no output calls or constants
20:12:12 <Pseudonym> Right near the end there's a .0 and a .1.
20:12:27 <dons> oh, hmm. maybe it's chopped off my screen
20:12:35 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1i
20:12:36 <lambdabot> Done.
20:12:51 <dons> i'll up the timeout to see what happens
20:12:56 <Pseudonym> Thanks.
20:13:55 <dons> \dynamic-reload unlambda
20:13:56 <lambdabot> module reloaded
20:13:59 <dons> try that
20:14:02 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1iii
20:14:07 <lambdabot> Done.
20:14:08 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k.0`k`k.1i
20:14:14 <lambdabot> Done.
20:14:17 <Pseudonym> Hrm.
20:14:21 <dons> hmm. 
20:14:44 <Pseudonym> Oh!
20:14:46 <Pseudonym> D'oh!
20:14:55 <dons> ok, why not grab http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/Unlambda.hs ?
20:15:57 <dons> unless you see why (I don't think the timeout was kicking in -- i upped it to 5 seconds)
20:16:12 <Pseudonym> I thought I spotted a bug.
20:16:15 <Pseudonym> Turns out it was fine.
20:17:19 <dons> oh, i see now . i'ts really long and my client was chopping :)
20:17:27 <Pseudonym> :-)
20:19:03 <dons> ah, it may still be the timeout. it's running for 20 seconds now, (and 100M heap) on my box.
20:19:18 <dons> ok, 30 seconds is too short
20:19:23 <dons> you suure this thing terminates?
20:19:43 <Pseudonym> No, I'm not.
20:19:45 <Pseudonym> I mean it SHOULD.
20:19:53 <Pseudonym> It certainly would in haskell.
20:20:11 <Pseudonym> But there may be a missing delay because I'm assuming normal order evaluation.
20:21:47 <dons> ok, well: unlambda: out of memory (requested 1048576 bytes)
20:21:49 <dons> :)
20:22:00 <Pseudonym> It shouldn't take that long.
20:22:15 <dons> after a minute or so. so I guess something's up
20:24:36 <dons> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`
20:24:37 <lambdabot> unlambda: Parse error at end of file
20:24:42 <dons> shgood
20:25:26 <adu> is that a good thing?
20:25:35 <araujo> hello
20:25:43 <adu> hi
20:27:07 <araujo> dons!
20:27:10 <araujo> hello adu 
20:27:18 <adu> how are you araujo ?
20:28:00 <Pseudonym> \unlambda ````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s``s`ksk`k.*i
20:28:05 <lambdabot> Done.
20:28:46 <araujo> adu, very well thanks, yourself?
20:28:48 <adu> what exactly does that do?
20:29:04 <Pseudonym> \unlambda ````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s``s`ksk`k``s`kr.*i
20:29:06 * araujo hacking night
20:29:10 <lambdabot> Done.
20:29:16 <Pseudonym> `ri
20:29:19 <adu> araujo : just got back home from class and I'm trying to figure out what Monads and Arrows have in common
20:29:22 <Pseudonym> \unlambda `ri
20:31:21 <Pseudonym> \unlambda ```s`kr.*i
20:31:21 <lambdabot> *
20:32:22 <Pseudonym> \unlambda `r`.1`r`.0i
20:32:22 <lambdabot> 0
20:32:22 <lambdabot> 1
20:38:02 <jgrimes> why would this: http://haskell.pastebin.com/602973 give me a type error?
20:39:53 <jgrimes> nevermind
20:44:41 <Lemmih> Heh. -: :- looks neat.
20:46:19 <Lemmih> > let (-!) = flip ($); (!-) = ($) in [1,2,3] -! zipWith (+) !- [4,5,6]
20:46:20 <lambdabot> [5,7,9]
20:46:37 <Pseudonym> \unlambda ``````s``s``s`ksk`k``sii``s``s`ksk`k``sii``s`k`s``s`ks``s``s`ksk`k``s``si`kk`kk``s`kk``s`k`s``s`ks``s`k`si``s`kk``s``si`kk`k`k``si`kk``s`k`s`kk``s`k`s`k`s`kd``s``s`ks``s`kks`k``s`kk``s``s`ksk`k``s`kk``s`k`sikk`k``s``si`k`d.0`k`d`k.1i
20:46:43 <lambdabot> Done.
20:46:49 <Pseudonym> I give up.
20:47:02 <gzl> Lemmih: heh, that's kind of nice.
20:47:37 <dons> Pseudonym, I'll see if it runs in one of the other unlambda impls.
20:48:50 <Cale> jgrimes: sounds like you figured it out -- it's just precedence, functions bind more tightly to their parameters than anything else.
20:51:05 <jgrimes> Cale, yeah, I thought about that as soon as I pasted it
20:51:21 <jgrimes> I was like... I just read about the precedence of functions
20:52:04 <jgrimes> Cale, thanks though :D
20:52:11 <Cale> :)
20:53:15 <dons> Pseudonym, ok, it also has a big space leak in the C interpreter for unlambda -- so i don't think it's my fault :)
21:05:25 <adu> lol
21:05:39 <adu> 'Nothing' represents a failure
21:10:17 <adu> wow
21:26:43 <dons> adu?
21:27:17 <adu> I'm reading about Haskell
21:27:34 <adu> i have sooooooooooo much respect for Haskell :)
21:27:45 <dons> hehe
21:28:27 <adu> no matter how hard it is to learn the cool stuff, its there, and its worth it
21:29:49 <araujo> @yay!
21:29:50 <lambdabot> Unknown command, try @listcommands.
21:29:53 <sieni> adu: read through either a) 3rd ed. of Stroustrup's C++ book, b) the C++ standard or c) both. I promise you'll have much more respect for Haskell after that experience (if you are mentally sane afterwards, that is)
21:30:41 <adu> sieni: i know enough about C++ to know that I don't know C++
21:30:52 <araujo> sieni, you know what they say... Haskell is a very bad, it makes you hate other languages ;-)
21:31:00 <adu> lol
21:31:28 <sieni> araujo: well, haskell hasn't made me hata 
21:31:30 <sieni> vittu
21:31:59 <sieni> araujo: well, haskell hasn't made me hate Scheme or Standard ML. And Clean sounds very nice as well.
21:33:18 <araujo> Ive not tried Clean, though i got nothing against scheme or ml, i don't feel like... getting back to those :-]
21:33:49 <Pseudonym> \unlambda ``````s``s``s`d`ks``s`d`kdk`d`k``sii``s``s`d`ks``s`d`kdk`d`k``sii``s`d`k`s``s`d`ks``s``s`d`ks``s`d`kdk`d`k``s``si`d`kk`d`kk``s`d`kd``s`d`kk``s`d`k`s``s`d`ks``s`d`k`si``s`d`kd``s`d`kk``s``si`d`kk`d`k`k``si`kk``s`d`k`s`d`kd``s`d`k`s`d`kk``s`d`k`s`d`k`s`d`kd``s``s`d`ks``s`d`kd``s`d`kks`d`k``s`d`kd``s`d`kk``s``s`d`ks``s`d`kdk`d`k``s`d`kk``s`d`k`sikk`d`k``s``si`d`k`d.0`d`k`d`k.1i
21:33:55 <lambdabot> Done.
21:34:04 <adu> what is this unlambda thing?
21:34:14 <Pseudonym> http://www.madore.org/~david/programs/unlambda/
21:34:50 <dons> Pseudonym, does it work running it locally?
21:35:25 <dons> \where+ unlambda http://www.madore.org/~david/programs/unlambda/
21:35:26 <lambdabot> Done.
21:35:45 <Pseudonym> Errr...
21:35:47 <Pseudonym> Ah.
21:35:56 <dons> :)
21:35:59 <dons> overloadig
21:36:02 <araujo> esoteric language?
21:36:39 <sieni> araujo: (about Clean) I would like to at least understand their solution to the IO problem in the context of purely functional languages (uniqueness types), which is different from Haskell's solution (monads)
21:36:39 <dons> nah it's jst ski combinators, plus added side effects and impurity :) it makes me feel a bit dirty
21:38:23 <adu> oh ic its an obfuscated language
21:38:29 <adu> that makes sense now
21:38:49 <adu> my favorite obfuscated programming language is Funge-98
21:38:54 <Pseudonym> It's the dirtiness which makes it difficult to work with.
21:39:03 <adu> you can actually get stuff done in it
21:39:27 <dons> yeah, a pure unlambda would be nicer
21:39:31 <adu> i actually worked on a Funge-98 IDE once
21:39:35 <dons> ski and >>= :)
21:39:52 <Lemmih> Heh. I so love refactoring. Using -fno-code together with --make suddenly started to work after hsc got restructured.
21:40:03 <dons> umm. scary
21:40:23 <dons> just by cleaing up the interfaces? good :)
21:40:55 <sieni> -fno-code? what is that?
21:41:09 <dons> don't produce code. 
21:41:24 <dons> just type check and desugar (and optimise?)
21:41:28 <dons> yes. and optimise
21:41:46 <sieni> ahh
21:41:49 <Lemmih> Yep. Need the optimized cmm, stg and core.
21:41:54 <araujo> sieni, at least to understand its solution, too complicated?
21:42:21 <Lemmih> But no pesky .hi files.
21:42:33 <sieni> araujo: how's that? monads are not that easy for the uninitiated either
21:42:58 <araujo> sieni, i don't know Clean, that's why i ask you :-)
21:42:58 <Lemmih> dons: But '--make -fno-code' still doesn't work (:
21:45:44 <adu> \unlambda .H
21:45:44 <lambdabot> Done.
21:45:59 <adu> \unlambda .H.I
21:45:59 <lambdabot> Done.
21:46:31 <sieni> araujo: neither do I, but the approach is different from Haskell (and sounds interesting).
21:47:18 <Pseudonym> OK, I think it having working locally now.
21:47:19 <Pseudonym> Kind of.
21:47:51 <adu> why doesn't it output anything?
21:48:17 <Pseudonym> \unlambda `.H`.Ii
21:48:17 <lambdabot> IH
21:48:48 <adu> oh
21:49:23 <adu> so characters are functions?
21:49:40 <Pseudonym> My problem seems to be the way I'm doing recursion using fixpoint combinator.
21:56:05 <adu> \unlambda ``.H.Ii
21:56:05 <lambdabot> HI
21:56:27 <adu> `.H.I
21:56:32 <adu> \lambda `.H.I
21:56:33 <lambdabot> (line 1, column 1):
21:56:33 <lambdabot> unexpected "`"
21:56:33 <lambdabot> expecting white space or simple term
21:56:46 <adu> \unlambda `.H.I
21:56:47 <lambdabot> H
21:57:05 <dons> there's a difference between \lambda and \unlambda :)
21:57:26 <adu> ya sorry i was typing-under-the-influence
21:57:34 <dons> \unlambda ``.H.ii
21:57:34 <lambdabot> Hi
21:58:24 <adu> \unlambda ````````````.H.e.l.l.o.,. .W.o.r.l.d.!i
21:58:25 <lambdabot> Hello, World
21:58:32 <adu> \unlambda `````````````.H.e.l.l.o.,. .W.o.r.l.d.!i
21:58:32 <lambdabot> Hello, World!
21:58:37 <adu> yey!
21:59:39 <sieni> lambadabot should have a befunge interpreter as well
22:00:08 <adu> sirni: i would perfer Funge-98
22:01:09 <adu> i believe funge98 is a superset of befunge anyways
22:01:49 <palomer> ok
22:01:58 <palomer> someone explain to me how to go from ml to system F
22:14:11 * palomer waits for an explanation
22:14:14 <palomer> where's ski when you need'em
22:32:43 <adu> wow
22:33:31 <adu> i think i understand call/cc now
23:02:10 <Lokadin> say if i want to run a function with arguments as the argument of another function how would i denote that? with quotations?
23:02:37 <Lokadin> function1 "function2 optionForfunction2"
23:02:38 <Lokadin> ?
23:02:52 <Lokadin> is say function2 returns a string?
23:05:49 <sieni> Lokadin: what do you mean? Most often you don't have to denote anything
23:06:53 <Lokadin> sieni: oh yea? well i'll try it as it is and see what happens' i shouldn't really be asking before it doesn't work anyways :$
23:07:15 <sieni> > ((\f -> \a b c -> f a b c) (\x y z -> x + y * z)) 1 2 3
23:07:17 <lambdabot> 7
23:08:23 <sieni> or 
23:08:25 <sieni> > let foo f = \a b c -> f a b c in let bar x y z = x + y * z in foo bar 1 2 3
23:08:26 <lambdabot> 7
23:08:46 <Lokadin> why is there a \ infront of the a?
23:09:03 <sieni> \ is lambda
23:09:20 <Lokadin> o
23:09:26 <sieni> it allows you to define an unnamed function
23:09:35 <sieni> e.g.
23:09:50 <sieni> > (\x y -> x + y) 1 2
23:09:51 <lambdabot> 3
23:09:56 <sieni> instead of
23:10:05 <sieni> > let foo x y = x + y in foo 1 2
23:10:07 <lambdabot> 3
23:10:22 <Lokadin> o
23:10:24 <Lokadin> cool
23:10:35 <Lokadin> i never really got that before thanks :D
23:11:38 <sieni> It's kind of central to functional programming languages, since they are based on the lambda calculus ;-)
23:12:11 <Lokadin> :)
23:18:36 <Lokadin> say could you explain the \h part in
23:18:37 <Lokadin> bracket (openFile filename ReadMode) hClose 
23:18:37 <Lokadin>            (\h -> do contents <- hGetContents h
23:18:39 <Lokadin> 	             putStrLn contents))
23:19:06 <Lokadin> so i understand the part after do
23:19:12 <Lokadin> but what is the \h there for?
23:19:23 <Lokadin> i mean can't we just not bother with it?
23:19:34 <sethk> Lokadin, no, the compiler needs it
23:19:40 <sethk> Lokadin, it has a value to put into h
23:19:54 <sethk> Lokadin, or whatever name you use, of course, it doesn't have to be any particular name
23:20:15 <Lokadin> kk,
23:20:57 <sethk> Lokadin, you used the h in hGetContents h, so you need it also, not just the compiler
23:21:16 <Lokadin> yea, i was thinking that
23:21:43 <Lokadin> hmmm
23:22:02 <Lokadin> okay, well i think i understand it well enough to use it, i'm sure it will dawn on my sometime
23:24:53 <Lokadin> could i do something like
23:25:05 <Lokadin> return (\x <- getLine)
23:25:06 <Lokadin> ?
23:26:04 <Lokadin> if i want it to return with the getLine and all...
23:26:50 <Lokadin> or would i simply use return getLine 
23:26:51 <Lokadin> ?
