00:26:36 <shapr> I didn't do it!
00:27:00 * shapr jerks awake after a nightmare of living in a world of imperative programming...
00:28:50 <bolrod> wow
00:29:10 <bolrod> sounds like you had an awfull time
00:29:21 <dons> poor shapr !
00:29:39 <dons> a disastrous, evil world
00:33:51 <ProfTeggy> Here, shapr, take this antidote:  f x == f y <=> x = y  ... a little dose of referential transparency might just help
00:33:54 <cm> a stateful world
00:33:57 <shapr> mmm
00:34:55 <ProfTeggy> err, x == y => f x == f y
00:35:39 <dons> just the right prescription :)
00:35:46 <shapr> dons: What about a Health Entry that uses Dybvig's monadic framework for subcontinuations? Like, with Oleg's cursors?
00:36:31 <dons> ah, more on this health problem. TuringTest has started on that, but I'm not sure it is going to be accepted for the shootout  proper yet.
00:36:55 <shapr> He started with Oleg's subcontinuation cursors?
00:37:22 <dons> no, on the health problem :) it's on the wiki now
00:37:35 <cm> dons, are there win32 binaries of hs-plugins?
00:38:04 <dons> binaries? no. it's definitely build-it-yourself. but it has been done for win32, using the `mingw' system
00:38:21 <cm> ah :(
00:38:27 <ncalexan> dons: is hs-plugins supposed to work on Mac OS X?  Last build I tried built, but failed every test.
00:38:53 <dons> something has broken in the linker on mac os x, since 6.4.1,  i think
00:39:10 <ncalexan> Yeah.  Any hints?
00:39:12 <dons> wolfgang changed the code generator there quite a bit, and it doesn't work atm :(
00:39:30 <ProfTeggy> ncalexan, do you get unresolved symbols during linking?
00:39:41 <ncalexan> It's closely tied to the GHC RTS, yes?
00:40:06 <dons> yeah, it'll appear as unresolved symbols, I think.
00:40:11 <dons> yes, very closely tied to the code generator, and changess in the runtime linker.
00:40:20 <ProfTeggy> hmm
00:40:54 <ncalexan> Yes, for example:
00:40:55 <ncalexan> a.out: 
00:40:55 <ncalexan> unknown symbol `___stginit_SystemziCmd_'
00:40:55 <ncalexan> a.out: user error (resolvedObjs failed.)
00:40:55 <ProfTeggy> I'm on Mac OS X too and saw unexpected linker failures with ghc 6.4
00:41:07 <ncalexan> That from testsuite/eval/eval1.
00:41:10 <dons> but ... ghci still works on this arch, should it should be possible to fix 
00:41:17 <ProfTeggy> hmm, maybe the name mangling changed
00:41:17 <dons> hmm, _3_ underscores?
00:41:22 <dons> yes.
00:41:26 <ncalexan> Yes.
00:41:29 <ncalexan> 3 underscores.
00:41:50 <ncalexan> The OSX linker is weird like that; it often complains about missing _main.
00:41:50 <dons> seems a bit odd. if the symbol is at all different to what hs-plugins expects, it won't find it.
00:43:01 <dons> ok. i'll note this down officially, and have a look soon. (i have access to a mac) 
00:43:41 <dons> one thing would be to build a debug version of hs-plugins, and then try to load  a module. then compare the output against the actual symbols in the `nm' list of the object
00:44:10 <ProfTeggy> Cheers, dons
00:44:32 <ncalexan> Cheers indeed.  Anyway, it's my bed time... g'night, all.
00:44:36 <dons> so _two_ people are complaining :) i really need to fix it :)
00:44:44 <ProfTeggy> *grin*
00:44:55 * ProfTeggy h-5's ncalexan
00:45:01 <ProfTeggy> A bunch makes a difference
00:47:20 <dons> hehe :)
00:50:37 <shapr> skew_: opitko Haskellia?
00:52:50 <vincenz> hi
00:53:05 <shapr> Sure, tease me..
00:53:08 <shapr> say hi and then disappear.
00:54:00 <vincenz> Hmm
00:54:21 <vincenz> Everytime I open a new screen it complains can't open /var/run/utmp, have to dig too hard
00:55:52 <shapr> sili: opitko Haskellia?
00:56:42 * vincenz tries rebooting
00:58:23 <tuomov> Ei oppi ojaan kaada.
00:58:42 <tuomov> Paitsi ehkä irc-oppi :).
00:59:51 <goltrpoat> why does finnish have to be one of those weird languages with no freaking resemblance to anything else out there.
01:00:06 <goltrpoat> i remember trying to learn it back when i was 18 or so, that didn't go very well at all.
01:00:18 <michie1> except to Latvian and Hungarian, iirc
01:00:26 <tuomov> estonian and hungarian
01:00:28 <goltrpoat> yah and estonian etc.
01:00:31 <tuomov> but hungarian is quite far
01:00:35 <tuomov> estonian is very close
01:00:40 <goltrpoat> very fleeting resemblance though.
01:00:41 <goltrpoat> yeah
01:00:45 <tuomov> latvian is not in the same family
01:01:15 <tuomov> then there are some minority languages around scandinavia and russia
01:01:23 <goltrpoat> ive been to estonia, i was 5 or 6 at the time, and i sort of remember saying stuff in estonian, but i don't remember any of that now.
01:02:23 <goltrpoat> tuomov:  there are minority ugoro-finnish languages in russia?  i didn't know that.
01:02:48 <neologism> samoyed language family, karelians etc.
01:02:52 <neologism> plenty of them
01:03:01 <goltrpoat> oh karelians, right.
01:03:07 <neologism> there's even something in romania (relatives to hungarians)
01:03:17 <tuomov> Anyway, "Ei oppi ojaan kaada" is a proverb literally translating as "Education (oppi) doesn't known one over in a ditch." and "Paitsi ehkä irc-oppi" means "Except perhaps an irc-op (oppi, from english)"
01:03:26 <goltrpoat> although i thought they spoke something germanic/lapp
01:03:27 <tuomov> s/known/knock/
01:03:57 <goltrpoat> although i think lapp is politically incorrect these days.
01:04:20 <goltrpoat> although i should probably stop saying although.
01:04:29 <shapr> tuomov: Doesn't known one over in a ditch? I don't understand.
01:04:35 <tuomov> shapr: knock
01:04:54 <shapr> oh
01:05:01 <tuomov> I think there's a better word for that, though
01:05:24 <shapr> Sort of like, education doesn't come and find you, you have to find it yourself?
01:05:44 <tuomov> no, more like, education doesn't harm you
01:05:49 <shapr> oh, heh
01:06:17 <tuomov> So, education (oppi) doesn't harm you, except perhaps an irc-op (irc-oppi).
01:06:30 <shapr> Though we could argue about 'koulutus'.
01:06:32 <michie1> And this is an old finnish proverb?
01:06:35 <goltrpoat> i just realized that quite literally the only finnish i remember is haista vittu.
01:06:38 <goltrpoat> which is rather sad.
01:06:45 <tuomov> michie1: the first part :)
01:07:16 <tuomov> and literally it is about education knocking one over in a ditch
01:07:17 <shapr> goltrpoat: I shall educate you with my tiny rememberings... "Minä olen amerikalainen." and "Minä haluan hampurilaisen."
01:07:19 <goltrpoat> oh wait.. there was also haista paska.
01:07:30 <neologism> paska = shit?
01:07:31 <tuomov> goltrpoat: that gets you far :)
01:07:36 <tuomov> yep
01:07:37 <goltrpoat> shapr:  yah i understand that
01:08:01 <shapr> michie1: Hey, are you new here? Or just a different nick?
01:08:02 <goltrpoat> ok maybe i remember a little bit more than i thought, heh.
01:08:06 <tuomov> you just need 'perkele' (with a very strong 'r') and you can manage most everyday conversation :)
01:08:11 <goltrpoat> haha
01:08:13 <goltrpoat> yes
01:08:16 <michie1> shapr: I've been here before, but mostly new :)
01:08:39 <shapr> Greetings and welcome to a crazy place of learning and exploration.
01:08:53 <goltrpoat> hahah
01:08:57 <goltrpoat> excellent.
01:08:58 <michie1> thank you :)
01:08:59 <shapr> If you're not familiar with Haskell, I can give you a quick tour of #haskell and Haskell.
01:09:00 <skew_> the stress in that sentence rotates
01:09:12 <goltrpoat> sharp:  in broken finnish, at that!
01:09:21 <goltrpoat> i'll help.
01:09:25 * shapr grins
01:10:00 <skew_> I'm working on some crazy at the moment, shapr is imparting learning, bring your own exploration :)
01:10:01 <shapr> michie1: If you have any questions about Haskell, type theory, or other common subjects here (Unicycling, Finnish, etc) we're happy to help.
01:10:09 * shapr laughs
01:10:12 <michie1> shapr: I programmed a little in it four years ago, I've been meaning to get back into it a little, thought I'd hang out here :)
01:10:58 <shapr> skew_: Anything crazy that you can talk about?
01:11:46 <shapr> michie1: Cool, this is definitely the place to chat about Haskell and soak up interesting ideas.
01:12:18 <tuomov> hmm.. I wonder if "aphorism" is actually the right term for the earlier, not "proverb"
01:12:27 <shapr> @wn aphorism
01:12:29 <lambdabot> *** "aphorism" wn "WordNet (r) 2.0"
01:12:29 <lambdabot> aphorism
01:12:29 <lambdabot>   n : a short pithy instructive saying [syn: {apothegm}, {apophthegm}]
01:12:41 <shapr> Looks like it.
01:13:01 <shapr> Seems like the two often overlap though.
01:13:23 <skew_> I'm making a little language with brackets that paramaterize an expression on free variables, and others that fill in those parameters from the current lexical environment
01:14:21 <shapr> Sounds like one of those Aardappel languages.
01:14:31 <shapr> Have you seen his upated site?
01:14:44 <skew_> not very recently
01:15:02 <tuomov> hmm.. the finnish wikipedia defines an aphorism as the literary counterpart of the proverb of folklore
01:22:30 <nothingmuch> i read that "n: a port shitty instructive saying"
01:25:15 <shapr> skew_: Found anything new or nifty lately?
01:28:50 <kosmikus> morning
01:29:25 <shapr> hiya kosmikus, how's code?
01:29:44 <kosmikus> code's better than work ;)
01:29:58 * shapr grins
01:30:13 <kosmikus> I guess you've seen that I released lhs2tex in the night.
01:30:30 <skew_> Hutton's work on interpereters is pretty interesting
01:30:33 <kosmikus> a new version, that is
01:30:52 <skew_> building stack machines from a denotational semantics by equational reasoning
01:31:01 <skew_> and CPS and defunctionalization
01:31:34 <ProfTeggy> kosmikus, what's the hightlight of this release?   Morning, btw. :)
01:31:56 <skew_> UI research from eric horvitz at microsoft
01:33:34 <kosmikus> ProfTeggy: it's the first official release since 1.9, which was ages ago
01:34:58 <kosmikus> ProfTeggy: the release announcement covers a few of the changes. nothing really spectacular, but all in all, quite a lot. there are almost no changes w.r.t. the 1.11pre4 release candidate which was available for the last month.
01:35:10 <ProfTeggy> Aha, OK.  Thank you.
01:35:15 <shapr> skew_: Do you have a blog?
01:35:46 <skew_> no
01:36:06 <shapr> ok
01:37:32 <shapr> skew: Are you talking about Hutton's articles like "What is the meaning of these constant interruptions?" 
01:37:46 <skew> yeah, or "calculating an exceptional machine"
01:38:16 <skew> Another thing I tried is typing a C-like grammar in backwards and running it through Happy --glr
01:38:32 <shapr> Oh that is neat. I've only heard about defunctionalization, I don't know anything about it.
01:39:08 <skew> it worked surprisingly well - the ususal if-then/else thing turned into two reduce/reduce conflicts, but otherwise things worked out
01:39:24 <shapr> That's a cool trick. You mind if I mention this stuff on my blog?
01:39:35 <skew> I'm thinking this might be useful for an IDE that actually keeps a parse of code
01:39:51 <skew> sure, might as well pass it around
01:39:53 <shapr> ok
01:44:10 <musasabi> Is it possible to implement modifyMVar in a safe manner without using block ?
02:03:18 <eivuokko> Isn't it impossible to implement just about anything exception safe without block?
02:05:28 <kosmikus> er, I want to create a ghc ticket, so I registered with trac. but now it tells me I have to login with guest/guest instead?
02:06:30 <shapr> kosmikus: Get one of the trac admins to approve you?
02:06:45 <shapr> I think Isaac or the Simons are the people to talk to.
02:06:52 <kosmikus> hm, I see.
02:07:11 <kosmikus> but isn't it strange that guests may create tickets, whereas newly created users may not?
02:07:32 <shapr> That is odd.
02:07:41 <shapr> I thought it was the other way around?
02:08:23 <eivuokko> It probably got something to do with trac's authentication wscheme, which has been lacking in past iirc. (it used http auth)
02:09:33 <shapr> Yeah, I gave up and just used a totally open trac and put my name in when I enter tickets.
02:19:02 <shapr> hugues23: Advanced Functional Programming dot com?
02:26:00 <hugues23> shapr: would like, but just Agence France Presse ;-)
02:45:20 <intero> hello
02:48:06 <intero> haskelldb fails on debian-amd64, with a lot of errors like: " undefined reference to `stg_ap_p_ret' ", as shown here: http://amd64.ftbfs.de/fetch.php?&pkg=ghc6&ver=6.4.1-2&arch=amd64&stamp=1141531193&file=log&as=raw
02:48:54 <intero> i have been googling for stg_ap_p_ret function, but i didn't really find much about it. is it part of ghc6?
02:49:12 <intero> if you have any clue, any hint is welcome of course :)
02:56:20 <shapr> Greetings intero, I'd suggest you ask on the HaskellDB mailing list.
02:56:34 <shapr> In essence, mail Björn Bringert, he's the expert.
02:56:53 <shapr> It sounds like a GHC problem though.
02:57:07 <shapr> intero: Alternatively, ask on the ghc-users list.
02:57:13 <shapr> That might get a faster and more detailed response.
02:57:22 <intero> thanks shapr!
02:57:41 <shapr> Sure, if you have any other questions, feel free to ask here.
02:57:44 <eivuokko> ghc-users sounds more likely, yeah.
02:58:19 <shapr> hei eivuokko, would you switch to Daan's darcs-server if the server side chunk were Haskell?
02:58:25 <intero> it's something i have never heard of, and was asked to check it out... so basically i need some instructions :)
02:58:37 <shapr> Who asked you to check out HaskellDB?
02:58:51 <shapr> I admit, it's the coolest database thingy ever, but most people haven't heard of it.
02:59:00 <shapr> Have you seen the tutorial on the wiki?
02:59:29 <shapr> I still have my curryspondence code around here somewhere if you need something to get you started with HaskellDB.
02:59:45 <eivuokko> shapr, I don't know.  Most likely not, because I already conviently use my system...maybe on next time around.
02:59:57 * shapr tries to figure out how to do pattern matching in Python.
03:00:23 <shapr> eivuokko: Ok, just trying to centralize darcs-cgi-push efforts...
03:00:23 <eivuokko> It also seems that Daan's system requires per-repo configuguration on client-side (for gpg), which is a bit unacceptable
03:01:04 <shapr> Could you come up with a list of things that would make Daan's solution acceptable to you?
03:01:18 <eivuokko> Uhm
03:01:25 <shapr> They call me Mach Daddy. (Machiavelli ;-)
03:01:25 <eivuokko> I'd ned to try it first
03:02:18 <eivuokko> shapr, imo it is not worth it.  There was a patch on darcs-devel to add http-push (very much like I did) into darcs using libcurl or external curl (and wget would be easy)...noe response
03:02:20 <shapr> Well, if you get the urge/time, I want a single best solution to push encrypted patches to darcs via http.
03:02:31 <shapr> I'll get you a response =)
03:02:49 <eivuokko> If that patch went in, I'd write server side in python
03:02:56 <eivuokko> (I prefer python over perl)
03:03:48 <shapr> I prefer Haskell over both of 'em.
03:03:54 <eivuokko> Well, yeah
03:03:55 <shapr> Anyway, I'll see what I can do.
03:03:59 <eivuokko> But it is harder to deploy
03:04:07 <shapr> I'd like to fix that too.
03:04:09 <eivuokko> (on your random host x)
03:04:12 <shapr> yeah, true.
03:04:14 <eivuokko> Heh
03:04:30 <eivuokko> I wouldn't mind.  Haskell is a breeze for webby stuff imo.
03:05:27 <shapr> Any idea how to write pattern matching in Python?
03:05:37 * shapr is having trouble switching gears again...
03:06:16 <eivuokko> Mhm
03:06:18 * shapr goes with a bunch of if statements.
03:06:41 <eivuokko> I usually go with if or short-circuit boolean ops and output params in imperative languages
03:06:48 <eivuokko> (typical imperative languages)
03:07:03 <shapr> Yeah, makes sense.
03:07:21 <alar> @seen ndm
03:07:22 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 day, 14
03:07:22 <lambdabot> hours, 50 minutes and 39 seconds ago, and I have missed 5 seconds since
03:07:22 <lambdabot> then.
03:08:22 <alar> shapr: what privilegies do I need to use @msg ?
03:08:43 <shapr> You need to be in the admins list.
03:08:51 <shapr> Look in Config.hs
03:09:01 <shapr> Last I looked, it was just a straight up string match.
03:09:20 <shapr> People (me) have been threatening to add a hostmask matcher for years, but I don't think it's happened yt.
03:09:22 <shapr> yet
03:10:40 <shapr> goood morning jethr0! howza?
03:11:48 <jethr0> top o' the morning, shapr 
03:12:40 <jethr0> shapr: if i got myself to "work" more on my yampa thingey, i'd be happier, but you can't have everything...
03:18:13 <shapr> g'day SamB 
03:19:22 <jethr0> SamB: you never said anything to the cool brainf*ck interpreter i found (http://www.hevanet.com/cristofd/brainfuck/dbfi.b)...
03:57:12 * shapr boings
04:00:16 * jyp toinks
04:04:03 <jyp> @quote
04:04:04 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
04:11:18 <shapr> @quote
04:11:19 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers:
04:11:19 <lambdabot> Just write whatever you want and don't cite any previous work, and
04:11:19 <lambdabot> indignant readers will send you references to all the papers you should
04:11:19 <lambdabot> have cited.
04:11:33 <shapr> true that
04:11:38 <shapr> Works on the Haskell mailing lists as wel.
04:11:42 <shapr> And often on #haskell
04:12:01 <sieni> Argh, CamelCase
04:12:06 <sieni> hurts me eyes
04:12:35 <shapr> The @remember command was designed for IRC nicknames, so it doesn't accept two words.
04:19:30 <dons> \unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
04:19:37 <lambdabot> *
04:19:37 <lambdabot> *
04:19:37 <lambdabot> **
04:19:37 <lambdabot> ***
04:19:37 <lambdabot> *****
04:19:39 <lambdabot> [156 @more lines]
04:19:40 <dons> \yow!
04:19:41 <lambdabot> ... I see TOILET SEATS ...
04:21:01 <shapr> g'day dons
04:21:05 <shapr> @timein dons 
04:21:07 <lambdabot> Local time for dons is Wed Mar 15 23:21:16 2006
04:21:32 <shapr> I like the new unlambda interpreter.
04:21:33 <bolrod> !!
04:21:47 <dons> yeah. it's fun :)
04:21:59 <jyp> \unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk
04:22:03 <jyp> @more
04:22:05 <lambdabot> *
04:22:05 <lambdabot> *
04:22:05 <lambdabot> **
04:22:05 <lambdabot> ***
04:22:05 <lambdabot> *****
04:22:07 <lambdabot> [156 @more lines]
04:22:09 <lambdabot> ********
04:22:11 <lambdabot> *************
04:22:13 <lambdabot> *********************
04:22:15 <lambdabot> **********************************
04:22:17 <lambdabot> *******************************************************
04:22:19 <lambdabot> [151 @more lines]
04:25:01 <bolrod> ......
04:25:12 <bolrod> wthell does it do
04:26:10 <bolrod> ?
04:26:10 <jyp> > length "*************"
04:26:11 <dons> fibonacci, of course :)
04:26:12 <lambdabot> 13
04:26:27 <bolrod> unlambda does the fibonacci?
04:26:44 <jyp> ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`kr``s`k`sikk`k``s`ksk does
04:26:47 <dons> encoding the number 'n' as a thing of length 'n' is very natural to a haskeller
04:27:19 <bolrod> hmm.. and what functions are that O_o
04:27:35 <jyp> @google unlambda
04:27:37 <lambdabot> http://www.madore.org/~david/programs/unlambda/
04:27:41 <dons> bolrod, it's the s k and i combinators, so any computatable function is expressable
04:27:46 <michie1> that's obfuscated haskell?
04:28:03 <bolrod> it sure isn't trivial
04:28:09 <dons> nah. it's obfuscated lambda calculus :)
04:28:15 <musasabi> Has anyone got STM chans with aborted transactions going into the tail instead of the head.
04:29:19 <musasabi> Because with TChan if I have one event that cannot be completed at the moment (aborts each time) it will block the whole channel.
04:30:03 <dons> \where unlambda
04:30:04 <lambdabot> http://www.madore.org/~david/programs/unlambda/
04:30:08 <dons> ah, it's there too
04:39:51 <nuggie> hi there =) can anybody help me with a simple haskell problem 
04:40:47 <nuggie> i want to know, how to insert an element in a list at a variable position (sorry for my bad english =))
04:44:47 <musasabi> insertAt :: Int -> a -> [a] -> [a] ?
04:46:07 <dcoutts> > let insertAt n x xs = let (before, after) = splitAt n xs in before ++ x : after in insertAt 2 'x' "abcde"
04:46:08 <lambdabot> "abxcde"
04:46:38 * dcoutts wonders if that is appropriately lazy
04:46:48 <nuggie> i have to realize the funktion insertElementAt :: Integer -> a -> [a] -> [a]
04:47:03 <nuggie> insertElementAt a b c
04:47:11 <nuggie> a is the position where to insert
04:47:16 <nuggie> b is the element
04:47:23 <musasabi> nuggie: see dcoutts's solution
04:47:24 <nuggie> and c is the list
04:47:37 <ProfTeggy> nuggie, you were given the answer already
04:47:47 <nuggie> ah
04:48:00 <dcoutts> nuggie, depending on the nature of this exercise you might want to use simple recursion or library functions like take & drop
04:48:16 <nuggie> but, what is let? it is undefined from out professor
04:48:23 <dcoutts> if you don't understand my solution then don't use it
04:48:32 <ProfTeggy> nuggie, you don't need the let
04:48:53 <dcoutts> try using take & drop if you know what they are, otherwise use primitive recursion
04:49:22 <nuggie> i know what take is , but dont know what drop is 
04:49:33 <ProfTeggy> insertElementAt 0 x xs = x:xs
04:49:39 <ProfTeggy> This is a start.
04:50:29 <ProfTeggy> insertElementAt n x (y:xs) = ...
04:50:30 <shapr> musasabi: Sounds like you want mplus STM or something?
04:50:35 <ProfTeggy> simply complete it
04:51:10 <ProfTeggy> nuggie, don't mesage me
04:51:22 <nuggie> hm
04:51:46 <nuggie> i dont know, how to come to the position "n"
04:52:22 <ProfTeggy> insertElementAt n x (y:xs) = y:insertElementAt (n-1) x xs
04:52:43 <shapr> nuggie: The length function can be defined by length [] = 0 ; length (x:xs) = 1 + length xs
04:53:38 <shapr> Usually you don't worry about getting to position "n", you just check to see if you're done, and if you're not done, you go one step further and call yourself.
04:54:06 <tennin> I'd like to know if dcoutts' solution is appropriately lazy as well.
04:54:34 * tennin still doesn't really grok laziness
04:54:55 <nuggie> ProfTeggy: dont i have to check if position x is equal with position y 
04:55:03 <tennin> does the (before, after) binding screw it up?
04:55:29 <ProfTeggy> nuggie, x isn't the position, it's the element to insert
04:55:35 <ProfTeggy> n is the position
04:55:58 <nuggie> is it all been done with your function ?
04:56:03 <ProfTeggy> Yes
04:56:06 <dcoutts> tennin, I think in this case I could have used case rather than let without changing the strictness, does anyone else agree/disagree?
04:56:12 <ProfTeggy> (you might want to add a case for the empty list, though)
04:56:24 <dcoutts> let insertAt n x xs = let (before, after) = splitAt n xs in before ++ x : after
04:56:37 <nuggie> yes, insertElementAt a b [] = [b]
04:56:38 <musasabi> shapr: hmm, that does solve it. Thanks.
04:56:42 <dcoutts> let insertAt n x xs = case splitAt n xs of (before, after) -> before ++ x : after
04:56:45 <ProfTeggy> Like that, yes
04:56:59 <shapr> musasabi: Wow, I was just being a smartass =)
04:57:01 <nuggie> ProfTeggy: thanks for your help
04:57:35 <Saulzar> dcoutts, Well I can manipulate an infinite list with it and it seems to work..
04:57:43 <ProfTeggy> nuggie, tell your prof that you came here -- be honest
04:57:54 <dcoutts> tennin, in the let version I think the first thing we'd need to eval in the result would be the ++ which evals the before which will force the splitAt
04:58:09 <dcoutts> Saulzar, and the case version is the same?
04:58:23 <nuggie> ProfTeggy: the problem is that we have the main-topic java , at the last 2 weeks we had the topic haskell
04:58:27 <nuggie> for only 2 weeks
04:58:36 <musasabi> although that does make my monad non-runnable, but it is a cheap price to pay
04:58:37 <ProfTeggy> nuggie, which Univ?
04:58:40 <dcoutts> > let insertAt n x xs = case splitAt n xs of (before, after) -> before ++ x : after in take 5 (insertAt 2 'x' (cycle 'a'))
04:58:41 <lambdabot> Couldn't match `[Char]' against `Char'
04:58:45 <nuggie> a whole programming-language (totally different to Java) in 2 weeks
04:58:48 <nuggie> Freiburg
04:58:49 <dcoutts> > let insertAt n x xs = case splitAt n xs of (before, after) -> before ++ x : after in take 5 (insertAt 2 'x' (cycle "a"))
04:58:50 <lambdabot> "aaxaa"
04:58:53 <Saulzar> dcoutts, Haven't tried it
04:58:58 * dcoutts has
04:58:59 <ProfTeggy> nuggie, Freiburg!  Peter Thiemann?
04:58:59 <shapr> nuggie: Do you have Thiemann?
04:59:04 * shapr grins
04:59:06 <ProfTeggy> Hehe, shapr
04:59:10 <nuggie> nope, Burgard
04:59:26 <nuggie> Otto Thiemann had lectures in the 2. semester
04:59:27 * ProfTeggy is a big fan of SC Freiburg (German soccer team)
04:59:28 <shapr> I met Peter Thiemann at ICFP2003, he's a nice guy.
04:59:40 <nuggie> but i dont know peter thiemann
04:59:43 <dcoutts> I met Peter Thiemann at ICFP2004, he's a nice guy.
04:59:51 <ProfTeggy> I'll be in the Dreisam stadium in April again
04:59:54 <shapr> I'm planning to go to ICFP2006, who else is going?
05:00:04 <dcoutts> shapr, where is it going to be?
05:00:09 <shapr> Portland, Oregon
05:00:16 <dcoutts> hmm, it's a long way
05:00:20 <sieni> I haven't met Peter Thiemann anywhere, but I've heard he's a nice guy.
05:00:23 <shapr> Probably a few block away from where SyntaxNinja works.
05:00:24 <nuggie> oh sorry
05:00:29 <nuggie> peter thiemann, youre right
05:00:31 <nuggie> =)
05:00:32 <ProfTeggy> Met him at Dagstuhl once
05:00:49 <shapr> The FP community is a well connected graph.
05:00:55 <dcoutts> shapr, that'd be fun
05:01:07 <shapr> dcoutts: Yeah, put your coker on a plane...
05:01:12 <dcoutts> heh
05:03:12 <dcoutts> @pl (\f -> zipWithM_ f squares [0..8])
05:03:13 <lambdabot> flip (flip zipWithM_ squares) [0..8]
05:05:56 <nuggie> ProfTeggy: sorry, i used the function know, but it didnt insert an element
05:05:57 <nuggie> *sigh*
05:07:19 <ProfTeggy> It should, nuggie
05:07:23 <kosmikus> shapr: I'll have to go to ICFP 2006 ...
05:07:26 <ProfTeggy> You did something wrong then
05:07:47 <shapr> kosmikus: You have an appointment there ore something? =)
05:07:49 * shapr grins
05:07:51 <ProfTeggy> (Works fine for me.)
05:08:13 <nuggie> insertElementAt 0 x xs = x:xs
05:08:34 <nuggie> insertElementAt n x (y:xs) = insertElementAt (n-1) x xs
05:08:38 <nuggie> right?
05:09:00 <ProfTeggy> No
05:09:03 <kosmikus> what about y?
05:09:08 <ProfTeggy> He forgot it
05:09:16 <ProfTeggy> y:insertElementAt (n-1) ....
05:09:22 <nuggie> yeah
05:09:29 <nuggie> forgot to paste it =)
05:09:34 * ProfTeggy sighs
05:09:45 <kosmikus> context-sensitive paste?
05:09:53 <nuggie> but i used the funktion with y:insertElementAt
05:10:48 <Itkovian> ProfTeggy: I was right about the difficulty-level of your exercises ... the students have trouble enough to implement a transpose :-)
05:11:39 <ProfTeggy> Itkovian, :-)
05:13:35 <nuggie> ahh, i applied the function: insertElementAt 2 4 [1,2,3,4,5]
05:13:46 <nuggie> now i have [1,2,3,4,4,5]
05:14:25 <Itkovian> nuggie: is the xs sorted?
05:14:39 <ProfTeggy> nuggie, evaluate  insertElementAt 3 ')' ":-"
05:15:43 <ProfTeggy> The empty list case is important to make this example work
05:16:18 <ProfTeggy> Good luck with your exam tomorrow ;-)
05:17:52 <nuggie> ProfTeggy: why the sarcasm =) ... haskell is only a little part of the exam 
05:26:24 <musasabi> @seen JaffaCake
05:26:25 <lambdabot> I haven't seen JaffaCake.
05:26:59 <musasabi> System.Random is broken for concurrent things :-(
05:29:44 <Igloo> musasabi: How so?
05:30:47 <musasabi> Igloo: uses readIORef + writeIORef which causes the same result for multiple threads in bursts.
05:30:58 <tennin> when is ICFP?
05:31:06 <tennin> I might be living in Portland then
05:32:00 <Igloo> Ah
05:32:10 <shapr> tennin: September 17th, 2006
05:32:19 <shapr> Or maybe that's Haskell Workshop specifically.
05:33:06 <tennin> swell
05:33:17 <tennin> are these conferences worthwhile for relative newbies?
05:36:28 <Igloo> Some of HW will be, ICFP probably mostly won't be
05:37:43 <Igloo> Maybe most of HW, actually
05:38:03 <Igloo> And you can also try to meet up with #haskellers in the evenings
05:55:50 <shapr> tennin: I'd say it depends on where you want to go. I only understood about half of ICFP2003, but I've followed up most of the presentation since then and learned what they meant.
06:03:09 <kosmikus> yes, HW is usually quite interesting
06:03:31 <kosmikus> ICFP can be quite boring, but it's still better than many other conferences ;)
06:04:00 <kosmikus> Igloo: I hope you're going to submit to HW this year :)
06:04:00 <ProfTeggy> Boring?  How come?
06:04:50 <kosmikus> I don't know. I think I usually find about 1/3 of the papers interesting, which is still quite a good ratio.
06:04:58 <shapr> Some of the ICFP stuff really was painfully boring.
06:05:04 <ProfTeggy> kosmikus: Indeed!
06:05:10 * shapr grabs his handy copy of the proceedings
06:05:13 <ProfTeggy> That's quite a luxurious ratio
06:05:25 <kosmikus> But I have problems getting interested into stuff I don't know by average talkers. I rather read papers, then.
06:05:42 <kosmikus> Of course, there are a select few people who can talk about everything and make it interesting at the same time.
06:06:30 <kosmikus> ProfTeggy: For HW, I find about 3/4 of the papers interesting.
06:06:56 <ProfTeggy> If you zoom in on a specific topic, that's not a surprise
06:08:32 <musasabi> ProfTeggy: if you have the change HW is very nice.
06:09:32 <musasabi> ProfTeggy: you might want to look at the proceedings from this year. The presentations are a little bit easier than the text most of the time.
06:09:46 <ProfTeggy> I can imagine, musasabi
06:10:09 <musasabi> *this year -> 2005
06:10:13 <ProfTeggy> That's a substantial trip, though, and my 2006 is full already
06:11:24 <ProfTeggy> And I'm a database person, actually.  (I shouldn't be here ;-).
06:11:48 <ProfTeggy> There's a lot of interesting DB workshop and conferences ahead, too
06:12:05 <shapr> It seems my interests have expanded dramatically since 2003... I can only find three subjects I don't want to read about: XML, JVM, and AOP.
06:12:55 <ProfTeggy> XML is a lot more fun when you think of it a ordered, unranked trees and  regular expression types
06:13:02 <ProfTeggy> s/a/as/
06:13:27 <shapr> kosmikus: Does impredicativity make GH possible as a library?
06:14:05 <shapr> Also, I met kosmikus, Igloo, and a bunch of other #haskell people at ICFP2003.
06:16:20 <Philippa> shapr: I don't believe it does
06:16:32 <Philippa> GH needs to introspect the structure of a type
06:16:48 <shapr> types as arrows? =)
06:16:55 <mattam> how impredicativity relates to Glasgow Haskell and libraries ???
06:16:56 <Philippa> hah
06:17:05 <sylvan> anyone familiar with the Network.CGI module that can explain why using POST to send an email adress to a haskell script breaks the string so that "test@test.com" returns just "test" in the environment (got by using wrapper)
06:17:12 <sylvan> oh, this only happens on IE, not in firefox
06:17:18 <Philippa> mattam: GHC currently has predicative rank-n polymorphism. Impredicative would be nice
06:17:23 <mattam> sorry for comming in the middle of a discussion
06:17:50 <shapr> mattam: Polymorphic types must be instantiated with a concrete type.
06:17:58 <shapr> That's predicative type systems.
06:18:05 <mattam> yep, i know
06:18:28 <mattam> but 'as a library' ??
06:19:01 <Igloo> kosmikus: Currently it looks like I won't be going  :-(
06:19:26 <tennin> GH = Generic Haskell probably
06:19:28 <shapr> yeah
06:19:36 <shapr> kosmikus did his thesis on it.
06:19:43 <Philippa> mattam: type system extensions naturally improve what libraries can do
06:19:47 <mattam> i see
06:19:57 <Philippa> however, in this case not enough to implement Generic Haskell as a library
06:20:04 <shapr> Arrows allow instrospection of some flavor.
06:20:05 <mattam> k
06:20:18 <Philippa> but not of a particularly relevant flavour
06:20:27 <shapr> Well, it was an idea :-)
06:20:41 <shapr> I'm mostly clueless about all this type theory stuff, but I can jump to conclusions with the best of them =)
06:21:06 <kosmikus> shapr: I'm afraid GH is not directly related to impredicativity
06:21:14 <shapr> Ok, thanks. Just wondering.
06:21:36 <Philippa> if you had access to the typeclass implementation you could do it that way in GHC
06:21:36 <kosmikus> shapr: however, there's a lot that can be done as a library. Have you read Generics for the masses?
06:21:39 <Philippa> (but not JHC)
06:22:01 <shapr> Is that part of the Scrap your Boilerplate series?
06:22:12 <kosmikus> shapr: no, that's by Ralf Hinze.
06:22:26 * shapr googles
06:22:50 <tennin> ProfTeggy: is there an interesting intersection between Haskell/FP and databases?
06:23:04 * tennin is ignorant of the latter but may have to learn soon
06:23:09 <shapr> Hm, neat - http://lambda-the-ultimate.org/node/256
06:23:19 <ProfTeggy> tennin, oh yes!
06:23:36 <ProfTeggy> tennin, esp. when it comes to DB query languages.
06:23:45 <shapr> kosmikus: Thanks, I'll read this.
06:23:53 <ProfTeggy> Compilers for both, FP and DB, languages share a lot!  (Well, they should. -)
06:24:03 <kosmikus> shapr: there's more recent work, but that one is a good starter.
06:24:25 <kosmikus> shapr: there'll be a TFP 2006 paper by Bruno, Ralf, and me called "Generics as a Library" :)
06:24:57 <shapr> Cool
06:25:12 <shapr> Will you have a free version online?
06:26:01 <kosmikus> shapr: also, our two new SYB papers are going in that directions, the "Open data types" paper is also related, and Ralf and I are working on material for the GP summer school that's going to compare different approaches to GP within a library-like GP framework.
06:26:23 <kosmikus> shapr: sure. I'm surprised that Bruno didn't put a version online yet.
06:27:41 <shapr> Sounds like good stuff.
06:27:44 <musasabi> kosmikus: open data types paper? URL?
06:27:52 <kosmikus> shapr: I think there's a revision deadline end of this week. We'll certainly have something online after that.
06:28:16 <kosmikus> musasabi: http://www.iai.uni-bonn.de/~loeh/, the second in the list of papers.
06:28:27 <musasabi> thanks
06:29:09 <kosmikus> musasabi: I'm very interested in feedback, actually.
06:32:57 <dcoutts> @index modifyIORef
06:32:57 <lambdabot> Data.IORef
06:33:05 <dcoutts> @type Data.IORef.modifyIORef
06:33:06 <lambdabot> forall a.
06:33:06 <lambdabot>          GHC.IOBase.IORef a -> (a -> a) -> IO ()
06:33:27 <dcoutts> @type Data.IORef.atomicModifyIORef
06:33:28 <lambdabot> forall b a.
06:33:28 <lambdabot>            GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
06:33:47 <xerox> MOI, Duncan!
06:33:51 <dcoutts> @type Data.MVar.modifyMVar
06:33:52 <lambdabot> Couldn't find qualified module.
06:33:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:33:52 <lambdabot> \\)?
06:34:04 <dcoutts> @type Concurrent.MVar.modifyMVar
06:34:05 <lambdabot> Couldn't find qualified module.
06:34:05 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:34:05 <lambdabot> \\)?
06:34:13 <dcoutts> hia xerox 
06:48:13 <alar> ndm: I have one more question for you
06:48:20 <ndm> alar, go on
06:48:33 <alar> Is there a theorem that decider can't be used to describe itself
06:48:35 <alar> ?
06:48:47 <alar> like Epigram can't be made in Epigram
06:49:18 <ndm> alar, there is no such thing as a decider
06:49:22 <ndm> its a "fake" concept
06:49:52 <ndm> but if a language is total
06:49:57 <ndm> then it can only describe total things
06:50:04 <ndm> so epigram could be written in epigram
06:50:52 <alar> Epigram is not turing-complete
06:51:05 <alar> what is total language?
06:52:18 <Philippa> no partial functions. You get a result for all inputs
06:52:36 <ndm> i thought epigram was turing complete, it has "general" as a recursive pattern
06:56:01 <defcon8> d.nnr .k.pyrb.
06:56:13 <defcon8> ydco co m. oafcbi oyguu cb ',.pyf rb a haot.nn t.fxrape
06:56:34 <alar> well, in reality
06:56:48 <alar> someone told me that Epigram is Turing-incpomplete
06:57:21 <twobitsprite> I think I'm going to invent a language that uses nomadic style :)
06:57:37 <twobitsprite> the data will wonder aimlessly through your functions...
06:57:56 <alar> nomad comprehensions
06:58:10 <alar> IO nomad and state nomad
06:58:14 <alar> sounds nice
06:58:16 <twobitsprite> heheh
07:00:06 <ndm> alar, i don't know for certain, but seeing a general recursive pattern made me thing it was
07:00:46 <defcon8> co brrb. aprgbeZ
07:04:52 <alar> ndm: I understand "decider" as "system where halting problem is solvable" 
07:05:02 <ndm> alar, yes
07:05:04 <alar> but I agree not to use fake concepts
07:05:21 <ndm> but that makes a decider a conservative approximation
07:05:41 <defcon8> the lazy fox jumped over the lazy dog
07:05:44 <ndm> and i don't see a details for a concrete machine which beats a LBTM, yet is provably halting
07:05:49 <alar> aproximation of what?
07:06:07 <alar> what is LBTM?
07:06:50 <alar> L bounded TM?
07:06:54 <alar> what is L?
07:07:03 <ndm> libear bounded turing machine
07:07:27 <ndm> i don't understand decider, i don't think it corresponds to a real machine
07:07:37 <kombinator> ndm: hello
07:07:57 <alar> is it TM with tape length bounded by linear function of input string?
07:07:58 <ndm> kombinator: hi
07:08:03 <kombinator> ndm: It seems you know a bit about proof-languages
07:08:09 <ndm> alar, yes, more details on wikipeida
07:08:20 <ndm> kombinator: yes, i am only a part time compiler hacker :)
07:08:30 <ndm> proof and termination/totality is my "day job"
07:10:58 <kombinator> ndm: I'm always puzzled about the following: In coq (for instance) you want all the functions to be total, bacause otherwise they won't serve as valid proofs. So you need to make them structurally-recursive (ctd)
07:11:20 <ndm> yes
07:11:39 <kombinator> or invent a fancy well-ordering to prove that your functions are total (I have not done this myself).
07:12:08 <kombinator> But it is still said to be not turing-complete
07:12:29 <ndm> because all your functions terminate
07:12:53 <Itkovian> termination is cool. huhhuh
07:13:02 <kombinator> And my question is a bit philosophical - can we express all total computable functions in such language?
07:13:09 <ndm> no
07:13:14 <ndm> well, yes
07:13:24 <ndm> all that we can prove totality for, yes
07:13:33 <ndm> but there are many functions which we don't know if they are total or not
07:13:39 <kombinator> and can we proove it for all?;))
07:14:36 * alar wants to know the bounds of this approach
07:14:44 <kombinator> say I have a function which is partial but still useful
07:14:46 <alar> are there examples?
07:15:03 <alar> of partiall still useful functions
07:15:12 <ndm> kombinator: give an example of a useful partial function that fails with non-termination
07:15:25 <alar> and of functions with nonprovable totality
07:15:28 <ndm> its quite hard to do :)
07:15:31 <kombinator> ndm: I can't of course;)
07:16:45 <kombinator> let's say that I have a function that is partial and still useful
07:17:22 <kombinator> but if it's useful then I probably know on what subset of its domain it terminates
07:17:31 <int-e> ndm: no problem in a functional programming language. just express while as a function.
07:18:09 <ndm> int-e: a function plus arguments
07:18:10 <kombinator> so I can easily take a subset of this function which is total (what's the mathematical name for it - limitation?)
07:18:45 <alar> narrowing?
07:18:48 <ndm> while takes a higher order funciton (probably), and a value - if with a value and a function its non-terminating (and non-productive), then its pretty useless
07:18:53 <kombinator> so if I can code all total computable functions then the language is quite powerfull
07:18:58 <ndm> kombinator: subset of hte domain domain
07:19:05 <kombinator> probaly narrowing
07:19:09 <int-e> ndm: but that doesn't make the while function useless
07:19:14 <ndm> if you can code all total computatable functions you've solved the halting problem
07:19:15 <int-e> ndm: even though it's partial
07:19:18 <kombinator> right
07:19:38 <kombinator> hm
07:19:55 <ndm> int-e: maybe i should rephrase, a function, plus all the arguments, in a way which it reaches a point where no more data will ever be generated - is useless
07:20:06 <kombinator> ndm: there is one non-automatic step in what I've said
07:20:30 <ndm> coding?
07:20:46 <kombinator> well - narrowing
07:21:42 <alar> recoding function that in narrower domain its totality is provable
07:21:53 <ndm> if you have to perform narrowing, then you aren't computing the original function
07:21:58 <ndm> and aren't doing all the total functions
07:22:48 <kombinator> that's my problem - why not all?
07:23:08 <ndm> because if you narrow it, then its a different function
07:23:24 <kombinator> but before narrowing it was not total
07:23:45 <int-e> if you have a language that can express all total computable functions, and only total computable functions, then well-formedness of that language is undecidable.
07:24:03 <kombinator> int-e: that sounds reasonable
07:24:31 <kombinator> well-formedness means that I can't tell if my program is a valid one?
07:24:44 <int-e> yep
07:24:46 <beelsebob_> uhh... buh?    - Convert.hs:22:2: `read' is not a (visible) method of class `Read'
07:24:46 <kombinator> (automatically)
07:24:47 <ndm> yes, think type checking
07:24:52 <beelsebob_> um... since when?
07:24:56 <int-e> not in general at least
07:25:01 <ndm> beelsebob_: read is not in the Read class
07:25:16 <ndm> try reads :)
07:25:25 <ndm> read is implemented on top of reads
07:26:18 * alar tries tyo imagine system that can't check well-formedness before execution of a program
07:27:13 <kombinator> but we could approximate the set of total computable functions by extending the language further and further if it's not enough (I hope)
07:27:40 <kombinator> alar: simple
07:27:41 <defcon8> hello people
07:28:20 <kombinator> alar: takes a haskell function and fails it iff it's not total
07:28:21 <beelsebob_> buh... sillyness
07:28:26 <beelsebob_> don't need complicated read :(
07:28:35 <ndm> kombinator: but there will always be an infinite number of terminating functions which you're language can't deal with
07:29:04 <kombinator> ndm: I know - but they will be marginally useful;))
07:29:21 <ndm> kombinator: maybe, but i guarantee someone will at some point try writing them
07:29:31 <alar> Are there examples of useful total functions with unprovable totality?
07:29:53 <kombinator> there is this funny /3 + 1 problem
07:29:58 <ndm> alar, no, because they are't total until they've b een proved :)
07:29:59 <kombinator> or sth
07:30:23 <dcoutts> there are many functions that are conjectured to be total but not proved :-)
07:30:34 * dcoutts is thinking of most of my code
07:30:41 <dcoutts> my/his
07:30:50 <alar> ndm: you've proved "<kombinator> ndm: I know - but they will be marginally useful;))"
07:30:53 <roconnor> kombinator: all these total functions get slower and slower to compute
07:30:55 <alar> :)
07:31:03 <ndm> http://en.wikipedia.org/wiki/Collatz_conjecture
07:31:50 <ndm> thats a non-terminating problem
07:31:56 <kombinator> ndm: That;s the one I was thinking about
07:32:02 <ndm> http://research.microsoft.com/terminator/collatz.htm
07:32:11 <ndm> in a more directly obvious non-termination way
07:33:16 <sieni> there's a program to compute the maximum number of iterations before the 4, 2, 1, 4, 2, 1 -cycle: http://www.hurmio.org/~ville/3n+1.scm
07:33:19 * dcoutts notes the problem with using different GUI toolkits on each platform:
07:33:20 <dcoutts> http://www.haskell.org//pipermail/haskell-cafe/2006-March/014937.html
07:34:54 <twobitsprite> what's the difference between ^ and **?
07:35:07 <sjanssen> @type (^)
07:35:08 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:35:09 <dcoutts> @type (**)
07:35:10 <lambdabot> forall a. (Floating a) => a -> a -> a
07:35:11 <sjanssen> @type (**)
07:35:12 <lambdabot> forall a. (Floating a) => a -> a -> a
07:35:28 <twobitsprite> I see
07:35:48 <sjanssen> (^) takes a postive, integral argument, ** is not restricted in this way
07:35:54 <sjanssen> for further confusion:
07:35:58 <sjanssen> @type (^^)
07:36:00 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:36:24 <roconnor> a ** b is short for exp(ln(a)*b)  a ^ n is short for repeated squaring and multiplying
07:36:57 <twobitsprite> ahh
07:37:54 <twobitsprite> it also seems like ** has a limit on the size of the numbers it can compute
07:38:19 <sjanssen> you're probably going outside the range of a Double
07:38:25 <alar> so, 3n+1 is example of useful partial function
07:38:26 <twobitsprite> right
07:38:35 <alar> because it's totality is not proved
07:41:46 <beelsebob_> okay - interesting problem
07:41:58 <beelsebob_> don't ask me why I'm not using parse combinators, I have my reasons...
07:41:59 <alar> I mean straihghtforward search for i(n)
07:42:24 <beelsebob_> I have defined (<+>) :: Parser a -> (a -> b -> c) -> Parser b -> Parser c
07:42:44 <beelsebob_> i.e. parse one thing, parse another, and combine their ASTs with the function
07:43:31 <beelsebob_> problem is... if I try to use that... e.g. (accept someToken) <+> f parseJam
07:43:35 <beelsebob_> f binds to parseJam
07:43:52 <beelsebob_> so I need to do ((accept someToken) <+> f) parseJam
07:44:01 <beelsebob_> which is ugly as sin, and destroys the neatness
07:44:06 <beelsebob_> any ideas how to fix it?
07:45:21 <alar> beelsebob_: if you're unsatisfied with syntax
07:45:23 <alar> use $
07:45:37 <beelsebob_> alar: how would I use it in this case?
07:45:46 <beelsebob_> I want *don't* apply - not apply
07:45:47 <alar> after f
07:45:52 <alar> ah
07:45:59 <alar> then I don't know
07:47:04 <twobitsprite> beelsebob_: can't you give the operator a higher precedence?
07:47:24 <ndm> beelsebob_: what are you trying to parse?
07:47:32 <sjanssen> there is no precedence higher than function application
07:47:35 <beelsebob_> twobitsprite: you can - but not as high precidence as a function
07:47:41 <twobitsprite> ahh
07:47:52 * twobitsprite is a newbie and really shouldn't answering questions anyways...
07:47:56 <beelsebob_> ndm: just some simple stuff - I'm just trying to do it first order without monads except for some simple combinators
07:48:51 <sjanssen> beelsebob_: perhaps you could introduce a second operator that has higher precedence than your original one, and is just a synonym for (,)
07:49:17 <sjanssen> or better, lower precedence.  then you don't need the tuple
07:49:26 <beelsebob_> sjanssen: how do you mean?
07:49:40 <sjanssen> what's the infix decl. for your operator?
07:49:52 <beelsebob_> infixl 5 <+>
07:51:38 <kombinator> int-e: but how to prove what you've said? Proof -languages havve proofs embedded in them and the checker doesn't have to synthesize proofs
07:51:59 <kombinator> int-e: I can't say: ta
07:52:05 <int-e> kombinator: I quote Goedel's incompleteness theorem
07:52:52 <int-e> kombinator: or rather the way it's proved - which builds on computable functions and their representation as logical formulas.
07:52:53 <defcon8> i really wonder why i keep getting dc
07:53:22 <shapr> hiya defcon8 
07:53:28 <kombinator> int-e: can you derive this fact directly from undecidability of HP?
07:53:47 <kombinator> int-e: this would greatly help
07:53:52 <shapr> dons: I really like sylvan's idea about the haskell weekly news showing up on the front page of haskell.org.
07:54:18 <sjanssen> where can I paste things?
07:55:05 <sjanssen> @paste
07:55:06 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
07:56:07 <roconnor> kombinator: you can prove a weak version of goedel incompleteness from undecidability of HP.
07:56:21 <roconnor> but this weak version is probably strong enough for all the uses you need.
07:57:13 <roconnor> for every TM x, you can write an arithmetic statement that says x halts.
07:57:32 <roconnor> call this statement S.
07:58:18 <roconnor> suppose you could prove A or you can prove -A for every A.
07:58:28 <roconnor> then you could prove S or you can prove -S.
07:58:45 <roconnor> then you can write a TM to search for the first proof of S or the first proof of -S.
07:59:00 <roconnor> this TM would then halt.
07:59:14 <roconnor> if it find a proof of S, then we know x halts.
07:59:23 <roconnor> if it finds a proof of -S, then we know x does not halt.
07:59:30 <araujo> morning
07:59:32 <roconnor> thus we have solved the halting problem.
07:59:37 <roconnor> contradiction.
08:00:00 <roconnor> therefore there is some statement A such that you can neither prove A nor prove -A.
08:00:21 <kombinator> that's the weak Goedel's theorem?
08:00:28 <shapr> What about the Busy Beavers?
08:00:40 <shapr> Some TMs are known to halt through observation, yeah?
08:01:05 <ndm> shapr, for certain input values
08:01:19 <ndm> if there are an infinite number of inputs, you can't even observe that
08:01:22 <shapr> roconnor: Could you factor known-halting TMs out of 'larger' TMs to get 'proofs by induction' ?
08:01:34 <roconnor> kombinator: the strong version says there is a particular Pi_1 sentence A that you can neither prove A nor prove -A.
08:01:51 <sjanssen> beelsebob_: check the paste page
08:01:56 <shapr> ndm: Hey, if you don't understand monads, I bet I can explain 'em to ya in ten minutes.
08:02:09 <ihope> Ten minutes?
08:02:15 <shapr> maybe less
08:02:16 <ndm> shapr, go for it :)
08:02:23 <ihope> Monads are magic one-way bubbles.
08:02:30 <roconnor> shapr: I don't think so.  I think of it as that there are some TMs that accidently halt on all input for no good reason.
08:02:31 <beelsebob_> @where paste
08:02:32 <lambdabot> http://paste.lisp.org/new/haskell
08:02:37 <shapr> ndm: Ok, you know the Maybe type?
08:02:39 <beelsebob_> @paste
08:02:40 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
08:02:45 <kombinator> roconnor: thanks, will try to digest this
08:02:46 <sjanssen> yeah, the second one is it
08:02:48 <ndm> do you want to head to overflow, since people are already having a termination conversation here as well :)
08:02:57 <shapr> ndm: It represents failure, yeah?
08:02:58 <beelsebob_> ah, I see sjanssen 
08:03:01 <beelsebob_> that makes a lot of sense
08:03:03 <beelsebob_> very nice :)
08:03:06 <ndm> shapr, yes, i understand maybe
08:03:07 * beelsebob_ uses it
08:03:10 <shapr> ndm: That wasn't a naval reference, was it?
08:03:23 <ndm> no, not intentionally
08:03:44 <shapr> ndm: Seems quiet for the moment.
08:03:49 <ndm> ok, go for it
08:03:57 <ndm> (time starts at 4:03 UK time ;))
08:04:01 <shapr> heh
08:04:19 <shapr> Ok, so you know how the maybe type represents failure, right?
08:04:25 <ndm> yes
08:04:42 <ndm> with Nothing
08:04:50 <shapr> One sensible way to look at a monad is that it turns the significance of a type into a pipeline with the same significance.
08:05:09 <ndm> the significance?
08:05:19 <shapr> Yeah, Nothing means "it died"
08:05:25 <alar>  
08:05:29 <alar> the content
08:05:32 <shapr> or Just a means "It lived, and you got a result too!"
08:05:38 <ndm> yes, i see that
08:05:52 <shapr> so, I talk about a webshop where you'd have a bunch of computations that should succeed, or everything should fail.
08:06:04 <shapr> doesClientExist >>= doesClientHaveMoney >>= doesItemExist >>= isItemInStock
08:06:14 <ndm> yes, i understand that
08:06:24 <shapr> In an imperative language, you'd use a bunch of nested if/then/else blocks, right?
08:06:28 <ndm> yep
08:06:42 <ndm> (or exceptions, but iguess thats beside hte point)
08:06:53 <shapr> (we hit exceptions next, 1.5 minutes ;-)
08:07:10 <shapr>     Nothing  >>= f = Nothing
08:07:10 <shapr>     (Just x) >>= f = f x
08:07:22 <ndm> ok, i understand taht
08:07:23 <earthy> hm. normally I'd say    doesItemExist >> isItemInStock >> getClientInfo >> getClientPayment
08:07:25 <shapr> That's the important part of the Monad instance for the Maybe type.
08:07:33 <ndm> yes
08:08:07 <ndm> i understand all of that
08:08:21 <ndm> i also pretty much understand the list monad (mostly)
08:08:24 <shapr> So, a monad just takes the failure significance and turns it into a pipeline.
08:08:33 <ndm> ok
08:08:54 <shapr> The next step up in niftiness is an error pipeline.
08:09:10 <ndm> using Either?
08:09:12 <shapr> Instead of just reporting "Nothing" meaning "It died", you can say "It died like this:"
08:09:13 <shapr> exactly
08:09:22 <ndm> ok, i can see how that would work
08:09:36 <shapr> The monad instance looks almost exactly the same, but it returns the first error result instead of Nothing
08:09:45 <ndm> yep
08:09:46 <alar> is Either a monad?
08:09:47 <ihope> Either lets you perform an autopsy.
08:09:52 <shapr> alar: If you want..
08:09:58 <ihope> alar: Either a is a monad, I think
08:10:11 <ndm> by default either seems a bit underspecified in haskell, no fromLeft, fromRight etc.
08:10:37 <ihope> There's either.
08:10:39 <tibbe> I need a function that makes a function take its arguments in opposite order (e.g a -> b -> c to b -> a -> c)
08:10:46 <shapr> The general pattern of understanding a monad is "What's the sigificance of the type we're using?" and then "How does it fit into a pipeline?" or alternately, "How do we automate that significance?"
08:10:51 <Igloo> tibbe: flip
08:10:59 <musasabi> instance Monad (Either String) where return x = Right x; fail x = Left x; (Left a) >>= _ = Left a; (Right a) >>= f = f a
08:11:07 <shapr> ndm: So, you understand monads now?
08:11:19 <ndm> i understand Maybe, Either
08:11:22 <ndm> but not monads
08:11:35 <shapr> Well, can you explain to me how the list monad works?
08:11:35 <alar> monads are one-way boxes
08:11:57 <sjanssen> alar: not many of the monads you use from day to day are one way
08:12:00 <ndm> shapr, yes - it takes the significant bit of the type (how many there are), and does it as that
08:12:17 <ndm> xs >>= f = concatMap f xs
08:12:28 <ihope> sjanssen: well, the fact that it's a monad doesn't mean it's not two-way.
08:12:29 <shapr> Most people would call the significance of the list monad backtracking, but it's all in how you see it really.
08:12:54 <shapr> So can you explain the state monad?
08:12:58 <ndm> ok, i never thought of it that way, but yeah - if you see it as ordered (i tend to see a list as a set usually)
08:13:05 <ndm> shapr, not much
08:13:11 <shapr> Well, try it..
08:13:14 <ndm> the state monad is usually where my eyes glaze over
08:13:21 <ndm> the significant bit is the state
08:13:21 <shapr> I'll help you with the rough spots :-)
08:13:30 <musasabi> ndm: you might want to start with Reader.
08:13:38 <musasabi> ndm: after Reader state is easy.
08:13:43 <alar> sjanssen I use only IO and State as mo0nads
08:13:44 <ndm> so i guess it keeps a state hidden away
08:13:45 <ihope> Yeah. Reader's a nice monad.
08:14:06 <sjanssen> alar: that's too bad.  you're really missing out ;)
08:14:07 <ndm> and performs computations over a value, which can somehow make use of the state
08:14:09 <ihope> ndm: well, if you think variables and imperative code... that's what state does.
08:14:19 <ndm> ihope, i don't think that way anymore....
08:14:42 <alar> sjansses: I'm a newbie
08:14:47 <ihope> ndm: then don't use State :-)
08:14:49 <musasabi> Currently I use a Reader + STM + IO sideactions and it is also MonadState on the side.
08:14:53 <shapr> ndm: Yeah, and the monad instance passes the state through both x and y of bindM (x >>= y)
08:14:58 <ndm> ihope, i don't, hence i don't understand it
08:15:15 <ndm> ok, and can x change the state?
08:15:16 <musasabi> just lacking continuations.
08:15:28 <shapr> ndm: If you wanted to write an old hand calculator in Haskell, you'd pass the single chunk of 'memory' around explicitly, yeah?
08:15:37 <ihope> ndm: any State monadic value can change the state.
08:15:48 <ndm> shapr, yes, as the first argument
08:15:56 <ndm> and return it as a tuple (result, state)
08:16:17 <shapr> Yeah, the state monad is exactly that, with the explicit passing being moved into the definition of >>=
08:16:26 <ndm> i understand state passing, and i realise the state monad does something like that, but can't wrap my head around how
08:16:30 <shapr> I have demo files that go step by step from explicit to monad, if you want to see.
08:16:40 <ndm> shapr, yes please
08:16:49 <ihope> ndm: well, isn't Haskell about focusing on the what rather than the how?
08:17:11 <ndm> ihope, indeed it is
08:17:29 <ndm> but for me that means describing something mathematically, and monads/state aren't that way to me
08:20:22 <shapr> http://www.scannedinavian.com/~shae/steve_atkins_monads/
08:21:20 <ihope> Hmm, for some reason, Firefox is no longer displaying .hs files as it would text files.
08:22:17 <ndm> thats teh server, if it sends text/plain for the mime time, firefox will show it, else it downloads it
08:23:01 <int-e> ihope: probably because the server knows that its Content-Type: text/x-haskell
08:23:20 <shapr> Where are the mime types specified?
08:23:22 <ihope> How do I force Firefox to display it?
08:23:34 <ihope> shapr: somewhere in the HTTP stuff :-P
08:23:36 <ndm> shapr, the server config somewhere, depends on your server (i think)
08:23:46 <int-e> ihope: I wish I knew. Actually I wish it had a 'display as text' button in the download menu.
08:23:47 <davidhouse> ihope, dunno if you can
08:23:55 <davidhouse> try googling for an about.config option
08:24:01 <davidhouse> DON'T set the application to firefox
08:24:09 <davidhouse> that starts an infinite cycle of firefoxes.
08:24:19 <ihope> Ouch.
08:24:24 <int-e> cool!
08:24:39 * int-e feels a sudden urge to break stuff
08:25:51 <ihope> Oh, rightrightright.
08:26:07 <int-e> text/x-haskell                                  hs
08:26:23 <ihope> @unlambda ```.kr.ni
08:26:23 <lambdabot> k
08:26:23 <lambdabot> n
08:26:26 <int-e> err. that's in /etc/mime.types
08:26:27 <shapr> ndm: It starts to get interesting with Eval9.hs That's where you see the initial state passed in.
08:26:58 <int-e> oh no, who taught lambdabot unlambda?
08:27:17 <davidhouse> shapr, that's trs cool.
08:27:51 <ndm> shapr, thanks
08:28:11 <ndm> that seems quite interesting - looks like their is a monad tutorial in those examples, just waiting to be written
08:28:18 <ndm> :)
08:28:42 <shapr> Steve Atkin wrote this code, and a website that went with them. But his website went away, and I only have the files left.
08:28:49 <int-e> @unlambda `|.i
08:28:50 <lambdabot> i
08:29:05 <davidhouse> @help @unlambda
08:29:06 <lambdabot>  @help <command> - ask for help for <command>
08:29:11 <ihope> What's |?
08:29:15 <davidhouse> @help unlambda
08:29:16 <lambdabot>  @unlambda <expr>
08:29:16 <lambdabot> Evaluate an unlambda expression
08:29:22 <davidhouse> @where unlambda
08:29:22 <lambdabot> http://www.madore.org/~david/programs/unlambda/
08:29:39 <twobitsprite> ok... so I need a miniproject to get a feel for haskell before I embark on anythin significant... any ideas?
08:29:51 <int-e> `|x evaluates to `xv if there is no current character or to `x.c if c is the current character
08:30:24 <shapr> ndm: Ok, maybe it was more than ten minutes...
08:30:25 * davidhouse steers well clear of that
08:30:38 <shapr> ndm: But I hope monads are mostly clear to you now.
08:30:50 <ndm> shapr, clearer, but still not quite done
08:30:54 <ndm> thanks a lot
08:30:59 <shapr> Sure, anytime.
08:31:23 <ndm> i might try learning the underlying category theory - that might be the best way for me to entirely understand them
08:31:30 <ihope> @unlambda `|i
08:31:31 <lambdabot> Done.
08:32:21 <shapr> I'm more a software engineering guy, but I can clearly see how much more the monadic abstraction gives me over the object abstraction.
08:33:14 <ndm> i like the function abstraction, i guess i'm more a maths person
08:33:17 <shapr> Also, the monadic abstraction works fine in OCaml, ML, Scheme, Java, Ruby, etc.
08:33:22 <xerox> I don't think CatTheory is really needed to understand monads, in fact I think I recall reading that the connection is kinda loose... from the programmatic to the mathematical pov.
08:33:50 <ndm> shapr, works, but i'm unconvinced that its useful
08:33:53 <davidhouse> a monad is just a mathematical object, like a ring or group.
08:33:56 <ndm> esp. with mutable state
08:34:06 <davidhouse> in fact, monoids appear in one of the monads.
08:34:06 <xerox> ndm: just try writing the code.
08:34:31 <ndm> xerox, for monads in java?
08:34:42 <xerox> ndm: urgh.. java?
08:34:54 <shapr> There's a nice paper on monadic parsing with Java.
08:35:23 <ndm> xerox, i know :) i prefer javascript
08:35:24 <xerox> I mean writing the Haskell code for solving a problem for which some monad is said to suit.
08:35:35 <ndm> shapr, i never got monadic parsing either, but it looks kind of cool
08:35:47 <shapr> Oh, I'd love to explain monadic parsing to ya
08:35:53 <ndm> another time :)
08:35:56 * xerox trembles about hoogle
08:35:56 <shapr> It's so powerful!
08:36:12 <ndm> i think i got it mainly, going though the parsec introduction
08:36:18 <jethr0_> shapr: have you tried monads in other languages (like python for example)?
08:36:24 <ndm> xerox, why trembling about hoogle?
08:36:36 <xerox> How do you parse! Heretic!  (just kidding)
08:36:46 <shapr> jethr0_: Just a bit, but they were useful there as well.
08:36:47 <jethr0_> my guess would be that in languages like java the missing HOFs would make it harder, but i guess you could work with inline, anonymous functions to some extent
08:36:49 * shapr gets url
08:37:11 <xerox> @wtf HOF
08:37:12 <lambdabot> No match for "HOF".
08:37:20 <jethr0_> higher order functions
08:37:25 <ihope> @help wtf
08:37:25 <lambdabot>  @help <command> - ask for help for <command>
08:37:28 <xerox> K.
08:37:36 <ihope> @spellcheck wtf
08:37:37 <lambdabot> Unknown command, try @listcommands.
08:37:45 <ihope> @spell wtf
08:37:45 <lambdabot> wt WFF ft EFT waft
08:38:08 <ndm> xerox, the hoogle parser is hand written, using nothing but pure haskell with no libraries
08:38:14 <ndm> mainly pattern matching
08:38:32 <xerox> Ah-uhm.
08:38:45 <xerox> Maybe one could use ghc-api and shorten hoogle out quite a bit?
08:39:36 <shapr> jethr0_: Here's one example - http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/439361
08:39:38 <sjanssen> is hoogle's parser all that involved?  seems that parsing type signatures shouldn't require a complicated parser
08:41:13 <ndm> xerox, not much by using ghc, all the "type checking" stuff is entirely different
08:41:30 <xerox> ndm: to type check, it has to parse, that's what I thought.
08:41:31 <ndm> the only bit i might get is parsing lines, and even then, the hoogle ones aren't haskell by quite a way
08:41:42 <ndm> take a look at hoogle.txt, its realitvely simple
08:41:51 <ndm> sjanssen: no, its pretty simple - it is wrong however :)
08:42:06 <ndm> i'm thinking of moving to a binary file format
08:42:21 <ndm> at the moment its a good format for outputting, and reading is complex (ish)
08:42:38 <ndm> if i move to binary, then i can create cache's as well, so searches can be much faster
08:42:55 <ndm> which will be necessary when i search every haskell function in existance :)
08:43:27 <alar> is it right that all Turing-completeness in Haskell is invisible Y in "let" and "case"?
08:43:54 <alar> so let is actually letrec
08:43:58 <xerox> Oh-uhm?
08:44:30 <ihope> Lambdas + fix = Turing-completeness.
08:44:32 <ihope> I think.
08:44:44 <alar> fix?
08:44:47 <beelsebob_> is there a hhypergraph minimum spanning tree algorithm easily available?
08:44:51 <ihope> alar: Y
08:44:56 <tibbe> @quote
08:44:57 <lambdabot> chromatic says: My productivity increased when Autrijus told me about
08:44:57 <lambdabot> Haskell's trace function. He called it a refreshing desert in the oasis
08:44:57 <lambdabot> of referential transparency.
08:45:09 <xerox> Haha.
08:49:36 <ihope> @quote
08:49:36 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o'
08:49:36 <lambdabot> $ cycle "l") lol
08:49:47 * xerox coughs in the background
08:50:15 <ihope> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
08:50:16 <lambdabot> ["ol","lol","olol","lolol","ololol","lololol","olololol","lolololol","
08:50:16 <lambdabot> ololololol","lololololol"]
08:50:29 <xerox> lol.
08:51:01 <newsham> http://www.cis.upenn.edu/~bcpierce/courses/670Fall04/GreatWorksInPL.shtml
08:51:30 <alar> ihope: yes, but where is this "fix" hidden in Haskell?
08:51:45 <ihope> Control.Monad.Fix, though everyone knows it should be Preluded.
08:52:08 <sjanssen> really, why isn't fix in the prelude
08:52:35 <sjanssen> has this ever been discussed by Haskell' people?
08:52:49 * alar doesn't understand
08:53:08 <ihope> > Control.Monad.Fix.fix (const 3)
08:53:09 <lambdabot> 3
08:53:19 <alar> I can write something without Control.Monad.Fix
08:53:33 <alar> and it still is Turing-complete
08:53:36 <int-e> > Control.Monad.Fix.fix (\(x,y) -> (3,succ x))
08:53:37 <lambdabot> Terminated
08:53:56 <davidhouse> @type Contrl.Monad.Fix.fix
08:53:57 <sjanssen> alar: you can write fix with function definitions
08:53:58 <lambdabot> Couldn't find qualified module.
08:53:58 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
08:53:58 <lambdabot> \\)?
08:53:59 <ihope> Hmm...
08:54:05 <alar> @info Control.Monad.Fix.fix
08:54:05 <lambdabot> Unknown command, try @listcommands.
08:54:08 <davidhouse> @type Control.Monad.Fix.fix
08:54:09 <lambdabot> forall a. (a -> a) -> a
08:54:09 <ihope> @type Control.Monad.Fix.fix
08:54:10 <lambdabot> forall a. (a -> a) -> a
08:54:17 <davidhouse> wassit do?
08:54:24 <ihope> fix x = x (fix x)
08:54:24 <int-e> > Control.Monad.Fix.fix (\(~(x,y)) -> (3,succ x))
08:54:25 <lambdabot> (3,4)
08:54:38 <ihope> Ah yes...
08:55:01 <newsham> least fixed point?
08:55:13 <sjanssen> davidhouse: fix is a way of doing recursion without doing it explicitly
08:55:15 <ihope> Nope. Just, well...
08:55:39 <davidhouse> @type (~)
08:55:40 <lambdabot> parse error on input `)'
08:55:41 <integral> > Control.Monad.Fix.fix $ \x -> x*x
08:55:43 <lambdabot> Terminated
08:55:53 <ihope> If there's just one fixed point and an obvious way to find it, fix finds it.
08:56:05 <ihope> davidhouse: lazy patterns
08:56:09 <ihope> @where lazy pattern
08:56:10 <lambdabot> I know nothing about lazy.
08:56:15 <ihope> @where pattern
08:56:16 <lambdabot> I know nothing about pattern.
08:56:20 <integral> like there it found the _|_ fixed point over the one at 0
08:56:24 * alar doesn't understand why fix \(x,y)-> (3, succ x) doesn't work
08:56:25 <davidhouse> @wiki Lazy_Pattern
08:56:26 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_Pattern
08:56:38 <davidhouse> grr. empty.
08:56:48 <ihope> @google haskell lazy pattern
08:56:50 <lambdabot> http://www.haskell.org/tutorial/patterns.html
08:57:25 <int-e> alar: because it doesn't know that the fixed point will be a pair before the fixed point is found
08:57:50 <ihope> alar: first, the lambda tries to find just where the (,) constructor was applied.
08:58:05 <ihope> Essentially, it's acting as a seq.
08:58:28 <ihope> \s@(x,y) -> seq s (3, succ x) -- sorta like this
08:58:29 <lambdabot> Unknown command, try @listcommands.
08:59:15 <ihope> Now, there's a bunch of useful functions about. \~(x,y) -> (x,y), \~(x:y) -> (x:y), \~(Just x) -> Just x...
08:59:52 <alar> well, I think I'll not understand it without looking at lambdas
08:59:57 <ihope> Like constructor assertions. "I know this is a (:), so you don't have to check that."
09:00:17 <ihope> alar: \x -> y = let foo x = y in foo
09:02:27 <alar> <ihope> alar: first, the lambda tries to find just where the (,) constructor was applied.
09:02:29 <alar> how?
09:02:49 <ihope> Well, it evaluates its argument just enough to find the constructor.
09:03:33 <alar> and then?
09:03:40 <ihope> For example, (\(x,y) -> 3), when given (error "foo"), evaluates (error "foo") until it finds a constructor.
09:04:03 <xerox> Whish me luck.
09:04:04 <ihope> alar: it pops the arguments to the constructor into the x and y variables.
09:04:07 <xerox> Wish, err.
09:04:17 <ihope> Goood luck! ;-)
09:04:22 <sjanssen> xerox: you're going to need it
09:04:37 <alar> >Control.Monad.Fix.fix (\x-> (3,succ (fst x)))
09:04:52 <roconnor> iterate \(x,y) -> (3,succ x) (undefined,undefined)
09:04:55 <roconnor> > iterate \(x,y) -> (3,succ x) (undefined,undefined)
09:04:56 <lambdabot>  parse error on input `\'
09:05:01 <roconnor> > iterate (\(x,y) -> (3,succ x)) (undefined,undefined)
09:05:03 <lambdabot> Undefined
09:05:21 <roconnor> oh right
09:05:22 <ihope> > Control.Monad.Fix.fix (\x-> (3,succ (fst x)))
09:05:23 <lambdabot> (3,4)
09:05:28 <roconnor> > tail $ iterate (\(x,y) -> (3,succ x)) (undefined,undefined)
09:05:29 <lambdabot> Undefined
09:05:33 <roconnor> hmm
09:05:47 <roconnor> > tail $ tail $ iterate (\(x,y) -> (3,succ x)) (undefined,undefined)
09:05:49 <lambdabot> [(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(
09:05:49 <lambdabot> 3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,
09:05:49 <lambdabot> 4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4)
09:05:49 <lambdabot> ,(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(
09:05:49 <lambdabot> 3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,4),(3,
09:05:50 <ihope> > [3,undefined]
09:05:50 <alar> hmm
09:05:51 <lambdabot> [23 @more lines]
09:05:52 <roconnor> there we go
09:05:53 <lambdabot> Undefined
09:06:16 <alar> so \x -> (3, succ (fst x)) works
09:06:29 <Cale> > head [3,undefined]
09:06:30 <lambdabot> 3
09:06:33 <alar> and \(x,y) -> (3, succ x) doesn't
09:07:04 <roconnor> fix (\x -> (3, succ (fst x)))
09:07:07 <roconnor> > fix (\x -> (3, succ (fst x)))
09:07:08 <lambdabot> (3,4)
09:07:18 <ihope> Well, in the former, you're not pattern matching until after you've given the interpreter something to match.
09:07:23 <roconnor> > fix (\~(~x,~y) -> (3, succ x))
09:07:24 <lambdabot>  parse error on input `->'
09:07:32 <alar> ah
09:07:44 <sjanssen> roconnor: the ~'s on the x and y are redundant
09:07:57 <sjanssen> a variable matches anything
09:07:59 <alar> an analog of lazy pattern
09:08:08 <ihope> Yep.
09:08:24 <ihope> Using lazy patterns also delays pattern matching as long as possible, but at the cost of always matching "no matter what".
09:08:40 <alar> > fix (\(x,y) -> (3, succ x))
09:08:41 <lambdabot> Terminated
09:09:11 <alar> this means "missmatch at the first application of argument to fix"?
09:09:19 <ihope> Um...
09:09:31 <alar> or what?
09:09:40 <roconnor> > fix (\~(x,y) -> (3, succ x))
09:09:41 <lambdabot>  parse error on input `->'
09:10:01 <roconnor> > fix (\s -> case s of ~(x,y) -> (3, succ x))
09:10:02 <lambdabot> (3,4)
09:10:12 <ihope> alar: well, it's tricky to explain...
09:10:16 <roconnor> > fix (\s -> let ~(x,y)=s in (3, succ x))
09:10:17 <lambdabot> (3,4)
09:10:19 <alar> > fix (\s -> case s of (x,y) -> (3, succ x))
09:10:20 <lambdabot> Terminated
09:10:24 <roconnor> > fix (\s -> let (x,y)=s in (3, succ x))
09:10:26 <lambdabot> (3,4)
09:10:30 <roconnor> ahhhhhhhhhh
09:10:43 <roconnor> lazy lets
09:10:50 <alar> lazy let and strict case?
09:11:08 <ihope> Hmm...
09:11:10 <sjanssen> roconnor: if you want to put a ~ in a lambda, put a space between \ and ~
09:11:19 <roconnor> > fix (\ ~(x,y) -> (3, succ x))
09:11:21 <lambdabot> (3,4)
09:11:24 <roconnor> oh
09:11:27 <ihope> (\(x,y) -> (3, succ x)) always evaluates its argument until it becomes (,) applied to two things.
09:11:38 <ihope> Then it sets x to one thing, and y to the other.
09:11:56 <ihope> > (\(Left l)@(Right r) -> l) (Left 3)
09:11:57 <lambdabot>  parse error on input `@'
09:12:01 <ihope> Aww.
09:12:14 <ihope> > (\x@(Right r) -> x) (Left 3)
09:12:15 <lambdabot> Add a type signature
09:12:22 <ihope> > (\x@(Right r) -> x) (Left 3) :: Either Integer Integer
09:12:24 <lambdabot>  Non-exhaustive patterns in lambda
09:12:35 <ihope> That's odd.
09:12:52 <sjanssen> ihope: that is what I'd expect
09:13:58 <int-e> > (\x@(~(Right r)) -> x) (Left 3) 
09:13:58 <sjanssen> > (\ x@ ~(Right r) -> x) (Left 3)
09:13:59 <lambdabot> Add a type signature
09:13:59 <lambdabot> Add a type signature
09:14:20 <int-e> > (\x@(~(Right r)) -> x) (Left 3) :: Either Integer Integer
09:14:21 <lambdabot> Left 3
09:14:52 <ihope> But why's it matching on (Right r) right away?
09:15:27 <alar> ihope: so (x,y) evaluates argument to deconstruct ',' ?
09:15:27 <int-e> because var@pat is defined that way: match pat but also bind var to the original value
09:15:49 <ihope> alar: yep.
09:16:00 <ihope> But just enough to deconstruct it, no more.
09:16:06 * alar begins to understand
09:16:15 <ihope> > (\(x,y) -> 3) (undefined, undefined)
09:16:15 <lambdabot> 3
09:16:24 <alar> aha
09:16:26 <tibbe> can I do something to make Haskell understand that a file is in ISO-8859-1 and not in UTF-8 (which my system uses)?
09:16:38 <alar> > (\(x,y) -> 3) undefined
09:16:39 <lambdabot> Undefined
09:16:49 <alar> > (\(x,y) -> 3)) undefined
09:16:50 <lambdabot>  parse error on input `)'
09:16:51 <Cale> > (\((x,y),z) -> 3) (undefined, undefined)
09:16:52 <lambdabot> Undefined
09:19:12 <defcon8> can someone explain length (x:xs)           =  1 + length xs please?
09:19:22 <davidhouse> it's a definition of list.
09:19:25 <davidhouse> *length
09:19:35 <davidhouse> defcon8: which bit don't you understand?
09:19:40 <defcon8> the x:xs
09:19:47 <davidhouse> ah. that's pattern matching.
09:19:54 <ihope> [1,2,3] = 1:[2,3]
09:19:58 <davidhouse> x gets set to the first value in the list, xs the rest.
09:20:04 <ihope> = 1:2:[3] = 1:2:3:[]
09:20:16 <alar> ihope: so "Terminated" means not "reduction does not terminate" but "pattern mismatch" in your fix example?
09:20:35 <defcon8> what happens there?
09:20:44 <ihope> alar: if it were a pattern mismatch, it'd say so:
09:20:50 <defcon8> yes i get that ihope
09:20:51 <ihope> > (\(x:xs) -> 3) []
09:20:52 <lambdabot>  Non-exhaustive patterns in lambda
09:21:07 <defcon8> can you give me an example please?
09:21:23 <ihope> length (1:[2,3]) = 1 + length [2,3]
09:21:35 <davidhouse> > (\(x:xs) -> "first: " ++ x ++ "; rest: " ++ xs) ["a", "b", "c"]
09:21:36 <lambdabot> Couldn't match `Char' against `[a]'
09:21:36 <tibbe> character encoding are a pain
09:22:05 <davidhouse> > (\(x:xs) -> "first: " ++ x ++ ";") ["a", "b", "c"]
09:22:07 <defcon8> ihope can you give an example with different numbers?
09:22:07 <lambdabot> "first: a;"
09:22:19 <davidhouse> > (\(x:xs) -> "first: " ++ (show x) ++ ";") [1, 2, 3]
09:22:21 <lambdabot> "first: 1;"
09:22:30 <ihope> length (5:[7,3,7]) = 1 + length [7,3,7]
09:22:32 <ihope> > (\(x:xs) -> "first: " ++ x ++ "; rest: " ++ concat xs) ["a", "b", "c"]
09:22:33 <lambdabot> "first: a; rest: bc"
09:23:09 <defcon8> ok
09:23:22 <davidhouse> it basically attempts to match the pattern x : xs against the list. x : xs just means "something : some list", and the first something it finds is the first item in the list.
09:23:28 <davidhouse> so x gets bound to the first item, and xs the rest
09:23:40 <xerox> Phew.
09:23:47 <xerox> The new router works, *fireworks*.
09:24:09 <davidhouse> > (\(x:y:z) -> "first:" ++ x ++ "; second: " ++ y ++ "; rest: " ++ concat z) ["a", "b", "c", "d", "e"]
09:24:11 <lambdabot> "first:a; second: b; rest: cde"
09:24:19 <ihope> > (\(x:xs) -> x) [1,2,3]
09:24:20 <lambdabot> 1
09:24:22 <ihope> > (\(x:xs) -> xs) [1,2,3]
09:24:23 <lambdabot> [2,3]
09:24:28 <twobitsprite> > cycle ["lol"]
09:24:30 <lambdabot> ["lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","
09:24:30 <lambdabot> lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","
09:24:30 <lambdabot> lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","
09:24:30 <lambdabot> lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","
09:24:30 <lambdabot> lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","lol","
09:24:31 <lambdabot> [24 @more lines]
09:24:32 <alar> ah
09:24:46 <ihope> > take 20 (cycle "lol")
09:24:46 <lambdabot> "lollollollollollollo"
09:25:09 <alar> pattern mismatch against unknow value is not pattern mismatch
09:25:11 <twobitsprite> > cycle "rada"
09:25:12 <lambdabot> "radaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradara
09:25:12 <lambdabot> daradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradar
09:25:12 <lambdabot> adaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradarada
09:25:12 <lambdabot> radaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradarad
09:25:12 <lambdabot> aradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradaradara
09:25:14 <lambdabot> [23 @more lines]
09:25:14 <alar> now I see
09:25:19 <davidhouse> > intersperse ' ' $ repeat "stop spamming lambdabot!"
09:25:20 <lambdabot> Couldn't match `Char' against `[Char]'
09:25:20 <alar> @karma+ ihope
09:25:21 <lambdabot> ihope's karma raised to 3.
09:25:37 <twobitsprite> @karma+ twobitsprite
09:25:38 <davidhouse> > intersperse ' ' $ concat $ take 20 $ repeat "stop spamming lambdabot!"
09:25:39 <lambdabot> You can't change your own karma, silly.
09:25:39 <lambdabot> "s t o p   s p a m m i n g   l a m b d a b o t ! s t o p   s p a m m i n
09:25:39 <lambdabot> g   l a m b d a b o t ! s t o p   s p a m m i n g   l a m b d a b o t ! s
09:25:39 <lambdabot> t o p   s p a m m i n g   l a m b d a b o t ! s t o p   s p a m m i n g
09:25:39 <lambdabot> l a m b d a b o t ! s t o p   s p a m m i n g   l a m b d a b o t ! s t o
09:25:40 <lambdabot> p   s p a m m i n g   l a m b d a b o t ! s t o p   s p a m m i n g   l a
09:25:42 <lambdabot> [8 @more lines]
09:25:44 <davidhouse> oh, never mind.
09:25:53 <davidhouse> > concat $ take 20 $ repeat "stop spamming lambdabot! "
09:25:53 <twobitsprite> heh... sorry :P
09:25:54 <lambdabot> "stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:54 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:54 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:54 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:54 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:56 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! stop spamming lambdabot!
09:25:58 <lambdabot> stop spamming lambdabot! stop spamming lambdabot! "
09:26:05 <xerox> sigh.
09:26:09 <davidhouse> sorry.
09:26:11 <davidhouse> that is all.
09:26:28 <ihope> > take 50 $ unwords $ repeat "stop spamming lambdabot!"
09:26:30 <lambdabot> "stop spamming lambdabot! stop spamming lambdabot! "
09:26:41 <twobitsprite> @type unwords
09:26:42 <lambdabot> [String] -> String
09:27:22 <ihope> > unwords ["like","this"]
09:27:23 <lambdabot> "like this"
09:27:40 <twobitsprite> @type words
09:27:41 <lambdabot> String -> [String]
09:27:44 <davidhouse> > words "the opposite of words"
09:27:46 <lambdabot> ["the","opposite","of","words"]
09:27:47 <twobitsprite> > words "something else"
09:27:49 <lambdabot> ["something","else"]
09:27:49 <davidhouse> > unwords $ words "the opposite of words"
09:27:49 <twobitsprite> yeah
09:27:50 <lambdabot> "the opposite of words"
09:28:07 <Cale> > unwords $ words "the     opposite   of         words"
09:28:08 <lambdabot> "the opposite of words"
09:28:25 <ihope> > words "              "
09:28:25 <lambdabot> []
09:28:38 <twobitsprite> > "malformed string?
09:28:39 <lambdabot>  lexical error in string/character literal
09:28:44 <davidhouse> > words "                     "
09:28:45 <twobitsprite> @type "
09:28:45 <lambdabot> []
09:28:46 <lambdabot> lexical error in string/character literal
09:29:04 <roconnor> words $ unwords ["the","opposite"," ","of","words"]
09:29:08 <roconnor> > words $ unwords ["the","opposite"," ","of","words"]
09:29:09 <lambdabot> ["the","opposite","of","words"]
09:29:36 <twobitsprite> why does words accept a single quotation mark?
09:29:56 <roconnor> twobitsprite: it doesn't.
09:30:04 <roconnor> > words "
09:30:05 <lambdabot>  lexical error in string/character literal
09:30:19 <ihope> @type "
09:30:20 <lambdabot> lexical error in string/character literal
09:30:22 <twobitsprite> why did it work for ihope?
09:30:27 <davidhouse> > (iterate (unwords.words) "the oppostite of words")!!10
09:30:28 <lambdabot> "the oppostite of words"
09:30:37 <ihope> twobitsprite: what worked?
09:30:41 <davidhouse> > words ""
09:30:42 <roconnor> twobitsprite: there is another quote mark a few spaces away
09:30:43 <twobitsprite> ohh... n/m... didn't see the matching one because of the space
09:30:43 <lambdabot> []
09:30:50 <twobitsprite> (damn transpanancy
09:30:51 <twobitsprite> )
09:31:02 <Cale> hehe
09:31:25 <palomer> Cale: any idea how to turn ML into system F?
09:32:06 <twobitsprite> [words y | y <- ["foo","bar"]]
09:32:11 <twobitsprite> > [words y | y <- ["foo","bar"]]
09:32:13 <lambdabot> [["foo"],["bar"]]
09:32:21 <twobitsprite> > [unwords y | y <- ["foo","bar"]]
09:32:23 <lambdabot> Couldn't match `String' against `Char'
09:33:04 <davidhouse> > words [ y ++ " " | y <- ["foo", "bar"]]
09:33:06 <lambdabot> Couldn't match `Char' against `[Char]'
09:33:17 <twobitsprite> > [unwords [x,y] | x <- ["quux","bfl"], y <- ["foo","bar"]]
09:33:18 <lambdabot> ["quux foo","quux bar","bfl foo","bfl bar"]
09:33:22 <davidhouse> > unwords [ y ++ " " | y <- ["foo", "bar"]]
09:33:23 <lambdabot> "foo  bar "
09:33:25 <twobitsprite> > sequence [unwords [x,y] | x <- ["quux","bfl"], y <- ["foo","bar"]]
09:33:27 <lambdabot> ["qqbb","qqbf","qqbl","qqb ","qqbb","qqba","qqbr","qqfb","qqff","qqfl","
09:33:27 <lambdabot> qqf ","qqfb","qqfa","qqfr","qqlb","qqlf","qqll","qql ","qqlb","qqla","
09:33:27 <lambdabot> qqlr","qq b","qq f","qq l","qq  ","qq b","qq a","qq r","qqfb","qqff","
09:33:27 <lambdabot> qqfl","qqf ","qqfb","qqfa","qqfr","qqob","qqof","qqol","qqo ","qqob","
09:33:27 <lambdabot> qqoa","qqor","qqob","qqof","qqol","qqo ","qqob","qqoa","qqor","qubb","
09:33:29 <lambdabot> [24 @more lines]
09:33:47 <davidhouse> i think there should be a law about using take $.
09:33:55 <davidhouse> or shorten how much lambdabot prints
09:34:00 <davidhouse> (yeah, i know, i'm not one to talk)
09:34:32 <ihope> Yeah, just one line at first.
09:34:34 <twobitsprite> I didn't mean to spam... I've just now seen "sequence" used in some tutorial and was playing with it
09:34:45 <twobitsprite> 2 lines would work...
09:34:50 <ihope> Unless the reply's in a private message.
09:35:14 <sjanssen> I like that idea
09:35:28 <sjanssen> first line to channel, next few lines in P.M.
09:35:34 <twobitsprite> anyone know of a more complete reference than Zvon?
09:35:48 <twobitsprite> sjanssen: no... bots should never initiate a pm
09:35:50 <davidhouse> nah.
09:35:59 <sjanssen> twobitsprite: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
09:36:00 <ihope> twobitsprite: why not?
09:36:10 <davidhouse> first line in channel, @more available. uneless the whole thing is in a PM, then print 5 or however many
09:36:26 <twobitsprite> ihope: what davidhouse 
09:36:28 <twobitsprite> ... said
09:36:41 <ndm> twobitsprite: hoogle
09:36:46 <ndm> @where hoogle
09:36:48 <lambdabot> http://www.haskell.org/hoogle
09:36:59 <ihope> twobitsprite: did he say something about bots initiating conversations?
09:37:18 <twobitsprite> ihope:  davidhouse> first line in channel, @more available. uneless the whole thing is in a PM, then print 5 or however many
09:37:41 <ihope> Yes, but I'm wondering why bots shouldn't initiate conversations.
09:37:51 <davidhouse> ihope, what, are you /ignore'ing me? ;)
09:37:52 <twobitsprite> i.e. if I pm lambdabot with a query, it can pm me back with a long result... otherwise if its in a channel, just display one line
09:38:13 <twobitsprite> ihope: I just don't see the point
09:39:17 <twobitsprite> ihope: I think lambdabot should be for demonstration purposes only within the channel... if I really wanted to evaluate something and get a long result, I'd dump it in my repl
09:40:01 <twobitsprite> ?
09:40:18 <sjanssen> what a sad way to a conversation
09:40:31 <sjanssen> insert an end in that comment somewhere
09:44:54 <twobitsprite> bleh... I'm trying to find a definition/explanation of the sequence function and can't find it anywhere
09:45:11 <davidhouse> it takes a list of monadic actions and executes them
09:45:26 <davidhouse> ...is a good way of thinking about it when you're working in monads with side-effects
09:45:37 <twobitsprite> > sequence ["aaa","bbb","ccc"]
09:45:38 <lambdabot> ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","
09:45:38 <lambdabot> abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","
09:45:38 <lambdabot> abc","abc","abc"]
09:45:50 <davidhouse> e.g. "sequence $ replicate 5 getLine" will take read 5 lines from the user
09:46:16 <twobitsprite> how does that correspond to the command I just ran?
09:46:27 <sjanssen> twobitsprite: do you understand the list monad?
09:46:37 <twobitsprite> sjanssen: no, that's what I'm trying to grok right now
09:46:56 <Igloo> This might make more sense to you:
09:47:04 <Igloo> > sequence ["ab", "cd", "efg"]
09:47:06 <lambdabot> ["ace","acf","acg","ade","adf","adg","bce","bcf","bcg","bde","bdf","bdg"]
09:47:37 <twobitsprite> yeah... its like counting
09:47:52 <twobitsprite> > sequence ["01","01"]
09:47:53 <lambdabot> ["00","01","10","11"]
09:48:09 <twobitsprite> I just don't know how/why it works like that
09:48:46 <shapr> Um.. anyone know if I need to charge value added tax to overseas clients?
09:48:47 <jethr0_> > do {x <- "01"; y <- "01"; return [x,y]}
09:48:48 <lambdabot> ["00","01","10","11"]
09:49:27 <twobitsprite> hmm.... so it's like an "inner-loop" per element in each of the lists...?
09:49:40 <sjanssen> twobitsprite: yes
09:49:59 <jethr0_> sequence is similar to folding (>>=) over a list
09:50:14 <jethr0_> "01" >>= \a -> "01" >>= \b -> return [a,b]
09:50:16 <twobitsprite> jethr0_: I don't understand >>=
09:50:17 <jethr0_> > "01" >>= \a -> "01" >>= \b -> return [a,b]
09:50:18 <lambdabot> ["00","01","10","11"]
09:50:48 <sjanssen> do you understand do syntax?
09:50:50 * twobitsprite reads and re-reads that code
09:50:51 <jethr0_> twobitsprite: you should definitely look into (>>=) first before "sequence"
09:51:05 <twobitsprite> sjanssen: I know it's like begin/end in other langauges..., right?
09:51:19 <sjanssen> twobitsprite: no
09:52:50 * twobitsprite massages his temples
09:53:08 <sjanssen> are you learning from a tutorial?
09:53:13 <twobitsprite> trying to
09:53:18 <jethr0_> do-notation is just syntactic sugar for the monadic combinators (>>=) and (>>)
09:53:46 <twobitsprite> so...
09:54:08 <jethr0_> so, "a >>= b" would translate to "do {x <- a; b x}"
09:54:16 <twobitsprite> > x <- "01" >>= y <- "01" >>= return [x,y]
09:54:17 <jethr0_> and "a >> b" to "do {a; b}
09:54:17 <lambdabot>  parse error on input `<-'
09:54:38 <twobitsprite> ewr
09:54:44 <jethr0_> twobitsprite: you can't mix it as easily as that
09:54:57 <mauke> you can't use <- outside do
09:55:08 <twobitsprite> mauke: except in coprehentions?
09:55:21 <twobitsprite> or is that sugar for do?
09:55:22 <jethr0_> twobitsprite: list comprehension are syntactic sugar for do-notation :)
09:55:25 <mauke> yep :-)
09:55:47 <twobitsprite> ok... I definately think I grok comps... so maybe I can work backwards from there...
09:55:54 <jethr0_> > do {x <- "ab"; y <- "cd"; return [x,y]}
09:55:55 <lambdabot> ["ac","ad","bc","bd"]
09:56:06 <jethr0_> > [[x,y] | x <- "ab", y <- "cd"]
09:56:08 <lambdabot> ["ac","ad","bc","bd"]
09:56:15 <twobitsprite> ok
09:56:17 <mauke> > do { x <- [0..9]; guard (x `mod` == 0); return x }
09:56:18 <lambdabot>  parse error on input `=='
09:56:25 <mauke> > do { x <- [0..9]; guard (x `mod` 2 == 0); return x }
09:56:26 <lambdabot> [0,2,4,6,8]
09:56:43 <twobitsprite> waitr
09:56:46 <jethr0_> twobitsprite: but monads are more general. list comprehensions are only about the list monad.
09:56:58 <davidhouse> how is sequence defined?
09:57:09 <twobitsprite> > [x | x <- [0..9], x `mod` 2]
09:57:10 <lambdabot>  add an instance declaration for (Integral Bool)
09:57:10 <lambdabot>   In a list comprehension: x `mod` 2
09:57:10 <lambdabot>   In the definition of `sdf': sdf = [x | x <- [0 .. 9], x `mod` 2]
09:57:13 <twobitsprite> er
09:57:42 <mauke> the == 0 isn't optional there :/
09:57:43 <twobitsprite> jethr0_: well.. let me work with the list monad for now, then I'll generalize my knowledge onto the other stuff
09:57:51 <twobitsprite> > [x | x <- [0..9], x == x `mod` 2]
09:57:53 <lambdabot> [0,1]
09:57:55 <jethr0_> sequence (x:xs) = do a <- x; return a:sequence xs
09:58:02 <twobitsprite> > [x | x <- [0..9], 0 == x `mod` 2]
09:58:03 <lambdabot> [0,2,4,6,8]
09:58:06 <twobitsprite> ahh ha
09:58:18 <davidhouse> '
09:58:22 <davidhouse> @index sequence
09:58:23 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
09:58:23 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
09:58:23 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
10:10:30 <neologism>  >[0,2..9]
10:10:36 <neologism> > [0,2..9]
10:10:37 <lambdabot> [0,2,4,6,8]
10:11:31 <mauke> > [' ', '%' .. '~']
10:11:33 <lambdabot> " %*/49>CHMRW\\afkpuz"
10:12:26 <mauke> man, Haskell should allow me to change the type of comprehension guards
10:13:08 <jethr0_> mauke: what type besides bool would make sense for a guard?
10:13:17 <mauke> (Boolean a) => a
10:14:01 <jethr0_> \type True
10:14:02 <lambdabot> Bool
10:14:50 <jethr0_> mauke: i don't know where "Boolean" is defined
10:14:58 <mauke> in my module :(
10:15:09 <jethr0_> mauke: what makes it differ from Bool?
10:15:20 <mauke> class Boolean a where toBool :: a -> Bool
10:15:35 <jethr0_> so, just put a "toBool" into the guards
10:15:48 <mauke> it also defines instances for Bool, [a], Maybe a, () and Integer
10:16:08 <mauke> that kind of defeats the point
10:16:10 <defcon8> hello
10:16:21 <defcon8> can anyone tell me what is wrong with http://pastebin.com/603837 ?
10:16:34 <kosmikus>  /win 11
10:16:57 <mauke> defcon8: what's the error message? is it about indentation?
10:17:06 <jethr0_> defcon8: two ideas. parens around (-1), and indentation for the the second else
10:17:23 <defcon8> anyone?
10:17:37 <mauke> ARGH
10:17:38 <jethr0_> defcon8: ah, maybe indentation of the first else two
10:17:48 <jethr0_> *too
10:18:13 <defcon8> can someone paste the correct please?
10:18:18 <jethr0_> defcon8: the "else" should generally be equally indented as the corresponding "then"
10:18:44 <jethr0_> defcon8: i've just written 4 messages addressed to you, what more do you expect????
10:19:08 <defcon8> could you correct what i pasted it and paste the link?
10:19:22 <mauke> http://pastebin.com/603847
10:19:23 <cmarcelo> is this the right way to implement a "strict" factorial: http://pastebin.com/603844 ? i'm comparing with another version, without the $!'s and the memory usage seems to be the same =|
10:19:59 <Igloo> defcon8: What makes you think there's something wrong with it?
10:20:01 <mauke> I think the right way is product [1..n]
10:20:14 <jethr0_> http://pastebin.com/603848
10:21:50 <jethr0_> defcon8: and as igloo already said it worked in ghci with your version too
10:22:26 <jethr0_> except for the fact that signum is already declard in GHC.Num, so you'd have to use Main.signum to refer to it
10:22:50 <defcon8> mauke can you paste the correct way of what i was trying to do?
10:22:53 <defcon8> with if and else
10:23:04 <Igloo> defcon8: What makes you think there's something wrong with it?
10:23:12 * jethr0_ gives up
10:23:13 <mauke> defcon8: STOP IGNORING THIS CHANNEL
10:23:19 <bolrod> ?
10:24:26 <jethr0_> i don't get why people bother asking when they don't even seem to possess any means of noticing answers to them
10:24:45 <bolrod> @arr
10:24:46 <lambdabot> Aye
10:24:58 <mauke> @vixen do you love me? :(
10:24:59 <lambdabot> i wouldn't say i do love...
10:25:21 <SyntaxNinja> @arr
10:25:21 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
10:25:22 <bolrod> @vixen do you love mauke ?
10:25:23 <lambdabot> i wouldn't say i do love...
10:25:28 <bolrod> oh
10:25:35 <jethr0_> @vixen can you tell me what's wrong with my if-then-else indentation?
10:25:36 <lambdabot> that's all
10:26:00 <bolrod> @vixen tru
10:26:01 <lambdabot> :)
10:26:08 <bolrod> @botsnack
10:26:08 <lambdabot> :)
10:26:12 <bolrod> ok.. back to normal life
10:26:25 <mauke> > reverse "):"
10:26:26 <lambdabot> ":)"
10:26:48 <bolrod> > reverse ":C"
10:26:49 <lambdabot> "C:"
10:27:01 <jethr0_> @vixen ok, back to normal life
10:27:02 <lambdabot> just ok?
10:27:09 <jethr0_> @vixen back to normal life...
10:27:10 <lambdabot> Crazy little wanker!
10:27:17 <bolrod> O_O!
10:27:46 <bolrod> @arr
10:27:46 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
10:28:14 <twobitsprite> the clap??
10:28:39 <bolrod> @arr
10:28:40 <lambdabot> I heard andersca is a pirate
10:28:43 <jethr0_> Gonorrhoea?
10:29:04 <twobitsprite> I thought it was chlemidia(sp?)
10:29:28 <jethr0_> twobitsprite: i was just googling :)
10:29:50 <jethr0_> clap, clap, clap
10:30:01 <bolrod> @vixen clap
10:30:02 <lambdabot> i find it hard to masturbate when the lights are on.
10:30:09 <jethr0_> ^_^
10:30:14 <bolrod> :)
10:30:16 <twobitsprite> lmao
10:30:16 <palomer>  eh!
10:30:31 <twobitsprite> @vixen quite the nympho, aren't you?
10:30:32 <lambdabot> what about me?
10:30:36 <jethr0_> @vixen what's new in california?
10:30:37 <lambdabot> i dunno...
10:30:49 <twobitsprite> @vixen do you like cheesecake?
10:30:51 <jethr0_> @vixen how is arnold holding up?
10:30:52 <lambdabot> sure, i definitely don't hate
10:30:52 <lambdabot> how? it depends...
10:31:11 <twobitsprite> @vixen where do you live?
10:31:12 <lambdabot> Huntington Beach California
10:31:18 <jethr0_> @vixen asl?
10:31:19 <lambdabot> 19/f/California
10:31:24 <bolrod> lawl
10:31:33 <bolrod> @vixen omg
10:31:33 <lambdabot> I consider rabits as an endangered species.
10:31:51 <ValarQ> what the heck?
10:32:10 <jethr0_> @vixen bolrod seems to be more than just a little amused by you
10:32:11 <lambdabot> I'm stroking my hard cock as we speak...
10:32:16 <jethr0_> *cough*
10:32:23 <bolrod> urh
10:32:30 <bolrod> I dont see that going to gether with the asl part
10:32:32 <bolrod> O_O
10:32:37 <jethr0_> that's what i call "falling out of character"
10:32:59 <mauke> @vixen are you a trap?
10:33:00 <lambdabot> i truely am
10:33:04 <ValarQ> :)
10:33:13 <jethr0_> @vixen you little tramp
10:33:14 <lambdabot> hey, what's in a jack and coke anyhow?
10:33:16 <cmarcelo> mauke, product [1..n] seems to work, but i'm trying to understand how to "force" haskell to do the tail recursion..
10:33:19 <bolrod> @vixen you want to cyber with jethr0_ ?
10:33:20 <lambdabot> do i wanna cyber? i never have... teach me how
10:33:29 <jethr0_> bolrod: i don't think so
10:33:59 <bolrod> :)
10:34:18 <bolrod> @vixen are you actually a 40 year old man in a midlife crisis?
10:34:19 <lambdabot> do i seem to have a deep voice? nope, all woman here
10:34:25 <bolrod> hahaha
10:37:18 <bolrod> well..  
10:37:30 <bolrod> back to installing a WINDOWS system
10:37:32 <bolrod> arg
10:39:23 <Cale> palomer: nope, I'm really not very familiar with either.
10:47:46 <ncalexan> lisppaste: help
10:47:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:48:07 <lisppaste2> ncalexan pasted "Monad stacks" at http://paste.lisp.org/display/17909
11:08:20 * palomer loves twelf
11:16:50 <ncalexan> @karma+ Cale
11:16:50 <lambdabot> Cale's karma raised to 6.
11:18:06 <jethr0_> @karma+ Cale
11:18:07 <lambdabot> Cale's karma raised to 7.
11:18:28 <palomer> the twelf solver sucks:O
11:18:35 <palomer> ski: you around?
11:18:37 <ncalexan> That's a little about face.
11:20:48 <palomer> what is?
11:21:14 <ncalexan> • palomer loves twelf ==> the twelf solver sucks
11:21:31 <palomer> I still love it
11:21:38 <ncalexan> Fair enough :)
11:22:50 <palomer> hrmmm, who was the one who had used twelf in this channel
11:22:51 <palomer> ...
11:23:03 * xerox goes wireless!
11:25:08 <ct16k> hy every one... haskell noob here, with haskell silly noob question :"> could you please tell me how do i make a conversion from char to double without geting an error? (I obviously don't know to google to much either, cause it's been giving me a headache for the past hour)
11:25:49 <xerox> > read "2.2" :: Double
11:25:51 <lambdabot> 2.2
11:26:00 <ct16k> tried that
11:26:01 <jethr0_> > (fromIntegral . ord 'c' :: Double)
11:26:02 <lambdabot> Couldn't match `Int' against `t -> t1'
11:26:08 <jethr0_> > ((fromIntegral . ord) 'c' :: Double)
11:26:09 <ct16k> and i get
11:26:10 <lambdabot> 99.0
11:26:27 <ct16k> Instance of Integral Double required for definition of mypolishparse
11:26:45 <ncalexan> ct16k: good starting exercise, RPN calculator?
11:26:45 <xerox> ct16k: maybe it's due to the context, may you show us more?
11:26:48 <sinfinity> should this set k to a Char or a Key: do k <- getKey 
11:27:02 <ncalexan> @type getKey
11:27:03 <lambdabot> Not in scope: `getKey'
11:27:08 <ncalexan> @type System.IO.getKey
11:27:09 <lambdabot> Not in scope: `System.IO.getKey'
11:27:14 <ncalexan> @index getKey
11:27:15 <lambdabot> Graphics.HGL.Utils, Graphics.HGL, Graphics.SOE
11:27:21 <ncalexan> @index getChar
11:27:22 <lambdabot> System.IO, Prelude
11:27:32 <ncalexan> @type getChar
11:27:33 <lambdabot> IO Char
11:27:49 <jethr0_> ct16k: taking it from the error message, the "read" works just fine, you just use the double as an integral lateron without "casting"
11:27:52 <sinfinity> @type Graphics.HGL.getKey
11:27:53 <lambdabot> Graphics.HGL.X11.Window.Window
11:27:53 <lambdabot>         -> IO Graphics.HGL.X11.Types.Key
11:27:55 <jethr0_> but without more code that's hard to say
11:28:22 * xerox sings the wireless song
11:28:24 <ct16k> this is the line that causes the error
11:28:31 <ct16k> "                 otherwise = mypolishparse xs [read x::Double]"
11:28:46 <xerox> Then the trouble is in the definition of mypolishparse.
11:29:05 <ct16k> mypolishparse::[[Char]]->[Double]->Double
11:29:21 <jethr0_> @type read
11:29:22 <lambdabot> forall a. (Read a) => String -> a
11:29:39 * ncalexan sings the wired baseline to xerox's wireless solo...
11:30:12 <xerox> It's cool, 99% signal upstairs, the ap is downstairs!
11:30:13 <sinfinity> ok, and what is up with 'last generator in do must be an expression'
11:30:15 <sinfinity> I am using hugs by the way
11:30:16 <jethr0_> ct16k: what kind of "chars" are we talking about here?
11:30:30 <xerox> ct16k: the _definition_, that is the type-signature.
11:30:54 <jethr0_> ct16k: and usually error messages come with line/column positions :)
11:31:01 <xerox> jethr0_++
11:31:22 <ct16k> yup, it did come so... line 51, quoted above :)
11:31:34 <xerox> Could you show us the definition?
11:31:41 <ct16k> i thought of making a simple evaluator for expresions in post-fixed polish form
11:31:43 <ct16k> sure
11:31:47 <jethr1> xerox: please don't do that ^_^
11:31:55 <xerox> Hah.
11:32:06 * xerox tips his hat
11:32:13 <musasabi> record syntax GADTs will be only available in GHC 6.6 ?
11:32:29 <xerox> musasabi: sounds interesting, how does it look?
11:33:20 <musasabi> http://www.haskell.org/hawiki/GADT_20with_20record_20syntax
11:33:42 <ct16k> btw, i'm using WinHugs for now (this is about my third session...)
11:33:42 <xerox> Thanks!
11:33:56 <ct16k> so... this is just about all of the mypolishparse in the sourcecode
11:33:58 <ct16k> mypolishparse::[[Char]]->[Double]->Double
11:33:59 <ct16k> mypolishparse [] xs2=head xs2
11:33:59 <ct16k> mypolishparse (x:xs) ys | x=="+"    = mypolishparse xs ([(ys!!1)+(ys!!0)]++(drop 2 ys))
11:33:59 <ct16k>                         | x=="-"    = mypolishparse xs ([(ys!!1)-(ys!!0)]++(drop 2 ys))
11:33:59 <ct16k>                         | x=="*"    = mypolishparse xs ([(ys!!1)*(ys!!0)]++(drop 2 ys))
11:33:59 <ct16k>                         | x=="/"    = mypolishparse xs ([(ys!!1)/(ys!!0)]++(drop 2 ys))
11:34:01 <ct16k>                         | x=="^"    = mypolishparse xs ([(ys!!1)^(ys!!0)]++(drop 2 ys))
11:34:02 <xerox> BOOM.
11:34:03 <ct16k>                         | otherwise = mypolishparse xs ([read x::Double]++ys)
11:34:05 <ct16k> mypolish::[Char]->Double
11:34:07 <ct16k> mypolish xs=mypolishparse (words xs) []
11:34:13 <xerox> lisppaste2: url
11:34:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:34:16 <jethr0> spam spam spam
11:34:27 <xerox> There is better if it exceedes... 3 lines?
11:34:55 <xerox> Gotta go dinner, seeya later, good luck with the code.
11:35:10 <musasabi> ct16k: that does not look pretty.
11:35:39 <ct16k> yeah, i know... i'm code in asm for a living, so functional programming is a very strange place for me for now
11:35:41 <musasabi> ct16k: you might want: parseBinOp :: String -> Maybe (Int -> Int -> Int)
11:35:41 <ncalexan> ct16k: instead of indexing, pattern match on ys as well.
11:35:58 <ncalexan> Ie (y1:y2:ys) and then your drop 2 ys is just ys...
11:36:20 <ncalexan> and you don't have all those !!0 !!1 cluttering things.
11:36:29 <ct16k> though of that, and the last line should then be ...++[y1]++[y2]++ys
11:36:40 <ct16k> which i thought was uglier :">
11:37:02 <ncalexan> How about stack@(y1:y2:ys)?  Then you have stack for [y1] ++ [y2] ++ ys.
11:37:05 <sieni> hmm... is static memory management feasible in the same sense as static typing?
11:37:17 <musasabi> sieni: partially at least.
11:37:19 <ncalexan> (That's an @ pattern; see the report if you want definitions.)
11:37:25 <musasabi> sieni: look for region inference.
11:37:34 <sieni> musasabi: I've heard of region inference
11:37:36 <ncalexan> sieni: perhaps see John Meacham's regions in Haskell page.)
11:37:59 <sieni> musasabi: I'm not sure if that amounts to the same thing as I was thinking
11:41:40 <sieni> I was just thinking about reference counting in a module hierarchy
11:42:40 <sieni> of course if you have strong references in both directions, you are screwed, since the neither of the object get their reference count to zero
11:43:11 <sieni> so the other option is that you have strong reference in one direction and weak reference in the other
11:43:51 <sieni> so is this obvious or what, but if you have a high-level module and a low level module: which one should hold the strong reference to the other?
11:46:26 <ncalexan> Neither can function without the other, right?  (Otherwise they wouldn't be mutually referenced.)  Doesn't that imply that it makes no difference?
11:47:15 <sieni> no.
11:47:42 <ncalexan> Then I'm misunderstanding what you mean by module.
11:48:07 <sieni> module or class or whatever
11:49:22 <musasabi> sieni: don't know much of that stuff unfortunately.
11:49:23 <sieni> I mean that you have a hierarchy of stuff, like you have a top level module, which is the application itself and then it provides or requires some services and those are some other modules
11:49:55 <sieni> and those depend on further things etc.
11:50:08 <ct16k> k.. I did the stacky thing, so it looks preetier know, but still, any suggestions how to correct the error? (because I'm not even sure I fully understand what causes it, but I blame it on the noob thingy)
11:50:12 <musasabi> How did the polymorphism story and foralls change in GHC6.5? I am getting  "Illegal polymorphic or qualified type" on code that works fine with 6.4.1
11:50:28 <ncalexan> ct16k: paste?
11:50:36 <ncalexan> lisppaste: help
11:50:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:51:24 <musasabi> I have the following:
11:51:25 <musasabi> type AnyEv a = forall st ev. Ev st ev a
11:51:40 <musasabi> newEmptyRef :: (Monoid t, Ref ref) => AnyEv (ref t)
11:51:42 <sieni> well, I would say that the lower level modules should hold the strong reference (and the higher level module should inform about his/her death and leave its memory areas for later use)
11:51:52 <ct16k> paste what?
11:51:57 <musasabi> and it complains from the newEmptyRef declaration.
11:52:14 <ncalexan> Your code, if you wanted help interpreting an error message.
11:52:37 <ncalexan> @type runRWST
11:52:38 <lambdabot> Not in scope: `runRWST'
11:52:42 <ncalexan> @index runRWST
11:52:43 <lambdabot> Control.Monad.RWS
11:52:50 <ncalexan> @type Control.Monad.RWS.runRWST
11:52:51 <lambdabot> forall w s a (m :: * -> *) r.
11:52:51 <lambdabot>           Control.Monad.RWS.RWST r w s m a -> r -> s -> m (a, s, w)
11:53:07 <ct16k> it's the above, already pasted, long one :">
11:53:25 <ct16k> it just has stack@(y1:y2:ys)
11:53:39 <ct16k> to make it look nicer
11:56:41 <ct16k> u want me to paste it again?
11:58:07 <shapr> use the pastbot
11:58:09 <shapr> pastebot
11:58:41 <ncalexan> lisppaste: help
11:58:41 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:58:52 <ct16k> and how do I do that? (tried the link, I get Proxy Error, reson: Error reading from remote server)
11:59:42 <defcon8> wow i managed to stay connected without getting disconnected
12:00:48 <ncalexan> ct16k: link works for me.
12:01:40 <shapr> ct16k: Is infelice really your last name?
12:02:00 <SyntaxNinja> @quote  defcon8 wow i managed to stay connected without getting disconnected
12:02:01 <lambdabot> defcon8 wow i managed to stay connected without getting disconnected hasn'
12:02:01 <lambdabot> t said anything memorable
12:02:08 <SyntaxNinja> @quote
12:02:08 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
12:02:14 <SyntaxNinja> hmm
12:02:14 <defcon8> :D
12:02:20 <ct16k> no, it's not
12:02:24 <ncalexan> @quote
12:02:25 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out
12:02:25 <lambdabot> right, "Hey, you know how you always have these bugs because what you
12:02:25 <lambdabot> thought was in the variable is not there?" And I get all of these nods of
12:02:25 <lambdabot> agreement. "Well, I've found a new language that solves that problem."
12:02:25 <lambdabot> Audience: "Ooooh! How?" Me: "There's no variables!" And then they all
12:02:26 <SyntaxNinja> @quote SyntaxNinja
12:02:27 <lambdabot> start moving away from me slowly....
12:02:29 <lambdabot>  I think that the compiler authors will fly here from England just to
12:02:31 <lambdabot> kill me if I did that
12:02:39 <shapr> ct16k: Is it a purposeful joke on felicitations?
12:03:04 <defcon8> but as you have seen, i keep getting disconnected
12:03:09 <ncalexan> @quote
12:03:09 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
12:03:27 <ct16k> i'm a little paranoid when it comes to irc, so i give as little info about me as possible. no, it's not that either. it's something
12:03:40 <ct16k> that would be read as "unhappy"
12:03:46 <ct16k> in frenglish :)
12:04:31 <shapr> ct16k: I thought so, unfelicitous means discouraging in English.
12:04:33 <palomer> hrmph
12:04:40 <palomer> anyone here ever used dependently typed systems?
12:04:50 <shapr> yeah
12:05:56 <palomer> ok, I have type constructors eval: exp -> exp -> type, of: exp -> tp -> type which stands for "exp has type tp", and I want to prove type preservation
12:06:40 <palomer> now, I would think the function that proves type preservation would be
12:06:55 <shapr> I'm doing my bookkeeping/accounts, I can't help much right now.
12:07:04 <palomer> tps: eval E V -> of E T -> of V T
12:07:21 <palomer> hrmph
12:08:26 <ct16k> nope, still not working... I think it may have something to do with me being behind two or three routers before leavin the LAN and accessing the Internet
12:08:49 <ct16k> is there a forum someplace where I could post this?
12:11:10 <shapr> ct16k: You could use the wiki.
12:17:26 <lightstep> what are the keys for epigram?
12:18:03 <ct16k> yes, I could. where exaclty should I post? In the SandBox, or is there a dedicated section? (can't seem to find one at a first look)
12:19:51 <lightstep> is there a key combo for elaborate, for example?
12:20:22 <kowey> tom moertel around, please?
12:20:41 <twobitsprite> fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
12:21:02 <twobitsprite> wouldn't (tail fib) always return [1,2,3,5...]?
12:21:15 <twobitsprite> ohh
12:21:18 <twobitsprite> wait, n/m
12:21:19 <twobitsprite> I see
12:23:51 <shapr> kowey: He's tmoertel when he's on.
12:23:57 <shapr> lightstep: The tutorial is nice.
12:24:06 <shapr> lightstep: And lots of demo code goes by on the epigram list as well.
12:24:22 <shapr> ct16k: I'd suggest the sandbox.
12:24:25 <kowey> thanks, shapr; was just going to thank him for pxsl
12:25:01 <alar> ndm: can you tell me what's the meaning of strange glyph that looks like T rotated 90 degrees?
12:25:23 <lightstep> shapr, i mean the key bindings. i don't know how to type those images into the xemacs box
12:25:36 <ndm> alar, i think its for type theory, a typing judgement
12:25:40 <ndm> but don't really have much idea
12:25:58 <alar> yes, it's for type theory
12:26:31 <shapr> lightstep: I don't remember. But swiert here on #haskell is part of the epigram dev team, you could ask him when he's around. I don't remember if there's more about keybindings on the mailing list.
12:27:06 <shapr> alar: I've seen it lots in "Types and Programming Languages" but I can't remember right now.
12:27:06 <lightstep> ok, thanks. meanwhile, i'll just try to get it
12:27:25 * shapr has a brain of only echoes at the moment.
12:27:33 <alar> oh
12:27:34 <integral> the one that looks like "|-"?  It's from logic.
12:27:36 <ncalexan> alar: it's pronounced turnstile, usually, and it A |- B
12:27:49 <alar> found an article with that glyph in wikipedia
12:27:51 <ncalexan> means that with the assumptions in A, you can make the judgement B.
12:27:57 <integral> Just remember that it's different from an implication :-)
12:28:20 <alar> ncalexan: what's the difference between |- and => ?
12:28:22 <ncalexan> integral: What exactly is the difference?
12:28:27 <ncalexan> alar: maybe I mis-spoke.
12:29:11 <integral> ncalexan: it's written differently :-)
12:29:26 <integral> so you've got different rules to deal with it when you're working formally
12:31:09 <ncalexan> Maybe http://plato.stanford.edu/entries/logic-substructural/ will clarify?
12:32:37 <vincenz> AHAAA
12:32:42 <vincenz> AHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaÂµ
12:32:54 <alar> @karma+ ncalexan
12:32:55 <lambdabot> ncalexan's karma raised to 1.
12:32:55 <jethr0> hi vince
12:32:58 <vincenz> hey
12:37:28 <sinfinity> in hugs... why do I keep getting "last generator in do must be an expression"
12:37:58 <jyp> a return () at the end
12:38:19 <jyp> add "return ()" at the end of the do-block
12:38:20 <sinfinity> was that added since Haskell School of Expression was written?
12:38:35 <jyp> I wouldn't know
12:38:51 <Lemmih> No, you probably made an indentation error.
12:39:06 <sinfinity> hm
12:39:37 * palomer slaps twelf
12:41:45 <palomer> @type read
12:41:46 <lambdabot> forall a. (Read a) => String -> a
12:42:00 <palomer> whoa.
12:42:55 <palomer> that's wicked cool
12:43:22 <palomer> dynamic typing is useful only in the FFI, right?
12:43:50 <sjanssen> palomer: I don't think anything about dynamic typing is tied to FFI
12:44:10 <SimonRC> What is the recommended way of indenting a case statement?
12:44:19 <SimonRC> ghci doesn't like what emacs has done to it
12:44:31 <shapr> xanavim: Lots of apple employees using Haskell?
12:45:18 <shapr> hiya vincenz 
12:45:52 <SimonRC> palomer: yes
12:46:36 <SimonRC> even then, a designer should really use one big data type
12:46:53 <SimonRC> the scheme type is something like:
12:47:05 <SimonRC> (hypothetically, from the C api for scheme)...
12:48:50 <sjanssen> how does one even get a Dynamic out of a foreign call?
12:48:53 <SimonRC> data SCM = SCM_Nil | SCM_Cons SCM SCM | SCM_String String | SCM_Integer Integer | SCM_Real Float | SCM_Vect (Array Int SCM) | ...
12:49:01 <SimonRC> sjanssen: dunno
12:49:34 <vincenz> hiya
12:49:42 <xanavim> shapr: I'm not an apple employee  :D
12:49:56 <xanavim> shapr: just visiting for the day
12:50:07 * xanavim is an apple developer
12:50:39 <palomer> SimonRC: one could still use Read in that case
12:50:55 <SimonRC> palomer: huh?
12:51:07 <SimonRC> I was continuing my previous line
12:51:48 <sjanssen> can you use class functions in dynamic?
12:52:03 <SimonRC> erm, sometimes
12:52:24 <palomer> maybe I should get better acquainted with Dynamic
12:52:42 <sjanssen> palomer: do you have a good reason to use it?
12:52:46 * SimonRC personally considers dynamic types to be heretical.  :-S  :-)
12:53:47 <palomer> nope, never used it either
12:54:23 <sjanssen> you probably don't want to use it, once you have, you lose all the safe, static properties of Haskell
12:54:47 <palomer> ok, someone give me a hard lambda term existence question
12:54:58 <palomer> like "find a lambda term t such that t x = t"
12:55:18 <palomer> @type let f x = f in f
12:55:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
12:55:18 <lambdabot>   Expected type: t
12:58:01 <shapr> xanavim: Still, quite nifty :-)
12:58:18 <shapr> xanavim: Are you new to #haskell, or just using a different nick?
13:01:39 <twobitsprite> I think I'm gaining half-litetacy for type classes... I think I'd be able to read them, but I don't think I'd be able to write them right now...
13:01:59 <twobitsprite> I think I'm having a hard time overloading the terminology in my head
13:02:25 <SimonRC> twobitsprite: you'll get it in the end
13:02:38 <mauke> type classes are just interface definitions
13:02:53 <twobitsprite> I see some parts that are analogous to OO terminology, but it doesn't seem to be a complete mapping
13:02:59 <SimonRC> mauke: erm, mostly
13:03:26 <twobitsprite> mauke, yeah, I think I see that partially... it's mostly the terms and syntax that are bothering me
13:04:10 <SimonRC> but they are parameterisable, and you can require conditions more accrately that in e.g. Java
13:04:26 <xanavim> shapr: I'm new to haskell
13:04:37 <xanavim> and #haskell  (:
13:05:07 <jethr0> twobitsprite: i'm not too sure that it's desirable to "overload" the terminology. just have them in parallel and let the "good" ideas influence each other. but uniting OO and FP paradigm is (at least for me) not necessarily desirable
13:06:11 <jethr0> it might keep you from thinking in FP, because the analogies might always foster OO solutions
13:06:11 <adu> does call/cc and monads fulfill similar use cases?
13:06:27 <twobitsprite> jethr0, I guess I meant "shadowing"
13:06:36 <jethr0> twobitsprite: i understood what you meant :)
13:06:46 <twobitsprite> jethr0, just being a smart-ass? :P
13:06:46 <jethr0> my wording wasn't as precise
13:07:27 <adu> FP = functional programming?
13:07:33 <bolrod> tru
13:07:49 <adu> then why not use FP and OOP? instead of OO?
13:07:54 <shapr> xanavim: Would you like the quick tour?
13:08:09 <jethr0> adu: yes, would be better. but i'm _so_ lazy :)
13:08:16 <twobitsprite> adu, or maybe the GOP? FDA?
13:08:17 <adu> hehe
13:08:23 <jethr0> also OO encompasses OOD, OOA, OOP
13:08:35 <adu> then use OO and F :)
13:08:42 <jethr0> right
13:08:59 <adu> or OO and Fn
13:09:26 <twobitsprite> would P be procedural?
13:09:33 <adu> sure
13:09:35 <adu> why not
13:09:56 <xanavim> shapr: sure
13:09:57 <jethr0> the Object Oriented Paradigm versus the Non-Strictly evaluated Functional Programming
13:10:13 <jethr0> twobitsprite: procedural is a really bad name, IMO
13:10:27 <shapr> xanavim: Ok! First stop on your left is the channel topic, including urls to the log files, recent announcements, that sort of thing.
13:10:34 <twobitsprite> jethr0, you prefer sequential?
13:10:53 <jethr0> i prefer imperative
13:11:06 <twobitsprite> jethr0, are they the same thing? 
13:11:22 <jethr0> twobitsprite: i don't know. what is procdural programming?
13:11:39 <twobitsprite> jethr0, I believe they tend to overlap, but I'm not sure it can be proven that all imperative languages are procedureal
13:11:51 <xanavim> shapr: ok, I bookmarked those yesterday, plan to read the log files  (:
13:11:54 <jethr0> i don't even know what procedural is supposed to be
13:11:56 <shapr> xanavim: Next there's the haskell.org website with many useful things including the Learning Haskell Page: http://www.haskell.org/learning.html and the wiki: http://www.haskell.org/haskellwiki/
13:12:02 <twobitsprite> jethr0, procedural would be like asm or basic
13:12:05 <jethr0> assembly is sequential, but has rather poor support for procedures
13:12:10 <jethr0> hmm
13:12:11 <shapr> xanavim: Last and niftiest is the channel bot, lambdabot!
13:12:19 <shapr> @vixen a/s/l 
13:12:20 <lambdabot> 19/f/California
13:12:26 <alar> =))
13:12:43 <shapr> Written entirely in Haskell, lambdabot is available for all sorts of thrills, chills, and type theory like you wouldn't believe!
13:12:52 <shapr> @listplugins
13:12:52 <lambdabot> Unknown command, try @listcommands.
13:12:54 <mauke> @vixen do you like type theory?
13:12:54 <SimonRC> twobitsprite: indeed, Brainfuck is imperative, but not procedural (see channel ##brainfuck)
13:12:55 <lambdabot> sure, i definitely don't hate
13:12:56 <shapr> err
13:12:57 <jethr0> languages like perl, basic and assembly have really bad support for creating new functions. but in the case of assembly i don't even hold that against it
13:13:09 <shapr> @listmodules
13:13:09 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
13:13:09 <lambdabot> help hoogle karma lambda localtime more pl plugs poll pretty quote search
13:13:09 <lambdabot> seen spell state system todo topic type unlambda version vixen where
13:13:11 <mauke> what!
13:13:25 <mauke> jethr0: I'd say perl has good support for creating functions
13:13:30 <twobitsprite> jethr0, I'm not sure that procedure == function...
13:13:38 <jethr0> mauke: yes, but the syntax is _very_ awkward
13:13:48 <jethr0> twobitsprite: i never said that
13:13:54 <mauke> jethr0: how so?
13:13:55 <SimonRC> jethr0: procedures are rarely pure, but functions can be
13:14:02 <shapr> xanavim: I usually suggest starting with the HaskellDemo ( http://www.haskell.org/hawiki/HaskellDemo ) on the oldwiki, and then checking out Hal Daume's "Yet Another Haskell Tutorial" 
13:14:10 <twobitsprite> jethr0, we're talking about procedural languages... I never said anything about functions
13:14:23 <jethr0> mauke: the "sub xyz {(a,b,c) = @_;}" idiom
13:14:25 <shapr> xanavim: lambdabot can directly eval Haskell as well, so she's good for teaching.
13:14:26 <alar> procedures is pascal word and functions is C word
13:14:32 <alar> that's all the difference
13:14:45 <jethr0> twobitsprite: yes, i'm often imprecise
13:14:50 <shapr> Originally, procedures meant functions with side-effects...
13:14:55 <mauke> ah, ok, parameters are kind of ugly
13:15:00 <jethr0> that's pascal's notion for example
13:15:26 <jethr0> mauke: apart from that perl is one of the most functionally capable mainstream languages out there
13:15:44 <twobitsprite> jethr0, it even supports currying, correct?
13:15:49 <mauke> on the other hand, perl's model of argument passing is very symmetric (unlike, say, C or Java)
13:15:56 <Excedrin> perl doesn't support currying
13:16:03 <mauke> Excedrin: it does
13:16:03 <jethr0> never tried, but HOFs, map, filter, ... are supported quite well
13:16:39 <xanavim> shapr: excellent, thanks!
13:16:40 <mauke> you can even do explicit tail calls :-)
13:16:53 <twobitsprite> you can have a "sub" with no formal parameters that simply uses $1, etc to get the "word" following its application...
13:17:06 * twobitsprite hasn't touched perl in a long time
13:17:17 <mauke> uh, no
13:17:28 <mauke> $_[1] is the second argument of that function
13:17:36 <mauke> nothing to do with words
13:17:38 <jethr0> ya, but it's not a nice abstraction IMO. you never really know which and how many parameters to pass (except for comments), ...
13:17:45 <mauke> true
13:17:50 * SimonRC wishes there were a Control.Monad.Random to save him from excessive wheel re-invention.
13:17:52 <shapr> xanavim: Have any questions?
13:18:09 <Excedrin> mauke: could you provide an example of currying in perl?
13:18:48 <mauke> my $add = sub { my $x = shift; sub { my $y = shift; $x + $y } };
13:18:52 <jethr0> http://perldesignpatterns.com/?CurryingConcept
13:18:53 <mauke> print $add->(2)->(2);
13:18:55 <jethr0> *yuch*
13:19:08 <Excedrin> oh, explicitly doing it doesn't count :P
13:19:13 <jethr0> hehe
13:19:35 <adu> shapr: i have a question
13:19:36 <twobitsprite> Excedrin, at least you _can_ explicitly do it... :P
13:19:54 <Excedrin> yes, but it's not supported
13:19:58 <jethr0> but you'd better not mess with @_ before constructing the curried rest
13:20:16 <jethr0> that's an evil artifact of the ugly parameter passing
13:20:33 <twobitsprite> aren't fixing that to be more elegant in perl6?
13:21:32 <shapr> adu: ask me!
13:21:42 <mauke> you think that's ugly? look at http://home.cs.tum.edu/~mai/add.txt !
13:22:01 <mauke> (note: I should "fix" the explicit recursion :-)
13:22:44 <jethr0> yes, that's certainly very pretty. maintainable, even
13:23:02 <jethr0> considering that it's not obfuscated
13:23:33 <Excedrin> all perl is obfuscated
13:23:39 <adu> no
13:23:47 <adu> most perl is tho
13:24:07 <Excedrin> yes, for values of "most" equal to "all"
13:24:21 <mauke> print "Hello, world!\n";  # not obfuscated
13:25:22 <Excedrin> that's pretty difficult to understand actually
13:25:37 <Excedrin> it's only a step away from Malbolge in my opinion
13:25:38 <jethr0> > print "Hello, world!\n"
13:25:40 <lambdabot> No IO allowed
13:25:59 <adu> Excedrin: no!... most != all
13:26:06 <mauke> what, you have problems with hello world?!
13:26:17 <adu> > "Hello World!"
13:26:18 <lambdabot> "Hello World!"
13:26:21 <adu> :)
13:27:31 <adu> does anyone here know about call/cc?
13:27:51 <jethr0> adu: to an extent
13:28:00 <jethr0> but i've never used it in haskell, yet
13:28:27 <TuringTest> adu: We know about call/cc
13:28:45 <adu> TuringTest: then are there similar uses for call/cc and Monads?
13:28:47 <xanavim> shapr: ah, yes.. is there a text editor with really good haskell support?  I use both vim and emacs, so I don't have a preference either way
13:29:02 <shapr> xanavim: haskell-mode 2.0 in emacs is decent.
13:29:16 <shapr> xanavim: What brings you to #haskell and Haskell? Personal interest?
13:29:16 <xanavim> shapr: great, I will look at that
13:29:26 <TuringTest> @type Control.Monad.Cont.runCont
13:29:27 <lambdabot> forall r a.
13:29:27 <lambdabot>           Control.Monad.Cont.Cont r a -> (a -> r) -> r
13:29:39 <xanavim> shapr: I would like to learn the language to broaden my knowledge of programming  (:
13:29:45 <TuringTest> adu: Control.Monad.Cont has a monad which implements call/cc
13:29:49 <mauke> Haskell is Perl: http://rafb.net/paste/results/US4UVZ75.html :-)
13:29:52 <shapr> For any nmap users here, please take the nmap survey in the next few hours! http://www.insecure.org/nmap/survey.html
13:30:08 <shapr> xanavim: This channel is a good place to do that.
13:30:10 <xanavim> shapr: and who knows, it may become for favorite development language  (:
13:30:10 <jethr0> adu: i think it's been argued that monads do implicit CPS (or sth like that)
13:30:13 <adu> TuringTest: oo
13:30:16 <xanavim> s/for/my
13:30:20 <jethr0> adu: but your question is a little general
13:30:25 <adu> jethr0: ah that makes sense
13:30:38 <jethr0> adu: i think call/cc is more powerful than monads
13:30:44 <adu> jethr0: i didn't want to be too specific and get into an argument over semantics
13:30:47 <TuringTest> adu: And there are monads that implement partial continuations as well.
13:31:15 <TuringTest> jethr0: cal//cc in Haskell is limited in scope to its continuation monad.  So it is not global like in Scheme
13:31:24 <jethr0> yes, i know
13:31:26 <shapr> xanavim: It's definitely mine. But we all choose whatever fits our head best.
13:31:54 <adu> hm
13:31:56 <adu> interesting
13:32:38 <jethr0> adu: but call/cc is really only applicable in _very_ special circumstances. usually people advocate that it's used only by library authors, because it's a b*tch to get right
13:33:02 <shapr> adu: Did you ever ask me a question?
13:33:17 <adu> shapr: my question was about call/cc and monads
13:33:20 <shapr> ah
13:33:25 <adu> so yes
13:33:41 <jethr0> whereas monads are applicable in many situations and much less "dangerous" to handle
13:34:11 <adu> jethr0: i agree, monads are much easier to use than call/cc
13:34:43 * twobitsprite grokked scheme's call/cc       much quicker than monads
13:35:43 <jethr0> if you were SCO, would you really name your open source based new product "SCAMP" (http://www.sco.com/products/mysql/scamp.html)?
13:35:55 <jethr0> scam scam scam
13:35:58 <sieni> jethr0: well, in scheme you can break referential transparency (i.e. in this case get access to a state) with letrec and call/cc, which shouldn't be possible in Haskell
13:36:19 <jethr0> sieni: i was talking about unbounded continuations
13:36:32 <jethr0> although i never made that clear :(
13:36:34 <adu> twobitsprite: but call/cc mainly handles the monad 'fail' method, it doesn't do 'bind' so much
13:36:53 <lisppaste2> ct16k pasted "mypolishparse" at http://paste.lisp.org/display/17915
13:36:59 <JKnecht> "scamp" sound open, free, and young. To throw you off from the fact they're bloodsucking parasites.
13:37:18 <ct16k> finally... :-<
13:37:20 <twobitsprite> adu, I'm not up to speed yet with monads to know what you mean... I'm just saying that I only took me a few minutes to work out the implications of call/cc and I'm still trying to figure out monads...
13:37:24 <jethr0> hehe, i don't perceive it as having those attributes. i sounds like a mixture of "tramp" and "scam" to me
13:37:46 <ct16k> I'd appreciate the support on the paste... :)
13:37:48 <JKnecht> and innovative. Scamp, rascal, rogue.
13:38:00 <jethr0> twobitsprite: you figured out call/cc in a few minutes??? you're my new god!
13:38:15 <twobitsprite> jethr0, it's like a first-class goto with arguments...
13:38:48 <sieni> jethr0: saying that "call/cc is more powerful than monads" is probably considered in Haskell circles equally relevant as "imperative programming is more powerful than functional programming"
13:38:48 <adu> i think its more like a 2-way goto
13:39:45 <sjanssen> ct16k: so what is the problem?
13:40:01 <ct16k> ERROR file:.\Lab3.hs:51 - Instance of Integral Double required for definition of mypolishparse
13:40:14 <jethr0> JKnecht: "to scamp" means "to botch something up" in english too :)
13:40:19 <ct16k> line 51 being the one with the read x
13:40:34 <sjanssen> ct16k: you use ** for exponentiation if the exponent is a double
13:40:53 <sieni> call/cc is like finding a box on the street and the box has a button and when you open it you see a message inside. But sometime in the future you can put another message inside the box, push the button and then everything is reset to the original finding of the box, except that the original message
13:41:01 <sieni> is replaced with the latter message
13:41:28 <jethr0> sieni: yes, i agree, but adu was asking "are there similar uses for call/cc and monads" and i was saying that unbounded continuations have a _very_ limited usage and are more powerful than monads.
13:42:05 <jethr0> sieni: i'm aware what continuations do. they have their uses, but those _very_ limited
13:42:21 <jethr0> like for the construction of coroutines for example
13:42:26 <sieni> can't you just dump your continuation (from the continuation monad) inside the state monad, if you want indefinite extent?
13:42:30 <adu> hmm
13:43:24 <jethr0> sieni: the point of continuations is that they encompass the _whole_ continuation, i.e. _everything_ that's going to happen lateron. the continuation monad can only represent what happens within it!
13:43:38 <jethr0> s/continuations/unbounded continuations/
13:43:57 <adu> huh, very interesting
13:45:03 <ct16k> that actually works... wow... thx. now I just have to figure out why the error was reported on the line with the read... :-L
13:45:17 <jethr0> http://www.cockeyed.com/citizen/creditcard/application.shtml :)
13:46:54 <jethr0> bbl
13:47:54 <twobitsprite> ((call-with-current-continuation call-with-current-continuation) (call-with-current-continuation call-with-current-continuation))
13:48:03 * twobitsprite loves that
13:48:31 <twobitsprite> can you do that with monads? :P
13:49:03 <sieni> jethr0: well, doesn't that mean that the so called delimited continuations are more powerful than full continuations, since you can decide, where to start capturing them. (and anyway, a continuation does not capture everything; you can e.g. modify global variables and those changes are visible to the continuation, when it's invoked)
13:49:35 <sieni> I'll go sleeping about now
13:49:48 <twobitsprite> sleeping about?
13:50:20 <sieni> let me rephrase that
13:50:33 <twobitsprite> :P
13:51:13 * twobitsprite pictures sieni sleep-walking around the channel
13:51:52 <twobitsprite> anyways... it's quittin' time... laterz
13:52:45 <sieni> good night
13:52:52 <Philippa> jethr0: if you really care about capturing /everything, main = runCont main'...
13:53:20 <sieni> (I have a naked chick in the bed)
13:53:32 <shapr> sieni: Hey, that's off-topic.
13:53:41 <sieni> shapr: oh, sorry
13:53:47 <shapr> But I have one too... ;-)
13:54:17 <sieni> shapr: come for a beer some time to Helsinki :-)
13:54:32 <ct16k> now, I have one more question, if it's not too much
13:54:45 <sieni> nighty nite
13:54:50 <shapr> Last time I drank beer in Helsinki...
13:55:15 * shapr just leaves it and goes to bed.
13:55:16 <lisppaste2> ct16k annotated #17915 with "mypolishparse" at http://paste.lisp.org/display/17915#1
13:55:21 <ct16k> how do I tidy up the code a bit to look like the first one?
13:55:51 <ct16k> I couldn't preserve the yall@... part because ys does not always have at least 2 elements
13:58:45 <Cale> a where clause would tidy that up significantly
14:01:08 <ct16k> good idea. 10q. hopefully I'll soon get the hang of it
14:01:57 <lisppaste2> Cale annotated #17915 with "tidied up" at http://paste.lisp.org/display/17915#2
14:02:20 <Cale> well, that's the first thing to do anyway :)
14:02:40 <Cale> [y]++ys = y:ys
14:03:01 <Cale> you can make that substitution in a couple of places
14:07:23 <ct16k> doing just y:ys doesn't help, as I need the first two elements of ys separately, or none of them. and doing y1:y2:ys (as I did the first time), causes an error when ys contains less then 2 elems
14:08:01 <ct16k> but "where" did very nice cleaning. I should really start using it more often
14:10:51 <lo> hello ct16k
14:12:04 <ct16k> hello
14:12:16 <lo> you done with rpn?
14:12:47 <ct16k> what exaclt does rpn stand for?
14:12:55 <sjanssen> reverse polish notation
14:12:55 <lo> reverse polish notation
14:13:02 <ct16k> oh :">
14:13:03 <ct16k> yes
14:13:28 <ct16k> i'm not too familiar with english mathematical terms
14:18:23 <davidhouse> if i wanted to find a definition for a function, where would be a good place to look?
14:18:26 <davidhouse> (i want sequence)
14:19:48 <jyp> davidhouse: http://darcs.haskell.org/packages/base/Control/Monad.hs ?
14:21:18 <davidhouse> thanks johs
14:21:21 <davidhouse> *jyp. sorry.
14:22:13 <ct16k> is (win)hugs more recommended for newbies, or should I just start using GHC now to avoid accomodation issues later?
14:25:04 <ndm> ct16k: i use winhugs all the time, its much faster than ghc at compiling
14:25:06 <ndm> @where winhugs
14:25:07 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
14:25:09 <jyp> ct16k: I started with ghci without any problem
14:28:35 <ihope> \unlambda
14:28:36 <lambdabot> unlambda: Parse error at end of file
14:28:40 <ihope> Yay!
14:28:45 <ihope> Yay! ```sii``sii
14:28:48 <ihope> Oops.
14:28:56 <ihope> \unlambda ```sii``sii
14:29:03 <lambdabot> Done.
14:29:11 <ihope> \unlambda i
14:29:12 <lambdabot> Done.
14:29:26 <ihope> \unlambda iii
14:29:27 <lambdabot> Done.
14:29:36 <TuringTest> \unlambda .f
14:29:36 <lambdabot> Done.
14:29:55 <ihope> \unlambda `.fi
14:29:55 <TuringTest> \unlambda ihope
14:29:56 <lambdabot> Done.
14:29:56 <lambdabot> f
14:30:09 <TuringTest> ihope: Ah..thats better...output
14:30:14 <ihope> \unlambda ````ihope
14:30:15 <lambdabot> unlambda: Unknown operator 'h'
14:30:32 <ihope> \unlambda `.nihope
14:30:33 <lambdabot> n
14:30:52 <jyp> \unlamdba .x
14:30:53 <lambdabot> Done.
14:30:55 <ihope> So "extra" characters are ignored?
14:31:23 <ct16k> k then... I'll stick with winhugs for now then, al least until I start doing something really useful in haskell (if that time comes)
14:33:42 <adu> \unlambda ``.N.oi
14:33:42 <lambdabot> No
14:34:03 <ihope> > length "I know this won't work"
14:34:05 <lambdabot> 22
14:34:19 <adu> it worked
14:34:31 <ihope> :-D
14:34:34 <davidhouse> ihope, why not?
14:34:36 <ihope> > length "\unlambda I know this won't work"
14:34:37 <lambdabot>  lexical error in string/character literal
14:34:45 <ihope> > length "\\unlambda I know this won't work"
14:34:47 <lambdabot> 32
14:35:37 <ihope> \unlambda ````````````````````````````````.\.u.n.l.a.m.b.d.a. .I. .k.n.o.w. .t.h.i.s. .w.o.n.'.t. .w.o.r.ki
14:35:38 <lambdabot> \unlambda I know this won't work
14:36:06 <davidhouse> :P
14:36:21 <davidhouse> lambdabot doesn't check its own messages
14:37:04 * davidhouse needs a new project
14:37:19 <davidhouse> something that will mix writing funky algorithms with some actual practical haskell
14:38:41 <davidhouse> /e] 
14:38:43 <davidhouse> err
14:38:57 * davidhouse thinks he should really finish reading up on monad transformers
14:42:39 <ct16k> well, thx for the support guys&gals, I'm going to bed now as I have to be @work in about 8 hours, but I'll be comming back with more noob questions for sure.
14:42:53 <ct16k> til' then b'bye
14:42:56 <ct16k> &have phun
14:42:57 <lambdabot> Not enough privileges
14:43:01 <davidhouse> should monad transformers pretty much be used every time i want one monad on top of another?
14:43:27 <TuringTest> davidhouse: That statement is qualified enough to be true.
14:43:57 <davidhouse> TuringTest: what do you mena?
14:43:59 <davidhouse> *mean
14:44:10 <TuringTest> "pretty much"
14:44:20 <ihope> @have
14:44:21 <lambdabot> Not enough privileges
14:44:29 * ihope laughs
14:44:53 <TuringTest> davidhouse: I like MonadTrans, Cale like MonadTrans,  MonadTrans is everyone's friend
14:45:15 <davidhouse> TuringTest: so... yes?
14:45:26 <TuringTest> What is the question?
14:45:56 <davidhouse> ah. earlier, when you said "that statement is qualified enough...", did you mean "not qualified enough"?
14:47:12 <TuringTest> I meant that you said "pretty much" which qualifies "every time" into meaning "sometimes".  And "should monad transformers sometimes be used" is true
14:47:38 <TuringTest> BTW: http://haskell.org/hawiki/MonadTemplateLibrary is excellent, including the good links at the bottom
14:56:22 <ihope> \oh
14:56:23 <lambdabot> Maybe you meant: . ghc id pl wn yow
14:56:38 <ihope> \spell the
14:56:39 <lambdabot> the
14:57:56 <ihope> @spell have
14:57:57 <lambdabot> have
14:57:59 <ihope> @spell hav
14:58:00 <lambdabot> Harv have Gav Ha ha
14:58:05 <ihope> @ha
14:58:06 <lambdabot> Maybe you meant: . faq ghc id map pl what wn
14:58:13 <ihope> @what
14:58:14 <lambdabot>  @where <key>, return element associated with key
14:58:52 <ihope> @help heavy
14:58:53 <lambdabot>  @help <command> - ask for help for <command>
14:58:55 <ihope> @help have
14:58:57 <lambdabot>  @help <command> - ask for help for <command>
14:59:42 <davidhouse> @arr
14:59:43 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
14:59:48 <davidhouse> hehe. pirates++
14:59:53 <ihope> :-)
15:00:04 <ihope> @. eval arr
15:00:06 <lambdabot>  Not in scope: data constructor `Cap'n'
15:00:15 <davidhouse> lol! :P
15:00:23 <ihope> @remember lambdabot Not in scope: data constructor `Cap'n'
15:00:24 <lambdabot> Done.
15:00:35 <davidhouse> it that quotes?
15:00:40 <ihope> Aye.
15:00:43 <ihope> @quote lambdabot
15:00:44 <lambdabot>  Not in scope: data constructor `Cap'n'
15:00:53 <davidhouse> @quote lambdabot
15:00:54 <lambdabot>  Occurs check: cannot construct the infinite type: a
15:01:02 <davidhouse> @quote lambdabot
15:01:03 <lambdabot>  Not in scope: data constructor `Cap'n'
15:01:11 <ihope> @. quote arr
15:01:12 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup. hasn't said
15:01:12 <lambdabot> anything memorable
15:01:32 <ihope> @quote lambdabot
15:01:33 <lambdabot>  Occurs check: cannot construct the infinite type: a
15:01:38 <ihope> Not much in there.
15:01:45 <ihope> And I added both those quotes 
15:01:48 <ihope> :-P
15:01:49 <davidhouse> @. (remember lambdabot) arr
15:01:51 <lambdabot> compose module failed: Parse error: "(remember"
15:01:54 <davidhouse> aww.
15:02:08 <ihope> @. remember lambdabot arr
15:02:09 <lambdabot> compose module failed: Parse error: "lambdabot"
15:02:21 <ihope> @. "remember lambdabot" arr
15:02:22 <lambdabot> compose module failed: Parse error: "\"remember"
15:03:18 <ihope> Maybe I should @. remember arr
15:03:23 <ihope> @arr something
15:03:25 <lambdabot> I'll crush ye barnacles!
15:03:38 <ihope> Hmm.
15:03:40 <ihope> @quote arr
15:03:41 <lambdabot> arr hasn't said anything memorable
15:03:49 <ihope> @remember
15:03:51 <lambdabot> Incorrect arguments to quote
15:04:05 <ihope> . remember quote
15:04:18 <ihope> @remember lambdabot
15:04:19 <lambdabot> Incorrect arguments to quote
15:07:40 <ihope> @\&?%
15:07:41 <lambdabot> Unknown command, try @listcommands.
15:08:53 <Lokadin_> say can anyone help me figure out why a function i made isn't working? :(
15:09:04 <Lokadin_> @lisp
15:09:06 <lambdabot> Unknown command, try @listcommands.
15:09:18 <Lokadin_> @YAHT
15:09:19 <lambdabot> Unknown command, try @listcommands.
15:09:23 <Lokadin_> YAHT
15:09:28 <Lokadin_> hmmm
15:09:31 <Lokadin_> !YAHT
15:09:36 <Lokadin_> @listcommands
15:09:37 <lambdabot> use listcommands [module|command]. Modules are:
15:09:37 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
15:09:37 <lambdabot> help hoogle karma lambda localtime more pl plugs poll pretty quote search
15:09:39 <lambdabot> seen spell state system todo topic type unlambda version vixen where
15:09:52 <Lokadin_> @where lisp
15:09:53 <lambdabot> I know nothing about lisp.
15:09:56 <Lokadin_> @where lisp2
15:09:57 <lambdabot> I know nothing about lisp2.
15:10:04 <Lokadin_> *sighs*
15:10:09 <Lokadin_> where is that paste thingy?
15:10:45 <ihope> @google lisppaste
15:10:47 <lambdabot> http://common-lisp.net/project/lisppaste/
15:10:54 <Lokadin_> o thanks :D
15:12:07 <bolrod> YAHT?
15:12:12 <bolrod> @arr
15:12:13 <lambdabot> I'll crush ye barnacles!
15:13:56 <lisppaste2> Lokadin pasted "file writing reading program" at http://paste.lisp.org/display/17920
15:14:17 <Lokadin_> basically though it complains about function getName
15:14:33 <Lokadin_> says it returns an IO String instead of a filepath
15:15:13 <ihope> getName "read" >>= doRead
15:15:16 <ihope> Try that.
15:15:33 <Lokadin_> kk thanks :) one sec
15:15:42 <bolrod> my gawd its cold outside O_o
15:15:58 <bolrod> and the spring starts next week!
15:16:04 <bolrod> hell... it still freezes
15:16:48 <Lokadin_> ihope:  alright :) it complied thanks
15:16:59 <Lokadin_> bolrod: :P not cold in toronto
15:17:11 <bolrod> -.-
15:17:28 <Lokadin_> and we are getting wireless city wide by october :D
15:17:42 <bolrod> ((-.-))
15:17:47 <Lokadin_> lol
15:17:53 <bolrod> we dont even have wireless in trains !
15:17:57 <bolrod> they are 'testing' it
15:18:05 <bolrod> I only once seen such a train
15:18:08 <bolrod> and I was in it
15:18:15 <bolrod> only noticed it when I got out of the train
15:18:24 <Lokadin_> damn
15:18:27 <bolrod> and it probably isn't even free 
15:18:27 <Lokadin_> tht sux
15:18:40 <bolrod> well.. I was in some 'old' cabin
15:18:46 <Lokadin_> o
15:18:54 <Lokadin_> why were you on a train?
15:19:02 <bolrod> I go to school by train
15:19:25 <bolrod> long train... only a few of the wagons had wireless I guess
15:19:48 <Lokadin_> o
15:19:53 <Lokadin_> makes sense
15:19:55 <bolrod> dont know if it would have been possible to receive any....
15:19:55 <Lokadin_> they were testing
15:20:29 <Lokadin_> bolrod: where you at? that you take train to school
15:20:41 <bolrod> I go to university
15:20:47 <Lokadin_> well i figured
15:20:56 <Lokadin_> i got some friends that go to my uni on train to
15:21:01 <Lokadin_> Go Train
15:21:01 <bolrod> :)
15:21:21 <Lokadin_> what a wierd name for a transportation service
15:21:25 <Lokadin_> Go
15:21:32 <Lokadin_> oh well
15:21:33 <bolrod> Go ?
15:21:49 <Lokadin_> that's the name of the transit company
15:21:50 <Lokadin_> GO
15:21:54 <bolrod> ahwell.  I'll just sleep and listen to music :)
15:21:59 <bolrod> oh.. here it is NS
15:22:04 <bolrod> :)
15:22:28 <bolrod> germany has DB  :)
15:22:34 <Lokadin_> lol
15:22:40 <bolrod> looks like a weird smiley  with a sad face
15:22:53 <Lokadin_> yea, an upside down one
15:22:55 <bolrod> well..  I heard their train system is even worse then ours
15:23:04 <Lokadin_> where is yours?
15:23:10 <bolrod> Netherlands
15:23:13 <Lokadin_> o
15:23:20 <bolrod> today... a train actually left the station early!
15:23:23 <Lokadin_> well that must be pretty good
15:23:25 <bolrod> by 2-3 minutes!
15:23:37 <Lokadin_> wow!, well i dono if that's a good thing though
15:23:48 <bolrod> imagine I'd come there 2 mintues early.. and the train already left!
15:23:55 <bolrod> that would be somewhat annoying
15:23:59 <Lokadin_> yep
15:24:01 <Lokadin_> very true
15:24:03 <ihope_> Something happened...
15:24:09 <bolrod> ?
15:24:14 <bolrod> meteor struck?
15:24:23 <Lokadin_> here if the busses come early more than 3 times a year the driver loses their job
15:24:31 <alar> bolrod: and if you have to wait for next one 2 hours?
15:24:39 <bolrod> haha
15:24:52 <bolrod> nah.. each half hour there is one 
15:25:09 <alar> not so laughful on winter night
15:25:17 <ihope_> bolrod: yeah, a big one. I seem to be standing in a crater.
15:25:24 <bolrod> haha
15:25:31 <Lokadin_> ihope: lol
15:25:37 <bolrod> cool   where?.. I'll take a look with google earth 8)
15:26:19 <bolrod> damn its late... 
15:26:35 <ihope_> Lemme see here...
15:26:37 <Lokadin_> say where can i find the ghc api?
15:27:13 <ihope_> It's at 35°1′38″N, 111°1′22″W.
15:27:57 <Lokadin_> many question marks
15:28:09 <Lokadin_> your in the states :P
15:28:23 <ihope_> Heh.
15:28:59 <ihope_> 35 degrees, 1 minute, 38 seconds north, 111 degrees, 1 minute, 22 seconds west.
15:29:46 <Lokadin_> hmmm
15:29:52 <Lokadin_> so ghc api anyone?
15:30:05 <ihope_> @where api
15:30:06 <lambdabot> I know nothing about api.
15:30:10 <ihope_> @google ghc api
15:30:14 <lambdabot> http://www.cs.kent.ac.uk/pubs/2005/2266/
15:30:44 <Lokadin_> Porting HaRe to the GHC API
15:30:45 <Lokadin_> :(
15:31:07 <Lokadin_> @where ghc
15:31:08 <lambdabot> http://haskell.org/ghc
15:31:26 <ihope_> @where hide
15:31:27 <lambdabot> http://haskell.org/haskellwiki/HIDE
15:31:40 <Lokadin_> whats hide?
15:31:50 <ihope_> hIDE... an IDE, I guess.
15:32:19 <ihope_> I still haven't figured out what @heavy does...
15:33:16 <Lokadin_> @heavy
15:33:17 <lambdabot> Not enough privileges
15:33:20 <Lokadin_> :|
15:33:39 <Lokadin_> brb
15:33:54 <ihope_> @happy
15:33:55 <lambdabot> Unknown command, try @listcommands.
15:33:59 <ihope_> @heart
15:34:00 <lambdabot> Maybe you meant: learn part
15:34:05 <ihope_> @hevy
15:34:06 <lambdabot>  @help <command> - ask for help for <command>
15:34:10 <ihope_> @heevy
15:34:11 <lambdabot> Unknown command, try @listcommands.
15:34:18 <ihope_> Grr!
15:34:36 <ihope_> Aha! @leave!
15:34:40 <ihope_> @help leave
15:34:41 <lambdabot> leave <channel>
15:36:34 <Lokadin_> so does hide work?
15:36:43 <Lokadin_> i mean can it be installed?
15:37:20 <dcoutts> not easily
15:37:48 <Lokadin_> kk
15:37:55 <Lokadin_> how about yi?
15:38:08 <ihope_> > let x = 24; y = 30 in (y^2 - x)
15:38:09 <lambdabot> 876
15:38:13 <Lokadin_> does it have better syntax highlighting for haskell than vim?
15:38:20 <ihope_> > let x = 24; y = 30 in (y^2 - 100)
15:38:22 <lambdabot> 800
15:38:38 <ihope_> So 01.876.8000 or what?
15:38:46 <ihope_> And what kind of phone number is that? ;-)
15:40:35 <ihope_> > [1,2,3] ++ do a <- [4,5,6], [a, a+3, a+6]
15:40:37 <lambdabot>  The last statement in a 'do' construct must be an expression
15:40:46 <ihope_> > [1,2,3] ++ do a <- [4,5,6]; [a, a+3, a+6]
15:40:48 <lambdabot> [1,2,3,4,7,10,5,8,11,6,9,12]
15:40:53 <ihope_> Not right.
15:41:05 <ihope_> > [1,2,3] ++ do a <- [4,7,10]; [a, a+1, a+2]
15:41:06 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12]
15:47:03 <Lokadin_> Setup.lhs: cannot satisfy dependency fps-any
15:47:05 <Lokadin_> :(
15:48:00 <ihope_> @google cannot satisfy dependency fps-any
15:48:03 <lambdabot> http://tunes.org/~nef/logs/haskell/06.02.09
15:48:08 <dons> install fps
15:48:10 <Lokadin_> yep
15:48:16 <TuringTest> oh, hi dons,
15:48:20 <Lokadin_> i just figured that out
15:48:42 <TuringTest> dons: I just sent you the replacement for the CTK regex code.  :)
15:48:43 <ihope_> So it looks like http://www.cse.unsw.edu.au/~dons/fps.html
15:48:58 <dons> \where fps
15:48:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:49:01 <dons> yup
15:49:07 <dons> TuringTest, cool!
15:49:08 <Lokadin_> is ghc 6.5 stable?
15:49:17 <TuringTest> Lokadin_: no
15:49:22 <dons> no
15:49:22 <dons> yes
15:49:23 <dons> for some definitoin of stable
15:49:42 <Lokadin_> lol, well er has it been pronounced stable?
15:49:43 <dons> it's not the 'stable branch'
15:49:52 <dons> so no. it's not pronounced stable
15:49:56 <Lokadin_> kk
15:49:57 <dons> it's pronounced 'head'
15:50:02 <dons> :)
15:50:10 <Lokadin_> lol kk :)
15:50:39 <TuringTest> I have only 27 minutes of battery time left, so I will let you look at the code I sent at your leisure, dons.
15:50:45 <TuringTest> good night all
15:51:03 <dons> night TuringTest
15:51:08 <dons> oh he' always so fast to quit
15:51:36 <jips> hi dons 
15:51:48 <dons> heya jips
15:52:39 <jips> dons: any hs-plugins news?
15:53:52 <Lokadin_> would yi go under app-text
15:54:00 <Lokadin_> ?
15:54:02 <Lokadin_> as category
15:55:05 <Lokadin_> and fps under dev-haskell?
15:55:26 <dons> Lokadin_?
15:56:24 <Lokadin_> i'm trying to make ebuilds
15:56:29 <Lokadin_> for yi and fps in gentoo
15:58:07 <dons> ah. well, it's up to you then :)
15:58:09 <kosmikus> Lokadin_: there is an ebuild for yi.
15:58:26 <jips> dons: tomorrow i'm gonna take a stab at that merge file close bug i mentioned to you... but now i must sleep; gotta wake up in 4 hours :(
15:58:29 <dons> and fps is certainly in there already (for hmp3)
15:58:38 <dons> Lokadin_, ask dcoutts
15:58:45 <kosmikus> Lokadin_: I'm just going to bed, but you should join #gentoo-haskell and talk to me or dcoutts when we're around.
15:58:45 <dcoutts> ?
15:58:45 <ihope_> Prepositions are things a sentence should never end with.
15:58:46 <dons> (or ask on #gentoo-haskell )
15:59:11 <Pseudonym> Propositions are all false.
15:59:22 <Lokadin_> kk
15:59:30 <Lokadin_> kosmikus: really?
15:59:32 <dcoutts> Lokadin_, we're not going to add fps since it's not going to exist in the longer term
15:59:49 <Lokadin_> jips: hmp3 is not a gentoo package
15:59:54 <Lokadin_> hmmm
15:59:57 <dcoutts> not yet
16:00:05 <dcoutts> it's in our development overlay
16:00:07 <Lokadin_> so it would have to be bundled with yi?
16:00:24 <Lokadin_> or just have a darcs ghc?
16:00:25 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/
16:00:40 <Lokadin_> oo
16:00:41 <Lokadin_> :D
16:00:43 <Lokadin_> thanks
16:00:49 <dcoutts> we're lacking a ghc-darcs ebuild
16:00:58 <dcoutts> feel free to darcs send us one
16:01:03 <kosmikus> actually, that's on my todo list since weeks ;)
16:01:18 <kosmikus> but yeah, it should be really easy. darcs.eclass exists.
16:01:27 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/TODO
16:01:36 <kosmikus> and ghc-cvs exists as well.
16:01:36 <dcoutts> it really is on the TODO :-)
16:01:52 <kosmikus> so the number of changes that'd be needed are probably really small.
16:02:02 <vincenz> lalala
16:02:08 <dcoutts> kosmikus, except that ghc needs several darcs repos
16:02:16 <dcoutts> not just one like with ghc-cvs
16:02:31 <dcoutts> it needs all the libraries
16:02:35 <vincenz> > [1..10] >>= \x -> if x > 5 then return x else fail
16:02:36 <lambdabot> Couldn't match `[]' against `(->) t'
16:02:43 <vincenz> > [1..10] >>= \x -> if x > 5 then return [x else fail
16:02:43 <lambdabot>  parse error on input `else'
16:02:55 <vincenz> > [1..10] >>= \x -> if x > 5 then return x else fail "a"
16:02:56 <kosmikus> dcoutts: ghc-cvs also needed multiple checkouts. I assume one can use a similar trick.
16:02:56 <lambdabot> [6,7,8,9,10]
16:03:01 <ihope_> Is 5115834148248347 a prime number?
16:03:02 <vincenz> @pl \x -> if x > 5 then return x else fail "a"
16:03:03 <lambdabot> flip (liftM2 if' (> 5) return) (fail "a")
16:03:04 <dcoutts> kosmikus, fair enough
16:03:10 <vincenz> ihope_: yes
16:03:20 <ihope_> > 80861057 * 63266971
16:03:22 <lambdabot> 5115834148248347
16:03:33 <Lokadin_> so how can i grab that whole gentoo-haskell thing?
16:03:38 <Lokadin_> wget?
16:03:40 <ihope_> :-P
16:03:48 <dcoutts> Lokadin_, if you want to talk about this stuff join #gentoo-haskell
16:03:53 <Lokadin_> kk
16:04:01 <dons> Pseudonym, I had a dream about unlambda last night
16:04:17 <vincenz> > \x -> and $ map (\y -> x `mod` y == 0) [1..round(sqrt(x))+1]
16:04:18 <lambdabot>  add an instance declaration for (Show (b -> Bool))
16:04:43 <vincenz> > \(x -> and $ map (\y -> x `mod` y == 0) [1..round(sqrt(x))+1] ) 5115834148248347
16:04:44 <lambdabot>  parse error on input `->'
16:04:54 <vincenz> > (\x -> and $ map (\y -> x `mod` y == 0) [1..round(sqrt(x))+1] ) 5115834148248347
16:04:55 <lambdabot> Add a type signature
16:05:09 <Pseudonym> dons: Ha!
16:05:14 <vincenz> > (\x -> and $ map (\y -> x `mod` y == 0) ([1..round(sqrt(x))+1]::[Int]) ) 5115834148248347
16:05:15 <lambdabot>  add an instance declaration for (Floating Int)
16:05:31 <Pseudonym> I still don't fully understand what I did wrong.  I'm 99% certain that I need to delay something.
16:05:57 <vincenz> > (\x -> and $ map (\y -> x `mod` y == 0) ([1..1+toIntegral$ round $ sqrt x]::[Int]) ) 5115834148248347
16:05:58 <lambdabot>  Not in scope: `toIntegral'
16:06:01 <vincenz> grr
16:06:14 <vincenz> @type round
16:06:14 <dons> vincenz, perhaps in a private msg to lambdabot?
16:06:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:06:45 <Pseudonym> dons, what the program was _supposed_ to do was print a Peano integer in binary expansion.
16:06:49 <ihope_> vincenz: try taking from the list while its square is less than whatever thingy
16:06:59 <vincenz> good point
16:07:10 * Pseudonym was sick of printing numbers as rows of asterisks
16:07:22 <dons> :)
16:07:44 <Pseudonym> So about 2/3 of the code was an implementation of division/remainder by 2.
16:07:51 <Pseudonym> Which required recursion.
16:07:56 <dcoutts> dons, can I suggest you add editor@lwn.net to your HWN cc list
16:08:02 <ihope_> !
16:08:25 <dcoutts> dons, LWN runs the OCaml weekly news and other similar things
16:08:44 <dcoutts> it ends up on the development page in the LWN weekly edition
16:08:47 <dons> dcoutts, ok. john originally had some protocol for talking to them, i'll look into it.
16:08:51 <vincenz> > map (\x -> and $ map (\y -> x `mod` y /= 0) $ takeWhile (\y -> y*y <= x) [2..]) [2..10]
16:08:52 <lambdabot> [True,True,False,True,False,True,False,False,False]
16:09:00 <vincenz> :)
16:09:06 <dcoutts> dons, cool
16:15:26 <ihope_> > (\x -> and $ map (\y -> x `mod` y /= 0) $ takeWhile (\y -> y*y <= x) 5115834148248347
16:15:27 <lambdabot>  parse error on input `}'
16:15:47 <ihope_> > (\x -> and $ map (\y -> x `mod` y /= 0) $ takeWhile (\y -> y*y <= x) [2..]) 5115834148248347
16:15:51 <lambdabot> Terminated
16:15:55 <ihope_> Aww.
16:17:08 <dons> :) people burn poor shodan's processor all day long
16:17:50 <dons> though, load average: 0.01, 0.02, 0.00
16:17:56 <ihope_> Heh.
16:18:06 <dons> so youu need to try harder!
16:18:51 <ihope_> @type let x = const const :: a -> (a -> a -> a) in (x . x . x . x) (x . x . x . x) (x . x . x . x) (x . x . x . x)
16:19:11 <ihope_> What's the stuff now?
16:19:12 <lambdabot>   Occurs check: cannot construct the infinite type:
16:19:12 <lambdabot>   a
16:19:16 <ihope_> Aww.
16:19:29 <ihope_> I don't get why it does that, but... ah well.
16:19:33 <ihope_> @type const const
16:19:34 <lambdabot> forall a b b1. b1 -> a -> b -> a
16:19:49 <ihope_> @type const const :: a -> (a -> a -> a)
16:19:51 <lambdabot> a -> (a -> a -> a) :: forall a. a -> a -> a -> a
16:20:03 <ihope_> Aha... um...
16:20:08 <ihope_> Oh.
16:20:23 <ihope_> Let's try this:
16:20:25 <ihope_> @type let x = const const in (x . x . x . x) (x . x . x . x) (x . x . x . x) (x . x . x . x)
16:20:27 <lambdabot> forall a
16:20:27 <lambdabot>                                  b
16:20:27 <lambdabot>                                  a1.
16:20:27 <lambdabot>                               a1
16:20:27 <lambdabot>                               -> a
16:20:29 <lambdabot>                               -> b
16:20:31 <lambdabot>                               -> a
16:20:47 <ihope_> Is that it?
16:21:01 <dons> bad ghc 6.4.1 formatting. i should install 6.5
16:21:01 <ihope_> > let x = const const in (x . x . x . x) (x . x . x . x) (x . x . x . x) (x . x . x . x) 1 2 3
16:21:03 <lambdabot> 2
16:21:32 <ihope_> @type let x = const const in (x . x . x . x . x . x . x . x . x . x . x . x . x . x . x . x)
16:21:33 <lambdabot> forall a
16:21:33 <lambdabot>                                  b
16:21:33 <lambdabot>                                  a1.
16:21:33 <lambdabot>                               a1
16:21:34 <lambdabot>                               -> a
16:21:36 <lambdabot>                               -> b
16:21:38 <lambdabot>                               -> a
16:21:59 <ihope_> > let x = const const in (x . x . x . x . x . x . x . x . x . x . x . x . x . x . x . x) 1 2 3
16:22:00 <lambdabot> 2
16:22:03 <ihope_> Bwah.
16:23:22 <ihope_> What happened to the @type DoS?
16:23:30 <ihope_> @type let x = const const :: a -> a -> a -> a in x x x x x x x x x x x x x x x x x x x x x x
16:23:32 <lambdabot> a -> a -> a -> a in x x x x x x x x x x x x x x x x x x x x x x :: forall
16:23:32 <lambdabot> a.
16:23:32 <lambdabot>                               a
16:23:32 <lambdabot>                               -> a
16:23:32 <lambdabot>                               -> a
16:23:34 <lambdabot>                               -> a
16:23:42 <dons> ihope_... please.
16:23:56 <dons> sure, there's some exponentional types out there.. but that isn't one :)
16:24:02 <ihope_> :-)
16:24:11 <ihope_> So you mean take it to /msg or just stop?
16:24:28 <dons> i'm saying stop. cause if you do it i just have to patch lambdabot to add a timeout to @type too :)
16:24:44 <ihope_> :-)
16:24:46 <dons> and i have other work to do today :)
16:25:08 <ihope_> It was (a -> a -> a) -> a, wasn't it?
16:25:16 <dons> don't think so.
16:25:34 <ihope_> @type let x = undefined :: (a -> a -> a) -> a in x x
16:25:35 <lambdabot>   Occurs check: cannot construct the infinite type:
16:25:35 <lambdabot>   t = (t -> t1) -> (t -> t1) -> t -> t1
16:25:40 <dons> i can think of two. one is Cale's tricky type, which really is huge. and one is a smileys type, which is just really big
16:25:41 <ihope_> I guess not.
16:26:28 <Lokadin_> say anyone know why HaSh never took off?
16:26:33 <Lokadin_> or did it?
16:27:29 <dons> HaSh, do you mean h4sh?
16:27:41 <dons> or was HaSh someone''s shell? It rings a bell
16:27:47 <Lokadin_> er Haskell Shell
16:28:09 <dons> there's been a couple, but no big effort to hack it up haas emerged yet
16:28:16 <Lokadin_> o
16:28:17 <Lokadin_> kk
16:28:24 <Lokadin_> any ones with source?
16:29:07 <Lokadin_> that you know of?
16:29:52 <dons> I don't know where the src is.
16:29:55 <dons> \where hash
16:29:55 <lambdabot> I know nothing about hash.
16:29:57 <dons> nope.
16:31:02 <Lokadin_> kk
16:31:07 <Lokadin_> well thanks anyways
16:31:08 <Lokadin_> :)
16:32:34 <arjanoosting> Lokadin_: maybe h4sh, see http://article.gmane.org/gmane.comp.lang.haskell.general/11970
16:32:51 <dons> \where h4sh
16:32:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
16:32:55 <dons> but it isn't a shell
16:33:26 <dons> it's a bunch of list functoins exported to the shell, connected by thhhe shells | which works like >>=
16:34:29 <Lokadin_> kk
16:40:06 <Lokadin_> so it's basically a replacement for the usual functions like cat head tail and the like?
16:40:06 <Lokadin_> er commands
16:42:18 <dons> yep. using nice list functions instead
16:42:46 <arjanoosting> hmm, I know i read something about haskell shell scripting not long ago...
16:42:53 <arjanoosting> http://www.haskell.org/hashell/
16:43:06 <ihope_> @md5
16:43:07 <lambdabot> Maybe you meant: id map msg
16:43:16 <ihope_> @id Hello, world!
16:43:17 <lambdabot> Hello, world!
16:43:24 <dons> ah, hashell. that's it
16:43:51 <ihope_> Nobody uses @state anymore :-(
16:44:04 <dons> \state
16:44:04 <lambdabot> 5115834148248347
16:44:08 <dons> well, someone did
16:44:24 <Igloo> What does it do?
16:44:49 <Lokadin_> arjanoosting: thanks :)
16:45:23 <dons> state was the second plugin written, by shapr I think. it just implements state.
16:47:08 <musasabi> serialization is too easy and hard at the same time in Haskell.
16:47:30 <musasabi> It is so easy that everyone has at least three different libraries for it.
16:47:43 <dons> :)
16:47:44 <musasabi> And so hard that none of them is clearly dominating.
16:48:11 <dons> ah well, I'd say most of them are just Binary in some form :)
16:48:28 <Cale> @state 0
16:48:40 <ihope_> @hoogle Integer -> String
16:48:42 <lambdabot> System.Info.os :: String
16:48:42 <lambdabot> System.Info.arch :: String
16:48:42 <lambdabot> System.Info.compilerName :: String
16:48:55 <Excedrin> \state
16:48:55 <lambdabot> 0
16:48:56 <musasabi> dons: well the classic Binary is horrible from a performance pov
16:49:02 <ihope_> Um.
16:49:05 <dons> yep. you don't want "classic" Binary
16:49:10 <dons> you want to tweak it up
16:49:17 <Cale> ihope_: I can't believe it didn't list show
16:49:18 <ihope_> Where's the show-as-binary thing?
16:49:37 <musasabi> yes, but everyone has different tweaks. or wholly different libs.
16:49:39 <dons> it's probably a matter of someone writing a really rich, cabalised one. good interface docs etc, and selling it a  bit
16:49:49 <dons> and then we'll get some consensus
16:50:20 <musasabi> Today I was trying to decide on a binary lib to depend on and noticed that I already was using two different ones in some modules.
16:50:47 <Excedrin> so you used a third?
16:52:14 <musasabi> Excedrin: I complained on #haskell and started to play nethack
16:52:30 <Excedrin> that's thinking out of the box
16:52:52 <dons> hehe
16:53:46 <ihope_> @hoogle reallyUnsafe
16:53:47 <lambdabot> No matches found
16:53:48 <musasabi> Bulat's alt-binary has most of what I need but it depends on the streams stuff.
16:53:55 <ihope_> @google reallyUnsafe
16:53:57 <lambdabot> http://www.guidedogsqld.com.au/docs/monocular/mvi_article.pdf
16:54:11 <musasabi> I think I will just use SerTH + low level combinators.
16:57:36 <Excedrin> SerTH seems nice. Do you know if it's possible to control the binary format exactly?
16:59:17 <ihope_> Grr. I found a nice calculator online somewhere.
16:59:19 <Lokadin_> dons: say where would i find a yi wiki or information page?
16:59:40 <ihope_> Now I can't find it.
17:00:11 <dons> Lokadin, you can find the yi wiki from the yi page
17:00:15 <dons> \where yi
17:00:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:00:23 <Lokadin_> well i mean that one is down no?
17:00:24 <dons> \google yi text editor
17:00:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:00:30 <dons> ah is it?
17:00:42 <Lokadin_> er well doesn't work for me 
17:00:49 <dons> well, that page isn't down
17:00:54 <dons> but the  wiki might be
17:00:54 <Lokadin_> not that
17:00:57 <Lokadin_> http://www.scannedinavian.org/YiWiki
17:01:00 <dons> (but it didn't have much content on it)
17:01:05 <Lokadin_> o okay
17:01:11 <dons> so don't worry.
17:01:13 <Lokadin_> nm, i'll just look at help pages then
17:01:18 <dons> if you want to find out about yi, read the papers. and the docs in the src
17:01:18 <musasabi> Excedrin: SerTH is usually used in higher level situations where you don't want to know the format (i.e. Haskell -> Haskell), a manual API is nice for the situations when the on-wire format is specified.
17:01:18 <Lokadin_> thanks :D
17:01:20 <Lokadin_> :P
17:01:30 <Lokadin_> if anyone is to worry it would be you no?
17:01:31 <Lokadin_> lol
17:01:40 <dons> well, I'm not worried :)
17:01:50 <Lokadin_> :) that's good
17:01:50 <Lokadin_> lol
17:03:27 <Lokadin_> The "help" command is unknown.
17:03:29 <Lokadin_> :(
17:03:35 <Lokadin_> where would i find it?
17:03:59 <Lokadin_> hmmm
17:04:37 <Lokadin_> i just wanted syntax highlighting :(
17:05:16 <dons> no syntax highlighting in the main yi yet.
17:05:35 <dons> the help commmand is unknown, you can't find it :)
17:05:47 <Lokadin_> :P i'm aware lol
17:05:57 <Lokadin_> :)
17:06:14 <musasabi> -> sleep
17:07:23 <Lokadin_> dons: is there a user manual or anything? maybe a feature list?
17:08:28 <dons> well, the vim mode implements vim (well, some percent of vim) and the mg mode implements emacs
17:08:41 <dons> so try: ./yi-static --as=mg to try the emacs mode
17:08:50 <dons> or not args to get the vim mode
17:09:16 <dons> to really find out what it does, you read yi/Yi/Keymap/Foo.hs , for the mode 'Foo'
17:10:33 <Lokadin_> oo
17:10:34 <Lokadin_> kk
17:10:41 <Lokadin_> well i like vim mode best
17:10:47 <Lokadin_> hmm
17:11:21 <dons> ok. there a few others. but vim and mg are the most complete
17:11:24 <dons> i use the vim mode
17:11:40 <dons> the full set of features is in Yi/Core.hs
17:11:56 <dons> and then the interfaces combine these core features to provide specific editor emulation
17:12:19 <dons> anyway, it's mostly a 1 hacker show, so development is slow.. 
17:12:25 <Lokadin_> o
17:12:27 <Lokadin_> i get ya
17:12:44 <Lokadin_> i'd help but i'm just learning haskell :(
17:13:38 <dons> anyway, you're just looking for good syntax highlighting?
17:14:01 <Lokadin_> basically
17:14:22 <Lokadin_> cause vi is a little sparse on the highlighting
17:14:25 <dons> well, what's wrong with the vim syntax highlighting?
17:14:40 <Lokadin_> i guess it's fine
17:14:46 <dons> it lets you configure it to be as goofy as you want too.
17:14:50 <dons> so change the colours!
17:15:12 <Lokadin_> lol :P it's just the common commands aren't highlighted
17:15:20 <Lokadin_> but that's fine
17:15:24 <dons> ah, you mean the standard functtoins?
17:15:27 <dons> from the PreludE?
17:15:27 <orbitz> commands?
17:15:30 <Lokadin_> yea
17:15:35 <Lokadin_> that's right
17:15:47 <dons> if you add this to your .vimrc:
17:15:48 <dons> let hs_highlight_debug=1
17:15:48 <dons> let hs_highlight_more_types=1
17:15:54 <dons> let hs_highlight_types=1
17:15:57 <dons> you get much more stuff colored
17:16:03 <Lokadin_> :D thanks
17:16:10 <dons> i.e. types,  and some prelude stuff like error, undefined
17:16:30 <dons> let hs_highlight_boolean=1
17:16:30 <dons> too
17:16:45 <dons> I also have:
17:16:46 <dons> :highlight hsDelimiter   ctermfg=DarkBlue
17:16:46 <dons> :highlight hsImport      ctermfg=DarkRed
17:16:46 <dons> :highlight hsStructure   ctermfg=DarkCyan
17:16:46 <dons> :highlight hsStatement   ctermfg=Brown
17:16:49 <dons> :highlight hsOperator    ctermfg=DarkBlue
17:16:51 <dons> :highlight hsString      ctermfg=DarkGreen
17:16:54 <dons> to tweak the colours
17:17:26 <Lokadin_> in the vimrc?
17:17:28 <Lokadin_> or in vim
17:17:49 <Lokadin_> to tweak colours
17:20:10 <dons> in the .vimrc
17:20:11 <gizban> how do I 'show' a data type I've created?
17:22:09 <dons> 'deriving Show'
17:22:16 <ihope_> data Foo = ... deriving Show
17:22:23 <Lokadin_> dons: nice :D
17:23:42 <dons> it's optimised for a light background -- not sure what it looks like with dark colours in the bg
17:23:56 <Lokadin_> hmmm, looks fine on black
17:24:18 <Lokadin_> in gnome-terminal anyways
17:24:33 <dons> ah yeah, it's not too bad on xterm black bg now that I check it
17:24:37 <gizban> thanks
17:26:01 <araujo> Hello
17:26:50 <Lokadin_> dons: yep :)
17:28:28 <gizban> parseVar = spot (\x -> 'a' <= x && x <= 'z')
17:28:33 <gizban> what does the \x mean?
17:28:59 <Lokadin_> gizban: \ is lamda
17:29:10 <Lokadin_> it allows you to have nameless function
17:29:33 <Lokadin_> so instead of func x =  'a' <= x && x <= 'z'
17:29:46 <Lokadin_> from my understanding anyways
17:29:49 <gizban> oh, ok.  Thanks
17:30:03 <Lokadin_> np
17:30:31 <Lokadin_> i actually only found out earlier today :P lol
17:31:39 <dons> it's a bit like: spot (let f x = 'a' <= x &&& x <= 'z' in f)
17:32:07 <dons> but then you don't need the name of the actualy function, so we use a lambda to just specify a nameless function
17:32:16 <dons> spot $ \x -> 'a'  <= x ...
17:33:30 <dons> if the function isn't recursive, then: let f x = e in f  == \x.e
17:33:43 <dons> and then:
17:33:48 <dons> @pl \x -> 'a' <= x && x <= 'z'
17:33:48 <lambdabot> liftM2 (&&) ('a' <=) (<= 'z')
17:33:58 <dons> you don't need to even name the argument :)
17:34:16 <dons> spot $ liftM2 (&&) ('a' <=) (<= 'z')
17:34:22 <dons> fun fun
17:34:38 <gizban> looks like a mess.  Reminds me of my Perl troubles
17:35:01 <Lokadin_> i think i'm a lot more confused now than i was before *sighs*
17:35:15 <Lokadin_> but i'm sure i'll get it later
17:38:27 <dons> probably the main point is that you only need lambdas in your language.
17:38:56 <Lokadin_> in haskell you mean?
17:38:56 <dons> everything computable can be done with just \x.e
17:39:29 <Lokadin_> dons: do you use gvim ever?
17:39:30 <dons> in general. lambda calculus , the language of lambdas and application of lambdas, is turing complete
17:41:14 <Lokadin_> turing complete?
17:43:18 <dons> \wikipedia turing complete
17:43:21 <lambdabot> No Result Found.
17:43:27 <dons> \wikipedia turing 
17:43:29 <lambdabot> No Result Found.
17:43:46 <dons> \wikipedia Turing
17:43:48 <lambdabot> No Result Found.
17:43:51 <dons> bah.
17:44:12 <dons> a Turing showed that any computable function could be done on an abstract machine he invented
17:44:31 <Lokadin_> o
17:44:44 <dons> so to establish that a language is Turing-complete means that it can compute anything computable
17:44:59 <ihope_> So CFB and OFB can use hashing algorithms as their block ciphers? :-)
17:45:03 <SimonRC> erm
17:45:40 <SimonRC> Turing-completness means that it can compute any computable *function* / *algorithm*
17:46:07 <SimonRC> modern computers compute many things which aren't funcions or algorithms
17:46:11 <dons> ah yes. sloppy me.
17:46:27 <dons> and anyway, Turing showed this by showing the equivalence to the lambda calculus
17:46:32 * SimonRC read that rant that was on LtU a while back
17:47:14 <ihope_> SimonRC: what else is there?
17:47:22 <SimonRC> interactive programs
17:47:28 <SimonRC> they don't compute a function
17:47:50 <Pseudonym> ihope_: Sure.  You can use a Feistel network.
17:48:00 <Pseudonym> Easy way to turn a one-way function into a block cipher.
17:48:03 <ihope_> Well... it's sorta like a function from input to output.
17:48:24 <Pseudonym> And OTOH, block ciphers are often used to make hash functions.
17:51:10 <ihope_> Hmm. Mutually dependent cipher thingies, anyone?
17:51:15 <Pseudonym> Kind of.
17:51:57 <Pseudonym> To make a hash function from a block cipher, you encrypt a fixed piece of data using the material that you want hashed as the key.
17:52:17 <Pseudonym> The non-reversability of the hash is guaranteed if the block cipher is immune to known-plaintext attacks.
17:53:04 <ihope_> So I factor one number in 5 minutes. The next one has been running for 30 minutes and is still going.
17:53:21 <Pseudonym> What algorithm are you using?
17:53:38 <ihope_> The elliptic curve thing.
17:53:50 <Pseudonym> That's slow on medium-sized integers.
17:53:51 <ihope_> Is there a better way to find "biggish" prime numbers?
17:54:06 <ihope_> The integer I'm using is 9287492837498026592165982146592749729035720975927982365918265946539865043965290164782634826482365984256973659284729165782648723658743657937248
17:54:12 <Pseudonym> If you can live with strong pseudo-primes, sure.
17:54:25 <ihope_> How strong?
17:54:53 <Pseudonym> You could use a Fermat test.
17:55:57 <Pseudonym> http://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html
17:56:55 <ihope_> Hmm, MVars sound like fun!
18:01:55 <palomer> ping pong rocks.
18:03:14 <palomer> rabin-miller isn't fermat's test
18:05:14 <Pseudonym> No, but it's based on, surely?
18:06:16 <ihope_> This number's been going for 45 minutes now...
18:07:44 <ihope_> Say... what's QML like?
18:07:53 <palomer> maybe you can relate the 2 things
18:08:54 <ihope_> Yeah, with enough effort, I could implement Shor's algorithm in QML.
18:09:12 <ihope_> The problem is *running* the QML program. I don't have a quantum computer handy.
18:14:13 <Lokadin_> say is QML similar to functional programming languages?
18:15:42 <ihope_> I think it's functional.
18:15:51 <ihope_> Based on Haskell, I believer.
18:15:56 <ihope_> s/r//
18:16:15 <dons> based on haskell? wow.
18:17:23 <ihope_> Well, according to Wikipedia, it's "Haskell-like".
18:18:18 <dons> ok, might just mean its fp
18:19:23 <ihope_> Well, having seen a snip of code, I can tell you that it looks like Haskell.
18:20:49 <ihope_> Well, I gotta go. Bye.
18:26:54 <palomer> running code is overrated
18:29:11 <liyang> I thought QML was a DSL implemented on top of Haskell.
18:53:05 <Pseudonym> ihope_: Did you want to find all factors of that number?
18:54:19 <Pseudonym> So far I have 2, 2, 2, 2, 2, 13, 19, 83 and 350892013
18:56:07 <Pseudonym> That just leaves 40345953622132335076140777211405080756912353859014779544886134903781617090322996255035975953895961198503612205376043428370795003 to be factored.
18:57:00 <Pseudonym> 35885043143
18:57:24 <Pseudonym> There's another factor.
18:59:10 <Pseudonym> This took about a minute on an old machine, BTW.  I'm using my own pollard rho algorithm in Haskell.
18:59:16 * Pseudonym had to re-implement it before starting
19:04:32 <Cale> 297568108169
19:06:08 <araujo> Does there exist a predefined function to do something like: f (+ 1) 2 = (+ 1) $ (+1) 2 
19:06:46 <Pseudonym> No, but here's mine:
19:06:48 <Pseudonym> iterateFun :: Integer -> (a -> a) -> (a -> a)
19:06:48 <Pseudonym> iterateFun 0 f x = x
19:06:48 <Pseudonym> iterateFun n f x = iterateFun (n-1) f $! f x
19:07:10 <Cale> 9126421238616817
19:07:19 <lennart> foldr (.) id (replicate n f)
19:08:27 <araujo> sweet :-]
19:08:35 <araujo> thanks Pseudonym , lennart 
19:08:36 <Cale> and the result still isn't prime, so we have more factors to find
19:08:50 <Cale> or iterate
19:09:01 <Pseudonym> Cale: What algorithm are you using?
19:09:43 <Cale> the algorithm described in P. L. Montgomery's, "Speeding up the Pollard and Elliptic Curve Methods of Factorization," Mathematics of Computation 48 (1987), pages 243-264
19:09:51 <Pseudonym> Ah, interesting.
19:09:55 * Pseudonym will look that one up
19:10:34 <Cale> > iterate (+1) 2 !! 2
19:10:35 <lambdabot> 4
19:10:42 <Pseudonym> I have a suspicion that Pollard (p-1) might be even quicker than Pollard rho on this number.
19:12:15 <lispy> i have a version of pollard rho in haskell sitting around somewhere...
19:12:50 <lispy> ah, here we go: http://files.codersbase.com/pollard-rho.hs
19:13:59 <Pseudonym> Ah, you're not using the Brent improvement.
19:14:26 <lispy> in fact, my code is nastly because it was mostly meant for comparing the run time between it and miller-rabin
19:14:35 * Pseudonym nods
19:14:40 <lispy> that and it was one of the first haskell programs i wrote
19:15:10 <lispy> what is the brent improvement?
19:15:34 <lispy> i use the floyd loop detection
19:15:38 <Pseudonym> The original Pollard algorithm used two streams: iterate f x0 and iterate (f.f) x0 in Haskell notation.
19:15:59 <Pseudonym> The Brent algorithm takes the first element and compares that with the next r eleents.
19:16:00 <lispy> oh iterate would probably simplify my program a bit
19:16:08 <Pseudonym> Starting with r = 1, and then doubling it on every pass.
19:17:18 <Pseudonym> That way you avoid evaluating the stream twice.
19:17:28 <Pseudonym> And you do fewer checks in the case where the cycle is large.
19:17:49 <lispy> ah, cool
19:18:29 <lispy> heh, i just realized the bulk of that code is actually my strong pseudoprime generator and timing code
19:19:09 <lispy> rewriting it is a project for a rainy day :)
19:20:55 <liyang> Does anyone know how I can tell Firefox to view any text/* file in-browser? It's really irritating me the fact that it forces me to open .hs (and other source) files in an external editor. -_-;;;
19:21:40 <lispy> liyang: i think the configuration of the web server is what matters
19:21:57 <Pseudonym> Lunch.
19:22:28 <liyang> lispy: the web server returns text/x-haskell, which is correct as far as I can see.
19:25:22 <lispy> yeah, i'm googling for a way to change the mime type handler in ff but not having any suck
19:25:25 <lispy> er luck
19:28:25 <liyang> I found someone whinging about it here: http://juerd.hates-software.com/2004/05/30/514d04a9.html , but the comments went off in a different direction. :(
19:45:40 <twobitsp1ite> does haskell have anything resembling a record/struct type?
19:46:47 <liyang> twobitsp1ite: yes. data Foo = Bar { fieldname :: Cow, anotherone :: Moo } | Poo
19:47:19 <twobitsprite> liyang: they have to be varients? I can't have data Foo = { field1 :: ... }
19:47:40 * twobitsprite is moving to haskell from ocaml, so bear with me :P
19:48:11 <Saulzar> Don't have to be a variant, but still needs a constructor 
19:48:38 <twobitsprite> Saulzar: {field1 = "foo"} isn't a constructor?
19:48:41 <liyang> twobitsprite: a data declaration allows you to have sums of product (read: record) types.
19:49:07 <twobitsprite> liyang: sums of product?
19:49:23 <liyang> (... so you still need a constructor.)
19:49:49 <twobitsprite> liyang: constructor == "Bar" a la your example?
19:49:58 <liyang> twobitsprite: yes.
19:50:01 <twobitsprite> ok
19:50:23 <twobitsprite> ocaml will infer the type of your record by field names, I didn't know if there was something like that or not..
19:50:23 <liyang> You can use the same name as your type if there are no `variants'.
19:51:12 * twobitsprite is still getting used to the fact that : and :: are swapped in haskell
19:51:51 <dons> you end up writing more concise  code, as :: tends to encourage exta spaces when used as a list cons
19:52:03 <dons> that's the argument, anyway.
19:52:34 <dons> it's a debatable oint that we should have stuck to the usual syntax, though
19:52:41 <twobitsprite> dons: I'm not arguing either way as to which is "Better", I'm just saying that I'm still getting used to it
19:52:56 <liyang> twobitsprite: sum and product are regular language terminology; you might as well read then as variant and record. :)
19:53:13 <twobitsprite> dons:  I tend to use cons more than type definitions, so I think it makes sense to have the shorter one for cons...
19:53:46 <twobitsprite> liyang: right... it took me a sec to realize what you meant, but I know what you mean
19:54:01 <dons> yeah, I agree.
19:54:12 <liyang> dons: well we inherited it from Miranda (not quite; can't remember now) or somesuch. :)
19:54:14 <twobitsprite> (x:xs) does seem to look better than (x :: xs)
19:55:05 <dons> yep. also, using the same syntax for the type and value level is a good innovattoin. i think. no one ever complains about , say, (x,y) :: (Int,Bool)
19:55:22 <dons> the : :: syntax is from type theory, so long before Miranda
19:55:57 <dons> as an ml-er, what do you think about the (x,y) :: (Int,Bool) syntax?
19:56:05 <twobitsprite> dons: yeah... it always did bother me that the type of a tuple in ocaml was "a * b" and the value for a tuple was "a, b"
19:56:24 <twobitsprite> dons: I like it... I think its intuitive and reflective
19:56:49 <dons> ok, more points for my argument that "no one ever complains about the type/value syntax" :)
19:57:01 <twobitsprite> I think it might cause to minor confusion when you take into account the sepperate name spaces between values and types... but that's still a problem in ocaml, so it's not any worse..
19:57:17 <liyang> (twobitsprite: my earlier data example would look like Foo = Cow x Moo + 1 in regular language.)
19:58:07 <dons> usually people mention the type/construcotr names as a problem: data D = D -- is two different Ds on two levels, one type, one  value)
19:58:39 <twobitsprite> liyang: right... so I know where ocaml was coming from with it's "a * b" syntax for tuples (products) but it was still a bit odd syntactically...
19:59:11 <liyang> *nods*
19:59:20 <twobitsprite> dons: I usually try code as though types and values shared name spaces, just for clarity of intent, etc...
19:59:31 <twobitsprite> s/try/try to/
20:03:06 <twobitsprite> can you put a '|' before the first varient as you can in ocaml for the sake of indentation, etc?
20:03:17 <twobitsprite> data Foo =
20:03:20 <twobitsprite>   | Bar
20:03:23 <liyang> nope.
20:03:24 <twobitsprite>   | Baz
20:03:29 <liyang> But I usually write:
20:03:34 <liyang> data Foo
20:03:38 <liyang>     = Bar
20:03:43 <liyang>     | Moo
20:03:46 <liyang> and so on.
20:04:09 <twobitsprite> that works too... in fact that's what came naturally to me in Ocaml, but people complained about '=' being on a new line
20:04:25 <liyang> lol
20:04:41 <twobitsprite> but, you usually indent by 4 spaces?
20:05:09 * liyang looks around guiltily... <_<    >_>
20:05:34 <twobitsprite> what's the convention?
20:07:48 <dons> well, the report says tabs are 8. so use 4 spaces, I do :)
20:07:59 <dons> and don't use tabs
20:08:05 * twobitsprite never uses tabs
20:08:49 <twobitsprite> ohh yeah... and I've seen haskell code like:
20:08:56 <liyang> My beginning-of-line indents are always multiples of 4 spaces.
20:08:58 <twobitsprite> { elem1 :: Int
20:09:04 <twobitsprite> , elem2 :: Char }
20:09:12 <twobitsprite> is that conventional?
20:09:49 <twobitsprite> liyang: as opposed to middle-of-line indents?
20:09:54 <dons> yep for largee records
20:09:55 <Saulzar> Some people seem to like the comma at the beginning of the line
20:10:20 <twobitsprite> Saulzar: that's another thing that came naturally to me in Ocaml that Ocaml people didn't like :P
20:10:48 <twobitsprite> strange
20:10:53 <Saulzar> Well
20:11:04 <Saulzar> , you wouldn't think of doing this
20:11:06 <dons> well, looks like you've found your natural langauge :)
20:11:07 <Saulzar> , would you?
20:11:20 <dons> i like that style, though it took a whlie to get used to.
20:11:28 <dons> it has advantages when editing later
20:11:31 <twobitsprite> Saulzar: I would, if the line before it started with a '{' :P
20:11:44 <dons> to add a new entry, you don't need to edit the previous line to add a , at the end
20:11:58 <twobitsprite> dons: it keeps me from constantly scanning to the end of a line to find the ,
20:12:00 <Saulzar> Hmm
20:12:01 <eivuokko> Yeah, much nicer diffs for comma-first
20:12:04 <dons> same for removing an entry
20:12:06 <dons> right
20:12:06 <twobitsprite> dons:  that too
20:12:26 <dons> it's used in ghc all over the place. same for large lists
20:14:22 <twobitsprite> Saulzar: besides... mapping programming language with natural language is artificial at best anyways... I would do "isTired me == True" either :P
20:14:32 <Saulzar> Just need layout mode for records and lists then :)
20:14:36 <twobitsprite> s/would/wouldn't
20:16:02 <liyang> twobitsprite: as opposed to middle-of-line indents for alignment purposes, usually to make lhs2TeX happy. :)
20:16:18 <twobitsprite> liyang: ahh... like lining up '=' etc?
20:16:25 <liyang> Yup.
20:16:37 * twobitsprite needs to learn TeX
20:16:52 <twobitsprite> (it's pronounced "tech", right?)
20:17:25 <lispy> yup
20:17:33 <lispy> but, most people use latex these days
20:17:52 <lispy> latex rounds a bunch of the corners and puts on some training wheels.
20:18:29 <twobitsprite> er yeah... I thought latex was usually implied...
20:19:40 <gzl> there are people who do use straight TeX. so best to say LaTeX.
20:21:12 <twobitsprite> I see
20:26:04 <twobitsprite> hmm... I wish you could put guards in types...
20:27:08 <dons> guards in types?
20:27:10 <twobitsprite> i.e. type Digit a | a < 10 = Int or something... but I guess syntax would be wierd for that
20:27:24 <dons> ah. you want  smart constructors.
20:27:32 <dons> \wiki Smart_constructors
20:27:33 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
20:27:40 <eivuokko> Dependent types?
20:27:47 <dons> checking stuff on the type level can be done (without dependent types)
20:27:56 <dons> or just by coding up a smart constructor
20:28:34 <twobitsprite> yeah, I've seen "smart constructors" in the idioms page... but how to you check stuff at the type level?
20:28:53 <dons> read the section on "Enforcing the constraint statically"
20:28:57 <dons> on the smart constructors page
20:29:03 <dons> I added it recently
20:29:19 <twobitsprite> k
20:29:21 <dons> you represent the numbers on the type level, and check those with operators on the type level
20:29:37 <dons> instance InBounds (S (S (S (S Z)))) where
20:29:40 <dons> for exmale :)
20:29:55 <dons> but, you can also get decimals if you're willing to write a little more code
20:30:09 <dons> there's links to that on the Type arithmetic page
20:30:59 <twobitsprite> ahh... I remember that... I don't want to have to use Peano numbers... because my numbers will be in the range [0, 3^18)...
20:31:11 <dons> so, thne, a smart constructor :)
20:31:25 <twobitsprite> dons: right-o :)
20:31:54 <dons> prehaps I'll add a secion using a decimal repreesntation to handle really big numbers.
20:32:07 * dons adds this to the todo list
20:32:31 <twobitsprite> dons: would that still be efficient?
20:32:43 <dons> well, you'd at least by able to write them
20:32:59 <dons> (D1,D5,D2,D9) == 1529
20:33:02 <twobitsprite> I mean... for i.e. doing arithmetic, etc...
20:33:08 <twobitsprite> CPU-wise
20:33:25 <dons> oh, yes. oleg's got many arithmetic running in the type checker
20:33:33 <dons> fibonacci, md5 (?) I think
20:33:46 <dons> the type checker is surprisingly efficient :)
20:34:10 <eivuokko> Haskell rules makes it fairly easyto make efficient.
20:34:10 <dons> follow the links to Oleg's work on the type arithmetic page 
20:34:19 <twobitsprite> but there is still a slow down, right? I mean, you aren't using the MCP or any CPU arithmetic pipes...
20:34:26 <dons> of course
20:34:34 <dons> it's being innterpreted by the type checker
20:34:39 <twobitsprite> right
20:34:58 * twobitsprite will stick with function-constructors
20:35:04 <dons> hmm. however, a smart constructor that was run at compile time in a TH splice -- would be efficient
20:35:07 <twobitsprite> (constructor-functions?)
20:35:16 <twobitsprite> TH?
20:35:16 <dons> construcotsr
20:35:37 <dons> Template Haskell, a compile-time meta programming language in ghc
20:37:00 <twobitsprite> dons: isn't that like a macro system?
20:37:06 <twobitsprite> a la camlp4, etc?
20:37:31 <dons> it can be used for macros, yep
20:37:43 <dons> but it's actually running haskell code, in the compiler
20:37:53 <twobitsprite> is it easier to use than camlp4?
20:37:53 <dons> that constructs abstract syntax trees
20:38:01 <dons> hmm. i don't know
20:38:14 <dons> it's easy for simple things
20:38:40 <dons> large things can get a bit hairy, since you play with abstract syntax of full haskell, without a lot of syntactic support.
20:38:41 <twobitsprite> like introducing a base-27 number literal? :)
20:39:11 <lispy> synatic support is for the weak!
20:39:13 <twobitsprite> i.e. "0p112" => "14"
20:39:23 <dons> yeah, you could add that.
20:39:26 <twobitsprite> (er... that's ternary :P)
20:39:33 <dons> \remember lispy synatic support is for the weak!
20:39:34 * araujo loves flip
20:39:34 <lambdabot> Done.
20:39:36 <araujo> yay!!!
20:40:00 <lispy> > flip flip
20:40:01 <lambdabot>   add an instance declaration for (Show (b -> (a -> b -> c) -> a -> c))
20:40:08 <lispy> @type flip filp
20:40:09 <lambdabot> Not in scope: `filp'
20:40:12 <lispy> @type flip flip
20:40:13 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
20:41:01 <twobitsprite> @type flip flip sequence
20:41:02 <lambdabot> forall a c (m :: * -> *) a1.
20:41:02 <lambdabot>         (Monad m) =>
20:41:02 <lambdabot>         (a -> ([m a1] -> m [a1]) -> c) -> a -> c
20:41:17 * twobitsprite 's head explodes
20:41:34 * lispy gets bits of sprites all over himself
20:41:53 * lispy gets out the Bits-B-Gone cleaner
20:41:54 <twobitsprite> lol
20:43:18 <jcreigh> gotta love CGA...
20:43:32 <lispy> heh, TGA was cooler! ;)
20:45:01 <twobitsprite> is there a short-hand for (Int, Int, Int, Int, Int, ...)?
20:45:05 <twobitsprite> :P
20:45:41 <twobitsprite> or maybe a list would be better...
20:47:27 <dons> yep
20:47:32 <dons> a list would be better
20:47:38 <dons> or maybe write a data type
20:47:43 <twobitsprite> dons: that
20:47:47 <twobitsprite> 's what I'm doing
20:47:52 <dons> data I27 = I Int Int  Int ....
20:48:31 <twobitsprite> hmm... n/m I need to rethink this... that wouldn't be very memory efficient
20:48:46 <twobitsprite> (I know, I know... premature-optimization and all that...)
20:48:53 <dons> the data type would be as efficient as the tuple
20:49:02 <dons> but such a large number of Ints is a bit weird
20:49:08 <dons> maybe you just want an array?
20:49:37 <eivuokko> Or many types and one to combine them.
20:49:51 <twobitsprite> I know... but maybe it's just better to have a single Int, and then devide/modulo when I need ternary digits...
20:49:51 <dons> yeah even better
20:50:18 <twobitsprite> type Tryte = Int
20:50:43 <twobitsprite> tryte x | x < 3 ^ 9 = Tryte x
20:50:51 <twobitsprite> er
20:51:54 <twobitsprite> data Tryte = Tryte Int
20:51:59 <twobitsprite> ?
20:55:02 <Saulzar> twobitsprite, type just makes a type synonym, data makes a new type
20:55:31 <twobitsprite> Saulzar: right... is my last declaration correct?
20:56:59 <Saulzar> Yes, it works doesn't it? :)
20:57:19 <twobitsprite> > data Tryte = Tryte Int
20:57:20 <lambdabot>  parse error on input `data'
20:57:53 <twobitsprite> you can't use data declarations in the repl?
20:58:14 <twobitsprite> (do haskellers call it a repl, or a top-level?)
20:59:02 <Saulzar>  @eval, or > isn't the top level... it just evaluates an expression
20:59:43 <dons> it's in a do loop, effectively
20:59:52 <dons> so you can only type expressions
21:00:04 <twobitsprite> dons: right... but even in ghci
21:00:15 <dons> even in ghci, it's a do loop
21:00:25 <twobitsprite> I see... you don't call it a REPL or top-level?
21:00:25 <dons> you write them in a file, and load that in ghci
21:00:37 <dons> no, it's not a part of the language
21:00:51 <dons> but ghci does provide a REPL, II guess
21:01:41 * araujo calls it REPL
21:02:00 * twobitsprite will call it REPL then...
21:04:25 * twobitsprite wishes he didn't have to specify "deriving Show" for all his types/datas
21:04:25 <jcreigh> I'm new to haskell, and I've wondered about that. Is it because Haskell does so much type inference and whatnot that it's more or less impossible to have a REPL like Lisp/Python/Ruby have where it's possible to declare functions?
21:04:47 <twobitsprite> jcreigh: I doubt it... Ocaml does type inference and has a full REPL
21:05:52 <twobitsprite> it might be because of the laziness and the fact that in a file order of declarations is mostly irrelevant...?
21:06:06 <jcreigh> twobitsprite: Hmmm. Well, in Haskell, you can say
21:06:09 <jcreigh> y = x * 2
21:06:11 <jcreigh> x = 4
21:06:16 <jcreigh> ...and it works
21:06:27 <jcreigh> And I can see that messing with a REPL.
21:06:32 <twobitsprite> jcreigh: that's what I was just saying... 
21:06:47 <eivuokko> Yeah, error messages would suffer.
21:06:49 <twobitsprite> jcreigh: that's not just type inference though, that's mostly the laziness
21:07:56 <jcreigh> twobitsprite: Oh, right, that is what you said. :) I should starting paying attention to other people...
21:08:18 <eivuokko> Maybe if one was forced to write types first, then a binding group at a time...but that'd possibly alter semantics.  Same with class instances
21:08:34 <araujo> jcreigh, it is because of static typing afaik
21:09:03 <araujo> mmm..
21:09:28 <araujo> jcreigh, you can use let declarations inside ghci though
21:09:33 <twobitsprite> araujo: no, because Ocaml has static type and has a full REPL
21:09:45 <araujo> twobitsprite, ?
21:09:53 <araujo> twobitsprite, what do you cal a full REPL?
21:10:12 <twobitsprite> araujo: supports the full language
21:10:41 <twobitsprite> ack... it's midnight... need to sleep
21:11:51 <araujo> twobitsprite, i thought ocaml repl had the same approach of ghci
21:12:12 <twobitsprite> araujo: I can define types in the Ocaml REPL, I can't in ghci
21:13:16 <twobitsprite> Pseudonym: nice pseudonym :P
21:13:33 <dons> such a thing could be written , but i'm not sure it would make sense. since the types inferred for declarations could be invalidated by later declarations
21:13:47 <dons> remember that haskell isn't a top-to-bottom evaluation language
21:13:49 <jcreigh> twobitsprite: You never know. That might be his real name. :)
21:14:27 <twobitsprite> dons: that's what I was saying... I'm saying that static typing, etc are probably not the reason that ghci doesn't support a full REPL, but there were probably other reasons, i.e. laziness
21:14:53 <jcreigh> dons: At first, I was a little disappointed that Haskell didn't seem to support such an obvious feature. But when you're right, when you think about it, there's really no way to implement that would make sense.
21:15:33 <jcreigh> s/when// (using vi behavior of only matching the first occurence on a line)
21:15:47 <araujo> twobitsprite, since jcreigh mentioned only dynamic typing REPL, i thought he was assuming those REPL were "full" for eval or some other dynamic typing feature....
21:16:16 <twobitsprite> jcreigh: I tought that was usual behavior for regexps... but then again, I haven't used them anywhere but vi in a while...
21:16:31 <palomer> I don't see why one couldn't have a REPL for haskell
21:16:57 <araujo> we already have one
21:17:18 <twobitsprite> palomer: well... you would have to change some things, i.e. not being able to retro-activly define things...
21:17:29 <jcreigh> bedtime...
21:17:43 <twobitsprite> i.e. y = x + 1; x = 4 -- woudln't work as per jc's example
21:18:59 <dons> you could do it, but it would be equivalent to hitting :reload in ghci after each declaration
21:19:11 <dons> i.e. old decls could become type incoorrect by new decls
21:19:24 <dons> so, maybe that's useful, maybe not
21:19:37 <dons> and when old decls don't type check anymore. what do you do? how do you edit them?
21:20:02 <ncalexan> dons: that's obvious... embed emacs in ghci.
21:20:34 <dons> so in the end, the only system that works, is to have an editor running with the whole state in it, and a :reload -- i.e. what we already do :)
21:21:11 <dons> yeah, perhaps if you had stronger support for embedding editors in ghci, there couuld be tigher integration
21:21:37 <dons> still, when you add a new type decl, and suddenly the whole state doesn't type check.. that's going to suck, and you need an editor to fix things again.
21:21:47 <dons> so, much better to say: no new types to be declared
21:22:40 <palomer> yeah, a REPL wouldn't be useful for haskell
21:22:46 <dons> some nice macros to embed ghci in your editor would be good though
21:22:55 <dons> so it did a :reload for you when you save things, perhaps
21:23:15 <eivuokko> Yeah, automatic :reload on fiel change in ghci...please :)
21:23:18 <dons> but it would be only an incremental improvement on what we have now
21:23:18 <palomer> it could be done for...yi!
21:24:03 <dons> eivuokko, you'd have to be sure you only save things when they're type correct... or have some other way to say, "ok, now type check it"
21:24:19 <dons> I save more often than i :reload
21:24:26 <eivuokko> dons, As it happens, I usually save when I wnat :reload :)
21:25:06 <dons> actually, on this topic, i have a script that type checks my module from my editor, and inserts the types that are inferred
21:25:10 <eivuokko> ghc error messages are easy to read...I see at a glance if error messages are relevant almost all the time
21:25:40 <dons> so at least I don't need to leave vim to type check
21:26:07 <araujo> dons, script written in?
21:26:18 <eivuokko> I use visual haskell, but the embedded compiler and project thingy isn't good enough atm.
21:26:43 <dons> araujo, it's a two line shell script that passes vim buffers to ghci to check
21:26:50 <dons> and then returns the result back to vim
21:27:06 <araujo> oh, ok
21:27:07 <eivuokko> Hmh
21:27:21 <eivuokko> How do you get dependencies right?
21:27:43 <dons> how does ghci get it right?
21:28:07 <eivuokko> By being run from correct path in regards of hierarchy, or commandline, usually
21:33:51 <dons> hmm, I don't understand your questoin "How do you get dependencies right?"
21:33:56 <dons> who, which dependencies?
21:35:08 <eivuokko> Other modules
21:35:17 <eivuokko> (.hi files, or .hs files)
21:36:10 <newsh2> I wrote an FFI example.  Comments welcome, especially if there's a common case that I didnt cover:  http://lava.net/~newsham/x/ffi/
21:37:19 <newsh2> any ideas for more realistic examples godo too
21:37:21 <newsh2> good
21:37:31 <eivuokko> A note that "wrapper" generates stubs .c .h that need to added in more complex build system
21:38:03 <eivuokko> (at least iirc, they need to be added if not using ghc --make in one pass)
21:38:46 <Pseudonym> Is anyone here a Win32 programming expert?
21:39:04 <newsh2> eivuokko: i'm accessing C code from haskell, not vice versa.
21:39:09 <eivuokko> I dislike (but it's not that serious) that you use malloc and newCString in away that async exception can leak memory
21:39:21 <newsh2> (typically a .h file would already exist and you'd have to conform to that)
21:39:21 <eivuokko> Pseudonym, define expert :)
21:39:41 <newsh2> i knwo some win32, its nto what I specialize in
21:40:03 <Pseudonym> Ever debugged a custom ActiveX control?
21:40:31 <newsh2> I dont know activex.  i'm somewhat familiar w/ visual studio and windebug debuggers
21:40:44 <Pseudonym> This is definitely an ActiveX problem.
21:40:59 <Pseudonym> So thanks, but I don't think you can help.
21:41:18 <eivuokko> newsh2, also, you don't free callback generated from wrapCB.
21:41:46 <newsh2> needs to be freed?
21:41:47 <eivuokko> newsh2, Considered moving the example to the wiki, btw? :)
21:41:50 <eivuokko> Yup
21:42:20 <newsh2> yes, i want to wiki it (or have somenoe else do it) but want some feedback first
21:42:38 <newsh2> i made it because there wasnt a good wiki example
21:43:11 <eivuokko> \hoogle freeHaskellFunPtr 
21:43:12 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
21:43:37 <newsh2> do I need to free my other mallocs too?
21:43:58 <eivuokko> Yeah, probably.  (I don't use malloc myself)
21:44:15 <eivuokko> Using ForeingPtr malloc is maybe a good idea.
21:44:27 <eivuokko> or alloca
21:44:28 <newsh2> ok, why? :)
21:44:39 <eivuokko> Not to leak memory? :)
21:44:51 <eivuokko> Well
21:44:58 <eivuokko> The thing with async exceptions..
21:45:29 <eivuokko> ..you need to use eith Control.Exception.block correctly (and unblock) or bracket-based "with"-swtyle resource handling
21:46:18 <eivuokko> Or you risk leaking memory...or in case of constructing ForeignPtr with finaliser, the whatever resource it points to
21:46:27 <newsh2> why ForeignPtr instead of Ptr?
21:46:53 <eivuokko> Because, then you cannot leak the memory (in case of malloc vs mallocForeignBytes or something)
21:47:14 <eivuokko> But as you'd need to use withForeingPtr anyway.. alloca is easier in your example
21:49:51 <newsh2> updated the code, it has frees now for the mallocs and the funptr thing
21:50:07 <eivuokko> If you ask me, if possible at all..don't care about async exceptions.  But if you are writing library or something, it is a huge thing to say to someone using killThread.
21:51:37 <newsh2> i dont really care about the exception thing much but i thought it was a reasonable example of a multi-return function
21:51:42 <newsh2> also a lot of win32 apis work that way
21:51:50 <eivuokko> Don't I know that :)
21:52:10 <eivuokko> I have use6 written, which combines six with-style resource handlers into one
21:52:17 <eivuokko> And I have needed it with win32 apie :)
21:53:18 <newsh2> maybe is hould put it up and let dons hack away at it 
21:53:41 <eivuokko> I think you still don't free CStrings
21:53:51 <newsh2> thanks
21:54:39 <eivuokko> Also, you use rror in IO monad, while fail might be better
21:54:43 <eivuokko> *error
21:55:17 <newsh2> I dont use errors much.  how does fail differ from error?
21:55:24 <eivuokko> It's in monad
21:55:30 <eivuokko> Monad :)
21:55:37 <eivuokko> error is pure, I think
21:55:41 <eivuokko> Well "pure"
21:55:51 <newsh2> so how is it better?  
21:56:20 <eivuokko> It looks better to me :)  (Uses "more" local error handling, instead of neutral error)
21:58:44 <newsh2> where on the wiki would this go?
21:58:59 <lispy> @hoogle pushmatrix
21:59:00 <lambdabot> No matches found
22:00:54 <newsh2> theres a page with some ffi stuff on it but i dont know where its linked from
22:01:10 <lispy> i hate this about hopengl, i can never find the corresponding function to the opengl function
22:01:14 <lispy> i want glPushMatrix()
22:03:07 <newsh2> can you list all pages that link to a page in wiki?
22:03:51 <lispy> newsh2: you can with mediawiki, not sure what type of wiki we're talking about.  If it happens to be mediawiki look for a link called "Special Pages" ond you'll find it listed as a special page
22:04:56 <newsh2> i dont know how to edit the wiki.
22:05:45 <lispy> @hoogle matrixExcursion
22:05:46 <lambdabot> No matches found
22:07:29 <int-e> lispy: hmm? don't you just drop the gl prefix and make the first letter lower case?
22:08:59 <lispy> int-e: i wish it was that easy, but whoever wrote HOpenGL thought it would be fun to arbitrarily rename things without ever creating a lookup table
22:09:21 <ncalexan> @hoogle matrix
22:09:22 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.Matrix :: Matrix m
22:09:22 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.matrix :: (Matrix m, MatrixComponen
22:09:22 <lambdabot> t c) => Maybe MatrixMode -> StateVar (m c)
22:09:22 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.MatrixMode :: MatrixMode
22:09:29 <lispy> based on some random finds on gmane i thinkit's matrixExcursion
22:09:32 <lispy> time to try it
22:10:30 <lispy> nope, that's not defined
22:10:49 <int-e> preservingMatrix :: IO a -> IO a ... but is that really HOpenGL?
22:11:30 <int-e> Heh. I wonder how many OpenGL bindings for Haskell there are.
22:12:32 <lispy> i think the only one that likes HOpenGL is probably the author
22:12:52 <lispy> i know, i'm confused and frustrated by the changes to the api
22:13:20 <lispy> but it is the most complete binding i've seen (not that it seems to matter since I can't even do the basics with it...)
22:14:07 <lispy> HGL is probably what I should be using
22:14:17 <ncalexan> I think so.
22:15:04 <lispy> oh second thought, HGL doesn't do opengl does it?
22:15:41 <int-e> "We are pleased to announce a new release of the HGL: a portable graphics library."
22:16:08 <lispy> well, in that case HOpenGL is the only opengl binding for haskell that i know of
22:17:40 <newsh2> http://www.haskell.org/hawiki/FfiExample?action=show
22:18:33 <ncalexan> lispy: maybe http://www.informatik.fh-wiesbaden.de/~panitz/hopengl/skript.html would be helpful?
22:18:45 <ncalexan> I found the bindings excellent, but I really didn't do much with them.
22:23:11 <Saulzar> I like HOpenGL lispy :)
22:24:12 <lispy> ncalexan: good link...but i'm not finding those matrix stack functions
22:24:23 <Saulzar> preservingMatrix is the one
22:24:38 <lispy> Saulzar: i'd like it a lot better if the types weren't so painful and i know the mapping between opengl functions and hopengl
22:24:48 <lispy> why did they change the name?
22:24:51 <Saulzar> We've had this discussion before :P
22:24:52 <lispy> thanks tho
22:24:55 <Saulzar> Well, it does a push and pop
22:25:29 <Saulzar> So you use it like a block
22:25:38 <Saulzar> preservingMatrix $ do
22:25:40 <Saulzar>     foo
22:25:42 <Saulzar>      bar
22:26:18 <lispy> why isn't that documented anywhere? Especially the deviation from opengl
22:26:31 <lispy> and if it is documented, why is it so hard to find?
22:27:24 <lispy> i'm not trying to be grumpy, i just can't understand the motivation
22:28:07 <lispy> IMO, you'd want to make a very thin wrapper called HOpenGL and then make these sort of utility/convience/sanity functions on top of that and give it a new name
22:28:24 <Saulzar> Well, it's under Graphics.Rendering.OpenGL.GL.CoordTrans along with all the other functions for transforms etc..
22:29:04 <Saulzar> I guess that's one way, but then you clutter everything up.
22:30:41 <lispy> one thing that confuses me about the types is that in opengl you have glTranslate2f and glTranslate3f, right?  but in HOpenGL translate (Vector2 0 (0::Float)) is not valid
22:31:31 <Saulzar> I beleive there is only glTranslate  (takes 3 arguments fixeD)
22:32:27 <Saulzar> Yep, seems the transformation funcs only have one version
22:33:02 <lispy> alright
22:33:20 <lispy> wonder what function i was thinking of
22:33:43 <newsh2> whats the debian shootout thing about?
22:33:49 <Saulzar> glVertex etc.. has several versions
22:33:56 <Saulzar> In fact a lot of the functions do
22:34:43 <Saulzar> translate seems a special case where it doesn't
22:35:16 <Saulzar> I guess it's not of much use to have 8 data formats for convenience functions :)
22:38:10 <int-e> hmm, Translate isn't used that often, is it? in the case of Vertex you can actually save a lot of bandwidth between client and server by providing special versions for pairs and small data types.
22:39:54 <int-e> anyway, the GL specification says this in a footnote: "The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada that allow passing of argument type information admit simpler declarations and fewer entry points."
22:41:59 <lispy> that makes sense when you have glVertex() instead of glVertex#T() where # is the number of points and T is a type
22:42:43 <int-e> the gl prefix isn't part of the specification either. bracket style replacements of push/pop-pairs aren't though, I agree that they should be mentioned somewhere.
22:43:03 <int-e> btw, does anything about http://haskell.org/HOpenGL/examples/Planet.hs strike you as odd?
22:43:23 <Saulzar> Is that the out of date version which doesn't compile?
22:43:32 <Saulzar> Yeah, it is
22:43:56 <Saulzar> That website needs removing/marked clearly as depreciated..
23:02:11 <dons> newsh, debian shootout?
23:05:20 <sieni> dons: I suppose he refers to http://shootout.alioth.debian.org
23:05:20 <dons> \shootout?
23:05:21 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
23:05:21 <lambdabot> all
23:05:59 <sieni> hmm... clean has surpassed haskell in speed
23:08:27 <dons> it should -- it's fast!
23:08:35 <dons> they have some good low-level io libs too
23:08:49 <dons> but, as long as lazy languages are at the top, i'm happy :)
23:09:08 <dons> anyway, factor in 1 for memory and loc too, we're still 2nd by a good distance
23:09:49 <dons> also, at lot of weird tweaks happened to the benchmarks (i.e. the hard benchmarks now weight 1 too -- which punishes us, but helps languages like clean that don't implement, say, concurrency )
23:10:06 <nothingmuch> how is clean different from haskell?
23:10:11 <nothingmuch> i heard they were pretty related
23:10:34 <sieni> well at least it uses uniqueness types instead of monads for io
23:11:12 <nothingmuch> i got "well at least it uses bzzzt bzzzt instead of monads for io"... time to read =)
23:11:32 <sieni> hehe
23:11:41 <nothingmuch> oh, i see
23:11:51 <nothingmuch> type variables are instantiated once and only once?
23:12:22 <dons> much smaller set of libs and features too.
23:12:34 <dons> and they probably should just be the same language
23:12:38 <dons> oh well
23:12:42 <sieni> http://en.wikipedia.org/wiki/Uniqueness_type
23:18:58 <newsh2> where do you see ghc 2nd?  i see ghc at #5:  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
23:20:28 <int-e> newsh2: enter 1 at Memory Use and Code Lines to the right ... then it's second. they were the default weights for a while
23:21:26 <newsh2> i'm sure the regexp program is hurting the score
23:21:31 <newsh2> not terribly fast and lots of LoC
23:21:54 <int-e> not entering the benchmark at all is worse I believe
23:22:15 <newsh2> so someone should put regexp's into the prelude ;-)
23:25:43 <Muad_Dibber> increase the code lines and ghc will raise very hard :)
23:25:52 <grey-> newsh2: ack, you're everywhere.
23:26:18 <newsh2> muad: you can rank it strictly by loc (1/0/0)
23:27:08 <newsh2> hi grey
23:27:40 <charles> anyone using wxHaskell?
23:36:54 <newsh2> <dons> and they probably should just be the same language
23:37:01 <newsh2> how hard would it be to integrate the two?
23:55:29 <ProfTeggy> G'day all.
