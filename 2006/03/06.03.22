00:12:25 <adu> i'm installing ghc right now
00:13:04 <adu> i can't wait to use those cool heierarchical libraries
00:13:18 <sethk> dons, maybe (Just looked at your endian comment).  I'll check the numbers, see if they make sense that way.
00:15:03 <sethk> I know System.IO has openTemporaryFile.  Is there a function that returns a filename for a temporary file?  I can code it but I think I've seen it somewhere.
00:16:14 <sethk> found it (System.Posix.Temp)
00:16:51 <sethk> it also creates the file, which I can do without, but I'll just close it.
00:17:57 <vincenz> seems my rb-tree is crash free
00:17:57 <vincenz> \o/
00:17:58 <lambdabot> Maybe you meant: . id pl wn yow
00:18:05 <vincenz> time to use haskell to check consistency
00:19:01 <vincenz> damn
00:19:06 <vincenz> dooing intersperse in c++ is yucky
00:19:22 <vincenz> I want to have the different tree versions outputted with , in between
00:19:28 <vincenz> so I can just do read [Tree Integer]
00:19:49 <Korollary> sethk: I think it opens it immediately because otherwise it's a security flaw.
00:26:21 <vincenz> \o/
00:26:21 <lambdabot> Maybe you meant: . id pl wn yow
00:26:23 <vincenz> gotta love haskell
00:26:27 <vincenz> 10 lines of code to see when something fails
00:26:33 <vincenz> two fail caases
00:29:45 <nothingmuch> vincenz: ... then your brain explodes and you take a vacation ;-)
00:31:41 <shapr> @y0
00:31:41 <lambdabot> Maybe you meant: . id pl wn yow
00:31:45 <shapr> @y0w
00:31:45 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
00:31:45 <lambdabot> legislation..
00:34:04 <nothingmuch> morning shapr 
00:34:27 <shapr> goood morning nothingmuch!
00:35:26 <vincenz> shapr: :)
00:35:39 <vincenz> nothingmuch: you interested in haskell-oriented icfp-style competitions?
00:35:51 <nothingmuch> vincenz: no.... not enough free time
00:35:55 <nothingmuch> i'm interested only in theory
00:35:57 <nothingmuch> ;-)
00:36:23 <vincenz> shapr: this is so great... few lines of code, few lines for cairo, and I can see the two cases where my remove function for my c++ red-black tree fails is exactly one specific case in the rebalancing
00:36:31 <vincenz> ;)
00:37:52 * nothingmuch procastrinates in an orderly fashion
00:38:10 <shapr> vincenz: Tried QuickCheck?
00:41:40 <vincenz> shapr: doesn't help much
00:41:46 <vincenz> shapr: I'm coding a C++ rb tree
00:41:51 <vincenz> using haskell to display trees with cairo
00:42:00 <vincenz> and check color consistency (which is only like 3 lines of code)
00:42:05 <vincenz> I show all failed trees
00:42:11 <vincenz> and it easily allowed me to discover the failing case
00:42:32 <shapr> Ah, I see.
00:42:36 <vincenz> :)
00:43:45 <shapr> Any screenshots?
00:44:47 <vincenz> hmm sure
00:44:48 <vincenz> in a min
00:44:52 <vincenz> besides can't host at the moment
00:45:05 * vincenz wishes he could use options for the haskell program
00:45:09 <vincenz> not sure how to do getopts in haskell yet
00:47:24 <shapr> pesco wrote some nice code for that.
00:47:56 <vincenz> ah I see the issue
00:47:57 <vincenz> o.O
00:48:01 <vincenz> damn, wikipedia was wrong
00:48:53 <shapr> ?
00:49:38 <vincenz> nm
00:49:47 <vincenz> I see my problem
00:51:26 * vincenz considers inventing a format that can dump pointer-centric data
00:51:33 <vincenz> and then having haskell render it with cairo
00:51:37 <vincenz> :)
00:51:39 <Revision17> other than types, how is 'iterate' different than 'map'?
00:51:47 <vincenz> @type iterate
00:51:48 <lambdabot> forall a. (a -> a) -> a -> [a]
00:52:10 <vincenz> Revision17: iterate f x = [x, f x, f (f x), f (f (f x)]
00:52:22 <Revision17> oooooh
00:52:30 <Revision17> so it's like folding in o'caml
00:52:31 <vincenz> map f l = [f (head l), f (head $ tail l), f (head $ tail $ tail l)...
00:52:48 <vincenz> Revision17: ocaml expert?
00:52:51 <vincenz> good that's my lingo
00:52:51 <vincenz> no
00:52:53 <vincenz> it's not like fold
00:52:58 <vincenz> cause fold works on a list and generates a number
00:53:00 <vincenz> this is more like an unfold
00:53:52 <Revision17> I don't really know haskell or o'caml very well; but thanks I understand very well now
00:55:23 <vincenz> :)
00:58:17 <araujo> hiya!
00:59:40 <sethk> 'night all
01:00:49 * shapr yarghs
01:01:10 * shapr boings
01:01:12 <shapr> ofelt_: y0
01:05:36 <araujo> hola shapr 
01:07:26 <shapr> jiihaa!
01:08:57 <araujo> shapr, how you doing?
01:09:39 <vincenz> \o/
01:09:39 <lambdabot> Maybe you meant: . id pl wn yow
01:09:43 <vincenz> it wokrs
01:09:50 <vincenz> THANK YOU HASKELL AND CAIRO
01:09:50 * araujo wonders if shapr got some cool ideas about designing administration systems which he could steal 
01:09:53 <shapr> whee!
01:09:59 <shapr> araujo: What sort of admin systems?
01:10:05 <vincenz> araujo: check out hac
01:10:09 <vincenz> @where hac
01:10:10 <lambdabot> http://haskell.org/haskellwiki/HAC
01:10:23 <vincenz> we'll need some sort of admin system for that :D
01:10:32 <vincenz> time to make more test cases
01:10:42 <vincenz> ./maptest5 | ../treeChecker/tree
01:10:57 <araujo> shapr, well, ive got this univ. project about developing an administration system for bussiness transactions.
01:11:43 <shapr> What sort of business transactions?
01:11:48 <shapr> Purchases, or what?
01:12:18 <araujo> vincenz, that's a contest?
01:12:22 <vincenz> yeah
01:12:30 <vincenz> hmm
01:12:31 <vincenz> maybe I should do
01:12:39 <araujo> shapr, yes, purchasing , sorry if im not being clear enough
01:12:43 <vincenz> haskellprogramthatgenerates permutations | maptest3 | haskelltrecker
01:12:50 <araujo> shapr, you know, to keep track of purchasing and such
01:13:11 <vincenz> trecker = tree checker
01:13:17 <shapr> That's a pretty boring task, how about extending it to do something fun? =)
01:13:18 <araujo> The system will have to keep control of all the purchasing transactions and other money related transactions for a company.
01:13:28 <araujo> shapr, That's what im looking for!!!!!
01:13:31 <shapr> Ah!
01:13:55 <araujo> Sooooo boooring, that i want to turn it into something more interesting
01:14:01 <shapr> Yeah, I agree.
01:14:07 <shapr> Ok, I have some ideas.
01:14:18 <araujo> And i think that using Haskell would be a nice first step.... 
01:14:19 * shapr tries to get the ideas into words
01:14:25 <araujo> shapr, cool!
01:14:35 <shapr> Does it have to be for business?
01:14:37 <araujo> vincenz, cool indeed
01:14:41 <araujo> shapr, right
01:14:53 <araujo> shapr, or probably for an organization too
01:15:09 <vincenz> how do I run a process and pass it data and then take data back from it
01:15:09 <araujo> The main idea is to keep track of transactions whatever entity is
01:15:34 <araujo> vincenz, runInteractiveCommand ?
01:15:50 <vincenz> @hoogle runInteractiveCommand
01:15:51 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
01:16:09 <vincenz> hmm
01:16:09 <vincenz> odd
01:16:14 <vincenz> it's not documented in ghc's docs
01:16:22 <araujo> mm.. it's there
01:16:30 <vincenz> was looking at posix.process o.O
01:17:01 * shapr thinks
01:17:05 <araujo> shapr, :-]
01:17:27 <araujo> shapr, sucha boring thing that ive not found anything to make it fun
01:20:06 <vincenz> araujo: got any demo code using that function?
01:20:25 <araujo> @where hashell
01:20:26 <lambdabot> haskell.org/hashell
01:20:38 <araujo> ^ lot of places there
01:20:40 * vincenz just wants to pipe in a string, pipe out a string
01:20:42 <vincenz> and then read that string
01:22:15 <araujo> vincenz, well, just pass it the string to rIC and use some function to take the stdout handle contents to string
01:22:36 <araujo> @hoogle hGetLine
01:22:37 <lambdabot> System.IO.hGetLine :: Handle -> IO String
01:24:23 <vincenz> how do you close the input handle
01:24:25 <vincenz> once you're done
01:24:30 <vincenz> so the program will eventually terminate
01:25:05 <araujo> @hoogle hClose
01:25:05 <lambdabot> System.IO.hClose :: Handle -> IO ()
01:25:55 <vincenz> thx
01:25:56 <shapr> araujo: You could use STM to emulate open transactions.
01:25:59 <vincenz> was looking for it but couldn't see it
01:26:03 <araujo> Though i don't understand your question at all.... no need to close the input handle unless you just want to abort while passing input data
01:26:12 <shapr> araujo: Martin Fowler's 'Analysis Patterns' book has really great stuff on transactions.
01:26:35 <araujo> shapr, goodie, goodie, let's see
01:26:46 <vincenz> @hoogle ExitSuccess
01:26:46 <lambdabot> System.Exit.ExitSuccess :: ExitCode
01:28:13 <araujo> shapr, looks sweet
01:29:33 <farre> have you returned from your vacation nibro?
01:29:33 <shapr> What about a transaction system for a self employed person?
01:29:45 <araujo> shapr, goodie, that also would make it
01:30:23 <araujo> shapr, and since you are a self-employed, i think you could give me a bunch of ideas right? :-]
01:31:45 <vincenz> this is going to rock :)
01:35:59 <shapr> araujo: yes!
01:36:55 <Frobar> is the haskell convention of seeing a function with multiple arguments as a chain of functions taking one argument and returning a function just to make "locking" arguments possible when passing functions around, or is there something deeper to it?
01:37:40 <Frobar> bleh, pretty malformed sentence there, but i hope you see what i mean
01:37:47 <jips> deeper
01:39:14 <Frobar> ok, in what other circumstances is it advantageous to view functions that way?
01:42:24 <araujo> shapr, hah, this STM thing might give me some cool stuff to work around :-]
01:42:32 <vincenz> @hoogle args
01:42:32 <lambdabot> Distribution.Simple.Args :: [String]
01:42:32 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
01:42:32 <lambdabot> System.Environment.getArgs :: IO [String]
01:43:16 <araujo> shapr, i would like to know if you have any idea for this "self-employed" system
01:44:00 <araujo> shapr, would you mind taking some minutes when you got free time and email me about it? :-)
01:44:21 <araujo> vincenz, what are you hacking at?
01:46:54 <vincenz> araujo: test program
01:47:05 <vincenz> I'll paste later
01:47:08 <vincenz> @hoogle head
01:47:08 <lambdabot> Data.List.head :: [a] -> a
01:47:08 <lambdabot> Prelude.head :: [a] -> a
01:47:08 <lambdabot> Data.PackedString.headPS :: PackedString -> Char
01:55:32 <vincenz> \o/
01:55:33 <lambdabot> Maybe you meant: . id pl wn yow
01:55:42 <vincenz> time to generate permutations
01:55:52 <vincenz> :)
01:58:31 <vincenz> @hoogle perm
01:58:32 <lambdabot> System.Console.GetOpt.Permute :: ArgOrder a
01:58:32 <lambdabot> System.Directory.Permissions :: Permissions
01:58:32 <lambdabot> System.Directory.Permissions :: Bool -> Bool -> Bool -> Bool -> Permissions
01:58:44 <shapr> araujo: Yes, when I have free time.
01:58:50 <ski> Frobar
01:59:07 <ski> > map (map (* 10)) [[1,2,3],[4,5,6],[7,8,9]]
01:59:07 <Frobar> ski: yes?
01:59:08 <lambdabot> [[10,20,30],[40,50,60],[70,80,90]]
01:59:11 <ski> instead of
01:59:28 <ski> > map (\ns -> map (\n -> n * 10) ns) [[1,2,3],[4,5,6],[7,8,9]]
01:59:29 <lambdabot> [[10,20,30],[40,50,60],[70,80,90]]
02:00:15 <Frobar> i'm still a beginner, but isn't the first example just locking one of the arguments to *?
02:00:16 <ski> so you "partially apply" functions, giving some arguments early, and pass the resulting function that still wants more args to some higher-order function
02:00:32 <ski> both examples do same thing
02:00:55 <ski> 'locking one of the arguments to *' means ?
02:01:28 <Frobar> ski: yeah, that's the way i imagined it could be used. i mean the same thing with "function with locked argument" as you do with "partially applied function".
02:01:37 <ski> ah, ok
02:01:40 <ski> right
02:01:59 <ski> so it makes this idiom shorter and more concise
02:02:28 <ski> sometimes, there can be deeper reasons, too
02:02:37 <ski> most often if you have
02:02:42 <ski> foo :: A -> B -> C
02:03:01 <ski> then this function does nothing until given both arguments
02:03:24 <ski> but say that it will have some subcomputation that only depends on the first argument
02:03:33 <ski> then one could define like
02:03:47 <ski> f a = \b -> ...
02:03:48 <ski>   where
02:03:53 <ski>   blah = ..a..
02:04:09 <ski> s/f/foo/
02:04:45 <sethk> Frobar, if you for some reason don't want partial application you can always define a function that operates on a tuple  (A, B)
02:04:47 <ski> so, if you do 'map (foo some_a) some_list', then 'blah' would only be computed once, instead of once for each element of 'some_list'
02:05:02 <ski> Frobar : see what i mean ?
02:05:24 <sethk> Frobar, but the partial application is related to the way the run time system works
02:05:26 <Frobar> the way i think about it is that you create a new function by "locking" one of the arguments to a multi-arg function. so for example the function  (*) 5  will be the * function with the first argument locked to 5. while not correct, it makes the most intuitive sense when i compare with other languages i know :)
02:05:41 <ski> yes
02:05:48 <sethk> Frobar, indeed, that is precisely correct, the partial application returns a function
02:05:57 <vincenz> remind me how to generate all permutations
02:06:24 <Frobar> sethk: yup, i know, but then there is no such thing as a real "multi-arg" function. it's just a chain of functions taking one argument and returning a function.
02:06:33 <sethk> Frobar, in your example it returns the function that multiplies an argument by 5
02:06:47 <ski> Frobar : the point is, the function can possibly compute some stuff once, now already, when given first argument, instead of possibly many times, later, when the returned function is used
02:06:50 <Frobar> sethk: yes, i understand how it works
02:07:18 <sethk> Frobar, I know, but you seemed to think your terminology was somehow wrong, which it isn't, although the wording is a bit different
02:07:45 <ski> let foo_a = foo a  in [foo_a b0,foo_a b1,foo_a b2]
02:07:50 <ski> is better than
02:07:59 <ski> [foo a b0,foo a b1,foo a b2]
02:08:12 <vincenz> > [1,2,3] // 
02:08:13 <lambdabot>  parse error on input `}'
02:08:13 <vincenz> > [1,2,3] // 1
02:08:14 <lambdabot>  Not in scope: `//'
02:08:17 <ski> if we assume the compiler doesn't spot that this could be optimised
02:08:17 <Frobar> sethk: the reason i thought it was wrong was that it doesn't really make sense to talk of "multi-arg" functions in such a system, though i guess that's nitpicking :)
02:08:20 <vincenz> > [1,2,3] \\ 1
02:08:20 <lambdabot>  add an instance declaration for (Num [a])
02:08:24 <vincenz> hm
02:08:55 <sethk> Frobar, no, it isn't nit picking.  the first thing you'll find in a lambda calculus book (well, maybe the 2nd or 3rd) is that only functions of one argument are available.
02:09:00 <ski> > [1,2,3] \\ [1]
02:09:01 <lambdabot> [2,3]
02:09:19 <sethk> Frobar, and that, while this seems like a problem, it isn't because ....
02:09:44 <ski> currying, and tupling
02:10:13 <sethk> ski, real functional programmers don't tuple  :)
02:10:32 <ski> sethk : divMod
02:10:48 <Smokey`> how would a real functional programmer represent a 3D vector, or an RGB colour? :)
02:11:08 <shapr> tuple? Or maybe a custom type with an Enum instance?
02:11:08 <sethk> Smokey`, don't ask me, I'm only a pseudo functional programmer  :)
02:11:20 <ski> RGB :: Double -> Double -> Double -> Color
02:11:22 <Smokey`> hehe :)
02:11:27 <ski> see, a curried constructor ! :)
02:11:55 <ski> data Color = RGB Double Double Double
02:12:21 <ski> (and i don't agree about not tupling .. tupling has it's place)
02:14:02 <adu> do you haveto define your own get methods for triples?
02:14:15 <ski> yes
02:14:28 <ski> (if you want them, i.e.)
02:14:50 <Frobar> hrm, if you wonder why i didn't respond to your examples, i'm still on page 20 of my haskell book, and had some trouble parsing the syntax, though i understand the gist of it :)
02:14:53 <adu> whats the usual convention? or does it differ depending on what kinds of things they have?
02:16:13 <adu> like n1of3 (a, b, c) = a
02:16:29 <ski> i've seen 'fst3'
02:16:36 <adu> oh
02:17:01 <adu> what would tha last be, thd3?
02:17:18 <ski> something like that, i think
02:17:20 <sethk> ski, I didn't mean to imply that tuples are wrong.  just that they shouldn't be used because a function takes more than one argument.
02:17:33 <ski> (i think these 3 were in some old hugs or gofer prelude)
02:17:59 <adu> hm
02:18:36 <ski> Frobar : ok .. (i can explain some more, if you wonder about anytihng specific in the examples)
02:18:39 * vincenz runs a few million test
02:18:44 <Frobar> is monads just a structured way to temporarily go imperative for operations that require it?
02:18:50 <adu> what is the advantage of using (a,b) over [a,b]?
02:18:54 <ski> Frobar : no
02:18:56 <Frobar> ski: nah, i understand the gist, and i'll probably get to it in a few days
02:19:05 <ski> adu : list elements must have same type
02:19:08 <vincenz> araujo: pnig
02:19:20 <ski> > [False,'a']
02:19:21 <lambdabot> Couldn't match `Bool' against `Char'
02:19:23 <adu> ski: what about [a, b] could have type [Either a b]
02:19:25 <ski> > (False,'a')
02:19:26 <lambdabot> (False,'a')
02:19:29 <vincenz> araujo: ping pong
02:19:39 <ski> adu : sure, that qualifies as 'same type' :)
02:19:44 <ski> > [Left False,Right 'a']
02:19:45 <lambdabot> [Left False,Right 'a']
02:19:56 <ski> also
02:20:12 <adu> is there a 3-way either class?
02:20:14 <ski> [WrapShow False,WrapShow 'a']
02:20:18 <ski> if you have
02:20:25 <ski> data Showable
02:20:27 <ski>   where
02:20:35 <shapr> Frobar: monads a way to make a pipeline that abstracts a certain operation, for example, ever wanted to abstract out a bunch of nested if/then/else calls?
02:20:37 <ski>   WrapShow :: Show a => a -> Showable
02:21:03 <ski> adu : no predefined, i think
02:21:09 <adu> so if there was an n-way Either-like class then you wouldn't need tuples at all
02:22:02 <adu> or maybe a few 
02:22:03 <ski> > [Left False,Right Left ('a'),Right (Right Data.Char.chr)]
02:22:03 <lambdabot> Couldn't match `Either a b' against `t -> t1'
02:22:12 <adu> like Any3, Any4
02:22:15 <ski> @type [Left False,Right (Left 'a'),Right (Right Data.Char.chr)]
02:22:15 <lambdabot> [Either Bool
02:22:15 <lambdabot>                        (Either Char (Int -> Char))]
02:22:17 <Frobar> shapr: how is it different from a function in a imperative language?
02:22:23 <Frobar> +n
02:22:45 <ski> Frobar : monads abstract effects
02:22:52 <araujo> vincenz, pong
02:23:00 <Frobar> ski: could you provide some example?
02:23:06 <ski> common side-effects are, state (assignment), exceptions, goto
02:23:10 <shapr> Frobar: The monadic interface is an abstraction just like objects are an abstraction.
02:23:12 <vincenz> araujo: http://rafb.net/paste/results/1e6Rgh96.html
02:23:13 <ski> there are also others
02:23:17 <shapr> It's a way to hide the plumbing.
02:23:52 <ski> Frobar : have you seen 'Maybe' yet ?
02:24:17 <Frobar> but isn't that just the way a function works in an imperative language? it abstracts effects.
02:24:23 <Frobar> ski: nope, what is it?
02:24:44 <robokop> maybe is cool
02:24:45 <ski> Frobar : but in haskell, functions doesn't abstract effects, just plain pure computation
02:25:16 <ski> > lookup "b" [("a",1),("b",3),("c",6)]
02:25:16 <lambdabot> Just 3
02:25:21 <ski> > lookup "x" [("a",1),("b",3),("c",6)]
02:25:22 <lambdabot> Nothing
02:25:28 <ski> @type lookup
02:25:29 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
02:25:31 <Frobar> ski: yeah, and so i thought monads was perhaps a way to get imperative-style effect-abstracting "functions" for operations that require it
02:25:52 <ski> Frobar : yes ... they can do that
02:25:52 <Frobar> ah well, it'll probably clear on me when i've read some more
02:26:01 <ski> Frobar : but they are more general
02:26:57 <ski> Frobar : 'lookup' searches an association list (of key/value - pairs), when it finds a matching key, it returns the corresponding value
02:26:59 <Frobar> in that they can be used any time you want some effect in your functional world?
02:27:09 <ski> Frobar : yes
02:27:53 <Frobar> i have to go to a lecture, thanks for the help!
02:28:02 <ski> but sometimes the key you're looking for isn't in the association list (and you want to catch this condition, instead of aborting program), so you need to tell the caller of the function that there was no value
02:28:03 <ski> ko
02:28:07 <ski> ok
02:28:09 <Maddas> Yow!
02:28:39 <Maddas> @yow
02:28:39 <lambdabot> Hey, wait a minute!!  I want a divorce!! ... you're not Clint Eastwood!!
02:29:56 <vincenz> @quote vincenz 
02:29:57 <lambdabot>  \o/
02:30:13 <Maddas> vincenz: :-)
02:30:29 <ski> @keal
02:30:29 <lambdabot> i can explain why something is without knowing what the rules decided by man are
02:31:06 <ski> hm ..
02:31:18 <ski> it seems 'seq' can be defined in haskell
02:32:01 <vincenz> > last [1,2,3]
02:32:02 <lambdabot> 3
02:39:46 <shapr> @quote
02:39:47 <lambdabot> samc says: monads are hard, let's go shopping
02:41:37 <sethk> who's samc?
02:42:25 <shapr> He's the Sam from .nz, iirc
02:42:43 <sethk> ok  :)
02:42:51 <shapr> We've had samc, samx, SamB, and at least one other sam.
02:43:03 <shapr> I suggested they start #sam ;-)
02:43:11 <sethk> almost as bad as simons  :)
02:43:15 <shapr> heh, yeah
02:43:29 <tennin> I saw "case [() | Flag <- list] of {_:_ -> a; _ -> b}" in someone's code.  Is there a reason to use this over "if Flag `elem` list then a else b" ?
02:44:46 <ski> first version words even if 'T' isn't in 'Eq' (where 'list :: [T]')
02:45:12 <shapr> I'm confused, wouldn't that listcomp generate a () for each flag?
02:45:43 <sethk> tennin, the compiler turns the if/then/else into case anyway ...
02:45:46 <tennin> yeah, my other question is whether it works lazily or not
02:45:49 <ski> shapr : yes
02:46:34 <ski> tennin : it does  (if you mean lazy in the list)
02:47:58 <tennin> I mean, does it actually generate the whole list of ()'s or does it stop as soon as the _:_ condition is satisfied
02:48:01 <ski> (shapr : so it would count how many 'Flag's were in the list, and then lazily check if this count was > 0 or = 0)
02:48:13 <ski> tennin : latter
02:48:16 <tennin> ok, thanks
02:49:11 <ski> > case [() | True <- [False,True] ++ undefined] of {_:_ -> True; _ -> False}
02:49:12 <lambdabot> True
02:49:46 <ski> > case [() | True <- [False] ++ undefined] of {_:_ -> True; _ -> False}
02:49:47 <lambdabot> Undefined
02:49:56 <ski> > case [() | True <- repeat False] of {_:_ -> True; _ -> False}
02:50:00 <lambdabot> Terminated
02:50:06 <ski> > case [() | True <- [False,False]] of {_:_ -> True; _ -> False}
02:50:07 <lambdabot> False
02:52:13 <tennin> so, the difference is that the test in "Flag <- list" is built in to the language semantics instead of relying on an outside function == ?
02:52:20 <ski> yes
02:52:46 <ski> possibly the type can't be in Eq, because of other constructors having noncomparable arguments (such as functions)
02:53:27 <ski> (or they could have arguments of parametric type, and the author didn't want to bring in an require an extra 'Eq' constraint in his function, when it isn't really needed)
02:53:55 <vincenz> araujo: taken a look?
02:54:00 <vincenz> people
02:54:02 <tennin> thanks
02:54:07 <vincenz> look at @where hac
02:54:19 <vincenz> @where hac
02:54:20 <lambdabot> http://haskell.org/haskellwiki/HAC
02:58:14 <shapr> vincenz: Hey, did I say Daan Leijen's name anywhere close to correctly? :-)
02:58:19 * shapr has a sudden idea...
02:58:56 <vincenz> shapr: yes
02:59:01 <vincenz> err oh say..
02:59:02 <vincenz> not sure
02:59:16 * vincenz has the memory of a 1-year old fish
03:01:12 <vincenz> shapr: what's the idea?
03:02:14 <shapr> Oh, it was to create a wiki page of Haskell voice chat people.
03:02:19 <shapr> But I got completely distracted.
03:02:46 <shapr> kzm: y0
03:03:15 <shapr> kzm: Could you use the free command to build the +RTS -Mxxx for you?
03:03:21 <sieni> Cool: http://www.haskell.org/pipermail/haskell/2006-March/017656.html
03:03:59 <shapr> sieni: Yeah, it rocks.. I still haven't figured out how to use it for a blog though.
03:06:09 <vincenz> I don't get it
03:06:12 <vincenz> it's not pure haskell
03:06:14 <vincenz> they have to parse it
03:06:23 <vincenz> which means that basically they could just be reading xml
03:06:49 <shapr> hm?
03:07:08 <shapr> What do you mean it's not pure Haskell?
03:07:31 <vincenz> We should point out the absence of commas.
03:08:13 <shapr> expliquez? Je ne comprends pas?
03:08:55 <vincenz> nm
03:09:06 <vincenz> it says "We should point out the absence of commas"
03:09:13 <vincenz> how can you have list without comma-separating items
03:09:33 <shapr> Oleg is da mastah
03:09:43 <sethk> vincenz, [ "abc" "def" "ghi"
03:09:49 <shapr> He kicks butt without requiring motion.
03:10:08 <vincenz> > [1 2 3]
03:10:08 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
03:10:08 <lambdabot>   In the list element: 1 2 3
03:10:08 <lambdabot>   In the definition of `vaj': vaj = [1 2 3]
03:10:16 <vincenz> > ["abc" "def" "ghi"]
03:10:16 <lambdabot> Couldn't match `[Char]' against `t -> t1 -> t2'
03:10:18 <shapr> If given the choice between working under Oleg or working under John Hughes, I would be very hard pressed to decide.
03:10:33 <sieni> vincenz: the list are supposed to be one-element lists. The things without quotes are functions.
03:10:38 <vincenz> shapr: and the two simon's?
03:10:53 <shapr> hmm
03:11:11 <vincenz> sieni: so explain to me how you will have for instance two h1's after each other in a body
03:11:15 <vincenz> you'll need a list with two elements
03:11:32 <shapr> I think they'd be second in my list, but only because I've already read so much of their writings that I think I have a feel for how they do things.
03:12:31 <sieni> vincenz: try the source in ghci. It works fine.
03:13:01 <sieni> evaluating test_haskell outputs quite a funny-looking thingie
03:13:09 <vincenz> where does oleg work?
03:13:25 <sieni> in the military I guess :-)
03:13:32 <vincenz> I mean...
03:13:39 <vincenz> none of his papers of .lhs files mentions his last name
03:13:42 <vincenz> how can he publish these things
03:13:55 <vincenz> they're all ng-posts or emails
03:14:06 <shapr> He doesn't need to use his last name. Everybody knows Oleg :-)
03:14:16 <vincenz> yeah but if I want to google him
03:14:18 <vincenz>  to see what uni
03:14:20 <sieni> Fleet Numerical Meteorology and Oceanography Center
03:14:23 <shapr> sieni: yup
03:14:33 <shapr> West Coast, USA
03:14:35 <sieni> He works for the US Navy :-)
03:14:41 <vincenz> last name?
03:14:44 <jips> who is oleg?
03:14:45 <shapr> Kiselyov
03:14:57 <shapr> jips: He is the might Oleg
03:15:00 <shapr> ahem
03:15:02 <shapr> jips: He is the mighty Oleg
03:15:18 <shapr> He does so much cool stuff we've named a unit of typeclass hackery after him.
03:15:24 <shapr> Like "that'll require at least half an oleg."
03:15:25 <vincenz> oh?
03:15:43 <vincenz> is there a fromShapr :: Shapr -> Oleg?
03:15:58 <shapr> Unlike the volt, etc, an Oleg is a very large amount of type hackery.
03:16:07 <sieni> he has lots of nice stuff on his website: http://okmij.org/ftp/
03:16:20 <vincenz> sieni: yeah but they're all 'article' not submitted stuff
03:16:22 <shapr> vincenz: I think a 'shapr' is only a unit of randomness.
03:16:25 <vincenz> why doesn't he submit any of the thigns
03:16:29 <vincenz> shapr: good point :)
03:16:37 <shapr> He does publish articles, they're usually niftier than his ng posts.
03:16:38 <vincenz> 'article' in the sense of ng-article or email
03:16:51 <shapr> His recent paper on deriving the split radix was seriously badass.
03:17:07 <shapr> And I think it's a hint about the future of compiler optimization.
03:18:07 <shapr> He published an article in the last issue of TMR.
03:18:23 <vincenz> ?
03:19:29 <sieni> and lots of the stuff are feats of ultimate hackery and as such they seem to be of little interest to any journal
03:19:52 <sieni> like he has lots of nice tutorials on scheme macros: http://okmij.org/ftp/Scheme/macros.html
03:20:33 <shapr> It's funny, his stuff is often just flat out useful.
03:44:18 <sethk> what's wrong with this line?   newtype SSMap = Map String String
03:46:00 <Saulzar> newtype needs a constructor
03:46:46 <sethk> so I need to use data there?
03:47:05 <Saulzar> eg. newtype SSMap = SSMap (Map String String)
03:52:08 <ski> rather, a 'newtype' constructor must take exactly one argument
03:52:29 <ski> (or, um .. Saulzar is right :)
04:00:01 <shapr> @quote OlinShivers
04:00:01 <lambdabot>  You are crazy, but that's not important. The only thing that matters is whether or not you do anything. Do *anything*, and you matter.
04:05:26 <shapr> How do I match several spaces with sed?
04:05:55 <shapr> \sed "s/ /-/g" "foo bar  baz"
04:05:56 <lambdabot> Maybe you meant: id seen
04:06:23 <jips> anyone familiar with Haskell XML Toolbox arrow interface?
04:13:08 <jips> does upx work well with haskell compiled executables?
04:13:18 <shapr> What's upx?
04:13:32 <shapr> oh
04:13:43 <shapr> neato
04:17:58 <Frobar> shapr: "s/ /-/g" should replace every single space with a -. the regex will match once for every space.
04:18:34 <musasabi> jips: the arrow interface seemed quite nice when I used it.
04:19:03 <jips> musasabi: i can't seem to figure out how to use it. i'm sort of new to haskell
04:19:10 <Frobar> if you want to replace adjacent spaces with a single -, you could use "s/ +/-/g"
04:19:32 <shapr> Frobar: I'll try that, thanks.
04:19:40 <Frobar> np
04:19:46 <shapr> Frobar: It doesn't seem to work :-/
04:19:59 <Frobar> shapr: what do you get?
04:20:10 <shapr> The output is the same as the input.
04:20:48 <musasabi> jips: Have you looked at the examples?
04:20:49 <Frobar> echo "urgt  urgt urgt" | sed "s/ /-/g"  works fine here
04:21:00 <jips> musasabi: all the examples only use the (>>>) combinator. couldn't a monad have been used?
04:21:15 <Frobar> the result is urgt--urgt-urgt
04:21:26 <shapr> I'm using: free -mto|head -2|tail -1|sed "s/ +/-/g"
04:21:36 <shapr> Right, but I want all the spaces to disappear.
04:21:45 <shapr> Is there an easier to way to get the system ram in megabytes?
04:21:48 <Frobar> ah, you need to escape the +
04:21:51 <Frobar> \+
04:21:52 <lambdabot> Not enough arguments to @.
04:21:56 <shapr> aha!
04:21:59 <musasabi> jips: with (>>>) one can do things, not possible in a monad.
04:22:07 <Frobar> i hate how that differs between different regex implementations..
04:22:21 <Frobar> some take + literally without \, and some with
04:22:39 <musasabi> jips: but you don't have to care about arrow internals to use it.
04:24:10 <shapr> Hm, should +RTS -Mxxx be in megabytes?
04:24:16 <jips> musasabi: right... anyway, i can't figure out how to do simple stuff, like make a [String] containing all of the element names that are used in the xml document
04:25:12 * musasabi would just use a writer arrow transformer ;)
04:25:34 <jips> i don't know how to do that
04:25:47 <jips> musasabi: why does runX return a list?
04:26:13 <musasabi> look for the transformer versions of that.
04:26:18 <musasabi> but I have this girl here insisting that I consentrate more on her and less on irc while in bed. ->
04:26:48 <shapr> haha
04:26:53 * shapr knows that feeling
04:26:56 <jips> doesn't appear like the relationship is gonna last :\
04:27:06 <jips> if she can't handle this i mean
04:27:08 <shapr> jips: I know, musasabi will soon leave IRC :-(
04:27:17 <shapr> Oh that's what you meant.
04:27:18 * shapr grins
04:27:57 <tre_> today my copy of "The Haskell Road to Logic, Maths, and Programming" should arrive
04:28:33 <shapr> Can I pass +RTS options to GHCi?
04:29:08 <shapr> doh
04:29:13 * shapr discovers the problem.
04:30:52 <shapr> tre_: yay!
04:31:07 <shapr> Hm, how to calculate 80% of a number with zsh?
04:31:54 <shapr> duh
04:32:04 <shapr> ghc -e "print $ .8
04:33:44 <Frobar> shapr: print $(( $x * 0.8 ))  will work as well
04:33:52 <musasabi> back
04:33:58 <shapr> Yeah, but it's much more fun to use ghc :-)
04:34:02 <Frobar> :)
04:34:26 * shapr tries to come up with a pure ghc solution...
04:34:54 <shapr> Can I use ghc -e "$CODE" and read from stdin?
04:35:19 * shapr looks at musasabi, oh sensei
04:35:32 <Frobar> prolly.. if $CODE includes some IO
04:35:58 <shapr> Yeah, I just dunno if there's a short hand way to get stdin.
04:36:07 <shapr> Isn't there a .ghc or something?
04:36:18 <shapr> There's definitely .ghci, I wonder if it's executed when ghc -e is called?
04:36:19 <musasabi> shapr: +RTS foobar works fine with ghci.
04:36:20 <Frobar> echo "urgt urgt" | ghc -e "$CODE"
04:36:49 <shapr> musasabi: Yeah, but it requires +RTS -M with nnk nnm or something. I was leaving out the k, m, etc.
04:37:47 <shapr> hmmm
04:37:50 <musasabi> shapr: if you are running into something eating too much memory maybe compile those modules optimized and use the optimized versions from ghci?
04:38:38 <shapr> musasabi: At this moment, I'd much rather find some way to easily refer to stdin from a ghc -e command. You know if it's possible?
04:39:33 <shapr> Or read from stdin...
04:39:44 <Frobar> what do you mean by refer to stdin? any IO operations in the code will probably use stdin/stdout unless you say otherwise.
04:40:01 <shapr> Nah, they don't.
04:40:10 <shapr> Or if they do, how does it work?
04:40:27 * shapr remembers that unilateral declarations are often wrong.
04:40:44 <Frobar> stdin/stdout has been the standard handles in every language i've used
04:40:54 <Frobar> thus _std_ =)
04:41:20 <musasabi> shapr: it works to an extent. e.g. ghc -e 'getLine >>= print . words'
04:41:26 <shapr> hm, right
04:41:37 <shapr> I wish I could influence default imports via .ghci or so.
04:41:54 <shapr> Maybe I should submit a patch where -e reads and executes .ghci
04:42:08 <musasabi> why not write a simple alias?
04:42:13 <shapr> like what?
04:42:36 * shapr likes the sound of 'simple'.
04:42:45 <musasabi> ge() { ghc -iSomeWhere -e "import SomeThing; $*"; }
04:42:56 <shapr> hm
04:42:58 <shapr> Would work...
04:43:33 <shapr> oh, there's more: ghc -e Main.main Main.hs
04:44:00 <musasabi> runghc Main.hs ?
04:44:39 <shapr> http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html#eval-mode
04:45:01 <shapr> That's pretty cool.
04:45:52 <shapr> Doesn't say if you can execute an arbitrary string in the context of imports though...
04:45:55 * shapr tries
04:46:03 <shapr> hiya Krunch, new to Haskell, or just #haskell?
04:46:26 <shapr> Hm, I've seen you around here before maybe?
04:47:33 <Krunch> i'm just getting started on haskell
04:47:57 <shapr> Learning for business or pleasure?
04:48:16 <Krunch> pleasure
04:48:28 <shapr> Spiffy
04:48:31 <Krunch> but i can't figure out why this doesn't work http://pastebin.com/615976
04:49:06 <Krunch> here is the error from hugs http://pastebin.com/615977
04:50:45 <shapr>  % ghc ProtoPArrow.hs -e "show $ many1 (char '-')"
04:50:45 <shapr> "- >> (-)*\"\""
04:50:46 <shapr> w00!
04:51:22 <shapr> musasabi: I feel a powerful alias coming up...
04:52:46 <shapr> Krunch: It's saying that you need to declare the type to require equality.
04:53:41 <jips> Krunch: yeah, a cool trick is to erase your manual srep type signature, and let hugs tell you what it should be
04:53:44 <shapr> Krunch: http://pastebin.com/615982
04:54:29 <shapr> hoi boegel
04:54:46 <Krunch> i haven't seen that "=>" notation in the tutorial i'm reading yet
04:54:47 <Krunch> thanks
04:54:53 <sieni> musasabi: what's this "black box" problem with arrows and lifting functions to arrows? could you elaborate on that?
04:55:08 <sieni> musasabi: (I was reading http://www.haskell.org/tmrwiki/ArrowsIntroduction)
04:55:51 <kosmikus> Krunch: also, bool2int is better written using pattern matching or if-then-else, and is anyway equivalent to the predefined fromEnum
04:56:46 <Krunch> thanks, i looked up Bool -> Int on hoogle but didn't found anything in Prelude
04:57:47 <kosmikus> strange that it doesn't
04:58:05 <Krunch> fromEnum :: Enum a => a -> Int
04:58:28 <shapr> sieni: You can't shortcut something that might require execution.
04:58:39 <jips> > fromEnum True
04:58:39 <lambdabot> 1
04:58:40 <Krunch> ha no, i looked up Bool -> Integer
04:58:46 <jips> > fromEnum False
04:58:47 <lambdabot> 0
04:59:05 <sieni> shapr: (With a Mexican President voice) ¿Que? 
05:00:00 <shapr> Someone, I forget who, wrote a wxHaskell gui based on arrows. It was very efficient because it didn't need to redraw the screen unless something changed. But that was only true as long as you didn't lift any non-arrow functions with arr.
05:00:33 <sieni> so are the arrows a crappy abstraction or what?
05:00:53 <shapr> They're great for what they do.
05:01:01 <kosmikus> Krunch: I'd probably define srep as "srep xs x = (length . filter (==x)) xs"
05:01:31 <shapr> sieni: They just don't interoperate well with normal functions.
05:01:34 * shapr looks for examples.
05:01:38 * Krunch didn't knew about filter
05:01:52 <shapr> sieni: http://www.cs.helsinki.fi/u/ekarttun/haskell/blackhole.txt
05:04:42 <sieni> shapr: that's nice
05:04:50 <shapr> musasabi: Can you make misc/a.hs readable?
05:05:52 <sieni> That might be nice short explanation on the arrowsintroduction page
05:05:58 <shapr> Yeah, I'll stick it in there.
05:08:40 <shapr> musasabi: Er, that would be http://www.cs.helsinki.fi/u/ekarttun/haskell/a.hs
05:10:33 <musasabi> shapr: It is readable now. (what should be there?)
05:11:30 <shapr> musasabi: Ah, I thought that would be the code for a.png
05:12:18 <shapr> Is there code that explicitly matches a.png and b.png?
05:14:01 * shapr suspects it's already in SPDraw.hs...
05:16:14 <musasabi> shapr: I think those are for illustration, but they match code in SP-things quite closely.
05:16:40 <shapr> ok
05:16:42 <shapr> thanks :-)
05:18:59 <musasabi> feel free to use any of the SP-stuff.
05:19:26 <shapr> thanks
05:23:19 <tuomov> hmm.. is there a simple way to mark a file as binary in darcs?
05:23:32 <tuomov> I don't want to add a pattern in _darcs/binaries, but just say add --binary or something?
05:23:49 <tuomov> the manual doesn't seem to indicate such a possibility
05:25:51 <shapr> Is Ola Karlsson on #haskell?
05:26:47 <shapr> Guess not.
05:33:10 <boegel> shapr: yo !
05:33:13 <shapr> y0 y0
05:33:19 <jips> boing
05:33:26 <boegel> shapr: was it you who was interested in FunMath ? or someone else ?
05:33:29 <shapr> it was me.
05:33:44 <boegel> shapr: have you seen the website I mentioned here a few days ago ?
05:33:55 <shapr> Don't think so.
05:34:02 <boegel> shapr: http://www.funmath.be
05:34:13 <boegel> the prof I did my thesis with set it up...
05:38:06 <shapr> boegel: That's cool
05:44:03 <vincenz> boegel: ah boute
05:44:09 <vincenz> boegel: I read an interesting paper from him :)
05:48:17 <boegel> vincenz: which one ? :) I did my thesis (on HRay) with him
05:48:38 <boegel> he very much a nutty professor in the actual meaning of the word :)
05:48:45 <boegel> s/he/he's/
05:52:34 <vincenz> boegel: it was a journal
05:52:34 <vincenz> iirc
05:52:40 <vincenz> about the entire functional math sutff
05:52:59 <boegel> vincenz: did you like it ?
05:57:37 <vincenz> boegel: it was hard to read
05:57:40 <vincenz> is it useful?
05:57:44 <vincenz> or is it just another notation for many things
06:08:46 <boegel> vincenz: it was for me
06:08:53 <boegel> vincenz: it's way more than that
06:09:02 <boegel> it allows you to reason about the stuff you're doing
06:09:24 <boegel> it's pretty hard doh, I think the only person who's able to fully grok it, is Boute himself :)
06:09:49 <boegel> vincenz: if you can read Dutch, you can check out my thesis, I've put it online (http://www.elis.ugent.be/Haskell/Hray -> downloads)
06:23:17 <ihope> @hostname
06:23:17 <lambdabot> Unknown command, try @listcommands.
06:23:56 <mwc> Strangest thing happening here
06:24:03 <mwc> 13918 matt      25   0  4476 3116  968 R 96.1  0.4  33:15.70 assn5
06:24:11 <mwc> HUGE CPU utilization, almost no RAM
06:24:44 <ihope> What's it calculating?
06:24:45 <mwc> On the otherhand; if I remove some $! and seqs, the memory use climbs exponentially in no time
06:25:43 <mwc> ihope, it's doing montecarlo integration by importance sampling using a markov process, the calculation itself is the hamiltonian of a small lattice of atoms ((1,1),(5,5))
06:26:01 <mwc> anyways, I'm wondering if anybody has ever seen seq or $! mask an infinite loop somewhere?\
06:26:05 <ihope> Um, sounds complicated.
06:26:20 <ProfTeggy> mwc, sounds like "science."
06:26:36 <mwc> ProfTeggy, yeah, computational physics course assignment
06:26:45 <mwc> The weird hting is, my profiles seem pretty normal
06:26:59 <ihope> Well, "seq infiniteloop foo" infinite-loops, as does "bar $! infiniteloop"...
06:27:13 <mwc> I'm wondering how much I can trust profile data if I interrupt the code?
06:28:03 <mwc> ihope, I think I'm going to start peeling off seqs and $! and seeing what triggers the memory exlposion
06:29:09 <ihope> Have you tried Debug.Trace.trace or whatever it is?
06:30:18 <mwc> No, I let it run overnight and just started fiddling with it
06:30:45 <mwc> it ran for over 7 hours, I must have an infinite loop somewhere
06:32:50 <mwc> Something to finish messing with after class today I suppose
06:33:01 <mwc> thanks for the ideas, I'm going to think on it
06:39:10 <Krunch> is there an haskell debugger that could be attached to a running process ? (like gdb)
06:39:25 <Lemmih> Krunch: No, not really.
06:45:50 <boegel> Krunch: you're free to write one :)
06:46:32 <ihope> Hmm...
06:47:53 <Krunch> i'll think about that when i'll have more than 5 hours of experience in haskell :)
06:48:32 <ihope> :-)
06:49:33 <ihope> Oh, right. Note to self: NEVER open primes.txt in Notepad.
06:50:05 <wolverian> ihope, /dev/primes? :)
06:50:17 <danfg> so what do you guys think of ruby?
06:50:44 <ihope> Nope. I have a program that outputs primes, and I piped it into that file.
06:50:46 <Krunch> wolverian: that would do an intersting kernel patch
06:51:00 <wolverian> Krunch, yes.. maybe I should learn kernel development
06:51:12 <boegel> ihope: how big is it ?
06:51:43 <wolverian> danfg, cute, practical (but slow), I don't like the balance of dynamicness and staticness, has too many fanboys (rails)
06:51:52 <ihope> 39.7 MB
06:52:16 <bolrod> :)
06:52:25 <wolverian> and I don't get the ruby community's obsession on comparing ruby to java
06:52:33 <wolverian> it makes no sense 
06:52:37 <bolrod> before win XP notepad didn't open files bigger then 100KB right?
06:52:55 <ihope> I don't know.
06:53:09 <wolverian> bolrod, might have been 2k. not sure. something like that anyway
06:53:22 <wolverian> (also was it 64kb?)
06:53:24 <danfg> well, ruby and rails get mixed up way too often
06:53:32 <bolrod> yeah.. it showed an error that you had to open it with wordpad
06:53:36 <bolrod> how stupid is that..
06:53:37 <bolrod> :)
06:53:47 <wolverian> danfg, yeah.. I'm not sure which is at fault there. I just follow planet ruby 
06:53:48 <ihope> Well, WordPad opens the file, and Notepad doesn't.
06:53:52 <wolverian> danfg, (and most posts are about rails :/)
06:54:01 <bolrod> notepad is stupid anyway..
06:54:08 <bolrod> it doesn't even know the newline char
06:54:08 <danfg> :)
06:54:16 <ihope> WordPad doesn't have "go to line".
06:54:18 <bolrod> it just shows a block.. and then puts everything on one line
06:54:30 <bolrod> wordpad does however have the newline
06:54:34 <wolverian> ihope, dude, you're in windows, what did you expect? :)
06:54:48 <ihope> :-)
06:55:02 <wolverian> (well, I assume you are.. wine *cough*)
06:55:08 <ihope> Sadly, wireless driver issues prevent me from switching to Linux.
06:55:10 <bolrod> notepad in wine?
06:55:13 <bolrod> is that even possible?
06:55:23 <wolverian> bolrod, yes, iirc
06:55:40 <bolrod> hmm.. maybe yes..   
06:55:52 <wolverian> ihope, ah. that is why I got a thinkpad. :)
06:55:59 <bolrod> or microsoft built it in the kernel for a laugh
06:56:16 <Frobar> bolrod: notepad doesn't understand unix-style newline. wordpad does.
06:56:25 <bolrod> yeah
06:56:37 <bolrod> didn't I say that?
06:56:46 * wolverian wonders what 'Brown paper bag' means in this changelog
06:57:32 <danfg> wolverian: would you consider haskell a good language for beginners? i mean, i was going to teach my brother some ruby, but i ran into haskell and have been excited about it. he used to be very good with spreadsheets, so i thought maybe he would find Haskell attractive (feel free to point out if i just said something crazy)
06:57:32 <Frobar> bolrod: "it doesn't even know the newline char" made it sound like there's a specific newline char that all systems use :)
06:57:53 <bolrod> wellll  
06:58:01 <bolrod> it is a newline char...
06:58:04 <dbremner> wolverian- what's the context?
06:58:09 <wolverian> danfg, it _might_ depend on how mathematical he is. I don't have actual experience in teaching languages. however, I've always wished my first language had been functional.
06:58:17 <ihope> Notepad takes MJ, not J?
06:58:20 <wolverian> dbremner, no context besides that. the program is Beagle.
06:59:02 <wolverian> danfg, scheme might be better as a first language. simpler, in some ways. 
06:59:12 <Frobar> danfg: i'd recommend python over haskell for a beginner. in my experience, beginners find the imperative style a lot more intuitive.
06:59:16 <wolverian> but really, someone else who does have experience on teaching functional languages should say something here
06:59:35 <wolverian> Frobar, no, not python! it's a prison of the mind.
06:59:41 * wolverian is biased
06:59:54 <danfg> Frobar: he does have experience with imperative, from his days with apple basic lol :)
06:59:57 <ihope> Frobar: what about someone who's never used an imperative language before?
07:00:08 <Krunch> IMO scheme is easier to learn as a first language (if you want a functional one)
07:00:20 <dbremner> Krunch- I'd second that.
07:00:21 <Frobar> ihope: i'm talking about people who have never programmed before
07:00:43 <ihope> Well, they've never used imperative langauges...
07:00:43 <danfg> wolverian: that's interesting, i don't think he's ever been very good with math, he's kinda' smart though, i like to think. and lazy too. i'll have a look at this scheme thing
07:00:49 <wolverian> Frobar, does the person's education matter? I'd imagine a maths student would find haskell pretty easy to pick up
07:01:30 <wolverian> danfg, you can't go wrong with scheme :) (it's like the smallest possible subset of a language to be called one, well, besides forth..)
07:01:59 <Krunch> bf is smaller
07:02:02 <sjanssen> wolverian: forgetting brainfuck?
07:02:09 <sjanssen> or unlambda
07:02:11 <Frobar> yes, probably, but then again you can't go wrong with an imperative first language
07:02:14 <wolverian> I guess it depends _what_ you're trying to teach...
07:02:16 <shapr> Chalmers teaches Haskell as the first programming langage.
07:02:19 <wolverian> Frobar, yes, you can.
07:02:22 <shapr> Frobar: Um, I dunno about that...
07:02:35 <wolverian> Frobar, I _really_ wish I had learned a functional language first. it would have made things so much easier for me later.
07:02:40 <ihope> So how come programming classes teach BASIC and computer science classes teach C?
07:02:44 <danfg> lol, i also want him to learn something he can start using for practical applications right out of the box. how does scheme rate on that aspect? :)
07:02:46 <Frobar> shapr: linköping's university uses lisp
07:02:48 <shapr> Yeah, I wish I'd learned Haskell too.
07:02:59 <moonlite> i want to know all about records in haskell. where would i go?
07:03:07 <shapr> Frobar: Yeah, and my last university used COBOL... none of those mean we should choose them ;-)
07:03:12 <wolverian> danfg, the modern distributions are very practical, even if they're not quite lisp.
07:03:23 <Frobar> pretty much all the student's who hadn't had much experience with programming earlier said they found the ada (the other language taught in that course) approach more intuitive.
07:03:28 <Frobar> -'
07:03:39 <wolverian> ihope, I don't know of any programming class anywhere that uses basic 
07:04:02 * ihope looks up the whatever
07:04:02 <wolverian> well, ada _is_ a good language, too, even if imperative.
07:04:24 <shapr> I've been teaching Haskell to my girlfriend, she's fine with it.
07:04:43 <shapr> The types catch her, but referential transparency didn't make a ripple.
07:04:47 <wolverian> I had a hard time picking up haskell without a college background 
07:04:58 <wolverian> now that I am in university I find it much easier as I study maths and cs
07:05:08 <shapr> I don't have a college background either, I had similar troubles.
07:05:22 <shapr> My biggest problem is one single thing...
07:05:30 <shapr> There's no jargon dictionary for symbols!!
07:05:55 <Frobar> wolverian: i still think imperative -> functional is the most productive route to take for most people. picking up functional programming after imperative just seems a lot easier to most people than the other way around.
07:06:07 <dbremner> wolverian - there was a well written paper from an austrailian university about their success in teaching Haskell. Someone else probably knows what it is - or wrote it.
07:06:12 <wolverian> Frobar, it was very hard for me.
07:06:21 <wolverian> dbremner, ah, interesting. I'd like to see that
07:06:28 <danfg> me too
07:06:34 <wolverian> shapr, hm? symbols?
07:06:47 <dbremner> wolverian - currently googling for it, I'd like to read it again.
07:06:52 <wolverian> dbremner, thanks :)
07:07:01 <ihope> COMPUTER PROGRAMMING I - 2 units (grades 10-12)
07:07:04 <shapr> Frobar: I disagree, but I'm aware I don't know everything.
07:07:08 <ihope> Prerequisite: Successful completion of Algebra I
07:07:16 <Frobar> wolverian: oh well, people differ i guess. personally i've never had much problem with unlearning habits when moving between paradigms.
07:07:19 <ihope> BASIC computer language will be introduced...
07:07:25 <wolverian> ihope, oh, high shcool level? I see. we used pascal.
07:07:34 <shapr> Frobar: In my opinion, purely functional programming works much like Math, and thus is easier to connect to what's already known.
07:07:46 <wolverian> Frobar, well, I programmed about five years solely in basic...
07:07:52 <wolverian> Frobar, it was _hard_ to unlearn that :)
07:07:54 <ihope> wolverian: is there a high school anywhere that teaches Haskell?
07:07:55 <shapr> dbremner: That's probably a paper by Manuel Chakravarty.
07:08:03 <wolverian> ihope, I very much doubt that.
07:08:04 <shapr> From UNSW
07:08:17 <shapr> But there are high school students than teach themselves Haskell.
07:08:21 <Frobar> i programmed for 5 years in mostly c++/python
07:08:25 <shapr> There are always a few on #haskell
07:08:41 <wolverian> Frobar, I can understand it'd be easier to learn the functional paradigm after those than basic.
07:08:43 <shapr> Phubuh was fourteen when he started, and he passed my level of understanding by the time he was fifteen.
07:08:58 <wolverian> I still do think it's easier to pick up imperative after learning functional (I have friends who have done that)
07:09:20 <shapr> Yeah, everything is in the IO monad ;-)
07:09:21 <danfg> i was so surprised to hear about Haskell in 2006 because this language exists since 1987 and i'd never ever heard about it.
07:09:32 <wolverian> shapr, right. :) 
07:09:37 <shapr> danfg: Lots of FUD is spread about Haskell, sadly.
07:09:42 <integral> exists since 1987?   they didn't have monads back then I thought ...
07:09:48 <dbremner> shapr - http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
07:09:55 <danfg> shapr: like what?
07:09:59 <shapr> Like "academic masturbation" and "useless because you can't change values"
07:09:59 <dbremner> integral - the IO model has changed.
07:10:16 <shapr> or "only for ivory tower purists with no connection to commercial programming"
07:10:18 <dbremner> wolverian - the last link is what I meant.
07:10:38 <wolverian> dbremner, yes. thanks!
07:10:41 <shapr> Or "can only be understood by PhD students or CS Professors"
07:10:44 <Saulzar> shapr, Yep, I'd heard of it before 2006 but was under that understanding.
07:10:51 * wolverian notices his system opened the .ps from inside the .gz automatically.. nice 
07:11:26 <dbremner> wolverian- mine didn't because Stuffit Expander is the devil.
07:11:28 <shapr> I always laugh, since I have 1. no university background for math or science (only art) 2. my own company 3. not much understanding of category theory
07:11:54 <shapr> I do have the ability to know a powerful tool when I see it, and man Haskell is it!
07:11:57 <wolverian> dbremner, :) switch to gnome ;)
07:12:37 <dbremner> wolverian - I'm happy enough with OS X for now.
07:13:19 <wolverian> sigh, that .ps is vectors, not fonts. devil ate my copypaste
07:13:21 <Saulzar> shapr, Same here, basically none of the background (well I have done CS but not any relavant theory).
07:13:25 <danfg> shapr: that's interesting, my brother 1. has university background in philosophy, 2. his own company, 3. not sure he even knows what category theory is :)
07:13:30 <Frobar> shapr: but the "mathematical" way (at least non-discreet math) often does not correspond very well with how people think about problems. i think most people (me included) use a step-based approach that lies closer to the imperative model.
07:13:53 <shapr> Frobar: I disagree... look at cake recipes.
07:14:03 <sjanssen> Frobar: would you think in steps if you learned Haskell first?
07:14:15 <shapr> They can be viewed either way without much effort.
07:14:24 <integral> cake arrows
07:14:27 <Saulzar> I don't know, I don't think the step-based approach is needed after a while.
07:14:29 * shapr laughs
07:14:35 <Frobar> sjanssen: i would have to unlearn step-based thinking at least, which is more of an effort than if i start with an imperative language
07:14:40 <shapr> danfg: But your brother likes Haskell?
07:14:40 <dbremner> wolverian - I think section 2.2 is a particularly compelling argument - I remember what the pass rates of my first CS class were.
07:14:54 <danfg> shapr: i want to teach him Haskell
07:14:57 <Frobar> shapr: baking a cake is very much a step-by-step process
07:14:59 <Maddas> I sure hope Haskell isn't as hard as baking cake, I might as well give up already otherwise :-)
07:15:01 <shapr> Frobar: For another viewpoint, is OOP step-based?
07:15:06 <integral> hmm, iirc SICP in part unlearns step-based thinking, and that's imperative :-)
07:15:38 <Frobar> shapr: i've only experienced oop in imperative languages, and there it's definitely so
07:15:44 <Saulzar> My approach to cake recipes is that if it takes more than 3 steps then approximate the rest with "mix in the stuff and cook it"
07:15:54 <wolverian> dbremner, hm, interesting. and, yes, the maths department has all the cute girls :)
07:16:17 <Maddas> Huh...
07:16:32 <Maddas> wolverian: Surely that is a peculiarity of that particular university, right? :-)
07:16:36 <shapr> danfg: I think it'll work out well.
07:16:42 <wolverian> Maddas, compared to CS, that is.. 
07:16:52 <Saulzar> Definately
07:16:55 <Maddas> wolverian: Ok.
07:16:59 <danfg> shapr: i'm sold :)
07:17:23 <shapr> hei mikaeli 
07:17:32 <wolverian> it is rather sad. I'd very much like to see more girls getting interested in researching CS.
07:17:35 <mikaeli> hi everyone
07:17:59 <Maddas> mikaeli: Hi there
07:18:18 <wolverian> right now I observe many rather poorly motivated freshmen.. 
07:18:38 <wolverian> (not because there aren't girls around, but if girls applied more to CS, there'd be more motivated students in total)
07:18:44 <Maddas> heh.
07:18:50 <wolverian> (well, maybe the first point is also true. I haven't researched that.)
07:18:57 <shapr> Frobar: Cake recipes could be considered referentially transparent somewhat.
07:19:44 <shapr> Frobar: I was thinking about hanging clothes on a clothesline, I don't follow a loop. I use induction.
07:19:46 <dbremner> wolverian - I think there are a lot of people who could make excellent programmers if they'd started with an easier language.  In the 80s, students started with Pascal. C or C++ is arguably a couple steps backward.
07:19:55 <wolverian> I was pleasantly surprised when the databases course started off with teaching relational calculus, and sql was the topic on only about a fourth of the lectures.
07:20:03 <shapr> It's more about 1. If no clothes in the basket, do something else 2. otherwise, hang up one of the clothes in the basket.
07:20:10 <integral> If people think Haskell is a toy, what must they think of Pascal? ;-)
07:20:12 <shapr> wolverian: Impressive
07:20:17 <Maddas> Indeed
07:20:20 <wolverian> dbremner, one could argue that it depends on whether you want to do software engineering or computer science.
07:20:54 <shapr> Frobar: I wonder if the imperative or functional mindset is a personal thing?
07:21:03 <wolverian> shapr, they also made rather clear how sql breaks relational calculus, and the sql practice points count only 10% towards the total score. it is a great course. :)
07:21:05 * Maddas thinks it is
07:21:07 <tennin> personally, I decided to learn Haskell after trying in vain to write a Python program that manipulated other Python code
07:21:10 <shapr> The more I think about how I do things, the more I realize I use induction totally.
07:21:19 <dbremner> wolverian - Either path requires programming, I think there's reason not to start with a greased razor blade.
07:21:23 <tennin> & realized that it would be a whole lot easier if I didn't have to worry about unrestricted side effects
07:21:25 <shapr> wolverian: Sounds awesome! Did you tell them about HaskellDB?
07:21:30 <Saulzar> I think that it just amounts to what you're used to
07:21:34 <shapr> tennin: Heh, I know that feeling.
07:21:47 <shapr> I've gotten really frustrated at J2EE because I couldn't trust values to stay the same.
07:21:51 <shapr> They kept changing behind my back!
07:22:05 <mikaeli> shapr: You could argue that Hitler was imperative, but Einstein definately functional:)
07:22:12 <wolverian> dbremner, oh, absolutely. java is nice for beginners, but it scares me that people might think that's all there _is_ .. the edge must not be too dull.
07:22:26 <wolverian> s,people,students,
07:22:29 <shapr> Partial application gives me safer 'semi-objects' because I can apply it to values, and those values won't change.
07:22:30 <tennin> before that, the idea of pure functional languages had struck me as pointless
07:22:35 <shapr> mikaeli: Ouch, that's strong
07:23:00 <shapr> I used Java before I tried Python. First time I tried Python I thought "Can OOP really be this EASY?"
07:23:00 <Frobar> shapr: i am more likely to think of it as "pick up cloth, put on clothesline, repeat until no more clothes" than "if basket not empty put picked-up cloth on clothesline and hang remaining clothes"
07:23:14 <dbremner> tennin - for me it was the ICFP and the 20-year rule.
07:23:28 <Maddas> Frobar: Hm, funny, that (first one) sounds pretty functional to me..
07:23:34 <shapr> Frobar: Yeah, but a loop is more complicated than an inductive control structure.
07:23:44 <Frobar> Maddas: i think of it as a loop
07:24:19 <Frobar> shapr: perhaps, but it might be easier to many people because it lies closer to how they think about everyday problems
07:24:20 <wolverian> shapr, you know, I don't really mind the differences between OO and FP. it's all about the quality of the code, the methods of organisation the language offers and the overall design of the model. I also think that static typing doesn't fit imperative code quite as well as it does FP. I'm not sure why. in any case, java bothers me a lot. the API is a mess, and the language very restrictive. on the other hand, I like agile languages.
07:24:22 <shapr> tennin: Pure FP also gives you common subexpression elimination.
07:24:28 <wolverian> shapr, no, I didn't tell them about haskelldb.. I'll take a look at that.
07:24:30 <Maddas> Maybe I'm missing something, but how is a loop necessarily imperative?
07:24:33 <wolverian> thanks!
07:24:36 <shapr> Frobar: Well, I don't agree, though as I said, I could be wrong.
07:24:54 <Maddas> Frobar: also, I thought you were mapping the clothes to the cloth line :-)
07:24:56 * wolverian has had too much coffee perhaps 
07:25:01 * shapr hasn't had enough!
07:25:03 <shapr> @y0w!
07:25:03 <lambdabot> What UNIVERSE is this, please??
07:25:15 <shapr> @quote
07:25:15 <lambdabot> Heffalump says: CPP leads to suffering
07:25:25 <Frobar> Maddas: =)
07:25:31 <sjanssen> suffering leads to hate . . .
07:25:34 <shapr> Frobar: Anyway, talk is no fun, got any code samples you'd like to point out as being representative?
07:25:37 <wolverian> or in other words, I didn't understand the good sides of static typing until I learned haskell.
07:25:38 <Maddas> "C++ adds to C but returns the same value" :-)
07:25:39 <sjanssen> hate leads to the DARK SIDE
07:25:44 <dbremner> shapr - I've often wondered why ghc doesn't use m4, ML/I, or some such.
07:25:47 <Frobar> shapr: representative of what?
07:25:53 <shapr> sjanssen: ergo, CPP -> DarkSide
07:26:03 <shapr> Frobar: Well, something you think is more naturally done imperatively.
07:26:21 <shapr> For example, I'd show length [] = 0; length (x:xs) = 1 + length xs
07:27:19 <danfg> i think someone mentioned a balance of dynamicness and staticness in ruby. what is static about ruby?
07:27:26 <shapr> Higher order functions are easier to use in a purely functional language.
07:27:39 <Frobar> shapr: i'm not saying some things are done more naturally in an imperative way (though that's probably the case), i'm saying that in my experience many if not most people find imperative solutions more intuitive
07:27:49 <wolverian> danfg, no implicit coercion.
07:28:00 <wolverian> (compare to perl)
07:28:01 <shapr> Frobar: Ok, got any anecdotes?
07:28:02 <Frobar> at least to problems that don't lend themselves much to either paradigm
07:28:03 <Maddas> Frobar: You just said that probably is the case -- saying you didn't doesn't let you escape arguing it :-)
07:28:11 <neologism> Frobar: most people find their mother language sometwhat more intuitive ;)
07:28:16 <danfg> wolverian: you lost me on the coercion
07:28:36 <wolverian> danfg, "2" + 3 is an error in ruby. in perl it evaluates to 5.
07:28:45 <wolverian> danfg, "2".to_i + 3 in ruby evaluates to 5.
07:28:53 <danfg> oh
07:29:00 <Frobar> neologism: i'm talking about people with very little general experience with programming though
07:29:02 <shapr> Perl is weakly typed.
07:29:03 <kowey> wolverian: i thought that's strong vs weak (as opposed to static vs dynamic)
07:29:28 <Maddas> Isn't 'weak' stronger than just automatic coercion, though?
07:29:36 <shapr> Yeah, it is.
07:29:43 <wolverian> right.
07:29:58 <wolverian> shapr, perl is strongly typed on the containers.
07:30:01 <shapr> I think weak in Perl means you just have a value in memory, and it's treated as whatever type you ask for.
07:30:25 <shapr> Whereas in Haskell, each value has some metainfo in memory that says what type it is, it's not just a buncha bits.
07:30:45 <neologism> Frobar: I read somewhere about an experiment when they taught programming to children using prolog
07:30:46 <mauke> Perl doesn't support untyped bits
07:30:59 <flux__> neologism, how did it go?
07:31:06 <shapr> mauke: You're a perl guy, yeah? Can you tell us what weakly typed means in Perl?
07:31:09 <neologism> flux__: well ;)
07:31:12 <mauke> I have no idea
07:31:19 <wolverian> shapr, the term isn't used in perl.
07:31:25 <shapr> wolverian: Oh, ok
07:31:27 <Maddas> I think type terminology doesn't easily map to Perl the obvious way
07:31:34 <mauke> Perl is weirdly typed
07:31:36 <Krunch> neologism: i know several people who played with prolog as childs
07:31:36 <Maddas> yeah :-)
07:31:39 <shapr> audreyt: Got a moment to explain weakly typed in Perl, or suggest someone who could?
07:31:43 <integral> are the terms "weak" and "strong" even well defined?!
07:31:48 <shapr> integral: Sure, yeah.
07:32:02 <wolverian> shapr, however, perl very much supports implicit coercion, which I think, is one definition of weak typing. however, that only applies to values, not containers.
07:32:14 <edwinb> eb@dronach:~$ perl -e 'print "10 potatoes"+2'
07:32:14 <edwinb> 12
07:32:19 <edwinb> that always scares me...
07:32:19 <wolverian> (er, well, it does apply to containers in some ways, actually.. I have to think about this)
07:32:24 <integral> edwinb: turn on warnings :-)
07:32:30 <shapr> http://c2.com/cgi-bin/wiki?WeaklyTyped
07:32:30 <Maddas> I thought implicit coercion wasn't enough -- for example, if it were well-defined coercion, how would that make it weak?
07:32:44 <dbremner> wolverian - have you used PL/I? here's my favorite example.
07:32:45 <edwinb> pfft ;)
07:32:48 <integral> you can't coerce an array ref to a hash ref though
07:32:57 <dbremner> wolverian - DCL (A,B,C) CHAR(3);
07:32:59 <mauke> integral: you can, actually :-)
07:32:59 <wolverian> shapr, that's a better definition than wikipedia's. thanks
07:33:00 <integral> it seems more like dynamic typing with implict coercion
07:33:06 <wolverian> dbremner, no, I haven't.
07:33:09 <Frobar> shapr: well, take the problem of printing the numbers from a to b, provided that you're not allowed to use any fancy constructs in the language. i think most people find it most natural to think of that as "set n to a; print n; add 1 to n; loop until n past b;"
07:33:16 <integral> mauke: damn you.  I'll pick hash ref to array ref then!
07:33:30 <dbremner> wolverian - the result of that code is C = "   "
07:33:37 <Frobar> i may be wrong, but that's what my experience from other students is telling me
07:33:41 <wolverian> dbremner, sorry, I don't get it :) 
07:33:51 <danfg> wolverian: with a few changes you can make it so that "2" + 3 = 5 or "5" in ruby, but i get your point. it's just that 1st time i saw ruby, i thought it was very dynamic in many aspects, i didn't think it was perfect though, so it's always interesting to me to hear feedback from a haskell coder
07:33:59 <Maddas> Frobar: That really sounds very much like they already learned an imperative language first.
07:34:06 <mauke> perl -le 'print [{wtf => 1}, "surprise!"]->{wtf}'
07:34:20 <wolverian> danfg, the .to_i etc. stuff just seems inhibiting when the language is otherwise dynamic.
07:34:25 <integral> mauke: that's deprecated.
07:34:36 <wolverian> mauke, does that still work in bleadperl, btw?
07:34:37 <dbremner> wolverian - it converts A and B to numbers, adds them, then converts the result back to a string and truncates from the right.
07:34:46 <shapr> Frobar: Personally, I'd just count one more until I reach the end. Thus I wonder if it's a personal viewpoint?
07:34:51 <Frobar> Maddas: some of them had practically zero programming experience, and they told me they found that version much easier to understand
07:35:00 <wolverian> dbremner, well, that's certainly pretty tight code for all that..
07:35:05 <Maddas> Frobar: Interesting. Much easier than which one?
07:35:11 <Saulzar> Frobar, Compared to what?
07:35:20 <Frobar> a functional version of the same routine
07:35:28 <mauke> wolverian: dunno
07:35:29 <Maddas> It depends a lot on the wording, of course :-)
07:35:32 <danfg> wolverian: sometimes i think there must be a higher reason for the to_i behavior, but at first i agree with you
07:35:35 <Saulzar> What was the functional version? :)
07:35:47 <dbremner> wolverian - it's easy to create rules that seem to make sense, but they tend to interact in weird ways, e.g. Koenig lookup in C++.
07:35:49 <neologism> Saulzar: recursion?
07:36:04 <wolverian> mauke, that's supposed to be removed in 5.10, anyway. :)
07:36:15 <Maddas> Frobar: But is this really explicitly imperative? Why must you modify N when adding N + 1, that's not necessary in your text.
07:36:20 <wolverian> danfg, I'm sure there is. I just don't like it, similarly to how I don't like the lack of autovivification
07:36:26 <Maddas> Frobar: I would, for example, understand your example as a recursive function.
07:36:28 <Saulzar> Recursion is not as easy to think in than combining functions
07:36:50 <wolverian> danfg, these worries may be unique to perl programmers who are introduced to ruby.
07:36:54 <neologism> recursion is quite natural imho
07:36:55 <Frobar> Maddas: the functional version was recursive. a lot of people have a lot of trouble with recursion, trust me.
07:36:58 * danfg looks up autovivification
07:37:06 <Maddas> Frobar: No, I understand _what you said_ as recursive.
07:37:10 <Saulzar> Granted recursion is not particually difficult, but combining a few functions makes for more natural solutions
07:37:11 <wolverian> danfg, (as that's what I am by history, not quite as good at haskell yet)
07:37:35 <Maddas> Frobar: I believe you, though. But believe me, a lot of people have trouble with pointer chasing and off-by-one loop statements too :-)
07:37:41 * wolverian wonders if it's a good idea to identify oneself as a 'X programmer' 
07:38:11 <Maddas> I don't believe either type of programming is really natural. Eating is natural, using a computer isn't :-)
07:38:12 <Saulzar> X is not a very good language :)
07:38:23 <wolverian> Saulzar, it's a substitution template. :)
07:38:27 <shapr> Maddas: I think you have a point.
07:38:35 <shapr> Programming is just unnatural.
07:38:45 <wolverian> unnatural to humans, maybe. 
07:38:48 <shapr> Otherwise we'd be born with CPUs!
07:38:53 <Maddas> (-:
07:38:59 <Frobar> Maddas: yes, but i wonder if those problems are in proportion to those a lot of people have with the functional way of thinking about problems.
07:39:05 <integral> I hate 'where'.
07:39:19 <Saulzar> I love 'where'
07:39:28 <Maddas> Frobar: I don't know, I think it depends much more on the teacher and his lectures than on the language, for example. 
07:39:36 <integral> I can't manually call functions declared in a 'where' from the ghci command line.
07:39:37 <Saulzar> What's the trouble with it integral? 
07:39:40 <Maddas> Frobar: I believe that the language can make a large difference, of course, but you'll find people liking either.
07:39:40 <shapr> Yeah, true. Good teachers make for well educated students.
07:39:50 <integral> Something like cayenne's 'open' would be nice
07:39:56 <Frobar> i still think the paradigm matters very much
07:40:01 <shapr> integral: You could install HaRe
07:40:01 <Maddas> Frobar: Absolutely.
07:40:14 <integral> shapr: what's that?  And does it work with GHC extensions in your source?
07:40:24 <shapr> Frobar: I agree, but I still think functional makes more sense :-) Things don't get mutated in math classes.
07:40:30 <Maddas> Frobar: But you can explain either in a way that is hard to understand, and I believe that you can explain many, many things both functionally or imperatively so that they are easy to understand.
07:40:34 <Saulzar> integral, You mean you're wanting to try out inner functions?
07:40:37 <Frobar> yes, but i think most people, at least beginners, find the imperative style more accessible. that's speaking from experience, not my personal intuition.
07:40:39 <integral> Saulzar: yeah.
07:40:45 <wolverian> danfg, did you find it? I can explain it to you if you wish
07:41:00 <integral> Saulzar: it's even simpler in this case, since the inner functions aren't even closures!
07:41:04 <shapr> Frobar: I'm sure you have more experience than I do.
07:41:05 <Saulzar> integral, Well, you can always split them out... seems a good idea if they're useful on thier own basis
07:41:06 <Maddas> Frobar: Interesting.
07:41:13 <integral> Saulzar: *sigh*.
07:41:36 <shapr> I've only taught people here on #haskell, and Haskell nearly always their second or Nth language.
07:41:38 <integral> but then i've got to have bigLongNamesThatDon_tClashBecauseWeDon_tHaveNestedModulesOrAnything
07:41:54 <shapr> integral: qualified imports?
07:41:57 <Maddas> I notice this (regarding things being called 'natural') most when talking about natural languages with other people -- I've met too many people trying to convince me that writing in pictograms is absolutely unnatural, and I absolutely fail to understand that view.
07:42:13 <danfg> wolverian: give me a minute, i'm also talking to ruby guys at #ruby-lang on the other end. :) they were talking about the .to_i thing, and why it is necessary to avoid ambiguity. "2" + 3  could be = 5 or "23"
07:42:13 <integral> shapr: but modules have to be in another file...  but yes, I like qualified imports :-0
07:42:15 <Maddas> (And that the conventional English/German/similar alphabet is the most natural of all)
07:42:19 <integral> :-)
07:42:30 <Saulzar> integral, Yeah, you don't have to export everything either...
07:42:52 <shapr> Frobar: seen http://www.cse.unsw.edu.au/~chak/papers/CK02a.html as mentioned by dbremner?
07:42:53 <Krunch> shapr: i'm not sure there are a lot of people learning their first programming language from irc (expect php "programmers" of course)
07:43:04 <shapr> There are some.
07:43:05 <Frobar> Maddas: i also think that learning to think functionally is a very good excercise, regardless of whether you end up programming mostly in an imperative language or not
07:43:13 <shapr> Plus #haskell has gotten a very good reputation.
07:43:15 <integral> I guess I should just give in and use really small modules  :-/
07:43:21 <Maddas> Frobar: Absolutely, I also think that way of math.
07:43:37 <Saulzar> Maybe they're not likely to end up on freenode unless they're a linux person or something anyway
07:43:46 <Maddas> Frobar: I still think that once you're used to thinking in both, the difference between the ways of thinking shrinks a lot. But maybe that's just me.
07:43:54 <shapr> I agree.
07:44:01 <danfg> wolverian: the word seems like self-reviving (self-ressuscitation?), heh. before i look it up, please enlighten me!
07:44:03 <shapr> But then I think OOP and the monadic abstraction are nearly the same too.
07:44:07 <Frobar> ugh.. if i'm a bit unresponsive it's because i'm trying to keep an icq conversation active :P
07:44:16 <shapr> Frobar: c'mon, type faster! ;-)
07:44:16 <wolverian> danfg, yeah. in JS, "2" + 3 = "23", because the + is overloaded for strings. maybe it's the same in ruby. in perl, operators determine the type of the operands, not the other way around.
07:44:19 <Maddas> Frobar: No worries, I'm really supposed to be wirting an essay :-)
07:44:23 <Maddas> Writin,g even.
07:44:25 <wolverian> danfg, therefore "2" + 3 has only _one_ definition
07:44:26 <Maddas> Ugh.
07:44:31 <shapr> I'm sposed to be writing Python for money :-/
07:44:51 <Maddas> shapr: Hey, my next semester project is in C++, does that cheer you up? ;-)
07:44:58 <wolverian> danfg, autovivification is what happens in perl when you access a key in a hash without declaring the key first. $foo{bar}{baz} = 2; # bar is automatically created, i.e. autovivified 
07:45:05 <Frobar> shapr: nope, what is it?
07:45:10 <mauke> it's not limited to hashes
07:45:26 <Frobar> http://www.cse.unsw.edu.au/~chak/papers/CK02a.html that is
07:45:27 <mauke> perl -wle '$foo->[23]{"bar"} = "hello"; print $foo'
07:45:35 <wolverian> mauke, right, sorry. 
07:45:45 <wolverian> my thinking is limited at times. 
07:45:51 <Frobar> ah, never mind
07:45:51 <mauke> package variables are autovivified, too
07:46:27 <Frobar> heh, i must be stressed when i can't even be bothered with visiting an url to find out what it's about
07:46:31 <shapr> Frobar: Manuel Chakravarty teaches several hundred students per year (per term?).
07:46:43 <tennin> the approach taken by How to Design Programs looks to me like an excellent one for beginners
07:47:07 <shapr> This article says "It's not about teaching imperative or functional programming, it's about communicating the basic concepts of programming."
07:47:09 <tennin> though I've never seen anyone try to learn from it
07:47:14 <dbremner> tennin- one of my friends is working through the Little Schemer.
07:47:24 <Maddas> shapr: sounds very reasonable.
07:47:26 <dbremner> tennin - IIRC, Rice teaches from it.
07:47:39 <shapr> Yeah, Chilli is a sensible guy.
07:47:45 <shapr> Not often on #haskell lately, though.
07:50:38 <shapr> Monads are a lot like objects, but they're like a zipper instead a bag of marbles.
07:51:47 <wolverian> mauke, well, aren't package variables just hash keys..? :)
07:51:55 <Maddas> shapr: Whoa, and I thought I had finally understood them (-:
07:52:25 <xerox> What what?
07:52:27 <shapr> Well think about it, how would you compare a monad and a command object, for example?
07:54:11 <Maddas> shapr: I've never really found a personally satisfying analogy for monads in general (as opposed to particular ones like the IO monad), so I just think of them as these monad things.
07:54:38 <Maddas> But I consider that a personal failure of imagination, not any didactical guideline :-)
07:57:25 <Maddas> Hmm, actually, a zipper doesn't seem too bad.
07:57:39 <Maddas> shapr: What makes you think of a bag of marbles, though?
07:58:28 <xerox> What are you comparing the zipper to?
07:59:19 <Maddas> xerox: You don't mean zipper as in Oleg's Zipper, do you? I didn't :-)
07:59:45 <shapr> Maddas: Well, OOP is just a bunch of objects.
07:59:51 <shapr> They roll around like a bag of marbles.
07:59:52 <Maddas> shapr: Oh, haha.
08:00:01 <xerox> IIKWYM that zipper is just more general than general, but yes, a zipper :-)
08:00:08 <shapr> There's no order, the only abstraction is hiding things inside the marbles.
08:00:23 <xerox> (I.e. it is parametric on the structure AND the means of moving.)
08:00:26 <Maddas> shapr: That's cool, I see
08:00:42 <shapr> xerox: Yes
08:00:52 <ihope> Is the static typing stuff still going on?
08:01:09 * shapr quickly zaps ihope with a static charge!
08:01:41 * ihope notices that his keyboard starts working whenever he moves his fingers over it
08:01:41 <Maddas> ihope: No, we're now talking about marbles and zippers instead! (:
08:02:07 <Saulzar> I must say I don't follow any of the marbles and zipper analogy :)
08:02:12 <xerox> Fun fun fun.
08:02:18 <ihope> Oh, right, we have logs
08:02:41 <shapr> Saulzar: You know OOP?
08:02:48 <Saulzar> Yes
08:02:59 <shapr> Could you compare a program with a bunch of objects inside to a bag of marbles?
08:03:43 <jethr0> moin moin
08:03:54 <Saulzar> I don't see it matches particually well... but I suppose :)
08:04:09 <shapr> hey jethr0! ltns!
08:04:09 <shapr> Saulzar: You know monads?
08:04:24 <jethr0> ltns?
08:04:32 <int-e> marbles? marbles are round and shiny. software usually isn't.
08:04:41 <Saulzar> Yes.. well, enough :)
08:04:55 <Maddas> jethr0: Long time no see
08:05:02 <Maddas> (Or software, for coders :-)
08:05:14 <ihope> Okay. So you have a bunch of marbles rolling around, bouncing off each other.
08:05:16 <shapr> jethr0: long time no see.
08:05:16 <shapr> Saulzar: Could you describe a monadic program as a zipper?
08:05:28 <vincenz> @where hac
08:05:28 <lambdabot> http://haskell.org/haskellwiki/HAC
08:05:31 <ihope> The zipper stuff... no idea.
08:05:32 <moonlite> uuh :( I have a state (Control.Monad.State) which contains a record. Now i'd like to modify the record, but apparently this helper function doesn't work: "setField field value r = r{field=value}". Are there any way of updating a field in a record "dynamically"? 
08:05:39 <shapr> Whereas a monad is more like a zipper, everything gets sewn together dynamically.
08:06:19 <ihope> moonlite: try using the (\r -> r {field = value}) function somewhere.
08:06:21 <shapr> moonlite: Template Haskell?
08:06:42 <jethr0> ihope: i think the problem is referring to a record name through a variable...
08:06:42 <ihope> @index modifyState
08:06:42 <lambdabot> bzzt
08:06:54 <ihope> Oh, I see.
08:06:56 <jethr0> *record field name
08:06:58 <moonlite> shapr: oh. i'll look at that
08:07:30 <ihope> @hoogle State a b -> (a -> a) -> State a b
08:07:31 <lambdabot> Control.Monad.State.withState :: (s -> s) -> State s a -> State s a
08:07:38 <ihope> Hmm.
08:07:43 <ihope> Ah.
08:08:12 <xerox> I don't see the relation between monads and zippers anyway.
08:08:32 <shapr> ihope: Do you know monads?
08:08:45 <shapr> xerox: The execution pattern of a monad is like a zipper.
08:08:50 <ihope> shapr: yeah
08:09:02 <xerox> Is it?  It is just function application, imo.
08:09:07 <Saulzar> A monadic program seems a somewhat lower level concept than OO ..
08:09:12 <ihope> I always thought of monads as magic bubbles.
08:09:28 <xerox> The zipper involve a different *type* machinery, I think.
08:09:30 <shapr> xerox: Yeah, but look at how >>= sews it all together.
08:09:35 <ihope> You can stick a value into a magic bubble, and you can stick a function into a magic bubble.
08:09:39 <shapr> xerox: No, I mean the zipper on your jacket!
08:09:43 <xerox> Ah, ops.
08:09:59 <shapr> Not Huet's Zipper :-)
08:10:19 <ihope> You can also turn doubly layered magic bubbles into singly layered magic bubbles...
08:10:22 <Saulzar> So I suppose the marbles and zipper thing works, but they don't compare very well :)
08:10:38 * xerox is biased, he touched more structural zippers than physical zippers... he hates jackets.
08:10:53 <shapr> Well, one reason I find those effective analogies is that I wish to compare 'abstractional complexity'.
08:11:18 <shapr> For example, how many things can possibly be coupled to each other in the worst case with either abstraction?
08:11:56 <shapr> (I think this is true) In the monadic abstraction, the worst case is the number of monad transformers in the stack that makes up the whole monad.
08:12:36 <shapr> (once again, correct me if you disagree) In the object abstraction, any instance can affect any other instance, so I think the worst case complexity would be the maximum number of object instances in an OOP app at any given time.
08:12:50 <Saulzar> But monads only describe the rules of the program, no the data... and not the code. Objects are the data, and the code... seems somewhat orthogonal
08:12:58 <shapr> I think that's one of the great advantages of monads.
08:13:18 <shapr> Monads are both data and code, I'd say.
08:13:49 <shapr> Saulzar: tell me more...
08:15:36 <ski> boegel : funmath seems cool !  you said your prof were involved with it ?
08:15:52 <ski> (err .. he just left)
08:16:27 <Saulzar> Hmm, monads give you the building blocks of your language - state, exceptions, search etc. Your program uses the basic building blocks
08:16:48 <ski> (reading the main page there, it seems to come to roughly same conclusions regarding math notation as i've done on my own)
08:17:52 <ihope> @hoogle a b c -> b -> a () c
08:17:53 <lambdabot> Control.Parallel.par :: a -> b -> b
08:17:53 <lambdabot> Control.Parallel.seq :: a -> b -> b
08:17:53 <lambdabot> GHC.Conc.par :: a -> b -> b
08:20:03 <DukeDave> afternoon all
08:20:08 <shapr> hiya
08:20:40 <shapr> Saulzar: Ok, think of a derivative of a program.
08:21:08 <Maddas> shapr: Heh!
08:21:31 <shapr> I'd say you can compare abstractions at that level, the first order derivative, sort of.
08:21:41 * shapr thinks more.
08:21:58 <Maddas> shapr: So changing monads would be changing the first derivative of the program instead of the program itself? :-)
08:22:18 * shapr thinks about that.
08:22:20 <Maddas> (At least I find that an interesting line of thought)
08:22:27 <Saulzar> Hehe, I suppose that works.
08:23:07 <shapr> well yeah
08:23:13 <shapr> Any abstraction is the first order derivative.
08:23:19 <shapr> That's the sort of the whole point, isn't it?
08:23:22 <Maddas> Indeed.
08:23:41 <shapr> monads reach higher orders of abstraction, but let's not even go there for now.
08:23:52 <shapr> hm, or maybe we should.
08:23:54 <Maddas> Right, I was thinking about that too
08:23:56 <Maddas> heh :-)
08:23:59 <ihope> Monad arrow!
08:24:06 <shapr> The second order derivative of objects is metaclasses. 
08:24:06 <ski> marrow !
08:24:11 <ihope> Yeah!
08:24:36 <Maddas> shapr: But what if metaclasses are also just classes? Does that let you produce arbitrarily powerful abstractions just by deriving derivations?
08:24:59 <shapr> In Smalltalk and CLOS, they are just classes.
08:25:02 <ski> (Maddas : maybe like \x. e^x is it's own derivative ?)
08:25:05 <Maddas> Indeed, that's why I was asking.
08:25:16 <Maddas> ski: Oh no, let's not go there. My essay... ;-)
08:25:28 <ihope> You know, it seems that Functor is the only Prelude class such that instances can be made into a type constructor which is actually a member of that class.
08:25:29 <ski> Maddas : essay ?
08:25:38 <Maddas> ski: (I'm supposed to be working now)
08:25:50 <ihope> Arrow doesn't work either.
08:25:52 <DukeDave> hi guys, what is the `correct' name for structs in haskell?   i.e. of the form  > newtype Foo a = Foo {bar :: String}
08:25:58 <ihope> Records, I think.
08:26:03 <shapr> Maddas: I don't know. I can't say anything about arbitrarily powerful. I can't see that high.
08:26:08 <ski> ihope : what do you mean ?
08:26:24 <shapr> I don't think metaclasses will allow more powerful abstractions actually.
08:26:30 <Maddas> shapr: Right, going too far will make things unwieldy.
08:26:37 <shapr> They'll always be limited by the rules of metaclasses.
08:26:46 <DukeDave> Thanks ihope 
08:26:51 <ihope> ski: data Functor_ a where Functor_ :: Functor f => f a -> Functor_ a
08:26:51 <ski> (ihope : re 'Functor' i.e.)
08:26:58 <ihope> Functor_ is an instance of Functor.
08:27:19 <ski> 'Show' ?
08:27:20 <ihope> If you did the same thing with Monad, then Monad_ wouldn't be a Monad, and Num_ wouldn't be a Num...
08:27:26 <ihope> Show has showList.
08:27:33 <shapr> Python, monads, and some other things are in 'sweet spots' (local minima) of unusual simplicity and power inside an extremely large solution space.
08:27:38 <ski> ihope : and ?
08:27:44 * Maddas agrees with shapr
08:28:14 <ihope> ski: well, showList (Show_ "foobar") isn't the same as showList "foobar".
08:28:17 <shapr> I think that more expressive abstractions will be simpler even than monads, more 'predictable', and more powerful as well.
08:28:27 <ski> ihope : did anyone say they should ?
08:28:28 <ihope> ski: that is, map Show_
08:28:59 <shapr> Because, abstractions are only about effective communication, with yourself and others. They're just conventions that let us easily change our focus.
08:29:01 <ski> shapr : or maybe orthogonal
08:29:53 <shapr> I often wish for a third and very different abstraction to compare to monads and objects.
08:30:02 <shapr> I think I'd be able to generalize sufficiently to come up with a bunch more after that.
08:30:24 <ihope> Well, I didn't really try it with Read, but Read_ would be just as useless as Functor_.
08:30:27 <ski> shapr : what are 'objects', to you ?
08:31:05 <shapr> ski: Two axes, one along inheritance, and one along statefulness.
08:31:14 <Saulzar> I just don't see how they can be compared at all
08:31:32 <ski> shapr : inheritance being implementation inheritance, yes ?
08:31:36 <shapr> Yup
08:31:49 <ski> shapr : how about subtyping / interface-inheritance ?
08:31:52 <shapr> Saulzar: They do the same thing, they hide stuff that doesn't pertain to the problem.
08:32:10 <ski> (shapr : like a collection of objefcs implementing widget interface ..)
08:32:31 <shapr> ski: I see that as part of implementation inheritance, since the type is the same as the interface, as far as I can tell.
08:33:09 <Saulzar> shapr, Sure, they both provide abstraction - but they're at such different levels
08:33:20 <ski> shapr : but class types is not same as object types, necessarily ..
08:33:26 <shapr> Saulzar: Not so different, they both do state hiding and pipelining for example.
08:33:46 <shapr> ski: What about limiting this to prototype oriented systems?
08:33:53 <ski> shapr : an object of a subclass needn't have as type a subtype of the type of an object of the baseclass
08:34:09 <ski> shapr : maybe, then :)  (i don't know much about those)
08:34:10 <shapr> ski: How so?
08:34:22 <ski> binary methods
08:34:36 <ski> methods returning object of same type as "self"
08:34:47 <ski> this can be seen in OCaml
08:34:54 * shapr is totally lost
08:35:14 <ski> should i take a simple example  ?
08:35:31 <shapr> An instance of a subclass does not need to be a subtype of an instance of the base class?
08:35:35 <shapr> How can that be so?
08:35:54 <ski> let's say we have a class A
08:36:00 <ski> with a method
08:36:04 <shapr> hiya Wrrrtbt, learning Haskell?
08:36:08 <shapr> ski: ok...
08:36:32 <shapr> int-e: aha!
08:36:37 <ski> meth0 :: A -> Blaha
08:36:45 <ski> so, if
08:36:50 <ski> obj :: A
08:36:57 <ski> and
08:37:00 <ski> obj' :: A
08:37:00 <ski> then
08:37:13 <ski> obj.meth0(obj') :: Blaha
08:37:32 <ski> ok ?
08:37:48 <shapr> It looks like you're getting a value out of the instance or something.
08:37:54 <Maddas> ski: Is this in any way related to subclasses not necessarily obeying the 'substitution principle'?
08:38:08 <ski> Maddas : possibly
08:38:13 <Maddas> (Liskov Substitution Principle)
08:38:22 <shapr> I think I understand what you've said so far, but I still don't see how it relates.
08:38:26 <ski> Maddas : though usual reason for breaking that is state, i think
08:38:26 <pierre-> hello.
08:38:27 <Saulzar> What is this syntax obj.meth0(obj') ?
08:38:34 <shapr> privet pierre- 
08:38:38 <shapr> Saulzar: OCaml, I think.
08:38:38 <ski> Saulzar : invented
08:38:39 <pierre-> privet
08:38:55 <ski> not ocaml
08:38:56 <mauke> no, OCaml is obj#method obj'
08:38:59 <shapr> oh, ok.
08:39:18 <Saulzar> if meth0 takes an A, looks like 2 params there obj and obj' 
08:39:25 <ski> that exact concrete syntax doesn't matter much
08:39:44 <ski> Saulzar : yes, that's why this is called a "binary method"
08:39:45 <Saulzar> Ah, I see
08:39:51 <ski> anyway
08:39:57 <ski> now we make a subclass, B
08:39:57 <Saulzar> It's an instance method which also takes another A :)
08:40:12 <ski> yes
08:40:34 <mikaeli> ski: structural subtyping?
08:40:35 <ski> this subclass B has possibly new methods
08:40:40 <shapr> Is this like duck typing?
08:40:56 <ski> also, it still has the old methods meth0
08:41:00 <ski> so, given
08:41:04 <ski> obj :: B
08:41:09 <ski> obj' :: A
08:41:17 <ski> obj.meth0(obj') :: Blaha
08:41:22 <shapr> aha - http://c2.com/cgi-bin/wiki?StructuralSubtyping
08:41:36 <ski> note that the argument of the method still has type 'A'
08:42:20 <Maddas> ski: Hm, I don't see how it's related to statefulness, but I might ask another time if you don't mind.
08:42:31 <ski> it would be unsafe to say it only accepts objects of type 'B' as argument, in this class
08:42:50 <shapr> yeah
08:42:59 <Saulzar> Right..
08:43:01 <ski> Maddas : i don't intend to bring state into this example at all ..
08:43:25 <Maddas> Indeed, don't let me interrupt your explanation, it's unrelated anyway.
08:43:28 <ski> since, an object of type 'B' can be coerced into having (static) type 'A'
08:43:39 <shapr> ok
08:43:58 <ski> and, then some other code could call meth0 on the object, with an object of type 'A' as argument
08:44:13 <ihope> Is the unsafeCoerce# function really defined *at all*?
08:44:24 <shapr> ihope: Yeah, it calls out to Perl and...
08:44:26 <ski> so, if B is subtype of A, we can't change type of argument of meth0 from A into subclass B
08:44:27 * shapr is joking
08:44:33 <ihope> :-)
08:45:02 <ski> we *could* change the type "the other way around"
08:45:46 <shapr> yeah
08:45:55 <ski> i.e. we could be more allowing in 'meth0' in 'B', we could allow not only 'A' args, but also args of 'SuperA'
08:45:55 <shapr> y0 metaperl 
08:46:27 <shapr> upcasting.
08:46:47 <ski> ('SuperA' being a superclass of 'A')
08:46:52 <beelsebob_> is it possible to get the token stream out of ghc-api easily?
08:47:01 <ski> so, 'meth0' in 
08:47:11 <ski> 'B' can accept any object of 'SuperA'
08:47:17 <metaperl> shapr: hi!
08:47:48 <shapr> ski: I think I got it.
08:48:01 <ski> but, if we upcast a 'B' object, into 'A', then we forget that 'meth0' can handle all objects of 'SuperA', and only know that objects in 'A' work
08:48:14 <ski> ok, now i take same example, but with a crucial difference
08:48:22 <ski> we have a class A
08:48:30 <ski> it has a method 'meth0'
08:48:42 <ski> meth0 :: Self -> Blah
08:48:57 <Saulzar> Hmm, that makes sense. A proper subclass can only relax pre-conditions and tighten post conditions 
08:49:03 <ski> it takes an object of the same type of the type of 'self'
08:49:21 <ski> so, if we instantiate an object of 'A', then meth0 :: A -> Blah
08:49:23 <ski> otoh
08:49:25 <Lemmih> beelsebob_: It's easy to use the GHC lexer, if that's what you want.
08:49:31 <ski> if we make a subclass 'B' of 'A'
08:49:50 <ski> and instantiate an object of 'B', then meth0 :: B -> Blah, for that object
08:50:03 <shapr> ski: self is a metavariable?
08:50:30 <ski> 'Self' is a type-metavariable, just like 'self' is a object-metavariable
08:50:58 <ski> it refers to the actual type of the object, after possible subclassing
08:51:46 <ski> so, the static types know that the argument of meth0 will always be of same class as 'self'
08:52:32 <ski> now, note that, even though 'B' is a subclass of 'A' (it's implementation was derived/inherited from the one in 'A') ..
08:52:42 <ski> .. 'B' is *not* a subtype of 'A' !
08:53:00 <ski> you can't pass a 'B' where an 'A' is expected
08:53:52 <ski> 'meth0' in 'B' may assume all the methods in 'B' are defined in the argument object
08:54:26 * shapr goes through that again...
08:54:28 <ski> but if you would upcast a 'B' object to 'A', then you could pass 'A' objects as args, which don't understand/support all the methods of 'B'
08:55:41 <shapr> hm
08:55:46 <ski> (so, the 'B' implementation of 'meth0' could try to invoke 'B'-methods on the 'A'-argument-object, and MethodNotUnderstood would result)
08:56:42 <ihope> Almost time to go to school.
08:56:48 * ihope waits until the last minute
08:56:55 * shapr tends to wait longer
08:56:57 <ski> it's different to say a method should take an argument of same type as this actuall class ('A') and say that a methods should take an argument of whatever final subclass of this class was instantiated into an object
08:57:24 <shapr> yeah
08:57:26 <ski> shapr : OCamls OO system explained this to me ..
08:57:36 <shapr> It's a strange thing, I did not know about it.
08:57:56 <Saulzar> Hmm, but the self argument is like a closure - can't be treated like just another argument
08:58:18 <ski> in Java the 'compare' method take an 'Object' and one dynamically has to downcast and hope for the best
08:59:04 <Saulzar> Compare by value with inheritance is quite hard
08:59:33 <ski> this issue is called the binary-methods problem
08:59:58 <ski> shapr : there is a similar issue, when a method should return something of same type as the actual object (e.g. a clone method)
09:00:21 <ski> (or, immutable objects, for that matter)
09:00:27 <Saulzar> Is that related to multi-methods and double-dispatch?
09:00:56 <ski> Saulzar : i guess, though i don't know multi-methods
09:01:43 <Saulzar> Multi-methods being a method polymorphic on multiple arguments
09:01:55 <ski> yes
09:02:07 <ski> i'm not sure how a static typesystem for such would look like
09:03:42 * ski thinks programming with coinheritance could be interesting ..
09:09:25 <vincenz> o.O
09:11:11 <shapr> ski: Hur kan man sÃ¤ga referential transparency pÃ¥ svenska?
09:11:33 <vincenz> sega referential transparency?
09:11:37 <vincenz> I thought sega was dead
09:11:47 <vincenz> ski: interesting train of thought
09:11:55 <shapr> "att sÃ¤ga" -> to say
09:11:57 <vincenz> ski: I wish I was more lucid, but I'd love to discuss at some later point
09:12:02 * vincenz is on sleepderp
09:12:04 <vincenz> deprv
09:12:11 <vincenz> my most common drug
09:12:47 <vincenz> ski: as for the clone idea, some way, loki solves it but I can't remember
09:13:09 <Buggaboo> hi ski
09:13:10 <vincenz> loki, the library from "Modern C++ Design" - Alexandrescu
09:13:25 <vincenz> anyays
09:13:34 * vincenz is off for some much needed R&R
09:16:13 <ski> shapr : funktionen är referentiellt transparent
09:16:37 <shapr> hm, was that latin-1?
09:16:52 <integral> is there a standard function for \f -> sequence $ map f ?
09:16:54 <ski> (vincenz : discuss this OO isuue ?)
09:17:06 <ski> shapr : i don't know ..
09:17:19 <mikaeli> sure it was. I saw it correctly
09:17:37 <ski> hiya Buggaboo
09:17:50 <shapr> I'm stuck on utf-8 at the momen.t
09:18:04 <Buggaboo> generic programming on C++ is quite interesting.
09:18:10 <shapr> I've been debating Haskell vs Erlang on helgon.net recently.
09:18:24 <integral> integral: you want mapM
09:18:32 <Buggaboo> more syntax baggage than haskell, but quite alright for an imperative language.
09:18:32 * ski has no idea which of those character sets are considered more proper, not to mention how to configure which to use
09:18:54 <ski> shapr : is it visible to non-members ?
09:19:21 <ski> @type \f -> sequence . map f
09:19:22 <lambdabot> forall (m :: * -> *) a a1.
09:19:22 <lambdabot>          (Monad m) =>
09:19:22 <lambdabot>          (a1 -> m a) -> [a1] -> m [a]
09:19:29 <ski> @type mapM
09:19:30 <lambdabot> forall b (m :: * -> *) a.
09:19:30 <lambdabot>    (Monad m) =>
09:19:30 <lambdabot>    (a -> m b) -> [a] -> m [b]
09:20:19 <shapr> ski: I don't know, want the url?
09:21:25 <ski> sure
09:22:12 <shapr> http://www.helgon.net/Forum2/display_mess.asp?mid=0&tid=307631&fid=76&VD=192905
09:22:18 <shapr> Active Server Pages, eww
09:24:48 * ski wonders if he has to enable javascript
09:25:31 * shapr dunno
09:26:12 <ski> (bah, still redirects .. oh well)
09:29:03 <dbremner> shapr- doesn't seem to work for me.
09:30:53 <shapr> It's mostly in Swedish, so might not have worked even if you had access :-)
09:34:35 <shapr> hiya vaxen
09:34:42 <vaxen> lo
09:35:33 <shapr> How's code?
09:36:56 <vaxen> trying to figure out how to do function to the power n = function ( function(function x)....) to the n
09:37:19 <shapr> @type iterate
09:37:20 <lambdabot> forall a. (a -> a) -> a -> [a]
09:38:06 <shapr> vaxen: Does that help?
09:38:37 <vaxen> not really, i'm still learning
09:38:45 <vaxen> i'll have a look at the turorials
09:38:54 <vaxen> s/turorials/tutorials
09:39:41 <shapr> > take 5 $ iterate (+2) 1
09:39:42 <lambdabot> [1,3,5,7,9]
09:40:36 <shapr> vaxen: better?
09:41:15 <vaxen> basically im trying to write an iteration function that takes number n, function f :: a->a and element x::a and returns f^n x
09:41:18 <jethr0> > until (>8) (+2) 1
09:41:19 <lambdabot> 9
09:41:25 <jethr0> hmm
09:41:36 <vaxen> and i dont have any other functions defined (such as until etc)
09:42:16 <vaxen> what i thought was: iterator n f x = if (n==0) then x else iterator (n-1) f(fx) x
09:42:49 <vaxen> wanna try to get it to output the whole f(f(f(f(f(x)))))) for n f's
09:43:11 <jethr0> > let f 0 g = id; f n g = g . f (n-1) g in f 3 (+2) 4
09:43:12 <lambdabot> 10
09:44:44 <shapr> vaxen: Check out foldr and then scanr
09:45:11 <sjanssen> @type iterate
09:45:11 <lambdabot> forall a. (a -> a) -> a -> [a]
09:45:35 <sjanssen> perhaps a combination of iterate and takeWhile could work?
09:45:50 <vaxen> assuming im trying to do it with VERY basic functions
09:46:50 <vaxen> the type could be something like (n->a)->(a->a)->a->a
09:47:12 <vaxen> cause im returning f^n x
09:53:12 <vaxXen> shapr: foldr function?
09:53:18 <jonkri> how can i check if a element is in a list?
09:53:29 <sjanssen> @type elem
09:53:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:53:37 <jonkri> thanks
09:55:42 <shapr> > foldr1 (+) [1..5]
09:55:43 <lambdabot> 15
09:55:48 <shapr> > scanr1 (+) [1..5]
09:55:49 <lambdabot> [15,14,12,9,5]
09:57:04 <jethr0> > foldl (.) id (replicate 3 (+2)) 4
09:57:05 <lambdabot> 10
10:00:21 <shapr> vaxXen: Did that help any?
10:00:31 <vaxXen> its way too advanced for what im trying to do
10:00:41 <vaxXen> im only a beginner :$
10:02:38 <shapr> ok, time to learn cool stuff!
10:02:52 <shapr> Higher order functions encapsulate basic execution patterns...
10:03:07 <vaxXen> hehe
10:03:24 <shapr> For example, the pattern of applying a function to an item can be turned into the pattern of applying a function to a list.
10:03:27 <shapr> > (+1) 1
10:03:28 <lambdabot> 2
10:03:37 <shapr> > map (+1) [1,2,3,42]
10:03:38 <lambdabot> [2,3,4,43]
10:04:03 <shapr> So map takes two parameters, a function and a list, and it applies the function to each item in the list, yeah?
10:04:28 <vaxXen> yeah
10:04:30 <ski> > map (map (* 10)) [[0],[1,2],[3,4,5]]
10:04:30 <lambdabot> [[0],[10,20],[30,40,50]]
10:04:39 <vaxXen> so foldr does something similar..
10:05:04 <vaxXen> well not quite
10:05:05 <shapr> Another basic pattern is to start with a function from two inputs to one input, maybe it's (+), and then apply it to an entire list.
10:05:25 <shapr> This is called fold, because it's like folding up something through that function.
10:05:36 <shapr> > foldr1 (+) [1,1,1]
10:05:37 <lambdabot> 3
10:05:57 <shapr> foldr folds to the Right, and foldl folds to the Left
10:06:09 <mathrick> shapr: foldr1 x y = foldr x y 0 ?
10:06:14 <shapr> At least, I think that's correct, I often get confused there...
10:06:16 <ski> > foldr1 (^) [2,2,2,2]
10:06:17 <lambdabot> 65536
10:06:20 <ski> > foldl1 (^) [2,2,2,2]
10:06:21 <shapr> mathrick: You got it.
10:06:21 <lambdabot> 256
10:06:39 <mathrick> shapr: except that the order was wrong :)
10:06:39 <vaxXen> i got it
10:06:57 <shapr> fold also takes a starting value, but foldr1 and foldl1 don't.
10:07:09 <mathrick> shapr: foldr folds _from_ the right, I'd say
10:07:20 <mathrick> I don't know how it's customarily described
10:07:35 <mathrick> but intuitively, it folds "from" the right
10:07:37 <shapr> I believe you, I always get those confused.
10:08:00 <shapr> I end up having to try them twice :-/
10:08:00 <vaxXen> so to solve my problem i can use scanr (f) n [x] ?
10:08:05 <mathrick> shapr: note I don't know what's correct. I'm just saying what I think should be right :)
10:08:18 <shapr> vaxXen: try it!
10:08:25 <shapr> lambdabot runs real Haskell.
10:08:25 <vaxXen> that is so clever
10:08:29 <vaxXen> :P
10:08:35 <ski> foldr f z [a_0,a_1,...,a_n_1,a_n] = f a_0 (f a_1 (... (f a_n_1 (f_ a_n z))..))
10:08:55 <shapr> vaxXen: scan is like fold, but it also spits out the intermediate results.
10:08:57 <mathrick> ski: that's actual haskell code?
10:09:03 <vaxXen> yeah i realised that
10:09:15 <shapr> vaxXen: There are a few more basic patterns, but you've obviously got the basic idea now.
10:09:21 <ski> foldr (^) 42 [a_0,a_1,...,a_n_1,a_n] = a_0 ^ (a_1 ^ (... (a_n_1 ^ (a_n ^ 42))..))
10:09:27 <jonkri> how do i perform something for every element in a list?
10:09:33 <ski> mathrick : no, pseudo-code
10:09:48 <shapr> vaxXen: If you're more of a math guy, you might like list comprehensions as well.
10:09:59 <mathrick> ski: okay, I was getting afraid for a second there :)
10:09:59 <jonkri> like, in [1, 2, 3], i want to send 1 and 2 and 3 into a function (three calls)
10:10:00 <vaxXen> thats a very nice solution to what im trying to do, but im not supposed to use any other functions other than arithmetic functions and let/where
10:10:18 <ski> foldl (^) 42 [a_0,a_1,...,a_n_1,a_n] = ((..((42 ^ a_0) ^ a_1) ...)^ a_n_1) ^ a_n
10:10:28 <shapr> jonkri: map function [1,2,3] ?
10:10:31 <jonkri> ah, thanks
10:10:31 <dcoutts_> jonkri, map, fold, mapM, it depends what you're doing
10:10:45 <jonkri> map is fine
10:10:50 <mathrick> vaxXen: you can define foldr yourself trivially
10:10:56 <shapr> Yeah, I'd just rewrite fold.
10:11:00 <mathrick> well, it'll be trivial when you do it :)
10:11:12 <mathrick> vaxXen: actually, it's a very good excersise
10:11:12 <SyntaxNinja> I think we need a planet.haskell.org
10:11:27 <shapr> yup
10:11:32 <vaxXen> ok, thanks for the help
10:11:33 <shapr> We've needed it for awhile.
10:11:41 <SyntaxNinja> shapr: who is going to do it?
10:11:45 <vaxXen> is there a place that lists all functions included in haskell like properly?
10:11:48 <shapr> vaxXen: And remember, *lots* more cool tricks here, come back when you want more!
10:12:04 <shapr> vaxXen: Oh, read the Prelude
10:12:04 <vaxXen> something like what php does with php.net/<enter function here>
10:12:12 <mathrick> vaxXen: also, I'd suggest starting with foldl first, it's a bit more straightforward to define
10:12:18 <shapr> lambdabot has some good tools.
10:12:23 <shapr> @type foldr1
10:12:24 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:12:31 <shapr> @hoogle fold
10:12:32 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
10:12:32 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
10:12:32 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
10:12:47 <shapr> I wonder if it does substring searching?
10:12:49 <shapr> @help hoogle
10:12:49 <lambdabot>  @hoogle <expr>, Haskell API Search for either names, or types.
10:12:52 <shapr> guess not.
10:13:01 <vaxXen> hehe
10:13:27 <ski> @typo filter
10:13:28 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:13:30 * SyntaxNinja posts to haskell-cafe
10:13:30 <vaxXen> thanks for the help guys, will try and solve it
10:13:51 <ski> > filter (< 5) [1,4,2,8,5,7]
10:13:52 <lambdabot> [1,4,2]
10:14:00 <shapr> SyntaxNinja: Well, RSS aggregators are easy, yeah?
10:14:03 <ski> > filter (< 5) [2,8,5,7,1,4]
10:14:04 <lambdabot> [2,1,4]
10:14:51 <mathrick> > filter (<0) [1 .. 100]
10:14:52 <lambdabot> []
10:15:01 <SyntaxNinja> shapr: what could be easier?
10:15:32 <shapr> How about a wiki page that was read to fill in the aggregator?
10:16:58 <SyntaxNinja> huh?
10:17:45 <shapr> As in, once the aggregator is setup, the only cost is changing the feed list, yeah?
10:17:51 <shapr> The only maintenance cost, that is.
10:18:52 <SyntaxNinja> is there any "planet functional" or something?
10:18:53 <SyntaxNinja> right
10:19:02 <shapr> So you asked what would be easier, and I spit out my first thoughts on the matter.
10:19:27 <shapr> Don't think so.
10:19:30 <shapr> There's a planet lisp, though.
10:19:55 <shapr> stepcut has RSS code, we could write our own aggregator... but I'm too non-strict.
10:21:56 <mathrick> shapr: heh
10:24:52 <SyntaxNinja> yeah, we don't hav to write it from scratch ;)
10:33:46 <shapr> hej psi 
10:34:07 <psi> hej hej
10:37:13 <sili> hej
10:37:23 <palomer> psi hej
10:37:41 <bolrod> ey hey
10:38:23 <palomer> high
10:48:04 <jonkri> what's smaller than Small in a data type sense?
10:54:22 <sjanssen> Tiny?
10:54:39 <ski> empty ?
10:57:19 <jonkri> hehe
10:57:20 <jonkri> thanks
10:59:12 <dcoutts> anyone want to fix ghc's build system to be friendly to parallel make?
10:59:22 <dcoutts> as I recall it nearly works, but not quite
11:00:04 <shapr> I think it does work now.
11:00:14 <shapr> last I checked.
11:00:54 <sieni> hmm... should I get a huge lambda tattoo?
11:00:56 * Igloo would prefer it was rewritten from scratch
11:01:21 <Igloo> But that'll become more feasible once lots of bits are built by cabal
11:01:44 <twobitsprite> how does "return" know what kind of monad to create? is ther value just implicitly wrapped in whatever monad was passed in (the context for the preceeding >>=)?
11:02:07 <ski> twobitsprite : overloaded (on return type)
11:02:29 <twobitsprite> @type return
11:02:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
11:02:38 <sieni> twobitsprite: It uses magic called "type inference" ^_^
11:02:44 <Igloo> twobitsprite: The typechecker knows by infering the type from elsewhere
11:03:03 <ski> > return 'a' :: Maybe Char
11:03:04 <lambdabot> Just 'a'
11:03:10 <Igloo> The implementation at runtime will normally pass a value as an argument that essentially is the type
11:03:15 <ski> > return 'a' :: [Char]
11:03:15 <lambdabot> "a"
11:03:36 <ski> > (return 'a' :: () -> Char) ()
11:03:37 <lambdabot> 'a'
11:04:11 <twobitsprite> @type (return 'a' :: () -> Char)
11:04:12 <lambdabot>   No instance for (Monad ((->) ()))
11:04:12 <lambdabot>   arising from use of `return' at <interactive>:1:1-6
11:04:19 <ski> bah
11:04:29 <twobitsprite> erm
11:04:50 <ski> it's irritating that same modules are not loaded for @type contra @eval (aka '> ')
11:05:41 <ski> twobitsprite : 'instance Monad ((->) a)' currently lives in 'Control.Monad.Reader', if you want to play with it ..
11:06:04 <twobitsprite> hmm
11:12:59 <twobitsprite> it seems like there's some implicitly injected type... I'm having a hard time visializing this in a way the doesn't make me feel like there's a lot of arbitrary voodoo going on
11:15:24 <dcoutts_> shapr, you used make -j2 ?
11:16:16 <dcoutts_> shapr, I'll try make -j for the full parallel make debugging effect
11:16:44 <shapr> I think I did make -j 3
11:17:31 <shapr> Since I have two cpus.
11:18:26 <dcoutts_> shapr, ok, I recall trying it before with 6.4 or 6.4.1 and it nearly worked except for a bit near the beginning of the build. I'll give it another go.
11:18:47 <dcoutts_> shapr, you were using 6.4.1 or cvs 6.4 branch or latest darcs?
11:21:36 <shapr> Er, 6.4 something, I don't remember.
11:23:52 <ski> twobitsprite : it's overloaded on return type (i.e. context of the use), in a bit similar way that numeric literals are overloaded
11:23:56 <ski> @type 2
11:23:57 <lambdabot> forall t. (Num t) => t
11:24:00 <ski> @type 3.4
11:24:00 <lambdabot> forall t. (Fractional t) => t
11:30:54 <MarcWeber> Which function to use to do   print $ a   when a is of type (show b) => IO b ?  Thus I need IO ( IO b)  -> IO 
11:31:29 <ski> print =<<
11:31:35 <ski> er
11:31:38 <ski> print =<< a
11:31:43 <ski> or
11:31:50 <ski> do b <- a
11:31:54 <ski>    print b
11:32:29 <MarcWeber> ski: Thanks.. Why do I forget =<< every time? of cause that's what I want..
11:33:32 <sieni> haha: getCurrentDirectory: does not exist (No such file or directory)
11:33:47 <sieni> (and ghci refuses to start ^_^)
11:34:36 * mwc shines the lambda symbol into the sky
11:35:19 <shapr> BatLambda responds!
11:36:00 <mwc> I had some code. I ran it, memory use exploded, ate up all the ram on my computer, kept going until I aborted it
11:36:21 <mwc> I added some seqs, and now it stays at 3K ram
11:36:40 <mwc> next, I attempted to profile
11:36:55 <mwc> I assume the profile data from an aborted run is somewhat sane
11:37:05 <mwc> lo:
11:37:06 <mwc>         total time  =    14525.50 secs   (726275 ticks @ 20 ms)
11:37:06 <mwc>         total alloc = 1827,457,072,268 bytes  (excludes profiling overheads)
11:37:24 <mwc> so, I think I must have some sort of evil infinite loop happening here
11:38:33 <mwc> and I think I may have screwed this up
11:38:39 <mwc> does this look alright?
11:38:41 <mwc> iterateM :: (Monad m) => (a -> m a) -> a -> m [a]
11:38:41 <mwc> iterateM f x = let iM f x = x : iM f (x >>= f) in
11:38:41 <mwc>     sequence $ iM f $ return x
11:39:49 <mwc> I have a function in a monad that I want to iterate to produce an infinite list of hte results, just like iterate
11:40:26 <xerox> fixM ?
11:40:30 <mwc> fixM?
11:40:36 <mwc> \type fixM
11:40:37 <lambdabot> Not in scope: `fixM'
11:41:07 <mwc> yeah, hoogle doesn't have it either
11:42:19 <integral> @index fixM
11:42:19 <lambdabot> bzzt
11:43:18 <mwc> is there anything horribly wrong with using sequence on an infinite list? it seems that's what the implementation of mapM in the report does
11:44:55 <Philippa> mwc: depends, do you care about termination?
11:45:10 <mwc> Philippa, no, I end up using take on the result
11:45:23 <Philippa> (and with some monads it will terminate - eg sequence [Just 1, Nothing, Just 3...])
11:45:25 <mwc> liftM $ take n $ iterateM foo ...
11:45:35 <Philippa> that's not good enough AIUI
11:45:38 <Philippa> many monads're strict
11:45:40 <mwc> hmm, what about StateT
11:49:36 <ihope> @type let import Control.Monad.Reader in return 3 4
11:49:36 <lambdabot> parse error on input `import'
11:49:39 <ihope> Aww.
11:51:56 <ihope> @type Control.Monad.Reader.return 3 4
11:51:57 <lambdabot> forall a. (Num a) => a
11:52:05 <ihope> > return 3 4
11:52:05 <lambdabot> 3
11:52:24 <ihope> The Cont monad and the Reader monads are "the monads".
11:52:38 <ihope> As for State and all that... well, who cares about them? :-P
11:52:56 <Philippa> I often have use for State rather than Reader
11:53:33 <ihope> Yep...
11:53:46 <mwc> Woot, I fixed it, thanks for the hint Philippa 
11:54:01 <ihope> Any monad can be converted into a Cont monad.
11:54:01 <mwc> replaced with:
11:54:11 <ihope> Monadic value... whatever.
11:54:38 <mwc> nIterateM :: (Monad m) => Int -> (a -> m a) -> a -> m [a]
11:54:55 <ihope> @type (Control.Monad.Cont.Cont . (>>=))
11:54:56 <lambdabot> forall (m :: * -> *) a b.
11:54:56 <lambdabot>              (Monad m) =>
11:54:56 <lambdabot>              m a -> Control.Monad.Cont.Cont (m b) a
11:54:58 <mwc> supplied a number to it
11:57:39 <ihope> > 500 `elem` [1..]
11:57:40 <lambdabot> True
11:59:33 <ihope> Has anybody run Graham's number through the Collatz function thingy?
12:14:15 <ihope> You know, if people continue to get more and more bored of using the word "Internet", eventually we'll have things like "webtarnetz0rs"...
12:14:22 <ihope> s/s/z/ :-)
12:15:30 <ihope> > fix (1+) :: Float
12:15:31 <lambdabot> Terminated
12:15:43 <ihope> That was quick.
12:16:39 <liyang> ihope: I already use teh intarweb.
12:17:22 * ihope connects to br0wn.fr33n0d3.n3tz0rz
12:18:28 <liyang> It started off as harmless piss-taking but has become much more prevalent in my vocabulary in recent months. :(
12:32:10 <machack666> Hey, this is probably really easy, but if you have a simple lol [[a]] and you want to define functions to retrieve rows and columns in a point free style, how would you go about doing that?  row :: [[a]] -> Int -> [a] is easy; it's just `row = (!!)'.  I'm having a harder time with getting col :: [[a]] -> Int -> [a] defined point-free.  If I define `col ls i = map (!!i) ls', it works.  How would I define this point-free?
12:32:52 <ihope> @pl col ls i = map (!!i) ls
12:32:53 <lambdabot> col = flip (map . flip (!!))
12:33:10 <machack666> wow, @pl is cool.  Thanks
12:33:11 <ihope> Not as nice as it could be, but there you go...
12:33:32 <machack666> now I just need to try to understand it. :)
12:33:57 <ihope> :-)
12:34:25 <ihope> Well, the flip makes it take its arguments in the wrong order.
12:35:00 <ihope> So first i is run through flip (!!), turning it into (!!i), then it's run through map, to make map (!!i).
12:35:23 <ihope> Then it applies that to ls, producing map (!!i) ls.
12:37:10 <machack666> oh!  I was wondering why there wasn't a flip3 or something to handle more than two arguments, but is it because of how haskell returns functions when partially applied that it works?
12:37:43 <ihope> Well, yeah, I guess.
12:37:49 <ihope> What would the type of flip3 be?
12:38:48 <xerox> 'cos function are curried by default.
12:39:06 <machack666> I hadn't thought that far... I suppose flip3 would be (a -> b -> c -> d) -> (c -> b -> a -> d), but that could be handled with creative interspersings of flips and functions/
12:39:22 <mauke> @djinn (a -> b -> c -> d) -> (c -> b -> a -> d)
12:39:23 <lambdabot> f a b c d = a d c b
12:39:35 <ihope> You beat me to it...
12:39:37 <ihope> @pl f a b c d = a d c b
12:39:37 <lambdabot> f = flip . (flip .) . flip
12:39:53 <xerox> @. pl djinn (a -> b -> c -> d) -> (c -> b -> a -> d)
12:39:53 <lambdabot> f = flip . (flip .) . flip
12:40:03 <mauke> @help .
12:40:03 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>= f
12:40:15 <machack666> you haskell guys are just too damn cool. :)
12:40:30 <ihope> :-)
12:40:57 <machack666> @help djinn
12:40:57 <lambdabot> Generates Haskell code from a type.
12:40:57 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
12:41:11 <jips> "We put the Funk in Funktion"
12:42:04 <dcoutts> Igloo, your alpha ghc build is unregisterised right?
12:50:20 <machack666> should I assume that lambdabot doesn't like @pl'ing with let statements in the body?
12:50:41 <machack666> i.e., it's not possible at that point to points-free represent
12:51:08 <ihope> I think it's always points-free-able.
12:51:13 <ihope> @pl let a = b in a
12:51:14 <lambdabot> b
12:51:29 <machack666> @pl replaceIndex i s e = let (h,t) = splitAt i s in h ++ [e] ++ tail t
12:51:30 <lambdabot> (line 1, column 20):
12:51:30 <lambdabot> unexpected "="
12:51:30 <lambdabot> expecting variable, "(", operator or end of input
12:51:45 <machack666> let me try with braces
12:52:02 <machack666> @pl replaceIndex i s e = let {(h,t) = splitAt i s} in {h ++ [e] ++ tail t}
12:52:02 <lambdabot> (line 1, column 20):
12:52:02 <lambdabot> unexpected "="
12:52:02 <lambdabot> expecting variable, "(", operator or end of input
12:52:08 <ihope> Maybe parentheses.
12:52:21 <ihope> ... = (let (h,t) = ...
12:52:28 <machack666> @pl replaceIndex i s e = let ((h,t) = splitAt i s in h ++ [e] ++ tail t)
12:52:29 <lambdabot> (line 1, column 20):
12:52:29 <lambdabot> unexpected "="
12:52:29 <lambdabot> expecting variable, "(", operator or end of input
12:52:41 <machack666> @pl replaceIndex i s e = (let (h,t) = splitAt i s in h ++ [e] ++ tail t)
12:52:41 <lambdabot> (line 1, column 20):
12:52:41 <lambdabot> unexpected "="
12:52:41 <lambdabot> expecting variable, "(", operator or end of input
12:52:58 <machack666> works in ghci code-wise
12:53:41 <ihope> @pl let collatz x | even x = x `div` 2; collatz x | odd x = 3 * x + 1 in iterate collatz 927598123472957239847
12:53:41 <lambdabot> (line 1, column 15):
12:53:41 <lambdabot> unexpected "|"
12:53:41 <lambdabot> expecting pattern or "="
12:53:48 <ihope> Bleh.
13:02:01 <rizzix> hello rdrake 
13:04:02 * shapr boings
13:04:34 <astrolabe> Hi shapr.  I have a question for you.
13:05:18 <astrolabe> (shapr hides)
13:05:50 <shapr> ask me!
13:06:04 <shapr> Though my brain is especially tired right now.
13:06:51 <astrolabe> Do you find that with largeish haskell programs, you end up carrying around a complicated 'state' structure, either in monads or explicitly?
13:07:11 <shapr> Sometimes, yeah. It depends on the program.
13:07:38 <astrolabe> Thanks.  As long as I know it's not abnormal.
13:08:18 <shapr> Curryspondence ended up being separate programs to parse mbox files and stuff them into a DB, so the DB was my global state.
13:08:52 <astrolabe> That's a thought.  I'll meditate upon it.
13:10:03 <shapr> lambdabot has two chunks of state, read only state that's constant during the runtime (irc server, nickname(s)), and read-write for the plugins.
13:10:22 <SyntaxNinja> Philippa_!
13:10:28 <shapr> Pseudonym used monad transformers for that.
13:11:40 <astrolabe> For both states?
13:11:50 <Philippa_> 'lo SyntaxNinja
13:11:52 <Philippa_> 'sup?
13:12:14 <Philippa_> (I just spent a good couple of minutes cursing loudly at our router for having forgotten it'd given an IP to this machine...)
13:12:21 <Philippa_> (because it started giving it to Damien's lappy instead)
13:13:27 <SimonRC> hmm
13:13:45 <SyntaxNinja> Philippa_: nomuch. 
13:14:15 <SimonRC> Is Haskell supposed to be good at everything, or are there some things it is no good at and is never likely to be good at?
13:14:54 <astrolabe> I seem to have a slight fetish for staying out of monads when I can.  I think I prefer the constriction that pure fp enforces.  Perhaps it's a mistake.
13:15:13 <Cale> well, monads can be pure fp :)
13:15:44 <SimonRC> It's just that I saw this, and wondered if it was possible to do sensibly in Haskell:   http://svn.openttd.org/cgi-bin/trac.cgi/browser/branch
13:15:45 <astrolabe> In theory yeah, but it feels imperitive.
13:15:57 <Philippa_> I like monads largely when they improve my discipline somehow
13:16:03 <SimonRC> I have this nagging feeling it would take up 8 times as much space.
13:16:19 <Philippa_> Reader is in many ways an improvement over threading the parm manually if you're going to stick to that invariant
13:16:22 <Cale> IO and ST are good to steer clear of when you don't really need them
13:16:53 <Philippa_> I'm in two minds about ST - though I'd really /love/ a "heap copy" operation that shifted all my references to the new heap and so forth
13:17:07 <astrolabe> Philippa: How can they improve discipline?  Could you give an example or something?
13:17:09 <Cale> but monads like Maybe, [], State, Reader, just help with existing functional idioms.
13:17:49 <SimonRC> For "threading" situations, I find it best to avoid a monad until you are beginning to get sick of threading your RNG/global value/accumulator around, then just re-write.
13:18:16 <Philippa_> astrolabe: what Cale just said. You have more possibilities with manual threading than with a Reader monad carrying the same piece of data, for example
13:18:21 <SimonRC> BTW, is there a RNG monad planned to put in System.Random?
13:18:31 <Philippa_> so if you mean to stick to the Reader invariants, Reader's more disciplined
13:18:33 <SimonRC> I have to re-invent it occasionally.
13:18:36 <twobitsprite> why doesn't think make sense to me "(>>>) :: abc -> a c d -> a b d"
13:18:46 <Cale> Manual threading can lead to stupid bugs
13:18:47 <twobitsprite> er, s/abc/a b c
13:19:17 <Cale> twobitsprite: a is a two-parameter type constructor
13:19:25 <twobitsprite> Cale: ahh
13:19:38 <Cale> replace it with (->) and what you have is composition (with the parameters flipped)
13:19:48 <SimonRC> yes
13:20:04 <astrolabe> Ah, you're right! like using the threaded state before last (not that I'd ever make that mistake).
13:20:26 <SimonRC> is (->) an arrow/
13:20:27 <SimonRC> ?
13:20:38 <Philippa_> yes
13:20:51 <Philippa_> >>> is just function composition
13:21:02 <Philippa_> I imagine you can fill in the other two operations
13:21:34 <Cale> astrolabe: yeah -- the use of monads can enforce very strict controls on how your threaded state parameter gets used
13:21:47 <Cale> You can even do things like enforce game rules.
13:22:03 <Cale> (if your parameter holds game state)
13:22:56 <astrolabe> ooh.  That's exactly what my parameter holds.
13:24:44 <Cale> have you seen my sudoku solver? It's a state monad with nondeterminism which enforces the rules of sudoku.
13:25:04 <gzl> how does it work?
13:25:18 <astrolabe> I think I saw it, but didn't inwardly digest it.  In TMR?
13:25:23 <Cale> To write the solver in that monad, all I had to do was try to place each of [1..9] in each spot in the grid.
13:25:28 <Cale> Not in TMR
13:25:41 <Cale> http://www.haskell.org/hawiki/SudokuSolver
13:25:44 <astrolabe> Ah, that must have been someone elses :)
13:25:48 <astrolabe> thanks
13:25:56 <gzl> so it's just a brute force approach (with constraints)?
13:26:00 <Cale> gzl: yeah
13:26:06 <gzl> ok.
13:26:25 <Cale> Which is sort of naive, but has the appearance of being even more naive than it is.
13:26:37 <gzl> it's naive but it's more effective than other stuff
13:26:44 <gzl> there are a bunch of techniques that you can easily implement
13:26:50 <gzl> but for hard puzzles they don't work
13:27:05 <gzl> at some stage you have to guess, which basically requires doing this
13:27:14 <Cale> I was thinking about implementing Knuth's algorithm.
13:27:19 <Cale> (Dancing links)
13:28:07 <gzl> I've heard of it but don't know what it does. what's the point? this backtracking brute force thing solves pretty much any puzzle
13:28:15 <Cale> Actually it doesn't.
13:28:19 <gzl> oh, it doesn't?
13:28:28 <astrolabe> Not in reasonable time
13:28:34 <Cale> There are a few nice examples which take bloody ages with backtracking.
13:28:39 <gzl> I see
13:28:58 <gzl> ok. well, good. I guess that makes the problem less boring. :)
13:29:15 <astrolabe> What is knuth's algorithm?
13:29:34 <Cale> http://en.wikipedia.org/wiki/Dancing_Links
13:29:53 <gzl> to solve any puzzle, what methods are generally used?
13:30:07 <Cale> http://en.wikipedia.org/wiki/Algorithm_X
13:30:16 <Cale> (those are related)
13:30:58 <astrolabe> 'any puzzle' is a very general question.
13:31:02 <Cale> Usually puzzles turn out to be either graph theoretic problems, or group theoretic problems
13:31:15 <Philippa_> astrolabe: here, have the halting problem encoded as a puzzle...
13:31:17 <gzl> no no, I mean any Sudoku puzzle.
13:31:24 <gzl> not literally any puzzle
13:31:29 <astrolabe> Ah :)
13:31:47 <Cale> Oh, Algorithm X is probably the best known algorithm for it.
13:32:01 <gzl> oh, and that solves any board?
13:32:37 <Cale> well, really it's a matter of performance, but I think it does very well.
13:32:49 <gzl> ok
13:32:50 <gzl> cool
13:32:56 <gzl> I'll look into that then
13:34:59 <gzl> wow, this is a really recent algorithm
13:35:10 <gzl> I assumed it would be from 1959 or something
13:38:32 <ihope> @wikipedia fixed point theorem
13:38:34 <lambdabot> No Result Found.
13:38:42 <ihope> @help wikipedia
13:38:43 <lambdabot>  @wikipedia <expr>, search wikipedia and show url of first hit
13:44:20 <astrolabe> @wikipedia fixed-point theorem
13:44:22 <lambdabot> No Result Found.
13:44:42 <astrolabe> http://en.wikipedia.org/wiki/Fixed-point_theorem
13:44:56 <astrolabe> a bug?
13:47:07 <ihope> Indeed, Gaim doesn't like notices...
13:59:58 <ihope> Idea: value classes.
14:00:42 <ihope> I have no idea what these would be useful for, nor how to implement them.
14:09:14 <Igloo> dcoutts: alpha build is unregisterised, yes
14:09:45 <dcoutts> Igloo, it looks like there is some support for a regeristerised build
14:09:54 <dcoutts> but the mangler is broken
14:10:05 <dcoutts> and some of the register assignments are suspect
14:10:17 <dcoutts> I was just wondering if you'd ever looked at it
14:11:03 <Igloo> No
14:11:19 <dcoutts> ok
14:11:31 <Igloo> I now have a policy of not turning on registerised compilation for something that isn't being actively tested, too, as it's too much hassle when it breaks for the benefits it gives
14:11:48 <dcoutts> ah, we've got more testers
14:12:28 <Igloo> If you keep the old version around it's less of a problem, anyway
14:12:38 <dcoutts> the old version?
14:12:59 <dcoutts> I've got two helpers looking at the registerised build on alpha
14:15:51 <ihope> Do composites that are hard to factor yield good prime numbers?
14:16:00 <Igloo> When you create 6.4.2, 6.4.1 is still available, right?
14:17:01 <dcoutts> Igloo, both are available, though not parallel installable
14:17:33 <Igloo> Right, so if 6.4.2 is broken you can just go back to 6.4.1 (err, assuming you have binaries of it too)
14:17:42 <dcoutts> Igloo, right
14:17:52 <dcoutts> we have ghc & ghc-bin
14:17:53 <Igloo> Whereas I can't just tell the Debian buildds to do that
14:18:15 <dcoutts> oh
14:20:09 <astrolabe> ihope: good in what sense?
14:20:27 <ihope> astrolabe: more prime than usual :-P
14:22:01 <astrolabe> yes they do.  For instance, 2 is hardly prime at all, it's even for goodness sake!
14:23:16 <ihope> So the bigger the prime number is, the more prime it is? :-P
14:23:36 * ihope stops using that emoticon
14:28:41 <bass> Hi guys, is there a standard function that works like this:
14:28:41 <bass> apply :: Int -> (a->a) -> a -> a
14:28:41 <bass> apply 0 f e = e
14:28:41 <bass> apply n f e = apply (n-1) f (f e)
14:28:41 <bass> So: apply 3 (\x->x+1) 0 ==> 4
14:29:08 <ihope> @index church
14:29:08 <lambdabot> bzzt
14:29:20 <ihope> @hoogle Int -> (a -> a) -> a -> a
14:29:21 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
14:29:21 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
14:29:21 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:29:31 <ihope> @hoogle Integer -> (a -> a) -> a -> a
14:29:32 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
14:29:32 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
14:29:32 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:29:41 <ihope> There doesn't seem to be one.
14:29:58 <bass> indeed
14:30:47 <Lemmih> > iterate (+1) 0 !! 4
14:30:48 <lambdabot> 4
14:34:18 <ihope> :-P
14:34:46 <ihope> @pl \f x n -> iterate f x !! n
14:34:47 <lambdabot> ((!!) .) . iterate
14:34:51 <ihope> Ouch.
14:35:12 <bass> orbitz: apply2 n f e = foldr ($) e $ replicate n f
14:35:26 <orbitz> bass: i refuse
14:35:30 <ihope> So many of them...
14:36:03 <ihope> @pl apply 0 f e = e; apply n f e = apply (n-1) f (f e)
14:36:04 <lambdabot> (line 1, column 16):
14:36:04 <lambdabot> unexpected ";"
14:36:04 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
14:36:28 <ihope> @pl apply n f e = case n of 0 -> e; n -> apply (n-1) f (f e)
14:36:28 <lambdabot> (line 1, column 27):
14:36:28 <lambdabot> unexpected ">" or "-"
14:36:28 <lambdabot> expecting variable, "(", operator or end of input
14:36:33 <ihope> Ooph.
14:37:12 <norpan> you need braces
14:37:59 <ihope> @pl apply n f e = case n of {0 -> e; n -> apply (n-1) f (f e)}
14:38:00 <lambdabot> (line 1, column 25):
14:38:00 <lambdabot> unexpected "{"
14:38:00 <lambdabot> expecting variable, "(", operator or end of input
14:38:14 <ihope> @pl case x y = y x
14:38:15 <lambdabot> case = flip id
14:38:26 <ihope> Apparently @pl doesn't recognize case at all.
14:38:38 <norpan> apparently
14:38:59 <ihope> @pl let apply 0 f e = e; apply n f e = apply (n-1) f (f e) in apply
14:39:00 <lambdabot> join . ((.) .) . ap id (subtract 1)
14:39:10 <ihope> Whoo.
14:39:21 <bass> what does @ pl do?
14:39:34 <ptolomy> points-free-ifies.
14:39:37 <norpan> i guess it stands for pointless
14:39:41 <bass> ok
14:39:43 <ihope> @google points free
14:39:45 <lambdabot> http://www.mypoints.com/
14:39:48 <ihope> Um...
14:41:11 <ihope> @dictionary points-free
14:41:12 <lambdabot> Unknown command, try @listcommands.
14:41:16 <ihope> @dict points-free
14:41:17 <lambdabot> Supported dictionary-lookup commands:
14:41:17 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
14:41:17 <lambdabot> Use "@dict-help [cmd...]" for more.
14:41:25 <ihope> @all-dicts points-free
14:41:26 <lambdabot> No match for "points-free".
14:41:30 <ptolomy> Dang. I was working on a program to deal with directory trees and I thought, "Aha! I'll use haskell, write a function that recurses and finds all files and subdirs, then due to laziness, I'll only check as deep as I actually need!", but it turns out things are too strict. :-/
14:41:48 <ihope> Hmm...
14:42:02 <ihope> <badidea>unsafePerformIO</badidea>
14:42:13 <kosmikus> @all-ditcs point-free
14:42:14 <lambdabot> No match for "point-free".
14:42:26 <jyp> ihope: You mean interleavePerformIO
14:42:46 <ihope> Ah, that's better.
14:42:51 <ptolomy> http://haskell.org/haskellwiki/Haskell/Pointfree
14:43:00 <ihope> (And I think that's unsafeInterleaveIO)
14:43:08 <jyp> true :)
14:43:39 <ihope> unsafePerformAnyMonad
14:44:05 <ihope> That is, Monad m => m a -> a
14:45:02 <ptolomy> This will be my first ever use of an "unsafe". 
14:45:09 <ptolomy> I feel.... somehow different.
14:48:58 <twobitsprite> is there something like @index in ghc(i)?
14:49:19 <twobitsprite> or on the web? so that I don't have to be on IRC to use ? :P
14:50:11 <Lemmih> There's the std lib docs.
14:50:12 <Lemmih> @docs
14:50:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:51:00 <ptolomy> Ooh. The Dark Powers of Unsafe did my bidding.
14:51:04 <twobitsprite> Lemmih: I don't see a search
14:52:23 <TuringTest> Ah....my eyes!  The code pointed to by the mailing list message "[Haskell-cafe] Bit streams programs in Haskell" that just arrived....so painful.
14:52:51 * shapr looks
14:53:07 <TuringTest> No...don't look...at http://bitbenches.infogami.com/
14:53:39 <Lemmih> twobitsprite: Look at the index.
14:53:49 <shapr> TuringTest: Where's the most pain?
14:54:17 <shapr> Huh, this Haskell code looks like Erlang.
14:54:30 <astrolabe> ptolomy: That's how it seems, but you've sold your soul.
14:54:44 <TuringTest> Such as "readarr arr index = unsafePerformIO (readArray arr index)"
14:55:26 <shapr> amazing: do_iter 1 func input = let x = (unsafePerformIO (func input))
14:55:33 <TuringTest> let 'h' = (chr.fromIntegral) (readarr arr 0) in (something that never evaluates it)
14:55:42 <TuringTest> shapr: It is unholy
14:55:50 <shapr> TuringTest: Would you call this idiomatic? ;-)
14:55:52 <TuringTest> They don't quite grok "lazy" or "monad"
14:56:01 <shapr> Yeah, that's a nice way to say it.
14:56:12 <TuringTest> They have invented their own "idioms"
14:56:40 <shapr> heh
14:56:49 <shapr> {-- the do_iter function repeats a function iter times it is not pretty, but it is for me hard to convince haskell to repeat a computation many times also calculates the sum of all channels value to make sure everything is evaluated --}
14:57:19 <TuringTest> The do_iter is not the serious problem.
14:57:31 <TuringTest> They define things in let statements that will do nothing, ever.
14:57:59 <shapr> I'm just amused that they try to force Haskell to repeat the same computation.
14:58:06 <shapr> I think that shows their understanding right there.
14:58:31 <TuringTest> They are always building an accumulator and calling "reverse"
14:58:51 <ptolomy> That code makes me sad inside. Literally, it depresses me.
14:59:21 <TuringTest> They are asking for help.  But I can't read the code without damage.
15:00:50 <ptolomy> It'll take a brave Haskell Priest to exorcise those demons..
15:00:51 <twobitsprite> that code is pretty ugly, and I'm still green as hell with Haskell
15:01:03 <twobitsprite> why not rewrite?
15:01:18 <TuringTest> They don't have an english specification.
15:01:31 <TuringTest> And reading the code is considered harmful.
15:01:47 <twobitsprite> (we are talking about the bitbanches, right?)
15:02:08 <TuringTest> bitbanches ?
15:02:35 <ptolomy> the versions in other languages aren't that helpful either..
15:02:42 <twobitsprite> benches*
15:02:45 <magnus--> Hello.. I have a type system question, I've run into a problem
15:03:24 <twobitsprite> magnus--: ask away
15:03:25 <magnus--> ype Undecorated x = x Undecorated
15:03:26 <magnus--> data BTree decor = Leaf | Branch (decor BTree) (decor BTree)
15:03:53 <twobitsprite> I don't think I understand the first line...
15:04:02 * ptolomy is pretty sure he had the same question a few months ago. I responded by taking a nap.
15:04:21 <magnus--> ype Undecorated x = x Undecorated
15:04:21 <magnus--> data BTree decor = Leaf | Branch (decor BTree) (decor BTree)
15:04:22 <magnus--> ack
15:04:27 <magnus--> sorry for double paste
15:04:29 <twobitsprite> syn?
15:04:34 <magnus--> ype = type
15:04:46 <twobitsprite> you have a hard time selecting the first character, don't you?
15:04:51 <twobitsprite> :P
15:05:06 * twobitsprite always misses the last character... :P
15:05:11 <magnus--> What I want here is to wrap every BTree child with some extra data
15:05:23 <magnus--> some decoration
15:06:21 <magnus--> for example to make child pointers into STRefs I would like to use BTree (STRef s) 
15:06:42 <twobitsprite> what is that first line supposed to do?
15:06:46 <astrolabe>  10What does 'ty01pe Undecorated x = x Undecorated' do?
15:06:52 <astrolabe> heh
15:07:06 <twobitsprite> astrolabe: ack... colors...
15:07:14 <magnus--> Undecorated x is a type that is not decorated in anyway. x Undecorated means the children of x are undecorated
15:07:19 <astrolabe> Sorry, they just happened :)
15:08:00 <magnus--> if we apply BTree to Undecorated, we get Leaf | Branch BTree BTree
15:08:14 <magnus--> (of course this doesn't work in haskell, but this is the idea I want)
15:08:25 <magnus--> in steps
15:08:33 <astrolabe> Ah, I've seen something like that somewhere
15:08:57 <twobitsprite> so... you just want extra type information in your BTree?
15:09:00 <magnus--> BTree Undecorated = Leaf | Branch (Undecorated BTtree) (Undecorated BTree) = Leaf | Branch BTree BTree
15:09:49 <magnus--> Well, not only that
15:10:02 <magnus--> consider Btree Maybe
15:10:16 <magnus--> that would be a Btree where some parts are known and some are not
15:10:37 <magnus--> some children
15:10:57 <twobitsprite> data Undecorated x = Undec x
15:10:57 <twobitsprite> data BTree x = Leaf | Left (BTree x) | Right (BTree x)
15:11:00 <twobitsprite> does that work?
15:11:21 <twobitsprite> (I'm still not sure I understand, but that's at least syntactically correct...)
15:11:32 <magnus--> Here is a partial tree
15:11:33 <magnus--> ype Undecorated x = x Undecorated
15:11:33 <magnus--> data BTree decor = Leaf | Branch (decor BTree) (decor BTree)
15:11:41 <magnus--> gah, wrong paste again :(
15:11:56 <magnus--> type Partial x = Maybe (x Partial)
15:12:14 <twobitsprite> something tells me you're coming from Ocaml?
15:12:27 <twobitsprite> you seem to like to reverse the order of type constructors...
15:12:44 <magnus--> Partial BTree = Maybe (Leaf | Branch (Partial BTree) (Partial BTree)
15:12:45 <magnus--> )
15:12:51 <magnus--> do you see what I mean?
15:13:26 <magnus--> I am reversing them on purpose, I am not following ocaml order
15:14:06 <twobitsprite> er... ok, I think I see
15:14:28 <magnus--> I guess I want to be programming at the type level
15:14:38 <magnus--> to save some typing
15:15:15 <twobitsprite> you want to apply your type variables as functions
15:15:22 <magnus--> yes
15:15:47 <twobitsprite> so that "Maybe Left ..." would work...?
15:16:02 <twobitsprite> (as an expression)
15:16:22 <twobitsprite> i.e. "myBranch = Maybe Left ..."
15:17:21 <twobitsprite> I don't think you can do that...
15:17:29 <magnus--> Okay
15:17:41 <twobitsprite> types aren't first class values, you can't pass them around
15:18:06 <magnus--> Ah... I want first order types
15:18:10 <magnus--> higher order types
15:18:10 <twobitsprite> (that would greatly complicate things, and worst case cenario is that you break type safety)
15:18:41 <magnus--> or first class types
15:18:46 <magnus--> not sure what is correct to say
15:19:29 <twobitsprite> higher-order types would be meta-types... types that operate on types... we kind of have that with classes... first class types would be types that can be passed around like values
15:19:59 <twobitsprite> I'm sure there's a way you can do what you want, but I don't think you're approaching it from the right angle...
15:20:21 <twobitsprite> (I'm not possitive what that angle would be, though... I'm still fairly green to Haskell myself)
15:21:08 <jips> \seen dons 
15:21:09 <lambdabot> dons is in #hac and #haskell. Last spoke 15 hours, 58 minutes and 17 seconds ago.
15:21:19 <magnus--> I'll keep looking for solutions :)
15:21:22 <twobitsprite> I think you might have to define a class of BTrees
15:21:38 <twobitsprite> I'm not sure how exactly, but I would recommend looking into type classes
15:21:53 <twobitsprite> my hacker-sense tells me the solution is to be found there :P
15:22:27 <jips> dons: if you read this: i've tried using simon marlow's readFile', but apparently it also seems to do lazy IO and so i was still experiencing the same trouble. i'll have to think about other solutions. unfortunately, i'm going off the grid now so the next time you see me will be in 7 days, minimum
15:22:35 <twobitsprite> in fact...
15:22:39 * twobitsprite hacks up some ideas
15:22:42 <jips> everyone, please make sure that dons reads that message
15:22:42 <Philippa_> twobitsprite: a higher-order type is just a (sufficiently powerful) type-level function
15:22:45 <jips> night all!
15:23:04 <Philippa_> although the type-of-a-type is commonly called a kind (Haskell has a kinding system, although in haskell 98 you rarely see any evidence of it)
15:25:18 <magnus--> Aha.. that's probably the type error I get when I try to compile my example
15:26:18 <magnus--> (actually some similar code to the example)
15:28:25 <magnus--> I found a name for what I want
15:28:32 <magnus--> first class modules
15:28:39 <magnus--> it can acheive what I want
15:28:46 <magnus--> SML/ocaml have them (functor in SML)
15:28:54 <twobitsprite> magnus--: here:
15:29:01 <twobitsprite> data IBTree a = ILeaf a | ILeft (IBTree a) | IRight (IBTree a) deriving Show
15:29:14 <twobitsprite> *Main> ILeaf (Just 4)
15:29:15 <twobitsprite> ILeaf (Just 4)
15:29:42 <magnus--> I don't have any Left and Right in my BTree, I have Branch
15:29:59 <magnus--> I should call it a Node I guess
15:30:06 <twobitsprite> well... you can change it to branch, but it should still work
15:30:09 <magnus--> Leaf | Node Btree Btree
15:30:38 <magnus--> I think you have misunderstood still
15:30:43 <magnus--> the code you pasted does not do what I want
15:31:16 <magnus--> data BTree a = Leaf a | Node (Btree a) (Btree a)
15:31:34 <magnus--> is a binary tree where the leafs contain something
15:31:39 <magnus--> that's not what I want
15:31:49 <twobitsprite> the leaf can contain a Maybe
15:32:53 <magnus--> I want to have functions from types to types
15:33:13 <magnus--> that can be passed as arguments
15:33:21 <magnus--> to functions from types to types
15:34:38 <twobitsprite> maybe you should look at Qi... rumor has it that it has a turing complete type system
15:35:01 <twobitsprite> but it's kind of a toy language AFAICT... not much in the way of support
15:35:17 <magnus--> yes I probably want to stick to haskell or use SML or ocaml
15:35:38 <magnus--> or give up on types and have fun in lisp
15:35:48 <kosmikus> magnus--: you are aware that there's a paper about first-class modules in Haskell?
15:36:09 <magnus--> kosmikus: I am not
15:36:19 <twobitsprite> well... Haskell's type system is a superset of the ML type system AFAIK... and I don't think what you want is possible in Haskell, at least not the way you want it...
15:36:21 <ihope> @index totient
15:36:22 <lambdabot> bzzt
15:36:40 <twobitsprite> @google "first-class modules" haskell
15:36:40 <magnus--> kosmikus: I'm not
15:36:41 <lambdabot> http://research.microsoft.com/~simonpj/Papers/first-class-modules/index.htm
15:37:03 <kosmikus> that's it. shields and spj
15:37:11 <shapr> Anyone here familiar with Cartesian Product Algorithm type inferencing for OOP languages?
15:37:24 * twobitsprite flexes his google-fu
15:37:42 <ihope> How fast does the lower bound on the totient function grow?
15:37:43 <shapr> I wonder if Agesen's work on CPA has been connected with Boquist's GRIN work?
15:37:56 <magnus--> kosmikus: That looks interesting. Thanks!
15:38:37 <Philippa_> shapr: not seen CPA, got an URL or two?
15:38:57 <magnus--> twobitsprite: It appears that haskells type system is stronger than ML's, but the module system of ML is stronger than Haskell's
15:38:59 <Philippa_> (it /sounds/ like some variant of structural typing...)
15:39:06 <Philippa_> magnus--: pretty much, yeah
15:39:06 <shapr> http://citeseer.ist.psu.edu/agesen95cartesian.html
15:39:14 <shapr> Philippa_: seen your msgs on #khjk?
15:39:16 <Philippa_> Haskell's module system is almost as trivial as is possible
15:39:27 <Philippa_> nope, if you want to catch my attention PM me
15:39:30 <shapr> ok
15:39:32 <Philippa_> *looks*
15:40:13 <ihope> Aww. 3290374821253024315252614692249982158495957 is congruent to 1 modulo 4.
15:40:34 <kosmikus> chance of .25
15:41:48 <twobitsprite> ihope: awefully big number... might I ask the context?
15:41:55 <ihope> Looking at the last digit, that increases to 50%.
15:42:12 <ihope> twobitsprite: it's the biggest prime factor of a "random" number with...
15:42:35 <ihope> ...80 digits.
15:42:37 <lisppaste2> int-e pasted "drop3, naive version" at http://paste.lisp.org/display/18180
15:43:13 * int-e would be curious to see an FPS version of that.
15:44:22 <ihope> Now, 34082896224643790393363263025713473358347566085939067 is congruent to 3 modulo 4.
15:45:44 <astrolabe> Is there a good way of converting an Array to a DiffArray and vice-versa?
15:45:50 <ihope> @index gcd
15:45:51 <lambdabot> Prelude
15:45:55 <ihope> Oh.
15:45:57 <ihope> @type gcd
15:45:58 <lambdabot> forall a. (Integral a) => a -> a -> a
15:46:31 <ihope> Okay, the GCD here is 3456.
15:54:11 <shapr> dcoutts: Is your partial eval work online? If not, are you basing it on hughes' "partial eval based on type inference" at all?
15:54:44 <int-e> shapr: it's just sad that they've discovered unsafePerformIO already. (See the Koan of side effects)
15:54:49 <dcoutts> shapr, no it's not much llike hughes' work, though it's related to types, but in a different way
15:55:02 <shapr> dcoutts: Oh I *really* want to know now.
15:55:09 <shapr> I might could apply it to Python.
15:55:26 <dcoutts> shapr, it's based on a type analysis so I think it'd be hard to do for python
15:55:49 <dcoutts> it works for Haskell progs since they're already HM typed
15:55:59 <dcoutts> the analysis is an extesion of HM
15:56:04 <shapr> Type inferencing works (sort of) for Python using Cartesian product algorithm.
15:56:20 <dcoutts> so for Haskell we can count on everything already being well typed
15:56:22 <twobitsprite> is there a function to see if a number is a whole number?
15:56:34 <shapr> twobitsprite: n == floor n
15:56:41 <dcoutts> shapr, I'd try a more traditional untyped approach
15:57:02 <shapr> ?
15:58:15 * shapr is too sleepy to effectively discuss
15:58:30 <int-e> fromIntegral (floor n) == n   (I don't think (RealFrac a, Integral a) is inhabited)
15:58:33 <shapr> dcoutts: Is your type based peval strategy documented anywhere?
15:58:42 <dcoutts> shapr, not yet
15:58:53 <shapr> Think you'll have anything online soon?
15:59:21 <palomer> grr, g++ compiles slowly
15:59:38 <shapr> kosmikus: You're right, much like TMR articles don't happen without an editor to push people.
15:59:41 <shapr> hiya stepcut 
15:59:51 * stepcut twiddles his thumbs and looks innocent
15:59:54 <ihope> Let's see here...
15:59:55 <shapr> How's life?
16:00:11 <stepcut> good -- still working on trying to come up with something for TMR ;)
16:00:22 <shapr> Well, I think TMR is dead.
16:00:29 <ihope> A new... thing is like a mountain.
16:00:44 <shapr> Maybe I'll eject the last issue soon.
16:00:46 <ihope> A bad tutorial slams you into the side of the mountain, then lets you climb up it.
16:00:46 <stepcut> currently I am trying to understand the LogicT monad transformer
16:00:58 <ihope> A good tutorial turns the mountain into a bunch of little hills.
16:01:10 <shapr> ihope: Good tutorials flatten the whole thing.
16:01:29 <ihope> Well, there'll always be something you don't know.
16:01:47 <ihope> I mean... is there a tutorial out there that will teach me *everything* about Haskell?
16:02:02 * stepcut ponders a tutorial on downhill skiing
16:03:09 <shapr> ihope: Sure, read the #haskell logs for the last five years.
16:03:21 <ihope> Hmm, I guess that'll work.
16:03:35 <ihope> But I'd call that a mountain in and of itself...
16:03:36 <shapr> Speaking of which, 4 years, 47 weeks old, we're nearing our fifth birtday!
16:03:43 <stepcut> nice!
16:03:45 <ihope> Yay!
16:03:50 <ihope> @countdown
16:03:50 <lambdabot> Unknown command, try @listcommands.
16:03:54 <ihope> Me.
16:04:00 <ihope> s/e./eh./
16:04:27 <ihope> Oh, what a disappointing number...
16:12:24 <palomer> >;o
16:17:57 <ihope> ...?
16:29:38 <dons> \yow!
16:29:38 <lambdabot> I feel like I am sharing a ``CORN-DOG'' with NIKITA KHRUSCHEV ...
16:30:17 <ihope> Where are these from?
16:30:20 <ihope> \yow
16:30:20 <lambdabot> America!!  I saw it all!!  Vomiting!  Waving!  JERRY FALWELLING into
16:30:20 <lambdabot> your void tube of UHF oblivion!!  SAFEWAY of the mind ...
16:30:36 <dons> fro the emacs 'zippy' file
16:30:57 <dons> \google zippy openbsd cvs
16:30:59 <lambdabot> http://cvsup.de.openbsd.org/pub/OpenBSD/cvs/ports/www/
16:31:03 <dons> close!
16:35:44 <ihope> Eureka!
16:37:11 <rasterfar> Suppose I have a datatype with many constructors, but all with a common field.
16:37:22 <rasterfar> Using record syntax, is it possible to write something like
16:37:31 <rasterfar> show_p (_ {p=x}) = show x
16:37:39 <rasterfar> Or do I need a seperate case for each constructor?
16:37:44 <dons> nope.
16:37:50 <rasterfar> drat!
16:37:54 <dons> better to structure the type hierarchicahly.
16:38:06 <ihope> show x = show (grabTheField x) -- ?
16:38:13 <dons> data D = D X J  ; data J = A | B | C | D | E ...
16:38:14 <ncalexan> rasterfar: or DrIFT may come in handy.
16:38:20 <dons> so factor out the common field?
16:38:38 <ncalexan> I believe it will give you updates that fail safely if the field DNE.
16:38:58 <ihope> Silly me. I multiplied the totients instead of the primes.
16:39:10 <rasterfar> Okay, thanks for the tips.
16:39:22 <ihope> I was wondering why my product of two large prime numbers was a multiple of 10 :-P
16:40:03 <dons> funny...
16:40:30 <ihope> The "real" product: 384389580515812097899651420799037706626839699098983809646798936319672332437
16:40:37 <rep> http://news.yahoo.com/s/nm/20060322/us_nm/bars_dc
16:41:07 <lisppaste2> magnus pasted "Higher order modules in SML" at http://paste.lisp.org/display/18182
16:41:19 <magnus--> That's my BTree example
16:41:37 <magnus--> twobitsprite: That's what I mean
16:42:02 <magnus--> although it's kinda clunky in SML since I have to use modules to acheive it
16:42:39 <ihope> Indeed, on my computer, that number takes at least 2 minutes to factor :-P
16:44:20 <ihope> Okay. Totient number 1: 2 :-P
16:44:38 <ihope> Erm, wait.
16:45:00 <ihope> #1 is 1, and #2 is 2.
16:45:40 <ihope> This means that 21 is a "good" Blum Blum Shub modulus.
16:45:49 <dons> oh this erlang bit-stream code burns my eyes
16:46:03 <ihope> That is, apart from the fact that it's really tiny...
16:48:35 <ihope> Okay. The totients of 2 and 10 are 1 and 4. So 33 is the next good modulus.
16:49:16 <ihope> 57 is another one...
16:49:55 <ihope> The one after that is 69.
16:51:14 <ihope> Any multiple of 3 that is also a multiple of a prime number that's congruent to 3 modulo 4 is considered good here :-P
16:52:58 <ihope> The totient of 6 is 2 and the totient of 10 is 4, so 77 isn't a "good" one.
16:53:29 <ihope> 93 is.
16:54:39 <ihope> Okay, okay. The smallest "good" number is 9, but that's not very good at all...
16:55:38 <shapr> Is there some way to convert text from a postscript file to html, and the pix as images? The PDF viewer on the Nokia 770 isn't happy with large files.
16:57:10 <dons> I think so. gimme  a sec
16:57:46 <dons> hmm. maybe not. what about converting it to .pdf -- it'll be much smaller
16:58:01 <dons> you can always strip the ascii out, though.
16:58:10 <dons> ps2ascii comes to mind
16:58:22 <shapr> hm, strip the ascii and save only the images as pdf?
16:58:59 <dons> hmm.
16:59:05 <dons> not sure how to get only the images
16:59:10 <dons> ah! what about google..
16:59:18 <dons> it knows how to turn pdf into html
16:59:20 <shapr> I'd like to read research papers on my Nokia 770, but it doesn't handle PostScript at all, and often craps out with PDF.
16:59:22 <dons> now, how does it do that?
16:59:25 <shapr> good question
16:59:42 <Philippa_> badly
16:59:54 <Philippa_> it really, really fucks a lot of stuff up, especially mathematical stuff
17:00:00 <dons> yes. badly. but still..
17:00:01 <ncalexan> http://www.adobe.com/products/acrobat/access_onlinetools.html
17:00:05 <ncalexan> That might help a little.
17:00:43 <ncalexan> But I don't think any conversion is going to deal well with standard LaTeX-y notation.
17:00:45 <shapr> that is handy.
17:02:00 <ncalexan> Does anyone know if there is a 'live' yampa repo?  The last official version is many years old.
17:02:16 <ncalexan> It's hard to tell what's happened to the project.
17:02:32 <shapr> It's still active, somewhat.
17:03:03 <ncalexan> Any idea what kind of activity is happening?
17:03:08 <stepcut> i think the latest publicly released stuff is a couple years old -- unless they have released the GADT version recently
17:03:18 <ncalexan> 2002 :(
17:03:49 <stepcut> ncalexan: maybe that means it has not had any bugs in 4 years?
17:04:14 <ncalexan> Right, that and no packaging changes, bitrot, etc :)
17:38:55 <dons> \seen TuringTest
17:38:56 <lambdabot> I saw TuringTest leaving #haskell and #hac 1 hour, 13 minutes and 58 seconds ago.
18:01:15 <dons> yay, oleg's writing on the wiki now :)
18:02:16 <dons> can I just say that this erlang bit stream code in haskell is really depressing
18:16:37 <int80_h> hi guys :)
18:24:09 <dons> can anyone read OCaml?
18:24:16 <dons> vincenz? 
18:26:13 <dons> no matter. i've inferred the semantics (I hope)
18:29:55 <ihope> @babel es en Â¡Hasta manzana!
18:29:56 <lambdabot>  Â Until apple!
19:42:04 <rasterfar> \yow
19:42:04 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
19:42:04 <lambdabot> legislation..
19:43:23 <rasterfar> \shoot foot
19:43:23 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
20:43:16 <dons> \yow!
20:43:17 <lambdabot> I brought my BOWLING BALL -- and some DRUGS!!
20:45:26 <Korollary> bleh, other languages blow
21:17:57 <dons> quiet today
21:35:11 <akemp> A question about arrows?
21:35:56 <akemp> In the articles about functional reactive programming out of Yale, they talk about how arrows can store state.
21:36:22 <akemp> No real problem with that, but doesn't that take us back to imperative-style programming?
21:38:43 <Korollary> monads can store state too
21:39:39 <akemp> True, but they seem pretty explicit about it.
21:39:51 <Saulzar> State is one of the key points of the FRP stuff
21:40:04 <akemp> The Yampa stuff seemed to capture state in a fairly implicit fashion.
21:40:09 <dons> arrows do it the same way. it's still purely functional.
21:41:06 <akemp> hmmm...  You don't see any similarity?  
21:41:42 <Saulzar> Some problems are much easier with state
21:41:49 <akemp> Absolutely.
21:42:21 <akemp> For example, take the "loop" arrow.
21:42:28 <akemp> Effectively an integrator.
21:42:36 <dons> and instead of threading a state argument around, use a monad or arrow to do the threading for you.
21:42:49 <akemp> The result of "calling" the function is different between "calls".
21:43:18 <akemp> Sugared, the state is invisible.  Just like with an object in OOP.
21:44:15 <akemp> read: "Sugared, the state is invisible to the programmer."
21:46:00 <Saulzar> Maybe, but you expect to be dealing with state when you're dealing with FRP in the same way you'd clearly see what was going on when the type of your function was State Foo  
21:50:05 <akemp> The benefit being that the programmer expectations of State are much reduced?  e.g.  in all OOP languages, everything carries state, whereas in FP only some well-defined things carry state
21:52:24 <Korollary> isnt there an arrow syntax?
21:53:22 <Saulzar> Hmm
21:53:55 <Saulzar> Korollary, Yeah, there's a do-syntax for arrows
21:54:14 <Korollary> so it can't be implicit
21:54:18 <dons> -<- thingies
21:55:46 <akemp> I guess implicit/explicit depends on the frame of reference.
21:56:07 <akemp> I was talking about implicit from the calling function's perspective.
21:56:38 <Korollary> what's the function's type?
21:56:59 <Korollary> are you saying that somehow referential transparency is violated?
21:57:01 <Saulzar> Hmm, but there is no calling function as such unless you're combining the arrow to form another etc.
21:57:51 <dons> yeah, so it's implicit in the way it is in monads. the type still tells you what's going on. and there's no fp rules being broken.
21:57:57 <akemp> Korollary: I know that referential transparency isn't violated in the pure sense, but I'm wondering if it isn't violated from the programmer's perspective.
21:58:25 <dons> the same way it appears to be in an IO function
21:58:27 <Saulzar> Just like you can't do much with a State Foo (except combine it with another State Foo) or  use runState to evaluate the result of the whole stateful computation
22:03:27 <akemp> My questions are derived from a reading of some of the Yampa papers.  "loop" in particular threw me off because it seemed to encapsulate and hide state.
22:04:13 <akemp> I understand that "loop" is technically purely functional, but, from the programmer's perspective, it sure looks OOP.
22:04:26 <dons> OOP? or impure?
22:04:56 <akemp> Not really sure...
22:04:56 <dons> what's the type of 'loop'?
22:05:00 <Saulzar> I've been using Yampa for a while and never needed to use loop manually :)
22:05:51 <akemp> loop :: Arrow a => a (b,d) (c,d) -> a b c
22:07:10 <dons> -- | The 'loop' operator expresses computations in which an output value is
22:07:10 <dons> --   fed back as input, even though the computation occurs only once.
22:07:11 <dons> --   It underlies the @rec@ value recursion construct in arrow notation.
22:09:22 <akemp> Effectively, loop takes an Arrow with two inputs and two outputs and returns an Arrow with one input and one output.  The other I/O is wrapped into a state-like feedback loop.
22:10:12 <dons> I often find it helps to draw these these arrows on paper
22:10:39 <akemp> Assuming that "y <- loop x", two calls of "y" will return different results.
22:11:48 <Korollary> but what is y?
22:13:04 <Korollary> doesngetLine 
22:13:18 <Korollary> doesn't getLine return different results in a similar sense?
22:13:32 <akemp> I understand that "y" has state.  My discomfort comes from the fact that the state is hidden to the programmer, which seems to be one of the failings of OOP and imperative coding.
22:13:57 <dons> yeah, it's like all imperative code modelled with monads or arrows, isn't it?
22:14:15 <dons> they all use hidden state and sequencing to model impurity
22:14:41 <dons> and it's good to feel uncomfrotable :)
22:15:13 <dons> pure haskell is simple and easy, and the bits that model imperative/impure langs should feel icky
22:15:38 <akemp> I guess I feel like monads were necessary.  Arrows, in practice, seem as though they're trying to model an imperative language.
22:15:57 <akemp> dons: amen
22:16:16 <dons> if monads provide general sequencing of computations, arrows provide graphs of computations.
22:16:25 <dons> so they're going to be a bit weirder, scarier
22:17:07 <dons> so sequencing, with parallel streams and loops
22:20:34 <aFlag> On a .lhs file if a line starts with a "#" ghc yields "lexical error". Hugs, in other hand, doesn't complain.
22:20:42 <aFlag> Is that a ghc bug or something?
22:23:36 <dons> if a line starts with a #??
22:23:41 <dons> can you give me an example
22:23:52 <dons> (I suspect you just need to switch on -fglasgow-exts)
22:24:02 <dons> oh, a .lhs file. hmm.
22:24:10 <dons> so it should be a comment?
22:24:32 <aFlag> yes, anything that's not > should be a comment, right?
22:25:04 <akemp> Did you compile with "ghc -cpp"?
22:25:18 <aFlag> i don't think so
22:25:29 <dons> but this is just a comment char, yeah?
22:25:37 <dons> it's not cpp or anything
22:25:51 <dons> yep. i think this might be  a bug
22:26:04 <akemp> "-cpp" runs the c preprocessor.  You'll get a lexical error on things like "#ifdef" otherwise.
22:26:14 <dons> it seems to only happen if the # is the first char of the line
22:26:30 <dons> so I wonder if it is conflicting with the #!/bin/foo handling
22:26:37 <aFlag> There's no -cpp useflag for ghc, so I'm guessing I didn't compile with -cpp, but i could be wrong
22:27:06 <dons> aFlag, I from my testing, I think this might be a bug. Can you post a short (2 line, say?) example on the ghc bug tracker?
22:27:38 <aFlag> sure
22:29:12 <akemp> aFlag: according to the docs, "-cpp" runs the c preprocessor over the source file.  It cured my lexical errors on # signs...
22:29:28 <dons> but it shouldn't be needed.
22:29:45 <dons> a # without -cpp in a lhs file should be a comment
22:30:19 <aFlag> also #define foo "bar" gave the same error
22:31:17 <Smokey`> another Haskell lab over and done with in ~50 minutes. :)
22:32:24 <Smokey`> ugh, #ifdef, tucky.
22:32:26 <Smokey`> yucky*
22:34:22 <aFlag> i've tried #ifdef also, same error
22:58:24 <audreyt> shapr: perl is always strongly typed, so I don't know if "weak typing" even makes sense in a perl context
23:16:11 <aFlag> what's weak typing?
23:20:27 <audreyt> aFlag: (Elephant*)moose;
23:20:39 <audreyt> GHC supports weak typing via unsafeCoerce#
