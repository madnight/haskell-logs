00:00:29 <shapr> CosmicRay: entry1 = blog_template "Oleg's HSXML kicks butt" [p syntaxninja "has been pushing" planethaskell "recently..."] ; syntaxninja = [[a (attr [href (URL "http://blog.syntaxpolice.org/isaac/index.cgi")]) "Isaac Jones"]] ; planethaskell = [[a (attr [href (URL "http://antti-juhani.kaijanaho.fi/planet-haskell/")]) "Planet Haskell"]]
00:01:52 <shapr> Stanislaw Lem died :-(
00:01:58 <goltrpoat> whoa
00:08:54 <shapr> hm, do I work or hack on hsxmlblog?
00:20:07 <sethk> shapr, hack, of course
01:06:02 * shapr snores quietly
01:06:21 * Itkovian slaps shapr
01:06:23 <Itkovian> wake up
01:08:35 * Muad_Dibber kindly picks up shapr and tucks him into #haskell-sleep
01:10:16 * shapr boings
01:29:41 <Itkovian> fixed
01:30:03 <Itkovian> some idiot half pulled out my network cable.
01:30:05 <Itkovian> grmbl.
01:37:26 <sethk> Itkovian, which half?
01:37:58 <Itkovian> the bad half
01:38:33 <Itkovian> some people are putting in new UTP (don't ask why, the exisiting UTP is fine as it is) and they prolly touched my machine ...
01:38:51 <sethk> Itkovian, installing cat6 for gigabit?
01:39:04 <Itkovian> can somebody tell me why one would put UTP where UTP already lies, insted of e.g. putting fiber to the offices with a small switch at the end?
01:39:43 <sethk> Itkovian, people are afraid of fiber, if they've never used it
01:39:53 <sethk> Itkovian, the hardware for fiber is still more expensive than copper
01:39:57 <Itkovian> but we already have fiber between network cabins
01:40:05 <Itkovian> yeah, but the amount of copper is huge
01:40:16 <sethk> Itkovian, I'm not saying it is smart, but it is common
01:40:25 <Itkovian> it's stupid imo.
01:40:39 <Itkovian> some planning idiot prolly decided that it would be best to put in UTP
01:41:24 <sethk> Itkovian, they have done amazing things to make copper perform almost at fiber speeds.  But that really makes sense for using existing wiring, not new wiring
01:41:52 <Itkovian> besides, the old wiring is still in place and will not be removed. duh.
01:42:16 <Itkovian> the difference is: the uni owns the new wires, whereas the old ones were put in by our dept.
01:42:23 <Itkovian> _two_ years ago
01:42:43 <sethk> Itkovian, ah, empire builders.  
01:42:44 <Itkovian> do they rellay think we'll take our wires with us if we ever move buildings?
01:42:55 <sethk> Itkovian, the old Edifice Complex
01:43:14 <sethk> Itkovian, you can pull out the old cable and melt it down and sell it
01:43:44 <Itkovian> har har
01:44:49 <sethk> Itkovian, fiber is popular in africa because people pull down copper and melt it and sell it.
01:54:46 <dcoutts> Lemmih, pong
02:03:12 <shapr> My mother's school had a big budget for computerizing the school, and the idiot company they contracted out to decided to put in fiber from one end to the other end of a 100meter hall, after which the school had no left money for computers. Since then, no one has been able to figure out how to connect ethernet to the fiber.
02:03:53 <shapr> So they continue on with disconnected computers.
02:04:02 <shapr> Dilbert is an understatement.
02:07:01 <dcoutts> shapr, that's a nice story :-)
02:08:22 <shapr> I found out about it when I looked at the thick orange cables on the school ceiling and said "Those look remarkably like fiber, but no one in their right mind would run fiber from one end of this hall to the other."
02:09:31 <shapr> Then my mother told me about the IT department for all the schools county. It consists of two people, one who never comes to work, and the other one is likely to do damage instead of help.
02:10:27 <shapr> The only decent computers in my mother's school are those purchased by the parents of the children and donated to the school so their kids wouldn't be totally without computer literacy.
02:11:08 <shapr> This $100 laptop from MIT would really help out parts of the USA :-)
02:11:28 <sethk> shapr, black box has gadgets that will do it.  but black box is pricey
02:11:58 <shapr> black box?
02:12:40 <shapr> I'd run diskless X terminals from a central server and 100MBit UTP.
02:16:10 <shapr> Anyway, my mother tried to persuade me to move back to the USA and take over the IT department but it hasn't succeeded yet :-)
02:16:16 <shapr> I like programming lots more than hardware.
02:18:20 <sethk> shapr, black box is a company that specializes in interconnecting things which aren't normally connectable
02:18:51 <sethk> shapr, hardware, such as marrying a fiber segment with a copper segment
02:19:10 <sethk> shapr, which I thought has a topic, but it might have been hours ago.  :)
02:20:59 <shapr> sethk: Hardware in my mother's school ends up being operated by the teachers. At this point, anything new would need to be 1. nearly free 2. idiot proff 3. efficient.
02:21:24 <shapr> That's the sort of requirements I get for my website contracts occasionally :-)
02:21:56 <sethk> shapr, the really free part would be an issue  :)
02:34:57 <dons> ?yow!
02:34:58 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
02:34:58 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
02:35:08 <shapr> g'day dns
02:35:13 <shapr> um, dons
02:35:22 <dons> programmatica seems kind of a subliminal project, no? it's so cool, but we hear so little about it
02:35:36 <dons> for exapmle, HaRe 0.3 has been released in january -- but they didn't tell anyone
02:36:07 <shapr> Programatic does lotsa cool stuff.
02:36:46 <dons> but the tools that have come out of it aren't as wide spread as i would have thought they could be
02:36:55 <dons> so i'll add some links to the wiki
02:37:11 <gvdm> pragmattica?
02:37:28 <shapr> Programatica
02:37:35 <gvdm> which is?
02:37:51 <dons> start here: http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
02:37:53 <shapr> It's a collection of tools for Haskell development.
02:37:54 <dons> perhaps
02:38:28 <shapr> It includes an editor, highlighter, dump to pretty html for sources, integration of unit tests, quickcheck, proof assistants, and more.
02:38:50 <dons> so why aren't we all  using it? 
02:39:00 <dons> why don't we all have HaRe installed with our vim and emacs?
02:39:03 <gvdm> dont give me links, busy upgrading to modular xorg, uninstall old one, emacs wont start (wants libxpm), elinks wont start (wants libX11???????????)
02:39:03 <dons> it's a mystery
02:39:17 <shapr> I had trouble using HaRe last time I tried it.
02:39:20 <dons> me too
02:39:21 <dcoutts> because 1) we don't use vim/emacs and 2) it's haskell98
02:39:34 <dons> haskell98, maybe
02:39:40 <gvdm> is haskell98 being replaced?
02:39:41 <shapr> H98 is a big limitation for me.
02:39:52 <dons> me too -- but surely they extend the parser...
02:39:55 <dons> I would
02:40:15 <dons> i mean, @pl does some cool refactorings, but HaRe could be king of the hill
02:40:16 <shapr> I think a parser available via ghc-api would solve a bunch of problems.
02:40:26 <dons> why don't have have a lambdabot haRe plugin?
02:40:36 <dons> why don't the HaRe guys sell their stuff some more?
02:40:41 * dons doesn't know
02:40:47 <gvdm> sell?
02:40:50 <shapr> I dunno. I've tried :-)
02:40:53 <dons> promote
02:41:03 <gvdm> as in market or as in money?
02:41:09 <gvdm> aah
02:41:12 <dons> promote amongst the community
02:41:12 <dons> soo we use it
02:41:19 <gvdm> GPL or similar i taxe it?
02:41:22 <dons> yup
02:41:23 <gvdm> take*
02:41:36 <dons> not sure about programatica
02:41:40 <shapr> For a coupla projects that weren't programatica, I've been actively told that they want to announce stuff themselves. That was in response to offers of TMR articles, etc.
02:43:13 <dons> true. some people like to keep things secret, then dazzle us with v1.0
02:43:17 <gvdm> hey, if you guys dont use vim/emacs what do you use?
02:43:23 <dons> but you build better community support by releasing more often
02:43:30 <shapr> dons: yeah well.
02:43:32 <dons> it's more likely to suceed if people know about it
02:43:59 <dons> there's a lot of group dynamics and psychology involved in open source
02:44:06 <shapr> yup
02:44:47 <dons> anyway, i shall investigate HaRe 0.3 
02:45:07 <chrisbrown> HaRe - who wants to know about it?
02:45:41 <dcoutts> chrisbrown, we were wondering why we're not all using it
02:45:58 <chrisbrown> well you tell me- its available!
02:46:04 <chrisbrown> its only haskell 98 though
02:46:11 <chrisbrown> which might be a reason
02:46:27 <dons> and I write the HWN, and I didn't even know 0.3 is out
02:46:30 <dons> how could this be?
02:46:58 <dons> also, no entry in the 'programming tools' section of haskell.org -- i'm adding one now :)
02:47:12 <dons> and why dont' we have a lambdabot HaRe plugin yet? I want one. :)
02:47:17 <dons> since we already have @pl
02:47:28 <chrisbrown> because i dont have the time
02:48:04 <dons> is the src in darcs?
02:48:10 <chrisbrown> i am the only person working on it now - i agree it could be advertised better
02:48:21 <chrisbrown> you can get the latest release from darcs
02:48:30 <dons> you know @pl?
02:48:32 <dons> @pl \x y z -> f (g x y z)
02:48:32 <lambdabot> ((f .) .) . g
02:48:48 <chrisbrown> http://www.cs.kent.ac.uk/projects/refactor-fp/
02:48:54 <dons> it feels a bit like the bizarro land version of HaRe
02:48:58 <shapr> chrisbrown: Why not use the ghc-api parser?
02:49:09 <dons> @where+ hare http://www.cs.kent.ac.uk/projects/refactor-fp/
02:49:10 <lambdabot> Done.
02:49:11 <shapr> aha - An evaluation of porting HaRe to the GHC API.
02:49:11 <chrisbrown> because i dont have time to finish the port
02:49:37 <chrisbrown> i need to write a thesis - porting to ghc wont get me a thesis
02:49:40 <shapr> chrisbrown: What if we offered you e-beer ;-)
02:49:53 * shapr grins
02:49:54 <chrisbrown> it would take a couple months work
02:50:00 <shapr> Ouch
02:50:02 <dons> chrisbrown, I see lots of community good will towards this project. can I mention the "update 20/01/2006" of HaRe in today's HWN ?
02:50:04 <shapr> What's your thesis about?
02:50:06 <dons> that would be some free advertising
02:50:09 <dons> maybe some patches..
02:50:21 <chrisbrown> dons i would really really appreciate that if could
02:50:25 <chrisbrown> *if you
02:50:26 <dons> ok. good.
02:50:35 <dons> and I will investigate a lambdabot plugin 
02:50:46 <dons> which pretty much makes your project famous instantly if you get a lambdabot plugin
02:50:51 <dons> see hoogle, djinn, pl ...
02:50:53 <chrisbrown> shapr: actually i am doing some expreimentation of ways to make the port easier
02:51:00 <chrisbrown> i.e. hacks
02:51:12 <shapr> Investigatory hacks are great.
02:51:19 <chrisbrown> dons - you can call HaRe from the command line
02:51:28 <chrisbrown> its a bit of a pain though
02:51:37 <shapr> ooh - http://chrisbrown.blog.co.uk/main/
02:51:40 <chrisbrown> you need position information for most refactorings
02:51:50 <chrisbrown> and the ability to answer questions
02:51:57 <dons> hmm.
02:51:59 <chrisbrown> but these are passed as arguments
02:52:07 <dons> so could a simplified String -> String be done?
02:52:11 <chrisbrown> it would also require programatica
02:52:12 <dons> i.e. like @pl
02:52:40 <chrisbrown> you could write a wrapper - its String -> IO() at the moment
02:52:41 <shapr> Aren't refactorings AST transformations?
02:52:46 <chrisbrown> yes
02:53:03 <shapr> So, why is position info needed?
02:53:18 <shapr> maybe for the UI?
02:53:26 <dons> right, so what I'd like is some simple way to feed a string representing an expression into HaRe, getting some kind of useful answer out -- that could be lambdabot-able
02:53:38 <chrisbrown> because - you dont want all your code layout to be replaced with a pretty prited version of your code everytime you refactor something
02:53:44 <shapr> You don't?
02:53:48 <chrisbrown> no
02:53:52 <dons> I can imagine you don't :)
02:53:59 <chrisbrown> there is no standard layout for haskell
02:54:09 <chrisbrown> everyone has a unique style
02:54:16 <shapr> Most refactoring browsers let you customize your pretty printer options for your own style.
02:54:34 <shapr> Heck I thought that was a feature =)
02:54:55 <chrisbrown> well, this way you dont have to
02:55:05 <dons> we're all hippies in this haskell world. "No rules, man!"
02:55:16 <chrisbrown> also there has been work done in analysing styles and it is not easy for Haskell
02:55:27 <shapr> Oh, didn't know that.
02:55:50 <dons> chrisbrown, ok, added HaRe to http://haskell.org/haskellwiki/Libraries_and_tools/Program_development
02:55:55 <dons> maybe you know of other tools?
02:56:34 <chrisbrown> dons - some of them are far from small
02:56:58 <dons> ?
02:57:01 <chrisbrown> actually the whole HaRe site is out of date
02:57:05 <dons> you referring to the text?
02:57:10 <dons> ah, yes, I just tooks it from there...
02:57:14 <chrisbrown> sorry - yeah! :) 
02:57:17 <dons> I thought 'small' sounded odd
02:57:23 <chrisbrown> heh
02:57:24 <dons> since i've actually built HaRe a few times..
02:57:37 <dons> seem to recall something about a lexer that ghc almost dies on
02:57:44 <chrisbrown> possibly take out the word "small"
02:57:46 <shapr> chrisbrown: nifty blog.
02:57:54 <dons> oh, a haskell blog?
02:57:56 <chrisbrown> shapr: thanks
02:58:19 <chrisbrown> dons: so you have actually used HaRe??
02:58:21 <chrisbrown> wow
02:58:26 <chrisbrown> what do you think of it?
02:58:34 <dons> yeah. i wanted to write a lambdabot plugin last year
02:58:41 <shapr> I'd still like to stick with the original refactoring browser ideas, that transformations are only correct when your test suite passes.
02:58:50 * shapr is old and inflexible.
02:59:14 <shapr> On the other hand, I think I have good reasons for that.
02:59:17 <dons> but got frustrated with the giant lexer that ghc almost dies on. I was going to submit the lexer from ghc. But I will look at the current state of the src and give you some feed back, if you like.
02:59:26 <chrisbrown> shapr: but that only prooves the refactoring is correct for those test cases. Huiqing Li wrlote her thesis in formalising and prooving refactorings
02:59:49 <shapr> Yeah, but those test cases *are* the meaning.
02:59:51 <chrisbrown> HsLex takes a wihle to complie
03:00:02 <dons> since i've been using lambdabot's @pl from vim i'm getting the refactoring bug.
03:00:11 <dons> the _automatic_ refactoring bug
03:00:27 <dons> chrisbrown, so why not use one of the standard lexers generated with alex?
03:00:45 <dons> the one from ghc is easy to rip out, and will produce a very fast lexer
03:00:56 <shapr> A refactoring is a source code change that does not change the *meaning* of the code. Obviously changing code has to change something. But you perceive with the programmer's definition of meaning via the unit tests.
03:01:02 <shapr> It's like another view of domain specific languages.
03:01:20 <chrisbrown> because we use programatica - and i suppose just concentrating on writing refactorings rather than the engineering. plus im the only guy working on it now - and the system is already in place
03:01:29 <shapr> chrisbrown: Do I sound like a new age airhead? ;-)
03:01:43 <ibid> http://planet.haskell.org/ ought to work now
03:01:54 <chrisbrown> you can proove a program's behaviour using induction
03:01:56 <dcoutts> shapr, man what a pardigm shift!
03:02:12 <shapr> dcoutts: Did you understand what I said?
03:02:27 <shapr> chrisbrown: Behaviour is defined by the guy who pays you!
03:02:32 <chrisbrown> hahaha
03:02:38 <chrisbrown> true
03:02:47 <dcoutts> shapr, I think I was following the new age airhead line of thinking...
03:02:55 <chrisbrown> well if anybody here wants to help me hack HaRe to GHC.....
03:02:58 <shapr> dcoutts: spiffy =) what do you think?
03:03:05 <dons> chrisbrown, i fixed the HaRe blurb on the wiki.  I'll mentoin HaRe in the HWN coming out tonight, and have a look at intergration with lambdabot.
03:03:19 <dons> chrisbrown, you might want to ask Lemmih
03:03:24 <chrisbrown> dons: how does the lambda bot work?
03:03:32 <dcoutts> shapr, not sure about the DSLs bits
03:03:42 <shapr> Anyway, the client has certain needs, high level tests check that those needs continue to be fulfilled by the code.
03:03:47 <dons> he's been doing lots of stuff with ghc-api and hIDE. type checking buffers, syntax highlighting.
03:03:50 <chrisbrown> the obvious way would be to just map the GHC AST over the Programatica AST presevring our API and refactorings
03:03:52 <dons> how does lambdabot work?
03:03:57 <shapr> So that's really what behaviour-preserving means in terms of refactoring.
03:04:00 <chrisbrown> but then still, haskell 98 :(
03:04:15 <chrisbrown> but everyone should be using haskell 98 anyway!
03:04:18 <shapr> dcoutts: 'program at the level of the problem'
03:04:27 <dons> then why not extend the lexer and parser? or does it need much more than that?
03:04:28 <dcoutts> shapr, ah ok, in that sense
03:04:47 <shapr> dcoutts: The most efficient solution to any problem would be to write a DSL at the problem level, and then code the solution in that DSL.
03:04:57 <dons> there's hsx, nibros extended h98 parser/lexer library, for example
03:05:09 <chrisbrown> dons: i want to move away from Programatica - i am implementing lots of refactorings based on type information and the type checker in Programatica is too slow
03:05:09 <dcoutts> shapr, ideally yes.
03:05:24 <dons> ah, so you need type information. didn't know that.
03:05:30 <dons> then ghc-api would be an option
03:05:34 <chrisbrown> yep
03:05:48 <dons> interesting. especially once ghc-apii comes preinstalled with ghc 6.6
03:05:55 <chrisbrown> my solution is to have GHC and Programatica! and map the GHC type information onto the Programatica AST
03:05:57 <shapr> Obviously changes to the DSL implementation should not affect the behaviour of the language. That's the connection.
03:06:22 <dons> right. sounds doable. then i'd only need ghc-api, and your refactoring magic code
03:06:26 <dons> no extra dependencies?
03:06:59 <chrisbrown> you would still need programatica
03:07:19 <chrisbrown> unless I can find an easy way to merge the layout info
03:07:27 <dons> ah right.
03:07:46 <chrisbrown> ghc seems to use multiple levels
03:07:58 <chrisbrown> where Programatica just stores everything in the AST
03:08:21 <chrisbrown> it would also mean we would have to get Strafunski working over GHC
03:08:29 <chrisbrown> oh and boxed and unboxed types
03:08:38 <chrisbrown> and other messy stuff im sure i could think of
03:09:58 <chrisbrown> to be honest i wish i could start from scratch with it all *sigh*
03:12:09 <dons> :)
03:12:30 <chrisbrown> or have another year
03:12:49 <dons> well, i'll have a look at the code -- i've still got another year.
03:12:50 <dons> or at least till the end of this year :S
03:13:08 <chrisbrown> dons: much appreciated :):)
03:13:23 <dons> i'd really like to say HaRe widely used, and easilyy installed
03:13:55 <dons> ibid, should i change the tags in HWN so they look better in planethaskell? or did you work around my formatting?/
03:15:43 <chrisbrown> Lemmih: you are using ghc-api for hIDE - do you have any documentation for it? 
03:19:42 <pierre-> hello. 
03:23:24 <chrisbrown> dons: how do I go about making a lambdabot plugin? is there any documentation?
03:24:53 <chrisbrown> @version
03:24:54 <lambdabot> lambdabot 3p368, GHC 6.4.1 (Linux i686 3.20GHz)
03:24:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:25:00 <chrisbrown> hmmm :)
03:25:17 <chrisbrown> oh interesting it has Jose Proenca's point free refactoring
03:31:29 <dons> you just look at the other plugins in Plugin/s/
03:31:58 <chrisbrown> ok im just getting it from darcs at the mo
03:32:10 <chrisbrown> the problem is is that HaRe requires a source file
03:32:45 <chrisbrown> unless i can write a script to take the input to lambda bot and convert it into a source file
03:33:00 <dons> yep. that's doable. 
03:33:13 <chrisbrown> it also requires position information
03:33:18 <chrisbrown> which could be tricky
03:33:26 <dons> or let HaRe read from stdin
03:33:26 <dons> would be better
03:33:35 <chrisbrown> that would be
03:33:39 <chrisbrown> hmm
03:33:59 <dons> the @eval plugin writes expresions into a temp file
03:34:09 <dons> @eval map (+1) [1..10]
03:34:10 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
03:34:18 <chrisbrown> ok
03:34:28 <dons> other than that, you just provvvide an instance of 'Module' in your plugin
03:35:04 <chrisbrown> i'll have a play
03:36:07 <chrisbrown> dons: out of interest - what area are you working on?
03:38:42 <dons> type safe dynamic linking
03:38:48 <dons> www.cse.unsw.edu.au/~dons
03:39:01 <dons> have a look at the Hello plugin for the very basics you need for a new plugin
03:39:13 <chrisbrown> oh you wrote hsplugins!
03:39:19 <dons> to call external programs, you can use Plugs as your example
03:39:33 <dons> yep :)
03:39:33 <chrisbrown> ok
03:39:40 <chrisbrown> coolness
03:40:29 <dons> however, if you can just provide some sort of stdin/stdout interface to HaRe, i can write the lambdabot plugin :)
03:41:13 <dons> though writing a lambdabot plugin is good for your @karma :)
03:41:21 <chrisbrown> the problem with HaRe is it requires a new programatica project
03:42:48 <chrisbrown> i could write a simple script that lambdabot could call - then the script calls HaRe?
03:44:19 <dons> well, could not lambdabot call HaRe directly?
03:44:27 <dons> (a script is fine, but keeping it all in haskell is better)
03:44:50 <dons> how would the script work?
03:46:25 <chrisbrown> the problem is this:
03:47:34 <chrisbrown> programatica needs to set up a new project containing the module to refactor, HaRe then calls the programatica parser. So it would need a module to be created and the programatica to be called to set a new project and to chase imports. Then the refactoring would be called.
03:48:18 <chrisbrown> and the refactorer modifies the module
03:48:26 <dons> right. so kind of heavy weight..
03:48:31 <chrisbrown> yeah :(
03:48:39 <dons> or could it be scripted and run quite quickly?
03:49:06 <dons> especially if the 'module' is just an expression with some stub wrapper code.
03:49:30 <dons> hmm. could we build our own AST and pass it directly into HaRe?
03:49:32 <chrisbrown> well, i was thinking to write a script to take the input from lambdabot - plonking it into a module - giving that to HaRe - and then taking what we need from the file and returning that to lambdabot
03:49:34 <dons> into thhe refactoring rules.
03:49:47 <dons> right. 
03:49:54 <dons> that's how I'd start, too.
03:49:57 <chrisbrown> ah hold on perhaps.
03:50:18 <chrisbrown> each refactoring calls the API function to parse a file - i could modify that to take an AST instead
03:50:43 <chrisbrown> but it would still require programatica - and it would still require a module somewhere...
03:51:09 <dons> say we have a rule that only a single expression can be entered. we could build an AST out of that (for n EXP type) and wrap it in some boilerplate module AST code. Program [Decl (Ident "x") (Expr ..)]. 
03:51:28 <chrisbrown> ok.....
03:51:52 <dons> so we just use the library parser to parse the expression for us. then we'd only need HaRe and the AST type it accepts?
03:52:13 <chrisbrown> just thinking....
03:52:33 <chrisbrown> HaRe itself doesn't care about programatica. it only cares about the AST, and tranforms the AST
03:52:48 <chrisbrown> how it gets the AST is irrelevent
03:52:51 <dons> right. so we only need to build something of type AST. 
03:53:08 <chrisbrown> so i suppose we could just wrap up an expression into a simple programatica AST and pass that in
03:53:17 <dons> yeah. 
03:53:32 <chrisbrown> i would need to modify HaRe to do this - a special instance just for lambdabot
03:53:53 <dons> right, some flag to accept a Read'able expression on the command line
03:54:03 <dons> or a Readable AST on stdin
03:54:42 <chrisbrown> would HaRe live on a server somwhere for lambdabot?
03:54:52 <dons> yep. on the same box
03:55:14 <dons> as does hoogle, ghci and djinn
03:55:26 <chrisbrown> so it would be preferable to have an optional flag - that way way when new release come out it would be easy to add to the serever
03:56:06 <dons> yep. say -e means HaRe reads an expression on stdin?
03:56:29 <dons> then lambdabot could invoke HaRe directly
03:56:36 <chrisbrown> ok...
03:56:59 <ibid> dons: i think i'll figure something out with css
03:57:04 <chrisbrown> so with the -e hare becomes.... HaRe :: String -> String
03:57:15 <dons> String -> IO String, yeah
03:57:26 <chrisbrown> i.e refactoring " f x = 45"
03:57:28 <chrisbrown> -e
03:57:33 <chrisbrown> ok
03:57:41 <chrisbrown> but it would still need some position information
03:58:01 <dons> yeah, you can place constraints on the format of the data on stdin
03:58:12 <dcoutts> dons, how much ram does your mips box have? We think our trouble may be related to the fact that the mips ghc binary is 48Mb and the mips box only has 64Mb total :-)
03:58:20 <dons> it might need to be in some form with all the info HaRe needs
03:58:29 <chrisbrown> it also requires that the positions match up with the positions of the tokens
03:58:34 <dons> oh, my misp64 has 8G i think
03:58:41 <chrisbrown> so the boilerplate code would require to add position info
03:58:52 <dons> ok. stil seems doable
03:58:55 <dcoutts> dons, wow! ok I see.
03:59:12 <dons> it's a dual r10k I think.
03:59:22 <dcoutts> nice
03:59:48 <dcoutts> my mips chap has a single 4k @100Mhz with 64Mb ram :-)
04:00:57 <dons> chrisbrown, so what do you think? can we get a direct feed into HaRe this way?
04:04:00 * dons darcs gets HaRe to see
04:08:33 <chrisbrown> dons: thinking about it - im not sure what the point would be in refactoring a single declaration
04:08:44 <chrisbrown> most refactorings work over modules, and it would be almost faster to write out the expression again rather than calling HaRe with all the information it needs to do the refactoring
04:08:48 <dons> there's nothing fun that can be done?
04:09:56 <chrisbrown> dons: we can certainly try
04:10:06 <dons> does it simplify expressions at all?
04:10:12 <chrisbrown> in some cases
04:10:22 <dons> removing redundant args, replacing some code with shorter library functions?
04:10:35 <dons> those kind of changes seem to work well with @pl
04:10:42 <chrisbrown> i have wrote some program slicing stuff, and there is a refactoring to remove redundant declarations
04:10:45 <dons> @pl \x y -> compare (f x) (f y)
04:10:45 <lambdabot> (. f) . compare . f
04:11:01 <dons> @pl \f xs -> xs >>= return . f
04:11:02 <lambdabot> fmap
04:11:14 <chrisbrown> what is pl?
04:11:16 <dons> some of these I wouldn't do by hand. I neeed @pl to do it.
04:11:24 <dons> it's a pointfree refactoring plugin
04:11:26 <chrisbrown> ah
04:11:32 <dons> @pl \(a,b) -> (f a, g b)
04:11:33 <lambdabot> f *** g
04:11:38 <chrisbrown> yeah Jose wrote that i believe
04:12:05 <dons> not sure. Thomas Yaeger wrote the plugin and all its code.
04:12:13 <dons> but maybe he use Jose's work as a model?
04:12:25 <chrisbrown> i know Jose came to us about a year ago to work on that
04:12:26 <dons> TheHunter, did you know about this work of Jose's?
04:12:49 <dons> oh, we've had @pl for a couple of years now
04:12:55 <chrisbrown> ah
04:12:59 <dons> I'm pretty sure Thomas just hacked it up.
04:13:00 <chrisbrown> possibly not his work then
04:13:12 <chrisbrown> but there is a similar refactoring in HaRe
04:13:14 <dons> @pl \f g (a,b) -> (f a, g b)
04:13:15 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
04:13:38 <dons> so here we just feed in expressions and it does fun things with them.
04:13:48 <dons> so I often wondered if HaRe could do a better job
04:13:57 <dons> or do different things
04:14:00 <chrisbrown> well it can but it also needs other information
04:16:02 <dons> ok, could it work over this limited interface of irc? if lambdabot adds or rediscovers any extra info ? or does the user need to interactively try things?
04:16:42 <dons> @pl \h f g x -> f x `h` g x
04:16:42 <lambdabot> liftM2
04:16:48 <dons> @pl \f a b c d -> f b c d a
04:16:48 <lambdabot> flip . ((flip . (flip .)) .)
04:16:59 <dons> sometimes it does a good job, sometimes not
04:17:03 <chrisbrown> usually what happens is the user selects a particular expression or places the cursor somewhere and calls the refactoring, and under the hood HaRe calls the refactoring with the position information and any other information such as new variable names
04:17:57 <dons> ok. so that sounds like we could have defaults for things like variable names, and some kind of dummy position information?
04:18:40 <chrisbrown> dummy position information? 
04:18:41 <dons> with the selected expression fed on stdin. and maybe the extra info supplied on the command line, or say, the first line of stdin.
04:18:56 <dons> could defaults be chose for the position informattoin, (0,0) or something?
04:19:23 <dons> such that generating this extra info HaRe needs is easy.
04:20:13 <chrisbrown> some refactorings require that you highlight subexpressions or place the cursor over a particular part of the expression
04:21:38 <chrisbrown> @version
04:21:39 <lambdabot> lambdabot 3p368, GHC 6.4.1 (Linux i686 3.20GHz)
04:21:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:22:08 <dons> ok. could those kind of refactorings be disabled? or could the user specify the highlighted bits somehow: f x = _e_ <-- ascii highlighting. then lambdabot could work out the position info?
04:22:23 <chrisbrown> yes that would work
04:22:27 <chrisbrown> good idea
04:22:39 <chrisbrown> also
04:23:09 <chrisbrown> some refactorings require a (Row, Col) where others require (start, end) where start = (row, col) and end = (row, col)
04:24:36 <dons> ok. so could those be faked? i.e. always (0,0) ? or is that meaningless?
04:24:46 <chrisbrown> so some might have f x = _1 + 2_ + 2
04:24:54 <dons> yeah
04:26:04 <chrisbrown> well the script that we are using could work that out - iit could have a list of the refacorings that only require a (row, col) and a list that require (start, end)
04:26:16 <dons> right.
04:26:18 * vincenz hates people that ask for homework help
04:26:56 <vincenz> well in the sense of "this is problem description, please help"
04:27:02 <vincenz> where it's just a copy paste..
04:27:22 <Muad_Dibber> indeed
04:27:27 <Muad_Dibber> asking for help is good though.
04:27:29 <dons> vincenz :) yeah. it's midsession time!
04:27:36 <chrisbrown> i hate it when they say "here is the code [insert huge haskell program] what is wrong with it?"
04:27:45 <vincenz> if anyone saw the haskell cafe one...where cale answered
04:27:51 <vincenz> I mean that was a literal copy and paste
04:28:19 <vincenz> it even ended with "Using this definition, test your program with the factorial program."
04:28:46 <chrisbrown> dons: now i have lambdabot from darcs i need to build it following the intructions in the README?
04:28:50 <Muad_Dibber> lol
04:28:51 <vincenz> chrisbrown: the one cale answered to was even funnier
04:29:00 <chrisbrown> vincenz: yeah?
04:29:01 <vincenz> chrisbrown: it was a copy paste (or typed in) version of the assignment page
04:29:05 <chrisbrown> haha
04:29:07 <vincenz> here is simple .. datatype
04:29:14 <vincenz> here is a factiorial in simple program language
04:29:14 <chrisbrown> and was he teaching that assignment?
04:29:16 <vincenz> a()...
04:29:17 <vincenz> (b)...
04:29:18 <dons> chrisbrown, yep. install fps, then build it with : autoconf ; ./configure ; make
04:29:18 <vincenz> (c)...
04:29:19 <vincenz> (d)...
04:29:23 <vincenz> Using this definition, test your program with the factorial program.
04:29:24 <chrisbrown> dons: ok
04:29:48 <dons> chrisbrown, then ./lambdabot willl give you a prompt where you can type in your lambdabot commands
04:29:53 <chrisbrown> ok
04:29:54 <vincenz> http://www.nabble.com/The-simple-programming-language%2C-t1344638.html#a3596582
04:30:00 <dons> $ ./lambdabot 
04:30:00 <dons> lambdabot> botsnack
04:30:01 <dons> :)
04:30:24 <chrisbrown> vincenz: i saw that
04:30:39 <dons> to add a plugin, just stick your module in Plugins/ and add its name to the list in config.mk
04:30:54 <vincenz> dons: and recompile?
04:31:01 <dons> that's a good idea
04:31:25 <chrisbrown> dons: i'll play around...i mainly just want to see the kind of interface i need to create the HaRe wrapper
04:31:36 <dons> yep. ok.
04:31:57 <dons> let me know any problems, or if you're stuck :)
04:32:05 <chrisbrown> ok - cheers
04:32:07 <dons> i'm happy to do the lambdabot side of things if needed
04:32:23 <chrisbrown> i'll probably ask for your help when it comes to that
04:32:49 <chrisbrown> what is runhaskell?
04:32:58 <chrisbrown> ghc?
04:33:14 <dons> runhaskell is runghc if you have it.
04:33:22 <dons> or you can just compile setup.hs as normal
04:33:25 <dons> and invoke ./setup
04:33:30 <dons> (you don't use Cabal?)
04:33:57 <chrisbrown> whats Cabal? lol
04:34:38 <dons> you kent guys live in a weird universe :P
04:34:46 <chrisbrown> we must!
04:35:21 <vincenz> yeah...it's called britain
04:35:26 <chrisbrown> lol
04:35:47 <vincenz> pounds, ounces, inces, pounds again (iso euros)
04:35:52 <vincenz> and they call themselves europeans
04:36:01 <chrisbrown> ah - we have metres and kilograms now
04:36:14 <vincenz> aha :)
04:36:22 <chrisbrown> catching up
04:36:22 <vincenz> but how many people actually use it instead of stones ?
04:36:29 <chrisbrown> no one
04:36:34 <dons> hehe
04:36:37 <chrisbrown> i dont know my weight in kilograms
04:36:38 <Muad_Dibber> vincenz, the question is not whether they call themselves europeans...but whether *WE* call them europeans ;)
04:36:46 <vincenz> chrisbrown: I didn't know what a stone was until recently
04:36:51 <chrisbrown> haha
04:36:54 <chrisbrown> really?
04:36:55 <vincenz> Muad_Dibber: inderdaad
04:36:57 <vincenz> chrisbrown: yeah
04:37:00 <chrisbrown> we use miles too
04:37:07 <vincenz> I knew pounds and ounces (went to the US during highschool)...but stones..
04:37:21 <vincenz> when I heard about it I thought about stone age people
04:37:24 <Muad_Dibber> i know a stone is something i can smash your window with..I would have no idea the amount of kilogram a stone weights :P
04:37:34 <chrisbrown> i dont either
04:37:38 <dons> my parents still use stones. but .au switched 40 years ago..
04:37:38 <vincenz> Muad_Dibber: it doesn't
04:37:43 <vincenz> Muad_Dibber: nothing weighs a kilogram
04:37:55 <dons> good to see the uk is catching up with the colonies ;)
04:37:58 <vincenz> that's impossible
04:38:01 <vincenz> you weigh in newtons
04:38:08 <Muad_Dibber> you get what i mean.
04:38:12 <vincenz> :D
04:38:31 <vincenz> chrisbrown: so what si your gravitational constant when you do math?
04:38:37 <vincenz> stones*m/s/s?
04:38:46 <chrisbrown> kilograms
04:38:48 <chrisbrown> i think
04:39:11 <vincenz> it's even funner in the US
04:39:17 <vincenz> there you have ounces, and liquid ounces
04:39:32 <ValarQ> liquid ounces?
04:39:35 <vincenz> one is mass, the other is volume
04:39:39 <vincenz> afaik
04:39:45 <ValarQ> oh, ok
04:39:50 <dons> ok, night chris and others! chris, feel free to darcs send patches to lambdabot too :)
04:39:56 <vincenz> dons: bye
04:40:03 <chrisbrown> dons: thanks
04:40:12 <chrisbrown> good night
04:47:08 * chrisbrown remembers that he has to mark Java assignments :(
04:47:43 <Lemmih> chrisbrown: (re documentation for ghc-api) Nope.
04:48:03 <chrisbrown> Lemmih: have you managed to use it for anything?
04:50:18 <Lemmih> chrisbrown: Yeah, I've just rewritten the core of hIDE and I wrote a whole-project dead code analyzer some time ago.
04:50:33 <chrisbrown> how does it deal with layout information?
04:52:11 <chrisbrown> Lemmih: im interested in porting HaRe to using GHC
04:55:29 <Lemmih> chrisbrown: Layout information? The lexer manages a list of layout contexts.
04:58:07 <Lemmih> Isn't HaRe only intersted in the renamed syntax?
05:12:08 <vincenz> @hoogle slurp
05:12:09 <lambdabot> No matches found
05:12:21 <vincenz> que hace slurp?
05:13:32 <Lemmih> slurp from drop3 etc?
05:13:44 <vincenz> yeah
05:14:29 <Lemmih> It's defined at the bottom of the file.
05:14:39 <vincenz> what is unsafeFreeze?
05:17:27 <Lemmih> It returns an immutable interface to a mutable array.
05:18:02 <vincenz> why is it unsafe?
05:18:53 <Lemmih> Because it doesn't copy the array. If you change the mutable array then the immutable will also change.
05:22:28 <vincenz> h
05:22:29 <vincenz> ah
05:22:30 * vincenz nods
05:22:34 <vincenz> thx
05:22:48 <vincenz> couldn't they do it differrent
05:22:58 <vincenz> in a way that makes it impossible to get the mutable array
05:23:01 <vincenz> so it's no logner unsafe
05:23:10 <vincenz> cause in a way this feels less unsafe than other unsafe stuff
05:23:38 <vincenz> withBuffer (...allow modification) -> returns buffer that's non modifiable
05:24:27 <Lemmih> Huh?
05:25:35 <vincenz> withBuffer :: (ModifiableBuffer -> Nonstateful code) -> NonModifiableBuffer
05:26:04 <vincenz> aka...the modifiable buffer can't escape the context
05:26:21 <dcoutts> vincenz, I've wondered about the opposite occasionally
05:26:45 <vincenz> dcoutts: ?
05:26:49 <Lemmih> Hi dcoutts.
05:27:04 <dcoutts> vincenz, eg for a mutable buffer (like the GtkTextBuffer) taking a static snapshot and allowing people to use pure query functions on the snapshot
05:27:08 <dcoutts> hia Lemmih
05:27:14 <dcoutts> Lemmih, you pinged me earlier
05:27:43 <vincenz> dcoutts: seems rather trivial, just don't allow them the IO monad
05:27:54 <dcoutts> vincenz, but to avoid making a copy we'd use a withBuffer style thing
05:28:04 <ihope> @hoogle Int# -> Int
05:28:04 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Int'
05:28:37 <dcoutts> vincenz, but we can't have pure query functions on the buffer ordinarily because they wouldn't be safe
05:29:11 <dcoutts> we can have them on a safe snapshot and use a different type to guarentee they're only used on the snapshot
05:30:11 <dcoutts> withBufferSnapshot :: TextBuffer -> (TextBufferSnapshot -> a) -> IO a
05:30:33 <dcoutts> and then profide pure query functions :: TextBufferSnapshot -> foo
05:30:41 <vincenz> oh right
05:30:45 <vincenz> good point
05:31:04 <dcoutts> it's the dual of what you were suggestign (I think (?))
05:31:07 <ihope> So there's nothing a person can do with a RealWorld and no way to get it?
05:31:08 <vincenz> dcoutts: yep
05:31:10 <Lemmih> dcoutts: Yeah, I thinking about how to manage plugins in hIDE. Using Cabal is a mess if plugins can depend on each other or if we want to install&reload them on the fly.
05:31:37 <dcoutts> Lemmih, what makes Cabal a mess for this?
05:33:29 <vincenz> woo
05:33:34 <vincenz> vincenz@abstractserver:/home/music/Sorted$ mpg123 -Z `find . `
05:33:34 <vincenz> bash: /usr/bin/mpg123: Argument list too long
05:33:44 <vincenz> alternate suggestions?
05:35:17 <Lemmih> dcoutts: It's difficult to initiate the dependencies of a plugin when they aren't different from normal libraries. Building and installing a cabal package is too time consuming (especially for small changes) and too permanent.
05:35:36 <vincenz> ooh
05:35:38 <vincenz> hmp3 !
05:35:42 <ihope> How can I add two Words?
05:35:43 <vincenz> @where hmp3
05:35:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
05:35:45 <dcoutts> Lemmih, ok what are you thinking of?
05:36:33 <dcoutts> Lemmih, I agree it seems like a lot of overhead for small plugins, but it seems rather nice at first for the big chunks (which are not really going to get reloaded/updated that much)
05:36:53 <vincenz> @version
05:36:53 <lambdabot> lambdabot 3p368, GHC 6.4.1 (Linux i686 3.20GHz)
05:36:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:37:02 <dcoutts> using cabal does make building the plugins easier because of the dep tracking
05:37:26 <vincenz> what is mpg321?
05:37:27 <Lemmih> dcoutts: I'm thinking of writing our own package management, separate from the GHC package system.
05:37:38 <dcoutts> Lemmih, so you think we need some distinction between our plugins and normal packages?
05:37:58 <Lemmih> dcoutts: Yeah, exactly.
05:37:59 <vincenz> anyone tried hmp3?
05:38:04 * vincenz does configure and gets no Makefile
05:38:10 <dcoutts> vincenz, yes
05:38:39 <dcoutts> Lemmih, right. hmm. And this is because for our plugins we need to initialise them but for normal ones we don't.
05:38:55 <vincenz> ah...
05:38:57 <vincenz> Setup.lhs
05:39:18 <Lemmih> dcoutts: I'm thinking we can use 'ghc --make' (via the ghc-api) for compilation.
05:39:25 <mauke> @hoogle (b -> [a] -> b) -> b -> [a] -> b
05:39:26 <lambdabot> No matches, try a more general search
05:40:11 <dcoutts> Lemmih, perhaps we can address the pluging initialisation issue differently
05:40:30 <dcoutts> Lemmih, eg by not tieing it so strongly to the package dep structure
05:41:07 <dcoutts> Lemmih, let me play devil's advocate; so why exactly do our plugins need initialising in a particular order?
05:41:35 <vincenz> what's up with this Setup.lhs?
05:41:38 <vincenz> how does it work?
05:41:55 <dcoutts> vincenz, is configure executable? that's the problem I found
05:42:02 <vincenz> nono
05:42:07 <vincenz> I mean, how would I use such a system
05:42:12 <vincenz> instead of Make
05:42:33 <cajole> nope
05:42:37 <dcoutts> vincenz, you mean how do you build a cabal package ?
05:42:48 <vincenz> yep
05:42:51 <mauke> @hoogle b -> (a -> [a] -> b -> b) -> [a] -> b
05:42:52 <lambdabot> No matches, try a more general search
05:43:16 <dcoutts> vincenz, runghc Setup.lhs configure; runghc Setup.lhs build; runghc Setup.lhs install
05:43:29 <Lemmih> dcoutts: Well, I don't think it'll scale well if plugins can't depend on each other.
05:43:34 <vincenz> ooh
05:43:36 <vincenz> hmp3 me likes
05:43:49 <vincenz> dcoutts: I meant if you want to make something like that yourself... what files do you need to create?
05:43:52 <dcoutts> Lemmih, they can depend on each other, but why initialisation in a particular order?
05:44:02 <vincenz> aka...an empty shell project I can reuse for my own code
05:44:02 <mauke> what's good name for a fold-like function that doesn't recurse?
05:44:03 <dcoutts> vincenz, see the cabal docs
05:44:05 <vincenz> instead of using ugly makefile
05:44:08 <vincenz> dcoutts: will do
05:44:11 <vincenz> dcoutts: what if people dont have cabal
05:44:18 <dcoutts> vincenz, get it! :-)
05:44:27 <dcoutts> vincenz, oh if user don't have it you mean
05:44:30 <vincenz> dcoutts: yep
05:44:39 <dcoutts> vincenz, well ghc-6.4.x comes with it
05:44:52 <dcoutts> or they can download it seperately
05:45:19 <vincenz> does it work on windows?
05:45:31 <vincenz> or systems where you don't have root access
05:46:07 <dcoutts> vincenz, yes, yes.
05:47:24 <ihope> @index plusInt
05:47:24 <lambdabot> bzzt
05:47:28 <goron> Why does this hold? logBase 0.999999999 1.1 > logBase 0.99999999 1.1
05:47:36 <Lemmih> dcoutts: Hm, maybe initiation isn't a problem but I'm pretty sure it'll make it difficult to reload plugins.
05:47:42 <ihope> goron: because floats are weird
05:48:03 <dcoutts> Lemmih, how so? and how would an alternate system solve it?
05:48:25 <ihope> Oh, I see...
05:48:30 <dcoutts> Lemmih, btw we can add custom stuff into the .cabal files with x-hide-foo: blah
05:48:44 <ihope> goron: because 0.999999999 > 0.99999999
05:48:49 <vincenz> yep
05:48:57 <vincenz> log is monotonous
05:49:04 <goron> ihope: I would have expected floats to be consistent at least.
05:49:08 <Lemmih> dcoutts: I'm not sure it's safe to unload a plugin without unloading the plugins that depend on it.
05:49:14 <vincenz> goron: they're not the same number of 9s
05:49:19 <goron> vincenz: I know
05:49:22 <vincenz> then it's obvious
05:49:24 <dcoutts> Lemmih, that's probably true in general.
05:49:26 <vincenz> that >
05:49:27 <goron> vincenz: It should be the other way around...
05:49:29 <vincenz> nope
05:49:33 <vincenz> log is monotonous
05:49:36 <goron> vincenz: That's the point I am trying to make. 
05:49:39 <dcoutts> Lemmih, because there will still be links from one to the other
05:49:46 <vincenz> goron: well that's not what you said
05:49:46 <goron> vincenz: Yes, so... I will show you the sequence.
05:49:50 <dcoutts> Lemmih, pluging unloading is a very sticky problem I think
05:50:02 <goron> vincenz: I did not say anything which is incorrect. 
05:50:02 <vincenz> goron: you said log (0.9 9s') > log (0.8 9s)
05:50:10 <vincenz> goron: which is always correct
05:50:40 <vincenz> 15:46 < goron> Why does this hold? logBase 0.999999999 1.1 > logBase 0.99999999 1.1
05:50:40 <goron> >logBase 0.9999 1.1
05:50:48 <vincenz> > logBase 0.9999 1.1
05:50:49 <lambdabot> -953.0541421591608
05:50:51 <vincenz> > logBase 0.99999999 1.1
05:50:52 <lambdabot> -9531017.884886332
05:51:02 <ihope> Hmm.
05:51:05 <dcoutts> Lemmih, it's not obvous to me how to solve that except by some custom mechanism which instructs a plugin to 'detach itself' from its dependencies
05:51:05 <vincenz> now -that- is wrong
05:51:08 <goron> > logBase 0.999999999 1.1
05:51:09 <lambdabot> -9.531018245222588e7
05:51:16 <goron> vincenz: you see?
05:51:24 <ihope> > logBase 0.9999999999999999999999999999999999999 1.1
05:51:24 <lambdabot> Infinity
05:51:27 <vincenz> goron: yes...just that your original question made no sense
05:51:29 <dcoutts> Lemmih, and such a thing could get very complex to implement on a per-plugin basis
05:51:40 <dcoutts> Lemmih, do you think there is a general solution?
05:51:40 <goron> vincenz: it did make sense, you just parsed it incorrectly.
05:51:46 <vincenz> goron: nope...
05:51:54 <vincenz> goron: the erroneous case is going from 0.9999 tto 0.999999
05:52:03 <vincenz> not the 0.9999999 to 0.999999999
05:52:13 <ihope> Is it subtracting from zero and inverting?
05:52:27 <ihope> > logBase 64 2
05:52:28 <lambdabot> 0.16666666666666669
05:52:32 <int-e> > 0.9999999999999 == 1
05:52:32 <ihope> > logBase 2 64
05:52:33 <lambdabot> False
05:52:33 <lambdabot> 6.0
05:52:34 <Lemmih> dcoutts: Add 'plugin_unload' and run that in the plugins before unloading them?
05:52:37 <ihope> Hmm.
05:52:48 <goron> vincenz: hmm, I take it back.
05:52:51 <dcoutts> Lemmih, and what would such a thing do exactly?
05:52:57 <ihope> > logBase 1.1 0.999999999 > logBase 1.1 0.99999999
05:52:58 <lambdabot> True
05:52:59 <vincenz> goron: but yeah... there is a problem
05:53:12 <ihope> > logBase 1.1 0.999999999 -- you get the idea
05:53:13 <lambdabot> -1.0492058395767407e-8
05:53:25 <dcoutts> Lemmih, eg a plugin that registerd itself with the GUI would have to tell the GUI to unregister the callback
05:53:35 <vincenz> wait
05:53:40 <vincenz> > logBase 2 3
05:53:41 <lambdabot> 1.5849625007211563
05:53:44 <vincenz> > logBase 3 2
05:53:44 <lambdabot> 0.6309297535714574
05:53:46 <vincenz> > logBase 4 2
05:53:47 <lambdabot> 0.5
05:53:50 <vincenz> oh...
05:53:53 <vincenz> the base comes first
05:53:54 <vincenz> do
05:53:58 <dcoutts> Lemmih, I imaginge keeping track of where a plugins callbacks have got to could get rather tricky
05:53:58 <Lemmih> dcoutts: Yeah, can't it do that?
05:54:03 <int-e> > map (\x -> (x == 1, logBase x 1.1) [0.99999999999999999, 0.9999999999999999]
05:54:04 <lambdabot>  parse error on input `}'
05:54:04 <Lemmih> Hm
05:54:13 <int-e> > map (\x -> (x == 1, logBase x 1.1)) [0.99999999999999999, 0.9999999999999999]
05:54:14 <lambdabot> [(True,Infinity),(False,-8.584777805027455e14)]
05:54:18 <vincenz> then it's' obvious why it's infinity
05:54:19 <dcoutts> Lemmih, and there's no guarantee that we've done it correctly
05:54:19 * int-e shrugs
05:54:20 <vincenz> 0.9999999999999999 = 1
05:54:28 <vincenz> and log base 1 for any number not == 1 is infinity
05:54:36 <goron> vincenz: you are saying the first argument is the base?
05:54:39 <ihope> > logBase 1 1
05:54:40 <lambdabot> NaN
05:54:41 <vincenz> goron: it appears so
05:54:42 <vincenz> look
05:54:43 <dcoutts> Lemmih, and if we unload and there are references left then Segfault! (at least if one gets called)
05:54:46 <vincenz> > logBase 2 4
05:54:47 <lambdabot> 2.0
05:54:47 <vincenz> > logBase 4 2
05:54:48 <lambdabot> 0.5
05:55:07 <dcoutts> Lemmih, there's a reason that even GHCi doesn't unload code (as far as I understand)
05:55:07 <vincenz> unintuitive ....
05:55:24 <ihope> log_(i*pi) (-1)
05:55:27 <dcoutts> Lemmih, to guarentee there are no references left needs some kind of code garbage collection
05:55:27 <int-e> log 1 is +0
05:55:28 <vincenz> oh wait... I was using that logic all along
05:55:30 * vincenz mutters
05:55:46 <vincenz> disregard everything I said up to 5 minutes ago
05:55:49 <dcoutts> Lemmih, *I think* I may be wrong of course. dons would know better than I of course.
05:55:57 <int-e> IEEE floating points are not really suitable for doing math.
05:56:05 <goron> So, is the first argument the base or the second?
05:56:19 <vincenz> int-e: you want peano only
05:56:21 <int-e> the first
05:56:23 <vincenz> goron: the first
05:56:27 <goron> int-e: ok
05:56:30 <Lemmih> dcoutts: We can downplay the plugins. Only using them to add new types of projects and stuff like that.
05:56:57 <vincenz> > map (1-) $ map (10^) $ [-1..-10]
05:56:58 <lambdabot>  Not in scope: `..-'
05:57:11 <vincenz> > map (1-) $ map (10^) $ map (0-) $ [1..10]
05:57:12 <lambdabot> Exception: Prelude.^: negative exponent
05:57:17 <vincenz> > map (1-) $ map (10.0**) $ map (0-) $ [1..10]
05:57:18 <lambdabot> [0.9,0.99,0.999,0.9999,0.99999,0.999999,0.9999999,0.99999999,0.999999999,0.9999999999]
05:57:24 <int-e> vincenz: rational numbers are fine. floating point is hairy but often a useful approximation. You better know what you're doing before you rely on any results obtained with FP math though.
05:57:28 <vincenz> > map (logBase 1.1) $ map (1-) $ map (10.0**) $ map (0-) $ [1..10]
05:57:29 <lambdabot> [-1.1054487136015798,-0.105448713601581,-1.049730821657871e-2,-1.0492583325166422e-3,-1.0492111147852485e-4,-1.049206393359161e-5,-1.0492059206337474e-6,-1.0492058792437426e-7,-1.0492058395767407e-8,-1.0492059555898493e-9]
05:57:34 <vincenz> seems ok
05:57:37 <Lemmih> dcoutts: So no dependencies and no dangerous references if the plugin returns some kind of AST.
05:57:39 <shapr> dcoutts: Hey, any ETA on your peval stuff?
05:57:46 <dcoutts> shapr, nah
05:57:47 <goron> The documentation does not state this. 
05:57:54 <shapr> dcoutts: six months, six years?
05:57:55 <goron> In fact there is no documentation
05:58:00 <dcoutts> shapr, 2 years
05:58:02 <vincenz> six decennia?
05:58:02 <goron> For a standard lib....
05:58:06 <shapr> dcoutts: ah, I see.
05:58:08 <vincenz> what is peval?
05:58:17 <shapr> partial evaluation.
05:58:22 <vincenz> of?
05:58:35 <dcoutts> Lemmih, right, if we can guarantee that a plugin has not wormed it's way into too much then we could unload it.
05:58:35 <shapr> everything.
05:58:51 <ihope> So where are plusCard and such?
05:58:58 <ihope> s/Card/Int/
05:59:16 <dcoutts> Lemmih, but pretty much any value returned by a plugin could contain references to code in that plugin.
05:59:19 <vincenz> hmm
05:59:24 <vincenz> pity hmp3 does not have "next"
05:59:30 <dcoutts> Lemmih, due to lazynes, closures etc.
05:59:59 <shapr> dcoutts: Maybe dons will steal Erlang's hot code reloading stuff.
06:00:14 <dcoutts> shapr, yes, it'd be interesting to know how that's done
06:00:28 <dcoutts> when is it safe to finally unload old code?
06:00:39 <ihope> Hey, cool. := can be an infix constructor.
06:00:41 <dcoutts> I think it probably needs some kind of code GC
06:01:01 <dcoutts> ihope, yeah, it's used in wxhaskell & gtk2hs
06:01:38 <Lemmih> dcoutts: Yeah, the safety isn't guaranteed but it should work as long as the static core isn't buggy.
06:02:10 <shapr> dcoutts: Erlang saves refs, newly created values get a handle to the newest version of the code, and refs to older versions of the code keep the old version in memory until they can be GC'd.
06:02:40 <dcoutts> Lemmih, I'd like to see an example where we can be sure it's safe.
06:02:56 <vincenz> shapr: how do they convert data?
06:03:04 <dcoutts> shapr, right, sounds sensible.
06:03:11 <vincenz> shapr: old code uses lists....new code uses binary tree..
06:03:14 <shapr> vincenz: no clue.
06:03:29 <shapr> Erlang is dynamically checked, so it probably causes a runtime error.
06:03:29 <vincenz> or do you cycle through a data-conversion code before going to new code?
06:03:31 <vincenz> so it's a two step process
06:03:38 <shapr> We could ask on #erlang.
06:03:40 <shapr> They might know.
06:03:42 <vincenz> >load data-conversion
06:03:46 <vincenz> >load new-code
06:03:48 <dcoutts> shapr, the bit ghc misses is the finding when there are no more references to a chunk of code
06:04:20 <Lemmih> dcoutts: Is that even possible if we want to unload code?
06:04:43 <dcoutts> Lemmih, sorry? is what possible?
06:04:58 <vincenz> shapr: if you could somehwo define collections at a higher-level...it should be able to deduce it itself
06:05:01 <vincenz> that would rock
06:05:13 <Lemmih> dcoutts: Safe unlinking of code.
06:05:30 <dcoutts> Lemmih, is that not what you're talking about?
06:05:35 <dcoutts> Lemmih, unloading plugins?
06:06:15 <goron> What's the point of making a static language like Haskell dynamic?
06:06:21 <shapr> goron: emacs
06:06:35 <goron> shapr: Emacs is written in Lisp. Lisp is dynamic.
06:06:54 <goron> shapr: Lisp can be extended to support Haskell syntax.
06:07:05 <shapr> I'd rather do it the other way around.
06:07:08 <goron> shapr: At least Common Lisp can.
06:07:14 <Lemmih> dcoutts: Yeah, it is. You asked for an example where we can be sure it's safe but I don't think such an example exist.
06:07:25 <vincenz> goron: that is nasty
06:07:57 <goron> shapr: A type system is nice, but one can also be implemented in Lisp. 
06:08:08 <vincenz> goron: you can also write windows in assembly
06:08:17 <goron> shapr: It's a waste of resources to reimplement emacs.
06:08:21 <shapr> I disagree.
06:08:44 <goron> vincenz: the point of Lisp is that you can create the syntax you want. 
06:08:46 <dcoutts> Lemmih, well a trivial example might be if a function returns some primitive type and we can be sure it's already evaluated (no thunks). Then we can unload the code that generated that value but retain the value.
06:08:50 <vincenz> it's pretty sad that Lisp is so deformable to support other syntaxes... I mean...
06:08:57 <Lemmih> goron: Dynamic Haskell is great. Seen GHCi?
06:08:59 <goron> vincenz: almost nobody uses it like that, but they should.
06:09:02 <vincenz> goron: which only means that every program will be written different
06:09:12 <vincenz> too much flexibility only makes for unreadable code
06:09:27 <goron> vincenz: Some code is hard.
06:09:30 <vincenz> DSL's in haskell are still in haskell syntax, although they're very readable
06:09:53 <goron> vincenz: I think the hard code is the interesting code.
06:10:00 <vincenz> goron: so how would you do that? basically provide a parser in lisp?
06:10:07 <goron> vincenz: yes
06:10:08 <vincenz> goron: so you're basically building an entire compiler just to use lisp?
06:10:16 <Lemmih> dcoutts: But we don't want to use the value after we unload the plugin...
06:10:17 * vincenz shakes his head
06:10:19 <goron> vincenz: First implement parser combinators.
06:10:27 <goron> vincenz: they are a very good idea.
06:10:31 <vincenz> goron: so it's not just using some macros...
06:10:38 <goron> vincenz: no
06:10:41 <vincenz> basically you read in text and parse it
06:10:43 <vincenz> at which point I ask you
06:10:52 <vincenz> ... why are you still using lisp if you're building an entire compiler for another language
06:10:57 <vincenz> use the other language
06:11:07 <goron> vincenz: The point is that you can mix languages .
06:11:12 <goron> vincenz: without hacking.
06:11:15 <vincenz> goron: no you can't...
06:11:20 <vincenz> goron: each will need it's own parser
06:11:22 <vincenz> nothing different from a linker
06:11:26 <vincenz> which exists on any system
06:11:39 <vincenz> unless you mangle the languages so they use the same underlying system
06:11:46 <vincenz> which will most likely crirpple them
06:11:51 <sebell> *cough* CIL
06:12:05 <vincenz> sebell: by berkely?
06:12:10 <goron> vincenz: No, you translate everything to basic Lisp.
06:12:24 <vincenz> goron: yes and ghc translates everythign to assembly
06:12:29 <sebell> vincenz: Common Intermediate Language, of .NET, of MS :)
06:12:31 <vincenz> hey, it's a language that all languages compile to!
06:12:36 <Lemmih> I doubt translating Haskell to Lisp is trivial.
06:12:37 <dcoutts> Lemmih, well guaranteeing that we're not using any values calculated from the plugin would be sufficient
06:12:44 <vincenz> sebell: ah..
06:12:47 <goron> vincenz: But tying them together is a lot harder.
06:12:52 <shapr> dcoutts: hey, did you see the "Haskell's market" thread on haskell-cafe?
06:12:52 <vincenz> sebell: which is just assembly for a virtual platform
06:12:55 <vincenz> goron: I disagree
06:13:01 <goron> vincenz: Elaborate.
06:13:07 <vincenz> goron: use the right tool for the job
06:13:15 <vincenz> don't conform a hammer to be screwdriver
06:13:29 <dcoutts> shapr, yeah, briefly
06:13:36 <vincenz> basically you take lisp...(imagine some big gadget) and plug it on the end of a hammer to get a screwdriver
06:13:41 <vincenz> just use a screwdriver!
06:13:42 <sebell> vincenz: Exactly, it just came to mind when you said "cripple"
06:13:43 <shapr> HEY, who here would sign up to do contract work with Haskell?
06:13:50 <mauke> foo :: b -> (a -> [a] -> b) -> [a] -> b;  foo z _ [] = z;  foo _ f (x : xs) = f x xs
06:13:55 <goron> vincenz: How would you tie Haskell to C?
06:13:57 <mauke> what's a good name for this function/concept?
06:13:58 <shapr> I think it's time to organize a consortium of Haskell contract programming.
06:13:59 <goron> vincenz: without FFI
06:14:12 <vincenz> goron: how would you combine languages in lisp without read?
06:14:16 * vincenz shakes his head
06:14:24 <shapr> vincenz: Y0, would you like to get paid to do Haskell work?
06:14:26 <vincenz> you use FFI obviously
06:14:29 <vincenz> shapr: ooh
06:14:42 <shapr> This is a potential question, rather than a concrete one :-)
06:14:45 <goron> vincenz: Ok, then some language for which no FFI exists...
06:14:49 <vincenz> shapr: yes
06:14:56 <Lemmih> dcoutts: So, yeah, as long as the static core doesn't screw up we're safe.
06:14:57 <vincenz> goron: you're giving the wrong premise
06:15:03 <shapr> vincenz: Do you have a resume online that I can link to?
06:15:06 <goron> vincenz: why? You can do that in Lisp...
06:15:10 <shapr> Lemmih: get paid to write Haskell?
06:15:12 <vincenz> shapr: heh...not yet but I've got two years of phd to go
06:15:24 <vincenz> goron: right... or you can just extend the compiler for said language to support FFI
06:15:24 <dcoutts> Lemmih, I guess so.
06:15:27 <Lemmih> shapr: Nope.
06:15:36 <shapr> Yeah, but is moonlighting allowed while doing a PhD?
06:15:36 <vincenz> goron: I think you're conforming the world just so you can say "only lisp works
06:15:44 <vincenz> shapr: moonlighting?
06:15:47 <vincenz> shapr: I doubt it tho
06:15:49 <shapr> Lemmih: want to get paid for Haskelling?
06:15:51 <vincenz> so gimme two years
06:15:54 <shapr> vincenz: working after hours
06:15:56 <goron> vincenz: Lisp is the only stable language
06:15:58 <Lemmih> shapr: Sure.
06:15:59 <dcoutts> Lemmih, so we can't pass values from one plugin to another?
06:16:01 <shapr> goron: excuse me?
06:16:06 <shapr> Lemmih: Got a resume?
06:16:06 <goron> vincenz: Why do we get Haskell Prime?
06:16:16 <vincenz> goron: asssembly is a stable language
06:16:19 <vincenz> c is a stable language
06:16:24 <vincenz> c++ is a stable language
06:16:25 <shapr> lambda calculus is stable :-)
06:16:28 <vincenz> right
06:16:30 <sebell> goron: Since when is "Lisp" stable? It's an enormous family of languages
06:16:32 <shapr> Hasn't change since Church thought it up
06:16:37 <goron> vincenz: And when we get a new arch?
06:16:37 <Lemmih> shapr: Alas, no (:
06:16:47 <vincenz> goron: you have to make a new lisp compiler
06:16:52 <shapr> Lemmih: Can you write one in a coupla days?
06:17:04 <goron> vincenz: yes, but all your languages work right away then.
06:17:08 <shapr> Lemmih: er, CV is probably better since this is Europe.
06:17:10 <vincenz> shapr: sadly I have no professional experience in haskell... so it'd be hard to sell
06:17:23 <Igloo> shapr: You mean you don't know about lambda calculus 2, with goto's?
06:17:24 <dcoutts> Lemmih, eg a core module passes an interface from plugin A to plugin B (but A & B do not depend on each other) Now plugin B has an untracked reference to code in plugin A
06:17:24 <goron> vincenz: You write one compiler, not one for every language.
06:17:25 <vincenz> goron: same if you use c
06:17:26 <shapr> vincenz: I only have a few days professional experience in Haskell. But no one else can say much better :-)
06:17:26 <sebell> goron: Same for all compilers that leverage C
06:17:30 <vincenz> there's probably more archs supported by than lisp
06:17:36 <vincenz> by c than lisp
06:17:41 <vincenz> and you get native code
06:17:50 <shapr> Igloo: oh no, does it change binary compatibility? apt-get install lambdacalculusc2 ?
06:18:31 <goron> vincenz: Only nobody is doing that in C, because C has no read.
06:18:34 <Lemmih> shapr: Well, I'm a high-school drop out who haven't had a single official job as a programmer... my CV wouldn't be very impressive.
06:18:41 <vincenz> goron: so what do you call scanf ?
06:18:47 <mauke> goron: my C has read(), actually :-)
06:18:56 <shapr> Lemmih: If you list all the Haskell code you've written, I bet it'll look better.
06:19:12 <vincenz> goron: really... I used to be like you once...but I long accepted that it's best to use the right tool for the job instead of forcing everything into one tool
06:19:28 <shapr> Igloo: Want to put your CV into the pool of Haskell moonlighters?
06:19:35 <goron> vincenz: Oh, I agree with that. It's impossible for me to implement it all.
06:19:50 <greenrd> I am trying to write a fast function that counts the number of subsets of a set that sum to N
06:19:54 <goron> vincenz: but I would rather have that the entire world worked on one compiler.
06:20:12 <goron> vincenz: now the same optimizations are done for every compiler.
06:20:14 <vincenz> goron: nbut you're not, don't you see?
06:20:21 <vincenz> goron: you still have to make compilers for other languages in lisp
06:20:32 <greenrd> I can see that when I've found such a set, I can prune all supersets of that set from the search space
06:20:34 <Lemmih> dcoutts: I don't follow.
06:20:38 <vincenz> and optimizations targetting for instance array intensive code are most likely not gonna work well in lisp...
06:20:40 <goron> vincenz: I think a lot of the optimization work can be reused.
06:20:45 <vincenz> goron: I disagree
06:20:52 <goron> vincenz: less for data-parallell languages.
06:20:57 <vincenz> many optimizations need high level information
06:21:17 <goron> vincenz: true, but I don't know about the percentage.
06:21:31 <astrolabe> greenrd: recurse on n
06:21:32 <vincenz> goron: besides the basic optimizations that are part of literature
06:21:34 <vincenz> I'd say 100%
06:21:45 <Lemmih> dcoutts: I proposed that plugins can't interact with each other.
06:21:49 <goron> vincenz: it's obviously not 100%.
06:21:52 <dcoutts> Lemmih, suppose a core module gets an implementation of some interface from one plugin. It passes that implementatin to another plugin. That's not an unreasonable thing to do but it'll break.
06:22:03 <dcoutts> Lemmih, but in this case neither plugin depend on each other
06:22:04 <goron> vincenz: x *2 -> x+x
06:22:11 <dcoutts> Lemmih, at least not statically
06:22:13 <goron> vincenz: that works always.
06:22:15 <vincenz> goron: read my comment
06:22:23 <vincenz> "besides the basic optimizations that are part of literature"
06:22:24 <dcoutts> Lemmih, eg imagine a plugin that provides a build system
06:22:24 <goron> vincenz: oh, ok
06:22:52 <Igloo> shapr: Wouldn't it be more normal to have a company get the business and distribute it amongst people appropriately?
06:23:03 <ihope> Hmm. What does lazy do?
06:23:11 <vincenz> @hoogle lazy
06:23:12 <lambdabot> Control.Monad.ST.Lazy :: module
06:23:12 <lambdabot> Control.Monad.ST.Lazy.lazyToStrictST :: ST s a -> ST s a
06:23:12 <lambdabot> System.Win32.Registry.rEG_NO_LAZY_FLUSH :: RegRestoreFlags
06:23:16 <goron> vincenz: I am wondering about the ratio basic/all
06:23:22 <Lemmih> *sigh*
06:23:24 <shapr> Igloo: I don't think there is a normal for Haskell consulting. Not yet anyway.
06:23:37 <ihope> GHC.Base.lazy :: a -> a
06:23:41 <dcoutts> Lemmih, so imagine there's a build system interface in the core but the implementation(s) are provided by other plugins. Then some plugin which wants to use the build system asks the core for the current build system. It's now holding a reference to code that it does not staticalyl depend on.
06:23:51 <vincenz> goron: besides... lisp is not the right level... you need to analyze at a higher level, and turn out stuff at a lower level
06:24:07 <vincenz> goron: to enable proper caching, data layout in memory, in memory banks, turning off and on memory banks, 
06:24:14 <vincenz> dma-ing stuff to local scratchpade
06:24:16 <vincenz> etc..etc..
06:24:30 <dcoutts> Lemmih, and that is fine software engeineering practice unless you want to unload plugins.
06:24:52 <dcoutts> Lemmih, why do we need plugin unloading again?
06:25:54 <Lemmih> dcoutts: To avoid space leaks?
06:25:59 <goron> vincenz: If you embed a language suitable for that in Lisp, you can.
06:26:15 <dcoutts> Lemmih, so which plugins are going to be frequently reloaded?
06:26:23 <dcoutts> Lemmih, how does ghci get away with it?
06:27:00 <Lemmih> dcoutts: The ones that is currently being hacked on.
06:27:06 <Lemmih> dcoutts: I'll check.
06:27:24 <dcoutts> Lemmih, as I recall ghci doesn't bother with code unloading
06:27:41 <shapr> C'mon, who can I get resumes or CVs from?
06:28:02 <shapr> Igloo: Although I could organize the company, since I know lots of Haskellers and what they're good at...
06:28:14 <dcoutts> shapr, you're asking everyone for their CV?
06:28:24 <dcoutts> shapr, I've got an old one...
06:28:26 <shapr> dcoutts: If you want to do contract Haskell work, yeah.
06:28:48 <ihope> Convenient. "GHC.Prim has no implementation."
06:29:34 <vincenz> goron: if you emebed a language suitable for that in any language X, you can do it inX
06:30:12 <goron> vincenz: optimizations don't work across language barriers in your model
06:30:21 <Lemmih> dcoutts: Hm, right.
06:30:28 <vincenz> goron: then why would they in lisp?
06:30:39 <dcoutts> shapr, I'm to busy atm I guess :-(
06:30:46 <vincenz> anyways
06:30:48 <dcoutts> shapr, I'd be interested in the future
06:30:49 <vincenz> this conversation is usueless
06:30:50 <goron> vincenz: because everything is translated to one s-expression.
06:30:55 <vincenz> be a zealot if that makes you feel happier
06:31:12 <goron> vincenz: I am not a zealot, I am just making a point.
06:31:16 <vincenz> not really
06:31:24 <goron> vincenz: It's a clear advantage. 
06:31:30 <vincenz> none that I can discern
06:31:33 <Lemmih> shapr: Setting up a website for unemployed Haskellers?
06:31:33 <dcoutts> shapr, hey, I'll be in Sweeden in the autumn
06:31:37 <goron> vincenz: maybe it's not practical... that's not the point.
06:31:43 <vincenz> you're basically moving all the work that needs to be done from some language X to Lisp
06:31:44 <shapr> goron: I'd say that multidimensional data structures are better than sexps.
06:31:48 <shapr> dcoutts: Where at?
06:32:11 <dcoutts> shapr, near Stockholm, but I can travel
06:32:11 <vincenz> goron: which can be done for any language Y iso lisp
06:32:15 <vincenz> lisp has no clear advantage
06:32:48 <goron> vincenz: a language Y iso  lisp is lisp.
06:32:48 <shapr> dcoutts: I'll be living in Stockholm in July.
06:32:54 * vincenz shrugs
06:33:13 <dcoutts> shapr, my gf is there for a few months, october to mid-december
06:33:22 <goron> shapr: You mean multidimensional arrays?
06:33:25 <shapr> Lemmih: Sort of... did you see the "Haskell's market" thread on haskell-cafe?
06:33:37 <shapr> goron: No, algebraic datatypes in general.
06:33:41 <goron> shapr: ok
06:33:51 <dcoutts> shapr, or maybe it was septembre, yes I think I was going to go in September before my term starts again in October
06:33:55 <ihope> Bleh, Word# has no arithmetic?
06:34:01 <shapr> Cool, I'll be in the same town.
06:34:05 <shapr> And I'll have a spare unicycle.
06:34:28 <goron> shapr: You can also embed algebraic datatypes in Lisp.
06:34:35 <goron> shapr: There is no limit. 
06:34:46 <ihope> Is there an unboxed unsigned Integer anywhere?
06:35:34 <Lemmih> shapr: Yeah.
06:36:03 <goron> shapr: Lisp is the least hackish way of giving users access to the compiler. 
06:36:22 <goron> shapr: (well, at least that I have seen)
06:36:32 <dcoutts> shapr, mmm yeah, not sure if I'll be able to bring my unicycle on the train :-)
06:37:02 <dcoutts> shapr, possibly, I strapped it to my backpack when I took the train to Edinburgh for the festival
06:37:15 <shapr> goron: what about Epigram?
06:37:36 <shapr> dcoutts: your coker?!
06:37:36 <goron> shapr: I don't see why a dependently typed language could not be embedded.
06:37:46 <dcoutts> shapr, na, the 28" one
06:37:49 <shapr> goron: No I mean, typing information gives access to the compiler, yeah?
06:37:49 <goron> shapr: And  I mean the complete syntax. 
06:38:05 <vincenz> goron: and you could just as easily build a lisp-compiler in haskell...
06:38:09 <goron> shapr: Indirect information
06:38:09 * vincenz shakes his head
06:38:36 <shapr> goron: How would region allocation help a lisp compiler?
06:39:02 <shapr> Lemmih: So I figure, in response to Pete Chown's post, I'd like to list a bunch of people who would be willing to do contract work with Haskell.
06:39:39 <Lemmih> shapr: ah.
06:39:40 <goron> shapr: Why would it not?
06:40:30 <shapr> The lisp implementation itself would need to be aware of region allocation and the advantages.
06:40:43 <shapr> goron: What's the great advantage of lisp anyway?
06:40:56 <shapr> If you want a simple self-describing language, Joy is significantly simpler.
06:40:57 <vincenz> shapr: Lots of Incessant Silly Parentheses
06:41:54 <petekaz> sounds like you have paren-envy.
06:42:01 <shapr> Joy would allow partial evaluation at read time, has better macro properties, would allow parallel eager evaluation.. I could go on.
06:42:11 <goron> shapr: The advantage is that the user can extend it without limits.
06:42:21 <vincenz> goron: that's not true
06:42:23 <vincenz> you use read
06:42:24 <SamB> what if I want limits?
06:42:28 <vincenz> at which point you can use haskell aas well
06:42:29 <shapr> How is that different from Haskell or Joy?
06:42:30 <SamB> they are very useful for integration
06:42:31 <vincenz> using read and parsec
06:42:34 <goron> shapr: I don't know about Joy.
06:42:38 <mauke> how do I extend lisp to use lowercase symbols?
06:42:45 <mauke> without rewriting the whole standard library, I mean
06:43:06 <vincenz> goron: you said you'd read in the language and parse it...that's not extending lisp, thats writing a parser in lisp, which can be done in haskell just as well and probably much easier with the parsec combinator library
06:43:08 <shapr> Joy is a postfix concatenative stack based purely functional programming language. With no names, realistically.
06:43:17 <shapr> @lambda joy "2 2 2 + +"
06:43:18 <lambdabot> [6]
06:43:19 <integral> mauke: R5RS is entirely lowercase...
06:43:27 <vincenz> shapr: kind of like forth?
06:43:35 <shapr> vincenz: Yeah, if forth and haskell had a love child...
06:43:36 <SamB> yes, its true...
06:43:38 <mauke> integral: I meant common lisp, not scheme
06:43:45 * vincenz nods at shapr 
06:43:47 <SamB> lisp seems to lack parsing combinators
06:44:11 <vincenz> goron: or using c and yacc
06:44:15 <vincenz> goron: or ocaml and ocamlyacc
06:44:23 <vincenz> goron: or assembly and much work
06:44:26 <vincenz> goron: ...
06:44:27 <vincenz> ...
06:44:28 <vincenz> ...
06:44:31 <petekaz> speaking of lisp (scheme) and haskell, as a newbie, I am really enjoying that new haskell tutorial that was recently posted.
06:44:34 <shapr> goron: It sounds to me like you're saying that the minimal distance between AST and compiled output gives lisp advantages. Is that correct?
06:45:10 <goron> vincenz: you can write e.g. (haskell <haskellcode>)
06:45:23 <goron> vincenz: using Haskell syntax.
06:45:29 <SamB> the thing about lisp is that they forgot to do syntax
06:45:36 <FuttyImre> petekaz which one?
06:45:46 <goron> SamB: They are not implemented.
06:45:50 <integral> and they (CL) have separate function and value names
06:45:54 <petekaz> FuttyImre: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
06:45:57 <goron> SamB: But you *can* implement them.
06:46:19 <petekaz> FuttyImre: It's called "Write yourself a Scheme in 48 Hours - A Haskell Tutorial"
06:46:24 <shapr> goron: But then you've got Haskell again?
06:46:41 <goron> shapr: Haskell is not the best for all things.
06:46:47 <vincenz> basically lisp is great for people not wanting to use lisp :D
06:47:07 <vincenz> goron: you can do what you say with ANY language
06:47:20 <vincenz> you write a parser in that language
06:47:25 <shapr> goron: I don't think it is, but neither is lisp :-)
06:47:34 <vincenz> shapr: right tool for job :)
06:47:38 <musasabi> dons: is there a nice way of doing lines in fps except for (\r?\n) instead of \n ?
06:47:41 * vincenz looks at his case
06:47:44 <goron> shapr: and that's why you could do it like this.
06:47:46 <vincenz> err belt
06:47:58 <goron> shapr: Stratego does the same.
06:48:01 <vincenz> goron: or you could write a lisp parser in haskell
06:48:19 <goron> shapr: You embed a language like Java (they have a nice system for that).
06:48:34 <goron> shapr: And then you can transform Java programs with concrete syntax.
06:49:02 <goron> shapr: I am describing the same, but Lisp is reflexive, something Stratego is not.
06:49:04 <shapr> goron: How's that different from writing a Java interpreter/compiler in Haskell?
06:49:10 <shapr> reflexive?
06:49:19 <shapr> ik begrijp het niet
06:49:31 <shapr> at least, not in this context
06:50:08 <goron> shapr: Stratego does not have macros.
06:50:32 <goron> shapr: you can manipulate Statego using Statego concrete syntax, but it's not completely the same.
06:50:42 <vincenz> goron: where are you using macros when you supply a parser/
06:50:52 <SamB> hehehe
06:51:01 <shapr> You'd like Joy then, lists and quotations are the same thing.
06:51:26 <SamB> maybe 'haskell has a macro bound and not a function?
07:01:01 <goron> shapr: Joy  indeed looks nice. 
07:05:09 <musasabi> dons: sent a patch.
07:25:16 <ihope> > [ x | x <- [1..100], gcd x 100 == 1 ]
07:25:16 <lambdabot> [1,3,7,9,11,13,17,19,21,23,27,29,31,33,37,39,41,43,47,49,51,53,57,59,61,63,67,69,71,73,77,79,81,83,87,89,91,93,97,99]
07:25:21 <vincenz> dons is on?
07:25:39 <vincenz> ihope: o.O
07:26:14 <ihope> vincenz: the number of prime numbers that doesn't end in one of those digit combinations is finite.
07:26:27 <ihope> (Replacing 1, 3, 7 and 9 with 01, 03, 07 and 09.)
07:27:42 <vincenz> how so?
07:28:10 <ihope> Well, that's essentially saying that the number of prime numbers not ending in 1, 3, 7 or 9 is finite.
07:28:21 * vincenz is considering using haskell typing for his research
07:28:46 <ihope> The only other options are 0, 2, 4, 5, 6 and 8, which, except in the cases of 2 and 5, would create non-prime numbers.
07:29:04 <vincenz> how are they finite
07:29:13 <vincenz> oh
07:29:15 <vincenz> doesn't end in those
07:29:17 <ihope> > [ x | x <- [1..30], gcd x 30 == 1 ] -- in base 30, every prime number except 2, 3 and 5 ends in one of these digits
07:29:18 <lambdabot> [1,7,11,13,17,19,23,29]
07:29:50 <vincenz> intuitively I feel you're right, just curious about the actual proof
07:30:20 <vincenz> for instance... for 100
07:30:29 <vincenz> hmm
07:30:30 <vincenz> n
07:30:30 <vincenz> nm
07:30:31 <ihope> Well, if a number ends in 0, then it is a multiple of 10, and multiples of 10 cannot be prime.
07:30:59 <ihope> If it ends in 2, then it's a multiple of 2, so unless it *is* 2, it's not prime.
07:31:41 <ihope> > let totient n = length [ x | x <- [1..n], gcd x n == 1 ] in (totient 37*43, 36*42)
07:31:42 <lambdabot> (1548,1512)
07:31:46 <ihope> Hmm.
07:32:09 <ihope> That doesn't seem right :-P
07:32:19 <FuttyImre> comma?
07:32:42 * shapr is in a comma induced by bad grammar!
07:33:04 <vincenz> in a comma?
07:33:16 <shapr> pun on coma
07:33:35 <ihope> So what's wrong with my totient function?
07:33:50 <FuttyImre> shapr :)
07:34:05 <shapr> Obviously, the bad grammar was my own :-)
07:34:58 <ihope> So monad = imperative stuff?
07:35:34 * ihope takes a shower, uses it, then puts it back
07:45:57 <dons> vincenz, you pinged?
07:46:02 <dons> how is hmp3? it all works?
07:46:20 <toast> how do u use haksell to secure a system
07:46:39 <dons> secure in what sense?
07:47:40 <toast> "Haskell is still the language of choice for discriminating hackers"
07:48:07 <ibid> toast: do you know what 'hacker' means?
07:48:25 <ibid> (hint: has nothing especially to do with computer security)
07:48:44 <dons> ah
07:48:54 <integral> we could solve the whole virus problem by just arresting everyone who goes to the next Haskell Workshop :-)
07:49:06 <dons> not the kind of hackers you're thinking of I think, toast.
07:49:19 <Saulzar> You won't catch me there
07:49:26 <dons> though, I've not heard of a haskell exploit 
07:50:09 <vincenz> dons: yes hmp3...I'd like / to work on filenames not directories :)
07:50:16 <dons> ?
07:50:27 <vincenz> in hmp3 searches ffor a directory, not a file
07:50:31 <dons> oh, searching
07:50:45 <dons>  63% (139 dirs, 1665 files)
07:50:51 <dons> ^^ I need to search on dirs :)
07:51:07 <dons> hmm. I wonder what we could do. 
07:52:30 <vincenz> 79% (38 dirs, 2816 files)
07:54:22 <toast> i got a haskell class
07:54:32 <toast> but i don't like the teacher much
07:54:36 <dons> currently, you'd have to organise your mp3 files hierarcC[Chically.  
07:54:49 <toast> i want a an awsome tut, any links ?
07:54:52 <dons> vincenz, but it would be possible to sort on file names. not too hard
07:55:00 <dons> ?where yaht
07:55:01 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:55:06 <dons> that's pretty awesome
07:55:22 <dons> do you really need that ability, vincenz?
07:55:50 <vincenz> dons: well erm, it's much easier than scrolling
07:56:01 <dons> you should add more dirs ;)
07:56:11 <dons> also, you know pgup/pgdown work ?
07:56:32 <dons> I agree. if it's a flat clump of 2000 files, searching on file name is better
07:56:36 <dons> i'll add it to the todo list
07:56:40 <dons> and think up a good interface
07:58:11 <dons> toast, lots of good tuts linked to from haskell.org
07:59:00 <vincenz> dons: woo
08:06:13 <dons> vincenz, how'd you find hmp3? just randomly chose an mp3 player?
08:06:47 <jorik> theres no player like amaroK
08:07:43 <dons> but is it written in Haskell?
08:08:17 <jorik> no (but why care?)
08:08:31 <dons> it's nice to see more haskell apps, is all
08:08:38 <vincenz> dons: hmm?
08:08:39 * ptolomy wishes he'd gotten Haskell in school. He wouldn't have had to pick it up on the mean streets.
08:08:42 <ihope_> > reverse "rcibl"
08:08:42 <dons> and they don't segfault on you
08:08:43 <lambdabot> "lbicr"
08:08:43 <vincenz> dons: you mentioned it before I think
08:08:45 <vincenz> dons: or haskell-cafe
08:08:47 <vincenz> cant remember
08:08:56 <vincenz> dons: either way... I needed something and mpg123 can't handle that many iles
08:08:56 <vincenz> look
08:09:11 <vincenz> vincenz@abstractserver:/home/music/Sorted$ mpg123 `find .`
08:09:11 <vincenz> bash: /usr/bin/mpg123: Argument list too long
08:09:24 <dons> ah, ok. i was hoping you just installed some random app, and it turned out to be a haskell one. which would have been a nice surprise.
08:09:35 <ptolomy> I really enjoy seeing basic day-to-day apps written in haskell because it helps iron out practical haskell issues.
08:09:47 <ptolomy> (for limited definitions of the word "practical".)
08:09:50 <dons> very true.
08:10:03 <vincenz> dons: tbh...it's not really haskell
08:10:10 <vincenz> dons: it's a haskell shell around curses and mpg123
08:10:11 <vincenz> o.O
08:10:15 <dons> binary libs, fast strings, fast network code, all arrive as a result of the push of haskell into broader domains
08:10:26 <dons> vincenz, it's still 5k loc
08:10:29 <dons> that's haskell :)
08:10:52 <dons> sorry, 1.7k
08:10:59 <dons> 2k of comments
08:11:02 * petekaz eagerly awaits someone to write "Practical Haskell" in a similar vain as "Practical Common Lisp"
08:11:04 <dcoutts> @quote DennisHuer
08:11:04 <lambdabot> DennisHuer hasn't said anything memorable
08:11:06 <ptolomy> Everyday apps help push Haskell out of it's parents basement and into the sunlight. Builds character.
08:11:17 <dons> ?quote DennisHeur
08:11:18 <lambdabot> DennisHeur hasn't said anything memorable
08:11:19 <dcoutts> bah! dons, lambdabot is forgetting quotes
08:11:20 <dons> hmm
08:11:29 <dons> maybe it got zapped in a sig kill
08:11:32 <dcoutts> I set that the other day becasue it'd forgotten
08:11:41 <dcoutts> @google "are you fully nerd" ghc
08:11:42 <lambdabot> http://blog.gmane.org/gmane.comp.lang.haskell.glasgow.bugs
08:12:05 <dcoutts> 06:01:06 <lambdabot> Are you fully nerd????
08:12:11 <dons> yep. it did forget it 
08:12:14 <dons> it's not in  the quote list
08:12:16 <dcoutts> :-(
08:12:20 <dons> this happens if i have to sig kill it 
08:12:26 <dons> which i shouldn't have to do
08:12:28 <dcoutts> ah ok
08:12:28 <dons> bad dons
08:12:35 <ihope_> So is there a difference between logical shifts and the just plain bitwise shifts?
08:12:37 <dons> it won't flush the state to disk
08:13:03 <dcoutts> dons, right yeah
08:13:10 <dons> petekaz, we actually started on such a project. let me find the url
08:13:47 <Igloo> dons: You could make a "dump everything to disk every hour" thread
08:14:08 <Igloo> FSVO "hour"
08:14:11 <dons> yeah, that's not a bad idea. but flushing works so well as is. as long as i don't get the big hammer
08:14:21 <dons> still, it's a good idea
08:14:56 <Igloo> How dead is it when you need to SIGKILL? Would a SIGHUP handler be able to do a dump to disk?
08:15:16 <dons> it seems to ignore sighup sometimes
08:15:21 <ptolomy> Igloo: I somehow understood FSVO, but I can't exapand it. Definition?
08:15:24 <dons> getting the signals right wouuld perhaps be a better plan
08:15:31 <Igloo> For Some Value Of
08:15:39 <ptolomy> Right. Thanks. ;)
08:16:47 <ihope_> case 1# `addIntC#` 1# of (# x,y #) -> (I# x, I# y)
08:17:00 <ihope_> GHCi doesn't like that.
08:17:24 <dons> -fglasgow-exts?/
08:17:35 <dons> there's an addIntC# primop?
08:17:51 <neologism> any native english speaker here?
08:17:58 <ihope_> neologism: yes
08:18:12 <dons> several dozen, I think
08:21:01 <vincenz> do you consider someone who did highschool in the US native?
08:21:52 <neologism> my question was "what is funny about "running with scissors" ?"
08:22:06 <ptolomy> Not that much, really.
08:22:25 <vincenz> isn't that one of the first things you learn not to do as child?
08:22:25 <dons> it's something youur parents always tell you not to do
08:22:25 <ptolomy> It is symbolic of brainless rebellion in some circles, I guess.
08:22:27 <Igloo> It's the canonical "be careful" mothering phrase
08:22:33 <dons> "because someone might lose an eye"
08:22:38 <dons> hehe
08:23:07 <ndm> its a lot less funny if you were ever playing with scissors and almost did loose an eye
08:23:23 <neologism> noone ever told me to 'not tu run with scissors'
08:23:25 <ndm> (which did happen to me, when i was 20, playing with a housemate with scissors)
08:23:41 <neologism> thnx for explanation
08:23:42 <ndm> got a nice cut right along my cheek - just missed my eye
08:24:57 <dons> well, you shouldn't play with scissors, ndm. didn't anyone tell you that?
08:25:04 <ndm> they did
08:25:25 <neologism> its obviously english thing
08:25:25 <dons> :P
08:25:31 <ndm> and just after that i got a big lecture off my other housemate (it was her boyfriend i was playing with) about how we should treat scissors with respect
08:25:34 <neologism> I've never heard of anyone being advised of not to run with them
08:25:46 <dons> it just a strange cliche, I think neologism
08:25:54 <vincenz> neologism: your momy didn't love you
08:26:03 <Igloo> neologism: Are there a lot of people missing one eye in your country?
08:26:08 <dons> ha!
08:26:32 <dons> they'll have your eye out
08:26:35 <Saulzar> A bit like "It's all fun and games until somone loses an eye"
08:26:52 <dons> lets's see
08:27:06 <int-e> heh. that sounds like it could make a good Go joke.
08:27:14 <dons> ?google south park kenny dies scissors
08:27:16 <lambdabot> http://en.wikipedia.org/wiki/Kenny_McCormick
08:27:18 <Saulzar> At least Haskell is safe, if you lose your eye while using Haskell you can be sure it was your own fault.
08:28:07 <snk_kid> hiya
08:28:29 <Igloo> . o O (unsafeRunScissorM?)
08:29:03 <Saulzar> withScissors ... 
08:29:06 <neologism> vincenz: noone says so here
08:29:07 <snk_kid> can i have some suggestions on some IDEs, whats the progress of hIDE?
08:29:21 <dons> STM == Scissor Transaction Memory -- be very careful
08:29:22 <neologism> Igloo: no :)
08:29:29 <vincenz> neologism: ?
08:29:33 <neologism> vincenz: we are advised other things
08:29:41 <vincenz> ah
08:29:50 <vincenz> neologism: such as wat
08:29:52 <vincenz> what even
08:29:53 <neologism> like to look at left and right when you're crossing a road etc.
08:30:04 <neologism> but nothing about scissors
08:30:04 <dons> but that''s not funny
08:30:14 <vincenz> dons: well it is if you're wiley coyote
08:30:14 <dons> what about running with a stick?
08:30:22 <neologism> nothing
08:30:26 <dons> ?google happy tree friends
08:30:27 <lambdabot> http://www.happytreefriends.com/
08:30:42 <dons> this cartoon will tell you about all the wonders of running with sticks and scissors
08:30:46 <neologism> dons: they tell us to "not cry if you're hurt" etc ;)
08:31:05 <dons> but no comedic violence?
08:31:41 <vincenz> neologism: you live in stoiland?
08:31:48 * int-e remembers something about scissors, knives, forks and light (i.e. fire) not being for small children.
08:31:58 <dons> actually, I remember being shocked when I first watched happy tree friends, with the stick running and the eye poking out
08:32:02 <neologism> what is stoiland?
08:34:40 <vincenz> neologism: the land of the stoics
08:34:46 <ihope_> ???o ?? d??? ?s???d s??? p??? u?? ?o? ?? <- booched
08:36:48 <neologism> vincenz: kind of ;)
08:37:11 <neologism> vincenz: they also tell us "dont cry or I punch you to have reason to cry" :)
08:37:40 <vincenz> hehe
08:37:52 <vincenz> neologism: and where is this?/
08:45:53 <neologism> vincenz: .cz
08:46:29 <dons> ah, that's the kind of thing we're looking for, neologism. though it's a bit scarier
08:47:42 <ihope_> > 2*3
08:47:43 <lambdabot> 6
08:47:45 <ihope_> > 2*3*7
08:47:46 <lambdabot> 42
09:03:11 <toast> 2:[2:3:4]
09:06:48 <lennart_> Howdy folks!
09:09:18 <lennart_> Today I'm sitting in the middle of Sahara in Libya in a big tent camp.  And the Libyans have set up Internet here.  Most impressive.:)
09:10:19 <DrNoboto> what are you doing in libya?
09:10:42 <lennart_> watching the eclipse tomorrow
09:11:11 <DrNoboto> sounds like a trip :)
09:11:37 <lennart_> It's pretty cool to find WiFi in the desert. :)
09:12:27 * neologism wonders if theres a place on earth without wifi :)
09:14:27 <waern> lennart, cool!
09:14:41 <lennart_> totally weird
09:14:51 <waern> maybe cool is the wrong word ;)
09:15:11 <lennart_> it's not that hot right now.  sun is setting
09:15:22 <waern> okay
09:15:25 <sieni> neologism: yes. most places underwater are probably without wifi
09:17:24 <CosmicRay> whee.  finally I have had the time to make the next HDBC release.
09:29:31 * ptolomy congratulates lennart_ for making his workday seem more boring than usual by comparison.
09:30:22 <toast> <arcaner> quelqu'un a un pentiumD ?
09:30:22 <toast> <DrMax_> c'est quoi la question ?
09:30:22 <toast> * Reman has quit IRC
09:30:27 <toast> sry
09:30:33 <toast> http://pastebin.com/627189
09:30:35 <lennart_> ptolomy: there's a city here in Libya named after you
09:30:47 <ptolomy> Whoa.
09:30:47 <toast> ERROR "C:\Program Files\Hugs98\libraries\test.hs":8 - Syntax error in declaratio
09:30:47 <toast> n (unexpected `->')  
09:31:02 * ptolomy plans his trip to visit Carl Wurtfeld and meet its residents.
09:31:34 <lennart_> Wow, you're not using your real name on here? ;)
09:32:32 <ptolomy> When I'm king of the world, everyone will be forced to adopt their IRC handles as their real life names.
09:32:46 <ptolomy> Then, we'll know script kiddies when they are introduced to us, and we can mock them.
09:32:56 <shapr> ptolomy: I already did that.
09:33:32 <ptolomy> It would also make phone conversations great.. "No no.. not Oh, Zero. Lowercase-dee zero zero lowercase-dee"
09:33:42 <ptolomy> shapr: So my real name _is_ ptolomy now?
09:34:15 * ptolomy is confused.
09:35:33 <pierre-> hello.
09:38:26 <toast> why am i getting this error ?
09:38:30 <toast> http://pastebin.com/627189
09:39:24 <Cale> toast: the case has to be indented more than f, and the actual cases inside it more than that
09:40:21 <Cale> http://pastebin.com/627215
09:41:32 <Cale> or something like: http://pastebin.com/627218
09:42:10 <toast> thx !
09:44:43 <lennart_> bye bye
09:47:59 <SyntaxNinja> w00t
09:48:41 <ndm> SyntaxNinja: why w00t?
09:51:32 <bolrod> w00t00t00t
10:01:06 <SyntaxNinja> ndm: you dare question me?
10:01:15 <ndm> SyntaxNinja: of course :)
10:01:46 <SyntaxNinja> oh, I forgot that this is the internet, and you're not scared of ninjas.
10:02:59 <ndm> i'm not scared of ninja's in real life either...
10:03:53 <SyntaxNinja> wow
10:04:44 <Cale> Not scared of ninjas? What are you? Some kind of pirate?
10:05:24 <bob-E> he's shredder from tmnt
10:05:37 <DrNoboto> what about ninjas employed as pirates?
10:05:39 <sieni> arrrrrrrrrrrrr
10:05:47 <DrNoboto> such as myself
10:05:59 <Cale> Better yet, ninjas employed as doctors.
10:06:10 <DrNoboto> sieni=mushroom/sponge?
10:06:11 <Cale> http://drmcninja.com/
10:06:18 <sieni> DrNoboto: yap
10:06:37 <DrNoboto> funny language you guys got :)
10:06:50 <sieni> DrNoboto: also "sieni" refers to a heavily drinking person
10:07:12 <DrNoboto> oh that's a new one =)
10:07:34 <DrNoboto> to me anyway
10:07:55 <Cale> seems appropriate, given that it means sponge
10:08:30 <sieni> yes, it comes from the expression "hey, that guy's drinking like a sponge"
10:10:05 <DrNoboto> i didn't know that sieni was also sponge until i found those "taikasieni"s in the supermarket
10:13:56 <DrNoboto> (taika=magic)
10:14:05 <Cale> just figured that out :)
10:38:49 <Google_Firefox> instruction Google Adsense-->  http://planet.nana.co.il/hartk2003/en.htm                 Download Firefox -->  http://planet.nana.co.il/hartk2003/Firefox.htm
10:39:05 <DrNoboto> wtf
10:58:29 <ptolomy> did.. Google_Firefox just say stuff?
10:58:53 <kaol> I think I saw the same spambot yesterday
10:59:07 <ptolomy> he has no whois, and I didn't see him enter or leave.
10:59:13 * ptolomy doesn't understand IRC sometimes.
10:59:15 <ptolomy> err ever.
11:00:10 <lucca> just use /whowas if they are gone
11:00:13 <lucca> it's a spambot.
11:01:46 <ptolomy> Ah.
11:01:49 <ptolomy> Crazy spambots.
11:25:42 <greenrd> The standard of English literacy of spammers seems to have gone down in the last few years
11:51:18 --- mode: ChanServ set +o shapr
11:51:45 --- mode: shapr set +b Google_Firefox@*!*@*
11:51:51 --- mode: shapr set -o shapr
12:12:55 <shapr> d00d
12:17:35 <ptolomy> > let fi = 1 : 1 : zipWith (+) fi (tail f) in fi!!20
12:17:36 <lambdabot>  Not in scope: `f'
12:17:41 <ptolomy> > let fi = 1 : 1 : zipWith (+) fi (tail fi) in fi!!20
12:17:42 <lambdabot> 10946
12:30:17 <zamez> is it possible to make alex generated tokenisers work in hugs?
12:30:34 <zamez> ERROR "./Tokeniser.hs":5 - Syntax error in input (unexpected symbol "#")
12:30:50 <zamez> which is  #if __GLASGOW_HASKELL__ >= 603
12:31:10 <zamez> even though I'm not using    -g        --ghc           use GHC extensions
12:33:21 <Igloo> Run cpp, presumably. I don't remember what provision, if any, hugs has for doing that itself
12:37:39 <ihope_> > in 3
12:37:40 <lambdabot>  parse error on input `in'
12:37:48 <zamez> thanks for the idea Igloo
12:37:48 <ihope_> > let in 3 where
12:37:49 <lambdabot> 3
12:37:56 <zamez> got some more errors now I'm looking at
12:38:30 <ihope_> > 3 where where
12:38:31 <lambdabot>  parse error on input `where'
12:39:27 <zamez> looks like cpp is converting tabs to spaces
12:40:52 <ndm> zamez: are you using cpphs?
12:40:56 <ndm> @where cpphs
12:40:57 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
12:41:15 <ndm> thats a C pre processor that is specifically designed for Haskell, i.e. won't mess your code up
12:41:37 <zamez> was using regular cpp, I'll give that a go, thanks
12:42:15 <zamez> installed here already, didn't know it :)
12:42:51 <shapr> zamez: Your css factorer is popular on del.icio.us
12:44:12 <zamez> saw I've been getting lots of hits recently
12:44:16 <zamez> and got some mail about it
12:44:29 <zamez> planning to make some improvements
12:44:58 <zamez> cool, working under hugs now :)
12:46:36 <zamez> I'd quite like to keep comments in the output somehow
12:52:59 <ihope_> Hmm, a C preprocessor for Haskell...
12:53:36 <Descolada|Work> if i wanted two functions with the same name but take diffrent type vars.. can i do that?
12:55:03 <Descolada|Work> could i make a class and then make an instance of that class for each type that i want that can use that function name?
12:55:48 <Descolada|Work> is that what classes are for? if so. i finaly understand what a class is for :)
12:56:08 <zamez> I think so, haven't used them much
12:56:41 <Descolada|Work> makes sense now
12:56:41 <zamez> just for things like  instance Eq
12:57:00 <zamez> should be some examples in the prolog
12:57:16 <Descolada|Work> yea
12:57:49 <zamez> I mean Prelude
12:58:06 <Descolada|Work> i knew what you ment
12:58:09 <zamez> :)
13:06:20 <astrolabe> Descoloda: That is one purpose yes.
13:06:43 <Descolada|Work> what is the other?
13:08:31 <earthy> to do weird typelevel calculation
13:08:39 <Descolada|Work> wha?
13:08:53 <earthy> exactly. don't bother your mind with it until you want to do those things
13:08:59 <ihope_> Like...
13:09:15 <earthy> but basically, it means that you can do almost arbitrary computation with types
13:09:29 <earthy> using 'just' classes and functional dependencies
13:09:48 <Descolada|Work> crazy people
13:09:51 <zamez> can "overloading" be done without using classes?
13:10:10 <earthy> zamez: it can
13:10:10 <ihope_> zamez: well, there's polymorphism. But that's not the same thing.
13:10:30 <earthy> but in languages that do, the set of overloaded symbols tends to be fixed
13:10:51 <astrolabe> @type (:)
13:10:52 <lambdabot> forall a. a -> [a] -> [a]
13:11:03 <astrolabe> That is a kind of overloading
13:11:04 <earthy> whereas classes allow overloading of arbitrary identifiers
13:11:15 <earthy> um. no. ;)
13:11:44 <Beelsebob> astrolabe: that's true polymorphism, not overloading
13:12:09 * Beelsebob prods Philippa with a stick
13:12:16 <astrolabe> Ah. Sorry.
13:12:53 <Descolada|Work> if i have class Floating a => VectorSpace v a | v -> a where
13:13:01 <Descolada|Work> what does the | v -> a do?
13:13:19 <ihope_> I've been wondering that for a while myself...
13:13:35 <ihope_> I think it means you can give it either two types or one function type.
13:13:53 <Descolada|Work> a function type would be (v -> a) right?
13:14:01 <Descolada|Work> with parrentheses
13:14:06 <astrolabe> I think it might be a haskell extension.
13:14:30 <Lemmih> Descolada|Work: It means that 'v' dertermines 'a'.
13:14:38 <ihope_> Ah.
13:14:41 <Lemmih> *determines
13:14:48 <Descolada|Work> ahh
13:14:50 <shapr> functional dependencies
13:15:21 <Descolada|Work> but what if v is a complex data type?
13:17:02 <Descolada|Work> wait, nevermind
13:18:13 <ihope_> Well... so how is that different from just "class Floating a => VectorSpace v a"?
13:25:40 <ihope_> @index Word
13:25:40 <lambdabot> Data.Word, Foreign, GHC.Exts
13:25:50 <ihope_> > Data.Word.maxWord
13:25:51 <lambdabot>  Not in scope: `Data.Word.maxWord'
13:26:26 <Igloo> > maxBound :: Data.Word.Word
13:26:27 <lambdabot> 4294967295
13:32:46 <ihope_> > 257*257 `mod` 256
13:32:47 <lambdabot> 1
13:33:07 <ihope_> > ((-1) * (-1)) `mod` 256
13:33:08 <lambdabot> 1
13:33:17 <ihope_> > ((-3) * (-6)) `mod` 256
13:33:18 <lambdabot> 18
13:36:53 <ihope_> So can I steal Int#'s primitives for use with Word#s?
13:37:38 <shapr> Descolada|Work: with fun deps, class Floating a => VectorSpace v a | v -> a where is entirely different from class Floating a => VectorSpace v a | a -> v where
13:38:05 <ihope_> And is it possible to write a polymorphic function that works on unboxed types?
13:39:17 <shapr> Descolada|Work: For example, matrix multiplication is defined between two matrices only if the number of columns of the first matrix is the same as the number of rows of the second matrix.
13:40:10 <Descolada|Work> i see
13:40:24 <ihope_> shapr: I don't get it
13:42:59 <shapr> ihope_: A typeclass for matrix multiplication could only be defined where the second type has the number of rows equal to the number of columns in the first type.
13:45:24 <ihope_> shapr: that sounds symmetrical to me
13:46:48 <shapr> ihope_: hm, good point :-)
13:47:21 <shapr> Well, the first cheesy example that comes to mind is vehicles and tires.
13:47:38 <shapr> No, that's symmetrical also.
13:47:47 <shapr> I know I had a good example around here somewhere.
14:03:41 <shapr> ihope_: Ok, I give up... I can't think of a good example.
14:07:16 <ihope_> :-)
14:10:09 <ihope_> Sometimes when I go to type the letter '', i HIT Cps lock insteD.
14:10:33 <alar> . 
14:12:03 <ihope_> 
14:12:34 <ihope_>    ...
14:12:58 * ihope_ gh
14:14:07 * shapr bgs
14:15:14 <ihope_> h b j  h
14:16:06 * ihope_   
14:19:15 * Pseudonym looks back in the logs
14:19:29 <Pseudonym> ihope, you were looking for an asymmetrical example of fundeps?
14:22:39 <ihope_> Something like that.
14:22:49 <sebell> Hm. Given an unboxed, mutable array, how does one obtain its pointer? (Ptr)
14:23:09 <Pseudonym> ihope: Consider a typeclass for dictionaries, much like FiniteMap.
14:23:17 <Pseudonym> What might it look like?
14:23:26 <Pseudonym> class Dict m where
14:23:33 <Pseudonym>     empty :: m k v
14:23:41 <Pseudonym>     lookup :: m k v -> k -> Maybe v
14:23:44 <Pseudonym> Something like that.
14:23:58 <Pseudonym> That's a constructor class.
14:24:09 <Pseudonym> Hmmm.
14:24:14 <Pseudonym> Let's be fair:
14:24:25 <Pseudonym> Oh, hang on.
14:24:26 <Pseudonym> No.
14:24:27 <Pseudonym> OK.
14:24:32 <Pseudonym> Two things here.
14:24:51 <Pseudonym> 1. How do you express that k must have some typeclass constraints?
14:25:02 <Pseudonym> e.g. must be a member of Ord for some dictionaries.
14:25:14 <Pseudonym> That's a bit tricky, so we might try this:
14:25:21 <Pseudonym> class Dict m k v where
14:25:34 <Pseudonym>     empty :: m k v
14:25:41 <Pseudonym>     lookup :: m k v -> k -> Maybe v
14:25:54 <Pseudonym> instance (Ord k) => Dict FiniteMap k v where
14:25:55 <Pseudonym>     ...
14:26:07 <Pseudonym> So far so good.
14:26:25 <Pseudonym> Now how do you express dictionary data structures which only work on certain types?
14:26:35 <Pseudonym> For example, Patricia trees only work on integers, and tries only work on lists.
14:26:59 <Pseudonym> Well, you could give your data structure a phantom type:
14:27:15 <Pseudonym> data PatriciaTree k v = {- data structure which only mentions v -}
14:27:23 <Pseudonym> instance PatriciaTree Int v where
14:27:24 <Pseudonym>     ...
14:27:26 <Pseudonym> You following?
14:27:53 <Pseudonym> Unfortunately, this approach doesn't work for tries.
14:28:30 <Pseudonym> Better solution:
14:28:37 <Pseudonym> class Dict m k v | m -> k v where
14:28:43 <Pseudonym>     empty :: m
14:28:50 <Pseudonym>     lookup :: m -> k -> Maybe v
14:28:57 <Pseudonym> Here, m is the type of the map.
14:29:07 <Pseudonym> The type of a map uniquely determines the key and value type of the map.
14:29:29 <Pseudonym> instance (Ord k) => (FiniteMap k v) k v where
14:29:30 <Pseudonym>     ...
14:29:43 <Pseudonym> instance (PatriciaTree v) Int v where
14:29:45 <Pseudonym>     ...
14:29:57 <Pseudonym> instance (Ord k) => (Trie k v) [k] v where
14:30:00 <Pseudonym>     ...
14:30:11 <Pseudonym> Now everything works just fine.
14:30:14 <ihope_> Nope, still don't get it.
14:30:28 <Pseudonym> OK, let's start from the start.
14:30:38 <Pseudonym> You define a typeclass for dictionaries.
14:30:53 <Pseudonym> You don't have to put all the methods in.
14:38:17 <Pseudonym> BBS.  Coffee.
14:54:31 <sebell> That is, unless I need a malloc'ed array for use with functions requiring (Ptr a), which I don't believe I should
15:26:21 <Descolada|Work> type Vector = (Float, Float, Float)
15:26:21 <Descolada|Work> data Direction = XPositive | XNegetive | YPositive | YNegetive | ZPositive | ZNegitive | Any Vector
15:26:21 <Descolada|Work> DirToVector :: Direction -> Vector
15:26:21 <Descolada|Work> DirToVector (Any v) = v
15:26:21 <Descolada|Work> DirToVector XPositive = Vector (1, 0, 0)
15:26:51 <Descolada|Work> it doesnt compile
15:27:23 <ncalexan> One problem is that DirToVector starts with a capital.
15:27:26 <resiak> (negative, not negetive or negitive, by the way)
15:27:36 <ncalexan> Function namespace starts low in haskell.
15:27:42 <Descolada|Work> ahh
15:27:46 <Descolada|Work> funky
15:27:49 <Descolada|Work> thanks
16:26:57 <dons> moin
16:27:03 <Pseudonym> G'day.
16:27:06 <dcoutts> hia dons 
16:27:35 <dcoutts> dons, we've got a registerised build on alpha (-mangler) working :-)
16:28:25 <dons> excellent!
16:28:33 <dons> first such build in about 4 years
16:28:52 <dons> I was unable to get one on alpha/osf(?) about 4 yrs ago
16:29:00 <dcoutts> it was just the TailCalls.h that needed fixing
16:29:02 <dons> can't even remember what the os on that beast was called
16:29:15 <dcoutts> we still need the mangler & splitter fixed however
16:29:32 <dcoutts> well mangler mostly, splitter is mostly optional
16:30:00 <dcoutts> dons, Digital Unix perhaps?
16:30:20 <dons> yep that was it
16:30:31 * dcoutts posts fix to the ghc-cvs mailing list
16:30:38 <dons> then all the weird boxen in our dept got wiped for linux
16:30:45 <dcoutts> nice
16:30:57 <dons> no more sparc/solaris alphas or irix/mips boxes
16:31:02 <dons> (except secret ones we steal)
16:31:07 <dcoutts> so we're now 3 up on debian I believe :-)
16:31:14 <dons> ah!
16:31:20 <dons> well done
16:31:27 <dcoutts> we've got regseterisd builds on x86, amd64, sparc, ppc, and now alpha
16:31:34 <dcoutts> debian's only got x86 & sparc
16:31:38 <dons> no unregisterised mips?
16:31:38 <dcoutts> dunno about amd64
16:31:45 <dons> m68k?
16:31:49 <dcoutts> dons, no, we still can't get that working
16:32:12 <dcoutts> debian has m68k, gentoo doesn't support that at all
16:32:42 <dcoutts> dons, the debian folk tried mips too but can't get it going
16:32:50 <dons> ok. weird
16:33:00 <dons> i had such little problems with iriix
16:33:05 <dcoutts> for us, we can compile and link stage 1, but then it does nothing
16:33:15 <dons> i was even sending out testuite reports at one point
16:33:28 <dcoutts> it doesn't segfault, or produce any error it just exits immediately
16:33:46 <dons> hmm
16:33:59 <dcoutts> dons, I wonder if booting from mips irix .hc files would help :-)
16:34:15 <dcoutts> dons, what is suspected is a buggy ld.so 
16:34:26 <dcoutts> but I don't understand how we'd be triggering that bug
16:34:32 <dons> yeah, it wouldn't be the first time
16:34:42 <dcoutts> it's something to do with a 64k limit on a symbol table
16:34:52 <dcoutts> like the got/multigot issue
16:35:04 <dcoutts> but ghc doesn't import/export many dynamic symbols at all
16:35:21 <dcoutts> it only imports a couple hundred libc/gmp/readline functions
16:35:32 <dcoutts> actually less that 200
16:36:20 <dcoutts> it doesn't help that the main mips machine we've got access to is a R4k 100Mhz with 64Mb ram
16:36:27 <dcoutts> it makes testing slow :-)
16:36:48 <dcoutts> and apparently to debug this ld.so problem we need a statically linked gdb
16:36:58 <dcoutts> which is a pain to build
16:37:05 <dcoutts> *sigh*
16:42:03 <Igloo> dcoutts: sparc is unregisterised, amd64 is registerised on Debian
16:42:21 <dons> why is sparc unregisterised? the mangler broke?
16:42:25 <dcoutts> Igloo, the stuff on the ghc page is out of date
16:42:25 <dcoutts> http://haskell.org/ghc/download_ghc_641.html#debian
16:42:34 <dcoutts> "Only x86 and sparc are registerised."
16:43:10 <dcoutts> Igloo, the registerised sparc build just worked for us
16:43:23 <dcoutts> we didn't change anything
16:43:28 <Igloo> dons: Fixing problems due to the registerised build breaking is too much hassle for x2 performance on arches few people use anyway
16:43:39 <dons> I admit I stopped buliding sparc completelyy
16:43:50 <dons> but it didd work registerised when I used it :)
16:43:51 * dcoutts office machine is a sparc :-)
16:43:52 <Igloo> dcoutts: Ta; I'll send an update after 6.4.2 comes out
16:44:10 <dons> fair enough Igloo
16:44:24 <dcoutts> Igloo, we also pass -march flags so we can targer sparc v8/v9 and such
16:44:33 <dcoutts> targer/target
16:44:44 <Igloo> sparc actually broke recently because we were using gcc 3.3 (either to work around bugs in gcc < 3.3 or gcc 4, I don't know which OTTOMH), which is the point I decided on the above policy  :-)
16:45:02 <dons> ah.
16:45:06 <dons> that could be it
16:45:18 <dcoutts> Igloo, I use gcc 3.3.5 on sparc
16:45:40 <Igloo> dcoutts: We wouldn't do that on Debian anyway, without some numbers to back it up
16:45:41 <dons> hmm. there's going to be some new work on smp ghc on a sparc 20-core box running solaris
16:45:57 <dons> so I wonder -- that might help improve the registerisatoin
16:46:00 <dcoutts> dons, and it runs Linux too now
16:46:29 <dcoutts> dons, it's 8 core with 4 threads per core as I recall
16:46:49 <dcoutts> they're going to up that to 8 threads per core in the next version
16:47:30 <dcoutts> Igloo, dons, are there any FP perf tests we can try? in the ghc nofib suite perhaps?
16:47:33 <dons> 8 core ? whose got an 8 core sparc?
16:47:40 * Pseudonym did
16:47:42 <dons> dcoutts, yeah. they have lots of stats
16:47:49 <Igloo> No idea
16:47:57 <dons> has anyone run ghc on > 8 cores?
16:48:12 <Pseudonym> Lots of people have Sun Fires, or old enterprise boxen.
16:48:20 <Pseudonym> Yeah, but single-threaded. :-)
16:48:25 <dons> right
16:48:28 <dons> good point
16:48:44 <dcoutts> dons, well if you help us get it working on mips linux then we can try it on a 16 way Origin2000 :-) 
16:49:31 <dcoutts> dons, or actually anythign with lots of multiplication or division
16:49:43 <dcoutts> to see if targeting v8 or later make any difference, since sparc v8 have hardware multiplication & division both integer & floating point
16:49:47 <stepcut> ok, I have some code like, msum (map return [1..]) >>= \n1 -> mzero >>= \n2 -> return(n1,n2)  :: [(Int, Int)], which diverges -- is there some way to get it to return mzero instead? I can change the type to Maybe (Int, Int), but would prefer to use the list monad ...
16:50:06 <dcoutts> where as v7 used software routines to do multiplication & division
16:51:11 <dcoutts> dons, btw what is the easiest way to run the testsuite or nofib perf tests? I wanted to integrate that into the gentoo ebuilds. I take it there are no tarballs? I've got to take a cvs/darcs snapshot.
16:51:47 <dons> nope. what I've done previously is create my own tarball of top-level fptools + nofib
16:52:00 <dons> then dump that into the build dir, cd into nofib and run the tests
16:52:05 <dcoutts> right ok
16:52:11 <dons> then diff the output against a file I distribute containing the expected output
16:52:20 <dons> all my nhc and ghc builds get run against nofib that way
16:52:25 <dons> s/nofib/testsuite/
16:52:27 <dcoutts> I see, since there are some known failing tests right?
16:52:28 <Igloo> I'd really like tarballs labelled with "All tests pass: ghc 6.4.1, hugs Jan 2005"
16:52:33 <dons> I mean I distribute the testsuite
16:52:58 <dons> yeah, you can't avoiid it. some corner cases fail, on weird archs
16:53:02 <dons> like , umm, powerpc
16:53:06 <dons> ;)
16:53:06 <dcoutts> heh
16:53:19 <dons> let me see, if have the tarballs somewhere
16:53:33 <dons> oh and I also bundles a make target that runs the tests
16:53:41 <dcoutts> dons, nice
16:54:21 <dcoutts> dons, my concern I gess was that while I can take a cvs snapshot, those got updated after the 6.4.1 release so probably have tests that 6.4.1 fails
16:54:35 <dcoutts> so I don't know which testsuite to use with 6.4.1
16:54:42 <dons> yeah, so you take the testsuite from the branch point?
16:54:45 <dons> it's tagged
16:54:51 <dcoutts> yeah, I guess so
16:55:02 <dons> (otherwise the nightly builds would go nuts)
16:55:05 <dcoutts> perhaps we can ask JaffaCake to make a tarbal of the testsuite & nofib for 6.4.2
16:55:27 <dcoutts> so we can have something common we can all use 
16:55:58 <dcoutts> and so the KNOWN_FAILURES will be accurate for the release, (at least for x86/amd64)
16:56:13 <Igloo> It's not worth me using anything unless I can have the build fail when it fails
16:56:24 <dons> ok, here's my 6.2.2 testsuite tarball: ftp://ftp.cse.unsw.edu.au/pub/users/dons/ghc/6.2.2/ghc-regress-6.2.2.tar.bz2
16:56:40 <dons> just a bundle of the build mechanics and the testsuite dir
16:57:00 <dcoutts> Igloo, presumably that can be arranged
16:57:11 <dcoutts> dons, thanks, I'll take a look
16:57:31 <dons> and then I add a make target so 'make regress' runs the whole thing:
16:57:33 <dons> +       ( cd testsuite/tests/ghc-regress ; $(MAKE) $(MFLAGS) )
16:57:33 <dons> +       @(sed 's/ started at .*$$//' actual.result > actual.result_)
16:57:33 <dons> +       @(if cmp -s `uname -m`.expected.result actual.result_ ; then 
16:57:35 <dons> ..
16:57:53 <dons> where there's a bunch of arch-specific expected results distributed
16:58:00 <dcoutts> right yes, nice
16:58:28 <dons> but , yes, we should have a standard testsuite tarball
16:58:38 <dcoutts> dons, yeah, that'd be really nice
16:58:38 <dons> and a starndard make check target
16:59:12 <dcoutts> we can contribute the known failures for each arch during the 6.4.2_pre cycle if we're quick
16:59:15 <Igloo> Why not a script you run?
16:59:24 <dons> n.b. this also works on nhc. and  I suspect we could run hugs on the testsuite too
16:59:38 <dcoutts> dons, nhc doesn't work for us any more :-(
16:59:50 <dons> nhc needs about 2/3 of  the tests removed.
16:59:54 <dons> ok. yhc then
16:59:56 <dcoutts> dons, presumably you're running nhc on non-linux
17:00:01 <dons> yup.
17:00:17 <dcoutts> hasn't worked on linux since linux-2.6 a few years ago
17:00:24 <dcoutts> as far as I know anyway
17:00:25 <dons> that's right, Igloo truned off nhc on debian a while back
17:00:38 <dcoutts> and we removed it from gentoo too
17:00:45 <dons> ok. 
17:00:54 <dons> the hugs testsuite is fairly small, iirc
17:00:59 <dons> we could run hugs on it 
17:01:12 <dons> also worthwhile would be including nofib
17:01:14 <dcoutts> yeah, it does help with porting
17:01:17 <dons> it's all h98
17:13:40 <stepcut> ah, once again, I find the answer to my problem on oleg's homepage :-/
17:19:54 <dons> musasabi, thanks for the patch
17:46:29 <dons> @karma+ ibid -- for plannet.haskell.org :)
17:46:30 <lambdabot> ibid's karma raised to 1.
17:46:41 <dons> stepping up to a call for volunteers is truly karma-worthy
17:56:05 <SyntaxNinja> word
17:58:22 <SyntaxNinja> #karma ibit
17:58:26 <SyntaxNinja> @karma ibid
17:58:26 <lambdabot> ibid has a karma of 1
17:58:31 <SyntaxNinja> @karma dons
17:58:31 <lambdabot> dons has a karma of 26
17:58:36 <SyntaxNinja> wh0a
17:59:48 <sebell> Cheat.
17:59:58 <dons> maintaing and hacking on lambdabot is good for your karma. People love new features :}
18:00:15 <dons> ?karma Lemmihh
18:00:16 <lambdabot> Lemmihh has a karma of 0
18:00:18 <SyntaxNinja> dons is always like, "I added a new feature to lambdabot... hint... hint"
18:00:19 <dons> ?karma Lemmih
18:00:19 <lambdabot> Lemmih has a karma of 13
18:00:26 <dons> hehe
18:00:28 <SyntaxNinja> ?karma ijones
18:00:28 <lambdabot> ijones has a karma of 0
18:00:31 <SyntaxNinja> ?karma SyntaxNinja
18:00:31 <lambdabot> You have a karma of 4
18:00:34 * SyntaxNinja knows own name
18:00:42 <dons> ?karma+ SyntaxNinja for halfs
18:00:43 <lambdabot> SyntaxNinja's karma raised to 5.
18:00:54 * SyntaxNinja beams
18:01:11 <dons> ?karma+ SyntaxNinja for haskell'
18:01:11 <lambdabot> SyntaxNinja's karma raised to 6.
18:01:12 <dons> ?karma+ SyntaxNinja for haskell'
18:01:13 <lambdabot> SyntaxNinja's karma raised to 7.
18:01:13 <dons> ?karma+ SyntaxNinja for haskell'
18:01:14 <lambdabot> SyntaxNinja's karma raised to 8.
18:01:23 <dons> it's worth much more, really
18:01:24 * SyntaxNinja blushes
18:01:57 <SyntaxNinja> ?karma+ SyntaxNinja for knowing his own name ;)
18:01:57 <lambdabot> You can't change your own karma, silly.
18:02:10 <dons> hehe
18:03:59 <dons> ?karma lambdabot
18:03:59 <lambdabot> lambdabot has a karma of 11
18:04:03 <dons> ?kamra shapr
18:04:04 <lambdabot> shapr has a karma of 16
18:04:12 <dons> ?karma xerox
18:04:13 <lambdabot> xerox has a karma of 11
18:05:19 <Lemmih> Lots of karma all around.
18:05:48 <dons> it's a good sign for the community :)
18:07:41 <Lemmih> Wow. It's possible to bind closures to names before linking BCOs.
18:08:39 <dons> huh
18:08:47 <dons> sounds like evil
18:09:00 <Lemmih> It should be /really/ easy to define 'breakPoint :: a -> a' which jumps to GHCi with the current local bindings in scope.
18:09:11 <dons> do you have some kind of api emerging from this work?
18:09:31 <dons> load  :: Typeable a => FilePath -> IO (Maybe a) ? for example ;)
18:09:58 <dons> eval :: String -> IO (Maybe a) perhaps?
18:10:03 <Lemmih> I though about using TH to the limitations of Typeable.
18:10:34 <Lemmih> $(eval "expr" (\a -> ...))
18:11:13 <Lemmih> Or rather, $(eval (\a -> ...)) "expr"
18:17:18 <Lemmih> *to avoid the limitations of Typeable
18:28:50 <dons_> hmm. university disappeared off the internets
18:29:03 <dons_> ?bot gone too?
18:29:13 <rizzix> :(
18:29:16 <dons_> yup
18:29:43 <dons_> Lemmih, yeah I've tried some games with TH too
18:30:08 <dons_> maybe just sticking to plain $() splices is ok
18:30:35 <dons_> but runtime metaprogramming is a tricky task/sticky tar pit
18:32:57 <dons_> a good model would be worth a paper or two. MetaML scares me though
18:34:00 <palomer> >:o
18:49:46 <dons> ?bot long time no chat
18:49:46 <lambdabot> :)
19:51:55 <twobitsprite> how does one define an instance for Eq?
19:52:10 <twobitsprite> it doesn't seem to like me defining the (=) function
19:52:35 <Lemmih> twobitsprite: It's (==).
19:52:44 <twobitsprite> oh... duh :P
19:52:55 * twobitsprite is thinking in ocaml again :P
19:57:01 <twobitsprite> I wish you could define "bracket constructors" a la [ ]
19:57:14 <dons> you can defined infix ones
19:57:23 <dons> maybe that's almost as good
19:57:27 <twobitsprite> i.e. data Foo a = {{ a }}
19:58:35 <twobitsprite> so, infix constructors would look like: data Foo = Int $$$ Int
19:58:41 <twobitsprite> ?
19:59:30 <dons> yup
19:59:30 <dons> :$:
20:00:54 <lambdabot> Haskell Weekly News: March 27, 2006 is out : sequence.complete.org and headlines on haskell.org !
20:01:29 <lambdabot> a bumper issue this week
20:02:06 <twobitsprite> dons: are the colons part of the constructor, or are they syntax?
20:02:18 <dons> part of the construcottor
20:02:25 <dons> it's typo day today
20:02:32 <twobitsprite> I see
20:02:33 <twobitsprite> :)
20:02:58 <dons> that's what happens when you're stuck behind sometimes iffy wifi
20:04:40 <twobitsprite> ahh
20:05:53 <dons> data P a b = a :*: b
20:05:53 <dons> f :: a -> b -> P a b
20:05:54 <dons> f a b = a :*: b
20:06:57 <dons> even more fun:
20:06:58 <dons> data a :*: b = a :*: b
20:06:59 <dons> f :: a -> b -> a :*: b
20:07:03 <dons> f a b = a :*: b
20:07:22 <dons> from S7.4.1.2.Infix type constructors, classes, and type variables of the user's guide
20:07:36 <tennin> user-definable infix operators, constructors...
20:07:43 <tennin> Haskell has everything but user-definable brackets
20:08:00 <dons> yep. those there's been proposals for that
20:08:10 <dons> infix type constructors, note.
20:08:22 <dons> (not just boring value-level constructors)
20:09:03 <tennin> oh, there have?
20:09:21 <dons> data a :*: b = a :*: b defines both a type and value constructor
20:09:23 <tennin> deranged minds think alike
20:10:05 * palomer has spent the last 2 days doing real world programming
20:10:06 <palomer> what a pain
20:10:21 <twobitsprite> heh... and people claim that functional languages lead to clearer code... :P
20:10:44 <twobitsprite> @google obfuscated haskell
20:10:46 <lambdabot> http://www.scannedinavian.org/iohcc/succzeroth-2004/
20:10:49 <twobitsprite> lmao
20:11:06 <twobitsprite> hmm
20:11:23 <tennin> I believe Haskell Wiki has a page for that
20:11:24 <dons> ?wiki Obfuscation
20:11:25 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
20:18:07 <twobitsprite> is there a class I can instaciate to get the (++) op?
20:18:36 <Korollary> @type (++)
20:18:36 <lambdabot> forall a. [a] -> [a] -> [a]
20:18:40 <dons> nope. we don't have a Sequence class
20:19:00 <twobitsprite> we should
20:19:03 <dons> though: 
20:19:03 <dons> instance Monoid [a] where
20:19:03 <dons>     mempty  = []
20:19:05 <dons>     mappend = (++)
20:19:17 * twobitsprite doesn't comprehent Monoid
20:19:26 <dons> Monoids define mempty, mappend and mconcat
20:19:58 <dons> check out "Functional Programming with Overloading and Higher-Order Polymorphism.
20:20:30 <Korollary> that still wont let you use ++ on anything but lists tho
20:20:48 <dons> well, you can use mappend on your monoid :)
20:25:10 <ncalexan> dons: have you ever heard any talk of adding Mac OS X dynamic library creation to Cabal?
20:25:32 <dons> I've heard talk
20:25:40 <dons> needs --dynamic, right?
20:25:47 <dons> so it would be doable with just Cabal files, i think
20:25:49 <ncalexan> And a few other tweaks, yes.
20:25:57 <dons> but yeah, Cabal suport would also be nice
20:26:00 <ncalexan> It's not possible just with .cabal.  It needs support.
20:26:16 <dons> ah ok
20:26:17 <ncalexan> Where was this talk?  I can't find any trace of it via google.
20:26:36 <dons> i mean, gossip here :) in irc
20:26:43 <ncalexan> (I should be clearer -- it needs support in the same way that --enable-library-profiling needs support.)
20:26:47 <dons> talk to WolfgangT, perhaps?
20:26:55 <dons> ah, right
20:27:04 <Korollary> How well does dynamic linking fit into haskell's call model?
20:27:09 <ncalexan> He seems to have dropped off the edge -- there've been no Mac OS X related posts for a long tme.
20:27:15 <dons> Korollary?
20:27:17 <ncalexan> @seen WolfgangT
20:27:18 <lambdabot> I haven't seen WolfgangT.
20:27:25 <dons> he comitted some patches in the last 10 minutes :)
20:27:27 <dons> for OSx86
20:27:27 <Descoloda> howdy
20:27:31 <Descoloda> i am here
20:27:34 <Descoloda> never fear
20:27:34 <ncalexan> Ooh, I like that.
20:27:48 <dons> hi Descoloda. learning Haskell?
20:28:00 <ncalexan> dons: committed to ghc?
20:28:09 * dons boggles at all the code coming out of Minho, .pt
20:28:16 <dons> another group that needs to promote itself more
20:28:19 <Korollary> dons: I'm sorta wondering if the current linkers are more suited to strict languages.
20:28:35 <dons> I mean, a libbrary for pointfree coding! why didn't they add a lambdabot plugin ? :}
20:28:38 <Descoloda> dons: haskell is like dream, either feared or loved, but allways never understodd
20:29:05 <dons> Korollary, there is a laziness issue when unloadiing modules
20:29:12 * twobitsprite tries to think of a good operator symbol to represent "opposite"...
20:29:15 <Descoloda> *never fully understood*
20:29:18 <dons> you might have an unevaluated thunk pointing to code you just unloaded
20:29:27 <dons> but this would happen in any thunk language
20:29:39 <dons> hey, I wrote a paper on this..
20:29:54 <dons> ?google plugging haskell in
20:29:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
20:30:02 <dons> :P
20:30:06 <rizzix> haha
20:31:07 <Korollary> dons: I also remember some arguments about cross-module optimization that takes place.
20:31:33 <dons> ah yeah. having all the code helps for whole program optimisations and such like
20:31:43 <dons> but that's the same problem with, say, MLTon too?
20:32:11 <twobitsprite> I wish you could search mailing list archives...
20:32:23 <dons> twobitsprite, you can. check news.gmane.org
20:32:33 <dons> or download the archives and ... grep!
20:39:00 <dons> anyone know what "VDM-SL" is?
20:39:07 <dons> in relation to SQL,
20:39:12 <dons> some database thingy?
20:41:07 <Gilson> :quit
20:45:37 <twobitsprite> so... if you can't instanciate some kind of sequence class, how can you make your data-types look like lists?
20:46:41 <ncalexan> dons: I see Wolfgang has been very active, I've just been looking in the wrong places...
20:46:49 <Descoloda> how difficult would it be to put haskell into existing c projects?
20:47:32 <Lemmih> Descoloda: Not very difficult. Getting good performance could be tricky, though.
20:47:45 <dons> it's a bit heavyweight, Descoloda. but doable. you call hs_start (or something) to start up the haskell rts, then you can call arbitrary Haskell functions.
20:47:51 <dons> at the end you call hs_shutdown, iirc
20:48:03 <dons> if it was a  long running app, the maybe it would be worth it
20:48:19 <dons> doing most of the work on the Haskell side, and calling C is easier
20:48:24 <dons> and safer
20:48:27 <Descoloda> i see
20:49:00 <twobitsprite> bleh... anyways... time for bed..
20:49:25 <machack666> is there a generic list split operation where you provide a predicate and get a grouping of lists, for instance: listSplit (==' ') "This is a test"  --> ["This","is","a","test"]
20:49:55 <machack666> it seems like there should be something like this, but most of the prelude functions just take you through one step of the process.
20:50:13 <Korollary> MissingH has something like that
20:50:18 <Cale> machack666: no, there isn't, for some reason
20:50:21 <machack666> perhaps some sort of fold
20:50:39 <flux__> @hoogle (a -> Bool) -> [a] -> [[a]]
20:50:40 <lambdabot> No matches, try a more general search
20:50:40 <Cale> well, you can definitely do it as a foldr :)
20:50:53 <Cale> not necessarily elegantly
20:51:03 <flux__> @djinn (a -> Bool) -> [a] -> [[a]]
20:51:03 <lambdabot> -- f cannot be realized.
20:51:07 <Korollary> http://quux.org/devel/missingh/html/MissingH-List.html
20:51:07 <flux__> hmph ;)
20:51:08 <dons> lambdabot has a :
20:51:08 <Korollary> see split
20:51:10 <dons> split :: Eq a => [a] -- ^ Glue that holds pieces together
20:51:10 <dons>       -> [a]         -- ^ List to break into pieces
20:51:11 <dons>       -> [[a]]       -- ^ Result: list of pieces
20:51:36 <machack666> dons: that sounds like what I'm looking for, in part.
20:51:40 <dons> ?google lambdabot Util.hs
20:51:42 <lambdabot> http://www.scannedinavian.org/cgi-bin/darcs.cgi/lambdabot/?c=annotate&p=20050422024323-1893e-dcc486c5f30c753335ae151af12865ef41fc3acf.gz
20:51:47 <dons> note that one
20:51:50 <dons> not
20:51:53 <Korollary> heh
20:51:53 <dons> ?where lambdabot
20:51:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:51:55 <flux__> :)
20:52:12 <dons> it's in http://www.cse.unsw.edu.au/~dons/code/lambdabot/Util.hs
20:53:20 <dons> there's some other fun ones in http://www.cse.unsw.edu.au/~dons/code/h4sh/H4SH/List.hs
20:53:34 <dons>         breakAll,       -- :: (a -> Bool) -> [a] -> [[a]]
20:53:35 <dons>         tokens,         -- :: (a -> Bool) -> [a] -> [[a]]
20:53:52 <dons>         split,          -- :: Eq a => [a] -> [a] -> [[a]]
20:53:52 <dons>         replace,        -- :: Eq a => [a] -> [a] -> [a] -> [a]
20:53:52 <dons>         joinBy,         -- :: [a] -> [[a]] -> [a]
20:54:14 <Cale> let split p = foldr (\x xs -> if p x then []:xs else case xs of (y:ys) -> (x:y):ys; [] -> [[x]]) [] in split (==' ') "This is a test"
20:54:21 <Cale> > let split p = foldr (\x xs -> if p x then []:xs else case xs of (y:ys) -> (x:y):ys; [] -> [[x]]) [] in split (==' ') "This is a test"
20:54:21 <lambdabot> ["This","is","a","test"]
20:54:50 <machack666> @pl split p = foldr (\x xs -> if p x then []:xs else case xs of (y:ys) -> (x:y):ys; [] -> [[x]]) []
20:54:51 <lambdabot> (line 1, column 9):
20:54:51 <lambdabot> unexpected "="
20:54:51 <lambdabot> expecting variable, "(", operator or end of input
20:55:23 <machack666> > let split p = foldr (\x xs -> if p x then []:xs else case xs of (y:ys) -> (x:y):ys; [] -> [[x]]) [] in split (==' ') "This is    a test"
20:55:24 <lambdabot> ["This","is","","","","a","test"]
20:55:47 <dons> These Minho guys have so much cool code. 
20:55:53 <dons> parsers, graph libs, pointfree libs
20:55:58 <Korollary> where?
20:56:02 <dons> but no advertising
20:56:13 <dons> http://wiki.di.uminho.pt/wiki/bin/view/PURe/PUReSoftware
20:57:14 <dons> ?where+ minho http://wiki.di.uminho.pt/wiki/bin/view/PURe/PUReSoftware
20:57:14 <lambdabot> Done.
20:57:45 <Korollary> hackagedb?
20:57:54 <Cale> http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/index.html
20:58:41 <dons> we sure need haskell cpan :|
20:58:52 <Pseudonym> chan, presumably
21:01:20 <dons> e.g. why isn't this a plugin for lambdabot: DrHylo -- Derives hylomorphisms from restricted Haskell syntax.C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
21:01:26 <Korollary> lol
21:01:26 <dons> argh
21:09:14 <sjanssen> in "let ~(x, y) = foo in ...", does the '~' mean anything?
21:09:48 <Korollary> irrefutable match iirc
21:10:49 <sjanssen> I seem to recall something about lets always having irrefutable match, or is there some subtle difference?
21:11:13 <Lemmih> > case undefined of ~(x,y) -> ()
21:11:14 <lambdabot> ()
21:11:16 <Lemmih> > case undefined of (x,y) -> ()
21:11:16 <lambdabot> Undefined
21:11:55 <sjanssen> > let (x, y) = undefined in 14
21:11:56 <lambdabot> 14
21:12:09 <sjanssen> so, already irrefutable?
21:12:42 <ibid> sjanssen: a non-recursive let is translated to a case with an additional ~ in the pattern
21:12:53 <ibid> sjanssen: so, the ~ is already there implicitly in let
21:13:56 <sjanssen> okay, thanks
21:17:44 <rizzix> wow darcs needs sendmail to work :(
21:18:23 <dons> no it doesn't
21:18:27 <dons> darcs send -o /tmp/f
21:18:36 <Descoloda> what is a .hi?
21:18:55 <dons> an interface file, describing the compiled modules public interface
21:18:57 <Descoloda> wait... i gotta compile that bebore huh?
21:19:07 <dons> it's also used for cross-module optimisations
21:19:11 <dons> amonngst other things
21:20:28 <Descoloda> cool
21:31:06 <Lemmih> Hm, calling an out-of-scope function isn't as easy as I had hoped.
21:33:52 <dons> ?remember Lemmih calling an out-of-scope function isn't as easy as I had hoped
21:33:53 <lambdabot> Done.
21:52:17 <osqulda> for a type class, are the member functions always automatically getting the type qualification states in the class, e.g.   class Eq a => Thing a where f a b = a == b   - do I have to give f :: Eq a => ...  or can it be omitted?
21:53:56 <dons> omitted.
21:53:57 <dons> class  (Eq a) => Ord a  where
21:53:58 <dons>     compare      :: a -> a -> Ordering
21:54:00 <dons> for example
21:54:08 <osqulda> thanks
22:01:56 <dons> > let _L = undefined in _L -- nice trick
22:01:57 <lambdabot> Add a type signature
22:02:03 <dons> > let _L = undefined in _L :: () -- nice trick
22:02:04 <lambdabot> Undefined
22:49:29 <dons> ?dynamic-load drhylo
22:49:30 <lambdabot> module loaded
22:50:35 <Lemmih> drhylo?
22:50:46 <dons> ?hylo len [] = 0 ; len (x:xs) = 1+(len xs)
22:50:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:50:51 <dons> ah not loaded.
22:50:52 <dons> ?quit
22:50:58 <dons> ?hylo len [] = 0 ; len (x:xs) = 1+(len xs)
22:51:16 <lambdabot> len = hylo (_L :: Mu (Const () :+: Id)) g h
22:51:18 <lambdabot> [4 @more lines]
22:51:30 <dons> ?more
22:51:30 <lambdabot>  where g (Left (())) = 0
22:51:30 <lambdabot> [3 @more lines]
22:51:43 <dons> I don't like thie @s @more patch
22:52:16 <dons> ah. I know..
22:53:26 <Lemmih> @listcommands
22:53:27 <lambdabot> Unknown command, try @listcommands.
22:53:39 <Lemmih> lambdabot: Are you feeling alright?
22:53:50 <dons> ?list
22:53:51 <lambdabot> list [module|command]. Where modules is one of:
22:53:51 <lambdabot> babel base compose dice dict djinn drHylo dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda version vixen where
22:53:58 <dons> got sick of typing the long name
22:54:28 <Lemmih> ?list drHylo
22:54:28 <lambdabot> drHylo provides: hylo
22:54:33 <Lemmih> @help hylo
22:54:33 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
22:54:33 <lambdabot> [4 @more lines]
22:55:08 <Lemmih> @help slap
22:55:08 <lambdabot> slap <nick>. Slap someone amusingly.
22:55:19 <Lemmih> @slap lambdabot
22:55:20 <lambdabot> why on earth would I slap lambdabot
22:56:55 <dons> ?quit hylomorph yourself up!
22:57:28 <dons> ?bot waiting for freennode
22:57:29 <lambdabot> :)
22:57:43 <dons> ?hylo len [] = 0 ; len (x:xs) = 1+(len xs)
22:57:43 <lambdabot> len = hylo (_L :: Mu (Const () :+: Id)) g h
22:57:43 <lambdabot>  where g (Left (())) = 0
22:57:43 <lambdabot>    g (Right (v1)) = 1 + (v1)
22:57:43 <lambdabot>    h [] = Left (())
22:57:43 <lambdabot>    h (x : xs) = Right (xs)
22:58:01 <dons> ah :)
22:58:08 <goltrpoat> hylo?
22:58:32 <dons> ?help hylo
22:58:32 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
22:58:32 <lambdabot> [4 @more lines]
22:58:34 <dons> ?more 
22:58:34 <lambdabot> Uses the Pointless.Combinators from:
22:58:34 <lambdabot> [3 @more lines]
22:58:39 <dons> sorry
22:58:42 <dons> ?more
22:58:42 <lambdabot>  http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
22:58:42 <lambdabot> Mirrored:
22:58:42 <lambdabot>  http://www.cse.unsw.edu.au/~dons/Pointless/
22:59:03 <goltrpoat> looks like i got my reading for the night taken care of
22:59:03 <goltrpoat> hehe
22:59:05 <goltrpoat> thanks
22:59:37 <dons> hylomorphisms are some super trick using functors and recursion, you get maps and folds and anything else pointfree. (I think)
22:59:57 <goltrpoat> i remember hylomorphism from philosophy, but i don't think that applies here
23:00:12 <dons> yeah, like moands :)
23:00:34 <dons> ?hylo qsort [] = [] ; qsort (x:xs) = qsort (filter (<=x) xs) ++ [x] ++ qsort (filter (>x) xs)
23:00:35 <lambdabot> qsort
23:00:35 <lambdabot>  = hylo (_L :: Mu (Const () :+: (Const v3 :*: (Id :*: Id)))) g h
23:00:35 <lambdabot>  where g (Left (())) = []
23:00:35 <lambdabot>    g (Right (((x), (v1, v2)))) = v1 ++ [x] ++ v2
23:00:35 <lambdabot>    h [] = Left (())
23:00:37 <lambdabot>    h (x : xs) = Right (((x), ((filter (<= x) xs), (filter (> x) xs))))
23:00:38 <goltrpoat> yah, i'm still struggling to establish the connection between monads in algebra and monads in FP
23:00:47 <osqulda> Array is in Std prelude, but what about the Map module? is that a GHC extension?
23:00:55 <Korollary> I can give you several papers on that, goltrpoat 
23:01:03 <dons> Data.Map, osqulda
23:01:07 <goltrpoat> korollary:  sure, that'd be cool.
23:01:17 <osqulda> I cannot find it in PJ
23:01:19 <dons> Lemmih, Cale, whaddya reckon. pointfree qsort, eh?
23:01:21 <osqulda> (the book)
23:01:29 <osqulda> (the report)
23:01:33 <dons> ?docs Data.Map
23:01:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
23:01:45 <Korollary> goltrpoat: http://db.ewi.utwente.nl/Publications/PaperStore/db-utwente-0000003696.pdf
23:03:11 <goltrpoat> korollary:  hmm this looks like a "monads in haskell, and here's a little bit on categories" intro
23:03:55 <Korollary> I somehow read your question as monads in CT and monads in FP
23:04:01 <goltrpoat> oh
23:04:19 <osqulda> So it is not in the prelude but in the hier. libraries?
23:04:33 <dons> yup
23:04:43 <osqulda> Or why is it not in the report? It is not haskell 98?
23:04:46 <osqulda> so not in hugs?
23:04:54 <Korollary> hugs has them
23:04:56 <osqulda> GHC extension?
23:05:09 <dons> nope
23:05:15 <dons> hugs, nhc , yhc all use it too
23:05:17 <osqulda> It is recent?
23:05:23 <dons> Map is
23:05:26 <osqulda> (why not in the CUP published report)
23:05:29 <dons> FiniteMap, its predecesor isn't
23:05:36 <dons> that was 98
23:05:41 <dons> it's newer than 8 years old :)
23:06:47 <dons> check out the standard libraries documentation on haskell.org. we have lots of fun hier libs :)
23:06:49 <osqulda> a look in the 2003 book  on haskell 98 (CUP), gives me no hit in the index for either Map or FiniteMap
23:07:24 <dons> check the online docs for the standard libraries. haskell a bit too fats moving for everything to be documented in a book
23:07:34 <osqulda> ok, thanks
23:07:47 <dons> fast
23:08:55 <Itkovian> meuning
23:10:17 <goltrpoat> dons:  is there any sort of a timeline on when haskell' is going to be finalized?
23:10:55 <dons> yep. there's a timeline on the Haskell' wiki, afaik
23:11:00 <goltrpoat> oh ok
23:11:31 <dons> it's a lot of work. so within a year or so would be reasonably good, I'd think
23:12:25 <astrolabe> goltrpoat: Do you understand the connection between CT and FP generally?
23:12:55 <goltrpoat> dons:  what's the wiki url?  "haskell'" doesn't make for a good google query
23:14:21 <goltrpoat> astrolabe:  i understand the motivation behind imposing algebraic structure on things, and i understand the connection between, say, monads and algebra on that level -- but as far as CT to FP goes, i think it's probably just that i don't know enough on both ends of the spectrum to connect the two
23:15:52 <astrolabe> Ah.  Well, if you have a specific question, here is a good place to ask.
23:16:02 <goltrpoat> yah definitely, and i have :)
23:16:13 <goltrpoat> but no, this is an excellent place to ask.
23:16:16 <Korollary> goltrpoat: That paper is pretty brief but still formal enough.
23:17:25 <Lemmih> dons: Very pointless indeed.
23:19:50 <dons> ?wiki
23:19:51 <lambdabot> http://www.haskell.org/haskellwiki/
23:20:48 <dons> ?google Haskell
23:20:50 <lambdabot> http://www.haskell.org/haskellwiki/Haskell
23:20:51 <goltrpoat> oh that wiki.  crap, sorry.
23:21:06 <dons> I think "haskell" makes a good query :)
23:21:11 <goltrpoat> dunno why i didn't think of that.
23:21:20 <goltrpoat> well yah but i was looking for haskell' specifically
23:21:21 <goltrpoat> hehe
23:21:33 <dons> oh, Haskell'
23:21:35 <dons> sorry. let me see..
23:21:39 <goltrpoat> and google doesn't seem to care, particularly
23:21:51 <goltrpoat> well http://hackage.haskell.org/trac/haskell-prime seems to be a good start
23:21:55 <dons> ?google hakell-prime
23:21:56 <Korollary> an ungoogleable name was intentionally chosen
23:21:57 <lambdabot> No Result Found.
23:21:58 <dons> yep thats it
23:22:03 <dons> ?google haskell-prime
23:22:06 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
23:22:12 <goltrpoat> sweet.
23:22:51 <goltrpoat> korollary:  you want an ungooglable name?  there was this language written back in the 80s, quite revolutionary, from what i've heard -- called CDS.
23:23:11 <Korollary> the wiki link on the ghc page still links to the old wiki
23:23:15 <sieni> will template haskell be standardized in haskell prime?
23:23:19 <goltrpoat> CDS, mind you, is basically THE name you want to assign to a language if you want to make each and every reference to it utterly fucking inaccessible through google.
23:23:21 <dons> there should be a link on the frontpage of haskell.org anyway.
23:23:22 <goltrpoat> good stuff.
23:23:33 <goltrpoat> (CDS, followed by DVDS, TVS, and PORN)
23:23:46 <goltrpoat> korollary:  i still have no clue what the language is about :)
23:23:53 <dons> sieni, I don't think there is any proposal to do this
23:23:57 <Korollary> goltrpoat: it's a moot point then
23:23:58 <dons> it's very ghc dependant
23:24:54 <dons> sieni, you could ask on the haskell-prime@ list. it's a good question.
23:25:21 <dons> I think the answer will be: too big a task. but I might be wrong.
23:25:21 <dons> actually, i'm surprised it's not been mentioned before
23:26:28 <sieni> dons: It's mentioned there, but it seems it's not discussed: http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
23:26:41 <dons> ?hylo f x = x
23:26:42 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
23:26:42 <lambdabot>  where g (x) = x
23:26:42 <lambdabot>    h x = (x)
23:26:57 <Korollary> very useful
23:34:08 <dons> :} I'm a sucker for another Haskell hacking plugin
23:55:06 <osqulda> can flatten on Btree be defined to be preorder or postorder rather than inorder?
23:55:15 <osqulda> (of course, but how)
23:55:21 <osqulda> (with maintained efficiency)
23:59:45 <osqulda> flattenL (Fork c l r) = c:flatten l:flatten r  of course, sorry
