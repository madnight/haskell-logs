00:07:18 <Saulzar> It's very cool, hard to make good use of them without looking like a physics engine demo though :)
00:09:16 <Zertt> ej ole
00:09:43 <Zertt> anybody knowns about hds?
00:09:47 <Zertt> *dhs
00:09:57 <Zertt> distributed haskell
00:10:03 <Zertt> http://www-i2.informatik.rwth-aachen.de/~stolz/dhs/
00:10:47 <Zertt> It seems, that it was highschool diplom of one dude
00:11:04 <Zertt> but now it is unsupportted
00:12:01 <Zertt> anybody here?
00:12:24 <Saulzar> Yeah. Not heard of dhs though.
00:12:36 <jjinux> Hi, I'm right at the end of finishing my function.  It's returning a State MyState String--I'm using the State monad.  Now, from within main, how do I call the function and just print the string, ignoring the MyState which I no longer care about?
00:13:03 <Saulzar> jjinux, Take a look at runState and friends
00:13:09 <jjinux> Thanks.
00:14:23 <Zertt> is there something, like dhs?
00:14:26 <Zertt> or not?
00:14:51 <int-e> evalState looks good.
00:15:47 <__AL__> dcoutts, dons, Lemmih Yes!! It works!! Hs-plugins in AMD64!!!!
00:16:18 <__AL__> Compiler - ghc-6.4.2.20060309
00:19:25 <Zertt> what it does?
00:20:32 <__AL__> We can execute haskell code from String
00:20:46 <__AL__> http://www.cse.unsw.edu.au/~dons/hs-plugins/
00:21:00 <__AL__> Now it works on AMD64 machines
00:25:51 <Lemmih> Great.
00:40:34 <shapr> Good morning #haskell !
00:41:38 <shapr> Anything exciting happening?
00:43:23 <__AL__> Yes, hs-plugins compiled on AMD64 machine ;)
00:44:01 <shapr> nifty
00:44:24 <shapr> Is that a supported config now, or does it need custom frobbing?
00:45:58 <__AL__> Just use ghc-6.4.2.20060309 (stable)
00:46:13 <shapr> Sounds good
00:50:24 <__AL__> Now Yi works...
00:50:25 <Saulzar> Hmm, if I use hGetContents then immediately close a handle, I get no contents?
00:51:26 <jethr0> Saulzar: yes, that seems to be a recurring problem
00:51:29 <Saulzar> Seems slightly wierd, but if I'm not evaluating the string before the handle is closed it gives the empty string
00:51:33 <shapr> __AL__: spiffy! How do you like Yi?
00:51:38 <shapr> gutentag jethr0 
00:51:44 <jethr0> (partial) solution is to strictly evaluate the handle before closing it
00:51:48 <jethr0> hey shapr
00:51:56 <jethr0> i'm continuing my struggle with yampa :)
00:52:11 <Lemmih> Saulzar: hGetContents is lazy.
00:52:38 <jethr0> Saulzar: sry, didn't read your msg correctly. i thought you were talking about runInteractiveProcess. forget what i said
00:53:17 <int-e> otoh, hGetContents will close the file for you when it's done.
00:53:21 <shapr> Struggling how?
00:53:25 <shapr> Understanding, use, or what?
00:53:53 <jethr0> use, mainly. i just spent a few hours figuring out how to use derivative in combination with integral for my mouse input :)
00:54:46 <shapr> Have you read the Yampa Arcade paper?
00:54:58 <shapr> That's the closest thing to a cookbook.
00:55:01 <jethr0> of course. there's not much other "documentation" around, except for the three papers
00:55:16 <jethr0> well, it's far away from a real cookbock
00:55:18 <jethr0> ook
00:55:22 <shapr> Oook!
00:55:39 <shapr> Anyway, yampa is basically arrows, which is basically monads++
00:55:43 <jethr0> and yourself. how's evil project progressing?
00:55:47 <__AL__> shapr, Yes, extensible editor with cool language, rulez
00:56:11 <shapr> So if you figure out your data, and the chunk of code you want to use to ,um, 'combine' your data.. then you're good to go.
00:56:20 <shapr> I'm working on my Evil Project right now.
00:56:28 <jethr0> i'm aware of that. but afrp is also a continuous signal transformation DSL. and that part is giving me way more headaches than the arrows bit
00:56:45 <shapr> Oh, right.
00:57:03 <shapr> I don't have any good advice for that :-)
00:57:08 <jethr0> me neither
00:57:14 <jethr0> nor insight
00:57:33 <shapr> I suspect that dataflow programming might give you some insight.
00:57:41 <shapr> But I've never really tried that myself, so it's just a thought.
01:01:55 <shapr> At EuroHaskell 2004, John Hughes talked about a yampa-like system that used discrete steps instead of continuous signals. He said he ran into a bunch of different problems getting it to work. I don't know if he ever succeeded.
01:02:51 <Saulzar> As it is, a delay ends up as 1 frame, so you really need to think in discrete steps anyway (I think)
01:03:02 <JKnecht> this suggests fuzzification to me somehow.
01:03:06 <shapr> As for Yampa demos, pesco wrote a neat screensaver-like critter with Yampa and there's Frag.
01:08:52 <jethr0> shapr: i haven't seen critter yet, but i've got frag here for reference.
01:09:13 <jethr0> but i'm just trying to write a simple pong game before going on to sth more complex like a jump'n'run game
01:09:46 <shapr> You've seen robot soccer as well?
01:10:12 <jethr0> the 1 frame delay issue might become a problem at some point. but if i get to a playable framerate, 1 frame reaction delay might not be my biggest problem
01:10:21 <jethr0> no
01:10:30 <jethr0> but i've got a paper about it somewhere around
01:11:11 <shapr> I got it working once, it's neat.
01:11:33 <jethr0> ah, you mean the example in the afrp/yampa package. no, haven't looked at that either
01:14:23 <shapr> hoi Itkovian 
01:15:05 <Itkovian> hi shapr
01:17:14 <shapr> How's code?
01:21:33 <jjinux> Saulzar, wow, that took me a while ;)  I got it to work though.
01:22:39 <azuroth> anybody know a library for loading and writing any sort of audio files?
01:25:21 <jethr0> depends what you want to do with them. if you just want to read/write them any byte-oriented solution should work :)
01:26:21 <Lemmih> azuroth: I got a binding to SDLmixer.
01:28:08 <azuroth> sdlmixer, eh. hopefully that isn't as hard to install as openal ^_^;
01:34:25 <shapr> dbremner: Hiya, found anything new and nifty?
01:35:13 <dbremner> shapr - a couple things.
01:35:25 <shapr> Ooh, I want to hear.
01:36:25 <dbremner> shapr - there has been a lot of work on binary reordering.
01:37:06 <shapr> I like the recent Linux kernel reordering ideas, seen 'em?
01:37:27 <shapr> bok gour 
01:37:45 <dbremner> shapr - nope. I know that IBM has reordered AIX and OS/400.
01:38:11 <shapr> http://lwn.net/Articles/173882/
01:38:27 <gour> shapr: you greeted me?
01:38:36 <shapr> Yes! Greetings gour!
01:38:51 <gour> shapr: thanks. i quickly left the channel
01:39:06 <shapr> Yes, I wondered if someone scared you... 
01:39:08 * gour is busy to setup his laptop for wifi
01:39:11 <shapr> oh
01:39:28 <gour> soon i'm going to india and laptop has to be ready
01:39:38 <shapr> Neato, what for?
01:39:47 <dbremner> shapr - the kernel doesn't benefit from a lot of optimizations because they've disabled strict aliasing.
01:39:55 <gour> intensive study of vedic astrology
01:40:21 <shapr> Hm, I've studied vedic maths a bit, but that's the extent of my familiarity with the Vedics.
01:40:46 <gour> shapr: there will be time for it (hopefully :-)
01:42:13 <shapr> I had some Indian cowokers years ago. I learned lots of neat stuff from them. They took me to their temple, introduced me to Indian foods, and Sher-bidi cigarettes too :-)
01:42:30 <gour> shapr: see e.g. http://www.amazon.com/gp/product/0892131489/sr=8-1/qid=1142156501/ref=sr_1_1/104-1377561-7988756?%5Fencoding=UTF8
01:42:52 <shapr> dbremner: Was that one of the nifty things?
01:43:02 * gour is not itnerested for bidi, it's more 'hindi' than vedic :-)
01:43:08 <dbremner> shapr - nope.
01:43:55 * gour has to reboot his new laptop kernel, bbl
01:44:53 <shapr> Ah, literature in reaction to the Western medical separation of mind and body. I've often wondered why that continues.
01:45:47 <dbremner> shapr - there was a recent Atlantic article arguing that it was genetic.
01:52:54 <shapr> hiya davidhouse 
01:53:02 <davidhouse> hey shapr
01:53:08 <shapr> How's code?
01:53:33 <davidhouse> okay thanks :) been working on my blog, which means PHP.
01:53:45 <davidhouse> it's hard to start writing PHP after a long haskell session
01:53:47 <shapr> I use Haskell and ImageMagick for my blog.
01:54:03 <davidhouse> i have to keep reminding myself that 1) it's not functional 2) it's not lazy
01:54:23 <shapr> heh
01:54:31 <davidhouse> hows your code?
01:54:34 <shapr> I know the feeling. I often blow the recursion limit in Python.
01:54:49 <shapr> Or I write a bunch of code that relies on laziness, and Python rolls over and dies.
01:55:50 <davidhouse> what've you been working on then?
01:56:22 <shapr> In Haskell, only my Evil Project, for which I hope to get vulture capital.
01:57:05 <davidhouse> oh, that. does anyone actually know what your Evil Project is?
01:57:14 <shapr> Er, well, it's secret for the moment.
01:58:29 <jethr0> shapr hopefully knows
01:58:48 * shapr grins
01:58:58 <jethr0> and you misspelled voluptous
01:59:14 <shapr> Isn't it voluptuous?
01:59:18 <jethr0> yes
01:59:30 * jethr0 goes to grumble in the corner
02:17:25 <jethr0> which seems to have a noticeable effect on the channel
02:37:43 <LPhas> Hi, someone did install gtk2hs on macosx?
02:41:37 <xerox_> 'lo
02:42:00 <LPhas> hi poli
02:42:08 <LPhas> come to #haskell.i
02:42:14 <LPhas> t
02:42:17 <LPhas> :P
02:43:14 <xerox_> :-)
02:45:05 <xerox_> I'm trying but my internet is so sloppy.  I think I'm awfully lagged-to not count that it possibly will disconnect in no time...
03:04:05 <xs> hi. my code gets stack overflows with large data sets. what can i do about this?
03:04:36 <xs> (i'm just using foldr/filter.. so it seems weird to me.)
03:04:49 <jyp> Do you compile with ghc -O ?
03:05:01 <xs> no
03:05:14 <jyp> That would be a cheap thing to try
03:05:55 <xs> hm, well, i'm using ghci. i'll give it a go ghc, thanks
03:06:03 <Lemmih> xs: Try foldl'
03:06:27 <Lemmih> > foldr (+) 0 [1..1000000]
03:06:29 <lambdabot> Exception: stack overflow
03:06:31 <Lemmih> > foldl' (+) 0 [1..1000000]
03:06:32 <lambdabot> 500000500000
03:07:14 <xs> what's the difference?
03:07:25 <xs> (-O doesn't change it much, alas..)
03:08:10 <jyp> foldl
03:08:18 <jyp> foldl' is strict
03:08:29 <jyp> and processes the list left to right.
03:10:11 <xs> @libsrc foldl'
03:10:11 <lambdabot> foldl' not available
03:10:17 <xs> where is it defined?
03:10:29 <jyp> > List.foldl' (+) 0 [1..1000000]
03:10:30 <Lemmih> @index foldl'
03:10:30 <lambdabot>  Not in scope: `List.foldl''
03:10:30 <lambdabot> Data.List
03:10:36 <xs> ah, thanks
03:10:37 <jyp> > Data.List.foldl' (+) 0 [1..1000000]
03:10:38 <lambdabot> 500000500000
03:12:47 <xs> yay, thanks!
03:12:59 <xs> so is it better to use foldl instead of foldr?
03:14:35 <Lemmih> It depends on what you want.
03:14:51 <sjanssen> xs: with numeric things foldl is usually better, it can use constant stack space
03:16:35 <xs> hmm. except for the data being reversed, why would you use foldr then?
03:16:47 <xs> (say you accumulate a list..)
03:18:03 <sjanssen> > foldl (&&) False $ repeat False
03:18:07 <lambdabot> Terminated
03:18:18 <sjanssen> > foldr (&&) False $ repeat False
03:18:20 <lambdabot> False
03:19:10 <sjanssen> foldr gives the function it is passed a chance to "short circuit" the computation
03:19:28 <sjanssen> there are other reasons as well
03:20:28 <xs> ooh hmm. right. generally involving laziness?
03:21:02 <sjanssen> yeah
03:21:16 <xs> ok, i get it, great, thanks!
03:22:00 <xerox__> xs: http://cale.yi.org/autoshare/folds.png
03:22:59 <xs> those are nice
03:32:29 <jyp_> > foldl' (&&) False $ repeat False
03:32:32 <lambdabot> Terminated
03:32:42 <jyp_> > foldr' (&&) False $ repeat False
03:32:42 <lambdabot>  Not in scope: `foldr''
03:39:31 <shapr> shazam!
03:40:12 <Lemmih> badabum!
03:42:05 <Lemmih> And off it goes. To travel the world and return in a few hours.
03:44:11 <araujo> morning!
04:25:38 <tomshackell> @seen kombinator
04:25:39 <lambdabot> kombinator is in #haskell. I don't know when kombinator last spoke.
04:26:04 <tomshackell> kombinator: hello?
04:26:17 * Beelsebob smacks tomshackell with a trout
04:27:29 <tomshackell> hello Beelsebob 
04:27:33 <Beelsebob> morning
04:27:42 <Beelsebob> I'm getting an amusing error right now
04:27:43 <tomshackell> I'm not sure the trout was exactly necessary, but thanks anyway ;-)
04:27:59 <Beelsebob> Prelude.[] - Data constructor not found
04:28:17 <Beelsebob> somehow I think the nhc bit of hat-trans is b0rken a bit
04:28:29 <tomshackell> nhc or yhc?
04:28:37 <tomshackell> or hat-trans in general?
04:28:55 <Beelsebob> well, it's hat-trans giving the error - but I imagine that it's a problem with nhc's front end
04:30:35 <tomshackell> Beelsebob: usually you get Prelude.[] not found by doing something like import Prelude ()
04:30:46 <Beelsebob> nope
04:31:09 <Beelsebob> it compiles fine with hat not enabled, so ghc things it's fine... give me two ticks and I'll yhc it
04:31:37 <tomshackell> ehehe that might do anything :-)
04:31:38 <Beelsebob> ah... yhc doesn't like it - can't open Control.Monad.hi
04:31:49 <Beelsebob> sorry - Control/Monad.hi
04:31:54 <Beelsebob> what's the equiv?
04:32:07 <tomshackell> the equiv?
04:32:16 <Beelsebob> of Control.Monad
04:32:19 <Beelsebob> when using yhc
04:32:47 <tomshackell> it has Control.Monad ...
04:32:58 <Beelsebob> give me a bit to update my yhc install then
04:34:09 <tomshackell> must be quite old ...
04:34:17 <tomshackell> think it's hard Control.Monad a good few months.
04:34:21 <Beelsebob> it is - it's from back when it was yhcc and yhc on this box
04:34:45 <tomshackell> lol, yeah, update it ;-)
04:34:48 <Beelsebob> ... getting patches
04:36:03 <kombinator> tomshackell: hello
04:36:20 <tomshackell> kombinator: hiya :-)
04:36:28 <shapr> tomshackell: Any guesses how long it'll be before yhc is up to running gtk2hs?
04:36:52 <tomshackell> shapr: well it'll need FFI first ... which is on my "must do" list.
04:37:06 <shapr> Ok, guesses as to when FFI will work?
04:37:35 <kombinator> tomshackell: I've just read the mail; why the problem didn't show up on i386?
04:37:44 <tomshackell> shapr: it's what I'm working on at the moment.
04:37:48 <shapr> cool
04:37:52 <Beelsebob> tomshackell: the cpphs darcs rep is corrupt
04:38:02 <Beelsebob> patch 75 is unappliable
04:38:34 <tomshackell> kombinator: probably by pure (bad/good) luck.
04:38:46 <tomshackell> kombinator: it should affect i383 as well.
04:39:09 <tomshackell> Beelsebob: interesting ...
04:41:00 <tomshackell> I pulled it fine only yesterday.
04:41:13 <Beelsebob> the error is "Fri Jul 23 16:32:56 BST 2004 malcolm
04:41:13 <Beelsebob>   * [cpphs @ 2004-07-23 15:32:56 by malcolm]
04:41:13 <Beelsebob>   Do not export 'preDefine' from CppIfdef - it should rightly be internal
04:41:13 <Beelsebob> darcs: ./Cpphs.hs: openBinaryFile: does not exist (No such file or directory)
04:41:39 <Beelsebob> I wonder if it's a darcs bug - not respecting the pointer to where the repository should be put
04:41:47 <tomshackell> what version of darcs you using?
04:42:09 <Beelsebob> erm... some... hang on
04:42:34 <tomshackell> kombinator: have you tried the patch?
04:42:49 <kombinator> I'm trying it now
04:42:52 <Beelsebob> compiled on Oct 10 2005 at 11:58:35
04:43:42 <tomshackell> Beelsebob: works fine on mine, darcs version 1.0.3 (release)
04:43:47 <kombinator> it failed again...
04:43:55 <Beelsebob> I'll just go pull the latest darcs source
04:44:58 <tomshackell> Beelsebob: also works on the one at work, which is 1.0.6 (release) and 1.0.7pre1
04:45:06 <kombinator> tomshackell: so you're allocating a constructor on the heap only if it takes 0 args?
04:45:17 <Beelsebob> tomshackell: I'm pulling 1.0.6 just now
04:45:38 <Beelsebob> erq!
04:45:43 <tomshackell> kombinator: cinfo_alloc is for allocating cinfo's, so the node allocated should be the corresponding zcon.
04:45:43 <Beelsebob> pulling patch 20 of 3738
04:45:51 <tomshackell> Beelsebob: --partial ;-)
04:46:08 <Beelsebob> oh - what that do?
04:46:12 <Beelsebob> just grab the latest version?
04:46:35 <tomshackell> kombinator: but if you alloc a cinfo for a 2 arity constructor, for example, it doesn't have a zcon node, because it's not a zcon.
04:46:51 <tomshackell> Beelsebob: --partial says "Just get me the latest version, not the entire history"
04:46:56 <Beelsebob> ah, cool
04:46:57 <Beelsebob> :)
04:47:05 <shapr> Is there a way to flesh out a partial history?
04:47:23 <dcoutts> tomshackell, does yhc support exestantial data constructors?
04:47:53 <tomshackell> dcoutts: the type system is the same as nhc, so unless nhc supported them (which I doubt), then no.
04:48:29 <tomshackell> ... we really need someone to rewrite the type system, it's being quite a limitation ;-)
04:48:34 <dcoutts> tomshackell, wxhaskell & gtk2hs use them for their "set obj [ attr := value ]" syntax
04:48:41 <Beelsebob> tomshackell: sorry :(
04:49:33 <dcoutts> tomshackell, it could be done without, but it wouldn't be the same api
04:50:15 <tomshackell> Beelsebob: oh sorry bob, that wasn't a hint :-) I'd forgot that you'd looked at that.
04:50:25 <Beelsebob> np
04:50:33 <Beelsebob> sorry, just don't have time to jibble with it just now
04:50:52 <tomshackell> dcoutts: mmm, also no multiparameter type classes, no second rank types, etc. etc.
04:51:16 <tomshackell> Beelsebob: that's fine :-)
04:51:18 <kombinator> tomshackell: I've set a watchpoint (awatch) on the location which causes troble
04:51:24 <dcoutts> tomshackell, I don't think we need mptc or higher foralls
04:51:26 <tomshackell> kombinator: what's the problem this time?
04:51:35 <dcoutts> tomshackell, is yhc used to build in the same sort of way as ghc? ie on .hs file produces one bytecode file and then we link them together at the end? I'm just wondering about the gtk2hs build system.
04:51:42 <kombinator> it crashes in the same place
04:52:00 <tomshackell> kombinator: interesting ... turn on the sanity checker, it's new and improved ;-)
04:52:13 <kombinator> finfo_alloc (arity=0, stack=9, name=0x58c0a0 "Prelude.Num.Prelude.Int", code=0x0, numConsts=0, constTypes=0x0, constTable=0x0, obj=0x58c020)
04:52:13 <kombinator>     at info.c:62
04:52:13 <kombinator> 62          obj->info = (Info*)finfo;
04:52:34 <kombinator> that function gets the problematic heap node
04:52:48 <tomshackell> dcoutts: it currently doesn't link the bytecode together until runtime (although we want to do something a bit like Java's .jar files)
04:53:15 <tomshackell> kombinator: do you mean it creates it?
04:53:25 <kombinator> tomshackell: for sanity check - is DEBUG 1 in jonkers.c enough?
04:53:31 <kombinator> tomshackell: yes
04:53:43 <dcoutts> tomshackell, oh ok, so at the moment a package is just a big directory of bytecode files.
04:53:49 <tomshackell> kombinator: VERY_PARANOID 1 in mutator.c
04:53:56 <tomshackell> dcoutts: indeed.
04:54:33 <tomshackell> dcoutts: because it's runtime linked FFI has to be done by loading a .dll/.so with the C code in, is that a problem for gtk2hs?
04:55:22 <dcoutts> tomshackell, gtk2hs only links to C .so/.dll it doesn't static-link to any C libs.
04:56:34 <tomshackell> oh so it just accesses gtk's .so files directly?
04:58:35 <tomshackell> kombinator: any luck?
04:59:07 <kombinator> when I set heap size to 10K it segfaulted on GC, now I'm trying with default heap
04:59:15 <kombinator> and it's still running
05:01:58 * tomshackell has an idea.
05:02:04 <dons> \yow!
05:02:04 <lambdabot> If I am elected, the concrete barriers around the WHITE HOUSE will
05:02:04 <lambdabot> be
05:02:04 <lambdabot> replaced by tasteful foam replicas of ANN MARGARET!
05:04:28 <jethr0> \typo even
05:04:29 <lambdabot> forall a. (Integral a) => a -> Bool
05:04:35 * shapr grins
05:04:57 <shapr> ?typo even
05:04:58 <lambdabot> forall a. (Integral a) => a -> Bool
05:05:08 <shapr> ,typo even
05:05:17 <dons> nah.
05:05:19 <jethr0> i used to know all those nice permutations of commands, but dons didn't like me abusing the error correction feature, so i forced myself to forget them again :)
05:05:32 <jethr0> ah, there you are, dons ^_^
05:05:39 <dons> you only get a few 
05:05:56 <jethr0> i know, but you can still do quite some mischief with those few
05:06:18 <jethr0> ?play \x -> x
05:06:19 <lambdabot> Maybe you meant: lam pl
05:06:25 <jethr0> *damn*
05:06:39 <jethr0> "lam" must be new
05:07:14 <tomshackell> kombinator: try repulling, don't know whether it'll fix the problem but it was certainly a mistake. You'll need to rerun configure as well.
05:08:01 <kombinator> ok
05:09:20 <dcoutts> tomshackell, well with ghc of course we're producing an elf binary so we link against the gtk libs at link time, but they are all shared .so libs. For yhc I guess you just load up all the .so files we specify (in a package file?) and link up the foreign imports with symbols from the loaded .so libs.
05:11:44 <tomshackell> dcoutts: yup that'd probably work.
05:11:59 <kombinator> tomshackell: it still segfaults in GC (VERY_PARANOID is on, -h 10K)
05:12:14 <kombinator> i'll post the stack trace on #haskell-overflow
05:12:18 <tomshackell> kombinator: okay :-)
05:15:29 <Beelsebob> right - latest darcs got cpphs fine
05:15:35 <Beelsebob> yhc building now :)
05:15:38 <tomshackell> :-)
05:16:14 <Beelsebob> eh... why is yhc trying to build cpphs again
05:16:20 <Beelsebob> bah... no... not working again
05:16:35 <tomshackell> it doesn't build cpphs ...
05:16:35 <Beelsebob> when it does a non-partial pull of cpphs it fails earlier now
05:16:38 <ndm> Beelsebob: it doesn't build cpphs at all, it includes the source in directly
05:16:43 <Beelsebob> ah, okay
05:16:49 <tomshackell> what he said.
05:16:50 <ndm> if you do a non --partial it won't work
05:16:50 <Beelsebob> it failed earlier in the pull now
05:17:00 <ndm> the windows one knows this, and always tacks on --partial
05:17:07 <Beelsebob> that'll be why it doesn't work then
05:17:09 <tomshackell> yeah I should change that makefile.
05:17:55 * Beelsebob sorts that one
05:17:57 * tomshackell does and pushes
05:17:58 <Beelsebob> yay - building now
05:18:14 <tomshackell> wonder why it won't non-partial pull (works fine on mine ...)
05:18:56 <Beelsebob> linking the interpreter failed
05:19:21 <Beelsebob> first error: /usr/bin/ld: multiple definitions of symbol _ffic_addArg
05:19:33 <Beelsebob> ... lots more similar errors
05:19:48 <Beelsebob> all in ffi.o and FFI.o
05:20:03 <Beelsebob> sounds like an issue with case-preserving file systems
05:22:01 <tomshackell> *wonders why there is both ffi.o and FFI.o*
05:22:08 <lisppaste2> kombinator pasted "YHC gc bug" at http://paste.lisp.org/display/17782
05:23:30 <Beelsebob> ... there aren't
05:23:38 <Beelsebob> hang on a min...
05:24:20 <Beelsebob> nope... nothing in /usr
05:25:09 <ndm> tomshackell: reason for cpphs weirdness, there used to be both Cpphs and cpphs, i.e. two files with the same name, different case. this is fine on linux, screws up mac and windows
05:25:14 * Beelsebob wonders how to get ld to give more output
05:25:56 <Beelsebob> oh - tomshackell your latest patch broke something - platform.h:44: error: parse error befor QInt
05:26:46 <tomshackell> you need to rerun configure.
05:27:00 <lisppaste2> kombinator pasted "YHC gc bug (')" at http://paste.lisp.org/display/17783
05:27:56 <ndm> tomshackell: is there any way to have the configure thing automatically detect it needs rerunning and give an approriate error message
05:28:04 <ndm> perhaps and configure_version in configure.in
05:28:10 <ndm> and then add a check for it in platform.h
05:29:05 <ndm> or a makefile rule, configure_generated depends on configure_source, build rule is to give an error message saying rerun configure
05:30:01 <tomshackell> ndm: yeah that'd be possible ... either in fact.
05:30:36 <tomshackell> slightly prefer option 1 as it'll work on windows too.
05:30:41 <ndm> tomshackell: the makefile thing seems easiest, and might stop these mistakes
05:30:47 <ndm> windows has no configure script...
05:30:54 <tomshackell> oh yeah :-)
05:31:15 <ndm> when someone buys me a 64 bit windows machine, i'll write out hte config by hand
05:32:35 <Beelsebob> tomshackell: found the bug - the link command calls ghc and passes it both obj/FFI.o and obj/ffi.o
05:32:45 <Beelsebob> and the OS X linker thinks it's possible they're different files
05:33:38 <tomshackell> ahhh
05:34:20 <Beelsebob> so it needs src/runtime/BCKernal/Makefile to only have ffi.c and never FFI.c in
05:34:46 <Beelsebob> but now... /usr/bin/ld: Undefined Symbols: _primFFI_init
05:35:25 <Beelsebob> and also the names of some of the symbols in thread.o overlap with names of apple library calls
05:36:07 <tomshackell> Beelsebob: really which ones?
05:36:08 <ndm> tomshackell: you broke windows! #define QUARTER_TYPE char sound reasonable?
05:36:28 <tomshackell> ndm, yes it should be on 32bit machines :-)
05:36:39 <ndm> #define QUARTER_TYPE char
05:36:52 <Beelsebob> _semaphore_create, _thread_create, _semaphore_destroy, _semaphore_signal, _semaphore_wait
05:37:03 <Beelsebob> found in libm.dylib
05:37:04 <ndm> add that line somewhere in src/runtime/BCKernel/msvc/config.h please
05:37:19 <ndm> or windows doesn't work :)
05:37:22 <tomshackell> Beelsebob: in lib m!?
05:37:34 <tomshackell> lib m is the math lib isn't it?
05:37:47 <Beelsebob> dunno
05:39:02 <tomshackell> fairly sure, rather odd to place thread functions ...
05:39:48 <tomshackell> I'll go through and rename stuff later ;-)
05:39:55 <ndm> tomshackell: can you add that define above in the appropriate place
05:39:56 <Beelsebob> okay - so having made FFI.c lowercase in the makefile it no longer includes primitive.o in the link
05:39:59 <Beelsebob> and thus fails
05:40:23 <ndm> before the guy who keeps building it on windows send me an email :)
05:40:36 <tomshackell> sure :-)
05:41:16 <tomshackell> done
05:41:31 <Beelsebob> tomshackell: what do $@ and $^ in the makefile do?
05:41:56 <tomshackell> $@ means the target of an implicit rule and $^ mean all the sources.
05:42:11 <Beelsebob> all which sources?
05:42:18 <tomshackell> i.e. foo.o: foo.c blah.h
05:42:26 <tomshackell> $@ = foo.o, $^ = foo.c blah.h
05:42:41 <Beelsebob> yeh - but where does it get the name foo from
05:42:50 <Beelsebob> and why is primitive.o not included in the list
05:42:56 <ndm> thanks, windows now builds :)
05:43:17 <tomshackell> Beelsebob: depends which line of the makefile you mean :-)
05:43:23 <Beelsebob> the link line
05:43:44 <Beelsebob> $(LD) $(LDFLAGS) -o $@ $^ $(LDLIBS)
05:43:52 <tomshackell> in that case $@ is $(BIN) and $^ is $(OBJ)
05:44:03 <Beelsebob> the reason my link fails is that it doesn't try to link in primitive.o
05:44:57 <tomshackell> did you change any of the rest of the makefile?
05:45:15 <Beelsebob> yes -- line 14 s/FFI.c/ffi.c/
05:46:03 <tomshackell> ahh in that case it'll leave out the primitive FFI stuff, just rename the file PrimFFI.c or something and change the makefile :-)
05:46:27 <tomshackell> I'd forgot I can't have both FFI.o and ffi.o
05:46:32 <Beelsebob> ah, okay
05:46:51 <Beelsebob> if they're called FFI.c and ffi.c I won't have one of the files
05:47:02 <Beelsebob> because it'll have been overwritten when it got the other
05:47:12 <Beelsebob> so can you push the patch?
05:47:23 <tomshackell> ndm: ah the makefile method doesn't work so well ...
05:47:55 <tomshackell> ndm: though it'll probably be oaky in practice actually ...
05:50:21 <tomshackell> ndm: it'll break if the config.h.in has it's datestamp touched but is not actually changed (because configure won't touch config.h because it won't have changed, thus the dependency in the makefile isn't fixed by running configure). However, in all other cases it works fine.
05:51:06 * Beelsebob prods tomshackell until he jibbles a patch
05:51:08 <tomshackell> but none the less i think I'll just add a configure version since I don't trust that no-one will not manage to break it.
05:51:29 <davidhouse> is this yhc again?
05:51:46 <tomshackell> Beelsebob: no one is BCKernel/ffi.c the other is BCKernel/builtin/FFI.c but the .o files both end up in the obj dir.
05:51:54 <Beelsebob> ah, okay
05:51:56 <tomshackell> davidhouse: indeed
05:52:04 <davidhouse> tomshackell: and what exactly _is_ yhc?
05:52:09 <tomshackell> Beelsebob: I'll repatch it if you like.
05:52:16 <tomshackell> davidhouse: do you know what nhc is?
05:52:17 <davidhouse> @where yhc
05:52:17 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
05:52:28 <tomshackell> yeah or do that :-)
05:52:31 <davidhouse> tomshackell: nope. :)
05:53:52 <kombinator> tomshackell: what does mod_constNode() do?
05:54:33 <dons> Yet another Haskell Compiler ;)
05:54:48 <tomshackell> dons: ehehe, hadn't thought of that one :-)
05:55:01 <dons> and that would make nhc, Not another Haskell Compiler 
05:55:17 <davidhouse> pgsiwthc would be next.
05:55:19 <tomshackell> that's pretty acurate really given the current state of nhc ;-)
05:55:24 <davidhouse> "please god stop it with the haskell compilers"
05:55:28 <dons> truly Haskell must have more native code-producing systems than just about any modern language
05:55:48 <tomshackell> dons: ehehe well Yhc isn't "native code" producing ;-)
05:56:10 <dons> we really worked out how to spit out native code. meanwhile the python/perl/java/etc guys struggle
05:56:16 <dons> well, bytecode is close enough :)
05:57:26 <dons> and then JHC is Just another Haskell Compiler
05:57:29 <dons> I see a pattern!
05:57:53 <Beelsebob> tomshackell:  okay - yhi built this time - don't know if it works
05:57:53 <dons> gc == God, not another  Haskell Compiler 
05:58:21 <dons> hbc, Help, Bombarded with Haskell Compilers
05:58:27 <dons> maybe that's a stretch
05:58:46 <dons> UHC, hmm, hard. Umm. another Haskell Compiler
05:59:45 <dons> &uptime
05:59:45 <lambdabot> uptime: 10 hours, 37 minutes and 42 seconds
05:59:57 <davidhouse> dons, all these are really haskell compilers?
06:00:02 <dons> sure.
06:00:10 <davidhouse> wow. ghc is good for me :)
06:00:15 <Beelsebob> ghc, yhc, jhc, hbc, nhc and hugs
06:00:15 <dons> and that's not counting Hugs, and interpreter
06:00:20 <Beelsebob> any others?
06:00:30 <dons> also helium, hbi
06:00:30 <dons> ghci also counts, I guess
06:00:40 <Beelsebob> in that case yhe counts
06:01:01 <dons> hhmm, though if it shares a runtime, then maybe it shouldn't count
06:01:22 <dons> ghci is mostly ghc, but with a bytecode generator and interpreter. so maybe it doesn't count.
06:01:40 <dons> gofer too that's most of haskell
06:01:46 <dons> i learnt haskell on a gofer system
06:01:54 <davidhouse> why on earth would someone want to write another haskell compiler?
06:01:55 <Beelsebob> strangely - so did I
06:02:05 <Beelsebob> davidhouse: you wouldn't now
06:02:10 <davidhouse> you'd obviously have to love haskell but then it's all in C.
06:02:16 <Beelsebob> but yhc covers the very fast and non-optimising compiler
06:02:21 <dons> lml too possibly, for the really old school
06:02:25 <Beelsebob> ghc covers the slow and not-very-optimising one
06:02:33 <Beelsebob> and jhc the slow and extremely optimising one
06:02:49 <dons> davidhouse, often to do language research. it's academic research pushing haskell forward
06:02:55 <kombinator> tomshackell: did you look at the debug output?
06:03:02 <Lemmih> not-very-optimising? I beg to differ.
06:03:30 <dons> i didn't understand that either. seems to do the very-optimising case in my books
06:03:47 <tomshackell> kombinator: I did
06:04:01 <Beelsebob> Lemmih: by that I meant no where near as optimising as jhc
06:04:05 <dons> there's phrac too, but that's just a typechecker (with assoc types) so far.
06:04:35 <Lemmih> Beelsebob: But it still produces faster binaries. (:
06:04:44 <Beelsebob> true
06:04:50 <tomshackell> kombinator: I couldn't see what was going wrong ... it looks like the node in question was never threaded.
06:05:05 <Beelsebob> but the intent of jhc is to produce faster binaries eventually
06:05:06 <dons> jhc gets the loops better, right? but there's a lot of other things to do too :)
06:05:16 <kombinator> the last line is Checking 0x535a60[308]
06:05:29 <tomshackell> tomshackell: and it must have been fine before the GC (because it sanitied okay)
06:05:33 <kombinator> the node is created by mod_constNode()
06:05:38 <Beelsebob> tomshackell: you need to add Test.QuickCheck to yhc
06:05:40 <Beelsebob> it's easy to add
06:05:50 <dons> davidhouse, what did you mean by "then it's all in C"?
06:05:52 <tomshackell> Beelsebob: feel free :-)
06:05:56 <Beelsebob> k
06:06:01 <dons> most (?) haskell compilers are written in haskell.
06:06:15 <davidhouse> oh?
06:06:25 <tomshackell> kombinator: yeah mod_constNode creates constant nodes that are placed in constant tables, e.g. Int 3, Float 3.0 ...
06:06:44 <dons> though it is true that the runtime systems, a small but crucial part, are going to be in C -- you need fast garbage collection and scheduling
06:06:52 <davidhouse> dons, via clever bootstrapping? or is there one root compiler which everything else is compiled using?
06:07:03 <dons> via non-clever bootstrapping. 
06:07:07 <dons> just like gcc
06:07:12 <dcoutts> davidhouse, ghc requires ghc to compile :-)
06:07:21 <Beelsebob> davidhouse: ghc bootstraps from gcc, yhc bootstraps from it's interpreter
06:07:25 <Beelsebob> (which is written in c)
06:07:26 <davidhouse> any bootstrapping is clever in my eyes.
06:07:27 <dons> haskell people are good with recursion :)
06:07:38 <tomshackell> Beelsebob: it *could* bootstrap from it's interpretter, it currently uses ghc
06:07:43 <Beelsebob> true
06:07:48 <tomshackell> because I haven't got round to writing the makefiles ;-)
06:07:51 <Beelsebob> hehe
06:08:02 <Beelsebob> and also you need to make it able to package up binaries
06:08:03 <davidhouse> how does gcc bootstrap?
06:08:05 <Beelsebob> rather than hbcs
06:08:15 <Beelsebob> with gcc
06:08:18 <Beelsebob> on a different box
06:08:20 <dons> it's supposed to be very hard though.
06:08:21 <Lemmih> davidhouse: It's simple: fixM (\compiler -> compiler compiler_src) (:
06:08:31 <dcoutts> tomshackell, that'll make life easier for the various arches that don't have ghc yet. http://packages.gentoo.org/search/?sstring=ghc
06:08:56 <dcoutts> tomshackell, the other gentoo devs always tease us about ghc needing ghc to build on end users machines
06:09:22 <dons> dcoutts: build from .hc src :) the devs and users love it
06:09:34 <dons> since you get make -jN and a 20 minute build
06:09:43 <dcoutts> dons, really?
06:09:45 <dcoutts> wow
06:10:09 <dcoutts> we tried ghc's normal build from source style and it doesn't work with -j2
06:10:19 <dons> there was a pseudo-honour when I switched ghc/openbsd to .hc files, and it was no longer the slowest package on the system to build
06:10:23 <dcoutts> sadly, it almost works, but now quite
06:10:30 <dcoutts> dons, heh :-)
06:10:33 <tomshackell> ndm: it'll tell you to reconfigure now if there's a version mistmatch between config.h and platform.h
06:10:37 <dons> the normal one almost works, not quite. but gcc src -- make works it out better
06:10:48 <dcoutts> dons, how do you build the .hc pacakge?
06:11:03 <dcoutts> I mean how do you prepare it rather than how the users build it
06:11:37 <tomshackell> #
06:11:38 <dons> you do a nightly-build (or similar) following the bootstrap instructions, but instead of copying the .hc src to a new machine, you copy it to your webserver :)
06:11:51 <dcoutts> dons, so which arches do you build for on OpenBSD ?
06:11:53 <dons> the build cripts bundles up a .hc tarball for you
06:12:06 <dons> amd64, x86 and sparc
06:12:14 <dcoutts> ok
06:12:27 <dcoutts> we've also got ppc, ppc64, alpha and hppa
06:12:29 <dons> though sparc is getting a bit slow and tedious.
06:12:55 <dons> yeah, i haven't pursued building on the other boxes too much. not a lot of demand
06:13:23 <dcoutts> with a .hc the sparc build wouldn't be so bad :-) building ghc on my sparc takes almost 12 hours
06:13:43 <dcoutts> dons, but you need .hc files for each arch right
06:13:45 <dons> ah, yeah not so bad at all. more like 2 hrs from memory
06:13:49 <dons> yes. for each arch
06:14:18 <dcoutts> ok, I'll see of any of my gentoo helpers want to investigate
06:15:02 <dons> see here for example: ftp://ftp.cse.unsw.edu.au/pub/users/dons/ghc/6.2.2/
06:15:41 <dons> so the problem is that when a new release comes out, you need to then do a build to produce a .hc bundle on all the machines
06:15:46 <dons> which can be tedious
06:15:56 <tomshackell> kombinator: right I have to head off, good luck finding the bugs. I should have access to a 64bit machine on monday (hopefully) so I might be able to have a go then.
06:16:17 <kombinator> see you
06:17:10 <Beelsebob> tomshackell: do you have a Random module somewhere in there or do I need to add it?
06:17:11 <tomshackell> kombinator: thanks for your help :-)
06:17:20 <tomshackell> Beelsebob: no that still needs to be written ;-)
06:17:28 <tomshackell> right see you all later :-)
06:17:32 <Beelsebob> see you
06:17:34 <dcoutts> dons, we have to do the same to prepare binaries for our ghc-bin package
06:18:36 <dons> ah, true.
06:18:50 <dcoutts> though we don't need to update those immediately
06:19:05 <dcoutts> since for example one can build ghc-6.4.1 with ghc-bin-6.4
06:19:13 <dons> right, you just need something that'll build the compiler.
06:19:24 <dons> or 6.2.2 i would think?
06:19:28 <dcoutts> right
06:20:07 <dons> maybe  I should write a page on the wiki for C bootstrapping for packagers
06:20:34 <dons> since it's a frequent topic, and no one, still, seems to do it other than openbsd
06:20:43 <dons> some script support to generate the .hc bundles would help
06:20:44 <dcoutts> yeah, that'd be interesting
06:21:30 <dons> with some os's moving to more bsd-ports style building of packages by users, cutting down time might be worthh it
06:22:20 <dcoutts> yeah
06:23:24 <dcoutts> and splitting out some of the ghc bundled libs would help too
06:24:20 <dons> you only build the libs once  normal and once  prof though?
06:24:30 <dcoutts> yes
06:24:37 <dcoutts> esp. X11, HGL, OpenGL, OpenAL, GLUT and the old hslibs
06:24:39 <dons> but there are some libs in there that are rarely used and could be moved
06:24:46 <dons> esp. hslibs yep.
06:24:55 <dons> and then we can move fps and hs-plugins in :)
06:25:03 <dcoutts> yay
06:25:17 <dcoutts> there's no problem for us if these things are seperate packages, we can track dependencies properly
06:25:18 <vincenz> jethr0: ping
06:25:34 <dons> oh, so you also bundled up fps for the hmp3 port too ?
06:25:44 <jethr0> vincenz: pong
06:26:18 <dcoutts> dons, I just included fps into the hmp3 ebuild because you don't plan on maintainig it as a seperate package
06:26:21 <vincenz> jethr0: When do you sleep?
06:26:29 <dons> right.
06:26:58 <dcoutts> http://haskell.org/~gentoo/gentoo-haskell/portage/media-sound/hmp3/hmp3-1.0.ebuild
06:27:02 <dons> ah, so you grab it off the server, but just buiid it with local scope in some scratch dir?
06:27:08 <jethr0> haven't slept yet. my sleep rythm is out of kilter again. but i really want to get sth done, so i'll go to sleep sometime later
06:27:33 <Saulzar> You must be a programmer or a student, or both
06:28:00 <dons> ?localtime dons
06:28:03 <lambdabot> Local time for dons is Mon Mar 13 01:28:07 2006
06:28:04 <jyp> receipe to get something done...
06:28:08 <dons> sleep time!
06:28:09 <jyp> 1. Log off of IRC
06:28:11 <jethr0> Saulzar: what made you say that on the haskell channel. what's the percentage of academic programmers here who don't have the tightest of work hours? plus it's sunday
06:28:16 <shapr> jyp: truly
06:28:18 <Saulzar> ?localtime saulzar
06:28:24 <dcoutts> dons, well actually it gets put onto the gentoo mirrors, but yes it just builds it in a sandbox, installs it into a temp dir and then merges it into the root filesystem
06:28:26 <shapr> @timein Saulzar 
06:28:27 <lambdabot> Local time for Saulzar is Mon Mar 13 03:27:12
06:28:34 <Saulzar> Time for work :)
06:28:45 <dons> jethhr0, 87% 
06:28:47 <jethr0> jyp: partly. but i like it in here :)
06:28:53 <jyp> :)
06:29:00 <dons> Saulzar, you across the ditch?
06:29:11 <dons> I think I worked that out once before.
06:29:23 <jethr0> vincenz: anything else you pinged me for?
06:29:27 <Saulzar> Yeah, 2 hours ahead
06:29:29 <shapr> In my experience, this channel is great for shaping ideas and answering questions, but distracting when you just want to get stuff done.
06:29:44 <dcoutts> dons, looking at the src_unpack is usually a good way of finding out what the packagers needed to fix.
06:29:46 * shapr suspects Saulzar ~= olliej
06:30:01 <dcoutts> dons, eg for hmp3 we had to chmod +x ${S}/configure
06:30:15 <Saulzar> shapr, He goes to the same Uni as me (same city)
06:30:16 <dons> ah, I should have done that in the tarball
06:30:28 <shapr> Saulzar: Ah, I see.
06:30:30 <Saulzar> In fact he's in the room next door.
06:30:40 * shapr remembers now.
06:30:44 <jethr0> well, i'm in phase for beyond explorative with my yampa pong game, so shaping ideas would be a good idea for me.
06:30:50 <dcoutts> dons, right, because cabal doesn't run it otherwise, and if confgure doesn't get run then the compilation fails later :-)
06:30:55 <shapr> I remember now. I can't remember where it started, I just remember doing... what they told me.
06:30:55 <vincenz> jethr0: no just curious when you slept...
06:31:01 <dons> dcoutts, thanks for pointing that outt, in fact. but somme new cabals do handle it
06:31:03 <vincenz> jethr0: you've been up since at least last night
06:31:05 <dons> they run: sh connfigure, iirc
06:31:10 <shapr> jethr0: You got yampong working?
06:31:21 <dcoutts> dons, ah, ok. We're using cabal-1.1.3
06:31:21 <jethr0> hehe. k, i'll go back to watching galactica then
06:31:37 <jethr0> vincenz: i woke up at 9pm yesterday :(
06:31:43 <vincenz> ah
06:31:50 <vincenz> I know the feeling
06:31:50 <Saulzar> Ouch
06:32:09 <jethr0> shapr: i've had a  semi-working version for a while now, but i'm refactoring it all the time until (i hope) at some point i'll get where i want.
06:32:34 <jethr0> but progress is beyond slow...
06:33:06 <dons> ok, night guys. my nightly cronjobs starting up is the sign..
06:33:10 <shapr> Regular sleep schedule how-to: 1. no stimulants after 3pm 2. exercise at least one hour a day 3. eat three meals every day at the same time 4. no alcohol 5. go to sleep when you're tired.
06:33:29 <shapr> It's amazing how many years it took me to figure that out.
06:33:38 <jethr0> shapr: also, i've got 700 frames but it's really visually pleasing. so i'll try to restrict it to 60fps or sth to see if i get less flickering out of that. and yes, double buffering is already enabled
06:33:38 <vincenz> shapr: damn
06:33:45 <dons> 6. go to bed before your cron jobs wake up
06:33:48 <shapr> jethr0: In that case, dump the url to your repo on the yampa list.
06:33:52 <vincenz> shapr: I fail on 1, 2, and 3
06:33:55 <Saulzar> cron is evil, it starts in the middle of the day
06:34:05 <Saulzar> I fail on 1 3 and 5
06:34:06 <jethr0> shapr: i fail on 1 2 3 and 5
06:34:13 <vincenz> yeah I fail on 5 too
06:34:17 <vincenz> I start smoking and drinking cigarettes
06:34:21 <vincenz> err coke
06:34:29 <shapr> I realized that staying up late kills the next day for me.
06:34:33 <dons> shapr, i agree. i was all over the place till i did these things you suggest
06:34:41 <dons> 6. wake up at the same hour
06:34:43 <dons> that helped _a lot_
06:34:50 <shapr> And that I'm most productive and clueful when I get up in the morning. Thus, all these things are for my own efficiency.
06:34:52 <Saulzar> Staying up late only kills you the next day unless you always stay up to the same time...
06:34:54 <jethr0> shapr: damn, my cron job is at 7am and i've witnessed that too today
06:35:02 <vincenz> dons: you assume waking up is decideable
06:35:06 <vincenz> dons: I can never get out of bed
06:35:15 <shapr> vincenz: Alarm clock... across the room
06:35:35 <shapr> So that you have to crawl out of bed, scurfle under the stuff, find the clock, and by that time my brain is almost moving.
06:35:50 <vincenz> shapr: I've done 3 alamr clocks accross my appartement
06:35:54 <vincenz> shapr: sometimes they're off when I wake up
06:35:57 <vincenz> unexplainably
06:36:00 <shapr> Then I remember, "hey, I have some really cool stuff to do today, I *want* to wake up!"
06:36:00 <jethr0> i'm not too worried. i often get a lot done during my weird sleep days. i might be more productive with a strict sleeping schedule, but with me it _very_ dependent on the right mood and i usually get into that only after 8pm or so
06:36:14 <jethr0> and if i want to get sth done _in_ that mood, i'll have to stay up for a while
06:36:19 <dons> lucky my gf wakes up a 7.30, so that is sort of a kick in the head each day.
06:36:20 <vincenz> jethr0: trust me, regular hours are a LOT more productive
06:36:31 <vincenz> jethr0: yeh me too, and sometimes I just don't feel like getting up quite yet
06:36:41 <jethr0> vincenz: i know. but without sth forcing me to work, my moods are pretty important
06:36:46 <shapr> jethr0: Yeah, it's true. The flow mood comes more often when you have all those regular things.
06:36:59 <jethr0> yup
06:37:01 <jyp> Has anyone compile nhc lately?
06:37:10 <jethr0> k, bbl
06:37:22 <shapr> jethr0: So recruit a partner, and make your goal a startup using this code you're developing.
06:37:45 * vincenz wants to recruit a partner for personal reasons
06:38:33 <dcoutts> jyp, last time I compiled nhc was on linux 2.4. It hasn't worked since.
06:38:58 <shapr> jethr0: Alternatively, make a single overall goal, and then very small goals that you can accomplish in an hour that each get you one step closer to the big goal.
06:39:03 <jyp> dcoutts: too bad. thanks for the info anyway.
06:39:09 * shapr is doing that right now.
06:39:19 <dcoutts> jyp, your best bet is yhc
06:39:30 <shapr> Anyone have get-it-done advice for me? :-)
06:39:55 <jyp> dcoutts: actually I have nothing special to do with nhc, I just need to test my new collections package with it
06:39:59 <nnunley> Ah... No parrot... perl module, compiled
06:40:11 <vincenz> shapr: use a top-down approach
06:40:20 <nnunley> Doh.  Sorry, all.
06:40:25 <shapr> vincenz: How so?
06:41:26 <vincenz> shapr: start with the highlevel relations before going down into the details
06:41:43 <shapr> Yeah, that makes sense.
06:42:38 <shapr> Though the first time I end up doing it from the bottom because I don't know what I'm doing.
06:42:44 <vincenz> ah
06:42:55 <vincenz> yes you need enough bottom up instantiations for an undertanding
06:43:00 <vincenz> but only for understanding
06:43:04 <vincenz> once you know a field you can do top down
06:43:10 <shapr> yeah, true
06:43:36 <vincenz> you know 'I know this' 'I know that' 'I know that'
06:43:48 <vincenz> and then through interpolation and extrapolation you can get anywhere at the highlevle map
06:48:46 <xerox__> @seen bourbaki
06:48:46 <lambdabot> I saw bourbaki leaving #haskell-blah 5 days, 23 hours, 51 minutes and 6
06:48:46 <lambdabot> seconds ago, and I have missed 1 day, 19 hours, 31 minutes and 39 seconds
06:48:46 <lambdabot> since then.
07:03:33 <jyp> @quote
07:03:34 <lambdabot> quote module failed: getRandItem: empty list
07:03:40 <jyp> @yow
07:03:41 <lambdabot> quote module failed: getRandItem: empty list
07:03:51 <jyp> @keal
07:03:52 <lambdabot> quote module failed: getRandItem: empty list
07:04:03 <jyp> @vixen
07:04:04 <lambdabot> vixen module failed: getRandItem: empty list
07:07:31 <ihope_> @arr
07:07:32 <lambdabot> quote module failed: getRandItem: empty list
07:08:59 <ihope_> Alfa, bravo, carlie, delta, eco, foxtrot, golf, otel.
07:10:09 <davidhouse> ihope, what have you got against 'h's?
07:16:44 <ihope_> Well, it all started wen someone said, "Ello."
07:17:39 <davidhouse> rigt.
07:25:08 <ihope_> Let's ban te letter!
07:33:41 <dcoutts> yay, gtksourceview-1.6 is out and works on win32. That'll be good for gtk2hs on win32.
07:38:36 <Philippa_> cool
07:38:47 <Philippa_> nagged anyone about mozembed, or should I do that myself?
07:44:37 <dcoutts> Philippa_, you'll have to do that
07:45:06 <mathrick> @index done
07:45:06 <lambdabot> bzzt
07:45:11 <mathrick> ?
07:45:11 <mathrick> @index done
07:45:12 <lambdabot> bzzt
07:45:42 <mathrick> @docs done
07:45:43 <lambdabot> done not available
07:47:54 <mathrick> okay, so how is done called in haskell?
07:48:23 <liyang> done?
07:48:35 <liyang> what is?
07:48:47 <Lemmih> @type all done
07:48:48 <lambdabot> Not in scope: `done'
07:49:30 <mathrick> liyang: IO () noop
07:49:39 <mathrick> that's how Bird calls it
07:49:41 <liyang> mathrick: return ()
07:49:45 <mathrick> ah
07:49:54 <liyang> Why do you need it?
07:50:15 <liyang> oh, you're reading Bird and Wadler?
07:50:21 <mathrick> yeah
07:50:29 <liyang> Edition?
07:50:35 <mathrick> well, I was under impression it's some kind of primitive, and I wanted to understand one definition of write
07:50:39 <mathrick> liyang: 2nd
07:50:44 <liyang> 1st!
07:50:47 <liyang> Drat.
07:50:47 <mathrick> the Bird only one
07:51:05 <mathrick> liyang: ?
07:51:24 <liyang> Otherwise it'd be Snap!
07:52:06 <mathrick> again, ?
07:52:46 <liyang> playing textbook snap.
08:06:12 <mathrick> > map ord "asd"
08:06:13 <lambdabot> [97,115,100]
08:06:20 <mathrick> @index ord
08:06:21 <lambdabot> Data.Char
08:07:39 <mathrick> hrmpf, I don't understand something
08:08:10 <mathrick> Prelude> putChar 'a'
08:08:11 <mathrick> a
08:08:11 <mathrick> Prelude>
08:08:15 <mathrick> as expected
08:08:38 <mathrick> Prelude> map putChar "asd"
08:08:39 <mathrick> Top level:
08:08:39 <mathrick>     No instance for (Show (IO ()))
08:08:39 <mathrick>       arising from use of `print' at Top level
08:08:39 <mathrick>     Probable fix: add an instance declaration for (Show (IO ()))
08:08:40 <mathrick>     In a 'do' expression: print it
08:08:50 <davidhouse> use mapM_.
08:08:53 <Lemmih> Use mapM_
08:09:00 <davidhouse> @type putChar
08:09:01 <lambdabot> Char -> IO ()
08:09:01 <mathrick> what's that, and how is it different?
08:09:23 <davidhouse> so after mapping, you have a list: [IO (), IO (), IO ()].
08:09:26 <Lemmih> @type map putChar "asd"
08:09:27 <lambdabot> [IO ()]
08:09:28 <davidhouse> ghci can't show that.
08:09:31 <Lemmih> @type mapM_ putChar "asd"
08:09:32 <lambdabot> IO ()
08:09:33 <mathrick> right
08:09:53 <davidhouse> if you use mapM_, as Lemmih just demonstrated, you get IO (), which ghci can show.
08:09:56 <davidhouse> @type mapM_
08:09:56 <lambdabot> forall (m :: * -> *) a b.
08:09:56 <lambdabot>    (Monad m) =>
08:09:56 <lambdabot>    (a -> m b) -> [a] -> m ()
08:10:36 <mathrick> what I'm really trying to understand here is that:
08:10:38 <mathrick> Prelude> let write = foldr (>>) done . map putChar
08:10:51 <mathrick> I can see it's being curried
08:11:04 <mathrick> but done . map putChar as starting value baffles me
08:11:14 <davidhouse> @type done
08:11:15 <lambdabot> Not in scope: `done'
08:11:18 <mathrick> where done = return ()
08:11:19 <Lemmih> @type foldr (>>) (return ())
08:11:20 <lambdabot> forall a (m :: * -> *).
08:11:20 <lambdabot>          (Monad m) =>
08:11:20 <lambdabot>          [m a] -> m ()
08:11:46 <davidhouse> return () gives you a type of m ()
08:11:54 <davidhouse> @type foldr (>>)
08:11:55 <lambdabot> forall (m :: * -> *) a b.
08:11:55 <lambdabot>      (Monad m) =>
08:11:55 <lambdabot>      m b -> [m a] -> m b
08:12:49 <davidhouse> basically, what it expands to is putChar a >> putChar s >> putChar d >> return ()
08:13:04 <liyang> let write = (foldr (>>) done) . map putChar
08:13:06 <mathrick> hmm
08:13:26 <davidhouse> which is the same as do { putChar a; putChar s; putChar d; return () }
08:13:36 <mathrick> davidhouse: but what is map doing there?
08:13:52 <davidhouse> okay, look at it blow-by-blow.
08:14:01 <mathrick> k
08:14:04 <liyang> map putChar takes a list of Chars, and gives you back a list of IO () actions.
08:14:08 <ihope_> @type sequence
08:14:09 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:14:09 <davidhouse> map putChar "asd" = [putChar 'a', putChar 's', putChar 'd']
08:14:30 <ihope_> @type sequence_
08:14:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:14:51 <davidhouse> foldr (>>) done $ map putChar "asd" = putChar a >> putChar s >> putChar d >> return ()
08:15:03 <mathrick> what's $?
08:15:06 <ihope_> @type ((>> return ()) . sequence)
08:15:06 <lambdabot> forall (m :: * -> *) a.
08:15:06 <lambdabot>            (Monad m) =>
08:15:06 <lambdabot>            [m a] -> m ()
08:15:07 <davidhouse> incidentally, you could just use sequence_ as ihope pointed out.
08:15:13 <ihope_> mathrick: x $ y = x y
08:15:18 <davidhouse> mathrick: pretend it's a '.' if you want
08:15:27 <ihope_> Um.
08:15:35 <ihope_> I don't think so.
08:15:41 <davidhouse> oh, wait.
08:15:49 <davidhouse> that's not what i meant.
08:16:12 <davidhouse> it's another way of writing foldr (>>) done (map putChar "asd")
08:16:32 <davidhouse>  foldr (>>) done $ map putChar "asd" ==  foldr (>>) done (map putChar "asd")
08:16:47 <davidhouse> ihope, is there any difference between sequence_ and sequene for actions which return ()?
08:16:54 <mathrick> wait, you're going a bit too fast
08:17:09 <davidhouse> mathrick: just ignore the $. pretend it's brackets.
08:17:39 <davidhouse> so we've got  foldr (>>) done (map putChar "asd") == putChar 'a' >> putChar 's' >> putChar 'd' >> done
08:17:40 <davidhouse> okay?
08:17:46 <mathrick> let me just ask few questions to see if I get it
08:18:38 <mathrick> when I write 'write "asd"', what I get is ' foldr (>>) (done . (map putChar)) "asd" ', right?
08:19:31 <liyang> no.
08:19:36 <davidhouse> not quite
08:19:47 <davidhouse> (foldr (>>) done) . (map putChar)) "asd" 
08:19:56 <davidhouse> ((foldr (>>) done) . (map putChar)) "asd" 
08:19:59 <mathrick> oooh
08:20:16 <davidhouse> (to use exessive parentheses :))
08:21:01 * mathrick reparses in that case
08:21:19 <mathrick> okay, now it's clear
08:21:50 <mathrick> not using parens is cute, but unfortunately, relies on a good and error-free knowledge of precedence rules
08:22:03 <davidhouse> it's all part of learning the language.
08:22:25 <jethr0_> i've never been a fan of absolutely minimalistic paren'ting
08:22:27 <mathrick> however, how was it possible that . didn't get swallowed by foldr's call?
08:22:43 <liyang> function application binds tighter than .
08:22:49 <mathrick> I thought call operator (' ') takes precedence over everything?
08:22:52 <jethr0_> when someone is unfamiliar with some weird precendence rule he won't be able to read it, and that's often unnecessary
08:22:54 <mathrick> liyang: yeah, exactly
08:23:28 <jethr0_> mathrick: call operator (' ')???
08:23:29 <liyang> I wouldn't call ' ' the call operator...
08:23:40 <mathrick> well, application, if you prefer
08:23:49 <mathrick> anyway, application > *
08:23:49 <davidhouse> it's not at all.
08:23:55 <liyang> then what is (.)? The composition operator?
08:24:01 <mathrick> yes
08:24:18 <mathrick> that's what I'd call it
08:24:21 <davidhouse> mathrick, f a b is not f(a(b))
08:24:22 <liyang> (Well it is, but (.) lives in the same world as foldr; ' ' is just a separator...)
08:25:02 <mathrick> davidhouse: I know
08:25:27 <davidhouse> mathrick: ' ' isn't application.
08:25:39 <mathrick> in f a b, it i
08:25:40 <mathrick> s
08:25:55 <davidhouse> no, because then it'd be f(a(b)).
08:26:10 <mauke> davidhouse: how so?
08:26:26 <mathrick> davidhouse: how?
08:26:27 <jethr0_> > 4 + 3 `div` 2 - 1
08:26:28 <lambdabot> 4
08:26:30 <mathrick> it's left-associative
08:26:39 <jethr0_> damn
08:27:07 <jethr0_> > 4 + 3 < 2 + 1
08:27:08 <lambdabot> False
08:27:32 <davidhouse> hmm.
08:27:36 <mathrick> I'm just not sure why the separation should occur at '.' and not somewhere else
08:27:43 <davidhouse> well, (.) has very low priority, i guess.
08:28:29 <mathrick> hmm
08:28:42 <mathrick> well, anyway, if you paren it that way, then it's instantly clear
08:28:55 <mathrick> now, explain $ if you please :)
08:29:25 <mauke> f $ x = f x
08:29:44 <davidhouse> what mauke said. but it has very high priority.
08:29:50 <mathrick> aha
08:29:51 <mathrick> okay
08:29:52 <davidhouse> so you can use it instead of parantheses.
08:29:56 <mathrick> I can see it now
08:30:09 <mathrick> higher than application?
08:30:27 <davidhouse> so in foldr (>>) done $ map putChar "asd", the $ gives the map priority over the foldr.
08:30:29 <mauke> very low, actually
08:30:58 <mathrick> davidhouse: err, wait
08:31:06 <mathrick> so it's not (done map)?
08:31:37 <davidhouse> wait, yeah, it must be very low priority.
08:31:40 <mauke> that's evaluated as (foldr (>>) done) (map putChar "asd")
08:31:57 <mathrick> okay
08:32:14 <mathrick> but now, the meaning is different than with '.'
08:32:21 <davidhouse> not really.
08:32:54 <davidhouse> if you had something like f $ g $ h $ i j, you could write that as f . g . h $ i j
08:33:09 <davidhouse> . is used when you want to eta-reduce.
08:33:27 <mathrick> what is eta-reduction?
08:33:44 <davidhouse> omitting arguments.
08:33:53 <mathrick> h?
08:33:54 <davidhouse> foldrNew = foldr
08:34:17 <davidhouse> without eta-reduction you should write that as foldrNew f s l = foldr f s l
08:34:31 <davidhouse> but you can just omit them.
08:35:04 <davidhouse> in your example, you had "write = foldr (>>) done . map putChar", which has been eta-reduced from "write s = foldr (>>) done $ map putChar s"
08:36:02 <mathrick> I guess I still don't see the exact diff between $ and .
08:36:19 <davidhouse> $ applies functions, . composes them.
08:36:48 <mathrick> okay
08:36:51 <davidhouse> you can't use "write = foldr (>>) done $ map putChar"
08:37:01 <mathrick> right
08:38:00 <liyang> @type (.)
08:38:01 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
08:38:01 <shapr> salut Evelf 
08:38:04 <liyang> @type ($)
08:38:05 <lambdabot> forall b a. (a -> b) -> a -> b
08:38:11 <davidhouse> a lot of time they're very similar
08:38:14 <Evelf> salut shapr 
08:39:16 <davidhouse> > negate $ 1
08:39:17 <lambdabot> -1
08:39:26 <davidhouse> > negate . 1
08:39:27 <lambdabot>  add an instance declaration for (Num (a -> b))
08:39:37 <mathrick> okay, and what are the rules of evaluation order? Because particularly monads and IO rely on it not being done in a totally random order
08:39:39 <davidhouse> 1 is not a function, so you can't compose it.
08:39:45 <davidhouse> on the other hand,
08:39:49 <davidhouse> > negate . id 1
08:39:50 <lambdabot>  add an instance declaration for (Num (a -> b))
08:39:53 <mathrick> > negate . const 1
08:39:54 <lambdabot>  add an instance declaration for (Show (a1 -> a))
08:40:01 <davidhouse> > (negate . id) 1
08:40:02 <lambdabot> -1
08:40:10 <mathrick> ah
08:40:23 <mathrick> > const 1
08:40:23 <lambdabot>  add an instance declaration for (Show (b -> a))
08:40:36 <mathrick> > const 1 3
08:40:37 <lambdabot> 1
08:40:42 <mathrick> right
08:40:45 <davidhouse> . has low priority, so negate . id 1 == negate . (id 1)
08:41:01 <mathrick> davidhouse: nah, I forgot that const takes an argument
08:41:08 <mathrick> I was really thinking about id
08:41:12 <davidhouse> heh.
08:42:37 <mathrick> so, anyway, even if you strip monads to the bare minimum, with no do and anything, just IO () type, you still need certain guarantees about the order of execution for your functions to not output garbage
08:43:12 <davidhouse> hmm. i just had a crazy though: it'd be nice to have "kind classes", so you could declare certain kinds to be elements of, say, KindEq then compare types :)
08:43:50 <mathrick> ?
08:43:59 <davidhouse> that wasn't directed at you.
08:44:05 <mathrick> ah, you mean like classes as first class objects?
08:44:08 <shapr> mathrick: Monads force evaluation order because they're of type a -> m a, which expands to a -> (a -> m a) and then a -> (a -> (a -> m a))
08:44:40 <davidhouse> shapr, err, what? a -> m a expands to a -> a -> m a? how?
08:44:41 <shapr> Monads are a special case of continuation passing style.
08:45:09 <davidhouse> mathrick: i mean classes as in type classes.
08:45:45 <mathrick> davidhouse: yeah, so basically, you want to treat types as values in some contexts, right?
08:45:53 <davidhouse> yeah.
08:46:03 <liyang> davidhouse: http://www.e-pig.org/ :)
08:46:27 <davidhouse> bbl.
08:46:34 <mathrick> you can do it in Py, although I find it semi-annoying because you need to construct type values specially, using imports from types
08:47:24 <shapr> davidhouse: I'll explain it next time... have you already seen http://www.nomaware.com/monads/html/index.html ?
08:47:39 <liyang> mathrick: there's the Data.Typeable in Haskell.
08:47:53 <mathrick> what's that?
08:51:38 <liyang> mathrick: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
08:51:46 <mathrick> hmm, contrary to what I expected, blue ones are not of salmiakki, but menthol flavour
08:51:53 <mathrick> what a randomness
08:53:12 <davidhouse> shapr, yes. i'm just not understanding your usage of "expands to". under what operation?
08:53:46 * mathrick signs under davidhouse's inquiry
08:54:11 <mathrick> The Typeable class reifies types to some extent <-- "reifies"?
08:55:20 <shapr> davidhouse: Do you know continuation passing style?
08:55:32 <davidhouse> shapr, heard of it.
08:55:35 <davidhouse> so no :)
08:55:37 <shapr> mathrick: reify = make it real.
08:55:59 <shapr> mathrick: In this case, roughly means 'allows you to treat it as a value.'
08:56:12 <mathrick> ah
08:56:53 <shapr> davidhouse: CPS is where you never 'return' because each function gets whatever args it requires, and a function to call with its result.
08:57:08 <davidhouse> ah.
08:57:36 <shapr> davidhouse: Evaluation order is always explicit in CPS, you always which function will be executed next... it'll be the one passed to this one as an argument.
08:57:45 <davidhouse> yeah.
08:57:45 <shapr> er, "always know which"
08:58:13 <shapr> The monadic interface is a special case of CPS.
08:59:02 <davidhouse> ... because you're passing around the monadic plumbing? or something?
09:00:33 <shapr> http://www.nomaware.com/monads/html/laws.html
09:00:41 <shapr> CPS by itself doesn't follow the monad laws.
09:01:23 <shapr> Haskell doesn't have evaluation order. Monads force evaluation order by calling the next function explicitly when they're done.
09:01:47 <shapr> I bet that was a crappy explanation =)
09:01:56 <shapr> The Nomaware tutorial is way better.
09:02:45 <shapr> davidhouse: So, was that clear as mud?
09:02:56 <davidhouse> pretty much.
09:02:58 <davidhouse> well
09:03:12 <shapr> dcoutts: How did you, dons, etc get group writable to stick for the hIDE repo? I'm trying to do the same thing myself.
09:03:15 <davidhouse> i get it mostly, i'm just failing to see how monads are a case of CPS.
09:03:41 <shapr> CPS is just where you get your standard args, and an extra arg that's the function to call with your result.
09:04:01 <Cale> hehe, CPS is a special case of the monadic interface too :)
09:04:22 <shapr> Monads do that too, but they have a few other conditions. If one of those other conditions isn't met, it can be CPS, but not a monad.
09:04:26 <davidhouse> sorry, i'm going for tea :) thanks for your input anyway. i'll do some more reading.
09:04:30 * shapr grins
09:04:47 <shapr> Cale is better at explaining monads than I am. His monads as containers page is nice.
09:05:56 <Cale> @oldwiki MonadsAsContainers
09:05:57 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
09:07:40 * mathrick reads more Bird to get to monad laws
09:26:34 <ihope_> @type (Control.Monad.Cont.Cont . (>>=))
09:26:35 <lambdabot> forall (m :: * -> *) a b.
09:26:35 <lambdabot>              (Monad m) =>
09:26:35 <lambdabot>              m a -> Control.Monad.Cont.Cont (m b) a
09:26:51 <ihope_> @oldwiki MonadsAsComputations
09:26:52 <lambdabot> http://www.haskell.org/hawiki/MonadsAsComputations
09:27:13 <ihope_> That's not right...
09:27:22 <davidhouse> Cale, have you seen the wikibook adaptation of your Monads as Containers?
09:27:33 <davidhouse> IMO it's _the_ definitive introduction to monads.
09:28:11 <davidhouse> Cale, http://en.wikibooks.org/wiki/Programming:Haskell_monads
09:34:38 <ihope_> Well, that book doesn't explain *why* we use monads.
09:34:44 <ihope_> ...Erm well, not at first.
09:35:23 <davidhouse> it's an introduction.
09:35:25 <davidhouse> it's lacking a lot.
09:35:32 <ndm> davidhouse: that wiki book doesn't seem to have any of the monads as containers stuff in it
09:35:41 <ndm> it seems to be just a new version of monads as spacesuits
09:35:53 <davidhouse> ndm, it was inspired by cale's article i believe.
09:36:02 <davidhouse> and yes, it is indeed a new version of monads as spacesuits.
09:36:18 <ndm> davidhouse: it doesn't seem that inspired - its pretty much entirely different
09:36:54 <davidhouse> i didn't write it! the author claims he was inspired by Cale's explanations using a box as a physical metaphor.
09:38:05 * ihope_ rewrites the Wikibook
09:38:21 <ndm> perhaps, i think both are important individually
09:41:20 <davidhouse> @type modify
09:41:21 <lambdabot> Not in scope: `modify'
09:41:24 <ihope_> Put simply, I don't think it's a good idea to introduce users to the Identity monad first...
09:41:28 <davidhouse> @type Control.Monad.modify
09:41:29 <lambdabot> Not in scope: `Control.Monad.modify'
09:41:35 <ihope_> @index modify
09:41:35 <davidhouse> @type Control.Monad.State.modify
09:41:36 <lambdabot> Control.Monad.State, Control.Monad.RWS
09:41:36 <lambdabot> forall (m :: * -> *) s.
09:41:36 <lambdabot>           (Control.Monad.State.MonadState s m) =>
09:41:36 <lambdabot>           (s -> s) -> m ()
09:43:54 * davidhouse adds modify to the wikibook
09:44:33 <jonkri> what function do i use to convert a string to lower case?
09:44:45 <ihope_> map toLower
09:44:47 <mnislaih> map toLower
09:45:01 <ihope_> > map toLower "IT KEEPS PEOPLE FROM FLAMING"
09:45:02 <lambdabot> "it keeps people from flaming"
09:45:08 <jonkri> thanks
09:45:38 <ihope_> > map toLower "And thE lEEt spEAkErs gEt nO rEspEct EIthEr
09:45:39 <lambdabot>  lexical error in string/character literal
09:45:40 <ihope_> > map toLower "And thE lEEt spEAkErs gEt nO rEspEct EIthEr"
09:45:41 <lambdabot> "and the leet speakers get no respect either"
09:47:06 <Spark> > map toHigher "can you hear me?"
09:47:07 <lambdabot>  Not in scope: `toHigher'
09:47:11 <Spark> oops
09:47:13 <ihope_> :-)
09:47:17 <Spark> that was a bit daft really
09:47:31 <ihope_> > map toUpper "can You hear mE?
09:47:32 <lambdabot>  lexical error in string/character literal
09:47:33 <ihope_> > map toUpper "can You hear mE?"
09:47:34 <Spark> but why is it not upper/downer or higher/lower
09:47:34 <lambdabot> "CAN YOU HEAR ME?"
09:47:51 <mathrick> Spark: haha
09:47:56 <ihope_> Well... upper, lower. I don't get it either.
09:47:58 <mathrick> uppercase / lowercase
09:47:59 <davidhouse> Spark: as in uppercase and lowercase
09:48:06 <ihope_> highercase/downercase
09:48:12 <Spark> yeah i know but why
09:48:25 <mathrick> because it's english
09:48:49 <mathrick> one of the fundamental properties of the english language is complete lack of "downer"
09:48:52 <Spark> this is probably the wrong channel to talk about etymology, #c is probably better :)
09:49:15 <davidhouse> shapr, still around?
09:49:15 <Spark> hmm yeah
09:49:20 <Spark> you get upper/lower town
09:49:49 <Spark> but im not sure you ever get that in legal documents
09:50:52 <Spark> but then its not like you get "low treason" either
09:55:40 <ihope_> It's like a painting. By fixing the Mona Lisa's smile, I ruin the Mona Lisa. If I repaint the rest of the Mona Lisa, it probably won't be as good as the original.
10:00:02 <dcoutts> shapr, we set all the files & dirs to be group writable and set the group sticky bit so that new files would be owned by the right group. We also set out umasks so that new files are group writable.
10:08:41 <shapr> dcoutts: thanks
10:09:33 <chris2> anyone want to have a look at my code and tell me what could be done better?  http://rafb.net/paste/results/lM1jl995.html
10:10:37 <jonkri> how can i bring something to the io monad so that i can use it with <-?
10:11:26 <jonkri> i just get couldn't match `IO' against...
10:12:05 <mathrick> ?
10:12:33 <jethr0_> chris2: it would be easier if we knew what the whole thing and especially "traceback" do
10:13:02 <jethr0_> it's certainly one of the most array-dense codes i've ever seen
10:13:02 <chris2> it's an implementation of http://www.sbc.su.se/~pjk/molbioinfo2001/dynprog/dynamic.html
10:13:09 <mathrick> jonkri: you need the op to be of type "IO a" if you want to bind it to a value of type a
10:13:20 <vincenz> jethr0_: YOU'RE STILL UP!!!
10:13:23 <jonkri> yeah
10:13:32 <chris2> jethr0_: that's typical of dynamic programming, isnt it? :P
10:13:33 <jonkri> mathrick, how can i tell "break" to return a IO value instead of a "normal" tuple?
10:13:56 <mathrick> @type break
10:13:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:14:06 * jethr0_ guesses the filling phase could be done _beautifully_ backwards with lazy evaluation
10:14:21 <jethr0_> vincenz: i've slept a little already
10:14:24 <mathrick> jonkri: I'm not sure I see what you want to do
10:14:34 <ndm> jonkri: return
10:14:38 <ndm> @type return
10:14:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
10:14:53 <mathrick> jonkri: (also note I had just read the chapter on monads, so I use you to see how much of it I got :)
10:14:54 <ndm> although what you probably want is "let" instead of "<-"
10:14:58 <jonkri> ah, i could use return in the function
10:15:12 <jonkri> thanks, return solved it
10:15:15 <jonkri> i wanted to do
10:15:20 <jonkri> a <- return break...
10:15:21 <ndm> let (a,b) = return (break ....)
10:15:22 <jonkri> thanks
10:15:31 <ndm> let (a,b) = break ....
10:15:38 <ndm> (a,b) <- return (break ....
10:15:41 <vincenz> yah
10:15:42 <ndm> those last two are equivalent
10:15:52 <vincenz> ah..yah
10:15:52 <ndm> (the top one of the three is just wrong :))
10:16:01 <jonkri> thanks
10:17:46 <jethr0_> chris2: i'd tackle it in a very different manner, so it's hard for me to say anything to your code. maybe my idea wouldn't work, so i guess your solution might be a short solution, but it sure doesn't look very haskellish to me. it's a pretty short (presumably correct) solution though
10:17:53 <shapr> davidhouse: I'm here, have a question?
10:18:15 <chris2> jethr0_: yeah, mine is pretty staight like the description
10:18:30 <chris2> jethr0_: could you outline how to do it?
10:18:55 <davidhouse> shapr, giving you an opportunity to finish that CPS-monad thingy :) i almost get it, i think. let me find that quote...
10:19:04 <jethr0_> chris2: or is your solution doing it backwards already?
10:19:26 <chris2> i use an array for hashconsing
10:19:30 <chris2> i dont explicitly fill
10:19:47 <jethr0_> chris2: maybe i'm just too tired to make sense of it. better ask someone else ^_^
10:19:55 <chris2> okay ;)
10:19:57 <chris2> dinner, bbl
10:20:11 <davidhouse> shapr, you said monads pass around stuff with information on what to do next. right?
10:22:06 <jethr0_> chris2: i guess it's about how i would have approached it. but somehow there's too many (!!) and (!) in it for me...
10:24:49 <shapr> davidhouse: Yeah, look at http://www.nomaware.com/monads/html/meet.html for example. See the definition of comb?
10:25:00 <ihope_> @index (!)
10:25:00 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.
10:25:00 <lambdabot> Map, Data.Array, Text.Html
10:25:06 <araujo> hello!
10:25:10 <ihope_> @index (!!!)
10:25:11 <lambdabot> bzzt
10:25:18 <davidhouse> shapr, argh, sorry my internet is crapping up. mind pastebinning the appropriate bit for me?
10:25:44 <shapr> comb :: Maybe a -> (a -> Maybe b) -> Maybe b
10:25:44 <shapr> comb Nothing  _ = Nothing
10:25:44 <shapr> comb (Just x) f = f x
10:27:09 <shapr> davidhouse: You have Data.Maybe on your drive somewhere, yeah?
10:27:12 <davidhouse> yeah
10:27:25 <davidhouse> right.
10:27:47 <shapr> Look at the monad instance.
10:27:59 <shapr> The import part is:
10:28:00 <shapr>     Nothing  >>= f = Nothing
10:28:00 <shapr>     (Just x) >>= f = f x
10:28:03 <jethr0_> chris2: the code is very good. i would not have gone with an infix operation "@@" though and rather've called it sth like "scoring x y" or so
10:28:55 <shapr> davidhouse: Monads generally work like that, you get the result from the last operation and pass it into the next op.
10:29:25 <ihope_> @index Identity
10:29:25 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
10:29:34 <ihope_> @hoogle Identity a -> a
10:29:35 <lambdabot> Control.Monad.Identity.runIdentity :: Identity a -> a
10:29:35 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
10:29:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:29:44 <ihope_> gr a b, eh?
10:29:49 <shapr> I like to say that a monad turns a the significance of a value into a pipeline that automates that significance.
10:30:16 <davidhouse> shapr, right. so comb is >>= for Maybe. makes sense. 
10:30:23 <davidhouse> and yeah, i see how it applies generally
10:31:15 <shapr> The Maybe type represents failure, so the maybe monad makes a pipeline that abstracts out what would be a bunch of nested if/then/else blocks in an imperative language.
10:31:49 <vincenz> data as computation
10:33:06 <shapr> An online order would have a bunch of conditions to fulfill, 'does client exist', 'does client credit card have enough money' 'does item exist' 'does warehouse have as many items as were ordered'
10:33:26 * ihope_ turns the Haskell Wikibook's nuclear waste facility into a toy factory
10:33:29 <davidhouse> and you'd bind one to the other to the other to other...
10:33:41 <davidhouse> shapr, or use foldr mplus mzero :)
10:33:45 <shapr> With the maybe monad, you could do clientExist >>= clientCardWorks >>= itemExists >>= itemInStock
10:33:49 <davidhouse> ihope_, why?
10:34:17 <shapr> Yeah, my example is cheesy and artificial, but I hope it gets the idea across.
10:34:22 <ihope_> davidhouse: monads aren't all about putting things in containers and taking them out again, are they?
10:35:30 <davidhouse> ihope_, no, but 1) it's a good way of explaining their plumbing and 2) a toy factory would surely be container-based anyway?
10:35:55 <vincenz> I like the monad: shapr >>= shapr >>= shapr ..
10:36:07 <ihope_> davidhouse: yes. Lists are containers.
10:37:31 <shapr> davidhouse: so... the functions are explicitly passed to the monad like clientExist >>= clientCardWorks, that's how it resembles CPS.
10:37:41 <davidhouse> yes, i see now.
10:37:52 <ihope_> Hmm, meh. /me rewrites the module completely
10:38:05 <davidhouse> ihope_: don't.
10:38:19 <davidhouse> ihope_, if you want to explain monads as computations, do that in a seperate module.
10:38:19 <ihope_> In a user subpage...
10:38:39 <davidhouse> "Now you've seen exactly what monads are, lets explain where they might be useful"
10:39:38 <ihope_> But then...
10:39:45 <chris2> jethr0_: heh, thx :) yeah.. but i wanted to have higher prec than -, else i would need to stray () all over
10:41:36 <ihope_> Well, the user would most likely wade through all the stuff on the current page before seeing why they're useful, and get the idea that monads are very, very complicated, and...
10:42:03 <chris2> jethr0_: i'll now prepend a space to the strings so they'll be one-indexed, that makes it more readable
10:43:10 * vincenz personally finds 0-indexed more readable
10:44:04 <davidhouse> shapr, thanks :)
10:44:10 <chris2> vincenz: i do too, but this algo works better if it's 1-indexed
10:45:03 <vincenz> ah
10:45:19 <shapr> davidhouse: Sure, any other questions?
10:45:59 <chris2> vincenz: because index 0 is used for beginning of induction... but maybe i could make that -1...
10:46:22 <davidhouse> i'm pretty sure i get it. although still, how did you decide that a -> m a expands to a -> a -> m a, etc?
10:46:42 <davidhouse> oh, wait.
10:47:11 <davidhouse> because clientExist has type a -> Maybe a, then clientExist >>= clientCardWorks has type a -> a -> Maybe a or something>/
10:47:20 <davidhouse> fudging the argument order a little
10:50:04 <davidhouse> yes? or no?
10:51:00 <ihope_> Um...
10:51:43 <ihope_> There, (>>=) would be acting on a function, so it'd use the Reader instance declaration, I think.
10:52:36 <ihope_> So why shouldn't I rewrite the wiki page?
10:52:56 <davidhouse> those two reasons i mentioned.
10:53:04 <chris2> is there a non-operator alias for : ?
10:53:27 <davidhouse> chris2, (:).
10:53:38 <chris2> but no alphabetic name?
10:53:48 <davidhouse> let cons = (:). there you go
10:54:02 <chris2> ;)
10:54:13 <davidhouse> but, honestly, why?
10:54:47 <chris2> because i cant write  : $
10:55:00 <mauke> (:) $
10:55:00 <chris2> and i think i have way too many parentheses here
10:55:18 <davidhouse> give more context.
10:55:49 <chris2>           traceback x y | x@@y == x-1@@y = (a!!x, ' ' ) : (traceback (x-1) y)
10:56:13 <chris2> i wanted to avoid the parentheses around traceback
10:56:44 <davidhouse> have you actually tried (:) $ ? i think it might work
10:56:53 <chris2> (:) $ works
10:56:58 <mathrick> @index concatMap
10:56:58 <lambdabot> Data.List, Prelude
10:57:00 <chris2> but  foo : $ bar  doesnt
10:57:18 <mathrick> > concatMap (+10) [1 .. 10]
10:57:19 <lambdabot>  add an instance declaration for (Num [b])
10:57:19 <lambdabot>   In an arithmetic sequence: [1 .. 10]
10:57:25 <chris2> i hate that i need parens around (x-1) there :/
10:57:27 <davidhouse> you can't always get rid of _all_ parantheses.
10:57:37 <chris2> sure
10:57:40 <mathrick> @type concatMap
10:57:40 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
10:57:43 <davidhouse> chris2, you don't really.
10:57:57 <mathrick> ahh
10:58:03 <chris2> it wont compile else...
10:58:03 <davidhouse> traceback $ flip (/) y $ x - 1 if you want to be really annoying
10:58:10 <chris2> :P
10:58:17 <chris2> yeah great ;)
10:58:18 <ihope_> What's wrong with parentheses?
10:58:22 <mauke> (a !! x, ' ') : traceback (x - 1) y
10:58:28 <mauke> just works (TM)
10:58:44 <mathrick> > concatMap (\x -> replicate 5 x) [1 .. 10]
10:58:45 <lambdabot> [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,
10:58:45 <lambdabot> 8,8,8,8,9,9,9,9,9,10,10,10,10,10]
10:58:51 <chris2> mauke: oops ;) my bad.
10:59:35 <ihope_> > [1..10] >>= replicate 5
10:59:36 <lambdabot> [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,
10:59:36 <lambdabot> 8,8,8,8,9,9,9,9,9,10,10,10,10,10]
10:59:53 <vincenz> > "spam" >> replicate 5
10:59:53 <lambdabot> Couldn't match `[]' against `(->) t'
10:59:58 <vincenz> > "spam" >>= replicate 5
10:59:59 <lambdabot> "ssssspppppaaaaammmmm"
11:00:46 <ihope_> > "spam" >> "spam"
11:00:47 <lambdabot> "spamspamspamspam"
11:01:51 <mathrick> > "spam" >>= replicate 3 >>= map toUpper
11:01:52 <lambdabot> Couldn't match `[a]' against `Char'
11:02:07 <mathrick> > "spam" >>= replicate 3 >>= (map toUpper)
11:02:07 <lambdabot> Couldn't match `[a]' against `Char'
11:03:14 <mathrick> @type map toUpper
11:03:15 <lambdabot> Not in scope: `toUpper'
11:03:17 <ihope_> > [1,2,3,4,5] >>= replicate 3 >>= (\x -> replicate x x)
11:03:18 <lambdabot> [1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,
11:03:18 <lambdabot> 5,5,5,5,5,5,5,5,5]
11:03:44 <mathrick> @type (map toUpper)
11:03:44 <lambdabot> Not in scope: `toUpper'
11:03:48 <mathrick> @type (map toUpper::Char)
11:03:49 <lambdabot> Not in scope: `toUpper'
11:03:54 <mathrick> what?
11:04:02 <mathrick> @type (map Data.Char.toUpper)
11:04:03 <lambdabot> [Char] -> [Char]
11:04:20 <mathrick> > "spam" >>= replicate 3 >>= map Data.Char.toUpper
11:04:20 <lambdabot> Couldn't match `[a]' against `Char'
11:04:34 <mathrick> hrmpf
11:04:44 <mathrick> @type "spam" >>= replicate 3 
11:04:44 <lambdabot> [Char]
11:04:59 <mathrick> I don't get it
11:05:07 <mauke> > map toUpper $ "spam" >>= replicate 3
11:05:07 <lambdabot> "SSSPPPAAAMMM"
11:05:24 <mathrick> but why didn't >>= work?
11:05:31 <mauke> map toUpper :: [Char] -> [Char]
11:05:41 <mathrick> yes
11:05:41 <mauke> >>= expects Char -> [Char]
11:05:56 <mathrick> ah
11:06:00 <mathrick> right
11:06:58 <mathrick> > "spam" >>= replicate 3 >>= map (toUpper . (\x -> [x]))
11:06:58 <lambdabot> Couldn't match `[a]' against `Char'
11:07:23 <mathrick> bah
11:07:27 * mathrick can't think
11:07:29 <davidhouse> \x -> [x] == return, by the way.
11:07:29 <lambdabot> compose module failed: Parse error: "->"
11:07:42 <mauke> \wtf
11:08:06 <mathrick> > "spam" >>= replicate 3 >>= (map toUpper . (\x -> [x]))
11:08:07 <lambdabot> "SSSPPPAAAMMM"
11:08:12 <mathrick> \o/
11:08:13 <lambdabot> Maybe you meant: . id pl wn yow
11:08:20 <mathrick> haha
11:08:27 <mauke> \pl
11:08:27 <lambdabot> (line 1, column 1):
11:08:27 <lambdabot> unexpected end of input
11:08:27 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
11:08:27 <lambdabot> expression
11:08:42 <davidhouse> > "spam" >>= replicate 3 >>= (map toUpper . return)
11:08:43 <lambdabot> "SSSPPPAAAMMM"
11:08:57 <mauke> > "spam" >>= replicate 3 >>= (return . toUpper)
11:08:58 <lambdabot> "SSSPPPAAAMMM"
11:09:10 <davidhouse> that too.
11:10:22 <mathrick> heh
11:11:16 <mauke> > liftM toUpper $ concatMap (replicate 3) $ "spam"
11:11:17 <lambdabot> "SSSPPPAAAMMM"
11:11:25 <mathrick> > "spam" >>= replicate 3 >>= ((\x -> "lovely " ++ x) . return . toUpper)
11:11:26 <lambdabot> "lovely Slovely Slovely Slovely Plovely Plovely Plovely Alovely Alovely
11:11:26 <lambdabot> Alovely Mlovely Mlovely M"
11:11:38 <mathrick> heh, not what I meant
11:12:24 <mathrick> > "spam" >>= replicate 3 >>= ((\x -> "lovely " ++ x) . map toUpper . return)
11:12:25 <lambdabot> "lovely Slovely Slovely Slovely Plovely Plovely Plovely Alovely Alovely
11:12:25 <lambdabot> Alovely Mlovely Mlovely M"
11:12:36 <mathrick> > "spam" >>= replicate 3 >>= ((\x -> "lovely " ++ x) . (map toUpper . return))
11:12:37 <lambdabot> "lovely Slovely Slovely Slovely Plovely Plovely Plovely Alovely Alovely
11:12:37 <lambdabot> Alovely Mlovely Mlovely M"
11:12:40 <mathrick> bah
11:12:55 <mauke> what do you want to do?
11:13:16 <mathrick> > ((\x -> "lovely " ++ x)  $ "spam" >>= replicate 3 >>= (map toUpper . return)
11:13:16 <lambdabot>  parse error on input `}'
11:13:21 <mathrick> > ((\x -> "lovely " ++ x)  $ "spam" >>= replicate 3 >>= (map toUpper . return)
11:13:21 <lambdabot>  parse error on input `}'
11:13:24 <mathrick> ghrr
11:13:27 <mathrick> > (\x -> "lovely " ++ x)  $ "spam" >>= replicate 3 >>= (map toUpper . return)
11:13:28 <lambdabot> "lovely SSSPPPAAAMMM"
11:13:43 <mathrick> now
11:15:30 <ValarQ> hmm
11:15:35 <ValarQ> what about
11:15:40 <ValarQ> > "lovely " ++ (liftM toUpper $ "spam" >>= replicate 3)
11:15:40 <lambdabot> "lovely SSSPPPAAAMMM"
11:15:50 <mathrick> @type liftM
11:15:51 <lambdabot> Not in scope: `liftM'
11:16:00 <mathrick> @index liftM
11:16:01 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
11:16:01 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
11:16:01 <lambdabot> Control.Monad.Error, Control.Monad.List
11:16:07 <davidhouse> liftM turns a non monadic function into a monadic one.
11:16:18 <mathrick> ah
11:16:25 <davidhouse> for example, toUpper operates on chars, but liftM toUpper operates on lists of length one.
11:16:42 <davidhouse> (or on Maybe Char, IO Char and so on)
11:17:17 <mathrick> liftM f = return . f
11:17:18 <mathrick> ?
11:17:19 <davidhouse> > liftM toUpper "x"
11:17:20 <lambdabot> "X"
11:17:35 <davidhouse> almost.
11:17:50 <mathrick> > (\f -> return . f) toUpper "x"
11:17:50 <lambdabot> Couldn't match `Char' against `[Char]'
11:17:59 <davidhouse> liftM f a = a >>= (return.f)
11:18:16 <davidhouse> (\a -> a >>= return . toUpper) "x"
11:18:21 <davidhouse> > (\a -> a >>= return . toUpper) "x"
11:18:22 <lambdabot> "X"
11:19:08 <mathrick> not sure I see why
11:19:25 <jonkri> if i have "'temp1' 'temp2' 'temp3'", what is then the easiest way of getting ("temp1", "temp2", "temp3")? what functions should i use?
11:19:56 <davidhouse> @type Control.Monad.liftM
11:19:57 <lambdabot> forall r (m :: * -> *) a1.
11:19:57 <lambdabot>         (Monad m) =>
11:19:57 <lambdabot>         (a1 -> r) -> m a1 -> m r
11:20:28 <davidhouse> so it takes a non-monadic function f, a monadic value, and returns a monadic value.
11:20:35 <shapr> yup
11:20:38 <mauke> > foldr id False (replicate 123 not)
11:20:39 <lambdabot> True
11:20:39 <mathrick> ah, monadic value
11:20:40 <mathrick> right
11:20:52 <integral> @type replicate 123 not
11:20:53 <lambdabot> [Bool -> Bool]
11:21:02 <mathrick> replicate 1 not
11:21:06 <mathrick> > replicate 1 not
11:21:06 <lambdabot>  add an instance declaration for (Show (Bool -> Bool))
11:21:08 <davidhouse> so it needs to pull the value out of the monad then put it through the function, then make it monadic.
11:21:18 <mathrick> davidhouse: yup
11:21:20 <shapr> > return 5 :: Maybe Int
11:21:21 <lambdabot> Just 5
11:21:26 <mathrick> heh
11:21:40 <mathrick> shapr: Just 5 is a polish boysband name :)
11:23:55 <mathrick> > (\Maybe x -> x) $ not :: Maybe (Bool -> Bool) >>= liftM id
11:23:56 <lambdabot>  Not in scope: data constructor `Maybe'
11:24:06 <shapr> neat
11:24:08 <mathrick> hmm, I seem to be lacking an argument
11:24:17 * shapr disagrees, therefore starting an argument.
11:24:23 <mathrick> :D
11:24:25 <vincenz> mathrick: what if one member leaves?
11:24:36 <mathrick> member of what?
11:24:44 <davidhouse> mathrick, Maybe isn't a data constructor.
11:24:51 <mathrick> right
11:24:53 <vincenz> mathrick: of the 5 members
11:24:58 <davidhouse> you want Just or Nothing.
11:25:18 <mathrick> > (\Just x -> x) $ not :: Maybe (Bool -> Bool) >>= liftM id True
11:25:19 <lambdabot>  Not in scope: type constructor or class `True'
11:25:28 <vincenz> o.O
11:25:31 <vincenz> oh yeah
11:25:34 <vincenz> no type annotation halfway
11:25:34 <mathrick> @type (\Just x -> x) $ not :: Maybe (Bool -> Bool) >>= liftM id
11:25:35 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
11:25:35 <lambdabot>   When checking the pattern: Just
11:25:49 <davidhouse> mathrick: what are you trying to do?
11:25:49 <mathrick> @type (\(Just x) -> x) $ not :: Maybe (Bool -> Bool) >>= liftM id
11:25:50 <lambdabot>   Couldn't match `Maybe a' against `t -> t1'
11:25:50 <lambdabot>   Expected type: Maybe a
11:25:50 <vincenz> > (\Just x -> x) $not >>= liftM id True
11:25:51 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
11:25:51 <lambdabot>   When checking the pattern: Just
11:25:51 <lambdabot>   In a lambda abstraction: \ Just x -> x
11:25:57 <mathrick> davidhouse: very convoluted not
11:26:02 <vincenz> > (\(Just x) -> x) $not >>= liftM id True
11:26:03 <lambdabot> Couldn't match `Bool -> Bool -> b' against `Bool'
11:26:21 <davidhouse> > let myNot False = True; myNot True = False in map myNot [True, False]
11:26:21 <lambdabot> [False,True]
11:27:15 <davidhouse> > (\Just x -> x) . not >>= liftM id True
11:27:15 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
11:27:15 <lambdabot>   When checking the pattern: Just
11:27:15 <lambdabot>   In a lambda abstraction: \ Just x -> x
11:27:17 <davidhouse> oops
11:27:22 <mathrick> @type not :: Maybe (Bool -> Bool)
11:27:23 <lambdabot>   Couldn't match `Maybe (Bool -> Bool)' against `t -> t1'
11:27:23 <lambdabot>   Expected type: Maybe (Bool -> Bool)
11:27:45 <mathrick> right
11:27:47 <mathrick> that was stupid
11:27:48 <davidhouse> > liftM not Maybe False
11:27:49 <lambdabot>  Not in scope: data constructor `Maybe'
11:27:54 <davidhouse> > liftM not $ Just False
11:27:55 <lambdabot> Just True
11:28:11 <mathrick> heh
11:28:26 <davidhouse> > liftM (+1) [1]
11:28:27 <lambdabot> [2]
11:29:40 <mathrick> hmm
11:29:43 <mathrick> @type not
11:29:44 <lambdabot> Bool -> Bool
11:29:53 <mathrick> @type Just not
11:29:54 <lambdabot> Maybe (Bool -> Bool)
11:30:16 <mathrick> guess it doesn't like me using function names as values
11:30:28 <mathrick> > 5 :: Maybe Int
11:30:29 <lambdabot>  add an instance declaration for (Num (Maybe Int))
11:30:29 <lambdabot>   In the expression: 5 :: Maybe Int
11:30:29 <lambdabot>   In the definition of `isr': isr = 5 :: Maybe Int
11:30:40 <davidhouse> Just 5 :: Maybe Int
11:30:51 <mathrick> > return 5 :: Maybe Int
11:30:52 <lambdabot> Just 5
11:31:05 <mathrick> > return not :: Maybe (Bool -> Bool)
11:31:06 <lambdabot>  add an instance declaration for (Show (Bool -> Bool))
11:31:10 <mathrick> k
11:31:30 <mathrick> > (\Just x -> x) $ return not :: Maybe (Bool -> Bool) >>= liftM id True
11:31:31 <lambdabot>  Not in scope: type constructor or class `True'
11:31:39 <mathrick> > True
11:31:39 <lambdabot> True
11:31:52 <mathrick> @type True
11:31:52 <lambdabot> Bool
11:31:57 <davidhouse> > execState ((liftM fst $ get) >>= put) 5
11:31:58 <lambdabot>  Not in scope: `put'
11:32:11 <mathrick> > (\Just x -> x) $ return not :: Maybe (Bool -> Bool) >>= liftM id $ True
11:32:12 <lambdabot>  Not in scope: type constructor or class `True'
11:32:16 <mathrick> boo
11:32:49 <davidhouse> > execState ((liftM fst Control.Monad.State.get) >>= Control.Monad.State.put) 5
11:32:50 <lambdabot>  Not in scope: `Control.Monad.State.put'
11:33:06 <mathrick> @type (\Just x -> x) $ return not :: Maybe (Bool -> Bool) >>= liftM id
11:33:07 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
11:33:07 <lambdabot>   When checking the pattern: Just
11:33:11 <davidhouse> ?
11:33:24 <mathrick> @type (\(Just x) -> x) $ return not :: Maybe (Bool -> Bool) >>= liftM id
11:33:25 <lambdabot>   Couldn't match the rigid variable `>>=' against `(->)'
11:33:25 <lambdabot>   `>>=' is bound by the polymorphic type `forall (>>= :: * -> * -> *)
11:34:03 <Cale> @type (\(Just x) -> x) $ (return not :: Maybe (Bool -> Bool)) >>= liftM id
11:34:04 <lambdabot> Not in scope: `liftM'
11:34:11 <Cale> @type (\(Just x) -> x) $ (return not :: Maybe (Bool -> Bool)) >>= Control.Monad.liftM id
11:34:11 <lambdabot>   Couldn't match `Maybe' against `(->) Bool'
11:34:11 <lambdabot>   Expected type: (Bool -> Bool) -> Maybe b
11:34:22 <Cale> of course :)
11:35:11 <mathrick> hmm?
11:36:07 <mathrick> @type (\(Just x) -> x) $ (return not :: Maybe (Bool -> Bool)) >>= (return id :: Maybe (Bool -> Bool))
11:36:07 <lambdabot>   Couldn't match `Maybe (Bool -> Bool)' against `t -> t1'
11:36:07 <lambdabot>   Expected type: Maybe (Bool -> Bool)
11:36:34 <mathrick> now that's just a strange error
11:36:45 <Cale> @type fmap id (return not)
11:36:46 <lambdabot> forall (m :: * -> *).
11:36:46 <lambdabot>         (Functor m, Monad m) =>
11:36:46 <lambdabot>         m (Bool -> Bool)
11:37:03 <Cale> fmap id is just id though
11:37:24 <davidhouse> @type ((return.not) $ Just False) >>= (return.id)
11:37:24 <lambdabot>   Couldn't match `Bool' against `Maybe a'
11:37:24 <lambdabot>   Expected type: Bool
11:37:28 <Cale> (as is liftM id, because that's the same thing)
11:37:34 <palomer> > return 5 :: [Int]
11:37:34 <davidhouse> @type ((return.not) False) >>= (return.id)
11:37:35 <lambdabot> [5]
11:37:35 <lambdabot> forall (m :: * -> *).
11:37:35 <lambdabot>               (Monad m) =>
11:37:35 <lambdabot>               m Bool
11:37:48 <davidhouse> ((return.not) False) >>= (return.id) :: Maybe Bool
11:37:51 <davidhouse> > ((return.not) False) >>= (return.id) :: Maybe Bool
11:37:52 <lambdabot> Just True
11:37:53 * palomer is amazed that type annotations can change the semantics of a haskell program
11:38:04 <Cale> >>= (return . id) is not getting anything done
11:38:11 <davidhouse> no, i know.
11:38:24 <davidhouse> i don't know where mathrick was going with that one
11:39:04 <mathrick> I wanted to make monadic not for Maybe values, bind it to a monadic id, then extract it out of Maybe monad
11:39:06 <davidhouse> return.id is a right-identity for >>=.
11:39:24 <Cale> perhaps you're looking for ap
11:39:30 <mathrick> ap?
11:39:30 <Cale> @type Control.Monad.ap
11:39:30 <lambdabot> forall b (m :: * -> *) a.
11:39:30 <lambdabot>        (Monad m) =>
11:39:30 <lambdabot>        m (a -> b) -> m a -> m b
11:39:41 <davidhouse> ap is $ for monads
11:39:52 <davidhouse> > ap not $ Just False
11:39:52 <Cale> > (return not) `ap` (return False) :: Maybe Bool
11:39:53 <lambdabot> Couldn't match `a -> b' against `Bool'
11:39:53 <lambdabot> Just True
11:39:56 <vincenz> > [1..10] >>= replicate x x
11:39:57 <lambdabot>  Not in scope: `x'
11:40:02 <vincenz> > [1..10] >>= \x -> replicate x x
11:40:03 <lambdabot> [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,
11:40:03 <lambdabot> 9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10]
11:40:04 <vincenz> hmm
11:40:12 <vincenz> it's odd tat with list monad you can not use retur
11:40:22 <Cale> vincenz: you can't?
11:40:53 <davidhouse> > ap (return.not) $ Just False
11:40:54 <lambdabot> Couldn't match `(->) Bool' against `Maybe'
11:40:55 <mathrick> > [1..10] >>= \x -> return x
11:40:56 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
11:41:05 <Cale> > [1..10] >>= \x -> [2..10] >>= \y -> if x < y then return (x,y) else mzero
11:41:06 <lambdabot> [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),
11:41:06 <lambdabot> (2,6),(2,7),(2,8),(2,9),(2,10),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(3,10),
11:41:06 <lambdabot> (4,5),(4,6),(4,7),(4,8),(4,9),(4,10),(5,6),(5,7),(5,8),(5,9),(5,10),(6,7),
11:41:06 <lambdabot> (6,8),(6,9),(6,10),(7,8),(7,9),(7,10),(8,9),(8,10),(9,10)]
11:41:16 <mathrick> @type mzero
11:41:16 <lambdabot> Not in scope: `mzero'
11:41:24 <Cale> @type Control.Monad.mzero
11:41:24 <lambdabot> forall (m :: * -> *) a.
11:41:24 <lambdabot>         (Control.Monad.MonadPlus m) =>
11:41:24 <lambdabot>         m a
11:41:25 <mathrick> @type Control.Monad.mzero
11:41:26 <lambdabot> forall (m :: * -> *) a.
11:41:26 <lambdabot>         (Control.Monad.MonadPlus m) =>
11:41:26 <lambdabot>         m a
11:41:37 <Cale> > mzero :: [Integer]
11:41:38 <lambdabot> []
11:41:42 <Cale> > mzero :: Maybe Integer
11:41:43 <lambdabot> Nothing
11:42:04 <mathrick> how does it know that Nothing is zero in Maybe?
11:42:11 <mathrick> explicit or implicit thing?
11:42:16 <Cale> mzero is a typeclass method
11:42:31 <mathrick> and that means ...?
11:42:39 <palomer> ok, someone give me a program that returns 0 given one annotation and 1 given another
11:42:47 <Cale> Well, the instance of MonadPlus for Maybe has mzero = Nothing
11:42:58 <mathrick> so it's explicit
11:43:02 <Cale> yes
11:43:09 <Cale> class A t where
11:43:13 <mathrick> mhm
11:43:19 <Cale>     f x :: t -> Integer
11:43:39 <Cale> instance A Char where
11:43:43 <Cale>     f x = 0
11:43:49 <Cale> instance A Integer where
11:43:50 <Cale>     f x = 1
11:43:57 <davidhouse> instance A Char? isn't Char a type?
11:44:04 <Cale> yes
11:44:10 <mathrick> davidhouse: instance == of a class
11:44:28 <davidhouse> oh, sorry. i'm reading "instance A Char" as "A is an instance of class Char", it's the other way round
11:44:28 <vincenz> davidhouse: instance A Char where:::
11:44:31 <Cale> Typeclasses are predicates on types
11:44:37 <Cale> oh
11:44:39 <Cale> okay
11:44:44 <vincenz> just like objectclasses are predicates on objects
11:44:48 <vincenz> but only decidable at runtime
11:46:31 <mathrick> damn, this channel is like one big logic puzzle
11:46:39 <mathrick> I can see how it sucks my time away
11:46:47 * mathrick beats #haskell with a stick
11:47:32 <davidhouse> @ type sequence . repeat getLine
11:47:33 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
11:47:33 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
11:47:33 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
11:47:33 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
11:47:33 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
11:47:35 <lambdabot> [8 @more lines]
11:47:37 <davidhouse> @type sequence . repeat getLine
11:47:37 <lambdabot>   Couldn't match `[a]' against `t -> t1'
11:47:39 <lambdabot>   Expected type: [a]
11:48:01 <mathrick> @type sequence
11:48:02 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
11:48:03 <davidhouse> @type sequence $ repeat getLine
11:48:04 <lambdabot> IO [String]
11:48:13 <davidhouse> @type sequence $ repeat putStrLn
11:48:14 <lambdabot>   No instance for (Monad ((->) String))
11:48:14 <lambdabot>   arising from use of `sequence' at <interactive>:1:0-7
11:48:58 <davidhouse> @type sequence $ repeat $ putStrLn "hello world"
11:48:59 <lambdabot> IO [()]
11:49:03 <davidhouse> @type sequence_ $ repeat $ putStrLn "hello world"
11:49:04 <lambdabot> IO ()
11:49:11 <davidhouse> hmm.
11:49:26 <mathrick> @type sequence_
11:49:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:50:22 <davidhouse> there's no difference between those two is there?
11:50:53 <davidhouse> something like main = sequence $ replicate 5 $ putStrLn "hello world" would produce exactly the same results as when used with sequence_
11:51:36 <mathrick> <lambdabot> IO [()]
11:51:37 <mathrick> <lambdabot> IO ()
11:51:49 <mathrick> there is, AFAICS
11:54:53 <resiak> sequence_ is when you don't care about the result, I think
11:55:35 <davidhouse> yeah, it is.
11:56:20 <davidhouse> i just found out where i was going wrong: i'd always been using sequence, but that's only because somewhere further down my do block i'd have a call of type IO (), so it'd work.
11:56:27 <davidhouse> main has to be of type IO ().
11:57:08 <ndm> davidhouse: it used to, now i think its IO a
11:57:08 <davidhouse> wait, apparently it doesn't.
11:57:29 <davidhouse> @type main
11:57:30 <lambdabot> Not in scope: `main'
11:57:34 <davidhouse> was worth a shot :)
11:58:40 <ihope_> :-)\
11:58:41 <davidhouse> wow, even stuff like main = getLine works. must be IO a.
11:59:04 <ihope_> I don't see why we'd restrict it to IO ().
11:59:53 <ihope_> @djinn-add data IO a
12:00:10 <ihope_> @djinn-add (>>=) :: IO a -> (a -> IO b) -> IO b
12:00:10 <lambdabot> Cannot parse command
12:00:13 <ihope_> Aww.
12:00:20 <ihope_> @djinn-env
12:00:20 <lambdabot> data () = ()
12:00:20 <lambdabot> data Either a b = Left a | Right b
12:00:20 <lambdabot> data Maybe a = Nothing | Just a
12:00:20 <lambdabot> data Bool = False | True
12:00:20 <lambdabot> data Void
12:00:23 <lambdabot> type Not x = x -> Void
12:00:25 <lambdabot> data IO a
12:04:34 <ihope_> @djinn-del IO
12:05:53 <ihope_> So to get a Void from ((a -> b) -> a) -> a, we need to pass it a (Void -> a) -> Void. To get a Void from Void -> a, we need to pass it a Void.
12:06:16 <davidhouse> what's a Void?
12:06:28 <davidhouse> @index Void
12:06:28 <lambdabot> bzzt
12:06:40 <vincenz> Void is what is in ihope_'s head
12:06:49 <mathrick> data Void
12:06:50 <mathrick> :)
12:07:31 <vincenz> > bot
12:07:31 <lambdabot>  Not in scope: `bot'
12:07:39 <ihope_> > undefined
12:07:40 <lambdabot> Add a type signature
12:07:45 <davidhouse> > undefined :: Int
12:07:46 <lambdabot> Undefined
12:07:55 <ihope_> > undefined :: Void
12:07:56 <lambdabot>  Not in scope: type constructor or class `Void'
12:08:03 <ihope_> Um.
12:08:06 <ihope_> > const
12:08:07 <lambdabot>  add an instance declaration for (Show (a -> b -> a))
12:14:23 <ihope_> "Schrdinger's cat was named Erwin?" "No, Schrdinger himself was called Erwin."
12:14:47 <ValarQ> :)
12:15:17 <vincenz> Cale: ?
12:15:27 <vincenz> Cale: can you tell lambdabot to join #meta-science?
12:15:58 <davidhouse> vincenz:, get your own ;)
12:15:59 <mathrick> > "The letter h is not allowed in this channel" >>= (\x -> if x == 'h' || x == 'H' then [] else return x)
12:16:00 <lambdabot> "Te letter  is not allowed in tis cannel"
12:16:21 <davidhouse> filter (/='h') "The letter h is not allowed in this channel"
12:16:27 <mathrick> pff
12:16:28 <davidhouse> > filter (/='h') "The letter h is not allowed in this channel"
12:16:29 <lambdabot> "Te letter  is not allowed in tis cannel"
12:16:32 <mathrick> cheapskate
12:16:52 <mathrick> +/- spelling
12:16:59 <ihope_> > filter (/='h') "Meta-science: Everything from philosophy to abstract coding"
12:17:01 <lambdabot> "Meta-science: Everyting from pilosopy to abstract coding"
12:17:21 <mathrick> pilosopy!
12:17:28 <bolrod> ;o?
12:17:49 <mathrick> > filter (/='h') "Let the light of philosophy shine brightly over our heads"
12:17:50 <lambdabot> "Let te ligt of pilosopy sine brigtly over our eads"
12:18:14 <davidhouse> > (\s -> if any (=='h') then "aargh" else "works") "This letter that follows g is just a waste of time"
12:18:14 <lambdabot> Couldn't match `Bool' against `t -> t1'
12:18:15 <ihope_> Wat are eads?
12:18:21 <davidhouse> > (\s -> if any (=='h') s then "aargh" else "works") "This letter that follows g is just a waste of time"
12:18:22 <lambdabot> "aargh"
12:18:38 <ihope_> I call it OTEL.
12:18:46 <mathrick> OTL
12:18:54 <ihope_> You know. ALPA, BRAVO, CARLIE...
12:19:03 <mathrick> but tat requires some familiarity wit 4can and stuff
12:19:05 <bolrod> Alfa  Bravo  Charlie  Delta 
12:19:11 <ihope_> ...GOLF, OTEL.
12:19:24 <bolrod> Golf  Hotel ...
12:19:41 <bolrod> India .. ^.0
12:19:43 <mathrick> bolrod: you are opeless, my boy
12:19:58 <bolrod> hehe
12:20:44 <bolrod> its ilarious
12:20:50 <bolrod> hmm
12:20:50 <mathrick> yes
12:20:54 <bolrod> ilarius
12:20:57 <bolrod> :)
12:21:01 <bolrod> sounds like latin
12:21:05 <mathrick> especially since we are coding in askell
12:21:06 <ihope_> :-)
12:21:23 <davidhouse> what nationality was Haskell Curry?
12:21:29 <ihope_> German, I tink
12:21:31 <davidhouse> because that's just about the funkiest name ever.
12:21:39 <bolrod> :)
12:21:44 <ihope_> E. Askell Brooks Curry...
12:22:04 <bolrod> Haskell Brooks Curry (September 12, 1900, Millis, Massachusetts - September 1, 1982, State College, Pennsylvania)
12:22:27 * mathrick eats some more salmiakki and ruins is palate completely
12:22:36 <bolrod> hmm
12:22:50 <bolrod> Gttingen... sounds indeed german
12:22:55 <mathrick> woever saped tose candy sould be sot repeatedly in te ead
12:23:04 <mathrick> s/tose/tese/
12:23:36 <bolrod> The son of educator Samuel Silas Curry
12:23:37 <bolrod> hmm..
12:23:55 <bolrod> almost sounds like its eatable
12:24:48 <mathrick> usually called 'edible'
12:24:52 <mathrick> don't ask why
12:24:56 <mathrick> oops
12:25:04 <bolrod> why?
12:25:04 <mathrick> wy, I meant wy!
12:25:09 <ihope_> !
12:25:10 <bolrod> hehe
12:25:11 <ihope_> O noes!
12:25:33 <bolrod> you ave failed me for te last time....!
12:25:50 <bolrod> !
12:25:53 <bolrod> a a a a
12:26:05 <bolrod> 8/
12:26:16 <ihope_> I really, really ate you guys.
12:26:23 <bolrod> tru!
12:26:29 <ihope_> And you tasted good. Mmm...
12:26:33 <wchogg> "a a a a"?  Is tat a stutter or just maniacal laugter?
12:26:44 <davidhouse> ha ha ha ha.
12:26:52 <bolrod> =)
12:28:48 <mathrick> I sould start moving my stuff
12:28:56 <bolrod> to ere?
12:29:08 * mathrick is moving out and as to return is room on 15t
12:29:18 <mathrick> bolrod: "were"
12:29:31 <bolrod> sut up
12:29:31 <mathrick> to my friend's room
12:29:35 <bolrod> =)
12:29:40 <bolrod> ;o
12:29:55 <bolrod> well... you could. ofcourse.. 
12:30:02 <mathrick> I could wat?
12:30:11 <bolrod> could move your stuff
12:30:20 <mathrick> nono, I sould
12:30:31 <bolrod> yes..
12:30:44 <bolrod> isn't it te same?
12:30:45 <mathrick> because oterwise tey will do it anyways, just I'll gonna ave to pay for tat
12:31:03 <mathrick> and tat's just not nice
12:31:05 <bolrod> tat sucks
12:31:12 <mathrick> *srug*
12:31:41 * mathrick ponders correcting the topic a bit
12:31:50 <bolrod> hehe
12:31:54 <bolrod> ;0
12:31:57 <mathrick> A!
12:32:01 <mathrick> I did it again!
12:32:01 <ihope_> I tried to. It didn't work.
12:32:06 * mathrick ides in same
12:32:20 <bolrod> it is ard to lauf witout te aitjs
12:32:40 <mathrick> you can always do 
12:32:45 <mathrick> or 
12:32:49 <mathrick> or 
12:32:54 <bolrod> ????
12:32:54 <lambdabot> Unknown command, try @listcommands.
12:33:01 <ihope_> !
12:33:11 <bolrod> it looks like my terminal finds your writings difficult to read
12:33:22 <bolrod> or to sjow... watever.
12:33:27 <ihope_> My cat client sows question marks.
12:33:28 <mathrick> tese sould be allowed, tey ave  sound, but not te  letter
12:33:48 <mathrick> it's japanese, iragana to be exact
12:33:56 <bolrod> my irc client is really basic... and cool
12:33:59 <mathrick> you can also laug in katakana
12:34:02 <davidhouse> works here.
12:34:12 <bolrod> Oi!
12:34:13 <ihope_> bolrod: is it as basic as telnet?
12:34:14 <mathrick> 
12:34:25 <bolrod> irssi
12:34:28 <mathrick> 
12:34:33 <bolrod> !!!!!!!!!!!!!!!!!
12:34:34 <davidhouse> mathrick: the first four look like an I followed by a crossed J, that right?
12:34:35 <mathrick> 
12:34:47 <mathrick> davidhouse: somewhat, yes
12:34:48 <bolrod> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
12:34:53 <tomshackell> irssi is great
12:34:54 <ihope_> 
12:34:57 * tomshackell uses irssi
12:35:01 <mathrick> and it can use utf-8 too
12:35:03 * SimonRC too
12:35:12 <mathrick> but I use xcat myself
12:35:26 <bolrod> looks like you guys suck at not typing the aitsj
12:35:29 <bolrod> :/
12:35:30 <SimonRC> UTF-8 is quite high on my list of "Things that Rock"
12:35:38 <bolrod> Oi! Crickey!
12:35:44 <mathrick> 
12:35:46 <ihope_> bolrod: the wat?
12:35:51 <davidhouse> mathrick: hehe :)
12:36:07 <SimonRC> mathrick: have some Hs HHHHHHhhhhhhhhhhhhhhhhhhhhhhh
12:36:10 <bolrod> mathrick: you sure?
12:36:12 <mathrick> wy?
12:36:21 <ihope_> Too many otels.
12:36:24 <bolrod> insult me >:)
12:36:32 * ihope_ insults bolrod
12:36:32 <mathrick> e e
12:36:34 <SimonRC> mathrick: you lack them
12:36:40 <mathrick> no, rly?
12:36:48 <mathrick> I aven't noticed
12:36:59 <mathrick> does tis appen often?
12:37:10 <bolrod> ow can you insult someone witout tem knowink.. :/
12:37:27 <ihope_> I just insulted you. Did you notice?
12:37:35 <chris2>  snq ,u no  poun s poo 
12:37:38 <bolrod> I did
12:37:38 <bolrod> !
12:37:54 <mathrick> 
12:37:58 <SimonRC> chris2: where are the upside-down letters in unicode?
12:38:00 <mathrick> 
12:38:04 <bolrod> mathrick: try
12:38:05 <mathrick> SimonRC: IPA
12:38:07 <ihope_> True.
12:38:28 <ihope_> Mmm, IPA.
12:38:40 <chris2> the upside-down n is difficult to find :P
12:38:41 <ihope_> Ponetic alpabet.
12:38:47 <SimonRC> International Phonetic alphabet, not the beer
12:38:51 <mathrick> more like pony
12:38:59 <davidhouse> chris2, between y and i
12:39:01 <bolrod> ;o
12:39:07 <bolrod> mpmmffffp mffffp mmfpffmmmffpffm
12:39:17 <chris2> davidhouse: quertz here ;)
12:39:27 <mathrick> tat still applpies
12:39:31 <mathrick> almost
12:39:42 <ihope_> @elp djinn-add
12:39:43 <lambdabot> Define a new function type or type synonym
12:39:49 <davidhouse> :)
12:39:52 <mathrick> I submit we sould applepie functions from now on
12:40:05 <ihope_> Mmm, sounds yummy.
12:40:11 <ihope_> Ow is it done?
12:40:14 <bolrod> irc is not made for sounds
12:40:35 <davidhouse> > if True ten "yep" else "nope"
12:40:36 <lambdabot>  parse error on input `else'
12:40:37 <chris2> tat would be evil
12:40:47 <bolrod> =)
12:40:47 <mathrick> ihope_: like normal application, just more flour
12:40:51 <ihope_> A.
12:41:01 <ihope_> > if' True "yep" "nope"
12:41:01 <lambdabot>  Not in scope: `if''
12:41:13 <ihope_> But @pl uses it all te time!
12:41:41 <davidhouse> @pl \x -> if x then "yes" else "no"
12:41:41 <lambdabot> flip (flip if' "yes") "no"
12:41:56 <mathrick> > let if' x y z = if x then y else z in if' True "yep" "nope"
12:41:57 <lambdabot> "yep"
12:42:04 <bolrod> > data B00l = Tru | Yar 
12:42:05 <lambdabot>  parse error on input `data'
12:42:14 * SimonRC really wants ifM
12:42:18 <SimonRC> monadic if
12:42:26 <mathrick> ow would tat work?
12:42:28 <davidhouse> when is pretty close
12:42:37 <ihope_> Yes, ow?
12:42:38 <ihope_> s/s/a/
12:42:58 <davidhouse> > let ifM p y n = when p y >> unless p n
12:42:58 <lambdabot>  parse error on input `}'
12:43:03 <SimonRC> ifM fileExists "foo.txt" then "yes" else "no"
12:43:40 <ihope_> I'd say ifM fileExists "foo.txt" then return "yes" else return "no"
12:43:48 <davidhouse> yeah.
12:44:01 <SimonRC> that's a subset of what mine can do
12:44:15 <SimonRC> mine is equivalent to (fileExists "foo.txt") >>= \x -> if x then "yes" else "no"
12:44:18 <mathrick> mine can also give you coal!
12:44:23 <SimonRC> return is just a function, after all
12:44:33 <mathrick> and tat's not someting easily emulated in askell
12:44:45 <ihope_> SimonRC: tat would mean (fileExists "foo.txt") is in te list monad
12:44:56 <SimonRC> erm, no
12:45:07 <SimonRC> why?
12:45:11 <bolrod> wy?
12:45:22 <ihope_> Because te function on the rigt side returns a [Char].
12:45:28 <SimonRC> why the [] monad?
12:45:36 <ihope_> Because te function on the rigt side returns a [Char].
12:45:43 <SimonRC> eh?
12:45:50 <ihope_> @type \x -> if x then "yes" else "no"
12:45:51 <lambdabot> Bool -> [Char]
12:45:51 <davidhouse> let ifM p y n = p >>= \if p then y else n
12:45:52 <bolrod> you see... it is not needed to ave te 8th letter of te current alfabet.. to make yourself understandable..
12:46:00 <bolrod> OI
12:46:06 <bolrod> SJEET
12:46:15 <wchogg> Sjeet?
12:46:17 <bolrod> I guess it is at some point
12:46:23 <bolrod> :)
12:46:27 <ihope_> Sierra otel eco eco tango?
12:46:29 <davidhouse> > let ifM p y n = p >>= \if p then y else n in ifM (Just Bool) "yes" "no"
12:46:30 <lambdabot>  parse error on input `if'
12:46:38 <davidhouse> > let ifM p y n = p >>= \b if b then y else n in ifM (Just Bool) "yes" "no"
12:46:39 <lambdabot>  parse error on input `if'
12:46:46 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM (Just Bool) "yes" "no"
12:46:47 <lambdabot>  Not in scope: data constructor `Bool'
12:46:52 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM (Just True) "yes" "no"
12:46:52 <lambdabot> Couldn't match `Maybe' against `[]'
12:46:57 <davidhouse> wow... my head isn't screwed on today.
12:47:10 <bolrod> cool
12:47:12 <bolrod> take a picture
12:47:34 <davidhouse> hmm... ihope's right. the then and else branches would have to have type Bool.
12:47:42 <SimonRC> why?
12:47:56 <davidhouse> @type (>>=)
12:47:57 <lambdabot> forall (m :: * -> *) b a.
12:47:57 <lambdabot>    (Monad m) =>
12:47:57 <lambdabot>    m a -> (a -> m b) -> m b
12:48:14 <davidhouse> wait, no.
12:48:14 <SimonRC> @type mx -> mx >>= (\ x -> if x then "yes" else "no")
12:48:15 <lambdabot> Parse error in pattern
12:48:21 <SimonRC> @type \mx -> mx >>= (\ x -> if x then "yes" else "no")
12:48:22 <lambdabot> [Bool]
12:48:22 <lambdabot>                   -> [Char]
12:48:32 <SimonRC> grr
12:48:32 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM (Just True) (Just "yes") (Just "no")
12:48:33 <lambdabot> Just "yes"
12:48:37 <SimonRC> stupid parser
12:48:40 <SimonRC> oops
12:48:54 <SimonRC> stupid mis-smart type checker
12:49:05 <bolrod> ...
12:49:08 <bolrod> riiite
12:49:09 <SimonRC> @type \mx -> (mx :: Just Int) >>= (\ x -> if x then "yes" else "no")
12:49:10 <lambdabot> Not in scope: type constructor or class `Just'
12:49:16 <SimonRC> @type \mx -> (mx :: Maybe Int) >>= (\ x -> if x then "yes" else "no")
12:49:17 <lambdabot>   Couldn't match `Bool' against `Int'
12:49:17 <lambdabot>   Expected type: Bool
12:49:24 <SimonRC> @type \mx -> (mx :: Maybe Bool) >>= (\ x -> if x then "yes" else "no")
12:49:24 <lambdabot>   Couldn't match `Maybe' against `[]'
12:49:24 <lambdabot>   Expected type: Maybe b
12:49:33 <SimonRC> @type >=
12:49:33 <lambdabot> parse error on input `>='
12:49:36 <SimonRC> @type >>=
12:49:36 <lambdabot> parse error on input `>>='
12:49:40 <SimonRC> @type (>>=)
12:49:41 <lambdabot> forall (m :: * -> *) b a.
12:49:41 <lambdabot>    (Monad m) =>
12:49:41 <lambdabot>    m a -> (a -> m b) -> m b
12:49:46 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM (Just True) (Just "yes") (Just "no")
12:49:47 <lambdabot> Just "yes"
12:50:06 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM [True] ["yes"] ["no"]
12:50:07 <lambdabot> ["yes"]
12:50:22 <davidhouse> > let ifM p y n = p >>= \b -> if b then y else n in ifM [True] "yes" "no"
12:50:23 <lambdabot> "yes"
12:50:26 <ihope_> @djinn a -> (a -> a)
12:50:27 <lambdabot> f _ a = a
12:50:36 <ihope_> @djinn (a -> a) -> (a -> b -> b) -> b -> b
12:50:37 <lambdabot> f _ _ a = a
12:50:41 <bolrod> :)
12:50:44 <ihope_> Heh.
12:50:46 <bolrod> elpfull e'
12:50:48 <ihope_> Oops.
12:51:17 <mathrick> wat is djinn?
12:51:29 <ihope_> @djinn (a -> b -> c) -> (a -> b) -> a -> c
12:51:29 <lambdabot> f a b c = a c (b c)
12:51:30 <ihope_> Tat.
12:51:38 <bolrod> @djinn (a->b->a)->a->[b]->a
12:51:38 <lambdabot> f _ a _ = a
12:51:44 <bolrod> stupid
12:51:50 <bolrod> tats foldl!
12:52:04 <ihope_> Well, it doesn't like the definition of [].
12:52:15 <bolrod> it is useless
12:52:18 <ihope_> :-P
12:52:33 <bolrod> @djinn (a->b->a)->a->[b]->[a]
12:52:33 <lambdabot> -- f cannot be realized.
12:52:35 <davidhouse> djinn makes functions up to match a given type
12:52:41 <ihope_> You might as well ave done (a -> b -> a) -> a -> c -> a
12:52:47 <bolrod> I can see tat
12:52:53 <ihope_> And for that last one, (a -> b -> a) -> a -> d -> c
12:53:01 <davidhouse> @djinn a -> b
12:53:01 <lambdabot> -- f cannot be realized.
12:53:04 <mathrick> watc your spelling!
12:53:05 <SimonRC> djinn doesn't like lists
12:53:13 <davidhouse> @type f = "hello"
12:53:14 <lambdabot> parse error on input `='
12:53:18 <davidhouse> @type "hello"
12:53:19 <lambdabot> [Char]
12:53:35 <bolrod> @type ["[ello]"]
12:53:35 <lambdabot> [[Char]]
12:53:38 <bolrod> 8)
12:54:40 <bolrod> tat mite look confusing toug
12:54:49 <bolrod> damn.. tat word is ard to spell
12:55:10 <davidhouse> @where djinn
12:55:10 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
12:55:59 <bolrod> I am bored
12:56:20 <ihope_> Let's ban a different letter.
12:56:25 <mathrick> > foldr (\ _ x -> [x]) 1 replicate [] 123
12:56:25 <lambdabot> Couldn't match `t -> t1 -> t2' against `[a]'
12:56:30 <bolrod> not even tese wobbly screens can make me apy
12:56:34 <mathrick> > foldr (\ _ x -> [x]) 1 replicate 1 123
12:56:35 <lambdabot> Couldn't match `t -> t1 -> t2' against `[a]'
12:56:38 <mathrick> hmm
12:56:59 <ihope_> Okay. OVEMBER is out.
12:57:07 <mathrick> okay
12:57:13 <bolrod> yes.. I installed XGL wit compiz... 
12:57:17 <mathrick> is otel still i effect?
12:57:22 <ihope_> Ope.
12:57:34 <ihope_> We can use that one ow! Yay!
12:57:36 <bolrod> hahaha
12:57:37 <mathrick> ooray!
12:57:42 <bolrod> ca?
12:57:46 <bolrod> o e?
12:57:52 <davidhouse> > foldr (\_ x -> [x]) 1 $ replicate 1 123
12:57:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:57:53 <lambdabot>   Expected type: a
12:57:53 <lambdabot>   Inferred type: [a]
12:57:58 <ihope_> Cmo?
12:58:06 <bolrod> 21:57:12 < ihope_> We can use that one ow! Yay!
12:58:13 <bolrod> ca_  o_e ?
12:58:20 <ihope_> Ah.
12:58:22 <ihope_> @fortue
12:58:22 <lambdabot> quote module failed: getRandItem: empty list
12:58:30 <bolrod> ah drats
12:58:31 <ihope_> Too bad.
12:58:47 <mathrick> but @help works ow!
12:58:50 <bolrod> I could make a script for that
12:59:36 <ihope_> Dag. The oly commo word usig OVEMBER is "ow".
12:59:41 <ihope_> ;-)
12:59:54 <mathrick> > foldr (\ x _ -> [x]) 1 replicate 1 123
12:59:55 <lambdabot> Couldn't match `t -> t1 -> t2' against `[a]'
12:59:59 <mathrick> boo
13:00:15 <SimonRC> ihope_: is that "now" or "own"?
13:00:24 <ihope_> The former.
13:00:25 <davidhouse> or even "onw"?
13:00:29 * mathrick ca't stop eatig cady
13:00:40 <davidhouse> :)
13:00:52 <mathrick> I'm goa get fat
13:01:09 <SimonRC> mathrick: don', caddies are bad for you.
13:01:37 <mathrick> ah, they are't
13:01:38 <SimonRC> Oh grea, I'm no yping  any more!
13:01:48 <ihope_> Oh oes!
13:01:53 <SimonRC> his is geing silly.
13:01:59 <bolrod> hahahahhaa
13:02:07 <bolrod> u are teh suck at this
13:02:14 <ihope_> Of course, we do't have to ba that.
13:02:29 <mathrick> how about we ba all vowels?
13:02:33 <davidhouse> my 'e' key broke on my keyboard once.
13:02:38 <ihope_> :-)
13:02:38 <SimonRC> one of us isn' yping h, anoher isn' yping n, and I'm no using .
13:02:48 <ihope_> O noes.
13:02:49 <mathrick> nd w'll hv smthng lk rbc scrpt
13:02:51 <ihope_> Tis is bad.
13:02:59 <davidhouse> it worked it you pressed it really, really hard, so i'd do that at the beginning of every session then copy-paste it everywhere.
13:03:09 <SimonRC> LOL
13:03:26 <mathrick> davidhouse: heh, I had the same with x for a log time
13:03:40 <ihope_> Repeat after me: The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog.
13:03:45 <mathrick> I mapped it to a otherwise useless key you can fid o daish keyboards
13:03:53 <SimonRC> "DearJimSpaceBarIsBrokenCanYouFixItPlease."
13:04:06 <SimonRC> where Jim == sysadmin
13:04:18 <mathrick> heh
13:04:19 <ihope_> programmersDontLikeToPutSpacesInIdentifiers
13:04:20 <bolrod> whut a stupid excuse to 'ot typi' a space
13:04:21 <davidhouse> > filter (`notElem` "hn") "The quick brown fox jumps over the lazy dog"
13:04:22 <lambdabot> "Te quick brow fox jumps over te lazy dog"
13:04:22 <ihope_> iDontKnowWhy
13:04:36 <mathrick> IDoLikeSpacesIMyIdetifiers
13:04:36 <davidhouse> camelCaseAllTheWay
13:05:00 <mathrick> ActuallyIPreferUderscoreAsThisCaBeUsedInPopularLaguages
13:05:06 <SimonRC> ihope_: because i ends o make hings a bi ambiguous if you allow spaces
13:05:16 <mathrick> somethig_like_that
13:05:22 <bolrod> > filter (`notElem` "bah") "this must be really stupid
13:05:23 <lambdabot>  lexical error in string/character literal
13:05:25 <bolrod> > filter (`notElem` "bah") "this must be really stupid"
13:05:26 <lambdabot> "tis must e relly stupid"
13:05:29 <SimonRC> mathrick: check ou Emacs's "glasses-mode"
13:05:42 <mathrick> guess what I have eabled all the time?
13:05:59 <mathrick> also, they patched it *really* stupidly i oe of recet cvs's
13:06:07 <jonkri> why can't i do "a <- return Nothing"? the function type is IO [Maybe Int]
13:06:10 * mathrick had to patch it back maually
13:06:28 <SimonRC> jonkri: hmm
13:06:29 <jonkri> expected type: (Maybe Int), inferred type: Maybe Int
13:06:33 <davidhouse> jonkri, needs to be alist
13:06:35 <davidhouse> *a list
13:06:39 <ihope_> Wait, which servers are gonna be affected and all that?
13:06:49 * ihope_ joins every server, just to be safe
13:06:51 <mathrick> affected by what?
13:06:53 <jonkri> yeah, but i later on returns [a]
13:06:56 <jonkri> so i should be alright?
13:07:12 <jonkri> it's this "<-" line that gets the error
13:07:17 <davidhouse> a <- return $ head [Nothing]
13:07:34 <davidhouse> it has to be the same monad all the way through.
13:07:42 <davidhouse> or in your case, the same three monads. eurgh.
13:08:03 <jonkri> hmm, ok
13:08:05 <ihope_> Three monads?
13:08:08 <davidhouse> i think.
13:08:11 <ihope_> Why a list of maybes?
13:08:18 <davidhouse> ihope_, IO, [], Int.
13:08:29 <davidhouse> err
13:08:31 <ihope_> Maybe.
13:08:32 <davidhouse> IO, [], Maybe
13:08:42 <ihope_> instance Monad Int where...
13:08:45 <ihope_> That'd be weird.
13:08:46 <SimonRC> :-D
13:08:55 <bolrod> hmm. who of you is using windows?
13:08:56 <bolrod> :)
13:09:00 <SimonRC> alas, Int doesn;t have kind * -> *
13:09:01 <ihope_> I'm using Windows.
13:09:11 <ihope_> True >>= False
13:09:15 <ihope_> > True >> False
13:09:16 <lambdabot> Couldn't match `m a' against `Bool'
13:09:21 <ihope_> (I changed my mind)
13:09:34 <davidhouse> aargh
13:09:51 <davidhouse> herbert's down then :)
13:10:07 <davidhouse> wb, everyone.
13:10:44 <chris2> mathrick: i just discovered c-subword-mode today... it works in other modes too
13:10:45 <ihope_> What's WB?
13:10:59 <wchogg> Welcome back.
13:11:02 <ihope_> Ah.
13:11:03 <mathrick> chris2: I do that with cua-mode
13:11:24 <ihope_> > (map head . words) "welcome back"
13:11:28 <mathrick> and c-{backward,forward}-into-nomenclature
13:11:32 <lambdabot> "wb"
13:11:42 <chris2> aah
13:12:06 <mathrick> but that c-subword looks like it could be even better
13:12:17 <mathrick> alternatively, M-x camel-case-mode :)
13:12:21 <chris2> "This function is obsolete; use `c-forward-subword' instead."
13:12:24 <chris2> :)
13:12:34 <davidhouse> ihope_: i just like it because when you pronounce it as "wub" it sounds funny
13:12:50 <ihope_> :-)
13:13:01 <bolrod> hmm..
13:13:05 <mathrick> I'm not sure I like salmiakki-methol taste
13:13:47 <ihope_> @wb
13:13:54 <ihope_> @wb salmiakki
13:13:55 <lambdabot> No match for "salmiakki".
13:14:00 <ihope_> @help wb
13:14:00 <lambdabot>  @help <command> - ask for help for <command>
13:14:03 <ihope_> ...
13:14:07 <mathrick> :)
13:14:08 <ihope_> @wb the
13:14:09 <lambdabot> No match for "the".
13:14:25 <ihope_> @wb a
13:14:26 <lambdabot> *** "A" wn "WordNet (r) 2.0"
13:14:26 <lambdabot> A
13:14:26 <lambdabot>   n 1: the blood group whose red cells carry the A antigen [syn: {
13:14:26 <lambdabot> type
13:14:26 <lambdabot>     A}, {group A}]
13:14:28 <lambdabot> [16 @more lines]
13:14:35 <ihope_> @help wn
13:14:35 <lambdabot> I perform dictionary lookups via the following 13 commands:
13:14:35 <lambdabot>  @all-dicts .. Query all databases on dict.org
13:14:35 <lambdabot>  @devils ..... The Devil's Dictionary
13:14:36 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
13:14:38 <lambdabot>  @elements ... Elements database
13:14:40 <lambdabot> [9 @more lines]
13:14:42 <ihope_> There we go.
13:14:49 <ihope_> @all-dicts salmiakki
13:14:50 <lambdabot> No match for "salmiakki".
13:15:30 <mathrick> ihope_: wikipedia
13:16:30 <mathrick> okay, I should stop now, my palate is really fubar'd, and my stuff really needs moving
13:17:32 <bolrod> :)\
13:17:34 <bolrod> sure
13:17:36 <bolrod> go ahead
13:17:57 <bolrod> I'll just grab some chips and something to drink
13:17:58 <bolrod> or something
13:18:03 <bolrod> 8)
13:44:41 <shapr> shazam!
13:53:33 <twobitsprite> ghci doesn't let you define functions in it?
13:53:50 <ihope_> let f x = ...
13:54:26 <ihope_> > filter (/='a') "abacabadabacabaeabacabadabacabafabacabadabacabaeabacabadabacabag"
13:54:26 <lambdabot> "bcbdbcbebcbdbcbfbcbdbcbebcbdbcbg"
13:54:41 <ihope_> > filter (/='b') "bcbdbcbebcbdbcbfbcbdbcbebcbdbcbg"
13:54:42 <lambdabot> "cdcecdcfcdcecdcg"
13:54:45 <twobitsprite> ahh
13:58:06 <goltrpoat> quick question.. i was reading hutton and meijer's 'monadic parser combinators' a little while ago, and they're using monad comprehension all over the place (in gofer).  i couldn't find an equivalent in haskell98, so i used either do notation or an explicit series of >>='s.  did monad comprehension just not make it into the 98 standard?
13:59:30 <ndm> goltrpoat: no, it didn't
13:59:37 <ndm> only list comprehension
13:59:45 <goltrpoat> do you know why?  just curious
13:59:48 <ndm> although its possible GHC supports it with a flag
13:59:53 <goltrpoat> ah
14:00:00 <ndm> the reason was to help beginners not get confusing error messages
14:00:15 <ndm> so list comprehensions can be taught early on, and the error messages do not to
14:00:20 <ndm> talk about monads
14:00:34 <goltrpoat> ah right, that's sort of what i was thinking
14:02:37 <ihope_> How do I make noise with Haskell? :-)
14:02:56 <mathrick> ?
14:03:39 <ihope_> Play notes.
14:03:44 <mathrick> > foldr (:) "" replicate 100 "spam"
14:03:44 <lambdabot> Couldn't match `[a]' against `t -> t1 -> t2'
14:03:47 <mathrick> buh
14:03:57 <mathrick> > foldr (++) "" replicate 100 "spam"
14:03:58 <lambdabot> Couldn't match `[a]' against `t -> t1 -> t2'
14:04:08 * wolverian hands mathrick a $
14:04:09 <mathrick> > foldr (++) "" $ replicate 100 "spam"
14:04:10 <lambdabot> "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp
14:04:10 <lambdabot> amspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspams
14:04:10 <lambdabot> pamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspam
14:04:10 <lambdabot> spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa
14:04:10 <lambdabot> mspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp
14:04:12 <lambdabot> amspamspamspamspamspamspam"
14:04:35 <ihope_> (unwords . replicate 100) "spam"
14:04:48 <Beelsebob> > concat $ repeat "spam"
14:04:49 <lambdabot> "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp
14:04:49 <lambdabot> amspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspams
14:04:49 <lambdabot> pamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspam
14:04:49 <lambdabot> spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa
14:04:49 <lambdabot> mspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp
14:04:51 <lambdabot> [23 @more lines]
14:05:12 <mathrick> why only 23?
14:05:42 <ihope_> I think it only pays attention to the first 2048 characters.
14:05:53 <ihope_> > length "amspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspams"
14:05:54 <lambdabot> 75
14:06:04 <ihope_> > 75*28
14:06:05 <lambdabot> 2100
14:06:20 <Beelsebob> > 2048 `div` 75
14:06:21 <lambdabot> 27
14:06:28 <Beelsebob> yeh... 28 lines
14:06:41 <ihope_> > 75-(2100-2048_
14:06:41 <lambdabot>  parse error on input `}'
14:06:43 <ihope_> > 75-(2100-2048)
14:06:44 <lambdabot> 23
14:06:50 <wolverian> lambdabot, where are your sources?
14:06:55 <davidhouse> @where lambdabot
14:06:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:06:57 <Beelsebob> @where lambdabot
14:06:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:06:59 <wolverian> thanks!
14:07:02 <ihope_> @where lambdabot
14:07:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:07:04 <wolverian> I want @pt in my ghci :)
14:07:09 <mathrick> @pt?
14:07:09 <lambdabot> (line 1, column 1):
14:07:09 <lambdabot> unexpected end of input
14:07:09 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
14:07:09 <lambdabot> expression
14:07:15 <ihope_> @help pt
14:07:15 <davidhouse> @help pt
14:07:15 <lambdabot>  @help <command> - ask for help for <command>
14:07:15 <lambdabot>  @help <command> - ask for help for <command>
14:07:19 <davidhouse> @help @pt
14:07:20 <lambdabot>  @help <command> - ask for help for <command>
14:07:20 <ihope_> pl?
14:07:27 <ihope_> @pt \x y -> x >>= y
14:07:28 <lambdabot> (>>=)
14:07:28 <Beelsebob> @help pt
14:07:28 <lambdabot>  @help <command> - ask for help for <command>
14:07:30 <davidhouse> pl or pf, i guess you mean
14:07:31 <ihope_> Yep, pl.
14:07:37 <ihope_> @help pf
14:07:38 <lambdabot>  @help <command> - ask for help for <command>
14:07:40 <Beelsebob> oh - bad
14:07:43 <ihope_> @help pl
14:07:43 <lambdabot>  @pointless <expr> - play with pointfree code
14:07:45 <ihope_> ;-)
14:07:48 <wolverian> hrm, I actually just used @pt accidentally 
14:07:53 <Beelsebob> @where pointless
14:07:53 <wolverian> and thought it was @pl, since lambdabot did reply
14:07:54 <lambdabot> I know nothing about pointless.
14:07:58 <Beelsebob> oh - okay?
14:08:00 <wolverian> (in private)
14:08:04 <mathrick> so what does it do?
14:08:14 <davidhouse> converts to pointsfree style.
14:08:24 <davidhouse> @pl \x -> x*x
14:08:24 <lambdabot> join (*)
14:08:30 <Beelsebob> i.e. removes the arguments from the function definition
14:08:31 <davidhouse> @pl \x -> x^2
14:08:31 <lambdabot> (^ 2)
14:08:33 <jethr0_> @pl \a b -> a + b
14:08:33 <lambdabot> (+)
14:08:37 <wolverian> hrm, what's @pt then?
14:08:42 <Beelsebob> it isn't
14:08:44 <davidhouse> @pf \x -> x^2
14:08:44 <Beelsebob> @pt
14:08:45 <lambdabot> (^ 2)
14:08:45 <lambdabot> (line 1, column 1):
14:08:45 <lambdabot> unexpected end of input
14:08:45 <lambdabot> expecting white space, natural, identifier, lambda abstraction or
14:08:45 <lambdabot> expression
14:08:47 <ihope_> pt is pl
14:08:48 <jethr0_> @pl even 4 && odd 4
14:08:49 <lambdabot> even 4 && odd 4
14:08:57 <jethr0_> bah
14:08:58 <wolverian> oh, thanks
14:08:58 <ihope_> :-P
14:08:58 <davidhouse> pf is pl. pt doesn't exist.
14:09:05 <ihope_> @pl True && False
14:09:05 <davidhouse> @pt \x -> x^2
14:09:06 <lambdabot> False
14:09:06 <lambdabot> (^ 2)
14:09:10 <davidhouse> oh, maybe it does.
14:09:11 <Beelsebob> @pl \x -> even x && odd x
14:09:11 <lambdabot> liftM2 (&&) even odd
14:09:16 <davidhouse> pf = pl = pt
14:09:20 <ihope_> @pl Yes `and` No
14:09:21 <lambdabot> Yes `and` No
14:09:22 <jethr0_> ah
14:09:35 <SimonRC> @type Yes `and` No
14:09:36 <lambdabot> Not in scope: data constructor `Yes'
14:09:36 <lambdabot>  
14:09:36 <lambdabot> <interactive>:1:10: Not in scope: data constructor `No'
14:09:46 <jethr0_> lambdabot has an editing distance built in, so that slightly misspellt commands are still recognized
14:09:59 <davidhouse> @pl \x y -> (show y^2) ++ map toUpper x
14:09:59 <lambdabot> flip ((++) . (^ 2) . show) . map toUpper
14:10:10 <jethr0_> this is paired with prefix analysis and looking how far from alternatives an input lies
14:10:34 <davidhouse> a lot of the time points-free is pointless. it's simply not readable enough.
14:10:37 <jethr0_> \typo (+)
14:10:38 <lambdabot> forall a. (Num a) => a -> a -> a
14:10:46 <ihope_> :-)
14:10:54 <ihope_> \type -> type
14:10:55 <lambdabot> parse error on input `->'
14:11:04 <ihope_> > `(foo)`
14:11:04 <lambdabot>  parse error on input ``'
14:11:07 <vincenz> @type typo
14:11:07 <lambdabot> Not in scope: `typo'
14:11:10 <vincenz> \@typo
14:11:11 <lambdabot> not an expression: `'
14:11:18 <ihope_> So how do I use (,) infix? ;-)
14:11:33 <Beelsebob> ihope... (a,b)
14:11:39 <davidhouse> > ((,)) 1 2
14:11:40 <lambdabot> (1,2)
14:11:40 <Beelsebob> it's the tupling function
14:11:46 <jethr0_> (,) is a bit limited with regards to sections, afaik
14:11:47 <ihope_> I know.
14:11:49 <vincenz> > ((,,)) 1 2 3
14:11:50 <lambdabot> (1,2,3)
14:11:52 <vincenz> ooh
14:12:02 <ihope_> But I can't foo `(,)` bar
14:12:10 <vincenz> ihope_:  you can't do that with any operator
14:12:17 <vincenz> > 1 `(+)` 2
14:12:17 <lambdabot>  parse error on input `('
14:12:18 <ihope_> > (,3)
14:12:18 <goltrpoat> bit off-topic, but how the hell does prolog do backtracking to perform function inversion, when you supply the result of a rule and query for the argument?  and, shouldn't there be a way to similarly formalize function inversion (say only on isomorphic functions, for simplicity's sake) in functional programming?
14:12:19 <lambdabot>  parse error on input `3'
14:12:21 <Beelsebob> ihope_: that's becasue it's an infix operator
14:12:35 <Beelsebob> ((,)3) 4
14:12:41 <Beelsebob> > ((,)3) 4
14:12:42 <lambdabot> (3,4)
14:12:43 <davidhouse> > 1 ((,)) 2
14:12:44 <lambdabot>   add an instance declaration for (Num ((a -> b -> (a, b)) -> t -> a1))
14:12:44 <lambdabot>   In the definition of `jsr': jsr = 1 ((,)) 2
14:12:44 <lambdabot>   In the definition of `v': v = let jsr = 1 ((,)) 2 in take 2048 (show
14:12:44 <lambdabot> jsr)
14:12:44 <vincenz> goltrpoat: tree traversal
14:12:46 <ihope_> Beelsebob: so why can't I do (,3)?
14:12:48 <davidhouse> grr.
14:12:56 <jethr0_> goltrpoat: is that decidable?
14:12:56 <Beelsebob> >(,3) 4
14:13:04 <Beelsebob> > (,3)4
14:13:05 <lambdabot>  parse error on input `3'
14:13:11 <Beelsebob> good question
14:13:14 <jethr0_> i mean whether a function is isomorphic/injective/bijective?
14:13:18 <davidhouse> > 1 (,) 2
14:13:19 <lambdabot>   add an instance declaration for (Num ((a -> b -> (a, b)) -> t -> a1))
14:13:19 <lambdabot>   In the definition of `den': den = 1 (,) 2
14:13:19 <lambdabot>   In the definition of `v': v = let den = 1 (,) 2 in take 2048 (show den)
14:13:24 <goltrpoat> vincenz:  not quite that easy, no?  at the leaf nodes, you just know that your arguments satisfy some boolean predicates, which puts bounds on them at best
14:13:37 <vincenz> goltrpoat: so.? traversal is topdwon, not bottomup
14:13:46 <vincenz> you add more and more conditions until you reach a leaf
14:13:48 <vincenz> if it fails
14:13:49 <vincenz> you go up
14:13:51 <vincenz> next leaf
14:13:52 <vincenz> if that fails
14:13:55 <vincenz> go up the tree, and pop a condition
14:13:57 <ihope_> It's not possible even to decide if a function is total...
14:14:20 <vincenz> ihope_: all depends on how you implement a function
14:14:23 <ihope_> newtype Self a = Self (Self a -> a) -- or something
14:14:41 <ihope_> (\(Self a) -> a (Self a)) (Self (\(Self a) -> a (Self a)))
14:14:52 <jethr0_> that gives me a headache
14:15:07 <ihope_> A type-safe version of (\x -> x x) (\x -> x x)
14:15:31 <goltrpoat> vincenz:  not following.  if i have a rule f(X,Y), and i say f(5,Y), you get your usual tree traversal -- say Y is written in terms of X.  what you're saying is if i go backwards, i start by assigning some value to X, go down the tree, fail, go back up, adjust the value, etc?
14:15:53 <goltrpoat> jethr0/ihope:  no, not decidable in general of course
14:16:03 <vincenz> goltrpoat: no... you don't adjust the value... haskell is pure... no side -effects... going back up automatically removes the value from X
14:16:12 <goltrpoat> vincenz:  i was talking about prolog though?
14:16:21 <vincenz> goltrpoat: It'll use asimilar system
14:16:30 <jethr0_> goltrpoat: how do you intend to "formalize function inversion" if it's not decidable??
14:16:38 <vincenz> goltrpoat: keep an environment, go down.... fails...pop the assertion X=5 from the environment
14:16:47 <vincenz> jethr0_: only for bijective functions
14:17:27 <jethr0_> vincenz, aren't injective functions invertible?
14:17:36 <jethr0_> vincenz: yes, but is bijectivity decidable!
14:17:47 <vincenz> jethr0_: no
14:17:51 <jethr0_> exactly
14:17:53 <vincenz> jethr0_: well yes... but only for a part of the domain
14:17:58 <vincenz> jethr0_: no was in response to first
14:18:38 <jethr0_> i never said anything about the whole domain. noone said the inverted function had to be total
14:18:44 <goltrpoat> well.. the idea was that the programmer says "this is bijective", and the compiler goes, oh ok, then i can invert the function.
14:18:49 <jethr0_> just well-defined
14:19:47 <goltrpoat> vincenz:  what i mean is..  and i really don't know much about prolog, i was just reading about it the other day and it seemed interesting.  say fac(0,_) :- 1.  fac(N,F) :- X > 0, M = N-1, fac(M,F1), F is F1*N.  then if i say ?- fac(5,X), i get X=120.  my understanding is that if i say ?- fac(X,120), i'll get X=5.
14:19:51 <vincenz> jethr0_: then use the proper word
14:19:54 <vincenz> jethr0_: function implies total
14:20:04 <jethr0_> does it? i didn't know that
14:20:06 <vincenz> yep
14:21:33 <jethr0_> from wikipedia: "In mathematics, a partial function is a relation that associates each element of a set, sometimes called its domain (but see discussion below), with at most one element of another (possibly the same) set, called the codomain."
14:21:50 <vincenz> notice the word "partial"
14:21:57 <jethr0_> notice the word "function"
14:22:04 <vincenz> -partial function-
14:22:06 <vincenz> trust me on this
14:22:09 <vincenz> function implies totality
14:22:10 <jethr0_> -total function-
14:22:13 <vincenz> nope
14:22:17 <vincenz> it's function and partial function
14:22:28 <ihope_> Um...
14:22:30 <jethr0_> k
14:22:43 <ihope_> Does "value" imply that as well?
14:22:45 <ihope_> x = x
14:22:51 <ihope_> Is x a value?
14:23:05 <vincenz> fromk wikipedia: n mathematics and most scientific and technical fields, an abstract entity that associates every element (input, argument) of a certain set of numbers or other objects to a corresponding element (output, result) in some other set: see function (mathematics).
14:23:32 <goltrpoat> semantics, but vincenz is right.  a function takes values in its domain to its range.  a total function assigns something in the range to each element of the domain.  if an element in the domain doesn't have an image, then it's not a total function, but each element in the domain has an image from definition of domain
14:23:38 <jethr0_> "If a partial function f:XY associates, to every element in X, an element of Y, then f is termed a total function, or simply a "function" as traditionally understood in mathematics."
14:23:58 <jethr0_> ok, but it's a thin line, IMO. but i have no problem with being wrong :)
14:24:07 <vincenz> :)
14:24:20 <twobitsprite> does the factorial "10000!" really have a bunch of zeros at then end, or am I seeing a limitation of GHCi?
14:24:28 <vincenz> jethr0_: I'm like you, I'll argue until someone proves me wrong and then accept it (arguiing in thehope of someone proving me wrong to learn something new)
14:24:57 <ihope_> twobitsprite: it really does have a bunch of zeros at the end.
14:25:03 <ndm> twobitsprite: it does
14:25:12 <vincenz> twobitsprite: doesn't that seem logical?
14:25:12 <ndm> consider, 10 * 100 * 1000
14:25:17 <ihope_> It's multiplying 10, 20, 30, 40, 50, etc. as well as many other things.
14:25:20 <vincenz> twobitsprite: you have a few numbers in ther ethat have 0's
14:25:25 <twobitsprite> ahhh
14:25:30 <twobitsprite> your right, thanks :)
14:25:31 <jethr0_> an 5*2s
14:25:33 * twobitsprite wasn't thinking
14:25:37 <vincenz> and 4*25s
14:25:53 <ihope_> 4*25 = 5*2*5*2
14:26:10 <jethr0_> hehe, let's play the illuminati game
14:26:11 <vincenz> yeah but I was talking about the numbers that are passed over, not their prime factors
14:26:25 <vincenz> jethr0_: what's illuminati game? sounds intriguing by the name alone
14:26:33 <ihope_> Card game?
14:26:43 <ihope_> @google illuminati
14:26:45 <lambdabot> http://www.conspiracyarchive.com/
14:26:51 <vincenz> @google illuminati game
14:26:53 <lambdabot> http://www.sjgames.com/illuminati/
14:27:07 <goltrpoat> so anyway.. that factorial example, the function is not even invertible.  from what little i read, the backtracking capability is used fairly extensively, and judging by the number of prolog compilers out there, it can't be that difficult.
14:27:09 <jethr0_> 23, cross sum 5. 23 - 5 = 18; cross sum 9; 5+9 = 14; 23 - 14 = 11; they are all _magic_ numbers ^_^
14:27:28 <vincenz> huh?
14:27:32 <jethr0_> =9
14:27:38 * vincenz doesn't get it
14:27:44 <twobitsprite> why can't one do peice-wise function definition in ghci?
14:27:50 <jethr0_> vincenz: you'd have to read the book to understand it
14:28:12 <jethr0_> it's all about conspiracy theories and "magic" numbers. like assasinations happening on the 23rd of a month
14:28:47 <jethr0_> or 5 people doing sth on the 2.3. of a year, and so forth
14:28:54 <vincenz> why are they magic numbers?
14:29:11 <jethr0_> 23 just is. and anything derivable from 23 is too :)
14:29:18 <vincenz> derivable in what sense
14:29:20 <mwc> dcoutts, did my patch get sent correctly or did I muck it up?
14:29:22 <jethr0_> in any sense
14:29:28 <vincenz> jethr0_: then all of N is a magic number
14:29:31 <goltrpoat> i remember a character in foucault's pendulum tying the circumference of a hot dog stand outside to the knights templar (at least i think it was hot dogs and templars, been a while).
14:29:35 <twobitsprite> 2 + 3 = 5 and 2 / 3 = .666 :P
14:29:36 <vincenz> and even Q
14:29:48 <ihope_> What does the prime factorization of x have to do with that of (x+1)?
14:30:11 <goltrpoat> ihope:  the latter has none of the primes in the former?
14:30:21 <vincenz> ihope_: nada
14:30:34 <jethr0_> vincenz: it's like 42, only more paranoid
14:30:37 <vincenz> goltrpoat: are you sure?
14:30:45 <vincenz> jethr0_: any number in N can be derived from 23
14:30:45 <goltrpoat> no, thinking
14:30:58 <ihope_> vincenz: well, if one contains a 2, the other doesn't, and if one doesn't contain a 2, the other does
14:31:01 <vincenz> 3-2 = 1 ... 1 + 2 = 3 ... 1+3 = 4...
14:31:33 <goltrpoat> ok yes, i'm sure.
14:31:42 <jethr0_> vincenz: that's what makes it so paranoid
14:31:45 <vincenz> goltrpoat: prove it?
14:31:49 <goltrpoat> say x = a_1 a_2 .. a_n.  x+1 = a_1 a_2 .. a_n + 1.  this is obviously not divisible by any of the a_k.
14:31:57 <vincenz> goltrpoat: how do you know?
14:32:14 <vincenz> simple case
14:32:19 <jethr0_> it's not. at least not if a_k are primes
14:32:20 <vincenz> x = a1*a2....
14:32:30 <jethr0_> that's the proof for there being infinitely many primes
14:32:51 <vincenz> ah yes
14:32:53 <ihope_> Hmm...
14:32:56 <vincenz> anyways
14:32:57 <vincenz> I'm off
14:32:59 <goltrpoat> hehe
14:33:00 <vincenz> tatah
14:33:01 <jethr0_> by
14:33:02 <goltrpoat> later
14:33:09 <vincenz> jethr0_: go to sleep
14:33:09 <ihope_> @index factor
14:33:09 <lambdabot> bzzt
14:33:12 <ihope_> Meh.
14:33:16 <jethr0_> i will
14:33:27 <vincenz> I mean within a maximally bound timeframe
14:33:33 <jethr0_> goltrpoat: it's not true for a_k non-prime though
14:33:43 <goltrpoat> uh.. we were talking about prime factors
14:33:47 <jethr0_> k
14:33:48 <goltrpoat> a_k are the prime factors
14:34:10 <jethr0_> yes, then it's one of my favorite (because easy) proofs :)
14:38:14 * ihope_ factors a prime
14:38:19 <ihope_> s/prime/number.
14:38:32 <ihope_> Prime numbers are easy to factorize ;-)
14:38:52 <jethr0_> and fast if you know beforehand that they are prime :)
14:39:13 <goltrpoat> this might be an urband legend, but bill gates is often quoted as saying that the next major advance in technology is going to be the ability to factor large primes.
14:39:27 <ihope_> I think it will be.
14:39:30 <goltrpoat> haha
14:39:32 <ihope_> Shor's algorithm, aye?
14:39:42 <jethr0_> define "next", "large", "advance", "technology" :)
14:39:45 <ihope_> Oh, wait...
14:39:47 <goltrpoat> i think he meant large semiprimes :)
14:39:51 <ihope_> :-)
14:40:04 <jethr0_> sry, *major
14:40:28 <ihope_> I'm factoring 12907543875.
14:40:34 <ihope_> First, we factor 12907543874 and 12907543876...
14:40:35 <jethr0_> i don't think it's gonna be the "next" one. but when/if it happens at least cryptography will be dealt quite a blow
14:40:38 <ihope_> ;-)
14:41:21 <astrolabe> Does anyone else find GHCi is unstable?
14:41:28 <jethr0_> and the N/=NP question might be settled once and for all, making CS more mathlike :)
14:41:34 <mwc> goltrpoat, quantum computers let you factor numbers of size n in O[(log n)^3] time
14:41:41 <ihope_> astrolabe: are you using unsafeCoerce? ;-)
14:41:50 <mwc> that must be what he's talking about
14:41:53 <astrolabe> ihope_: I don't think so.
14:41:58 <tic> jethr0_, when where what?
14:42:15 <mwc> it's already been done; I believe IBM has a 7 qubit computer that they used to factor 15 sucessfully
14:42:18 <goltrpoat> mwc:  yah, i know about shor's.
14:42:19 <ihope_> Anything using unsafeCoerce "should" be called unsafeSomething.
14:42:23 <jethr0_> mwc: yes, but it's not clear yet, whether quantum computers will scale. whether there'll ever be a 64bit quantum computer
14:42:29 <ihope_> Heh.
14:42:36 <ihope_> > 2^64
14:42:37 <lambdabot> 18446744073709551616
14:42:54 <ihope_> Yeah. Pretend that 64-bit computer has 18446744073709551616 of something.
14:42:54 <goltrpoat> mwc:  problem is, for all we know, quantum computers will never scale to more than a few qubits
14:42:59 <mwc> Well, I am a theoretical physicist (major) and I can say that there are some very interesting things coming up in quantum computer tech
14:43:02 <jethr0_> i was just picking a large number, really. but afaik they've come to 7 or so, right?
14:43:15 <tic> mwc, like?
14:43:21 <jethr0_> and there might be strict physical limits to how many qubits you can have "in phase"
14:43:28 <mwc> tic, nanotech stuff like quantum dots
14:43:34 <mwc> jethr0_, the problem is thermalization
14:43:58 <jethr0_> i thought there were space problems too. that the "link" would break down at a certain distance
14:44:01 <mwc> quantum computers are never gonna be on the desktop; they'll be in abandonned nickel mines 1000m underground cooled by liquid helium
14:44:22 <ihope_> mwc: did they ever say that for classical computers?
14:44:22 <jethr0_> mwc: what's the max. number of qubits they've gotten to? 7?
14:44:29 <tic> mwc, like the 4 computers to rule the world as envisioned by the IBM in the 30s? :)
14:44:31 <Beelsebob> ndm: why does yhc complain about unknown preprocessor declarations at every single preprocessor command?
14:44:42 <SimonRC> tic: no, it was 6
14:44:45 <wchogg> mwc-Do you actually work on quantum computing?
14:44:46 <mwc> jethr0_, afaik, 7, but I haven't read literature in that area in a while
14:44:53 <tic> SimonRC, okay. Still. :)
14:44:56 <ndm> Beelsebob: because it isn't valid haskell
14:44:59 <ndm> try -cpp
14:45:02 <Beelsebob> ah, okay
14:45:03 <Beelsebob> cool
14:45:25 <ihope_> Attach 9 7-qubit quantum computers to each other. Bam: 64 qubits, for low values of 64.
14:45:43 <mwc> tick, ihope_, the problem with quantum computers is that they're VERY sensitive to radiation and stray thermal noise. You'll need a massive cooling plant, the kind of stuff they had for MRI machines in the 80s, and you'll need it buried under a pile of rock or metal to stop cosmic radiation
14:45:44 <ndm> Beelsebob, what are you working on Yhc with
14:45:56 <jethr0_> mwc: in one of my lectures we did how to do fourier transformation on a quantum computer, and since then i've been amazed and perplexed by the possibilities of superimposition (or whatever the term is).
14:46:06 <Beelsebob> ndm: I'm trying to give it a CPUTime, Random and Test.QuickCheck module
14:46:10 <jethr0_> the only problem is getting out all the answers without disturbing them ^_^
14:46:15 <Beelsebob> with -cpp I get the same error
14:46:20 <ndm> Beelsebob, neat :)
14:46:28 <ndm> with a brand new darcs tree?
14:46:32 <ihope_> mwc: "the kind of stuff they had for MRI machines in the 00's...
14:46:33 <Beelsebob> yes
14:46:34 <ihope_> Erm.
14:46:36 <Beelsebob> pulled today
14:46:44 <ihope_> "the kind of stuff they had for quantum computers in the 00's..."
14:46:46 <ndm> with -cpp, that should happen
14:46:53 <ndm> * shouldn't
14:47:01 <mwc> ihope_, I meant 80s. Big massive plants for superconductor cooling
14:47:09 <wchogg> Where I work, it seems like half the department is involved in quantum computers right now.  It's a really hot topic.
14:47:16 <ndm> Beelsebob, please post one of the errors, the line and the message
14:47:29 <jethr0_> it's been a hot topic for a few years now.
14:47:43 <Beelsebob> command was ../../../inst/bin/yhc -d ../../../inst/lib/yhc/packages/yhc-base/1.0/ -i ../../../inst/lib/yhc/packages/yhc/base/1.0/ -c -cpp System/CPUTime.hs
14:47:44 <wchogg> Mostly since the late 90's I thought.
14:48:00 <jethr0_> but as i see it the main thrusts will come from phsics actually building the computers. although complex algorithms would also be nice (even if never applicable)
14:48:03 <Beelsebob> error was yhc: Unknown preprocessor directive at line 33 in file ...
14:48:12 <ndm> can i see line 33 ?
14:48:40 <Beelsebob> line 33 is: #if !defined(mingw32_HOST_OS) && !defined(cygwin32_HOST_OS)
14:48:54 <mwc> What I think is an interesting area is the NMR computers. You take a complex organic like adenine, and you can use different frequencies of radiowaves to address individual carbon atoms. THe advantage is you can have a trillion computers running in parallel in a beaker
14:48:57 <ndm> hmm, puzzling
14:48:59 <Beelsebob> same error if I use #ifndef
14:49:09 <ndm> can you try a simple example of a preprocessor
14:49:18 <Beelsebob> yeh... give me a min
14:50:08 <ndm> i have never tried -cpp with -c, they might conflict
14:50:38 <Beelsebob> simple example works fine
14:50:50 <Beelsebob> win -c on as well
14:50:55 <Beelsebob> with*
14:52:11 <ndm> yep, for me too
14:52:25 <Beelsebob> @where paste
14:52:25 <lambdabot> http://paste.lisp.org/new/haskell
14:52:27 <ndm> is line 33 the first cpp directive?
14:52:35 <jethr0_> k, good night #haskell
14:52:42 <Beelsebob> ndm: yes
14:52:52 <ndm> hmmmmm
14:53:16 <ndm> Beelsebob, does running cpphs over it work?
14:53:27 <ndm> i.e. stand alone cpphs
14:53:56 <Beelsebob> interesting - it does
14:54:01 <Beelsebob> but it produces corrupt output
14:54:40 <Beelsebob> line 33 ends up being: #endiffxception Nothing)et CPU time"peration lockks) * 1000000000)
14:54:47 <Beelsebob> ... which you can see why it's complaining about
14:55:02 <Beelsebob> does cpphs dislike nested #ifs?
14:58:15 <ndm> Beelsebob, fire off a bug report to malcolm :)
14:58:22 <Beelsebob> anyway, I should go see Lex, I'll see you later, and see if we can unjibble this
14:58:22 <ndm> what are the line endings in the file you are processing?
14:58:36 <Beelsebob> okay - to malcolm himself or is there an appropriate adress to send to?
14:58:38 <Beelsebob> ndm: UNIX
14:58:45 <ndm> straight to malcolm
15:02:52 <Beelsebob> right - I should go see Lex, I'll speak to you about random yhc jibbling tomorrow
15:05:56 <Blicero_> is there a way to serialize and deserialize dyngraphs to and from disk
15:12:03 <itsmike> must go now 1 laptop 500$ 1 desktop 500$  message me if interested on msn at mcsltd2@hotmail.com, aim at ogd443 or yahoo at thishastogotoday
15:21:23 <ihope_> > length 
15:21:24 <lambdabot>  add an instance declaration for (Show ([a] -> Int))
15:21:27 <ihope_> > length "must go now 1 laptop 500$ 1 desktop 500$ message me if interested on msn at mcsltd2@hotmail.com, aim at ogd443 or yahoo at thishastogotoday"
15:21:27 <lambdabot> 139
15:24:37 <mathrick> > length "lilo is an idiot and should be kept away from computers, and especially computers that happen to run big IRC networks"
15:24:38 <lambdabot> 117
15:32:04 <ihope_> @spam
15:32:04 <lambdabot> lShell module failed: Prelude.init: empty list
15:32:11 <ihope_> @lShell
15:32:11 <lambdabot> Unknown command, try @listcommands.
15:32:18 <ihope_> What's @spam?
15:32:30 <ihope_> @samp
15:32:30 <lambdabot> Maybe you meant: lam map
15:32:35 <ihope_> @spem
15:32:35 <lambdabot> Maybe you meant: seen spell
15:32:40 <ihope_> @spell
15:32:41 <lambdabot> No word to spell.
15:32:48 <ihope_> @sam
15:32:48 <lambdabot> lShell module failed: Prelude.init: empty list
15:32:51 <Cale> @spell spel
15:32:52 <lambdabot> spell spiel spelt spew Opel
15:32:57 <ihope_> @spell sam
15:32:58 <lambdabot> SAM Sam same seam Sm
15:33:02 <ihope_> @same
15:33:02 <lambdabot> Maybe you meant: lam state time
15:33:08 <ihope_> @seam
15:33:09 <lambdabot> Maybe you meant: keal lam seen
15:33:13 <Cale> @keal
15:33:13 <ihope_> @lam
15:33:13 <lambdabot> quote module failed: getRandItem: empty list
15:33:13 <lambdabot> lShell module failed: Prelude.init: empty list
15:33:18 <ihope_> Aha.
15:33:20 <ihope_> @help lam
15:33:21 <lambdabot> Evaluate terms of the pure, untyped lambda calculus
15:33:21 <lambdabot> darcs get http://www.eecs.tufts.edu/~rdocki01/lambda
15:33:25 <Cale> oop, quote module failed again
15:33:30 <ihope_> @lam \x.x
15:33:30 <lambdabot> lShell module failed: Prelude.init: empty list
15:33:35 <ihope_> @lam \x -> x
15:33:35 <lambdabot> lShell module failed: Prelude.init: empty list
15:33:49 <Cale> okay, something is broken :)
15:34:28 <bolrod> @spell ohkay
15:34:29 <lambdabot> okay oak okays OK Ajay
15:34:56 <ihope_> @spemm spemm
15:34:56 <lambdabot> sperm Spam spam spume spumy
15:35:04 <ihope_> @spell spleel
15:35:04 <lambdabot> spleen spell Spiegel spiel supplely
15:35:09 <ihope_> @spell ohnoes
15:35:09 <lambdabot> oh noes oh-noes ones Ono's honors
15:35:25 <ihope_> @spell machairodontician
15:36:00 <bolrod> @spell Hippopotomonstrosesquippedaliophobia
15:36:10 <bolrod> >:/
15:36:25 <bolrod> how the hell do you pronounce that anyway
15:37:02 <ihope_> What is hippopotomonstrosesquippedaliophobia?
15:37:10 <bolrod> fear of long words
15:37:11 <bolrod> 8)
15:37:37 <bolrod> Sesquipedalophobia  also
15:37:44 <ihope_> > length "Hippopotomonstrosesquipedalian"
15:37:45 <lambdabot> 30
15:37:55 <bolrod> hippopotomonstro  is probably.. fear of very huge words?
15:38:00 <bolrod> (with the other part)
15:40:24 <bolrod> Allodoxaphobia- Fear of opinions.
15:40:31 <bolrod> hmm
15:40:36 * ihope_ thinks
15:40:42 <ihope_> > 2**.5
15:40:42 <lambdabot>  Not in scope: `**.'
15:40:46 <ihope_> > 2** .5
15:40:47 <lambdabot>  parse error on input `.'
15:40:50 <ihope_> > 2**0.5
15:40:51 <lambdabot> 1.4142135623730951
15:40:55 <ihope_> Aha.
15:41:14 <ihope_> > log 0.4142135623730951 / log 2
15:41:15 <lambdabot> -1.271553303163612
15:41:17 <bolrod> ?
15:41:31 <ihope_> I'm trying to figure out what contains half a bit of information.
15:41:56 <bolrod> urh
15:42:08 <bolrod> nothing?
15:42:12 <ihope_> Well...
15:42:23 <Philippa_> you left something out
15:42:25 <ihope_> Suppose I tell you that everybody in the world did not win the lottery.
15:42:25 <bolrod> unary ?
15:42:33 <Philippa_> > log (2**0.5) / log 2
15:42:33 <ihope_> How much information is in that event?
15:42:34 <lambdabot> 0.5000000000000001
15:42:43 <Philippa_> oh look, I could've calculated that from the log rules ;-)
15:42:58 <bolrod> :)
15:43:18 <bolrod> just read something funny today.. 
15:43:22 <ihope_> > 1000000000000 + 1 - 1000000000000
15:43:23 <lambdabot> 1
15:43:25 <ihope_> !
15:43:28 <bolrod> how much is 0.33333333333... etc    times 3 ?
15:43:37 <ihope_> 0.99999999999999999999999999999999999999999999999999999999...
15:43:38 <TuringTest> 1
15:43:41 <bolrod> yes..
15:43:43 <bolrod> both :)
15:43:52 <bolrod> since 1/3 * 3 = 1
15:43:58 <bolrod> and 1/3 = 0.3333.... etc
15:44:31 <ihope_> > 1000000000000000000000000 + 1 - 1000000000000000000000000
15:44:32 <lambdabot> 1
15:44:35 <TuringTest> Q:How many mathematicians does it take to screw in a lightbulb? 
15:44:35 <TuringTest> A: 0.999999.... 
15:44:42 <palomer> ho ho ho
15:44:43 <ihope_> :-)
15:44:45 <ihope_> > 1000000000000000000000000000000000000 + 1 - 1000000000000000000000000000000000000
15:44:45 <bolrod> :)
15:44:45 <lambdabot> 1
15:44:48 <palomer> 0.999999.. = 1
15:44:50 <ihope_> Oh, right right right.
15:44:51 <palomer> fascinating fact
15:44:55 <bolrod> > 10000000000000000000 /2
15:44:56 <lambdabot> 5.0e18
15:45:01 <bolrod> > 1000000000000000000000000000000000000 /2
15:45:02 <lambdabot> 5.0e35
15:45:05 <bolrod> > 10000000000000000000000000000000000000 /2
15:45:06 <lambdabot> 5.0e36
15:45:08 <bolrod> > 100000000000000000000000000000000000000000 /2
15:45:09 <lambdabot> 5.0e40
15:45:11 <palomer> well, unless you're working in the hyperreals
15:45:11 * resiak looks at bolrod 
15:45:12 <ihope_> > 1000000000000.0 + 1.0 - 1000000000000.0
15:45:13 <lambdabot> 1.0
15:45:21 <bolrod> hmm
15:45:23 <ihope_> > 1000000000000000000000000.0 + 1.0 - 1000000000000000000000000.0
15:45:24 <bolrod> > 100000000000000000000000000000000000000000000000 /2
15:45:25 <lambdabot> 0.0
15:45:25 <lambdabot> 5.0e46
15:45:27 <TuringTest> palomer: No...I think it is still 0.999... == 1 in the hyperreals
15:45:30 <ihope_> Ere we go.
15:45:32 <bolrod> is it fixed?
15:45:35 <bolrod> > 100000000000000000000000000000000000000000000000000000000000000000 /2
15:45:36 <lambdabot> 5.0e64
15:45:38 <bolrod> damn
15:45:43 <TuringTest> palomer: But it may depends on your mapping.
15:45:46 <bolrod> at some point it went wrong..
15:45:49 <ihope_> > 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 `div` 2
15:45:50 <lambdabot> 500000000000000000000000000000000000000000000000000000000000000000000000000
15:45:50 <lambdabot> 0000000000000000000000000000000000000000000000000000000000
15:45:56 <bolrod> weird
15:45:59 <palomer> TuringTest: I'm pretty sure it's not
15:46:10 <bolrod> last time I got 4.98 e something
15:46:12 <bolrod> :)
15:46:29 <TuringTest> palomer:  If you read 0.999.. as the sequence 0.9 0.99 0.999 0.9999 0.9999 etc then you are right
15:46:49 <palomer> 0.9999.. = sum(i=1,oo) {9*10^(-i)}
15:46:53 <TuringTest> Since that sequence, as a hyper-real, is less than one
15:47:03 <palomer> but that's what it is!
15:47:17 <bolrod> its pretty simple
15:47:19 <TuringTest> Well 7 as a hyperreal is still 7
15:47:23 <bolrod> x = 0.999999......
15:47:31 <TuringTest> So if I interpret 0.999... as a real then map to hypereal it is 1.0
15:47:31 <bolrod> 10x= 9.99999.........
15:47:36 <bolrod> 9x = 9
15:47:38 <bolrod> x=1
15:47:40 <bolrod> :)
15:47:50 <TuringTest> You have to specify the sequence to embed it the way you want to.
15:48:15 <palomer> I've always interpreted 0.999.. as an infinite sum
15:48:51 <ihope_> > 0.99999999999999999999999999999999999999999999 == 1/0
15:48:52 <lambdabot> False
15:48:53 <ihope_> > 0.99999999999999999999999999999999999999999999 == 1.0
15:48:54 <lambdabot> True
15:49:04 <ihope_> > 3/3 == 1
15:49:05 <lambdabot> True
15:49:12 <ihope_> > 10000/100/100 == 1
15:49:13 <lambdabot> True
15:49:16 <bolrod> http://en.wikipedia.org/wiki/Proof_that_0.999..._equals_1
15:49:28 <TuringTest> palomer: The usual thing to do with the hypereals is to construct them from a sequence of real numbers.  So if your partial sums are the sequence you get what you wanted.
15:49:46 <palomer> here's another proof that 0.99.. = 1 . assume it isn't, then there must be a real between the 2. now prove that real is 0
15:50:48 <Blicero_> is there no convenient way to serialize and deserialize graphs for storage on disk?
15:51:33 <palomer> in fact, there must be a rational between the 2
15:51:59 <palomer> call this rational q
15:52:09 <bolrod> you sure?...
15:52:12 <palomer> q < 10^(-i) for some i in N
15:52:17 <goltrpoat> is it too late to point out that hyperreals are a term from non-standard analysis?
15:52:27 <palomer> goltrpoat: yes.
15:52:43 <goltrpoat> foiled again.
15:53:11 <palomer> now 0.99999.. + 10^(-i) is always greater than 1, contradiction
15:53:42 <bolrod> real numbers are weird
15:53:45 <bolrod> :)
15:53:52 <palomer> just use the countable model of the reals
15:54:08 <palomer> they become less weird
15:54:11 <bolrod> whats that set again...  Q?
15:54:20 <palomer> nope
15:55:02 <TuringTest> palomer: Do you a concrete countable model of the reals in your pocket?
15:55:14 <goltrpoat> is that the lowenheim skolem stuff
15:55:19 * TuringTest nods
15:55:22 <bolrod> rational numbers are denumerable  right?
15:55:29 * TuringTest nods
15:55:41 <bolrod> Reals are not..
15:55:57 <TuringTest> bolrod: for the usual model, yes.
15:57:00 <TuringTest> Q: Whats big, grey, and proves the uncountability of the reals? 
15:57:13 <bolrod> ?
15:57:29 <TuringTest> bolrod: It is a joke.  It is funny
15:57:36 <bolrod> Ic
15:58:02 <bolrod> is there an answer to this joke?
15:58:04 <bolrod> :)
15:58:58 * TuringTest looks at joke, looks at answer on same line, looks at bolrod
15:59:16 <TuringTest> Don't make me paste more jokes.
15:59:26 <bolrod> ...
15:59:27 <Cale> Cantor's Diagonal Elephant
15:59:37 <bolrod> I only see Q:...
15:59:56 <Cale> TuringTest: only the question got pasted
15:59:59 <TuringTest> ah
16:00:03 <astrolabe> What does 'for the usual model' mean here?
16:00:07 <TuringTest> My bad...I see it in my client.
16:00:37 * TuringTest worries Cale can somehow see TuringTest's screen
16:00:50 <Cale> nope, I've heard that one before
16:01:08 <TuringTest> astrolabe: http://mathworld.wolfram.com/Loewenheim-SkolemTheorem.html
16:01:28 <TuringTest> I like the classics.
16:02:57 <bolrod> I like sleep
16:03:06 <bolrod> it is boring to go to sleep though
16:04:47 <Cale> you don't normally use a countable model of the reals though
16:05:14 <Cale> since it tends not to satisfy any of the same second-order statements
16:05:33 <astrolabe> So, where does the diagonal argument break?
16:06:03 <palomer> it breaks?
16:06:14 <palomer> uncountability is not statable in first order logic
16:06:32 <palomer> TuringTest: well, erm, the construction is pretty straightforward
16:06:36 <palomer> there should be computational model theory
16:06:54 <palomer> denumerable=countable?
16:06:59 <Cale> yeah, it breaks because you can't state the theorem
16:07:31 <astrolabe> Ah, so 'for the usual model' means 'for the usual first-order logic model'?
16:07:33 <Cale> countable means that there is an injection from the set into the set of naturals.
16:07:43 <palomer> model == first order model
16:07:55 <Cale> The usual model of the real numbers isn't the countable one for me.
16:08:09 <Cale> I'd pick Dedekind cuts or Cauchy sequences.
16:08:25 <palomer> those are some pretty restricted models
16:08:33 <palomer> you can't state much in those models
16:08:43 <astrolabe> Cauchy sequences definitely :)
16:09:08 <Cale> Actually probably Dedekind cuts, for me, just because I'm more familiar with that way to build the reals.
16:09:30 <astrolabe> Most mathematicians are not predominently interested in first-order models.
16:09:59 <astrolabe> But dedekind cuts are less gereneralisable I think.
16:10:13 <Cale> probably
16:10:27 <palomer> someone write a one line injective function of type (Int,Int) -> Int
16:10:28 <palomer> go!
16:10:35 <astrolabe> My spelling is even worse than usual.
16:11:15 <liyang> palomer: f (a,b) = 2^a + 3^b
16:11:49 <Cale> +?
16:12:04 <astrolabe> Clever, but what if a = -1?
16:12:05 <palomer> well, that proves that the rationals are countable
16:12:31 <Cale> f(a,b) = 2^(1+sgn(a)) 3^(1+sgn(b)) 5^|a| 7^|b|
16:12:51 <Cale> you can break things up and encode as much as you like :)
16:13:22 <liyang> Cale: oh, I see. Oops.
16:13:36 <Cale> he said Int, which makes it more annoying
16:13:45 <liyang> I just assumed Nat.
16:14:24 <Cale> heh, and if it's Haskell's Int, an injection is impossible
16:15:52 <palomer> why?
16:15:58 <palomer> oh, that's right
16:16:42 <Cale> It's Integer that's unbounded
16:34:08 <dons> moin
16:38:47 <musasabi> evening
16:39:01 <TuringTest> hi dons
16:39:50 <TuringTest> dons: I have picked the name Text.Regex.Laxy to be the root of my module.
16:40:51 <TuringTest> dons: You had said something about "This week I was working on a set of regex combinators".  Is this based on the CTK combinators?
16:40:57 <dons> Laxy eh?
16:41:05 <dons> yeah, I was thinking about that
16:41:05 <TuringTest> Lazy
16:41:59 <TuringTest> I am thinking the CTK makes a good DFA engine for simple purposes, so I am poking at it and may include it under the hood.
16:43:01 <dons> cool. 
16:44:33 <TuringTest> dons: I just e-mail'd you my current modifications to the CTK core.
16:45:03 <TuringTest> It is supposed to allow things like "[^abc]" to be encoded efficiently, but I have not tested it.
16:45:29 <TuringTest> (With unicode, making an array of maxBound::Char would be a poor idea)
16:45:39 <dons> hmm very nice. I was thinking of starting with your improved stuff.
16:45:42 <dons> yes :}
16:46:20 <dons> ah, very good. 
16:48:44 <TuringTest> Since you asked -- I just email'd the whole ball of wax
16:49:07 <dons> yep. reading it.
16:50:23 <TuringTest> The main change is Cont / Dense and Sparse.  They got a 3rd field which is the "otherwise" Lexer
16:50:33 <TuringTest> Instead of defaulting to "I am done"
16:50:58 <TuringTest> I had to rework the joinCont a bit to handle this, but it was straightforward
16:51:04 <TuringTest> I hope it works
16:51:18 <dons> sounds like a reasonable idea to try
16:51:31 <araujo> Hello!
16:52:24 <dons> g'day araujo
16:52:32 <TuringTest> dons: I still need to make a function to transform Text.Regex.Lazy.Pattern.Pattern into the CTK combinators.
16:52:42 <TuringTest> once I do that I can run the tests
16:55:27 <araujo> g'day dons , how hacking goes? :-)
16:58:24 <dons> yep, ok. did a bit of lambdabot this week
16:58:27 <dons> ?bot
16:58:28 <lambdabot> :)
16:58:35 <dons> &bot
16:58:35 <lambdabot> :)
16:58:38 <dons> \bot
16:58:38 <lambdabot> :)
16:58:40 <araujo> :-)
16:58:45 <dons> # 1+2
16:58:46 <lambdabot> 3
17:02:26 <palomer> what's # ?
17:04:50 <dons> a synonym for @eval, as is '>'
17:05:12 <dons>  ?&\# and some others are synonyms for @
17:07:45 <palomer> why have synonyms?
17:13:06 <jimapple> Has everyone seen http://www.oreillynet.com/mac/blog/2006/03/haskell_vs_ocamlwhich_do_you_p.html ?
17:14:32 <dons> palomer, I think that \foo is nicer than @foo. but we've never explored it. so i implemnented this to see what looks nicer, and what people like
17:15:45 <dons> 'a language that lets me use recursion significantly in my code with almost no performance hits' hhehe
17:15:53 <dons> it's not tail calls that are going to be a problem..
17:16:42 <jimapple> What is it going to be?
17:17:04 <palomer> dons: gotcha
17:17:05 <dons> jimapple, not sure if he understand the expressiveness of haskell -- no mention of IO for example, and seems obsessed with recursion being a performance problem-- which is weird
17:17:30 <dons> more likely he coded in a space leak perhaps? or is using hugs or something.
17:18:16 <palomer> I agree with the article, mostly
17:18:30 <TuringTest> jmichaelson: the author of that article wrote "(e.g., quite a few of the algorithms in my Bioinformatics class use Dynamic Programming. I have no idea how this would be done in Haskell and I've tried the recursive way of doing things and it is just way too slow)"
17:19:19 <TuringTest> Someone might point him at LogicT or something.  I would have though dynamic programming in Haskell would work well...
17:19:35 <dons> neith of which make much sense.. dynamic programming is one of the easier things in haskell -- it's in Thompson
17:20:12 <palomer> thompson?
17:20:22 <dons> standard haskell textbook
17:20:25 <TuringTest> "but I would recommend checking out #haskell on irc.freenode.net for further questions. It's an extremely helpful channel and they would certainly help to put you on the right track as far as your performance issues go and your confusion about how to do dynamic programming (dynamic programming algorithms should be very natural to write in a functional style in Haskell)."
17:20:30 <TuringTest> from a comment to the article
17:20:48 <dons> yeah, the comment made clear the things the author got wrong, I thought
17:20:48 <palomer> I don't see how dynamic programming in haskell is any different from any other language
17:20:57 <dons> lazyness makes it particularly easy, iirc
17:21:16 <dons> so easy it can be done in an intro-to-haskell textbook
17:21:28 <Philippa_> palomer: you're used to haskell enough to not burn yourself on "lack" of side-effects
17:21:55 <Philippa_> yeah, but you could provide Deep Thought's programming in an intro-to-haskell textbook
17:23:03 <jimapple> Metaphysics the Haskell Way
17:23:24 <dons> nice to see anyway that the commens are mostly pro-haskell, and not too many perforamnce whinges
17:23:35 <dons> maybe we're getting a bit of perforamance mind-share now
17:23:41 <TuringTest> dons: There is an early prototype of a token-counter for the shootout being discussed at http://alioth.debian.org/forum/forum.php?thread_id=2096&forum_id=999
17:23:58 <dons> yeah, saw one based on a java lexer?
17:24:14 <dons> we should still fair very well, I suspect
17:24:23 <dons> (just lacking parens is going to be a win ;)
17:24:24 <TuringTest> dons: Only ruby does better
17:24:35 <TuringTest> According to the lexer they use
17:25:10 <dons> ah, it really punishes mlton
17:25:15 * TuringTest nods
17:25:19 <dons> i knew they were intentionally packing their lines
17:25:27 <dons> whereas our rank is basically unchanged
17:25:32 * dons feels vindicated
17:25:39 <Philippa_> dons: can GHC's inliner be trusted to do a good job if you build a "make my life sane" IO wrapper for whatever piece of optimisation insanity you need to indulge in?
17:25:50 <Philippa_> (that is, if you build a whole new monad)
17:26:05 <dons> if you stick INLINE pragmas on key thingies
17:26:42 <TuringTest> {-# INLINE keyThingie1 #-}
17:26:43 <Philippa_> cool
17:27:22 <Philippa_> (and... duh)
17:28:01 <TuringTest> Yes...that's me...stating the obvious for the 21st century
17:28:12 <Philippa_> actually the duh was aimed at myself
17:28:19 <Philippa_> I know the pragmas exist
17:28:46 <Philippa_> (and as a further note to myself: inlining is one thing, but don't write the monad in 'here's an interpreter' style 'cos partial evaluation's another)
17:28:50 <TuringTest> I just liked "keyThingie1" once it thought it.
17:31:59 <goltrpoat> hey philippa
17:32:06 <goltrpoat> ltns
17:33:50 <TuringTest> 'night all
17:39:14 <Philippa_> 'lo goltrpoat
17:39:30 <Philippa_> it has been - they missing me in #flipcode at all?
17:40:34 <goltrpoat> not sure, i haven't really been hanging out there a whole lot
17:41:32 <goltrpoat> philippa:  can you see my messages?  im getting crap from the server saying private messages from unregistered users are blocked
17:42:13 <Philippa_> I can't
17:42:21 <Philippa_> you'll need to register and identify to the nickserv
17:42:33 <goltrpoat> wow.. goddamn that's retarded.
17:42:35 <goltrpoat> k, sec
18:08:51 <lispy> goltrpoat: yeah, we
18:09:04 <lispy> goltrpoat: yeah, welcome to freenode idosynchracies
18:11:57 <dons> spammers seems to have dried up since registration was brought in though
18:12:09 <dons> and even lambdabot knows how to self-identify, so it can't be too hard ;)
18:12:50 <dons> anything that keeps the signal to noise ratio up is good, imo.
18:15:35 <musasabi> and one can turn the feature off if wanted
18:18:20 <lispy> dons: i guess i don't hangout in spammy channels.  I used freenode for over a year before the change and the only spam i receive i still get from lilo
18:18:37 <dons> heya musasabi. long time, no code :)
18:18:50 <dons> lispy, yeah, we've only been spammed here 2 or 3 times in the last year, but it is annoying  :)
18:20:12 <musasabi> dons: pesky things like real life have been keeping me quite busy.
18:20:20 <dons> bah, real life boo boo
18:20:38 <araujo> realife--
18:21:04 <musasabi> hopefully I will get more time to code this week
18:22:16 * araujo bit bored
18:22:41 <dons> araujo, write a cool lambdabot plugin!
18:22:58 <dons> hmm, question, lambdabot now has a log module, it logs rather nicely.
18:23:06 <dons> so, should we start storing our own logs of #haskell?
18:23:11 <araujo> yay!
18:23:47 <dons> it generates directories in the usual form, like meme: http://meme.b9.com/clog/haskell/
18:23:50 <araujo> dons, i don't know.. i feel like doing nothing :-(
18:23:57 <dons> but maybe it would be nice to us to control our own logs.
18:24:36 <araujo> what do you mean?
18:25:13 <dons> well, lambdabot-generated logs on lambdabot's box feel more under community control than meme or clog.
18:25:35 <dons> so then i'm not so scared we'll lose our logs should meme or clog switch off their servers
18:25:44 <araujo> oh, right
18:33:57 <stepcut> does lambdabot have a log search engine ?
18:34:34 <araujo> @keal
18:34:34 <lambdabot> quote module failed: getRandItem: empty list
18:38:56 <dons> oh, i really like Swierstra's idea to have arbitrary expressions made infix with ``
18:39:16 <dons> xs `zipWith (+)` ys is so lovely
18:39:39 <stepcut> that is neat
18:40:08 <dons> this is one of the few proposals for Haskell' that could really be lovely when implemented :)
18:40:36 <stepcut> has there been any discussion of daan's record system?
18:41:28 <dons> there was a little a few days ago, raised by Cale
18:41:46 <araujo> that'd be cool
18:44:14 <Philippa_> dons: it's not the first time I've seen the idea (and I've even suggested it in the past), though I like his second version of the proposal now I've thought about it - especially in comparison to Bulat's
18:44:48 <Philippa_> stepcut: Daan's record system is highly unlikely to make it into haskell'
18:44:54 <dons> ah, it seemed so lovely I was surprised it hadn't been suggested before
18:45:01 <dons> yes. the problem : not implemented. 
18:45:14 <Philippa_> we can't use it without breaking existing code atm (though I'm reasonably sure there's a kind hack that can be done to let the record 'fall through' the data constructor)
18:45:22 <stepcut> Philippa_: yeah -- a bit too aggresive seeing as how it is not even implemented in any haskell compilers yet :
18:45:23 <stepcut> :p
18:46:03 * stepcut goes out for a walk
19:06:29 <dons> \version
19:06:29 <lambdabot> lambdabot 3p322, GHC 6.4.1 (Linux i686 3.20GHz)
19:06:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:13:13 <Lemmih> GHC-5.x didn't have arrows, right?
19:14:43 <dcoutts> @seen mwc
19:14:43 <lambdabot> I saw mwc leaving #haskell 30 minutes and 16 seconds ago, and I have
19:14:43 <lambdabot> missed 5 minutes and 25 seconds since then.
19:16:49 <palomer> ghc6 has arrows?
19:18:45 <dons> @index Control.Arrow
19:18:46 <lambdabot> bzzt
19:18:57 <dons> @hoogle Arrow
19:18:57 <lambdabot> Control.Arrow.Arrow :: Arrow a
19:18:57 <lambdabot> Control.Arrow.ArrowZero :: Arrow a => ArrowZero a
19:18:57 <lambdabot> Control.Arrow.ArrowPlus :: ArrowZero a => ArrowPlus a
19:19:08 <dons> palomer, of course. they're standard
19:19:47 <Lemmih> GHC's compiler pipeline could be expressed much simpler as arrow combinators.
19:20:11 <dons> really? as arrows? why not just monadic combinators?
19:20:26 <dons> oh, i guess you've got a couple of source coming in, and a couple of ways out.
19:20:38 <dons> hmm. this is an interesting idea Lemmih
19:20:51 <dons> I'm not sure if anyone's written on using arrows to construct compilers
19:21:44 <dons> there's a haskell workshop paper in that, I reckon..
19:21:53 <palomer> arrows? I've just gotten used to monads!
19:22:05 <Lemmih> I'm hoping it could abstract away the intermediate files and allow GHC to keep them in memory when possible.
19:22:11 <dcoutts> Lemmih, would it solve GHC's "bunch of global mutable vars" issue? :-)
19:22:59 <dons> yeah, that's what I was thinking Lemmih, the .hi files and src coming in, and the multiple exit points
19:23:06 <palomer> yeah, ghc randomly screws up on my system
19:23:31 <palomer> though admittedly quite rarely
19:23:38 <dons> in fact -- pipelines are exactly what arrows were built for...
19:23:54 <Philippa_> obStupidQuestion: how does that suggest more than a bunch of tuple projection work?
19:24:22 <Philippa_> (and the matching footnote: I don't find the arrow combinators notably useful there - does the syntactic sugar work out much better?)
19:24:38 <dons> yeah, the sugar is what you'd need
19:24:58 <dons> i've seen it used really nicely to describe gates and circuits
19:25:10 <Lemmih> dcoutts: alas, no /-: The mutable variables are burried deep into the rename, typechecker and various other dark corners.
19:25:11 <dons> ie. multiplexers -- which is kind of what ghc is :)
19:25:18 * Philippa_ nods
19:25:34 <dons> for high level pipeline descriptions, arrows migth work really well, I reckon
19:25:36 <Philippa_> fair enough, that makes plenty sense
19:26:09 <dcoutts> Lemmih, did you like Igloo's comment about rewriting ghc in a functional language ;-)
19:26:18 <Philippa_> (though I guess I don't see how more so than monads if you allow mdo, but that's because I smell an ArrowApply instance)
19:26:24 * Lemmih grins.
19:26:32 <dons> the arrow syntax almost gives you an ascii representation of the 2-d control flow. 
19:26:47 <dons> just as you'd draw on paper if you were to describe ghc's input and eoutputs
19:26:48 <Philippa_> yeah, I know
19:28:04 <Philippa_> I suspect I mostly just have an occasionally irrational irritation with ArrowApply because usually the do notation's just as good
19:28:43 <Philippa_> (and because therefore every time you spot an arrow, it's worth asking "does this work better viewed as a monad?" before getting excited)
19:32:05 <dons> well, I think these 2-d type of control flow, where some things are happening in parallel, streams are merged, and there are multiple exit points, are exactly what arrows syntax is fo.  ghc already uses monads, and it's icky :) 
19:32:51 <Philippa_> 'tis possible I'd use the monads differently ;-) But yeah, ISWYM
19:33:29 <Philippa_> and the explicit visual marking out of "this is what's going into and coming out of the BigArchitecturalBlocks" from all the glue work helps
19:37:08 <dibblego> if a function f returns a value v1 upon one invocation, then a value v2 upon another invocation and so on - if v1 == v2 == v3 == ... vn, then what adjective describes that type of function? is it "monadic"? "idempotent"? both?
19:37:28 <Philippa_> impure
19:37:44 <dibblego> why impure?
19:37:52 <dibblego> seems like "pure" is more descriptive
19:38:05 <dons> does it return the same result each time?
19:38:09 <dibblego> yes
19:38:18 <dons> then pure.
19:38:18 <Philippa_> oh, wait, pure then
19:38:19 <Philippa_> my bad
19:38:29 <dons> referentially transparent, perhaps
19:38:39 <dibblego> ok, so the term "monadic" means something else?
19:38:41 <Philippa_> or rather, it's pure /if it also doesn't affect the result of any other function except insofar as its return value matters/
19:38:44 <Philippa_> yes
19:38:53 <dibblego> right
19:39:04 <Philippa_> (which I assume you had in mind?)
19:39:14 <dibblego> yes, you assumed vorrectly
19:39:17 <dibblego> *correctly
19:40:08 <Philippa_> monadic more or less means "making use of a monad" - in practice, having a return type m a where m is some type constructor with an associated instance of Monad
19:40:14 <dons> yeah, it needs to return the same value, and not do any side effects, to be pure
19:40:47 <Philippa_> that value of type m a will represent a computation which won't necessarily be pure
19:40:59 <Philippa_> but the function that returned that value will be - it yields the same set of actions still
19:41:25 <dibblego> I think I understand what you mean - having never used Haskell, and read for a few minutes
19:41:27 <Philippa_> you may even have a pure way of carrying out that computation (essentially a function of type m a -> a)
19:41:32 <dons> idempotence is something else, f . f == f, right? like 1 * 1 == 1
19:41:47 <Philippa_> but you won't find a function of that type that works with all monads
19:41:56 <Philippa_> there isn't one in Haskell 98 of type IO a -> a
19:42:16 <Philippa_> (some compilers have one, but it's a compiler hack. Ignore the hands behind the curtain...)
19:42:57 <dons> idempotent functions are things like map id, or floor . floor = floor
19:43:11 <Sysop_fb> #join #osdev
19:43:14 <Sysop_fb> oops
19:43:22 <Philippa_> functions that don't do anything, then
19:43:30 <Philippa_> (yeah, yeah, I may be in a snarky mood tonight)
19:43:35 <dibblego> I don't know of those functions, but I agree with your stated definition - I had doubts when someone else didn't agree
19:43:46 <dons> well, 'floor' does something...
19:44:00 <Philippa_> you might've been talking to a webdev type
19:44:06 <dons> but idempotence in haskell is usually used to mean functions that if applied multiple times don't do anything than if applied once.
19:44:29 <dons> the 'init' function in ghc's liner is idempotent ..
19:44:35 <Philippa_> "doesn't do anything in this context"
19:44:35 <dons> s/liner/linker/
19:44:59 <Philippa_> webdev people use 'idempotent' to say something similar to 'pure'
19:45:22 <Philippa_> because somebody drew a dodgy analogy when they didn't have the terminology for the concept
19:45:31 <lispy> dons: your definition of idempotent is consistent to the way it is used in math
19:45:33 <dibblego> is the term 'pure' specific to Haskell, or can it be used in a general language discussion?
19:45:50 <dcoutts> either meaning, has do side effects or gaurds against those side effects happening more than once (like the ghc linker example)
19:45:55 <dcoutts> do/no
19:46:21 <dons> in general. it is a general term for non-side effecting languages or functions
19:46:26 <Philippa_> it can be used in a general discussion, though people who haven't done any functional programming won't grok it and might even think it's a really stupid idea
19:46:34 <dons> doesn't gcc have a 'pure' pragma?
19:46:38 <dcoutts> yep
19:46:41 <dcoutts> attribute
19:46:47 <dcoutts> and a const one
19:46:49 <dons> attribute, right :)
19:46:57 <dcoutts> which mean slightly different things
19:46:59 <dibblego> Idon't wish to identify with fools - I know when to use inaccurate terminology :)
19:47:00 <dons> yep.
19:47:26 <dcoutts> const can use global vars I think, pure cannot, pure must be a pure function of it's args
19:47:48 <dibblego> so you can perform compile-time enforcement of pure functions right? since you can prove their purity?
19:48:23 <dcoutts> I'm not sure that gcc enforces the attributes, perhaps it does
19:48:35 <dibblego> I haven't used gcc for about 7 years
19:48:44 <dons> dibblego, certainly in haskell -- thhe type system enforces this property
19:48:51 <dcoutts> but it uses the attributes to optimise
19:49:11 <dons> right, iirc you can always break the 'const' property in gcc, with things then going badly
19:49:13 <dibblego> dons: is there a formal statement of the proof? that is, how do you express that a function is pure?
19:49:55 <dibblego> logical steps to determine if a function is pure
19:50:05 <dcoutts> dons, I'd think that it ought to be possible for gcc could check if a function really is const
19:50:18 <dibblego> you could say; it returns a type that is made up entirely of pure functions
19:50:24 <dons> it's all pure, so you check the dynamic and static semantics of haskell for the proof that an expressionn can't perform a side effect
19:50:27 <dcoutts> it just needs to have no reads from global vars or dereference any pointers
19:50:30 <dibblego> I'm not sure how accurate that is
19:50:58 <dibblego> all Haskell functions are pure?
19:51:02 <Philippa_> yes
19:51:12 <dcoutts> in fact I think newer gcc's may discover const & pure C functions automatically and use that information at least within the same source file.
19:51:12 <dibblego> oh, well that changes things
19:51:14 <dons> i'm it's a pure functional language.
19:51:18 <dons> s/i'm//
19:51:22 <Philippa_> (unless you grabbed that compiler hack IO a -> a function, but hey)
19:51:45 <araujo> dibblego, f x = a for all x
19:51:49 <dons> so, from the axioms, you can't introduce any impurity, and all programs are built from pure pieces.
19:52:12 <dibblego> how do you do a read from a file? since a ead function must be pure
19:52:19 <dibblego> s/ead/read
19:52:27 <Philippa_> @type readFile
19:52:28 <lambdabot> FilePath -> IO String
19:52:39 <araujo> dibblego, i think that's a way to express that a function is pure.
19:52:44 <Philippa_> see earlier description of monads - IO is one
19:52:48 <dcoutts> hia araujo
19:52:53 <dibblego> ok thanks for the tips
19:52:53 <araujo> dcoutts, hiya!!
19:53:40 <Philippa_> (there're standard functions that allow you to build bigger computations from smaller ones, but you can't "get out of" the IO monad - the end result is you use pure functions to build a value of type IO a which is your program, and then the RTS runs it)
19:54:03 <dons> by abstracting over the sequencing of operations. we use monads to describe code that has a sequencing requirement, thus allowing side effects, but it's isolated by its type from the pure part.
19:54:15 <Philippa_> (this turns out to still be 'pure' because any IO a can be described by a function of type World -> World where World represents the state of the entire universe at a given instant)
19:54:43 <Philippa_> (but you can't expose World to the user or they'll do something they shouldn't like attempt time travel ;-)
19:54:46 <dcoutts> dibblego, the idea with IO is that the pure functional program constructs an imperitive program. That process of construction is in itself pure. An it's simply that the final value of the program is something of type IO which is then executed.
19:55:07 <dibblego> it seems the people in this channel possess sound methods of reasoning - and yet I cannot find a single soul to relate to in my usual programming
19:55:26 <dons> welcome to #haskell :)
19:55:34 <Philippa_> and welcome to life...
19:55:42 <dcoutts> in reality the construction of the imperitive program and it's execution are interleaved
19:55:48 <dons> @remember dibblego it seems the people in this channel possess sound methods of reasoning
19:55:49 <lambdabot> Done.
19:55:52 <Philippa_> but that's laziness for you
19:55:57 <dibblego> do many of you hold the position that the general population of the industry have deeply ingrained religious beliefs regarding their positions, even if they don't know it?
19:56:07 <Philippa_> of course, what seems to be true may not be ;-)
19:56:30 <dcoutts> dibblego, yep, that sounds right
19:56:33 <Philippa_> yeah. Most of them reckon it's the guy who should be giving during penetrative sex, for example ;-)
19:56:43 <dibblego> a colleague once told me, the sky is blue - I corrected him with "no you observe the sky is blue, all implicit axioms withstanding"
19:56:46 <Philippa_> (and by extension, that said sex should be heterosexual)
19:57:35 <araujo> 0_o
19:57:41 <dibblego> how incredibly odd - I very rarely meet people like this, and yet here is a channel of them
19:58:02 <Philippa_> yeah, I forget what colour air's supposed to be if you put a small amount of it under a white light, but it ain't blue
19:58:29 <dons> dibblego, you'll find that Haskell attracts a lot of people interested in proofs, soundness and oother more theoretical aspects of computer science
19:58:30 <Philippa_> araujo: I seem to keep ending up with guys who'd rather receive anyway
19:58:50 <dibblego> dons: perhaps that is why is it not dominant in the market?
19:59:01 <dons> the language is developed by academic research, rather than open source hackery, to a large extent
19:59:05 <araujo> Philippa_, :-P
19:59:05 <Philippa_> or their less formal equivalents: "not tacnuking my foot" and "having half a damn clue what my code's doing" ;-)
19:59:10 <dibblego> I find it difficult to deny that there is a very stupid mass, however optimistic I am
19:59:28 <Philippa_> araujo: now that I'd be happy with :-)
19:59:35 <dons> it's very common in universities, and has a niche in security and safe software that require proofs of correctness
19:59:36 <wchogg> Haskell is fairly obscure, and I think you have to have a certain enthusiasm and love for cs theory to find it in the first place.
19:59:46 <araujo> Philippa_, ;-)
19:59:57 <wchogg> dons-I don't think it's common in American universities, at least not from what I've seen.
20:00:14 <Philippa_> wchogg: FCVO 'theory', though. You don't have to be into Theoretical Computer Science
20:00:32 <dons> true, in the US things are different. it's more common in europe and australia/nz
20:00:41 <dibblego> do many of you use Haskell for commercial development?
20:00:45 <dcoutts> who wants to help me patch ghc to use a directory of package.conf files ?
20:00:46 <wchogg> The US is Java-Land.
20:00:53 <dons> however, it's growing. and it's hard to think of a language that is as dynamic 
20:01:18 <Philippa_> everywhere's java land. A lot of unis still use Haskell as a secondary language though
20:01:34 <dibblego> I have my own theories about language, and I have recently learned that Haskell closely aligns with them - I derived all my conclusions using a completely different approach
20:01:45 <Philippa_> scheme and relatives, I'd say. But they come at costs
20:02:00 <wchogg> I mostly meant that alot of Universities I've seen teach *nothing* but Java.  There are no alternative languages where I am, except C if you take operating systems.
20:02:14 <Philippa_> sadly that's pretty common here too :-(
20:02:16 <dons> dibblego, there are some. in the US it's used as I said, for high-assurance software. but you cann find some interesting applications here: http://haskell.org/haskellwiki/Haskell_in_practice
20:02:24 <dibblego> where I teach, it is Java, Haskell or .NET
20:02:26 <Philippa_> oh, and you might get perl and relatives somewhere down the line
20:02:44 <jimapple> (from earlier: I just checke, an gcc does not enforce __attribute__ ((pure)))
20:02:46 <wchogg> Wow, they teach .NET?  I've seen alot of places that don't for some reason.
20:02:46 * Philippa_ would like to do more with haskell in web dev, for example
20:02:55 <araujo> Only java and .Net (and some C sometimes)
20:03:00 <araujo> (here)
20:03:07 <dons> jimapple, welcome to the wonders of C :)
20:03:08 <Philippa_> that "some reason" would be that for the most part it's even more vendor-specific than Java
20:03:12 <Spark> i would be suprised if the top 10 universities did not have functional programming in their curriculums (i dont like latin)
20:03:12 <dibblego> when I attended the university years ago, it was only C or C++
20:03:23 <Philippa_> jimapple: since when is any useful property enforced in C?
20:03:26 <Spark> in any country that is
20:03:35 <Philippa_> Spark: Romania?
20:03:37 <dons> the C guys are a bunch of hippies who never like to tell you what to do. 
20:03:47 <Spark> is that a country? :)
20:04:05 <Philippa_> not quite
20:04:20 <dons> unlike those dominatrix haskellers always telling you want you can't do, and what you should be doing to please them.
20:04:25 <Spark> i should say the top 10% maybe :)
20:04:26 <Philippa_> C comes from an era when you couldn't get useful guarantees anyway, so the best the type system could do was get the hell out of your way
20:04:32 <Spark> for countries that have less than 10 universities
20:04:33 <Philippa_> dons: see my article ;-)
20:04:39 <wchogg> dons-So you're saying we're kinky for liking Haskell?
20:04:47 <dons> Philippa_, yeah, that was for you :)
20:04:53 <Philippa_> (although I imagine most of the crowd in here're dominators rather than dominatrices)
20:05:04 <wchogg> Oh yeah, that piece from the Monad Reader?
20:05:10 <Philippa_> yeah, that was me
20:05:12 <jimapple> Yes, I would be very surprised if GCC checked the purity. OTOH, there are lots of C add-ons that check lots of things: SAC, CCured, Cyclone, etc.
20:05:19 <dons> we like to be strict with ourselves. Philippa_ wrote an article on it.
20:05:25 <dcoutts> anyone feel like doing some ghc hacking? I've got 3 projects of farying difficulty....
20:05:30 <wchogg> I got a pretty good laugh out of the Haskell/BDSM connection.
20:05:30 <dibblego> I have started writing an article that invalidates OO languages under a given set of axioms (which everyone typically assumes)
20:05:38 <dcoutts> farying/varying
20:05:50 <stepcut> dibblego: sweet :p
20:05:55 <goltrpoat> how does one "invalidate" a language
20:05:57 <dibblego> I would be keen to hear what some of you have to say about it - I only have the orthodox refutations, which are really not very valuable
20:06:04 <Philippa_> wchogg: one of the things I like about that is it only works for /good/ BDSM :-)
20:06:13 <dibblego> goltrpoat: point out the contradictions of the axioms
20:06:20 <dcoutts> goltrpoat, use it to write a program that segfaults?
20:06:27 <dibblego> using mathematical methods
20:06:35 <Philippa_> dibblego: they concentrate on record or product types even when union/sum types are more appropriate to a task
20:06:37 <dons> dibblego, there's a large amount of language research on proving soundness of OO languages. so you might want to check that out.
20:06:45 <Philippa_> you should be able to hone in on a few issues from there
20:06:50 <goltrpoat> dcoutts:  if i use a table saw and cut off my hand by accident, does that invalidate table saws
20:06:59 <dons> the cutting edge these days is to use theorem provers to automatically check your type system and dynamic semantics
20:07:02 <Philippa_> no, it invalidates the idea of your body being a safe design
20:07:06 <jimapple> dcoutts: what projects have you?
20:07:31 <dibblego> one of my axioms is that time moves (that we are not moving away from our software at the speed of light) - under this axiom, OO is invalid - I'd like to find any holes in my reasoning, but I cannot
20:07:50 <dibblego> I have put it passed a few clever people, and we are all convinced - it has taken us 2 years
20:08:19 <goltrpoat> well.. now that you put it that way
20:08:20 <goltrpoat> hehe
20:08:29 <goltrpoat> im convinced.  anyone else convinced?
20:08:34 <Spark> what has the speed of light got to do with execution
20:08:51 <Spark> you have one line to answer or i ignore you
20:08:52 <jimapple> goltrpoat: It means you haven't heard of http://www.sawstop.com/
20:09:01 <dibblego> at the speed of light, software cannot change relative to the observer
20:09:15 <dcoutts> jimapple, 1. allow ghc to use a directory of .conf files rather than always having to use a global package.conf file, 2. allow us to pack all the .hi files for a package into one file (this could improve speed and make management more convenient). 3. get ghci's linker to load up .o files from .a archives.
20:09:21 <wchogg> dibblego-So your theory is dependent on the existence of a background metric for spacetime?  Lame!
20:09:35 <goltrpoat> jimapple:  touche
20:09:35 <dcoutts> jimapple, that's in order of difficulty :-)
20:09:48 <Philippa_> yeah, you can find loads of problems with typical OO without any form of IO or outside universe
20:10:14 <dibblego> wchogg: how is it lame? one must state their axioms, even if they appear absurd
20:10:39 <dibblego> or that they don't exist appears absurd I should say
20:11:15 <Philippa_> you only need raw computational axioms to have a good go at OO though
20:11:32 <goltrpoat> dibblego:  ok.  axiom:  apples grow on trees, sometimes.  corollary:  goats chew on soda cans.  discuss.
20:11:48 <Philippa_> as a rule of thumb all interactions with an outside world are potentially going to go horribly wrong anyway
20:11:57 <Philippa_> you can't prove the substrate system won't get hit by a meteorite
20:12:07 <dibblego> goltrpoat: do you suggest that the apparant lack of relation is what makes it lame?
20:12:49 <Philippa_> you can parameterise most proofs of OO's lameness on any of a wide range of Theories of Everything ;-)
20:13:28 <Philippa_> anyway, carry on and let's see if you get somewhere interesting - you just seem to be starting at the wrong layer of abstraction
20:13:53 <dibblego> I don't see why it is not important to assume time
20:14:01 <dibblego> or really, to state the assumption of time
20:14:25 <Philippa_> you only need a notion of computational progress. In a lambda calculus you can use the number of reduction steps, for example
20:14:36 <dons> yeah, i think that perhaps beginning with physics might take a whlie to make useful statements about what's happening on the machine..
20:14:42 <Spark> time is expressed in terms of the arrow relation in small step operational semantics
20:15:03 <wchogg> dons-As a physicist who's being trying to learn programming, I can attest to that. :-P
20:15:05 <Philippa_> Spark: you're missing a few qualifiers there, I don't have a small step operational semantics for the universe ;-)
20:15:33 <dcoutts> does anyone have a step operational semantics for Haskell?
20:15:44 <lambdabot> Issue 28 of the Haskell Weekly News it out: http://sequence.complete.org/
20:15:54 <dons> dcoutts, for Core, yes.
20:15:54 <Spark> in the context of this discussion, the universe is the set of all program states :)
20:16:18 <dibblego> I better do work - seeya
20:16:23 <dcoutts> dons, oh, ok, that's more that I thought
20:16:24 <dons> there's at least one implementatoin in the twelf theorem prover, i know of.
20:16:42 <dons> and I suspect several papers. SPJ published a static semantics
20:16:50 <dcoutts> I know there's a rather new denotational semantics
20:16:59 <dcoutts> in a couple articles in JFP
20:17:08 <dons> but still the ML guys make fun of us not having a "Standard ML" book 
20:17:10 <Spark> "new" "denotational semantics"? :)
20:17:17 <dons> hehe
20:17:21 <dcoutts> it's quite complex
20:17:44 <dcoutts> well, new as in it's in recent JFP editions
20:18:27 <dcoutts> the semantics of pattern matching is suprisingly complicated
20:18:56 <dons> yep. as I think the lazy/strict patterns discussion recently has emphasised
20:19:07 <dcoutts> right
20:19:22 <dcoutts> and having to deal with the existance of seq makes a big difference
20:20:04 <dcoutts> that makes it rather different from the informal formal semantics we were taught as undergrads
20:20:27 <dcoutts> we did lots of equational reasoning with functions etc as undergrads
20:20:43 <dons> yeah. we don't bother teaching seq in our principles of programming course, either.
20:21:23 <dcoutts> because is breaks things :-)
20:21:28 <dcoutts> is/it
20:21:31 <dons> it makes the proofs too hard
20:21:59 <dons> particularly when doing the proofs on paper, by newbies :)
20:22:00 <dcoutts> because it distinguishs things that we'd often rather not distinguish
20:22:16 <wchogg> What does seq do again?  I looked up the type, but it's not obvious what it means.
20:22:30 <dons> because it's not the type that is important :)
20:22:33 <dcoutts> > undefined `seq` 3
20:22:33 <lambdabot> Undefined
20:23:06 <dcoutts> @type seq
20:23:07 <lambdabot> forall b a. a -> b -> b
20:23:18 <dcoutts> @type \a b -> b
20:23:18 <lambdabot> forall t t1. t1 -> t -> t
20:23:32 <dons> > fst `id` (1,undefined)
20:23:32 <lambdabot> 1
20:23:38 <dons> > fst `seq` (1,undefined)
20:23:38 <wchogg> So it returns the second value passed to it as long as it doesn't bottom?
20:23:39 <lambdabot> Add a type signature
20:23:43 <dcoutts> > let seq = (\a b -> b) in undefined `seq` 3
20:23:44 <lambdabot> 3
20:23:46 <dons> > fst `seq` (1,undefined) :: ()
20:23:47 <lambdabot> Couldn't match `()' against `(a, a1)'
20:23:48 <dcoutts> > undefined `seq` 3
20:23:48 <lambdabot> Undefined
20:23:56 <dons> > fst `seq` (1,undefined) :: (Int,())
20:23:57 <lambdabot> Undefined
20:24:23 <dons> wchogg, it forces evaluation to a normal form
20:24:27 <dcoutts> wchogg, it forces it's first arg to weak head normal form
20:24:46 <dcoutts> you can't write seq in Haskell
20:24:46 <dons> so it's how we add strictness. it's the strictness primitive, in a sense
20:24:51 <dcoutts> it must be a primitive
20:25:10 <wchogg> You can't write it in Haskell because Haskell is naturally lazy?
20:25:14 <dons> !Int translates into a bunch of `seq`, for example
20:25:16 <dcoutts> right
20:25:27 <wchogg> Okay, I wanted to make sure there wasn't a more profound reason.
20:25:38 <dcoutts> older versions of Haskell had a Seq class rathe than a seq primitive
20:25:49 <dcoutts> that didn't change the semantics
20:25:51 <dons> strictness seems like magic in a lazy, pure language :)
20:26:00 <dcoutts> but couldn't be applied to functions (right?)
20:26:03 <wchogg> And the Seq class was handled differently by the compiler?
20:26:44 <dcoutts> the Seq class was just ordinary Haskell so didn't need special support in the compiler (except for effeciency)
20:35:18 <wchogg> So is Haskell' going to be finalized in the next few months or is it more of a end-o-the-year project?
20:36:08 <dons> by September, is the plan
20:36:37 <wchogg> Cool.  
20:37:24 <wchogg> It seems like there's alot of pretty aggressive ideas people have been throwing around for Haskell' on the mailing list.  I know there's alot of ideas about records.
20:38:03 <dons> unimplemented things are unlikely to make it in, but it'll probably lead to research, and new things over the next few years
20:38:36 <dons> the idea isn't to invent a new language just yet, it's to sanction the extensions that are currently in use.
20:38:52 <dons> but for which we have no standard to refer to
20:39:33 <wchogg> This is one of the things I really like about Haskell as opposed to CL:  the fact that there are so many new ideas flowing into it.  I don't really know enough to contribute, but I enjoy reading the proposals.
20:40:32 <dons> i large part of the programming language research commuity is now working on haskell, and it has a fairly unified community, making progress forward easier, I think. new ideas make it into the standard compiler, and get widely used if they're good. this helps aa lot
20:40:39 <stepcut> personally, I am glad we have not yet adopted a new record system -- because the proposals for replacements seem to be getting better as the years go by
20:41:49 <dons> stepcut, is there a theorem in there somewhere: the size of a record system extensions is proprotional to the number of years since H98
20:42:08 <dons> oh, I misread "better" as "biggeR"
20:42:18 <stepcut> Atleast almost every agrees the current system sucks -- which makes it easier to ditch and replace. If we put in something that is "ok", it will be much harder to put in the "right" thing later
20:43:02 <Philippa_> dons: I'll be seriously impressed if there's much can be done beyond Daan's system + a bit of funky kinding to let recordness 'fall through' data constructors
20:43:28 <Philippa_> (and naturally if you're passing it as a record rather than something of the relevant datatype you unbox much as with typeclasses...)
20:44:24 <Philippa_> (IMO, if ISO Haskell happens before we have a good record system, we've screwed up bad)
20:44:46 <dons> ISO Haskell, eh?
20:44:59 <stepcut> ISOLUV Haskell ?
20:45:07 <wchogg> ISO Haskell seems almost a misnomer.
20:45:26 <stepcut> RFC Haskell ?
20:47:18 <Philippa_> dons: I figure it or something like it'll happen one of these years. Probably when research on non-dependant type systems starts seriously running out of steam for a while
20:48:01 <dcoutts> stepcut, the major problem is that record selector names are global. Most people don't actually need extensible records.
20:48:38 <Philippa_> turning Haskell into a true dependantly typed language would be the sort of major shift that leaves a language cruftier than a teen python hacker's boxers
20:48:42 <dons> yeah, i mean, it could happen. ANSI C was what, 15 years after C appeared. it's been 16 since Haskell appeared.. but the language is still far too dynamic
20:49:28 <wchogg> That's is one of the nastiest analogies I have ever heard, yo.
20:50:04 <Philippa_> yeah, I'm talking about another decade or so
20:50:35 <wchogg> Heh...how advanced will cutting edge languages even be in a decade?
20:51:40 <Philippa_> for what value of 'cutting edge'?
20:51:55 <Philippa_> I'm hoping for Epigram to be where haskell was five years ago
20:51:58 <dons> well, more programs will be well-typed and they'll run faster
20:52:05 <dons> :)
20:52:10 <dons> maybe the later is hoping for too much
20:52:32 <Philippa_> I don't know about faster. Though getting the concurrency right'll be a lot easier, so that might be achievable given everything's going multi-core
20:53:05 <dons> and there'll be more properties checkable in the type system, to go along with the new programs that will be well-typed
20:53:19 <wchogg> Honestly, all I want is a language as pretty as Haskell with a badass macro system.
20:53:42 <Philippa_> read up on Template Haskell
20:53:46 <dons> macros are evil, and you don't need them with higher-order combinators :)
20:53:50 <Philippa_> it won't do everything a macro system does...
20:54:08 <Philippa_> but then if you want pretty syntax that bad you'd have run screaming from lisp anyway ;-)
20:54:30 <wchogg> No, I actually like lisp.  It's my second favorite.
20:54:48 <wchogg> I *do* like how pretty haskell is though.  It's very expressive and terse.
20:54:54 <Philippa_> yeah. You don't get much room to actually prettify it with macros though
20:55:16 <Philippa_> yeah. And it actively encourages you to use whitespace with style and a sense for reading pace, too
20:55:43 <Philippa_> I start to forget about it because I'm so used to it, but I really like the flexibility of binding in haskell
21:03:47 <wchogg> dons-I am curious though about what you mean that you don't need macros when you have higher-order combinators?
21:06:56 <Philippa_> with lazy evaluation, you don't need macros to build most control structures
21:07:14 <Philippa_> a build-your-own-if reads thusly:
21:07:36 <wchogg> Oh, I know stuff like if is easy to do in a lazy language.
21:07:44 <Philippa_> :-)
21:08:01 <Philippa_> you can build most things if you're feeling twisted enough
21:08:13 <Philippa_> you can build all of them with about as much 'safety' as you'd have in a lisp
21:08:26 <Philippa_> (modulo purity, but hey)
21:08:50 <Philippa_> (when in doubt, build an AST type and an interpreter for it ;-)
21:09:26 <Philippa_> OTOH, I agree there's a use for something that lets you build 'native-feeling' syntactic extensions
21:09:46 <Philippa_> Template Haskell doesn't quite, but it lets you screw around with haskell ASTs enough to do some fun stuff anyway
21:10:07 <Philippa_> (I've got a little example using it to build a compiler for a toy language up on TMR, for example)
21:10:11 <wchogg> Template Haskell is pretty neat, but it feels kindof clunky.
21:10:18 <Philippa_> yeah, I agree
21:10:33 <Philippa_> I'd like a bit more sugar - I'm not sure I'd like more than that
21:10:55 <Philippa_> it'd be nice to have some way to build something like do notation with it, but hey
21:11:40 <stepcut> Philippa_: like camlp4?
21:12:01 <Philippa_> stepcut: I guess, yeah. Not used it
21:12:27 <wchogg> camlp4?  I presume that's an ocaml thing?
21:12:47 <Philippa_> yeah
21:13:00 <Philippa_> parser, processor&pretty printer
21:14:25 <stepcut> camlp4 let's you do *syntax* extensions to ocaml. One example they have is making an s-exp version of ocaml
21:15:19 <stepcut> but, I don't think it does much in the way of code generation
21:15:37 <Philippa_> in fairness all we really need to get started on that's a suitably extensible haskell parser that spits out the TH AST type
21:16:08 <Philippa_> heh, and now I'm thinking of some of the horribly wanky things I've made parsec do in the past
21:16:29 <stepcut> I thought it was interesting how *little* overlap there is between what you can do with camlp4 and what you can do with TH
21:16:35 <Philippa_> I mean, if there's one thing you're going to put in its state, it's just /got/ to be a structure full of more parsers, hasn't it?
21:16:59 <Philippa_> everything else is just boring ;-)
21:17:14 <dcoutts> @localtime Philippa_ 
21:17:16 <lambdabot> Local time for Philippa_ is Mon Mar 13 05:16:53 2006
21:17:20 <Philippa_> "fucking late"
21:17:25 <stepcut> Philippa_: have you seen the ctk lexer stuff ?
21:17:26 <dcoutts> just wondering :-)
21:17:44 <dcoutts> @localtime dcoutts 
21:17:45 <lambdabot> Local time for dcoutts is Mon Mar 13 05:16:53
21:17:49 <Philippa_> what, thought I'd gone on holiday all of a sudden?
21:17:56 <dcoutts> heh
21:19:52 <Lokadin_> funky funktions!! :D
21:20:16 <Lokadin_> thatz whatz it all aboot!
21:20:17 <Lokadin_> lol
21:21:12 <Lokadin_> say does anyone know if there are laptops you can assemble yourself?
21:21:38 <stepcut> Lokadin_: how much time ya got ?
21:21:41 <stepcut> ;p
21:22:14 <Lokadin_> well as much time as i have to put together a desktop
21:22:16 <Lokadin_> lol
21:22:28 <Lokadin_> maybe a lil more
21:22:36 <Lokadin_> no soldering or anything like that though
21:22:53 <Philippa_> stepcut: I haven't (sorry for the pause)
21:23:56 <stepcut> Philippa_: it has an built-in concept of a meta-lexer -- which is a lexer that returns a new lexer
21:24:52 <stepcut> Philippa_: in YI you can use it to do things like switch to a different set of lexing rules if you are in insert mode vs edit mode (or whatever vi calls those things)
21:25:05 * Philippa_ nods
21:25:08 <Philippa_> higher-orderness good
21:27:09 * stepcut goes to bed
21:27:16 <stepcut> @localtime stepcut
21:27:17 <lambdabot> Local time for stepcut is Sun Mar 12 21:26:56 2006
21:27:48 <Philippa_> in a way, working in Haskell makes you really appreciate what a dynamic system offers you
21:27:59 <Philippa_> you have to build the dynamism (although often that turns out to be a fairly quick thing to do)
21:28:39 <Cale> It also makes you really appreciate what a dynamic system doesn't give you
21:29:28 <Philippa_> mmm, although I'm not assuming dynamic = (wholly) dynamically typed
21:29:49 <Philippa_> (staged, statically typed and with dynamic checks at stage boundaries'll do)
21:31:22 <dibblego> aren't you supposed to be sleeping?
21:31:27 <Philippa_> one thing I can say for Haskell: it finally gave me the clear space to truly think 'architecturally'. It turned out to be the same kind of thought as most of the other code
21:31:34 <Philippa_> define "supposed"
21:31:51 <dibblego> according to your own definition of what is right for yourself
21:32:02 <Philippa_> I've not got to get up in a few hours if that's what you mean - one of my partners'll probably show up late afternoon so I should be up for that, but that's about it
21:32:18 <dibblego> righto then
21:32:48 <dibblego> I suffer terribly without sleep
21:33:22 <Philippa_> I'd be better off sleeping. I'll live though
21:39:22 <goltrpoat> what's a good paper on arrows?
21:40:24 <Philippa_> the first one and ross paterson's paper're good
21:41:03 <Philippa_> both're linked from www.haskell.org/arrows/biblio.html
21:41:21 <Philippa_> (not the notation paper, though that probably won't do any harm)
21:41:22 <goltrpoat> ah cool, thanks
21:41:46 <dons> we use the higher-order lexers in the shootout entry to emulate some of pperls funky pattern extensions (like inserting a value into an association list using the bit of the pattern that matched as a key)
21:42:18 <dons> all without having to extend the regex lang -- just use haskell for any extensions, since the meta concept is expressive enough to hook all of haskell into the regex engine
21:42:22 <dons> good edsl stuff
21:42:49 <Philippa_> is it monadic, or another structure?
21:43:37 <dons> pure state threading, not monadic as such
21:44:10 <Philippa_> fair enough :-)
21:47:59 * dcoutts tests a conf dir patch for ghc
21:49:09 <dibblego> I should go back to university
21:51:03 <Philippa_> FWIW uni doesn't really cover this kind of fun anyway
21:51:15 <dibblego> a PhD would if I made it so
21:51:35 <Philippa_> not at an undergrad level because it's too scary for their poor widdle minds (er, I never graduated, but ignore that ;-), postgrad you don't really get taught this kind of stuff
21:51:59 <dibblego> I never intend to be taught at a university
21:52:06 <goltrpoat> philippa:  eh.  i was reading some notes online for an undergrad course at UT that talked about haskell
21:52:14 <dibblego> in fact, I've always argued that if learning is an objective, university is the wrong place
21:52:25 <Philippa_> goltrpoat: bet it didn't talk about funky ways to structure a lexer though
21:52:46 <Philippa_> or achieving serious levels of dynamism in haskell and the tradeoffs involved
21:52:49 <goltrpoat> philippa:  it presented a brief rehash of hutton and meijer's paper
21:52:55 <goltrpoat> that was about as complex as it got
21:53:02 <Philippa_> or faking first-class modules...
21:53:04 <Philippa_> yeah, I got that
21:53:07 <Philippa_> from Hutton, too
21:53:15 <dibblego> at the moment, I am making The Big Guy rich - I'd rather do fun stuff and get my missus to do the money making - in this country, there is a threshold where it's not worth working for additional money anyway due to tax
21:53:24 <dcoutts> goltrpoat, most universities that teach Haskell at an undergrad level don't do so to a very high level
21:53:27 <goltrpoat> philippa:  you had hutton as a professor?
21:53:31 <dons> Philippa_, depends on the university, right? some of the haskell unis do a lot of this stuff (if I am binding "this" correctly)
21:53:37 <goltrpoat> radical.
21:53:55 <Philippa_> yeah, I'm right next door to UoN's other campus and Hutton's still theoretically the supervisor for my third year project if it ever happens
21:54:04 <goltrpoat> nice
21:54:10 * dcoutts wishes Oxford had an advanced function programming course on it's 4 year undergrad degree
21:54:15 <Philippa_> dons: yeah, but AIUI they mostly go off into theoretical land
21:54:33 <dons> dcoutts, terrible that they donn't
21:54:41 <dcoutts> dons, yeah
21:54:45 <dons> AFP courses are so much fun.
21:54:47 <Philippa_> I mean, Oxford's notable for the amount of haskell involved from the people I've spoken to - one of your dropouts showed up here (though I already knew him via afp)
21:55:00 <Philippa_> I don't know if the one here'll survive long
21:55:15 <dons> and even less have AFP and the theoretical side, with type systems courses
21:55:47 <Philippa_> Looking at the notes, AFP here seems to mostly be "here, write your own monad! And learn a little about continuations!"
21:55:51 <dcoutts> we use haskell on a lot of courses but don't really teach it much
21:56:07 <Philippa_> then again, it'd take at least a year's worth of modules to pass on all the folklore in this chan anyway
21:56:17 <dons> Philippa_, unsw AFP : http://www.cse.unsw.edu.au/~cs4132/
21:56:39 <dcoutts> I'd like a course that covers type classes, monads, cunning combinator libs, stuff
21:56:48 <dcoutts> IO :-)
21:56:56 <Philippa_> I think the one here does that just about
21:57:31 <Philippa_> dons: looks funky. What's the target audience?
21:57:53 <dons> type classes should be in an introductory course though. except for type checking with type classess...
21:58:07 <dons> AFP is for 4th year honours students and post grads
21:58:10 <Philippa_> yeah
21:58:13 <dcoutts> dons, oh they are, but not advanced use of them
21:58:18 <Philippa_> ah. Ours is optional for second and third years
21:58:27 <dons> ah, i don't know anyone who teaches advanced type classes.
21:58:35 <Philippa_> is there anything in H98 that counts as 'advanced'?
21:58:51 <dons> this course teaches associated types, or did last year, http://cgi.cse.unsw.edu.au/~cs3161/ :)
21:59:14 <dons> for 3rd year undergrads. we proofed them silly :) hehe
21:59:42 <Philippa_> yeah, high proof density was the complaint I heard about Oxford's course
21:59:50 <dcoutts> dons, well I think our intro course only covers type classes for the Eq, Ord sort of cases, not for the lots of other cunnign stuff you can do. Eg what sorts of designs would use classes vs. records vs ordnary functions.
21:59:55 <Philippa_> to the extent that the guy was actively shuddering when I used the word 'monad' in the pub
22:00:26 <dcoutts> Philippa_, yeah, that's the main complaint, lots of proofs
22:00:40 <Philippa_> ordinary function = you're damned sure you'll only ever need one, record = you really need all the flexibility you can grab, class = you're pretty sure you only want one per type? ;-)
22:00:44 <dons> dcoutts, ah, same here. and the type systems course 3161 covers constraints in the type checker. 
22:00:57 <dons> but still, I don't know of anywhere that'd teach hlist-style hackery
22:01:04 <Philippa_> we don't cover any type theory here :-(
22:01:10 <dons> we'd have to get Ralf lammel to do a graduate workshpo
22:01:17 <Philippa_> in fairness there's some fairly filthy stuff required in hlist
22:01:28 <dcoutts> dons, anyway hlist-style hackery is evil ;-)
22:01:34 <Philippa_> equality of type variables is an awful hack from what I've understood
22:01:41 <Philippa_> most of the rest I think I can follow sensibly...
22:01:56 <Philippa_> (I had a fair crack at building something similar before I asked for Oleg's region code for my article)
22:03:34 <dons> Philippa_, on whether anything in H98 is advanced -- the semantics of exceptions, the runtime system, edsls, type checking classes
22:04:01 <dons> you don't teach the RealWorld# token to beginners :)
22:04:23 <Philippa_> I really meant typeclasses there, but yeah
22:05:39 <Philippa_> I don't think typechecking (single parm) classes is particularly advanced, though it's got some tedious detail involved
22:05:55 <dons> i think the proofs in our theory course would have been ovewhelming, so the assignments were all hack fests-- write an interpreter for Core, write a type inference for mini-haskell. 
22:05:58 <Philippa_> tbh I think there's more risk of brain damage in getting polymorphic recursion right
22:06:26 <dons> sure. it depends on what they've done before. if they've only done Haskell 1A, and got as far as Eq and Ord, they stil don't know what type inference really is.
22:06:44 <goltrpoat> what i want to know.. is why the generic programming with morphisms lecture is called bananas.ps
22:06:55 <Philippa_> give or take, yeah. I'd sorta taken it from context that you'd got H-M through okay
22:06:55 <dons> it uess lots of (  and )
22:07:05 <Philippa_> (| and |), no?
22:07:16 <dons> or is that a lense?
22:07:21 <goltrpoat> oh
22:07:23 <Philippa_> there's a series of papers with increasingly dodgy names as a result
22:07:27 <dons> and somewhere in there is some barbed wire.
22:07:38 <dons> $ <- is that barbed wire?
22:07:43 <Philippa_> and then there's bananaaaaas in spaaaaaaace...
22:08:14 <dons> @google bananes lenses barbed wire
22:08:15 <lambdabot> http://www.bedrijvengids-belgien.be/bedrijvengids-belgie/l1c1-b-o1c1--
22:08:15 <lambdabot> p1c1--n1c1-coated.htm
22:08:22 <dons> @google bananas lenses barbed wire
22:08:25 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
22:08:29 <dons> there wego
22:08:43 <dons> ^^ that's why goltrpoat
22:08:52 <goltrpoat> gotcha
22:08:53 <dons> oh, I forgot envelopes!1
22:09:43 <dons> followed by "Bananas in Space: Extending Fold and Unfold to Exponential Types" as Philippa says
22:10:01 <dons> oh, nice title: Calculate Categorically! - Fokkinga (1992)
22:10:05 <dons> Cale would like that ^^
22:11:47 * dcoutts was acosted the other day by a drunk man in the pub who quized hime on category theory
22:12:07 <goltrpoat> nice
22:12:45 <dcoutts> Quick! what are the defining axioms of a catrgory?
22:12:53 <dibblego> I must go to the wrong pubs
22:12:57 <dons> I've had that happen! though i was the one who was drunk :} I got questioned on what Leibniz had to do with Haskell monads
22:13:00 <goltrpoat> dibblego:  that's what i was thinking
22:13:08 <dcoutts> dibblego, no, I do, clearly :-)
22:13:14 <dibblego> or that :)
22:14:49 <dons> dcoutts, it's lovely to see you're lending .au your queen for the week :) (/me notices she is in sydney carrying on like she owns the place ;)
22:15:09 <goltrpoat> the best i get is drunk 50 year old hicks spending hours telling me that they are fascinated by games and that they want to know how they're made
22:15:18 <dcoutts> dons, heh, it means we can get rid of her for a week or two :-)
22:15:26 <goltrpoat> and me politely nodding, smiling, and staring at my guinness
22:17:25 <dibblego> I was in Sydney last week and went to the wrong pubs - still feling it, and I have squash tonight - 'twill be painful
22:17:54 <dons> ah, you're in qld :)
22:18:00 <dibblego> am now :)
22:18:16 <dibblego> I was working at Homebush West
22:18:57 <dibblego> I still am in theory - over the network - I'll be going back in a few weeks
22:19:25 <tennin> do they kick you out of the pub if you fail the quiz?
22:19:39 <dibblego> you can't fail a quiz in a pub
22:19:53 <dibblego> you just take a sip of your beer and change reality
22:20:01 <dibblego> to suit your otherwise incorrect answer
22:20:16 <dibblego> that's the beauty of public bars
22:21:03 <dcoutts> mwc, sorry, your gtk2hs patch didn't get through, would you mind re-sending?
22:48:20 <goltrpoat> the haskell/opengl "lecture notes" from that afp site are remarkably silly
22:49:00 <goltrpoat> summary:  "check out what i wrote.  i know it sucks, but bear with me."
22:51:20 <goltrpoat> sort of a weird contrast with the rest of it
22:52:29 <dons> which site?
22:52:51 <goltrpoat> http://www.cse.unsw.edu.au/~cs4132/lecture/
22:52:53 <dons> if its the unsw one, then those are the lectures students gave on the code they wrote for their projcets
22:52:57 <goltrpoat> ohh
22:53:10 <dons> only the first 3 or 4 are from the lecturer, the rest are student projects
22:53:10 <goltrpoat> my bad
22:53:31 <dons> so some of the slides will be by 4th years students who've not given a talk before
22:53:48 <dons> others will be by phd students, and should be fairly good
22:55:05 <dons> you'll see the names in [] brackets next to the lecture nottes
22:55:21 <goltrpoat> -nod- i assumed all of those were from the lecturer
22:55:37 <dons> the first 8 are by phd students and the lecturer (chak), the last few, 12, 12, 13 are from undergrads
22:55:44 <dons> 11,12,13 i mean
22:56:18 <dons> so slides in weeks 2-10 should be very good, I'd expect
22:56:56 <dons> sjw's project would be publishable, i reckon.
22:59:55 <dons> it's a pity that the slides from previous years aren't up. i gave a talk on the ghc runtime system :}
23:00:16 <dons> and another student I worked with wrote a speed controller for a solar car
23:01:01 <goltrpoat> ah cool
23:04:31 <dons> scary, i realise that was 4 years ago. this phd is taking forever :}
23:04:58 <ncalexan> Hehe...
23:06:24 <goltrpoat> oh sweet, there's one on SSA
23:07:03 <Lemmih> dons: What are you researching?
23:07:55 <dons> type safe linking is the topic
23:08:12 <dons> (i've only been doing the phd for 2 years though :)
23:08:20 <shapr> What did you do for the first two years?
23:08:33 <shapr> Lie around and enjoy being an academic? ;-)
23:08:40 * shapr envisions the academic life of luxury.
23:08:51 <dons> well, when I did this course in 02 I was doing my honours degree. then i worked as a research assistant for a year, and then I started a phd :)
23:09:17 <dons> so, yeah, lying around writing free code :)
23:09:22 * shapr grins
23:10:15 <dons> shapr, does daan leijan's darcs-server do what you wanted to do with cgi all these years?
23:10:50 <shapr> Sure seems so.
23:10:56 <shapr> It appears to do everything I want and then some.
23:11:08 <dons> when i read the spec I though, that's everything shapr used to beg for.
23:11:17 <shapr> I suspect it'll be installed on Kakapo.ScannedInAvian.com in a coupla days.
23:11:22 <dons> :)
23:11:35 <dons> a kakapo eh?
23:11:49 <shapr> Yeah, I just installed kiki yesterday.
23:11:53 <shapr> er, "kiwi"
23:12:02 <shapr> I'm trying to come up with more .au and .nz birds to use.
23:12:02 <dons> ah, yes, now it makes sense :)
23:12:28 <shapr> I had a lot of fun reading - http://www.kakapo.net/en/
23:12:33 <dons> hmm, nz has a bit of a monopoly on the weird ones.
23:12:56 <dons> and things like tuatura (sp?) and those giant ground crickets
23:13:01 <shapr> Mrak suggested... cassowary, I think.
23:13:07 <dons> ah, yesh. that's a good one
23:13:08 <shapr> Yeah, the Weta.
23:13:18 <dons> that's it.
23:13:30 <shapr> Those are terrifying looking critters.
23:13:49 <dons> we have smaller ones here, I would find them in my bedroom at night as a child
23:13:51 <shapr> I suspect H.R. Giger had a bad childhood experience with a Weta, thus affecting his art.
23:14:15 <shapr> I bet that was fun :-)
23:14:37 <shapr> I woke up with scorpions in my bed once when I was living in Florida.
23:14:55 <ncalexan> That's enough to scare the be-jesus out of you.
23:15:17 <dons> the cricket wasn't as bad as the red belly black snake that was under my bed one night :S
23:15:37 <dons> that was really hard to encourage to leave
23:15:42 <shapr> Florida had rattlesnakes, scorpions, wasps, bees, alligators, and all kinds of crazy stuff.
23:15:59 <dons> hehe. fun fun 
23:16:18 <shapr> I've grabbed a few cottonmouths by the tail and just flipped 'em off into the distance.
23:16:30 <shapr> We had a bunch of 'em in Tennessee.
23:16:39 <dons> a snake?
23:16:50 <ncalexan> Yes, very poisonous.
23:16:59 <shapr> yup
23:17:09 * dcoutts loves the fact that the UK has no dangerous wildlife
23:17:19 <shapr> Wild boars
23:17:47 <dons> no snakes in nz either, i think
23:17:56 <shapr> All the other critters killed 'em off? =)
23:18:22 <dons> i guess the giant crickets had at 'em, and that was that :)
23:18:27 * shapr grins
23:18:42 <ncalexan> I was wondering, would it be possible to decouple deriving clauses and type declarations?  I don't know how much of the representation of types is needed but discarded across module boundaries.
23:19:55 <shapr> You can do that now if you use the Template Haskell deriving code bits.
23:20:12 <dons> i would think it would be very possible to have 'deriving Foo' anywhere, but since you always get the same result, then binding them to the decl site makes sense, doesn't it?
23:20:26 <ncalexan> Not really.
23:21:00 <ncalexan> I often want to pass MonadClasses through transformers, and with O(n^2) interactions, it gets annoying.
23:21:13 <ncalexan> For example, instance (MonadClass m) => MonadClass (StateT s m) where ...
23:21:26 <ncalexan> When that can be derived, it's unclear where it should live.
23:21:36 <dons> hmm. yeah. interesting
23:21:40 <ncalexan> But if it lives in one or the other .hs file, the imports get pretty nasty.
23:21:59 <ncalexan> It really couples your code together.
23:22:25 <ncalexan> So you don't know that decoupling absolutely will not work in GHC?
23:23:24 <dons> I don't know. sounds like a good question for haskell-cafe@ 
23:23:45 <ncalexan> Mmm.
23:24:25 <dcoutts> shapr, oh yes, appart from 99 wild boars :-)
23:31:56 <dons> no wolves roaming the highlands? :(
23:32:24 <dons> snatching babies from the prams of unsuspecting mothers?
23:32:25 <dcoutts> dons, nope, not for a century or two :-(
23:32:48 <dons> :(
23:34:07 <dcoutts> so my cunning ghc conf dir plan is like this:
23:34:15 <dcoutts> 10 line patch to ghc
23:34:43 <dcoutts> it makes ghc and ghc-pkg read package.conf.d/*.conf
23:34:55 <dcoutts> but ghc-pkg still installs into the global file
23:35:28 <dcoutts> in the gentoo stuff we can just drop the file in package.conf.d/ rather than calling ghc-pkg
23:35:54 <dons> I like this cunning plan
23:35:57 <ValarQ> would simplify package handling
23:36:00 <dcoutts> in fact, we already have such a dir of .conf files so that we can re-register packages
23:36:02 <dons> updating a single file is  gross
23:36:20 <dcoutts> so I'd just symlink package.conf.d/ to gentoo/
23:36:29 <dons> as we all know mutable things are evil.
23:36:39 <dcoutts> (since we keep the .conf files in /usr/lib/ghc-${PV}/gentoo/*.conf)
23:36:51 <dons> dcoutts, I think this is a nice idea
23:37:14 <dcoutts> dons, anyway, it's a quick test and minimally invasive for end users
23:37:32 <dcoutts> ghc-pkg should continue to work the same way for normal uses
23:37:55 <dcoutts> and it should allow us to really try this style out and see if it should be changed properly for ghc 6.6
23:38:00 <ValarQ> shouldn't be impossible to get accepted then?
23:38:09 <dons> well, i wonder if maybe a package is just better for all purposes. but yes, just try it out, and see what happens.
23:38:30 <dcoutts> I don't want to re-work all of ghc-pkg yet
23:38:35 <dons> s/"maybe a directory is just better"/
23:38:38 <dcoutts> to install the things into the dir
23:38:49 <dons> yeah fair enough
23:38:56 <dcoutts> I don't want to break stuff :-)
23:38:58 <ValarQ> how does uninstallation/unregistering of modules work today?
23:39:10 <dcoutts> ghc-pkg unregister foo-x.y
23:39:16 <ValarQ> ok
23:39:21 <dcoutts> or under my new scheme just rm the package file
23:39:30 <ValarQ> and the gentoo/foo.conf magically disapears then?
23:39:31 <dcoutts> which is what the package manager does automatically
23:39:54 <dcoutts> because the gentoo/foo.conf belongs to the lib package not to ghc package
23:40:07 <dcoutts> so it'll get isntalled and uninstalled right
23:40:14 <ValarQ> it makes sense when you say it
23:40:56 <ValarQ> i guess we will change our minds when it breaks our systems ;)
23:41:01 <dcoutts> RedHat did a lot of work on a number of packages a few year back to split out their config into dirs of config files
23:41:13 <dcoutts> since it makes it much more robust when using a package manager
23:41:48 <dcoutts> it becomes just files which works by default rather than having to register & unregister things at just the right time
23:41:57 <ValarQ> a lot of stuff works like that
23:41:57 <dcoutts> eg reinstalling ghc is a mighty pain
23:42:06 <dcoutts> you have to re-register all the ghc libs
23:42:09 * ValarQ is thinking of libraries and the ldconfig stuff
23:42:32 <dcoutts> and technically you should be doing that in dep order, which is a bit hard to do when coding in bash shell scriot :-)
23:42:42 <ValarQ> indeed
23:43:03 <dcoutts> with the conf dir aproach that should "Just Work"tm
23:43:27 <dcoutts> without having to do anything spcial at all
23:44:46 <dons> yes, reregistering everything on a reinstall is a pain
23:45:01 <dcoutts> yay, it works!
23:45:09 <ValarQ> whats stopping you from recreating the entire global config now?
23:45:30 <dcoutts> ValarQ, because package.conf gets wiped when ghc is reinstalled
23:45:37 <ValarQ> ow
23:45:46 <ValarQ> i see
23:45:55 <dcoutts> ValarQ, we work around that by saving all the .conf files for each package in a special dir
23:46:06 <dcoutts> and then we reregister them if ghc is reinstalled
23:46:55 <ValarQ> and you simply want to move some of that logic into ghc itself?
23:48:01 <ProfTeggy> Moin
23:48:12 <ValarQ> morning mr Teggy
23:59:23 <dcoutts> ValarQ, well partly, but by using a dir of .conf files we can eliminate much of the logic completely. It doesn't need to be in ghc or anywhere.
