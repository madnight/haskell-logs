00:03:43 <shapr> boegel: nifty!
00:05:44 * sieni ponders, whether reimplementation of i2p in Haskell would be a worthwhile project
00:13:17 <MarcWeber> Which module do I have to import to be able to use concatMapM from Module.Combinators.hs ?
00:13:18 <wilx``> What is i2p?
00:13:43 <sieni> http://www.i2p.net/
00:14:04 <ski> @index concatMapM
00:14:04 <lambdabot> bzzt
00:15:16 <MarcWeber> What does bzzt mean?
00:15:33 <fluxx> summer
00:15:39 <ski> @index foobar
00:15:39 <lambdabot> bzzt
00:15:40 <fluxx> hmh
00:15:50 <fluxx> it must be another word, or does that have two meanings?-)
00:15:51 <ski> it doesn't find it
00:16:00 <MarcWeber> So my checked out library direcory is much more up to date than my ghc?
00:16:13 <fluxx> the device that keeps sound (on wrong answer maybe)
00:16:27 <MarcWeber> wait
00:16:46 <ski> MarcWeber : maybe it's defined in some file with that library ?
00:19:00 <MarcWeber> It's defined in fptools/libraries/monads/Monad/Combinators. so I should use package monad then.. me fool?
00:22:13 <Phyx-> @type diff
00:22:14 <lambdabot> Not in scope: `diff'
00:23:02 <Phyx-> hmmm any fucntions like that in haskell? go get the diff between 2 lists?
00:23:31 <ski> > [1,4,2,7,5] \\ [5,2]
00:23:32 <lambdabot> [1,4,7]
00:23:42 <Phyx-> nice
00:23:44 <Phyx-> thanx
00:23:47 <tromp_> > [0,0] \\ [0]
00:23:48 <lambdabot> [0]
00:24:14 <tromp_> > [0,0,0,0] \\ [0,0]
00:24:15 <lambdabot> [0,0]
00:25:02 <Phyx-> worked like a charm thanx ski :D
00:25:21 <ski> (and tromp_)
00:25:50 <tromp_> it's difference in terms of multisets
00:26:00 <nonpop> > []
00:26:01 <lambdabot> Add a type signature
00:26:09 <Phyx-> and tromp_ :)
00:26:19 <ski> > [[],[1,2]]
00:26:20 <lambdabot> [[],[1,2]]
00:26:45 <Phyx-> tromp_, i just fix a list and then i want to see the diff with the original, so what it "fixed"
00:27:13 <ski> > [1,2,3] \\ [2,3,4]
00:27:14 <lambdabot> [1]
00:27:36 <ski> > [0] \\ [0,0]
00:27:37 <lambdabot> []
00:40:23 <MarcWeber> I have this : do { a<- f1 start; b <- f2 a; return b} How can I shorten this? Is there a lift function?
00:41:02 <tromp_> f1 start >= f2
00:41:51 <roconnor> f1 start >>= f2
00:43:00 <ski> also
00:43:04 <ski> f2 =<< f1 start
00:43:08 <MarcWeber> Oh.. I think I have to investigate some time into >>= again ;-)
00:44:01 <ski> btw, 'do { a<- f1 start; b <- f2 a; return b}' is same as 'do { a<- f1 start; f2 a}' in case you didn't know
00:47:52 <dons> sieni, that lambdabot error is a ghc 6.4 isms. I'ts fixed in 6.4.1
00:48:17 <dons> or, you turn off -Werror in the config.mk file
00:48:59 <Phyx-> @type (, , [], [])
00:49:00 <lambdabot> parse error on input `['
00:49:03 <Phyx-> hmmm
00:49:16 <Phyx-> what's the empty type of that tupple?
00:49:20 <Phyx-> tuple*
00:50:12 <dons> the empty type?
00:50:20 <MarcWeber> empy ()  ( (), () ) ?
00:51:14 <dons> yeah, do you mean a  type with no inhabitants? or something else?
00:51:40 <Phyx-> no idea.. i think i'm lost
00:51:41 <Phyx-> :|
00:52:09 <dons> what are you trying to do?/
00:52:17 <dons> @type ([], [])
00:52:17 <lambdabot> forall a a1. ([a], [a1])
00:52:20 <MarcWeber> When applying the same arguments to many functions (eg. a list of functions) is there a shorter way then     map (\f -> f arg1 arg2) [f1,f2,f3,f4,f5]  if f1..f5 all are of same type?
00:52:55 <MarcWeber> @type ()
00:52:56 <lambdabot> ()
00:53:07 <MarcWeber> @type (a, b)
00:53:07 <lambdabot> Not in scope: `a'
00:53:07 <lambdabot>  
00:53:07 <lambdabot> <interactive>:1:4: Not in scope: `b'
00:53:14 <fluxx> @pl map (\f -> f a b) l
00:53:15 <lambdabot> map (flip ($ a) b) l
00:53:36 <dons> ($ a) is always good for your karma
00:54:40 <fluxx> however good it might be, I'd think twice before writing that :)
00:55:51 <dons> hehe. someone was even suggesting it as a good style yesterday. who was that?
00:57:18 <Phyx-> how do i make from [[a]] [a] ?
00:57:25 <Phyx-> @type zip
00:57:26 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
00:57:29 <MarcWeber> concat
00:57:34 <Phyx-> ahh, ok
00:57:44 <MarcWeber> @type concat
00:57:44 <lambdabot> forall a. [[a]] -> [a]
00:58:34 <EtnaRosso> Cale may you help me to understand the example oin your tutorial about list?
00:58:35 <Phyx-> ok, works
00:58:47 <Phyx-> thanx MarcWeber 
01:01:49 <MarcWeber> Phyx for strings?
01:02:32 <MarcWeber> if ls see also unlines
01:03:04 <MarcWeber> I shouldn't use dvorak and qertz/y in different windows s/ls/so/
01:05:08 <Phyx-> MarcWeber, nah, it worked the first time
01:05:11 <Phyx-> brb
01:08:45 <MarcWeber> @seen Cale
01:08:46 <lambdabot> Cale is in #haskell. Last spoke 5 hours, 23 minutes and 23 seconds ago.
01:09:19 <MarcWeber> @localtime Cale
01:09:20 <lambdabot> Local time for Cale is Thu Mar  2 10:24:00
01:09:43 <ski> heh
01:09:44 <MarcWeber> EtnaRosso I think he might still be sleeping? Just put your question.. we'll try to help you
01:09:51 <ski> EtnaRosso : which example ?
01:10:14 <EtnaRosso> the statement [10,20,30] >>= \x ->[x,x+1] return [10,11,20,21,30,31]. Why?
01:10:23 <EtnaRosso> What is the semantic for >>=?
01:11:03 <ski> to "run" the whole result, "run" the left argument, give result to right argument and "run" that
01:11:15 <ski> where meaning of "run" depends on the monad
01:11:40 <EtnaRosso> yes in this case we have
01:12:01 <EtnaRosso> xs >>= f = concat(map f xs)
01:12:06 <ski> a list-monadic action has the feature that it can have multiple results (also zero results is possible)
01:12:33 <ski> so, think of the right argument here as being an ambiguous function, that gives two results
01:12:36 <EtnaRosso> in the example f is \x->[x,x+1]
01:12:40 <ski> yes
01:12:53 <EtnaRosso> and xs?
01:13:03 <ski> [10,20,30]
01:13:25 <EtnaRosso> good so i think it should apply the function to [10,20,30]
01:13:52 <EtnaRosso> the key is mapping, the map function
01:14:23 <ski> think of '(>>=)' as nondeterministically selecting one element of the list
01:14:55 <ski> first we select 10, and then apply the function to this, there we select first variant, i.e. just return x, i.e. 10
01:14:57 <EtnaRosso> yes but 
01:15:06 <tromp_> >>= replaces each element by a sublist
01:15:08 <ski> then we try to vary every selection, in every possible way
01:15:15 <EtnaRosso> i would have a more "general" talk
01:15:31 <ski> like ?
01:15:41 <EtnaRosso> for a generic monad how does the operator >>= work? 
01:15:50 <nonpop> hmm
01:15:52 <tromp_> any way you like!
01:16:03 <tromp_> as long as you respect yhe type
01:16:11 <ski> and the laws
01:16:29 <ski> <ski> to "run" the whole result, "run" the left argument, give result to right argument and "run" that
01:16:29 <ski> <ski> where meaning of "run" depends on the monad
01:16:32 <EtnaRosso> tromp_ i think that the behaviour is governed by the instance definition
01:16:41 <ski> EtnaRosso : there you have your generic explanation
01:16:42 <tromp_> ah yes,, gotta satisfy the laws too
01:16:55 <EtnaRosso> sky run the left argument
01:17:10 <EtnaRosso> in the our case the left argument is [10,20,30]
01:17:16 <EtnaRosso> How the monad run it?
01:17:17 <ski> yes, run it, and perform it's effects
01:17:22 <ski> depends on the monad :)
01:17:39 <EtnaRosso> the list monad of course, cause [10,20,30] is alist
01:18:48 <ski> in this case, running means trying every element of the list as a value of 'x'
01:19:03 <ski> this is what the 'map' achieves
01:19:11 <EtnaRosso> good!
01:19:40 <ski> then, because 'f' also can have multiple results, we need to flatten these together with the multiple results that 'xs' gave, so we use 'concat'
01:20:21 <chrisbro1n> hi guys
01:21:05 <EtnaRosso> hahahahah
01:21:11 <EtnaRosso> greaattttttttt thanks
01:21:24 <EtnaRosso> hi chrisbro1n 
01:25:35 <chrisbro1n> > ['a'..'z']
01:25:36 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
01:25:39 <chrisbro1n> oooh
01:26:03 <chrisbro1n> > ['a'..'zz']
01:26:03 <lambdabot>  lexical error in string/character literal
01:26:09 <ski> > 'zz'
01:26:09 <lambdabot>  lexical error in string/character literal
01:26:16 <chrisbro1n> doh
01:26:54 <chrisbro1n> > ["aa" .. "zz"]
01:26:55 <lambdabot>  add an instance declaration for (Enum [Char])
01:26:55 <lambdabot>   In an arithmetic sequence: ["aa" .. "zz"]
01:26:55 <lambdabot>   In the definition of `ydq': ydq = ["aa" .. "zz"]
01:27:08 <chrisbro1n> i see
01:27:35 <ski> > [('a','a') .. ('z','z')]
01:27:36 <lambdabot>  add an instance declaration for (Enum (Char, Char))
01:27:36 <lambdabot>   In an arithmetic sequence: [('a', 'a') .. ('z', 'z')]
01:27:36 <lambdabot>   In the definition of `bxh': bxh = [('a', 'a') .. ('z', 'z')]
01:27:52 <ski> (hm, right)
01:28:19 <chrisbro1n> make sense when you think about it actually
01:28:47 <ski> the naive implementation of that could well include "b5" / ('b','5')
01:28:54 <MarcWeber> What is the easiest way of transforming  a function of type  f::(a->b->[c])   into   (a->b->IO [c]) ? (return.f) results in (a->m ( b->[c]) ) ...
01:29:21 <shapr> MarcWeber: I'd partially apply and lift
01:29:38 <ski> 'return .: f' is one possibility
01:29:51 <ski> MarcWeber : where do you use this ?
01:30:41 <MarcWeber> I have to kinds of deps.. one which needs info form the file system. thus it returns IO [deps]. the other depends only on the target name. thus -> [deps].
01:31:03 <MarcWeber> Now I want a function which concats both lists and returns IO [alldeps] .. ;-)
01:31:12 <MarcWeber> So I endet up trying something like this:
01:31:38 <MarcWeber> liftM concat  (mapM (\f -> f r t) [(return.deps), dynDeps])
01:31:56 <MarcWeber> which would take anyone some hours to understand I think ;-)
01:32:32 <chrisbro1n> the problem is getting it out of the monad...
01:32:41 <chrisbro1n> if you have f :: m a
01:32:46 <chrisbro1n> f = return a
01:32:49 <MarcWeber> (lifttM concat.mapM) might be written as concatMapM
01:32:54 <chrisbro1n> let g <- f
01:32:56 <chrisbro1n> g :: a
01:33:15 <chrisbro1n> remove the "let"
01:33:43 <chrisbro1n> oh thats not exactly what you want...
01:33:48 <MarcWeber> chrisbro1n But then it's easier to use do { a<-dyndeps; let b=deps; return dyndeps++deps} is much easier to read ;-)
01:33:57 <chrisbro1n> yes
01:34:09 <ski> liftM2 (++) (return . deps) dynDeps
01:34:11 <ski> is simpler
01:34:32 <ski> liftM (deps ++) dynDeps
01:34:33 <chrisbro1n> i was just trying to explain the bind combinator...
01:34:34 <ski> even simpler
01:35:13 <ski> hrm
01:35:31 <ski> (possibly i misread)
01:35:58 <ski> MarcWeber : @type dynDeps
01:36:02 <MarcWeber> I was really surprised to see that concatMapM is in a Combinators.hs file.. because I never got to the chapters "monadic combinators" of the all about monads tutorial yet
01:36:39 <chrisbro1n> MarcWeber: does do { a<-dyndeps; let b=deps; return dyndeps++deps} solve the problem?
01:36:44 <MarcWeber> dynDeps:: (Rule r) => r -> DepObj -> IO [DepObj]
01:36:50 <MarcWeber> It should
01:37:29 <EtnaRosso> so .. create a monad for generic sets, for example, is a proper thing?
01:40:36 <MarcWeber> ski I also tried to specify both arguments only once.. But it gets to complicated I like your liftM (deps ++) solution.
01:41:39 <chrisbro1n> its elegent certainly
01:43:03 <chrisbro1n> can anyone explain the monomorphism restriction?\
01:44:27 * ski returns
01:45:10 <ski> MarcWeber : so you've gotten 'r' and 't' before this point ?
01:46:48 <ski> MarcWeber : deps :: (Rule r) => r -> DepObj -> [DepObj]   ?
01:50:17 <ski> if 'r' and 't' are not large expressions
01:50:39 <ski> liftM2 (++) (return (deps r t)) (dynDeps r t)
01:50:50 <ski> simplified as
01:51:00 <ski> liftM (deps r t ++) (dynDeps r t)
01:51:05 <ski> would do it, i think
01:51:11 <EtnaRosso> so to buid this set monad i need to create at first a new type Set?
01:51:25 <ski> yes
01:51:41 <ski> and how do you do that, for every possible element type ?
01:57:31 <Phyx-> anyway to count the occurences of an element in a list?
01:58:55 <mauke> length . filter (x ==)
02:00:42 <xerox> length . filter . (==)
02:00:47 <EtnaRosso> sow how can i set up this set type so that {x} is a set with a single element x
02:01:04 <EtnaRosso> ?
02:01:48 <xerox> EtnaRosso: data Container a = Container a
02:01:49 <xerox> ?
02:02:17 <EtnaRosso> no no is just a "sintattic" matter, a bit of sugar
02:02:23 <EtnaRosso> as for list
02:02:37 <xerox> I don't understand
02:03:06 <EtnaRosso> if you write [1,2,3] on the prompt it is typed as list
02:03:25 <xerox> Right.
02:03:39 <EtnaRosso> i wolud like to write {1} and it should be typed as "Set"(new type)
02:03:46 <EtnaRosso> please my english
02:03:51 <xerox> @type Set.fromList ([1] :: [Int])
02:03:52 <lambdabot> Couldn't find qualified module.
02:03:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
02:03:52 <lambdabot> \\)?
02:03:59 <xerox> @type Data.Set.fromList ([1] :: [Int])
02:04:00 <lambdabot> Data.Set.Set Int
02:04:14 <xerox> Hmm let me check a thing.
02:05:04 <EtnaRosso> i'm reading the prelude
02:05:04 <xerox> If you do ':info Set' in GHCi you see that it has a Show instance, but no Read instance.
02:06:50 <EtnaRosso> parse error is { a reserved keyword?
02:08:14 <ski> you can't extend the syntax like that (without changing an implementation)
02:10:32 <gour> @where QuickCheck
02:10:33 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
02:12:34 <gour> @where Cabal
02:12:35 <lambdabot> http://www.haskell.org/cabal
02:16:31 <chrisbro1n> EtnaRosso: { is a reserved symbol in Haskell
02:17:17 <araujo> Hello
02:17:21 * araujo back from univ.
02:17:53 * shapr luvs QuickCheck
02:21:07 <Phyx-> histogram :: Agenda -> String
02:21:07 <Phyx-> histogram a = show "OK"
02:21:11 <Phyx-> why does that bomb?
02:21:33 <Phyx->     No instance for (Show (Agenda -> String))
02:21:33 <Phyx->       arising from use of `print' at Top level
02:22:03 <integral> guess: you're trying "histogram" at your prompt, not "histogram (undefined)"
02:22:11 * shapr grumbles at haskell-mode
02:22:22 * Phyx- slaps himself
02:22:25 <shapr> Haskell-mode doesn't handle '"' correctly.
02:22:38 <Phyx-> integral, thanx.. it's been bout 6 hours straight on the assignment
02:22:38 <Phyx-> hehehe
02:22:48 <Phyx-> my mind is slipping
02:22:49 <integral> ouch, that's a lot of haskell
02:23:34 <Phyx-> gotta get it finished today
02:23:40 <Phyx-> else no party for me tomorow :(
02:23:48 <Phyx-> only have 2 more 2 go
02:26:58 <EtnaRosso> @url
02:26:58 <lambdabot> Maybe you meant: arr pl
02:27:52 <EtnaRosso> ok building my first monad i have a "Misplaced type signature"
02:32:38 <MarcWeber>  Couldn't match `IO' against `(->) [ClockTime]' ?? What does IO mean here? IO () ? and (->) ?
02:33:20 <CosmicRay> cabal/packaging question.  Can I *portably* include .c (or compiled to .o) and .h files in a Haskell package, and expect it to be available in a standard way to Haskell packages that use it?
02:33:44 <dcoutts> CosmicRay, more or less - yes
02:33:51 <ProfTeggy> MarcWeber, (->) is a type constructor, just like IO
02:34:06 <CosmicRay> dcoutts: and does that work with hugs too?
02:34:20 <MarcWeber> ProfTeggy Which one?
02:34:24 <ProfTeggy> (->) t is a partially applied function type constructor
02:34:32 <dcoutts> CosmicRay, not sure about that.
02:34:38 <shapr> hiya CosmicRay 
02:34:41 <CosmicRay> hey shapr
02:34:46 <shapr> How's code?
02:34:53 <MarcWeber> CosmicRay You should be able to do this as you can ask ghc to compile your .c file..
02:34:54 <CosmicRay> finally getting to work on some haskell stuff again
02:35:00 <shapr> I liked your asterisk for business post.
02:35:01 <dcoutts> CosmicRay, btw did I tell you that I've packaged hdbc for gentoo?
02:35:03 <CosmicRay> shapr: thanks
02:35:07 <Phyx-> @type replicate
02:35:08 <lambdabot> forall a. Int -> a -> [a]
02:35:10 <CosmicRay> dcoutts: no, but that's great.
02:35:13 <Phyx-> damnit., int
02:35:18 <Phyx-> @type repeat
02:35:19 <lambdabot> forall a. a -> [a]
02:35:24 <Phyx-> there we go
02:35:25 <CosmicRay> dcoutts: this question actually relates to HDBC
02:35:29 <dcoutts> CosmicRay, we just need to test the hdbc-odbc backend and it'll be unmasked
02:35:37 <CosmicRay> dcoutts: I'm finding that I have some common C memory management code in all the HDBC drivers
02:35:46 <CosmicRay> dcoutts: and thought I may be able to move it into the parent package
02:35:54 <ProfTeggy> MarcWeber, you can write t1 -> t2 or (->) t1 t2, it's the same
02:35:59 <dcoutts> CosmicRay, right
02:36:01 <CosmicRay> dcoutts: sweet.  I hope to get 1.0 released this week.
02:36:10 <dcoutts> CosmicRay, cool
02:36:13 <Phyx-> > take 5 (repeat "*")
02:36:14 <lambdabot> ["*","*","*","*","*"]
02:36:16 <CosmicRay> dcoutts: just need to add features for interrogation of types of tables and colums.
02:36:29 <Phyx-> > concat (take 5 (repeat "*"))
02:36:30 <lambdabot> "*****"
02:36:32 <dcoutts> CosmicRay, is there going to be a hdbc-mysql backend?
02:36:33 <Phyx-> :)
02:36:44 <CosmicRay> dcoutts: I hope so, but I don't know if I'll have time to write it.
02:36:55 <CosmicRay> dcoutts: mysql is going to be annoying because of its lack of transactions.
02:37:06 <dcoutts> CosmicRay, btw I've found that your cabal packaging is just fine - much less hassle that hsql
02:37:09 <CosmicRay> or rather, its lack of transactions *sometimes*
02:37:17 <dcoutts> heh
02:37:30 <MarcWeber> CosmicRay http://www.haskell.org/ghc/docs/6.4-latest/html/Cabal/authors.html#pkg-descr see c-sources :
02:37:34 <musasabi> @seen malcolm
02:37:35 <lambdabot> I haven't seen malcolm.
02:37:41 <Phyx-> hmmm, anywya to count occurences of an element in a list?
02:37:45 <musasabi> Does he irc these days?
02:38:01 <MarcWeber> ProfTeggy: Thanks.. I haven't thought of it this way.. 
02:38:06 <CosmicRay> dcoutts: the kuldgy answer would be to tell MySQL users that "commit and rollback just won't work unless you're using innoDB, so don't even try."
02:38:21 <MarcWeber> Phyx length (filter (=elem) list) 
02:38:40 <dcoutts> CosmicRay, how would you reccomend we test the hdbc-odbc backend ?
02:38:48 <CosmicRay> MarcWeber: Thanks.  That's half the battle, but I also need to get the .h files installed on the system somewhere, so that the packages that depend on these could work well
02:39:05 <CosmicRay> dcoutts: well there are unit tests out there already.  the trick will be to have some odbc data source they can connect to.
02:39:07 <Phyx-> MarcWeber, ok, lemme give it a try
02:39:19 <CosmicRay> dcoutts: are you talking about build-time testing on every gentoo box, or just on your own?
02:39:22 <dcoutts> CosmicRay, yeah, I don't know much about odbc
02:39:37 <dcoutts> CosmicRay, oh, just for our own test before I unmask the package
02:39:49 <dcoutts> not automatically as part of the build
02:40:06 <shapr> @seen nhc98
02:40:07 <CosmicRay> dcoutts: ah.  well I test it against postgresql, since I have that installed for hdbc-postgresql anyway
02:40:07 <lambdabot> I haven't seen nhc98.
02:40:10 <shapr> huh
02:40:13 <shapr> He was here recently.
02:40:15 <MarcWeber> Phyx- Or foldr 0 (\count elem->if elem=yourelem then count+1 else count) list might be faster (?)
02:40:26 <CosmicRay> dcoutts: the postgresql odbc driver includes an example clause you can add to your .odbc.ini or /etc/odbc.ini
02:40:38 <CosmicRay> dcoutts: I don't know how you register an ODBC driver on Gentoo, or if that happens automatically
02:40:39 <dcoutts> CosmicRay, I like to make sure that I've done some little testing beyond checking that it builds ok before unleashing it on the users ;-)
02:41:03 <CosmicRay> dcoutts: but you can then run make test-ghc6 or make test-hugs.  It will connect to the ODBC data source named "hdbctest".
02:41:09 <dcoutts> ok
02:41:11 <CosmicRay> both tests should pass.
02:41:12 <shapr> I've never gotten comfortable with ODBC on unix.
02:41:15 <dcoutts> CosmicRay, which unix odbc impl do you use?
02:41:20 <CosmicRay> dcoutts: unixodbc
02:41:47 <dcoutts> CosmicRay, that's what we've got it using, I just wanted to check because there is another one
02:41:47 <MarcWeber> CosmicRay There are options for extra include directories, too. (I think)
02:41:51 <Phyx-> lemme give that a try also MarcWeber
02:41:53 <Phyx-> thanx
02:42:11 <dcoutts> CosmicRay, do you know of any particular version requirements on the db backends?
02:43:22 <dcoutts> CosmicRay, we've put in >=dev-db/sqlite-3.2, >=dev-db/libpq-7, >=dev-db/unixODBC-2.2
02:43:27 <dcoutts> but it's only a guess
02:43:43 <dcoutts> I don't know if that's too strict or lax
02:44:40 <MarcWeber> CosmicRay Which library do you want to check for/ install whatsoever?
02:49:30 <gour> dcoutts: hi, yesterday you posted about hiDE's & VS Haskell plugin's syntax high. does hIDE uses lex with yi or gtksourceview?
02:49:54 <dcoutts> gour, it uses ghc's lexer with gtksourceview
02:50:12 <dcoutts> it uses gtksourceview but with gtksourceview's syntax highliting turned off
02:50:33 <dcoutts> (gtksourceview provides useful features beyond just syntax highliting)
02:50:35 <gour> dcoutts: thanks. any progress on amd64? (atm, hIDE looks to me as vapourware :-)
02:50:57 <gour> dcoutts: e.g. (besides syntax h.) ?
02:51:35 <dcoutts> gour, well I'm demoing it tomorrow ;-)
02:51:51 <dcoutts> gour, I reckon we can make it build on amd64 if we do a static build
02:52:00 <gour> dcoutts: ok. now i know what is the time ;)
02:53:52 <gour> dcoutts: so, all the best for your presentation!
02:54:13 <Phyx-> anything wrong here?
02:54:15 <Phyx-> histogram a = "theorie: " ++ concat (take x (repeat "*")
02:54:15 <Phyx->              where x = (counts "theorie" a)
02:54:37 <mauke> (( )
02:54:37 <dcoutts> gour, thanks
02:54:43 <Phyx-> ohhh
02:54:44 <Phyx-> right
02:54:53 <Phyx-> bah, i think it's time for a break...
02:55:17 <gour> dcoutts: i hope you'll have some material to update or site afterward
03:00:20 <tibbe> there must be a function that replaces each occurence of a string (in a tring) with another string!
03:00:34 <tibbe> @hoogle String -> String -> String -> String
03:00:35 <lambdabot> Distribution.PreProcess.Unlit.unlit :: String -> String -> String
03:00:35 <lambdabot> Distribution.PreProcess.Unlit.plain :: String -> String -> String
03:00:35 <lambdabot> Graphics.UI.ObjectIO.CommonDef.dumpFatalError :: String -> String ->
03:00:35 <lambdabot> String -> x
03:00:58 <tibbe> @hoogle [a] -> [a] -> [a] -> [a]
03:00:59 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
03:00:59 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
03:03:45 * CosmicRay returns
03:04:26 <CosmicRay> dcoutts: that sounds reasonable.  obviously we need sqlite3, but to be sure I haven't really tested with many older versions of libraries.
03:04:39 <CosmicRay> dcoutts: I think, but I'm not sure, that this needs postgres 8
03:04:47 <dcoutts> CosmicRay, ah ok
03:14:44 <Phyx-> @type show
03:14:45 <lambdabot> forall a. (Show a) => a -> String
03:14:56 <Phyx-> > show (9/5.0)
03:14:57 <lambdabot> "1.8"
03:14:59 <Phyx-> k
03:17:48 <Phyx-> what's new line? i keep getting this
03:17:51 <Phyx-> "theorie: ********80.0%\npraktijk :**"
03:18:09 <Phyx-> > "mooo" ++ "\n" ++ "noooo"
03:18:10 <lambdabot> "mooo\nnoooo"
03:18:15 <Phyx-> > "mooo\n" ++ "\n" ++ "noooo"
03:18:17 <lambdabot> "mooo\n\nnoooo"
03:18:19 <Phyx-> ...
03:18:47 <Phyx-> > "mooo" ++ '\n' ++ "noooo"
03:18:48 <lambdabot> Couldn't match `[a]' against `Char'
03:18:55 <Phyx-> > "mooo" ++ ['\n'] ++ "noooo"
03:18:56 <lambdabot> "mooo\nnoooo"
03:19:02 <Phyx-> hehe
03:19:04 <xerox> > "a" ++ 'b' : "c"
03:19:05 <lambdabot> "abc"
03:19:17 <Phyx-> i get that
03:19:21 <Phyx-> i want new line :|
03:19:28 <xerox> > "a" ++ '\n' : "c"
03:19:29 <lambdabot> "a\nc"
03:20:14 <Phyx-> anyway to tell it to write on another line?
03:20:23 <xerox> putStrLn ?
03:20:35 <tromp_> lambdabot can't do IO
03:20:51 <xerox> I thought he was asking in general
03:21:00 <Phyx-> return type for function has to be String, not IO
03:21:13 <xerox> What do you want?
03:21:33 <Phyx-> well, the teacher gives the function's type
03:21:41 <Phyx-> Agenda -> String
03:21:55 <xerox> ....a String containing two lines interspersed by a newline, or an IO action writing out two lines?
03:21:55 <Phyx-> he said make sure the output matches his
03:22:01 <Phyx-> but he has a newline in his :S
03:22:40 <Phyx-> unless i screw it and make it an IO function anyway
03:23:03 <tromp_> because he showed the string result using IO
03:23:51 <tromp_> so your string output is fine
03:24:12 <Phyx-> k
03:25:09 <Phyx-> anyway to add tabs btw?
03:26:02 <tromp_> \t
03:26:22 <tromp_> '\t'
03:27:17 <Phyx-> PutStrLn with \t in it?
03:28:12 <tromp_> you wanted a String result
03:28:23 <tromp_> so just put tab characters in the String
03:29:01 <Phyx-> i changed it to IO
03:31:43 <Phyx-> hmmm i c
03:31:46 <Phyx-> thanx
03:41:05 <tromp_> yw:)
03:45:20 <Phyx-> question again
03:45:21 <Phyx-> length (filter (not (==[])) a)
03:45:45 <Phyx-> gives an error, i can't do length a since that for some reason also gives errors
03:45:54 <Phyx-> @type not
03:45:55 <lambdabot> Bool -> Bool
03:46:09 <Phyx-> @type (not (==[]))
03:46:10 <lambdabot>   Couldn't match `Bool' against `t -> t1'
03:46:10 <lambdabot>   Expected type: Bool
03:46:14 <Phyx-> hmm
03:46:43 <Phyx-> @type (==[])
03:46:44 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
03:46:53 <Phyx-> @type not (==[])
03:46:53 <lambdabot>   Couldn't match `Bool' against `t -> t1'
03:46:53 <lambdabot>   Expected type: Bool
03:46:56 <Phyx-> ok..
03:48:48 <tromp_> you mean (not . (==[])) ?
03:48:48 <Phyx-> @type  (==[]) `not`
03:48:49 <lambdabot> parse error (possibly incorrect indentation)
03:49:03 <Phyx-> @type (not.(==[]))
03:49:04 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
03:49:06 <Phyx-> :D
03:49:11 * Phyx- hugs lambdabot 
03:49:41 <tromp_> still, you're missing a simpler solution
03:50:41 <Phyx-> which is?
03:51:06 <Cale> hello
03:51:14 <Cale> MarcWeber: looking for me?
03:51:23 <Phyx-> > filter (not.(==[]) [1,2,3,4,4,4]
03:51:23 <lambdabot>  parse error on input `}'
03:51:30 <Phyx-> > filter (not.(==[])) [1,2,3,4,4,4]
03:51:31 <lambdabot>  add an instance declaration for (Num [a])
03:51:31 <lambdabot>   In the list element: 4
03:51:37 <Phyx-> ?
03:51:44 <xerox> > filter (not . null) [[1],[],[2]]
03:51:45 <lambdabot> [[1],[2]]
03:51:50 <Cale> it's trying to interpret 4 as a list, and can't
03:51:58 <Cale> since there's no instance of Num for lists
03:52:01 <Phyx-> ahh, ok
03:52:03 <tromp_> not . null
03:52:17 <Cale> and yeah, null is better than (==[])
03:52:19 <sieni> Phyx-: you can't compare Apples with Oranges ;-)
03:52:20 <Phyx-> thanx :) i'm learning more here then in the damn book
03:52:21 <Phyx-> lol
03:52:25 <Cale> @type null
03:52:26 <lambdabot> forall a. [a] -> Bool
03:52:30 <Cale> @type (==[])
03:52:31 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
03:52:35 <tromp_> and what do you do with the length?
03:52:41 <xerox> www.apples-to-oranges.com :-P
03:52:43 <Cale> (==[]) requires an extra condition
03:52:56 <Phyx-> tromp_, creating a graph
03:53:23 <Phyx-> ....
03:53:34 <tromp_> why does that need number of non-null elements?
03:54:37 <Phyx-> need to know how big the array is, so i can device it in occurences of each element in it
03:54:48 <Phyx-> guess i could sum up the individual elements
03:54:58 <Cale> Phyx-: yeah, I learned most of what I know about Haskell by hanging around here and doing exercises that people wanted help with, and reading papers that got mentioned :)
03:55:11 <Cale> (and later, by reading the mailing lists :)
03:55:42 <Phyx-> #^#%*^%*@^$ damn interpreter
03:55:46 * Phyx- kicks ghci
03:56:16 <tromp_> that makes no sense:(
03:56:18 <Phyx-> shit...
03:56:24 <Phyx-> something screwed up my code
03:56:28 <Phyx-> i dunno where
03:56:34 <Cale> paste it somewhere?
03:56:36 <Cale> lisppaste2: url
03:56:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:57:05 <Phyx-> ohh rofl...
03:57:10 <Phyx-> GVIM was having fun
03:57:30 <Phyx-> it pasted bits everythere, i keep forgetting that ifi highlight text and start typing it won't replace the text
03:57:44 * xerox needs either a bigger desk or a smaller laptop, hmpf...
03:58:50 <Cale> Phyx-: yeah, highlighting will just put the text in the primary clipboard so that you can paste it with the middle mouse button :)
04:00:38 <Phyx-> ok, time to mail myself assignment and go get some food
04:00:40 <Phyx-> i'm starving
04:00:57 <gour> Phyx-: do you know for Pida? (http://pida.vm.bytemark.co.uk/projects/pida/wiki) It uses gvim, has darcs support..
04:01:19 <Phyx-> is there a windows version?
04:01:46 <Phyx-> guess noyt
04:01:48 <Phyx-> not*
04:02:03 <Phyx-> look cool, but i'm on nix 5% of the time only
04:02:17 <gour> Phyx-: i'm not sure whether it (already) runs, but it's python stuff. ask on #pida
04:02:58 <Phyx-> ohh, ok
04:03:56 <Phyx-> ok, thanx guys, later
04:03:59 <Cale> Screenshots of IDEs always look like spaceship cockpits. Can't people design user interfaces which are simple?
04:04:01 <Phyx-> gonna grab some foood :D
04:04:12 <Phyx-> Cale, my GUI's are worse
04:04:21 <Cale> hehe
04:04:23 <Phyx-> lol, i use sfx in em, pure gdi
04:04:40 <Cale> Win32 GDI?
04:04:41 <Phyx-> actually, gdi+
04:04:46 <Phyx-> yeah
04:05:01 <Cale> I remember the Win32 GDI being a nightmare to use.
04:05:17 <Phyx-> i think it's very easy
04:05:35 <Phyx-> well, later
04:05:50 <Cale> I haven't seen GDI+, but the GDI was very prone to errors.
04:07:09 <gour> Cale: you can simplify pida's look a lot
04:15:54 <gour> @where hIDE
04:15:54 <lambdabot> http://haskell.org/haskellwiki/HIDE
04:22:34 <sieni> > product [(1::Int)..34]
04:22:35 <lambdabot> 0
04:22:47 <sieni> > product [(1::Int)..33]
04:22:48 <lambdabot> -2147483648
04:22:52 <sieni> yea ^_^
04:23:21 <xerox> Unbound integers, your potential, our passion.
04:23:54 <sieni> -> sauna
04:24:18 * xerox melts for the envy
04:32:04 <dcoutts> xerox, I'm showing off your code tomorrow morning :-)
04:32:49 <vincenz> what code?
04:34:23 <dcoutts> vincenz, cairo & some cairo apps
04:35:19 * xerox hugs dcoutts 
04:35:28 <vincenz> ah :)
04:35:38 <xerox> dcoutts: we should really get around writing THAT api.
04:35:45 <dcoutts> yes
04:35:50 <xerox> I loved your paper idea.
04:35:51 <Cale> which api?
04:35:55 <dcoutts> because it will rock
04:36:06 <dcoutts> Cale, you can help if you like
04:36:09 <vincenz> what api?
04:36:18 <xerox> Gotta go to dinner, bbl.
04:37:41 <dcoutts> xerox, keeping people guessing eh? :-)
04:38:01 <Cale> hehe
04:38:50 <dcoutts> Cale, bascially we were thinking about a pure cairo api
04:39:06 <vincenz> dcoutts: in what way would it be different?
04:39:07 <dcoutts> ie all (but one) functions would be pure
04:39:17 <vincenz> dcoutts: you mean nonmonadic?
04:39:23 <dcoutts> vincenz, yes, it'd be easier to use
04:39:38 <dcoutts> or rather it'd be harder to make mistakes
04:39:38 <vincenz> dcoutts: but stuff like "fill" and "stroke"...
04:39:44 <dcoutts> yep
04:39:44 <vincenz> they require to know the current stack of operations
04:39:51 <dcoutts> we have a plan, fear not
04:39:56 <vincenz> :)
04:40:18 <Cale> an algebraic description language for drawings with a cairo interpreter? :)
04:41:02 <dcoutts> Cale, something like that but sticking very close to the cairo api
04:41:11 <SyntaxNinja> good morning
04:41:11 <dcoutts> there should be near-zero overhead
04:41:15 <Cale> cool
04:41:46 <dcoutts> SyntaxNinja, hia, sorry I've been very busy recently :-(
04:41:57 <vincenz> dcoutts: btw...how heavy is it to rerender all your prims every time you move something
04:42:15 <dcoutts> vincenz, it depends how much you're drawing
04:42:29 <dcoutts> obviously you'd want to minimise the redraw to get better performance
04:42:36 <vincenz> dcoutts: well let's assume I want to make a graph editor... that means every time I add or move a node, I'd have to redraw everythiing
04:42:37 <dcoutts> SyntaxNinja, eventally I'll get a weekend to finnish off cabal-etup
04:42:43 <vincenz> dcoutts: cause there's no way of "undrawing" soomething
04:42:49 <dcoutts> vincenz, that might get too slow
04:42:55 <vincenz> dcoutts: how would you tackle this?
04:43:00 <SyntaxNinja> dcoutts: np.
04:43:04 <SyntaxNinja> dons: what's yr status, anyway?
04:43:15 <SyntaxNinja> dcoutts: sorry I haven't applied that cabal patch. will do so asap.
04:43:29 <dcoutts> vincenz, can you make a data strucure that allows you to map from exposed screen rectangles to bits of the grap that need too be redrawn?
04:43:44 <dcoutts> SyntaxNinja, which one was that? I forget.
04:44:08 <dcoutts> SyntaxNinja, it's not high pripority for us, we've already got the patch applied in gentoo.
04:44:21 <vincenz> dcoutts: not really what if you have an edge between two far nodes?
04:44:36 <dcoutts> SyntaxNinja, we're going to use Cabal-1.1.3 in our current round of marking packages stable
04:44:50 <dcoutts> vincenz, lines are their own visual elements
04:45:06 <vincenz> dcoutts: well how do you undraw them?
04:45:35 <vincenz> what's the heavy part "data -> Render()" or "Render() -> Screen"
04:46:09 <dcoutts> vincenz, could be either depending on what you're doing, but usually the latter
04:46:40 <dcoutts> you don't undraw them, the windowing system tells you which rectanges of the screen need redrawign and you need to figure out which elements intesect with that
04:46:46 <vincenz> which means it's best to draw the new stuff only, aka, undraw certain things
04:47:05 <vincenz> dcoutts: yeah but with edges going accross the screen...eventually it'll end up being everything
04:47:09 <dcoutts> vincenz, the old stuff remains because it's clipped to the exposed region
04:47:27 <dcoutts> the drawing is cliped to the exposed region
04:47:32 <vincenz> yep
04:47:49 <dcoutts> so you can just draw normally and not worry about drawing outside the exposed area
04:48:17 <vincenz> aka, draw everythiing
04:48:19 <dcoutts> it's only an optiisation to minimise the amout that is drawn outside
04:48:23 <vincenz> seeing how data -> render () ain't that bad
04:48:56 <dcoutts> eg if you have a line that intersects the exposed region then you just draw it
04:49:06 <vincenz> right
04:49:08 <dcoutts> it'll get clipped to the exposed region
04:49:08 <vincenz> but what I mean is
04:49:12 <vincenz> if you move a node, it moves the line
04:49:15 <dcoutts> yep
04:49:15 <vincenz> which means a lot of redrawed places
04:49:18 <dcoutts> yep
04:49:25 <vincenz> would you then reclip the bounding box of that line
04:49:29 <vincenz> or make many smaller boxes along that line
04:49:46 <dcoutts> for long lines you might be able to do something more clever than just a bounding box
04:49:59 <SyntaxNinja> dcoutts: I think I'm going to go ahead and make a cabal release w/o cabal-install or cabal-get. 
04:50:06 <dcoutts> since the bounding box will cover a lot of things that do not need redrawing
04:50:10 <SyntaxNinja> but it'll be another "RC", not 1.1.2
04:50:12 <dcoutts> SyntaxNinja, ok
04:50:13 <SyntaxNinja> er, not 1.2
04:50:16 <dcoutts> right
04:50:50 <dcoutts> SyntaxNinja, one bug I noticed I think was that --with-compiler=ghc has stopped working
04:51:01 <dcoutts> it seems to want --with-compiler=/usr/bin/ghc
04:51:26 <dcoutts> it now checks if the thing exists rather than just trying to run it
04:51:35 <dcoutts> so if it's not a full path then it fails
04:52:18 <dcoutts> but --with-compiler=ghc has the advantage that the register script that cabal generates will work on another system where ghc is on the path but in a differnt location
04:52:40 <dcoutts> it's not very important I guess
04:53:05 <dcoutts> I only noticed it because it broke our cabal eclass but it's easily fixed
04:54:15 <SyntaxNinja> dcoutts: OK.  file a bug report if you want... I guess I feel like that's the most expected behavior, but we can tweak it to do a different kind of check if it's not  apath
05:18:00 <sieni> > map (curry fst 1) [1..10]
05:18:01 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:18:25 <vincenz> > take 10 $ repeat 1
05:18:26 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:19:18 <Lemmih> > replicate 10 1
05:19:19 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:20:10 <jethr0_> take 10 $ [1,1..]
05:20:14 <jethr0_> > take 10 $ [1,1..]
05:20:15 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:21:10 <jethr0_> > zipWith div [1..10] [1..]
05:21:11 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:23:33 <Lemmih> > foldr ((:).const 1) [] [1..10]
05:23:34 <lambdabot> [1,1,1,1,1,1,1,1,1,1]
05:25:09 <int-e> @type head . sequence . map return 
05:25:10 <lambdabot> forall a. [a] -> [a]
05:25:24 <Excedrin> what's const useful for?
05:26:00 <mauke> defining >>
05:26:57 <mauke> or anyToken = tokenIf "any token" (const True)
05:27:17 <int-e> well, for using higher order functions mostly. map (const 1) is actually a good example.
05:31:17 <Lemmih> > let len = sum . map (const 1) in len "Hello, world!"
05:31:18 <lambdabot> 13
05:33:46 <Excedrin> ah, it's a short version of (\x -> 1)
05:37:36 <sieni> > sum $ map (`mod` 2) [1,3,4,56,7,3,5,4,6,6,2,4,6,7]
05:37:37 <lambdabot> 6
05:39:25 <xerox> > sum $ map (fromEnum . odd) [1,3,4,56,7,3,5,4,6,6,2,4,6,7]
05:39:26 <lambdabot> 6
05:44:08 <mauke> > fromEnum True
05:44:09 <lambdabot> 1
05:45:23 <CosmicRay> Say I have:
05:45:28 <CosmicRay> import qualified Database.HDBC.ColTypes as ColTypes
05:45:33 <CosmicRay> if I add this to my export list:
05:45:38 <CosmicRay>      module ColTypes
05:45:55 <CosmicRay> then will a module importing this module be able to reference the contents of ColTypes as, say, ColTypes.foo?
05:46:07 <CosmicRay> ghc warns that my import of ColTypes doesn't serve any purpose
05:46:11 <CosmicRay> and haddock doesn't see it at all
05:48:55 <CosmicRay> in other words, what effect does "qualified" on import have when the module is re-exported?
05:49:02 <Excedrin> > length (filter odd [1,3,4,56,7,3,5,4,6,6,2,4,6,7])
05:49:03 <lambdabot> 6
05:49:09 <Excedrin> is that worse than the sum $ map versions?
05:50:07 <Excedrin> I guess I could have used $, but I'm curious why not use length and filter instead
05:52:21 <Lemmih> Excedrin: xerox was just playing around.
05:53:14 <Excedrin> ok
05:55:32 <vincenz> @type fromEnum . odd
05:55:33 <lambdabot> forall a. (Integral a) => a -> Int
05:56:43 <xerox> It would be cool to have a |bool :: Bool -> a -> a -> a|. (The name was random.)
05:56:57 <integral> @type if'
05:56:58 <lambdabot> Not in scope: `if''
05:57:09 <xerox> Yeah :-\
05:57:11 <integral> @index if'
05:57:12 <lambdabot> bzzt
05:57:36 <xerox> On the same line of |maybe| and |either|, you know.
05:57:37 <integral> I guess we're just meant to use: case x of { False -> y; True -> z } but that's so ugly
05:59:48 <Lemmih> or 'if x then z else y'?
06:01:15 <palomer> ack, I'm getting carpel tunnel!
06:12:30 <Excedrin> what's '<-' called?
06:12:40 <xerox> ...arrow?
06:13:03 <xerox> It's a binding operator, too.
06:13:30 <vincenz> Excedrin: LEFTANGLE DASH
06:13:44 <xerox> ...
06:13:51 <vincenz> :D
06:13:51 <mauke> LESS-THAN SIGN HYPHEN-MINUS
06:14:10 <xerox> Unicode madness!
06:14:12 <vincenz> leftangle sounds better
06:15:05 <Excedrin> if you were speaking about "do foo <- action", what would you say?
06:16:05 <int-e> left arrow
06:16:20 <int-e> I'd call it. I'm not sure how I'd pronounce it.
06:16:35 <gzl> maybe 'from'?
06:16:55 <gzl> or some variant of that.
06:17:01 <Excedrin> 'is bound to' ?
06:17:11 <ski> or 'gets'
06:17:16 <ski> palomer : pong
06:17:55 <palomer> ping
06:18:42 <ski> you wondered something about 'normalize' and 'getKind' ?
06:18:58 <palomer> yeah, I had been using runST
06:19:09 <palomer> and getting the "cannot instantiate blah" error
06:19:55 <palomer> because  I would be doing things like showSType x = runST (do {x' <- normalize x; return $ showNormalized x'})
06:20:18 <ski> (i didn't get most of your problem, since it disconnected again shortly after it connected)
06:20:34 <palomer> normalize:: SType -> ST s (SType)
06:20:43 <ski> type of 'showNormalized' ?
06:20:56 <palomer> SType s -> String
06:21:27 <palomer> normalize :: SType s -> ST s (SType s)
06:22:05 <ski> ah, that won't work
06:22:18 <ski> did you sort it out ?
06:22:21 <palomer> which is a total bummer
06:22:30 <palomer> well, I came to the conclusion that it can't be done
06:22:38 <palomer> which sucks:(
06:23:19 <ski> you can convert it to a string and pass out that string out of the top 'runST' call, and then print it
06:23:48 <palomer> ski: hmm?
06:24:23 <ski> but, since 'x' here has type 'SType s' this means that this already refers to the internal state of the ST-thread, so you can only access it in the same thread, not another one
06:25:00 <palomer> thread?
06:25:17 <ski> not 'thread' as in concurrency
06:25:39 <ski> just as in a sequencing of the internal state in the ST-monad
06:26:20 <palomer> what's a thread then?
06:27:27 <ski> using the ST monad threads an implicit state around
06:27:50 <ski> it is in this state that 'newSTRef' allocates cells
06:27:50 <Cale> ST-thread is a little redundant :)
06:27:54 <ski> hi esap
06:28:05 <ski> Cale : hm, yes you're right :)
06:28:19 <palomer> ok, and what's this about another thread?
06:28:50 <ski> each use of 'runST' initializes another state, passes it to the ST-action to be run, and afterwards destoys the final state
06:29:31 <palomer> ah, so it creates a new thread
06:29:34 <ski> yes
06:29:45 <palomer> which cannot access anything in the old thread
06:29:57 <ski> this is one reason why references into one state can't be used in another state thread
06:29:59 <ski> yes
06:30:06 <Cale> the thread is purely conceptual and may or may not have anything to do with the runtime system :)
06:30:13 <ski> (indeed)
06:30:46 <palomer> ok, this is a kind of nice way to see things
06:31:02 <palomer> so yeah, these kinds of limitations stop me from using the standard library
06:31:40 <ski> (actions within a single thread is fully sequentialized, but separate threads are not sequentialized with respect to each other .. so that's another reason for not allowing cross-thread accessing, since it would be nondeterminate which intermediate state an access from another thread used)
06:32:11 <palomer> there should be a monadic standard library
06:32:20 <ski> m, yes
06:32:48 <palomer> typeclass MShowable x m where show :: a -> m String
06:33:02 <palomer> s/show/mshow
06:33:24 <palomer> it sucks we have to duplicate the code though
06:33:43 <ski> can't you have something like
06:34:04 <ski> freezeSType :: SType s -> ST s FrozenSType
06:34:12 <ski> instance Show FrozenSType
06:34:13 <ski> ?
06:34:41 <palomer> yeah
06:34:45 <ski> where the 'freezeSType' dereferences all the references, in the current state
06:34:55 <palomer> I have a freezeSType
06:35:07 <palomer> I guess that's the best way
06:36:50 <ski> if you use
06:36:57 <ski> @oldwiki IndirectComposite
06:36:57 <lambdabot> http://www.haskell.org/hawiki/IndirectComposite
06:36:59 <mauke> let's say I want to write a C tokenizer using something like Parsec
06:37:16 <mauke> what's the best way to deal with preprocessor directives (especially #include)?
06:37:24 <ski> then you could even have use a single type for the basic forms of it
06:37:26 <xerox> Doesn't it have a C-lexer built in in the defaults?
06:37:28 <Cale> mauke: remove them beforehand
06:37:39 <mauke> Cale: huh?
06:37:49 <Cale> mauke: write an equivalent to cpp
06:37:58 <Cale> and apply that in order to remove them
06:38:08 <Cale> and then you're left with something which is just C
06:38:11 <mauke> er, that's what I'm trying to do
06:38:17 <mauke> cpp is C's tokenizer
06:38:43 <Cale> oh, I didn't know it did that too
06:39:05 <mauke> macro expansion is token replacement
06:39:19 <Cale> I suppose it is
06:39:30 <ski> palomer : so you could have newtype FrozenSType = FST (STRef s (SType' FrozenSType))
06:39:33 <mauke> xerox: I can't find it in the docs
06:39:43 <palomer> IndirectComposite <--this looks awesome
06:39:59 <palomer> in fact, I can use GADTs here
06:40:13 <Cale> I always thought of it as more of a textual expansion, but yeah, it does appear to occur at the token level.
06:40:50 <Cale> okay, then what I really mean is that you will probably want to handle #includes as a separate pass
06:40:56 <palomer> ski: I don't quite understand what IndirectComposite does
06:41:13 <Cale> since IO isn't accessible from inside a parsec parser
06:41:20 <mauke> my current program simply runs the token parsers in a loop, which works quite well
06:41:31 <Cale> It can be lazy, but structure it as you would a separate pass
06:41:33 <mauke> the problem is that there's a token type that only occurs in a #include directive
06:41:39 <ski> palomer : it makes the recursion indirect, similarly to making a non-direct-recursive version of a function, for calling with 'fix'
06:41:39 <Cale> hmm
06:41:45 <mauke> #include </*not a comment>
06:41:53 <Cale> ah, haha
06:41:57 <palomer> ski: and what's the advantage of making it non-direct-recursive?
06:42:13 <palomer> why not simply use http://www.haskell.org/hawiki/DecoratingStructures
06:42:40 <ski> palomer : you can vary the indirection, and use many variants *at*same*time*
06:42:51 <palomer> ski: for example?
06:43:06 <ski> palomer : DecoratingStructures only allow you to vary what you decorate the nodes with
06:43:12 <Cale> What is the syntax actually like for #includes? Do they always have to be on their own line? (I don't ever recall seeing them written any other way)
06:43:16 <ski> palomer : here you want to vary the indirection
06:43:59 <Cale> hmm...
06:44:02 <mauke> Cale: beginning-of-line whitespace "#" whitespace "include" whitespace (system-header | local-header) whitespace newline
06:44:03 <ski> palomer : e.g. with DecoratingStructures, you could have a function  typecheck :: AST () -> M (AST Type)
06:44:12 <mauke> whitespace includes comments
06:44:31 <Cale> is it safe to expand all includes before doing other processing, or is that allowed to get you into an infinite loop?
06:44:37 <ski> palomer : there the initial decoration on each node is nothing special, and the final decoration is the type of that subtree of the AST
06:44:53 <palomer> ski: sure
06:45:00 <mauke> my only problem is actually recognizing them
06:45:00 <palomer> I actually do something like this
06:45:17 <mauke> Cale: you need to do things in order, consider #if 0 .. #endif
06:45:28 <Cale> mauke: yeah
06:45:48 <Cale> hmm
06:46:02 <palomer> ski: so how is IndirectComposite any better?
06:46:27 <ski> palomer : it allows varying the indirection
06:46:48 <palomer> can you show a function which may need this?
06:47:28 <ski> palomer : you can of course put 'STRef s's into your datatype, but the you *fix* this into your type, so if you want to express FrozenSType, you need to duplicate the constructors for all the forms of types
06:48:05 <ski> palomer : if you don't want that duplication, then you *don't* put the 'STRef s' indirection into the main datatype, instead defining something like
06:48:45 <ski> data SType' stype = Fun stype stype
06:48:51 <palomer> my types are applications, variables or literals
06:49:06 <ski>                    | App stype stype
06:49:09 <ski>                    | ...
06:49:10 <ski> ok
06:49:18 <ski> this can prolly be adapted
06:49:20 <ski> anyway
06:49:24 <ski> then you define
06:49:39 <Cale> mauke: well, you obviously at least need a special case in there to handle the #include somewhere relatively high up in your parser
06:49:50 <ski> newtype SType s = ST (STRef s (SType' (SType s)))
06:50:02 <Cale> mauke: I'm sure that this has been written before in Haskell
06:50:06 <ski> this adds 'STRef s' indirections at every node
06:50:11 <ski> and you also add
06:50:34 <ski> newtype FrozenSType = FST (SType' FrozenSType)
06:50:57 <ski> this is with no indirections
06:51:08 <palomer> sure
06:51:09 <ski> so you define
06:51:24 <ski> freezeSType :: SType s -> ST s FrozenSType
06:51:36 <ski> freezeSType (ST ref) = do
06:51:52 <ski>   stype' <- readSTRef ref
06:51:57 <ski>   case stype' of
06:52:09 <ski>     App st0 st1 -> do
06:52:19 <palomer> but your SType' must contain references
06:52:25 <ski>       fst0 <- freezeSType st0
06:52:31 <ski>       fst1 <- freezeSType st1
06:52:48 <ski>       return (FST (App fst0 fst1))
06:52:51 <ski>     ...
06:52:56 <palomer> yeah, it's the same as my normalize function
06:53:03 <ski> aha :)
06:53:39 <palomer> ok, I see how it works
06:54:04 <ski> (if you have cyclic structures this simple scheme may cause looping, though, so in that case, it becomes somewhat harder)
06:54:23 <ski> so, you purge the references into the current state by reading all the references
06:54:39 <ski> then the resulting tree can be exported from the state thread with no problem
06:55:53 <palomer> http://www.rafb.net/paste/results/zwIDOX78.html <---here's an alternative
06:56:32 <palomer> ski: you can't purge the references from your datatype, though, because SType' will contain references
06:56:44 <ski> no, not necessarily
06:57:02 <ski> values of type 'SType s' will contain references
06:57:13 <ski> values of type 'FrozenSType' won't
06:57:38 <ski> the 'STRef s' part is only present in the definition of 'SType s'
06:57:55 <ski> not of the core 'SType' stype' one
06:58:12 <palomer> oh, wait, your SType has a reference at every level
06:58:18 <ski> right :)
06:58:54 <ski> and 'freezeSType' initially removes the top reference for each node, before caseing
06:59:05 <palomer> so SType corresponds to my SType variables
06:59:41 <palomer> interesting...
06:59:45 <ski> yes
07:00:23 <palomer> hmm
07:00:42 <palomer> did you check out my GADT alternative?
07:00:44 <Phyx-> @type sum
07:00:45 <lambdabot> forall a. (Num a) => [a] -> a
07:01:18 <palomer> actually, my GADT alternative doesn't really keep any invariants
07:01:24 <ski> palomer : the rafb paste ?
07:01:28 <palomer> ski: yeah
07:01:55 <ski> hmm
07:02:04 <palomer> ski: nonetheless, SType' will contain a Var String constructor
07:02:10 <palomer> which is meaningless for SType
07:02:26 <ski> do you use 'STRef s' in other places than for indirection in your current 'SType s' ?
07:02:41 <palomer> nope
07:03:00 <ski> i seem to recall you also using them for variable identies
07:03:12 <ski> good evening, Philippa
07:03:18 <palomer> identity?
07:03:21 <palomer> I've changed that
07:03:24 <ski> ok
07:03:28 <palomer> I'm using STO instead of ST
07:03:46 <ski> which is ?
07:03:57 <palomer> so I'm using STOrefs , which is an (Int,STRef)
07:04:01 <palomer> so the Int keeps the identity
07:04:06 <ski> ok
07:04:10 <palomer> actually, (Integer,STref)
07:04:28 <ski> what type does your 'Var' constructor currently have ?
07:04:50 <palomer> newtype SType s = ST (STRef s (Maybe (SType' (SType s)))) <---did you mean this?
07:05:09 <palomer> STyvar (Tyref s) 
07:05:17 <palomer> newtype Tyref s = Tyref (STIRef s (Maybe (MonoSType s)),Kind) deriving Eq
07:05:22 <ski> i meant whatever type your 'Var' constructor currently have
07:05:41 <palomer> STyvar==Var
07:06:06 <palomer> ski: I think you're missing a Maybe in your SType declaration
07:06:09 <ski> 'STIRef' ?
07:06:21 <palomer> yeah, I renamedSTOref to STIRef
07:06:28 * ski had no 'Maybe' in his type declarations
07:06:45 <palomer> oh, right, but you had vars
07:06:53 <palomer> which, really, don't make any sense in ST
07:07:00 <ski> hm ?
07:07:20 <palomer> ski: if I wanted to create a type, say alpha
07:07:22 <palomer> I would have to write
07:08:16 <palomer> do{x <- newSTyref (Var "alpha"); return ST x}
07:08:33 <palomer> no, not even
07:08:45 <palomer> I don't see how you could create anything with your SType
07:09:18 <palomer> oh, right, that works
07:09:41 <palomer> now, Var "alpha" doesn't do anything
07:09:53 <Phyx-> http://www.rafb.net/paste/results/QfDpAk43.html
07:10:00 <Phyx-> can anyone take a look at that?
07:10:25 <Phyx-> oops
07:10:27 <Phyx-> no else
07:10:53 <ski> palomer : i think possibly you need to adapt IndirectComposite slightly, since it seems to me you indeed use 'STRef s's for more that just recursive node-indirection (namely in variables)
07:11:18 <palomer> right, my variables are strefs which may or may not indirect
07:11:28 <palomer> if none of them indirect, the type is considered normalized
07:11:32 <ski> yes, and you need to remove those too, when freezing
07:12:11 <ski> (you need to purge all 'STRef s's to freeze)
07:12:33 <ski> so, the reference in variables hold the type of the variable, yes ?
07:12:49 <palomer> ski: you mean kind?
07:13:09 <palomer> the variables are (kind,stiref)
07:13:24 <ski> what does the 'STIRef s' hold ?
07:13:41 <palomer> (Integer,STref s)
07:13:52 <ski> and that 'STRef s' holds ?
07:14:04 <palomer> STRef s (SType s)
07:14:12 <ski> right
07:14:19 <ski> there's the 'SType s' i mentioned
07:14:43 <palomer> where?
07:14:52 <ski> STRef s (SType s)
07:15:06 <palomer> yeah
07:15:07 <ski>          ^^^^^^^
07:15:25 <palomer> I mena, where did you mention it?
07:15:30 <palomer> s/mena/mean
07:15:40 <Phyx-> WTF?
07:15:47 <ski> <ski> palomer : i think possibly you need to adapt IndirectComposite slightly, since it seems to me you indeed use 'STRef s's for more that just recursive node-indirection (namely in variables)
07:15:48 <Phyx-> somehow tab characters are appearing in my code
07:16:22 <ski> Phyx- : missing 'else' branch
07:16:30 <palomer> so how would I adapt it?
07:16:36 <ski> depends
07:16:50 <ski> this 'SType s' part in variables ..
07:17:05 <ski> .. does it contain current instantiation for type variables ?
07:17:26 <palomer> STyvars may be instantiated, sure
07:17:44 <SyntaxNinja> is there a good way to get ghc to just relink rather than rebuild the entire thing?
07:17:46 <ski> so, this is what the variable later has been bound to, then ?
07:17:49 <SyntaxNinja> I mean, for the ghc build itself.
07:18:03 <palomer> later?
07:18:25 <Phyx-> ski: 22:24:50 < Phyx-> oops
07:18:25 <Phyx-> 22:24:51 < Phyx-> no else
07:18:37 <ski> first you create type variables .. then later they possibly get instantiated during type inference
07:18:45 <palomer> ski: exactly
07:18:46 <Phyx-> (329,18): Syntax error: 
07:18:46 <Phyx->     unexpected ']'
07:18:48 <ski> (Phyx- : sorry, missed that)
07:18:50 <Phyx-> bah
07:18:57 <ski> palomer : ok
07:19:11 <Phyx-> i dunno what to fill i for that one
07:19:17 <ski> palomer : so, i assume you don't want to omit this part when freezing
07:19:58 <ski> palomer : but maybe you want to omit the kind part, and make it look like the variable never existed, if it was instantiated to anything
07:21:17 <palomer> sure
07:21:27 <palomer> so this is where Var comes in
07:21:31 <ski> yes
07:21:46 <palomer> however, the only function to ever need Var will be show
07:21:49 <ski> so you possibly have to handle the 'Var' case specially in 'freezeSType'
07:22:02 <palomer> all the others won't know what to do with Var
07:22:04 <SyntaxNinja> Igloo: do you know if I can just get a ghc source tree to re-link, or do I have to rebuild the whole thing?
07:22:16 <palomer> so I'll have non exhaustive searches everywhere
07:22:52 <ski> hm ?
07:23:48 <ski> anyway, if you always remove the 'Var' constructor, so it doesn't appear in the frozen type, then there should be no problem
07:23:54 <palomer> for example, I have a function that, given a type, returns the return type of that type
07:24:06 <ski> otherwise, i think the type have to be slightly adapted
07:24:11 <palomer> for example, returnType (a -> b ) == b <--pseudo code
07:24:28 <palomer> when I say Var, I mean your Var String
07:24:45 <ski> (into something that could possibly be called, IndirectingStructures, or something)
07:25:02 <ski> mhm
07:25:19 <palomer> SType = ... | Var String
07:25:28 <palomer> err
07:25:33 <palomer> SType ' = ... | Var String
07:25:39 <palomer> ack
07:25:56 <palomer> SType' a = App a a | ... | Var String
07:26:01 <ski> not '| Var String (Kind,STIRef s)' ?
07:26:08 <tuomov> hmm.. should one use hfuse or fuse_example?
07:27:09 <palomer> newtype SType s = SType s (STIref s (SType' (SType s)))
07:27:26 <Igloo> SyntaxNinja: If you want to build the GHC executable you'll have to build it from source
07:27:26 <palomer> or newtype SType s = SType s (Kind,STIref s (SType' (SType s)))
07:27:41 <palomer> whichever
07:27:48 <palomer> this is what you're suggesting, right?
07:30:00 <ski> do you want to annotate each node with a kind ?
07:30:29 * ski has not suggested that, dunno if we want that
07:30:51 <palomer> err, shouldn't be a problem
07:30:58 <palomer> you can't put it in Var
07:31:04 <ski> why ?
07:31:12 <ski> didn't you before ?
07:31:13 <palomer> because I'll be using SType' for parsing
07:31:25 <palomer> ski: right now I have 2 datatypes
07:31:30 <palomer> Type and SType
07:31:39 <palomer> Type corresponds to your FrozenSType
07:31:39 <ski> ok
07:31:43 <palomer> and is used for parsing and printing
07:31:44 <ski> ok
07:32:03 <Buggaboo> ski: hey there, are you familiar with very basic search algorithms?
07:33:06 <ski> Buggaboo : somewhat
07:33:49 <ski> palomer : could you paste your original types (i.e. before i started suggesting changes to them :) somewhere ?
07:34:40 <palomer> http://www.rafb.net/paste/results/HGHQwc61.html
07:37:55 <Buggaboo> ski: what is the difference (in memory and time costs) in checking for a target state/node during generation or expansion of the nodes?
07:40:31 <palomer> http://www.rafb.net/paste/results/3ZeDsb16.html
07:40:31 <SyntaxNinja> Igloo: right, I have a source tree, some libs have changed, and I want to juts relink the tree.
07:41:53 <ski> palomer : hm, so you only have 'STRef s's in the 'Var' constructor then ? (in that case i must have missunderstood a bit)
07:42:32 <palomer> yup
07:43:33 <Cale> Buggaboo: could you explain what generation and expansion are? I think I know what generation is anyway :)
07:44:00 <Igloo> SyntaxNinja: make shouldn't do /too/ much redundant work
07:44:14 <Cale> Buggaboo: I have some experience writing search algorithms (esp. in a monadic framework), but I might not use common terminology
07:44:16 <ski> (was just about to ask about 'Tyref s')
07:44:44 <palomer> this is the best design I've come up with so far 
07:44:48 <palomer> and I've tried many, many designs
07:45:03 <Buggaboo> Cale: ah, okay, dynamic dfs/bfs, they don't have a complete input of the search space.
07:45:31 <ski> palomer : right, so you only want to parameterize the indirection in the 'Var' constructor
07:45:34 <Buggaboo> so the tree has to be generated.
07:45:42 <Cale> Buggaboo: okay, but you definitely do that lazily
07:45:46 <Cale> right?
07:45:48 <ski> palomer : i somehow thought you had indirections in every other node, too
07:46:00 <Buggaboo> Cale: yes very lazily.
07:46:04 <palomer> no no, only variables
07:46:34 <Cale> Buggaboo: you want to make sure that you only look at the smallest part of that tree needed to continue in the algorithm
07:46:36 <ski> (palomer : must be because i'm a bit tired, then :)
07:46:49 <Cale> you can even do away with the tree data structure itself, and use the list monad
07:46:58 <Cale> which is basically the same thing :)
07:46:59 <Buggaboo> I'm not so clear as to what expansion means... and the difference of it to generation.
07:47:13 <Cale> Where are these terms appearing?
07:47:38 <ski> palomer : so anyway, then you don't want IndirectComposite .. since that is good e.g. for making lists where tails are mutable references, and then one can freeze the list, or indeed, a tree where every node lies behind a mutable reference, and this can then be frozen
07:47:53 <ski> palomer : so, i think you want something like :
07:49:50 <Buggaboo> Cale: "A part of the tree is dynamically generated by expanding the nodes in the fashion defined by the basic algorithm (dfs, bfs, iterative deepening)"
07:50:11 <Cale> oh, okay
07:50:20 <Cale> so they're the same, I think
07:50:40 <Cale> expanding the nodes ~= monadic binding
07:51:35 <Buggaboo> Cale: Yeah, but further in my text, they discuss the testing moment when a node needs to be checked if its an optimal target node.
07:52:09 <Buggaboo> Cale: Those moments are during generation or expansion.
07:52:13 <Buggaboo> Cale: this confuses me.
07:53:08 <Buggaboo> Cale: and it says, all basic algorithms (not dynamic) always check during the expansion.
07:53:41 <SyntaxNinja> Igloo: are you saying I should delete the executables that I already have and just run make again? :)
07:54:03 <Cale> Buggaboo: odd
07:54:13 <Cale> I'm not really sure what they're referring to
07:54:34 <Buggaboo> me neither, I'm looking it up now.
07:54:39 <ski> palomer : http://www.rafb.net/paste/results/VBcX4g97.html
07:54:53 <ski> palomer : how about that ?
07:56:18 <Cale> Buggaboo: perhaps it's something which you'd have to worry about more in a strict language
07:56:20 <palomer> ski: but now you're going to have references in your MonoType
07:56:30 <Buggaboo> Cale: ah, found the bit.
07:56:58 <Buggaboo> expansion: apply a successor function to the current state.
07:56:59 <palomer> oh wait, you won't
07:57:24 <palomer> @kind Identity
07:57:25 <lambdabot> Not in scope: type constructor or class `Identity'
07:57:31 <Buggaboo> generation: create a set of states (by expansion)
07:57:33 <palomer> @kind Control.Monad.Identity.Identity
07:57:33 <lambdabot> * -> *
07:58:07 <Buggaboo> so I think they mean by generation, when you have the complete direct descendants of the current state.
07:58:17 <palomer> this could work
07:58:29 <Cale> Buggaboo: ah, perhaps
07:58:50 <Buggaboo> and expansion, right after applying one operator after the other on the current state
07:58:51 <palomer> ski: but now you have indirection at 2 places
07:58:54 <Igloo> SyntaxNinja: Yes. Although you hsouldn't need to delete anything.
07:59:02 <palomer> actually, you don't
07:59:04 <palomer> yeah, this is neat
07:59:06 <Cale> In Haskell, you can write it so that it looks naive, but it's not :)
07:59:10 <SyntaxNinja> Igloo: if I type make, it says everything is up to date.
07:59:42 <palomer> ski: thx
08:00:02 <palomer> well, I better go before I become a cripple
08:00:15 <Buggaboo> Cale: ah, so I think it's spatially cheaper to check during expansion in the case of dyn bfs. Instead of generation.
08:00:17 <Igloo> If that's all it says then things have changed since I last tried
08:01:23 <ski> palomer : http://www.rafb.net/paste/results/gvGPXG36.html
08:02:31 <ski> palomer : something like that should do it, i think
08:03:12 <Cale> Buggaboo: yeah, at least marginally
08:03:29 <ski> Buggaboo : why not check "after" the tree has been expanded ?
08:04:02 <Cale> ski: because you might not have to do quite as much allocation?
08:04:20 <Cale> it doesn't seem like a major gain to me, but I might be missing something
08:04:22 <ski> not if it's lazily generated (dunno if that's the case here)
08:04:29 <Cale> right, it's probably strict
08:04:50 <Cale> If it's lazy, you can write it very naively, and get quite nice results
08:04:58 <SyntaxNinja> Igloo: it says which things are up to date :)
08:05:09 <ski> (as noted by the 'Why Functional Programming Matters" paper :)
08:05:13 <Cale> yeah :)
08:05:48 <Igloo> SyntaxNinja: OK, you might need to delete things like the executables or libraries, then. GHC's build system isn't perfect, sadly
08:06:28 <Cale> though even in the lazy case, if you can have solutions occurring at different depths, it's good in a dfs to pick off any solutions from the head of the list (span) before continuing the iteration.
08:06:47 <Cale> (for obvious reasons)
08:06:59 <Cale> you don't want to do partition though
08:07:07 <Cale> since that observes more than you'd like
08:07:21 <ski> Cale : you mean alternative branches ?
08:07:24 <Cale> yeah
08:07:27 <Buggaboo> ski: well if your subject has cyclic structures in it, it may take a while to generate a complete tree (maybe forever even)
08:07:51 <ski> (i.e. doing a little breadth-first to improve efficiency of depth-first)
08:07:56 <Cale> yeah
08:08:07 <ski> Buggaboo : only if the generation is strict
08:08:12 <SyntaxNinja> Igloo: ok thanks
08:08:22 <Buggaboo> ski: yeah.
08:08:22 <Cale> you can prune with filter or guard (which are equivalent)
08:08:36 <Cale> (though guard is more general)
08:09:19 <Buggaboo> ski: iterative deepening (dfs with depth control) is optimal and complete I think.
08:10:00 <Buggaboo> hm... and why did I say that...
08:10:14 <Buggaboo> I was gonna say something but I forgot...
08:10:48 <Buggaboo> oh yeah, dfs with but doing some bfs to improve the efficiency.
08:11:09 <Buggaboo> hm. I never thought of that technique.
08:11:20 <ski> time complexity of iterative deepeneing is approx. b^d_max, says a book here
08:11:50 <ski> where b is branching factor, d_max is depth limit
08:12:22 <ski> Buggaboo : that technique is often used in prolog coding :)
08:12:26 <Buggaboo> what bugs me about iter deep is that it repeats the search, to make up for the optimality requirement.
08:12:50 <ski> that's what bugs us all about it, i think :)
08:13:15 <Buggaboo> ski: I thought prolog uses backtracking? (dfs with one nodal space for the fringe/front)
08:13:28 <ski> possibly one could make an implementation that recalls what it has done, so it only has to continue from where it left off
08:13:42 <ski> but i don't know how much more space would be needed for that
08:13:51 <Buggaboo> yeah, that's backtracking there.
08:13:59 <Buggaboo> what you described.
08:14:16 <ski> Buggaboo : yes, but many uses of if-then-else (and cuts) essentially prune away alternate useless branches
08:14:35 <ski> no, i meant such an implementation for iterative-deepening
08:14:46 <Buggaboo> oh okay.
08:16:13 <Buggaboo> hm, I need to see the pseudo-implementation of backtracking.
08:17:22 <ski> which ?
08:18:30 <ski> (arg, misread in book above .. should be b^d, not b^d_max .. d is shortest solution length, apparently)
08:18:39 <ski> wb
08:19:51 <Buggaboo> sorry got disco-ed for some strange reason.
08:19:53 <Buggaboo> aha.
08:21:03 <Buggaboo> http://www.cs.uu.nl/docs/vakken/za/sheets-coll3.pdf (p.57) pseudo-code of backtracking
08:21:26 <Buggaboo> everything except the pseudo-code is in dutch sorry :\
08:27:56 <ski> that first page looks ok (though it only finds first solution, i think)
08:28:37 <Buggaboo> yeah, it promises completeness but not optimality.
08:28:58 <Buggaboo> and its probably equally expensive as dyn dfs.
08:29:40 <ski> which is ?
08:30:39 <jethr0_> Buggaboo: i don't know what you're talking about right now, but i just implemented an alpha-beta-search on lazy trees with iterative deepening, that remembered its evaluations between iterations...
08:31:00 <Buggaboo> alpha-beta, nice.
08:31:06 <Buggaboo> what game are you doing?
08:31:31 <jethr0_> space is an issue though. i'm still trying to figure out how to "convert" evaluated thunks back into unevaluated ones...
08:31:45 <jethr0_> Buggaboo: i started with tic-tac-toe, but eventually i'd like to do othello
08:31:59 <Buggaboo> you have a good heuristic for that?
08:32:30 <Buggaboo> ski: spatial and time costs for dynamic dfs?  I dunno.  It's in my book.
08:32:34 <jethr0_> Buggaboo: it's all a bit in the future. i want to use neural networks for the heuristic
08:32:47 <Buggaboo> ... dude, isn't that overkill?
08:33:01 <Buggaboo> for othello?
08:33:10 <jethr0_> Buggaboo: for othello? maybe. but if i go through with it, it's a nice learning project :)
08:33:19 <Buggaboo> always.
08:33:35 <Buggaboo> thanks Cale, ski, jethr0_, I'm heading for bed!
08:33:37 <jethr0_> but right now it's a bit on ice... the alpha-beta is more or less finished though
08:33:41 <jethr0_> night
08:33:48 <ski> Buggaboo : ..
08:34:11 <ski> Buggaboo : i meant what is the diff between dyn dfs and backtracking ?
08:34:13 <Buggaboo> good luck with the pruning, and not getting rid of good hidden solutions.
08:34:46 <ski> jethr0_ : how do you remember between iterations ?
08:35:06 <Buggaboo> ski: oh, um, backtracking has only one direct descendant on the fringe/front, and dyn dfs has all of them, after generation of course.
08:35:28 <Buggaboo> backtracking is less memory expensive.
08:35:41 <Buggaboo> but has the good and bad sides of dyn dfs.
08:35:44 <Buggaboo> good night!
08:35:47 <ski> but the latter only explores one of them, before looking at the others, then ?
08:35:57 <ski> (latter = dyn dfs)
08:35:57 <jethr0_> ski: everything i've evaluated so far
08:36:15 <ski> jethr0_ : but, how ?
08:36:17 <Buggaboo> yes ski.
08:36:24 <ski> Buggaboo : ok
08:36:27 <ski> Buggaboo : goodnight
08:36:31 <Buggaboo> nighty night
08:36:43 <jethr0_> ski: the whole application specific stuff is in the lazy tree. it's pretty much all solved by lazyness :)
08:37:17 <ski> jethr0_ : ok, so you keep it as forced data in a lazy tree, which you just traverse again down and then one level more ?
08:37:26 <jethr0_> the tree branches/leaves are annotated with "Pending / AlphaBetaCut / DepthCut / Done" and the search algo updates the annotations as it goes by
08:37:36 <jethr0_> yup
08:37:50 <ski> so, it's in ST or IO monad ?
08:37:56 <jethr0_> neither, it's pure
08:38:11 <ski> 'the search algo updates the annotations as it goes by'
08:38:16 <jethr0_> i do a lot tree rebuilding, but i don't think it's all that costly
08:38:16 <ski> how do you do that, then ?
08:38:23 <ski> aha
08:38:57 <jethr0_> i guess there's better suited solutions out there. i just wanted to try doing it with a lazy tree and it performs pretty well
08:39:14 <ski> (well, you rebuild all spines down to Pending, at least, i guess ?)
08:39:44 * SimonRC has an insight: Type classes (with type inference) are duck typing done more formally.  They allow complete compile-time checking, while retaining almost all the advantges of duck typing.
08:39:55 <SimonRC> (What is the proper name for duck typing, anyway?)
08:40:06 <jethr0_> ski: i skip all "Done"s, keep track of the current depth, if i find a leave it's done. fathers of all-done children are done, ...
08:40:36 <jethr0_> SimonRC: i've had a similar insight lately :)
08:41:11 <ski> SimonRC : what is 'duck typing' ?
08:41:23 <jethr0_> ski: also i don't go into AlphaBetaCut subtrees unless alpha or beta have changed the right amount, and i don't go in to DepthCuts unless the remaining depth is bigger then the cut's.
08:41:38 <SimonRC> The trouble is, duck typing can be "added" retroactively, not so easily done with type classes, though type inference helps greatly.
08:41:39 <ski> jethr0_ : right
08:41:45 <ski> jethr0_ : ok
08:41:58 <SimonRC> ski: If if looks like a duck and quacks like a duck, it's a duck.
08:42:16 <SimonRC> ski: I.e. defining types by the methods/functions they have.
08:42:25 <jethr0_> SimonRC: true, but duck typing is inherently non-robust, whereas type classes make compile-time guarantees
08:42:51 <ski> SimonRC : that seems pretty ambiguous, to me ..
08:43:11 <jethr0_> ski: it's the way of the dynamically typed languages
08:43:19 <SimonRC> That is what the second sentance was about.
08:43:43 <SimonRC> Dynamic vs static typing is a Great Debate.
08:44:09 <jethr0_> smalltalk is similarly type agnostic in that you can send any object any message and it has a catch-all responder that handles unknown messages...
08:44:27 <ski> it seems to be hiding values behind a record of methods/functions
08:44:30 <jethr0_> ruby and python have adopted similar solutions
08:44:54 <jethr0_> ski: it's what OO was intended to be :)
08:45:06 <jethr0_> sending messages to objects
08:45:10 <ski> yes, but that leaves out many details
08:45:21 <ski> hence, ambiguous
08:45:32 <jethr0_> how is it ambiguous?
08:45:44 <SimonRC> I can think of an algebraic data type I may have to add in the future that will end up having dozens of constructors, and will need another constructor or two adding many of the times I add a feature.
08:46:10 <SimonRC> In a program I my continue writing in the holidays.
08:46:28 <lispy> SimonRC: re: duck typing, Type classes are really sweet
08:46:35 <SimonRC> well, yes
08:47:09 <SimonRC> ski: I believe the details vary betwen languages anyway, if you are saying our definitions are ambiguous.
08:48:43 <ski> i was thinking of how to handle other common things related to this, like recusion, open recursion, binary methods, inheritance, etc
08:49:26 <SimonRC> ski: See Python?
08:50:11 <jethr0_> ski: well, if you standardized message passing, recursion and binary methods are very well implementable. and as inheritance isn't about types, you just inherit method implementations
08:50:13 <ski> what about python (which i don't know well) ?
08:50:52 <ski> inheritance is partly about types
08:51:09 <jethr0_> ski: not so much in dynamically types languages :)
08:51:26 <ski> different meaning of 'type' :)
08:51:44 <jethr0_> and as i said, smalltalk is what the "fathers" of OO intended it to be and smalltalk is also dynamically typed
08:52:02 <jethr0_> ski: true, but now we're getting closer to "duck typing"
08:52:19 * ski referred to what Anton Straaten (iir his name correctly), called 'implicit types' i think
08:52:34 <jethr0_> sounds a lot like duck typing to me
08:52:37 <jethr0_> :)
08:53:40 <ski> (i.e. the interfaces etc that would correspond to types in a statically typed language, not the tags or names of methods that are accessible at run-time in a dynamically typed language)
08:54:18 <ski> (iirc Anton Straaten is a Scheme person, btw)
08:55:05 <jethr0_> i don't get your point in the above
08:55:25 <ski> (in any case, i think these things in dynamically typed languages are interesting, and would love to understand them better)
08:55:26 <jethr0_> where do you draw the line between "what would correspond to types" and "names at run-time"?
08:55:55 <ski> names are more or less flat
08:56:00 * jethr0_ doesn't find them all that enticing any more
08:56:00 <ski> this is a list
08:56:06 <ski> this is a function
08:56:27 <ski> this is an object that supports methods with these names and these arities
08:56:30 <ski> etc
08:56:46 <jethr0_> sounds interesting
08:57:01 <ski> whereas with static types, you get more things like
08:57:10 <ski> this is a list *of* *blah*
08:57:20 <ski> this is a function from *blah* to *bleh*
08:57:41 <ski> this is an object that supports methods with these names and accepting *blahs* and returning *blehs*
08:57:41 <jethr0_> but isn't type inference a nice compromise?
08:58:20 <jethr0_> all the dynamically typed languages do a lot of inference behind the scenes for optimizations anyways
08:58:39 <ski> this is a class that can create objects that supports methods with these names and accepting *blahs* and returning *blehs* and that can be subclassed in a way with a particular open recursion pattern
08:59:05 <ski> not sure what 'type inference' has to do with this ..
09:00:04 <ski> (maybe such inference in dyn. typed lang.s .. don't know much about that)
09:01:08 <jethr0_> well, inference kinda gets from your first list to your second list. you give it a chaotic mess and it finds all the "implicit types", if this is the right term here
09:01:35 <ski> (jethr0_ : re '.. all that enticing ..' .. there's some reason i'm mostly a static typer .. but that doesn't mean i don't want to find out good points of dynamic typing :)
09:02:21 <ski> jethr0_ : you are speaking of partial type inference for improving efficiency, yes ?
09:02:39 <jethr0_> i think i've kinda lost the focus of our discussion :)
09:03:05 <ski> hm, somewhat ditto ..
09:03:11 * SimonRC goes to eat.
09:03:19 <jethr0_> ski: i don't mean to bash dynamic typing per se and am very interested in all kinds of new approaches. but right now i'm pretty happy with the way haskell handles things
09:03:30 <ski> :)
09:04:14 <ski> i guess i'm mostly right here interested in finding out nice approximations (if not better) for 'duck typing' in static typing
09:04:39 <ski> (sortof discovering the implicit mostly static interfaces mechanisms behind it)
09:07:22 <ski> anyway, i should prolly go to sleep
09:07:27 <jethr0_> me too
09:07:29 <jethr0_> good night
09:07:40 <ski> ditto
09:07:50 * xerox catches'em'all!
09:09:39 <xerox> (Ditto was a pokemon, <grin>)
09:09:59 <jethr0_> xerox: you seem to know an awful lot about that *g*
09:10:13 * xerox whistles innocently
09:22:21 * jethr0_ goes off to bed. good night
10:10:35 <Phyx-> anyone here?
10:10:36 <Phyx-> getTotalMins :: Agenda -> String -> Int
10:10:36 <Phyx-> getTotaMinsl :: [] a = 0
10:10:41 <Phyx-> gives me
10:10:56 <Phyx-> Illegal signature in pattern: [] a
10:11:24 <SyntaxNinja> get rid of the "::" in the definition
10:11:34 <Phyx-> type Afspraak      =  (Tijdslot, Omschrijving, [Categorie], [Deelnemer])
10:11:34 <Phyx-> type Agenda        =  [Afspraak]
10:11:42 <SyntaxNinja> "::" means "has type"
10:11:42 <Phyx-> bah
10:11:43 <Phyx-> i hate those typos...
10:12:07 <Phyx-> i've been fighting with it, but never noticed that :S
10:12:11 <SyntaxNinja> wow, how did that 'l' get all the way from th emiddle to the end of the word :)
10:12:45 <Phyx-> ?
10:12:50 <dons> SyntaxNinja, I've been (unfortunately) still busy.  But I do want to get further in to hackageDB. It's a matter of building up some time and priority. Let me put some large bold letters in my calendar for this weekend.
10:13:23 <SyntaxNinja> dons: OK. thanks.
10:13:49 <SyntaxNinja> Phyx-: your next problem might have to do with misspelling your function "getTotaMinsl"
10:14:20 <Phyx-> compiled :d
10:14:50 <Phyx-> heheh, didn't even see that SyntaxNinja 
10:14:54 <Phyx-> again, thanx
10:15:01 <Phyx-> you really are a syntax ninja
10:15:26 <SyntaxNinja> Phyx-: :)
10:18:37 <SyntaxNinja> dons: I'm thinking I won't hold off the cabal release any longer. I'm already later than I thought.
10:19:23 <Lemmih> hackageDB is holding cabal back?
10:19:57 <Phyx-> compiled and worked :D
10:21:22 <SyntaxNinja> Lemmih: I was hoping to release a cabal w/ cabal-get.
10:21:35 <SyntaxNinja> Phyx-: you go!
10:22:13 <Phyx-> :P
10:24:27 <Lemmih> SyntaxNinja: And you want it to have less dependencies?
10:24:32 <SyntaxNinja> ja
10:25:17 <Lemmih> For HackageDB or just cabal-get?
10:28:50 <SyntaxNinja> just cabal-get
10:28:56 <SyntaxNinja> so that it can be included w/ cabal
10:28:58 <SyntaxNinja> sanely.
10:29:55 <Lemmih> I could easily remove the HTTP, NewBinary, Crypo and FilePath dependencies. Would that be enough?
10:30:49 <Lemmih> Probably also the GnuPG dep. That would leave only hackage-client.
10:31:09 <SyntaxNinja> Lemmih: here's the plan: http://hackage.haskell.org/trac/hackage/ticket/65
10:32:17 <SyntaxNinja> Lemmih: but that's not too detailed yet... I think that they should all be sucked into one source tree, sorta like the 'compat' tree in cabal.
10:32:28 <SyntaxNinja> dons or dcoutts should feel free to correct me.
10:33:16 <SyntaxNinja> dcoutts mentioned that there are smaller things than haxml and http. basically just trim out all the code we don't need, and suck it into one source tree so that it can be included simply in cabal.
10:33:45 <SyntaxNinja> hackage-client is perhaps something that could be separate. that would definitely be nice, so ppl would be encouraged to write clients.
10:34:15 <SyntaxNinja> but nah, one tree. the bootstrapping is too hard otherwise.
10:36:23 <Lemmih> hm
10:36:32 <SyntaxNinja> what do you think?
10:36:50 <SyntaxNinja> you can log into the wiki as a guest (see first page) and provide more data on the tickets, if you want :)
10:37:28 <Lemmih> Not sure how to do it without making it ugly and complex.
10:50:52 <Lemmih> Heh: [  1 of 262] Compiling ExternalCore     ( coreSyn//ExternalCore.lhs, interpreted )
11:03:36 <SyntaxNinja> Lemmih: making what ugly & complex?
11:05:19 <Lemmih> SyntaxNinja: cabal-get.
11:06:18 <dons> int-e, the new pidigits has been benchmarked, good stuff: http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=all
11:07:13 <dons> (though i see a redundadnt pragma crept in, oh well)
11:12:15 <SyntaxNinja> Lemmih: in what way?
11:15:22 <Lemmih> SyntaxNinja: Inlining all the dependencies is gonna be a mess. And I'm not sure whether to make a special version for Cabal or inlining the normal branch too.
11:18:45 <SyntaxNinja> why is it going to be a mess?
11:19:02 <SyntaxNinja> I guess it doesn't necessarily have to be inlined. we can put off that decision.
11:19:23 <SyntaxNinja> because we can write bootstrapping code in the makefile and cabal-install (which dcoutts is working on)
11:23:27 <SyntaxNinja> Lemmih: so if you want to hack on this, that would be great. I'd say that we should merge the cabal and cabal-get trees, add cabal-install, and trim down cabal-get.  leave them as separate packages for now, and maybe we'll do some hacks to add a "packages" directory or something to the cabal src tree.
11:24:09 <SyntaxNinja> I gotta go for now, though. email me. ttyl
11:24:16 <Lemmih> Bye.
11:24:25 <SyntaxNinja> Lemmih: generally sound OK? are you interseted in working on it?
11:24:44 <SyntaxNinja> this is a more central role for cabal-get than originally envisioned :)
11:25:14 <Lemmih> Yeah, I'm interested.
11:25:44 <SyntaxNinja> ok lemmy know if you need more details. email me, don't be shy :) peace
11:27:02 <Lemmih> dcoutts: ping.
11:40:57 <zce> I'd like to learn group theory from online materials.
11:41:01 <zce> Any recommendations?
11:41:26 <gzl> why online materials? there are in-print books that are going to be much better.
11:42:16 <zce> I don't have access to a decent library right now.
11:42:35 <zce> I'm going to graduate school in economics, in an university that's dedicated to it and has a specialized library.
11:44:04 <zce> help?
11:44:53 <Frederick> zce, maybe pm Cale he knows lots of good links
11:45:09 <zce> thanks!
11:45:25 <gzl> check out jmilne.org/math
11:45:29 <gzl> I think he has a book on group theory.
11:45:55 <gzl> (online)
11:45:55 <Cale> http://www.math.uiuc.edu/~r-ash/Algebra.html -- this has some stuff
11:46:09 <gzl> I've looked at those. not so useful.
11:46:21 <syntaxfree> good links.
11:46:21 <Cale> It's not as complete as you'd like
11:47:19 <gzl> oh wait, I was thinking of something slightly different. this isn't that bad, but yeah, not so much material.
11:55:12 <palomer> you should really by "abstract algebra" by Foote and Dummit
11:55:43 <palomer> ok, it takes ghc 10 seconds to realize that it's already compiled some files, how do I speed this up?
11:55:55 <palomer> like, it goes "skipping foo.hs...skipping bar.hs....." for 10 seconds!
11:57:12 <Saulzar> Write your own makefile? :)
12:00:10 <palomer> are you nuts? that would take... minutes!
12:03:53 <dons> palomer, I think you should start a "Palomer's Complaints" blog :) 
12:05:33 <palomer> I should!
12:08:23 <gzl> you should also not say Dummit and Foote backwards. it really freaks me out. :P
12:09:50 <syntaxfree> well. I appreciate the help.
12:15:08 <palomer> how do I create a list of ones of length 5?
12:16:36 <Lemmih> > replicate 5 1
12:16:37 <lambdabot> [1,1,1,1,1]
12:16:38 <palomer> hmm, maybe I'm going about this the wrong way. I have a pair of line,column pairs, and I want to get that region, the region being every character after the first line,column pair and before the second. The ordering is lexicographical
12:22:55 <cpatrick> palomer: sounds like a fold?
12:29:48 <palomer> cpatrick: how would that work?
12:32:44 <cpatrick> actually I misread what you were asking, never mind
12:33:23 <cpatrick> some variant of drop and take might be a starting point though
12:33:49 <cpatrick> > take 5 $ drop 3 "hello world"
12:33:50 <lambdabot> "lo wo"
12:34:07 <syntaxfree> > (flip replicate . replicate) 4 4
12:34:08 <lambdabot>  add an instance declaration for (Show (a -> [a]))
12:35:25 <Cale> together with lines
12:36:06 <palomer> yeah, but I'll only be removing columns from the first and last lines
12:37:35 <syntaxfree> > replicate 4 (replicate 4 4)
12:37:36 <lambdabot> [[4,4,4,4],[4,4,4,4],[4,4,4,4],[4,4,4,4]]
12:37:45 <syntaxfree>  > (flip replicate . replicate) 4 4 4
12:37:57 <syntaxfree> > (flip replicate . replicate) 4 4 4
12:37:58 <lambdabot> Couldn't match `[a -> [a]]' against `t -> t1'
12:38:41 <syntaxfree> @pl replicate 4 (replicate 4 4)
12:38:41 <lambdabot> replicate 4 (replicate 4 4)
12:38:58 <syntaxfree> @pl f x y z = replicate x (replicate y z)
12:38:59 <lambdabot> f = (. replicate) . (.) . replicate
12:39:42 <syntaxfree> @p f z y x = replicate x (replicate y z)
12:39:43 <lambdabot> Maybe you meant: part paste pl pl-resume pointless poll-add poll-close
12:39:43 <lambdabot> poll-list poll-remove poll-result poll-show pretty .
12:39:56 <syntaxfree> @pl f z y x = replicate x (replicate y z)
12:39:56 <lambdabot> f = (flip replicate .) . flip replicate
12:53:54 <vincenz> crap
12:53:58 <vincenz> Anyone using iPod/iTunes?
12:54:22 <Pseudonym> Of course not.
12:54:42 <Pseudonym> Overpriced, less-functional MP3 player which scratches easily.
12:54:51 <Pseudonym> Why in $DEITY's name would _anyone_ buy one?
12:55:07 <vincenz> tsk
12:55:10 <Pseudonym> :-)
12:55:23 <vincenz> thx ... I just got one recently
13:11:12 <vincenz> HOLY CRAP
13:12:39 <dons> why use iTunes? gnupod works beautifully. and it runs anywhere.
13:14:25 <vincenz> not for movies
13:14:26 <vincenz> anyways
13:14:29 <vincenz> I opened my ipod wiht itunes
13:14:30 <vincenz> and blammo
13:14:36 <vincenz> all the stuff I had put on there with gtkpod was gone
13:15:24 * vincenz mutters
13:18:32 <vincenz> grr and apparently this itunes just messed up my ext2fs in windows
13:18:51 <vincenz> it shows my e local disk... you click on it "want to format?"
13:19:09 <vincenz> s/my e/me a
13:19:21 * vincenz is getting seriously frustrated
13:19:29 <vincenz> all I wanted to do was put the SICP movies on my ipod
13:24:07 <vincenz> On another note
13:24:13 <vincenz> any idea why my copy of lambdabot crashes from time to tim
13:27:11 <vincenz> dons: ?
14:24:19 <palomer> hrmph
14:25:03 <palomer> [replicate k ['a'..'z'] | k <- [1..]] >>= sequence    is good for variable names, but does anyone have any alternatives?
14:26:35 <Cale> hehe, ["x" ++ show k | k <- [1..]]
14:29:22 <palomer> ah, no, the other one is better
14:29:45 <palomer> since I have to go up to the 40th or so element (for simple terms)
14:30:34 <Cale> you could possibly influence the names based on what they were created for, like prepending a tag
14:30:48 <Cale> if there's any meaningful information you have about it
14:31:05 <Cale> I know that GHC tries to use the type variable names which you used
14:41:17 <dons> vincenz, crashes? i've never seen that. you'll need to give me much much more info.
14:41:43 <vincenz> dons: that's the problem, there is no info
14:41:46 <vincenz> the binary keeps running
14:41:50 <vincenz> but suddenly he can't evaluate
14:41:52 <vincenz> or he's no longer in the channel
14:42:29 <vincenz> once he froze, aka wouldn't respond to commands, twice he suddenly left irc while still running
14:42:55 <dons> palomer, ghc uses something like : 
14:42:56 <dons>   let i     = unique s
14:42:56 <dons>       fresh = mkId $ if i < 26 then [chr (ord 'a' + i)] else 't' : show i
14:43:37 <dons> oh, so that's not a crash.
14:43:37 <dons> probably juts the network issues.
14:43:38 <vincenz> > mkId
14:43:39 <lambdabot>  Not in scope: `mkId'
14:43:48 <vincenz> dons: the other time, however he didn't respond to typed stuff
14:44:08 <dons> sometimes it gtes disconnected by the irc server, but doesn't realise it.
14:44:24 <vincenz> even though still connected
14:47:57 <dons> yep , happens only rarely if you have a very reliable connection
14:48:13 <vincenz> I do
14:50:06 <dons> notice that this only happens to #haskell's lambdabot about once a month or so. maybe less often.
14:50:30 <vincenz> hmm
14:50:34 <vincenz> more frequently
14:50:37 <vincenz> even though he's used less
14:53:54 <vincenz> heisenbugs..
14:54:30 <Cale> this server doesn't ping very often
14:54:45 <Cale> er, network
14:54:46 <vincenz> the connection remains active, the bot just doesn't respond
14:54:50 <Cale> yeah
14:55:20 <vincenz> btw, is there an xml module for haskell
14:55:23 <Cale> yeah
14:55:28 <vincenz> :)
14:55:32 <Cale> there are some pretty sophisticated ones
14:55:33 <vincenz> comes with ghc?
14:55:37 <Cale> no
14:55:38 <vincenz> don't need anything fancy
14:55:56 <vincenz> I was just thinking to use xml as format for saved files of my graph editor
14:55:59 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/
14:56:08 <Cale> that might be overkill
14:56:09 <vincenz> one thing I'm still stuck on is how to make the types of the graph dynamic
14:56:17 <vincenz> so I can decorate at will
14:56:20 <vincenz> err... the user can
14:56:44 <Cale> is it to be Haskell-scriptable?
14:56:50 <vincenz> partially yeah
14:57:05 <vincenz> map $ Gr.lsuc $ selectedNodes
14:57:12 <Cale> right :)
14:57:25 <vincenz> in a little box at the bottom
14:57:35 <vincenz> or some popup dialog
14:57:39 <vincenz> I think that owuld be neat
14:57:42 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html :)
14:57:52 <vincenz> thx
14:58:03 <vincenz> one thing I'm worried about is the amount of effort for layout algorithms
14:58:11 <vincenz> I saw this commercial editor today that did lots of stuff
14:58:24 <Cale> oh, yeah, you can go a long way
14:58:53 <vincenz> yeah
14:59:02 <Cale> I'm not sure how much work has been put into drawing graphs with large automorphism groups well, but you should be able to draw very pretty graphs of them :)
14:59:03 <vincenz> and basically I wonder how they handled multiple representations of nodes
14:59:17 <vincenz> for instance for hierarchical graphs
14:59:19 <vincenz> let me find the link
14:59:57 <vincenz> http://www.aisee.com/shots/
15:00:10 <vincenz> notice how it has many ways of displaying nodes
15:00:13 <vincenz> and nodes can contain information
15:00:17 <vincenz> I wonder how to do this in haskell
15:00:20 <vincenz> as haskell is typed
15:00:35 <vincenz> most likely a dynamically typed lang would be better for that...
15:01:03 <vincenz> notice how different
15:01:08 <vincenz> http://www.aisee.com/shots/3.htm
15:01:10 <vincenz> is from other graphs
15:01:17 <vincenz> (and it's hierarchical)
15:01:18 <Cale> well, if you know the interface to nodes, you could use an existential type
15:01:27 <vincenz> hmm?
15:01:37 <sethk> anyone have experience with the Time module?  I'm getting what look like garbage numbers for picoseconds
15:01:52 <vincenz> sethk: obviously, cpu's can't measure picoseconds
15:02:06 <vincenz> cpus run in bare-sub nanosecond 
15:02:19 <vincenz> aka .3 ns top
15:02:23 <vincenz> (well bottom)
15:03:08 <vincenz> so the fastest possible instruction that is cached and has no pipeline stalls will take 300 ns, all the rest will take a shitload more :D
15:03:14 <Cale> that's just some slightly unnecessary future-proofing :)
15:03:28 <vincenz> hehe
15:03:37 <vincenz> at some point people will complain
15:03:41 <sethk> vincenz, no, probably not, but it can measure milliseconds
15:03:44 <vincenz> "damn haskell people, couldn't they foresee subpicoseconds"
15:03:46 <sethk> vincenz, but that's not the point
15:03:46 <Cale> System.Time will be replaced by then anyway
15:03:57 <vincenz> which brings up an interesting point
15:04:02 <sethk> vincenz, the point is that if the resolution is lower, you should see 0, not garbage
15:04:07 <vincenz> we've had 8 bit,16 bit, 32 bit...
15:04:07 <Cale> in fact, there's a replacement already basically finished
15:04:11 <vincenz> now it's 64bit
15:04:17 <vincenz> do you think we'll ever need more?
15:04:22 <Cale> no
15:04:31 <Cale> > 2^64
15:04:32 <lambdabot> 18446744073709551616
15:04:33 <vincenz> so you're saying no memory will ever be > 64bit wide
15:04:36 <sethk> I need better than seconds resolution.  If I can't use Time...
15:04:42 <sethk> I'll have to come up with another way to measure.
15:04:48 <vincenz> sethk: who cares if it's garbage
15:04:53 <vincenz> the nano and milli will most likely be accurate
15:04:55 <Cale> > log (2^64) / log 10
15:04:56 <lambdabot> 19.265919722494793
15:05:12 <sethk> vincenz, I do
15:05:12 <vincenz> > log (2^64) / log 2
15:05:14 <lambdabot> 64.0
15:05:16 <Cale> heh
15:05:25 <vincenz> so you're finally saying
15:05:32 <sethk> vincenz, because the result of numerical operations on TimeDiff objects are wrong
15:05:34 <vincenz> YEs, at LAST we'll never need to go further than this bitwidth
15:05:40 <vincenz> sethk: oh
15:05:46 <Cale> let's see, how many particles are there in the known universe?
15:05:52 <vincenz> 10^52
15:06:01 <vincenz> or 10^80 
15:06:03 <vincenz> can't remember
15:06:30 <vincenz> either way
15:06:31 <Cale> hmm
15:06:35 <vincenz> most likely they'll go higher
15:06:38 <Cale> hehe
15:06:43 <vincenz> a colleague of mine is working on RISC architecturs with ultrawide registers
15:07:01 <Cale> oh, wider registers, maybe
15:07:08 <Cale> wider addresses, probably not
15:07:15 <vincenz> depends
15:07:22 <vincenz> if you go towards ubiqutuous computinhg
15:07:32 <vincenz> it would be nice if you could directly map part of your address to the i
15:07:34 <vincenz> ...ip
15:07:50 <sethk> eventually massively parallel involving many (relatively) cheap machines makes more sense than adding more bandwidth to each machine
15:07:56 <vincenz> and ipv6 is already.... 96bit
15:08:06 <Cale> 96?
15:08:08 <vincenz> yeah
15:08:12 <vincenz> 6*16bit
15:08:21 <Cale> ah, hmm
15:08:31 <Cale> I recall hearing 128
15:08:32 <vincenz> it's 6 sets of 4 nibbles
15:08:39 <vincenz> afaik
15:09:11 <vincenz> just do ifconfig
15:09:26 <vincenz> hmm
15:09:28 <Cale> Wikipedia says 128
15:09:32 <cpatrick> it's 128
15:09:32 <vincenz> it seems to be 4 sets of 4 nibbles
15:09:37 <vincenz> oh
15:09:38 <vincenz> okies
15:09:39 <vincenz> thx
15:09:40 <Cale> there are shorthands
15:09:41 <cpatrick> but you can't really use all of that space
15:09:43 <vincenz> I was wrong
15:09:54 <vincenz> cpatrick: no but it' makes it easier to partition
15:10:07 <vincenz> I mean there's not 2^32 machiens
15:10:25 <vincenz> it's just that you want to nicely have region, subregion, etc.
15:10:31 <cpatrick> (vincenz: yeah) the first 16 bits are are always 2001 (production networks) or 2002 (6-to-4)
15:10:51 <cpatrick> the last 64 bits are usually the mac address (with some mangling)
15:10:58 <vincenz> I wonder if they'll maje sure to keep the first few nibbles free
15:11:04 <vincenz> once we start going interplanetary
15:11:25 <cpatrick> that still gives you 65536 times as many subnets as there are ipv4 addresses
15:11:55 <vincenz> it's not the amount
15:11:58 <cpatrick> vincenz: hehehe. knowing the IETF types, they've probably already reserved some address space for other planets ;-)
15:12:03 <vincenz> it's the ability to do a lot with sub-sets
15:12:18 <vincenz> aka you don't want to have part of a number be the region and the other bits the subregion
15:12:26 <vincenz> hence you need a much wider address
15:12:38 <vincenz> planet.continent.country.region.city.ip
15:12:41 <vincenz> or somesuch
15:12:56 <vincenz> hence you need enough bitwdith  in each number
15:13:06 <vincenz> which is an issue with ipv4
15:13:07 <cpatrick> yeah, though I hear that in practice ipv6 routing is already becoming a mess :-/
15:13:13 <vincenz> really?
15:13:22 <vincenz> I thought it was meant to simplify things
15:13:27 <vincenz> so you didn't have to worry about local ip
15:13:29 <vincenz> ..s
15:14:04 <vincenz> so how come this is not 128 bit
15:14:07 <vincenz> inet6 addr: fe80::250:baff:fe33:5fc6/64
15:14:16 <cpatrick> the :: means "fill in the rest with zeroes"
15:14:22 <vincenz> ah
15:14:29 <cpatrick>     inet6 2001:388:7094:4080::23/64 scope global
15:14:44 <vincenz> I assume you can't have two ::
15:15:25 <cpatrick> correct. here we see a machine on the 2001:388:7094:4080:: subnet (allocated to the university computer club here), and the 0x23'rd machine on that subnet
15:15:39 <vincenz> :)
15:15:46 <vincenz> anyways, back to the original discussion
15:16:05 <vincenz> Cale: you said something about existential types to solve my problem of annotating graphs with custom info?
15:16:47 <Cale> vincenz: yeah, possibly
15:16:58 <vincenz> how does that work?
15:17:24 <Cale> data Showable = forall a. (Show a) => Showable a
15:17:32 <Cale> or, in the newer syntax
15:17:46 <vincenz> this is ghc 6.4.1?
15:17:49 <Cale> data Showable where Showable :: (Show a) => a -> Showable
15:17:50 <Cale> yeah
15:18:10 <vincenz> so basically you specify an interface
15:18:13 <vincenz> hmm
15:18:14 <vincenz> seems good
15:18:21 <vincenz> and then I assume I'd have to use hs-plugins
15:18:23 <vincenz> to load code
15:18:26 <vincenz> and to do haskell scripting
15:18:27 <Cale> note that there's no downcasting here :)
15:18:36 <vincenz> oy
15:18:41 <Cale> so once you apply the constructor, you only have the interface
15:18:44 <Cale> the type is gone
15:19:01 <vincenz> hmm
15:19:05 <ncalexan> Cale: it's perfect duck typing!
15:19:15 <vincenz> ncalexan: no it's not
15:19:21 <vincenz> ducktyping doesn't lose the interface
15:19:32 <Cale> what is duck typing anyway?
15:19:34 <ncalexan> You haven
15:19:42 <ncalexan> You haven't lost the interface; that's the point.
15:19:53 <ncalexan> Cale: looks like a duck, acts like a duck, is a duck implications.
15:19:56 <vincenz> you lose any other possible interface
15:20:02 <Cale> ncalexan: formally :)
15:20:08 <Cale> well, not too formally :)
15:20:09 <vincenz> anyone familiar with the GDL format?
15:20:10 <Cale> hehe
15:20:57 <ncalexan> vincenz: I would say that's orthogonal to the duck-typing idea.
15:21:22 <vincenz> right
15:21:25 <vincenz> but haskell makes it unorthogonal
15:21:28 <vincenz> by losing it
15:21:32 <vincenz> aka it's a skew
15:21:35 <vincenz> not orthogonal
15:22:10 <Cale> well, you don't have to pick just one class
15:22:17 <Cale> you can throw in some others if you like
15:22:17 * vincenz grins evilly
15:22:25 <vincenz> I'm gonna backhack the GDL format the people of aisee  use
15:22:42 <vincenz> should give me some info
15:27:46 <vincenz> btw, never install itunes, it'll wipe your ipod empty
15:28:46 <palomer> you're kidding me, right?
15:28:55 <vincenz> nope
15:28:59 <vincenz> I had 13 gb on my ipod
15:29:01 <vincenz> took me 3 hours
15:29:05 <vincenz> I installed itunes
15:29:08 <vincenz> to get some movies onto my ipod
15:29:14 <vincenz> first thing it did was ask me for a name for my ipod
15:29:17 <vincenz> I typed it in
15:29:18 <vincenz> BLAMMO
15:29:25 <vincenz> "available space: 29.8GB"
15:29:33 <palomer> well, at least you have more free space now
15:29:38 <vincenz> uhuh
15:29:40 <vincenz> I'm leaving today
15:29:46 <vincenz> I wanted my ipod full of music for the trip
15:29:55 <palomer> man that sucks
15:30:01 <palomer> are you sure it didn't press the wrong button?
15:30:03 <palomer> s/it/you
15:30:04 <vincenz> yeah well I've got it reloading again with gtkpod
15:30:05 <vincenz> nope
15:30:10 <vincenz> I mean yes
15:30:14 <vincenz> I didn't push any button
15:30:15 <vincenz> it just came up
15:30:17 <vincenz> first thing
15:30:25 <palomer> so the lesson of the day: init your ipod before putting any music on it, right?
15:30:27 <vincenz> anyways, I've got gtkpod reloading my music
15:30:31 <vincenz> palomer: yes
15:30:45 <vincenz> so it'll be ready as I get back to work
15:30:46 <palomer> as opposed to: lesson of the day: never install itunes
15:30:52 <vincenz> and I've got lynx in screen bittorrenting the SICP movies
15:31:07 <vincenz> hopefully I can recode those on time too
15:31:08 <palomer> goice choice
15:31:14 <palomer> s/goice/good
15:31:18 <vincenz> great movies for the cartrip ;D
15:31:24 <palomer> this is an ipod monster, right?
15:31:28 <vincenz> huh?
15:31:32 <vincenz> no an ipod video
15:31:42 <vincenz> I got it this weekend
15:31:46 <vincenz> \o/
15:31:54 <palomer> I have to decide which ipod to get
15:31:57 <vincenz> it's lovingly called oasispod, in the spirit of my other computers
15:32:11 <vincenz> palomer: well... shuffler is only 512MB
15:32:20 <palomer> but better sound quality
15:32:20 <vincenz> so you got a choice between nano and normal 
15:32:30 <palomer> there are 1gb shuffles too
15:32:31 <vincenz> nano was too small for my taste
15:32:44 <vincenz> 2 GB of music is hardly anything
15:33:13 <palomer> you have 4gb nanos
15:33:23 <vincenz> tho I gotta admit, I'm impressed by this stresstesting some people did with it
15:33:28 <vincenz> yeah ... well 4GB is small too
15:33:37 <Cale> Music: 11177 items, totalling 49.8 GB
15:33:45 <palomer> but the ipod monster is just too big
15:33:58 <vincenz> 30GB?
15:34:01 <vincenz> no it's perfect
15:34:05 <vincenz> 50% music
15:34:09 <vincenz> 50% movies whatnot
15:34:16 <vincenz> I Even have my bookmarks.html on it :D
15:34:19 <palomer> I mean, too big physically
15:34:24 <vincenz> not really
15:34:27 <vincenz> it's smaller than 4G
15:34:31 <Cale> still not enough space for all my music
15:34:36 <palomer> 4G?
15:34:38 <Cale> hehe
15:34:39 <vincenz> there's 60GB too
15:34:42 <vincenz> palomer: 4th generation
15:34:46 <Cale> yeah :)
15:34:49 <palomer> oh, this is 5G?
15:34:52 <vincenz> yep
15:35:03 <vincenz> vincenz@abstractserver:/home/music$ du -s
15:35:04 <vincenz> 24409218   
15:35:08 <vincenz> tho it's not all sorted ye
15:35:12 <vincenz> the sorted music is about 15GB
15:35:26 <vincenz> (that's one PAIN of a job...sorting and idtagging)
15:35:46 <palomer> if buying/browsing music was made easier, I'd spend so much money on music
15:35:59 <vincenz> yeah I think that's something that should prolly come soon
15:36:02 <Cale> 43.5 GB of my music is sorted by category, artist, and album
15:36:07 <vincenz> some smarter way of browsing music
15:36:13 <vincenz> Cale: how long did it take you to do that?
15:36:17 <palomer> and finding new songs you'd like
15:36:21 <Cale> and an additional 1.7 GB by artist only
15:36:26 <vincenz> would be neat if you could meta-google music
15:36:31 <gzl> blimey. 43.5 GB.
15:36:44 <Cale> vincenz: by downloading it mostly in that form and using scripts to automatically rename things
15:36:46 <vincenz> like songs in a similar spirit as the current playing song
15:36:52 <vincenz> Cale: from where?
15:37:09 <vincenz> anyone seen ipodlinux?
15:37:13 <vincenz> and the way you have to type?
15:37:14 <vincenz> it's funky
15:37:15 <Cale> *mule, LANs I've been on
15:37:28 <vincenz> they actually map a full ascii set to the 4 buttons
15:37:33 <Cale> Mostly aMule
15:37:34 <vincenz> using huffman
15:38:06 <vincenz> would be neat to run cairo ghc apps on the ipod
15:38:14 <vincenz> :D
15:38:53 <Cale> for my favourite artists, I even have the icons on the directories in Nautilus set as the album covers :)
15:38:55 <vincenz> anyways I've been thinkign... how much power does USB2 give you?
15:39:02 <vincenz> more or less
15:39:35 <vincenz> anyone? gross estimate on ipod power consumption?
15:40:08 <palomer> hrm, seriously, we should have this thing called the musicnet, where all your music follows you around wherever you are!
15:40:11 <vincenz> or ipod nano for that matter, given how it has the same cpu
15:40:26 <vincenz> palomer: yeah I foresee in the future that people will have something like an ipod but smaller
15:40:32 <vincenz> they step into a car, stick it into the carradio
15:40:33 <vincenz> get home
15:40:36 <vincenz> stick it into their hifi
15:40:43 <vincenz> get to work, stick it into their desktop
15:40:56 <palomer> why need to stick it anywhere?
15:41:01 <palomer> you should be able to download it on the fly
15:41:07 <vincenz> I've already seen hifi's for ipod, they look neat, a foot wide large flat speaker
15:41:11 <vincenz> with a stand in the front to place the ipod in
15:41:13 <palomer> from waves in the sky
15:41:25 <vincenz> I like carrying stuff with me
15:41:31 <palomer> and listen to music till you die
15:41:32 <vincenz> net goes down, yer fckd
15:41:42 <palomer> that's true regardless
15:41:45 <vincenz> but returning to ...
15:41:52 <vincenz> how much power does the ipod nano consume
15:41:57 <vincenz> let's assume 100mW?
15:42:06 <palomer> it's pretty low
15:42:08 <vincenz> or for that matter even .5W?
15:42:24 <vincenz> well they all have a dualcore
15:42:26 <palomer> google!
15:42:30 <palomer> @google ipod music consumption
15:42:32 <lambdabot> http://pda.physorg.com/lofi-news-music-ipod-said_10106.html
15:42:37 <palomer> @google ipod nano power consumption
15:42:39 <lambdabot> http://www.zeropaid.com/news/6147/New+iPod+nano+uses+human+skin+to+
15:42:39 <lambdabot> transmit+audio/
15:42:42 <vincenz> so...200 cpus = 100 ipods = 500W....
15:42:49 <palomer> whoa
15:42:49 <vincenz> and you have some nice parallel processing
15:43:05 <vincenz> at the powerconsumtion of a desktop
15:44:12 <vincenz> even the nanos have dual core and 64MB
15:44:33 <vincenz> that would make a great massivemultiprocessor
15:44:44 <vincenz> just a nice plate to stick 100 nanos into
15:44:52 <vincenz> that takes care of IP-routing
15:45:07 <palomer> supercomputing nanos eh?
15:45:28 <vincenz> well they're dualcore 425Mh
15:45:32 <vincenz> not exactly nothing
15:45:36 <vincenz> iirc
15:46:18 <palomer> 425 mega hertz?
15:46:20 <palomer> are you nuts?
15:47:58 <vincenz> what?
15:50:23 <vincenz> hmm
15:50:26 <vincenz> you're right
15:50:28 <vincenz> that's excessive
15:51:17 * vincenz coughs
15:51:22 <vincenz> dual 32-bit ARM7 
15:51:25 <vincenz> up to 80mhz
15:51:35 <vincenz> ./core
15:51:54 <vincenz> http://www.portalplayer.com/products/documents/5020_Brief_0108_Public.pdf
15:52:31 <vincenz> heh... that cpu has integrated firewire, yet ipods don't support it
15:53:06 <vincenz> ooh and it can support 640x480 tfts
15:53:19 <fluxx> are you sure they have exactly that model?
15:53:27 <vincenz> yes
15:53:36 <vincenz> someone did a vivisection
15:53:39 <vincenz> its on the ipodlinux site
15:53:51 <vincenz> woah
15:54:12 <fluxx> funny, then, as in those volumes you want to save on _everything_, and a cpu supporting tft's and firewire doesn't sound like its the cheapest
15:54:17 <vincenz> Four controller inputs enabling next-generation multi-dimension human interface contrllers such as 3D joysticks and XYZ controllerse
15:54:27 <vincenz> fluxx: bs
15:54:35 <vincenz> fluxx: companies make multiprupose chips
15:54:41 <vincenz> cause it's too expensive to custom make chips
15:54:50 <vincenz> so they make chips with a lot of stuff on it so they can sell vast amounts
15:54:56 <vincenz> it's the trend
15:55:02 <fluxx> yes, but firewire and tft-controller?-o
15:55:06 <vincenz> yes
15:55:07 <vincenz> it's in there
15:55:10 <fluxx> actually usb can be found often
15:55:10 <vincenz> check the spex
15:55:15 <vincenz> it has usb too
15:55:22 <vincenz> integrated on chip
15:55:44 <vincenz> it even has optosensorsto enable 3d-joystick style controllers
15:55:56 <fluxx> but, off to school
15:56:01 <vincenz> likewise
15:56:07 <fluxx> (..5 minutes)
15:56:45 <palomer> wasn't apple big on firewire?
15:56:51 <vincenz> damn
15:56:55 <vincenz> 6 dma channels
15:57:10 <vincenz> palomer: afaik yes
15:57:27 <palomer> yet there's no firewire on ipods
15:57:28 <palomer> strange
15:57:35 <vincenz> and the cpu supports it :D
15:57:59 <vincenz> o.O
15:58:18 <vincenz> that chip even has tv-out 
15:59:31 <vincenz> I wonder if you can access the opto-sensors
15:59:35 <vincenz> through code
15:59:41 <vincenz> that would make for some cool games
16:00:07 <ncalexan> palomer: my iPod is firewire.  3rd gen.
16:00:18 <ncalexan> But I think all the later are firewire too.
16:00:23 <vincenz> hmm
16:00:23 <ncalexan> Dual firewire/usb.
16:00:28 <vincenz> then I must have misread
16:00:36 <vincenz> I remembered reading somewhere it didn't do firewire
16:00:40 <vincenz> my mistake :/
16:01:17 <ncalexan> It could be that it uses a simplified protocol and just uses the wire, meaning that it doesn't play nice with other controllers... but I don't know.
16:02:02 <palomer> vincenz: can't you just look on your ipod to see if it has the firewire jack?
16:02:08 <vincenz> palomer: it only has one jack
16:02:10 <vincenz> and I use that for usb
16:02:18 <vincenz> the ipod side is flat and wide
16:02:33 <vincenz> no firewire cable came with it
16:02:46 <vincenz> anyways... I wonder if they'll come out with a keyboard for it
16:03:11 <vincenz> like the foldable keyboard for those palmtops
16:03:35 <ncalexan> The flat jack outs to firewire for me :)  It's dual...
16:03:44 <vincenz> then all you'd have to do is crosscompile ghc for ARM
16:03:49 <vincenz> and you'd be set :)
16:05:22 <vincenz> anyone know if ghc has an ARM backend/
16:20:50 <sethk> how do I convert a real to an integer?
16:21:03 <ncalexan> round, floor, ceiling.
16:21:46 <sethk> ncalexan, thanks.  I just saw quot in the prelude, which also seems to do it.
16:21:55 <sethk> ncalexan, quot the same as floor?
16:22:05 <ncalexan> Shouldn't be... rem quot are for integral types, no?
16:22:08 <ncalexan> @where quot
16:22:08 <lambdabot> I know nothing about quot.
16:22:12 <ncalexan> @hoogle quot
16:22:13 <lambdabot> Prelude.quot :: Integral a => a -> a -> a
16:22:13 <lambdabot> Prelude.quotRem :: Integral a => a -> a -> (a, a)
16:22:13 <lambdabot> Text.PrettyPrint.HughesPJ.quotes :: Doc -> Doc
16:22:20 <sethk> ncalexan, yes, but my question was not phrased well
16:22:34 <sethk> ncalexan, I was converting to integer because a calculation had done a conversion to fractional
16:22:47 <ncalexan> Ah, that's different :)
16:49:40 <sethk> suggestions on measuring how long something takes, with granularity better than one second?
16:53:26 <sieni> sethk: on unix you can use gettimeofday()
16:54:43 <sethk> sieni, yes, I know, and haskell has that, but I'm only getting one second resolution out of it, unfortunately.
16:55:34 <sieni> ?
16:55:53 <sethk> there is a picoseconds in the type, but it contains garbage as far as I can tell.
16:56:18 <sethk> possibly not, possibly the show function for it is borked and the actual value is ok
16:56:23 <sieni> picoseconds? the struct should contain microseconds
16:56:24 <sethk> hard to tell which
16:56:32 <sethk> sieni, in unix, yes, but the haskell one uses picoseconds
16:57:51 <sieni> ok
16:58:48 <sethk> sieni, I guess they were planning for future picosecond resolutions, or something  :)
17:21:32 <vincenz> re @work
17:36:41 <astrolabe> @hoogle getClockTime
17:36:42 <lambdabot> System.Time.getClockTime :: IO ClockTime
17:37:41 <astrolabe> @hoogle getCPUTime
17:37:42 <lambdabot> System.CPUTime.getCPUTime :: IO Integer
17:49:09 <sethk> getCPUTime is cpu time consumed by the process making the call
17:49:27 <sethk> I wonder if it's possible to just get the cpu click
17:49:35 <sethk> I can do an ffi thing, I guess, if necessary
18:08:23 <EtnaRosso> morning all
18:12:40 <vincenz> EtnaRosso: Buongiorno
18:13:21 <EtnaRosso> vincenz are you italian?
18:13:24 <vincenz> no
18:13:28 <vincenz> but I lived there most of my life
18:13:44 <vincenz> sicilano per caso?
18:17:36 <EtnaRosso> yes from Catania
18:17:46 <EtnaRosso> could you help me with monads?
18:18:51 <vincenz> certainly
18:19:38 <vincenz> spara pure
18:27:26 <EtnaRosso> ok at first monad definition
18:27:44 <EtnaRosso> I should define return and >>= ok?
18:27:51 <ski> right
18:28:40 <EtnaRosso> to use monad sould i use the >>= that i have defined?
18:29:15 <EtnaRosso> or some "access function" that use >>=?
18:31:14 <cpatrick> EtnaRosso: it's more common to use 'do' notation
18:31:54 <EtnaRosso> yes but do i understand that  create some sort of "chains" or sequence of actions
18:32:30 <vincenz> do x; a <- y; z 
18:32:31 <vincenz> ==
18:32:42 <vincenz> x >> y >>= \a -> z
18:33:42 <EtnaRosso> ok suppose that we have x >>= f = something on f
18:33:46 <EtnaRosso> in the definition
18:34:28 <EtnaRosso> first question x is a generic item in the monad space?
18:34:47 <vincenz> x should be M a
18:34:54 <vincenz> for any a
18:35:02 <vincenz> (obviously the input type for f)
18:35:09 <vincenz> let f : a -> b
18:35:13 <vincenz> then x : M a
18:35:20 <ski> f :: a -> M b
18:35:26 <vincenz> correct
18:35:31 * vincenz smacks himself
18:36:05 <ski> so 'x' is any M-action, yes
18:37:01 <ski> (EtnaRosso : btw, i think xerox is italian)
18:41:15 <EtnaRosso> then suppose that i have x >>= f = g f
18:41:37 <ski> what is 'g' ?
18:41:55 <EtnaRosso> where, if i understand, f :: a -> b and g f :: a -> M b
18:42:16 <EtnaRosso> g is an unspecifief "functor"
18:42:53 <EtnaRosso> g f :: a -> M b or g f :: Ma -> Mb
18:42:58 <ski> x :: M a
18:43:02 <ski> f :: a -> M b
18:43:05 <ski> should be the case
18:43:28 <ski> and the right-hand-side of the equation clause should have type 'M b'
18:43:45 <ski> btw, which monad is this ?
18:43:57 <ski> what's the definition of the monad type constructor ?
18:44:27 <EtnaRosso> let me se the MayBe monad
18:46:05 <ski> ok
18:46:37 <ski> so, you should prolly pattern-match against the possible forms of the left argument to '(>>=)'
18:48:01 <EtnaRosso> lambdabot url
18:48:14 <ski> lisppaste2 : url?
18:48:14 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:48:21 <EtnaRosso> thanks
18:48:51 <EtnaRosso> i neeed just one minute to setup my own monad
18:52:01 <lisppaste2> EtnaRosso pasted "Incomplete Set Monad" at http://paste.lisp.org/display/17439
18:53:10 <EtnaRosso> now i need a definition of >>= such that applyng a function f on a set, it returns a set of elementts f x(x in Set)
18:54:48 <EtnaRosso> it could be similar to the list monad
18:56:41 <EtnaRosso> for example let 	s >>= f=EmptySet the definition of >>=
18:57:46 <ski> i thought you were doing a 'Maybe' monad ?
18:58:49 <ProfTeggy> Something like  s >>= f = nub $ map f s   ? 
18:58:54 <EtnaRosso> excuse me i prefeer this new monad
18:59:02 <kzm> I'm trying to FFI to a library - must it be in the form of a .so (I only have a .a)?
18:59:23 <EtnaRosso> ProfTeggy i cant understand
18:59:53 <ProfTeggy> Map function f, then remove duplicates (nub), are you trying to define a Set monad?
18:59:56 <ProfTeggy> I came in late.
19:00:09 <EtnaRosso> yes but my definition is uncorrect?
19:00:22 <ProfTeggy> I haven't seen your definition
19:00:35 <EtnaRosso> s >>= f = EmptySet
19:00:52 <EtnaRosso> return EmptySet on every function
19:01:04 <ProfTeggy> And constructor EmptySet represents the empty set { } ?
19:01:23 <ProfTeggy> What's the intention behind such a def'n?  
19:01:33 <ProfTeggy> Looks weird to me.
19:01:42 <EtnaRosso> i0m tryng to define and use a monad
19:01:46 <ski> <lisppaste2> EtnaRosso pasted "Incomplete Set Monad" at http://paste.lisp.org/display/17439
19:01:47 <EtnaRosso> leraning intent
19:01:56 <EtnaRosso> learning
19:02:09 <ProfTeggy> Aha... a set in insertion representation
19:02:12 <ProfTeggy> Thanks, ski
19:02:39 <ProfTeggy> EtanRosso, as it happes, I wrote a complete thesis on monads over such insertion types (and monad comprehensions over such types)
19:02:51 <ProfTeggy> s/happes/happens/
19:03:00 <ProfTeggy> You're welcome to read it -)
19:03:04 <lisppaste2> EtnaRosso annotated #17439 with "Fun Set Monad" at http://paste.lisp.org/display/17439#1
19:03:08 * ski smiles
19:03:31 <EtnaRosso> Teggy are you really a teacher?
19:03:39 * ProfTeggy nods
19:03:42 <EtnaRosso> url me your dissertation
19:03:49 <ProfTeggy> Yes, Sir!
19:04:07 <EtnaRosso> great!
19:04:17 <EtnaRosso> so teach me to use monads ;)
19:04:30 <ProfTeggy> http://www.ub.uni-konstanz.de/kops/volltexte/1999/312/312_1.pdf
19:04:42 <ProfTeggy> You study the text, then come back to me :-P
19:05:00 <kosmikus> :)
19:05:23 <EtnaRosso> thanks
19:05:39 <EtnaRosso> but the question now is: How can i use this set monad?
19:06:17 <ski> first, is it indeed a valid monad definition ?
19:06:19 <ProfTeggy> You can use do notation to perform set computation (once your monad def'n makes sense)
19:06:51 <ski> does the monad laws hold ?
19:07:08 <ski> forall x. x >>= return = x
19:07:14 <ski> is one of the laws
19:07:26 <EtnaRosso> i try typing EmptySet >>= \x -> (x + 1)
19:07:46 <ski> try 'EmptySet >>= return'
19:07:53 <EtnaRosso> ?
19:08:14 <ski> 'EmptySet >>= \x -> return x' if you like
19:08:25 <EtnaRosso> what should it do?
19:08:42 <EtnaRosso> by now i can't understand the semantic of return
19:09:04 <EtnaRosso> it tell me "No instance for Show (Set a)
19:09:06 <ski> it should return the left argument to '(>>=)' according to the monadic law i stated above
19:09:11 <ProfTeggy> If your monad models a collection, think of return as an injection, or singleton collection
19:09:17 <ski> ok, try
19:09:51 <ski> (EmptySet >>= \x -> return x) :: Set Int
19:10:05 <ski> after adding 'deriving Show' to the definition of the datatype
19:11:37 <EtnaRosso> good
19:12:02 <ski> also try '((Insert 0 EmptySet) >>= \x -> return x) :: Set Int'
19:12:18 <ski> (that should return 'Insert 0 EmptySet', of course)
19:13:17 <EtnaRosso> return EmptySet
19:13:21 <EtnaRosso> intresting
19:13:28 <ski> this means that you have a bug
19:13:41 <EtnaRosso> it is the definitio of >>=
19:13:46 <ski> i.e. what you have defined isn't really a monad
19:13:56 <EtnaRosso> yes i know
19:14:16 <ski> so, you need to try to adapt the definition of '(>>=)'
19:16:37 <ProfTeggy> For this, I'd propose to write fromSet :: Set a -> [a] and toSet :: [a] -> Set a functions
19:16:48 <ProfTeggy> This is left as an exercise.
19:17:28 <ProfTeggy> Alternatively, you can write setMap :: (a -> b) -> Set a -> Set b
19:19:59 <EtnaRosso> yes i'm using setMap
19:21:30 <lisppaste2> EtnaRosso annotated #17439 with "Set Monad that doesn't work" at http://paste.lisp.org/display/17439#2
19:22:35 <ProfTeggy> EtanRosso, the order of f and EmtySet in the arguments of setMap is swapped
19:23:43 <lisppaste2> EtnaRosso annotated #17439 with "Set Monad with setMap" at http://paste.lisp.org/display/17439#3
19:24:41 <EtnaRosso> and now?
19:24:52 <ProfTeggy> This won't work
19:25:40 <EtnaRosso> no i have a type error loading it
19:25:51 <ProfTeggy> Sure
19:26:00 <ProfTeggy> The type of >>= doesn't fit the Monad class
19:26:38 <EtnaRosso> ...
19:26:53 <ProfTeggy> (back to some real work)
19:28:33 <EtnaRosso> so am i thank you
20:04:59 <lisppaste2> cmarcelo annotated #17439 with "Set Monad, or List Monad? =)" at http://paste.lisp.org/display/17439#4
20:05:55 <cmarcelo> EtnaRosso, take a look at the code I just pasted..
20:06:58 <araujo> morning
20:07:52 <ski> cmarcelo : list monad, basically :)
20:08:19 <EtnaRosso> ok but why the mine doesn't work?
20:08:39 <cmarcelo> ski: yep =) but changin setUnion would make it a Set?
20:09:05 <Mitar> is it possible to construct an infinite list ob boolean value which does not repeat itself with only recursive list syntax?
20:09:35 <EtnaRosso> no obviously
20:09:37 <ski> EtnaRosso : 'f' has type 'a -> M b' in '(>>=)', when you 'setMap' it over 'x' (of type 'M a') you get 'M (M b)', not 'M b' which is the expected result type
20:10:58 <cmarcelo> these monad laws are necessary only for make do-notation work or other monad functions take them as granted?
20:11:24 <ski> cmarcelo : latter
20:11:29 <ski> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); foo = repeat False /\/ map not foo in take 20 foo
20:11:29 <lambdabot> [False,True,False,False,False,True,False,True,False,True,False,False,
20:11:29 <lambdabot> False,True,False,False,False,True,False,False]
20:11:45 <ski> Mitar : does that suffice ?
20:12:02 <ski> > let [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs); foo = repeat 0 /\/ map (+ 1) foo in take 20 foo
20:12:03 <lambdabot> [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2]
20:12:26 <ski> (i hope you see that that is not repeating itself)
20:13:09 <ski> (Mitar : not fully sure what you mean by 'recursive list syntax')
20:13:56 <Mitar> let l = 1 : 2 : l
20:13:57 <Mitar> :-)
20:14:00 <Mitar> for example
20:14:08 <ski> that is repeating
20:14:13 <Mitar> i know
20:14:13 <ski> l = cycle [1,2]
20:14:13 <Mitar> :-)
20:15:41 <Mitar> so only with this syntax (without using some recursive functions) it is not possible to construct it?
20:18:49 <ski> l = [even x | x <- [0..]]
20:18:52 <ski> is that allowed ?
20:19:42 <Mitar> ehm ..
20:19:56 <Mitar> i am just curious
20:20:23 <Mitar> let say it is ...
20:20:41 <ski> though, of course that is repeating
20:20:43 <ski> say
20:23:07 <ski> l = [x == ((\y -> y*y) . floor . sqrt . fromIntegral $ x) | x <- [0..]]
20:23:09 <ski> instead
20:23:17 <Mitar> lol
20:23:22 <ski> > take 50 [x == ((\y -> y*y) . floor . sqrt . fromIntegral $ x) | x <- [0..]]
20:23:23 <lambdabot> [True,True,False,False,True,False,False,False,False,True,False,False,
20:23:23 <lambdabot> False,False,False,False,True,False,False,False,False,False,False,False,
20:23:23 <lambdabot> False,True,False,False,False,False,False,False,False,False,False,False,
20:23:23 <lambdabot> True,False,False,False,False,False,False,False,False,False,False,False,
20:23:23 <lambdabot> False,True]
20:23:44 <ski> (that has a 'True' on only square indices)
20:24:00 <Mitar> ok ..
20:24:23 <tromp_> that reminds me of a nice puzzle
20:24:40 <Mitar> it is not nicer than my solution with counting falses from 0 to infinity and inserting true between
20:24:47 <Mitar> :-)
20:24:48 <ski> but, i think if you just allow recursive list construction and consing elements, then it is not possible
20:25:03 <Mitar> True, True, False, True, False, False, True, False, False, False, True ...
20:25:26 <Mitar> i also think this way ...
20:26:32 <ski> > take 50 [any (x ==) . (\y -> y*(y+1)/2) $ [0..x] | x <- [0..]]
20:26:33 <lambdabot>  add an instance declaration for (Fractional [a])
20:26:33 <lambdabot>   In a lambda abstraction: \ y -> (y * (y + 1)) / 2
20:27:06 <ski> > take 50 [any (x ==) . map (\y -> y*(y+1) `div` 2) $ [0..x] | x <- [0..]]
20:27:07 <lambdabot> [True,True,False,True,False,False,True,False,False,False,True,False,False,
20:27:07 <lambdabot> False,False,True,False,False,False,False,False,True,False,False,False,
20:27:07 <lambdabot> False,False,False,True,False,False,False,False,False,False,False,True,
20:27:07 <lambdabot> False,False,False,False,False,False,False,False,True,False,False,False,
20:27:07 <lambdabot> False]
20:29:24 <EtnaRosso> excuse me
20:29:57 <EtnaRosso> but cmarcelo you say that setMap f s returns a Set of Sets?
20:31:45 <vincenz> buongiorno a tutti
20:31:47 <Mitar> thanks
20:32:15 <vincenz> ski, smettila di fare il pirla
20:36:10 <k1ngz0r> I cant load a file in windows witch i can load in red hat. And ghci tells me that it can´t find this : Graphics.UI.WXCore any ideas?
20:36:26 <vincenz> you don't have the lib installed in windows
20:37:13 <k1ngz0r> ok. Is there a substitute wich I can use? 
20:37:38 <ski> (vincenz : i wonder what that means ..)
20:39:31 <cmarcelo> EtnaRosso, when f :: a -> Set a, "setMap f s" returns Set of Sets. f could be the return function, for example..
20:39:56 <vincenz> (ski: you don't want to know)
20:42:28 <EtnaRosso> right but in our case?
20:43:47 <kzm> I don't suppose it is possible to construct CStrings from pure code?
20:49:25 <cmarcelo> EtnaRosso, try for example to think about "Insert 0 EmptySet >>= return".. evaluating we get "setFlat (setMap return (Insert 0 EmptySet))".. and return always wraps his argument in a set..
20:50:08 <EtnaRosso> i understant it is for the case of Set fo Sets
20:52:43 <resiak> There isn't a predefined function (say) orderedElem e = (elem e . takeWhile (<= e)), is there?
21:39:00 <vincenz> @type elem
21:39:01 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:39:30 <vincenz> resiak: that's quite specific as it expects a sorted list
21:39:58 <vincenz> > 3 `elem` (fromList [1,2,3])
21:39:59 <lambdabot>  Not in scope: `fromList'
21:40:03 <vincenz> > 3 `elem` (Set.fromList [1,2,3])
21:40:04 <lambdabot>  Not in scope: `Set.fromList'
21:40:08 <vincenz> > 3 `elem` (Data.Set.fromList [1,2,3])
21:40:08 <lambdabot>  Not in scope: `Data.Set.fromList'
21:40:17 <vincenz> > 3 `elem` (S.fromList [1,2,3])
21:40:18 <lambdabot> Couldn't match `[a]' against `Data.Set.Set a1'
21:40:22 <vincenz> > 3 `S.elem` (S.fromList [1,2,3])
21:40:23 <lambdabot>  Not in scope: `S.elem'
21:40:32 <vincenz> @hoogle a -> Set a 
21:40:32 <lambdabot> Data.Set.singleton :: a -> Set a
21:40:32 <lambdabot> Data.Set.unitSet :: a -> Set a
21:40:32 <lambdabot> Data.Set.empty :: Set a
21:40:36 <vincenz> @hoogle a -> Set a  -> Bool
21:40:37 <lambdabot> Data.Set.member :: Ord a => a -> Set a -> Bool
21:40:37 <lambdabot> Data.Set.elementOf :: Ord a => a -> Set a -> Bool
21:40:37 <lambdabot> Data.Set.null :: Set a -> Bool
21:40:42 <chrisbro1n> hi all
21:40:44 <vincenz> > 3 `S.member` (S.fromList [1,2,3])
21:40:45 <lambdabot> True
21:43:56 <vincenz> @type fmap
21:43:57 <lambdabot> forall (f :: * -> *) b a.
21:43:57 <lambdabot>    (Functor f) =>
21:43:57 <lambdabot>    (a -> b) -> f a -> f b
21:44:21 <vincenz> > (S.fromList [1,2,3,4]) `fmap` (\x -> x `mod` 2)
21:44:22 <lambdabot> Couldn't match `Data.Set.Set a' against `t -> t1'
21:44:43 <vincenz> > (\x -> x `mod` 2) `fmap` (S.fromList [1,2,3,4])
21:44:43 <lambdabot>  add an instance declaration for (Functor Data.Set.Set)
21:44:43 <lambdabot>   In the definition of `pnn':
21:44:43 <lambdabot>    pnn = (\ x -> x `mod` 2) `fmap` (Data.Set.fromList [1, 2, 3, 4])
21:44:53 <vincenz> > S.toList $ (\x -> x `mod` 2) `fmap` (S.fromList [1,2,3,4]) 
21:44:54 <lambdabot>  add an instance declaration for (Functor Data.Set.Set)
21:45:07 <vincenz> @hoogle Set a -> [a]
21:45:08 <lambdabot> Data.Set.elems :: Set a -> [a]
21:45:08 <lambdabot> Data.Set.toList :: Set a -> [a]
21:45:08 <lambdabot> Data.Set.toAscList :: Set a -> [a]
21:48:16 <nik> hiya
21:49:12 <ValarQ> hello
21:50:07 <nik> http://nopaste.php-q.net/195652 <-- I do not understand what's wrong..."argument out of range", any hint? :)
21:51:40 <ValarQ> it works with ghc
21:54:06 <vincenz> oy
21:54:13 <vincenz> nik: thtat's a very unhaskellish way to do it
21:55:48 <ibid> hrm, anybody think of a good arrows exercise? (something like, "define an arrow type for such and such" or "given this arrow type. write such and such an arrow that belongs to that type"?
21:57:07 <nik> vincenz, had just some lessons in haskell (school)
21:57:08 <nik> hm
21:57:53 <resiak> vincenz: fair enough.
21:58:01 <nik> vincenz, which way do you prefer?
21:58:04 <vincenz> here's a better way
21:58:53 <vincenz> let newton a x = heada $ dropWhile end_condition $ iterate do_newton x
21:58:53 <vincenz>   where do_newton x     = (x - (x^2 - a)/ 2*x)
21:58:53 <vincenz>         end_condition x = (x**2 -a)/2*x > 0.0000001
21:59:00 <vincenz> whoops...make that head, not head
21:59:02 <vincenz> whoops...make that head, not heada
21:59:03 <vincenz> @hoogle head
21:59:04 <lambdabot> Data.List.head :: [a] -> a
21:59:04 <lambdabot> Prelude.head :: [a] -> a
21:59:04 <lambdabot> Data.PackedString.headPS :: PackedString -> Char
21:59:53 <vincenz> and without the let obviously
21:59:57 <nik> do not looks like shorter :x
22:00:13 <vincenz> no but the advantage is
22:00:18 <vincenz> you can use separae functons
22:00:24 <vincenz> and then you can use other conditioins on that infinitie list
22:00:38 <nik> icbt, thx
22:00:40 <nik> ic
22:00:48 <vincenz> ini fact
22:00:52 <vincenz> there's a great article on this
22:01:03 <vincenz> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
22:01:04 <vincenz> read that
22:01:08 <vincenz> its' rather lightweight
22:01:14 <vincenz> and great as intro to haskell thinking
22:01:49 <vincenz> it'll show you how it's easy to combine such infinite list functions to make very good numerical approximation methods
22:02:44 <vincenz> btw, what does that function appproximate?
22:02:58 <vincenz> sqrt>
22:02:59 <vincenz> ?
22:05:04 <nik> ("newton"?)
22:05:12 <vincenz> you might want an "abs" in there
22:05:14 <vincenz> for that condition
22:05:25 <vincenz> @hoogle abs
22:05:25 <lambdabot> Prelude.abs :: Num a => a -> a
22:05:25 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
22:05:25 <lambdabot> Language.Haskell.Syntax.HsEAbs :: HsQName -> HsExportSpec
22:06:36 <vincenz> and it seems to be off
22:06:38 <vincenz> I removed the condition
22:06:44 <vincenz> newton a x = head $ dropWhile end_condition $ iterate do_newton x
22:06:44 <vincenz>   where do_newton x     = (x - (a - x*x)/ 2*x)
22:06:44 <vincenz>         end_condition x = (x*x -a)/2*x > 0.0000001
22:06:59 <vincenz> *Main> take 10 $ newton 2 5
22:06:59 <vincenz> [5.0,-52.5,72246.5625,-1.8854784300132397e14,3.351465163981843e42,-1.882236249294709e127,Infinity,NaN,NaN,NaN]
22:07:54 <vincenz> newton a x = iterate do_newton x where do_newton x     = (x - (x*x -a)/ 2*x)
22:11:49 <vincenz> let newton a b = iterate (\x -> x - (x*x-a)/2*x) b in take 10 $ newton 2 5
22:11:55 <vincenz> > let newton a b = iterate (\x -> x - (x*x-a)/2*x) b in take 10 $ newton 2 5
22:11:55 <lambdabot> [5.0,-52.5,72246.5625,-1.8854784300132397e14,3.351465163981843e42,-1.
22:11:55 <lambdabot> 882236249294709e127,Infinity,NaN,NaN,NaN]
22:12:02 <vincenz> that seriously diverges
22:14:12 <vincenz> hmm seems it'll only work if you start with number > 0 and < 2
22:27:09 <Lemmih> Bah. Parsing comments as '--Compiled C--' is annoying.
22:28:11 <chrisbro1n> does anyone here use quickCheck?
22:28:26 <Lemmih> Yep.
22:28:28 <vincenz> used t before
22:28:29 <chrisbro1n> or do you find induction is more useful?
22:32:10 <EtnaRosso> re all
22:32:34 <vincenz> ciao
22:37:33 <EtnaRosso> vincenz!
22:39:19 <vincenz> :)
22:44:17 <EtnaRosso> libpaste url
22:44:48 <chrisbro1n> if i have the following data type:
22:44:58 <chrisbro1n> data New = Int `Con1` Int Int
22:45:20 <chrisbro1n> con1 must be referenced in a pattern as an application? ...
22:45:26 <chrisbro1n> f (Con1 x y z) = ...
22:45:27 <chrisbro1n> ?
22:46:11 <Lemmih> Int `Con1` Int Int => (Int) `Con1` (Int Int), I think.
22:46:41 <Igloo> That's not a valid data declaration (Int Int is ill-kinded)
22:46:56 <chrisbro1n> ah
22:47:10 <chrisbro1n> well the data declaration parses
22:47:15 <chrisbro1n> but the pattern does not
22:47:31 <Igloo> It parses, but it fails during type checking
22:47:50 * chrisbro1n remembers Hare does not yet use the type checker
22:47:50 <chrisbro1n> ah
22:47:52 <Igloo> Try just that declaration ina file of its own
22:47:56 <chrisbro1n> ok...
22:48:53 <chrisbro1n> thanks 
22:49:00 <chrisbro1n> its not a valid declaration
22:49:08 <chrisbro1n> that makes my life easier
22:49:43 <EtnaRosso> let me begin the last part of this live tutorial about monads
22:50:00 <EtnaRosso> suppose that we have defined the our set monad as in http://paste.lisp.org/display/17439#4
22:50:12 <EtnaRosso> the question now is how to use it?
22:51:09 <EtnaRosso> typing EmptySet >>= \x -> (x + 1) it return an error
22:51:28 <EtnaRosso> "No Instance for (Num (Set b))
22:51:41 <Lemmih> Try: EmptySet >>= \x -> return (x+1)
22:52:01 <MarcWeber> @index foldrM
22:52:02 <lambdabot> bzzt
22:52:49 <MarcWeber> How to get the function foldrM from base.Data.Foldable ?
22:53:47 <EtnaRosso> good it works thank you Lemmih
22:56:58 <MarcWeber> No one any idea?
22:57:22 <Lemmih> MarcWeber: base.Data.Foldable?
22:57:31 <Lemmih> MarcWeber: How about using foldM?
22:58:37 <ProfTeggy> No snow in the past ten minutes -- I guess this must be Spring
22:58:40 <MarcWeber> ghc-pkg describe base doesn't liste Data.Foldable as exposed-module.. . That's the reason.
22:58:50 <MarcWeber> 6.4.2 isn't new enough ;-(
23:00:14 * MarcWeber grasps some snow and throws a small soft ball in the direction of ProfTeggy ... ;-) I won't be able to do this, soon
23:03:28 <MarcWeber> Lemmih I need to iterate through a list of dependencies .. in case of AND I want to get the latest modification time. in case of OR I want to get the modification time of the first element which exists..
23:03:58 <Lemmih> MarcWeber: And foldM won't do?
23:06:00 <MarcWeber> At the moment it looks like this (ugly.. ) http://www.rafb.net/paste/results/HIdaOm59.html.. it will.
23:06:37 <MarcWeber> I can use a function returning Nothing or the date if the dependency exists.. and then use the maximum function or the first element not beeing nothing ..
23:09:13 <EtnaRosso> bu why?
23:09:47 <EtnaRosso> what is the signature of >>=?
23:10:10 <ibid> @type (>>=)
23:10:11 <lambdabot> forall (m :: * -> *) b a.
23:10:11 <lambdabot>    (Monad m) =>
23:10:11 <lambdabot>    m a -> (a -> m b) -> m b
23:10:30 <MarcWeber> Lemmih I think it will even become more readable.. ;-)
23:10:50 <EtnaRosso> great thanks
23:22:20 <NotInventedHere> Hello, what is the state of the art in terms of date/time libraries for haskell?
23:25:08 <EtnaRosso> what about quantifiers?
23:25:16 <Lemmih> NotInventedHere: http://semantic.org/TimeLib/
23:25:28 <Lemmih> Or:
23:25:29 <Lemmih> @docs System.Time
23:25:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.
23:25:30 <lambdabot> html
23:26:53 <NotInventedHere> Limmih, lambdabot, thanks!
23:40:48 * shapr tries to setup Postmaster
23:42:26 <MarcWeber> lambdabot shouldn't break links into lines, should she? ;-)
23:42:47 <shapr> fix it!
23:49:25 <shapr> Anyone else tried to build Postmaster?
23:59:00 <shapr> Yay, I built Postmaster! Now to see if I can use it to replace postfix...
