00:54:33 <shapr> Sure is quiet today.
00:54:50 <shapr> Hey, I was thinking about a weekly Haskell contest along the lines of songfight.org
00:56:35 <shapr> I always read Chicxulub (Yucatan) as "chixuclub"
00:56:55 <shapr> So, has anyone used JHC for larger sized programs?
01:00:03 * shapr throws lambdas
01:00:58 <kuvkir> hello folks. please show me the starting point from which i should learn haskell..
01:02:26 <shapr> privet kuvkir, welcome to #haskell!
01:02:42 <shapr> @learn
01:02:42 <lambdabot> http://www.haskell.org/learning.html
01:03:02 <shapr> That page on haskell.org collects a bunch of different resources.
01:03:25 <shapr> You might like "Yet Another Haskell Tutorial" - http://www.isi.edu/~hdaume/htut
01:03:27 <Muad_Dibber> kuvkir, also, after following up from that link, feel free to ask in here. shapr is such a cool guy he's always willing to help!
01:03:51 <shapr> or "Write Yourself a Scheme in 48 Hours" http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
01:04:22 <shapr> There's also "Haskell for C Programmers" and a bunch of other introductions.
01:04:30 * shapr feels cool!
01:04:47 <shapr> Muad_Dibber: I always thought I was so cool because I live 40 miles south of the arctic circle!
01:04:58 * shapr shivers
01:05:07 <sieni> shapr: aren't you living in stockholm now?
01:05:14 <shapr> Not till July
01:05:20 <Muad_Dibber> shapr, don't put me into slimey mode where I tell you you are cool becuase you know so much and help so many people without ever comlaining!
01:05:27 * shapr grins
01:05:37 <shapr> Muad_Dibber: yeh, I'm just being silly :-)
01:06:11 <kuvkir> thanks for the likns guys
01:06:30 <shapr> kuvkir: If you want the instant taste test, check out http://www.haskell.org/hawiki/HaskellDemo
01:06:41 <shapr> Also, lambdabot has bunches of useful tools to help learn and discuss Haskell.
01:06:53 <shapr> > map (+1) [1,2,3]
01:06:54 <lambdabot> [2,3,4]
01:07:01 <shapr> @index anyChar
01:07:01 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
01:07:06 <shapr> @type Data.Char.chr
01:07:07 <lambdabot> Int -> Char
01:07:24 <shapr> kuvkir: As Muad_Dibber said, feel free to ask any questions here.
01:07:47 <kuvkir> shapr: wow nice..
01:08:25 <shapr> kuvkir: Are you learning for fun or for work?
01:09:28 <kuvkir> shapr: just for fun.. but maybe sometimes i shall use it for my work...
01:10:05 <shapr> Have you used any other functional languages?
01:10:57 <integral> hmm, is there something Maybe (a -> b) -> a -> Maybe b ?
01:11:17 <kuvkir> shapr: yes, i know scheme.
01:11:21 <Muad_Dibber> @hoogle Maybe ( a->b)
01:11:22 <lambdabot> No matches, try a more general search
01:11:36 <kuvkir> if it can count as functional language...
01:11:39 <integral> @hoogle Maybe (a -> b) -> a -> Maybe b
01:11:40 <lambdabot> No matches, try a more general search
01:11:47 <shapr> kuvkir: Yes, I think it does.
01:12:26 <shapr> integral: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html#v%3Amaybe ?
01:14:19 <integral> @type Data.Maybe.maybe (const Nothing) (Just .)
01:14:19 <lambdabot> forall b b1.
01:14:19 <lambdabot>                Maybe (b -> b1) -> b -> Maybe b1
01:14:27 <integral> thanks shapr :-)
01:15:58 <Muad_Dibber> > take 3 $ cycle $ map snd $ filter (\x -> let i = fst x in i == 12 || i == 15) $ zip [1..] ['a'..'z']
01:15:59 <lambdabot> "lol"
01:20:53 <integral> @pl \x -> f x >>= g
01:20:53 <lambdabot> (g =<<) . f
01:24:42 <nothingmuch> aye
01:24:46 <nothingmuch> err, wrong channel =)
01:46:24 <shapr> hiya Taral 
01:46:54 <Taral> hi
01:47:03 <Taral> @time shapr
01:47:05 <lambdabot> Local time for shapr is Thu Mar 30 11:46:42 2006
01:47:10 <Taral> Ah, that explains that.
01:47:31 <shapr> ?
01:48:02 <Taral> @time Taral
01:48:03 <lambdabot> Local time for Taral is Thu Mar 30 03:47:44
01:48:11 <Taral> :)
01:48:22 <shapr> ah
01:48:44 <Taral> I've been reading the coq reference manual, trying to see if I can conceive of a cross between coq and haskell.
01:49:15 <shapr> You've seen Xavier's paper about generating executable code (ML?) from ... Coq?
01:49:22 <shapr> I forget which proof assistant he used.
01:52:54 <shapr> Is there a mailing list for JHC?
01:54:33 <shapr> musasabi: Ever tried to build the base libs with JHC?
01:55:30 <Taral> coq 8.0 has extraction that outputs ocaml or haskell from certified code.
01:55:32 <shapr> I'm trying to build Flippi, when I build Text/Html/BlockTable.hs, I get a BlockTable.ho.tmp, but just after it claims to write the ho file, it fails.
01:56:04 <Taral> But coq's really designed to be a proof assistant, not a programming language.
01:56:49 <shapr> What's the difference? ;-)
01:57:43 <shapr> Seriously though, I'm very interested in proof programming.
01:57:53 <Taral> Well...
01:58:02 <Taral> It's clumsy for doing forward inference.
01:58:19 <Taral> Which is something really common/straightforward in a programming language.
01:58:48 <shapr> Epigram and other dependently typed languages are an incremental step towads proof programming.
01:59:01 <Taral> @google epigram
01:59:02 <lambdabot> No Result Found.
01:59:14 <shapr> GADTs are another small step into a level of typing detail that cannot be inferred currently.
01:59:15 <Taral> www.e-pig.org
01:59:20 <Taral> I hate GADTs.
01:59:20 <shapr> @where epigram
01:59:20 <lambdabot> http://www.e-pig.org/
01:59:25 <shapr> Why?
01:59:31 <Taral> They're a clumsy hack.
01:59:39 <shapr> How to do them better?
01:59:40 <Taral> Very expressive and powerful, but not aesthetically pleasing.
01:59:59 <Taral> GADT-hacking is one reason why I wanted to mix coq and haskell.
02:00:17 <Taral> Instead of making ugly looking GADTs, you can use sigma types.
02:02:13 <shapr> Write it up, propose it for Haskell' ;-)
02:02:28 <Taral> No, no.
02:02:45 <Taral> You should be smacked for that.
02:03:15 <shapr> \smack shawn
02:03:21 <shapr> ?smack shapr
02:03:22 <lambdabot> Unknown command, try @list
02:03:24 <shapr> um
02:03:27 <shapr> @slap shapr
02:03:28 * lambdabot slaps shapr
02:03:51 <shapr> Have you checked out Joy?
02:03:59 <Taral> @where Joy
02:03:59 <lambdabot> I know nothing about joy.
02:04:03 <Taral> LOL
02:04:11 <Taral> @where love
02:04:11 <lambdabot> I know nothing about love.
02:04:31 <Taral> Fun!
02:04:38 <Taral> No, I haven't checked out Joy. What is it?
02:05:17 <shapr> @google joy concatenative von thun
02:05:19 <lambdabot> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
02:05:30 <shapr> It's like Forth and Haskell had a love child.
02:05:58 <integral> but were persuaded by Lisp to hide the family resemblence by skipping out syntax...
02:06:06 <shapr> heh, yeah
02:06:16 <shapr> @lambda joy "2 2 2 + +"
02:06:17 <lambdabot> [6]
02:06:26 <Taral> you know, I'd prefer epigram if it didn't try to make the quantum leap with program formatting...
02:06:42 <shapr> I actually like epigram's approach.
02:06:54 <shapr> Of course, I think it should be generalized to type level refactoring...
02:07:10 <Taral> See, the whole point is to augment Haskell with a propositional typespace
02:07:14 <shapr> @lambda joy "5 6 10 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte >"
02:07:16 <lambdabot> unbound variable: unbound_variable_error
02:07:18 <shapr> whoops
02:09:38 <Taral> I did conceive at one point of mixing C and coq.
02:10:02 <Taral> add strict typing and a propositional typespace to C and see what happens. :)
02:11:20 <robokop> is there a way how i could re arrange the items in a list in a random way
02:12:05 <Taral> zip it with random numbers, sort it, strip the numbers?
02:12:14 <integral> Fisher-Yates shuffle?
02:12:38 <Taral> F-Y shuffle wants random access
02:13:07 <robokop> think i'll try your solution taral
02:13:14 <kuvkir> how do you think guys what is the best haskell environment/compiler for learning purposes?
02:13:30 <shapr> kuvkir: I like emacs + ghc, but not everyone prefers that.
02:13:46 <Taral> kuvkir: They're all perfectly good.
02:14:59 <kuvkir> shapr: me likes emacs too. i found haskell-mode. 
02:15:39 <kuvkir> but concerning the compiler.. what is better ghc or hugs? 
02:16:42 <shapr> GHC does a lot more, but can be difficult to compile yourself.
02:16:50 <shapr> If you can get a binary for your platform, you get the best of both worlds.
02:17:17 <Taral> ok sleepy time
02:19:12 <integral> @pl \t -> mkMp (unifyConst' t)
02:19:13 <lambdabot> mkMp . unifyConst'
02:23:11 <integral> @pl \t t' -> unifyConst (t := t')
02:23:11 <lambdabot> (unifyConst .) . (:=)
02:28:56 <Smokey`> quick question, is there anything equivilant to templates in Haskell?
02:29:00 <shapr> Template Haskell
02:29:02 <shapr> quick answer!
02:29:21 <shapr> What sort of templates are you talking about?
02:29:36 <Smokey`> C++ templates
02:29:45 <shapr> What sort of behaviour do you want?
02:29:47 <shrimpx> polymorphism =)
02:30:13 <Smokey`> eg:  template<int Dimensions, class Real> class Point { Real value[Dimensions]; ... };
02:31:24 <shapr> data Maybe a = Nothing | Just a
02:31:36 <shapr> @type (Just 1 :: Maybe Int)
02:31:37 <lambdabot> Maybe Int
02:31:40 <sieni> Smokey`: type classes
02:31:42 <integral> Smokey`: not like that.  Haskell doesn't have native type-level integers.
02:31:43 <shapr> @type (Just 'a' :: Maybe Char)
02:31:44 <lambdabot> Maybe Char
02:31:57 <Smokey`> integral: meh, damn... that means i'm going to have to write alot more code :(
02:32:07 <shapr> I still don't think I understand what you're asking for.
02:32:16 <Smokey`> ahh well, i can get by with just 3D for now, and just have a simple 2D one with no operators/functions for it
02:32:21 <shapr> You want a point that can be what?
02:32:36 <Smokey`> shapr: any number of dimensions, with any data type for the x/y/z/w/... values
02:32:38 <pierre__> Smokey`: typeclasses is your choice
02:32:44 <pierre__> *are
02:32:46 <shapr> Yeah, typeclasses.
02:32:54 <Smokey`> alrighty, ty :)
02:33:17 <shapr> Depending on what you're doing, a point that can be any number of dimensions might be too much trouble.
03:06:17 <shapr> @seen jimapple
03:06:18 <lambdabot> I saw jimapple leaving #ScannedInAvian 17 days, 6 hours, 54 minutes and 6 seconds ago.
03:13:48 <shapr> Hm, who was asking about the connection between functional and relational programming? Was it tennin?
03:19:01 <dcoutts> shapr, so what's the niche for our haskell consultency outfit?
03:20:14 <dcoutts> shapr, I was thinking that while there is probably some work in supporting companies in house development (eg tools & libs support), that programming the new generation of highly threaded cpus might be a good business
03:21:47 <dcoutts> cell is a tricky example, but the 32 thread sparc and things in that direction should be not so hard
03:23:27 <shapr> Yeah, that's one niche.
03:23:40 <shapr> I still think the best niche is exemplified by the ICFP results.
03:23:49 <dcoutts> mmm
03:24:33 <dcoutts> so how would such a company be run?
03:24:48 <shapr> Earlier today I was considering stealing the songfight.org approach and using that to train #haskellers.
03:24:49 <JKnecht> as a professional associaton.
03:24:53 <dcoutts> distributed, part time staff with near zero overhead?
03:24:59 <dcoutts> JKnecht, right
03:25:36 <dcoutts> shapr, what's the songfight.org approach?
03:26:04 <shapr> Weekly contests where the subject of a song is a string, and votes are taken from listeners.
03:26:29 <shapr> I still think that speed of development with maintainable results is the strongest point of Haskell.
03:26:45 <dcoutts> yeah
03:27:01 <robokop> is there a way in which i can make a list of random values but without lifting my function in the IO
03:27:19 <dcoutts> robokop, pass an infinte list of random numbers in as an argument
03:28:04 <dcoutts> or if you need more control over the randoms then pass in a randum number generator and use that
03:28:04 <robokop> ke and how do i make one
03:28:11 <dcoutts> see the Random module
03:28:25 <sieni> yeah, a startup doing everything in Haskell and getting lots of venture capital would be cool
03:28:29 <robokop> i looked and tryed but i can't get it to work
03:28:31 <shapr> dcoutts: My first thoughts on running such a company is that I'd get the contract requests, and ask the Haskeller(s) most qualified if they have time to do it in the next N amount of time.
03:28:34 <sieni> currently just the business idea is missing
03:28:44 <dcoutts> shapr, right
03:28:54 <dcoutts> sieni, I think taking venture capital is rather risky
03:28:56 <shapr> I know a bunch of Haskell programmers, what they do well, and what they enjoy doing.
03:29:30 <shapr> I even have a bunch of business ideas for startup companies..
03:29:47 <JKnecht> contract requests?
03:29:55 <shapr> But the specific case mention on {haskell,-cafe} was about support.
03:29:56 <dcoutts> shapr, yes, I was thinking along similar lines, a low risk approach is to have a bunch of capable people on staff and you hand out contract work to them
03:30:33 <dcoutts> shapr, so they don't need to share an office full time, very low oferheads, just for some minimal shared infrastructure
03:30:37 <shapr> This guy dropped onto the mailing list, wanted to rewrite some Java code into Haskell, but someone else said "You can't just ring up a Haskell programmer, how would you support it?"
03:30:42 <shapr> dcoutts: Yeah, exactly.
03:31:09 <shapr> I've been doing international consulting for years, and I met my biggest client once ... four years ago.
03:31:22 <shapr> After that it's email and skype.
03:31:25 <dcoutts> shapr, and that means that people don't have to make a big up font time comittment, the company can start with a big staff and build up its buisness slowly
03:31:48 <shapr> Right, if you don't have time, I could ask someone else.
03:32:06 <shapr> If there's a pool of twenty people, it's very likely someone will always be available.
03:32:08 * JKnecht advises Haskell community to get more hooves on the ground than darcs.
03:32:57 <dcoutts> shapr, yes, and if things go well then people can make more sure time commitments
03:33:24 <shapr> Personally, I'd like to specialize in weekend applications. We get a spec on Wednesday, we check it out on Thursday, we agree to it on Friday, and we hand it to the client on Monday.
03:33:36 <dcoutts> shapr, nice :-)
03:34:18 <dcoutts> shapr, eg one could iamgeine someone going part time on their day job if there was enough regular contracting buisness
03:34:34 <shapr> Yeah, that would be really nice.
03:34:54 <dcoutts> anyway, it allows that kind of slow transition
03:35:48 <shapr> Company overhead would be pretty much zero.
03:36:02 <shapr> hoi mjans, learning Haskell?
03:36:04 <dcoutts> right
03:36:29 <mjans> no just looking here
03:36:38 <mjans> trying to learn Clean
03:36:39 <pejo> shapr, where will you find 20 people who aren't busy all the time? :-)
03:36:55 <shapr> Initial startup would require only Daan Leijen's darcs-server, a few pgp keys, etc.
03:36:58 * Lemmih isn't very busy.
03:37:05 <mjans> me to
03:37:07 <mjans> bye
03:37:35 <JKnecht> what rate(s) were you thinking of?
03:37:38 <shapr> pejo: Actually, I've been trying to organize this sort of thing for years, so I already have a list of people who would be interested in doing the occasional bit of Haskell contract work.
03:37:54 <shapr> pejo: Want me to add you to the list?
03:38:13 <dcoutts> shapr, am I on your list?
03:38:24 <pejo> shapr, nah, I already work too much.
03:38:40 <shapr> dcoutts: Yes, though you said you probably won't have time before you graduate.
03:38:58 <dcoutts> shapr, yeah, i'm in two minds about it. ;-)
03:39:06 <pejo> Multiple jobs is a killer, if you ask me. :-)
03:39:18 <shapr> I'm self-employed, my job has schizophrenia!
03:39:32 <dcoutts> shapr, I really like the idea though, I think it'd be quite exciting thing to join in on
03:39:56 <pejo> (Isn't Galois doing contracting work on fp already though?)
03:40:13 <dcoutts> pejo, I had the idea that their buisness was a little different
03:40:30 <dcoutts> so it wouldn't be direct competition
03:40:31 <shapr> Yes, but Galois has more inertia than a loosely organized group of Haskell consultants would have.
03:40:41 <pejo> dcoutts, ah, it probably is in that case. I haven't paid much attention to them since they're in the US.
03:40:58 <shapr> Galois mostly picks up large clients for medium to longer term work. (At least, that's my impression)
03:41:12 <dcoutts> that's my impression too
03:41:37 <shapr> I'm more interested in nano-apps.
03:41:51 <dcoutts> shapr, that is an interesting idea
03:42:17 <Muad_Dibber> a nano-app being?
03:42:33 <dcoutts> shapr, I wonder how much there is in straight consultancy style things, eg that shap who says who can he call when he has trouble with an in house project
03:43:03 <shapr> I've been a member of websites like CodeLance for awhile, that market is weird.
03:43:23 <dcoutts> shapr, so eg improving or bugfixing development tools or common libs, or doing performance analysis on in house apps etc, even training
03:43:37 <dcoutts> shapr, what's that market like?
03:44:02 <shapr> Covered up in programmers from India or the Ukraine who are willing to work for $5 an hour.
03:44:26 <dcoutts> shapr, hmm, right. Quality. That's the way to go.
03:44:42 <dcoutts> Quality & speed, like you say, the nano-prog.
03:44:42 <JKnecht> is Galois a wage labor capital formation, professional assoc. or what? Can't tell from their site.
03:44:45 <shapr> From what I've seen, the $5/hr people don't return code that's maintainable, just working.
03:45:17 <dcoutts> JKnecht, it's an ordinary company with waged staff I think
03:45:34 <shapr> JKnecht: It's a company owned by Haskellers and staffed by more.
03:45:45 <JKnecht> was ready to infer that from site and statement about 'inertia'.
03:45:49 <shapr> John Launchbury is the president.
03:46:06 <shapr> They're headquartered in or near Portland.
03:46:15 <JKnecht> Oregon?
03:46:16 <dcoutts> shapr, did you see his talk at ICFP a couple years ago?
03:46:20 <shapr> Thus the location of the next ICFP should be nifty :-)
03:46:29 <shapr> dcoutts: I saw him talk at HW2003.
03:46:34 <dcoutts> shapr, all about the history & progress of Galois
03:46:59 <dcoutts> shapr, I think the oneI'm thinking about was ICFP'04
03:47:08 <shapr> Yeah, I 's absolutely right about the business approach that's necessary to make Haskell work in the market.
03:47:15 <shapr> s/I/he
03:47:59 <dcoutts> shapr, he was talking about taking on high paying clients and delivering high(er) assurance software
03:48:13 <shapr> Yeah, that's the market I'd aim for as well.
03:48:39 <dcoutts> shapr, you mean if you were going to do a traditional company, or for a looer knit thing?
03:48:45 <shapr> If you can develop a whole app in a weekend, your hourly pay will end up being quite high :-)
03:48:49 <shapr> Both
03:49:02 <dcoutts> shapr, long projects are risky for a loosly associatedcompany
03:49:17 <shapr> I don't see much point in traditional companies though. The only advantage they have is easy personal communication, and that's not a problem for #haskell denizens.
03:49:22 <shapr> dcoutts: very much so.
03:49:30 <shapr> Long projects are risky for any company.
03:49:33 <dcoutts> true
03:50:01 <shapr> The eXtreme Programming approach is to have iterations of one or two weeks where you give another useful chunk of functionality to the client at the end.
03:50:08 <dcoutts> yes
03:50:35 <Muad_Dibber> so, what is the goal of this conversation?
03:50:49 <shapr> I just want to get paid to write Haskell =)
03:50:57 <Muad_Dibber> hehe :)
03:51:07 <Muad_Dibber> shapr, what you do now then?
03:51:11 <dcoutts> Muad_Dibber, to give us all enought confidence to start a professional association for Haskell contracting work
03:51:22 <shapr> Right now I get paid to write Python. It's not bad, but it does get frustrating.
03:51:54 <Muad_Dibber> You work in a team? Or deliver applications by yourself?
03:52:26 <shapr> I do both, sort of. I build Zope/Plone sites, and I'm the only coder. There is another person who does CSS and html though.
03:52:55 <JKnecht> to conquer, such an assoc must put a Monster App on the ground. Then it's members will command high rates. I'm working on ideas for this.
03:53:13 <shapr> Most of my work is done for a German university, and they pay me to work on websites for EU projects mostly.
03:53:37 <shapr> JKnecht: I'd start out by offering Haskell support.
03:53:46 <dcoutts> shapr, right
03:53:50 <Saulzar> Do you think so? If there are lots of small-ish but _complete_ apps it is much more feasable and still impressive
03:54:03 <shapr> "<dcoutts> improving or bugfixing development tools or common libs, or doing performance analysis on in house apps etc, even training"
03:54:24 * dcoutts can do Haskell training!
03:54:25 <Philippa> a framework which runs as many of those apps as you want at once, scalably and effectively configurably wouldn't necessarily be huge itself, but the system of that + pile of mini apps is big
03:54:27 <shapr> Yeah, look at the popularity of zamez' CSS factoring tool.
03:54:31 <dcoutts> I already do it professionally :-)
03:54:33 <JKnecht> shapr: you don't need an assoc. for that. Seems you've been doing that fine for some time.
03:54:37 <Philippa> (and muchly resembles what you actually see in most places)
03:55:16 <Muad_Dibber> I can help as well! I can serve coffee to haskellers!
03:55:19 <shapr> JKnecht: Yeah, but I haven't gotten much business. If there's a group of Haskellers offering support, hopefully more people will be wiling to build apps with Haskell. Witness "Haskell market" thread on the mailing list.
03:55:58 <dcoutts> shapr, and we can build a group with a wide and deep skill set
03:56:03 <Saulzar> They'll realise they get such a good deal for free in #haskell they'll stop paying for training...
03:56:18 <dcoutts> shapr, we know people with fingers in many pies
03:56:21 <shapr> Saulzar: #haskell can only do so much.
03:56:27 <shapr> dcoutts: Yeah, that's the most important part.
03:56:29 <Saulzar> I'm kidding, of course :)
03:56:44 <JKnecht> Guess I better get to work. 
03:56:52 * JKnecht goes for coffee
03:59:07 <dcoutts> shapr, so are you building a secret page of people and their notable coding skills ;-)
03:59:48 <shapr> Here's the thread I mentioned - http://comments.gmane.org/gmane.comp.lang.haskell.cafe/12131
03:59:52 <shapr> dcoutts: Well, it's not secret...
04:03:08 <dcoutts> shapr, so thene there's the default software stack. That makes a big difference so coding speed.
04:03:11 <Saulzar> Hmm, I'll be finishing project in a couple of months. Almost time to look for pay. Seem to be oodles of Java with the odd C++ around here.
04:03:24 <dcoutts> eg web bits, db bits, gui bits
04:03:40 <shapr> dcoutts: Yup, that's one reason I'd like to do weekly sprints on random subjects, to see what's missing, and how much of that we can fill in.
04:03:50 <dcoutts> shapr, that's a very good idea
04:04:04 <Philippa> shapr: I think I just named you one in PM :-)
04:04:25 <shapr> Yeah, depending on what you want from an ECMAscript lib..
04:04:28 <dcoutts> shapr, eg I've never tried doing db stuff with a GUI, but almost any real app would want that
04:04:43 <shapr> musasabi has some javascript generation for his PArrows parser lib.
04:05:03 <dcoutts> shapr, and HaskellDB is a little bitrotted and needs to be made to work with HDBC for example
04:05:13 <shapr> dcoutts: And we'd want the contractors in the pool to be able to do a bunch of different stuff so that whoever is free would have the skills to do something useful.
04:05:26 <shapr> Yeah, HaskellDB could be a huge bonus to speed of development.
04:05:28 <dcoutts> shapr, right, or in a small team
04:05:36 * dcoutts thinks HDBC is looking better than HSQL
04:05:39 <shapr> Yeah, specialization is for insects.
04:05:53 <shapr> Bringert is one of the people on my list.
04:06:19 <Philippa> shapr: the problem with that quote is it came from the mouth of a fictional immortal :-)
04:06:41 <dcoutts> shapr, ah, Bringert who worked on HaskellDB
04:06:52 <shapr> Yeah, but I still think Mr Long is right.
04:07:09 <Philippa> I'd modify it to overspecialisation
04:07:29 <dcoutts> shapr, oh and he did the http lib
04:07:30 <Philippa> I mean, we're all still pretty damn specialised in what we do, no?
04:08:18 <dcoutts> shapr, I've done a bit of db stuff, and some professionally, but I've never tried the Haskell db APIs before
04:08:22 <pejo> Philippa, who are we, and why would "development" be a specialisation that is too narrow?
04:08:55 <shapr> dcoutts: I've only used HaskellDB seriously and it's great fun.
04:08:59 <Philippa> pejo: you're putting words in my mouth
04:09:19 <Philippa> rather, my point is that it isn't overspecialisation but it's nevertheless specialisation
04:09:23 <shapr> I do wish HaskellDB had backend SQL specialization, but that's a feature that's planned for whenever there's enough developer resources.
04:10:21 <shapr> hiya olliej 
04:10:42 <dcoutts> shapr, HaskellDB + HDBC + postgresql/sqlite could make a good platform
04:11:08 <dcoutts> shapr, or adding yhc as a postgresql language :-)
04:11:14 <shapr> Yeah, I think so too.
04:11:25 <olliej> shapr: heya
04:11:44 <dcoutts> shapr, so one can do stored procedures in Haskell rather than perl/python/tcl/SQL/C
04:11:54 <olliej> anyone know if any papers have been published re: yhcs .NET backend?
04:13:06 <shapr> dcoutts: That would be nice, but I'd settle for ease of use to begin with.
04:13:35 <dcoutts> shapr, yeah. it's not a straightforward idea, just a fun one
04:14:03 <shapr> Yeah, it would be cool to do stored procs with Haskell.
04:14:59 <dcoutts> shapr, postgresql actually has a bit of a type system and allows you to define your own functions in any language and then call them in SQL queries
04:15:18 <dcoutts> shapr, but putting Haskell in the db you could do proper type checks
04:15:41 <dcoutts> since you could use the actual type info from the db schema at query preperation time
04:16:31 <dcoutts> where as HaskellDB has to that outside the db and hope the schema doesn't change (iirc)
04:16:31 <shapr> Yes, but I think higher order queries would make more of a difference in everyday business cases.
04:17:10 <dcoutts> shapr, you mean like query templates but done correctly
04:17:13 <shapr> yup
04:17:21 <dcoutts> yes
04:17:43 <shapr> HaskellDB already does that, and it's lovely.
04:17:56 <dcoutts> :-)
04:18:39 * dcoutts goes back to hacking on gtk2hs
04:18:44 * shapr goes back to hacking on Python
04:23:15 <olliej> shapr: traitor
04:23:21 * olliej goes back to hacking C++
04:23:30 <olliej> :)
04:23:48 <shapr> olliej: Hey, pay to write Haskell and I'll never write Python again :-)
04:24:10 <shapr> Actually, I did have a neat idea for a Haskell killer app... Python!
04:24:34 <olliej> shapr: :)
04:24:45 <shapr> Michael Salid wrote a type inferencer and compiler for Python that uses lots of cool tricks from the Self virtual machine. But getting it completed is rough.
04:25:02 <shapr> So I recently proposed to him that it be rewritten in Haskell.
04:25:22 <olliej> hehe
04:25:32 <boegel> shapr: to convince all Python people that Python is not the way to go ?
04:25:44 * olliej is trying to harangue the yhc guys to find out how their .net backend works
04:26:17 <shapr> What with Martin Sulzmann's Chameleon nifty constraint handling based typechecker, lazy evaluation for incremental typing, and existing backends for C--, I figure Starkiller could be implemented quickly in Haskell.
04:27:29 <shapr> boegel: Actually, my motivation is that Plone sucks butt, and Starkiller's type inferencing would let me find the worst problems in Plone before they bite my client and raise my blood pressure to fatal levels.
04:28:13 <boegel> heh
04:28:19 <boegel> so what's keeping you from writing it
04:28:27 <boegel> time? :)
04:29:04 <shapr> And lack of expertise... if I can get Michael Salib interested, that would change :-)
04:30:27 <boegel> w00!
04:35:01 <tic> dang, I was meaning to ask you something, shapr.
04:37:12 <shapr> ?
04:48:27 <shapr> tic: Any idea what?
04:48:53 <tic> shapr, no, not really. :(
04:49:07 * dcoutts chuckles
04:57:35 <shapr> dcoutts: from http://www.cabochon.com/~stevey/blog-rants/choosing-languages.html "After all, we're not about to use OCaml or Haskell for anything at Amazon; they're not popular enough, so we'd have a heck of a time hiring people, finding documentation, integrating with other languages and 3rd-party systems, etc."
04:57:56 <dcoutts> shapr, well it's a good point :-(
04:58:26 <shapr> Yes, but a consultant pool would make it a lot easier to hire people.
04:59:24 <dcoutts> shapr, yes
05:06:29 <dcoutts> shapr, it's fustrating because he goes on to say that performance is not important and that development time is much more important
05:08:33 <dcoutts> shapr, but yeah, for a bunch of haskell experts that's not a problem
05:09:07 <dcoutts> shapr, so we need a name!
05:09:17 * shapr thinks
05:09:21 <shapr> Church & State?
05:09:25 <dcoutts> hah!
05:09:26 <dcoutts> nice
05:09:34 <Philippa> "Functioning Systems"
05:09:48 <Philippa> short, simple and includes the unique selling point ;-)
05:10:01 <dcoutts> generic boring: "lambda consultants"
05:12:27 <dcoutts> hugues23, so does AFP use Haskell for anything?
05:12:41 <dcoutts> hugues23, before you arrived we were discussing comercial use
05:15:17 <genneth> shapr: nice pointer to the invariants in STM thing
05:15:38 <shapr> Saw it on the haskell.general list, figured it's worth posting.
05:17:11 <shapr> genneth: Optimistic thread concurrency sure sounds like STM.
05:17:37 <genneth> shapr: they have a bunch of whitepapers available, but need reg'ing
05:17:42 <shapr> suck
05:17:58 <shapr> I had the same problem when researching wimax chipsets.
05:18:04 <shapr> Now I get wimax spam :-(
05:18:10 <genneth> what happened to that idea anyway?
05:18:40 <shapr> I don't have enough money to make it happen, and a bunch of phone companies are starting to do something similar.
05:18:57 <shapr> Nokia has a new tech that switches GSM calls to VoIP calls if you have a nearby WiFi point.
05:19:28 <shapr> Still, everyone is using 802.11a/b/g, and that'll keep the telcos making money.
05:19:33 <shapr> WiMAX would kill 'em :-)
05:19:49 <genneth> :-p
05:20:08 <shapr> Also, my 'best' idea at the time was software in Haskell..
05:20:21 <shapr> Unexpected events have changed that though.
05:20:26 <genneth> i recently found out that over cambridge there's a huge 60mb wireless network run by some electronic engineering dudes
05:20:27 <tic> UMA's neat.
05:20:37 <shapr> UMA? Uniform Memory Access?
05:20:48 <tic> unlimited mobile access. These TLAs you know. :)
05:20:56 <tic> (switching between GSM and WiFi for example)
05:21:11 <genneth> the network covers practically all of it, and is accessible from the uni network
05:21:15 <shapr> genneth: Yeah, but how many 30km range access points would you need to replace the whole network?
05:21:35 <genneth> one, probably
05:21:36 <genneth> :-p
05:22:01 <tic> wimax for the people!
05:22:28 <tic> s/for/to. these prepositions.
05:22:34 <shapr> wimax claims 50km line of sight, and 30km indirect. Even if it's half that I'd save gobs of money.
05:24:46 <shapr> I'd also like to see digital music players with wifi where the default setting is to have all music wifi accessible and world readable.
05:34:06 <Philippa> shapr: would suck to have your player DoSed by people after something obscure in your collection though
05:34:41 <dcoutts> and wifi sucks battery power which isn't good for very small devices
05:34:53 <tic> Philippa :)
05:35:58 <shapr> Philippa: I'm thinking hardware bittorrent... you set your player to automatically search for and download tracks with a certain keyword, and if you have multiple people downloading from you, use bittorrent.
05:36:09 <shapr> I don't know if wifi supports multicast. It would make sense though.
05:36:30 <shapr> There is the "I'm here" broadcast wifi messages.. I wonder if you could hack that ...
05:52:07 <winkiller> hi there - can anyone tell me which debian package is best suited to start playing around a bit with haskell?
05:52:36 <winkiller> got ghc5, ghc6 and much more stuff to choose from
05:53:31 <neologism> hugs is nice for playing, ghc for serious work ;)
05:54:06 <winkiller> ok, thanks :)
05:56:42 <shapr> winkiller: lambdabot is handy for playing.
05:56:52 <shapr> > map (+1) [1..9]
05:56:53 <lambdabot> [2,3,4,5,6,7,8,9,10]
05:57:04 <shapr> Though if you want to do lots of that, private messages are good.
05:57:10 <winkiller> yeah
05:58:38 <shapr> It's funny how the massive statefulness of Plone feels like a really huge state monad without the safety guarantees.
06:00:55 <Philippa> ...
06:01:07 <Philippa> not really, that sounds rather more like "obvious" :-)
06:31:57 * shapr snores quietly
06:40:00 <dons> ?yow!
06:40:00 <lambdabot> We just joined the civil hair patrol!
06:40:26 <dons> ?seen rizzix
06:40:27 <lambdabot> I saw rizzix leaving #haskell 1 day, 8 hours, 59 minutes and 56 seconds ago, and I have missed 23 hours, 49 minutes and 46 seconds since then.
06:41:15 * dons boogles at spam that says "Three Steps to the Software You Need at the Prices You Want", only to discover it doesn't say 1) go to haskell.org 2) download ghc 3) $$
06:42:58 <boegel> yo CosmicRay 
06:44:07 <Philippa> dons: I got one with the subject "turd evangelism" earlier today
06:44:20 <CosmicRay> hi boegel
06:45:00 <dons> turd evangeliism, you just can't write that kind of gold
06:45:34 <shapr> y0 y0 Mistah Goerzen
06:48:24 <Saulzar> I miss nigerian scams, spam these days is boring
06:48:55 <dcoutts> Philippa, that's beautiful
06:54:42 <Philippa> Saulzar: the local ones're funny. My email address isn't .uk, so I get ones with UK people in...
06:57:18 <dcoutts> dons, Simon liked our idea for a standard testsuite tarball :-)
07:01:27 <CosmicRay> hey shapr!
07:01:34 <CosmicRay> shapr: didya see I finally released a new HDBC?
07:01:43 <CosmicRay> shapr: I also wrote a Drupal to Serendipity conversion tool using it.
07:04:53 <shapr> CosmicRay: neato!
07:04:56 <dcoutts> CosmicRay, should I update the gentoo HDBC packages now do you think or wait for 1.0 ?
07:05:11 <CosmicRay> dcoutts: go ahead and update them now, I'd say.
07:05:14 <dcoutts> ok
07:05:33 <CosmicRay> there are some significant new features here compared to the previous release
07:05:39 <dcoutts> ok, cool
07:05:42 * dcoutts does that
07:05:51 <CosmicRay> note that there are 0.99.2.1 releases for the postgresql and odbc backends
07:05:51 <MarcWeber> setOnCurve f true = setBit f 0
07:06:00 <shapr> CosmicRay: Are you allowed to do moonlighting?
07:06:12 <CosmicRay> I discovered that I had a symbol with the same name in both, which prevented using them both in a single executable
07:06:16 <CosmicRay> shapr: on my own time, sure.
07:06:20 <MarcWeber> setOnCurve f true = setBit f 0
07:06:22 <MarcWeber> setOnCurve f false = clearBit f 0
07:06:30 <MarcWeber> Why do I get pattern matches overlap here?
07:06:42 <shapr> CosmicRay: Interested in joining a Haskell consultants pool?
07:06:42 <ihope> s/true/True/, s/false/False/
07:06:48 <dcoutts> CosmicRay, so it's 0.99.2 generally and 0.99.2.1 for postgresql & odbc. ok.
07:06:54 <CosmicRay> shapr: sure
07:07:00 <CosmicRay> dcoutts: yeah.  All the backends are 0.99.2.x
07:07:10 <ihope> Otherwise you're telling it to take the parameter true and set it to the value you recieve.
07:07:14 <dcoutts> CosmicRay, yes
07:07:35 <CosmicRay> dcoutts: sqlite3 is 0.99.2.0, the others are 0.99.2.1.  basically I try to make it clear what HDBC version a backend is for, while still letting the backends rev separately when needed.
07:07:42 <MarcWeber> ihope: oh.. thx
07:07:46 <CosmicRay> shapr: sounds like a nice idea.
07:07:55 <dcoutts> CosmicRay, yes, I figured that's what it was
07:07:56 <shapr> CosmicRay: Yeah, I think so.
07:08:29 <shapr> Just need a website with a collection of CVs/resumes.
07:13:34 <CosmicRay> dcoutts: in fact, if you would let me know when you've done that, I'd appreciate it... then I could move the old files out of that directory on my server
07:14:11 <ihope> Wuh, GHC 6.5?
07:14:45 <CosmicRay> that's the development ghc
07:14:48 <CosmicRay> 6.4.1 is still the latest release
07:15:18 <dcoutts> CosmicRay, ideally they should live there a bit longer, any user who doesn't sync their package cache (which is prefectly legit - it's like useing a stable distro) will still download the older versions.
07:15:30 <ihope> How was the first GHC compiled? Was it using itself, via Hugs?
07:15:39 <CosmicRay> dcoutts: OK
07:25:12 <ihope> > filter isUpper "Assyria" -- the capital of Assyria
07:25:13 <lambdabot> "A"
07:30:17 <shapr> ihope: hah
07:31:13 <ihope> http://cgi.cs.indiana.edu/~oracle/oracul.cgi?N=1374-08&fmt=html
07:31:31 <ihope> BK:  What... is the capital of Assyria?
07:31:36 <ihope> SG:  [pause] A!
07:39:05 <dcoutts> CosmicRay, ok, just testing hdbc-* ...
07:39:52 <dcoutts> CosmicRay, it'd be nice if it was easier to run the testsuites, eg make test
07:40:55 <[b]HmR`les> some1 here who can quickly explain what the $ does in haskell? thx
07:41:30 <Muad_Dib> [b]HmR`les: very quickly, it is more or les this: a ( b) == a $ b
07:41:48 <[b]HmR`les> ok its an application, thx
07:42:16 <mauke> f $ g $ x = f (g x)  -- it's right associative
07:42:17 <Muad_Dib> yeah
07:42:19 <Muad_Dib> thats the word :)
07:42:26 <[b]HmR`les> ok thanks
07:42:46 <mauke> @help .
07:42:46 <lambdabot> . <cmd1> <cmd2> [args].
07:42:46 <lambdabot> . [or compose] is the composition of two plugins
07:42:46 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
07:43:21 <dcoutts> CosmicRay, I get a error when preprocessing Database.HDBC.ODBC.TypeConv
07:43:25 <dcoutts> TypeConv.hsc: In function `main':
07:43:25 <dcoutts> TypeConv.hsc:79: error: `SQL_WCHAR' undeclared (first use in this function)
07:43:37 <dcoutts> CosmicRay, am I missing some header file?
07:45:17 <ihope_> Squaring function!
07:45:23 <ihope_> > (\x -> length (replicate x x >> replicate x x)) 3
07:45:24 <lambdabot> 9
07:45:37 <[b]HmR`les> @help _
07:45:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:45:44 <[b]HmR`les> list
07:45:48 <mauke> @pl (\x -> length (replicate x x >> replicate x x))
07:45:48 <lambdabot> length . ap ((>>) . join replicate) (join replicate)
07:46:15 <ihope_> Woot.
07:49:58 <CosmicRay> dcoutts: sounds like you're missing the ODBC headers....
07:50:04 <CosmicRay> let me see which file has that on my system...
07:50:22 <CosmicRay> sqlext.h seems to.
07:50:23 <dcoutts> CosmicRay, which is odd because I'm not, and it would complain about not being able to #include them
07:50:47 <CosmicRay> yeha, that sounded odd to me as well.
07:50:53 <CosmicRay> are you compiling against unixodbc or iodbc?
07:50:57 <dcoutts> CosmicRay, SQL_WCHAR is in /usr/include/sqlext.h
07:51:08 <CosmicRay> sql_wchar comes straight out of the odbc v3 spec
07:51:11 <dcoutts> CosmicRay, unixodbc-2.2.6
07:51:23 <CosmicRay> pretty close. 2.2.11 here.
07:51:30 <CosmicRay> let me check that file...
07:51:42 <shapr> CosmicRay: Ever tried to build a SAN at home?
07:51:43 <CosmicRay> well that file includes sqlext.h.
07:51:50 <CosmicRay> so that is weird.
07:51:54 <CosmicRay> shapr: nope, not really
07:52:02 <dcoutts> CosmicRay, sorry I was wrong, it's defined in /usr/include/sqlucode.h
07:52:20 <dcoutts> and we're not #includ'ing that one
07:52:49 <dcoutts> and it's not #included by any other .h
07:53:03 <dcoutts> so that'll be the problem, let me try fixing it...
07:53:24 <CosmicRay> my sqlext.h does include it.
07:53:27 <CosmicRay> that is weird.
07:53:32 <CosmicRay> I wonder why yours does not.
07:53:36 <dcoutts> probably versionitis
07:53:52 <CosmicRay> in any case, my sqlext.h does say:
07:53:55 <CosmicRay> #ifndef __SQLUCODE_H
07:53:55 <CosmicRay> #include "sqlucode.h"
07:53:55 <CosmicRay> #endif
07:53:59 <dcoutts> yep works now
07:54:16 <CosmicRay> now I wonder if sqlucode.h is standard or is just there for unixodbc.
07:54:40 <dcoutts> yeah, my sqlext.h has no reference to __SQLUCODE_H or sqlucode.h
07:54:49 <dcoutts> CosmicRay, I'm afraid I've no idea
07:55:08 <dcoutts> CosmicRay, I could patch it locally, it's up to you what you think best
07:55:57 <CosmicRay> dcoutts: I've committed the fix to my tree, but it would probably be best for you to patch it locally for now
07:56:11 <dcoutts> CosmicRay, ok will do
08:04:09 <robokop> can i safely use a StdGen more then once when wanting different random values
08:04:53 <Saulzar> The same StdGen will always give you the same value, but it returns another StdGen which won't
08:05:11 <robokop> ke
08:05:57 <robokop> but if i do something with map (f (stdgen :: StdGen)) somelist
08:06:04 <robokop> how should i fix that
08:07:28 <shapr> You can either explicitly thread around the randomGen, or you can use a monad to thread it for you.
08:07:32 <Saulzar> Simple way could be to use something like randoms (Which gives an infinite list of random numbers)
08:07:46 <shapr> oh, I like that option better.
08:08:21 <robokop> well of for a while think avbout it agian after dinner
08:09:51 <dcoutts> CosmicRay, ok it's in gentoo now. It takes a few hours to propogate. However as I said I'd reccomend leaving the tarballs for the older versions for a while.
08:10:29 <dcoutts> CosmicRay, you'll be able to see here: http://packages.gentoo.org/search/?sstring=hdbc
08:10:40 <davidhouse> @localtime dons
08:10:42 <lambdabot> Local time for dons is Fri Mar 31 02:11:10 2006
08:10:49 <davidhouse> what timezone is he in?!
08:10:55 <shapr> Oz
08:10:59 <davidhouse> ah.
08:11:08 * davidhouse is having trouble building yi
08:11:12 <dcoutts> CosmicRay, and yes it does work on all 5 arches :-)
08:12:19 <dcoutts> CosmicRay, at least it builds on all of them and we tested each backend properly on at least one arch. That was for 0.99.0.
08:12:58 <CosmicRay> nice.
08:13:32 <shapr> hoi jyp 
08:13:38 <CosmicRay> thanks dcoutts
08:13:48 <davidhouse> i'm trying to build yi and ld is telling me "cannot find -lcurses". any ideas as to what might be causing this?
08:14:00 <davidhouse> i was advised to check i had readline5 installed, and I do.
08:14:01 <dcoutts> davidhouse, you probably don't have ncurses installed
08:14:02 <integral> Do you have curses?  perhaps yours is named ncurses
08:14:20 <davidhouse> i've got ncurses, but it's not called curses.
08:14:37 <davidhouse> (shouldn't configure check for that anyway?)
08:20:04 <davidhouse> perhaps a symlink connecting libcurses.so to libncurses.so would work?
08:20:08 <davidhouse> or is that a Bad Idea?
08:42:08 <davidhouse> can lambdabot pass on messages?
08:42:38 <davidhouse> like, in #wordpress, we can say "phenny, tell X that Y", and the next time X comes into the channel and says something phenny says "Z said Y at time T"
08:43:14 <shapr> Well, there's already memoserv.
08:43:21 <shapr> But it wouldn't be hard to add that functionality.
08:43:38 <shapr> lambdabot started out having explicit functions for each possible IRC signal, now it's just a typeclass.
08:48:22 <shapr> Man I hate it when fields in a database table are named Veröffentlichungen
08:48:51 <Descoloda> lol
08:48:54 <shapr> It's rough keeping the encodings straight from client to connection manager to server.
08:49:29 * shapr is using client -> sqlrelay -> freetds -> ms.database.something
08:51:05 <davidhouse> is there an introductory tutorial to yi anywere?
08:51:49 <shapr> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
08:52:06 <shapr> Other than that, look at the keymaps.
08:55:31 * shapr laughs
08:56:04 <shapr> "Incidentally, I looked on the Haskell home page for links to programming idioms and advice, but came up empty.  The obvious place to look was under "Using Haskell", but I didn't find anything.  Was I being stupid? -- Simon Peyton-Jones"
08:56:29 <shapr> If SPJ weren't so amazingly humble, I'd swear that was a tactful way to say "Get it together guys!"
08:57:23 <dcoutts> shapr, heh, yeah
08:59:17 <Muad_Dib> lol
09:04:56 <ihope_> If NetHack were written in Haskell, then some might be confused by the calls to getHand and stuff...
09:05:23 <shapr> There is a clone...
09:05:28 <davidhouse> how ready is yi?
09:05:37 <davidhouse> yi --as emacs, nothing seems to work.
09:05:45 <davidhouse> even my enter key fails to create a new line :|
09:05:47 <shapr> the Vi emulation does lots.
09:05:54 <shapr> There are multiple emacs emulations.
09:06:00 <shapr> I forget which one is the most complete.
09:06:16 <shapr> The one thing that's missing right now is syntax highlighting.
09:06:22 <shapr> Once that's in, I'll switch.
09:06:37 <davidhouse> cool.
09:06:42 <davidhouse> emacs2 seems to work better
09:06:53 <davidhouse> as in, C-x C-f does something :)
09:07:17 <shapr> yay
09:08:02 <davidhouse> but yeah, syntax highlighing would be kind of necesary.
09:11:40 <fizbin> Hey, anyone up for the Haskell equivalent of perl golf?  That is, I've got some ugly code that finally works, but it's ugly and inelegant, and I want to know how to do this better.
09:12:01 <shapr> davidhouse: dons and Lemmih have done some *very* cool stuff for syntax highlighting, but I don't think it's made it into the repo yet.
09:12:07 <fizbin> That is, while with perl golf the goal might be "shortest", here the goal is "most elegant"
09:13:32 <fizbin> In theory, the paste.lisp.org pastebot should have sent the message that my code is sitting at http://paste.lisp.org/display/18456
09:15:26 <shapr> fizbin: check out combinations and permutations on http://www.haskell.org/hawiki/LicensedPreludeExts
09:17:31 <fizbin> shapr: Cute in terms of elegance of presentation, but not that useful: first off, the code there doesn't handle infinite source lists well at all.
09:17:38 <shapr> True
09:17:53 <shapr> Just thought it might help some.
09:18:07 <shapr> Since I don't have time to look at your code thoroughly right now.
09:18:55 <fizbin> shapr: However, it inspires me to go back and see if I can make more use of list comprehensions in my code to clean it up.
09:19:00 <shapr> yay :-)
09:30:13 <shapr> tic: Did you remember?
09:30:40 <tic> shapr, no rememberence. It might not have been important, I suppose.
09:52:59 <SyntaxNinja> is Haskell hacking metrosexual? http://headrush.typepad.com/creating_passionate_users/2006/03/code_like_a_gir.html
10:08:23 <shapr> y0 SyntaxNinja 
10:09:16 <astrolabe> In a function definition, I have the following lines (after 'where')
10:09:26 <astrolabe> pin Black = slowFunc Black
10:09:37 <astrolabe> pin White = slowFunc White
10:10:00 <astrolabe> These are so the code doesn't keep calling slowFunc.
10:10:12 <astrolabe> But is there a nicer way of doing it?
10:10:28 <davidhouse> pin = slowFunc
10:10:51 <astrolabe> davidhouse: but that doesn't work.
10:10:59 <astrolabe> I'm not explaining myself
10:11:34 <shapr> SyntaxNinja: Definitely metrosexual.
10:11:41 <astrolabe> I'm trying to calculate 'slowFunc Black' and 'slowFunc White' once only.
10:12:02 <shapr> Why are they being calculated multiple times?
10:12:58 <astrolabe> They return an array, I'm going through a list calling slowFunc on the appropriate value, then evaluating at some point.
10:13:28 <astrolabe> Where the value and the point depend on the list element.
10:13:37 <davidhouse> anyone a haskell-mode user? (emacs)
10:13:47 <shapr> davidhouse: me
10:13:54 <shapr> astrolabe: I still don't get it...
10:14:24 <davidhouse> shapr, is there any way to completely turn off haskell-mode's indentation? i'm not using turn-on-haskell-indent but when i press TAB it still just inserts 8 spaces instead of one tab
10:14:52 <astrolabe> Maybe I should have pinBlack instead of pin Black.
10:15:10 <shapr> davidhouse: In my experience, using a real tab character is a recipe for insanity.
10:15:12 <astrolabe> It's sort of like cheap memoization.
10:15:24 <shapr> But if you *really* want to do it, I'm sure there is some way.
10:15:36 <davidhouse> ...of which you know not
10:15:44 * shapr thinks
10:15:54 <shapr> Um, does emacs insert a real tab char for you in all other modes?
10:16:06 <davidhouse> yep.
10:16:41 <astrolabe> I think having tabs in haskell code is a bad idea.
10:16:44 <shapr> In that case, it's entirely possible the author of the mode did it that way.
10:16:59 <shapr> But there are two haskell-indent modes, you could try the other one.
10:17:05 <SyntaxNinja> hi shapr.
10:17:07 <davidhouse> i could nideed.
10:17:09 <davidhouse> *indeed
10:17:20 <shapr> In my use of both Python and Haskell, tab chars have caused problems.
10:17:41 <SyntaxNinja> do you ever have a shell script (or a perl script) that's Just barely too short / too long to re-write as a haskell program?
10:18:05 <shapr> No, I use ghc ShaeTools.hs -e "code here"
10:18:10 <davidhouse> and is there a way to get emacs to reload its .emacs config file without a restart?
10:18:34 <flux__> you could open it and say (maybe) eval-buffer
10:18:36 <shapr> davidhouse: Yeah, but it's easier to put your cursor at the end of whatever config code you're changing and hit C-x C-e
10:18:44 <flux__> but then it might do things twice which are usually done only once
10:18:49 <flux__> yes, that's the better way
10:18:53 <davidhouse> shapr, what does that do?
10:18:54 <shapr> Like, (setq tab-width 4)
10:19:00 <fizbin> astrolabe: You appear to want a CAF
10:19:17 <shapr> davidhouse: Try C-h k C-x C-e
10:19:20 <astrolabe> Oooh!  Thanks, I'll look it up.
10:19:34 <davidhouse> oh yeah. :) emacs's help++
10:20:11 <shapr> davidhouse: alternatively, remember that C-h at any point inside a combo shows you what commands/keys you could do next.
10:20:23 <shapr> (Though C-x C-h is rather large)
10:20:36 <davidhouse> woah. that's awesome.
10:20:56 <shapr> davidhouse: Also, after my years of experience with emacs and love of emacs, I want Yi all the more.
10:21:24 <davidhouse> why? so you can hack it?
10:21:44 <shapr> No, because it'll kick the crap out of emacs in terms of expressive power (among many other things).
10:22:27 <davidhouse> it'll be a while before it's in a usable state, i should imagine.
10:22:33 <davidhouse> how fast is development happening on it?
10:22:48 <shapr> When development is happening, it's a flood. When it's not happening, it's a desert.
10:23:02 <shapr> Flocking behaviour is common on #haskell =)
10:23:12 <SyntaxNinja> shapr: the problem is that someone else wrote them, so I'd have to re-write them
10:23:33 <shapr> This means that if one person starts making progress on a program that other would want to use, a bunch of people tend to converge on it.
10:23:42 <davidhouse> yeah.
10:36:18 <davidhouse> @pl \f g h x -> f (g x) (h x)
10:36:19 <lambdabot> liftM2
10:36:35 <davidhouse> interesting.
10:36:55 <mauke> @type ap
10:36:55 <lambdabot> Not in scope: `ap'
10:37:08 <davidhouse> oh, wait.
10:37:12 <basti_> @index ap
10:37:12 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
10:37:13 <davidhouse> @pl \f g h x y -> f (g x) (h y)
10:37:13 <lambdabot> ((flip . ((.) .)) .) . (.)
10:37:20 <davidhouse> well, that's out of the question :)
10:37:24 <davidhouse> @type Control.Monad.ap
10:37:24 <lambdabot> forall b (m :: * -> *) a.
10:37:24 <lambdabot>        (Monad m) =>
10:37:24 <lambdabot>        m (a -> b) -> m a -> m b
10:37:30 <davidhouse> ($) for monads.
10:39:37 <davidhouse> > let readList = map (read.return) in readList "1234"
10:39:38 <lambdabot> Add a type signature
10:40:10 <davidhouse> > let readList = map (read.return) :: String -> [Int] in readList "1234"
10:40:11 <lambdabot> [1,2,3,4]
10:47:12 <glauber_sp> hi guys. Is there anyone using gentoo ~x86? I cannot compile ghc using gcc4.1, even the masked version.
10:48:19 <ulfdoz> It is not meant to be "even" it is meant to be "probably" you can't compile it. That's what ~x86 means.
10:49:40 <glauber_sp> ulfdoz, I know. I said even because the changelog says this masked version has a gcc4.1 patch that makes it compile =)
10:50:30 <ulfdoz> glauber_sp: what about switching gcc to some older version.
10:51:52 <glauber_sp> ulfdoz, I'm comming from 3.5.x. The binary version of the ghc works. So if it doesn't compile, I use the binary version for now =)
10:53:08 <ulfdoz> glauber_sp: Problems with compiler updates are sometimes very strange. I already did an emerge --emptytree world, because I haven't found the problem.
10:54:57 <glauber_sp> ulfdoz, I'm still compiling the new system. after this, I'll check ghc again. the package changelog says it has support to gcc4.1 since 5 days ago
10:59:29 <basti_> ?.
10:59:30 <lambdabot> Not enough arguments to @.
10:59:32 <basti_> whats that?
11:01:03 <ulfdoz> Gentoo is a l33t linux distro for people with no heater or who like the sound of the fans.
11:01:49 <glauber_sp> ulfdoz, the problem seems to be a CFLAG (-nopie). I'll make others checks here.
11:09:26 <zellyn> shapr: hi!
11:11:28 <goron> It seems that a lot of "open-source" code  does not contain comments. Is that too make it hard to understand? e.g. http://svn.openfoundry.org/pugs/src/Text/Parser/Rule.hs Or is it just that Real Programmers don't need them?
11:11:44 <goron> er s/too/to
11:14:56 <astrolabe> I think good programmers like comments
11:20:09 <goron> astrolabe: I suspect some projects of just not including the comments on purpose. 
11:20:21 <fizbin> Hey, how do you phrase an import statement in Haskell when you only want to import one symbol, and that symbol isn't alphanumeric?
11:20:33 <basti_> fizbin: you mean an operator?
11:20:36 <basti_> (infix things)?
11:20:42 <fizbin> E.g. I want to import only the function % from Rational.
11:21:04 <basti_> is that a function or is that the data constructor :%?
11:21:07 <int-e> import Data.Ratio ((%))
11:21:09 <waern_> code can be so clear that comments are unnecessary, that's when you've got really readable code.. unfortunately people rarely code that way in haskell
11:21:19 <goron> They can of course, but claiming at the same time of being "open-source".... is plain  ridiculous.
11:21:23 <basti_> waern_: haskell is readable by definition ^^
11:21:36 <int-e> % is a function that wraps :% and a reduction to lowest fractions (gcd, two divisions).
11:21:40 <goron> waern_: I also have seen scheme48. 
11:21:41 <basti_> i see.
11:21:51 <fizbin> Thanks, int-e.  That did it.
11:21:58 <goron> waern_: It also includes very little commenting. 
11:22:18 <basti_> fizbin: that (parenthenses) often is the way to address infix functions 
11:22:29 <basti_> when the parser gets in your way somehow
11:22:47 <waern_> what I mean is, you should strive to write more readable code, not to write lots of comments
11:23:00 <fizbin> I was trying all sorts of quotes, `, ", ', etc.  But I'll remember () for operators.
11:23:37 <Descolada|Work> code presentation is a verry important part of being a programmer
11:23:45 <basti_> `` will convert a prefix function to infix.
11:23:45 <Descolada|Work> spelling is the second
11:23:49 <goron> waern_: sure, but code does not say why something is done.
11:23:56 <goron> waern_: Or done in a certain way.
11:24:02 <basti_> > (+) `foldr1` [1,2,3,4]
11:24:03 <lambdabot> 10
11:24:04 <basti_> :D
11:24:23 <waern_> goron, no.. and when you need to say that you should use comments of course
11:24:34 <waern_> but most of the time you are interested in what the code DOES
11:24:49 <waern_> and that's wrong.. that should be evident by just looking at the source
11:24:53 <goron> Anyway, I wouldn't be suprised that some projects have two versions of code: one without comments, and one with. 
11:25:06 <Descolada|Work> why have two
11:25:07 <Descolada|Work> ?
11:25:19 <goron> One is non-public.
11:25:34 <goron> Or it really is the intention to create unmaintainable mess.
11:34:29 <TuringTest> Anyone here a gtk2hs user?  I have a reference count error:
11:34:31 <TuringTest> cairo-pattern.c:529: failed assertion `pattern->ref_count > 0'
11:34:35 <goron> E.g. /usr/src/linux/drivers/net/sk98lin/skrlmt.c is pretty good documented good at first sight. I don't see that in a lot of open code. I haven't seen all code of course.
11:34:54 <TuringTest> dcoutts: ping
11:35:20 <dcoutts> TuringTest, what did your code look like?
11:35:38 <dcoutts> TuringTest, do you have a small test case?
11:35:45 <TuringTest> pasting...
11:36:41 <goron> Hmm, not all of Pugs is like that: http://svn.openfoundry.org/pugs/src/UTF8.lhs
11:37:01 <lisppaste2> TuringTest pasted "for dcoutts " at http://paste.lisp.org/display/18461
11:37:08 <int80_h> weee
11:37:14 <int80_h> all hail haskell
11:37:22 <TuringTest> I wanted to temporarily swap out the pattern color
11:37:46 <TuringTest> But I suppose I need to learn the semantics better
11:38:06 <TuringTest> I think a pattern is "newtype Pattern = Pattern GHC.Ptr.Ptr"
11:39:07 <TuringTest> This is all during a "renderWithDrawable" as in the snippet that lets me use Cairo from ghci.  It works if I remove the setSource line.
11:41:00 <TuringTest> Using Mac OSX and a port-darwin version of ghc 6.4.1 with gtk2hs / cairo-0.9.10.1 and gtk2 version 2.8.10
11:41:41 <dcoutts> TuringTest, ok thank, I'll take a look
11:48:14 <int80_h> are the mailing lists archived?
11:48:39 <dcoutts> yes
11:49:06 <dcoutts> follow the link from the haskell.org homepage
11:50:01 <dcoutts> xerox_, ping
11:50:12 <TuringTest> xerox ...
11:50:20 <dcoutts> TuringTest, yep looks like a bug. I think I see what's going wrong
11:50:24 <TuringTest> :)
11:50:36 <TuringTest> I am glad I sought help.
11:51:00 <dcoutts> TuringTest, it looks like what's heppending is this:
11:51:41 <dcoutts> we allocate a pattern, set the cairo context to use that pattern, use it, deallocate it, but the context is still using it!
11:52:59 <whocares_> hola, this isn't a troll.  but i know many will be willing to put their 2 cents in.  I've become frustrated with my mental model of mainstream OO languages for various reasons, and would like to know the differences between Haskell, Clean, and OCaml?
11:53:29 <TuringTest> Hmm...
11:53:33 <basti_> clean is a whole lot like haskell, it's purely functional too. It uses a different model for the stuff haskell uses monads for, though
11:53:42 <basti_> (one that is arguably easier to understand)
11:53:51 <whocares_> basti_: what i like about haskell is i can compile down to exe
11:53:59 <whocares_> or rather clean
11:54:00 <whocares_> oops
11:54:04 <TuringTest> dcoutts: I have  a new mimimal test case (in a moment)
11:54:09 <whocares_> clean compiles down to a fast exe
11:54:19 <whocares_> i'm already trolling myself:)
11:54:25 <basti_> ocaml is a lot more like lisp.
11:54:28 <shapr> Haskell compiles to a fast exe too.
11:54:30 <basti_> it has a simpler typesystem than both
11:54:39 <whocares_> see, ocaml is the missing link in all of this
11:54:49 <monochrom> OCaml has an OO model, and this model is better than the mainstream ones.
11:54:51 <basti_> but ocaml really kicks.
11:55:08 <whocares_> shapr: by the way, saw your python decorations post on lambda:)
11:55:20 <whocares_> see, about OO
11:55:23 <shapr> Still, OCaml also has machine dependent Int sizes, and silently overflows the Int.
11:55:25 <whocares_> i have problems with OO
11:55:30 <shapr> Er, did I post about OO?
11:55:46 <dcoutts> shapr, doesn't ghc have machine dependent Int sizes, and silently overflows the Int.
11:55:48 <monochrom> I bet you have problems with bad OO.
11:56:01 <shapr> dcoutts: I don't think so...
11:56:09 <whocares_> maybe it's just a freaktard mental model of why C# and Java force me to go static with functions?
11:56:15 <basti_> yes, ocaml is a lot more dirty than both ocaml and haskell
11:56:15 <monochrom> OCaml's OO is both more flexible and more type-safe at the same time.
11:56:18 <dcoutts> shapr, Int is 32bit on x86, 64bit on amd64.
11:56:19 <shapr> whocares_: In my opinion, the monadic abstraction is more regular and powerful than the object abstraction.
11:56:21 <mauke> > 2^32
11:56:22 <lambdabot> 4294967296
11:56:30 <mauke> > 2^64
11:56:30 <lambdabot> 18446744073709551616
11:56:32 <basti_> ocaml seems like a good compromise between imperative and functional style
11:56:35 <shapr> dcoutts: Hm, I thought Int was specified by the H98 standard?
11:56:35 <lisppaste2> TuringTest annotated #18461 with "dcoutts , new test case" at http://paste.lisp.org/display/18461#1
11:56:40 <monochrom> And of course, you can still be functional and non-OO in OCaml.
11:56:59 <whocares_> shapr: i guess i'll learn Clean until I can get my hands on a future VisualHaskell which looks like it fucking rocks....but I don't have 2003, only 2005
11:57:00 <mauke> OCaml is really ugly, though
11:57:01 <shapr> Maybe I'm thinking of Char?
11:57:04 <dcoutts> shapr, H98 specifies Int to be at least 29 bits
11:57:11 <zellyn> hi folks.
11:57:12 <whocares_> mauke: it is?
11:57:15 <basti_> yes ocaml is really ugly
11:57:16 <shapr> hiya zellyn 
11:57:20 <zellyn> I was reading the nomaware monad tutorial, and found this: newtype State s a = State { runState :: (s -> (a,s)) }
11:57:33 <shapr> whocares_: Well, drop by and check out Haskell when you get a chance.
11:57:37 <TuringTest> dcoutts: the withSourceRGB was not needed for the test case, setSourceRGB also dies.
11:57:44 <zellyn> After some searching, I found a definition of "newtype" in the Haskell reference.
11:57:46 <franka> Machine-dependent ints are not a problem, since you can always code up machine-independent ones.
11:57:47 <dcoutts> TuringTest, ?! oh ok
11:57:51 <basti_> haskell is a very beautiful language.
11:57:51 <whocares_> shapr: well, Haskell has the mindshare
11:57:55 <mauke> zellyn: think "data"
11:57:56 <zellyn> Is there a simpler explanation?
11:58:03 <dcoutts> TuringTest, can I see the whole code
11:58:05 <shapr> whocares_: Didn't always have that... five years ago it was just me on #haskell
11:58:05 <whocares_> shapr: can Haskell compile down to native win32 exe?
11:58:14 <shapr> whocares_: yup
11:58:16 <zellyn> It was the part inside { } that was new to me.
11:58:19 <whocares_> shapr: cool
11:58:22 <mauke> zellyn: oh, that's record syntax
11:58:25 <monochrom> (If you know what some of these words mean)  Haskell has typeclasses, monads, and arrows; it doesn't have OO or the module system of OCaml.  Contrapositively for OCaml.  I would say that's the main difference.
11:58:35 <Cale> zellyn: newtype creates a new type which has an implementation the same as some other data type
11:58:44 <whocares_> i was lurking the haskell.general archives about the "disruptive" haskell technology
11:58:50 <int80_h> crap
11:58:50 <whocares_> i've got a few words on that
11:58:57 <zellyn> I gather it's the same as saying:   newtype State s a = State (s -> (a,s))
11:58:57 <shapr> whocares_: I think the only serious difference between clean, ocaml, and Haskell is that Haskell is lazy.
11:58:59 <shapr> whocares_: Oh tell me.
11:59:02 * int80_h checks log for answer to question
11:59:06 <Cale> zellyn: yes
11:59:06 <whocares_> need a kickass IDE like VisualHaskell but for Eclipse
11:59:22 <zellyn> Except that you can go from State back to (s -> (a,s)) without pattern matching?
11:59:27 <mauke> zellyn: it also defines an extractor
11:59:28 <mauke> yes
11:59:36 <whocares_> what's great about Haskell is that it can surpass other static languages unlike the ruby, python boys
11:59:38 <Cale> well, runState :: State s a -> s -> (a,s)
11:59:54 <Cale> it defines a function with that type
12:00:00 <shapr> whocares_: Have you seen the Alioth shootout?
12:00:19 <whocares_> shapr: no, i haven't. i only hear about the debian something shoothout
12:00:39 <lisppaste2> TuringTest pasted "Medium sized file for dcoutts" at http://paste.lisp.org/display/18463
12:00:59 <monochrom> "State { runState :: (s -> (a,s)) }" is not specific to newtype.  Look up record syntax.
12:01:07 <whocares_> oh lord, i get trillian hover-over about "alioth"
12:01:13 <zellyn> This might be an uninformed question, but is that an overloading of record-like syntax to define an extractor, or ...
12:01:18 <dcoutts> TuringTest, and which bit is going wrong?
12:01:19 <franka> I think an important difference between Haskell vs. Ocaml and Clean is that Haskell's type system is more regular.
12:01:19 <whocares_> or rather wikipedia alioth hover over alioth
12:01:22 <zellyn> monochrom: you just answered my question.
12:01:27 <davidhouse> zellyn: runState lets you run a computation that depends on State. you give it a stateful computation (i.e., a function in State) and some initial state, and it returns the final (state, value) pair
12:01:37 <TuringTest> dcoutts: The "setSource old" lines, such as in "applyFillStyle"
12:01:42 <shapr> whocares_: Try setting cpu, mem, and lines to 1 on http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
12:01:43 <davidhouse> there's also execState which returns the final state and evalState which returns the final value
12:01:50 <Cale> zellyn: it defines an extractor, as well as allowing for an update syntax
12:01:52 <franka> In Ocaml there are two other type systems sort of embedded, which makes it more work to understand how to encode things.
12:01:57 <davidhouse> i.e. execState = fst.runState, evalState = snd.runState
12:02:04 <TuringTest> Everything else works great, and I have only been using it for a few days. 
12:02:08 <zellyn> Gotcha.
12:02:15 <whocares_> franka: but at the same time, i'm going out on a limb putting my efforts into any functiional language.  i guess though it doesn't matter. it'll take microsoft or sun or ibm to make it mainstream
12:02:24 <shapr> whocares_: For awhile, GHC had the best score on the shootout.
12:02:33 <whocares_> shapr: good
12:02:35 <zellyn> I finally found the record syntax docs.
12:02:43 <whocares_> shapr: nobody likes slow shit
12:02:52 <shapr> whocares_: Well, clients do if you can produce it quickly.
12:02:58 <shapr> Programmer time is more expensive than computer time.
12:02:58 <franka> If you are going out on a limb, I would choose Ocaml.
12:03:01 <whocares_> shapr: that's my whole point
12:03:02 <franka> It is the most practical.
12:03:03 <zellyn> My meta-question is, when I see something like { foo :: bar } in a data decl for the first time, where do I look?
12:03:04 <Cale> if you have  data Person = Person { name :: String, age :: Integer }, then if p is a person, you can write p { age = age p + 1 }, to get a person which has the same name, but is one year older :)
12:03:29 <whocares_> shapr: well, not really. i have to do for the "mind-bending", but i also have to have client stuff in the back of my mind
12:03:32 <franka> But if you like to experiment with languages, Haskell is more interesting.
12:03:37 <Cale> zellyn: the Haskell Report is a good reference
12:03:48 <Cale> (if a bit on the technical side)
12:04:07 <Cale> This sort of thing also tends to get mentioned in lots of tutorials
12:04:10 <zellyn> Yeah, that's where I've been ending up, for the stuff that's more advanced than "Tour of the Haskell Syntax"
12:04:13 <whocares_> Tim Sweeney's pdf report at POPL tweaked my interest too. when him or Carmack say something then I listen
12:04:33 <whocares_> although Sweeney doesn't like Haskell syntax
12:04:42 <zellyn> It's a little heavy on grammar, light on examples.
12:04:43 <shapr> I like most of Haskell's syntax.
12:04:48 <zellyn> But it works okay!
12:04:55 <shapr> whocares_: I think Sweeney really meant that Haskell syntax is scary for C programmers.
12:04:59 <shapr> But I could be misinterpreting that.
12:05:25 <whocares_> shapr: i don't care what he cares about Haskell's syntax, but when he talks about large-scale systems programming on the mainstream then i listen
12:05:28 <zellyn> shapr, whocares_: he also mentiones that type mismatch errors can be rather confusing.
12:05:37 <shapr> whocares_: I'd like to try ghc-smp and parallel arrays together on the Cell.
12:06:25 <basti_> I'd like to have a language that includes parallelism in a sensible way
12:06:26 <whocares_> and i guess i'm a sheeple. all the brains tend toward haskell and functional languages...even if the uber brains can't show the mainstream why they're wrong:)
12:06:28 <shapr> Personally, I believe that Haskell's strong point is producing correct code in a small amount of time.
12:06:34 <shapr> But if you read that Haskell's market thread, you already know that.
12:06:48 <whocares_> shapr: how about DSLs? that is important for business!
12:07:02 <whocares_> i hear Haskell is good for DSLs
12:07:06 <shapr> Yeah, DSLs is a good way to produce correct code quickly :-)
12:07:09 <sieni> shapr: that's only part of it, since it also applies to ML
12:07:31 <TuringTest> Speaking of DSLs...I am almost done with a gnuplot -> haskell -> gtk2hs/cairo bit of code.
12:07:44 <shapr> sieni: I think referential transparency makes correct code easier to reach... once you're comfy without variables.
12:07:53 <whocares_> ok, i think this might have come up on the "disruptive technologies" thread, but rapid DSLs for Excel dudes might mean something
12:07:54 <shapr> TuringTest: cool! Any online demos?
12:08:06 <whocares_> i'm coming on this from the outside
12:08:13 <TuringTest> shapr: dcoutts is helping me debug some of the color changing at the moment. 
12:08:19 <shapr> neato
12:08:23 <shapr> whocares_: Like what?
12:08:36 <whocares_> shapr: natural language?
12:08:43 <sieni> shapr: well, I'm not that afraid of side-effects, but it's nice to have a lispish language with static typing.
12:08:46 <whocares_> shapr: wrong
12:08:51 <shapr> hm?
12:08:51 <whocares_> shapr: scratch that
12:09:04 <whocares_> shapr: do you know about intentional programming?
12:09:10 <whocares_> shapr: or subtext?
12:09:18 <shapr> whocares_: Charles Simonyi came up with IP long ago and far away.
12:09:20 <malcolm> @google eclipse haskell
12:09:21 <lambdabot> http://eclipsefp.sourceforge.net/
12:09:26 <shapr> He left Microsoft research and started his own company with the IP tech.
12:09:36 <shapr> I think SubText should be flushed immediately...
12:09:43 <whocares_> shapr: i know, but could Haskell be the core for something like those techs
12:09:52 <shapr> I'd much rather go with the visual syntax that Wouter van Oortmerssen is using.
12:10:39 <whocares_> shapr: and the rest of the guys i can't get excited with numerical analysis and such....i need something for the end user, and it's fine if it's farther down the road
12:10:56 <whocares_> actually i would just use Fortran for numerical analysis
12:11:16 <whocares_> i guess i'm throwing out the disruptive technology argument
12:11:19 <shapr> whocares_: Welll, the idea behind Intentional Programming was that any algorithm would only need to be written once, and then saved as an AST, sort of... then the source language was just a view onto that AST. You'd choose your flavor and see what you wanted to see.
12:11:30 * TuringTest goes to dinner
12:11:53 <shapr> SubText seems like a cheesy ripoff of Self to me.
12:12:08 <shapr> It's sort of like prototype oriented programming without the 'pro' part :-)
12:12:34 <shapr> I know that's an opinion statement with no facts, but..
12:12:40 <whocares_> i kindof like it
12:12:40 <zellyn> I agree.
12:12:46 <zellyn> It *looks* really cool.
12:12:55 <shapr> whocares_: Have you tried Self?
12:12:58 <wchogg> whocares_:why are you uninterested in numerics?  Just curious.
12:13:02 <zellyn> But I'd like to see something complicated done in it.
12:13:05 <shapr> whocares_: Are you using Linux?
12:13:12 <whocares_> shapr: hehe, yeah, but self is dead and especially dead on x86
12:13:23 <shapr> Even so, it makes SubText look primitive.
12:13:25 <whocares_> shapr: io or lua is the new self i would guess
12:13:47 <whocares_> hell, i would do smalltalk or ruby if they would kickass with a novel environment
12:14:00 <whocares_> well, smalltalk does, but ruby...
12:14:05 <whocares_> but smalltalk has issues
12:14:07 <zellyn> whocares_: ?
12:14:08 <shapr> I'm not sure there is a new Self yet. Nothing has the same simplicity and 'naked objects' interaction.
12:14:17 <zellyn> okay, was about to say that ST's env is nothing if not novel
12:14:33 <shapr> imho, Prototyping is simpler and more elegant than the dual hierarchy of class and instance.
12:14:34 <whocares_> yeah, sorry zellyn, smalltalk enviros rocks
12:14:45 <whocares_> i mean ruby, should have not been ruby included
12:14:48 <shapr> Smalltalk has an image problem ;-)
12:14:57 <whocares_> what's wrong with image!
12:15:08 <whocares_> dolphin produces execs?
12:15:15 <shapr> It's hard to distribute a large image file...
12:15:27 <shapr> Yeah, dolphin is cool, I used it on my Palm IIIx a bit.
12:15:29 <whocares_> changesets and you can exe it
12:15:35 <whocares_> dolphin rocks hard
12:15:57 <shapr> Still, modifying the system means that it's hard to have multiple products installed at the same time.
12:16:04 <zellyn> yeah.
12:16:04 <whocares_> i've got time on my hand now so i guess i have to get medieval on my brain
12:16:09 <whocares_> so functional i go
12:16:15 <shapr> whocares_: Do you have a blog or website?
12:16:20 <zellyn> And I found I was always afraid of somehow corrupting the image.
12:16:23 <whocares_> even though i sometimes think OO is medeival on my brain
12:16:33 <shapr> whocares_: I still think (monads > oop).
12:16:55 <whocares_> shapr: i've got two, but my "why desktop linux is a failure blog" isn't up yet
12:16:58 <shapr> Even so, I suspect there are more elegant abstractions just waiting to be found.
12:17:26 <whocares_> shapr: i've got a huge blog coming up why linux desktop failed
12:17:28 <zellyn> whocares_: I was about to say, the more I learn about Monads (and I'm really new to them), the more cool, and the more "different" they feel.
12:17:57 <whocares_> zellyn: i just want to do the mind bending at this point:)
12:18:06 <basti_> monads are easy
12:18:08 <zellyn> whocares_: ?
12:18:10 <whocares_> zellyn: even if it isn't financially rewarding. i've got money
12:18:12 <shapr> whocares_: Well, make your own decision about OCaml/Clean/Haskell, but be sure to come back here and chat. 
12:18:13 <basti_> they are just a CT interpretation of monoids.
12:18:20 <basti_> and monoids are dead stupid
12:18:23 <basti_> so monads are, too
12:18:27 <shapr> whocares_: If you want mind bending, Haskell wins lambdas down ;-)
12:18:34 <shapr> or should that me with one lambda behind its back?
12:18:40 <zellyn> basti_: heh.  I just haven't been using my brain for that kind of stuff for a while.
12:18:46 <basti_> ;)
12:18:46 <whocares_> oh, no. geek humor
12:18:57 <shapr> Oh right, #haskell shouldn't be funny.
12:18:58 <zellyn> whocares_: if you're after brain-bending, I recommend haskell.
12:19:04 <shapr> We have an ivory tower around here somewhere...
12:19:07 * shapr rummages...
12:19:09 <whocares_> and even worse, lambda/functional "I am beyond geekdom humor" :)
12:19:11 <jcreigh> whocares_: It's only a matter of time before someone works "42" into the conversation...
12:19:21 <whocares_> yes, ivory tower humor:)
12:19:29 <zellyn> I started learning Ruby as part of that "learn a new language each year to keep fit" idea.
12:19:31 <shapr> whocares_: The 'replace emacs' editor has the most recursive name ever...
12:19:33 <basti_> We need new lambda buttons.
12:19:34 <shapr> It's YI
12:19:38 <zellyn> Ruby was really, really boring from that perspective.
12:19:48 <shapr> Ruby's OO model is better than Python's.
12:19:55 <zellyn> Agreed.
12:20:00 <whocares_> here's my deal on ruby.  
12:20:03 <shapr> I prefer significant whitespace and despise explicit END.
12:20:24 <shapr> Ruby isn't any better than Python for real first class code, imho.
12:20:32 <whocares_> it would make a kickass desktop environment in the smalltalk style and coupled with xorg 7.0 and xgl and all that nifty stuff
12:20:34 <jcreigh> zellyn: Yeah, there's not really anything mind-bending in Ruby. It's a nice language for some things, but not mindbending.
12:20:35 <zellyn> DSL's are a whole lot neater in Ruby.
12:20:55 <whocares_> aren't ruby's dsls kindof limiting
12:20:57 <shapr> zellyn: Wait till you hit monad transformers. That makes DSLs nice and easy.
12:21:03 <sieni> well, I hate significant whitespace, but at least Haskell doesn't suck in other respects
12:21:08 <shapr> heh
12:21:18 <whocares_> i see these guys talking about ruby dsls and they're in reality just apis
12:21:27 <franka> What kind of support does Ruby give for DSLs?
12:21:28 <davidhouse> whitespace-gnosticism makes things easy.
12:21:35 <whocares_> not even syntax transformation
12:21:36 <zellyn> whocares_: yes
12:21:41 <zellyn> Really, they're not exactly DSLs.
12:21:51 <zellyn> You just have the ability to make regular function calls look dsl-ish.
12:22:04 <shapr> Which is the 'embedded' part of EDSLs.
12:22:11 <shapr> They're embedded in another language.
12:22:12 <whocares_> ruby does have "define_method" or such and you can put some symbols in
12:22:21 <whocares_> i just don't enough to "really" know
12:22:24 <zellyn> It's one of those things where the logical difference is small, but practical seems bigger.
12:22:38 <whocares_> but some of these guys are just passing off the lack of parantheses as a "dsl"
12:22:50 <shapr> It's hard to pin down the edges of DSL.
12:22:50 <franka> What happens when you try to combine two DSLs in the same program?
12:22:54 <zellyn> Yeah.  Really, that's close to what's going on.
12:22:57 <whocares_> shapr: true
12:23:05 <zellyn> It's really simple.
12:23:07 <franka> Or compose them.
12:23:14 <zellyn> But it starts to become useful nonetheless.
12:23:15 <whocares_> oh, i have a big question
12:23:19 <sieni> franka: wtf? :-)
12:23:28 <whocares_> what can ruby do that Haskell can't?
12:23:31 <whocares_> muwahahaha:)
12:23:32 <zellyn> Kinda like Java can do almost anything Python can do, but the extra lines and characters and classes become a real pain.
12:23:32 <shapr> franka: Works fine in Haskell... dunno about Ruby.
12:23:33 <franka> sieni: What?
12:23:41 <shapr> franka: You had a bunch of ^P chars
12:23:43 <basti_> whocares_: both are turing complete
12:24:03 <whocares_> basti_: so you don't know you're saying
12:24:05 <sieni> franka: see shapr's comment :-)
12:24:12 <franka> ^P characters?  I don't see them myself.
12:24:13 <jcreigh> whocares_: Side effects without a PhD? :-)
12:24:14 <zellyn> Lazy eval.
12:24:16 <zellyn> Currying.
12:24:24 <basti_> no, i just tend to avoid stupid debates ;)
12:24:34 <franka> <-- Are there any there?
12:24:35 <davidhouse> franka: it comes up as "<10><10><10><10>...What happens..." in my client
12:24:36 <zellyn> (without faking / emulating / using call/cc for evil)
12:24:37 <shapr> franka: no
12:24:39 <whocares_> no, in seriousness i hear all these great things about dynamic languages but i hear haskell can do it all with static typeness
12:24:41 <davidhouse> a whole load of <10>s
12:25:10 <franka> Oh, sorry.  It must be my client.  I don't see anything...
12:25:14 <zellyn> whocares_: intuitively, to me, Ruby/Python/Perl feel "loose" to me.
12:25:16 <shapr> whocares_: Well, do it all what?
12:25:16 <whocares_> basti_: i'm just a newbie and want some opionions. when i came in i didn't want to troll:)
12:25:19 <basti_> franka: i think that happened by accident
12:25:25 <zellyn> Java feels "safe" but incredibly annoying.
12:25:35 <whocares_> Java is not safe in the least bit
12:25:48 <basti_> whocares_: the problem is that you're comparing two rather extreme approaches
12:25:50 <whocares_> just like C++ isn't safe
12:26:01 <shapr> whocares_: Haskell's type system is a simplified automated proof assistant. You get the choice to use it as a skeleton to support your program, or ignore it and do anything you like.
12:26:03 <whocares_> basti_: explain
12:26:10 <basti_> static/dynamic, imperative/functional, scriptlike/mathematic
12:26:11 <basti_> al
12:26:13 <jcreigh> whocares_: I must admit that Haskell is the first statically typed language that I haven't hated. Types are actually helpful in Haskell, and aren't there just to get in your way, as in C/C++.
12:26:24 <whocares_> basti_: i can't let you get off that easy. we already know that
12:26:28 <zellyn> ditto here.
12:26:37 <whocares_> ok, so structure subtyping?
12:26:38 <shapr> Yeah, I hated static types before I found Haskell.
12:26:40 <zellyn> I mean, ditto jcreigh.
12:26:51 <zellyn> Static types somehow feel liberating in haskell.
12:26:54 <davidhouse> jcreigh: same here.
12:26:56 <whocares_> duck typing in haskell?
12:27:01 <shapr> whocares_: typeclasses.
12:27:10 <whocares_> shapr: thank you sir:)
12:27:25 <shapr> Typeclasses aren't exactly duck typing, but very close.
12:27:52 <ncalexan> shapr, whocares_: I think existentials and typeclasses are the essence of duck typing.
12:27:53 <magnus--> what do you guys program in haskell?
12:27:59 <whocares_> it looks like Microsoft is going full steam ahead (In a limited way) with C# 3.0.  Java is losing again
12:28:02 <zellyn> I was reading about STM the other day.  And the discussions on what it would take to add them to languages with side-effects seemed like a convincing argument for haskell and the use of monads to keep side-effects contained.
12:28:16 <franka> There are no ^P characters in the logs.
12:28:18 <shapr> I write shellscripts in Haskell.
12:28:24 <whocares_> damnit, i need VS2003
12:28:30 <magnus--> shapr: aha
12:28:31 <whocares_> so i can do VisualHaskell
12:28:37 <ncalexan> I write games in Haskell.
12:28:40 <shapr> I wrote chunks of lambdabot 
12:28:50 <magnus--> ncalexan: any urls?
12:28:57 <whocares_> ncalexan: Tim Sweeney wants to write games in something "like" Haskell
12:28:57 <sieni> magnus--: well, I'd like to program most of stuff in Haskell, but I'm a bit stuck with C right now :-/
12:28:58 <shapr> I wrote a mailing list search webapp in a few evenings after work.
12:29:09 <ncalexan> magnus--: no :(  Maybe I should say I write small pieces of games :)
12:29:13 <monochrom> Typeclass is an organized way to overload operators.  (C++'s way is ad-hoc and chaotic.)
12:29:32 <shapr> It's pretty easy to write stuff in Haskell. The only downside right now is that I wish for more libraries.
12:29:39 <sieni> magnus--: but haskell is certainly equally general purpose language as is C or Perl or Java
12:29:40 <magnus--> ncalexan: hehe... you should try to push one idea all the way
12:30:02 <sieni> (except of course nicer to program in ^_^)
12:30:12 <whocares_> am I the only one that felt creepy about "state" when we had to move from C to C++.  I know C and structs has it, but something about "encouraging" it seemed creepy
12:30:24 <monochrom> heh
12:30:30 <tuomov> sieni: it's not nicer in all cases. I wouldn't even imagine using it for low-level work.
12:30:42 <tuomov> you can do all sorts of low-level stuff, but it's painful
12:30:59 <davidhouse> from what i've seen haskell isn't that nice once you start involving stuff like GUIs.
12:31:01 <shapr> I wonder what would make low-level stuff easier in Haskell.
12:31:05 <davidhouse> it can be done, but not in a pretty way.
12:31:09 <sieni> tuomov: agreed... I've had my share of that
12:31:12 <magnus--> seini: yes I agree... tho for me it's still hard in some ways to get things done in haskell
12:31:24 <tuomov> once you have started involving GUIs, you've already gone awry
12:31:24 <shapr> davidhouse: Arrows are nice for Haskell GUIs, but mostly a black art these days.
12:31:33 <shapr> It's getting better though.
12:31:58 <shapr> I do wish Haskell had good bit level parsers.
12:32:42 <shapr> Still, it does a bunch of things right that other languages should emulate/steal.
12:33:08 <davidhouse> from what i see, haskell would be great for an application centred around hardcore algorithms. but this isn't most apps.
12:33:20 <whocares_> this might sound weird too, but something (at the pshycological syntax level) really sucks about having to make functions static within not-only a namespace, but a fucking class?
12:33:22 <tuomov> shapr: one thing would be bit-level data-types
12:33:35 <shapr> tuomov: Like what?
12:33:36 <tuomov> like c's struct, where you can have exact control of the location of things
12:33:40 <shapr> hm
12:33:52 <monochrom> Here is a difference in operator overloading between Haskell and C++.  Write a template/polymorphic function "f x y = x+y".  Its type signature in C++ is "T f(T, T)"; the type signature does not say that f requires T to support +.  Its type signature in Haskell is "f :: (Num t) => t -> t -> t"; the Num part tells you f requires t to support +.
12:33:57 <whocares_> what is wrong with standalone functions?
12:34:08 <tuomov> I'm not sure that haskell should support such things, however
12:34:11 <shapr> Like a Binary typeclass that let you map a type to bit-level values?
12:34:15 <tuomov> maybe it's best to use C for that
12:34:25 <magnus--> monochrom: the next version of C++ is going to fix that
12:34:29 <shapr> tuomov: I like that idea.
12:34:30 <magnus--> monochrom: with "concepts"
12:34:38 <tuomov> shapr: no, I mean it should facilitate access to raw data
12:34:39 <whocares_> tuomov: that's why i'm exploring functional progrfamming
12:34:41 <sieni> struct layout is confusing enough in C already
12:34:53 <shapr> tuomov: How so?
12:34:55 <monochrom> Yes, concept is probably a highly readable way of expressing typeclasses.
12:35:10 <tuomov> shapr: for binary file access etc.
12:35:17 <monochrom> But until then, C++ sucks :)
12:35:21 <tuomov> so you can just mmap things and so on
12:35:35 <whocares_> monochrom: does familiarty breed contempt? at least with me:)
12:35:40 <tuomov> and of course it would help interfacing with C libraries
12:35:51 <whocares_> we can blame everything on poor Bjarne:)
12:36:19 <magnus--> I still have a sweet spot for C++... C++ does very well without needing a garbage collector
12:36:28 <tuomov> C++ sucks.
12:36:29 <monochrom> But I don't blame anything on Simon Peyton Jones.
12:36:36 <whocares_> who knows. i just hate "classes". I really like the idea of prototypes
12:36:39 <magnus--> all other languages "cheat" by requiring a garbage collector
12:36:57 <Excedrin> C++ requires one too
12:37:00 <tuomov> If I don't want GC, I don't want C++ either, but C
12:37:05 <sieni> magnus--: There isn't much beyond abstract classes and destructors that could be called useful in C++ compared to C
12:37:07 <whocares_> classes just always seemed so restrictive to me
12:37:21 <magnus--> seini: templates are very useful
12:37:24 <davidhouse> whocares_: how?
12:37:35 <Excedrin> it's just that most C++ programmers are happy to write a poor performing "manual GC" in every app
12:37:58 <shrimpx> yea but you can implement smart pointers and tell your friends how awesome you are
12:38:06 <whocares_> davidhouse: just so fragile, as in fragile base classes, and honestly Prototype-based OO programming always seemed like the "human" way to program
12:38:26 <sieni> magnus--: they are also (although both abstract classes and templates solve similar problems as Haskell type classes or ML functors)
12:38:30 <shapr> whocares_: Try monads!
12:38:45 <shapr> Anyway, time for me to sleep.
12:39:00 <whocares_> shapr: i'm lurking and working on it! my first day of serious interest in functional
12:39:04 <iturk> hi there i am trying to compile a simple hello world in eclipse using haskell but when i do run as Ghci section i only get the compiling notes .. i would like to see also the hello world been displayd
12:39:05 <monochrom> If you use those OO design patterns heavily (and what's the point of OO or C++ if you don't?), you need GC.
12:39:16 <iturk> did anyone had already the same problem ?
12:39:22 <tuomov> OO design patterns are crap.
12:39:26 <shapr> whocares_: I'd enjoy talking to you again when I have consciousness to spare.
12:39:31 <tuomov> naive OO is much better.
12:39:34 <whocares_> why do patterns that are needed on top of OO feel creepy?
12:39:38 <sieni> monochrom: you can use C++ as a better C (with destructors and abstract classes)
12:39:41 <whocares_> i'm just not smart enough for OO
12:39:57 <tuomov> no, you're not over-engineerer enough.
12:39:57 <whocares_> i'll stick with straight C
12:40:15 <monochrom> Case in point: the Observer pattern pretty much destroys any hope of safe manual deallocation (other than waiting until the whole program exits.)
12:40:25 <whocares_> OO should be a feeling, not a framework
12:40:49 <whocares_> and IMHO, OO tends to kill bottom-up programming
12:40:59 <monochrom> iturk: try to open the console view.
12:41:05 <tuomov> anything coming out of the "software engineering" school of programming is crap
12:41:16 <whocares_> tuomov: bullshit
12:41:26 <tuomov> yes, bullshit.
12:41:46 <whocares_> tuomov: software engineering is important, it's just that "software engineering" is pushing the wrong low-level tech
12:41:56 <iturk> monochrom: actually there is a haskell compiler output
12:41:58 <shrimpx> do you guys even know what you mean when you say those words?
12:42:11 <iturk> but it says: The compiler output appears here.
12:42:11 <iturk> (If you have turned it on in the Preferences.)
12:42:12 <whocares_> tuomov: "software-engineering" is much, much, much more than coding
12:42:16 <tuomov> "software engineering" is the management types' version of programming
12:42:22 <shrimpx> haha
12:42:23 <tuomov> as opposed to hacking and computer science
12:42:24 <shrimpx> lollerskates
12:42:26 <iturk> i couldnt find the option in preferences 
12:42:29 <whocares_> tuomov: don't get kiddie on me
12:42:51 <whocares_> tuomov: business objectives have to be completed
12:43:01 <tuomov> busyness objectives..
12:43:14 <whocares_> tuomov: fine, then geek out at home
12:43:33 <sieni> tuomov: we had a discussion about these things and we had the conclusion that the "computer scientists" are interested in "p==np" and all that abstract crap and the software engineers are more interested in spanking a bunch of programmers to achieve some programming goal, but nobody seems to actually teach programming
12:43:48 <tuomov> control of programmers on the assembly line
12:43:50 <monochrom> compiler output != hello-world output
12:44:12 <whocares_> sieni: yeah, and the abstract math computer geeks need to educate the "lesser folks" on how they can achieve business goals
12:44:25 <tuomov> sieni: computer scientists are interested in much more than that
12:44:43 <whocares_> until then haskell will be confiscated by Microsoft for their further languages....slowly sanitized for general consumption
12:44:46 <tuomov> Haskell is more a product of computer science, not software engineering
12:45:09 <shrimpx> you know that software engineering is a branch of computer science right?
12:45:13 <whocares_> tuomov: then fine. geek out
12:45:16 <tuomov> C is the hacking language, while java and so on are software engineering languages
12:45:26 <iturk> monochrom: in preferences the compiler should be ghc.exe or ghci.exe ??
12:45:32 <whocares_> java is barely software engineering
12:46:03 <davidhouse> tuomov: if that's your view of how programming should be then it might explain your distate for OO.
12:46:12 <davidhouse> *OOP
12:46:18 <Excedrin> whocares_: if by "barely" you mean "epitome"
12:46:27 <whocares_> davidhouse: i have a bad taste of OO, but tuomov is wrong
12:46:36 <tuomov> Excedrin: there are worse examples
12:46:36 <ValarQ> tuomov: "hacking language"?
12:46:47 <sieni> tuomov: that was more like my colleague's opinion rather than mine, (I'm not that worthy to comment on the subject, since I'm a mathematician by training, not a computer scientist nor a software engineer), but he complained a lot about the lack of proper programming training at Finnish universities
12:46:56 <tuomov> ValarQ: language designed by hackers without much theory of any kind
12:46:56 <davidhouse> tuomov: there's a real world out there. don't forget that.
12:47:14 <whocares_> sieni: so as a mathematician do you think you're a great "hacker"?
12:47:21 <sieni> whocares_: no
12:47:53 <gzl> what is so bad about objects?
12:48:03 <tuomov> I switched to (applied) mathematics after realising how shit programming in the "real world" is
12:48:03 <whocares_> sieni: i'm not a mathematician and i hate the lack of engineering or riigidity of programming
12:48:15 <whocares_> sieni: and hence i'm here
12:48:41 <tuomov> that was already before graduating or doing any real work.. doing a few years in an IT company only reinforced the disgust
12:48:42 <sieni> (but I'm a professional programmer, yes)
12:49:06 <whocares_> tuomov: at least you didn't switch to theoretical math...or you'd be tripping acid and dreaming in topology:)
12:49:22 <monochrom> Interesting, I can't get Eclipse to launch GHCi either.
12:49:30 <davidhouse> maths is great. i'm going to be doing my degree in it. but i regard it as an academic subject, not something that will help me in my day-to-day life.
12:49:42 <whocares_> i feel bad about not furthering my math
12:49:42 <sieni> I'm more like complaining that there needs to be a third branch of training (the actual programming) in addition to computer science and software engineering
12:49:55 <davidhouse> programming, on the other hand, is all about pragmatism.
12:50:00 <whocares_> i feel math is very important for all programmers
12:50:06 <whocares_> just for the sake of logical thinking
12:50:07 <tuomov> sieni: that's something for vocational schools. no that's something for autoditactism
12:50:21 <davidhouse> whocares_: vice versa as well.
12:50:25 <tuomov> you can't be a great programmer by school training
12:50:58 <tuomov> sieni: a problem is that all the university degrees have been inflated
12:51:19 <whocares_> sieni: Steve McConnel is his classic tome "Code complete" calls it a craft.  listen, not every programmer is going to be a Von Neumann
12:51:30 <sieni> tuomov: I disagree. I would say that good programmers could teach programming skills like people teach ship building skills
12:51:46 <whocares_> sieni: there's not enough of you math brains (and frankly many of you math brains suck at "hacking") to produce all the code we need
12:51:56 <Descolada|Work> how would i join #python?
12:52:12 <whocares_> i would join ##ruby
12:52:16 <tuomov> sieni: programs are much more complex than ships
12:52:31 <sieni> tuomov: yeah, right
12:52:31 <Descolada|Work> but my boss wants me to use python, and i have a few questions
12:52:43 <whocares_> Descoloda: /join #cobol
12:52:46 <Poopsmith> Descolada|Work: Er, you don't know how IRC works, do you? Type /join #python. 
12:52:47 <tuomov> I'd go so far as to say that you can't design a program, you hav eto evolve it
12:53:04 <Descolada|Work> i know how it works, it says i need to be identified
12:53:11 <whocares_> tuomov: artificial life in 2070?
12:53:35 <whocares_> i wonder how von neuman would do as a hacker in 2006?
12:53:39 <Descolada|Work> i just dont know what identified on this network means :)
12:53:42 <whocares_> i have a feeling he would suck
12:53:45 <tuomov> whocares_: that's how free software is built. You start out with something small and it grows, without much design.
12:54:01 <whocares_> tuomov: or agile, XP programming
12:54:03 <Poopsmith> Descolada|Work: It means registering a nick with nickserv. 
12:54:10 <Poopsmith> Descolada|Work: /msg nickserv help
12:54:10 <tuomov> designs tend to fail.
12:54:16 <Descolada|Work> ok
12:54:19 <Descolada|Work> kinda lame
12:54:23 <whocares_> tuomov: absolutes fail
12:54:28 <sieni> whocares_: Well, you can call me a math brain if you want, but I'd rather characterize myself as a programmer with a math training.
12:54:32 <whocares_> Descoloda: dude, just /join #python
12:54:41 <whocares_> what's the problem, and why are you programming?
12:55:04 <whocares_> that was mean, i'm sorry
12:55:11 <tuomov> whocares_: of course you have to have some very general outline of what you want, but design at the scale of details of all the classes in a program and so on, will fail
12:55:32 <whocares_> tuomov: once again, absolutes fail
12:55:41 <Descolada|Work> whocares_: you are mean :p
12:55:44 <shrimpx> it would be more logical to bow out and admit that you don't know anything about the software development process than sit here and waste time clogging the channel with empty words
12:55:48 <sieni> whocares_: I don't have any problems, I like programming. I got interested in computers when I was 6 in 1980. I got interested in math something like 5 years later
12:56:08 <whocares_> tuomov: yes, i've always bought into the bottom-up scheme of things, but top-down pseudo-code doesn't hurt
12:56:29 <whocares_> sieni: i'm 36, and still hope to geek out in math
12:56:48 <shapr> Hey, be nice guys.
12:56:57 <whocares_> i said i was sorry
12:57:06 <whocares_> but how did she end up in #haskell
12:57:13 <shapr> she who?
12:57:16 <whocares_> but not know how to goto #python?
12:57:22 <shapr> what?
12:57:27 <monochrom> I bottom-up when I don't understand what I'm doing, e.g., I want an application but I don't know the right architecture for it.  I top-down when I do.
12:57:38 <whocares_> monochrom: yep, yep
12:57:44 <tuomov> a ship is much more "hierarchical" than an interconnected program
12:57:46 <whocares_> monochrom: and you can switch back and forth
12:57:51 * shapr puts an icecube onto whocares_ 
12:57:59 <tuomov> you want the ship to carry a certain amoung of stuff, so you design a hull that can carry that weight
12:58:06 <whocares_> shapr: oh god, shapr was looking for a girlfriend
12:58:16 <shapr> ??
12:58:17 <lambdabot> Not enough arguments to @.
12:58:20 <whocares_> the one chick that has come into #haskell in the last 8 months
12:58:29 <whocares_> shapr starts jerking:)
12:58:31 <shapr> whocares_: calm down man...
12:58:34 <monochrom> I think shipwrights of today understand ships (or existing ships) so much that they can top-down and even use recipes.
12:58:48 <monochrom> Top-down is a sign of maturity.
12:58:49 <shapr> whocares_: Dude, get over it.
12:59:04 <whocares_> shapr: i was already over it bro
12:59:05 <shapr> whocares_: You're being abrasive.
12:59:14 <sieni> wtf? it's thursday and the channel looks like a pub on friday
12:59:29 <tuomov> no top-down is a sign of simplicity, and it shouldn't be forcibly applied to complex things
12:59:36 <shapr> whocares_: Be nice or I kick you out of the channel. That's the rules.
12:59:36 <kolmodin_> sieni: :)
12:59:41 <monochrom> I don't oppose bottom-up.  I oppose insisting on bottom-up forever and never planning to transit to top-down.  The refusal is a sign of refusing to grow up.
12:59:52 <whocares_> shapr: geez, i'm sorry. and i said i was. just because i said "it" was possibly a "she" you throw a fit
12:59:57 <monochrom> (I.e., childish)
13:00:15 <sieni> I'll have some salmiakkikossu to compensate on that
13:00:18 <tuomov> top-down is the authoritarian view
13:00:27 <whocares_> monochrom: agreed
13:00:32 <shapr> whocares_: No, throwing a fit includes kicking you out of the channel. And I said this to you because references to 'jerking' and 'looking for a girlfriend' are offensive and impolite.
13:00:34 <kolmodin_> @remember tuomov C++ sucks.
13:00:34 <lambdabot> Done.
13:00:40 <shapr> At least, the way you said them.
13:00:43 <monochrom> No. Top-down is the don't-miss-the-forest-for-the-trees view.  
13:00:53 <whocares_> monochrom: bottom-up rigidity is that Paul-grahm essay fanboy syndrome
13:00:58 <zellyn> shapr: dunno if you remember chatting about monads the other day.
13:01:04 <shapr> zellyn: Sure yeah.
13:01:13 <zellyn> I've found the idea of "overloading the semicolon" to be quite helpful.
13:01:16 <ihope> @quote
13:01:17 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol squad, but he declined.
13:01:20 <shapr> zellyn: Yeah, I know what you mean.
13:01:25 <kolmodin_> @remember tuomov OO design patterns are crap.
13:01:26 <lambdabot> Done.
13:01:29 <whocares_> ok, how do we think about a whole program? a function right?
13:01:43 <tuomov> top-down is the yes-i-know-everthing-including-how-this-should-be-done-in-every-detail -view
13:01:47 <zellyn> In imperitive languages,  foo() actually means "foo's side effects, and throw away the return value"
13:01:52 <shapr> whocares_: Seriously though, anymore sexist remarks and I'll temporarily remove you.
13:02:12 <sieni> if tuomov said that (OO design patterns are crap), then I have to agree with that
13:02:16 <zellyn> x = foo() means give x the return of foo(), PLUS any side-effects of foo()
13:02:42 <ihope> What about x = foo?
13:03:02 <zellyn> ihope: damn.  [...thinking...]
13:03:07 <whocares_> this comes into the "psychology of programming" that is not nearly enough studied
13:03:33 <whocares_> Weinman....I believe wrote a book that was a bit lacking back in the 70 or 80s or so
13:03:36 <tuomov> excessive top-down thinking creates too rigid structures (and that applies to other things besides programming)
13:03:53 <zellyn> I guess x = foo in that way is really x = id(foo)
13:03:55 <int-e> ihope: if you're a Pascal programmer, you'll expect side-effects from that, too.
13:04:03 <whocares_> tuomov: "excessive" is the keyword, like "excessive" bottom-up is bad
13:04:33 <tuomov> not really, you only need coordination between bottom-up structures
13:04:35 <whocares_> but in my very limited functional career, pure bottom-up doesn't burn you as much
13:04:48 <zellyn> whocares_: dunno if you're reading Steve Yegge, but you might like his latest post: http://steve-yegge.blogspot.com/
13:05:02 <whocares_> i've seen steve's post
13:05:06 <whocares_> in fact, i was there today
13:05:15 <sieni> tuomov: yes, I just noticed, that in C it's better to have weak references in the top -> bottom direction and strong references in the opposite and most of the memory allocation problems take care of themselves after that
13:05:18 <tuomov> like, n people write n libraries, and n+1:th person decides to create a program that uses those libraries
13:05:27 <tuomov> but these libraries do not have all the features he wants, so he requests those
13:05:44 <whocares_> tuomov: all we're saying is that its stupid to be dogmatic in your thinking. it'll only burn you
13:06:06 <tuomov> whocares_: I'm just saying that the "software engineering" school is very top-down
13:06:17 <whocares_> in functional programming, you tend to think top-down instead of implementing top-down
13:06:21 <tuomov> applying the old assembly line principles to programming
13:06:46 <whocares_> agreed, and that comes to bad abstractions
13:06:48 <zellyn> shapr: is there a tutorial-level intro to arrows?
13:06:53 <whocares_> which is the bane of OO
13:07:01 <tuomov> whocares_: you thing top-down at the level of functions, but you build composites of functions from the bottom-up to some vague top-level vision
13:07:11 <tuomov> s/tihng/think/
13:07:17 <zellyn> shapr: crap.  I just remembered http://www.haskell.org/tmrwiki/ArrowsIntroduction
13:07:19 <shapr> zellyn: Er, sort of... 
13:07:27 <shapr> Yeah, that's the one I never finished.
13:07:41 <zellyn> shapr: I had got that mixed up in my mind with the /arrows page on haskell.org, which is rather unhelpful.
13:07:50 <zellyn> Is there a one-line def?
13:07:51 <whocares_> tuomov: no, once again, "we" think all sorts of levels. at the functional programming level we implement bottom-up
13:08:01 <shapr> Of arrows?
13:08:13 <zellyn> Of course, all the one-line definitions of Monads don't make any sense until you already understand them!
13:08:18 <zellyn> But hit me up, just for fun.
13:08:21 <zellyn> Yep, of arrows.
13:08:48 <shapr> Arrows are a generalization of monads. They're sort of like monads that you can paste post-it notes onto...
13:08:57 <whocares_> tuomov: but i agree with your basic point 
13:09:01 <monochrom> I learned arrows by using the arrows in the HXL library.
13:09:08 <whocares_> tuomov: that it's more natural to think bottom-up
13:09:17 <shapr> Monads can't hold any values on them, you can only call a monad. Arrows can do a lot more.
13:09:20 <sieni> I think that the top-down/bottom-up -distinction is irrelevant, since the module dependencies in a program generally form an acyclic graph, and there where you decide to put your root node, there lies your top and the rest is bottom
13:09:32 <whocares_> actually, people think top-down is more natural, but the abstractions never work out that way
13:09:37 <tuomov> it's easier to think small, and act big, than to think big and down to all the details
13:09:55 <sieni> shapr: I don't trust arrows, they are really dubious in some sens
13:09:56 <sieni> e
13:10:01 <shapr> sieni: What sense?
13:10:04 <whocares_> tuomov: but i wasn't clear. i'm talking implementation
13:10:26 <shapr> Opitko Arrowllia?
13:10:32 <whocares_> it's hard to think about major abstractions
13:10:37 <sieni> shapr: all that "hiding lots of stuff inside a pure function"-sense
13:10:39 <whocares_> in fact, it's stupid
13:10:56 <shapr> whocares_: You could always compare code.
13:11:28 <whocares_> that's why functional programming excites me.  where i don't have to "think" about abstractions. they just naturally evolve
13:11:41 <tuomov> yep, evolve.
13:13:24 <shapr> sieni: I rather like arrows.
13:13:56 <shapr> They're otherworldly somewhat, but they're sometimes more powerful and elegant than anything else I've seen. Not always though.
13:13:56 <whocares_> i thought about a nice blogspot for some functional programmer.  "I'm too stupid to not be functional", or another one "I went functional after I realized I was too stupid for OO"
13:14:25 <zellyn> well, later folks.
13:14:27 <zellyn> Must $work
13:14:32 <shapr> ttyl zellyn 
13:14:32 <whocares_> zellyn: later
13:14:53 <whocares_> I think I am too stupid for Java
13:15:20 <whocares_> i need to move to something that doesn't make me thing
13:15:23 <whocares_> think
13:15:31 <whocares_> that sounds crazy
13:16:00 <whocares_> but i think it comes down to bits of code that you know work and you can piece together without worrying about
13:16:09 <iturk> friend >[ 2 * n | n <? [ 2 , 4 , 7 ] , even n , n>3] the result should not be [4,8,14] instead of just [8] ??
13:16:29 <ulfdoz> whocares_: try a tv.
13:16:50 <whocares_> ulfdoz: i tried that and cancelled cable
13:17:04 <iturk> by the way i am doing "list comprehesion"
13:17:13 <whocares_> ulfdoz: they wouldn't let me keep history, discovery, and military channel:)
13:17:15 <monochrom> 4 is the only number satisfying even n and n>3
13:17:24 <tuomov> try assembly line work
13:17:46 <tuomov> then watch telly the rest of the day mentally and physically exhausted
13:17:55 <ulfdoz> hrhr, whaat a solution. :)
13:17:57 <whocares_> tuomov: i'm hedging my bets with functional
13:18:08 <whocares_> tuomov: but i do have a point?
13:18:22 <sieni> whocares_: well, I have noticed that functional style of programming is very useful in a multithreaded network server
13:18:35 <iturk> monochrom: so it will apply the even and n>3 using the list given by parameter 
13:18:39 <whocares_> tuomov: that you can do it and forget it
13:18:55 <whocares_> i could be braindead
13:19:03 <whocares_> we do need average programmers
13:19:12 <sieni> you end up with a nice mixture of functional programming and transactional processing of stuff
13:19:43 <whocares_> sieni: multicore future?
13:19:55 <whocares_> sienie: tim sweeney is worried about that
13:20:07 <tuomov> whocares_: yeah, you should piece together the big idea from smaller modules that, however, do not have strict predetermined specifications, so you can alter them as needed
13:20:29 <whocares_> sienie: sweeney is very worried about the multi-core future
13:20:30 <tuomov> too often in corporate software development "well we have a design already so we can't do that. too bad."
13:20:47 <sieni> whocares_: no, just basic this-day stuff
13:21:00 <whocares_> sieni: i just don't like "OO"
13:21:12 <whocares_> or at least the way "we" think about it
13:21:32 <whocares_> state is bad
13:21:33 <tuomov> OO is too religious, trying to apply it everywhere, where it isn't natural at all
13:21:51 <whocares_> OO is like "what is OO"?
13:21:54 <sieni> whocares_: I was referring to the actual work that I do 
13:21:57 <whocares_> nobody knows
13:22:25 <whocares_> sieni: that's cool
13:22:53 <whocares_> just an average programmer (at best) trying to learn a thing or two
13:23:41 <whocares_> i love how the java programmers on theserverside always blame on "junior" or "inexperienced"  or just plain "bad" programmers.  it's never them
13:23:51 <whocares_> well, i'm an average programmer (if that)
13:24:02 <tuomov> define an average programmer?
13:24:12 <whocares_> that's what's weird
13:24:43 <whocares_> i think i produce decent code. it's not copy-n-paste
13:24:43 <tuomov> I know bad code when I see it, but beyond that it is up to tastes
13:25:12 <tuomov> and everyone makes mistakes
13:25:18 <whocares_>  how do you know bad Java code?
13:25:26 <tuomov> all of it is :)
13:25:29 <sieni> tuomov: well, I would consider myself an average programmer. at least I don't (or wouldn't even do while drunk) such mistakes that I've sadly had to observe in a production codebase
13:26:07 <whocares_> sieni: but what does that mean...be specific. can you throw out some code? nobody throws out bad code
13:26:24 <whocares_> we see it at that one site, but nobody on the fucking planet produces that bad code
13:26:31 <whocares_> we need to see mediocre code
13:26:51 <whocares_> and how do we judge?
13:26:56 <whocares_> Knuth?
13:27:23 <tuomov> I don't think "lots of complicated tricks" is a sign of an excellent programmer
13:27:26 <whocares_> we can see obviously horrible code
13:27:29 <basti_> www.thedailywtf.com
13:27:38 <whocares_> yeah, i know dailywtf
13:27:43 <whocares_> that's insanse
13:27:56 <tuomov> the code is about communication too, not just implementation of some idea
13:28:06 <whocares_> that's not even bad code, that's taco-bell dude that somehow got a gig coding
13:28:25 <whocares_> tuomov: but what is "elegance"
13:28:34 <tuomov> it's up to tastes
13:28:44 <whocares_> ahh, the etheral
13:28:56 <whocares_> ethereal
13:29:02 <sieni> whocares_: not too much, but I can say that the stupidity is something like publishing a public interface and using magic strings to distinguish between stuff (like (whether I'll print this stuff on screen or should I do some other action)
13:29:06 <sieni> )
13:29:24 <whocares_> then i'm at least average
13:29:50 <whocares_> i used to go loco with our 6809 guys just learning C++
13:30:02 <sieni> that's idiotic enough to use in an internal interface (like it's too hard to make a wrapper for the old behaviour))
13:30:04 <whocares_> they were used to cut-n-paste in their realm
13:30:34 <tuomov> I don't even like ranking people like that. there are programmers that shouldn't be programming, and there are other programmers, and they have various different qualities
13:30:35 <whocares_> but then we have the reality of reality of people that don't know the realm
13:30:49 <whocares_> i'm average
13:31:17 <whocares_> i don't suck. when i graduated from college or during i studied "Code Complete"
13:31:41 <ulfdoz> whocares_: The average is just another minority.
13:31:44 <whocares_> and now i know about refactoring "which in a bit of rage i think is somewhat a sham"
13:32:08 <sieni> I'm just talking about C and when I complain to these guys that I don't really understand C++ that well, then one of these guys (who can easily cause segfaults continuously on our test builds) starts telling me how easy c++ is... you just have to understand this thing called object oriented programming...
13:32:23 <whocares_> copy-n-paste is the dirty little secret that is that we hate to admit
13:32:47 <whocares_> oh my god, let me talk about C vs C++
13:33:15 <sieni>  and it's not that funny to realize that you know c++ better than these people only because you have had to fix their mistakes
13:33:16 <whocares_> i'm old school unix hacker (hate unix) 
13:33:47 <whocares_> wait a minute:)
13:33:49 <whocares_> hold on 
13:34:53 <whocares_> i'm hoping your not saying that C++ is better than C?
13:35:11 <mwc> Somebody needs to do for C++ what Scala did for Java
13:35:16 <kolmodin_> @remember tuomov [how do you know bad Java code?] all of it is :)
13:35:16 <lambdabot> Done.
13:35:17 <mwc> and at HOTs while they're at it
13:35:35 <whocares_> C++ is an abomination and there is no need for it
13:35:59 <whocares_> and i've written at least a hundred thousand lines of it (more than any language)
13:36:07 <tuomov> I wouldn't go so far as to say there's no need for it, but there's also no alternative for it
13:36:16 <tuomov> and it is an abomination
13:36:20 <mwc> C++ is an Arquebus compared to a modern assault rifle/language
13:36:20 <whocares_> the alternative is C
13:36:23 <whocares_> straight C
13:36:26 <mwc> but of course, it worked and it still does
13:36:36 <tuomov> C with subtyping..
13:36:36 <whocares_> C++ is what fucked all many, many years ago
13:36:39 <sieni> whocares_: some aspects of c++ are useful (like abstract classes and destructors) but many things are outright harmful (it's hard to know without a trained eye, when an object gets destroyed (or constructed for that matter))
13:36:53 <mwc> Java tried to address the issues of C++, but totally missed the mark IMHO
13:36:58 <whocares_> sieni: it's not the godamn concepts, it's the language
13:37:12 * metaperl- watches with interest
13:37:14 <mwc> easy there, gramps.
13:37:17 <whocares_> sieni: C is the glue
13:37:19 <sieni> whocares_: C is straightforward
13:37:22 <mwc> don't blow an aneurism :P
13:37:24 <tuomov> C with subtyping, templates. That's the useful part.
13:37:38 * metaperl- wonders what was wrong with Objective C
13:37:43 <whocares_> i'm 36...wow, i'm gramps:)
13:37:46 <mwc> What about Cyclone?
13:37:47 <tuomov> add to that tagged unions, and we'd have the perfect low-level language.
13:37:50 <metaperl-> whocares_: me too
13:37:51 <sieni> but C++ does lots of nonobvious stuff, but it still looks like C
13:38:03 <mwc> Cyclone has a lot of that stuff (no templates AFAIK)
13:38:07 <tuomov> metaperl-: I don't like its dual-syntax
13:38:09 <metaperl-> Cyclone?
13:38:29 <whocares_> C was the always the simple plain glue to our system boys 
13:38:30 <mwc> http://en.wikipedia.org/wiki/Cyclone_programming_language
13:38:39 <sieni> The two languages I've liked are Scheme and Haskell and I've also liked Common Lisp and Standard ML quite a bit
13:38:57 <whocares_> our systems boys said,  "here, here's our interfaces to our operating system...love it learn it"
13:39:07 <whocares_> and what did we do?
13:39:11 <whocares_> we bastardized it
13:39:18 <mwc> Cyclone has Tagged Unions and Polymorphism
13:39:32 <sieni> Knowing C as your first programming language is quite comparable punishment to knowing an indo-european language as the first natural language
13:39:33 <mwc> Hahah, yeah
13:39:42 <whocares_> sieni: wrong
13:40:02 <whocares_> sieni: C is how men learn about systems languages
13:40:05 <mwc> What's wrong with knowing English
13:40:11 <mwc> or C for that matter
13:40:30 <sieni> whocares_: I simplified a bit, it's a bit worse to have an indo-european language as a mother tongue as C as the first programming language
13:40:31 <tuomov> umm.. he said knowing as first language
13:40:48 <metaperl-> sieni: what should one's first natural language be?
13:40:55 <mwc> IMHO, a lot of bad code I see from my classmates comes from having them learn Java or higher level stuff first
13:41:03 <whocares_> you mean real language?
13:41:06 <whocares_> as in speaking?
13:41:15 <whocares_> what's this indeo-english shit?
13:41:32 <whocares_> and why is it indeo?
13:41:34 <mwc> knowing what's natural for the computer helps you become proficient in understanding it
13:41:42 <tuomov> http://en.wikipedia.org/wiki/Indo-european_language_family
13:41:43 <mwc> whocares_, he's refering to languages from india and europe
13:41:45 <whocares_> newton script?
13:41:48 <mwc> basically, he's trolling
13:42:03 <sieni> metaperl-: whatever is your native language, of course
13:42:06 <whocares_> stop trolling
13:42:16 <whocares_> ;)
13:42:24 <whocares_> we have one language
13:42:26 <whocares_> it's english
13:42:34 <tuomov> he's right in some sense
13:42:45 <whocares_> it's what all language are and will be made in for the next 2 centuries
13:43:00 <tuomov> english is the dominant language, so it's bad if an indo-european language is your native language, because then you're unlikely to have to learn a very different language
13:43:10 <whocares_> plus, english has scientific basis
13:43:17 <tuomov> english is a fucking mess
13:43:19 <whocares_> i'm sure wikipedia can tell you why
13:43:23 <tuomov> (pronunciation vs. spelling)
13:43:30 <whocares_> it's a fucking mess and that's why it's expressive
13:43:43 <sieni> whocares_: are you like... really drunk, or been smoking some crack or have you just forgotten to take your medication?
13:43:48 <whocares_> remember esperanto?
13:44:22 <whocares_> sieni: what is your politcally correct gestapo problem?
13:44:38 <monochrom> A messy language is great for poetry.
13:45:04 <whocares_> monochrom: and great for science
13:45:38 <sjanssen> whocares_: I would make the case that precise languages are best for science
13:45:48 <mwc> you need to read what Mark Twain said about reforming english spelling. http://www.stats.gla.ac.uk/~ernst/linguistics/mark_twain_spelling.html
13:45:53 <whocares_> sjanssen: that's what german was for
13:45:56 <mwc> Mmm. Lojban
13:45:58 <mwc> Hahaha, no
13:45:59 <whocares_> actually, german wasn't
13:46:01 <mwc> German is terrible for science
13:46:11 <whocares_> and therfore english
13:46:22 <whocares_> english is much more expressive than the latin languages
13:46:32 <mwc> You know what some german wanted to call a betatron?
13:46:34 <mwc> Ausserordentlichhochgeschwindigkeitelektronenentwickelndenschwerarbeitsbeigollitron.
13:46:37 <whocares_> and therefore some asshole rage frome sieni
13:46:40 <sieni> Somebody could call me a cynicist, but I would say that simple languages are best for science
13:46:49 <mwc> somebody here must speak german and can vouch that that is not gibberish
13:46:59 <tuomov> science papers tend to use very simple english..
13:47:03 <sjanssen> mwc: I love how Germans get to squash words together, I wish I could do it more often
13:47:13 <whocares_> german is not gibberish, but very ultramondecomplexweirdolongwords
13:47:24 <sieni> whocares_: Yes, I agree that I'm an asshole and my real-life friends tend to agree with that quite often
13:47:27 <mwc> they just refuse to make up new words
13:47:29 <tuomov> youdunnoanythingaboutultracomplexlongwords
13:47:34 <tuomov> tryfinnishandyoullseesomeofthem
13:47:42 <monochrom> sjanssen: Like MonadAsContainers ?
13:47:57 <whocares_> sieni: fine, i'm an asshole too
13:47:59 <mwc> If you can beat that 1000 character jawbreaker in finish, I'll tip my hat to you
13:48:23 <whocares_> there is actual history behind the rise of german to english in science
13:48:31 <whocares_> and a little bit of science
13:48:35 <sjanssen> monochrom: yes, but WikiNames aren't exactly blessed by English
13:49:12 <whocares_> the story "if IIRC" is that english is like Ruby compared to Java
13:49:21 <whocares_> well, that wasn't the story, but...
13:49:54 <tuomov> it's more to do with other events in world history.. like the nazis
13:50:03 <whocares_> tuomov: nope, wrong
13:50:17 <whocares_> there's actual historical stories on the change
13:50:34 <whocares_> english is just more malleable and less verbose than latin languages
13:50:54 <whocares_> definitely less verbose
13:50:56 <tuomov> german is not a romance ("latin") language
13:51:00 <whocares_> i know
13:51:18 <tuomov> it's an anglo-saxon language in the very same family as english
13:51:24 <whocares_> therefore german wasn't going to go to french or italian or spanish
13:51:50 <whocares_> tuomov: and as you said,  english is somewhat german
13:52:02 <whocares_> well, english is german
13:52:11 <whocares_> from like 2000 years ago or so
13:52:26 <tuomov> english is a mishmash of a bit everything
13:52:34 <tuomov> lots of french words there
13:52:46 <tuomov> but it has an anglo-saxon base
13:55:14 <sieni> I think I need to get some sleep
13:55:15 <whocares_> western germanic tribes moves to the island of england who knows how many thousands of years ago
13:55:27 <whocares_> but yes, english is a mish-mash
13:55:41 <whocares_> just think of english 50 years from now
13:56:02 <whocares_> since it's the international language it'll evolve even more
13:56:05 <whocares_> at a faster pace
13:56:43 <tuomov> if it just had any correlation between spelling and pronunciation..
13:57:36 <tuomov> but it tends to borrow things together with their spelling and pronuncation from different sources
13:57:42 <whocares_> we don't need no stinkin' spelling:)
13:57:53 <whocares_> where you from tuomov?
13:57:56 <tuomov> .fi
13:58:00 <whocares_> cool
13:58:10 <whocares_> you're spelling is fine
13:58:15 <bolrod> w/ in13
13:58:18 <bolrod> oops
13:58:19 <whocares_> see, i fubar'd it
13:58:22 <tuomov> and finnish has one of the most phonemic correspondences between pronunciation and spelling
13:58:26 <whocares_> i said you're instead of your
13:58:51 <whocares_> tuomov: you're not a smalltalker, what are you doing here?
13:58:54 <whocares_> :)
13:59:16 <whocares_> tuomov: then english must kill you
13:59:41 <whocares_> the scandanavians always do good enough
14:00:09 <whocares_> well all of europe
14:00:10 <tuomov> note that scandinavian (which does not include finland!) are also anglo-saxon
14:00:19 <tuomov> +languages
14:00:33 <whocares_> sorry, dude. i almost thought that about finland. sorry
14:00:54 <tuomov> the anglophones often include finland in scandinavia, but that is not the case either in geographical or cultural sense
14:01:13 <whocares_> what amazes me is the danes
14:01:20 <tuomov> finland and scandinavia and iceland are the "nordic countries", though
14:01:26 <whocares_> the danes speak almost perfect american english
14:01:41 <whocares_> tuomov: sorry dude
14:02:09 <tuomov> I speak crappy english
14:02:24 <whocares_> yep, i'm just a stupid american that should feel bad for my stupidness for some odd politically-correct reason
14:02:43 <whocares_> actually for a stupid american i do know your countries on a map
14:02:55 <tuomov> you're above-average american then :)
14:02:55 <whocares_> always loved my geography
14:03:14 <whocares_> yeah, well fuck you still
14:03:30 <whocares_> i could say some things
14:03:37 <whocares_> but we always hold back
14:04:04 <whocares_> tuomov: what's the temp there right now?
14:04:12 <tuomov> -3.3
14:04:28 <whocares_> about 28 or so F i guess
14:04:33 <tuomov> (celsius, not stone age measures)
14:04:34 <whocares_> cold
14:04:45 <int80_h> Hi, I'm trying to use the hugs server that comes with hugs
14:04:56 <tuomov> warm :)
14:05:07 <whocares_> tuomov: yeah, it's stone age for the most technologically advanced, richest country to ever exist.....do you want to play with me?
14:05:08 <CosmicRay> I didn't know hugs came with a server
14:05:10 <int80_h> I converted the server.html file to text
14:05:18 <int80_h> yeah you can use it to serve cgi
14:05:18 <tuomov> and it's getting warmer despite time being 01:04
14:05:27 <int80_h> which is what I would like to do
14:05:40 <tuomov> possibly plus degrees (!) tomorrow
14:05:42 <int80_h> but I'm wondering if I have to seperate the code out into tw or more files
14:06:04 <int80_h> it could be that I'm too new and I should just get to the buisess of learning the language and get to the fancy stuff later
14:06:10 <whocares_> tuomov: yeah, it's cold in backward ass countries like yours
14:06:24 <tuomov> whocares_: tech. advanced? More like the backwards country with all the christian religious nutters..
14:06:26 <int80_h> you mom is a backward ass country
14:06:33 * int80_h snorts
14:06:35 <sjanssen> is celsius technically superior to fahrenheit?
14:06:47 <int80_h> I would say morally superior
14:06:55 <whocares_> tuomov: who went to the moon in '69? enough said
14:07:15 <shapr> Guys, you left the topic in the dust..
14:07:17 <sjanssen> I mean, I'll agree that metric lengths, weights, and such are way better
14:07:24 <whocares_> metric rocks
14:07:28 <monochrom> Kelvin rocks
14:07:31 <int80_h> yeah, I was hoping to get a haskell cgi server today
14:07:32 <whocares_> but shut the fuck up tuomov
14:07:36 <tuomov> the thing with metric is that the factors are regular
14:07:42 --- mode: ChanServ set +o shapr
14:07:48 <sjanssen> ah yes, Celsius is more easily convertible to Kelvin
14:07:54 <whocares_> tuomov: you backward ass fin who gets their ass kicked by the russians at any chance
14:07:55 <shapr> Look, take the flames elsewhere.
14:08:01 --- kick: whocares_ was kicked by shapr (Kicked by shapr)
14:08:05 <tic> sheesh.
14:08:06 <tic> what's that about
14:08:10 * shapr grumbles
14:08:16 <tuomov> sjanssen: also between centimeter, meter, nanometer, etc. while the conversion between inches and feets and so on.. I don't want to think about it
14:08:17 <int80_h> haven't seen a flamer in this channel in a good long while
14:08:26 <shapr> int80_h: It happens.
14:08:26 <int80_h> which is to say, never
14:08:30 <sjanssen> this guy has been weird for the past fifteen minutes
14:08:39 <mwc> yeah, I tuned out there for a bit
14:08:41 <Excedrin> hour or two
14:08:41 <int80_h> shapr, any ideas on how to use the server that comes with hugs?
14:08:50 <shapr> Sorry, I haven't tried it.
14:08:55 <mwc> Server?
14:09:01 <mwc> HaskellTTP?
14:09:09 <int80_h> no, it comes with hugs
14:09:20 <mwc> Serves what it?
14:09:26 <int80_h> or rather, it uses hugs as a server
14:09:31 <int80_h> serves cgi pages
14:09:34 <mwc> Ah
14:09:36 <mwc> Cool
14:09:39 <int80_h> two other uses, let me find the docs
14:09:47 <int80_h> oh you can serve shells and...
14:09:57 <sjanssen> hugs comes with an HTTP server?  that's neat
14:10:24 <int80_h> ooh you can also use it to embed haskell code in your web pages
14:10:32 <mwc> Like an SSI?
14:10:44 <int80_h> not sur how it works. As I can't get it to work
14:10:54 <int80_h> docs say server.html is a complete example
14:11:07 <int80_h> it could be I'm too new to understand what to do
14:11:25 <int80_h> I should just sog through my textbooks.
14:11:27 <int80_h> slog
14:11:40 <whocares_> int80_h: what, you trying to set up  a server?
14:11:51 <int80_h> yeah, I'd like to use haskell to serve cgi
14:12:00 <int80_h> using the code that comes with hugs
14:12:13 <whocares_> int-80: it might be better to learn the language and set up another server
14:12:15 <mwc> Might be easier to compile a CGI app using GHC and just drop that in the cgi-bin directory?
14:12:42 <int80_h> awe, I had my heart set on hugs
14:13:06 <whocares_> int80_h: dude, then do it
14:13:17 <mwc> I used hugs for a week when I started haskell, but I got the impression that GHC is what's used by everybody and their brother
14:13:28 <int80_h> yeah, I'm just too new. I will be patient and learn the language. Then it should be clear how to use the example code
14:13:39 * int80_h just wanted to show off for his friends
14:13:51 <whocares_> int80_h: why do you have to show your friend?
14:14:00 <int80_h> to be cool, duh ;)
14:14:02 <mwc> Once you get a stack of about 3 or 4 monads, you can really show off
14:14:26 <tic> mm monad transformers..
14:14:29 <int80_h> onads! eep!
14:14:33 <whocares_> actually, some killer web app is the "disruptive tech", but how haskell will do that
14:14:52 <int80_h> ah speaking of disruptive tech, are the mailing lists archived somewhere?
14:14:55 <whocares_> "web app" that makes my ears cringe
14:15:19 <mwc> nothing like a State inside a WriterT inside a StateT :D
14:15:29 <whocares_> i'm gonna serve up XAML 
14:15:35 <whocares_> in some functional
14:15:38 <whocares_> in a dsl
14:15:47 <mwc> XAML? MSXUL you mean?
14:16:05 <whocares_> XAML or WPF/E rather
14:16:21 <whocares_> html is sick
14:16:23 <tic> I think the point he's trying to make is that MS is just copying Mozilla's XUL.
14:16:29 <whocares_> in a bad way, IMHO
14:16:39 <tic> whocares_, you seem to see everything in black and white.
14:16:40 <mwc> tic, exactly. Needless standards/api proliferation
14:16:57 <tic> mwc, well, that's business as usual for you :/
14:17:05 <int80_h> bbl later gang
14:17:09 <whocares_> tic: huh? i just want something new for functional languages to flourish
14:17:19 <whocares_> XAML/WPF/E will flourish
14:17:29 <sjanssen> what is WPF/E?
14:17:29 <tic> whocares_, "html is sick". blam. 
14:17:33 <whocares_> if you want to get political about open source then be it
14:17:36 <whocares_> nahh
14:17:39 <whocares_> tic: nahh
14:17:40 <tic> sjanssen, windows presentation foundations/E-something.
14:17:47 <mwc> tic, yeah, I'm convinced that the whole Tower of Babel myth was actually prophecizing the internet standards mess :P
14:17:55 <whocares_> tic: i mean html is sick in the way that we're trying to bend it
14:17:57 <mwc> WPF/Extreme?
14:18:02 <tic> mwc, "Standards are a good thing, because there are so many to choose from!"
14:18:15 <tic> whocares_, bend it? I don't think so. XHTML is usable.
14:18:24 <tic> I shouldn't be saying this. but aol.com.
14:18:26 <whocares_> uhhmm, is XMLHtppRequest a standard?
14:18:28 <whocares_> ooops?
14:18:34 <whocares_> let's face facts
14:18:39 <whocares_> w3c is dead
14:18:40 * tic awaits the lols
14:18:48 <mwc> whocares_, haskell-blah?
14:19:10 <monochrom> #haskell-blah
14:19:16 <whocares_> all we care about are mozilla and IE and the ankle-biters
14:19:28 <tic> don't feed the troll...
14:19:40 <whocares_> or i guess the gpl-jihadists care about more
14:19:43 <sjanssen> BUT I'M HUNGRY!
14:19:47 <sjanssen> hehe
14:19:51 <whocares_> feed me, feed me
14:19:59 <whocares_> puhhlease
14:20:17 <whocares_> open source jihadists need not apply
14:20:28 <tic> So, I think I should play some tunes on the recorder and perhaps go to bed. It's late after-all.
14:20:36 <shapr> dude, take it to #haskell-blah or other non #haskell place if it's not about FP or Haskell.
14:20:43 * shapr goes to sleep
14:21:07 <whocares_> sorry to piss people off
14:21:11 <tic> I note the choice of nick name and using certain words in a strictly negative fashion shows the lack of respect in whoever is behind that keyboard.
14:21:19 <tic> whocares_, no, you're obviously not sorry about it.
14:21:40 <tic> whocares_, if you say something, the least you can do is to stand for it.
14:21:52 <whocares_> stand for what? i stand for everything i've said
14:22:09 <whocares_> that i rip on open-sores idiots?
14:22:26 <whocares_> i've been using linux before probably 85% of yo
14:22:34 <tic> whocares_, calling people idiots will get you banned fairly soon.
14:22:46 <whocares_> who did i call an idiot?
14:22:47 <tuomov> tic: I also think it's worse than sick to what html is bent to
14:22:49 <Igloo> tic: So will feeding trolls
14:23:02 <tic> Igloo, sorry. I should stop. I'm just bad at this.
14:23:04 <tic> Nigth guys!
14:23:11 <whocares_> tic: are you can admitting to be an open sore?
14:23:42 <tuomov> "web applications" are an abomination
14:23:50 <monochrom> tic: You should stand for what you have said rather than escaping to bed! XD
14:23:52 <whocares_> they are
14:24:13 <whocares_> it's an abomination for developers for sure
14:24:17 <tuomov> now, I'm not against applications running in a browser window, but HTML is not the tool
14:24:31 <whocares_> we love deployment
14:24:49 <whocares_> but let's not get sick school-girl on the AJAX
14:24:58 <Philippa_> HTML works fine if it's a form-based app
14:25:31 <tuomov> http://www.netvibes.com/ <-- there's one one horror
14:25:34 <tuomov> -one
14:25:38 <whocares_>   the only reason i bring it up is because the dynamic boys are sucking it up these days
14:26:03 <tuomov> you can move the boxes around an everything.. a complete WIMP desktop in html
14:26:31 <Philippa_> is it genuinely nothing but HTML?
14:26:32 <whocares_> please don't try to convince be about the "greatness" of dhtml
14:26:38 <tuomov> javascript, of course
14:26:50 <whocares_> yes, "D"html
14:26:56 <tuomov> "web 2.0"
14:26:59 <tuomov> (I'll wait for -2.0)
14:27:01 <whocares_> oh no
14:27:04 <whocares_> can i get 3.0
14:28:01 <whocares_>  can we get 3.0 already?
14:28:21 <tuomov> knowing 1.0 and 2.0, I'd rather see -2.0
14:28:26 <whocares_> is everybody a web monkey?
14:28:40 <whocares_> and us thick, real clients a minority now?
14:29:01 <whocares_> so everything can be done in DHTML, which obviously has massive limitations
14:29:17 <tuomov> aspecially wrt. usability
14:29:59 <whocares_> tuomov: beyond that. have you seen flex2 or xaml demos?
14:30:05 <tuomov> no
14:30:08 <whocares_> maybe i just expect more
14:30:35 <tuomov> what's flex2 anyway?
14:31:06 <whocares_> tuomov: adobe(macromedia's) new flash framework. very impressive and eclipse-based
14:31:28 <whocares_> it's for GUI app people, not designer people
14:31:36 <tuomov> and GUIs suck.
14:31:42 <whocares_> they do?
14:31:45 <tuomov> yep
14:31:48 <whocares_> how so?
14:31:49 <tuomov> (google for tuomov)
14:31:54 <whocares_> no
14:31:56 <whocares_> tell me
14:32:14 <tuomov> I've written about it a lot
14:32:16 <whocares_> sounds interesting
14:32:21 <whocares_> i'm very interested
14:32:24 <tuomov> http://www.modeemi.fi/~tuomov/ion/
14:32:38 <tuomov> http://www.modeemi.fi/~tuomov/vis/
14:32:48 <whocares_> well, ok, i'm on your page
14:33:07 <tuomov> http://www.modeemi.fi/~tuomov/b/archives/2006/02/12/T21_08_50/
14:33:16 <whocares_> and i haven't read yet, and i reallly, really, really, appreciate new thinking on the desktip
14:33:30 <whocares_> can i say something first
14:33:47 <SyntaxNinja> can we take the off-topic discussino to #haskell-blah, please?
14:34:01 <whocares_> the problem with non-windows, non-mac desktops are that they are not smalltalk environments:)
14:34:06 <tuomov> it's not like there's much other discussion atm..
14:34:15 <whocares_> in that, you should be able to control everything
14:34:33 <tuomov> and I should go to sleep too
14:34:34 <whocares_> you want some advice?
14:34:41 <whocares_> one piece of advice
14:34:53 <SyntaxNinja> tuomov: how could there be?
14:35:09 <whocares_> fork squeak/croquet and leverage the opengl capabilities of XGL
14:35:27 <whocares_> make everything completely customiable
14:35:41 <whocares_> that's the only chance for the "linux" deskop"
14:35:47 <whocares_> to be different
14:35:56 <whocares_> goto sleep dude. i'll read your paper
14:36:06 <whocares_> wait!
14:36:09 <whocares_> i already know it
14:36:29 <whocares_> and i totally disagree, but not in a fundamental way since i'm usually full-window
14:36:46 <whocares_> you were on osnews.com a while back
14:37:16 <whocares_> who knows....vi for window managers?
14:37:51 <whocares_> anyway, later folks, if you hate me then fuck off
14:38:36 <astrolabe> Don't see why I should.
14:39:21 <basti_> how boring
14:40:25 <SyntaxNinja> sigh
14:46:34 --- mode: shapr set +b *!*@*.ipt.aol.com
14:47:06 <shapr> That boy needs Ritalin more than I do.
14:48:16 <SyntaxNinja> heh
14:48:31 <shapr> I told him in privmsg that if he started swearing again I'd ban him.
14:49:54 * dcoutts supports shapr 
14:50:03 <dcoutts> (for president)
14:50:13 <musasabi> Any good ideas for debugging while a deriving(Read,Show) seems to infer functions which don't work?
14:50:19 <Muad_Dib> shapr for holy emperor of the huniverse!
14:50:24 <musasabi> while -> why
14:50:27 * Igloo would have banned him only everyone else seemed happy enough talking to him, and I wasn't really around anyway
14:51:02 <SyntaxNinja> I almost put on my bike helmet.   but that's just because I got a new one just now.
14:51:26 <Muad_Dib> SyntaxNinja: pic! :)
14:51:39 <musasabi> all the member types of the record work for read/show.
14:52:00 <sjanssen> musasabi: don't work in what way?
14:52:16 <SyntaxNinja> Muad_Dib: this one. but it was on sale: http://store.yahoo.com/jeanswesterner/gispheco2.html
14:53:28 <int-e> Heh. Somehow I had expected that ban to affect more people ... but I can't find any AOL users here.
14:53:54 <musasabi> sjanssen: in the read . show -> "*** Exception: Prelude.read: no parse" way.
14:54:03 <Muad_Dib> SyntaxNinja: into what kind of bicycling are you? speeding? off road?
14:54:07 <Lemmih> CosmicRay: 404
14:54:22 <Muad_Dib> err
14:54:28 * Muad_Dib hops onto #haskell-blah
14:57:52 <CosmicRay> Lemmih: on what?
14:58:07 <ralejs> musabi:can you give a small example when the read . show breaks?
14:59:10 <musasabi> let r = Request ... ; read (show r) :: Request
14:59:25 <musasabi> hmm, does readsPrec have to accept space?
15:07:11 <ralejs> well, according to the report: (x,"") is an element of (readsPrec d (showsPrec d x ""))"
15:09:25 <ralejs> So read . show should hold if they are derived. If that's not the case then it's a bug in whatever implementation you're using
15:11:31 <musasabi> hmm, seems that if I make things accept the extra space then they work.
15:12:10 <musasabi> -> sleep, too tired to think or write english.
16:16:08 <dons> moin
16:16:43 <JKnecht> gday
16:18:23 <resiak> Any pointers for reading matter relating to creating bindings to C libraries?
16:19:46 <dons> ?where ffi
16:19:47 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:20:22 <dons> I don't know of a tut. check haskell.oorg perhaps
16:21:30 <JKnecht> http://www.haskell.org/hawiki/C_2b_2bFromHaskell
16:23:27 <JKnecht> http://www.haskell.org/hawiki/FfiTutorial
16:24:05 <dons> ah, good.
16:24:16 <dons> that should be moved to the new wiki
16:24:59 <Descolada|Work> there was one good tutorial for haskell, a tutorial for C programmers or somthing
16:34:26 <resiak> Thanks all, those look ace.
16:36:20 <dons> it's pretty easy to do a binding, just a matter of a 'foreign import' with the Haskell type and the C ident name
16:38:41 <Igloo> Just beware of mixing up things like Haskell's Int and C's int (matching pairs are Int/HsInt and CInt/int)
16:39:28 <Pseudonym> Yay, I get to use Haskell for my job again!
16:39:50 * Pseudonym loves it when that happens
16:39:53 <dons> yay!
16:40:02 <lispy> heh, i don't get to use haskell because we're giving the code to the client :)
16:40:16 <Pseudonym> That doesn't worry me.
16:40:17 <lispy> so i get to use java...(/me was hoping for python)
16:40:24 <Pseudonym> I have a tricky custom curve fitting/denoising problem.
16:40:50 <Pseudonym> And I'm using Haskell to do the symbolic algebra required to produce the appropriate algorithm.
16:42:26 <lispy> i'm writing a java program to fetch gis data from a database, display it and then delegate computations to R code
16:42:45 <lispy> it's a weird learning experience
16:43:58 <lispy> most of the code for doing this is available in libraries, but getting the libraries to compile, instantiate and cooperate is really hard
16:45:37 <JKnecht> I used the ArcGIS stuff from ESRI.
16:47:03 <JKnecht> uses the glue framework from I forget who.
16:49:57 <JKnecht> Mind Electric, but I guess better known as "Web Methods".
16:50:08 <dons> Pseudonym, do you have any online Haskell code? aqsis isn'twritten in .hs is it?
16:50:27 <Pseudonym> Nope.
16:50:36 <dons> (I'm expanding the libraries and tools section of the wiki)
16:50:37 <Pseudonym> I generally don't put most of my code online.
16:50:43 <Pseudonym> However...
16:50:50 <Pseudonym> http://andrew.bromage.org/darcs/
16:50:59 <dons> ah!
16:51:04 <Pseudonym> I promise to put it there as appropriate.
16:51:12 <dons> ok.
16:51:30 <dons> numbertheory looks interesting.
16:51:42 <dons> looks highly suitable to go on the Math page.
16:51:46 <Pseudonym> Yes.
16:51:49 <Pseudonym> It's good stuff.
16:51:57 <Pseudonym> There's a lot more I want to do, though.
16:52:43 <dons> lispy, put any Haskell code online yet?
16:53:03 <dons> I've discovered in my trawling that much much good code never gets announced onn haskell@ :|
16:55:15 <dons> keeping us divided and conquered, in comparison to cpan
16:56:42 <JKnecht> Number Theory? There's a harithmetik or somesuch?
17:00:03 <dons> harithmetik?
17:00:16 <Excedrin> Pseudonym: do you use vim?
17:00:39 <ihope> Harithmetik?
17:00:45 <ihope> That's... hmm.
17:02:25 <JKnecht> 30K hits from google on number theory and haskell but nothing fitting the bill.
17:02:53 <Pseudonym> Yes, I use vim.
17:03:30 <Pseudonym> The number theory stuff is currently primes, fibonacci sequences and combinatorics.
17:04:40 <Excedrin> Pseudonym: do you use autoindent/smartindent?
17:07:55 <Smokey`> mmm, I'm still not a fan of vim, went through most the tutorials and everything... definately prefer Kate over everything else for *nix environments,  I use the mouse to select/copy/drag/duplicate alot (that being said, I dont see myself doing that soo much in Haskell, as opposed to C++)
17:08:54 <Excedrin> I'm addicted to vi style command and edit mode
17:09:30 <Excedrin> I wish my irc client supported vi commands for entering text :P
17:09:33 <dons> anything not listed here: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics ?  
17:09:40 <dons> JKnecht ^^
17:09:44 <Smokey`> yeah, alot of people are...  I guess after growing up in windows though, and Visual Studio... i'm kinda acustomed to that kind of editing, as opposed to vi.
17:09:55 <dons> Excedrin, I wrote a partial smart indenter for vim, ftp://ftp.cse.unsw.edu.au/pub/users/dons/vim/indent/
17:10:02 <Excedrin> thanks
17:10:54 <palomer> hrmph
17:10:58 * palomer wonders where lennart is
17:11:00 <dons> but I only use: set comments=bO:--
17:11:29 <dons> set formatoptions=tcqr in practice.
17:11:37 <dons> (to indent after --)
17:12:00 <ihope> @get-lennart
17:12:00 <lambdabot> Unknown command, try @list
17:12:03 <dons> hmm. I could probably write a much smarter indenter now by calling into a nice Haskell parser
17:14:51 <dons> ?palomer lennart is back in sweden, I think
17:14:51 <lambdabot> hrmph
17:15:15 <dons> shame on you, lambdabot
17:20:11 <Smokey`> hmmm, that foreign import thing gives me some ideas :P
17:20:47 <ihope> @help palomer
17:20:48 <lambdabot> palomer. Sound a bit like palomer on a bad day
17:20:56 <ihope> @help ihope
17:20:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:20:59 <ihope> Hm.m
17:21:32 <JKnecht> Andrew Bromage's lib very slight. Something like a Haskell companion to Joe Roberts Elementary Number Theory or an actual combinatorial optimization lib was the kind of thing I meant.
17:23:08 <Pseudonym> Sorry, Excedrin.  I use autoindent, yes.
17:23:42 <Pseudonym> JKnecht: Like most open source people, I write code to scratch an itch.
17:24:07 <Pseudonym> I needed n choose r to compute some probability distributions, so that's what I wrote. :-)
17:24:24 <JKnecht> I'm pretty sure I've seen a combinatorial opt. package. Not in Haskell of course.
17:24:31 <Pseudonym> Sure.
17:26:38 <JKnecht> Oh yeah, Mathematica has Combintorica.
17:29:41 <dons> ?seen rizzix
17:29:41 <lambdabot> I saw rizzix leaving #haskell 1 day, 19 hours, 49 minutes and 6 seconds ago, and I have missed 23 hours, 49 minutes and 46 seconds since then.
17:31:03 <fizbin> Heh.  I just wrote n choose r in haskell today too.
17:40:29 <fizbin> pChooseQ p q = (p-q+1) * (pChooseQ p (q-1)) `div` q
17:41:05 <fizbin> Plus appropriate base cases
17:52:46 <fizbin> So is the standard here to use paste.lisp.org, or the paste page on hawiki?
17:53:36 <Lemmih> I like lisp paste more.
17:55:25 <fizbin> I just wish that the lisp paste would colorize haskell properly.
18:03:28 <fizbin> I've got a structure that's kind of like a Monad, only it can't be since it's a type constructor that only works on types that are Ord instances
18:04:07 <fizbin> Anyway, when working with it, I end up using syntax like what's at the top of http://www.haskell.org/hawiki/HaskellIrcPastePage
18:04:38 <fizbin> Does anyone have any suggestions for a better syntax?
18:06:26 <fizbin> Because currently it feels like a bad abuse of lambda and precedence rules.
18:06:50 <heatsink> The >=> \x -> looks like it should be written in do-notation
18:07:04 <Lemmih> fizbin: Is ProbWorld a Monad?
18:07:22 <fizbin> I've got a structure that's kind of like a Monad, only it can't be since it's a type constructor that only works on types that are Ord instances
18:07:49 <heatsink> oh, I recall that conversation, sort of.
18:11:22 <heatsink> I don't have any suggestions, sorry.
18:13:40 <Lemmih> dons: ping. I managed to call lots of out-of-scope functions (:
18:13:59 <Lemmih> Advanced debugging with GHCi: http://darcs.haskell.org/~lemmih/DebugLog.txt
18:15:04 <dons> !
18:15:40 <heatsink> that's.... interesting.
18:15:48 <dons> cool cool
18:15:53 <fizbin> I can't use do notation.  I tried to import from the Prelude everything except the Monad functions and define my own >>=, but GHC rejected my attempt to use do notation - somehow GHC still needed it to be a real Monad instead.
18:15:55 <dons> I gotta get me into this actoin
18:16:06 <Lemmih> Surprisingly easy to hack.
18:16:08 <dons> Lemmih, is hasp online somewhereE?
18:16:29 <dons> so what's your plan with this? where are you taking the ghc-api?
18:16:36 <Lemmih> dons: Yeah, but it's a bit bitrotted.
18:16:38 <dons> have you looked at Ennal's debugger for ghc?
18:16:58 <dons> I thought I'd document it on the wiki for posterity
18:17:08 <Lemmih> Ennal's debugger? No, got an URL?
18:17:47 <dons> ?google Robert Ennals non-stop ghc
18:17:48 <lambdabot> http://research.microsoft.com/~simonpj/Papers/papers.html
18:18:03 <dons> it was at 2003 HW, iirc
18:18:24 <dons> maybe here: http://research.microsoft.com/~simonpj/Papers/optimistic/index.htm
18:18:46 <dons> maybe not that one
18:18:56 <dons> let me see...
18:19:07 <dons> (it's the interface you might want to borrow from)
18:19:58 <Lemmih> Isn't the GHCi interface good enough?
18:20:10 <dons> oh, well, if you're going to write a full debugger :)
18:20:18 <dons> it's worth a read anyway
18:20:28 <dons> http://www.cambridge.intel-research.net/~rennals/hw2003.pdf
18:20:44 <dons> "Debugging Lazy Programs by Not Being Lazy"
18:20:53 <dons> gdb-like debugging
18:20:55 <dons> with breakpoints
18:22:22 * Lemmih reads.
18:24:07 * Igloo dons Do "hoover" have "dyson" have the same meaning over there as here?
18:24:10 <Igloo> Doh
18:24:47 <liyang> fizbin: you can't do that -- see http://haskell.org/onlinereport/exps.html#sect3.14 :-/
18:24:55 <heatsink> Was dyson that futurist who plotted how to escape the inevitable heat-death of the universe?
18:25:19 <dons> well, hoover does.
18:25:20 <Igloo> That's a new one on me
18:25:37 <fizbin> What exactly is that reference supposed to tell me, liyang?
18:25:49 <heatsink> ?google Freeman Dyson
18:25:50 <lambdabot> http://www.sns.ias.edu/~dyson/
18:26:39 <Igloo> Different Dyson, then  :-)
18:27:07 <dons> not the cyclonic vacuum guy
18:27:09 <Igloo> No detail on that page, though
18:27:39 <fizbin> I mean, I know what the do syntax means.
18:28:06 <liyang> fizbin: sorry, got distracted -- the standard explicitly refers to the Monad class. :-/
18:29:02 <liyang> (er, from the Prelude, I guess, that being the important part.)
18:30:54 <fizbin> Right.
18:31:54 <fizbin> So if I've got something with functions similar to >>= and return, are there any other possibilities for better syntax?
18:42:23 <kpreid_> isn't there a ghc extension for "use the local >>="?
19:15:00 <twobitsprite> arg!! I can't find an elegant solution to find a string of stones on a go board :(
19:15:46 <twobitsprite> this is one of those cases where the imperative solution comes straight to mind, but the functional solution evades me
19:17:33 <dons> ? why
19:17:57 <dons> tthe imperative solution is just a specific case of the functional one. you can always write it in a monad..
19:18:17 <twobitsprite> I mean, I can find a solution, but it always looks so ugly
19:18:57 <dons> use IORefs and IO moonif you want a demo, post the imperatah.
19:19:00 <dons> sorry.
19:19:01 <dons> ah, I see.
19:19:48 <dons> I'm sure there's a lovely pure algorithm in there waiting to be found.
19:20:04 * twobitsprite is looking :P
19:20:23 <dons> why is the algorithm `imperative' btw?
19:20:57 <dons> maybe if you implement it in Haskell, a nice functional version will resolve itself :)
19:21:02 <dons> apply @pl liberally ;)
19:21:05 <twobitsprite> I never said "it" was imperative... I said the imperative solution comes to mind
19:21:28 <dons> oh, an imperative solution. you mean its easier to think up a step-by-step way to solve it?
19:21:46 <twobitsprite> er yeah... an updating way to solve it
19:21:59 <dons> oh, an updating way to solve it.
19:22:03 <dons> mutating some state?
19:22:06 <twobitsprite> with loops, etc.. yar
19:22:22 <dons> well, loops are just maps, yeah?
19:23:16 <twobitsprite> well... it ends up looking more like a fold, with a lot of arguments... I end up returning and accepting a large tuple
19:23:43 <dons> ok.
19:24:27 <twobitsprite> 
19:24:31 <twobitsprite> http://senseis.xmp.net/?SolidConnection
19:24:59 <twobitsprite> I'm trying to find those stones which are "solidly connected" to the given stone.. i.e. the string or chain
19:25:35 <twobitsprite> it's simple at first, until you take into account large "circular" groups...
19:25:51 <dons> is it a graph algo?
19:26:38 <dons> you carry arond a list of nodes visited, to avoid loops?
19:26:46 <twobitsprite> I just have an array of intersections... i.e. Array.array (0,360) [(0,Empty),(0,Black)...]
19:27:16 <twobitsprite> dons: yeah, I end up with a list of "checked" nodes, and check each new not to see if it's in the list
19:27:32 <twobitsprite> s/not/node
19:44:47 <jewel> has STM been implemented in languages other than haskell?
19:49:38 <dons> less sophisticated versions eerged in C#, i think
19:49:41 <dons> emerged
19:50:11 <dons> there's some description here http://haskell.org/haskellwiki/GHC/Concurrency
19:56:52 <Excedrin> why is STM tied closely to GHC?
19:56:57 <jewel> does that description have any links to non-haskell implementations?
19:58:56 <dons> thhe implementation just happens to be in the ghc rts
19:59:13 <dons> well, the papers referenced from that page do 
19:59:23 <monochrom> The authors happen to be Haskell people.
20:00:16 <monochrom> With researchers being hidden variables, two great things tend to magically correlate with each other.
20:00:22 <jewel> which papers? (They all seem to be ghc / haskell )
20:00:45 <monochrom> "composable memory transactions"
20:01:11 <dons> and parallelism, concurrency and safety are Haskell's strengths. so its not too surprising ti emerged here -- it's easier to get working in Haskell
20:01:45 <jks> anyone know of irc channels dedicated to verification? (i.e. formal verification)
20:03:14 <Korollary> that would be a pretty quiet channel
20:03:26 <jks> hehe
20:04:13 <dons> it sometimes comes up here, but not too often
20:05:00 <jks> I'm just having some problems with the UPPAAL tool on Mac OS X
20:05:03 <ptolomy> is there a convenient haskell png library?
20:05:32 <dons> i think there is. but I haven't found it yet..
20:05:32 <jks> I guess that it's pretty much impossible to find anyone in the same situation
20:05:50 <dons> ptolomy, if i find it in the next couple of hours, i'll let you know.
20:05:59 <ptolomy> dons, Thanks.
20:06:06 <dons> ptolomy, have you looked here http://haskell.org/haskellwiki/Libraries_and_tools
20:06:54 <ptolomy> Yes.
20:07:13 <ptolomy> I will freely admit that I'm not a great looker, however.
20:07:20 <ptolomy> Ooh. That works both ways.
20:07:35 <Korollary> I look great.
20:09:19 <jks> I guess this is probably not the place to locate people with interest in the ambient calculus either?
20:09:38 * ptolomy looks like somebody beat up a younger Ed McMahon.
20:11:43 <dons> there ambience here has a bit of an interest in lambda calculus
20:13:14 <jks> hmm, well, I'm in it for the concurrency and stuff
20:13:28 <jks> so lambda doesn't really cut the cheese for me
20:13:38 <Korollary> you could find people that are into pi-calculus here sometimes
20:13:49 <jks> that's more like it :)
20:14:44 <dons> ptolomy, I think the wxHaskell lib can write and read .pngs
20:17:15 <ptolomy> ooh.
20:17:25 * ptolomy has been looking for an excuse to tinker with wxHaskell anyway..
20:17:44 * jks wishes for a faster computer
20:34:51 <dons> i love my haskell type system
20:35:30 <jks> I just love type systems
20:35:35 <dons> algorithm for chaginge your code: a) change the type of 1 function, b) recursively fix each function that then breaks type checking c) profit!
20:36:03 <dons> the above algorithm can be executed on mushy sleepy brains
20:36:14 <jks> You forgot b2) Introduce spooky bug
20:36:36 <dons> nah. no spookey bugs
20:36:36 <dons> strong ty
20:36:44 <dons> strong typing for ever!
20:37:03 <jks> strong typing isn't a guarantee of a bug-free world
20:37:13 <Lemmih> IO debugging: http://darcs.haskell.org/~lemmih/DebugLog.txt
20:37:47 <dons> yes yes. I know :P just most bugs. and fixing typing tends not to introduce bugs, which was my point.
20:38:05 <dons> ?vixen do you have any bugs?
20:38:05 <lambdabot> i do occassionally, i guess
20:38:11 <dons> ah. so true.
20:38:17 <jks> hehe
20:38:19 <dons> ?vixen yet you're strongly, statically typed too.
20:38:19 <lambdabot> hey, what's in a jack and coke anyhow?
20:38:21 <sjanssen> Lemmih: that is sexy
20:38:42 <dons> wow Lemmih.
20:38:53 <jks> dons, I'm trying to decide whether to use a type system or a logic to help me
20:39:56 <Lemmih> I think I'll try writing a HW paper about it.
20:40:12 <dons> how many HW papers ? I see a couple in what you've been doing
20:40:29 <dons> better get started though!
20:42:07 <musasabi> Has anyone else got "coreSyn/CoreUtils.lhs:(617,36)-(618,71): Non-exhaustive patterns in case" with GHC 6.4.2 snapshots? Probably GADT related and works fine with 6.4.1.
20:53:27 <SamB> ?vixen do you have any arachnids?
20:53:27 <lambdabot> yes i do
20:54:22 <dons> hey SamB.
20:55:02 <ptolomy> @google lambdabot source
20:55:03 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
20:55:09 <ptolomy> Ooh.
20:55:47 <dons> ?google lambdabot
20:55:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:55:50 <dons> ?version
20:55:50 <lambdabot> lambdabot 3p370, GHC 6.4.1 (Linux i686 3.20GHz)
20:55:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:59:50 <ptolomy> ?vixen I drive a chevy.
20:59:51 <lambdabot> american cars are worthless
22:06:37 * shapr yodels
22:07:44 <musasabi> morning shapr 
22:11:27 <Smokey`> I cant believe it, Haskell is starting to draw me away from C++... I swore i'd never turn frolm C++... :S
22:11:32 <Smokey`> s/frolm/from/
22:11:51 <audreyt> Smokey++
22:13:53 <sieni> Shapr - our multiculturalist: an american yodeling guy that lives in Sweden
22:16:04 <dons> ?karma+ Smokey`
22:16:04 <lambdabot> Smokey`'s karma raised to 1.
22:18:04 <shapr> hyvää huomenta musasabi!
22:18:42 <shapr> sieni: I'm from Alabama. The only culture I got is bacterial.
22:18:44 <Smokey`> dons: Doesn't mean i've turned yet, there are still a fair few things i 'need' that haskell can't provide... :)
22:19:00 <Smokey`> 'need', being,  not 'need', but would definately prefer if i had.
22:19:05 <skew> hello. Morning in Europe?
22:19:16 <shapr> @timein shawn
22:19:18 <lambdabot> Local time for shawn is Thu Mar 30 22:18:55
22:19:21 <shapr> grr
22:19:24 <shapr> @timein shapr 
22:19:26 <lambdabot> Local time for shapr is Fri Mar 31 08:19:04 2006
22:19:28 <shapr> Obviously not awake yet.
22:19:47 <musasabi> Smokey`: anything in special you are needing?
22:20:20 <dons> yeah, what cha looking for?
22:20:29 <sieni> skew: sort of
22:20:45 <dons> btw, i've addd about 50 new tools and libs to http://www.haskell.org/haskellwiki/Libraries_and_tools, so if you looked for something, and it wasn't there. it might be now
22:20:45 <skew> Ah, it is the same time as germany, I've just moved west since I last looked up the delta.
22:20:54 <sieni> I _should_ get to work, but I'm kind of still waiting to wake up
22:21:11 <Smokey`> musasabi: inline assembler would definately help, or access to instrinsic functions. (I have a tendency not to trust compilers in certain areas, espcially when optimizing),   templates (like C++ templates, i know you have typeclasses, but again, doesn't provide everything that i'm aware of),  that's about it (that I can think of)
22:21:16 <dons> Smokey`, you do a lot of asm programming right?
22:21:16 <dons> ah yes.
22:21:29 <Smokey`> dons: i use asm for optimizing for certain apps, yes.
22:21:37 <Smokey`> eg: ray tracer,   such as intersection routines
22:21:58 <dons> templates are just a restricted version of generics in Haskell, aren't they? I think most of this is just a matter of learning more about the language
22:22:01 <shapr> sieni: I like those hyvää huomenta drinks. The short red cans are definitely morning uppers.
22:22:02 <skew> I had an interesting idea - incremental computation like in a spreadsheet or so, but of interpreter output with respect to source code
22:22:04 <dons> inline asm, that's a tricky one
22:22:06 <Smokey`> ahh also, Haskell doesn't have pointers (that i'm aware of), not sure if it has anything similar... but they're extremely useful (from my imperitive point of view)
22:22:13 <dons> you'd instead call a C wrapper.
22:22:18 <dons> very doable
22:22:21 <skew> Foreign.Ptr
22:22:24 <Smokey`> sweet
22:22:25 <dons> the C wrapper would be just a symbol name
22:22:32 <sieni> shapr: Hmm... I've already had a can of coke and two cups of coffee
22:22:35 <dons> let me code up a 5 line example
22:22:53 <musasabi> usually Haskell optimizations are much higher level then C/C++
22:23:09 <Smokey`> dons: ot sure who it was, but earlier I asked if i could do something similar to template<int Dimension, class Type> class Vector { Type value[Dimensions]; ... };  in haskell, and i was told i could, but making it any arbitary number of dimensions would be exceedingly had)
22:23:10 <Smokey`> hard*
22:23:20 <shapr> sieni: You may want to work your way up to an entire can of hyvää huomenta though. It can have unexpected consequences. At least don't knock back the whole thing at once :-)
22:24:17 <Smokey`> other than those few things, Haskell is peferfect (compared to C++) :P
22:24:28 <Smokey`> ugh, my typing is NOT however.
22:24:32 <sieni> Smokey`: well, I'd say that in C++, pointers are only useful in certain special situations (like pimpl) (otherwise you'd use references)
22:24:40 <shapr> I thought peferfect was a neat word.
22:24:53 <Smokey`> sieni: cant do pointer arithmetic on references :)
22:25:30 <tuomov> references are evil.
22:25:46 <tuomov> pointers in disguise
22:25:57 <dons> I'd be very surprised if you could write some poolymorphic/generic function in C++ that wasn't doable in Haskell, and probably a lot cleaner. But I don't know enough C++ to comment.
22:26:04 <skew> I have vague memories from a class on complexity theory of a proof turned interpretation of a program into a parallel divide-and-compose on tabulatiion of functions
22:26:04 <Smokey`> also, with pointers, you can exploit a few bits for extra storage space (cheap, dodgy hack, but in certain cases, it works like a dream)
22:26:09 <shapr> So that's why I can never get any good references for my resumes...
22:26:25 <sieni> Smokey`: I don't know if pointer arithmetic is considered a useful use of pointers ;-)
22:26:41 <kolmodin_> morning!
22:26:53 <musasabi> Smokey`: of course with Haskell you can still keep your inner loop as C if profiling shows that it is a problem.
22:27:08 <skew> That word suggests pfefferfect cooking.
22:27:10 <tuomov> int foo(int bar, int *return_value2); a=foo(b, &c); vs.
22:27:15 <musasabi> but in practise the Haskell solution is fast enough for most apps.
22:27:19 <tuomov> int foo(int bar, int &return_value2); a=foo(b, c); 
22:27:27 <tuomov> the first one clearly marks that c may be modified
22:27:29 <Smokey`> sieni: for optimizing, yeah it is.  especially if you're using your own data structures, you can easily avoid cache misses and remove unecessary array indexing that a compiler would do by default.
22:27:53 <dons> ?remember tuomov references are evil.
22:27:54 <lambdabot> Done.
22:28:31 <dons> that kind of trick you'd do in C if using Haskell, Smokey`
22:28:42 <shapr> skew: Yeah, I was trying to remember the word... pfeffer is pepper in german?
22:28:48 <skew> yes
22:29:15 <skew> I was thinking peffer, but I was short an f
22:29:16 <sieni> tuomov: sort of, but it's better to mark them clearly in the function parameters. (like foo_ret *bar or foo_ret &bar can be modified and const foo *bar and const foo &bar may not)
22:29:44 <sieni> oops
22:29:50 <tuomov> sieni: but it is good to document it in the code where the function is called, and the & does that
22:29:53 <sieni> I meand foo *bar_ret and foo &bar_ret
22:30:28 <tuomov> of course (a, c)=foo(b) would be the correct approach, but it's C/C++..
22:31:18 <skew> templates just allow numbers and types as arguments, right?
22:32:13 <tuomov> references are only useful for ugly C++ GC/ref. counting container hacks
22:32:15 <sieni> tuomov: at least in my C code I  pass pointers to structs to functions quite often and there it's a bit hard to use the & explicitly at the function call site
22:32:47 <tuomov> for return values local variables on the stack are often used, not dynamically allocated stuff
22:34:11 <skew> that's stuff I prefer not to worry about
22:34:18 <sieni> If I allocate a struct in the stack, I tend to use struct foo bar[1]; in order to be able to access its elements with -> instead of . ^_^
22:34:22 <Smokey`> skew: yes, but templates can be specialised for template-argument specific values...  eg:  template<int Dimension, class Type> class Vector { Type vlaue[Dimensions]; }  template<class Type> template<3, Type> class Vector { Type x, y, z; ... };  or even template<2, float> class Vector { float x, y, z; ... /* take advantage of hte fact it's a float in specialised functions */ };
22:34:37 <Smokey`> which allows for more optimization.
22:34:44 <skew> you get that with type classes, if you feed ghc enough and scary enough options
22:35:11 <skew> -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances -fallow-incoherent-instances -fdestroy-observable-universe
22:35:21 <Smokey`> lol
22:35:55 <sieni> np: huopatossu mononen - don't smoke weed bitch
22:36:58 <Smokey`> GHC has a C preprocessor yeah?
22:37:25 <sieni> Smokey`: does it need one? you have cpp, right?
22:37:37 <sieni> this song is really weird
22:37:47 <dons> Smokey`, here's your inline asm in Haskell. well, almost (you write the asm in its wn file): http://www.cse.unsw.edu.au/~dons/tmp/inline-asm.hs 
22:37:50 <dons> Smokey`, yep. -cpp
22:38:45 <Smokey`> dons: hahaha :)  cute.  but messy.
22:39:17 <dons> well. it's a good idea to separate the Haskell and C/asm world
22:39:20 <dons> so I would argue it's not very messy, really
22:39:39 <Smokey`> mmm
22:39:46 <skew> even sillier things could be done with Template Haskell
22:39:53 <dons> it generates a:         call madness
22:39:55 <dons> in the A.hs output
22:40:42 <dons> the Haskell code remains fairly unpoluted. just a 'foreign import'
22:41:06 <dons> so, no arguments that you can't drop down to asm if you need it :}
22:41:13 <Smokey`> aye :)
22:42:23 <dons> I might stick this on the haskell.org wiki Idioms page, just to surprise people
22:42:54 <skew> beyond pointing at the FFI that stuff isn't really so useful to you. People are not drawn to Haskell for the awesome bit-fliging capabilities
22:45:37 <dons> hopefully not. but if I had a $$ for every time it was used as an argument _not_ to pick up Haskell.
22:46:03 <dons> ?faq <-- I should just refer to tihs more often
22:46:04 <lambdabot> The answer is: Yes! Haskell can do that.
22:47:13 <sieni> haskell's ffi (well, at least ghci's) is very convenient, if you compare it to many other languages
22:47:49 <dons> ghci's? the ffi syntax is standardised. what did you mean sieni?
22:48:02 <dons> nhc, hugs yhc all do the same thing, afaik
22:48:07 <skew> dons, not not X just implies X in classical logic
22:48:31 <dons> hehe
22:49:50 <sieni> dons: that was a disclaimer (I only use ghc, so I'm not always sure, what's standard and what isn't :-)
22:50:19 <skew> more constructive all around to point people at the really cool stuff
22:50:37 <skew> the lambdabot thing is great.
22:51:54 <palomer> hoho
22:51:57 <palomer> found a yahoo bug
22:51:59 <dons> yeah, hopefully they find out about the cool stuff. adding all the cool little tools to lambdabot has been part of this project. like, say djinn:
22:52:06 <palomer> search for "to love life and another"
22:52:07 <dons> ?djinn a ->(a,a)
22:52:07 <lambdabot> f a = (a, a)
22:52:17 <palomer> it estimates that there are 1.9 million entries
22:52:33 <palomer> there are actually 13 entries
22:53:15 <skew> hmm, I see "1 - 1 of about 1"
22:53:36 <sieni> Q: what's the difference between yahoo and a box full of crap?
22:53:39 <sieni> A: the box
22:53:40 <skew> "Crazy Ivans Stargate Alliance Board"
22:55:03 <palomer> sieni: I don't get it
22:55:03 <sieni> note to self: avoid drinking the evening before hangover
22:56:48 <sieni> palomer: yahoo has actively helped china to jail dissidents. the company is so to speak full of shit
22:56:52 <shapr> sieni: haha
22:57:05 <palomer> the box is the difference?
22:57:16 <palomer> oh, it's too late
22:57:16 <sieni> palomer: yes
22:57:19 <palomer> that's a very fine joke
22:57:29 <palomer> I read it as " what's the difference between crap and a box"
22:58:53 <skew> I'm liking the GADTs here - making a simple lambda calculus interpreter with debruijn indices where the environment is just the right size
22:59:49 <sieni> palomer: maybe the options should be ordered the other way in order to make it easier to parse :-)
23:00:22 <palomer> GADTs are fun
23:00:31 <palomer> but people are really going the wrong way for GADT inference
23:01:20 <sieni> skew: have you been reading TAPL latelty? I just got to de bruijn indices this week on my daily bus trip to work :-)
23:01:32 <skew> read it a while back
23:01:47 <palomer> in fact, they're going the wrong way for GADT type checking too
23:01:58 <palomer> I don't yet understand de bruijn indices
23:02:48 <skew> hmm, maybe connor's paper "I am not a number I am a free variable" would help explain
23:02:52 <sieni> palomer: they are pretty simple, I'd say
23:03:17 <sieni> palomer: TaPL explains them very well in my opinion
23:03:48 <palomer> well, yes
23:03:53 <palomer> if I actually bothered learning about them
23:04:06 <palomer> I was actually about to invent something quite like them
23:04:11 <palomer> but was I was studying in paris
23:04:19 <sieni> palomer: that explains a lot
23:04:30 <skew> If you have seen presentations of them and didn't get it, connor's stuff connects them with variables a bit
23:04:51 <palomer> I remember thinking, just when I was about to take the elevator to my flat "why not get rid of variable names and have  numbers instead"
23:05:09 * shapr gödels
23:05:12 <palomer> I then thought it was a stupid idea
23:05:54 <gzl> I thought TAPL's explanation was really clear.
23:06:01 <sieni> the de bruijn indices is just a particularly straightforward way to avoid clashes with variable names in lambda calculus (or first order logic as well)
23:06:08 <skew> just a little bit more structure than that - 0 refers to the closest enclosing lambda, 1 to the next closest, etc
23:06:12 <shapr> TaPL roxx
23:06:48 <palomer> skew: well, yes, I had worked out that bit too
23:06:58 <skew> I think that's all there is to it
23:07:06 <palomer> don't forget application
23:07:12 <palomer> that's the hard bit
23:07:12 <shapr> I want de bruijn arrays.
23:07:22 * shapr gödels at CosmicRay 
23:07:35 <CosmicRay> heh
23:07:41 <palomer> I couldn't figure out how to apply them
23:07:46 <palomer> so I gave out
23:07:54 <palomer> and 6 months later found out this idea was already discovered
23:07:56 <palomer> and famous
23:08:13 <palomer> s/gave out/gave up
23:09:28 <shapr> CosmicRay: You left out Postmaster! C'mon, a Haskell mail server?
23:10:43 * CosmicRay blinks, searching for context
23:10:43 <shapr> CosmicRay: Postmaster: Your mail is respected by all discriminating hackers, and has no side-effects.
23:10:49 <CosmicRay> ah, hehehe
23:11:07 <CosmicRay> forgive me, oh great guardian of the lambda
23:11:10 <shapr> I'm sure there's something funnier you could say about a Haskell mailserver.
23:11:13 * shapr laughs
23:11:16 * shapr laughs more
23:11:26 <shapr> That's the funniest thing I've been called all day!
23:11:30 <CosmicRay> hehe
23:11:43 <CosmicRay> I say strange things at 1AM sometimes ;-)
23:11:59 <shapr> It's 9:11 here.
23:13:14 <dons> oh, hmm. April 1 soon, eh?
23:13:33 <CosmicRay> dons: oh, indeed.!
23:13:44 <shapr> Oh I know. Postmaster: If you can configure it, your mail will pass through at least a PhD worth of code.
23:13:48 <CosmicRay> perhaps I should announce that VB is my new preferred language. ;-)
23:14:27 <CosmicRay> shapr: the other problem with that post was coming up with something for Exchange.  I had the whole "were can I ever start" problem. ;-)
23:14:28 <shapr> dons: ohh, April 1st HWN!
23:14:33 <CosmicRay> bwahahaha
23:14:35 <shapr> CosmicRay: I can understand that :-)
23:15:00 <CosmicRay> dons: lesse, GHC 6.6 released, the first haskell' compiler? ;-)
23:15:02 <shapr> CosmicRay: Surprisingly, you came up with a less than heated comment that is also perfectly accurate. Your diplomacy score is high!
23:15:08 <dons> I'll have to think hard on this. hmm.
23:15:19 * shapr thinks too
23:15:23 <Korollary> ocaml switches to haskell-like syntax
23:15:25 <CosmicRay> shapr: hehe.  unfortunately I did not do so well with the city manager of tuttle, ok
23:15:27 <dons> yes, a Haskell' compiler with lots of fun stuff in it.
23:15:35 <CosmicRay> Korollary: how about *perl*? ;-)
23:16:00 <CosmicRay> Korollary: and the scary thing about the perl thing is that it's just wacky enough that autrijus may have done it ;-)
23:16:46 <CosmicRay> interesting, it seems that sequence is no longer aggregating my blog.
23:17:17 <CosmicRay> dons: btw, thanks for doing such a great job with HWN
23:17:24 <shapr> dons: After the global excitement of pugs, rumor has it that Guido van Rossum is secretly writing Python3000 with GHC 6.5
23:17:50 <CosmicRay> heh
23:17:51 <dons> well, we're so happy doing logic programming on the type level, that instead of ditching FDs, we going to extend logic programming to the value level. Haskell' prime will feature new Generalised Prolog data types
23:17:58 <shapr> ohhh
23:18:00 <dons> ah, that's a good one shapr
23:18:11 <skew> isn't that curry?
23:18:21 <dons> yeah ;)
23:18:37 <Korollary> scheme R6 includes an optional type system with inference
23:18:38 <dons> I think there's lots of good fun to be had in the Haskell' process...
23:18:45 <skew> the hard part is thinking of things that are not true
23:18:51 <shapr> skew: heh, yes!
23:19:01 <dons> keep thinking. i'll write some of these down ....
23:19:32 <Korollary> AMD optimizes next gen processors for lazy eval instructions
23:20:11 <dons> ah, yes. the new 'thunkify' instr...
23:20:43 <shapr> After the most recent delay of Windows 'Vista', rumors are flying that Microsoft management has hired all the winning ICFP teams for the last several years, given them a copy of Haskell' and told them to finish Vista by May.
23:20:53 <astrolabe> The first (and very bad) version of my haskell go bot is playing on kgs!  (at last)
23:20:57 <Korollary> To meet Windows Vista schedule, MS turns haskell prototype implementations into shippable binaries.
23:21:20 <skew> hardware transactional memory?
23:21:21 <dons> in 3 days, with a bonus for a 24 hours effort..
23:21:28 <shapr> dons: haha!
23:21:43 <skew> network transactional routers, shipping from cisco in novemeber.
23:21:50 <CosmicRay> haha
23:21:53 <magnus--> astrolabe: cool, what's the name of the bot?
23:22:22 <CosmicRay> bah, it appears that drupal doesn't know how to deal with a HTTP redirect
23:22:25 <astrolabe> It's called 'Fomalhaut'.  It even beats some careless novices.
23:23:09 <magnus--> astrolabe: in the computer go room?
23:23:20 <astrolabe> yeah
23:23:27 <shapr> Wizards of the Coast have hired Simon Peyton-Jones to design the next hit card game, Magic : The Combinator.
23:23:29 <magnus--> cool.. I'll have to play it sometime
23:23:54 <astrolabe> I'm waiting for them to turn it into a 'Ranked Robot' so it can get [30k?] after its name.
23:24:08 <shapr> Experts say that lambda calculus is much more addictive than Magic : The Gathering.
23:24:58 * audreyt likes CPAN: The Gathering and looks forward to plan Cabal: The Gathering
23:25:06 <audreyt> collectible trading libraries++
23:25:12 * shapr grins
23:27:33 <shapr> Recent cosmological excitement was caused when an FP newbie from the year 2100 finally succeeded in getting an Int out of IO Int. Of course, the value ended up in going backwards in time to our present day 2006.
23:28:59 <Korollary> Physicists at Cornell lifted a function without even running the quantum computer.
23:29:04 <shapr> wow!
23:29:07 <CosmicRay> haha
23:29:46 <skew> quantum zeno effect + quantum computer
23:29:57 <tennin> GHC to be rewritten in XSLT?  
23:30:17 <shapr> ouch
23:30:23 * tennin is struggling through XSLT spec
23:30:54 <shapr> To catch up with Web 2.0, Microsoft has ordered the Simons to rewrite GHC in XSLT and javascript.
23:31:14 <Korollary> There's gotta be some negatives as well
23:31:19 <shapr> @quote darius
23:31:19 <lambdabot>  I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
23:31:22 <tennin> I love Haskell, but it just doesn't have the libraries and developer base for real-world compiler development, says SPJ
23:31:43 * shapr snickers
23:31:59 <shapr> tennin: Hey, you were asking about the connection between FP and relational calculus, yeah?
23:33:10 <tennin> yeah, or in particular between category theory and relational calculus
23:33:34 <shapr> I saw a recent article on LtU that seems related.
23:38:53 <tennin> which article?
23:50:54 <shapr> hei ohub 
23:51:04 <ohub> hello :)
23:51:20 <shapr> tennin: I don't remember.. :-/
23:52:07 <tennin> how recent?
23:53:49 <jewel> I looked at some of the papers at http://haskell.org/haskellwiki/GHC/Concurrency but I still don't see any that relate to non-haskell implementations
23:54:13 <ohub> I just read http://jaortega.wordpress.com/2006/03/28/a-haskell-bookshelf/ and decided to look a bit about Haskell and second thing (after Hello World) was to join here
23:55:54 <Korollary> good idea
23:56:21 <dons> jewel, there was an email about this yesterday on haskell-prime, i think.
23:56:32 <dons> CosmicRay, re. HWN, no problems. it's quite fun
23:56:47 <dons> ohub, good move  :) there's lots of professional teachers of Haskell here to help :)
23:56:53 <jewel> astrolabe, how do you implement the KGS wire protocol?
23:57:10 <dons> also, you should now check out http://haskell.org
23:57:24 <dons> ohub, and meet lambdabot
23:57:29 <dons> > map (+1) [1..10]
23:57:30 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
23:57:34 <dons> @type map
23:57:34 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:57:38 <dons> @docs Data.List
23:57:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
23:57:39 <dons> @index map
23:57:40 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
23:57:45 <dons> @google lambdabot
23:57:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:57:54 <ohub> dons; A Haskell interpreter bot? :)
23:57:56 <Korollary> @karma dons
23:57:56 <lambdabot> dons has a karma of 26
23:58:07 <dons> ohub, interpreter and about 50 other things
23:58:08 <Korollary> @keal
23:58:09 <lambdabot> i want to invent white dye
23:58:19 <dons> @quote
23:58:19 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
23:58:22 <dons> ?wiki Lambdabot
23:58:23 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
23:58:27 <dons> ^^ has a full explanaation
23:58:35 <ohub> nice
23:58:41 <Korollary> ?vixen What do you recommend to a haskell newbie?
23:58:41 <lambdabot> Ooh, functional programmers are so hot!
23:58:51 <dons> ohub, so welcome. it's a fun community, and we love questions.
23:58:59 <Korollary> and we're downright silly
23:59:01 <dons> you might want to subscribe to haskell@haskell.org mailing list too
23:59:09 <dons> for announcements.
23:59:13 <dons> oh, install ghc :)
23:59:19 <dons> having an implementation is a good idea.
23:59:23 <ohub> I have ghc already (darcs build depency..)
23:59:42 <dons> ah via darcs!
23:59:47 <dons> excellent
23:59:47 <dons> we love darcs.
