00:38:19 <Lemmih> Anyone got a small piece of code that runs slowly when compiling with GHC?
00:45:56 <int-e> hmm. anything that involves getContents and little extra work.
00:46:29 <int-e> main = do x <- getContents; print $ length $ unlines x
00:46:55 <int-e> @type lines
00:46:56 <lambdabot> String -> [String]
00:47:01 <int-e> err, that one.
00:49:57 <Lemmih> Well, lazy IO based on lists of chars would be slow in any language.
00:51:01 <Lemmih> I'm trying to find a case where GHC compiles to something slower than what it should.
00:51:44 <int-e> I think that one is actually a GC tuning issue - some instances of that pattern spent 80% of their time doing GC, which improved a lot by increasing the initial heap size very slightly.
00:52:10 <int-e> (seen in the sumfile shootout benchmark)
00:52:43 <flux__> otoh it's not very surprising that most of the times _is_ spent on gc, because the other tasks that function performs are so small?
00:52:58 <int-e> that being said, I expect that the buffer management of lazy file reading could be improved.
00:54:12 <flux__> I wonder if it'd be feasible some day for a haskell environment to represent strings as actually (Array Char, String)'s, but so that they'd appear to be lists in the code..
00:54:39 <flux__> (I imagine that could at times bring a performance boost)
00:54:52 <flux__> maybe eager haskell could do something like that
00:55:08 <flux__> (atleast divide the work to be done in blocks in order to facilitate generating that kind of structure)
01:00:09 <neologism> is there xor operator in haskell?
01:00:25 <Lemmih> @index xor
01:00:25 <lambdabot> Data.Bits, Foreign
01:00:39 <sieni> flux__: I think that's up to the implementation, how they are represented
01:00:57 <Beelsebob> (|+|) x y = x || y && not (x && y)
01:01:08 <sieni> flux__: haskell certainly does not prevent optimization by a compiler
01:01:26 <neologism> uh.. how do I import that?
01:01:26 <flux__> of course, but the straight forward implementation of [Char] is the linked list that is (?) currently used
01:01:38 <Beelsebob> neologism: put it in a module and import it :P
01:01:41 <flux__> going another way might turn out to be difficult
01:01:45 <neologism> Beelsebob: whats the import command
01:01:50 <Beelsebob> import
01:01:53 <neologism> import Data.bits doesnt work
01:01:58 <sieni> flux__: is it? have you looked at ghc code?
01:02:08 <flux__> nope
01:02:09 <Beelsebob> that's because it's Data.Bits
01:02:22 <Beelsebob> import Data.Bits (xor)
01:02:29 <neologism> :)
01:02:29 <flux__> but I'd be surprised if it wasn't :)
01:03:05 <neologism> ERROR "Search.hs":47 - Instance of Bits Bool required for definition of findConnected
01:03:08 <neologism> uh?
01:03:12 <sieni> flux__: well... ghc is pretty heavily optimizing compiler and is pretty high in the computer language shootout
01:03:28 <Beelsebob> neologism: that's because the xor in Data.Bits is designed for using the data structures in that file
01:03:36 <Beelsebob> use my definition if you want an xor on Bools
01:03:59 <neologism> ok
01:04:38 <flux__> sieni, but isn't haskell well known for its limited io performance?
01:04:47 <sieni> flux__: no?
01:04:55 <flux__> witness the existence of fast packed strings?
01:04:59 <neologism> Beelsebob: your version is wrong ;)
01:05:05 <neologism> you forgot brackets
01:05:12 <Beelsebob> heh
01:05:18 <int-e> flux__: the fun fact is that reducing the buffer size for stdin helps the program speed - hinting that the GC might actually copy those buffers, which is bad.
01:05:27 <sieni> flux__: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
01:06:14 <flux__> before let a = take 10000000 $ repeat 'a'    print a  haskell takes 20M memory, afterwards it takes 250M (!)
01:06:25 <flux__> it doesn't sound like a very efficient representation to me
01:07:07 <int-e> are you re-using a again later?
01:07:09 <Beelsebob> flux__: are you per chance using OS X?
01:07:26 <flux__> no, linux
01:07:36 <flux__> int-e, I'm using an interactive environment
01:07:59 <int-e> oh. it can't throw a away then, so you have that list in memory. that will be big, yes.
01:08:00 <flux__> hm, would it run gc after prompt?
01:08:17 <flux__> the efficient representation of 10M utf32 'a''s would take 40M
01:08:36 <Saulzar> It will create thunks for lazily evaluating each element in that list
01:09:04 <flux__> yes, but evaluated all those chunks with 'print'.. but are there chunks still in the memory, unreferenced?
01:09:07 <sieni> flux__: I think you should compile to a stand-alone binary to see how efficient the representation becomes
01:09:10 <int-e> on the bright side, it will never execute that *costly ;-)* code of take and repeat again if you use a.
01:09:17 <Beelsebob> flux__: a memory efficient rep is not necesssarily a speed efficient one
01:09:20 <Saulzar> So you're right, lazy evaluated lists are not good for/intended for packed memory use
01:09:47 <flux__> beelsebob, no, but it does suggest that the string actually consists of char+pointer
01:09:55 <sieni> the fact that ghc can compile fast code doesn't imply that its interactive environment executes haskell code fast
01:10:04 <flux__> beelsebob, also if data takes a lot to represent it takes a lot of memory bandwidth to manipulate
01:10:12 <flux__> which is scarse these days (compared to cpu performance)
01:10:19 <int-e> sure, it does. actually I think it's more like 3 pointers and a value
01:10:40 <Beelsebob> really? My CPU has 2 1.25Ghz data buses which matches the CPU speed
01:10:47 <flux__> how about latency?
01:10:55 <int-e> hrm. no, the char is a thunk as well, so 4 pointers for the cons and 2 plus a value for the character?
01:11:04 <Beelsebob> if you're fetching 250MB at once do you care about latency?
01:11:06 <flux__> so the cpu needs to be smart about fetching the data in advance
01:11:21 <flux__> code manipulating a char+ptr-kind of data cannot just stream all that data
01:11:36 <Beelsebob> it can if the compiler optimised it
01:11:38 <int-e> Beelsebob: if the access pattern is linear, I don't. If it's random then I do, very very much.
01:11:41 <flux__> yes, and that would be great
01:12:35 * Beelsebob goes to sing - final rehearsal, concert this evening :/
01:12:57 <int-e> heh. actutally at least the characters get shared (so it's only the 4 pointers per cons)
01:13:10 <flux__> sieni, btw, the naive implementation of 'sum' at the shootout gives really horrible performance to haskell
01:13:17 <flux__> the optimized one, though, is quite ok
01:14:55 <flux__> (it was the only benchmark for which I could from the name decide that it has the potential for being performance-bound by string manipulation efficiency)
01:15:06 <Beelsebob> anyway... let as = 'a' : as in print $ take 10000000 as... produces a very efficient rep
01:15:12 <Beelsebob> should only use a few bytes for it
01:15:25 <Beelsebob> because it'll just use a cyclic data structure
01:15:46 <flux__> yes, but the problem is that it isn't infinite
01:15:56 <sieni> flux__: I agree that generating efficient code with Haskell might require quite a bit of tuning. If you just want to generate efficient code in a statically typed functional language, then mlton might be an option, although Standard ML has its limitations compared to Haskell0
01:16:04 <sieni> -0
01:16:08 <Beelsebob> flux__: what isn't infinite?
01:16:20 <flux__> beelsebob, the list produced by 'take n'
01:16:26 <Beelsebob> flux__: and?
01:16:35 <flux__> beelsebob, so it can only share the letter 'a'
01:16:37 <Beelsebob> that list can be gced as you print it
01:17:02 <flux__> yes, because it doesn't have a name
01:17:04 <Beelsebob> assuming buffering is set up on a per-character not per-line basis
01:17:10 <flux__> I gave mine a name on purpose ;)
01:17:19 <Beelsebob> yes... to make it innefficient
01:17:31 <Beelsebob> :)
01:17:44 <flux__> is there a way to manually wake up the gc?
01:17:52 <flux__> @index gc
01:17:52 <lambdabot> bzzt
01:18:26 <jyp> @hoogle gc
01:18:26 <lambdabot> Data.Generics.Schemes.gcount :: GenericQ Bool -> GenericQ Int
01:18:26 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
01:18:26 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (
01:18:26 <lambdabot> c (t' a))
01:18:28 <Lemmih> @index performGC
01:18:29 <lambdabot> System.Mem
01:18:37 <Lemmih> @type System.Mem.performGC
01:18:38 <lambdabot> IO ()
01:27:59 <flux__> the process does actually have some free space, because a smaller allocation didn't increase its size at all
01:32:54 <flux__> apparently the module doesn't know about functions for getting statistics on memory usage
01:34:12 <jyp> @bot
01:34:13 <lambdabot> :)
01:48:46 <neologism> is there union in haskell?
01:48:58 <neologism> something like [1,2,3] `union` [3,4,5] ?
01:49:03 <jyp> yes :)
01:49:16 <jyp> > [1,2,3] `Data.List.union` [3,4,5]
01:49:16 <lambdabot> [1,2,3,4,5]
01:49:20 <neologism> thnx
01:49:36 <jyp> somewhat inefficient on lists of course.
01:50:14 <neologism> I dont care about efficiency
01:50:20 <neologism> this is school project ;)
01:53:16 <neologism> btw: may I put prototype in where ?
01:53:26 <jyp> yup
01:53:42 <neologism> great :)
02:16:12 <neologism> do you know dijkstra shortest path?
02:17:01 <jyp> yup
02:17:46 <neologism> I dont understand how it gives me the path... all I get is cost of the path
02:18:46 <kombinator> neologism: I believe you can remember back-links
02:19:03 <jyp> well, in the classical imperative algorithm, you store the path by saving a pointer to the previous node when updating the cost
02:19:12 <jyp> like kombinator said.
02:19:19 <neologism> hm...
02:45:51 <dons> > [1,2,3] `union` [3,4,5] -- should also work here. List is in scope
02:45:51 <lambdabot> [1,2,3,4,5]
02:45:59 <dons> \bot
02:46:00 <lambdabot> :)
02:46:18 <dons> ?type union
02:46:19 <lambdabot> Not in scope: `union'
02:46:24 <dons> ?type List.union
02:46:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
02:47:19 <jips> dons: hi
02:47:25 <dons> $type map
02:47:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:47:36 <dons> hmm, I think I like ? better than \ or $
02:47:40 <dons> hey jips
02:48:26 <jips> dons: remember i was talking about that bug in hs-plugins where a file handle wasn't being properly closed after a failed merge?
02:48:30 <dons> yup
02:48:38 <dons> it's burnt into my brain
02:48:56 <dons> "jips == hs-plugins bug reporter" :)
02:48:56 <jips> should i take a stab at it now, or have you already solved it?
02:49:03 <jips> heh
02:49:08 <dons> no, please go ahead and fix it
02:49:18 <dons> i can't release 1.0 till it's done, but i haven't had time yet
02:49:35 <dons> grab the release candidate, and look at the code for 'merge'
02:49:43 <dons> you'll probably see the missing hClose in there somewhere
02:49:46 <jips> ok, i'll work on this now for a few hours
02:50:08 <dons> look in src/System/Plugins/Make.hs
02:50:20 <dons> my guess is just a missing hClose is all it is
02:50:32 <jips> ok
02:53:09 <dons> time for dinner. but ask any questions and I'll answer them later.
02:53:28 <jips> great thanks
03:01:46 <vincenz> any news on lambdabot extensions?
03:07:35 <kombinator> anyone knows a good primer on garbage-collectors?
03:25:24 <araujo> Morning!
03:27:31 <neologism> what is this
03:27:32 <neologism> hysteria.sk/~neologism/haskell.txt
03:28:10 <Lemmih> @vixen What is that?
03:28:11 <lambdabot> yeah, it is
03:28:38 <sieni> neologism: it's what it says. a pattern match failure
03:29:47 <neologism> I dont understand how it can fail the match in this code ;(
03:30:13 <neologism> ah.. got it
03:40:15 <vincenz> neologism: please use http://
03:40:18 <vincenz> so links are clickable
03:40:57 <sieni> and easier to find from logs
03:40:58 <neologism> sorry
03:41:08 <neologism> my dijkstra is almost working now :)
03:41:11 <vincenz> cool
03:41:18 <vincenz> dijkstra of what?
03:41:23 <neologism> shortest path
03:41:38 <vincenz> of graphs?
03:41:45 <vincenz> Have you looked at Data.Graph?
03:41:47 <vincenz> it has dijkstra
03:43:30 <neologism> vincenz: its a school project
03:43:37 <neologism> and my task is to implement dijkstra
03:43:56 <neologism> I doubt "Data.Graph.Dijkstra" will be accepted :)
03:46:10 <vincenz> :D
03:46:22 <vincenz> yeah but it's great to know haskell comes well-equipped
03:46:26 <vincenz> neologism: can I take a look?
03:46:31 <vincenz> neologism: maybe give some pointers?
03:46:59 <neologism> gimme some time to fix that
03:47:05 <neologism> if Iam desperate I'll tell ya :)
03:47:08 <neologism> and thnx for the offer
03:47:23 <vincenz> okies
03:49:39 <neologism> I would appreciate some tips how to debug it
03:49:43 <neologism> s/debug/trace
03:50:49 <goron> neologism: how about Debug.trace ;0
03:50:56 <goron> er ;)
03:51:18 <neologism> where can  I read about it?
03:52:01 <goron> This navigation is *slick*: http://www.cse.ogi.edu/~hallgren/House/kernel/pfe.cgi?Main{-House.hs-}
03:52:01 <vincenz> neologism: it's easy
03:52:13 <vincenz> neologism: trace :: String -> a -> a
03:52:18 <vincenz> it'll show string
03:52:21 <vincenz> then return the value 
03:52:25 <goron> @type Debug.trace
03:52:26 <lambdabot> Couldn't find qualified module.
03:52:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
03:52:26 <lambdabot> \\)?
03:52:41 <vincenz> @type Debug.Trace.trace
03:52:42 <lambdabot> forall a. String -> a -> a
03:52:54 <neologism> vincenz: show as in putStr ?
03:53:06 <neologism> ah.. simple show ;)
03:53:07 <goron> ah, well, close enough.
03:53:56 <goron> It's generated by this tool: http://www.cse.ogi.edu/~hallgren/h2h.html
03:54:11 <vincenz> neologism: yea
03:54:19 <goron> Someone produced something useful, you don't see that everyday :D
03:54:23 <vincenz> neologism: no
03:54:26 <vincenz> neologism: but if you want that
03:54:34 <vincenz> sTrace x = trace (show x) x
03:54:46 <vincenz> sTrace :: a -> a
03:55:58 <neologism> uh... I forgot some pretty fundamental part of the dijkstra algorithm ;)
03:56:13 <goron> neologism: do you use a state monad?
03:56:20 <neologism> I dont use any monad
03:56:56 <goron> neologism: That often helps for imperative algorithms.
03:57:23 <goron> neologism: if you want to be creative, OTOH, don't use a state monad.
03:57:31 <neologism> I want to be creative :)
03:59:40 <neologism> hm... seems like I dont understand how the algo works
04:00:09 <goron> neologism: where is your code?
04:00:35 <neologism> the problem is in my head not in my code
04:04:08 <xerox_> Hi!
04:07:46 <vincenz> xerox_: ciao
04:07:53 <goron> hi
04:13:07 <goron> neologism: so you don't understand the algorithm?
04:13:59 <neologism> I do now
04:14:11 <neologism> my code doesnt :)
04:15:59 <neologism> strange is that the whole program works (as in no runtime error) but part of it doesnt (as in runtime error)
04:16:36 <xerox_> :-)
04:16:44 <xerox_> What's up?
04:17:01 <dons> who was asking about lambdabot extensions?
04:18:24 <dons> vincenz, ah it was you?
04:18:29 <dons> what did you want to know?
04:18:33 <dons> whether:
04:18:35 <dons> ?bot
04:18:36 <lambdabot> :)
04:18:38 <dons> was implemented?
04:19:05 <goron> neologism: do you plan to post the code somewhere?
04:20:09 <neologism> http://hysteria.sk/~neologism/Search.hs
04:20:28 <neologism> but its very bad readable I think
04:20:56 <vincenz> dons: what you plan as extensions
04:23:54 <vincenz> neologism: hint: it's easier if you store your graph as Map Node Edge
04:23:57 <vincenz> neologism: hint: it's easier if you store your graph as Map Node [Edge]
04:24:04 <vincenz> easier to find edges coming from a node
04:24:37 <neologism> vincenz: next step once its working ;)
04:28:39 <goron> neologism: functional programming is also about creating small functions. 
04:29:01 <goron> neologism: This function has six arguments: dijkstra' g pc start end s q
04:29:19 <neologism> yes, its ugly
04:29:28 <vincenz> neologism: suggestion
04:29:34 <vincenz> neologism: make Graph, Graph a b
04:29:39 <vincenz> with node attributes and edge attributes
04:29:40 <vincenz> it'sm ore generic
04:29:49 <goron> neologism: that's bad for readability, and in that case a state monad comes in handy. 
04:29:52 <vincenz> then expect dijkstra to take a Graph with edge-attributes that are numbers
04:30:09 <goron> neologism: there are other monads, but you'd have to ask others for when to use those.
04:30:59 <neologism> now I am focusing on finding the bug
04:31:15 <goron> neologism: when you can't find it, refactor. 
04:40:27 <neologism> hm.. is it possible that putting sTrace into the code leads to Program error: pattern match failure: ?
04:46:26 <int-e> what is sTrace?
04:46:42 <neologism> [12:54] < vincenz> sTrace x = trace (show x) x
04:46:51 <neologism> but the runtime error suddenly dissapeard
04:58:23 <neologism> found the bug :)
04:58:30 <neologism> (coffee is the best debugger :))) )
05:16:05 <Beelsebob> neologism: nope, hat-delta is
05:16:07 <Beelsebob> :P
05:16:19 <neologism> what is hat-delta?
05:16:29 <Beelsebob> it's a Haskell debugger :P
05:16:46 <Beelsebob> specifically Haskell 98 though be warned
05:21:24 <neologism> is "sort" stable? 
05:21:31 <Beelsebob> sort?
05:21:38 <neologism> > sort [3,6,2]
05:21:39 <lambdabot> [2,3,6]
05:21:55 <Beelsebob> what do you mean by stable?
05:22:58 <bringert> from haddock: "The sort function implements a stable sorting algorithm."
05:23:13 <neologism> ok
05:26:22 <int-e> > sortBy (\a b -> fst a `compare` fst b) [(1,23),(2,12),(1,42)] -- stable means that the order of elements that compare equal is preserved - i.e. in this example, the (1,23) will come before the (1,42) in the result.
05:26:23 <lambdabot> [(1,23),(1,42),(2,12)]
05:36:57 <neologism> what is the S set good for in dijkstra algo? http://en.wikipedia.org/wiki/Dijkstra_algorithm
05:44:18 <neologism> > sort [(1,0), (2, 1), (1,1), (1,2)]
05:44:19 <lambdabot> [(1,0),(1,1),(1,2),(2,1)]
05:44:24 <neologism> ha!
05:53:26 <lisppaste2> Ronald Mai pasted "Sum And Product Problem" at http://paste.lisp.org/display/17752
06:55:15 * Beelsebob jibbles with kibbles
06:59:26 <vincenz> neologism: news?
06:59:42 <neologism> vincenz: I am fucking tired
06:59:48 <vincenz> neologism: I meant about the code :D
06:59:50 <neologism> and I am going to refactor it when I am not that tired
07:00:07 <neologism> vincenz: reload the code on the url
07:00:12 <neologism> this is the latest version
07:00:15 <neologism> I am getting runtime error there
07:00:20 <vincenz> okies
07:00:37 <vincenz> talk about unreadable code :/
07:00:41 <vincenz> that dijkstra is an abominatoin
07:01:03 <neologism> yes
07:01:24 <vincenz> should use more whereclauses with descriptive variable names
07:01:28 <vincenz> I can't make anything out of that :/
07:01:30 <neologism> yes
07:01:44 <neologism> as I said... I am going to rewrite that once my head is clear
07:01:49 <vincenz> cool
07:01:51 <vincenz> @time neologism 
07:01:52 <neologism> this is unmaintanable
07:01:55 <lambdabot> Local time for neologism is Sat Mar 11 16:01:30 2006
07:02:22 <vincenz> I'd refrain from using list comprehensions
07:02:26 <vincenz> many of them seem like filter
07:02:41 <vincenz> and filter is more readible
07:02:43 <vincenz> readable
07:02:54 <neologism> will talk about that tomorrow, ok? :)
07:03:06 <vincenz> sure thing
07:03:07 <neologism> I am barely able to read/write now :)
07:03:07 <vincenz> what time is it there?
07:03:20 <neologism> lambdabot told ya
07:03:25 <vincenz> just checking
07:03:37 <neologism> roughly the same as in belgium Id say
07:03:42 <vincenz> ayup
07:03:45 <vincenz> which country?
07:03:48 <neologism> .cz
07:03:52 <vincenz> ah
07:03:58 <neologism> thnx for the help
07:04:01 <vincenz> no worries
07:10:02 * Saulzar yawns.
07:11:47 <vincenz> time to work on my project
07:13:13 <dons> vincenz, extensions to lambdabot? you mean where is it heading?
07:13:59 <vincenz> no
07:14:03 <vincenz> yes
07:14:04 <vincenz> sorry
07:14:24 <dons> well, i'd like to continue to stabilise it. make it more robust.
07:14:31 * vincenz nods
07:14:34 <dons> add a command line interface
07:14:49 <vincenz> basically make the irc plugin just one type of input interface
07:15:00 <dons> yeah.
07:15:04 <vincenz> on a sidenote
07:15:12 <vincenz> let's assume I wanted to make a mud in haskell
07:15:17 <vincenz> would you go for threaded or singlethread
07:15:25 <vincenz> (and how would you dump stuff?)
07:15:35 <dons> I'd definitely go multithreaded.
07:15:40 <dons> and I'd dump stuff to stderr at first
07:15:49 <vincenz> yeah but then you need to mvar your world
07:16:02 <vincenz> as for dumping, my main concern is what format
07:16:05 <dons> have separate threads for input, output, network, whatever, and connect them via chans
07:16:16 <dons> oh, Show/Read format?
07:16:35 <dons> simple, and easy.
07:16:38 <vincenz> problem is that that is very code-tied
07:16:43 <vincenz> what if you wanted extensible code
07:16:51 <vincenz> ever seen cold?
07:16:54 <dons> nope
07:17:17 <vincenz> anyways, dumpwise... the problem is that you then need everythign in active memory
07:17:21 <vincenz> instead of loading on use
07:17:24 <dons> it depends on what kind of extensibility you're looking for I guess
07:17:30 <vincenz> code-extensibility
07:17:39 <vincenz> so you can easily add new features
07:18:19 <dons> ? how is this related to dumping stuff? or am i missing something
07:18:20 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
07:18:20 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
07:18:20 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
07:18:20 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
07:18:20 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
07:18:22 <lambdabot> [8 @more lines]
07:18:27 <dons> silly me.
07:18:44 <vincenz> dons: well ideally you'd have an object-database
07:19:17 <Saulzar> Are you talking about changing stuff on disk then it automatically is reflected in game?
07:19:20 <dons> oh, you want  to dump objects out?
07:19:27 <dons> i.e. serialise them?
07:19:59 <dons> in which case, you have to choose between one of the Binary libraries
07:20:34 <vincenz> Saulzar: yes :)
07:20:37 <Saulzar> I think I see what you're saying, you want some format which can handle adding new features easily without breaking everything
07:20:40 <vincenz> Saulzar: and viceversa
07:20:48 <vincenz> such that you can do online building
07:20:51 <vincenz> possibly even online coding
07:21:01 <vincenz> tho the second could be eased a bit with hs-plugins that are reloadable
07:22:42 <Saulzar> A mud in haskell would be neat, in fact a mud which wasn't ROM and in C would be neat ;)
07:23:28 <vincenz> well cold is really cool
07:23:35 <vincenz> basically it's a database that's object oriented
07:23:38 <vincenz> and a driver
07:23:44 <vincenz> which allows compilation and decompilation
07:23:53 <vincenz> then you basically write all the code for connection handling in the mud database
07:23:58 <vincenz> so everything is controlled by the code in the db
07:24:04 <vincenz> and given a reasonable starting db
07:24:08 <vincenz> that allows telnet like connection handling
07:24:10 <vincenz> and parses input
07:24:12 <vincenz> you can do online coding
07:24:28 <vincenz> it uses a classless object system
07:24:39 <vincenz> and a language that's a mix between c and python
07:24:41 <vincenz> coldc
07:24:47 <vincenz> no types (objects are the types)
07:24:48 <Saulzar> Hmm..
07:24:50 <vincenz> but some baisc syntax
07:24:59 <vincenz> for easy creation of lists, dictionaries and usch
07:25:03 <vincenz> it's the best system out there
07:25:20 <vincenz> but a) relatively unknown b) lack of development
07:25:43 <pesco> I've heard of it! *flagwave*
07:25:48 <vincenz> :)Ã 
07:28:13 <Saulzar> There must be some fairly easy way of scheduling updates around where players are, poll for updates on disk and schedule them when the areas are not in use
07:28:28 <vincenz> it basically has a set of active objects
07:28:31 <vincenz> and flushes them out periodically
07:29:39 <Saulzar> Yeah, don't see there'd be any other way... only thing is identifying what is "active", if the world is mostly static or not
07:30:15 <vincenz> I doubt a world would be static
07:30:19 <vincenz> consider picking up something
07:30:20 <vincenz> room changes
07:30:21 <vincenz> and so do you
07:30:24 <vincenz> cause the contentlist changes
07:30:33 <vincenz> anyways
07:30:35 <vincenz> as a first project
07:30:40 <vincenz> I plan to make a generic hierarchical graph editor
07:30:45 <vincenz> which could then be customized for map editting
07:31:45 <Saulzar> Right, but most muds would have objects/descriptions which respawn - it's all 99% static, on reloading from disk most stuff is reset
07:32:07 <vincenz> well the idea is that all changes get flushed to disk
07:34:13 <vincenz> obviously ideally you can do behaviour management
07:34:17 <vincenz> ... online
07:37:22 * vincenz shrugs
07:37:33 <vincenz> sometimes I wonder whether a static language is best adapted to such
07:40:33 <jyp> Saulzar: I wrote some of the basics of a haskell mud
07:41:19 <vincenz> jyp: oh?
07:41:24 <jyp> mostly a way to test out things
07:41:26 <jyp> yup
07:42:29 <jyp> I you someone is interested I can make the code available.
07:42:35 <vincenz> yep
07:42:37 <vincenz> I would be
07:43:11 <jyp> Mind you it's a for-fun project... the quality is very uneven :)
07:43:16 <vincenz> no worries
08:04:47 <ihope> So I guess I'm pretty much wanting to write a simple IRC client with bot stuff thrown in.
08:05:40 <ihope> So I want the bottom line of the terminal to be reserved for input, while everything else is the output.
08:07:14 <ihope> But this stuff should be asynchronous: some output will probably be stuck on the screen while the user's typing something.
08:16:23 <dcoutts> ihope, I think there's 3 Haskell IRC clients written using gtk2hs
08:17:20 <ihope> Hmm, that's nice.
08:17:38 <dcoutts> one was based on lambdabot code
08:19:28 <vincenz> dcoutts: hiya
08:19:36 <vincenz> dcoutts: I'm hoping to embark on another cairo project
08:19:52 <dcoutts> vincenz, cool, what will it be?
08:21:15 <vincenz> I want to make a hierarchical graph editor
08:21:41 <ihope> So I suppose one problem with Haskell is that programs have no real "when this happens, do this".
08:22:04 <nothingmuch> ihope: imagine writing a program in an imperative language
08:22:10 <nothingmuch> then wrapping it in a plastic bag
08:22:14 <nothingmuch> in a "threading" sort of way
08:22:32 <ihope> Um...
08:22:34 <vincenz> http://www.imec.be/ovinter/static_jobs/jobs_EN.shtml
08:22:37 <vincenz> whoops
08:22:49 <nothingmuch> then look at the part of the bag that's sticking out of the upper most statement and jerk wildly
08:22:49 <nothingmuch> and shake it up a bit
08:22:53 <dcoutts> ihope,  "when this happens, do this" is exactly how gtk2hs works
08:22:59 <ihope> Oh.
08:23:09 <dcoutts> that's what makes it a mid level GUI lib rather than a high level GUI lib
08:23:44 <dcoutts> people are trying to build abstractions on top which are more declarative than "when this happens, do this"
08:24:00 <dcoutts> xerox_!!
08:24:01 <vincenz> how so?
08:24:09 <ihope> http://www.expertrating.com/jobs/Programming-jobs/Intercal-Programmer-jobs.asp
08:24:11 <vincenz> xerox e un mito
08:24:24 <ihope> ¿Cómo?
08:24:51 <sieni> I think most of the channel agrees with me, when I say: WTF?
08:24:51 <xerox_> Yo
08:24:57 <xerox_> My internet is slowly dying :-(
08:25:01 <xerox_> It's been of for three days in a row, now I'm up, but I don't know how long will it last.
08:25:05 <xerox_> s/of/off/
08:25:14 * xerox_ hugs dcoutts
08:25:21 <xerox_> Hoi vincenz :-)
08:25:34 <dcoutts> xerox, you saw vincenz's cops & robbers gui?
08:25:59 <dcoutts> xerox_, and now he's starting a graph editor
08:26:29 <dcoutts> vincenz, so what make is hierarchical? do you mean acyclic?
08:26:29 <xerox_> Yea, I did.. cool!
08:26:31 <sieni> hmm... it's funny... I just had my 2^5nd birthday and I'm now going to my sister's 5^2th birthday party
08:26:37 <vincenz> dcoutts: hierarchical means that you have subgraphs
08:26:42 <dcoutts> ah
08:26:44 <vincenz> which is mostly important for visualization purposes
08:27:04 <dcoutts> graphviz can do subgraphs I believe
08:27:18 <dcoutts> so is this anything similar to Dazzle ?
08:27:20 <vincenz> graphviz a) ain't an editor b) does not allow a lot of extra semantics
08:27:28 <vincenz> www.aisee.com
08:28:01 <vincenz> not familiar with dazzle
08:28:02 <dcoutts> a I see
08:28:16 <vincenz> preferably an open system
08:28:19 <vincenz> such that developers can reuse it
08:28:49 <xerox_> Could someone nslookup ns1.libero.it and ns2.libero.it, and maybe dns.wind.it?
08:29:24 <vincenz> dcoutts: got a link to dazzle?
08:29:36 <dcoutts> http://www.cs.uu.nl/dazzle/
08:29:40 <Beelsebob> vincenz: it does alow for a lot of extra semantics - you can insert arbitrary latex or html
08:29:52 <vincenz> Beelsebob: that's not semantics but markup
08:29:55 <dcoutts> but someone forked off the graph editor part as an open source thing
08:30:01 * dcoutts tries to find that
08:30:04 <Beelsebob> vincenz: what do you want on your graph?
08:30:08 * Beelsebob tries to remember malcolm wallace's graph layout program
08:30:13 <xerox_> I think I'm off again.. sigh.  Too much lag.
08:30:17 <vincenz> for instance apply code on it, or transformations
08:30:23 <vincenz> or have layout that's annotation-dependent
08:31:01 <ndm> Beelsebob: Blobs
08:31:08 <Beelsebob> ah, no, you're expected to do your own code and transfomations before you lay it out
08:31:19 <ndm> http://www.cs.york.ac.uk/fp/darcs/Blobs/
08:31:19 <vincenz> yes
08:31:21 <vincenz> which is what this would target
08:31:37 <Beelsebob> and it does have some annotation dependant layout - you can ask it to make edges come out of certain ports on the nodes
08:32:37 <dcoutts> ah found it but ndm beat me to it :-)
08:32:39 <xerox_> growl.
08:32:53 <vincenz> hmm
08:32:56 <vincenz> Blobs seems like a good starting place
08:32:59 <ndm> dcoutts, i have http://www.cs.york.ac.uk/fp/darcs/ bookmarked :)
08:33:05 <dcoutts> ndm, heh
08:33:13 <bolrod> @seen dblhelix
08:33:13 <lambdabot> I saw dblhelix leaving #haskell-blah and #haskell 5 days, 1 hour, 46
08:33:13 <lambdabot> minutes and 49 seconds ago, and I have missed 1 day, 19 hours, 31 minutes
08:33:13 <lambdabot> and 37 seconds since then.
08:33:18 <dcoutts> vincenz, but a cairo version of something similar would be nice :-)
08:33:27 <vincenz> it's not cairo based?
08:33:31 <dcoutts> nope
08:33:34 <dcoutts> wxhaskell
08:33:41 <vincenz> ah
08:33:46 <vincenz> well wouldn't that be reinventing the wheel?
08:34:33 <dcoutts> I'm not sure, perhaps it's just replacing the drawing code
08:34:43 <dcoutts> depends on how modular the code is
08:36:43 <vincenz> what's the difference between blobs and dazzle?
08:36:56 <dcoutts> dazzle is closed source
08:36:58 <ndm> vincenz: i don't believe dazzle is open source
08:37:12 <ndm> malcolm took the bits he could from dazzle, and freed them, and tweaked them
08:37:37 <vincenz> so (date Blobs) > (date Dazzle)
08:37:44 <ndm> vincenz: yes
08:37:52 * vincenz nods
08:37:53 <vincenz> thx
08:38:06 <vincenz> blobs still active?
08:38:59 <ndm> http://www.cs.york.ac.uk/fp/darcs/
08:39:06 <ndm> click on Blobs
08:39:14 <xerox_> help :-|
08:39:20 <ndm> last commit was 3 days ago, but it was rather quiet for a few weeks before that
08:39:29 <palomer> <:o
08:40:35 <palomer> hello #haskell!
08:40:43 <vincenz> aloha
09:33:51 <vincenz> @seen cale
09:33:52 <lambdabot> cale is in #haskell. Last spoke 10 hours, 12 minutes and 38 seconds ago.
09:40:35 <Cale> hi
09:40:54 * Cale wakes up
09:41:09 <vincenz> Cale: hi
09:43:52 <Cale> hi vincenz 
09:44:59 <vincenz> Cale: I hope you're not lagged
09:45:07 <vincenz> I try to download when oyu're not there
09:47:20 <Cale> ah, perhaps that's why my torrent isn't finished yet :)
09:47:45 <vincenz> sowwy :/
09:47:49 <Cale> (It's all right though)
09:47:57 <vincenz> instead of all left?
09:47:58 <vincenz> :P
09:48:10 * vincenz takes the Either monad
09:48:21 <vincenz> I wish I could set a cap rate on download speed
09:48:30 <vincenz> So I wouldn't have to do file by file and check you're here
09:48:32 <vincenz> like 1kb/s
09:48:35 <vincenz> and just let it ri
09:48:35 <vincenz> p
09:48:39 <Cale> heh
09:48:50 <Cale> what are you using?
09:48:54 <vincenz> firefox
09:49:32 <Cale> oh
09:50:02 <Cale> yeah, come to think of it, that is annoying.
09:50:13 <vincenz> what is?
09:51:53 <Cale> the lack of controls in the firefox download manager
09:52:47 <Cale> I suppose there are extensions to handle downloads with wget, but that's not really the same
09:53:39 <jips> who thinks it would be cool to write a webbrowser from scratch using haskell, gtk2hs for gui and cairo for html+css rendering?
09:54:10 <dcoutts> jips, I was looking at box layout algorithms the other day
09:54:58 <jips> css box model is indeed pretty ugly and complicated
09:55:04 <dcoutts> that was for epigram, they want to make a WYSIWYG structure editor with latex-quality rendering
09:55:11 <jips> hm...
09:55:29 <dcoutts> the new epigram gui is going to be cool :-)
09:55:33 <Cale> Writing an entire HTML+CSS layout engine is a pretty big project -- it would be cool if someone did it in Haskell though :)
09:55:49 <dcoutts> jips, the really annoying bit would be javascript
09:56:01 <dcoutts> that pretty much requires this nasty dom model
09:56:05 <zamez> I think it would be interesting
09:56:15 <jips> yeah, javascript i think would be pointless to even try
09:56:18 <Cale> Epigram should use the Computer Modern Roman font :)
09:56:38 <Cale> eh, pointless?
09:56:47 <Cale> I think it could be done
09:56:54 <Cale> If you're going to go to all the trouble of writing the rest of it
09:56:57 <dcoutts> Cale, I wonder why you don't get that Computer Modern Roman as a truetype/opentype font
09:57:08 <jips> it could be done, but most scripts on the web are so bad and broken and only work with certain versions of certain browsers
09:57:22 <Cale> Because it's a MetaFont font
09:57:23 <dcoutts> why can't we pinch latex fonts for using in X and in pdf etc
09:57:31 <dcoutts> well why can't it be converted?
09:57:41 <Cale> I've seen TTF versions of it
09:57:43 <dcoutts> it's just vectors
09:58:01 <Cale> Oh, it can
09:58:03 <dcoutts> even without the hinting it'd be an improvement
09:58:08 <dcoutts> wouldn't it?
09:58:11 <Cale> but the shapes are actually different at every point size
09:58:32 <Cale> (like a real typeface should be)
09:58:32 <Cale> yeah
09:58:42 <Cale> I think so
09:58:55 <dcoutts> can't opentype handle that?
09:59:08 <dcoutts> I thought that's more or less what hinting is about
09:59:25 <dcoutts> adusting the shapes at various point sizes to make it look right
10:00:17 <Cale> yeah -- I kind of think that CMR does a little more than the average hint
10:00:36 <Cale> but it might be possible
10:00:52 <Cale> I can't recall if MetaFont is Turing complete
10:01:45 <Cale> anyway, there ought to be some provision for storing glyphs at various point sizes
10:03:08 <tomshackell> kombinator: hello?
10:03:16 <Cale> so lagged... going to reset my connection
10:05:52 <vincenz> Cale: that's myffault
10:05:58 <ndm> @seen kombinator
10:05:58 <lambdabot> kombinator is in #haskell. Last spoke 6 hours, 58 minutes and 20 seconds
10:05:58 <lambdabot> ago.
10:06:05 <vincenz> Cale: 4 minutes?
10:06:23 <Cale> hm?
10:06:31 <vincenz> in four minutes the file is done
10:06:34 <Cale> oh
10:06:39 <vincenz> tho for some reason it seems to have stalled
10:06:47 <Cale> that's probably my fault
10:06:54 <vincenz> okies
10:06:58 <vincenz> I'll do it when oyu're not online
10:07:03 <Cale> okay
10:11:08 <kombinator> tomshackell: hi
10:11:36 <tomshackell> kombinator: hi, are you the person who emailed about Yhc on 64bit architectures?
10:11:44 <kombinator> right
10:12:01 <tomshackell> cool, Neil siad you had a problem with the GC?
10:12:40 <kombinator> yes, I have already found one bug in gc, but it still crashes in another place
10:13:01 <tomshackell> this doesn't surprise me it's quite sensitive :-)
10:13:06 <tomshackell> what was the bug you found?
10:13:27 <kombinator> another casting problem
10:13:35 <kombinator> hunk ./src/runtime/BCKernel/info.c 136
10:13:35 <kombinator> -    *lstArg = cinfo->size - 1;
10:13:35 <kombinator> +    *lstArg = ((Int) cinfo->size) - 1;
10:14:06 <kombinator> lstArg was becoming very big if cinfo->size was 0
10:15:20 <tomshackell> ahh, surprised that's not an issue on 32 bit platforms also ...
10:15:52 <kombinator> it's not because the width of cinfo-size is the same as of lstArg
10:16:13 <kombinator> so the large value becomes -1 after casting
10:16:26 <tomshackell> gah, of course.
10:16:45 <tomshackell> well found :-)
10:17:18 <kombinator> the problem that I (and Neil) found yesterday was of the same kind
10:18:04 <tomshackell> *nods* it's too easy to introduce things which are actually bugs (like taking an unsigned value and subtracting 1 indescrimnately) but which actually work due to the mechanics of the platform.
10:18:36 <ndm> just shows how bad an idea unsigned numbers are!
10:19:09 <kombinator> implicit casts are evil
10:19:24 <tomshackell> indeed, I'd prefer it if C refused to do them entirely.
10:19:38 <tomshackell> I had completely forgotten when I wrote that that cinfo->size was unsigned.
10:20:37 <kombinator> now the gc still crashes at me and I don't know how to bite it...
10:21:02 <tomshackell> is it always crashing every time it GCs or only sometimes?
10:21:35 <kombinator> actually, I'm only running the Queens test
10:21:37 <ndm> does gcc have a warning, since i know there are some signed/unsigned errors in the code base
10:21:45 <ndm> these might correspond to the issues
10:21:47 <kombinator> and it crashes every time
10:21:59 <tomshackell> ndm: no because unsigned short to int is a widening cast.
10:22:04 <kombinator> I'll look at the warnings
10:22:39 <tomshackell> ndm: it'd be nice if it *did* warn about that, but sadly it doesn't.
10:24:29 <lisppaste2> kombinator pasted "make output when building YHC runtime on AMD64" at http://paste.lisp.org/display/17758
10:26:06 <kombinator> nothing particularly alarming there
10:27:30 <ndm> i'm impressed it checks inside the printf!
10:27:39 <tomshackell> ndm: mmm gcc feature
10:28:04 <ndm> tomshackell: to paper over a broken interface...
10:28:29 <__AL__> Lemmih: I find out that problem was in hs-plugins -- for example "plugs" and many other examples fails with "magic number mismatch: old/corrupt interface file?"
10:28:42 <palomer> is it possible to get parsec to tell me where it's failing to parse?
10:28:44 <tomshackell> kombinator: there's a couple of things that might help, turning on debug in jonkers.c is the most obvious.
10:28:56 <tomshackell> though it does produce a lot of output ...
10:29:38 <tomshackell> also is it this assertion that fails?
10:29:40 <tomshackell> ASSERT(mkt_isMarked(*p));
10:29:52 <tomshackell> (jonkers.c:62)
10:30:09 <kombinator> I'll post the stacktrace on haskell-overflow
10:30:33 <tomshackell> cool
10:30:49 <kombinator> please join;)
10:31:31 <__AL__> Lemmih: version 0.9.10, from darcs it all fails with segfault
10:46:55 <lisppaste2> kombinator pasted "YHC's gc debug output" at http://paste.lisp.org/display/17760
10:50:24 <palomer> yay! infinite loop!
10:50:26 <kombinator> tomshackell: so the crash occurs when scanning the heap
10:50:46 <palomer> ok, how does one deal with mutually recursive datatypes?
10:53:38 <tomshackell> kombinator: indeed
10:54:07 <tomshackell> kombinator: it looks like it reachs the (:) node, then tries to thread the arguments but ends up trying to thread something which isn't a heap pointer.
10:54:55 <tomshackell> in mutator.c turn on VERY_PARANOID that'll check the whole heap after every instruction which'll check it's not actually a heap corruption.
10:55:19 <tomshackell> otherwise I suspect node_size ...
10:56:37 <palomer> >:o
10:57:03 <palomer> oh my god how I wish I could use hat
10:57:22 <tomshackell> palomer: ?
10:57:35 <tomshackell> in the sense of hat doesn't work or that hat is hard to use?
10:57:38 <palomer> my code doesn't work with hat
10:57:40 <ndm> palomer: prod tomshackell into getting hat support into Yhc, then you'll have brilliant hat support
10:58:00 <ndm> palomer: does hat-trans just crash on it, or does the resulting code not work
10:58:08 <ndm> send a bug report to the hat mailing list
10:58:44 <palomer> I've been over this with webster
10:58:50 <palomer> there's nothing that can be done
10:58:52 <palomer> :(
10:58:55 <palomer> it's a known problem
10:59:03 <tomshackell> there's valid readsons for programs not working with hat, GHC extensions for example. There's also less valid reasons such as type checking errors.
10:59:04 <ndm> what is the problem, and who is webster?
10:59:09 <palomer> if only there was a way to find infinite loops!
10:59:22 <ndm> hat-nonterm and black-hat are great ways
11:00:20 <tomshackell> hat-stack also.
11:00:26 <ndm> palomer: how long is yoru code?
11:00:30 * kombinator is still waiting for Queens to terminate
11:00:31 <palomer> 3300 lines
11:00:34 <palomer> or so
11:00:49 <palomer> to use hat, I would need to remove all references to Map
11:00:52 <palomer> and replace them with List
11:00:59 <tomshackell> kombinator: that's a good sign :-) however if it takes too long then stop it and turn on ALWAYS_NEEDHEAP ;-)
11:01:03 <ndm> one thing that has bitten me before, do you have any Ord instances that are not semetric, transitive etc.
11:01:29 <palomer> hrmmm
11:01:36 <tomshackell> *nods* Ord is the easiest way to write nonterminating programs.
11:01:36 <palomer> is it possible to import my own version of Map?
11:01:42 <ndm> palomer: but Yhc should have hat support for Data.Map in a short time
11:01:57 <kombinator> what's the default heap size for yhi?
11:02:00 <palomer> but I won't be able to use Yhc
11:02:06 <ndm> why not?
11:02:09 <palomer> because I use glasgow extensions
11:02:17 <ndm> ah, in that case your screwed :)
11:02:18 <palomer> like newtype deriving
11:02:27 <tomshackell> kombinator: erm depends on how recently you pulled. Until yesterday 40M, now it's 16M (and configurable)
11:02:34 <palomer> hrm, I'll just write an MMap module
11:02:37 * palomer curses
11:02:38 <ndm> oh, if thats all it is, i am sure you can submit a patch to get Yhc to do that
11:02:54 <ndm> or prod someone, doesn't sound very hard at all
11:03:25 <ndm> palomer: is your code "open" in any way, i.e. could i have a copy?
11:03:30 <palomer> http://www.rafb.net/paste/results/p36JwM94.html <
11:03:36 <palomer> that's what I get when I run black-hat
11:03:56 <ndm> i have never run hat, i'm afraid...
11:04:01 <palomer> ndm: I haven't released it yet...
11:04:08 <ndm> could i have it in its current state?
11:04:25 <ndm> i'm writing a termination checker, so if this is genuine code with a good non-termination problem
11:04:31 <tomshackell> palomer: yeah, that's a common problem with hat, the tools are a cow to install properly.
11:04:33 <ndm> that would be really handy, i.e. not manufactured non-termination
11:04:34 <kombinator> ndm, tomshackell: how to specify heap size less than 1M?
11:04:37 <palomer> ndm: the non-termination is in ST
11:04:51 <palomer> ndm: can your checker handle ST?
11:05:01 <ndm> tomshackell: can Yhc handle ST?
11:05:02 <tomshackell> kombinator: yhi -h 1M Main
11:05:02 <vincenz> @seencale
11:05:02 <lambdabot> Unknown command, try @listcommands.
11:05:04 <vincenz> @seen cale
11:05:05 <lambdabot> cale is in #haskell. Last spoke 58 minutes and 1 second ago.
11:05:15 <kombinator> and less than 1M?
11:05:28 <tomshackell> kombinator: yhi -h 10K Main
11:05:32 <tomshackell> kombinator: yhi -h 10b Main
11:05:34 <tomshackell> ;-)
11:05:36 <kombinator> thx
11:05:46 <ndm> palomer: if Yhc can handle it, then my termination checker has a chance on it
11:05:52 <tomshackell> just running yhi should tell you the options.
11:06:03 <palomer> ndm:  but it uses extensions!
11:06:11 <Cale> vincenz: still here
11:06:15 <ndm> palomer: what, ST?
11:06:22 <tomshackell> oh I didn't push that yet ...
11:06:22 <palomer> no, newtype deriving
11:06:30 <palomer> as well as multi parameter type classes
11:06:33 <ndm> i wouldn't worry about that, newtype deriving is easy
11:06:45 <palomer> and no-monomorphism
11:06:46 <ndm> MPTC are likely to go in Yhc eventually, maybe even sooner than later
11:06:52 <tomshackell> ndm: no Yhc doesn't support ST because it uses second rank polymorphism
11:06:54 <ndm> monomorphism was never in Yhc
11:07:10 <palomer> tomshackell: ST is _so_ useful
11:07:11 <lisppaste2> kombinator pasted "YHC gc bug" at http://paste.lisp.org/display/17761
11:07:22 <palomer> are there any alternatives to hat?
11:07:29 <tomshackell> trace ;-)
11:07:48 <tomshackell> or Debug.Trace I think it's called now :-)
11:07:53 <kombinator> tomshackell: that was with VERY_PARANOID
11:08:01 <palomer> yeah, but trace isn't easy to use on a 400 line file
11:08:01 <ndm> not any alternatives which will actually work to find non-termination
11:08:04 <kombinator> and -h 20KB
11:08:25 <palomer> haskell may be used to write programs that work, but haskell programmers don't seem to write programs that install
11:08:31 <tomshackell> kombinator: good that means there's no (obvious) heap corruption.
11:08:51 <tomshackell> palomer: mmmm ... it's a problem :-)
11:08:51 <ndm> the hat tools are horrible, i intend to windows port them at some point
11:08:52 <palomer> ndm: anyways, yeah, finding non-termination statically is going to be _hard_
11:09:06 <ndm> palomer: no, its going to be _impossible_
11:09:13 <palomer> so how does your tool work?
11:09:21 <ndm> currently, in theory
11:09:25 <ndm> @where catch
11:09:25 <lambdabot> I know nothing about catch.
11:09:41 <ndm> @where+ catch http://www.cs.york.ac.uk/~ndm/projects/catch.php
11:09:42 <lambdabot> Done.
11:10:05 * palomer wishes he could automatically annotate every function in a file with 'trace "im in $foo" >> return () '
11:10:07 <ndm> thats a description of how it currently works, i have nothing written up on teh termination yet
11:10:46 <ndm> remember, lazy evaluation can put your non=termination in really weird places
11:11:05 <tomshackell> kombinator: try getting it to print fstArg, lstArg and size after node_size in jonkers.c:178
11:11:39 <palomer> ndm: I doubt it would in ST
11:12:00 <ndm> if you know its this one file, can you lisppaste it?
11:12:38 <palomer> it's a _really_ ugly file
11:12:48 <tomshackell> palomer: is it the monadic code that's looping?
11:12:50 <palomer> with tons of dependencies
11:12:59 <palomer> tomshackell: it's looping in ST
11:13:19 <zellyn> @where ST
11:13:19 <lambdabot> I know nothing about st.
11:13:25 <zellyn> What is ST?
11:13:31 <ndm> can you modify ST to write out a partial trace
11:13:31 <palomer> well, it's not looping inside a specific file
11:13:31 <zellyn> (sorry - noob here!)
11:13:36 <palomer> a function which the file is calling is looping
11:13:50 <ndm> at least that would tell you if its doing lots of ST operations, or looping inside just one
11:13:51 <palomer> well, found it
11:13:58 <ndm> do tell
11:14:17 <palomer> well, found the function, not the error
11:14:24 <palomer> but the looping can really only be caused by one thing in my code
11:14:27 <palomer> circular references
11:14:32 <tomshackell> zellyn: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
11:15:53 <zellyn> tomshackell: thanks!
11:16:52 <lisppaste2> kombinator pasted "YHC gc bug (')" at http://paste.lisp.org/display/17762
11:17:54 <lightstep> is ScannedInAvian.org down, or is my network broken?
11:18:56 <tomshackell> kombinator: well that's correct :-)
11:19:20 <kombinator> you mean, they look correct - right?
11:19:39 <tomshackell> *nods* that's the values that fstArg, lstArg and size should have :-)
11:20:14 <zellyn> lightstep: .org down, .com up.
11:20:25 <kombinator> and it crashes on i = 0 in the loop over arguments
11:20:42 <palomer> know what would be cool?
11:20:55 <palomer> a function that would look at your store and tell you if you have any circular references
11:21:19 <lightstep> palomer, like a garbage collector?
11:21:41 <tomshackell> hmm my guess is either that the threading is overwriting the wrong place or that the mark phase screwed something up.
11:21:59 <tomshackell> the second is easy to test ...
11:22:22 <palomer> lightstep: a garbage collector collects, my function would simply inspect
11:23:27 <tomshackell> in jonkers.c: jonk_collect between:
11:23:29 <tomshackell>   mark();
11:23:30 <tomshackell>   jonk_threadCAFs();  mark();
11:23:46 <tomshackell> sorry the second mark(); is spurious there ...
11:23:53 <tomshackell> add sanity_heap(false);
11:24:49 <kombinator> I'll turn VERY_PARANOID off - ok?
11:24:53 <tomshackell> sure :-)
11:25:05 <kombinator> that instance with default heap is still running;)
11:25:38 <tomshackell> rofl, yeah scanning the whole heap takes quite a while and doing every instruction is very slow. HelloWorld takes about a minute ;-)
11:27:13 <lisppaste2> kombinator pasted "YHC gc bug ('')" at http://paste.lisp.org/display/17763
11:27:41 <tomshackell> that's with sanity_heap immediately after the mark?
11:27:44 <kombinator> It's no different from the previous one
11:27:48 <kombinator> yes
11:28:04 <kombinator>   mark();
11:28:04 <kombinator>   sanity_heap(false);
11:28:04 <kombinator>   jonk_threadCAFs();
11:28:22 <tomshackell> that's cool means the mark phase is likely fine, which is nice because the mark is even worse to debug than the collector.
11:29:02 <tomshackell> okay are you familiar with gdb's hardware watchpoints?
11:30:12 <kombinator> no
11:30:37 <palomer> <:o
11:30:42 <palomer> Cale: you around?
11:31:01 <tomshackell> kombinator: ah very useful, essentialy what you can do is get gdb to watch a peice of memory for you and run until it's changed.
11:31:36 <kombinator> where are they in help?
11:32:07 <tomshackell> breakpoints
11:32:22 <tomshackell> 'watch' is the general command of use.
11:32:53 <kombinator> ok
11:33:01 <tomshackell> so what you might do is:
11:33:16 <tomshackell> - set a breakpoint at the top of jonk_collect
11:33:43 <kombinator> done
11:33:43 <tomshackell> - figure out which heapnode is the one being corrupted (if you're lucky the pointer doesn't changed between invocations, otherwise you have to do it based on offsets from G_hpStart)
11:34:18 <tomshackell> - except before figuring it out it's best to run gdb to the breakpoint ;-)
11:35:16 <tomshackell> because if you try and watch memory that's not malloced yet it gets grumpy
11:35:37 <tomshackell>   Updating 0x535990[262] [{ } (C: ... ...)] to 0x535198[7]
11:36:11 <tomshackell> hmm looks like it changes every time sadly.
11:36:43 <tomshackell> [262] is the offset from G_hpStart thus the node you want is G_hpStart+262
11:36:58 <tomshackell> and you want it's first argument so that's
11:37:51 <tomshackell> watch ((Node*)(G_hpStart+262))->args[0]
11:38:03 <kombinator> ok
11:38:38 <tomshackell> out of interest what value does that have at the top of jonk_collect?
11:38:58 <kombinator> it crashed without reaching the watchpoint
11:39:21 <kombinator> what value?
11:39:52 <kombinator> ok, now I get it
11:40:45 <dcoutts> has anyone here ever used hsql with the sqlite3 backend? I can't get it to work. It fails on getting int fields from query result sets.
11:40:54 <tomshackell> yes sorry my explanation was a bit jumbled. you need to:
11:41:08 <tomshackell> - set breakpoint at the top of jonk_collect
11:41:15 <tomshackell> - run gdb, tell it to watch the memory
11:41:35 <tomshackell> - continue gdb and hopefully it'll stop if the memory changes.
11:42:09 <kombinator> (gdb) print ((Node*)(G_hpStart+262))->args[0]
11:42:09 <kombinator> $3 = (struct _Node *) 0x58a4c1
11:42:10 <lambdabot> compose module failed: Parse error: "="
11:43:35 <kombinator> it doesn't reach that watchpoint
11:43:37 <tomshackell> and what's G_hpStart and G_hpEnd?
11:43:55 <kombinator> (gdb) print p
11:43:55 <kombinator> $1 = (Node *) 0x52a8f0
11:43:55 <kombinator> (gdb) print G_hpStart
11:43:55 <kombinator> $2 = (Word *) 0x52a0c0
11:43:55 <kombinator> (gdb) print G_hp
11:43:56 <lambdabot> compose module failed: Parse error: "="
11:43:56 <lambdabot> compose module failed: Parse error: "="
11:43:56 <kombinator> $3 = (Word *) 0x52c800
11:43:56 <lambdabot> compose module failed: Parse error: "="
11:44:17 <tomshackell> oh so it starts off incorrect ...
11:44:51 <tomshackell> hmm VERY_PARANOID should have flagged that ...
11:46:02 <kombinator> maybe the offset from g_hpStart is wrong?
11:46:20 <kombinator> but C: makes sense...
11:46:26 <tomshackell> what 262?
11:46:33 <kombinator> yes
11:46:46 <kombinator> the value of p just before the crash
11:46:54 <tomshackell> well I did get it to print the offset from G_hpStart in []s because it's useful :-)
11:47:06 <tomshackell> what value of *p does it have when it crashed?
11:47:13 <tomshackell> is it the same 0x58a4c1?
11:47:42 <kombinator> (gdb) print p
11:47:42 <kombinator> $5 = (Node *) 0x52a8f0
11:47:42 <kombinator> (gdb) print *p
11:47:42 <kombinator> $6 = {_hidden = 5809089, args = 0x52a8f8}
11:47:42 <lambdabot> compose module failed: Parse error: "="
11:47:42 <lambdabot> compose module failed: Parse error: "="
11:48:13 <kombinator> something's wrong here
11:50:05 <tomshackell> print (Node*)*p
11:50:32 <kombinator> (gdb) print *((Node*)p)
11:50:32 <kombinator> $11 = {_hidden = 5809089, args = 0x52a8f8}
11:50:33 <lambdabot> Maybe you meant: . id pl wn
11:50:50 <davidhouse> lambdabot: shut up
11:50:59 <tomshackell> print *((Node**)p)
11:51:16 <kombinator> (gdb) print *((Node**)p)
11:51:16 <kombinator> $12 = (struct _Node *) 0x58a3c1
11:51:17 <lambdabot> Maybe you meant: . id pl wn
11:51:31 <tomshackell> hmm looks very familiar.
11:51:44 <tomshackell> looks like something *is* corrupting the heap before GC ...
11:52:20 <kombinator> and sanity_heap () doesn't see it?
11:52:31 <tomshackell> hmmm watchpoint tricks again, same again except this time the breakpoint is mutator.c:98
11:52:46 <tomshackell> that'll tell you about every time that word is touched.
11:57:55 <kombinator> this is weird
11:58:18 <tomshackell> oh?
11:58:32 <kombinator> the value of ((Node*)(G_hpStart+262))->args[0] is the same on the braekpoint and after the crash
11:58:47 <kombinator> (gdb) print ((Node*)(G_hpStart+262))->args[0]
11:58:47 <kombinator> $4 = (struct _Node *) 0x58a4c1
11:58:48 <lambdabot> compose module failed: Parse error: "="
11:58:53 <kombinator> or gdb tricks me
12:00:06 <tomshackell> ie. it was never modified in the program at all?
12:00:46 <davidhouse> is this GHC?
12:01:02 <tomshackell> no Yhc
12:01:04 <kombinator> the breakpoint in mutator.c:98 is supposed to be reached just before all execution?
12:01:11 <davidhouse> oh, okay.
12:01:22 <davidhouse> i was wondering what talk of C was doing in #haskell :)
12:02:46 <kombinator> I'll be back in 5-10 minutes
12:02:58 <tomshackell> should be  *--sp = top; it's one of the first lines in the mutator
12:03:29 <tomshackell> okay :-)
12:10:44 <TuringTest> > 1+1
12:10:45 <lambdabot> 2
12:14:49 <kombinator> tomshackell: but a value can be placed on the heap before the execution - right?
12:16:40 <tomshackell> yes ... it can ...
12:16:48 <tomshackell> it can be loaded by the module system
12:17:07 <tomshackell> not sure about a (:) node though ...
12:17:22 <tomshackell> as far as I can remember the module system only loads 0 arity definitions.
12:17:38 <kombinator> where is the heap initialized?
12:17:55 <kombinator> perhaps I should fill it with a fixed pattern?
12:18:13 <kombinator> and check if it will show up in the debugger
12:18:46 <tomshackell> good idea. heap_init in heap.c
12:19:15 <tomshackell> 39: G_hpStart = (Word*)malloc(wSize * sizeof(Word));
12:25:05 <kombinator> the pattern doesn't show up
12:25:54 <kombinator> but a 0-ary definition can contain (:)
12:26:52 <kombinator> x = [1, 2, 3]
12:28:39 <tomshackell> except I'm fairly sure that's compiled as PUSH_CONST [] ; PUSH_INT 3 ; MK_CON (:) ... etc.
12:30:09 <kombinator> what does jonk_scan () do anyway?
12:30:24 <tomshackell> I believe the module system only loads consttable items into the heap, which are all 0 arity
12:30:54 <tomshackell> essentially it updates a lot of the pointers to their new locations.
12:31:28 <kombinator> perhaps we should focus on the difference between scanning the heap in jonk_scan() and sanity_heap()?
12:31:47 <kombinator> oh
12:31:58 <tomshackell> they're quite different, sanity_heap is much more like mark.
12:33:21 <kombinator> every time we update a node we print its address here: SHOW(printf("\tUpdating %p[%d] [", p, HEAPOFFS(p));pr_jonk_node(p,1);printf("] to %p[%d]\n",new ?
12:33:37 <kombinator> I'll look at the debug log once more
12:35:54 <__AL__> All examples from hs-plugins fails with "magic number mismatch: old/corrupt interface file?". Arch - amd 64. Can anybody help?
12:42:24 <dcoutts> __AL__, if you get hs-plugins working on amd64 do tell me
12:43:27 <andrew_p> hello
12:44:31 <kombinator> tomshackell: which part of sanity_heap() can reach that problematic location?
12:45:31 <andrew_p> anybody seen code to factorize large prime integers?;)
12:45:49 <ndm> andrew_p, not possible :)
12:46:01 <ndm> or yes, factor_prime x = [1,x]
12:46:36 <__AL__> dcoutts, ok, i'll try. What can i read about it?
12:46:45 * palomer hates evolution
12:46:51 <palomer> anyways, found my bug if anyone cares
12:47:33 <andrew_p> well, i should explain .. i was going to write that myself and got a function that makes a list of primes from one to the facrized number .. the i should make up pairs somehow and chech if their product equals the prime to factorize 
12:47:57 <andrew_p> but the latter function looks somewhat complicated for me .. i'm a beginner in haskell :)
12:48:26 <kombinator> kombinator tomshackell: which part of sanity_heap() can reach that problematic location?
12:48:32 <pesco> ndm: Is 1 considered a prime?
12:48:39 <TuringTest> pesco: No
12:48:43 <ndm> pesco: No
12:48:49 <pesco> Okay.
12:49:09 <pesco> Right, the prime factorization uniqueness theorem wouldn't make much sense then, would it?
12:49:35 <andrew_p> there was an exercise in crypto book to compute RSA key and i thought it would be nice to have a function in Haskell for that purpose
12:49:44 <ndm> kombinator: i think tom has gone off now
12:50:03 <pesco> andrew_p: Have fun studying number field sieves!
12:50:21 <pesco> I'm personally quite looking forward to doing so... ;-)
12:50:51 <kombinator> ndm: he's just joined as tomshack1ll, didn't he?
12:51:21 <ndm> kombinator: he went off IM, he may be on here as a new name, quite possibly
12:52:05 <tomshack1ll> kombinator:  hello
12:52:12 <tomshack1ll> sorry it killed my connection ...
12:52:39 <tomshack1ll> kombinator: well it depends where it is being reached from ...
12:53:05 <tomshack1ll> in theory sanity heap should check all the stack and CAFs and globals the same as jonk/mark
12:53:08 <kombinator> tomshack1ll: if it's not reachable?
12:53:13 <andrew_p> i think i should start with a function that given a list of primes will make all possible pairs, independent of order .. this task differs from generating a set of all possible subset, which would be easy to implement
12:57:12 <andrew_p> he-he, i factorized the number given in exercise by "brute-forcing" it, so i will write the program later :D
13:00:06 <dcoutts> __AL__, ask gour and/or dons 
13:01:38 <tomshack1ll> kombinator: if you want to check what sanity heap is doing there's a debug flag in that as well ...
13:01:54 <tomshack1ll> though that'll give a truely horrendous ammount of output.
13:02:02 <mpercossi> hello all
13:02:12 <tomshack1ll> given it'll print every heap node every instruction.
13:02:44 <__AL__> dons, How can i help with porting hs-plugins to amd64?
13:02:56 <mpercossi> Let's say I define the following:
13:03:03 <mpercossi> type Vector     = UArray Int Double
13:03:03 <mpercossi> type MVector s  = STUArray s Int Double
13:03:14 <mpercossi> runSTVector :: (forall s . ST s (MVector s)) -> Vector
13:03:14 <mpercossi> runSTVector = runSTUArray
13:03:21 <mpercossi> I get error:
13:03:27 <mpercossi> vector.hs:176:14:
13:03:27 <mpercossi>     Couldn't match the rigid variable `.' against `ST'
13:03:27 <mpercossi>       `.' is bound by the type signature for `runSTVector'
13:03:27 <mpercossi>       Expected type: . (forall s) (ST s (MVector s)) -> Vector
13:03:27 <mpercossi>       Inferred type: (forall s1. ST s1 (STUArray s1 i e)) -> UArray i e
13:03:28 <mpercossi>     In the definition of `runSTVector': runSTVector = runSTUArray
13:03:30 <mpercossi> Failed, modules loaded: none.
13:03:38 <mpercossi> does anyone know how I can fix this problem?
13:04:16 <mpercossi> (I'd like to create an analog of runSTUArray for vectors...)
13:04:38 <mpercossi> (this way I can do some work in ST, get back the result and display it in IO or using show)
13:06:26 <tomshack1ll> kombinator: anyway I'm off to have some food, thanks for all your help it's really much appreciated. I'll try and get a login on my friends AMD64 and see if I can get it to work, thanks again :-)
13:11:30 <kombinator> ndm: too bad tom's gone, I've just found a suspect
13:11:43 <alar> hello
13:12:27 <alar> ndm: is there a teorem that decider can't be used to make itself?
13:12:42 <alar> like one cannot write Epigram in Epigram
13:18:56 <ihope> @google 36 F.Supp.2d 191
13:18:58 <lambdabot> http://www.law.cornell.edu/copyright/cases/36_FSupp2d_191.htm
13:25:23 <ihope> @time
13:26:26 <davidhouse> @time you got a watch
13:26:36 <ihope> @time why?
13:26:39 <ihope> @help time
13:26:40 <lambdabot> print a user's local time
13:26:44 <davidhouse> @time ihope
13:26:45 <ihope> @time davidhouse
13:26:46 <lambdabot> Local time for davidhouse is Sat Mar 11 21:26:24 2006
13:26:47 <lambdabot> Local time for ihope is Saturday, March 11, 2006 4:26:16 PM
13:26:57 <palomer> @time palomer
13:26:58 <lambdabot> Local time for palomer is Sun Mar 12 16:26:39
13:27:27 <ihope> @time ihope
13:27:28 <davidhouse> how come mine's "Sat Mar..." and yours is "Saturday, March"? and mine is 24h and yours is 12h?
13:27:31 <lambdabot> Local time for ihope is Saturday, March 11, 2006 4:27:00 PM
13:27:35 <alar> @time ndm
13:27:41 <alar> @time lambdabot
13:27:42 <ihope> davidhouse: it
13:27:46 <ihope> 's a client thing.
13:27:47 <davidhouse> woah, palomer's in the future
13:28:00 <palomer> do you have a problem with that?
13:28:02 <davidhouse> ihope, ah. i figured the client just passed the timezone
13:28:18 <davidhouse> palomer: what's it like? flying cars and stuff?
13:28:31 <ihope> We'll have flying cars tomorrow?
13:28:32 <palomer> they managed to make cell phones even smaller
13:28:36 <ihope> Gasp!
13:28:37 <palomer> and  cars bigger
13:29:05 <ihope> Do you need a microscope to see those cell phones?
13:29:11 <palomer> there should be a degree in which you don't publish anything, you just learn
13:29:34 <davidhouse> what would be the point of the degree? you could just get a textbook
13:29:37 <palomer> the cell phones are made of anti matter, so putting cell phones in a room will actually create more space
13:29:45 <palomer> davidhouse: funding:P
13:30:16 <davidhouse> palomer: it will also cause a catastrophic explosion of gamma rays, which is a shame.
13:30:49 <ihope> Well, not if there's quantum stuff.
13:31:02 <ihope> You see, with quantum superpositions, things can overlap.
13:31:05 <palomer> the expert has spoken
13:31:05 <davidhouse> if it's antimatter...
13:31:47 <davidhouse> ihope: so, what, the exclusion principle doesn't apply?
13:31:55 <davidhouse> or it's probabilistic or something
13:31:56 <ihope> So for every cell phone you have in the room, you get approximately 10^300 times as much space.
13:32:02 * alar proposes to change -allow-overlapping-instances to -allow-quantum-superposition
13:32:07 <palomer> sweet
13:32:12 <ihope> :-)
13:32:28 <SamB> how do you do such things as write libraries for C in Haskell?
13:32:37 <ihope> SamB: you mean FFI?
13:32:43 <davidhouse> (considering the universe has ~10^80 particles... ;) )
13:32:53 <SamB> in particular, the linking stuff
13:32:57 <ihope> Hmm... I must have overestimated.
13:33:00 <palomer> davidhouse: you forgot to count the dark matter
13:33:12 <davidhouse> well, i didn't exactly "count" them...
13:33:16 <ihope> Oh yeah, that.
13:33:19 <davidhouse> > length universe
13:33:20 <lambdabot>  Not in scope: `universe'
13:33:29 <alar> palomer: dark matter is on the dark side of The force
13:33:31 <ihope> I'd like to turn the universe into a Bigger Place.
13:33:40 <SamB> you need to build it first
13:33:48 <palomer> I wish the universe was more inclusive
13:33:49 <SamB> and then import the module
13:33:59 <davidhouse> @index universe
13:34:00 <lambdabot> bzzt
13:34:07 <davidhouse> which module defines the universe?
13:34:14 <palomer> IO
13:34:16 <alar> Prelude.IO
13:34:54 <palomer> my supervisor was spewing crap of the form "theory is useful" and "all programming languages are equal"
13:34:54 <davidhouse> i heard it was a hakell rewrite of a 500,000-line C library which was just a map with some filtering.
13:34:54 <ihope> So unsafePerformIO is omnipotent?
13:34:59 <palomer> really made me mad
13:35:27 <davidhouse> > haskell == c
13:35:28 <lambdabot>  Not in scope: `c'
13:35:34 <palomer> @type haskell
13:35:35 <lambdabot> Not in scope: `haskell'
13:35:40 <davidhouse> damn straight, lambdabot.
13:35:46 <ihope> If there are x particles in the universe, there are actually 2**x particles in the universe.
13:36:28 <ihope> So... I think that means that there aren't x particles in the universe.
13:36:39 <davidhouse> ihope: that's a shame. as that means there's either an infinite amount of particles or 0 in the universe.
13:36:48 <ihope> > 2**0
13:36:49 <lambdabot> 1.0
13:36:52 <ihope> > 2**1
13:36:53 <lambdabot> 2.0
13:37:03 <ihope> > iterate (2**) 0
13:37:04 <lambdabot> [0.0,1.0,2.0,4.0,16.0,65536.0,Infinity,Infinity,Infinity,Infinity,
13:37:04 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:04 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:04 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:04 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:06 <lambdabot> [24 @more lines]
13:37:11 <ihope> That means it's infinity.
13:37:23 <davidhouse> iterate (2**) (1/2)
13:37:31 <ihope> (I didn't know 2^65536 was infinite.)
13:37:31 <davidhouse> > iterate (2**) (1/2)
13:37:31 <lambdabot> [0.5,1.4142135623730951,2.665144142690225,6.342906794358192,81.171805264480
13:37:31 <lambdabot> 35,2.723630486928073e24,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:31 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:31 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:31 <lambdabot> Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,
13:37:33 <SamB> so, anyway, what flags do you use to build a program with no "module Main" and no main()?
13:37:34 <lambdabot> [24 @more lines]
13:37:52 <davidhouse> oh, nuts. ignore my "or 0" one.
13:38:04 <ihope> The universe is big, then.
13:38:21 <mpercossi> Hello I have a matrix structure that in monadic code encloses a STUArray s Int Double, and I'd like to be able to convert it to a structure enclosing a UArray Int Double. e.g.
13:38:23 <mpercossi> type MBlock s = STUArray s Int Double
13:38:23 <mpercossi> data MMatrix s = MMatrix Int Int (MBlock s)
13:38:23 <mpercossi> type Block = UArray Int Double
13:38:23 <mpercossi> data Matrix = Matrix Int Int Block
13:38:26 <mpercossi> n
13:38:30 <davidhouse> "fairly sizeable" is what i'd call it
13:38:47 <mpercossi> how can I make the equivalent of runSTUArray, but for matrices?
13:39:28 <mpercossi> the signature would be: runSTMatrix :: (forall s . ST s (MMatrix s)) -> Matrix
13:39:38 <ihope> @hoogle (forall s . ST s (MMatrix s)) -> Matrix
13:39:38 <lambdabot> hoogle: Unexpected character when parsing: . ST s (MMatrix s)) ->
13:39:38 <lambdabot> Matrix
13:39:38 <lambdabot>  
13:39:56 <mpercossi> what?
13:40:04 <SamB> ihope: silly
13:40:09 <mpercossi> ok
13:40:19 <mpercossi> seriously though, has anyone ever tried to do this?
13:40:34 <mpercossi> it seems like a sensible approach: monads let me do any updating operations on matrices,
13:40:39 <wagle> do what? (i just got here)
13:40:50 <mpercossi> but then I get everything out of a monad to be able to print in IO
13:41:04 <mpercossi> (sorry if I sound naive -- just learning haskell)
13:41:39 <mpercossi> Sorry wagle: I've defined a monadic, and non-monadic matrix class based on UArray
13:42:10 <mpercossi> I'd like to be able to do some monadic code on my matrix structure around STUArray s
13:42:23 <wagle> why the existential type s?
13:42:25 <mpercossi> and convert it to a matrix structure around UArray Int Double
13:42:51 <mpercossi> Well actually  defn is type MBlock s = STUArray s Int Double
13:42:51 <mpercossi> data MMatrix s = MMatrix Int Int (MBlock s)
13:43:11 <mpercossi> and I want to do some monadic code, and get something of the following type:
13:43:15 <mpercossi> type Block = UArray Int Double
13:43:15 <mpercossi> data Matrix = Matrix Int Int Block
13:43:21 <mpercossi> do you see what I mean?
13:43:32 <wagle> i dont know UArray
13:43:38 <mpercossi> ah ok. too bad
13:43:42 <mpercossi> anyone else?
13:43:49 <wagle> dont mind me..
13:43:57 * wagle gets back to work
13:54:05 <jethr0_> SamB: have you seen "http://www.hevanet.com/cristofd/brainfuck/dbfi.b"? it's a brainf*ck interpreter in BF :)
13:54:31 <ihope> :-)
13:54:43 <ihope> How about a BF interpreter in brainf*ck?
13:54:53 <TuringTest> mpercossi: Look at freeze*
13:54:56 <jethr0_> haha
13:55:19 <akemp> anyone built the darcs-GHC lately?
13:55:46 <vincenz> aloha
13:56:04 <ihope> %bleh
13:56:05 <lambdabot> Unknown command, try @listcommands.
13:56:13 <ihope> # foo
13:56:14 <lambdabot>  Not in scope: `foo'
13:56:17 <ihope> | 3+2
13:56:18 <lambdabot> 5
13:56:21 <ihope> $help
13:56:22 <lambdabot>  @help <command> - ask for help for <command>
13:56:27 <TuringTest> @type Data.Array.Base.unsafeFreeze
13:56:28 <lambdabot> forall e
13:56:28 <lambdabot>              i
13:56:28 <lambdabot>              (b :: * -> * -> *)
13:56:28 <lambdabot>              (m :: * -> *)
13:56:28 <lambdabot>              (a :: * -> * -> *).
13:56:30 <lambdabot> [4 @more lines]
13:56:31 <jethr0_> ihope: you're such a spammer :)
13:56:35 <TuringTest> @more
13:56:35 <lambdabot>            (Data.Array.Base.IArray b e,
13:56:35 <lambdabot>            Data.Array.Base.MArray a e m,
13:56:36 <lambdabot>            GHC.Arr.Ix i) =>
13:56:38 <lambdabot>            a i e -> m (b i e)
13:56:39 <ihope> :-)
13:56:47 <ihope> %-)
13:56:48 <lambdabot> Maybe you meant: . id pl wn
13:57:01 <jethr0_> |-)
13:57:03 <ihope> @help wn
13:57:03 <lambdabot> I perform dictionary lookups via the following 13 commands:
13:57:03 <lambdabot>  @all-dicts .. Query all databases on dict.org
13:57:03 <lambdabot>  @devils ..... The Devil's Dictionary
13:57:03 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
13:57:03 <lambdabot>  @elements ... Elements database
13:57:06 <lambdabot> [9 @more lines]
13:57:07 <TuringTest> mpercossi: Data.Array.Base.unsafeFreeze can turn an MArray into an IArray for you
13:57:13 <ihope> @wn meh
13:57:15 <lambdabot> No match for "meh".
13:58:43 <davidhouse> @wn sausage
13:58:44 <TuringTest> mpercossi: Data.Array.MArray.freeze and Data.Array.MArray.unsafeFreeze
13:58:44 <lambdabot> *** "sausage" wn "WordNet (r) 2.0"
13:58:44 <lambdabot> sausage
13:58:44 <lambdabot>   n 1: highly seasoned minced meat stuffed in casings
13:58:44 <lambdabot>   2: a small nonrigid airship used for observation or as a
13:58:44 <lambdabot>    barrage balloon [syn: {blimp}, {sausage balloon}]
14:01:16 <jethr0_> @wn haskell
14:01:17 <lambdabot> No match for "haskell".
14:03:54 <ihope> What Haskell function computes A001511?
14:04:30 <vincenz> ihope: "A" ++ show 0 ++ show 0 ++ show "1511"
14:04:35 <vincenz> err
14:04:37 <vincenz> ihope: "A" ++ show 0 ++ show 0 ++ show 1511
14:04:53 <ihope> > "A" ++ show 0 ++ show 0 ++ show 1511
14:04:54 <lambdabot> "A001511"
14:04:56 <ihope> Wow!
14:05:14 <vincenz> what's A001511 is the implicit question in my answer
14:05:50 <TuringTest> it is a serial number of an integer sequence
14:06:00 <TuringTest> Give use the link, ihope
14:06:06 <TuringTest> Give us the link, ihope
14:06:07 <ihope> www.google.com
14:06:15 <TuringTest> @google A001511
14:06:16 <lambdabot> http://www.research.att.com/~njas/sequences/A001511
14:06:28 <ihope> There's also A007814
14:06:51 <TuringTest> A001511 is trivial
14:06:56 <TuringTest> @google A007814
14:06:57 <lambdabot> http://www.research.att.com/~njas/sequences/A007814
14:07:07 <twobitsprite> does haskell have a system for extending the syntax a la camlp4 or lisp/scheme macros?
14:07:19 <ihope> @index intersperse
14:07:20 <lambdabot> Data.List
14:07:39 <vincenz> twobitsprite: personally I find a lot less need for it i nhaskell
14:07:49 <vincenz> twobitsprite: I used to be a serious ocaml-fan, but switched over to haskell
14:07:57 <ihope> @type Data.List.intersperse
14:07:58 <lambdabot> forall a. a -> [a] -> [a]
14:08:09 <ihope> > Data.List.intersperse 0 [1..]
14:08:10 <lambdabot> [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,
14:08:10 <lambdabot> 17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,
14:08:10 <lambdabot> 0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,
14:08:10 <lambdabot> 46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,
14:08:10 <lambdabot> 0,61,0,62,0,63,0,64,0,65,0,66,0,67,0,68,0,69,0,70,0,71,0,72,0,73,0,74,0,
14:08:12 <lambdabot> [24 @more lines]
14:08:19 <twobitsprite> vincenz: I'm currently work in ocaml... but I got turned off by camlp4 (amongst other things)...
14:08:27 <vincenz> it's a mess
14:08:38 <vincenz> as well as badly documented
14:08:40 <ihope> > let sequence = 0 : intersperse 0 (map (1+) sequence) in sequence
14:08:41 <lambdabot> Exception: <<loop>>
14:08:44 <ihope> Aww.
14:08:47 <sjanssen> twobitsprite: what kind of syntax do you want to make?
14:08:48 <vincenz> the expressiveness of haskell leads to the fact that you can do a lot of stuff with just function deifnition
14:08:55 <ihope> > let sequence = 0 : intersperse 0 (map (1+) sequence) in head sequence
14:08:56 <lambdabot> 0
14:09:01 <ihope> > let sequence = 0 : intersperse 0 (map (1+) sequence) in take 2 sequence
14:09:02 <lambdabot> Exception: <<loop>>
14:09:06 <vincenz> o.O
14:09:39 <twobitsprite> vincenz: I'm specifically looking to introduce a septemvigesimal (base-27) litteral syntax... i.e. 0p4m5l2
14:10:11 <twobitsprite> ("0p" being the prefix for sep numbers (a la the "0x" of hex numbers))
14:10:12 <TuringTest> twobitsprite: There is "Template Haskell" which lets you do some meta-programming tricks.
14:10:19 <jethr0_> why 27 and not 36?
14:10:31 <twobitsprite> TuringTest: is this a sepperate language or simply a preprocessor?
14:10:48 <TuringTest> twobitsprite: It is a compiling option with GHC
14:11:13 <jethr0_> twobitsprite: it's for metaprogramming in haskell
14:11:13 <twobitsprite> TuringTest: is GHC generally the optimal implementation?
14:11:22 <vincenz> twobitsprite: it's a very big one
14:11:27 <vincenz> twobitsprite: with lots of features
14:11:29 <TuringTest> twobitsprite: For my purposes, I only use GHC
14:11:31 <vincenz> twobitsprite: and it's performant
14:11:36 <vincenz> same as TuringTest 
14:12:17 <twobitsprite> I ask because I got turned off from Scheme because of the lack of any one implementation that had "all the good features"
14:12:33 <vincenz> twobitsprite: 
14:12:38 <vincenz> twobitsprite: GHC has a lot of neato stuff
14:12:48 <ihope> :-)
14:12:49 <vincenz> like a great std lib
14:12:50 <ihope> Yep, it does.
14:12:54 <vincenz> and nice typing extensions
14:12:59 <vincenz> and a plan to implement a compiler within the language
14:13:07 <vincenz> err... I mean a compiler accessible from code
14:13:12 <TuringTest> vincenz: "great" may be pushing it.  GHC has the best current std lib.
14:13:26 <twobitsprite> vincenz: ahh... for more dynamic programs, i..e?
14:13:40 <ihope> Hmm... what's a good type representing an arroy of bits?
14:13:49 <ihope> Or, rather, an array of bytes?
14:14:01 <TuringTest> twobitsprite: If you need "eval" in Haskell you can check out hs-plugins (which also handles plugins...)
14:14:11 <TuringTest> But most people do not use "eval"
14:14:39 <vincenz> ihope: Array Int?
14:14:45 <vincenz> array Int8?
14:14:57 <ihope> @index Int8
14:14:57 <lambdabot> Data.Int, Foreign
14:15:00 <TuringTest> ihope: Foreign.Marshal.Array
14:15:11 <vincenz> TuringTest: why..what do you think is missing?
14:15:18 <ihope> TuringTest: sounds scary
14:15:21 <vincenz> not contesting, just curious
14:16:25 <TuringTest> vincenz: When making the shootout programs we discovered the HashTable is poor, and Text.Regex is very very poor.  There is no provision for handling "ASCII" strings, and we are still waiting on Fast Packed Strings.
14:16:47 <twobitsprite> what about perfomance? A lot of people say that most Haskell implementations are noticably slower than i.e. ocaml, but I've heard people saying that this has been improving recently...
14:17:06 <TuringTest> vincenz: There are many binary IO libs that people have written because the std lib is too spare.
14:17:18 <TuringTest> twobitsprite: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
14:17:34 <vincenz> TuringTest: ah yes
14:17:38 <vincenz> binary libs sadly are lacking :/
14:17:47 <vincenz> I was hoping for a good one
14:17:53 <vincenz> to read in a custom binary data that I have
14:17:54 <TuringTest> vincenz: Both binary and ASCII....wtf were people thinking?
14:18:12 <TuringTest> But we have Parsec...weird.
14:18:23 <vincenz> TuringTest: ascii?
14:18:37 <vincenz> TuringTest: I guess haskell people are more interested in highlevel stuff than bitfucking
14:18:38 <TuringTest> Much of the world is not Unicode.  Making it Unicode hurts performance.
14:18:43 <vincenz> though bitfucking can be very useful
14:18:51 <vincenz> TuringTest: Char is by default unicode????
14:18:53 <twobitsprite> TuringTest: right... so GHC is really good at little example bits of code... what about large applications? does GHC do any, i.e., whole program flow analysis optimizing?
14:18:57 <TuringTest> vincenz: Of course.
14:19:00 <vincenz> doh
14:19:02 <TuringTest> It is always Unicode
14:19:06 <TuringTest> > maxBound :: Char
14:19:07 <lambdabot> '\1114111'
14:19:08 <vincenz> twobitsprite: it's fast
14:19:13 <vincenz> twobitsprite: have you checked latest shootouts?
14:19:21 <ihope> Oh, right. unsafeCompile :: IO a -> Foreign.Marshal.Array
14:19:23 <twobitsprite> vincenz: that's what I was just responding too...
14:19:26 <ihope> Or something like that.
14:19:32 <ihope> > '\1114112
14:19:32 <lambdabot>  lexical error in string/character literal
14:19:33 <vincenz> twobitsprite: GHC optimizes stuff pretty well?  Even uses such things that are not in ocaml, like deforestation
14:19:35 <ihope> > '\1114112'
14:19:36 <lambdabot>  lexical error in string/character literal
14:19:39 <vincenz> s/?/.
14:19:42 <ihope> > '\1114111'
14:19:43 <lambdabot> '\1114111'
14:19:46 <ihope> :-)
14:19:52 <ihope> > minBound :: Char
14:19:53 <lambdabot> '\NUL'
14:19:55 <TuringTest> twobitsprite: GHC does separate compilation.  Other people are writing a JHC compiler that will do whole program compilation.
14:20:02 <vincenz> twobitsprite: and lazyness allows a whole new way of compilation
14:20:05 <vincenz> TuringTest: ocaml is also separate compilation
14:20:09 <vincenz> TuringTest: only sml does whole flow
14:20:28 <vincenz> err...sml-nj iirc
14:20:38 <twobitsprite> vincenz: well... MLton at least, I SML/NJ does seperate...
14:20:41 <vincenz> right
14:20:42 <vincenz> mlton
14:20:43 <vincenz> that's the one
14:20:45 <vincenz> bad memory
14:20:47 <TuringTest> (and Haskell beat MLton in the shootout for speed)
14:21:12 <ihope> > cycle "zapiz
14:21:13 <lambdabot>  lexical error in string/character literal
14:21:15 <ihope> > cycle "zapiz"
14:21:15 <lambdabot> "zapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapi
14:21:15 <lambdabot> zzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapi
14:21:15 <lambdabot> zzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapi
14:21:15 <lambdabot> zzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapi
14:21:15 <lambdabot> zzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapizzapi
14:21:18 <lambdabot> [23 @more lines]
14:21:22 <bolrod> ;l
14:21:48 <bolrod> > [a..z]
14:21:48 <lambdabot>  Not in scope: `z'
14:21:56 <TuringTest> twobitsprite: What kind of programs are you wanting to write?
14:21:58 <bolrod> > ['a'..'z']
14:21:59 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
14:22:02 <bolrod> ;o
14:22:14 <ihope> > ['a'..'Z']
14:22:14 <lambdabot> ""
14:22:18 <bolrod> haha
14:22:21 <bolrod> Z = a-1
14:22:22 <ihope> > ['A'..'z']
14:22:22 <lambdabot> "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
14:22:23 <bolrod> ;p
14:22:24 <vincenz> twobitsprite: To be honest... I was long an ocaml convict... Always using speed as argument.  But I couldn't use it anymore, and I was getting frustrated by the lack of typeclasses.  Then moving to haskell, I fell in love with lazyness
14:22:26 <bolrod> oh
14:22:31 <bolrod> well.. something in between..
14:22:44 <JohnMeacham> TuringTest: there is a program out there that will turn a seperatly compiled program into a single module that can be compiled at once.
14:22:45 <ihope> [\]^_`
14:22:46 <bolrod> ['z','y'..'A']
14:22:50 <bolrod> > ['z','y'..'A']
14:22:51 <lambdabot> "zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA"
14:22:53 <vincenz> JohnMeacham: for what lang?
14:22:54 <bolrod> :)
14:23:02 <bolrod> `_^]\
14:23:07 <vincenz> > reverse ":("
14:23:07 <lambdabot> "(:"
14:23:11 <bolrod> hehe
14:23:11 <TuringTest> JohnMeacham: "a program out there" is hard to google...
14:23:14 <vincenz> emotional semantics!
14:23:20 <bolrod> haha
14:23:27 <twobitsprite> TuringTest: several layered systems... first tier is a ternary computation framwork... second tier is a genetic algorithms framework using ternary computation... third is a GA for producing board position analysis algorithms for playing the game Go...
14:23:55 <TuringTest> twobitsprite: Haskell should handle those well.
14:24:01 <bolrod> > reverse ":C"
14:24:02 <lambdabot> "C:"
14:24:04 <twobitsprite> fourth is a distributed network a la SETI@Home for paralellizing the search
14:24:04 <vincenz> twobitsprite: one advantage of lazyness is that you can construct the infinite tree of all possible moves, and then recurse over it without having it all in one loop tying the creation close to the selection
14:24:18 <vincenz> twobitsprite: I suggest you read whyfp, it's light fun reading and really give syou some cool idea
14:24:22 <vincenz> @google whyfp
14:24:24 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
14:24:37 <TuringTest> twobitsprite: What is your ternary computation?  (Black stone , no Stone, white Stone) ?
14:24:45 <twobitsprite> vincenz: I'm not Go is not very well suited for tree based searches... I'm just creating a framwork for arbitrary algorithms to evolve...
14:24:49 <twobitsprite> TuringTest: yes
14:24:50 <ihope> > ";;--))
14:24:51 <lambdabot>  lexical error in string/character literal
14:24:52 <vincenz> twobitsprite: I see
14:25:11 <vincenz> twobitsprite: tbh, it interests me, keep me up to date?
14:25:21 <vincenz> twobitsprite: and talk to tromp_ he's a go expert
14:25:30 <jethr0_> haskell has a type for a kind of ternary boolean in "Maybe Bool" already
14:25:32 <mahogny> ok. gcc just crashed when I tried to install HXML. gcc wants me to send a bug report. anyone know about this?
14:25:34 <twobitsprite> vincenz: I'll keep an eye out for him
14:25:37 <TuringTest> > map (\c -> case c of ')' -> '('; ')' -> '(' ; _ -> c) ":)"
14:25:37 <lambdabot>   Warning: Pattern match(es) are overlapped
14:25:37 <lambdabot>      In a case alternative: ')' -> ...
14:25:52 <TuringTest> > map (\c -> case c of ')' -> '('; '(' -> ')' ; _ -> c) ":)"
14:25:53 <lambdabot> ":("
14:26:00 <TuringTest> > map (\c -> case c of ')' -> '('; '(' -> ')' ; _ -> c) ":("
14:26:01 <bolrod> pff
14:26:01 <lambdabot> ":)"
14:26:08 <vincenz> > reverse "):"
14:26:09 <lambdabot> ":)"
14:26:37 <TuringTest> twobitsprite: http://haskell.org/hawiki/HaskellGoPeople 
14:26:45 <jethr0_> twobitsprite: i started writing a _very_ naive go game (without computer algo) once and found out that storing stones wasn't even necessary. i think one would get along very well with storing just groups
14:26:46 <vincenz> twobitsprite: out of curiousity what sort of data structures were yo thinking of using in ocaml for the problem?
14:26:46 <twobitsprite> TuringTest: oooh :)
14:26:47 <bolrod> > ['a'..100]
14:26:48 <lambdabot>  add an instance declaration for (Num Char)
14:26:48 <lambdabot>   In an arithmetic sequence: ['a' .. 100]
14:26:48 <lambdabot>   In the definition of `tmw': tmw = ['a' .. 100]
14:26:58 <bolrod> > ['a'..'9']
14:26:59 <lambdabot> ""
14:27:03 <bolrod> > ['A'..'9']
14:27:04 <lambdabot> ""
14:27:12 <TuringTest> twobitsprite: Note that I am not a go player.
14:27:14 <bolrod> > ['0'..'A']]
14:27:15 <lambdabot>  parse error on input `]'
14:27:17 <bolrod> > ['0'..'A']
14:27:18 <lambdabot> "0123456789:;<=>?@A"
14:27:31 <bolrod> hrm.. now where are the parenthesis
14:28:05 <vincenz> > "bolrod" >>= \x ->  replicate (fromEnum x) x
14:28:06 <lambdabot> "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
14:28:06 <lambdabot> bbbbbbbbbbbbbbbbbbbbbbbbooooooooooooooooooooooooooooooooooooooooooooooooooo
14:28:06 <lambdabot> oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooolllllllllllllll
14:28:06 <lambdabot> lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll
14:28:06 <lambdabot> llllllllllllllllllrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
14:28:07 <twobitsprite> jethr0_: right... I've thought of this... but again, this isn't going to be an expert system... i.e. my program is going to know basically nothing about the game, other than what happens to the board when a stone is place (capturing, ko, etc)... the real smarts are going to evolve from randomly generate algorithms...
14:28:08 <lambdabot> [4 @more lines]
14:28:11 <TuringTest> > ['\NUL'..'A']
14:28:11 <lambdabot> "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\
14:28:12 <lambdabot> SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@A"
14:28:19 <vincenz> > "bolrod" >>= \x ->  replicate (fromEnum x - fromEnum 'a' + 1) x
14:28:20 <ihope> > [' '..'~']
14:28:20 <lambdabot> "bbooooooooooooooollllllllllllrrrrrrrrrrrrrrrrrrooooooooooooooodddd"
14:28:21 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`
14:28:21 <lambdabot> abcdefghijklmnopqrstuvwxyz{|}~"
14:28:32 * twobitsprite wishes people would stop spamming the bot... :(
14:28:35 <ihope> > succ '~'
14:28:36 <lambdabot> '\DEL'
14:28:40 <bolrod> :)
14:28:57 <vincenz> twobitsprite: you sure you want to use a GA?  the searchspace is HUGE
14:29:06 <vincenz> twobitsprite: and what will the input be for generated GA results?
14:29:15 <TuringTest> twobitsprite:  http://catb.org/~esr/jargon/html/koans.html "Sussman attains enlightenment"
14:29:18 <vincenz> will they be functions that eval a current board or whole game only?
14:29:27 <twobitsprite> vincenz: the Go search space is huge :P
14:29:51 <twobitsprite> vincenz: besides... that's why I'm going with a massively distributed model, a la SETI@Home... I even plan to have a screensaver :)
14:30:11 <jethr0_> twobitsprite: from what i've read genetic algorithms are hard to use for go, because they won't always explore the whole domain space, and get stuck in sub-optimal local maxima (for games with a big branching factor like go, that is)
14:30:21 <twobitsprite> I'm young... I have plenty of time to wait for a meaningful solution :)
14:30:37 <davidhouse> > succ $ succ '~'
14:30:38 <lambdabot> '\128'
14:30:41 <wagle> you sure that you are only off by a factor of 10^6?
14:30:48 <mahogny> twobitsprite, how will you map into phenotypes?
14:30:50 <bolrod> > map (-1) ");)
14:30:50 <lambdabot>  lexical error in string/character literal
14:30:52 <twobitsprite> jethr0_: you can overcome that by having higher rates of mutation....
14:30:53 <bolrod> > map (-1) ");"
14:30:54 <lambdabot>  add an instance declaration for (Num (Char -> b))
14:30:58 <bolrod> ;o
14:31:02 <wagle> (computing power)
14:31:07 <bolrod> > 'b'-1
14:31:08 <lambdabot>  add an instance declaration for (Num Char)
14:31:14 <vincenz> twobitsprite: right but what will the output be? programs that can play go, or whole-games?
14:31:16 <bolrod> > 'b'-1::Char
14:31:16 <lambdabot>  add an instance declaration for (Num Char)
14:31:35 <vincenz> whole-games will most likely require more storage, programs that can play go will require proper semantics in the bits that are part of the genes
14:31:50 <jethr0_> twobitsprite: it's a cool project, but i'm not convinced that it's very feasible. there have been approaches with neural nets AFAIK and people started adding domain knowledge very soon (alive-ness, eyes, local pattern matching, ...)
14:31:53 <ihope> > fromEnum (toEnum 'b' - 1)
14:31:54 <lambdabot> Couldn't match `Int' against `Char'
14:32:02 <jethr0_> and a depth cut-off is _very_ bad for ladders, too
14:32:03 <mahogny> twobitsprite, just a hint from own experience; for this kind of problem, you *need* smeared out maps to the phenotypes. in particular, you want a very indirect map
14:32:09 <ihope> > toEnum (fromEnum 'b' - 1) :: Int
14:32:10 <lambdabot> 97
14:32:13 <twobitsprite> mahogny: well... the algorithms are going to be in a sort of "assembly"... i.e. a series of primative instruction mutating a global memory space... I simply plan to do segment swapping for mating and randomizing for mutation... one does not necessarily need an abstract phenotype....
14:32:14 <ihope> Uh.
14:32:19 <ihope> > toEnum (fromEnum 'b' - 1) :: Char
14:32:20 <lambdabot> 'a'
14:32:30 <vincenz> twobitsprite: oy
14:32:37 <vincenz> twobitsprite: you'll have a LOT of assembly code that is meaningless
14:32:47 <vincenz> twobitsprite: I thought about doing that for a different problem domain
14:32:52 <jethr0_> mahogny: yes, but you might also want to use symmetries, and combining the two seems hard
14:33:02 <vincenz> twobitsprite: but even the concept of making it calculate sqrt seemed to reslt in a huge search space with a lot of code that's meaningless
14:33:03 <bolrod> > map (chr.(-1).ord) ");"
14:33:04 <lambdabot>  add an instance declaration for (Num (Int -> Int))
14:33:14 <bolrod> ...
14:33:20 <mahogny> jethr0_, not really. in fact, there are maps that are especially made to have fast convergence for symmetries
14:33:49 <bolrod> > chr.(-1).ord $ 'a'
14:33:49 <lambdabot>  add an instance declaration for (Num (Int -> Int))
14:33:57 <jethr0_> hmm, interesting. i thought you meant a "random" projection from the genotypes
14:34:01 <mahogny> twobitsprite, I kind of doubt assembly. but try it. have a look at Amoeba, Tierra and Avida. they might give some hints on how to get good convergence
14:34:15 <twobitsprite> mahogny: I'll look them up, thanks
14:34:33 * vincenz wants something like spore
14:34:36 <vincenz> :D
14:34:46 <vincenz> maybe s-pure
14:34:52 <mahogny> twobitsprite, I have written my own version of Amoeba in haskell but it still has some bugs. you might try and ask me later if you're interested
14:35:06 <vincenz> mahogny: ooh, interesting :)
14:35:07 <twobitsprite> I could also optomize by occasionally search algorithms for unreachable code...
14:35:24 <vincenz> mahogny: what is it?
14:35:38 <mahogny> vincenz, simulation of prebiotic evolution
14:35:41 <vincenz> twobitsprite: the other problem is that you'll need a LOT of seeds
14:35:49 <mahogny> vincenz, it shows how life can arise from nothing
14:35:53 <vincenz> mahogny: sadly it's an ungoogable term... have a link?
14:36:02 <vincenz> mahogny: and that's one of my main fields of personal interests and would love a look
14:36:14 <mahogny> vincenz, hm. got access to physica D etc?
14:36:18 <twobitsprite> vincenz: each "client" (or computer running the screensaver) will generate half thier population randomly, and retrieve the other half from the network...
14:36:48 <mahogny> vincenz, the author is called A Pargellis
14:37:04 <wagle> adami's text on artificial life might have a webpage..  also alife.edu
14:37:04 <twobitsprite> and after so many rounds of competition, the top 10-or-so percent will propogate to other clients vie the network...
14:37:08 <mahogny> vincenz, he has written several papers on Amoeba. the source is hard to get though. there is a version... in french, somewhere :P
14:37:17 <vincenz> mahogny: and the haskell thingy?
14:37:23 <mahogny> vincenz, on my disk :)
14:37:29 <jethr0_> twobitsprite: have you calculated how long that will take. i recently calculated how long chess exhaustion would take and even using millions of computers in parallel makes only a minute dent in the number. this is obviously different from a genetic approach, but go also has a _huge_ branching factor...
14:37:32 <vincenz> mahogny: GPLd?
14:37:41 <palomer> does darcs completely overwrite a repository when using darcs put?
14:37:48 <mahogny> vincenz, but read the papers. mine isn't very well documented and you don't see much in it yet (=nothing). public domain
14:38:03 <mahogny> vincenz, Avida might be a better start. it got a gui
14:38:04 <wagle> http://www.santafe.edu/
14:38:25 <vincenz> mahogny: okies
14:38:28 <vincenz> mahogny: thx
14:38:28 <jethr0_> twobitsprite: the problem with genetic approaches is that they will soon get stuck in local minima. AFAIK vector support machines (though more complex and maybe slower) partially solve this problem
14:38:32 <mahogny> vincenz, np
14:38:59 <wagle> i'm not finding the alife site
14:39:10 <mahogny> jethr0_, so far, I'd say the opposite. a good GA is the best way to avoid local minimas and they spank the heck of most other methods
14:39:21 <twobitsprite> jethr0_: again, the branching factor in a game is irrelevant to this application for several reasons: a) go itself can be viewed as several smaller intependant games occuring in parallel (with occasional overlappings towards the middle and end-games) b) go is very pettern based... some of the strongest go programs use mostly a pattern database as opposed to tree searching
14:39:25 <mahogny> jethr0_, it depends on population size of course
14:41:08 <jethr0_> twobitsprite: yes, but i've read that branching factor works against genetic approaches. supposedly tdgammon worked so amazingly well, because the uncertainty of throwing dice made the neural network go into all possibilities at some point.
14:41:23 <twobitsprite> I figure GNU Go as a whole application takes up about 10MB or so (haven't actually looked in a while, but it's on that order) so if I have each algorithm be about 5MB each, I can assume that these algorithms will optomize past the efficiency of GNU Go and at least approach GNU Go in strength
14:41:40 <jethr0_> huh???
14:41:50 <mahogny> jethr0_, what learning method did they use? back propagation?
14:41:53 <jethr0_> you're not really planning to evolve a 5mb program with genetic algorithms, are you??
14:41:56 <vincenz> mahogny: I'd love a look at the implementation however
14:41:58 <JohnMeacham> TuringTest: I think it is called 'moduleinone' or 'allinone' or something like that.
14:42:07 <TuringTest> JohnMeacham: thanks
14:42:25 <twobitsprite> jethr0_: I'm not certain, I'm still mostly in preliminary investigation phase... would you recommend smaller algorithms?
14:42:31 <jethr0_> mahogny: time differential
14:42:32 <ihope> @index beep
14:42:33 <lambdabot> bzzt
14:42:37 <jethr0_> YES
14:42:53 <ihope> beep = putChar '\a
14:42:54 <JohnMeacham> http://www.isi.edu/~hdaume/HAllInOne/index.html
14:43:01 <ihope> That is, '\a'
14:43:01 <andrew_p> that's still me :) equality is represented by '==' in haskell, right?
14:43:19 <twobitsprite> jethr0_: keep in mind that not all of the size is pure algorithm... the algorithm will exist within the mutable memory space and thus most of it could potentially evolve into a pattern database of sorts...
14:43:38 <ihope> > 3 == 3
14:43:39 <lambdabot> True
14:43:40 <ihope> > 3 == 2
14:43:41 <lambdabot> False
14:43:46 <ihope> ;-)
14:44:00 <jethr0_> twobitsprite: i am _extremely_ doubtful whether such a huge program could evolve into anything sensible within a reasonable time frame
14:44:09 <mahogny> vincenz, http://www.tfd.chalmers.se/~johen/amoebaj/
14:44:24 <vincenz> thankies
14:44:26 <mahogny> vincenz, with reservations for todos and bugs :)
14:44:30 <jethr0_> evolving algorithms of a few bytes is hard already. crossing several MB algorithms is a sure way of getting garbage, IMO
14:44:37 <twobitsprite> jethr0_: perhaps the size of the program could evolve to... algorithms could expand and shrink, thus evolving optimal size
14:44:40 <mahogny> vincenz, you have my docs there as well as one of the original papers
14:44:40 <vincenz> mahogny: couldn't darcs it could ya?
14:44:48 <vincenz> :P
14:45:00 <jethr0_> twobitsprite: i think you should start with something much simpler
14:45:10 <mahogny> vincenz, ugh. I'm too old to know that kind of stuff lol. would have to read up
14:45:19 <mahogny> vincenz, need it darcsed?
14:45:24 <palomer> is there a book on design patterns with lazy evaluation?
14:45:28 <twobitsprite> jethr0_: these are just the thoughts in my head... I definately plan to work my way up to these as I continue to research the domain
14:45:32 <jethr0_> like an evolving algorithm for othello. the branching factor is a fraction of go's, but it's still not trivial
14:45:48 <vincenz> mahogny: nah, wget worked :)
14:46:00 <vincenz> thx!
14:46:05 <vincenz> I'll take a look at it tomorrow when It's not so late
14:46:46 <twobitsprite> jethr0_: well... I program mostly for my own amusement, so I'll just play with it
14:50:26 <ihope> > let x = "{-------"; y = "--------"; z = "-------}" in length (x ++ y ++ z)
14:50:27 <lambdabot> 24
14:50:44 <ihope> > let x = "{-------"; y = "--------"; z = "-------}" in length (x ++ y ++ z ++ x ++ y ++ y ++ y ++ y ++ y ++ z)
14:50:45 <lambdabot> 80
14:50:51 <ihope> > let x = "{-------"; y = "--------"; z = "-------}" in x ++ y ++ z ++ x ++ y ++ y ++ y ++ y ++ y ++ z
14:50:51 <lambdabot> "{----------------------}{------------------------------------------------
14:50:51 <lambdabot> ------}"
14:51:38 <jethr0_> spam spam spam
14:52:52 <ihope> > (unwords . repeat) "spam"
14:52:53 <lambdabot> "spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:52:53 <lambdabot> spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:52:53 <lambdabot> spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:52:53 <lambdabot> spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:52:53 <lambdabot> spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:52:55 <lambdabot> [25 @more lines]
14:53:00 * jethr0_ sighs
14:56:13 <vincenz> ihope: ever tried /msg lambdabot ?
14:56:40 <ihope> (unwords . intersperse "spam" . cycle) ["egg", "bacon", "sausage", "tomato", "baked beans"]
14:56:51 <bolrod> tell me why this works
14:56:57 <bolrod> > chr 'a' -1
14:56:58 <lambdabot> Couldn't match `Int' against `Char'
14:57:03 <bolrod> urg
14:57:05 <bolrod> what was it
14:57:10 <vincenz> > fromEnum 'a' -1
14:57:11 <lambdabot> 96
14:57:13 <bolrod> > ord 'a' -1
14:57:14 <lambdabot> 96
14:57:17 <bolrod> but this
14:57:22 <bolrod> >(-1)  ord 'a' 
14:57:26 <bolrod> > (-1)  ord 'a' 
14:57:26 <lambdabot>  add an instance declaration for (Num ((Char -> Int) -> Char -> a))
14:57:27 <vincenz> > let foobar = ord in foobar 'a' - 1
14:57:27 <lambdabot> 96
14:57:27 <bolrod> doesn't
14:57:37 <vincenz> bolrod: -1 isn't a fucntion
14:57:43 <vincenz> it's a special case
14:57:45 <bolrod> it isn't?
14:57:47 <vincenz> it's a negative integer
14:57:52 <bolrod> grr
14:57:53 <vincenz> > (+1) ord 'a'
14:57:54 <lambdabot>  add an instance declaration for (Num (Char -> Int))
14:57:58 <bolrod> ok.....
14:57:59 <vincenz> > (+1) $ ord 'a'
14:58:00 <lambdabot> 98
14:58:02 <bolrod> weird
14:58:02 <vincenz> > (- 1) $ ord 'a'
14:58:03 <lambdabot>  add an instance declaration for (Num (Int -> b))
14:58:11 <bolrod> ahhhh
14:58:17 <vincenz> > (flip (-) 1) $ ord 'a'
14:58:18 <bolrod> wait..
14:58:18 <lambdabot> 96
14:58:27 <ihope> > subtract
14:58:28 <lambdabot>  add an instance declaration for (Show (a -> a -> a))
14:58:30 <bolrod> > (-1) (ord 'a')
14:58:30 <ihope> > subtract 3 2
14:58:30 <lambdabot>  add an instance declaration for (Num (Int -> a))
14:58:31 <lambdabot> -1
14:58:39 <bolrod> > ((-)1) (ord 'a')
14:58:40 <lambdabot> -96
14:58:48 <bolrod> no you f00l
14:58:50 <bolrod> 96!
14:59:06 <bolrod> > (`-`1) (ord 'a')
14:59:07 <lambdabot>  parse error on input `-'
14:59:11 <bolrod> > (`(-)`1) (ord 'a')
14:59:12 <lambdabot>  parse error on input `('
14:59:26 <bolrod> hmm
14:59:34 <bolrod> > ((+)-1) (ord 'a')
14:59:34 <lambdabot>  add an instance declaration for (Show (Int -> Int))
14:59:42 <bolrod> > ((+)(-1)) (ord 'a')
14:59:43 <lambdabot> 96
14:59:45 <bolrod> YES
14:59:47 <bolrod> \o/
14:59:48 <lambdabot> Maybe you meant: . id pl wn yow
14:59:55 <ihope> :-)
14:59:55 <bolrod> omg..  -,-
14:59:56 <vincenz> \o/
14:59:56 <lambdabot> Maybe you meant: . id pl wn yow
14:59:59 <vincenz> oh no
15:00:01 <ihope> \o/
15:00:01 <lambdabot> Maybe you meant: . id pl wn yow
15:00:03 <vincenz> \ for commands
15:00:03 <vincenz> doh
15:00:04 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
15:00:04 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
15:00:04 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
15:00:04 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
15:00:04 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
15:00:05 <lambdabot> [8 @more lines]
15:00:07 <bolrod>  \o/
15:00:11 <bolrod> thets bettah
15:00:15 <vincenz> >\o/
15:00:15 <bolrod> o//
15:00:18 <vincenz> \\o
15:00:18 <bolrod> \\o
15:00:19 <lambdabot> Maybe you meant: . id pl wn yow
15:00:19 <lambdabot> Maybe you meant: . id pl wn yow
15:00:21 <vincenz> lol
15:00:23 <bolrod> 8)
15:00:26 <vincenz> stick figures look so cute
15:00:32 <vincenz> reminds me of xiaoxiao
15:00:34 <bolrod> yeah :)
15:00:36 <bolrod> (o/
15:00:39 <bolrod> \o)
15:00:39 <lambdabot> Maybe you meant: . id pl wn yow
15:00:43 <bolrod> <o)
15:00:46 <bolrod> (o>
15:00:48 <vincenz> (o/ is like "hey you all, come this way" (to the right)
15:00:52 <ihope> vincenz: ever tried /msg lambdabot ?
15:00:57 <bolrod> :D
15:01:12 <bolrod> <o/   aye aye 'captn'
15:01:13 <vincenz> Join #meta-science for spammy fruitless discussions or philosophy talks
15:01:26 <vincenz> .o| (that one coudl be taken as nazi )
15:01:34 <bolrod> :)
15:01:52 <bolrod> -o,  <-- stick figure from top view
15:01:58 <bolrod> .o-
15:02:08 <bolrod> :)
15:03:07 <bolrod> > map (chr.((+)(-1)).ord) ");"
15:03:08 <lambdabot> "(:"
15:03:13 <bolrod> hehe :x
15:03:31 <ihope> > map pred ");
15:03:31 <lambdabot>  lexical error in string/character literal
15:03:33 <ihope> > map pred ");"
15:03:34 <lambdabot> "(:"
15:03:39 <ihope> > map pred "Muahaha"
15:03:40 <lambdabot> "Lt`g`g`"
15:03:49 <vincenz> > map succ "candy"
15:03:50 <lambdabot> "dboez"
15:04:04 <ihope> > map succ 
15:04:04 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
15:04:10 <ihope> > map succ "An unbreakable code!"
15:04:11 <lambdabot> "Bo!vocsfblbcmf!dpef\""
15:04:11 <bolrod> thats not cool...  (chr.((+)(-1)).ord)  looks much cooler
15:04:14 <bolrod> :P
15:04:21 <ihope> > map pred "Bo!vocsfblbcmf!dpef\""
15:04:22 <lambdabot> "An unbreakable code!"
15:04:33 <vincenz> that's caesar code
15:04:36 <vincenz> the oldest inthe book!
15:04:48 <vincenz> this one is much better
15:04:56 <vincenz> > map (succ.pred) "Unbreakable!"
15:04:57 <lambdabot> "Unbreakable!"
15:05:00 <ihope> > reverse "An unbreakable code!"
15:05:01 <lambdabot> "!edoc elbakaerbnu nA"
15:05:34 <mathrick> > map (+13) "Secret"
15:05:34 <lambdabot>  add an instance declaration for (Num Char)
15:05:42 <bolrod> > map (chr.((+)a).ord) "An unbraakable code"
15:05:43 <lambdabot>  Not in scope: `a'
15:06:00 <mahogny> > sort "an unbreakable code"
15:06:01 <lambdabot> "  aaabbcdeeeklnnoru"
15:06:06 <TuringTest> > map (foldr (.) (replicate 13 succ)) "a"
15:06:06 <mahogny> maybe a bit hard to reverse
15:06:07 <lambdabot> Couldn't match `a -> c' against `[a1]'
15:06:12 <mathrick> > map (chr . (+13) . ord) "Secret"
15:06:12 <lambdabot> "`rp\DELr\129"
15:06:18 <ihope> > map (succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ" "Secret"
15:06:18 <lambdabot>  lexical error in string/character literal
15:06:24 <mathrick> that doesn't look like rot13
15:06:24 <ihope> > map (succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ . succ) "Secret"
15:06:24 <mahogny> but then you could also do RLE and get really nice compression :)
15:06:26 <lambdabot> "`rp\DELr\129"
15:06:30 <TuringTest> map (foldr1 (.) (replicate 13 succ)) "a"
15:06:36 <TuringTest> > map (foldr1 (.) (replicate 13 succ)) "a"
15:06:36 <lambdabot> "n"
15:06:37 <ihope> mahogny: what's that?
15:07:00 <lscd> mathrick: your characters are getting too high - you need to mod ord(z) them
15:07:05 <mathrick> > chr . (+13) . ord 'S'
15:07:05 <lambdabot> Couldn't match `Int' against `t -> t1'
15:07:10 <mahogny> ihope, run length compression. you store sequences as [(letter, number of it)]
15:07:10 <mathrick> lscd: ah, right
15:07:19 <mathrick> > (chr . (+13) . ord) 'S'
15:07:20 <lambdabot> '`'
15:07:25 <ihope> Ah.
15:07:28 <bolrod> > map (chr.((+)(untill (==ord) (+1) 1).ord) "An unbraakable code" 
15:07:28 <lambdabot>  parse error on input `}'
15:07:28 <mahogny> ihope, used in PCX among other
15:07:46 <mathrick> > (chr . (mod ord(z) . (+13) . ord) 'S'
15:07:46 <lambdabot>  parse error on input `}'
15:07:52 <mathrick> > (chr . (mod ord(z)) . (+13) . ord) 'S'
15:07:52 <lambdabot>  Not in scope: `z'
15:08:00 <mathrick> > (chr . (mod ord('z')) . (+13) . ord) 'S'
15:08:00 <lambdabot> Couldn't match `Char -> Int' against `Char'
15:08:03 <bolrod> > map (chr.((+)(untill (==ord) (+1) 1)).ord) "An unbraakable code" 
15:08:03 <lambdabot>  Not in scope: `untill'
15:08:09 <bolrod> > map (chr.((+)(until (==ord) (+1) 1)).ord) "An unbraakable code" 
15:08:10 <lambdabot> Couldn't match `Char -> Int' against `Int'
15:08:33 <mathrick> > 100 mod ord('z')
15:08:34 <lambdabot>   add an instance declaration for (Num ((a -> a -> a)
15:08:34 <lambdabot>                -> (Char -> Int)
15:08:34 <lambdabot>                -> Char
15:08:44 <mathrick> ?
15:08:52 <mathrick> > 100 `mod` ord('z')
15:08:53 <lambdabot> 100
15:08:59 <mathrick> > (chr . (`mod` ord('z')) . (+13) . ord) 'S'
15:09:00 <lambdabot> '`'
15:09:01 <jethr0_> rot13 implies modulo 26
15:09:09 <mathrick> > (chr . (`mod` 26) . (+13) . ord) 'S'
15:09:10 <lambdabot> '\DC2'
15:09:13 <mathrick> jethr0_: right
15:09:21 <jethr0_> and it's only defined on a-z
15:09:29 <mathrick> mhm
15:09:33 <vincenz> oasisbot is up for spamming in an alt channel
15:09:45 <mathrick> altchannel is what?
15:09:48 <lscd> jethr0_: it's often defined on A-Z too, but.... ya
15:10:08 <mathrick> well, it's assumed to be defined analogously on A-Z
15:11:40 <vincenz> #meta-science
15:11:42 <jethr0_> ya, i guess you know what i meant :)
15:12:48 <mathrick> how do you do multiple guards inline, ie in let expression?
15:13:02 <vincenz> mathrick: ;
15:13:24 <vincenz> > let x 'a' = 'b'; x 'b' = 'c' x y = y in map x ['a'..'z']
15:13:24 <lambdabot>  parse error on input `='
15:13:29 <vincenz> > let x 'a' = 'b'; x 'b' = 'c'; x y = y in map x ['a'..'z']
15:13:30 <lambdabot> "bccdefghijklmnopqrstuvwxyz"
15:13:59 <mathrick> also, is there some builtin function "between"?
15:14:03 <jethr0_> > let f x | x == 0 = 0 | otherwise = 5 in f 3
15:14:04 <mathrick> @index between
15:14:04 <lambdabot> 5
15:14:04 <lambdabot> Text.ParserCombinators.Parsec.Combinator, Text.ParserCombinators.Parsec,
15:14:04 <lambdabot> Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
15:14:56 <jethr0_> > 3 < 4 < 6
15:14:57 <lambdabot>   precedence parsing error
15:14:57 <lambdabot>    cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix
15:14:57 <lambdabot> expression
15:15:13 <ihope> > (3 < 4) && (4 < 6)
15:15:14 <lambdabot> True
15:15:15 <davidhouse> > 3 < 4 && 4 < 5
15:15:16 <lambdabot> True
15:15:17 <jethr0_> i forgot which language that worked in. i think it was ruby
15:15:38 <mathrick> it "works" in C too :)
15:15:42 <mathrick> just doesn't do what you want
15:15:53 <jethr0_> ya, good old integer bools
15:15:56 <bolrod> :)
15:16:00 <davidhouse> > let ltChain a b c = a < b && b < c in ltChain 3 4 5
15:16:00 <lambdabot> True
15:16:14 <ihope> @fixity
15:16:15 <lambdabot> Unknown command, try @listcommands.
15:16:21 <ihope> @hoogle &&
15:16:22 <lambdabot> Data.Bool.(&&) :: Bool -> Bool -> Bool
15:16:22 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
15:16:22 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
15:16:26 <ihope> @info
15:16:26 <lambdabot> Unknown command, try @listcommands.
15:16:28 <vincenz> > let ltChain x = and . scanl1 < x in ltChain [1,2,3]
15:16:29 <lambdabot> Couldn't match `[Bool]' against `t -> t1'
15:16:38 <vincenz> > let ltChain x = foldl1 and . scanl1 < $ x in ltChain [1,2,3]
15:16:39 <lambdabot>  parse error on input `$'
15:16:44 <vincenz> > let ltChain x = foldl1 and . scanl1 (<) $ x in ltChain [1,2,3]
15:16:45 <lambdabot> Couldn't match `Bool' against `t -> t1'
15:16:45 <jethr0_> > all $ sequence [(3<), (<6)] 4
15:16:46 <lambdabot> Couldn't match `a -> Bool' against `[a1]'
15:19:04 <jethr0> lambdabot seems kinda absent in /msg mode
15:19:10 <davidhouse> @type sequence [(3<), (<6)]
15:19:11 <lambdabot> forall a.
15:19:11 <lambdabot>          (Monad ((->) a), Ord a, Num a) =>
15:19:11 <lambdabot>          a -> [Bool]
15:19:29 <TuringTest> > let ltChain xs = and (zipWith (<) xs (tail xs)) in ltChain [1,2,3]
15:19:30 <lambdabot> True
15:19:31 <davidhouse> @type sequence
15:19:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:19:43 <mathrick> why can't I /msg lambdabot ?
15:19:51 <jethr0> me neither :(
15:19:54 <mathrick> actually, I can, but it's not very talkative there
15:19:57 <vincenz> you sure you're regged?
15:20:01 <jethr0> yes
15:20:03 <vincenz> maybe lambdabot isn't regged
15:20:10 <mathrick> ah, possible
15:20:11 <TuringTest> The and (zipWith...) version short-circuits when it sees False
15:20:14 <mathrick> I am reg'd
15:20:19 <jethr0> and you don't have to be reg'ed to talk with lambdabot
15:20:20 <stepcut> *** lambdabot is an identified user
15:20:30 <mathrick> but when I /query, it should work
15:20:43 <mathrick> --- [mathrick] is identified to services 
15:21:23 <jethr0> > and $ sequence [(3<), (<6)] 4
15:21:24 <lambdabot> True
15:21:47 <jethr0> > and $ map ($4) [(3<), (<6)]
15:21:48 <lambdabot> True
15:21:53 <mathrick> > let asd = 10
15:21:54 <lambdabot>  parse error on input `}'
15:21:59 <mathrick> buh
15:22:01 <mathrick> thought so
15:22:14 <davidhouse> @type sequence [(3<), (<6)]
15:22:15 <lambdabot> forall a.
15:22:15 <lambdabot>          (Monad ((->) a), Ord a, Num a) =>
15:22:15 <lambdabot>          a -> [Bool]
15:22:18 <jethr0> we're not in ghci :)
15:22:37 <davidhouse> how is (->) 4 a monad?
15:22:49 <davidhouse> or (->) Int even
15:22:50 <jethr0> (e->) has always been a monad :)
15:22:56 <davidhouse> oh?
15:23:21 <TuringTest> jethr0: You have to import Control.Monad.Reader
15:23:24 <TuringTest> (I thought)
15:23:26 <jethr0> > liftM2 (&&) even odd 4
15:23:27 <lambdabot> False
15:24:10 <jethr0> TuringTest: i don't know about that
15:24:19 <TuringTest> e
15:24:20 <TuringTest> eh
15:24:23 <davidhouse> @type even
15:24:24 <lambdabot> forall a. (Integral a) => a -> Bool
15:24:38 <davidhouse> @type liftM2
15:24:39 <lambdabot> Not in scope: `liftM2'
15:24:48 <davidhouse> @type Control.Monad,liftM2
15:24:48 <lambdabot> parse error on input `,'
15:24:51 <davidhouse> @type Control.Monad.liftM2
15:24:52 <lambdabot> forall r (m :: * -> *) a2 a1.
15:24:52 <lambdabot>         (Monad m) =>
15:24:52 <lambdabot>         (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:25:35 <davidhouse> jethr0: where's the monadic definition/explanation of how (->a) is a monad?
15:26:32 <ihope> @djinn (e -> e -> a) -> e -> a
15:26:33 <lambdabot> f a b = a b b
15:26:38 <ihope> @djinn a -> e -> a
15:26:38 <lambdabot> f a _ = a
15:26:52 <ihope> There you go.
15:26:54 <jethr0> davidhouse: i honestly don't know
15:26:58 <vincenz> lambdabot: @join #meta-science
15:26:59 <lambdabot> Not enough privileges
15:28:17 <TuringTest> @type (even >>= return
15:28:18 <lambdabot> parse error (possibly incorrect indentation)
15:28:21 <TuringTest> @type (even >>= return)
15:28:22 <lambdabot> forall a.
15:28:22 <lambdabot>        (Integral a, Monad ((->) a)) =>
15:28:22 <lambdabot>        a -> Bool
15:28:22 <mahogny> ok. I got a date in form yyyy-mm-dd. is there a sane way to get this into day of the year, 0-365?
15:28:35 <mahogny> when I say sane, I mean a one-liner
15:28:59 <bolrod> erh
15:29:00 <TuringTest> mahogny: not really...you need the full leap-year calculation
15:29:10 <mahogny> ok. I'll try something else then
15:29:13 <bolrod> its not that hard
15:29:24 <mahogny> bolrod, there were easier work-arounds :)
15:29:56 <jethr0> but it's easy to botch up the rules. it'd be better to use some kinda library for that than implement it the millionth time
15:30:22 <mahogny> yes. it oughta be in the hierarchial libraries
15:30:26 <mathrick> rules are easy, 4 - 100 - 400 :)
15:30:29 <mahogny> methinks
15:30:59 <bolrod> every 4th year yes.. then ever 100th year not.. but every 400th year it is again
15:31:08 <bolrod> so 1900 not a leap year
15:31:13 <mathrick> yup
15:31:14 <bolrod> but 2000 was 
15:31:20 <mathrick> yup
15:31:26 <mathrick> next will be 2400
15:31:32 <bolrod> ?
15:31:36 <mathrick> might not be around by then
15:31:40 <davidhouse> leapYear yr = (yr`mod`4 ==0) && ((yr`mod`100 /= 0) || (yr`mod`400 == 0))
15:31:47 <mathrick> bolrod: next year when 400 rule kicks in
15:32:02 <bolrod> ;o
15:32:04 <bolrod> yes
15:32:06 <davidhouse> > let leapYear yr = (yr`mod`4 ==0) && ((yr`mod`100 /= 0) || (yr`mod`400 == 0)) in map leapYear [1900,2000,2400]
15:32:06 <lambdabot> [False,True,True]
15:32:24 <bolrod> ...
15:32:32 <bolrod> that function does not agree
15:32:39 <mathrick> it does
15:32:39 <ihope> > let leapYear yr = (yr`mod`4 ==0) && ((yr`mod`100 /= 0) || (yr`mod`400 == 0)) in map leapYear [1900,2000,2232,2400,2579]
15:32:40 <lambdabot> [False,True,True,True,False]
15:32:40 <bolrod> yes it did
15:32:42 <bolrod> srry
15:32:44 <TuringTest> http://en.wikipedia.org/wiki/Leap_year
15:32:54 <bolrod> its late
15:32:55 <bolrod> :)
15:33:07 <jethr0> yup, still using libraries for this kinda thing seems better than implementing them every time you need'em
15:33:21 <mathrick> yes
15:33:45 <davidhouse> jethr0: is there one?
15:33:45 <TuringTest> There was a good Date library mentioned on the mailing lists recently...
15:33:53 <mahogny> how would one go if one would want to suggest this going into the stdlibs?
15:34:14 <ncalexan> Ashley Yakely (sp?) implemented one, but it doesn't seem to have gotten widespread use.
15:34:23 <TuringTest> http://semantic.org/TimeLib/ is the library
15:34:29 <ncalexan> Ja.
15:35:36 <jethr0> don't know, but there certainly should be. and as seen above it wouldn't be too long either
15:36:02 <mathrick> kan man bruge utf-8 med haskell?
15:36:51 <jethr0> i think so
15:37:12 <tic> mathrick, you should probably speak English around here. :)
15:37:34 <mathrick> tic: that was deliberate
15:37:41 <tic> Oh.
15:37:48 <mathrick> jethr0: looking at your domain, you're German, right?
15:37:54 <jethr0> > 
15:37:54 <lambdabot> <stdin>: hGetLine: end of file
15:37:58 <jethr0> > \11100010
15:37:58 <lambdabot>  parse error on input `}'
15:37:59 <davidhouse> that wasn't german.
15:38:07 <mathrick> nope
15:38:08 <mathrick> it was danish
15:38:11 <tic> then why would you speak norwegian?
15:38:14 <tic> oh, danish.
15:38:19 <mathrick> and/or norwegian
15:38:31 <jethr0> davidhouse: i think it was danish, but i live in northern germany and have spent all my summer holidays in denmark
15:38:33 <tic> some words/sentences don't differ much.
15:38:51 <davidhouse> what does 'bruge' mean?
15:38:57 <mathrick> tic: small test for language speakers in the channel? :)
15:39:08 <mathrick> davidhouse: use
15:39:08 <jethr0> in german the sentence would've been "kann man UTF-8 mit haskell gebrauchen" (more or less, at least)
15:39:19 <tic> "kan man anvnda UTF-8 med haskell?"
15:39:30 * tic uses ISO8859-1
15:39:52 <mathrick> jethr0: I was just about to ask, so it's gebrauchen in German?
15:40:02 <jethr0> people keep looking at my domain. where's my right to privacy :)
15:40:03 <mathrick> seems somewhat similar
15:40:06 <davidhouse> or something like benutzen, i'd guess.
15:40:10 <mathrick> tee hee
15:40:25 <jethr0> mathrick: well, you wouldn't say it in that context, but "gebrauchen" is one form for "use"
15:40:50 <mathrick> I see
15:41:05 <mathrick> my german learning failed pretty hard at the time
15:41:18 * palomer ponders writing a midi parsing library in C++
15:41:20 <davidhouse> it's amazing how similar german/scandanavian languages are.
15:41:55 <davidhouse> i.e., kan man bruge utf8 med haskell == kann mann utf8 mit haskell gebrauchen. the only differences are word order and bruge/gebrauchen
15:42:32 <jethr0> yup, but swedish is much harder for me to understand, if not impossible
15:42:56 <jethr0> but i guess it also has to do with me having been to denmark a lot and not to sweden
15:43:14 <davidhouse> why are so many of the people in here scandanavian? it's weird
15:43:21 <mahogny> icelandish is similar too but that's quite a nut to crack due to their isolation :)
15:43:42 <davidhouse> iceland's also nowhere near scandanavia...
15:43:44 <mahogny> davidhouse, maybe scandinavians got in general better taste in languages? :)
15:44:01 * mathrick er ikke en nordisk mænd
15:44:10 <mathrick> mahogny: doubt it
15:44:18 <mathrick> at least not danes
15:44:19 <lscd> jethr0: swedish isn't that hard to understand, at least written
15:44:52 <davidhouse> for contrast: "est-ce qu'on peut utiliser le utf8 avec haskell?" completely different :)
15:46:03 <davidhouse> and "can you use utf8 with haskell"
15:46:38 <jethr0> "can one use utf8 with haskell"
15:46:44 <mahogny> bah. french is english with bad pronounciation :)
15:46:46 <mathrick> davidhouse: actually, danish is very similar
15:46:46 <mathrick> man == one
15:46:59 <davidhouse> jethr0: technically yes.
15:47:07 <davidhouse> but no-one in england except the queen says 'one'.
15:47:07 <TuringTest> > can you (useWith Hakell utf8)
15:47:08 <palomer> davidhouse: one article too many
15:47:08 <lambdabot>  Not in scope: `utf8'
15:47:15 <mathrick> davidhouse: ??
15:47:17 <palomer> "can we use the utf8 with haskell"
15:47:17 <jethr0> davidhouse: i do :)
15:47:25 <davidhouse> man in german, on in french on the other hand, are very common
15:47:36 <mathrick> also, kan du bruge utf-8 med haskell is also correct
15:47:47 <davidhouse> palomer: sans 'le'?
15:47:48 <mathrick> just that man is more popular
15:48:21 <palomer> sans 'le'.
15:48:30 <mathrick> davidhouse: "how does one use utf-8 with haskell" <-- this sort of construct is very popular, at least in written language
15:48:40 <jethr0> davidhouse: "one's right" has 218000 hits in google. although erroneously some come from "no one's right"
15:48:59 <davidhouse> mathrick: i'm english. that doesn't come up much in day-to-day language.
15:49:07 <davidhouse> it's what the textbooks say, but it's not what we use.
15:49:11 <mathrick> :)
15:49:27 <mathrick> davidhouse: I admit that I mostly have contact with written language
15:49:29 <davidhouse> people still know what it means
15:49:32 <mathrick> and there, it's common
15:49:52 <davidhouse> you'd get some funny looks if you used it conversationally. it's semi-common in quality newspapers, i suppose.
15:50:02 <mathrick> ONE DOES NOT SIMPLY USE UTF-8 WITH HASKELL
15:50:02 <palomer> here you'd usually say "y'a-t-il facon d'utiliser utf8 avec haskell"
15:50:04 <mathrick> ;)
15:50:08 <jethr0> well, the google hits are wrong, but there are uses for "one" in english, if not spoken than written and maybe older usage
15:50:54 <jethr0> "peux-je utiliser utf8 avec haskell?"
15:51:00 <davidhouse> puis-je.
15:51:02 <davidhouse> i'd almost always translate man -> you or we.
15:51:03 <jethr0> sry
15:51:14 <palomer> puis-je == can I
15:51:21 <jethr0> i know
15:51:25 <davidhouse> it's weird, because you say 'je peux'.
15:51:46 <palomer> can I, literally, use utf8 with haskell
15:52:09 <palomer> davidhouse: like in english, you switch the subject and verb around when asking a question
15:52:24 <palomer> oh, you're talking about the tense
15:52:32 <davidhouse> palomer: right. but you don't change the verb. and you don't change the verb with any other verb in french
15:52:35 <palomer> peux-je is strictly correct, I believe
15:52:37 <davidhouse> pouvoir is just a weird exception.
15:52:40 <palomer> but noone uses it
15:52:52 <jethr0> yuchu
15:53:26 <davidhouse> palomer: is "il y a" or "y'a" more common in written language?
15:53:53 <palomer> which kind of written language?
15:54:03 <palomer> between friends, y'a
15:54:20 <jethr0> i think i've never heard "y'a-t-il" in spoken french. at least not in so many syllables :)
15:54:23 <palomer> between diplomats, il y a
15:54:38 <davidhouse> heh.
15:55:26 <palomer> I say "il y aurais-t-il"
15:55:40 <palomer> but I say it so fast it's midway between il y and y'
15:55:44 <jethr0> that takes forever for me to parse
15:55:56 <davidhouse> that doesn't even make sense, does it?
15:56:02 <palomer> why not?
15:56:08 <palomer> you're just changing the mode
15:56:09 <jethr0> isn't aurais 2nd person?
15:56:27 <vincenz> so UTF-8 works straight witht haskell?
15:56:28 <palomer> oh, good point, aurait
15:56:36 <vincenz> > maxEnum :: Char
15:56:37 <lambdabot>  Not in scope: `maxEnum'
15:56:42 <palomer> note: french isn't my strongest language
15:56:44 <davidhouse> technically, it should be y aurait-il, no?
15:56:47 <jethr0> well, unicode does. i don't know if utf8 does
15:56:52 <palomer> but it is nonetheless my native tongue
15:57:06 <vincenz> remind me how to get the maximum of an enum?
15:57:13 <davidhouse> you say y a-t-il, changing that to the conditional, it goes to y aurait-il.
15:57:17 <jethr0> maxBound
15:57:22 <vincenz> > maxBound :: Char
15:57:23 <lambdabot> '\1114111'
15:57:27 <vincenz> yep
15:57:28 <vincenz> utf
15:57:35 <palomer> davidhouse: good point:O
15:57:42 <palomer> yeah, that's what I say
15:57:55 <palomer> I guess that's why I always omit the subject
15:57:57 <davidhouse> i guess y aurait-il sounds just like y aurait-t-il
15:58:20 <palomer> well, erm, aurait-t-il wouldn't make sense
15:58:20 <davidhouse> you just don't insert that extra t because you can pronounce it anyway.
15:58:24 <palomer> unless you're stuttering
15:58:29 <davidhouse> exactly.
16:00:55 <jethr0> hah, '"one does not" -other' has 1 million hits in google :)
16:01:47 <jethr0> damn, but '"one does not" -other -which' still has 500k
16:02:26 <mathrick> why -other?
16:02:48 <davidhouse> the other one does not, etc
16:02:59 <davidhouse> and similarly with which.
16:03:16 <jethr0> "which one does not" and "one does not imply the other" or similar
16:04:05 <jethr0> damn, i still missed "this one does not". google is just too syntacticly oriented for this kind of query
16:04:12 <ihope> Oh dear.
16:04:27 <ihope> (sequence . repeat) (putChar '\a')
16:04:27 <jethr0> "one plus one does not equal three"
16:05:09 <davidhouse> jethr0, the first three results were from thinkexist.com, "collected quotes from albert einstein", "george orwell quotes". that should give you an idea of the usage.
16:05:18 <ihope> When you hit Ctrl+C, it beeps for each letter it's outputting...
16:05:24 <jethr0> davidhouse: i know, i've looked through them
16:05:42 <davidhouse> jethr0: http://www.google.co.uk/search?q=%22one%20plus%20one%20does%20not%20equal%20three%22 only 140 results
16:05:54 <jethr0> and albert einstein's english wasn't the most idiomatic/colloquial anyways
16:06:28 <davidhouse> he didn't really speak much english, being german.
16:07:06 <jethr0> well, he lived in america for 22 years
16:07:34 <davidhouse> i'd imagine those quotes were in german originally, is what i meant.
16:07:47 <jethr0> that too
16:09:02 <ihope> Now how do I get GHCi to say "IIIIIIntInterInterrupted."?
16:09:07 <jethr0> i will still continue to use "one", because i like it. "One Man's Pork Is Another's Bacon" ^_^
16:09:26 <jethr0> i guess the interruption was interrupted several times
16:09:48 <davidhouse> ihope, putStrLn "IIIIIIntInterInterrupted." ought to do it
16:09:55 <ihope> :-P
16:10:04 <davidhouse> > "IIIIIIntInterInterrupted."
16:10:05 <lambdabot> "IIIIIIntInterInterrupted."
16:10:45 <davidhouse> jethr0: heh. yeah, it's common in idioms and stuff too. but just don't try to use it conversationally ;)
16:11:06 * davidhouse tries to think of a german analog
16:11:44 <jethr0> davidhouse: i understand your point quite well. there are quite a few deprecated-sounding word usages in german.
16:11:47 <davidhouse> i suppose jemanden/jemandem: officially, they're correct, but no-one really uses them (or do they? i haven't been to germany, i'm just going by what my german teacher says :))
16:11:50 <jethr0> but that's no reason to avoid them :)
16:12:24 <jethr0> davidhouse: i think they are far more used than "one"
16:12:59 <davidhouse> i couldn't think of any other examples :)
16:14:05 <jethr0> i guess "jemanden" would be used similarly to "someone", although maybe slightly less
16:14:50 <davidhouse> jemanden is simply someone in the accusative. jemandem is in the dative.
16:14:51 <jethr0> no, you're right. "jemand" is used quite frequently, but the forms you've mentioned are much rarer!
16:15:13 <davidhouse> hence, ich schreibe einen Brief jemandem is technically correct.
16:15:43 <jethr0> "Ich schreibe jemandem einen Brief" is good german, but think about how often you say that
16:15:59 <davidhouse> sorry, getting the objects the wrong way round
16:16:40 <davidhouse> jethr0: but, for example, you'd never say "ich schriebe der Mann einen Brief". you'd always (i hope) use "dem Mann"
16:16:48 <kosmikus> jethr0: I'd use that sentence.
16:16:55 <palomer> is it true that in german you usually put the verb at the end of a sentence?
16:17:01 <davidhouse> palomer: not usually.
16:17:01 <ihope> ¡Me gusta gustar!
16:17:01 <jethr0> davidhouse: i don't see what you mean by that
16:17:09 <davidhouse> but it has a lot of subordinating conjuctions
16:17:18 <kosmikus> palomer: no.
16:17:30 <davidhouse> palomer: a lot more than french/english.
16:17:55 <davidhouse> palomer: e.g. "i have to go into town" in german would have a verb at the end: "ich muss in die Stadt gehen"
16:18:14 <jethr0> kosmikus: so would i, but it's applicable in a very specific situation only. usually you'd say "Ich schreibe einen Brief an meine Freundin" or sth.
16:18:34 <palomer> Worldwide, German accounts for the most written translations into and from a language and according to the Guinness Book of Records <--this is according to wikipedia
16:18:37 <palomer> how can this be?
16:18:38 <kosmikus> jethr0: ah, that's what you mean. yes, sure.
16:18:40 <jethr0> well, the predicate is "muss" in your sentence
16:18:53 <palomer> German is the language with the most native speakers <--this too
16:18:58 <davidhouse> err
16:19:00 <davidhouse> chinese?
16:19:12 <jethr0> well, they've got incompatible dialects one could argue
16:19:15 <jethr0> but spanish??
16:19:46 <davidhouse> jethr0: true, but subordinating conjuctions like dass, obwohl are very common in german. hardly any conjuctions in french/english subordinate
16:19:56 <jethr0> german has less then 100 million native speakers i'd say
16:19:58 <davidhouse> (subordinate = send the verb to the end)
16:20:21 <davidhouse> french/english word order is in fact very similar.
16:20:23 <palomer> what about...english?
16:20:26 <davidhouse> (to each other, i mean)
16:20:44 <davidhouse> you can often translate word-for-word (apart from the whole adjective-after-noun thing in french)
16:20:49 <jethr0> english is very keen on short sentences, not least due to bad/lacking comma rules.
16:20:52 <palomer> ok, so if your sample space is all currently used german sentences, what percentage have their verb at the end?
16:21:13 <jethr0> german otoh likes to produce _long_ nested sentences
16:21:20 <palomer> davidhouse: but most of the time when you translate word for word it sounds really odd
16:21:23 <davidhouse> jethr0: their neither bad nor lacking. they're completely different; you use a comma to indicate a pause in speech, not to seperate off clauses.
16:21:57 <jethr0> davidhouse: english comma rules allow for very ambiguis sentences
16:22:05 <davidhouse> jethr0: that's also true.
16:22:43 <jethr0> palomer: the predicates are almost always in front of the sentence. what you mean are secondary verbs/infinitives
16:23:08 <palomer> err, my question is how often does one see the verb at the end of a sentence
16:23:10 <jethr0> but i must admit that i never learnt german in this way and so have no idea where verbs usually go :)
16:23:21 <davidhouse> palomer: not nearly as bad as if you did it with german. think "il est le cas que je dois faire mes devoirs", you can translate word for word. in german, that'd be something like "es stimmt, dass ich meine Hausaufgaben machen muss" == "it's true that I my homework do must"
16:24:07 <dcoutts> jethr0, the complexity of punctuation in English is fun. :-)
16:24:17 <palomer> "il est le cas" sounds weird
16:24:38 <davidhouse> palomer: sorry. had to think on my feet, i've never really spoken french to french people
16:24:40 <jethr0> palomer: you keep repeating "the verb". in german sentences there are frequently more than one verb, with the predicate somewhere in front. infinitives will often stand at the end, but you can't just throw all kinds of sentences into the same category
16:24:42 <dcoutts> jethr0, even native speakers have trouble knowing when to use . , ; - ( ) etc
16:24:56 <palomer> oh, I meant "a verb'
16:24:56 * SamB wonders if it means something when you are being constantly distracted from what you are trying to do
16:25:04 <davidhouse> jethr0: it's not just infinitives at the end though. think sentences involving dass, obwhohl, weil...
16:25:33 <davidhouse> SamB: there's a very easy way to solve that: "/quit" :)
16:25:46 <davidhouse> *obwohl
16:25:53 <jethr0> davidhouse: yes, but those are nested sentences (called "relative sentences" in german). those are part of an enclosing sentence, which again has the predicate in front
16:26:13 <SamB> davidhouse: mostly it isn't by IRC that I am distracted.
16:26:24 <davidhouse> jethr0: hmm... true.
16:26:44 <SamB> I guess its what you call writer's block...
16:27:27 <davidhouse> dcoutts, don't even get started on apostrophes ;)
16:27:30 <jethr0> german would be too hard for me to learn :)
16:27:37 <davidhouse> nah, german is fun to learn.
16:27:39 <SamB> what is the proper way to deal with writers block?
16:27:47 <dcoutts> davidhouse, oh yeah, that too. :-)
16:27:49 <davidhouse> a much more rigid grammar than french
16:28:01 <jethr0> i found french grammar hard already
16:28:02 <davidhouse> dcoutts, or should i say "apostrophe's" ;)
16:28:14 <int-e> davidhouse: please don't
16:28:21 <dcoutts> davidhouse, actually I think the use of ' is easier than , ; and -
16:28:22 <davidhouse> int-e, don't worry.
16:28:23 <int-e> davidhouse: that apost... catastrophic.
16:29:01 <SamB> argh, spare me from the apostrophic constructions
16:29:26 <jethr0> but english has some intricacies too. i am amazed how many people get "you and i" vs. "you and me" wrong in more than cases than a normal distribution would account for
16:29:47 <davidhouse> yeah.
16:29:52 <davidhouse> english people can't speak english.
16:29:57 <ihope> You and I can go to the movies, just you and me...
16:29:57 <jethr0> hehe
16:30:00 <ihope> Right?
16:30:11 <jethr0> no, should be "i" in both cases
16:30:12 <SamB> I blame grammarians
16:30:12 <davidhouse> ihope, you and I in both instances
16:30:13 <lscd> davidhouse: no group of people can speak english
16:30:27 <davidhouse> "and it's goodnight from bob and I" aargh.
16:30:34 <int-e> ihope: Everyone should go to the movies, including you and me.
16:30:41 <ihope> Grr.
16:30:48 <davidhouse> ihope: just imagine the "you" bit wasn't there. then which one to use is obvious.
16:31:02 <davidhouse> e.g. you'd never say "it's goodnight from i", so that's obviously wrong.
16:31:08 <ihope> "I can go to the movies, just me.
16:31:36 <davidhouse> it doesn't always work :)
16:31:37 <Saulzar> Kids will use "me and fred" exclusively
16:31:39 <jethr0> i'm not sure about "me". is "is it just me, or ..." wrong?
16:31:51 <davidhouse> i'm not sure about "just".
16:32:00 <jethr0> huh?
16:32:02 <davidhouse> "is it just I" sounds very odd.
16:32:15 <jethr0> am it just i
16:32:23 <int-e> am I just it :)
16:32:27 <davidhouse> "am it"?
16:32:30 <twobitsprite> does one have to recompile the top-level/repl (what is it called in haskell?) to include other modules?
16:32:32 <jethr0> just joking
16:32:34 <SamB> is it just me, or are you making this out to be governed by rules when it may well not be?
16:32:35 <davidhouse> :)
16:33:07 <davidhouse> you definitely use "me" when it's the object of a verb. e.g., "he gave you and me a biscuit".
16:34:01 <Saulzar> Does it matter? "he gave you and I a biscuit" sounds fine to me...
16:34:11 <jethr0> Saulzar: yes, because noone uses it right
16:34:15 <jethr0> *correctly
16:34:42 <ihope> Saulzar: "he gave I a biscuit"
16:34:43 <int-e> Saulzar: would you also say 'he gave I a biscuit'?
16:34:44 <jethr0> many forms like "whom", "whose", ... are being lost by not being used
16:34:50 <davidhouse> Saulzar: does "he have I a biscuit work"? ;)
16:34:58 <Saulzar> Well no, but...
16:35:05 <davidhouse> Saulzar: it's technically wrong. but no-one's going to sue you.
16:35:23 <lscd> davidhouse: while your form of  the biscuit sentence is technically correct, it 'sounds' wrong to me, because it doesn't fit common usage
16:35:32 <Saulzar> People who speak English as a second language speak it more correctly than those who speak it natively.
16:35:57 <ihope> True.
16:36:21 <ihope> I'll try to get rid of that aspect of stuff by learning every language.
16:36:21 <jethr0> twobitsprite: you mean in ghci/hugs?
16:36:23 <davidhouse> lscd, no, you're wrong there. every english speaker i know says "he gave you and me". if someone says "you and I" there it's generally because they're trying to sound more "proper" (people have the impression that using "you and I" is a more posh form of "you and me")
16:36:35 <jethr0> twobitsprite: you can just import modules with ":m +Data.List" in ghci
16:36:37 <lscd> davidhouse: i'm a native english speaker
16:36:40 <davidhouse> lscd: snap
16:36:45 <lscd> snap?
16:36:48 <davidhouse> me too.
16:37:01 <lscd> ok; now please explain what 'snap' means in this context to me
16:37:10 <jethr0> @wn snap
16:37:12 <lambdabot> *** "snap" wn "WordNet (r) 2.0"
16:37:12 <lambdabot> snap
16:37:12 <lambdabot>   n 1: the act of catching an object with the hands; "Mays made the
16:37:12 <lambdabot>     catch with his back to the plate"; "he made a grab for
16:37:12 <lambdabot>     the ball before it landed"; "Martin's snatch at the
16:37:13 <davidhouse> :O you've never played snap? the card game?
16:37:14 <lambdabot> [59 @more lines]
16:37:15 <Saulzar> cards :)
16:37:15 <jethr0> hehe
16:37:18 <lscd> i haven't
16:37:21 * ihope snaps
16:37:25 <lscd> hm.... are you british, btw?
16:37:35 <davidhouse> lscd: yeah. warwickshire.
16:37:48 <lscd> ah.... that explains why you used biscuit in the example, and perhaps why you're used to the correct form
16:38:12 <davidhouse> aha. american?
16:38:17 <ihope> @type let undefined :: a -> (a -> a) -> a -> a in undefined undefined
16:38:18 <lambdabot> Not in scope: `undefined'
16:38:22 <lscd> canadian, living in switzerland for > 7 years
16:38:26 <ihope> !
16:38:35 <vincenz> lambdabot: @join #meta-science
16:38:35 <lambdabot> Not enough privileges
16:38:41 <jethr0> "the queen and i were having tea and biscuits"
16:38:50 <ihope> @type let undefined = error "blueberries", undefined :: a -> (a -> a) -> a -> a in undefined undefined
16:38:51 <lambdabot> parse error on input `,'
16:38:58 <ihope> @type let undefined = error "blueberries"; undefined :: a -> (a -> a) -> a -> a in undefined undefined
16:38:59 <lambdabot> a -> (a -> a) -> a -> a in undefined undefined :: forall a.
16:38:59 <lambdabot>                                   ((a
16:38:59 <lambdabot>                                   -> (a
16:38:59 <lambdabot>                                     -> a)
16:38:59 <lambdabot>                                   -> a
16:39:01 <lambdabot> [16 @more lines]
16:39:04 <ihope> @type let undefined = error "blueberries"; undefined :: a -> (a -> a) -> a -> a in undefined undefined undefined
16:39:05 <lambdabot>   Occurs check: cannot construct the infinite type:
16:39:05 <lambdabot>   t = (t -> t1) -> ((t -> t1) -> t -> t1) -> (t -> t1) -> t -> t1
16:39:12 <davidhouse> jethr0: correct, because you're the subject.
16:39:24 <davidhouse> "I was having tea and biscuits". works.
16:39:39 <jethr0> davidhouse: i was trying to sound british, but it's kinda hard to do across irc
16:39:47 <davidhouse> heh.
16:39:58 <lscd> jethr0: eh... it's not so difficult; it's all in the diction, and grammar quirks
16:40:16 <jethr0> ihope: whenever someone is spamming the channel with lambdabot requests, chances are it was you :)
16:40:47 <lscd> jethr0: oh, and _not_ mentioning the queen. ;)
16:41:06 <davidhouse> what do people think british people are like?
16:41:29 * resiak drinks tea
16:41:30 <jethr0> i've lived a year in england, so i've got some kind of a clue
16:41:34 <ihope> They say "pack" instead of "deck".
16:42:13 <ihope> Sure, it makes more sense. British things make more sense than American things, but Americans don't care.
16:42:15 <davidhouse> hmm. as in cards? i'd probably say "deck".
16:42:28 <ihope> 52 C in a P (W J)
16:42:37 <davidhouse> we use the correct form of "colour", "labour", etc :)
16:42:57 <davidhouse> ihope, 52 cards in a pack without jokers
16:42:58 <jethr0> hmm, beef with gravy and then hyper-sweet pudding :)
16:42:59 <ihope> We use different correct forms :-P
16:43:04 <lscd> as does canada, at least legally speaking
16:43:06 <sjanssen> davidhouse: I believe those words a spelled without 'u' ;)
16:43:14 <mathrick> davidhouse: which school are you, one which bastardises or bastardizes? :)
16:43:15 <lscd> sjanssen: you're incorrect ;)
16:43:15 <Saulzar> Pain in the neck when all the gui libraries are hijacked by American spelling of "colour" :)
16:43:26 <mathrick> sjanssen: except they are spelt with u :)
16:43:27 <TuringTest> I moved from America to Scotland 3 months ago.  There is very very little difference in practice.
16:43:28 <int-e> sjanssen: that depends on which side of the atlantic ocean you live on.
16:43:35 <davidhouse> oh, no. people using 'z's instead of 's's. argh. bastardises all the way.
16:43:47 <mathrick> davidhouse: agreed
16:43:53 <TuringTest> davidhouse: Is that zee or zed ?
16:43:58 <lscd> naw..... s and z are nearly entirely interchangeable
16:43:58 <mathrick> zed!
16:43:59 <davidhouse> that's a zed.
16:43:59 <lscd> zed!
16:44:00 <ihope> Zee.
16:44:06 <lscd> that's not controversial...... zee is for americans :p
16:44:14 <ihope> :-)
16:44:18 <ihope> Zulu!
16:44:27 <lscd> zed you ell you!
16:44:30 <jethr0> is that "hache" or "ache"?
16:44:31 <TuringTest> zee makes for a nicer song...
16:44:41 <Saulzar> hache ??
16:44:54 <ihope> That's the Spanish name for 'h'.
16:45:11 <davidhouse> ache.
16:45:12 <ihope> And it be hotel.
16:45:13 <Saulzar> Rout/route
16:45:16 <mathrick> jethr0: ache is not read like "h"
16:45:16 <davidhouse> aich, really.
16:45:16 <jethr0> some people are starting to pronounce the letter with a leading "h". i think it's originally from australia, but i've heard it in american english too
16:45:23 <ihope> Root.
16:45:27 <jethr0> mathrick: i know
16:45:36 <davidhouse> root, yeah.
16:45:36 <lscd> it's a matter of accent..... but ache, definitely
16:45:41 <jethr0> eitsh
16:45:43 <ihope> @help poll
16:45:44 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
16:45:44 <lambdabot> poll-close poll-remove
16:45:57 <davidhouse> ache = a nagging pain :) "ake"
16:46:02 <TuringTest> "pahk yaw cahr in Hahvahd yahd"
16:46:13 <TuringTest> That has a lot of "h" in it.
16:46:18 <Saulzar> Hmm, they do that with flower as well, pronounce it like flour
16:46:18 <TuringTest> (Boston accent)
16:46:43 <davidhouse> who, bostoners?
16:46:48 <jethr0> goti
16:46:50 <davidhouse> brits definitely don't do that.
16:46:52 <int-e> flu:r?
16:47:05 <davidhouse> unless you're northern.
16:47:15 <Saulzar> Aussies do that one
16:47:20 <lscd> davidhouse: there's a british accent that does pretty much anything you can think of ;)
16:47:34 <davidhouse> yeah, true.
16:47:43 <davidhouse> i love northern people. "canna use t'internet?"
16:47:44 <davidhouse> hehe.
16:48:14 <jethr0> "oi gat noe miney"
16:48:43 * ihope gaivs jathrau miney
16:49:17 <davidhouse> the cockney accent is quite famous outside of england, isn't it?
16:49:21 <lscd> very
16:49:24 <jethr0> thinx mait, you 'lrig'
16:49:43 <lscd> but when i try to imitate it, people say i sound scottish, so i don't have it down quite right......
16:50:04 <jethr0> hmm, the missing "t" is hard to put into irc language as in "par'y, ma'e, alrigh'"
16:50:04 <davidhouse> i can't do accents to save my life.
16:50:20 <ihope> Ì cán. :-P
16:50:21 <lscd> neither can i
16:50:41 <jethr0> i go' a le''er from me muhm
16:50:47 <jethr0> s/^/o/
16:51:22 <jethr0> pa''ern ma'ching
16:51:37 <davidhouse> http://pastebin.com/597239 heh.
16:53:20 <jethr0> isn't there a valid use for "try to never" instead of "try never to"?
16:53:47 <ihope> What's wrong with "try to never"?
16:53:58 <jethr0> as in "try to never get killed"
16:54:19 <jethr0> hmm, that's not an infinitive. i rest my case
16:54:48 <davidhouse> "try to never kill" is a split infinitive.
16:54:54 <davidhouse> you're splitting "to kill"
16:55:01 <ihope> So?
16:55:04 <dcoutts> "try never to kill"
16:55:11 <davidhouse> "try never to kill" is considered better style, but it's a little pedantic.
16:55:14 <jethr0> that has a different meaning, doesn't it?
16:55:15 <davidhouse> i'm guilty of that.
16:55:23 <davidhouse> jethr0: no, not really.
16:55:30 <davidhouse> well.
16:55:37 <int-e> davidhouse: would you say splitting infinitives is actually wrong?
16:55:50 <lscd> int-e: no - that's a remnant from latin grammar
16:55:59 <dcoutts> int-e, I don't think so, not wrong
16:56:10 <ihope> wats rong with bad splgn if pplz cn unstrd u
16:56:11 <davidhouse> perhaps you might intepret the latter as "don't ever try to kill"
16:56:27 <davidhouse> ihope, l0lz omfgbbq kthx
16:56:33 <dcoutts> it makes a sentance sound more formal to not split infinitives
16:56:35 <dcoutts> ;-)
16:56:35 <ihope> :-D :-D :-D
16:56:36 <lscd> ihope: it makes it a lot harder for people who don't know the words you're using to find them in dictionaries; and it's not as easy for people to understand as you think
16:56:38 <jethr0> "try never to kill" sounds like once you've done so, it doesn't matter. whereas "try to never kill" means (to me) that you should keep trying after the deed. but that might be a personal perception
16:56:57 <lscd> 'try to never kill' sounds plain odd
16:57:08 <ihope> Never try to kill.
16:57:11 <ihope> ;-)
16:57:16 <davidhouse> kill to never try.
16:57:50 <ihope> Oh neos.
16:57:52 <int-e> > let e (l,r) = e
16:57:52 <ihope> (sic)
16:57:53 <lambdabot>  parse error on input `}'
16:58:07 <ihope> > let e (l,r) = e in e
16:58:08 <lambdabot>   Occurs check: cannot construct the infinite type: t = (a, b) ->
16:58:08 <lambdabot> t
16:58:08 <lambdabot>   Expected type: t
16:58:08 <lambdabot>   Inferred type: (a, b) -> t
16:58:19 <ihope> > let Nothing = False in Nothing
16:58:20 <lambdabot> Couldn't match `Maybe a' against `Bool'
16:58:26 <ihope> > let Nothing = Just False in Nothing
16:58:27 <lambdabot> Add a type signature
16:58:32 <ihope> > let Nothing = Just False in Nothing :: Maybe ()
16:58:32 <lambdabot> Nothing
16:58:38 <ihope> > let Nothing = Just False in Just False :: Maybe ()
16:58:39 <lambdabot> Couldn't match `()' against `Bool'
16:58:44 <ihope> > let Nothing = Just False in Just () :: Maybe ()
16:58:45 <lambdabot> Just ()
16:58:54 <ihope> > let Just x = Nothing in x :: ()
16:58:55 <lambdabot>  Irrefutable pattern failed for pattern Data.Maybe.Just x
16:59:08 <davidhouse> right, well i'm off.
16:59:12 <jethr0> bye
16:59:15 <vincenz> bye
16:59:17 <davidhouse> enjoy the rest of your grammar debates.
17:00:14 <Saulzar> You and I, we'll talk again :)
17:00:51 <vincenz> dum dum dum... (dramatic note)
17:00:53 <ihope> That's "you and me"! *bang bang bang*
17:01:13 <int-e> > let e (l,r) = e' l r $ e' r l []; e' [] _ t = t; e' (x:y) z t = (x,(y,z)) : e' y (x:z) t; p l = p' (l,[]); p' ([],[]) = [[]]; p' x = e x >>= \(a,y) -> map (a:) $ p' y in map ((++".") . concat . intersperse " ") $ p ["never", "try", "to", "kill"]
17:01:14 <lambdabot> ["never try to kill.","never try kill to.","never to kill try.","never to
17:01:14 <lambdabot> try kill.","never kill to try.","never kill try to.","try to kill never.",
17:01:14 <lambdabot> "try to never kill.","try kill to never.","try kill never to.","try never
17:01:14 <lambdabot> to kill.","try never kill to.","to kill try never.","to kill never try.","
17:01:14 <lambdabot> to try never kill.","to try kill never.","to never try kill.","to never
17:01:16 <lambdabot> kill try.","kill to try never.","kill to never try.","kill try never to.",
17:01:18 <lambdabot> "kill try to never.","kill never try to.","kill never to try."]
17:01:35 <vincenz> int-e: have you eaten?
17:02:03 * vincenz tries to invent a haskell koan on the fly
17:03:14 <int-e> ah. unwords = concat . intersperse " "
17:03:32 <int-e> vincenz: why did you ask that?
17:04:01 <vincenz> A young student once approached Simon Peyton and looked up at him, "Why do we use lazyness, after all there's no sense in all those values."  Peyton looked at him and replied, "Cut down the leaves on that tree" and pointed towards a tree.  The student nodded and left.  The next day he returned and asked the same question, and Peyton replied similarly.  The student's eyes lit up and was enlightened.
17:04:22 <vincenz> good or bad?
17:04:30 <int-e> missing a 'he' at least.
17:04:36 <vincenz> tsk
17:04:39 <vincenz> int-e: empty your cup
17:04:54 <jethr0> vincenz: i don't get it
17:05:01 <vincenz> jethr0: cut down the leaves and the tree can't grow
17:05:09 <int-e> it seems to be a little too straight-forward to me.
17:05:10 <dbremner> vincenz - have you seen the OCaml koans? http://web.archive.org/web/20030330201259/http://www.bagley.org/~doug/ocaml/Notes/okoans.shtml
17:05:10 <int-e> :)
17:05:12 <vincenz> similarly you don't know how much you'll need from a lazy structure
17:05:38 <jethr0> i understand lazyness, just not your "koan" :)
17:05:53 <vincenz> oh
17:05:56 <vincenz> koan come from zenbuddhism
17:06:06 <vincenz> they're idiomatic tales to tell of a concept
17:06:08 <jethr0> nm
17:06:40 <vincenz> it was bad huh
17:06:44 <vincenz> well so much for koaning on the fly
17:06:44 <jethr0> but maybe i'm just not enlightened yet
17:07:13 <dbremner> vincenz - the lazy evaluation koan on that page is pretty good.
17:07:19 <vincenz> dbremner: I like the one about side effects
17:07:57 <vincenz> so
17:08:02 <vincenz> rate the one I wrote from 1 to 10?
17:08:40 * vincenz should start writing ... he never writes
17:08:46 <vincenz> maybe get a bit of experience
17:09:06 <vincenz> I once wrote a nice poem on a mud tho... was very short but quite powerful :) Sadly it's lost to bitrot
17:09:25 <ihope> I can write.
17:09:33 <vincenz> ihope: yeah me too, since about second grade
17:09:43 <vincenz> err first
17:09:47 <ihope> Hay un pingüino se llama Gordo (right?).
17:10:00 <vincenz> no hablo espanol
17:10:15 <vincenz> Pero, se vuoi parlare italiano, non ce di che
17:10:21 <jethr0> the lazy evaluation one is funny
17:10:26 <vincenz> hehe
17:10:28 <vincenz> yeah but so true
17:10:41 <vincenz> @vote-add VincenzKoan
17:10:41 <lambdabot> Unknown command, try @listcommands.
17:10:43 <ihope> Hmm, "pero" means "but", correct?
17:10:47 <vincenz> @poll-add VincenzKoan
17:10:48 <lambdabot> Added new poll: "VincenzKoan"
17:10:51 <vincenz> @choice-add VincenzKoan 1
17:10:51 <lambdabot> New candidate "1", added to poll "VincenzKoan".
17:10:52 <vincenz> @choice-add VincenzKoan 2
17:10:52 <lambdabot> New candidate "2", added to poll "VincenzKoan".
17:10:54 <vincenz> @choice-add VincenzKoan 3
17:10:54 <lambdabot> New candidate "3", added to poll "VincenzKoan".
17:10:55 <vincenz> @choice-add VincenzKoan 4
17:10:55 <lambdabot> New candidate "4", added to poll "VincenzKoan".
17:10:56 <vincenz> @choice-add VincenzKoan 5
17:10:56 <lambdabot> New candidate "5", added to poll "VincenzKoan".
17:10:58 <vincenz> @choice-add VincenzKoan 6
17:10:58 <lambdabot> New candidate "6", added to poll "VincenzKoan".
17:11:01 <vincenz> @choice-add VincenzKoan 7
17:11:01 <lambdabot> New candidate "7", added to poll "VincenzKoan".
17:11:03 <vincenz> @choice-add VincenzKoan 8
17:11:04 <lambdabot> New candidate "8", added to poll "VincenzKoan".
17:11:06 <vincenz> @choice-add VincenzKoan 9
17:11:06 <lambdabot> New candidate "9", added to poll "VincenzKoan".
17:11:08 <vincenz> @choice-add VincenzKoan 10
17:11:09 <lambdabot> New candidate "10", added to poll "VincenzKoan".
17:11:12 <jethr0> spam
17:11:14 <dbremner> jethr0 - these were probably first. http://www.lisp.org/humor/ai-koans.html
17:11:15 <vincenz> done
17:11:21 <jethr0> vincenz: where on your scale is good?
17:11:25 <vincenz> yeah
17:11:27 <vincenz> err
17:11:30 <jethr0> dbremner: i know those already, thx
17:11:33 <vincenz> well make it college grading
17:12:03 <vincenz> < 5 => bad, > 5 ok, > 7 pretty good, > 8 good...
17:12:10 <vincenz> >= 5 even
17:12:19 <jethr0> apart from not understanding the koan, i give it a
17:12:24 <jethr0> @poll-vote 4
17:12:25 <lambdabot> Unknown command, try @listcommands.
17:12:31 * vincenz winces
17:12:31 <ihope> @vote VincenzKoan 5
17:12:32 <lambdabot> voted on "5"
17:12:36 <jethr0> @vote 4
17:12:36 <lambdabot> usage: @vote <poll> <choice>
17:12:42 <vincenz> ouch
17:12:43 <jethr0> @vote VinzenzKoan 4
17:12:44 <lambdabot> No such poll:"VinzenzKoan"
17:12:53 <vincenz> @vote VincenzKoan 6
17:12:53 <lambdabot> voted on "6"
17:12:57 <jethr0> i think you get what i'm trying to vote
17:13:03 <vincenz> yep
17:13:10 <vincenz> an 8, thanx!
17:13:27 <dbremner> @vote VincenzKoan 5
17:13:28 <lambdabot> voted on "5"
17:13:29 <jethr0> but as i said, i didn't get it, so maybe it's just really good, but too enlightened for me
17:13:46 <ihope> Un día, Gordo ve una casa muy pequeña. Gordo anda a la casa.
17:14:49 <ihope> El dueño de la casa lo grita, «¡NO PINGÜINOS!»
17:14:50 <vincenz> One day, Fattie goes to a very small house, Fattie goes to a house.
17:15:00 <ihope> Ve = sees.
17:15:02 <int-e> well, it's a memoizing koan.
17:15:13 <vincenz> oh
17:15:20 <vincenz> goes to show I don't know spanish
17:15:21 <ihope> And it's Fatso, not Fattie ;-)
17:15:28 <vincenz> "va" in french and english is gog
17:15:28 <vincenz> go
17:15:32 <vincenz> ihope: same difference
17:15:42 <Saulzar> Haha, the lazy evaluation koan is hillarious.
17:15:54 <ihope> "Va" = goes, "ve" = sees.
17:15:59 <vincenz> the dynamic typing one is great to start a flamewar
17:16:12 * ihope likes flamewars
17:16:17 <vincenz> ihope: vim!
17:16:29 <ihope> vincenz: WordPad!
17:16:45 <vincenz> ihope: windowshumper
17:16:50 <jethr0> for haskellers the koans are all disputable. for example the HOF one
17:17:20 <jethr0> though shalt not have any gods besides emacs
17:17:28 <vincenz> the hof one doesn't constitute a koan
17:17:34 <ihope> Gordo está triste. Él regresa a su casa.
17:17:37 <jethr0> s/besides/but/
17:17:56 <vincenz> thou shalt not have any gods, butt emacs
17:18:02 <ihope> Nicely put.
17:18:11 <ihope> ...Wait a minute...
17:18:52 <dbremner> jethr0 - that one is based on the PL/I question in the AI koans.
17:18:54 <ihope> Oh right.
17:19:19 <ihope> > 0.0 == (-0.0)
17:19:20 <lambdabot> True
17:19:30 <ihope> > 0.0/0.0 == (-0.0)/0.0
17:19:31 <lambdabot> False
17:19:39 * ihope shakes his head
17:19:41 <int-e> > 1/0.0 == 1/(-0.0)
17:19:42 <lambdabot> False
17:19:42 <ihope> > 0.0/0.0
17:19:43 <lambdabot> NaN
17:19:50 <int-e> > 1/0.0 == 1/(0.0)
17:19:51 <lambdabot> True
17:19:54 <ihope> > (-0.0)/0.0
17:19:55 <lambdabot> NaN
17:20:25 <vincenz> > NaN == NaN
17:20:26 <lambdabot>  Not in scope: data constructor `NaN'
17:20:31 <jethr0> ihope: don't shake your head. everyone knows that you can't calculate with IEEE floating points
17:20:36 <vincenz> ah, even lambdabot speaks in koan
17:20:48 <vincenz> jethr0: yeah you need infinite numbers
17:20:56 * vincenz proposes using beads as a new counting system
17:21:13 <jethr0> no, i meant they are the most non-algebraic data type ever conceived
17:21:22 * ihope proposes getting rid of everything but natural numbers
17:21:26 <dbremner> jethr0 - also the x87 fpu is broken.
17:21:35 <jethr0> wouldn't an infinite number of beads take up a lot of space?
17:21:59 <jethr0> ihope: don't you like negative numbers?
17:22:02 <vincenz> jethr0: ... that's your answer to IEEE
17:22:20 <jethr0> huh?
17:22:36 <ihope> jethr0: tell me how to get x from (f x) given x
17:22:36 <vincenz> nm
17:22:45 <ihope> Given f, that is.
17:22:53 <vincenz> ihope: can't do
17:22:59 <vincenz> ihope: unless f is bijective
17:23:00 <ihope> (a -> b) -> b -> a
17:23:24 <vincenz> (Bijective a) => a a b -> b -> a
17:23:29 <vincenz> (Bijective f) => f a b -> b -> a
17:23:34 <jethr0> if f is given as a tabular projection, i can give you the all elements being projected onto x
17:23:38 <ihope> But that's just what you have to do to perform negative composition.
17:23:44 <vincenz> ihope: inversion
17:24:13 <ihope> En la casa, José lo dice, «¿Por qué estás tú triste?» (Or something like that.)
17:24:16 <vincenz> if f is injective
17:24:21 <vincenz> I could give you an equivalence class
17:24:30 <vincenz> namely a : a = f x
17:24:43 <ihope> @hoogle a -> IO b
17:24:44 <lambdabot> Control.Exception.evaluate :: a -> IO a
17:24:44 <lambdabot> System.Exit.exitFailure :: IO a
17:24:44 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
17:24:51 <vincenz> er.... a : f a = f x
17:25:00 <vincenz> anyways
17:25:01 <vincenz> rebooting
17:25:05 <vincenz> gonna shoot some american soldiers
17:25:08 <vincenz> later \o)
17:25:10 <ihope> Um.
17:25:17 <vincenz> american army... great game
17:25:22 <ihope> Ah.
17:25:37 * vincenz detaches
17:26:44 <ihope> @fortune
17:26:45 <lambdabot> Man's reach must exceed his grasp, for why else the heavens?
17:34:16 <ihope> @yow
17:34:16 <lambdabot> I wonder if there's anything GOOD on tonight?
17:34:22 <ihope> @yow
17:34:23 <lambdabot> The fact that 47 PEOPLE are yelling and sweat is cascading down my
17:34:23 <lambdabot> SPINAL COLUMN is fairly enjoyable!!
17:34:39 <ihope> @help fortune
17:34:39 <lambdabot> Provide a random fortune
17:34:43 <ihope> @help yow
17:34:43 <lambdabot> Yow!
17:34:49 <ihope> @help vixen
17:34:50 <lambdabot> sergeant curry's lonely hearts club
17:34:53 <ihope> @arr
17:34:54 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
17:35:00 <ihope> @. elite arr
17:35:00 <lambdabot> 5MAr+ly ME la$z
17:35:07 <ihope> @msg
17:35:08 <lambdabot> Not enough privileges
17:35:11 <ihope> #help msg
17:35:17 <ihope> @help msg
17:35:18 <lambdabot> msg someone
17:44:19 <ihope> @msg ihope bleh
17:44:19 <lambdabot> Not enough privileges
17:44:26 <ihope> @quine
17:44:26 <lambdabot> Maybe you meant: quit quote
17:46:55 <ihope> How do I do this:
17:47:14 <ihope> "If foo happens before bar does, do baz, otherwise do qux.
17:49:31 <Lemmih> Use an MVar?
17:51:24 <ihope> @index MVar
17:51:24 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
17:52:20 <ihope> Two improvements for Haskell: variables in the IO monad and event handlers.
17:54:33 <Saulzar> ihope, IORef, and what do you mean by event handlers?
17:54:45 <dons> we have both already... MVars/IORefs and , signal handlers
17:54:52 <ihope> Eh, okay.
17:54:52 <dons> or maybe you just mean catch/handle
17:55:16 <dons> it's a general purpose language, so of course it has these kinds of tihngs
17:55:25 <ihope> When an IRC message is recieved, parse it and toss it to the IRC bot,
18:05:23 <timetolag> must go NOW 2 alienware laptops price 550 altogether for both.  want them gone today message me on aim at ogd443 or msn at mcsltd1@hotmail.com or yahoo at thishastogotoday
18:06:08 <wagle> spamming channels, are we?
18:06:16 <ihope> @spam timetolag
18:06:17 <lambdabot> lShell module failed: Prelude.init: empty list
18:06:35 <mwc> dcoutts,  how hard would it be to allow the mozilla embedding stuff in gtk2hs to be built around XULRunner rather than Firefox
18:06:38 <ihope> @spam
18:06:39 <lambdabot> lShell module failed: Prelude.init: empty list
18:06:42 <mwc> seems that that's the way the window is blowing these days
18:06:46 <mwc> *wind
18:07:12 <dcoutts> mwc, if it provides a pkg-config file then it'd probably be easy
18:07:24 <ihope> I BUY UR LAPTOPS $ !$ OL
18:07:44 <mwc> I'll let you know how it goes
18:08:04 <dons> \lam \x.x
18:08:05 <lambdabot> lShell module failed: Prelude.init: empty list
18:08:15 <dons> \help lam
18:08:15 <lambdabot> Evaluate terms of the pure, untyped lambda calculus
18:08:15 <lambdabot> darcs get http://www.eecs.tufts.edu/~rdocki01/lambda
18:08:22 <dons> \lam four
18:08:22 <lambdabot> lShell module failed: Prelude.init: empty list
18:08:25 <dons> hmm
18:08:25 <int-e> \eval 1+1
18:08:26 <lambdabot> 2
18:08:32 <ihope> @something
18:08:32 <lambdabot> Unknown command, try @listcommands.
18:08:37 <ihope> @lam
18:08:38 <lambdabot> lShell module failed: Prelude.init: empty list
18:08:42 <dons> looks like just lambda is broken.
18:08:42 <ihope> @help lam
18:08:43 <lambdabot> Evaluate terms of the pure, untyped lambda calculus
18:08:43 <lambdabot> darcs get http://www.eecs.tufts.edu/~rdocki01/lambda
18:08:50 <ihope> @map
18:08:50 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:08:53 <dons> ?map
18:08:53 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:08:57 <dons> \map
18:08:57 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:08:59 <ihope> That...
18:08:59 <dons> and so on
18:09:04 <ihope> What's @lam?
18:09:06 <ihope> @spellcheck
18:09:07 <lambdabot> Unknown command, try @listcommands.
18:09:18 <ihope> @rand
18:09:19 <lambdabot> parse error (possibly incorrect indentation)
18:09:23 <ihope> @rand 3
18:09:24 <lambdabot> Only unit numeric type pattern is valid
18:09:28 <dons> now you'r ejust typing random things ihope
18:09:52 <ihope> True...
18:09:59 <ihope> !help
18:10:20 <dons> @dynamic-unload lam
18:10:21 <lambdabot> dynamic module failed: unknown or static module
18:10:26 <dons> @dynamic-unload lShell
18:10:26 <lambdabot> module unloaded
18:15:42 <dons> > let f = 0 : intersperse 0 (map (1+) f) in f
18:15:44 <lambdabot> Exception: <<loop>>
18:15:59 <dons> hmm. cool, it still produces a loop, int-e (where you asking about that a few days ago?)
18:16:14 <int-e> no that wasn't me.
18:18:28 <int-e> neat. it can't decide whether to end the list there or not.
18:18:31 <dons> ihope, by the way, you know you can message lambdabot in private?
18:18:45 <dons> (just noticed enormous amounts of channel noise in the last 24 hours... )
18:18:57 <ihope> I can? Really? :-P
18:19:21 <int-e> intersperse sep (x:xs) = x:if null xs then [] else sep:intersperse sep xs  instead of  intersperse _   [x]     = [x]; intersperse sep (x:xs)  = x : sep : intersperse sep xs  would work better.
18:19:38 <dons> well, i think that perhaps once people start saying "people would stop spamming the bot... :(" then that's a sign..
18:19:48 <ihope> Um...
18:20:16 <int-e> > let int _ [] = []; int sep (x:xs) = x:if null xs then xs else sep:int sep xs; f = 0:int 0 (map (1+) f) in take 10 f
18:20:17 <lambdabot> [0,1,0,2,0,1,0,3,0,1]
18:20:31 <ihope> ...You did it!
18:21:15 <dons> oh sorry, reading more of the logs, I see several people were playing at it.
18:21:17 <dons> my apologies
18:22:01 <dons> hmm, though now I see:  <ihope> > (unwords . repeat) "spam" :/
18:22:37 <int-e> lovely spam! oh wonderful spam!
18:22:42 <dons> generally, if someone is annoyed enough to ask you to hack lambdabot off channel, then you should.
18:25:21 <dons> @quit some tweaks
18:28:07 <int-e> actually intersperse can (should?) be written as a foldr, once the first list member is dealt with.  intersperse sep (x:xs) = x:foldr (\y l -> sep:y:l) [] xs
18:38:49 <ihope> @quote
18:38:50 <lambdabot> Taral says: How do you add an @quote?
18:42:39 <ihope> @hoogle clipboard
18:42:40 <lambdabot> Graphics.UI.ObjectIO.StdClipboard.Clipboard :: Clipboard item
18:42:40 <lambdabot> Graphics.UI.ObjectIO.StdClipboard.ClipboardItem :: ClipboardItem
18:42:40 <lambdabot> Graphics.UI.ObjectIO.StdClipboard.toClipboard :: Clipboard item => item ->
18:42:40 <lambdabot> ClipboardItem
18:43:33 <vincenz> re
18:43:38 <vincenz> dons: for some reason my bot keeps on crashing and crashing
18:44:04 <vincenz> even such simple things as /msg bot @msg NickServ IDENTIFY 123
18:46:45 <ihope> Hmm. In private messages, lambdabot isn't responding to >, only to @eval.
18:48:23 <ihope> Note to self: filter (not . isAlpha) does not leave behind only letters.
18:48:45 <vincenz> > filter (not . isAlpha) "ihope"
18:48:45 <lambdabot> ""
18:48:50 <vincenz> painful
18:49:29 <ihope> Here we go.
18:49:49 <ihope> (words . filter (Control.Monad.Reader.liftM2 (||) isAlpha isSpace))
18:50:06 <ihope> @pl Control.Monad.liftM2 (||)
18:50:07 <lambdabot> Control . Monad . liftM2 (||)
18:50:13 * ihope giggles
18:50:18 <ihope> @pl liftM2 (||)
18:50:19 <lambdabot> liftM2 (||)
18:50:27 <vincenz> @pl ihope is nutty
18:50:27 <lambdabot> ihope is nutty
18:56:03 <int-e> hmm, that used to work though (using > for @eval in private messages)
18:56:36 <int-e> $ 6*7
18:56:44 <ihope> > fromEnum á
18:56:45 <lambdabot>  lexical error
18:56:47 <int-e> | 6*7
18:56:50 <ihope> > fromEnum 'a'
18:56:51 <lambdabot> 97
18:58:15 <ihope> @type fromEnum 96
18:58:15 <lambdabot> Int
18:59:19 <dons> ihope, ah thanks. looks like a bug I introduced some where
19:03:57 <ihope> Tie true delight js in the ginding out, rather than in the knowing.
19:04:35 <ihope> @karma dons
19:04:36 <lambdabot> dons has a karma of 23
19:04:43 <ihope> @karma
19:04:44 <lambdabot> You have a karma of 1
19:04:48 <ihope> :-)
19:06:24 <vincenz> @karma
19:06:25 <lambdabot> You have a karma of 2
19:12:30 <ihope> @karma lambdabot
19:12:31 <lambdabot> lambdabot has a karma of 11
19:14:13 <ihope> @karma shapr
19:14:13 <lambdabot> shapr has a karma of 7
19:14:21 <ihope> @karma syntaxninja
19:14:21 <lambdabot> syntaxninja has a karma of 0
19:15:40 <palomer> ok guys
19:15:54 <palomer> I've decided that once I graduate I'm going to take an easy job so as to be able to work on my side projects
19:16:00 <palomer> probably not programming
19:16:04 <palomer> anyone have anything to recommend?
19:16:19 <vincenz> palomer: gigolo
19:16:36 <vincenz> palomer: what are you studying
19:16:39 <vincenz> palomer: what side projects
19:16:46 <vincenz> palomer: why don't you want to do those porjects as your job
19:17:06 <palomer> I don't see how it could be possible
19:17:07 <Saulzar> McDonalds
19:17:15 <palomer> they are varied and unmarketable
19:17:45 <stepcut> if they can market blogs, anything is marketable ;)
19:17:49 <palomer> furthermore, I don't know if I'll want to do them for any length of time
19:17:59 <palomer> I don't want to be tied down
19:18:26 <Saulzar> You'd surely do better working part time even rather than taking a minimum wage job
19:18:42 <palomer> part time programmer...
19:18:44 <palomer> there's an idea
19:19:11 <palomer> are there part time jobs for the newly graduated?
19:19:29 <palomer> but, then again, I don't want programming to become a chore
19:19:38 * palomer wishes he could work in a patent office
19:21:58 <dons> @quit bug fix
19:22:09 <dons> > 1+2
19:22:26 <palomer> imposter
19:22:27 <palomer> !
19:22:28 <lambdabot> 3
19:22:36 <dons> > 1+2
19:22:37 <lambdabot> 3
19:22:41 <dons> \bot
19:22:41 <lambdabot> :)
19:22:59 <ihope> \bo
19:22:59 <lambdabot> :)
19:23:00 <dons> things seem to work now, ihope
19:23:16 <ihope> Yay!
19:24:03 <ihope> @loacltime ihope
19:24:05 <lambdabot> Local time for ihope is Saturday, March 11, 2006 10:23:34 PM
19:24:13 <ihope> Bye bye
19:25:00 <dons> you're stuck in thhe past ;)
19:25:07 <dons> @localtime dons
19:25:10 <lambdabot> Local time for dons is Sun Mar 12 14:25:13 2006
19:25:28 <dons> Mar 12 is  much more fun than Mar 11 :)
19:25:53 <stepcut> @localtime stepcut
19:25:54 <lambdabot> Local time for stepcut is Sat Mar 11 19:25:33 2006
19:26:04 <mwc> @localtime mwc
19:26:04 <lambdabot> Local time for mwc is Sat Mar 11 22:25:05
19:26:19 <dons> you crazy yesterday-people
19:26:22 <mwc> ah, ctcp
19:26:26 <dons> yup
19:26:49 <int-e> Hmm. Sat Mar 12 04:26  here.
19:27:17 <dons> oh, you really are a day out of time
19:28:55 <Saulzar> You're still ~2 hours slow yourself :)
19:30:21 <mwc> Ever wished there was some way to tell how far progressed a build was after you "make"'d
19:30:54 <int-e> @localtime int-e
19:30:56 <lambdabot> Local time for int-e is Fri Jul 13 13:13:13 1313
19:35:12 <int-e> @localtime int-e
19:35:13 <lambdabot> Local time for int-e is two days after the day before yesterday
19:37:27 <Lemmih> Have you broken the dam yet, int-e?
19:39:19 <mwc> dcoutts, think I have mozembedding from xulrunner working now; just doing a final build and test
19:41:46 <dcoutts> mwc, you mean using gtk2hs or you mean just the gtk widget on it's own?
19:42:07 <mwc> through gtk2hs
19:42:15 <dcoutts> oh, great
19:42:43 <dcoutts> darcs send when you're done
19:43:38 <mwc> I believe the new way to do things (tm) is to use XULRUNNER as the source of the embedding stuff; so I made the priority xulrunner > firefox > mozilla
19:45:56 <dcoutts> mwc, that sounds ok
20:06:30 <jethr0> @karma
20:06:30 <lambdabot> You have a karma of 0
20:07:49 <mwc> @karma
20:07:49 <lambdabot> You have a karma of -1
20:07:56 <palomer> whoa
20:07:58 <palomer> @karma
20:07:58 <lambdabot> You have a karma of 2
20:08:02 <palomer> booya
20:08:07 <palomer> god I'm bored
20:08:09 <mwc> Ah yes, I tried to hack lamdabot :P
20:08:17 <palomer> my brain is dying!
20:08:25 <mwc> I think it was @karma++ mwc
20:15:38 <mwc> dcoutts, patch in the mail
20:15:50 <mwc> test and works fine
20:20:15 <zellyn> palomer, what do you have to do to get karma?
20:20:37 <jethr0> zellyn: suck up to any other channel user :)
20:21:13 <zellyn> Heh.
20:21:21 <jethr0> or, alternatively log on under a different name
20:21:23 <zellyn> @help karma
20:21:24 <lambdabot> return a person's karma value
20:21:29 <zellyn> @karma
20:21:29 <lambdabot> You have a karma of 0
20:21:33 <zellyn> @help
20:21:33 <lambdabot>  @help <command> - ask for help for <command>
20:21:40 <jethr0> @karma+ zellyn
20:21:41 <lambdabot> zellyn's karma raised to 1.
20:21:49 <zellyn> Oooh.
20:21:52 <jethr0> @karma- zellyn
20:21:53 <lambdabot> zellyn's karma lowered to 0.
20:21:56 <jethr0> see ^_^
20:22:05 <zellyn> Well, that's certainly easier than slashdot, eh?  :-)
20:22:17 <ncalexan> zellyn: Canadian?
20:22:23 <zellyn> hah
20:22:34 <zellyn> No.
20:22:39 <ncalexan> Blood traitor!
20:22:46 <zellyn> Are you Canadian?
20:22:55 <ncalexan> Of course not, I'm British!
20:23:02 <ncalexan> Just kidding... yes, British Columbia.
20:23:06 <zellyn> Actually, I'm originally South African, now American.
20:23:16 <ncalexan> Oh, interesting background.  Where in US?
20:23:20 <palomer> zellyn: help people
20:23:23 <zellyn> Atlanta, Georgia.
20:23:26 <ncalexan> I'm in California these days.
20:23:30 <ncalexan> A long way away.
20:23:30 <palomer> if you help someone extra a lot, you get karma
20:23:54 <zellyn> Heh.  I'm not going to be helping anyone just yet, unless they're even bigger newbies than I.
20:23:58 <palomer> if you get enough karma, you get a date with one of the ops' sister
20:24:10 <zellyn> I'm just reading through SOE, and lots of Monad tutorials.
20:24:14 <palomer> SOE?
20:24:28 <zellyn> School of Expression.
20:24:44 <palomer> that's a tutorial?
20:24:49 <jethr0> it's a book
20:24:53 <zellyn> http://haskell.org/soe
20:24:57 <zellyn> @where soe
20:24:58 <lambdabot> http://haskell.org/soe/
20:25:54 <zellyn> SOE seems like it would be good if you'd never done any functional programming, and I find it pretty good when working straight through.
20:26:08 <palomer> there's only one monad you need, and that's ReaderStateST
20:26:23 <palomer> everything else is child's play!
20:26:24 <zellyn> @where ReaderStateST
20:26:25 <lambdabot> I know nothing about readerstatest.
20:26:39 <palomer> well, it's ReaderT on StateT on ST
20:27:01 * int-e wonders where palomer does the pesky IO.
20:27:08 <palomer> first rule of haskell club: don't listen to palomer
20:27:15 <palomer> I don't do much IO
20:27:39 <zellyn> I heard ST mentioned for the first time on #haskell yesterday or this morning.
20:27:46 <zellyn> I don't think I'm quite there yet.
20:27:54 <palomer> probably not
20:28:09 <zellyn> Actually, I'm not yet at Monad Transformers at all, so definitely not yet.
20:28:34 <palomer> the best way to learn about monads is to start using them though
20:28:41 <zellyn> Yeah, that's what it seems like.
20:29:04 <zellyn> Any suggestions on which to use to get a handle on them?
20:29:05 <palomer> like, if you have a function which always carries around an argument that rarely gets updated, use Reader
20:29:21 <zellyn> Or are you suggesting building one?
20:29:24 <palomer> nonono
20:29:33 <palomer> building a monad isn't something you do unless you have to
20:30:02 <palomer> State is an interesting monad, you use it when your algorithm has a state
20:30:26 <palomer> ST is when you need references
20:30:31 <int-e> Hmm. Maybe, State and List monads.
20:30:38 <zellyn> References?
20:31:09 <Saulzar> (Mutable values)
20:31:20 <palomer> actually, you should start by Maybe and List
20:31:25 <int-e> Maybe is probably the easiest to understand, State isn't that difficult as well. The list monad is a bit stranger, especially if you're taught to think of monads as computations.
20:31:31 <palomer> the Maybe monad is used when the computation may or may not return a value
20:31:55 <zellyn> I'm just into part III of http://www.nomaware.com/monads/html/index.html
20:32:01 <palomer> int-e: the list monad is for computation that can return any number of computations
20:32:13 <palomer> s/computations/values
20:32:24 <jethr0> zellyn: a nice monad to start with is Maybe. it doesn't do much, but it definitely helped me a lot with monads
20:32:36 <int-e> palomer: Yes. It can model nondeterministic computations. Which are a bit weirder than the usual sequential ones.
20:32:40 <zellyn> With varying degrees of understanding of parts I and II.  Haskell still seems a bit slippery for now - I get things and then lose them again.
20:32:48 <int-e> > sequence [[1,2],[3,4],[5,6]]
20:32:49 <lambdabot> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
20:33:02 <palomer> zellyn: did you pick a small project yet?
20:33:14 <zellyn> No, not yet.
20:33:17 <int-e> palomer: this is one of the effects that seem strange at first.
20:33:53 <zellyn> I understand the list monad okay.  It's interesting that none of the references mention that it doesn't remove duplicates.
20:34:16 <jethr0> zellyn: why would anyone think that lists can't have duplicates?
20:34:28 <palomer> @type sequence
20:34:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
20:34:50 <jethr0> > join [[1,2,3]]
20:34:51 <lambdabot> [1,2,3]
20:35:00 <jethr0> > join [[1,2],[3,4]]
20:35:01 <lambdabot> [1,2,3,4]
20:35:09 <zellyn> Well, I mean whenever it's mentioned that the list monad embodies "try all possiblities", I think of a set rather than a list.
20:35:36 <palomer> that is strange, I would have thought that sequence [[1,2],[3,4],[5,6]] = [[1,2],[3,4],[5,6]]
20:35:41 <zellyn> > [1,2,3] >>= [3,4,5]
20:35:42 <int-e> that just shows that the analogy can't be taken too far. if you encode sets as lists, there's no easy way to avoid duplicates.
20:35:42 <lambdabot> Couldn't match `a -> [b]' against `[a1]'
20:35:50 <jethr0> hmm, okay, but that's just one use of the list monad. it's not strictly only for that kind of computation
20:36:31 <jethr0> and maybe you want to try sth twice, for examle when side-effects are used
20:36:32 <Saulzar> > [1,2,3] >> [3,4,5]
20:36:33 <lambdabot> [3,4,5,3,4,5,3,4,5]
20:36:48 <int-e> > [1,2] >>= \a -> [3,4] >>= \b -> [a,b]
20:36:49 <lambdabot> [1,3,1,4,2,3,2,4]
20:36:55 <jethr0> > replicate 3 undefined >> [1,2]
20:36:56 <lambdabot> [1,2,1,2,1,2]
20:37:02 <int-e> > [1,2] >>= \a -> [3,4] >>= \b -> return [a,b]
20:37:03 <palomer> ok, someone explain to me how sequence works in this case
20:37:03 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
20:37:23 <int-e> == sequence [[1,2],[3,4]]
20:37:31 <Cale> > sequence [[1,2],[3,4]]
20:37:32 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
20:37:47 <Cale> > do x <- [1,2]; y <- [3,4]; [x,y]
20:37:48 <lambdabot> [1,3,1,4,2,3,2,4]
20:37:54 <Cale> > do x <- [1,2]; y <- [3,4]; return [x,y]
20:37:55 <lambdabot> [[1,3],[1,4],[2,3],[2,4]]
20:38:31 <palomer> hrmph, /me will have to ponder this
20:38:44 <int-e> sequence [] = return []; sequence (a:as) = do a' <- a; as' <- sequence as; return (a':as')
20:39:06 <jethr0> > sequence [(+1), (-1)] 1
20:39:07 <lambdabot>  add an instance declaration for (Num (a -> a))
20:39:23 <jethr0> > sequence [(+1), (subtract 1)] 1
20:39:23 <azuroth> is openal the only lib around for sound output..?
20:39:24 <lambdabot> [2,0]
20:39:31 <palomer> ok, it sorta makes sense
20:39:38 <ncalexan> azuroth: maybe the SDLmixer libs?
20:39:44 <ncalexan> Really depends what you want to do.
20:40:36 <azuroth> what would be really cool is a lib that just took a list of floats and played some sound
20:41:13 <zellyn> Heh.  Monads still hurt my brain.
20:41:22 <zellyn> I guess I need to read a bit more and work with them a bit.
20:41:22 <ncalexan> I don't know of any cross-platform way to do that.
20:41:34 <int-e> . o O ( playSound _ = putStr "\b" )
20:41:47 <azuroth> heheheh. awesome!
20:41:58 <zellyn> Any suggestions for a small project to try?
20:42:28 <palomer> zellyn: what are you into?
20:43:04 <jethr0> zellyn: raytracing is quite fun in haskell
20:43:26 <zellyn> Hmm.  That's not a bad idea.
20:43:31 <jethr0> or maybe a game like tic-tac-toe, othello, ...
20:44:17 <jethr0> zellyn: there's quite a few people who have written their own raytracer, not least the TMR article by boegl
20:44:35 <jethr0> http://haskell.org/tmrwiki/HRay
20:44:55 * palomer is probably the only person who hasn't
20:45:00 <palomer> I don't see the point of raytracers
20:46:19 <jethr0> palomer: maybe there is none. but i felt truly elated when i got mine to work well in very short time and it produced quite amazing images
20:46:35 <zellyn> I wrote a simple raytracer in college, but that was C++.  Bad C++, of course!
20:46:47 <palomer> there's nothing like bad C++
20:46:48 <jethr0> it's like creating your own little world. IMO there are few projects that produce such nice output with so little effort
20:47:02 <jethr0> bad VB?
20:47:03 <palomer> what does one usually use to draw?
20:47:10 <palomer> there's an article in TMR on this?
20:47:12 <jethr0> draw what?
20:47:29 <zellyn> @where TMR
20:47:30 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
20:47:37 <jethr0> i rendered to PGM files. but by now i might want to use HOpengl, cairo, or similar
20:47:57 <jethr0> i already posted the link above
20:48:12 <zellyn> Is there a win32/linux graphics solution?
20:48:12 <palomer> but, if you're going to use HOpengl, why not just let opengl draw everything?
20:48:34 <ncalexan> zellyn: for raytracing, Lemmih's hsSDL bindings are probably best.
20:49:05 <jethr0> zellyn: you mean for guis?
20:49:34 <palomer> use gtkhaskell, by virtue of me contributing 4 lines to it!
20:49:35 <palomer> yes!
20:49:40 <jethr0> palomer: i mentioned cairo as an alternative, just to increase its visibility :)
20:49:53 <jethr0> gtkhaskell?
20:50:04 <zellyn> gtkhaskell now does cairo, right?
20:50:12 <jethr0> you mean gtk2hs, right?
20:50:12 <palomer> hsgtk
20:50:15 <palomer> yeah
20:50:17 <palomer> that stuff
20:50:39 <zellyn> I was reading about graphics in haskell whilst trying to get some version of SOEGraphics to work on my system.
20:51:28 <zellyn> How does one paste 20 or 30 lines of code for folks to read?
20:51:37 <palomer> @paste
20:51:38 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
20:52:02 <jethr0> lisppaste2
20:52:18 <jethr0> http://paste.lisp.org/new/haskell
20:53:25 <lisppaste2> zellyn pasted "SOE exercise 7.5" at http://paste.lisp.org/display/17774
20:54:03 <zellyn> That was an exercise in SOE, to add simple variables to a (very) simple expression evaluator.
20:54:28 <zellyn> any comments?
20:55:01 <zellyn> Some things seemed like there must be a more concise way.
20:55:33 <zellyn> Particularly, pulling a variable value from a [(String, float)] list of [(name,value)]
20:55:35 <jethr0> that's a good situtation for the reader monad btw
20:55:36 <zellyn> getVar table name = snd $ head $ filter ((==name) . fst) table
20:55:41 <jethr0> cale has a good example on the wiki
20:55:56 <zellyn> Yeah, that seems like a good problem for Reader.
20:56:07 <int-e> @type lookup
20:56:08 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
20:57:48 <zellyn> > lookup "foo" [("foo", 1), ("bar", 2)]
20:57:49 <lambdabot> Just 1
20:58:03 <zellyn> > lookup "blah" [("foo", 1), ("bar", 2)]
20:58:04 <lambdabot> Nothing
20:58:25 <jethr0> can't find cale's example interpreter right now
21:00:32 <jethr0> i guess the example in "all about monads" is good enough
21:01:05 <jethr0> maybeToList $ lookup "blah" [("foo", 1), ("bar", 2)]
21:01:07 <jethr0> > maybeToList $ lookup "blah" [("foo", 1), ("bar", 2)]
21:01:08 <lambdabot> []
21:01:50 <int-e> > maybe id 42 $ lookup "blah" [("foo", 1), ("bar", 2)]
21:01:51 <lambdabot>  add an instance declaration for (Show (a -> a))
21:02:06 <int-e> > maybe 42 id $ lookup "blah" [("foo", 1), ("bar", 2)]
21:02:07 <lambdabot> 42
21:02:22 <int-e> > maybe 42 id $ lookup "foo" [("foo", 1), ("bar", 2)]
21:02:22 <lambdabot> 1
21:04:16 <zellyn> > (maybeToList . lookup) "blah" [("foo", 1), ("bar", 2)]
21:04:16 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
21:04:37 <zellyn> > (maybeToList . lookup "blah") [("foo", 1), ("bar", 2)]
21:04:38 <lambdabot> []
21:05:05 <zellyn> I'm still trying to get my intuition settled on $ and .
21:05:19 <jethr0> (maybeToList . (`lookup` [("foo", 1), ("bar", 2)])) "foo"
21:05:26 <jethr0> > (maybeToList . (`lookup` [("foo", 1), ("bar", 2)])) "foo"
21:05:27 <lambdabot> [1]
21:05:51 <zellyn> hah.  Nice.
21:05:53 <jethr0> (.) is composition, $ is application
21:07:49 <zellyn> So why didn't that first one work?
21:08:27 <jethr0> zellyn: because maybe expects a unary function as second argument
21:08:41 <int-e> zellyn: because . only 'chains' one argument. you need ((maybeToList .) . lookup) "blah" [("foo", 1), ("bar", 2)]  to chain two - which is arguably not very readable.
21:08:49 <jethr0> > maybe 42 (const 1) $ lookup "blah" [("foo", 1), ("bar", 2)]
21:08:50 <lambdabot> 42
21:09:13 <jethr0> sry, wrong example
21:10:05 <Revision17> Haskell is such an incredibly nice language.  It took me, a haskell neophyte, 1 hour to write a lexer; vs the 2 hours and 10X the lines of code in java
21:10:23 <jethr0> Revision17: congrats
21:10:40 <jethr0> what kind of lexer, i.e. for what kind of language
21:11:24 <Revision17> jethr0:  a simple one for an infix calculator type deal; I'm writing a symbolic differentiator in haskell since I just did it in java to learn java
21:11:33 <Revision17> it's kinda my "hello world" program after hello world
21:12:56 <jethr0> k, i can only advocate parsec. it's really easy to use and just a nice tools. but i guess you wanted to do this one from scratch
21:13:26 <Revision17> yea; if I weren't so new I would absolutly use parsec or happy or one of the other parser generators available
21:14:10 <Revision17> a basic recursive decent parser shouldn't be too difficult though, I don't think
21:14:57 <zellyn> :t (*)
21:15:02 <zellyn> > :t (*)
21:15:02 <lambdabot>  parse error on input `:'
21:15:11 <zellyn> @type (*)
21:15:12 <lambdabot> forall a. (Num a) => a -> a -> a
21:15:33 <zellyn> okay, I'm not sure I quite understand this
21:15:37 <zellyn> @type ((+3) . (*2))
21:15:37 <lambdabot> forall a. (Num a) => a -> a
21:15:42 <zellyn> That makes sense
21:15:49 <zellyn> @type ((+3) . (*))
21:15:50 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a -> a
21:15:55 <zellyn> That's trickier.
21:16:08 <zellyn> I'm guessing it basically means I messed up!  :-)
21:16:21 <jethr0> zellyn: it means that's a function you're unlikely to use
21:16:26 <zellyn> heh
21:16:43 <zellyn> Num (a -> a)   means that the function a -> a is Numeric?
21:16:45 <jethr0> unless you make functions addable
21:16:49 <zellyn> gotcha
21:17:01 <jethr0> it means the function is an instance of the typeclass Num
21:17:20 <jethr0> so that you can add two such functions, which IMO doesn't make very much sense
21:17:38 <jethr0> except maybe for lambda numerals
21:17:47 <jethr0> eh, church numerals
21:18:35 <zellyn> > (+3) $ (*2) 5
21:18:35 <lambdabot> 13
21:18:54 <zellyn> That makes sense.
21:19:12 <jethr0> > (+3) . (*2) $ 5
21:19:13 <lambdabot> 13
21:20:38 <zellyn> > (+3) . (*2) 5
21:20:38 <lambdabot>  add an instance declaration for (Num (a -> b))
21:21:02 <zellyn> ((+3) . (*2)) 5
21:21:08 <zellyn> > ((+3) . (*2)) 5
21:21:09 <lambdabot> 13
21:21:33 <zellyn> Okay, that all makes sense.
21:21:42 <zellyn> I keep getting the feeling this shouldn't been so hard.
21:21:53 <zellyn> That's what I get for not thinking hard enough since college!
21:22:07 <jethr0> hehe, can i do anything to help?
21:22:09 <zellyn> Java is killing my brain!
21:22:10 <ncalexan> jethr0: adding two functions makes lost of sense in lots of situations.
21:22:30 <ncalexan> Lots of sets of functions form a vector space, with all sorts of additions...
21:22:35 <jethr0> ncalexan: ok, any examples (except church numerals)?
21:22:39 <ncalexan> s/lost/lots/
21:22:48 <ncalexan> Cont. functions on [0,1], with pointwise addition.
21:22:53 <zellyn> Every now and then, something clicks in Haskell, but it's a bit slow.
21:23:10 <jethr0> true, like with fuzzy logic
21:23:16 <jethr0> didn't think of those cases
21:23:25 <ncalexan> The ring of germs at a point :)
21:23:41 <ncalexan> The L^p spaces... lots :)
21:24:09 <jethr0> zellyn: it's like that for most people. imperative programming seems to make it harder to adopt functional thinking
21:24:35 <zellyn> Well, I absolutely loved functional programming in college in Lisp.  But Java has been slowly rotting my brain.
21:24:45 <ncalexan> Ditto what jethr0 said.  After you schedule things so many times, it's hard to get used to just saying what to do.
21:25:14 <zellyn> Now for my job, I have to write 100 lines of Java to do what 10 lines of Haskell would do.  So sad.
21:25:37 <lscd> zellyn: same problem, although i'm still in school..... where we do ..... java :(
21:25:51 <jethr0> imperative programming encourages "premature optimization". getting away from that is essential in any language, but haskell won't let you optimize so easily, so it forces you to let go ^_^
21:26:33 <zellyn> At first I thought Haskell was like Lisp, with type inferencing.
21:26:35 <dons> zellyn, a bit slow? do you use ghc with -O2?
21:26:46 <zellyn> Hah.
21:26:51 <zellyn> No, I mean my brain.
21:26:56 <dons> it's very fast, if you check the language shootout. much much faster than java, for example
21:26:58 <zellyn> No -02 switch for that.
21:26:59 <dons> ah :)
21:27:02 <dons> if only!
21:27:13 <jethr0> dons: o2 works on my brain too, but after some time i get dizzy from it
21:27:17 <jethr0> exhilerated even
21:27:27 <dons> I need coffee to get -O2
21:27:39 <zellyn> What's the main thing Lisp has that Haskell doesn't?
21:27:42 <jethr0> without O2 my brain quickly dies
21:27:50 <jethr0> side effects :)
21:27:54 <zellyn> hah.
21:28:01 <zellyn> I mean in terms of expressive power.
21:28:06 <jethr0> macros
21:28:11 <zellyn> That's what I thought.
21:28:19 <zellyn> There's some GHC-only macro facility, right?
21:28:32 <jethr0> hmm, there's template haskell
21:28:33 <zellyn> But Lisp gets a lot of mileage out of only having s-exps
21:29:02 <int-e> lisp has a trivial syntactic structure that makes writing macros easier.
21:29:04 <jethr0> yes, to an extent. but doing macros on untyped s-expressions can get pretty hairy, pretty fast
21:29:56 <zellyn> What is the current state of threading in Haskell?  Does it work okay for things like a webserver that has multiple threads?
21:30:17 <jethr0> supposedly very well
21:30:24 <stepcut> zellyn: yes -- though some people have had problems when they had 1000's of threads
21:31:17 <ncalexan> dons: what is the purpose of the darcs.cgi view on your site?  I can't actually browse any of the source.
21:31:45 <zellyn> Actually, the only thing I think I would miss moving away from Java is the huge set of software people have written for it.
21:32:01 <zellyn> For instance, if you need to evaluate Javascript in Java, someone's written a library to do it.
21:32:37 <stepcut> zellyn: 3rd party libraries are really starting to take off in haskell these days -- especially thanks to things like Cabal
21:32:46 <zellyn> Yeah, it seems like it.
21:32:58 <stepcut> zellyn: but, there are definately a lot of libraries not yet written :-/
21:33:12 <zellyn> Maybe if I get really ambitious, I'll try the Javascript interpreter thing.  :-)
21:33:40 <zellyn> Although the JS spec is pretty ugly in places.
21:34:19 <stepcut> heh. Well, writing compilers and interpreters is one thing that is well understood in haskell 
21:34:30 <zellyn> Seems like it.
21:34:53 <zellyn> I come at Haskell via the "Impressed by Pugs" route, actually.
21:35:23 <zellyn> Or maybe that's the "Impressed by audreyt" route.
21:36:12 <jethr0> dons: today was someone who came via the "impressed by shootout" route. i hadn't thought of that, but (apart from the aesthetical problems) that seems to be a nice marketing tool, too :)
21:36:44 <zellyn> Oh, and of course the "tool of choice for discriminating hackers" route.
21:38:08 <stepcut> :p
21:38:34 <palomer> what's impressive about pugs?
21:38:53 <lscd> it's one thing that keeps dragging me back here [the shootout] :D
21:38:56 <jethr0> its code quality
21:39:18 <palomer> the shootout is quite meaningless
21:39:46 <jethr0> palomer: i agree, but if it brings (the right) people to haskell, why not
21:40:25 <palomer> sure
21:41:36 <zellyn> palomer: the Pugs hackers seemed to get a heck of a lot done amazingly quickly.
21:42:08 <zellyn> It speaks well of Haskell.
21:42:32 <jethr0> btw, by code quality i didn't mean design. some of the choices don't seem optimal at first sight. but small module size and (over)documentation are exceptional!
21:44:53 <stepcut> yeah, that is why I like haskell, it's good for a quick hack, or for high-quality code
21:45:42 <jethr0> well, i haven't figured out how to do big code in haskell. but i guess "finding" some monads for high-level program flow goes a long way
21:46:42 <azuroth> would anyone tell me how to make openal?
21:46:58 <azuroth> (under debian)
21:46:59 <zellyn> Well, folks, thanks for the help.
21:47:31 <jethr0> "apt-get install libopenal-dev" ?
21:47:42 <palomer> night zellyn 
21:47:46 <azuroth> I mean, haskell bindings
21:48:11 <jethr0> ah, how many calls would that be
21:48:36 <jethr0> c2hs is quite nice (if low-level and non-automatic). the gtk2hs bindings are done with c2hs and supposedly readable
21:49:20 <Lemmih> How about using the binding that ships with GHC?
21:50:12 <azuroth> there's a binding with ghc? what package?
21:50:42 <palomer> you mean the FFI?
21:50:54 <Lemmih> azuroth: OpenAL and ALUT.
21:51:30 <azuroth> strange, I don't seem to have them
21:53:00 <dons> jeth0, cool. i'm glad the shootout is attracting people (rather than turning them away)
21:53:13 <jethr0> dons: we have no idea how many are turned away :)
21:53:31 <dons> true. but at least they're no longer blogging that they're turned away
21:53:33 * jethr0 remembers that he wanted to collect "nice" and fast versions of the shootout entries
21:53:55 <dons> i see only blog entries saying  how good it is now.
21:54:20 <stepcut> hehe
21:54:40 <jethr0> hmm, i don't mean to whine all the time, but i think the shootout code doesn't reflect entirely positively on haskell
21:55:02 <stepcut> jethr0: fortunately, most people never look at the code ;)
21:55:49 <jethr0> man, i'm too damn stupid for AFRP. stupid integrals *grumble*
21:56:17 <stepcut> jethr0: AFRP is hard
21:56:20 <Lemmih> azuroth: You can get the cabal packages from ghc-head, I think.
21:56:34 <ncalexan> jethr0: me too.  It can be done, and it's elegant... but it's not exactly the standard way to think of reactive programs.
21:57:11 <jethr0> stepcut: i'm not sure it is. i'm just _so_ not used to dealing with continuous integrals when programming that i'm at a total loss and have to get my mind on the right track somehow
21:58:00 <jethr0> and recursiveness (even if it is completely transparent) doesn't help my struggling mind, either
21:58:34 * azuroth just make installed cabal. do I just ./configure && make openal as usual..?
21:58:59 <jethr0> my guess would be "runghci ./Setup.hs configure"
22:00:01 <dons> the code is actually fairly good. except for some obvious cases doing heavy io
22:00:08 <dons> where we are forced into evil tricks
22:00:23 <dons> in the real world, you'd just ffi some C code, or use fast packed strings
22:00:31 <dons> the shootout isn't the real world though
22:00:38 <Lemmih> azuroth: You probably have to change the packages a little. But that should be way easier than writing them from scratch.
22:01:09 <jethr0> i disagree (though humbly). some of the code (nbody as an example) doesn't represent haskell at all!
22:01:18 <dons> nbody is pretty evil true
22:01:41 <dons> but, say, nsieve* and partial-sums are lovely, as are the several concurrency and binary tree benchmarks
22:01:42 <jethr0> it's like the java version in bizarro land
22:01:48 <dons> pi-digits is very nice
22:02:29 <dons> anyway, the shootout is a weird world, but we had to get some decent scrores for marketing purposes.
22:02:39 <stepcut> What I need is a *synchronous* version of AFRP
22:02:41 <jethr0> how come the new knucleotide is still not in the benchmarks
22:03:10 <jethr0> stepcut: what does synchronous mean in this context? for event handling?
22:04:31 <stepcut> jethr0: oops, i think I meant discrete 
22:04:43 <dons> jethr0, hmm. not sure. is it in the gp4 benchamarks -- the debian ones are often weeks behind.
22:04:57 <Revision17> Is there a way to do an 'or' type thing with just pure pattern matching in this code: http://pastebin.com/597475
22:05:03 <jethr0> gp4?
22:05:11 <stepcut> jethr0: well, discrete and synchronous -- for virtual analog sythesis
22:05:20 <dons> @shootout
22:05:21 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
22:05:21 <lambdabot> all
22:05:34 <dons> there's two machines the benchmarks are run on
22:05:48 <ncalexan> stepcut: Nilson did some work on a discrete Yampa; it's described in a paper of his, I believe.
22:06:11 <palomer> Revision17: what exactly do you want to do in pseudo-code?
22:06:16 <stepcut> ncalexan: I will have to look for that -- I think hal daume III implemented a discrete version too -- but the paper cost $$$
22:06:30 <jethr0> primitive tri (Lexer.Num x:xs) = case tri of Yes -> ...; ...
22:06:41 <ncalexan> Really?
22:06:55 <Revision17> jethr0:  ah, yea I guess it is proper to use a case
22:06:57 <Revision17> thanks
22:06:57 <ncalexan> Ah, you might not be affiliated with an institution...
22:07:01 <Revision17> and you too palomer 
22:07:02 <Revision17> :)
22:07:04 <jethr0> or using pattern guards
22:07:08 <palomer> I did all the thinking
22:07:14 <palomer> jethr0 is our PR man
22:07:28 <Revision17> jethr0:   won't that require an instance of Eq?
22:07:49 <jethr0> Revision17: not for the case version
22:08:01 <Revision17> I ment for pattern gaurds
22:08:04 <stepcut> ncalexan: yeah -- I am done with institutional learning
22:08:30 <jethr0> Revision17: yes, i think so
22:08:42 <jethr0> palomer: i am?
22:09:59 <jethr0> > let x = Nothing::Maybe () in Nothing{} == x
22:10:00 <lambdabot> True
22:10:01 <azuroth> hmm. I wonder why my ghc doesn't seem to have openal or anything
22:10:13 <jethr0> Revision17: although you could use the above {}-trick, maybe
22:10:19 <palomer> jethr0: what does that syntax mean?
22:10:45 <jethr0> it matches on constructor without taking record/datatype elements into account
22:11:18 <palomer> could you parenthesize it?
22:11:32 <jethr0> parenthesize what?
22:11:52 <jethr0> palomer: since when am i a PR man? and why? and how? and is that an insult? :)
22:12:10 <palomer> take your new position in stride!
22:12:30 <palomer> it has to be known that whenever you answer a question, I'm the one answering through you
22:12:52 <jethr0> ah, so you're the brains and i am your voice?
22:12:56 <palomer> exactly
22:13:06 <palomer> who here is into german house?
22:13:15 <jethr0> to express that one usually write "what jethr0 said" :)
22:13:16 <palomer> and racoons
22:13:29 <jethr0> palomer: i am _in_ a german house
22:13:46 <palomer> http://images.warner.de/flash/WEA/Seeed/617121/video_ding_214x214.swf
22:14:49 <palomer> god I'm tired
22:16:07 <jethr0> in some cases going to alleviates that condition
22:16:15 <jethr0> s/to/to bed/
22:16:35 <palomer> it's too early
22:16:39 <palomer> ugh, I guess I must
22:16:54 <palomer> jethr0: think of a way of saving and restoring a store
22:17:06 <jethr0> a store?
22:17:07 <palomer> and a function that checks if a store has any circular references
22:17:16 <palomer> yeah, in ST
22:17:54 <jethr0> i thought ST stood for state transformer
22:18:12 <palomer> did you really?
22:18:14 <mwc> StateT. ST is some entirely different and scary voodoo
22:18:22 <palomer> it's not that scary
22:18:36 <palomer> I think it's writable in pure haskell + rank 2 types
22:18:59 <mwc> I haven't had the heart to delve into it. I think what scares me is the IO a stuff
22:19:27 <Saulzar> What does ST stand for ? Short for STate ?
22:19:35 <jethr0> palomer: from the looks of it, it doesn't seem possible to save/restore it
22:20:52 <palomer> state thread
22:21:07 <palomer> well, it would be a variant of ST of course
22:21:18 <palomer> one easy way is to simply store 2 versions of every pointer
22:21:20 <palomer> the old and the new
22:21:31 <palomer> you could also store a stack of pointer versions
22:21:44 <palomer> you'll need existential types though
22:22:13 <palomer> heck, you could probably pull it off easily enough without existential types
22:22:18 <jethr0> palomer: ah, you mean saving/restoring it from the _inside_?
22:22:22 <palomer> the circular references problem is a doozy
22:22:27 <palomer> jethr0: yes, of course
22:22:48 <palomer> you'd need to use TH or some other crazy voodoo like that
22:22:49 <jethr0> well, i was considering doing it from the outside...
22:22:59 <palomer> you can't do anything from the outside, though
22:23:05 <jethr0> i know
22:23:38 <jethr0> what kind of references? pointers? how could pointers be circular?
22:24:06 <jethr0> unless they point to structures with pointers in them
22:25:27 <jethr0> i wonder why writing stuff like "let vy = 2*ym - yp - vy" and having it compile cleanly confuses me
22:25:33 <palomer> data Foo s = STRef s (Maybe Foo) ; a <- newSTRef Nothing ; b <- newSTRef (Just (Foo a)); writeSTRef a (Just b)
22:25:59 <palomer> jethr0: it compiles, but vy is in bottom
22:26:13 <palomer> err, rather, vy is bottom
22:26:23 <jethr0> yup, i just realized by execution :)
22:26:46 <palomer> jethr0: now a points to b
22:26:49 <palomer> and b points to a
22:26:51 <palomer> circular references
22:26:58 <stepcut> palomer: that sounds more like dance hall than house to me...
22:27:16 <palomer> I honestly can't tell the difference
22:27:50 <palomer> it would be cool to write a = -a and have ghc figure out that a must be 0!
22:27:58 <stepcut> :p
22:28:14 <jethr0> palomer: well, you could wrap you writeSTRef's in a function that checks for circles (in a terminating fashion)
22:28:29 <stepcut> palomer: isn't that called prolog ? 
22:28:45 <palomer> well, yes, but it's nice to have a generic function that one can use all the time
22:28:48 <jethr0> s/circles/cycles/
22:28:56 <palomer> stepcut: prolog is simply going to loop (like haskell)
22:29:40 <palomer> and sml downright refuses it
22:29:43 <palomer> which I think is silly
22:29:56 <palomer> since let a = if True then 2 else -a does evaluate to something
22:30:06 <Saulzar> Does value recursion make sense in a strict language?
22:30:17 <palomer> sure
22:30:27 <palomer> let a = if True then 2 else -a
22:30:33 <palomer> no language is perfectly strict:P
22:30:46 <palomer> (just as no language is perfectly lazy)
22:30:59 <Saulzar> Yeah but you can never use it for anything useful, can you?
22:31:08 <jethr0> why can't you write a language that's perfectly lazy?
22:31:30 <palomer> if you have a twisted mind you could write some specification which turns out to be mutually recursive value bindings
22:31:41 <palomer> jethr0: you could, but noone would use it
22:31:43 <palomer> ditto for strict
22:31:54 <jethr0> where is haskell not lazy?
22:32:09 <Saulzar> seq, patterns... 
22:32:17 <palomer> !
22:32:51 <jethr0> well seq is _explicitely_ not lazy. and i guess one could make lazy ~-patterns standard
22:33:08 <palomer> there are strict functions in haskell
22:33:15 <palomer> so haskell is not strictly lazy
22:33:24 <adu> lol
22:33:55 <jethr0> that's a weird argumentation. most of those functions are _explicitely_ strict.
22:34:00 <adu> so its also not strictly strict
22:34:21 <palomer> jethr0: what does that change?
22:34:30 <palomer> strictness is part of the language
22:35:20 <palomer> it would be hard to do anything "useful" without strictness
22:35:32 <palomer> anyways, night
22:35:39 <jethr0> yes, but the strictness annotations are either for performance/GC or for doing side-effect stuff (IO). so you could put the strict functions into the stateful monads and have a completely lazy language, no?
22:35:54 <Excedrin> why? isn't it possible to write useful programs without strictness?
22:36:07 <palomer> by useful I mean real world
22:36:26 <palomer> jethr0: aren't the IO functions strict?
22:36:38 <jethr0> palomer: yes, but IO isn't done _inside_ haskell
22:36:44 <mwc> not all; I believe there's one that reads a file lazily
22:36:55 <mwc> Handle -> IO String or something
22:37:11 <mwc> that reading is done lazily; so there's plenty of lazy IO
22:37:12 <palomer> right, but the fact remains that the IO functions are strict
22:37:25 <palomer> if you could find a way to remove all strictness from haskell, I would be interested in hearing about it
22:37:28 <mwc> strict in parameters? I can't think of any counterexamlpes
22:37:33 <jethr0> IO _has_ to be strict in many parts. so arguing that purely lazy languages can't do IO and thus pure lazyness is stupid is a weird argumentation
22:37:45 <palomer> I never said it's stupid
22:37:49 <palomer> it's just not terribly useful
22:38:11 <palomer> much in the same way as complete strictness isn't terribly useful
22:38:16 <jethr0> yes, but haskell extracts IO, and anything non-IO/non-sideeffect doesn't need strictness IMO
22:38:19 <adu> what exactly do you guys mean by "strict" and "lazy"?
22:38:27 <Excedrin> what's an example of lazy evaluation in C?
22:38:37 <palomer> Excedrin: if statements
22:38:47 <palomer> any control structure, really
22:38:49 <mwc> huh?
22:38:51 <jethr0> strict = evaluated when encountered, lazy = evaluated when absolutely needed (i.e. on output)
22:39:02 <mwc> Oh, I see what you mean
22:39:07 <adu> ic
22:39:13 <palomer> jethr0: yes, anything non IO doesn't need side effects
22:39:20 <palomer> but IO makes the world go round
22:39:32 <jethr0> exactly, and as haskell doesn't really do IO, haskell can be pure.
22:39:33 <adu> jethr0: so what other languages call "immediate" and "delayed"
22:39:44 <palomer> haskell does tons of IO
22:40:12 <jethr0> palomer: as far as i understand IO is done by some kind of interpreter/interleave thingey
22:40:13 <adu> it doesn't do IO? then why are there tons of IO functions in the IO library?
22:40:25 <Excedrin> if statements aren't lazy.. that's like saying that all of the program past the current instruction is lazy because it hasn't been evaluated yet
22:41:07 <palomer> if you consider if a function then if is lazy
22:41:09 <jethr0> Excedrin: if statements have to be lazy otherwise "then" and "else" would always both be executed
22:41:17 <palomer> well, lazy in some argument
22:41:40 <Excedrin> but if isn't a function in C
22:41:58 <palomer> I see no difference between if and a lazy function which does the same thing
22:42:15 <adu> isn't (?:) overloadable in C++?
22:42:16 <palomer> if you want to give lazy functions a different name, go ahead
22:42:21 <jethr0> nobody said anything about functions :) (until palomer just did :)
22:42:29 <jethr0> adu: no
22:42:45 <palomer> but I really must be getting to bed
22:42:47 <palomer> night
22:43:04 <jethr0> (&&) and (||) are overloadable, but the overloaded functions won't be short-circuiting, which is kinda evil
22:43:53 <Excedrin> jethr0: again, if the first statement of your C program causes the program to exit, then the rest isn't evaluated, but that doesn't make it lazy
22:44:36 <jethr0> Excedrin: i don't know on what basis you're arguing with me. if "then" and "else" were evaluated strictly, they'd both be executed
22:44:48 <jethr0> that has nothing to do with your argument
22:45:48 <jethr0> because C is a strict language, you can't implement "if" in it (excluding the use of && and ||, and ?: which is a synonym for "if")
22:46:41 <jethr0> oh yes, and i won't accept inline assembly either :)
22:47:06 <Excedrin> well, the other control statements can emulate if
22:47:13 <Excedrin> but I see your point
22:47:25 <Excedrin> or palomer's point, whichever
22:47:44 <jethr0> strike the above. you can't implement "if" as a function anyway, because C is strict. even using &&. unless you use a macro
22:49:29 <dons> this fact that control structures are lazy means that we don't need control structures in Haskell -- we just write functions
22:49:34 <dons> @type Control.Monad.when
22:49:35 <lambdabot> forall (m :: * -> *).
22:49:35 <lambdabot>         (Monad m) =>
22:49:35 <lambdabot>         Bool -> m () -> m ()
22:49:46 <dons> @type until
22:49:46 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
22:49:48 <dons> and so on
22:50:04 <dons> it's cool and way more fun than filling up the language with control keywords
22:50:10 <jethr0> it also means that you need macros to implement "if", etc in lisp/scheme, because they are also strict
22:50:22 <jethr0> any lazy behaviour will have to be done using macros in them
22:51:30 * jethr0 wonders if one could implement "if" with a C macro
22:51:49 <jethr0> but i guess macros are also bound to be strict
22:52:12 <jethr0> not strict in their arguments, but in their resulting code
22:52:42 <jethr0> dons, have you done any AFRP?
22:55:25 <dons> a student in my group did, he wrote Frag
22:55:27 <dons> @wiki Frag
22:55:28 <lambdabot> http://www.haskell.org/haskellwiki/Frag
22:55:47 <dons> but personally, no.
22:55:57 <jethr0> i know about frag, i'm just struggling with this continuous integration stuff
22:56:38 <jethr0> all i want is to put calculate the velocity to get from the last mouse position to the next. but i'm just too stupid to do it
22:57:24 <dons> have you read Mun's thesis on frag? he mentions stuff like this, I think.
22:57:45 <jethr0> k, i'll have a look at it again
22:59:52 <azuroth> hmm. can you somehow force an autoconf generated configure to just keep going, even though it errors?
23:00:45 <dons> hackthe script, and replace the fatal steps with warnings. then rerun autoconf
23:02:31 <Lemmih> Aren't the errors serious?
23:04:59 <azuroth> Lemmih: I hope not :-)
23:06:47 <jethr0> amazingly enough, AFRP/yampa is even worse documented (i.e. there doesn't even exist an empty haddock docu) than template haskell
23:09:06 <Saulzar> Takes a bit of digging to get going
23:09:30 <jethr0> i have no idea why anyone would write a "framework" without writing _any_ kind of documentation.
23:09:48 <jethr0> most of the implemented functions aren't even mentioned in the three existing papers
23:10:10 <jethr0> Saulzar: there's nothing to dig for. and the code docu just isn't enough
23:10:49 <Saulzar> Between the tutorial and space invaders and the code it's something, but it's tough
23:11:48 <jethr0> yes, i didn't say there was nothing. but i have no idea how to calculate the velocity to get from my last mouse position to the current one using "integral". and that's not really a complex problem
23:12:19 <jethr0> hmm, maybe using derivative...
23:12:23 <Saulzar> Hmm..
23:12:43 <jethr0> yup, that might actually work
23:12:44 <Saulzar> Yeah
23:12:54 <jethr0> now i just have to find out how to use that :'(
23:13:35 <Saulzar> For the thing I'm working on I've mostly scrapped using integral/derivative in favour of manually doing the "simulation" and using yampa purely for events and state (and the controllers)
23:15:18 <Saulzar> I guess deriviative works much like integral (but uses a different function, obviously)
23:15:23 <jethr0> bah, how evil, but i guess it kept you from going crazy. doing a simple mouse motion has drained me of as much energy as writing a whole game would normally have :)
23:15:28 <jethr0> i hope it's worth it
23:16:32 <Saulzar> I had a lot of problems with doing things like collisions, since it requires manipulating object position/rotation in more complex ways
23:17:26 <jethr0> yes, collisions by events alone seems to induce single or even double-frame delays. and i don't quite graps how much code to put into objects versus functions called by the switcher
23:17:42 <jethr0> Saulzar: what are you working on?
23:18:08 <Saulzar> It's a nice idea, definately works well in some cases but to me it is far from perfect for games
23:18:11 <jethr0> originally i wanted to write a tutorial on writing games with yampa. but at this rate that might take a while to complete :(
23:18:20 <azuroth> arrgh. I was using autoconf, not autoreconf?
23:18:44 <Saulzar> jethr0, Robot wars game thingey
23:18:47 <jethr0> hehe, yes annoying problem!
23:18:56 <jethr0> ah, yes, you posted a screenshot lately
23:19:50 <jethr0> Saulzar: i'm early on in finding out how to use afrp. but currently i could imagine writing a jump'n'run game or a small car racing game in it. but optimal might be stretching it a bit
23:20:00 <jethr0> rather a nice exercise in FRP
23:21:09 <jethr0> using derivative and then integral has _no_ effect at all :(
23:21:16 <Saulzar> Clearly the authors of yampa have a mindset which is hard to get "into"
23:22:07 <Saulzar> Hmm, code?
23:23:30 <Saulzar> I intend to write some tutorials on it at some stage, else no one will ever be able to write a robot for the game :)
23:23:58 <jethr0> afrp seems to make easy stuff hard, and hard stuff possible
23:24:04 <Saulzar> Definately
23:24:36 <lisppaste2> jethr0 pasted "yampa" at http://paste.lisp.org/display/17776
23:24:55 <jethr0> it might not make any sense. i'm in the blindly trying everything phase
23:25:14 <jethr0> i just set the position to the mouse position earlier which worked fine.
23:25:38 <jethr0> but for one that's somewhat ugly, and also i want to now the velocity now...
23:25:44 <Saulzar> Hmm
23:25:52 <Saulzar> Looks ok.
23:26:14 <jethr0> it's similar to the gun in the yampa arcade, but i think their code is wrong too and only salvaged by their velocity clamping
23:26:46 <jethr0> well, like this is doesn't even move anymore
23:26:55 <Saulzar> Hmm
23:27:19 <jethr0> in their example they have "let ad = 10 * (xd - x) - 5 * v"
23:27:33 <Saulzar> Can you give a trace on dv?
23:27:49 <jethr0> but i don't see where those arbitrary seeming values 10 and 5 would be coming from
23:28:04 <jethr0> i tried it and it didn't follow the mouse directly either, but only laggingly
23:28:19 <jethr0> Saulzar: i'll try, but i have no idea how trace will work within the arrow "rec"
23:28:27 <Saulzar> They're using some acceleration model
23:28:38 <Saulzar> Which seems to work ok but is horribly bad gameplay :)
23:28:43 <jethr0> yes, but i've tried it that way and it didn't work either
23:29:11 <Saulzar> For simple games trying to do everything physically with integration/derivatives is too much
23:29:25 <jethr0> if i could just figure out a way how to get from the last position and the current position to the velocity *tries-to-kill-himself*
23:29:41 <Saulzar> Wait..
23:30:07 <Saulzar> Everything in that block is recursive, isn't it?
23:30:13 <jethr0> yes
23:30:14 <Saulzar> ie. it's not using _any_ outside behaviour
23:30:19 <Saulzar> rather, outside input
23:30:19 <jethr0> dv is 0 all the time btw
23:30:34 <jethr0> no, it's using the mouse position just above the "rec"
23:30:50 <Saulzar> But you're not using ym
23:30:57 <Saulzar> It's using y again
23:31:05 <jethr0> hmm, might've been the stupid trace artifact of onetime evaluation *grr*
23:31:14 <jethr0> ups
23:31:46 <jethr0> i had that right at some point, but you know the trial-and-error drill, don't you :)
23:31:55 <Saulzar> Don't think it needs to be recursive either
23:32:02 <jethr0> *YES*, it's working now
23:32:10 <Saulzar> Great :)
23:32:27 <jethr0> nope, i don't thinks it's recursive any more
23:32:30 <jethr0> either
23:33:27 <jethr0> thx for your support
23:33:27 <Saulzar> It's certainly interesting, but the delay mechanism in Yampa is quite wierd, 1 frame is not "infintesimal" for practical simulation
23:33:41 <Saulzar> So long as you understand that, it's ok
23:33:55 <jethr0> i know. i think they've been thinking of "improving" that, but i guess it's going to remain a problem
23:34:27 <jethr0> now, i'll be on to complex events (which don't delay more than one frame)
23:36:28 <azuroth> hmm. I hate openal.
23:36:30 <jethr0> and, as i realized when starting to write my last game in python, collision resolution is _way_ more complicated than anyone would ever think before tackling it
23:37:55 <Saulzar> Hehe, yes. Depends how you do it... 
23:38:09 <jethr0> why, is there an easy, foolproof way to do it?
23:38:41 <Saulzar> If you do it roughly, eg. with spheres or bounding boxes I think it can be "ok"
23:39:44 <jethr0> hmm, but i've run again and again into problems of collisions with two other objects in combination with detecting collisions one frame after resolution.
23:39:56 <Saulzar> For pong I guess you can treat the ball like a "line" from past-next location
23:40:05 <jethr0> if you solve it roughly, it becomes totally unrealistic
23:40:12 <jethr0> for pong it's not really a problem
23:40:41 <jethr0> but i want to write a rather more complex/dynamic jump'n'run game at some point
23:41:08 <Saulzar> I have 2 steps, detect collisions apply impules, followed by an iterative "seperation" where objects are projected out of each other
23:41:22 <jethr0> with frequent enough frames and a slow enough ball, even considering current position should be ok
23:41:23 <Saulzar> You could just use bounding boxes for that kind of game maybe
23:41:46 <jethr0> Saulzar: yes, i tried exactly the same. but when you have 3 object colliding at once that poses some evil problems
23:42:09 <Saulzar> Hmm, seems to work ok when there are a few piled up on top of each other
23:43:04 <jethr0> really. how do prevent the "separation" to cause an undetected new collision?
23:43:15 <jethr0> s/to cause/from causing/
23:43:27 <dbremner> jethr0 - IIRC, the Naughty Dog developers had builtin collision support in their custom language.
23:43:28 <jethr0>   (_,dvy) <- derivative <<< iPre zeroVector -< glMousePos mouse
23:43:28 <jethr0>   y <- (y0+) ^<< integral -< dvy
23:44:00 <Saulzar> It iterates until they're not colliding (well, it has a threshold for max penentration depth)
23:44:21 <Saulzar> It's taken me about 5 rewrites to get something which is stable enough
23:44:42 <jethr0> ok, but that can be kinda evil for complex collisions, _and_ does not necessarily terminate in a nice situtation
23:45:15 <Saulzar> Well, I'm not exactly trying to do a commercial physics engine :)
23:45:30 <Saulzar> Provided it's stable and looks "good enough" I'm happy
23:45:31 <jethr0> also, i had problems when bounding boxes touched exactly with their corners. for some strange reason i got _huge_ accelerations out of that ^_^
23:45:42 <Saulzar> Hehe.
23:46:13 <jethr0> i wasn't criticizing. just making my point that collision resolution is non-trivial
23:46:37 <Saulzar> I've been using convex polygons, I think robocode (the original whom I am cop... taking motivation) used symetrical tanks, and circles I think
23:47:04 <Saulzar> Yeah, very much so
23:47:53 <jethr0> there's nothing like stealing^H^H^Hinspiration. i'm amazed you did it with polygons; i was a bit put off by how much more polygons were than bounding boxes
23:47:56 <Saulzar> Though you can certainly hack it for some types of game. I had a platform game when I was learning C which used getPixel and specific colour values to do the collision ;)
23:48:17 <jethr0> yup, that's quite common for early-stage games
23:48:54 <jethr0> i think many of the early console games did (or tried to do) pixel-perfect collisions
23:49:32 <Saulzar> Supprising how it worked at all, whole games ended up less than 500 lines. Trying to do the same thing these days seems to be so much more work
23:49:53 <Excedrin> is using one of the existing physics engines (like ODE) out of the question?
23:50:15 <jethr0> Excedrin: you mean for 2d pong? seems like a bit over-the-top.
23:50:23 <Saulzar> Hehe.
23:50:42 <Excedrin> I wasn't following that it was for pong :P
23:50:44 <jethr0> i've considered it for my jump'n'run game, but considering that i might want non-realistic physics for some objects, it doesn't seem a perfect solution
23:51:08 <Saulzar> Yeah, physics engine adding non physical stuff becomes the headache
23:51:52 <Excedrin> also, I guess arrays of function pointers in C are also lazy? (it's one way to implement an if function..)
23:51:57 <jethr0> stuff like per-object gravity, not colliding with certain objects but still noticing the "collision" might not be so easy with ode
23:52:25 <Saulzar> Hmm, actually I think ODE just tells you about the collision, then you add the contact points
23:52:44 <jethr0> Excedrin: ok, you might have a point there. although it borders on inline assembly :)
23:52:55 <jethr0> execute (if bool then p1 else p2);
23:53:31 <jethr0> ok, i thought it also did some of the resolution and constraints
23:53:47 <Saulzar> It does, but only by the contact points you add
23:54:09 <Saulzar> So I suppose you could just ignore the collision and not add any contacts, and it would penentrate happily
23:54:22 <jethr0> Excedrin: but as you can't create functions inline it would be pretty limited in its use. also typing it might be a problem unless you want to have explicit casts everywhere
23:55:11 <jethr0> Excedrin: i think without the ability to create inline functions i wouldn't consider it as a real "if" alternative
23:57:00 <jethr0> Saulzar: hmm, i might look into that. but openode (or whatever it was called) didn't necessarily look easy to use
23:57:44 <Saulzar> I wouldn't recomend it, think it's often more trouble than it's worth
23:58:24 <jethr0> although i like the demo where you could drop 3 primitive solids and build a huge pile of them *hehe*
