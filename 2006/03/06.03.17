00:01:41 <Blicero_> what does a ' appended to a function name denote?
00:02:09 <sieni> nothing?
00:02:30 <dons> it's just another identifier character
00:02:40 <dons> like a-z A-Z 0-9 or _
00:02:40 <sieni> > let foo' x = x + 1 in foo' 8
00:02:42 <lambdabot> 9
00:05:48 <Blicero_> i was asking what it means in terms of conventions
00:06:15 <Blicero_> like how conventionally a function with a postfix "_" changes the type from m a to m ()
00:06:44 <eivuokko> I don't think there is a strong convention.
00:08:42 <dons> it's often used to name an alternative version of a function
00:08:48 <dons> or a somehow "2nd" version of something
00:08:53 <dons> let x = 2 in let x' = x + 1 ..
00:08:57 <dons> for example
00:09:10 <dons> sometimes ' means a function is 'strict' 
00:09:15 <dons> we have foldl and foldl'
00:09:34 <dons> those are the two conventions i can think of atm, and the first is the more common by far
00:10:17 <dons> so, when you see ' on a library function in the prelude, it means 'strict'. everywhere else it probably means 'alternative version'
00:10:56 <Cale> of course, a strict version is kind of an alternative version too
00:11:47 <dons> so yes, that also captures the notion of 'alternative version' 
00:12:04 <dons> hey Cale, 2 days no irc :)
00:12:14 <Cale> I've been here
00:12:27 <Cale> maybe just not talking so much
00:12:33 <dons> well, I couldn't say "long time, no see" since i've just not seen you in 2 days
00:12:37 <dons> :)
00:12:54 <dons> \localtime dons
00:12:58 <lambdabot> Local time for dons is Fri Mar 17 19:13:08 2006
00:13:00 <dons> hometime!
00:13:07 * dons <- out
00:13:12 <Cale> later
00:51:59 <mathrick> \localtime mathrick 
00:52:00 <lambdabot> Local time for mathrick is Fri Mar 17 09:57:05
00:52:15 <mathrick> heh, fancy name for /CTCP TIME
01:39:11 <ct16k> it there a way to find out the type of some content at runtime?
01:48:21 <ibid> ct16k: why do you want to do that?
01:48:40 <ibid> (iow, not directly. there are ways around it for specific situations, though)
01:56:26 <ct16k> practice :)
01:56:55 <ct16k> i was thinking maybe something with classes
01:57:12 <ct16k> as each operator is defined for each type, as far as I understood
01:57:56 <ct16k> and use that to identify the type, and return it in a string, for example
01:58:34 <ct16k> but I haven't really began studying classes in haskell
02:00:31 <Lemmih> > let g fn x = fn x in (g succ 10, g succ 'a')
02:00:33 <lambdabot> (11,'b')
02:00:41 <Lemmih> ^^ 'g' doesn't inspect the type of 'x'.
02:02:13 <Lemmih> You can think of 'show x' as short of 'show fn_for_showing_x x'.
02:04:16 <ibid> ct16k: yeah, that you can do if you're willing to restrict the types that you can do that to :)
02:04:25 <ibid> restrict the set, that is
02:07:04 <ct16k> of course some restrictions will exist, but I think i can work just fine with the default types (int, char, string...)
02:07:27 <ct16k> i=it
02:16:10 <ct16k> humm... I gotta go. I'll work on this ideea, and for sure ask for some more help later, when I get to the implementation
02:38:07 <KOC> hello all. i installed ghc from a gentoo package, but I don't seem to have a 'runhaskell
02:38:29 <wilx> runghc?
02:38:30 <KOC> ' - is this a gentoo problem?
02:38:46 <KOC> no runghc either
02:40:01 <KOC> is it possible to install separately or do i need to check with the gentoo packagers?
02:40:17 <int-e> dev-lang/ghc-6.4.1-r2 installs a runhaskell in /usr/bin
02:40:27 <mathrick> KOC: did you do ./configure && make?
02:40:37 <mathrick> it's a binary distro, but still needs them
02:40:41 * mathrick fell for that
02:40:54 <mathrick> wait
02:40:58 <mathrick> gentoo package
02:41:01 <mathrick> n/m then
02:41:39 <KOC> oh that explains it
02:41:55 <KOC> i need to either unmask the latest version or install it myself
02:42:01 <int-e> I don't know about earlier packages or the binary one.
02:42:17 <kosmikus> KOC: which package did you install? there should be a runhaskell and a runghc ...
02:42:25 <KOC> ghc-6.2.2
02:42:35 <KOC> hugs didn't install a runhugs either
02:42:42 <KOC> forget if it's supposed to
02:43:35 <kosmikus> KOC: ghc-6.4.1 should have runghc, hugs98-2005.3 should have runhugs
02:43:50 <KOC> yeah i dont have that version; it's "unstable"
02:44:02 <KOC> thanks; i think i'll remove the pacakges and do it from scratch
02:44:16 <kosmikus> KOC: it's in a testing phase which is nearly over now.
02:44:29 <kosmikus> KOC: doesn't automatically mean it's unstable.
02:44:47 <mathrick> "An Introduction to Gtk2Hs" http://haskell.org/~shae/memory.pdf
02:44:58 * mathrick senses slight issues with filenames
02:45:51 <mathrick> ah, it's because it's Memory game
02:46:51 <KOC> kosmikus, so the highest version gentoo packages are decent?
02:50:38 <kosmikus> KOC: yes.
02:50:48 <KOC> sweet
02:50:49 <kosmikus> oh well.
02:50:54 <kosmikus> not generally, maybe.
02:50:59 <kosmikus> but for ghc and hugs98, they are.
02:51:21 <KOC> i know the bug masking wxhaskell was figured out but not patched in portage
02:51:36 <kosmikus> ?
02:51:53 <KOC> something with wxGTK
02:52:15 <kosmikus> that's fixed, isn't it?
02:53:26 <KOC> perhaps it has been
02:53:53 <KOC> oh it wasnt as of like 2 days ago
02:53:59 <KOC> shows how well i pay attention
02:59:14 <shawn> join #ocaml
03:06:08 <ValarQ> shawn: why?
03:06:19 <shawn> because I forgot the leading /
03:06:31 <ValarQ> i see
03:06:42 <kosmikus> that's a good reason
03:35:07 <dcoutts> KOC, yeah the wxGTK bug blocking wxhaskell only just got fixed a day or two ago
03:48:25 <lightstep> hello. i'm trying to feed a simple CPS into a type checker, but somehow i get it wrong. can someone help me with this? http://paste.lisp.org/display/17970
03:48:54 <lightstep> i think the type of "with" is wrong, but i don't understand why
03:53:59 <lightstep> oh, i was just missing parenthesis, so haskell parsed it wrong
04:03:09 <tic> Claim: Haskell's not usable for real-world applications, because of its lazy evaluation. Proof: Have a look at GHC and the explicit seq'ing everywhere.  Who's up for saying I'm wrong?
04:03:59 <lightstep> tic, doesn't ghc prove that haskell is usable? perhaps the argument iss against having lazy evaluation as the default mechanism?
04:04:07 <eivuokko> You claim ghc is not usable?
04:04:48 <dcoutts> tic is that seq'ing in the low level libs or in ghc proper?
04:05:31 <vincenz> Claim: Haskell's not usable for real-world applications because it's a higher level langauge.  Proof: Have a look at GHC, it converts everything to assembly
04:05:45 <tic> dcoutts, I was discussing this with a PhD student who's working on Haskell analysis and verification, and after using it for 5 years, he's come to terms with it not being all that great, especially given the evidence of GHC. Now, he didn't say /where/, but he said there were a lot of these seq's everywhere.
04:06:02 <tic> vincenz, I'm not hostile. :) I'm trying to have an interesting discussion here. :)
04:06:12 <vincenz> I was just adding a humourous note :D
04:06:24 <tic> Ah.
04:06:29 <vincenz> tic: I've actually been considering a language with haskell type system but strict eval as default and an oo like syntax
04:06:32 <vincenz> something like
04:06:36 * ValarQ searches for seq's
04:06:48 <tic> vincenz, greenspun has a nice quote about that.
04:06:50 <vincenz> > let (...) = flip($) in [1,2,3]...reverse...map (+1)
04:06:51 <lambdabot> [4,3,2]
04:07:05 <dcoutts> tic, so there's some truth to lazyness by default not being perfect, but I don't think it shows that strict by default is the better choice. We need easier ways of adding strictness/lazyness and tools for understanding when/why it's useful.
04:07:41 <vincenz> > let (...) = flip($) in [1,2,3]...reverse...map (+1)...filter (>2)
04:07:42 <lambdabot> [4,3]
04:07:43 <tic> dcoutts, agreed.
04:08:04 <eivuokko> Evaluation control is problem in almost all languages, in my experience
04:08:08 <dcoutts> strictness/lazyness is often about ordering the actions in a cmputation for greatest effeciency. This is hard.
04:08:19 <tic> so, in a lot of cases lazyness gives you memory leaks
04:08:38 <vincenz> shouldn't we then focus on memory instead of the laziness
04:08:41 <dcoutts> it's just that in Haskell you can get away with not having to address it up front like you would in C
04:09:22 <sieni> naah, haskell is cool as... well... intercourse!
04:10:10 <JKnecht> better.
04:10:17 <tic> okay, you guys seem to know a bit.. Functional vs OOP, both say it's The End-All, Be-All. But are the two styles really mutually exclusive?
04:10:43 <dcoutts> one can code in an OOPy style in Haskell
04:11:02 <tic> how about inheritance?
04:11:03 <lightstep> tic, it depends what OOP means
04:11:17 <vincenz> tic: ocaml combines both
04:11:21 <tic> vincenz, k..
04:11:29 <tic> I'll have to look it up a bit, I guess. (iffy syntax though.)
04:11:31 <tic> Thanks!
04:11:49 <vincenz> I did miss typeclasses in haskell however
04:11:55 <vincenz> modules in the way they do it is seriously verbose
04:12:21 <lightstep> the usual model of single dispatch and sequential evaluation of methods isn't much more than nice syntax
04:12:22 <dcoutts> ie with lots of runtime decisions on which function to call (records of closures) rather than the more  natural Haskll style which makes static decisions on which function to call (type classes)
04:12:50 <vincenz> dcoutts: ocaml does both
04:13:07 <vincenz> either way
04:13:11 <dcoutts> you mean parameterised modules
04:13:13 <vincenz> oop and typeclasses are disjoint decisions
04:13:25 <vincenz> one is objectclasse,s the other is typeclasses
04:13:34 <vincenz> one applies classes to objects, the other to types, those are orthogonal
04:14:05 <vincenz> and do not fill the same shoe
04:14:10 <dcoutts> true, but in OOP languages you always use the classes of objects even when the classes of types might be more suitable
04:14:41 <dcoutts> think of all the uses of classes/objects in Java and see how they'd partition into different features in Haskell
04:14:51 <Saulzar> Hmm, OCaml does objects in an imperitive style right? Meant to be used with mutable values etc.?
04:14:58 <dcoutts> some become type classes, some records, some exestential thingies
04:15:00 <vincenz> Saulzar: yes
04:15:42 <Saulzar> I have a feeling there will be some comprimise between the two, it does not feel to me that OO and functional programming are at odds with each  other
04:15:59 <dcoutts> oh and one last on: in java you use objects to simulate lazyness (delayed evaluation)
04:16:10 <vincenz> Saulzar: they're orthogonal
04:16:27 <vincenz> dcoutts: to me that's an implementation issue that is no longer part of the language
04:16:29 <Saulzar> Yeah, but implementation aspects aren't entirely
04:16:55 * vincenz thinks that some language should approach it that way
04:16:56 <lightstep> vincenz, what does that mean? can you combine them? in most languages, you need to wrap a method in a closure to use it
04:17:04 <vincenz> drawing paralelels betewene objectclasses and typeclasses
04:17:36 <vincenz> lightstep: methods are first class values, and they're bound to an object with the # operator in ocaml
04:25:12 <Maddas> If you don't mean purely functional, e.g. Common Lisp has a sophisticated object system.
04:25:55 <Maddas> And there's OOHaskell, not that I know anything about it.
04:26:14 <vincenz> clos is not typed
04:26:22 <Maddas> vincenz: Huh?
04:27:58 <nnunley> It's optionally typed, no?
04:28:16 <vincenz> it's not built starting from a type-system
04:28:17 <vincenz> afaict
04:28:51 <Maddas> The class system and the type system are different (though intertwined) things in CL, afaik.
04:29:12 <Maddas> (Which makes sense to me, a subclass and a subtype aren't the same thing)
04:31:45 <vincenz> darcs is so COOL
04:31:57 <vincenz> Maddas: well in a way
04:31:59 <kpreid_> all of Haskell's types are what CLOS would consider classes
04:32:14 <vincenz> you can draw paralleles between typeclasses and objectclasses, except that typeclasses reside one level higher in the chain object -> type -> kind
04:33:38 <lightstep> what is a rigid type variable?
04:34:10 <Maddas> kpreid_: How so? I don't understand the analogy since to me, the two things (Haskell and CL/CLOS) are too different.
04:34:57 <kpreid_> well, perhaps so, but what I meant is that Haskell's type system doesn't include the kinds of things you can express in CL as types that aren't classes
04:35:13 <Maddas> Right.
04:35:16 <kpreid_> (range restrictions, (or cons null), etc)
04:35:27 <Maddas> (And arbitrary tests in general)
04:35:39 <vincenz> kpreid_: I also think it's because CL's typing isn't very stric
04:35:42 <Maddas> kpreid_: But you can't easily express all Haskell types as CLOS classes either, can you?
04:36:03 <Maddas> vincenz: What do you mean with strict? Static vs dynamic or strong vs weak?
04:36:09 <kpreid_> maddas: I think my answer to that is I agree they're too different :)
04:36:15 <Maddas> kpreid_: ok :-)
04:36:16 <dcoutts> Who wants to hack on the binutils bfd library? I don't like the fact that it kills one's machine when ghc invokes ar to build libHSbase.a
04:36:20 <vincenz> Maddas: strong
04:36:23 <vincenz> besides
04:36:26 <Maddas> vincenz: AFAIK it's strong...
04:36:27 <vincenz> dynamic typing imho is not typing
04:36:33 <kpreid_> heh, heh
04:36:42 <kpreid_> there are really at least two things called "types"
04:36:51 * dcoutts looks about for a C hacker who cares about ghc
04:36:54 <Maddas> kpreid_: Even more, I suspect.
04:36:58 <dcoutts> http://sourceware.org/bugzilla/show_bug.cgi?id=2467
04:38:42 <Maddas> vincenz: Everyone to his own, I prefer to stick to common (but reasonable) 'definitions' of typing, since there's already enough confusion as is.
04:40:00 <vincenz> Maddas: why do I not think it's typing ... you basically switch on an object id...
04:40:03 <vincenz> anyways
04:40:04 <vincenz> it's am oot point
04:40:07 <vincenz> I just thought of somethin
04:40:13 <vincenz> anyone here work in the industry?
04:40:19 <vincenz> (as developer)
04:40:53 <Maddas> vincenz: Yes, but isn't static typing basically the same, just at compile-time?
04:40:59 <kpreid_> the most fundamental difference between the two 'type' systems is that CL has types which are this-or-that, and the 'anything' type T, whereas in Haskell, you just can't express that (but can do things like the Monad type class - you can't write "return" in CL)
04:41:02 <Maddas> It's a very general process you described :-)
04:41:15 <vincenz> Maddas: not really
04:41:29 <vincenz> Maddas: besides it's on expressions, not values
04:41:31 <kpreid_> s/fundamental/significant/
04:41:46 <Maddas> vincenz: You didn't mention either in your first statement.
04:41:51 <vincenz> so
04:42:03 <vincenz> back to the idea that occurred to me, anyone here an industry developer?
04:42:09 <chris2> is there a tool like lhs2tex with xhtml output?
04:42:19 <Maddas> kpreid_: Hmmm... ;-)
04:42:20 <vincenz> preferably using XP methodolgy?
04:42:34 <kpreid_> Maddas: I have the feeling what I said is probably wrong :)
04:42:53 <vincenz> Maddas: the difference is that dynamic typing often falls into ducktyping... look at for instance ruby-objects
04:43:07 <vincenz> and ducktyping isn't really typing, cause any object can have a zillion different types
04:43:24 <kpreid_> duck typing is a concept that applies only to message-passing systems
04:43:39 <Maddas> vincenz: Yes, but I think it's important to be as precise as reasonably possible here.
04:44:08 <mathrick> vincenz: ducktyping doesn't mean lack of typing
04:44:24 <Maddas> You'll find degenerate cases of static tying too, in any case.
04:44:24 <mathrick> it fills the same role (in part at least) as type variables do
04:44:28 <vincenz> mathrick: that is subjective
04:44:38 <mathrick> every ducktyped object is strongly typed
04:44:39 <kosmikus> chris2: not that I know of, but these guys (http://sneezy.cs.nott.ac.uk/QML/weblog/) have written a plugin to embed lhs2tex output in HTML
04:44:40 <vincenz> mathrick: in ducktyping you can coerce yourobject to be anything
04:44:45 <mathrick> vincenz: no
04:44:49 <vincenz> which basically invalidates the purpose
04:44:55 <vincenz> mathrick: sure, just make sure it has the methods
04:45:00 <mathrick> this is a clearly incorrect statement
04:45:17 <chris2> kosmikus: better than nothing. thx!
04:45:18 <mathrick> vincenz: depends on how you implement your ducktyping
04:45:22 <Maddas> vincenz: But static type systems can also allow you to coerce things to anything without being dynamic due to that.
04:45:31 <mathrick> it's not about methods more than anything else
04:45:42 <Maddas> vincenz: I think there's a mutual disagreement on the exact meaning of static, dynamic, strong and weak at work here :]
04:45:44 <vincenz> Maddas: only if you explicitly make it so
04:45:57 <mathrick> vincenz: what you say with ducktyping is "I don't care about the exact type, as long as it fills the contract"
04:45:57 <vincenz> c++ isn't strongly typed, so sure you can cast
04:46:00 <vincenz> in haskell you can not cast
04:46:05 <mathrick> compare to Num class for instance
04:46:05 <Maddas> vincenz: I can also give you a dynamic type system where you cannot cast.
04:46:07 <vincenz> except iwth functions that were made to be such
04:46:10 <mathrick> vincenz: neither can you in Python
04:46:14 <mathrick> which is dynamically typed
04:46:25 <mathrick> dynamically *and* strongly
04:46:41 <vincenz> mathrick: I disagree... just change it's internal dict and it'll behave like a different "type"
04:46:45 <vincenz> note the quotes
04:46:48 <kpreid_> "strong" is a lousy term, because "weak" is poorly defined
04:47:00 <vincenz> OR
04:47:05 <vincenz> you can say that pythong is strongly typed
04:47:08 <vincenz> but there is only one type
04:47:10 <vincenz> the dict type
04:47:18 <mathrick> vincenz: you *cannot* make dict be anything else, no matter how hard you try
04:47:19 <vincenz> in which case I agree, but in which case the typing system is rather useless
04:47:27 <Maddas> kpreid_: Indeed, and all these terms have been so 'misused' so widely that I long ago gave up hope to find a definition most people would agree on.
04:47:34 <vincenz> mathrick: everything is a dict
04:47:43 <vincenz> mathrick: kinda makes the point moot
04:47:46 <mathrick> vincenz: that's an implementation detail
04:48:00 <vincenz> not really
04:48:04 <mathrick> ducktyping in no way requires you to have everything as a dict
04:48:14 <vincenz> mathrick: you switched context to python, I follow
04:48:18 <vincenz> please stick to linear arguments
04:48:34 <mathrick> vincenz: yes, because that's a language I know, which is both strongly and dynamicall typed
04:48:36 <vincenz> don't use one side to prove a point on another track
04:48:49 <mathrick> but python is just an example
04:48:55 <vincenz> mathrick: it was a bad example
04:48:59 <vincenz> cause it did not illustrate dynamic typing
04:49:06 <vincenz> you went to the core value of python, which is a dict
04:49:08 <vincenz> in fact everything is a dict
04:49:12 <vincenz>  so yes, you can't not make it a dict
04:49:19 <mathrick> you're now trying to prove that, because inpython the contract is implemented in terms of methods available, ducktyping precludes strong typing in some way
04:49:20 <vincenz> but at the slightly higher level
04:49:22 <mathrick> which is not valid
04:49:23 <vincenz> where some dicts are numbers
04:49:25 <vincenz> and some dicts are lists
04:49:32 <vincenz> you can coerce them to be one or the other
04:49:52 <mathrick> vincenz: by breaching the basic assumptions of the language, yes
04:49:57 <vincenz> not really
04:50:07 <mathrick> but you still won't be able to do C-style cast
04:50:09 <vincenz> just define for instance objkect.__len__
04:50:12 <vincenz> or object.__at__
04:50:14 <vincenz> and voila
04:50:15 <vincenz> it's a list
04:50:32 <mathrick> vincenz: that means nothing else than making its type an instance of Num or Eq class
04:50:33 <Maddas> It's more useful to categorize languages on a line between dynamic and static than using an either/or approach.
04:50:37 <mathrick> you can do that in Haskell
04:50:43 <mathrick> does that mean coercing anything?
04:50:44 <vincenz> mathrick: no it doesn't
04:50:57 <vincenz> Maddas: I agree
04:51:23 <Maddas> You can also simulate dynamic dispatch in Haskell, for example (IIRC).
04:51:31 <mathrick> vincenz: the point is, static/dynamic and strong/weak are orthogonal axes
04:51:37 <vincenz> I never claimed otherwise
04:51:41 <mathrick> C is both static and weak
04:51:47 <lightstep> mathrick, the difference is that in haskell, you can assure that you have or don't have the Num context at each point in the code
04:51:48 <mathrick> python is dynamic and strong
04:52:07 <mathrick> lightstep: because it's static
04:52:16 <tuomov> you make it sound like dynamic was good with that statement :)
04:52:27 <mathrick> who does?
04:52:30 <Maddas> Let's not start another flame war about good and bad :-)
04:52:30 <vincenz> to me it's
04:52:43 <vincenz> mathrick: what is an example of a weak dynamically typed system?
04:52:45 <vincenz> there is none
04:52:47 <vincenz> cause that would mean there are bugsg
04:52:51 <mathrick> yes
04:52:55 <tuomov> mathrick: you. considering dynamic in the everyday sense of the word
04:53:02 <tuomov> "dynamic and strong", "static and weak"
04:53:07 <vincenz> meaning dynamically typed makes the "orthogonal" access have length 0
04:53:08 <vincenz> aka
04:53:12 <vincenz> dynamically typed = lack of typing
04:53:19 <mathrick> tuomov: yes, I don't see anything invalid about it
04:53:23 <Maddas> tuomov: That the words have other connotations is pretty normal.
04:53:24 <mathrick> being dynamic is a choice
04:53:33 <tuomov> mathrick: it was a joke. laugh.
04:53:44 <Maddas> heh.
04:53:48 <mathrick> heh
04:54:05 <tuomov> I'm not a fan of dynamic aka. timebomb typing, btw.
04:54:38 <lightstep> tuomov, you have partial functions in haskell, too
04:54:44 <Maddas> tuomov: You're just asking for someone to call static typing 'timesink typing' or something like that.
04:55:07 <tuomov> with type inferene it isn't
04:55:08 <tuomov> +c
04:55:33 <tuomov> dynamic typing requires thorough testing of everything. testing sucks.
04:55:36 <mathrick> tuomov: try defining a generalised n-dimensional matrix pointwise addition
04:55:39 <Maddas> tuomov: Many people disagree.
04:55:41 <mathrick> you can't
04:55:44 <Maddas> (On the former statement)
04:55:45 <lightstep> tuomov, why is doesNotUnderstand worse than error "Prelude.head"?
04:55:51 <mathrick> because of static typing in haskell
04:55:59 <tuomov> runtime vs. compiletime
04:56:02 <Maddas> tuomov: The worst timesink and timebomb of all are these kind of discussions :-)
04:56:16 <tuomov> It sucks when the user has to find a typing nerror
04:56:23 <lightstep> mathrick, actually, you can
04:56:36 <lightstep> mathrick, make is polymorphic in the index type
04:56:43 <lightstep> s/is/it/
04:56:55 <tuomov> mathrick: and yeah, I'd like depedently-typed matrices
04:56:57 <Maddas> tuomov: It sucks when the developer has to find a typing error. These arguments don't really help much (Yes, I know what you mean)
04:57:19 <tuomov> dynamic typing means there are more chances of the user running into problems
04:57:24 <tuomov> and the user shouldn't run into those
04:57:28 <Maddas> Right, but you get more dimensions of freedom.
04:57:32 <Maddas> (As a developer)
04:57:35 <MarcWeber> Any idea why i get this error when trying to compile hs-plugins? http://www.rafb.net/paste/results/4vZnrE89.html in src/AltData/Typable.hs
04:57:37 <mathrick> tuomov: noone ever said you don't have to test
04:57:49 <mathrick> if you can't handle dyntyping, don't use it
04:57:53 <mathrick> it's a tradeoff
04:57:55 <tuomov> and a static type system is a very good testing system!
04:57:55 <mathrick> not a flaw
04:58:13 <Maddas> tuomov: 'static' type systems in general (widely-used ones) aren't anywhere as complete as Haskell's, and 'static' doesn't imply having all the goodies.
04:58:40 <tuomov> weak is bad too
04:58:50 <Maddas> But sometimes very convenient.
04:58:54 <tuomov> weak allows implementing dynamic typing :)
04:59:19 <Maddas> FSVO dynamic typing :-)
04:59:49 <tuomov> mathrick: I didn't say I can't handle it. I said most developers can't, and I have to use their shit.
05:00:02 <mathrick> tuomov: *shrug*
05:00:03 <Maddas> I prefer to use whatever is best for a given problem, and I don't believe that any current solution is best for all.
05:00:10 <tuomov> a typing error is a _very_ common reason for a python program to fail
05:00:46 <mathrick> sloppy haskell programmer OTOH will just say "fuck this shit" and do something else
05:00:51 <mathrick> instead of finishing his app
05:01:02 <mathrick> so indeed, you won't have to use his shit :)
05:01:05 <tuomov> it will get rid of shitty software, so it's good
05:01:15 <Maddas> This is becoming fairly ridiculous :-)
05:01:19 <mathrick> it is
05:01:36 <tuomov> runtime typing error is the new segfault.
05:01:46 <mathrick> heh
05:01:51 <Maddas> I've had my share of programs failing to compile, too.
05:02:19 <tuomov> yeah, we got rid of segfaults by switching from C to python etc., but the situation didn't change to any better.
05:03:00 <Maddas> Maybe not for you. I find these sweeping generalisations offensive, to be honest.
05:03:19 <tuomov> good that you do
05:03:22 <Maddas> No.
05:05:27 * Saulzar mentions the Nazi's
05:05:46 <Saulzar> Er, no ' :)
05:05:47 * Maddas invokes Bob the angry flower
05:05:49 * lightstep cheers
05:05:55 <Maddas> Bah, too late :-)
05:06:01 <beelsebob_> I AM NOT AN ANGRY FLOWER!
05:06:06 <beelsebob_> I AM ANGRY FLOUR!
05:06:19 <Maddas> Same sound, same thing!
05:06:29 <beelsebob_> hehe
05:10:10 <dons> \remember tuomov runtime typing error is the new segfault.
05:10:11 <lambdabot> Done.
05:11:31 <mathrick> also, I fully support the movement to make lazy evaluation smarter
05:11:44 <mathrick> it's way too easy to hit OOM with simple fibonacci
05:12:00 <mathrick> which should in theory work just fine for arbitrarily large arguments
05:12:32 <dons> space leaks are pretty easy to spot these days. we have standard tools.
05:12:45 <dons> they've never very troublesome to track down
05:13:08 * dcoutts finds them harder to track down in C code
05:13:16 <mathrick> can you have more than one return () in a do block?
05:13:33 <mathrick> what are those standard tools?
05:13:38 <dons> > do return () ; return () 
05:13:39 <lambdabot>  add an instance declaration for (Show (m ()))
05:13:54 <dcoutts> mathrick, return doesn't return in they way you imagine
05:13:54 <dons> mathrick, the profiling flags to ghc. -prof -auto-all
05:14:16 <mathrick> dcoutts: I know, but what is the meaning of a double return?
05:14:36 <dcoutts> mathrick, it depends how they're combined
05:15:00 <dcoutts> in dons's example (return () >> return ()) we just get the value of the second
05:15:10 <Saulzar> > do return Nothing; return 5
05:15:11 <lambdabot>  add an instance declaration for (Show (m a))
05:15:16 <dcoutts> @type return () >> return ()
05:15:17 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
05:15:20 <Saulzar> Hmm, whoops :)
05:15:21 <tibbe> I need a Map that has O(1) lookup, the one in Data.Map is O(log n)
05:15:22 <dcoutts> @type return 3 >> return ()
05:15:23 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
05:15:25 <mathrick> well, it's not so much a double return as a return () followed by more lines of code in what I'm looking at
05:15:35 <dons> tibbe, an array then?
05:15:42 <dons> or a hashtable.
05:15:49 <dons> Data.Array, Data.HashTable
05:15:56 <mathrick> dcoutts: >> ?
05:16:00 <mathrick> isn't that a >>= ?
05:16:05 <tibbe> dons, yeah basically, I need a lookup table to record all words in a list and then check if a given word appears in a list
05:16:08 <dcoutts> @type (>>)
05:16:09 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
05:16:18 <dons> though, tibbe, is the map a serious bottleneck?
05:16:34 <dons> i'd try it with a map first, since that code is easy to write.
05:16:35 <dcoutts> mathrick, (>>) is like (;) in imperitive languages
05:16:43 <tibbe> dons, yes, I'm saving permutations so I have n! of em
05:16:48 <dons> if then its a problem, switch to an array or similar
05:17:01 <mathrick> dcoutts: I know, but I thought do clauses were joined by >>=
05:17:12 <mathrick> not >>
05:17:15 <dcoutts> mathrick, (>>) is a special case of (>>=)
05:17:24 <mathrick> and yes, I know that >> is a special case of >>=
05:17:28 <mathrick> dcoutts: yes
05:17:36 <mathrick> still, >>= is more general
05:18:12 <tibbe> dons, it would be nice to use a prebuilt datastructure though, I need a fromList and a member function
05:18:14 <mathrick> although probably in the case of return () >>= return () it doesn't matter that much
05:18:36 <lightstep> mathrick, so you sould know that do{return();return()}==(return()>>=\_->return())==((\_->return())())==return()
05:18:53 <Saulzar> That won't pass the type checker, since >>= binds the result of the first to an arguement of the second..
05:18:58 <Saulzar> and return () doesn't take an argument
05:19:12 <mathrick> lightstep: I find your syntax thoroughly confusing
05:19:17 <dcoutts> mathrick, (do { x <- f; ... }) translates into (f >>= \x -> ...) and (do { f; ... }) translates into (f >> ...)
05:19:33 <Saulzar> return () >> return ()   is the same as return () >>= \_ -> return ()
05:19:37 <mathrick> dcoutts: oh
05:19:42 <dcoutts> so do { return 3; return () } = return 3 >> return ()
05:19:50 * mathrick notes
05:20:13 <mathrick> so return () inside an if / else is basically a NOOP?
05:20:19 * mathrick gains enlightenment
05:20:20 <dcoutts> the difference is if we're binding a value to the result or if we're just running the action for its side effects
05:20:29 <Saulzar> Yep
05:21:26 <ibid> mathrick: return () is a NOOP everywhere expect in the tail position of a function
05:21:54 <mathrick> mhm
05:22:00 <ibid> (which makes it rather unfortunately named)
05:22:07 <mathrick> indeed
05:22:12 <Saulzar> Hmm, is it possible to cause some side effect as a result of including return ()?
05:22:13 <lightstep> as well as any other return
05:22:28 <ibid> lightstep: agreed
05:22:32 <mathrick> wrap () would be more appropriate
05:22:46 <dcoutts> Saulzar, depends on the definition of your monad
05:22:48 <ibid> Saulzar: i think the monad laws essentially forbid it
05:22:59 <ibid> mathrick: or bless () :)
05:23:12 <mathrick> :D
05:23:22 <mathrick> levelup ()
05:23:37 <mathrick> *levelUp, to use camelCase
05:23:40 <dcoutts> ibid, is it possible to have a monad that counts evaluation steps? or would that violate the monad laws
05:23:59 <dcoutts> ibid, eg each use of >>= increases a count
05:24:01 <Saulzar> Hmm
05:25:10 <ibid> dcoutts: return a >>= k === k a
05:25:14 <ibid> dcoutts: is one law
05:25:36 <dcoutts> right, so no then
05:25:41 <mathrick> #haskell is the best example of the validity of claims that monads are inherently hard to understand
05:25:59 <mathrick> because of their sheer flexibility and versatility
05:26:11 <ibid> monads aren't hard to understand, they're just taught the wrong way most of the time
05:26:59 <mathrick> ibid: they are, because they require changing the way you think entirely
05:27:11 <mathrick> this is not to say they are impossible to understand
05:27:38 <ibid> well, ok, there's a lot of levels to understanding monads, but most of the confusion one sees on this channel stems from prejudice ("everybody tells me monads are hard, so they must be hard") and from bad documentation ("too much too soon")
05:27:43 <mathrick> just that it takes a considerable effort to 1) shake off old habits 2) wrap (return ;) your head around all the possibilities
05:27:55 <ibid> i myself am frequently quilty of the latter
05:28:14 <mathrick> ibid: I heard a lot about monads, and everyone in here seemed eager to commit sin #2
05:28:24 <mathrick> so I just took and started reading about them
05:28:39 <mathrick> essentially ditching 70% of Bird in between
05:28:44 <mathrick> I'm glad I did
05:28:55 <mathrick> but I still have only very limited idea about monads
05:29:21 * mathrick is around the corner of truly grasping State monad
05:29:43 <Saulzar> Pays not to try understanding everything, they seem to be much simpler with a bit of practice at normal Haskell stuff
05:29:43 <sieni> the container analogy is nice
05:30:11 <ibid> mathrick: i mean, sure the full generality of monads is a lot to take on one sitting, but a lot of the confusion here are much more basic, created by sin#2
05:30:45 <sieni> sin #2?
05:30:56 <lightstep> mathrick, i think the gadt approach to monads is really good
05:30:59 <Saulzar> Trying to understand Monads the Universe and everything all at once
05:31:12 <mathrick> sieni: <ibid> well, ok, there's a lot of levels to understanding monads, but most of the confusion one sees on this channel stems from prejudice ("everybody tells me monads are hard, so they must be hard") and from bad documentation ("too much too soon")
05:31:21 <ibid> Saulzar: trying to *teach*, more to the point
05:31:26 <mathrick> lightstep: gadt?
05:31:41 <lightstep> generalized algebraic data type
05:31:49 <Saulzar> Hmm, true. But there are some good references out there
05:32:17 <lightstep> a very confusing name to a simple and (in hindsight) obvious syntax and idea for ADTs
05:32:34 * mathrick dunno about ADT either
05:32:42 <mathrick> so it tells me nothing :)
05:32:46 <dons> in hindsight obvious, i've thought that too
05:33:01 <Saulzar> A lot is really baffling to a Haskell newbie because it's simply hard to read the code. At least it used to be really mind bending to me to sit and look at some of the code in examples
05:33:10 <ibid> mathrick: i found that if i taught my students "haskell as a quirky imperative language" first, before exposing them to all the neat functional stuff, the students 1) got it pretty fast, and i didn't see much of the usual "return"/"do" confusion and 2) they still had no more problems than usual to get the juicy functional stuff
05:33:11 <mathrick> most ingenious solutions are obvious in the hindsight
05:33:17 <Saulzar> Not because the monads were tricky, but I couldn't read the Haskell very well
05:33:19 <lightstep> mathrick, like Tree a = Leaf a | Node (Tree a) Int (Tree a)
05:33:45 <mathrick> Saulzar: agreed
05:33:55 <ibid> hrm, PLEASE don't use "ADT" for ALGEBRAIC data type, it's a (semi)standard acronym for ABSTRACT data type
05:34:00 <mathrick> lightstep: put another way, what is an ADT, in few words?
05:34:20 <mathrick> haha, I'm just writing an article
05:34:28 <mathrick> and reading Gtk2HS intro
05:34:38 <dcoutts> mathrick, which one?
05:34:55 <mathrick> dcoutts: the one in Monad.Reader
05:34:56 <mathrick> #1
05:35:00 <ibid> mathrick: an algebraic data type is any Haskell data type that's declared using the "data" keyword
05:35:11 <lightstep> mathrick, algebraic data type is that thing with a tagged union and many fields
05:35:20 <ibid> mathrick: in technical terms, it's a tagged union of products :)
05:35:34 <mathrick> aha
05:35:41 * mathrick digests that long, scary name
05:35:48 <dcoutts> mathrick, there's another new one on the gtk2hs web site front page
05:35:48 <Saulzar> ibid, There seems to be a pretty strong prejudice against Haskell amongst people have learned Haskell in a course
05:36:01 <mathrick> dcoutts: that's the one, I believe
05:36:05 <mathrick> memory game
05:36:12 <dcoutts> mathrick, I mean a new one
05:36:17 <lightstep> mathrick, here's a State minad with this technique: http://lambda-the-ultimate.org/node/290#comment-2210
05:36:20 <ibid> Saulzar: sure there is, as there is for anything else people learn in a course that doesn't have an immediate job prospect effect :)
05:36:28 <Saulzar> Hehe.
05:36:43 * mathrick is learning haskell in a course *and* for fun
05:36:52 <mathrick> should I feel exceptional?\
05:37:00 <ibid> mathrick: there are always us geeks ;)
05:38:48 <ibid> mathrick: (yes, you should feel special;)
05:40:37 <ibid> Saulzar: like, how many students don't curse, say, push-down automata after taking that course? :)
05:40:51 <ibid> (assuming, of course, that they still remember the name after the exam;)
05:41:13 <mathrick> what's hard and/or bad abour PDAs?
05:41:30 <ibid> personal data assistants?
05:41:34 <mathrick> not that I ever read the proof they're equivalent to CF grammars :)
05:41:42 <ibid> ah, push-down automata
05:41:51 <ibid> mathrick: it's theory!
05:41:56 <mathrick> uh
05:42:11 <mathrick> ibid: well, yeah, I made a mistake
05:42:16 <ibid> mathrick: it doesn't immediately translate into new leet php-coding skillz ::)
05:42:22 <Saulzar> ibid, Fair enough :)
05:42:30 <mathrick> I went to a polytechnique, being fundamentally a theory guy
05:42:45 <mathrick> I'm glad I took a EE basics course, but otherwise, :(
05:42:57 <ibid> hrrm. out here, a polytechnic is where people who want to avoid theory go to :)
05:43:03 <Saulzar> Same here
05:43:32 <mathrick> I just lived near a pretty good (or so I thought) poly
05:43:49 <mathrick> with no considerably better unis in proximity
05:44:21 <mathrick> in the end, I just went for exchange programme, and my proximity now is within 1000km :)
05:44:22 <ibid> well, it could also be a terminology issue
05:44:32 <ibid> does your polytechnic issue doctorates?
05:44:36 <mathrick> yes
05:44:44 <ibid> ok, then it's a real university :)
05:44:55 <ibid> and not a polytechnic as the term is used here
05:44:59 <mathrick> aha
05:45:02 <mathrick> but it is a technical uni
05:45:05 <ibid> yeah
05:45:14 <ibid> out here, they're universities of technology
05:45:14 <mathrick> means, "don't worry, we do no nasty math in here"
05:45:19 <ibid> :)
05:47:41 <Maddas> Saulzar: Happens to other languages being taught, too :-)
05:48:14 <Maddas> mathrick: Where do you live?
05:48:32 <mathrick> Maddas: right now, in DK
05:48:39 <Maddas> Oh, ok. Where did you study, then?
05:48:40 <mathrick> but I'm a Pole originally
05:48:53 <Saulzar> Well, I just find it funny that almost everyone here learned Haskell in a course and hate it. I've never seen it in a course and love it :)
05:48:54 <mathrick> Maddas: Silesian University of Technology, Poland
05:49:05 <ibid> Saulzar: is the course mandatory?
05:49:05 <Maddas> Oh, I assumed you studied in France because you called it polytechnique :-)
05:49:11 <mathrick> Saulzar: people here hate haskell?
05:49:23 <Saulzar> Er, here as in physical location
05:49:27 <mathrick> Maddas: nah, just unsure on what spelling is trendy
05:49:31 <Saulzar> ibid, No (otherwise I'd have seen it) 
05:49:35 <Maddas> Saulzar: I have observed similar things. But people here also hate Java when the course is bad (or hard) :-)
05:50:06 <Maddas> (I don't/didn't have any Haskell courses, but CS students do)
05:50:06 <mathrick> you can dislike java even without a course :)
05:50:18 <Maddas> You can dislike any language without a course :-)
05:50:19 <ibid> i think the best compliment i got from one of my haskell students was during the last lecture
05:50:34 <ibid> he asked, "are there masters thesis topics available from this"
05:50:38 <ibid> :)
05:50:44 <mathrick> heh
05:50:57 <mathrick> our Uni (PL one, not DK) used to run a lisp course
05:51:07 <Saulzar> Definately keen there :)
05:51:20 <mathrick> but it was elective, and got cancelled before I enrolled into the Uni, because students hated it
05:51:26 <mathrick> :\
05:51:30 <Maddas> Saulzar: Many courses (at least for other languages) don't touch many features of the language for educational reasons, so many students also think the language is much more limited than it is.
05:51:50 <ibid> yes, and it was doubly nice considering that i (mis?)read the body language as "i'm bored"
05:51:54 <Maddas> (Especially introductory courses, of course)
05:51:57 <Maddas> ibid: Heh!
05:52:06 <Saulzar> True, they want a win32 gui straight away.
05:52:11 <ibid> i had (mis)read, that is
05:52:16 <mathrick> I have found that you generally need to be keen and avid in order to learn anything properly :)
05:52:44 <mathrick> but still, *many* courses are run in a way they certainly shouldn't be
05:53:00 <mathrick> including most of the basic programming courses I have seen at my home uni
05:53:01 <Maddas> Saulzar: To be fair, I think the same thing would happen to me given the right/wrong course and language if I weren't too interested in it.
05:53:43 <mathrick> Saulzar: bleh win32
05:53:47 <Maddas> mathrick: Indeed.
05:54:00 <mathrick> it should be called "how NOT to write a GUI lib"
05:55:18 <mathrick> damn
05:55:25 <mathrick> this setup is killing my wrists
05:55:50 <Maddas> What setup in particular?
05:55:50 <mathrick> and I can't find any chair that would be possible to lower more than what I already have
05:56:04 <mathrick> Maddas: pithy table instead of a real desk
05:56:08 <mathrick> +lots of keyboarding
05:56:52 <Maddas> Ew. With a bad keyboard too, I presume. :-)
05:57:10 <mathrick> well, it's acceptable
05:57:15 <Maddas> (I find heavily using the mouse worse than writing much, in general)
05:57:35 <mathrick> nah, right now mouse is much better than kbd
05:58:04 <Maddas> I'm fairly comfortable with the keyboard, though, and I've customized one thing or another, and my mouse sucks.
05:58:38 <xerox> Hola!
05:58:55 <Maddas> Hey there, xerox!
05:58:58 <dcoutts> @yarr!
05:58:59 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
05:59:04 <dcoutts> ohh, sorry xerox 
05:59:10 * Maddas laughs
05:59:13 <xerox> Brrr.
05:59:25 <dcoutts> ;-)
05:59:34 <xerox> What's up, me 'earties?
05:59:49 * dcoutts shouts at ranlib for being a pita
05:59:56 <twobitsprite> @arr
05:59:57 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
06:00:13 <xerox> @state
06:00:15 <twobitsprite> lambdabot: it's a hornpipe... how's you know?
06:00:20 <xerox> @. vixen . state arr
06:00:21 <lambdabot> where can I a see a picture of you?? URL??
06:00:22 <xerox> @state
06:00:23 <lambdabot> I'll crush ye barnacles!
06:00:27 <xerox> o_0
06:00:34 <dcoutts> how rude!
06:00:37 <twobitsprite> lol
06:00:38 <int-e> @arr
06:00:38 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
06:01:04 <int-e> I beg your pardon? Can anyone translate that to plain english?
06:01:55 <mathrick> what be 'earties?
06:02:00 <mathrick> ah, hearties
06:02:24 <mathrick> int-e: sexual innuendo :>
06:03:13 <int-e> I see
06:03:54 <dcoutts> int-e, the clap is a STD
06:04:58 <mathrick> int-e: http://en.wikipedia.org/wiki/Gonorrhoea
06:06:06 <int-e> thanks. I guess I shouldn't have asked :)
06:06:16 <int-e> but I understand it now.
06:24:34 <Itkovian> if I retain a 'reference' to a parent node in a child of a tree, the parent node will only be stored once, right?
06:26:09 <mathrick> @t liftM
06:26:10 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
06:26:10 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
06:26:14 <mathrick> @type liftM
06:26:15 <lambdabot> Not in scope: `liftM'
06:26:24 <mathrick> @type Monad.Control.liftM
06:26:25 <lambdabot> Couldn't find qualified module.
06:26:25 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
06:26:25 <lambdabot> \\)?
06:26:38 <mathrick> @index liftM
06:26:39 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
06:26:39 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
06:26:39 <lambdabot> Control.Monad.Error, Control.Monad.List
06:26:56 <mathrick> @type Control.Monad.liftM
06:26:57 <lambdabot> forall r (m :: * -> *) a1.
06:26:57 <lambdabot>         (Monad m) =>
06:26:57 <lambdabot>         (a1 -> r) -> m a1 -> m r
06:31:34 <mathrick> @type Reader
06:31:35 <lambdabot> Not in scope: data constructor `Reader'
06:31:43 <mathrick> @type Control.Monad.Reader
06:31:44 <lambdabot> Not in scope: data constructor `Control.Monad.Reader'
06:35:22 <mathrick> @index floor
06:35:22 <lambdabot> Prelude
06:35:43 <mathrick> > 20 `div` 3
06:35:44 <lambdabot> 6
06:35:57 <mathrick> @index ceil
06:35:58 <lambdabot> bzzt
06:36:00 <mathrick> @index ceiling
06:36:01 <lambdabot> Prelude
06:36:50 <Maddas> Is there any particularly recommended Haskell module to write servers? (Not HTTP)
06:38:00 <Lemmih> Network?
06:40:30 <Maddas> Yeah
06:40:40 <Maddas> (Communicating with a custom protocol)
06:41:31 <Lemmih> @docs Network
06:41:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.
06:41:32 <lambdabot> html
06:41:49 <Maddas> Thanks!
06:49:16 <rkeene> Does anyone know of a Haskell binding for libxml2 ?  (Or some other way of validating and parsing XML documents against an XML-Schema within Haskell)
07:03:56 <musasabi> rkeene: if you can use a xml schema -> dtd conversion then there are multiple working solutions.
07:05:34 <Lemmih> rkeene: http://haskell.org/haskellwiki/Libraries_and_tools#Web.2C_HTML.2C_XML
07:08:14 <musasabi> Sometimes the lack of recursive module support is killing everything :-(
07:10:41 <rkeene> musasabi, No DTD will suffciently discriminate my data.
07:12:01 <rkeene> Lemmih, Thanks.  I'll investigate further.
07:24:49 <mathrick> type Reader e = (->) e -- our monad
07:24:53 <mathrick> how should I read it?
07:26:19 <kosmikus> like "type Reader e r = e -> r"
07:26:55 <int-e> class (Monad m) => MonadReader r m | m -> r where ask   :: m r; local :: (r -> r) -> m a -> m a   (from Control.Monad.Reader)
07:27:04 <mathrick> kosmikus: that's still unclear to me
07:27:36 <mathrick> "type Reader with two parameters e and r is a function from e to r"?
07:27:57 <int-e> so 'ask' reads the value and 'local' modifies it (but note that unlike the state monad, the modification can not depend on the calculation in the monad).
07:29:11 <int-e> in Control.Monad.Reader, it's basically that, but wrapped in a newtype. newtype Reader r a = Reader { runReader :: r -> a }
07:31:29 <int-e> mathrick: what are you trying to do? write your own code for the reader monad?
07:35:17 <mathrick> int-e: no, just reading MonadsaAsContainers
07:37:52 <mathrick> bbl
08:03:33 <musasabi> Does the darcs haddock version support GADTs?
08:34:26 <roconnor> ls
08:34:29 <roconnor> oops
08:35:11 <Muad_Dib> roconnor: its called /list on irc ;)
08:36:03 <roconnor> I wish my computer would give me focus on the window I am looking at.
08:36:48 <roconnor> *sigh* what does one do when your network card doesn't work under debian.
08:37:02 <roconnor> There is no useful help to be found anywhere
08:37:14 * roconnor dispares
08:37:49 <Muad_Dib> first option i'd have would be to ask in #debian instead of in #haskell ;)
08:38:02 <roconnor> and the 2nd option?
08:38:12 <roconnor> I've tried the first ;)
08:38:31 <roconnor> I've come here to sulk, which probably isn't appropriate.
08:39:16 <Muad_Dib> take an ubuntu livecd and see if it works in there?
08:39:51 <roconnor> hmm, maybe a good idea.
08:42:11 <Maddas> roconnor: No problem, use a window manager that can only show one window at a time :-)
08:44:36 <twobitsprite> is there any sugar for arrays?
08:45:12 <jips> what do I do if readFile isn't closing the file properly?
08:47:23 <_Codex> twobitsprite: vector is sugar for array?
08:48:19 <twobitsprite> _Codex: eh?
08:48:44 <_Codex> simpler array class.
08:48:55 <eivuokko> jips, read it on your own. :-(
08:49:05 <jips> eivuokko: hm...
08:49:10 <_Codex> oh
08:49:21 <_Codex> never mind
08:49:27 <twobitsprite> _Codex: where would I find vector stuff? I don't see it in the prelude or anything
08:49:34 <eivuokko> jips, I am assuming you mean the handle is left hanging before gc
08:49:52 <tibbe> @hoogle fold
08:49:53 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
08:49:53 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
08:49:53 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
08:49:57 <tibbe> @hoogle foldl
08:49:58 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
08:49:58 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
08:49:58 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
08:49:59 <tibbe> @hoogle foldr
08:50:00 <lambdabot> Data.List.foldr :: (a -> b -> b) -> b -> [a] -> b
08:50:00 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
08:50:01 <lambdabot> Data.List.foldr1 :: (a -> a -> a) -> [a] -> a
08:50:01 <tibbe> @hoogle foldlr
08:50:03 <lambdabot> No matches found
08:50:05 <tibbe> @hoogle foldrl
08:50:05 <lambdabot> No matches found
08:50:10 <tibbe> @quote
08:50:11 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level
08:50:11 <lambdabot> than syntax is perl
08:50:17 <twobitsprite> @hoogle spam
08:50:18 <lambdabot> No matches found
08:50:21 <tibbe> @quote
08:50:21 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A:
08:50:21 <lambdabot> When he uses == and /= in everyday IRC chat or when he tries to fix a
08:50:21 <lambdabot> relationship by passing himself as a continuation
08:50:25 <tibbe> twobitsprite, sorry
08:50:27 <eivuokko> Could you tkae that to priavet chat, please.
08:50:29 <jips> eivuokko: the handle is the left hanging and there is another attempt to open the file
08:50:42 <twobitsprite> or use the hoogle web interface
08:50:56 <eivuokko> jips, Yeah, or remove file....exceptions in Windows :-(
08:51:07 <twobitsprite>  
08:51:11 <twobitsprite> oops
08:51:22 <jips> dons: if you read this, i think the bug might be in the use of readFile in rawMerge. readFile uses lazy IO and I don't think that the file is being closed properly because of this
08:51:24 <jips> dons: bbiab
08:54:12 <twobitsprite>  hmm... are arrays in haskell the same as arrays in C? i.e. constant random access time, etc?
08:54:19 <twobitsprite> it looks like they're just assoc list
08:56:30 <Igloo> Reading is constant
08:56:45 <Igloo> For immutable arrays writing will be O(size of array)
08:59:13 <twobitsprite> Igloo: awesome... I just need constant read time
08:59:23 <twobitsprite> Igloo: and, that's with the (!) function, right?
08:59:28 <Igloo> Yup
08:59:52 <twobitsprite> cool
09:00:04 <twobitsprite> what all do I need to import from Array?
09:00:16 <twobitsprite> just array and (!)?
09:00:43 <Igloo> Whatever you want to use
09:00:57 <twobitsprite> . o O ( I wonder what (!)? can mean as an emoticon.... )
09:02:07 <twobitsprite> ohh that's right... I forget haskell modules can restrict what they export... for some reason I was thinking about python in which case importing everything is silly most of the time...
09:04:22 <araujo> Hello!
09:05:16 <twobitsprite> so, the only kind "array literal" would be something like: array (0,9) [(0,4),(1,3)..(9,42)]
09:24:34 * dcoutts bludgeons GNU ranlib into using 5x less memory for building large archives
09:25:14 <Igloo> Are you looking at its source? If so, I'd be interested to know why it isn't constant memory use
09:25:26 <dcoutts> Igloo, yes I've got a patch
09:25:30 <dcoutts> http://sourceware.org/bugzilla/show_bug.cgi?id=2467
09:25:45 <dcoutts> Igloo, yes, I was wondering why it wasn't constant too
09:25:53 <dcoutts> but it's not
09:26:12 <Igloo> I know, that's why I want to know why  :-)
09:26:16 <dcoutts> it allocates bfd resources for every .o files in libHSbase.a
09:26:23 <dcoutts> all 12,000 of them
09:26:32 <dcoutts> and never frees them
09:26:43 <dcoutts> well not until the whole .a file is re-written
09:27:02 <Igloo> But is that necessary for what it's doing or just a bug?
09:27:06 <dcoutts> but it doesn't need to do that because it inspects each .o file in turn
09:27:22 <dcoutts> and it copies out the info it needs
09:27:52 <dcoutts> it does call bfd_free_cached_info after it's done with each .o file
09:28:06 <dcoutts> however on almost all targets that is #defined to bfd_true
09:28:12 <dcoutts> ie it's a noop
09:28:31 <dcoutts> if I give a proper implementation then the memory use is constant
09:28:52 <dcoutts> Igloo, if you can get any debian binutils people to review it that be great
09:29:25 <dcoutts> and/or suggest how to do it properly if my patch is judged just to be a hack
09:30:10 <dcoutts> Igloo, if we can get this fixed then we should be able to build ghc with SplitObjs=Yes on machines with less than half a gig of ram.
09:30:15 <Igloo> So when you said "5x less" above, is that constant?
09:30:15 <dcoutts> which would be nice
09:30:36 <dcoutts> Igloo, well it now peaks at 90mb rather than 500Mb
09:30:45 <dcoutts> for libHSbase.a
09:31:05 <Igloo> But you also said "if I give a proper implementation then the memory use is constant"
09:31:14 <dcoutts> constant at 90Mb :-)
09:31:20 * Igloo is confused as to what your patch does, make it constant or 1/5
09:31:27 <dcoutts> it makes it constant
09:31:50 <Igloo> So even if I just have 1 small object file it'll also use 90M of RAM?
09:31:54 <dcoutts> so includign all the other overheads, on an example like libHSbase.a the overall effect is a 5x reducation
09:32:10 <dcoutts> Igloo, no, it'll use less than that
09:32:17 <Igloo> So it's not constant?
09:32:19 <dcoutts> there are still other linear memory factors
09:32:26 <dcoutts> but the realyl big one is now gone
09:32:40 <dcoutts> it still loads the whole archive
09:32:55 <Igloo> And that is necessary?
09:33:13 <dcoutts> but now it doesn't build a big bfd struct (with all it's associated hash tables) for each tiny .o file in the archive
09:33:28 <Igloo> Anyway, re prodding Debian people to loko at it, I'd rather wait a bit for upstream to respond
09:33:36 <dcoutts> Igloo, loading the whole file into memory is pretty deeply ingrained in the bfd
09:33:52 <Igloo> Hmm, OK
09:33:53 <dcoutts> or at least loading structs representing the thing
09:34:21 <dcoutts> the point here was that the structs to represent each .o file were much bigger than the .o file
09:34:49 <dcoutts> and now we only need to have one of these bfd* things with all it's hash tables at once
09:35:01 <dcoutts> because we scan each .o file in turn
09:35:16 <dcoutts> and release the hashes & caches stuff when we're done
09:35:26 <dcoutts> so that bit becomes constant memory use
09:35:41 * Igloo would like to find out exactly what it is trying to do and work out whether it can be truly constant, but isn't likely to have time any time soon
09:36:29 <dcoutts> Igloo, about prodding, I'm not asking for it to be included in distros without upstream support, but I mean that upstream can be rather slow
09:36:40 <dcoutts> I was hoping for some eariler review & suggestions
09:37:22 <dcoutts> I'm tring to poke the gentoo toolchain people too
09:38:17 * davidhouse finishes writing an essay about escape velocities
09:38:44 <twobitsprite> how do you compare enumeration types?
09:38:59 <davidhouse> compare types? you can't
09:39:06 <twobitsprite> er... constructors
09:39:13 <davidhouse> what do you mean?
09:39:16 <twobitsprite> i.e. data Foo = Bar | Baz
09:39:18 <sjanssen> twobitsprite: derive Ord for the type
09:39:20 <twobitsprite> Bar == Baz
09:39:30 <sjanssen> twobitsprite: and Eq
09:39:43 <twobitsprite> sjanssen: just put "deriving Eq" at the end?
09:39:57 <sjanssen> data Foo = Bar | Baz deriving (Eq,Ord)
09:39:59 <davidhouse> data Foo = Bar | Baz deriving (Eq, Ord)
09:40:20 <twobitsprite> do you need Ord if you don't plan on using <, >, etc
09:40:21 <twobitsprite> ?
09:40:26 <sjanssen> no
09:40:40 <twobitsprite> thanks
09:41:03 <davidhouse> you need Ord if you want Enum, right?
09:41:19 <davidhouse> it's something like class (Ord a) => Enum a where...
09:41:57 <sjanssen> davidhouse: nope, Enum is independent of Ord
09:42:11 <davidhouse> @index Enum
09:42:12 <lambdabot> Prelude
09:42:24 <davidhouse> ... where else, lambdabot? :P
09:42:53 <sjanssen> using :info Enum in ghci is the easiest way to look at the defn.
09:43:39 <twobitsprite> is there an easy way to "map" a list of functions onto a single value?
09:44:00 <davidhouse> hmm... it appears you're correct
09:44:08 <sjanssen> @type map ($x)
09:44:09 <davidhouse> twobitsprite: use a fold
09:44:09 <lambdabot> Not in scope: `x'
09:44:15 <davidhouse> oh, way
09:44:16 <davidhouse> *wait
09:44:22 <sjanssen> @type \x fns -> map ($x) fns
09:44:23 <lambdabot> forall a b. a -> [a -> b] -> [b]
09:44:50 <davidhouse> > map ($ 1) [(*3), (+4), (*5).(*9).(+3)]
09:44:52 <lambdabot> [3,5,180]
09:45:07 <twobitsprite> ahh... I forget that Haskell has a function application operator :P
09:45:33 <davidhouse> > map (\f -> f 1) [(*3), (+4), (*5).(*9).(+3)] -- if you prefer
09:45:34 <lambdabot> [3,5,180]
09:46:51 <davidhouse> wow
09:46:55 <davidhouse> i never knew about :info
09:47:23 <davidhouse> that's like, ber-useful
09:48:20 <sjanssen> I just discovered it a week ago myself
09:53:03 <ndm> davidhouse: have you ever seen :find, in hugs with a properly configured editor its beautiful
09:53:15 <davidhouse> ndm, what does it do?
09:53:20 <davidhouse> finds the definition of a function?
09:53:28 <ndm> davidhouse: finds the definition, exactly
09:53:37 <davidhouse> that _would_ be cool
09:53:39 <ndm> but its particularly handy for prelude stuff, :find head
09:54:36 <davidhouse> yeah
09:56:22 <davidhouse> is GHCi's :def just like a persistent let, or can it be used to run a shell command?
09:59:52 <Lemmih> Prelude> :def testDef \x -> putStrLn x >> return ":!ls"
09:59:53 <Lemmih> Prelude> :testDef "Hello world"
09:59:53 <Lemmih> "Hello world"
09:59:53 <Lemmih> coding  Desktop  Diagram1.dia.autosave  download  gtk2hs.hide
10:00:08 <dcoutts> ?
10:00:34 <davidhouse> seems rather arcane syntax, but thanks
10:01:24 <Lemmih> !
10:01:40 <davidhouse> ?
10:03:02 <palomer> :def seems like a persistent let
10:03:15 <Lemmih> What's with all the ?'s, guys?
10:03:18 <Lemmih> palomer: How so?
10:03:25 <davidhouse> Lemmih: what was your ! for?
10:03:50 <Lemmih> davidhouse: It was a response to dcoutts.
10:04:00 <davidhouse> ah. not my comment, then
10:04:18 <dcoutts> Lemmih, :-)
10:05:24 <davidhouse> ndm, ping
10:05:48 <ndm> davidhouse: pong
10:06:20 <davidhouse> ndm, i want to move hoogle to somewhere in my $PATH. is it sufficient to copy the binary and hoogle.txt, or does it require other files?
10:06:32 <ndm> davidhouse: that should be enough
10:06:38 <davidhouse> thanks
10:06:44 <ndm> although i think hoogle.txt is only looked for in teh current directory
10:06:46 <ndm> (maybe)
10:07:02 <davidhouse> grr. so it appears
10:07:09 <ndm> so you might want to create a hoogle.sh that calls hoogle with a command line param, to pass the location of hoogle.txt
10:07:18 <davidhouse> i'll have to set up a bash alias to call hoogle with -l.
10:07:19 <ndm> i'll get that fixed soon, its a stupid way to do it
10:07:52 <ndm> i hope to hack hoogle this weekend, so i'll fix it then
10:10:16 <davidhouse> oh, wow
10:10:30 <davidhouse> not only does it only look in the current dir, it does really dumb filepath building
10:10:50 <davidhouse> you can only pass relative paths to -l, it seems
10:11:07 <ndm> hmm, that is braindead :)
10:11:28 <ndm> i have never tired it, and i didn't write -l support, someone else did
10:11:44 <davidhouse> wait, scratch that
10:11:56 <davidhouse> a ~ accidently slipped in before my path
10:12:42 <ndm> ah, thats not so bad
10:12:50 <davidhouse> nah, it works
10:12:53 <ndm> anyway, i'll fix it this weekend to look at curdir and installed dir
10:13:03 <davidhouse> look i $PATH.
10:13:06 <davidhouse> *in
10:13:15 <davidhouse> but anyway, yay! hoogle and ghci integration!
10:13:29 <ndm> neat :)
10:13:37 <davidhouse> via :def.
10:13:48 <ndm> @wiki Hoogle
10:13:50 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
10:13:57 <davidhouse> argh, :defs aren't persistant across ghci sessions.
10:14:00 <ndm> feel free to write up how you did it on the wiki page
10:14:08 <ndm> nothing in ghci is persistant
10:14:20 <davidhouse> really?
10:14:22 <davidhouse> that's a pain
10:14:36 <ndm> yeah, feel free to patch it :)
10:14:39 <davidhouse> in which case, it can't easily be done
10:15:41 <davidhouse> it'd be nice if you could pass a paramter to GHCi to read in a file of :defs.
10:16:00 <davidhouse> hmm... can you pass any parameters to GHC to define a command? or even load a module?
10:16:33 <Lemmih> davidhouse: You can write :defs in ~/.ghci
10:17:45 <davidhouse> awesome! it works!
10:19:53 * davidhouse adds it to the wiki
10:25:45 <twobitsprite> are the declarations in a where clause cumulative?
10:26:00 <twobitsprite> i.e. can one declaration depend on a previous one?
10:26:14 <int-e> they are recursive, actually
10:26:22 <twobitsprite> (i.e. let-rec* from scheme?)
10:26:28 <int-e> a declaration can also depend on a later one
10:26:31 <twobitsprite> I see
10:26:33 <twobitsprite> awesome
10:27:10 <int-e> (the same is true for let ... in)
10:27:11 <davidhouse> ndm, check out the hoogle wiki page
10:28:10 <int-e> > let f = n; n = q in f where q = r; r=42
10:28:11 <lambdabot> 42
10:29:02 <Lemmih> davidhouse: You don't need the extra quotes.
10:39:05 <twobitsprite> data Foo = Bar Int
10:39:26 <twobitsprite> how do I get (Bar 4) + 3 to work?
10:39:36 <mwc> You don't.
10:39:38 <twobitsprite> I figure I have to do something with Num... but deriving doesn't work
10:39:41 <twobitsprite> ohh
10:39:54 <mwc> (+) is a member of Num, it has type (Num a) => a -> a -> a
10:40:16 <mwc> you can't have two different types applied to (+)
10:40:17 <twobitsprite> I can't make Foo a member of Num?
10:40:21 <twobitsprite> ahh
10:40:23 <mwc> No
10:40:34 <Lemmih> twobitsprite: You can.
10:40:43 <twobitsprite> what about getting (Bar 4) + (Bar 3)?
10:41:08 <mwc> You could define a multiparameter type class, and create an operator (+') :: (Num a, Num b) => a -> b -> a
10:41:12 <mwc> Lemmih, whoa, you can?
10:41:40 <Lemmih> *Test> Bar 10 + 20
10:41:41 <Lemmih> Bar 30
10:41:56 <Lemmih> *Test> 10 + 20 :: Foo
10:41:56 <Lemmih> Bar 30
10:42:22 <mwc> coulda sworn something about no implicit conversinos
10:42:43 <mwc> oh, right, fromIntegral :: Foo
10:42:44 <_roconnor> data Foo = Bar Int deriving Num
10:42:46 <Lemmih> mwc: '10' is actually 'fromIntegral (10::Integer)'.
10:42:48 <mwc> yeah
10:42:58 <mwc> I just remembered that
10:43:00 <Lemmih> mwc: And 'fromInteger' is a member of Num.
10:43:24 <Lemmih> (and I meant fromInteger instead of frromIntegral)
10:43:51 <twobitsprite> Lemmih:     Can't make a derived instance of `Num Position' (`Num' is not a derivable class)
10:44:33 <Lemmih> twobitsprite: You can derive Num if you use a 'newtype' and GHC.
10:44:50 <twobitsprite> Lemmih: newtype?
10:45:29 <twobitsprite> Lemmih: I have: data Position = Pos Int deriving Num
10:46:03 <Lemmih> twobitsprite: Change 'data' to 'newtype' and use -fglasgow-exts.
10:46:10 <mwc> you need to make an explicit instance: instance Num Position
10:46:18 <mwc> Lemmih, num is derivable?
10:46:44 <mwc> I thought only Eq, Show, Enum in special cases
10:47:13 <Lemmih> mwc: GHC got semi-magic support for newtypes.
10:47:52 <mwc> Ah, voodoo is cool\
10:49:05 <twobitsprite> hmm... just for educational purposes, I'll try making an explicit instance of Num...
10:49:18 <ndm> davidhouse: thanks for that
10:49:40 <Lemmih> twobitsprite: That's probably a good idea.
10:51:15 <vincenz> blegh
10:51:18 <vincenz> walking over a tree is a b*tch
10:51:50 <twobitsprite> esp. ones that are still standing... I think it's that whole gravity thing not letting you walk up the side of it...
10:52:25 * Lemmih grins.
10:54:05 <_roconnor> newtype Foo = Bar Int deriving Num
10:55:04 <mwc> The voodoo only works for unary constructors over a single parameter already an instance of num?
10:55:19 <davidhouse> Lemmih: thanks
10:56:22 <davidhouse> Lemmih: although it seems you need them if you want to hoogle a type
10:56:48 <davidhouse> but then that's true of shell hoogle as well
10:57:00 <twobitsprite> hm... I think I am misunderstanding type classes: data Position = (Num a) => Pos a
10:57:44 <davidhouse> twobitsprite: where did you get that from?
10:57:50 * _roconnor tries to remember
10:58:03 <_roconnor> isn't it something like data (Num a) => Position a = Pos a
10:58:10 * _roconnor can never remember
10:58:16 <twobitsprite> davidhouse: I made it up..
10:58:28 <davidhouse> twobitsprite: i don't think it makes sense
10:58:44 <_roconnor> twobitsprite: most certainly you will need the "a" in "Position a"
10:58:57 <_roconnor> then the Num a goes in some random place.
10:59:08 <twobitsprite> davidhouse: I don't want to use just Ints, i.e.: data Position = Pos Int
10:59:28 <twobitsprite> davidhouse: can't I make a type that accepts a class of typed data?
10:59:33 <davidhouse> you want to parametrise it over a type
10:59:41 <twobitsprite> right
10:59:55 <twobitsprite> ah... so like: data Position a = (Num a) => Pos a
10:59:56 <twobitsprite> ?
11:00:13 <davidhouse> i think you need something like data (Num a) => Position a = Pos a
11:00:18 <davidhouse> not sure of the exact syntax.
11:00:20 <davidhouse> experiment
11:00:33 <int-e> davidhouse: that will work./
11:03:06 <twobitsprite> ok, now, is there a class that includes Ints and Integers but not Factionals?
11:03:23 * twobitsprite starts to think he might be asking to much and should just stick with Ints...
11:04:20 <davidhouse> Integral
11:04:27 <twobitsprite> ahh, thanks
11:05:20 <davidhouse> you might find http://haskell.org/onlinereport/basic.html#sect6.3 useful
11:08:00 <twobitsprite> ah ha
11:15:45 <twobitsprite> http://pastebin.com/607867
11:15:50 <twobitsprite> what amI doing wrong?
11:16:54 <int-e> twobitsprite: (+) and (-) are defined in the Num class
11:17:30 <int-e> twobitsprite: so you have to make a Num instance for Position a to define them
11:17:57 <twobitsprite> so I change the second occurence of Integral to Num?
11:18:10 <twobitsprite> or both?
11:18:20 <davidhouse> the second
11:18:35 <davidhouse> as you only want it to be an instance of Num when the type parameter is an instance of Integral
11:18:48 <int-e> right
11:19:17 <twobitsprite> I see
11:19:19 <twobitsprite> still doesn't work
11:19:21 <twobitsprite>     Couldn't match the rigid variable `a' against `Position a'
11:19:26 <davidhouse> pastebin again
11:19:45 <int-e> twobitsprite: ah, you also need to add Pos to the right side of these expressions
11:20:01 <int-e> twobitsprite: (Pos x) + (Pos y) = Pos (x + y)
11:20:08 <davidhouse> @type (+)
11:20:09 <lambdabot> forall a. (Num a) => a -> a -> a
11:20:15 <twobitsprite> ahh
11:20:17 <int-e> twobitsprite: (you can write the left side in infix notation if you like)
11:20:35 <davidhouse> yep. so if you give it two (Pos a)s, then you must return a Pos a.
11:21:05 <twobitsprite> ahh ha... got it
11:21:16 * twobitsprite finaly feels like he's getting the hang of thi
11:21:17 <twobitsprite> s
11:22:06 <twobitsprite> (of course... I got a bunch of warnings for undefined methods :P
11:22:08 <twobitsprite> )
11:24:26 <twobitsprite> why does lambdabot say "forall ..." and GHCi doesn't?
11:25:07 <_roconnor> forall stuff will become an extension to Haskell one day.
11:25:18 <davidhouse> what exactly is forall stuff?
11:25:22 <int-e> probably because lambdabot uses -fglasgow-exts
11:25:34 <_roconnor> @type (+)
11:25:35 <lambdabot> forall a. (Num a) => a -> a -> a
11:25:39 <_roconnor> that forall thing
11:25:40 <int-e> > ghci -fglasgow-exts
11:25:40 <int-e> Prelude> :t 1
11:25:40 <int-e> 1 :: forall t. (Num t) => t
11:25:41 <lambdabot>  Not in scope: `exts'
11:25:54 <davidhouse> _roconnor: yeah, it doesn't seem to mean much
11:26:08 <_roconnor> @wiki rank2polymorphism
11:26:09 <lambdabot> http://www.haskell.org/haskellwiki/rank2polymorphism
11:26:23 <_roconnor> hmm
11:26:36 <davidhouse> @oldwiki Rank2Polymorphism
11:26:37 <lambdabot> http://www.haskell.org/hawiki/Rank2Polymorphism
11:26:51 <davidhouse> @oldwiki RankTwoPolymorphism
11:26:52 <lambdabot> http://www.haskell.org/hawiki/RankTwoPolymorphism
11:26:54 <davidhouse> that last one finds it
11:26:59 <_roconnor> there we go
11:27:44 <int-e> Anyway you can just ignore foralls at the beginning of a type.
11:27:45 * _roconnor not so sure that page is helpful
11:28:26 <davidhouse> that sounds rather scar
11:28:30 <davidhouse> *scary
11:28:37 * davidhouse just ignores the foralls at the beginning of a type
11:30:56 <int-e> no, scary are the things that happen when there are foralls elsewhere, like forall u. (forall t. t -> t) -> u -> u
11:31:50 <palomer> how is that scary?
11:32:12 <palomer> flip const has that type
11:33:14 <jyp> @type flip const
11:33:15 <lambdabot> forall a b. b -> a -> a
11:34:36 <jyp> forall a b. b -> a -> a :> forall u. (forall t. t -> t) -> u -> u
11:35:51 <jyp> @type (flip const :: forall u. (forall t. t -> t) -> u -> u)
11:35:52 <lambdabot> forall u.
11:35:52 <lambdabot>                     (forall t. t -> t) -> u -> u
11:36:33 <twobitsprite> is there a way to not fully implement an instance without getting a warning? i.e. if I want to instatiate Num with out defining (*)?
11:36:58 <_roconnor> twobitsprite: define (*) to be error "(*) not implement for so and so"
11:37:27 <twobitsprite> _roconnor: ok, I didn't know if there was some sugar for something like that...
11:38:05 <_roconnor> twobitsprite: be aware that the compiler will not tell you if you accidently use (*) on your time.
11:38:15 <_roconnor> on your type
11:39:29 <twobitsprite> I see
11:39:58 <davidhouse> twobitsprite: the alternative is to just define it :P
11:40:21 <twobitsprite> davidhouse: of course... I planned on defining it, I was just curious :P
11:42:47 <davidhouse> @pl \(Pos x) (Pos y) -> Pos $ x + y
11:42:48 <lambdabot> (line 1, column 7):
11:42:48 <lambdabot> unexpected "x"
11:42:48 <lambdabot> expecting operator or ")"
11:43:06 <davidhouse> @pl \(Just x) (Just y) -> Just $ x + y
11:43:07 <lambdabot> (line 1, column 8):
11:43:07 <lambdabot> unexpected "x"
11:43:07 <lambdabot> expecting operator or ")"
11:44:28 <twobitsprite> what's wrong with "fromInteger x = Pos x" in my instance?
11:44:45 <davidhouse> @type fromInteger
11:44:46 <lambdabot> forall a. (Num a) => Integer -> a
11:44:54 <davidhouse> hmm.
11:44:58 <Lemmih> twobitsprite: ... = Pos (fromInteger x)
11:45:03 <twobitsprite> ahh... :P
11:45:14 <davidhouse> why?
11:45:28 <davidhouse> Integers are instances of Num, right?
11:45:49 <Lemmih> 'x' is an Integer and Pos is of type 'Int -> Position'.
11:46:31 <davidhouse> Pos is of type (Integral a) => a -> Pos a
11:46:41 <Lemmih> It is?
11:46:46 <davidhouse> i believe so
11:46:56 <davidhouse> twobitsprite: mind pastebinning what you've got?
11:47:01 <rep> i can go on and on and on and on and on
11:47:40 <Lemmih> > let go on = on (go on) in go (\on -> on) :: ()
11:47:44 <lambdabot> Terminated
11:48:29 <davidhouse> > "i can go " ++ (replicate 5 "on and ")
11:48:30 <lambdabot> Couldn't match `Char' against `[Char]'
11:48:35 <davidhouse> > "i can go " ++ (concat $ replicate 5 "on and ")
11:48:36 <lambdabot> "i can go on and on and on and on and on and "
11:48:46 <davidhouse> > "i can go " ++ (unwords $ replicate 5 "on and")
11:48:47 <lambdabot> "i can go on and on and on and on and on and"
11:49:47 <Lemmih> > "i can go " ++ unwords (intersperse "and" (replicate 5 "on"))
11:49:48 <lambdabot> "i can go on and on and on and on and on"
11:50:54 <twobitsprite> @pl (flip (-)) 1 4
11:50:55 <lambdabot> 3
11:51:08 <twobitsprite> @pl (\ x y -> (flip (-)) x y)
11:51:09 <lambdabot> subtract
11:52:09 <davidhouse> > subtract 2 3
11:52:10 <twobitsprite> damn... I wish you could just (-x) y like you can with (+x) y
11:52:10 <lambdabot> 1
11:52:32 <davidhouse> > 3 `subtract` 2 -- really counter-intuititive: don't ever use it infix
11:52:33 <lambdabot> -1
11:52:45 <davidhouse> > (-3) 2
11:52:46 <lambdabot>  add an instance declaration for (Num (t -> a))
11:52:59 <davidhouse> > (-3) 2 :: Int
11:53:00 <lambdabot>  add an instance declaration for (Num (t -> Int))
11:53:03 <jyp> > flip (-) 3 2
11:53:04 <lambdabot> -1
11:53:14 <davidhouse> oh, wait. -3 is an Int.
11:53:20 <twobitsprite> davidhouse: precisely
11:53:47 <twobitsprite> anyways... its quitin' time
11:53:48 <twobitsprite> later
11:53:49 <davidhouse> > ((-) 3) 2 :: Int
11:53:50 <lambdabot> 1
11:53:55 <twobitsprite> ahh ha
11:53:56 <twobitsprite> thanks
11:54:07 <davidhouse> but it doesn't quite work
11:54:07 <_roconnor> @hoogle unsafeCoerce
11:54:09 <lambdabot> No matches found
11:54:12 <davidhouse> > (3 (-)) 2 :: Int
11:54:12 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> Int))
11:54:12 <lambdabot>   In the expression: (3 (-)) 2 :: Int
11:54:12 <lambdabot>   In the definition of `wdy': wdy = (3 (-)) 2 :: Int
11:54:23 <davidhouse> > (flip (-) 3) 2 :: Int
11:54:24 <lambdabot> -1
11:54:29 <davidhouse> there you go.
11:54:30 <twobitsprite> yeah, that's it... still long
11:54:44 * twobitsprite shrugs...
11:54:56 <twobitsprite> I wish haskell used a diferent symbol for unary negation
11:55:07 <jyp> > (subtract 3) 2
11:55:08 <lambdabot> -1
11:55:39 <_roconnor> @hoogle subtract
11:55:39 <lambdabot> Prelude.subtract :: Num a => a -> a -> a
11:55:39 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.Subtract :: TextureComb
11:55:39 <lambdabot> ineFunction
11:55:39 <lambdabot> Graphics.HGL.Draw.Region.subtractRegion :: Region -> Region -> Region
11:55:43 <Lemmih> > (`subtract` 3) 2
11:55:44 <lambdabot> 1
11:55:50 <_roconnor> woa
11:55:57 <jyp> I wish haskell did not do something special with (-) sections :)
11:56:11 <twobitsprite> jyp same thing :P
11:56:19 <twobitsprite> anyways... gotta catch bus... later
11:56:25 * jyp waves
11:58:51 <davidhouse> "The definition shown here uses multi-parameter type classes and funDeps, which are not standard Haskell 98. It is not necessary to fully understand these details to make use of the Reader monad." http://pastebin.com/607926
11:58:54 <davidhouse> where does it use those things?
11:59:22 <ValarQ> @type -1
11:59:23 <lambdabot> forall a. (Num a) => a
11:59:27 <ValarQ> @type - 1
11:59:28 <lambdabot> forall a. (Num a) => a
12:02:01 <kosmikus> davidhouse: where is that text from? the definition you pasted doesn't use mptc's, nor fundeps.
12:02:19 <davidhouse> kosmikus: All About Monads. http://www.nomaware.com/monads/html/readermonad.html
12:02:34 <davidhouse> those extensions are used in the definitions of other monads, so perhaps it was an over-eager copy-paste
12:03:29 <kosmikus> it obviously refers to the stuff coming after the initial definition.
12:03:35 <kosmikus> class MonadReader ...
12:03:49 <davidhouse> yeah, could do
12:04:46 <_roconnor> So there is this pair of ML and Haskell code derived from the same source.
12:04:53 <kosmikus> Reader isn't useful without an implementation of "ask"
12:04:54 <davidhouse> argh. i always forget to un-/away myself
12:05:09 <_roconnor> The ML code runs 250 times slower than the haskell code
12:05:12 <kosmikus> so all of it is "the definition of the Reader monad"
12:05:29 <_roconnor> but the Haskell code doubles its memory footprint each iteration.
12:05:29 <kosmikus> and it makes use of an mptc with a fundep
12:05:52 <_roconnor> I think the ML code is wasting time eagerly evaluating stuff that will never be used.
12:06:12 <_roconnor> and the Haskell code is accumulating more and more thunks that will never actually be used.
12:06:16 <_roconnor> I wonder which is better...
12:07:54 <davidhouse> how many iterations are you going to be running it on?
12:08:12 <_roconnor> it got to 2GB after twelve iterations.
12:08:29 <_roconnor> there is no right number of iterations, more iterations meens a better approximation of the result.
12:09:09 <_roconnor> lazyness might not be so great if thunks keep adding up
12:09:21 <_roconnor> it's intresting.
12:19:16 <kaydara> good night all
12:21:24 <davidhouse> when should i use Reader over just a simple lookup table? say a Data.Map?
12:23:13 <jyp> huh... those two have nothing in common afaics
12:23:59 <kaydara> i nned to make a function like : constrVal 2 = [[True,True],[True,False],[False,True],[False,False]]
12:24:03 <davidhouse> Reader is for computations within a shared environment, right
12:24:05 <kaydara> but i am really out of ideas how to pick it
12:24:11 <kaydara> can someone give a hint ?
12:24:37 <davidhouse> kaydara: huh? whate exactly do you need to do?
12:24:52 <jyp> davidhouse: Reader just saves you passing an argument, probably the actual environment will be your Data.Map
12:25:12 <davidhouse> yeah, that's what i mean
12:25:24 <kaydara> davidhouse need to create that function but i really dunno how to do it, and is quit simple i think
12:25:35 <davidhouse> kaydara: what does that function need to do?
12:25:47 <davidhouse> jyp: so i could use Reader whenever i use a lookup table?
12:26:07 <kaydara> recives a int argument
12:26:20 <kaydara> and return a list of list with all logic values possibles
12:26:30 <kaydara> like in that example
12:26:38 <kaydara> constrVal 2 = [[True,True],[True,False],[False,True],[False,False]]
12:26:38 <davidhouse> ah
12:26:57 <jyp> davidhouse: A sorry... I thought you referred to the Reader monad from the monadic templates library
12:27:08 <davidhouse> jyp: is that not what i'm referring to?
12:27:52 <jyp> davidhouse: At one point I thought you referred to a specific implentation... but wait
12:29:05 <jyp> davidhouse: So, you can use Reader when you want to pass a constant thing to many functions without specifying it each time
12:29:18 <davidhouse> ah.
12:29:21 <jyp> davidhouse: so if your lookup table is constant, that's fine
12:29:25 <davidhouse> so it's not good if i want to change the env?
12:29:34 <jyp> no.
12:29:49 <davidhouse> okay then :) what are the alternatives then?
12:29:54 <davidhouse> pass a lookup table around?
12:29:55 <jyp> unless you change it "locally"
12:30:05 <davidhouse> yeah. that's probably not what i want
12:30:06 <jyp> or use State
12:31:58 * davidhouse wonders whether StateT Reader would be an option
12:32:46 <davidhouse> seems unlikely.
12:32:54 <jyp> probably not what you want, indeed.
12:32:55 <davidhouse> okay, well i'll just pass a Map around then
12:33:19 <jyp> You can use Reader, and local :: (r -> r) -> m a -> m a when you want to update the map
12:33:31 <jyp> that's a quite classic pattern
12:33:37 <davidhouse> hmm
12:34:10 <davidhouse> that's basically the equivalent of State's modify?
12:34:12 <jyp> because, very often, you don't want to pass a changed env. up to your caller.
12:35:18 <jyp> so of "locally" modify
12:35:36 <davidhouse> yeah
12:35:57 <jyp> eg. local bindSomeVar fctWhereVarIsBound
12:36:13 <davidhouse> i don't really think this project is going to be suited to Reader then. that's a shame, i was looking for somewhere i could use monad transformers to test my understanding of them
12:36:14 <jyp> and fct can change your env, you will not ever see it.
12:37:19 <jyp> if you do a simple lambda-calculus evaluator, Reader is perfectly suited for it.
12:37:41 <jyp> ... to thread the env down the sub-expressions.
12:37:50 <davidhouse> that's an oxymoron, right?
12:37:58 <davidhouse> simple lamda evaluator?
12:38:00 <davidhouse> :)
12:38:14 <jyp> not really :)
12:38:15 <davidhouse> i could try. someone suggested a type checker before
12:38:41 <jyp> the evaluator is much simpler than the type-checker.
12:38:48 <davidhouse> oh good. :)
12:38:59 <davidhouse> any chance i could bundle a monad transformer onto there as well?
12:39:09 <davidhouse> make the expressions non-deterministic or something?
12:39:11 <jyp> of course
12:39:25 <jyp> you can also count the number of applications or something
12:39:53 <jyp> actually, I think this is all very well explained in one of the first Wadler's paper on monads
12:40:09 <jyp> he doesn't use transformers (of course)
12:40:22 <jyp> and the notation is old-fashioned (you guessed it)
12:40:50 <jyp> but otherwise it can guide you well if you get stuck.
12:40:57 <davidhouse> okay.
12:41:32 <davidhouse> hmm
12:41:35 <jyp> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
12:41:45 <davidhouse> would i not need a mutable environment for an evaluator?
12:41:46 <jyp> must be the second to the end
12:42:03 <davidhouse> or do i change it with local then recurse or something
12:42:16 <jyp> no, because (\x->e) binds x in e only
12:42:22 <jyp> I mean yes ;)
12:42:34 <davidhouse> yes to which question?
12:42:40 <jyp> the second :)
12:42:42 <davidhouse> good. :)
12:43:38 <jyp> actually the paper I referred to is the last one on that page
12:43:55 <jyp> The essence of functional programming
12:44:05 <jyp> Quite a title :)
12:45:15 <davidhouse> hmm
12:45:17 <jyp> spoiler: the whole solution to the problem is on page 4
12:45:32 <davidhouse> any tips on defining a datatype for handling a lambda?
12:46:34 <jyp> You want to capture the syntax of the language...
12:46:46 <jyp> so what would you say ?
12:47:49 <davidhouse> perhaps something like data Expression = Lambda [Parameter] Function?
12:48:03 <davidhouse> i'm not sure, i haven't had much practice at coming up with datatypes like this
12:48:26 <jyp> I'd say  data Expression = Lambda [Parameter] Expression
12:48:56 <jyp> naturally mapping \a b c ... -> expr
12:49:23 <jyp> of course you'd want other constructors
12:49:40 <jyp> like Const Int, or something
12:49:43 <davidhouse> i'd have to, it's a recursive constructor
12:49:56 <jyp> I'll let you discover others.
12:50:13 <jyp> and remember the paper if ever you get stuck.
12:50:16 <davidhouse> :) thanks for your help.
12:50:26 <davidhouse> (i think i'll stick with expressions that deal with ints to begin with)
12:58:01 <jyp> No problem. :)
13:09:23 <lisppaste2> davidhouse pasted "lambda evaluator" at http://paste.lisp.org/display/17985
13:09:34 <davidhouse> jyp, still around?
13:11:09 <jyp> aye
13:11:40 <davidhouse> that's how far i've got. having a little trouble with the datatype: i want Expression to be able to take any number of parameters
13:11:47 <davidhouse> that doesn't seem very easy at the moment
13:12:09 <davidhouse> (i'm also noticing this is looking a lot like arrows, especially if i generalise to a Lambda a b type)
13:12:31 <jyp> well, keep in mind that we first want to describe the syntax
13:13:02 <davidhouse> yes.
13:13:05 <jyp> ie. I don't see what the (a -> ...) is for
13:13:13 <jyp> a -> Value
13:13:42 <davidhouse> hmm
13:14:00 <davidhouse> perhaps i'm takling this completely wrongly then. what would you suggest as a type?
13:14:57 <davidhouse> i don't think i'm completely clear as to what i'm trying to model
13:15:49 <jyp> data Expr = Lam [Var] Expr | Apply Expr Expr | Const Int
13:16:33 <davidhouse> Apply Expr Expr is?
13:16:50 <jyp> rather, data Expr = Lambda [VarName] Expr | Apply Expr Expr | Const Int | Var VarName
13:16:57 <jyp> function application
13:17:39 <davidhouse> oh. so what's Lambda for then?
13:18:08 <jyp> abstraction...
13:18:23 <jyp> as in \x -> expr
13:19:23 <jyp> you could also have lets... let x = expr1 in expr2
13:19:29 <jyp> maybe easier
13:19:35 <davidhouse> heh. sorry. temporary brain block when i thought you gave the values as well as the parameter names for lambdas
13:24:44 <ihope> > (undefined :: Int) :: String
13:24:45 <lambdabot> Couldn't match `String' against `Int'
13:25:10 <ihope> So you can't revoke a type annotation...
13:32:10 <ihope> @hoogle IORef
13:32:11 <lambdabot> Data.IORef.IORef :: IORef a
13:32:11 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
13:32:11 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
13:32:31 <ihope> @type Data.IORef.IORef
13:32:32 <lambdabot> Not in scope: data constructor `Data.IORef.IORef'
13:33:04 <ihope> @type Data.IORef.readIORef :: IORef a -> IO b
13:33:04 <lambdabot> Not in scope: type constructor or class `IORef'
13:35:45 <ihope> Ouch, coerce looks a bit evil indeed.
13:36:43 <davidhouse> someone stop me from going mad: get >>= return . flip M.(!) iden
13:37:05 <ihope> What's M, and what's iden?
13:37:06 <davidhouse> it's saying "not in scope: data constructor 'M'" and "not in scope: !"
13:37:09 <ihope> And what's (!)?
13:37:18 <davidhouse> import qualified Data.Map as M
13:37:28 <jyp> @type (Data.Map.!)
13:37:29 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> k -> a
13:37:34 <davidhouse> @type Data.Map.(!)
13:37:35 <lambdabot> Couldn't find qualified module.
13:37:35 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
13:37:35 <lambdabot> \\)?
13:37:36 <jyp> @type Data.Map.(!)
13:37:37 <lambdabot> Couldn't find qualified module.
13:37:37 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
13:37:37 <lambdabot> \\)?
13:38:00 <davidhouse> hmm... i could have sworn you did it the other way round
13:38:04 <ihope> @type (Data.Map.!)
13:38:05 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> k -> a
13:38:08 <davidhouse> thanks jyp :)
13:38:16 <jyp> my pleasure ;)
13:38:46 <ihope> @type newIORef undefined >>= \ref -> writeIORef ref a >> readIORef ref
13:38:47 <lambdabot> Not in scope: `newIORef'
13:38:47 <lambdabot>  
13:38:47 <lambdabot> <interactive>:1:31: Not in scope: `writeIORef'
13:39:09 <ihope> @type Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef ref a >> Data.IORef.readIORef ref
13:39:10 <lambdabot> Not in scope: `a'
13:39:20 <ihope> @type \a -> Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef ref a >> Data.IORef.readIORef ref
13:39:20 <lambdabot> forall a.
13:39:20 <lambdabot>                                     a
13:39:20 <lambdabot>                                     -> IO a
13:39:27 <ihope> Hmm.
13:39:34 <ihope> @type \a -> Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef ref a >> Data.IORef.readIORef ref :: a -> IO b
13:39:35 <lambdabot>   Couldn't match `IO' against `(->) t'
13:39:35 <lambdabot>   Expected type: IO a
13:39:43 <ihope> Hmm.
13:40:30 <davidhouse> what's a?
13:40:36 <davidhouse> never mind
13:41:01 <mathrick> I still don't understand "(->) syntax
13:41:12 <mathrick> how should it be read?
13:41:30 <jyp> (->) a b   is equivalent to   (a -> b)
13:41:42 <mathrick> and (->) t?
13:41:45 <mathrick> it's curried?
13:41:49 <davidhouse> ihope, surely if you're writing something with type a then when you read it you'll get back something of type a?
13:41:49 <jyp> yup
13:42:21 <ihope> davidhouse: well, the IORef thingy has type forall a. IORef a.
13:42:28 <mathrick> jyp: with the type of the second argument being free?
13:42:41 <ihope> Writing to it gets me forall a. IORef a, and reading from it gets me forall a. a.
13:42:43 <jyp> mathrick: yu[
13:42:46 <jyp> mathrick: yup
13:42:56 <ihope> At least... I think that's how it works.
13:42:59 <jyp> @kind (->)
13:43:00 <lambdabot> ?? -> ? -> *
13:43:08 <jyp> @kind (->) Int
13:43:09 <lambdabot> ? -> *
13:43:13 <jyp> @kind (->) Int Int
13:43:14 <lambdabot> *
13:43:15 <mathrick> what's the diff between class and kind and type?
13:43:29 <davidhouse> classes are groups of types
13:43:32 <jyp> values have types
13:43:34 <ihope> Value :: type :: kind.
13:43:37 <jyp> types have kinds
13:43:46 <ihope> And classes have instances.
13:43:47 <davidhouse> kinds are like "types of types". type constructors have various kinds
13:43:58 <ihope> Which, well, is not the same thing as a type of a class.
13:44:02 <mathrick> and where do classes fall in?
13:44:07 <davidhouse> @kind Maybe
13:44:08 <lambdabot> * -> *
13:44:10 <ihope> Well...
13:44:17 <davidhouse> @kind State
13:44:18 <jyp> classes capture complex properties of types.
13:44:18 <lambdabot> Not in scope: type constructor or class `State'
13:44:25 <davidhouse> @kind Control.Monad.State
13:44:25 <ihope> Type variables have classes.
13:44:26 <lambdabot> Not in scope: type constructor or class `Control.Monad.State'
13:44:31 <ihope> Or, well.
13:44:32 <davidhouse> @kind Control.Monad.State.State
13:44:33 <lambdabot> * -> * -> *
13:44:48 <ihope> forall a. Num a => a -- the class is Num, and a has to be in that class.
13:45:06 <mathrick> okay, so I can get the class concept
13:45:08 <mathrick> but not kind
13:45:26 <jyp> mathrick: let's see some examples
13:45:30 <jyp> @kind Int
13:45:31 <lambdabot> *
13:45:40 <ihope> Well... if you think of types as values and type constructors as functions, then you can think of kinds as types.
13:45:42 <jyp> @kind []
13:45:42 <lambdabot> * -> *
13:45:49 <mathrick> jyp: and that means ...?
13:45:49 <jyp> @kind [Int]
13:45:50 <lambdabot> *
13:45:51 <davidhouse> think about Maybe. it's a bit like a data constructor, in that you appear to be giving it parameters. but instead of passing it values, you're passing it types
13:46:04 <ihope> @kind Int :: #
13:46:05 <lambdabot> parse error on input `::'
13:46:10 <ihope> Bleh.
13:46:18 <jyp> @kind Maybe
13:46:19 <lambdabot> * -> *
13:46:21 <ihope> No kind annotations?
13:46:23 <davidhouse> so it takes one type, and returns another type. so in a sense, Maybe has a "type" of its own. this "type of a type" is called a kind
13:46:32 <jyp> mathrick: can you see the pattern?
13:46:59 <jyp> mathrick: "normal" types have kind *
13:47:00 <ihope> @kind #Int
13:47:00 <lambdabot> lexical error
13:47:04 <ihope> @kind Int#
13:47:05 <lambdabot> Not in scope: type constructor or class `Int#'
13:47:07 <mathrick> hmm
13:47:10 * mathrick thinks
13:47:48 <mathrick> so for example, you'd have a kind of "parametrised types with two parameters"?
13:47:54 <jyp> mathrick: when you apply a type of kind * to one of kind * -> * you get kind *
13:47:58 <ihope> @index Int#
13:47:59 <lambdabot> bzzt
13:48:04 <jyp> mathrick: exactly
13:48:11 <mathrick> okay
13:48:20 <jyp> @kind GHC.Int#
13:48:21 <lambdabot> Couldn't find qualified module.
13:48:21 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
13:48:21 <lambdabot> \\)?
13:48:22 <davidhouse> a parametrised type constructor with two parameters has kind * -> * -> *
13:48:54 <mathrick> okay, and are kinds actually used anywhere?
13:49:04 <davidhouse> only in kind errors ;)
13:49:18 <davidhouse> i.e. if you tried to do something like f :: Int -> Maybe, it would give you a kind error
13:49:35 <davidhouse> because you need to give Maybe a parameter, and you haven't.
13:49:39 <jyp> mathrick: all the time inside the compiler; only rarely by the user
13:49:56 <mathrick> aha
13:49:58 <mathrick> I see
13:50:13 <davidhouse> (strictly speaking, it's because you've tried to force something with kind * -> * down (->), which is expecting something of kind *)
13:50:20 <ihope> @index (+#)
13:50:20 <lambdabot> bzzt
13:51:03 <mathrick> I don't suppose there are any metakinds around?
13:51:16 <jyp> not in haskell
13:51:31 <ihope> Metakinds would be scary.
13:52:04 <ihope> Would they be necessary, though, for user-defined kinds?
13:52:11 <jyp> I think there are in Omega (?)
13:52:21 <davidhouse> metakinds being the analogy of metatypes, i assume, which are?
13:52:54 <jyp> I took metakinds to mean kinds of kinds.
13:53:07 <ihope> Metatypes = kinds?
13:53:30 <jyp> iirc, in Cayenne, values = types = kinds = metakinds.
13:53:36 <mathrick> jyp: yep, kinds of kinds
13:54:03 <jyp> but you can have a whole infinite such stack of kinds.
13:54:11 <mathrick> and how do the metatypes work?
13:54:24 <davidhouse> jyp, sounds scary.
13:54:31 <davidhouse> i want kind classes :)
13:54:32 <mathrick> jyp: well, yeah, but it loses any sensible interpretation above the kind
13:54:53 <davidhouse> i want to be able to declare certain kinds as instances of kind classes like EqK, and then compare types of things
13:55:02 <jyp> apparently for some mathematicians it's very sensible.
13:55:21 <jyp> davidhouse: try cayenne :)
13:55:26 <davidhouse> although i'm not sure how useful it'd be beyond EqK.
13:55:40 <mathrick> what's cayenne?
13:55:57 <jyp> A haskell-like language with dependent types
13:56:21 <jyp> @where cayenne
13:56:21 <lambdabot> I know nothing about cayenne.
13:56:23 <mathrick> is cayenne a pun on Curry?
13:56:41 <jyp> If lennart was around he could answer you :)
13:57:31 <jyp> @where+ cayenne http://www.cs.chalmers.se/~augustss/cayenne/index.html
13:57:32 <lambdabot> Done.
13:58:08 <twobitsprite> any particular reason you can't do "4 < 5 < 6"?
13:58:31 <davidhouse> because 4 < 5 has type Bool
13:58:32 <jyp> yes...
13:58:41 <jyp> @type 4 < 5 < 6
13:58:41 <lambdabot>   precedence parsing error
13:58:41 <lambdabot>    cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix
13:58:41 <lambdabot> expression
13:58:42 <davidhouse> and there's no function (<) :: Bool -> Int -> Bool
13:58:46 <twobitsprite> ahh
13:58:47 <twobitsprite> :P
13:58:53 <ihope> That should be special syntax or something/
13:58:53 <jyp> > 4 < 5 < 6
13:58:54 <lambdabot>   precedence parsing error
13:58:54 <lambdabot>    cannot mix `(<)' [infix 4] and `(<)' [infix 4] in the same infix
13:58:54 <lambdabot> expression
13:59:50 <davidhouse> > (4 < 5) < 6
13:59:51 <lambdabot>  add an instance declaration for (Num Bool)
14:00:26 <ihope> > (4 < 5) && (5 < 6)
14:00:27 <lambdabot> True
14:01:01 <davidhouse> > let lt2 a b c = a < b && b < c in lt2 4 5 6
14:01:02 <lambdabot> True
14:01:59 <twobitsprite> > 4 < 5 && 5 < 6
14:02:01 <lambdabot> True
14:02:43 <jyp> > liftM2 (&&) (4 <) (< 6) 5
14:02:43 <lambdabot> True
14:02:50 <ihope> This looks simple enough.
14:03:14 <jyp> True
14:03:21 <jyp> :)
14:03:21 <ihope> :-)
14:03:34 <ihope> Check my MVar for a message; if there's one, handle it; yield; start over.
14:04:06 <ihope> What happens if I yield while all the other threads are blocked?
14:04:12 <ihope> Do I yield to myself?
14:04:23 <jyp> yes, afaict
14:04:56 <ihope> And if nothing ever yields, does the non-yielding thread hog all the everything? :-)
14:05:23 <ihope> @index finally
14:05:24 <lambdabot> Control.Exception, Distribution.Compat.Exception
14:05:27 <jyp> I guess
14:15:45 <musasabi> Anyone with experience with the Haddock parser?
14:16:33 <musasabi> I have GADT support working mostly but it needs some tweaks in the parser.
14:25:40 <SyntaxNinja> dcoutts: alive?
14:25:50 <SyntaxNinja> dons: alive?
14:36:45 <musasabi> Does anyone have a fast mime-decoder/encoder for use with FastPackedStrings or at least reasonably memory efficient for e.g. 1mb messages?
14:38:05 * palomer has just realized how much he really despises his professor
14:39:37 <wilx> Heh.
14:39:38 <wilx> Why?
14:40:19 <palomer> because she spends her time shooting out slogans without ever explaining anything
14:40:35 <palomer> her favourite tricks is to make 2 columns on the board
14:40:48 <palomer> something of the sort "proofs           programs"
14:40:59 <palomer> and then s/tricks/trick
14:41:08 <palomer> and then she'll put some words on the left hand column
14:41:12 <palomer> and some words on the right
14:41:22 <palomer> and then she'll babble on about curry-howard
14:41:26 <palomer> _without ever proving anything_
14:41:32 <palomer> gah!
14:43:56 <wilx> Hmm, well, some courses do not have the space for prooving everything.
14:52:20 <palomer> at least give a convincing argument
14:52:25 <palomer> instead of simply waving your hands
14:52:29 * palomer hates slogans
14:52:47 <palomer> hah, pugs is implemented in haskell
15:04:57 <sili> haskell hurts my brain
15:05:25 <jyp> it can be a painful cure indeed :)
15:06:17 <sili> jyp: i have a felling cool stuff is in the works, but can't fully grok it all yet
15:08:54 <SyntaxNinja> sili: your feeling is right :)
15:16:09 * davidhouse gets the hang of monad transformers
15:16:14 <davidhouse> that was... shockingly easy
15:16:20 * jyp rejoices
15:16:22 * davidhouse feels he needs something more challenging
15:16:31 <davidhouse> jyp, i gave up on your lambda thing :P
15:16:52 <jyp> why so ?
15:17:01 <davidhouse> couldn't get my head round it.
15:17:29 <jyp> maybe try again some time :)
15:17:44 <davidhouse> i don't think i ever fully understood what i was trying to model, and i didn't want to bother you with loads of questions and end up with you basically writing it all for me
15:18:20 <jyp> You can also just read the paper...
15:18:33 <davidhouse> oh, nuts, i forgot about that
15:18:54 <davidhouse> :) maybe i'll have another whack
15:19:08 <davidhouse> jyp, got the URL again?
15:19:15 <jyp> it's quite interesting how the monad transformer things are already implicit in there
15:19:27 <jyp> @google wadler monads
15:19:29 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
15:19:45 <jyp> The essence of functional programming
15:19:53 <jyp> at the end
15:19:54 <davidhouse> y'know, writer is a really easy monad.
15:19:58 <davidhouse> jyp, thnks
15:20:06 * jyp tips his hat
15:20:31 <twobitsprite> hmm... without any mutable datatypes, how does one create circular data structures?
15:20:46 <jyp> twobitsprite: with lazyness
15:21:00 * twobitsprite contemplates this
15:21:42 <KOC> jyp, what were you working on
15:21:57 <jyp> http://web.comlab.ox.ac.uk/oucl/work/duncan.coutts/papers/recursive_data_structures_in_haskell.pdf
15:22:08 <jyp> KOC: ?
15:22:29 <jyp> KOC: at what time?
15:23:14 <KOC> oh it seems there was some serious lag
15:23:30 <KOC> whatever davidhouse was trying to wrap his head around
15:23:44 <davidhouse> a simple evaluator for lambdas
15:25:19 <KOC> oh? sounds interest
15:25:22 <KOC> ing
15:25:59 <jyp> @timein jyp
15:26:01 <lambdabot> Local time for jyp is Sat Mar 18 00:25:39
15:26:06 <jyp> tts...
15:28:25 <heatsink> I'm trying to plug a heap space leak... how can I tell if a library function is strict in its argument?
15:28:40 <heatsink> specifically, I'm looking at Data.IntMap.update
15:32:24 <twobitsprite> ahh... but to chang any value in a complex circular data structure, you'd have to completely rebuild it...
15:34:51 <heatsink> true.
15:35:24 <heatsink> You can get around that by using indirection.
15:35:46 <TuringTest> twobitsprite: Well, if your node's data is in a separate type from the linking type, then just the linking types need to be reconstructed.
15:36:59 <TuringTest> @type Data.IntMap.update
15:36:59 <lambdabot> forall a.
15:36:59 <lambdabot>         (a -> Maybe a)
15:36:59 <lambdabot>         -> Data.IntMap.Key
15:36:59 <lambdabot>         -> Data.IntMap.IntMap a
15:36:59 <lambdabot>         -> Data.IntMap.IntMap a
15:37:28 <heatsink> How can I update an IntMap so that the function :: (a -> Maybe a) evaluates immediately?
15:37:40 <heatsink> It evaluates lazily... I tested with Debug.Trace
15:38:02 <heatsink> I think that's holding on to data and causing heap overflow.
15:38:15 <TuringTest> heatsink: You can query the IntMap after each update...
15:38:58 <heatsink> hmm... I'll try that.  Seems like a kinda lame way to do it, though.
15:40:16 <TuringTest> Typically people want Haskell to be lazy, so that is the default.   Perhaps Edison has a better API for you.
15:44:34 <twobitsprite> I'm trying to think of how one would make a game board that's updatable...
15:44:45 <TuringTest> STArray
15:45:01 <twobitsprite> @hoogle STArray
15:45:02 <lambdabot> Data.Array.ST.STArray :: STArray s i e
15:45:02 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i
15:45:02 <lambdabot> e
15:45:02 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
15:45:02 <lambdabot> m (a i e)
15:45:36 <TuringTest> Your size is fixed, so the fixed bounds of an Array are not an obstacle.  The contents of the STArray can be any Haskell data type.
15:45:50 <TuringTest> The Array can be 2D like a game board...
15:46:02 <twobitsprite> I don't see docs for it on the Zvon site
15:46:34 <Excedrin> has anyone written a chess program in Haskell?
15:46:50 <TuringTest> http://cvs.savannah.nongnu.org/viewcvs/xadrez-haskell/xadrez-haskell/doc/index.html?rev=1.5
15:47:22 <twobitsprite> @where STArray
15:47:23 <lambdabot> I know nothing about starray.
15:48:07 <twobitsprite> I can't find anything about STArray...
15:48:08 <TuringTest> twobitsprite: start here http://www.haskell.org/haskellwiki/Arrays
15:48:49 <TuringTest> There are more wiki examples here http://haskell.org/hawiki/ImperativeHaskell
15:49:08 <TuringTest> STArray is very very similar to IOArray
15:49:19 <TuringTest> STUArray is very very similar to IOUArray
15:51:25 <heatsink> oh cool, I didn't have to write a trie implementation
15:51:59 <TuringTest> heatsink: Where did you grab the code from?
15:53:05 <heatsink> TuringTest: http://www.eecs.tufts.edu/~rdocki01/edison.html
16:01:46 * heatsink tries to figure out where the description for ghc-pkg is
16:06:12 <twobitsprite> can a module import something from another module and then re-export it?
16:06:41 <int-e> yes
16:08:43 <heatsink> I registered Edison with ghc-pkg, but I can't import anything from it
16:15:50 <heatsink> ah... must install it in the same prefix as all other libs.
16:16:44 <TuringTest> heatsink: Or you can use some command line switches, I think
16:17:15 <TuringTest> -i<dirs>
16:18:25 <twobitsprite> how do I check list membership?
16:19:46 <heatsink> elem
16:26:28 <Revision17> If I have a module (Parser) with a data type in it (Node) and I want to use it in another module, is there a way I can get around having to use Parser. or P. ("import qualified Parser as P")?
16:28:03 <heatsink> Hmm... GHC can't find the Edison library if I try to compile with profiling, but otherwise it finds.  Do I need to recompile the library for profiling?
16:28:18 <SyntaxNinja> heatsink: yea
16:28:31 <heatsink> Revision17, import Parser(Node)
16:29:13 <heatsink> if you want constructors/field accessors, then put those in parentheses after "Node".  If you want all constructors/field accessors of Node, use (..)
16:29:52 <Revision17> heatsink:  so import Parser (Node(..))?
16:30:06 <heatsink> Revision17, yes
16:30:38 <Revision17> hmm kinda funky syntax; I was trying import Parser(Node) before
16:31:03 <Revision17> well, thanks
16:31:06 <Revision17> :)
16:31:06 <Cale> well, that would just import the type
16:31:10 <Cale> and not the constructors
16:31:56 <Revision17> Cale:  it seemed to me that the type would be almost useless without the constructors, so I just asssumed if it worked it would import them
16:32:04 <Revision17> but now I know otherwise
16:32:35 <Cale> yeah, it's actually quite common to have a module where you don't export the constructors of a type
16:32:56 <heatsink> Actually, are field names imported like regular functions?
16:33:19 <Cale> heatsink: almost -- of course, the record syntax works with them
16:34:38 * heatsink doesn't see an option to pass extra flags to the compiler through the Cabal build system
16:37:09 <heatsink> How can I compile a package for ghc profiling with a Cabal build system?
16:41:29 <SyntaxNinja> heatsink: ./setup configure --help |grep prof
16:42:22 <SyntaxNinja> (if you get nothing, try a newer cabal)
16:43:32 <heatsink> I've got version 1.0, which seems to be the newest
16:43:39 <heatsink> but I got nothing
16:50:10 <araujo> im using 1.1.3 here
16:54:05 <heatsink> oh, I see it.
16:54:24 <heatsink> I might need to download that... but for now, at least I got past the heap overflow problem.
16:54:32 <heatsink> Now to deal with this stack overflow...
16:54:41 <heatsink> :J
16:59:12 <heatsink> thanks ninja, araujo, turing
16:59:23 <dcoutts> SyntaxNinja, pong
16:59:30 <ihope> Whoa, I stayed connected all this time?
16:59:47 <ihope> Anyway... when a thread blocks, it automatically yields, right?
17:00:33 <adu> ihope: isn't that amazing when that happens?
17:00:48 <ihope> Um...
17:01:08 <ihope> But does it?
17:11:29 <Revision17> Is there a way to do exponentiation on two doubles in the standard library?
17:11:42 <ihope> > ((12+144+20+3*sqrt 4)/7)+5*11 == 9^2
17:11:43 <lambdabot> True
17:12:22 <Revision17> > 5.2 ^ 1.3
17:12:22 <lambdabot> Add a type signature
17:12:31 <ihope> Use **, not 
17:12:36 <ihope> Not ^, that is
17:12:48 <Revision17> > 5.2 ** 1.3
17:12:50 <lambdabot> 8.527158718823063
17:12:54 <ihope> See? A dozen, a gross and a score plus three times the square root of four divided by seven plus five times eleven is nine squared and not a bit more.
17:13:23 <Revision17> why is there the difference in function names for exponentiation between Integers and Doubles?
17:13:36 <ihope> Well... I dunno.
17:14:20 <ihope> @type (^)
17:14:21 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:14:23 <ihope> @type (^^)
17:14:24 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:14:26 <ihope> @type (**)
17:14:27 <lambdabot> forall a. (Floating a) => a -> a -> a
17:15:17 <ihope> I guess their domains aren't subsets of each other.
17:16:05 <ihope> But every Fractional is also a Num, so it looks like (^) should work on everything (^^) does.
17:16:18 <Revision17> I guess that makes sense
17:16:49 <ihope> But an Integral is not a Floating, nor vice versa.
17:17:52 <ihope> Apparently (**) is a class method, but (^) is... well, I dunno.
17:19:59 <Revision17> another sorta related question; show (1/0) gives "Infinity"; is there a way to write infinity other than (x/0)?
17:20:09 <adu> ihope: if you only consider one argument at a time their domains could both be considered subsets of each other
17:27:02 <ihope> adu: true, but I'm not considering one at a time :-)
17:31:25 <sjanssen> (^) is separate from (^^) because a negative exponent requires Fractional numbers
17:32:07 <sjanssen> (^) and (^^) are separate from (**) because there is a fast algorithm for doing powers with integral exponents
17:32:12 <ihope> Ah.
17:34:48 <ihope> Is the square thing the fastest onw known?
17:35:53 <sjanssen> I don't know of any algorithms that are better than logarithmic time
17:36:20 <ihope> I guess logarithmic time is as fast as it gets.
17:36:36 <ihope> After all, the time it takes to *access* a number is in log time.
17:40:22 <dancor> is there a multimap for haskell
17:41:40 <ihope> A what?
17:41:46 <ihope> @google define:multimap
17:41:47 <lambdabot> No Result Found.
17:42:16 <sjanssen> I think a multimap is a set with repeated keys
17:42:21 <dancor> so i can be like scrabblePointVals = makeMMap [("aeiourstln", 1), ("dg", 2), ..]
17:42:22 <ihope> Maybe an array of lists?
17:42:40 <dancor> then lookup 'a' and get 1
17:42:58 <dancor> like a finite map..
17:43:02 <ihope> Oh, I see.
17:43:04 <sjanssen> dancor: I don't think that is a multimap . . .
17:43:10 <ihope> Well, you could always create one.
17:43:35 <ihope> data Multimap i a = Multimap [(i,a)]
17:43:44 <dancor> ihope: true, it's multi on the keys not the values
17:44:04 <sjanssen> dancor: you want many keys to one value?
17:44:11 <dancor> sjanssen: yeh
17:44:29 <ihope> lookup x m = map snd (filter m ((== x) . fst))
17:44:44 <ihope> Um...
17:44:46 <sjanssen> dancor: so would a standard map (ie Data.Map) work?
17:44:59 <ihope> data Multimap i a = Multimap {runMultimap [(i,a)]}
17:45:20 <ihope> lookup x m = map snd (filter ((== x) . fst) (runMultimap m))
17:45:36 <dancor> ihope: heh well that was fast
17:45:57 <sjanssen> that is really slow though
17:46:04 <dancor> heh
17:46:35 <dancor> sjanssen: i could make a map, expanding the multikeys to separate key,value pairs
17:46:46 <sjanssen> dancor: that is what I would do
17:46:57 <dancor> i guess it depends what's important
17:47:36 <KOC> is there a newer version of greencard besides 3.01
17:47:53 <KOC> because it seems like my compile is having a lot of trouble
17:48:03 <dancor> is map faster than writing our own mmap?
17:48:31 <dancor> is it like written in c or something?  or are you just saying we could be faster in our implementation of mmap
17:49:01 <sjanssen> I'm saying that lookup in ihope's implementation is linear, where Data.Map is logarithmic
17:49:29 <dancor> oh right of course you could use some cooler structure like a hash or balanced tree
18:03:36 <musasabi> For multimap one can simply use "type MultiMap k v = Data.Map k [v]"
18:07:53 <dons> Moin!
18:08:30 <KOC> is the format for packages given to ghc-pkg documented anywhere? i cant seem to google it
18:10:19 <musasabi> KOC: http://haskell.org/ghc/docs/latest/html/users_guide/packages.html ?
18:11:17 * ihope bye byes
18:12:05 <dons> \seen jips
18:12:06 <lambdabot> jips is in #haskell. Last spoke 9 hours, 20 minutes and 38 seconds ago.
18:12:43 <dons> jips, that sounds like a possibility for the bug, yes. good work :)
18:13:16 <dons> what you can do is ealuate the list (using length, for example). that will ensure it is read.
18:17:54 * musasabi usually uses "lseq [] r = r; lseq (x:xs) r = x `seq` lseq xs r" for shallow evalution of lists
18:25:10 <dons> i often use something like: forkIO (Control.Exception.evaluate (length output) >> return ())
18:25:19 <dons> since we're in IO reading the file anyway
18:25:47 <dons> thiis idea is from simon m
18:32:52 <KOC> ok so i am getting the error "Line 31: Invalid syntax (no colon after field name)" where Line 31 contains only "}" (presumably the ending of a Package definition)
18:33:02 <KOC> this is with ghc-pkg 
18:34:54 <KOC> and the specifications for the file i found only talk about fields and their meanings, not about the entire file
20:34:36 <dancor> why does Data.Map lookup return a monad?
20:36:27 <Korollary> because the lookup may fail
20:36:38 <dancor> hmm
20:36:41 <akemp> Then why doesn't "!" return a monad?
20:37:07 <Korollary> well, there are many ways to handle such failures
20:37:12 <dancor> do i have to do anything special to do a lookup?  i get errors just doing it
20:37:50 <Korollary> not really. if you are sure the lookup will succeed, you can pattern match against (Just value), and if it fails, it's an error.
20:39:43 <dancor> hmm why is the return type "Monad m => m" instead of "Maybe m" specifically?
20:42:18 <dancor> hmm i can't just do: fn :: Int, fn = lookup 'myIntKey' myMap
20:42:38 <akemp> Couldn't you also just use "!"?
20:43:00 <Korollary> dancor: do fromJust (lookup ....)
20:43:32 <dancor> right.  fromJust.  why does it return to a general monad instead of a Maybe?
20:43:41 <dancor> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
20:43:56 <Korollary> It's more general that way. Maybe you'd like an empty list instead of Nothing.
20:45:36 <dancor> you could treat the result of lookup as a List?
20:47:37 <Korollary> I'm just guessing that a failed lookup return the zero element of whatever monad you want to use.
20:48:18 <dancor> i think you are right.  but it's still a bit odd.
20:49:12 <Korollary> well, maybe you want to build up a list from lookups. Then, it just works.
20:51:05 <dancor> i suppose that is the motivation
20:51:11 <dancor> interesting
20:51:22 <dancor> seems like a hack :)
20:51:40 <Korollary> on the contrary. It's a generalization.
20:51:50 <dancor> not a very general one :)
20:51:58 <Korollary> monads are very general.
20:52:28 <dancor> indeed.
20:58:02 <dancor> hmm ghc thinks this has type 't t1' not Int: do fromJust (Data.Map.lookup 'a' woot)
20:58:20 <dancor> woot = insert 'a' 50 empty
20:59:09 <Korollary> I didn't mean the "do" literally.
20:59:40 <dancor> heh got it
20:59:55 <dancor> sorry all this talk of monads
21:00:16 <Korollary> it's a popular topic around these parts.
21:01:47 <dancor> and do is a popular word, in several languages.
21:15:58 <vincenz> even english
