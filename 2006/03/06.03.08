02:45:13 <shapr> While I was in Athens I went to a Communist Youth block-party.
02:45:17 <shapr> Silly american...
02:45:18 <tromp_> what framework would you rather use?
02:45:25 <jethr0> shapr: tell them it's just the inflation they're controlling themselves
02:45:53 <jethr0> _plus_, they can print their own money
02:45:56 <tromp_> you're not a ruby guy...
02:46:14 <shapr> I realized that a bunch of deep & serious evil hides behind the overall cover of Communism. I saw a lot of terrifying stuff.
02:46:33 <shapr> tromp_: I'd like to try Ruby on Rails, Seaside, and some others.
02:46:53 <shapr> I have the beginnings of a Haskell framework in mind, but I'm not sure how to make it really usable.
02:47:14 <jethr0> communism is a little dead right now. even china is moving silently away and cuba doesn't really count. but who cares for the mainstream anyways...
02:47:19 <shapr> Biggest problem I have now is that i18n is impossible with the string substitution based approach.
02:47:47 <tromp_> you've studied HSP and WASH as well?
02:48:15 <shapr> So I figure, use a Data.Graph value to hold the website, then I can have a proxy value that can point to a whole collection of other nodes per language.
02:48:19 <shapr> Yeah, I've used both HSP and WASH.
02:48:40 <shapr> HSP is just what it says, Haskell Server Pages. It's a lot like JSP/ASP but lets you sew HTML bits together with Haskell code.
02:48:55 <shapr> WASH does a lot more, but has some weird behaviour.
02:49:26 <tromp_> does wash try to do the same as ruby on rails?
02:49:35 <shapr> On the other hand, Peter Thiemann (author of WASH) also combined Simon Marlow's Haskell Web Server with an hs-plugins version of WASH, and that looks interesting.
02:51:46 <shapr> WASH doesn't have any support for nifty front end stuff like ajax.
02:52:09 <shapr> It does have some cool cache features that are based on BigWig
02:52:18 <shapr> WASH also requires javascript for most things.
02:52:22 <shapr> It passes values around that way.
02:52:39 <shapr> WASH has a 'log' that it uses to emulate real continuation based webdesign.
02:52:51 <shapr> That can grow too large unless you know about it and truncate it when required.
02:53:01 <sili_> that's convenient
02:53:27 <shapr> WASH is focussed entirely around forms, and before stepcut's patch, had nearly zero support for dealing with links that weren't forms.
02:53:50 <sili_> :|
02:53:54 <shapr> I don't know if Thiemann applied stepcut (Jeremy Shaw)'s patch or not.
02:54:33 <shapr> Personally, I'd like to have parameterizable Data.Graph values.
02:54:50 <sili_> i'd like to know more haskell.
02:55:04 <shapr> One big problem with xml templating in Zope is that you can't include one template in another, everything has to be sewn together in the top level.
02:55:49 <shapr> With HaXml, you could find out which xml tags a template could produce, and get some 'type safety' by matching that with the DTD.
02:56:14 <shapr> That way, you could do recursively included xml templates and it'd probably work.
02:58:08 <shapr> I'd like to stick my Data.Graph values on top of Oleg's ZFS, because that gives you version control. You'd be able to have the development site in the same graph value as the production site, and when you're done with the dev site, set the 'public site' pointer to the dev site.
02:58:12 <shapr> All values would be shared, etc.
02:59:19 <shapr> Zope uses the ZODB, which is an object database held inside a single file. That's way cool for efficient searching, attaching random properties to an instance, etc. But it sucks very much when you end with a big binary blob that you can't access with grep, find, etc
03:00:06 <shapr> One advantage of Data.Graph is that it uses inductive graphs, so you could easily file out the contents into the filesystem.
03:00:10 <shapr> Or so I like to believe :-)
03:00:26 * shapr notes the sudden exodus of users from the channel ;-)
03:00:43 <tromp_> startkeylogger
03:00:45 <tromp_> :P
03:00:48 * shapr snickers
03:01:08 <shapr> Far worse is a long boring diatribe on how web frameworks could be built in Haskell ;-)
03:01:41 <tromp_> slashdot links to an article about  Exploring Active Record
03:02:10 <shapr> What do you think? How would you approach a Haskell WebApp framework?
03:02:15 <Saulzar> I thought that if Haskell could _not_ build web frameworks that would be a tremendous advantage :)
03:02:37 <musasabi> HAppS has some XML templating.
03:03:05 <shapr> musasabi: Could SerTH work for HaskellDB as well?
03:03:07 <musasabi> but it goes with the xslt route or gives it to the browser.
03:03:30 <tromp_> never having used any web framework, i cannot sensibly comment:(
03:03:41 <musasabi> shapr: yes, it could work with HaskellDB, but I haven't recently have time to do much stuff with it.
03:04:32 <shapr> I think SerTHDB would be nicer than any database backed persistence tool I've seen yet.
03:04:49 <musasabi> HaskellDB would benefit if Haskell had a proper record system, like the Daan's one they are discussing on haskell-prime ml.
03:05:22 <shapr> Yeah, especially since Daan wrote the first HaskellDB version and used T-Rex to do it.
03:06:02 <musasabi> shapr: actually the code gets quite painfull when one tries to decide whether keep the data in the cache as a FastPackedString/Ptr or haskell values and how to minimize the amount of converting between them.
03:06:28 <shapr> I can believe it.
03:06:40 <shapr> Can you just leave that to the programmer somehow?
03:07:06 <shapr> Or are there global maxima to that problem?
03:08:42 <musasabi> Think of a simple persistent "Map k v" as a B+tree. When performing lookups we need to convert everything to Haskell values. When writing to buffer cache we need raw values, and if we keep both we have halved the size of data we can cache.
03:09:35 <shapr> Can you gc the least used item?
03:11:08 <musasabi> yes, but that requires a doubly linked list of IORef/MVar (depending who locks) which is not free either (for LRU book-keeping).
03:11:26 <shapr> yow
03:12:08 <jethr0> shapr: which features of zope/plone are you using most? i.e. what are the killer applications for your special case?
03:12:11 <musasabi> of course if the thing is in STM that means unsafeIOtoSTM, because the caching behaviour should not be transactional, which has some issues.
03:12:26 <shapr> even more yow
03:13:13 <araujo> Hola
03:13:33 <shapr> jethr0: special case?
03:14:04 <jethr0> the "app"/pages you're currently writing
03:14:40 <jethr0> i was wondering which functionality one would start with if one wanted to write zope in haskell. i guess templating and persistence are high on the list, right?
03:14:48 <shapr> jethr0: I'd say I use mapping of url to code or page, code bits in xml templates, and i18n
03:16:30 <shapr> andrew cooke wrote a clone of the zope page templates in Haskell, it's called halipeto
03:16:43 <shapr> I used it for my ScannedInAvian.org site (currently down)
03:16:43 <jethr0> yes, i've seen you're using it on your homepage
03:16:54 <jethr0> even downloaded it but was too lazy to install/use it yet
03:17:05 <tromp_> is finland part of scandinavia?
03:17:22 <shapr> I'm in Sweden for the last few years.
03:17:27 <shapr> But was in Finland before.
03:17:39 <tromp_> i always thought so, but wikipedia suggests it's controversial
03:18:06 <shapr> Do you like the ScannedInAvian logo my gf made? -> http://www.scannedinavian.com/
03:19:07 <tromp_> the characters are cute, but the meaning is hard to grasp
03:19:21 <shapr> jethr0: So, map an url to a data.graph value?
03:19:25 <tromp_> they guy holder the scanner is supposed to be in flight?
03:19:36 <shapr> Nah, he's just holding a scanner up to an avian.
03:19:46 <shapr> @wn avian
03:19:48 <jethr0> shapr: huh?
03:19:48 <lambdabot> *** "avian" wn "WordNet (r) 2.0"
03:19:48 <lambdabot> avian
03:19:48 <lambdabot>   adj : pertaining to or characteristic of birds
03:20:00 <tromp_> oh
03:20:21 <tromp_> i thought of aviators
03:20:26 <jethr0> shapr: you mean putting urls into a graph and "substituting" them by their content?
03:20:47 <shapr> tromp_: It comes from a long ago IRC joke, I said I live in Finland, on the internet, and I'm an open source addict. So the internet penguin in Finland would be a scanned in avian, yeah?
03:21:29 <shapr> jethr0: If you can think up some way to map urls to a node inside a data.graph value, I already know how to deal with i18n inside a data.graph value.
03:22:10 <tromp_> i understand "scanned avian" but the "in" doesn't seem to fit
03:22:16 <shapr> I guess the root node could be the root of the website, and you could have specially marked nodes to denote dirs.
03:22:29 <shapr> tromp_: He's been scanned in, so now he's virtual.
03:22:32 <jethr0> shapr: i'm not sure i understand. does your graph content mirror the sitemap structure or is one graph for a single page?
03:22:42 <shapr> jethr0: e) all of the above
03:22:55 <jethr0> :)
03:23:01 <tromp_> except in english you wouldn't put in after scanned
03:23:03 <shapr> the ZODB is really just a big graph itself, with the ability to attach some nodes to others.
03:23:21 <jethr0> so, what does one put into the graph? content, colors?, authorization stuff?
03:23:23 <shapr> tromp_: Hm, you would in American.
03:23:33 <shapr> Oh yeah, I use authorization as well.
03:23:47 <jethr0> no, i mean _in_ the graph?
03:23:52 <shapr> like "beat up truck" "scanned in avian"
03:24:06 <jethr0> so the graph would really be a complete representation of the site modulo templates?
03:24:18 <shapr> It could hold templates as well.
03:24:46 <shapr> For example, the navigation is usually site-wide, so why not make page contents stuck into the site-wide nav?
03:24:56 <jethr0> and how do you reference other nodes? especially with online/wiki-like editing?
03:25:01 <shapr> Each link in the navigation would just be a link to a node in the graph
03:25:19 <jethr0> hmm, maybe with tree uris :)
03:25:24 <shapr> I think you'd have types of edges?
03:25:36 <shapr> tree uris?
03:26:04 <shapr> What's that?
03:26:04 <jethr0> well, you have a tree already. and now you want to create a "link"/inline one of the nodes. how do you reference it?
03:26:45 <tromp_> since scanned avian denotes the result of scanning, shldn't the logo show like a 2d image produced by the scanner?
03:26:46 <jethr0> x = NodeLink ?
03:26:59 <shapr> The tree is just a view of the graph value. The links would be the same kind of thing. Ask a node for its 'pagelink' edges, maybe?
03:27:17 <shapr> y0 pesco 
03:27:17 <Saulzar> Hmm, that sounds quite a radical way to store a site.
03:27:30 <shapr> Saulzar: I thought it was the only sensible approach... 
03:27:43 <jethr0> hmm, i'm not convinced how that would work with text-only editing by non-domain-specialists
03:27:43 <shapr> I thought all the others were radical to insane =)
03:27:50 <Saulzar> Still, it's nothing like I've ever used :)
03:28:07 <shapr> jethr0: Ok, fair enough... I'd be happy with something *I* could use.
03:28:14 <jethr0> hehe
03:28:19 <shapr> On the hand, this is still simpler than the ZODB, and it's used by mucho people.
03:28:25 <shapr> other*
03:28:33 <Saulzar> Hmm - could always have import/export to static pages
03:28:46 <shapr> I think the inductive graph approach is better.
03:28:53 <jethr0> shapr: how would the database tie into this (for example for access control?)
03:29:40 <shapr> Well, I'd think that you could have a thunk that calls a function, or describe access directly in the graph.
03:29:52 <shapr> privs and permissions in Zope are a complete nightmare.
03:30:13 <shapr> I'd be much happier looking at a graphical representation of why I don't have access
03:31:17 * pierre- just finished arithmetical expressions calculator
03:31:19 <shapr> Saulzar: inductive graphs are built from the empty graph node-by-node. I think that would guarantee an on-disk representation as long as the contents of each node could be saved to disk.
03:31:27 <jethr0> i'm interested in this but not really convinced. but i guess you've had long python hours to brood over it :)
03:31:40 <shapr> Saulzar: How would you compare the inductive graph approach to others you know?
03:32:01 <shapr> jethr0: ok, for user simplicity, let's assume that the site structure is described by the filesystem.
03:32:09 <jethr0> hmm
03:32:16 * shapr is making this up off the top of his head
03:32:47 <shapr> assume that a dir must have a text file named "root" that holds global site values or something.
03:32:54 <jethr0> k
03:32:56 <Saulzar> shapr, I've only ever used php for simple sites.
03:33:22 <shapr> dirs underneath that would be reached by uri, and the files would be inductive graph nodes.
03:33:28 <shapr> Is that more convincing?
03:33:38 <shapr> Or alternately, what's unconvincing about what I described so far?
03:33:57 <jethr0> that's how i understood it all along. but i guess i'd have to look closer at how zope works to get the applicability
03:33:58 <shapr> I'm aware it's just the skeleton of an idea, but I'm not sure where to go next, thus this discussion helps flesh out the idea :-)
03:34:43 <jethr0> so would you serialize the tree as a whole into a DB?
03:34:53 <shapr> I'd put it on the filesystem.
03:34:57 <Saulzar> Sounds interesting, how much of it could be statically typed?
03:35:20 <shapr> Saulzar: Most or all of it, if you're willing to go to the trouble to keep up with the types.
03:35:26 <Saulzar> Seems like it could involve torture by typeclass :)
03:35:37 <pierre-> is 38 lined arithmetical expressions calculator long or short? 
03:35:51 <shapr> I was thinking more about runtime checking of universal quantification.
03:36:16 <jethr0> shapr: but what about cycles in the graph?
03:36:54 <shapr> I don't think that's a problem with inductive graphs. Edges in fgl only go one way, you have to make two to get a cycle.
03:36:59 <jethr0> pierre-: does it parse the input?
03:37:50 <jethr0> shapr: let's say you'd want to add a user to be able to read/write to all pages. so you'd deserialize the whole tree, add permissions and serialize again??
03:38:27 <jethr0> or for simple page building you'd have to do a lot of filesystem access, no?
03:38:30 <pierre-> jethr0: yes, some sort of
03:38:32 <shapr> hm, I'd use acquisition probably.
03:38:46 <shapr> That is, all nodes below here acquire the permissions declared 'above'
03:39:03 <jethr0> pierre-: 38 lines is ok given normal, short lines :)
03:39:32 <jethr0> shapr: yes, but for that you'd have to deserialize a big part of the tree for single pages, to see lookup all the inherited permissions
03:40:05 <jethr0> but i guess one would keep the tree in "memory" all the time anyways
03:40:23 <jethr0> question is how feasible that becomes spacewise
03:41:05 <Saulzar> How big are pages anyway? I assume you have references to outside resources...
03:41:26 <shapr> I think you'd only need to keep parts of the tree in memory. But it's the same problem musasabi described earlier, going between on-disk and memory representations.
03:41:46 <jethr0> one thing that become easy in such a tree is content sharing. common templates, css, ... could only exist once
03:43:27 <jethr0> i think it sounds pretty good in general. the main problem i see lies in serialization performance though
03:45:18 <musasabi> well if the data is less than a few gb one can just keep it in memory and only save snapshots to disk.
03:46:46 <jethr0> depends if you store binary blobs in the tree as well or "outsource" those. if you do, a few gb should hold most realistic sites, i think. but i might underestimate the proportions
03:47:05 <Saulzar> What kind of site would have more than 1 gb of data? Are we talking all the pages/images/database entries and everything or?
03:47:13 * shapr shrugs
03:47:15 <shapr> Could be anything.
03:47:41 <shapr> On the other hand, I'd probably create a binary node type that points to something in this dir.
03:47:51 <shapr> Then you never load it into memory, you just hand it out when people ask for it.
03:48:05 <jethr0> so, what would tree nodes need to be able to do? reference/inline other nodes, make sql lookups, templating, authorization, ...(?)
03:48:31 <shapr> reference, inline, and templating are all the same thing, roughly.
03:48:39 <jethr0> hmm
03:48:52 <shapr> You'd have a reference that's a link to another node, and a reference that includes that other node upon display.
03:49:23 <jethr0> and how would you feed session variables along? that would be independent of the tree, right?
03:49:39 <shapr> The rendering engine has to deal with that, but it doesn't take up memory or drivespace.
03:49:53 <shapr> Yeah, the tree is just a big chunk of state... except ...
03:49:56 <jethr0> and internationalization would be branches below a content node, right?
03:50:17 <shapr> You'll want some way to change the big tree from user input... like, building a web forum.
03:51:09 <jethr0> the danger i see is that it would get very messy with all these different contents it's carrying. maybe a few parallel trees might be a solution, but then you might've synchronization problems
03:51:28 <Saulzar> So the big tree is a database too, effectively? 
03:51:40 <shapr> yeah it is.
03:51:40 <jethr0> a typed, structured database :)
03:51:52 <shapr> yup, it's a typed data.graph value.
03:52:29 <shapr> That's the biggest advantage in fact, the ZODB has no types.
03:52:39 <jethr0> i'm still uncertain what to do about sessions...
03:52:42 <Saulzar> Sounds like a fairly massive sort of project :)
03:52:53 <shapr> The second biggest advantage is that an inductive graph is far easier to dump to disk than a fully connected graph like the ZODB
03:53:08 <shapr> I don't think it'd be that complicated a project, the libraries are all in place.
03:53:14 <jethr0> i was impressed that philippa's flippi wiki had only a few lines of code. but i guess it's on a different scale of magnitude :)
03:53:32 <shapr> On the other hand, I keep bouncing off Oleg's ZFS code.
03:53:41 <shapr> Delimited continuations are beyond me at the moment.
03:54:13 <jethr0> well a good tree diff would do instead, although not as neat
03:54:47 <nothingmuch> møøsen
03:55:34 <shapr> Another massive problem of the ZODB is that moving content from one database to another is insanely difficult.
03:55:51 <shapr> Thus making dev and production servers nearly impossible to sync.
03:56:46 <shapr> The zipper at the center of Oleg's ZFS is roughly the same data structure used by subversion and friends. 
03:57:08 <jethr0> i agree the zipper would be a nice solution here
03:57:20 <shapr> So you'd get versioning and maximal sharing with ZFS underneath this whole thing.
03:57:28 <jethr0> although i haven't quite grasped how you'd serialize its state
03:58:58 <shapr> serializing an inductive graph is easy if the node contents can be serialized.
03:59:04 <shapr> On top of ZFS? No clue....
03:59:53 <shapr> I'd think it'd be like a graph on top of a graph, but I'm not sure how that would translate into an on-disk representation.
03:59:59 <musasabi> ZFS needs transactional support for some kinds of links.
04:00:14 <chrisbrown> wow - just got a ghc panic!
04:01:00 <tromp_> DON'T PANIC
04:01:04 <chrisbrown> lol
04:01:24 <shapr> I'd be happy to skip the ZFS layer for the first incarnation of this idea.
04:01:28 <shapr> Oh and I have a name for it too!
04:01:29 <shapr> schvung!
04:01:33 <jethr0> and the tree would only be the data representation. all the MVC, session, ... stuff would be handled outside of it
04:01:50 <jethr0> that's a horrible name :)
04:02:08 <shapr> Oh I like it, it means "energy, bounce, verve."
04:02:17 <shapr> In Swedish.. what does it mean in German?
04:02:33 <jethr0> "schwung" means momentum
04:02:39 <edwinb> Hmm. Someone just rode past me on a unicycle. There's something you don't see every day...
04:02:45 <shapr> edwinb: Was it dcoutts?
04:03:03 <shapr> Really big 36 inch wheel with a Haskeller on top? =)
04:03:10 <edwinb> It was a she, so unlikely to be called Duncan ;)
04:03:16 <edwinb> but it was quite a big wheel.
04:03:43 <shapr> Are you in nottingham?
04:03:45 <edwinb> I am
04:04:11 <edwinb> I think I'm stealing swiert's desk.
04:06:01 <shapr> Maybe she's part of the Uni of Nottingham's juggling society?
04:06:34 <shapr> jethr0: yeah, schvung / schwung
04:07:06 <edwinb> well, it looked fun anyway ;)
04:07:28 <shapr> Ah, last saturday was Nott Another Juggling Convention
04:15:42 <sieni_> juggling <3
04:16:36 <jethr0> i am again and again in awe how pugs managed to keep single file sizes so small...
04:17:20 <shapr> Ok, now I have to document schvung on my blog, otherwise I'll forget all this useful discussion...
04:17:48 <jethr0> i'd love to give it a try. but without your superior domain knowledge i wouldn't get very far
04:18:44 <shapr> * inductive graph value holds site content
04:18:58 <shapr> * page links are graph edges
04:19:04 <shapr> * node includes are graph edges
04:19:51 <shapr> er, what else?
04:20:05 <jethr0> dunno
04:21:08 <shapr> Ok, different approach, the four most used features I mentioned were url to code mapping, templating, i18n, and authorization.
04:21:22 <shapr> jethr0: btw, do you have a blog or website?
04:21:32 <jethr0> not really
04:21:36 <shapr> Anything I can point to?
04:22:07 <jethr0> nm, when i've written it all alone i'll create a site to point to :)
04:22:40 * shapr snickers
04:34:17 <shapr> salut kowey
04:34:30 <kowey> heya shapr
04:34:41 <shapr> How's code?
04:35:17 <kowey> not so good... my fancy new algorithm is 10 times slower than the dumb one :-)
04:38:56 <shapr> Well, that happens sometimes...
05:08:44 * kowey is surprised by the usefulness of the List monad
05:08:59 <kowey> this is the first time i've used Map.lookup as a list
05:10:59 <shapr> jethr0: http://www.scannedinavian.com/~shae/blog/2006-03-08.html
05:12:53 <jethr0> cool
05:17:38 <beelsebob_> @hoogle getAll
05:17:39 <lambdabot> No matches found
05:17:46 <beelsebob_> @hoogle IO ()
05:17:47 <lambdabot> Control.Concurrent.yield :: IO ()
05:17:47 <lambdabot> Foreign.C.Error.resetErrno :: IO ()
05:17:47 <lambdabot> GHC.Conc.yield :: IO ()
05:17:50 <beelsebob_> bah
05:18:04 <beelsebob_> anyone know how to get all program input?
05:18:54 <nothingmuch> shapr: it's been a couple of hours you lying bastard
05:19:04 <shapr> whoops
05:19:06 <mauke> @hoogle getContents
05:19:06 <lambdabot> Prelude.getContents :: IO String
05:19:06 <lambdabot> System.IO.getContents :: IO String
05:19:06 <lambdabot> System.IO.hGetContents :: Handle -> IO String
05:19:06 * shapr reads
05:20:18 <beelsebob_> thanks
05:24:09 <jethr0> how come we dropped so badly on the shootout. i guess the c people couldn't take us being on top of the world anymore
05:24:48 <roconnor> @where shootout
05:24:48 <lambdabot> I know nothing about shootout.
05:26:16 <jethr0> shootout.alioth.debian.org
05:29:48 <beelsebob_> hehe, yay for me getting good at haskell...
05:30:01 <beelsebob_> XML parser written - compiled, ran and passed all test cases first time
05:30:10 <roconnor> the fannkuch haskell code looks like C
05:30:21 <roconnor>  mallocArray n
05:30:26 <roconnor> newArray [0 .. n-1]
05:30:59 <roconnor> and there are #'s everywhere
05:31:19 <roconnor> what is ==# ?
05:31:35 <Saulzar> I guess it is comparison of unboxed double
05:31:40 <musasabi> @where+ shootout http://shootout.alioth.debian.org/
05:31:40 <lambdabot> Done.
05:32:08 <jethr0> gcc absolute kicks haskell's *ss for the knucleotide benchmark
05:32:32 <jethr0> yah, quite a few of the benchmarks look rather non-lazy, non-functional
05:32:33 <roconnor> what's an unboxed double?
05:32:58 <shapr> unboxing means no thunk, no type wrapper.
05:33:14 <roconnor> why doesn't ghc produced unboxed code by itself?
05:33:26 <shapr> For example, an unboxed array in memory would be a pointer to a chunk of memory that holds numbers one right after the other, no thunks, no wrappers, no nothing.
05:33:43 <Saulzar> It does for some things, if you use strict types and certain compiler flags
05:33:45 <shapr> Because you can't thunk something that's unboxed, nor garbage collect anything less than the entire chunk.
05:34:08 <shapr> Yeah, what Saulzar said.
05:34:12 <roconnor> hmmm
05:34:22 <Itkovian> shouldn't let bools = True:bools in foldr (&&) False bools shortcircuit?
05:35:00 <ProfTeggy> Itkovian, it's a foldr _right_
05:35:05 <jethr0> first application gives false, no?
05:35:17 <ProfTeggy> Depends on the last elements of of bools, not the head
05:35:56 <roconnor> > let bools = True:bools in and (False:bools)
05:35:57 <lambdabot> False
05:36:00 * jethr0 's confused. what a weird thing to try
05:36:03 <shapr> roconnor: what's the hmm for?
05:36:17 <roconnor> I was thinking about unboxed stuff.
05:36:41 <jethr0> foldr'ing on sth that doesn't yet exist is weird
05:36:57 <jethr0> btw, does sth know what this means?:
05:37:00 <jethr0> @type map . filter
05:37:01 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
05:37:18 <jethr0> @type map filter
05:37:19 <lambdabot> forall a. [a -> Bool] -> [[a] -> [a]]
05:37:29 <LordL> @hoogle [a] -> [a] -> Bool
05:37:30 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
05:37:30 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
05:37:30 <lambdabot> Graphics.UI.ObjectIO.CommonDef.disjointLists :: Eq x => [x] -> [x] ->
05:37:30 <lambdabot> Bool
05:37:43 <Igloo> Is "sth" meant to mean "something"?
05:37:51 <jethr0> yes, sry
05:38:07 <jethr0> someone*
05:38:24 <jethr0> i'm really confused by what "map . filter" supposedly does
05:38:36 <norpan> first it filters, then it maps
05:38:49 <jethr0> norpan: no, i mean just like that without additional arguments
05:38:53 <jethr0> @type map . filter
05:38:54 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
05:38:54 <Igloo> map . filter = \x -> map (filter x) = \x ys -> map (filter x) ys
05:39:10 <jethr0> @type \x ys -> map (filter x) ys
05:39:11 <lambdabot> forall a.
05:39:11 <lambdabot>           (a -> Bool) -> [[a]] -> [[a]]
05:39:18 <jethr0> hmm
05:39:32 <jethr0> Igloo: thx
05:39:42 <norpan> jethr0: yes, it creates a function that first filters and then maps
05:39:51 <jethr0> :)
05:40:17 <jethr0> norpan: no it doesn't. as igloo pointed out it creates a function that maps filter over a list of lists
05:40:38 <norpan> well
05:40:50 <norpan> it does what it does
05:40:54 <jethr0> hehe
05:41:07 <norpan> it filters and then maps
05:41:23 <norpan> WHAT it filters and maps is another issue :)
05:41:28 <jethr0> > (map . filter) even [[1..5],[3,5..]]
05:41:32 <lambdabot> Terminated
05:41:37 <jethr0> > (map . filter) even [[1..5],[3,5..15]]
05:41:38 <lambdabot> [[2,4],[]]
05:42:32 <jethr0> > ((+) . (+)) 3 4 5
05:42:33 <lambdabot>  add an instance declaration for (Num (a -> a))
05:42:42 <jethr0> @type ((+) . (+))
05:42:43 <lambdabot> forall a.
05:42:43 <lambdabot>      (Num (a -> a), Num a) =>
05:42:43 <lambdabot>      a -> (a -> a) -> a -> a
05:42:45 <Itkovian> jethr0: what doesn't exist?
05:43:24 <jethr0> Itkovian: when did i say anything about existing?
05:43:46 <Itkovian> "jethr0: foldr'ing on sth that doesn't yet exist is weird"
05:44:34 <jethr0> Itkovian: well you've got a lazy infinite(?) list and work on its end, while at the same time defining the end
05:45:11 <Itkovian> good point :-)
05:46:03 <jethr0> > let bools = True:bools in foldr (&&) False bools in bools
05:46:03 <lambdabot>  parse error on input `in'
05:46:13 <jethr0> > let bools = True:bools in foldr (&&) False bools in bools
05:46:14 <lambdabot>  parse error on input `in'
05:46:23 <jethr0> Itkovian: ah sorry, i totally misread your code
05:46:41 <jethr0> i though the foldr was part of the bools definition
05:46:50 * jethr0 slaps himself with a fresh herring
05:47:21 <jethr0> still, foldr'ing on infinite lists can take a while
05:48:04 <Itkovian> I just thought it would shortcircuit on the (&& False)
05:48:06 <jethr0> but then again i've been talking nonsense for the last half hour :((
05:48:12 <Itkovian> happens to me too
05:49:13 <jethr0> i'm not sure, but foldr really replaces the (:) with your action. so i guess it first does the substitution and then the evaluation, but i really have no idea
05:53:25 <edwinb> hi swiert. thank you for the loan of your desk ;)
05:57:31 <jethr0> i think we should keep the short, sweet, fast shootout entries somewhere to show that some of the awkward code is due only due to the "strict"/biased shootout rules.
05:58:06 <Saulzar> They can be added as "alternative solutions"
05:59:00 <jethr0> i know. but i mean visibly so that people can see that haskell _has_ an aesthetic quality (which isn't necessarily communicated with the "optimized" entries).
05:59:34 <jethr0> we've had so many short _and_ fast entries developed that were then scrapped because of minor semantic points
05:59:43 <Saulzar> Hmm
06:02:36 <shapr> jethr0: http://www.scannedinavian.com/~shae/blog/2005-05-20.html
06:02:51 <jethr0> making the whole a little presentable, the whole shootout process could even server as a huge optimization tutorial
06:03:29 <jethr0> shapr: i'd already read that :)
06:03:33 <shapr> oh, ok =)
06:04:14 * Saulzar ticks off another "TODO", running out of easy things
06:04:34 <jethr0> and also, i've come to realize how much this kind of community effort could help compiler/library directions. many things came up that showed certain libraries had major performance deficiencies (Map and RegExp, just to name two)
06:05:06 <dcoutts> shapr, edwinb, clearly I ought to have brought my unicycle when I came to Nottingham last week :-)
06:05:20 <shapr> dcoutts: truly
06:05:30 <shapr> jethr0: Yeah, good point
06:07:01 <jethr0> this should become an institution for haskell with a few people always probing the performance boundaries of small, yet somewhat realistic examples
06:07:35 <jethr0> and competing for the fastest, shortest, most readable/idiomatic version
06:09:36 <dcoutts> heh, heh, did people see this: http://www.soi.city.ac.uk/~ross/haskell-prime-stats/
06:09:46 * earthy did
06:09:49 <earthy> 'interesting'
06:09:59 <dcoutts> or "who are the haskell chatter-boxes"
06:10:09 * dcoutts is 20th!
06:10:27 * dcoutts is not sure if that's a good or bad thing :-)
06:12:05 * jethr0 has written 12721 lines in #haskell since december *brr*
06:12:49 <Saulzar> Have you written more Haskell than #Haskell? :)
06:13:04 <jethr0> i correct. 7605 lines, the rest were references
06:13:09 <jethr0> but still
06:13:33 <jethr0> Saulzar: no way! 8000 lines of haskell would be the equivalent of all extant software ^_^
06:13:47 <xerox_> Oi!!
06:14:21 <sieni> it's "no wai"!
06:14:38 <LordL> @hoogle a -> [a] -> [a]
06:14:38 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
06:14:38 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
06:14:38 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
06:14:39 <Saulzar> Haha, I'm getting close to that with my current project in verbose haskell :)
06:15:02 <jethr0> Saulzar: what's your current project?
06:15:25 <Saulzar> Robot AI game thingey
06:16:08 <tromp_> what do your 7605 lines do?
06:16:19 <jethr0> considering that Pugs only has 16000 "real" lines of code
06:16:46 <Saulzar> GUI code shoves up the line count a reasonable amount
06:16:57 <Saulzar> and that's including spaces
06:16:57 <jethr0> tromp_: smalltalk in this channel
06:17:29 <jethr0> Yi has 11000 lines
06:28:14 <shapr> jethr0: How did you find out your number of lines? grep the logs?
06:29:41 <Saulzar> http://saulzar.orcon.net.nz/robots2.jpg, though the graphics are not done doesn't really show much of what is going on :)
06:29:59 <jethr0> shapr: i downloaded some of the logs to look for good examples for my BlowYourMind page. but found only few good ones :(
06:30:04 <jethr0> shapr: but yes, i did
06:32:38 * beelsebo1_ prods Philippa with a pogo stick
06:37:59 <jethr0> shapr: i don't mean to be a pest, but is there a roadmap for the "current" monad reader?
06:44:56 <dcoutts> Saulzar, so is this using Gtk2Hs ?
06:45:44 <Saulzar> dcoutts, Yeah
06:45:58 <dcoutts> Saulzar, cool, so how are you doing the drawing?
06:47:03 <Saulzar> It's a GL window (Haven't touched the code/poked at cairo since we last talked)
06:47:15 <dcoutts> oh right, GL, cool
06:47:41 <Saulzar> Those red blobs are textures, the graphics need some work :)
06:48:06 <dcoutts> :-)
06:48:12 <beelsebo1_> @where quickcheck
06:48:13 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
06:49:21 <dcoutts> Saulzar, well we'd like screenshots for the gtk2hs website if/when you feel it's looking good :-)
06:49:51 <dcoutts> who was it here who was making a GUI for the 2005 ICFP contest?
06:50:08 <dcoutts> that was a nice GUI, I wanted screenshots of that for the Gtk2Hs web page too!
06:50:20 <Saulzar> vincenz/jethr0, I think?
06:51:12 <Saulzar> I'm just making it work right now, then make it pretty - and it is 80% done :)
06:53:38 <Saulzar> Getting some bizzare crashes occasionally, sometimes happens sometimes not - and always with C optimisations turned on
06:56:24 <jethr0> Saulzar: vincenz and i wrote a nice look-alike of the last icfp server
06:56:31 <dcoutts> jethr0, ah!
06:56:33 <dcoutts> Saulzar, how old is your Gtk2Hs darcs version? We did have a particularly nasty bug that could cause some segfaults.
06:56:35 <jethr0> well, actually vincenz did all the gui work
06:56:48 <dcoutts> jelmer, can we have screensots :-)
06:56:57 <jethr0> sure
06:57:11 <dcoutts> jelmer, soory I meant jethr0 
06:57:18 <dcoutts> jethr0, cool
06:57:19 <jethr0> haha
06:57:42 * dcoutts has a love-hate relationship with x-chat tab-completion
06:57:59 <Saulzar> dcoutts, A couple of months old I think, updated recently but didn't compile it - will do so.
06:58:19 <Saulzar> dcoutts, Heh, yeah - it always picks the least likely candidate :)
06:58:27 <dcoutts> Saulzar, well hold on a sec, we're in the middle of some api changes
06:58:36 <swiert> dcoutts: I've made a noughts-and-crosses game for our AFP course. I'd be happy to send you a screenshot and some source.
06:58:49 <dcoutts> swiert, that't be great!
06:58:54 <Saulzar> Even if you type more than 1 letter it defaults to using just the first letter in completion.
06:58:59 <jethr0> dcoutts: how should i send them?
06:59:12 <dcoutts> jethr0, email or post the .pngs somewhere
06:59:23 <swiert> dcoutts: I was wondering if there's some way to force a repaint using GTK.
06:59:25 <jethr0> k. having problem building right now, but i'll stay on it
06:59:53 <dcoutts> swiert, you can ask a whole widget to get repainted by invalidating the whole widget's surface area
07:00:13 <dcoutts> swiert, let met find the func, it's soemthing like widgetRepaint
07:00:28 <Saulzar> dcoutts, Ah - well it's not urgent, but it does some strange things. I can shift some code doing IO up/down in the code and it will segfault when I click a button for example...
07:01:07 <dcoutts> swiert, widgetQueueDraw
07:01:39 <swiert> dcoutts: OK. Specifically, I've encountered the following problem. When the human player makes a move, I queueDraw that widget. Then the AI starts thinking about it's move, but the widget isn't redrawn.
07:02:04 <dcoutts> swiert, ah that's because your AI player is blocking the GUI
07:02:07 <swiert> dcoutts: Then the AI decides on it's move, and the two moves are made 'at the same time'.
07:02:31 * liyang invites swiert to #epigram :)
07:02:53 <swiert> dcoutts: Should I be forking another thread for the AI?
07:02:58 <liyang> There's a way to synchronously flush the queue, right?
07:03:04 <dcoutts> swiert, you can do some hack to try and wait 'til the GUI is finnished but the basic problem is that the AI is blocking the GUI
07:03:25 <dcoutts> yes you can use a thread or some restartable computation
07:03:57 <dcoutts> the hacky solution is to run the main loop until it is idle
07:04:25 <dcoutts> swiert, for a simulator I did the computation bit was easily split up into small slices so I didn't need a thread
07:04:48 <dcoutts> swiert, I ran the sim one step each time in an idle handler
07:04:56 <dcoutts> that way it interleaves perfectly with the GUI
07:05:09 <liyang> (Something like drawWindowProcessUpdates?)
07:05:11 <dcoutts> but if your computation is monolithic then a thread would help
07:05:14 <swiert> dcoutts: Here the first move has a fairly huge search space. The problem goes away after that.
07:05:50 <swiert> dcoutts: What do you mean by 'an idle handler'?
07:05:52 <Saulzar> Threads are more elegant, especially if your search algo is pure
07:05:55 <dcoutts> swiert, the other advanced thing people do is put their computation in a writer monad that returns a list of progress
07:06:34 <dcoutts> then you can very naturally run the compuation for a "bit" ie long enough for it to return one progress item in a list of progress + final result
07:06:50 <dcoutts> I think the Dazzle paper explains that technique
07:07:16 <dcoutts> but it's bascially to use a writer monad to write out (Either Progress Result) items
07:07:23 <Saulzar> That's a pretty cool idea :)
07:07:47 <dcoutts> swiert, an idle handler is a callback that you can set up that will be called when the GUI is otherwise idle.
07:07:57 <dcoutts> swiert, similar to a timeout
07:08:59 <dcoutts> doing work in idle handlers allows you to do things as fast as possible without blocking the GUI (so long as the computation is restartable and you don't do too much of it each time)
07:09:22 <dcoutts> liyang, drawWindowProcessUpdates probably will not help
07:09:22 <swiert> aha: idleAdd/idleRemove.
07:09:26 <dcoutts> yep
07:09:47 <swiert> dcoutts: Thanks! I didn't know about that.
07:10:03 <dcoutts> it covers quite a few cases where you'd otherwise need threads
07:10:14 <shapr> jethr0: Well, I think it's just do some editing, publish an issue.. I've been busy trying to find work and haven't even thought about it.
07:10:31 <dcoutts> I should publish the code for my ICFP '04 GUI. It uses that technique.
07:10:33 <swiert> seems like a sensible thing to try.
07:10:56 <jethr0> nm, finding work is definitely more important than the reader!
07:11:38 <liyang> dcoutts: I'm sure Win32 and AWT had something that did do what swiert wanted. :-/
07:12:14 <dcoutts> liyang, it can be done by running the event loop 'til it's idle, but it's still a hack
07:12:22 <beelsebo1_> anyone any good with quickcheck?
07:12:33 <roconnor> I'm okay with quickcheck
07:12:51 <liyang> I'm wondering what drawWindowProcessUpdates does do now.
07:13:03 <beelsebo1_> can you think of any way to only let it generate strings with alphabetic characters in it for a certain part of a data structure?
07:13:31 <dcoutts> liyang, boegel's HRay uses that hack, it maes sure that gUI has finnished repainting and then goes off and does some raytracing. But you still have the problem that the GUI is blocked while the rendering is going on.
07:13:42 <dcoutts> so it doesn't really solve things properly
07:13:45 <roconnor> bit complex, you will have to build your own generator.
07:13:51 <roconnor> as you figure.
07:14:06 <liyang> When it says delivers the expose events synchronously, it means it will put them into the event queue immediately, or it will call the expose handler immediately?
07:14:22 * dcoutts checks
07:14:22 <beelsebo1_> roconnor: but then you need to have a newtype - and a list of tagged characters is not what I want
07:14:33 <beelsebo1_> none of the standard string functions work then
07:14:49 <liyang> (insert `does' as appropriate for that sentence to parse.)
07:15:00 <roconnor> The way I would approach it is to newtype Letter = Letter Char
07:15:15 <roconnor> make an arbitrary letter using the primitives of quickcheck
07:15:23 <roconnor> that shouldn't be too hard to do.
07:15:25 <Beelsebob|Office> roconnor: indeed - but then you get [Letter] not [Char] and none of the standard string functions work any more
07:15:44 <dcoutts> liyang, no I think it means it will call them immediately, but you generally don't want to do that
07:15:48 <roconnor> but you can build a toString function
07:16:05 <Beelsebob|Office> roconnor: true - but I don't really want to polute my entire code with it
07:16:12 <roconnor> and then liftM toString to build your arbitrary data structure.
07:16:26 <roconnor> You don't do that.
07:16:38 <roconnor> You will only use Letter to facilicate making arbitrary stuff.
07:16:40 <Beelsebob|Office> oh... I see... I think
07:17:16 <roconnor> so, liftM toString :: Gen [Letter] -> Gen String
07:17:25 <roconnor> so, liftM toString arbitrary :: Gen String
07:17:38 <Beelsebob|Office> cool :)
07:18:06 <roconnor> In fact, if you make Letter an instance of Enum, then Aribtrary [Letter] may come for free.
07:18:12 <roconnor> then you don't have to do anything.
07:18:27 <roconnor> Assuming Enum a => Arbitrary a
07:18:33 <liyang> dcoutts: in this ( instance though, shouldn't it do something?
07:18:48 <liyang> s/(/(swiert's)/
07:19:33 * boegel yays on hearing his name (and app)
07:19:40 <boegel> hey dcoutts! ;)
07:19:51 <dcoutts> hia boegel 
07:20:43 <dcoutts> liyang, yes, you can cure the immediate problem but you still end up with a problem of an unresponsive GUI. That's the real thing that should be solved.
07:21:37 <jethr0> dcoutts: http://jethr0.dyndns.org/repos/icfp/pics/
07:21:57 <jethr0> dcoutts: not the fastest uplink though :(
07:22:13 <dcoutts> jethr0, cool pics!
07:22:34 <roconnor> @hoogle arbitrary
07:22:34 <lambdabot> Test.QuickCheck.Arbitrary :: Arbitrary a
07:22:34 <lambdabot> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
07:22:34 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
07:22:37 <dcoutts> jethr0, can we do a little blurb about it? do you want to write an explanation?
07:22:48 <jethr0> sure, where should i mail the whole bunch?
07:23:07 <dcoutts> jethr0, similar to what we've got for: http://haskell.org/gtk2hs/archives/category/screenshots/
07:23:24 <boegel> jethr0: cool GUI :)
07:23:54 <dcoutts> jethr0, is this all drawn with cairo?
07:24:22 <jethr0> dcoutts: yup. to be fair vincenz did all the gui work. it worked like a charm right out of the (for all i know :)
07:24:44 <jethr0> code is one directory up in Visualization.hs
07:24:44 <dcoutts> maybe we should ask vincenz :-)
07:24:47 <liyang> dcoutts: True. But it didn't seem to do anything, was my point. Ah well...
07:24:49 <jethr0> i will
07:25:53 <dcoutts> liyang, the hack boegel used to get it to repaint before blocking in the long running computation is different
07:26:29 <liyang> *nod*
07:27:21 <liyang> Think I'm used to e.g. Win32 or AWT which had something you can call to force the redrawing immediately.
07:29:42 <dcoutts> liyang, remember we're using this 2-phase invalidate & repaint system, so it's a little different
07:30:20 <liyang> I thought that's how other windowing systems worked too...
07:30:26 <liyang> I'm a little rusty though. :-/
07:32:49 <dcoutts> jethr0, ok, I've uploaded the pics, now for a little explanative blurb
07:34:13 <jethr0_> dcoutts: i just wrote a mail to vincenz asking if this was okay with him and if he had an idea for a blurb. i'll get back to you when he responds
07:34:22 <jethr0_> most likely he'll be in the channel later today
07:34:25 <jethr0_> @seen vincenz
07:34:25 <lambdabot> vincenz is in #haskell. I don't know when vincenz last spoke.
07:34:26 <dcoutts> jethr0, ok
07:34:29 <dcoutts> http://www.haskell.org/gtk2hs/gallery/icfp05
07:35:03 <dcoutts> that's where the pics are for the moment, then we'll link to them like we do with the other ones in http://haskell.org/gtk2hs/archives/category/screenshots/
07:35:12 <dcoutts> via little thumbnails
07:35:32 <dcoutts> I'll do that bit, you just send me what you want to say
07:35:40 <jethr0_> k, will do
07:35:44 <dcoutts> :-)
07:36:36 <jethr0_> gtk2hs was really a charm to use. the necessary(?) concurrency is a bit evil, but from the little i know about gui programming, doing it in haskell was no harder (if not easier) than doing it in a more common gui language
07:36:40 <jethr0_> kudos
07:37:14 <dcoutts> thanks, yes the concurrency could be better integrated
07:37:27 <dcoutts> we need more ghc rts support for that I think
07:38:38 <jethr0_> someone on the channel was working on a more fruit/fran-like frontend for gtk2hs, but i forgot who i was
07:39:09 * dcoutts is not much good at remembering names either
07:39:24 <dcoutts> I thought it was jips
07:39:28 <dcoutts> @seen jips
07:39:29 <lambdabot> I haven't seen jips.
07:39:35 <dcoutts> hmm wrong spelling
07:40:11 <roconnor> I want to a haskell library that uses Ciaro and replaces gnuplot.
07:40:37 * roconnor doesn't like gnuplot
07:40:40 <tromp_> you mean Cairo?
07:40:40 <jethr0_> roconnor: nice, way to go
07:40:56 <roconnor> yes
07:41:01 <roconnor> let me try again
07:41:09 <roconnor> I want a haskell library that uses Cairo and replaces gnuplot.
07:41:12 * roconnor doesn't like gnuplot
07:41:25 <dcoutts> you'd have to do all your own plotting
07:41:37 <roconnor> yes
07:41:41 <dcoutts> it'd be quite a bit of work I think
07:41:43 <tromp_> it would be greatif one can plot haskell functions Num a => a -> a
07:41:56 <dcoutts> though it could start simple
07:41:57 <roconnor> probably a fair amount of work.
07:42:17 <dcoutts> and yes, cairo would be a good lib to base it upon
07:42:18 <roconnor> tromp_: How about RealFrac => a -> a
07:42:37 <dcoutts> especially when xerox and I get on with the pure cairo layer! :-)
07:42:52 <tromp_> yes, good enough. or RealFrac a, RealFrac b => a -> b
07:42:54 <jethr0_> it might not be too hard. but things like determining sensible display boundaries, etc might be hard. the small stuff might be more taxing then the heavy :)
07:43:19 <jethr0_> than*
07:44:28 <roconnor> I hope you can make a quickplot, like quickcheck.
07:45:35 <jethr0_> wherever possible, it would be nice to stick to gnuplot syntax, unless that's what bothers you most
07:46:35 <roconnor> I was thinking about avoiding the whole gnuplot langauge
07:46:49 <tromp_> there'd be no point if you preserve gnuplot syntax
07:46:52 <roconnor> instead of a speical langauge, you'd just make haskell programs
07:47:13 <jethr0_> basically you want "(RealFrac a) => (a->a) -> (a,a) -> a -> [a]" given a function, a region, a sampling distance, give me the sampling points, no?
07:47:22 <tromp_> the whole beauty of it wld be that you can plot arbitrary haskell functions of the right type
07:47:45 <roconnor> jethr0_: yes, but I think it gets even more complex than that, colour, line type, line thinkness.
07:48:21 <roconnor> jethr0_: overlaying plots that have different units
07:48:23 <tromp_> of course one way is to have haskell produce a data file for gnuplot to plot
07:48:29 <roconnor> making tick marks
07:48:36 <roconnor> labeling axis.
07:48:41 <jethr0_> roconnor: hmm, i think that entirely orthogonal. with sampled points you can do whatever you like. interpolation, line type, ...
07:48:51 <roconnor> sure
07:49:05 <jethr0_> i didn't say it would be trivial, but doing simple graphs should be doable
07:49:06 <roconnor> there is probably right data types at different stages.
07:49:24 <roconnor> I think 2-D line graphs would be a useful start.
07:51:03 <jethr0_> i don't even want to think about interactive 3d graphs ^_^
07:53:10 <musasabi> A think for plotting sensibly a [(Double,Double)] with a sensible curve (and ~50000 points) would be nice.
07:53:50 <musasabi> [(0,1.0),(0,0.8),(0,1.2),(1,2), (1,2), ...] etc
07:53:58 <roconnor> I think haskell ought to use the deriviate of the funtion to optimaly non-uniformly sample the curve.
07:54:51 <jethr0_> k, i was just thinking of screen resolutions with < 2000 pixels width. but for finer output, better sampling would obviously be preferable
07:55:09 <jethr0_> also, lazyness helps in not evaluating points outside the display region
08:04:50 * jethr0_ breaks into tears at how bad the world has become (http://article.gmane.org/gmane.comp.lang.lightweight/3240)
08:05:18 <jethr0_> you know the apocalypse is near when the scheme people want to get rid of map, filter and fold
08:07:01 <liyang> lol
08:07:20 <liyang> note the date. :)
08:07:38 <jethr0_> liyang: i know. still recently enough *uhuhu*
08:08:06 <tromp_> before you know it they'll want to get rid of lambda:)
08:08:18 <jethr0_> tromp_: it says so in the post
08:08:46 <jethr0_> "We think dropping FILTER and MAP is pretty uncontroversial; (filter P
08:08:56 <jethr0_> S) is almost always written clearer as a DO loop." - The PLT Scheme Team
08:09:39 <mauke> haha, awesome
08:09:41 <jethr0_> those are _exactly_ the same arguments guido always brings for removing lisp ancestry from python. now i know where he's getting his talking points :(
08:09:49 <liyang> I hear the FISH in APRIL are tasty!
08:10:13 <mauke> jethr0_: uh, are you for real?
08:10:49 <tromp_> well, that's clearly a joke:)
08:11:03 <jethr0_> liyang: now i know what you mean.
08:11:06 <mauke> it's a python parody
08:11:07 <jethr0_> stupid april fools
08:11:20 <mauke> "...  and Scheme is designed from
08:11:20 <mauke> the ground up to, as much as possible, keep programmers from thinking
08:11:20 <mauke> at all.
08:11:25 <jethr0_> i'd already seen this one and forgotten about it again *argh*. it nearly gave me a heart attack ^_^
08:12:02 <jethr0_> mauke: it's not as if guido doesn't write this way. the python anti-filter rants gave me enough pain already :)
08:12:04 <tromp_> it hsld be quite clear from the line:
08:12:06 <tromp_> Scheme is designed from the ground up to, as much as possible, keep programmers from thinking at all
08:12:09 <jethr0_> *puh*, am i relieved
08:12:57 <jethr0_> don't attribute to malice what can be explained by stupidity. i was just applying Hanlon's Razor
08:13:10 * liyang giggles with irrational exuberance.
08:14:10 * jethr0_ feels ultimately fooled
08:14:40 <jethr0_> "irrational exuberance" - i like that. it has a literary, post-modernist feel to it *g*
08:15:23 <liyang> oh, that came from Alan Greespan.
08:15:26 <jethr0_> "I think it's rather a sad thing that Guido's announcement works so well as an April Fool's prank."
08:16:01 <jethr0_> liyang: ah, i remember now. there was even an alan greenspan special on The Daily Show with that slogan
08:18:18 <liyang> and a Flash animation of the same name to the tune of Yatta! by Happa-tai.
08:44:50 <shapr> jethr0_: Heard about the recent request for tail-call optimization for Python?
08:45:46 <jethr0_> i faintly remember sth. i thought they agreed not to do it...
08:46:37 <heatsink> shapr: You mean stackless? ;)
08:48:23 <jethr0_> stackless python is a nice idea. but it's really a pity it's not becoming the mainstream python implementation.
08:48:37 <jethr0_> although AFAIR they had problems with FFI calls to c
08:48:39 <shapr> heatsink: yeah, somewhat - http://www.artima.com/weblogs/viewpost.jsp?thread=147358 "Features of a programming language, whether syntactic or semantic, are all part of the language's user interface. And a user interface can handle only so much complexity or it becomes unusable. This is also the reason why Python will never have continuations, and even why I'm uninterested in optimizing tail recursion."
08:48:50 <shapr> Yeah, stackless ate the C stack
08:49:02 <shapr> It's still better than the standard Python implementation, imho
08:49:11 <shapr> It had first class continuations. The real deal =)
08:50:48 <jethr0_> i know. and those sexy micro threads of which you could run tens of thousands
08:50:57 <jethr0_> using continuations/coroutines
08:51:22 <jethr0_> and serializable everything
08:52:29 <musasabi> like GHC threads
08:52:38 <musasabi> except Haskell is lacking in serialization
08:52:50 <jethr0_> bbl
08:54:46 <heatsink> shapr: I think it makes sense.  Python would have to change significantly to make it more functional.
08:57:22 <roconnor> OMG, is continuations the way to do co-routines?
08:57:58 <newsham_> yup
08:58:00 <heatsink> roconnor: That's the way they're done in scheme at least
08:58:10 <roconnor> that's briliant!
08:58:16 <newsham_> python generators are mini coroutines, but there are lots of restrictions
08:58:25 * heatsink thinks it has finally figured out how to fork a python process from haskell code
08:58:45 <roconnor> I want to see an implementation of bounded producer / consumer written with continuations.
08:59:07 <roconnor> why didn't they teach me this in university?
09:00:18 <davidhouse> heatsink: easy. rewrite the python stuff in haskell. :)
09:00:52 <heatsink> davidhouse: how do you rewrite "import email" in haskell? :p
09:00:57 <roconnor> write a python interpreter in Haskell?
09:01:27 <roconnor> compile it with yhc
09:01:40 <roconnor> run it under the python bytecode interpreter.
09:02:46 <heatsink> That sounds like a fun project for someone who has a few weeks of free time.
09:03:04 <davidhouse> roconnor: the wheel looks like a nice thing to reinvent, doesn't it?
09:03:06 <davidhouse> :)
09:05:06 <roconnor> @google bounded consumer producer continuations
09:05:08 <lambdabot> http://www.cs.caltech.edu/courses/cs24/hw/hw6/hw6.pdf
09:06:38 <roconnor> ``this lab is a continuation of assignmetn #5''
09:06:40 <roconnor> :(
09:12:27 <dcoutts> vincenz, ping
09:13:44 * Igloo ties his hands to the table leg to avoid replying to cvs-ghc suggesting rewriting GHC in a pure functional language
09:13:57 <dcoutts> !?!
09:14:32 <Igloo> http://www.haskell.org//pipermail/cvs-ghc/2006-March/028702.html
09:15:06 <newsham_> roconnor: make two generators for producer/consumer and a function which uses them ?
09:15:47 <dcoutts> Igloo, I see :-)
09:16:56 <roconnor> Igloo: I thought ghc was using darcs.
09:22:08 <ibid> roconnor: it is, partially. still, there's no need to rename the list :)
09:29:56 <palomer> hrmph
09:30:06 * palomer ponders the question: when does one type contain more information than another?
09:31:51 <roconnor> palomer: Where there are more possible values of the type
09:32:36 <roconnor> a : Maybe () has more information than b : ()
09:32:45 <roconnor> b : () actually has no information.
09:33:00 <SyntaxNinja> w00t
09:33:01 <roconnor> a : Maybe () has at most 1 bit of information.
09:33:12 <roconnor> @djinn Maybe ()
09:33:12 <lambdabot> f = Nothing
09:33:13 <edwinb> if f :: A -> B is total, and g :: B -> A isn't, then B has more information than A?
09:33:16 * edwinb guesses
09:34:37 <sjanssen> is there an interval arithmetic package for Haskell?
09:34:47 <roconnor> for any non-empty A and B I can make f :: A -> B and g :: B -> A st f is total and g diverges everywhere.
09:35:14 <roconnor> @oldwiki ExactRealArithmetic
09:35:14 <lambdabot> http://www.haskell.org/hawiki/ExactRealArithmetic
09:40:13 <sjanssen> roconnor: some of the caveats of these packages are a little scary.  some computations don't terminate?
09:41:29 <roconnor> That is especially true for BigFloat, but I suppose the problem holds for all of them when dividing by 0.
09:42:03 <roconnor> sjanssen: If you find an interval arithmetic package, let me know, or put it on that wiki page.
09:43:27 <sjanssen> roconnor: I'm thinking of doing a FFI wrapper around a C IA library
09:43:42 <sjanssen> though, mabye I won't . . . only time can tell
09:44:24 <roconnor> what is your application?
09:45:20 <sjanssen> roconnor: none yet
09:45:26 <roconnor> heh
09:45:43 * roconnor isn't too fond of IA, but other people seem to like it.
09:53:12 <Lemmih> Hi AL.
09:53:19 <AL> Hi!!
09:53:32 <GeniXPro> Hello!!!!
09:54:13 <AL> Is there people who compiled Yi in linux-amd64? (sorry for my bad english)
09:55:22 <Lemmih> gour might have. (btw, hIDE is currently having problems with amd64)
09:56:08 <__AL__> I tried a lot of different yi versions but all crashs with Segmentation Fault
09:57:11 <__AL__> I'm newbie in Haskell so don't know how to debug it...
09:57:42 <__AL__> hIDE crashes too...
09:57:48 <Lemmih> The dynamic loader is probably borked on amd64.
09:58:40 <Lemmih> __AL__: Does GHCi work?
09:59:00 <__AL__> Yes
09:59:36 <__AL__> Version - 6.4.1
10:00:42 <Lemmih> We're planning to use ghc-api instead of hs-plugins. However, all of the hIDE developers are busy right now.
10:03:09 <__AL__> Is there sense to try GHC from Darcs?
10:03:16 <cmarcelo> hello. where can i find a friendly/introductory text about GADTs?
10:04:05 <Lemmih> __AL__: Well, hIDE only works with GHC from darcs.
10:04:37 <__AL__> Ok, i'll try to build it now
10:06:42 <palomer> cmarcelo: very good question
10:06:47 <JKnecht> http://haskell.org/docs/latest/users_guide/gadt.html
10:06:49 <palomer> cmarcelo: if you find any, let me know
10:06:55 <palomer> cmarcelo: and if you have any questions, you can ask here
10:07:45 <JKnecht> er, http://haskell.org/ghc/docs/latest/users_guide/gadt.html
10:08:38 <kowey> almost...
10:08:39 <kowey> maïeutique
10:08:40 <Lemmih> __AL__: Let me know if it works.
10:08:42 <kowey> oops
10:08:44 * Lemmih takes off shopping.
10:08:47 <kowey> http://haskell.org/ghc/docs/latest/html/users_guide/gadt.html
10:09:19 * palomer somewhat dislikes the ghc GADT syntax
10:09:30 <palomer> it's quite confusing
10:12:27 <__AL__> Lemmih, Ok
10:13:47 <palomer> ooh, hIDE is pretty
10:19:11 <brol> :quit
10:29:26 <shapr> palomer: I think the GADT syntax is better than the default syntax, it makes the type of constructors obvious.
10:29:36 <shapr> In my opinion, that's more regular.
10:30:20 <shapr> jethr0_: Hey, was it you who wanted to see pix of John Hughes riding my unicycle at EuroHaskell 2004?
10:33:18 <palomer> shapr: the regular syntax being the standard datatype syntax?
10:33:24 <palomer> that one is unsuitable for GADTs
10:33:38 <cmarcelo> so, with the GADT extension we can make constructors for our data that may result in specific types? Example: data Term a where Lit :: Int -> Term Int ; IsZero Term Int -> Term Bool ... is that it?
10:33:58 <cmarcelo> ops.. IsZero :: Term Int -> Term Bool
10:34:09 <palomer> cmarcelo: more than just specific types, they may be type constructors applied to any types appearing on the left hand side
10:34:13 <palomer> cmarcelo: look at Pair
10:37:13 <jethr0_> shapr: no, but i'd still like to see them :)
10:45:32 <cmarcelo> palomer, i see.. but i'm having difficulty to see the benefical implications of this.. =|
10:45:39 <cmarcelo> of having GADTs..
10:46:27 <kowey> very basic question here: are 'where', 'of', 'let' and 'do' the only keywords with layout rules associated to them?
10:47:36 <Igloo> That sounds right; the report has the definitive answer
10:48:18 <kowey> hmm... i've gotten by for two years without learning layout rules... it's high time i sat down and learned them
10:49:35 <shapr> cmarcelo: http://www.scannedinavian.com/~shae/haskell/
10:49:42 <astrolabe> I've been assuming 'where' and 'do' have the layout rule :o
10:50:14 <SyntaxNinja> shapr!
10:50:17 <shapr> SyntaxNinja!
10:50:48 <astrolabe> Ah, I misunderstood you.
10:51:28 <tuomov> how about 'in'?
10:51:29 <astrolabe>  In the report it says those 4 and doesn't mention others (at that point).
10:52:49 <tuomov> or does 'layout rules' only mean things that can have multiple unrelated lines of stuff?
10:53:00 <tuomov> then it would be those 4, I guess
10:53:25 <davidhouse> @pl \(c,_,_) -> c
10:53:25 <lambdabot> (line 1, column 6):
10:53:25 <lambdabot> unexpected ","
10:53:25 <lambdabot> expecting operator or ")"
10:53:25 <lambdabot> ambiguous use of a non associative operator
10:53:35 <cmarcelo> shapr, i'll take a look. i have to go to class now.. see you guys later..
10:53:44 <davidhouse> @pl \(a,b,c) -> c
10:53:44 <lambdabot> (line 1, column 6):
10:53:44 <lambdabot> unexpected ","
10:53:44 <lambdabot> expecting letter or digit, operator or ")"
10:53:44 <lambdabot> ambiguous use of a non associative operator
10:53:48 <davidhouse> ?
10:54:22 <kowey> noting my layout findings in here, btw
10:54:23 <kowey> http://en.wikibooks.org/wiki/Programming:Haskell_indentation
10:56:55 <DukeDave> hey gang
10:58:06 <DukeDave> for a hoot (and hopefully some practise!) me and my mate managed to throw together this one liner earlier.. would be great if anyone can clean it up, tips welcome!
10:58:25 <DukeDave> (it outputs primes btw)
10:58:26 <DukeDave>  map fst (filter (\x -> head (snd x) < 3) ([(num,(map (\x -> x) (map length (map (\x -> (filter (==0) x)) (map (\x -> map (\y -> (last x) `mod` y) x) [[1..y] | y <- [num]]))))) | num <- (filter odd [0..])]))
10:59:13 <DukeDave> (edit: it outputs all primes except 2 ;)  )
10:59:17 <jethr0_> DukeDave: that's too long to have a casual glance at. what does it do?
10:59:38 <DukeDave> it lists all the prime numbers f
10:59:43 <viblo> one small thing: (\x -> x) <- replace with id
11:00:03 <jethr0_> drop 1 primes where primes = sieve [2..] where sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ]
11:00:09 <DukeDave> oh yeah, can probably pull that whole map out actually
11:01:29 <DukeDave> lol, I hate you jethr0_  :)
11:01:39 <DukeDave> did you just write that?
11:01:58 <DukeDave> because it took us about an hour to build our one   *_*
11:02:12 <jethr0_> DukeDave: nah, copy pasted it
11:02:29 <jethr0_> good work dukedave
11:02:33 <DukeDave> few :)
11:02:40 <DukeDave> uhh, I mean phew
11:02:45 <DukeDave> lol, that was wierd 
11:03:19 <DukeDave> and, cheers!
11:05:42 <viblo> for future functions: you don't need all your (), like in num <- (filter odd [0..])
11:05:58 <viblo> and you can also skip the lambda in (\x -> (filter (==0) x)) 
11:06:22 <DukeDave> ahh yes
11:06:24 <viblo> (replace with (filter (==0))
11:06:26 <DukeDave> well spotted
11:06:32 <DukeDave> this is good :)
11:08:16 <viblo> same with (\y -> (last x) `mod` y)
11:09:35 <jethr0_> filter isPrim [2..] where isPrim x = all ((/=0) . (mod x)) [2..x-1]
11:12:18 <viblo> [x | x <- [1..], all ((/=0) . (mod x))) [2..x-1]]
11:12:27 <viblo> [x | x <- [2..], all ((/=0) . (mod x))) [2..x-1]]
11:12:46 <jethr0_> thx
11:13:34 <astrolabe> sieving's faster though
11:13:36 <jethr0_> ups, this test doesn't accept 2 as prime. oh well
11:13:39 <jethr0_> astrolabe: i'm well aware
11:14:09 <jethr0_> i was just looking how i would implement it if i were in a hurry (and could for some reason not concentrate well)
11:14:39 <astrolabe> I see.  I was just worried there might be children listening or something.
11:15:29 <jethr0_> hehe. nothing wrong with the naive approach. it's just a transliteration of the definition of a prime
11:36:04 <DukeDave> ahh nice solns there guys
11:36:16 <DukeDave> put mine to shame as expected
11:37:51 <jethr0_> don't be so hard on yourself. 
11:38:26 <jethr0_> DukeDave: what's your next project?
11:40:14 <DukeDave> not sure
11:41:11 <DukeDave> I still don't have a (personally) satisfactory soln to the source pretty printer problem;  although I now have monads just about understood :)
11:41:41 <jethr0_> i was thinking about that actually
11:42:09 * DukeDave perks up :)
11:42:53 <jethr0_> well, my thoughts didn't come to nothing much. just that splitting at "arbitrary" strings isn't exactly trivial
11:44:56 <DukeDave> I thought of quite a fun way to do it - although my haskell skills aren't really upto it (certainly not before friday when I have to submit).
11:45:01 <DukeDave> I was thinking:
11:45:13 <xerox_> Evening.
11:45:36 <DukeDave> type Block = NotKW String | IsKW String KWType
11:46:15 <mauke> s/type/data/
11:46:24 <DukeDave> then start with the whole line as 'NotKW mylineoftexttoparse'
11:47:00 <DukeDave> and have 'worker' parsing modules which break notKW blocks down into mixed blocks
11:47:03 <DukeDave> ish
11:47:05 <DukeDave> :)
11:47:15 <jethr0_> yup, that's similar to an idea i had
11:48:29 <DukeDave> in a rather cruel moment my lecturer said today "and next week once I have the assignment in I will show you how to write a pretty comprehensive parser in haskell in 40 mins"
11:50:47 <jethr0_> DukeDave: are you allowed to use libraries or just pure haskell?
11:54:10 <DukeDave> well
11:54:35 <DukeDave> I imagine there would be many more marks for your own work
11:55:17 <DukeDave> but the word on the street is -- its not that highly weighted so just get in something which meets the spec
11:56:14 <DukeDave> my current one is just a lines / pattern match '>' / words / check using elem   approach
11:56:25 <DukeDave> works on very well written code :)
11:59:57 <jethr0_> DukeDave: doing it with parsec isn't hard. want some help?
12:00:37 <DukeDave> I would say yes..
12:00:46 <DukeDave> but am just about to dash out annoyingly
12:00:51 <jethr0_> annoyingly
12:01:22 <DukeDave> uhh, yes, annoyingly :)
12:01:31 <jethr0_> nm
12:01:34 <DukeDave> but if you're around tomorrow
12:01:41 <jethr0_> maybe
12:02:01 <jethr0_> but i think i might be out.
12:02:49 <DukeDave> I've got parsec circled on my pad now, so I'll hit google tomorrow for one last  push :)
12:03:31 <Cale> DukeDave: did you see my Sudoku solver?
12:04:25 <DukeDave> I had a brief look and was entirely blown away!
12:04:33 <jethr0_> DukeDave: if you wait a few minutes i could post sth.
12:05:04 <DukeDave> yeah that would be cool!
12:05:22 * DukeDave just hopes one day he'll be able to actually help someone of freenode :)
12:05:39 <palomer> well, after 2 days of pondering I've come back to my starting point
12:05:42 <Cale> Sure, stick around :)
12:06:07 <xerox_> Hola Cale >/(
12:06:12 <Cale> hello
12:06:14 <xerox_> Wops, damn keymap.
12:06:18 <adu> Cale: you wrote a Sudoku solver? awsome!
12:06:43 <Cale> I learned a lot about Haskell just hanging around here and stealing other people's homework problems for myself :)
12:06:53 * xerox_ nods
12:07:16 <adu> huh interesting
12:07:23 <adu> maybe i should do that
12:07:35 <adu> instead of trying to do my tetration code
12:07:43 <Cale> adu: yeah, I wrote a solver, it's up here: http://www.haskell.org/hawiki/SudokuSolver
12:08:12 <jethr0_> DukeDave: i've got sth already. just a sec
12:08:36 <adu> what is MonadNondet ?
12:08:53 <Cale> adu: a faster replacement for the list monad
12:09:05 <Cale> the code appears further down the page
12:09:10 <adu> whats the list monad?
12:09:16 <adu> do you mean (:) ?
12:09:26 <Cale> return x = [x]
12:09:39 <Cale> xs >>= f = concat (map f xs)
12:10:07 <xerox_> > let tetration k a = iterate (^a) a !! (k-1) in tetration 2 2
12:10:08 <lambdabot> 4
12:10:41 <Cale> > [1,2,3] >>= \x -> [x, x * 10]
12:10:42 <lambdabot> [1,10,2,20,3,30]
12:10:50 <adu> actually "iterate (x^) 1 !! k" is how it actually works
12:10:55 <Cale> > do x <- [1,2,3]; [x, x * 10]
12:10:56 <lambdabot> [1,10,2,20,3,30]
12:10:59 <DukeDave> look at these guys -  defining lists in two lines
12:10:59 <xerox_> Okay.
12:11:00 <palomer> @hoogle (a -> m b) -> (b -> m c) -> (a -> m c)
12:11:01 <lambdabot> No matches, try a more general search
12:11:02 <lisppaste2> jethr0 pasted "not very educational" at http://paste.lisp.org/display/17649
12:11:12 <adu> xerox_: nice try tho
12:11:17 <palomer> there isn't a function of that type?
12:11:43 <adu> what does ">>=" do?
12:11:47 <jethr0_> DukeDave: have a look at the paste
12:12:02 <Cale> adu: you should read my monad tutorial :)
12:12:09 * xerox_ nod nods
12:12:17 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers
12:12:56 <palomer> @type >>=
12:12:57 <lambdabot> parse error on input `>>='
12:12:59 <palomer> @type (>>=)
12:13:00 <lambdabot> forall (m :: * -> *) b a.
12:13:00 <lambdabot>    (Monad m) =>
12:13:00 <lambdabot>    m a -> (a -> m b) -> m b
12:13:24 <Cale> so in the special case of lists, that becomes  [a] -> (a -> [b]) -> [b]
12:13:33 <Cale> you can almost imagine what it's doing
12:13:45 <adu> i thought a monad was a builtin type
12:13:48 <DukeDave> so, looks deceptivily easy.
12:13:52 <adu> you make it sound like a type-class?
12:14:03 <Cale> adu: yeah, it's just a typeclass
12:14:14 <Cale> Nothing magical about them at all.
12:14:19 <jethr0_> DukeDave: parsec _is_ deceptively easy, without the deception part
12:14:24 <adu> and every function is an instance of it?
12:14:34 <Cale> adu: every function?
12:14:54 <adu> ya, i thought thats how functions work in haskell
12:14:56 <Cale> Various type constructors are instances of monad.
12:15:16 <adu> but i thought monad meant "function of one variable"
12:15:21 <Cale> oh, no
12:15:26 <adu> WHAT?!?!?
12:15:43 <adu> how many meanings does it have in haskell then?
12:15:47 <Cale> one
12:16:16 <Cale> In general, it has more meanings, but in Haskell, just one.
12:16:36 <adu> so whats the name for the way that "->" works?
12:16:36 <Cale> in particular, Haskell is using the meaning which comes from category theory
12:16:47 <DukeDave> ahh so  parsec =  filter (\="deceptive")
12:16:49 <DukeDave> :)
12:17:07 <Cale> -> is the type constructor of functions
12:17:07 <jethr0_> DukeDave: obviously this doesn't help you much, because it's parsec specific
12:17:11 <adu> because  i remember reading in the haskell standard that a -> b -> c is like a function that returns a function that returns a value
12:17:17 <jethr0_> DukeDave: but it shows a simple way of approaching the problem
12:17:34 <Cale> adu: -> is right associative
12:17:46 <Cale> a -> b -> c means the same as a -> (b -> c)
12:18:12 <adu> right, thats what i said
12:18:26 <adu> i'm really confused
12:18:46 <adu> you're telling me what i already knew, but you're saying what i already knew is wrong
12:18:46 <Philippa> adu: you may be thinking of "unary"?
12:18:47 <adu> i don't get it
12:18:53 <Philippa> as in "all functions in haskell are unary"?
12:19:02 <palomer> -> has a single constructor
12:19:10 <adu> what does 
12:19:11 <Cale> adu: Monads have nothing to do with that
12:19:15 <adu> "monad" mean then?
12:19:23 <Cale> http://www.haskell.org/hawiki/MonadsAsContainers -- read this :)
12:19:36 <Philippa> palomer: I believe -> doesn't have /any/ constructors. It just is one
12:19:36 <DukeDave> I'll email lecturer tomorrow and point out that in the interest of good software development I am going to usilise an existing optimal solution ;)
12:19:45 <Philippa> (specifically, it is a type constructor)
12:20:00 <DukeDave> cheers man, that's a damn helpful example though
12:20:13 <lisppaste2> jethr0 annotated #17649 with "more concise" at http://paste.lisp.org/display/17649#1
12:20:23 <Philippa> adu: an instance of an algebraic structure, more or less
12:20:35 <Cale> If I wanted to be confusing, I'd mention that for any type e, the partially applied type constructor (->) e is a monad. :)
12:20:37 <jethr0_> np
12:20:38 <Philippa> within haskell, a type constructor that has an instance of Monad associated with it
12:21:51 <adu> Cale: that must be what i heard that made me think of (->) and monad at the same time...
12:23:00 <Cale> adu: yeah, usually the first monad people run into (which is a little annoying, since it's not a terribly easy example) is the monad IO.
12:23:27 <Cale> @type getLine
12:23:28 <lambdabot> IO String
12:23:54 <Cale> @type putStrLn
12:23:55 <lambdabot> String -> IO ()
12:24:00 <adu> ok, so "return", (>>=), and "join" are the only methods that are a part of the Monad type-class?
12:24:09 <Cale> @type getLine >>= putStrLn
12:24:10 <lambdabot> IO ()
12:24:20 <Cale> yeah
12:24:25 <adu> so is (>>=) like a pipe?
12:24:28 <DukeDave> ty jethr0_ 
12:24:28 <Cale> well, join isn't there, but it should be
12:24:40 <adu> isn't there? where?
12:24:51 <Cale> in the Monad typeclass itself
12:24:52 <jethr0_> welcome
12:25:31 <adu> yes it is
12:25:47 <adu> module Monad ( ... join, guard, when, unless...
12:25:57 <adu> my goodness theres tons of functions
12:25:58 <Cale> that's the Monad module
12:26:01 <adu> oh
12:26:05 <adu> i'm confused noe
12:26:09 <Cale> the class is in the Prelude
12:26:16 <Cale> class Monad m where
12:26:18 <Cale>    ...
12:26:22 <adu> its also in the Monad module
12:26:43 <Cale> yeah, possibly
12:26:44 <adu> wait, thats the MonadPlus class
12:26:47 <adu> n/m
12:26:49 <Cale> ah, okay
12:27:04 <adu> i'm still learning how to read haskell
12:29:27 <adu> so is (>>) a shortcut for return?
12:29:49 <Philippa> no
12:30:20 <Philippa> a >> b = a >>= (\_-> b)
12:30:38 <adu> that seems like "return"-ish to me
12:30:46 <Philippa> it's utterly not
12:31:04 <adu> it ignores a and returns b, thats like return isn't it?
12:31:05 <Philippa> return takes a single parameter of type a and puts it into the monad, yielding a value of type m a
12:31:20 <Philippa> it doesn't ignore a, it carries out a and ignores the /result/ of a
12:31:37 <adu> ok
12:31:46 <adu> so its like ";" in other languages
12:31:52 <Cale> (that's in the computational viewpoint)
12:31:54 <Cale> yeah
12:31:54 <Philippa> kind of, yeah
12:31:57 <adu> ok
12:32:51 <adu> lol i love the blueberry/apple thing :)
12:33:09 <ihope> @kind forall a. a
12:33:10 <lambdabot> *
12:33:35 <ihope> @kind forall ((~>) :: * -> * -> *) a b. a ~> b
12:33:35 <lambdabot> *
12:33:40 <ihope> Whoo.
12:33:50 <ihope> @kind forall ((->) :: * -> * -> *) a b. a -> b
12:33:51 <lambdabot> parse error on input `->'
12:34:46 <ihope> @type ((((),()),((),()),((),())),(((),()),((),()),((),())),(((),()),((),()),((),())),(((),()),((),()),((),())))
12:34:47 <lambdabot> ((((),
12:34:47 <lambdabot>                                       ()),
12:34:47 <lambdabot>                                      ((),
12:34:47 <lambdabot>                                       ()),
12:34:47 <lambdabot>                                      ((),
12:34:49 <lambdabot> [19 @more lines]
12:34:55 <ihope> Fix the line breaks!
12:35:01 <ihope> @kind ((((),()),((),()),((),())),(((),()),((),()),((),())),(((),()),((),()),((),())),(((),()),((),()),((),())))
12:35:02 <lambdabot> *
12:35:17 <jethr0_> @seen dukedave
12:35:17 <lambdabot> I saw dukedave leaving #haskell 5 minutes and 58 seconds ago.
12:35:41 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
12:35:42 <lambdabot> forall a.
12:35:42 <lambdabot>                           a
12:35:42 <lambdabot>                           -> ((((((((a, a),
12:35:42 <lambdabot>                              (a, a)),
12:35:42 <lambdabot>                              ((a, a),
12:35:44 <lambdabot> [125 @more lines]
12:36:00 <ihope> Oh noes.
12:36:11 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
12:36:27 <ihope> Um...
12:36:30 <Cale> hehe
12:36:50 <Cale> should get terminated after a little bit
12:36:52 <ihope> @pl \x y -> x (x y)
12:37:10 <lambdabot> forall a.
12:37:10 <lambdabot>                                 a
12:37:10 <lambdabot>                                 -> ((((((((((((((((a,
12:37:10 <lambdabot>                                       a),
12:37:10 <lambdabot>                                       (a,
12:37:12 <lambdabot> [65533 @more lines]
12:37:14 <lambdabot> join (.)
12:37:18 <Cale> whoa, it finished :)
12:37:19 <ihope> Wow!
12:37:31 <Cale> must be on a machine with more memory :)
12:37:45 <palomer> hrmph, my type system is coming along
12:37:50 <Cale> (used to just die on that)
12:37:52 <palomer> proving anything about it is going to be reall, really tough
12:38:01 <palomer> s/reall/really
12:38:16 <ihope> @type let join = Control.Monad.Reader.join in join (.) (join (.)) (join (.)) (join (.)) (join (.)) (join (.)) (join (,))
12:38:17 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t2 -> t3 ->
12:38:17 <lambdabot> t4 -> t1
12:38:17 <lambdabot>   Expected type: (t -> t2 -> t3 -> t4 -> t1) -> t -> t2 -> t3 -> t4 ->
12:38:17 <lambdabot> t1
12:38:21 <ihope> Aww.
12:38:26 <ihope> @type join (.)
12:38:27 <lambdabot> Not in scope: `join'
12:38:44 <ihope> @type let join x = \y -> x y y in join (.)
12:38:45 <lambdabot> forall c.
12:38:45 <lambdabot>               (c -> c) -> c -> c
12:38:55 <ihope> @type let join x = \y -> x y y in join (,)
12:38:56 <lambdabot> forall a. a -> (a, a)
12:38:59 <ihope> Hmm.
12:39:04 <ihope> ...Aha!
12:39:15 <ihope> Um.
12:39:49 <ihope> >:-)
12:40:22 <ihope> > let join x y = x y y in join (.) (join (.)) (join (.)) (join (.)) (join (.)) (join (.)) succ 0
12:40:27 <lambdabot> Terminated
12:40:52 <ihope> That = big.
12:41:03 <Cale> the fact that it's polymorphic let binding and not monomorphic lambda binding is important
12:41:28 <Cale> (for that type system DoS example :)
12:41:32 <palomer> @type let join x y = x y y in join
12:41:34 <lambdabot> forall t t1.
12:41:34 <lambdabot>            (t -> t -> t1) -> t -> t1
12:41:44 <ihope> Cale: what?
12:42:05 <palomer> can this function ever terminate?
12:42:37 <ihope> Yes...
12:42:47 <ihope> > let join x y = x y y in join succ 0
12:42:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
12:42:48 <lambdabot>   Expected type: (t -> t1) -> (t -> t1) -> t2
12:42:48 <lambdabot>   Inferred type: (t -> t1) -> t -> t1
12:42:51 <Cale> @type two f x = f (f x)
12:42:51 <lambdabot> parse error on input `='
12:42:52 <ihope> Um...
12:43:01 <Cale> @type let two f x = f (f x) in two
12:43:01 <lambdabot> forall t. (t -> t) -> t -> t
12:43:10 <ihope> Oh!...
12:43:15 <ihope> Right, right.
12:43:26 <Cale> @type let two f x = f (f x) in two (\x -> (x,x))
12:43:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
12:43:27 <lambdabot>   Expected type: a
12:43:35 <ihope> > let join x y = x (x y) in join (.) (join (.)) (join (.)) (join (.)) (join (.)) (join (.)) succ 0
12:43:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
12:43:36 <lambdabot>   Expected type: ((a -> t) -> t1 -> t2 -> t3 -> t4 -> t5 -> t6)
12:43:36 <lambdabot>        -> (a -> t)
12:43:40 <ihope> Aww.
12:43:47 <ihope> > let join x y = x (x y) in join (.) (join (.)) (join (.)) (join (.)) (join (.)) (join (.)) succ
12:43:48 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
12:43:48 <lambdabot>   Expected type: ((a -> t) -> t1 -> t2 -> t3 -> t4 -> t5)
12:43:48 <lambdabot>        -> (a -> t)
12:43:51 <ihope> > let join x y = x (x y) in join (.) (join (.)) (join (.)) (join (.)) (join (.)) (join (.))
12:43:51 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
12:43:51 <lambdabot>   Expected type: ((a -> t) -> t1 -> t2 -> t3 -> t4)
12:43:51 <lambdabot>        -> (a -> t)
12:43:56 <ihope> > let join x y = x (x y) in join (.) (join (.)) (join (.)) (join (.))
12:43:56 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
12:43:56 <lambdabot>   Expected type: ((a -> t) -> t1 -> t2) -> (a -> t) -> t1 -> t2
12:43:56 <lambdabot>   Inferred type: ((a -> t) -> t1 -> t2) -> (a -> a -> t) -> a -> t1 ->
12:43:58 <lambdabot> t2
12:44:04 <ihope> > let join x y = x (x y) in join (.)
12:44:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
12:44:05 <lambdabot>   Expected type: ((a -> t) -> c) -> (a -> t) -> c
12:44:05 <lambdabot>   Inferred type: ((a -> t) -> c) -> (a -> a -> t) -> a -> c
12:44:08 <ihope> Heh.
12:44:16 <ihope> Oh...
12:44:44 <ihope> @type let two x y = x (x y) in two two two two two two two two two two two two two two two two two two two two two two two two two two two two two succ 0
12:44:44 <lambdabot> forall a.
12:44:44 <lambdabot>                                                    (Enum a,
12:44:44 <lambdabot>                                                    Num a) =>
12:44:44 <lambdabot>                                                    a
12:44:49 <Cale> (\x -> (x,x)) isn't of a suitable type to pass to two
12:47:06 <Cale> so you can't abstract that process
12:48:29 <jethr0_> spam spam spam
12:49:33 <palomer> well, only a single algorithm to write
12:49:39 <palomer> this one is going to be a doozy
12:53:12 <orbitz> hrm, i think i'm gogn to implement chinese remainder theorme in haskell
12:53:14 <orbitz> that sounds interesting
12:54:32 <palomer> ooh, and challenging too!
12:55:59 <adu> hello again
12:56:39 <ihope> Chinese room!
12:56:57 <palomer> roomainder theorem?
12:57:25 <SimonRC> :-)
12:57:25 <adu> so how would a list like [1, 2, 3] be represented as a monad?
12:58:52 <palomer> adu: do you know any other programming?
12:59:05 <palomer> s/?/language?
12:59:30 <adu> palmer: ya i know scheme C/C++ Java Perl Python
13:00:17 <Philippa> adu: that doesn't make sense
13:00:22 <adu> i'm having a problem with Monads tho
13:00:24 <Philippa> the list type /is/ a monad
13:00:33 <adu> Philippa i don't see how
13:00:36 <Philippa> so [1,2,3] is a (trivial) computation
13:00:38 <palomer> adu: do you know what a generic class is?
13:00:40 <Philippa> go read the instance
13:00:43 <Philippa> that'll tell you how
13:00:49 <adu> a monad takes 1 argument and cons takes 2 arguments
13:00:55 <adu> how is a list a monad?
13:00:58 <palomer> (in either Java or C++)
13:01:03 <Philippa> you're confusing type constructors with data constructors
13:01:36 <adu> palomer i know what an abstract class is and i understand "type" and "type-class" in haskell
13:02:03 <adu> Philippa maybe i am
13:02:36 <palomer> adu: I'm talking about a parametric class
13:02:41 <palomer> adu: like vector in C++
13:02:51 <adu> ok
13:02:59 <Philippa> it's [] that forms a monad, with [a] being "computation that yields a value of type a"
13:03:11 <adu> ok
13:03:11 <Philippa> or rather, a result of type a
13:03:24 <jethr0_> adu: anything is a monad that fulfills the three monad laws. i.e. sensible definitions for "return" and ">>="
13:03:28 <palomer> adu: vector can be thought of a monad
13:03:42 <Philippa> return builds singleton lists - return 1 = [1] here
13:03:55 <jethr0_> heck, even identity is a monad
13:05:08 <Lemmih> > do x <- [1,2,3]; return (x+1)
13:05:09 <lambdabot> [2,3,4]
13:05:20 <adu> so "Monad []" makes a type with a (:) method?
13:05:47 <palomer> adu: do you know what an interface is in java?
13:06:26 <adu> palomer : ya just a bunch of function types but no impl
13:06:41 <palomer> adu: Monad is an interface for a generic class
13:07:04 <palomer> a generic class of one parameter
13:07:12 <Lemmih> adu: (:) is a data-constructor. It doesn't make types.
13:07:13 <adu> palomer : ooh
13:07:42 <palomer> a Monad is any generic class that implements that interface
13:08:04 <adu> ok
13:08:17 <palomer> so asking if [1,2,3] is a Monad doesn't make sense
13:08:30 <palomer> since [1,2,3] is a value
13:08:37 <adu> so what implements "Monad []"?
13:09:00 <Philippa> there's an instance definition somewhere for it
13:09:05 <adu> i suppose its in Cale's tutorial
13:09:08 <Philippa> (in effect, "the implementation of Monad []")
13:09:44 <palomer> adu: the syntactic sugar can also be confusing
13:09:53 <palomer> adu: ignore that [] exists, and instead call it List
13:10:13 <adu> can any list be turned into a "Monad []"?
13:10:18 <palomer> List is the C++/java equivalent of a singly parametric generic class
13:10:19 <adu> or only lists of length 1?
13:10:26 <resiak> Any list _is_ a monad [], surely?
13:10:27 <palomer> adu: forget about [], it doesn't exist
13:10:27 * jethr0_ shakes his head
13:10:45 <palomer> only List
13:10:49 <Philippa> adu: there's no such thing. Monad is not a type constructor
13:11:27 <palomer> so, when I ask "is List a monad" I'm asking " does List implement the Monad interface "
13:11:30 <Philippa> therefore you only have types that're instances of monad, and lists (which are things belonging to a type that's an instance of monad)
13:12:07 <adu> ok
13:12:41 <jethr0_> "Neo: There is no spoon? Boy: Then you'll see that it is not the spoon that bends, it is only yourself."
13:13:05 <Philippa> woah
13:13:23 <adu> what List function implements the (>>=) interface?
13:13:33 <Philippa> >>= is not an interface
13:13:34 <Philippa> try again?
13:13:48 <adu> and what does (:) implement? if it is a requirement of Monad?
13:14:00 <palomer> (>>=) is a member of the Monad interface. However, we should start using haskell terminology
13:14:01 <jethr0_> more importantly type classes are not java interfaces/classes
13:14:10 <adu> a Monad must implement (>>=) right?
13:14:13 <Philippa> (the implementation of >>= for List, as found in the instance declaration for Monad List, where Monad List describes an instance)
13:14:15 <palomer> jethr0_: how so?
13:14:19 <Philippa> (:) is irrelevant
13:14:24 <palomer> type classes are very much like interfaces
13:14:32 <jethr0_> at some point the analogy breaks down. like, when someone asks which class method implements the interface method.
13:14:40 <palomer> adu: anything that implements Monad must implement >>=
13:14:44 <Philippa> jethr0_: java interfaces are significantly different from java classes, don't conflate the two
13:14:54 <jethr0_> i'm not
13:14:57 <palomer> jethr0_: how so?
13:15:11 <palomer> I'm the one conflating
13:15:17 <Philippa> jethr0_: not really, they share names still. The name is what identifies it as the instance method, and there's an implementation associated with the class. How's that different?
13:15:25 <jethr0_> when "people" think of  java interfaces they think of "implements"
13:15:41 <Philippa> and the haskell equivalent is instance
13:15:48 <jethr0_> in the case of [] the class is "anonymous"
13:15:54 <Lemmih> > (>>=) [1,2,3] (\x -> [x+1])
13:15:55 <lambdabot> [2,3,4]
13:15:55 <Lemmih> > (flip concatMap) [1,2,3] (\x -> [x+1])
13:15:56 <lambdabot> [2,3,4]
13:16:12 <jethr0_> nm, i don't want to spread more confusion
13:16:47 <adu> so if the List type uses functions that are not implementing and functions required by the Monad type-class, then the analogy of "Monads as Containers" seems to be a bad analogy
13:17:27 <palomer> adu: how much programming have you done if I may so bold as to ask?
13:17:56 <adu> "how much" as in LOC? or in years? # of projects? what do you mean?
13:17:59 <jethr0_> adu: i don't mean to be rude, but you might consider looking at the tutorials. it took me three times to get a grip on things. it's just not the easiest thing in the world to "get"
13:18:00 <Philippa> adu: your use of terminology doesn't make sense
13:18:26 <palomer> adu: years
13:18:50 <adu> about 14 years
13:19:31 <palomer> and how much haskell programming have you done?
13:19:37 <adu> none
13:19:51 <palomer> well you need to do some haskell programming to understand monads
13:20:07 <adu> I'm somewhat afraid to use Haskell until i understand it, which i don't
13:20:11 <palomer> monads are considered an "advanced" topic, I think
13:20:20 <palomer> you can use haskell fine without understanding monads
13:20:33 <Philippa> adu: do you understand typeclasses?
13:20:37 <Philippa> if not, go fix that
13:20:40 <adu> yes
13:20:52 <Philippa> if you do, how the hell does your use of terminology above arise?
13:21:01 <adu> instances of typeclasses are types, and instances of types are values
13:21:06 <palomer> trying to understand monads without programming is like trying to win the olympics without practicing
13:21:16 <Philippa> that's not all there is to understand
13:21:26 <adu> lol
13:21:32 * palomer has never used the word instance for inhabitant
13:21:50 <adu> maybe i don't understand typeclasses then
13:21:52 <Philippa> no, really: do you know what an instance declaration looks like?
13:22:05 <Philippa> do you know how you make a type an instance of a type class?
13:22:10 <Philippa> if not, you don't understand type classes
13:22:31 <adu> instance MetaclassStuff => TypeName where ...
13:22:37 <Philippa> what's the ...?
13:22:51 <Lemmih> adu: Not quite.
13:22:52 <Philippa> (that syntax is wrong, btw)
13:22:56 <adu> Philippa function datatypes and implementation
13:23:08 <Philippa> that doesn't make sense
13:23:11 <Philippa> could you rephrase that?
13:23:23 <Philippa> (there are no datatype declarations inside an instance declaration, ever)
13:23:41 <jethr0_> i think he meant signatures
13:23:43 <adu> isn't f :: a -> b -> c like the type of the function?
13:23:55 <Philippa> yes. That's not a datatype
13:23:59 <adu> o oops
13:24:14 <phas> Hi, i'm seeking for someone for a project
13:24:19 <Philippa> it's not referred to as a datatype in any language I know of, in fact
13:24:34 <Lemmih> phas: Aren't we all?
13:24:39 <adu> sorry i don't know how that got there
13:24:40 <phas> I want to develop a package manager for a distribution
13:24:49 <phas> Lemmih, yeah probably :P
13:25:05 <ihope> @index :>
13:25:06 <lambdabot> bzzt
13:25:10 <ihope> @index (:>)
13:25:10 <lambdabot> bzzt
13:25:13 <ihope> Yay!
13:25:16 <Philippa> okay. So, if the instance declaration contains the implementations of the functions associated with the class, where does List's >>= come from?
13:25:25 <Lemmih> phas: A Haskell package manager?
13:25:42 <ihope> Philippa: the instance declaration...
13:25:43 <palomer> Philippa: I've been thinking of the annotations of the other day (and read the lexical typing paper, which is a lot of fun) and I think that you absolutely need one way unification to do it
13:25:52 <phas> Lemmih: a package manager wrote in Haskell, yeah
13:26:01 <palomer> with so called "universal variables"
13:26:03 <phas> Lemmih: ergh, written
13:26:08 <adu> maybe i should reread the standard again
13:26:08 <Philippa> yeah, that's about my gut instinct now I'm more awake
13:26:37 <Lemmih> phas: Like apt-get or emerge?
13:26:48 <phas> Lemmih: right
13:26:49 <palomer> and I think you were trying to have lexically scoped variables in your system
13:27:00 <phas> Lemmih: I explain better
13:27:20 <phas> Lemmih: I'm studiyng computer science at university
13:27:26 <Philippa> palomer: which one of the ideas I've kicked around? :-)
13:27:45 <palomer> Philippa: things like "f::a -> a; f 0 = 0"
13:27:46 <phas> Lemmih: I came up with an idea about creating a distribution using Darwin as Kernel
13:28:08 <palomer> which should pass, while "f::forall a -> a; f 0 = 0" should fail
13:28:12 <adu> igtg
13:28:16 <Philippa> I wasn't. I would remember it if I'd been trying to do that
13:28:19 <palomer> in the first case a is an existential variable, in the second case it's a universal variable
13:28:20 <phas> Lemmih: while I was seeking for people that could join me, i found a friend of mine wich come up
13:28:22 * Philippa nods
13:28:41 <palomer> so "f::a -> b; f x = x" should pass
13:28:41 <ihope> Okay. More syntactic sugar for pattern matching:
13:28:42 <phas> Lemmih: with a project of a new package manager
13:28:46 <Philippa> I was effectively doing all-existential annotations, but I wasn't trying to do anything with fancy scoping
13:29:00 <Philippa> and I've said my old implementation's broken, right?
13:29:00 <phas> Lemmih: wich he never implemented
13:29:07 <palomer> Philippa: right
13:29:10 <palomer> but I'm discussing the ideas
13:29:13 <Philippa> (which in hindsight doesn't surprise me, I was a lot sloppier about some of the maths at the time)
13:29:16 <Philippa> okay, fair enough
13:29:20 <phas> Lemmih: so i thought: "Why not implement it in Haskell?"
13:29:24 <ihope> {Left :> id; Right :> error} :: Either a String -> a
13:29:34 <phas> Lemmih: and build up a distro on it?
13:29:39 <palomer> anyways, I'm off!
13:29:40 <phas> Lemmih: so here I'm
13:29:40 <Philippa> starts to look like a variant of my haskell' proposal, then :-)
13:29:46 <palomer> well, yes
13:29:50 <ihope> Essentially, it'd replace Left with id and Right with error...
13:29:53 <palomer> it's the only way to make sens of what you proposed
13:29:54 <Lemmih> phas: Announcing your project on the haskell mailing list might be a better way to call attention to it.
13:30:04 <palomer> s/sens/sense
13:30:10 <palomer> Philippa: did you read the lexical scoing paper?
13:30:18 <phas> Lemmih: I'll surely do it
13:30:26 <palomer> btw, ghc's way of doing it is ugly
13:30:48 <Philippa> I did at some point, yeah. Plus the new boxy types paper covers it in that context
13:31:40 <palomer> grr, where are the annotations covered in the ghc manual...
13:32:55 <palomer> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3147017
13:33:00 <palomer> section 7.4.10.3
13:33:08 <palomer> I think this is totally wrong
13:34:19 <Lemmih> phas: How will your package manager be better than the existing ones?
13:34:24 <lisppaste2> jethr0 annotated #17649 with "move concise" at http://paste.lisp.org/display/17649#2
13:36:46 <phas> Lemmih: Well, my friend still not gave me specifications, so i still don't know details. But there are two things we are focusing on.
13:38:09 <phas> Lemmih: first speed up the lookup in the apps database, maybe using something like SQLite
13:39:01 <phas> Lemmih: second we want the sistem to use both binary and source packages at the same thime, like apt, but with a better support to it.
13:39:48 <jethr0_> doesn't emerge or however gentoos system is called handle binary and source packages?
13:40:20 <phas> jethr0_: That I know, emerge support only source packages
13:40:40 <phas> jethr0_: or maybe it's gentoo that use only them
13:40:48 <bolrod> db
13:40:53 <bolrod> 00ps
13:41:18 <jethr0_> "It handles both source and binary packages"
13:41:39 <jethr0_> "The emerge command can also be used to download and install binary files"
13:41:54 <jethr0_> but i've never used emerge...
13:42:15 <phas> uhm, well, i didn't know it
13:42:18 <ihope> So could I read [foo | bar <- baz | qux <- quux] as "foo where bar is taken from baz as qux is taken from quux"?
13:42:42 <phas> but in fact it doesn't exists a distro that really uses both binary and source packages
13:43:20 <ihope> Hmm...
13:43:37 <phas> and the thing itself to write the package manager in haskell is not little
13:43:46 <jethr0_> phas: and there are also tools for automatic from-source building for apt
13:43:47 <ihope> > (-|-)
13:43:48 <lambdabot>  Not in scope: `-|-'
13:44:04 <phas> jethr0_: yeah i mentioned them
13:44:10 <jethr0_> k
13:44:14 <ihope> I need something that looks like an infix operator but is actually a parse error.
13:44:36 <ihope> > foo -|- bar
13:44:37 <lambdabot>  Not in scope: `bar'
13:44:55 <jethr0_> > let a --- b = a - b in 3 --- 4
13:44:55 <lambdabot>  parse error (possibly incorrect indentation)
13:44:58 <phas> jethr0_: but i want to improve the source-binary support like you can have an hibrid distribution without issues
13:45:14 <ihope> > (---)
13:45:15 <lambdabot>  parse error on input `}'
13:45:17 <Excedrin> phas: Arch Linux has a 'srcpac' program that does a good job of using either source or binaries, and of course there's *BSD with ports
13:45:29 <ihope> jethr0_: is this used anywhere?
13:45:32 <jethr0_> hmm, i'd image that to be quite troublesome, but anything written in haskell is cool :)
13:45:42 <jethr0_> ihope: no, i was just testing sth :)
13:45:58 <jethr0_> *imagine
13:46:05 <phas> Excedrin: thaks, i'll put an eye on them
13:46:14 <xerox_> phas!
13:46:16 <ihope> > 3 + 2 --- 5
13:46:17 <lambdabot> 5
13:46:19 <ihope> Aww.
13:46:22 <ihope> > 3 + 2 --- 6
13:46:23 <lambdabot> 5
13:46:25 <jethr0_> > let a ---- b = a - b in 3 ---- 4
13:46:26 <lambdabot>  parse error (possibly incorrect indentation)
13:46:34 <ihope> It's a comment!
13:46:50 <jethr0_> well, AFAIK it's possible to have operators starting with --
13:47:16 <ihope> > (--+)
13:47:17 <lambdabot>  Not in scope: `--+'
13:47:21 <ihope> Wow.
13:47:28 <ihope> > (-->)
13:47:28 <lambdabot>  Not in scope: `-->'
13:47:31 <ihope> Yay!
13:49:25 <palomer> @hoogle (-->)
13:49:25 <lambdabot> No matches found
13:49:29 <palomer> @hoogle -->
13:49:30 <lambdabot> hoogle: unrecognized option `-->'
13:49:30 <lambdabot> HOOGLE - Haskell API Search
13:49:30 <lambdabot> (C) Neil Mitchell 2004-2005, York University, UK
13:49:30 <lambdabot>  
13:49:30 <lambdabot> Usage: hoogle [OPTION...] search
13:49:32 <lambdabot> [14 @more lines]
13:49:39 <xerox_> O_o
13:49:47 <xerox_> bad bad bad bad.
13:49:53 <bolrod> you want to use the comment thing as an operator? :)
13:51:50 <palomer> yes!
13:52:05 <bolrod> haha
13:52:05 <jethr0_> i think --> is valid
13:52:16 <jethr0_> > let a ---> b = a - b in 3 ---> 4
13:52:17 <lambdabot> -1
13:52:19 <bolrod> {->-} maybe?
13:52:20 <bolrod> 8)
13:52:32 <jethr0_> sry, meant it with 3 bars
13:52:42 <bolrod> weird
13:53:23 <chrisbrown> oh not the debate about the comment operator again
13:53:36 <chrisbrown> :)
13:54:05 <ihope> > {->-}
13:54:06 <lambdabot>  parse error on input `}'
13:54:08 <ihope> > ->-
13:54:09 <lambdabot>  parse error on input `->-'
13:54:12 <ihope> > (->-)
13:54:13 <lambdabot>  Not in scope: `->-'
13:55:05 <ihope> So what do you think? Does "fromJust = {Just ->- id; Nothing ->- error "Nothing"}" look good to you?
13:56:23 <jethr0_> @localtime philippa
13:56:33 <palomer> I'm off (really this time)
13:57:21 <ihope> @localtime ihope
13:57:24 <lambdabot> Local time for ihope is Wednesday, March 08, 2006 4:56:48 PM
13:57:29 <ihope> Cool.
13:58:04 <ihope> @localtime ihope
13:58:07 <lambdabot> Local time for ihope is Wednesday, March 08, 2006 4:57:31 PM
13:58:15 <ihope> Hmm, didn't work.
13:58:26 <Cale> -- only starts a comment when not followed by a symbol character
13:59:10 <Cale> so --abc is a comment, but -->abc is not
14:03:09 <ihope> So would it be a bad idea to turn ->- into special syntax?
14:04:37 <ihope> > {}
14:04:37 <lambdabot>  parse error on input `{'
14:06:25 <ihope> > foo {} bar
14:06:25 <lambdabot>  Empty record update
14:06:52 <ihope> Records, eh?
14:11:37 <ihope> > 99999999999999999999999999999999 :: Int
14:11:38 <lambdabot> -1
14:13:29 <bolrod> :)
14:13:35 <bolrod> > 100000000000000000000000 / 2
14:13:36 <lambdabot> 4.9999999999999996e22
14:13:38 <bolrod> ;)
14:15:06 <ihope> > 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 :: Integer
14:15:07 <lambdabot> 111111111111111111111111111111111111111111111111111111111111111111111111111
14:15:07 <lambdabot> 11111111111111111111111111111111111111111111
14:15:36 <ihope> > 2^2^2^2^2^2^2^2^2^2^2^2^2^2
14:15:40 <lambdabot> Terminated
14:17:21 <ihope> > ñ
14:17:22 <lambdabot>  lexical error
14:17:25 <ihope> Aww.
14:17:42 <bolrod> > Just "wrong"
14:17:43 <lambdabot> Just "wrong"
14:18:57 <ihope> > Àñôthër díàcrítícàl màrk?
14:18:58 <lambdabot>  lexical error
14:19:05 <palomer> yes! fixed annotations
14:19:07 * palomer does a dance
14:19:14 <xerox_> http://pics.obra.se/wanted-engineer.jpg
14:19:58 <palomer> not bad
14:22:14 <mathrick> @hoogle list comprehension
14:22:15 <lambdabot> Prelude.undefined :: a
14:22:15 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
14:22:15 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:22:23 <Cale> that's not a very difficult problem though :)
14:22:25 <mathrick> @docs list comprehension
14:22:25 <lambdabot> list comprehension not available
14:22:34 <mathrick> æh?
14:22:49 <mathrick> how do I search for a concept, not a function's docs?
14:22:51 <Cale> list comprehensions are part of the syntax
14:23:02 <Cale> You could look in the Haskell Report
14:23:04 <mathrick> I know, I want to see the exact syntax :)
14:23:15 <Cale> one sec :)
14:23:19 <mathrick> Cale: yes, how do I ask lambdabot to search the report?
14:23:29 <Cale> http://haskell.org/onlinereport/exps.html#sect3.11
14:24:10 <Cale> it doesn't have a module to search the report
14:24:24 <Cale> but the report is online, so you can search it yourself
14:25:38 <mathrick> okay, so the problem was [x | x < 10, x <- [1 .. 100]] is not valid
14:25:48 <Cale> right
14:25:49 * mathrick is used to python's order
14:25:57 <Cale> because x is not in scope yet
14:26:04 <univac> mathrick: oo ;]
14:26:05 <Cale> [x | x <- [1..100], x < 10]
14:26:20 <Cale> > [x | x <- [1..100], x < 10]
14:26:21 <lambdabot> [1,2,3,4,5,6,7,8,9]
14:26:34 <Cale> > do x <- [1..100]; guard $ x < 10; return x
14:26:34 <lambdabot> [1,2,3,4,5,6,7,8,9]
14:26:40 <mathrick> Cale: I cannot say [x | x < 10 where x <- [1 .. 100]] though, which is I find inconsistent :)
14:26:43 <mauke> hey, I was just typing that :-)
14:26:54 <tic> ohh, didn't know there was a guard keyword
14:27:00 <mauke> it's not a keyword
14:27:01 <Cale> it's not a keyword
14:27:03 <orbitz> mauke: hi
14:27:04 <mauke> huhu
14:27:04 <mathrick> > [x | x < 10 where x <- [1 .. 100]]
14:27:05 <lambdabot>  parse error on input `where'
14:27:05 <Cale> jinx
14:27:51 <Cale> guard b = if b then return () else mzero
14:27:53 <mauke> @type guard
14:27:54 <lambdabot> Not in scope: `guard'
14:28:03 <ihope> mzero?
14:28:11 <ihope> Hmm.
14:28:12 <Cale> guard :: (MonadPlus m) => Bool -> m ()
14:28:24 <Cale> really it ought to be
14:28:26 <bolrod> > [x | x<- [1..100], x<10]
14:28:27 <lambdabot> [1,2,3,4,5,6,7,8,9]
14:28:27 <ihope> A non-evil version of fail?
14:28:28 <Cale> guard :: (MonadZero m) => Bool -> m ()
14:28:31 <Cale> yes
14:28:38 <Cale> exactly
14:28:51 <Cale> (that's what mzero is)
14:29:00 <chrisbrown> ihope - thats pretty much what mzero does
14:30:00 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard $ x^2 + y^2 == z^2; return (x,y,z)
14:30:01 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
14:30:59 <adu> that uses Monad functions
14:31:08 <Cale> yep
14:31:20 <Cale> and it's the same as
14:31:41 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
14:31:42 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
14:31:58 <adu> where did the guard/return go?
14:32:41 <Cale> the return is implicit in the part before the | and the guard is from the fact that x^2 + y^2 == z^2 is of type bool, and so gets treated that way
14:33:44 <adu> Cale: but "return" returns [a], how did that turn into [a, b, c]?
14:33:55 <Cale> bind concatenates results
14:34:02 <adu> oh
14:34:16 <lnxnt> hi
14:34:20 <Cale> hello
14:34:22 <adu> i don't see any (>>=) in either examples...
14:34:23 <lnxnt> do you know JFlex?
14:34:44 <lnxnt> scanner generator..
14:34:55 <Cale> adu: the do-notation gets translated into a bunch of applications of bind
14:35:11 <Cale> lnxnt: for Haskell?
14:35:22 <lnxnt> Cale no
14:35:26 <mauke> > [1..10] >>= \x -> [x..20] >>= \y -> [y..20] >>= \z -> guard (x^2 + y^2 == z^2) >> return (x,y,z)
14:35:27 <Cale> try #java :)
14:35:27 <lambdabot> [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15)]
14:35:38 <adu> oh
14:36:39 <adu> ahh
14:36:52 <Cale> do-notation is just syntax sugar, so when you read it at first, you might want to translate it in your head into (>>=) and (>>)'s
14:37:00 <adu> that makes sense
14:37:55 <adu> i don't like syntax sugar, i like the "bottom-floor" 
14:38:13 <Philippa> you might change your mind in this particular case
14:38:15 <Cale> well, syntax sugar can be nice once you understand it
14:38:30 <adu> yes
14:38:30 <Philippa> the do notation is one of the nicest pieces of sugar I've used in a long, long time
14:38:40 <Cale> and in this case, it's very nice for getting rid of the details you're not concerned with, and showing you what's important
14:38:58 <adu> its just confusing in the beginning
14:39:00 <Cale> right
14:39:22 <adu> like I love how Mathematica has many ways of saying things
14:39:31 <adu> that get translated into the same thing in the end
14:39:32 * Philippa finds in this case it's only got 'serious' potential for confusion at the point where you start implementing your own monads
14:39:45 <Cale> I suppose it's rather like how vim or emacs' keys seem confusing at first, but they're actually quite well designed once you're used to them.
14:40:16 <Philippa> learning to use monads in terms of do alone is entirely possible, not much more complicated than the base level and a much closer map to the structures you'll actually intend as you code most of the time
14:42:00 <Cale> though you might be a little confused about why "return ()" in the middle of a do-block does nothing at first :)
14:43:42 <ihope> (Cont . const)!
14:43:59 <ibid> well, i'd say return is one of the worst cases of misnamed-functionitis
14:44:14 <ihope> Heh, yep.
14:44:23 <ihope> Is there anything worse?
14:44:28 <ibid> there is no context, except in the last expression of a do, where return does what it suggests
14:44:47 <ibid> ... its name suggests
14:48:20 <ihope> > [x | x <- getLine]
14:48:20 <lambdabot> Couldn't match `IO String' against `[a]'
14:48:23 <ihope> Aww.
14:48:47 <ihope> @type \x y x -> [x | y <- z] -- ;-)
14:48:48 <lambdabot>   Conflicting definitions for `x'
14:48:48 <lambdabot>   In a lambda abstraction
14:48:49 <xerox_> @type [x | x <- return getLine]
14:48:50 <lambdabot> [IO String]
14:48:59 <ihope> @type \x y z -> [x | y <- z]
14:49:00 <lambdabot> forall a a1 t. a -> t -> [a1] -> [a]
14:49:15 <ihope> That's nice.
14:49:41 <xerox_> Uhm.
14:49:51 <xerox_> There is no useful 'y' you could pass, I fear.
14:57:15 <ihope> Pass Just x as y, and see how badly it works.
14:57:50 <ihope> (\x y -> x = y) ones (1 : ones) -- defines ones to equal repeat 1
15:15:18 <ihope> let (\x y -> x = y) ones (1 : ones) in ones
15:15:26 <ihope> > let (\x y -> x = y) ones (1 : ones) in ones
15:15:27 <lambdabot>  parse error on input `='
15:16:55 <ihope> > have have equal let; equal equal =; for equal in; x equal 3 for x
15:16:56 <lambdabot>  parse error on input `let'
15:19:46 <ihope> > let let let let let let
15:19:47 <lambdabot>  parse error (possibly incorrect indentation)
15:20:06 <ihope> @type (=)
15:20:07 <lambdabot> parse error on input `='
15:20:42 <goltrpoat> why is the <10 in foldl (.) id [(<10), (+5), (*6)] illegal?  i was expecting something equivalent to \a -> (a*6+5) < 10
15:21:11 <Pseudonym> @type (<10)
15:21:12 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
15:21:15 <Pseudonym> @type (+5)
15:21:16 <lambdabot> forall a. (Num a) => a -> a
15:21:19 <Pseudonym> Different types.
15:21:39 <goltrpoat> but (<10) and (+5) compose left to right
15:21:48 <Pseudonym> Yeah, but the list is homogeneous.
15:21:52 <goltrpoat> oh duh.
15:24:22 <Lemmih> Prelude GHC.Exts> unsafeCoerce# (foldl (.) id [unsafeCoerce# (<10), (+5), (*6)] 1) :: Bool
15:24:25 <Lemmih> False
15:24:28 <Lemmih> Prelude GHC.Exts> unsafeCoerce# (foldl (.) id [unsafeCoerce# (<10), (+5), (*6)] 0) :: Bool
15:24:31 <Lemmih> True
15:24:38 <goltrpoat> ah cool
15:24:43 <Lemmih> unsafeCoerce# to the rescue!
15:24:53 <goltrpoat> hehe
15:25:14 <xerox_> *O_O*
15:25:59 <goltrpoat> is type coercion generally supposed to be avoided?
15:26:10 <Pseudonym> It's called "unsafe" for a reason.
15:26:19 <goltrpoat> -nod-
15:27:49 <Lemmih> Prelude GHC.Exts> foldl (.) id [unsafeCoerce# (<10), (+5), (*6)] 0
15:27:49 <Lemmih> -Segmentation fault
15:33:15 <ihope> @index unsafeCoerce#
15:33:15 <lambdabot> bzzt
15:34:19 <ihope> unsafeCoerce# gives a parse error here.
15:34:22 <ihope> > (#)
15:34:23 <lambdabot>  Not in scope: `#'
15:34:29 <Lemmih> ihope: You need -fglasgow-exts
15:34:31 <ihope> > (>#)
15:34:31 <lambdabot>  Not in scope: `>#'
15:34:39 <Lemmih> (but really, you're better off without it)
15:34:49 <ihope> I know.
15:36:17 <ihope> Yay, boomies!
15:36:34 <Lemmih> reallyUnsafePtrEquality# and dataToTag# are also funny.
15:36:51 <ihope> What's reallyUnsafePtrEquality?
15:37:07 <ihope> And why's it reallyUnsafe, and not just unsafe? ;-)
15:37:41 <xerox_> Lemmih: what's the type of the latter?
15:38:23 <Lemmih> xerox_: a -> Int#
15:38:31 <Lemmih> Prelude GHC.Exts> I# (reallyUnsafePtrEquality# map map)
15:38:31 <Lemmih> 1
15:38:50 <ihope> What's this stuff ending in hash marks?
15:39:00 <xerox_> Ah, heh.
15:39:18 <ihope> Unboxed types?
15:39:41 <Lemmih> ihope: GHC primitives, mostly.
15:39:47 <Pseudonym> Incidentally, this is a bit safer:
15:40:24 <Pseudonym> hang on.
15:40:44 <Lemmih> *the anticipation rises*
15:41:00 <ihope> reallyUnsafePtrEquality# reallyUnsafePtrEquality# reallyUnsafePtrEquality#
15:41:10 <Pseudonym> > toEnum $ foldl (.) id [fromEnum . (<10), (+5), (*6)] 0
15:41:11 <lambdabot> Add a type signature
15:41:11 <goltrpoat> heh
15:41:13 <ihope> Aww, it no worky.
15:41:15 <Pseudonym> > toEnum $ foldl (.) id [fromEnum . (<10), (+5), (*6)] 0 :: Bool
15:41:16 <lambdabot> True
15:41:24 <Pseudonym> > toEnum $ foldl (.) id [fromEnum . (<10), (+5), (*6)] 1 :: Bool
15:41:25 <lambdabot> False
15:41:32 <goltrpoat> oh, makes sense
15:41:33 <Pseudonym> But it only works in this case because you happen to be working with ints.
15:41:36 <goltrpoat> yeah
15:42:23 <ihope> Type @djinn! Type @djinn! :-P
15:42:30 <ihope> @djinn * -> *
15:42:30 <lambdabot> Cannot parse command
15:43:13 <goltrpoat> i just had this idea that i could pass around lists of adjoint functions, that comes from an AST chain, say, and evaluate that by folding the list
15:43:23 <goltrpoat> not terribly useful, was just curious
15:43:43 <nothingmuch> shapr: ping
15:44:21 <nothingmuch> @seen shapr
15:44:22 <lambdabot> shapr is in #ScannedInAvian and #haskell. Last spoke 4 hours, 54 minutes
15:44:22 <lambdabot> and 2 seconds ago.
15:45:09 <ihope> @seen ihope
15:45:10 <lambdabot> You are in #haskell. Last spoke just now.
15:45:15 <ihope> @seen lambdabot
15:45:16 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-
15:45:16 <lambdabot> haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
15:47:19 <ihope> What
15:47:24 <ihope> s #flippi?
15:48:39 <sjanssen> is there some kind of garbage collected pointer I can use?
15:48:54 <ihope> What are pointers?
15:49:25 <sjanssen> ihope: we'll tell you about pointers when you're older ;)
15:49:39 <ihope> Oof.
15:50:08 <ihope> Is that the kind of stuff they talk about in #haskell-blah?
15:50:11 <sjanssen> ihope: were you joking?  I hope I didn't just come off as a jerk
15:50:52 <ihope> Um...
15:51:08 <ihope> No, you didn't.
15:51:42 <Cale> ihope: a pointer is a value which represents a location in memory
15:52:20 <Cale> sjanssen: For use with the FFI?
15:52:37 <ihope> And why would I want one of those? ;-)
15:52:49 <ihope> @hoogle Int# -> Int
15:52:50 <lambdabot> hoogle: Unexpected character when parsing: > -> Int
15:52:50 <lambdabot>  
15:53:31 <Lemmih> I# :: Int# -> Int
15:53:39 <ihope> Thanks
15:55:25 <sjanssen> Cale: yes, for FFI
15:58:52 <Cale> well, Ptrs get garbage collected normally. There are ForeignPtrs which are able to run finalisers when they're GC'd
15:59:06 <Cale> (I'm still not exactly sure what it is that you're after :)
16:00:28 <sjanssen> I get it now, I just thought Ptr was a plain old C style pointer
16:00:41 <Cale> StablePtrs are the ones where the values they point to aren't affected by garbage collection
16:01:58 <Cale> (which makes it safe to pass them to C functions which will use them, even if the Haskell code otherwise wouldn't)
16:07:26 <BillWatkins> hey all
16:17:18 <BillWatkins> 00anyone fanct
16:17:29 <BillWatkins> 00anyone fancy helping a haskell newbie :/
16:17:52 <Excedrin> probably, just ask... and please turn off bold text
16:18:36 <BillWatkins> 00apologies, Im using some crubbish irc lcient, is this better?
16:18:39 <BillWatkins> 00ah meats
16:18:45 <BillWatkins> 00brb
16:19:26 <Pseudonym> \
16:19:37 <Pseudonym> Errr.
16:20:40 <Pseudonym> All better now?
16:20:48 <BillWatkins> hopefully
16:21:45 <mathrick> interesting, I didn't see any bold text the first time around
16:21:53 <mathrick> only after you attempted to turn it of
16:21:55 <mathrick> f
16:22:03 <BillWatkins> if anybody has 5 minutes, I'm writing something which, in an impure language, i'd use a variable, do I have to go the Monad route?
16:22:04 <Pseudonym> Me too.
16:22:14 <BillWatkins> that's what I thought :/
16:22:16 <Pseudonym> You don't have to.
16:22:19 <BillWatkins> never mind
16:22:30 <Pseudonym> Sorry, the "me too" was about the bold text.
16:22:33 <Pseudonym> :-)
16:22:41 <BillWatkins> yeah I figured
16:22:46 <Pseudonym> No, you don't HAVE to go the monad route.
16:22:46 <BillWatkins> :)
16:22:51 <mathrick> Pseudonym: "me either" would be probably clearer :)
16:23:01 <mathrick> BillWatkins: what do you want to do?
16:23:13 <Pseudonym> And what have you got so far?
16:23:16 * mathrick is still starting himself, but shhh
16:24:53 <Pseudonym> There are only two times when you "have" to use monads.
16:24:56 <Pseudonym> 1. IO
16:25:03 <Pseudonym> 2. Using a library that needs monads.
16:25:11 <Pseudonym> Any other time, it's just syntactic sugar.
16:25:45 <BillWatkins> it's hard to describe
16:26:19 <Pseudonym> Start at the beginning. :-)
16:26:29 <Pseudonym> Use imperative pseudocode if you have to.
16:28:00 <BillWatkins> ok well I'm creating a game that's kind of like minesweeper
16:28:23 <BillWatkins> without any graphical interface or anything like that
16:28:46 <frederik> i've decided that the notation of probability theory is a monad. it's very much like do-notation. in fact, the monad is a reader-monad. is this known?
16:29:00 <Heffalump> how is it a reader monad?
16:29:11 <Pseudonym> There's more than one notation for probability theory.
16:29:53 <frederik> the domain is the base probability space of the random variables
16:29:59 <frederik> the domain of the reader monad, that is
16:30:16 <Heffalump> oh, I see.
16:30:30 <frederik> so X ~ N(\mu,\sigma^2) is like do { x <- normal ...; ... }
16:31:24 <frederik> the one thing that the mathematicians are lacking is a "return" notation, or something to encapsulate a formula involving random variables and turn it back into a distribution
16:32:04 <frederik> e.g. Z ~ [ X ~ Beta(...); Y ~ N(...); return X+Y ]
16:32:58 <frederik> (my advisor will never understand monads :( that's why i have to come here)
16:34:44 <BillWatkins> well in this game, I have a world state, kind of like the grid in minesweeper, and to move takes the parameters of the numeric position and the grid itself
16:34:49 <frederik> ... (not that you guys are shedding a whole lot of light on the idea ;)  )
16:35:05 <ihope> I tried to do a probability monad once.
16:35:20 <frederik> i did an exact inference monad
16:35:49 <ihope> It's essentially the list monad, but with a "probability" value added to each value.
16:35:49 <frederik> http://ofb.net/~frederik/futility/src/NB.hs
16:36:08 <frederik> oh right
16:36:20 <BillWatkins> and the grid changes with each move placed, however, it is mighty unwieldy to have the current grid as a parameter, but other than some sort of start monad I am unsure of how to deal with it.
16:36:52 <ihope> Well, there's the State monad, located at Control.Monad.State.
16:36:58 <BillWatkins> start = state
16:37:26 <dons> moin
16:37:30 <frederik> ihope: i was going to do a stochastic parser with the list thing. but i decided that the resulting algorithm would be too slow.
16:37:47 <frederik> ihope: did you use it for anything?
16:37:58 <Pseudonym> http://bayes.wustl.edu/
16:37:58 <ihope> Nope.
16:38:08 <Pseudonym> Take a look, if you think you know probability theory. :-)
16:39:58 <Pseudonym> Probability isn't a monad, I _believe_, because it interprets its contained types.
16:40:06 <Pseudonym> There's no "Probability a" for all a.
16:40:17 <Pseudonym> At the very least, a must be Eq, I'm pretty sure.
16:40:40 <Pseudonym> For "normal", a must be RealFrac or something.
16:40:52 <tony2> chaps, quick question, why is it ok to use unsafePerformIO to allocate a global mutable variable? (given that haskell compilers don't memoise results)
16:40:54 <Heffalump> that just means you can't make a Monad instance, not that it isn't a monad in the more general sense.
16:40:55 <tony2>  i.e why doesn't it create a new variable each time and mess everything up?
16:41:33 <tony2> (sorry to be quite so off topic)
16:41:41 <Pseudonym> That's actually MORE on-topic.
16:41:42 <Pseudonym> :-)
16:41:42 <frederik> Pseudonym: i think that you probably don't understand what i just said, or don't understand the standard measure-theoretic development of probability theory? it's quite simple
16:42:03 <Pseudonym> frederik: Keep explaining, I'll just answer tony's question. :-)
16:42:19 <Pseudonym> tony2: It's because GHC happens to be fully lazy, even though it doesn't have to be.
16:42:31 <frederik> Pseudonym: i don't have much more to explain. i'm not sure what isn't understood
16:42:34 <Pseudonym> The function which creates a globral variable is a CAF.
16:42:42 <Pseudonym> And it's top-level, and let-floated.
16:42:48 <tony2> cool I see.
16:43:08 <Pseudonym> Fully lazy evaluation ensures that it's evalutted at most once.
16:43:22 <Pseudonym> And thanks to NOINLINE, the same CAF is used.
16:43:45 <Pseudonym> frederik, I understand that probability theory is a calculus.
16:43:54 <Pseudonym> I don't believe it's a monad.
16:43:58 <frederik> a calculus?
16:44:01 <frederik> what's a calculus?
16:44:01 <Pseudonym> Sure.
16:44:09 <Pseudonym> @dict calculus
16:44:09 <lambdabot> Supported dictionary-lookup commands:
16:44:09 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @
16:44:09 <lambdabot> jargon @lojban @vera @web1913 @wn @world02
16:44:09 <lambdabot> Use "@dict-help [cmd...]" for more.
16:44:17 <Pseudonym> Hmmm.
16:44:20 <Pseudonym> @wn calculus
16:44:22 <lambdabot> *** "calculus" wn "WordNet (r) 2.0"
16:44:22 <lambdabot> calculus
16:44:22 <lambdabot>   n 1: a hard lump produced by the concretion of mineral salts;
16:44:22 <lambdabot>     found in hollow organs or ducts of the body; "renal
16:44:22 <lambdabot>     calculi can be very painful" [syn: {concretion}]
16:44:24 <lambdabot> [6 @more lines]
16:44:27 <frederik> hehe
16:44:32 <frederik> i've gotta get back to studying
16:44:33 <Pseudonym> Any questions? :-)
16:44:34 <Pseudonym> @more
16:44:34 <lambdabot>   2: an incrustation that forms on the teeth and gums [syn: {tartar},
16:44:34 <lambdabot>    {tophus}]
16:44:34 <lambdabot>   3: the branch of mathematics that is concerned with limits and
16:44:34 <lambdabot>    with the differentiation and integration of functions
16:44:34 <lambdabot>    [syn: {the calculus}, {infinitesimal calculus}]
16:44:36 <lambdabot>   [also: {calculi} (pl)]
16:44:44 <Pseudonym> @wn calculi
16:44:46 <lambdabot> *** "calculi" wn "WordNet (r) 2.0"
16:44:46 <lambdabot> calculi
16:44:46 <lambdabot>   See {calculus}
16:44:46 <lambdabot>  
16:44:46 <lambdabot> *** "calculi" wn "WordNet (r) 2.0"
16:44:48 <lambdabot> [10 @more lines]
16:44:49 <frederik> i'm talking about the syntax, not the semantics
16:44:51 <Pseudonym> Great.
16:44:54 <frederik> if that's what you mean
16:45:01 <frederik> anyway later
16:45:11 <Pseudonym> Calculus as in formal manipulation system.
16:45:36 <Pseudonym> I don't think it's a monad for the same reason that propositional logic isn't a monad.
16:45:42 <Pseudonym> Anyway.
16:45:52 <Pseudonym> Yes, go study.
16:46:01 <carp> i think it is just a pretentiou name for a theory
16:46:06 <ihope> What is propositional logic?
16:46:06 <carp> s
16:46:17 <ihope> @djinn a -> Not (Not a)
16:46:17 <lambdabot> f a b = b a
16:46:38 <Pseudonym> Nah, it's a specific kind of theory.
16:46:42 <carp> ihope: it's a calculus ;)
16:47:01 <ihope> @djinn Not (Not a) -> (a -> Not (Not b)) -> Not (Not b)
16:47:01 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
16:47:50 <Pseudonym> Ah, here we are.
16:48:03 <Pseudonym> Mathworld defines a calculus as "an abstract theory developed in a purely formal way".
16:48:12 <Pseudonym> That sounds pretty comrpehensive to me.
16:48:33 <Pseudonym> So, for example, Euclidean geometry is a theory.
16:48:39 <ihope> Is Haskell a calculus?
16:48:51 <Pseudonym> Is it a theory?
16:49:16 <Pseudonym> But the various axiomatisations of Euclidean geometry are calculi.
16:49:47 <goltrpoat> i'd say it's a particular symbolic notation, coupled with a particular methodology that operates within that notation
16:51:20 <Cale> A calculus is a way of calculating something. Like, the differential calculus is a means for computing derivatives.
16:51:28 <BillWatkins> talk about over my head D;
16:51:32 <goltrpoat> or, equivalently, coupled with particular theory.  i think the mathworld definition means "methodology" by theory, not "proposition".
16:51:54 <ihope> > foo {bar ->- baz} qux
16:51:54 <lambdabot>  parse error on input `->-'
16:51:56 <Pseudonym> Cale: I think that's anot quite true.
16:52:01 <ihope> > foo {Bar ->- baz} qux
16:52:01 <lambdabot>  parse error on input `Bar'
16:52:22 <frederik> Pseudonym: Heffalump understood. i think you just don't understand what i said, and you're not asking questions about the things that you don't understand... i'm quite sure that the connection i drew is valid.
16:52:25 <Pseudonym> The calculus (i.e. infinitessimal calculus) is a method for formally manipulating infinitessimals.
16:52:31 <Cale> well, that's the original sense of the word
16:52:57 <Cale> now we just say 'Calculus' to refer to that entire body of work
16:53:09 <Cale> including many theorems which have nothing to do with the calculation directly
16:53:10 <Pseudonym> frederik: Quite possibly.  I understand that a lot of probability theory looks like ZF notation.
16:53:14 <goltrpoat> and lambda calculus is a method for formally manipulating function application
16:53:15 <carp> i think you are free to call a formal system such as a logic or a type system a calculus but clearly it has a wider meaning
16:53:31 <Pseudonym> And there's a strong link between ZF notation and monads, via list comprehensions.
16:54:08 <Pseudonym> But I'm not certain that the resemblance is more than skin-deep, if you know what I mean.
16:54:30 <Cale> ZF notation as in ZF set theory?
16:54:40 <Pseudonym> Yeah.
16:54:49 <ihope> Set comprehensions?
16:55:07 <Pseudonym> In fact, Turner originally called list comprehensions "ZF expressions".
16:55:15 <Cale> Well, apart from Set being a category and the powerset functor being a monad...
16:55:35 <Cale> yeah, that would probably just be resemblance
16:55:45 <Cale> comprehensions are older than ZF anyway
16:55:52 <Pseudonym> Absolutely.
16:55:57 <Pseudonym> But I think they formalised it first,.
16:55:57 <ihope> [ x | not (x `elem` x) ] `elem` [ x | not (x `elem` x) ]
16:56:17 * Pseudonym might be wrong about that
16:56:19 <Cale> Whitehead and Russel did, I think
16:56:36 <ihope> > [ 3 | ]
16:56:37 <lambdabot>  parse error on input `]'
16:56:52 <ihope> > [3 | 3 /= 2]
16:56:52 <lambdabot> [3]
16:56:57 <ihope> Yay!
16:57:05 <Cale> and before that, there were some failed attempts
16:57:05 <Pseudonym> I read a brilliant paper by David Hestenes once where he used probability calculus to decompose the Dirac equation.
16:57:28 <ihope> > [x,y | (x,y) <- [(1,2),(3,4),(5,6)]]
16:57:28 <lambdabot>  parse error on input `|'
16:57:31 <ihope> Aww.
16:57:37 <Pseudonym> He split it into a geometric part (using geometric calculus, based on geometric algebra) and a probability part.
16:58:02 <Cale> Frege tried
16:58:12 <Cale> (to formalise set theory)
16:58:26 <Cale> but his system fell prey to Russel's paradox
16:58:46 <Cale> (Russel was reading Frege's work when he found it)
16:59:07 <Cale> It allowed unbounded comprehensions
17:00:30 <Cale> oh, perhaps it was Zermelo who introduced bounded comprehensions as a means of solving the problem
17:00:53 <Cale> Russel solved it by adding a theory of types to the system
17:00:59 <Pseudonym> Could also have been Goedel, von Neumann and Bernays.
17:01:12 <Cale> I'm pretty sure they come after ZF
17:01:48 <Cale> ah, and Russel and Whitehead used that type system together as well
17:02:02 <Pseudonym> Right.
17:03:28 <Cale> That was around 1903, and in 1908, you have Zermelo putting things in terms of a similarly restricted comprehension without the weight of the type theory.
17:04:54 <Cale> I suppose NBG is a bit of a cross of the two, having a very simple type system with only two types in it.
17:05:47 <Cale> von Neumann started it in the 1920's and it was modified by Bernays in 1937 and then by Goedel in 1940.
17:09:55 <BillWatkins> In a minesweeper-esque game, which has a world-state like a grid, is it possible to have a move function that does not take in the grid, so that the grid can be built up over time?
17:10:04 <BillWatkins> without the use of state monads :/
17:11:03 <BillWatkins> I could pass the current grid as an argument easily, but that would be unwieldy to use
17:11:33 <BillWatkins> without the argument it seems hard to do, as the next go would require the latest grid
17:12:03 <Pseudonym> What does the "move" function do?
17:12:10 <Pseudonym> It modifies the grid, doesn't it?
17:12:16 <BillWatkins> yep
17:12:26 <BillWatkins> well returns a modified grid
17:12:42 <Pseudonym> So how can you not pass it a grid?
17:12:54 <BillWatkins> I could
17:12:58 <BillWatkins> but it's a big grid
17:13:02 <Pseudonym> So?
17:13:07 <BillWatkins> and typing all that is tough for the user
17:13:10 <Pseudonym> It's not like it gets copied.
17:13:22 <Pseudonym> How are you representing the grid?
17:14:02 <BillWatkins> as [[row1],[row2]..
17:14:28 <Pseudonym> Have you considered a tree, like a quadtree?
17:15:00 <Cale> @join #meta-science
17:15:31 <BillWatkins> not really, I don't really know what they are :)
17:16:50 <BillWatkins> basically, the user puts in their move on the empty grid, the computer modifies the grid and sends it back, then I want the next users move to relate to the most recent grid
17:16:56 <BillWatkins> it'd be easy in java :)
17:19:04 <Pseudonym> Oh, hang on.
17:19:20 <Pseudonym> You want to modify the grid in-place.
17:19:34 <Pseudonym> Well, you could actually do that in Haskell.  It does have mutable arrays.
17:19:38 <Pseudonym> But it would require using a monad.
17:20:36 <BillWatkins> I see
17:20:44 <SimonRC> What were "dialogues"?  (The IO things.)
17:21:10 <SimonRC> BillWatkins: the ST monad, or IO if you can;t be bothered to look that up
17:21:38 <Pseudonym> But either way, you could still use a list-of-lists or tree.
17:21:44 <SimonRC> But a pure ST action can be wrapped up to make it look pure on the outside.
17:21:47 <Pseudonym> I actually don't see what the difficulty is:
17:21:52 <Pseudonym> move :: Move -> Grid -> Grid
17:21:56 <Pseudonym> Let's say.
17:22:12 <Pseudonym> So assuming you're using IO to get the user's move:
17:22:17 <BillWatkins> yeah
17:22:33 <Pseudonym> mainLoop grid
17:22:35 <Pseudonym>   = do
17:22:41 <Pseudonym>     m <- getUsersMove
17:22:50 <Pseudonym>     mainLoop (move m grid)
17:22:56 <Pseudonym> ?
17:23:07 <SimonRC> yeah, tail recursion
17:23:27 <dons> or do you just want a global variable?
17:24:06 <BillWatkins> hmm
17:24:26 <BillWatkins> that seems to make sense, but I'm sure i've messed about with stuff like that
17:24:34 <BillWatkins> I don't really want to use anything mutable
17:25:39 <BillWatkins> for that mainloop the only time the user would have to enter a grid would be initially correct?
17:25:55 <BillWatkins> as in mainloop blank
17:26:56 <dons> and then you just thread the loop around yourself as Pseudonym's code suggests. quite clean
17:27:17 <BillWatkins> yeah, that sounds pretty good
17:27:23 <Pseudonym> The user supplies the initial grid in your code?
17:27:48 <BillWatkins> well "blank" is a constant 'variable'
17:27:59 <BillWatkins> referring to a pre-constructed blank grid
17:28:14 <Pseudonym> In real-life minesweeper, you generally construct grids randomly.
17:28:51 <Lemmih> Really?!
17:28:52 <SimonRC> Haskell would be far better at constructing a minesweeper-playing bot.
17:30:29 <SimonRC> BTW, did you know that deciding if the numbers you can see in a potential minesweeper position actually have any solutions is NP-complete?
17:31:43 <SimonRC> There is a way to carry the chains of "Is-a-mine, isn't-a-mine, is-a-mine,..." around to make arbitrary arrrangements of logic gates, to satisfaction of which is NP-complete.
17:32:27 <Pseudonym> Solving minesweeper itself is an integer linear programming problem.
17:32:49 <SimonRC> Basically, yeah, I think.
17:33:23 <Pseudonym> 8-SAT is directly reducible to it, I think.
17:33:41 <Pseudonym> Something like that, anyway.
17:34:28 <BillWatkins> is there a getInt in IO()? or is it getLine and parse it to an int?
17:34:37 <Pseudonym> Yeah, that.
17:34:47 <Pseudonym> However...
17:34:52 <Pseudonym> > read "1" :: Int
17:34:53 <lambdabot> 1
17:35:13 <Pseudonym> Bye.
17:35:15 <adu> hello?
17:35:18 <Lemmih> @type readLn
17:35:19 <lambdabot> forall a. (Read a) => IO a
17:35:28 <SimonRC> adu: hi
17:35:31 <adu> hi
17:35:40 <Pseudonym> Ah, good point.
17:35:44 * Pseudonym forgot about readLn
17:35:47 <adu> i'm trying to learn Haskell
17:36:10 <BillWatkins> heh
17:36:16 <Lemmih> Hi again, BillWatkins.
17:36:38 <BillWatkins> hey
17:37:23 <ihope> > show oegiweaf
17:37:24 <lambdabot>  Not in scope: `oegiweaf'
17:37:35 <ihope> @index RealWorld
17:37:36 <lambdabot> Control.Monad.ST, Control.Monad.ST.Lazy, Control.Monad.ST.Strict
17:37:39 <ihope> Whoa.
17:38:47 <ihope> @hoogle IO RealWorld
17:38:48 <lambdabot> System.Exit.exitFailure :: IO a
17:38:53 <ihope> ...
17:39:21 <ihope> @hoogle IO a -> ST RealWorld a
17:39:22 <lambdabot> Control.Monad.ST.Lazy.unsafeIOToST :: IO a -> ST s a
17:39:22 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
17:39:26 <ihope> Wow!
17:39:46 <adu> @type ST
17:39:47 <lambdabot> Not in scope: data constructor `ST'
17:39:58 <ihope> @kind Control.Monad.ST.ST
17:39:59 <lambdabot> * -> * -> *
17:40:25 <ihope> ST is a type constructor, not a value.
17:40:26 <adu> @type Control.Monad.ST.ST
17:40:27 <lambdabot> Not in scope: data constructor `Control.Monad.ST.ST'
17:40:37 <SimonRC> instance Monad (ST a) ...
17:40:45 <ihope> @info
17:40:46 <lambdabot> Unknown command, try @listcommands.
17:40:49 <ihope> Bsh.
17:40:52 <ihope> s/s/a/
17:41:14 <SimonRC> erm, Control.Monad.ST.ST is a type constructor, not a data constructor.
17:41:46 <Pseudonym> Lunch.
17:41:46 <adu> ok
17:41:48 <Pseudonym> BBL
17:42:02 <adu> @kind IO
17:42:03 <lambdabot> * -> *
17:46:14 <adu> whats the difference between join and (++) ?
17:46:24 <ihope> For lists, join = concat.
17:46:26 <Cale> join and concat do the same thing in the list monad
17:46:32 <Cale> but join is more general
17:46:37 <ihope> > Control.Monad.join [[1,2,3],[4,5,6],[7,8,9]]
17:46:38 <lambdabot> [1,2,3,4,5,6,7,8,9]
17:46:44 <adu> does (++) == concat?
17:46:47 <ihope> > [1,2,3] ++ [4,5,6] ++ [7,8,9]
17:46:48 <lambdabot> [1,2,3,4,5,6,7,8,9]
17:46:49 <Cale> no
17:47:05 <Cale> concat = foldr (++) []
17:47:11 <ihope> > concat [[1,2,3],[4,5,6],[7,8,9]]
17:47:12 <lambdabot> [1,2,3,4,5,6,7,8,9]
17:49:39 <dcoutts> vincenz, jethr0, http://haskell.org/gtk2hs/archives/2006/03/09/cops-and-robbers/
17:50:13 <dcoutts> thanks v. much for the screenshots and description!
17:50:43 <wolverian> cairo but no antialiasing? 
17:51:24 <dcoutts> is there not?
17:51:44 * dcoutts looks closely
17:51:47 <wolverian> none that I see
17:52:09 * dcoutts thought it was rathe hard to turn off antialiasing when using cairo
17:52:20 <wolverian> I have that impression as well :)
17:52:41 <dcoutts> well we can ask vincenz and jethr0 when he's here
17:52:52 <wolverian> it's a small matter, anyway. just curious
17:52:54 <dcoutts> jethr0 said it was all drawn with cairo
17:53:07 <wolverian> (as I've never seen non-antialiased cairo graphics)
17:53:13 * dcoutts too
17:54:10 <wolverian> you know what sucks? noticing two days too late that your order from another country is being shipped to the wrong address
17:54:23 <wolverian> I'll go hit my head against the wall until I fall asleep. cheers :)
17:54:31 <dcoutts> poor wolverian 
18:00:14 <newsham_> hwo do I use FFI to dynamically load a function from a DLL?
18:03:21 <Cale> wolverian: how wrong is the address?
18:03:54 <Cale> newsham_: maybe use hs-plugins?
18:03:55 <dcoutts> newsham_, what are you after exactly?
18:04:18 <Cale> the FFI is mostly for static binding
18:04:53 <Cale> is this on Windows?
18:04:56 <newsham_> playing with ffi
18:05:07 <newsham_> yes, win32.
18:05:10 <newsham_> (and hc0
18:05:15 <newsham_> ghc
18:05:23 <dcoutts> so you want to load up a named .dll and import a named function ?
18:05:35 <dcoutts> and choose the .dll at runtime
18:05:58 <newsham_> i dont need to choose the dll at runtime, but it seems like its more flexible, since then i wont necessarily have to have a .lib
18:06:14 <dcoutts> you don't need a .lib anyway I think
18:06:14 <Cale> maybe write an FFI binding to LoadLibrary and related calls?
18:06:34 <dcoutts> if you don't need to choose the .dll at runtime then don't 
18:06:41 <dcoutts> it's much easier to do statically
18:06:48 <newsham_> btw, when I   ghc -fffi foo.lhs bar.lib  I get some undefined references
18:07:03 <dcoutts> otherwise yes you need LoadLibrary and GetProcAddress (or whatever it's called)
18:07:06 <newsham_> :fake: undefined reference to `Foo_d1UL@8'
18:07:17 <newsham_> c:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x1d):Main.c: undefined reference to `
18:07:17 <newsham_> __stginit_ZCMain'
18:07:25 <wolverian> Cale, wrong city, but right street address.
18:07:28 <Cale> do you have a main function?
18:07:38 <Cale> er, IO action :)
18:07:42 <newsham_> yup.. main :: IO ()
18:07:49 <ncalexan> That looks more like it's missing the Main module.
18:07:51 <Cale> wolverian: ugh, that would be a good deal of driving then
18:07:52 <dcoutts> newsham_, you specify "-lbar" rather that "bar.lib" I think
18:08:15 <newsham_> its a win32 .lib, nto a libfoo.a
18:08:16 <Cale> yeah, that's possible too
18:08:35 <ncalexan> Although if it's Main.c, that's not a GHC issue, per se.
18:09:08 <newsham_> i get less errors with foo.lib than with -lfoo
18:10:22 <newsham_> hmm.. I get the same error even for a simple non-ffi example.. maybe my install is busted
18:10:36 <newsham_> ghc foo.lhs    <- do I need any libs for the normal calse?
18:10:38 <newsham_> case
18:11:18 <newsham_> works fine in ghci.
18:11:54 <Cale> newsham_: what are the first few lines in foo.hs?
18:12:05 <Cale> you need the module name to be Main
18:12:23 <Cale> and it has to have a main :: IO a (for some specific a, usually ())
18:12:23 <newsham_> module Foo where
18:12:23 <newsham_> main :: IO ()
18:12:24 <newsham_> main = print "hello world!"
18:12:28 <Cale> aha
18:12:32 <Cale> module Main where
18:13:05 <newsham_> ah.. thanks
18:13:42 <Cale> argh, I can never keep up with my email... too many mailing lists!
18:13:44 <newsham_> that fixed it right up...
18:14:01 <newsham_> seems i need the .lib though.. cant link against the .dll
18:16:10 <newsham_> weird.  if I compile it clean it works, but if i recompile it, it complaisn:  undefined reference to `Main_d1Vh@8'
18:16:19 <newsham_> is that because the filename isnt Main.lhs?
18:16:28 <Cale> I'm not sure
18:16:47 <Cale> but possibly it's being confused like that, yeah
18:16:49 <newsham_> nope, renamed same thing
18:16:52 <Cale> hmm
18:17:07 <BillWatkins> I love this channel thankyou!
18:17:54 <newsham_> weird..  well, a minor inconvenience at best
18:18:35 <newsham_> still, would be nicer if I could define the function interface with ffi and dynload it.
18:18:49 <newsham_> isnt that what the "dynamic" wrapper in ffi is for?
18:18:54 <ihope> @hoogle Either a String -> a
18:18:55 <lambdabot> No matches, try a more general search
18:19:01 <ihope> @hoogle Either String a -> a
18:19:02 <lambdabot> No matches, try a more general search
18:19:25 <ncalexan> @type Data.Either.either
18:19:26 <lambdabot> forall c b a.
18:19:26 <lambdabot>         (a -> c) -> (b -> c) -> Either a b -> c
18:19:52 <ncalexan> \e -> either id (const "")
18:20:01 <ncalexan> Better yet, drop the \ :)
18:22:27 <newsham_> (also would be ncie being able to use dll in ghci)
18:23:27 <ihope> ncalexan: {Left ->- id; Right ->- error}. It's some syntactic sugar I threw onto the mailing list.
18:23:39 <ihope> either id error, that is.
18:26:29 <newsham_> looks like the -l option is supposed to support this in ghci, but it doesnt seem tow ork with .dll's or .lib's
18:26:36 <newsham_> i'll chalk that up to platform support :\
18:27:51 <ncalexan> What does 'doesn't seem to work' mean?
18:28:06 <newsham_> Warning: ignoring unrecognised input 'foo.dll'
18:28:13 <newsham_> Loading object (dynamic)  ... failed.
18:28:14 <newsham_> Dynamic linker error message was:
18:28:14 <newsham_>    addDLL: unknown error
18:28:14 <newsham_> Whilst trying to load:  (dynamic)
18:28:34 <ncalexan> That's fairly non-working :)
18:28:50 <newsham_> yah, I didnt think it was too bold a statemen t:)
18:29:26 <ncalexan> Not-work takes many form, I was thinking I might help with a particular one.  Not with that one, thouhg.
18:31:55 <Cale> I get the impression that the user base for GHC is more unix users than windows users. At least, the vocal user base is like that.
18:32:24 <Cale> we have a few windows users here, but not too many compared to all the people using various flavours of unix :)
18:32:52 <newsham_> *nod*  i'm a unix one too, just that this is for a win32 dll :)
18:35:05 <tnks> Hi.  I was wondering if it was at all possible to serialize (save to disk) lambda expressions.  I know other types can be derived from Show and Read, but I'm not sure about arbitrary functions.
18:35:13 <newsham_> is there an easy way to build aggregate storables?
18:37:43 <ncalexan> tnks: in general, not really.  There might be a way using hs-plugins.
18:37:59 <ncalexan> But it wouldn't be storing the function so much as a Haskell representation of the function.
18:38:17 <ncalexan> Cale: does that square with your understanding?
18:38:55 <Cale> ncalexan: basically
18:39:05 <musasabi> newsham_: template haskell
18:39:22 <musasabi> or drift.
18:39:24 <newsham_> I said "easy" :)
18:39:25 <ncalexan> It's requested so often, someone should just code up what's possible, with all the usual caveats.
18:39:26 <Cale> if you want to store lambda terms, you have to create your own data structure for them
18:39:48 <Cale> I think it would be really nice to be able to take any haskell value and serialise it in its current state of evaluation.
18:40:04 <ncalexan> tnks: what would a string rep of a function look like that?
18:40:05 <Cale> of course, it would be system-dependent
18:40:51 <musasabi> well many other languages manage to do that.
18:40:52 <ncalexan> VMs like Squeak and smalltalk support that... they just snapshot the entire memory and filesystem and reload that.
18:41:23 <tnks> yeah.  It seems possible, but I don't have the intuition of the best way to go about it.
18:41:55 <Cale> tnks: well, it's possible if you're willing to hack on a haskell compiler. It's not possible in any current implementation.
18:42:03 <musasabi> the real problem is lambdas
18:42:11 <tnks> musasabi: right.
18:42:20 <musasabi> in particular lambdas which may not exist in future versions of a program.
18:42:55 <Cale> well, they're just closures
18:43:11 <Cale> the hard part is figuring out where your program stops and the standard library starts
18:43:39 <tnks> I think it would be easier for me to reason about if I knew more about the Haskell compiler.
18:43:46 <Cale> you're essentially de-linking a part of the program
18:43:55 <tnks> I don't know how it computes higher-order functions.
18:45:28 <Cale> well, every value is actually a reference to code
18:46:08 <Cale> initially, values are represented by references to code which computes them and returns them
18:46:37 <Cale> but after they've been computed, that reference is overwritten with one which points to some code to return the value directly
18:46:51 <Cale> at least, that's one way to do it
18:47:05 <tnks> Cale interesting.
18:47:27 <tnks> I wonder what GHC's implmentation's like.
18:47:35 <Cale> that's similar to GHC's implementation
18:47:59 <Cale> you can read about it in a less-butchered form in the STG-machine paper
18:48:34 <Cale> @google spineless tagless g machine
18:48:37 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
18:49:42 <tnks> cool.
18:49:43 <tnks> thanks.
18:51:58 <newsham_> working on haskell for a decade?  thats a lot of dedication
18:52:29 <Cale> longer now
18:53:16 <Cale> The first version of the Haskell standard is from 1990
18:53:49 <Cale> I suspect there were implementations before that
18:53:58 <ncalexan> gofer?
18:54:02 <Cale> yeah
18:59:45 <newsham_> there's no Storable implementation for tuples, is there?
19:00:23 <Cale> right
19:02:40 <dons> re
19:02:51 <Cale> wb
19:04:48 <dons> @quote
19:04:48 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
19:04:51 <dons> still working. good
19:06:10 <Cale> @quote
19:06:10 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty
19:06:10 <lambdabot> of Template Haskell
19:06:16 <Cale> @quote
19:06:16 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from
19:06:16 <lambdabot> England just to kill me if I did that
19:06:43 <dons> so fingers crossed on not running out of randoms anymore :}
19:06:48 <ncalexan> @quote
19:06:49 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write,
19:06:49 <lambdabot> it should be hard to understand
19:06:50 <Cale> does anyone remember exactly what it was that he suggested doing?
19:07:22 <newsham_> anyone have an example of constructing a Storable thats an aggregate of several storables?
19:07:30 <newsham_> i'm not completely getting it
19:08:02 <Cale> well, you write an instance
19:08:23 <dons> recursion is your friend :)
19:08:27 <dons> sort of
19:08:28 <newsham_> i have an instance, all the elements are Storables, somehow i need to make a peek and poke function
19:08:30 <Cale> where for poke, you're going to have to add to the pointer, and write each of the components
19:08:36 <lispy> recursion is recursion
19:08:53 <lispy> > let recursion = recursion in recursion
19:08:53 <lambdabot> Add a type signature
19:08:54 <newsham_> so basically I cast the pointer and add to it and then recurse?
19:09:03 <Cale> yeah, probably
19:09:05 <lispy> > let recursion = recursion in recursion :: a
19:09:06 <lambdabot> Add a type signature
19:09:18 <dons> type 'a' -- that's not going to fly, lispy :[
19:09:26 <dons> oh, not a vampire, I meant :p
19:09:37 <dons> use the unit type
19:09:47 <dons>  > let recursion = recursion in recursion :: ()
19:09:48 <lispy> > let recursion = recursion in recursion :: ()
19:09:49 <lambdabot> Terminated
19:09:58 <dons> good bot
19:10:01 <lispy> hehe
19:10:07 <Cale> @type let recursion = recursion in recursion
19:10:07 <lambdabot> forall t. t
19:10:14 <lispy> > let f x = f x in f 1
19:10:15 <lambdabot> Add a type signature
19:10:23 <dons> needs to be Show'able to run in lambdabot though
19:10:27 <lispy> > let f x = f x in f 1 ::()
19:10:31 <lambdabot> Terminated
19:10:45 <lispy> how do you get lambdabot to print <<loop>>
19:11:06 <dons> well, it used to be a little black hole thingy, but since 6.4.1, ghc no longer prints this message
19:11:10 <dons> int-e spotted it recently
19:11:19 <dons> now it just prints Terminated for all cases
19:11:19 <lispy> aww...
19:11:23 <dons> sad, I know
19:11:31 <dons> maybe ghc HQ doesn't even know this has changed.
19:11:45 <lispy> that makes them sound really disorganized :)
19:11:58 <dons> Prelude> let f = f in f :: ()
19:11:58 <dons> *** Exception: <<loop>>
19:12:03 <dons> ghc 6.2.2
19:12:16 * lispy cheers
19:12:19 <dons> doesn't terminate in 6.4.1
19:13:15 <lispy> interesting
19:13:31 <lispy> maybe people like to be able to code up infinite loops sometimes
19:15:28 <newsham_> cool, that was suprisingly easy (thankfully plusPtr does addition and a cast)
19:15:39 <newsham_> >   poke p x = do
19:15:39 <newsham_> >       poke (p `plusPtr` 0) (m_name x)
19:15:39 <lambdabot>  parse error on input `='
19:15:39 <lambdabot>  Not in scope: `x'
19:15:39 <newsham_> >       poke (p `plusPtr` 4) (m_se_result x)
19:15:40 <lambdabot>  Not in scope: `x'
19:15:40 <newsham_> ...
19:15:46 <newsham_> oopos, sorry bot.
19:15:51 <dons> hmm, well you can always write non-terminating thingies, but f = f in f, not sure they tweaked that for 'usability' reasons :)
19:16:06 <lambdabot> ouch!
19:16:08 <ncalexan> newsham_: maybe use size instead of hardcoding 0 and 4?
19:16:17 <newsham_> no thanks :)
19:16:32 <dons> why not?
19:16:34 <ncalexan> That's kind of the point of using storable.
19:16:48 <newsham_> i know the size.  it wont change.  this is simple and efficient.
19:16:56 <newsham_> i understand yoru point though.
19:16:59 <ncalexan> Great thinking.
19:17:10 <newsham_> this is a one-off for quick testing :)
19:17:45 <newsham_> (besides, if i was automatically generatign marshallers, my generator would put in the statically computed sizes as constants, so I dont see what the big deal is)
19:17:45 <dons> sizeOf incurs no runtime cost, the values are compiled in..
19:18:14 <newsham_> but  sizeof (mname x) + sizeof (mse_result x) + sizeof + ...
19:18:22 <newsham_> is considerably painful
19:18:34 <ncalexan> That looks a lot like a monadic map accum.
19:18:37 <eivuokko> Rather, poke and plusPtr should be encapsulated in a function that is easy to combine iwht itseilf.
19:18:50 <newsham_> yah, and I dont want it to do an accum at runtime :)
19:19:23 <newsham_> fixed size structs.. static offsets.
19:21:40 <lispy> do you guys feel like you have 1,000,000 things you want to be doing but only enough time to actualy do like 3?
19:21:50 <ncalexan> Always.
19:21:57 <newsham_> lispy: you have time to do 3 things?!@#
19:21:57 <lispy> yeah :(
19:22:11 <lispy> newsham_: work, sleep, and hang out with gf :)
19:22:23 <dons> who's writing an MUA in Haskell now?
19:22:40 <lispy> dons: exactly
19:22:53 <eivuokko> Is anyone here interested in D3D bindings?  I have lots of it done, but ran out of time - if anyone wanted to pick it up..
19:23:00 <newsham_> jsut mua?  i'm waiting for an office suite
19:23:27 <lispy> eivuokko: i prefer opengl because it's cross platform like me.  I would only be interested in learning to use it for getting a job possibly
19:24:41 <eivuokko> lispy, Ah, I meant is anyone interested to continue writing the bindings and making them representable.  They are barely usable now because installing them requires few quirky manual steps.
19:26:23 <lispy> eivuokko: it's cool, and should not be lost, but my interest in it is limited
19:26:36 <lispy> eivuokko: and i have too many other directions to run in :)
19:27:45 <lispy> eivuokko: the best i could offer is to host your darcs repo of the code
19:28:01 <eivuokko> I can host code myself.
19:28:41 * lispy still needs to read the frag paper
19:29:17 <eivuokko> Is there something special in it?
19:29:29 <lispy> dons: what experience did that student have with graphics engines prior to writing frag?  also, did she/he borrow heavily from some existing code? possible translating quake3 to haskell
19:29:41 <lispy> eivuokko: i just imagine it would be interesting
19:30:59 <lispy> i have at least 3 books to read at the moment, research to help out with, a paper to finish, and friends to maintain relationships with.   how did i get so busy?  all i ever do is sit around like a lump....
19:31:09 <lispy> like now!
19:31:11 <lispy> ;)
19:31:35 <newsham_> is there a function to get the length of a CString, or must I peekCString >>= length ?
19:32:01 <dons> @hoogle CString -> IO Int
19:32:02 <lambdabot> System.Console.Readline.getPoint :: IO Int
19:32:02 <lambdabot> System.Console.Readline.getEnd :: IO Int
19:32:02 <lambdabot> System.Console.Readline.getMark :: IO Int
19:32:11 <dons> hmm. CStringLen is better
19:32:36 <newsham_> CStringLen is a differen ttype, no?
19:32:54 <dons> it's a pair of a CString and its length
19:32:55 <Lemmih> @index lengthArray0
19:32:55 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
19:33:02 <dons> but you use lengthArray0, as Lemmih says
19:33:08 <Lemmih> @type Foreign.lengthArray0
19:33:09 <lambdabot> forall a.
19:33:09 <lambdabot>         (Eq a, Foreign.Storable.Storable a) =>
19:33:09 <lambdabot>         a -> GHC.Ptr.Ptr a -> IO Int
19:33:24 <dons> remember that CString is a Ptr a after all
19:33:50 <dons> if you're manipulating a lot of CStrings, maybe you should be using fast packed strings instead?
19:33:59 <dons> they're a whole lot safer and more fun
19:34:12 <dons> lispy, no experience, afaik
19:34:21 <dons> didn't borrow code either
19:34:31 <dons> just sat down and wrote the thing over 4 months
19:34:41 <dons> check the thesis
19:34:53 <lispy> dons: awesome
19:35:13 <dons> it's fairly short, and highly unoptimised -- haskell wasn't his native language
19:35:18 <dons> suggesting we could improve it...
19:35:21 <dons> it's gpl after all
19:35:23 <dons> and in darcs
19:35:27 <dons> yet I get no patches :/
19:35:39 <lispy> :)
19:35:44 <lispy> busy!
19:35:56 <lispy> i wish i was that productive
19:36:14 <lispy> sit down and churn it out in non-native pl with little or no prior experience
19:36:17 <dons> honours theses are strange times, remember
19:36:32 <dons> you get locked away for 12 months (at unsw anyway) and have to produce something at the end
19:36:40 <dons> so you tend to either sink or swim
19:36:51 <dons> Mun managed to learn freestyle :)
19:36:53 <lispy> heh, that's very different than the program where i went
19:38:03 <dons> it depends on the supervisor too. mine and Mun's tends to encourage hackability
19:41:35 <lispy> nice, your uni generally sounds like a good place for geeks
19:42:38 <dons> well, the CSE department is
19:42:39 <dons> a long long history of open source
19:42:39 <lispy> good
19:42:39 <dons> John Lion's was professor here, after all (the guy who published the orignal unix source code)
19:42:42 <lispy> our professors love MS but a lot of students are pro open source
19:42:42 <palomer> which uni is there?
19:42:42 <palomer> s/there/this
19:42:42 <dons> unsw, sydney
19:42:42 <eivuokko> My d3d bindings (not easily usable): http://darcs.tamelambda.net/repo/directx9/
19:42:44 <dons> the OS course is fairly famous, since you have 12 weeks to write your own :)
19:42:44 <palomer> dons: do they give funding for PhD students?
19:42:44 <dons> they fund me :)
19:42:44 <eivuokko> It really has most of boring (lew level imports and constants and structs) done.  Needs help to make it presentable! :)
19:42:44 <lispy> dons: oh man that would be fun
19:42:44 <lispy> i have this informal list of things i'd like to do still and writing an OS from scratch is one of them
19:42:44 <dons> this is the os course: http://www.cse.unsw.edu.au/~cs9242/05/
19:42:44 <lispy> we wrote a compiler for a class once, but i'd like to write another
19:42:44 <dons> you could come to unsw, you get to write 3 compilers if you pick the right courses :)
19:42:44 <eivuokko> Writing a compiler doesn't usually quench the thirst for writing them ;)
19:42:44 <dons> pick compilers, advanced compilers, and principles of programming languages.
19:42:44 <palomer> hrm, do you guys think this rule would make a type system inconsistent: ((exists A. P(A)) -> Q) -> forall A. (P(A) -> Q)
19:42:47 <lispy> palomer: i can't read it
19:43:09 <palomer> P is a formula with a free variable A
19:43:26 <palomer> exists A. P(A) means: whatever that formula is, quantify the A
19:43:34 <palomer> in fact,
19:43:55 <palomer> ((exists A. P) -> Q)-> forall A. (P -> Q) where A is not free in Q
19:44:36 <lispy> and the -> means implies?
19:44:42 <palomer> yeah
19:44:50 <palomer> the same arrow as in haskell
19:45:00 <palomer> @seen ski
19:45:00 <lambdabot> I saw ski leaving #haskell, #haskell-overflow and #haskell-blah 2 days, 2
19:45:00 <lambdabot> hours, 6 minutes and 55 seconds ago, and I have missed 31 minutes and 17
19:45:00 <lambdabot> seconds since then.
19:45:04 <palomer> @seen Cale
19:45:04 <lambdabot> Cale is in #meta-science and #haskell. Last spoke 34 minutes and 57
19:45:04 <lambdabot> seconds ago.
19:45:11 <palomer> Cale: wake up!
19:45:47 <lispy> palomer: can you prove that statement?
19:48:13 <palomer>   yes, it's metalogically provable in intuitionistic logic
19:48:22 <palomer> so I guess it won't make my type system inconsistent
19:48:45 * palomer adds it as a rule
19:48:48 <lispy> metalogically?
19:48:53 <lispy> not familiar with that one
19:49:32 <lispy> i have been thinking its time i relearn calculus tho
19:49:43 <lispy> so much math, so little time
19:50:02 <palomer> well P is a meta variable here
19:50:07 <palomer> so we really can't talk about provability
19:50:29 <palomer> we can only talk about meta provability
19:50:33 <palomer> Q is also a meta variable
19:54:17 <palomer> so, I can't give you a proof of the sequent (since it isn't a sequent), however I can sketch a proof tree which is valid, no matter what P and Q are
19:54:45 <palomer> many people don't make a distinction between variables and meta variables, and this bothers me
20:03:50 <dons> every day this week I look at the shootout, the scoring system has changed 
20:03:50 <lispy> dons: yeah, i believe the default weights are random or stored in a cookie
20:03:54 <lispy> hence their comment about april fools every day
20:04:04 <eivuokko> Cookie, I think.
20:04:10 <dons> ah, I see. yes, the default weights have all been flattened to 1
20:04:27 <dons> changing the rankings somewhat
20:04:56 <dons> Clean is much higher (since it does well on simple, lowly-ranked benchmarks, and poorly-to-zero on hard concurrency and IO benchmarks)
20:04:56 <dcoutts> @where shootout
20:04:57 <lambdabot> http://shootout.alioth.debian.org/
20:05:02 <dons> @shootout
20:05:02 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
20:05:02 <lambdabot> all
20:05:21 <dons> and we've lost a little bit by lowering the concurrency bench weights from 5 to 1
20:05:30 <dons> but yesterday the scoring system was wacked as well.
20:06:04 <dons> the cynic in me wonders whether they're trying to find a way to punish haskell somehow
20:06:21 <dons> though the approaches so far haven't messed our score much
20:06:45 <lispy> this is creepy: http://www.livescience.com/technology/060308_sandia_z.html
20:07:14 <dons> I did prefer it when the hard problems had higher weightings
20:07:43 <dons> now, a simple loop is equivalent to a n-thousand thread concurrency problem
20:08:15 <lispy> well, concurrency is a solved problem compared to simple loops
20:08:30 <dons> the new system is punishing lua in particularly
20:08:32 <dons> hmm
20:08:51 <dons> and perl is 6th worst now
20:09:01 <dons> ok, so we don't have so much to complain about ;)
20:09:22 <lispy> trust me, i'll still complain about perl :)
20:10:03 <sili_> blasphemy.
20:10:19 <Cale> palomer: hi
20:11:24 <dons> ah, we get syn hl on the new wiki!
20:11:44 <lispy> using geshi?
20:11:50 <dons> yep
20:11:57 <dons> http://haskell.org/haskellwiki/?title=HaskellWiki:Community&curid=1304&diff=2859&oldid=2848
20:12:01 <dons> ^^ changelog
20:12:41 <lispy> cool, they even based in on the one i based off the ocaml one
20:12:41 <Cale> oh sweet, with autolinking references :)
20:13:04 <lispy> yeah, geshi rocks
20:13:59 <lispy> although, i'd say comments need to be darker
20:14:09 <Cale> yeah
20:14:30 <dons> what's the difference between <pre-haskell> and <code-haskell> lispy, you know?
20:14:34 <Cale> none
20:14:40 <Cale> it says they're the same
20:15:02 <Cale> oh
20:15:09 <Cale> no I misread that
20:15:13 <lispy> dons: on my wiki i only have <haskell>
20:15:16 <dons> well, it says haskell == pre-haskell, and hask == code-haskell
20:15:24 <Cale> probably whether it uses <pre> or <code
20:15:24 <Cale> >
20:16:01 <lispy> inline verus block perhaps?
20:16:01 <Cale> I think <pre> is a block level element and <code> isn't.
20:17:20 <eivuokko> Wow, nice.  For once highlighting with decent colors :)
20:18:26 <dons> yeah, I quite like it.
20:18:27 <Cale> damn, it uses <span style="color: <foo>"> tags to set the colours, so it's not easy to modify them
20:18:38 <Cale> (it would be nice to fix the comment colour)
20:18:53 <Cale> the other colours are decent
20:19:27 <Cale> though it's a little odd in the way that it only colourises things that it explicitly knows about
20:20:05 <Cale> Control.Monad.ST has just Monad coloured purple
20:20:16 <Cale> with a link to the Prelude class declaration
20:20:38 <Cale> It obviously isn't doing a very deep parse of the code :)
20:21:16 <Cale> some type constructors and functions are highlighted and others aren't
20:22:37 <lispy> Cale: it's actually really easy to tweak the color if you change the haskell.php file
20:22:52 <dons> ah, php -- a parser-author's favourite language
20:23:04 <Cale> it should be set to a particular class so that the wiki-editable stylesheet can affect it
20:23:49 <lispy> that's probably possible.  geshi seems pretty intelligently designed
20:23:50 <Cale> Is there a way to make the grammar wikified?
20:24:16 <lispy> pretty sure it's just based on regexps
20:24:32 <Cale> probably
20:25:11 <Cale> I kind of hate that. Syntax highlighters based on regexps are never quite perfect.
20:25:19 <Cale> and yet everyone uses them
20:25:32 <lispy> they are simple but flawed
20:26:31 <lispy> but this is why eclipse has syntax highlighters for just a handful of languages and emacs has tons.
20:27:43 <dons> yes. we don't write parsers using lexers.. it's simple, yet so so many don't understand this
20:27:51 <dons> leading to horrible things like vim's syn hl system
20:28:12 <dons> so, really, the best you can aim for is token highlighting
20:28:21 <lispy> yup
20:28:29 <dons> pity haskell has only 4 kinds of tokens :/
20:28:52 <newsham_> syntax highlighting based on regexps are also a lot more forgiving
20:29:26 <newsham_> often you want highlighting even when there is no correct parse
20:29:41 <Cale> well, you can write a more forgiving parser too
20:29:45 <dons> that's fine. parsers can handle that
20:29:55 <newsham_> > syntax highlighting based on regexps are also a lot more forgiving
20:29:56 <lambdabot>  Not in scope: `forgiving'
20:29:57 <dons> we  use ghc's parser in visual studio and hide. it's lovely
20:30:02 <newsham_> (not to mention easier to write)
20:31:00 <lispy> yeah, but visual studio is pretty lame and how do you install hide?
20:31:16 <Cale> hide still isn't usable yet afaik
20:31:31 <palomer> is there a parser suitable for Yi yet?
20:31:32 <dons> doesn't matter. it uses a parser, it was no problem -> anyone could use a parser based system
20:32:06 <Cale> actually, didn't I hear a while back that Yi is doing syntax highlighting?
20:32:53 <newsham_> doesnt visual studio have to do a full parse?  (it makes context information available)
20:33:07 <dons> ah, here's yi: http://www.cse.unsw.edu.au/~dons/images//yi-color.png
20:33:16 <dons> using ghc's _parser_
20:33:24 <palomer> don't you need some kind of interactive parsing to parse the source while the user is typing?
20:33:33 <lispy> dons: cool
20:33:33 <newsham_> palo: yes.
20:33:45 <palomer> and which parser can do this?
20:33:50 <dons> you just need to be able to parse a line at a time
20:33:51 <newsham_> incremental parsing.
20:33:52 <lispy> not really, you could just parse it from scratch all the time
20:33:58 <eivuokko> newsham, It does more than parse, more like full frontend, I think.
20:33:59 <dons> and record the state of the parser at each line
20:34:13 <newsham_> google incremental parser
20:34:15 <dons> then, when something changes, you start parsing at the change, and continue until the parser state matches the recorded state
20:34:26 <dons> so you only reparse the bit that actually changed
20:34:46 <dons> so, in practice, you reparse only a few chars
20:34:53 <lispy> climacs uses an incremental parser for lisp and it was painfully slow last time i tired it
20:35:28 <newsham_> plus users type slowly :)
20:35:30 <Cale> dons: how hard do you think it would be to use the parsing information in order to keep indents aligned as well?
20:35:39 <dons> i think this is a solved problem, and there's no excuse for poor performance. it is fairly easy to get right
20:35:46 <dons> Cale, very doable
20:36:00 <Cale> It's quite common that you have something like
20:36:11 <Cale> f x y z = do foo x
20:36:20 <Cale>              bar y z
20:36:30 <dons> you'd store some kind of layout count for each line
20:36:35 <dons> and indent accordingly
20:37:08 <Cale> yeah, so that if a parameter was added to f in this case, 'bar' would get pushed along to keep it lined up with foo
20:37:08 <dons> modified by layout keywords, like do and where, and others, like parens, commas and such
20:38:09 <palomer> is "many" greedy in parsec?
20:38:16 <Cale> yep
20:38:47 <palomer> yeah, I wish that emacs would change the indentation whenever I change my code
20:39:02 <palomer> dons: why haven't I seen any of these parsers on the market?
20:39:02 <lispy> yeah or block uncomment correctly
20:39:17 <dons> palomer, subetheredit uses one. visual haskell uses the one that I use in yi
20:39:19 <lispy> palomer: you've been at the fish market by mistake?
20:39:22 <Cale> oh yeah, that was really annoying about emacs
20:39:28 <dons> I suspect that many others use the same stuff
20:39:30 <lispy> dons: subetheredit?
20:39:33 <dons> it's just that emacs and vim don't
20:39:41 <Cale> SubEthaEdit
20:39:44 <dons> also, bbedit uses one too, I seem to recall
20:39:47 <Cale> @google SubEthaEdit
20:39:49 <lambdabot> https://www.codingmonkeys.de/subethaedit/
20:39:50 <palomer> but, like, shouldn't these things be available as libraries, or parser generators
20:39:53 <lispy> subethaedit uses regexps
20:39:53 <dons> ah well, I don't speak apple talk
20:40:10 <palomer> dons: so I could simply supply the grammar for C and the highlighting rules to yi and let it do the rest?
20:40:20 <dons> palomer? it's called 'happy' -- it generates these things for you
20:40:24 <lispy> i know because i was hacking away at it's haskell highlighting file just the other day
20:40:30 <dons> palomer, yes. that's the idea.
20:40:49 <palomer> happy has incremental parsing?
20:40:53 <dons> you just define the grammar, as a happy grammar, and an association from tokens in your language to colors
20:41:07 <dons> then happy generates a parser that can be used to parse bit by bit, as I described
20:41:25 <dons> I would think these are really common outside of the emacs/vim world of 10+ year old editors
20:41:26 <Cale> are there incremental parser combinators?
20:41:41 <dons> seems doable, Cale. 
20:41:47 <dons> State -> Char -> .. functions
20:41:52 <dons> (State, a)
20:42:00 <palomer> yeah, emacs has this thing called "bovinator", which does incremental parsing
20:42:03 <palomer> but it's all elisp
20:42:04 <palomer> yuck.
20:42:13 <dons> but there's hardly enough editors around for much research to happen on this stuff
20:42:17 <dons> it's not a hot topic
20:42:23 <newsham_> to err is human, to moo bovine.
20:42:44 <palomer> dons: but it should be!
20:42:50 <dons> i agree
20:42:51 <palomer> we spend most of our time using editors
20:43:04 <palomer> and, quite frankly, emacs sucks, and its better than most things around
20:43:07 <dons> yeah, i don't know why we satisfy ourselves with half-broken crap 
20:43:15 <newsham_> palo: and we get along quite fine w/o incremental parsing ;-)
20:43:19 <newsham_> qed.
20:43:26 <dons> people are just happy to have things work 90%
20:43:45 <palomer> newsham_: emacs does do incremental parsing with bovinator
20:43:48 <dons> and not have to learn how to write a grammar, when they can spend 6 months attempting to fake all the corner cases with regexes
20:43:56 <Cale> hehe, the term 'Joe Haskell Programmer' is coming up on the mailing lists. Reminds me of my Algebraic Topology prof using "Joe Algebraic Topologist"
20:44:10 <newsham_> palo: i'm a vi guy :)
20:44:25 <dons> not even vim?
20:44:32 <newsham_> vim.
20:45:00 <dons> the vim highlighting dsl is one of the worst. it's the most obfuscated i've seen.
20:45:13 <dons> it approaches a parser generator in the limit, i suspect
20:45:19 <dons> but they don't know it :}
20:45:26 <lispy> Cale: i had a book author recommend using unisex names and non-genered pronouns for that sort of stuff.  And he was right, it makes it more fun :)
20:45:35 <dons> having written a haskell syn hl for vim, i never want to go back
20:45:50 <newsham_> dons: i'm glad i dont have to look at it :)
20:45:52 <palomer> joel haskell programmer?
20:45:55 <palomer> lesly haskell programmer?
20:46:03 <lispy> Robin haskell programmer
20:47:04 <palomer> I once wrote an emacs parser for gcc
20:47:08 <lispy> this particular author has a story in one of his text books about someone buying flowers for someone else.  It's very easy to assume genders for the people in the story but when you look at it carefully the story doesn't give those details away :)
20:47:10 <palomer> gcc error outputs, that is
20:47:40 <Cale> lispy: was it Hofstadter perhaps?
20:47:52 <lispy> Cale: hehe, no it was Timothy Budd
20:48:02 <lispy> well, dr. budd i should say to be polite...
20:48:03 <Cale> I recall Hofstadter discussing things like that in his Metamagical Themas
20:48:19 <newsham_> whoever heard of a female programmer?
20:48:35 <lispy> Ada Lovelake?
20:48:37 <lispy> er lovelace
20:48:41 * lispy can't spell
20:48:53 <flux__> that's cheating, that's "the female programmer"?-)
20:49:00 <Cale> I know quite a few female programmers
20:49:31 <newsham_> babage machine instructions?  next you're gonna say all knitters are programmers!
20:49:37 <lispy> yeah, actually the person that taught me programming was a woman
20:49:38 <flux__> infact there's one here, at work.
20:49:47 <Cale> Go to a university CS lecture, you'll likely find lots of them
20:49:55 <lispy> cute ones too!
20:50:00 <newsham_> they're just there to pick up their m.r.
20:50:18 <newsham_> m.r.c.s.
20:50:23 <lispy> newsham_: tell that to Philippa 
20:50:29 <dons> newham_ so cynical about everything
20:50:43 <newsham_> (i guess nobody can see me grinning)
20:50:45 <flux__> well, I don't know if that's the way, I wonder if you can count even half the men at those lectures "programmers"
20:50:51 <flux__> but then again, what is a programmer?
20:50:56 <lispy> newsham_: similarly you can't see me grinning :)
20:50:59 <Cale> flux__: one who programs
20:51:10 <Cale> (esp. of programming computers)
20:51:19 <lispy> so then a computer must be one who computes?
20:51:25 <Cale> exactly
20:52:00 <Cale> we had computers before we had computing machines
20:52:04 <flux__> that could make everybody a programmer then, unless he/she is incapable of programming the vcr?-)
20:52:14 <lispy> so when i was in grade school doing times tables my 3rd grade teacher was a programmer and she was a woman
20:52:34 <Cale> hehe
20:52:46 <newsham_> women cant program vcrs
20:52:55 <palomer> vcrs?
20:52:59 <newsham_> flux is strengthening my argument
20:53:05 <newsham_> video cassette recorders
20:53:09 <Cale> palomer: videocassette recorders
20:53:15 <palomer> oh, it's the s that bothered me
20:53:25 <lispy> cassette?  is that like a dvd? ;)
20:53:33 * lispy boggles
20:53:35 <flux__> lispy, think DAT
20:53:40 <newsham_> vcrs@(vcr:_)
20:53:58 <flux__> filled with mpeg
20:53:59 <palomer> yes! I got my system to infer a type _without any annotations_
20:54:19 <lispy> palomer: but is that type useful?
20:54:27 <Cale>    1. One who programmes, in various senses, as:    a. (s.v. PROGRAM, PROGRAMME v.)    b. One who devises a course of programmed instruction.    c. One who plans or chooses programmes for broadcasting.    d. One who arranges something according to a programme.
20:54:39 <Cale>  e. spec. One who writes computer programs.
20:54:39 <flux__> is that a useful definition in this context?
20:54:59 <Cale>     3. A device that automatically controls the operation of something in accordance with a prescribed programme; in quot. 1945 a part of an early electronic computer analogous to the control unit of later ones.
20:55:18 <palomer> lispy: not particularly, no
20:55:41 <flux__> newsham_, however, I believe every woman can operate an elevator
20:56:25 <flux__> I've hard the expression (not sure if this translates) "coding the elevator", that is, entering the elevator and choosing every floor in a random order
20:56:32 <newsham_> there exists a woman that can operate an elevator.  this i can vouch for
20:56:40 <flux__> doesn't work nicely with modern elevators, though ;(
20:56:53 <newsham_> there may exist a woman that cannot operate an elevator
20:56:55 <flux__> s/hard/heard/
20:57:13 <Cale> What if they're quadriplegic?
20:57:40 <palomer> ho hum, we're right on target to offending Philippa 
20:57:46 <palomer> which wouldn't be a good thing
20:57:49 <flux__> I think it's more about knowing how to operate an elevator, not the actual capability to do that
20:58:01 <palomer> Cale: give me the hardest thing to type which you can thing of
20:58:03 <palomer> Cale: with GADT
20:58:06 <Cale> heh
20:58:12 <palomer> not computationally hard, just logically hard
20:58:15 <newsham_> my employer doesnt pay me for knowing how to do things :(
20:58:38 <newsham_> they're pesky about me actually doing it
20:58:40 <flux__> would they pay you if you programmed even if you didn't know how to?
20:58:49 <flux__> much too common these days :/
20:58:53 <Cale> probably not for long though
20:58:58 <newsham_> flux: unlikely, but someone else would probably
20:59:22 <Cale> though, the daily wtf is good evidence
21:00:04 <flux__> I'd have some (too much) good material for the daily wtf, maybe I'll submit it some year
21:00:37 <lispy> i've been reading some blog entries by a by a guy that did hiring at amazon.  Apparently some applicants can't answer really basic questions about programming. I was shocked.
21:00:53 <newsham_> anyway, i think "joe haskell" would be fairly representative.
21:00:56 <newsham_> genderwise at least.
21:00:58 <flux__> and not the usual "programmer doesn't know what he's doing"-kind of wtf, but code that is incomprehensible, yet is production code
21:01:17 <newsham_> perhaps  ian mchaskell would be better?
21:01:32 <lispy> flux__: yeah, i was just auditing/rewriting/maintaining some 20 year old fortran code at work...omfg
21:01:50 <palomer> if it works, why fix it?
21:01:51 <newsham_> is the control flow irreducible?
21:02:13 <lispy> palomer: well...that's the thing it's so opaque the users didn't know about some nasty bugs
21:02:14 <flux__> control flow is controlled by undocumented single-letter-variables
21:02:22 <flux__> some of which are maintained over calls to the function
21:02:41 <Pseudonym> You could always transform it into continuation-passing style.
21:03:19 <newsham_> google: structuring control flow
21:03:19 <flux__> not that easy with C
21:04:10 <palomer> how do you get the first argument passed to your executable?
21:04:18 <lispy> one of the things that really bothered me about fortran was that a function could accept an int of one size but require a different size.  This would be silently okayed by the compiler but you'd get undefined results at runtime
21:04:39 <flux__> it responds to external events
21:04:50 <palomer> lispy: even with -Wall?
21:04:52 <flux__> or rather, reacts
21:05:00 <lispy> usually it wouldn't crash the values would just be wrong inside the function call
21:05:18 <lispy> palomer: i was using intel's compiler, but i did turn on the equivalent of -Wall
21:05:26 <newsham_> > getArgs
21:05:27 <lambdabot>  Not in scope: `getArgs'
21:05:55 <newsham_> palomer: getArgs?
21:06:01 <palomer> @hoogle getArgs
21:06:02 <lambdabot> System.Environment.getArgs :: IO [String]
21:06:02 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
21:06:02 <lambdabot> String])
21:06:05 <Pseudonym> Hands up anyone who has changed the value of 4.
21:06:09 <palomer> gotcha
21:06:09 * Pseudonym raises hand
21:06:36 <lispy> > 4 := 3.14159
21:06:37 <lambdabot>  Not in scope: data constructor `:='
21:06:53 <newsham_> 4 = 4 + eps   as eps approaches zero
21:07:15 <Pseudonym> The way you do it in Fortran is to note that all values are passed by reference.
21:07:20 <Pseudonym> Including constants.
21:07:31 <lispy> Pseudonym: oh, really?
21:07:33 <Pseudonym> So you can change a constant.  It'll be different the next time you invoke the same call.
21:07:44 <Pseudonym> The equivalent of this:
21:07:46 <lispy> i wondered why the stack wasn't corrupted by wrong size ints
21:07:54 <Pseudonym> void foo(double& f)
21:07:56 <Pseudonym> { ++f; }
21:07:58 <Pseudonym> Then:
21:08:07 <Pseudonym> for (int i = 1; i < 10; ++i)
21:08:11 <Pseudonym>     foo(4.0);
21:08:25 <lispy> i could be wrong, but fortran seems less type safe than C
21:08:26 <Pseudonym> If you print f within foo, you'll find it goes up from 4.
21:08:33 <Pseudonym> You're not wrong.
21:09:04 <flux__> the real wtf of that example is the loop with i = 1 and i < 10, what's that about?-)
21:09:42 <lispy> yeah, that's not valid fortran ;)
21:09:53 <lispy> do 100 i=1,10
21:10:01 <lispy> call foo(4.0)
21:10:10 <lispy> 100 continue
21:10:20 <lispy> or something like that
21:10:33 <Pseudonym> Right.  I can't remember enough Fortran syntax to do it eright.
21:10:35 <Pseudonym> right
21:10:41 <Pseudonym> But it's the equivalent of that.
21:10:49 <lispy> i can't remeber if it's 100 continue or continue 100
21:11:05 <Pseudonym> AND you started your code in the wrong column.
21:11:10 <lispy> heeh
21:11:31 <Pseudonym> And people think the layout rule is confusing.
21:11:54 <lispy> well, it can be, but confusing is different than just plain sucking :)
21:14:00 <Cale> You can always claim that you were writing Fortran 90
21:14:38 <flux__> I think it's too late now
21:24:22 <sieni> at least fortran 90 supports layout-independent format as well, like Haskell
21:24:34 <dons> > let 4 = 3.1415 in "yeah"
21:24:35 <lambdabot> "yeah"
21:25:18 <sieni> > let 1 + 1 = 7 in 1 + 1 + 7
21:25:19 <lambdabot>  Non-exhaustive patterns in function +
21:25:56 <Cale> > let 1 + 1 = 7 in 1 + 1
21:25:56 <lambdabot> 7
21:26:01 <lispy> > let 1 + 1 = 7 in (1 + 1) + 7
21:26:02 <lambdabot>  Non-exhaustive patterns in function +
21:26:06 <lispy> er...
21:26:17 <Cale> it shadows the former binding of + completely
21:26:25 <Cale> > let 1 + 1 = 7 in (1 + 1) Prelude.+ 7
21:26:26 <lambdabot> 14
21:26:27 <lispy> guess so :)
21:26:57 <dons> very nice
21:27:01 <dons> obfuscation, ho!
21:27:14 <dons> reminds me we should have the S (S Z) Obfuscation Contest this year
21:27:35 <dons> @wiki Obfuscation
21:27:36 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
21:27:54 <palomer> 1000 line source files are fun
21:28:15 <dons> let me tell you about the module system, palomer .. ;)
21:29:32 <palomer> to be fair, have of it is code which I commented out
21:30:02 <palomer> and all the functions deal with a single datatype, so I don't see how I could split it further
21:30:07 <palomer> 500 lines isn't that bad
21:35:27 <lispy> yeah, version control is nice, but i have to admit, i hate trying to go back in time with them
21:35:39 <lispy> so i end up with hundreds of lines of commented code too
21:36:40 <dons> so use version control, and make a new branch every time you save the file ;)
21:36:54 <lispy> :)
21:37:21 <lispy> actually it's nicer in darcs than most VC because you just checkout a new copy and backoff patches in a cherry picking style
21:37:25 <dons> i tend to kill off dead code. i need the dead code so rarely, that typing 'darcs changes' is usually worth it
21:37:40 <eivuokko> Yeah, me too.
21:37:50 <dons> dead code if overrated
21:37:55 <dons> is
21:38:01 <lispy> i should get into that habbit perhaps.
21:38:31 <lispy> although sometimes i leave around a naive implementation in comments when it's appropriate.  and that can add a lot to the code size
21:38:50 <dons> even better -- code up a naive implementation in the type of the function :)
21:38:56 <newsham_> i'm getting a crash when native code is calling a haskell callback (using FFI)
21:38:56 * dons is in a silly mood
21:39:36 <palomer> what's the best way to get rid of a darcs repository?
21:39:42 <palomer> rm -rf darcs_ ?
21:39:47 <palomer> or, rather, _darcs
21:39:53 <newsham_> foreign import stdcall "wrapper" mkCSCB :: CSCBFunc -> IO (FunPtr CSCBFunc)
21:39:55 <lispy> darcs dist
21:39:59 <newsham_> the cb I ahve is just "return ()"
21:40:07 <palomer> darcs dist tarballs a repository
21:40:08 <palomer> I thought
21:40:25 <lispy> yeah, but it tars it without the _darcs
21:40:40 <lispy> so then you still have your repo in tact and you have a non-repo copy :)
21:41:07 <lispy> newsham_: sorry, that's uncharted territory for me so i can't really suggest anything
21:41:33 <eivuokko> newsham, is the calling convetion correct for sure?
21:41:55 <lispy> palomer: but the rm -rf _darcs will undarcs a repo
21:41:59 <newsham_> usin th same calling convention as for the calls (also i have python ffi bindings that use the same and work)
21:42:32 <eivuokko> Uhm.
21:42:39 <palomer> yeah, that's what I want to do
21:42:50 <newsham_> oh, hrm, maybe its the wrong convention :)
21:43:01 <eivuokko> newsham, How is the callback declared in C?
21:43:03 <lispy> palomer: if you don't mind me asking, why do you want to do that?
21:43:32 <palomer> I want to make a toplevel dir
21:43:40 <palomer> so I'm going to redarcs it
21:43:50 <lispy> palomer: but then you'll lose your history
21:43:57 <eivuokko> I'd just darcs move stuff, then
21:44:00 <palomer> I've hit a major milestone
21:44:07 <newsham_> hah, i twas the calling convnetion
21:44:09 <newsham_> i'm dumb.
21:44:22 <eivuokko> newsham, It is tricky sometimes :)
21:44:36 <newsham_> they use stdcall for the api but ccall for the cb's
21:44:58 <eivuokko> newsham, And I am not sure if python stuff in windows is best example, iirc they are pretty confused themselves.
21:45:12 <palomer> ahh! ghc isn't the culprit, it's emacs
21:45:20 <newsham_> the ctypes ffi works well.. it has support for stdcall and ccall and win32 and unix
21:45:33 <newsham_> if you play w/ python and ffis i recommend giving it a shot
21:45:45 <eivuokko> newsham, At least in past python was compiled using msvc6 in a way that made it incompatible with all other compilers, including other versions of msvc.
21:46:01 <eivuokko> newsham, I happily don't.  I just used to ;)
21:46:12 <newsham_> ctypes doesnt require recompilation..  it can access dlls and sos directly
21:47:10 <newsham_> i think the distutils has support for building w/ other versions these days
21:47:26 <newsham_> (building add-on modules)  honestly i havent done much writing modules
21:47:30 <newsham_> native
21:48:34 <lispy> at work we use python for manipulating matrices because python has bindings for numarray.  I wonder if anyone has haskell bindings for numarray.  It would be neat to show to some of the geeks at work
21:49:11 <lispy> i don't see anything on google, i wonder if it would be hard to do it...
21:49:24 <newsham_> would be nifty, especially since the code around the numeric operations would be running at compiled speeds rather than interpretted
21:49:49 <newsham_> also writing math code in haskell seems natural
21:50:27 <lispy> yeah, and numarray seems to store the data one way and then provide "views"
21:50:56 <lispy> so when you resize the array to make it go from 1 dimensional to 2 dimensional they just provide a new interface for indexing instead of moving data around
21:55:39 <akemp> Anyone here built the ALUT lib in GHC?
21:56:03 <Lemmih> I think it's broken right now.
21:56:48 <akemp> hmmm...  Broken stuff included in HEAD... sweet.
21:58:23 <Lemmih> HEAD is the place for broken stuff (:
21:59:04 <akemp> oh...  Where should I find the nonbroken stuff?  ;)
21:59:18 <Lemmih> STABLE.
21:59:34 <akemp> STABLE?  That's so debian...
22:00:10 <lispy> this is really odd, i lengthened the captions in my paper and all of sudden the figures have been moved to the end of the paper
22:01:03 <akemp> Sound like Word; probably is LaTeX?
22:01:14 <lispy> it's latex, i've never used word
22:01:50 <akemp> I envy you.
22:02:21 <lispy> any idea how i can get my figures back to where they should be?
22:02:22 <palomer> lispy: in your life?
22:02:29 <palomer> or used word for anything serious
22:03:02 <lispy> okay, i did have to edit a small document (added a paragraph) last summer at my internship
22:03:21 <lispy> other than that i've used abiword, wordperfect, open office but mostly latex
22:04:29 <lispy> i have no idea how to do anything useful in word
22:04:40 <lispy> but i have heard it supports style sheets
22:07:13 <lispy> ah, i see, the figures with bigger captions are too big for their pages
22:08:22 <lispy> akemp: but, latex is far from perfect
22:08:30 <lispy> akemp: in fact, i'd say it's broken in a lot of ways
22:10:56 <lispy> word probably wouldn't be that bad if you could use emacs as the editor
22:12:33 <akemp> I liked LaTeX.  Wrote a couple of thesi in it.
22:12:43 <akemp> At least I knew its evil ways.
22:13:00 <akemp> Word does mysterious stuff.
22:13:27 <lispy> when i was working on my undergrad in math i did all my assignments in latex, it was a blessing
22:14:05 <lispy> one nice thing is that i can still reference them
22:14:28 <lispy> in fact, i've done cut 'n paste proofs because of it :)
22:15:00 <Cale> lispy: yeah
22:15:40 <Cale> lispy: I did many of my assignments in LaTeX, but it's still a little more work than just writing things on paper. TeXmacs is a nice middle ground.
22:16:36 <lispy> Cale: yeah.  I found that writing things by hand wasn't that much faster when i had to rewrite the whole page because i screwed something up at the end of the page
22:16:56 <lispy> my profs wanted our write ups in pen usually
22:16:56 <Cale> Use a pencil, man :)
22:17:00 <Cale> oh
22:17:06 <Cale> I found that I could type things out in TeXmacs a bit faster than plain TeX or LaTeX, but I probably wouldn't use it for anything more serious than an assignment.
22:17:40 <Cale> It was a little buggy in certain aspects.
22:17:41 <lispy> true, i started with texmacs but found that i still needed to know latex so i ended up ditching it and learning latex
22:17:58 <akemp> Right then... Got ALUT to compile.  Missing "includes".
22:19:34 <Lemmih> Do you need ALUT?
22:22:02 <akemp> Nope.  Just want HEAD to compile.  
22:22:07 <akemp> It's doing so right now.
22:24:01 <Lemmih> Disabling OpenAL and ALUT is easy, though.
22:24:45 <akemp> How do you do it?  
22:25:06 <akemp> (Aside from deleting them...)
22:25:09 <Lemmih> ./configure --disable-openal --disable-alut, iirc.
22:26:12 <akemp> Ah...  yes.  Magical configure incantations.
22:27:18 <akemp> Gotta say....  GHC cries out for more than a P3-750 with 256K of cache.
22:35:02 <adu> how do i set an element in a list
22:35:20 <adu> like ls !! n = value
22:35:43 <Cale> adu: well, first of all, you try not to, since it's quite slow
22:35:51 <adu> oh
22:36:00 <adu> can you do that with arrays?
22:36:03 <Cale> yeah
22:36:15 <adu> i'm guessing mutable arrays
22:36:21 <Cale> if you want to do updates, look at DiffArrays or mutable arrays
22:36:33 <adu> ok
22:36:42 <Cale> DiffArrays are nice because they have a pretty immutable interface, but also fast updates for many uses.
22:47:26 <adu> so if i wanted an MArray with the element type BigFloat, would i haveto define a new instance of it for it to work?
22:49:00 <shapr> Yay, I got mentioned in Oleg's latest nifty email!
22:52:07 <Lemmih> Gotta put that on your CV!
22:52:25 <lispy> shapr: haha
22:52:57 <lispy> shapr: my name appeared today in the wiki changelog!
22:53:05 <lispy> shapr: i was happy
22:55:43 <Cale> adu: yes, the mutable array types are fairly specialised
22:56:33 <adu> ok
22:56:44 <Cale> In fact, I think that the unboxed Bool arrays are packed as bitfields
22:57:02 <adu> wow
23:13:21 * shapr boings
23:15:11 <dons> yep. bit fields. hence speedy
23:15:22 <vincenz> aloha
23:15:39 <dons> pretty good here http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
23:15:56 <shapr> kia ora
23:16:32 <dons> huh, funny things happen when they rerun with different sizes: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
23:18:01 <vincenz> hola dons
23:18:17 <dons> hey
23:20:22 <vincenz> @type maybe
23:20:22 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:21:20 <vincenz> > maybe ("Nothing") id  $ (Some "Lala")
23:21:20 <lambdabot>  Not in scope: data constructor `Some'
23:36:55 * shapr learns PHP
23:37:15 * sieni slaps shapr with a large trout
23:37:25 * shapr cries
23:37:30 <shapr> Not the fish!
23:37:30 <Cale> > maybe ("Nothing") id  $ (Just "Lala")
23:37:31 <lambdabot> "Lala"
23:37:52 * shapr shouts NI! at sieni
23:38:52 * shapr throws a shrubbery into the path in front of sieni
23:44:42 <adu> yey i made it say something
23:47:19 <Cale> say something?
23:47:23 <adu> ya
23:47:38 <Lemmih> @vixen say something
23:47:39 <lambdabot> Hahaha
23:47:49 <adu> if i say: don't flip out, in a special way:
23:48:03 <adu> > do "n't" >> flip (curry fst) "out, man!" "."
23:48:04 <lambdabot> "..."
23:48:32 <adu> :)
23:49:44 * drrho is away: cutting red tapes
