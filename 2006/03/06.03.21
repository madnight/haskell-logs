00:20:13 <shapr> Sure is quiet around here...
00:20:22 <ValarQ> sure is
00:20:38 <shapr> hej ValarQ, wassup?
00:21:04 <ValarQ> not much, trying to get some of the coffee in my cup into my mouth
00:25:02 * nothingmuch makes noise for shapr
00:39:30 <shapr> hiya nothingmuch 
00:39:59 <ski> goddagens, shapr
00:42:25 * shapr listens to godmorgon rock
00:55:22 <bringert> I'm going to try to package an application written in Haskell for debian
00:55:47 <bringert> does anyone have any pointers?
00:57:38 * sieni hands bringert a void * and a char *
00:58:44 <ibid> bringert: there's a cabal packaging helper around (iirc by CosmicRay 
00:58:46 <ibid> )
00:59:05 <ibid> bringert: ISTR seeing a haskell policy, too
00:59:20 <bringert> ah, I should have said that it doesn't use Cabal
00:59:28 <bringert> it uses autoconf + make
01:01:01 <bringert> ibid: would your BNFC package be a good starting point?
01:01:03 <ibid> well, you can still learn a few things from it :)
01:01:36 <bringert> (I'm one of the BNFC developers :-)
01:01:53 <ibid> bringert: if it helps you. mind, i do have an idiosyncratic packaging style in general
01:01:58 <ibid> bringert: oh hi :)
01:02:27 <ibid> bringert: the bnfc packaging is just a case of "i did what seemed best at the time" :)
01:02:46 <bringert> hehe, ok. do you know of any orthodox haskell debian packagers then? :-)
01:10:05 <ibid> bringert: grep-dctrl -FBuild-Depends ghc6 -sSource /path/to/Sources :)
01:10:05 <ibid> bringert: googling came up with this. http://urchin.earth.li/~ian/qq/haskell-policy.txt, dunno how up to date that is
01:10:05 <ibid> bringert: i don't think there's anything special about packaging haskell programs, actually
01:10:05 <ibid> bringert: it's libraries where the fun starts
01:10:05 <bringert> oh, and I forgot to say that I've never packaged anything for debian before :-)
01:10:05 <bringert> maybe I should just go a head and cabalize the thing first
01:10:05 <bringert> "go a head"?
01:10:05 <bringert> weird
01:10:05 <boegel> go ahead
01:10:05 <ibid> bringert: ah. then you should look at generic packaging tutorials. start with http://www.debian.org/doc/maint-guide/
01:10:05 <ibid> bringert: you should also familiarize yourself with http://www.debian.org/doc/debian-policy/ (mandatory if the package should become a part of debian, recommended otherwise)
01:10:05 <bringert> ok, thanks
01:11:02 <ibid> bringert: if you need a sponsor at debian at some point, ask me (i won't guarantee i'll say yes, it depends on other factors like my overload quotient at the time;)
01:12:08 <bringert> I don't actually use Debian, I use Ubuntu. Would that cause any problems with the packaging or anything else?
01:12:45 <bringert> but I figured that it would be best to just package the stuff for debian, and then it should work in Ubuntu too, right?
01:14:14 <ibid> bringert: as far as i know, the source packages at least are compatible. there may be at various points binary incompatiblities, though
01:14:49 <ibid> bringert: if you compile a package in ubuntu, it's an ubuntu package, not a debian one, but it ought to work on both regardless
01:15:36 <ibid> bringert: any official debian package needs to be built on a debian sid system (chroots are fine), but it's that strict with unofficial packages
01:16:03 <ibid> it's *not* that strict, actually
01:16:48 <ibid> bringert: see also https://wiki.ubuntu.com/DeveloperResources for ubuntu stuff (some of which is also relevant to straight debian)
01:17:13 <bringert> I'll be happy to just be able to build packages for now, I'll worry about being included in the distributions later
01:23:51 <shapr> hej bringert!
01:23:57 <bringert> hej shapr
01:24:15 * bringert is looking into packaging GF for Debian
01:24:31 <bringert> shapr: what's up?
01:24:44 <shapr> I'm just back from five days in Stockholm. It was fun.
01:25:45 <shapr> When I move there in July, I suspect I'll regularly show up at chalmers looking for people to participate in type theory and/or unicycling.
01:26:02 <bringert> you are moving to Stockholm och Göteborg?
01:26:18 <bringert> shapr: have you met Nils-Anders Danielsson?
01:26:27 <bringert> he rides a unicycle to work
01:26:40 <shapr> Wow cool. Haven't I seen him post to the haskell mailing lists?
01:26:44 <bringert> yeah
01:26:55 <shapr> Cool, does he know Ulf Karlsson I wonder?
01:27:04 <bringert> dunno, why?
01:27:13 <shapr> Ulf started enhjulingsfolket.se, he's the Unicycling Master :-)
01:27:28 <shapr> Also a math or CS major at chalmers. I forget which.
01:28:03 <shapr> Oh, I got copies of the EuroHaskell 2004 pix from andersca. You want a copy?
01:28:16 <shapr> You look stylish on a unicycle =)
01:28:23 <bringert> aren't they online?
01:28:31 <bringert> or do you mean paper copies?
01:28:33 <shapr> Nah, andersca.org is offline.
01:28:36 <bringert> ah
01:29:24 <shapr> What's the news with BNFC/GF/etc?
01:29:30 <shapr> Anything exciting happening?
01:29:58 <jips> good morning
01:30:05 <shapr> good morning jips!
01:30:16 <bringert> we're planning on releasing GF 2.5 this week
01:30:28 <shapr> spiffy
01:30:38 <shapr> Do you have an url to the list of cool new features?
01:30:48 <bringert> there is a bunch of new feautres in BNFC CVS, but I'm not sure if it's available anywhere
01:31:19 <bringert> Java 1.5 support, string sharing in haskell, (very) basic semantic actions
01:31:53 <bringert> shapr: Changes in the current GF darcs version: http://www.cs.chalmers.se/~aarne/GF/doc/gf-history.html
01:32:52 <shapr> hm, neat
01:33:51 <shapr> Oh, I'm only moving to Stockholm, not Göteborg.
01:35:13 <shapr> But three hours one way by train is just fine for a weekend trip to Göteborg if I can find a floor to sleep on for Saturday night.
01:36:10 * bringert has a couch
01:36:15 <shapr> thanks :-)
01:36:33 <shapr> Do you know any type theory guys in Stockholm? I can only think of Karl-Filip Faxén.
01:36:53 <shapr> Maybe I already asked you this...
01:39:07 <bringert> Per Martin-Löf...
01:39:35 <shapr> He's in Stockholm??
01:39:38 * shapr googles
01:40:07 <shapr> oh wow
01:40:14 <shapr> Gee, I guess he counts as being a type theory guy.
01:43:36 <shapr> I wonder if there's a regular type theory meeting in Stockholm. If not, I'll organize one.
01:45:55 <shapr> bringert: What is a treebank anyway? Maybe all the dependent tables explicitly sewn together?
01:46:50 <bringert> basically a huge list of (String, [Tree])
01:46:55 <shapr> I don't see it in the 2.4 tutorial.
01:47:02 <shapr> Oh
01:47:28 <bringert> normal treebanks are often used to becnhmark parsers / grammars
01:47:42 <bringert> see for example the Penn tree bank or the Prague tree banks
01:53:42 <shapr> salut Cale 
01:58:55 * shapr notices that gettext could be implemented easily in Haskell.
02:03:26 <dcoutts> shapr, in IO or not ?
02:03:46 <bringert> shapr: we have been thinking about generating gettext files from GF
02:04:59 <shapr> Most of gettext would not require IO except for file reading and writing.
02:05:39 <ski> what is gettext ?
02:05:51 <shapr> It's the GNU internationalization framework.
02:06:27 <ski> specifying bits of text in different nat. langs ?
02:07:00 <shapr> Yup
02:33:26 <adu> i just realized something
02:34:59 <adu> "enum" and "menu" are anagrams, and quite possibly synonyms
02:36:08 <dcoutts> enumerations are not necessarily finite
02:37:18 <bringert> are menus necessarily finite?
02:41:46 <dcoutts> bringert, if not, it'd make it really hard to choose what to eat at a restaurant
02:42:09 <shapr> Although with metavariables...
02:47:49 <bringert> hmm, at my local sushi place, you can order any combination and number of individual sushi and maki and whatever they are called
02:47:57 <bringert> but I guess the menu is still finite
02:48:25 <adu> but like they both involve choosing from a list, so in that sense they're synonyms
02:49:09 <shapr> Enumerations are effectively finite? I guess that's not so in a lazy language.
02:49:40 <dcoutts> > take 5 [(0::Integer)..]
02:49:41 <lambdabot> [0,1,2,3,4]
02:49:53 <shapr> Can you have lazy menus?
02:50:09 <dcoutts> yay, we might get ranlib fixed: http://sourceware.org/ml/binutils/2006-03/msg00285.html
02:50:11 <adu> shapr: how about those menus that expand when you hover on them?
02:51:01 <adu> if there was an infinite amount of that going on, then you could have infinite menus
02:51:23 <jips> hello dcoutts 
02:51:30 <dcoutts> hia jips 
02:51:36 <shapr> Yeah, true. Serving time may end up including shipping time though :-)
02:52:15 <shapr> On the other hand, good restaurants with creative chefs are willing to improvise when I ask for crazy things, so...
02:52:29 <adu> also, Haskell enum is much different than C enum, but since we're talking fuzzy concepts it doesn't matter anyway
02:53:00 * adu likes fuzzy things
02:53:27 <dcoutts> shapr, perhaps that shows that the menu is bounded but dense and thus not finite, though probably countable
02:54:00 <adu> one time i couldn't find any info on fuzzy logic ops so I figured out how to define them using linear polynomials
02:55:37 <sieni> Well, if you printed the menu on a paper sheet that's isomorphic to I x half-closed long ray, you could fit omega-1 items on the list
02:56:16 <adu> whats omega-1?
02:56:21 <shapr> Did you guys notice Geoff Washburn's sML-evolution vs Haskell' comparison? http://trurl.livejournal.com/725386.html
02:56:23 <adu> is that the same thing as omega?
02:56:55 * shapr has no clue what sieni is talking about...
02:57:19 <shapr> That's one thing I like about this channel, easy access to knowledge I don't have yet :-)
02:58:09 <adu> sieni: is that the omega = 0.56714
02:58:53 <sieni> adu: no, the first uncountable ordinal
02:59:07 <adu> oh
02:59:14 <sieni> http://en.wikipedia.org/wiki/Long_line_%28topology%29
02:59:19 <adu> i thought that was aleph_1
03:00:02 <adu> lol, "but much longer"
03:00:19 <adu> like length has any meaning when talking about ordinalities and cardinalities
03:00:46 <integral> cardinal ne ordinal...
03:05:00 * shapr spoofs "Shall I compare thee to a summer's day" for #haskell
03:06:51 <shapr> http://www.scannedinavian.com/~shae/shallIcompare.text
03:07:33 * shapr RFS
03:07:35 <shapr> er, RFCs
03:08:00 <shapr> I'm sure someone with more poetic clue can improve that :-)
03:10:42 * sieni wants to go juggling, but there's too much work still left to be done today to leave now
03:47:55 <shapr> Hey, does anyone know why electric trains aren't powered by induction? Why do they require direct conductivity?
03:48:37 <mathrick> perhaps it'd be too hard to provide high quality link for a moving object?
03:49:28 <tuomov> how do maglevs get their power?
03:49:43 <mathrick> by the power of SCIENCE!
03:49:44 <shapr> Do you think the difficulty for an induction link would be significantly higher than a direct link?
03:50:03 <tuomov> or do the trains themselves have much power requirements at all?
03:50:44 <mathrick> shapr: yes, because once you assure a consistent contact, you're pretty much done with the direct link, while for induction the velocity itself is an important factor
03:50:57 <shapr> Ideal power requirements would be 1. enough to power the electromagnets vs the weight of the train and 2. enough to power the electromagnets to move the train
03:51:07 <mathrick> tuomov: of course
03:51:18 <mathrick> they have rather insane engine powers
03:51:48 <mathrick> this is not quite the same for maglevs
03:52:05 <mathrick> where being maglev automatically frees you from having a proper engine
03:52:12 <tuomov> I was talking of maglevs specifically.
03:52:38 <mathrick> well then, probably not trains but the maglev mechanism as a whole is whan consumes energy
03:52:42 <tuomov> Are the "engines" in the tracks or the trains
03:52:54 <mathrick> tuomov: both
03:53:10 <mathrick> but I think you can shift the workload to the tracks
03:53:26 <mathrick> with the train doing pretty much only the control part
03:55:52 <shapr> Still, you'd want the tracks to be as simple as possible.
03:56:36 <shapr> It's a lot easier to pull a slightly flaky train off the tracks than to go out and fix the rails.
03:56:53 <mathrick> shapr: yes, but I don't think you can significantly simplify maglev tracks anyway
03:57:08 <mathrick> they are a precise set of equipment, powered or not
03:57:10 <shapr> I'd make them inductively powered electromagnets.
03:57:17 * shapr thinks about that.
03:57:17 <tuomov> yeah.. they can't even fix the tracks here to be able to travel at 220km/h ro so that the new pendolino trains could do
03:57:24 <tuomov> everything goes at sluggish 130km/h
03:57:50 <shapr> Actually, you could probably use boring iron rails, though they would require a precision mix, as you say.
03:58:03 <mathrick> shapr: no, they need to be in phase with the train to work
03:58:17 <shapr> Phase?
03:58:18 <mathrick> it's not as simple as making them plain electromagnets
03:58:22 <mathrick> shapr: yes
03:58:23 <shapr> You mean alignment of the north and south poles?
03:58:32 <mathrick> they switch from N to S frequently
03:58:36 <shapr> Right, they have to.
03:58:59 <shapr> The frequency of the switch would depend on the 'magnetic capacitance' of the rails.
03:59:20 <shapr> And you modify the switching speed to get power in one direction or another.
03:59:30 * shapr has a nifty generalization of this idea, but is trying to get a patent on it...
03:59:31 <mathrick> yup
03:59:48 <mathrick> boo patents!
03:59:55 <tuomov> boo!
03:59:57 <shapr> Hey, it's for a real machine.
04:00:03 <tuomov> all the same
04:00:20 <shapr> Well, the idea is so simple that if I don't get a patent, I won't get any reward for doing all the research&dev.
04:01:08 <shapr> mathrick: Anyway, can you describe the difference between plain electromagnets and maglev rails?
04:01:43 <shapr> tuomov: So I can either give away my ideas and continue scraping along as a webmonkey, or I can get patents and hopefully fund a bunch of crazy ideas.
04:02:17 <tuomov> property is theft.
04:02:26 <shapr> I'm fond of eating.
04:02:28 <mathrick> shapr: yes. Maglev magnets are externally controlled in order to have a pole opposite to the pole of train magnet directly approaching, in phase with how train passes above them
04:02:51 <mathrick> so you'd have something like that (ASCII art):
04:02:55 <shapr> Can't they be inductively powered by the train magnets themselves?
04:03:05 <mathrick>  S N S N S N
04:03:11 <mathrick> N S N S N S
04:03:16 <mathrick> to get <- motion
04:03:21 <shapr> Right, I understand that.
04:03:58 <mathrick> shapr: I'm not sure, I know the idea, but not the exact computation, I generally loathe of the magnetic circuits theory :)
04:04:14 * shapr finds lots of detail on http://en.wikipedia.org/wiki/Maglev_train
04:04:38 <shapr> Oh, they *do* use induction coils!
04:05:59 <shapr> ooh http://en.wikipedia.org/wiki/Earnshaw%27s_theorem
04:06:23 <shapr> I could read wikipedia to the exclusion of most other things.
04:07:00 <mathrick> heh
04:07:19 <mathrick> that's what I'm doing right now, to the exclusion of my two deadlined projects
04:08:00 <shapr> Sounds familiar.
04:08:26 <mathrick> ah, so that inductrack thing is support only
04:11:25 <shapr> Inductrack is sort of like an autogyro.
04:35:12 <shapr> Sure is quiet...
04:35:28 <_calvin_> yeah..
04:35:43 <Lemmih> How's code, everybody?
04:40:26 <Lemmih> Okay, why don't I start.
04:40:30 <Lemmih> Code is great. I'm about to hack a decent UI for conjure.
04:40:33 <shapr> yay!
04:40:49 <shapr> I'm doing Python mostly, but I've been playing with the lambda calculus interpreter in lambdabot.
04:47:37 <dcoutts> Lemmih, cool
04:48:08 <dcoutts> Lemmih, well I've been hacking on improving Haskell support in Gentoo which is going great
04:48:48 <dcoutts> and I'm looking at getting the Gtk2Hs treeview changes finnished in preperatio for a new Gtk2Hs release
04:49:33 <dcoutts> and I hacked up a patch to ranlib to make building libHSbase.a not take 500Mb of ram
04:49:49 <dcoutts> said patch is now being reviewed upstream
04:49:53 <dcoutts> so it's all good
04:50:29 <dcoutts> dons, I'll send you the Gentoo announcement for HWN when we're ready
04:51:00 <dcoutts> we're getting ghc-6.4.1 marked stable on several arches
04:51:15 <dcoutts> ppc is done, x86, amd64 & sparc still to go
05:13:41 * shapr yawns
05:14:03 <shapr> \lambda SKI
05:14:03 <lambdabot> unbound variable: SKI
05:14:08 <shapr> \lambda S K I
05:14:08 <lambdabot> <<EM Dynamic -> EM Dynamic>>
05:15:45 <vincenz> dcoutts: Hi, good that you're around
05:15:53 <vincenz> dcoutts: how do I start with a simple cairo project not based on a dialog?
05:16:03 <vincenz> like the basic struts for a window with a drawable canvas that repaints
05:16:44 <dcoutts> vincenz, just make a window and put a drawing area in it
05:16:54 <jips> hello dcoutts 
05:16:59 <dcoutts> hia
05:17:16 <vincenz> dcoutts: yeah but don't you need refresh?
05:17:36 <jips> vincenz: idle signal
05:17:45 <dcoutts> vincenz, so you connect to the onExpose signal for the drawing area
05:18:13 <dcoutts> vincenz, are you trying to animate it?
05:18:19 <vincenz> nope
05:18:38 <dcoutts> ok, simple
05:18:40 <vincenz> I still have to do actArea <- windowGetActionArea window?
05:18:52 * shapr considers implementing arrows in lambda calculus.
05:18:53 <dcoutts> nope
05:19:09 <dcoutts> that's only for a dialog
05:19:25 <vincenz> so how do I add something to a window?
05:19:53 <vincenz> and you need to do both onExpose and onSizeRequest, no?
05:20:10 <dcoutts> vincenz, see demo/cairo/Drawing2.hs
05:20:19 <vincenz> ok
05:20:38 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/cairo/Drawing2.hs
05:21:48 <dcoutts> jips, did you have a question?
05:22:22 <vincenz> mainGUI seems osomething new too
05:22:31 <jips> dcoutts: not really
05:22:48 <dcoutts> just saying "hi" :-)
05:22:54 <dcoutts> ok :-)
05:23:01 <jips> dcoutts: how is hIDE coming?
05:23:08 <dcoutts> slowly
05:23:34 <jips> but on schedule?
05:23:39 <dcoutts> my current priority is the next gtk2hs release
05:23:45 <dcoutts> which has things we need for hIDE
05:23:50 <jips> which things?
05:23:57 <dcoutts> the new tree view api
05:24:08 <dcoutts> to make doing tree widgets much easier
05:24:13 <jips> cool
05:24:13 <dcoutts> and allow more features
05:24:28 <dcoutts> like basing a tree view on a haskell data model
05:24:50 <jips> interesting
05:24:56 <dcoutts> I need that to make the file browser "live"
05:25:12 <dcoutts> ie update in response to changes in the file system
05:25:32 <jips> how do you monitor changes in the file system?
05:25:46 <dcoutts> inotify or similar or polling
05:26:15 <dcoutts> the new api will also allow us to generate the tree on demand
05:26:16 <jips> is there an inotify haskell interface?
05:26:24 <shapr> I want one!
05:26:32 <dcoutts> rather than holding the whole thing in memory at once
05:26:42 <dcoutts> which is important for very large dir trees (eg / )
05:26:53 <dcoutts> shapr, I think it'll not be too hard
05:26:57 <vincenz> dcoutts: what about menu?
05:26:59 <dcoutts> it's a simple file based api
05:27:25 <dcoutts> vincenz, we'll need that too, to allow plugins toregister their menu / toolbar items
05:27:31 <vincenz> and... can you do cairo Render() before having done initGUI?
05:27:39 <vincenz> so I can have
05:27:44 <vincenz> createWindow :: Render() -> IO ()
05:27:48 <dcoutts> vincenz, yes, but only to non-X surfaces
05:27:52 <vincenz> createWindow drawing = do initGUI ...
05:27:57 <vincenz> dcoutts: I don't draw it yet
05:28:00 <vincenz> it's just a render to be drawn
05:28:27 <vincenz> easy way of adding a button to the menu (File->Save)
05:28:47 <vincenz> ?
05:28:56 <dcoutts> vincenz, you're wonderign how to do it in general or how we'll do it in hIDE ?
05:29:06 <vincenz> no just a quick way of doing it
05:29:09 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/noughty/Noughty.hs
05:29:19 <dcoutts> see makeMenuBar
05:29:22 <vincenz> thx
05:29:57 <vincenz> you just add this to a box?
05:30:04 <dcoutts> That's a new gtk2hs demo by swiert. Thank's swiert! :-)
05:30:24 <swiert> no problem.
05:30:34 <swiert> I see it's already being put to good use.
05:30:38 <dcoutts> vincenz, yes, see main
05:30:44 <dcoutts> swiert, yep :-)
05:31:29 <vincenz> dcoutts: so there's no special menu concept ?
05:31:32 <vincenz> cool :)
05:31:34 <dcoutts> swiert, the only way the demo could possibly be improved is if the nought & cross pics were generated with cairo :-)
05:31:39 <vincenz> so you could add a menubar ANYwhere in a window
05:31:40 <vincenz> not just the top
05:31:44 <dcoutts> vincenz, yes
05:31:53 <dcoutts> vincenz, that's how popups work
05:32:19 <shapr> Oh yes! The PlayStation3 will come with Linux preinstalled! http://lwn.net/Articles/176287/
05:32:40 <swiert> dcoutts: that and adding AI.
05:32:48 <dcoutts> swiert, oh yeah
05:33:00 <vincenz> dcoutts: what is the difference between these
05:33:01 <vincenz>   menuShellAppend fileMenu quit
05:33:02 <vincenz>   menuItemSetSubmenu file fileMenu
05:33:34 <dcoutts> vincenz, I'm not sure, I'd have to check the docs
05:33:50 <vincenz> oki
05:34:17 <dcoutts> swiert, as it is, it's a nice small demo
05:35:00 <swiert> dcoutts: that's what I was thinking as well.
05:35:30 <swiert> adding anything overly complicated kind of makes it unsuitable for a demo.
05:37:03 <dcoutts> yeah
05:37:17 <dcoutts> vincenz, so one adds it to the end of the menu and the other sets a sub menu
05:37:21 <vincenz> ah ok
05:37:30 <vincenz> confusing sometimes :?
05:37:47 <vincenz> I think gtk2hs 1.0 should have a searchable help system
05:37:57 <dcoutts> vincenz, hoogle!
05:37:57 <vincenz> I remember somtimes looking quite a bit for a function and what it does
05:38:03 <vincenz> it's hooglable?
05:38:07 <dcoutts> not yet
05:38:23 <dcoutts> but it will soon I think.
05:38:26 <dcoutts> @seen ndm
05:38:26 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 1 day, 12 hours, 23 minutes and 49 seconds ago, and I have missed 1 hour, 20 minutes and 6 seconds since then.
05:52:42 * shapr boings cheerfully
05:59:35 <shapr> You know you've been writing Haskell too long when this becomes perfectly normal (and working) code: (this_project['logo'] and 'http://codd.fim.uni-erlangen.de/fim/logos/' + this_project['logo']) or nothing
06:01:00 <Saulzar> You mean "writing a mix of Haskell and Python too long" ? :)
06:01:57 <shapr> All other ways to test both existence and truth and even more verbose, so I modelled this on the Haskell in Python tools like: reverse  = lambda x: x.reverse() or x
06:02:29 <shapr> Python function calls return None by default, and many basic ops like list sorting are purely side-effects. Painful, ain't it?
06:03:42 <Saulzar> It's a big IO monad
06:04:23 <vincenz> dcoutts: how do you draw text?
06:04:26 <vincenz> on the drawingArea
06:04:36 <dcoutts> vincenz, see the text cairo demo
06:04:41 <vincenz> nm
06:04:44 <vincenz> ok thx :)
06:05:00 <dcoutts> vincenz, there's a "toy" and a proper text api
06:05:12 * shapr wants gtk2hs for yhc or nhc!
06:05:19 <shapr> Not enough to make time to hack on it myself though =)
06:05:23 <dcoutts> you can use the toy one unless you need it to be effecient or you want more control
06:05:45 <dcoutts> shapr, yeah, I want it too
06:05:55 <Saulzar> I just noticed there is a widget "AspectFrame", after some time ago I did it manually. That looks very useful
06:05:56 <vincenz> ok
06:05:57 <shapr> Especially since it'll mean gtk2hs on my 770.
06:06:03 <dcoutts> shapr, indeed
06:06:05 * shapr hugs his 770
06:06:12 <mathrick> what's [yn]hc?
06:06:30 <shapr> Not a Haskell Compiler, and its derivative Yet Another Haskell compiler.
06:06:31 <dcoutts> Saulzar, yeah. And there's a way of controling the aspect of the top level windos
06:06:32 <shapr> @where nhc
06:06:32 <lambdabot> I know nothing about nhc.
06:06:35 <shapr> @where nhc98
06:06:35 <lambdabot> http://haskell.org/nhc98
06:07:00 <dcoutts> @where+ nhc http://haskell.org/nhc98
06:07:00 <lambdabot> Done.
06:07:15 <dcoutts> @where hugs
06:07:16 <lambdabot> http://haskell.org/hugs
06:07:18 <dcoutts> @where hugs98
06:07:19 <lambdabot> I know nothing about hugs98.
06:08:05 <vincenz> what is fillPreserve?
06:10:52 <shapr> Hm, 187 users today. Pretty good...
06:12:39 <dcoutts> vincenz, it fills but keeps the current path so it can be re-used / extended
06:12:49 <dcoutts> it's an optimisation
06:13:03 <dcoutts> ignore it
06:15:39 <vincenz> hmm
06:15:40 <vincenz> ok
06:15:46 <vincenz> anyways I got something going :)
06:15:53 <vincenz> centerText :: Double -> Double -> String -> Render()
06:15:54 <vincenz> centerText x y text = do (TextExtents xb yb w h _ _) <- textExtents text moveTo (x - xb - w/2) (y - yb - h/2) textPath text stroke
06:15:59 <vincenz> blegh
06:16:08 <vincenz> for some reason it always puts it mono line when I copy from vim
06:16:24 <vincenz> renderTree text tree = do clearCanvas; arc 20 20 10 0 (2*pi); stroke; centerText 20 20 text
06:16:30 * vincenz mutters
06:16:31 <vincenz> forget it
06:16:34 <vincenz> I'll paste it later
06:17:13 <jips> hello dcoutts 
06:17:42 <mathrick> that's what, cairo?
06:18:27 <dcoutts> mathrick, yep
06:18:55 <mathrick> looks funney in haskell
06:19:01 <vincenz> remind me how to match a record in haskell ?
06:19:06 <dcoutts> mathrick, it's better than in C :-)
06:19:07 <vincenz> renderNode x y Leaf = ...
06:19:14 <vincenz> renderNode x y (Node a{}) = ...?
06:19:35 <jips> dcoutts: the cairo people told me cairo's builtin text rendering is only a toy. they told me that for good text rendering, pango is useful. is it possible to use pango with the cairo haskell bindings?
06:19:36 <dcoutts> vincenz, (Node { foo = f, bar = b } )
06:19:44 <vincenz> dcoutts: right but I don't want to match all the fields
06:19:54 <dcoutts> vincenz, (Node { foo = f } )
06:20:02 <vincenz> I don't want to match an field
06:20:06 <vincenz> I just want it to be a Node
06:20:11 <dcoutts> vincenz, (Node { } )
06:20:12 <vincenz> so I can use selectors if and when needed
06:20:16 <vincenz> ah yes
06:20:19 <vincenz> a@(Node {})
06:20:22 <dcoutts> oh then don't bother
06:20:24 <dcoutts> a
06:20:26 <dcoutts> will do
06:20:33 <vincenz> dcoutts: no cause my data type has other constructors
06:20:44 <dcoutts> oh, ok
06:20:46 <mathrick> jips: it binds gtk+ 2.8, which would also mean it's gotta have pangcairo
06:21:05 <mathrick> (almost certainly, I don't believe you could regard them complete otherwise)
06:21:18 <jips> cool
06:21:22 <dcoutts> jips, yes we provide access to both the cairo toy text api and the pango version
06:21:39 <dcoutts> so you can use pango with cairo with gtk2hs
06:21:45 <jips> so i can do complex bidi rendering on a cairo canvas in a gtk app, using only haskell?
06:21:53 <dcoutts> yes
06:21:57 <jips> sweet
06:22:13 <dcoutts> you can render pango layouts
06:22:19 <dcoutts> and they can be fairly complex
06:27:53 <xerox> a@(Node _ _ foo)
06:28:09 <xerox> (I.e. you can still match positionally)
06:41:14 <vincenz> YAY!!!
06:41:20 <vincenz> xerox, dcoutts: check it out
06:41:41 <dcoutts> where?
06:41:45 <vincenz> just a sec
06:41:51 <vincenz> for some reason scping to my home box is SERIOUSLY slow
06:42:36 <vincenz> (aka it connects REALLY slowly)
06:42:50 <vincenz> :/
06:42:57 <vincenz> reeeeeeeeeally slowly
06:43:44 <vincenz> http://oasis.yi.org:8080/test.png
06:44:05 <vincenz> using a quick cairo gui to debug my c++ rb implementation
06:44:09 <dcoutts> nice
06:44:18 <vincenz> (I enable a dumping to a format easily read by haskell)
06:44:24 <dcoutts> you don't like anti-alising do you? :-)
06:44:26 <vincenz> works for any Tree a where (Show a)
06:44:30 <vincenz> dcoutts: nope :P
06:44:56 * vincenz tries with aliasing
06:45:07 <vincenz> hmm I guess it's fine for this
06:45:19 <vincenz> now to draw arrows
06:45:21 * vincenz wrinkles his nose
06:50:34 <vincenz> done
06:51:15 <vincenz> how would I make a scrollable drawingArea?
06:52:13 <vincenz> and make it such that resizing windows does not suddenly make my menubar area bigger
06:52:42 <shapr> edwinb: Do you have a moment for a dependently typed question?
06:54:02 <dcoutts> vincenz, there are packing params to control resizing, you set them when you pack the menubar into the vbox
06:54:10 <dcoutts> see the box docs
06:54:23 <dcoutts> and check out the scrollarea + viewport docs
06:54:30 <vincenz> ok
06:55:20 <int-e> dcoutts: s/scrollarea/ScrolledWindow/?
06:55:31 <dcoutts> int-e, yeah, probably
06:57:04 <vincenz> dcoutts: how exactly
06:57:24 <vincenz> vbox `set [containerChild := mb, something PackNatural, containerChild := canvas]
06:59:10 <edwinb> shapr: sure...
06:59:38 <dcoutts> vincenz, right
07:00:16 <dcoutts> set vbox [containerChile := mb, boxChildPacking mb := PackNatural, containerChild := canvas]
07:00:16 <vincenz> @hoogle getCurrentSize
07:00:16 <lambdabot> No matches found
07:00:51 <vincenz> :)
07:02:25 <vincenz> @hoogle Render Surface
07:02:26 <lambdabot> No matches, try a more general search
07:03:18 <vincenz> blegh
07:03:28 <vincenz> can't even get the current surface size from within Render() so you know how much to fill with white
07:03:57 <shapr> edwinb: AFAIU, Epigram is a terminating-only language, which gives it some disadvantages. Could programs be developed with Epigram or other deptype terminating language and then 'just add fix' to get the safety of the terminating program and the advantages of a full turing complete language?
07:04:27 <edwinb> there's no reason why not. But I think you'd want to avoid it as much as possible.
07:04:37 <shapr> Why so?
07:04:58 <edwinb> knowing about termination gives you some advantages too, such as optimisation opportunities
07:05:16 <shapr> Could you do all the optimizations and add the 'fix' call later?
07:05:17 <edwinb> we know that nothing is ever going to be _|_ for example
07:05:41 <edwinb> you could just add an elimination rule for fix and things would go.
07:06:15 <edwinb> of course, once you have fix, you can't trust your proofs any more either...
07:06:23 <edwinb> so you'd have to use it with care
07:06:46 <dcoutts> vincenz, you can clear without knowing the surface size
07:07:05 <edwinb> I think there has always been a plan to add fix to Epigram, but it's not seen as especially important right now.
07:07:12 <vincenz> dcoutts: oh?
07:07:36 <swiert> shapr: I think there are ideas in that direction.
07:07:58 <dcoutts> vincenz, save >> setOperator OperatorClear >> paint
07:07:58 <dcoutts>  >> restore
07:08:07 <vincenz> ah cool :)
07:08:13 <swiert> shapr: The reason, as edwinb, said that you need to be careful, is that if you have fix, you can't trust your proofs.
07:08:43 <dcoutts> edwinb, I hear they can add it in epigram by using a non-termination monad
07:08:47 <shapr> I'm thinking that you develop without fix, but run with fix. Would that give you safety at dev time and usefulness at runtime?
07:08:57 <dcoutts> just like we use monads to hide IO in Haskell
07:09:01 <edwinb> shapr: you mean as a compilation trick?
07:09:05 <swiert> The right monad is the key.
07:09:10 <dcoutts> you can encapsulate non-termination in epigram in a monad
07:09:20 <vincenz> dcoutts: that's black not white ;)
07:09:35 <dcoutts> swiert, I was told it's nearly all worked out
07:09:38 <edwinb> dcoutts: That seems a more reasonable way to do it. I'm not keeping completely up to date with the mad thoughts of Conor and Thorsten ;)
07:09:38 <shapr> Strong normalization gives lots of advantages, I just wonder if there's some way to have my cake and eat it too :-)
07:09:48 <dcoutts> vincenz, ok use paint with another operator and current colour
07:09:57 <edwinb> At run-time, you just get an ordinary direct recursive call
07:10:01 <swiert> dcoutts: yes - thorsten and tarmo uustalu are working on what they call the partiality  monad.
07:10:05 <edwinb> at least, you will when I get around to implementing a back end...
07:10:20 <dcoutts> swiert, right, partialitiy, not non-termination
07:10:21 <shapr> Neat, I didn't know Uustalu is working on Epigram.
07:11:33 <arjanb> *
07:11:38 <shapr> !
07:11:46 <dcoutts> ?
07:12:07 <swiert> Well, not Epigram directly. The idea is that functions using fix are not necessarily total. They manage to capture that in a suitable monad (I think).
07:12:08 <vincenz> dcoutts: yeah that works, but funnily enough, this way of doing it makes all my letters much bleedier
07:12:11 <edwinb> Chapter 6 of my thesis talks about how elimination rules actually get compiled. It might answer the question you're asking, or it may just read like meaningless drivel ;)
07:12:13 <vincenz> they're hardly readable now
07:12:21 <shapr> Barry Jay mentioned on the types forum that strong normalization is a good way to design a language, and then add fix to get something really useful. I was just trying to clarify all that, thanks :-)
07:12:27 <shapr> edwinb: I'll check it out.
07:12:28 <swiert> So not directly epigram itself, but technology related to it.
07:12:58 <shapr> I'm also interested in whether two programs that require fix to operate can be stuck together and the fix call factored out into a sinlge call.
07:13:02 <dcoutts> vincenz, are you using the toy text api?
07:13:12 <swiert> shapr: I think Conor's mantra is "If it's not structurally recursive, you've got the wrong structure"
07:13:13 <vincenz> dcoutts: not certain?
07:13:20 <vincenz> dcoutts: I'm using "textPath"
07:13:25 <vincenz> combine with stroke
07:13:38 <dcoutts> vincenz, that's going to produce the worst output
07:13:48 <dcoutts> since it's just using vectors without any hinting
07:13:50 <vincenz> showText?
07:14:14 <vincenz> ah yes
07:14:16 <vincenz> -MUCH- better
07:14:19 <dcoutts> pango is better at selecting fonts and hinting/ kernging and using anti-aliasing at various resolutions
07:14:48 <dcoutts> textPath converts some text to vectors
07:14:49 <vincenz> ah I see... I had accidentally removed setLineWidth
07:15:24 <dcoutts> which is ok at high sizes, it allows you to add more effects, etc but it's not good for readability at low point sizes
07:15:34 * vincenz nods
07:15:37 <vincenz> using showText now
07:15:40 <vincenz> instead of textPath
07:15:47 <dcoutts> using the pango api is even better
07:15:49 <vincenz> I take it I still have to stroke after?
07:15:51 <dcoutts> but a little harder
07:15:58 <vincenz> dcoutts: where is it mentioned?
07:16:03 <dcoutts> no, with showText it just does it
07:16:19 <dcoutts> vincenz, Graphics.UI.Gtk.Cairo
07:16:27 <vincenz> I meant the pango bit
07:16:30 <dcoutts> yes
07:16:33 <vincenz> oh
07:16:34 * vincenz coughs
07:16:45 <vincenz> I'll take a look :)
07:17:20 * vincenz scratches his head
07:17:27 <vincenz> there's not a single Char or String in any of those methods
07:17:39 <vincenz> oh nm
07:17:40 <vincenz> createLayout
07:18:36 <shapr> edwinb, swiert: I'd still like to see a deptype tutorial for the Haskell masses :-)
07:18:57 <shapr> Maybe one day...
07:19:53 <swiert> shapr: Conor's AFP lecture notes are pretty accessible.
07:20:32 <edwinb> hopefully such a thing will happen one day...
07:20:42 <edwinb> I think we all want to have one, but nobody wants to/has time to write one...
07:26:22 <shapr> Random question.. linear types seem to be the next step past referential transparency. Anyone feel like commenting on that? Is it true?
07:26:34 <jips> eh?
07:27:28 <swiert> Can you be a bit more explicit?
07:28:14 <shapr> Referential transparency gives you some particular 'cleanliness' in that values cannot be mutated. Linear types are even more strict in that you can only have a single reference to a value. Linear types seem to give optimization opportunities not available with multiple reference systems.
07:28:54 <shapr> I guess my question is, are there other handy limits like referential transparency and linear types? If so, got any names I can look up?
07:29:10 <swiert> Uniqueness types.
07:29:20 <shapr> Hm, right.
07:29:35 <swiert> I think they're the right way to go, as opposed to linear types. Check out Dana Harrington's thesis.
07:29:38 <shapr> I guess strong normalization might fit in there also.
07:29:42 <kosmikus> aren't "linear types" and "uniqueness types" synonyms?
07:29:54 * shapr doesn't know
07:30:10 <shapr> I don't think so...
07:30:13 <swiert> No. There's a distinction.
07:30:30 <shapr> A unique value could still have multiple references to it.
07:30:34 <shapr> A linear value cannot.
07:30:41 <swiert> Linear types guarantee that a value will only be used once.
07:30:58 <swiert> Uniqueness types guarantee that a value has only been used once so far.
07:31:05 <swiert> That is the hand waving explanation.
07:31:16 <kosmikus> hmm, ok
07:31:18 * shapr was totally confused..
07:31:37 <swiert> Check out: http://pages.cpsc.ucalgary.ca/~danaha/uniqueness-types.ps
07:31:52 <swiert> There's some really good stuff there, but it's not for the faint hearted.
07:31:53 <shapr> That's the thesis?
07:31:57 <swiert> Yes.
07:32:52 <swiert> Page 18-19 discuss linear vs uniqueness types.
07:33:23 <shapr> This is neat, have you mentioned it on LtU?
07:33:41 <swiert> No. Feel very welcome to though.
07:34:30 <swiert> The important difference is that there is a subtype coercion between a unique and non-unique type.
07:34:51 <shapr> Looks like you could actually have a linear uniqueness type :-)
07:35:33 <swiert> I don't think so. There's a neat duality between the rules for unique/linear types.
07:37:59 <shapr> Wouldn't something that gave information on both future and past uses of a variable be a linear unique type?
07:39:03 <shapr> I should probably read the whole thesis before asking silly questions.
07:40:30 <swiert> I wouldn't read the whole thesis unless you're into hard-core category theory...
07:40:42 <swiert> Stick to the first twenty odd pages.
07:42:33 <shapr> Category theory is great. Wish I understood it...
07:43:50 <swiert> Yeah, I kind of lose the plot when he starts about "a uniqueness category is a symmetric monoidal category with a symmetric isomonoidal endofunctor which is both a monoidal idempotent monad and a monoidal cocommutative comonoid."
07:46:03 <shapr> swiert: Can I quote that? :-)
07:47:15 <edwinb> I usually assume such long category theory mumbo jumbo statements simply mean "function" ;)
07:48:06 <swiert> Well, I think it says that the functor is gives you a way to think of "more than one occurrence" - like lists in Haskell.
07:48:47 <swiert> I recognize a few words - but haven't wrestled through the details.
07:48:52 <swiert> shapr: sure.
07:49:05 * dcoutts hugs natural transformations
07:50:24 <tenni1> scannedinavian is down?
07:50:28 <shapr> I know symmetric, endofunctor, idempotent, and monoidal. Isomonoidal, cocommutative, and comonoid lose me.
07:50:35 <shapr> tennin: What do you need?
07:50:55 <shapr> Cocommutative would that it commutes with its dual?
07:51:07 <tennin> I wanted to look at hIDE from the repository
07:51:18 <shapr> The hIDE repo has moved to haskell.org
07:51:28 <shapr> I should probably put up a redirect...
07:51:38 <swiert> A comonoid has a operation :: a -> (a,a).
07:52:03 <tennin> ok
07:52:05 <shapr> Ah, comonads a la Uustalu.
07:52:52 <shapr> Ok, what's an isomonoid?
07:53:07 <swiert> It is cocommutative if sulp = swap . sulp
07:53:21 <tennin> what about ghc-api?
07:53:31 <shapr> tennin: All the scannedinavian repos moved to haskell.org
07:53:33 <swiert> where sulp is the binary operation and swap (x,y) = (y,x).
07:53:41 <jips> ghc-api needs a blog
07:53:48 <tennin> ok, thanks.
07:54:02 <jips> in general, haskell needs a lot more blogs
07:54:02 <swiert> I think isomonoidal is a monoidal functor where you have isos as opposed to equality "on the nose".
07:54:19 <swiert> But that is pure speculation on my part.
07:54:29 <tennin> the haskell web's current state of flux is confusing me
07:54:48 <shapr> Scannedinavian changes are entirely due to me.
07:54:53 <shapr> It's my server and domain name.
07:55:38 <shapr> I hosted darcs repos and web pages for a few years when it was pretty much the only way get free Haskell hosting.
07:56:07 <shapr> But it got expensive, and I had to stop.
07:57:37 <shapr> Also, haskell.galois.com showed up, so now there's a more community involved host. Galois is probably the largest Haskell company.
07:57:40 <vincenz> YAY
07:57:42 <vincenz> my paper got accepted
07:57:52 <shapr> Cool! What's the paper about?
08:16:38 <araujo> Hello!
08:22:15 * vincenz just got another person interested in haskelll at work :)
08:22:23 <vincenz> the insidious virus continues
08:22:39 <vincenz> shapr: a profiling library written on top of c++ templates 
08:22:55 <vincenz> for data profiling
08:22:56 <vincenz> not time
08:23:23 <Saulzar> data profiling?
08:23:37 <vincenz> data-access
08:24:05 <Saulzar> Hmm, things like memory access patterns?
08:24:09 <vincenz> yep
08:24:13 <vincenz> allocation patterns
08:24:18 <vincenz> right now even higher level
08:24:21 <vincenz> like ddt-access patterns
08:24:30 <vincenz> for instance for vector/list or map/like ddt
08:24:41 <vincenz> s/map\/like/map- like/
08:24:51 <Saulzar> ddt?
08:24:55 <vincenz> dynamic data structure
08:25:19 <vincenz> the tool of this thing is written in ocaml
08:25:23 <vincenz> but I want to rewrite in haskell
08:25:28 <vincenz> but I'm worried it won't pay off after the work
08:25:29 <Saulzar> Hmm, recognition kind of thing?
08:25:39 <vincenz> (cause I typically have to do analysis of plural-gigabyte files)
08:25:54 <Saulzar> Yow
08:25:59 <vincenz> yeah
08:26:08 <vincenz> this one application which is a kernel of MPEG4
08:26:13 <vincenz> generates a whopping 2 GB of data
08:26:20 <vincenz> (and this data is in a custom binary format to save on space)
08:27:12 <vincenz> it'd be cool to use haskell tho
08:27:23 <vincenz> o.O
08:27:37 <Saulzar> Hehe..
08:27:49 <vincenz> no cause I'm a bit upset at my ocaml implementation
08:27:54 <vincenz> ocaml forces a lot of duplicity of code
08:28:26 <shapr> If you work on separate chunks you can build a lazy pipeline.
08:28:37 <vincenz> it's very non-parallelisable
08:29:03 <vincenz> cause your malloc trace defines your active blocks... and then your memory accesses with a certain address will target these active blocks
08:29:10 <shapr> A lazy pipeline means your max memory usage would be the largest chunk plus the runtime.
08:29:15 <vincenz> oh
08:29:18 <vincenz> that is already so
08:29:21 <vincenz> :)
08:29:40 <shapr> What sort of payoff would you hope to get from a Haskell rewrite?
08:29:53 <vincenz> shapr: easier extensibility due to cleaner code
08:29:57 <shapr> Maintainability will likely increase from what you say about code duplication.
08:30:03 <vincenz> right
08:30:15 <vincenz> and possibly extend later to use neat features like cairo to make the reports more visual
08:30:57 <vincenz> o.t.o.h, my fears are a) lack of binary io, b) amount of work, c) explosion in mem-space or runtime
08:31:25 <vincenz> d) bitching users
08:31:40 <shapr> heh
08:31:44 * dcoutts fears bitching users too
08:31:45 <shapr> d) is always a worry :-)
08:32:48 <vincenz> see people usually darcs-get the c++ code and the ocaml code, build the ocaml code, use the c++ code in their apps and then use the ocaml-tool to analyse profiling, swtiching to haskell would mean they'd need ghc installed
08:32:49 <jips> hello dcoutts 
08:33:15 <Saulzar> Hmm, more people have ocaml installed than ghc?
08:33:57 <vincenz> no but it'd be another step
08:34:03 <Saulzar> Could always give them a binary I suppose
08:34:08 <vincenz> mainly it's b) and c) tho
08:34:54 <Saulzar> How big is the project? (and who are you doing it for?)
08:36:44 <Saulzar> Rewriting a large amount of code to change language doesn't seem too fun, if it works
08:37:04 <vincenz> > foldl1 (+) [1364, 1083, 160, 1382, 546]
08:37:05 <lambdabot> 4535
08:37:16 <vincenz> * wc'd all the .ml and .mli files
08:37:26 <shapr> Saulzar: It can be a blast...
08:37:33 <vincenz> shapr: not from ocaml to haskell
08:37:39 <shapr> Not fun?
08:37:47 <vincenz> recoding?
08:37:47 <vincenz> no
08:38:00 <shapr> I enjoy getting the opportunity to explore new abstraction possibilities.
08:38:04 <jips> isn't there an automatic converter from ocaml to haskell code?
08:38:07 <vincenz> Saulzar: I'm hoping to gain extensibility
08:38:13 <shapr> I always have such huge time pressure that I never end up with a solution I really like.
08:38:27 <vincenz> jips: for oo?
08:38:37 <jips> vincenz: huh?
08:38:45 <shapr> Sometimes I get a feature request in the morning along with a desperate cry to have it working by noon.
08:38:48 <vincenz> my analysis machines are currently objects
08:38:57 <vincenz> shapr: I have sparse deadlines
08:39:00 <vincenz> but I have other priorities
08:39:04 <jips> vincenz: for the entire ocaml language
08:39:09 <shapr> My deadlines are sparse too... like Cantor dust ;-)
08:39:24 <Saulzar> Hmm, one wonders what that would do ..
08:39:24 <vincenz> I'm just wondering if using haskell will allow me to more easily add new analysis options
08:39:30 <shapr> vincenz: prototype it!
08:39:30 <vincenz> jips: I doubt what comes out would be clean
08:39:31 <Saulzar> Turn everything into IO code?
08:39:47 <vincenz> shapr: spike it?
08:39:50 <shapr> yes
08:39:53 <vincenz> I've been considering it
08:39:57 <vincenz> but then binary io turned me away
08:40:09 <vincenz> I started it until I had to read in my first packet
08:40:11 <shapr> Have you tried Bulat's code?
08:40:15 <vincenz> NewBinary?
08:40:30 <vincenz> plus ... that's a cabal pacage
08:40:33 <vincenz> meaning more work for users
08:40:34 <JKnecht> how about straight caml to h ?
08:40:36 <vincenz> unless I copy paste the file
08:40:44 <vincenz> JKnecht: I doubt that would serve much
08:40:47 <shapr> NewBinary is Jeremy Shaw by way of Hal Daume by way of GHC by way of NHC98.
08:41:08 <shapr> Bulat is the guy who wrote FreeArc in Haskell.
08:41:29 <shapr> hiya sgordon, how's code?
08:41:40 <vincenz> which binary code then
08:41:49 * shapr gets url...
08:42:05 <shapr> Bulat Ziganshin, that's his name...
08:42:08 <vincenz> yeah I know
08:42:11 <vincenz> just don't know which lib
08:42:12 <sgordon> hello
08:42:13 <shapr> That guy talks more than I do.
08:42:16 <vincenz> anyways /me is off to smoke
08:42:22 <shapr> Hey, that's bad for you.
08:42:27 <shapr> sgordon: Are you new to Haskell or #haskell ?
08:42:33 <sgordon> Yes; yes
08:42:41 <shapr> musasabi: Did you decide to try skip lists?
08:42:54 <shapr> sgordon: Nifty, learning for fun, school, or work?
08:43:03 <shapr> Different paths for different goals, you know...
08:43:08 <shapr> Would you like a short tour of #haskell?
08:43:14 <vincenz> skiplists are cool
08:43:16 <sgordon> mostly fun; may end up being work
08:43:19 <vincenz> but they're not really O(N)
08:43:29 <shapr> vincenz: Yeah, but musasabi wanted STM binary trees.
08:43:43 <vincenz> shapr: why binary trees perse?
08:43:53 <vincenz> I mean in the end it's gonna be something : key -> value
08:44:06 <vincenz> binary tree is an implementation choioce that in this case might have been too early
08:44:06 * shapr dunno
08:44:12 <sgordon> shapr: umm ... where is the "I tried to run this program from the textbook and I get a strange error" section?
08:44:20 <vincenz> especially rebalancing them isn't very healthy for multitreading
08:44:40 <shapr> sgordon: Lemme guess, Paul Hudak, "The Haskell School of Expression" and chr and ord are failing?
08:44:56 * vincenz thought the other post regarding the trainstations was blatant homework
08:45:14 <sgordon> close--Hudak, and the first graphics program on pp40-41 gives me a "Last generator in do {...} must be an expression" error
08:46:08 <shapr> Hm, my copy of Hudak is at my girlfriend's house... Can you paste the program into the bot?
08:46:22 <shapr> huh, where's the bot?
08:46:29 <sgordon> I was about to ask the same question...
08:46:55 <sgordon> (new to Haskell, #haskell, *and* this IRC client...)
08:47:16 <shapr> Hm, I dunno where the pastebot went to...
08:47:35 <shapr> but you can use http://rafb.net/paste/
08:49:05 <sgordon> ok, it's at http://rafb.net/paste/results/5gaCOZ45.html
08:50:33 <shapr> Hm, looks okay to me...
08:50:51 <shapr> You may want to try putting that other chunk into its own function and then passing that name to runGraphics
08:51:48 <wchogg> Couldn't it be indentation?
08:52:27 <sgordon> hmmm...
08:52:42 <shapr> Yeah, it could be.
08:52:42 <sgordon> emacs haskell-mode kept telling me I only had one option as to indentation, but maybe I shouldn't believe it
08:52:52 <shapr> Are you using haskell-mode 2.x ?
08:53:05 <wchogg> This might be stupid, but why not push in lines 5-7 to line up with the "w" after the do.
08:53:28 <shapr> Oh yeah
08:53:33 <shapr> That might fix it.
08:53:57 <sgordon> bingo!
08:54:37 <sgordon> thanks, y'all
08:54:45 <shapr> sgordon: Any other questions?
08:54:57 <sgordon> not for now...
08:55:08 <shapr> Do you work for metacarta?
08:55:11 <sgordon> ayup
08:55:14 <shapr> Hm, neat.
08:55:39 <shapr> I've been thinking about location aware todo lists recently.
08:55:44 <sgordon> we do a lot of python here so you'd think I'd have gotten the hang of this whitespace thing by now
08:56:40 <shapr> Haskell's whitespace includes the 'offside rule' (which I've forgotten at the moment), making it slightly more complicated than Python.
08:57:08 <jips> haskell's layout rules are i think the most complicated of any programming language
08:57:19 <davidhouse> shapr, the offside rule is where an attacking player has one or zero defending players in front of him when the ball is passed to him
08:57:21 <davidhouse> :)
08:57:25 <shapr> sgordon: Oh hey, you might know... can a gps receiver discover its direction?
08:57:32 <sgordon> I think I was just thrown by the example program because it was broken across a page boundary
08:57:37 <shapr> davidhouse: Yeah, and I always wanted to play fastback in football.
08:58:48 <shapr> sgordon: lambdabot has a bunch of useful tools.
08:58:51 <shapr> @type Data.chr
08:58:52 <lambdabot> Couldn't find qualified module.
08:58:52 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
08:58:55 <shapr> whoops
08:58:57 <sgordon> shapr: to my knowledge, you'd need another source of information like a compass--the gps system doesn't have enough resolution
08:59:09 <sgordon> anyway, got a lunch/meeting to go to.  thanks again!
08:59:14 <shapr> ok, have fun.
08:59:21 <shapr> @type Data.Char.chr
08:59:22 <lambdabot> Int -> Char
08:59:24 <shapr> @type Data.Char.ord
08:59:25 <lambdabot> Char -> Int
09:01:24 <shapr> hi bringert, long time no see.
09:03:56 <bringert> :-)
09:05:23 <wchogg> I can never remember, is Int fixed size or is Integer?
09:05:42 <bringert> Int
09:06:00 <wchogg> Cool, thanks.
09:06:13 <ibid> memory aid: Integer is longer :)
09:06:15 <jips> just like the c "int"
09:33:18 <monadic_kid> Lemmih: if you're there, i managed to make a build of your binding in the end, i just i had to read about Cabal files and added "include-dirs:" option :)
09:33:57 <monadic_kid> now if you only they would work on win32 :/
09:40:11 * shapr throws lambdas
09:41:00 * kosmikus catches a lambda and eats it
09:41:47 <tic> chomp chomp
09:43:00 <shapr> kosmikus: did you see my 'Shall I compare thee to #haskell' parody?
09:43:11 <kosmikus> no
09:43:28 <shapr> http://www.scannedinavian.com/~shae/shallIcompare.text
09:43:35 <shapr> Just something else to distract me from real work...
09:43:55 <shapr> So, anyone exploring new fun stuff?
09:44:37 <kosmikus> nice
09:52:07 <shapr> Anyone written cool code lately?
09:52:18 <Saulzar> I've written a lot of boring code :)
09:52:42 <Lemmih> Hiya SyntaxNinja.
09:52:43 <shapr> hiya SyntaxNinja 
09:52:47 <shapr> Saulzar: In Haskell?
09:53:04 <Saulzar> shapr, Yeah
09:53:12 <SyntaxNinja> y0y0
09:53:21 <shapr> Saulzar: What are you writing?
09:53:38 <Saulzar> shapr, Same old thing, robot AI game
09:53:38 <SyntaxNinja> every time I log in, I have to close 4 tabs, nickserv, chanserv, messageserv, and something else.  It's realy annoying.
09:54:22 <shapr> Maybe you can set xchat to not popup new tabs on NOTICE?
09:55:13 <dcoutts> SyntaxNinja, I use xchat and it doesn't do that for me
09:59:19 * shapr boings randomly
10:02:48 <wchogg> Bored, shapr?
10:12:57 <SyntaxNinja> hm
10:14:07 <shapr> wchogg: Yeah, tired of Python coding.
10:15:17 <dcoutts> we need a European Haskell consultency outfit
10:19:34 <vincenz> dumdumdumd
10:19:51 <shapr> Descolada|Work: Hi, still at work?
10:19:56 <vincenz> dcoutts: yeah... finally something for europe...unlike those brits
10:20:01 <Descolada|Work> allways it seems
10:20:29 <Descolada|Work> taking some downtime to try to learn haskell
10:20:50 <shapr> Good idea. Do you have any prior experience with functional languages, or jumping right in?
10:21:18 <Descolada|Work> ive got my goggles and snorkle baby
10:21:32 <vincenz> don't forget the flippers
10:21:40 <Descolada|Work> oh, right
10:21:43 <shapr> Descolada|Work: Want the quick tour?
10:21:50 <dcoutts> vincenz, is there a UK Haskell consultency?
10:21:59 <Descolada|Work> naw, just a few questins
10:22:09 <shapr> Descolada|Work: go for it!
10:22:13 <vincenz> dcoutts: I don't know... I was just poking fun at the uk-vs-europe on purpose, knowing you're from uk
10:22:23 * vincenz adds the explicit :P
10:22:30 * dcoutts is not a uk nationalist
10:22:43 <shapr> I think John Meacham is LA too, maybe you can start a Haskell gathering :-)
10:22:53 <vincenz> dcoutts: I was just kidding, but that's good to hear :)
10:24:01 <Descolada|Work> data BSPNode = BSPPlane { plane :: Plane, left :: BSPNode, right :: BSPNode }
10:24:01 <Descolada|Work> if i have somthing like that, and i want to access a BSPPlane in a function like
10:24:01 <Descolada|Work> pointTrace (start, end, node@(?))
10:24:01 <Descolada|Work> what do i put in the question mark?
10:24:02 <shapr> Hiya fiete, new to Haskell?
10:24:17 <vincenz> dcoutts: pro or contra euro-coinage?
10:24:22 <shapr> Descolada|Work: ooh, are you working on Frag?
10:24:25 <fiete> hmm not really, but Im not really skilled
10:24:40 <Descolada|Work> no, just learning by making my own stuff
10:24:52 <shapr> Oh, I thought you might be working on the Quake clone written in Haskell.
10:24:52 <fiete> shapr: it has been quite some time
10:24:57 <shapr> fiete: Welcome back then!
10:25:02 <Descolada|Work> learning until i can make my own port of quake2 that is
10:25:15 <shapr> Descolada|Work: You could extend the existing port of quake1 :-)
10:25:30 <Descolada|Work> i could, but then i wont learn it all >:)
10:25:42 <dcoutts> vincenz, (+1) euro
10:25:47 <fiete> shapr: :-) I remember that it was somehow possible to embed latex in haskell sources. am i right?
10:25:53 <mauke> Descolada|Work: node@BSPPlane { ... }
10:26:05 <shapr> fiete: Yup, .lhs files
10:26:12 <dcoutts> fiete, \begin{code} ... \end{code}
10:26:17 <dcoutts> (I think)
10:26:24 <fiete> cool ty
10:26:32 <shapr> Darcs sources are done that way.
10:26:33 <vincenz> is it possible to hide stuff in a .lhs file 
10:26:43 <Descolada|Work> in the ... i put somthing like { plane left right } ? or just leave it as ...
10:26:45 <shapr> vincenz: You mean fold stuff out of view via the editor?
10:26:53 <vincenz> shapr: no .. hide it in the .pdf
10:27:06 <vincenz> shapr: like some low level crud which is needed to make it run but you don't want to add into the printable pdf
10:27:08 <dcoutts> fiete, if you use latex, see also lhs2tex
10:27:09 <shapr> I think so, but I know almost nothing about LaTeX.
10:27:15 <vincenz> I meant with lhs2te
10:27:15 <vincenz> x
10:27:19 <Descolada|Work> and if possible could you point me to some documentation that could help too?
10:27:21 <shapr> Yeah, check out kosmikus' lhs2TeX.
10:27:29 <shapr> @oldwiki HaskellDemo
10:27:30 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
10:27:32 <vincenz> kosmikus: ping
10:27:41 <vincenz> kosmikus: is it possible to not have certain code show up in the tex?
10:27:42 <dcoutts> http://www.iai.uni-bonn.de/~loeh/lhs2tex
10:27:50 <kosmikus> vincenz: ?
10:28:01 <fiete> shapr: ok
10:28:02 <shapr> Descolada|Work: The HaskellDemo is a simple syntax demo. Is that the sort of thing you want?
10:28:05 <kosmikus> vincenz: you mean like %if False, %endif ?
10:28:45 <vincenz> kosmikus: well you have haskell code indented by > in the .lhs fie and you can run this as haskell source, now what if you wanted to make the .tex with lhs2tex... but certain lowlevel functions that are not relevant to the paper are needed to make it run, is it possible to hide them in the tex
10:29:19 <Descolada|Work> yes
10:29:22 <Descolada|Work> thank you
10:29:58 <vincenz> Blegh, I'm resident of too many channels
10:30:10 <kosmikus> vincenz: sure, see above
10:30:35 <shapr> Descolada|Work: Any other questions? Have you tried Frag yet?
10:30:47 <vincenz> kosmikus: I'm not certain I see it... could you make a tiny demo?
10:30:51 <vincenz> wait let me make a paste
10:31:12 <Descolada|Work> i have looked at it
10:31:27 <Descolada|Work> not quite what i want
10:31:43 <vincenz> http://rafb.net/paste/results/HgdJlp50.html
10:31:49 <shapr> Descolada|Work: What sort of documentation do you want?
10:32:15 <kosmikus> vincenz: %if False\n\n> code you don't want in the .pdf\n\n%endif
10:32:23 <vincenz> oh :)
10:32:30 <Descolada|Work> well, as soon as i can look at that haskeldemo ill have a better idea
10:32:30 <vincenz> what language is %if?
10:32:35 <vincenz> that's not latex
10:32:48 <kosmikus> vincenz: no, that's lhs2tex, like %format etc.
10:33:12 <sieni> well, probably not, since % denotes a comment in latex
10:33:35 <kosmikus> vincenz: see Section 10 of Guide2.pdf on "Conditionals"
10:34:57 <vincenz> thx
10:35:47 <vincenz> > "kosmikus" == "Ralf Hinze"
10:35:48 <lambdabot> False
10:35:54 <vincenz> > "kosmikus" == "Andres Loh"
10:35:55 <lambdabot> False
10:35:57 <vincenz> hmm
10:36:02 <vincenz> lambdabot: ok thx
10:36:23 <vincenz> > "kosmikus" == "loeh"
10:36:24 <lambdabot> False
10:37:11 <lambdabot> True!
10:37:35 * vincenz blinks
10:37:43 <davidhouse> that was odd.
10:37:49 <davidhouse> > True
10:37:50 <lambdabot> True
10:38:00 <davidhouse> > True!
10:38:00 <lambdabot>  parse error on input `}'
10:38:11 <mauke> < rjbs> Lolerscates, the famous Greek comedist.
10:39:14 * davidhouse wonders whether anyone has submitted a haskell workshop paper yet
10:39:23 <davidhouse> and if i can view them if 'yes'.
10:39:38 <Descolada|Work> > length [2..4]
10:39:39 <lambdabot> 3
10:39:45 <Descolada|Work> neet
10:39:50 <davidhouse> > [2..4]
10:39:51 <lambdabot> [2,3,4]
10:39:57 <davidhouse> Descolada|Work: know what's even better?
10:40:04 <Descolada|Work> ice cream?
10:40:05 <davidhouse> > take 10 [1..]
10:40:05 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
10:40:08 <vincenz> > [1,2..4]
10:40:09 <lambdabot> [1,2,3,4]
10:40:09 <davidhouse> infinite lists :)
10:40:12 <vincenz> > [1,3..5]
10:40:13 <lambdabot> [1,3,5]
10:40:18 <vincenz> > [1,3..9]
10:40:18 <Descolada|Work> i know about those
10:40:19 <lambdabot> [1,3,5,7,9]
10:40:29 <davidhouse> > ['a'..'z']
10:40:30 <lambdabot> "abcdefghijklmnopqrstuvwxyz"
10:40:42 <davidhouse> > [' '..'z']
10:40:43 <lambdabot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
10:42:05 <davidhouse> @index Enum
10:42:05 <lambdabot> Prelude
10:43:09 <davidhouse> > [1.1, 9.0]
10:43:10 <lambdabot> [1.1,9.0]
10:43:12 <davidhouse> > [1.1..9.0]
10:43:13 <lambdabot> [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1]
10:43:22 <Descolada|Work> strange
10:43:26 <davidhouse> indeed
10:43:37 <davidhouse> well, it'd be a little hard to enum them any other way
10:43:44 <davidhouse> seeing as the reals aren't well ordered
10:43:57 <Descolada|Work> i thought it would go up by the smallest amount, like 1.1 would be 0.1 and 1.02 would be 0.01
10:44:26 <robokop> >[10,9..1]
10:44:33 <robokop> > [10,9..1]
10:44:33 <Descolada|Work> is there a way to specify the amount?
10:44:34 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
10:44:43 <wchogg> Yeah, just specify another element.
10:44:50 <wchogg> >[1.1,1.2..9.0]
10:45:06 <Descolada|Work> ok
10:45:15 <wchogg> Crap.  I just tried almost the same thing in hugs.
10:45:19 <shapr> And?
10:45:27 <robokop> > [1.1,1.2..1.9]
10:45:28 <lambdabot> [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999999999994,1.6999999999999993,1.7999999999999992,1.899999999999999]
10:45:36 <Descolada|Work> wha?
10:45:45 <shapr> And now we discover the limitations of IEEE754.
10:45:56 <Descolada|Work> lol
10:45:59 <robokop> muhahaha
10:46:31 <shapr> If Ratio has an Enum definition, you'll probably get what you expected.
10:47:19 <shapr> > [3%7,4%7 .. 9%7]
10:47:20 <lambdabot> [3%7,4%7,5%7,6%7,1%1,8%7,9%7]
10:47:58 <shapr> > take 5 [6%16,5%15 .. ]
10:47:59 <lambdabot> [3%8,1%3,7%24,1%4,5%24]
10:48:14 * shapr is confused.
10:48:46 <sieni> shapr: how so?
10:49:25 <shapr> Shouldn't the third one be 4%14 ?
10:49:26 <wchogg> After 5/15 should come 4/14 or 2/7, instead you got 7/24?
10:50:01 <shapr> Maybe it takes the value of 6%16 - 5%15 and that's the increment?
10:50:02 <sieni> wchogg: where did you learn mathematics?
10:50:16 <sieni> shapr: indeed
10:50:26 <sieni> isn't that what it should do?
10:50:27 <jips> hello shapr 
10:50:37 <shapr> hiya jips, how's code?
10:50:42 <shapr> sieni: Yes, I think so.
10:50:54 <wchogg> sieni's right.  We were looking at the literal pattern.
10:51:02 <shapr> Yeah
10:51:16 <jips> shapr: i'm about to attempt coding a html+css renderer/browser using cairo and gtk
10:51:39 <shapr> neato!
10:51:39 <dcoutts> jips, that's ambitious!
10:52:20 <jips> well, there's already a really good html/xhtml parser for haskell, haskell xml toolbox, which is really good and has a sweet arrow interface
10:52:36 <jips> and the core of css 2.1 is pretty simple
10:52:51 <jips> so getting something basic working shouldn't be too hard
10:53:00 <dcoutts> jips, ok, I was under the impression that css 2.x was hard
10:53:07 <zamez> I have a simple CSS parser in Haskell if you want it, jips 
10:53:07 <dcoutts> the box model thing
10:53:17 <jips> zamez: cool
10:53:36 <zamez> http://zamez.org/factorcss
10:53:49 <jips> dcoutts: i'll start with only the simplest parts of the box model... no floating or absolute positiong
10:54:03 <dcoutts> ok right
10:54:19 <Descolada|Work> is there a haskell on rails? lol
10:54:30 <dcoutts> jips, sounds doable then, sounds fun actually
10:54:55 <dcoutts> Descolada|Work, there are various Haskell web frameworks
10:55:10 <Descolada|Work> neet
10:55:20 <dcoutts> eg wash
10:55:23 <dcoutts> @where wash
10:55:24 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
10:55:35 <jips> dcoutts: my eventual goal is a usable and light browser that i can use for my everyday browsing. like dillo or links-g, but with css support
10:56:01 <dcoutts> jips, cool, or for a light weight html component/widget we can embed in other apps?
10:56:52 <jips> dcoutts: sure, i guess so.
10:56:53 <shapr> jips: What about starting with MozEmbed?
10:56:55 <ValarQ> zamez: it sure made my css smaller :)
10:57:09 <ValarQ> zamez: it reduced it to a single comment
10:57:10 * shapr is just wondering.
10:57:20 <jips> shapr: bloated :)
10:57:22 <robokop> just curious to know is it possible to write driversoftware with haskell
10:57:35 <zamez> heh
10:58:12 <zamez> there are various bugs
10:58:33 <robokop> i once wrote a dmx driver in pascal
10:59:00 <robokop> so maybe rewriting it in haskell if possible
10:59:14 <shapr> robokop: sure - http://www.cse.ogi.edu/~hallgren/House/
11:01:43 <neologism> it seems to be alive and doing well
11:03:23 <jips> first things first though - make that hs-plugins patch and get it to dons
11:03:28 <jips> \seen dons 
11:03:29 <lambdabot> dons is in #haskell. Last spoke 15 hours, 1 minute and 46 seconds ago.
11:09:47 <jips> anyone here familiar with darcs?
11:10:44 <Descolada|Work> for that CSS thing, what languages are x and y?
11:10:45 <shapr> me me!
11:11:39 <jips> shapr: i darcs get this repository
11:11:43 <jips> shapr: now i've edited a file
11:11:55 <jips> shapr: how can i submit the patch to the author?
11:12:12 <davidhouse> isn't there a darcs send?
11:12:58 <davidhouse> yeah, i think you want darcs record then darcs send
11:16:49 <davidhouse> all right guys, i need a nice OSS project to get my teeth into
11:17:01 <zamez> Descolada|Work: .x is alex, .y is happy
11:17:02 <davidhouse> anyone need a plugin or module written for their software?
11:17:55 <zamez> http://www.haskell.org/alex/ http://www.haskell.org/happy/
11:19:02 <davidhouse> or, y'know, any bugs that need fixing
11:19:07 <davidhouse> be imaginitive
11:20:30 <Lemmih> GHC got quite a few open bugs.
11:21:03 <davidhouse> Lemmih: easy ones?
11:22:03 <Lemmih> No, not really. The easy ones are usually the first to be fixed.
11:22:38 <davidhouse> true.
11:23:01 <mathrick> anyone with bison/yacc skills?
11:24:20 <palomer_> hullo!
11:24:27 <palomer_> man I'm bored
11:25:11 <mathrick> http://pastebin.com/614774
11:25:25 <palomer_> ok newbs, ask me questions while I'm still bored
11:25:32 <mathrick> it gives me errors about `program' not deriving any sentence
11:26:02 <mathrick> palomer_: feel free to debug my bison problems
11:27:10 <palomer_> bison with haskell?
11:27:33 <mathrick> no, with C
11:31:53 <davidhouse> > [False .. True]
11:31:53 <lambdabot> [False,True]
11:31:57 <davidhouse> > [False..True]
11:31:58 <lambdabot>  parse error on input `False..'
11:32:02 <davidhouse> what's that about?
11:32:15 <twobitsprite> how do you specify the type of a function when defining it with the "let ..." form in ghci?
11:32:44 <davidhouse> twobitsprite, type annotations might work
11:32:53 * mathrick remember someone with nick staring with P and very good with parsers earlier today in here...
11:32:58 <mathrick> but he's not around now
11:33:05 <mathrick> *remembers
11:33:06 <davidhouse> > let f a = a + 3::(Int -> Int) in f 4
11:33:06 <lambdabot>  add an instance declaration for (Num (Int -> Int))
11:33:14 <davidhouse> > let (f a = a + 3)::(Int -> Int) in f 4
11:33:15 <lambdabot>  parse error on input `='
11:33:20 <davidhouse> nah. dunno then
11:33:24 <twobitsprite> hmm
11:33:37 <davidhouse> twobitsprite: why would you need to?
11:33:49 <Lemmih> > let f :: Int; f = 10 in f
11:33:50 <lambdabot> 10
11:33:59 <twobitsprite> Lemmih: ahh, thanks
11:34:00 <davidhouse> ah, so you can do it that way
11:34:07 <palomer_> does the standard haskell regexp library use perl regexp syntax or posix regexp syntax?
11:34:22 <Igloo> davidhouse: False.. is (.) from module False
11:34:42 <davidhouse> @index (.)
11:34:43 <lambdabot> Prelude
11:34:48 <davidhouse> Igloo: ah.
11:34:52 <davidhouse> right
11:34:53 <palomer_> @index (..)
11:34:53 <lambdabot> bzzt
11:34:57 <palomer_> @hoogle ..
11:34:57 <lambdabot> No matches found
11:35:00 <palomer_> @hoogle (..)
11:35:00 <lambdabot> No matches found
11:35:19 <palomer_> .. is part of which type class?
11:35:20 <Igloo> It's probably a reserved operator
11:35:27 <twobitsprite> @type (False..)
11:35:28 <lambdabot> Couldn't find qualified module.
11:35:28 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
11:35:29 <Igloo> It's syntax, related to the Enum class
11:35:30 <davidhouse> it parses as (False..), i.e., the function (.) which is defined in module False
11:35:38 <davidhouse> but there's isn't such a module
11:35:58 <davidhouse> but the interpreter doesn't get that far, the code doesn't even parse
11:36:19 <palomer_> reserved?
11:36:34 <shapr> Anyone know how files get rotated on Debian Linux?
11:36:37 <davidhouse> it's syntatic sugar, it doens't have to be a function
11:37:14 <palomer_> it could easily be made into a function
11:37:20 <davidhouse> sure.
11:37:25 <palomer_> with the same syntax
11:37:40 <davidhouse> let (..) = enumFromTo in 5 .. 6
11:37:46 <palomer_> exactly
11:37:46 <davidhouse> > let (..) = enumFromTo in 5 .. 8
11:37:46 <twobitsprite> palomer_: how would you keep the brackets around it?
11:37:47 <lambdabot>  parse error on input `..'
11:37:49 <liyang> shapr: you mean logs? Look in /etc/logrotate.d
11:37:57 <palomer_> twobitsprite, brackets around what?
11:38:00 <shapr> liyang: ah thanks!
11:38:09 <davidhouse> @yarr
11:38:09 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
11:38:18 <twobitsprite> palomer_: [4..5] according to your definition would be [[4,5]]
11:38:25 <palomer_> well, yes
11:38:35 <palomer_> I don't see any reason for being of the haskell syntax
11:38:45 <twobitsprite> I see
11:38:55 <davidhouse> twobitsprite: that's easily fixed
11:39:14 <davidhouse> well, not that easily actually
11:39:16 <jips> argh, bad news
11:39:17 <palomer_> ruby, for example, has (4..5) == [4,5]
11:40:10 <twobitsprite> I just thought you had a plan to keep the original syntax and was curious as to how you would do that
11:40:24 <shapr> jips: what?
11:40:34 <davidhouse> so. anyone had any ideas for haskell projects i could contribute to?
11:40:34 <twobitsprite> let (,,) = enumFromTo in 5 ,, 8
11:40:35 <jips> my hs-plugins patch doesn't work :(
11:40:39 <twobitsprite> > let (,,) = enumFromTo in 5 ,, 8
11:40:40 <lambdabot>  parse error on input `,'
11:40:53 <davidhouse> > let (--) = enumFromTo in 5 -- 8
11:40:54 <lambdabot>  parse error (possibly incorrect indentation)
11:41:00 <davidhouse> oh for goodness' sake
11:41:03 <twobitsprite> > let (#$) = enumFromTo in 5 #$ 8
11:41:04 <lambdabot> [5,6,7,8]
11:41:10 <davidhouse> > 5 `enumFromTo` 8
11:41:11 <lambdabot> [5,6,7,8]
11:41:15 <twobitsprite> heh
11:41:29 <palomer_> what function would we use to represent .. in [3..] ?
11:41:37 <shapr> I read that as for goodness' japanese wine. Talk about a freudian slip...
11:42:14 <davidhouse> palomer_, enumFrom
11:42:23 <davidhouse> palomer_: :info Enum in ghci might be helpful
11:42:27 <twobitsprite> > take 10 $ enumFrom 10
11:42:28 <lambdabot> [10,11,12,13,14,15,16,17,18,19]
11:42:54 <davidhouse> > last [1..]
11:42:55 <shapr> hiya Tur
11:42:57 <twobitsprite> unfortunately, you can't define unary ops...
11:42:58 <lambdabot> Terminated
11:43:09 <TuringTest> hi all
11:43:41 <monochrom> f x = x*x   -- f is a unary op...
11:43:55 <twobitsprite> > foldl (\ x -> last [x..] ) [1..]
11:43:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
11:43:55 <lambdabot>   Expected type: b -> a
11:43:55 <lambdabot>   Inferred type: a
11:44:00 <davidhouse> by 'op' he means 'function whose name is just symbols'
11:44:11 <monochrom> heh
11:44:17 <twobitsprite> monochrom: smarty pants
11:44:24 <davidhouse> (which is the standard definition of operator)
11:44:27 <davidhouse> no?
11:44:34 <twobitsprite> davidhouse: I thought so...
11:44:45 <davidhouse> perhaps 'infix function'
11:44:50 <twobitsprite> ... who's bahavior is infix by default
11:45:00 <vincenz> grr
11:45:09 <twobitsprite> vincenz: rrg
11:45:17 <monochrom> I think thinking of f as a unary operator is livable.
11:45:18 <davidhouse> > reverse "grr"
11:45:19 <lambdabot> "rrg"
11:45:36 <vincenz> > reverse "kcik esuohdivad"
11:45:37 <lambdabot> "davidhouse kick"
11:45:51 <davidhouse> @id /me kickcs vincenze
11:45:51 <twobitsprite> > "g" ++ (take 20 $ intersperse (repeat 'r') (repeat 'R'))
11:45:51 * lambdabot kickcs vincenze
11:45:51 <lambdabot> Couldn't match `[Char]' against `Char'
11:46:10 <twobitsprite> > "g" ++ (take 20 $ intersperse (cycle "r") (cycle "R"))
11:46:10 <vincenz> @id /me neuters davidhouse 
11:46:11 <lambdabot> Couldn't match `[Char]' against `Char'
11:46:11 * lambdabot neuters davidhouse
11:46:29 <davidhouse> twobitsprite: (repeat 'r') and (cycle "r") are of type [Char]
11:46:34 <davidhouse> @type intersperse
11:46:35 <lambdabot> Not in scope: `intersperse'
11:46:41 <davidhouse> @type Data.List.intersperse
11:46:42 <lambdabot> forall a. a -> [a] -> [a]
11:46:48 <palomer_> infinite types, unite!
11:46:50 <twobitsprite> > "g" ++ (take 20 $ intersperse 'r' (cycle "R"))
11:46:51 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
11:46:57 <twobitsprite> there we go, thanks :P
11:47:56 <davidhouse> > "g" ++ (take 20 $ cycle "rR")
11:47:56 <twobitsprite> I guess I was thinking zip
11:47:56 <lambdabot> "grRrRrRrRrRrRrRrRrRrR"
11:48:22 <twobitsprite> > "g" ++ (replicate 20 "rR")
11:48:22 <lambdabot> Couldn't match `Char' against `[Char]'
11:48:25 <twobitsprite> blast
11:48:39 <xerox> @quote xerox
11:48:39 <lambdabot>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
11:48:42 <davidhouse> > "g" ++ (concat $ replicate 20 "rR")
11:48:42 <lambdabot> "grRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrR"
11:48:45 <vincenz> > "g" ++ $ concat (replicate 20 "Rr")
11:48:45 <lambdabot>  parse error on input `$'
11:48:52 <vincenz> > "g" ++ ( concat $ replicate 20 "Rr")
11:48:53 <lambdabot> "gRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRr"
11:49:13 <vincenz> I HATE POINTERS
11:49:16 <sieni> > (++) "g" $ concat (replicate 20 "Rr")
11:49:17 <lambdabot> "gRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRrRr"
11:49:28 <davidhouse> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
11:49:29 <lambdabot> ["ol","lol","olol","lolol","ololol","lololol","olololol","lolololol","ololololol","lololololol"]
11:49:38 <davidhouse> vincenz: they hate you too!
11:49:39 <vincenz> @id /me mutters at davidhouse about the sppam
11:49:40 * lambdabot mutters at davidhouse about the sppam
11:49:43 <vincenz> davidhouse: I'm not in the mood
11:49:49 <vincenz> so keep your humor
11:49:55 <twobitsprite> > g ++ map (\ x -> case x in False then 'R' else 'r') cycle [False,True]
11:49:55 <lambdabot>  parse error on input `in'
11:50:02 <twobitsprite> > g ++ map (\ x -> case x with False then 'R' else 'r') cycle [False,True]
11:50:02 <lambdabot>  parse error on input `then'
11:50:08 <twobitsprite> bleh
11:50:10 <davidhouse> huh?
11:50:10 * twobitsprite gives up
11:50:27 <davidhouse> do you know the syntax for 'case'?
11:50:31 <twobitsprite> > g ++ map (\ x -> if x == False then 'R' else 'r') cycle [False,True]
11:50:31 <lambdabot>  Not in scope: `g'
11:50:44 <twobitsprite> I should just stop
11:50:47 <twobitsprite> :P
11:51:10 <davidhouse> > "g" ++ (take 20 $ map (\ x -> if x == False then 'R' else 'r') $ cycle [False,True])
11:51:11 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
11:52:08 <twobitsprite> > "gRrRrRrRrRrRrRrRrRr"
11:52:09 <lambdabot> "gRrRrRrRrRrRrRrRrRr"
11:52:12 <twobitsprite> :P
11:52:12 <davidhouse> :P
11:52:25 <palomer_> hah, I like that
11:52:26 <twobitsprite> at least I can get that one right!
11:52:40 <davidhouse> twobitsprite: just think about types and everything works
11:53:01 <davidhouse> and get things right in a PM with lambdabot or with ghci, then paste them into the chan :)
11:53:15 <twobitsprite> davidhouse: I'll start doing that :P
11:53:32 <palomer_> but then you wouldn't have anyone to correct you
11:53:46 <davidhouse> but then vincenz wouldn't get annoyed.
11:54:02 <xerox> "if x == False ..." comes from the daily wtf... right?
11:54:07 <Descolada|Work> 'take 20 $ map' - $ is?
11:54:18 <palomer_> daily wtf?
11:54:18 <davidhouse> Descolada|Work: function application
11:54:32 <davidhouse> Descolada|Work: f $ x = f x, it just saves on parantheses
11:54:40 <Descolada|Work> ahh
11:54:46 <davidhouse> > sin $ 45 + 45
11:54:47 <lambdabot> 0.8939966636005579
11:54:53 <davidhouse> > sin 45 + 45
11:54:54 <lambdabot> 45.85090352453412
11:54:56 <xerox> <http://thedailywtf.com/>
11:55:09 <Descolada|Work> okay, so it basicly says, do right, then left
11:55:13 <davidhouse> everything is left-associative (except, strangely, types)
11:55:24 <davidhouse> Descolada|Work: err, not quite
11:55:37 <davidhouse> > sin $ 45 + 45 == sin (45 + 45)
11:55:38 <Descolada|Work> okay
11:55:38 <lambdabot>  add an instance declaration for (Floating Bool)
11:55:50 <davidhouse> > (sin $ 45 + 45) == (sin (45 + 45))
11:55:51 <lambdabot> True
11:56:00 <Descolada|Work> cool
11:56:02 <davidhouse> it's exactly the same
11:56:14 <davidhouse> but haskellians don't like parentheses
11:56:23 <Descolada|Work> i see
11:56:25 <Descolada|Work> so do i
11:56:48 <davidhouse> right, got to re-install my OS. have fun :)
11:58:52 <sieni> indeed in Haskell doing something like if (foo == False) ... is a slight wtf, but in C it's easier to spot from the context what the intended return value of the function was (i.e. if (foo == false) ..., if (foo == NULL), ... or if (foo == 0))
11:59:36 <xerox> I'd say if not x, or if x and swap the clauses.
11:59:54 * Descolada|Work nods
12:00:01 <xerox> (But I tend to avoid ifs in general.)
12:00:28 <sieni> xerox: Yes, indeed in Haskell it does not serve any such purpose as in C, since the first argument of if is always a Bool
12:00:38 <Descolada|Work> i realy like guards and pattern matching in haskell
12:00:48 <xerox> (OTOH, ifs are cool, if it means Iterated Fractal Systems!!)
12:01:11 <sieni> weren't they Iterated Function Systems? :-o
12:01:34 <xerox> Same idea, prolly.
12:01:39 <robokop> > "g" ++ (take 20 (map (\ x -> case x of {False -> 'R'; True -> 'r'}) (cycle [False,True])))
12:01:40 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
12:01:57 * shapr boings
12:02:01 <xerox> Idea!
12:02:05 <Descolada|Work> lol
12:02:20 <robokop> it took me some time but i made it
12:03:58 <xerox> > take 20 $ map (chr . (+82) . (21*) . fromEnum) $ cycle [True,False]
12:03:59 <lambdabot> "gRgRgRgRgRgRgRgRgRgR"
12:04:40 <Descolada|Work> ewww
12:04:48 <xerox> Well.
12:04:53 <shapr> Deeep well!
12:06:00 <xerox> > ("g" ++) $ take 20 $ map (chr . (+82) . (32*) . fromEnum) $ cycle [False,True]
12:06:01 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
12:06:10 <xerox> k.
12:06:39 <shapr> hoi nineiryn 
12:08:34 <nineiryn> hi
12:09:23 <shapr> Learning Haskell?
12:10:03 * TuringTest uploads his first code to sourceforge!
12:10:06 <Descolada|Work> okay, now, what do those .'s do?
12:10:07 <TuringTest> Wheee...
12:10:19 <mauke> @type (.)
12:10:19 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
12:10:28 <shapr> A dot executes one function directly after another.
12:10:34 <mauke> @djinn (b -> c) -> (a -> b) -> a -> c
12:10:35 <lambdabot> f a b c = a (b c)
12:10:55 <Descolada|Work> using the same parameter or what has returned from the previos function?
12:11:19 <shapr> > ((+ 2) . (* 4)) 5
12:11:20 <lambdabot> 22
12:11:53 <xerox> (g . f) = \x -> g (f x)
12:12:00 <Descolada|Work> hmm, ok
12:12:05 <shapr> > let x = (+2) in (x . x) 1
12:12:06 <Cale> Descolada|Work: it's function composition
12:12:07 <lambdabot> 5
12:12:16 <Cale> in math, it's denoted by a small circle
12:12:18 <nineiryn> yes ,  im checking this channel out ;)
12:12:28 <shapr> nineiryn: Have any questions?
12:12:34 <Descolada|Work> i see
12:12:52 <mauke> @?e????"???j??
12:12:52 <lambdabot> Unknown command, try @listcommands.
12:12:54 <mauke> er, sorry
12:13:14 <nineiryn> not yet , it's to soon :) 
12:13:22 <shapr> Ok, feel free to ask any questions here.
12:13:29 <nineiryn> tnx , i will
12:15:07 <dcoutts> I have a "class Foo (a :: *)" and I want to extend that with "class Foo a => Bar (a :: * -> *)"
12:15:17 <dcoutts> any idea how I can do that?
12:15:35 <dcoutts> class Foo (a x) => Bar a
12:15:48 <dcoutts> doesn't work since 'x' is not in scope of course
12:16:19 <dcoutts> this is for a type class of things which extend some other things with a phanotm type var
12:16:37 <dcoutts> neytype Bar a = Bar Foo
12:17:01 <dcoutts> I've got this type class for things like Foo, and I want one for things like Bar
12:17:14 <dcoutts> where the one class extends the other
12:17:56 <dcoutts> I can make types instances of both classes, just not make one class extend the other :-(
12:24:07 <Descolada|Work> whats the diffrence between type and newtype ?
12:25:27 <Cale> Descolada|Work: type just gives an old type a new name, newtype creates a new type which has the same data representation as the old one
12:26:17 <Cale> newtype is closer to data than type (though not the same as it)
12:27:06 <Descolada|Work> hmm
12:27:10 <Cale> If I write  type String = [Char], then wherever I need a String, I can use a [Char] and that's fine
12:27:17 <Cale> (and vice versa)
12:27:47 <Cale> If instead, it was something like newtype String = S [Char], then I couldn't pass a [Char] when I needed a String
12:27:59 <Cale> I'd have to first apply the constructor S
12:28:11 <Descolada|Work> ahh
12:28:41 <robokop> but what is the difference then with Data
12:28:47 <Cale> but the constructor is compiled away, and doesn't exist at runtime. It's just a compiletime check to make sure that things are used correctly.
12:29:12 <Cale> With data, first of all, you can have multiple constructors and multiple fields in each
12:29:34 <Cale> data Tree = Leaf | Branch [Tree] works
12:29:39 <Cale> but not with newtype
12:29:57 <Cale> also, those constructors exist at runtime as actual datastructures
12:30:01 <robokop> ke
12:30:03 <robokop> thanks
12:30:10 <xerox> Newtype just sticks a label to a defined type.
12:30:28 <xerox> Datatypes are full-fledged structures, I'd say.
12:31:45 <Descolada|Work> so then, why did someone feel that 'newtype' had to exists
12:31:56 <Cale> Well, for one, efficiency
12:32:16 <Cale> If I write  data String = S [Char]
12:32:52 <Cale> then  S "Hello"  at runtime will be represented by something like a tag with a pointer to the actual string
12:33:07 <Cale> that is, there's an extra level of indirection
12:33:16 <Cale> also, they're not quite semantically the same
12:33:29 <xerox> Yes, and it lets you get much nicer error messages.
12:33:35 <Descolada|Work> heh
12:33:56 <Cale> S undefined isn't the same as undefined if S is a data constructor
12:33:57 <xerox> (I suppose that's a side-effect of the effect of being desciptive, which is also its aim.)
12:34:05 <Descolada|Work> and then what about type S = [Char]
12:34:08 <xerox> *descriptive
12:34:31 <xerox> A synonym is weaker than a newtype.
12:34:45 <Descolada|Work> okay
12:35:13 <Cale> with type String = [Char] then String is just substituted out for [Char] wherever it occurs before compiling
12:35:25 <Cale> So there's no gain in terms of type safety
12:36:44 <Descolada|Work> i see
12:37:19 <Descolada|Work> so a newtype is like a data but with less variables and without a extra level of inderection
12:38:53 <Descolada|Work> thanks
12:39:29 <Cale> another cool thing about newtypes
12:39:44 <Cale> is that you can derive any class for them which is supported on the original type
12:49:53 <xerox> Very true!
12:50:00 <xerox> Catch'ya later, 'earties.
12:50:41 <twobitsprite> @yow
12:50:42 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop in a
12:50:42 <lambdabot> plate of SAUCE MORNAY?
12:51:54 <Cale> @keal
12:51:55 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
12:52:24 <Cale> @keal
12:52:24 <lambdabot> the [nsa] even make light green both ways once
12:52:33 <Cale> @keal
12:52:34 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
12:53:08 <shapr> yow!
12:53:48 <shapr> I saw keal talking on #haskell, but the sheer surreality tripped my turing breaker and I thought he was a markovbot.
12:54:34 <ihope> @bot
12:54:35 <lambdabot> :)
12:54:39 <ihope> @snack
12:54:40 <lambdabot> Unknown command, try @listcommands.
12:56:36 <Cale> shapr: yeah, he's pretty crazy :)
12:56:39 <Cale> @keal
12:56:39 <lambdabot> Keal angry @ dons
12:56:44 <Cale> @keal
12:56:45 <lambdabot> T seems to be haskell, except with a decent interface at this point
12:58:19 * TuringTest announces Text.Regex.Lazy http://sourceforge.net/forum/forum.php?forum_id=554104
12:58:29 <TuringTest> (Now I can go eat dinner)
12:58:58 <ihope> @localtime lambdabot
13:02:52 <shapr> @timein lambdabot
13:03:09 <ihope> @help timein
13:03:09 <lambdabot>  @help <command> - ask for help for <command>
13:03:14 <shapr> @timein ihope
13:03:15 <lambdabot> Local time for ihope is Tuesday, March 21, 2006 4:02:52 PM
13:03:22 <shapr> ihope: Hey, you asked me something, didn't you?
13:03:30 <ihope> shapr: did I?
13:03:46 <ihope> I used the @get-shapr command once... :-)
13:06:41 <dcoutts> TuringTest, and you've cc'd dons on that for the HWN I hope
13:09:23 <shapr> ihope: Oh, that's what it was.
13:09:37 <TuringTest> dcoutts: Yes, I BCC'd him
13:09:40 <shapr> My lambda sense was activated!
13:09:47 <dcoutts> TuringTest, ok, good good
13:09:53 * shapr pretends to have been bitten by a radioactive lambda and given superpowers.
13:10:03 <dcoutts> TuringTest, btw, from the announcement, it looks good!
13:10:22 <TuringTest> dcoutts: The funny thing is that I have nothing to use it for at the moment.
13:10:28 <dcoutts> :-)
13:10:34 <ihope> @help shapr
13:10:35 <lambdabot>  @help <command> - ask for help for <command>
13:10:40 <ihope> Hmm.
13:10:43 <TuringTest> It is a spinoff of the shootout (regex-dna)
13:54:33 <ihope> Hmm, so it seems Haskell and Smalltalk are both really, really good for the same reasons :-)
13:57:07 <shapr> ihope: hm?
13:57:52 <shapr> TuringTest == Kuklewicz ?
13:58:01 * TuringTest nods
13:58:05 <shapr> ok,cool
13:58:14 <TuringTest> I am cool, yes.
13:58:34 <shapr> Yes :-)
13:58:47 <TuringTest> http://haskell.org/hawiki/HaskellChannelPeople
13:59:00 <TuringTest> And you are at the top.
13:59:15 <shapr> Probably because I started the page.
13:59:31 <shapr> No better reason :-)
13:59:44 <TuringTest> And I am at the bottom, for a similar reason...
14:02:30 <shapr> Er, where did your announcement show up?
14:02:42 <shapr> I was looking at it a moment ago, but now can't find it.
14:04:58 <TuringTest> ...
14:05:40 <Descolada|Work> > product [1..10]
14:05:41 <lambdabot> 3628800
14:05:43 <TuringTest> http://sourceforge.net/forum/forum.php?forum_id=554104
14:06:34 <TuringTest> shapr: It also went out to libraries@haskell.org mailing list
14:06:53 <ihope> > product [1..product [1..3]]
14:06:54 <TuringTest> (anything to help it increase volume...)
14:06:54 <lambdabot> 720
14:06:55 <shapr> ah, ok
14:08:20 <TuringTest> shapr: It won't compete with TCL for regex performance, but it is better than Text.Regex by over an order of magnitude on large strings.
14:08:33 <shapr> TuringTest: Have you seen Manuel Chakravarty's lazy regex library in ctk?
14:08:45 <jips> anyone here ever used haskell xml toolbox?
14:08:50 <TuringTest> shapr: The CompatDFA / DFAEngine is based on the CTK lexer
14:08:58 <shapr> oh spiffy
14:09:10 * shapr suddenly sees that in the announcement.
14:09:22 <ihope> Hmm...
14:09:38 <ihope> > foldr (^) 1 [1,2,3,4,5]
14:09:42 <lambdabot> Terminated
14:09:44 <ihope> > foldr (^) 1 [1,2,3,4]
14:09:45 <lambdabot> 1
14:09:46 <shapr> zoinks!
14:09:52 <Descolada|Work> i have a question about that grr thing earlyer, is "g" ++ $ take 20 $ cycle ['R', 'r'] diffrent?
14:10:04 <ihope> That function doesn't grow as fast as it would seem to.
14:10:16 <shapr> It's lazy, like the rest of Haskell.
14:10:16 <TuringTest> shapr: That is why DFAEngine.hs is under the LGPL.  I had to improve some of the design points to make it work as a regex matcher instead of a lexer.
14:10:33 <ihope> Descolada|Work: different from from?
14:10:38 <shapr> I'm a big fan of the GPL lately.
14:10:41 <Descolada|Work> > foldl (^^) 1 [1..5]
14:10:42 <lambdabot> 1.0
14:10:43 <ihope> s/from from/from what/
14:10:47 <TuringTest> shapr: Text.Regex.Laxy.Full has both lazy and strict versions of subRegex and splitRegex
14:11:12 <Descolada|Work> "g" ++ (take 20 (map (\ x -> case x of {False -> 'R'; True -> 'r'}) (cycle [False,True])))
14:11:13 <shapr> Have you considered trying arrows to get better GC, shortcut ops, and less shadowing?
14:11:15 <TuringTest> shapr: GHC is under BSD, and if someone wants to ship this library with it then I can't put it under GPL.
14:11:20 * SyntaxNinja posts possibly controversial email: http://www.haskell.org//pipermail/haskell-prime/2006-March/001008.html
14:11:22 <shapr> Yeah, true.
14:11:29 <ihope> > foldr (^) 1 [2,3,4,5]
14:11:33 <lambdabot> Terminated
14:12:00 <TuringTest> shapr: The Compat.hs module and Full.hs are build on the Parsec Monad -- but it will backtrack of course.
14:12:26 <TuringTest> shapr: It has several different strategies you can use (longest match, first match, all matches)
14:12:42 <TuringTest> And the DFAEngine is single pass, of course. But only for simpler tasks
14:12:58 <Descolada|Work> > "g" ++ $ take 20 $ cycle ['R', 'r']
14:12:58 <lambdabot>  parse error on input `$'
14:13:20 <Descolada|Work> > "g" ++ (take 20 (cycle ['R', 'r']))
14:13:21 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
14:13:23 <TuringTest> shapr: Arrows may be overkill for regular expression matching.
14:13:45 <shapr> Yeah, but are they overkill for the shootout? ;-)
14:14:06 <TuringTest> shapr: the shootout used a derivative of the CTK lexer appended to the code.
14:14:24 <TuringTest> shapr: But the front end was a string regex parser written with Parsec
14:14:44 <TuringTest> (now much smarter in Text.Regex.Lazy.ReadRegex.hs )
14:14:46 <shapr> Parsec will gc later and less than an arrow based parser.
14:15:12 <ihope> > ("g" ++) $ take 20 $ cycle ['R','r']
14:15:13 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
14:15:27 <TuringTest> shapr: Hmmm.....One could take the Pattern data and build an Arrow based parser from that.
14:15:32 <shapr> Yeah
14:15:32 <ihope> > (('g':) . take 20) (cycle "Rr") -- I like this way
14:15:33 <lambdabot> "gRrRrRrRrRrRrRrRrRrRr"
14:15:55 <Descolada|Work> ahh
14:16:02 <TuringTest> shapr: But I have not used arrows for anything yet, just read the docs and Yampa paper.  Hmm....
14:16:13 <Ulfalizer> heh.. hugs takes quite some time to compile
14:16:29 <shapr> In the case of dynamic parsers, arrow style parsers will end up being the same as monadic parsers. For example, when parsing unknown tags where the entire parser is built at runtime.
14:17:00 <shapr> musasabi and ibid have both written arrow style parser libs.
14:19:28 <TuringTest> shapr: For performance you need a pattern simple enough to transform into a DFA.  And it has a DFA based on the CTK Lexer.  But I am not terribly happy with the performance of Parsec.  I only need a few primitives....do you have any names-of or links-to those arrow parsers?
14:19:54 <shapr> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
14:19:57 <shapr> that's by musasabi 
14:20:32 <shapr> http://antti-juhani.kaijanaho.fi/tmp/LLParser.hs, That's by ibid, though he said it hasn't been tested much.
14:21:28 <shapr> musasabi's Parrows has a very cool Show instance.
14:22:02 <ihope> Parrows?
14:22:05 <ihope> :-)
14:22:47 <shapr> Yeah, I voted for ParrowT ;-)
14:23:18 * ihope Djinns his AntiMaybe AntiMonad
14:24:39 <ihope> Uh-huh. So AntiMaybe isn't an AntiMonad :-P
14:29:23 <musasabi> audreyt had many very good modifications to PArrows in the pugs tree, but I have been too busy to commit them back in :-(
14:29:34 <ihope> class Complement c d where complement :: c a -> b a -> a
14:31:37 * shapr looks at the pugs sources.
14:33:35 <shapr> Wow
14:34:06 <integral> we don't offer refunds if your brain turns to mush after looking :-P
14:34:43 <Descolada|Work> i want my brain back!
14:37:32 <shapr> The pugs version works with FPS.
14:37:34 <shapr> That's way cool.
14:37:45 <rizzix> FPS?
14:37:50 <TuringTest> Data.FastPackedString
14:37:51 <shapr> fast packed string
14:37:55 <rizzix> oh right
14:38:27 <TuringTest> I have a  DFAEngineFPS.hs that matches the DFA table against a FPS...
14:38:34 <TuringTest> (untested)
14:39:47 <integral> shapr: it's a pity Pugs doesn't actually *use* it yet :-)
14:57:59 <ptolomy> well, I'm silly. I had previously hard-coded the PortNumber of a server I was writing, but now I want to read from the command line. However, PortNumber doesn't have an instance of read. Thoughts?
14:58:31 <shapr> cast it?
14:59:14 <Descolada|Work> eat ice cream, that allways helps me
15:00:19 * ptolomy continues being confused.
15:01:01 <Cale> ptolomy: doesn't it have an instance of Num?
15:01:23 <Cale> you could just read an Integer and use fromIntegral
15:01:24 <ptolomy> oh, it does.
15:01:38 <ptolomy> of course. :)
15:01:39 <ptolomy> Thanks.
15:01:51 * ptolomy needs to stop this "work" stuff. Makes him brain-dead.
15:03:32 <Descolada|Work> see, the ice cream will preserve what brain you have left, so you can tackle the problem later
15:30:06 <ihope> So five points on a conic section are required to define it, right?
15:38:09 <TuringTest> Hmm....sounds right
15:39:00 <TuringTest> Depends if more than 3 are co-planar, perhaps
15:39:03 <shapr> It's so cool! - http://www.scannedinavian.com/~shae/eurohaskell/
15:40:35 <palomer> >:o
15:41:04 <shapr> palomer: See, John Hughes tried my unicycle.
15:41:09 <shapr> I'm the guy with the ponytail.
15:41:51 <palomer> woh's jon hughes?
15:41:55 <tic> ?!
15:41:56 <lambdabot> Not enough arguments to @.
15:41:57 <palomer> whoa
15:42:25 <tic> shapr, hey, no S room?
15:42:28 <shapr> palomer: Now you know who John Hughes is?
15:42:38 <palomer> whoa, unisexe bathrooms
15:42:39 <shapr> tic: Er, I think there was, but I only put a few of the pix online.
15:42:50 * shapr looks
15:42:50 <palomer> no, I still don't know
15:42:57 <shapr> @google john hughes haskell
15:42:59 <lambdabot> http://www.haskell.org/arrows/
15:43:01 <TuringTest> palomer: Either Male Female
15:43:13 <TuringTest> That would have been a better sign
15:43:39 <palomer> reall, I don't know why the KS calculus is popular
15:43:51 <tic> KS?
15:44:02 <tic> Isn't it commonly referred to as SKI?
15:44:18 <ihope> SK?
15:44:21 <TuringTest> http://en.wikipedia.org/wiki/SKI_combinator_calculus
15:44:39 <TuringTest> (But "I" can be defined from just "K" and "S")
15:45:32 <tic> ah, yes.
15:45:41 <ihope> I = SKK or SKS or SKI :-)
15:46:09 <shapr> I see that on zippers and keep thinking it's about applying the zipper bits to each other.
15:46:10 <ihope> Or SK(SK(KSKS(SK)KS)SKK(KS)S), but there's no reason to do it that way.
15:46:17 <shapr> Oh maybe zippers have YKK on them?
15:47:06 <palomer> iota is a much nicer calculus
15:47:37 <shapr> Aha - YKK on zippers - http://home.howstuffworks.com/question469.htm
15:47:52 <palomer> does anyone have a nice encoding of lambda calculus with a single symbol?
15:47:57 <shapr> X
15:47:59 <ihope> Ah, Iota's nice.
15:48:15 <shapr> There's an X combinator that does everything, but it's convoluted.
15:48:28 <ihope> What's the definition of X?
15:48:38 * shapr doesn't remember...
15:49:05 * shapr decides to sleep instead of research lambda calculus...
15:49:06 * shapr &
15:49:08 <ihope> YKK = K(YK)K = YK
15:49:15 * tic & # too
15:51:14 <norpan> X is something like \x->xKSK
15:52:06 <ihope> Hmm...
15:52:30 <palomer> note that there is no nesting if you only have one symbol
15:52:39 <palomer> X(XX) isn't part of your language
15:52:51 <ihope> It's all numbers of X's?
15:53:08 <palomer> yeah
15:53:25 <ihope> XX = XKSK = KKSKSK = KKSK = KK?
15:53:34 <palomer> (or else you could just use iota)
15:53:41 <ihope> XXX = KKX = K, then.
15:53:47 <norpan> just gödel encode it and do unary encoding of the number
15:54:02 <ihope> XXXX = KX, XXXXX = KXX = X... that's not right, is it?
15:54:07 <palomer> oh, that's right, you can't
15:54:18 <mathrick> bah, how do I resolve shift/reduce in if _ then _ else? 
15:54:24 <palomer> norpan: well, the term would have to be operationally equivalent to a lambda term
15:54:32 <mathrick> bison doesn't know what to do after "then"
15:54:40 <mathrick> then _ actually
15:55:08 <norpan> palomer: huh?
15:55:36 <palomer> norpan: your way doesn't work.
15:56:17 <mathrick> humm, actually why does it do that? "else" token should be enough to determine the course of action
15:56:32 <palomer> X^n = K -> X^(jn+i) = K^j X^i = either K X^i or X^i
15:57:01 <palomer> which means you only have a finite number of terms
15:57:17 <palomer> which is at most 2*n
15:57:31 <palomer> which, of course, is impossible
15:57:40 <palomer> wow, this answers a question I've been having
15:57:43 <norpan> i don't understand, you would need to define the application operator accordingly of course
15:58:09 <palomer> norpan: this is my question: find a lambda term X such that all lambda terms are equivalent to X^i for some i
15:59:10 <norpan> i would say there is no such term
15:59:17 <palomer> I just proved there is no such term
16:00:27 <norpan> ihope: yes, K = XXX and S = X(XX)
16:00:28 <palomer> even better
16:00:41 <palomer> X^n = Y K
16:00:54 <palomer> so X^(n+i) = X^n
16:01:26 <palomer> err
16:01:31 <palomer> X^(n+i) = X^n
16:02:14 <palomer> I can't take credit for this proof, ihope came up with this
16:02:28 <ihope> With... I came up with a proof?
16:02:35 <palomer> well, the idea, at least
16:02:47 <palomer> ok, someone give me an intuitive reason why Y K M = Y K
16:03:06 <Descolada|Work> i am lost
16:03:09 <ihope> YK = K(YK).
16:03:14 <palomer> ihope: that's not intuitive
16:03:23 <ihope> palomer: it isn't?
16:03:26 <palomer> why should the fixed point of K eat its arguments
16:03:49 <ihope> Because the fixed point of K is K applied to the fixed point of K...
16:04:06 <palomer> but there must be some deeper reason!
16:04:45 <ihope> Um... no?
16:05:16 <ihope> YKx = K(YK)x = YK.
16:05:29 <palomer> if I said: K X = X, now convince me that X eats its argumetns
16:05:53 <ihope> X = K X, therefore applying X to something produces X.
16:06:01 <palomer> oh, righto
16:06:07 <palomer> there we go
16:06:10 <palomer> now I'm convinced.
16:06:31 <palomer> man, we need a calculus encodable with a single element
16:06:50 <ihope> You mean the X combinator or Iota's I combinator?
16:07:08 <ihope> The one that I call the J combinator when nobody has to know what it is...
16:07:19 <palomer> well, erm, iota needs 2 symbols
16:07:23 <palomer> ` and i
16:07:31 <ihope> Oh.
16:07:46 <ihope> @google unary
16:07:47 <lambdabot> http://id.mind.net/~zona/mmts/expressions/unaryOps.html
16:07:57 <ihope> Nope.
16:08:02 * vincenz sighs
16:08:03 <ihope> @google esoteric unary
16:08:05 <lambdabot> http://en.wikipedia.org/wiki/List_of_esoteric_programming_languages
16:08:05 <vincenz> I'm stuck at a dilemma
16:08:22 <ihope> Grr.
16:09:08 <ihope> http://esoteric.voxelperfect.net/wiki/Unary (contains the F word)
16:09:26 <ihope> That F word happens to come directly after the word "brain".
16:09:56 <vincenz> brainfuck
16:10:04 <ihope> Bingo. :-P
16:10:23 <palomer> there are better ways to do that
16:10:24 <Descolada|Work> ...
16:10:25 <Descolada|Work> !!!
16:10:30 <palomer> just use jot
16:10:54 <palomer> still, it involves a non operationally preserving morphism
16:11:42 <vincenz> ?
16:12:08 <palomer> !
16:12:15 <vincenz> .
16:12:19 <ihope> ?
16:12:26 <ihope> )
16:13:05 <vincenz> @id /me ('s ihope 
16:13:05 * lambdabot ('s ihope
16:13:13 <vincenz> ihope: you just got bananed
16:13:18 <ihope> :-)
16:13:29 <ihope> Now that @id command's an interesting one...
16:13:42 <Descolada|Work> what is id ?
16:13:46 <ihope> @id @id @id @id Note to self: lambdabot doesn't do this.
16:13:46 <lambdabot>  @id @id @id Note to self: lambdabot doesn't do this.
16:13:52 <ihope> @id It's this!
16:13:52 <lambdabot> It's this!
16:15:26 <ihope> \quote
16:15:26 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
16:15:38 <ihope> \id \muahaha
16:15:38 <lambdabot> \muahaha
16:16:06 <Descolada|Work> > :type id
16:16:07 <lambdabot>  parse error on input `:'
16:16:27 <Descolada|Work> :type id in ghci says it is a -> a
16:16:38 <dons> \type id
16:16:39 <lambdabot> forall a. a -> a
16:16:55 <dons> \. id . id . id . id yow!
16:16:55 <lambdabot> compose module failed: Parse error: "yow!"
16:17:28 <ihope> \. id . id . id . id . id . id yow
16:17:28 <lambdabot> Where's the Coke machine?  Tell me a joke!!
16:17:38 <Smokey`> hey, relatively new to haskell but just wondering if there's any good resources for people comming from say, a C++ background?
16:17:50 <ihope> @google haskell for c
16:17:51 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
16:17:58 <Smokey`> ty :)
16:18:09 <ihope> \. state yow
16:18:23 <dons> haskell.org has most of the tutorials and introductions.
16:18:34 <dons> i'm not aware of a specific C++ document, though
16:20:03 <Smokey`> just trying to get my head around defining data types/structures in haskell atm
16:20:10 <ihope> Ah.
16:20:15 <dons> gee, the call for papers for Mathematically Structured Functional Programming is cool
16:20:33 <dons> oh, data Struct1 = Tag Int  Bool String
16:20:49 <ihope> How's this: data Foo = Bar Baz | Qux Quux -- Bar :: Baz -> Foo, Qux :: Quux -> Foo
16:21:15 <dons> Smokey`, you should be able to find some good introductoins to this in the general Haskell introductoins
16:21:18 <dons> for example
16:21:20 <dons> \where yaht
16:21:21 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
16:21:32 <dons> is a good one
16:21:39 <Smokey`> That's rather daunting to be honest ihope :)
16:21:56 <Smokey`> dons: thanks, i'll check it out :)
16:22:02 <ihope> Well, everything from -- forward is a comment.
16:22:17 <Descolada|Work> that unary language would be much better if it could be any character
16:22:29 <Smokey`> ihope: aye, but i dont understand the comment :P
16:22:39 <ihope> Heh...
16:22:40 <Descolada|Work> it just counts the number of chars until EOF
16:23:14 <ihope> In "data Foo = Bar Baz | Qux Quux", you can apply Bar to a Baz to get a Foo, or you can apply Qux to a Quux to get a Foo.
16:24:22 <dons> Smokey`: http://haskell.org/learning.html start here.
16:25:18 <ihope> So many tutorials...
16:29:44 <Smokey`> I guess my problem is I'm thinking too much in terms of "C++" data structures...  ahh well
16:30:41 <dons> the 'data' declarationn lets you create structures analogous to C++ structures
16:33:01 <dcoutts> this is foreign data?
16:33:14 <dcoutts> otherwise I don't see that such a thing is needed
16:33:31 <dcoutts> oh, sorry, different discussion
16:33:50 <dcoutts> there was talk about constant data in relation to haskell'
16:33:58 <Smokey`> :)
16:36:46 <Pseudonym> Actually, a tutorial for C++ programmers coming to Haskell isn't such a bad idea.
16:37:08 <Pseudonym> Because good C++ programmers already understand parametric polymorphism and typeclasses, only they're called templates and concepts.
16:37:34 <dons> yep. i agree it would be useful
16:38:14 <Smokey`> only other thing I can't grasp now, is making a function that takes parameters, but returns nothing... not even sure if it's possible.
16:38:19 <Pseudonym> And "Eq" is so much shorter than "EqualityComparableConcept".
16:38:35 <dons> the paper "A comparative study of language support for generic programming" is useful in this regard.
16:38:48 <Pseudonym> Smokey`: You can do that.  f :: Int -> ()
16:38:54 <dons> you don't return 'nothing' , you return the unit value, ()
16:39:03 <Smokey`> hmm, could've sworm i tried that...
16:39:10 <Pseudonym> However, it won't do anything.
16:39:22 <mwc> Does anybody have any sample code for building a list efficiently using State monad enclosed computation? My function ends with "restOfList <- computeRest (n - 1); return $ this : restOfList"
16:39:31 <mwc> it seems to me there should be a way to make that tail recursive?
16:39:35 <mwc> I just can't figure it out
16:40:29 <Pseudonym> mwc: Right, because that's not tail recursive.
16:40:42 <mwc> Pseudonym, yeah, I'm trying to make it TC
16:40:42 <Pseudonym> You could do something like this:
16:41:19 <Pseudonym> computeList = do xs' <- computeList'
16:41:31 <Pseudonym>                  return (xs' [])
16:41:41 <Pseudonym> computeList'
16:41:43 <Pseudonym>   = do
16:41:51 <Pseudonym>     x <- computeX
16:41:59 <Pseudonym> Hang on.
16:42:06 <Pseudonym> computeList
16:42:18 <Pseudonym>     = do computeList' id
16:42:42 <Pseudonym> I'll work it out in a text editor first. :-)
16:43:06 <mwc> yeah, if it matters any, I'm using the state monad since i have a random generator I need to use in calculating these values, and need to fetch it out at the end
16:43:35 <mwc> I suppose I could just hang the idea of getting it out at the end and use split, that makes it a lot easier
16:43:54 <mwc> but if I can do it "right" I'd rather do this, if as a learning experience than anything else
16:44:35 <Pseudonym> computeList d
16:44:36 <Pseudonym>   = do
16:44:37 <Pseudonym> computeList' d r
16:44:38 <Pseudonym>   | final d   = return r
16:44:38 <Pseudonym>   | otherwise = do
16:44:44 <Pseudonym> Grrr.
16:45:26 <mwc> you mean add an accumulator?
16:45:37 <Pseudonym> Kind of.
16:45:44 <Pseudonym> Just a moment.
16:45:49 <Pseudonym> Where's the paste page now?
16:47:03 <Pseudonym> http://www.nomorepasting.com/paste.php?pasteID=59533
16:47:07 <Pseudonym> That'll do.
16:47:47 <Pseudonym> The other option, of course, is to use a nondeterminism transformer monad on top of the state monad.
16:47:55 <Pseudonym> And then use "solutions" to get the list.
16:48:14 <Pseudonym> That's actually pretty elegant.
16:48:20 <Pseudonym> http://www.haskell.org/hawiki/NonDeterminism
16:49:16 * vincenz loves haskell
16:49:19 <vincenz> I've decide
16:49:24 <vincenz> time to recode my ocaml tool to haskell
16:49:28 <vincenz> to leverage haskelity
16:49:41 <Pseudonym> We like O'Caml here, but we prefer Haskell.
16:52:49 <mwc> thanks Pseudonym 
16:58:14 <palomer> I don't particularly like ocaml
16:59:24 <dons> you'd prefer php? ;)
17:00:13 * Pseudonym browses through the Sparc verilog source
17:00:19 <Igloo> It's got lambda...what more do you want?
17:01:15 <mauke> nicer syntax for explicit types
17:01:37 <mauke> oh, and typeclasses and do notation
17:01:40 <dons> now Igloo is almost as bad as ndm's javascript love ;)
17:01:40 <Pseudonym> Actually, syntax is ML's biggest problem.
17:01:50 <Pseudonym> The syntax is as old as Prolog, and just as pretty.
17:02:08 <vincenz> yeah
17:02:12 <vincenz> Pseudonym: and code duplicity
17:02:18 <dons> I think thhe syntax is the most oft-cited criticism we hear here.
17:02:25 * vincenz got his paper accepted today
17:02:27 <vincenz>  \o/
17:02:31 <Pseudonym> yay!
17:02:41 <Pseudonym> Yeah, if it wasn't for the syntax, I'd probably use ML more.
17:02:45 <dons> followed by lack of type classes, and then impurity.
17:02:48 <vincenz> yep
17:02:50 <Pseudonym> i.e. more than "not at all"
17:02:51 <vincenz> lack of type classes
17:02:57 <vincenz> code duplicity between .ml and .mli files
17:02:58 <dons> no one complains about lack of laziness
17:02:59 <Descolada|Work> "  "
17:02:59 <Descolada|Work> \o/
17:02:59 <lambdabot> Maybe you meant: . id pl wn yow
17:03:01 <vincenz> instead of the easier export syntax
17:03:13 <Pseudonym> I go to a lot of trouble to avoid laziness in Haskell. :-)
17:03:16 <Pseudonym> In places.
17:03:22 <vincenz> br
17:03:23 <vincenz> b
17:03:39 <Pseudonym> The only places where I really want it are 1) producer/consumer code, and 2) dynamic programming.
17:03:41 <vincenz> re
17:03:59 <Pseudonym> The rest of the time, it's only really there to make the semantics simple.
17:04:02 <dons> anyway, I say we should adopt Clean's motto as a "lazy and strict purely functional programming language"
17:04:11 <dons> since we do throw a lot of strictness around
17:04:12 <Pseudonym> Which, admittedly, is quite important.
17:04:24 <vincenz> you need a good strictness analyzer
17:04:49 <vincenz> time to keep on working on my RB tree
17:04:53 <vincenz> (in c++ :/  )
17:04:55 <vincenz> on another note
17:05:04 <vincenz> how hard is it to do double linked list in haskell
17:05:08 <vincenz> I have this one algo that relies on it
17:05:12 <vincenz> (in ocaml)
17:05:17 <dons> it's an faq
17:05:29 <Pseudonym> Why do you need a RB tree in C++?
17:05:31 <dons> and I thhnk we have a couple of libs for d-linked lists
17:05:45 <Pseudonym> It's in the STL.  Why write your own?
17:05:45 <vincenz> Pseudonym: to add profiling code
17:05:49 <Pseudonym> Ah.
17:05:52 <Pseudonym> Well.
17:06:00 <adu> talking about C++ in #haskell again i see
17:06:09 <Pseudonym> G'day adu.
17:06:13 <adu> hi
17:06:13 <Pseudonym> How's the parsing going?
17:06:18 <adu> good
17:06:28 <vincenz> anyways
17:06:30 <vincenz> concerning double linked list
17:06:36 <vincenz> maybe you guys have an alternate solution
17:06:43 <vincenz> shall I quickly describe the algo?
17:08:10 <adu> Pseudonym: i wrote a little thing for PLY using what i learned the other day and based on their examples
17:08:26 <Pseudonym> Cool.
17:08:32 <Pseudonym> vincenz: By all means.
17:08:41 <vincenz> ok... assume a possibly endless list of tokens
17:08:47 <adu> PLY = python lex/yacc
17:08:55 <vincenz> tokens being some sort of sumtype with Eq
17:09:05 <vincenz> for instance data Token = A | B
17:09:29 <vincenz> so what I'm doing is prefix-matching to make repeat structures of tokens
17:09:51 <vincenz> data Special a = Simple a | Repeat (Int, [Special a])
17:10:03 <vincenz> A A B -> Repeat(2,[Simple a]) B
17:10:22 <vincenz> continuing I meet two other A
17:10:31 <vincenz> so I have Repeat(2, [Simple A]) B Repeat(2, [Simple A])
17:10:33 <vincenz> then I meet a B
17:10:40 <vincenz> and I have a repeat of the entire first block I had
17:10:44 <vincenz> I use dual linked lists
17:10:54 <vincenz> so I can unlink the part up until which I matched
17:11:02 <vincenz> basically
17:11:05 <vincenz> for every new token I meet
17:11:20 <vincenz> I try to match up until the begin of match left = start of match right -1
17:11:27 <vincenz> then unlink the right matched
17:11:30 <vincenz> and make a repeat structure on the left
17:11:34 <vincenz> or if it's already a repeat structure
17:11:37 <vincenz> increase it's Int by 1
17:11:52 <vincenz> I recurse until I can no longer do this
17:11:53 * Pseudonym is lost already
17:11:55 <vincenz> then add another token from input
17:12:21 <Pseudonym> This is some kind of run-length encoding?
17:12:32 <Pseudonym> Only heirarchical?
17:13:00 <vincenz> yeah
17:13:15 <vincenz> to basically detect the highlevel pattern in a token stream
17:13:16 <vincenz> for instance
17:13:19 <Pseudonym> OK.l
17:13:23 <Pseudonym> With you, I guess.
17:13:27 <vincenz> you could have a 10 times [5 times A, then 3 times B]
17:13:33 <Pseudonym> Right.
17:13:37 <vincenz> how I do this is
17:13:43 <vincenz> whenever a new token is in
17:13:53 <vincenz> I try to match first half of processed to right half
17:13:58 <vincenz> so there's nothing in between
17:14:03 <vincenz> at that point I unhinge the right side
17:14:08 <vincenz> and make a repeat of the left
17:14:11 <vincenz> or if it's already a repeat
17:14:13 <vincenz> I increase it's count
17:14:18 <vincenz> but for that you need DLL
17:14:27 <vincenz> or it'd become seriously inefficient
17:14:30 <vincenz> at least this way of doing it
17:14:40 <vincenz> I agree that it's biased towards the start of the stream
17:14:42 <vincenz> but oh well
17:14:47 <vincenz> seems the easiest way of doing this
17:16:40 <Pseudonym> Sounds to me a similar kind of problem as LZ77.
17:17:50 <vincenz> LZ77 is not hierarchical
17:18:26 <Pseudonym> No, but it could be made so.
17:18:46 <Pseudonym> You replace a sequence by a virtual token, and then make repeated passes.
17:19:37 <vincenz> righ
17:19:42 <TuringTest> hi dons
17:19:45 <vincenz> the way I did it in ocaml to do it efficiently is to use DLL
17:19:55 <vincenz> so whenever I try to match... I can then unlink the matched part
17:20:00 <vincenz> to roll them together
17:20:08 <dons> hey TuringTest, congrats on releasing the regex lib!
17:20:34 <TuringTest> There is a DFAEngineFPS.hs file in there for fast packed strings, as well (untested)
17:20:36 <vincenz> http://rafb.net/paste/results/TcysDh48.html
17:21:10 <dons> yeah, I saw that. cool!
17:21:54 <TuringTest> I ended up putting both a lazy and strict version of subRegex and splitRegex into Text.Regex.Lazy.Full
17:21:59 <TuringTest> (they use Parsec)
17:22:59 <dons> ah, I see on thhe shootout they've tweaked the lines-of-code count
17:23:06 <dons> it uses the gzip bits count now
17:23:12 * TuringTest goes to look
17:23:31 <TuringTest> Spelled "GZip Bytes" now
17:23:40 <dons> bytes, yep
17:23:53 <dons> ah, and we're much further down :(
17:23:58 <dons> (on byte count)
17:24:18 <TuringTest> They have a comment stripped before gzip
17:24:23 <TuringTest> s/ed/er/
17:24:45 <dons> are we sure they do it for haskell comments?
17:24:49 <vincenz> Pseudonym: it can become uglier
17:25:24 <dons> ah well, it's the cost of those longer entries that need packed strings
17:25:27 <dons> we know  how to fix it
17:25:52 <mauke> use shorter identifiers, reuse identifiers in local scopes, etc
17:26:17 <dons> yeah :( that sucks.
17:26:24 <TuringTest> dons: Suspicious http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all&sort=gz
17:26:36 <dons> we know how to fix it I mean, by using, fps and friends
17:26:38 <TuringTest> Haskell does not look 60% longer than Pythong any way you slice it.
17:26:56 <Igloo> Or you could spend the time on improving GHC so things run faster...
17:27:27 <dons> thanks Igloo :)
17:28:46 <TuringTest> dons: Cut and Paste code is what is getting rewarded by gzip.
17:28:50 <dons> yeah, I really not sure that what the gzip algorithm compreses corresponds to any reasonable measure of code length. it'll punish richer languages, no?
17:28:53 <dons> yyeah
17:29:13 <eivuokko> It takes away diffrence caused by keywords, as well.
17:29:33 <dons> right.
17:29:34 <TuringTest> Lines of code pu haskell 1st. The token count they were experimenting with put ruby 1st, haskell 2nd
17:29:40 <dons> so we should enter only entries using lambdas
17:29:55 <mauke> awesome
17:30:06 <dons> maybe s k and i :)
17:30:12 <TuringTest> Now Haskell is 9th
17:30:20 <dons> yeah. seems odd. 
17:30:58 <TuringTest> Note: Infomation theory says compressible streams hold less information.  Haskell programs are definately short and cannot be compressed so their information density must be very very high.
17:31:23 <dons> so OCaml, Haskell, SML, Clean -- all the richer languages- are suffering.
17:32:42 <dons> silly metric
17:32:43 <TuringTest> OCaml does okay
17:33:01 <TuringTest> dons: If we want to change, we ought to complain.
17:33:19 <Igloo> Urgle. What are those !s in the partialsums code?
17:33:46 <TuringTest> dons: For just the CPU speed -- did you see where Clean is now?
17:33:57 <dons> yeah, cool eh? they're pretty zippy
17:34:17 <TuringTest> dons: They obviously have been working on it.  Impressive
17:34:47 <TuringTest> dons: Is clean bad a concurrency?  They are missing those 2 apps.
17:34:52 <TuringTest> s/a/at/
17:35:01 <dons> http://alioth.debian.org/forum/forum.php?thread_id=2127&forum_id=999
17:35:08 <dons> Isaac's entry on gzip ^^
17:35:26 <adu> ^^ = tetration
17:35:33 <dons> I'm not sure they have concurrency(?)
17:38:06 <TuringTest> dons: sandbox for LuaJIT http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=all
17:38:10 <TuringTest> also impressive
17:38:23 <TuringTest> (compare with Python Psycho)
17:41:04 <TuringTest> dons: By the way, what are you working on these days?
17:41:49 <dons> phd :)
17:42:05 <TuringTest> ah
17:42:22 <TuringTest> The funny thing is, I don't have anything to use Text.Regex.Lazy for...
17:42:58 <dons> I find this gzip metric instead of source code rather disappointing. there's only so many random changes to the rules before it becomes annoying
17:44:43 <TuringTest> dons: The token count fell apart over "what does { } ;  contribute" type questions.
17:46:46 <TuringTest> Gzip put Haskell, SMLton and gcc in  a tie.  That is just bizarre.
17:46:53 <dons> compressability is no indicator of productivity, as far as I can see.
17:47:12 <dons> and wasn't this metric supposed to give some clue to productivity?
17:47:16 <dons> bah
17:47:24 <vincenz> blegh
17:47:35 <Igloo> Why didn't they like the tokens metric?
17:47:48 <dons> it disadvantages languages with heavier syntax
17:48:05 <dons> which seem to have a stronger lobbying power
17:48:22 <Igloo> Isn't that, like, the point?  :-)
17:48:29 <TuringTest> Igloo: What do braces and semicolons count as?
17:48:47 <dons> it should be a measure of how much you have to type, no?
17:49:02 <Spark> or copypaste :)
17:49:19 <TuringTest> The token count put Ruby/GHC/Python as 1st/2nd/3rd.  GZip puts them at 2nd/1st/9th
17:49:22 <Igloo> TuringTest: tokens; you just don't want to penalise using "myVariable" rather than "m"
17:49:47 <TuringTest> Igloo: Line counts did not penalize myVariable either
17:50:02 <Igloo> They do because of line length
17:50:05 <TuringTest> Why does GZip hate Haskell ?
17:50:22 <TuringTest> Igloo: There was no mandated column limit
17:50:39 <dons> there was, 128 chars, iirc.
17:50:57 <Igloo> Oh, also, it stops you doing let f = foo; g = bar; ... on one line just to get around the metric
17:52:02 * Igloo think gzip sounds like a bad approximation to the tokens idea, which wins for me, anyway
17:52:07 <TuringTest> Igloo: I would vote for token counting where ; is ignored and paired delimeters like {} and "" count as 1 instead of 2
17:52:22 <dons> I would vote for tokens, fullstop.
17:52:30 <dons> you pay if your language needs lots of junk
17:52:31 <vincenz> tokens are language specific
17:52:48 <TuringTest> vincenz: Their parser knows that
17:52:51 <vincenz> this?in:c  = 3 tokens
17:52:53 <vincenz> err
17:52:54 <vincenz> 5
17:52:57 <vincenz> in scheme it's 1 token
17:53:14 <TuringTest> vincenz: Yes, their parser should handle that, I agree.
17:53:29 <vincenz> yeah or c people will just remove whitespae
17:53:33 <vincenz> s/ae/ace
17:53:49 <Igloo> No, their parser should just do something simple that covers all langauges well enough
17:53:51 <TuringTest> There was also a worry about putting alot of information in strings.
17:54:03 <vincenz> and eval'ing
17:54:06 <TuringTest> right
17:54:10 <vincenz> disallow eval
17:54:30 <TuringTest> vincenz: There are lots of ways to put info into strings and then parse them
17:54:33 <Igloo> Tokens being something not entirely unlike [a-zA-Z]+|[0-9]+|[^[:white:]a-zA-Z0-9]+
17:54:53 <vincenz> Igloo: language dependent
17:54:54 <TuringTest> vincenz: I suggested strings count as a linear multiple of their length.
17:55:01 <vincenz> TuringTest: good idea
17:55:16 <vincenz> data-strings will be the same for all langs anyways
17:55:16 <Igloo> vincenz: Good enough for most languages
17:55:18 <TuringTest> Full thread http://alioth.debian.org/forum/forum.php?thread_id=2096&forum_id=999
17:55:20 <vincenz> although it'll add constant
17:55:26 * vincenz sighs
17:55:33 <vincenz> my rb tree remove is bugg
17:55:34 <vincenz> y
17:55:37 <dons> so, why do Clean and Haskell, and SML, seem to fall so far when gzipped.
17:55:51 <vincenz> dons: you mean gzipping the code?
17:55:55 <TuringTest> dons: Is that a new phd project?
17:55:56 <dons> it's got to be density, yeah?
17:56:00 <vincenz> easy :) lots of information, little noise
17:56:06 <dons> i.e. the very thing that improves productivity.
17:56:11 <vincenz> yep
17:56:26 <vincenz> anyone care to debug an rb-tree in c++ with me?
17:56:33 <Igloo> dons: So largest gzipped size should win?  :-)
17:56:36 <dons> so gzip is going to remove noise, and make noiser languages appear more productive than they really are.
17:56:44 <vincenz> Igloo: more like hte least reduction
17:56:59 <vincenz> either gzip
17:57:01 <dons> the least reduction. hmm. interesting
17:57:05 <vincenz> isn't ideal, it's textbased, not ast based
17:57:12 <TuringTest> We could make a "density" ranking: gzip size / plain size
17:57:17 <Igloo> That has the problem with variable names again
17:57:19 <vincenz> TuringTest: that would just promote ugly coding
17:57:20 * Igloo disappears
17:57:20 <TuringTest> Highest wins
17:57:36 <TuringTest> All the code metrics like this promote bad things.
17:57:40 <vincenz> ast-variable-name-unaffected-zipping!
17:57:53 <vincenz> see how often you repeat code constructs
17:57:57 <dons> any metric has to be simple
17:58:10 <TuringTest> Lines of code was okay with me.
17:58:19 <TuringTest> You could *see* what the hell was going on
17:58:33 <TuringTest> Token count had too many policy knobs
17:58:43 <TuringTest> (Of course I think I know how to set them...)
17:59:08 <dons> yep. gzip is simple, but it's doesn't seem to be counting the right things.
17:59:08 <vincenz> btw
17:59:14 <vincenz> want to see the paper that got accepted (non final version)>
17:59:34 <dons> short languages stay short. long languages with redundant stuff appear equivalent to the short ones.
17:59:51 <FuttyImre> i think if haskell was as fast as clean is, no one would care about this gzip-thing ;)
18:00:03 <dons> well' it's basically there
18:00:04 <TuringTest> FuttyImre: true
18:00:23 <TuringTest> FuttyImre: If we have better libraries with GHC we would be about as fast
18:00:29 <dons> but conciseness is one of our good points
18:00:53 <TuringTest> conciseness for humans....not gzip
18:01:03 <dons> so being punished for having semantically rich code sucks.
18:01:20 <TuringTest> "Size of source tarball" as metric seems...not a good idea now.
18:01:27 <FuttyImre> turingtest afaik haskell has more libs than clean, but i may be wrong
18:01:49 <dons> clean has some fun io libs
18:01:50 <TuringTest> FuttyImre: We can only use the ones with GHC on the shootout -- this is a speed problem in some tests
18:02:04 <dons> that we don't havve in our standard libs at the moment
18:02:11 <TuringTest> dons: GHC.PArr might help...we never used it.
18:02:27 <dons> even so, we're 5th ranked, clean is 2nd.
18:02:30 <dons> (in speed)
18:03:04 <dons> and only a small gap to Clean and C. so speed, eh, it's ok.
18:03:39 <adu> is there a version of Clean for non-x86 cmoputers?
18:03:51 <FuttyImre> hm.. i thought these tests should reflect real world performance
18:04:06 <TuringTest> adu: http://www.cs.ru.nl/~clean/Download/main/main.htm
18:04:06 <dons> they do...
18:04:16 <dons> there''s been a lot of progress in the last 5 years.
18:04:26 <FuttyImre> actually i doubt that haskell is any faster than cpp
18:04:43 <dons> I think maybe you should look at the shootout tests a bit more closely
18:04:44 <vincenz> :(
18:05:15 <TuringTest> FuttyImre: They are close, but Haskell has better concurrency speed
18:05:20 <TuringTest> (haskell and g++)
18:06:04 <TuringTest> FuttyImre:  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gpp
18:07:09 <dons> a compiled, highly-optimised fp lang is a fast thing.
18:07:14 <TuringTest> g++ only really beats haskell on k-nucleotide, and only because GHC's Data.Hashtable performance is poor.
18:07:19 <Excedrin> gzip bytes is pretty silly, compression ratio would be more meaningful
18:07:27 <TuringTest> perhaps
18:07:31 <FuttyImre> dons indeed that's what i would expect
18:07:39 <mwc> Doesn't compressibility, in an abstract sense, indicate a lot of rendundancy?
18:07:47 <mwc> Wouldn't that be a metric of poor code?
18:07:57 <dons> mwc, yeah, this is what we are all puzzled by
18:08:06 <dons> I mean, short code stays short.
18:08:32 <dons> so gzip is sort of an identity on short, rich code.
18:08:38 <dons> but it makes long redundant code appear short
18:09:17 * TuringTest puts his powerbook to sleep.
18:09:21 <TuringTest> Good night
18:09:39 <dons> night
18:14:02 <ihope> \id \id id
18:14:03 <lambdabot> \id id
18:14:16 <ihope> Now, if you had two lambdabots here, that could be a problem.
18:14:34 <dons> faq
18:15:14 <mwc> nah, you need to figure out what to say to one to get the other to echo the same thing
18:15:16 <dons> long story short: irc protocol says bots should use 'notices' to avoid cycles like this. several common clients are broken wrt. notices. so we don't use notices
18:15:25 <mwc> thus, starting an endless lambdabot chatter :D
18:15:47 <dons> and instead kick lambdabots that talk to each other
18:16:13 <dons> in particular 'gaim' seems not to care about the protocol spec
18:16:44 <ihope> What does gaim do?
18:16:59 <Pseudonym> http://lambda-the-ultimate.org/node/1368#comment-15564
18:17:01 <dons> pops up a new window, rings a bell, and flashes some lights, when a notice occurs
18:17:02 <Pseudonym> Was that wrong?
18:17:04 <dons> endless user pain
18:17:38 <dons> if everyone used irssi, lambdabot could uses notices (which disallow reply loops) and all would be well in the univers
18:17:50 <ihope> Whoo. Isn't that the opposite of what it's supposed to do?
18:17:57 <ihope> The gaim thing, that is?
18:17:58 <dons> hehe Pseudonym, I like it!
18:18:14 <dons> that's HWN quote-of-the-week, worthy.
18:18:32 <Pseudonym> If so, make sure the italics are added correctly.
18:19:03 <dons> ihope, exactly
18:19:21 <dons> it's the opposiite. they got confused by the word 'notice' when implementing gaim, i think
18:19:34 <dons> and decided you better 'notice' any notiiced
18:19:53 <ihope> Yep...
18:20:19 <ihope> So what happens when the services talk to them?
18:21:18 <dons> they get scared, I guess.
18:21:39 <resiak> there's a whole plugin for making services not suck, actually
18:21:45 <dons> i think we have a wiki page on the saga that resulted when we switched lambdabot to use notices
18:22:05 <ihope> @google lambdabot notice
18:22:06 <lambdabot> http://www.haskell.org/hawiki/LambdaBot_2fNotices
18:23:55 <vincenz> anyone care to read the paper I submitted?
18:24:00 <vincenz> err got accepted
18:26:39 <Smokey`> http://rafb.net/paste/results/5iMISE26.html <-- anyone have an idea why ghc is saying "Not in scope: `inputFile'"?  :(
18:26:59 <dons> vincenz, sure. got a link?
18:27:08 <vincenz> trrying to find a place to put it
18:27:13 <dons> you can just post a link, and blurb about it, then people will read
18:28:26 * ihope away
18:28:31 <dons> Smokey`, the inputFile is not visible in the 'where'
18:28:39 <dons> use a 'let'
18:29:08 <dons>         [inputFile,outputFile] <- getArgsSafe
18:29:09 <dons>         let image =  greyScale . loadImage $ inputFile  
18:30:32 <Smokey`> hmm
18:32:18 <Smokey`> well that worked :)  not sure why though, mmm,  I'm a noob all over again -_-  not knowing how language semantics operator, in what order, and thus not knowing how the compiler approches the code, and where it starts -_-
18:32:58 <dons> the 'where' can't see the variables you bind in the do block. they're not in scope
18:33:33 <Smokey`> ahhh, alrighty :)
18:34:03 <Smokey`> hehe, makes more sense now :)
18:34:08 <Smokey`> thanks dons
18:34:31 <palomer> man
18:34:35 <palomer> I have to compile ghc-cvs
18:34:44 <palomer> will apt-getting it screw anything up?
18:35:25 <palomer> oh my god it's old in my repository
18:36:19 <palomer> is ghc switching to darcs anytime soon?
18:36:19 <vincenz> blegh
18:36:27 <vincenz> I hate web software
18:36:34 <vincenz> currently using typo (rubyonrails) as personal blog on my computer
18:36:38 <vincenz> but it crashes every 10 clicks
18:36:40 <vincenz> or less
18:36:40 <vincenz> literally
18:37:08 <vincenz> alternative solutions are welcome
18:37:31 <palomer> the server or the browser is crashing?
18:37:33 <dons> vim + html
18:37:35 <vincenz> server
18:38:22 <vincenz> I want a blog that a) is stable b) has color-coding b) possibly supports minimal latex for diagrams c) has categories d) allows me to set certain categories to be registered users read only
18:38:30 <palomer> dons: have you looked into the ways emacs speed up keyboard input for yi?
18:38:32 <vincenz> s/color-coding/syntax color-coding
18:38:46 <palomer> s/speed/speeds
18:39:33 <dons> nope. yi's been but on the backburner for a couple of months now
18:40:04 <palomer> s/but/put
18:40:26 <palomer> vincenz: why not use blogger or livejournal?
18:40:28 <dons> yeah
18:40:35 <vincenz> palomer: I don't want it to be readall
18:40:46 <vincenz> some articles might contain information I do not want disclosed outside a ggroup
18:40:53 <vincenz> (patentable whatnot)
18:40:59 <palomer> oh my
18:41:11 <palomer> serious business, eh?
18:41:12 * vincenz is doing research at a research institute, we have to clear all the papers for patents before submitting
18:41:22 <palomer> which research institute?
18:41:25 <vincenz> www.imec.be
18:41:58 <vincenz> but I'm getting seriously frustrated with coding this stupid remove method on my rb tree... :/
18:42:23 <palomer> oh, applied research
18:42:26 <vincenz> yeah
18:42:31 <palomer> rb tree?
18:42:34 <vincenz> red black tree
18:42:55 <vincenz> basically I'm reimplementing std::map
18:43:03 <vincenz> well part of it
18:43:11 <vincenz> but that code is as legible as hmm... chinese
18:43:50 <palomer> for haskell?
18:43:54 <vincenz> no c+
18:43:54 <vincenz> +
18:44:00 <palomer> why would you do that?
18:44:12 <adu> haskell rocks!
18:44:13 <vincenz> for profiling purposes
18:45:08 <palomer> std::map is slow as sin
18:45:10 <palomer> use hash_map
18:45:25 <vincenz> i don't really care about performance
18:45:30 <vincenz> I just want a sparse Int -> T structure
18:45:44 <vincenz> with something better than O(N) for all operations
18:46:01 <palomer> and what's wrong with std::map?
18:46:09 <vincenz> it doesn't contain my profile code?
18:47:08 <gregarican> hey, I'm coming from a background in Ruby and Python with some Smalltalk on the side. Will learning Haskell be a big leap?
18:47:13 <palomer> and your profile code is used to determine if map is fast enough?
18:47:19 <vincenz> palomer: it's got nothing to do with speed
18:47:25 <palomer> gregarican: it'll be an interesting leap
18:47:30 <palomer> vincenz: space?
18:47:36 <vincenz> palomer: data-accesses at a highlevel
18:47:40 <vincenz> to see how the map is being used
18:47:53 <vincenz> aka, key-accesses, adds or removes
18:48:05 <vincenz> as well as allocation behaviour
18:48:09 <palomer> you know that implementing a RB tree from scratch is pretty easy
18:48:15 <vincenz> not the remove method
18:48:23 <vincenz> especially if you want your iterators to not be invalidated on removal
18:48:51 <palomer> oh, you want it to have the same interface as std::map
18:48:57 <vincenz> yes
18:49:01 <vincenz> well more or less
18:49:08 <palomer> have you looked at all the different implementations of std::map?
18:49:10 <palomer> there are tons!
18:49:15 <vincenz> I've looked at the stl one
18:49:18 <vincenz> it's horrid
18:49:22 <vincenz> I copied the code they have
18:49:29 <palomer> there are a few variants of that one, methinks
18:49:30 <vincenz> and due to how I have my header setup for the iterators, it fucks up for some reaosn
18:49:39 <vincenz> I can show you the code if you want
18:49:42 <vincenz> maybe you can take a look at it?
18:49:49 <palomer> I can try
18:49:53 <vincenz> the method that does the erase and returns the node to actually be deleted
18:50:03 <vincenz> this is more or less a copy from stl versio
18:50:04 <vincenz> n
18:50:07 <vincenz> warning
18:50:07 <vincenz> long
18:50:21 <palomer> I can't promise anything
18:50:32 <palomer> then again, I'll be compiling ghc for the next 8 hours or so
18:51:06 <vincenz> http://rafb.net/paste/results/13UqlG93.html
18:51:22 <vincenz> what it does:
18:51:27 <vincenz> given the node to be removed
18:51:32 <dons> palomer, why not dooownload a binary snapshot?/
18:51:34 <vincenz> the root address, leftmost address and rightmost address
18:51:36 <dons> they're made nightly
18:51:37 <vincenz> it removes a node
18:51:43 <vincenz> and then returns ap ointer to the node actually to be deleted
18:51:50 <palomer> dons: it won't run
18:52:03 <palomer> a pointer or an iterator?
18:52:08 <vincenz> pointer
18:52:34 <vincenz> node_pointer : public base_pointer {contains a value}
18:52:41 <palomer> I don't remember std::map methods ever returning a pointer
18:52:51 <vincenz> this is called by the remove method itself
18:52:54 <vincenz> which then deletes the node returned
18:52:57 <vincenz> and returns true or false
18:53:01 <vincenz> depending on whether something was deleted or not
18:53:31 <vincenz> http://rafb.net/paste/results/9IdQlQ87.html
18:53:33 <vincenz> this is the actual remove method
18:53:47 <vincenz> quite simple asa you can see
18:53:50 <vincenz> the method rmeove(key)
18:53:51 <vincenz> just does
18:53:53 <vincenz> remove(find(key)
18:53:54 <palomer> void erase(iterator first, iterator last) 	 Associative Container 	Erases all elements in a range.
18:54:04 <palomer> I don't see any remove method
18:54:04 <vincenz> mine just erases a single element
18:54:09 <vincenz> palomer: second paste
18:54:18 <palomer> void erase(iterator pos) 	 Associative Container 	Erases the element pointed to by pos.
18:54:28 <vincenz> right
18:54:29 <vincenz> I have that one
18:54:31 <vincenz> but it's called remove
18:54:34 <vincenz> look at second paste
18:54:35 <palomer> remove is a protected method, I'm guessing
18:54:38 <palomer> checking
18:54:39 <vincenz> public
18:54:53 <palomer> rebalance rotates, I'm guessing
18:54:55 <vincenz> bool remove(key_type k) { remove(find(k)); }
18:55:01 <palomer> remove returns a boolean!
18:55:03 <vincenz> palomer: yes
18:55:09 <vincenz> palomer: if it was actually removed or not
18:55:14 <vincenz> aka if there was a node with that key
18:55:17 <palomer> you said a pointer
18:55:19 <Pseudonym> BBL
18:55:39 <vincenz> palomer: private chan?
18:55:44 <palomer> if you wish
18:56:02 <vincenz> #meta-science
19:19:15 <Smokey`> another question... is there a function in the standard prelude/libraries that iterates through a list, applying a function to every item in the list?  (eg: iterateList :: (a -> a) -> [a] -> [a],  (a -> a) being afunction that takes an item in the list, and returns the modified version) ?
19:20:04 <Smokey`> and just to clarify, there's no sort of looping in haskell?   you justhave to rely on recursion?
19:20:58 <eivuokko> \type map
19:20:59 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:21:13 <Smokey`> sweet, thanks man :)
19:21:43 <mwc> Smokey`, try hoogle-ing for the type signature of a function you're looking for
19:22:00 <mwc> \hoogle (a -> a) -> [a] -> [a]
19:22:01 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
19:22:01 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
19:22:01 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
19:22:02 <eivuokko> For such needs, there almost always is some sort of helper in prelude.
19:22:21 <Smokey`> mwc: yeah just remembered hoogle then, didn't realise you could search for type signatures, that's AWESOME :D
19:22:38 <mwc> I think type signature searches are the most useful feature in Hoogle
19:41:44 <dons> Smokey`: a) recursion is a general form of looping. b) usually we use 'map' or 'fold' or list comprehensions :)
19:41:50 <dons> > map toUpper "haskell"
19:41:51 <lambdabot> "HASKELL"
19:42:11 <dons> > [ toUpper x | x <- "haskell"]
19:42:12 <lambdabot> "HASKELL"
19:42:38 <dons> > let f [] = [] ; f (x:xs) = toUpper x : f xs in f "haskell"
19:42:39 <lambdabot> "HASKELL"
19:43:09 <dons> in haskell, higher-order functions (functions that take functions are arguments) replace control-flow keywords of other languages.
19:43:21 <dons> i.e. we use normal libraries to define what other languages need keywords to do
19:49:30 <vincenz> dons: can I pm?
19:51:54 <araujo> Hello!
19:52:26 * araujo wonders if someone could give him some ideas here
19:52:49 <vincenz> Modern multimedia applications possess a very dynamic use of the memory hierarchy depending on the actual input, therefore requiring run-time profiling techniques to enable optimizations. Because they can contain hundreds of thousands of lines of complex object-oriented specifications, this constitutes a tedious time-consuming task since the addition of profilecode is usually performed manually. In this paper, we present a high-level library
19:54:02 <araujo> Im looking for material about designing administration systems on Haskell, does anyone have any idea, link or something, that might help me to get this done in Haskell?
19:57:52 <vincenz> be so cool if you could just write pointer-centric code in haskell to check for correctness
20:45:42 <mwc> You'd think something like iterateM would be in the hierachial libs somewhere
20:47:17 <dons> use fix :)
20:47:34 <dons> there's replicateM for a known amount
20:47:40 <mwc> Oh damn, I thought I was leet for a second :(
20:47:55 <dons> but it's sometimes pointed out that: f a = a >> f a  should be there.
20:48:29 <dons> I sometimes add:
20:48:32 <dons> repeatM_ :: forall m a. Monad m => m a -> m ()
20:48:36 <dons> repeatM_ a = a >> repeatM_ a
20:49:57 <mwc> Off hand, how would I use fix to implemenent iterateM?
20:49:59 <dons> and the awkward squad paper defines 'forever' as forever a = a >> forever a :: IO () -> IO ()
20:50:27 <mwc> what I have now is:
20:50:56 <mwc> iterateM f x = let iM f x = x : iM f (x >>= f) in
20:50:56 <mwc>  sequence $ iM f $ return x
20:51:28 <Smokey`> yet another quick question -_-   is it possible for a function returning a value to use IO functions?   I seem to be getting errors for anything that doesn't return IO ()
20:52:07 <dons> oh, fix is a little bit tricky.
20:52:22 <dons> Smokey`, yes.
20:52:33 <dons> f :: IO Bool ; f = return True
20:53:57 <dons> let forever a = fix $ \f -> a >> f -- mwc
20:54:27 <dons> but you may as well write: forever a = a >> forever a
20:54:53 <dons> \pl \f -> a >> f
20:54:54 <lambdabot> (a >>)
20:55:04 <dons> forever a = fix (a >>)
20:55:19 <Korollary> I think by returning a value he means a non-monad return type.
20:55:33 <mwc> how does this get me to iterateM?
20:55:44 <dons> what's the type of iterateM again?
20:56:12 <Smokey`> dons: thanks again, tried that before but got a very similar error message due to another error I had, so just assumed it didn't work... thanks for making me look ahrder :)
20:56:26 <dons> \type return . iterate
20:56:26 <lambdabot> forall (m :: * -> *) a.
20:56:26 <lambdabot>        (Monad m) =>
20:56:26 <lambdabot>        (a -> a) -> m (a -> [a])
20:57:00 <dons> oh, you want a function, an initial value, and an infinite list of actoins?
20:57:14 <mwc> Monad m => (a -> m a) -> a -> m [a]. I was trying to create something like iterate :: (a -> a) -> a -> a, in the way that mapM :: Monad m => (a -> m b) -> a -> m [b] apes map
20:57:15 <dons> that you then want to force withh sequence?
20:57:17 <mwc> yes
20:57:22 <mwc> that's what I was doing above
20:57:59 <dons> looks almost like foldM
20:58:22 <vincenz> palomer: ping
20:58:32 <mwc> \type foldM
20:58:33 <lambdabot> Not in scope: `foldM'
20:58:33 <palomer> pong
20:58:35 <palomer> y0
20:58:47 <dons> \type Monad.foldM
20:58:48 <lambdabot> forall a (m :: * -> *) b.
20:58:48 <lambdabot>      (Monad m) =>
20:58:48 <lambdabot>      (a -> b -> m a) -> a -> [b] -> m a
20:58:51 <vincenz> palomer: this is the book I have (the entire set)
20:58:53 <vincenz> http://www.amazon.co.uk/exec/obidos/ASIN/0201361183/qid=1143003409/sr=8-3/ref=sr_8_xs_ap_i3_xgl/026-1209993-6010806
20:59:03 <vincenz> Algorithms in C++ 1-5, sedgewick
20:59:19 <Korollary> I have the c version by that author heh
20:59:23 <mwc> no, quite the opposite of foldM actually
20:59:31 <dons> ah, unfold.
20:59:35 <mwc> yes
20:59:39 <mwc> :D
20:59:41 <dons> yeah, you could write iterate with an unfold
20:59:47 <mwc> if I find unfoldM, I'm gonna cry
20:59:54 <dons> nah, don't think we have it.
21:00:21 <palomer> vincenz: and it doesn't explain red black trees?
21:00:25 <palomer> cormen has pretty pictures and everything
21:00:26 <vincenz> it's at work
21:00:29 <vincenz> I should've looked :
21:00:32 <vincenz> damn
21:00:33 <vincenz> more books
21:00:40 <vincenz> heh I never erally looked into my sedgewick books
21:00:43 * vincenz and his bookmania
21:00:57 <vincenz> I looked a bit at graph stuff
21:00:58 <vincenz> that's it
21:01:13 <araujo> http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/contracts-icfp.htm
21:01:14 * vincenz has another algorithm which he wants to do in haskell
21:01:22 <vincenz> if you want to discuss
21:01:27 <araujo> if somebody else is interested
21:01:28 <araujo> thanks orbitz !
21:03:19 <vincenz> araujo: already read that
21:03:43 <vincenz> palomer: want to hear about the other algo I need?
21:03:45 * araujo wonders why vincenz didn't point him when he asked for help :-P
21:03:47 <vincenz> I have it more or less in ocaml
21:03:51 <vincenz> araujo: hmm?
21:04:00 <vincenz> when
21:04:07 <araujo> a few minutes ago
21:04:28 <vincenz> design adminiistration systems?
21:04:33 <vincenz> long shot from contracts
21:04:46 <vincenz> araujo: I'm busy coding :/
21:04:57 <araujo> hah, it's all right ;-)
21:04:59 <Korollary> '2
21:05:01 <dons> mwc, is let iterateM f a = unfoldr (\b -> Just (f b, b)) a
21:05:02 <Korollary> oops
21:05:06 <vincenz> palomer: want to hear the other algo?
21:05:14 <palomer> err, sure
21:05:16 <vincenz> maybe dons might have some ideas too
21:05:27 <mwc> yeah
21:05:29 <vincenz> assume a list of tokens
21:05:31 <vincenz> for instance
21:05:32 <mwc> that looks like exactly what I want to do
21:05:33 <mwc> thanks
21:05:34 <vincenz> data Token = A | B
21:05:48 <dons> \pl \b -> Just (f b, b)
21:05:48 <lambdabot> Just . ((,) =<< f)
21:05:55 <mwc> then I shoul break it out of the monad using seq?
21:06:04 <vincenz> what I want to do is do structure recognition
21:06:08 <vincenz> so I get something like:
21:06:21 <vincenz> data Special a = S a | R (Int, [Special a])
21:06:25 <vincenz> so Special Token
21:06:27 <vincenz> for instance
21:06:33 <dons> \pl iterateM f a = unfoldr (Just . ((,) =<< f)) a
21:06:33 <lambdabot> iterateM = unfoldr . (Just .) . ((,) =<<)
21:06:46 <vincenz> A A B A A B A A B = R(3, [R(2, [S A]), S B])
21:07:05 <vincenz> more complex would be
21:07:09 <vincenz> A A B A A A B A A B = 
21:07:09 <dons> \karma+ unfoldr
21:07:10 <lambdabot> unfoldr's karma raised to 3.
21:07:39 <palomer> vincenz: that looks like the spine calculus
21:07:42 <vincenz> R(3, [R([2,3], [S A]). S B])
21:07:53 <Smokey`> alright, so now my functions are returning IO a, to use IO function calls,  how does one convert from IO a, to a?
21:07:55 <vincenz> that one I don't even know how to do in my ocaml version yet
21:07:58 <vincenz> palomer: spine calcules?
21:08:06 <dons> mwc, I usually don't write infinite lists of monadic things that i then force. I usually just write a loop, hence I wandered off to look at fix :)
21:08:17 <mwc> Ah
21:08:22 <mwc> fair enough
21:08:28 <mwc> the next step is to take a finite number
21:08:32 <palomer> data Spine a= Spine [a,[Spine a]]
21:08:37 <dons> Smokey`: there's no way to do it. to do that would be to allow arbitrary side effects inside pure code
21:08:44 <mwc> I ran my code under ghci using the identity monad and it all worked pretty good
21:08:56 <dons> you instead have the outside part of your progam monadic
21:08:59 <dons> (i.e. main :: IO ()
21:09:03 <vincenz> palomer: I'm trying do recognize regular repetitions of behaviour
21:09:06 <vincenz> even at a higher order level
21:09:17 <vincenz> so if these A and B come for instance reads and writes of variables
21:09:21 <dons> Smokey': which then calls in to the pure part
21:09:23 <vincenz> I could recognize forloops in original code
21:09:28 <dons> \google that annoying IO type
21:09:29 <palomer> ok, so what do your values represent?
21:09:30 <lambdabot> http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4171142
21:09:34 <dons> \google that annoying IO type haskell
21:09:35 <lambdabot> http://www.haskell.org/hawiki/UnderConstruction
21:09:42 <vincenz> palomer: a and B can be anything
21:09:42 <dons> hmm
21:09:47 <vincenz> it's just a sumtype
21:09:51 <vincenz> that has Eq
21:09:57 <vincenz> err, any type implementing Eq
21:10:19 <vincenz> (Eq a) => Special a = Single a | Repetition (Int, [Special a])
21:10:30 <Smokey`> mmm
21:10:37 <Smokey`> that's really really bad...
21:10:43 <vincenz> I've done it in ocaml
21:10:45 <vincenz> but it's yucky
21:10:49 <dons> mwc, but to take a finite number you just use replicateM_
21:10:53 <dons> \type Monad.replicateM
21:10:53 <vincenz> and requires double linked list to perform at all
21:10:53 <lambdabot> Not in scope: `Monad.replicateM'
21:11:03 <palomer> ok, I see it
21:11:03 <dons> \type Control.Monad.replicateM
21:11:04 <lambdabot> forall a (m :: * -> *).
21:11:04 <lambdabot>           (Monad m) =>
21:11:04 <lambdabot>           Int -> m a -> m [a]
21:11:27 <dons> Smokey`: in fact it's very normal. the idea is that you avoid side effects since they mess up any chance of reasoning about your code
21:11:56 <vincenz> palomer: possibly it would be extended for somtehing smarter
21:12:09 <vincenz> such that it can see
21:12:13 <Korollary> Smokey`: It's a very atypical restriction, but you'll get used to it shortly. No big deal.
21:12:13 <vincenz> A A B A A A B A A B
21:12:17 <dons> if you need side effects or mutable state or something like that, you use a non-IO monad
21:12:19 <vincenz> = 3 times, 2 or 3 A's and then a B
21:12:34 <dons> it's just IO that has no IO a -> a function
21:12:37 <vincenz> but that gets ugly fast
21:12:40 <vincenz> and it can be done easily
21:12:44 * Korollary thinks that referential transparency builds character.
21:12:46 <vincenz> by just remooving the Int parameter froom Repetition
21:13:37 <dons> Smoeky`: maybe this will help http://www.haskell.org/hawiki/ThatAnnoyingIoType
21:13:49 <Smokey`> so basically all of my file loading code has to be in main?  that's gonna make one hell of a messy main function, not to mention i've no idea how one would go about loading things on demand
21:13:55 <Smokey`> dons: thanks
21:14:02 <dons> Smokey' : no
21:14:20 <dons> just that main -- and functions it calls can be IO
21:14:32 <dons> but you can't have IO functoins called from pure, noon - IO stuff
21:15:03 <dons> anything that talks to the outside world needs to have IO type. and anything that calls something of type IO, in turn must be IO.
21:15:08 <palomer> vincenz: they have a whole field dedicated to this stuff
21:15:10 <dons> it's vaguely like taint checking in perl
21:15:27 <dons> if one part of your code is impure, anything that uses that bit is also impure
21:15:57 <Smokey`> dons: ahh, fair enough...  just wondering how i'm going to fix what i'm doing though :P
21:16:33 <vincenz> palomer: oh?
21:16:34 <Smokey`> because I am currently using <-   however, i cant call openFile/hGetContents/whatever without returning an IO type
21:16:34 <dons> well, main calls some functions that load your files are get their contents?
21:16:43 <vincenz> palomer: I can show my ocaml code
21:16:43 <dons> hmm, not quite.
21:16:58 <dons> f = do  contents <- readFile "foo" ; g contents
21:16:58 <Smokey`> dons: yeah, that's rather messy though, guess it's just gonna have to be that way though
21:17:27 <vincenz> http://rafb.net/paste/results/UlAY6792.html
21:17:46 <dons> you use <- when you want to get the result of some io function. and that result can then be passed to other code: that's all fine.
21:18:01 <palomer> it's called pattern recognition
21:18:08 <palomer> and they have some in cormen
21:18:13 <palomer> <:o
21:18:18 <vincenz> hehe, convinced me
21:18:21 * vincenz does an amazon order
21:18:41 <dons> Smokey`: what are you trying to do?
21:19:08 <Smokey`> dons: just loading image files, pretty simple stuff...  only problem is doing it in a language i'm not completely familiar with :)   hehe
21:19:16 <dons> ok.
21:19:24 <Smokey`> i've got to load an image, manipulate it, and save it...  first year CS assignment
21:19:34 <dons> ok. cool.
21:19:43 <dons> so the bits of the program that do IO are the loading and the saving
21:19:50 <Smokey`> aye
21:19:51 <dons> so those bits get called from 'main'
21:19:58 <vincenz> palomer: done
21:19:59 <dons> the manipulatoin function is probably pure, right?
21:20:01 <vincenz> gotta love amazon
21:20:04 <dons> like: Image -> Image
21:20:06 <vincenz> they should make me their preferred customer
21:20:11 <Smokey`> dons: correct
21:20:17 <vincenz> palomer: checked the paste?
21:20:53 <vincenz> palomer: here is the list based vesion instead of DLL
21:20:56 <dons> Smokey`, so you'd structe this as:
21:20:57 <vincenz> http://rafb.net/paste/results/QI4kCE70.html
21:20:59 <dons> main = do
21:21:00 <dons>     img <- readFile "foo"
21:21:00 <dons>     let img' = transform img
21:21:01 <dons>     writeFile img'
21:21:12 <palomer> they don't have that much in cormen, though
21:21:28 <dons> and then 'transform' can be a nice pure function, with no side effects 
21:21:38 <dons> so this is what i mean about IO is the outer layer.
21:21:42 <Smokey`> yup yup,  h/o a sec,  something just clicked in my head
21:21:43 <palomer> chapter 32
21:21:46 <dons> the 'transform' does all the hard work.
21:21:49 <palomer> (string matching)
21:22:16 <dons> you can even write such a function as: main = readFile "foo" >>= writeFile . transform
21:22:30 <dons> (this is 'pointfree' notation)
21:22:47 <Smokey`> hehe, yeah it's all good now.   for some reason it never occured to me to use <-  on my own IO functions... only on the ones in the IO lib... hehe :)
21:22:58 <dons> ah, that's what I thought was happening
21:23:00 <dons> :) 
21:23:11 <Smokey`> thanks :)
21:23:33 <vincenz> amazon is buggy as hell
21:23:36 <vincenz> I was logged in twice
21:23:37 <Smokey`> alrighty, not soo bad after all :)
21:23:40 <dons> often when people want to get 'a' from an 'IO a' they  really just want to get the result of some actoin, while staying in an IO a function.
21:23:41 <vincenz> and they were two different wishlists
21:23:45 <vincenz> same email and everything
21:23:46 <vincenz> o.O
21:23:50 <dons> they don't want to actually have a pure function that calls IO.
21:24:15 <Smokey`> yeah, that was the case with me :)
21:25:07 <dons> where are you going to uni?
21:25:31 <Smokey`> ANU (Australian National University)
21:26:03 <dons> ok cool. they teach haskell in first year there now?
21:26:11 <Smokey`> yeah, this is the first year they're doing it
21:26:20 <dons> (I'm a phd student at UNSW, I teach a 3rd year Haskell course)
21:26:33 <Smokey`> they're doing haskell first, and then mainly java. (just to give everyone an understanding of functional programming languages)
21:26:39 <Smokey`> sweet :)
21:26:58 <dons> right. that's basically the same as here. though we've ditched java for C in most cases
21:27:19 <Smokey`> heh, something tells me I should be going to UNSW
21:27:32 <dons> but we've had haskell for the last 10 years
21:27:38 <dons> yeah, CSE at unsw is pretty good, I reckon
21:27:48 <dons> though ANU is also good.
21:28:11 <Smokey`> have to say the CS faculty is pretty crap, atleast from my impressions.  the courses that i'm doing are very ... basic, and the tutors/lecturers have no idea what they're doing, even for first year stuff it's pretty bad
21:28:13 <dons> there are some 4th year courses that are taught simultaneously in canberra and at unsw via video link
21:28:26 <Smokey`> we'll see how things progress next year
21:29:12 <Smokey`> dons: wow, very cool :)
21:29:42 <dons> yeah, the theorem proving course is shared. 
21:29:45 <dons> there might be some others
21:30:17 <dons> anyway, if you're bored with your course, you can always learn more haskell..
21:30:37 <Smokey`> considering the possability of transfering uni's in 3rd year though,   I personally want to do masters, and do my best to get nominated for a PhD, however I'm more interested in 3D graphics and physical simulation,  and ANU deinately ain't the place for that (atleast from what I've seen)
21:30:58 <vincenz> Smokey`: there's this guy from poland doing interesting stuff
21:31:03 <vincenz> I used to have a bunch of articles
21:31:12 <vincenz> like deformable bodies in 3d
21:31:14 <dons> oh. interesting. there's a couple of comp graphics courses here. let me find the pagges.
21:31:22 <Smokey`> hehe, haskell is nice, i'll it tht... but i'm sticking wiht C++ with the occasional inline assembler :P  atleast for my kinda projects
21:32:01 <dons> well, if you like the segfaults
21:32:08 <dons> you using ghc?
21:32:13 <Smokey`> yeah
21:32:24 <Smokey`> vincenz: sweet :)  i've played with a little bit of that stuff myself, though i'm far more interested in computer graphics than anything
21:32:29 <dons> good. also, did I introduce lambdabot?
21:32:39 <dons> it hass a lot of resources to play with:
21:32:44 <dons> > map (+1) [1..10]
21:32:45 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
21:32:49 <dons> \type map
21:32:50 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
21:32:52 <dons> \kind (->)
21:32:53 <lambdabot> ?? -> ? -> *
21:32:58 <Smokey`> you didn't, but considering how the majority of you guys have answered my questions with lambdabot, i got the idea :)
21:33:04 <dons> \docs Data.List
21:33:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:33:09 <dons> \hoogle (a -> b) -> [a] -> [b]
21:33:10 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
21:33:10 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
21:33:10 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
21:33:17 <dons> \index map
21:33:17 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
21:33:27 <dons> \libsrc Data.List
21:33:27 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Data/List.hs
21:33:56 <Smokey`> very very cool :) more specificalyl useful :)
21:34:13 <dons> and also haskell.org. Check it out. it's got a lot of interesting stuff for people learning
21:34:41 <adu> yes, haskell.org is nice
21:34:44 <Smokey`> yeah, I've been getting most my info via haskell.org
21:34:49 <dons> \djinn (a -> b) -> [a] -> [b]
21:34:49 <lambdabot> -- f cannot be realized.
21:35:01 <dons> \djinn a -> b -> Either (a,a) (a,b)
21:35:02 <lambdabot> f a b = Right (a, b)
21:35:39 <dons> \pl \x f y -> y + (f x)
21:35:40 <lambdabot> ((+) .) . flip id
21:35:50 <dons> lots of fun stuff
21:36:11 <Smokey`> hmm, haven't bothered to look into actually compiling things properly yet, jsut been toying around with ghci, but can Haskell product static/dynamic libraries, as well as executable files, or?
21:36:24 <dons> ghc A.hs
21:36:36 <dons> yes, like gcc. you just use ld to make libs
21:36:50 <dons> or Cabal does it for you -- a build system a bit like make
21:37:05 <Smokey`> yeah, and how about in windows?  (sadly went from almost purely *nix before, back to windows due to visual studio :P)
21:37:14 <Smokey`> i'll look into it anyway :)
21:37:17 <dons> yep. it lets you build libraries on windows
21:37:20 <dons> \where Cabal
21:37:20 <lambdabot> http://www.haskell.org/cabal
21:37:41 <Smokey`> very sweet, I might actuall have a personal use for haskell then :)
21:38:01 <Smokey`> depending on how benchmarks compare w/ gcc 4.0 compiled code and ghc compiled code
21:38:09 <dons> \shootout
21:38:10 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
21:38:25 <dons> roughly the same. ghc is sometimes faster
21:39:00 <dons> but the Haskell code is usually much shorter, and has less bugs, and works on higher levels of abstraction
21:39:09 <Smokey`> I'm curious if that's GCC 4 though,  it has some optimizations that would greatly optimize the kinds of code i'd be working with.
21:39:26 <dons> graphics code?
21:39:53 <dons> this is the intro graphics course: http://www.handbook.unsw.edu.au/postgraduate/courses/2006/COMP9415.html
21:40:11 <Smokey`> hehe, intro... cute :)  I'm sure I could teach the class, but i'll have a look :)
21:40:37 <dons> there's also an advanced course.
21:41:11 <dons> but I can't find its page yet.
21:41:20 <Smokey`> *cuts straight to tutorial/lecture pages*
21:42:48 <Smokey`> I most definately know ALOT about every single subject they touch there :)
21:44:57 <vincenz> heh
21:44:58 <vincenz> dons: 
21:44:59 <vincenz> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=1&xloc=1&binarytrees=5&chameneos=5&message=4&fannkuch=3&fasta=3&knucleotide=5&mandelbrot=4&nbody=3&nsieve=0&nsievebits=2&partialsums=2&pidigits=2&recursive=2&regexdna=4&revcomp=3&spectralnorm=5&hello=0&sumcol=1&calc=Calculate
21:45:10 <vincenz> dons: just put nsieve at 0 cause it's not impemented in ocaml
21:46:45 <dons> Smokkey`: and this is the advanced course, http://www.cse.unsw.edu.au/~cs9018 I think
21:48:38 <Smokey`> "Home page from last time course was run" ?
21:48:46 <dons> like, last year
21:48:58 <dons> the advanced course is run every 2 years, I think
21:49:08 <dons> once they collect enough phd students to merit a class
21:49:35 <dons> that's the outline http://cgi.cse.unsw.edu.au/~cs9018/cgi-bin/moin.cgi/OutLine
21:50:20 <Smokey`> dons: yeah, again i know most of that stuff, but i could definately beenfit from the course and easy marks ;)
21:50:23 <dons> actually, it's being run next session, so maybe this is run once a year.
21:51:09 <dons> ok, so maybe you should just apply to do your research somewhere where they work on the stuff you're interested in
21:51:10 <Smokey`> You know you're a nerd when you're only in first year CS yet cant find a course to challenge you (a CS course that is)
21:51:49 <Smokey`> dons: yeah, main reason i decided to go to uni was the fact that I need ot touch up on a few key areas,  a) Mathematics,  b) Phyiscs, and c) Academic writing :)
21:52:03 <vincenz> Smokey`: d) sex
21:52:12 <dons> having a degree is a useful thing
21:52:29 <Smokey`> dons: hehe, yes, and the most important point of them all...  the expensive piece of paper :)
21:52:29 <vincenz> dons: yeah, the funny thing is that content of degree is useless
21:52:39 <vincenz> dons: nearly ALL the engineers of my year are doing unengineery things
21:52:42 <vincenz> except the true nerds
21:52:47 <vincenz> who have all landed lowlevel it jobs
21:53:11 <dons> though you won't learn much academic writing in an undergraduate degree (unless you do philospophy, perhaps)  
21:53:51 <Smokey`> i really suck at math/physics though, so while i'm acing the CS courses, i'm spending alot of my time in math/physics... so it all evens out :)   so i'm definately not bored with uni.
21:54:07 <dons> yeah, the interesting stuff only starts once you graduate and do honours or research
21:54:20 <Smokey`> dons: the vast majoriy of our assignments are report writing stuff... (except programming, which is this simple haskell thingie)
21:54:26 <dons> oh. that sucks
21:54:29 <dons> they don't want code?
21:54:41 <dons> oh, in physics and maths, you mean?
21:54:44 <Smokey`> aye :)
21:55:07 * vincenz feels ignored
21:55:20 <dons> :} vincenz
21:55:51 <dons> I was just shocked by what you said, about none of them getting eng jobs. i didn't know what to say.
21:56:02 <vincenz> well most end up in like manager like job
21:56:06 <Smokey`> hehe, doing another course which is reallllly dodgy,  COMP1200 "Perspectives on Computing"... soo pathetic, it's as broad as humanly possible, covering hardware, hardware design, history of hardware, operating systems, operating system history, programming languages, language history, etc... all these random, topics, which we only cover for at most 15 minutes each...
21:56:06 <vincenz> (notice I -was- in EE)
21:56:13 <vincenz> not CS
21:56:17 <vincenz> some ended up in consulting jobs
21:56:20 <Smokey`> it's sooo pathetic,  YET it's a requirement for ALOT of second year courses... sigh
21:56:23 <dons> perspectives. this is just silly.
21:56:27 <vincenz> IT consulting, not programming consulting
21:56:40 <vincenz> Smokey`: how fun
21:56:43 <vincenz> Smokey`: we had a similar course
21:56:46 <vincenz> it was called multimedia something
21:57:00 <vincenz> basically it treated stupid stuff like what is UTF, what is a font with (Forgot the word)
21:57:08 <vincenz> sans-serif font
21:57:11 <dons> luckily i did not have to do such a course.
21:57:13 <vincenz> that ocurse made me laugh
21:57:22 <dons> they just ask us to code lots and lots of things.
21:57:35 * vincenz did get to make a speechrecognition system tho
21:57:37 <vincenz> from scratch :)
21:57:51 <vincenz> and an image-recognition for 4-channel satelite images
21:57:59 <dons> that's cool. in a neural networks course, or ai or something?
21:58:00 <vincenz> (like what is a building, a field, a river, car)
21:58:02 <dons> I did image recognition in a NN course.
21:58:16 <vincenz> dons: speech-recognition was for a limited word set so what we basically did was use fixed phonemes
21:58:28 <vincenz> err frequencies of those phonemes in the histogram
21:58:49 <Smokey`> so far i'm not sure what I should do uni wise though, I can either keep going with the math/physics stuff all the way through to 3rd year, or i could stop at 2nd year, and just got full on CS which would be easy AND fun :)
21:58:54 <vincenz> dons: all matlab
21:59:10 <vincenz> the rest of our courses was mostly very theoretical
21:59:19 <vincenz> like wave propagation using the basic laws of whathisname
21:59:25 <vincenz> em-waves that is
21:59:32 <dons> Smokey`, well, I encourage you to pick the hard stuff :)
21:59:52 <Smokey`> yeah that's what i'm trying to do atm, but lack of motivation is making me fall behind math/physics :S
21:59:53 <dons> so no 'Web Applicatoins and E-Commerce' and such like
22:00:12 * vincenz did get a cs-like course in his last year as optional course, compiler construction
22:00:16 <Smokey`> bleh, anyway :)  enough bitching. :)  back to Haskell!
22:00:36 <vincenz> dons: to be honest, all my ai courses were a bit of a dissapointement
22:00:47 <vincenz> NN sound much cooler than what they really are
22:00:53 <vincenz> affine equations with thresholding
22:01:22 <dons> I enjoyed my 1A course -- the assignments were competitions between the students, icfp style.
22:01:28 <vincenz> cool
22:01:34 * vincenz wishes he had done cs
22:01:42 <dons> you had to program a haskell bot to solve mazes. and it would fight against cops created by the other students
22:01:56 <vincenz> all my cs knowledge was learned afterhours during the 1.5 years I was a software consultant
22:02:00 <dons> your score for the assignment was the score your bot got in the competition
22:02:07 <Smokey`> lol, nice
22:02:13 <vincenz> dons: lucky sob
22:02:18 <vincenz> :)
22:02:50 <vincenz> we should have a monthly or bimontly mini-icfp for #haskell
22:02:51 <vincenz> that would rock
22:03:16 <shapr> Yeah
22:03:19 <vincenz> if some people are interested
22:03:23 <vincenz> I could look into setting it up
22:03:28 <vincenz> possibly with shapr's help for the web-side
22:03:52 <vincenz> in the trend of the weekly ruby quiz, but then wider-spaced and a bit harder than those simpletons
22:04:11 <vincenz> 24-hours tops
22:04:20 <vincenz> with a rotation schedule for assignment-generation
22:04:28 <shapr> It's hard to get enough people interested in weekly contests on #haskell, it's easier to do weekly study groups.
22:04:40 <vincenz> shapr: weekly is too frequent for interesting games
22:04:47 <vincenz> shapr: hence monthly or bimonthly
22:04:51 <shapr> Ah, right
22:04:53 <Smokey`> monthly.
22:04:53 <vincenz> and hype it like a week or two in advance
22:04:56 <vincenz> get a few people involved
22:05:00 <vincenz> who agree in taking turns making problems
22:05:11 <vincenz> it might result not only in fun, but also some cool code-pieces to be reused
22:05:54 <shapr> Ok, let's do it.
22:05:58 <vincenz> open-submissions into a darcs repo that are then afterwards available for discussion/refactoring
22:06:09 <Smokey`> dons: so what're you doign at uni now? (exactly?)
22:06:17 <vincenz> shapr: ya hear?
22:06:22 <vincenz> shapr: I got my first paper accepted \o/
22:06:31 <shapr> Yeah, I heard, that's cool!
22:06:37 <vincenz> I was happy
22:07:12 <dons> Smokey`, I'm finishing the last year of a phd studying type safe linking of object code
22:07:33 <dons> well, maybe the lsat year. we'll see.
22:07:36 <Smokey`> hehe, suprise, suprise ;)
22:09:39 <Smokey`> sad thing is, if I were writing this assignment in C++, I would've been done hours ago :P  (that being said, would'nt have learned nearly as much as I have thus far)
22:10:07 <Smokey`> *wouldn't
22:10:27 <dons> ultimately, you'll be more productive if you get good at Haskel
22:10:37 <dons> C++ is hell in comparison.
22:11:27 <dons> it's doing a lot of things for you to make particular things easy. pattern matching on data structures, strong static typing , for example, will really make your life easier
22:11:51 <Smokey`> heh, from what i've gathered haskell has no class variables, 'data structures', global 'variables', references/pointers, or inline assembler :)  no idea how it goes as for multiple inheritance
22:12:05 <dons> ?
22:12:06 <vincenz> dons: tell me about it... c++ sucks... rbtrees with pointers YICK
22:12:12 <dons> it has data structures.
22:12:22 <dons> that's what 'data' does
22:12:28 <dons> class variables? what are they? type variables?
22:12:30 <vincenz> shapr: so how do you want to set it up? name it?
22:12:34 <dons> global variables are fine.
22:12:37 <vincenz> shapr: halgo-challenge?
22:12:40 <dons> references you get from a Ptr
22:12:53 <Smokey`> dons: member variales for classes sorry
22:12:54 <dons> inline asm, well, really. you just link a .S module if you need that.
22:13:15 <Smokey`> that is, a class that's accessible to all member functions (functions belonging to a class), and is persistant to the point of deconstruction of the class.
22:13:15 <dons> member variables for classes, like OO classes?
22:13:19 <Smokey`> dons: aye
22:13:27 <Pseudonym> What is this "class" of which you speak?
22:13:41 <Smokey`> again, I think i'm just too focus minded towards C++ :P
22:13:50 <Pseudonym> :_)
22:14:14 <Pseudonym> C++'s idea of what a "class" is isn't what a lot of other languages' idea is.
22:14:31 <Smokey`> imo Haskell has it's uses, and by the looks of it, that use is non-performance critical, heavily mathematically based applications
22:14:33 <rizzix> C++ classes are templates for Objects
22:14:37 <dons> Haskell's type system is strictkly more powerful ththan C++, and offers more features, the'res a paper by Garcia et al comparing Haskel to C++ and others. it has a fun table on page 3 I think showing all the features other languages are missing.
22:14:41 <Pseudonym> In fact, when you say "class" in C++, you're actually doing three separate things.
22:14:45 <Smokey`> I personally dont know of many heavily mathematically based apps that aren't performance critical -_-
22:14:50 <Pseudonym> 1. Declare a set (i.e. class) of types.
22:14:57 <Pseudonym> 2. Declare a SPECIFIC type.
22:15:05 <Pseudonym> 3. Declare that the specific type is a member of the set.
22:15:28 <Pseudonym> BTW, every program is performance critical at some level of abstraction.
22:15:40 <Smokey`> Pseudonym: true, some more than others however. :)
22:15:41 <Pseudonym> A program that computes the monthly payrolls is useless if it takes three months to run.
22:16:11 <Pseudonym> That's even a hard real-time constraint.
22:16:26 <Smokey`> Pseudonym: heh
22:16:59 <Smokey`> given my lack of experience iwth Haskell, I'm not one to jude 'against' Haskell.  so i'll just say this:
22:17:22 <Smokey`> I find C++ more convenient, and gives me lower level control to memory/computation compared to haskell :)
22:17:40 <rizzix> Maybe you are not comfortable with Haskell yet
22:17:43 <rizzix> ;)
22:17:50 <Smokey`> and I understand C++ far more, thus can take advantage of code-reuse far more efficiently in C++ as opposed to Haskell
22:18:00 <Pseudonym> True enough.
22:18:09 <Pseudonym> Sometimes the best tool for the job is the one you know.
22:18:11 <dons> yeah, I've not heard anyone say C++ was more convenient before.. I think you'll just need to learn Haskell a bit more.
22:18:31 <Smokey`> dons: I can garentee you Philippa_ will tell me the same thing :P  haha
22:18:49 <Pseudonym> I wouldn't say C++ was more convenient.  I'd say that it's sometimes the path of least resistance.
22:19:23 <Pseudonym> Having said that, good C++ programmers are rare.
22:19:32 <Pseudonym> Though not as rare as good Haskell programmers, admittedly.
22:19:42 <dons> Smokey`, regarding the thing about mathematical aps, that's far from the norm. check out: http://haskell.org/haskellwiki/Haskell_in_practice
22:20:00 <Pseudonym> I'd say the most common application is "structure hacking".
22:20:15 <dons> yep.
22:20:23 <Pseudonym> As opposed to, say, number crunching.
22:20:27 <dons> hence the large number of compilers/transformers/tranlsators
22:20:29 <Smokey`> dons: and also, rather more 'algorithmic' applications :)
22:20:43 <dons> well, lambdabot and darcs are written in haskell
22:20:49 <dons> I wrote a text editor, yi
22:20:50 <dons> \where yi
22:20:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
22:20:53 <dons> and an mp3 player
22:20:55 <dons> \where hmp3
22:20:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
22:21:03 <Pseudonym> The mp3 player is definitely the odd one out here.
22:21:08 <Pseudonym> Though lambdabot is pretty odd.
22:21:13 <dons> so, like I say, it's a general purpose language
22:21:26 <Smokey`> dons: I'm not saying you CANT write apps in it, i'm saying it's most probably not as efficient to write apps in it for certain types of applications
22:21:41 <Pseudonym> That is a tautology.
22:21:42 <dons> efficient in what sense?
22:22:08 <Pseudonym> Because you just define the class of "certain types of applications" to suit the assertion. :-)
22:22:10 <Smokey`> dons: potentially faster to develop (for say, an mp3 player), however, i'm speaking computation wise.
22:22:37 <Pseudonym> Think of it this way:
22:22:46 <Smokey`> again, i dont know haskell well enough, and cant think of what is most probably the best way to approach say, an mp3 player yet :)
22:22:52 <Smokey`> so it's quite possible i'm wrong. :)
22:22:55 <sethk> hello, all.
22:22:58 <Pseudonym> An idiomatically written C++ program is always going to be larger than the idiomatically written C program.
22:23:05 <Pseudonym> Because of exception handing, RTTI etc.
22:23:14 <sethk> I need to read two four byte binary numbers from a file into a variable (two variables, actually)
22:23:23 <sethk> what are my options?
22:23:29 <Pseudonym> So you can argue that in some applications (e.g. small embedded platforms), C is a better choice.
22:23:31 <dons> you using Binary, sethk?
22:23:37 <Pseudonym> You agree, Smokey?
22:23:48 <Smokey`> Pseudonym: a) never ever EVER have RTTI turned on, unless you use it (in which case you need to revise the way you wrote said app)
22:23:52 <sethk> dons, these values were written by a C program, so I'm using whatever works  :)
22:24:02 <dons> \where NewBinary
22:24:03 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
22:24:10 <sethk> dons, thanks, reading ...
22:24:16 <dons> or if they're written by C, use an ffi wrapper over fread
22:24:22 <Pseudonym> Smokey: That's a bit harsh.
22:24:24 <Smokey`> b) yes, exception handling has it's place, and not always necessary for C++, just more fore end-user apps,  c) doesn't haskell have exception handling too?
22:24:35 <Pseudonym> My point is this./
22:24:47 <Pseudonym> The idiomatically written C++ program is likely to be FAR more robust than the C program.
22:24:47 <Smokey`> Pseudonym: RTTI is deprecated, and there are far more efficient, easier, and better ways of achieving the same result. :)
22:24:49 <Pseudonym> Would you agree?
22:24:55 <sethk> dons, I'm not quite sure how to do it with ffi.  This particular program has no C in it, but I could close the file, then let C open it and read it and pass me the data.
22:25:02 <sethk> dons, that might be the easiest way
22:25:15 <sethk> dons, I say close it so I won't have to deal with passing a handle or anything complicated like that
22:25:42 <Smokey`> Pseudonym: depends on what features of C++ one uses, generally speaking C will be faster.
22:25:46 <dons> if its only going to be 8 bytes all up, read 8 Word8s and do your own bit shifting
22:25:48 <Pseudonym> Sure.
22:25:56 <Pseudonym> For example, an idiomatic C programmer will use <string.h>
22:26:03 <Pseudonym> where an idiomatic C++ programmer will use <string>
22:26:18 <Pseudonym> A C programmer will use <stdio.h>, a C++ programmer will use <iostream>
22:26:30 <vincenz> or <cstdio>
22:26:32 <vincenz> :D
22:26:35 <Smokey`> Pseudonym: yes, but how does this relate to (the topic in which i've already forgotten)?
22:26:41 <sethk> dons, I don't mind the bit shifting.  I just haven't done reading/writing of binaries in haskell, so I have to figure that part of it out.
22:26:46 <Pseudonym> The C version is often faster and smaller, but the C++ version is going to be more robust.
22:26:48 <Smokey`> as for string.h,  i actually use my own implementation
22:26:49 <vincenz> shapr: ping
22:26:51 <Pseudonym> My point is this.
22:26:55 <vincenz> Pseudonym: none
22:26:57 <sethk> but the Binary thing you told me looks interesting also.
22:27:06 <sethk> dons, you think it's overkill for just reading two ints?
22:27:07 <dons> yep, i use it a lot, sethk.
22:27:11 <dons> yeah, maybe:
22:27:13 <Smokey`> Pseudonym: i'll brb, gotta start dinner before house mates do, else i'll be waiting years! :)
22:27:15 <dons>     w1 <- getWord8 h
22:27:15 <dons>     w2 <- getWord8 h
22:27:15 <dons>     w3 <- getWord8 h
22:27:15 <dons>     w4 <- getWord8 h 
22:27:15 <dons>     return $! ((fromIntegral w1 `shiftL` 24) .|.
22:27:18 <dons>            (fromIntegral w2 `shiftL` 16) .|. 
22:27:20 <dons>            (fromIntegral w3 `shiftL`  8) .|.
22:27:22 <Pseudonym> An idiomatic Haskell program is going to be EVEN MORE robust.
22:27:23 <dons>            (fromIntegral w4))
22:27:26 <dons> is all you need, basically?
22:27:36 <Pseudonym> Yes, it might be a bit slower.
22:27:40 <Pseudonym> Yes, it might use more core.
22:27:42 <sethk> dons, looks like it, yes.  There isn't a nice getWord32?  :)
22:27:46 <Pseudonym> But it's far less likely to just plain break.
22:27:51 <Pseudonym> And it's going to be faster to write.
22:27:56 <dons> that''s it there, sethk. unless you wrap fread.
22:28:10 <Pseudonym> Engineering is the art of the tradeoff.
22:28:15 <dons> where getWord8 == hGetChar h
22:28:49 <dons> (that code is from the Binary instance for Word32, iirc)
22:28:57 <sethk> dons, ok, let me try that. 
22:29:09 <sethk> dons, you mean the w1 <- ... code?
22:29:36 <dons> yep. I have a stripped down version of Binary for simple uses here http://www.cse.unsw.edu.au/~dons/code/hmp3/Binary.hs
22:29:38 <Smokey`> Pseudonym: I agree completely.
22:29:43 <Smokey`> however... :) (you knew it would come)
22:30:03 <Smokey`> I tend to care more about computation/processing time, than stability and how many lines it takes to write.
22:30:12 <dons> sethk, with that, it would be a matter of (x <- get :: IO Word32) I think.
22:30:12 <Pseudonym> What type of programs do you write, then?
22:30:31 <Smokey`> most of the things I do are middleware libraries, not end-user applications, which have documentation... programmer disobeys docs, crash.
22:30:55 <Smokey`> it's just like some idiot programmer writing 1.0 / 0.0   it's gonna crash in C++
22:31:03 <sethk> dons, thanks, give me a few minutes to read.
22:31:08 * Pseudonym nods
22:31:17 <Pseudonym> I used to program a database server for a living.  In C++.
22:31:31 <Pseudonym> Unlike people who blindly criticise C++, I'm sold on it for many uses.
22:31:43 <Pseudonym> But the fact is, most programs I write don't need to scrounge cycles.
22:31:49 <dons> Smokey` might want to check out 
22:31:51 <Pseudonym> This also applies to prototype code.
22:31:53 <dons> \google why haskell matters
22:31:55 <lambdabot> http://www.haskell.org/haskellwiki/Why_Haskell_Matters
22:32:17 <palomer> haskell matters?
22:32:19 <Smokey`> dons: read it a long time ago, and again I agree.
22:32:28 <Pseudonym> My boss used to comment that there's nothing wrong with prototype code so long as it doesn't get shipped.
22:32:38 <Pseudonym> He went on to comment that a lot of prototype code gets shipped.
22:32:45 <Smokey`> lol
22:32:54 <Pseudonym> The concluded that to avoid prototype code getting shipped, write it in another language.
22:33:01 <palomer> I don't see why people like to take pretty things and then apply them
22:33:04 <Pseudonym> Smartest boss I ever had.
22:33:12 <palomer> pretty things are not to be applied, they are to be admired
22:33:37 <dons> \quote mwc
22:33:37 <lambdabot>  I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
22:33:46 <mathrick> ooh, Pseudonym is here
22:33:54 <Pseudonym> Where?
22:33:57 <vincenz> join the HALGO-challenge!
22:33:57 <Pseudonym> Oh, right.
22:34:04 <mathrick> Pseudonym: hjælp with bison needed!
22:34:14 <dons> \quote ##C++
22:34:14 <lambdabot>  haskell == plain english ??
22:34:27 <Pseudonym> Unfortunately, Pseudonym has to go.
22:34:28 <Pseudonym> Home.
22:34:30 <shapr> Pseudonym: Ideas for a #haskell specific ICFP programming contest?
22:34:33 <Pseudonym> And won't be back for abour four days.
22:34:36 <shapr> yow!
22:34:37 <Pseudonym> Oooh.
22:34:38 <mathrick> Pseudonym: nooooo!
22:34:46 <vincenz> Pseudonym: hey I've been thinking to start a sort of ICFP contest bimonthyl for the #haskell/haskell community
22:34:51 <Pseudonym> Cool.
22:34:54 <dons> shapr, one idea is that it shouldn't be as hard as the real contenst...
22:34:54 <vincenz> right what shapr said
22:34:57 * Pseudonym will think about problems if you like
22:35:00 <vincenz> dons: 24 tops
22:35:03 <shapr> Yes, please think about it.
22:35:04 <vincenz> 24 hour tops
22:35:11 <Pseudonym> I already have an idea.
22:35:15 <shapr> tell us!
22:35:16 <Pseudonym> Here's a code.  Break it.
22:35:20 * shapr goes for breakfast
22:35:25 <vincenz> shapr: break-fast?
22:35:31 <vincenz> that some kind of solution to Pseudonym's problem?
22:35:55 <vincenz> Pseudonym: wouldn't that filter the playing-field to cryptoers/
22:36:05 <dons> i'd die if it took 3 days/ 6k loc each week...
22:36:19 <Smokey`> I agree, Haskell is safer, and faster to develop with (assuming you know the language), problem is, for most of the apps/libs I work with, I'm more than willing to sacrifice safety for speed.  because it's up to the other programmers to not be idiots, and check that they're using my libs safely, in their end-user apps :)
22:36:20 <vincenz> dons: we're thinking (bi)monthly, 24 hours
22:36:28 <Smokey`> that's all I'm saying...
22:36:38 <vincenz> dons: cause noone can judge and generate games weekly
22:36:43 <mathrick> http://pastebin.com/615688 <-- why does bison claim it contains only useless rules after I uncomment %type <exp_list> act_list exp_list ?
22:36:47 <vincenz> besides too much and people will lose interest
22:36:50 <Smokey`> anyway, I like haskell and I can definately see uses for it :)
22:37:05 <vincenz> Smokey`: suffer, muhaha
22:37:08 <adu> i like Haskell too
22:37:26 <vincenz> Pseudonym: howabout the name "halgo-challenge" for the entire concept?
22:37:31 <vincenz> haskell-algorithms...halgo
22:37:39 <dons> remember though, that it is general purpose, and you can do any project. if you think it's missing something, ask us and we'll point to where the missing piece lives
22:37:57 <dons> (that was to Smokey`)
22:38:06 <vincenz> that's one great thing of the haskell community, there's very little bitrot, so you can find a lot of solutions to different pieces
22:38:08 <Smokey`> on a side note, with the "Why Haskell Matters" article, if the C++ source code in there use STL calls (which it should, considering the haskell example is using filter), it'd be alot smaller :)
22:38:21 <vincenz> Smokey`: stl doesn't scale imho
22:38:29 <vincenz> unless you start using functors which are just dirty to use
22:38:34 <adu> i think i might try making an IDE in haskell
22:38:36 <vincenz> and even then I doubt you'd scale far
22:38:37 <Smokey`> STL doesn't have functors.
22:38:44 <vincenz> Smokey`: std c++ does
22:38:44 <dons> adu, maybe you want to hack on hIDE?
22:38:52 <vincenz> yep stl does
22:38:55 <vincenz> functors = functorials
22:39:15 <vincenz> it should afaik
22:39:16 <Smokey`> mmm
22:39:23 <vincenz> but they're messy
22:39:25 <Smokey`> C++ has function pointers
22:39:26 <vincenz> like all template-hell
22:39:28 <Smokey`> not functors though
22:39:32 <eivuokko> vincenz, fwiw, nowdays usually called function objects.  And yeah, STL scaling isn't all too clear.
22:39:35 <vincenz> Smokey`: they have specfic functors tho
22:39:42 <Smokey`> vincenz: yes
22:39:47 <vincenz> eivuokko: and I've done some messy template code that screws up compiles
22:39:50 <vincenz> :/
22:39:56 <vincenz> compilers
22:40:08 <Smokey`> anyway, I like the low level access to the machine that C++ gives me :)
22:40:11 <eivuokko> vincenz, Yeah, so.  Hardly because of stl, tho, I'd guess.
22:40:16 <vincenz> for instance...imagine some abstract ddt<T> operator[] returns a var<T>
22:40:25 <vincenz> and var<T> has operator T&()
22:40:29 <vincenz> for some reasono
22:40:35 <vincenz> ddt<var<T>>[] won't give you a T&
22:40:44 <vincenz> err
22:40:50 <vincenz> ddt<T> operator[] returns T
22:40:55 <vincenz> var<T> operatorT&
22:40:58 <vincenz> you can't use those together
22:41:11 <vincenz> and I had other template code that crashed gcc 3.3 .. 
22:41:13 <eivuokko> Of course not.  Two user defined onversions
22:41:15 <vincenz> (correct at that)
22:41:23 <vincenz> eivuokko: yeah but why shouldn't it be able to
22:41:29 <vincenz> plus you can't overload . and .*
22:41:34 <vincenz> nor can you overload ?:
22:41:35 <sethk> dons  I'm getting "no instance for (Integral Char)  for the w4 part of the statement with the shifts
22:41:44 <sethk> dons, w4 is the only part not shifted, which should be a clue
22:41:44 <vincenz> it's messy as hell
22:42:08 <Pseudonym> Gotta go.
22:42:09 <Pseudonym> Nytol!
22:42:24 <vincenz> time to do the last parts of my rb tree
22:42:29 <vincenz> good thing I can dump to something eradable by haskell
22:42:37 <vincenz> so I can easily check consistency with 3 lines oof haskell cod
22:42:38 <vincenz> e
22:42:49 <sethk> dons, no, it is saying it for all four parts  (sorry)
22:43:01 <dons> seth, sorry, check in Binaryhs: getWord8 should be : do c <- hGetChar h; return $! (fromIntegral (ord c))   
22:43:03 <sethk> dons, do I need to use (ord w4) or something?
22:43:14 <vincenz> so about that name, dons, "halgo" sound like a good name?
22:43:32 <sethk> dons, thanks.  I was sort of thinking in the right direction...
22:43:34 <dons> sethk, and it has some type ... -> IO Word8
22:43:41 <dons> yep
22:44:01 <dons> grab the code from my Binary.hs to check things, if you want
22:44:07 <sethk> dons, right now I just want to get it working quickly.  People are waiting and trying not to look impatient (and failing  :)  )
22:44:10 <dons> vincenz, where halgo standss for?
22:44:19 <vincenz> haskell-algorithm challenge
22:44:21 <vincenz> halgo for short
22:44:25 <sethk> dons, I will, definitely, read it carefully, but a bit later tonight.  :)
22:44:31 <dons> yep :)
22:44:34 <vincenz> halgoch otherwise
22:44:56 <vincenz> or better names....
22:45:03 <dons> how about, HAC! the Haskell Algo Challenge
22:45:05 * vincenz always gets stuck on names, even for variables
22:45:11 <vincenz> dons: ooh
22:45:19 <vincenz> dons: nice phonetic play
22:45:37 <vincenz> channel #hac created
22:45:54 <dons> so we can have monthly h'sac's
22:45:58 <dons> sorry. 
22:46:00 <dons> hac's
22:46:13 <vincenz> montly or bimonthly...depending on demand and production
22:46:25 <vincenz> 24 hour submission deadline
22:46:31 <vincenz> saturday->sunday
22:46:55 <dons> lambdabot: \join #hac
22:48:21 <shapr> @yow !
22:48:21 <lambdabot> Are we having fun yet?
22:48:29 <shapr> I am, aren't you?
22:48:36 <shapr> ofelt: Are you having fun?
22:48:38 <vincenz> shapr: #hac
23:02:10 <sethk> dons, I must have typed something wrong with the shifts.  I got a strange answer.  But the bytes are correct, and when I did w1 +w2*256 + w3*256*256 + w4*256*256*256, which is the same thing, I get the right answer.
23:02:25 <sethk> dons, the main thing is, it's working and thanks for the help as usual.
23:02:30 <dons> ok. cool.
23:03:01 <dons> maybe the Binary code writes things in the opposite endianess.
23:18:41 <vincenz> lambdabot: @where HAC is http://haskell.org/haskellwiki/HAC
23:18:42 <lambdabot> I know nothing about hac.
23:22:45 <dons> \where hac
23:22:45 <lambdabot> http://haskell.org/haskellwiki/HAC
23:57:13 <adu> does GHC use GMP?
23:58:02 <Korollary> yes iirc
