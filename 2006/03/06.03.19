00:12:11 <sethk> Korollary, I'm in seattle again
00:12:19 <Korollary> Hey there
00:12:45 <Korollary> I read somewhere that you had some haskell code in production
00:13:31 <sethk> yes, I'm deploying more this weekend, actually
00:14:06 <sethk> I finally bit the bullet and figured out how ffi works
00:14:20 <sethk> which is letting me use haskell for two more programs
00:15:04 <sethk> when I finally decided not to be afraid of it, I got some ffi stuff working within a couple of hours
00:15:41 <Korollary> what does it do?
00:16:47 <sethk> Korollary, basically the project involves taking hardware as it comes off an assembly line, checking that it works, loading on burn in software, gathering the results of the burn in tests, things like that.
00:17:36 <Korollary> How does haskell help?
00:17:56 <sethk> Korollary, just by being a better language.
00:18:13 <sethk> Korollary, I find that once I get the compiler to accept my code, it generally works
00:18:28 <sethk> Korollary, and it doesn't have the kind of hidden bugs that can pop up in c/c++ code
00:19:17 <Korollary> It probably needs to be more correct than fast I assume
00:20:03 <sethk> Korollary, generally, yes, but I've found ways of making it go at comparable speeds to the C code it replaces.
00:20:19 <sethk> Korollary, I thought I would use ffi for performance, but I have not had to
00:20:48 <sethk> Korollary, I modified device drivers to do things I need, and that's where I use ffi (to call the device driver from c)
00:21:02 <Korollary> what platform?
00:21:30 <sethk> Korollary, this particular piece of hardware uses intel x86 code
00:21:38 <Korollary> linux?
00:21:56 <sethk> Korollary, the servers run linux, and, yes, I created a modified linux to run on the hardware as well.
00:22:02 <Korollary> cool
00:22:24 <vincenz> re
01:02:52 <sethk> what's the opposite of lines?  to turn an array of strings into a string?
01:03:03 <sethk> not array, list
01:03:35 <sethk> concat?
01:09:46 <neologism> foldr (++) [] ?
01:26:41 <eivuokko> unlines
01:30:34 <nothingmuch> concat doesn't reinsert newlines between them
01:41:40 <ski__> > map (unlines . lines) ["","\n","a","a\nb\nc","a\nb\nc\n","\na"]
01:41:41 <lambdabot> ["","\n","a\n","a\nb\nc\n","a\nb\nc\n","\na\n"]
01:54:10 <sethk> eivuokko, thanks.  concat did what I needed, but you are correct, the reverse of lines is unlines.  concat is more general.
01:57:21 <ski__> > map ((==) . (unlines . lines &&& id)) ["","\n","a","a\nb\nc","a\nb\nc\n","\na"]
01:57:22 <lambdabot>  add an instance declaration for (Show ((String, String) -> Bool))
01:57:38 <ski__> > map ((==) . ((unlines . lines) &&& id)) ["","\n","a","a\nb\nc","a\nb\nc\n","\na"]
01:57:40 <lambdabot>  add an instance declaration for (Show ((String, String) -> Bool))
01:57:49 <sethk> why is lambdabot asking for the show?
01:58:01 <ski__> arg
01:58:07 <ski__> > map (uncurry (==) . (unlines . lines &&& id)) ["","\n","a","a\nb\nc","a\nb\nc\n","\na"]
01:58:09 <lambdabot> [True,True,False,False,True,False]
01:59:08 <ski__> sethk : '(==)' was passed a pair to compare, but wanted curried arguments
01:59:49 <sethk> ski_, ok, but I'm not clear about why it believes it needs Show.  Which statement did it interpret as requiring a show on an argument?
02:00:42 <Lemmih> MarcWeber: You got ghc-6.5 from cvs? ghc-6.5 is kept in a darcs repo.
02:04:10 <MarcWeber> Lemmih: I did.. it worked.. I even had Typeable.h.. ;-)
02:20:54 <Lemmih> MarcWeber: Why do you need ghc-6.5 and hs-plugins? Getting something to work by statically linking to the Haskell DB driver(s) would take a couple of minutes.
02:25:40 <MarcWeber> Lemmih: Because I don't know how hs-plugins work exactly...(yet).. ;)
02:26:13 <MarcWeber> I don't know how to statically link.. all I've done till now is runhaskell Setup {configure,build,install}..
02:26:59 <MarcWeber> There are static flags and so on.. but I don't konw wether dynConnect will use hsplugin code anyway.. (does this check wether a library is compiled in before loading a shared one??)
02:31:29 <Lemmih> MarcWeber: Are you using hsql or hdbc?
02:32:41 <Lemmih> You don't need hs-plugins at all and statically linking is done by '-package pkg'.
02:34:58 <ski__> sethk : everything was probably wrapped in a 'print'
02:35:06 <ski__> > sin
02:35:07 <lambdabot>  add an instance declaration for (Show (a -> a))
02:35:33 <ski__> > sin + 0
02:35:35 <lambdabot>  add an instance declaration for (Num (a -> a))
02:39:01 <Lemmih> MarcWeber: First install haskelldb, second install haskelldb-hsql-mysql. That should be it.
02:51:00 <vincenz> bleghj
02:51:07 <vincenz> implementing a RB-tree sucks
02:51:23 <vincenz> especially one that can be iterated over in an stl-style of iteration
02:54:54 <wilx> Hmm, I am still trying to understand tuples and TH.
02:56:25 <wilx> Whatfor is the TypleT case of data Type used?
02:56:48 <wilx> If I give my TH function 'x where x = (1,2,3) I get series of AppT.
03:35:34 <Cale> wilx: Could it be because (1,2,3) = (,,) 1 2 3 ?
03:43:59 <wilx> Yup, it look like it.
03:44:17 <wilx> But there is also TupleT and I haven't seen it yet during my experiments.
03:47:48 <musasabi> Do any of the data structure packages have discrete interval encoding trees?
03:48:20 <musasabi> I have found http://web.engr.oregonstate.edu/~erwig/diet/, but that lacks a licence.
03:57:06 <kosmikus> just ask him about the license if it suits your needs
04:08:19 <dons> sethk, it's inferring a (String, String) -> Bool), i.e. a function, and there is no (standard) Show instance for functions
04:08:28 <dons> oop again. /me should scroll down
05:00:17 <davidhouse> @index (|||)
05:00:18 <lambdabot> Control.Arrow
05:02:50 <dons> now, a prize if you can use it in an > one liner to do something fun :)
05:03:10 * dons thinks we should have more Arrow results from @pl
05:10:02 <ihope> @pl arr id
05:10:03 <lambdabot> arr id
05:10:50 <davidhouse> @type arr
05:10:51 <lambdabot> Not in scope: `arr'
05:10:57 <davidhouse> oh, that's return for arrows, right?
05:11:19 <ski__> @type Control.Arrow.returnA
05:11:21 <lambdabot> forall b (a :: * -> * -> *).
05:11:21 <lambdabot>          (Control.Arrow.Arrow a) =>
05:11:21 <lambdabot>          a b b
05:11:34 <ski__> @type Control.Arrow.arr
05:11:35 <lambdabot> forall (a :: * -> * -> *) c b.
05:11:35 <lambdabot>        (Control.Arrow.Arrow a) =>
05:11:35 <lambdabot>        (b -> c) -> a b c
05:11:37 <Saulzar> It lifts a normal function to an arrow
05:11:53 <davidhouse> like return lifts a normal value to a monadic one
05:18:13 <dons> \p \f (a,b) -> (f a, f b)
05:18:13 <lambdabot> Maybe you meant: part paste pl pl-resume pointless poll-add poll-close
05:18:13 <lambdabot> poll-list poll-remove poll-result poll-show pretty .
05:18:22 <dons> \pl \f (a,b) -> (f a, f b)
05:18:23 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
05:18:27 <dons> ba
05:20:55 <ihope> Whoa.
05:21:03 <ihope> Indeed, no (->) arrow.
05:21:07 <ihope> @index &&&
05:21:07 <lambdabot> Control.Arrow
05:21:22 <ihope> @type Control.Arrow.&&&
05:21:23 <lambdabot> parse error on input `Control.Arrow.&&&'
05:21:25 <Saulzar> ihope, ?
05:21:28 <ihope> @type (Control.Arrow.&&&)
05:21:29 <lambdabot> forall (a :: * -> * -> *) c' c b.
05:21:29 <lambdabot>         (Control.Arrow.Arrow a) =>
05:21:29 <lambdabot>         a b c -> a b c' -> a b (c, c')
05:21:55 <ihope> Saulzar: I'm looking for the function that dons had...
05:22:14 <wilx> Let's say I want to generate lambda expression using TH and it should have one parameter that does not colide with user parameters. How can I generate some unique name for the parameter?
05:22:38 <ihope> Many Random Letters and Numbers. :-P
05:22:49 <Lemmih> wilx: Language.Haskell.TH.newName?
05:23:11 <ihope> Ah, I see.
05:23:27 <Lemmih> wilx: You can also just use spaces in the name (:
05:23:29 <wilx> What is the String it gets as paramter?
05:23:40 <xerox> Hola.
05:24:06 <Lemmih> wilx: newName "arg" => "arg"++show unique.
05:24:23 <wilx> Ah, thanks.
05:25:24 <dons> doesn''t work like that ihope ;)
05:25:55 <xerox> > (join (***)) (+1) (1,2)
05:25:56 <lambdabot> (2,3)
05:25:58 <xerox> (don's function)
05:26:01 <ihope> Aha.
05:26:16 <dons> yeah, I was looking for it to produce ***
05:26:19 <ihope> @type (Control.Arrow.***)
05:26:20 <lambdabot> forall (a :: * -> * -> *) c' c b' b.
05:26:20 <lambdabot>         (Control.Arrow.Arrow a) =>
05:26:20 <lambdabot>         a b c -> a b' c' -> a (b, b') (c, c')
05:26:41 <ihope> Aha.
05:26:48 <ihope> Hmm...
05:27:23 <ihope> @pl \f g (x,y) -> (f x, g y) -- is this what it does?
05:27:24 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
05:27:36 <xerox> Yes it is, in (->) monad.
05:27:45 <ihope> (->) arrow, you mean.
05:27:56 <xerox> Wops.
05:28:09 * xerox stretches and yawnes a little more.
05:29:06 <dons> all the more reason the  (->) a _monad_ should be in Monad.hs, since the -> a Arrow is in Arrow.hs
05:29:35 <dons> the (->) Arrow, i mean.
05:29:53 <dons> also known as the arrow Arrow
05:30:55 <xerox> Arrow Arrow Arrow (a'la Steve Ballmer.)
05:31:09 <dons> hehe
05:40:12 <ihope> I want a shirt with "developers" written all over it.
05:57:17 <Cale> Control.Monad should be reexported by the prelude :)
05:57:58 <Cale> (actually, that would be nice, as I seem to always end up importing it anyway)
05:58:23 <Saulzar> Hmm, there are a few like that
05:58:40 <Saulzar> I think Data.List, Data.Maybe and Control.Monad definately the most common
05:58:46 <xerox> Control.Arrow to, to some degree.
05:58:51 <xerox> s/to/too/1
06:01:43 <wilx> @paste
06:01:43 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
06:03:52 <Saulzar> Of 71 files in current project - 19 have Control.Monad, 18 Data.List, 17 Data.Maybe ..
06:05:29 <wilx> My TH hackery makes GHC cry.
06:08:33 <Saulzar> 562 lines of import :)
06:12:35 <jips> \seen dons 
06:12:36 <lambdabot> dons is in #haskell. Last spoke 41 minutes and 25 seconds ago.
06:33:23 <dons> yo
06:35:04 <dons> I have a theory that arrows are used more often as a tuple api, than as generalised monads
06:39:58 <ski__> (dons : s/tuple/pair/ ?)
06:40:22 * ski__ ponders arrow tranformers
06:40:35 <Saulzar> In non arrow code that would have to be the case :)
06:41:56 <ski__> is there some nice general theory for arrow transformers ?
06:42:22 <ski__> (in terms of CT, i.e.)
06:43:44 <ski__> a morphism 'a --> b' in a kleisli-category over monad m, corresponds to a morphism 'a --> m b' in the underlying category
06:44:39 <ski__> to get composition in the kleisli-category, we use monadic extension
06:45:06 <ski__> to get identity, we use the "return" morphism
06:45:58 <ski__> (/me wonders if he should show this explicitely)
06:47:37 <dons> pairs, yep.
06:47:42 <dons> two-ples :)
06:48:46 <ski__> (and we can get cokleisli-categories of comonads, in a dual way)
06:48:50 <xerox> dons: I believe in that theory too.
06:49:05 <ski__> but, some cases doesn't fit so well into this pattern
06:49:15 <ski__> more specifically, e.g. state
06:51:26 <ski__> if we say 'a --> b' corresponds, 'underneath' to 'a --> (s -> s * b)', then if we take this category to be e.g. yet another kleisli-category (e.g. of io) we get 'a --> io (s -> s * b)'
06:51:58 <ski__> but we probably want something more like 'a --> (s -> io (s * b))'
06:52:51 <ski__> (in case anyone wonders, i'm sortof thinking load ..)
06:53:10 <ski__> (s/load/loud/)
06:54:01 <ski__> so, instead we want 'a --> b' to correspond to 's * a --> s * b', in the underlying category
06:55:00 <jips> \seen dons
06:55:01 <lambdabot> dons is in #haskell. Last spoke 7 minutes and 18 seconds ago.
06:55:03 <ski__> and if we "walk one step down" by interpreting this category as a kleisli-category over 'io', we then get 's * a --> io (s * b)', which is better
06:55:29 <dons> there's a prize for the fastest haskell program that prints the last line of /usr/share/dict/words
06:55:49 <jips> hello dons 
06:55:55 <dons> hey jips. how's code?
06:56:03 <jips> ok. do you know who i am?
06:56:13 <dons> boo on you
06:56:15 <dons> ;)
06:57:36 <ski__> so, this (to me) suggests that we try saying a morphism in the "higher" category 'a --> b', should correspond to 'f a --> g b' in the "lower" category, where 'f' and 'g' are two endo-functors over the lower category
06:57:55 <jips> dons: i imagine that readFile closes the file when, and only when, it reads to EOF. during rawMerge, if there is some sort of parsing failure of the plugin file then no more reading of the file is done and therefore the file is never closed
06:58:05 <jips> dons: do you think this sounds reasonable?
06:58:11 <dons> yep. I reckon that is very reasonable
06:58:45 <dons> so we should have a handle/catch on the read, to ensure it is closed in the event of an exception
06:58:59 <ihope_> What's this --> stuff?
06:59:03 <ski__> (of course, i think we need some extra structure for 'f' and 'g' to guarrantee that the "higher" category is indeed a category (identity and composition + identity laws and associativity of composition))
06:59:10 <dons> do you know 'bracket', jips/
06:59:11 <ski__> ihope_ : asking me ?
06:59:13 <dons> ?
06:59:23 <jips> dons: dons yes, but i don't think that it is required even
06:59:28 <ihope_> ski__: I suppose.
06:59:33 <dons> ah, ok. proceed then, jips :)
06:59:50 <jips> dons: i can think of 3 solutions
07:00:08 <ski__> ihope_ : '-->' is some arrow, think of 'ar' in e.g. 'arr :: Arrow ar => (a -> b) -> ar a b'
07:00:22 <ihope_> Okay.
07:00:26 <jips> first though let me explain that i think that bracket is not needed since it's very clear when the file must be closed
07:00:34 <jips> anyway, the 3 solutions are:
07:00:58 <jips> 1) force readFile to close the file after a parse error by forcefully reading until EOF
07:01:16 <ihope_> Time to write an obfuscated thread-based factorial function...
07:01:17 <jips> 2) don't use readFile, use hGetContents and then close the file properly after a merge failure
07:01:24 <ski__> (ihope_ : or, even '~>' in e.g. 'arr :: Arrow (~>) => (a -> b) -> (a ~> b)' .. i think there was some syntax extension like this)
07:01:44 <jips> 3) use the well known strict readFile' function, which some people apparently recommened to always use instead of readFile anyway
07:01:53 <ihope_> ski__: I understand that ~> looks weird in many monospace fonts, right?
07:02:10 <ski__> ihope_ : depends
07:02:38 <dons> ah, there's a well known readFile'?
07:02:48 <dons> anyway, yes, 3) sounds good
07:02:57 <jonkri> i need to compile code that i've gotten from my teacher. this is the error message i get: "unknown flags in  {-# OPTIONS #-} pragma: _GHC". The Glorious Glasgow Haskell Compilation System, version 6.2.2, Gentoo 2006.0
07:03:04 <dons> just force eval after a readFile with 'length `seq` ...'
07:03:06 <ski__> ihope_ : what i was trying to think about was monadic transformers, and in extension arrow transformers (since it seemed the latter behaved better, in some sense)
07:03:30 <ihope_> Arrow transformers? They sound evil..
07:03:40 <dons> jonri, your ghc is older than the OPTIONS_GHC pragma
07:03:45 <ski__> (ihope_ : of course, if there's any result of this reasoning, it would have to be "translated down" from CT to haskell, again :)
07:03:47 <dons> so remove the bit that says '_GHC'
07:04:03 <ski__> ihope_ : not very much more than monad transformers
07:04:15 <ski__> (in fact, they may be somewhat nicer)
07:04:27 <monadic_kid> hiya all
07:04:32 <ski__> hiya monadic_kid
07:04:39 * monadic_kid is snk_kid
07:04:42 <monadic_kid> :)
07:04:43 <ihope_> Every time you say the word "ihope_", my client window flashes and the brown.freenode.net tab turns red...
07:04:55 <ski__> oh
07:05:15 <monadic_kid> i keep having problems trying to build hsSDL on windows :(
07:05:37 <ihope_> I'm not sure what happens if you /notice me.
07:05:48 <ski__> (ihope : why the server tab ?)
07:05:52 <dons> jips, so , number 3)?
07:05:58 <monadic_kid> anyne used hsSDL before?
07:05:58 <jonkri> dons: thanks
07:06:02 <ihope_> ski__: for message of the day and stuff.
07:06:12 <dons> or, do whatever, you wish, and send me the patch, jips :)
07:06:14 <jips> dons: i think that 3) is the best
07:06:19 <jips> dons: http://users.aber.ac.uk/afc/stricthaskell.html#semiclosed
07:07:08 <dons> can you darcs send me the readFile' patch, once you've tested it works?
07:07:10 <ihope_> Despite their name, notices seem to be the least noticable private messages on my client.
07:07:24 <dons> I think it's easier than needing readFile' (a seq would do). but do what you wish.
07:07:43 <ski__> ihope : did i succeed in using '/notice' ?
07:07:47 <ihope_> Yep.
07:08:07 <ihope_> It looks like /msg opens up a new tab, but /notice doesn't.
07:08:25 <ihope_> That'd be why I don't get NickServ tabs.
07:08:35 <monadic_kid> every time i try  to make abuild of hsSDL i get undefined reference to __stginit_ZCMain and ZCMain_main_closure
07:09:19 <monadic_kid> this is on windows, with cygwin (since it needs sh)
07:09:27 <jips> dons: readFile' would be much more efficient. it's just a simple 20 line function that can be pasted at the end of Make.hs. although maybe i should check to see if there is some licensing issue
07:10:09 <dons> well, I'm pretty sure: 
07:10:09 <dons> readFile' = do s <- readFile
07:10:11 <dons>                length s `seq` return s
07:10:16 <dons> is ok too.
07:10:20 <dons> you could try either.
07:11:11 <dons> a more advanced version (not suitable for a library) might be:
07:11:13 <dons> forkIO (Control.Exception.evaluate (length output) >> return ())
07:11:13 <jips> yeah that would also work but the real readFile' is much more efficient
07:11:33 <ski__> (ihope : for some reason, operator messages (from lilo) usually show up in my #scheme .. and /whois and /whowas in server tab, but /wii in current tab (this in x-chat))
07:11:50 <dons> jips, which one? I see several.
07:12:10 <dons> you want  the malloc'd one?
07:12:12 <Cale> dons: the last one by Simon Marlow is good
07:12:37 <dons> jips, since hardly anyone uses the merge stuff. then it's your call
07:12:50 <jips> dons: http://users.aber.ac.uk/afc/stricthaskell.html#readfilehs
07:13:07 <ski__> (ihope,.. : i guess i'll not continue my line of thought here right now, though, since the channel came to life)
07:13:23 <dons> o, jips, go for it if you want.
07:13:48 <jips> Cale: do you happen to know if the Simon Marlow readFile' code can be used freely?
07:13:54 <ihope_> My factorial function uses GADTs.
07:14:25 <dons> jips, it can.
07:14:43 <dons> i'll bug simon personally if he ever says otherwise :)
07:15:00 <dons> i have other simon M code in hs-plugins already, most likely
07:15:09 <Cale> jips: I'm pretty sure. If there was any doubt, it's easy enough to ask him :)
07:15:29 <ski__> ihope : can we see ? :)
07:16:07 <dons> \remember ihope My factorial function uses GADTs.
07:16:08 <lambdabot> Done.
07:16:19 <dons> that's going to be in the HWN this week!
07:16:24 <ihope_> data ConditionalEvent where ConditionalEvent :: Bool -> a -> a -> MVar a -> ConditionalEvent
07:16:48 <ihope_> A boolean, the THEN value, the ELSE value, and an MVar to put the result in.
07:17:00 <dons> is it a type level factorial?
07:17:07 <ihope_> Nope.
07:17:25 <dons> :( that's no fun
07:17:41 <ihope_> There's an MVar ConditionalEven which is used to invoke the conditional thread.
07:17:53 <dons> oh, and it's threaded!
07:17:57 <dons> wow
07:17:57 <ihope_> Yep!
07:18:03 <monadic_kid> so no ideas about hsSDL then?
07:18:06 <ski__> ihope_ : you only write to the 'MVar' inside the 'ConditionalEvent', yes ?
07:18:16 <ihope_> ski__: something like that
07:18:24 <dons> I think you should write a wiki artcile: The Most Complicated Factorial Function
07:18:29 <ihope_> :-)
07:18:32 <dons> even better would be fibonacci
07:18:39 <dons> use STMm in there somewhere
07:18:45 <ihope_> What's that?
07:18:47 <ski__> ihope : when can we see the rest of the code ?
07:18:55 <dons> and some linear implicit parameters
07:18:56 <ihope_> As soon as I finish writing it :-P
07:19:06 <ski__> dons : those are unsafe !
07:19:09 <dons> ski__, sounds top-secret NSA type stuff to me..
07:19:22 * ski__ does not grin
07:19:38 <jips> monadic_kid: what's that?
07:19:42 <Cale> http://www.willamette.edu/~fruehr/haskell/evolution.html
07:19:48 <dons> and, mm, what else, an ffi call or two..
07:20:00 <dons> it should use a peano representation somewhere
07:20:02 <monadic_kid> ihope_: software transactional memory
07:20:10 <ihope_> Yow!
07:20:24 <monadic_kid> ihope_: http://research.microsoft.com/~tharris/papers/2006-flops.pdf
07:20:31 <ihope_> You mean using GADTs, threads and unsafePerformIO isn't enough?
07:20:42 <dons> no! not by far
07:20:49 <dons> those are the easy, everyda extensions
07:21:03 <dons> I want, hardcore, stuff likely-to-be-removed from the language extensions...
07:21:11 <dons> :D
07:21:36 <dons> if its really good, it could win a obfuscated haskell prize..
07:22:22 <monadic_kid> jips: hsSDL is SDL binding for haskell, i can never make a build of it for windows and it's really annoying :)
07:22:25 <ski__> ihope_ : is the 'unsafePerformIO' safe, there ?
07:22:39 <dons> oh, and there's noo unsafeCoere#
07:22:39 * ski__ assumes it could be for a global
07:22:49 <ihope_> Well, it doesn't really do much.
07:22:57 <ski__> (s/Coere/Coerce/)
07:23:01 <dons> unsafePerformIO is the wussy way to break the type system. just coerce!
07:23:16 <ihope_> It just starts some threads, tosses some MVars all over, and kills them.
07:23:21 <dons> unless it's a hairs-width from a segfault, it's not fun :)
07:24:28 <dons> oh, this is really nice. the syntax highlighting on the wiki links to the prelude entries for those functions
07:24:37 <dons> e.g. http://www.haskell.org/haskellwiki/Performance/Strings
07:25:23 <ihope_> successorThread mVar = do (SuccessorEvent source destination) <- takeMVar mVar; putMVar destination (Succ source); yield; successorThread mVar
07:26:36 <dons> \localtime dons
07:26:40 <lambdabot> Local time for dons is Mon Mar 20 02:26:52 2006
07:26:43 <dons> nytol!
07:26:47 <ihope_> Can't you /time yourself?
07:26:58 <dons> jips, i expect that patch in the morning... ;)
07:27:55 <jips> dons: when is the morning?
07:28:06 <ski__> ihope_ : try '/ctcp ihope_ time'
07:28:28 <ihope_> ski__: how would I do a time response that way?
07:28:45 <ski__> ihope : what do you mean ?
07:28:46 <jonkri> i got another problem with my teachers code. "import {-# SOURCE #-} LifeClient.GUI.State" gives me "./LifeClient/GUI/State.hi-boot: openBinaryFile: does not exist (No such file or directory)"
07:28:54 <jonkri> can this also be because i have an old ghc?
07:29:10 <dons> yes. do you have .hs-boot files?
07:29:16 <dons> (this is using recursive modules)
07:29:29 <dons> if so, you really need ghc 6.4.x
07:29:40 <jonkri> i ahve the file "./LifeClient/GUI/State.hs-boot"
07:29:43 <ihope_> I think I'll need even more unsafePerformIO and inlining for this one.
07:29:53 <dons> ok. you need ghc 6.4.1, jonkri
07:29:58 <jonkri> fsck
07:30:05 <jonkri> thanks
07:30:17 <dons> your teacher should have said this. (who is it, i wonder if they lurk here...)
07:31:00 <jonkri> hmm, 6.4.1 is in gentoo's ~x86
07:31:10 <dons> sounds good.
07:31:14 <jonkri> phew
07:31:19 <jonkri> i wouldn't want to have compiled that myself
07:31:27 <jonkri> i guess he assumes we're doing this in school
07:31:27 <dons> dcoutts maintains it. you can bug him personally if it doesn't work..
07:31:32 <jonkri> :)
07:31:34 <dons> ah, maybe
07:31:44 <ihope_> Nah, I don't like unsafePerformIO right now.
07:31:50 <dons> but , still, whose the teacher? not many people use .hs-boot files, I think.
07:31:57 <jonkri> ok
07:32:00 <dons> maybe we know them..
07:32:02 <jonkri> "Nils Anders Danielsson"
07:32:05 <jonkri> "nad"
07:32:51 <dons> ok, well maybe we don't know this guy :}
07:32:57 <jonkri> hehe
07:33:15 <jonkri> you definately know the guy in the room next to his, anyway
07:33:25 <jonkri> in chalmers
07:33:28 <dons> hmm, ah!
07:33:33 <jonkri> :)
07:33:39 <jonkri> "john hughes"
07:33:44 <jonkri> i take it that rings a bell? ;)
07:34:02 <dons> yes, I think several people here have met him.
07:34:09 <jonkri> ok
07:34:09 <jonkri> what's a .hs-boot file anyway?
07:34:12 <dons> nibro would have  :)
07:34:23 <dons> it's a loop-breaker when using recursive module imports
07:34:30 <jonkri> oh, ok
07:34:42 <dons> so when A imports b, and B imports A, you break the loop with A.hs-boot
07:34:51 <jonkri> i see
07:34:59 <huga> hey jonkri, i think i'm taking the same course as you are.. last day to hand in the stuff today right?
07:35:00 <dons> which provides just enough code tie the knot
07:35:10 <jonkri> huga: :-)
07:35:26 <dons> last day to get help on #haskell then :)
07:35:34 <jonkri> huga: yeah, i have to do the last stuff in the game of life thingy
07:35:53 <jonkri> huga: "martin dahl"...
07:35:58 <jonkri> dons: :)
07:36:04 <dons> that's interesting you're doing the game of life. we also use that at unsw in sydney.
07:36:15 <jonkri> dons: i really try not to ask questions regarding the labs
07:36:20 <dons> i wonder if it's a coincidence.
07:36:25 <dons> jonkri, just joking :)
07:36:29 <jonkri> dons: but sometimes i need to know if a feature existws or so, and then it's handy :)
07:36:47 <jonkri> dons: yeah
07:36:53 <huga> jonkri: yeah. i have both lab 3 & 4 to do today.. better get started soon :S
07:37:34 <jonkri> huga: indeed
07:37:45 <jonkri> huga: good luck
07:37:50 <huga> thanks
07:38:35 <jonkri> no, don't tell me i broke this now. i had wxhaskell working, but now when i try to compile with "ghc -package wx" i get "ghc-6.4.1: unknown package:wx"
07:38:56 <dons> you need to reinstall it with ghc 6.4.1
07:39:04 <jonkri> noooooooooooo
07:39:06 <jonkri> that will take all day
07:39:08 <dons> it needs to be rebuilt for each compiler version :(
07:39:20 <dons> jonkri, ok, what's in the .hi-boot file?
07:39:25 <ihope_> Hmm, this could be tricky.
07:39:55 <dons> we can maybe convert it from .hs-boot to .hi-boot and save you some time.
07:39:58 <ihope_> Maybe instead of MVars, I'll take a function that takes a value and performs an action...
07:40:19 <ihope_> Or I could use *more* MVars and threads.
07:40:36 <jonkri> donghee: thank you, that's very kind, but fortunately i have other things to do i can do while it's compiling :)
07:40:38 <dons> ihope_, can you use 1 thread for  every value in the list?//
07:40:50 <dons> jonkri, ok :)
07:41:11 <ihope_> dons: I'm not using lists
07:41:41 <ihope_> I'm pretty much writing this program in an excessively message-passing-heavy format.
07:41:58 <dons> and you're not using arrows yet? shame!
07:42:01 <dons> :p
07:42:34 <ski__> ihope_ : you could make write-only wrapper of 'MVar'
07:42:40 * ihope_ cries
07:44:16 <ski__> i wonder if a read-only wrapper around a ref would make a true 'Functor'
07:44:41 <ski__> (and write-only wrapper make contravariant functor, then, ofc course)
07:51:23 * kosmikus knows NAD ...
08:02:40 <ihope_> Am I seeing things, or does my #esoteric tab really turn green even when nobody says anything there?
08:03:47 <basti_> that depends on your client. green might be the color for system messages (join/part etc) without actual talk
08:03:47 <norpan> i don't want to know what your #esoteric tab is and if it turns green you should see a doctor
08:10:15 <ihope_> Blue is the color for system messages.
08:10:31 <ihope_> There is *nothing* in the #esoteric tab when it supposedly turns green.
08:11:34 <ndm> ihope_: what is your IRC client?
08:11:38 <ihope_> ChatZilla
08:11:52 <ndm> mine too, i've just joined esoteric, so i'll see if i see it too
08:12:23 <ihope_> There, it just went green again.
08:12:26 <ihope_> Did you say anything?
08:12:28 <ndm> it just went green, and somone spoke
08:12:32 <ndm> SimonRC did
08:12:48 <ihope_> Oh, I was scrolled up some, and didn't see the chat :-P
08:12:56 <ski__> :)
08:13:07 <SimonRC> heh
08:13:10 * SimonRC is here too
08:19:47 <ihope_> Okay, I had arranged some song into letter thingies.
08:20:09 <ihope_> abacabadABACabac
08:21:35 <ihope_> .   .   !   .   >   >   
08:21:47 <ihope_> I imagine that makes little sense.
08:21:59 * ndm is using monads :)
08:22:09 <basti_> ihope_: lol
08:22:19 <basti_> lol re channel turning green
08:22:26 <basti_> and then, this doesnt make a lot of sense, no
08:35:49 <Laney> I need a quick hand on a function I'm trying to write. It's supposed to be equivalent to "map" but for a "Tree" algebraic type I've defined. Code and error message is here: http://pastebin.com/610811
08:36:36 <Laney> If anyone can see what I've done wrong, please let me know!
08:36:40 <ndm> Laney, your second line is wrong
08:36:42 <ndm> mapTree _ (Node x y) = (Node x y)
08:36:44 <ndm> should be
08:36:50 <ndm> mapTree f (Node x y) = (Node (f x) (f y))
08:36:51 <ihope_> mapTree f (Node x y) = Node (mapTree f x) (mapTree f y)
08:37:04 <ndm> (woops, indeed, ihope_ is right)
08:37:04 <Laney> Oh god, yes
08:37:25 <Laney> I didn't even think to look there because the error was on the base case line
08:37:33 <Laney> Now I feel stupid :(
08:38:19 <Laney> That worked, thanks chaps
08:38:41 <Laney> Main> mapTree (*2) tree1
08:38:41 <Laney> Node (Leaf 8) (Node (Leaf 4) (Leaf 2))
08:39:29 <leshaste> would some kind soul let me know what you think the time complexity for this implemention of Binary Search is http://pastebin.com/610824 ?
08:40:22 <ihope_> Be careful of the mental parts when dissemble the yo yo.
08:40:26 <ndm> leshaste: log n * n
08:40:41 <ndm> since !! is very slow on lists
08:41:04 <ndm> you'd be much faster just scanning the whole list in this case
08:41:09 <ndm> or use an array
08:41:16 <ndm> or use Data.Set/Data.Map
08:41:33 <leshaste> ndm: yes.. I feared as much. Thx very much!
08:41:55 <leshaste> ndm: although arrays are catastrophically slow in haskell aren't they?
08:42:06 <Lemmih> Not really.
08:42:07 <ndm> leshaste: they are read only
08:42:16 <ndm> in general, without doing wacky monad stuff
08:42:32 <leshaste> ok.. I read a paper by Peyton Jones saying they were about 300 times slower than in C
08:42:47 <leshaste> maybe some implementations are better than others
08:42:50 <ndm> leshaste: from when>?
08:42:53 <leshaste> 2003
08:42:58 <ndm> thats years ago!
08:43:04 <leshaste> 3 :)
08:43:14 <ndm> there are now unboxed arrays etc., which are close to C performance
08:43:20 <ihope_> A. Polluted skin: 1. Wash skin for 15 minute with a lot of water. 2. Take off the polluted coat & shoes, do not put them on unless they are cleaned. 3. Go to hospital away.
08:43:21 <leshaste> have array implementations improved 100 fold in 3 years :)
08:43:36 <ndm> leshaste: wouldn't surprise me
08:43:38 <leshaste> ndm: ah right.. very interesting.. I need to learn about this stuff properly
08:44:09 <leshaste> I like people in #haskell... your average IQ must be twice those in #C :)
08:44:41 <ihope_> There's nobody in #C.
08:44:53 <ihope_> They're all in ##undefined-behavior.
08:45:04 <ihope_> And only two of them can talk.
08:45:41 * leshaste smiles at obscure language joke but is not sure he fully got the last bit
08:45:50 <Saulzar> Seems it's ##C, What's the deal with ## channels?
08:46:07 <leshaste> they are meant to be "about channels" but that doesn't mean anything to me either
08:46:27 <leshaste> did unboxed arrays make it into any haskell standard?
08:46:33 <leshaste> seems it is not in haskell '98
08:46:45 <ndm> no, they are non-standard
08:46:50 <ndm> but reasonably well supported, i think
08:47:06 <leshaste> cool
08:47:11 <ihope_> The ## channels are "unofficial".
08:47:11 <leshaste> I only use ghc anyway :)
08:47:38 <ndm> although if you just use Data.Map and Data.Set, it will probably give you the performance you need, 100% portability and lots of other good stuff
08:47:51 <leshaste> ndm: right way to do binary search in haskell is presumably with a binary search tree right?
08:48:04 <ndm> leshaste: thats what Data.Map does
08:48:12 <leshaste> ndm: ok.. I need to do everything by hand ;)
08:48:19 <ndm> but yes, a binary search tree - either red black or AVL is probably best
08:48:23 <ndm> assignment time?
08:48:41 <ndm> but standard binary tree is probably enough
08:49:43 <leshaste> ndm: I hate to admit it but I have teach this stuff :)
08:49:53 <ihope_> I really should work on that bot some.
08:49:55 <ndm> ah, fair enough
08:50:04 <leshaste> ndm: my expertise stopped in 1995
08:50:13 <ndm> binary tree is probably the simplest and best way to go
08:50:14 <leshaste> anything after that is black magic to me :)
08:50:19 <ihope_> Oh, right, ncurses.
08:50:41 <leshaste> ndm: right. I know the algorithms so any technique from pre 95 is safe in my hands :)
08:51:38 <leshaste> (in fact I only ever used Orwell which was a clone of Miranda)
08:52:52 <ndm> are you teaching on windows or linux?
08:52:59 <leshaste> linux
08:53:16 <leshaste> if they want to sneak off and do it windows without telling me that is their own guilty secret
08:53:22 <leshaste> but it will be tested in linux
08:53:37 <leshaste> it isn't a haskell course
08:53:42 <leshaste> haskell is just for some examples
08:53:55 <leshaste> but I do want to make sure the examples have the right time complexity :)
08:54:53 <ndm> fair enough
09:10:02 <MarcWeber> On gentoo: How is the compiler specified which should be used to compile libraries? the ebuilds are using the wrong one.
09:11:37 <leshaste> MarcWeber: which ebuild is wrong?
09:12:16 <leshaste> MarcWeber: in any case... you would normally have to edit the ebuild.. try #gentoo or #gentoo-dev-help
09:16:04 <MarcWeber> leshaste: I don't think it's "wrong".. It's using the ghc compiler I did install with gentoo. But I've also installed one from cvs (manually) I want the ebuild to use that.
09:16:50 <leshaste> MarcWeber: and there is no sign in the ebuild of how to specify it?
09:16:50 <MarcWeber> Lemmih: I got it working with static building... Now DBDirect only works with MySQL but I don't mind...
09:21:21 <MarcWeber> leshaste: I couldn't find one... I'll try downloading it and building it manually.. I don't want to figure it out now
09:22:31 <leshaste> MarcWeber: sounds like a good idea.. or ask the person who made the ebuild.. that will be in the Changelog in portage
09:33:50 * palomer wonders if yi has tabs
09:52:40 <twobitsprite> flip Map.lookup . gChains
09:53:13 <twobitsprite>     Ambiguous type variable `m' in the constraint:
09:53:14 <twobitsprite>       `Monad m' arising from use of `Data.Map.lookup' at goban.hs:48:15-24
09:53:22 <twobitsprite> what does that mean?
09:53:39 <twobitsprite> it works when I have it in "pointfull" style..
09:53:46 <basti_> that you didn't specify "m". which you accidentally introduced, apparently.
09:54:07 <ihope_> @pl foo 1 = 2; foo x = 3
09:54:08 <lambdabot> (line 1, column 10):
09:54:08 <lambdabot> unexpected ";"
09:54:08 <lambdabot> expecting digit, variable, "(", operator or end of input
09:54:23 <twobitsprite> how would I specify m?
09:54:49 <basti_> twobitsprite: i think you don't want m at all. what is gChains?
09:55:05 <twobitsprite> basti_: it's a record accessor
09:55:12 <basti_> what's it's type?
09:55:24 <twobitsprite> gChains :: (Map Int Chain)
09:55:25 <ihope_> @pl ack m n = if m = 0 then n+1 else if n = 0 then ack (m-1) 1 else ack (m-1) (ack m (n-1))
09:55:25 <lambdabot> (line 1, column 9):
09:55:25 <lambdabot> unexpected "="
09:55:25 <lambdabot> expecting variable, "(", operator or end of input
09:55:44 <basti_> twobitsprite: then i don't understand why m.
09:56:01 <twobitsprite> Map.lookup returns a Maybe...
09:56:10 <basti_> oh
09:56:13 <twobitsprite> I think it has something to do with that
09:56:18 <jyp> nah, it returns a monad
09:56:27 <basti_> @type Map.lookup
09:56:28 <jyp> you'll want to constrain it to maybe
09:56:28 <lambdabot> Couldn't find qualified module.
09:56:28 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
09:56:28 <lambdabot> \\)?
09:56:33 <basti_> @type Data.Map.lookup
09:56:34 <lambdabot> forall a (m :: * -> *) k.
09:56:34 <lambdabot>        (Ord k, Monad m) =>
09:56:34 <lambdabot>        k -> Data.Map.Map k a -> m a
09:56:38 <basti_> ahh
09:57:26 <twobitsprite> I'm not sure how to handle that
09:57:44 <basti_> probably with a ":: Maybe a" in the right spot, then
09:59:02 <ihope_> "forall a b. (Num a, Num b) => a -> b -> b" should NOT take up 13 lines!
10:01:12 <ihope_> Especially if 6 of those lines are blank...
10:03:41 <ihope_> Silly me. I only need ONE MVar for this factorial.
10:04:14 <Saulzar> You're making it hard to achieve a deadlock :)
10:04:45 <ihope_> Deadlocks are fun!
10:06:27 <ihope_> Oh, sheesh. I should be using SampleVars.
10:06:38 <ihope_> That is, one SampleVar.
10:11:41 <leshaste> is there a technical term for the system only evaluating the same expression once? 
10:11:58 <jyp> memoization ?
10:12:06 <edwinb> you mean as in Call By Need?
10:12:32 <leshaste> i.e. h a b = a + a     then h(9-3) ( h 43 3) only evaluates 9-3 once
10:13:12 <leshaste> or is that just an implemention feature with no particular name
10:13:14 <edwinb> that'd be call by need.
10:13:20 <leshaste> oh ok.. thx.. 
10:13:20 <edwinb> call by need is call by name with memoisation
10:14:22 <leshaste> ok... and that would apply to even 9-3 here?
10:15:23 <edwinb> yes, if an argument is evaluated, call by need would store its value
10:15:39 <MarcWeber> database.DBStore :: DBInfo -- << invalid type signature. This line is generated by DBDirect. Is there an option for ghc to allow this?
10:15:56 <edwinb> whereas call by name wouldn't
10:15:56 <leshaste> edwinb: thx very much. I only get top class replies here!
10:16:10 <leshaste> I have been on irc for ever and that has never happened before :)
10:16:14 <edwinb> hehe
10:16:26 <edwinb> I'd still always go away and verify what people say ;)
10:16:42 <leshaste> the only problem for you is.. It makes me want to ask more questions ;)
10:20:37 <MarcWeber> removing database. and lowercasing the first D did it.
10:23:15 <leshaste> just learnt how to do the sieve of Eratosthenes in Haskell using infinite data structures...
10:23:29 <leshaste> the trick to get it to understand the primes are in order is very nice :)
10:23:45 <leshaste> my love for haskell is returning after all these years :)
10:23:56 <basti_> years?
10:24:08 <leshaste> basti_: I learnt Miranda up until 1995
10:24:15 <leshaste> now am learning haskell
10:24:19 <basti_> how cool.
10:24:28 <basti_> a real old dog ^^
10:24:37 <leshaste> yep :) with some new tricks
10:25:00 <leshaste> of course I would love to claim I learnt Miranda when I was 3 :)
10:27:00 <MarcWeber> leshaste: ;)
10:27:45 <mwc> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Aunion probably not the best example code :P
10:28:43 <mwc> I thought dogcow was apple's TM from the early 90s
10:30:30 <gzl> the dogcow is much older than that
10:30:32 <gzl> from the early 80s
10:30:44 <gzl> http://en.wikipedia.org/wiki/Dogcow
10:31:02 <mwc> Yeah, it says apple has TM on dogcow on that page
10:49:20 <jonkri> when i get error messages like this "life-client: Prelude.(!!): index too large", how can i know which line it happens on?
10:51:16 <neologism> jonkri: if you have time.. you can try HAT (haskell debugger)
10:51:20 <neologism> if not use trace
10:56:22 <basti_> whats an axiomatic representation of a hash table? "put k v >>= get k === return v" and ("put k v >>= x >>= get k === return v" or "put k v >>= x >>= get k === x >>= get k)?
10:57:15 <basti_> not to forget k1 != k2 -> "put k1 v1 >>= put k2 v2 >>= get k1 === return v1"!
11:05:58 <chrisbrown> hi
11:06:37 <chrisbrown> would anyone be able to give me a few pointers in template haskell?
11:11:09 <sieni> chrisbrown: http://www.haskell.org/th/
11:11:51 <chrisbrown> sieni: thanks. I have been looknig at that, but do you know of any good tutorials?
11:15:16 <sieni> chrisbrown: No, but I might be wrong. There are some articles, though.
11:16:23 <chrisbrown> this looks interesting http://www.haskell.org/tmrwiki/ImpureThoughts_2f1
11:31:57 <MarcWeber> I get a lot of errors of this kind: ? "put k v >>= get k === return v" and ("put k v >>= x >>= get k === return v" or "put k v >>= x >>= 
11:32:00 <MarcWeber>                 get k === x >>= get k)?
11:32:03 <MarcWeber> 20:57 < basti_> not to forget k1 != k2 -> "put k1 v1 >>= put k2 v2 >>= get k1 === return v1"!
11:32:06 <MarcWeber> 20:59 -!- ihope_ [n=ihope@c-67-172-99-160.hsd1.mi.comcast.net] has quit [Read error: 110 (Connection timed out)]
11:32:09 <MarcWeber> 21:00 -!- mathrick [n=mathrick@80.63.154.10] has quit ["Ex-Chat"]
11:32:11 <MarcWeber> 21:05 -!- chrisbrown [n=chrisbro@212.32.88.88] has joined #haskell
11:32:13 <araujo> morning
11:32:14 <MarcWeber> 21:05 -!- cinema [n=cinema@AMontsouris-151-1-66-123.w82-123.abo.wanadoo.fr] has quit [Read error: 104 (Connection reset by peer)]
11:32:16 <leshaste> flood! :)
11:32:17 <MarcWeber> 21:05 < chrisbrown> hi
11:32:20 <MarcWeber> 21:06 < chrisbrown> would anyone be able to give me a few pointers in template haskell?
11:32:22 <MarcWeber> no!
11:32:25 <MarcWeber> wrong selection sorry
11:32:27 <MarcWeber> glib/System/Glib/hsgclosure.c:184:0:
11:32:30 <MarcWeber>      error: too few arguments to function `rts_mkPtr'
11:33:20 <MarcWeber> when trying to compile gtk2hs (darcs latest or the last two distribution tar.gz) wiht ghc-6.5. Any idea where this might come from?
11:35:58 <ihope> @dónde
11:35:59 <lambdabot> Unknown command, try @listcommands.
11:36:02 <ihope> Aww.
11:36:06 <ihope> @hèlp
11:36:07 <lambdabot>  @help <command> - ask for help for <command>
11:36:10 <ihope> :-)
11:37:42 <jyp> MarcWeber: maybe try Lemmih's version
11:37:56 <ihope> Wha
11:38:04 <ihope> t's with the recipes in @fortune?
11:38:05 <jyp> MarcWeber: http://darcs.haskell.org/gtk2hs.hide/
11:38:19 <jyp> @fortune
11:38:20 <lambdabot> Compassion -- that's the one things no machine ever had.  Maybe it'
11:38:20 <lambdabot> s
11:38:20 <lambdabot> the one thing that keeps men ahead of them.
11:38:20 <lambdabot> 		-- McCoy, "The Ultimate Computer", stardate 4731.3
11:38:51 <ihope> @fortn
11:38:52 <lambdabot> Hackathon Raisin Rice
11:38:52 <lambdabot>  
11:38:52 <lambdabot> 10 cups rice
11:38:52 <lambdabot> 5 Onions, chopped fine
11:38:52 <lambdabot> 10 cloves garlic, crushed
11:38:54 <lambdabot> [17 @more lines]
11:38:58 <ihope> That!
11:39:10 <ihope> @. more . more . more more
11:39:10 <lambdabot> Butter
11:39:10 <lambdabot> 2.5 cups raisins
11:39:10 <lambdabot> 2.5 tsp oregano
11:39:10 <lambdabot> 22 cups water
11:39:12 <lambdabot> 40 chicken bouillon cubes (or equivalent - you want to make double
11:39:14 <lambdabot> [12 @more lines]
11:39:16 <lambdabot> 			  strength chicken stock - chicken-in-a-mug
11:39:18 <lambdabot> 			  works well made double strength).
11:39:20 <lambdabot>  
11:39:22 <lambdabot> Saute Rice, onion and garlic in a little butter until slightly brown.
11:39:22 <ihope> Um, oops?
11:39:24 <lambdabot> I manage this in the (large) pot(s) necessary by throwing together
11:39:26 <lambdabot> [7 @more lines]
11:39:28 <lambdabot> the onion, garlic, and butter to brown up, then faking it a bit with
11:39:30 <lambdabot> the dry rice thrown in while threatening kitchen interlopers with
11:39:32 <lambdabot> sharp instruments if they come in to ask how it's going.
11:39:33 <int-e> argh
11:39:34 <lambdabot> Dissolve bouillon in water, add along with remaining ingredients.
11:39:36 <lambdabot> Cook until rice is done (for more intimate proportions, divide down
11:39:38 <lambdabot> to an appropriate amount of rice for your occasion).
11:39:40 <MarcWeber> jyp: Will try it
11:39:40 <lambdabot>  
11:40:24 <int-e> ihope: I'm sure those tricks work in private messages as well.
11:41:00 <ihope> X-| I won't do it again.
11:45:08 <palomer> hah! I enjoyed it
11:45:23 <jyp> Strange reciepe for sure.
11:47:27 <ihope> @förn
11:47:28 <lambdabot> Unknown command, try @listcommands.
11:47:29 <ihope> @förtn
11:47:30 <lambdabot> Unknown command, try @listcommands.
11:47:59 <ihope> @førtüné
11:48:00 <lambdabot> Unknown command, try @listcommands.
11:56:43 <jyp> @quote
11:56:44 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live
11:56:44 <lambdabot> music and there was this cute girl I was talking too while this guy was
11:56:44 <lambdabot> there, we started ribbing each other in the appropriate way when confronted
11:56:44 <lambdabot> with the situation of two guys talking to the same girl, and our jeers
11:56:44 <lambdabot> eventually turned technical until we were arguing about haskell, perl,
11:56:46 <lambdabot> and pugs development. it turning out he was one of the pugs de
11:57:56 <jyp> @quote
11:57:57 <lambdabot> gFunk says: [the main advantage of functional programs are that they're]
11:57:57 <lambdabot> incorrect the first 1000 times you try to compile it!
11:58:38 <vincenz> @quote
11:58:39 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
11:58:52 <jyp> Hello vincenz 
12:00:25 <vincenz> hi :/
12:01:39 <jyp> why the :/ ?
12:02:33 <vincenz> trying to implement RB-tree in c++
12:02:46 <vincenz> basically I need a map
12:02:47 <jyp> ah, ok :)
12:02:52 <vincenz> from int's ot some templatized value T
12:02:57 <vincenz> and I figured to use a tree underneath
12:03:02 <magnus--> vincenz: std::map is implemented as a RB-tree
12:03:11 <vincenz> magnus--: yeah I know
12:03:14 <vincenz> magnus--: and it's horrible to read
12:03:19 <vincenz> especially how they handle the header bit
12:03:32 <vincenz> (To make it such that doing iterator++...enventually gets you to some end())
12:03:37 <magnus--> is this homework? Otherwise, just use std::map and be done with it :)
12:03:47 <vincenz> no can't do
12:03:52 <vincenz> cause I need to add profiling at different places
12:03:55 <vincenz> and std::map is a horror
12:04:21 <magnus--> okay
12:04:36 <vincenz> I'm actually using it as reference
12:04:39 <vincenz> but is it UGLLLLLLLYYYYYYYYYYY
12:05:45 <vincenz> blegh
12:05:52 <vincenz> I guess I'll for non-rb- first
12:05:58 <vincenz> the hard part is that header bit
12:06:20 <vincenz> cause it's the last element in the tree... and it's left pointer points to the initial, it's parent to the top of the tree and it's right one to the last valid element
12:06:26 <vincenz> so once you're there, traversal is rather ill defined
12:06:30 <vincenz> which complicates all the methods
12:09:52 <vincenz> :(
12:09:55 <vincenz> c++ sucks
12:10:07 <jyp> yessir
12:10:12 <vincenz> if someone has suggestions for another data structure
12:10:19 <vincenz> all I require is basically a sparse seqeuence
12:10:25 <gzl> I've so far been successful avoiding C++ entirely. I'm worried that's going to catch up with me.
12:10:29 <magnus--> AVL trees are supposedly simpler to code up
12:10:38 <vincenz> magnus--: they are/
12:10:44 <vincenz> well I'm still stuck at the basic stuff
12:10:56 <vincenz> something as simple as find becomes ugly with the presence of that last invalid element
12:11:01 <jyp> The question is, why C++ and not haskell ?
12:11:12 <vincenz> jyp: because it needs to be plugged into c++ applications?
12:11:36 <jyp> you may have a point :)
12:11:51 <magnus--> I still suggest using std::map and not worrying ;)
12:12:19 <vincenz> magnus--: I need to plug in my profiling framework at key points
12:17:59 <vincenz> oh well
12:18:04 <vincenz> I'll do a tree without balancing for the moment
12:18:07 <vincenz> test and go from there
12:18:14 <vincenz> performance isn't a priority
12:19:16 <magnus--> if performance is not a priority, why is profiling important?
12:20:01 <vincenz> you assume runtime profiling
12:21:41 <magnus--> sorry, I'm just confused
12:26:31 <jonkri> neologism: thanks
12:28:07 <jonkri> how do i get hat? "emerge -s hat | grep askell" returns nothing
12:32:22 <jonkri> a gentoo debugger for gentoo, anyone?
12:32:41 <jonkri> i get an error that doesn't give me a line number or anything. i will need to solve this
12:34:17 <ndm> @where hat
12:34:20 <lambdabot> http://www.cs.york.ac.uk/fp/hat
12:34:34 <ndm> jonkri: are you using Hugs or Ghc?
12:34:42 <jonkri> ghc
12:34:58 <ndm> ah, usually GHC is better with error line numbers
12:35:08 <ndm> what is the error?
12:35:32 <ndm> and how long is the code?
12:36:39 <jonkri> ndm: the error is: life-client: Prelude.(!!): index too large
12:36:50 <jonkri> ndm: i don't even know what file the problem appears in
12:36:50 <ndm> how long is the code?
12:37:17 <wimp> why should I use haskell instead of scheme?
12:37:25 <ndm> wimp, do you know scheme?
12:37:36 <wimp> I do
12:37:41 <wimp> but I don't know haskell
12:37:43 <ndm> ((less () (brackets)))
12:37:49 <ndm> static typing
12:37:52 <ndm> richer data structures
12:37:55 <ndm> laziness
12:37:57 <ndm> nicer syntax
12:38:20 <wimp> laziness I can get in scheme with lambda(); nicer syntax I won't argue on; how about static typing; I never understood this argument
12:38:24 <ndm> i learnt scheme before haskell, and haskell is better in every possible way
12:38:30 <ndm> consider you want a tree
12:38:43 <ndm> data Tree a = Branch (Tree a) (Tree a) | Leaf a
12:38:53 <ndm> that statement alone will remove most of the errors in your code
12:39:16 <wimp> doesn't dealing with this require dynamic typing?
12:39:17 <edwinb> typechecking is something that computers are better than humans at, so I prefer to let it do it for me. It stops me doing dumb things...
12:39:17 <ndm> jonkri: what i usually do is defined !!! as a safe variant of !!, and then replace half the !! with !!!
12:39:24 <wimp> i.e. at runtime knowing if it's a branch; or if it's a leaf
12:39:25 <Korollary> I learned haskell first, and right now I can't learn lisp or scheme because they appear inferior somehow.
12:39:31 <ndm> wimp, no its entirely static typing
12:39:38 <jonkri> ndm: what does that mean? "safe variant"
12:39:40 <edwinb> Branch and Leaf arent' types, they're constructors
12:40:04 <ndm> jonkri: ok, not safe variant, just a variant that gives a different error message
12:40:21 <wimp> so they both end up being of this "Tree object" which can then be dynamicly queried to see if it's a branch or a leaf?
12:40:23 <ndm> jonkri: then by process of elimination, in a few mins you'll have the cause of the error
12:40:26 <edwinb> wimp: exactly
12:40:47 <jonkri> ndm: ok, thanks
12:40:52 <edwinb> It leads to much more readable code, and the machine helps you out more.
12:41:03 <ndm> jonkri: i also define "safeIndex" which takes an additional parameter,  a string, to be given back in any error emssages
12:41:05 <wimp> how about haskell vs ML?
12:41:09 <ndm> also fromJust and head
12:41:10 <wimp> ML afaik supports the example you gave above
12:41:20 <edwinb> it may be a matter of taste which people prefer
12:41:20 <ndm> saves lots of debugging time later on!
12:41:31 <ndm> haskell has a nicer syntax, but not by much
12:41:43 <ndm> haskell is lazy, ml is strict - thats the big difference
12:41:43 <edwinb> I find ML syntax messy, but that may just be because I learned Haskell first.
12:41:52 <ndm> ML has no where
12:42:04 <wimp> lazy/strict for typing?
12:42:05 <wimp> or evaluation?
12:42:05 <ndm> but i guess as a scheme person, thats not really going to matter to you so much
12:42:08 <jyp> haskell has a more active community, afaict
12:42:09 <ndm> evaluation
12:42:21 <wimp> lazy == normal; strict == applicative ?
12:42:25 <edwinb> yes
12:42:31 <jonkri> "afaict"?
12:42:33 <ndm> scheme is strict
12:42:44 <jyp> jonkri: as far as I can tell
12:42:49 <jonkri> thanks
12:42:51 <magnus--> ML is like a strongly typed scheme minus macros
12:43:03 <ndm> apart from a few specific fucntions, and, or, if etc.
12:43:17 <edwinb> plus algebraic data types, which is quite a big plus...
12:43:23 <MarcWeber> jyp: Thanks.. I could compile and install it!
12:43:27 <Korollary> and pattern matching which lisp doesnt have
12:43:31 <jyp> MarcWeber: cool :)
12:44:03 <jonkri> ndm: will nat give me the line number?
12:44:07 <jonkri> s/nat/hat
12:44:21 <wimp> so haskell is equiv to ocaml in type resolutio npower?
12:44:26 <ndm> jonkri, hat-stack should give you exactly what you want
12:44:42 <ndm> wimp, haskell has type classes as well, which is more than ocaml
12:45:03 <ndm> jonkri: line numbers, what called what, its the perfect answer in that case
12:45:24 <jonkri> yes, thanks
12:48:59 <magnus--> wimp: Haskell has a steeper learning curve but I think that it's a more powerful language than SML/Ocaml
12:49:28 <magnus--> wimp: Haskell SML and OCaml share a lot of the basics so whichever you focus on you'll understand the others better
12:49:50 <wimp> and neither of them share that much in common with scheme/lisp other than the word "functional" ?
12:50:38 <magnus--> wimp: SML/OCaml are closer to scheme/lisp
12:50:39 <mwc> indeed, the typesystem separates SML,Ocaml, Haskell from Scheme/Lisp style FPs
12:51:19 <magnus--> wimp: on the other hand haskell is closer to lisp in the way you build domain specific languages for a lot of things
12:51:36 <wimp> ocaml lacks this?
12:52:01 <mwc> Nah, they have a tool called camlpp or something that's a pretty advanced "preprocessor"
12:52:09 <mwc> it makes it fairly easy to write EDSLs too from what I've read
12:52:24 <mwc> camlp4, just checked my PATH
12:52:25 <magnus--> I know mostly about haskell and sml
12:52:46 <jonkri> i have only one question
12:53:14 <jonkri> why the hell is there a microsoft person behind http://www.haskell.org/ghc/ ?
12:53:18 <wimp> just for a reference marker of how deeply involved you guys have been with scheme; have any of you finished sicp ?
12:53:18 <jonkri> :o)
12:53:43 <mwc> jonkri, MICROS~1 hires a lot of academic types from math and comp sci and just pays them to do research
12:53:46 <edwinb> Microsoft fund FP research... this seems to be a good thing to me...
12:54:11 <jonkri> ok, thanks :)
12:54:24 <Korollary> I have been thru SICP althout I havent done all the exercises.
12:54:26 <xerox> Hi!
12:54:43 <magnus--> wimp: I watched the SICP lecture videos from MIT. They were awesome. I know scheme and common lisp.
12:54:58 <xerox> They indeed are!
12:55:48 <wimp> I see; and all of you guys have switched to haskell with no regrets? especially of eval?
12:55:53 <wimp> of code/data being one?
12:56:47 <mwc> that to me has always seemed a sort of artificial feature. I never really found a use for it
12:57:14 <mwc> THen again, I tend to do do a lot of simulation and modelling code, so it most likely just doesn't apply to my domain
12:57:55 <edwinb> I've never felt the need for it...
12:58:02 <wimp> lol; I gues sI should just go learn haskhell and test it for myself
12:58:06 <wimp> what's the equiv of sicp ?
12:58:22 <magnus--> wimp: in haskell, higher order functions (and operators) acheive pretty much the same as macros acheive in lisp
12:58:33 <ndm__> i think most people use the online tutorials are used more instead of books
12:58:35 <magnus--> because the syntax is very lightweight for HOFs
13:00:29 <mwc> wimp, if you go to a library at a uni, you should be able to find the School of Expression by Hudak, seems to be well regarded
13:00:43 <mwc> I bought it
13:00:47 <magnus--> and you are (for imperative code) working at the meta level already (this is called monads)
13:01:06 <mwc> Monads do more than imperative code, but yea
13:01:24 <leshaste> not to be confused with go...s.. :) sorry
13:02:09 <jonkri> why does my user find ghc 6.1 but root does not when i try to make install hat?
13:02:45 <jonkri>   Looking for ghc...   (not found)
13:02:50 <jonkri> but when i exit to my normal user
13:02:50 <mwc> jonkri, checked their respectives PATH?
13:03:03 <ndm__> jonkri: beause hat is broken, probably
13:03:44 <jonkri> eeehrm
13:03:47 <jonkri> it's in /opt/ghc/bin
13:03:54 <jonkri> and root does not have that path
13:03:56 <ndm__> are you using hmake?
13:04:00 <jonkri> but why's it there? what's wrong with /usr/bin
13:04:04 <jonkri> ndm__: yeah, i had to
13:08:08 <jonkri> what now? see here: http://rafb.net/paste/results/mcHbUQ33.html . that means "file not found"
13:08:48 <ndm> jonkri: did you compile it with hat, then run it first
13:09:07 <jonkri> oh, i did not compile it with hat
13:09:18 <jonkri> i though a debugger could be used anytime, on any binary
13:09:23 <ndm> hmake -hat Main
13:09:39 <ndm> jonkri: no, compile the code with hat, run it, then it creates a trace
13:09:43 <ndm> then you debug the trace
13:09:59 <jonkri> this is how i compile my program atm
13:10:00 <jonkri> ghc -package wx --make LifeClient.Main -main-is LifeClient.Main.main -o life-client
13:10:19 <ndm> wx? wxWindows?
13:10:28 <jonkri> yes, something like that
13:10:39 <jonkri> it's not my code
13:10:53 <jonkri> at least not the wx part
13:11:03 <jonkri> so i'm not using hmake for my project
13:11:32 <ndm> if you have using wx, it probably won't compile with hat...
13:11:50 <jonkri> ok
13:11:55 <jonkri> so i can't debug it?
13:12:52 <ndm> probably not
13:13:45 <jonkri> that's bad
13:13:50 <jonkri> anyway, good to know. thanks
13:14:11 <jonkri> this must be a serious problem for haskell
13:14:21 <ndm> jonkri: it is, Yhc is trying to solve all this
13:14:49 <jonkri> yet another compiler? :)
13:14:56 <ndm> york haskell compiler
13:15:02 <ndm> with integrated hat trace generation
13:15:24 <jonkri> i see
13:15:26 <jonkri> thanks for your time
13:16:04 <ndm> no probs
13:22:53 <xerox> @yow
13:22:53 <lambdabot> Disco oil bussing will create a throbbing naugahyde pipeline running
13:22:53 <lambdabot> straight to the tropics from the rug producing regions and devalue
13:22:53 <lambdabot> the
13:22:53 <lambdabot> dollar!
13:34:29 <palomer> what are the reduction rules for undefined?
13:34:49 <palomer> > (\x -> 2) undefined
13:34:49 <lambdabot> 2
13:34:58 <palomer> > undefined 2
13:34:59 <lambdabot> Add a type signature
13:35:05 <palomer> > (undefined::Int) 2
13:35:06 <lambdabot> Couldn't match `Int' against `t -> t1'
13:35:09 <palomer> > (undefined::Int->Int) 2
13:35:10 <lambdabot> Undefined
13:37:31 <davidhouse> palomer, whenever you try to access it, it errors
13:37:53 <davidhouse> (\x -> 2) undefined works because of laziness
13:37:54 <palomer> access it?
13:38:06 <davidhouse> well, i'm not sure of the details, but yeah
13:38:17 <palomer> I think it's easier to state in terms of reduction rules
13:39:18 <Cale> When its evaluation is forced
13:39:37 <Cale> (specifically, by a 'case', at some level)
13:46:55 <leshaste> I don't suppose anyone here knows if an efficient suffix array construction implementation has ever been done in haskell?
13:48:56 * leshaste thought that question might be too obscure even for #haskell :)
13:57:31 <ihope> So what's the right way to respond to a CTCP TIME?
13:58:57 <mathrick> ihope: my xchat has that:
13:58:59 <mathrick> nctcp %s TIME %t
13:59:28 <mathrick> which gets translated to /nctcp <nick> TIME <time>
14:00:06 <ihope> So the CTCP stuff to send is "TIME <time>"?
14:00:35 <mathrick> ihope: it's /nctcp
14:00:47 <mathrick> meaning "notice ctcp"
14:00:55 <ihope> Ah, it's a notice?
14:00:59 <mathrick> but otherwise yes, TIME <time>
14:01:13 <mathrick> ihope: yes, that's being interpreted as "reply to CTCP"
14:01:20 <ihope> Okay. Thanks.
14:02:56 <ihope> Now I just need to know how to get ChatZilla to send notice CTCP's :-P
14:04:00 <mathrick> /nctcp I assume
14:04:13 <ihope> That doesn't work here.
14:07:18 <mathrick> Usage: NCTCP <nick> <message>, Sends a CTCP notice
14:07:19 <mathrick> funky
14:07:50 <mathrick> ihope: what if you simply try /nctcp by hand?
14:07:56 <mathrick> you can test on me
14:08:18 <ihope> ===	nctcp Unknown command
14:08:48 <mathrick> interesting
14:15:28 <adu> are there any other non-alphanumeric characters in names other than ' ?
14:16:08 <vincenz> _
14:16:18 <adu> oh ok
14:16:40 <adu> thats odd
14:16:46 <Korollary> you could check the syntax description in the online report
14:17:04 <adu> i am, but i can't read BNF
14:20:05 <ihope> Why do we use only one layer of scientific notation? I want to be able to use numbers like 3E8E5E2E6.
14:20:24 <Korollary> what is that number?
14:20:26 <davidhouse> no-one else does
14:21:03 <ihope> > 3*10^(8*10^(5*10^(2*10^6)))
14:21:08 <lambdabot> Terminated
14:21:52 <adu> ihope: that is very similar to tetration
14:21:56 <davidhouse> that would have a fair few digits
14:22:00 <ihope> :-)
14:22:22 <adu> ihope: more specifically Munafo's ideas about how to extend tetration to real numbers
14:22:51 <basti_> ihope: some people use "arrow notation"
14:23:10 <ihope> 386 -> 3#0.579066425627054
14:23:14 <adu> arrow notation also lends itself nicely to the ascii "^"
14:23:26 <ihope> > 10^10^10^0.579066425627054
14:23:27 <lambdabot> Add a type signature
14:23:34 <davidhouse> @type (^)
14:23:35 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:23:37 <ihope> > 10**10**10**0.579066425627054
14:23:38 <lambdabot> Infinity
14:23:42 <davidhouse> lol!
14:23:47 <adu> basti_: were you talking about chained-arrow notation or up-arrow notaiton ?
14:23:49 <ihope> Woot. That's not right.
14:24:11 <basti_> adu: both.
14:24:13 <ihope> > log (log (log 386))
14:24:14 <lambdabot> 0.579066425627054
14:24:19 <adu> a -> b -> c = a^^^...^b (with c up-arrows)
14:24:26 <ihope> > exp (exp (exp 0.579066425627054))
14:24:27 <lambdabot> 386.0000000000004
14:24:41 <ihope> Hmm.
14:24:57 <adu> ihope: http://home.earthlink.net/~mrob/pub/math/largenum.html
14:25:05 <adu> ihope: http://tetration.itgo.com
14:26:27 <adu> i think Munafo (the first website) was thinking of using power-towers in a polynomial-ish way
14:26:43 <adu> ihope: which is kinda what you're doing
14:40:36 <ihope> So what do I do if I want to turn the pink bits of an image red?
14:41:20 <ihope> Hue filter, I guess.
14:41:47 <ihope> Next question: how do I apply a hue filter? :-P
14:46:28 <davidhouse> \x -> filter (\pxl -> hue pxl == x) pxls
14:46:29 <lambdabot> compose module failed: Parse error: "->"
14:47:22 <ihope> :-)
14:50:31 <adu> alright!
14:50:50 <adu> i got a Haskell syntax highlighting thing working :)
14:52:55 <Igloo> In what?
14:54:05 <adu> SubEthaEdit
14:54:25 <norpan> hhgttg
14:55:06 <ihope> ¿Cómo?
14:55:33 <TuringTest> Going somewhere norpan?
14:56:06 <norpan> not really, just triggered on the sub-etha
14:56:30 <TuringTest> Ah...of course.  How obtuse of me.
14:58:00 <norpan> well, that's about the top of my intellectuality today, have had a few
14:59:20 <chrisbrown> adu: SEE already has syntax highlighting for Haskell
15:00:32 <chrisbrown> it was written by Beelsebob and can be found here http://www.dusoft.co.uk/freebies.php
15:00:37 <adu> chrisbrown: it does?
15:00:41 <adu> oh cool
15:00:59 <chrisbrown> yeah, not sure if the SEE team advertise on their page or not
15:01:23 <adu> thanks
15:01:26 <jonkri> dons: there?
15:01:28 <chrisbrown> no problem
15:02:17 <jonkri> dons: remember discussing if it was a coincidence that another haskell game of life assignment was used in australia? listen to this, at the top of our assignment: "This exercise was originally created by Manuel Chakravarty and Sean Seefried. It was modified to fit the Chalmers/GU course by Nils Anders Danielsson."
15:02:29 <jonkri> this might be a clue :-)
15:03:22 <adu> chrisbrown: i just tried his mode and I like mine better
15:03:28 <chrisbrown> haha
15:03:30 <chrisbrown> fair enough
15:03:48 <chrisbrown> I would like to try yours if you don't mind...
15:03:57 <adu> oh, you have SEE?
15:04:00 <chrisbrown> yep
15:04:05 <chrisbrown> use it daily for Haskell
15:04:07 <adu> chrisbrown: i've only been working on it for about an hour
15:04:17 <adu> how about i give it to you once i get the kinks out of it
15:04:21 <chrisbrown> ah ok, well if you want to send me it when you have finished?
15:04:26 <adu> sure
15:04:29 <chrisbrown> cool
15:04:40 <chrisbrown> look forward to trying it
15:16:58 <adu> chrisbrown: mine highlights more keywords
15:18:09 <chrisbrown> adu: I believe Beelsebob wanted to keep his simple, it can be anoying having lots of different colours...
15:18:28 <chrisbrown> but i'll certainly give yours a try!
15:21:16 <adu> hmm I like my SyntaxDefinition.xml better but is RegexSymbols.xml is better so i think I'll use his
15:21:44 <adu> ic
15:22:41 <araujo> hello
15:37:25 <adu> chrisbrown: i think i'm done
15:37:33 <adu> chrisbrown: you want me to email it to you?
15:37:48 <chrisbrown> please... cmb21@kent.ac.uk
15:37:50 <chrisbrown> thanks
15:37:53 <adu> ok
15:40:05 <adu> chrisbrown: there was also a problem with the function symbols and I fixed them
15:40:33 <chrisbrown> adu: oh?
15:40:33 <adu> for some reason it was grabing " \t function ::" as the function name
15:40:46 <adu> now it displays "function" like it should
15:40:54 <adu> simple fix
15:43:37 <ihope> class Applicable c where apply :: c a b -> a -> b
15:44:31 <ihope> Applying an Applicable to a value automatically turns it into a function.
15:48:41 <adu> chrisbrown: sent!
15:49:09 <adu> chrisbrown: let me know what you think
15:58:26 <chrisbrown> adu: thanks I'll take a look tomorrow
15:58:31 <chrisbrown> how do i make it work?
15:59:40 <adu> chrisbrown: drag it to ~/Library/Application Support/SubEthaEdit/Modes
15:59:52 <chrisbrown> cool
16:00:09 <adu> but expand it
16:00:16 <adu> either before or after the dragging part
16:00:27 <chrisbrown> ok
16:00:54 <adu> then restart SubEthaEdit if its open
16:01:45 <chrisbrown> cool, if you are on here tomorrow i'll speak to you about it, hopefully i will get some time in the morning to check it out
16:01:50 <adu> ok
16:02:02 <adu> chrisbrown: i also added class symbols
16:02:18 <adu> before it only recognized funcs / types and modules
16:02:24 <adu> not it recognizes classes too
16:02:27 <adu> now
16:02:34 <chrisbrown> cool
16:02:38 <chrisbrown> sounds good
16:02:58 <adu> s/before/Beeslebob's version/
16:03:47 <chrisbrown> anyway off to bed - night
16:06:01 <leif> Why does Prelude.mod only work for Integral types? And what's the equivalent function for Floats?
16:06:33 <resiak> What would 2.5 mod 3.6 mean?
16:07:37 <leif> 2.5?
16:08:10 <resiak> That was a really bad example I guess. *shuts up*
16:08:56 <leif> 3.6 `mod` 2.5 would be 1.1.
16:09:17 <SimonRC> yeah
16:10:57 <palomer> grrr, c++ doesn't even have mutually recursive types
16:11:07 <palomer> even java has that!
16:16:47 * SimonRC decides to go to bed.
16:19:19 <Pseudonym> Sorry?
16:19:48 <Pseudonym> What do you mean, C++ doesn't have mutually recursive types?
16:20:12 <Pseudonym> Do you mean you can't define an infinitely large structure?
16:21:28 <leif> So... does anyone know what the answer to my question is?
16:22:54 <Pseudonym> I don't think there is one, leif.
16:23:00 <Pseudonym> You could do this:
16:23:07 <newsham> hi
16:23:10 <Pseudonym> remainder :: (Fractional a) => a -> a -> a
16:23:33 <newsham> greetings -> response
16:23:40 <Pseudonym> remainder x y = x - fromIntegral (toIntegral (x/y)) * y
16:23:43 <Pseudonym> It ain't pretty.
16:23:47 <Pseudonym> Oh, hang on.
16:23:54 <Pseudonym> remainder x y = x - fromIntegral (floor (x/y)) * y
16:24:13 <Pseudonym> > let remainder x y = x - fromIntegral (floor (x/y)) * y in 3 `remainder` 0.5
16:24:14 <lambdabot> 0.0
16:24:17 <Pseudonym> > let remainder x y = x - fromIntegral (floor (x/y)) * y in 3 `remainder` 0.3
16:24:19 <lambdabot> 0.0
16:24:27 <Pseudonym> > let remainder x y = x - fromIntegral (floor (x/y)) * y in 3 `remainder` 1.2
16:24:29 <lambdabot> 0.6000000000000001
16:24:55 <Pseudonym> You might want different behaviour for negative numbers.
16:25:53 <leif> That looks fine. Thanks a million.
16:28:11 <newsham> r - floor(r) where r = x/y ?
16:28:22 <newsham> oh, thats not what you want, nevermind
16:32:46 <dons> Moin!
16:39:56 <araujo> yay!
16:40:00 <araujo> hola dons 
16:47:42 <dons> hola araujo :)
16:47:45 <dons> how's code?
16:50:10 <araujo> dons, very well... next to hack a bit on himerge tonight, starting univ next week, so im gonna be kind of busy :-)
16:50:15 <araujo> dons, yours?
16:51:37 <dons> ah, cool. where are you going to university?
16:51:48 <dons> busy, as usual these days, it seems.
16:53:43 <araujo> dons, here on my city, urbe university
16:54:25 <dons> nice. any haskell taught there?
16:54:44 <araujo> dons, not _yet_ ;-)
16:54:47 <dons> hehe
16:55:07 <araujo> dons, i got some projects for this semester, i hope to get them on haskell though
16:55:19 <dons> excellent.
16:56:27 <dons> yeah, sometimes you just have to ask the lecturer, and they'll let you write the assignment in haskell
16:56:41 <dons> (though sometimes they say: "No. That wouldn't be fair to the C++ people")
16:56:49 <araujo> yeah, i hope to do so
16:57:09 <araujo> dons, haha
16:57:13 <Korollary> They would be ok as long as they dont have to learn haskell to grade it. Most appropriate for large projects where your code won't be perused.
16:57:33 <dons> exactly.
16:57:35 <araujo> dons, i think i pretty much can use Haskell.. im positive on this
16:57:38 <dons> ones with automatic testing
16:58:08 <gzl> what do people here think of python? I quite like it so far.
16:58:20 <Korollary> I liked it while I was using it.
16:58:39 <araujo> dons, and if everything goes as expected, i think i could even give a brief talk about haskell :-)
16:58:45 <dons> yay!1
16:58:52 <newsham> program in what the prof wants you to code in.. good opportunity to use another language
16:59:04 <newsham> you can do haskell in your free time
16:59:19 <dons> newsham, plenty of places are happy to let you use haskell
16:59:22 <dons> you don't have to hide it
16:59:29 <araujo> right
16:59:32 <Korollary> nah it's not about hiding it
16:59:44 <Korollary> It's an excuse to learn lisp, ocaml, etc.
16:59:44 <newsham> sure, but the best thign about school is it makes you do stuff you wouldnt normally do, and free time to do stuff you wanna do
16:59:55 <dons> sure, but if it's just another java assignment, ...
17:00:13 <newsham> there's a lot to e learned writing code in java
17:00:14 <araujo> newsham, i just feel too much annoyed because of this "language" imposition thing. I mean, if you feel confortable with one language, why not to use that one?
17:00:19 <newsham> even if its "wow, I really dont like java" ;-)
17:00:46 <newsham> araujo: well, if you plan to do anything in life other than be an academic, get used to language imposition
17:00:54 <araujo> And more important, if you know you could get a better solution, let's go ahead!
17:00:54 <gzl> araujo: people use exactly the opposite argument to convince java/c whatever programmers to try out haskell. and what newsham said
17:01:18 <dons> yeah. i think the problem is going to be too much exposure to java/c
17:01:57 <newsham> write the code in java, then put a 1-page reimplementation in haskell in the comments
17:02:01 <araujo> newsham, i think Haskell (if you refer to it specifically) can pretty much do whatever other language in the industry does. Actually, some of my projects this semester will be about proving that.
17:02:06 <gzl> that's another story. but I don't think Haskell elitism is a necessarily a good thing either
17:02:26 <newsham> (besides, you can learn lots from haskell and bring it to another language. things other people who code in that language often will not normally do)
17:02:27 <araujo> gzl, opposite argument?
17:02:45 <gzl> araujo: opposite argument being that despite being comfortable in java/c, it's still worthwhile learning new languages
17:02:46 <newsham> aruajo: sure.  I can implement a TM in haskell as a proof if you want.
17:03:00 <araujo> gzl, I think that keeping Haskell inside academy, that's elitism. 
17:03:20 <gzl> I think elitism is too easily dismissive
17:03:22 <dons> anyway, as a person who imposes languages on students, i have to say: usually you don't care what they use. if they want to use C++, then go for it. 
17:03:24 <gzl> as a reason
17:03:25 <newsham> so do stuff in java and say "if I was doing this in haskell, it would be easier because.."
17:03:31 <newsham> what better advocacy?
17:03:33 <araujo> If you take it out to the street (as Dennis Ritchie said in a interview) , that's the work of the community pretty much.
17:03:59 <newsham> "see, here's my haskell implementation.  1/3rd the size, and within 3% of the performance"  or better "..and faster"
17:04:35 <araujo> Haskell is fun, and i just want to make the univ. fun too ;-)
17:04:36 <newsham> anyway, back to my original point,  learning to do stuff in another language could only help, not hurt.
17:04:50 <newsham> you know haskell, and you know you like it..  that much is already settled
17:04:54 <dons> yes. if you don't know the language, it's good to learn the one they're teaching
17:05:05 <araujo> newsham, i know java 
17:05:07 <dons> if you know it already, and it's the 40th java assignment, maybe use haskell
17:05:08 <araujo> and i don't like it
17:05:09 <MarcWeber> What does import qualified a.b.c mean compare d to import a.b.c?
17:05:23 <araujo> they force everybody to use java very much.
17:05:26 <newsham> araujo; could be worse.  could be c++.
17:05:29 <dons> MarcWeber, it changes how you can refer to the things you import
17:05:34 <araujo> I think that's a sad reality everywhere nowadays.
17:05:42 <dons> you need to use the full, qualified name, when you import qualfiied
17:05:49 <dons> i.e. Data.List.sort versus sort
17:05:52 <newsham> araujo:  *shrug*  I get paid to look at whatever language the client pays me to look at.  thats life.
17:05:53 <araujo> newsham, so you say i should get java?
17:06:01 <MarcWeber> dons: Can I then refer to b.c.<something expose by c> ?
17:06:15 <MarcWeber> araujo: or jikes ;)
17:06:16 <araujo> newsham, different life, different needs.
17:06:19 <dons> isn't newsham just saying: learn lots of languages, don't miss any opportunity to learn a new one?
17:06:36 <newsham> dons++  (not just "learn" but "get experience")
17:06:47 <Korollary> dons++ !
17:06:48 <newsham> you can learn something from every language.
17:07:07 <araujo> Ther eis no point to try to get experience in lkanguages that don't let you anything.
17:07:09 <newsham> sorry, didnt mean to break dons' referential transparency
17:07:22 <MarcWeber> newsham: You'll learn by deafault every day... You have to ask where you an learn more (important things) ..!
17:07:29 <araujo> I bet any Haskell programmer could take the java language faster and better than a java programmer can take the Haskell language.
17:07:37 <dons> argh! I'm _impure_
17:07:53 <Pseudonym> araujo: That's probably correct for a _typical_ programmer.
17:08:08 <ndm> araujo: i disagree
17:08:15 <Pseudonym> I don't think that's true for a expert.
17:08:16 <araujo> I think this is the second time i expose this theory here... i should try to prove it someday :-)
17:08:20 <ndm> most haskell programmers pick up Java first because they did other things first
17:08:24 <newsham> "purity has its regrets, and all programmers in pure functional languages will recall some moment when an impure feature has tempted them."
17:08:39 <ndm> hence by the time they get to haskell, they know haskell and <imperative lang>, hence java is easy
17:08:50 <Pseudonym> An expert Java programmer would have some idea about the performance issues in real JVMs and JIT compilers.
17:08:54 <araujo> ndm, no, im talking about the following, people starting programming with haskell and java.
17:09:07 <araujo> with no previous experience.
17:09:16 <ndm> different people pick up differnt things in different ways
17:09:24 <Pseudonym> I agree.
17:09:26 <ndm> i saw a first year coding "haskell" in Ada the other day
17:09:28 <newsham> pseudo: java on some platforms is pretty competitive with C.
17:09:35 <dons> ndm!
17:09:44 <Pseudonym> I think that people starting Haskell programming don't worry about the speed of the program unless it's a truly intractable algorithm.
17:09:45 <ndm> he had never seen Haskell, or heard of it, but thats what he was typing
17:09:46 <dons> haskell in ada? how so?
17:09:47 <araujo> ndm, im talking about some kind of experiment here, not about how things are with most of the people.
17:09:53 <dons> ah. hehe
17:09:55 <Pseudonym> They're more concerned with speed of writing.
17:09:58 <ndm> dons, all the "syntax errors" were valid haskell
17:10:04 <ndm> like he only used recursive functions
17:10:17 <Pseudonym> I certainly was.
17:10:25 <ndm> omitted return (he considered it implicit), if cond then res1 else res2 style of code
17:10:28 <newsham> old saying "a C programmer knows the cost of everything and the value of nothign.. a lisp programmers knows the value of everything and the cost of nothing"
17:10:30 <Pseudonym> I wasn't attracted to... well, it was Miranda at the time... because the code was fast.
17:10:43 <Pseudonym> I was attracted to it because my programming was fast.
17:11:01 <newsham> optimizing programmers time is very important.
17:11:09 <Pseudonym> That we have a few decent implementations now is a bonus.
17:11:12 * araujo got attracted to Haskell because of its purity
17:11:24 <araujo> I think it makes the code look prettier.
17:11:30 <Pseudonym> I agree.
17:11:39 <newsham> (dont forget that the real optimization function is your paycheck.  If you get paid to do java, you'll probably do it happily)
17:11:40 <Pseudonym> Miranda wasn't very pure, so that wasn't what attracted me.
17:11:53 <ndm> but we lack a good haskell debugger
17:11:58 <Pseudonym> Monads changed everything in that respect.
17:12:07 <ndm> which means that a language like C# is faster to debug than Haskell
17:12:09 <dons> newsham, I'm not sure I'd be happy programming PHP... even with the money
17:12:13 <ndm> so its still not a won battle
17:12:24 <dons> though I guess if it was enough, I'd write an embedded haskell in php, and code in that...
17:12:32 <Pseudonym> I've programmed PHP.  I really didn't like it.
17:12:40 <Pseudonym> If you only need a thin layer of glue, it's not so bad.
17:12:42 <newsham> dons: *shrug* getting paid well to write php is much nicer than getting paid poorly to deliver pizzas
17:12:46 <ndm> dons, should be easy enough to port Yhc to PHP :)
17:12:52 <dons> hehe
17:12:52 <Pseudonym> But I truly didn't like the language.
17:13:02 * ndm writes VBScript for code
17:13:08 <ndm> *cash
17:13:08 <Pseudonym> newsham: That depends.  Do you get to eat free pizzas?
17:13:22 <newsham> pseudo: in my experience -- very infrequently
17:13:40 <newsham> but it was a fun job none the less
17:13:42 <newsham> :)
17:13:42 <Pseudonym> Then you have a point.
17:13:42 <MarcWeber> newsham: You might use that job to promote haskell :-P ;)
17:13:44 <dons> if only we had free-as-in-pizza!
17:14:03 <ndm> i still want free-as-in-beer!
17:14:32 <dons> free-as-in-beer&pizza would be good
17:14:32 <Pseudonym> I'd be happy with free-as-in-disk-space.
17:14:43 <Pseudonym> Or free-as-in-bandwidth.
17:21:06 <newsham> gmail isnt free-as-in-diskspace enough?
17:21:17 <Pseudonym> High latency.
17:22:15 <newsham> 2 billion bytes of free storage!
17:22:46 <newsham> sure beats the latency of a 170k floppy
17:25:23 <dons> yeah, latency too high for my liking
17:25:44 <dons> and no unix sh interface..
17:25:46 <dons> hehe
17:26:12 <newsham> wget?  curl?  urllib?
17:28:48 <newsham> if only there was a programming language in which one could write utilities for accessing the free storage capacity of gmail
17:29:12 <Pseudonym> Or if gmail were accessible via DAV or something.
17:29:59 <qwr> http://richard.jones.name/google-hacks/gmail-filesystem/gmail-filesystem.html
17:31:09 <newsham> ahh, python strikes again :)
17:34:03 <MarcWeber> I want to carry a language and some user settings through a programm.. I use some IO funtions to get those settings at the beginning. Then StateT is the right way to carry it, right?
17:34:05 <newsham> http://libgmail.sourceforge.net/  nothing a little ffi couldnt fix
17:35:01 <newsham> (err nevermind)
17:35:13 <dons> MarcWeber, or just thread it as an argument to your functions
17:35:21 <dons> (a monad is better for large projects though)
17:36:07 <dons> ah! libgmail
17:36:15 <piggy_> Saying haskell program is shorter and faster isn't that attractive. Ruby has been promoted as an elegant language, but still few people use it until the killer app Rails came out. The same to PHP, no matter how ugly it is.
17:36:33 <MarcWeber> The concepts of haskell  ... they are that genious/innovative.. I can't believe it.. ;)
17:37:47 <newsham> piggy: i guess the hope is that if a language is consistently good at being smaller and faster it will attract people capable of making something like rails with it
17:38:09 <dons> and safer, don't forget that. that's the strongest point
17:40:34 <piggy_> newsham: yes, we need more real-world apps like darcs
17:42:11 <newsham> (also package support would help :)
17:42:53 <dons> that's what Cabal is for. and the oncoming hackageDB
17:43:25 <newsham> i mean like namespace stuff. 
18:01:39 <jonkri> is there a function to remove duplicates from a list?
18:01:53 <jonkri> [1, 1, 2] --> [1, 2]
18:01:56 <adu> in unix its uniq
18:02:07 <jonkri> adu: huh? :)
18:02:27 <mauke> jonkri: List.nub
18:02:40 <jonkri> thanks
18:03:15 <palomer> hrm
18:04:13 <jonkri> palomer: what's up?
18:04:30 <palomer> trying out this new color-theme for emacs
18:04:35 <palomer> its much prettier
18:04:40 <palomer> but many of the colours are the same
18:06:22 <palomer> what about yourself?
18:08:44 <jonkri> palomer: oh really? can i see it?
18:08:55 <jonkri> palomer: well, nothing really... working on a school assignment
18:09:02 <jonkri> palomer: late as usual :S
18:09:30 <dons> > nub [1,1,2,2,3,3,4]
18:09:31 <lambdabot> [1,2,3,4]
18:11:51 <araujo> http://www.thebricktestament.com/
18:12:00 <araujo> if somebody is bored :-)
18:12:47 <palomer> @type liftM list
18:12:47 <lambdabot> Not in scope: `liftM'
18:12:47 <lambdabot>  
18:12:47 <lambdabot> <interactive>:1:6: Not in scope: `list'
18:12:47 <palomer> jonkri: do you have color-theme installed?
18:12:47 <jonkri> palomer: no, i have haskell mode
18:12:47 <jonkri> palomer: i was thinking if you had a screenshot or so
18:12:47 <jonkri> dons: got my message earlier?
18:14:45 <dons> jonkri, which was that?
18:14:47 <palomer> www.magnesium.net/~palomer/foo.png
18:14:57 <jonkri> dons: remember discussing if it was a coincidence that another haskell game of life assignment was used in australia? listen to this, at the top of our assignment: "This exercise was originally created by Manuel Chakravarty and Sean Seefried. It was modified to fit the Chalmers/GU course by Nils Anders Danielsson."
18:15:02 <jonkri> this might be a clue :-)
18:15:13 <dons> ah, yes. I saw that.
18:15:22 <jonkri> palomer: nice
18:15:28 <jonkri> palomer: however, that background is to bright
18:15:30 <jonkri> palomer: for my taste
18:15:31 <dons> I sit next to Sean, so that's why i knew about this game of life :)
18:15:45 <jonkri> oooh
18:15:50 <jonkri> that's cool :D
18:15:56 <jonkri> anyway, he's getting cred at least :)
18:16:35 <dons> yep. we steal from the chalmers course too :)
18:18:07 <palomer> raise your hand if you've read the "fun with phantom types" paper!
18:18:43 <dons> aye!
18:18:55 <palomer> really?
18:19:02 <dons> yeah, a while back
18:19:25 <palomer> ok, it says here "the functions list and pair are the mapping functions of the list and the pair type constructor."
18:19:35 <palomer> what in the blazes does that mean?
18:19:58 <dons> hmm. depends what 'mapping ' means, right?
18:20:04 <palomer> it's on page 14
18:20:11 <palomer> http://www.informatik.uni-bonn.de/~ralf/talks/FOP.pdf
18:20:31 <dons> hey, also, maybe you want to add some examples to http://haskell.org/haskellwiki/Phantom_type
18:20:36 <dons> since you're reading the paper?
18:20:44 <dons> it's good for your karma, palomer....
18:21:00 <jonkri> dons: what have you stealed? :)
18:21:05 <dons> (I'm soliciting experts on various topics to add more articles to the wiki)
18:21:28 <palomer> examples of code which uses phantom types?
18:21:32 <dons> oh, I stole some stuff from the theorem prover course/QuickCheck course that Koen taught
18:21:34 <palomer> well, there's the example in the ghc manual
18:21:39 <palomer> there's also the example in peyton's paper
18:22:07 <dons> palomer, yeah, some fun clarifying example. something that you think a beginner to phantom types would dig.
18:22:08 <palomer> and the examples in the phantom types paper
18:22:24 <palomer> well, erm, I have a rather different view of phantom types
18:22:28 <palomer> (a more general view)
18:22:32 <dons> but, would _you_ like to write it?
18:22:39 <palomer> sure
18:22:51 <palomer> but for a newb I'd probably just paste peyton's example
18:23:02 <dons> have a look at the other Idioms examples to get the flavour. you can get quite technical
18:23:06 <dons> (see the type arith page)
18:23:35 <dons> it's not necessairly newb. just _anything_ is good, at this point :) and hard interesting stuff is good too
18:23:49 <palomer> oh my, you can do arithmetic at the type level
18:23:58 <dons> of course. this is haskell.
18:24:01 <palomer> that's nuts
18:24:04 <palomer> full arithmetic?
18:24:17 <palomer> or a decidable subset?
18:24:26 <dons> I think oleg implements md5 or fibonacci, something like that. as well as / * + - ^^
18:24:36 <dons> read Oleg's stuff. it's cool.
18:24:50 <dons> I use a bit of it on the Smart constructors page for static bounds checks
18:24:51 <palomer> you can also do arithmetic with phantom types
18:25:23 <palomer> ok, I'm adding this on my todo list
18:25:34 <dons> ok :)
18:26:05 <palomer> but, erm, do you know what the list function does?
18:26:29 <dons> let me read the page.
18:26:29 <palomer> it turns (a -> b) into ([a]->[b])
18:26:50 <palomer> that looks suspicioulsy like flip map
18:26:53 <palomer> @type flip map
18:26:54 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
18:26:54 * davidmccabe writes a lissajous demo.
18:26:56 <palomer> @type flip fmap
18:26:57 <lambdabot> forall (f :: * -> *) a b.
18:26:57 <lambdabot>      (Functor f) =>
18:26:57 <lambdabot>      f a -> (a -> b) -> f b
18:27:08 <dons> oh, iit's lifts the function to a map
18:27:19 <palomer> you can ignore the lift
18:27:41 <palomer> wait, it is map!
18:27:46 <palomer> and pair is mapping for pairs
18:27:48 <palomer> @type map
18:27:49 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:27:58 <dons> \type ord
18:27:59 <lambdabot> Not in scope: `ord'
18:28:02 <palomer> ugh, I have to write map now
18:28:04 <dons> \type Char.ord
18:28:05 <lambdabot> Char -> Int
18:28:07 <dons> \type map Char.ord
18:28:08 <lambdabot> [Char] -> [Int]
18:28:20 <dons> so it just means 'map', yeah?
18:29:29 <mauke> \type \f -> foldr ((:) . f) []
18:29:30 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
18:30:29 <palomer> dons: yeah
18:30:38 <palomer> so map lifts
18:30:44 <palomer> I always wondered what the word lift means
18:30:50 <palomer> it seems to be thrown around everywhere
18:32:16 <dons> when ever something is wrapped , in some way :)
18:32:36 <dons> so, into, IO, or a monad, or a functor, or 'lifted' to the type or kind level
18:32:56 <dons> or 'lifted' into data from code.
18:38:03 <palomer> so a function a -> b is lifted to a function a -> m b ?
18:38:12 <palomer> err, is lifted to a function m a -> m b?
18:43:31 <dons> 'lift' is a general term. it could mean either.
18:43:45 <dons> but it wouldn't mean going from [a] -> [b]  to a -> b :)
18:45:10 <palomer> that would be unlift
18:45:40 <palomer> what famous functions take functions of a -> b and transform them into functions of type a -> m b?
18:46:12 <mauke> (return .)
18:46:13 <Korollary> return . f ?
18:47:13 <dons> \djinn a -> m b
18:47:19 <dons> not going to happen...
18:47:21 <dons> \uptime
18:47:31 <dons> hmm
18:47:36 <palomer> @type (return .)
18:47:57 <dons> @bot
18:48:09 <lambdabot> -- f cannot be realized.
18:48:11 <lambdabot> uptime: 5 days, 12 minutes and 3 seconds
18:48:13 <lambdabot> forall (m :: * -> *) b a.
18:48:15 <lambdabot>      (Monad m) =>
18:48:17 <lambdabot>      (a -> b) -> a -> m b
18:48:19 <dons> oh, djinn stalled
18:48:21 <lambdabot> :)
18:48:27 <dons> interesting
18:48:49 <palomer> when would you want to use a function of type (a -> b) -> a -> mb ?
18:48:52 <palomer> err
18:48:52 <palomer> m b
18:50:17 <dons> for applying pure functions in a monadic pipeline
18:50:28 <dons> return . map toUpper =<< geContents
18:50:35 <dons> so you need the (return .)
18:50:44 <dons> I use this quite a lot
18:51:07 <dons> readM str >>= return . Just
18:51:13 <dons> peekArray (p - 1) (advancePtr argv 1) >>= return . map P.packCString
18:51:22 <dons> silentlyModifyST  f = modifyMVar_ state (return . f)
18:51:28 <dons> getPermissions a >>= return . readable
18:51:30 <dons> :)
18:52:00 <adu> would it make sense to have only 4 numeric classes? (Integral, Ratio, Real, Complex)?
18:52:08 <dons> getRepos >>= return . (:[]) . showRepos
18:52:26 <dons> I use this a lot: liftIO (unlambda s) >>= return . (:[])
18:52:36 <mauke> I'd either use liftM or make a new operator for >>= return .
18:52:40 <dons> well, not the unlambda bit :)
18:52:57 <dons> mauke, yeah, probably a good idea
18:53:12 <dons> \pl \a f -> a >>= return . f
18:53:13 <lambdabot> (. (return .)) . (>>=)
18:53:17 <dons> lovely
18:53:37 <dons> and we call it >>. or something
19:00:34 <newsham> someone make this nicer, more relevant, or provide comments?  http://www.haskell.org/hawiki/FfiExample
19:01:03 <lambdabot> Haskell Weekly News: March 20, 2006 out now, sequence.complete.org
19:05:10 <newsham> whoa.  hawiki bug?  it changed some of the text on that page "there can be only oen return value and there is no" -> "there can be only one return output left in - \n value and there is no"
19:05:54 <dons> 'return output' -- it's a known bug in the syntax hl on hawiki
19:06:13 <dons> it sucks. MediaWiki is so much nicer
19:06:28 <newsham> any work around?
19:06:36 <adu> does anyone want to talk about the numeric types?
19:07:13 <dons> adu, I think Cale has some agenda here. perhaps ask him.
19:07:21 <adu> hmm
19:08:45 <adu> i have some agenda as well :)
19:09:11 <palomer> yay!
19:09:16 <palomer> found a typo in the phantom types paper
19:09:20 <adu> i think Real, RealFrac and RealFloat should be merged
19:09:37 <adu> palomer: yey
19:10:02 <palomer> ok, i've only seen 2 mildly useful functions written with phantom types
19:10:05 <palomer> and both had typos
19:10:41 * palomer pokes cale
19:11:07 <dons> palomer, I think most of Oleg's math on the types stuff uses phantom types
19:12:49 <adu> whats a phantom type?
19:12:58 <palomer> ahh, that's what I thought
19:13:07 <palomer> btw, I'm no expert>:O
19:14:04 <dons> i think anyone reading a paper on phantom types should write a bit of wiki content on them ;)
19:14:34 <palomer> yeah, I'm just warning that the content may not be up to par with oleg's
19:15:20 <palomer> dons: still have the paper open?
19:15:20 <dons> oh, that's fine. just do the basics then :) it only has to be a paragraph or two if you want
19:15:33 <dons> yep
19:15:38 <dons> with the scary zombie on the front
19:15:47 <dons> oh, the slides, you mea?
19:16:03 <palomer> yeah
19:16:05 <palomer> page 14
19:16:15 <palomer> for he code
19:16:17 <palomer> before last line
19:16:33 <palomer> you have to switch ra_2 with rb_2, right?
19:16:56 <adu> Cale?
19:17:45 <dons> palomer,? in liftM2 pair (tequal ra1 ra2) (tequal rb1 rb2) ?
19:18:11 <palomer> yeah
19:18:18 <palomer> that code won't type check
19:19:02 <dons> hmm. 
19:19:18 <palomer> unless, of course, I don't understand what pair does
19:19:22 <palomer> do you agree?
19:20:35 <palomer> I'm about to send an email to ralf, so you better agree Xo
19:21:01 <palomer> oooh, woops
19:21:02 <palomer> misread it
19:21:04 <palomer> nevermind
19:21:49 <dons> hmm. I thought it was ok... but you can't be sure . anyway ralf is a nice guy.
19:25:47 <palomer> it types
19:32:38 * adu pokes Cale
19:33:03 <dons> it's ~2200 in Cale-land, I'm not sure he wakes up for another hour or so ;)
19:33:10 <adu> ok
19:33:45 <adu> wouldn't that mean he doesn't wake up for 9 hours?
19:34:06 <dons> no, joke, he has some weird hours.
19:34:11 <adu> hm
19:35:08 <sethk> dons, I just built a client/server app for my project using Algebraic types, hPrint, and read, and I have it working after about two hours.
19:35:24 <dons> excellent!
19:35:32 <dons> \karma+ sethk -- haskell hacker level 2
19:35:33 <lambdabot> sethk's karma raised to 2.
19:35:47 <sethk> dons, using the thing with named values     data whatever = watever { something :: Type" ...} I get marshalling/demarshalling for free
19:36:09 <dons> to disk, you mean?
19:36:18 <dons> via read/show?
19:36:25 <sethk> dons, no, I decided to do what I had down to disk, but over a net connection
19:36:37 <sethk> dons, so my client/server commands/responses are using that functionality
19:36:44 <sethk> s/down/done  :)
19:36:48 <dons> ah, yeah. very nice. i think the record syntax is good for such things.
19:36:57 <dons> I use them for config files for my mp3 player
19:37:07 <dons> Config {
19:37:07 <dons>          hmp3_window      = ("default",     "default")
19:37:08 <sethk> dons, excellent, yes.  that's what I meant, I just forgot the proper term for that syntax
19:37:08 <dons> ...
19:37:26 <sethk> dons, yes, I did something similar for reading a configuration file
19:37:42 <dons> makes it easy, eh? just derive Read/Show
19:37:52 <sethk> dons, yes, magic.  :)
19:37:57 <Korollary> It works even without labelled fields I think
19:38:10 <palomer> yes!
19:38:13 <sethk> Korollary, probably, but I find it much easier to deal with the other way
19:38:14 <palomer> my code's so fine
19:38:14 <Korollary> it's probably more readable that way tho
19:38:16 <palomer> so fine it blows my mind
19:38:18 <dons> I think you need labelled fields if you write them in labelled format :)
19:38:21 <palomer> hey mickey
19:38:40 <sethk> dons, yes, true, but he meant I think you can forgo labelling altogether
19:38:47 <dons> yep sure. you can
19:39:00 <sethk> dons, which is true, but the names are also good documentation IMHO
19:39:25 <dons> yeah, it makes it into a configuration language
19:39:48 <sethk> dons, right, you get a config file in plain text
19:43:22 <palomer> if I darcs get from a remote location, every subsequent darcs get is going to be from that location, right?
19:44:08 <palomer> darcs get www.foo.com/~bar/bing 
19:44:15 <palomer> ....2 weeks go buy
19:44:20 <palomer> go back to the directiory and type darcs get
19:44:23 <palomer> would that work?
19:47:27 <dons> palomer, yep
19:47:36 <dons> it stores the list of repos in _darcs/prefs/repos
19:47:42 <dons> so you can edit that by hand if you want
19:47:56 <palomer> and what if you want to get the latest source from a different location
19:47:58 <dons> this is where lambdabot grabs its url from, in fact:
19:47:59 <dons> \version
19:48:00 <lambdabot> lambdabot 3p325, GHC 6.4.1 (Linux i686 3.20GHz)
19:48:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:48:04 <palomer> darcs get <other location> ?
19:48:07 <dons> then the latest becomes the default
19:48:11 <dons> it's a stack
19:48:16 <dons> and the top of the stack is used by default
19:48:21 <palomer> ahh
19:48:27 <palomer> and is there an easy way to pop the stack?
19:48:40 <dons> vi _darcs/prefs/repos
19:48:56 <dons> sed 1d _darcs/prefs/repos > respos.1 ;)
19:49:04 <dons> etc. no 'api' for it, afaik
19:49:04 <palomer> that's evil
19:50:17 <palomer> darcs failed:  You must provide 'get' with either one or two arguments.
19:50:34 <palomer> eh?
19:51:49 <adu> how do you declare a function type that either takes a 2-tuple or a 3-tuple?
19:51:54 <palomer> you can't
19:52:05 <adu> woah
19:52:10 <palomer> well, not with haskell at least
19:52:14 <sethk> adu, you don't, but you can define an algebraic type that does more or less the same thing
19:52:17 <adu> something haskell CAN'T do? this is new to me
19:52:39 <palomer> you can with phantom types though
19:52:43 <palomer> but it's a bitch
19:52:46 <adu> hm
19:53:00 <adu> sounds like i don't want to do it then
19:53:11 <palomer> no, you don't
19:53:27 <palomer> anyways, you can't do it with standard pairs and triplets
19:54:10 <palomer> darcs get _always_ asks me for my password twice!
19:57:06 <dons> you should set up an ssh key authentication
19:57:11 <dons> then you get no passwords..
19:57:18 <dons> it makes it much more useable
19:57:45 <dons> copy your id_dsa.pub key to the server's .ssh/authorized_keys file
19:57:51 <adu> ooo
19:57:53 <adu> i got it
19:57:59 <dons> and make sure ssh-agent is running
19:58:11 <adu> (a, (b, Maybe c))
19:58:27 <dons> you can define it with a typeclass, no?
19:58:31 <adu> that will make something that will either have 2 or 3 things right?
19:58:44 <adu> i dunno
20:02:28 <dons> if it's only a 2 or a 3 tuple, then tag it with an Either
20:02:38 <dons> f :: Either (a,b) (a,b,c) -> ...
20:03:06 <dons> or isomorphically, (a, b, Maybe c)  or adu's idea
20:19:45 <adu> hm
20:19:57 <adu> cool
20:20:44 <dons> hmm. too many netspltis..
20:58:36 <wimp> does haske;ll suppot dynamic typing?
20:58:39 <wimp> err
20:58:40 <wimp> scoping
21:03:00 <Korollary> nope
21:03:34 <sieni> why would anyone want dynamic scoping in any language? It's confusing and causes hard-to-detect bugs without offering any real benefits.
21:04:12 <Korollary> because it's got dynamic in it, and anything with dynamic in it has got to be good.
21:06:26 <wimp> because SICP says it's not all bad
21:06:47 <wimp> chatper 1 of 1st edition
21:07:02 <wimp> chapter 4
21:07:13 <flux__> monads offer sort of 'dynamic scoping' behavior?
21:07:25 <wimp> how do monads work?
21:07:35 <wimp> anyone want to enlighten an idiot?
21:08:16 <Korollary> what section in ch 4?
21:09:01 <wimp> the section where they talk of how a small change in the meta circula evaulator
21:09:07 <wimp> can change dynamic/static scoping
21:09:12 <wimp> don't recall off the top of my head; sorry
21:19:37 <flux__> also, how about ghc's implicit parameters..
21:39:41 <dons> it supports dynamic scoping in TH. but _nobody_ wants to use it. it was a bug in lisp, in the first place, right?
21:43:37 <wimp> no
21:43:39 <wimp> I think it was intentional
21:56:47 <dons> oh, somewhere in Bob Harper's book `Programming Languages, Theory and Practice' when talking about name capture, he says it was a bug originally
21:58:41 <araujo> dons, dynamic scoping?
22:00:45 <dons> what this does in TH: [| $(var "x") |] 
22:01:26 <dons> not for the weak of constitution
22:03:03 <dons> ah! here it is, page 75 of 'Programming Languages', Harper. "In fact, the notion of ''dynamic scope'' arose as a result of an error in the original Lisp interpreter (circa 1960) that confused the scope of variables'' "
22:05:44 <dons> who wants to guess what the 't' stands for in 'mtl'
22:05:53 <adu> here
22:06:19 <dons> yes?
22:08:01 <Korollary> what do m & l stand for?
22:08:55 <JKnecht> in 1960?
22:09:35 <araujo> yeah, afaik, dynamic scoping was some kind of error in the early lisp implementation.
22:10:01 <araujo> One of the effort trying to fix that up was Scheme
22:15:30 <adu> i'm here
22:15:55 <Cale> adu: the problem with a new numeric hierarchy at this point is that fine class-hierarchies are currently a pain in Haskell
22:16:39 <adu> fine = lots of small classes?
22:16:43 <Cale> yeah
22:16:47 <adu> ic
22:17:06 <Cale> Because you can't have a definition of a subclass automatically generate a definition for a superclass.
22:17:44 <adu> where would you want something like that?
22:18:07 <adu> like going from Num => onlyMul
22:18:20 <Cale> yeah
22:18:26 <adu> ic
22:18:46 <Cale> Num => AbelianGroup, and Num => Monoid, or something :)
22:18:52 <adu> it seems so easy in UML, just draw an arrow and write "generalizes"
22:19:04 <adu> :)
22:19:09 <Korollary> UML is majik
22:19:12 <adu> hehe
22:19:25 <Cale> Those are an entirely different kind of classes too :)
22:19:49 <Korollary> what exactly is wrong with the status quo anyways?
22:20:07 <adu> how would you implement associativity and stuff? or would that be up to the instances...
22:20:20 <Cale> adu: You can't enforce things like that
22:20:29 <adu> hm
22:20:51 <adu> Korollary: Cale thinks there aren't enough classes, I think theres too many classes
22:21:45 <palomer> man, the more I'm programming in C++ the more I realize that haskell rocks!
22:22:24 <adu> Cale: whats wrong with defining a new class with the method "mul" or something?
22:22:58 <adu> or (*)?
22:22:59 <Cale> adu: well, if it's a superclass of Num, then you have to define it before you ever define an instance of Num
22:23:23 <adu> so you'd haveto change Haskell completely
22:23:36 <Cale> So in order to get an instance of Num, you end up defining 2 or 3 instances of smaller classes first, which can be irritating.
22:23:48 <Cale> Well, you need to add a feature.
22:24:09 <Cale> What feature that is, well, there's a bunch of proposals.
22:24:19 <adu> would it be like class Num a <= OnlyMul a ...
22:25:29 <adu> or class Num a =< OnlyMul a ...
22:25:30 <Cale> well, you'd just want to be able to define an instance of Num with definitions for (+) and (*) as usual, and get instances of Add and Mul (possibly with better names :)
22:25:53 <adu> oh, ic
22:25:57 <Cale> class (Add a, Mul a) => Num a
22:26:17 <adu> so like you could just define an instance of Ord, and you could implement Eq methods at the same time?
22:26:27 <Cale> yes
22:26:32 <adu> that would be great!
22:26:36 <Cale> Or Monad and get Functor for free.
22:26:44 <adu> :)
22:26:49 <adu> i like the sound of that
22:27:10 <Cale> there are lots of fiddly technical issues with getting it right, but I'm sure there's a decent way to do it
22:27:43 <adu> but what kind of syntax would you use for re-declaring a class to have a super-class?
22:27:54 <Cale> I think the status quo actually isn't *too* bad, in current Haskell, though things could be better named in places.
22:28:12 <Cale> Also, the fact that Eq and Show are superclasses of Num is irritating.
22:28:28 <adu> would you just declare Add and Mul, then do class (Add a, Mul a) => Num a as you say?
22:28:37 <Cale> yeah
22:28:48 <adu> hm
22:28:57 <Cale> possibly with some extra information in the class definition of Num, saying how to go the other way
22:29:10 <Cale> (like a default instances mechanism)
22:29:12 <dons> it's interesting seeing the 'Haskell for Mathetmaticians' faq, where they complain also about our numeric classes
22:29:26 <adu> lol
22:29:30 <Cale> Most of the problem is in naming, I think
22:29:33 <dons> something about 'the designers of Haskell knew just enough maths to be dangerous"
22:29:41 <Cale> Real is a really terrible name
22:30:11 <Cale> An actual real number type couldn't be an instance of the Real class.
22:30:42 <adu> lol
22:30:42 <dons> http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.html
22:30:57 <eivuokko> Is there a general purpose (and usefull) programming language math people don't complain about?
22:31:13 <dons> \where+ haskell-for-mathematicians http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.html
22:31:13 <lambdabot> Done.
22:31:15 <Cale> eivuokko: no
22:31:24 <dons> well, I think they like Haskell mostly. but it's still not quite maths to them
22:31:27 <Cale> eivuokko: well, mathematics, but that only runs on mathematicians :)
22:31:35 <dons> they want to execute the stuff that runs in their heads
22:31:42 <eivuokko> Yeah.
22:32:01 <adu> where is the Mathematicians faq
22:32:21 <Cale> actually, I rather like mathematica, except for the fact that its evaluation mechanism is sort of insane, and it's untyped.
22:32:26 <dons> \where haskell-for-mathematicians
22:32:27 <lambdabot> http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.
22:32:27 <lambdabot> html
22:32:29 <dons> adu ^^
22:32:34 <adu> thanx
22:32:37 * davidmccabe can think of eleven reasons not to use haskell.
22:32:40 <adu> it says not found
22:32:53 <adu> o wait got it
22:32:54 <dons> \remember Cale I rather like mathematica, except for the fact that its evaluation mechanism is sort of insane
22:32:55 <lambdabot> Done.
22:33:40 <dons> \google haskell mathematicians dangerous
22:33:41 <lambdabot> http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.
22:33:41 <lambdabot> html
22:33:43 <dons> hehe
22:33:59 <dons> fun search keys
22:34:05 <davidmccabe> \google making your users use tex to read your documentation
22:34:06 <lambdabot> http://www.catb.org/~esr/faqs/smart-questions.html
22:34:07 <Cale> dons: you can say things like Cos[x] ^= 2, and this becomes part of the definition of x.
22:34:36 <dons> davidmccabe, who makes people use tex?
22:34:42 <adu> Cale: i like that feature btw
22:34:51 <davidmccabe> I had to use TeX to find anything about the hugs graphics library.
22:35:05 <dons> you didn't just read the online haddocks?
22:35:06 <davidmccabe> well, I had to download the source tarball and find the tex files inside that.
22:35:07 <Cale> adu: It's nice in some cases, but it's a very brittle feature.
22:35:11 <dons> and why are you using hugs?
22:35:11 <davidmccabe> dons: I couldn't find them.
22:35:18 <davidmccabe> dons: the site didn't link to docs at all.
22:35:33 <dons> \hoogle Graphics
22:35:34 <lambdabot> Graphics.HGL.Run.runGraphics :: IO () -> IO ()
22:35:34 <lambdabot> Graphics.HGL.Utils.overGraphics :: [Graphic] -> Graphic
22:35:34 <lambdabot> Graphics.SOE.runGraphics :: IO () -> IO ()
22:35:34 <davidmccabe> dons: and... it was one of the recommended implementations? if it's out of favor at this point, the web sites should reflect that.
22:35:37 <Cale> adu: it doesn't extend well to deeper structural pattern matching
22:36:07 <davidmccabe> like most purveyors of esoteric languages, haskell people don't seem to know how to use the web.
22:36:20 <davidmccabe> dons: yes, that, Graphics.HGL.
22:36:26 <dons> \docs Graphics.HGL
22:36:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL.
22:36:27 <lambdabot> html
22:36:31 <dons> there's your docs
22:36:37 <dons> you can find them easily from haskell.org
22:36:39 <davidmccabe> thanks.
22:36:43 <davidmccabe> easily? maybe not.
22:36:48 <davidmccabe> maybe you just already know how to find them.
22:37:26 <dons> go to the front page. click on 'Standard libraries', click on HGL
22:37:38 <adu> "All things that could have been implemented correctly in a few seconds if a mathematician had been consulted early on."
22:37:38 <Cale> adu: so if you want to do, say  Sin[Sin[x]] ^= 2, first of all, it won't know that you want it to apply to x, rather it'll try to associate it with Sin[x], then complain that Sin is protected. There's TagSet, where you can write x /: Sin[Sin[x]] = 2, which means the right thing, but fails because x is too deep.
22:37:39 <adu> lol
22:38:04 <davidmccabe> ah, see, "Standard Libraries" doesn't mean the same thing here as it does everywhere else.
22:38:23 <adu> davidmccabe: it doesn't?
22:38:41 <davidmccabe> no.
22:38:45 <davidmccabe> it doesn't.
22:40:39 <dons> I think your criticism of the docs is unfounded. we have a widely used documentation system, and you didn't use it for some reason. i'm not sure why you went down the wrong track. a couple of minutes reading the introductions on haskell.org would have put you on to ghc, and the standard libs docs.
22:41:05 <dons> check out haskell.org, it's new , it's fresh, it's fun!
22:41:20 <Korollary> I take standard libs to mean the modules described in the report.
22:41:43 <Korollary> like python's global module index.
22:41:48 <adu> isn't that what the standard libs are?
22:42:03 <davidmccabe> dons: I didn't know it existed.
22:42:06 <davidmccabe> dons: it's hidden away.
22:42:12 <dons> \google haskell
22:42:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell
22:42:17 <Cale> There are the standard libraries, and then there are the GHC libraries.
22:42:18 <dons> there you are.
22:42:27 <davidmccabe> well, thanks.
22:42:35 <JKnecht> standard carries an implication of slow change and/or immutability that may not fit here.
22:42:37 <davidmccabe> but I think your complaint that it's easy to find is unfounded.
22:42:47 <adu> Cale: have you suggested anything for Haskell-prime?
22:42:52 <davidmccabe> JKnecht: yes, as in the C standard library.
22:42:54 <dons> \google HGL documentation Haskell
22:42:55 <lambdabot> http://www.haskell.org/ghc/docs/6.4/html/libraries/
22:43:02 <davidmccabe> you can stop googling now, dons.
22:43:09 <adu> and GHC > Std
22:43:15 <dons> well, i'm illustrating that it's pretty easy to find these docs :)
22:43:25 <Cale> adu: I've mostly just participated in discussions as they arose.
22:43:27 <JKnecht> slow byy Haskell standards but not the glacial pace of a C.
22:43:32 <davidmccabe> If you know about magic bots and so on and so on.
22:43:46 <araujo> davidmccabe, what do you mean with, standard libraries doesn't mean the same than everywhere?
22:43:51 <Cale> davidmccabe: Magic bots like google?
22:44:10 <davidmccabe> Cale: yes.
22:44:27 <davidmccabe> araujo: different communities call different strata of libraries "the standard libraries".
22:44:48 <dons>  \google is just another interaface to the real google.com. Go there, enter "Haskell" "HGL" "documentation"..
22:44:50 <Cale> To me, standard libraries means the libraries specified in the Haskell standard. Currently there are about 16 of those.
22:45:41 <JKnecht> but they're are not frozen, right?
22:45:43 <dons> we put a lot of work into haskell.org, in fact, davidmccabe, so I encourage you to check it out.
22:45:44 <davidmccabe> well, again, what's there is obvious to you and pretty opaque to me.
22:45:51 <davidmccabe> dons: I've been scouring it.
22:45:52 <araujo> davidmccabe, i don't get your comment really.
22:46:01 <davidmccabe> my apologies if it sounds like I'm whining here,
22:46:06 <davidmccabe> I didn't mean to get in an arguement about your website,
22:46:07 <davidmccabe> but,
22:46:12 <davidmccabe> it's not as wonderful as you seem to think it is for a newbie.
22:46:22 <araujo> davidmccabe, uh?
22:46:27 <dons> we're trying to improve this.
22:46:33 <davidmccabe> I'm glad.
22:46:42 <adu> i like looking at the Haskell Heir. Libs.
22:46:43 <Cale> also, it's a wiki
22:46:50 <adu> it makes me want to use GHC
22:46:59 <Cale> if you find that links you'd like to see are missing, by all means, add them :)
22:47:08 <dons> it was worse, it's getting better. but it's a volunteer effort. nonetheless, I think 3 clicks to find the result is pretty good. and google would get you there in 2 clicks anyway
22:47:17 <araujo> davidmccabe, you got there pretty much what you need to start off with Haskell.
22:47:22 <davidmccabe> Cale: well, I'd hate to go trompsing on your wiki before I know how things work.
22:47:30 <araujo> Just take a few minutes to surf it.
22:47:32 <dons> most OS distors actually provide the docs as packages now too
22:47:41 <dons> so you can just install the docs locally
22:48:02 <davidmccabe> that reminds me
22:48:19 <davidmccabe> anybody know what the ubuntu package name for HGL is?
22:48:23 <dons> In fact, I notice that http://haskell.org/graphics/ is probably useful too
22:48:36 <Cale> probably ghc6-hopengl
22:48:41 <davidmccabe> dons: no links to docs!!!!!!
22:48:45 <davidmccabe> none!!! at all!!!
22:48:45 <Cale> at least, that's what it is on Debian
22:48:50 <dons> HGL comes with ghc. it's not a separate package, is it?
22:49:03 <davidmccabe> I dunno; I tried running the example program the other day and it failed.
22:49:05 <Cale> dons: it is in a lot of distributions
22:49:09 <davidmccabe> and I couldn't understand the error message.
22:49:14 <davidmccabe> so I assumed that the library wasn't installed.
22:49:24 <Cale> http://packages.ubuntulinux.org/dapper/devel/ghc6-hopengl
22:49:48 <davidmccabe> thatks Cale.
22:50:18 <Cale> basically, you can find out anything you need to know about haskell by interfacing with #haskell or the haskell-cafe mailing list (the latter of which is also a surprisingly good code optimiser :)
22:50:41 <dons> or searching google with site:haskell.org
22:50:57 <dons> Cale ;)
22:51:16 <dons> yeah, we should add a ghc optimisation that calls haskell-cafe@ ....
22:51:18 <dons> is April 1 soon?
22:51:29 <eivuokko> Yeah.
22:51:30 <Cale> -Ocafe
22:51:48 <dons> -Ofully-nerd
22:51:48 <davidmccabe> hehe.
22:51:50 <davidmccabe> teeheehee
22:52:41 <dons> anyway, davidmccabe, feel free to ask more questions. also, you can talk to lambdabot, it knows lots of things
22:52:48 <dons> you've probably seen much of it
22:53:05 <dons> \hoogle a -> b -> [a] -> [b]
22:53:06 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
22:53:06 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
22:53:06 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
22:53:15 <davidmccabe> well, thanks dons.
22:53:26 <dons> \docs Data.List
22:53:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
22:53:28 <davidmccabe> hopefully y'all understand the shock I'm in.... :)
22:53:33 <dons> > map (+1) [1..10] -- for example
22:53:34 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
22:53:38 <dons> \type map
22:53:39 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:53:48 <dons> \kind (->)
22:53:49 <lambdabot> ?? -> ? -> *
22:53:52 <dons> \index map
22:53:53 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
22:53:59 <dons> \yow
22:54:00 <lambdabot> Send your questions to ``ASK ZIPPY'', Box 40474, San Francisco, CA
22:54:00 <lambdabot> 94140, USA
22:54:20 <eivuokko> \quote
22:54:21 <lambdabot> Cale says: I rather like mathematica, except for the fact that its
22:54:21 <lambdabot> evaluation mechanism is sort of insane
22:54:21 <dons> \where lambdabot
22:54:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:54:28 <dons> lots of resources!
22:54:39 <dons> hmm. that's a bit weird.
22:54:39 <dons> \quote
22:54:40 <lambdabot> Cale says: I rather like mathematica, except for the fact that its
22:54:40 <lambdabot> evaluation mechanism is sort of insane
22:54:44 <dons> grr
22:54:55 <Cale> \quote dons
22:54:55 <dons> the quote list got munged again. there's a bug in theree somewhere..
22:54:55 <lambdabot> dons hasn't said anything memorable
22:55:09 <Cale> \keal
22:55:09 <lambdabot> perhaps i just genius and never tested
22:55:18 <dons> it's in darcs, so no loss. but I thought I fixed that bug.
22:55:36 <Cale> what's happening?
22:56:08 <dons> sometimes when adding a quote (or sometime before adding a quote) the quote list gets dumped. hmm. maybe it's just not writing the quote on ^C
22:56:13 <dons> that might be it.
22:56:15 <palomer> man, programming in C++ is a _huge_ pain
22:57:16 <Cale> palomer: you should tell all the people in ##c++ about it ;)
22:57:45 <dons> \quote
22:57:45 <lambdabot> mwc says: I actually got away with running Haskell through a TeX pretty
22:57:45 <lambdabot> printer and handing it in as pseudocode
22:57:54 <dons> that's a good  one
22:58:03 <palomer> they should get rid of their call-by-value semantics
22:58:04 <Cale> \quote
22:58:04 <lambdabot> gFunk says: [the main advantage of functional programs are that they're]
22:58:04 <lambdabot> incorrect the first 1000 times you try to compile it!
22:58:32 <dons> should be 'static typing' really.
22:58:47 <Cale> \quote
22:58:47 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A:
22:58:47 <lambdabot> When he uses == and /= in everyday IRC chat or when he tries to fix a
22:58:47 <lambdabot> relationship by passing himself as a continuation
22:59:18 <dons> also, for those not following the mailing lists, haskell.org now has a feed of weekly news, so check it out! :)
22:59:43 <Cale> heh, I actually hadn't noticed the punnish use of the word 'fix' in that one before
22:59:49 <ibid> dons: once more, thanks for the effort :)
23:00:31 <dons> no problems. a) good haskell.org b) take over the world!
23:00:48 <Cale> I actually rather like the summary even though I keep up with the mailing lists. Sometimes HWN points out things which I'd ignored in trying to keep up with it all :)
23:01:24 <dons> there's so much these days. I think haskell-cafe is around 20-30 mails a day now
23:03:57 <dons> here, a nice graph of the traffic: http://dir.gmane.org/gmane.comp.lang.haskell.cafe
23:04:01 <dons> somethings happening..
23:04:29 <dons> maybe we're just getting more talkative :}
23:05:29 <Cale> there definitely seem to be more active Haskell users
23:05:30 <dons> nope, there's more participants too, http://gmane.org/details.php?group=gmane.comp.lang.haskell.cafe
23:05:54 <dons> more subjects, and less spam! :)
23:06:17 <davidmccabe> hurrah! finally got HGL to work.
23:06:22 <davidmccabe> it's fast, too.
23:06:27 <dons> cool!
23:06:29 <dons> in hugs or ghc?
23:06:34 <davidmccabe> not sure.
23:06:46 <Cale> I think I've only seen one spam get through on the Haskell lists so far.
23:06:48 <davidmccabe> since nothing else I've done in haskell really tells me anything about its speed.
23:06:55 <Cale> and it was pretty subtle
23:07:02 <dons> \shootout
23:07:02 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
23:07:02 <lambdabot> all
23:07:16 <dons> davidmccabe ^^ that might give some hints
23:07:22 * davidmccabe cheerfully attempts to write a lissajous program.
23:07:23 <eivuokko> I hate wrapping in lambdabot :-S
23:07:31 <dons> yeah, Ii know :(
23:07:40 <Cale> actually, I fixed the wrapping in mbot
23:07:45 <dons> once people hate it enough, someone will send me a patch
23:07:48 <Cale> I should submit that patch
23:07:55 <dons> maybe I should make the wrapping worse, to really force the issue...
23:08:00 <Cale> it's pretty easy to fix
23:08:02 <dons> Cale, please do.
23:08:08 <eivuokko> Hurrah :)
23:08:13 <Cale> the problem is that there's a hardcoded message width
23:08:22 <Cale> which is way too short
23:08:47 <Cale> if you increase that, then just increasing the line width in the user config works
23:08:53 <eivuokko> Is that protocoll or network specific value?
23:08:59 <dons> but we tried that, and some funny things happened, no?
23:09:02 <Cale> neither
23:09:15 <dons> you mean just setting the textwidth?
23:09:20 <Cale> funny things happen if you just edit Config.hs
23:09:33 <Cale> there's a silly hardcoded value, let me find it
23:09:42 <dons> oh, somewhere else?
23:09:56 <Cale> yes
23:10:00 <Cale> Lambdabot.hs line 366
23:10:10 <Cale>   mapM_ (ircPrivmsg' who . take 350) $ take 10 sendlines
23:10:14 <Cale> that's what I changed it to
23:10:17 <dons> urgh!
23:10:21 <dons> didn't know about that
23:10:44 <Cale> then set the textwidth at 350, and it works
23:10:55 <Cale> probably it should read the textwidth from the config there
23:10:56 <dons> ok, let's see if that fixes things.
23:11:01 <dons> yep
23:11:19 <Cale> (I'm pretty lazy though :)
23:17:46 <dons> \quit testing...
23:17:57 <dons> \shootout
23:18:14 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
23:18:22 <dons> :)
23:18:26 <dons> > [1..100]
23:18:27 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]
23:18:53 <dons> \listmodules
23:18:54 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock help hoogle karma lambda localtime more pl plugs poll pretty quote search seen spell state system todo topic type unlambda version vixen where
23:19:01 <dons> that seems good
23:19:19 <dons> irssi doesn't seem to know how to wrap the [1..100] list . but maybe I can live with that
23:19:57 <dons> \quote
23:19:57 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
23:20:34 <dons> anyone have issues with the formatting?
23:20:51 <dons> \version
23:20:51 <lambdabot> lambdabot 3p330, GHC 6.4.1 (Linux i686 3.20GHz)
23:20:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:21:21 <Cale> dons: you should also set the number of lines before @more to be 1
23:21:45 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
23:21:52 <dons> ah.
23:22:10 <dons> good point
23:22:16 <sieni> New Orleans has quit [Excess Flood]
23:22:17 <dons> hmm, but what consequences will that have?
23:22:41 <Cale> It will make it print one line at a time, which is usually fine.
23:22:46 <Cale> hmm
23:22:57 <dons> and ask for @more after each line?
23:22:58 <joeljose4> lemmih.. hy
23:22:58 <Cale> are there any cases where that's really bad?
23:23:04 <Cale> yeah
23:23:19 <Cale> perhaps @more should be based on character count
23:23:35 <joeljose4> hy all... 
23:23:37 <dons> \quit try tweakingg @more
23:24:19 <joeljose4> i was thinkig funct prog was dead.. untill yest an perl devloper old me they use haskell to build perl !!! .. kudos
23:25:08 <sieni> I would rather say that imperative progamming is, if not dead, at least dying.
23:25:25 <joeljose4> can we revive it?
23:25:43 <Cale> well, it's being subsumed
23:25:54 <joeljose4> like start a super sleak portal with super sleak tuts.. and projects aimed at exactly that?
23:26:15 <Cale> joeljose4: what? Revive imperative programming?
23:26:24 <dons> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
23:26:25 <joeljose4> there was a talk of ocaml bieng used to port linux into..
23:26:25 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,
23:26:25 <lambdabot> [5 @more lines]
23:26:35 <joeljose4> guess that talks died off .;(
23:26:54 <dons> ok maybe we can live with this. let's try it for a while Cale.
23:27:02 <Cale> okay
23:27:08 <Cale> @more
23:27:09 <lambdabot> 499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,
23:27:09 <lambdabot> [4 @more lines]
23:27:15 <Cale> okay, good :)
23:27:30 <joeljose4> @more
23:27:31 <lambdabot> 1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,
23:27:31 <lambdabot> [3 @more lines]
23:27:34 <dons> \web1913 annoying
23:27:36 <lambdabot> *** "Annoying" web1913 "Webster's Revised Unabridged Dictionary (1913)"
23:27:36 <lambdabot> [20 @more lines]
23:27:40 <dons> \more
23:27:40 <lambdabot> Annoy \An*noy"\ ([a^]n*noi"), v. t. [imp. & p. p. {Annoyed}
23:27:40 <lambdabot> [19 @more lines]
23:27:44 <dons> :)
23:27:51 <dons> but it's a rare command..
23:28:21 <joeljose4> \web1913 wow
23:28:23 <lambdabot> No match for "wow".
23:28:32 <joeljose4> \web1913 sos
23:28:32 <dons> iit's a 1913 dictionary..
23:28:33 <lambdabot> *** "SOS" web1913 "Webster's Revised Unabridged Dictionary (1913)"
23:28:33 <lambdabot> [4 @more lines]
23:28:35 <dons> \hoogle map
23:28:36 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
23:28:36 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
23:28:36 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
23:28:44 <dons> ah, now how did hoogle get around it?
23:28:46 <dons> interesting
23:28:49 <dons> majicks
23:29:42 <Cale> Probably writes in an unconventional way
23:29:56 <Cale> (i.e. sends messages rather than returning the list of lines)
23:43:01 <dons> oh, it returns return [unlines this]
23:43:04 <dons> wihch then get mapped.
23:43:33 <dons> whereas @eval leaves it up to @more to do the wrapping
23:44:19 <dons> so @dict could do it's own unlines, and that'd fix it, I think
23:52:29 <Cale> yeah
23:56:39 <alar> is fmap::Maybe equal to (maybe Nothing) ?
