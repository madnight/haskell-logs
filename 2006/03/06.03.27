00:00:59 <shapr> Oh, this is cool! http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
00:02:46 <ValarQ> wow, thats seems like a nice tutorial
00:04:09 <Lemmih> What's (map ("plugins/"++) pkgs) in bash?
00:06:58 <shapr> I dunno, but in zsh it plugins/**/*
00:07:13 <shapr> or do you mean just plugins/* ?
00:08:33 <dons> shapr, yes, I was thinking about frag and lambdabot in the shower, but how would it work?
00:08:35 <shapr> Lemmih: for x in *.pkg; do plugins/$x; done; ?
00:08:46 <dons> not the same as frag and vixen in the shower
00:08:54 * shapr laughs
00:09:38 <Lemmih> shapr: I have a list(?) of plugins (PLUGINS="gtkBase otherPlugin") which I wanna turn into PACKAGES="plugins/gtkBase ...".
00:10:13 <dons> sed is map + regex
00:10:13 <Lemmih> shapr: But n/m. A for-loop plus a mutable variable did the trick.
00:10:16 <shapr> ok
00:11:04 <dons> $ words "gtkBase otherPlugin" | sed 's,^,plugins/,'
00:11:04 <dons> plugins/gtkBase
00:11:04 <dons> plugins/otherPlugin
00:11:08 <shapr> dons: The full on solution is a typeclass like lambdabot's SystemModule that lets you write complete FragBots. Sounds complicated though, since I have no idea how movement works in Frag
00:11:09 <Lemmih> I keep expecting (PKG="$PKG $PLUGIN") to enter an infinite loop  (:
00:11:23 <dons> (that uses h4sh to supply 'words')
00:11:24 <shapr> As it should!
00:11:25 <dons> Lemmih! 
00:11:28 <dons> hehe
00:11:32 <dons> i get this too :}
00:13:16 <dons> oh, you want lambdabot inside Frag?
00:13:24 <dons> not frag inside lambdabot, as I was thinking :}
00:14:17 <Lemmih> @. elite taunt
00:14:36 <lambdabot> compose module failed: Parse error: "taunt"
00:15:00 <dons> @. id elite taunt
00:15:02 <lambdabot> +4UNT
00:15:02 <dons> ?
00:16:13 <shapr> dons: aalib for the other way :-)
00:16:14 <Lemmih> lambdabot might acutally be pretty good at auto-taunting.
00:19:17 <shapr> I can see two lambdabot's vixening each other in Frag.
00:29:52 <sethk> I've got a strange one.  I have a connectTo call in a thread.  If I do it immediately before forkIO and pass the handle in, everything is fine.  If, instead, I do the connect in the thread's function, the app exits
00:30:34 <sethk> literally the same call; I pasted it from one part of the file to the other to be sure.
00:31:14 <sethk> some sort of name clash?  but from one thread to another?
00:31:40 <sethk> the difference is that connectTo is, when it works, called from the main thread.
00:32:22 <shapr> @type connectTo
00:32:23 <lambdabot> Not in scope: `connectTo'
00:32:33 <shapr> @index connectTo
00:32:33 <lambdabot> Network
00:32:39 <shapr> @type Network.connectTo
00:33:09 <lambdabot> Network.BSD.HostName
00:33:09 <lambdabot>        -> Network.PortID
00:33:09 <lambdabot>        -> IO GHC.IOBase.Handle
00:33:40 * shapr has no idea :-)
00:33:40 <sethk> I don't recall anything in the docs about connectTo and threads.  I'll look again.
00:37:58 <dons> it might be to do with the network library. possibly it needs forkOS, or -threaded
00:38:11 <dons> otherwise, please ask on glasgow-haskell-users@
00:38:24 * shapr throws lambdas
00:38:24 <dons> it could well be a bug
00:38:29 <dons> sethk, are you compiling with -threaded ?
00:39:43 <ValarQ> shapr: hey! be carefull with those
00:40:04 <shapr> Hm, Geoff Washburn found a problem with unification in GADTs that covers a bunch of things, including that used by GHC.
00:40:13 <shapr> You think SPJ knows about this already?
00:40:27 <shapr> I found out by reading his livejournal, dunno if it's been mentioned elsewhere.
00:42:55 <sethk> dons, yes
00:42:59 <shapr> Seems that type variables can escape their scope or something.
00:43:12 <sethk> dons, and I've been using threads extensively in this app for weeks.
00:43:57 <sethk> dons, I'll send something to the list eventually
00:54:50 <NoobLuck> hi
00:54:54 <NoobLuck> ^^
00:55:16 <NoobLuck> how is going the recursive thing?
00:55:33 <dons> :)
00:55:41 <dons> you mean, in general?
00:55:58 <dons> let well = well in going well
00:56:04 <NoobLuck> general purpose ^^
00:56:23 <NoobLuck> n_n
01:00:20 <NoobLuck> ok im making a lab session ni haskell
01:00:47 <NoobLuck> wanna do some exercises?
01:01:02 <NoobLuck> and compare solutions?
01:03:37 <mathrick> @type tail
01:03:38 <lambdabot> forall a. [a] -> [a]
01:03:46 <mathrick> > tail [1 .. 10]
01:03:47 <lambdabot> [2,3,4,5,6,7,8,9,10]
01:03:59 <mathrick> @type last
01:04:34 <lambdabot> forall a. [a] -> a
01:06:51 * kaol considers refactoring a program written in C++ to Haskell
01:10:16 <NoobLuck> will be slow
01:10:39 <NoobLuck> slower
01:10:51 <NoobLuck> can anyone help me?
01:11:11 <NoobLuck> convert a decimal number into a binary
01:11:45 <NoobLuck> binary= list of bool
01:12:41 <NoobLuck> :O
01:12:52 <NoobLuck> ZZ
01:13:02 <NoobLuck> too easy i think
01:18:02 <ValarQ> NoobLuck: do you want to implement the library functions for it?
01:18:41 <NoobLuck> there aren not in haskell?
01:19:03 <ValarQ> well, you got showHex and alikes, not sure about binary numbers thought
01:19:26 <NoobLuck> making a list of bool or returning a number would be the same
01:19:35 <robokop> NoobLuck: int2Bin x = (not (toEnum (x `mod` 2)) : int2Bin (x `div` 2))
01:20:02 <robokop> NoobLuck: or something like that
01:20:03 <NoobLuck> i would have made it
01:20:13 <NoobLuck> i dont remember how to pass
01:21:07 <NoobLuck> wait
01:21:24 <NoobLuck>  int2Bin (x:xs) = (not (toEnum (x `mod` 2)) : int2Bin (xs `div` 2))
01:21:28 <NoobLuck> now?
01:21:43 <NoobLuck> no sorry
01:21:58 <NoobLuck> ok ok
01:21:58 <NoobLuck>  int2Bin x = (not (toEnum (x `mod` 2)) : int2Bin (x `div` 2))
01:22:00 <NoobLuck> was ok
01:23:01 <NoobLuck> but there must be a condition for negative numbers
01:23:14 <NoobLuck> and an error display
01:25:01 <NoobLuck> http://www.is.wayne.edu/olmt/binary/page3.htm
01:25:59 <robokop> well my functiun won't fit
01:26:19 <NoobLuck> no
01:26:24 <NoobLuck> is another method
01:26:44 <NoobLuck> is the same i think
01:28:40 <robokop> my function gives T T F for 4
01:28:44 <robokop> and that sux
01:29:00 <NoobLuck> i dont remember the way
01:29:42 <NoobLuck> i think
01:29:53 <NoobLuck> the base statement
01:30:31 <NoobLuck> should be
01:30:36 <NoobLuck> int2bin 0 = []
01:30:42 <shapr> akemp: Hey, did you get a chance to look at the recursive do paper?
01:31:22 <NoobLuck> int2bin :: Int -> [Bool]
01:31:23 <NoobLuck> int2bin 0 = []
01:31:23 <NoobLuck> int2bin n
01:31:23 <NoobLuck> 	| n >= 0    = 
01:31:23 <NoobLuck> 	| otherwise = error("Negative numbers not supported")
01:31:31 <NoobLuck> im here right now
01:32:50 <NoobLuck> i think that you should read the rests
01:33:13 <robokop> it has to be a [bool]
01:33:13 <NoobLuck> in the other direction
01:33:13 <robokop> ?
01:33:26 <NoobLuck> they ask to do that
01:33:37 <NoobLuck> of course can be done as you wih
01:33:54 <NoobLuck> using bool you can concntrate in the problem
01:34:23 <robokop> well whould you be happy if i would give you an int which exist of solely 1's and 0's
01:34:38 <NoobLuck> http://www.helpwithpcs.com/courses/binary-numbers.htm#decimal-to-binary-conversion
01:34:44 <NoobLuck> sure
01:34:46 <NoobLuck> no prob
01:35:04 <NoobLuck> im thinking in the solution too
01:35:23 <NoobLuck> look the order robokop
01:35:57 <robokop> yes
01:36:14 <NoobLuck> is in the other direction ~~
01:36:22 <NoobLuck> ~_~
01:37:02 <robokop> wel reverse would fit for that
01:38:32 <robokop>         int2Bin' :: Int -> Int int2Bin' x = (10 * largestPower2) + int2Bin' (x - 2 ^ largestPower2)  
01:38:51 <robokop> int2Bin' x = (10 * largestPower2) + int2Bin' (x - 2 ^ largestPower2)  
01:39:03 <robokop> sorry some bad pasting from me
01:39:24 <robokop> int2Bin' x = (10 ^ largestPower2) + int2Bin' (x - 2 ^ largestPower2)  
01:39:28 <NoobLuck> yeah
01:40:00 <NoobLuck> and int2Bin' 0 = 0
01:40:07 <robokop> yup
01:41:04 <NoobLuck> but i have to do it
01:41:11 <NoobLuck> with the first metho
01:41:13 <NoobLuck> d
01:41:18 <NoobLuck> the division
01:41:37 <robokop> oke
01:41:47 <NoobLuck> but largets power of two
01:41:57 <NoobLuck> is another function
01:42:16 <robokop> yup
01:42:40 <NoobLuck> should receive a parameter?
01:43:08 <NoobLuck> int2Bin' x = (10 ^ largestPower2 x) + int2Bin' (x - 2 ^ largestPower2 x)
01:43:31 <robokop> jup
01:43:38 <NoobLuck> :)
01:44:26 <robokop> when i code mostly i find things like that out at the moment i start writing that function (or on compile time)
01:44:32 <NoobLuck> whoa the problem is now the first method, we have to read the remainers in reverse order
01:44:44 <NoobLuck> "compile time" XDD
01:45:10 <NoobLuck> yes taht happens to me too XPP
01:45:40 <NoobLuck> :P
01:46:42 <NoobLuck> largestPowerof2 0 = error
01:46:46 <NoobLuck> largestPowerof2 1 = 0
01:48:02 <robokop> largestPower2 a x | a ^ 2 >  x = a-1
01:48:02 <robokop>                   | a ^ 2 == x = a
01:48:02 <robokop>                   | a ^ 2 <  x = largestPower2 (a+1) x
01:48:18 <robokop> int2Bin' x = (10 * largestPower2 0 x) + int2Bin' (x - 2 ^ largestPower2 0 x)
01:48:32 <NoobLuck> largestPowerof2 n = 1+ largestPowerof2 (n `div` 2 + n `mod` 2)
01:49:36 <NoobLuck> power of two
01:49:42 <NoobLuck> is not
01:49:46 <NoobLuck> 3Â²
01:50:05 <NoobLuck> 4Â²
01:50:17 <robokop> yeah should be the other way around
01:51:24 <robokop> largestPower2 a x | 2 ^ a >  x = a-1
01:51:25 <robokop>                   | 2 ^ a == x = a
01:51:25 <robokop>                   | 2 ^ a <  x = largestPower2 (a+1) x
01:55:06 <NoobLuck> a is the return value
01:56:09 <NoobLuck> for big numbers that function dont works
01:56:33 <NoobLuck> does not*
01:56:38 <NoobLuck> does not work*
01:56:50 <robokop> *Main> largestPowerof2 1000
01:56:50 <robokop> *** Exception: stack overflow
01:56:50 <robokop> *Main> largestPower2 0 1000
01:56:50 <robokop> 9
01:56:50 <robokop> (0.01 secs, 525788 bytes)
01:57:10 <robokop> which function doesn't work for 'big' numbers
01:58:13 <robokop> your function is building a list of 1+ 1+ 1+ 1+ 1+ 1+ and so on
01:58:19 <NoobLuck> yes
01:58:56 <NoobLuck> sorry
01:59:32 <NoobLuck> but the a value
01:59:55 <robokop> yeah whats wrong with that
02:00:01 <NoobLuck> is the same
02:01:06 <robokop> no it isn't
02:01:26 <NoobLuck> yes it can be faster in some cases
02:01:29 <robokop> due to lazy evaluation you get a long lines of 1's
02:01:51 <NoobLuck> i did not know that
02:01:56 <robokop> and for me it has to be calced everytime i cal my function
02:02:09 <robokop> and that is the difference
02:02:23 <NoobLuck> is better to do that?
02:03:07 <NoobLuck> i am not saying you are wrong
02:03:13 <NoobLuck> i just want to learn
02:04:12 <robokop> well it takes less cpu resources
02:04:28 <robokop> and most of the time i would prefer that
02:05:19 <NoobLuck> less memory?
02:05:40 <robokop> yup
02:06:00 <robokop> and your function gives 1 to much as result
02:06:07 <NoobLuck> i get the point
02:07:00 <robokop> well sorry memory usage is quite the same
02:07:10 <NoobLuck> if you know the size of the numbers you work with 
02:07:30 <NoobLuck> yuo can adjust the a parameter
02:08:37 <robokop> yes and that will be a bit quicker
02:08:37 <robokop> *Main> largestPowerof2 1000
02:08:37 <robokop> *** Exception: stack overflow
02:08:37 <robokop> *Main> largestPower2 0 1000
02:08:37 <robokop> 9
02:08:37 <robokop> (0.01 secs, 525788 bytes)
02:08:37 <robokop> sorry tought i coppied
02:08:37 <robokop> *Main> largestPowerof2 10000000
02:08:37 <robokop> 24
02:08:37 <robokop> (0.01 secs, 535120 bytes)
02:08:37 <robokop> *Main> largestPower2 0 10000000
02:08:37 <robokop> 23
02:08:37 <robokop> (0.01 secs, 537288 bytes)
02:08:37 <robokop> this one i would like to see
02:08:38 <robokop> > 2 ^ 23
02:08:38 <lambdabot> 8388608
02:08:43 <robokop> > 2 ^ 24
02:08:44 <lambdabot> 16777216
02:09:16 <NoobLuck> int2Bin' x = (10 * largestPower2) + int2Bin' (x - 2 ^ largestPower2)
02:09:44 <NoobLuck> int2Bin' x = (10 * (largestPower2 0 x)) + int2Bin' (x - 2 ^ (largestPower2 0 x))
02:10:03 <NoobLuck> but in the second member of the addition
02:10:24 <robokop> gtg 
02:10:28 <robokop> later all
02:10:31 <NoobLuck> if x-2^(largestPower2 0 x)
02:10:39 <NoobLuck> is < 0
02:14:13 <NameTab> hi guys
02:14:26 <NameTab> I don't quite get it, maybe one of you knows how to explain it to me
02:15:32 <NameTab> I've written a function which has to check different data types with different functions. So I want to give the function that needs to be used to the first function
02:16:08 <NameTab> but what datatype do I need to use then? will it even work because thoose check-functions are used on different datatypes?
02:17:23 <NoobLuck> i dont know if there is such function overload in haskell
02:17:35 <NoobLuck> im learning now
02:18:06 <NoobLuck> haskel
02:18:06 <NoobLuck> l
02:18:06 * NameTab too
02:19:28 <NoobLuck> :(
02:19:36 <NoobLuck> sorry i cant help you
02:20:14 <NameTab> too bad :)
02:29:11 <Saulzar> NameTab, Maybe type classes are what you are looking for
02:31:10 <NameTab> Saulzar: I don't know, I really haven't got a clue 
02:31:22 <Saulzar> NameTab, Type classes will give you overloading based on type
02:33:35 <NameTab> Num is an example of a type class?
02:33:42 <Saulzar> Yup
02:34:57 <NameTab> well, I'm still not sure how to use that, maybe a short example of what I've written so far makes things clear
02:35:10 <Saulzar> > (show 5) ++ (show "Fred")
02:35:11 <lambdabot> "5\"Fred\""
02:36:04 <NameTab> I've got a function doStuff which calls askQuestion a couple of times
02:37:00 <NameTab> askQuestion wants a function, it asks a question and gets the answer typed in from a user, this answer is checked by the function askQuestion received
02:38:06 <NameTab> and the different answers are supposed to be different data types
02:38:09 <NameTab> so what kind of type do I need to make askQuestion, it's something like a -> IO a
02:38:09 <NameTab> but a doesn't work for functions of course
02:38:18 <sethk> NameTab, sounds like you need to make an algebraic type, then your processing function pattern matches on the type
02:40:06 <Saulzar> NameTab, You can give it a type like (a -> Bool) -> IO Bool  maybe
02:40:06 <NameTab> algebraic type? (sorry, still pretty new to the language)
02:41:10 <Saulzar> a -> Bool will mean you're passing in a function
02:41:10 <sethk> NameTab, look at the data statement, and some examples of types defined with it
02:41:34 <poetix> http://codepoetics.com/poetix/?p=247 <- thoughts about Haskell, .Net and SOA
02:47:21 <NameTab> oeh, this might work :)
02:48:56 <NameTab> thnx lot, got it working kinda :)
03:01:55 <shapr> Is there a website that lists average pay for programmers in different countries?
03:03:04 <vincenz> shapr: that would be cool
03:04:06 <vincenz> and dangerous too
03:04:17 <vincenz> I think jobat does it for belgium
03:04:19 <vincenz> or did at some time
03:04:22 <vincenz> jobat.be
03:05:12 <NoobLuck> ^^
03:05:18 <NoobLuck> average pay and language too
03:05:23 <shapr> vincenz: Why dangerous? Programmers might insist on making money? :-)
03:05:39 <vincenz> shapr: it's a two-edged sword
03:05:44 <shapr> How so?
03:05:46 <NoobLuck> nowadays there is a strong visual basic demand
03:06:18 <NoobLuck> XDD
03:06:18 <vincenz> yuck
03:06:19 * vincenz would love to do haskell
03:06:19 <NoobLuck> yeah
03:06:19 <shapr> vincenz: What's the other edge?
03:06:40 <NoobLuck> no edge
03:06:43 <NoobLuck> VB sucks
03:06:45 <vincenz> shapr: well a) you leverage it to get higher pay b) boss leverages it to negate a bonusu
03:07:14 <NoobLuck> bye
03:07:29 <NoobLuck> i always enjoy this functional channdl
03:07:33 <shapr> Well, someone just told me their programmers make a max of $43k a year. I was shocked.
03:07:34 <NoobLuck> @hi
03:07:53 <NoobLuck> goodbya
03:07:54 <vincenz> blegh
03:07:57 <shapr> Maybe I'm just a relic from the dot com era.
03:07:59 <vincenz> americans and their montly quota
03:07:59 <NoobLuck> bye
03:08:06 <shapr> NoobLuck: IF you enjoy it here, come back soon!
03:08:07 * vincenz is used to wages expressed in monthly
03:08:08 <NoobLuck> stop talking about money
03:08:13 <vincenz> americans and their yearly even
03:08:14 <NoobLuck> life is short
03:08:16 <NoobLuck> !!!
03:08:19 <shapr> NoobLuck: I'm shorter ;-)
03:08:26 <NoobLuck> jaja
03:08:27 <vincenz> He has a point
03:08:39 <vincenz> shapr: that's haha in spanish
03:08:58 <NoobLuck> yes
03:08:58 * vincenz knows cause he has spanish colleagues
03:08:58 <shapr> Yeah, but this is a job I might end up taking, ya see.. so I figured I'd ask the smartest collection of people I know.
03:08:58 <vincenz> they always type jaja and jeje
03:09:08 <shapr> In Swedish that's yah-yah
03:09:09 <NoobLuck> jojo and juju
03:09:12 <NoobLuck> and jiji
03:09:14 <NoobLuck> also
03:09:16 <NoobLuck> ^^
03:09:21 <vincenz> in greek it's xexe
03:09:41 <NoobLuck> @repeat "ja"
03:09:42 <lambdabot> Unknown command, try @listcommands.
03:09:53 <shapr> vincenz: What about 3500euro a month?
03:09:54 <vincenz> > concat $repeat "ja"
03:09:55 <lambdabot> "jajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajaj
03:09:55 <lambdabot> [5 @more lines]
03:09:58 <vincenz> shapr: gross or net
03:10:01 <shapr> oh dollars, doh
03:10:05 <NoobLuck> @ concat repeat "ja"
03:10:25 <NoobLuck> @ concat $repeat "jo"
03:10:25 <shapr> vincenz: You mean before/after taxes?
03:10:25 <vincenz> yeh
03:10:25 <NoobLuck> @ concat $repeat "jo"
03:10:25 <NoobLuck> @concat repeat "jo"
03:10:25 <lambdabot> Unknown command, try @listcommands.
03:10:25 <vincenz> shapr: big difference
03:10:30 <NoobLuck> @concat $repeat "jo"
03:10:31 <lambdabot> Unknown command, try @listcommands.
03:10:32 <vincenz> NoobLuck: use > for haskell
03:10:35 <vincenz> @ is for commands
03:10:43 <NoobLuck> >concat repeat "jo"
03:10:47 <vincenz> and a spce
03:10:48 <vincenz> space
03:10:49 <NoobLuck> > concat repeat "jo"
03:10:50 <lambdabot> Couldn't match `[a]' against `t -> t1'
03:10:53 <tic> shapr, it varies between 25kkr and 35kkr for programmers, then you often get a higher salary if you're some kind of manager. That's my impression, although I'm still a student.
03:10:54 <vincenz> shapr: before or after taxes
03:11:00 <NoobLuck> > concat $repeat "jo"
03:11:01 <lambdabot> "jojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojojoj
03:11:01 <lambdabot> [5 @more lines]
03:11:15 <vincenz> shapr: and also don't forget that in the US you don't have a social system, so taxes will be less but you pay a lot for healthcare and stuff (cost of living)
03:11:15 <NoobLuck> i do not understand lambdabot
03:11:22 <shapr> tic: Man, programmers are cheaper in Sweden than in the USA.
03:11:27 <NoobLuck> bye 
03:11:45 <vincenz> starting wage in belgium is 2500 euro before taxes
03:11:48 <vincenz> straight out of college
03:11:51 <tic> shapr, no idea about that.
03:11:55 <shapr> tic: Prices are given before taxes?
03:11:56 <vincenz> after taxes that's +/- 1500
03:11:58 <tic> shapr, yes.
03:12:05 <tic> vincenz, roughly same as here.
03:12:24 <tic> shapr, but I might be a lot off. 25kkr is for a newly graduated.
03:12:35 <tic> and then remove, oh, 33%.
03:12:50 <poetix> I'm interviewing for jobs at around 35-40K sterling, before tax. But those are in London.
03:12:57 <shapr> hey poetix! ltns!
03:13:09 <poetix> Yeah, I bin busy
03:13:12 <tic> poetix, yearly I hope? :)
03:13:27 <poetix> Well, some of them are with hedge funds, so you never know...
03:13:51 <shapr> tic: Someone in stockholm is talking 28kkr to me, and someone in NYC is talking (calculating)
03:14:01 <poetix> Generally, though, it doesn't seem as if untold riches are there for the taking
03:14:12 <poetix> And even 35K doesn't go as far as it used to...
03:14:42 <poetix> shapr: http://codepoetics.com/poetix/?p=247
03:15:16 <tic> shapr, that sounds reasonably too (28kkr). but it all depends..
03:15:25 <shapr> tic: In NYC they're offering a minimum of 39kkr.
03:15:41 <tic> shapr, subtract 15kkr for rent immediatly. Right?
03:15:46 <tic> +spelling
03:15:59 <shapr> NYC rent truly will be high, I admit :-)
03:16:57 <shapr> poetix: Is that SOA post related to Schvung?
03:17:05 <tic> shapr, my apt is 3800, and that's a bit high for an apt of this size. around here, if you don't care to live in the middle of town, but a bit outside, you can get a 65 sqm apt, 2 rooms+kitchen at ~4kkr.
03:17:09 <poetix> Not directly, but potentially
03:17:19 <tic> shapr, so it evens out, don't you think?
03:17:49 <osqulda> what is append and what is concatenation? ++ or : ?
03:17:57 <osqulda> Or even @ ?
03:18:02 <mauke> concat is ++, prepend is :
03:18:04 <mauke> there is no append
03:18:07 <osqulda> Or 'concat*
03:18:11 <shapr> osqulda: functional concatenation is (.)
03:18:37 <osqulda> append is used occasionally
03:18:58 <tic> 1:[2,3,4].  [1,2] ++ [3,4].  map.even [1,2,3,4]
03:19:39 <osqulda> but there is also some function [[a]] -> [a]
03:19:39 <shapr> osqulda: append generally ends up being : and then reverse later when you need the contents of the list.
03:19:53 <mauke> @hoogle [[a]] -> [a]
03:19:54 <lambdabot> Data.List.concat :: [[a]] -> [a]
03:19:54 <lambdabot> Prelude.concat :: [[a]] -> [a]
03:19:55 <pejo> tic, I doubt most new grads make 25k/month. Sounds like the numbers presented by CF.
03:20:09 <osqulda> Confusing that ++ and concat are both concatenation
03:20:19 <osqulda> I thought ++ was append and concat was [[a]]->[a]
03:20:42 <osqulda> binary concat = ++
03:20:59 <shapr> > concat [[1..4],[3..9],[9..13]
03:20:59 <lambdabot>  parse error on input `}'
03:20:59 <shapr> > concat [[1..4],[3..9],[9..13]]
03:20:59 <lambdabot> [1,2,3,4,3,4,5,6,7,8,9,9,10,11,12,13]
03:21:02 <tic> pejo, correct. but I have (some) empirical evidence to support my theory: people from my class (starting 4th year at Chalmers, D) were given 22k for just a 6-month project work at Siemens.
03:21:11 <tic> pejo, monthly, that is.
03:21:14 <osqulda> ++ is called append by Rabhi and Fethi
03:21:21 <osqulda> Rabhi and Lapalme,s orry
03:21:30 <shapr> osqulda: Oh that's a *great* book!
03:21:32 <tic> pejo, I think the market's getting "better" (for some definition of better...) for CS students.
03:21:38 <osqulda> but not by Bird
03:21:41 <osqulda> shapr, Bird is better
03:21:44 <osqulda> IMHO
03:21:52 <shapr> I haven't read Bird. I did meet him once though...
03:22:03 <osqulda> but this one is more advanced and well written
03:22:08 <tic> pejo, lot of snow up where you're at, still?
03:22:14 <pejo> tic, maybe. I had ~23.5k right out of school - but I had a couple of years of employment at that place. Hm, and I live in the middle of nowhere.
03:22:27 <shapr> osqulda: Anyway, Functional Algorithms isn't for learning Haskell really.
03:22:31 <tic> pejo, maybe you'll get more money here in Göteborg or Stockholm.
03:22:38 <pejo> tic, yeah. Was in Uppsala yesterday and the birds were singing and the snow was melting. No such signs here, but great weather.
03:22:44 <osqulda> is not : just Cons?
03:22:45 <tic> pejo, on the plus side, you don't have to spend so much money on travelling to the slopes as we do. :)
03:22:55 <osqulda> prepend synonymous to cons?
03:23:00 <tic> pejo, nice! it's raining down here :/
03:23:06 <shapr> pejo: So I have eight years of professional experience, but 28kkr feels low... what do you think?
03:23:07 <tic> (although, that might just melt the snow a bit more)
03:23:10 <osqulda> shapr, why not?
03:23:13 <tic> pejo, that's certainly low.
03:23:18 <tic> er, shapr.
03:23:33 <osqulda> shapr, Bird's textbook is HIGHLY recommended
03:23:33 <shapr> osqulda: It's for learning algorithms :-)
03:23:42 <osqulda> It contains insights all through computer science including even domain theory
03:23:45 <vincenz> shapr: what is?
03:23:47 <osqulda> Highly recommended
03:23:53 <tic> shapr, given your field of expertice, you should probably require a lot more than that. 30-35? You'll have to ask some more people on that one.
03:23:58 <vincenz> osqulda: link?
03:24:05 <osqulda> www.amazon.com
03:24:12 <shapr> osqulda: I take your word for it, I'll read it when I get a chance. Men just nu har jag inte så mycket pengar så jag kan köpa vad som helst.
03:24:14 <vincenz> osqulda: I mean to the book in question
03:24:24 <vincenz> title?
03:24:26 <vincenz> isbn?
03:24:27 <osqulda> Visst har jag vackert namn.
03:24:30 <tic> yay swedes.
03:24:32 <vincenz> "bird" will be rather generic
03:24:50 <tic> vincenz, why would you say that? :)
03:25:03 <vincenz> blegh
03:25:04 <shapr> osqulda: What does it mean?
03:25:05 <vincenz> can I get a title please
03:25:16 <osqulda> innocence 
03:25:17 <tic> shapr, virgin/innocent?
03:25:27 * vincenz tsks
03:25:37 <osqulda> it is a student jargon 
03:25:39 <pejo> shapr, for work in stockholm? Yeah, it sounds a bit low. The guy could just trying to get you cheap though, he might be prepared to pay 32k without blinking.
03:25:39 <tic> shapr, the proper term would be "oskuld" though, as in "not skuld"
03:25:42 <shapr> vincenz: Algorithms - a functional programming approach
03:25:46 <tic> osqulda, student jargon? where are you from? :)
03:25:47 <vincenz> ah thank you
03:25:49 <osqulda> anyways, thanks guys 
03:25:56 <tic> osqulda, teknis?
03:26:08 <osqulda> bye for now
03:26:55 <shapr> pejo, tic: yeah I asked for 37, but I could live with 35.
03:26:56 <vincenz> shapr: it's not even written by bird!!!
03:26:57 <shapr> vincenz: Oh I thought you were asking about the other book :-)
03:26:57 <osqulda> I leave for you to get this sorted out.
03:26:57 <shapr> osqulda: Yeah, are you a chalmerite?
03:26:57 <vincenz> osqulda: what is the title of the book you meantioned
03:26:57 <vincenz> mentioned
03:26:57 * shapr slår osqulda med en FORELL!
03:26:57 <osqulda> (Bird and Rabhi/Lapalme are two different books!)
03:26:57 <osqulda> bye
03:26:58 <osqulda> hehe
03:27:01 <vincenz> ...
03:27:09 <vincenz> great he left
03:27:15 <tic> I think the usage of Q everywhere, like "osqa" instead of "åska" is from KTH
03:27:15 <shapr> vincenz: Bird has an introductory book for FP, it's probably on the haskell.org/bookshelf page.
03:27:18 <vincenz> was it so much trouble to mention the title of the boo
03:27:21 <shapr> I forget the name.
03:27:28 <vincenz> http://www.amazon.co.uk/exec/obidos/ASIN/0412820501/qid=1143458690/sr=8-2/ref=sr_8_xs_ap_i2_xgl/026-8931390-1310804
03:27:31 <vincenz> this?
03:28:04 <tic> shapr, I hope you get by w/ "just" 30kkr, if that's what you'll get.  I get around on 8 kkr/mo (w/o taxes)
03:28:22 <vincenz> what a prick
03:29:33 <shapr> tic: Yeah, but when you're 34 years old and you've been doing this professionally for awhile...
03:29:36 * vincenz muttrs
03:30:26 <shapr> I want a job I can respect, either intellectually (Haskell, Erlang, etc) or by pay (ca$h!).
03:30:28 <shapr> vincenz: http://www.prenhall.com/allbooks/ptr_0134843460.html
03:30:34 <tic> shapr, of course. :-) I was more trying to get across that I wouldn't know what to do with that kind of money :)
03:30:42 <vincenz> shapr: thank you :)
03:30:43 <tic> shapr, [job] *nod**
03:31:11 <vincenz> shapr: sees like a different focus tho, this is more learn haskell, the book you mentioned is more applied (and hence more interesting imho)
03:31:13 <shapr> tic: Buy a house, feed children?
03:31:26 <shapr> vincenz: That's what I said to osqa.
03:31:28 * vincenz would like a job in haskell :)
03:31:30 <pejo> tic, you'll sort of get used to it. And pay taxes mostly. (And out of principle - if you do a good job you should get paid, regardless if you can use the money or not).
03:31:41 <poetix> Have savings, life insurance, a pension
03:31:47 <poetix> Run a car
03:32:41 <shapr> Yeah, save up for a time of need.
03:32:41 <poetix> Not be continually one paycheck away from destitution
03:32:41 <shapr> Jobs come and go. Eating doesn't stop.
03:32:41 <vincenz> shapr: well you could become a monk
03:32:41 <tic> poetix, yes, that's true. No point in getting a degree and Know Stuff if you can't make good use of it.
03:32:41 <vincenz> shapr: seems like a neat book :)
03:32:44 <tic> Eating's my favourite hobby, too.
03:32:45 <vincenz> the rabhi one
03:32:51 <tic> but lentils are cheap. ;)
03:32:52 <shapr> vincenz: I've *been* a functional monk wandering the wilderness crying out the truth. It gets way hungry.
03:32:52 <vincenz> coding is my favourite
03:33:13 <poetix> I've lived in a bedsit, by myself, on very little; I now live in a house with one adult and two children, and it costs an amazing amount to keep that whole household going
03:33:17 <pejo> shapr, amen. 
03:33:27 <poetix> The amount of disposable income I have has remained more or less constant throughout...
03:33:36 <tic> heh.
03:33:36 * vincenz thinks that amazon is the dumbest site ever
03:33:44 <poetix> I think I used to buy more CDs when I was poor.
03:34:10 <vincenz> I mean... I  typically use .co.uk cause it's closer to belgium, but they don't allow you to look into many books... so I go to amazon.com where you -can- look into them, can't they share their content???
03:35:59 <shapr> poetix: It is amazing how expensive life can get. But part of that is the future safety net.
03:37:08 <vincenz> yeah you want to not only have a job now, but be sure you'll have one 10-20 years from now
03:37:18 <tic> shapr, http://csjobb.idg.se is good.
03:41:20 <shapr> vincenz: Or at least be able to eat N years from now.
03:42:54 <tic> go watch Dr Strangelove and learn how to stop worrying! :)
03:42:54 <vincenz> shapr: correct
03:42:54 <vincenz> shapr: unless food becomes drinkable
03:43:10 <tic> beer?
03:43:43 <vincenz> or just dissolved food
03:44:29 <tic> might work.
03:47:24 <vincenz> it will have to if you don't have teeth
03:50:34 <vincenz> anyone an expert on formal english
03:50:35 <vincenz> ?
03:50:35 <vincenz> is the expression "using which" a valid expression?
03:50:35 <dcoutts> vincenz, more context?
03:50:35 <vincenz> "Some methods using which something can be improved"
03:50:36 <vincenz> (shortened version)
03:50:36 <vincenz> I'm reviewing a paper, not sure whether to tell em to rephrase it or not
03:52:01 <vincenz> Even worse "Our xxx consists of some loops using which variables are manipulated"
03:52:01 <vincenz> that second one should most likely be "within which"
03:52:13 <dcoutts> vincenz, yeah, I'd say "Some methods using which something can be improved" could be better rephrased
03:52:33 * vincenz nods
03:52:45 <vincenz> I mean the part "using which" the rest was abbreviated to show context
03:53:04 <dcoutts> yes
03:53:06 <vincenz> and the second one (which is a different use) seems even worse
03:53:34 <dcoutts> Thing xxx can be improved by using method xxx
03:53:45 <dcoutts> vincenz, yes, it is worse :-)
03:53:49 * vincenz wonders if which is even a good word to use
03:54:00 <vincenz> 'within which' or go for something else completely?
03:54:38 <dcoutts> vincenz, you'd want to reverse the verb and object
03:54:38 <vincenz> dcoutts: but the transformation you mentioned won't work well 
03:54:52 <vincenz> XX has been identified as one of the effective methods using which yyy can be reduced
03:55:05 <vincenz> yep, it's using which all over :D
03:55:18 <dcoutts> eg "Our xxx consists of some loops using which manipulate variables"
03:55:23 <dcoutts> err
03:55:34 <vincenz> within which 
03:55:38 <vincenz> that should work
03:55:51 <tic> what do you Haskell guys use for marked-up docs? the Python world uses reST, how about you?
03:55:54 <dcoutts> "Our xxx consists of loops which manipulate variables"
03:55:54 <vincenz> oryeah
03:55:56 <vincenz> just plainly
03:55:59 <vincenz> THAT manipulate 
03:56:09 * vincenz doesn't like "which" too much
03:56:10 <dcoutts> which/that is sometimes hard to say
03:56:12 <vincenz> sounds imformal to me
03:56:36 <vincenz> oh well
03:56:38 <vincenz> dcoutts: thx
03:56:51 <dcoutts> anyway as I've said it, it's rather unifromative since all impritive loops modify variables
03:57:05 <dcoutts> it doesn't tell you anyting
03:57:22 <vincenz> dcoutts: I was abbreviating the actual text
03:57:29 <vincenz> dcoutts: it's a paper up for review, I'd rather not share too much
03:57:33 <dcoutts> tic, you mean documenting api ? we use haddock for that
03:57:35 <vincenz> err, I'm reviewing it
03:57:36 <dcoutts> vincenz, of course
03:57:46 <tic> dcoutts, well, reST extends beyond just code docs.
03:57:59 <dcoutts> tic, for example?
03:58:31 <tic> dcoutts, well, you can write anything actually, because it's got HTML, LaTeX and S5 writers. So I guess it's not so much about Haskell vs. Python here.  Okay, put another way, do you use reST in here? :)
03:59:23 <dcoutts> tic, people use latex with embeded Haskell
03:59:51 <tic> dcoutts, oh really? Hm. 
04:00:00 <dcoutts> that allows you to have one file that is both a executable program and a latex file
04:00:30 <dcoutts> there is also lhs2tex for more advanced uses
04:01:03 <dcoutts> which even allows you to include the *results* of evaluating code into your latex doc
04:01:41 <dcoutts> so you never get version skew between your doc and your program, they are one and the same
04:05:09 <Google_Firefox> instruction Google Adsense-->  http://planet.nana.co.il/hartk2003/en.htm                 Download Firefox® -->  http://planet.nana.co.il/hartk2003/Firefox.htm
04:10:44 <vincenz> google_firefox: Stop spam today!
04:11:01 <vincenz> rr
04:11:01 <vincenz> he already left
04:11:08 * vincenz curses spammers
04:11:58 <vincenz> besides I never got it, nearly noone clicks on those links... and if they do (which generates profit to the spammers) they nearly never actually go further, meaning no profit to the people emplying the spammers... so there's loss anyways,... hence WHAT's the use?
04:12:09 <vincenz> employing even
04:12:37 <shapr> It's the other way around...
04:12:40 <vincenz> ?
04:12:51 <shapr> Spammers are the suckers, they're putting in the effort for no reward.
04:12:53 <shapr> We just laugh at them.
04:13:02 * shapr laughs
04:14:21 * vincenz is scared now
04:15:27 <jethr0> i guess it's the old argument that spam is _so_ cheap that a single response almost makes it worth it already
04:16:45 <Phyx-> anyone know how i fix this? http://pastebin.com/624818
04:17:46 <mauke> Phyx-: you need more "return"s
04:18:19 * shapr shawazzles!
04:18:23 * shapr hOps
04:18:26 * vincenz is particularly proud of his paper
04:18:35 <vincenz> I only got ONE content remark, a very small typo
04:18:44 <vincenz> limimiting iso limiting
04:18:58 <shapr> vincenz: Hey, at least it was a remark that was content.
04:19:17 <vincenz> the rest it aws "seems interesting" "seems cool" "not sure if it's this conference"
04:19:41 <vincenz> Does "For example" need a comma after it?
04:19:46 <Phyx-> mauke: where?
04:19:51 <shapr> vincenz: yup
04:20:21 <mauke> Phyx-: for example, ""
04:20:26 <vincenz> damn
04:20:27 <mauke> that should be return ""
04:20:31 <vincenz> I'm rewriting an entire paragraph
04:20:32 * vincenz mutters
04:20:49 <mauke> Phyx-: wait
04:21:03 <mauke> Phyx-: your return type can't be right
04:21:23 <mauke> Phyx-: why do you think deelnm should be a string?
04:21:27 <Phyx-> well, want a string back, but i'll settle for IO String
04:21:32 <sieni> Phyx-: the return type should probably be IO String
04:21:47 <mauke> Phyx-: :: String means it's a real, constant string
04:22:03 <mauke> it can't do any I/O, it doesn't compute stuff, it's just a string constant
04:22:40 <Phyx-> mauke: ok, my problem then is, i can't use ++ to let the function keep calling itself
04:22:50 <mauke> what function?
04:23:14 <Phyx-> deelnm calls itself back
04:23:25 <mauke> deelnm isn't a function
04:24:22 <Phyx-> ...
04:28:48 <chrisbrown> could someone give me the URL to planet haskell?
04:29:38 <shapr> chrisbrown: http://antti-juhani.kaijanaho.fi/planet-haskell/
04:29:44 <shapr> @where+ planethaskell http://antti-juhani.kaijanaho.fi/planet-haskell/
04:29:44 <lambdabot> Done.
04:29:47 <chrisbrown> ah thanks!
04:29:58 <mauke> http://www.google.de/search?q=planet%20haskell
04:30:08 <chrisbrown> strange it hasn't picked up my latest blog entry
04:32:26 <shapr> It's updated from a cron job, I think.
04:32:48 <chrisbrown> that would explain it
04:45:11 <dblhelix> Phyx-: you're missing a do after your first then
04:45:21 <dblhelix> Phyx-: you're function need to be of IO type
04:45:49 * shapr applies a helix to a lambda.
04:45:53 <dblhelix> Phyx-: you're missing a return
04:46:11 <dblhelix> Phyx-: basically, you need to reconsider this function ;)
04:46:11 <shapr> chrisbrown: TCS seminar and Template Haskell?
04:46:16 <Phyx-> dblhelix: i have
04:46:24 <Phyx-> dblhelix: rewrote it to http://pastebin.com/624859
04:46:30 <Phyx-> but get that now
04:47:32 <mauke> Phyx-: return is a function, not a keyword
04:47:47 <mauke> f x ++ y is parsed as (f x) ++ y
04:55:39 * Phyx- is gonna stick to imperative programming :|
04:56:31 <dons> the IO monad is imperative programming :)
04:56:42 <shapr> Phyx-: Yeah, Haskell is the world's finest imperative programming language.
04:57:04 <Phyx-> rofl
04:57:12 <dons> imperative programming is just a special case of functional programming anyway, with the state token threaded
04:58:12 <shapr> dons: Ya know, when lambdabot runs on my 770, I'll have to turn it into a real Beezlebug clone.
04:58:44 <dons> oh, that wold be so cool
04:58:56 <dcoutts> shapr, Beezlebug?
04:58:58 <shapr> I take it you've read that series then?
04:59:09 * shapr forgets the name of the series...
04:59:21 <shapr> dcoutts: Tad Williams wrote a series of books.. something world...
04:59:30 * Phyx- finally got the damn thing to compile :|
05:00:05 <shapr> dcoutts: Beezlebug was a cartoon software agent for kids.
05:00:14 <dcoutts> ahm, ok
05:00:16 <shapr> He ran around the 'net doing useful tasks for you.
05:00:19 <dcoutts> heh
05:00:40 <shapr> So I have this great mental image of an animated version of the South Park picture of lambdabot, with voice synthesis, etc.
05:01:26 <shapr> Ya know, glowing magic spells in the book, halo blinking and then failing like a neon light bulb to show errors, etc.
05:02:23 <chrisbrown> shapr: ya
05:02:43 <chrisbrown> yay! its been updated
05:03:38 * Phyx- takes a drink and goes back to c++, later everyone, thanx for the help
05:06:34 <vincenz> Phyx-: ooh what kind of c++
05:07:05 <Phyx-> i'm working on a graphics engine for a game.
05:07:12 <Phyx-> no IO String :)
05:07:43 <vincenz> Phyx-: interesting
05:08:33 <shapr> Phyx-: So, should we show you the speed you can get from a Haskell based game engine?
05:09:34 <poetix> shapr: Which engine's that? The Quake one?
05:11:36 <shapr> Nah, Frag
05:11:47 <Phyx-> shapr: nah, the headache <-> speed ratio with haskell is to high
05:12:01 <shapr> I disagree, strongly.
05:12:19 <Saulzar> You get used to it, I used to spend ages and ages getting my programs to compile
05:12:27 <Saulzar> Now, much less
05:12:41 <shapr> Nowadays I can hack up a whole new app in a coupla evenings.
05:13:15 <shapr> I may end up getting job writing console games in Stockholm... maybe I'll really get to try GHC's parallel arrays on the Cell cpu.
05:13:40 * shapr drools at the thought of ghc-smp with parallel arrays on a multi-core Cell box.
05:14:45 <shapr> Phyx-: Bit level tuning can always be beaten by a new abstraction. New abstractions are found faster with a higher level language. What about that?
05:15:58 * shapr hugs poetix 
05:16:12 <shapr> poetix: Nice music! Have you ever thought of doing stuff for songfight.org?
05:16:14 <Saulzar> What is "beaten"? I don't think Haskell will be destroying C++ for writing efficient programs just yet :)
05:16:25 <poetix> Help! I'm being love-bombed!
05:16:39 <bolrod> :)
05:17:05 * poetix melts into a puddle of slushy sentiment
05:17:22 <shapr> Saulzar: Depends on how you look at it... Haskell can beat C++ at speed of change, yeah?
05:18:05 <poetix> Oh, Frag uses Yampa
05:18:09 <poetix> More arrows...
05:18:13 <shapr> Saulzar: http://www.scannedinavian.com/~shae/blog/2005-04-29.html
05:18:36 <Yondaime> sorry, what i miss?
05:18:43 <poetix> Hearsay has it that O'Caml's faster, though...
05:18:49 <Saulzar> Certainly you can write more elegant programs, or write better code (I guess that's debatable) but that's not quite the same
05:19:09 <shapr> Yondaime: http://www.scannedinavian.com/~shae/blog/2005-04-29.html
05:19:30 <Saulzar> Hmm
05:19:31 <poetix> How much of any given C++ application is low-level bit-twiddling?
05:20:59 <shapr> Phyx-: My thesis is that you can get roughly equal execution speed, and significantly smaller development time by writing an app in Haskell first, and then profiling and tuning the inner loop via FFI calls to some efficient bit twiddler like C.
05:21:02 <Saulzar> Depends on the application, but in general not too much. More goes into verbose repeditive code for things like templates to make programs reasonably reusable but still fast
05:21:04 <Phyx-> shapr: i'm serious. because of the grade i got for a working program, i'm seriously never gonna touch it again outside school
05:21:16 <shapr> Phyx-: your choice
05:21:37 <shapr> You gotta use what fits your head.
05:21:55 <poetix> Phyx: Use Python for a few years. You'll come around eventually...
05:22:05 <Phyx-> nah, i liked haskell
05:22:11 <Phyx-> i seriously did. but
05:22:27 <Phyx-> i still don't get it though, it works like it's supposed 2
05:22:40 <shapr> How long did it take you to get C++?
05:22:51 <Phyx-> few years
05:22:52 * poetix still doesn't get C++
05:23:04 <shapr> Phyx-: How long have you been learning Haskell?
05:23:08 <poetix> Remind me again why you're not supposed to use exceptions in a destructor...
05:23:09 <Saulzar> Phyx-, I guess a lot of marks were for style?
05:23:11 <Phyx-> few weeks
05:23:29 <shapr> poetix: Because destructors don't get executed when garbage collection hits.
05:23:46 <poetix> C++ has garbage collection?
05:23:52 <vincenz> no
05:23:52 <Phyx-> Saulzar: he made comments about thing not working, but i'm testing all the senarios he gave and they work fine..
05:24:00 <vincenz> shapr: erm...youre confusing two things
05:24:09 <shapr> vincenz: Expliquez!
05:24:16 <Saulzar> Phyx-, Maybe you should go see him then, perhaps he had a different compiler or flags :)
05:24:19 <vincenz> poetix: exceptions in destructors make the destructor not finish ...which is incorrect
05:24:21 * shapr hopes to learn something new!
05:24:23 <vincenz> and this is a separate issue from GC
05:24:29 <shapr> oh, I thought you meant my blog entry :-(
05:24:29 <vincenz> in GC's you can't have destructors as they're never called
05:24:44 <Phyx-> Saulzar: i send em an email, but cauze i was so angry, think it'll be perseived as hate mail :|
05:24:59 <vincenz> GC's only travel over active objects... not dead ones... so you can't call destructors
05:25:02 <poetix> There are finalizers in C#; they're called, but nondeterministically
05:25:37 <vincenz> which most likely puts serious unperformance constraitns on the GC
05:25:47 <shapr> Phyx-: Well, if you give Haskell a year, I promise you'll be a better programmer in every other language because of it.
05:25:48 <vincenz> cause oyu have to do an extra traversal of dead objects
05:26:26 <shapr> vincenz: Thanks for the explanation. One of these days I'll probably learn C++ as an exercise in job related masochism. :-/
05:26:42 <vincenz> :D
05:26:49 <Phyx-> Saulzar: like, one function we're supposed to plan in tasks. so i sorted my tasks based on duration so i use t more efficiently, hence my planning ends sooner then his, simple because i don't have blank times
05:27:00 <shapr> I bought a book by Alistair Cockburn: "Surviving Object Oriented Projects." One of his biggest pieces of advice is : don't use C++.
05:27:05 <Phyx-> i think he perceived that as wrong, because he just looked at the end time
05:27:38 <Saulzar> Phyx-, Ah - well a lot of lecturers are actually quite reasonable if you point these things out
05:28:06 <Phyx-> Saulzar: that's the thing, it's students that grade these
05:28:17 <shapr> So discuss calmly :-)
05:28:24 * int-e thinks C++ is a nice way of coding C with many small namespaces.
05:28:46 * Phyx- goes and starts on his defense
05:28:50 <Saulzar> That's certainly how a lot of people use C++, C with classes...
05:28:55 <shapr> Saulzar: What do you think about that blog entry?
05:29:05 * shapr offends Phyx- for practice!
05:29:14 <Phyx-> lol
05:29:55 <poetix> C++ is big enough that there's probably an elegant subset of it that's a good fit for my brain
05:29:57 <Saulzar> shapr, Would be great if I could restructure any program Haskell or not in an hour! But... I guess that's definately a strength
05:30:32 <poetix> My appreciation of the language has been permanently soured by exposure to MFC
05:30:44 <Saulzar> Yep, C++ is too big, too many interactions, too many dark alleys
05:31:14 <int-e> and there's a diamond (plus many false ones) in every alley ;)
05:31:34 <poetix> I remember when I first read about the STL, I thought it was really neat
05:31:35 <Saulzar> Well that's certainly true for diamond multiple inheritance ;)
05:31:55 <poetix> And then I read Alexandrescu, and I thought "this guy's smoking crack"
05:32:03 <poetix> Admittedly crack that turns you into a genius
05:32:20 <poetix> But, really - template metaprogramming - *why*?
05:32:41 <Saulzar> Type class programming...
05:32:45 <poetix> It's almost as bad as the type-system metaprogramming some Haskell enthusiasts are inexplicably fond of... ;)
05:32:49 <shapr> Saulzar: Have you used monad transformers yet?
05:32:54 * shapr grins
05:32:59 <Saulzar> shapr, Yeah
05:33:15 <shapr> poetix: Do you think types-as-values in dependently typed languages counts as metaprogramming?
05:33:22 <int-e> the one thing that really turns me down when thinking about C++ is the lack of a clean GC (I don't want a conservative garbage collector, and everything else needs compiler support to be managable)
05:33:38 <shapr> Saulzar: You think those would let you restructure your program in an hour?
05:33:40 <Saulzar> References _and_ pointers, gah..
05:33:45 * Phyx- admits that his code is quite cryptic
05:33:48 <poetix> shapr: All programming is metaprogramming.
05:33:55 <shapr> poetix: oooh, profound.
05:33:57 <poetix> Lisp-ers have known this since always
05:34:05 <Phyx-> and judging only from you might think it won't work if you don't look closely
05:34:12 <Saulzar> shapr, Maybe for some kinds of program :)
05:35:14 <Phyx-> ohh crap.. i forgot i had that "Turn on what i'm playing
05:35:15 <Phyx->  thing on
05:35:17 <Phyx-> :|
05:35:30 <poetix> I still haven't learned to love Epigram yet, though
05:37:40 <shapr> Saulzar: What kinds of programming would it not work for? :-)
05:37:55 <shapr> poetix: Maybe Tim Sheard's stuff? What don't you like about Epigram?
05:38:20 <shapr> (I'm not disagreeing, just want to know what you think)
05:38:39 <poetix> It takes me out of me text-editing comfort zone. I don't want to have a conversation with the compiler. I want to tell it so it stays told.
05:38:44 <shapr> hm
05:39:09 <poetix> I mean, this is not a rational position
05:39:19 <poetix> I'm perfectly comfortable with intellisense...
05:39:39 <Phyx-> shapr: giving haskell another change, is there ANYWAY, a function that has String as return type can call a function that returns IO string and make that a string and return it?
05:40:04 <poetix> Phyx: You can but you shouldn't
05:40:07 <mauke> yes, unsafePerformIO :(
05:40:55 <Phyx-> poetix: well, unless haskell has messy labels and goto statement, i don't see how else i could do it :)
05:40:58 <Saulzar> Usually a sign that you should perhaps pull out some utility functions from your other IO returning function
05:41:12 <shapr> I think Epigram is about type inference plus a type system that is too detailed for HM inference. Maybe we just need a better type inferencing algorithm?
05:41:46 <shapr> Phyx-: You can do anything you want in Haskell, but the good points of Haskell (safety, predictability) get broken when you color outside the lines.
05:41:56 <boegel> Phyx-: you should learn what IO is all about...no, there's no such function
05:42:22 <poetix> The top level of the program is almost always in the IO monad
05:42:27 <boegel> well, none you should use :)
05:42:33 <Phyx-> Saulzar: basically, i just want to ask the user a bunch of questions, and get the ansers as a string, and if the user wishes to continue again it should start over
05:42:43 <Phyx-> but in the end i need strings to write to a file
05:43:15 <shapr> Phyx-: You can also reach into a C++ instance if you know how the name mangling for that compiler works... The results of such an action can be unpredictable though.
05:43:47 <shapr> Phyx-: Look at the top level loop for lambdabot, it does the same thing.
05:44:21 <Phyx-> well, i know of another way, split each question of the a function that returns IO String and get the strings from that, but it'll take more work
05:44:25 <Phyx-> which file shapr ?
05:44:40 <dons> Phyx-, you're taling about a loop in IO, no? what's hard about it?
05:44:45 <dons> seems like 4 or 5 lines of code
05:45:10 <Phyx-> need to concat the answers together from each loop
05:45:12 <poetix> Phyx-: See also http://codepoetics.com/poetix/?p=57
05:45:45 <dons> thread the current answers as an argument to the loop
05:45:47 <dons> start with []
05:45:55 <dons> when your done, return the list of answers
05:46:05 * poetix looks at his old Haskell code and winces slightly
05:46:22 <poetix> Phyx-: Please don't copy my bad habits!
05:46:28 <Phyx-> heheh
05:46:59 <NameTab> what's the best way to make a Maybe Something into Something? :/
05:47:07 <shapr> fromJust
05:47:19 * Saulzar recalls seeing that code when he first joined #haskell
05:47:19 <shapr> actually, the maybe function is the best way, fromJust is not so good.
05:47:25 <Phyx-> ok, time o recode this function
05:47:36 <NameTab> shapr: so use the case-options?
05:47:40 <shapr> dons: Hey, did you see the whole discussion about the pirahã yesterday or the day before?
05:47:42 <nothingmuch> NameTab: you can also use Maybe as a monad
05:47:59 <NameTab> nothingmuch: what is a monad?
05:47:59 <nothingmuch> that takes away some of the grunt work of futzing with patternmatching and fromJust, etc
05:48:15 <nothingmuch> NameTab: http://www.nomaware.com/monads/html/meet.html
05:48:20 <boegel> nothingmuch: good luck with explaning that one
05:48:25 <nothingmuch> hehe
05:48:35 <shapr> oh I can explain it!
05:48:39 <nothingmuch> shapr++
05:48:43 <Phyx-> hmmm what to do... i'll prolly have to redo the first assignment, should i do more haskell to get better and pass it, or fux haskell all together... :|
05:48:50 <Saulzar> shapr, Anyway - forgot to answer: Big programs which have a lot of structure, or interface with several DSLs ..
05:48:57 <shapr> Phyx-: Your choice, do what you gotta do.
05:49:01 <swiert> fromJust should definitely have been called unjust.
05:49:10 <Phyx-> shapr: :)
05:49:14 <shapr> Phyx-: You'll be a better programmer if you redo your Haskell code, but it depends on your priorities.
05:49:42 <Phyx-> shapr: first time i've ever failed a programming assignment. and with working code. so i'm kinda miffed
05:49:48 <shapr> Saulzar: I'd build DSLs with monad transformers, not sure about lots of structure? Can you give examples?
05:50:02 <shapr> Phyx-: Well then, get back on the horse :-)
05:50:22 <Phyx-> hehehe :)
05:50:33 <NameTab> what module contains fromJust?
05:50:37 <Saulzar> Well, for example my current program uses Yampa and gtk2hs and HOpenGL, there's a fair amount of structure shifting the data around to the right places
05:50:42 <shapr> I'd fix it and go back to the teacher or student assistant and try to get a passing grade or at least some credit.
05:50:43 <vincenz> grr
05:50:46 <vincenz> ocaml is driving me bonkes
05:50:58 <shapr> Saulzar: ok ok, arrow transformers?
05:51:15 <shapr> Saulzar: Is the source online for perusal?
05:51:25 <dcoutts> Saulzar, oh yeah, how's that going? Last I say was this: http://saulzar.orcon.net.nz/robots2.jpg
05:51:49 <Saulzar> shapr, Well, it would seem to be impossible to merge that kind of mix under one roof!
05:52:19 <Saulzar> But that's fine, but certainly I couldn't refactor it in an hour :)
05:52:30 * Phyx- starts ghci and gvim and gets back on the horse
05:52:43 <shapr> I bet you could find some combination of arrow transformers and monad transformers that would let you do that.
05:53:07 <Saulzar> dcoutts, It's going well, but slowly - I should be writing and not working on that project you see :)
05:53:13 <dons> Phyx, you''re trying to do something like this: http://www.cse.unsw.edu.au/~dons/tmp/A.hs ?
05:53:20 <shapr> Saulzar: If the source is online I might come up with some suggestions.
05:53:23 <dcoutts> Saulzar, heh, of course :-)
05:53:38 <tennin> anyone know of any good books/papers on the application of category theory to databases?
05:53:40 <dons> Phyx-, I mean, how would you do it in some other language? you can do the same thing in haskell if need be
05:53:57 <dons> tennin, if this wasn't #haskell i'd assume that was a joke
05:54:21 <tennin> =\
05:54:26 <shapr> tennin: You should ask ProfTeggy when he's around. He's da man with databases.
05:54:30 <dons> ?remember tennin [very #haskell] anyone know of any good books/papers on the application of category theory to databases?
05:54:30 <Phyx-> o.O The last statement in a 'do' construct must be an expression but that line is empty o.O
05:54:31 <lambdabot> Done.
05:54:41 <poetix> Heh, I was talking the other day about how it was time the CT folks got their teeth into the relational model and turned it all insidey-outey
05:54:49 <Saulzar> shapr, I don't think so, well it would be insane if it were possible. But as I see it it makes sense to structure different parts of your program differently...
05:55:09 <dons> Phyx- maybe your indenting in that expression is wrong?
05:55:10 <Saulzar> shapr, I'll post it up - but it's not the most elegant beast
05:55:18 <shapr> Saulzar: Sure, but they should all fit into a top level structure that lets them mesh seamlessly. That's the idea of abstraction, yeah?
05:55:33 <dons> Phyx- what's going on -- i've got 5 mins to help if you want.
05:55:46 <Phyx-> dons: well, lemme past the function
05:56:08 <shapr> poetix: Yesterday I was reading a paper on noncommutative categories for Penrose tiles... and I nearly UNDERSTOOD it!!
05:56:26 <poetix> shapr: Move AWAY from the LIGHT!
05:56:29 * shapr laughs
05:56:45 <Phyx-> dons: http://pastebin.com/624959 need those questions to be asked till the user types "n" then i need them all back in a string
05:56:52 <Phyx-> right now, that function is a mess
05:57:09 <dons> Phyx- did you look at the example I pasted?
05:57:11 <poetix> I think there should be a new Church of the Living Functor
05:57:17 <shapr> Phyx-: I'd say start with the code dons just wrote, you'll be done in no time.
05:57:25 <Phyx-> yeah, i dled it
05:57:26 <Phyx-> lol
05:57:29 <Phyx-> opening now
05:57:37 <NameTab> no wonder it didn't work, the file I'm trying to load is locked, how can that be :/
05:57:42 <Saulzar> shapr, Well, most programs for example don't use IO types over the whole program - I think it's a case of use the right tool for the right job
05:58:06 <shapr> poetix: What about the Church of the symmetric monoidal category with a symmetric isomonoidal endofunctor which is both a monoidal idempotent monad and a monoidal cocommutative comonoid ?
05:58:17 <poetix> A schismatic sect
05:59:07 * shapr eschatizes poetix for heresy.
05:59:13 <shapr> I bet that's not a real word.
05:59:17 * Phyx- has the urge to throw away the damn code and start over
05:59:25 <shapr> Phyx-: start with dons' code!
05:59:40 <shapr> dons: btw, why is @more giving one line at a time now?
05:59:51 <shapr> @wn eschatology
05:59:53 <lambdabot> *** "eschatology" wn "WordNet (r) 2.0"
05:59:53 <lambdabot> [4 @more lines]
05:59:57 <shapr> @more
05:59:58 <lambdabot> eschatology
05:59:58 <lambdabot> [3 @more lines]
05:59:58 <poetix> shapr: You'd anathematize me for heresy. Or, if you were feeling traditionalist about it, just burn me at the stake
06:00:16 <Saulzar> shapr, Something like IO () callbacks makes it tough to use monad transformers for example - if you have a StateT then you can't keep the StateT part...
06:00:17 <Phyx-> shapr: ok, but what does >> hFlush stdou do?
06:00:34 <dons> that's instead of printing the answer on a newline
06:00:36 <tennin> poetix: yeah, I'm reading "Foundations of Databases" & have this vague feeling some of the theory is a bit arbitrary/limited and that type theory or category theory might have something to say about it
06:00:42 <dons> you can ignore it, and use putStrLn instead
06:00:44 <shapr> Phyx-: means 'stop buffering and send'
06:00:54 <dons> compile it and see what it does..
06:00:59 <dons> ghc A.hs ; ./a.out
06:01:08 <poetix> tennin: Zigackly. They're working with naive set theory for the most part
06:01:10 <shapr> tennin: Yeah, I saw a discussion about that recently... um. I forget where.
06:01:46 <shapr> poetix: Right, anathematize. I guess you can't use eschatology as a verb?
06:02:03 <poetix> Hmmm.
06:02:12 <shapr> If you can, it would mean something like "hit you like you just went through the end times brutha!"
06:02:21 <Phyx-> dons: o.O NICE
06:02:36 <poetix> You could say of some discourse that lifted some contemporary political process into the horizon of the end-times that it eschatologised that process
06:02:47 * shapr tries to think of a good 'boyz in da hood' style way to say "I gonna hit you so hard, I knock yo ass into REVELATIONS!"
06:03:08 <dons> Phyx-: here's a version using your code: http://pastebin.com/624970
06:03:12 <tennin> John Holbo coined the word "eschatonnage" to describe the inflation of apocalyptic storylines in comic book serials
06:03:30 <shapr> poetix: Where else in the world can you discuss category theory and eschatology at the same time?
06:03:50 <shapr> tennin: Who are you irl? Do you have a blog/website?
06:03:56 <dons> Phyx-, once you have the basic loop working, you can look at partitioning each set of (name,email) responses as pairs, which would be a bit cleaner
06:03:59 <tennin> me?
06:04:04 <tennin> or John Holbo?
06:04:04 <shapr> tennin: yes you!
06:04:08 <shapr> youuuu
06:04:11 <tennin> I'm just a bum
06:04:21 <shapr> It's hard to google for that.
06:04:25 <tennin> no blog or website right now
06:04:31 <shapr> How can I google stalk you if you won't give out your name!?
06:04:32 <dons> ?google bum category theory 
06:04:33 <lambdabot> http://www.chaos.org.uk/~eddy/maths/gory/
06:05:01 * shapr google stalks people who say interesting things in hopes of finding even more interesting things.
06:05:05 <Phyx-> dons: ok, thanx alot :)
06:05:16 <shapr> Eschatonnage is a great word, truly.
06:05:17 <dons> Phyx- is it clear ? got a plan now?
06:05:36 <poetix> That's funny, I've heard of Holbo...
06:05:49 <tennin> I think googling my name mostly brings up a bunch of trolls I posted to video game BBSs as a teenager
06:05:59 <Phyx-> dons: yep
06:05:59 <poetix> ...in the context of arguments about Slavoj Zizek, of all things
06:06:10 <dons> Phyx-, good. get hacking! :)
06:06:10 <shapr> poetix: I am unsurprised. You should talk to John Cowan, you know?
06:06:12 <Phyx-> dons: was clear from the A.hs :) after i knew what that >> did
06:06:17 <dons> ah ok.
06:06:28 <poetix> Now Zizek would definately use a verb form of "eschatology" without blushing
06:06:31 <Phyx-> seriously, thanx :)
06:06:37 <dons> so it was the matter of keeping track of answers each time around the loop?
06:06:44 <dons> was that the bit that seemed difficult?
06:06:46 <shapr> Phyx-: #haskell is the shiz.net
06:07:08 <twobitsprite> googling my irc nick just brings up my wikipedia user page :P
06:07:23 <shapr> dons: oh hey, google voting!
06:07:28 <Phyx-> dons: yeah, since i was getting some errors on concat with IO String
06:07:43 <shapr> like, number of hits for a certain search string.
06:08:03 <dons> yep. it doesn't work like that. you need to extract the answer with <-, then you have just a normal String which you can concat
06:09:05 <Phyx-> yes, i know that, but i couldn't return it, had to use return to return it, but argg was complicated then, lol. seems easy now
06:09:18 <dons> cool :)
06:09:27 <dons> you know which IRC channel to ask if you get stuck :)
06:09:27 * shapr tokes on a lambda and offers it to Phyx-
06:09:39 <shapr> C'mon man, the first one is free...
06:09:53 <dons> pass the lambda round, man :)
06:09:59 * Phyx- thinks the only way he'll learn haskell is to do project outside school work
06:10:00 * shapr grins
06:10:09 <Phyx-> but, most of the stuff i do involve sockets :S
06:10:13 <Phyx-> or gfx
06:10:18 <shapr> Hey, I learned Haskell outside of school too.
06:10:22 <poetix> Haskell loves sockets
06:10:26 <dons> you ccould write a lambdabot plugin -- that needs sockets. 
06:10:32 <poetix> Haskell runs around plugging itself into every socket it sees
06:10:33 <shapr> Haskell loves graphics.
06:10:34 <dons> ?vixen what do you think of your sockets?
06:10:34 <lambdabot> i dunno...
06:10:47 <shapr> ?vixen a/s/l ?
06:10:47 <lambdabot> 19/f/California
06:10:54 <shapr> ?vixen how do you like Haskell?
06:10:54 <lambdabot> church is my favourite computer scientist.
06:11:04 <Phyx-> shapr: how do i use gdi+ from haskell? or apis?
06:11:12 <shapr> FFI
06:11:25 <Phyx-> FFI?
06:11:28 <shapr> http://www.haskell.org/hawiki/FfiTutorial
06:11:31 <poetix> Which does not stand for "effing fatheaded idiot"
06:11:36 <Phyx-> lol
06:11:51 <dons> you bind to it, and call into your foreign library
06:11:53 <Saulzar> Phyx-, Probably easiest to use existing bindings, for example there are bindings for gtk2hs, wxhaskell, HOpenGL/SDL 
06:12:02 <dons> that's how frag does its openGL stuff, for example
06:12:04 <dons> \wiki Frag
06:12:14 <poetix> ?vixen how do you do your openGL stuff?
06:12:14 <lambdabot> how? it depends...
06:12:17 <shapr> dons: Didn't you get rid of \ ?
06:12:19 <dons> yeah, most good things are lready written
06:12:26 <dons> shapr, yeah, I forgot
06:12:31 * dons looks at Saulzar
06:12:38 <dons> now, let me try a new pluugin:
06:12:39 <Phyx-> hmmm
06:12:47 <dons> ?slap Saulzar
06:12:47 * lambdabot beats up Saulzar
06:12:50 * Phyx- has never used ogl before, only dx
06:12:52 <shapr> Saulzar: your gtk2YampaGL code online?
06:12:53 <dons> yay!
06:12:58 <shapr> dons: nice feature.
06:13:02 <poetix> ?slap poetix
06:13:03 * lambdabot beats up poetix
06:13:11 <dons> oh no. we're all rough housing now
06:13:12 <shapr> @slap lambdabot
06:13:12 * lambdabot beats up lambdabot
06:13:15 <poetix> Yay! Let's dance to the masochism tango
06:13:44 <poetix> @slap HAL
06:13:44 <lambdabot> why on earth would I slap HAL
06:13:52 <dons> lambdabot is very wise
06:13:57 <Saulzar> shapr, Just uploading, accidentally put a binary with it the first time and it was rather big :)
06:14:01 <poetix> Yeah, I wouldn't tangle with HAL either
06:16:22 <Saulzar> ?slap dons
06:16:22 * lambdabot beats up dons
06:16:41 <dons> :}
06:16:55 <Saulzar> Not so wise :)
06:17:05 <dons> maybe the lambdabot logo needs boxing gloves.
06:17:12 <poetix> The monster turns on its creator!
06:17:16 <dons> argh!
06:17:36 <poetix> "How could you...? I gave life to you! Ungrateful fiend! Aiieeeee!"
06:17:43 <dons> well, I know where the power plug is if things get really out of hand...
06:17:53 <dons> unless there's some kind of zombie/frankenstein bot 
06:18:13 <Saulzar> shapr, saulzar.orcon.net.nz/robots.tar.gz
06:18:14 <poetix> ?vixen do you have a bolt through your neck?
06:18:15 <lambdabot> i do occassionally, i guess
06:18:25 <poetix> I meant horizontally
06:19:11 <poetix> ?vixen do you like brains?
06:19:12 <lambdabot> sure, i definitely don't hate
06:19:13 * shapr looks at poetix blankly
06:19:34 <poetix> Bad blowjob joke
06:19:51 <shapr> That what I thought. Thus I pretend to be too innocent to get it!
06:20:48 <dons> ?slap poetix
06:20:49 * lambdabot beats up poetix
06:21:01 <dons> you shouldn't talk like that to a lady
06:21:11 <poetix> That's no lady; that's /vixen/
06:21:21 <poetix> ?vixen are you a lady?
06:21:21 <lambdabot> yup, i'm all woman
06:21:48 <shapr> Saulzar: Any spots that particularly bother you?
06:22:36 <Saulzar> shapr, Not particually (at the top level) There's some ugly stuff but it's unrelated.
06:24:19 <Saulzar> But there're 3 distinct parts, rendering .. RenderState.hs which uses StateT IO ..  the game logic stuff, uses Yampa, and the GUI stuff, which uses gtk2hs
06:24:38 <Saulzar> They're all fairly unrelated, and the code is quite different
06:24:48 <tennin> come to think of it, I should probably start posting more stuff on the web under my real name so my teenage crap isn't so prominent in google searches... that probably isn't helping my job prospects.
06:24:53 <Saulzar> Which I think is a good thing
06:25:15 <Phyx-> dons: still here?
06:25:17 <Phyx-> or shapr 
06:25:25 <Saulzar> tennin, I have the same problem, though nothing too bad :)
06:25:26 <dons> yo
06:25:30 * shapr hides
06:25:31 <Phyx-> http://pastebin.com/624970 <-- what does askquestions ans -- loop do?
06:25:35 <dons> isworking on my insomings to hack on
06:25:42 <dons> grr
06:25:57 <Phyx-> ?
06:26:06 <Phyx-> lol, first version didn't have it :S
06:26:09 <dons> I'm working on my insomnia. Need something to hack on.
06:26:28 <Saulzar> (and your dyslexia??)
06:26:31 <Phyx-> i'm guessing calling the same function with the unmodified list, but the --loop is a new one
06:26:34 <dons> what does askquestions ans do? it loops
06:26:49 <Phyx-> Oh crap
06:26:51 <Phyx-> -- is comment
06:26:52 <Phyx-> :|
06:26:53 <dons> that's a comment
06:26:57 <dons> :)
06:27:01 <dons> not a magic operator
06:27:05 <Phyx-> hehe
06:27:18 <mauke> that's why it's colored blue in my editor
06:27:24 <Phyx-> completely forgot about that, lol.
06:27:26 <dons> so that's just the recursive call in case the user enters some funny char
06:27:31 <Phyx-> me noticed it's blue in his also
06:27:47 <Phyx-> dons: yeah, i got that part, but the -- loop was what threw me for a loop
06:27:48 <Phyx-> heheh
06:27:50 <dons> oh, is it using php syntax hl?
06:28:01 <Phyx-> what is?
06:28:05 <Phyx-> i'm using gvim
06:28:20 <shapr> tennin: I'm not convinced most employers are clueful enough to use google. But I could be wrong :-)
06:28:54 <shapr> Saulzar: Can you lift the RenderState and gtk2hs stuff into arrows?
06:28:56 <dons> Phyx-, so you see how it accumulates the set of answers in the 'ans' parameter to 'askquestoins'?
06:29:41 <Phyx-> yep
06:30:10 <Phyx-> to my defense, i seem to know all this, it's just that i haven't coded askell for 2 weeks. and we have started bout 6 weeks ago. so i forget things
06:30:13 <Phyx-> heh
06:30:27 <Saulzar> shapr, I don't think so - for example gtk2hs uses callbacks (with type IO () ), which means you lose any transformer
06:31:00 <dcoutts> Saulzar, you can layer things on top of that IO callback
06:31:42 <dons> interesting seeing this "how to make money from haskell and take over the world" thread on haskell@
06:32:05 <Saulzar> dcoutts, But it would lose the "thread" as such, right? For example if you had a StateT, you'd not be able to update the same state uniformly in a callback
06:32:59 <dcoutts> Saulzar, there are verious ways of saving the state you need, eg IORefs, MVars, threads
06:34:41 <Saulzar> dcoutts, True, but you may as well just those directly (or via some other abstraction) rather than using monad transformers, right?
06:35:34 <dons> things are a bit cleaner with a monad transformer .. no access boilerplate to write
06:35:50 <dons> (as I found out when writing my own withIRef and similar)
06:36:24 * shapr waves the abstraction pom-poms.
06:36:43 <shapr> dons: I think the answer to that thread is "speed of development"
06:36:50 <dcoutts> Saulzar, well the point is that you mgiht be able to hide the IORefs in your arrows/monad abstraction
06:37:17 <dons> once you start coding up your own modifyFoo_ and similar, you may as well stick it all in a monad and use the iorefs from there, getting the access methods for free
06:37:33 <shapr> One of the pragprog guys recently suggested that software development could become simple enough that you could have a dev on every street corner. You'd just walk down to the corner and ask for certain app, then get it in a few hours.
06:37:47 <dons> shapr, yeah. J. Launchbury is always talking about the haskell brand.
06:38:01 <dons> things like transformers, compilers and high assurance
06:38:09 <Saulzar> You mean something like a function to pick the global state from a global IORef, resume the StateT, save it again at the end ... right?
06:38:21 <shapr> dons: And he also talks about the dangers of abstraction addiction.
06:38:50 <dons> shapr, i'm not so sure. maybe. or maybe it's more like architects. the problem is the training
06:38:54 <dcoutts> Saulzar, something like that
06:38:57 <Saulzar> Hmm.
06:39:09 <dcoutts> Saulzar, or a local IOref 
06:39:11 <shapr> dons: The Haskell culture has that if anything.
06:40:00 <shapr> y0 rick
06:40:55 <shapr> dons: Did you see the thread on #haskell where I used you as a good example of the Haskell and #haskell culture?
06:41:19 <dons> oh, no... 
06:41:29 <dons> recently?
06:41:29 <Saulzar> I guess it could be interesting to try, not sold that it would be better though
06:41:35 <shapr> Yeah, coupla days ago.
06:42:27 <shapr> dons: look for this in the logs: <shapr> Science News had an article about a tribe of isolated villagers in Brazil that don't have recursion, indirection, etc in their language.
06:42:52 <Phyx-> hmmm inits is in List right? i imported it, but still gives me not in scope inits
06:43:12 <neologism> shapr: recursion in natural language?
06:43:27 <shapr> neologism: Yeah, no dependent clauses.
06:43:28 <dons> hehe
06:43:33 <dons> I hope that got quoted
06:43:41 <dons> if not -- it's going in tomorrows HWN
06:43:43 <shapr> Hope what got quoted?
06:43:54 * Phyx- waves
06:44:05 <dons> the villagers with no recursion
06:44:07 <shapr> Phyx-: You getting Haskell more now?
06:44:21 <neologism> shapr: can you show me an example?
06:44:34 <shapr> dons: Well, the whole discussion was a coupla pages, and I was waving you around as a good example.
06:44:36 <neologism> I somewhat cannot imagine recutsion in a natural language
06:44:39 <Phyx-> shapr: except i can't find inits :|
06:44:47 <Phyx-> @type inits
06:44:47 <shapr> @index inits
06:44:48 <lambdabot> Not in scope: `inits'
06:44:48 <lambdabot> Data.List
06:44:59 <shapr> It seems to be in Data.List
06:45:03 <shapr> @type Data.List.inits
06:45:04 <lambdabot> forall a. [a] -> [[a]]
06:45:20 <shapr> Phyx-: That's exactly why I wrote the first version of the @index command.
06:45:37 <Phyx-> shapr: i did import Data.List
06:45:37 <dons> some interesting thoughts in there
06:45:41 <Phyx-> still get not in scope
06:45:43 <Phyx-> *sigh*
06:45:46 <dons> abotu the later work of the haskell communnity
06:47:09 <dons> Phyx-, do you import Data.List ?
06:47:20 <Phyx-> yes
06:47:43 <Phyx-> and reloaded
06:49:06 <shapr> dons: What about later work? Using younger info to refine ones picture of a past event?
06:49:15 <Phyx-> dons: basically i just wanted to get everything in a list but the last element
06:50:08 <dons> shapr, oh about how the work of the community has changed. it makes me ponder our forefathers ideas
06:50:25 <dons> Phyx-, so you want 'init' no?
06:50:33 <dons> > init [1..5]
06:50:34 <lambdabot> [1,2,3,4]
06:50:39 <dons> it's in Data.List
06:51:28 <dcoutts> so who wants to implement distghc ?
06:51:31 <Phyx-> that's weird
06:51:34 <Phyx-> after restart ghci
06:51:36 <Phyx-> it works
06:51:45 <dcoutts> it'd be like distcc for distributing compiles over clusters
06:52:05 <Lieter> hmm Haskell is much nicer when your program is starting to work the way it should ^^
06:52:12 <shapr> dons: I don't think their work has changed, I think they've just refined their understanding.
06:52:31 <dons> the emphasis has changed 
06:52:45 <shapr> How so?
06:52:46 <dons> back in the 80s everything was going to be S and K combinators  from the ground up
06:52:47 <dcoutts> it'd use ghc-api to do the parsing & renaming phases and then send the results to other machines in a cluster to do the hard crunching. Those other machines would need ghc but not any of the program's deps.
06:52:52 <shapr> Ah yes, supercombinators.
06:53:07 <shapr> dcoutts: Sounds easy enough.
06:53:14 <dons> if you read spj's tutorial, it's all about how to implement a haskell in terms of S and K 
06:53:18 <shapr> Yeah
06:53:40 <shapr> I came up with supercombinators all by myself a few months before I discovered SPJ's work.
06:54:26 <shapr> I wish I could get paid to go back and mine the Haskell community members' work for ideas that haven't been investigated yet.
06:55:02 <shapr> For example, someone at MIT came up with PackRat parsing in the ..60s? and it's only been usable the last few years.
06:55:43 <shapr> dcoutts: Core to .o, yeah?
06:56:03 <dcoutts> shapr, mm, I was thinking of an eariler layer than that
06:56:21 <dcoutts> shapr, because you want to distribute the heavy optimisation phases to the cluster
06:56:43 <shapr> oh
06:56:45 <dcoutts> shapr, so you just want to do enough to strip away all the depsendencies on other files
06:57:06 <dcoutts> shapr, eg distcc works by doing gcc -E and sending the preprocessed file to another node
06:57:08 <shapr> Does GHC dump at that stage?
06:57:57 <dcoutts> shapr, the key point there is that after gcc -E you only need that one file, all the .h files have already been read. We'd want something similar so we don't have to send all the .hi files over to the other node.
06:58:14 * shapr looks at http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html#dumping-output
06:58:18 <dcoutts> shapr, I think it can dumpt after renaming.
06:58:45 <dcoutts> shapr, but I don't know if it can read it in again. I was thinking of a slightly modifid front end using the ghc-api
06:58:49 <dons> ah, nice point about speed of development
06:59:09 <dons> that's another thing JL goes on about -- just being able to spit out haskell code on deadline, again and again
06:59:19 <shapr> Yeah
06:59:25 <shapr> I'd like to work at Galois.
06:59:48 <shapr> I applied for their QA guy position, hoping to exploit my knowledge of QuickCheck, but.. no go :-(
07:00:02 * shapr was crap in the phone interview
07:00:14 <dcoutts> shapr, :-(
07:00:25 <shapr> I was nervous, didn't know the people at all.
07:00:41 * shapr shrugs
07:00:49 <shapr> Live and learn.
07:02:03 <Phyx-> o.O wow, it compiled...
07:03:41 <dons> shapr, recently was this?
07:03:57 <shapr> Nah, ten months ago I think.
07:04:13 * dons ponders life after PhD
07:04:15 <Phyx-> what's that thing again about haskell only reading the file in when needed, how do i make it read in so i can write back to it?
07:04:26 <Phyx-> i'm getting an openfile error
07:04:31 <dons> Phyx-. close it first
07:04:54 <Phyx-> http://pastebin.com/625070
07:05:03 <Phyx-> @type fileClose
07:05:04 <lambdabot> Not in scope: `fileClose'
07:05:06 <shapr> dons: I think you'd get into Galois just fine.
07:05:06 <Phyx-> lol
07:05:15 <dons> ?hoogle hClose
07:05:16 <lambdabot> System.IO.hClose :: Handle -> IO ()
07:05:36 <Phyx-> and how do i get a handle?
07:05:43 <ozone> dons: start doing type-level hackery in C++, it will be a nice path into the 'real world' thing ;)
07:05:49 <Phyx-> isn't there an easier fix? :S
07:06:02 <dons> ozone is a silly boy
07:06:15 <ozone> dons: reloaded
07:06:16 <Phyx-> i need some )3 myself
07:06:21 <Phyx-> 03*
07:06:27 <Phyx-> O3
07:07:05 <jeroen_p> Woo, it compiled. Let's ship it!
07:07:18 <dons> Phyx-, can you write to a different file?
07:07:35 <dons> if not, you need to use openFile to get the input. and then hClose if after you've read it
07:07:37 <Phyx-> no, has to be same
07:08:09 <psnl> is there a haskell friendly pastebin?
07:08:52 <Phyx-> dons: i created a dummy function that gets the input as param and does nothing with it, but seems to close the file now
07:09:35 <dons> Phyx-, roughly:
07:09:37 <dons>     h <- openFile "/tmp/a.hs"
07:09:38 <dons>     s <- hGetContents h
07:09:38 <dons>     length s `seq` return () -- trick to force reading
07:09:38 <dons>     hClose h
07:09:38 <dons>     let s' = reverse s
07:09:40 <dons>     writeFile "/tmp/a.hs" s'
07:09:55 <snk_kid> hi, does anyone know where i can find api reference docs for SDL bindings?
07:10:30 <Phyx-> whoops, corrupted my file
07:10:45 <dons> oh, should be "ReadMode" argument to openFile
07:10:52 <Descolada|Work> whats `seq` ?
07:11:10 <dons> it forces evaluate of an expression.
07:11:14 <dons> so it's used for strictness
07:11:17 <Descolada|Work> ahh
07:11:30 <dons> here, it forces reading of the entire file before it's closed
07:11:47 <dons> which is usually not an issue unless you want to immediately write that file
07:12:26 <snk_kid> is there away to specify in a cabal file where haddock generated files are placed?
07:13:20 <dcoutts> snk_kid, I don't think so
07:13:39 <dcoutts> why do you need to do that? you can just move them after they're built
07:13:56 <snk_kid> dcoutts: well i can't find them anywhere
07:14:34 <dcoutts> snk_kid, look in dist
07:14:41 <snk_kid> dcoutts: by the looks of things directories are created but they contain nothing
07:14:59 <snk_kid> dcoutts: yeah there not there
07:15:03 <dcoutts> snk_kid, does ./setup haddock do anything?
07:16:04 <dons> Phyx-, just some style advice: http://pastebin.com/625099
07:16:04 <snk_kid> yep, just tried out
07:17:29 <Phyx-> man, i corrupted my file :|
07:17:58 <snk_kid> dcoutts: i'm absolutely baffled by this
07:18:00 <dons> you have an editor open?
07:18:06 <dons> can't you just save it again?
07:18:16 <Phyx-> nah, have to extract from the zip
07:18:21 <dons> this is why mutable values are evil :)
07:18:38 <dons> you shouldn't write _over_ your old value, you should create some new one ;)
07:18:39 <dcoutts> snk_kid, and if you use "./setup haddock -v" it'll tell you exactly what it's doing
07:18:40 <Phyx-> the teacher's pdf shows new lines, the actual file, has none
07:18:41 <Phyx-> lol
07:19:02 <dons> ok. night time. see ya. 
07:19:10 <dons> hope you get the code working Phyx-
07:19:34 <Phyx-> me 2. night dons 
07:20:55 <Descolada|Work> if you create new values, what happens to the one you dont need?
07:21:06 <snk_kid> dcoutts: it doesn't work with "./" and when it runs it just goes into redhat setup utility (using fedora 5 here)
07:21:31 <Phyx-> ohhh no, my error, lol. i kill the new lines with lines
07:21:41 <dcoutts> snk_kid, how are you running your cabal setup program? runhaskell Setup.lhs ?
07:21:41 <snk_kid> dcoutts: just gives a choose tools selection with a list of options to pick
07:22:10 <dcoutts> snk_kid, that's clearly a different setup program :-)
07:22:26 <snk_kid> dcoutts: runghc Setup.lhs --configure --with-haddock=some-path --with-cpphs=some-path
07:22:40 <neologism> @seen vincenz 
07:22:40 <lambdabot> vincenz is in #haskell. Last spoke 1 hour, 31 minutes and 53 seconds ago.
07:22:48 <dcoutts> snk_kid, ok then, use: runghc Setup.lhs haddock -v
07:22:49 <snk_kid> whoops "configure" without "--" :)
07:24:26 <snk_kid> dcoutts: yeah i tried verbose earlier, it seems to be working since it spous out loat of paths :)
07:25:08 <snk_kid> dcoutts: i can post the message if you want?
07:25:18 <dcoutts> snk_kid, ok
07:26:10 <snk_kid> dcoutts: http://pastebin.com/625113
07:26:48 <snk_kid> dcoutts: eeck i think i notice something odd
07:26:52 <dcoutts> snk_kid, strangly, cabal is just calling haddock incrorectly
07:27:00 <dcoutts> Running Haddock for SDL-0.2.0...
07:27:00 <dcoutts> /usr/bin/
07:27:03 <snk_kid> :)
07:27:04 <dcoutts> no haddock!
07:27:07 <snk_kid> hehe
07:27:22 <dcoutts> do you have haddock installed?
07:27:23 <snk_kid> yeah thats what i just noticed :)
07:27:29 <snk_kid> dcoutts: yep
07:27:36 <dcoutts> cabal should notice that and give a sensible error
07:27:45 <dcoutts> when you did configure did cabal find haddock?
07:27:52 <dcoutts> what cabal version is that btw?
07:28:10 <snk_kid> how do i findout the version of cabal?
07:28:18 <snk_kid> somehitng -
07:28:20 <snk_kid> somehitng -v
07:28:27 <snk_kid> something -v
07:28:30 <snk_kid> :)
07:28:43 <dcoutts> ghc-pkg list Cabal
07:28:58 <snk_kid> v 1.0
07:29:28 <snk_kid> i don't get any error messages when it runs
07:29:35 <snk_kid> which is odd to say the least
07:29:38 <kowey> HaXmL question - shouldn't (processXmlWith keep) give me exactly the same XML file on output as input?
07:33:25 <dcoutts> snk_kid, I'd use something later than 1.0, it had various bugs
07:33:49 <snk_kid> dcutts: i'm trying something out that might work, brb
07:34:52 <vincenz> neologism: ?
07:36:03 * snk_kid sighs with relief
07:36:20 <snk_kid> omg
07:36:39 * snk_kid kisses dcoutts for making him notice dumb things
07:36:55 <dcoutts> snk_kid, what did you miss?
07:37:46 <snk_kid> dcoutts: instead of --with-some=/usr/bin i change it to --with-some=/usr/bin/some-bin
07:37:57 <dcoutts> ah
07:38:02 <snk_kid> dcoutts: absolute path
07:38:04 <neologism> anyone willing to help me with monads?
07:38:10 <dcoutts> snk_kid, right
07:38:26 <dcoutts> snk_kid, yeah, I guess the docs are not very clear on that point
07:38:31 <snk_kid> dcoutts: that should have been in the cabal docs :-$
07:38:58 <snk_kid> dcoutts: thanks for helping me out
07:39:04 <dcoutts> np
07:39:26 <snk_kid> it's always the silly things you don't notice :P
07:40:01 <neologism> noone able/willing to help me?
07:40:17 <liyang> neologism: just ask the question. :)
07:40:22 <neologism> ok ;)
07:40:41 <neologism> I have this function
07:40:42 <neologism> crossAll :: [String] -> IO [String]
07:40:42 <neologism> crossAll set = sequence $ crossAll' (sorted set)
07:40:42 <neologism>         where crossAll' [] = []
07:40:42 <neologism>               crossAll' (x1:x2:xs) = cross x1 x2 : crossAll' xs
07:40:46 <neologism> which works and is ok
07:41:00 <neologism> but I want to integrate into "mutate" function (which is String -> IO String)
07:41:18 <neologism> ie to something like crossAll' (x1:x2:xs) = mutate (cross x1 x2) : crosAll' xs
07:41:21 <neologism> how to do so?
07:42:55 <neologism> any idea?
07:44:04 <int-e> @type sequence
07:44:04 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:44:19 <mauke> liftM2 (:) (mutate $ cross x1 x2) (crossAll' xs)?
07:44:40 <neologism> I am afraid I dont know liftM2
07:44:45 <neologism> what does it do?
07:44:48 <int-e> ah, isn't that just cross x1 x2 >>= mutate   then?
07:45:09 <neologism> int-e: yes... but I need that recursion there
07:45:35 <mauke> liftM2 f a b = do { x <- a; y <- b; return (f x y) }
07:45:46 <int-e> ok, but what about  crossAll' (x1:x2:xs) = (cross x1 x2 >>= mutate) : crosAll' xs  doesn't do what you want?
07:45:57 <neologism> int-e: I think it does
07:46:19 <neologism> @index liftM2
07:46:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:47:31 <neologism> none of your solutions work
07:47:48 <neologism> ** Expression     : (cross x1 x2 >>= mutate) : crossAll' xs
07:47:48 <neologism> *** Term           : cross x1 x2 >>= mutate
07:47:48 <neologism> *** Type           : IO [Char]
07:47:48 <neologism> *** Does not match : [a]
07:48:01 <neologism> (int-e solutions)
07:48:40 <int-e> you still need the sequence $ part above
07:48:47 * int-e hmms
07:49:04 <neologism> I changed just the crossAll'
07:49:20 <neologism> so its
07:49:20 <neologism> rossAll set = sequence $ crossAll' (sorted set)
07:49:20 <neologism>         where crossAll' [] = return []
07:49:20 <neologism>               crossAll' (x1:x2:xs) = (cross x1 x2 >>= mutate) : crossAll' xs
07:50:06 <neologism> ah.. the return should not be there
07:50:11 <neologism> it works now.. thnx
07:52:07 <neologism> int-e: btw: can it be rewritten using do block?
07:55:31 <int-e> neologism: not nicely, I think. (you can write cross x1 x2 >>= mutate as (do x' <- cross x1 x2; mutate x') but I don't think that enhances the readability.)
07:56:07 <neologism> I attempted to write that in do form.. maybe thats why I didnt succeed
07:56:12 <neologism> thnx for explanation
07:57:34 <int-e> neologism: alternatively you can incorporate the sequence in the crossAll':   crossAll' [] = return []; crossAll' (x1:x2:xs) = do x' <- cross x1 x2; x'' <- mutate x; rest <- crossAll' xs; return x'':rest   Again, I think the version using sequence is clearer.
08:03:35 <neologism> int-e: yes
08:03:42 <neologism> but I am trying to learn haskell :)
08:12:46 <int-e> neologism: that last remark was prompted by the return in your code; it's what I believe you may have been trying to do there.
08:17:35 <musasabi> Does anyone have a version of parsec for FastPackedStrings ?
08:18:31 <jethr0_> musasabi: wouldn't a lazily unpacked string work too?
08:22:36 <musasabi> not really that fast, but I'll try it out.
08:28:45 <neologism> int-e: eys
08:28:46 <neologism> yes
08:31:16 <mauke> Nomius: what language is that supposed to be?
08:35:56 <musasabi> hmm, -fvia-C/-fasm is broken for ghci?
08:36:48 <Philippa> musasabi: I'd expect a lazily unpacked string through a sufficiently optimising compiler to be fast enough?
08:37:38 <Philippa> it's potentially pretty much equivalent to the constant "if not EOF" checks a parser'll have to indulge in otherwise, no?
08:41:03 <dcoutts> musasabi, -fvia-C/-fasm make no sense for ghci. I'd expect that they get ignored.
08:42:08 <musasabi> dcoutts: I would like them to use the compiler and then load the hi+o
08:42:35 <dcoutts> musasabi, then use ghc to compile and then load them in ghci
08:43:28 <musasabi> dcoutts: that is nasty for modules because one has to add documentation for it etc. (FFI specification with addresses which are not supported by ghci)
08:44:21 <dcoutts> musasabi, yeah ghci's byte code stuff can't cope with ffi, so you need to compile first and then load in ghci
08:44:39 <dcoutts> musasabi, you can use --make to build all the modules you need
08:44:51 <dcoutts> and there's something for not compiling a main
08:45:34 <musasabi> dcoutts: yes, I know how to do it. Just wanted avoiding extra writing documentation and getting question from people not reading the documentation.
08:47:22 <musasabi> -> coffee (maybe after that, I might write proper english)
08:53:56 <dcoutts> musasabi, yeah, it's a bit unfortunate that it's not easier
09:18:06 <bolrod> hrm...  why dont I get an a.out file with ghc --make <name> -fglasgow-exts ?
09:19:09 <bolrod> oh wait -,-
09:19:12 <bolrod> nvm
09:19:50 <SyntaxNinja> shapr: I forgot about your blog's lame rss feed. when are you going to switch blogging software? :)
09:24:33 <shapr> As soon as I get Oleg's HSXML generating RSS from blog entries.
09:25:24 <shapr> I will have a blog that uses Haskell!
09:25:33 <SyntaxNinja> why not just use some already-working software?
09:26:01 <shapr> Because I'm a prima donna.
09:26:22 <shapr> I'm sure I'll end up wishing to extend or debug whatever I use, so it better be a language I enjoy hacking on.
09:26:23 <SyntaxNinja> hehe
09:26:36 <SyntaxNinja> but we want to read your blog dude!
09:26:49 <shapr> I'm working on it!
09:27:02 <davidhouse> shapr, what are your blog entries stored as?
09:27:04 <shapr> Anyone else looking at Oleg's HSXML for blog purposes?
09:27:07 <SyntaxNinja> IMO you would be an integral component to making planet.haskell.org work.  the planet debian site is an invaluable tool to spread ideas.
09:27:27 <shapr> davidhouse: Right now they're stored in a template form that's spit out by another piece of Haskell blog software.
09:27:35 <shapr> But fixing PLog to generate RSS correctly is no fun.
09:27:36 <dcoutts> SyntaxNinja, yeah, the planet.* idea is great. I follow planet.gnome a bit.
09:28:08 <dcoutts> Gtk2Hs rss feed get's aggregated into planet.gnome.org/news
09:28:23 <SyntaxNinja> dcoutts: now it's on planet haskell too :)
09:28:30 <dcoutts> SyntaxNinja, yep
09:28:50 <dcoutts> SyntaxNinja, and planet haskel get's our full feed rather than just announcements
09:29:05 <dcoutts> eg dev posts & screenshots too
09:29:50 <shapr> I have a relatively cute hack for today to blog about.
09:43:00 <davidhouse> hey all
09:43:08 <davidhouse> i'm having trouble with a bit of Parsec.
09:43:39 <davidhouse> i basically want a parser or a couple of parsers that will match (whatever)* and (whatever)?, and allow me to do different things on each
09:44:08 <davidhouse> between (char '(') (string ")*") (...) and between (char '(') (string ")?") (...) because haskell always matches on the first one
09:44:22 <shapr> musasabi: Yeah you're right, the error message I just got from HSXML in 169 lines long.
09:45:23 <mauke> do char '('; ...; char ')'; char '*' <|> char '?' ?
09:45:54 <davidhouse> mauke: oh yeah :) i was looking for a specific function, but that will work well
09:46:53 <mauke> hmm, if this is some kind of ploki-like language, you should reverse your input first :-)
09:47:56 <chrisbrown> there is something weird going on between the gcc stage and the assember stages on my mac when i use the -fviac option :S
09:51:20 * shapr boings cheerfully
09:51:25 <shapr> The type errors really do help!
09:51:33 <davidhouse> argh.
09:51:43 <davidhouse> haskell-mode's indentation is really annoying.
09:52:22 <bob-E> haskell is awesome
09:52:30 <basti_> yes
09:52:43 * shapr cheers
09:53:09 <metaperl-> having won the last to ICFP contests, who could argue?
09:53:14 <metaperl-> s/to/two
10:01:39 <davidhouse> eurgh.
10:01:45 <davidhouse> i'm just about ready to give up on emacs
10:01:54 <neologism> hows that?
10:01:57 <basti_> :(
10:02:02 <basti_> its not emacs' fault.
10:02:21 <neologism> basti_: emacs caused the war on iraq! :)
10:02:23 <davidhouse> there are just several annoyances with it
10:02:45 <davidhouse> and the version i've got appears to be buggy in places :(
10:02:53 <neologism> have tried vim?
10:02:54 <davidhouse> oops, gotta dash
10:03:03 <davidhouse> neologism: don't worry, i will ;)
10:03:21 <Phyx-> vim rules all
10:03:25 <Phyx-> even on windows
10:03:26 <Phyx-> lol
10:03:28 <neologism> I know zillion vim users but just one emacs user
10:03:41 <shapr> Hey, what about me?
10:03:44 <ValarQ> and me?
10:03:46 <neologism> I dont know you :)
10:03:50 <ValarQ> ah
10:03:51 <Phyx-> hehehe
10:03:53 <shapr> davidhouse: go YI!
10:04:04 * shapr begins to figure out HSXML!
10:04:23 <ValarQ> since haskell-mode 2.1 haskell seems to work quite good for me
10:06:31 <metaperl-> neologism: Hi, I am an XEmacs user
10:06:36 <ibid> ed is the standard editor
10:07:03 <astrolabe> What happened to that haskell editor?
10:07:12 <metaperl-> anyone considered a Ph.D with the Clean group?
10:07:22 * shapr boings
10:07:41 * metaperl- lines up to catch shapr
10:07:50 <metaperl-> *SPLAT*
10:07:59 <astrolabe> Watch out for the spring!
10:08:03 <metaperl-> ouch!
10:12:20 * SyntaxNinja boings
10:12:23 * shapr throws heterogenous collections of blog entries
10:13:13 * sieni does not boing
10:13:14 * ibid throws a small everything
10:15:36 <ibid> hrm, what's a ntinuation?
10:15:45 <basti_> a continuation?
10:16:51 <ibid> no, the dual of a continuation :)
10:17:06 <ibid> (tried to joke a bit. oh well...)
10:17:23 <davidhouse> shapr, what advantages does yi have over vim?
10:17:27 <int-e> oh, a whereyoucamefrom
10:17:31 <davidhouse> (just curious, don't want to start a flamewar)
10:17:47 <sieni> davidhouse: it has a sensible configuration language ^_^
10:17:57 <davidhouse> neologism: feel like recommending a GUI front-end to vim?
10:19:10 <ibid> int-e: hrm, sorta like a single-thread trace?
10:19:46 <davidhouse> or anyone, for that matter
10:19:50 <int-e> ibid: hmm, I imagine it's a sort of inverse quantum computation device, unifying several distinct pasts
10:20:27 <int-e> ibid: but maybe I'm just being silly.
10:20:27 <ibid> a "where you could have come from"?
10:20:33 <ibid> int-e: aren't we all?
10:20:57 <sieni> davidhouse: doesn't vim has a gui already?
10:21:02 <sieni> (gvim)
10:21:09 <davidhouse> that's what i was asknig.
10:25:23 <basti_> ibid: argh
10:25:35 <ibid> basti_: :)
10:26:53 <bob-E> gui front end to vim, gvim ? or for the less adept, try cream
10:27:51 <neologism> davidhouse: I dont use any
10:28:10 <neologism> I dont think there's much difference between vim adn gvim
10:29:13 <bob-E> gvim is vim in gtk, and cream is vim/gvim which is modeless, for those ex-window users
10:29:31 <neologism> there's easy vim or something like that which is also modeless
10:29:35 <neologism> but modeless vim is not vim anymore :)
10:30:25 <bob-E> vim has a modeless mode u can enable , but not as full as what is in cream , cream a seperate project in its own
10:30:26 <basti_> emacs is too modeful to be nice
10:30:33 <basti_> vi is hell
10:30:35 <bob-E> emacs is an OS :)
10:32:22 <sieni> modeful editing <3
10:32:51 <tenni1> modeful editing is ok if there's some clear visual indication of what mode you're in
10:33:11 <basti_> you mean, unlike in vi? ;)
10:33:13 <musasabi> Anyone have a copy/mirror of the fps repository? The site seems down.
10:33:28 <tennin> unlike standard vi in an xterm, anyway
10:33:49 <shapr> entry1 = blog_template "Oleg's HSXML kicks butt" [p "SyntaxNinja has been pushing" planethaskell "recently..."]
10:34:10 * shapr bounces
10:34:40 <shapr> No clue how to put in dates and links from one entry to another.
10:34:48 <tennin> I use emacs in vi emulation mode, and just the fact that it indicates insert/edit/replace modes with differently shaped/colored cursors makes it way more usable
10:35:05 <tennin> probably vim does the same thing?
10:36:06 <ncalexan> musasabi: you found one?  I can send you a gzip.
10:36:22 <ncalexan> (Setting up open access not so easy; I'm on my gf's wireless.)
10:36:59 <ncalexan> However, my last patch is Dec 14.
10:37:02 <ncalexan> So quite old.
10:41:51 <musasabi> ncalexan: that would be nice. ekarttun at cs helsinki fi
10:50:53 <neologism> vim shows you in what mode you are
10:51:46 <ValarQ> some of Elvis interfaces shows the mode
10:52:04 <sieni> neologism: yes, but usually the mode line is far away from the cursor, where text is being input
10:52:13 * shapr boings happily
10:52:48 <ncalexan> musasabi: en route.
10:53:54 <ValarQ> sieni: you want the mode info in the center of the document?
10:54:00 <CosmicRay> hey shapr
10:54:25 <sieni> ValarQ: no, but in emacs the viper mode changes the cursor depending on the mode
10:54:59 <shapr> hiya CosmicRay 
10:55:20 <ValarQ> sieni: elvis does that too (at least in the terminal and X11 interfaces)
10:55:47 <ValarQ> shapr: happy boing you got there :)
10:56:06 <musasabi> thanks
10:59:46 <ncalexan> musasabi: something went strange with my net connection... let me know if that doesn't get through, I'll resend from a different acct.
11:01:39 <neologism> sieni: you have the mode in your mind usually ;)
11:03:13 <musasabi> ncalexan: just arrived here :-)
11:03:42 <ncalexan> Excellent, your setup is better than mine.
11:03:44 <davidhouse> is there a way to perform lookaheads in Parsec?
11:04:03 <davidhouse> i.e. say 'if the input matches this parser, then consume it and do X, otherwise don't consume anything and do Y'
11:04:10 <flux__> hmm.. how well does darcs handle binary data?
11:05:41 <davidhouse> @docs Text.ParserCombinators.Parsec
11:06:06 <davidhouse> where's lambdabot?
11:08:44 <flux__> (obviously the faq answered that ;))
11:08:52 <ncalexan> davidhouse: try does that?
11:08:55 <mauke> 27/19:46 -!- lambdabot [n=lambdabo@shodan.cse.unsw.EDU.AU] has quit [Read error: 110 (Connection timed out)]
11:09:52 <davidhouse> Parsec is really badly documented.
11:09:56 <davidhouse> ncalexan: thanks, i'll check it out
11:10:15 <ibid> parsec is quite ok documented
11:10:24 <ibid> (unless you restrict yourself to the haddoc docs)
11:10:27 <ncalexan> Parsec has _great_ docs.
11:10:42 <ncalexan> Try the section 'predictive parsing' in http://www.cs.uu.nl/~daan/download/parsec/parsec.html
11:11:18 <davidhouse> ibid: well, that was what i was going by
11:11:29 <ibid> davidhouse: it does refer to the real docs, iirc
11:11:47 <ncalexan> Ah, yes, reverse engineering from Haddock docs can be a little difficult.
11:11:51 <ibid> davidhouse: of course, volunteers are most likely welcome to fix it :)
11:13:32 <jyp> Please, oh, please... Don't put @ in front of commands in makefiles.
11:14:15 <jyp> this is for you dons :)
11:14:21 <ibid> agreed
11:14:27 * shapr fights crazy type errors
11:14:31 <ibid> (except for some special cases like @echo)
11:14:35 <shapr> Man, I wish Oleg were here.
11:15:08 <jyp> Any chance a normal person can help you shapr ?
11:15:09 <davidhouse> jyp: what does the @ do?
11:15:32 <jyp> davidhouse: It prevents the shell to show the command that follows it
11:15:59 <jyp> davidhouse: so @ makes you absolutely clueless about what's going on in case of problem
11:16:05 <davidhouse> ah.
11:16:24 <shapr> jyp: I'm trying to hack Oleg's HSXML and RSS together to make a simple blog tool.
11:16:42 <shapr> I can't figure out how to use the render_rss_item function.
11:17:13 <shapr> Specifically, what fits into the body arg?
11:17:50 <shapr> this works: gwahr = render_rss_item (5,February,2006) (URL "foo.html") But I can't figure out the necessary type of the third argument.
11:18:20 <elux> hi
11:18:24 <jyp> shapr: cna
11:18:26 <elux> does anyone know of a pdf parser written in haskell?
11:18:33 <elux> for basic parsing
11:18:50 <jyp> shapr: what does ghci type inference say?
11:19:32 <shapr> Oleg is using HList-style heterogenous lists. GHCi type signatures aren't that helpful. They are long though.
11:19:44 <shapr> jyp: cna?
11:20:41 <shapr> Aha, render_rss_item is an internal method, I should be using the RenderInline instance of UpdateItems.
11:20:43 <jyp> shapr: I'm a bad typer. This was supposed to be the beginning of my next statement until I hit enter instead of apostrophe :)
11:20:54 <snk_kid> does hs-plugins need to be installed when using packages with ghci?
11:21:08 <shapr> Nah, hs-plugins needs ghci, but not the other way around.
11:21:22 <shapr> elux: If you know the format of pdf, writing parsers is easy.
11:21:35 <elux> the format is pdf is huge though
11:21:49 <elux> first is = of
11:21:54 <shapr> You could always write a minimal parser and publish it on the mailing lists. I'm sure someone else would use it and extend it.
11:22:14 <elux> thats true
11:22:25 <elux> do you recommend using parsec ?
11:22:31 <elux> or just doing it by hand?
11:22:35 <shapr> parsec
11:22:38 <snk_kid> shapr: okay, i tried to use SDL bindings and i get unresolved symbols error, do i need to make a binary package for fedora (cabal docs appear to hint this for red hat)
11:22:40 <elux> thats what i thoguth
11:22:41 <elux> thanks
11:22:51 <ncalexan> snk_kid: what errors do you get?
11:23:01 <ncalexan> I use those bindings, so I might be able to help a little.
11:23:07 <snk_kid> ncalexan: unknown symbol `SDL_HasAltiVec'
11:23:37 <ncalexan> Hmm... that's in the SDL CPU library.  Let me try to find that symbol.
11:23:38 <shapr> snk_kid: If the package has created only .a files, you need to do something to turn them into .o files that ghci can load. That's the only difference I'm aware of.
11:23:42 <ncalexan> Is that the only symbol error?
11:23:56 <snk_kid> ncalexan: yep
11:24:05 <shapr> jyp: Want to see my darcs repo of the HSXML sources to see what I'm doing?
11:24:33 <snk_kid> shapr: looks like object files are already there
11:24:52 <snk_kid> shapr: maybe it's not in my path?
11:24:53 <jyp> shapr: sure
11:25:20 <snk_kid> shapr: then again i can check function signatures with :t so it must be visible to it
11:25:34 <ncalexan> snk_kid: /sw/lib/libSDL.a(SDL_cpuinfo.o): is the file for me.
11:25:48 <shapr> snk_kid: Can you pastebot the entire error?
11:26:00 <ncalexan> Are you certain you're linking libSDL?  What platform?
11:26:07 <snk_kid> shapr: the one i gave to ncalexan above was the only one
11:27:30 <snk_kid> ncalexan: not sure if it's linking or it can't find the library then again packages where registered and i can :t functions, on fedora 5
11:28:07 <jyp> shapr: url?
11:28:19 <ncalexan> snk_kid: so the link error is in ghci?
11:28:37 <snk_kid> yep
11:28:47 <snk_kid> let me just try an compile a binary
11:29:07 <ncalexan> You might try ghc --make test.hs -package hsSDL to see if it's picking up the SDL libs.
11:29:30 <ncalexan> I think the extra-libs in hsSDL might be wrong...
11:29:54 <shapr> jyp: darcs get http://www.scannedinavian.com/~shae/hsxmlblog
11:30:07 <snk_kid> ncalexan: okay, i'll try that
11:30:12 <shapr> Yeah, I agre with ncalexan
11:30:38 <shapr> Sounds whatever should be adding -lSDL isn't
11:30:56 <ncalexan> Yeah.  I can help you hack the SDL.cabal file if you can make it link at all.
11:32:05 <shapr> jyp: interesting stuff starts at line 29 of sample1c.hs
11:32:28 * shapr likes darcs put
11:34:18 <jyp> "Oleg's HSXML kicks butt"
11:34:37 <jyp> indeed, at last a decent way to edit web documents :)
11:34:44 <ncalexan> I'm running across notation like proc p -> ... (|liftState cmd|) in the Control.Arrow / arrows package documentation.  A quick browse of the relevant papers doesn't say much about that funny notation... any help?
11:35:50 <snk_kid> how can i prevent name collisions, i'm importing a module and the fucntion i'm using conflicts with module List's version
11:36:17 <jyp> import Module hiding (whatEverClashes)
11:36:27 <snk_kid> jyp: thanks
11:36:30 <jyp> or import qualified Module
11:37:11 <jyp> note that Module is Prelude if it's a prelude-defined function
11:37:26 <elux> hey
11:38:03 <elux> snk_kid: once i write the minimalist parser for pdf in haskell .. how can i then use hscairo to output onto a cairo backend?
11:38:20 <elux> would it be a tedious task or should it be simple translations into cairo?
11:38:30 <dcoutts> elux, hmmm
11:38:45 <dcoutts> elux, how muchdo you know about the pdf language?
11:38:58 <elux> i still need to read the reference
11:39:13 <dcoutts> I expect it'd be a bit tedious, it's a large language I believe
11:39:17 <elux> well .. read the rest of it anyways
11:39:28 <elux> yes, its massive
11:40:04 <elux> im just trying to figure out if hscairo has any supporting api's to help when using cairo as a backend
11:40:11 <elux> like in this particular case
11:40:41 <elux> it might make more sense to write a pdf to svg convertor
11:40:47 <elux> then use cairo to parse the svg
11:40:53 <dcoutts> elux, sorry? hscairo/cairo 
11:41:07 <dcoutts> I think we're getting confused here with what cairo does
11:41:20 <dcoutts> are you trying to read in a pdf or generate a pdf?
11:41:33 <elux> read in
11:41:36 <elux> cairo does 2d rendering
11:41:42 <elux> with vector formats
11:42:09 <dcoutts> yes it does, it can render to screen, ps, pdf, png (and will be able to do svg in the future)
11:42:20 <elux> right
11:42:23 <dcoutts> (that is svg as an output format)
11:42:25 <elux> but it does also read svg
11:42:36 <elux> librsvg generates svgs
11:42:46 <dcoutts> there is librsvg which can read in svg files and render them onto a cairo surface
11:42:49 <dcoutts> right
11:42:56 <dcoutts> there is a bindign for that already
11:43:04 <dcoutts> it's in the dev version of gtk2hs
11:43:13 <elux> im trying to read in a pdf .. convert it to svg and use cairo to render it
11:43:32 <snk_kid> now i'm baffled, init is of type [InitFlag] -> IO () but i'm getting compile errors saying that the function expects IO () 
11:43:36 <elux> once i have the svg, i will make a shell format to support multiple pages and other features and use cairo to render the content
11:43:45 <dcoutts> any you don't want to use an existing pdf reader/renderer?
11:43:52 <snk_kid> :t
11:43:59 <dcoutts> eg popler/xpdf
11:44:21 <snk_kid> :t Graphics.UI.SDL.General.init
11:44:28 <snk_kid> @t Graphics.UI.SDL.General.init
11:44:42 <shapr> jyp: It looks to me like the RSS generation uses a custom datastructure and generates both html and rss from it.
11:44:59 <elux> those aren't an option because they are GPL.. id need something BSD or LGPL
11:45:10 <dcoutts> elux, right, ok
11:45:13 <elux> poppler is derivative work of xpdf .. so ..etc.
11:45:18 <snk_kid> lambdabot off?
11:45:45 <elux> so i just figured id write my own minimalist version and release it LGPL
11:45:50 <jyp> shapr: indee
11:45:53 <jyp> d
11:46:08 <sjanssen> snk_kid: looks like it's connection timed out a while ago
11:46:17 <snk_kid> heh
11:46:28 <snk_kid> anyways this line:
11:46:39 <snk_kid> main = init [InitEverything]
11:47:17 <snk_kid> where init is of type "[InitFlag] -> IO ()" now i'm getting compile errors saying it expects an arguement of type IO ()
11:48:07 <elux> dcoutts: do you know of a postscript reader in haskell?  i could just use that instead
11:50:02 <dcoutts> elux, I'm afraid I don't. It realyl is a big spec, so I doubt people have tried to tackle it.
11:50:34 <dcoutts> elux, you could probably get a core command set working, but the full spec is going to be a big job I'd say
11:50:58 <dcoutts> even with the fact that the translation from pdf's model to cairo's model is very thin
11:51:14 <elux> all id need are the text, embedded fonts, text outlines,images,drawed objects
11:51:19 <elux> and colors
11:51:49 <elux> i dont need any embedded notes .. watermarks .. javascript or any garbage like that
11:52:02 <elux> ill have to look into it and see if its too big of a job for one person
11:52:09 <elux> ive looked at the spec in the past and its gigantic
11:52:33 <snk_kid> ncalexan: are you still around?
11:52:36 <ncalexan> Yep.
11:52:52 <snk_kid> ncalexan: can you see whats wrong with this "main = init [InitEverything]"
11:53:33 <ncalexan> Well, I have no idea... but mine is
11:53:38 <Philippa> depends. Is init ever called elsewhere? What's the type of init?
11:53:38 <ncalexan> SDL.withInit [SDL.InitVideo] $ do ... your thing here.
11:53:55 <Philippa> (speaking from a "don't know WTF lib you're using" POV :-)
11:54:05 <ncalexan> with an import qualified Graphics.UI.SDL as SDL hiding (flip) before that.
11:54:18 <ncalexan> Are you using Lemmih's bindings?  Graphics.UI.SDL.Core etc?
11:54:30 <snk_kid> Philippa: i mentioned it a thew times abouve, the type is [InitFlag] -> IO ()
11:54:59 <Philippa> okay. Ew
11:55:12 <Philippa> (I assume InitEverything is an InitFlag... not sure what's broken)
11:55:14 <snk_kid> ncalexan: yeah it's Lemmih's bindings
11:55:25 <ncalexan> Sorry, cat just caught a bird.  BRB.
11:56:00 <snk_kid> Philippa: i get an odd error saying it expects an arg of type IO () ???
11:56:48 <Philippa> saying what does?
11:57:00 <snk_kid> compiler errors
11:57:04 <Philippa> (Though I wouldn't be surprised if init :: [InitFlag] -> IO () -> IO () )
11:57:18 <Philippa> bad answer. What does the compiler error say expects an arg of type IO ()?
11:57:41 <snk_kid>     Couldn't match `IO ()' against `[a]'
11:57:41 <snk_kid>       Expected type: IO ()
11:57:41 <snk_kid>       Inferred type: [a]
11:57:41 <snk_kid>     In the application `init [InitEverything]'
11:57:41 <snk_kid>     In the definition of `main': main = init [InitEverything]
11:58:52 <Philippa> okay. You /sure/ you've got the type of init right?
11:59:12 <snk_kid> Philippa: yeah i've checked the docs and with :t
11:59:25 <Philippa> then something's fubar. Where're the docs?
11:59:41 <snk_kid> Philippa: generated from haddock :)
12:00:00 <snk_kid> Philippa: i don't think you can get them online (lemmih's SDL bindings)
12:00:16 <snk_kid>  :t Graphics.UI.SDL.General.init
12:00:16 <snk_kid> Graphics.UI.SDL.General.init :: [Graphics.UI.SDL.General.InitFlag]
12:00:16 <snk_kid>                                 -> IO ()
12:01:53 <Philippa> something's badly broken then
12:01:59 <snk_kid> heh
12:02:04 <Philippa> because it thinks init wants an IO ()
12:02:17 <Philippa> ask it :t init [InitEverything] ?
12:02:22 <Philippa> (:m to add the relevant modules)
12:03:59 <dcoutts> lamdabot?
12:04:04 <dcoutts> @botsnack
12:04:07 <dcoutts> :-(
12:04:08 <snk_kid> i get back Graphics.UI.SDL.General.init [Graphics.UI.SDL.General.InitEverything] :: IO ()
12:05:15 <Philippa> weird
12:05:36 <Philippa> you're sure the source is picking up the right bindings, and not some other init?
12:07:22 <snk_kid> Philippa: well before there was conflicts with module List's init name collisions but i sorted that out in the the import statement with hiding
12:08:02 <ncalexan> Maybe http://darcs.haskell.org/~lemmih/SDLhead would help?
12:09:04 <snk_kid> i've been using http://darcs.haskell.org/~lemmih/SDLstable/
12:10:12 <ncalexan> That should work too.
12:10:23 <ncalexan> There are demo programs; try running those.
12:11:30 <snk_kid> i don't see any demo programs in there
12:13:32 <snk_kid> ncalexan: strangest thing is "main = initSubSystem [InitEverything]" works with what you suggested earlier i.e.  ghc --make Test.hs -package SDL-0.2.0
12:13:59 <ncalexan> Oh, really?  Then the problem is in the package decl for hsSDL.
12:14:41 <ncalexan> Try ghci -lSDL -package SDL
12:14:54 <snk_kid> why would the compiler go nutz wit init which is exactly the same type as initSubSystem :-S
12:15:46 <ncalexan> That I can't answe.r
12:16:50 <snk_kid> ncalexan: sorry i forget to mention earlier i think it was trying to link earlier (without ghci -lSDL -package SDL) but it failures, this is the exact message: "Loading package SDL-0.2.0 ... linking ... ghc-6.4.1: /usr/local/lib/SDL-0.2.0/HSSDL-0.2.0.o: unknown symbol `SDL_HasAltiVec'
12:16:51 <snk_kid> ghc-6.4.1: unable to load package `SDL-0.2.0'
12:16:51 <snk_kid> "
12:17:44 <snk_kid> ncalexan: so i assume that it's not linking to SDL itself when i built the package earlier, maybe i need to build a binary package for fedora
12:19:12 <snk_kid> on cabal docs it mentions after runhaskell Setup.hs configure/build/install something about building binary packages for red hat linux
12:19:12 <ncalexan> I'm not sure what your status is.  You can run the initSubSystem code, but it barfs on init?  That's bizarre.
12:19:28 <ncalexan> I think that should be separate, but I can't guarantee it.
12:20:19 <snk_kid> ncalexan: yeah it barfs when i try to comiler, with ghci i can't "unknown symbol" errors regardless which one i use
12:20:29 <snk_kid> *when i try to compile
12:21:08 <ncalexan> So you never actually made it run anything?
12:21:21 <ncalexan> You said 'ncalexan: strangest thing is "main = initSubSystem [InitEverything]" works with what you suggested earlier i.e.  ghc --make Test.hs -package SDL-0.2.0'
12:21:34 <ncalexan> So it works with ghc but not ghci.
12:21:59 <snk_kid> ncalexan: yeah it compiles, i haven't tried that in ghci yet
12:22:42 <ncalexan> Run ./a.out.  Does it actually work?
12:23:57 <snk_kid> ncalexan: ghc --make doesn't produce a binary, it produces .hi and object file
12:24:03 <snk_kid> ncalexan: well for me
12:24:53 <ncalexan> Ah, you have no main function.
12:25:10 <ncalexan> Have main = yourInitFunction.
12:25:27 <snk_kid> yep i have a main function
12:25:52 <snk_kid> eeee
12:26:19 <adu> ee as in ooh?
12:26:21 <snk_kid> ncalexan: i just change the module name to Main and now i see, i get linker errors :-S
12:26:48 <adu> thats different
12:27:12 <snk_kid> ncalexan: i must have screwed up the package build as i'm getting linker errors to SDL
12:27:14 <ncalexan> snk_kid: how much haskell/ghc do you know?
12:27:40 <ncalexan> It seems that you're conflating all sorts of problems... linking errors with main/Main are different from SDL binding problems.
12:28:09 <ncalexan> Maybe you should do a few tests without SDL stuff to get the build system working?  Then we can work on the SDL linking issues.
12:28:37 <snk_kid> no, no i've never said/ment linker errors with main module or main function
12:29:00 <adu> snk_kid: have you gotten anything to compile with GHC?
12:29:05 <snk_kid> i can build normal console application with standard prelude fine
12:31:26 <ncalexan> Okay, then get your test running a main = print "test" linking, then we'll add in the SDL init.
12:32:45 <snk_kid> ncalexan: done
12:33:48 <ncalexan> Okay, now let's try main = withInit [InitEverything] $ do print "after init"
12:33:58 <ncalexan> (Maybe caps are off)
12:35:31 <adu> how is ObjectIO compared to wxHaskell?
12:36:11 <snk_kid> ncalexan: now (as i said just a moment ago) i'm geetting  linker errors all todo with SDL
12:36:47 <snk_kid> ncalexan: ah i solved it with -lSDL
12:37:11 <snk_kid> ncalexan: ghc --make Test.hs -o test -lSDL works
12:37:20 <ncalexan> Excellent; that's what we had before.
12:37:39 <ncalexan> The issue is that the package is not forcing the -lSDL correctly.
12:38:06 <snk_kid> ncalexan: do i need to playing the cabal files to get it right?
12:38:11 <snk_kid> *to play
12:38:38 <ncalexan> Yep.
12:38:40 <ncalexan> extra-libraries: 
12:38:43 <ncalexan> sorry.
12:38:59 <ncalexan> Add 'extra-libraries: SDL' to the Core/SDL.cabal file.
12:39:10 <snk_kid> ncalexan: gotcha
12:39:15 <ncalexan> You may need to tweak 'extra-lib-dirs' to make it work.
12:39:26 <ncalexan> i.e.: 'extra-lib-dirs: /sw/lib' or whatever.
12:39:44 <ncalexan> Then ./Setup clean configure build install etc.
12:40:00 <ncalexan> (clean configure may not be necessary.)
12:41:11 <snk_kid> okay think i'll make some tea first :)
12:41:31 <snk_kid> brb
12:41:35 <ncalexan> I'm going to have lunch, too... I should be back in an hour or so.
12:41:43 <ncalexan> You should try to build the demo applications next.
12:41:52 <adu> is there a lex/yacc equivalent for haskell?
12:42:05 <snk_kid> ncalexan: do you know which directory there in?
12:42:27 <snk_kid> ncalexan: i can't seem to find any there
12:42:36 <snk_kid> ncalexan: from SDLstable
12:42:57 <ncalexan> '/Users/nalexand/Devel/SDLhead/src/Core/Examples/'
12:43:08 <ncalexan> Maybe they're new in SDLhead?
12:43:13 <mauke> adu: yes
12:43:17 <ncalexan> You could probably just use SDLhead anyway.
12:43:21 <ncalexan> adu: happy.
12:43:27 <ncalexan> But parsec might make you happier.
12:43:31 <ncalexan> And alex is the lexer.
12:43:34 <adu> oh
12:43:56 <snk_kid> ncalexan: yeah, i'll check out, thanks alot for your help
12:44:05 <snk_kid> an
12:44:15 <snk_kid> and everyone else aswell :)
12:44:45 <adu> so alex:happy::lex:yacc
12:45:47 <ncalexan> snk_kid: n/p.  Best of luck... the bindings are reasonably good, at least for what I need.
12:45:54 <ncalexan> adu: I believe so.
12:46:26 <ndm> adu, alex=lex, happy=yacc
12:46:39 <ndm> i think there is also frown=yacc as well
12:46:46 <ndm> and i am writing helix=lex at this very minute
12:47:43 <ncalexan> ndm: what benefits/diffs from alex?
12:48:08 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/helix.php
12:48:15 <ncalexan> There is also halex, btw, but that's not necc. a strong candidate.
12:48:30 <ndm> ncalexan: lower complexity O(n) for helix, O(n^2) for alex
12:48:40 <ndm> plus i need it for my parser system
12:48:48 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/parsing.php
12:48:49 <adu> ndm: compile time? or runtime?
12:48:56 <ndm> adu, runtime
12:49:10 <jeroen_p> How can I draw a random number between 1 and 8? I found next of StdGen, but it's only evaluating once when I try to fill a 15x15 list with random Ints.
12:49:10 <adu> so helix makes faster code?
12:49:34 <ndm> adu, lower complexity - yes, faster (in real life scenarios) - unknown
12:49:50 <adu> hm
12:49:51 <ndm> there are certainly instances where Helix will be faster
12:50:10 <ndm> the example on teh helix web page, i guarantee helix will beat alex on that
12:50:50 <ncalexan> jeroen_p: one way to do it is to try randomRs.
12:50:54 <ncalexan> @index randomRs
12:51:06 <ncalexan> Ah, no lambdabot.
12:51:22 <dcoutts> ndm, tell me when you want Helix and/or your parser stuff packaging for gentoo
12:51:46 <ndm> dcoutts, will do - its still a little way off being finished
12:51:47 <ncalexan> randomRs (1 :: Int, 8) (mkStdGen 0) gives you an infinite list of random numbers.
12:52:13 <ndm> although i can now parser my parser description with my parser
12:52:15 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/parser.txt
12:52:15 <ncalexan> It can be wrong when you want sequenced random numbers, but at that point you're in IO anyway.
12:52:33 <ndm> thats a parser description, that when run with my parser, over that file, will parse itself
12:52:59 <jeroen_p> Thanks ncalexan, I'll look that one up
12:53:27 <ncalexan> jeroen_p: System.Random.
12:54:04 <jeroen_p> Thanks
13:00:50 <Taral> boo
13:10:26 <shapr> hiya Taral 
13:11:30 <Taral> hi!
13:11:34 <Taral> long time
13:14:09 <snk_kid> ncalexan: Its all working lovely now, omg the pain and hassle i've had to go through finally pays off :)
13:14:25 <ncalexan> Ah, so the extra-libs fixed the problem?  Good.
13:14:58 <snk_kid> ncalexan: yep
13:15:53 <cinema> shapr, do you know if anyone here uses Omega (Tim Sheard's)
13:17:16 <snk_kid> omg the pain i've been through with, Fedora 5, ghc, haddock, eclipse omg all the headaches
13:18:11 <NameTab> if I load a file in haskell and adjust it
13:18:16 <NameTab> I can't save it because it's locked
13:18:31 <snk_kid> the last thing left is to get fedora-eclipse and haskell plugin to work in harmony
13:18:34 <NameTab> can I make it unlock somehow?
13:22:04 <shapr> cinema: I know some people have looked at it. I've discussed it with them. I can't remember who right now...
13:22:34 <shapr> cinema: On a related note, several of the Epigram developers visit here.
13:22:55 <cinema> shapr, yes but Epigram is too difficult for me
13:23:02 <shapr> How so?
13:23:10 <shapr> Have you tried Conor's tutorial?
13:23:37 <cinema> yes, I've tried. But I find Omega a lot easier for a haskeller
13:24:02 <shapr> I haven't tried Omega yet, so I'll hoard that bit of info until I do have a chance.
13:24:15 <cinema> Omega is a generalisation of Haskell's GADTs
13:24:32 <cinema> shapr, if you want some code, I'll provide it to you
13:24:34 <shapr> Yeah, that much I know... only because someone corrected me when I said it was a deptyped system like Epigram.
13:24:39 <shapr> cinema: sure yeah!
13:24:39 <cinema> (some broken one too)
13:24:48 <shapr> Taral: How's code?
13:24:58 <Taral> mmm, code.
13:25:04 <Taral> Let's see... what do I have here?
13:25:08 <Taral> Ah, yes. coq.
13:25:09 <Philippa> shapr: I'm not convinced it's easier to be sure of what you're proving in Omega. I'm pretty certain it's easier for most haskellers to code in
13:25:35 <shapr> Is Omega strongly normalizing like Epigram?
13:25:37 <Taral> I'm starting to think that adding a propositional type-space and lambda cube to Haskell would make for a very interesting experiment.
13:26:09 <shapr> When you say lambda cube, doesn't it really mean one of the combinations of X indexed Y?
13:26:22 <Taral> huh?
13:26:24 <shapr> Like, type indexed terms are dependently typed systems like Epigram, yeah?
13:26:37 <Taral> lambda cube = calculus of constructions
13:26:45 <shapr> Er, I think it's just one corner of the cube.
13:26:46 <Philippa> not quite
13:26:53 <Philippa> exactly
13:26:56 <Taral> Yeah, it's the far corner of the cube
13:27:00 <Philippa> and there're definite uses for more general PTSes
13:27:02 <Taral> people refer to it as "lambda cube".
13:27:08 <Taral> (perhaps improperly)
13:27:27 <Philippa> shapr: Omega's not strongly normalising atm AFAIK
13:27:35 <shapr> That's a heavy difference.
13:27:48 <Taral> And then there's still that bit about using linear logic for types.
13:27:53 <Taral> But that's on the way way back burner.
13:27:55 <Philippa> not if you get to choose which set of dependencies you're using I guess
13:28:10 <Taral> Does anyone have good references on object lifetime inference?
13:28:12 <shapr> Taral: Er, I think I've read something about that.
13:28:19 * Philippa wonders if it's possible to encode linear typing in epigram as-is in a way that mixes well with other encodings
13:28:22 <Taral> The closest I get is region inference, which is too restrictive.
13:28:31 <Philippa> you can probably do it with a monad or close relative thereof, come to think of it
13:28:37 <shapr> There's lots more stuff that's similar to region inference.
13:28:47 <Philippa> in what sense "too restrictive"?
13:28:51 <Taral> shapr: I've been playing with coq, and being able to tie values and propositions about values together is very valuable.
13:28:52 <Philippa> you want a range instead of a worst case?
13:28:58 <Taral> Philippa: Yeah.
13:29:12 <Taral> I'm trying to see if it's possible to infer free(3) points for objects.
13:29:15 <shapr> Taral: I keep meaning to get around to playing with those guys: Coq, NuPRL, etc
13:29:20 <Taral> Thus removing them from GC.
13:29:26 <Taral> shapr: coq is very worth it
13:29:28 <shapr> cool idea
13:29:31 <Taral> if only for the brain bending.
13:29:36 <Philippa> it is, but region inference is about as good as it gets atm
13:29:44 <Taral> Damn.
13:29:46 <Philippa> ultimately, to do better you need something equivalent to GC
13:30:10 <shapr> There are other resource lifetime calculation systems. I've seen them discussed on LtU.
13:30:19 <Philippa> as it is, a good many region schemes'll start to resemble small scale copying collection in places too - "copy out the answer and free the rest"
13:30:50 <Taral> Philippa: I think that's an artifact of the restrictiveness of region-based lifetime calculation.
13:30:51 <Philippa> shapr: point
13:31:08 <Philippa> in that you need to show when something in fact lives longer, yes
13:31:11 <Taral> Although regions have the advantage of efficiency (objects are freed in large chunks)
13:31:32 <Taral> C programmers have been using malloc/free on a per-object basis for years and it's very efficient.
13:31:32 <Philippa> in practice, you'll end up with some notion equivalent to passing ownership to another region even if you don't retain the stack discipline though
13:31:46 <Philippa> no it's damn well not, there's a reason a lot of systems pool
13:31:46 <Taral> Philippa: Yeah, that ties back to my linear logic proposal.
13:31:55 <sebell> It's not efficient!
13:32:05 <vincenz> feck c++
13:32:13 <Taral> *shrug* efficient enough with delayed free/coalesce.
13:32:22 <Philippa> even that depends
13:32:31 <Philippa> it can really suck for cache coherancy purposes, for example
13:32:36 <Taral> Heh.
13:32:53 <Taral> If you're worried about cache coherency, you're already deeper than is important for my purposes.
13:33:15 <Philippa> but at the kind of level you should be talking about if you want to claim 'very efficient'
13:33:17 <Taral> Anyway, there are areas where people will pay a small performance penalty if they can eliminate the GC overhead.
13:33:32 <Philippa> cache coherancy isn't necessarily a small overhead
13:33:33 <Taral> Philippa: Sorry, strike "very" and substitute "sufficiently"
13:33:40 <vincenz> Taral: don't think that malloc and free is very efficient
13:33:52 <vincenz> Taral: I've published papers giving much improved results over the ones given in std systems
13:33:59 <Philippa> I don't know if you've seen how easy it is to stall a PS2, but the guys working on that thing have problems...
13:34:03 <Taral> You've got improvements over dlmalloc?
13:34:11 <vincenz> be it the lea one from linux or the kingsley one from windows
13:34:25 <Taral> vincenz: Linky?
13:34:30 <vincenz> Taral: dl being doug lea, yes
13:34:43 <vincenz> Taral: lemme google
13:34:46 <Taral> thanks!
13:34:48 <vincenz> either way
13:34:51 <vincenz> they're app specific
13:35:03 <Taral> So the real goal is to eliminate GC from a program, and see how much that gains/costs us.
13:35:19 <Taral> But to eliminate GC, I have to be able to constrain object lifetime.
13:35:31 <shapr> Have you read Henry Baker's work?
13:35:33 <Taral> No.
13:35:34 <Philippa> no you don't
13:35:41 <Taral> Philippa: You have an alternative?
13:35:47 <Philippa> you /can/ just assume you have a fuckload of memory, and see how much a fuckload costs you :-)
13:35:49 <Taral> (besides leaking everything forever)
13:35:58 <Taral> *sigh*
13:36:02 <Taral> engineering vs. mathematics
13:36:16 <Taral> That's a mathematician's answer. :P
13:36:16 <shapr> Taral: You'll like this - http://www.pipeline.com/~hbaker1/
13:36:25 <Taral> hm... *looks*
13:36:29 * Maddas cheers for baker
13:36:37 <shapr> Taral: hbaker unicycles. He's cool.
13:36:43 <Taral> heh
13:36:45 <Taral> what a criterion
13:36:55 <Philippa> Taral: a mathmo wouldn't bother to ask how much a fuckload of memory costs :-)
13:36:58 <shapr> He was also the guy who started combining GC and linear logic, iirc.
13:37:06 <Taral> oh?!
13:37:10 <Taral> Philippa: Ha ha.
13:37:14 <Taral> :)
13:37:21 <Taral> Thermodynamics and GC... interesting.
13:37:21 <shapr> Garbage collection simulates infinite memory.
13:37:29 <shapr> Henry Baker kicks butt.
13:38:05 <shapr> It's too bad he dropped CS and became an investment banker. 
13:38:22 <Taral> Ah, well.
13:38:26 <shapr> I heard rumors he got so fed up with the resistance to change of the CS world that he just left.
13:38:30 <Taral> I'm sure there's more money in investment banking.
13:38:36 <Philippa> I figure it'd be really easy to get a trivial tagged GC working in a linearly typed system just by marking boxed values as not-pointer when the linear value gets used. It's overwriting that's more interesting IMO
13:39:48 <Philippa> (I see linear typing in that regard as being about as explicitly-managed as using RAII-based types in C++)
13:40:07 <NameTab> does nobody know how to load a file before you actually need it, just to prevent it from being locked when you're actually using it?
13:40:19 <shapr> Taral: btw, feel free to poke me and ask me about any combination of CS subjects, I may know something interesting.
13:40:27 <shapr> I collect nifty bits.
13:41:53 <Taral> So do I.
13:41:53 <Taral> :)
13:42:01 <Taral> This is a new thing for me, so I'm filling my bucket. :)
13:42:55 <Philippa> Taral: hopefully it'll make sense if I say I don't consider linear typing to be "inferring free"?
13:43:22 <Philippa> (and it doesn't always sufficiently if you want to make good use of overwrites, either)
13:43:45 <Taral> Linear logic does not infer free.
13:44:19 <Taral> It infers single-reference, for things like overwrite, etc.
13:44:41 <Philippa> overwrite's a hard case. The easy one is just "used it! So I'll free it"
13:44:59 <Philippa> "hey, I'm freeing it /and/ allocating something of exactly the same size" is just a neat optimisation :-)
13:45:10 <Taral> Yes. In fact, given an algorithm that overwrites, it is easy to derive the version that copies/shares.
13:46:46 <vincenz> Philippa: that's called a freelist
13:47:02 <vincenz> and most DMM's used that 
13:47:50 <Philippa> vincenz: 'sbetter if you can shortcut the free+alloc calls outright though, no?
13:49:28 <Philippa> (hell, my boyfriend figured out the idea of a freelist while I was talking to him about linked lists in general, and he doesn't code)
13:56:25 <vincenz> Philippa: it's only one compare two pointer accesses
13:59:43 <shapr> Anyone want to help me hack Oleg's HSXML into a blogging tool?
14:01:01 <shapr> entry1 = blog_template "Oleg's HSXML kicks butt" [p syntaxninja "has been pushing" planethaskell "recently..."]
14:01:01 <shapr> planethaskell = [[a (attr [href (URL "http://antti-juhani.kaijanaho.fi/planet-haskell/")]) "Planet Haskell"]]
14:01:06 <shapr> That sort of stuff works already.
14:02:32 <shapr> I'm just trying to rip out enough of RSS.hs to turn a (time, title, content) tuple into an RSS item.
14:02:39 <Pseudonym> How well does it serialise?
14:02:42 <Philippa> vincenz: you're assuming inlining there :-)
14:03:10 <shapr> Pseudonym: You mean generate html, or saving data to disk?
14:03:37 <Pseudonym> I mean converting this to XML/HTML/whatever, or to HSXML source.
14:04:07 <shapr> It creates dtd-compliant xml and html output.
14:04:14 <Pseudonym> Presumably since HSXML is a markup language, you can serialise to that rather than XML.
14:05:00 <shapr> Er, maybe so.
14:05:18 <shapr> I just got into this for the promise of type-safe blog entries.
14:06:12 <shapr> It works, I like that. It gives insane type errors, just as musasabi warned.
14:06:37 <shapr> Pseudonym: Have you seen Oleg's HSXML and RSS posts to the mailing lists?
14:09:05 <vincenz> Philippa: uninlining compilers are crap
14:09:36 <Pseudonym> A bit, yes.
14:09:47 <Pseudonym> I browsed them.
14:10:38 <shapr> I've been hacking around on the source a bit today: darcs get http://www.scannedinavian.com/~shae/hsxmlblog/
14:11:03 <shapr> Nothing really worthwhile yet, only small working code bits created while discovering how the system works.
14:11:30 <vincenz> shapr: what is it
14:11:54 <shapr> Stuff like the entry1 I pasted earlier. entry1 = blog_template "Oleg's HSXML kicks butt" [p syntaxninja "has been pushing" planethaskell "recently..."]
14:12:12 <shapr> It's Oleg's SXML done the typesafe way with Haskell.
14:12:45 <Philippa> vincenz: point. Even then I don't want a branch every time I want to overwrite a value though
14:20:04 <MarcWeber> In which package is Distribution.Compat.FilePath ?
14:22:31 <int-e> cabal, apparently http://www.haskell.org/cabal/release/rc/doc/API/Distribution.Compat.FilePath.html
14:25:42 <shapr> I want a button on my website that says "HTML checked by Hindley-Milner"
14:26:18 <shapr> Although that's really the inference system...
14:26:34 <Pseudonym> And it's not Hindley Milner.
14:26:39 <Pseudonym> Because it depends on typeclasses.
14:26:56 <shapr> Right, good point.
14:28:24 <MarcWeber> int-e: Ah. the module is hidden. That's why adding Cabal didn't work..
14:28:24 <Pseudonym> Oh, hang on.
14:28:33 <Pseudonym> "Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules."
14:28:47 <Pseudonym> I tell a lie.
14:28:55 <Pseudonym> I realise it's not done that way in practice, but still.
14:30:13 <Pseudonym> Where's lambdabot?
14:30:25 <shapr> No one knows.
14:30:33 <bolrod> no netsplits
14:30:35 <shapr> I think the hosting box went down.
14:30:53 <Pseudonym> @remember simonpj Haskell has become a laboratory and playground for advanced type hackery
14:32:59 <SyntaxNinja> heh
14:44:38 <shapr> Does RSS have some support for category tags?
14:56:46 * Philippa just had a silly thought and has a sneaking suspicion she doesn't have the ability to pull it off...
14:57:06 <Philippa> wonder how hard it is (ignoring inference) to play with linearity constraints in a pure type system?
14:57:50 <Pseudonym> You mean, like, faking linearity in Haskell?
14:58:22 <Philippa> no, I mean actually having linearity in a PTS (the lambda cube is a PTS, for example)
14:59:45 <Pseudonym> shapr: RSS 2.0 does have a category tag.
15:00:53 <Pseudonym> http://blogs.law.harvard.edu/tech/rss#ltcategorygtSubelementOfLtitemgt
15:01:35 <Pseudonym> Interestingly, the "category" tags are hierarchical.
15:02:55 <Pseudonym> Philippa, implementing linearity in a PTS might be easier if it was combinatorial.
15:03:39 <Pseudonym> One of the nice things about linear types is they're easier to think about if the intermediate language uses SK combinators instead of lambdas.
15:03:49 <Pseudonym> Well, I guess that's not a nice thing about linear types.
15:03:53 <Pseudonym> It's a nice thing about SK combinators.
15:04:13 <Pseudonym> B, C and I preserve linearity, and S and K don't.
15:04:30 <Pseudonym> (In general.)
15:04:42 <Philippa> no lambda would rather muck things up
15:04:53 <Pseudonym> How so?
15:05:26 <Philippa> okay, it wouldn't if you have types for all the combinators I guess
15:05:32 <Pseudonym> Right.
15:05:39 <Pseudonym> They could even be axioms. :-)
15:06:14 <Pseudonym> I guess, look up the logic for linear type systems and see if it makes sense.
15:07:31 <Philippa> it's more "does the dependent stuff screw everything up?"
15:09:28 <Philippa> I guess a related question would be "can you get all of that /and/ a sensible stage distinction?"
15:28:32 <vincenz> http://www.sciences.univ-nantes.fr/lina/atl/atlProject/presentation/
15:36:41 <dcnstrct> how fast does haskell code run once it's been compiled ? 
15:37:25 <dcnstrct> in other words do Haskell programs run faster or slower than java programs ? 
15:38:17 <mauke> some haskell programs are faster than some java programs
15:40:55 <Pseudonym> It depends on the program, the programmer and the implementation.
15:41:37 <dcnstrct> haskell code compiles directly to binary object code right ? 
15:41:41 <dcoutts> yes
15:41:43 <mauke> no
15:41:47 <Pseudonym> More or less.
15:41:54 <Pseudonym> Very few compilers do these days.
15:41:58 <dcoutts> heh, what a range of answers :-)
15:42:02 <Pseudonym> Most, at the very least, go via an assembler.
15:42:06 <bolrod> :D
15:42:17 <mauke> some implementations don't include a compiler
15:42:35 <dcoutts> dcnstrct, ghc compiles (indirectly) down to object code
15:42:43 <Pseudonym> Ask a vague question, get a vague answer. :-)
15:42:53 <dcoutts> dcnstrct, other haskell compiles use byte code like Java does
15:43:16 <Pseudonym> dcnstrct, why do you want to know, as a matter of interest?
15:43:18 <dcoutts> dcnstrct, and there are also some lightewight Haskell interpeters
15:43:21 <Philippa> JIT implementations for bytecode don't seem to be happening atm
15:43:38 <Pseudonym> Just for the record, compiling direct to binary object code is not a prerequisite for performance.
15:43:39 <Philippa> jhc compiles down to what should be reasonably fast C - it's not done yet though
15:43:58 <Philippa> well duh, dcnstrct asked for comparison to Java :-)
15:44:03 <Pseudonym> True.
15:44:07 <dcnstrct> Pseudonym, I'm commming from a relativly slow language... Ruby
15:44:11 <Pseudonym> Right.
15:44:26 <Pseudonym> If you like Ruby, but don't like its speed, you'll probably like Haskell.
15:44:36 <Philippa> in most cases you pretty much need a JIT-like solution to obtain really high performance without a reasonably-direct-to-binary compilation though
15:45:03 <dcnstrct> I love ruby! can't wait for the ruby virtual machine to be done, but I need something faster for the mean time and I never want to see java again.
15:45:18 <Pseudonym> Then you'll definitely love Haskell!
15:45:25 <Pseudonym> Haskell looks almost exactly nothing like Java.
15:45:29 <Pseudonym> Not even if you squint.
15:45:34 <dcnstrct> hehe
15:45:50 <Philippa> Pseudonym: there're braces and semicolons if you really really /insist/
15:45:55 <Pseudonym> Welcome!  You're one of us!
15:45:59 <Philippa> that's about it though
15:46:07 <dcnstrct> awww thanks guys.  
15:46:08 <Philippa> (and they're not exactly mandatory :-)
15:46:27 <Philippa> > map (+1) [1,2,3]
15:46:28 <Pseudonym> They mostly go away if you don't want them.
15:46:41 <Philippa> bah, the bot's down isn't it?
15:47:00 <jethr0_> [2,3,4]
15:47:04 <Philippa> dcnstrct: have a quick guess what the result of that'd be. If you get it, odds are you'll do fine :-)
15:47:25 <Philippa> or rather, if you got it before jethr0_ so kindly gave the answer :-)
15:47:28 <dcnstrct> [2,3,4]
15:47:29 <jethr0_> > pi
15:47:31 <jethr0_> 3
15:47:37 <Pseudonym> @version
15:47:37 <Philippa> > (\x.x x) (\x.x x)
15:47:57 <jethr0_> parse error on input `.'
15:47:58 <Philippa> (right, that should keep jethr0_ quiet for a few minutes ;-)
15:48:06 <mauke> jethr0_++
15:48:23 <Philippa> > (\x -> x x) (\x -> x x) -- picky bastard, I meant interpret lambda calculus for once :-)
15:48:43 * jethr0_ goes off to write a plugin for irssi to put these requests into ghci :)
15:48:50 <dcnstrct> [1,2,3].collect { |x| x+1 }
15:48:51 <mauke> Occurs check: cannot construct the infinite type: t = t -> t1
15:48:57 <Philippa> dcnstrct: if that term were to pass typechecking (which it won't), it'd loop forever
15:49:20 <jethr0_> Philippa: ya, i've never particularly liked the Y combinator. in the long run it always gives me headaches
15:49:24 <Philippa> dcnstrct: we write \x -> x + 1 instead, or just (+1) due to currying
15:49:29 <dcnstrct> well alright guys you provided me with all the info I needed.  Thanks alot. I'm going to go learn some haskell now, bbl
15:49:31 <Philippa> jethr0_: that's not Y though
15:49:35 <Philippa> that's just Omega
15:49:38 <jethr0_> close enough
15:50:10 <jethr0_> "Y f = f (Y f)", right?
15:50:51 <Philippa> that's just the definition of being a fixpoint operator
15:53:49 <Philippa> the one you can evaluate is \f.(\x.f (x x)) (\x.f (x x))
15:54:31 <jethr0_> so what you gave me was "Y id", right?
15:54:49 <jethr0_> no, nm
15:55:02 <twobitsprite> I'm trying to understand the '|' in this:
15:55:04 <twobitsprite> class Monad m => MonadState s m | m -> s where
15:55:52 <Pseudonym> @wiki FunDeps
15:56:00 <Pseudonym> Ah, right, no lambdabot.
15:56:07 <Pseudonym> I don't know if it's on the new wiki yet, but...
15:56:14 <Pseudonym> http://haskell.org/hawiki/FunDeps
15:58:47 <Philippa> jethr0_: Y id beta reduces to Omega, yes
16:07:22 <twobitsprite> I'm starting to feel like the haskell type syntax is getting a bit too overloaded...
16:12:07 <Pseudonym> Syntax is but a means to get at the cool semantics, surely.
16:12:25 <Pseudonym> Oh, $DEITY.  I'm sounding like Phil Wadler.
16:13:28 * dcoutts wishes lambdbot was here to @remember that quote
16:23:28 <dons> ?yow
16:23:28 <lambdabot> I have a TINY BOWL in my HEAD
16:24:05 <ncalexan> @index 
16:24:05 <lambdabot> bzzt
16:27:23 <jethr0_> @slap lambdabot
16:27:24 <lambdabot> why on earth would I slap lambdabot
16:28:15 <ncalexan> @keal
16:28:15 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
16:28:21 <ncalexan> @keal
16:28:22 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
16:28:31 <ncalexan> Ah, everything is back to normal.
16:32:18 <ncalexan> @keal
16:32:19 <lambdabot> my very first computer was an 80-0840
16:32:21 <ncalexan> @keal
16:32:21 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
16:40:54 <ihope> @type GHC.Base.unsafeCoerce#
16:40:54 <lambdabot> forall b a. a -> b
16:41:16 <ihope> > GHC.Base.unsafeCoerce# GHC.Base.unsafeCoerce# :: String
16:41:16 <lambdabot>  parse error on input `::'
16:41:26 <ihope> Hmm.
16:41:33 <ihope> > GHC.Base.unsafeCoerce# GHC.Base.unsafeCoerce# `asTypeOf` ""
16:41:33 <lambdabot>  parse error on input ``'
16:41:41 <ihope> Geh.
16:42:09 <ihope> <lambdabot>  Not in scope: `#'
16:43:22 <dons> ihope. that would be just too much 
16:43:46 * ihope types that into GHC and sends the error report to Microsoft
16:44:42 <ihope> Hmm. Typing # into GHC doesn't do much.
16:45:21 <dons> ?
16:45:24 <dons> Prelude> :set -fglasgow-exts
16:45:24 <dons> Prelude> GHC.Base.unsafeCoerce# GHC.Base.unsafeCoerce# `asTypeOf` ""
16:45:24 <dons> ""
16:45:32 <ihope> Whoa.
16:47:48 <ihope> GHC.Base.unsafeCoerce# "hello" "world" :: String
16:48:32 <dons> it lets you break the type system. it's quite easy to get a segfault if you do this, btw
16:49:26 <ihope> Hmm. Maybe I shouldn't coerce from an Integer into a Char.
16:49:28 <dons> Prelude> snd $ GHC.Base.unsafeCoerce# 1
16:49:32 <dons> zsh: segmentation fault (core dumped)  ghci -v0
16:49:34 <dons> welcome to C
16:50:03 <dons> ?type chr . fromIntegral 
16:50:04 <lambdabot> Not in scope: `chr'
16:50:08 <dons> is a better solution ;)
16:50:12 <ihope> :-)
16:50:42 <ihope> Okay. Coercing from Int to Char works much better.
16:51:05 <ihope> > maxBound :: Char
16:51:06 <lambdabot> '\1114111'
16:51:23 <dons> it all depends on the underlying representation once you do this
16:51:27 <dons> just as it does in C
16:51:37 <ihope> So how come unsafeCoerce# returned \1492384?
16:51:48 <dons> it's some pointer value, probably
16:51:59 <dons> just an arbitrary chunk of memory in the closure for that value
16:52:30 <dons> ihope reaches level 4 hacker
16:53:30 <ihope> \id So what happened to this?
16:53:57 <dons> ?id can't use \
16:53:58 <lambdabot> can't use \
16:54:02 <dons> too many complaints
16:54:10 <dons> so you get @ or ?
16:54:17 <ihope> Conflicts with lambdas?
16:54:19 <dons> yup
16:54:25 <dons> people paste in lambdas
16:54:29 <ihope> Sort of ironic for a lambdabot.
16:54:50 <dons> hehe
16:54:53 <dons> I agree
16:54:58 <dons> I'd prefer people stop pasting in lambdas ;)
16:55:12 <ihope> /So what's wrong with this? Sure, it's hard to use, but...
16:55:36 <dons> hard to use
16:55:41 <dons> it conflicts even worse
16:55:47 <ihope> With what?
16:55:58 <dons> irssi (and other) meta char
16:56:14 <dons> weren't you going to write me a lambdabot plugin, btw?
16:56:27 <ihope> No...
16:56:58 <dons> I spent all weekend cleaning up lambdabot, and adding an offline shell mode -- just to make it easier  to hack on
16:57:12 <ihope> Oh, right, let's see here...
17:02:15 <dons> I've found since I changed my vim syn highlight code to highlight tabs and end-of-lines spaces in yellow, I edit them out :)
17:02:41 <ihope> :-)
17:02:52 <ihope> > reverse "^_^"
17:02:53 <lambdabot> "^_^"
17:02:56 <ihope> Hmm.
17:04:35 <ihope> No instance for (Show (String, String, String, String, String, String))
17:05:19 <dons> hehe
17:05:32 <dons> stick it in a list
17:06:55 <ihope> Hmm, it doesn't like to coerce ((a,b),c) into (a,(b,c)).
17:07:46 <ihope> So I have a bunch of libncurses stuff in the Cygwin folder. What do I do with what to stick it in Haskell?
17:09:48 <dons> can you elaborate more?
17:10:00 <dons> you want   to use one of the curses bindings already written in Haskell?
17:10:11 <ihope> Is there one?
17:10:16 <dons> several
17:10:22 <dons> try the Curses.hsc here: www.cse.unsw.edu.au/~dons/hmp3.html
17:11:50 <ihope> Hmm, sounds good. Thanks.
17:12:27 <dons> I've been writing curses apps in Haskell for the last couple of years :)
17:12:44 <dons> the hmp3 curses binding is a small, portable one. it works with old curses as well as ncursees
17:12:53 <dons> but it uses fps, 
17:13:03 <dons> if that's a problem, then try hscurses
17:13:09 <dons> ?where hscurses
17:13:09 <lambdabot> I know nothing about hscurses.
17:13:21 <dons> ?google hscurses stefan wehr
17:13:22 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
17:13:25 <dons> there
17:13:35 <dons> ?where+ hscurses http://www.informatik.uni-freiburg.de/~wehr/haskell/
17:13:35 <ihope> "The misfortune intended by curses can range from illness, and harm, to even death." Hmm... is there an alternative to using curses at all?
17:13:35 <lambdabot> Done.
17:13:54 <dons> not really, if you want to build console aps
17:14:07 <dons> it's pretty easy to use, 
17:14:17 <dons> but we could do with a combinator library on top of it
17:14:26 <dons> something like Text.PrettyPrint for curses screens
17:14:35 <dons> I started on such a thing in hmp3, but its not finished yet
17:17:28 <ihope> > let {} in True
17:17:29 <lambdabot> True
17:18:35 <dons> > let in True
17:18:36 <lambdabot> True
17:18:40 <dons> little known fact :}
17:20:10 <ihope> Whoa!
17:21:20 <Pseudonym> > () where {}
17:21:21 <lambdabot> ()
17:21:26 <Pseudonym> > () where
17:21:27 <lambdabot> ()
17:22:06 <dons> it's the haiku of haskell code
17:22:18 <ihope> :-)
17:22:19 <ihope> 23 = 22+1 = 2*11+1 = (1+1)*11+1 = (1+1)*(10+1)+1 = (1+1)*(2*5+1)+1 = (1+1)*((1+1)*5+1)+1 = (1+1)*((1+1)*(4+1)+1)+1 = (1+1)*((1+1)*(2*2+1)+1)+1 = (1+1)*((1+1)*((1+1)*(1+1)+1)+1)+1
17:22:25 <ihope> Yes, I skipped a step. So sue me.
17:22:30 <Pseudonym> > () where leaves = "brown"
17:22:31 <lambdabot> ()
17:22:51 <ihope> > True where True = False
17:22:52 <lambdabot> True
17:23:45 <dons> > True where 1+1 = 3
17:23:46 <lambdabot> True
17:24:14 <ihope> > 3+4 where 1+1 = 3
17:24:15 <lambdabot>  Non-exhaustive patterns in function +
17:24:40 <ihope> Man who run in front of car get tired. Man who run behind car get exhausted.
17:26:44 <Pseudonym> > let { leaves fall = "gently" ; river = "babbles" } in (\rhythm -> undefined) "nature"
17:26:45 <lambdabot> Add a type signature
17:26:48 <Pseudonym> Damn.
17:26:56 <Pseudonym> > let { leaves fall = "gently" ; river = "babbles" } in (\rhythm -> undefined) "nature" :: ()
17:26:57 <lambdabot> Undefined
17:27:00 <Pseudonym> There you go.
17:27:24 <dons> not sure you even needs those { }
17:27:37 <dons> it's truly lovely though
17:27:43 <ihope> :-)
17:27:43 <Pseudonym> Nah, but I wanted a semicolon after the first line.
17:27:57 <ihope> > let leaves fall = "gently" ; river = "babbles" in (\rhythm -> undefined) "nature" :: ()
17:27:58 <lambdabot> Undefined
17:28:07 <Pseudonym> > True
17:28:08 <lambdabot> True
17:28:34 <Pseudonym> Your next exercise is to write a Haskell haiku that results in the string "haiky".
17:28:39 <Pseudonym> "haiku"
17:32:27 <ihope> > {- an old pond--the sound of a frog jumping into -} "haiku"
17:32:27 <lambdabot> "haiku"
17:32:45 <vincenz> l
17:33:18 <Pseudonym> Three syllables short.
17:33:22 <Pseudonym> And cheating.
17:33:47 <ihope> > {- an old pond--the sound of a frog jumping into -} "haiku" -- syllables :-)
17:33:48 <lambdabot> "haiku"
17:33:59 <Pseudonym> That's even more surreal.
17:36:21 <ihope> > let haiku = "haiku"; haiku = tail haiku in haiku ++ drop 5 haiku
17:36:22 <lambdabot>   Conflicting definitions for `haiku'
17:36:22 <lambdabot>   In the binding group for: haiku, haiku
17:36:41 <ihope> > let haiku () = "haiku"; haiku () = tail haiku in haiku () ++ drop 5 (haiku ())
17:36:42 <lambdabot> Couldn't match `[Char]' against `() -> [Char]'
17:36:55 <ihope> > let haiku () = "haiku"; haiku () = tail haiku () in haiku () ++ drop 5 (haiku ())
17:36:55 <lambdabot> Couldn't match `[a]' against `t -> t1'
17:37:02 <ihope> > let haiku () = "haiku"; haiku () = tail (haiku ()) in haiku () ++ drop 5 (haiku ())
17:37:03 <lambdabot>   Warning: Pattern match(es) are overlapped
17:37:03 <lambdabot>      In the definition of `haiku': haiku () = ...
17:37:09 <ihope> Grr.
17:40:24 <ihope> > (1+1)*((1+1)*((1+1)*(1+1)+1)+1)+1
17:40:26 <lambdabot> 23
17:41:11 <ihope> data Natural = One | Add Natural Natural | Multiply Natural Natural -- a bad way to design a natural number.
17:45:44 <dons> hehe, "Subject: IT advisory: Day Light Savings and Calendar issues this week"
17:46:34 <ihope> So how big's an Int#?
17:47:08 <ihope> And is there anything with kind * -> #?
17:47:09 <dons> 32 bits on a 32 bit machine
17:47:17 <dons> 64 on a 64 bit machine
17:47:47 <ihope> Makes sence.
17:47:49 <dons> * to #, hmm.
17:47:57 <ihope> Oops! # -> *
17:48:02 <dons> we don't have hoogle kind search , do we
17:48:22 <ihope> @hoogle # -> *
17:48:22 <lambdabot> hoogle: Unexpected character when parsing: > -> *
17:48:22 <lambdabot>  
17:48:23 <dons> oh, lots of things. all the constructors
17:48:33 <ihope> Hmm.
17:48:33 <dons> ?kind GHC.Int.I#
17:48:34 <lambdabot> Not in scope: type constructor or class `GHC.Int.I#'
17:48:49 <ihope> ?kind GHC.Base.I#
17:48:50 <lambdabot> Not in scope: type constructor or class `GHC.Base.I#'
17:48:53 <ihope> ?kind GHC.Prim.I#
17:48:53 <lambdabot> Not in scope: type constructor or class `GHC.Prim.I#'
17:49:25 <dons> ?kind GHC.Num.I#
17:49:26 <lambdabot> Not in scope: type constructor or class `GHC.Num.I#'
17:52:44 <ihope> Meh. data UnboxedIntThingy = UnboxedIntThingy Int#
17:53:52 <dons> oh, silly me. of course there's no bulit in type with kind # -> *
17:54:11 <dons> ?kind (->)
17:54:12 <lambdabot> ?? -> ? -> *
17:54:16 <dons> is close
17:54:32 <dons> ?kind (->) 7
17:54:33 <lambdabot> Only unit numeric type pattern is valid
17:54:36 <dons> ?kind (->) Int
17:54:37 <lambdabot> ? -> *
17:54:46 <dons> ?kind (->) Int :: # -> *
17:54:47 <lambdabot> parse error on input `::'
17:54:51 <dons> ?kind (->) Int : # -> *
17:54:52 <lambdabot> parse error on input `:'
17:54:55 <dons> no kind annotations
17:55:05 <ihope> ?kind 1
17:55:06 <lambdabot> *
17:55:09 <ihope> Hmm.
17:55:13 <ihope> What's it for?
17:55:17 <dons> what''s whatT?
17:55:24 <dons> oh, the type 1
17:55:30 <dons> for fun ,I think
17:55:34 <ihope> Heh.
17:55:37 <ihope> > 1 :: 1
17:55:38 <lambdabot>  add an instance declaration for (Num GHC.Base.Unit)
17:55:38 <lambdabot>   In the expression: 1 :: 1
17:55:38 <lambdabot>   In the definition of `sjy': sjy = 1 :: 1
17:55:41 <dons> type hackers sometimes use 1 for (), iirc
17:56:04 <ihope> ?kind 0
17:56:04 <lambdabot> Only unit numeric type pattern is valid
17:56:19 <dons> there you go
17:56:34 <ihope> So data Integer = S# Int# | J# Int# ByteArray#
17:57:41 <dcoutts> dons, you're a cmm hacker; I sent in a patch to add static branch prediction annotations
17:57:57 <dcoutts> just for fun really, I don't expect it'll make much performance difference
17:58:15 <ihope> So Int : Integer :: Word : Wordeger?
17:58:29 * ihope shrugs
17:58:49 <dons> oh. cool dcoutts :)
17:58:51 <dcoutts> dons, I added the ability to specify predictions but the only case where I actually added annotations was for stack & heap checks
17:59:31 <dcoutts> you won't see the patch for a couple days because ghc-cvs blocks emails bigger than 40k and the current darcs context for any patch is >40k
17:59:44 <dcoutts> so my patches get held for moderation :-(
18:00:12 <dcoutts> someone needs to tag & darcs optimise
18:00:46 <dcoutts> or come to think of it, why does the darcs context have the full patch message rather than just the one line patch name and the patch hash?
18:02:41 <ihope> So it looks like if you want unboxed stuff, you have to use a lot of unboxed stuff.
18:02:46 <dons> yeah, a hashed contxt might be useful
18:03:03 <dons> ihope, easier to use strictness annotations and check the compiler with -ddump-simpl
18:03:07 <dons> you end up with the same result
18:03:17 <dons> (usuually)
18:03:30 <dons> check the ghc performance page on unboxing on the wiki
18:03:39 <ihope> What's this compiler checking thing?
18:04:31 <dons> look at what ghc does with the code -- read its internal Core 
18:04:40 <dcoutts> dons, so when is ghc moving to making full use of cmm? ie cmm stacks and everything?
18:04:47 <dons> there's a tutorial on the performance page
18:05:07 <dons> dcoutts, I'm not sure it is. maybe once the cmm tools are more portable and available?
18:05:20 <dons> spjj wrote something on this a month or so ago
18:05:33 <dcoutts> dons, well ghc already has a cmm implementation
18:05:51 <dons> some of one, yep
18:05:53 <dcoutts> dons, oh it can't move to that til we have 'real' cmm , not via C/gcc
18:06:42 <dcoutts> that's going to be a pain for portability
18:07:00 <dcoutts> we're not going to have qcmm generate code on that many arches
18:07:18 <ihope> @hoogle Int# -> Word#
18:07:18 <lambdabot> hoogle: Unexpected character when parsing: > -> Word>
18:07:18 <lambdabot>  
18:07:25 <ihope> Ow.
18:08:37 <ihope> @index +
18:08:37 <lambdabot> Prelude
18:09:41 <ihope> Um. So are the operations on Integers actually defined anywhere in Haskell source, or are they abstract?
18:09:55 <ihope> In GHC, I mean.
18:10:28 <Pseudonym> Well, obviously you're talking about an instance of Num.
18:10:30 <dons> abstract?
18:10:39 <Pseudonym> So in that sense it's abstract.
18:10:51 <dons> module GHC.Num where ...
18:11:44 <ihope> ...instance Num Integer where...
18:11:56 <ihope> @google "instance num integer where"
18:12:00 <lambdabot> http://www.zvon.org/other/haskell/Outputprelude/Num_c.html
18:12:01 <dons> its in GHC.Num
18:13:07 <ihope> Cool. Now would I find the actual declarations anywhere?
18:14:03 <dons> grab the src and read iit :)
18:14:09 <dons> ?fptools
18:14:09 <lambdabot>  not available
18:14:16 <dons> ?fptools Data.List
18:14:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:14:20 <dons> from there
18:14:56 <dcoutts> dons, so what should my next ghc patch be? :-)
18:15:25 <dons> ah, well. hmm
18:15:34 <dons> embedded ghci support ??
18:15:42 <dons> oh, Lemmih's working on that
18:15:45 <dons> how about a smaller ghc?
18:15:59 <dons> a cabaalised build system...
18:16:00 <dcoutts> hmm you mean like stripping libs
18:16:04 <dcoutts> ah right yes
18:16:15 * Lemmih votes for the cabalized build system.
18:16:32 <dcoutts> at least for non-base
18:16:37 <dons> ?quit in-tree hoogle
18:16:51 <ihope> dons: how would I get that instance declaration from that?
18:16:54 <dcoutts> what about a dynamically linked rts?
18:17:04 <dons> oh yeah, we could improve the dyn linking
18:17:11 <dons> that would also be good if we ever want to embed ghci
18:17:17 <dons> ?version
18:17:17 <lambdabot> lambdabot 3p364, GHC 6.4.1 (Linux i686 3.20GHz)
18:17:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:17:21 <dons> ?hoogle map
18:17:22 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:17:22 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
18:17:22 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
18:17:25 <dons> good bot
18:17:30 <dons> run @pl over the ghc src ?
18:17:33 <dons> ;)
18:17:35 <dcoutts> I don't undestand why we can't have genuine shared libs for ghc
18:17:42 <dcoutts> at least on ELF systems
18:17:50 <dons> we can on the mac. but it needs hacks to Linker.c, iirc
18:17:54 <dons> otherwise ghci stops working
18:18:06 <dcoutts> because ELF shared lib semantics are almost exactly the same as static libs
18:18:21 <dcoutts> ie you don't even need position independent code
18:18:49 <dcoutts> the ELF spec goes out of it's way to preserve the C static linking model
18:19:05 <dcoutts> you don't have to declare dynamic entry points like in a dll
18:19:28 <dons> you could ask wolfgang the details. he's done it on the mac, and made some progress on linux
18:19:32 <dons> x86
18:19:41 <dcoutts> he's doing the PIC approach
18:19:46 <dons> yep
18:19:47 <dcoutts> I believe, ie properly
18:19:52 <ihope> Oh, how helpful. (+) = addIntegers
18:20:12 <dcoutts> but why can't we do it now? I don't get it. Of course non-PIC .so will incur a bigger linking overhead
18:20:27 <dcoutts> since ld.so will need to fixup lots of "textrels"
18:20:32 <dons> ihope, it's all in GHC.* except primops which are in compiler/prelude/primops.txt.pp
18:20:50 <dcoutts> but who cares? it'd be much quicker than ghci's .o linker
18:20:58 <dons> some of those in turn are implemented in C in the rts/gmp or in the nativegen/
18:21:19 <dons> yeah. it would be. but maybe go back and read the ghci doc about why we needed our own linker in the first place
18:21:36 <dons> i can't recaall the details -- other than tat it involved rewriting binaries
18:22:05 <dcoutts> well it's not portable to non-ELF systems
18:22:14 <dcoutts> you'd need the ghci linker for win32
18:22:31 <dcoutts> because dll's really are different from win32 .lib files
18:22:40 * dons -> uni
18:22:49 <dcoutts> bye, dons 
18:23:56 <SamB> ghci doesn't take ar files anyway
18:24:07 <SamB> (which .lib files are)
18:27:19 <ihope> Hmm, this looks promising.
18:27:35 <ihope> I don't understand it, but still...
18:29:35 <dcoutts> SamB, it could be made to do so, it just needs code in Linker.c
18:29:57 <dcoutts> ar files are trivial to read/write
18:30:07 * dcoutts has written Haskell code to do both
18:31:10 <orbitz> ohh liste ocmprehsion makes my phi function so much sexier!!
18:31:51 <ihope> :-)
18:32:03 <orbitz> phiVals n = [x | x <- [1..n], euclidGCD x n == 1] 
18:32:03 <orbitz> whee
18:33:25 <SamB> wouldn't it be slower though?
18:33:36 <SamB> might save disk space, I guess
18:33:45 <dcoutts> SamB, than .o file? I shouldn't think so
18:34:09 <ihope> Hmm, what's the definition of Int?
18:34:25 <SamB> data Int = I# Int# ?
18:34:41 <SamB> @libsrc GHC.Int
18:34:42 <lambdabot> GHC.Int not available
18:35:33 <ihope> @libsrc GHC.Base
18:35:34 <lambdabot> GHC.Base not available
18:37:29 <ihope> > let phiVals n = [x | x <- [1..n], euclidGCD x n == 1] in phiVals 10
18:37:29 <lambdabot>  Not in scope: `euclidGCD'
18:37:36 <ihope> > let phiVals n = [x | x <- [1..n], gcd x n == 1] in phiVals 10
18:37:37 <lambdabot> [1,3,7,9]
18:37:54 * ihope claps
18:38:57 * ihope goes to bed
18:45:26 <ihope> Say... suppose that in module X, the type Y is made to be an instance of Z. If Y is exported, does the instance declaration come with it?
18:50:41 <sudoer> hi anyone built ghc from darwinports?
18:51:09 <sudoer> I get this error when running port install ghc: Error: Target com.apple.build returned: shell command "DYLD_FALLBACK_LIBRARY_PATH=/opt/local/lib make all" returned error 2
18:51:31 <SamB> strange indeed
18:51:44 <SamB> what shell?
18:53:33 <sudoer> tcsh
18:53:56 <SamB> maybe GHC's makefile doesn't like tcsh?
18:54:41 <ihope> @pl module Queue( module Stack, enqueue, dequeue ) where
18:54:42 <lambdabot> module Queue (module Stack, enqueue, dequeue) where
18:54:52 <sudoer> is the a way to "clean the port" so I can try again?
18:55:08 <SamB> make clean?
18:55:53 <sudoer> I thin k it might have been killed while installing ghc from darwinports
18:55:57 <SamB> note that I only used BSD for about a week nearly three years ago
18:56:35 <ihope> Hmm... HydraIRC looks like an IDE at first glance.
18:56:54 <SamB> does it have many heads?
18:57:52 <ihope> Well, it has many of something.
18:58:09 <sudoer> SamB, this is mac
18:58:31 <ihope> I think it wouldn't be very inaccurate to say it has many heads.
18:58:57 <SamB> sudoer: well, ports is from BSD, no?
18:59:11 <sudoer> yeah, its similiar
19:01:18 * ihope *really* goes to bed this time
19:31:48 <dons> re
19:35:34 <Korollary> good @localtime
19:38:04 <twobitsprite> so... a State monad has two parts... a value and a state...
19:38:46 <twobitsprite> State 4 >>= f -- passes in the value?
19:39:30 <twobitsprite> no..
19:39:37 <dons> a state monad has two parts, the expression being evaluated, and the state parameter being threaded around without you noticing
19:39:50 <dons> think of the state component as an extra argument to all the code
19:40:03 <twobitsprite> right...
19:40:06 * twobitsprite ponders
19:40:21 <twobitsprite> what do you mean by "expression being evaluated"?
19:40:49 <dons> there's some fragment of code currently being evaluated, right?
19:40:55 <dons> i.e. putStrLn "foo" 
19:40:59 <dons> is evaluated inside the IO monad
19:41:13 <twobitsprite> right
19:41:48 <dons> so, in any other monad, you evaluate the expression, but it has access to any extra 'arguments' carried invisibly around inside the monad for you
19:41:58 <dons> so instead of passing the state as an explicit argument to all the functions that use it
19:42:03 <dons> the monad does the passing for you
19:42:17 <dons> and you access the argument when you need it with, say, `get'
19:42:29 <twobitsprite> so... State 4 >>= (\x -> get + 4) ??
19:42:40 <twobitsprite> would yield State 8?
19:42:58 <dons> um. depends on what monad. in a state monad the extra state is like an extra argument, yes.
19:43:14 <twobitsprite> isn't the monad "State"?
19:44:10 <dons> @type Control.Monad.State.State 4 >>= id
19:44:11 <lambdabot> forall s b.
19:44:11 <lambdabot>              (Num (s -> (Control.Monad.State.State s b, s))) =>
19:44:11 <lambdabot>              Control.Monad.State.State s b
19:44:24 <dons> so that's not quite right yet, I think
19:45:27 <twobitsprite> I wish haskell more introspective powers...
19:46:13 <twobitsprite> so I could play with it and see exactly what was going on
19:48:50 <dons> inside ghci you can
19:48:59 <dons> ghci is good for exploring the effects of various things
19:49:05 <twobitsprite> in the definition of the Monad instance for State, it looks like bind uses the argument of the State monad as a function
19:49:24 <dons>     m >>= k  = State $ \s -> let
19:49:25 <dons>         (a, s') = runState m s
19:49:25 <dons>         in runState (k a) s'
19:49:26 <dons> ?
19:49:33 <twobitsprite> well... I always try to evaluate something, just to see what I get and I always seem to get "no instance for Show" errors...
19:49:46 <dons> so yeah, this is what I mean about the extra invisible state parameter being threaded around for you
19:49:52 <twobitsprite> (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s' 
19:49:52 <dons> ah, right
19:50:01 <dons> you need to runState to get the result out of the monad
19:50:09 <dons> i.e. runState (...) >>= print 
19:50:12 <dons> could be useful
19:50:16 <twobitsprite> ahh
19:50:41 <dons> good trick, using print
19:50:59 <dons> and when the type doesn't seem to be showable, you can get partway there by using :t
19:51:02 <dons> until things work
19:51:02 <twobitsprite> Couldn't match `(->) s' against `IO'
19:51:24 <dons> it's in the (-> s) state? so something's not fully applied
19:51:30 <dons> some argument missing?
19:51:52 <twobitsprite> runState (State 4) >>= print
19:51:55 <twobitsprite> > runState (State 4) >>= print
19:51:56 <lambdabot>  Not in scope: data constructor `State'
19:52:08 <twobitsprite> > runState (Control.Monad.State.State 4) >>= print
19:52:09 <lambdabot>  Not in scope: data constructor `Control.Monad.State.State'
19:52:32 <dons> you won't be able to eval things like that in lambdabot
19:52:37 <dons> though Monad.State would be safe
19:52:40 <dons> i'll add it..
19:54:47 <twobitsprite> anyways... I run that in ghci and get the IO error
19:55:26 <Cale> State can't be applied to 4
19:55:32 <twobitsprite> I also don't understand that it looks like "State" accepts two arguments, but only lets you provide one
19:55:34 <dons> Prelude Control.Monad.State> :t State    
19:55:34 <dons> State :: (s -> (a, s)) -> State s a
19:55:40 <Cale> and runState doesn't result in an IO action
19:55:40 <dons> see its type ^^
19:55:51 <dons> return .. 
19:56:06 <twobitsprite> so, state accepts a function?
19:56:21 <dons> a function from state to new state and a value
19:56:21 <Cale> you shouldn't really have to use the State constructor directly
19:56:24 <Cale> @type Control.Monad.State.runState
19:56:25 <lambdabot> forall s a.
19:56:25 <lambdabot>            Control.Monad.State.State s a -> s -> (a, s)
19:56:43 <dons> ?quit more patches all over the shop
19:57:07 <Cale> mixing it up again with the command prefixes, I see :)
19:57:16 <dons> only ? and @
19:57:25 <dons> ? has been valid since \ came in.
19:57:31 <dons> but \ got disbarred
19:57:57 <palomer> hullo
19:58:04 <twobitsprite> hey palomer 
19:58:37 <dons> > fst $ runState (State (\s -> (7,s))) ()
19:58:38 <lambdabot> 7
19:58:39 <dons> good
19:58:48 <dons> you get state monads in @eval now
19:59:15 <dons> ?version
19:59:15 <twobitsprite> right on
19:59:15 <lambdabot> lambdabot 3p368, GHC 6.4.1 (Linux i686 3.20GHz)
19:59:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:59:22 <dons> once it hits 400, I'll release v4.0
19:59:36 <dons> it'll be shiny
19:59:43 <twobitsprite> yay
20:00:16 <dons> Cale, lambdabot has an offline mode now, enabling editor bindings (currently vim) and much faster dev turnaround
20:00:22 <dons> if you want to hack...
20:00:24 <Cale> > let inc = do x <- get; put x+1 in evalState (do inc; inc; get) 0
20:00:25 <lambdabot>  add an instance declaration for (Num (State s ()))
20:00:25 <lambdabot>   In the result of a 'do' expression: (put x) + 1
20:00:25 <lambdabot>   In the definition of `inc':
20:00:29 <Cale> > let inc = do x <- get; put (x+1) in evalState (do inc; inc; get) 0
20:00:30 <lambdabot> 2
20:00:44 <Cale> dons: cool
20:00:52 <twobitsprite> vim mode lambdabot?
20:01:00 <dons> sort of
20:01:14 <twobitsprite> canI do :@type ...
20:01:15 <dons> you can call lambdabot commands from vim, passing the current region/line as input
20:01:18 <dons> yep
20:01:19 <dons> and @pl
20:01:22 <dons> for example
20:01:31 <twobitsprite> nice... I'll have to check that out
20:01:34 <twobitsprite> is this documented?
20:01:34 <Korollary> Why is cabal so unreachable from haskell.org main page?
20:01:50 <dons> documented. yes.
20:01:53 <dons> somewhat
20:01:53 <Cale> twobitsprite: you can also get the equivalent of @type from ghci
20:02:04 <dons> since lambdabot just calls ghci anyway..
20:02:11 <Cale> :t whatever
20:02:32 <Cale> also, :i whatever is useful too
20:02:32 <twobitsprite> Cale: of course, I was just using type as a for-instance
20:02:44 <dons> lambdabot will be the technology convergence platform for Haskell  :S
20:02:45 <Cale> okay
20:02:54 <Cale> dons: heh
20:03:51 <twobitsprite> dons: does lambdabot come with a .vim file?
20:04:10 <dons> it's not such a tight binding. do you know enough vim script to write the whole binding in vim?
20:04:15 <dons> currently I just use a shell script
20:04:42 <twobitsprite> does it currently just work as a commandline prog?
20:05:00 <twobitsprite> #lambdabot -pl ...
20:05:29 <Korollary> isn't pointfree available as an individual module?
20:06:01 <Korollary> it should be easily turned into an executable that you can use with  shell-command-on-region in Emacs.
20:08:05 <dons> twobitsprite, yes
20:08:47 <dons> the idea is that, yes, you can use lambdabot/pl from shell-regoin thingies
20:08:51 <dons> this is how the vim mode works
20:09:05 <dons> call lambdabot with: echo "pl $DECL" | ./lambdabot | sed '$d;s/lambdabot> //'
20:09:10 <dons> passing the region in $DECL
20:09:38 <dons> $ ./lambdabot 
20:09:38 <dons> lambdabot> pl map (\x -> x + x + x) [1..10]
20:09:38 <dons> map ((+) =<< join (+)) [1..10]
20:09:55 <twobitsprite> I see
20:10:38 <twobitsprite> have you asked around in #vim?
20:10:52 <dons> nah. not really interested :} using a shell script works fine.
20:10:57 <dons> you just hit: !!pl
20:11:06 <twobitsprite> there's a standard way to pass a region of text into another program's stdin
20:11:17 <twobitsprite> right on
20:11:17 <dons> well, there is in vim.
20:11:27 * dons -> meeting
20:11:56 <twobitsprite> @localtime dons
20:11:58 <lambdabot> Local time for dons is Tue Mar 28 14:12:23 2006
20:15:22 <Lemmih> Guys, know what 'zonking' is?
20:16:02 <Korollary> sounds fun
20:16:36 <Lemmih> n/m found an online dictionary.
21:07:04 * shapr yawns
21:07:48 <shapr> good morning #haskell!
21:13:47 <akemp> Morning?  It's night!
21:17:36 <shapr> Depends on your timezone I guess.
21:18:33 <akemp> @localtime shapr
21:18:35 <lambdabot> Local time for shapr is Tue Mar 28 07:18:12 2006
21:18:39 <akemp> @localtime akemp
21:18:40 <lambdabot> Local time for akemp is Mon Mar 27 21:17:45
21:29:41 <shapr> akemp: Hey, did you get a chance to look at that recdo.ps.gz paper?
21:33:02 * shapr starts adding Python tools to lambdabot
21:39:58 <Lemmih> dcoutts: ping.
21:49:48 * shapr hops so fast it looks like brownian motion!
21:52:44 <shapr> Hiya ccshan, how's the current continuation?
21:53:52 <ccshan> The current continuation is delimited by increasingly many prompts
21:54:34 <ccshan> (:  I'm suddenly wondering if I can teach an undergrad PL course using GPU as the excuse -- do you know anything about compiling functional languages into GPUs?
21:55:44 <Korollary> excuse for what?
21:56:12 <ccshan> excuse for having less mutable state, first and foremost
21:56:46 <goltrpoat> off-topic, but what the hell is an intensional semantics?
21:56:49 <shapr> Well, there's Nvidia's Cg language...
21:57:03 <Korollary> goltrpoat: havent heard of that one.
21:57:06 <shapr> And there's the parallel arrays in GHC.
21:57:18 <ibid> is there a use for planet given that we have sequence?
21:57:18 <ccshan> Is it easier to compile a pure language into a shading language or GPU code than to compile a language with rampant mutable state?
21:57:32 <ccshan> goltrpoat: what's the context?
21:57:49 <shapr> ccshan: It is clearly easier to turn nested data parallel arrays into GPU code.
21:57:54 <ccshan> shapr: i haven't noticed ghc parallel arrays! thanks
21:58:10 <shapr> Thing is, they currently don't dump to Cg code.
21:58:17 <goltrpoat> ccshan:  extensional vs intensional denotational semantics.  i'm reading about CDS0, which i hadn't heard about until about ten minutes ago, and it's rather over my head
21:58:29 <Korollary> ccshan: it's easy to compile imperative code into a general purpose cpu, too. Perhaps you mean is it easier to optimize?
21:59:11 <goltrpoat> shaders are functional by nature..  i think the whole trend of retrofitting C to shader semantics is a bit silly
21:59:17 <shapr> ccshan: btw, does Oleg ever drop by here?
21:59:37 <rasfar> categorical semantics is extensional, maybe it's non-categorical?
21:59:39 <Korollary> goltrpoat: it's done because the target audience writes a lot of c++
21:59:57 <ccshan> shapr: it's okay to not dump to Cg code -- I just want to a toy functional language (very toy is ok) such that I can easily write (1) an interpreter for it in Haskell, (2) a non-optimizing (but clearly optimizable) compiler for it into even just a fake, simplified GPU simulation
22:00:07 <ccshan> goltrpoat: in programming languages or natural languages?
22:00:27 <shapr> ccshan: Oh that'll be straightforward.
22:00:33 <ccshan> Korollary: by GPU I meant a graphics processing unit; does this clarify?
22:00:34 <goltrpoat> ccshan:  programming languages, but i think it may have been lifted from linguistics
22:00:54 <Korollary> ccshan: I knew what gpu stood for
22:00:55 <ccshan> shapr: I don't think so -- he has much superior work ethics (:
22:01:06 <shapr> ccshan: haha, good answer
22:01:45 <shapr> #haskell is sort of like the infinite coffee break.
22:02:12 <dons> ccshan, hey. we have a student here at unsw looking at compiling haskell to a gpu
22:02:19 <ccshan> shapr/korollary: Is it easier or more optimizable to compile the lambda calculus without assignment into GPU code than the lambda calculus with assignment?
22:02:36 <ccshan> dons: cool, please say more
22:02:44 <dons> since gpus provide map and fold primitives, i think?
22:02:49 * shapr has no clue
22:02:58 <Korollary> it depends on the gpu's instruction set.
22:03:00 <shapr> I'd look at Manuel Chakravarty's work on parallel arrays.
22:03:04 <dons> let me find some references
22:03:57 <ccshan> goltrpoat: I'm not sure what the precise definition is, but intensional tends to mean that you can distinguish "identical" values -- i.e., objects have identity
22:04:03 <dons> I think the work came out of an invited talk at popl 05, from http://graphics.stanford.edu/~hanrahan/
22:04:19 <goltrpoat> dons:  there is an obvious map (a fragment shader takes a list of fragments and writes out a list of fragments), what's the fold though?
22:04:44 <dons> I'd have to read the Brook for GPUs paper again
22:04:50 <ccshan> dons: oops, I should have gone to that talk
22:05:05 <goltrpoat> dons:  unless you're talking about multipass, or a "fold" on shader constants, or streams, or something
22:05:12 <goltrpoat> but that's sort of limited
22:05:35 <ccshan> Korollary: is there a plausible toy GPU instruction set for which the lambda calculus without assignment is easier to compile? (:
22:05:47 <dons> from memory, the brook for gpus paper introduces a 'reduce' that compiles fairly straight-forwardly to gpu code
22:05:58 <dons> but as yet, I'm not aware of any work on actually compiling a functional language onto a gpu
22:05:59 <ccshan> shapr: "Manuel Chakravarty's work on parallel arrays" is the GHC extension, right?
22:06:11 <dons> though there must be 4 or 5 groups out there with some interest in it
22:06:23 <shapr> Yeah, though the separate work on array fusion is one of your 'clearly optimizable' thunks.
22:06:47 <ccshan> goltrpoat: I noticed that some GPU languages support "reduce" for associative operations (is it Brook?) -- is there some hardware support for that? like summing up a stream of numbers?
22:07:09 <shapr> ccshan: If you want to really get your class excited, you could point out that this approach is perfectly designed for the Cell cpu as well.
22:07:22 <shapr> At least, I'm assuming they're enthusiastic geeks :-)
22:07:24 <ccshan> shapr: looking it up
22:07:26 <dons> ccshan, have you read: http://graphics.stanford.edu/papers/brookgpu/
22:07:28 <goltrpoat> ccshan:  more than four numbers at a time? :)
22:07:37 <dons> that's where they introduce the map and fold/reduce, iirc
22:07:51 <ccshan> goltrpoat: that's what Brook seems to support; I have no idea how
22:08:13 <shapr> Anyway, the 7 or 8 sidekick cpus on a Cell die have a dedicated channel to the sidekick next to them.
22:08:23 <ccshan> shapr: I'm hoping that they'd be more enthusiastic about something with a more obvious connection to video games
22:08:55 <goltrpoat> ccshan:  no native support for that -- furthermore, there is no conditional branching until shader version 2.0, and some severe restrictions on that afterwards
22:09:05 <Korollary> do they get to have a computer graphics course first?
22:09:12 <goltrpoat> ccshan:  like you can't have a texture sample instruction in a loop with a break in it
22:09:20 <shapr> I've seen a paper or two about compiling to Cg for scientific modelling of some flavor. GPUs are way fast.
22:09:46 <dons> ccshan, you've seen: http://gpgpu.org/
22:09:49 <dons> ?
22:09:55 <shapr> I've been saying for years that Nvidia should switch to selling general purpose parallel processing units.
22:09:56 <Korollary> that's a bit inaccurate. a gpu is more like an ASIC. It's "normal" for it to excel at particular tasks.
22:10:31 <ccshan> goltrpoat: thanks; but just to make sure, i can have if inside the stream right? for thresholding an image for example?
22:10:32 <dons> if we have massively multi-core cpus, can we ditch gpus and just donate an extra cpu to the gpu task?
22:11:01 <ccshan> Korollary: most people haven't taken graphics -- this PL course is required; the graphics course is elective
22:11:15 <shapr> afaik, The gpu is more like a bunch of small cpus.
22:11:21 <ccshan> dons: yes, I saw gpgpu hours ago, thanks (:
22:11:34 <Korollary> dons: a general purpose cpu takes up a ton of silicon real estate for general purpose stuff.
22:11:53 <shapr> So a Cell cpu could do it, but you'd probably want a real cpu for other stuff.
22:11:57 <sethk> Korollary, I know some engineers who designed an ASIC that's slower than a celeron processor doing the same thing.  But they are especially - ugh - talented
22:11:59 <goltrpoat> ccshan:  a vertex stream is just a stream of data, it goes through the vertex shader, which transforms it in whatever way and writes stuff out to the pixel shader.  the pixel shader can kill a fragment if it wants to -- for your threshold example, you could texkill pixels with luminosity less than a threshold, say
22:12:07 <Korollary> sethk: heh
22:12:40 <shapr> On the other hand, Linux has asymmetric multiprocessing support. Right now that's only used for duplicate CPUs running at different speeds. I think it could be extended to handle entirely different CPUs.
22:12:56 <ccshan> goltrpoat: the vertex shader can also decide to make every polygon that is darker than a given threshold into a black polygon, right?
22:13:07 <shapr> Getting Linux running on all cores of the Cell would be a good test for that.
22:13:18 <goltrpoat> ccshan:  sure
22:13:25 <sethk> shapr, you would need some sort of strategy to schedule computations on the best available processor
22:13:32 <ccshan> shapr: even just starting with mixing 68k and x86 code? that'd be fun...
22:13:36 <shapr> sethk: Sure yeah, but wouldn't that be part of the fun?
22:13:40 <ccshan> goltrpoat: thanks; that cleared it up
22:13:45 <sethk> shapr, yes, sounds like it
22:13:54 <shapr> ccshan: the Cell cores are all roughly PowerPCs
22:14:39 <shapr> The chain gang aronud the edges is more like PowerPC 601s with a minimal frontend.
22:14:50 <ccshan> shapr: the chain gang?
22:14:57 <shapr> The SPUs
22:15:20 <shapr> The cell is one straw boss CPU and eight sidekick CPUs.
22:15:37 <shapr> They're really called CPU and SPU, I think. But I prefer descriptive names :-)
22:15:47 <ccshan> shapr: ah, so Cell is used in playstations. shows what an old hat i am...
22:15:59 <Korollary> *will be* used heh
22:16:15 <Korollary> whenever they come out
22:16:18 <shapr> The standard use of the cores at the moment is to run an OS on the big guy in the middle and get it to hand out tasks to the SPUs.
22:16:27 <ccshan> korollary: thanks (i'm quite ignorant)...
22:16:39 <shapr> Korollary: I was miffed that the PS3 will come with Linux installed but the memory won't be expandable.
22:16:49 <Korollary> ccshan: I'm ignorant, too. I'm not buying a ps3 :)
22:16:57 <shapr> I was planning on purchasing one, upgrading the memory, and trying ghc-smp with bunches of cores :-/
22:16:57 <ccshan> shapr: so the SPUs are more generally programmable than a GPU?
22:17:05 <goltrpoat> no, the SPUs are borderline useless
22:17:12 <shapr> goltrpoat: I disagree
22:17:16 <goltrpoat> no branch prediction, tiny cache, and all of them share the same bus to the altivec unit
22:17:19 * ccshan sits back
22:17:47 <shapr> On the other hand, each SPU has its own DMA controller, and a dedicated pipeline to the SPU next to it.
22:17:50 <dons> shapr, talking to roman l here -- he's going to be running ghc-smp on a 20 cpu smp sparc server to test the scaling properties of the rts
22:17:52 <goltrpoat> i mean..  ok, i should rephrase.  they are not borderline useless -- it'd be more accurate to say that the architecture makes the altivec unit borderline useless, since it's going to be sitting there scheduling dma packets 90% of the time
22:18:07 <shapr> dons: I drool like a river...
22:18:30 <dons> yeah, should be fun
22:18:39 <shapr> dons: Oh please tell him to put his results on haskell-cafe when he gets them, I wanna hear about it.
22:18:50 <rizzix> can anyone explain me why is it that the babel module fails with ja, ru, zt etc
22:19:02 <shapr> goltrpoat: I'd say instead that this is a perfect place to exploit region allocation and other ways to tune data locality.
22:19:03 <dons> rizzix, char encodings I think
22:19:18 <Korollary> goltrpoat: But that's what they were meant to do. I don't think they meant the SPU's to be capable on their own, but excel as a group at game-like tasks.
22:19:26 <dons> i think our regexes for extracting the content from the pages break when using these non-latin1 languages
22:19:35 <dons> you might want to grab the latest lambdabot and try to fix it?
22:19:47 <rizzix> oh
22:19:50 <dons> you can use offline lambdabot mode to make debugging a lot easier
22:20:05 <rizzix> oh thx for the tip
22:20:08 <dons> ?help babel
22:20:08 <lambdabot> babel <lang1> <lang2> <phrase>.
22:20:08 <lambdabot> [3 @more lines]
22:20:11 <dons> ?more
22:20:11 <lambdabot> Translate a phrase in lang1 to lang2.
22:20:11 <lambdabot> Language is an element of
22:20:11 <lambdabot> "german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
22:20:14 <shapr> goltrpoat: Consider efficient use of a box with eight 8086 cpus :-)
22:20:19 <ccshan> So, surely reduce using an associative operator would be easy to put into a GPU (it can just divide the task into however many processing units there are)...?
22:20:52 <dons> yep, I think that's basically the story
22:21:05 <Korollary> except the compiler does the dividing
22:21:13 <rizzix> dons that does not really fix it does :P
22:21:22 <dons> well, it does if you make the patch..
22:21:35 <dons> this is open source -- if you need some feature, you implement it :)
22:21:39 <goltrpoat> shapr:  they're crippled in the same way that the VUs were crippled on the ps2 -- you have these really nice processors, but you can't use them to a full extent because you're piping data in bite-sized chunks over the bus -- which makes things especially tricky when a particular algorithm can't really be serialized into bite-sized stages, it needs a large chunk of the dataset
22:21:41 <dons> and then you get to add your name to the AUTHORS file :)
22:21:46 <rizzix> :)
22:21:50 <rizzix> thx 
22:21:52 <dons> ?version
22:21:53 <lambdabot> lambdabot 3p368, GHC 6.4.1 (Linux i686 3.20GHz)
22:21:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:22:15 <dons> grab the source, inspect the html for the non-euro babel results, and find the right regexes
22:22:23 <dons> I can help guide you, if needed
22:22:59 <goltrpoat> shapr:  i guess we'll see, but i'm not looking forward to ps3.  the 360 architecture is very fun to work with, so ps3 would have to be a huge leap from the ps2 mentality.. and it doesn't seem like they're really doing anything drastically different
22:23:19 <Korollary> goltrpoat: do you work with the 360?
22:23:25 <goltrpoat> yeah
22:23:30 <rizzix> indeed, when i'm up to actually fixing it, i'll keep you in touch
22:25:11 <shapr> goltrpoat: Well, I think it's an opportunity for GHC to shine :-) Find a games company to pay me to hack ghc-smp and parallel arrays into House, and I bet you'll get efficient and easily written games.
22:26:02 <Korollary> House?
22:26:16 <Korollary> you want a console to run on House + GHC?
22:26:35 <ccshan> in the less connected to real processors department, perhaps the right "fake parallel architecture" to use is dataflow concurrency
22:26:38 <shapr> House is the ghc runtime.
22:26:57 <Korollary> I thought House was an OS
22:27:05 <shapr> Yeah, dataflow would let the SPUs pick up tasks whenever they're free.
22:27:05 <goltrpoat> shapr:  heheh
22:27:07 <shapr> Korollary: It's that too.
22:28:16 <shapr> Korollary: Lunar^ and sebc got grub to call the GHC runtime directly, and added interrupt handlers.
22:28:27 <ccshan> arrays :: GPU = abstract data types (i.e., trees) :: ???
22:29:20 <shapr> goltrpoat: If I had the money, I'd set it up myself. I think it's a good approach to handling bunches of small cores in a console.
22:29:37 <sethk> Korollary, house is more or less an embedded o/s, or at least the beginnings of one
22:31:24 <goltrpoat> sharp:  well.. you'd have to handle a fair bit more than making the SPUs pick up tasks when they're free, no?  data dependencies, exclusion, synchronization, etc
22:31:56 <ccshan> goltrpoat: perhaps this is where pure FP simplifies things?
22:32:22 * shapr hugs pure FP
22:33:14 <goltrpoat> ccshan:  it does, doesn't it
22:33:16 <goltrpoat> wasn't really thinking
22:33:29 <ccshan> goltrpoat: i'm not sure! hopeful thinking
22:35:18 <ccshan> surely the connection machine folks talked to the lisp machine folks?
22:35:49 <Korollary> goltrpoat: how much of the code gets manually edited to take advantage of the parallelism, and is it particularly hard?
22:35:59 <Korollary> in the rendering pipeline, that is
22:36:53 <goltrpoat> it seems like it would, no?  in the simple scenario, you got the renderer A, and the game logic B.  while A is evaluated on the last frame, B is evaluated on the current frame (to eliminate lockstep between the two).  so if the frame rolls around and B isn't done, since B(t_i) is A(t_i)'s input, B gets invoked by the lazy evaluation, and all is well
22:38:40 <shapr> With dataflow you could use the old VR trick of updating pixels randomly when the viewpoint is changing too quickly, thus giving the appearance of motion blur, and not doing computation that's old and unneeded.
22:39:05 <goltrpoat> korollary:  we just got the devkits a few weeks ago, i haven't done a whole lot with it yet.  they're using OpenMP for parallelism
22:39:13 <shapr> Oh that's sensible.
22:39:37 <shapr> I wish I had a job working on multicore systems, even microsoft sponsored ones...
22:39:57 <goltrpoat> korollary:  i suspect that bit is no different than writing pc code for multicore platforms though -- this thread goes here, this thread goes there
22:40:26 <goltrpoat> or rather.. writing pc games
22:40:38 <Korollary> goltrpoat: I meant in general, not particularly on the 360. I used to browse game dev forums but I don't remember any loud complaints.
22:40:40 <goltrpoat> since there's generally a fairly clear separation between the systems, and a couple of synchronization points
22:41:20 <shapr> My argument against threads is that high end of the Cell roadmap has 64 of the current 'single core' Cells. That'll be ...
22:41:26 <shapr> > 9 * 64
22:41:27 <lambdabot> 576
22:41:37 <shapr> More cores than you want to explicitly schedule...
22:41:41 <ccshan> goltrpoat: i assume that A(t_i) has to peek at some shared (synchronized?) memory location to find out if B(t_i) is done...?
22:42:00 <shapr> er 64 cores on a single die, that is...
22:42:00 <goltrpoat> korollary:  oh.  well, you try to desynch the cpu from the gpu, obviously.  the last multiprocessor system ive done any large amount of work with was ps2 -- where it was crucial to set things up so that as much stuff was running in parallel as possible
22:42:03 * shapr isn't awake yet.
22:42:52 <goltrpoat> ccshan:  probably..  the rendezvous mechanism in ada comes to mind
22:43:27 <goltrpoat> korollary:  as in, it was the difference between 1 fps and 50 fps
22:43:33 <Korollary> goltrpoat: would that also depend on profiling based timing, i.e. if one unit has some time left before the other one finishes, try to do more to make them overlap more?
22:44:58 <goltrpoat> korollary:  yeah.  to bring up the ps2 again, they had this special version of the devkit, the performance analyzer, that timed something like a couple of hundred different hardware parameters and gave you a graph.  so most of the optimization would revolve around..  ok, the VU1 is stalling here because it's waiting on the EE to get this other crap from the VU0
22:45:33 <goltrpoat> korollary:  oh wait..  you mean including profiling into the actual app?  as in, "if this is running too slow, add another task to this other queue" ?
22:45:42 <Korollary> no, I meant what you said
22:45:45 <goltrpoat> ah ok
22:46:19 <Korollary> I was expecting that they had something like the intel tools (vtune?)
22:47:02 <goltrpoat> it was much nicer than the usual nonintrusive profilers, since it was hardware level, so the observation wasn't affecting the execution speed
22:47:10 <goltrpoat> it was the only nice thing about the ps2, basically.
22:47:21 <Korollary> well they probably bloody needed that tool
22:47:27 <goltrpoat> haha oh yes.
22:48:17 <Korollary> my thesis was on a cpu+sidekick hardware and it was a bitch to program. Since then I ahbor such archs.
22:49:01 <goltrpoat> well it wasn't exactly a cpu+sidekick.  it was more like a gang of cpus, which communicated via carrier pigeons
22:49:13 <goltrpoat> or rather, via one carrier pigeon.
22:49:23 <goltrpoat> courier, too.
22:49:57 <Korollary> same deal, tho. Complex target arch where hand optimizing goes a long way.
22:51:17 <Korollary> ok. Anton V S confuses the hell outta me.
22:55:15 <Korollary> I make a resolution not to get involved in a static-vs-dynamic types debate for the rest of the year.
22:58:07 <shapr> Korollary: What happen?
22:58:45 <shapr> Korollary: I like franka's view on typing, it's all the same, but statically typed languages let you do the typing beforehand.
22:59:14 <poltrgoat> blah
22:59:28 <Korollary> shapr: on LtU, topic: extremely static language. His response just makes me want to repeat my questions.
23:00:01 <Korollary> btw, this is hilarious: http://www.forbes.com/technology/2006/03/22/vista-microsoft-ballmer_cz_dl_0322microsoft.html
23:08:41 <gzl> hahaha
23:08:43 <gzl> good article
23:17:04 <poltrgoat> anyone know if there are any plans for a 2005 version of visual haskell?  i'm using the 2003 version right now, but i'm about to start writing production code, and it'll be a bitch to have to switch back and forth
23:18:02 <Korollary> production code? cool.
23:19:38 <neologism> visual haskell?
23:19:43 <neologism> where can I get that?
23:20:22 <poltrgoat> http://www.haskell.org/visualhaskell/ ... it's basically a visual studio binding for ghc 6.5
23:21:06 <poltrgoat> with syntax highlighting, project settings, go to definition, and other fun stuff
23:21:54 <neologism> ah.. I dont have windows :(
23:22:00 <poltrgoat> ah
23:22:03 <Korollary> heh
23:22:13 <sieni> as if there was anything fun about anything in visual studio
23:22:52 <Korollary> I remember hating vs6. I bet it improved since then, but oh well.
23:22:53 <goltrpoat> compared to all those.. other.. greatly superior.. ides, you mean
23:22:59 <neologism> sieni: I can show it to my friends saying "see! haskell has serious use!" :)
23:23:36 <goltrpoat> vs6 was pretty bad
23:24:03 <goltrpoat> although most of my gripes with it were about the c++ compiler, not the ide
23:26:22 <Korollary> yeah the compiler sucked
23:26:33 <Korollary> com/atl sucked
23:26:36 <neologism> I heard VS compiler is great... isnt that true?
23:26:49 <Korollary> it actually produced quite fast code.
23:27:02 <neologism> so what was the problem?
23:27:06 <Korollary> it was lacking template support, etc.
23:27:11 <ozone> VS6 wasn't particularly C++ standards compliant, VS2003 (and 2005) are much, much better
23:27:21 <neologism> ah...
23:27:37 <Korollary> also you can drop in the intel c++ compiler
23:27:48 <Korollary> as a substitute
23:28:55 <tibbe> is it possible to do type inference on object oriented languages?
23:29:08 <Korollary> like ocaml?
23:30:17 <ozone> tibbe: the next revision of C++ (C++0x) will have some type inference
23:30:25 <ozone> and i think scala might have it
23:30:46 <goltrpoat> ozone:  weren't they planning on type classes, too
23:31:04 <ozone> goltrpoat: 'concepts', which are somehwat similar to type classes
23:31:10 <ozone> stroustrup has a good paper on it
23:31:19 <goltrpoat> ah cool
23:31:26 <tibbe> ozone, is doable in general (on a complete program) without any type annotations?
23:31:26 <tibbe> is it*
23:31:28 <goltrpoat> i haven't read much about it, probably should
23:31:53 <ozone> goltrpoat: google for C++0x concepts, you should find it
23:32:18 <ozone> tibbe: i don't believe so, type inference in the presence of subtyping in general is undecidable IIRC
23:32:37 <ozone> but there was some interesting paper out in the past year that brought something else to the table.  can't remember what the title of it is, though
23:34:54 <tibbe> ozone, do you remember the title of stroustrup's paper?
23:37:31 <goltrpoat> is that the cuj one
23:37:38 <ozone> let's see, hang on
23:37:55 <goltrpoat> i think ive read it, if that's the case.. but it's been a while and i don't remember it going into too much detail
23:38:04 <goltrpoat> http://www.osl.iu.edu/publications/prints/2005/siek05:_concepts_cpp0x.pdf seems to be rather thorough though
23:38:24 <ozone> http://public.research.att.com/~bs/popl06.pdf
23:39:16 <goltrpoat> doh, different paper entirely.  thanks
23:39:53 <tibbe> ozone, thanks
23:40:30 <goltrpoat> ozone:  did you use to hang out on #coders?  i remember there being an ozone from au there
23:41:16 <ozone> goltrpoat: if you mean, like, 1995-1996, yeah :)
23:41:36 <goltrpoat> oh, nuts.  i'm pGeist
23:41:53 <ozone> oh geez, long time no see :)
23:41:56 <goltrpoat> hehe yeah
23:42:23 <goltrpoat> what you been up to?
23:42:24 * shapr boings
23:42:41 <ozone> what, since 10 years ago?  you know, stuff'n'things...
23:42:46 <goltrpoat> haha
23:42:57 <ozone> got into this "haskell" thing
23:43:09 <goltrpoat> yah, all the kids are doing it
23:43:28 <ozone> :)
23:43:35 <Korollary> only the cool kids
23:43:37 <shapr> tibbe: Yes, see Self and the Cartesian Product Algorithm used in Starkiller for examples.
23:44:11 <ozone> went to work at a government researchy place for a couple of years, now at a great place called rising sun research
23:44:31 <ozone> did a honours thesis on haskell/objective-c integration, which is how i got into all this functional language stuff
23:44:39 <goltrpoat> ah nice
23:45:36 <shapr> tibbe: It's not really type inferencing as in Haskell.. or maybe it is.. hmm. Anyway, 1. find all the possible types that can go through a method call. 2. compile type specialized versions of those calls. 3. use as necessary.
23:46:05 <ccshan> shapr/goltrpoat: thanks for the great tips -- i'm going to bed, but i think i can evaluate an arithmetic expression in O((log n)^2) passes, and will think about evaluating expressions with "let" (optimal graph reduction?) -- good night!
23:46:16 <ozone> but yeah, been pretty good.  gotten back into music (i was never really a coder in the demoscene, more a muso), which has been great
23:46:29 <ccshan>  /Korollary
23:46:29 <goltrpoat> ccshan:  cool
23:46:30 <ozone> if you're into electronica/dance doof doof stuff, gimme your email and i'll add you to the distro list
23:46:33 <goltrpoat> ccshan:  later
23:46:37 <shapr> tibbe: Self did all that at runtime, you'd only compile a type specialized version of method when it was actually called. When sun killed the Self research project, they imported those ideas into Java and called it "just in time compilation" or JIT.
23:46:42 <Korollary> I used to be an m68k coder. Tee hee.
23:46:48 <ozone> you sound like you're doing game dev now, what a surprise for a #coder boy :)
23:46:48 <dons> m68k rules!
23:46:52 <shapr> The HotSpot JVM is the result of such research.
23:47:00 <goltrpoat> ozone:  i'm more into the punk/goth stuff
23:47:03 <Korollary> dons: move a0,d0;
23:47:06 <goltrpoat> ozone:  haha yeah, who wouldve thought
23:47:17 <shapr> ccshan: I'd love to hear how you get on with it.
23:47:30 <ozone> goltrpoat: seems that quite a lot of #coders people are doing well for themselves!
23:47:35 <ccshan>  /dons
23:47:37 <ccshan> will be back!
23:47:42 <dons> Korollary, make me want to go and boot up my m68k board
23:47:47 <shapr> um, /dons?
23:47:49 * shapr is confused
23:47:58 <shapr> That's a strange quit alias.
23:48:06 <goltrpoat> ozone:  haven't been there a whole lot.. i saw firelight is an official 360 middleware developer
23:48:19 <ozone> goltrpoat: yeah, firelight's been doing great
23:48:28 <ozone> fmod is used in a crapload of games
23:48:34 <goltrpoat> yah definitely
23:48:46 <shapr> tibbe: Want anymore info?
23:49:03 <ozone> goltrpoat: i went to asm97, which was probably the highlight of the scene for me :)  (came 2nd in the music compo, woot)
23:49:04 <tibbe> shapr, sure, sorry for not replying, was reading
23:49:12 <shapr> no worries.
23:49:17 <shapr> IRC is async
23:50:18 <Lemmih> dcoutts: ping.
23:50:21 <dons>  /dons is how I quit :)
23:50:22 <goltrpoat> ozone:  i did a coma 2000 or 2001 or whatever demo with vastator, 2nd place in the demo compo (it was utter crap, but everything else was even worse, yay canadian compos)
23:50:30 <ozone> goltrpoat: so yeah, life's been pretty kind to me in the past 9-10 years
23:50:35 <goltrpoat> right on
23:50:37 <ozone> goltrpoat: ah cool.  have you got mindcandy?
23:51:02 <goltrpoat> no, but having googled it, i probably should
23:51:21 <Korollary> I think a haskell-demo compo makes much more sense than a 64k demo compo.
23:51:29 <adu> i have some mind candy for you
23:51:55 <adu> its a riddle
23:52:30 <neologism> there are haskell demos?
23:52:35 <Korollary> there should be
23:52:51 <goltrpoat> pfft.  side two doesn't have the good, the bad and the ugly.
23:52:51 <neologism> Id love to see some ;)
23:53:08 <shapr> Korollary: IOHCC counts?
23:53:18 <Korollary> shapr: whats that?
23:53:31 <ozone> goltrpoat: oh yeah, boo
23:54:29 <ozone> goltrpoat: i still keep in touch with some scene folks.  if you know yannis, he was over here a few months ago
23:54:53 <goltrpoat> yah, yannis rings a bell
23:55:21 <goltrpoat> i see bramz and floyd on #flipcode now and again, that's about it
23:55:24 <ozone> goltrpoat: of yeah, you know pulse?  (impulse tracker author.)  am working with him now on the same project at our company, which is pretty cool :)
23:55:31 <goltrpoat> oh sweet
23:55:34 <Korollary> wow. impulse tracker.
23:55:35 <ozone> best fucking coder i've ever seen, bar none
23:55:46 <goltrpoat> nice
23:55:54 <goltrpoat> yah, IT was pretty solid
23:56:34 <ozone> goltrpoat: yeah, you know that the later versions of IT had full networking support, for collaborative tracking (via IPX).  still haven't seen that in any other music software today.  and that was done in 640k of RAM :)
23:56:38 <adu> sounds like high praise
23:56:46 <goltrpoat> oh i didn't know that
23:59:19 <Korollary> so BillG was right
23:59:59 <shapr> CosmicRay: Serendipity has no static type checking!
