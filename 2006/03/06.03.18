00:37:04 <jyp> @yow
00:37:04 <lambdabot> Yow!  It's a hole all the way to downtown Burbank!
00:37:20 <jyp> @quote
00:37:20 <lambdabot> ghc says: Malformed predicate
00:37:32 <jyp> @quote
00:37:33 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes
00:37:33 <lambdabot> and sprynges of great variety and harm.
00:45:42 <Saulzar> Which should we pay more attention to, ghc or Cale?
01:23:50 <neologism> anyone here using hat?
01:26:57 <tibbe> @quote
01:26:58 <lambdabot> dons says: I don't mind autoconf, except for the fact that it's stupid
01:26:58 <lambdabot> and ugly
01:36:39 <neologism> how do I tell ghc that I have main in Searh.hs ?
01:38:12 <eivuokko> --main-is Search or --main-is Search.main
01:38:42 <neologism> not.. its -main-is ;)
01:38:44 <neologism> just one -
01:38:55 <eivuokko> Yeah, might be..
01:39:32 <neologism> uh
01:39:36 <neologism> main :: IO ()
01:39:36 <neologism> main = print $ dijkstra maze1
01:39:42 <neologism> earch.hs:1:0:
01:39:42 <neologism>     The main function `hs' is not defined in module `Search'
01:39:42 <neologism>     When checking the type of the main function `hs'
01:39:50 <neologism> how do I have to define that main function?
01:40:20 <jyp> drop .hs
01:40:30 <eivuokko> You said -main-is Search.hs, which it took to mean function hs in module Search
01:40:30 <jyp> --main-is Search
01:40:34 <jyp> not 
01:40:38 <neologism> thnx ?)
01:40:38 <jyp> -main-is Search.hs
01:40:45 <jyp> :)
01:41:09 <neologism> now.. how to use HAT
01:42:27 <neologism> it says "specially compiled program is run...."
01:42:34 <neologism> now what is specially compiled program
02:19:18 <belmando> hiii
02:19:26 <adu> hi
02:19:37 <belmando> where adu
02:19:48 <adu> where?
02:36:04 <neologism> how do I make "where" statements in guarded functions?
02:36:09 <neologism> foo x | bah
02:36:14 <neologism>    where bah = ....
02:36:26 <neologism> foo x | bah = bar
02:36:29 <neologism>     where bar = ...
02:36:30 <neologism> I mean this ;)
02:37:23 <Saulzar> Doesn't work?
02:38:05 <Saulzar> > let foo x | True = bar where bar = 4 in foo "asdf"
02:38:06 <lambdabot> 4
02:38:30 <neologism> I had
02:38:33 <neologism> .. | ..
02:38:34 <neologism> where
02:38:37 <neologism> ... | ...
02:39:09 <Saulzar> Ahh, well it scopes over all the guards 
02:39:48 <Saulzar> > let foo x | False = bar | True = bar where bar = 4 in foo "asdf"
02:39:49 <lambdabot> 4
02:39:53 <neologism> solved now
02:44:23 <neologism> lets say I have array of [(String, Int)] and I want to get the String with the lowest Int
02:44:28 <neologism> how to do so the best way?
02:45:14 <Saulzar> minimumBy (comparing snd)
02:45:32 <Saulzar> (Though comparing isn't a prelude function)
02:46:12 <Saulzar> comparing f x y = (f x) `compare` (f y)
02:46:13 <neologism> @where minimumBy
02:46:14 <lambdabot> I know nothing about minimumby.
02:46:50 <Saulzar> @index minimumBy
02:46:51 <lambdabot> Data.List
02:47:01 <neologism> thnx
03:01:20 <davidhouse> jyp, ping
03:01:33 <jyp> pong
03:02:13 <neologism> vim should be taughht that in (\(x, y, _) -> (x, y)) the number of brackets matches ;(
03:02:38 <davidhouse> jyp, i managed it! :)
03:02:46 <davidhouse> got the lambda thing going
03:02:48 <jyp> haha ... :)
03:03:00 <davidhouse> i read some of the paper and as soon as i saw Add Expr Expr things started to click
03:03:37 <davidhouse> i've done it in State at the moment because that's what I know but it shouldn't be too hard to convert it to Reader
03:04:17 <davidhouse> jyp, http://paste.lisp.org/display/18003 is my current implementation
03:06:26 <kowey> neologism: i just got used to inserting a space: \ (x,y) ->
03:07:16 <neologism> nice idea ;)
03:07:23 <jyp> davidhouse: I see you have implemented an impure "let"
03:07:51 <davidhouse> jyp, it's eager if that's what you mean
03:08:17 <neologism> @type Data.List.minimumBy
03:08:18 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:08:23 <neologism> ah!
03:08:46 <jyp> davidhouse:  you have let x = value, instead of let x = value in expr
03:09:03 <davidhouse> jyp, yeah. it's basically modelling a do block.
03:09:07 <davidhouse> i was thinking of changing that
03:09:08 <jyp> davidhouse: so x acts as a global variable in your implementation
03:09:50 <davidhouse> i was thinking perhaps change Let VarName Expr to Let VarName Expr Expr, which would make it easier to convert to Reader
03:10:00 <jyp> exactly :)
03:10:24 <jyp> then you may want to implement closures
03:10:26 <davidhouse> but otherwise it looks good?
03:10:42 <jyp> I say yes ;)
03:10:43 <neologism> > minimumBy (\(a, b) (c, d) -> a `compare` c) [("Foo", 2), ("Bar", 1)]
03:10:44 <lambdabot> ("Bar",1)
03:12:54 <davidhouse> there's a small limitation in that you can only have one-parameter lambdas, but that's easily fixed
03:13:39 <adu> jyp what are you implementing?
03:14:15 <jyp> adu: davidhouse is implementing a lamda calculus evaluator
03:14:30 <davidhouse> SIMPLE lambda caculus evaluator.
03:14:33 <davidhouse> :)
03:14:42 <adu> ic
03:14:45 <adu> interesting
03:22:03 <neologism> uh.. my program seems to be looping forever
03:22:09 <neologism> how can I debug such situations?
03:29:56 <Saulzar> neologism, Simplest is Debug.Trace or error
03:30:23 <neologism> I need to know on what its looping
03:32:38 <Saulzar> Well if you have a trace before/in/after the loop then you'll quickly figure out where...
03:32:54 <neologism> the problem is that I dont know what loop
03:33:02 <neologism> I am trying to figure that out
03:33:05 <Saulzar> Well, you must have some idea what changed :)
03:33:15 <neologism> I am writing the program
03:33:20 <neologism> everything is changing ;)
03:33:35 <neologism> Saulzar: have you ever used HAT?
03:33:40 <Saulzar> No
03:33:51 <astrolabe> Is there a way to pass command line arguments to a haskell program?
03:34:27 <Saulzar> I've never used a debugger with haskell, always seemed to sort it out quickly enough with a few some trace statements
03:34:42 <zamez> getArgs
03:34:52 <neologism> Saulzar: not my case ;(
03:35:06 <Saulzar> How big is the program?
03:35:16 <neologism> 120 lines
03:35:24 <neologism> or even less... I have some sample data there
03:35:43 <astrolabe> @hoogle getArgs
03:35:44 <lambdabot> System.Environment.getArgs :: IO [String]
03:35:44 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
03:35:44 <lambdabot> String])
03:35:52 <astrolabe> thanks zamez
03:35:58 <neologism> hysteria.sk/~neologism/Search.hs
03:36:31 <Saulzar> I'd add traces/remove bits in a top down way until you figure out what's wrong
03:36:41 <neologism> I am trying
03:38:51 <Saulzar> Other thing is you can test each function seperately
03:39:06 <Saulzar> If that's hard then split the functions up until they're more managable size
03:49:36 <lisppaste2> davidhouse pasted "simple lambda ealuator" at http://paste.lisp.org/display/18004
03:52:42 <neologism> wow!
03:52:43 <neologism> it works!
04:27:54 <Saulzar> neologism, Cool. :)
04:30:17 <neologism> no it doesnt
04:30:26 <neologism> I need to trace the program
05:04:35 <neologism> how do I use hmake/
05:04:36 <neologism> ?
05:05:53 <neologism> uh.. got it
05:28:55 <musasabi> dcoutts: are you familiar with the haddock parser? Looking for pointers where I go wrong when parsing docs inside layout.
05:29:15 <dcoutts> musasabi, not terribly familiar
05:29:17 <dcoutts> only a little
05:29:43 <dcoutts> what are you trying to do? are you fixing the parser?
05:30:08 <musasabi> GADT support.
05:30:16 <dcoutts> ah
05:30:28 <musasabi> I have it working except the parser fails if I add comments.
05:30:36 * dcoutts thinks it'd be better to teach the ghc parser about haddock markup
05:30:52 <dcoutts> musasabi, oh that's pretty good progress
05:31:34 <musasabi> http://youzen.b2.fi/~musasabi/gadt.patch
05:31:51 <musasabi> "hunk ./src/HsParser.ly 497" is the problematic one.
05:32:22 <dcoutts> I'm afraid your guess is better than mine, I don't know the parser lib that haddock uses
05:33:37 <musasabi> ok, just saw that you had contributed patches there. I'll try debugging more and asking JaffaCake if it still does not work.
05:33:56 <dcoutts> musasabi, yah, my patches were on the other side of haddock, in the output bits
05:42:17 <mathrick> @type reverse
05:42:18 <lambdabot> forall a. [a] -> [a]
05:42:32 <mathrick> > reverse "あえいおう"
05:42:33 <lambdabot>  lexical error in string/character literal
05:42:39 <mathrick> boo-ya!
05:44:55 <dons> hey
05:47:05 <ski> \x -> x
05:47:06 <lambdabot> compose module failed: Parse error: "->"
05:47:42 <mathrick> \x -> x 6
05:47:43 <lambdabot> compose module failed: Parse error: "->"
05:47:43 <ski> dons : using '\\' as command char fits bad with just saying lambdas, imo
05:47:51 <mathrick> (\x -> x) 6
05:47:56 <mathrick> > (\x -> x) 6
05:47:57 <lambdabot> 6
05:48:35 <dons> ah
05:48:43 <dons> but why would you be just saying lambdas?
05:49:01 <ski> when explaining something, e.g.
05:49:11 <dons> i searched the logs, and no one was doing it.
05:49:18 <ski> (happened to me the other day)
05:49:20 <dons> if people start doing it, then i'll disable \ :)
05:49:48 <mathrick> is \ equivalent to @?
05:49:56 <mathrick> \t 6
05:49:57 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
05:49:57 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
05:50:00 <dons> ok ski. i'll note this. if it happens a few more times, then i'll change it
05:50:03 <ski> (i don't remember what i was explaining .. just that it was some couple of days ago)
05:50:04 <mathrick> \type 6
05:50:05 <lambdabot> forall t. (Num t) => t
05:50:11 <ski> dons : fair enough
05:53:48 <dons> mathriick, yep. you can use a variety of chars to talk to lambdabot
05:53:53 <dons> %bot
05:53:54 <lambdabot> :)
05:53:55 <dons> &bot
05:53:56 <lambdabot> :)
05:53:58 <dons> @bot
05:53:59 <lambdabot> :)
05:54:01 <dons> \bot
05:54:02 <lambdabot> :)
05:54:07 <dons> # 1+2
05:54:08 <lambdabot> 3
05:54:21 <dons> ?bot
05:54:22 <lambdabot> :)
05:56:00 <sieni> > (\wtf -> WTF) 7
05:56:01 <lambdabot>  Not in scope: data constructor `WTF'
05:56:04 <sieni> eiku
05:56:09 <sieni> > (\wtf -> "WTF") 7
05:56:10 <lambdabot> "WTF"
05:59:42 <mathrick> dons: that's a bit excessive :)
05:59:51 <mathrick> :bot
05:59:56 <mathrick> ,bot
06:00:00 <mathrick> .bot
06:00:03 <mathrick> !bot
06:00:08 <ihope> More prefix characters?
06:00:22 <mathrick> heh, . , and ! are commonly used
06:00:30 <mathrick> more so than \ or %
06:03:50 <ihope> It seems like ! and @ are the most common.
06:04:03 <ihope> Supposedly, my bot will use #.
06:04:44 <mathrick> #bot
06:04:51 <mathrick> # bot
06:04:52 <lambdabot>  Not in scope: `bot'
06:04:54 <ihope> Yeah, like that.
06:05:06 <ihope> The first one, that is.
06:05:10 <mathrick> ihope: you're writing a rival for lambdabot ?
06:05:35 <ihope> Um, well, I'm writing a bot...
06:05:49 <ihope> Well, I gotta go for a bit.
06:21:45 <tic> lambdabot botsnack
06:21:51 <tic> @bot botsnack
06:21:52 <lambdabot> :)
06:22:03 <JKnecht> @version
06:22:04 <lambdabot> lambdabot 3p325, GHC 6.4.1 (Linux i686 3.20GHz)
06:22:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:22:31 <neologism> @type Data.List.sortBy
06:22:32 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:24:07 <ihope> lambdabot, @botsnack
06:24:07 <lambdabot> :)
06:24:27 <ihope> lambdabto, @botsnack
06:37:04 <twobitsprite> how does one bind a pattern to a name? i.e. (made up syntax) f (c = (Cons a b)) = ...
06:37:28 <twobitsprite> where c is bound to the whole Cons and a,b are bound to the elements of the Cons respectively
06:37:44 <ski> f c@(Cons a b) = ...
06:37:48 <twobitsprite> ahh
06:37:48 <twobitsprite> thanks
06:38:15 <ski> (this is called an 'as'-pattern)
06:38:26 <ski> (or was it 'at' ?)
06:40:30 <twobitsprite> I think remember is as 'as'... I just couldn't remember the syntax (or where I saw it)
06:40:38 <twobitsprite> s/is/it
06:40:40 <musasabi> Is there a function for liftM mconcat . sequence ?
06:40:57 <twobitsprite> @pl liftM mconcat . sequence
06:40:57 <lambdabot> fmap mconcat . sequence
06:41:23 <mathrick> what was @pl again?
06:41:26 <mathrick> @help pl
06:41:27 <lambdabot>  @pointless <expr> - play with pointfree code
06:41:32 <ski> twobitsprite : i think in the MLs, it's known as 'as'-patterns .. but it could be that it's more commonly pronounced as 'at'-patterns in haskell
06:41:48 <twobitsprite> ski: that's a possibility
06:42:03 <ski> @type Control.Monad.mconcat
06:42:04 <lambdabot> Not in scope: `Control.Monad.mconcat'
06:42:06 <musasabi> fmap should be defined for all monads, then Functor dependency is nasty.
06:42:12 <ski> @index mconcat
06:42:13 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
06:42:21 <ski> ah, silly me
06:43:26 <musasabi> -n
06:45:24 <dons> ski, wouldn't it be more commonly know as a 'pattern bind'?
06:45:57 <ski> i don't think i've heard that term for it, before
06:46:20 <dons> ihope, mathrick, we decided against . as a prefix, becaues it clashes with ... 
06:46:23 <dons> ! could be used
06:46:37 <dons> ski, oh. hmm. i hope its not a term i just made up somewhere along thhe line
06:47:14 <mathrick> dons: yup, but ... doesn't have to be a command, and usually isn't in bots I know
06:47:30 <dons> ah, the h98 report says 'as pattern'
06:47:40 <dons> but .. is a command here  :)
06:47:47 <mathrick> not that you have any kind of prefix shortage in lambdabot :)
06:47:52 <mathrick> dons: ah, heh
06:47:55 <dons> command composition
06:47:56 <mathrick> what does it do?
06:47:58 <mathrick> @..
06:47:59 <lambdabot> Not enough arguments to @.
06:48:07 <dons> \. id bot
06:48:08 <lambdabot> compose module failed: Parse error: "bot"
06:48:08 <mathrick> wow, you can compose commands?
06:48:11 <mathrick> funk
06:48:17 <dons> \. id botsnack
06:48:18 <lambdabot> :)
06:48:25 <dons> \. elite vixen
06:48:26 <lambdabot> I h4TE iT wH3N i G3t s7u(K Wi+|-| (|-|47+ING \/\/I7h 4 8ot!
06:48:35 <dons> \. elite . id botsnack
06:48:36 <lambdabot> :)
06:48:53 <musasabi> @source
06:48:54 <lambdabot> lambdabot 3p325, GHC 6.4.1 (Linux i686 3.20GHz)
06:48:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:48:55 <dons> you can compose composes. it's a nano-language on the lambdabot plugin level
06:49:11 <mathrick> elite @. vixen
06:49:23 <mathrick> okay, so that doesn't work
06:49:39 <dons> its not infix
06:49:45 <mathrick> dons: first . needs to be prefix, and others can be infix then?
06:49:48 <mathrick> yeah, I noticed
06:49:56 <mathrick> oh, wait
06:50:02 <mathrick> I read it wrong
06:50:04 <mathrick> it's always prefix
06:50:05 <dons> well, think about how it wouldd be parsed:
06:50:15 <musasabi> dons: please tag/optimize the lambdabot repo - a partial get is 329 patches.
06:50:16 <dons>  (. e1 (. e2 e3))
06:50:23 <dons> it is tagged
06:50:29 <dons> it'll get tagged again on the next release
06:50:38 <ski> so the first arg must be one word, right ?
06:50:42 <dons> there's been 1000 patches in the last year...
06:50:48 <musasabi> ok
06:51:26 <dons> ski, yeah. it's a bit silly that way. only the last command can tagke args
06:51:39 <dons> we couuld do with a properly thought out calculus 
06:52:08 <dons> current, we only have  . == >>= on plugins, but a proper parser,and then a few fun ways to combine them, would be useful
06:52:16 <ski> dons : reverse forth ? :)
06:52:26 <dons> sounds scary
06:52:39 <dons> and not "a properly thought out calculus" ;)
06:52:43 <dons> hehe
06:53:11 * mathrick should learn forth one of these days
06:53:25 <mathrick> purely stack-based language sounds interesting
06:53:43 <mathrick> I can't currently see how it'd work
06:53:47 <musasabi> dons: It would be nice to get the plugins in a few subdirs like "Fun" "Admin" "Haskell" etc as there are more and more of them.
06:53:51 <ski> though we'd need to distinguish between commands and literals, in-command, somehow
06:53:57 <dons> musasabi, good idea!
06:54:25 <dons> musasabi, what are you up to?
06:54:58 <dons> hmm, now i wonder where I came up with this term 'pattern bind', since h98 says several times 'as-patterns'
06:55:03 <dons> \google pattern bind haskell
06:55:05 <lambdabot> http://www.haskell.org/arrows/sugar.html
06:55:06 <musasabi> add yet an another plugin.
06:55:14 <dons> good good
06:55:24 <dons> i hope to see the src in my mailbox in the morning
06:55:37 <dons> also, weren't you working on the log module at some point?
06:55:47 <dons> sjw has rewritten it -- it is pretty solid now
06:56:00 <dons> we log a channel at my uni with lambdabot, and it does a great job
06:56:20 <musasabi> yes, but it ended so hacky that I didn't want to publish things.
06:56:28 <dons> ok
06:56:59 <dons> oh ski, i meant to tell you. we added an unlambda interpreter:
06:57:02 <dons> \unlambda ski
06:57:03 <lambdabot> Done.
06:57:13 <dons> \unlambda `.!i
06:57:13 <lambdabot> !
06:57:39 <MarcWeber> Does anybody know where at haskelldb the "SELECT" part is added to an SQL statement? The only place where I was able to find it was the SQL pretty printer function. Is this result send to database?
06:57:42 <dons> with a nick like yours, maybe unlambda might be your kind of thing...
06:57:48 <ski> dons : cool (i think i glimpsed it some day ago)
07:02:59 <ihope> Whoa, are the docs advocating the use of unsafePerformIO? :-)
07:05:20 <musasabi> dons: is there an easy way to get a list of all the nicks on the current channel?
07:05:38 <ihope> Maybe /names?
07:05:39 <jonkri> what's the easiest way of transforming 7 to 1001?
07:05:51 <musasabi> inside lambdabot that is.
07:05:53 <jonkri> (binary)
07:06:23 <jonkri> 1001 is nine, btw, but you get what i mean :)
07:06:29 <ihope> :-)
07:06:32 * ihope writes
07:06:51 <jonkri> :)
07:07:22 <ihope> > let binary 0 = ""; binary x | odd x = binary (x `div` 2) ++ "1"; binary x | even x = binary (x `div` 2) ++ "0" in binary 38
07:07:24 <lambdabot> "100110"
07:07:32 <ihope> Is that right?
07:08:20 <jonkri> jeez, ok
07:08:21 <ihope> Now, maybe you should s/binary /binary' / and add binary 0 = "0"; binary x = binary' x
07:08:22 <ski> > Numeric.showIntAtBase 2 (\x -> fromJust (lookup x [(0,'0'),(1,'1')])) 9 ""
07:08:23 <lambdabot> "1001"
07:08:26 <jonkri> i get what you're doing. thanks
07:08:42 <jonkri> ski: oh
07:09:13 <ski> > Numeric.showIntAtBase 2 (\x -> fromJust (lookup x [(0,'0'),(1,'1')])) 0 ""
07:09:14 <lambdabot> "0"
07:09:50 <ihope> Wow!
07:10:03 <ihope> > let binary 0 = ""; binary x | odd x = binary (x `div` 2) ++ "1"; binary x | even x = binary (x `div` 2) ++ "0" in binary 4375473
07:10:04 <lambdabot> "10000101100001110110001"
07:10:15 <ihope> > Numeric.showIntAtBase 2 (\x -> fromJust (lookup x [(0,'0'),(1,'1')])) 4375473 ""
07:10:16 <lambdabot> "10000101100001110110001"
07:11:21 <jonkri> @type Numeric.showIntAtBase
07:11:22 <lambdabot> forall a.
07:11:22 <lambdabot>          (Integral a) =>
07:11:22 <lambdabot>          a -> (Int -> Char) -> a -> ShowS
07:11:27 <jonkri> i don't get how i should read that
07:11:34 <jonkri> what's the most fundamental use of the function? example?
07:12:29 <ski> take a base, a function converting a digit to a char, a number to convert, and give a ShowS that will show the numeral, in front of any more characters you pass
07:12:37 <ski> > Numeric.showIntAtBase 2 (\x -> fromJust (lookup x [(0,'0'),(1,'1')])) 4375473 "hello"
07:12:38 <lambdabot> "10000101100001110110001hello"
07:13:02 <ihope> > Numeric.showIntAtBase 3 (\x -> fromJust (lookup x [(0,'0'),(1,'1')])) 4375473 ""
07:13:03 <lambdabot> Exception: Maybe.fromJust: Nothing
07:13:20 <ski> > Numeric.showIntAtBase 3 (\x -> fromJust (lookup x [(0,'0'),(1,'1'),(2,'2')])) 4375473 ""
07:13:21 <lambdabot> "22020022000120"
07:13:40 <ski> you can prolly use something better than a lookup, though
07:13:43 <jonkri> @type lookup
07:13:44 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
07:13:49 <jonkri> ah, i get it
07:13:53 <ski> @hoogle Int -> Char
07:13:54 <lambdabot> Data.Char.intToDigit :: Int -> Char
07:13:54 <lambdabot> Data.Char.chr :: Int -> Char
07:13:54 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
07:14:13 <ihope> > Numeric.showIntAtBase 16 (\x -> fromJust (lookup x [(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0'),(0,'0')])) 4375473 ""
07:14:14 <lambdabot> Exception: Maybe.fromJust: Nothing
07:14:18 <ihope> Hmm.
07:14:30 <ski> > Numeric.showIntAtBase 3 Data.Char.intToDigit 4375473 ""
07:14:31 <lambdabot> "22020022000120"
07:14:40 <ihope> Aha!
07:14:49 <ihope> > Data.Char.intToDigit 10
07:14:50 <lambdabot> 'a'
07:14:53 <ski> :)
07:14:55 <ihope> > Data.Char.intToDigit 30
07:14:56 <lambdabot> Exception: Char.intToDigit: not a digit 30
07:14:59 <jonkri> thanks
07:15:01 <ihope> > Data.Char.intToDigit 15
07:15:02 <lambdabot> 'f'
07:15:03 <ihope> > Data.Char.intToDigit 16
07:15:04 <lambdabot> Exception: Char.intToDigit: not a digit 16
07:15:09 <ski> hm
07:15:16 <ski> seems only upto hexadecimal
07:16:37 <jonkri> :t Data.Maybe
07:16:39 <jonkri> haha
07:16:59 <jonkri> what's fromJust?
07:17:05 <jonkri> where's fromJust, even
07:17:10 <jonkri> in what library
07:17:37 <ski> @hoogle fromJust
07:17:38 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
07:18:12 <jonkri> what's hoogle?
07:19:06 <jonkri> why is "" neccessary at the end?
07:19:11 <MarcWeber> jonkri: haskell.org/hoogle
07:19:12 <jonkri> after the number?
07:20:49 <ski> jonkri : because it's a 'ShowS' not a 'String'
07:20:56 <ski> type ShowS = String -> String
07:21:03 <ski> @type showString
07:21:04 <lambdabot> String -> ShowS
07:21:26 <jonkri> ok
07:21:30 <jonkri> why?
07:21:31 <ski> > showString "foo" . shows 12 . showChar '#' . showString "bar" $ ""
07:21:32 <lambdabot> "foo12#bar"
07:21:50 <ski> instead of using left-nested append
07:21:51 <jonkri> hm, ok
07:21:57 <ski> more efficient
07:22:03 <jonkri> if you say so :)
07:22:22 <ski> (of course, it's another matter if it
07:22:37 <ski> 's good to expose this in the interfaces)
07:23:09 <ihope> @type shows
07:23:09 <lambdabot> forall a. (Show a) => a -> ShowS
07:23:29 <Igloo> Except in the above case the concat would be right-nested. It only helps if you have deeper structure
07:23:37 <ihope> @index (.>>)
07:23:37 <lambdabot> bzzt
07:26:26 <ihope> > let x .> y = (x .) . y; x .>> y = ((x .) .) . y in ((negate .> (+)) .>> const (*)) 1 2 3 4
07:26:27 <lambdabot> -10
07:26:49 <ihope> It's a bit obfuscated, but it seems to work fine.
07:26:56 <ski> Igloo : yes
07:27:03 <sieni> "a bit"
07:27:38 <ski> > let (.:) = (.) . (.); (.::) = (.) . (.) . (.) in ((negate .: (+)) .:: const (*)) 1 2 3 4
07:27:39 <lambdabot> -10
07:27:53 <jonkri> @hoogle showIntAtBase
07:27:53 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a ->
07:27:53 <lambdabot> ShowS
07:27:55 <ski> (ihope : that is my usual notation for that)
07:28:15 <ihope> Ah...
07:28:39 <ski> (ihope : sortof, one dot for each dot in the definiens)
07:29:11 <ihope> @type let x <. y = x . (. y) in (fix <. show)
07:29:11 <lambdabot> Not in scope: `fix'
07:29:17 <sieni> who said that obfuscation only works with C or Perl? :-)
07:29:22 <ihope> @type let x <. y = x . (. y) in (Control.Monad.Fix.fix <. show) -- Grr!
07:29:23 <lambdabot> forall c.
07:29:23 <lambdabot>                      (Show c) =>
07:29:23 <lambdabot>                      (String -> c) -> c
07:29:45 <ihope> > let x <. y = x . (. y) in (Control.Monad.Fix.fix <. show) read :: Int
07:29:45 <lambdabot> Terminated
07:30:12 <ihope> Well... so what does <. do, anyway? :-)
07:30:32 <ski> @pl \x y -> x . (. y)
07:30:33 <lambdabot> (. flip (.)) . (.)
07:30:39 <ski> @type \x y -> x . (. y)
07:30:40 <lambdabot> forall c a b c1.
07:30:40 <lambdabot>        ((a -> c1) -> c) -> (a -> b) -> (b -> c1) -> c
07:31:18 <ski> @type \x y -> x . (. (. y))
07:31:20 <lambdabot> forall c a b c1 c2.
07:31:20 <lambdabot>          (((b -> c1) -> c2) -> c) -> (a -> b) -> ((a -> c1) -> c2) ->
07:31:20 <lambdabot> c
07:31:34 <ihope> I don't get it.
07:32:19 <ski> seems to pass third to first, but "mediating" the "left-most" part of the type with the second
07:32:59 <ski> this could also be expressed as converting the first and second to the function that takes third
07:33:17 <ihope> ...?
07:33:28 <ski> @type \y x -> x . (. (. y))
07:33:29 <lambdabot> forall c a b c1 c2.
07:33:29 <lambdabot>          (a -> b) -> (((b -> c1) -> c2) -> c) -> ((a -> c1) -> c2) ->
07:33:29 <lambdabot> c
07:33:40 <ski> @type \y x -> x . (. y)
07:33:41 <lambdabot> forall c a b c1.
07:33:41 <lambdabot>        (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
07:33:53 <ihope> @djinn ((a -> c1) -> c) -> (a -> b) -> (b -> c1) -> c
07:33:54 <lambdabot> f a b c = a (\ d -> c (b d))
07:34:01 <ihope> :-)
07:34:32 <ski> these are of the form 'forall a b. (a -> b) -> (f b -> f a)' respectively '(a -> b) -> (f a -> f b)'
07:34:45 <ihope> a and b are the things being "composed", and c is the value they're applied to.
07:34:58 <ihope> I not gets it.
07:35:32 <ski> where 'f x' is something like '(((..((x -> c_n)-> c_{n-1})..) -> c2) -> c1) -> c0'
07:36:06 * ski has no idea for a use case for this, though :)
07:37:52 <ihope> So x .> y = (x .) . y, and x <. y = x . (. y), so x <.> y = (x .) . (. y), and maybe even x .< y = x . (y .)...
07:38:35 <ihope> Wait, wait...
07:38:44 <ihope> Nah, I got it right :-P
07:39:32 <ihope> x .><<><>> y = ((. (. ((. ((x .) .)) .))) .) . y -- eek
07:42:23 <ski> ihope : that operator sortof looks like a fish
07:42:30 <ihope> Yeah, it does.
07:42:36 <ihope> @type (><>)
07:42:37 <lambdabot> Not in scope: `><>'
07:42:49 <ski> behold : ihope invents the fish calculus !
07:43:03 <ihope> Whoa!
07:43:08 <MarcWeber> Anyone using haskelldb?
07:43:30 <ski> ihope : now you need to bootstrap a compiler for it, written it itself !
07:43:38 <ski> s/it/in/
07:44:34 <ihope> What form would it take these things in?
07:48:50 <Lemmih> MarcWeber: Got a question?
07:50:49 <ski> <MarcWeber> Does anybody know where at haskelldb the "SELECT" part is added to an SQL statement? The only place where I was able to find it was the SQL pretty printer function. Is this result send to database?
07:51:03 <MarcWeber> Lemmih: Yes. I don't know yet where the SELECT statements are made. I've grepped the source files for SELECT and got one function ppQuery to pretty print a query. Is this sent to database then?
07:52:28 <MarcWeber> Different sql implementations use different characters to quote field/table names. eg MS Access is using SELECT [my field with spaces] from [whaterver] and mysql is using SELECT `field with` .. But I didn't find "`" anywhere.. 
07:52:49 <Lemmih> MarcWeber: Have you seen this: http://haskell.org/hawiki/HaskellDbTutorial
07:54:40 <MarcWeber> Lemmih: I have.
07:55:19 <Blanchy> can anyone here help me with writing a RPN calculator in haskell?
07:55:47 <eivuokko> I haven't used lately, but haskelldb and ms access are a bit flaky combination (if you have probs with access)
07:57:27 <Lemmih> MarcWeber: Are you trying to change the way haskelldb pretty prints a query?
07:57:50 <MarcWeber> I want to see something like "`"++field for MySQL and "["++field++"]" for Access and so on.
07:58:08 <MarcWeber> I couldn't locate these driver depended things.
07:58:29 <MarcWeber> But I might have missed them
07:58:36 <Lemmih> There are none.
07:59:51 <MarcWeber> Lemmih: How can you use fields containing spaces?
08:00:05 <MarcWeber> not yet.
08:00:18 <eivuokko> Yeah, weakness in haskelldb, impossible to customise :-S
08:01:09 <Lemmih> eivuokko: I'd say it's a weakness in SQL that has been propagated to HaskellDB.
08:01:22 <eivuokko> Huh
08:01:39 <eivuokko> HaskellDb doesn't even need sql backend, really.
08:01:59 <eivuokko> Pretty printing and adding db-functions is way too hard.
08:02:13 <eivuokko> *Customising pretty printing
08:02:13 <MarcWeber> I thought haskelldb is meant to be used?
08:02:46 <MarcWeber> Can you get data from a SQL engine in another way then sending sql queries?? ;-)
08:02:50 <Lemmih> If everybody could agree on some standard SQL then there wouldn't be a need for backend-specific pretty printing.
08:03:09 <eivuokko> MarcWeber, It is being used.  No question about that, it just isn't easiest target to fix if it doesn't work for you.
08:03:38 <MarcWeber> Lemmih: But they can't. That's why haskell is there to simplify things.. ;)
08:03:58 <eivuokko> Lemmih, This is true for many other things.  Let's forbid extensions in every and all languages. ;)  I think extension are very much in spirit of SQL
08:04:04 <MarcWeber> eivuokko: I know. But that's really important for me. Do you know haskelldb better ? Is it easy to add?
08:05:06 <eivuokko> MarcWeber, It probably is easy to add when you find right place - if you are willing to use your own version of haskelldb (customised just for you, not working with other dbs).
08:05:19 <MarcWeber> I have to dig through the code and modify it.
08:05:27 <MarcWeber> eivuokko: I don't want to customize it...
08:05:27 <eivuokko> Yes.
08:05:38 <eivuokko> Then it is PITA.
08:05:42 <MarcWeber> I just want to add different "quotings" for different backends.
08:05:49 <MarcWeber> That's all.
08:06:52 <eivuokko> HaskellDB abstractions simply don't have layer for that, I think.
08:07:35 <MarcWeber> eivuokko: Do you think it's easier to "write your own" or modify haskell db?
08:07:47 <eivuokko> Uhm.
08:07:57 <eivuokko> That so much depends..
08:08:51 <MarcWeber> Then I'll try to understand that code first..
08:08:55 <twobitsprite> is "data (Integral a, Ix b) => Blah a b ..." the right syntax?
08:09:44 <Heffalump> I think so
08:09:55 <ihope> I think something like "data Foo = Bar a => Baz a"
08:10:00 <Heffalump> but you get very little benefit from stating the constraints in the data type, it's more documentation than anything else.
08:10:04 <Heffalump> ihope: huh?
08:10:16 <ihope> But I don't know, so... :-)
08:10:37 * ihope finishes his Monad_ type constructor
08:11:14 <eivuokko> Isn't type constructor class context extension, used with forall?
08:11:46 <ski> no
08:11:53 <jonkri> what is the easiest way of converting [[1,2], [5, 6]] and [[3, 4], [7, 8]] to [[1, 2, 3, 4], [5, 6, 7, 8]]
08:11:54 <jonkri> ?
08:12:08 <ihope> Um...
08:12:14 <Heffalump> zipWith (++)
08:12:17 <ski> > zipwith (++) [[1,2], [5, 6]] [[3, 4], [7, 8]
08:12:18 <lambdabot>  parse error on input `}'
08:12:21 <ski> > zipwith (++) [[1,2], [5, 6]] [[3, 4], [7, 8]]
08:12:22 <lambdabot>  Not in scope: `zipwith'
08:12:28 <ski> > zipWith (++) [[1,2], [5, 6]] [[3, 4], [7, 8]]
08:12:30 <lambdabot> [[1,2,3,4],[5,6,7,8]]
08:12:37 <jonkri> of course, i suck
08:12:38 <jonkri> :)
08:12:39 <jonkri> thanks
08:16:43 <ihope> data Monad_ a where Monad :: Monad m => m a -> Monad_ a
08:17:01 <ihope> instance Monad Monad_ where (Monad a) >>= b = Monad (a >>= (\(Monad c) -> c) . b)
08:17:29 <ihope> What's wrong with my instance declaration (apart from the lack of return and fail)?
08:17:45 <Heffalump> Monad_ is the data constructor, not Monad.
08:17:50 <Heffalump> oh, no it's not
08:17:51 <Heffalump> sorry
08:18:02 <ski> you can't combine two arbitrary monads like that
08:18:08 <ihope> Am I?
08:18:33 <ski> Monad a :: Monad_ a
08:18:35 <ihope> Hmm, let's see here...
08:18:43 <ski> skolem m0
08:18:54 <ski> a :: Monad_ m0 => m0 a
08:18:59 <ihope> Aha...
08:19:11 <ski> b :: a -> Monad_ b
08:19:26 <ihope> ski: eh?
08:19:34 <ski> (\(Monad c) -> c) . b :: Monad m1 => a -> m1 b
08:19:54 <ski> m0 and m1 are not known to be same monads
08:20:11 <ihope> OH!
08:20:19 <ski> so you can't do this
08:20:26 <ihope> I see.
08:21:25 <ihope> (Monad a) >>= b = fail "" -- How's this? :-)
08:21:26 <ski> it's sortof 'binary methods'
08:22:14 <ihope> It's sort of ironic, indeed, that after capturing a class in a type constructor, you can't make that constructor be in that class :-)
08:22:17 <ski> ihope : 'fail' being ?
08:22:42 <twobitsprite> so... I'm trying to instantiate Ix, but I'm not sure how to implement range, index, etc...
08:22:46 <ski> (you need to unsure monad laws, which is why i ask)
08:22:54 <twobitsprite> @type Array.index
08:22:55 <ihope> class Monad m where ... fail :: String -> m a -- something like that
08:22:55 <lambdabot> forall a. (GHC.Arr.Ix a) => (a, a) -> a -> Int
08:24:01 <ski> ihope : hm, there was some thread on comp.lang.functional a bit related to this, some while ago, i think ..
08:37:51 <MarcWeber> Lemmih: I have another problem. I can't get hsplugins to compile. genericConnect needs it I think... I get some wired syntax error .. I'm using CVS ghc compiler build only some days ago
08:39:09 <MarcWeber> Then I won't use generic for now.
08:43:30 <ihope> Bleh.
08:43:42 <ihope> data Show_ where Show :: Show a => a -> Show_
08:43:56 <ihope> instance Show Show_ where showList a = showList (map (\(Show b) -> b) a)
08:44:50 <ihope> What happened to the Magic Type Thingies?
08:45:20 <ihope> Oh well.
08:45:28 * ihope lets the default definition handle it
08:45:28 <ski> you can't 'map' like that
08:46:14 <ihope> Should I use Plain Old Recursion?
08:46:25 <ihope> Or... hmm.
08:46:38 <ski> @type showList
08:46:39 <lambdabot> forall a. (Show a) => [a] -> ShowS
08:46:40 <ihope> What's the point of showList anyway?
08:46:43 <Saulzar> That approach is fine, but you can't return a "b" - since the type varies...
08:47:01 <ihope> Saulzar: so what should I return?
08:47:05 <ski> ihope : specialcasing, e.g. for '[Char]'
08:47:11 <ski> it's a hack
08:47:15 <ihope> Ah.
08:47:27 <Saulzar> I guess you want to have it convert the b to a Strhing :)
08:47:34 <ski> or ShowS
08:48:57 <Lemmih> MarcWeber: HaskellDB depends on hs-plugins?
08:49:16 <ski> showChar '[' . (compose . intersperse (showChar ',') . map (\(Show b) -> shows b) a) . showChar ']'
08:49:19 <ski> something like that
08:49:32 <ihope> So is letting it show the list rather than showListing it the best I can do?
08:50:18 <ski> ihope : try above
08:50:25 <ski> compose = foldr (.) id
08:50:32 <ski> @type intersperse
08:50:32 <ihope> ski: isn't that the same thing?
08:50:33 <lambdabot> Not in scope: `intersperse'
08:50:40 <ski> @type Data.List.intersperse
08:50:41 <lambdabot> forall a. a -> [a] -> [a]
08:51:03 <ski> ihope : you mean same as default ?
08:51:11 <ihope> Tes.
08:51:12 <ihope> s/T/Y/
08:51:28 <MarcWeber> Lemmih: Not all but loading the needed driver. I'm trying to get an example working before modifying anything now
08:51:42 <ski> ihope : probably
08:51:51 <ihope> :-)
08:52:11 <Saulzar> Ah, I see - I didn't realise you were trying to use showList, thought you forgot to "show" at all
08:54:02 <Lemmih> MarcWeber: Last time I looked at HaskellDB, genericConnect was something like 'genericConnect MySQL = mysqlConnect; genericConnect PostgreSQL = postgresConnect; ...'
08:55:48 <jonkri> what is the easiest way to convert [[1, 2, 3], [4, 5, 6], [7, 8, 9]] to [3, 6, 9]?
08:56:59 <ski> > map last [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
08:57:00 <lambdabot> [3,6,9]
08:57:09 <jonkri> thanks ski
08:58:06 <MarcWeber> Lemmih: It's much more strange.. I can't find that function.. but it's used in the test files.. I'll checkout again.
08:59:25 <basti_> hi all
08:59:34 <mathrick> @type foo 10 where foo (Integer x) = id
08:59:35 <lambdabot> parse error on input `where'
08:59:58 <mathrick> @type let foo (Integer x) = id in foo 10
08:59:59 <lambdabot> Not in scope: data constructor `Integer'
09:00:53 <basti_> whats the exact relation between haskell types and CT? I've been trying to figure it out myself, and advanced to something like: elementary haskell types form a category with functions as morphisms, and functions form own categories.
09:01:20 <Lemmih> MarcWeber: 'checkout'? HaskellDB is using darcs.
09:01:22 <basti_> but whats the connection of the datatype category, and the HOF category?
09:01:49 <MarcWeber> Lemmih: you are right
09:02:08 <MarcWeber> I forgot it. Grepping .bash_history is nice... The command was still there
09:04:16 <ski> basti_ : 'functions form own categories' ?
09:04:47 <basti_> ski: i mean, HOF's are the objects of a category distinct to the FOF-Category?
09:05:16 <basti_> i think that came out a little distorted... language...
09:06:21 <ski> you could have functor categories, i think
09:06:33 <ski> * -> *
09:06:34 <ski> etc
09:06:36 <basti_> oh
09:06:41 <basti_> yes of course
09:08:01 <basti_> i was thinking along the lines of: haskell functions are morphisms.
09:08:35 <basti_> now, what if a function is of higher order? is it a morphism of the same category as first-order-functions?
09:08:40 <ski> monomorphic functions are morphisms in the base '*' category, i think
09:08:59 <ski> (Int -> Bool) -> ([Int] -> Bool)
09:08:59 <ski> e.g.
09:09:07 <basti_> hmmm
09:09:24 <basti_> ah yes polymorphism
09:09:29 <ski> that would still be a morhism in same category
09:09:41 <ski> @type any
09:09:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:09:43 <basti_> so i was talking about monomorphic functions only
09:09:50 <ski> that is a nat. transf.
09:09:59 * basti_ ponders
09:10:25 <ski> hm
09:10:26 <basti_> because there is no type parameter?
09:10:45 <ski> (or is it ?)
09:10:57 <ski> 'type parameter' ?
09:11:10 <basti_> no type quantification
09:11:23 <ski> we have two contravariant functors, there
09:11:30 <basti_> we do, yes?
09:12:25 <ski> (it will probably be more complex, if the tyvar occur in both positive and negative positions)
09:12:38 <basti_> ohh.
09:12:44 <ski> if we say
09:12:55 <ski> f,g :: *^op -> *
09:13:00 <ski> f a = a -> Bool
09:13:06 <ski> g a = [a] -> Bool
09:13:36 <basti_> uhmmm
09:13:42 <ski> then isn't 'any' a natural transf. from 'g' to 'f' ?
09:14:26 <ski> hm
09:14:30 <basti_> from g to f?!
09:14:32 <ski> in the *^op category
09:14:39 <basti_> not from f to g?
09:14:57 <twobitsprite> if I "import Array (array, Array)" why can't I use "(Array.!)"?
09:15:06 <ski> i don't know if there's any term like "contravariant nat. transf." or whatever
09:15:19 <basti_> twobitsprite: maybe you didn't import (!)?
09:15:34 <ski> import Array (array, Array,(!))
09:15:42 <twobitsprite> basti_: I have to explicitly import it even though I'm using as a fully qualified op?
09:15:56 <ski> hm
09:15:56 <basti_> i can't say exactly, i'm sorry...
09:15:58 <twobitsprite> I don't want (!) to over-ride my local (!)
09:16:12 <ski> twobitsprite : what is the error ?
09:16:19 <twobitsprite> not in scope
09:16:28 <ski> ah, yes
09:16:36 <ski> import qualified Array ((!))
09:16:43 <ski> even, if you want
09:16:47 <MarcWeber> Lemmih: 2004-05-18 19:55  d00bring * src/HaskellDB.hs: Removed re-export of genericConnect, since this would force everyone yo link against all database drivers.. This is from the darcs changelog
09:17:03 <ski> import qualified Array as A ((!))  -- or something, don't remember if this is right order
09:17:07 <ski> to use (A.!)
09:17:25 <twobitsprite> I see
09:17:28 <twobitsprite> thanks
09:17:40 <basti_> ski: hmm, so, we got associative, monomorphic functions, which form a category (or don't they?) but which isn't interesting?
09:17:43 <ski> twobitsprite : note that you can 'import' same module many times, with some identifiers 'qualified' and others not
09:18:01 <twobitsprite> ski: yeah, that seems to work, thanks
09:18:34 <ihope> Note to self: the Monad class defines >>=, not (>>=).
09:18:45 <ihope> And stuff like that. . is the compose function.
09:18:51 <mathrick> ?
09:18:57 <ski> ihope : hm ?
09:19:02 <mathrick> (>>=) is the same as >>=
09:19:09 <mathrick> just prefix vs. infix
09:19:11 <basti_> yes.
09:19:28 <ski> basti_ : we hopefully get other related categories, too, like functor categories
09:19:51 <ihope> True, but the "normal" way to write it is >>=... or something.
09:19:58 <ihope> > (`mod` 3)
09:19:59 <lambdabot>  add an instance declaration for (Show (a -> a))
09:20:00 <ihope> > (`mod`)
09:20:00 <lambdabot>  parse error on input `)'
09:20:13 <basti_> ski: yes i see that, I just firsthand didn't think about -polymorphic- functions possibly becoming a category, but now that you mention it, it's obvious
09:20:19 <ski> basti_ : possibly we could have a 2-cat of the kinds, hmm
09:20:41 <ski> basti_ : how are '-polymorphic- functions possibly becoming a category' ?
09:20:51 <twobitsprite> how do I get my datatype to work as [(MyType 0)..(MyType 9)]?
09:20:53 <basti_> i had an inkling that we'd need to raise the category order at some point, yes...
09:21:13 <Lemmih> MarcWeber: Do you need to use several DB drivers?
09:21:16 <ski> (basti_ : not s/order/dimension/ ?)
09:21:26 <basti_> is dimension the word for n-cats?
09:21:39 <ski> i think i have seen that term used, at least
09:21:43 <basti_> okay
09:21:55 <ski> can't say how standard it is
09:22:03 <basti_> well polymorphic functions are functions on types, too.
09:22:26 <ski> er ?
09:22:37 <basti_> they have a kind other than *
09:23:02 <ski> @type map
09:23:04 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:23:15 <basti_> hmm
09:23:17 <ski> what kind does that have ?
09:23:18 <basti_> no they dont
09:23:54 <ski> higher-rankedness gets more complicated, of course
09:23:57 <MarcWeber> Lemmih: Only Mysql for now
09:24:09 <basti_> where is the documentation about this sort of stuff?
09:24:40 <ski> basti_ : is there any gathered ?
09:24:47 <basti_> not?
09:24:47 <basti_> ^^
09:25:09 <ihope> You can't "map Maybe [Int, String, Char]" and get [Maybe Int, Maybe String, Maybe Char]...
09:25:31 <ihope> If you could, there would be much oh noes.
09:26:11 * basti_ laughs
09:26:26 <MarcWeber> Lemmih: The last Select statement in the wiki is strange. That with tRow1 and tRow2. I don't understand the sense of that.
09:26:49 <basti_> i remember some discussion about being able to distribute functors
09:27:20 <ski> ihope : would that be a type-level list ?
09:27:29 <ihope> ski: yep.
09:27:45 <Lemmih> MarcWeber: What's strange about it?
09:27:48 <basti_> you -can- however, define lists on type-levels.
09:27:58 <twobitsprite> aarggggg.... types are giving me a headache
09:28:02 <ski> mapT :: forall k0 k1. (k0 -> k1) -> [k0] -> [k1]
09:28:10 <ihope> basti_: how?
09:28:17 <ihope> twobitsprite: what's the type?
09:28:23 <ski> basti_ : some church encoding ?
09:28:30 * ski wonders
09:28:53 <basti_> like "data TList a b = TCons a b | TNil" for example.
09:28:55 <ihope> type List a = Nil | Cons a (List a)
09:29:19 <twobitsprite> ihope: http://pastebin.com/609272
09:29:19 <basti_> you could make a TCons 17 (Tcons "a" TNil)
09:29:54 <twobitsprite> ihope: I feel like Goban should be "Goban (Position, Position) ..." instead of (Int, Int)...
09:29:55 <Saulzar> @query lambdabot
09:29:56 <lambdabot> Unknown command, try @listcommands.
09:30:04 <basti_> that somewhat like a list on type level
09:30:05 <Saulzar> (Whoops)
09:30:18 <twobitsprite> ihope: but when I do that, it seems like things break
09:30:38 <MarcWeber> Lemmih: Oh nothing. I need a break
09:30:50 <ihope> You could try "type Position = Int"...
09:31:00 <ski> basti_ : that's not type-level lists
09:31:11 <basti_> no its not.
09:31:12 <twobitsprite> ihope: but then I loose the constructor "Pos"
09:31:43 <twobitsprite> maybe I'm just taking on too big of a project for not knowing enough about haskell
09:31:48 <ihope> twobitsprite: well, what errors do you get with the Goban (Position, Position)?
09:31:56 <ski> (basti_ : you can't even contain type constructors of other kind than '*' in it ..)
09:31:59 <basti_> but there WAS a way wasnt it?
09:32:33 <wolverian> http://dheera.net/sci/sequence_sol.php <- that's an interesting expression
09:32:39 <ski> (basti_ : not that i'm aware of ..)
09:32:55 <basti_> hmm
09:33:13 <basti_> what about the PCP stuff in "evolution of a haskell programmer"
09:33:56 <twobitsprite> ihope: http://pastebin.com/609279
09:34:31 * ihope looks
09:35:02 <ihope> newGoban h = Goban (Pos w, Pos h) board
09:35:20 <twobitsprite> ihope: h is already a Position though
09:35:30 <twobitsprite> er...
09:35:38 <ihope> (Pos w, h) then
09:36:25 <twobitsprite> ihope: http://pastebin.com/609281
09:36:31 <twobitsprite> it's in the range that I have a problem
09:36:48 <ihope> Maybe [Pos 0 .. ln]
09:37:01 <twobitsprite> I can't get [Position..Position] to work
09:37:25 <ihope> Maybe using a newtype would be better...
09:37:42 <twobitsprite> newtypes scare me
09:37:54 <ihope> newtype Position = Pos {runPos :: Int} -- Don't worry, they're pretty much the same as data.
09:37:59 <twobitsprite> I just feel like I'm overloaded with all the complexities of the type system...
09:38:12 <int-e> @type \a -> [a..a]
09:38:13 <twobitsprite> I don't even know if I need a Position type, but I feel like I do...
09:38:13 <lambdabot> forall a. (Enum a) => a -> [a]
09:38:33 <ihope> Well, I don't see why type Position = Int wouldn't work.
09:38:34 <int-e> you need an enum instance. with newtype, you can derive that.
09:38:59 <ski> basti_ : PCP ?
09:39:11 <basti_> ski: a drug that gives birth to bad code.
09:39:44 <twobitsprite> ihope, int-e: Now I just feel like I'm plugging a bunch of magic into my code just becuase I think I _might_ need it later... *sigh*
09:39:49 <gzl> heh. in here, I would have assumed PCP = post correspondence problem.
09:39:52 <jyp> @quote
09:39:53 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files
09:39:53 <lambdabot> in Different Directories!"
09:39:55 <basti_> oh yes
09:40:51 <twobitsprite> ok, I'm going to refactor my Goban type into something much simpler...
09:41:00 <twobitsprite> I can add complexity later
09:44:58 <ihope> Oh, noes.
09:45:03 <ihope> facCps k n = facCps (k . (n *)) (n-1)
09:45:04 <int-e> twobitsprite: newtypes are basically type-safe type aliases. their syntax looks like single-constructor datas. they can derive any class that the encapsulated type has.   newtype Position = Position Int deriving (Enum, Ord, some more classes that Int has that you happen to need)
09:45:43 <ihope> But dang, that's a nice way of putting it.
09:45:44 <int-e> twobitsprite: the typesafe part is that you can't pass a Position for an Int and vice versa.
09:46:02 <twobitsprite> int-e: I think I'll just stick with working with the subset of haskell that I already understand until I get used to it, then I'll increment my knowledge for them :P
09:46:08 <wilx> @wiki
09:46:09 <lambdabot> http://www.haskell.org/haskellwiki/
09:46:20 * ski still sometimes prefer 'retricted typesynonyms' to 'newtypes'
09:46:57 <twobitsprite> int-e: ok, that last part made a lot of sense
09:47:43 <wilx> Hm, where was the TH tutorial?
09:48:18 <twobitsprite> int-e: ok, so how do I get my Position to behave in a [x..y] context?
09:48:31 <twobitsprite> int-e: where Position is a newtype
09:48:59 <ihope> Weird idea: if a pattern match fails *anywhere* inside a function, the next instance is tried.
09:48:59 <int-e> twobitsprite: you need an Enum instance for Position for that. Int has an Enum instance, so adding Enum to deriving (..) will do that.
09:49:32 <twobitsprite> int-e: it doesn't like me deriving Enum
09:49:33 <ihope> Weird extension: if *anything* fails anywhere inside a function, the next instance is tried.
09:49:43 <twobitsprite>     Can't make a derived instance of `Enum Position'
09:49:43 <twobitsprite>     (`Position' has non-nullary constructors)
09:49:53 <ihope> Are you using a newtype?
09:49:57 <twobitsprite> yep
09:50:05 <ihope> Hmm...
09:50:18 <twobitsprite> newtype Position = Pos Int deriving (Show, Ix, Ord, Eq, Enum)
09:50:44 <ihope> instance Enum Position where toEnum x = Pos x; fromEnum (Pos x) = x
09:50:49 <ihope> That should do it.
09:51:18 <int-e> hrm. try ghc(i) -fglasgow-exts  (is deriving for newtype an extension?)
09:52:02 <ihope> Dang, that "Interpretive Haskell programmer" must be insane...
09:53:08 <araujo> Hello!
09:53:12 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving <-- yes, it's en extension. :/
09:54:08 <twobitsprite> still doesn't like it
09:54:57 <twobitsprite> http://pastebin.com/609322
09:55:22 <twobitsprite> (and i'm running "ghci -fglasgow-exts"
09:55:24 <twobitsprite> )
09:55:39 <ihope> X-P
09:56:01 <int-e> And the haskell report specifies that the newtype is treated like data which is obviously bogus for Enum.
09:56:01 <ihope> Both ln and the Pos thingy are Positions?
09:56:07 <twobitsprite> ihope: yep
09:56:46 <int-e> Pos (h' ^ 2 + h') - 1 <-- wrong bracketing
09:56:52 <twobitsprite> ahh
09:57:14 <ihope> Seems like the error's in the wrong place, but I guess that might cause the thing...
09:57:34 <twobitsprite> fixed bracketing, same error
09:57:55 <Saulzar> map Pos [Pos 0..ln]  gives you a Pos Pos Int, no?
09:58:04 <twobitsprite> Saulzar: ahh ha
09:58:21 <twobitsprite> Saulzar: that did it
09:58:25 <twobitsprite> thanks :)
09:58:37 <int-e> hmm. right. the line I quoted actually works (although I'd change it)
09:58:55 <twobitsprite> (it always helps to have a fresh set of eyes look at your code... I tend to start hyper focusing on the small parts)
09:59:19 <twobitsprite> int-e: how would you change it? just put $ after Pos?
10:00:23 <int-e> twobitsprite: probably Pos (h' ^ 2 + h' - 1)
10:00:37 <int-e> Twigathy: I don't like $ for numerical expressions. but that's a matter of taste
10:04:30 <twobitsprite> do you think it's worth using (Integral a) instead of Int even though I'm never going to be using numbers outside the range of Int?
10:06:26 <Saulzar> I wouldn't, not unless you want it to be very general and re-used in different circumstances. But I don't know if that's good practice.
10:06:30 <int-e> no. if anything you'll get type confusions that way, one part of the code using Int as an index and another using Integer ...
10:07:06 <int-e> (with the obvious problems when you put these two parts together)
10:07:18 <ski> ihope : which function should fail ?
10:10:23 <ihope> ski: well, if a called function fails, then all its possibilities are tried. If nothing's found, then the next instance of the calling function is tried.
10:11:04 <ski> (ihope : also, i think this would break law of substitution)
10:11:32 <ski> you want to have an implicit Maybe-monad, you mean ?
10:11:41 <ihope> ski: something like that, I suppose.
10:11:45 <ski> (integrated with pattern-match-failure)
10:11:56 <ski> this would be a side-effect
10:13:03 <ski> if you pass in 'let Just x in Nothing in x' to a function, where should it go if that is forced ?
10:13:29 <ski> to the function that passed in this ? or to the one that forced it ?
10:13:39 * ihope thinks
10:14:02 <ihope> If you pass it to a function, then it's evaluated, the next instance of the recieving function is called.
10:14:39 <ihope> foo (_:_) = "meh"
10:14:46 <ihope> foo [] = "ooh"
10:14:54 <ihope> foo _ = "uh oh"
10:15:06 <ihope> foo undefined = "uh oh" -- :-)
10:15:19 <ski> err of course i meant 'let Just x = Nothing in x'
10:15:21 <twobitsprite> ihope: wouldn't that break type safety?
10:15:41 <ihope> twobitsprite: how?
10:15:49 <ski> twobitsprite : ditto
10:16:07 <twobitsprite> the third case should never arise because "foo :: [a] -> String" and the first two cases should match any [a]
10:16:19 <twobitsprite> right?
10:16:41 <ihope> Um...
10:17:10 <ihope> But they don't match undefined.
10:17:11 <twobitsprite> ski: ditto what I said, or what ihope said?
10:17:27 <twobitsprite> ihope: you mean "_|_"?
10:17:28 <ski> (latter)
10:18:08 <ihope> twobitsprite: there's errors and nonterminations. This doesn't match errors, and it doesn't terminate on nonterminations.
10:19:31 <twobitsprite> I'm not sure I follow
10:20:16 <ihope> _|_ lumps two things into the same category.
10:20:48 <ski> errors is a kind of diverging
10:20:52 <twobitsprite> I thought it was the value of errors?
10:21:22 <ski> errors have no value
10:21:25 <ihope> ski: well, that's what I'm one-tenth-seriously suggesting we change!
10:22:02 <twobitsprite> ski: I thought the haskell report said _|_ was an error
10:22:51 <ski> you have to differentiate between values and values :)
10:23:12 <ski> we have "real values" and "semantic values"
10:23:31 <ski> '_|_' belongs to the latter
10:23:31 <palomer> hmm?
10:23:35 <twobitsprite> ski: right
10:23:49 <twobitsprite> I meant the latter
10:24:19 <ski> in the usual semantics, both nontermination and calls to 'error' yield '_|_'
10:25:03 <ski> (but see e.g. the semantics for imprecise exceptions)
10:25:12 <ski> (for another take)
10:25:17 <twobitsprite> by "nontermination" do you mean, i.e. a recursive call with no base case?
10:25:27 <ski> not necessarily
10:25:29 <twobitsprite> right, ok
10:25:36 <ski> i mean stuff like 'let x = x in x'
10:25:44 <ski> or 'let x = 1+x in x'
10:25:50 <ski> but not 'let x = 1:x in x'
10:26:03 <ski> since '(:)' is not strict in second arg
10:26:54 <twobitsprite> right... so essentially something in infinite _lexical_ (or maybe semantic) recursion, as opposed to executional recursion?
10:27:19 * twobitsprite questions his wording, but hopes his meaning it preserve
10:27:20 <twobitsprite> d
10:27:26 <ski> something where we can't even determine the top-level constructor, yes
10:27:38 <twobitsprite> k
10:28:21 <ski> '1 : let x = x in x' e.g. is a partial value
10:28:33 <twobitsprite> interesting how Haskell will attempt to infinitely evaluate your example, but Ocaml will just give an error... I guess this is due to laziness?
10:28:34 <ski> we can determine first cell in the list, but not next
10:29:03 <ski> twobitsprite : did you try 'let rec x = 1 :: x;;' ?
10:29:28 <wilx> Hmm, about Template Haskell...let's say I say x = (1,2) in my module. Now I would like to pass the x to some of my TH functions so that it can analyze it and find out its arity.
10:29:51 <twobitsprite> ski: yeah, it returns [1; 1; ...] (well... with a lot more "1; "s and then an actuall "...")
10:30:06 <ski> that's the printer chickening out
10:30:13 <twobitsprite> heh
10:30:30 <twobitsprite> I'd like to say it's the printer being smart and noticing the pattern :P
10:30:43 <twobitsprite> (but that's all semantics :P)
10:30:47 <ski> so, if you tried 'let x = 1 :: x;;' or something similar, you'll see that that has different scoping properties, hence fails
10:30:47 <alar> 2bitsprite: in Haskell "let" stands for "letrec" in ML
10:30:58 <twobitsprite> alar: I realize this
10:31:08 <twobitsprite> alar: er... "let rec" in ocaml
10:31:17 <alar> oh, sorry
10:31:23 <wilx> The thing is that it gets expanded/substitued and I get type erros. Instead of something like Exp I get the tuple type (,).
10:31:50 <alar> let x=u in v -> (\x -> v) u
10:32:25 <alar> letrec is the same with hidden Y within :)
10:32:49 <twobitsprite> alar: smarty-pants :P
10:33:37 <twobitsprite> alar: letrec still isn't syntactically correct
10:34:03 <ihope> Is there any type representing a letter of the Latin (i.e. English) alphabet?
10:34:43 <twobitsprite> ihope: that seems like a job for smart constructors...?
10:34:49 <jyp> Char ?
10:34:54 <ihope> twobitsprite: whats?
10:35:14 <twobitsprite> ihope: I'm guessing you mean something like [a..z] ++ [A..Z]
10:35:28 <ihope> twobitsprite: no, just one or the other
10:35:40 <ihope> a = A, b = B etc.
10:36:07 <twobitsprite> data Latin = A | B | C | ... -- ?
10:36:18 <ihope> Yep.
10:36:42 <twobitsprite> oh, you're wondering if there is one predefined?
10:36:56 <ihope> Yeah/
10:37:00 <twobitsprite> ohh... I dunno
10:38:10 <twobitsprite> I thought you meant: latin c | c `elem` ([a..z] ++ [A..Z]) = Latin c -- or something, which is why I mentioned smart constructors...
10:38:48 * ihope looks closer
10:38:56 <ihope> @google haskell smart constructor
10:38:57 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
10:40:43 <alar> latin c | isalpha c
10:41:19 <twobitsprite> alar: yeah, that too :P
10:41:35 <twobitsprite> > isalpha 'a'
10:41:36 <lambdabot>  Not in scope: `isalpha'
10:41:39 <twobitsprite> > isAlpha 'a'
10:41:40 <lambdabot> True
10:42:17 <ihope> > isDigit '3'
10:42:18 <lambdabot> True
10:42:19 <ihope> > isDigit 'a'
10:42:20 <lambdabot> False
10:42:25 <ihope> > isHexDigit 'a'
10:42:26 <lambdabot> True
10:45:03 <twobitsprite> > isNoun "boat"
10:45:04 <lambdabot>  Not in scope: `isNoun'
10:45:05 <twobitsprite> :P
10:45:09 <ihope> Heh.
10:45:31 <ihope> > collatzConjecture == True
10:45:32 <lambdabot>  Not in scope: `collatzConjecture'
10:45:41 <twobitsprite> lol
10:45:54 <ihope> Now, let's see here...
10:46:34 <palomer> c# is getting record syntax
10:46:36 <palomer> wicked.
10:46:44 <twobitsprite> eww
10:46:51 <palomer> well, a part of record syntax
10:46:59 <ihope> First, we take the number and facotrize it, then remove all the 2's. Then we add a 3 to it, then do some Scrambling.
10:47:08 <ihope> Then we start over.
10:47:20 <ihope> The problem is what Scrambling does...
10:47:45 <ihope> I know it removes every factor, then adds some factors that weren't there before.
10:48:51 <ihope> 2 -> 3 -> 2*2 -> 5 -> 2*3 -> 7 -> 2*2*2 -> 3*3 -> 2*5 -> 11 -> 2*2*3 -> 13 -> 2*7 -> 3*5 -> 2*2*2*2 -> 17 -> 2*3*3 -> 19 -> 2*2*5
10:50:33 <twobitsprite> ???
10:50:34 <lambdabot> Maybe you meant: . id pl wn
10:50:45 <twobitsprite> heh
10:51:19 <int-e> ihope: one of the factors is a two, and you can say very little about the others
10:51:24 <ihope> > [2,3,2*2,5,2*3,7,2*2*2,3*3,2*5,11,2*2*3,13,2*7,3*5,2*2*2*2,17,2*3*3,19,2*2*5]
10:51:25 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:52:03 <ihope> int-e: if x is an integer, 3x+1 is not a multiple of three.
10:52:31 <jips> \seen dons 
10:52:32 <lambdabot> dons is in #haskell. Last spoke 3 hours, 54 minutes and 48 seconds ago.
10:52:39 <int-e> ihope: read what I wrote again, please.
10:53:23 <int-e> ihope: hmm. ok, none of the factors is three.
10:53:25 <twobitsprite> cyclic data structures in Haskell are _hard_ :(
10:53:29 <int-e> ihope: is that what you meant?
10:53:38 <ihope> int-e: yes.
10:56:40 <twobitsprite> is it more commond to 0-index or 1-index in haskell?
10:57:03 <ihope> > [1,2,3,4,5,6] !! 4
10:57:03 <Igloo> 0
10:57:04 <lambdabot> 5
10:57:10 <ihope> Yep, looks like 0.
10:57:47 <Heffalump> but fst and snd
10:58:08 <twobitsprite> hmm... I was just thinking how it was odd that [0..4] => [0,1,2,3,4] insead of [0,1,2,3] like you find in most languages (i.e. rang(0,4) in python...)
10:58:34 <twobitsprite> s/rang/range
10:58:43 <wolverian> I find python's behaviour strange.
10:58:55 <twobitsprite> wolverian: in a lot of ways it is :P
11:00:51 <int-e> twobitsprite: hmm, has python become 'most languages' now? What other examples for that behaviour do you have?
11:01:30 <twobitsprite> wolverian: well... in python range is used to get a list of indexes, i.e. "for i in range(0,len(mylist))
11:01:53 <astrolabe> You could argue C is a bit similar
11:01:57 <palomer> man, after using haskell and java, it's a pleasure to have fast compilation times with gcc
11:02:14 <int-e> astrolabe: in C the comparison is explicit
11:02:18 <wolverian> twobitsprite, that's confusing two different things.
11:02:55 <wolverian> twobitsprite, mylist.end and mylist.elems would be the right separation. 
11:03:22 <twobitsprite> wolverian: well "[0..length myList - 1]" is a but cumbersome
11:03:36 <Korollary> length of lists is cumbersome.
11:03:58 <twobitsprite> Korollary: yeah... I always found 0-indexing to be a bit cumbersome
11:04:13 <Korollary> I mean indexing at all is cumbersome.
11:04:29 <twobitsprite> Korollary: oh?
11:04:40 <twobitsprite> Korollary: well... indexing of arrays makes a lot of sense
11:05:27 <ihope> What Haskell function takes a String and stores it in memory, starting at address 0?
11:05:31 <ihope> >:-)
11:06:00 <twobitsprite> ihope: eh?
11:06:12 <Heffalump> unsafePerformIO (...)
11:06:19 <Heffalump> duh ;-)
11:06:34 <ihope> Heffalump: why the unsafePerformIO? Is this an IO (IO a)?
11:06:57 <Heffalump> is what an IO (IO a)?
11:07:13 <Heffalump> oh, if you want something of type String -> IO () you don't need the unsafePerformIO.
11:09:11 <ihope> Yes, that'll work.
11:09:36 <ihope> Well, maybe I should write this in assembler or something. Much shorter :-)
11:09:56 <twobitsprite> ihope: want to write to memory address 0?
11:10:00 <int-e> C will do
11:10:18 <ihope> twobitsprite: yeah.
11:10:28 <ihope> Well, the program just has to overwrite itself in memory.
11:10:41 <twobitsprite> ihope: why?
11:11:12 <ihope> Isn't that the simplest way to do self-modifying code?
11:11:27 <Korollary> what architecture is this? You'll get a segv more than likely.
11:11:56 <ihope> x86, I guess.
11:11:57 <twobitsprite> ihope: if you want to modify your code on the binary level...
11:12:03 <ihope> twobitsprite: yeah.
11:12:18 <ski> for what purpose do you want to modify ? change constants ?
11:12:23 <twobitsprite> ihope: on any decent O/S (i.e. Windows, Linux, BSD, etc) your program will be killed by the OS
11:12:28 <ski> s/constants/immediate constants/
11:12:47 <ihope> twobitsprite: I'm wanting to *write* an operating system.
11:13:10 <twobitsprite> ihope: ahh... a self modifying OS...
11:13:17 <Korollary> You could do it for msdos executables. 32-bit linkers set the code segments to read only iirc. You may need to write some assembly to set the writable flag on the code segment.
11:13:26 <ihope> twobitsprite: yep.
11:15:24 <davidhouse> jyp, if you're around and interested, http://paste.lisp.org/display/18004 is the final lambda evaluator using a pure let and Reader
11:19:39 <davidhouse> what's the minimal complete definition for Show?
11:19:52 <ihope> I think show.
11:19:59 <alar> 
11:20:02 <alar> showprec
11:20:07 <sjanssen> show or showsPrec
11:20:12 <davidhouse> what does showsPrec do?
11:20:45 <ihope> showsPrec _ x s   = show x ++ s
11:20:59 <ihope> That's the default.
11:21:00 <sjanssen> it takes a precendence argument, this way showsPrec can pretty print statements with operators
11:21:42 <ihope> Ah!
11:21:52 <ihope> Um.
11:22:16 <lisppaste2> jyp annotated #18004 with "Lambda eval" at http://paste.lisp.org/display/18004#1
11:22:31 <ihope> AHA! So THAT's impossible, too!
11:22:59 <sjanssen> ihope: you should look at Foreign.Ptr, especially castPtrToFunPtr
11:23:22 <ihope> Um, I think I'll just pretend to use assembler.
11:23:53 <jyp> @pl liftM (flip (M.!) iden) $ ask
11:23:53 <lambdabot> fmap (flip (M .!) iden) ask
11:24:07 <jyp> @pl liftM (flip (!) iden) $ ask
11:24:07 <lambdabot> fmap (! iden) ask
11:24:39 <davidhouse> jyp, closures?
11:25:20 <jyp> A representation of (\x->expr) that persists in the heap
11:25:48 <jyp> Incidetally, type VTable = M.Map VarName Int would become type VTable = M.Map VarName Value
11:26:02 <jyp> and data Value = Scalar Int | Closure ...
11:26:27 <ihope> @google closure
11:26:28 <lambdabot> http://www.closuremusic.com/
11:26:32 <jyp> (or another representation)
11:26:38 <jyp> @google haskell closure
11:26:40 <lambdabot> http://www.haskell.org/hdirect/ffi-11.html
11:27:36 <jyp> davidhouse: closure = partially evaluated expression, is prehaps a better definition
11:27:46 <davidhouse> i see
11:27:48 <davidhouse> example?
11:28:39 <ski> closure is a way of representing function values
11:28:50 <jyp> in the above, (! iden) is a partially applied function
11:29:04 <ski> '(\x -> y -> x + y) 4' will return a closure
11:29:06 <jyp> so the runtime might represent it as a closure at some point
11:29:17 <ski> er
11:29:24 <ski> (\x -> \y -> x + y) 4
11:30:16 <davidhouse> jyp, ah.
11:30:37 <gba> Does someone know if there are papers or books about "functional software engineering" ? All books and papers I read wrote about thinking in objects even in the requirements analysis phase. 
11:30:42 <ski> the closure here would consist of the code '\y -> x + y' and the bindings for the free variables, in this case that 'x' is bound to '4'
11:31:21 <snk_kid> ahoy hoy
11:31:33 <jyp> @google functional software engineering
11:31:35 <lambdabot> http://www.amazon.com/exec/obidos/tg/detail/-/0792386663?v=glance
11:32:42 <jyp> useless.
11:33:20 <gba> jyp, this is not what I would want to read
11:33:41 <jyp> I know. I could always try, uh ? :)
11:33:47 <gba> yeah
11:33:57 <snk_kid> i don't think you'll find anything useful from typical software engineering in the functional departement except maybe in formal methods
11:34:12 <twobitsprite> is there a disjoint array type? i.e. hashtables?
11:34:27 <gba> snk_kid, this is also what I think
11:34:37 <gba> snk_kid, but it's a pity
11:35:04 <jyp> A lot of the software engineering babblings address problems that disappear by themselves when you use a decent language like haskell, imho.
11:35:33 <snk_kid> i don't know if it's a pity, personally i think alot of stuff from SE is a bunch of rubbish except for formal methods
11:36:02 <ski> http://www.mm.informatik.tu-darmstadt.de/~kuehne/fps/ ?
11:36:21 <jyp> twobitsprite: like Data.Map ?
11:36:33 <gba> Okay but how do you make design docs and something like that for projects with 50 and more devs if SE is rubbish?
11:36:44 <_Codex> Btw, how do you think operation called "hiding" works?
11:37:38 <ski> import Prelude hiding (take)
11:37:42 <ski> take = ...
11:37:49 <gba> ski, cool thanks for that link :)
11:38:21 <twobitsprite> jyp: I don't see that in the Zvon reference or the index for the haskell report...
11:38:26 <twobitsprite> @where Map
11:38:27 <lambdabot> I know nothing about map.
11:38:27 <_Codex> ski: same op, but I'm meaning more generic version of it.
11:38:29 <snk_kid> most of what comes out of SE (especially in the OO department) is about more about opinions & how somebody 'feels' just like how nobody can tell what OO really is apart from the obvious '3' that people agree, the rest is in the eyes of the beholder
11:38:30 <twobitsprite> @where Data.Map
11:38:31 <lambdabot> I know nothing about data.map.
11:38:36 <twobitsprite> @index Map
11:38:37 <lambdabot> Data.Map
11:39:02 <jyp> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-Map.html
11:39:12 <ski> _Codex : hm ?
11:39:31 <_Codex> like in category diagrams do not need to describe all arrows of a category, you need hiding so that you can draw diagrams.
11:39:58 <ski> hrmm ?
11:40:31 * ski fails to see the connection
11:41:56 <_Codex> ski: I mean, a diagram only describes part of all the arrows of a category.
11:42:03 <ski> (iirc a diagram can be seen as a functor into the category in question, from a "shape" category describing what the diagram looks like)
11:42:10 <ihope> Hmm, /me does something
11:43:45 <snk_kid> is there some kind of correlation between dependant type system and sequent calculus?
11:43:49 <_Codex> ski: yes, exactly that: diagram can be seen as functor I->C, where I is the shape, and C is (bigger) category.
11:44:27 <ski> (_Codex and the functor is usually not surjective in objects nor morphisms ..)
11:45:00 <ski> snk_kid : former can be expressed with a latter, i think
11:45:30 <ihope> Do latters have rangs?
11:45:54 <snk_kid> ski: well this sight on Qi suggests that is would be the other way round
11:46:07 <ski> snk_kid : mhm ?
11:46:54 <snk_kid> ski: Qi is programming language based lisp that has turing-complete type system, that can subsume any type theory in existance apparently
11:47:24 <ski> substructual ones, also ?
11:47:34 <ihope> Dang, no arrows either. We can't get Nums or Eqs...
11:47:39 <snk_kid> http://www.lambdassociates.org/advtypes.htm
11:48:01 <snk_kid> "Qi has the most powerful type theory of any language that will ever be invented."
11:48:10 <snk_kid> pretty bold claim
11:48:45 <snk_kid> well i have no clue what "sequent calculus" is about so i can't really comment
11:48:46 <ihope> Yep.
11:49:13 <ihope> @index integerEq
11:49:14 <lambdabot> bzzt
11:49:59 <ihope> Ooh, functors.
11:50:08 <ski> snk_kid : sequent calculus is a means of presentation of a logical system (or type theory, for that matter)
11:50:31 <ski> snk_kid : others are hilbert-style, natural deduction, fitch style, proof nets, etc
11:51:01 <ski> sequent calculus was invented by Gerhard Genzen, iirc
11:51:31 <ski> (hm 'Gentzen' ?)
11:51:59 <ihope> Yay, I now have a type constructor that can represent any functor.
11:52:09 <ski> ihope : hm ?
11:52:20 <ihope> The problem: any type made with this constructor is useless!
11:52:38 <ihope> data Functor_ a where Functor :: Functor f => f a -> Functor_ a
11:52:49 <ihope> instance Functor Functor_ where fmap f (Functor x) = Functor (fmap f x)
11:56:03 <ihope> So how do I do fancy console stuff with Haskell?
11:56:33 <Korollary> ncurses?
11:59:22 <ski> ihope : you might be interested in this message http://groups.google.com/group/comp.lang.functional/msg/ac9ec53dd11e97a2 and Adrian Hey's reply to it
12:01:14 <ihope> ski: what is it?
12:01:43 <ski> ihope : about "binary methods" problem
12:02:10 <ski> e.g. with your 'Monad_' type before, you couldn't ensure both args to '(>>=)' used same monad
12:02:20 <ihope> Ah.
12:02:35 <ihope> It seems there are many classes with that problem.
12:02:57 <ski> ihope : i just though that thread could be interesting, in respect to that
12:03:11 * ski found it thus, at least
12:03:15 <snk_kid> multimethods?
12:03:19 <ski> no
12:03:32 <ihope> Even Show's one, it seems: you can't know that a list of Show_s is homogenous.
12:03:43 <snk_kid> i'm not really paying attension anyways :)
12:03:50 <ski> snk_kid : know any ML ?
12:04:14 <snk_kid> i did, my memory needs refreshing
12:04:53 <ski> if you do a functor for a set module, say, with input being comparision, then you can ensure you use same compaision when merging sets
12:05:11 <ski> as opposed to if you carry comparision inside every individual set
12:05:40 <ski> ihope's existentials above is similar to this latter
12:06:11 <ihope> So far, the only existential for a class that's actually a member of that class is Functor_.
12:06:23 <ski> (only worse, since the type can also vary)
12:06:24 <ihope> And Functor_ is useless.
12:06:51 <ski> data ShowFunctor_ a where ShowFunctor :: (Show (f a),Functor f) => f a -> ShowFunctor_ a
12:06:52 <ski> ?
12:07:29 <ihope> That makes me dizzy...
12:08:00 <ihope> Well, I think we can't showList this one either.
12:09:08 <ski> why not ?
12:09:25 <ski> (and which couldn't you 'showList', earlier ?)
12:09:45 <ihope> data Show_ where Show :: Show a => a -> Show_
12:10:01 <ski> why not ?
12:10:01 <ihope> instance Show Show_ where showList = ?
12:10:21 <ski> i thought i gave something for that, earlier ?
12:10:24 <ihope> If the list you get is heterogenous, then you can't showList it.
12:10:32 <ski> i don't see that
12:10:53 <ski> just first map it to [ShowS], then convert that to ShowS
12:11:11 <ihope> Well, the showList for a Char is different from the default.
12:11:24 <ski> yes
12:11:31 <ski> but there's no way around that
12:11:36 <ski> also, this isn't 
12:11:43 <ski> har]
12:11:45 <ski> arg
12:11:53 <ski> [Char]
12:11:54 <ihope> Right. Does adding the Functor restraint add a way around?
12:12:05 <ski> around what ?
12:12:22 <ihope> The showList problem, with showing heterogenous lists.
12:12:41 <ski> i still don't see a problem
12:13:30 <ihope> Well, how could you showList a list of Show'd Strings?
12:13:40 <ihope> s/Strings/Chars/
12:14:04 <ski> ['a','b','c']
12:14:19 <ski> no way around that
12:14:33 <ski> or
12:14:47 <ski> [Show 'a',Show 'b',Show 'c'] -- is also possible :)
12:17:31 <ihope> But [Show 'a', Show 'b', Show 'c'] doesn't work the same as Show "abc".
12:17:46 <ihope> By the way, I just stumbled upon a way to type the letter Ç.
12:18:07 * ski wishes he could see it
12:18:17 <ihope> C with cedilla.
12:18:36 <ski> of course those two doesn't work the same .. they are different !
12:18:55 <tuomov> <compose> , C
12:19:07 <ihope> ski: ['a', 'b', 'c'] = "abc", though.
12:19:16 <ski> yes
12:19:22 <ski> but 'Show' is not 'id'
12:19:37 <ihope> tuomov: on my keyboard, 'C
12:19:52 <ihope> ski: but it's supposed to act that way with regards to the Show class.
12:20:05 <ihope> If it doesn't, then the point of the type is pretty much ruined.
12:20:17 <ski> hm
12:20:53 <ski> @type readList
12:20:54 <lambdabot> forall a. (Read a) => ReadS [a]
12:21:32 <ski> > (readList :: ReadS [Char]) "\"abc\""
12:21:33 <lambdabot> [("abc","")]
12:21:44 <ski> > (readList :: ReadS [Char]) "['a','b','c']"
12:21:45 <lambdabot> [("abc","")]
12:22:02 <ski> both variants seem to read fine, though
12:22:28 <ski> (of course, you can't read a 'Show' value)
12:22:57 <wilx> @paste
12:22:58 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
12:27:31 <wilx> I pasted my code.
12:27:39 <wilx> Why do I get AppT instead of TupleT?
12:27:47 <wilx> I mean, I would expect TupleT.
12:30:18 <ski> (guessing) maybe you get an application of the 'TupleT' constructor ?
12:30:37 <ihope> @index <+>
12:30:37 <lambdabot> Control.Arrow, Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ,
12:30:37 <lambdabot> Text.PrettyPrint
12:33:31 <twobitsprite> why is it when I "import Data.Map (Map)" it seems to import Data.Map.! ?
12:33:50 <ihope> Maybe I should skip the fancy IRC stuff and make my poor little bot communicate directly with the server.
12:37:33 <wilx> Hmm.
12:38:29 <ihope> Whoa. The only class I haven't tried yet is Read?
12:40:22 <ihope> And a value which you can only readsPrec and readList on is pretty useless, like Functor.
12:44:13 <ihope> Hmm...
12:44:19 <ihope> @index StdGen
12:44:20 <lambdabot> System.Random
12:44:40 <ihope> I think it'll work!
12:48:01 <ihope> Yay, it did!
12:48:14 <MarcWeber> Is this a preprocessor command: INSTANCE_TYPEABLE1([],listTc,"[]") ? I get a syntax error here. Of cause that is no legal haskell code..
12:48:35 <ihope> > INSTANCE_TYPEABLE1([],listTc,"[]")
12:48:36 <lambdabot>  Not in scope: `listTc'
12:48:40 <ihope> It's legal Haskell.
12:49:04 <MarcWeber> Then the new cvs ghc compiler is broken somwhere.
12:49:39 <MarcWeber> I've never seen this syntax before (in haskell).. What does it mean?
12:49:46 <MarcWeber> It's from hs-plugins
12:51:40 <ndm_> INSTANCE_TYPEABLE1 is defined in typeable.h
12:54:02 <ihope> MarcWeber: it's not special syntax. INSTANCE_TYPEABLE1 could be a data constructor and ([],listTc,"[]") is a tuple.
12:54:02 <MarcWeber> ndm_: So all I have to do is adding this file to the preprocessor?.. hmm.. Let me look up how to do this...
12:54:46 <ndm_> MarcWeber: maybe, its all very confusing, but it is handled by the cpp
12:54:47 <MarcWeber> ihope: It is in that way that you would normally insert a space .. but you are right.. it could
12:55:20 <ndm_> its definately not a data declaration, i know that much :)
12:55:25 <MarcWeber> ndm_: Do you also know how to tell cabal/ ghc to feed the cpp with this file before doing anything?
12:55:37 <ndm_> MarcWeber: not a clue
12:55:45 <MarcWeber> ndm_: Thanks a lot!
12:56:03 <ndm_> no probs, i was stuggling with Typeable stuff last week as well, for Yhc
12:56:46 <MarcWeber> ndm_: I'll call cpp manually .. Then I'll get proper error lines as well (sure).. YEah.
12:57:36 <ndm_> MarcWeber: i used cpphs, and it worked fine after a while
12:57:46 <ndm_> @where cpphs
12:57:47 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
13:00:00 <ihope> @hoogle RandomGen a => a -> [Int]
13:00:01 <lambdabot> System.Random.randoms :: (Random a, RandomGen g) => g -> [a]
13:00:31 <ihope> What's Random?
13:01:34 <ihope> Things which can be randomly generated?
13:02:43 <drakioned> hmm
13:03:14 <drakioned> "This library deals with the common task of pseudo-random number generation"
13:03:57 <MarcWeber> ihope: Random is class which provides random randomRS and so on for different types.
13:04:11 <ihope> Yeah, that helps...
13:04:13 <MarcWeber> ihope: you need mkStdGen .
13:04:34 <MarcWeber> this will generate a random generator "state" (see state monad examples ;)
13:04:38 <ihope> Would doubling a Blum Blum Shub seed make a good "new" seed?
13:04:54 <MarcWeber> you can than use random or randomR to get a random value and a new state
13:27:12 <MarcWeber> ndm_: ThAnkS It cOMpiLEs !
13:28:44 <MarcWeber> Lemmih: hs-olugins is compiled (thanks to cpphs and ndm_), genericConnect has been renamed to dynConnect.. Let's GO! ;) I like haskell !
13:29:31 <gvdm> say, where gan i get some docs on haskell-mode, i have no clue what it does or how to invoke its functions
13:29:39 <gvdm> s/gan/can/
13:29:59 <twobitsprite> can you pattern-match in a lambda?
13:30:16 <ihope> twobitsprite: only one pattern. You can use case to get more.
13:30:33 <ihope> \x -> case x of (y:ys) -> blum; [] -> shub
13:30:33 <lambdabot> compose module failed: Parse error: "->"
13:32:24 <twobitsprite> @pl filter (\ x -> case Maybe _ -> True; Nothing -> False)
13:32:25 <lambdabot> (line 1, column 27):
13:32:25 <lambdabot> unexpected "_"
13:32:25 <lambdabot> expecting variable, "(", operator or ")"
13:32:31 <twobitsprite> @pl filter (\ x -> case Maybe x -> True; Nothing -> False)
13:32:31 <lambdabot> (line 1, column 29):
13:32:31 <lambdabot> unexpected ">"
13:32:31 <lambdabot> expecting variable, "(", operator or ")"
13:32:48 <twobitsprite> @pl filter (\ x -> case x of Maybe _ -> True; Nothing -> False)
13:32:49 <lambdabot> (line 1, column 32):
13:32:49 <lambdabot> unexpected "_"
13:32:49 <lambdabot> expecting variable, "(", operator or ")"
13:32:52 <Cale> The @pl module doesn't know about case
13:32:52 <twobitsprite> doh
13:32:57 <twobitsprite> I see
13:33:28 <Cale> also, it's Just x, not Maybe x
13:33:29 <twobitsprite> ok, well... you see what I'm trying to do... and I assume I can do something monadic here... but I'm not quite sure what...
13:33:35 <twobitsprite> ohh yeah...
13:33:37 <Cale> > isJust (Just 5)
13:33:38 <lambdabot> True
13:33:42 <Cale> > isJust Nothing
13:33:43 <lambdabot> False
13:33:46 <twobitsprite> ahh
13:34:45 <gvdm> foldl1 (+) [1,3..10]
13:34:46 <twobitsprite> what about one that will filter out all of the Nothing's and return a list of the contents of all the Just's?
13:35:06 <resiak> filter inJust
13:35:15 <gvdm> how do you get lamdabot to do stuff?
13:35:19 <resiak> uhm, isJust.
13:35:26 <resiak> > foldl1 (+) [1,3..10]
13:35:28 <lambdabot> 25
13:35:30 <astrolabe> @hoogle [Maybe a] -> [a]
13:35:31 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
13:35:55 <twobitsprite> astrolabe: I need to start remembering about hoogle..
13:35:58 <twobitsprite> thanks
13:36:28 <gvdm> anyway, back to my original question, where can i get haskell-mode docs? or does everybody use some non/emacs editor?
13:36:46 * twobitsprite uses vim
13:36:52 <astrolabe> I use emacs but without a special mode
13:37:08 * twobitsprite doesn't use a special mode either
13:37:29 <Cale> the website where you download haskell-mode has some info
13:37:40 <Cale> I just installed it for the syntax highlighting
13:39:18 <twobitsprite> @pl Data.Maybe.catMaybes $ map ((flip Map.loopup) chains) (friends pos)
13:39:19 <lambdabot> Data (Maybe (catMaybes (map (flip Map (loopup chains)) (friends pos))))
13:39:39 <twobitsprite> heh
13:40:59 * twobitsprite just browses the docs
13:42:32 <twobitsprite> is there a web interface for @pl so I don
13:42:39 <twobitsprite> t have to spam the channel?
13:42:58 <Cale> you can msg lambdabot directly
13:43:05 <twobitsprite> that works too
13:43:34 <alar>  /query lambdabot
13:44:02 <alar> in private lambdabot has more abilities than in channel
13:54:09 <ihope> So it looks like CPS can make many things tail-recursive.
13:54:17 <palomer> http://java.sun.com/developer/technicalArticles/Interviews/livschitz_qa.html  <--biggest load of crap, ever
13:54:26 <twobitsprite> ihope: CPS?
13:54:47 <ihope> Continuation passing style.
13:55:24 * ihope attempts to come up with a tail-recursive Ackermann function
13:55:47 <twobitsprite> palomer: which part is crap?
13:57:24 <ihope> Well, I guess that particular thing could have been tail-recursive anyway.
14:02:37 <gvdm> hmm access nth element of list?
14:02:40 <gvdm> get?
14:02:44 <gvdm> no...
14:02:45 <basti_> !
14:02:51 <basti_> @type (!)
14:02:51 <twobitsprite> l ! n
14:02:51 <ihope> !!
14:02:52 <lambdabot> Not in scope: `!'
14:02:56 <basti_> @type (!!)
14:02:57 <lambdabot> forall a. [a] -> Int -> a
14:02:59 <basti_> ah
14:03:02 <twobitsprite> er, yeah
14:03:09 <ihope> > ['a','b','c'] !! 1
14:03:10 <lambdabot> 'b'
14:03:29 <gvdm> cool
14:04:04 <twobitsprite> gvdm: I hate being the one to do this, but odds are you are making a poor design choice if you're going to be indexing a list a lot
14:04:39 <wilx> Aww, too long interview. 
14:04:45 <wilx> What does she say there?
14:04:54 <gvdm> naa, thats cool, im not building anything, messing around in hugs
14:04:59 <MarcWeber> I've read that hmake should be able to automatically add package dependencies, right?
14:05:14 <twobitsprite> wilx: I couln't finish it either, but it sounded like a lot of garbage
14:05:17 <gvdm> i get that you do things in different ways
14:05:37 <twobitsprite> gvdm: me?
14:06:11 <gvdm> yeah
14:06:36 <gvdm> no as in, when you do things in haskell, they are different from other languages
14:08:21 <twobitsprite> ahh, yes
14:09:08 <twobitsprite> gvdm: lists are good for iteration, but not so good for arbitrary storage of just some stuff that you need to be able to look at randomly
14:10:20 <alar> 2bitsprite: sometimes one can rely on deforestation ability of compiler
14:10:40 <twobitsprite> alar: eh?
14:11:44 <twobitsprite> @what deforestation
14:11:45 <lambdabot> I know nothing about deforestation.
14:11:49 <alar> compiler can sometimes avoid creation of unnecessary data structures
14:11:49 <twobitsprite> @wiki deforestation
14:11:50 <lambdabot> http://www.haskell.org/haskellwiki/deforestation
14:12:07 <twobitsprite> @oldwiki deforestation
14:12:09 <lambdabot> http://www.haskell.org/hawiki/deforestation
14:12:38 <alar> e.g. when a tree is produced and is comsumed immediately after that
14:13:08 <alar> compiler can combine producer and consumer that there is no tree in final code
14:13:10 <ihope> alar: what do you mean by "consumed"?
14:13:18 <twobitsprite> alar: right well... I personally don't like to rely on "maybe my compiler will fix my design for me"
14:13:23 <ihope> Like composing a -> Tree and Tree -> b?
14:13:38 <alar> ihope: I mean "used and then garbage collected"
14:13:43 <basti_> or like in "map a (map b l)"?
14:14:13 <MarcWeber> What is wrong here: DBDirect: user error (loadShared: couldn't load `/usr/lib/libz.so' because /usr/lib/libz.so: invalid ELF header) ?
14:14:14 <ihope> Hmm, (map a . map b) sounds fun :-)
14:14:45 <alar> 2bitsprite: when I think I can't rely on this I program in a language with explicit control over program sequencing and memory allocation
14:14:47 <ihope> Maybe you need to rebuild libz.so?
14:14:56 <ihope> s/so/hs/, or something
14:16:03 <twobitsprite> alar: I'm just saying that if I need to store a bunch of "things" sequentially and know I'm going to need non-sequential access to these "things", I use something other than a list
14:17:25 <MarcWeber> ihope: No. Same error
14:17:56 <ihope> Well, I don't know ELF.
14:18:20 <twobitsprite> ELF is a linux binary executable format, correct?
14:18:24 <MarcWeber> lambdabot: do you know ELF ?
14:18:51 <MarcWeber> twobitsprite: not sure something really lowlevel binary executable thing on linux, yes
14:19:03 <ihope> @elf
14:19:03 <lambdabot> Maybe you meant: help pl
14:19:22 <twobitsprite> @google elf linux file format
14:19:24 <lambdabot> http://www.skyfree.org/linux/references/ELF_Format.pdf
14:19:55 <ihope> Executable and Linking Format
14:20:21 <ihope> @google Executable and Linking Format
14:20:23 <lambdabot> http://www.cs.ucdavis.edu/~haungs/paper/node10.html
14:21:59 <palomer> (there's also the elf logical framework)
14:23:17 <MarcWeber> I might try building everything with gcc from my distro and not with gcc shipping with ghc?
14:23:23 <MarcWeber> I'll compare those versions
14:23:25 <twobitsprite> palomer: I doubt that's what MarcWeber's error is about :P
14:24:18 <palomer> you never know!
14:25:13 <MarcWeber> I need to ask someone who knows what is happening . ;)
14:26:18 <ihope> Hmm, makemakemakemakemake.
14:28:39 <ihope> What happens if I try to link Haskell objectry to C objectry?
14:44:47 <palomer> busy busy busy
14:46:13 <SimonRC> If I manage to think of a very elegant datastructure for a problem containing, say, and infinite list of functions, and I then find I need to write it to disk, is there any way to do so?
14:46:59 <basti_> write an infinite data structure?
14:47:06 <SimonRC> Because (e.g.) there is no instance Show of functions, and you can't "summarise" an infinite list, even though it only contains a finite amount of information.
14:47:07 <astrolabe> You might be able to save the recipee for making the list I suppose.
14:47:12 <SimonRC> :-S
14:47:16 <basti_> you could write a haskell module maybe
14:48:09 <SimonRC> I thought there might be a way to write the internal data structures to disk, since they will be read in by the same program.
14:48:53 <basti_> that will be hard, because the "internal data strucutre" is a program
14:48:57 <basti_> haskell doesn't reflect, sadly
14:49:00 <musasabi> SimonRC: usually I just use something like "data Fun a = Fun a String" and then use the string for serializing/loading and the function for the work.
14:49:23 <basti_> you can, however, very probably just rebuild the same structure
14:49:55 <SimonRC> musasabi: but then application becomes ugly
14:51:18 <SimonRC> Slightly more irritating (because more subtle) is a large datastructure that is referred to from many places.  It writes out fine, but when read back in, it has grown enormously.
14:51:29 <basti_> :/
14:51:37 <SimonRC> This is one of those situations where the idea of identity would be handy.
14:51:52 <basti_> yes, I dearly miss identity and reflection in haskell
14:52:06 <SimonRC> GADTs help in some places.
14:52:34 <gFunk> @pl addBy f = map sum . groupBy f
14:52:36 <lambdabot> addBy = (map sum .) . groupBy
14:52:37 <SimonRC> EDSLs can have provisions for serialisation embedded, I suppose
14:53:13 <gFunk> @pl isSameDirection x y = abs (x+y) == abs x + abs y
14:53:13 <ihope> A few decks short of a card...
14:53:13 <lambdabot> isSameDirection = ap (ap . (((==) . abs) .) . (+)) ((. abs) . (+) . abs)
14:54:20 <SimonRC> In fact, anything that could be self-referential becomes really ugly once you need to serialise it.
14:54:48 <ihope> gFunk: compare signums?
14:55:06 <musasabi> SimonRC: SerTH can help partially there.
14:55:07 <ihope> > signum (-3) == signum (-2)
14:55:08 <lambdabot> True
14:55:10 <lisppaste2> davidhouse pasted "weird error" at http://paste.lisp.org/display/18010
14:55:11 <ihope> > signum (-3) == signum (4)
14:55:12 <lambdabot> False
14:55:17 <ihope> > signum (-3) == signum (0)
14:55:18 <lambdabot> False
14:55:23 <ihope> > signum (5) == signum (0)
14:55:25 <lambdabot> False
14:55:31 <gFunk> ihope: thanks!
14:55:46 <davidhouse> err, disregard that paste
14:58:45 <ihope> Hmm...
14:59:05 <musasabi> One can have dirty identity in Haskell.
14:59:25 <musasabi> the problem is that values of different types may be pointer identical to each other.
14:59:32 <ihope> !
14:59:32 <basti_> I'd be very happy with computer-intensional identity
14:59:40 <davidhouse> what are you refering to by "identity" here?
14:59:46 <basti_> musasabi: how?
14:59:48 <musasabi> which makes type safe caches hard.
14:59:54 <musasabi> basti_: e.g. [] and newtypes.
14:59:57 <ihope> musasabi: you mean that really unsafe pointer equality?
15:00:22 <musasabi> ihope: yes, that really unsafe one.
15:00:23 <basti_> i don't see how a memory address can hold two values
15:00:38 <ihope> basti_: what if the values are the same?
15:00:46 <basti_> then they're equal.
15:00:47 <ihope> musasabi: what's it called?
15:00:58 <basti_> which is the point of asking if they're equal.
15:00:59 <musasabi> basti_: multiple haskell values can be compiled down to a single machine value.
15:01:00 <basti_> i think.
15:01:05 <basti_> oh
15:01:11 <basti_> ok thats bad
15:01:20 <ihope> type Num a = (a -> a -> a, a -> a -> a, Either (a -> a -> a) (a -> a), a -> a, a -> a, Integer -> a)
15:01:25 <ihope> :-)
15:01:29 <basti_> but still, typechecked intensional identity would be ok
15:01:37 <ihope> 4 :: Num a -> a, etc...
15:01:41 <musasabi> ihope: System.Mem.StableName
15:01:48 <basti_> for example i recently had the problem of traversing a lazy graph
15:02:10 <ihope> musasabi: I thought there was something with a name like reallyUnsafePointerEquality.
15:02:16 <ihope> @index reallyUnsafePointerEquality
15:02:17 <lambdabot> bzzt
15:02:18 <basti_> i had to introduce an artificial identity
15:02:25 <basti_> (that is, comparing id's)
15:02:53 <ihope> Hmm, an abstract type that can hold anything at all...
15:03:00 <musasabi> ihope: that is unsafe enough to cause problems in practise.
15:03:15 <ihope> musasabi: but where is it?
15:03:22 <musasabi> where is what?
15:03:41 <ihope> reallyUnsafePointerEquality?
15:04:04 <musasabi> unsafeCource# ;)
15:04:12 <gFunk> @pl f x y = signum x == signum y
15:04:13 <lambdabot> f = (. signum) . (==) . signum
15:04:14 <ihope> :-)
15:04:32 <musasabi> One scenario which causes problems is like this:
15:04:44 <musasabi> newtype W a = W a
15:05:11 <musasabi> let x = "foobar"; y = W x in serialize x >> serialize y
15:05:16 <musasabi> Now we start decoding.
15:05:22 <ihope> What's serialize?
15:05:39 <musasabi> ihope: just some method that serializes and caches things.
15:06:00 <ihope> What's its type?
15:06:59 <basti_> a->String? 
15:07:00 <musasabi> 1) deserialize the string. This works nicely. 2) deserialize the "W String", now we hit the cache because x and y were pointer-equal. But we wanted to have a value of type "W String" and the cached value was of type "String" -> problem.
15:07:22 <musasabi> serialize :: Serialize t => t -> MySerializingMonad ()
15:07:34 <basti_> ah yes it would have to be monadic
15:07:35 <basti_> my bad
15:07:50 <basti_> or would it?
15:07:52 * basti_ ponders
15:08:06 <ihope> \x -> Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef x >> Data.IORef.readIORef ref
15:08:06 <lambdabot> compose module failed: Parse error: "->"
15:08:11 <musasabi> of course not. But making it a monad makes things easier.
15:08:12 <ihope> What's wrong with that?
15:08:12 <basti_> no it would not.
15:08:33 <araujo> Hello!
15:08:40 <basti_> ihope: parenthenses? ;)
15:08:49 <ihope> basti_: where?
15:08:57 <gFunk> Hi.  I was thinking the Quicksort in the Haskell Introduction is pretty gnarly.  
15:09:09 <ihope> @type \x -> Data.IORef.newIORef undefined >>= (\ref -> Data.IORef.writeIORef x >> Data.IORef.readIORef ref)
15:09:10 <lambdabot>   Couldn't match `(->) a' against `IO'
15:09:10 <lambdabot>   Expected type: a -> b
15:09:13 <gFunk> http://www.haskell.org/haskellwiki/Introduction
15:09:14 <ihope> @type \x -> Data.IORef.newIORef undefined >>= (\ref -> (Data.IORef.writeIORef x >> Data.IORef.readIORef ref))
15:09:14 <lambdabot>   Couldn't match `(->) a' against `IO'
15:09:14 <lambdabot>   Expected type: a -> b
15:09:40 <basti_> ihope: aroundhmmm
15:10:26 <basti_> ihope: did you forget a parameter of writeIORef?
15:10:39 <ihope> Aha.
15:10:47 <ihope> @type \x -> Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef ref x >> Data.IORef.readIORef ref
15:10:48 <gFunk> something like this might be more gentle for people that don't know the syntax:
15:10:48 <gFunk> http://pastebin.com/609836
15:10:48 <lambdabot> forall a.
15:10:48 <lambdabot>                                     a
15:10:48 <lambdabot>                                     -> IO a
15:11:01 <ihope> @type \x -> Data.IORef.newIORef undefined >>= \ref -> Data.IORef.writeIORef ref x >> Data.IORef.readIORef ref :: a -> IO b
15:11:02 <lambdabot>   Couldn't match `IO' against `(->) t'
15:11:02 <lambdabot>   Expected type: IO a
15:11:27 <basti_> uh?
15:13:38 <gFunk> think anyone would mind if i changed the Introduction wiki page?
15:13:59 <ihope> Let's unsafeCoerce# EVERYTHING!
15:14:10 * palomer concurs
15:14:46 <musasabi> well unsafePerformIO is enough.
15:15:35 <ihope> unsafeCoerce# - unsafePerformIO = still unsafe?
15:16:25 <musasabi> unsafePerformIO is the bigger hammer.
15:16:40 <musasabi> unsafeCource# is easier to abuse.
15:16:59 <ihope> unsafeCoerce# unsafeCoerce#
15:17:55 <musasabi> unsafeCoerce# can be implemented with polymorphic IORef + unsafePerformIO.
15:18:23 <ihope> How's the polymorphic IORef work?
15:20:36 <musasabi> {-# NOINLINE foo #-} foo = unsafePerformIO $ newIORef $ error "don't try this at home"
15:21:21 <ihope> What's NOINLINE?
15:21:39 <musasabi> unsafeCoerce x = unsafePerformIO $ do writeIORef foo x; readIORef x
15:21:47 <musasabi> unsafeCoerce x = unsafePerformIO $ do writeIORef foo x; readIORef foo
15:22:22 <musasabi> ihope: tells the compiler not to inline the definition.
15:22:44 <ihope> What's inlining?
15:24:12 <musasabi> ihope: the difference whether every usage of foo will get a fresh IORef or the same shared one.
15:24:58 <ihope> Ah. So is this the all the same or each different?
15:25:19 <musasabi> all the same.
15:25:39 <ihope> Hmm...
15:27:03 <musasabi> identity is a nasty concept.
15:27:09 <ihope> @type \x -> let ref = Data.IORef.newIORef undefined in ref >>= \ref -> writeIORef ref x >> readIORef ref
15:27:10 <lambdabot> Not in scope: `writeIORef'
15:27:10 <lambdabot>  
15:27:10 <lambdabot> <interactive>:1:85: Not in scope: `readIORef'
15:27:22 <ihope> @type \x -> let ref = Data.IORef.newIORef undefined in ref >>= \ref -> Data.IORef.writeIORef ref x >> Data.IORef.readIORef ref
15:27:23 <lambdabot> forall a.
15:27:23 <lambdabot>                                           a
15:27:23 <lambdabot>                                           -> IO a
15:27:35 <ihope> Heh...
15:27:59 <ihope> @type \x -> let ref = Data.IORef.newIORef undefined in ref >>= \ref -> Data.IORef.writeIORef ref x >> Data.IORef.readIORef ref :: a -> IO b
15:28:00 <lambdabot>   Couldn't match `IO' against `(->) t'
15:28:00 <lambdabot>   Expected type: IO a
15:28:04 * wolverian runs his hands over the whitespace, to find hidden characters
15:28:31 <musasabi> ihope: that won't work.
15:29:32 <ihope> Why not?
15:30:16 <musasabi> a and b won't match thus you won't get the polymorphism needed for unsafeCoerce#
15:31:25 <ihope> Are you saying I need unsafePerformIO?
15:32:21 <musasabi> yes.
15:32:45 <ihope> Scary.
15:33:02 <musasabi> and dirty
15:34:45 <ihope> So unsafeCoerce# - unsafePerformIO = return
15:36:05 <ihope> By the way, is there any function with a more misleading name?
15:37:38 <musasabi> hmm, the names are quite descriptive I think.
15:39:51 <ihope> @type (3,,)
15:39:52 <lambdabot> parse error on input `,'
15:40:00 <ihope> (1,,5,2,,8,,2,47,,5,,2,)
15:40:17 <ihope> What type does that have? :-P
15:40:17 <davidmccabe> http://www.lambdassociates.org/qilisp.htm
15:40:28 <palomer> why doesn't (3,) parse?
15:40:31 <davidmccabe> this appears to be a dialect of lisp with a bunch of haskell-style features.
15:40:37 <palomer> @type (3,)
15:40:38 <lambdabot> parse error on input `)'
15:40:47 <Korollary> because of the close-paren I think
15:40:52 <Korollary> @type (,) 3
15:40:53 <lambdabot> forall a b. (Num a) => b -> (a, b)
15:41:59 <ihope> Sorty annoying.
15:42:54 <Korollary> sorta picky arent we
15:46:12 <ihope> > (3 :: Integer) + (4 :: Float)
15:46:13 <lambdabot> Couldn't match `Integer' against `Float'
15:46:14 <palomer> sorty?
15:46:36 <ihope> Yes. Now we hyve to tylk like this.
15:46:56 <ihope> Don't get cyught using YLFY!
15:52:38 <drakioned> @hoogle ST () a -> a
15:52:39 <lambdabot> Control.Monad.ST.Lazy.runST :: ST s a -> a
15:52:39 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
15:52:53 <drakioned> hmm
15:54:14 * drakioned confuzzled
15:58:32 <drakioned> anyone here?
15:58:57 <ndm> drakioned: yes, what are you confuzzled about
15:59:48 <drakioned> would foreach work in something of type ST?
16:00:03 <ndm> foreach?
16:00:18 <ndm> you mean the C# programing construct?
16:00:19 <drakioned> flip mapM_
16:01:30 <SimonRC> drakioned: yeah, I think so.
16:02:40 <drakioned> I defined a STRef, and used a foreach to change it, and can't figure out how to extract values from the function
16:03:37 <drakioned> I get something of type ST () a at the end of it.
16:07:53 <drakioned> am I doing something really daft?
16:11:05 <SimonRC> you want mapM, not mapm_
16:11:21 <SimonRC> the _ functions all return something based around ()
16:12:15 <SimonRC> or you could create a STRef outside of the "loop" and store the value in that somehow
16:15:52 <drakioned> umm, I did create it outside the loop
16:18:36 <ihope> Would the numbers 1, 3, 7 and 9 be called prime modulo 10?
16:19:40 <palomer> 9 is certainly not prime
16:19:44 <palomer> since it's not prime in Z
16:19:54 <palomer> 7 = 3 * 9
16:20:11 <palomer> 3 is prime, though
16:20:18 <palomer> and 1 isn't
16:22:05 * ptolomy stares at the hypnotic spurts of text output from jhc's compilation of base libraries.
16:27:02 <davidmccabe> http://haskell.org/graphics/index.html
16:27:06 <davidmccabe> I notice there are no links to documentation there.
16:27:17 <davidmccabe> At all.
16:28:40 <ihope> Oh, right. They're coprime to 10.
16:36:34 <ihope> @index coprime
16:36:35 <lambdabot> bzzt
16:49:58 <machack666> is there a way of making extensible records in haskell without resorting to nesting data structures (or, if we must do that, hiding the nesting automatically)?
16:51:15 <musasabi> HList
16:54:53 <machack666> ie, data Type1 = MkType1 { field1 :: SomeType, field2 :: SomeType2 }; data Type2 = MkType2 { field3 :: SomeType, field4 :: SomeType }
16:57:07 <ihope> What do you mean by extensible?
16:57:17 <machack666> data Type3 = (...composite of Type1 and Type2, with single-level accessors..., akin to MkType3 { field1 :: SomeType, field2 :: SomeType2, field3 :: SomeType3, field4 :: SomeType4 }
16:57:52 <musasabi> The HList paper has a summary of the various approaches in the start before introducing their own solution.
16:58:07 <machack666> is HList just on the wiki?
16:59:01 <machack666> got it... thanks for the pointer
17:10:29 <twobitsprite> is an signifigant reason I should try to write my functions in points-free style?
17:10:39 <twobitsprite> it just doesn't seem very readable to me
17:13:27 <ptolomy> One argument is that it encourages you to think about your code in a more functional manner.
17:14:30 <twobitsprite> ptolomy: is that always a good thing?
17:14:46 <ptolomy> Well, in my little worldview, nothing is _always_ a good thing.
17:14:58 <twobitsprite> ptolomy: that's kind of how I feel about it
17:15:03 <ptolomy> but in a purely functional language, thinking about things in terms of functions is generally a good thing.
17:15:32 <ptolomy> Personally, I go with the "points free where reasonable" strategy.
17:16:20 <twobitsprite> ptolomy: right... because some sutuations just call for many flips and other "function rewriting" functions towhere it's impossible to follow the flow of things...
17:24:10 <araujo> openFile: resource busy (file is locked)
17:24:28 <araujo> why do i keep getting that msg when i try to write to an existing file?
17:25:15 <ihope> Hmm... try opening it in write mode.
17:29:02 <musasabi> twobitsprite: use the one that is most readable for you.
17:34:14 <araujo> mm...
17:34:23 <araujo> ihope, writeFile shund't take care of it?
17:34:35 <araujo> shoudn't*
17:34:56 <ihope> Well, I don't know much about reading from/writing to files.
17:35:24 <Korollary> that error message looks like the problem is not with how you're trying to access it, but more like something else is accessing it, too.
17:36:19 <araujo> Korollary, interesting.. i also have that impression.... well, i only calling readFile before doing the writting....
17:36:24 <araujo> might that be the issue?
17:38:56 <musasabi> araujo: that is an issue.
17:39:15 <araujo> musasabi, ok, even using read/writeFile?
17:39:27 <araujo> i thought these functions would take care of this automatically...
17:39:33 <araujo> i might probably should go with handles....
17:39:36 <musasabi> araujo: http://groups.google.com/group/fa.haskell/browse_frm/thread/dee79699efa59bf3/db05d09f271668a3?lnk=st&q=openUnlocked+einar+karttunen&rnum=1#db05d09f271668a3
17:40:59 <dons> mm. the example from Manuel on the comparing functional dependency-style peano numbers with a proposed type-level functions and kind decls form is very nice
17:41:56 <araujo> i see, thanks musasabi 
17:43:35 <musasabi> that code is not good in the start of the thread, but the thread has the relevant stuff.
17:44:34 <dons> Cale, don't you think this is nice: http://www.haskell.org/pipermail/haskell-prime/2006-March/000960.html
17:44:34 <musasabi> In the end I used System.Posix.openFd + GHC.openFd
17:44:51 * ihope laughs
17:45:04 <ihope> Since when does Haskell use ket notation?
17:45:14 <dons> ket ?
17:45:35 <dons> type level functions, and kind decls. mmmm tasty!
17:45:36 <dons>   kind Nat = Z | S Nat
17:45:36 <dons>   type Add Z     (b :: Nat) = b
17:45:37 <dons>        Add (S a) (b :: Nat) = S (Add a b)
17:45:43 <dons> who needs dependent types, eh?
17:45:57 <ihope> dons: bra and ket.
17:49:40 <ihope> Hmm, complex numbers... sine waves...
17:50:54 <musasabi> dons: why not simply make types values?
17:51:05 <dons> 'simply' ?
17:51:29 <dons> the above is some stuff happening now at ghc HQ
17:51:59 <ihope> Complex plane -> polar coordinates -> (circle -> sine wave)!
17:52:34 <dons> musasabi, coming out of the associated types work. so hopefully we'll see this type level function stuff in ghc soon
17:52:39 <dons> and kind decls are long awaited
17:52:55 <musasabi> dons: One can either make type-level functions separate from normal functions or the same. It is debated which is the better way to do things.
17:53:14 <musasabi> dons: btw how do I get the names of everyone on a channel?
17:53:14 <dons> ah, i think the idea is to be able to use, say, 'reverse' on both levels
17:53:16 <musasabi> in lambdabot.
17:53:31 <dons> so functions can be lifted to the type level
17:53:35 <dons> (is that what you meant)
17:53:41 <dons> in lambdabot . hmm
17:53:47 <dons> let me check the code
17:54:24 <dons> ah, we have a function, IRC.names ?
17:54:43 <dons> -- | 'names' builds a NAMES message from a list of channels.
17:54:43 <dons> names :: [String] -> Message
17:54:46 <musasabi> if functions can be lifted from value to type level, why not data declarations?
17:54:47 <dons> in IRC.hs
17:55:20 <musasabi> dons: yes, that is easy, the part of receiving the answers is the hard part.
17:55:25 <dons> i don't know of any language that lets you automatically lift data decls
17:55:33 <dons> and presumably, get type decls for freeE?
17:55:51 <dons> I mean, it sort of makes sense -- in theorem provers you often have Int on the type level, and Nat again on the kind level
17:56:44 <dons> ah, receiving the answers.
17:57:12 <dons> so the part in Seen.hs that says:
17:57:13 <dons>       -- This magically causes the 353 callback to be invoked :)
17:57:14 <dons>       tryError $ send . IRC.names =<< ircGetChannels
17:57:19 <dons> is the tricky bit?
17:57:42 <dons> so first you need to register a call back, by the  looks of it
17:57:46 <musasabi> dons: most of the examples I have encountered end up defining an identical kind and a datatype. (e.g. the HW paper)
17:58:07 <musasabi> doesn't that break things if something else is doing /names ?
17:58:11 <araujo> @hoogle evaluate
17:58:11 <lambdabot> Control.Exception.evaluate :: a -> IO a
17:58:11 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
17:58:21 <dons> ah, you think we  only have 1 call back?
17:59:00 <dons> hmm. I wish ircSignalConnect was documented
17:59:59 <musasabi> mmh, I can read that code. Just seems like there could be a functionality for "send a command and get the results back".
18:00:38 <dons> yes. that wraps up these callbacks
18:00:54 <araujo> musasabi, yeah, it is that i need to use handles manually
18:00:58 <dons> hmm. perhaps we should add names to the system plugin
18:01:09 <dons> then other plugins can call into it
18:01:13 <dons> to get names listts
18:02:36 <ihope> How many prime knots are there?
18:02:44 <musasabi> dons: or just keep that info somewhere in common, as Seen already tracks what users are present on which channels.
18:03:04 <dons> ah. it should be in the global state then.
18:03:16 <dons> and just let seen do the updating
18:04:36 <dons> this system for dealing with channel state should be cleaned up a bit, to make more things available
18:04:44 <dons> we are getting more and more plugins that need this kind of info.
18:07:12 <dons> possibly you could patch Seen.hs , adding a `names' hook to call. (you'd do this by adding a 'names' command to Seen.hs, and then calling it from your module. Inter-module calls are dealt with in Compose.hs)
18:07:27 <ihope> > let x ^^ y = foldr (^) 1 (replicate y x); x ^^^ y = foldr (^^) 1 (replicate y x); x ^^^^ y = foldr (^^^) 1 (replicate y x) in 3^^^^3
18:07:28 <lambdabot> Exception: stack overflow
18:08:38 <dons> musasabi, what kind of plugin are you writing?
18:08:55 <dons> also, if you submit code every couple of days , i'm likely to start hacking on it too...
18:28:05 * twobitsprite has just experienced maybe-monad enlightenment
18:28:39 <twobitsprite> > Just 4 >>= (\ x -> if x == 0 then fail "zero" else Just (x + 1))
18:28:40 <lambdabot> Just 5
18:28:44 <twobitsprite> > Just 0 >>= (\ x -> if x == 0 then fail "zero" else Just (x + 1))
18:28:45 <lambdabot> Nothing
18:28:56 <twobitsprite> that should be in a monad tutorial
18:29:31 <ihope> > Nothing >>= (\ x -> if x == 0 then fail "zero" else Just (x + 1)) -- This too
18:29:31 <lambdabot> Nothing
18:29:40 <twobitsprite> ihope: right
18:29:49 <Korollary> You could put things you like on the wiki
18:29:53 <twobitsprite> I feel like I'm having a "why did you just say so" moment...
18:30:08 <twobitsprite> Korollary: where on the wiki would be a good place to put that?
18:30:19 <twobitsprite> s/did/didn't
18:31:24 <ihope> @quote Oleg
18:31:25 <lambdabot>  The implementation of RSA on type level is left for future work
18:31:26 <ihope> :-D
18:31:32 <Korollary> somewhere on http://haskell.org/hawiki/HaskellNewbie  maybe
18:33:26 <twobitsprite> that page is immutable
18:33:56 <ndm> thats the old wiki
18:33:57 <ndm> @wiki
18:33:58 <lambdabot> http://www.haskell.org/haskellwiki/
18:34:03 <ndm> use the new wiki instead
18:34:13 <ndm> and you have to be logged in, or they appear immutable
18:45:58 <twobitsprite> http://haskell.org/haskellwiki/Simple_Monad_Examples
18:46:25 <twobitsprite> there we go, I started a monad examples page... maybe you all can think of some other/better examples...
18:47:29 <twobitsprite> is there a naming convention for functions that are meant to be used monadicly? I.e. should I prefix my functions as "maybeSomething"?
18:47:42 <Korollary> not really
18:49:32 <gFunk> @pl f x = uncurry (==) . map2 signum x
18:49:33 <lambdabot> f = (uncurry (==) .) . map2 signum
18:57:31 <gregarican> hello. I'm new to Haskell and have some experience in Ruby, Smalltalk, and Python. does Haskell have current implementations for PDA's like Palm OS, Windows Mobile, and ARM Linux?
19:00:21 <eivuokko> Not really, I think.
19:02:19 <ndm> gregarican: there was a port of nhc at some point
19:02:27 <ndm> and i know two people have started ports of Yhc
19:02:44 <ndm> so answer is not yet, but should be possible without a massive amount of effort
19:03:05 <ndm> Yhc may build on Windows Mobile, and should on ARM Linux
19:03:18 <gregarican> ndm: thanks for the info!
19:03:20 <ndm> its just no one owns these devices
19:03:25 <twobitsprite> @pl (\ p b e -> (p > b) && (p < e) )
19:03:26 <lambdabot> ap (flip . (((.) . (&&)) .) . (>)) (<)
19:03:29 <twobitsprite> ick
19:04:24 <twobitsprite> gregarican: ghc will compile to portable C code though, IIRC
19:05:24 <gregarican> thanks. i guess i'm looking for a utopian solution. a high level scripting language that will be portable to palm os, windows mobile, arm linux, etc.
19:06:01 <twobitsprite> gregarican: python doesn't run on those?
19:06:01 <dons> hugs runs on those systems, iirc
19:06:12 <twobitsprite> dons: oh?
19:06:24 <dons> and nhc at some point ran on both palm os and arm linux
19:06:44 <dons> at some point in the lat 4 years
19:07:09 <gregarican> twobitsprite: python on the palm is rather old (pippy based on python 1.5.2). it has windows mobile and arm linux covered though
19:07:12 <twobitsprite> is there something simpler than "getX (MyCons _ x _) = x" ?
19:07:25 <dons> no, don't think so twobitsprite
19:07:27 <Korollary> twobitsprite: use labelled fields
19:07:34 <dons> ah well, records, yes
19:07:43 <twobitsprite> I might do that
19:07:45 <twobitsprite> thanks
19:07:46 <dons> getX c = x c
19:07:59 <dons> and then, getX = c
19:08:04 <dons> sorry, getX = x
19:08:30 <dons> and then you avoid the need for getX altogether :)
19:27:06 <palomer> man, I have so much love to give today
19:27:33 <Korollary> I take paypal
19:27:55 <stepcut> hrm, debian does not seem to have a command-line base64 encoder/decoder
19:31:06 * palomer gives stepcut some love
19:39:53 <stepcut> # apt-cache search love | wc
19:39:53 <stepcut>      45     357    2601
19:39:54 <lambdabot>  parse error on input `|'
19:45:02 <stepcut> http://video.google.com/videoplay?docid=4776181634656145640
19:45:10 <palomer> well, I managed to find a programming language which has error messages which are even less intuitive than ghc's
19:46:06 <stepcut> clean?
19:48:16 <dons> twelf?
19:48:22 <dons> twelf is really hard
19:48:47 <stepcut> perl?
19:49:02 <stepcut> oh wait, I know what it is: ghostscript
19:49:03 <araujo> hello there
19:49:08 * araujo gets some yogurt
19:49:16 <Korollary> perl doesn't have error messages. Doesn't everything run pretty much? ;)
19:49:31 <dons> tex? most errors just hit the end of the file and say you're missing a }
19:49:31 <palomer> twelf
19:49:37 <palomer> dons: you used twelf, right?
19:49:47 <dons> yep
19:49:49 <dons> i wrote a compiler that used twelf ass the typechecker
19:49:56 <palomer> ok, I want to prove type preservation
19:50:06 <palomer> so I'm populating tps : eval E V  -> of E T -> of V T -> type.
19:50:17 <palomer> how the heck does this prove type preservation?
19:51:05 <dons> hmm. my twelf is a bit rusty.. but this sounds like a general question on what is meant by type preservation, right?
19:51:33 <dons> i.e. that no eval step will break type safety, and lead to an ill-typed expr (that's it, right?)
19:51:45 <palomer> yeah
19:51:50 <palomer> eval is small step
19:51:55 <palomer> of: exp -> tp -> type
19:52:02 <palomer> eval: exp -> exp -> type.
19:52:11 <twobitsprite> hmm.. @pl doesn't like constructors...
19:52:24 <dons> ok, so then you proceed by induction on the eval rules, yeah?
19:52:40 <dons> twobitsprite, hmm. possibly.
19:52:46 <palomer> dons: yeah
19:53:00 <palomer> something of the sort     tps_ifs : tps (e_ifs P) (of_if A B C) A.
19:53:26 <palomer> however, just looking at the kind of tps, I don't see how populating it proves type preservation
19:54:13 <dons> well, I can't work it ouy without reading the full set of rules. but are you following one of the type preservation examples distributed with twelf? 
19:54:27 <dons> i think there's on for minML
19:54:31 <palomer> yeah, there is 
19:54:36 <palomer> I mean, I can write it
19:54:37 <palomer> out
19:54:38 <palomer> and extend it
19:54:42 <palomer> but I don't know what the heck I'm doing
19:54:49 <dons> ah. ok.
19:54:55 <palomer> I actually did write it out
19:55:31 <palomer> elements of (tps X Y Z) give us a proof of an instance of type preservation and nothing more
19:55:45 <palomer> like, how do you turn this into a type preservation proof?
19:55:49 <twobitsprite> > (not . isAlpha) 'a'
19:55:50 <lambdabot> False
19:56:03 <palomer> forall {x} {y} exists {z} {u:tps x y z} true ?
19:56:22 <dons> ah, sounds right.
19:56:58 <twobitsprite> f . g x == f(g(x)) -- right?
19:57:19 <twobitsprite> isn't that at least the mathematical definition of composition?
19:57:29 <palomer> dons: you wouldn't know how to ask twelf to prove that, would you?
19:57:45 <dons> (.)       :: (b -> c) -> (a -> b) -> a -> c
19:57:47 <dons> (.) f g x = f (g x)
19:58:24 <twobitsprite> er... sorry, I got my question backwords... I thought the mathematical definition "swapped" that...
19:58:31 <dons> palomer, hmm. my twelf is definitely too rusty to do thiis atm. sorry.
20:00:19 <twobitsprite> nevermind... I'm a crackhead
20:00:23 <palomer> np
20:02:21 <MarcWeber> Hi dons ! Good morning..  I have a Typeable.h header in my ghc distribution.. I don't mind. I now get DBDirect: user error (loadShared: couldn't load `/usr/lib/libz.so' because /usr/lib/libz.so: invalid ELF header). Do you know how to fix this?
20:10:19 <dons> that's a weird one. why are you trying to load a .so file? Does that even work?
20:10:23 <dons> hmm
20:11:01 <MarcWeber> dons: I don't know I've tried compiling DBDirect and running that application.. I'm not sure what it does (yet..)..
20:11:11 <dons> from memory, you need to statically link your app against libz
20:11:14 <dons> ie. compile it with -lz
20:11:41 <dons> I'm not 100% sure that loading a .so file like that will work. 
20:11:49 <dons> but I know if you statically link libz, it should be ok
20:12:16 <dons> (i do this in yi)
20:14:45 <MarcWeber> dons: So ghc -lz (...) DBConnect.hs?
20:14:50 <MarcWeber> Doens't work. Same error
20:16:58 <dons> who wrote this DBConnect.hs code?
20:17:14 <dons> perhaps you should ask them how they got it to work in the first place?
20:19:31 <MarcWeber> I probably should
20:21:35 <MarcWeber> dons: So it's not ghc-6.5 related ;) thx.
20:21:45 <dons> well, i don't think it is.
20:32:26 <twobitsprite> do record types in Haskell have a syntax like the Ocaml "with", i.e. in ocaml {myRecord with x = 4} => copy of myRecord with the value names "x" changed to 4...
20:35:04 <twobitsprite> ahh, n/m... I must have skimmed right over that part...
20:57:38 <palomer> higher order syntax hurts my brain
20:57:44 <palomer> especially with twelf
20:59:08 <twobitsprite> when I import Data.Map (Map) it seems to implicitly import Data.Map.! ... why?
21:01:50 <twobitsprite> er, I guess its when I "import Data.Map as Map"
21:03:31 <palomer> the twelf parser is terrible>:O
21:13:14 <dons> terrible? how ?
21:13:26 <dons> or do you mean, the syntax of twelf is weird
21:23:23 <stepcut> twobitsprite: you might want, import qualified Data.Map as Map
22:00:57 <twobitsprite> stepcut: that did the trick, thanks
22:51:13 <Saulzar> Hmm, seems using something like Vector !Double !Double can be up to 10 times faster than (Double, Double), and I've been using the latter
22:54:03 <Korollary> I remember seeing that on the wiki in the shootout entries.
22:54:08 <Saulzar> I saw Boegels article which used the later and thought it looked nice, now I have some massive refactoring to do :)
22:56:36 <ibid> well, the former is strict in the doubles, the latter is not, it's easy to see a potential performance problem there
22:57:33 <Saulzar> Right, just didn't expect it to be quite as drastic, some small tests show it is
22:57:42 <Korollary> shouldn't primitives like doubles be easily made strict by ghc?
22:58:07 <ibid> depends on how they're used
22:58:11 <Saulzar> You can lazily evaluate them like anything else...
22:58:22 <ibid> it's not about primitiveness, it's about usage
22:58:30 <Saulzar> hmm
22:58:39 <ibid> whether the strictness analysis spots it or not
23:30:19 <dancor> what's the deal with regex in haskell.  there are different libraries?
23:31:31 <Korollary> It's not part of the standard anyway. I read somewhere that someone was working on an alternative to the one provided by ghc.
23:35:23 <dancor> what's wrong with the standard one
23:36:16 <Korollary> nothing really. It's based on some C library, which happens to be slower than perl's iirc. So people wanted to rectify that.
23:36:51 <dancor> i guess perl is the regex library to beat
23:37:21 <Korollary> possibly. regex matters a lot in perl.
23:37:54 <Korollary> I think Tcl had a very fast one as well
23:37:57 <sieni> no, cl-ppcre: http://www.weitz.de/cl-ppcre/
23:40:27 <Korollary> yay, a pissing contest :)
23:42:05 <sieni> please tell us more
23:42:19 <araujo> @pl f msg out = hGetContents out >>= p . (msg ++)
23:42:20 <lambdabot> f = flip ((>>=) . hGetContents) . (p .) . (++)
23:42:39 * araujo loves lambdabot 
