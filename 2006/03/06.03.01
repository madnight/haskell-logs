00:00:06 <jethr0> mathrick: np. in my example above you can see how the zipWith version works
00:00:20 <vincenz> 4587  -> 44087
00:01:01 <jethr0> it does the "fib (n-1) + fib (n-2)" over a whole list, and because this list is getting longer each time, it never stops :)
00:01:27 <mathrick> jethr0: so why didn't vincenz's version go into infinite loop?
00:01:40 <vincenz> mathrick: it didn't
00:01:50 <vincenz> mathrick: think about it... how would lambdabot know an infinite loop
00:01:57 <vincenz> it'd have to compute forever
00:01:57 <mathrick> vincenz: that's what I said
00:02:00 <jethr0> mathrick: i don't know what's wrong with "drop" either
00:02:01 <xerox> > let a = a in a
00:02:02 <lambdabot> Add a type signature
00:02:04 <mathrick> it didn't
00:02:06 <xerox> > let a = a in a :: ()
00:02:07 <lambdabot> Terminated
00:02:08 <vincenz> mathrick: it just stops calculating after some seconds
00:02:10 <xerox> Hmm.
00:02:21 <mathrick> eh?
00:02:22 <xerox> I think she knows about loops.
00:02:36 <mathrick> > let fib = 1:1:(zipWith (+) fib (tail fib)) in drop 10000 fib
00:02:42 <lambdabot> [54438373113565281338734260993750380135389184554695967026247715841208582865
00:02:43 <lambdabot> 622349017083051547938960541173822675978026317384359584751116241439174702642
00:02:45 <lambdabot> 959169925586334117906063048089793531476108466259072759367899150677960088306
00:02:46 <jethr0> vincenz: i think the question is why "drop" is producing single elements and not the list 1001..
00:02:47 <lambdabot> 597966641965824937721800381441158841042480997984696487375337180028163763317
00:02:49 <lambdabot> 781927941101369262750979509800713596718023814710669912644214775254478587674
00:02:51 <lambdabot> [23 @more lines]
00:02:55 <mathrick> jethr0: yes
00:03:14 <jethr0> but, i think in those 23 more lines is the rest, and it evaluates only up to some point
00:03:21 <jethr0> iterate (*2) 1
00:03:25 <jethr0> > iterate (*2) 1
00:03:26 <lambdabot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,
00:03:26 <lambdabot> 131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,
00:03:26 <lambdabot> 67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,
00:03:26 <lambdabot> 8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,
00:03:26 <lambdabot> 549755813888,1099511627776,2199023255552,4398046511104,8796093022208,
00:03:28 <lambdabot> [24 @more lines]
00:03:29 <vincenz> jethr0: the element was so long that it only displayed that much
00:03:33 * jethr0 wasn't thinking straight
00:03:39 <vincenz> jethr0: it started with a [
00:03:48 <vincenz> This isi odd
00:03:51 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in let dofunc x = primes !! x in iterate dofunc 1
00:03:52 <jethr0> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p> 0] in take 1 $ drop 2500 primes
00:03:55 <lambdabot> Terminated
00:03:56 <lambdabot> [22343]
00:03:58 <vincenz> mine terminates
00:03:59 <vincenz> for no reason
00:04:01 <jethr0> this is weird though
00:04:05 <mathrick> it is
00:04:10 <mathrick> it should never terminate
00:04:17 <vincenz> it terminated for my code!!!
00:04:20 <mathrick> and certainly not as fast as it did
00:04:29 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in let dofunc x = primes !! x in iterate dofunc 1
00:04:32 <jethr0> mathrick: don't forget it's lazy lists :)
00:04:33 <lambdabot> Terminated
00:04:44 <vincenz> why doesn't that give me ANY output?
00:05:17 <xerox> vincenz: simply said.
00:05:24 <vincenz> it should give me 
00:05:25 <xerox> You're not returning a list, you're returning an element.
00:05:26 <earthy> because it generates an infinite list
00:05:32 <vincenz> [3,3rd prime, ..]
00:05:34 <vincenz> no
00:05:37 <vincenz> > iterate (+1) 1
00:05:38 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
00:05:38 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
00:05:38 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
00:05:38 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
00:05:38 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
00:05:40 <lambdabot> [24 @more lines]
00:05:41 <vincenz> gives a list
00:05:41 <earthy> xerox: he's returning a list
00:05:46 <jethr0> mathrick: when you don't have a timeout (as in here), you can still print the first n elements of a lazy list, even if it is infinite
00:05:50 <xerox> I missed iterate, sorry.
00:05:56 <mathrick> jethr0: I know
00:06:08 <jethr0> printing an infinite list will just take infinitely long, but still print one element at a time
00:06:09 <mathrick> jethr0: but I ran it on my hugs, and it doesn't terminat
00:06:10 <earthy> unfortunately, the list explodes. this is lazyness biting vincenz in the ass
00:06:16 <mathrick> so I understood it correctly :)
00:06:20 <vincenz> earthy: it shouldn't for the first few elements
00:06:34 <vincenz> I mean come on
00:06:40 <earthy> ah, but it won't print until it has generated a number of elements, right?
00:06:42 <vincenz> I can generate up to the 4587th prime
00:06:43 <mathrick> btw, emacs doesn't like lines 300k chars long :)
00:06:44 <xerox> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in let dofunc x = primes !! x in iterate (dofunc $!) 1
00:06:48 <jethr0> mathrick: yes, hugs and ghci and lambdabot all handle these implementation specific things a little differently
00:06:48 <lambdabot> Terminated
00:06:49 <vincenz> earthy: ah good point
00:06:58 <earthy> lambdabot needs to generate a bunch of 'm
00:07:06 <mathrick> correction, it hit 900k
00:07:12 <vincenz> > let primes = sieve [2..] where sieve (p:x) = p : sieve [n | n <- x, n `mod` p > 0] in let dofunc x = primes !! x in take 8 $ iterate dofunc 1
00:07:13 <lambdabot> [1,3,7,19,71,359,2423,21589]
00:07:20 <jethr0> btw, we should really only check divisors up to "sqrt n"
00:07:20 <vincenz> that last one bit the printing
00:07:30 <mathrick> jethr0: I don't think infitiy being infinite is very implementation-specific
00:07:53 <earthy> I think lambdabot uses too much mem already before the code has generated enough primes for lambdabot to start printing
00:08:00 <jethr0> mathrick: :), no i meant when/if to to timeout, how much max stack is available, ...
00:08:02 <vincenz> nope
00:08:03 <vincenz> it works
00:08:07 <vincenz> earthy: it's not hte mem
00:08:15 <vincenz> earthy: it's the computation for finding the 21589th prime
00:08:21 <vincenz> it can only go up to the 4587th prime
00:08:24 <earthy> hm. right.
00:08:42 <vincenz>  lambdabot> [1,3,7,19,71,359,2423,21589]
00:08:44 <earthy> 'duh'. ;)
00:08:52 * earthy didn't fully read the code. ;)
00:09:08 <vincenz> that's a dangerous thing
00:09:28 <vincenz> the one for 0 is
00:09:35 <vincenz> [0,2,5,13,43,193,1181,9547]
00:09:45 <jethr0> > let primes3 = 2 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [3..] in primes!!5000
00:09:46 <lambdabot>  Not in scope: `primes'
00:09:49 <jethr0> > let primes3 = 2 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [3..] in primes3!!5000
00:09:50 <lambdabot> 48619
00:10:07 <vincenz> it's more efficient!
00:10:25 <vincenz> \o/
00:11:24 <jethr0> > take 20 $ unfoldr sieve [2..] where sieve (p:ps) = Just(p, [i | i <- ps, i `mod` p /= 0])
00:11:25 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
00:11:29 <ihope> > let primes3 = 3 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [5..] in take 10 primes
00:11:30 <lambdabot>  Not in scope: `primes'
00:11:34 <ihope> > let primes3 = 3 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [5..] in take 10 primes3
00:11:35 <lambdabot> [3,5,6,7,8,10,11,13,14,16]
00:11:58 * vincenz peers
00:12:04 <ihope> Hmm, how come 16's prime if 8's prime?
00:12:09 <ihope> > let primes3 = 3 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [4..] in take 10 primes3
00:12:10 <lambdabot> [3,4,5,6,7,8,10,11,13,14]
00:12:19 <jethr0> that seems pretty broken
00:12:21 <ihope> > let primes3 = 3 : filter (\x -> all ((/=0) . (mod x)) (takeWhile (\y -> (y*y) <= x) primes3)) [4..] in take 50 primes3
00:12:22 <lambdabot> [3,4,5,6,7,8,10,11,13,14,17,19,22,23,26,29,31,34,37,38,41,43,46,47,53,58,
00:12:22 <lambdabot> 59,61,62,67,71,73,74,79,82,83,86,89,94,97,101,103,106,107,109,113,118,122,
00:12:22 <lambdabot> 127,131]
00:12:34 <vincenz> ihope: easy 
00:12:35 <jethr0> and it was pasted from the wiki :(
00:12:40 <vincenz> ihope: it onl checks until the sqrt of the number
00:12:58 <jethr0> but there is a non-broken version using filter somewhere
00:13:05 <vincenz> either wa
00:13:10 <vincenz> sieving isn't the optimal way
00:13:21 <vincenz> the best way is to tick off by doing all the numbers < sqrt
00:13:23 <vincenz> not just the primes
00:13:30 <vincenz> cause you can easily parallelize that 
00:13:30 <ihope> Um...
00:13:47 <jethr0> vincenz: that's what this does
00:13:58 <vincenz> oh yeah
00:13:59 <ihope> Isn't this stuff implementation-specific?
00:14:00 <jethr0> at least it should. ticking of all multiples of primes
00:14:20 <vincenz> jethr0: nono
00:14:30 <vincenz> jethr0: more efficient is ticking of all multiples of all numbrs < sqrt
00:14:31 <vincenz> not just the primes
00:14:39 <vincenz> it's parallezable
00:14:42 <vincenz> erm
00:14:46 <vincenz> it's parallizable
00:14:52 <vincenz> damn I can't type
00:14:55 * vincenz goes for coffee
00:14:58 <ihope> Parallelizable, I'm guessing.
00:14:59 <vincenz> parallellizable
00:15:11 <vincenz> I haven't had my coffee yet
00:15:48 <tromp_> a real sieve doesn't use the mod operation though:)
00:16:00 <jethr0> k
00:16:08 <vincenz> tromp_: no, just increment, tick off
00:16:24 <mathrick> parallelisable
00:16:26 <vincenz> for number 2: x+=2  primes[x] = False
00:16:31 <tromp_> like the monstrosity on my homepage
00:16:36 <vincenz> tromp_: link?
00:17:06 <tromp_> http://www.cwi.nl/~tromp/pearls.html#sieve
00:17:09 <vincenz> I once found 8M primes with a very simple program I had written, and this was before I knew how to use malloc, so I was bound by stack-page size!
00:17:22 <vincenz> err... all primes < 8M
00:17:55 <vincenz> tromp_: that -is- ugly
00:18:06 <jmicheal> anyone have good examples when to use >>= ? looking at its type doesnt help me alot :(
00:18:06 <vincenz> tromp_: you wrote that by hand?
00:18:14 <earthy> small world inc. 'Freek Wiedijk'. :)
00:18:21 <tromp_> yep, 'fraid so
00:18:33 <vincenz> tromp_: all your code on that page could be sent to some obfuscating contest
00:18:40 <tromp_> some of it was
00:18:47 <vincenz> even the hanoi one
00:18:47 <jethr0> jmicheal: ">>=" is used _a lot_. you should read up on monads :)
00:19:01 <jmicheal> yea I tried but monads give me a headache :P
00:19:02 <jethr0> jmicheal: http://www.nomaware.com/monads/html/
00:19:14 <vincenz> jmicheal: monads are good against headaches
00:19:36 <jmicheal> yea jethr0 checkin that out now
00:19:43 <earthy> cool, there's a bug in the documentation of that code, tromp. :)
00:19:52 <tromp_> but it generates all primes under 100M in a sec
00:20:05 <jethr0> jmicheal: it took me four times to get myself motivated to use monads and three times i failed. but it's quite worth it :)
00:20:13 <earthy> vincenz: Doaitse even states monads are good for getting headaches
00:20:51 <jmicheal> hehe :)
00:21:34 <vincenz> earthy: who is doaitse
00:22:48 <jethr0> tromp_: nice, a 1989 IOCCC category winner. *chapeau*
00:22:51 <vincenz> tromp_: what's special about acute triangles?
00:24:11 <tromp_> just a nice puzzle
00:25:05 <tromp_> what bug, earthy?
00:25:13 <ihope> Aww, that sieve of there is written in... something.
00:25:25 <ihope> I'm guessing X.
00:25:28 <ihope> s/X/C/
00:26:18 <earthy> tromp: usage: %s <bytes_used or -maxprime>\n
00:26:37 <earthy> -maxprime  is not parserd
00:26:39 <earthy> -r
00:27:00 <tromp_> what do you mean not parsed?
00:27:14 <tromp_> to search up to 1M you say primes -1000000
00:27:40 <earthy> ah. the code seems to state -maxprime
00:27:47 <vincenz> 1M = 1024*1024
00:27:57 <earthy> as in: generate up to the maximum prime the machine will show
00:27:59 <vincenz> unless you sell harddisks
00:28:00 <tromp_> or say primes -1048576
00:28:13 <jethr0> vincenz: 1Mibi = 1024 * 1024 :)
00:28:18 <jethr0> or rather Mi
00:28:28 <vincenz> Mi?
00:28:37 <vincenz> what's a Mibi?
00:28:58 <jethr0> vincenz: m,k,M,G have been multipliers long before computers existed
00:29:02 <earthy> usage: %s (<bytes_used>|-<maxprime>)    would be the way I'd phrase that. :)
00:29:21 <tromp_> ah, ok
00:29:33 <tromp_> can change that
00:29:56 <earthy> but it's ugly nasty code. ;)
00:30:06 <earthy> extremely impressive. :)
00:30:25 <jethr0> vincenz: M = 10^6, Mi = 2^20. it's a feeble attempt to set the record straight
00:30:31 <vincenz> oh
00:30:46 <earthy> MegaBinary
00:30:58 <vincenz> :D
00:31:11 <vincenz> How about MegaUnary?
00:31:44 <tromp_> thx:)
00:32:04 <jethr0> vincenz: try "/sbin/ifconfig". they've actually switched :)
00:36:33 <vincenz> hmm?
00:36:45 <vincenz> oh yeah
00:36:51 <jethr0> @seen roconner
00:36:52 <lambdabot> I haven't seen roconner.
00:36:55 <vincenz> tromp_: that orimaze is difficult
00:38:10 <MarcWeber> I have one comparison (==) of strings in my program. I want to see which values are actually compared. Is there a possibility to debug print this information without adding IO everywhere?
00:38:32 <vincenz> woo I solved it!
00:38:43 <jethr0> MarcWeber: Debug.Trace.trace
00:38:44 <musasabi> MarcWeber: Debug.Trace
00:39:05 <roconnor> @seen roconnor
00:39:05 <lambdabot> You are in #haskell. Last spoke just now.
00:39:09 <MarcWeber> Thanks!
00:39:37 <jethr0> roconnor: thx for adding to my idiom list. that unfoldr is amazing.
00:39:44 <jethr0> roconnor: any more ideas?
00:39:55 <roconnor> let me look again
00:40:13 <roconnor> that's the only time I've used unfoldr ;)
00:40:18 <jethr0> roconnor: i'll have a look at epigram, so you got good chances of being pestered by me :)
00:40:29 <jethr0> it's still a beautiful solution
00:40:55 <jethr0> coincidence of unfoldr and splitAt matching in signature, i guess, but still beautiful
00:42:02 <roconnor> I might say that factorial ought to be memoized
00:42:06 <tromp_> gratz vincenz, the 4x4 is doable
00:42:15 <tromp_> the 5x5 is VERY hard
00:42:33 <roconnor> > let factorials = scanr (*) 1 [0..] in factorials!!6
00:42:36 <lambdabot> Exception: stack overflow
00:42:45 <roconnor> > let factorials = scanl (*) 1 [0..] in factorials!!6
00:42:45 <lambdabot> 0
00:42:54 <roconnor> > let factorials = scanl (*) 1 [1..] in factorials!!6
00:42:55 <lambdabot> 720
00:43:18 <roconnor> there we go
00:43:54 <jethr0> roconnor: true
00:43:58 <roconnor> anyhow, that's all I have off the top of my head
00:44:02 <jethr0> :)
00:44:07 <xerox> > prod [1..6]
00:44:07 <lambdabot>  Not in scope: `prod'
00:44:12 <xerox> > product [1..6]
00:44:13 <lambdabot> 720
00:44:28 <jethr0> when some weird monad magic comes to mind (like sequence, liftM, ...), please do tell :)
00:45:19 <roconnor> I will
00:46:49 <int-e> vincenz: solved what?
00:47:57 <vincenz> tromp's orimaze thingy
01:08:11 <vincenz> Anyone else experiencing this?
01:08:13 <vincenz> gmail seems to be down
01:08:17 <vincenz> and I mean computationally
01:08:19 <vincenz> not just a netsplit
01:09:25 <vincenz> it's back
01:09:27 <eivuokko> Not for me.  But I've seen it hickup few times in past.
01:09:50 <jethr0_> must be all those people using it as their network drive :)
01:10:07 <vincenz> it was hickuping while I tried to edit my filters
01:10:09 <vincenz> and then suddenly boom
01:10:11 <vincenz> it was down
01:10:16 <vincenz> and on my personalized google page
01:10:23 <vincenz> it didn't show naything in the gmail div
01:10:57 <vincenz> at that time I realized how dependent I was on google and how vulnerable our world is *sniff*
01:11:21 <eivuokko> Heh
01:11:30 <vincenz> :P
01:11:49 <vincenz> although gmail being down.. well iti's a bad thing, it's my main mail account
01:13:42 <danols> hi all
01:13:47 <danols> @type liftIO
01:13:48 <lambdabot> Not in scope: `liftIO'
01:14:13 <danols> hmm
01:14:24 <eivuokko> @index liftIO
01:14:24 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
01:14:24 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
01:14:24 <lambdabot> Control.Monad.List
01:14:41 <danols> hi eivuokko
01:15:01 <eivuokko> Ok, so @index wasn't terribly usefull this time :)
01:15:30 <danols> eivuokko i have a question
01:15:53 * vincenz mutters
01:15:59 <eivuokko> Just ask it (on channel), but don't paste too much code.
01:16:00 <vincenz> it seems I have to use windows after all ... 
01:16:10 * vincenz reboots to windows
01:17:13 <danols> simpleHTTP :: Request -> IO (Result Response)
01:17:25 <danols> right ?
01:17:36 <danols> so i do resp <- simpleHTTP
01:17:59 <danols> now resp is of either type it seems
01:18:44 <danols> where i can use case on
01:18:51 <danols> with right a -> something etc
01:18:57 <danols> how do i go about not using case ?
01:19:04 <xerox> @type either
01:19:05 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
01:19:53 <xerox> do response <- simpleHTTP request
01:19:56 <xerox>    either handleError handleResponse response
01:20:20 <xerox> handleError :: ConnError -> IO ()
01:20:28 <xerox> handleResponse :: Response -> IO ()
01:20:41 <xerox> Something like that.
01:21:13 <danols> can i just simply just process the response without not worrying about handleError ?
01:22:32 <xerox> How should the program act when errors happen?
01:23:06 <danols> xerox right now just throw an exception ? :)
01:23:33 <xerox> handleError = error
01:23:37 <Lemmih> do Right response <- simpleHTTP request
01:23:55 <xerox> :-|
01:24:09 <xerox> (...and then complain again sometime in the future?)
01:24:19 <danols> xerox no i'll know why :)
01:24:45 <xerox> My way you have full I/O and decision power.
01:26:48 <danols> xerox ofcourse it's better that way
01:26:52 <danols> xerox but i'm prototyping
01:26:58 <danols> @type Right
01:26:59 <lambdabot> forall b a. b -> Either a b
01:27:17 <jethr0_> > ["gnimnix"] >>= return . reverse
01:27:17 <lambdabot> ["xinming"]
01:27:35 <xerox> jethr0_: fmap
01:27:48 <jethr0_> xerox: sry, wrong window
01:27:59 <xerox> @pl \f xs -> xs >>= return . f
01:27:59 <lambdabot> fmap
01:28:00 <jethr0_> i'm just trying out some things i'm seeing in the channel logs
01:28:40 <jethr0_> like this:
01:28:43 <jethr0_> > (fmap . (!!)) ['a'..'z'] [0,25]
01:28:44 <lambdabot> "az"
01:29:55 <jethr0_> i have no idea why that works. i have no problem with lifting, but the (.) confuses me
01:30:15 <xerox> jethr0_: the (.) sticks the first list to (!!) first argument.
01:30:32 <xerox> > fmap (['a'..'z'] !!) [0,25]
01:30:33 <lambdabot> "az"
01:30:42 <jethr0_> aahh, much better :)
01:31:55 <jethr0_> xerox: would you have any suggestions/improvements for the idiom page i'm starting? http://haskell.org/haskellwiki/User:JohannesAhlmann
01:37:32 <saintiss> hi
01:37:44 <saintiss> apparently, I can use the :: operator to check the type of a value
01:37:55 <saintiss> e.g. 1 :: Integer returns 1
01:38:08 <fluxx> > 2 :: Integer
01:38:09 <saintiss> but why is that? I thought :: was an operator used for creating declarations
01:38:09 <lambdabot> 2
01:38:37 <saintiss> does it have multiple functionality or is this a cause of the implementation?
01:38:40 <fluxx> it doesn't check per'se, but rather suggests the compiler that the type of this expression is the provided one
01:38:49 <fluxx> and the compiler might disagree
01:38:49 <saintiss> ic...
01:38:51 <jethr0_> saintiss: you're explicitely giving the expression "1" the type "Integer". and it then returns the value of the expression
01:38:53 <MarcWeber> Juchuhh Jippidaiey .. My make dependency tree and output it is working !! I'm sure that could have been done with less effort
01:38:56 <fluxx> > "hello"::Integer
01:38:57 <lambdabot> Couldn't match `Integer' against `[Char]'
01:39:05 <saintiss> > t :: Integer -> Integer
01:39:05 <lambdabot>  Not in scope: `t'
01:39:10 <saintiss> then why does that not work?
01:39:19 <saintiss> I am telling it to assume t is now a function
01:39:28 <saintiss> apparently it doesn't work as a declaration there
01:39:31 <fluxx> > let foo a = a + 42 in (foo :: Integer -> Integer) 42
01:39:32 <lambdabot> 84
01:40:15 <fluxx> saintiss, oh, you can't enter such declarations in the interactive sessions, if that's what you're doing?
01:40:16 <saintiss> hmm, interesting
01:40:37 <saintiss> fluxx, I knew that indeed, but I was just wondering why :: behaves differently in interactive sessions than in files
01:40:39 <Igloo> :: isn't an operator, it's syntax
01:40:43 <saintiss> ah...
01:40:52 <saintiss> so it's just hard-coded in the interpreter then...
01:41:03 <saintiss> and there is a different interpreter for interactive than for files
01:41:27 <jethr0_> > let foo :: Integer -> Integer; foo a = a + 42 in foo 42
01:41:28 <lambdabot> 84
01:41:49 <saintiss> right, so "let" lets you declare things in interactive sessions
01:42:02 <saintiss> when the interpreter reads :: from a file, it is seen as a let then?
01:42:34 <pierre-> :: is just context-dependent 
01:42:50 <Igloo> When reading from a file, declarations are expected at the top level
01:42:59 <Igloo> At the top level of ghci, statements are expected
01:43:16 <Igloo> At the top level of the hugs prompt, something mostly like an expression is expected
01:44:13 <Igloo> You also have delcarations after let and after where
01:44:37 <saintiss> ic...
01:48:05 <micty> are there sub languages of haskell?
01:48:33 <Igloo> helium might be one
01:48:38 <micty> (languages which were derived from haskell?)
01:48:50 <MarcWeber> Wow.. it might become a make system with progress bar ;-) of course it does
01:49:03 <MarcWeber> micty The language extensions?
01:49:07 <Igloo> Cayenne, possibly
01:49:25 <Igloo> Some with very little use, and numerous other influenced by Haskell to some extent or other
01:50:58 <carp> the last version of agda was supposed to be haskell (and cayenne) like too I think
01:51:16 <micty> MarcWeber - no, I mean like ML has SML and Caml OCml 
01:51:32 <micty> MarcWeber - or lisp, and scheme
01:51:49 <micty> MarcWeber - and c and c++
01:51:58 <micty> MarcWeber - and c#
01:52:29 <micty> and java
01:52:46 <roconnor> O'Haskell
01:53:31 <micty> OK, (but I hate O langs)
01:59:49 <lispy> Itkovian: a little quake3 work was done.  I fixed some bugs that were a result of ignoring compiler warnings :)
02:01:07 <jmicheal> O'My :P
02:08:16 <micty> I have seen somewhere the definitio of >> to something like ( (fa) (fb).....(f())) but I don't remember where it was
02:09:20 <micty> it is not here http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3A%3E%3E%3D
02:09:33 <Lemmih> (>>) is overloaded. It's defined differently for each Monad.
02:10:29 <neologism> is it called overloading?
02:10:39 <neologism> isnt it just type polymorphism?
02:11:56 <ndm> @seen Jaffacake
02:11:56 <lambdabot> I haven't seen Jaffacake.
02:12:14 <ihope> Well, with classes, I guess it's overloading, since it's defined multiple times... sort of.
02:13:11 <neologism> my prof told me its type polymorphism
02:13:12 <Lemmih> neologism: It's the difference between, say, 'id' and '>>'.
02:13:32 <neologism> cause you have type classes and each type class instance have different methods
02:13:40 <neologism> ie. polymorphism
02:14:13 <ProfTeggy> that's also referred to as ad-hoc polymorphism (in contrast to parametric polyorphism)
02:18:17 <earthy> now, how did I classify polymorphism again... parametric polymorphism, overloading, type-indexing
02:19:03 <earthy> the meaning of the term 'ad-hoc polymorphism' tends to shift
02:19:49 <mauke> ah, adding features by removing code feels good
02:23:10 <micty> where is the source for the Prelude function?
02:23:12 <micty> s
02:24:41 <earthy> there is some source in the haskell report
02:24:43 <ndm> micty, if you are using hugs, just do ":f map" for example
02:25:30 <micty> I don't have hugs yet... what is it/where do I get it?
02:25:37 <ndm> micty: http://www.cs.york.ac.uk/fp/darcs/yhc-devel/src/packages/yhc-base-1.0/Prelude.hs
02:25:41 <eivuokko> Also http://darcs.haskell.org/packages/ and base there, but report is easier to read.
02:25:43 <ndm> thats a prelude that comes with Yhc
02:25:48 <ndm> micty, windows or Linux?
02:26:11 <ndm> eivuokko: that prelude is split into millions of little packages, its a nightmare to read!
02:27:05 <micty> windows
02:27:12 <eivuokko> ndm, It is, however, the right place to read if you are wondering about speed of things when using ghc.
02:27:24 <ndm> @where WinHugs
02:27:24 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
02:27:26 <eivuokko> ndm, otherwise it's of course just plain silly to read it.
02:27:50 <ndm> eivuokko: i often read the prelude, to figure out the exact semantics/laziness of certain functions
02:27:51 <earthy> and ofcourse, there's the tour of the haskell prelude at http://www.cs.uu.nl/~afie/haskell/tourofprelude.html
02:28:06 <ndm> micty: follow that WinHugs link
02:28:56 <eivuokko> ndm, Heh.  I usually test it.  But I meant my link, not Prelude in general.
02:29:50 <Lemmih> @libsrc Prelude
02:29:51 <lambdabot> http://darcs.complete.org/fptools/libraries/base/Prelude.hs
02:30:28 <micty> what is this winhugs?
02:31:12 <ndm> micty: hugs, a haskell interpretter, for windows
02:31:23 <ndm> with a nice GUI, as well as a console version
02:31:33 <ndm> its the easiest haskell interpetter to get started with
02:32:00 * earthy coughs
02:32:06 <earthy> yes and no
02:32:13 <earthy> there's helium's hint
02:32:18 <earthy> which provides better error messages
02:32:27 <ndm> earthy: but thats still not full haskell?
02:32:36 <earthy> but that is not full haskell
02:32:43 <earthy> it's getting closer and closer though
02:32:58 <ndm> is their ultimate goal full haskell?
02:33:15 <earthy> not really
02:33:20 <ndm> i can't beleive its easier to use than WinHugs, even if the error messages are better
02:33:45 <earthy> but I think from Helium and EHC a very good Haskell' implementation with great error messages will emerge
02:34:07 <ndm> cool, looks like there could be loads of haskell' implementations
02:34:18 <ndm> which is much better than the current "GHC as a standard"
02:34:22 <tromp_> are there any untyped languages with Haskell's syntax?
02:34:23 <earthy> ;)
02:34:37 <earthy> tromp: why would you want that?
02:34:51 <tromp_> to do algorithmic information theory
02:35:14 <ndm> tromp_: you could write one...
02:35:26 <tibbe> hmm is there a monad transformer for IO?
02:35:28 <tromp_> i'm lazy:(
02:35:29 <ndm> tromp_: Erlang is probably closest...
02:35:41 <tromp_> erlang is untyped?
02:35:43 <ndm> (i think, i don't know that much of its syntax)
02:35:48 <ndm> tromp_: yes, i think
02:36:46 <tibbe> about that IOT transformer...
02:37:13 <Phyx-> shapr is gone :(
02:37:24 <earthy> tromp: doesn't AIT normally abstract from the programming language used?
02:41:47 * earthy hugs wikipedia
02:42:34 * xerox joins the hug
02:42:43 <jonkri^vanja> can i download wxhaskell 0.9 for debian somewhere? i only find 0.8... thanks in advance
02:43:49 <tibbe> earthy, then you should get wikipodia so you can have it on your ipod ;)
02:44:01 * Phyx- hugs lambdabot 
02:44:08 <Phyx-> lambdabot: open up :p
02:44:11 <earthy> tibbe: that requires installing iPodLinux, which is something I do not wish to do
02:44:30 <tibbe> earthy, I didn't now, I don't use it, just discovered it today
02:44:54 <earthy> (it's a great, *GREAT* idea though. pity it's too big for my Palm)
02:45:13 <earthy> (it'd be perfect on a LifeDrive however)
02:45:42 <Phyx-> rofl... i'm so broke i'm eating nachos for dinner
02:46:01 <tibbe> earthy, how big is it?
02:46:12 <xerox> tibbe: and how do you browse it on the ipod?
02:46:18 <earthy> tibbe: 753MiB
02:46:43 <earthy> xerox: you select letters with the scrollwheel and click to the next/previous letters and click to search
02:47:06 <earthy> not *very* practical. perfect on a lifedrive, not so perfect on an iPod
02:47:07 <xerox> I mean at a more deeper level, maybe you have some url?
02:47:20 <earthy> oh, yeah, there's hyperlinks
02:47:38 <xerox> I mean some explanative url, I'll search, nevermind.
02:51:44 <musasabi> Is there a way to suply -package through an OPTIONS pragma?
02:51:50 <musasabi> for GHC that is.
02:52:31 <tibbe> xerox, the wheel and the 3 (?) buttons of course ;)
02:53:20 <tromp_> earthy: not if you want to do it concretely, which is exactly my goal
02:55:00 <tibbe> how do you compose IO and Reader, now I just use reader and don't want to do a lift on everything which I will have to if I go with ReaderT IO.
02:57:41 <Lemmih> tibbe: That's not possible.
02:58:10 <tibbe> Lemmih, as I thought, darn
02:58:31 <tibbe> Lemmih, now I'll have my interpreter cluttered with all these ugly lifts
03:00:35 <Lemmih> Sounds like a bit of refactoring is in order.
03:00:55 <tibbe> well, it's nice and refactored, kinda
03:01:10 <tibbe> http://www.itstud.chalmers.se/~larssont/Interpreter2.hs
03:01:26 <ndm> Lemmih, how is Gardener coming along? when will it be ready to run on code?
03:01:51 * ndm really wants to tidy up Yhc
03:03:42 <Lemmih> tibbe: That doesn't very cluttered with lifts (:
03:05:41 <micty> is this \ _ -> k 
03:05:51 <micty> a function that returns k?
03:06:03 <ndm> micty, yes
03:06:06 <Lemmih> ndm: It's almost done. Requires a very recent version of GHC, though.
03:06:07 <ndm> and takes one argument
03:06:31 <ndm> Lemmih: i have a build of HEAD GHC
03:07:03 <ndm> I removed 25 dead definitions out of Yhc yesterday, it would be nice to have it done automatically :)
03:07:31 <musasabi> dons: btw pidigits went in.
03:08:49 <tibbe> great, now my program has the IO virus
03:09:18 <micty> is [] in Monad [] stands for list or empty list?
03:09:26 <micty> nil
03:09:44 <ndm> tibbe, why do you need IO?
03:10:32 <tibbe> ndm, because I want to add IO capabilities to my interpreter (e.g. putChar/readChar)
03:10:46 <ndm> tibbe, but currently, it could be entirely pure?
03:11:16 <mauke> micty: are you talking about instance Monad []?
03:11:32 <micty> mauke-yes 
03:11:34 <tibbe> ndm, yes
03:11:43 <tibbe> ndm, it runs in Reader
03:11:49 <mauke> micty: yeah, that's the list type, not the empty list value
03:12:08 <micty> mauke-thanks
03:13:20 <Lemmih> @kind []
03:13:21 <lambdabot> * -> *
03:13:46 <carp> it's the list type constructor
03:14:52 <tibbe> argh!
03:35:19 <Phyx-> hmm i dled lambdabot with darcs, but now what?
03:42:24 <ndm> Phyx-: what is it you are aiming to do?
03:44:03 <Phyx-> trying to get lambdabot running on my channel. is it even able to run on windows?
03:44:09 <Phyx-> the readme shows nix commands only
03:54:57 <Phyx-> $ ln -s fps.cabal.no-mmap fps.cabal <-- shouldn't this be an ld?
03:55:00 <Phyx-> or does ln exist?
03:55:06 <Phyx-> don't have it in MingW
03:56:47 <Phyx-> oops, guess i do
04:00:25 <musasabi> Phyx-: just use copy instead ln.
04:00:42 <Phyx-> musasabi: i found it in MSYS
04:00:44 <musasabi> (or if ln works, use that)
04:00:53 <Phyx-> musasabi: but where s runhaskell?
04:01:54 <musasabi> try runghc
04:04:06 <musasabi> if that does not work just "ghc --make Setup.hs -o setup" (or Setup.lhs) and then setup configure, setup build, setup install
04:13:44 <jonkri^vanja> ok, i'm trying to install wxhaskell but it complains: You need to emerge wxGTK with gtk2 in your USE
04:14:04 <jonkri^vanja> i emerged wxgtk first with USE="gtk2" but later with USE="*"
04:14:49 <jonkri^vanja> and i _still_ get the error. so something is broken. please help!
04:15:06 <tibbe> jonkri, had that problem too, don't remember how i solved it though...
04:15:20 <tibbe> perhaps try something in the test branch
04:15:26 <jonkri^vanja> what's that?
04:16:12 <tennin> What became of the CGI library described in Hughes' paper on arrows?
04:18:06 <tibbe> jonkri^vanja, ther ~arch masking
04:18:13 <tibbe> the*
04:18:35 <Phyx-> musasabi: ok, lemme try
04:24:35 <Phyx-> musasabi: no runghc
04:24:50 <Phyx-> i'll jus start ghc
04:25:38 <palomer> hmm
04:25:39 <palomer> @seen cajole 
04:25:40 <lambdabot> cajole is in #haskell. I don't know when cajole last spoke.
04:25:42 <palomer> @seen Cale 
04:25:42 <lambdabot> Cale is in #haskell. Last spoke 8 hours, 22 minutes and 48 seconds ago.
04:26:21 <palomer> there should be a book on haskell design
04:29:13 <palomer> ok, that's it, I'm going to start using darcs
04:29:20 <palomer> I'm sick of copying my directories
04:29:55 <jonkri^vanja> tibbe, ok, thanks
04:35:36 <Phyx-> musasabi: ahh, found em in the bin folder
04:35:37 <Phyx-> thanx :P
04:39:36 <Phyx-> rofl
04:39:52 <Phyx-> i get a memory violation error when doing Setup.hs build
04:41:42 <Phyx-> bah... i give up...
04:42:26 <Phyx-> Preprocessing library fps-0.1...
04:42:27 <Phyx-> Building fps-0.1...
04:42:36 <Phyx-> then a big error :s
04:42:45 <Phyx-> is this thing windows friendly?
04:44:08 <musasabi> Phyx-: use "ghc --make " to build setup from Setup.hs
04:44:38 <Phyx-> ok, so ghc --make Setup.hs?
04:45:15 <Phyx-> ok, finished i think
04:46:33 <Phyx-> musasabi: sorry to bother you, then what?
04:46:50 <Phyx-> the runhaskell Setup.hs install fails
04:46:53 <Phyx-> obviously
04:47:29 <musasabi> Phyx-: setup install
04:47:43 <musasabi> (if you have first compiled setup and run setup configure and setup build)
04:48:16 <Phyx-> i did run configure and build
04:50:44 <Phyx-> hahhaha, that's a new one, it broke msh
04:50:45 <Phyx-> :S
04:53:53 <Phyx-> musasabi: you guys should put up a windows readme
04:55:11 <musasabi> one problem is that many haskell projects don't have any active windows gurus.
04:55:41 <palomer> oh boy, I'll be using darcs for the first time soon
04:55:50 <palomer> this coincides with my using a makefile for the first time 2 months ago
04:56:06 <Phyx-> wouldn't be that far of a stretch, using MSYS and MingW i got most to work
04:56:12 <gour> palomer: you'll like it
04:56:15 <Phyx-> but now setup is failing
04:56:25 <Phyx-> i did setup install and it hung
04:56:27 <Phyx-> :|
04:56:31 <palomer> next step: some serious quickchecking
04:56:37 <musasabi> Phyx-: most of the time it is small things like not regularly testing whether thigns work on windows.
04:56:42 <gour> Phyx-: what do you try t obuild?
04:56:43 <Phyx-> palomer: yeah, i used it first time a few mins ago, it's good
04:56:53 <Phyx-> gour: lambdabot 
04:57:04 <Phyx-> musasabi: a question
04:57:15 <musasabi> yes?
04:57:18 <gour> Phyx-: ahh, on linux it built nicely, never tried on win32
04:57:34 <Phyx-> runhaskell Setup.hs configure --prefix=/f/g that still valid in windows?
04:57:47 <palomer> Phyx-: quickcheck?
04:58:04 <Phyx-> i dunno, i mean the prefix
04:58:10 <musasabi> yes, that should be valid, although --prefix=C:\foo\bar maybe
04:58:12 <sebell> Phyx-: Should be fine
04:58:14 <Phyx-> gour: i have all the tools you name
04:58:18 <Phyx-> but
04:58:23 <Phyx-> ok, lemme try again
04:58:36 <musasabi> (I don't have a windows machine myself)
04:59:25 <Phyx-> lol, if it doesn't work, i'll be handing out rdesktop user accounts :P
04:59:48 <Phyx-> lemme make a fresh fps folder
05:01:13 <Phyx-> bah
05:01:21 <Phyx-> now it says i can't remove the folder
05:02:43 <Phyx-> ok
05:04:17 <Phyx-> fetching again
05:08:47 <Phyx-> *sigh*
05:17:44 <musasabi> Phyx-: cabal works with some issues on windows, once upon a time I tested some packages on a windows 2003 machine and it worked via the compile with ghc and run the resulting setup.exe route.
05:18:49 <jonkri^vanja> why isn't it possible to have a "name :: type" in two different constructors where name and type is the same?
05:18:58 <jonkri^vanja> i get multiple declarations
05:20:19 <Phyx-> musasabi: i am on windows 2003
05:20:35 <Phyx-> musasabi: and when i run ghc it produces a .o file
05:20:43 <Phyx-> i run that and nothing happeneds
05:22:48 <jonkri^vanja> for example i can't do this: data Test = Test { a :: c, b :: d} and Another = Another { e :: f, a :: c }
05:27:45 <palomer> well, erm, that syntactically incorrect
05:28:06 <palomer> s/that/that is
05:28:37 <palomer> and besides, record labels create functions. do you want the same function name have 2 different types?
05:29:16 <jonkri^vanja> palomer, oh, functions, ok
05:29:36 <jonkri^vanja> palomer, the functions are undefined?
05:29:49 <jonkri^vanja> s/the/does it work even if the
05:29:52 <palomer> data Test = Test {a::Int}
05:30:12 <palomer> let b = Test 4 in a b
05:30:59 <Lemmih> jonkri^vanja: 'data Tt = Tc { x :: X }' is sugar for 'data Tt = Tc X; x (Tc v) = x'.
05:31:24 <Lemmih> s/ = x/ = v/
05:31:56 <jonkri^vanja> Lemmih, what do you mean?
05:32:08 <jonkri^vanja> Lemmih, ";" separates two "lines"?
05:32:21 <Lemmih> jonkri^vanja: Yes.
05:32:48 <Lemmih> > let x = 10; y = 20 in (x,y)
05:32:49 <lambdabot> (10,20)
05:33:18 <jonkri^vanja> ah, ok
05:34:05 <jonkri^vanja> i still don't understand your two lines above
05:34:18 <jonkri^vanja> why "= v"?
05:35:19 <jonkri^vanja> and e :: f looks like e is defined as a function that returns f, but i don't dont declare what the function does anywhere
05:39:45 <ihope> @index IOT
05:39:46 <lambdabot> bzzt
05:40:55 <ihope> Is there a transformer for the IO monaD>
05:41:04 <Lemmih> jonkri^vanja: It's a field which creates a function of type 'Another -> f'.
05:41:56 <jonkri^vanja> what if i want to use the a function below then?
05:47:51 <palomer> anyone here heavy on monad transformers?
05:47:54 <gour> Lemmih: any (more) progress in making hIDE buildable?
05:47:56 <palomer> I have a monad transformer design question
05:48:03 <ihope> ListT (StateT IO)
05:48:06 <ihope> Erm.
05:48:08 <ihope> ListT (StateT a IO)
05:48:21 <ihope> >:-)
05:48:31 <palomer> ihope: you want IOT?
05:48:42 <ihope> Well... yeah,
05:49:12 <palomer> IOT cannot exist
05:49:20 <palomer> well, erm, it would be screwed up if it did
05:49:28 <ihope> Why?
05:49:37 <palomer> Philippa claims that you could win the lottery
05:49:41 <palomer> I don't quite understand her argument
05:50:01 <palomer> anyways, there are semantic considerations for not having IOT
05:50:25 <palomer> but, yeah, I see your point of view. if you have runIO, might as well have IOT
05:50:36 <jonkri^vanja> Lemmih, what's a field? what's another? and btw, i used a::c both times above, i want THE SAME name and type for both
05:50:51 <jonkri^vanja> if someone could tell me how this works i would be very greatful
05:51:38 <palomer> jonkri^vanja: in my previous example, what was the type of a?
05:52:10 <jonkri^vanja> palomer, int
05:52:19 <palomer> nope
05:52:28 <palomer> it is Test -> Int
05:52:45 <jonkri^vanja> to make what i mean clearer: data Test = Test { a :: Int, b :: Int} and Another = Another { e :: Int, a :: Int }
05:52:55 <jonkri^vanja> that's impossible, since a :: Int appears in two places, if i understood it correct
05:53:21 <palomer> the first label creates a function named a with type Test -> Int
05:53:29 <jonkri^vanja> (Lemmih: oh, you meant _that_ another ;-))
05:53:38 <palomer> the second label creates a function named a with type Another -> Int
05:54:16 <palomer> so we have 2 functions named a, each with a different type
05:56:56 <jonkri^vanja> how should i name these things in a clearer way?
05:57:22 <Lemmih> gour: Haven't had much time for hIDE lately.
05:57:24 <palomer> give the labels different names
05:58:01 <gour> Lemmih: ok, np. 
05:58:01 <jonkri^vanja> yeah, but that feels messy. i mean the same thing, basically
05:58:14 <palomer> oh, but they aren't
05:58:19 <palomer> they act on different things
05:58:45 <palomer> if you want, you can create use typeclasses if you want one function to act on two different types
05:58:51 <palomer> s/create/
05:59:05 <jonkri^vanja> what's the syntax for that?
05:59:32 <palomer> class Intable a where intable :: a -> Int
06:00:02 <palomer> instance Intable Test where intable (Test {a=foo}) = foo
06:00:20 <jonkri^vanja> hmm, ok. thanks
06:00:23 <palomer> instance Intable Another where intable (Another {a'=foo}) =foo
06:01:46 <palomer> check out the yaht for typeclass syntax
06:02:30 <jonkri^vanja> thanks palomer, and thanks Lemmih
06:04:15 <palomer> Philippa: got time to answer a design question?
06:32:06 * palomer is amazed at the deadness of this channel
06:33:38 <int-e> oh come on, there are only 183 people here, give them a rest.
06:34:03 <bd_> Everyone's just being lazy.
06:34:37 <palomer> anyone here big on monad transfomers?
06:37:01 <Lemmih> Somewhat.
06:37:26 <TuringTest> palomer: I can sling a transformer...
06:37:42 <palomer> ok, so cale wrote this STI monad
06:37:48 <palomer> which is ST with indexed strefs
06:38:00 <palomer> so I want to use this for most of my code
06:38:01 <TuringTest> http://haskell.org/hawiki/STOMonad ?
06:38:04 <palomer> yeah
06:38:13 <palomer> but at some point I want to use STIRE
06:38:21 <palomer> which is STI + reader + error
06:38:23 <jonkri^vanja> thanks for your help
06:38:28 <TuringTest> ST + I + R? E?
06:38:31 <TuringTest> ah
06:38:45 <TuringTest> And error is the problem
06:38:50 <palomer> how so?
06:39:40 <TuringTest> (Nevermind -- I was wrong)
06:40:01 <palomer> so, the question is:
06:40:13 <palomer> should I write a STIRE monad, or should I use the RET transformer
06:40:28 <palomer> (which I would also have to write)
06:40:32 <palomer> RET = reader + error
06:41:06 <palomer> ie, should I encapsulate my use of RET into a monad
06:42:00 <TuringTest> I am lazy, I would just use ErrorT ReaderT STO
06:42:14 <TuringTest> (where STO is already StateT ST)
06:42:44 <palomer> but if you weren't lazy, you'd do it the hard way, right?
06:42:51 <palomer> or, rather, the more verbose way
06:42:51 <TuringTest> I am always lazy
06:43:10 <xerox> The Monad makes reusable code!
06:43:12 <TuringTest> Well... what would you gain with the verbose way?  What is the the pro-verbose column?
06:44:06 <palomer> column?
06:44:18 <palomer> oh, right
06:44:21 <palomer> the columns
06:44:26 <TuringTest> Pro v Con
06:44:37 <palomer> well, if ever I want to add to that monad, I would simply change that file and nothing else
06:44:49 <palomer> and, besides, with your code I would need to write lift $ lift $ all the time, no?
06:45:15 <palomer> whereas in my code I would only need to write lift $
06:45:19 <TuringTest> Well..Monad ErrorT/StateT/ReaderT should all lift automatically
06:45:39 <TuringTest> (unless I am on crack)
06:45:59 <musasabi> don't use lift write specific lift functions.
06:46:24 <TuringTest> And you could write "myFoo = lift $ lift $ foo" for the rest.  Hide the lifting inside a shorthand like myFoo
06:46:28 <TuringTest> (or a class)
06:46:35 <musasabi> yes.
06:47:03 <musasabi> Then when the monad stack changes just small changes are needed to combinators.
06:47:07 <TuringTest> All the "lift" should be called by helper functions
06:47:17 * TuringTest nods as musasabi
06:47:19 <palomer> even better, I could write my own transfomer, ReaderErrorT
06:47:32 <palomer> TuringTest: could you give me an example?
06:47:43 <musasabi> or define it by hand
06:48:18 <musasabi> newtype FooM a = FooM { unFooM :: MyState -> FooRes a }
06:48:19 <palomer> well, the code for ReaderErrorT would be 4 lines long
06:48:21 <TuringTest> instead of lift$ lift$ newSTORef define "newRef = lift $ lift $ newSTORef"
06:48:34 <musasabi> data FooRes a = FooOk a | FooErr String
06:48:43 <musasabi> + instance Monad etc
06:49:37 * palomer can't tell if musasabi is being facetious
06:50:08 <palomer> TuringTest: so you encapsulate all the outside functions you'd use?
06:50:46 <TuringTest> Right...The code running inside the monad never ever calls "lift"
06:50:49 <palomer> liftify bar = lift $ lift $ bar
06:51:00 <palomer> newRef = liftify newSTORef
06:51:11 <TuringTest> That is even clearer
06:51:17 <palomer> TuringTest: what are the advantages of doing it this way?
06:51:23 <Revision17> What does @ do in this code "foo x l@(y:ys) ="?
06:51:35 <palomer> Revision17: it binds l to (y:ys)
06:51:41 <TuringTest> You can insert something in the middle of the Monad stack and only redefine newRef
06:51:56 <Revision17> palomer: ah, that makes sense; thanks :)
06:52:11 <palomer> TuringTest: or, in this case, redefine liftify
06:52:20 * TuringTest nods at palomer
06:52:48 <palomer> there should be a mechanical way of combining monad transformers
06:52:54 <TuringTest> (What I said does not apply to "liftIO")
06:52:55 <palomer> the code is always the same
06:53:06 <palomer> what's liftIO?
06:53:12 <TuringTest> palomer: the newtype deriving() helps
06:53:33 <TuringTest> @index liftIO
06:53:33 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
06:53:33 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
06:53:33 <lambdabot> Control.Monad.List
06:53:43 <TuringTest> @index MonadIO
06:53:44 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.
06:53:44 <lambdabot> Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error,
06:53:44 <lambdabot> Control.Monad.List
06:53:55 <palomer> @hoogle liftIO
06:53:56 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
06:53:56 <lambdabot> Graphics.UI.ObjectIO.StdIOBasic.liftIO :: IOMonad m => IO a -> m a
06:53:57 <TuringTest>  Control.Monad.Trans.MonadIO defines liftIO
06:54:06 <int-e> palomer: hmm. newtype MonadComb mt1 mt2 a = mt1 (mt2 a) ; instance MonadTrans (MonadComb mt1 mt2) where ...
06:54:31 <TuringTest> If you add transforms to the IO base monad, they can be made instances of MonadIO and liftIO will lift the IO to the top level in one step.
06:54:42 <palomer> fromJust (liftIO getStr) <--this code should work, right?
06:55:07 <palomer> int-e: yeah, there should be language support for it
06:55:08 <TuringTest> palomer:  MaybeT ?
06:55:27 <palomer> oh, righto, Maybe isn't a MonadIO
06:55:42 * palomer is staying far away from IO, for now
06:56:10 <palomer> far, far away
06:56:20 <palomer> ok, this is going to be interesting
06:56:24 <int-e> there is no safe distance
06:56:48 <palomer> thx a bunch!
07:01:02 <palomer> ErrorReaderT is the same as ReaderErrorT, right?
07:03:56 <int-e> One supports error depending on the reader value, the other doesn't. I think they are not the same.
07:04:13 <astrolabe> http://www.nomaware.com/monads/html/standardxformers.html
07:04:21 <astrolabe> the bottom of the page says they're different
07:04:40 <astrolabe> Ah no
07:04:52 <astrolabe> I'm muddling me monads
07:06:37 <Phyx-> anyone have a compiled lambdabot for me?
07:06:45 <palomer> newtype ReaderStateT r s m a = ReaderStateT (ReaderT r (StateT s m) a)
07:06:45 <palomer>     deriving (Functor, Monad, MonadReader r, MonadState s)
07:06:58 <palomer> how can a ReaderStateT derive Monad ?
07:09:23 <TuringTest> technology indistinguishable from magic
07:09:28 <bd_> I'd guess because it's isomorphic to an instance of Monad...
07:09:42 <TuringTest> palomer: (Monad m) => 
07:09:48 <int-e> palomer: simple. (ReaderT r (StateT s m) a) is a Monad
07:09:58 <TuringTest> (If m is a monad)
07:10:04 <int-e> right
07:10:32 <int-e> I guess it'll actually put a (Monad (ReaderT r (StateT s m) a)) => constraint there
07:10:51 <palomer> ah, gotcha
07:11:05 <TuringTest> int-e: The constraint goes into the Monad instance for ReaderStateT
07:11:13 <int-e> TuringTest: yes
07:12:29 <TuringTest> I am temporarily out of small Haskell projects to amuse myself with.  Perhaps I should think of another or locate a real project to assist for fun.
07:12:46 <kowey> TuringTest: darcs?
07:13:32 <TuringTest> I actually don't use darcs
07:13:50 <astrolabe> TuringTest: Enter the Loebner prize contest.
07:14:04 <goron> astrolabe: heh
07:14:15 <TuringTest> astrolabe: do not taunt me
07:14:53 <goron> TuringTest: You can build another Haskell compiler.
07:14:54 <astrolabe> Taunt?  You'd like to?
07:15:21 <TuringTest> Well, what I meant to say is taunting is better done in haskell-blah
07:15:21 <palomer> int-e: so they're not the same?
07:15:54 <TuringTest> palomer: Some monads do commute.  ReaderT commutes with most anything.
07:15:56 <int-e> palomer: yes
07:16:41 <astrolabe> What is IOT?
07:17:15 <astrolabe> Ah, a transformer that wraps things in IO.
07:17:26 <TuringTest> where is that, astrolabe ?
07:17:39 <TuringTest> I thought that did not / could not exist
07:17:51 <TuringTest> > "a" \\ "a"
07:17:51 <astrolabe> I was just reading above, where someone said that.
07:17:52 <lambdabot> ""
07:18:05 <mauke> > "\\"\\"\\"
07:18:06 <lambdabot> ""
07:18:30 <TuringTest> > "IDIOT" \\ "ID"
07:18:31 <lambdabot> "IOT"
07:18:39 <goron> :)
07:18:41 <TuringTest> It only deletes the first "I"
07:19:02 <mauke> > "\\\ \" \\ "\ \\\"
07:19:03 <lambdabot> ""
07:19:38 <TuringTest> mauke aspires after Houdini
07:19:49 <palomer> ok, TuringTest says they're the same and int-e says they're not
07:19:51 <palomer> make up your minds!
07:20:56 <palomer> http://www.rafb.net/paste/results/yRNDST11.html
07:20:58 <TuringTest> palomer: In general, the order of monad transforms can matter.  But the specific transformer ReaderT is kinda immuatable, so it commutes with most things.
07:22:48 <ramza3> anybody using jaskell
07:22:59 <ramza3> ?
07:24:35 <palomer> what's MonadError?
07:24:59 <TuringTest> palomer: instance MonadTrans (ReaderErrorT r e) where lift = lift 
07:25:11 <TuringTest> makes it compile
07:25:21 <palomer> but I'm stacking 2 transformers
07:25:25 <palomer> shouldn't that mean 2 lifts?
07:25:30 * palomer is confused
07:25:40 <TuringTest> the first lift knows to call the second
07:25:58 <bd_> TuringTest: Wouldn't lift = lift loop?
07:26:06 <TuringTest> hmmm....
07:26:32 <sieni_> palomer: like bench press and deadlift?
07:26:38 <palomer> har har
07:28:49 <Lemmih> ramza3: I don't think so. What is it?
07:28:59 <ramza3> Lemmih, haskell in java
07:31:39 <goron> ramza3: And its last change is six years old?
07:32:25 <TuringTest> palomer:  instance (Error e) =>  MonadTrans (ReaderErrorT r e) where lift = ReaderErrorT . lift . lift 
07:32:33 <TuringTest> That does the trick
07:32:40 <ramza3> goron, I think google got the best of you, try this one: http://jaskell.codehaus.org/
07:33:19 <goron> ramza3: I saw that page too, but didn't spend much time looking at it. Thank you
07:34:07 <TheHunter> does that really need (Error e)?
07:39:30 <palomer> TuringTest: why do we need to qualify e as Error?
07:39:40 <palomer> e should be the type of the error returned
07:39:52 <TuringTest> The MonadTrans instance of ErrorT needs an (Error e) context
07:40:17 <TuringTest> You have to re-declare this context
07:40:43 <TuringTest> The GHC error told us to put (Error e) and it works
07:40:48 <palomer> so I can only transform errors?
07:41:08 <palomer> or, rather, values of Error e
07:41:26 <TuringTest> You have to use instances of Error e in your monad
07:41:54 <TuringTest> The only provided instance is [Char] but you can declare your own
07:42:28 <TuringTest> You just need to provide implementation of "noMsg" and "strMsg"
07:42:33 <MarcWeber> Is there a foldr1 function for monads?
07:42:38 <palomer> oh my, my errors are going to be (Int,Int)
07:43:14 <TuringTest> palomer: so have them return (-1,-1) or some such flag value
07:43:26 <TuringTest> Or leave them undefined...
07:44:00 <palomer> is MonadError a subclass of Monad?
07:45:46 <palomer> <last question> is MonadError a subclass of Monad?
07:45:50 <palomer> I can't understand the docs
07:46:16 <TuringTest> in ghci , just type ":i MonadError"
07:46:24 <MarcWeber> Now I know why foldr1M doesn't exist.. you can use liftM (foldr1 func) (sequence list) ....
07:46:47 <palomer> yeah, it says the same thing as the docs
07:46:54 <palomer> how can I tell if its a subclass of Monad?
07:47:08 <MarcWeber> palomer I'm using sources to loob things like this up.. wait
07:48:05 <TuringTest> palomer: "subclass" is not a Haskell term .  What do you mean?
07:48:13 <palomer> it isn't?
07:48:15 <palomer> hrm
07:48:31 <palomer> class Monad m => MonadError e (m::* -> *) | m -> e where <--what does this mean?
07:48:42 <palomer> am I defining a typeclass called MonadError?
07:48:46 <Phyx-> hmmm,, ok i'm just gonna make my own bot using ghci :| compiling lambdabot seems not to be working
07:48:54 <TuringTest> ok..I'm wrong it is a haskell term
07:49:00 <Phyx-> it aint windows friendly :S
07:49:15 <palomer> MarcWeber: to loob what up?
07:49:15 <Phyx-> @type takeUntil
07:49:16 <lambdabot> Not in scope: `takeUntil'
07:49:17 <MarcWeber> He means inherits all methods from Monad, right? Is this said this way in haskell?
07:49:24 <TuringTest> palomer: It means that MonadError e m is a class where m must be an instance of Monad
07:49:31 <TuringTest> palomer:  And it means that m has kind *->*
07:49:49 <palomer> but Error is also a typeclass
07:49:55 <MarcWeber> palomer oh.. The definition looks the same here .. I have read about that stuff *think*
07:50:25 <TuringTest> palomer:  and it means that for all instances, if m==m' then e == e'
07:50:32 <Cale> hello
07:50:38 <palomer> so Error e is an instance of monad for any e
07:50:48 <TuringTest> No
07:50:54 <TuringTest> Error is not a monad
07:51:07 <palomer> ahh, this is becoming clearer
07:51:22 <Cale> Error is just a funny class which says which datatypes are suitable for holding errors.
07:51:40 <palomer> so instances of MonadError are the monads
07:51:43 <Cale> yeah
07:51:59 <palomer> and MonadError insists that its first argument is an error
07:51:59 <TuringTest> The naming scheme is broken, 
07:52:06 <palomer> yeah, I noticed
07:52:44 <MarcWeber> Hi Cale!
07:52:47 <Cale> hello
07:53:20 <palomer> could one simply use Either as a way to flag errors?
07:53:32 <Cale> yes
07:53:36 <Cale> Either String
07:53:44 <Cale> is in itself a monad
07:54:35 <palomer> wait, that won't work, I really need MonadError
07:54:53 <Cale> yeah, if you want lots of other features
07:55:04 <palomer> hrmph, looks like I'm going to have to make (((Int,Int),(Int,Int)),String) an instance of Error
07:55:17 <palomer> Cale: how would I throw an error with Either String?
07:56:06 <Cale> Using the MonadError class
07:56:16 <Cale> or just  Left "error!"
07:56:18 <TuringTest> when (bad) $ Left "message"
07:56:21 <Cale> which is an action in that monad
07:57:49 <TuringTest> palomer:  instance Error (((Int,Int),(Int,Int)),String)  where noMsg = (((-1,-1),(-1,-1)),"noMsg") ; strMsg = const noMsg
07:57:55 <TuringTest> (in one line)
07:58:38 <Cale> you probably want strMsg to fill out the string
07:58:53 <palomer> No instance for (Monad (Either [Char]))
07:58:55 <TuringTest> palomer:  Cale may be right, what does the String represent?
07:59:05 <palomer> oh, the string is the error
07:59:11 <Cale> palomer: import Control.Monad.Error
07:59:16 <TuringTest> palomer: import Data.Either
07:59:16 <palomer> the ((Int,Int),(Int,Int)) is the position in the code where the error happened
07:59:24 <Cale> either one of those :)
07:59:46 <Cale> palomer: did you see dons' nice hack for getting that into a string?
08:00:31 <palomer> for doing wha?
08:00:47 <palomer> Data.Either doesn't define an instance (Monad (Either String))
08:00:49 <TuringTest> Cale: I saw that.
08:01:02 <Cale> Control.Monad.Error does
08:01:25 <Cale> for getting the current source position into a string :)
08:01:29 <lisppaste2> TuringTest pasted "for palomer" at http://paste.lisp.org/display/17391
08:01:38 <TuringTest> Cale: I pasted it
08:02:41 <TuringTest> He used the same name "trace" as in Debug.trace which was not so nice
08:03:11 <palomer> what does that code do?
08:03:25 <ihope_> Apparently these carriage returns are acting up.
08:03:43 <palomer> it prints the current line and column number of the source file?
08:03:45 <TuringTest> palomer: It grabs the location information in the source *.hs file and adds it to the error trace
08:03:52 <palomer> oh my
08:03:53 <TuringTest> palomer: yes
08:03:57 <TuringTest> By using catch
08:03:57 <palomer> that's nuts
08:04:00 <TuringTest> :)
08:04:09 <TuringTest> Don is a bit nuts, sure.
08:04:19 <TuringTest> As Cale said, it is a nice hack
08:04:29 <palomer> is it possible to get a stack trace this way?
08:04:42 <TuringTest> Err...no
08:04:42 <ihope_> What the...
08:04:52 <TuringTest> ihope_: Acting up?
08:05:05 <ihope_> Well, I'm not sure just what's wrong.
08:05:15 <ihope_> Hmm...
08:05:29 <TuringTest> ihope_: could the NSA be bugging your computer again?
08:05:37 <ihope_> Anyway, my IRC bot won't hold a connection.
08:05:40 <Cale> palomer: a stack trace would be slightly less meaningful than you'd want
08:05:52 <palomer> hmm
08:05:54 <palomer> this function seems insane
08:05:55 <TuringTest> (after 10^6 tail calls, for instance)
08:05:58 <palomer> also exactly what I want
08:06:03 <TuringTest> :)
08:06:04 <ihope_> TuringTest: hmm... you think? You suppose they think my bot's out to DoS something? ;-)
08:06:19 * ihope_ tweakies
08:06:25 <Phyx-> http://rafb.net/paste/results/D2zCZ028.html
08:06:32 <Phyx-> can anyone tell me what's wrong there?
08:06:36 <Cale> palomer: you probably want to convert it so that it just returns a string in your monad
08:07:09 <Cale> Phyx-: what's the error?
08:07:10 <TuringTest> Phyx-: Dup and lta are undefined?
08:07:13 <ihope_> Maybe this thing's garbage collecting too often.
08:07:17 <Phyx-> Cale: http://rafb.net/paste/results/dMPaw439.html
08:07:19 <palomer> oh, but my errors are coming from user input source files
08:07:22 <Phyx-> TuringTest: yep, it is
08:07:23 <ihope_> Well, I'm stumped.
08:07:33 <palomer> Cale: this is exactly what I want in other respects
08:07:37 <Phyx-> Dup :: Int -> Afspraak -> Agenda
08:07:47 <palomer> Cale: I'm writing a static analyzer, and when it fails it returns the portion of code at which it failed
08:08:03 <TuringTest> Phyx-: the error may be caused by bad code leading up to this function definition
08:08:19 <Cale> Phyx-: yeah, it's probably whatever came just before
08:08:36 <palomer> this is to catch errors in your own code
08:08:40 <palomer> right?
08:08:43 <TuringTest> palomer:  right
08:08:43 <Cale> Phyx-: given the typ sig you gave for Dup, you probably don't want that capital D
08:08:47 <palomer> so it's like a trace on speed
08:08:55 <palomer> in fact, this is so much better than trace
08:09:05 <Cale> Phyx-: capitalised identifiers are reserved for data constructors
08:09:28 <Cale> palomer: it's for debugging
08:09:30 <Phyx-> erm, one sec
08:09:43 <Phyx-> http://rafb.net/paste/results/q3Wg9f50.html
08:09:47 <Cale> palomer: you basically still have no guarantees as to when the messages will be printed
08:10:09 <Cale> Phyx-: right, you can't name it Dup, you could name it dup though
08:10:33 <Cale> (Dup has to be the name of a data constructor)
08:10:45 <palomer> is there a function MonadError e a -> Either e a ?
08:10:56 <ihope_> @index runError
08:10:57 <lambdabot> bzzt
08:11:01 <Phyx-> ok, renamed it
08:11:02 <Cale> palomer: nope, that can't exist
08:11:03 <Phyx-> let's see
08:11:12 <ihope_> @index MonadError
08:11:12 <lambdabot> Control.Monad.Error
08:11:21 <palomer> Cale: why not?
08:11:36 <Cale> palomer: IO is a MonadError, for example
08:11:45 <TuringTest> @type Control.Monad.Error.runErrorT
08:11:45 <lambdabot> forall a e (m :: * -> *).
08:11:45 <lambdabot>            Control.Monad.Error.ErrorT e m a -> m (Either e a)
08:11:47 <Phyx-> holy errors batman
08:11:56 <Phyx-> renamed it to lowercase
08:12:01 <Phyx-> and got ike 8 errors
08:12:07 <TuringTest> palomer: ErrorT to Either by using runErrorT
08:12:16 <Cale> yeah, it probably got to type checking :)
08:12:30 <Cale> and so you're getting a bunch of errors which it couldn't tell you before
08:12:33 <TuringTest> palomer: but not MonadError in general
08:12:43 <palomer> i think i'm very confused as to what MonadError is
08:12:49 <Phyx-> Cale: heheh
08:12:53 <palomer> to me, it represents computation that can fail
08:13:05 <TuringTest> palomer: do not confuse the type class MonadError with the instances.
08:13:17 <Phyx-> ahhh
08:13:17 <palomer> so ErrorT and MonadError  have less in common than one would think, right?
08:13:31 <Phyx-> ofcourse, [int] doesn't match int, forgot to get the element i want
08:13:31 <TuringTest> instance MonadError ErrorT 
08:13:36 <Cale> :)
08:13:39 <palomer> gah
08:13:44 <Phyx-> any easy way to get the nth element in a list?
08:13:45 * palomer goes nuts
08:13:50 <Cale> Phyx-: xs !! n
08:13:58 <palomer> ok, I'll ignore that MonadError exists and I'll stick with ErrorT
08:14:09 <Phyx-> > 5!![1,2,3,4,5,6,6]
08:14:10 <lambdabot> Couldn't match `Int' against `[a]'
08:14:13 <Phyx-> :O
08:14:23 <Cale> palomer: well, you'll still want to use the *operations* from MonadError
08:14:31 <TuringTest> > [1,2,3,4,5,6] !! 5
08:14:31 <Phyx-> > [1,2,3,4,5,6,6]!!5
08:14:32 <lambdabot> 6
08:14:33 <lambdabot> 6
08:14:40 <TuringTest> > [1] !! 0
08:14:41 <lambdabot> 1
08:14:44 <Phyx-> same time TuringTest :P
08:14:51 <palomer> oh, righto
08:14:54 <Phyx-> ok, makes life easier
08:14:56 * Phyx- tries
08:14:57 * palomer will masticate this over
08:15:08 <Cale> Phyx-: sorry, that involved metasyntactic variables :)  xs is plural, it's the list, n is usually a natural number :)
08:15:24 <Phyx-> yeah, i noticed :P i'm a noob :P
08:15:31 <TuringTest> Phyx-: Be warned : (!!) is a slow operation
08:15:40 <Cale> xs !! n takes O(n) time
08:15:47 <Phyx-> TuringTest: the list is on 4 long always
08:15:52 <Phyx-> it's not speed critical
08:16:02 <TuringTest> Phyx-: What about a tuple of 4 items
08:16:04 <TuringTest> ?
08:16:23 <Phyx-> well, it's a result of zipwith
08:16:33 <Phyx-> zipWith (-) (lta (snd a)) (lta (fst a))
08:16:33 <TuringTest> ah
08:16:36 <Cale> yeah, stick with the list here :)
08:16:45 <Phyx-> lta makes from a tuple a list
08:16:50 <Cale> lists are a lot more convenient than tuples for anything more than pairs.
08:16:56 <Phyx-> sinds i couldn't find a build in function :|
08:16:59 <Cale> (if they're suitable at all)
08:17:06 <Phyx-> can you directly subtract tupples?
08:17:17 <Phyx-> > (5,6) - (2,3)
08:17:18 <lambdabot>  add an instance declaration for (Num (a, b))
08:17:18 <lambdabot>   In the definition of `otb': otb = (5, 6) - (2, 3)
08:17:18 <lambdabot>   In the definition of `v': v = let otb = (5, 6) - (2, 3) in take 2048 (
08:17:18 <lambdabot> show otb)
08:17:22 <Phyx-> guess not
08:17:25 <Cale> no, not without writing an instance for Num
08:17:53 <Cale> instance (Num a, Num b) => Num (a,b) where
08:18:03 <Cale>    (a,b) + (c,d) = (a+b,c+d)
08:18:08 <Phyx-> lta is pretty simple, but it does what i want
08:18:08 <Cale>    ... etc ...
08:18:09 <Phyx-> lta (a,b,c,d,e) = [a,b,c,d,e]
08:18:16 <Phyx-> so i can do zipwith and subtract them
08:18:32 <TuringTest> it is slow, but it works.
08:18:37 <Cale> note that it enforces a pretty heavy type constraint on its input tuple
08:18:51 <Cale> namely, all the members will have to be the same type
08:18:53 <MarcWeber> Is there a shorter way for
08:18:53 <MarcWeber> a<- ...
08:18:53 <MarcWeber> case a of
08:18:53 <MarcWeber>   ....
08:19:10 <Cale> MarcWeber: not really
08:19:11 <Phyx-> yaymm 2 more errors only
08:19:21 <TuringTest> MarcWeber: We all wish there was a shorter way
08:19:25 <Cale> We do?
08:19:32 <TuringTest> Ok...not Cale
08:19:38 <Cale> Maybe it would be convenient occasionally, I guess.
08:19:39 <Phyx-> Cale: they are all Ints by definition of Tijdstip type 
08:19:43 <Cale> I'd never thought of that
08:19:46 <TuringTest> foo >>= case of
08:19:49 <TuringTest> could work
08:19:54 <TuringTest> if it was allowed....
08:20:08 <Cale> foo >>= \x -> case x of
08:20:29 <TuringTest> The idea is not to introduce the temporary name
08:20:39 <TuringTest> for brevity and clarity
08:21:12 <MarcWeber> Thanks
08:21:18 <TuringTest> If you introduce a name, then giving it a meaningful name is work and giving it "x" is obscure
08:21:28 <Cale> obscure?
08:21:36 <Cale> The only two uses of x are right there
08:21:45 <ihope_> \a b c d -> d a a (c d b) b
08:21:47 <TuringTest> Cale: I have to read the rest of your code to know that
08:21:59 <Cale> I suppose
08:22:02 <TuringTest> And if you always use "x" for this, then I have to be sure it is not the same "x"
08:22:17 <TuringTest> And if you gave it a fancy name, you had to do too much work
08:22:20 <Cale> well, no, if x is in scope, I wouldn't use it
08:22:25 <Cale> too much work?
08:22:29 <goron> TuringTest: Why not build a little extension for Haskell? That would be a nice project.
08:22:30 <TuringTest> heh
08:22:34 <Cale> How is coming up with a name work?
08:22:35 <TuringTest> goron: Nope
08:22:42 <Phyx-> ohh wow, i think i actually crashed the interpreter
08:22:47 <TuringTest> Well, it is not much work...
08:22:52 <goron> TuringTest: Why not?
08:22:53 <Cale> Phyx-: which interpreter?
08:22:58 <Phyx-> Cale: helium
08:23:00 <ihope_> Any idea why this network connection I'm doing with Haskell drops, while doing the same one by hand succeeds?
08:23:01 <Cale> Phyx-: ah
08:23:14 <palomer> lambdacase was proposed
08:23:26 <TuringTest> goron: I do not write languages.  A library, maybe, but not a language.
08:23:29 <palomer> for haskell', but rejected
08:23:36 <TuringTest> goron: (I am not religious)
08:23:44 <TuringTest> palomer: darn
08:23:51 <Phyx-> yay, 0 errors
08:23:54 <Phyx-> now to see if it works
08:23:55 <Phyx-> :|
08:24:04 <Phyx-> compiling is only have the battle :|
08:24:04 <TuringTest> Phyx-: If it compiles, it must work!
08:24:04 <goron> TuringTest: But what you are asking for can't be done in a library, right?
08:24:13 <Cale> Phyx-: in Haskell, it's most of the battle
08:24:15 <palomer> http://hackage.haskell.org/trac/haskell-prime/ticket/41
08:24:16 <TuringTest> goron: Haskell' rejected the idea
08:24:25 <palomer> actually, it's in the "maybe" section
08:24:27 <Cale> Phyx-: I'd say it's about 90% :)
08:24:30 <Lemmih> Proposing lambdacase for haskell' is pretty weird.
08:24:33 <TuringTest> ah maybe...there is hope
08:24:34 <Phyx-> Cale: unless the code is actually wrong, as in it compiles, but doesn't do what you wanted :P
08:24:41 <Cale> Phyx-: right
08:24:49 <MarcWeber> Thanks I'll try the "normal" case syntax and if it works I'll rewrite it using >>= \x case x of ...
08:25:04 <Phyx-> god damn, i still have 3 more assignments 2 go :|
08:25:08 <Phyx-> if this one works
08:25:09 <Cale> Phyx-: if you have the right algorithm, and it typechecks, the likelihood of bugs is pretty small
08:25:17 <goron> TuringTest: Haskell' is something which is "widely agreed upop". It doesn't mean that you can't extend Haskell and compile to Haskell?
08:25:35 <goron> TuringTest: And I don't see what religion has to do with it. 
08:25:48 <palomer> oh, and you'll have to liftM the lambdacase (I think)
08:25:57 <goron> TuringTest: Besides the fact that everyone is religious over it's own cool language.
08:25:57 <Phyx-> Cale: hahhaa, seems not small enough, hahaah, i'm laughing my ass off at my result
08:26:22 <Cale> Phyx-: what does your program do?
08:26:28 <TuringTest> tell jokes?
08:26:38 <goron> er its
08:26:39 <Phyx-> > (14,11,2005,0,0) !! 3
08:26:40 <lambdabot> Couldn't match `[a]' against `(a1, b, c, d, e)'
08:26:45 <Phyx-> oops
08:26:51 <TuringTest> 0
08:26:51 <MarcWeber> I have this line:
08:26:53 <MarcWeber> liftM (foldr1 combineModificationTimes) (sequence (map getModTime deps))
08:26:58 <Cale> > [14,11,2005,0,0] !! 3
08:26:59 <lambdabot> 0
08:27:01 <jethr0_> @pl (map snd *** map snd)
08:27:02 <lambdabot> map snd *** map snd
08:27:08 <TuringTest> MarcWeber: And?
08:27:11 <Phyx-> Cale: well, if given 2 dates, it's supposed to fill in till the second one
08:27:18 <Phyx-> ahh, it's 0 bound :|
08:27:31 <Cale> right
08:27:35 <mauke> 1-based indexing must die
08:27:39 <Phyx-> heheh
08:27:44 <TuringTest> > [1] !! 0
08:27:45 <lambdabot> 1
08:27:47 <Cale> eh, 1-based indexing is okay
08:27:54 <Phyx-> no wonder it over iterated
08:27:55 <MarcWeber> Wouldn't it be easier to introduce a foldr1M ? Then I could write foldr1M combineModificationTimes (map ...)
08:28:03 <Cale> Just so long as you know which one you're talking about :)
08:28:09 <mauke> how about a compromise? I propose 0.5
08:28:21 <jethr0_> Cale: it's only annoying if it keeps switching between languages. i'm alright with 0-based indexing. one-off errors will occur either way.
08:28:23 <Phyx-> alright, almost got it working
08:28:25 <Cale> I propose 27
08:28:27 <TuringTest> foldr1M f xs = liftM (foldr1 f) (sequence xs)
08:28:30 <Phyx-> but one prob
08:28:31 <palomer> I prefer 1 based indexing to 0 based indexing
08:28:32 <TuringTest> There, I defined it
08:28:33 <Lemmih> @index foldM
08:28:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
08:28:33 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
08:28:33 <lambdabot> Control.Monad.Error, Control.Monad.List
08:28:37 <Phyx-> i got to empty lists at the end
08:28:38 <Phyx-> :|
08:28:39 <Cale> 27-based indexing is the future
08:28:52 * jethr0_ 's all for prime number indexing
08:28:55 <TuringTest> Long Live Balanced Ternary!
08:28:58 <mauke> $[ = 27; # WE HAVE ARRIVED ONTO THE FUTURE
08:29:04 <mauke> sorry, perl only
08:29:09 <MarcWeber> TuringTest Thanks .. ;-) Isn't this used often?
08:29:15 <Phyx-> Cale: care to take a look? i need to remove the [],[] at the end
08:29:17 <Phyx-> lemme paste
08:29:18 <TuringTest> It may be in your code
08:29:19 <Cale> okay
08:29:28 <palomer> seriously, why should we start indexing at 0?
08:29:33 <Cale> Phyx-:  filter (not . null)  ?
08:29:42 <TuringTest> But there are very many one-liners that are not officially named / defined
08:30:06 <TuringTest> palomer: array index ranges that start at zero are faster in Haskell
08:30:09 <Phyx-> http://rafb.net/paste/results/8mSwG743.html
08:30:14 * ihope_ tries compiling this bot instead of interpreting it
08:30:26 <palomer> TuringTest: oh, that can be optimized out
08:30:50 <jethr0_> Cale: can you explain to me how this works:
08:30:53 <jethr0_> > (id >>= (+) >>= (+) >>= (+)) 3 
08:30:53 <lambdabot> 12
08:31:11 <mauke> a function monad?
08:31:24 <Cale> jethr0_: (+) adds the environment parameter (in this case 3) to its parameter
08:31:40 <Cale> id returns the environment
08:31:40 <TuringTest> I was arriving at the same conclusion...
08:32:06 <Cale> so that's ((3 + 3) + 3) + 3)
08:32:15 <TuringTest> How did he overload (+) ?
08:32:23 <Cale> it's not overloaded
08:32:28 <TuringTest> Ah..I get it
08:32:30 <mauke> @type id >>= (+)
08:32:31 <Cale> >>= is what's overloaded
08:32:31 <lambdabot> forall a. (Monad ((->) a), Num a) => a -> a
08:32:54 <Cale> > (id >>= (+)) 4
08:32:55 <lambdabot> 8
08:32:56 <Cale> > (id >>= (+)) 3
08:32:57 <lambdabot> 6
08:33:04 <Cale> > map (id >>= (+)) [1..10]
08:33:04 <lambdabot> [2,4,6,8,10,12,14,16,18,20]
08:33:20 <TuringTest> That is just wierd...
08:33:43 <Phyx-> Cale: filter (not.null) didn't work
08:33:47 <Phyx-> they are still there
08:33:52 <TuringTest> Where is Monad ((->) a) declared?
08:34:18 <ihope_> Control.Monad.Reader
08:34:28 <Cale> x >>= f = \v -> f (x v) v
08:34:31 <bd_> @hoogle (e -> r) >>= (r -> (e -> b))
08:34:31 <lambdabot> hoogle: Unexpected character when parsing: >>= (r -> (e -> b))
08:34:31 <lambdabot>  
08:34:38 <bd_> er, wait
08:34:46 <bd_> @hoogle (e -> r) -> (r -> (e -> b)) -> (e -> b)
08:34:47 <lambdabot> No matches, try a more general search
08:34:52 <ihope_> With GHC, how do I link two source files into an executable?
08:34:53 <Cale> Phyx-: oh, right
08:35:08 <Cale> Phyx-: that's because they're components of your 5-tuple
08:35:22 <Phyx-> bah.. didn't even notice that
08:35:23 <Phyx-> :|
08:35:24 <Lemmih> ihope_: ghc --make [mainmodule] -o exe
08:35:25 <Cale> the only way to get rid of them is to project down to 3-tuples like:
08:35:28 <Phyx-> i really am a noob :|
08:35:32 <Cale> (\(a,b,c,d,e) -> (a,b,c))
08:35:33 * Phyx- slaps himself
08:36:03 <Phyx-> well, works... now to only change the dates
08:36:09 <Phyx-> btw, anyway to do it all smaller?
08:36:14 <Phyx-> i used like 3 functions
08:36:29 <ihope_> Lemmih: thanks
08:36:45 <Cale> Well, look at perJaar
08:37:03 <Cale> it's applying fixAfspraak to each of the elements of its input list
08:37:05 <Cale> that's just map
08:37:16 <Cale> perJaar = map fixAfspraak
08:37:53 <mauke> I think I get it: apply is run, id is readState (which happens to duplicate the 3), and (+) combines them into a single result
08:37:59 <Phyx-> lemme try
08:38:12 <Cale> mauke: yeah, it's exactly like the reader monad
08:38:26 <Cale> I'm out for a little while
08:38:27 <TuringTest> Where return is the same as const
08:38:29 <Phyx-> ok, that made it smaller
08:38:30 <TuringTest> hsh
08:38:30 <Cale> be back in a bit
08:38:38 <Phyx-> now to update code
08:39:44 <palomer> seriously, ST rocks
08:39:46 <palomer> I use it for everything
08:40:13 <bd_> @djinn (e -> a) -> (a -> (e -> r)) -> e -> r
08:40:13 <lambdabot> f a b c = b (a c) c
08:42:42 <palomer> so the proper indentation for if is "if ... \n\tthen ...\n\telse ...", right?
08:43:04 <TuringTest> gcc 4.1.0 has been released !!!
08:43:25 <TuringTest> ?
08:43:44 <palomer> I just realized something
08:43:51 <TuringTest> Ooopps
08:44:03 <MarcWeber> palomer else one tab > compared to then where the then is doesn't matter
08:44:08 <palomer> I can apply runST whenever the return value isn't dependent on state!
08:44:27 <palomer> MarcWeber: pardon me?
08:44:55 <MarcWeber> \t\t\t\t if blah
08:44:55 <MarcWeber> then
08:44:55 <MarcWeber> \t else will work, too
08:45:29 <ihope_> Say... if I have a Handle for a network connection, is more than hPutStr required to send to it?
08:45:31 <Phyx-> ok, so you can get the nth element of a list using !! anyway to fo with with a tuple?
08:46:06 <ihope_> Well, I know there's fst and snd...
08:46:16 <Phyx-> it's a 3 tupple
08:46:19 <Phyx-> 4*
08:46:35 <ihope_> \(_,b,_,_) -> b
08:46:37 <Phyx-> if i keep going like this, i'll be spinning out helper functions all day :|
08:46:49 <palomer> MarcWeber: is that esthetically pleasing?
08:46:49 <ihope_> Well, that's a short one.
08:46:57 <ihope_> \(_,_,_,d) -> d
08:47:34 <Phyx-> i know how to do it that way, was just wondering if there was a build in function :P ohh well, was just being lazy i guess
08:48:29 <MarcWeber> palomer Sorry, it was even wrong.. *me hides*
08:50:00 <palomer> I've been putting state everywhere!
08:50:01 <palomer> oh deary my
08:50:40 <palomer> what's the difference between Int and Integer?
08:50:43 <LordL> ihope_ you might need to hFlush it too
08:50:53 <palomer> oh, ints are bounded!
08:50:56 <ihope_> Just what does that do?
08:50:56 <palomer> right?
08:51:06 <ihope_> Yep.
08:51:14 <ihope_> -65536 to 65535, I think.
08:51:23 <LordL> it flushes the send buffer..
08:51:29 <palomer> that's pretty small
08:51:31 <palomer> @hoogle !!
08:51:32 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
08:51:32 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
08:51:41 <palomer> so list lengths are also bounded
08:51:42 <palomer> that sucks
08:51:47 <ihope_> I don't think so.
08:51:57 <ihope_> Well, no. There are infinite lists in the world.
08:51:57 <palomer> well, accessible list lengths through !!
08:52:02 <TuringTest> from the gcc 4.1.0 changes "A new language front end for Objective-C++ has been added. This language allows users to mix the object oriented features of Objective-C with those of C++."
08:52:15 <palomer> TuringTest: sounds major
08:52:22 <TuringTest> major strange
08:52:30 <ihope_> If you want to directly access elements beyond 65535, you shouldn't be using lists.
08:52:49 <palomer> what if I don't care about performance?
08:52:54 <TuringTest> I bet it helps Apple bridge Obj-C and C++ code
08:53:10 <palomer> is there a version of !! that takes Integers?
08:53:11 <ihope_> Well...
08:53:12 <Lemmih> @type List.genericIndex
08:53:13 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
08:53:27 <TuringTest> @type genericLength
08:53:28 <MarcWeber> TuringTest What is Objective-C ?
08:53:28 <lambdabot> Not in scope: `genericLength'
08:53:41 <Lemmih> > genericIndex [1..10000000] 1000000
08:53:42 <lambdabot> 1000001
08:53:59 <TuringTest> MarcWeber: http://www.objc.info/about/
08:54:46 <int-e> hmm. Int have a range of at least -2^29+1 to 2^29-1 I think.
08:55:46 <dons> morning TuringTest
08:55:55 <TuringTest> dons: evening dons
08:56:25 <palomer> [1..2^^28] !! 1000000000000000000000000000
08:56:27 <palomer> > [1..2^^28] !! 1000000000000000000000000000
08:56:27 <lambdabot> Exception: Prelude.(!!): negative index
08:56:36 <palomer> hmm?
08:56:40 <TuringTest> dons: They did not like the "-package parsec" on the regex-dna.  I suggested "--make", but so far I have not heard back.
08:56:41 <ihope_> Heh.
08:56:42 <palomer> > [1..2^^28] !! 1000000000000000000
08:56:43 <lambdabot> Exception: Prelude.(!!): negative index
08:56:53 <ihope_> > [1..] !! 100000000000000000000000000000
08:56:54 <lambdabot> Exception: Prelude.(!!): negative index
08:56:56 <ihope_> > [1..] !! 1000000000000000000000000
08:56:57 <int-e> "The finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1]."
08:56:57 <lambdabot> Exception: Prelude.(!!): negative index
08:56:59 <ihope_> > [1..] !! 100000000000000000000000
08:57:00 <lambdabot> Exception: Prelude.(!!): negative index
08:57:04 <ihope_> Grr.
08:57:08 <ihope_> > [1..] !! 100000000000
08:57:12 <lambdabot> Terminated
08:57:33 <dons> hmm. I'm pretty sure musasabi hasset -package foo flags before.
08:57:45 <dons> probably they just don't want to hack the build system to support it.
08:57:51 <TuringTest> dons: Einar was the one complaining, I think
08:57:58 <TuringTest> dons: Yes, it is a build system issue
08:58:01 <dons> yeah, we've defniitely had -packatge mtl before
08:58:07 <dons> ok.
08:58:27 <TuringTest> musasabi: ping
08:58:28 <MarcWeber> TuringTest >>without any extra functional-programming baggage<< ;-) what are they refering to? I don't know smalltalk ( no answer needed)
08:58:49 <TuringTest> MarcWeber: I don't use Obj-C so I am not able to answer
08:58:59 <TuringTest> dons: gcc 4.1.0 is out
08:59:25 <TuringTest> (And it has a front end called "Objective-C++" which sounds weird)
08:59:34 <dons> huh.
09:01:56 <TuringTest> dons: What's new?
09:02:48 <dons> in general? i've got to get a paper written :) and some `official' projects need to get more work done on them. it's all a bunch of spinning plates
09:03:00 <Phyx-> damnit... this is all so confusing
09:03:50 <Phyx-> lol, o get something that compiles, but fucks the output :|
09:04:02 <Lemmih> dons: What about?
09:04:07 <TuringTest> dons: But do you have time to benchmark the regex-dna and write a sonnet?
09:04:24 <Phyx-> lol, o get something that compiles, but fucks the output :|
09:04:26 <Phyx-> oops
09:04:29 <Phyx-> sorry bout that
09:04:30 <dons> Lemmih, on extensible data types and plugins.
09:04:46 <dons> I'll try to write more sonnets, TuringTest :)
09:04:54 <dons> and did I forget to benchmark something?
09:05:41 <TuringTest> dons: "forget" may be too harsh.  But the CTK entry on http://haskell.org/hawiki/RegexDna#head-aff4aae171d0d3e35a4d2d102202004800e51658 is unbenchmarked
09:05:46 <dons> ah. ok.
09:05:58 <dons> fixing...
09:06:05 <TuringTest> (It is the one I submitted)
09:06:43 <TuringTest> :)
09:07:10 <dons> Lemmih, are you doing general ghc hacking now? I see a lot of interesting patches :)
09:07:41 <ihope_> data Virus = Very Yes
09:07:49 <sieni_> dons: you are so cute: http://leadership.wharton.upenn.edu/digest/Don%20Stewart033x5.jpg
09:10:56 <dons> hehe
09:12:59 <TuringTest> dons: I am out of Haskell programs to amuse myself with now that the shootout is complete.  Hmmm...I need a new project to play with...
09:13:24 <dons> here's a real picture: http://www.syntaxpolice.org/pics/estoniaBerlin/Estonia/13.html, that's ndm, dons and nibro. dons is in the middle.
09:14:13 <TuringTest> And nibro has a name tag.
09:14:33 <TuringTest> ICFP
09:16:10 <TuringTest> dons: I was measuring the CTK entry at 3x faster than the Parsec entry.  So my guess is 40s.
09:17:01 <Lemmih> dons: Yeah, kinda. I'm working on making the ghc-api more usable as a library.
09:18:42 <TuringTest> Lemmih: Have you tried writing a program that uses the ghc-api to compile the ghc codebase ?  We may get to the trusting-trust problem after a while...
09:19:02 <Phyx-> does visual ghc allow debugging?
09:19:34 <dons> TuringTest, a physics plugin for lambdabot, if you're looking for code to write? :) 
09:19:42 <TuringTest> heh
09:19:44 <TuringTest> maybe
09:20:21 <TuringTest> But the n-body debacle has turned me off from haskell numerics at the scale of simulations.
09:20:27 <ihope_> > 1024^2
09:20:29 <lambdabot> 1048576
09:20:46 <Lemmih> TuringTest: I have, actually. I wrote a dead code analyzer designed for GHC.
09:20:53 <Lemmih> TuringTest: trusting-trust problem?
09:21:19 <TuringTest> The C compiler that infects other code, including the c-compiler.
09:21:35 <TuringTest> In theory, of course.
09:21:53 <sjanssen> TuringTest: there was something on Lambda the Ultimate about that a while back
09:22:00 <ihope_> > Quality / quantity
09:22:01 <lambdabot>  Not in scope: `quantity'
09:22:02 <TuringTest> sjanssen: True.
09:23:16 <TuringTest> Maybe I could contribute to http://dis.um.es/~alberto/hmatrix/matrix.html
09:24:47 <TuringTest> I was using Mathematica today and wanted currying so much I wrote a curry / uncurry implementation for it.
09:24:58 <TuringTest> (Instead of getting the project done)
09:25:05 <jethr0_> way to go
09:25:11 <jethr0_> that's the spirit
09:25:11 <Phyx-> this valid?
09:25:12 <Phyx-> dup :: Int -> Afspraak -> Agenda
09:25:12 <Phyx-> dup -1 f = [f]
09:25:24 <jethr0_> Phyx-: you gotta put (-1) in parens
09:25:28 <Phyx-> ok
09:25:30 <Phyx-> thanx
09:25:34 <jethr0_> because of the stupid unary minus debacle
09:25:48 <TuringTest> @type (+ (-1))
09:25:49 <lambdabot> forall a. (Num a) => a -> a
09:25:53 <TuringTest> @(type subtract 1)
09:25:53 <lambdabot> parse error on input `)'
09:25:58 <Phyx-> cauze i got this before "heap overflow."
09:25:59 <Phyx-> :P
09:26:00 <TuringTest> @type (subtract 1)
09:26:01 <lambdabot> forall a. (Num a) => a -> a
09:26:14 <jethr0_> Phyx-: it compiled/ran before?
09:26:37 <Phyx-> think so, no errors
09:26:39 <ihope_> For all a, a = a, therefore a - a = 0. As well, a^2 = a^2, so a^2 - a^2 = 0, so a - a = a^2 - a^2. This means that (a - a) = (a - a)(a + a), so 1 = a + a.
09:26:51 <jethr0_> Phyx-: heap overflow usually means that you've got a run-away recursion, or are using up insanely much space
09:27:04 <ihope_> Dividing by two yields that for all a, a = 1/2.
09:27:23 <mauke> makes sense
09:27:49 <Phyx-> bah, this as a simple assignment and i make it difficult :|
09:28:01 <jethr0_> ihope_: you're missing a 2aa, no?
09:28:11 <mauke> there is an x with x = 0. dividing by x yields that 1 = 0.
09:28:31 <astrolabe> ihope you can't divide by (a-a) unless you know a-a /= 0
09:28:48 <jethr0_> pah, i'm too tired for this... good night
09:37:26 <Phyx-> wow, taking a shower game me a new idea
09:38:00 <ihope_> astrolabe: give me an a such that a-a /= 0
09:38:11 <dons> Phyx- that happens to me too. 
09:38:28 <dons> You think you're not thinking about the problem, but the brain just keeps ticking away.
09:38:40 <Phyx-> indeed
09:38:56 <Phyx-> if i'm right, i can scrape away 4 useless functions and make 1 small working one
09:40:06 <TuringTest> dons: thanks for the benchmark
09:40:11 <lennart> mmmmmmm, working functions :)
09:40:19 <TuringTest> lennart: ?
09:41:11 <Phyx-> what's an easier way to type this? i'm assuming the take is not needed? "take 3 (iterate id 5)"
09:41:30 <int-e> > replicate 3 5
09:41:31 <lambdabot> [5,5,5]
09:41:38 <Phyx-> ahhh
09:41:43 <int-e> > take 3 (repeat 5)
09:41:44 <lambdabot> [5,5,5]
09:41:45 <Phyx-> @type replicate
09:41:45 <lambdabot> forall a. Int -> a -> [a]
09:41:58 <Phyx-> good, i can use it
09:44:19 <dons> working functions are the best kind :)   
09:46:17 <dons> TuringTest, I was wondering, maybe you could hack on matrix library david roundy was working on (also a physicist, btw).
09:46:29 <ihope_> > cycle 
09:46:30 <lambdabot>  add an instance declaration for (Show ([a] -> [a]))
09:46:34 <ihope_> > cycle "awikipedi"
09:46:35 <lambdabot> "awikipediawikipediawikipediawikipediawikipediawikipediawikipediawikipediaw
09:46:35 <lambdabot> ikipediawikipediawikipediawikipediawikipediawikipediawikipediawikipediawiki
09:46:35 <lambdabot> pediawikipediawikipediawikipediawikipediawikipediawikipediawikipediawikiped
09:46:35 <lambdabot> iawikipediawikipediawikipediawikipediawikipediawikipediawikipediawikipediaw
09:46:35 <lambdabot> ikipediawikipediawikipediawikipediawikipediawikipediawikipediawikipediawiki
09:46:37 <lambdabot> [23 @more lines]
09:48:13 <TuringTest> dons: (searching mailing list folder) Roundy pointed out that atlas and fftw are the best performance, and did not mention a project of his own in that direction.
09:48:48 <dons> ah. ok. yes. fftw. that rings a bell.
09:51:03 <TuringTest> The trick is, like NumPy / SciPy, to wrap fast routines.  And provide visualization.
09:51:43 <TuringTest> I usually get my plots via GnuPlot.
09:52:08 <dons> me too :)
09:52:40 <TuringTest> Hmm...new version of SciPy on Feb 16th....hmmm....
09:53:25 <TuringTest> Hmmm...I'm way behind on scipy
09:55:26 <TuringTest> dons: So the CTK engine is twice as fast as Parsec.  That is worth the extra code.
09:55:39 <TuringTest> Did you see the Action1/Meta1 bug fix?
09:55:43 <ihope_> @md5 foobar
09:55:43 <lambdabot> Maybe you meant: id map msg
09:55:48 <ihope_> @help msg
09:55:49 <lambdabot> msg someone
09:55:53 <ihope_> @msg ihope bleh
09:55:54 <lambdabot> Not enough privileges
09:56:13 <int-e> ihope_: 3858f62230ac3c915f300c664312c63f ;)
09:57:44 <dons> TuringTest, is it? I guess 2x faster versus 2x longer. Te big points are in being the shortest, or fastest though., so until we're near that, it probably doen't matter too much either way.
09:57:48 <MarcWeber> Shit: main.exe: internal error: stg_ap_pp_ret                                             Please report this as a bug to glasgow-haskell-bugs@haskell.org,
09:58:01 <dons> is that an old ghc?
09:58:09 <MarcWeber> 6.4.1
09:58:29 <dons> hmm. better report a bug, and provide a test case
09:58:43 <dons> @poll-list all
09:58:43 <lambdabot> ["Which_Haskell_implementation_do_you_use?"]
09:58:50 <dons> @poll-show Which_Haskell_implementation_do_you_use?
09:58:50 <lambdabot> ["UHC","JHC","HBC","NHC","YHC","Hugs","GHC/GHCi"]
09:59:00 <MarcWeber> No, its even 6.4.2
09:59:00 <dons> @poll-result Which_Haskell_implementation_do_you_use?
09:59:00 <lambdabot> Poll results for Which_Haskell_implementation_do_you_use? (Open): UHC=0,
09:59:00 <lambdabot> JHC=0, HBC=0, NHC=1, YHC=0, Hugs=0, GHC/GHCi=3
09:59:10 <Lemmih> @vote GHC/GHCi
09:59:10 <lambdabot> usage: @vote <poll> <choice>
09:59:19 <Lemmih> @vote Which_Haskell_implementation_do_you_use? GHC/GHCi
09:59:20 <lambdabot> voted on "GHC/GHCi"
09:59:38 <MarcWeber> I'll remove all *.hi files and o files and I'll try again.. if it is still there I'll report a bug.
10:01:50 <MarcWeber> dons: Now it's gone
10:01:56 <ihope_> int-e: append hex 3858f62230ac3c915f300c664312c63f to the beginning of it. What do you get?
10:02:10 <MarcWeber> Now I get Prelude.head: empty list ;-)
10:04:14 <ihope_> Question: What is your name?
10:04:16 <ihope_> Answer: http://www.imdb.com/title/tt0460091/
10:07:23 <TuringTest> @vote Which_Haskell_implementation_do_you_use? GHC/GHCi
10:07:23 <lambdabot> voted on "GHC/GHCi"
10:07:29 * TuringTest wave good night
10:07:37 <TuringTest> waves good night
10:07:45 <Lemmih> g'night, TuringTest.
10:07:50 <dons> night
10:07:52 <dons>  too fast.
10:08:15 <Phyx-> god damnit... interpreter gave me a BSoS
10:08:18 <Phyx-> BSoD*
10:11:46 <Lemmih> oleg is so cool. I just saw his SXML stuff.
10:12:56 <ihope> ChatZilla's nice but PuTTYtel's reliable.
10:15:45 <ihope> Let's see here...
10:15:58 <ihope> Aha. 1 times 10 mod 7 is 3.
10:16:11 <ihope> 3 times 10 mod 7 is 2.
10:16:35 <Phyx-> bah, took me 4 hours to make a bloated function
10:16:49 <Phyx-> and 10mins to make a small efficient one that uses 1 function
10:16:56 <Phyx-> i hate myself....
10:17:17 <ihope> I hate you too.
10:17:36 <Phyx-> erm..
10:17:39 <ihope> Erm. You get the idea.
10:21:07 <dons> Lemmih, yeah, I like this SXML stuff too.
10:21:12 * Lemmih hugs Phyx-
10:21:22 <Lemmih> /I/ love you, though. (:
10:22:09 <Lemmih> dons: I hope it can replace my ugly xml+haskell parser in HASP.
10:22:23 <ihope> HASP>?
10:22:25 * Phyx- hugs Lemmih back and kicks ihope 
10:22:50 <Lemmih> ihope: <HASP>!</HASP>
10:23:30 <ihope> I don't get it.<HASP />
10:24:05 <Lemmih> ihope: It's a bit like PHP for Haskell.
10:28:54 <Phyx-> how do i strip off all but the head and tail of a list?
10:28:59 <Phyx-> i ned only what's between
10:29:12 <ihope> (init . tail)
10:29:26 <ihope> Or (tail . init)
10:30:19 <ihope> Depends on which error message you want when you strip [] and which you want for [x] ;-)
10:32:31 <Phyx-> hmmm
10:32:41 <Phyx-> let's see
10:33:04 <Phyx-> > (init.tail) (replicate 5 [1..2])
10:33:05 <lambdabot> [[1,2],[1,2],[1,2]]
10:33:16 <Phyx-> ok, cool, thanx
10:34:48 <ihope> > (init.tail) [1,2,3,4,5,6]
10:34:49 <lambdabot> [2,3,4,5]
10:35:44 <ihope> >(init.tail) []
10:35:55 <ihope> > (init.tail) []
10:35:56 <lambdabot> Add a type signature
10:40:46 <Phyx-> that might be a problem
10:41:22 <Phyx-> ahh wait, no, my list can never be empty
10:41:34 <ihope> I don't think that'll happen "in the wild".
10:44:19 <Phyx-> what does this mean?
10:44:20 <Phyx-> Warning: Missing pattern in function bindings: 
10:44:21 <Phyx->   fixes _ (_ : _) = ...
10:45:14 <Lemmih> It means that you haven't defined 'fixes' for non-empty lists.
10:45:42 <Phyx-> ohh yeah, i was getting 2 that, just wanted to see if it worked
10:46:04 <Phyx-> why can't it just say that? is it a rule for compilers to giv cryptic messages?
10:46:31 <ihope> Yes.
10:46:41 <Phyx-> :s
10:47:39 <Lemmih> Every 18 months, compilers will make their warnings and error messages twice as cryptic.
10:48:06 <ihope> Soon we'll be into the Error = Very Yes.
10:48:48 <ihope> Then it'll appear to work, but cleverly do the wrong thing.
10:48:48 <Phyx-> rofl
10:48:56 <ihope> head [] = []
10:49:06 <ihope> Stuff like that ;-)
10:49:29 <Saulzar> "Maybe there is an error involving types, between lines 10 and 22300"
10:50:56 <Phyx-> ok, if i don't get this assignment by 3 am, i'm shooting myself
10:50:59 <Saulzar> I suppose it is important to make the error seem specific as well, otherwise people can easily see it for what it is
10:51:04 <ihope> If not, then it's a data constructor out of scope on line -2.
10:52:12 <Phyx-> > 10%2
10:52:13 <lambdabot> 5%1
10:52:17 <Phyx-> wtf?
10:52:34 <Phyx-> >10 `mod` 2
10:52:41 <Phyx-> > 10 `mod` 2
10:52:41 <lambdabot> 0
10:52:54 <Lemmih> (%) /= mod.
10:53:07 <Phyx-> > 10 `mod` 3
10:53:08 <lambdabot> 1
10:53:20 <Phyx-> in most languages it is
10:53:24 <Phyx-> @type (%)
10:53:25 <lambdabot> Not in scope: `%'
10:53:37 <ihope> @index (%)
10:53:38 <lambdabot> Data.Ratio
10:53:51 <ihope> @type (Data.Ratio.%)
10:53:52 <lambdabot> forall a.
10:53:52 <lambdabot>       (Integral a) =>
10:53:52 <lambdabot>       a -> a -> GHC.Real.Ratio a
10:55:11 <Phyx-> hmm'
10:59:00 <Lemmih> > (\x -> x*x) 0.2
10:59:01 <lambdabot> 4.000000000000001e-2
10:59:09 <Lemmih> > (\x -> x*x) 0.2 :: Rational
10:59:10 <lambdabot> 1%25
11:03:30 <Phyx-> > init (reverse [1..5])
11:03:31 <lambdabot> [5,4,3,2]
11:03:41 <Phyx-> > head (reverse [1..5])
11:03:42 <lambdabot> 5
11:03:50 <Phyx-> init [1..5]
11:03:59 <Phyx-> > init [1..5]
11:04:00 <lambdabot> [1,2,3,4]
11:04:09 <Phyx-> hrm...
11:04:24 <ihope> ?
11:05:04 <Phyx-> just wanted to see what init does
11:06:03 <sjanssen> Phyx-: init returns each of the items in a list except for the last one
11:07:33 <Phyx-> yeah, i noticed ^_^
11:11:43 <Phyx-> now i wonder
11:11:51 <Phyx-> why the heck is it duplicating :S
11:12:36 <Phyx-> ahh
11:12:45 <Phyx-> because head always returns something
11:12:48 <Phyx-> head [1]
11:12:51 <Phyx-> > head [1]
11:12:52 <lambdabot> 1
11:13:16 <Phyx-> how can i make it give a [] back when the lenght is 1?
11:13:41 <ihope> You mean return [] for the empty list?
11:13:57 <Phyx-> the list isn't empty
11:14:04 <Phyx-> it only has one elem
11:14:10 <Phyx-> > tails
11:14:11 <lambdabot>  add an instance declaration for (Show ([a] -> [[a]]))
11:14:28 <ihope> The head of a list [x] is []?
11:14:28 <Phyx-> > tail [1[
11:14:29 <lambdabot>  parse error on input `}'
11:14:32 <Phyx-> > tail [1[]
11:14:33 <lambdabot>  parse error on input `}'
11:14:37 <Phyx-> > tail [1]
11:14:38 <lambdabot> []
11:14:53 <ihope> >init [1]
11:16:31 <palomer> http://www.rafb.net/paste/results/6HgQwH12.html <--anyone have any ideas?
11:18:42 <Phyx-> there, this did it (if (length y) > 1 then [head (reverse y)] else [])
11:33:08 <frederik> does haddock not work with template haskell?
11:38:45 <dcoutts> frederik, nope, it doesn't understand the syntax
11:39:22 <palomer> head (reverse y) == last y
11:39:27 <dcoutts> ghc should be taught about haddock markup and then haddock should be implemented on top of the ghc-api
11:49:05 <sokoot> is ord :: char -> int part of the prelude? (hugs)
11:50:01 <joelk> @index ord
11:50:02 <lambdabot> Data.Char
11:51:47 <sokoot> hmm ok, tnks
11:53:13 <dons> @remember Lemmih [Lemmih's Law] Every 18 months, compilers will make their warnings and error messages twice as cryptic
11:59:52 <MarcWeber> Anyone interested in my make system preview? http://www.rafb.net/paste/results/awt8Wo17.html feedback is welcomed.
12:01:47 <MarcWeber> actually making/ cleaning isn't implemented yet ;-) and the function deciding which rule to take if there are several possibilities has to be written yet.. I think it will sort the possiblilites by 1. dependencies are there to make target 2. levels (shorter nodes should be prefered) what do you think?
12:01:56 <Excedrin> what's the stuff around line 41, and is there a typo on line 46?
12:02:58 <MarcWeber> 41: The files beeing in the current diretory from where the main.exe was started.
12:03:30 <MarcWeber> 46 a notice. pay attention to the OutOfDate of UpToDate text below.
12:03:56 <palomer> MarcWeber: ooh, pretty
12:04:04 <araujo> Hello!
12:04:15 <MarcWeber> thanks to Data.Tree ;-)
12:04:54 <Excedrin> what does "older file a.c and newer file a.c" mean?
12:05:05 <MarcWeber> the most important difference to a traditional make will be that files are only "cleaned" if they can be remade..
12:05:16 <MarcWeber> Excedrin should be older than ;-) its late
12:06:04 <Excedrin> but there's two a.c files of different ages?
12:06:13 <MarcWeber> The idea is to add platform dependend rules instead of a lot of ${flags} stuff..
12:06:48 <MarcWeber> Once you've written one make program you can use it from within every directory. (like make implicit rules but better)
12:07:39 <MarcWeber> Where do you see them, Excedrin?
12:07:56 <Excedrin> line 46
12:08:22 <palomer> MarcWeber: this is for hmake, right?
12:08:26 <MarcWeber> that should be a note , no file listening
12:08:30 <MarcWeber> I don't know hmake
12:08:42 <MarcWeber> I wasn't able to download it.
12:09:27 <palomer> getKind x  = 
12:09:27 <palomer>     runSTI (do
12:09:27 <palomer>               x' <- normalize x
12:09:27 <palomer>               getKind_  x')<--ok, why doesn't this program type check?
12:10:46 <MarcWeber> theoretically it could even support two file targets "fileA" and (PatchedTarget  "fileA") .. ;-)
12:11:01 <palomer> http://www.rafb.net/paste/results/KofVH177.html <--this is the kind of error I get
12:11:24 <MarcWeber> palomer I don't know those functions..
12:11:32 <palomer> runSTI is like runST
12:11:46 <palomer> normalize returns a STI s (MonoSType s)
12:12:16 <palomer> and getKind_ returns an STI s Kind
12:13:20 * palomer pokes cale
12:13:21 <palomer> @seen cale
12:13:22 <lambdabot> cale is in #haskell. Last spoke 3 hours, 34 minutes and 42 seconds ago.
12:14:54 <MarcWeber> ;-) good night
12:15:47 <palomer> night
12:17:32 <palomer> @type Control.Monad.ST.runST
12:17:33 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:18:38 <palomer> darn you ST!
12:18:44 * palomer wonders if there's any way around this
12:19:14 * palomer pokes everyone in the channel
12:21:54 <palomer> hullo kingston!
12:28:24 <joelk> palomer, what's the type of getKind?
12:30:02 <palomer> joelk: MonoSType s -> Kind
12:32:07 <joelk> I would have expected MonoSType s -> STI s Kind
12:32:24 <palomer> wel, I'm running runSTI
12:35:59 <joelk> Sorry, I actually meant getKind_
12:36:10 <palomer> yeah
12:36:16 <palomer> MonoSType s -> STI s Kind
12:37:18 <joelk> I got similar errors when mixing Lazy and Strict ST for the first time. Had to get my s-es in order :-)
12:40:18 <joelk> so, normalize :: MonoSType s -> STI s (MonoSType s) ?
12:40:25 <palomer> yup
12:44:41 <joelk> in the error message, does "SType.hs:(140,4)-(142,26)" refer to the definition of runSTI.
12:45:01 <palomer> it's the same as runS
12:45:04 <palomer> runST
12:47:04 <palomer> ski!
12:47:06 <palomer> to the rescue
12:47:55 <palomer> ski: you around?
12:52:27 <palomer> ski_: hullo
12:59:49 <joelk> Is MonoSType s something like STI s TypeFoo?
13:00:52 <palomer> MonoSType may contains strefs
13:02:14 <palomer> think of it as MonosType s = STIref s (something else)
13:10:38 <sokoot> is there any hugs 2002 version rpm package for fc4
13:10:46 <joelk> OK, I think I understand. I think what you really want is normalize :: MonoSType s -> STI s (), which modifies the contents of the ref, whereas now you are returning a new state thread embedded in the old one.
13:10:55 <sokoot> ?
13:21:27 <palomer> joelk: if I remove the normalize from the code it still doesn't work
13:21:58 <palomer> and normalize can never have that type, unfortunetly
13:23:46 <palomer> (that would be too good)
13:34:55 <joelk> OK, memories of my times wrestling with ST are coming back. getKind :: MonoSType s -> Kind, is analgous to foo :: STRef s a -> a, which is exactly what ST is supposed to prevent.
13:37:15 <sjanssen> @index mplus
13:37:15 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
13:37:15 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
13:37:15 <lambdabot> Control.Monad.Error, Control.Monad.List
13:49:54 <palomer> joelk: why is it supposed to prevent that?
13:51:02 <joelk> For the same reason it prevents functions with type IORef a -> a
13:51:21 <palomer> what's wrong with that?
13:52:21 <palomer> http://www.rafb.net/paste/results/PSPxC483.html
13:54:27 <joelk> What's wrong with "unsafePerformIO . readIORef"?
13:54:48 <liyang> @hoogle (a -> [a]) -> [a] -> [[a]]
13:54:49 <lambdabot> No matches, try a more general search
13:55:21 <liyang> @djinn (a -> [a]) -> [a] -> [[a]]
13:55:22 <lambdabot> -- f cannot be realized.
13:55:25 <ncalexan> liyang: strange that hoogle doesn't find map.
13:55:26 <liyang> :(
13:55:47 <ncalexan> > map (:[]) [2,3]
13:55:48 <lambdabot> [[2],[3]]
13:55:55 <palomer> joelk: nothing, as far as I can see
13:56:17 <liyang> @type map (:[]) [2,3]
13:56:18 <lambdabot> forall a. (Num a) => [[a]]
13:56:19 <joelk> Well, only that it's unsafe
13:56:25 <liyang> @type map (:[]) 
13:56:26 <lambdabot> forall a. [a] -> [[a]]
13:56:42 <palomer> but how??
13:57:11 <ncalexan> How is it unsafe?
13:58:06 <palomer> yeah
13:58:08 <joelk> It's not a pure function
13:58:31 <palomer> ahh, good point
13:58:35 <palomer> referential transparency
13:58:37 <ncalexan> It depends on when it is reduced, because the IORef could be different at the times.
13:58:40 <palomer> now I get it
13:58:42 <ncalexan> s/the/those/
13:58:55 <palomer> it's all clear now
13:59:19 <joelk> And ST is for keeping operations within the state thread in order, just like IO is for RealWorld. As is my understanding.
13:59:21 <palomer> btw, given a string, how do I find the piece of text that lies between l1,c1 and l2,c2, where l1 and l2 are line numbers and c1 c2 are column numbers?
14:00:15 <palomer> "unsafePerformIO . readIORef" <--this is a valid function, no?
14:00:44 <ncalexan> palomer: lines will break text into a list of lines.
14:00:47 <ncalexan> Then you can index.
14:01:09 <ncalexan> Taking out the columns... that's just take (c2-c1) . drop c1
14:01:38 <mauke> @type \l1 l2 c1 c2 -> map (take (c2 - c1) . drop c1) . take (l2 - l1) . drop l1 . lines
14:01:39 <lambdabot> Int
14:01:39 <lambdabot>                              -> Int
14:01:39 <lambdabot>                              -> Int
14:01:39 <lambdabot>                              -> Int
14:01:39 <lambdabot>                              -> String
14:01:41 <lambdabot>                              -> [[Char]]
14:01:44 <palomer> > take 1 [1,2]
14:01:45 <lambdabot> [1]
14:02:02 <ncalexan> Hmm, my suggestion will not handle spans across lines.
14:02:16 <palomer> ncalexan: what do you mean?
14:02:20 <palomer> > take 5 [1,2]
14:02:21 <lambdabot> [1,2]
14:02:30 <ncalexan> Well, my take . drop needs everything on the same line.
14:02:49 <palomer> oh, then you just put a map
14:03:01 <ncalexan> Maybe lines . drop (l1-1) ...
14:03:17 <ncalexan> sorry, backwards composition there.
14:03:17 <joelk> Anyway, I'm off to lunch. See you around, palomer, everybody.
14:03:24 <palomer> joelk: cya!
14:03:44 <palomer> mauke: does that work?
14:03:53 <mauke> maybe
14:04:02 <mauke> I didn't test it
14:10:26 <palomer> how do I export everything in a module?
14:10:42 <ncalexan> Don't include a module Main (...) list .
14:10:47 <ncalexan> just module Main where
14:18:11 <palomer> whoa
14:18:23 <palomer> I switched ReaderT for ReaderErrorT
14:18:30 <palomer> and now I have an infinite loop
14:18:58 <palomer> http://www.rafb.net/paste/results/L17HeQ89.html
14:19:11 <palomer> something's fishy in denmark
14:19:21 <palomer> it's probably at the lift
14:21:36 <palomer> @logs
14:21:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:21:42 <ncalexan> Yes, it's at the lift.
14:21:42 <palomer> @log
14:21:42 <lambdabot> Maybe you meant: lam msg yow
14:21:50 <palomer> what should the lift be?
14:21:52 <ncalexan> You need to scrutinize your type.
14:21:59 <palomer> and how could that cause an infinite loop?
14:22:06 <ncalexan> Your def is equiv to lift x = lift x... that'll loop for sure :)
14:22:16 <palomer> ahh
14:22:23 <palomer> :>
14:22:28 <ncalexan> Try:
14:22:45 <ncalexan> lift (ReaderErrorT k) = ReaderErrorT $ lift k
14:22:54 <ncalexan> (untested)
14:23:28 <palomer> http://www.rafb.net/paste/results/1LoF8u74.html
14:24:06 <ncalexan> I'm thinking :)
14:24:14 <palomer> turingtest had posted working code before
14:24:17 <palomer> where are the logs?
14:24:34 <palomer> found'em
14:24:37 <dons> http://tunes.org/~nef/logs/haskell
14:24:39 <ncalexan> Ah... you need to guarantee that e is MonadTrans.
14:24:44 <dons> http://meme.b9.com/clog/haskell/
14:24:52 <palomer> e is an Error
14:25:59 <palomer> instance (Error e) =>  MonadTrans (ReaderErrorT r e) where lift = ReaderErrorT . lift . lift 
14:26:21 <ncalexan> Sorry, I was unwrapping your types, and thought e was ErrorT e m.
14:27:04 <palomer> np
14:27:37 <ncalexan> Oh, and I forgot that you don't need to scrutinize a ReaderErrorT.  Silly me.
14:28:19 <palomer> scrutinize?
14:28:37 <ncalexan> case or pattern match against.
14:32:43 <Cale> palomer: what's up?
14:34:31 <palomer> the fire's out
14:34:37 <palomer> I really, really wanted to do this:
14:35:04 <palomer> getKind x = runSTI (do{x' <- normalize x; getKind_ x'})
14:35:16 <palomer> and ditto for showMonoSType
14:35:35 <palomer> are there any ways around this?
14:39:52 <Cale> hm?
14:40:11 <Cale> around what?
14:41:35 <palomer> I'd like to write a function: MonoSType s -> Kind
14:41:45 <palomer> is this possible?
14:42:13 <Cale> well, (forall s. MonoSType s) -> Kind, for sure
14:44:23 <palomer> hmm
14:44:32 <palomer> and would the function I just wrote have that type?
14:44:57 <Cale> possibly, I don't know what normalize and getKind_ are, but yeah
14:45:26 <palomer> lemme check
14:45:43 <palomer> omg it works!
14:45:49 <palomer> but doesn't this break referential transparency?
14:46:52 <palomer> for example, if I create a STyvar and I pass it to getKind
14:47:05 <palomer> and if I create a STyvar, instantiate it, then pass it to getKind
14:47:08 <palomer> I'll get 2 different answers!
14:48:54 <palomer> ahh, I get type errors elsewhere
14:48:54 <Cale> the universal quantification there makes sure that no state leaks out
14:49:58 <palomer> but this means I can't do things like foo x = getKind x !!!
14:50:41 <palomer> or, rather, I have to annotate every function which uses getKind
14:51:11 <palomer> is this wise?
14:51:46 <Cale> hm?
14:52:13 <Cale> well, depends on what you want
14:53:26 <palomer> instantiateVar:: MonoSType s1 -> (forall s . MonoSType s) -> STI s () <--this refuses to type check
14:53:43 <palomer> http://www.rafb.net/paste/results/y2zgU033.html
14:55:09 <Cale> well, where are you going to get a MonoSType s1 from anyway?
14:55:49 <palomer> well, erm, this is the way it works
14:55:56 <palomer> my user inputs a source file
14:55:58 <palomer> which I parse
14:56:03 <palomer> then I do some static analysis
14:56:10 <palomer> including type inference
14:56:18 <palomer> so I'm going to be unifying MonoSTypes
14:57:41 <palomer> the monostypes are generated from the source code
14:57:57 <palomer> does this help?
14:58:38 <Cale> um
14:58:58 <Cale> hmm
14:59:16 <palomer> is it possible to make that function type check?
14:59:30 <Cale> maybe you meant  STI s1 () ?
15:01:49 <palomer> yeah
15:02:04 * palomer is having to annotate _every single function_!
15:02:10 <palomer> what if I had wanted to get kind of both arguments?
15:02:29 <palomer> (forall s1 . MonoSType s1) -> (forall s2 . MonoSType s2) -> STI s3 () ?
15:02:37 <Cale> why are you running these ST computations early?
15:03:03 <Cale> and why not get the kinds before passing them to the function
15:03:04 <Cale> ?
15:03:50 <palomer> I'm running the ST computations early?
15:03:54 <palomer> you mean getting the kinds?
15:03:58 <Cale> yeah
15:04:24 <Cale> getKind x = do{x' <- normalize x; getKind_ x'}
15:04:32 <palomer> yeah, I could do that
15:04:42 <palomer> but using functions that return monads is always a hassle
15:04:45 <palomer> for example, with show
15:05:11 <Cale> what about show?
15:05:23 <palomer> well, I'd need a function MonoSType s -> String
15:05:35 <palomer> or, in our case, (forall s . MonoSType s) -> String
15:06:01 <palomer> however, this function isn't useful because I won't be able to use it inside the monad!
15:06:04 <palomer> actually, lemme try
15:06:09 <Cale> why not MonoSType s -> ST s String ?
15:06:54 <palomer> because then it won't be an instance of Show
15:07:03 <palomer> I won't be able to use the built in type classes
15:07:06 <palomer> also, the syntax is uglier
15:07:16 <palomer> I can't do something like trace (show sometype)
15:09:19 <Cale> well, of course it's going to really be a computation which produces a string dependent on the state of the variables captured in the MonoSType s
15:09:25 <Cale> so it's not really the same thing at all
15:10:08 <Cale> if what you're printing isn't dependent on the s, then sure, you'll be able to write a Show instance just fine
15:10:13 <Cale> but it probably does
15:10:25 <palomer> yeah, big time
15:10:39 <palomer> only the normalizing though
15:10:44 <palomer> once it's normalized, it isn't
15:11:01 <palomer> or, rather, printing normalized terms isn't dependent
15:12:06 <Cale> oh, okay
15:12:48 <palomer> so I could use that as a show, I guess
15:13:12 <palomer> come to think of it, I could make getKind independent of s 
15:13:13 <Cale> then you could write something which just bottoms out or produces an error string if the thing isn't normalised, and make sure to enforce the invariant that it's normalised beforehand
15:13:32 <palomer> Cale: that would be _great_
15:13:43 <palomer> but, like, how would you do it?
15:14:25 <palomer> seeing if a term is normalized depends on s
15:15:10 <Cale> palomer: well, how do you show a normalised term?
15:15:16 <Cale> er
15:15:18 <Cale> type
15:16:02 <Cale> You ought to be able to do it without involving ST at all if what you said is true.
15:16:13 <palomer> Cale: I use the variable indexing of STI
15:16:41 <Cale> oh, but that's yet another kind of state which they depend on
15:16:58 <palomer> hmm?
15:17:04 <Cale> oh, I see
15:17:16 <Cale> yeah, STIRefs are showale
15:17:20 <palomer> exactly
15:17:21 <Cale> showable*
15:17:28 <Cale> so you can just print the thing regardless
15:17:37 <Cale> Perhaps even derive Show
15:17:39 <palomer> right
15:17:51 <palomer> however, if it's not normalized it'll print something totally wrong
15:18:16 <palomer> I mean, I could write a seperate NormalizedSType datatype
15:18:22 <palomer> but that seems like a waste of time
15:19:57 <palomer> and hide the NormalizedSType constructors
15:20:12 <palomer> in fact
15:20:35 <palomer> newtype NormalizedSType s= NormalizedSType (MonoSType s)
15:20:45 <Cale> sure
15:21:00 <palomer> but, erm, that makes things ugly
15:21:11 <palomer> since normalize returns a NormalizedSType
15:21:16 <palomer> I'll have to caste it all the time
15:21:19 <Cale> wait
15:21:33 <Cale> if a NormalisedSType no longer involves the state
15:22:01 <palomer> well, a normalizedSType can become un-normal
15:22:13 <palomer> as execution continues
15:22:44 <Cale> oh, then that won't do
15:23:42 <palomer> showSType x = do{b <- isNormal x; if b then showNormalized x else error "you can only show normalized types"} would be ideal
15:23:46 <palomer> but impossible
15:24:03 <palomer> or, rather, sticking a runSTI in front
15:25:18 <Cale> well, by putting a runSTI in front, you're starting and finishing a complete STI execution right there
15:25:27 <Cale> you won't be able to import state from elsewhere
15:25:37 <palomer> yeah
15:26:16 <Cale> so this 'x' probably can't really be used
15:26:49 <palomer> so I have to stick with what I have
15:32:50 <Cale> well, ST isn't as nice a language as Haskell, I know, but when you want to have arbitrarily many mutable cells, you have to give something up :)
15:33:37 <palomer> I was actually wondering about that
15:33:47 <palomer> maybe it's possible to make the ST syntax as nice as haskell's
15:34:38 <Cale> well, the thing is that in ST, the order of computations is critically important
15:35:15 <Cale> whereas in plain Haskell, it's largely unimportant
15:35:50 <Cale> so whatever you'd use, you'd hope that the syntax was different from plain Haskell
15:37:06 <palomer> well, erm, it would be assumed that computations would be strict and from left to write
15:41:19 <Cale> palomer: you'd still want it to look different and stand out, since that's exactly the opposite of everything else in the language
15:42:00 <palomer> or you could quarantine it
15:42:25 <palomer> a la strict haskell
16:14:11 <ncalexan> @type maybe
16:14:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:14:42 <ncalexan> maybe (const "test") Nothing
16:14:51 <ncalexan> > maybe (const "test") Nothing
16:14:52 <lambdabot> Couldn't match `Maybe a' against `t -> t1'
16:21:37 <pundai> "Write a datatype Quadruple which holds four elements. However, the
16:21:37 <pundai> rst two elements must be the same type and the last two elements must be the same
16:21:37 <pundai> type"
16:21:39 <pundai> how do i do that
16:22:02 <pundai> Quadruple (a :: Something...?
16:25:01 <ncalexan> data Quad a b = Quad a a b b
16:25:11 <ncalexan> or type Quad a b = (a, a, b, b)
16:44:52 <Cale> that seems to be a common exercise to get stuck on
16:48:28 <lispy> ah, but can you make the first and third the same type and the second and fourth the same?
16:48:52 <Cale> hehe
16:52:31 <lispy> data Banana a n = B a n a n a
16:52:39 <lispy> :)
16:53:14 <lispy> data Bana n a = B a n a n a
16:53:18 <lispy> that one is even better
16:57:07 <bomber098> is haskell purely acdemic with no practical
16:59:33 <eivuokko> No.  There is a lot of practical things you can do, and have been done using haskell.
16:59:36 <Muad_Dib> No
16:59:50 <Muad_Dib> Although haskell is mostly popular in academic world yet, it does have some uses :)
17:04:13 <Saulzar> More than some, there is very little you can't use it for...
17:04:21 <bomber098> ahhh
17:04:30 <bomber098> is there haskell webserver?
17:04:30 <Cale> Haskell is a nice general purpose programming language
17:04:41 <Cale> hmm, I think so
17:05:53 <Cale> at the very least, there are some nice server-side Haskell web scripting
17:05:58 <Cale> libraries :)
17:06:43 <Saulzar> There are a few I'm sure
17:07:06 <Cale> I think one of the Simons wrote a webserver in Haskell
17:07:55 <ncalexan> Yeah, for the concurrency primitives paper.
17:08:49 <Cale> http://www.haskell.org/~simonmar/papers/web-server.ps.gz
17:09:00 <Cale> a good example of being both academic and practical :)
17:11:46 <ncalexan> You understand Oleg's Zipper / Continuations examples?
17:12:24 <Cale> haven't looked at them
17:12:47 <ncalexan> deep magic.
17:17:15 <sieni_> almost everything oleg does is magic :-)
17:22:21 <bomber098> wow
17:22:30 <bomber098> so what lisp is haskell based on?
17:22:34 <bomber098> is it a form of scheme?
17:23:11 <eivuokko> Nope.
17:26:11 <sieni_> bomber098: well, it's based on scheme in the sense that scheme was the first language with proper closures, but e.g. syntax is completely different and Haskell is statically typed, the evaluation is lazy and the syntax supports currying easily
17:27:43 <bomber098> currying?
17:28:07 <sili> magic.
17:28:42 <sieni_> bomber098: it means that if you apply a function to less than the number of its arguments, it returns a function that computes the result if applied for the rest of the arguments
17:28:46 <sieni_> e.g.
17:29:15 <sieni_> > let f = ((\x y -> x + y) 7) in f 8
17:29:16 <lambdabot> 15
17:29:35 <sili> sieni_: you're scaring me
17:29:56 <Cale> > let f = (+ 2) in f 1
17:29:57 <lambdabot> 3
17:30:20 <sieni_> sili: how's that?
17:30:21 <sieni_> :-)
17:30:25 <Cale> (with a little more syntax sugar :)
17:30:51 <sieni_> bomber098: in scheme you would have to spank the lambda much more
17:30:56 <dblhelix> yeah, gimme some sugar :)
17:31:15 <sieni_> too much syntactic sugar cause cancer of the semicolon
17:31:16 <sili> you'd need lots of lambduhs
17:31:49 * dblhelix sees sieni_ spank lambdas and wonders what kind of club he just walked into
17:31:57 <bomber098> uh
17:31:58 <bomber098> hmm
17:32:09 <bomber098> maybe im not smart enuf for this
17:32:23 <sili> it just takes some time and practice
17:32:37 <sili> some programming background helps
17:33:10 <astrolabe> a self fulfilling prophesy.  They haven't said anything difficult, but it is unfamiliar.
17:34:01 <astrolabe> @type (+3)
17:34:02 <lambdabot> forall a. (Num a) => a -> a
17:34:04 <ncalexan> bomber098: there are some great haskell tutorials.
17:34:15 <sili> yet another haskell tutorial
17:34:19 <ncalexan> YAHT by Hal Daume is definitely popular.
17:34:23 <astrolabe> @eval (+3) 2
17:34:24 <lambdabot> 5
17:34:31 <dblhelix> sili: sometimes I doubt whether programming background helps... maybe Haskell is best learnt without programming experience and at age 12
17:34:33 <astrolabe> @learn
17:34:34 <lambdabot> http://www.haskell.org/learning.html
17:34:34 <ncalexan> A Gentle Intro to Haskell is what I learned from.
17:34:43 <ncalexan> That's the one :)
17:35:18 <sili> dblhelix: you think so? i think i'd be fucked if i didn't know other languages and have prior interest in languages like lisp
17:35:29 <sieni_> ncalexan: although the "gentle introduction" is the least gentle of the introductions that I have seen myself :-)
17:35:57 <ncalexan> Really?  Haven't read it in years, but I liked it at the time.
17:36:00 <dblhelix> sili: lisp... mmm maybe... but functional languages then... thinking imperatively can really ruin your whole learning experience
17:36:07 <astrolabe> Yeah, the gentle introduction is a gentle introduction to the report, not so much for beginners.
17:36:34 <sili> dblhelix: ya, i wish i had learned lisp as a first language
17:36:46 <ncalexan> sili: God, no way.
17:36:48 <sieni_> ncalexan: well I've liked reading it, but IMO it requires some background in functional programming
17:36:49 <dblhelix> sili: that's kind of my point
17:36:51 <ncalexan> Lisp teaches you the way of the devil.
17:36:52 <sili> ncalexan: yes way.
17:37:00 <sili> ncalexan: even scheme, i'd have settled for either.
17:37:07 * astrolabe read 'the little lisper'
17:37:08 <ncalexan> Scheme != Lisp.
17:37:14 <sili> ncalexan: i didn't say they were =
17:37:22 <sili> ncalexan: but there's obviously a lot in common.
17:37:24 <dblhelix> ncalexan: so you think the devil spends his day typing parentheses, huh? :)
17:37:25 <ncalexan> I read the little MLer... I hated that book.
17:37:35 <ncalexan> dblhelix: no, making me type them :)
17:37:41 <astrolabe> I loved it
17:37:42 <ncalexan> Maybe we should also point beginners to helium, which might make the process simpler.
17:38:17 <dblhelix> well, haskell was my first functional language... I've never regret that
17:38:30 <sieni_> ncalexan: yes, scheme is much nicer ^_^
17:38:34 <ncalexan> bomber098: helium is an interpreter that simplifies the learning process, by restricting a few types and having great error messages.
17:39:19 <dblhelix> admittedly, sometimes I have some difficulties keeping an open mind towards ML and Clean... but I think most of the time I do just fine
17:39:50 <ski> @where helium
17:39:50 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
17:39:57 <bomber098> hmm
17:39:58 <dblhelix> ncalexan: yeah, please do so... point them to helium
17:40:18 <bomber098> clisp claims it is most powerful language
17:40:27 <bomber098> why is haskell better?
17:40:35 <ncalexan> Maybe not better, but different.
17:40:36 <ski> better for what ?
17:40:39 <dblhelix> bomber098: for what definition of powerful?
17:40:47 <ncalexan> Language choice is pretty personal.
17:41:46 <sili> i should learn some ML
17:41:51 <dblhelix> @where+ helium http://www.cs.uu.nl/helium/
17:41:51 <lambdabot> Done.
17:41:58 <dblhelix> @where helium
17:41:58 <lambdabot> http://www.cs.uu.nl/helium/
17:42:16 <ncalexan> I never knew the where+ syntax.  That's neat.
17:42:21 <ncalexan> @where heliu
17:42:21 <lambdabot> I know nothing about heliu.
17:42:21 <dblhelix> (I like that URL better)
17:42:40 <ncalexan> Hmm... doesn't do partial matches, eh?
17:43:28 <ski> @wgere helium
17:43:28 <lambdabot> http://www.cs.uu.nl/helium/
17:44:46 <ski> bomber098 : haskell e.g. has static typing
17:55:44 <bomber098> whats good about static typing?
17:55:54 <bomber098> greenspun mentions it
17:56:16 <ski> catches errors earlier
17:56:37 <ski> often enables more efficient compiled code
17:56:44 <neologism> http://www.tiobe.com/index.htm?tiobe_index
17:57:11 <ski> and it can help with structuring and design of program
17:57:23 <ayrnieu> bomber - very little is good about it, without adding several other terms to the jargon soup.
17:58:22 <ayrnieu> bomber - such as 'strong typing' and 'type inference'.
17:58:36 <Cale> bomber098: static typing is basically the property that the compiler checks that certain things won't go wrong with your program, *at the time that it is compiled*
17:59:37 <ski> (ayrnieu : but usually we want 'strong typing' anyway, no ?)
17:59:39 <sieni_> bomber098: when a quality engineer comes to your office saying that the server you thought you fixed spits out a stack trace saying approximately that "you can't take 'cadar' of this", then you just beg that you could do your programming in ML or Haskell instead of Scheme
17:59:41 <ayrnieu> bearing in mind that a description that broad includes systems that nobody would comfortably describe as having 'static typing'.
18:00:42 <ayrnieu> sieni - that's perfect :-)
18:02:44 <ncalexan> sieni: that's a bad example... you can't take head [].
18:03:32 <bomber098> relly?
18:03:33 <ncalexan> (Though I know you were thinking of head False.)
18:03:42 <bomber098> paul graham says ML never lived up to epectations
18:03:49 <bomber098> wow
18:04:11 <ncalexan> bomber098: Haskell, as much as possible, tries to prevent you from shooting yourself in the foot.  Most of that happens at compile time.
18:04:13 <bomber098> can u build up daatbase like abstractions 
18:04:17 <bomber098> in haskell
18:04:23 <bomber098> oh
18:04:28 <bomber098> so haskell isncompiled liek c
18:04:33 <bomber098> compiled liek C
18:04:35 <bomber098> like
18:04:37 <bomber098> wow
18:04:41 <ncalexan> It can be compiled and interpreted.
18:04:42 <bomber098> so why not use c?
18:04:48 <bomber098> is c a pain?
18:05:02 <ncalexan> More of a pain than Haskell, I would say.  At least for my brain.
18:07:35 <ski> @where haskelldb
18:07:36 <lambdabot> http://haskelldb.sourceforge.net/
18:11:20 <bomber098> woa
18:11:44 <bomber098> so haskell may make me more productive than perl squeak ruby clisp scheme or java?
18:13:01 <wli> you never know
18:13:07 <ncalexan> Maybe, but I really wouldn't expect that.  I think any of those other languages _could_ make you more productive than any of the other.
18:13:28 <ncalexan> I would suggest it's about matching your mind to the language that lets you express your ideas 'best'.
18:13:51 <ncalexan> I have a friend who thinks great things in C.  I can't think of anything in C, I get lost in the details.
18:17:58 <EtnaRosso> morning all
18:18:19 <EtnaRosso> I would like to know something about monads, does anyone can help me=
18:18:20 <EtnaRosso> ?
18:18:31 <ncalexan> @where monad tutorial
18:18:32 <lambdabot> I know nothing about monad.
18:18:36 <ncalexan> @where nomaware
18:18:36 <lambdabot> I know nothing about nomaware.
18:18:57 <ncalexan> http://www.nomaware.com/monads/html/
18:19:00 <EtnaRosso> thanks
18:19:12 <EtnaRosso> for example i'm using the ghc suite
18:19:20 <ncalexan> Wadler's How to Declare an Imperative is a more technical starting point, but still very readable.
18:19:23 <EtnaRosso> can i see the sources of the list monad?
18:19:54 <ncalexan> http://www.nomaware.com/monads/html/meet.html#list
18:19:59 <ncalexan> That actually tells you how to make list a monad.
18:20:13 <ncalexan> Best to read up to that point sequentially, I think.
18:20:43 <ncalexan> But the instance Monad [a] ... declaration should be in the prelude, which is available in the report.
18:21:04 <ncalexan> Now, I must sleep.  Cheers, everyone!
18:21:05 <Cale> EtnaRosso: or read my tutorial :)
18:21:06 <EtnaRosso> mhm good suggestion
18:21:18 <ncalexan> Argh!  Sorry, I dropped the ball on that one, Cale.
18:21:19 <Cale> (well, preferably, read both :)
18:21:19 <EtnaRosso> thanks ncalexan 
18:21:32 <Cale> @oldwiki MonadsAsContainers
18:21:32 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
18:21:33 <EtnaRosso> Cale your tutorial?
18:21:35 <Cale> there :)
18:21:41 <ncalexan> Cale's intro is great, easiest to comprehend (hehe) in my mind.
18:21:56 <ncalexan> And of course, you can always ask the master himself with Cale's tutorial :)
18:21:58 <ncalexan> g'night all.
18:21:59 <EtnaRosso> Cale can i ask some question to you here?
18:22:03 <Cale> sure
18:23:24 <EtnaRosso> monads is good for rule based processing?
18:23:37 <Cale> hmm
18:23:41 <Cale> rule-based?
18:24:05 <EtnaRosso> for example if happens something then do something else
18:24:38 <EtnaRosso> i think i need to read both tutorial and then come back here
18:24:44 <Cale> the list monad is good for nondeterministic calculations, where you have a bunch of options to choose at each stage, and you're searching for something
18:25:03 <Cale> yeah, read my tutorial, and the nomaware one is good too
18:48:58 <EtnaRosso> in the statement "(Just x) >>= f = f x" f is a generic function, or i should/may use a specific one?
18:49:39 <ski> 'f' is an argument
18:49:49 <ski> what do you mean by 'generic function' ?
18:50:35 <EtnaRosso> unspecified in the monad instance definition
18:50:47 <ski> then yes
18:50:58 <ski> it is specified when '(>>=)' is called
18:51:42 <ski> > Just 5 >>= (\x -> lookup x [(3,"three"),(5,"five")])
18:51:42 <lambdabot> Just "five"
18:51:47 <ski> > Just 4 >>= (\x -> lookup x [(3,"three"),(5,"five")])
18:51:48 <lambdabot> Nothing
18:51:53 <ski> > Nothing >>= (\x -> lookup x [(3,"three"),(5,"five")])
18:51:53 <lambdabot> Nothing
18:51:59 <Bobl> does anyone have a nice example for reading a file in with a sequence of integer (a board), i'm rather new at haskell but not with functional programming...
18:52:47 <ski> what format in the file ?
18:53:40 <Bobl> ski, just ascii
18:53:58 <ski> yea, but what format are the integers given in ?
18:54:20 <ski> (i assume they represent a 2-dim board, so it's a sequence of sequences of integers, yes ?)
18:54:22 <Bobl> ski, 8 integers on a line separated by space, and a multiple of 7 lines.
18:54:59 <ski> if it's just something that simple, you could use 'lines' and 'words'
18:55:23 <ski> > lines "1 2 3\n 4 5 6\n 7 8 9\n"
18:55:24 <lambdabot> ["1 2 3"," 4 5 6"," 7 8 9"]
18:55:39 <ski> > map words . lines $ "1 2 3\n 4 5 6\n 7 8 9\n"
18:55:39 <lambdabot> [["1","2","3"],["4","5","6"],["7","8","9"]]
18:55:53 <ski> > map (read . words) . lines $ "1 2 3\n 4 5 6\n 7 8 9\n" :: [[Int]]
18:55:53 <lambdabot> Couldn't match `Char' against `String'
18:56:02 <ski> > map (map read . words) . lines $ "1 2 3\n 4 5 6\n 7 8 9\n" :: [[Int]]
18:56:03 <lambdabot> [[1,2,3],[4,5,6],[7,8,9]]
18:56:25 <ski> and, of course, use 'readFile' to get the file as a string
18:56:28 <ski> @type readFile
18:56:29 <lambdabot> FilePath -> IO String
18:56:40 <Bobl> ski, but of course ;).
18:56:42 <ski> Bobl : would that work for your purposes ?
18:57:06 <Bobl> ski, yes, probably, i need to get the hang of the notations though,
18:58:01 <ski> (you can of course name more intermediate results than i did above, if you think readability increases)
18:58:24 <Bobl> ski, nahh, I just am so not into it yet, first day of haskell, approx 10 am.
18:58:45 <ski> ('approx 10 am' means ?)
18:59:26 <Excedrin> 10:12 AM ?
18:59:27 <Bobl> ski, the time, 10:00.
18:59:50 <ski> you mean you started with haskell then ?
19:00:43 <Bobl> ski, no i started at 9:00.
19:01:11 <Bobl> ski, so i am a haskell virgin except for the last hour.
19:01:17 <ski> ok
19:01:38 <ski> (and i think the usual term is 'newbie' :)
19:02:36 <ayrnieu> ski - this depends on your mental model of haskell.
19:02:55 <ski> Bobl : out of curiosity, which functional languages have you seen before ?
19:03:02 <Bobl> ski, newbie is sooooo 2005.
19:03:03 <ski> ayrnieu : hm ?
19:03:33 * ski never understood the 'is sooooo' remarks
19:03:36 <ayrnieu> of the haskell experience, perhaps.  Are we all in a big class, segregated by experience, gaining esteem as we gain in person, and constantly seeing an influx of dubiously experienced new people?  Or are we getting screwed in the head?
19:03:36 <Bobl> ski, amanda (sort of miranda for windows) but id like to try a more serious language such as haskell.
19:03:58 <Cale> Usually, being a virgin "except for the last hour", means that you're not anymore. :)
19:04:19 <ayrnieu> One of these possibilities makes 'virgin' more sensical, and the other makes 'newbie' more sensical.
19:04:34 * Bobl loves useless discussions.
19:05:31 <ayrnieu> if they move you towards love, and you regard them as useless, do you hold your love worthless?
19:06:06 * ski has no idea what ayrnieu is talking about
19:06:26 <ayrnieu> something bobl said, ski.
19:06:38 <ski> Bobl : ok .. haskell was invented to replace miranda, more or less
19:07:05 <ski> morning, Buggaboo
19:07:13 <Bobl> ski, which is why im here.
19:07:48 <Buggaboo> hey ski
19:07:50 <Buggaboo> how are ye?
19:08:06 * ski is fine
19:10:13 <Bobl> noobie alert: what does the $ do?
19:10:22 <araujo> Hellu.
19:10:25 <ski> f $ x = f x
19:10:59 <Bobl> ski, function application?
19:11:05 <Cale> yep
19:11:06 <ulfdoz> hrhr, from the definition, the real benefit of the operator can't be seen, imho.
19:11:11 <ski> Bobl : 'map (map read . words) . lines $ "1 2 3\n 4 5 6\n 7 8 9\n"' is the same as '(map (map read . words) . lines) $ "1 2 3\n 4 5 6\n 7 8 9\n"' which is the same as '(map (map read . words) . lines) "1 2 3\n 4 5 6\n 7 8 9\n"'
19:11:53 <ski> Bobl : it's function application as a (right associative) infix operator, with low precedence
19:11:54 <Cale> $ binds really loosely, whereas function application normally binds tighter than anything else
19:12:07 <ski> it helps avoid write some parens
19:12:12 <ulfdoz> Bobl: basically you can change associativity with it from foo $ bar a b = foo (bar a b).
19:12:22 <Bobl> ski, ah i see, i love haskell already ;)
19:12:37 <ski> :)
19:13:26 <Bobl> ski, and the point is to seperate arguments?
19:13:38 * Bobl should look in his book, really.
19:13:45 <Cale> to separate a function from its argument
19:14:02 <Cale> esp. when the function is a composition
19:15:07 <ski> foo a b $ (bar x $ baz y z) c $ quux $ frob d e
19:15:09 <ski> is the same as
19:15:30 <ski> foo a b (bar x (baz y z) c (quux (frob d e)))
19:16:13 <Bobl> ski, the book says '.' is function composition.
19:16:19 <ski> right
19:17:00 * ski realizes Bobl might have meant the '(.)' operator by 'point'
19:17:00 <nothingmuch> i have a dumb question
19:17:05 <nothingmuch> i just read the first SYB article
19:17:26 <nothingmuch> everyone has been telling me that SYB encompasses most of what attribute grammars can give you
19:17:42 <nothingmuch> but as I understood they are completely orthogonal
19:18:05 <nothingmuch> am I missing something?
19:19:00 <ski> never heard anything about they solving similar things as attribute grammars
19:19:28 <nothingmuch> *phew*
19:19:38 <nothingmuch> that means I'm potentially not an idiot =)
19:20:00 <ski> (not that i have really looked much on SYB .. :)
19:20:22 <nothingmuch> SYB is fudging rank 2 polymorphism in order to give you map/fold over any structure
19:20:43 <nothingmuch> basically you have a generic function
19:20:58 <nothingmuch> that takes something that transforms one type of node
19:21:17 <nothingmuch> and it returns a thing that transforms any type of node using the cast operator thingy
19:21:50 <ski> what is a 'node' ?
19:21:50 <nothingmuch> and then there are some traversal functions that let you fudge a deep data type without needing to declare too much boilerplate code
19:21:59 <nothingmuch> any tagged union type
19:22:09 <nothingmuch> (i think)
19:22:21 * nothingmuch is not very in touch with the terms of the haskell world
19:22:32 <nothingmuch> now... is that interpretation what you also got?
19:23:05 <ski> something like that (i said i haven't looked much)
19:23:42 <ski> @where SYB
19:23:42 <lambdabot> I know nothing about syb.
19:24:09 <Bobl> is there a function to convert IO String to a normal string?
19:25:23 <sieni_> Bobl: no, and for good reason
19:25:32 <neologism> you cannot escape a monad
19:25:54 * Bobl needs a little more to hang on to.
19:26:02 <ski> @oldwiki ThatAnnoyingIoType
19:26:02 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
19:26:11 <ski> Bobl : see that
19:26:17 <Bobl> thank you
19:26:46 <nothingmuch> Bobl: ofcourse, once you get to haskell level mse we'll tell you how to cheat
19:27:34 <nothingmuch> but first you need to explain why the name of that secret function starts with 'unsafe'
19:27:37 <nothingmuch> ;-)
19:29:03 <Cale> also, see http://www.haskell.org/hawiki/IntroductionToIO
19:29:50 <Cale> which is intended to be a brief overview of how IO works in Haskell
19:31:35 <neologism> will "[x] ++ xs" optimalized to (x:xs) ?
19:31:59 <ski> possibly
19:32:01 <Cale> neologism: possibly, but I wouldn't count on it
19:32:07 <EtnaRosso> Cale i have defined a new type using data
19:32:09 <neologism> hm...
19:32:17 <EtnaRosso> how can i made it "printable"?
19:32:23 <Akamatsu> :O GVIM is nice
19:32:34 <ski> EtnaRosso : try adding 'deriving Show' after the type definition
19:32:39 <Cale> EtnaRosso: add  'deriving (Show)' to the end of the data declaration
19:32:42 <Cale> yeah
19:33:23 <EtnaRosso> yes but i think i need to define how it will be shown
19:33:42 <Cale> oh
19:33:42 <Cale> okay
19:33:49 <ski> 'deriving' can define that for you, for many datatypes
19:33:50 <EtnaRosso> deriving Show is something similar to class extension?
19:33:52 <Cale> then you have to write an instance of Show
19:34:02 <Cale> class extension?
19:34:07 <neologism> EtnaRosso: its a type class
19:34:22 <Cale> It just writes some boilerplate code for you based on the structure of your type
19:34:34 <Cale> If you need more control, then you write something like:
19:34:40 <Cale> instance Show MyType where
19:34:44 <Cale>     show x = ...
19:34:56 <EtnaRosso> good
19:41:58 <EtnaRosso> ouch! parse error ... where i can paste it to show you my code=
19:41:59 <EtnaRosso> ?
19:42:32 <Cale> lisppaste2: url
19:42:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:43:32 <lisppaste2> EtnaRosso pasted "parse error on instance" at http://paste.lisp.org/display/17404
19:44:13 <Cale> instance Show Event where
19:44:18 <Cale>    show e = "Send"
19:45:07 <ski> so you forgot the 'where'
19:45:08 <Cale> (the 'where' is missing)
19:45:31 <EtnaRosso> ah sorry
19:45:42 <ski> (and the parens in 'main' in call to 'print' is not needed)
19:59:55 <Bobl> if i have a [String] how can i concatenate all elements so i have a String in the end. I guess map (++) [Stringthingy] wont work.
20:00:15 <joelk> @type concat
20:00:16 <lambdabot> forall a. [[a]] -> [a]
20:00:29 <ski> > concat ["foo ","bar ","baz"]
20:00:30 <lambdabot> "foo bar baz"
20:00:41 <ski> > foldr (++) "" ["foo ","bar ","baz"]
20:00:42 <lambdabot> "foo bar baz"
20:00:43 <Bobl> ah there is a concat function!
20:01:26 * Bobl begins to remember his functional programming lectures.
20:01:34 <ski> > concat . intersperse " " $ ["foo","bar","baz"]
20:01:35 <lambdabot> "foo bar baz"
20:01:55 <ski> (or)
20:02:03 <ski> > concat $ intersperse " " ["foo","bar","baz"]
20:02:03 <lambdabot> "foo bar baz"
20:02:19 <Bobl> ski, you are like the haskell-god, aren't you?
20:02:34 <ski> no
20:02:36 <sieni_> no, spj is teh haskell god
20:07:27 <tromp_> i thought oleg was
20:08:14 <Saulzar> I imagine there are more than 2 people who are fairly clued up :)
20:22:57 <Bobl> what is an ambiguous type a? i dont use any types a
20:27:44 <boegel> Bobl: they don't give you the actual name of the type, because it can't be inferred...
20:28:14 <Bobl> boegel, i see, i get another error now, thanks.
20:28:25 <boegel> np
21:05:43 <pvgorp> hi, we don't understand why the following function definition is invalid: 
21:05:44 <pvgorp> strangeAdd:: (Int->Int)->Int 
21:05:44 <pvgorp> strangeAdd x y= x y
21:06:13 <ntgrl> @type \x y -> x y
21:06:14 <lambdabot> forall t t1. (t -> t1) -> t -> t1
21:06:18 <ntgrl> pvgorp: try adding a space before the =
21:06:26 <ntgrl> pvgorp: also fix the type ;-)
21:06:34 <pvgorp> we're experimenting with reverse bracket precedence by the way
21:06:44 <pvgorp> that's why the type is so odd
21:06:48 <ntgrl> @type \x (y :: Int) -> x y :: Int
21:06:49 <lambdabot> Int :: (Int -> Int) -> Int -> Int
21:07:00 <ntgrl> pvgorp: umm?  the type is still lacking a bit...
21:07:52 <pvgorp> why?  we'd like to pass a function that adds a constant as the first parameter and then apply it to the second Int parameter
21:10:41 <ntgrl> pvgorp: yes, and the return type?
21:11:02 <pvgorp> hmmm... good point... stupid mistake, thanks
21:12:42 <gour> pvgorp: you mean something like strangeAdd x y= x  + y ?
21:13:37 <pvgorp> no, strangeAdd x y = x y, where x is a function Int->Int
21:14:04 <pvgorp> point is, we were looking at the right associativity of type declarations
21:14:18 <pvgorp> we were trying to see what happens when we would make it left associative
21:14:22 <Akamatsu> @type take
21:14:24 <lambdabot> forall a. Int -> [a] -> [a]
21:14:39 <ski> strangeAdd :: (Int -> Int) -> (Int -> Int)
21:14:41 <ski> or
21:14:41 <pvgorp> apparently, you need to add extra parameters for intermediate results in that case
21:14:44 <ski> strangeAdd :: (Int -> Int) -> Int -> Int
21:14:45 <ntgrl> but that's got nothing to do with your problem, which is just not understanding how (->) :: * -> * -> * works
21:15:24 <pvgorp> ntgrl, you mean (->) is part of prelude?
21:15:27 <ski> foo :: (Int -> Int) -> Int
21:15:30 <ski> foo x = x 0
21:15:49 <pvgorp> ski, that's erroneous, no?
21:15:56 <pvgorp> ah no, sorry\
21:15:57 <ski> no
21:15:59 <pvgorp> that's correct
21:16:04 <ntgrl> @king (->)
21:16:05 <lambdabot> ?? -> ? -> *
21:16:07 <ntgrl> @kind (->)
21:16:07 <lambdabot> ?? -> ? -> *
21:16:12 <ski> :)
21:16:19 <Akamatsu> >  Maybe Intt
21:16:19 <lambdabot>  Not in scope: data constructor `Intt'
21:16:21 <Akamatsu> >  Maybe Int
21:16:21 * ntgrl throws lambdabot a cookie
21:16:21 <lambdabot>  Not in scope: data constructor `Int'
21:16:23 <Akamatsu> hehe
21:16:26 <Akamatsu> >  Maybe
21:16:26 <lambdabot>  Not in scope: data constructor `Maybe'
21:16:29 <Akamatsu> :|
21:16:35 <ski> @kind Maybe Int
21:16:36 <lambdabot> *
21:16:38 <ski> @kind Maybe
21:16:38 <lambdabot> * -> *
21:16:53 * Akamatsu scratches head even more
21:16:55 * gour sees that strangeAdd is really strange :-)
21:17:16 <ski> a type 'TypeA -> (TypeB -> Type)' can be written 'TypeA -> TypeB -> TypeC', because the infix type constructor '(->)' is right associative
21:17:49 <ski> '(TypeA -> TypeB) -> TypeC' is of course another type
21:18:20 <ski> pvgorp : is this what you meant by 'we were trying to see what happens when we would make it left associative' ?
21:18:21 * pvgorp nods
21:18:44 <pvgorp> ski, yes, but making it left associative doesn't seem to be trivial
21:18:56 <ski> (s/Type)/TypeC)/)
21:19:17 <ski> you don't "make it left-associatively"
21:19:19 <pvgorp> because (TypeA -> TypeB) -> TypeC doesn't take 2 parameters anymore
21:19:32 <ski> you can use it in a left-associative way
21:19:34 <pvgorp> while TypeA -> (TypeB -> Type) does\
21:19:40 <pvgorp> ski, how?
21:19:55 <ski> former is a function that takes a function as argument
21:20:05 <ski> latter is a function that returns a function as result
21:20:16 <ski> strictly speaking, neither takes 2 parameters
21:20:28 <pvgorp> ok, but the latter takes the second prameter in the next step
21:20:30 <ntgrl> umm, since both of those have explict (), it's the same no matter what your disambiguation rule is
21:20:34 <pvgorp> while there is no second step in the first case
21:21:32 <pvgorp> basically because the strangeAdd takes a function as an argument and doesn't actually ADD two integers, it just delegates the implementation of ADD
21:21:48 <ski> that the infix type constructor '(->)' is right associative just means that if you use it in a right associative way, like 'TypeA -> (TypeB -> TypeC)', then there is syntactic sugar that allows you to omit the parens
21:21:53 <pvgorp> while we were interested in an implementation off ADD with other precedence rules for ()
21:22:12 <ntgrl> umm, precedence rules only take effect when you *don't* have ()
21:22:43 <ski> precedence tells how to insert omitted parens
21:22:51 <pvgorp> well indeed, but by making it explicit in the left associative way we were experimenting how it would look like if the rules would be reversed
21:23:24 <ntgrl> Isn't the answer: we'd need a lot more parens in our normal types?
21:23:39 <ski> well, if the rules were reversed, then if you omitted parens, it would just be interpreted in a left-associative way
21:23:50 <ski> nothing complicated
21:24:01 <pvgorp> the simplest way to formulate our experiment is: "how can you implement the addition of two integers using brackets from the left to the right?"
21:24:49 <ski> pvgorp : so i assume what you really was interested in was : what if we construct a type in a left-associative way, instead of in a right-associative way, what functions could have this other, new type then ?
21:25:58 <ntgrl> (+) :: Int -> (Int -> Int) -- like this
21:26:01 <ski> because if you change the types like that, in no way can it be the same function, it must be a different function
21:26:24 <ski> that is a type signature, saying that an infix operator '(+)' has a certain type
21:27:12 <pvgorp> the point is we wer
21:27:27 <ski> strangeAdd :: (Int -> Int) -> Int -- is a type signature, saying that a variable 'strangeAdd' has a certain *different* type
21:27:32 <pvgorp> we were expecting the associativity change to only have an influence on e.g. evaluation order of parameters
21:27:41 <pvgorp> but it turns out the whole semantics of the type change
21:27:56 <ski> indeed
21:28:04 <pvgorp> it seems evaluation order can never be changed
21:28:17 <ski> evaluation order is not specified in types
21:28:23 <gour> beauty of haskell ;)
21:28:34 <ski> evaluation order in haskell is mostly unspecified in haskell
21:28:34 <pvgorp> ski, yeah, in the engine I guess
21:28:45 <ski> s/ in haskell//
21:29:51 <ski> pvgorp : were you trying to change evaluation order to some specific order ?
21:29:52 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:30:59 <pvgorp> ski, well, we were trying to see for example if it was possible to make sure the first parameter is always evaluated first
21:31:03 <pvgorp> or the other way round
21:31:13 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:31:13 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:31:14 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:31:14 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:31:15 <Soul_keeper> new chan #linuxsociety if you want ops jump in !@!!!!
21:31:42 <ski> (yuurgh)
21:31:51 <pvgorp> things will clear up in our minds very soon
21:31:55 <pvgorp> thanks for your input
21:31:58 <ski> well
21:32:19 <ski> why did you want to make sure one parameter was evaluated first ?
21:32:50 <pvgorp> the point is I read somewhere parameter evaluation happend left-to-right
21:32:59 <pvgorp> and I didn't really understand what was meant by that
21:33:10 <pvgorp> which is why I tried to change it and see what would happen
21:34:49 <ski> maybe 'twas 'evaluation order, for pattern-matched parameters. happens left-to-right' ..
21:36:11 <pvgorp> actually, now that I look at it, it was this:
21:36:17 <pvgorp> function application evaluates to the left
21:36:18 <pvgorp> e.g. 
21:36:21 <pvgorp> mult x y z 
21:36:22 <pvgorp> is
21:36:45 <pvgorp> (((mult x)y)z)
21:37:00 <ski> s/evaluates/associates/
21:37:11 <pvgorp> right
21:37:15 <ski> those are separate things
21:37:37 <ski> > (const 4) (1 / 0)
21:37:38 <lambdabot> 4
21:37:50 <ski> > ((const id) (1/0)) 4
21:37:51 <lambdabot> 4
21:38:01 <ski> > (const (1/0)) 4
21:38:02 <lambdabot> Infinity
21:38:10 <ski> > (const (1/0)) 4 :: Int
21:38:10 <lambdabot>  add an instance declaration for (Fractional Int)
21:38:13 <ski> er
21:38:19 * ski bonks his head
21:38:27 <ski> > (const (1 `div` 0)) 4 :: Int
21:38:28 <lambdabot> Exception: divide by zero
21:38:56 <pvgorp> hrmm, ic
21:39:14 <ski> anyway, what i tried to show is that explicit grouping here does not affect evaluation order
21:39:50 <ski> parens and associativity deals with *which* expression was meant
21:40:04 <ski> order of evaluating that expression is another matter
21:40:09 <pvgorp> indeed, makes sense
21:41:03 <pvgorp>  ((const id) (1/0)) 4
21:41:10 <pvgorp> although why does this not return infinity?
21:41:17 <pvgorp> first it applies const to id, right?
21:41:21 <ski> > ((const id) (1 `div` 0)) 4 :: Int
21:41:22 <lambdabot> 4
21:41:31 <ski> @type const
21:41:31 <lambdabot> forall a b. a -> b -> a
21:41:33 <ski> @type const id
21:41:34 <lambdabot> forall a b. b -> a -> a
21:41:51 <ski> 'const' returns the value of first argument (not evaluating second argument)
21:42:04 <ski> 'const id' returns the value of second argument (not evaluating first argument)
21:42:24 <pvgorp> ic, so const id is one function, not const applied to id?
21:42:31 <ski> both :)
21:42:58 <ski> have you seen 'map', yet ?
21:43:01 <pvgorp> ok, so const has a really strange implementation which returns a variant of itself when it is fed "id" ?
21:43:07 <ski> no
21:43:10 <ski> not strange at all
21:43:11 <pvgorp> yes, it applies a function to all elements of a list
21:43:12 <musasabi> Is there something like (&&&) but for triples ?
21:43:23 <ski> musasabi : don't think so
21:43:56 <ski> > map (* 10) [1,2,3]
21:43:57 <lambdabot> [10,20,30]
21:44:21 <ski> @type map (* (10 :: Int)) [1,2,3]
21:44:22 <lambdabot> [Int]
21:44:27 <ski> @type map (* (10 :: Int))
21:44:27 <lambdabot> [Int] -> [Int]
21:44:57 <ski> so, 'map' applied to one argument returns/is a function
21:45:17 <pvgorp> ah, of course
21:45:25 <ski> > map (map (* 10)) [[1,2,3],[4,5,6],[7,8,9]]
21:45:26 <lambdabot> [[10,20,30],[40,50,60],[70,80,90]]
21:45:40 <ski> there i passed this function as argument to another 'map' call
21:46:00 <ski> so, regarding 'const id'
21:46:10 <ski> 'id' is defined as
21:46:11 <pvgorp> id is the identity function I guess
21:46:13 <ski> id x = x
21:46:15 <pvgorp> right
21:46:15 <ski> yes
21:46:17 <pvgorp> then that explains it
21:46:22 <pvgorp> then const id returns id
21:46:22 <ski> 'const' is defined as
21:46:29 <ski> const x y = x
21:46:35 <ski> no
21:46:42 <pvgorp> hmm, almost :)
21:46:47 <ski> 'const id whatever' returns 'id' :)
21:46:58 <ski> i.e.
21:47:01 <pvgorp> right
21:47:07 <ski> const id whatever = id
21:47:09 <ski> is true
21:47:46 <ski> now 'id' is a function that takes an argument and just returns it
21:47:50 <ski> so, that means
21:47:58 <pvgorp> id 4 == 4
21:48:00 <ski> const id whatever x = id x = x
21:48:08 <ski> so
21:48:10 <pvgorp> right
21:48:16 <pvgorp> and no need to evaluate whatever
21:48:17 <ski> const id whatever x = x
21:48:24 <ski> so, if we define
21:48:27 <ski> const_id = const id
21:48:28 <ski> then
21:48:34 <ski> const_id whatever x = x
21:48:39 <pvgorp> right
21:48:54 <ski> so you see that this defines a function that discards first argument, and returns second one
21:49:04 <pvgorp> as a sidenote, when I try these @type expressions in hugs, but they are not accepted :(
21:49:15 <pvgorp> ski, exactly, that is clear now... thanks :)
21:49:27 <ski> use ':t expression' or ':type expression' in hugs
21:49:43 <ski> '@type' is lambdabot-syntax
21:49:46 <pvgorp> ski, ah, lambdabot is just an interpreter with different syntax?
21:49:57 <ski> lambdabot is a bot
21:50:01 <pvgorp> ah ok :)
21:50:06 <pvgorp> it delegates to hugs?
21:50:13 <ski> is supports some commands that hugs and ghci supports
21:50:29 <ski> but lambdabot-commands generally start with '@'
21:50:42 <pvgorp> ok... well, thanks for the explanation
21:50:45 <ski> '> ' is an exception shorthand
21:50:52 <ski> @help eval
21:50:53 <lambdabot>  @eval <expr>
21:50:53 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
21:50:57 <ski> @eval 1+2
21:50:58 <lambdabot> 3
21:51:00 <ski> > 1+2
21:51:01 <lambdabot> 3
21:51:04 <pvgorp> aha
21:51:31 <ski> > length [1..10000000000]
21:51:34 <lambdabot> Terminated
21:51:54 <ski> > putStr "foo!"
21:51:55 <lambdabot> No IO allowed
21:51:59 <ski> @type putStr
21:52:00 <lambdabot> String -> IO ()
21:52:25 <Muad_Dibber> > sum $ take 2 $ [1..]
21:52:26 <lambdabot> 3
21:52:38 <Muad_Dibber> :)
21:52:56 <ski> (pvgorp : Muad_Dibber just used an infinite list :)
21:53:12 <pvgorp> ski, yeah, I've seen those before...
21:53:20 <pvgorp> quite powerful
21:53:23 <pvgorp> lazy evaluation
21:53:27 <ski> yes
21:53:33 <Muad_Dibber> lambdabot was i bit lazy in evaluating it though.
21:53:50 <ski> > [1..]
21:53:51 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
21:53:51 <lambdabot> 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
21:53:51 <lambdabot> 52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,
21:53:51 <lambdabot> 76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
21:53:51 <lambdabot> 100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,
21:53:53 <lambdabot> [24 @more lines]
21:53:53 <pvgorp> btw, is it true that haskell would have severe problems if you rule out static typing?
21:54:42 <ozone> pvgorp: well, it's kind of a non-statement, since haskell wouldn't be haskell without its static typing
21:55:08 <ski> well, typeclass-based overloading would probably have to be abandoned (or at least changed)
21:55:26 <fluxx> ski, wouldn't everything work with type-tagged values?
21:55:43 <fluxx> I don't quite understand the question, though, is it suggested that static typing is a problem to haskell?
21:55:48 <pvgorp> hmm, ok, so it's basically just a choice
21:55:55 <pvgorp> it would work without, but differently
21:55:55 <ski> design choice
21:56:07 <fluxx> 'rule out' means 'remove'?
21:56:24 <pvgorp> fluxx, yeah...
21:56:30 <sieni> but of course you can emulate dynamic typing with union types or whatever they are called in haskell
21:56:55 <ski> fluxx : i believe not all features of static types could be emulated with run-time tags
21:57:20 <fluxx> ski, can you point to an example?
21:57:21 <pvgorp> ok, thanks for all the help
21:57:23 <pvgorp> bbl
21:57:35 <fluxx> it might be obvious
21:57:38 <fluxx> but I'm not thinking ;)
21:57:39 <ski> (sieni : algebraic types .. but sum / disjoint union types is also ok)
21:57:55 * ski tries to remember some
22:04:17 <ski> it may be that i was thinking of features that only have to do with checking (and not other aspects of type systems)
22:05:01 <ski> (like e.g. checking that a function always returns an integer)
22:14:27 <sieni> hmm... wtf?
22:14:38 <sieni> I'm compiling Lambadabot and get an error:
22:14:51 <sieni> Binary.hs:1:0:
22:14:51 <sieni>     Warning: `IO' is imported more than once:
22:14:51 <sieni>                imported from GHC.IOBase at Binary.hs:28:25-30
22:14:51 <sieni>                imported from Prelude at Implicit import declaration
22:14:51 <sieni> make: *** [Binary.o] Error 1
22:15:01 <fluxx> ski, dynamic systems aren't expected to do that anyway..
22:15:49 <ski> (fluxx : but you can check that a list contains only integers)
22:16:04 <sieni> dons: ping ;-)
22:16:07 <fluxx> but things would need to work differently.. with typeclasses. let a = read b in a :: Int needs to return a lambda function that checks the required type
22:16:08 <Saulzar> Stuff which requires type annotation would seem to need _some_ static typing
22:16:40 <ski> > read "1" + 2
22:16:41 <lambdabot> 3
22:17:29 <aleator> what is best way of wrapping c function that returns a sequence of variable length?
22:18:25 <Saulzar> Or at least there would have to be a way of defaulting everything in some way
22:21:23 <Saulzar> I hate to think how you specify a monad transformer stack with 3 monads :)
22:22:39 <earthy> StateT (ReaderT (WriterT [])), e.g.
22:22:43 <earthy> why? :)
22:23:17 <Saulzar> With dynamic typing, you would at least have to be able to specify that type
22:23:25 <earthy> owh. right.
22:23:34 <Saulzar> Otherwise, if you just use the StateT stuff, how does it even know you have a ReaderT (...) ?
22:23:41 <Saulzar> Would be bizzare
22:23:54 <earthy> why?
22:24:05 <earthy> you only need to specify that which you use
22:24:12 <ski> maybe build up record of functions with some functor-like thing ?
22:24:17 <Saulzar> You'd have to make it explicit somehow from the start
22:24:32 <earthy> so, if you only want to use the fact that it's a state monad, you wouldn't have to match the dynamic to anything but StateT m
22:24:49 <earthy> Saulzar: have you seen the Clean implementation of Dynamics?
22:25:06 <earthy> it allows you to match a Dynamic against a given type
22:25:14 <Saulzar> No..
22:25:17 <ski> (earthy : that one is interesting)
22:25:19 <earthy> and then use operations for that type
22:26:04 <ski> dynApply :: Dynamic Dynamic -> Dynamic
22:26:20 <ski> dynApply (f :: a -> b) (x :: a) = dynamic f x
22:26:21 <earthy> ski: that's ill-typed, in a sense
22:26:26 <ski> iirc
22:26:33 <ski> hm ?
22:26:36 <tuomov> it would be cool if h4sh put extra arguments after the code to by run in e.g. 'arg' list instead of considering them files
22:27:26 <earthy> ski: yeah, it is allowed.
22:27:36 <ski> also
22:27:36 <earthy> but you explicitly match the type of f and the type of x
22:27:41 <ski> yes
22:27:54 <ski> dynApply' :: Dynamic Dynamic -> b
22:28:04 <ski> dynApply' (f :: a -> b) (x :: a) = f x
22:28:07 * earthy nods
22:28:16 <Saulzar> What is Dynamic Dynamic?
22:28:21 <ski> arguments
22:28:48 <earthy> saulzar: in haskell that'd read    dynApply :: Dynamic -> Dynamic -> Dynamic    and  dynApply' :: Dynamic -> Dynamic -> b
22:28:56 <Saulzar> a b -> c rather than a -> b -> c ?
22:29:02 <ski> yes
22:29:29 <ski> (iirc 'a -> (b -> c)' is a different type, in Clean)
22:29:59 <earthy> well, not really
22:30:09 <earthy> but meant to be used differently
22:32:56 <musasabi> Why is D a valid overlapping instance but C undecidable?
22:32:57 <musasabi> newtype W a = W a
22:32:57 <musasabi> class C a; instance C (); instance Integral a => C a
22:32:57 <musasabi> class D a; instance D (W ()); instance Integral a => D (W a)
22:34:24 <ski> mayhaps since the latter removes one level of type-constructor ?
22:35:32 <ski> assume you add 'instance C a => Integral a' to the former case
22:48:30 <musasabi> ski: point.
22:49:07 <musasabi> of course "instance D (W a) => Integral a", but that would trigger an error.
22:50:20 <ski> yes, increasing is not supported, either
22:56:21 <ski> good day, shapr
22:58:17 <shapr> hej ski
23:01:58 <ValarQ> tjo formarn
23:25:07 <shapr> hej ValarQ 
23:25:21 <shapr> Oh, I had something totally Haskelly to ask here... I forget what it was though.
23:30:22 <shapr> Let's see... typeclasses can be implemented in straight up Haskell if you use GADTs..
23:30:27 <shapr> What other equivalences exist?
23:32:31 <ulfdoz> a/aw
23:32:42 <ulfdoz> Sorry
23:36:42 <shapr> hoi boegel, how's code?
23:36:59 <shapr> Man, this place is so QUIET!
23:37:01 * shapr yells
23:38:07 <ValarQ> what? what?
23:38:34 <shapr> Vakna! Stiga upp! :-)
23:38:45 <ValarQ> heh
23:38:59 <shapr> Bor nra till Stockholm? Jag glmmer vilken stad ...
23:39:08 <ValarQ> Rockneby
23:39:14 <ValarQ> 20km north of Kalmar
23:39:23 * shapr looks at eniro.se
23:40:30 <shapr> Man, you're way south of Stockholm.
23:40:42 <ValarQ> yeah
23:41:13 <shapr> I'm moving from Boden to Stockholm, feels like it'll nearly be the Equator :-)
23:41:41 * ValarQ never really liked big cities
23:41:48 <shapr> Stockholm is further north than Seattle, but feels more southerly.
23:42:17 <shapr> I'm looking forward to being able to hook up with type theory and funktionell programmering mnniskor face to face.
23:42:39 <shapr> Well, that and the long list of other arcane subjects that interest me.
23:42:56 <sieni> ahh, ok
23:43:29 <sieni> whoa, even souther than me
23:44:16 <ValarQ> i wonder who will become the next northern Haskeller after shapr
23:49:50 <musasabi> ibid is the northest one in Finland that I know of.
23:51:24 <sieni> http://www.cse.unsw.edu.au/~dons/images/haskell/eu.jpg
23:51:29 <sieni> aleator as well?
23:51:44 <musasabi> at least per whois
23:52:25 <musasabi> we should ask them where in Jyvskyl they live, so we would know which one is the northmost one. But it might be someone in Canada or Sweden too.
23:53:06 <EtnaRosso> re all
23:53:08 <EtnaRosso> Cale!
23:53:47 <boegel> shapr: not much Haskell code lately, mostly research related code
23:53:52 <boegel> in R
23:54:12 <shapr> boegel: Sounds nifty.
23:54:23 <boegel> shapr: it is, if you get results :)
23:54:46 <boegel> but other people like my work with Haskell apparently, I got another email on HaskLS yesterday
