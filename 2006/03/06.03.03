00:01:08 <integral> is postmaster a haskell mail system?
00:01:11 <shapr> Yup
00:01:14 <shapr> http://postmaster.cryp.to/
00:01:22 <integral> neat
00:01:49 <shapr> I've used sendmail, postfix, qmail, and exim. Now it's time to try something I can *really* configure.
00:02:12 <integral> oh, it doesn't do queuing it appears :-/   I already use the perl qpsmtpd for esmtpd
00:02:33 <shapr> Peti said the queuing was in progress.
00:02:40 <shapr> That is, he has something that works, but it's not pretty.
00:02:58 <integral> luckily exim's good enough and easy
00:02:59 <shapr> @seen peti
00:02:59 <lambdabot> I haven't seen peti.
00:06:31 <shapr> @docs Control.Monad.Env
00:06:31 <lambdabot> Control.Monad.Env not available
00:06:49 <Phyx-> what's monad?
00:07:11 <shapr> The monadic interface is an abstraction much like the object convention.
00:07:29 <integral> Phyx-: pink, fluffy and _friendly_
00:07:40 <shapr> Though I think the monadic abstraction is just a lot niftier than the object oriented abstraction.
00:07:53 <Phyx-> o.O
00:08:04 <shapr> Simpler, easier to understand, makes more sense, has fewer special cases... 
00:09:14 <Phyx-> anyone have a precompiled lambdabot for me? :P
00:11:58 <shapr> Is there a simple way to search .so files for a symbol?
00:12:26 <xerox> ldd
00:12:30 <MarcWeber> Phyx- You can also talk to lambdabot privately .. So if you're online.. just use this lambdabot
00:14:45 <shapr> xerox: Can I use ldd to see if /usr/lib/libssl.so has EVP_ripemd160?
00:15:24 <pejo> shapr, nm -D file.so | grep SYMBOL
00:15:30 <shapr> aha, nm
00:15:36 <Phyx-> MarcWeber: i want to intergrate it into a bot of mine, for that i either need a working bot, or source i can understand, since lambdabot is written in haskell i presume, i don't really undersand it. though i could use stdio and pipe ghci
00:15:38 <shapr> thanks
00:15:57 <shapr> It's easy to add plugins to lambdabot.
00:16:05 <shapr> I may be biased, since I wrote the plugin interface.
00:17:12 <shapr> pejo: thanks!
00:18:03 <Phyx-> shapr: i can't get it to compile...
00:18:32 <shapr> What's the problem?
00:19:53 <shapr> I don't get it, hopenssl compiles fine, binaries seem to work, but GHCi asks for EVP_ripemd160 and I can't find it.
00:20:57 <shapr> Looks like it's just not there.
00:20:59 * shapr shrugs
00:23:20 <EtnaRosso> i love haskell!
00:24:04 <Phyx-> shapr: the problem is, i'm on windows :P
00:24:45 <shapr> Phyx-: I don't know if anyone has tried to build lambdabot on windows.
00:24:47 <shapr> EtnaRosso: Me too!
00:25:32 <Phyx-> shapr: i get till building
00:25:45 <Phyx-> then a nice memory exception box pops up
00:26:07 <shapr> Seems I need /usr/lib/libssl.so.0.9.8 and it's symlinked to /usr/lib/libssl.so, so should :set -lssl work in GHCi to get that? Do I need to add -L/usr/lib as well?
00:31:13 <shapr> Aha, I need to add them to the ghci command line.
00:31:22 <shapr> That is, -lcrypto -lssl 
00:32:28 <shapr> yay!
00:33:35 <vincenz> does ghc have an arm7 backend?
00:34:02 <Lemmih> shapr: The cabal file should set those flags.
00:34:56 <EtnaRosso> there is some sort of "random" function in haskell?
00:34:56 <MarcWeber> shapr Me some minutes ago.. But I can't link fps by now .. will have to wait till later then
00:35:13 <MarcWeber> EtnaRosso Yeah. some kinds of.. 
00:35:46 <MarcWeber> @docs randomR
00:35:46 <lambdabot> randomR not available
00:36:00 <EtnaRosso> @docs random
00:36:01 <lambdabot> random not available
00:36:08 <EtnaRosso> in the Random module
00:36:20 <shapr> @index randomR
00:36:20 <lambdabot> System.Random
00:36:55 <shapr> Lemmih: I haven't used cabal to install postmaster and its libs system-wide. Thanks for reminding me.
00:37:57 <MarcWeber> EtnaRosso http://www.haskell.org/ghc/docs/6.4-latest/html/libraries/base/System-Random.html
00:38:56 <MarcWeber> You have to make a random generator (eg let g=mkStdGen 2
00:39:05 <EtnaRosso> ouch
00:39:19 <EtnaRosso> but by now the problem is that random is non in scope
00:39:26 <EtnaRosso> do i have to load something?
00:40:03 <MarcWeber> @> do { let g= mkStdGen; (randomValue, g2)=randomR (1::Int, 6) g; print randomValue}
00:40:04 <lambdabot> compose module failed: Parse error: "do"
00:40:33 <MarcWeber> EtnaRosso Are you using ghci?
00:40:40 <EtnaRosso> yes
00:40:53 <MarcWeber> :m +System.Random
00:41:31 <MarcWeber> See also State monad.. There are some examples ; - )
00:41:38 <EtnaRosso> thank you
00:41:54 <EtnaRosso> but really the state monad mantain it state during time?
00:42:21 <MarcWeber> State monad means you can pass a state without seeing it.. so you don't have to type as much.
00:42:33 <shapr> Let's see...
00:42:36 <vincenz> x <- get; put x+1;
00:43:18 <shapr> I can replace: [("sendmail","postmaster"),("apache","hws"),("moinmoin","flippi")]. What am I missing?
00:43:32 <MarcWeber> EtnaRosso http://www.nomaware.com/monads/html/statemonad.html
00:43:39 <vincenz> noooooooo
00:43:41 <vincenz> no nomaware
00:43:47 <shapr> ("linux","house") isn't quite there.
00:43:48 <vincenz> they have the most horrible code samples to illustrate
00:43:56 <shapr> vincenz: Hey, I like 'em!
00:44:03 <EtnaRosso> ok by now i'm involved in random 
00:44:05 <shapr> Do something better or don't complain :-P
00:44:16 * vincenz pleads the 5th
00:45:41 <vincenz> blegh for some reason I can't download any other SICP movies anymore
00:45:42 <vincenz> I'm missing a few
00:53:29 <Phyx-> 5th?
00:53:43 <tromp_> tyou take the 5th
00:53:53 <tromp_> not plead
00:54:58 <tromp_> oops, i'm wrong
00:55:04 <tromp_> both are fine:)
00:57:13 <EtnaRosso> so an example for random?
00:59:38 <shapr> Anyone using haskell-mode 2.1 in gnu emacs? With xemacs, it seems that '"' breaks syntax highlighting, and so does any use of literate Haskell. Does it work on gnu emacs?
01:04:03 * ValarQ tests
01:04:51 <jips> hello haskell
01:04:55 <jips> @seen dons
01:04:55 <lambdabot> dons is in #haskell. Last spoke 10 hours, 14 minutes and 21 seconds ago.
01:05:01 <shapr> hi jips
01:05:29 <ValarQ> shapr: seems to work well in gnu emacs
01:05:46 <jips> anything cool happen with haskell in the last 2 weeks?
01:06:52 <shapr> ValarQ: Hm, I wonder what's wrong...
01:07:49 <ValarQ> shapr: if it worked well with 2.0, maybe you can compare the two versions
01:09:26 <Phyx-> ok, which fool made it posible to not be able to devide 2 ints and get a float?
01:09:30 <Phyx-> who do i need to shoot?
01:09:50 <tromp_> startkeylogger
01:10:25 <tromp_> sorry; reading slashdot:(
01:10:35 <Phyx-> anyway to convert a damn Int to float so i can?
01:10:51 <shapr> Sorry, demonic Ints are out of my experience.
01:10:58 <shapr> Maybe you meant Imps?
01:11:03 <Phyx-> rofl...
01:11:07 <Phyx-> i'm serious
01:11:13 <Phyx-> else my percentages are screwed
01:11:15 <ProfTeggy> fromInteger, Phyx
01:11:27 <Phyx-> @type fromInteger
01:11:28 <lambdabot> forall a. (Num a) => Integer -> a
01:11:33 <shapr> @type fromIntegral
01:11:34 <lambdabot> forall b a. (Num b, Integral a) => a -> b
01:11:45 <Phyx-> @type toFloat?
01:11:45 <lambdabot> parse error (possibly incorrect indentation)
01:11:46 <Phyx-> @type toFloat
01:11:47 <lambdabot> Not in scope: `toFloat'
01:11:51 <Phyx-> @type toDouble
01:11:51 <lambdabot> Not in scope: `toDouble'
01:11:55 <Phyx-> :|
01:12:11 <ProfTeggy> > fromIntegral 42 :: Float
01:12:12 <lambdabot> 42.0
01:12:44 <Phyx-> ahh
01:12:45 <Phyx-> :D
01:12:49 * Phyx- hugs ProfTeggy 
01:12:52 <ProfTeggy> Ugh
01:14:33 <shapr> tromp_: You think that hit Itkovian?
01:15:41 <Phyx-> @type *
01:15:41 <lambdabot> parse error on input `*'
01:15:50 <sjanssen> @type (*)
01:15:50 <Phyx-> @type (*)
01:15:51 <lambdabot> forall a. (Num a) => a -> a -> a
01:15:51 <lambdabot> forall a. (Num a) => a -> a -> a
01:17:06 <Phyx-> @type round
01:17:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:17:56 <Phyx-> > round 8.0
01:17:57 <lambdabot> 8
01:18:00 <Phyx-> > round 8.5
01:18:01 <lambdabot> 8
01:18:05 <Phyx-> wtf?
01:18:12 <Phyx-> > round 8.8
01:18:13 <lambdabot> 9
01:18:14 <vincenz> > round 8.51
01:18:15 <lambdabot> 9
01:18:17 <vincenz> > round 8.5
01:18:18 <lambdabot> 8
01:18:20 <vincenz> round is of
01:18:24 <Phyx-> indeed
01:18:26 <vincenz> @fptools round
01:18:26 <lambdabot> round not available
01:18:32 <Phyx-> > round 8.50
01:18:32 <vincenz> > round 81.5
01:18:32 <lambdabot> 8
01:18:33 <lambdabot> 82
01:18:36 <vincenz> o.O
01:18:39 <tromp_> no idea, shapr. it shouldn't be a timed out, shld it?
01:18:40 <vincenz> WOAH
01:18:41 <Phyx-> hehe
01:18:48 <vincenz> it's even undeterministic
01:18:49 <Phyx-> BUG
01:18:59 <vincenz> > round 9.5
01:19:00 <lambdabot> 10
01:19:04 <vincenz> > round 8.5
01:19:04 <lambdabot> 8
01:19:06 <sjanssen> could this be one of those fancy rounders?
01:19:08 <shapr> tromp_: If norton terminated it on the desktop, the client wouldn't have time to disconnect? Idunno.
01:19:09 <vincenz> LOL
01:19:13 <vincenz> oh wait
01:19:16 <sjanssen> like round up when odd or something like that?
01:19:24 <vincenz> > round 7.5
01:19:25 <lambdabot> 8
01:19:26 <vincenz> > round 6.5
01:19:27 <lambdabot> 6
01:19:28 <vincenz> yep
01:19:33 <vincenz> seems so
01:19:34 <tromp_> next time i'll ask him to type it himself:)
01:19:35 <shapr> That's strange...
01:19:51 <Phyx-> > round 7.5
01:19:51 <lambdabot> 8
01:19:55 <Phyx-> hehe
01:19:58 <Phyx-> nice, hahah
01:19:58 <vincenz> > map round $ map (+0.5)$ map fromIntegral [1..10]
01:19:59 <lambdabot> [2,2,4,4,6,6,8,8,10,10]
01:20:16 <Phyx-> even ghci does it
01:20:20 <Phyx-> anyway to make thie reliable?
01:20:31 <vincenz> > map (round . (+0.5) . fromIntegral) [1..10]
01:20:32 <lambdabot> [2,2,4,4,6,6,8,8,10,10]
01:20:59 <sjanssen> Phyx-: it's working the way it's supposed to
01:21:05 <vincenz> no it's not
01:21:09 <Phyx-> it's not
01:21:17 <Phyx-> sjanssen: in my math class, 8.5 is 9
01:21:22 <shapr> g'day twb
01:21:23 <Phyx-> and 6.5 is 7
01:21:32 <twb> shapr: hiya shapr.
01:21:32 <Phyx-> > round 8.5
01:21:33 <lambdabot> 8
01:21:38 <Phyx-> how can that be right?
01:21:40 * Lemmih wonders why JaffaCake isn't hanging out in #haskell anymore.
01:21:41 <vincenz> Phyx-: try this
01:21:48 <sjanssen> Phyx-: it's a different kind of rounding, tis a fairly common thing
01:21:50 <twb> I'm trolling today :-)
01:21:57 <vincenz> sjanssen: it's illega
01:22:01 <Phyx-> sjanssen: it seems useless
01:22:03 <shapr> twb: How so?
01:22:16 <twb> So I'm watching SICP again, and there's the usual explanation of how to do laziness in a strict language.
01:22:23 <Phyx-> vincenz: try what?
01:23:13 <twb> And there's also the "entirely lazy languages suck because they are hard to optimize and mutable data is a pita".
01:23:20 <vincenz> > let myround x = (round (2*x+0.5) `div` 2) in map (myround . (+0.5) . fromIntegral) [1..10]
01:23:21 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
01:23:23 <vincenz> :D
01:23:30 <vincenz> > let myround x = (round (2*x+0.5) `div` 2) in map (myround . (+0.4) . fromIntegral) [1..10]
01:23:31 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
01:23:34 <vincenz> > let myround x = (round (2*x+0.5) `div` 2) in map (myround . (+0.6) . fromIntegral) [1..10]
01:23:35 <lambdabot> [2,3,4,5,6,7,8,9,10,11]
01:23:44 <sjanssen> Phyx-, vincenz: http://en.wikipedia.org/wiki/Rounding#Statistician.27s_method_of_rounding
01:23:52 <vincenz> sjanssen: that's not the definition of round however
01:24:05 <twb> So I'm wondering if there's a pro-lazy-everything article somewhere that I can read.
01:24:11 <vincenz> twb: yes whyfp
01:24:13 <shapr> vincenz: I think he's saying that may not be *your* definition of round, but it is *one* definition of round.
01:24:14 <vincenz> @google whypf
01:24:16 <lambdabot> http://www.globalmarketing.cn/UserInfo.asp?UserID=344
01:24:17 <vincenz> @google whyfp
01:24:19 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
01:24:25 <vincenz> shapr: thank you for the personal attack
01:24:28 <Phyx-> vincenz: guess i'll e using that
01:24:37 <shapr> Silly person, it's not a personal.
01:24:44 <shapr> er, 'personal attack'
01:24:52 <vincenz> in most programming languages not just *mine*
01:24:53 <shapr> I'm just saying that there is more than one definition of round.
01:24:55 <twb> vincenz: you can be functional without lazy.
01:25:01 <vincenz> round x = floor (x+0.5)
01:25:12 <vincenz> twb: it also reasons about lazyness
01:25:28 <twb> vincenz: OK.
01:25:32 <vincenz> Phyx-: which gives you another option
01:25:35 <shapr> twb: Okasaki's work on amortized algorithms shows one of the good points of non-strict eval.
01:25:54 <twb> shapr: I realize that lazy is good *in moderation*.
01:25:58 <Phyx-> thanx, let's try
01:26:07 <Phyx-> good
01:26:11 <twb> shapr: what I'm saying is, I guess, what is the argument for lazy *by default*.
01:26:12 <Phyx-> 91% and 9%
01:26:29 <vincenz> twb: computation on demand
01:27:00 <twb> vincenz: you don't need lazy-by-default for that.
01:27:00 <shapr> Laziness does a lot of nifty stuff.
01:27:30 <vincenz> twb: you don't need lazyness by default for anyhting, just use lambdathunks, however it gets unwieldy quickly
01:27:52 <shapr> I wrote a mailing list search plugin for lambdabot long ago, and it was able to parse an mbox file of whatever size, and max memory usage was the size of the RTS plus the largest email.
01:27:57 <twb> vincenz: even with syntactic abstractions?
01:28:30 <vincenz> twb: isn't that what haskell does in the end?
01:28:36 <vincenz> to a very deep level
01:28:47 <vincenz> I don't know, to me the line is rather fuzzy
01:29:28 <twb> You agree that (say) Scheme is strict by default and Haskell is lazy by default, right?
01:29:33 <vincenz> twb: yes
01:29:49 <vincenz> twb: however you can do haskell lazyness in scheme, and scheme strictness in haskell
01:29:54 <vincenz> the question isi how unwieldy it gets
01:29:56 <shapr> I think laziness gives the programmer a lot more control, but more potential drawbacks. Strict is easy to deal with, partially by disallowing customization, a la windows :-)
01:30:05 <twb> And that streams give you laziness and monads(?) seq(?) give you strictness?
01:30:18 <vincenz> monads not perse as I found out
01:30:37 <shapr> Monads work fine in Java, Perl, or whatever.
01:30:49 <vincenz> state monad isn't fully strict :/
01:30:55 <vincenz> as I found out after a bug
01:31:01 <twb> Well, seq then.
01:31:07 <astrolabe> I think a good reason for lazyness by default is that more expressions have values in the lazy case.  Efficiency is a secondary consideration.
01:31:20 <shapr> seq only gives you weak head normal form.
01:31:21 <Phyx-> theorie  :   ********* (91.0%)
01:31:21 <Phyx-> praktijk :   *         (9%)
01:31:26 * Phyx- hugs vincenz 
01:31:27 <Phyx-> :D
01:31:31 <shapr> @foldoc whnf
01:31:33 <lambdabot> *** "whnf" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
01:31:33 <lambdabot> WHNF
01:31:33 <lambdabot>  
01:31:33 <lambdabot>    {weak head normal form}
01:31:33 <lambdabot>  
01:31:33 <vincenz> Phyx-: dutch?
01:31:38 <Phyx-> yeah
01:31:44 <shapr> @foldoc "weak head normal form"
01:31:45 <lambdabot> *** "weak head normal form" foldoc "The Free On-line Dictionary of
01:31:45 <lambdabot> Computing (27 SEP 03)"
01:31:45 <lambdabot> Weak Head Normal Form
01:31:45 <lambdabot>  
01:31:45 <lambdabot>    <reduction, lambda calculus> (WHNF) A {lambda expression} is
01:31:47 <lambdabot> [35 @more lines]
01:31:51 <twb> astrolabe: can you clarify "more expressions have values"?
01:32:06 <shapr> astrolabe: hi!
01:32:15 <jips> twb: i guess he means [1..]
01:32:19 <astrolabe> try doing   head [1..] with a strict language
01:32:34 <astrolabe> Hia shapr!  How's the evil project?
01:32:38 <twb> astrolabe: that's what streams are for.
01:32:40 <shapr> Or try tail [1/0,1]
01:32:42 <astrolabe> > head [1..]
01:32:42 <vincenz> > tail [1..]
01:32:43 <lambdabot> 1
01:32:43 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,
01:32:43 <lambdabot> 29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
01:32:43 <lambdabot> 53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,
01:32:43 <lambdabot> 77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
01:32:44 <lambdabot> 101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,
01:32:46 <lambdabot> [24 @more lines]
01:32:46 <twb> (enum succ)
01:32:47 <vincenz> doh
01:32:48 <shapr> astrolabe: It's moving right along.
01:32:53 <vincenz> > last [1,2,3]
01:32:54 <lambdabot> 3
01:32:57 <vincenz> >last [1..]
01:33:24 <jips> > True or (1/0)
01:33:25 <lambdabot> Couldn't match `Bool' against `t -> t1 -> t2'
01:33:29 <sjanssen> vincenz: hey now, let's not kill lambdabot
01:33:34 <vincenz> sjanssen: he won't die
01:33:38 <jips> > True or (1/0) == 0
01:33:38 <lambdabot> Couldn't match `Bool' against `t -> t1 -> t2'
01:33:40 <astrolabe> I've read that every expression that has a strict value has a lazy value, but obviously the converse isn't true.
01:33:41 <vincenz> sjanssen: he's got an auto timeout
01:33:48 <vincenz> > last [1..]
01:33:50 <jips> > True or ((1/0) == 0)
01:33:52 <lambdabot> Terminated
01:33:54 <lambdabot> Couldn't match `Bool' against `t -> t1 -> t2'
01:33:54 <vincenz> see
01:34:02 <twb> astrolabe: with streams, you can still say things like (take 4 (enum 0 succ)) ==> (0 1 2 3)
01:34:20 <Igloo> jips: You want ||
01:34:28 <sjanssen> vincenz: yeah, I know.  pretending I didn't gave an opportunity for a joke
01:34:31 <astrolabe> twb: sure, but now replace lists with trees
01:34:33 <vincenz> twb: can you use streams in any unction taking lists?
01:34:38 <jips> Igloo: danke
01:34:43 <twb> astrolabe: aha!
01:34:44 <vincenz> twb: and you can't map over functions and then take the first four
01:34:50 <vincenz> twb: unless you special case the map
01:35:01 <vincenz> > take 4$ map (+2) $ [1..]
01:35:02 <lambdabot> [3,4,5,6]
01:35:05 <twb> OK, I'm beginning to see.
01:35:11 <shapr> twb: How would you do ones = 1 : ones or fib = 0 : 1 : zipWith (+) fib (tail fib) ?
01:35:48 * jips has been too much programming in visual basic lately :'(
01:35:57 * vincenz winces for jips 
01:36:21 <twb> Of course, you can map structures that are infinite in multiple dimensions onto a stream.
01:36:46 <shapr> Yeah, but you force traversal order then, don't you?
01:36:57 <twb> It's a common question for turing machine lectures -- e.g. tapes that are infinite in both directions or tapes that are an infinite plane of squares.
01:37:04 <twb> shapr: that's true.
01:37:23 <shapr> That means an A* search would be more obvious in Haskell than Scheme. (to me at least)
01:37:52 <astrolabe> Well, strictness and lazyness are both turing complete, you can calculate the same things with them, but you get more freedom with the way you code in a lazy expression (at the cost often of efficiency, but sometimes a gain).
01:38:26 <twb> astrolabe: nono no I'm not using the turing-completeness argument.
01:38:42 <astrolabe> I think it is about being able to write expressive, easily understood code.
01:38:50 <twb> astrolabe: I was simply using different types of turing machine tapes as infinite data structures.
01:39:26 <shapr> Searching lazily calculated structures with more than one dimension would be a pain with streams.
01:39:32 <astrolabe> twb: I see. I agree you could map the multiple dimensions on to one, but it is nicer not to have to.
01:39:48 <twb> I wonder if you could make a language that can automatically lazify/strictify with a declaration, similar to how CL has a declaration to make a symbol dynamically scoped.
01:40:27 <sjanssen> twb: don't languages with explicit laziness already have this?
01:40:39 <jips> in haskell you can request strictness with !
01:40:40 <twb> sjanssen: I don't know.
01:40:43 <shapr> Personally, I'd probably end up dynamically generating a new stream for each thunk, sort of like Oleg's continuation zipper allowing new cursors for each zipper node/state.
01:41:16 <shapr> I've heard Clean does much more in the way of strictness declarations.
01:41:56 <shapr> For example, can you do data Foo = Foo ![a] ?
01:42:42 <sjanssen> shapr: why not?
01:42:46 <shapr> In the opposite manner, people regularly write "atLeast n" instead of using length for cases where they don't want to see the whole list.
01:43:18 <shapr> sjanssen: doh, you can =)
01:43:40 <shapr> Ok, what about data Foo a = Foo [!a] instead?
01:43:44 <shapr> strict items but not a strict list?
01:43:45 <sjanssen> though, saying ![a] doesn't mean all that much, just that the first cons is defined
01:44:24 <shapr> twb: I think laziness is deeply fascinating. So far my experiences imply that it's more powerful but also costs more skullsweat.
01:44:49 <shapr> Strong normalization is along the same lines, sort of...
01:45:18 <twb> shapr: you can make the same argument for mutable data ;-)
01:45:52 <Phyx-> lol, i love it when haskell programs work :D
01:47:14 <sjanssen> Phyx-: were you still looking for a function to do the common method of rounding?
01:47:34 <Phyx-> sjanssen: no, i used the one vincenz provided
01:47:39 <Phyx-> works like a charm
01:47:58 <vincenz> floor (x+0.5)
01:48:19 <shapr> twb: Yeah, true that. But I'm firmly on the side of "learn lots to be able to do lots." Thus I use Haskell, Emacs, Linux, etc.
01:48:55 <sjanssen> @type properFraction
01:48:56 <lambdabot> forall a b.
01:48:56 <lambdabot>       (RealFrac a, Integral b) =>
01:48:56 <lambdabot>       a -> (b, a)
01:48:58 <shapr> Other personal examples include zsh, dvorak... not sure what else.
01:49:06 <sjanssen> you can use that if you want a more explicit method
01:49:06 <roconnor> @type getContents
01:49:07 <lambdabot> IO String
01:53:11 <Phyx-> @type fromIntergral
01:53:12 <lambdabot> Not in scope: `fromIntergral'
01:53:15 <Phyx-> @type fromInterger
01:53:16 <lambdabot> Not in scope: `fromInterger'
01:53:20 <Phyx-> @type fromInteger
01:53:21 <lambdabot> forall a. (Num a) => Integer -> a
01:53:29 <Phyx-> fuck... helium doesn't know it
01:53:40 <Phyx-> ghci works but helium ...
01:53:49 <Phyx-> anyway to write that myself?
01:54:01 <sjanssen> Phyx-: helium isn't quite Haskell, it doesn't have classes
01:54:23 <Phyx-> i finished getting my assignment to work in gchi
01:54:26 <Phyx-> ghci*
01:54:30 <Phyx-> but it has to run un helium
01:54:37 <Phyx-> it doesn't since helium doesn't know that function
01:55:37 <sjanssen> Phyx-: Helium probably has a bunch of explicit conversion functions (like integerToFloat or some such), you should check their documentation
01:56:27 <earthy> which version of helium, phyx?
01:58:41 <Phyx-> earthy: latest
01:58:45 <Phyx-> as far as i know
01:58:48 <Phyx-> dled it last week
01:58:56 <Phyx-> sjanssen: yeah, it has fromInt
01:59:08 <Phyx-> but it's complaining bout things that ghci didn't
02:02:35 <twb> Incidentally, the video I was watching that concerns laziness in Scheme is http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/videos-divx/Lecture-6b.avi
02:03:47 * shapr grumbles at postmaster
02:06:32 <shapr> Whoops, user error. Postmaster works fine so far.
02:07:14 <Phyx-> what does "(277,31): Warning: Missing patterns in function bindings:" mean?
02:08:55 <twb> Phyx-: it means you haven't defined a result for all inputs.
02:09:06 <Phyx-> hmmm ok
02:09:11 <Phyx-> thanx
02:09:27 <twb> e.g. tl (x:xs) = xs -- doesn't work for "tl []".
02:09:32 <roconnor> > let [a,b,c] = [1,2,3] in b
02:09:33 <lambdabot> 2
02:10:04 <EtnaRosso> see you
02:10:19 <twb> To avoid that error, you'd want something like: tl [] = error "tl: nil"
02:10:30 <Phyx-> what's the difference between Int and Integer
02:10:38 <twb> Phyx-: Integer is a bignum.
02:10:47 <twb> Phyx-: i.e. arbitrarily large.
02:10:50 <sjanssen> > 2^33 :: Int
02:10:51 <lambdabot> 0
02:10:56 <sjanssen> > 2^33 :: Integer
02:10:57 <lambdabot> 8589934592
02:11:17 <twb> sjanssen: for 32-bit systems :-)
02:11:20 <Phyx->       Expected type: Integer
02:11:21 <Phyx->       Inferred type: Int
02:11:21 <Phyx->     In the first argument of `fc', namely `x'
02:11:21 <Phyx->     In the first argument of `(/)', namely `(fc x)'
02:11:23 <Phyx-> i now get that
02:11:29 <Phyx-> now that my code works i helium
02:11:32 <Phyx-> FUCK....
02:11:58 * ProfTeggy covers his inncoent eyes.
02:12:01 <Phyx-> sorry for the swearing
02:12:04 <twb> Phyx-: lisppaste the whole thing.
02:12:05 <Phyx-> it's fustrating...
02:12:07 <ProfTeggy> Too late, buddy
02:12:08 <twb> lisppaste: url
02:12:08 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
02:12:09 <shapr> Phyx-: hey man, at least swear in Dutch...
02:12:15 <Phyx-> rofl...
02:12:17 <shapr> gezeik!
02:12:25 <ProfTeggy> Phyx, please swear using the lisppaste bot.
02:12:25 <Phyx-> hahahah
02:12:39 <twb> Phyx-: yes, it is frustrating.  It'd be nice if the fixnum optimization was implicit.
02:12:55 <shapr> Yeah, swearing is generally frowned upon in #haskell
02:13:29 <twb> Bah.
02:13:36 <shapr> Hm, #haskell is just a few weeks away from 5 years old.
02:13:38 <twb> That's word discrimnation!
02:13:58 <shapr> Nah, it's really about emotional content in dicussions.
02:14:01 <twb> Maybe you'd like all four letter words to ride on diferent buses and shop in different malls.
02:14:27 <shapr> Happily, shapr is a five letter word.
02:15:00 <astrolabe> Has #haskell changed much?
02:15:16 <twb> astrolabe: still characters on an irc server :P
02:15:24 <Phyx-> w00t
02:15:26 <Phyx-> works :D
02:15:29 <Phyx-> yyayyyayayaaayya
02:15:56 <shapr> astrolabe: Yeah, quite a bit.
02:16:27 <ProfTeggy> For the worse?
02:16:37 <ProfTeggy> (Presumably.)
02:17:11 <sjanssen> who started #haskell?  do we know?
02:17:49 <shapr> Yes..
02:17:53 <astrolabe> shapr I think
02:18:00 <Igloo> wli and someone else were idling here before that
02:18:09 <Igloo> I'm not sure who came here first
02:18:43 <shapr> Some guy named Linoleum registered the channel, and it was me and him for awhile. Then he stopped showing up, so I asked him if I could be founder.
02:18:55 <twb> Hpmh.  GJS is going on about how small EVAL is, but he doesn't mention READ ;-)
02:19:36 <astrolabe> Has spj ever been in?
02:19:39 <shapr> ProfTeggy: Actually, #haskell has been a great place for the most part.
02:19:45 <Igloo> Yes
02:19:46 <shapr> astrolabe: Yeah, twice at least.
02:20:19 <ProfTeggy> shapr, that's good to hear
02:20:27 <astrolabe> It must have gone over his head.
02:20:55 <astrolabe> Or maybe he can spot that #haskell and getting stuff done are difficult partners.
02:21:05 <shapr> ProfTeggy: Of course, the people I've banned disagree with that.
02:21:26 <ProfTeggy> There are bans...?
02:21:29 <sjanssen> astrolabe: that is probably why, he's far too busy hacking GHC and writing groundbreaking papers
02:21:39 <shapr> Yup, at least two bans that I can think of off the top of my head.
02:21:43 <sylvan> Could someone put a space after the commas in the topic? It bugs me =)
02:21:51 <shapr> sylvan: It's an open source topic.
02:21:54 <sylvan> ah
02:22:08 <Phyx-> any build in functions to insert stuff inbetween a list?
02:22:11 <astrolabe> I assumed it was a haskell list.
02:22:19 --- topic: set to '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]' by sylvan
02:22:27 <sjanssen> Phyx-: intersperse
02:22:32 <sylvan> yay.. and now the auto-linkify thing works too...
02:22:36 <Phyx-> @type intersperse
02:22:37 <lambdabot> Not in scope: `intersperse'
02:22:42 <Phyx-> erm
02:22:48 <sjanssen> @type Data.List.intersperse
02:22:49 <lambdabot> forall a. a -> [a] -> [a]
02:23:15 <Phyx-> that doesn't look helium friendly
02:23:23 <Phyx-> guess i'll have to write it myself
02:23:23 <kowey> Phyx-: just a hint so you can avoid my mistake... for a long time, i'd do something like concat $ intersperse " " foo
02:23:29 <kowey> when i could just have done unwords
02:23:44 <Phyx-> heheeh
02:23:58 <sylvan> I'm trying to find a good intro for typed lambda calculus.. including type inference, let-polymorphism etc....
02:24:07 <sylvan> anyone have any tips?
02:24:33 <shapr> ProfTeggy: I hold to ideas like 'agree to disagree' and 'steps of the parthenon.' Some people cannot co-exist with those ideas.
02:26:41 <shapr> sylvan: Types and Programming Languages ?
02:26:59 <shapr> tromp_: Oh, now we get to try it again!
02:27:23 <shapr> startkeylogger
02:27:34 * shapr shrugs
02:27:41 <sylvan> don't have that one... I'll look it up
02:27:53 <Phyx-> what's that start startkeylogger thing?
02:28:06 <shapr> Phyx-: http://it.slashdot.org/article.pl?sid=06/03/03/004215
02:29:54 <tromp_> stopkeylogger
02:29:55 <Phyx-> rofl
02:30:10 <Phyx-> @type insert
02:30:11 <lambdabot> Not in scope: `insert'
02:30:15 <Phyx-> good
02:30:22 <Phyx-> no conflic with existing functions
02:32:36 <Phyx-> @splitAt
02:32:37 <lambdabot> Unknown command, try @listcommands.
02:32:43 <Phyx-> @type splitAt
02:32:44 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:33:19 <Phyx-> it's 0 bound?
02:33:43 <Phyx-> > splitAt 0 [1..5] 
02:33:44 <lambdabot> ([],[1,2,3,4,5])
02:33:49 <Phyx-> > splitAt 1 [1..5] 
02:33:50 <lambdabot> ([1],[2,3,4,5])
02:33:59 <Phyx-> guess not
02:36:46 <Phyx-> yay, works :D
02:37:40 <Phyx-> are there unsigned Ints in haskell?
02:37:54 <Lemmih> Phyx-: Yep. See Data.Word
02:38:34 * Phyx- cries
02:38:44 <Phyx-> i have to stay away from everything that helium can't do
02:38:46 <Phyx-> for now
02:38:55 <Phyx-> till we're allowed to officially only use ghci
02:38:57 <shapr> But one day, you'll be able to use Haskel lfor real!
02:39:03 <shapr> And then, all the power will be YOURS!
02:39:09 <Phyx-> :D
02:39:10 * shapr powers up his Postmaster...
02:39:20 * Phyx- falls off bed laughing
02:40:10 <Phyx-> @type abs
02:40:11 <lambdabot> forall a. (Num a) => a -> a
02:41:25 <Phyx-> ty lambdabot 
02:42:06 <tuomov> *sigh*
02:42:08 <tuomov> time for a darcs fork
02:42:17 <tuomov> store patch metadata in utf-8 -> wontfix
02:42:29 <tuomov> and nothing happening wrt using iso-8601 time format either
02:42:31 <tuomov> stupid yanks.
02:42:50 <shapr> hey!
02:43:00 <shapr> C'mon, use your finnish sisu ;-)
02:50:25 <Phyx-> question again!
02:50:34 <Phyx-> how do i add 2 tuples together
02:50:38 <Phyx-> like ++ for lists
02:51:21 <earthy> you don't. :)
02:51:43 <Phyx-> heh
02:51:45 <Phyx-> :)
02:51:51 <earthy> sorry.
02:52:37 <earthy> unless you define something like ($%$) :: (a,b) -> (c,d) -> (a,b,c,d); (a,b) $%$ (c,d) = (a,b,c,d)
02:52:47 <earthy> but that'd only work for 2-tuples
02:54:20 <Phyx-> wouldn't unzip $ zip [t1] [t1] work?
02:57:07 <kowey> tuomov: i don't know how serious you are, but you might want to note that jch + many other darcs developers are european :-)
02:57:22 <Phyx-> earthy: ? would it?
02:57:48 <Phyx-> > unzip $ zip [(1,2,3,4)] [(5,6,7,8)]
02:57:49 <lambdabot> ([(1,2,3,4)],[(5,6,7,8)])
02:57:54 <Phyx-> hmmm
02:57:55 <Phyx-> guess not
02:58:11 <Phyx-> > unzip $ zip (1,2,3,4) (5,6,7,8)
02:58:12 <lambdabot> Couldn't match `[a]' against `(a1, b, c, d)'
02:58:16 <Phyx-> :D
02:59:43 <tuomov> kowey: if it was initially written by someone using more than ascii, all these things more likely would've been done right from the start...
03:00:09 * kowey nods
03:00:51 <Igloo> tuomov: Where's that bug?
03:00:55 <greenrd> I've just read http://en.wikipedia.org/wiki/Continuation_passing_style
03:00:59 <greenrd> What is CPS useful for in Haskell?
03:01:22 <tuomov> http://bugs.darcs.net/issue64
03:01:37 <roconnor> @type openFile
03:01:38 <lambdabot> Not in scope: `openFile'
03:01:44 <roconnor> @hoogle openFile
03:01:44 <sieni> greenrd: e.g. http://users.aber.ac.uk/afc/stricthaskell.html#cps
03:01:44 <lambdabot> System.IO.openFile :: FilePath -> IOMode -> IO Handle
03:01:44 <lambdabot> Graphics.UI.ObjectIO.StdGUI.ProcessOpenFiles :: ProcessOpenFilesFunction
03:01:44 <lambdabot> ps -> ProcessAttribute ps
03:01:44 <lambdabot> Graphics.UI.ObjectIO.StdGUI.ProcessOpenFilesFunction :: [String] -> ps ->
03:01:44 <lambdabot> GUI ps ps
03:02:50 <sieni> greenrd: and also: http://www.haskell.org/hawiki/MonadCont
03:03:10 <tibbe> @hoogle [m a] -> m a
03:03:10 <lambdabot> Data.List.head :: [a] -> a
03:03:10 <lambdabot> Data.List.last :: [a] -> a
03:03:10 <lambdabot> Prelude.head :: [a] -> a
03:03:28 <Igloo> tuomov: Are you concerned about file names or patch descriptions?
03:03:40 <tibbe> how do I combine a list of [Maybe] so that I get Nothing if one of the values is Nothing?
03:03:42 <tuomov> descriptions. file names _are_ a more difficult problem.
03:03:50 <tuomov> that isn't easily solved
03:03:52 <kowey> Igloo, tuomov, maybe the rest of #darcs might be interested in this discussion?
03:04:16 <Igloo> tuomov: Right, I agree with you then. I'll finish skimming the thread and then try to work out how to say so
03:04:49 <Lemmih> tibbe: sequence
03:04:55 <tuomov> currently the situation is that if I get a patch from someone that contains e.g. the name in a non-utf8 encoding, my rss and html changelog generation scripts will break, because the expect utf-8, which is my locale
03:04:58 <Igloo> (well, filenames pretty much have to be 8bit data, and it just has to break when you have non-utf8 names on FSes that don't like that)
03:08:26 <roconnor> @where list paste
03:08:26 <lambdabot> I know nothing about list.
03:08:31 <roconnor> @where paste
03:08:31 <lambdabot> http://paste.lisp.org/new/haskell
03:09:08 <lisppaste2> roconnor pasted "why does this not work in ghci" at http://paste.lisp.org/display/17450
03:09:27 <roconnor> getInfo "foo" just returns []
03:09:34 <roconnor> when run in ghci
03:10:17 <Lemmih> roconnor: hGetContents is lazy.
03:10:18 <tibbe> Lemmih, thanks
03:10:26 <Lemmih> roconnor: You close the file before reading anything.
03:10:51 <roconnor> this lazy reading stuff has to go!
03:11:22 <roconnor> @hoogle contents
03:11:23 <lambdabot> Control.Concurrent.Chan.getChanContents :: Chan a -> IO [a]
03:11:23 <lambdabot> Prelude.getContents :: IO String
03:11:23 <lambdabot> System.Directory.getDirectoryContents :: FilePath -> IO [FilePath]
03:11:42 <Lemmih> roconnor: Can't you use 'readFile'?
03:11:49 <roconnor> maybe
03:11:57 <roconnor> @hoogle readFile
03:11:58 <lambdabot> Prelude.readFile :: FilePath -> IO String
03:11:58 <lambdabot> System.IO.readFile :: FilePath -> IO String
03:12:02 <roconnor> sounds good
03:12:37 <roconnor> lazy IO makes no sense to me.
03:14:07 <sili> mynads
03:14:22 <Igloo> tuomov: Why the 1 on your username?
03:15:59 <tuomov> I don't know
03:16:32 <tuomov> maybe because I haven't registered?
03:17:14 * int-e sees no 1.
03:17:23 <Igloo> int-e: On the darcs BTS
03:17:23 <roconnor> @hoogle (a,b) -> (b,a)
03:17:23 <neologism> multiple personalities? :)
03:17:24 <lambdabot> No matches, try a more general search
03:17:30 <roconnor> @djinn (a,b) -> (b,a)
03:17:30 <lambdabot> f (a, b) = (b, a)
03:36:14 <roconnor> @hoogle a -> [a] -> Bool
03:36:15 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
03:36:15 <lambdabot> Data.List.notElem :: Eq a => a -> [a] -> Bool
03:36:15 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
03:49:48 <NotInventedHere> > fst (2, 1)
03:49:49 <lambdabot> 2
03:50:02 <NotInventedHere> @hoogle fst
03:50:03 <lambdabot> Data.Tuple.fst :: (a, b) -> a
03:50:03 <lambdabot> Prelude.fst :: (a, b) -> a
03:50:03 <lambdabot> Control.Parallel.Strategies.fstPairFstList :: NFData a => Strategy [(a, b)
03:50:03 <lambdabot> ]
03:50:19 <NotInventedHere> @where fst
03:50:19 <lambdabot> I know nothing about fst.
03:50:29 <NotInventedHere> @type fst
03:50:29 <lambdabot> forall a b. (a, b) -> a
03:50:46 <NotInventedHere> @type (+)
03:50:47 <lambdabot> forall a. (Num a) => a -> a -> a
04:13:25 <shapr> hi charles 
04:14:03 <shapr> Lotsa Haskell users at Google?
04:19:46 <mwc> Woot, Hoogle is becoming an official google project :D
04:19:55 <Cale> whoa
04:22:27 <SyntaxNinja> shapr!
04:22:37 <vincenz> Cale!
04:22:42 <Cale> hello
04:22:44 <vincenz> :D
04:22:55 <vincenz> my favourite mathematician after the guy in a beautiful mind
04:23:05 <shapr> hiya SyntaxNinja 
04:23:20 <Cale> heh
04:23:28 <vincenz> :d
04:23:40 <astrolabe> A slightly barbed compliment
04:23:50 <vincenz> why's that
04:24:02 <shapr> Because Nash was a bit odd?
04:24:11 <vincenz> yeah but he rocked
04:24:23 <shapr> I'm not sure the trade is worth it...
04:24:29 <vincenz> grr
04:24:31 <astrolabe> Mathematically he rocked.  Seemed to be a bit of a **** though
04:24:34 <vincenz> you people are getting oyur semantics wrong
04:24:37 <vincenz> I said my favourite
04:24:43 <vincenz> aka I like him best, then cale
04:24:49 <vincenz> that relates in no sense at all the weirdness
04:26:03 <Cale> what about Poincare, Galois, Euler, or Gauss? :)
04:26:04 <vincenz> Damn I just got advertised to in PM... but his guy reallytook his time
04:26:08 <vincenz> Cale: nope
04:26:18 <roconnor> Poincare!!!
04:26:22 <vincenz> tho da vinci outranks you too, but he's not really a mathematician
04:26:43 <astrolabe> Gauss is the man
04:27:00 <vincenz> why, cause of his line integral thingy?
04:27:30 <vincenz> gauss is just that... gauss....noise
04:27:35 <astrolabe> No.  Cos of loads of stuff, including practically inventing modular arithmatic
04:27:40 * vincenz shrugs
04:28:00 <Cale> Gauss and Euler were huge
04:28:10 <vincenz> yeah but they just don't impress me
04:28:25 <astrolabe> I'll grant you, Cale is a great, but who is this Nash guy?
04:28:25 <roconnor> I'm not sure you all realize the awsomeness that was Poincare.
04:28:34 <vincenz> roconnor: cause of his drawings?
04:28:57 <roconnor> he did drawings?
04:29:06 <vincenz> isn't it "poincare drawings"?
04:29:11 <vincenz> afaik that's a term
04:29:23 <jethr0_> gauss and euler were _huge_. they founded or expanded so many mathematical branches
04:29:25 <roconnor> oh, the poincare returns
04:29:27 <roconnor> yes
04:29:39 <SyntaxNinja> dcoutts: did you see simon marlow's post about cabal-setup?
04:29:39 * astrolabe doesn't realise the awesomeness that was Poincare.
04:29:42 <vincenz> I only have one hero
04:29:45 <vincenz> his name is da vinci
04:30:12 <roconnor> But I love how he would bash Zermelo's set theory.
04:30:13 <vincenz> he invented the helicopter half a millenia before it was built
04:30:29 <jethr0_> not to speak of archimedes and euclid
04:30:42 <jethr0_> they were _millenia_ ahead of their time :)
04:30:49 <vincenz> how's that?
04:30:57 <astrolabe> These things are difficult to argue with.  Somehow 'da vinci was a moron' isn't easy to say.
04:31:08 <vincenz> homo universalis
04:31:24 <vincenz> now I'll be blasphemous
04:31:25 <jethr0_> it's been ventured that archimedes already knew about integration as we know it. and euclid lay the foundations for what we know as math today
04:31:32 <vincenz> one of the people I felt was always overblown is einstein
04:31:35 <vincenz> that's such a hype
04:31:43 <astrolabe> Nooooo!
04:31:57 <lisppaste2> roconnor pasted "Poincare quite" at http://paste.lisp.org/display/17453
04:31:57 <astrolabe> What about his hair!
04:32:08 <vincenz> astrolabe: overblown too :P
04:32:16 <vincenz> literally
04:32:18 <jethr0_> mathematically einstein may well be a hype, but in respect to changing the way we view the world, einsteins ideas were pretty world-shaking
04:32:31 <vincenz> jethr0_: yeah but I think that's just attributable to the ideas of the time
04:32:39 <_llll_> he couldnt know integration as we know it today, as our conception of mathmatics is completely different
04:32:45 <vincenz> science always moves like that.;.. you have a body of mass
04:32:48 <astrolabe> vincenz: Do you think there were any better physicists in the last 3 centuries?
04:32:51 <vincenz> and then one guy gets it out in the open
04:32:59 <vincenz> astrolabe: honestly he's not that great
04:32:59 <_llll_> archimedes ddi calculate some volumes in a way that resembles what we now call integration
04:33:01 <jethr0_> although others did a lot too. uncertainty, quantum mechanics, ...
04:33:13 <vincenz> astrolabe: heisenberg perhaps?
04:33:14 <astrolabe> vincenz: honestly, he is.
04:33:29 * vincenz shrugs
04:33:33 <astrolabe> Not even close.
04:33:35 <jethr0_> _llll_: yes, but archimedes main text was vandalized and is now being tried to put back together again
04:33:55 <jethr0_> _llll_: and there are signs that he knew about the infinitesimal approach to integration
04:34:21 <_llll_> it still isnt integration
04:35:00 <jethr0_> _llll_: well if you were born a few thousand years ago, you might argue it out with him :)
04:35:24 <astrolabe> The ancient greeks were amazingly productive.
04:35:37 <vincenz> of course
04:35:47 <jethr0_> the greeks laid so many foundations to the sciences, it's amazing
04:36:21 <vincenz> again, the greeks were in the center of a trading place
04:36:25 <vincenz> they got many ideas from elsewhere
04:36:27 <jethr0_> and not just because they worked early on, but because their results were amazing. like measuring the earth circumference pretty exactly by measuring shadows... *great*
04:36:29 <vincenz> whenwill people look at science properly
04:36:33 <vincenz> it isn't the individual
04:36:41 <vincenz> it's the culmination of the time that is expressed through an individual
04:36:47 <vincenz> "stand on the shoulders of giant"
04:37:05 <vincenz> ...S
04:37:07 <jethr0_> you started with da vinci :)
04:37:16 <astrolabe> vincenz: Then why do a very few people repeatedly get the best results?
04:37:19 <_llll_> what does "Instance of Num (Int -> Int) required for definition of ..." mean?
04:37:41 <jethr0_> that you're trying to add a function and a number :)
04:37:48 <vincenz> astrolabe: it's obviously partly people, but much less than what people hype it to be
04:37:57 <jethr0_> _llll_: probably missing an argument somewhere
04:38:00 <vincenz> astrolabe: and as long as people take this individualistic stance on science, you'll get less advances
04:38:05 <vincenz> too much competition, not enough cooperation
04:38:18 <vincenz> anyways
04:38:19 <vincenz> time to cook dinner
04:38:38 * astrolabe goes into disagreement overload.
04:39:08 * jethr0_ 's not agreeing with vincenz either
04:39:52 <_llll_> hmm, why cant it tell me the line number where there is a problem?
04:40:13 * vincenz shrugs
04:40:19 <vincenz> astrolabe: you're doing research?
04:40:37 <jethr0_> _llll_: it usually does. what interpreter/compiler?
04:41:08 <astrolabe> vincenz: Sort of, not so much these days.
04:41:11 <_llll_> hugs, well it tells me the line number of the start of the definition
04:41:25 <jethr0_> vincenz: the greeks could well have laid back and enjoyed their life. instead these people went out and pondered their whole life about the geneisis of the universe, atoms, ethics, astrology, physics, maths, ...
04:41:28 <astrolabe> vincenz: Also it isn't really maths anymore.
04:41:31 <Cale> hmm
04:41:40 <Cale> _llll_: perhaps see if GHCi gives more info?
04:41:43 <jethr0_> they gotta get some credit for their hardships
04:42:17 <vincenz> jethr0_: you're missing my point
04:42:30 <vincenz> jethr0_: I never said "don't do anything"
04:42:31 <_llll_> i shall install ghc
04:42:40 <vincenz> jethr0_: I said, step off the comptetitive model
04:42:56 <Cale> _llll_: remember not to compile it yourself, get the binary version :)
04:43:26 <_llll_> well im just going to do apt-get install ghc
04:43:40 <Cale> ah, good
04:43:45 <Cale> apt-get install hc6
04:43:45 <vincenz> jethr0_: though you're european so you'll notice that less
04:43:49 <Cale> ghc6 rather
04:44:10 <_llll_> right, it's going now
04:45:18 <vincenz> jethr0_: feel free to come talk about it on #meta-science :D
04:45:48 <_llll_> ive found the line that doesnt work by commenting bits out, but i dont see the error yet.  (2*i) is allowed, when i<-[2..n] isnt it?
04:46:12 <Cale> _llll_: what's the surrounding context?
04:46:31 <Cale> i <- [2..n] would be allowed in a list comprehension, or in do-notation for the list monad
04:46:41 <_llll_> list comprehension
04:46:49 <Cale> is n in scope?
04:47:04 <_llll_> it should be
04:47:14 <Cale> er, which thing is being disallowed?
04:47:21 <Cale> can I see the whole line?
04:47:38 <_llll_> i dont know, it just says "need instance of Num (Int -> Int)
04:47:47 <_llll_> (foldl1 (++) [xprod (pair 1 (2*i)) (canfrom 2 ((2*i)-1)) (canfrom (2i+1) len)|i<-[2..n] ])
04:48:02 <Cale> okay
04:48:33 <Cale> what's the type of xprod?
04:48:43 <_llll_> xprod::Ord v=> [FiniteMap v v] ->[FiniteMap v v] -> [FiniteMap v v] -> [FiniteMap v v]
04:49:04 <_llll_> hmm, ghci cant find the module FiniteMap
04:49:17 <Cale> Data.FiniteMap
04:49:26 <Cale> though it's deprecated in favour of Data.Map
04:49:50 <_llll_> ah, ghci gives a better error
04:50:09 <_llll_> In the first argument of `canfrom', namely `((2 i) + 1)'
04:50:16 <Cale> aha
04:50:21 <Cale> yes :)
04:50:29 <_llll_> oh good grief
04:50:49 <_llll_> i cant believe that
04:51:15 <Cale> If you had an instance of Num for Int -> Int, then 2 would be interpreted as a function
04:52:34 <_llll_> this is like the time i had "while (i<n) do;" in pascal
04:53:07 <Cale> hehe
04:53:16 <_llll_> thanks for the help
04:53:20 <Cale> no problem
04:53:30 <_llll_> ghci seems cool
04:53:40 <Cale> yeah, it is pretty cool
04:53:52 <_llll_> so is Map the same as FiniteMap apart from the name?
04:53:58 <Cale> not quite
04:54:06 <palomer> instance Num (Int -> Int) where toInteger x = toInteger (x 0)
04:54:26 <Cale> Map's implementation is a bit faster, and the interface is a bit different
04:54:40 <palomer> Cale: asymptotically faster?
04:55:03 <Cale> I'm not sure if anything is asymptotically faster, but at least the constants seem etter
04:55:07 <Cale> b*
04:55:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
04:55:23 * davidhouse speaks from his brand new ubutunu install :)
04:55:55 <palomer> are there any container typeclasses?
04:56:02 * davidhouse is entering a programming competition next fri
04:56:07 <palomer> they would help avoid clashes between Prelude and Map
04:56:09 <davidhouse> and i'm not sure whether to use haskell or not...
04:56:27 <Cale> palomer: the problem is harder than you'd think
04:57:01 <palomer> how so?
04:57:03 <Cale> palomer: Say, for Data.Set, it would be nice to have an instance of Functor, right?
04:57:26 <palomer> sure
04:57:45 <Cale> but it can't be done, due to the additional Ord constraint on the element type
04:58:09 <palomer> ok
04:58:15 <Cale> it could perhaps be done for Data.Map
04:58:32 <Cale> but the same problem will show up in lots of places
04:58:32 <palomer> but I'm talking about grouping functions like "lookup" and "insert" into a typeclass
04:58:46 <Cale> @type Data.Map.lookup
04:58:47 <lambdabot> forall a (m :: * -> *) k.
04:58:47 <lambdabot>        (Ord k, Monad m) =>
04:58:47 <lambdabot>        k -> Data.Map.Map k a -> m a
04:59:00 <palomer> oh, right
04:59:02 <palomer> humph
04:59:14 <Cale> It's annoying, and a real problem
04:59:18 <palomer> very much
04:59:35 <palomer> but are there any container type classes at all?
04:59:59 <Cale> There isn't much in the standard libraries
05:00:05 <Cale> or in GHC's libraries even
05:00:16 <Cale> but people have been pushing around ideas
05:01:24 <Cale> http://www.cs.chalmers.se/~rjmh/Papers/restricted-datatypes.ps
05:01:29 <palomer> I mean, containers are a very important part of generic programming
05:01:32 <jethr0_> Cale: have you used the continuation monad? i'm looking for examples, tutorials, ... for shift/reset, but there's not much material out there :(
05:01:49 <jethr0_> and the papers are all a bit "operational semantics" oriented for my taste
05:02:54 <Cale> I've never found the need to put the continuation monad into a real program, but I've played around with it
05:03:34 <palomer> that paper is really interesting
05:03:43 <palomer> is there any push into getting this into ghc?
05:03:46 <Cale> jethr0_: is this the one you're talking about? http://www.haskell.org/hawiki/ContinuationsDoneRight
05:04:08 <palomer> wait, isn't it already in ghc?
05:04:21 <palomer> man, I have to learn about type inference with typeclasses one of these days
05:04:24 <Cale> palomer: well, there are some uglinesses to it still -- the need for programmers to know about well-formed-types and add constraints to their programs, for example
05:04:34 <vincenz> Cale: I read that as
05:04:39 <vincenz> ContinuationsDonsRight
05:04:41 <palomer> Cale: you could put the contraints in the constructor
05:04:49 <jethr0_> Cale: i'm just looking around for continuations to play with. you really never felt that the cont. monad could be used in a program?
05:05:01 <palomer> for set, it would be: Set :: forall a. Ord a => Set [a]
05:05:27 <palomer> this fits perfectly with the new gadt datatype syntax
05:05:51 <Cale> jethr0_: well, it's like having goto, but worse :)
05:06:02 <palomer> in fact, this could become a generalization to GADTs with type classes
05:06:26 <Cale> palomer: doesn't that throw away the element type?
05:06:45 <jethr0_> Cale: i think you're exaggerating. i liked the concept of continuations in scheme because they allowed all kinds of complex behaviour. at the cost of understandability. but lazyness takes away lots of reasons to keep continuations/coroutines/... around
05:06:48 <Cale> er, maybe I'm misreading that
05:07:15 <Cale> jethr0_: well, you really can write first-class gotos
05:07:17 <palomer> ah no, you're right, it does throw it away
05:07:56 <palomer> Cale: so the biggest problem is getting programmers to learn about this mechanism?
05:08:12 <Cale>  getCC :: MonadCont m => m (m a)
05:08:12 <Cale>  getCC = callCC (\c -> let x = c x in return x)
05:08:22 <Cale> palomer: well, it's a bit of an aesthetic thing
05:08:31 <Cale> palomer: read the whole paper and see what you think :)
05:09:12 <Cale>  test = (`runContT` return) $ do
05:09:12 <Cale>      jump <- getCC
05:09:12 <Cale>      lift $ putStrLn "hello!"
05:09:12 <Cale>      jump
05:09:44 <integral> that's an infinite loop, right?
05:09:46 <Cale> yes
05:10:03 <Cale> prints hello! over and over
05:10:20 <integral> getCC essentially returns the monad to the right of the >>= after the getCC itself?
05:11:26 <xerox> Howdy!
05:11:29 <xerox> shapr: I think so.
05:11:47 <vincenz> buona sera
05:11:48 <Cale> it captures the continuation -- all the stuff that would happen after it
05:12:42 <jethr0_> i think i'll look into composable continuations instead. non-delimited continuations always make my head hurt
05:13:03 <vincenz> they're like nasty gotos
05:13:20 <xerox> jethr0_: there's a nice article (with code!) from TheHunter on some TMR.
05:13:27 <jethr0_> ah, stop it you all. you've been spoiled
05:13:28 * xerox misses TheHunter - sniff
05:13:59 <jethr0_> vincenz: _i_ like the concept of continuations when it allows expressing a solution more succinctly
05:14:13 <vincenz> I like any concept that allows pristine, beautiful succint solutions
05:14:18 <jethr0_> same way "goto"s are considered acceptable for some problem in C.
05:14:29 <vincenz> gotos are never a solution
05:14:31 <Cale> jethr0_: I don't really know too much about shift/reset... apparently they're good for some MonadReader-like-stuff
05:14:39 <vincenz> especially in c++ where they completely fuck up destructors and constructors
05:14:42 <xerox> Indeed.  /me searches for some code
05:14:44 <Cale> these are better than gotos though
05:15:08 <palomer> does darcs need to be installed on a remote server for me to be able to darcs  put?
05:15:15 <vincenz> palomer: nope
05:15:15 <xerox> This one is cool, imo: <http://blog.moertel.com/articles/2005/09/13/scope-herding-with-delimited-continuations>
05:15:16 <davidhouse> anyone on ubuntu here? is ghc available in the standard universE?
05:15:18 <Cale> you can stick your jump labels into data structures and pass them around :)
05:15:20 <vincenz> palomer: file:///directory
05:15:29 <xerox> davidhouse: I am.
05:15:49 <vincenz> voglia una tipa italiana
05:15:54 <xerox> davidhouse: I see this for ghc6: *** 6.4.1-1ubuntu3 0 500 ftp://archive.ubuntu.com dapper/universe Packages
05:16:00 <Cale> xerox: I think you are pointing at exactly the thing I was thinking of
05:16:08 <jethr0_> vincenz: gotos can be _a_ solution in C when you have recurring cleanup code and instead of duplicating it, just jump to one point and the end of a function
05:16:08 <xerox> Cale: yes I think so too.
05:16:13 <davidhouse> xerox, which frontend? just plain apt?
05:16:22 <xerox> davidhouse: yes.  apt-cache policy ghc6
05:16:43 <vincenz> jethr0_: that's what destructors are for
05:16:48 <vincenz> and that's the reason c isn't a valid argument
05:16:50 <vincenz> :D
05:16:51 <jethr0_> vincenz: C doesn't have destructors
05:16:55 <davidhouse> xerox, which repos have you got set up?
05:17:01 * vincenz refers to point 2
05:17:05 <xerox> davidhouse: I'm using dapper.
05:17:14 <xerox> davidhouse: let me put the sources.list online.
05:17:52 <xerox> davidhouse: <http://haskell.galois.com/~paolo/sources.list>
05:19:19 <davidhouse> xerox, thanks
05:20:28 <xerox> davidhouse: you're welcome.
05:21:14 * vincenz shuts up with his silly sleep-deprv humor
05:21:37 <Phyx-> > [1..10] // (dropUntil 3 [1..10]) !! 1
05:21:38 <lambdabot>  Not in scope: `dropUntil'
05:21:41 <Phyx-> erm
05:22:04 <xerox> takeUntil?
05:22:15 <Phyx-> > [1..10] // (takeUntil 3 [1..10]) !! 1
05:22:15 <lambdabot>  Not in scope: `takeUntil'
05:22:26 <Phyx-> @type takeUntil
05:22:26 <lambdabot> Not in scope: `takeUntil'
05:22:29 <Phyx-> @type takeWhile
05:22:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:22:36 <xerox> (<3)
05:22:44 <jethr0_> vincenz: i'm not offended, but i'm off reading about delimited continuations
05:22:52 <Phyx-> xerox: the end list is not integers
05:23:11 <Phyx-> i want to remove from the list,the first occurence of the item
05:23:16 <Lor> Evening, folks.
05:23:23 <xerox> Phyx-: hmm.
05:24:13 <Cale> They never should have removed takeUntil and dropUntil
05:24:14 <palomer> vincenz: hmm? I'm transfering through ssh
05:24:24 <Lor> Hey, is there some established name for a "dotted number" like version numbers and section numbers, which are sequences of numbers that are compared lexicographically?
05:24:26 <xerox> Phyx-: only the first? I.e. remove 1 [1,1,2,3,1] ==> [1,2,3,1]
05:25:17 <Phyx-> xerox: yep
05:25:42 <SyntaxNinja> yay haskell.galois.com
05:26:50 <vincenz> palomer: oh
05:26:58 <vincenz> jethr0_: take care  and have fun
05:27:02 <jethr0_> thx
05:27:02 <vincenz> xerox: hai la tipa?
05:27:31 <palomer> cabal is at version 1.0?
05:27:32 <palomer> nice
05:27:34 <xerox> vincenz: no.
05:27:36 <xerox> Phyx-: I got one.
05:27:40 * xerox hugs SyntaxNinja 
05:28:03 <vincenz> xerox: communque vissendo in italia ne deve vedenre in giro
05:28:04 <xerox> > let remove x = reverse . snd . foldl (\(done,ys) y -> if x == y && not done then (True,ys) else (done,y:ys)) (False,[]) in remove 1 [1,1,2,3,1]
05:28:05 <lambdabot> [1,2,3,1]
05:28:12 <vincenz> xerox: una delle cose che mi manca di piu del' italia
05:28:14 <xerox> vincenz: "vivendo", heh.
05:28:30 <vincenz> xerox: le tipe e la maniera d'uscire
05:28:44 <vincenz> xerox: I never learned to write italian... it comes more fluent spoken than writtn
05:29:04 <xerox> vincenz: quite ok :-)
05:30:25 <vincenz> cmq mi manca l'italia
05:30:30 <vincenz> :/
05:30:49 <Phyx-> nice :D
05:30:56 * Phyx- thanx vincenz 
05:31:01 <vincenz> Phyx-: with?
05:31:12 <vincenz> woot, I'm good
05:31:16 <vincenz> I get thanked for idling
05:31:20 <xerox> Phyx-: you could also write it as:
05:31:41 <Phyx-> ohh rofl. it was xerox who helped me
05:31:53 * Phyx- takes the thanx back from vincenz and hands it to xerox 
05:32:40 <Phyx-> xerox: that one's so complited i can't use it. it works, but i won't be able to explaint it to the teacher
05:33:20 <xerox> remove :: (Eq a) => a -> [a] -> [a]
05:33:20 <xerox> remove x xs = reverse . snd . foldl f (False,[]) xs
05:33:20 <xerox>   where f (done,ys) | x == y && not done = (True,  ys)
05:33:20 <xerox>                     | otherwise          = (done,y:ys)
05:34:12 <xerox> Cale: it's some time that I'm looking for a nice idiom to express this fold-with-state that have some n-tuple as 'k' value... do you have any ideas?
05:35:46 <xerox> Phyx-: does it make any sense?
05:37:31 <Cale> xerox: hmm
05:40:17 <astrolabe> What is y?
05:40:38 <xerox> astrolabe: the item of the list being folded.
05:41:13 <xerox> foldl (\acc y -> ..) acc (y:ys)
05:41:22 <xerox> foldr (\y acc -> ..) acc (y:ys)
05:42:08 <astrolabe> Is it in the environment?
05:42:21 <SyntaxNinja> xerox: someday I will tell the story of haskell.galois.com.
05:42:44 * xerox will sit on the bench and listen carefully
05:42:45 <davidhouse> SyntaxNinja: i'm sitting comfortably
05:42:51 <xerox> astrolabe: environment?
05:43:17 <xerox> astrolabe: <http://cale.yi.org/autoshare/folds.png>
05:43:33 <astrolabe> the context, is it defined outside of what you are showing here?
05:43:43 <xerox> astrolabe: nope.
05:43:53 <xerox> ops.
05:43:57 <astrolabe> Oh that's nice
05:44:11 <xerox> I'm sorry!  It is:
05:44:12 <xerox>   where f (done,ys) y | x == y && not done = (True,  ys)
05:44:12 <xerox>                       | otherwise          = (done,y:ys)
05:45:03 <astrolabe> Ah :)
05:45:05 <cinema> Has anyone seen the story on slashdot concerning Sony's Ps3, and the comment by Cyricz titled "More emphasis on functional languages" ?
05:45:10 <SyntaxNinja> :)
05:45:24 <Cale> cinema: url?
05:45:41 <cinema> It's been modded: "Score:2, Funny" !
05:46:00 <cinema> Url : http://games.slashdot.org/article.pl?sid=06/03/03/1615248&from=rss
05:46:19 <cinema> The comment cites Haskell
05:46:29 <Cale> http://games.slashdot.org/comments.pl?sid=179141&cid=14843757
05:46:31 <Cale> that one?
05:47:12 <cinema> exactly
05:47:52 <cinema> Classifying it as funny is the saddest thing I've seen for at least a mont
05:48:00 <cinema> s/mont/month/
05:48:33 <jyp> The poster says haskell is strict... That is funny :)
05:49:19 <cinema> jyp, sure, I hadn't seen things that way
05:52:35 <Phyx-> xerox: not really :P
05:52:48 <xerox> Phyx-: sorry?
05:53:38 <Phyx-> 20:49:25 < xerox> Phyx-: does it make any sense?
05:53:57 * davidhouse is entering a programming contest on friday
05:54:07 <davidhouse> i'm not sure whether or not to use haskell
05:54:13 <Phyx-> xerox: where did y come from
05:54:40 <Phyx-> ohh
05:54:41 <Phyx-> nvm
05:54:42 <Phyx-> i see it
05:54:47 <xerox> Phyx-: I corrected it afterwards, sorry again.
05:55:50 <Phyx-> :P
05:59:37 <Phyx-> xerox: one question i'm doing x@((a,b,c,d):xs) how can i see if x is the first element in the list?
05:59:59 <xerox> (x@(a,b,c,d):xs)
06:00:04 <xerox> If you want :-)
06:00:12 <Cale> in the first, x is the whole list
06:00:47 <Phyx-> hmmm
06:01:03 <xerox> "x@" just add a synonym.
06:01:07 <Phyx-> so with (x@(a,b,c,d):xs) x is always the first?
06:01:12 <Cale> yes
06:01:20 <Cale> and x = (a,b,c,d)
06:01:25 <Phyx-> i thought it was the head of the list
06:01:35 <Phyx-> it keeps changing everything the function is called
06:01:38 <Cale> it is the head of the list -- is that not the same thing?
06:01:39 <Phyx-> :|
06:01:41 <davidhouse> what's the list of?
06:01:47 <davidhouse> is it not a list of quadruples?
06:01:48 <xerox> davidhouse: of quadruples.
06:01:52 <davidhouse> then it's the same hing
06:01:55 <davidhouse> *thing
06:02:03 <xerox> What is the same thing?
06:02:12 <sethk> the same hing as what?
06:02:16 <davidhouse> x and the head of the list
06:02:26 <Phyx-> what i'm trying to do isn't the same...
06:02:38 <davidhouse> Phyx-: what are you trying to do?
06:02:55 <Phyx-> davidhouse: honestly, i forgot...
06:03:00 <Phyx-> damn tv
06:03:31 <Phyx-> ahh
06:03:35 <Phyx-> i know again
06:03:49 <Phyx-> there's an action that i only need to do with the first argument and the last of the list
06:04:06 <Phyx-> while the list loops, i can't use the head since that constantly changes
06:05:23 <cinema> Is anyone using hIDE to develop haskell programs ?
06:05:37 <cinema> Or is it too early ?
06:06:13 <Cale> too early
06:06:25 <cinema> Cale, thanks
06:06:42 * xerox awws
06:07:00 <Cale> unless someone has some good news :)
06:07:27 <davidhouse> can it save files yet?
06:10:42 <sethk> I haven't really done much more than glance at hIDE.  I will, as soon as I hear that it will be useful.
06:11:21 <Lemmih> davidhouse: Yes, it can. Finally! (:
06:11:40 <Lemmih> cinema: It's a bit too early.
06:12:07 <xerox> Lemmih: what about dropping the plugin platform?
06:12:54 <davidhouse> Lemmih: then what are we waiting for? ;)
06:12:58 <davidhouse> when will it be usable?
06:13:38 <Lemmih> When GHC-6.6 is out.
06:14:16 <cinema> Lemmih, I'll wait a little then
06:14:55 <davidhouse> Lemmih: and when will that be?
06:16:19 <Lemmih> davidhouse: In a couple of months.
06:16:35 <davidhouse> Lemmih: awesome.
06:19:06 <davidhouse> Lemmih: any info on what the final name will be? i kinda like hIDE but i saw the name competition on the wiki...
06:23:01 <astrolabe> I'm reading 'All About Monads'.  It references this paper http://www-internal.cse.ogi.edu/~mpj/pubs/springschool95.ps, and says it inspired the Haskell monad template library.  Reading the abstract, it seems to be about other things.  Have they referenced the correct paper?
06:23:33 <Lemmih> davidhouse: It'll probably settle on 'hIDE'. Haven't thought about it much, tho.
06:24:01 <davidhouse> Lemmih: funky.
06:25:16 <xerox> astrolabe: I think I agree something wrong was linked.  Tho it seem to be a cool paper.
06:27:56 <astrolabe> xerox: Thanks.  I agree it looks good.
06:31:08 <Cale> cinema: http://games.slashdot.org/comments.pl?sid=179141&cid=14845534
06:31:43 <astrolabe> I guess this is the one that was meant http://wiki.ittc.ku.edu/lambda/images/f/f4/Jones_-_Composing_Monads.pdf
06:37:26 <xerox> Cale: wow, you're "active" on slashdot :-)
06:37:50 <Cale> eh
06:38:18 <Cale> Someone posted that comment here, and due to the fact that it was being modded funny, I thought I'd reply
06:40:29 <xerox> Cale: I mean wrt your curricula of replies.. heh ;-)
06:40:44 <Cale> I'm not that active
06:41:07 <xerox> Cale: could you suggest a good reading (like the hyperreal's one) about complex numbers?
06:42:16 <goron> xerox: can't you better read a real book? 
06:42:17 <Cale> http://en.wikipedia.org/wiki/Complex_numbers ?
06:42:49 <xerox> That was simple.  Heh.
06:43:07 <_llll_> "complex numbers" in and of themselves arnt really a huge subject.  maybe read about Galois theory or complex analysis for why they are useful
06:43:26 <xerox> goron: if another book will enter this room I'll be forced to get out... somehow :-)
06:43:47 <cinema> Cale, nice answer
06:43:59 <goron> xerox: now the question becomes: do you have a small room or a lot of books :D
06:44:01 <Cale> xerox: they're also covered in Spivak to some extent
06:44:23 <Cale> xerox: Chapter 25
06:44:24 <xerox> Cale: /me flies to check
06:44:27 <xerox> Great.
06:44:39 <xerox> goron: both?  Yay.
06:48:59 <xerox> Cale: <http://sigfpe.blogspot.com/> the second-last post is pretty nice :-)
06:50:59 <jips> @seen dons 
06:51:00 <lambdabot> dons is in #haskell. Last spoke 16 hours and 11 seconds ago.
06:52:22 <Cale> xerox: the cautionary tale?
06:52:23 <Cale> yeah
06:53:43 <xerox> Yup.
06:54:59 <palomer> oh my god.
06:55:07 <Cale> that is pretty sweet :)
06:55:21 <xerox> (:
06:56:40 <Cale> the paper it references looks nice too
06:57:30 <xerox> I skimmed it but I don't know enough about integration. :-\
06:58:38 <xerox> I find funny that it starts with: "A conjecture stated that: <formula> Indeed, .." heh.
07:02:53 <ski> composable continuations could possibly make monad implementations more efficient
07:06:34 <Phyx-> http://www.rafb.net/paste/results/RoELwz84.html
07:07:11 <Phyx-> can anyone help little old me?
07:07:26 <TuringTest> maybe
07:07:30 <Phyx-> http://www.rafb.net/paste/results/RoELwz84.html
07:07:44 <astrolabe> just maybe?
07:07:54 <TuringTest> "m = getMins a" looks wrong....what is a?
07:08:40 <xerox> Cale: hee hee, that sigfpe guy does Haskell too! <http://homepage.mac.com/sigfpe/Computing/haskell.html>
07:09:12 <Phyx-> TuringTest: oops, that's one problem
07:09:13 <Phyx-> lemme see
07:09:30 <Phyx-> instead of x there used to be (a,b,c,d):xs
07:09:36 <Phyx-> but i needed the whole thing also
07:10:48 <TuringTest> x@((a,b,c,d):xs)
07:10:55 <TuringTest> That capture the whole thing as x
07:12:23 <Phyx-> once i do plan xs e f
07:12:28 <Phyx-> i lost the "whole" thing
07:12:32 <TuringTest> http://www.haskell.org/onlinereport/exps.html#pattern-matching describes these "as patterns"
07:13:17 <TuringTest> sounds like you may need a helper function
07:13:33 <Phyx-> yeah
07:13:36 <Phyx-> i changed it a bit
07:13:43 <Phyx-> and it's been "compiling" ever since
07:14:36 <TuringTest> "useable" is not being used by anything
07:14:45 <TuringTest> neither is "total"
07:14:46 <Phyx-> not yet
07:14:49 <Phyx-> not yet
07:14:57 <Phyx-> i'm trying to build up the variable that i would need
07:15:08 <Phyx-> my main problem is getting the beginning and end
07:15:21 <Phyx-> maybe i should just change the function to give the head and the last elem
07:15:55 <TuringTest> You should not use "f" in "plan x e f" and "where f ...."
07:16:02 <TuringTest> I can't tell which is being shadowed
07:17:07 <TuringTest> normally both would be visible to the recursive call (plan xs e f) so one must be shadowing the other
07:18:48 <Phyx-> hold on
07:18:52 <Phyx-> i'm changing it
07:20:10 <Phyx-> x@((a,b,c,d):xs)
07:20:24 <Phyx-> does x refer to (a,b,c,d) or to (a,b,c,d):xs ?
07:21:08 <ramza3> hello
07:21:54 <Phyx-> TuringTest: ?
07:21:57 <Lemmih> Phyx-: The latter.
07:22:03 <TuringTest> Oh hi
07:22:12 <Phyx-> thanx Lemmih 
07:22:14 <astrolabe> hi ramza
07:22:16 <TuringTest> Phyx-: The whole thing
07:25:19 <Phyx-> :|
07:29:08 <Phyx-> TuringTest: rewrote it 2 http://www.rafb.net/paste/results/6Czz9N33.html
07:30:30 <TuringTest> Phyx-: if it complies then it works
07:30:40 <TuringTest> s/complies/compiles/
07:32:03 <TuringTest> plan x@(h:xs) e f = doPlan x  h (last xs) e f
07:32:18 <TuringTest> This is what you mean, with shorter syntax
07:32:55 <TuringTest> plan x e f = doPlan x (head x) (last x) e f
07:33:06 <TuringTest> This seems to mean the same thing
07:34:22 <TuringTest> plan x g h= doPlan x (head x) (last x) g h
07:34:36 <TuringTest> This matches the dummy variable names, but you'll be renaming those anyway
07:35:09 <Phyx-> ohh yeah
07:35:17 <Phyx-> forgot i don't need the (a,b,c,d) anymor
07:45:00 <Phyx-> http://www.rafb.net/paste/results/VUI7Qs82.html
07:45:16 <Phyx-> how come m get's printed once and first over and over and over again
07:46:19 <xerox> Goodnight.
07:47:21 <TuringTest> Phyx-: The goal of your function is very unclear to me.
07:48:40 <Phyx-> TuringTest: i'm just trying to populate a function at this time that shows how much time there is between 2 periods
07:48:56 <Phyx-> it gives me [0,120,105,0,120,30,0,120,105]
07:49:00 <Phyx-> instead of
07:49:08 <Phyx-> it gives me [0,120,105,30,105]
07:49:10 <Phyx-> :|
07:49:28 <TuringTest> Right
07:49:41 <TuringTest> It did what you said, not what you meant.
07:50:01 <Phyx-> yes
07:50:08 <Phyx-> how do i make it not repeat those...
07:50:18 <Phyx-> i though about putting them in the empty case
07:50:19 <Phyx-> but
07:50:23 <lisppaste2> TuringTest pasted "to be annotated" at http://paste.lisp.org/display/17459
07:50:57 <jethr0_> Phyx-: could you explain in english what the algo is supposed to do. it's rather hard to determine from the code alone
07:57:46 * jethr0_ goes away again
07:59:16 <SyntaxNinja> dcoutts alive?
08:15:57 <Excedrin> does ghc optimize Data.Map so that inserts aren't recreating the entire structure?
08:16:59 <norpan> why should they
08:17:28 <sjanssen> Excedrin: no, but only O(log n) nodes have to be recreated
08:41:19 <Yagi> hiz
08:42:37 <ski> hi Yagi
09:28:05 <Phyx-> i wanna slap the guy who invented the concept of functional programming
09:31:14 <Philippa> any particular reason, or are you just not getting it yet?
09:44:50 <TuringTest> Ah...I had to learn more about Parsec to fix a subtle bug I had.
09:45:05 <TuringTest> I really should put up a wiki page about Parsec combinators
09:45:57 <Phyx-> TuringTest: i need a starting point
09:46:04 <Phyx-> i've done 2 much haskell for 1 day
09:46:18 <Phyx-> but i'm missing this last assignment
09:46:48 <TuringTest> assignment? Do you mean homework or binding?
09:47:14 <Phyx-> it's about planning, you get in a Agenda, with daily stuff already planned, then you get a time interval And then list of stuff 2 plan into
09:47:14 <sethk> TuringTest, or maybe he assumed your mortgage
09:47:14 <SyntaxNinja> Phyx-: functional programming is great!
09:47:19 <Phyx-> homework
09:47:24 <Phyx-> so, what i do now
09:47:34 <Phyx-> is, i start of by filling in all blank spaces
09:47:41 <Phyx-> and marking how long they are
09:48:21 <Phyx-> and later on, fit the appoints that fit into the blank spaces one at a tiime and recalculating blank spaces
09:48:29 <Phyx-> atleast, what it *should* be doing
09:49:00 <TuringTest> Ah...that is much clearer an explanation that "abcdefgh"
09:50:57 <TuringTest> Phyx-: So you have a list of occupied intervals, a target interval which will partially overlap the occupied list, and a list of event durations to insert into the target interval without overlapping the occupied stuff or each other.
09:51:29 <Phyx-> yeah
09:51:54 <Phyx-> but the list contains whole appointments, so not only intervals, but text etc
09:53:11 <TuringTest> That's a knapsack problem with a set of knapsacks...
09:53:38 <TuringTest> Phyx-: The extra data is easy to tote along.  The problem is when to schedule the new events.
09:53:55 <TuringTest> http://www.nist.gov/dads/HTML/knapsackProblem.html
09:54:14 <Phyx-> yeah, that is the problem
09:54:52 <TuringTest> Okay..so I know the problem now.  Will a solution placing all the events always exist?
09:54:52 <Phyx-> and another problem i have
09:55:07 <Phyx-> is that, the first appointment, can start later then the given interval
09:55:08 <TuringTest> Are you supposed to find the "best solution" if some do not fit? 
09:55:17 <Phyx-> in which case, appointments can be scheduled before it
09:55:58 <Phyx-> but, if i keep calling the same function over and over, i dunno where the first one is
09:56:00 <TuringTest> Phyx-: You need to create a list of available intervals.  The format should be (start time, duration)
09:56:10 <Phyx-> some do not fit
09:56:28 <TuringTest> You build this using the prior events and the target interval.
09:56:37 <Phyx-> i tried
09:56:43 <Phyx-> but like i did before
09:56:49 <Phyx-> it kept repeating data
09:57:18 <TuringTest> Phyx-: Could you put your latest attempt on http://paste.lisp.org/  (channel #haskell)  ?
09:57:34 <TuringTest> (or just annotate http://paste.lisp.org/display/17459 )
09:58:04 <Phyx-> i deleted everything, one sec, lemme finish writting this one
10:03:41 <Phyx-> damn code.... i feel like a n00b all over again
10:05:42 <zce> do you know what's gray and proves the uncountability of real numbers?
10:07:48 <TuringTest> Zorn's pet rock?
10:08:00 <zce> Cantor's diagonal elephant.
10:08:37 <TuringTest> What's round, purple and commutes?
10:08:43 <zce> an abelian grape?
10:08:50 <Phyx-> barney
10:08:59 <zce> What do you get when you cross a mosquito with a rock climber? 
10:09:08 <TuringTest> (an old joke)
10:09:33 * zce repeats his question
10:10:14 <TuringTest> Vector by a scalar is a type error
10:10:29 <zce> right.
10:10:45 <zce> What's yellow, normed, and complete?
10:11:17 <TuringTest> An Bananach space
10:11:26 <TuringTest> Foolproof: A Sampling 
10:11:26 <TuringTest> of Mathematical Folk 
10:11:26 <TuringTest> Humor
10:11:50 * zce is getting them from here: http://dominic-mazzoni.com/mathanswers.html
10:12:07 <TuringTest> An engineer, a physicist, and a mathe- 
10:12:07 <TuringTest> matician find themselves in an anec- 
10:12:07 <TuringTest> dote, indeed an anecdote quite similar to 
10:12:07 <TuringTest> many that you have no doubt already 
10:12:08 <TuringTest> heard. After some observations and 
10:12:09 <TuringTest> rough calculations the engineer realizes 
10:12:12 <TuringTest> the situation and starts laughing. A few 
10:12:14 <TuringTest> minutes later the physicist understands 
10:12:16 <TuringTest> too and chuckles to himself happily, as 
10:12:18 <TuringTest> he now has enough experimental evi- 
10:12:20 <TuringTest> dence to publish a paper. This leaves 
10:12:21 <TuringTest> the mathematician somewhat perplexed, 
10:12:24 <TuringTest> as he had observed right away that he 
10:12:26 <TuringTest> was the subject of an anecdote and de- 
10:12:27 <TuringTest> duced quite rapidly the presence of 
10:12:30 <TuringTest> humor from similar anecdotes, but con- 
10:12:32 <TuringTest> siders this anecdote to be too trivial a 
10:12:34 <TuringTest> corollary to be significant, let alone 
10:12:36 <TuringTest> funny.
10:12:39 <greenrd> lol
10:13:17 <TuringTest> zce: Whats sour, yellow, and equivalent to the Axiom  of Choice? 
10:13:26 <integral> zorn's lemon
10:13:51 <TuringTest> What is brown, furry, runs to the sea, and is equivalent to the Axiom of Choice?
10:14:04 <mauke> zorn's lemming?
10:15:07 <zce> What is the world's longest song?
10:16:10 <zce> "Aleph-nought Bottles of Beer on the Wall."
10:16:50 <tuomov> The university administration is trying to decide wheter to fund the physicists, the mathematicians or philosophers. The physicists appeals aren't received well, because they need very expensive equipment. The mathematicians are much less costly, as they only need, pencil, paper, and a garbage bin. But the philosophers, they don't even need a garbage bin.
10:17:39 <TuringTest> nice
10:17:50 <zce> cheap shot.
10:19:02 <TuringTest> My favorite:
10:19:04 <TuringTest> An engineer, a physicist, and a mathe- 
10:20:28 <zce> yes?
10:20:49 <jips> i think that's it
10:21:16 <TuringTest> ..And then the mathematician hears a noise, looks out the window, sees the firetrucks and says "Ah, it is not unique!"
10:21:44 <TuringTest> (the end)
10:22:25 <zce> that's like a bad remix of a bad joke.
10:26:19 <SyntaxNinja> dcoutts: w00t
10:26:48 <jips> dcoutts is here?
10:27:08 <SyntaxNinja> jips: I'm just poking just in case.
10:27:51 <jips> hm.... does that work? dons: w00t
10:28:29 <zce> @w00t
10:28:29 <lambdabot>  @where <key>, return element associated with key
10:30:14 <SyntaxNinja> jips: only if I do it.
10:31:54 <zce> may I attempt to say one word with the explicit promise from the channel authorities not to get banned or anything?
10:32:21 <jips> you may proceed with my blessing
10:32:28 <zce> startkeylogger
10:32:34 <zce> no one? :-P
10:33:20 <jips> hm... that was in the topic of one of my other channels... but i've just got on the grid after being off for 2 weeks so i'm not sure what it's supposed to mean
10:33:54 <Plex> it causes mIRC to be closed by Norton Firewall
10:34:02 <TuringTest> zce: Bah.  Your jedi mind tricks will not work on me
10:35:14 * zce is wasting time at bash.org
10:35:14 <zce> <defekt> eh, some muslims just burned the swiss flag as a danish flag
10:35:15 <zce> <naama-> it's the thought that counts
10:37:59 <zce> <M3rlin-> what is the legal age to buy alcoholic in england ?
10:37:59 <zce> <p5Ds13a06> you cant buy alcoholics
10:37:59 <zce> <p5Ds13a06> but if you wink the right way, some of them will follow you home for free
10:38:41 <SyntaxNinja> zce: spare us bash.org
10:38:58 <zce> I'm just bored. I guess y'all are not as bored as me.
10:39:34 <SyntaxNinja> bash.org is like road-kill.  gross, but hard not to look ;)
10:40:16 <zce> I am way too bored.
10:40:23 <jips> i think the guys just like to keep this channel tightly on topic as much as possible. this makes it one of the best irc channels i know of :)
10:40:53 <zce> people don't gripe about off-topicness when I go off about group theory or something.
10:40:57 <SyntaxNinja> we have spill-over channels for the fun stuff (#haskell-blah)
10:41:07 * zce is a bit too drunk for group theory right now.
10:41:34 <jips> group theory is on topic
10:41:42 <zce> how so?
10:42:07 <jips> pretty much anything related to mathematics is on topic i think
10:42:40 <zce> Haskell and FP involves a lot of mathematical  background, I guess, but group theory is apparently not related.
10:42:55 <zce> Is "history of babylonian mathematics" on topic?
10:43:12 <Excedrin> questions about what's on topic are not on topic
10:43:59 <int-e> zce: there's a #haskell-blah channel; I think off-topic discussion is welcome there.
10:44:14 <zce> I ssee.
10:44:23 <zce> I'm sorry if I presented an annoyance.
10:50:03 <SyntaxNinja> zce: you're fine.
10:56:57 <Lemmih> Phew. That was a large one.
10:56:59 * Lemmih sends off his patch and heads for bed.
10:59:37 <SyntaxNinja> Lemmih: patch?
11:00:25 <Lemmih> SyntaxNinja: For GHC, not cabal-get, unfortunately (:
11:00:28 <SyntaxNinja> bah
11:08:55 <dons>  I think it's about the quality of the connectoin, and the fact we don't attempt to discover when we've been disconnected.. it's not so much a heisenbug, as 
11:11:20 <xz> is it possible to use pattern matching for the end of a string? for example i want a function that does this: func c++"end" = do_something_to c
11:12:05 <xz> c could be more than one character long, so i don't want to use :
11:13:09 <mauke> @index isSuffixOf
11:13:10 <lambdabot> Data.List
11:13:53 <mauke> maybe something like func c | "end" `isSuffixOf` c = ... 
11:17:17 <xz> mauke: where is that function?
11:17:33 <xz> mauke: thanks for the suggestion - i'll try that.
11:18:04 <xz> also how could i do something like func "start"++end = do_something_to end ?
11:18:20 <xz> do i have to spell it out like 's':'t':'a':'r':'t':end ?
11:18:56 <mauke> you have to spell it out or use isPrefixOf
11:19:09 <xz> mauke: ok thanks
11:19:10 <mauke> ++ isn't a constructor so you can't use it in pattern matches
11:19:35 <Lor> regex patterns would be pretty neat at times.
11:19:45 <liyang> Use guards.
11:20:19 <liyang> f x | p x = bar only matches when p x holds.
11:20:30 <xz> liyang: yes i know
11:20:57 <mauke> hmm, "p" ++ s patterns should be easy to implement as an extension
11:21:02 <liyang> that was in reply to the regex patterns comment...
11:21:40 <xz> mauke: if i use isSuffixOf, how can i then extract the bit of string that didn't match?
11:23:27 <ihope> So what's the shortest Haskell quine out there?
11:23:37 <ihope> Fifty characters is the best I can do.
11:23:52 <ihope> main=x++(show x)where x="main=x++(show x)where x="
11:24:01 <ihope> Erm, wait.
11:24:09 <liyang> xz: obviously you need something more general than isSuffixOf. :)
11:24:42 <mauke> naive way: take (length c - 3) c
11:24:50 <ihope> 62: main=putStr(x++show x)where x="main=putStr(x++show x)where x="
11:25:04 <xz> liyang: yeah i want to match certain bits of string against the argument and use the remaining string in the function. the matches are at the end at the start and also in the middle sometimes
11:25:54 <ihope> All but the last three elements? (init . init . init)
11:26:01 <xz> mauke: i don't know what i will do when i want to match stuff++"match"++morestuff though
11:27:30 <Lor> Then you use a real lexer.
11:28:29 <xz> Lor: can i do that in haskell?
11:28:41 <Lor> Do what?
11:29:20 <Lor> You can use lexer combinators, or alex if you prefer (I don't).
11:30:19 <xz> Lor i'm new to haskell - is there something i can search for on haskell.org to find out more about how to use regex in haskell for pattern matching?
11:30:29 <ihope> @pl \x -> nose x
11:30:30 <lambdabot> nose
11:30:56 <ihope> @pl \x -> id (id x)
11:30:57 <lambdabot> id
11:31:14 <ihope> @pl \x -> const x 3
11:31:14 <lambdabot> id
11:31:26 <ihope> @pl (>>= return)
11:31:27 <lambdabot> id
11:31:32 <jips> hm... type safe programming can be difficult
11:32:03 <ihope> isForEverybody haskell = false
11:32:15 <ihope> Or, rather, False.
11:32:36 <Lor> xz, read about parser combinators. They are pretty nifty if you do any non-trivial text processing.
11:33:05 <Igloo> @pl \x -> putStr (x ++ show x)
11:33:06 <lambdabot> putStr . ap (++) show
11:33:48 <Lor> Dang, that's neat.
11:34:14 <Igloo> @index ap
11:34:14 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.
11:34:14 <lambdabot> State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont,
11:34:14 <lambdabot> Control.Monad.Error, Control.Monad.List, Data.Graph.Inductive.Query.
11:34:14 <lambdabot> ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:34:35 <Igloo> Hmm, main=(\x->putStr$x++show x)"main=(\\x->putStr$x++show x)" is shorter anywya
11:35:46 <Lor> main=putStr.ap(++)show$"main=putStr.ap(++)show$"
11:35:58 <Igloo> You need an import for that
11:35:59 <Lor> That would be shorter, _if_ ap were in prelude.
11:36:56 <Lor> A prelude-only variant of @pl would be nice.
11:43:17 <ihope> Lor: fix and ap being in the Prelude would be nice ;-)
11:43:18 <bilbo> @index mkRegex
11:43:19 <lambdabot> Text.Regex
11:43:26 <bilbo> Try the Text.Regex package.
11:43:42 <ihope> @pl fmap id
11:43:42 <lambdabot> id
11:43:57 <bilbo> That was for xz
11:44:28 <ihope> @pl \x -> (>>= (return . x)
11:44:28 <lambdabot> (line 1, column 8):
11:44:28 <lambdabot> unexpected ">"
11:44:28 <lambdabot> expecting lambda abstraction or expression
11:45:11 <ihope> @pl \x -> (>>= (return . x))
11:45:11 <lambdabot> fmap
11:45:36 <ihope> Arr, it be smart.
11:46:27 <ihope> I have an expression that, after being run through @pl, doesn't typecheck. (Yes, it does typecheck before being sent through.)
11:47:03 <ihope> @type
11:47:04 <lambdabot> not an expression: `'
11:47:29 <ihope> @type
11:47:29 <lambdabot> not an expression: `'
11:47:41 <ihope> Whoops.
11:48:02 <ihope> @type (\x -> x x :: (forall a. a -> a) -> b -> b)
11:48:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> (a -> a) ->
11:48:03 <lambdabot> b -> b
11:48:03 <lambdabot>   Expected type: t
11:48:27 <ihope> @type ((\x -> x x) :: (forall a. a -> a) -> b -> b)
11:48:28 <lambdabot> forall b.
11:48:28 <lambdabot>                  (forall a. a -> a) -> b -> b
11:48:54 <ihope> Well, there you have it. A self-application that doesn't take very many things.
11:49:17 <ihope> But it's still better than the one without a type annotation.
11:49:20 <Lor> Does ghc support impredicative polymorphism nowadays?
11:49:30 <ihope> Ermp, what's that?
11:49:36 <Lor> That's what you're doing.
11:49:50 <ihope> Oh.
11:49:55 <Lor> You're instantiating the a in forall a. a -> a with a polymorphic type, namely forall a. a -> a.
11:50:02 <Lor> That's impredicative.
11:50:28 <ihope> @type (\x -> x x) :: (forall a. (a -> a) -> a -> a) -> b -> b
11:50:29 <lambdabot>   Couldn't match the rigid variable `b' against `t -> t1'
11:50:29 <lambdabot>   `b' is bound by the polymorphic type `forall b.
11:50:45 <int-e> @type id
11:50:46 <lambdabot> forall a. a -> a
11:50:49 <int-e> @type const undefined
11:50:50 <lambdabot> forall a b. b -> a
11:50:56 <ihope> @type (\x -> x x) :: (forall a. (a -> a) -> a -> a) -> (b -> b) -> b -> b
11:50:57 <lambdabot> (forall a. (a -> a) -> a -> a) -> (b -> b) -> b -> b :: forall b.
11:50:57 <lambdabot>                         (forall a.
11:50:57 <lambdabot>                         (a -> a) -> a -> a)
11:50:57 <lambdabot>                         -> (b -> b)
11:50:57 <lambdabot>                         -> b
11:50:59 <lambdabot>                         -> b
11:51:28 <int-e> what other simple terms of type forall a.a->a are there?
11:51:31 <ihope> Don't send so many messages; my very, very bad IRC client can't handle it.
11:51:41 <ihope> undefined
11:52:08 <ihope> Are there any other such terms that are actually meaningful?
11:52:19 <ihope> I think not.
11:52:58 <ihope> Anyway, this nice new self-application now takes any Church numeral.
11:54:14 <ihope> Now what's ((a -> a) -> a -> a) -> (a -> a) -> a -> a?
11:54:27 <ihope> It's a Church numeral transformity thingy!
11:54:32 <int-e> hmm, so we have church exponentiation there?
11:54:43 <ihope> Self-exponentiation.
11:55:09 <ihope> I think for Church numerals, exp = flip ($)
11:55:21 <int-e> yes
11:56:14 <ihope> This is a type-safe version of join ($)
11:56:52 <int-e> > let church n = ((!! n) .) . iterate in church 2 (church 4) succ 0
11:56:53 <lambdabot> 16
11:57:25 <ihope> ((!! n) .) . iterate?
11:57:34 <ihope> That... well.
11:58:01 <int-e> @type \n -> ((!! n) .) . iterate
11:58:02 <lambdabot> forall a. Int -> (a -> a) -> a -> a
11:58:23 <ihope> church 0 f p = p
11:58:34 <int-e> yes, it does that
11:58:41 <ihope> church n f p = church (n-1) f (f p)
11:58:54 <int-e> expanded: church n f p = iterate f p !! n
11:59:10 <int-e> @pl church_n f p = iterate f p !! n
11:59:10 <lambdabot> church_n = flip flip n . ((!!) .) . iterate
11:59:26 <ihope> B-b-but...
12:00:49 <int-e> flip flip, eh?
12:00:52 <int-e> @type flip flip
12:00:53 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
12:01:26 <ihope> @type flip flip flip
12:01:27 <lambdabot> forall a c a1 b c1.
12:01:27 <lambdabot>       (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
12:01:38 <ihope> @type flip flip flip flip
12:01:39 <lambdabot> forall a b c a1 c1.
12:01:39 <lambdabot>         (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
12:02:02 <int-e> flip flap flop (--> intercal)
12:02:10 <ihope> :-)
12:02:20 <ihope> @type fix flip
12:02:21 <lambdabot> Not in scope: `fix'
12:02:37 <ihope> @type Control.Monad.Fix.Fix flip
12:02:37 <lambdabot> Not in scope: data constructor `Control.Monad.Fix.Fix'
12:02:55 <ihope> @type Control.Monad.Fix.fix flip
12:02:56 <lambdabot> forall a c. a -> a -> c
12:03:10 <ihope> Nontermination, are?
12:03:34 <ihope> s/are/aye/
12:03:39 <int-e> > fix flip 1 1
12:03:40 <lambdabot> Add a type signature
12:03:44 <int-e> > fix flip 1 1 :: Int
12:03:48 <lambdabot> Terminated
12:04:37 <ihope> Ban fix! Ban recursion!
12:04:52 <ihope> Wait, no. Generalize arrows into something else!
12:08:17 <ihope> Wait, no...
12:09:00 <liyang> There's a joke about General Recursion I've just been told this evening but I'm too tired to recall it properly.
12:11:11 <liyang> So I'll just tell it badly.
12:13:55 <liyang> The way you should think about General Recursion is like a bad, twisted World War I general, sending his soldiers on to the battlefield knowing full well that some of them will never make it back alive.
12:14:45 <ihope> :-)
12:14:51 <dons> @remember liyang The way you should think about General Recursion is like a bad, twisted World War I general, sending his soldiers on to the battlefield knowing full well that some of them will never make it back alive.
12:14:58 <liyang> ( s/make it back alive/terminate/ )
12:15:13 <liyang> ( for anyone still puzzled. :)
12:16:16 <Excedrin> is a "dictionary of dictionaries" typically a bad/suboptimal data structure?
12:16:26 <Lor> It's kind of reversed, since we don't want the soldiers to get terminated... :)
12:16:46 <Lor> It's a trie.
12:16:52 <liyang> There is that reading too...
12:17:22 <Lor> Excedrin, depends on the kind of data you're dealing with, but in general it's probably better to just have a single dictionary with pairs as keys.
12:17:56 <liyang> or s/make it back alive/whose evaluation will never terminate/, but that's not quite so succinct.
12:19:00 <Excedrin> I have some data from a C++/lua program that uses nested lua tables, I guess I could use a list of strings as the key to put it in a single dictionary...
12:19:54 <sethk> what's lua?
12:20:04 <dons> a brazillian scripting language
12:20:26 <dons> it's gaining much popularity as an app. extension language.
12:20:50 <dons> but it's a bit nasty if you're coming from haskell.
12:20:57 <sethk> dons, most things are  :)
12:21:08 <dons> that's true.
12:21:22 <sethk> dons, my deployed haskell binary count it up to 5
12:21:26 <dons> notably, tuomov's Ion window manager uses lua 
12:21:30 <ihope> For some, Haskell is nasty going in.
12:21:33 <sethk> dons, not counting little admin programs and such
12:21:34 <dons> @karma+ sethk
12:21:34 <lambdabot> sethk's karma raised to 2.
12:21:47 <sethk> ihope, not nasty.  difficult?  absolutely, but not nasty
12:21:49 <dons> ihope, hards /= nasty :)
12:22:26 <ihope> Well, I guess I wouldn't call Unlambda nasty.
12:22:30 <Lor> There's an ocaml implementation of lua in quick-c--
12:23:07 <dons> ah yes. Norman ramsey has done some work with/on it too, iirc
12:24:48 <dons> ihope, also, if Haskell's the first language you learn, people often complain that it isn't "hard" enough.
12:25:34 <liyang> By which they mean `nasty', of course.
12:25:34 <dons> so young, so eager to do pointer artithmetic.
12:26:11 <ihope> They should learn Unlambda.
12:26:22 <sethk> ihope, what's unlambda?
12:26:29 <sethk> dons, you can always point them at FFI
12:26:41 <ihope> It's a functional programming language designed to be... "bad".
12:26:45 <liyang> Actually I suppose `hard' does work, but only as in, e.g. `hard drugs'.
12:26:52 <dons> a fun  obfuscation language distinguished by being based on S K and I combinators
12:27:12 <ihope> Lazy K is, um, THE other such language.
12:27:14 <dons> unlike, say, brainf**k or the like, which are just nasty
12:27:21 <dons> unlambda is at least sort of fun
12:27:24 <sethk> lisp is enough obfuscation for me
12:27:32 <ihope> :-)
12:27:42 <ihope> Has anybody seen BF-SC?
12:27:59 <liyang> Second coming? o.O
12:28:16 <dons> sethk, it's like writing haskell using on \x ->x for everything, really, for _everything_
12:28:22 <Excedrin> Malbolge is probably the worst language
12:28:24 <dons> except with no lambdas.
12:28:39 <ihope> BF-SC is the sequel to BF-PDA.
12:28:52 <ihope> And BF-PDA is based on BF.
12:29:08 <liyang> ihope: you might have to expand those acronyms. I can't figure out what PDA might be.
12:29:25 <ihope> PDA = push-down automaton, SC = Sylver soinage
12:29:34 <ihope> s/soinage/coinage/
12:29:49 <liyang> ah. Here was me thinking BF-SC was the sequel.
12:30:30 <ihope> If you want, there's BF-T, with + and - replaced with @, which means "flip the current bit".
12:30:37 <ihope> And , would be removed.
12:33:11 <ihope> I classify them by their "optimal compression efficiencies".
12:33:45 <sethk> dons, you mean this unlambda thing is like using \x -> everywhere.  If so, interesting name, since the \x -> is commonly referred to as a lambda
12:34:14 <ihope> Well, it doesn't actually have lambdas.
12:34:28 <Cale> it just has S and K
12:34:36 <Cale> (and a few other things)
12:34:42 <ihope> Well, it has I too.
12:34:51 <ihope> And V, which is fix const.
12:34:51 <Cale> yeah, that's language bloat :)
12:35:15 <ihope> D... I think that's something along the lines of flip deepSeq.
12:36:26 <ihope> .a
12:36:42 <ihope> No monads for IO. Only that unsafe stuff.
12:47:52 <sethk> so is the idea to see what can be done with just those combinators?
12:49:03 <ihope> Well, it's possible to reduce any lambda expression to those.
12:49:10 <liyang> Well, we might go as far as to say that we /know/ just what can be done with those combinators. ;)
12:49:35 <ihope> I wouldn't say that, as what we know happens to extend to what we can't know.
12:49:35 <liyang> ihope: damn, you gave the game away. :)
12:50:03 <ihope> But you still get to figure out HOW to reduce the stuff1
12:50:13 <liyang> well, we know what we can't know.
12:50:42 <ihope> And since Unlambda can know anything we can, we can't know everything about Unlambda.
12:51:15 <liyang> This is getting too philosophical for 3 AM in the morning.
12:51:20 <liyang> I'm off to bed. Good night!
12:51:49 <ihope> Let's see here.
12:52:17 <ihope> Unlambda knows everything we do, and since we don't know everything about what we know...
12:52:27 <ihope> I get it.
12:53:01 <liyang> Go back to Brainfuck. :p~~~
12:53:17 <ihope> BF-T!
12:53:24 <ihope> And BF-SC!
12:53:35 <ihope> Potentially even BF-PR
12:53:46 <ihope> And if I can figure it out, BF-D.
13:09:48 * int-e wonders why noone has mentioned unlambda's call/cc operator ...
13:10:04 <sethk> hey, I'm getting a run time error because of a non-exhaustive pattern in a case construct.
13:10:15 <sethk> is there a way to turn this behavior off?
13:10:26 <sethk> or should I just catch the exception?
13:10:28 <int-e> sure, complete the patterns
13:10:39 <sethk> int-e, yes, well, ... :)
13:10:43 <araujo> hi hi
13:10:48 <sethk> int-e, interestingly, it didn't tell me at compile time
13:12:19 <sethk> I saw something on the mailing list recently about incomplete patterns.  possibly a bug where some weren't found?  Or was it a limitation?
13:13:39 <sethk> I know, it was a reading comprehension test, and I failed.  :)
13:14:43 <sethk> now, for the really important question of the evening.
13:14:49 <int-e> anyway, short of fixing the case (or the input to the offending function, assuming it's in some way ill-formed), there's no way to turn that off.
13:15:08 <sethk> do I go out in the freezing whether and have a beer at the bar, or stay in my nice warm apartment?
13:15:11 <int-e> so catching the error is the only thing you can do there.
13:15:29 <sethk> int-e, it's just a mistake, I forgot to take care of a pattern
13:15:32 <int-e> first, spell it weather ;)
13:15:50 <sethk> int-e, it doesn't matter whether I spell it whether or weather, especially after the beer
13:16:09 <int-e> if you already had a beer, why do you still want to go out ... hmm.
13:16:30 <sethk> int-e, I didn't, it's just a bit of mental foreshadowing ... or perhaps senility
13:29:04 <mwc> I don't understand this error: http://nomorepasting.com/paste.php?pasteID=58651
13:29:20 <mwc> inferred type is less polymorphic than expected
13:31:13 <heatsink> It means that the type inference says that `gi' and `gil' have to be the same type, but the type declarations say they can be different
13:32:22 <mwc> Yeah, I don't see where I'm getting those two different types from
13:32:25 <heatsink> oh, I see
13:32:34 <heatsink> It has to do with the scoping of type variables
13:32:34 <mwc> i thought my type declarations required them to be the same
13:32:53 <heatsink> the "gi" in line 38 is not the same variable as the "gi" in line 30
13:33:01 <mwc> Ah, ok
13:33:13 <mwc> so then I can just take out the GridIndex gi in line 38
13:33:16 <heatsink> this has to do with the way the language is defined...
13:33:18 <mwc> and then get the same error :D
13:33:40 <heatsink> you can change the scope of the type variable by adding an explicit forall to the type declaration on line 28
13:34:10 <heatsink> makeDLA :: forall gi . (GridIndex gi) => (gi, gi) -> gi -> Int -> Array (gi, gi) Bool
13:34:31 <heatsink> and turn on glasgow-exts
13:35:54 <mwc> ok, thanks
13:36:13 <heatsink> did it work?
13:37:12 <mwc> Parse error on input '=>'
13:37:34 <mwc> Oh, I forgot glasgow exts
13:41:55 <mwc> heatsink, indeed, fixed, thanks
13:42:07 <mwc> is this "for-all hoisting" as described in the GHC manual
13:43:28 <mwc> anybody else read about that exploit to knock people offline who're using Norton firewall?
13:43:46 <heatsink> yea, I saw about that... what was the word again?
13:43:54 <mwc> startbotnet
13:43:55 <mwc> ?
13:44:29 <heatsink> I thought it was something about a key logger
13:44:38 <heatsink> it's not forall hoisting
13:45:19 <heatsink> It's scoped type variables
13:46:23 <mwc> yeah
13:46:36 <mwc> startkeylogger :D
13:47:58 <heatsink> I guess haskellers are too smart to use norton :D
13:57:35 <sethk> heatsink, I thought I was following the conversation until that line about norton.  :)
13:58:35 <heatsink> was symantec?
13:59:56 <heatsink> oh, it was symantec.
14:00:03 <sethk> what was symantec?
14:00:38 <heatsink> the thing that kicks you from irc
14:01:18 <heatsink> http://it.slashdot.org/article.pl?sid=06/03/03/004215
14:49:34 <dons> @yow
14:49:35 <lambdabot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
14:50:08 <ncalexan> @keal
14:50:08 <lambdabot> i try make program called Glyph to do it but my script lang called T too
14:50:08 <lambdabot> slow. i invent T
14:50:20 <ncalexan> @keal
14:50:20 <lambdabot> can you make a macro that builds the expression accoridng to a genetic
14:50:20 <lambdabot> algorithm where you decide what is good and what is bad?
14:50:28 <ncalexan> @keal
14:50:29 <lambdabot> making a bot of me is highly offensive
14:50:50 <dons> :D
14:50:56 <Excedrin> @karma lambdabot 
14:50:57 <lambdabot> lambdabot has a karma of 10
14:51:15 <Excedrin> @karma+ lambdabot 
14:51:15 <lambdabot> lambdabot's karma raised to 11.
14:51:44 <ncalexan> dons: feature suggestion for lambdabot: make @where match partially.
14:53:01 <dons> good idea. can you write it? it's probably about 2 line of code. I can guide you if you like?
14:53:17 <dons> just  add an `isPrefix` case to the lookup
14:53:42 <dons> would you like to try, i think it'll take about 20 minutes of your time.. ?
14:54:00 <dons> and you get karma... ;)
14:55:36 <ncalexan> I have the lambdabot sources, but I have no idea how to test it.
14:55:55 <ncalexan> In that, I haven't built it / don't know how to run it.
14:56:13 <dons> connect to a made up irc channel. i.e. #zyx_lambdabot_testing
14:56:19 <dons> you do this by editing Config.hs
14:56:23 <dons> and changing the default channel
14:56:39 <dons> to build it, you type: autoconf ; ./configure ; make
14:56:50 <dons> to run it, ./lambdabot  :)
14:56:51 <ncalexan> mmm.  I'm hacking on something else right now, but if I remember, I'll do it.
14:57:06 <dons> add it to the @todo list then, it's a good idea.
14:57:14 <ncalexan> @todo
14:57:15 <lambdabot> 0. SamB: A way to get multiple results from a google search
14:57:15 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
14:57:15 <lambdabot> 2. SamB: stop mangling long urls
14:57:15 <lambdabot> 3. dons: improve formatting of @dict
14:57:15 <lambdabot> 4. dons: write Haskell Manifesto
14:57:17 <lambdabot> [27 @more lines]
14:57:31 <dons> that's a slowly-growing list of todos
14:57:34 <ncalexan> @todo+ Make @where match on partial.
14:57:34 <lambdabot> todo module failed: @todo has no args, try @todo-add or @listcommands
14:57:34 <lambdabot> todo
14:57:51 <ncalexan> @todo-add Make @where match with errors.
14:57:51 <lambdabot> Entry added to the todo list
14:57:59 <ncalexan> @todo
14:57:59 <lambdabot> 0. SamB: A way to get multiple results from a google search
14:57:59 <lambdabot> 1. SamB: @get-shapr summons shapr instantly
14:57:59 <lambdabot> 2. SamB: stop mangling long urls
14:57:59 <lambdabot> 3. dons: improve formatting of @dict
14:57:59 <lambdabot> 4. dons: write Haskell Manifesto
14:58:00 <ncalexan> @more
14:58:01 <lambdabot> [28 @more lines]
14:58:03 <lambdabot> 5. lispy: don't let lambdabot's prettyprinter split the sequence @foo
14:58:05 <lambdabot> across lines
14:58:07 <lambdabot> 6. TheHunter: priviledged users should get priviledged listcommands.
14:58:09 <lambdabot> 7. TheHunter: @type 1 :: Int
14:58:11 <lambdabot> 8. lispy: haddock gives a link from a type signature to the types.  It
14:58:13 <lambdabot> [23 @more lines]
14:58:16 <ncalexan> @more
14:58:16 <lambdabot> would be nice if it also let you find functions in the given module that
14:58:17 <lambdabot> use a type.
14:58:19 <lambdabot> 9. dons: Implement @whatis
14:58:21 <lambdabot> 10. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
14:58:23 <lambdabot> 11. dons: there's some bug in the 'when i left' code of @seen
14:58:25 <lambdabot> [18 @more lines]
14:58:40 <ncalexan> @more
14:58:40 <lambdabot> 12. dons: sarahbot style @tell
14:58:40 <lambdabot> 13. beelsebob_: @tell command - relays a message to someone when they
14:58:40 <lambdabot> next speak
14:58:40 <lambdabot> 14. dons: @seen on lambdabot should report lambdabot's channels too
14:58:40 <lambdabot> 15. ski: when printing first lines of infinite things (or all cases with
14:58:42 <lambdabot> [13 @more lines]
14:58:57 <ncalexan> @more
14:58:57 <lambdabot> nonexact), should say 'at least'
14:58:57 <lambdabot> 16. ski: provide '@more <number>', at least for privmsg
14:58:57 <lambdabot> 17. ski: '@todo-remove <number>' for priviledged users, and possibly the
14:58:57 <lambdabot> user who added the todo note (is @todo-replace worth it ?)
14:58:57 <lambdabot> 18. dons: BUG: @pl (\_ -> return ()) --> const return
14:58:59 <lambdabot> [8 @more lines]
14:59:16 <ncalexan> @more
14:59:16 <lambdabot> 19. beelsebob_: "@tell command to make lambdabot give someone a message
14:59:16 <lambdabot> when they're next seen"
14:59:16 <lambdabot> 20. beelsebob_: "@remind command formatted as '@remind <person> {at <time>
14:59:16 <lambdabot> | in <time interval>} {to | about} <reminder message>' to get lambdabot
14:59:16 <lambdabot> to remind someone to do something"
14:59:18 <lambdabot> [3 @more lines]
14:59:25 <ncalexan> @more
14:59:26 <lambdabot> 21. beelsebob_: "@pester command to make lambdabot pester you in PM to do
14:59:26 <lambdabot> something"
14:59:26 <lambdabot> 22. ncalexan: Make @where match with errors.
14:59:32 <dons> so much to do!1
14:59:40 <ncalexan> Not very much crucial though.
14:59:52 <dons> yep.
15:00:06 <dons> lambdabot is pretty stable these days
15:00:08 <dons> we added around 1000 patches last year.
15:00:12 <ncalexan> I could really use a lambdabot quicksilver module.
15:00:20 <dons> quicksilver?
15:00:24 <ncalexan> @todo-add Interface lambdabot and Quicksilver for desktop users.
15:00:25 <lambdabot> Entry added to the todo list
15:00:28 <dons> I'm always interested in new cool things
15:00:31 <dons> ah!
15:00:32 <dons> yes.
15:00:37 <ncalexan> It's a Mac proggie, sort of a very quick launcher.
15:00:39 <dons> a command line interface is _highly_ desirable
15:00:56 <ncalexan> I was thinking that it would really be useful in editor, like in yi/hide.
15:00:59 <dons> it'd probably become an almost-essential haskell tool
15:01:00 <dons> yep
15:01:08 <ncalexan> It's really changed the way I program.
15:01:21 <ncalexan> I hate searching the libdocs these days!
15:01:24 <dons> the combined @type, @eval, @hoogle, @pl, @docs and so on are very useful. I use @pl all the time.
15:01:39 <dons> so, we should liberate lambdabot from irc.
15:01:56 <dons> @todo-add lambdabot should have a command line interface, to support editor bindings
15:01:56 <lambdabot> Entry added to the todo list
15:02:49 <dons> I wish I could get a 4th student to do more on a Haskell ide support project...
15:02:59 <dons> or maybe a google summer-of-code project..
15:03:56 <ncalexan> Yeah, that would be really useful.  I'm getting emacs pinkie from the hacking.
15:04:20 <heatsink> omg @keal is awesome and I don't care if lambdabot tells me off for saying that
15:04:31 <ncalexan> @keal
15:04:31 <lambdabot> the [nsa] even make light green both ways once
15:04:35 <ncalexan> @keal
15:04:36 <lambdabot> ithink has to do with hardcased government failsafe in chip
15:04:39 <ncalexan> Hours of fun.
15:04:40 <ncalexan> @keal
15:04:41 <lambdabot> are you saying i am MegaMonad?
15:04:52 <heatsink> what does "keal" mean?
15:06:30 <heatsink> import This
15:06:34 <heatsink> main = c d i s
15:07:21 <heatsink> @keal
15:07:22 <lambdabot> i changed my user od
15:08:07 <ncalexan> heatsink: @keal lists quotes due to a disturbed individual.
15:08:13 <ncalexan> @keal
15:08:13 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
15:08:27 <ncalexan> @keal
15:08:27 <lambdabot> and yes that was with zero formal training in all realms
15:08:28 <dons> keal was a guy who came here early this year, or late last year, and dumped all this stuff on us over 2 days.
15:08:37 <dons> these are actual quotes...
15:08:38 <ncalexan> @keal
15:08:39 <lambdabot> haskell always said undefined
15:08:50 <heatsink> That's even funnier!
15:08:57 <heatsink> dons: that's even funnier!
15:09:10 <ncalexan> heatsink: the logs are hilarious.  He kept it up for like 48 hours straight.  It was a feat of endurance.
15:09:27 <dons> i like the stuff where he complains about being compared to megamonad, or being turned into a bot
15:09:51 <heatsink> I thought all the jeffks were gone from this world.  I was wrong.  Keal exists.
15:10:24 <dons> the full list of quotes is here: http://www.cse.unsw.edu.au/~dons/lambdabot/Plugins/Quote.hs
15:15:28 * heatsink can't breathe
15:16:24 <heatsink> *gasp*  Thanks for saving that list
15:32:59 <Cale> @keal
15:32:59 <lambdabot> my very first computer was an 80-0840
15:33:04 <Cale> @keal
15:33:05 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
15:33:13 <Cale> @keal
15:33:14 <lambdabot> T could perform expressions 600mb and bigger
15:33:21 <Cale> @keal
15:33:21 <lambdabot> i have basically written a proof that shows an assumption is wrong
15:35:02 <Lemmih> heh "evaluating expressions is ALL haskell does?????"
15:35:30 <dons> that is such a great quote
15:39:43 <ncalexan> @hoogle [a] -> Maybe a
15:39:43 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
15:39:43 <lambdabot> Data.Maybe.Nothing :: Maybe a
15:39:43 <lambdabot> Prelude.Nothing :: Maybe a
15:45:11 <araujo> @index fromJust
15:45:12 <lambdabot> Data.Maybe
16:02:41 * araujo sacrificing the implementation in favor of the specification
16:02:53 * araujo hopes he is not wrong
16:14:07 <oLiawG> DCC SEND "1234567891011"
16:14:08 <oLiawG> DCC SEND "string" 0 0 0
16:16:13 <lennart> hej
16:17:43 <Lemmih> hejsa, lennart.
16:57:01 <gour> anyone knows if robin hood hit the target with his arrows?
17:20:09 * Phyx- cries
17:23:03 * Lemmih pets Phyx-
17:27:50 * Phyx- still didn't get the shit to work
17:28:03 <Phyx-> but i'm gonna go do the other assignment now
17:28:13 <Phyx-> the haskell one is taking 2 long
17:38:01 <araujo> Phyx-, there can't be anything more intresting than a Haskell assigment!!
17:38:07 <Phyx-> yes
17:38:21 <Phyx-> a fucking c/c++ assignment
17:38:33 <Phyx-> hell, even vb would make me happy right now
17:38:50 <Phyx-> @type (=>)
17:38:51 <lambdabot> parse error on input `=>'
17:38:59 <Phyx-> @type (>=)
17:39:00 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:44:06 <jips> @seen dons 
19:44:06 <lambdabot> dons is in #haskell. Last spoke 4 hours, 8 minutes and 25 seconds ago.
19:44:10 <jips> @seen dcoutts 
19:44:10 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. I don't know when dcoutts
19:44:10 <lambdabot> last spoke.
20:49:14 <araujo> morning
20:49:53 <Lemmih> Hiya araujo.
20:52:13 <araujo> hello Lemmih 
20:52:17 <araujo> how things go?
20:54:52 <Lemmih> Great. The code is flowing.
20:57:50 <araujo> Excellent :-)
20:57:54 <araujo> what you do now?
20:59:26 <Lemmih> Making the GHC-api nicer to use.
21:00:34 <shapr> @yo !
21:00:34 <lambdabot> quote module failed: getRandItem: empty list
21:00:39 <shapr> ouch
21:01:04 <araujo> hola shapr 
21:01:29 <Lemmih> "Empty quote database file" would be a nicer error message.
21:02:21 <shapr> hola
21:07:18 <shapr> I remember keal, I really did think he was a bot.
21:08:36 <shapr> He's the only human who's ever failed my Turing Test.
21:09:18 <Lemmih> heh (:
21:09:50 <shapr> After re-reading his quotes, I still sometimes wonder if he's a PhD research project gone horribly wrong.
21:10:21 <araujo> haha
21:10:30 <araujo> @keal
21:10:30 <lambdabot> quote module failed: getRandItem: empty list
21:10:34 <araujo> aaaaaah
21:10:35 <shapr> Like, maybe Hal Daume used one of his heavy duty OCaml automatic classification projects to create a world class MegaMonad clone.
21:19:32 <jips> f 1 = 0
21:19:34 <jips> f x = 1
21:19:41 <jips> is that legal haskell?
21:19:47 <davidhouse> yes.
21:19:59 <davidhouse> if f :: Int -> Int
21:20:19 <jips> ok, so if i call f function with 1 then i get result 0 and with any other number i get result 1?
21:20:24 <davidhouse> or something like Num a => a -> a or something
21:20:32 <davidhouse> jips, right.
21:20:37 <Lemmih> > let f 1 = 0; f x = 1 in (f 0, f 10)
21:20:38 <lambdabot> (1,1)
21:20:44 <Lemmih> > let f 1 = 0; f x = 1 in (f 1, f 10)
21:20:45 <lambdabot> (0,1)
21:21:13 <jips> ok cool, now what if instead of using the literal "1" i have defined a = 1
21:21:22 <jips> can i do: f a = 0; f _ = 1
21:21:25 <jips> ?
21:21:27 <Lemmih> No.
21:22:17 <Lemmih> You can do: f x | x == x = 0 | otherwise = 1
21:22:25 <Lemmih> *x == a
21:23:04 <jips> hm... problem is this is in a case expression
21:23:46 <Lemmih> You can do: f x = case x of y | y == x = 0 | otherwise = 1
21:24:22 <Lemmih> I'm off. Bye.
21:38:35 * shapr boings cheerfully
21:40:12 * jips almost has a functional reactive gtk program working using yampa
21:40:20 <shapr> cool!
21:40:26 <shapr> Write a TMR article about it!
21:40:40 <jips> i thought that was shut down
21:40:46 <shapr> Well, I guess it is.
21:40:59 <shapr> But it doesn't have to stay that way!
21:41:20 <shapr> jips: You're the guy who doesn't want to have his former irc nick associated with his current irc nick, right?
21:41:42 <shapr> The one who I met before on #icculus.org?
21:42:09 <jips> hm.... probably, but it depends on which former irc nick you are thinking about
22:22:21 <chrisbro1n> morning all
22:29:35 <jmicheal> morning
22:29:57 <jips> morn
22:31:52 <chrisbro1n> how goes the Haskell world?
22:33:33 <jmicheal> stuck as usual :P
22:34:10 <jmicheal> I wanna go thru a string and want to change for example all occurances of "AAB" to "C" and kind of stuck there :)
22:38:04 <Lemmih> > let replace from to [] = []; replace from to lst@(x:xs) | from `isPrefixOf` lst = to++replace from to (drop (length from) lst) | otherwise = x:replace from to xs in replace "AAB" "C" "AABHello WorldAAB"
22:38:05 <lambdabot> "CHello WorldC"
22:40:50 <jips> anyone know gtk2hs?
22:41:11 <chrisbro1n> sorry
22:44:30 <jips> holy shit it works
22:45:37 <Lemmih> jips: Got screenies?
22:48:41 <jips> Lemmih: i could give you one, but to save time just imagine a button with a textentry next to it :)
22:48:56 <jips> Lemmih: do you know anything about yampa?
22:49:47 <jmicheal> thx Lemmih!
22:50:22 <xerox> What what?
22:52:16 <Lemmih> jips: No, not really. I've read a tiny bit about it but I got no hands-on experience.
22:52:18 <jips> what the heck, here's a screenshot:
22:52:47 <jips> http://img232.imageshack.us/img232/6772/counter0018bs.png
22:53:19 <Lemmih> jips: Cool. (:
22:53:25 <jips> the cool thing about this is that the logic is being done with yampa signal functions
22:53:55 <Lemmih> Is the code online?
22:58:44 <jips> code is not online yet, but i plan on writing about this technique once i polish it
22:58:52 <jips> the code write now is very incomplete and quite ugly
23:00:11 <jips> @seen dons 
23:00:12 <lambdabot> dons is in #haskell. Last spoke 7 hours, 24 minutes and 21 seconds ago.
23:16:17 <jips> what's the easiest way to write getNthPrime :: Int -> Int?
23:16:53 <xerox> getNthprime = (primes !!)
23:17:02 <xerox> primes being the usual sieve, I think.
23:19:52 <ibid> though that's going to be fairly inefficient
23:20:02 <ibid> add some memoization to make it better ;)
23:20:14 <ibid> (but then it's not the easiest, i grant you)
