00:00:54 <Philippa> not as such, no
00:01:11 <Philippa> though there're related things you can do - for example, you could keep an STRef handy
00:01:50 <Philippa> but then the STRef remains constant so it still doesn't matter if the environment's a copy or not
00:02:00 <Philippa> (it's the cell the STRef refers to that gets updated)
00:03:13 <MarcWeber> STRef?
00:03:23 <MarcWeber> that counter example.. That is done using a state monad, isn't it?
00:03:57 <MarcWeber> passing that environment not that directly..
00:04:44 <MarcWeber> Having a counter like that wouldn't be functional.. as you would have one function/whatsoever which would return different values (the first time 1, the snd time 2, ..)
00:05:12 <Philippa> if you want to be able to make as many counters as you like you'd need the ST monad, not plain State
00:05:18 <Philippa> hence the STRef
00:05:33 <Philippa> State only has one value that changes. ST has many, with references to said values
00:06:20 <MarcWeber> That answers my other question. Thanks.. That would have been: What is a STRef? ;-) I'm happy again
00:07:27 <astrolabe> Practically, how many monads do people have in a pile?  I guess 10 would be too unwieldy?
00:07:54 <Philippa> I usually end up wrapping the resulting stack behind a new interface
00:08:13 <Philippa> if nothing else, it means you don't end up having to rewrite everything because you found you needed a WriterT somewhere
00:08:34 <astrolabe> That's sensible
00:08:55 <astrolabe> So the interface has commands for accessing different levels of the stack?
00:09:27 <Philippa> it might do or might not. Depends on how abstract you're feeling
00:09:39 <Philippa> (I tend to use commands like that for implementing the interface but not expose them)
00:11:04 <astrolabe> Haskell is really cool, but it you need a PhD to use it properly.
00:11:22 <jethr0> astrolabe: you mean in constrast do C++, right :)
00:11:58 <astrolabe> C/C++ is very easy by comparison I find.
00:12:04 <jethr0> i don't think there's a single soul on earth that's completely comfortable with all of C++'s quirks. writing exception-safe code is an exercise in futility
00:12:21 <astrolabe> painful though, I'll grant you.
00:13:02 <astrolabe> Maybe the problem is that with haskell, you get the impression that there is a proper way to do things, so you strive for them.
00:13:08 <Philippa> partly that, yeah
00:13:21 <Philippa> partly it also encourages you to think big thoughts, even if you don't realise that's what they are
00:13:28 <petekaz> astrolabe: I just set out to learn haskell last night (reading the awkward group tutorial now) and it seems like you are right!
00:13:38 <Philippa> I have a 2kLoC app that's doing AOP-like things by faking first-class modules...
00:14:04 <petekaz> astrolabe: re: PhD
00:14:18 <Philippa> petekaz: it's not that bad. I mean, I never finished my bachelor's...
00:14:30 <petekaz> Ah, there's hope!
00:14:40 <Philippa> admittedly I'd be doing a PhD if I could, but hey :-)
00:15:00 <astrolabe> I was exagerating, and Philippa is a special case anyway.
00:15:07 <Philippa> a lot of the advanced stuff you see people talking about is the equivalent of OO gurus discussing architectural principles from scratch
00:15:49 <Philippa> yeah, as in needs. Hence my not having graduated. But hey, shit happens
00:15:55 <petekaz> I've recently started to learn erlang and scheme as well.  I know a little CL, but my main programming these days is in Python (which is ever so practical for things I do at work) or Ruby, and little Java.  School was 10 years ago for me.
00:16:22 <Philippa> in some regards Haskell's the anti-Python
00:16:29 <Philippa> in others, it's what Python wishes it could be ;-)
00:16:47 <jethr0> python wishes it could be scheme, but guide won't let it :)
00:17:15 <petekaz> I prefer CL over scheme again for practical purposes.
00:17:34 <petekaz> I'm not an academic, I just want to get stuff done, so practical is important to me.
00:17:42 * Philippa nods
00:17:48 <ayrnieu> I suspect that history will tell us that python was a worthy catalyst of ultimately superior competitors, who were better for it.
00:17:58 <Philippa> Haskell mostly needs libraries there, though there's certainly room for improvement in the language itself
00:18:05 <astrolabe> I find it difficult to tell how practical haskell is.
00:18:18 <Philippa> it's wonderfully practical in some places and utterly impractical in others at the moment
00:18:27 <jethr0> astrolabe: it's a difficult question. what philippa said :)
00:18:45 <jethr0> although the incredible ease of FFI mends some weak points of haskell
00:18:57 <dons> where do you think it is impracticaal, Philippa?
00:19:01 <petekaz> Does haskell have a lot of forward movement?  Or is it stagnant?
00:19:13 <dons> it's highly dynamic, petekaz
00:19:17 <Philippa> dons: a big message-passing type system is a real PITA to implement safely, to give an example
00:19:23 <astrolabe> I think one area it is impractical is it gives the programmer a lot of rope.
00:19:29 <Philippa> granted it is in many languages, but hey
00:19:44 <petekaz> I use Darcs which is the only Haskell program I've ever usede.
00:20:41 <petekaz> I also followed Joel Reymont's trail which is how I got motivated to learn erlang and now haskell.
00:21:01 <dons> welcome :)
00:21:12 <dons> joelr spent a lot of time here at one point
00:22:04 <petekaz> Thanks, yeah, I read his post-mortem of why he went back to erlang. I'm having a blast with erlang now, but wanted to see if there was a place for haskell in my bag o tricks.
00:22:15 <Philippa> dons: more generally, there're times when I really do want (mostly structural) subtyping, and sometimes I find I really cba to write the library. I understand the FFI's good, but sometimes I don't want to have to do any more than the equivalent of #including the C headers. Stuff like that
00:22:26 <dons> petekz, to get a feel for how active haskell is, you might want to browse the list of announcements made to haskell's mailing list over the last year; http://www.cse.unsw.edu.au/~dons/code/hwn/announce.html
00:22:27 <Philippa> all of that said, I'm an extremely picky coder
00:22:28 <petekaz> In that vain, what is generally accepted as the best book on haskell? or perhaps upcoming book?
00:23:10 <astrolabe> I don't know that there is one
00:23:15 <astrolabe> check out
00:23:17 <astrolabe> @learn
00:23:18 <lambdabot> http://www.haskell.org/learning.html
00:23:31 <petekaz> Yeah, I'm there. :-)
00:23:44 <Philippa> IMO it's possibly better to learn by way of asking questions in here, poking around the wiki and reading tutorials
00:23:46 <astrolabe> I learned from 'The haskell school of expression' which I liked.
00:24:00 <petekaz> I was wondering if there was a SICP or PAIP or Practical CL equivalent for haskell.
00:24:06 <Philippa> but then I had the advantage of an intro to haskell course at uni, even if it skipped a lot of important stuff
00:24:14 <dons> petekaz, btw, it's the opinion of some here that joelr's mistake was to basically jump into the deep end and use some cutting-edge research for his problems. this made thing harder, as some things worked, some worked but were hard, some didn't. a more conservative approach might have been better, I reckon.
00:24:15 <Philippa> not really
00:24:19 <astrolabe> The tutorials are a good way to get started, but books tend to have nice examples too.
00:24:31 <Philippa> dons: seconded. Though not the worst case I've seen
00:25:00 <dons> for example, he wanted to use relatively unknown pickler combinators for binary IO, rather than the general advice to use standard binary IO classes.
00:25:04 <Philippa> you can often get good conversation and explanation in here, especially for the theoretical stuff where it's useful to have multiple viewpoints (though preferably not all at once)
00:25:15 <dons> anyway, he did much interesting stuff, and spotted several windows bugs
00:25:17 <dons> @karma joelr
00:25:18 <lambdabot> joelr has a karma of 0
00:25:24 <dons> oh, I thought he had some points
00:25:38 <petekaz> is lambdabot written in haskell?
00:25:45 <Philippa> yup
00:26:10 <dons> @version
00:26:11 <lambdabot> lambdabot 3p303, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
00:26:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:26:15 <dons> it's even in darcs :)
00:26:23 <astrolabe> I think you need a lot of experience in haskell to find good ways to do stuff.  I guess Joel was in too much of a hurry to get it.
00:26:32 <petekaz> it seems that irc bots are a great place to start looking at code since I did the same for erlang and CL.
00:27:22 <dons> there's hundreds, thousands of haskell aps, but not a lot make it into open source distros. mostly they come out of academic work, some are listed here: http://haskell.org/haskellwiki/Haskell_in_practice
00:27:47 <dons> note that lambdabot does a few weird things. so it's not idea for learning all of haskell :) but it wouldn't be too bad a place to start.
00:28:01 <dons> s/idea/ideal/
00:28:04 <petekaz> re: joel, I do not attribute any negatives to haskell as a result of his jumping ship, he has a habit of that. He's done it so many times. On the other hand, thanks to his praise, he landed me here.
00:28:25 <Philippa> he did better than Brandon typically does, at least
00:28:36 <astrolabe> He's obviously very able.
00:28:40 <Philippa> though thankfully Brandon concluded Haskell was the wrong language for him without doing his usual stunt
00:29:04 <astrolabe> Who is Brandon?
00:29:17 <Philippa> if you don't know, you don't want to :-)
00:30:11 <Philippa> Brandon Van Every. He decided a while back he was fed up of C++ and went looking at other languages. Keeps pissing people off by appearing to expect them to steer their projects his way, and by making grand pronouncements that're full of shit because he doesn't understand all the issues properly. His stint on LtU was amusing
00:30:28 <Philippa> oh, and I co-moderate a mailing list with him - I know him from before the language quest
00:30:42 <Philippa> amongst other things, he's speed-crazed
00:30:49 <vincenz> send him to ocaml
00:30:50 <astrolabe> Learning to think functionally is very difficult I find, and I'm a mathmo!
00:31:12 <Philippa> I didn't find it too difficult, but I'd got at least half way there on my own time already
00:31:16 <petekaz> brandon has been here too?
00:31:29 <Philippa> thankfully no. He saw the speed concerns with lazy evaluation and steered clear
00:31:30 <dons> astrolabe, how long have you been playing with haskell? a while now?
00:31:31 <petekaz> he made a mess on CL mailing lists a while back.
00:31:34 <Philippa> heh
00:31:40 <Philippa> he made a mess in a lot of places
00:31:43 <vincenz> Philippa: reminds me of me before my enlightenmend :D
00:31:56 * astrolabe looks for his oldest .hs file
00:32:13 <Philippa> he was really shocked when on LtU some of us pointed out that you need to know an optimisation's safe before you apply it...
00:32:29 <Philippa> it hadn't occurred to him that there might be any proof-type issues in optimisation at all
00:32:46 <dons> hehe
00:33:00 <dons> some people are just noisy
00:33:01 <vincenz> a colleague of mine worked on that, equivalence proving of c-code pre and post transformation
00:33:50 <astrolabe> I've been playing with haskell for about 6 months.
00:34:18 <dons> hmm, i thought I had my first .hs file around here somewhere. /me keeps looking
00:34:21 <vincenz> I've been playing with haskell for a month
00:34:32 <Philippa> mine was very probably a variant of main = print "hello world"
00:34:37 <Philippa> well, ignoring all the uni exercises
00:36:07 <dons> yeah, mine was a uni exercise from '99. it used   to be on the web, but I can't find it :/
00:36:38 <vincenz> the new ICFP is up
00:36:41 <vincenz> 21-24 july
00:36:52 <petekaz> The thing that intrigues me about haskell (keep in mind I just started reading about haskell last night) is lazy evaluation.  I'm not too keen on typing though (I suppose that's blasphemy around here though)
00:36:52 <vincenz> (rather late compared to the others)
00:37:11 <dons> petekaz, better to have your bugs spotted early than later.
00:37:12 <vincenz> petekaz: typing helps you to forego a lot of debugging
00:37:25 <vincenz> petekaz: I mostly write bugfree code thanks to typing
00:37:36 <dons> it's mechanical bug spotting for you. who doesn't want that?
00:37:46 * petekaz should have seen this coming :-)
00:37:59 <vincenz> petekaz: and it doesn't preclude unittesting
00:37:59 <petekaz> I like less writing.
00:38:04 <Philippa> petekaz: the typing mostly works out
00:38:06 <vincenz> petekaz: it's not like java or c
00:38:12 <Philippa> and it's not half as much writing as... what vincenz said
00:38:13 <vincenz> petekaz: you don't write the types, they're inferred
00:38:16 <dons> less writing? ah, you don't have to write the types you know.
00:38:25 <petekaz> oh.
00:38:26 <Philippa> or rather, you declare the types themselves, but not the types of values
00:38:27 <dons> haskell is the most concise language around, I think.
00:38:53 <dons> it's certainly the most concise on the language shototout
00:38:55 <Philippa> once you include the extra things expressed by the type system, yeah
00:39:01 <dons> @shootout
00:39:01 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=
00:39:01 <lambdabot> all
00:39:25 <vincenz> petekaz: in addition, if you're a dynamic typer and hence like unittesting... you should check out the power of QuickCheck
00:39:46 <vincenz> made possible through the use of typeclasses
00:40:20 <petekaz> This channel is great.
00:40:25 <vincenz> yep
00:40:28 <vincenz> I love this channel
00:40:35 <vincenz> and I'm only a recent addition
00:41:15 <dons> it's almost the 5th anniversary of #haskell, btw :)
00:41:22 * Philippa tries to remember how long she's been around
00:41:25 <vincenz> anyone competing in the icfpcontest?
00:41:36 <Philippa> more'n'half the chan's life now, I'm pretty certain
00:41:47 <dons> we'll have to check with shapr for the precisee date.
00:41:51 <vincenz> oh well I've been a stalker on this channel for quite a bit more
00:42:11 <vincenz> btw
00:42:17 <dons> vincenz, i'll probably have a go . dcoutts/Igloo/? will also likely attempt it.
00:42:17 <vincenz> I'm getting people at work interested in haskell
00:42:25 <vincenz> so much so I might give a course
00:42:39 <vincenz> dons: dcouts is doing it with colleagues
00:42:42 <vincenz> dons: so I'm left without a tea
00:42:43 <vincenz> m
00:42:48 <Philippa> cool. Looks like I'm off gaming btw
00:42:53 <vincenz> Philippa: what game?
00:43:24 <Philippa> dunno yet, I'll see what's going when I get there
00:43:31 <dons> anyway, petekaz, feel free to ask more questions. also, play with lambdabot :)
00:43:41 <dons> > map (+1) [1..20]
00:43:43 <lambdabot> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
00:43:43 <vincenz> dons: who will you be teaming up with?
00:43:46 <dons> @type map
00:43:47 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
00:43:55 <vincenz> > reverse ":("
00:43:56 <lambdabot> "(:"
00:43:58 <petekaz> dons: thanks.
00:44:02 <dons> @hoogle (a -> b) -> [a] -> [b]
00:44:03 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
00:44:03 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
00:44:03 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
00:44:19 <dons> @docs Data.List
00:44:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:44:38 <dons> and so on. lots of good haskell support here, in lambdabot, and on the wiki
00:44:38 <dons> @wiki
00:44:39 <lambdabot> http://www.haskell.org/haskellwiki/
00:44:40 <dons> @oldwiki
00:44:41 <lambdabot> http://www.haskell.org/hawiki/
00:44:57 <vincenz> I suggest reading "Yet Another Haskell Tutorial"
00:45:01 <vincenz> I personally found that one the best
00:45:05 <vincenz> it's on the wiki under tutorials
00:45:10 <petekaz> Ok.
00:45:33 <dons> vincenz, probably the same team I had as last year. me and a couple of other guys I work with. (though one's moved back to .de, so that might be interesting)
00:45:36 <petekaz> I'm in the monad section of teh awkward squad tutorial now.
00:45:41 <vincenz> :/
00:46:01 <vincenz> dons: I'm hoping to find a team that'll collaborate over irc and darcs
00:46:04 <vincenz> (possibly skype)
00:46:12 <petekaz> I was going to hit the Gentle Intro to haskell next, but I'll take your advice and try Yet Another instead.
00:46:24 <vincenz> petekaz: it's unofficially called "Not so Gentle"
00:46:31 <vincenz> ;)
00:46:46 <petekaz> ahh ... good to know!
00:46:53 <petekaz> Glad I popped here first then!
00:47:02 <dons> vincenz, you could ask on haskell-cafe@ closer to the date. probably a couple of teams can be arranged. maybe just another #haskell team?
00:47:04 <vincenz> you can try it after, but YAHT is a great intro
00:47:10 <vincenz> dons: perhaps
00:47:24 <vincenz> it's a pity it's so late in the yea
00:47:25 <vincenz> ...r
00:47:30 <vincenz> I mean that's the middle of summer
00:47:39 <dons> the middle of winter, you mean? ;)
00:47:45 <vincenz> huh?
00:47:51 <vincenz> july 21?
00:47:59 <dons> yeah, the middle of winter.. ;)
00:47:59 <vincenz> ah...aussie
00:48:10 <vincenz> yeah but in the northern hemishpere that's the middle of summer
00:48:19 <dons> no!
00:48:21 <dons> :p
00:48:27 <vincenz> end of july/begin of august is the major time of vacations
00:48:37 <dons> yep, I know what you mean
00:48:40 <dons> just teasing
00:48:47 <vincenz> I know
00:48:50 <vincenz> hence me plowing on in my speech
00:49:03 <vincenz> :D
00:49:08 <dons> :)
00:49:23 <dons> @y0w
00:49:24 <lambdabot> As President I have to go vacuum my coin collection!
00:49:40 <vincenz> @. yow yar
00:49:41 <lambdabot> compose module failed: Parse error: "yar"
00:49:45 <vincenz> @. yow arr
00:49:46 <lambdabot> Do I have a lifestyle yet?
00:49:55 <dons> @. elite yow
00:49:56 <lambdabot> REla+I\/E$!!
00:49:59 <dons> @. vixen yow
00:50:00 <lambdabot> i think you know the answer to that one, silly
00:50:53 <dons> @. vixen . elite yow
00:50:54 <lambdabot> love is all you need, you know?
00:51:08 <dons> @. vixen . elite . id yow
00:51:09 <lambdabot> you know what? if we'd known it was going to be like this we'd have
00:51:09 <lambdabot> picked our own goddamn cotton!
00:51:22 <dons> @. vixen . elite . id . id . id . id yow
00:51:22 <lambdabot> *shrugs*
00:51:24 <vincenz> elite ain't doing much
00:51:36 <dons> just making things more confusing for vixen
00:51:54 <vincenz> @. vixen . vixen . vixen . vixen . vixen . vixen yow
00:51:55 <lambdabot> Cute is as cute does.
00:52:08 <dons> hehe self-complements
00:52:09 <vincenz> @vixen Hello
00:52:10 <lambdabot> nothing good is on TV
00:52:15 <vincenz> what does vixen do?
00:52:22 <vincenz> you sure it's a text transformer and not a source?
00:52:45 <vincenz> @. elite . elite . elite . elite yow
00:52:46 <lambdabot> xiDz, 7|-|e $e\/EN 84zi( P|-|o0D 9r0uP5 4R3 9U/\/\, PuphP|-| pas7ry,
00:52:46 <lambdabot> pIsZ4, p35tICiD3$, 4nti8I0+i($, NU7RA-Sw337 4nd milx DuDs!!
00:54:57 <dons> vixen is both, since she answers to the empty string
00:55:15 <dons> so she can act as a src
00:55:22 <dons> @. elite vixen
00:55:22 <vincenz> ah
00:55:22 <lambdabot> HOw
00:55:34 <dons> @. elite vixen
00:55:35 <lambdabot> WhY M3? :)
00:55:47 <dons> but not much is produced by [] input
00:55:55 <vincenz> aisee
00:56:01 <dons> plugin composition is fun, but we need more filters I think
00:56:08 <dons> @type map
00:56:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
00:56:11 <vincenz> I agree
00:56:12 <dons> should be a src to djinn
00:56:19 <dons> @. djinn type map
00:56:20 <lambdabot> -- f cannot be realized.
00:56:22 <dons> should work
00:56:58 <dons> and this should be true:  type . djinn . type x == type x 
00:57:04 <xerox> @djinn (a -> b) -> [a] -> [b]
00:57:05 <vincenz> @help @.
00:57:05 <lambdabot>  @help <command> - ask for help for <command>
00:57:05 <lambdabot> -- f cannot be realized.
00:57:10 <xerox> Should it?
00:57:11 <vincenz> @help .
00:57:11 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
00:57:11 <lambdabot> f
00:57:25 <vincenz> dons: the problem with @. is that it actually expects it's inut
00:57:30 <vincenz> @. F G XS
00:57:31 <lambdabot> compose module failed: Parse error: "F"
00:57:42 <dons> ?
00:57:43 <vincenz> so you can't combine em I Think
00:57:54 <dons> i don't understand what you mean.
00:57:58 <dons> can you explain further?
00:57:59 <vincenz> it expects a third argument
00:58:02 <vincenz> namely the input
00:58:12 <vincenz> so you can't just combine them
00:58:12 <dons> yep
00:58:14 <dons> sure you caan
00:58:18 <dons> @. elite vixen
00:58:19 <lambdabot> *giGGLEs*
00:58:27 <xerox> haha
00:58:39 <vincenz> dons: well yes maybe for these simple ones, but take some stricter plugins
00:58:42 <dons> but it's not haskell.
00:58:48 <vincenz> what's the one that keeps data?
00:59:02 <dons> @state ?
00:59:03 <lambdabot> 5ta7E/\/\3N+!
00:59:04 <vincenz> yeah
00:59:07 <vincenz> @state ?
00:59:07 <lambdabot> ?
00:59:18 <vincenz> @. state . state . state . state state
00:59:19 <lambdabot> ?
00:59:19 <lambdabot>  
00:59:21 <vincenz> @. state . state . state . state state a
00:59:24 <vincenz> @. state . state . state . state state a
00:59:25 <lambdabot> a
00:59:25 <lambdabot>  
00:59:31 <dons> interesting.
00:59:32 <vincenz> nm
00:59:39 <dons> side effects are evil!
00:59:56 <shapr> dons: /msg chanserv info #haskell
01:00:06 <shapr> Registered: 4 years 44 weeks 5 days (16h 49m 2s) ago
01:00:09 <dons> ah!
01:00:20 <shapr> Think we should have an online lambda party?
01:00:29 <vincenz> yes
01:00:29 <dons> shapr, i was writing a potted history of #haskell for the wiki..
01:00:32 <shapr> oh cool
01:00:33 <dons> @wiki IRC_channel
01:00:34 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
01:00:37 * shapr looks
01:00:38 <dons> so maybe you could expand...
01:00:44 <dons> and point to some logs?
01:00:57 <shapr> Yeah, all the old logs are online.
01:01:09 <xerox> @state
01:01:10 <lambdabot> a
01:01:10 <lambdabot>  
01:01:14 <xerox> UH?
01:01:24 <dons> I think 5 years is a real milestone! :)
01:01:32 <vincenz> a party with online side-effects
01:01:33 <xerox> What happens wrt state?
01:01:54 <shapr> Pedantically, I didn't start it, I requested foundership four or six weeks afterwards, because the channel was empty. Realistically, I canvassed and proselytized furiously for the first few years.
01:02:20 <shapr> xerox: state was the second lambdabot plugin, just a demo of how to save state. It was a big question at first.
01:02:24 <shapr> @state Alabama
01:02:28 <shapr> @state Nevada
01:02:28 <lambdabot> Alabama
01:02:33 <vincenz> @state
01:02:34 <lambdabot> Nevada
01:02:35 <vincenz> @state
01:02:54 <shapr> It saves whatever is in the argument, and gives back what you had in the previous argument.
01:03:14 <shapr> @echo is another one of those really early debugging commands.. back when I didn't know the format of an irc message :-)
01:03:15 <lambdabot> echo; msg:Message {msgPrefix = "shapr!n=user@2002:51e0:9345:0:0:0:0:2",
01:03:15 <lambdabot> msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo is another one of
01:03:15 <lambdabot> those really early debugging commands.. back when I didn't know the
01:03:15 <lambdabot> format of an irc message :-)"]} rest:"is another one of those really
01:03:15 <lambdabot> early debugging commands.. back when I didn't know the format of an irc
01:03:17 <lambdabot> message :-)"
01:03:20 <dons> yeah shapr,, I know. a lot of grunt work in those first couple of years
01:03:20 <xerox> shapr: no I mean, this:
01:03:21 <xerox> @ÃŸtate
01:03:24 <xerox> @state
01:03:31 <xerox> It printed *two* lines.
01:03:41 <vincenz> @. state . state state a
01:03:42 <vincenz> @. state . state state a
01:03:42 <lambdabot> a
01:03:42 <lambdabot>  
01:03:47 <vincenz> like that
01:03:53 <dons> a newline?
01:03:54 <xerox> right.
01:04:17 <vincenz> @state 
01:04:17 <vincenz> @state 
01:04:17 <lambdabot> a
01:04:19 <shapr> lambdabot should filter out newlines, though the solutions that were in there before dons were ugly.
01:04:41 <shapr> dons has done lots to clean up lambdabot, and I haven't kept up.
01:05:46 <vincenz> shapr: are you participating in icfp this year?
01:05:57 <vincenz> the contest
01:06:00 <shapr> Probably not.. when is it?
01:06:01 <dons> the future for lambdabot now, or at least my big goal, is to separate it from irc, giving it a command line interface and some editor bindings
01:06:08 <vincenz> shapr: end of july
01:06:08 <ozone> dons: still up!
01:06:09 <vincenz> 21-24
01:06:14 <dons> morning ozone
01:06:16 <xerox> dons: that's right right right
01:06:43 <shapr> That's cool, lambdabot has become a general purpose tool :-)
01:06:51 <gour> dons: that would be nice, i.e. to have put lambdadot off
01:06:57 <ozone> dons: turn it into a screensaver
01:06:58 <xerox> offlambdabot
01:07:06 <gour> lol
01:07:21 <shapr> vincenz: I dunno, maybe.
01:07:45 <ozone> and make an ajax interface for it, after you write haskell on rails
01:07:56 <shapr> ozone: Hey, I have some ideas for that ;-)
01:08:07 <shapr> poetix called it Haskell on Heat :-)
01:08:13 * shapr boings
01:08:18 <ozone> well, better than haskell in heat
01:08:18 <xerox> What is it? :)
01:08:20 <dons> I just noticed a few months back that with @pl, @docs and @hoogle I was using it for a lot of development
01:08:29 <vincenz> dons: likewise
01:08:33 * xerox too
01:08:35 <ozone> the thought of haskell curry in heat makes me shiver
01:08:35 <dons> and beginners like using @type and @eval
01:08:43 <ozone> i think i might have had too much mead.  time to sleep!
01:08:50 <shapr> Yeah, though @pl needs an opposite. I want @cse
01:08:52 <xerox> 'night ozone 
01:09:04 <dons> shapr, yeah!
01:09:07 <vincenz> dons: I've argued for that before... hooking up a documentation system with @type etc to an ajax enabled interface
01:09:10 <xerox> Unfortunately we're not #prolog, hehe.
01:09:20 <shapr> xerox: Seen the bi-arrows paper? =)
01:09:24 * xerox arfs
01:09:31 <xerox> (Point me!)
01:09:39 <vincenz> @pl xerxo
01:09:42 <vincenz> @pl xerox
01:09:45 <shapr> xerox: http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
01:10:10 <lambdabot> xerxo
01:10:10 <lambdabot> xerox
01:10:34 <xerox> Danke.
01:10:40 <shapr> dons: I still wish for something that unifies print and web output. I think haddock and .lhs shouldn't be different systems.
01:11:04 <shapr> Oh, I'd also like to steal Python's help function.
01:11:24 <shapr> You can do help(map) in a Python interpreter, I say we should get the haddocks from "help map"
01:11:25 <dons> how's that work?
01:11:31 <dons> ah yes.
01:11:33 <dons> very much so
01:11:40 <dons> hoogle could almost do that. it parses haddocks
01:16:59 <shapr> I'm having fun playing with Postmaster, the MTA.
01:17:15 <ndm> dons, not anymore hoogle doesnt
01:17:23 <ndm> or rather it does, but thats not the preferred method
01:17:31 <ndm> haddock HEAD has a hoogle output format natively in it
01:18:27 <ndm> modifying that code in HaddockHoogle.hs should be trivial to have a doc format
01:20:25 <dcoutts_> ndm, you mean to have some neutral (xml?) doc format that preserves all the haddock info?
01:20:33 <dons> , I was wondering: do you know if more people search in hoogle using function types or function names?
01:20:43 <dons> s/^/ndm/ :)
01:21:05 <ndm> dccoutts_, i thought of that, but in the end gave up and went directly for hoogle format
01:21:11 <ndm> XML was too much work, and not that useful
01:21:34 <ndm> dons, i think it was about 25% signature, 75% name last time i checked
01:21:57 <dons> ah ok. that's roughly what I thought. good to see that the signature does get used a reasonable amount of the time
01:22:27 <dons> and, what, a few percent for things like project names?
01:22:33 <dons> or urls even?
01:22:43 <ndm> dons, a few percent for things you'd search on google for
01:22:47 <ndm> there are some wacky searches
01:23:00 <dons> @google 1 + 1
01:23:01 <lambdabot> 1 + 1 = 2
01:23:09 <xerox> Aha!
01:23:11 <ndm> i.e. eastenders - a UK tv program has been searched for
01:23:16 <dons> oh weird.
01:23:23 <xerox> Did you modify the search plugin?
01:23:32 <dons> also, what's this I hear about hoogle being picked up by google?
01:23:45 <ndm> dons, i have heard nothing
01:23:47 <dons> or is that some crazy fp rumour.
01:23:52 <shapr> I think it was a joke :-)
01:23:57 <ndm> didn't even hear that rumour until now...
01:24:01 <ndm> where was it  mentioned?
01:24:17 <dons> here. let me find the log page
01:24:20 <shapr> Coupla days ago I think.
01:24:41 <ndm> i'd love google to pick it up
01:24:44 <ndm> hire me on a big salary
01:24:51 <ndm> and develop hoogle more :)
01:24:56 <xerox> 18:33 <mwc> Woot, Hoogle is becoming an official google project :D
01:25:09 <dons> sounds like the kinda thing that should go on the humour page then ;)
01:25:16 <shapr> @google hoogle google
01:25:18 <lambdabot> http://blog.outer-court.com/forum/posts-by-Hoogle.html
01:25:22 <shapr> er?
01:25:25 <dons> hmm
01:25:34 <dons> @google hoogle
01:25:35 <lambdabot> http://haskell.org/hoogle/
01:25:37 <dons> does this still return pron?
01:25:38 <dons> no!
01:25:41 <ndm> not anymore!
01:25:44 <dons> @karma+ hndm
01:25:44 <lambdabot> hndm's karma raised to 1.
01:25:45 <ndm> took a while though
01:25:50 <dons> @karma+ ndm
01:25:50 <lambdabot> ndm's karma raised to 7.
01:26:04 <dons> and lots of links from haskell.org ;)
01:26:14 <ndm> indeed
01:26:18 <xerox> 18:27 <shapr> Lotsa Haskell users at Google?
01:26:21 <shapr> Anyone else using Postmaster? I'm looking for useful scripts.
01:26:23 <xerox> 8:33 <mwc> Woot, Hoogle is becoming an official google project :D
01:26:38 <xerox> end of the story
01:26:41 <dons> weird. blame mwc then.
01:26:50 <shapr> I have the standard banning, blacklisting, and timeout plugins, is there a greylisting plugin for Postmaster?
01:27:03 <ndm> i guess so, if anything happens i'll let you  know ;)
01:27:09 <dons> so we need to write a nice April 1 spoof for hoogle and google
01:27:36 <dons> it just seemed every so plausible they would be interested in type-indexed searches..
01:27:45 <shapr> hm, I wonder if we could write an april 1 spoof that half the mailing list would actually believe...
01:27:53 <shapr> dons: Hey that would work!
01:27:56 <ndm> yes, in fact i'm surprised they haven't done anything like this before
01:27:58 * shapr thinks..
01:28:03 <dons> well, seeing that Cale and I both fell for hoogle and google
01:28:32 <shapr> Andres Löh's work on type indexed types and Neil Mitchell's work on Hoogle have been combined in their stealth internet startup, which has already been acquired by Google!
01:29:06 <dons> hehe. yes, something like this. all pages on the internet will have types inferred and indexed
01:29:15 <shapr> There's a sneak preview of the new Hoogle on http://haskell.org/ghoogle/ that takes the filetype: powers of google to new heights!
01:29:18 <dons> google says "Type inference is the future of search"
01:29:22 <shapr> It's true.
01:29:32 <shapr> But they should start with bayesian stats per page and per connection.
01:29:43 <shapr> Then you could directly suggest pages to users.
01:30:06 <ndm> shapr, thats not massively far off some of the hoogle ideas flying around...
01:30:27 <shapr> nifty :-)
01:30:33 * shapr tries to think up a really confusing April 1st story...
01:30:39 <dons> concise page types can powerfully express content searches, and neil mitchell's break through work on type searches has ..  
01:31:17 <dons> Neil says "the next step is to develop a dependently-typed page type system, to express metal-level searches"
01:31:22 <dons> ;)
01:31:32 <dons> I know how ndm loves dependent types. hehe
01:31:46 <ndm> hehe, indeed - i think anyone who knows me will realise thats a fake :)
01:32:35 <shapr> The foremost Haskell company, Galois Connections, has hired Don Stewart of hs-plugins fame and Jeremy Bobbio of hOp fame as part of their bid to get their House distribution, hOppix, poised to take over the scalable server segment currently held by RedHat Enterprised Edition.
01:32:45 * dons envisages a very nice April 1 issue of HWN ...
01:33:25 <shapr> John Launchbury has said that the addition of Simon Marlow's SMP RTS work will allow hOppix to scale far better than Solaris, and the possible addition of YHC's bytecode format could let the entire distribution fit onto a single floppy.
01:33:36 <dons> hehe
01:33:46 <dons> that last sentence just confused me greatly
01:33:48 <ndm> and Yhc now has concurrency
01:34:24 <dons> !
01:34:30 <ndm> dons, i believe you promised to port Yi over once we got it, and now we do!
01:34:43 <ndm> of course, things like getArgs still don't work, so I'd wait a while yet
01:34:43 <dons> can I port yi? yes!
01:34:55 <dons> ok. but who needs args ;)
01:34:58 <ndm> well, not that long - libraries are slowly shaping up
01:35:12 <ndm> we have full MVar support
01:35:12 <dons> ok. a few more libs. but really only concurrency was the issue.
01:35:19 <dons> excellent!
01:35:34 <dons> I could probably port hmp3 too then.
01:35:43 <ndm> neat :)
01:35:50 <ndm> we also added cpp built in, which will help
01:36:04 <dons> great stuff.
01:36:22 <ndm> plus there is now an interpretter writing in Python for Yhc bytecode files
01:36:24 <shapr> Simon Peyton-Jones has been given a short-term contract to combine his financial combinators work with earlier work OGI.EDU work on typesafe operating systems. This new project should allow GHC to produce programs that include a perfect description of their required resources, both in memory and cpu costs. 
01:36:31 <ndm> but i doubt that will be useful to you
01:36:35 <dons> written in python? bizaare.
01:36:45 <dons> for bootstrap purposes?
01:36:52 <ndm> dons, no - just for fun
01:36:55 <dons> shapr!
01:37:08 * xerox doesn't belive shapr anymore, <grin<
01:37:12 <dons> yes, I really like the idea of a finanncial combinators article
01:37:29 <dons> with static guarantees that no project will go over budget
01:37:46 <shapr> The Haskell Lambaster tried to contact members of the new projects, but was only able get a single sentence out of a jet-lagged Don Stewart, "We are the Knights who say Yi!" No one knows what this could mean.
01:38:30 <dons> lol! 
01:39:01 <dons> ok, 3am, really sleep now. night guys!
01:39:03 <shapr> In other news, Jamie Zawinski is rumored to have given up on XEmacs and switched his efforts to a secret Haskell editor project headquartered somewhere in Portland, Oregon, or maybe New South Wales, Australia.
01:39:05 <shapr> g'nite!
01:40:30 <shapr> dons: I think your financial combinators budgeting library is perfect for an April Fools' edition of HWN.
01:44:04 <shapr> Man, Postmaster is way nifty.
01:44:49 <mauke> why doesn't ghc have something like ocaml's Unix lib?
01:45:18 <shapr> You mean Posix support? or what?
01:45:43 <mauke> all the functions I need in an easy to find single package
01:45:58 <shapr> And what functions do you need?
01:46:15 <mauke> I need: fork, pipe, dup2, close, read, write, setsid, wait, sigaction, select, and socket stuff
01:46:28 <mauke> oh, and exec of course
01:46:37 <shapr> socket stuff is in Network.Socket
01:46:53 <shapr> Most of the other stuff is in the Posix lib.
01:47:11 <mauke> I don't see setsid or select
01:47:11 <shapr> I think select is in its own lib though.
01:47:23 <shapr> @index select
01:47:23 <lambdabot> Text.Html
01:47:30 <shapr> bzzt
01:47:49 <shapr> @google select filetype:hs
01:47:51 <lambdabot> http://www.venge.net/graydon/cgi-bin/viewcvs.cgi/src/modfs/modfs.hs?r1=1.
01:47:51 <lambdabot> 1.1.1&logsort=cvs
01:48:58 <shapr> Googles shows several select modules.
01:58:18 <shapr> Has anyone tried to replace any Linux system services with a Haskell program? Anything I should consider?
02:13:22 <Lemmih> shapr: What are you replacing?
02:20:17 <shapr> Lemmih: Trying to replace postfix/sendmail/exim4/etc with Postmaster, but I can't seem to figure out enough to do it. I think I'll go back to postfix :-(
02:20:56 <shapr> I think the test-spool setting is fine for the tutorial, but what should go there for running Postmaster as my MTA?
02:21:15 <shapr> Also, I'd like to look up all HELO names to check for validity, but that could wait.
02:42:53 * shapr boings
02:57:04 <SimonRC> is there already a function in Haskell to merge a pair of lists, or do I have to do it myself?
02:57:13 <ndm> SimonRC, define merge
02:57:14 <Lemmih> @type concat
02:57:14 <lambdabot> forall a. [[a]] -> [a]
02:57:17 <Cale> merge in which sense?
02:57:22 <norpan> zip?
02:57:25 <ndm> (++) is one (the most common one)
02:57:48 <ndm> `union` is another good one, if they are "set" like
02:58:02 <Lemmih> @type uncurry (++)
02:58:04 <lambdabot> forall a. ([a], [a]) -> [a]
02:58:09 <SimonRC> I mean, take two ascending lists, and turn them into one big ascending list, containing the same elements.
02:58:15 <SimonRC> like used in merge sort
02:58:22 <xerox> @hoogle zip
02:58:23 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
02:58:23 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
02:58:23 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
02:58:23 <lambdabot> c]
02:58:29 <norpan> @type merge
02:58:29 <xerox> @hoogle unzip
02:58:30 <lambdabot> Not in scope: `merge'
02:58:30 <lambdabot> Data.List.unzip :: [(a, b)] -> ([a], [b])
02:58:30 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
02:58:30 <lambdabot> Data.List.unzip3 :: [(a, b, c)] -> ([a], [b], [c])
02:58:39 <ndm> @hoogle Ord a => [a] -> [a] -> [a]
02:58:41 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
02:58:41 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
02:58:41 <lambdabot> Data.List.(\\) :: Eq a => [a] -> [a] -> [a]
02:58:50 <ndm> @hoogle+
02:58:50 <xerox> @type uncurry (++) . zip
02:58:51 <lambdabot> Data.List.union :: Eq a => [a] -> [a] -> [a]
02:58:51 <lambdabot> Data.List.intersect :: Eq a => [a] -> [a] -> [a]
02:58:51 <lambdabot>   Couldn't match `([a], [a])' against `t -> t1'
02:58:51 <lambdabot>   Expected type: ([a], [a])
02:58:53 <Cale> you'd have to write it yourself
02:59:14 <xerox> @type (uncurry (++) .) . zip
02:59:15 <lambdabot>   Couldn't match `([a], [a])' against `[(a1, b)]'
02:59:15 <lambdabot>   Expected type: [a1] -> [b] -> ([a], [a])
02:59:24 <norpan> @type foldr insert
02:59:25 <lambdabot> Not in scope: `insert'
02:59:31 <norpan> @type foldr Data.List.insert
02:59:32 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
02:59:49 <norpan> there you go
02:59:50 <davidhouse> what does uncurry do?
02:59:53 <ndm> SimonRC, http://www.nmitchell.co.uk/code/haskell.htm has most of the code you need
03:00:09 <ndm> it has mergeUnique, but making it merge standard is just a case of removing one line
03:00:17 <Cale> merge [] ys = ys
03:00:17 <Cale> merge xs [] = xs
03:00:17 <Cale> merge (x:xs) (y:ys) = compare x y of
03:00:17 <Cale>     LT -> x : merge xs (y:ys)
03:00:18 <Cale>     EQ -> x : y : merge xs ys
03:00:19 <mauke> @djinn (a -> b -> c) -> (a, b) -> c
03:00:20 <Cale>     GT -> y : merge (x:xs) ys
03:00:20 <lambdabot> f a (b, c) = a b c
03:00:44 <Cale> oops missed the 'case' before compare
03:01:02 <norpan> just use foldr insert
03:01:04 <norpan> easy
03:01:27 <Cale> but not the same
03:02:09 <SimonRC> ndm: I *know* how to write it, I just thought is would be bad style to re-invent it if it already existed.
03:02:29 <ndm> SimonRC: fair enough, but basic answer is no, you have to write it yourself
03:03:04 <norpan> Cale: in what way is it different
03:03:06 <Cale> norpan: take 10 $ foldr insert [1,3..] [2,4..], doesn't give anything
03:03:30 <Cale> whereas  merge [1,3..] [2,4..] is the same as [1..]
03:03:57 <palomer> @type foldr (:)
03:03:58 <lambdabot> forall a. [a] -> [a] -> [a]
03:03:58 <Cale> also, even for finite lists, the running time will be asymptotically different
03:04:13 <norpan> bah
03:04:21 <palomer> @type let test = if test == 0 then 1 else 0 in test
03:04:22 <lambdabot> forall a.
03:04:22 <lambdabot>                  (Num a) =>
03:04:22 <lambdabot>                  a
03:04:30 <palomer> > let test = if test == 0 then 1 else 0 in test
03:04:32 <lambdabot> Terminated
03:05:29 <palomer> > let test = if test == 0 then 0 else 0 in test
03:05:30 <lambdabot> Terminated
03:05:38 <jethr0_> Cale: i was speaking with philippa and dons earlier about large-scale design using monads. and i was wondering what the telltale signs for a new monad were. would you say recurring control flow patterns?
03:05:40 <ihope> What's the MD5 hash of the empty string?
03:05:46 <palomer> hey guys!
03:05:53 <shapr> d00d
03:05:59 <palomer> what's the algorithm for finding if a case statement is non-exhaustive?
03:06:06 <greenrd> ihope: d41d8cd98f00b204e9800998ecf8427e  /dev/null
03:06:14 <jethr0_> d41d8cd98f00b204e9800998ecf8427e
03:06:21 <Cale> jethr0_: depends which kind of monad :)
03:06:42 <shapr> If there are fewer case branches than ADT constructors, yeah?
03:06:42 <roconnor> $ echo -n | md5sum
03:06:43 <roconnor> d41d8cd98f00b204e9800998ecf8427e  -
03:06:58 <SimonRC> jethr0_: many do what the state and Maybe monads do.
03:06:58 <ihope> What utilities are there to hash hex strings?
03:07:01 <Cale> jethr0_: almost any kind of "container" type can be made into a monad in one way or another.
03:07:02 <jethr0_> Cale: if you were writing a framework and didn't know where to use monads in advance, how would one go about it? start writing and refactor, or ponder endlessly, ...?
03:07:21 <Cale> or are you saying something else -- where should one use monads in code?
03:07:39 <jethr0_> i'm a bit at a loss how to structure large-scale software (i.e. >2000 lines of "normal" languages) in haskell
03:07:48 <SimonRC> @hoogle (a->b) -> (b->b->c) -> (a -> c)
03:07:49 <lambdabot> No matches, try a more general search
03:07:55 <jethr0_> the modularisation using records and modules just doesn't seem to suffice for this
03:08:00 <SimonRC> @hoogle (b->b->c) -> (a->b) -> (a -> c)
03:08:01 <lambdabot> No matches, try a more general search
03:08:03 <SimonRC> bah
03:08:08 <ihope> @djinn (a -> b) -> (b -> b -> c) -> a -> c
03:08:08 <lambdabot> f a b c = b (a c) (a c)
03:08:14 <jethr0_> Cale: where should one write ones own monad
03:08:38 <SimonRC> ihope: I though that might already exist, like it does in J
03:08:57 <Cale> jethr0_: as opposed to using monad transformers, or more generally?
03:09:14 <jethr0_> hmm, generally how to structure "big" programs in haskell
03:09:25 <shapr> Monadic design seems much like oop design to me. Except the shape of the abstraction is layers of chain links instead of a bunch of magnets.
03:09:28 <jethr0_> and dons and philippa argued that much structure would be embedded in monads
03:09:45 <ndm> @hoogle ( a -> b ) -> ( b -> b -> c ) -> ( a -> c )
03:09:46 <lambdabot> No matches, try a more general search
03:09:48 <SimonRC> @hoogle (b->b->c) -> (a->b) -> (a -> a -> c)
03:09:48 <lambdabot> No matches, try a more general search
03:09:50 <ihope> @pl f a b c = b (a c) (a c)
03:09:51 <lambdabot> f = flip =<< (ap .) . flip (.)
03:10:00 <SimonRC> yuk
03:10:02 <jethr0_> shapr: do you know any readable examples for that kind of design?
03:10:03 <ihope> Heh.
03:10:16 <jethr0_> stuff like yi kinda scares me. maybe darcs?
03:10:28 <ihope> So what's (a -> b) -> (b -> b -> c) -> a -> c for?
03:10:32 <shapr> Darcs doesn't much internal abstraction last I checked.
03:10:47 <jethr0_> hmm
03:10:58 <SimonRC> ihope: it was supposed to be hook::(a -> b) -> (b -> b -> c) -> (a -> a -> c)
03:11:05 <shapr> How about looking from the viewpoint of domain specific languages?
03:11:16 <Cale> jethr0_: well, it could be. You must have seen my small sudoku solver. Basically, I'd create a new monad whenever I needed some extra problem-specific computational features.
03:11:20 <ihope> Ah.
03:11:27 <SimonRC> So, to compare two data structures by the field f, you do: "hook compare f"
03:11:36 <shapr> The idea of monads (well, every abstraction) is to hide all the pieces of the program that do not relate to the particular task at hand.
03:11:42 <Cale> yeah, you're basically creating an embedded domain specific language
03:11:45 <SimonRC> ihope: the name "hook" comes from J
03:12:11 <shapr> So you could use {objects,monads,arrows} to make a nice DSL for operating on files and directories.
03:12:31 <davidhouse> Cale, where is your sudoku solver? i could do with seeing some nice algorithms in hs.
03:12:41 <SimonRC> ihope: in J, HoFs are distinct from plain functions, and a hook is written as fg, IIRC
03:12:49 <shapr> And then you'd use that DSL inside a nice database DSL that implemented transactions or whatnot it terms of the file/dir DSL.
03:13:10 <ihope> What's an HoF?
03:13:18 <jethr0_> shapr: ok, i'd never looked at it from that angle...
03:13:29 <shapr> We always want to write code that's at the level of the problem, and DSLs are the best for that.
03:13:32 <Cale> http://www.haskell.org/hawiki/SudokuSolver
03:13:35 <shapr> As an example, think of PHP.
03:14:13 <SimonRC> ihope: higher-order function
03:14:20 <shapr> PHP has a small number of really big chunks of functionality, and a simplistic language that ties those chunks together.
03:14:23 <jethr0_> i'm just always annoyed when i need default values for an algorithm and have to use named records. but i guess i'm still thinking too much in OO terms. sometimes i simply miss initial state
03:14:46 <ihope> @djinn (a -> a -> a -> a -> a) -> (a -> a -> a -> a) -> (a -> a -> a) -> (a -> a) -> a -> a
03:14:47 <lambdabot> f a b c d e =
03:14:47 <lambdabot>   a e (b e (c e (d e)) (c e (d e))) (b e (c e (d e)) (c e (d e))) (b e (c
03:14:47 <lambdabot> e (d e)) (c e (d e)))
03:14:56 <shapr> You can get initial state with partial application, default values in a typeclass declaration, etc.
03:14:59 * jethr0_ doesn't like PHP because he once tried to program OO-style in it and it totally broke
03:15:12 <Cale> I didn't do anything clever in terms of heuristics, it's essentially backtracking brute force, which works well enough for most sudoku problems, but it looks even simpler than that.
03:15:24 <Cale> (the actual part that decides where to place things)
03:15:31 <shapr> I don't like PHP much either, but you can't argue with its popularity.
03:15:43 <ihope> @djinn (a -> a -> a) -> (a -> a) -> a -> a
03:15:44 <lambdabot> f a b c = a c (b c)
03:15:52 <shapr> Obviously it made the problem of sewing together HTML and database bits simple enough that everybody used it.
03:16:53 <jethr0_> i always saw PHP as not really turing complete :). i've unfortunately spent (a short) time using perl and PHP seemed less expressive, somehow
03:17:02 <shapr> I think you're right.
03:17:08 <ihope> Lambdabot's not replying to /msg's.
03:17:20 <shapr> PHP isn't a general purpose programming language, but then it wasn't designed to be.
03:17:50 <jethr0_> shapr: i tried references on references and it totally broke down. but then again it's not supposed to be used that way, probably
03:17:55 <davidhouse> PHP wasn't designed.
03:18:13 <jethr0_> shapr: any ideas where to look for bigger programs that are implemented in your DSL fashion, maybe sth you wrote?
03:18:25 <jethr0_> davidhouse: few languages ever were
03:18:34 <shapr> It's not my DSL fashion :-) It's Paul Hudak's if anyone's...
03:18:48 <shapr> He's done the coolest DSL work, imho
03:18:57 <shapr> Look at Dance, for example.
03:19:00 <jethr0_> you mean like fran?
03:19:15 <shapr> I mean like Haskore.
03:19:40 <shapr> The original Haskore was a simple and beautiful DSL.
03:20:02 <jethr0_> hm, k. maybe i'll look at the haskore code
03:20:04 <shapr> The current version is powerful and necessary break with the original version.
03:20:24 <ihope> > 330597555467039442158611922708179366597 * 195712774071374193487969453352655688097
03:20:25 <lambdabot> 647021646816692886828286740869079848357144047091849139822657356983626522959
03:20:25 <lambdabot> 09
03:20:52 <palomer> @type 4
03:20:53 <lambdabot> forall t. (Num t) => t
03:21:31 <jethr0_> shapr: you got a minute?
03:23:47 <roconnor> @what DSL
03:23:48 <lambdabot> I know nothing about dsl.
03:23:57 <jethr0_> domain specific language
03:24:28 <jethr0_> kinda bottom-up in the sense of getting the language to the problem instead of reducing the problem to a low-level language
03:24:54 <lennart> or top down
03:24:57 <lennart> :)
03:25:35 <jethr0_> lennart: that wouldn't fit my definition of DSL anymore because it would be just a solution which happened to have nice abstractions. but i guess it qualifies
03:26:36 <jethr0_> although, as usually i might be dead wrong :)
03:26:44 <Lemmih> Wow. Compiling "{-# OPTIONS" with GHC results in a very bad error message.
03:26:56 <ihope> What? What?
03:28:19 <shapr> jethr0_: whatcha need?
03:28:27 <roconnor> @info Map
03:28:28 <lambdabot> Unknown command, try @listcommands.
03:28:33 <roconnor> @docs Map
03:28:34 <lambdabot> Map not available
03:28:38 <roconnor> @docs Data.Map
03:28:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
03:29:01 <jethr0_> i'm trying to write a scrabble game as a problem to "study" good haskell design. would you give a few hints how you'd approach it?
03:29:33 <lisppaste2> jethr0 pasted "scrabble notes" at http://paste.lisp.org/display/17541
03:30:01 <jethr0_> it's really just scribbly notes yet as i am trying to figure out how to approach this
03:30:28 <jethr0_> (as a design study :)
03:31:50 <shapr> What do you think is the problem level? How would a scrabble expert describe the game?
03:32:59 <jethr0_> shapr: pretty much my top comment in the past
03:33:27 <jethr0_> a player get's a board and a rack with letters and tries to put the letters on the board in one continuous line in order to maximize his points.
03:33:36 <jethr0_> but i guess it's not domain specific enough
03:33:53 <shapr> That's one step of the game.
03:34:24 <jethr0_> how would you describe it?
03:34:29 <shapr> You could write a Scrabble monad that had a few monad transfomers stacked up.
03:34:50 <shapr> Letters, board, and weights would be read-only state for each game, but would be different per language.
03:34:51 <ihope> :-)
03:35:20 <jethr0_> i don't quite follow
03:35:22 <shapr> Various bits of state need to be passed from one step to another.
03:35:26 <ihope> @index (>>=)
03:35:26 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer,
03:35:26 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.
03:35:26 <lambdabot> Monad.Cont, Control.Monad.Error, Control.Monad.List
03:36:00 <davidhouse> in general, is haskell used more for specific problems like solving sudoku, scrabble etc, or for actual applications?
03:36:10 <jethr0_> davidhouse: hehe
03:36:21 <norpan> both
03:36:33 <jethr0_> shapr: and input has to be interleaved too.
03:36:38 <jethr0_> s/input/IO/
03:36:40 <ihope> data Scrabble a = MaybeT (ReaderT (WriterT (StateT (RWST (IdentityT (ContT (ErrorT (ListT IO)))))))) a
03:36:47 <ihope> Or something like that...
03:36:52 <shapr> The set of letters and weights is different for English, Swedish, and German, for example. But that sort of state is the same while you're playing a game, so I'd probably put read only state at the bottom of the monad transformer.
03:37:26 <ihope> @index MaybeT
03:37:26 <lambdabot> bzzt
03:37:31 <ihope> @index ReaderT
03:37:32 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.
03:37:32 <lambdabot> Monad.RWS
03:37:41 <ihope> @index RWST
03:37:41 <jethr0_> shapr: k. and how would the "move" be communicated?
03:37:42 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
03:38:35 <Cale> don't use data, use newtype, as you can then use deriving to derive Functor and Monad
03:38:50 <ihope> Ah, cool >:-D
03:39:24 <roconnor> IdentityT!
03:39:38 <shapr> jethr0_: I'd start with being able to handle the simplest move, are there cases where a player can pass, or must pass?
03:39:39 <ihope> The most useful monad transformer of the bunch...
03:39:40 <jethr0_> i'm still not convinced/sure. after a move i have to "update" the bag of letters, the player's letter rack, the board.
03:39:46 <shapr> If so, the simplest move would be just passing the state along unchanged.
03:40:12 <jethr0_> shapr: i agree, but i haven't got any form of structure in my head yet...
03:40:36 <jethr0_> and one thing TDD isn't so good at is emerging top-level design
03:40:54 <shapr> It could be, when mixed with QuickCheck :-)
03:40:55 <Cale> Have a StateT with a state type encompassing the game state, and then only provide restricted forms of get and put which allow for legal moves to be made
03:41:09 <Cale> if you need undo, there's a monad transformer for that as well :)
03:41:14 <jethr0_> k
03:41:29 <jethr0_> and i need IO for user interaction at some point. so should i layer StateT on IO?
03:41:32 <ihope> Now why isn't lambdabot responding to private messages?
03:41:51 <Cale> jethr0_: quite possibly
03:42:11 <davidhouse> jethr0_, how long have you been programming haskell?
03:42:15 <Cale> @reconnect
03:42:30 <shapr> The idea here is that each layer of the monad transformer is mostly independent. You can modify one layer without changing the others.
03:42:31 <jethr0_> davidhouse: a few months. the last 4 fews very actively
03:42:37 <Cale> hmm
03:42:52 <Cale> there we go :)
03:43:35 <shapr> Thus my description of the maximum 'complexity of change' for the monadic abstraction being 'max number of layers in a monad transformer' vs the object abstraction being 'max number of instances'.
03:44:12 * shapr isn't sure if that's accurate.
03:44:20 <jethr0_> Cale: what does the restricted "put" return on invalid moves?
03:44:38 <davidhouse> jethr0_, nice. i'm just curious because i've only been at it a few weeks and you're one of the programmers in here who isn't absolutely god-like but still pretty damn decent (don't take that as an insult). just wondering how long it'll take to get to that kind of ability.
03:45:02 <shapr> hah
03:45:16 <shapr> I feel pretty clueless most of the time... god-like my gluteas maximus.
03:45:40 <jethr0_> davidhouse: i'm not offended. i think i'm pretty advanced in haskell by now, but as i like to expand my knowledge rather than use it, i guess i'll stay a newbie for quite a while :)
03:46:06 <davidhouse> jethr0_, are you a CS student or just a hobbyist?
03:46:08 <jethr0_> on the other hand, i only understand 50% of the discussion topics in here, so maybe not so advanced after all
03:46:18 <jethr0_> CS studying hobbyist
03:46:23 <shapr> I'll claim to be a real Haskell programmer when I have a steady job doing it. :-/
03:46:25 <davidhouse> ah, okay.
03:46:30 <jethr0_> but my CS studies didn't really help all that much
03:46:49 <davidhouse> well, 50% is a damn sight more than I :)
03:47:32 <Cale> jethr0_: well, that's up to you. It could throw an exception, or it could simply return a Boolean value which let you know if it succeeded, and do nothing.
03:47:49 <Cale> In some monads, using mzero is a nice option.
03:47:56 <jethr0_> davidhouse: it went very much in phases for me. after having grappled with the "report" basics for a while, i tried monads and am still not "finished" with those
03:48:33 <davidhouse> mm. yeah.
03:48:40 <jethr0_> i'd love to experiment with delimited continuations a la shift/reset, but there's simply not enough material for me to steal :)
03:48:52 <davidhouse> i have no idea what you just said.
03:49:09 <davidhouse> or what you meant, rather.
03:49:10 <davidhouse> :)
03:49:12 <jethr0_> hehe, never mind, it's not a very haskellish topic anyways
03:49:20 <shapr> A continuation is something that represents the 'rest of a computation'.
03:49:56 <Cale> the "do nothing" option is actually kind of neat, as the state simply won't change when an invalid move is made, so if there's any GUI present, it just won't let the player make the invalid move
03:49:57 * davidhouse can use monads, but i don't think i'd know when to create one. he's currently learning about monad transformers
03:50:02 <jethr0_> shapr: btw, how is it going with epigram. the notation scares me a bit judging by the papers
03:50:07 <shapr> Think of freezing a running computation as a value.
03:50:30 <shapr> jethr0_: I've been distracted by my paying work, and my Evil Project.
03:50:40 <jethr0_> Cale: i'll try to implement it that way...
03:50:45 <ihope> @type succ
03:50:46 <lambdabot> forall a. (Enum a) => a -> a
03:50:53 <jethr0_> shapr: yes, i remember, your secret project that will change the world
03:50:57 <shapr> Epigram notation is just the fraction-lookalike notation that says "this code has this type."
03:51:13 <jethr0_> shapr: yeah, but it's so... two-dimensional :)
03:51:19 <shapr> jethr0_: Only one section of the IT Industry, and even then, only if it works =)
03:51:31 <shapr> Yeah, that is nifty.
03:51:39 <ihope> Haskell is sort of two-dimensional, but...
03:56:22 <shapr> jethr0_: Do you own or have read TaPL?
03:56:38 <roconnor> @pf (\b s a -> (tranformSet b s)<+>a)
03:56:39 <lambdabot> ((<+>) .) . tranformSet
03:56:50 <roconnor> @pf (\b s a -> a<+>(tranformSet b s))
03:56:51 <lambdabot> (flip (<+>) .) . tranformSet
03:57:48 <jethr0_> shapr: i've got it and skimmed it. but right now it lies at home and it seemed a bit too theoretical for my taste
03:58:00 <jethr0_> s/at home/at my parents/
03:58:26 <jethr0_> but i guess i'll come back to it eventually
03:58:53 <shapr> Epigram notation is the same as the type notation in TaPL.
03:59:03 <jethr0_> samb's brainf*ck interpreter becomes cooler each time i look at it
03:59:09 <roconnor> newtype LinearTransform = LinearTransfrom (Map Index (Map Index Scalar))
03:59:20 <jethr0_> shapr: i've seen the notation before in denotational semantics or some such
04:06:44 <shapr> Is SASL the only way to submit encrypted mail to a server? Is there something simpler?
04:06:56 * shapr considers hacking Postmaster to do something simpler :-)
04:07:01 <stesch> rot13 :-)
04:07:35 <ihope> Ah yes. rot13 is a very secure encryption algorithm indeed.
04:07:50 <jethr0_> it's virtually unbreakable. unless you know the key
04:07:53 <jethr0_> :)
04:08:05 <jethr0_> *take that NSA*
04:08:22 <stesch> Don't mock Caesar!
04:08:37 <jethr0_> didn't caesar use rot3?
04:09:54 <shapr> Caesar used the stick and scroll method. Real message letters would be written once ever rotation of the stick, with chaff between those letters. Then he sent the stick and message by separate couriers.
04:10:56 <shapr> At least, that's what I read :-)
04:12:31 <ihope> I guess Caesar didn't have RSA.
04:14:52 <stesch> And NSA. :-)
04:16:08 <ihope> :-)
04:16:19 <orbitz> good afternoon
04:16:23 <ihope> So these guys are calling RSA unbreakable?
04:17:27 * stesch liked the movie ...
04:17:39 <ihope> Well, I guess encrypting 3947 with a private key like 53436398978783282707130841686189557896970113387173745328727976545685933155033-184551143855540497053876453570829485929-311587867708298779857885336494189972161 is probably unbreakable ;-)
04:17:50 <jethr0_> not exactly short :(
04:17:51 <jethr0_> > let rot13 = map (let oa = ord 'A' in chr . (+oa) . (`mod` 26) . (+13) . (+(-oa)) . ord . toUpper) in rot13 . rot13 $ "HELLOWORLD"
04:17:53 <lambdabot> "HELLOWORLD"
04:18:19 <jethr0_> i guess bit-twiddling languages like c or perl are better for concise versions...
04:18:33 <ihope> > let rot13 = map (let oa = ord 'A' in chr . (+oa) . (`mod` 26) . (+13) . (+(-oa)) . ord . toUpper) in rot13 "HELLOWORLD"
04:18:34 <lambdabot> "URYYBJBEYQ"
04:18:35 <stesch> http://www.miranda.org/~jkominek/rot13/
04:18:47 <ihope> > let rot13 = map (let oa = ord 'A' in chr . (+oa) . (`mod` 26) . (+13) . (+(-oa)) . ord . toUpper) in rot13 "Hello, world!"
04:18:48 <lambdabot> "URYYBSGJBEYQH"
04:18:58 <ihope> Heh.
04:19:05 <ihope> > let rot13 = map (let oa = ord 'A' in chr . (+oa) . (`mod` 26) . (+13) . (+(-oa)) . ord . toUpper) in (rot13 . rot13) "Hello, world!"
04:19:06 <lambdabot> "HELLOFTWORLDU"
04:19:07 <jethr0_> hmm, actually it's stupid to restrict it to letters *stupid me)
04:19:27 <jethr0_> > let rot13 = map (chr . (`mod` 255) . (+13) . ord) in rot13 . rot13 $ "HELLOWORLD"
04:19:28 <lambdabot> "b_ffiqilf^"
04:19:40 <stesch> jethr0_: Nope. rot13 is only defined for letters.
04:19:45 <jethr0_> d'oh
04:19:59 <stesch> jethr0_: Only some stupid Windows newsreader think otherwise
04:20:00 <palomer> > ord 'A'
04:20:01 <lambdabot> 65
04:20:01 <jethr0_> well, it's not involutorical otherwise
04:20:22 <jethr0_> or however that word is in english. self-reversing
04:20:23 <palomer> wait, why doesn't jethr0_ last code not work?
04:20:47 <jethr0_> because rot128 would :)
04:21:01 <jethr0_> > let rot13 = map (chr . (`mod` 256) . (+128) . ord) in rot13 . rot13 $ "HELLOWORLD"
04:21:03 <lambdabot> "HELLOWORLD"
04:21:15 <ihope> rot95.
04:26:48 <jethr0_> > let rot256 = map (chr . (`mod` 256) . (+256) . ord) in rot256 "HELLOWORLD"
04:26:50 <lambdabot> "HELLOWORLD"
04:28:23 <roconnor> > maxBound :: Char
04:28:24 <lambdabot> '\1114111'
04:28:38 <jethr0_> > ord $ maxBound :: Char
04:28:39 <lambdabot> Couldn't match `Char' against `Int'
04:28:56 <roconnor> > ord $ (maxBound :: Char)
04:28:57 <lambdabot> 1114111
04:29:11 <jethr0_> yup, that must be it
04:35:33 <roconnor> @hoogle Gen a -> IO a
04:35:34 <lambdabot> System.Exit.exitFailure :: IO a
04:35:48 <roconnor> *sigh*
04:37:21 <roconnor> @hoogle Arbitrary a -> IO a
04:37:22 <lambdabot> System.Exit.exitFailure :: IO a
04:37:56 <jethr0_> @seen cale
04:37:57 <lambdabot> cale is in #haskell. Last spoke 47 minutes and 58 seconds ago.
04:38:17 <Cale> hi
04:38:21 <jethr0_> hi there :)
04:38:26 <roconnor> @hoogle System.Random.StdGen
04:38:27 <lambdabot> Prelude.undefined :: a
04:38:27 <lambdabot> Test.QuickCheck.Batch.bottom :: a
04:38:37 <jethr0_> when you said "restrict get and put to valid moves" how did you mean that?
04:38:47 <roconnor> @hoogle StdGen
04:38:47 <jethr0_> i can't hide them, can i?
04:38:47 <lambdabot> System.Random.StdGen :: StdGen
04:38:47 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
04:38:47 <lambdabot> System.Random.getStdGen :: IO StdGen
04:39:31 <Cale> jethr0_: sorry, just put
04:39:37 <jethr0_> i know
04:39:58 <jethr0_> but still, do you mean to write another function or did you really mean "restrict"?
04:40:13 <SimonRC> Why doesn't supplying an instance for Ord automatically supply and instance for Eq?
04:41:10 <Cale> hang on, phone
04:41:17 <jethr0_> np at all
04:41:34 <Cale> okay
04:41:54 <Cale> I mean write another function and don't implement MonadState
04:42:04 <Cale> and hide the constructor of your newtype
04:42:26 <roconnor> SimonRC: Haskell is a bit broken with regards to that.
04:42:36 <SimonRC> ah, ok
04:43:00 <roconnor> I think maybe you can define a == b = (compare a b)==Eq
04:43:04 <jethr0_> hmm, so i shouldn't use StateT then? because that would automatically supply get/set/modify, no?
04:43:07 <jethr0_> hmm, i'm confused
04:43:14 <int-e> Well, you can't provide an Ord instance before you have an Eq instance.
04:43:15 <roconnor> even before you have defined compare
04:43:17 <Cale> have a look at the Sudoku solver -- it's a newtyped StateT, but it doesn't derive MonadState, instead, the function 'place' is written in order to place a number in the grid in some valid way only.
04:43:29 <jethr0_> cool, thx
04:44:18 <jethr0_> Cale: doesn't it bother you sometimes that you have to start a new file just to be able to hide a few accessors/functions? it drives me crazy...
04:44:39 <Cale> not too much, though it would be nice to have multiple modules in the same file
04:44:54 <Cale> there's nothing in the standard which prevents that, it's just how GHC/Hugs happen to work.
04:45:21 <int-e> It could have efficiency reasons; if you have many independent classes I think you end up passing around many dictionaries in the current implementations; class Eq a => Ord a where also means that you can include the Eq dictionary in the Ord one, as an optimization.
04:46:54 <jethr0_> and also finding modules would become _much_ harder
04:47:29 <roconnor> @docs Arrow
04:47:30 <lambdabot> Arrow not available
04:47:55 <roconnor> what are the operations on Arrows?
04:47:59 <SimonRC> int-e: I thought all the polymorphism disappeared at compile-time, replaced by multiple copies of functions.
04:48:15 <roconnor> oh wait
04:48:18 <roconnor> @hoogle Arrow
04:48:19 <lambdabot> Control.Arrow.Arrow :: Arrow a
04:48:19 <lambdabot> Control.Arrow.ArrowZero :: Arrow a => ArrowZero a
04:48:19 <lambdabot> Control.Arrow.ArrowPlus :: ArrowZero a => ArrowPlus a
04:48:30 <roconnor> @info Control.Arrow.Arrow
04:48:30 <lambdabot> Unknown command, try @listcommands.
04:49:15 <int-e> SimonRC: it doesn't. it's not even possible in general.
04:49:18 <xerox> lennart: ping!
04:49:20 <roconnor> whoa, whats the diff between arr and pure?
04:49:26 <xerox> roconnor: none?
04:49:32 <roconnor> ok
04:49:57 <int-e> SimonRC: consider, for example the crazy type  data Tree a = Leaf a | Branch (Tree (a,a))
04:50:11 <palomer> so what's the standard way of deciding if a case statement is non-exhaustive?
04:51:04 <int-e> SimonRC: and treeToList (Leaf a) = [a], treeToList (Branch a) = concatPairs (treeToList a)
04:51:15 <int-e> SimonRC: (concatPairs does the obvious thing)
04:51:35 <palomer> int-e: I'm not sure Tree represents a Tree
04:51:50 <int-e> palomer: it represents a perfectly balanced binary tree
04:52:01 <int-e> palomer: in a very, very weird way.
04:52:07 <palomer> don't you mean Tree a = Leaf a | Branch a (Tree a) (Tree a) ?
04:52:15 <int-e> palomer: Branch should probably be called 'Nest'
04:52:19 <int-e> palomer: no I don't.
04:53:00 <palomer> Leaf 1 is a Tree, so is Branch (Leaf (1,1)) so is Branch Branch (Leaf ((1,1),(1,1))) ...
04:53:16 <palomer> oh, you're right, it is a balanced binary tree
04:53:21 <palomer> a crazy one
04:53:23 <int-e> palomer: Nest is definitely a better name.
04:54:13 <int-e> anyway, the point is, that you can't predict all types that treeToList will ever encounter at compile time.
05:01:04 <palomer> int-e: could that datatype ever be useful?
05:02:05 <int-e> palomer: hmm, probably not.
05:04:03 <int-e> palomer: except for excercising compilers and type checkers that is. on the other hand, type level calculations (for example for implicit parameters using type classes) do something similar.
05:04:26 <palomer> type classes can have implicit parameters
05:07:36 <Lemmih> What's the syntax for the LANGUAGE pragma?
05:07:54 <Lemmih> {-# LANGUAGE extension, extension #-}?
05:11:02 <davidhouse> we should log this. "the day Lemmih asked a question".
05:11:35 <davidhouse> :)
05:11:47 <ncalexan> @quote+ we should log this. "the day Lemmih asked a question".
05:11:47 <lambdabot> we should log this. "the day Lemmih asked a question". hasn't said
05:11:47 <lambdabot> anything memorable
05:11:58 <ncalexan> @quote-add we should log this. "the day Lemmih asked a question".
05:12:03 <ncalexan> @quote-add
05:12:14 <ncalexan> Right, I can't do this.
05:12:24 * Lemmih laughs.
05:12:28 <int-e> @quote we
05:12:29 <lambdabot> babel module failed: getRandItem: empty list
05:12:43 <ncalexan> Moreover, lambdabot can't handle this :)
05:13:10 <palomer> @quote palomer
05:13:11 <lambdabot> palomer hasn't said anything memorable
05:13:16 <palomer> what? I did so!
05:13:21 <SimonRC> int-e: actually, I think I have seen a "2-3 tree" done the way you rtree was.
05:13:44 <ncalexan> @quote dons
05:13:44 <lambdabot> babel module failed: getRandItem: empty list
05:13:58 <palomer> @quote Cale
05:13:59 <lambdabot> babel module failed: getRandItem: empty list
05:14:12 <palomer> who broke lambdabot?
05:14:52 * ncalexan raises hand?
05:15:14 <int-e> SimonRC: hmm, I doubt that. There's no room for storing the data for the internal nodes.
05:17:33 <SimonRC> I only meant it used a type trick a bit like that
05:17:53 <SimonRC> it came in 2 data declarations, IIRC.
05:18:24 <int-e> SimonRC: it's possible though, something like data Node k e = Branch2 e k e | Branch3 e k e k e; Tree k e = Leaf k e | Nest (Tree k (Node k e)) ... hmm.
05:18:47 <int-e> Leaf k e --> Leaf (Node k e)
05:19:01 <int-e> ah no. got it right the first time.
05:19:46 <SimonRC> I forget how it worked, except that only trees with 2^n to 3^n leaves could be of the same type.
05:20:06 <SimonRC> erm, actually, maybe not
05:22:24 <int-e> SimonRC: Yes, it works. Fun :)
05:28:19 <MarcWeber> Lemmih, jethr0_ This is my attempt of caching information.. How to make this actually cache? Run it and watch the trace output.. http://www.rafb.net/paste/results/awI9Mg98.html
05:33:53 <roconnor> can I limit the memory size of my ghci sessions?
05:34:37 <Lemmih> MarcWeber: eh.
05:36:05 <MarcWeber> roconnor: There is a -H16m switch which does something related using ghc.. But I'm not sure and I can't find the documentation right now..
05:36:19 <roconnor> thx
05:36:33 <ncalexan> roconnor: there is an option to not cache results across repl invocations; that might help.  I can't remember what it is; maybe :r.
05:36:55 <MarcWeber> Lemmih: It took me quite a while to write it again.. so I'm not sure wether you'll understand everything at the first glance or wether you want to read that code anyway.. ;-)
05:37:21 <ncalexan> roconnor: try http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-set.html#id3105814
05:37:26 <ncalexan> +r looks close.
05:38:31 <Lemmih> MarcWeber: Why not: 'case exspensivePureCalculation a b c of result -> do fn1 result; ...; fn2 result'?
05:39:15 <roconnor> not really, I'm trying to stop my code from spinning out of control before it starts thrashing
05:39:36 <roconnor> actually, maybe my shell can do it.
05:39:48 <roconnor> something about limits 
05:40:02 <Lemmih> roconnor: -M<size> Sets the maximum heap size (default unlimited)  Egs: -M256k -M1G
05:40:13 <roconnor> that would be helpful
05:40:13 <Lemmih> roconnor: -K<size> Sets the maximum stack size (default 8M)  Egs: -K32k   -K512k
05:40:23 <roconnor> there's a stack?
05:40:41 <MarcWeber> Lemmih: I can't follow you.. Why are you using case at all?
05:40:55 <Lemmih> MarcWeber: 'case' is strict.
05:41:25 <MarcWeber> I still need some explanation
05:41:26 <ncalexan> roconner: if it's thrashing, your computation requires more memory than you have; how is changing the memory options going to help?  The best it could do is abort before it pages.
05:41:28 <Lemmih> MarcWeber: Using 'result' wont execute 'exspensivePueCalculation' again.
05:42:11 <roconnor> ncalexan: yes, I want it to abort.  If it is thrashing, then my code is usually broken anyways
05:42:16 <Lemmih> roconnor: Yep. Try running 'sum [1..1000000]' in ghci.
05:42:33 <MarcWeber> Where do I have to use that case? in getFirst?
05:43:01 <roconnor> omg, where'd that stack come from?
05:43:32 <ncalexan> roconnor: that's an OS level decision, I should think.  I don't know of anything that GHC does that would figure out when the surrounding paging is too slow :(
05:44:04 <roconnor> ncalexan: but I could ask ghci not to ever allocate more that 256MB
05:44:24 <roconnor> and just abort the evaluation
05:44:46 <MarcWeber> Lemmih: ?
05:44:54 <ncalexan> Point.
05:44:55 <Lemmih> MarcWeber: You have to redesign your program, I think. I have no idea what the code you posted is trying to do.
05:45:41 <ncalexan> MarcWeber: I have a guess at what you're trying to do, but you've conflated so many different things into the code.
05:45:58 <vincenz> > sum [1..1000000]
05:46:00 <lambdabot> Exception: stack overflow
05:46:02 <ncalexan> There's the Dynamic/Typeable stuff, the IO stuff, the actual computation... a lot of those can be handled one at a time.
05:46:03 <vincenz> woah
05:46:06 <MarcWeber> ncalexan: It took me days to put it all together (in my project)... ;-)
05:46:19 <vincenz> > foldr (+) 0 [1..1000000]
05:46:21 <lambdabot> Exception: stack overflow
05:46:22 <vincenz> > foldl (+) 0 [1..1000000]
05:46:24 <lambdabot> Exception: stack overflow
05:46:36 <ncalexan> > foldr' (+) 0 [1..1000000]
05:46:37 <lambdabot>  Not in scope: `foldr''
05:46:43 <Lemmih> > foldl' (+) 0 [1..1000000]
05:46:45 <lambdabot> 500000500000
05:47:04 <ncalexan> MarcWeber: you might also be interested in the old IOExts Memo module.  It did something similar, without any disk.
05:47:28 <ncalexan> Due warning: this caching idiom seems very hard to get right.
05:47:50 <ncalexan> But I'm no expert -- please prove me wrong, I want the same behaviour you do!
05:48:03 <MarcWeber> ncalexan, Lemmih I want to create a haskell make system. Think of a target "all" which should make a.exe and b.exe. Both should be made by ghc with ghc --make helloworld.hs -o a/b.exe..
05:48:38 <MarcWeber> then I will get a nice tree all depends on a/b.exe which both depend on helloworld.hs
05:49:07 <MarcWeber> When checking the b.exe for dependencies I don't want to ask the os again wether the hs file exists. Here I need caching.
05:49:38 <Lemmih> MarcWeber: Use a state monad where you save dependency trees?
05:49:59 <MarcWeber> .. don't know yet.. finally of course..
05:50:00 <ncalexan> MarcWeber: that sounds like a false economy to me, but that's not really the point.
05:50:35 <MarcWeber> ncalexan: doesFileExist is just an example.. think of a dependency tree which depends on a tool which can be retrieved from the internet.. 
05:50:36 <ncalexan> I think the FS will do a better job servicing that request from it's cache the second time than your code will, but that's just my gut feeling.
05:50:50 <ncalexan> That's why I said it wasn't the point :)
05:51:18 <Lemmih> MarcWeber: I don't understand why you wont use a state monad.
05:51:20 <ncalexan> I understand the idiom.  SPJ wrote a paper about similar things; that led to WeakRef et al.
05:51:22 <MarcWeber> If you have 2000 files which depends on that tool and another file I don't want to send 2000 requests to get the response "server down" ..
05:51:44 <MarcWeber> Is WeakRef related to STRef?
05:51:47 <ncalexan> Is this stuff across invocations?
05:52:01 <ncalexan> Of the program, that is?  That would explain why StateT is not applicable.
05:52:05 <MarcWeber> Can you rephrase this question?
05:52:23 <ncalexan> Are you caching deps/build info between runs of the make program?
05:52:42 <MarcWeber> no I don't think so... but why not?
05:52:46 <Lemmih> ncalexan: One would just save the state to disk.
05:52:52 <ncalexan> Lemmih: point.
05:53:45 <Lemmih> ncalexan: (re WeakRef) He want the information to be garbage collected when memory gets tight?
05:54:10 <MarcWeber> ncalexan: consider a stuipd user creating a thise rules (A->B) (B-A) .. are they stupid at all? if he tries to make A the system needs check the path .. if a dependency is already there abort because it would lead to a cycle..
05:54:24 <MarcWeber> That's why I need that existential and (==) stuff..
05:55:08 <ncalexan> Lemmih: I don't know.  Do you remember the SPJ paper on memo-izing?  They consider issues like this, perhaps minus the disk cache.
05:55:10 <MarcWeber> Java has that stuff, too, right?
05:55:23 <Lemmih> MarcWeber: From what I've understood, keeping a piece of state is exactly what you want.
05:55:37 <MarcWeber> Yeah.. of course.
05:56:10 <Lemmih> And a state monad is a great way to do just that.
05:56:29 <MarcWeber> But how is this done in haskell exactly? Do I have to introduce some artifical "executed before" what you would do in imperative languages?
05:56:43 <ncalexan> Sorry, I must have misunderstood the requirements pretty severely.  My fault.
05:56:53 <ncalexan> @oldwiki MonadState
05:56:54 <lambdabot> http://www.haskell.org/hawiki/MonadState
05:57:30 <MarcWeber> And I don't see why the State monad should solve my problem because it's only syntactic suggar, right
05:57:36 <goron> What is a more clean alternative to OTOH(which is jargon)?
05:58:08 <Lemmih> MarcWeber: Figure out what information you don't wanna recompute and put it in the state.
05:58:13 <integral> "On the other hand" -- written in full isn't that obscure an english phrase
05:58:30 <ncalexan> Alternatively?  From another perspective?  Viewed in another light...
05:58:47 <ncalexan> In contrast, ...
06:02:51 <SimonRC> Is there any good way to save data structures containing infinite lists, functions, etc to a file?
06:03:55 <SimonRC> The elegance of my datastructures is slightly impeded by not being able to serialise such things.
06:03:59 <goron> ncalexan: good suggestion, ty.
06:04:00 <Lemmih> SimonRC: Not really.
06:04:05 <SimonRC> bah
06:05:37 <MarcWeber> Why did I think haskell would do this automatically..
06:07:30 <MarcWeber> Then I would introduce a datasturcture like this: data HaveResultYet a= Just a | NotYetQurried .. Or I'll just use nothing..
06:09:04 <MarcWeber> I thought haskell would remember results because it computes them if needed....
06:09:24 <Lemmih> MarcWeber: It does.
06:09:41 <Lemmih> but (fn x,fn x) are two different results.
06:09:54 <Lemmih> (or well, two different closures)
06:11:09 <MarcWeber> I thouht that when using existential types haskell only saves functions.. not the object itself.. I can't remember who I talked with..
06:11:43 <Lemmih> What object are you referring to?
06:11:49 <MarcWeber> So I thought if using the same "function table" from the array I might get the same results without recomputing..
06:12:46 <MarcWeber> CacheItem in my case
06:14:20 <MarcWeber> When having a some "record" data FunTable :: FunTable { getDB::DB; closeDB::IO () }
06:14:43 <MarcWeber> and you return this FunTable in any functions you don't know wether you've returned functions or the values..
06:14:50 <MarcWeber> There is no difference.
06:15:09 <MarcWeber> But you can't return the values as it wouldn't be lazy then..
06:15:18 <MarcWeber> This kind of data type is used in HSQL
06:15:46 <MarcWeber> Aeh.. DB should be IO DB of cause..
06:16:21 <Lemmih> I can see your words but they don't make sense to me, sorry.
06:17:24 <MarcWeber> Lemmih: when using an imperative language you return either pointers to functions as record or the results of the function as a record.. You can't make this difference in haskell.
06:18:25 <MarcWeber> Because type Int may be a value or a function returning an Int ..
06:18:42 <Lemmih> Um.
06:19:03 <MarcWeber> What is IO Int then?
06:19:23 <MarcWeber> is it a function returning an Int or is it the returned value ?
06:19:41 <Lemmih> Neither (:
06:19:56 <Lemmih> It's an IO action returning an Int.
06:20:09 <MarcWeber> eg data Int = Int (IO Int)  ...
06:20:23 <Lemmih> Now you've lost me again.
06:20:31 <MarcWeber> then you can use the constructor this way : Int 2 or that way  Int (sqr 4) ...
06:21:05 <Igloo> What type are you trying to use 2 with there?
06:21:10 <MarcWeber> In the first case I think of the data beeing some "memory" which is assigned the hex DWORD (whatever) value 0002 ..
06:21:37 <MarcWeber> In the second case you can't assign the result because you may not compute the result until really needed..
06:21:42 <MarcWeber> ::Int
06:21:47 <MarcWeber> @Igloo
06:21:48 <lambdabot> Unknown command, try @listcommands.
06:21:54 <Igloo> Then you can't do that
06:22:03 <Igloo> Your Int constructor takes an IO Int, not an Int
06:22:15 <MarcWeber> Then use return 2
06:22:44 <palomer> annotations never ever change the evaluation of a term, right?
06:23:28 <MarcWeber> OK so when using IO Int I will ever have a function reference..
06:26:13 <MarcWeber> So when using that IO value return or sqr will be executed every time again?
06:28:06 <Lemmih> case sqr 4 of x -> print (x,x) -- This'll only run 'sqr' once.
06:28:14 <lennart> palomer: annotations are not supposed to change the meaning of your program, but who knows what compiler writers come up with :)
06:29:11 <palomer> lennart: when checking case expressions for exhaustiveness, do we usually take into account the type of the scrutinee?
06:29:36 <palomer> (assume simple patterns)
06:29:55 <lennart> palomer: Usually we don't, because usually it doesn't matter
06:31:01 <lennart> but with GADTs it can, I don't know what ghc does there
06:32:16 <palomer>  case x of C x1 y1 -> e1; C x1 y2 -> e2; C x2 y1 -> e3; C x2 y2 -> e4 ~= case x of C x1 z -> (case z of y1 -> e1; y2 -> e2); C x2 z -> (case z of y1 -> e3; y2 -> e4) ?
06:32:38 <palomer> like, is unrolling nested paterns into simple patterns always a trivial matter?
06:33:22 <ncalexan> palomer: IIRC, SPJ & Lester's book has a section on this.
06:33:28 <lennart> palomer: I'm not sure about trivial, but it's mechanical
06:33:49 <lennart> I didn't seem totally trivial to me when I first did it :)
06:34:36 <ncalexan> lennart: you wrote the original article, no?
06:34:40 <lennart> yes
06:35:16 <ncalexan> Another feather in your cap.
06:36:09 <lennart> it was in the air at that time.  what i did differently was to ensure you didn't get a blowup in size (it linear in the original size)
06:37:09 <Philippa> most things don't the first time, no?
06:37:14 <lennart> at the cost of possiblty examining the same value more than once
06:37:29 <lennart> Philippa: that seems to be the way :)
06:37:30 <palomer> which original article?
06:37:52 <lennart> about compiling pattern matching
06:37:59 <Philippa> the one that strikes me as a PITA is adding guards on top
06:38:55 <lennart> guards didn't make it much more difficult for me.  it probably depends on how you've structured the algorithm
06:39:30 <palomer> lennart: dml is the sml equivalent of cayenne, right?
06:39:50 <lennart> it's interesting to look back at the things we struggled with and see how they are totally mainstream and easy these days :)
06:40:01 <lennart> palomer: not really
06:40:42 <lennart> dml does not make more programs have a type (like cayenne), instead it allows you to make more exact types
06:41:06 <lennart> with dml you can erase the extra types and get an sml-typable program
06:41:33 <palomer> but everything you can do with dml can be done in cayenne, right?
06:42:02 <lennart> Can be done, yes.  But not as conveniently.
06:43:00 <lennart> First, DML has more of a GADT flavor (I didn't do GADTs in Cayenne because I couldn't think of a good syntax).  Second, DML has some good constraint solvers so you don't have to prove things yourself.
06:44:00 <lennart> DML is at a rather different point in the design space, and well worth looking at.
06:44:47 <palomer> gotcha
06:46:59 <palomer> hrm, ordered SPJ's book from ILL
06:47:04 <palomer> hope it gets here within the month
06:47:09 <lennart> ILL?
06:47:14 <palomer> interlibrary loans
06:48:14 <palomer> anyone know of any articles on this (exhaustive check) offhand?
06:48:29 <palomer> or, rather, pattern expansion
06:48:39 <palomer> (nested pattern -> composition of simple patterns)
06:50:05 <lennart> well, it's in the book you've ordered.  and in my 1985 article.  and there's a long range of french articles.  Luc Maranget has written a bunch
06:51:48 <lennart> i'm not sure about exhaustiveness check articles
06:52:23 <lennart> i do believe it's exponential in the worst case, though :)
06:53:07 <palomer> even for simple patterns?
06:53:11 <palomer> how could that be?
06:53:32 <lennart> no, not for simple patterns
06:54:09 <lennart> but for simple patterns you only have to check that you have all the constructors.  or do you mean something else by 'simple pattern'?
06:54:42 <palomer> right, so it's the expansion of nested patterns into simple patterns that's exponential
06:55:08 <lennart> yes, if you insist never to examine the same value more than once
06:57:32 <palomer> oh, but I'm only doing static analysis
06:57:52 <palomer> no code generation
06:58:40 <palomer> so I don't mind if a value is examined more than once
06:58:40 <goron> palomer: there is a nice way to prove theorems. First you assume it in your code generator. Then when someone comes along and finds a bug, you know it's false. 
06:59:33 <lennart> palomer: then you can have a linear expansion, but if you do exhaustiveness checking on that, it might not be accurate
06:59:57 <palomer> yeah, that's what I'm worried about
07:00:26 <lennart> i think an accurate check will be exponential in the worst case
07:01:21 <palomer> goron: eh?
07:01:34 <goron> palomer: it was a joke. 
07:01:51 <palomer> goron: but, erm, what was it refering to?
07:02:10 <goron> palomer: it's a way of doing static analysis ;)
07:02:15 <palomer> oh, righto
07:02:26 <goron> palomer: A bit far fetched, I know.
07:03:37 <lennart> goron: I would not want too many of those thing going on in the compilers I use :)
07:04:04 <goron> lennart: You'd never know :)
07:04:52 <palomer> hmm, I still can't figure out where the exponential bit comes in
07:05:06 <palomer> is it still exponential even if you only have unary constructors?
07:05:11 <palomer> unary or nullary, that is
07:07:32 <lennart> ummmm, probably not
07:10:22 <palomer> lennart: you wouldn't happen to have an electronic version of your 1985 paper lying around, would you?
07:11:35 <lennart> no, i'm afraid not
07:12:04 <lennart> palomer: but it's described in Simon's book.  Isn't that available online?
07:13:16 <palomer> is it?
07:13:22 <palomer> lemme check
07:13:29 <SimonRC> ?!
07:13:30 <palomer> (I wouldn't have ordered it!)
07:13:47 <palomer> it is!
07:25:07 <araujo> @index splitAt
07:25:08 <lambdabot> Data.List, Prelude
07:25:16 <araujo> @hoogle splitAt
07:25:17 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
07:25:17 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
07:25:17 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString,
07:25:17 <lambdabot> PackedString)
07:25:33 <araujo> @hoogle splitAtWith
07:25:34 <lambdabot> No matches found
07:25:43 <araujo> > splitAt 1 [1 .. 9]
07:25:44 <lambdabot> ([1],[2,3,4,5,6,7,8,9])
07:25:53 <lennart> splitAtWith?
07:26:04 <ndm> break, span
07:26:08 <ndm> those are probably want you want
07:26:19 <araujo> lennart, yeah
07:26:29 <araujo> but it doesn't exist apparently :-)
07:26:37 <lennart> what ndm said...
07:31:38 <araujo> yeah
07:36:42 <Phyx-> hi guys
07:36:47 <Phyx-> i have a bit of problem here
07:36:49 <Phyx-> lemme paste
07:38:54 <Phyx-> http://rafb.net/paste/results/HL9Gyw64.html <-- to the best of my knowledge is does exaust...
07:40:25 <ndm> Phyx-: used has a case for length 0, and for length >= 2
07:40:26 <ncalexan> Phyx- what about a one element list?
07:40:27 <ndm> but not for one
07:40:51 <ndm> and remember that gets is a pattern match as well, so that might in turn be incomplete
07:41:04 <Phyx-> so i should at used (a,b,c,d) = ?
07:41:14 <Phyx-> add*
07:41:22 <ndm> [(a,b,c,d)] 
07:41:30 <Phyx-> ok, thanx, lemme try
07:41:42 <ndm> you could, although i think gets will still be a problem
07:41:54 <ndm> the code probably just needs redoing from scratch, thinking clearer about what it needs to do
07:41:54 <Phyx-> how so?
07:42:45 <ndm> Phyx-: gets is equivalent to tail, so use the defined one, but tail [] = crash
07:44:26 <Phyx-> i dunno man, i've been fighting with this
07:44:31 <Phyx-> it's taken alot of my time
07:44:46 <Phyx-> and i have another project, which thanx to this i only have 24hours to complete
07:58:19 * Phyx- opens gvim for another crack
07:58:24 <ihope> Hmm. A /whois #:-) gives me "No such nick/channel"...
08:07:59 <ihope> @me
08:08:00 <lambdabot> Maybe you meant: . id map more msg pl time wn
08:08:07 <ihope> @. oh noes
08:08:08 <lambdabot> compose module failed: Parse error: "oh"
08:08:17 <ihope> @help .
08:08:17 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>=
08:08:17 <lambdabot> f
08:08:22 <ihope> Um.
08:08:50 <ihope> @djinn a -> a >>= pl
08:08:50 <lambdabot> Cannot parse command
08:08:56 <ihope> ;-)
08:13:27 * shapr yodels
08:16:03 <Pseudonym> I didn't know you could yodel.\
08:16:12 <jethr0_> shapr: isn't it terrible cold/snowy at your place?
08:16:13 <shapr> g'day Pseudonym 
08:16:20 <Pseudonym> G'day.
08:16:26 <shapr> jethr0_: Yeah, but not so bad I can't unicycle.
08:16:38 <bosie> shapr where are you ?
08:16:41 <jethr0_> really, because there's serious snow chaos in northern germany
08:16:46 <Pseudonym> Yodelling is like bagpiping.  It should be done outside on a mountain somewhere.
08:16:55 <Pseudonym> Definitely not an indoor sport.
08:17:01 * ihope â˜ºACTION does something redundantâ˜º
08:17:18 <jethr0_> Pseudonym: you mean because bagpiping sounds so horrible? :) (no offense intendend *dumdidum*)
08:17:33 * jethr0_ does whatever ihope just did
08:17:36 <shapr> bosie: Northernmost Haskeller... 40 miles south of the arctic circle.
08:17:42 <Pseudonym> I meant what I said.
08:17:46 <Pseudonym> You take what you want from it.
08:18:00 <jethr0_> Pseudonym: and i already did
08:18:08 <Pseudonym> Cool.  We're all happy!
08:18:10 <Pseudonym> Group hug!
08:18:33 * jethr0_ 's not happy because he's still struggling with haskell program design
08:18:40 * ihope hugs or something
08:18:53 <jethr0_> but then again i've been doing other things the last hours, so it's not too amazing i haven't made any progress :/
08:18:53 <Pseudonym> Group GHCi!
08:19:08 <shapr> bwahaha
08:19:12 <Lemmih> That could actually be cool.
08:19:31 <jethr0_> Lemmih: collaborative REPL?
08:19:48 <Pseudonym> Why is it that I don't need to be a local admin to install Visual Studio, but I do to install Visual Haskell?
08:20:04 * Pseudonym curses Windows bizarreness
08:20:11 <MarcWeber> jethr0_: Yeah.. you've helped me understanding some things!! ;)
08:20:47 <Lemmih> > unwords ["hm,", "we already got lambdabot"]
08:20:48 <lambdabot> "hm, we already got lambdabot"
08:21:28 <jethr0_> MarcWeber: i have? by being absent? :)
08:23:28 <ihope> â˜ºACTION does something elseâ˜º
08:23:57 <ihope> Now were that an emote or not?
08:25:15 <jethr0_> > let f [] = []; f ('A':'C':'T':'I':'O':'N':xs) = "yodels"++f xs; f (x:xs) = x:f xs in f "jethr0 ACTION mutedly"
08:25:16 <lambdabot> "jethr0 yodels mutedly"
08:25:27 <jethr0_> i'm not very convinced by that pattern...
08:26:11 <jethr0_> hands up, who's for regular expressions in patterns? :)
08:26:34 <xerox> Hola Pseudonym
08:26:46 <Pseudonym> Saluton
08:27:11 <jethr0_> Salutamus
08:27:26 <ihope> Â¿CÃ³mo?
08:27:39 <Pseudonym> Will you people please stop trying to hack my IRC client?
08:27:51 <ihope> :-)
08:27:53 * xerox
08:27:55 <xerox> Ops.
08:27:56 <jethr0_> ¡i concur!
08:28:05 * ihope as well
08:28:18 <jethr0_> stop those hacking attempts
08:29:09 <ihope> Whoa! Everybody on the channel tried to hack my client at the same time?
08:29:13 <ihope> s/?/!/
08:29:31 <jethr0_> ihope: what client are you using?
08:29:54 <ihope> Chatzill
08:29:56 <ihope> a
08:30:20 <ihope> I did a /version #haskell :-P
08:32:05 <ihope> I'd like a tree monad. But I don't think that's easy.
08:32:22 <ihope> Binary trees of binary trees cannot be transformed into binary trees easily, can they?
08:32:32 <ncalexan> ihope: actually, that was discussed just a few days ago, and it's fairly straightforward.  See the logs.
08:32:38 <ihope> Well, or course they can! merge _ = Leaf
08:33:08 <jethr0_> what does ">>=" do on a tree monad?
08:33:13 <Pseudonym> If the trees only store data at leaves, it's easy.
08:33:36 <Pseudonym> In fact, term substitution is one of the other "canonical" monad models in Haskell.
08:34:13 <xerox> jethr0_: there are many possibilities, in fact.
08:34:58 <ihope> Pseudonym: I like my trees to store data everywhere else.
08:35:19 <Pseudonym> Well aren't you a silly thing.
08:35:41 <Pseudonym> But if you consider, for example:
08:36:14 <Pseudonym> data Expr bind = EInt Int | EAdd (Expr bind) (Expr bind) | EVar bind
08:36:32 <Pseudonym> Then join :: Expr (Expr bind) -> Expr bind has an obvious meaning.
08:36:49 <ihope> data Tree a = Branch (Tree a) a (Tree a) | Leaf
08:37:01 <ihope> data Tree a = Branch (Tree a) (Tree a) | Leaf a
08:37:09 <Pseudonym> join in that monad is simply variable substitution.
08:37:20 <jethr0_> cool
08:37:31 <Pseudonym> And even cooler:
08:37:32 <ihope> So how does join work on the first thing?
08:37:47 <Pseudonym> bindExpr :: Expr a -> (a -> Expr b) -> Expr b
08:38:07 <Pseudonym> You supply a function which turns variable names into terms, and bindExpr does the substitution.
08:38:24 <jethr0_> i like it!
08:38:53 <Phyx-> > if fustrated then kill_myself else kill_everyone
08:38:54 <lambdabot>  Not in scope: `kill_everyone'
08:39:18 <jethr0_> Phyx-: so killing everyone is not a result of frustration, no?
08:39:18 <Pseudonym> > enemy_submarine
08:39:19 <lambdabot>  Not in scope: `enemy_submarine'
08:39:30 <jethr0_> > use bat with doorknob
08:39:31 <lambdabot>  Not in scope: `doorknob'
08:39:33 <ihope> Oh, right. My definition allows for empty trees.
08:39:44 <Phyx-> jethr0_: nope
08:39:44 <ihope> jethr0_:
08:39:55 <ihope> > doorknob >>= bat -- This should work.
08:39:55 <Phyx-> jethr0_: that's how i usually feel
08:39:55 <lambdabot>  Not in scope: `bat'
08:40:09 <ihope> See? No doorknob scoping error!
08:40:11 <ihope> :-P
08:40:13 <Pseudonym> If you use the second one, ihope, then joinTree :: Tree (Tree a) -> Tree a has an obvious meaning.
08:40:36 <Pseudonym> joinTree (Branch l r) = Branch (joinTree l) (joinTree r)
08:40:43 <Pseudonym> joinTree (Leaf x) = x
08:41:06 <ihope> Mmh...
08:41:17 <jethr0_> > let a >>= b = a+b; getContent = 3; putStrLn = 5 in getContent >>= putStrLn
08:41:18 <lambdabot> 8
08:41:23 <Pseudonym> I suppose you could argue that it's the property that values are only at leaves which makes it a monad.
08:41:54 <jethr0_> from the little i know about monads, that would be hard to argue, no?
08:42:18 <Pseudonym> IIRC it gets tricky when you have key-value pairs, like in B-trees.
08:42:29 <Pseudonym> But that's a Haskell type system issue.
08:55:29 <Phyx-> is it valid to have the length of a like this?
08:55:31 <Phyx-> indexes :: Agenda -> Taak -> Int -> Agenda
08:55:31 <Phyx-> indexes [] _ _ = []
08:55:31 <Phyx-> indexes a _ length(a) = a
08:55:43 <Phyx-> (sorry for the paste, thought it only 3 lines)
08:56:12 <astrolabe> I think you can only use a once on LHS
08:56:22 <Phyx-> ?
08:56:27 <Lemmih> Phyx-: No.
08:56:41 <arjanb> but you can do  indexes a _ n | length a == n = a
08:57:03 <Phyx-> thought about that
08:57:06 <Phyx-> just now
08:57:08 <Phyx-> thanx
09:05:43 <jethr0_> @type all
09:05:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:05:53 <xerox> @type none
09:05:54 <lambdabot> Not in scope: `none'
09:06:38 <jethr0_> not . all?
09:06:44 <jethr0_> not . any, rather
09:06:44 <xerox> not at all!
09:06:51 <jethr0_> stupid boolean logic
09:07:25 <ihope_> > none
09:07:26 <lambdabot>  Not in scope: `none'
09:07:35 <ihope_> none = not . any
09:07:51 <xerox> > let none = (not .) . any in none (>2) $ take 10 $ cycle [0,1]
09:07:52 <lambdabot> True
09:08:02 <xerox> `any' has got two arguments.
09:08:07 <jethr0_> > let xs = [1,2,3,4] in all (==1) $ zipWith subtract xs (drop 1 xs)
09:08:08 <lambdabot> True
09:08:11 <ihope_> @type (not .) . any
09:08:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:08:12 <jethr0_> > let xs = [1,2,3,5] in all (==1) $ zipWith subtract xs (drop 1 xs)
09:08:14 <lambdabot> False
09:08:32 <ihope_> @index (.>)
09:08:32 <lambdabot> bzzt
09:08:34 <ihope_> @index (.>>)
09:08:35 <lambdabot> bzzt
09:08:41 <ihope_> @index (<.>)
09:08:41 <lambdabot> bzzt
09:08:44 <ihope_> Etc. etc.
09:08:49 <int-e> drop 1 = tail
09:08:49 <xerox> (>.>) perchance?
09:08:57 <xerox> (>.>) = flip (.)
09:09:30 <int-e> @index (>>-)
09:09:31 <lambdabot> bzzt
09:09:37 <ihope_> ..-
09:09:42 <ihope_> Erm.
09:09:43 <ihope_> ..+
09:09:53 <jethr0_> int-e: tail is strict, drop 1 is not!
09:09:54 * xerox hits ihope_ with an arrow
09:10:10 <jethr0_> maybe strict is the wrong term, but "drop 1" handles empty lists better
09:10:24 <xerox> > drop 1 [] :: [()]
09:10:25 <lambdabot> []
09:10:33 <ihope_> lazyCons ~(x:xs) = x:xs
09:10:38 <xerox> FSVO of better.
09:10:41 <int-e> strict is the wrong word. but I know what you mean
09:10:51 <int-e> (as you said)
09:10:53 <ihope_> > (
09:10:53 <lambdabot>  parse error on input `}'
09:11:09 <ihope_> > (\~Nothing -> True) (Just 3)
09:11:10 <lambdabot>  parse error on input `->'
09:11:18 <ihope_> > (\(~Nothing) -> True) (Just 3)
09:11:19 <jethr0_> most often i don't want an error, but especially with zipWith, the non-action of drop can often be helpful
09:11:19 <lambdabot> True
09:11:51 <int-e> hmm.
09:12:06 <int-e> > zipWith (+) [] (tail []) :: [Int]
09:12:07 <lambdabot> []
09:12:12 <xerox> lambdabot should know how to protect herself from abuses, we ought to give her chili-powered-spray, or some counting+insulting code.
09:12:25 <ihope_> Um...
09:12:26 <int-e> > zipWith (+) (tail []) [] :: [Int]
09:12:28 <lambdabot> Exception: Prelude.tail: empty list
09:12:29 <int-e> :)
09:12:34 <ihope_> What sort of abuse?
09:13:09 <ihope_> > let lazy x = head x : tail x in zipWith (lazy (tail [])) []
09:13:10 <lambdabot> Couldn't match `[a]' against `t -> t1'
09:13:22 <ihope_> Um.
09:13:27 <ihope_> > let lazy x = head x : tail x in zipWith (+) (lazy (tail [])) []
09:13:29 <lambdabot> []
09:13:31 <ihope_> Ding!
09:14:13 <int-e> are pattern matches in patterns like zipWith z (a:as) (b:bs)  defined to be processed from left to right?
09:14:41 <ihope_> Um...
09:14:57 <Pseudonym> Yes.
09:15:12 <ihope_> @type \(zipWith z (a:as) (b:bs)) -> 3
09:15:12 <lambdabot> Parse error in pattern
09:15:46 <Pseudonym> Left-to-right, top-to-bottom.
09:15:54 <Pseudonym> Well, top-to-bottom, left-to-right.
09:16:01 <Pseudonym> So, for example:
09:16:04 <int-e> well, it's a toplevel declaration with 3 pattern bindings.
09:16:07 <Pseudonym> f _ [] = foo
09:16:12 <Pseudonym> f (x:xs) (y:ys) = bar
09:16:33 <Pseudonym> In that case, in the second rule, the second pattern will actually be computed first.
09:16:45 <Pseudonym> Because top-to-bottom overrules left-to-right.
09:16:55 <int-e> sure.
09:26:10 <int-e> Pseudonym: actually, no. In the second line, the first pattern match will be done first again. But before we get there, the second argument was already forced by the [] pattern in the first line.
09:28:17 <int-e> I checked the Haskell Report.
09:29:39 <Pseudonym> Yes, what I describe is an optimisation./
09:29:52 <int-e> right
09:30:19 <int-e> anyway. This means that I can rely on zipWith fun l (tail l)  to work for empty lists :)
09:30:24 <Pseudonym> Yeah.
09:30:25 <Pseudonym> :-)
09:31:56 <jethr0_> good to know. but i still dislike tail for its partiality
09:33:55 <dcoutts> if I were here promoting epigram then I'd say that partiality should be modeled with a monad just like other unpleasent things like IO exceptions etc.
09:34:19 <jethr0_> sad thing you aren't
09:34:22 <int-e> uhm
09:34:32 <ndm> if i were promoting catch, i'd say happily  use tail, and then afterwards proove that its safe
09:34:39 <int-e> that rules out general recursion, right?
09:34:59 <dcoutts> int-e, well you can do general recursion in the partiality monad :-)
09:35:19 <ndm> unsafePerformComputation ?
09:35:36 <dcoutts> but it seperates your nasty "might not terminate" parts of your program from the nice total parts
09:35:42 <jethr0_> if i were here to promote java, i'd say checked exceptions solve everything. good thing i'm not...
09:35:47 <dcoutts> just like we do with IO in Haskell
09:35:55 <int-e> it's hard enough to escape those pesky monads as is ...
09:36:12 <ihope> I tried to separate total functions from the non-total stuff.
09:36:16 <jethr0_> int-e: don't let roconner hear you :)
09:36:27 <ihope> I tried a monad, and it didn't work. I tried an arrow, and it didn't work.
09:36:27 <Pseudonym> If I were here to promote C, I'd say "I'm a silly person who still things it's the 1970s".
09:36:36 <Pseudonym> thinks
09:36:47 <int-e> C is very useful.
09:37:00 <Pseudonym> C is occasionally useful.
09:37:03 <ndm> all Haskell depends on C
09:37:10 <int-e> very useful to write the few performance critical inner loops
09:37:19 <jethr0_> C is hopefully becoming less and less useful
09:37:21 <ihope> All Haskell depended on C for a while.
09:37:27 <ncalexan> ndm: that's very flawed.  It's possible to 'do haskell' with no C.
09:37:27 <Pseudonym> I'd rather write my performance critical inner loops in C++, personally.
09:37:39 <ndm> apart from Yhc, actually, which you can still work without C
09:37:44 <Pseudonym> C is, unfortunately, a necessary evil when working on very small embedded platforms.
09:37:50 <jethr0_> Pseudonym: *bah*, now you've become unpure. go cleanse yourself :)
09:37:55 <ndm> Pseudonym: C++ is horrible, i'd much rather use C
09:38:06 <ndm> or rather C with "class" instead of "struct"
09:38:13 <ihope> So my failed "capturing nontermination in an arrow" is why I'm looking for a more general version of arrows.
09:38:26 <Pseudonym> C++ gives you C plus more.  Why would you prefer C to C++?
09:38:56 <Pseudonym> Even if you only use C++ as a better C, it's still better than C by definition.
09:39:14 <astrolabe> It's bigger, that's not the same as better.
09:39:16 <dcoutts> Pseudonym, you can link C code to anything. You can link C++ code to C++ code.
09:39:23 <jethr0_> Pseudonym: C++ has evil semantics. things are done behind your back and writing exception-safe code is nearly impossible
09:39:24 <Pseudonym> extern "C"
09:39:39 <ihope> But that won't happen until I get "kind List a = Nil | Cons a *"
09:39:45 <Pseudonym> Writing exception-safe code in C++ isn't difficult most of the time.
09:39:47 <dcoutts> Pseudonym, no, I'm not talking about linking C into C++, I mean linking C++ into other languages
09:39:51 <Pseudonym> It's by definition impossible in C.
09:40:06 <jethr0_> huh???
09:40:17 <int-e> why, it's per definition possible in C
09:40:17 <Pseudonym> How can you write exception-safe code in C?
09:40:21 <int-e> C has no exceptions ;)
09:40:32 <ndm> Pseudonym: C++ is ugly and badly designed, its just nasty hack after hack
09:40:50 <jethr0_> Pseudonym: have you read "exceptional c++". i've never been so aware to c++'s shortcomings as after reading that book!
09:40:59 <Pseudonym> Yes, I have.
09:41:01 <jethr0_> _really_ exception-safe code is _very_ hard in c++
09:41:03 <int-e> that being said, I don't particularily dislike C++ and actually use it occasionally.
09:41:17 <xerox> Chess is C++, Go is Haskell.
09:41:18 <Pseudonym> BTW, for the record, I used to say all of these bad things about C++.
09:41:19 <ihope> int-e: Haskell has no monads
09:41:22 <Pseudonym> So I udnerstand the arguments.
09:41:33 <Pseudonym> This was all before I wrote something non-trivial in C++.
09:41:33 <int-e> ihope: there's the IO monad
09:41:38 <ndm> i use C++, but its important to not use the majority of it - but treat it like C with some extra things
09:41:46 <Pseudonym> Then I saw the light.
09:41:51 <astrolabe> ihope: a novel point of view.
09:41:52 <Pseudonym> It's unfortunate that the light is highly polarised.
09:41:58 <dcoutts> jethr0_, yes, I think they found that writing a proper collection type that could cope with elements that could throw an exception at any point was actually impossible.
09:41:59 <ndm> Pseudonym: i helped write the british airways departure control system, over 10 million lines of code
09:42:00 <Pseudonym> But it's light nonetheless.
09:42:07 <ndm> having done all that, i realise how much i hate C++
09:42:09 <jethr0_> Pseudonym: i'm not at all conviced, but maybe i'll be illuminated some day too
09:42:22 <Pseudonym> BTW, the one thing you DON'T want to do in C++ is maintain legacy code.
09:42:29 <ihope> int-e: IO is an instance of the Monad class, but there is no Monad class.
09:42:31 <Pseudonym> You really want to write new code.
09:42:45 <ndm> actually i'd say in any non-pure language you don't wnat to maintain code
09:42:46 <Pseudonym> Pre-ISO C++ code is a special kind of pain.
09:43:00 <jethr0_> i'd say, you really want to write new code all the time :)
09:43:04 <Pseudonym> Well, yes.  I say all this, but I'd really, really prefer to be programming in haskell.
09:43:07 <int-e> ihope: you're confusing me.
09:44:10 <astrolabe> ihope has gone all zen
09:44:26 <astrolabe> He'll be hitting us with sticks next.
09:44:42 * ihope hits us with sticks next
09:44:58 <astrolabe> see!
09:45:43 <ihope> Let's eliminate some letters from the Englis alpabet.
09:45:47 <int-e> is there a way to import foreign functions directly as ST monad operations?
09:46:03 <jonkri> say that i create a as "data Twonumbers = Twonumbers { a::Int, b::Int }. is it possible for me to define "data pair = Twonumbers | Threenumbers" by typing something like that?
09:46:23 <ihope> data Pair = Something Twonumber | SomethingElse Threenumbers
09:46:34 <ihope> Alternatively, you can define a class:
09:46:35 <jethr0_> hope: tat would be an exerce in futlty
09:46:39 <int-e> (if all I do is modify an array, I don't see why the code has to reside in IO, but it's definitely impure)
09:47:04 <jonkri> ihope, there is a type "Somthing" to do this?
09:47:25 <ihope> The Something and SomethingElse are data constructors.
09:47:45 <ihope> class Whatever a where firstTwo :: a -> (Int, Int); lastOne :: a -> Maybe Int
09:47:47 <jonkri> in order to call a Maybe type i need "Just <>" or "Nothing". is there something similar i should know about Something?
09:48:21 <ihope> Something is a data constructor, not a type constructor.
09:48:30 <ihope> Something :: Twonumbers -> Pair
09:48:30 <jonkri> ok
09:48:35 <astrolabe> 'Something' isn't built in to the language.
09:48:42 <jonkri> ok
09:48:43 <ihope> SomethingElse :: Threenumbers -> Pair
09:49:38 <jonkri> ihope, "Something :: Twonumbers -> Pair" looks like a function type signature, wont i need to define that function somewhere?
09:49:59 <ihope> It's defined in the data declaration.
09:50:10 <jonkri> ok
09:50:21 <ihope> data Pair = Something Twonumber | SomethingElse Threenumbers -- This defines the functions Something and SomethingElse, as well as the type Pair
09:51:44 <jonkri> ok
09:52:04 <jonkri> say that i have a function that should return a Pair, containing two numbers. what do i type then?
09:52:21 <jonkri> and no, this is not homework :)
09:53:13 <jethr0_> (Int,Int)
09:53:13 <jethr0_> ?
09:53:26 <ihope> jonkri: foobar x y = Something (Twonumbers x y)
09:53:28 <jonkri> jethr0_, look above
09:53:34 <jonkri> ihope, perfect!
09:53:37 <jonkri> thanks all
09:53:43 <ihope> You're welcome
09:53:52 <jonkri> now i finally begin to understand this
09:54:16 <Lemmih> dons: ping.
09:54:33 <astrolabe> a bad sign
09:58:10 <jonkri> i have a otherwise guard that i don't want to return anything in, is there a way to return nothing (without returning Nothing)
09:59:14 <Cale> jonkri: you can use undefined or error, but if that case ever happens, it will crash the program
09:59:20 <sethk> jonkri, haven't seen your code, but you can usually do    ()
09:59:24 <Cale> (with a suitable error message)
09:59:31 <jonkri> oh, ok
09:59:31 <sethk> jonkri, or return () in a monadic situation
09:59:49 <Cale> () will make your function have return type ()
10:00:01 <jonkri> thanks
10:00:07 <Cale> (or  m ()  in the case of a monad m)
10:00:13 <sethk> Cale, if he really wants to return nothing, then that's the type it should have, right?
10:00:22 <jonkri> the type is defined as something else so i will have to filter it out
10:00:26 <Cale> sethk: he said in the otherwise case
10:00:32 <jonkri> i wont have to, but i think that's the way i will do it :)
10:00:50 <Cale> The best thing to do imo is to deal with the error properly
10:00:54 <sethk> Cale, yes, but that might not matter.  I do that sometimes, and the other (other than otherwise) code is, say, recursive
10:01:06 <Cale> i.e. use a type which is suitable for handling that error case
10:01:12 <sethk> Cale, of course if the proper type is not () you are correct
10:01:31 <Cale> sethk: in the pure case, that won't be too interesting :)
10:01:39 <Cale> In the monadic case it might be though :)
10:01:45 <sethk> true.  Probably an exception is a better solution
10:02:00 <Cale> I like the use of Maybe or Either String
10:03:42 <sethk> Cale, I'm hacking on a device driver so my brain is scrambled anyway
10:05:24 <jethr0_> cale, i'm trying the hidden state thingey, but am having with IO...
10:05:27 <jethr0_> "newtype Scrabble b = Scrabble (StateT ScrabbleState IO b) deriving (Functor,Monad)"
10:05:44 <ihope> > pi
10:05:45 <lambdabot> 3.141592653589793
10:05:55 <jethr0_> Cale: can i do io with that? and if so, how?
10:06:13 <ihope> Where's the ScrabbleState thingy defined?
10:06:39 <jethr0_> ihope: it's just a big record. i could paste it, but the whole thing is rather hideous...
10:07:17 <jethr0_> i've tried liftIO, but that obviously won't work :/
10:07:18 <Cale> jethr0_: yes, by liftIO'ing
10:07:29 <jethr0_> it says "No instance for (MonadIO Scrabble)"
10:07:30 <Cale> oh, right, derive MonadIO
10:07:35 <jethr0_> k
10:09:37 <jethr0_> "instance (Monad m) => MonadIO m where liftIO s = Scrabble s"??
10:09:57 <ihope> deriving (Functor,Monad,MonadIO)
10:09:58 <ihope> I think.
10:10:03 <jethr0_> ah, i'll try that
10:12:18 <jethr0_> yeah, it compiled without errors. why-o-why am i always too lazy for TDD *grumble*
10:13:54 <jonkri> how (and where) is the sin() function defined in haskell?
10:14:05 <jethr0_> @index sin
10:14:06 <lambdabot> Prelude
10:14:15 <jonkri> forgive me for that!...
10:14:26 <jethr0_> *ha*, shortest answer ever :)
10:14:32 <jonkri> you bet :)
10:15:55 <Phyx-> Goddddd daaaammmmniiitttttt.. after 28 hours, finally got it working. *does the haskell happu dance*
10:16:01 <jonkri> does sin use radians or degrees and how can i change it?
10:16:10 <jethr0_> > sin pi
10:16:11 <lambdabot> 1.2246063538223773e-16
10:16:15 <jonkri> Phyx-, concatulations
10:16:19 <jethr0_> > sin (2*pi)
10:16:20 <lambdabot> -2.4492127076447545e-16
10:16:26 <jonkri> > sin 90
10:16:27 <lambdabot> 0.8939966636005579
10:16:42 <jonkri> what?
10:16:50 <Phyx-> jonkri: ty
10:16:55 <jethr0_> it uses radians and the above were rounding errors
10:17:14 <jonkri> no, that was not rounding errors. those where ROUNDING ERRORS
10:18:06 <jethr0_> > pi
10:18:07 <lambdabot> 3.141592653589793
10:18:08 <jonkri> what's up with that? and, how can i change to degrees?
10:18:45 <jethr0_> > let rad2deg x = (x/pi*180) in rad2deg pi
10:18:46 <lambdabot> 180.0
10:18:53 <astrolabe> jonkri: the numbers are represented in floating point form, which is a kind of approximation.
10:19:19 <jonkri> you got to be kidding me
10:19:27 <jonkri> astrolabe, why does jethr0_ get 180.0 then?
10:19:31 <jonkri> he should get 186.8
10:19:42 <jonkri> jethr0_, thanks
10:19:58 <astrolabe> Eh?  Why?  what is 86.8?
10:20:01 <jethr0_> jonkri: why are you so upset about 16th digit rounding errors?
10:20:18 <jonkri> > sin pi
10:20:19 <lambdabot> 1.2246063538223773e-16
10:20:23 <jonkri> ooooh
10:20:25 <jonkri> silly me
10:20:27 <jonkri> astrolabe, sorry
10:20:40 <jonkri> i though sin pi would equal 1 for some reason, and didn't notice e^-16
10:20:43 <jethr0_> it's still not exactly beautiful, though
10:20:57 <astrolabe> > cos pi
10:20:58 <jonkri> i though 1 became 1.224
10:20:58 <lambdabot> -1.0
10:21:01 <jonkri> yeah, thanks
10:21:06 <int-e> > sin pi * 2^64
10:21:08 <lambdabot> 2259.0
10:21:12 <astrolabe> Ah
10:21:29 <jonkri> jethr0_, thanks again ;-)
10:21:30 <jethr0_> isn't there an "fmod" or so around? i really wanted to do "90 `fmod` pi"
10:21:32 <jethr0_> np
10:21:56 <int-e> @index fmod
10:21:57 <lambdabot> bzzt
10:23:00 <jethr0_> > let fmod a b = b - (floor(a/b)) in fmod 90 pi
10:23:01 <lambdabot> Add a type signature
10:23:03 <astrolabe> @type rem
10:23:04 <lambdabot> forall a. (Integral a) => a -> a -> a
10:23:11 <astrolabe> hmmm
10:23:12 <jethr0_> > let fmod a b = b - (floor(a/b)) in fmod 90.0 pi
10:23:13 <lambdabot> Add a type signature
10:23:22 <jethr0_> > floor -1.1
10:23:22 <lambdabot>  add an instance declaration for (Fractional (a -> b))
10:23:53 <Cale> > let fmod a b = b - fromIntegral (floor(a/b)) in fmod 90.0 pi
10:23:54 <lambdabot> -24.858407346410207
10:23:56 <jethr0_> > floor (-1.1)
10:23:57 <ihope> > tan pi
10:23:57 <lambdabot> -2
10:23:58 <lambdabot> -1.2246063538223773e-16
10:24:09 <Cale> @type floor
10:24:10 <jethr0_> yes, but floor doesn't do what i need for negatives, i think
10:24:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:24:20 <ihope> > (>>>) ((>>>>>)) (((>>>>>>>)))
10:24:21 <lambdabot>  Not in scope: `>>>>>>>'
10:24:30 <ihope> :-P
10:25:04 <jethr0_> never mind
10:25:28 <Pseudonym> > iterate (\x -> x + sin x) 1 !! 10
10:25:29 <lambdabot> 3.141592653589793
10:26:21 <jethr0_> @pl \x -> x + sin x
10:26:22 <ihope> > pi
10:26:22 <lambdabot> ap (+) sin
10:26:23 <lambdabot> 3.141592653589793
10:26:48 <ihope> > iterate (\x -> x + sin x) 1
10:26:49 <lambdabot> [1.0,1.8414709848078965,2.80506170934973,3.135276332899716,3.14159261159065
10:26:49 <lambdabot> 3,3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,
10:26:49 <lambdabot> 3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:26:49 <lambdabot> 141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:26:49 <lambdabot> 141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:26:51 <lambdabot> [24 @more lines]
10:27:06 <ihope> Nice.
10:27:24 <ihope> > iterate (\x -> x + sin x) (pi + 1)
10:27:25 <lambdabot> [4.141592653589793,3.300121668781897,3.14225583034577,3.1415926536384045,
10:27:25 <lambdabot> 3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:27:25 <lambdabot> 141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:27:25 <lambdabot> 141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:27:25 <lambdabot> 141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.
10:27:28 <lambdabot> [24 @more lines]
10:27:41 <int-e> well, that has cubic convergence.
10:27:49 <Pseudonym> It's pretty fast, yes.
10:28:06 <Pseudonym> Unfortunately, it requires having a fast accurate sin available.
10:28:45 <ihope> > iterate (\x -> x + sin x) 30
10:28:46 <lambdabot> [30.0,29.011968375907138,28.33942920128125,28.274379845059023,28.2743338823
10:28:46 <lambdabot> 08156,28.274333882308138,28.274333882308138,28.274333882308138,28.
10:28:46 <lambdabot> 274333882308138,28.274333882308138,28.274333882308138,28.274333882308138,
10:28:46 <lambdabot> 28.274333882308138,28.274333882308138,28.274333882308138,28.274333882308138
10:28:46 <lambdabot> ,28.274333882308138,28.274333882308138,28.274333882308138,28.27433388230813
10:28:48 <lambdabot> [23 @more lines]
10:28:57 <ihope> What foreign pi is this?
10:29:06 <Cale> > 28.27433388230813 / pi
10:29:07 <lambdabot> 8.999999999999998
10:29:14 <Cale> It's 9 * pi
10:29:24 <ihope> Ah.
10:29:29 <ihope> > 3-/pi
10:29:30 <lambdabot>  Not in scope: `-/'
10:29:32 <ihope> > 3/pi
10:29:33 <lambdabot> 0.954929658551372
10:29:45 <ihope> > (:-/)
10:29:46 <lambdabot>  Not in scope: data constructor `:-/'
10:29:53 <ihope> Yay, it's a data constructor!
10:29:57 <ihope> > (:-|)
10:29:58 <lambdabot>  Not in scope: data constructor `:-|'
10:30:02 <ihope> > (:-P)
10:30:03 <lambdabot>  Not in scope: data constructor `P'
10:30:09 <ihope> Aww.
10:30:28 <ihope> > (:-\)
10:30:29 <lambdabot>  Not in scope: data constructor `:-\'
10:30:45 <hyperion^> o_O
10:30:59 <ihope> > o_O
10:30:59 <lambdabot>  Not in scope: `o_O'
10:31:30 <ihope> > >_<
10:31:31 <lambdabot>  parse error on input `>'
10:31:36 <ihope> > (
10:31:36 <lambdabot>  parse error on input `}'
10:31:39 <ihope> > (>_<)
10:31:40 <lambdabot>  parse error on input `)'
10:32:04 <hyperion^> i shouldn't have say any thign
10:32:11 <hyperion^> x(
10:32:26 <ihope> > x(o_O:-)
10:32:27 <lambdabot>  Not in scope: data constructor `:-'
10:32:59 <hyperion^> > repeat 5 slap ihope
10:33:00 <lambdabot>  Not in scope: `ihope'
10:33:34 * int-e hands lambdabot a pair of binoculars.
10:34:14 <ihope> > binoculars >>= lambdabot
10:34:14 <lambdabot>  Not in scope: `lambdabot'
10:34:17 <jethr0_> spam,spam,spam
10:34:25 <ihope> Hmm.
10:34:31 <hyperion^>  Not in scope: `spam'
10:34:32 <ihope> Lambdabot isn't very self-aware.
10:34:46 <ihope> @quote-add lambdabot Not in scope: `lambdabot'
10:34:54 <ihope> @quote lambdabot
10:34:54 <lambdabot> babel module failed: getRandItem: empty list
10:34:59 <ihope> Ooph.
10:35:52 <jethr0_> @pl \xs -> all (==head xs) xs
10:35:53 <lambdabot> all =<< (==) . head
10:36:15 <ihope> @pretty 8-(o_O:-)
10:36:16 <lambdabot> "Parse error" at column 10
10:36:28 <ihope> @pretty Pretty pretty pretty
10:36:28 <lambdabot> "Parse error" at column 21
10:36:41 <jethr0_> pretty only takes expressions
10:36:48 <jethr0_> and definitions
10:37:01 <ihope> But 8-(o_O:-) is an expression.
10:37:10 <ihope> > 8-(o_O:-)
10:37:11 <lambdabot>  Not in scope: data constructor `:-'
10:37:48 <jethr0_> @pretty case i'll have of to -> fix pretty | some -> day soon
10:37:49 <lambdabot> "Parse error" at column 43
10:41:58 <ihope> @pretty thats for sure
10:41:59 <lambdabot> "Parse error" at column 15
10:42:31 <hyperion^> @pretty
10:43:03 <dons> @quit silly randoms bug
10:43:08 <jethr0_> @pretty do r <- randomRIO (0,10); return (r * 10)
10:43:35 <jethr0_> dons: is lambdabot depleting /dev/random?
10:48:01 <dons> I don't think so. but this bug only appeared with 6.4
10:48:47 <jonkri> > round 5.3
10:48:58 <jonkri> > floor 5.4
10:48:58 <jethr0_> jonkri: lambdabot just left :)
10:49:00 <dons> not back yet...
10:49:05 <dons> fixing some stuff
10:49:06 <jonkri> ah, but round 5.3 is 5 right?
10:49:18 <dons> try it in ghci
10:49:21 <dons> or hugs
10:49:23 <jethr0_> ghci says so
10:49:24 <jonkri> yeah, sorry
10:49:26 <jonkri> you're so right :)
10:49:36 * jonkri is a lazy assed bastard :)
10:54:37 <dons> @bot
10:54:38 <lambdabot> :)
10:55:10 <dfhaii> > 'nn' !! 1
10:55:11 <lambdabot>  lexical error in string/character literal
10:55:25 <dons> > "nn" !! 1
10:55:26 <lambdabot> 'n'
10:55:53 <dfhaii> t'is a confusing language
10:56:14 <dons> > ['n','n'] !! 1 -- same thing
10:56:15 <lambdabot> 'n'
10:56:41 <dfhaii> > :t 'n'
10:56:42 <lambdabot>  parse error on input `:'
10:56:45 <Philippa_> String = [Char]
10:56:50 <dons> there's a difference between Chars (using '') and strings which have "". Just like a lot of languages.
10:56:58 <dons> @type 'n'
10:56:59 <lambdabot> Char
10:57:02 <dons> @type "n"
10:57:03 <lambdabot> [Char]
10:57:13 <dons> @type "nndkd9392--n"
10:57:14 <lambdabot> lexical error in string/character literal
10:57:23 <dons> @type "nndkd"
10:57:24 <lambdabot> [Char]
10:58:02 <dfhaii> @type "9"
10:58:06 <lambdabot> [Char]
11:05:08 <Lemmih> dons: Are build reports still mailed to ghc-cvs@haskell.org?
11:06:53 <Phyx-> yay, done double checking, everything works
11:06:58 <ihope> 4ft3r 4 wh1l3, 4ll 0ur sp4m w1ll b3 un1nt3ll1g1bl3.
11:07:08 <Phyx-> hope teachers gives me an A or i'll...
11:07:31 <Phyx-> still need to add comments though
11:07:59 <jethr0_> @elite after a while, all our spam will be unintelligible
11:08:01 <Lemmih> Jim Apple is in #haskell, right?
11:08:24 <dons> Lemmih, yep. to cvs-ghc@ actually http://www.haskell.org//pipermail/cvs-ghc/
11:08:30 <jethr0_> there should really be an @unelite command :)
11:08:40 <lambdabot> Af+3R A WhI|e, A|| oUR 5PA/\/\ \/\/iLl be UNiNtE11I9Ibl3
11:09:06 <ihope> @. elite . elite . elite . elite . elite elite Is @elite idempotent at all?
11:09:06 <lambdabot> i$0RZ @31i73 id3/\/\p0+EN7 4+ 4|1?
11:09:22 <ihope> i$0RZZ?
11:13:32 <ihope> @elite i$0RZ @31i73 id3/\/\p0+EN7 4+ 4|1?
11:13:32 <lambdabot> I$0Rs @31i73 iD3/\/\P0+3N7 4+ 4|1?
11:13:44 <ihope> w4t3vr
11:14:10 <Phyx-> nice, sometimes the simple's functions work :D
11:14:14 * Phyx- hugs \\
11:15:52 <Lemmih> dons: Oh, right. Thanks.
11:18:21 <ihope> L's b sm mr lers frm glsh!
11:19:05 <ihope> Tell me: would English be more comprehensible without ETAOIN or with only ETAOIN?
11:19:18 <ihope> @type elem
11:19:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:20:36 <Pseudonym> T wld b frly cmprhnsbl wth nly cnsnnts.
11:21:25 <ihope> > filter (`elem` "ETAOINetaoin:? ") "Tell me: would English be more comprehensible without ETAOIN or with only ETAOIN?"
11:21:26 <lambdabot> "Te e: o Eni e oe oeenie itot ETAOIN o it on ETAOIN?"
11:21:45 <jethr0_> neither
11:21:48 <ihope> > filter (not . (`elem` "ETAOINetaoin")) "Tell me: would English be more comprehensible without ETAOIN or with only ETAOIN?"
11:21:49 <lambdabot> "ll m: wuld glsh b mr cmprhsbl whu  r wh ly ?"
11:22:05 <ihope> Definitely with only ETAOIN.
11:22:31 <ihope> Well...
11:22:34 <Pseudonym> Only if your sentence contains the pseudo-word "ETAOIN".
11:22:48 <dons> we should definitely gzip each word, and then use the resulting dictionary
11:23:03 <jethr0_>  > filter (`elem` "ETAOINetaoin:? ") "nation"
11:23:03 <Pseudonym> cat - > novel.txt.gz
11:23:04 <ihope> "Ll m: wuld glsh b mr cmprhsbl whu ETAOIN r wh ly ETAOIN?"
11:23:14 <jethr0_> > filter (`elem` "ETAOINetaoin:? ") "nation"
11:23:15 <lambdabot> "nation"
11:23:17 <ihope> dons: hmm?
11:23:37 <Pseudonym> > filter (not . (`elem` "ETAOINetaoin")) "Strange notation"
11:23:38 <lambdabot> "Srg "
11:23:57 <ihope> > filter (`elem` "ETAOINetaoin") "This this way can get pretty darn UNINTELLIGIBLE."
11:23:58 <lambdabot> "TitiaanetettanNINTEIIE"
11:24:21 <jethr0_> > filter (`elem` "ETAOINetaoin:? ") "a man, a plan, panama"
11:24:22 <lambdabot> "a an a an anaa"
11:24:29 <ihope> A canal!
11:24:42 <jethr0_> i though there was something odd about it *grin*
11:25:08 <Phyx-> night all, thanx a million, you guys are helpfull :D
11:25:11 <jethr0_> changes the result only very slightly, though
11:25:47 <ihope> Just a secon...
11:26:30 <ihope> > filter (`elem` "ETAOINetaoin") "Tango hotel india sierra space mike india golf tango space bravo echo space bravo echo tango tango echo romeo"
11:26:31 <lambdabot> "Tanooteiniaieaaeieiniaotanoaeaoeoaeaoeotanotanoeooeo"
11:26:47 <ihope> Um...
11:28:50 <Phyx-> lolz
11:29:00 <ihope> > filter (`elem` "ETAOINetaoin ") "Tango hotel india sierra space mike india golf tango space bravo echo space bravo echo tango tango echo romeo"
11:29:01 <lambdabot> "Tano ote inia iea ae ie inia o tano ae ao eo ae ao eo tano tano eo oeo"
11:40:35 <jethr0_> > let abc = ["alpha", "bravo", "charly", "delta", "echo", "foxtrott", "golf", "hotel", "india", "juliet", "kilo", "lima", "mike", "november", "oscar", "pappa", "quebeck", "romeo", "sierra", "tango", "uniform", "viktor", "whisky", "x-ray", "yankee", "zulu"] in unwords $ map ((abc!!) . (subtract (ord 'a')) . ord) "helloworld"
11:40:37 <lambdabot> "hotel echo lima lima oscar whisky oscar romeo lima delta"
11:40:51 <jethr0_> spam,spam,spam
11:42:29 <ihope> > filter (`elem` "ETAOINetaoin '19-,.") "It's a Class A misdemeanor for a rooster or hen to make a loud noise within 119 feet of a private residence without the express written consent of Major League Baseball in Guerra-Vernon County, California."
11:42:30 <lambdabot> "It' a a A ieeano o a oote o en to ae a o noie itin 119 eet o a iate
11:42:30 <lambdabot> eiene itot te ee itten onent o ao eae aea in ea-enon ont, aionia."
11:42:55 <ihope> > filter (not . (`elem` "ETAOINetaoin")) "It's a Class A misdemeanor for a rooster or hen to make a loud noise within 119 feet of a private residence without the express written consent of Major League Baseball in Guerra-Vernon County, California."
11:42:55 <lambdabot> "'s  Clss  msdmr fr  rsr r h  mk  lud s wh 119 f f  prv rsdc whu h xprss
11:42:55 <lambdabot> wr cs f Mjr Lgu Bsbll  Gurr-Vr Cuy, Clfr."
11:43:11 <jonkri> ihope, what are you doing? :-)
11:43:44 <jethr0_> lossy text compression :)
11:43:52 <jonkri> hehehe
11:43:52 <ihope> :-)
11:44:15 <ihope> I'm trying to figure out whether English without E, T, A, O, I, or N or English with only E, T, A, O, I and N is more comprehensible.
11:44:47 <ihope> > filter (`elem` "ETAOINSHRDLUetaoinshrdlu '19-,.") "It's a Class A misdemeanor for a rooster or hen to make a loud noise within 119 feet of a private residence without the express written consent of Major League Baseball in Guerra-Vernon County, California."
11:44:48 <lambdabot> "It's a lass A isdeeanor or a rooster or hen to ae a loud noise ithin 119
11:44:48 <lambdabot> eet o a riate residene ithout the eress ritten onsent o aor Leaue aseall
11:44:48 <lambdabot> in uerra-ernon ount, aliornia."
11:45:00 <ihope> :-)
11:45:19 <ihope> > filter (not . (`elem` "ETAOINSHRDLUetaoinshrdlu")) "It's a Class A misdemeanor for a rooster or hen to make a loud noise within 119 feet of a private residence without the express written consent of Major League Baseball in Guerra-Vernon County, California."
11:45:20 <lambdabot> "'  C  mm f      mk    w 119 f f  pv c w  xp w c f Mj g Bb  G-V Cy, Cf."
11:45:25 <jethr0_> i still say "neither". why would you care? to evade cryptanalysis?
11:45:26 <ihope> Heh.
11:45:45 <ihope> Just wondering.
11:46:18 <ihope> If I want to evade cryptanalysis, I can use a good cryptothing ;-)
11:48:44 <jethr0_> sure, but by not using etoin you'd make letter frequency based attack a lot harder
11:49:52 <ihope> What if I don't use one of those... things?
11:57:13 <dons> @quit a fix perhaps
11:57:40 <jonkri> data a b = a { x, y :: b } defines a data type a with two "variables" of type b?
11:58:32 <lennart> well, data A b = A { x, y :: b} does
11:58:55 <jonkri> yeah, of course
11:59:11 <lennart> field is a better word than variable
11:59:18 <jonkri> ok, thanks :)
12:01:51 <jonkri> so, say that i define A like above
12:01:56 <jonkri> test :: Int -> A
12:02:02 <jonkri> test a = (A a a)
12:02:15 <jonkri> Kind error: `A' is not applied to enough type arguments
12:02:25 <jonkri> what's the problem there?
12:04:35 <cpatrick> you want `test :: Int -> A Int`
12:05:09 <cpatrick> I'm also not sure if you have to do `A { x = a, y = a }`
12:05:31 <jonkri> i didn't have to do that. thanks
12:06:59 <Cale> yeah, the record syntax is optional
12:09:19 <jethr0_> Cale: i got the scrabble thing working. thx for your help
12:09:42 <jethr0_> unfortunately it's a bit verbose still, but maybe i'll have an insight where to cut dozens of lines :)
12:09:52 <Saulzar> jonkri, Can't match the variable 'a' for both of them
12:10:15 <Cale> Saulzar: hm?
12:10:23 <jonkri> Saulzar, what? where am i matching?
12:10:27 <Saulzar> Sorry :)
12:10:32 <jonkri> np, thanks anyway :)
12:10:38 <jethr0_> Cale: the only thing i haven't done yet is deriving from MonadPlus, because i have IO in there and didn't really know how to derive my wrapper manually from MonadPlus
12:10:39 <Saulzar> I'm just seeing things.
12:10:44 <jonkri> hehe
12:10:52 <Cale> jonkri: I think he read it as  test (A a a) = a or somethin
12:10:54 <Cale> g
12:11:14 <Saulzar> Yeah.
12:11:14 <Cale> jethr0_: well, you can't derive MonadPlus in that case
12:11:28 <jonkri> that can't be done?
12:11:36 <jonkri> i can match test (A 1 1) = 1
12:11:44 <jonkri> oh
12:11:45 <jonkri> hahaha
12:11:48 <jonkri> someone, hit me!
12:12:26 <jonkri> i
12:12:41 <jonkri> (sorry for flooding) i was thinking a as a variable in a... non-functional sense
12:16:32 <dons> > let 1 = 2 in 3
12:16:34 <lambdabot> 3
12:16:50 <jethr0_> fun with pattern matching
12:17:04 <dons> > case 1 of 2 -> 3
12:17:05 <lambdabot>  Non-exhaustive patterns in case
12:17:08 <jethr0_> > let add = acc in 3
12:17:09 <lambdabot>  Not in scope: `acc'
12:17:40 <dons> pattern matching is so great. i'd hate to have to use a language without it.
12:18:13 <jethr0_> i just thought about how i would try to use union types a la haskell in java. and without pattern matching it's just no fun...
12:18:42 <dons> no fun at all. i think you need about 1 page of code and 2 classes just to get a union going
12:18:53 <dons> (it was an exercise in a class i tutored)
12:20:11 <jethr0_> i was thinking of "interface A {}; class B implements A {}; class C implements A {}; case x {(instanceof B) {}; (instanceof C) {}}
12:20:18 <jethr0_> hmm, i forgot java case syntax already
12:20:37 <Saulzar> Hmm, you can do ok with "visitor" type patterns. But that's not quite the same...
12:20:54 <Saulzar> As in design patterns, not pattern matching :)
12:21:11 <Saulzar> But it's heavyweight for small things
12:21:48 <jethr0_> yes, visitors are generally ok, even in C++. but they sometimes incurr a bad penalty for many object creations/virtual function calls
12:22:14 <jethr0_> stupid STL copies its visitors on each visit (for a reason i never bothered to find out) *tststs*
12:25:29 <jethr0_> > fabs (-0.2)
12:25:30 <lambdabot>  Not in scope: `fabs'
12:25:34 <jethr0_> > abs (-0.2)
12:25:35 <lambdabot> 0.2
12:27:19 <jethr0_> good night
12:33:25 <palomer> hrm, it seems I'm on crack when I write code sometimes
12:33:41 <palomer> I'm surprised it works
12:36:21 <palomer> logical programming would be so much more appropriate for this kind of stuff
12:43:16 * stepcut reads about MIME
12:45:19 <jonkri> brb
12:47:43 * palomer wishes there was a way to browse source file versions seamlessly
12:48:26 <DukeDave> Hey guys, I'm just battling with haskell :)   and wondered if anyone could take a look: http://pastebin.com/586258
12:48:48 <DukeDave> its just a 'quicky', but is causing me no end of grief
12:49:55 * Cale looks
12:50:07 <Lemmih> DukeDave: data Wrapped a = Wrapped a; instance Show a => Show (Wrapped a) where ...
12:50:24 <Cale> yeah
12:51:01 <Lemmih> DukeDave: You can't restrict data declarations.
12:51:34 <DukeDave> excellent
12:52:04 <DukeDave> thanks guys, I am getting there slowly
12:52:11 <DukeDave> :)
12:54:13 <Cale> well, that's a bit of a lie, you can restrict data declarations, it just doesn't mean as much as one might like it to
12:55:26 <Lemmih> What does it affect, OOI?
12:55:37 <Cale> The types of the constructors
12:55:47 <Cale> and of course, functions which pattern match using them
12:55:58 <Lemmih> Ah.
12:56:08 <Cale> but it doesn't allow you to infer the class constraint simply from the type application
12:56:44 <DukeDave> *_*
12:56:55 <Cale> (sorry Dave)
12:57:16 <Cale> what I mean is that if you write
12:57:38 <Cale> data Show a => Wrapped a = Wrapped a
12:57:56 <Cale> then you get a constructor Wrapped :: (Show a) => a -> Wrapped a
12:58:20 <Cale> and anything which pattern matches using Wrapped will get a Show constraint in its type
12:58:21 <Cale> like
12:58:28 <Cale> f (Wrapped a) = a
12:58:37 <Cale> f :: (Show a) => Wrapped a -> a
12:58:49 * DukeDave is digesting
12:59:09 <Cale> but just seeing Wrapped Foo in a type signature doesn't guarantee that there's an instance Show Foo.
12:59:36 <palomer> warning to all: don't write unreadable code, it's probably broken
12:59:59 <DukeDave> with you.
13:00:31 <DukeDave> Clearly its just not possible to make mistakes in this language :)
13:00:43 <Cale> hehe :)
13:01:43 <Cale> @quote-add DukeDave Clearly its just not possible to make mistakes in this language :)
13:01:44 <lambdabot> Unknown command, try @listcommands.
13:02:03 <Cale> @quote DukeDave Clearly it's just not possible to make mistakes in this language :)
13:02:04 <lambdabot> DukeDave Clearly it's just not possible to make mistakes in this language
13:02:04 <lambdabot> :) hasn't said anything memorable
13:02:10 <Cale> what?
13:02:12 <palomer> pfft, I just said that I had a blunder most blunderous
13:02:14 <Cale> hmm
13:03:43 <jimapple> Hello, all
13:03:54 <palomer> ok, I've come to the conclusion that haskell is extra verbose
13:03:58 <palomer> my application is 3000 lines
13:04:04 <palomer> I've never written a 3000 line application before
13:04:38 <jimapple> Maybe that's because you got fed up at line 1000. Now Haskell makes it fun!
13:04:49 <jimapple> :-)
13:05:07 <palomer> and, erm, by the end it'll probably be 4000 lines
13:05:07 <jimapple> What about Haskell is making your code so long?
13:05:20 <Cale> palomer: man, what are you writing?
13:05:57 <Cale> I wrote a pipeline scheduler and register allocator with a parser for a PPC+Altivec assembly language, and it still only came to about 600 lines of code.
13:06:23 <dons> Cale, I disabled quote-add till I work out why it's breaking the random list thing.
13:06:25 <Cale> (and 600 lines of documentation :)
13:06:27 <palomer> a parser and static analyzer
13:06:29 <Cale> dons: oh, okay
13:07:02 <dons> sorry.
13:07:16 <palomer> it's standard H-M, really
13:07:23 <palomer> with nested patterns
13:25:31 <jonkri> if i have a field test of data A = A { x, y :: Int } and want test's x value, what do i type?
13:26:02 <lennart> palomer: 4000 lines?  *gasp*
13:26:13 <lennart> You can write a good compiler in 4000 lines
13:27:20 <jonkri> anyone?
13:27:22 <Cale> It might have something to do with the extensive use of ST
13:27:36 <Cale> jonkri: x test
13:28:03 <jonkri> Cale, thanks
13:29:24 <Cale> Monads are a flexible way to get nice DSLs, but they can become awkward and inexpressive under some conditions.
13:33:38 <jonkri> i have a list of Maybe Int's that i want to convert to ints (remove the Nothing's), how should i do that?
13:35:23 <Cale> concatMaybes
13:35:25 <Cale> er
13:35:27 <Cale> catMaybes
13:35:41 <Cale> > catMaybes [Nothing, Nothing, Just 5, Just 6, Nothing]
13:35:42 <lambdabot> [5,6]
13:35:49 <Cale> it's in Data.Maybe
13:35:55 <jonkri> thanks :)
13:37:46 <dons> 4000 loc for just the type checker and parser? hmm
13:38:27 <dons> yeah, I've got a full haskell type checker and most of a backend interpreter in 4300 lines..
13:38:57 <adu> Cale: i looked at the Haskel 1.4 docs and they looked almost exactly the same except for the "Eval" class
13:39:04 <adu> are there any other differences?
13:39:06 <Cale> adu: lots
13:39:16 <Cale> adu: look at the type of filter
13:39:27 <adu> filter?
13:39:30 <Cale> yeah
13:41:22 <dons> adu, here's a version of the Haskell 1.2 prelude: http://www.cse.unsw.edu.au/~dons/cc.prelude
13:41:28 <dons> which is worth looking at
13:41:55 <adu> thanx
13:42:00 <dons> at least for the dfinition of `undefined':
13:42:01 <dons> undefined              :: a
13:42:02 <dons> undefined | False       = undefined
13:42:22 <Cale> there are lots of definitions where the type is subtly different
13:42:31 <Cale> in Haskell 1.4, the type of (++), for example
13:42:38 <palomer> @hoogle lookupWith
13:42:39 <lambdabot> Data.FiniteMap.lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt
13:42:39 <lambdabot> -> key -> elt
13:42:39 <lambdabot> Data.IntMap.insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a ->
13:42:39 <lambdabot> IntMap a -> (Maybe a, IntMap a)
13:42:39 <lambdabot> Data.IntMap.updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap
13:42:41 <lambdabot> a -> (Maybe a, IntMap a)
13:43:36 <palomer> is it possible to have local instance declarations?
13:44:27 <eivuokko> Nope.
13:44:36 <dons> palomer, it's questions like that that partially explain this 4000 line type checker ;)  hehe
13:46:14 <adu> i don't see filter in haskell98
13:46:39 <Cale> it's there
13:46:43 <Cale> @type filter
13:46:44 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:46:57 <Cale> with a much more specific type than it had in 1.4
13:47:05 <adu> oh its in PreludeList
13:47:12 <adu> in 1.4 it was in Prelude
13:47:17 <adu> hm
13:48:47 <adu> oh ic, so now it only works on lists, but before it could work on any MonadZero instance?
13:50:37 <adu> why is the "forall a" not present in the definitions?
13:51:22 <palomer> is there a reason why you can't have local instance declarations?
13:51:48 <eivuokko> adu, maybe because forall is not part haskell98 (not really knowing what you are referring to)
13:52:09 <adu> hm
13:52:26 <adu> @type sequence
13:52:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:53:05 <lennart> palomer: yes
13:53:15 <lennart> :)
13:54:34 <palomer> a very good reason?
13:55:36 <lennart> palomer: well, if you believe that coherency is important when resolving overloading it's a good reason.
13:55:46 <eivuokko> palomer, opinions seem to vary.  As it usually is, probably biggest reason being that noone implemented convincing system.
13:56:37 <palomer> but when would it be a problem?
13:56:50 <lennart> yes, there's no proof that you can't make a nice type system with local instances.  just that none have been made (that I know)
14:01:15 <palomer> 40 line do statements are no fun
14:02:31 <adu> how exactly does 
14:02:43 <adu> "properFraction" work?
14:03:18 <liyang> gcd?
14:03:38 <adu> no i mean given an integer, like 5, does it return (5, 0)?
14:03:43 <adu> or (4, 1)?
14:03:58 <jimapple> >properFraction 5
14:04:07 <dons> > properFraction 5
14:04:08 <lambdabot> (5,0.0)
14:04:57 <adu> then the haskell 98 report is wrong
14:05:11 <adu> > ceiling 5
14:05:12 <lambdabot> 5
14:05:39 <adu> according to the haskell 98 report ceiling 5 should be 6 and floor 5 should be 4 which is wrong
14:06:03 <lennart> adu: yes, if the report says that it is wrong
14:06:19 <adu> unless
14:06:42 <adu> wait, it only applies when r > 0, so n/m
14:07:04 <adu> sorry
14:08:05 <adu> >properFraction -4.5
14:08:27 <adu> > properFraction -4.5
14:08:28 <lambdabot>  add an instance declaration for (Fractional (a -> (b, a)))
14:09:03 <eivuokko> > properFraction (-4.5)
14:09:04 <lambdabot> (-4,-0.5)
14:09:50 <adu> thanx
14:14:48 <Cale> palomer: does that last statement have anything to do with the local instances thing?
14:15:05 <palomer> oh, no
14:15:17 <palomer> it has more to do with me being unable to find the right abstractions
14:20:28 * palomer kicks the spine calculus
14:42:00 <aslplssa> @help
14:42:01 <lambdabot>  @help <command> - ask for help for <command>
14:42:04 <aslplssa> @help limit
14:42:05 <lambdabot>  @help <command> - ask for help for <command>
14:42:10 <aslplssa> @help change limit
14:42:11 <lambdabot>  @help <command> - ask for help for <command>
14:42:12 <aslplssa> @help change limits
14:42:13 <lambdabot>  @help <command> - ask for help for <command>
14:42:26 <aslplssa> @help @help limit
14:42:27 <lambdabot>  @help <command> - ask for help for <command>
14:42:32 <dons> aslplssa, what are you trying to do?
14:42:53 <dons> there's no limit command..
14:42:55 <aslplssa> dons, bro i need help how to change limit on the tool of perl mambo bot
14:43:15 <dons> wrong channel I think...
14:43:38 <aslplssa> where i can join for that thenb
14:43:39 <dons> this is the haskell channel, not the perl channel. and lambdabot is no perl bot.
14:43:47 <dons> don't knoow.
14:44:03 <aslplssa> @help version
14:44:04 <lambdabot> Report the build date, ghc version and darcs repo of this bot
14:44:10 <dons> funny that you thought to try here though.
14:44:19 <aslplssa> ah
14:44:20 <aslplssa> ok
14:50:36 <Cale> Daan's proposal for records looks really good. http://www.cs.uu.nl/~daan/pubs.html
14:51:29 <Cale> Are there any known problems with it?
14:52:13 <Cale> There are no lacks predicates to deal with, and it has basically all the nice operations which you'd want in a general extensible record system.
14:53:49 <Cale> Type inference is complete and sound
14:54:05 <Cale> why haven't people jumped all over this? :)
14:55:33 <jimapple> Other things on their plates?
15:11:39 <jonkri> thanks everyone
15:11:40 <jonkri> cya
15:12:06 <Cale> well, there's a lot of discussion on record systems going on, and if people have been aware of this paper, I don't understand how they could be making the meagre proposals that they have been
15:13:16 <Cale> If I knew more about GHC's internals, I'd likely go ahead and try to implement it myself :)
15:16:59 <jimapple> I think Haskell' is only including things already implemented
15:18:26 <jimapple> The morrow interpreter is nowhere to be found
15:20:36 <Cale> hmm
15:20:43 <stepcut> I drove past morrow street today...
15:20:46 <Cale> Still, people have proposed to implement more
15:21:50 <stepcut> Cale: i will read that paper tomorrow, thanks
15:23:09 <jimapple> It true, but I think the committee will be conservative
15:24:07 <jimapple> There is so much low-hanging fruit right now that I can see implementers doing other things foirst, which makes them all look bad for not implementing Haskell06, even though they implemented the most useful features
15:25:22 <Cale> that's likely, though there are some (meta-)proposals to allow for standardising various optional extensions, which would allow good ideas which weren't formally part of Haskell' to get standardised and implemented
15:25:47 <Cale> Can I ask what low-hanging fruit people are working on? :)
15:26:44 <adu> fruit?
15:26:50 <jimapple> the GHC team is working on:
15:27:19 <Cale> adu: "Low-hanging fruit" is an expression which roughly means "Things which are good and easily implemented"
15:27:47 <jimapple> (though, of course, there's also the tantalus reference!)
15:27:51 <jimapple> GHC as a library
15:28:00 <jimapple> better interactions of GADTs with type classes
15:28:15 <jimapple> Sim Sheard's stuff w/ user-defined kinds
15:28:24 <jimapple> impredicativity
15:28:32 <jimapple> associated types with class
15:28:54 <jimapple> Sulzmann's CHR stuff
15:29:49 <Cale> oh, I didn't know that CHRs were actually something to be implemented -- I thought they were a formalism for discussing the properties of fundeps and similar systems, but that makes sense :)
15:30:55 <jimapple> I think they won't be implemented, but that they will provide such use in understanding FDs that teh team will spend time on them, as SPJ already appears to be doing
15:31:03 <jimapple> I feel like a Kremlinologist sometimes
15:32:03 <jimapple> (The spell checker in Gaim knows the word "Kremlinologist" but nots the word "GAIM" "gaim" or "Gaim")
15:33:27 <jimapple> g'night, all
15:35:26 <Cale> night
15:38:18 <palomer> ok
15:38:29 <palomer> I've heard impredicativity used everywhere
15:38:31 <palomer> what does it mean?
15:49:06 <dons> ndm, tell me more about this python interpreter for yhc bytecode..
15:49:31 <dons> how big is it? does it mean i could write a faster haskell one fairly easily?
16:02:05 <Cale> palomer: I believe a type system is called impredicative if it allows type variables to be instantiated with polytypes.
16:02:49 <Cale> Consider the program:
16:03:02 <Cale> f get = (get [1,2], get "abc")
16:03:34 <Cale> We'd need to give a higher rank type to f in order to get it to compile
16:04:46 <Cale> Now look at
16:04:57 <Cale> g Nothing = (0,'0')
16:05:11 <Cale> g (Just get) = (get [1,2], get "abc")
16:05:40 <Cale> g :: Maybe (forall a. [a] -> a) -> (Int, Char)
16:06:30 <Cale> that sort of thing isn't normally allowed even with higher rank types
16:07:14 <Cale> http://research.microsoft.com/~simonpj/papers/boxy/ -- those examples were stolen from here :)
16:07:54 <palomer> oh
16:08:07 <palomer> impredicative means other things in logic
16:08:09 <palomer> I think
16:08:37 <Cale> the uses are probably somehow related
16:13:57 <palomer> ghc uses an impredicative type system, no?
16:33:18 <palomer> why isn't it allowed?
16:33:22 <palomer> hrmph, I'm too tired
16:36:35 <Cale> ghc currently uses a predicative type system
16:36:58 <Cale> the type variable 'a' in Maybe a must be instantiated to a monotype
17:10:04 <Cale> l
18:17:01 <shapr> Goood morning #haskell !
18:17:17 <juhp> from the point of view of library ABI it doesn't matter what version of gcc I build ghc with does it?
18:19:06 <juhp> Iã€€mean ghc binaries (of the same version) are compatible irrespective of which gcc there're built with presumably?
18:19:21 <juhp> right?
18:20:58 <shapr> It would seem likely.
18:21:08 <juhp> shapr: :)
18:21:28 * shapr pretends to be a magic 8-ball
18:22:07 <juhp> shapr: just that I'm having trouble building ghc on x86_64 with gcc-4.1 ;)
18:22:12 <Saulzar> They upgraded to gcc 4.0 at uni, and I have been using the binary ghc package.. still seems to work
18:22:31 <juhp> Saulzar: yea
18:23:14 <juhp> well I'm pretty sure it is true - at least for sanely recent versions
18:24:25 <juhp> perhaps for now I'll just rebuild it with gcc34 ;)
19:06:17 * shapr boings cheerfully
19:08:39 <Muad_Dib> hi shapr :)
19:08:50 <shapr> Hiya, wassup?
19:08:59 <Muad_Dib> Not much, you?
19:09:06 <tromp_> g'morning
19:09:07 <shapr> Workin, same as most days.
19:09:08 <shapr> hoi tromp_ 
19:15:40 <EtnaRosso> morning all
19:24:18 <shapr> Can anyone recommend an open source timeclock that automatically calculates time per-project, etc?
19:26:24 <EtnaRosso> some references to rule based
19:26:29 <EtnaRosso> reasoning in haskell?
19:27:46 <shapr> EtnaRosso: Is Constraint Handling close enough?
19:27:57 <shapr> Or maybe Computer Algebra Systems like DoCon?
19:28:17 <EtnaRosso> i don't know
19:29:57 <shapr> @google rule based reasoning haskell
19:29:59 <lambdabot> http://portal.acm.org/citation.cfm?id=570193
19:30:42 <EtnaRosso> thanks i have found a project called swish
19:31:46 <kosmikus> morning
19:53:40 <Noobluck> hello folks
19:54:00 <Noobluck> > repeat "hello "
19:54:01 <lambdabot> ["hello ","hello ","hello ","hello ","hello ","hello ","hello ","hello ","
19:54:01 <lambdabot> hello ","hello ","hello ","hello ","hello ","hello ","hello ","hello ","
19:54:01 <lambdabot> hello ","hello ","hello ","hello ","hello ","hello ","hello ","hello ","
19:54:01 <lambdabot> hello ","hello ","hello ","hello ","hello ","hello ","hello ","hello ","
19:54:01 <lambdabot> hello ","hello ","hello ","hello ","hello ","hello ","hello ","hello ","
19:54:03 <lambdabot> [24 @more lines]
19:54:46 <ProfTeggy> Nooclue, thanks for the flood.
19:54:49 <Noobluck> to make a list of lists
19:55:03 <Noobluck> become a list?
19:55:13 <ProfTeggy> @tyep concat
19:55:14 <lambdabot> forall a. [[a]] -> [a]
19:55:15 <Noobluck> with concatenation
19:55:22 <mauke> sounds zen
19:55:22 <Noobluck> ok
19:55:25 <Noobluck> thanks
19:55:47 <Noobluck> > concat repeat "Hello "
19:55:48 <lambdabot> Couldn't match `[a]' against `t -> t1'
19:55:51 <sieni> foldr (++) [] $ repeat "All work and no play makes Jack a dull boy. "
19:55:54 <Noobluck> > concat (repeat "Hello ")
19:55:55 <lambdabot> "Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
19:55:55 <lambdabot> Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
19:55:55 <lambdabot> Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
19:55:55 <lambdabot> Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
19:55:55 <lambdabot> Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
19:55:57 <sieni> > foldr (++) [] $ repeat "All work and no play makes Jack a dull boy. "
19:55:57 <lambdabot> [24 @more lines]
19:55:59 <lambdabot> "All work and no play makes Jack a dull boy. All work and no play makes
19:56:00 <Noobluck> :)
19:56:01 <lambdabot> Jack a dull boy. All work and no play makes Jack a dull boy. All work and
19:56:03 <lambdabot> no play makes Jack a dull boy. All work and no play makes Jack a dull boy.
19:56:03 <mauke> @type cycle
19:56:05 <lambdabot> All work and no play makes Jack a dull boy. All work and no play makes
19:56:07 <lambdabot> Jack a dull boy. All work and no play makes Jack a dull boy. All work and
19:56:09 <lambdabot> [23 @more lines]
19:56:11 <lambdabot> forall a. [a] -> [a]
19:56:31 <Noobluck> @type cycle
19:56:31 <lambdabot> forall a. [a] -> [a]
19:56:37 <Noobluck> if i define my concat
19:56:41 <Noobluck> my own concat
19:56:47 <Noobluck> and i load into a module
19:56:57 <Noobluck> if i cal from interpreter
19:57:01 <Noobluck> call
19:57:06 <Noobluck> which is executed
19:57:07 <Noobluck> ??
19:57:24 <Noobluck> cycle [1,23]
19:57:27 <mauke> neither, you'll get an error
19:57:32 <Noobluck> > cycle [1,23]
19:57:33 <lambdabot> [1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,
19:57:33 <lambdabot> 23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
19:57:33 <lambdabot> 1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,
19:57:33 <lambdabot> 23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
19:57:33 <lambdabot> 1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,
19:57:35 <lambdabot> [24 @more lines]
19:57:36 <Noobluck> thanks
19:57:38 <EtnaRosso> there is a function to remove all the occurrences of an element in a list=
19:57:40 <EtnaRosso> ?
19:58:04 <ProfTeggy> @type List.delete
19:58:06 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
19:58:35 <sieni> >  (\x y -> filter (/= x) y) 7 [1..10]    
19:58:37 <lambdabot> [1,2,3,4,5,6,8,9,10]
19:58:37 <tromp_> > delete 0 [0,0]
19:58:38 <lambdabot> [0]
19:59:06 <tromp_> delete only deletes the  first occurance
20:00:33 <ProfTeggy> tromp, it's a tiny step from there
20:00:44 <tromp_> filter makes more sense then
20:01:09 <ProfTeggy> [ x | x <- xs, x /= e ]
20:01:44 <Noobluck> cycle "hello "
20:01:47 <Noobluck> > cycle "hello "
20:01:48 <lambdabot> "hello hello hello hello hello hello hello hello hello hello hello hello
20:01:48 <lambdabot> hello hello hello hello hello hello hello hello hello hello hello hello
20:01:48 <lambdabot> hello hello hello hello hello hello hello hello hello hello hello hello
20:01:48 <lambdabot> hello hello hello hello hello hello hello hello hello hello hello hello
20:01:48 <lambdabot> hello hello hello hello hello hello hello hello hello hello hello hello
20:01:50 <Noobluck> ok
20:01:50 <lambdabot> [24 @more lines]
20:02:37 <Noobluck> @type concat
20:02:37 <lambdabot> forall a. [[a]] -> [a]
20:02:57 <Noobluck> @type forall
20:02:58 <lambdabot> Not in scope: `forall'
20:03:43 <Lieter> Noobluck he means a can be any type
20:03:52 <Noobluck> ok
20:04:02 <Lieter> that i do know from haskell :P
20:04:27 <Noobluck> where i can learn this notation? (\x y -> filter (/= x) y) 7 [1..10]    
20:05:22 * shapr swears at the crappy database support in Python/Zope/Plone.
20:05:30 <shapr> Why can't I use HaskellDB? It's so cool!
20:05:40 <Lieter> @type elem
20:05:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
20:05:57 <Lieter> @type concatMap
20:05:58 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
20:06:09 <EtnaRosso> the sintax on ghci to add a module?
20:06:25 <bolrod> :?
20:06:27 <bolrod> :)
20:07:48 <kosmikus> EtnaRosso: :m +Foo
20:08:28 <EtnaRosso> thanks
20:09:02 <EtnaRosso> but delete removes only the first occurrences
20:09:17 <Noobluck> @type even
20:09:17 <lambdabot> forall a. (Integral a) => a -> Bool
20:10:04 <Noobluck> module <name> where
20:10:12 <Noobluck> import data.char
20:10:15 <Noobluck> module <name> where
20:10:16 <Noobluck> import data.char
20:10:27 <Noobluck> the import should have a full path
20:10:47 <Noobluck> and the module name must begin with an upper letter
20:11:32 <Noobluck> and have have the same name as the file (without th .hs extension)
20:20:18 <Noobluck> @type sort
20:20:18 <lambdabot> Not in scope: `sort'
20:20:27 <Lieter> @help
20:20:28 <lambdabot>  @help <command> - ask for help for <command>
20:21:03 <dblhelix> @type List.sort
20:21:04 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:24:12 <kosmikus> @index sort
20:24:12 <lambdabot> Data.List
20:25:40 <EtnaRosso> some sample code for the random function?
20:32:17 <musasabi> EtnaRosso: look at the source of System.Random
20:32:36 <musasabi> darcs.haskell.org/packages/base/System/Random.hs I would guess
20:38:03 <Noobluck> i have to implement the sort function
20:38:21 <Noobluck> can you give me some ideas?
20:38:47 <tromp_> quicksort is easy
20:39:44 <nothingmuch> Noobluck: what do you know about sorts?
20:39:54 <nothingmuch> are you familiar with big O complexity and all that/
20:39:56 <nothingmuch> ?
20:40:07 <Noobluck> quicksorts merget sort
20:40:13 <Noobluck> no
20:40:18 <nothingmuch> okay
20:40:27 <nothingmuch> do you know bubble sort? insertion sort?
20:40:35 <Noobluck> insertion
20:40:37 <nothingmuch> okay
20:40:39 <Noobluck> all
20:40:46 <nothingmuch> and is haskell your first language dealing with this stuff?
20:40:50 <Noobluck> but forgot ~_~
20:40:53 <Noobluck> no
20:40:55 <Noobluck> is C
20:40:58 <nothingmuch> hmm
20:41:01 <Noobluck> i think
20:41:08 <nothingmuch> well, let go of your misconceptions about "easy"
20:41:08 <Noobluck> it should not be efficient
20:41:13 <nothingmuch> =)
20:41:15 <nothingmuch> good
20:41:25 <Noobluck> just a couple of lines
20:41:31 <nothingmuch> is this homework you want to do on your own? or do you want to learn  from example?
20:41:49 <Noobluck> i have been thinking for 20 minutes
20:41:52 <Noobluck> i am stuck
20:41:58 <Noobluck> no fold
20:42:03 <Noobluck> no map no filter
20:42:06 <Noobluck> can be used
20:42:08 <musasabi> sort' [] = []; sort' (x:xs) = low ++ [x] ++ high where low = ...; high = ...
20:42:42 <nothingmuch> are you allowed to implement filter on your own?
20:42:46 <nothingmuch> what about list comprehensions?
20:42:54 <Noobluck> im on ti
20:42:56 <nothingmuch> (arguably they are almost like filters)
20:43:03 <Noobluck> all of list
20:43:07 <Noobluck> can be used
20:43:44 <Noobluck> i think i will use quick sort
20:43:50 <Noobluck> is in documentation page
20:43:51 <Noobluck> XD
20:43:51 <nothingmuch> myFilter f (x:xs) = if f x then x:rest else rest where rest = myFilter f xs
20:44:03 <nothingmuch> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
20:44:07 <nothingmuch> that's the canonical implementation
20:44:11 <Noobluck> yes
20:44:23 <nothingmuch> it could use filter instead of list comprehensions
20:44:34 <nothingmuch> there's really no diference in brevity here
20:44:39 <nothingmuch> you can even use a part function:
20:44:55 <Noobluck> but the name is isort
20:45:04 <Noobluck> i think i should do insertion
20:45:45 <nothingmuch> sort (x:xs) = smaller ++ [x] ++ bigger where (smaller,bigger) = part (< x) xs
20:45:55 <nothingmuch> and then define part in terms of an accumilator function or something like that
20:46:08 <nothingmuch> insertion is not that trivial in haskell
20:46:19 <nothingmuch> since it's intuitive with mutable structures
20:46:22 <nothingmuch> and not really with lists
20:46:32 <Noobluck> lol i found the exercise
20:46:37 <Noobluck> they where asking me
20:47:10 <Noobluck> ok
20:47:15 <Noobluck> quicksort better
20:47:21 <Noobluck> http://www.comp.dit.ie/rlawlor/Prob_Solv/Hugs/Hugs_10%20Sorting.pdf
20:47:24 * shapr quicksorts his brain
20:47:24 <Noobluck> found this
20:47:36 <nothingmuch> Noobluck: do you understand the code on the wiki?
20:48:08 <nothingmuch> http://en.wikipedia.org/wiki/Quicksort
20:48:25 <earthy> *WOEI*
20:48:36 <earthy> (sorry, wrong channel)
20:48:52 <Noobluck> yes
20:48:55 <nothingmuch> anyway, i'm off to get some "real' work done
20:49:01 <Noobluck> but this is a lab practice
20:49:01 <nothingmuch> Noobluck: good luck
20:49:06 <nothingmuch> err, so?
20:49:12 <nothingmuch> you need to make it more complicated?
20:49:17 <nothingmuch> just make sure you really understand the code
20:49:26 <nothingmuch> evaluate it (lazily!) in your head
20:49:51 <Noobluck> yeah
20:50:00 <Noobluck> the problem is they dont ask 
20:50:15 <nothingmuch> who?
20:50:18 <nothingmuch> your profs?
20:50:22 <Noobluck> no
20:50:25 <Noobluck> is hard
20:50:28 <Noobluck> ok?
20:50:30 <nothingmuch> i don't understand
20:50:32 <Noobluck> jaj
20:50:50 <Noobluck> functional paradigm is hard since is the first time we study it
20:50:57 <nothingmuch> okay
20:51:08 <Noobluck> we don't know right now about intensional lists
20:51:10 <Noobluck> ok?
20:51:20 <nothingmuch> i don't know what intensional lists are either ;-)
20:51:29 <nothingmuch> anyway, let's go through the quicksort example on the hawiki
20:51:53 <Noobluck> [x * x | x [1..5], odd x ]
20:51:56 <Noobluck> > [x * x | x [1..5], odd x ]
20:51:57 <lambdabot>  Not in scope: `x'
20:52:15 <nothingmuch> x <- [1 .. 5]
20:52:23 <nothingmuch> read it like this:
20:52:51 <nothingmuch> "make a list of x * x" where "odd x" returns true, and "x is bound to every element of [1..5]"
20:53:40 <nothingmuch> so, it takes 1, binds it to x, runs 'odd x' on it, gets true, evaluates x * x, gets 1, and accumilates that
20:53:51 <Noobluck> yes im am reading this
20:53:55 <Noobluck> now
20:54:06 <Noobluck> this is nice
20:54:09 <nothingmuch> okay
20:54:12 <nothingmuch> but it's just sugar
20:54:27 <Lieter> [ (x,y) | x<-[1..5], even x, y<-[1..x] ]
20:54:38 <Noobluck> [(a,b) | a <- [1..3], b <- [1..3]]
20:54:46 <nothingmuch> Lieter: don't be mean ;-)
20:54:53 <Lieter> i'm just trying
20:55:00 <Lieter> i dun understand it too :P
20:55:03 <Noobluck> that means
20:55:03 <nothingmuch> oh =)
20:55:05 <Lieter>  [ (x,y) | x<-[1..5], even x, y<-[1..x] ]
20:55:07 <nothingmuch> well, try something simpler
20:55:20 <nothingmuch> [ (x,y) | x<-[1..3], y<-[1..3] ]
20:55:25 <Noobluck> make a list ot tuples
20:55:26 <Lieter>    deelnemers = nub (concat [deelnmr | (_,_,_,deelnmr) <- agenda])
20:55:29 <nothingmuch> try to guess what that gives you
20:55:37 <Lieter> i did that already
20:55:43 <Lieter> but i cant figure out why it works :P
20:55:44 <nothingmuch> okay
20:55:46 <nothingmuch> oh
20:55:49 <Noobluck> where x is in 1 to 5 and elementes are even
20:55:58 <nothingmuch> there <- thing specs what to bind into each symbol
20:56:00 <Noobluck> and combine it with
20:56:01 <nothingmuch> do you get that part?
20:56:07 <nothingmuch> [1 .. 5], even x ?
20:56:25 <nothingmuch> basically, the list of even numbers will be bound, element by element, into x
20:56:28 <Lieter> yeah 1 thru 5 but only the even nums
20:56:29 <Noobluck> y that is in 1 to x
20:56:34 <nothingmuch> okay
20:56:43 <nothingmuch> the second list will be created a new for every element of x
20:56:58 <Noobluck> yes
20:57:03 <Noobluck> and an x
20:57:04 <Lieter> yes
20:57:12 <Noobluck> will be combined with al the x
20:57:18 <nothingmuch> okayy
20:57:23 <Noobluck> all the y
20:57:26 <Noobluck> lesser than x
20:57:27 <Noobluck> !!
20:57:36 <nothingmuch> then it takes the left most part (x,y) and evaluates that for every combination of an x and a y
20:57:56 <nothingmuch> and that's your result list
20:58:19 <nothingmuch> okay
20:58:21 <Lieter> with tupels
20:58:23 <nothingmuch> if we have a list
20:58:34 <nothingmuch> of random numbers, 10 elements long
20:58:39 <nothingmuch> in 'list'
20:58:42 <nothingmuch> and we say
20:59:00 <nothingmuch> [ x | x <- list, ( < 5 ) ]
20:59:03 <nothingmuch> what does that mean?
20:59:04 <Noobluck> now i have to implemetn
20:59:09 <Noobluck> implement
20:59:13 <Noobluck> map and filter
20:59:15 <nothingmuch> no no, just follow through
20:59:18 <Noobluck> with intensional listss
20:59:40 <Lieter> i think make a list of x'es where x is smaller then 5
20:59:41 <nothingmuch> they're more commonly called list comprehensions
20:59:42 <nothingmuch> okay
20:59:45 <nothingmuch> filter is very very easy:
20:59:48 <bolrod> less then 12 hours left Lieter ;p
20:59:57 <nothingmuch> myFilter f list = [ x | x <- list, f x ]
21:00:12 <nothingmuch> let's take that apart:
21:00:13 <Lieter> idd bolrod ;)
21:00:19 <Noobluck> [ x | x <- list, ( < 5 ) ] is the same as filter (<5) list
21:00:20 <nothingmuch> it binds x to every element of list, right?
21:00:30 <Lieter> yes
21:00:31 <nothingmuch> Noobluck: right
21:00:54 <nothingmuch> Noobluck: so, if instead of '5' we have the quicksort pivot in there, it's the unsorted list of all the elements smaller than the pivot
21:01:19 <Noobluck> yes now i get the quicksort
21:01:30 <nothingmuch> anyway, map:
21:01:35 <Noobluck> isort :: [Int] -> [Int]
21:01:35 <Noobluck> isort [] = []
21:01:35 <Noobluck> isort (x:xs) = insert x (isort xs)
21:01:35 <Noobluck> insert :: Int -> [Int] -> [Int]
21:01:35 <Noobluck> insert x xs = [y | y <- xs, y <= x] ++ [x] ++ [y | y <- xs, y > x]
21:01:41 <nothingmuch> myMap f list = [ f x | x <- list ]
21:01:43 <nothingmuch> or
21:01:43 <Noobluck> this is what they wanted me to do
21:01:47 <Noobluck> i found it
21:01:57 <nothingmuch> myMap f (x:xs) = f x : myMap f xs
21:02:19 <nothingmuch> yuck yuck yuck yuck yuck
21:02:21 <nothingmuch> but okay =)
21:02:23 <Noobluck> myMap f (x:xs)
21:02:33 <nothingmuch> Noobluck: are you asking what that means?
21:02:40 <Noobluck>         | fx = myMap f xs
21:02:52 <nothingmuch> isort does *not* map well to funnctional ;-)
21:02:59 <Noobluck> | otherwise = myMap f xs
21:03:09 <Noobluck> myMap f (x:xs)
21:03:10 <Noobluck> | otherwise = myMap f xs
21:03:11 <nothingmuch> why are you using a guaurd?
21:03:13 <shapr> Has anyone else read the bi-arrows paper?
21:03:13 <Noobluck> myMap f (x:xs)
21:03:17 <Noobluck>         | fx = myMap f xs
21:03:28 <Noobluck>      otherwise = myMap f xs
21:03:32 <nothingmuch> no
21:03:37 <nothingmuch> fx does not exist
21:03:41 <nothingmuch> and makes no sense here
21:03:43 <shapr> jimapple: Have you read the bi-arrows for reversible computations paper?
21:03:49 <Noobluck>         | f = myMap f xs
21:03:54 <Noobluck>         | f  x= myMap f xs
21:03:57 <Noobluck> ahh
21:04:02 <nothingmuch> Noobluck: err, no
21:05:00 <nothingmuch> anyway,  i have to go back to work
21:05:02 <Noobluck> myMap f (x:xs)
21:05:02 <Noobluck>         | f x       = x:myMap f xs
21:05:02 <Noobluck> 	| otherwise = myMap f xs
21:05:02 <nothingmuch> ciao
21:05:04 <Noobluck> this
21:05:10 <nothingmuch> that's a filter, not a map
21:05:17 <Noobluck> ok
21:05:19 <Noobluck> XD
21:06:12 <Noobluck> thanks!
21:06:54 <integral> shapr: do you have a url for that paper?
21:07:59 <integral> shapr: n/m I found it
21:11:15 <jelmer> hey arjanb :-)
21:14:04 <arjanb> hey jelmer
21:16:49 <shapr> Anyone read any cool papers recently?
21:18:15 <earthy> not really
21:18:54 <shapr> I have ~100 in my incoming papers list, just curious if anyone else has something to suggest.
21:19:32 <earthy> although, there was something on LTU that I liked
21:19:41 <shapr> Which?
21:19:55 <earthy> ah, right, Barry Mazur's introduction to Category Theroy
21:19:58 <earthy> Theory even
21:20:51 <shapr> Here's a neat paper - http://www.nyu.edu/gsas/dept/philo/courses/concepts/magicwords.html
21:21:04 <shapr> It fits with my own theories of language as a tool for symbolic computation.
21:21:54 <earthy> Wittgenstein redux
21:24:27 <earthy> unfortunately with little practical research to support it
21:24:50 <shapr> I wonder if "Structuring Quantum Effects: Superoperators as Arrows" and "Bi-Arrows for Reversible Computation" are connected. It would seem so.
21:25:50 <araujo> Morning!
21:26:03 <shapr> hola
21:26:25 <araujo> hola shapr !
21:37:10 <shapr> isydor: salut
21:37:25 <isydor> shapr: salut
21:37:41 <shapr> connais tu Lunar^?
21:38:57 <isydor> en effet oui pourquoi ? :) 
21:40:44 <shapr> isydor: Just curious, since you come from poivron.org :-)
21:46:40 <isydor> shapr: ok ^^
22:02:47 <chrisbro1n> hi all
22:15:45 <Lieter> @type nub
22:15:46 <lambdabot> Not in scope: `nub'
22:15:51 <Lieter> @type nub()
22:15:52 <lambdabot> Not in scope: `nub'
22:16:04 <mauke> @index nub
22:16:05 <Lieter> @type (nub)
22:16:05 <lambdabot> Data.List
22:16:06 <lambdabot> Not in scope: `nub'
22:17:07 <wolverian> @type Data.List.nub
22:17:07 <lambdabot> forall a. (Eq a) => [a] -> [a]
22:18:11 <bolrod> what's nub O_o
22:19:22 <bolrod> aha...
22:20:14 <wolverian> it's a shorter version of noob ;)
22:21:22 <bolrod> AHAHAHAHAHAA ...  ic -,-
22:22:06 <mauke> nub = uniq
22:25:48 <bolrod> yes I see here..
22:51:17 <araujo> @index isJust
22:51:18 <lambdabot> Data.Maybe
22:55:05 <bolrod> hmm
22:58:15 * araujo wonders if a function with 8 arguments is just too much
22:58:41 <tic> maybe it's very generic? :)
23:00:21 * bolrod wonders if a recursion between 3 functions is a bit too much
23:00:27 <bolrod> :)
23:01:13 <bolrod> watever.. it works.. 
23:02:11 <sieni> of course, all functions in Haskell take only 1 argument ;-)
23:03:00 <tromp_> except the ones that take 0 arguments:)
23:04:17 <ski> nothingmuch : isort = foldr insert []
23:04:19 <araujo> tic, well, it gotta take care of pretty much a lot of things
23:04:46 <nothingmuch> ski: ooh
23:04:47 <ski> tromp_ : right .. and there are exactly 0 such
23:04:55 <nothingmuch> but they weren't alowed to use fold
23:05:00 <araujo> though if i split it up into 2 functions, i should go adding one more function call to the code :-(
23:05:05 * araujo not sure what to do
23:05:28 <tromp_> 0 is one:)
23:05:30 <ski> nothingmuch : but i'd still not say it doesn't map well to FP
23:05:44 <tromp_> False is one...
23:06:00 <bolrod> False is a function?
23:06:07 <ski> > let idF :: (a -> b) -> (a -> b); idF x = x in idF False
23:06:08 <lambdabot> Couldn't match `Bool' against `t -> t1'
23:06:14 <ski> bolrod : no
23:06:20 <tromp_> yes
23:06:22 <bolrod> no
23:06:29 <nothingmuch> ski: that was perhaps an exaggeration, but... err. There are much more beautiful ways to sort in a pure language
23:06:29 <tromp_> a 0 argument function
23:06:33 <bolrod> no
23:06:38 <mauke> AKA constant
23:06:41 <tromp_> yes
23:06:48 <bolrod> hmm
23:06:54 <sieni> @t const False
23:06:55 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
23:06:55 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
23:07:06 <sieni> @type const False
23:07:07 <lambdabot> forall b. b -> Bool
23:07:11 <ski> nothingmuch : there are more beautiful ways to sort, period, perchance ?
23:08:06 <nothingmuch> yes
23:08:17 <nothingmuch> but i dunno, inplace qsort in C is just as ugly as insertion sort
23:08:31 <araujo> nothingmuch, what isn't ugly in C? :-)
23:08:40 <tromp_> there's heapsort, but you need arrays for that
23:09:44 <cpatrick> incidentally, why is there no in-place qsort or heapsort in the haskell standard libraries?
23:09:54 <cpatrick> Data.List.sort is slow!
23:10:23 <nothingmuch> cpatrick: look into the packed array stuff
23:10:26 <araujo> cpatrick, because it is such an easy thing to do by yourself?!
23:10:31 <nothingmuch> (guessing)
23:10:43 <nothingmuch> hehe, insertion sort in ghci on a large reversed array is very "incremental"
23:11:04 <nothingmuch> it sometimes still surprises me the extent of haskell's laziness
23:11:06 <musasabi> cpatrick: like the sort in fps?
23:12:04 <cpatrick> musasabi, nothingmuch: ooh, didn't know about that. I'll have to look at FPS then
23:15:11 <cpatrick> musasabi: that only works if you have an FPS of chars though?
23:15:47 <musasabi> well Char is not very efficient in any case
23:30:56 <dons> yeah, in-place sort on a list doesn't make sense, does it?
23:31:07 <dons> so use sort on packed strings, if speed is a big deal
23:31:19 <dons> fps-sort uses sort(3)
23:43:04 <nothingmuch> home &
