00:01:44 <shapr> @vixen oh yeah?
00:01:44 <lambdabot> understand now?
00:01:51 <shapr> @vixen love, baby
00:01:51 <lambdabot> ain't it just like a man?
00:10:37 <shapr> @quote lispy
00:10:37 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to
00:10:37 <lambdabot> tell my alarm clock how to snooze by using a list comprehension
00:10:55 <shapr> @quote gzl
00:10:56 <lambdabot>  [on why monads are scary] maybe it's because people look up monad on
00:10:56 <lambdabot> wikipedia, find the category theory page, and crap themselves
00:11:33 <shapr> @quote mwc
00:11:33 <lambdabot>  I actually got away with running Haskell through a TeX pretty printer
00:11:33 <lambdabot> and handing it in as pseudocode
00:11:44 <mathrick> haha
00:11:47 <vincenz> lol
00:12:10 <mathrick> \usepackage{listings} is amazing, too
00:12:23 <vincenz> that's arguable
00:12:25 <shapr> @quote xerox
00:12:25 <lambdabot>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l"
00:12:25 <lambdabot> ) lol
00:12:31 <mathrick> it's a reason alone to bother with all of LaTeX's idiosyncracies
00:13:07 <mathrick> vincenz: dunno, if something reduces the task of including 10 pages source code to 2 lines, it's amazing in my book :)
00:13:11 <shapr> @quote lambdabot 
00:13:11 <lambdabot>  lambdabot hasn't said anything memorable
00:13:27 <shapr> @quote ghc
00:13:27 <lambdabot>  GHC stage restriction
00:13:30 <shapr> @quote ghc
00:13:30 <lambdabot>  Offending Program
00:13:39 <shapr> ooh, I like that one.
00:13:49 <shapr> @quote dons
00:13:50 <lambdabot>  note to self: grep only works on disks
00:14:02 <shapr> @quote cjs
00:14:03 <lambdabot>  I have to explain this shit to people. I mean, I start out right, "Hey,
00:14:03 <lambdabot> you know how you always have these bugs because what you thought was in
00:14:03 <lambdabot> the variable is not there?" And I get all of these nods of agreement. "
00:14:03 <lambdabot> Well, I've found a new language that solves that problem." Audience: "
00:14:03 <lambdabot> Ooooh! How?" Me: "There's no variables!" And then they all start moving
00:14:05 <lambdabot> away from me slowly....
00:14:46 <shapr> @quote SebastianHanowski
00:14:47 <lambdabot>  I tried to formalise a proof of rev (rev l)  = l i found in W. Kluges
00:14:47 <lambdabot> book "Abstract Computing Machines - A Lambda Calculus Perspective" which
00:14:47 <lambdabot> is pretty much a 'Pimp My Ride' for SECD-machines.
00:15:23 <shapr> @quote
00:15:23 <lambdabot> Gahhh says: monads are usually a personal experience.
00:15:39 <shapr> lambdabot is one of my favorite toys.
00:16:03 <shapr> mathrick: I've never gotten around to learning LaTeX... one day.
00:16:09 <shapr> mathrick: How's Haskell treating you?
00:16:25 <shapr> @quote Cale
00:16:25 <lambdabot>  The perfect programming language is mathematics, but that only runs on
00:16:25 <lambdabot> mathematicians.
00:17:31 * shapr is bored and doesn't feel like working
00:17:47 <Bobl> whats the best way to get the nth element of a list?
00:17:58 <shapr> !!
00:17:59 <vincenz> whoo
00:18:06 <vincenz> downloading something at 2000KB/s
00:18:11 <shapr> > [1..9] !! 5
00:18:12 <lambdabot> 6
00:18:19 <shapr> > [0..9] !! 5
00:18:20 <lambdabot> 5
00:18:22 <Bobl> shapr, thanks.
00:18:33 <neologism> what about tuples?
00:18:46 <vincenz> neologism: tuples are not indexable
00:18:50 <vincenz> neologism: you need specific functions
00:18:54 <neologism> ;(
00:18:57 <vincenz> like fst (a,_) = a
00:19:03 <shapr> Tuples are a type, so you need fst, snd for 2-tuples, and fst3, snd3, etc for 3-tuples.
00:19:24 <shapr> On the other hand, you can create generic tuple lookups with Template Haskell.
00:19:28 <shapr> Have you seen the zipN demo?
00:19:32 <neologism> no
00:19:34 * vincenz is downloading 3 files for a total of 3000Kb/s
00:19:39 <vincenz> KB even
00:19:45 <sieni> zipN demo?
00:21:09 <mathrick> shapr: Haskell has been a harsh mistress so far
00:21:22 <mathrick> I've just bumped into yet another issue
00:21:35 <shapr> Next issue of The Monad.Reader? =)
00:21:46 <mathrick> shapr: nah, basic stuff, no monads yet
00:21:51 <shapr> sieni: Yeah, liftN, zipN can all be done with Template Haskell.
00:21:51 <mathrick> I'm working with Bird, and there's this simple datatypes chapter
00:22:12 <mathrick> where he gives data Either = Left Char | Right Bool
00:22:18 <mathrick> and that's okay
00:22:19 <mathrick> however
00:22:34 <vincenz> woah
00:23:44 <mathrick> then he goes to generalise it into that:
00:23:46 <vincenz> "The Z machine is the largest X-ray generator in the world. It's designed to test materials under extreme temperatures and pressures.  It works by releasing *20* *million* *amps* of electricitiy into a vertical aray of very fine tungsten wires."
00:23:48 <mathrick> data Eeither a b = Lleft a | Rright b
00:23:48 <mathrick> Lleft :: a -> Eeither a b
00:23:48 <mathrick> Rright :: b -> Eeither a b
00:23:51 <gvdm> why would "fac 0 = 1" in hugs give me ERROR - Undefined variable "fac"
00:24:05 <gvdm> when i am trying to define it
00:24:15 <mathrick> and I'm typing it out literally how it appears in the book, and ghci errors out
00:24:24 <mathrick> /home/makat05/haskell/types.hs:7:0:
00:24:24 <mathrick>     Misplaced type signature: Lleft :: a -> Eeither a b
00:24:37 <gvdm> its like "shuddup bitch, i dont know about that function so you can't declare it"
00:24:40 <mathrick> gvdm: in interactive session?
00:24:43 <dblhelix> gvdm: you should define the function in a text editor or so and then load the resulting text file into hugs
00:24:53 <gvdm> um, i think so
00:25:01 <mathrick> gvdm: then what dblhelix said
00:25:10 <gvdm> type hugs at cmd line and have prompt
00:25:41 <mathrick> so, someone care to explain either 1) What's wrong with the code 2) What's wrong with Bird? :)
00:26:45 <mathrick> because when I was trying to understand how it's supposed to work last night, I failed, and apparently haskell shares my view
00:27:04 <shapr> mathrick: first, type signatures on constructors were not possible until recently..
00:27:13 <shapr> So that would be only explanation from Bird
00:27:18 <shapr> But, you can do it now.
00:27:25 <mathrick> shapr: ghc 6.4.1
00:27:31 <mathrick> and it fails
00:27:34 <mathrick> as I said
00:27:46 <shapr> hold on a moment...
00:27:52 * shapr cleanses his brain of Python thoughts...
00:27:56 <mathrick> heh
00:28:13 * mathrick still wishes for a real lambda in Py...
00:28:39 * neologism is about to implement Dijkstra shortest path in haskell
00:29:10 <shapr> mathrick: Simplest is data Either a b = Left a | Right b
00:29:27 <shapr> mathrick: You know about parameterized types?
00:29:42 <mathrick> I'm just learning
00:30:10 <shapr> Well, let's say you have data Thingy a = Box a
00:30:20 <mathrick> shapr: but I can see it, it's sorta like a constructor with parameters in OO languages
00:30:23 <mathrick> shapr: okay
00:30:29 <shapr> The type is Thingy, and the constructor is Box
00:30:33 <mathrick> mhm
00:30:53 <mathrick> however, why not just say Either a = Left a | Right b?
00:30:57 <mathrick> err
00:30:59 <mathrick> Right a
00:31:10 <shapr> If you had a concrete datatype that could only contain Int, you'd see data Thingyi = Boxi Int
00:31:21 <mathrick> yup
00:31:24 <shapr> and one for Float would be data Thingyf = Boxf Float
00:31:44 <shapr> But data Thingy a = Box a could be constructed to have both of those types, and a bunch more.
00:31:56 <mathrick> yeah, I have no problem with parametrised types themselves
00:31:59 <shapr> ok
00:32:09 <shapr> You know the Maybe type too?
00:32:13 <mathrick> no
00:32:20 <shapr> data Maybe a = Just a | Nothing
00:32:28 <shapr> It's mostly used to represent failure.
00:32:39 <mathrick> heh, cute
00:32:43 <shapr> Return with your shield or on it.
00:32:51 <shapr> The 'samurai principle'
00:33:00 <shapr> (ok, they didn't use shields, but ... whatever)
00:33:00 <mathrick> and how is Either used then?
00:33:28 <shapr> If you wanted to return a failure message, you could extend Maybe to return a result, or a failure.
00:33:51 <shapr> Since the result and the failure are almost definitely different types, can you guess what the entire type would look like?
00:34:41 <shapr> data Either a b = Left a | Right b
00:34:42 <mathrick> Either a b = Ok a | Failure b
00:34:47 <shapr> you got it :-)
00:35:02 <mathrick> okay, but when do the different types really come into play?
00:35:04 <shapr> By convention, right is success and left is failure
00:35:09 <mathrick> a is a variable after all
00:35:28 <mathrick> so it doesn't matter if Ok's a is different from Failure's a
00:35:38 <shapr> ?
00:35:57 <mathrick> say we have data Either a = Left a | Right b
00:36:15 <shapr> you left out the b, but yeah.
00:36:15 <mathrick> then I can say Left "asd" and Right "asd", and both are correct, right?
00:36:29 <mathrick> shapr: because I meant Right a in fact
00:36:55 <shapr> Yeah, but errors are usually String, and success results usually aren't
00:37:33 <mathrick> shapr: but how does that matter for a _formal_ parameter?
00:39:24 <mathrick> it's like saying that if I had something like that:
00:39:34 <mathrick> left :: a -> a
00:39:40 <mathrick> right :: a -> a
00:39:48 <mathrick> a's are in any way related
00:39:51 <mathrick> they're not
00:39:53 <shapr> Either usually gets concretely instantiated (constructed?) as Either String (some number type) = Left String | Right (numbertype)
00:40:02 <mathrick> they're just placeholder
00:40:43 <mathrick> shapr: eh?
00:40:57 <mathrick> could you give me a minimal bit of code that does that?
00:42:03 * shapr writes something...
00:44:32 <shapr> divOrFail     :: Float -> Float -> Either String Float
00:44:32 <shapr> divOrFail x 0 = Left "divide by zero"
00:44:32 <shapr> divOrFail x y = Right $ x / y
00:45:20 <shapr> mathrick: Makes sense?
00:45:22 <mathrick> aaaah
00:45:24 <mathrick> yes
00:45:26 <mathrick> it does
00:45:40 <mathrick> now I see the need for two type variables
00:45:41 <mathrick> thanks
00:45:50 <mathrick> Bird is sometimes really bad at explaining
00:46:10 <shapr> He's a nice guy though, he was in line in front of me at ICFP2003
00:46:24 <mathrick> maybe he's being *cough* gentle *cough* :)
00:46:25 <shapr> I was like "Hey! I've read some of your stuff, it's really cool!"
00:46:29 <shapr> And he blushed furiously
00:46:30 <mathrick> shapr: heh
00:46:45 <shapr> He got all shy, just like I do when that happens to me.
00:46:49 <shapr> I guess I didn't expect him to be a geek.
00:48:24 <mathrick> still, I'd appreciate if he gave a word of explanation when defining Either
00:48:28 <shapr> heh
00:48:42 <mathrick> I mean, it's cute to do stuff just for the sake of it, but sometimes it helps
00:48:58 <shapr> Yeah well, you have #haskell :-)
00:49:18 <shapr> I don't know if I would have made it though Thompson or Hudak without #haskell
00:49:25 <sieni> is http://haskell.readscheme.org/ dead?
00:49:38 <shapr> I got a lot of help from, dennisb, Heffalump, wli, and others.
00:49:39 <sieni> in the sense that is it actively maintaine
00:49:40 <sieni> d
00:49:41 <sieni> ?
00:50:28 <mathrick> shapr: yeah, I appreciate it
00:53:00 <mathrick> shapr: okay, so the last thing, why didn't my type signatures for Left and Right work?
00:54:07 <shapr> Because that sort of syntax only works for GADTs, and that's only been available for a few months.
00:54:28 <shapr> check this out - http://www.scannedinavian.com/~shae/haskell/
00:55:08 <mathrick> okay, so why Bird '98 does them? :)
00:56:25 <mathrick> (this is my another complain, he doesn't differentiate clearly between haskell and his notation)
00:56:34 <mathrick> s/complain/&t/
00:57:23 <Bobl> say i have a [Int] and i want to make a [(Int,Bool)] with map, so i want some function that can do Int -> (Int,Bool), but I dont want to have a helping function, i want lambda abstraction, how do i do this?
00:58:32 <sieni> > (\x -> (x, even x)) 7
00:58:33 <lambdabot> (7,False)
00:59:02 <Bobl> sieni, you are my hero! can i give you karma?
00:59:18 <Lemmih> > map (id &&& even) [1..5]
00:59:18 <sieni> I don't know :-)
00:59:19 <lambdabot> [(1,False),(2,True),(3,False),(4,True),(5,False)]
00:59:51 <sieni> >  (\x -> map (\y -> (y, even y)) x) [1..10]
00:59:52 <lambdabot> [(1,False),(2,True),(3,False),(4,True),(5,False),(6,True),(7,False),(8,
00:59:52 <lambdabot> True),(9,False),(10,True)]
01:00:01 <Lemmih> @karma+ sieni 
01:00:02 <lambdabot> sieni's karma raised to 1.
01:00:12 <sieni> ^_^
01:01:19 <sieni> > map (id &&& even &&& odd) [1..5]
01:01:20 <lambdabot> [(1,(False,True)),(2,(True,False)),(3,(False,True)),(4,(True,False)),(5,(
01:01:20 <lambdabot> False,True))]
01:13:15 <Cale> shapr: have you seen this video? http://video.google.com/videoplay?docid=-262774490184348066 -- seems like something you'd be interested in :)
01:14:25 <vincenz> is it me or is thre no sound in that video
01:14:36 <Cale> it's you
01:15:39 <vincenz> can't wait until spore is out
01:15:54 <Cale> yeah, me too
01:16:06 <vincenz> I actually ordered a book that the creator used as inspiration
01:16:55 <vincenz> At hme ine the Universe - Stuart Kauffman
01:17:00 <vincenz> At home in the Universe ..
01:18:35 <vincenz> > [1..3]
01:18:36 <lambdabot> [1,2,3]
01:18:36 <vincenz> > [1...3]
01:18:37 <lambdabot>  Not in scope: `...'
01:18:39 <vincenz> hmm
01:18:47 <vincenz> > [1..3)
01:18:47 <lambdabot>  parse error on input `)'
01:19:14 <vincenz> > [1..3] >>> filter even
01:19:14 <lambdabot> Couldn't match `a b' against `[]'
01:19:20 <vincenz> @type even
01:19:20 <lambdabot> forall a. (Integral a) => a -> Bool
01:20:11 <vincenz> no such thing as an injector for data and arrows?
01:21:44 <Saulzar> I guess it doesn't make sense, then you're returning a value not an arrow
01:22:15 <vincenz> something like the |> discussed recently
01:22:30 <Saulzar> What's that?
01:22:57 <vincenz> there was a thread on the news about some guy wanting code-reviiew and it contained a custom |> operator
01:23:29 <Itkovian> what did |> do?
01:23:32 <Saulzar> I guess you could inject a const function, but...
01:23:38 <vincenz> like $ but in the opposite sense
01:23:48 <vincenz> x |> f
01:23:53 <vincenz> so you can do x |> f1 |> f2
01:24:23 <Itkovian> that would make it even less readable imo
01:24:45 <vincenz> Itkovian: I would say that's subjective and dependent on your personal background
01:24:50 <Bobl> how would one substitute the nth element of a list?
01:25:01 <vincenz> Itkovian: people coming from oo-like languages, or with more of a dataflow view on things would find iti more readibly
01:25:04 <vincenz> readible..
01:25:16 <Itkovian> readable
01:25:20 <vincenz> right
01:25:23 <Itkovian> ;-)
01:25:33 <Cale> Bobl: normally you try to avoid that, but you can do it by building a new list out of the old in various ways
01:25:50 <Cale> splitAt is handy
01:25:51 <Bobl> Cale, such as?>
01:26:00 <vincenz> take (n-1) l ++ new:(drop (n+1) l)
01:26:08 <Cale> > splitAt 5 "Hello, World"
01:26:09 <lambdabot> ("Hello",", World")
01:26:15 <Saulzar> The people who wrote the perl cookbook redefined . like |>, I read through it and didn't realise it was haskell :)
01:26:24 <Itkovian> or let (h,x:xs) = splitAt n ys in h++(y:xs)
01:26:38 <Cale> > let (xs,(y:ys)) = splitAt 5 "Hello, World" in xs ++ ('!':ys)
01:26:39 <lambdabot> "Hello! World"
01:26:56 <Cale> yeah
01:26:56 <vincenz> > let (|>) = flip ($) in 1 |> (+2) |> (*3)
01:26:57 <lambdabot> 9
01:27:06 <vincenz> > let (|>) = flip ($) in 1 |> +2 |> *3
01:27:06 <lambdabot>  parse error on input `+'
01:27:08 <adu> ooo
01:27:30 <adu> did that just assign to a list?
01:27:41 <vincenz> adu: no it made a new one
01:28:12 <adu> k
01:29:01 <Itkovian> > let replace_n = (\n x xs -> let (h,(t:ts)) = splitAt n xs in t++(x:ts)) in replace_n 5 '!' "Hello, World!"
01:29:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:29:02 <lambdabot>   Expected type: [a]
01:29:02 <lambdabot>   Inferred type: [[a]]
01:29:03 <Saulzar> Is there any real advantage one way or another? Adding extra ways to do the same thing seems unnesescary
01:29:13 <Itkovian> erm
01:29:27 <Itkovian> > let replace_n = (\n x xs -> let (h,(t:ts)) = splitAt n xs in h++(x:ts)) in replace_n 5 '!' "Hello, World!"
01:29:27 <lambdabot> "Hello! World!"
01:30:19 <vincenz> Saulzar: referriing to me?
01:30:26 <Saulzar> Yeah
01:30:42 <saintiss> hi all
01:30:47 <vincenz> I'm using this different notation because it's more apt to some pseudocode that I'm writing in haskellish
01:31:06 <saintiss> is it possible for functions which take more than one parameter of different types, to be part of a class?
01:31:35 <saintiss> because the functions which are part of a class, like (==), all seem to be dependent on one type variable only
01:31:52 <Saulzar> It's a common extension, multi parameter type classes
01:32:16 <saintiss> Saulzar, could you give me an example where this is useful?
01:33:09 <Saulzar> Hmm, well take multiplying different types - vectors and scalars for example
01:33:10 <Bobl> i dont suppose \(x,y) -> works for lambda abstraction?
01:33:40 <Saulzar> Bobl, What do you mean? That should work fine
01:33:52 <Bobl> Saulzar, whooah, marvelous
01:33:59 <Itkovian> Bobl: sure it does, you have one argument, which happens to be a tuple
01:34:07 <Saulzar> It will pattern match the parameters like a nomal function
01:35:02 <Bobl> i am suprized how inuitive haskell syntax is.
01:35:09 <saintiss> Saulzar, then you'd have class MyMul    mult::[a]->b->[a] ?
01:35:13 <sieni> Bobl: eskimoish?
01:35:39 <Saulzar> saintiss, I guess it would be a -> b -> c
01:36:04 <vincenz> Saulzar: it's HisMul, not YourMul :P
01:37:10 <Bobl> sieni, intuitive
01:37:55 <Saulzar> saintiss, Then you might have instance MyMul Vector Double Vector  mult :: Vector -> Double -> Vector 
01:38:24 <Saulzar> saintiss, Though this is not nesescarily a great example, since c is dependant on a and b, and that's another common extension
01:38:36 <saintiss> Saulzar, ic...
01:39:07 <vincenz> anyone know a source for some opensource java games?
01:39:22 <Saulzar> Must be millions of them :)
01:39:29 <vincenz> yeah but the problem is locating one
01:39:41 <Saulzar> robocode is one
01:40:19 <vincenz> it's a coding game?
01:40:47 <Saulzar> Yeah, I guess that's not strictly a "game" ... :)
01:40:55 <vincenz> yeah that won't do :/
01:41:59 <Saulzar> What do you want it for?
01:41:59 <shapr> Silly question.. we have refrigerators to keep things cold, why don't we have hotboxes to keep things hot?
01:42:09 <vincenz> Saulzar: I need some source code drivers
01:42:18 <Saulzar> shapr, They go rotten? :)
01:42:24 <vincenz> shapr: microwave?
01:42:49 <vincenz> besides we do have them
01:42:53 <vincenz> look at the USB cupheater
01:43:00 <vincenz> or if you want passive devices, a thermos
01:43:20 <vincenz> electric blankets
01:43:54 <vincenz> baby-bottle warmers
01:43:54 <shapr> Yeah, but there's nothing that keeps items warm to a certain temperature.
01:43:56 <Itkovian> shapr: they're called ovens
01:43:58 <shapr> Not outside a lab, anyway.
01:44:04 <vincenz> shapr: baby-bottle warmers
01:44:10 <vincenz> they're stable after a certain startup
01:44:13 <shapr> Itkovian: Ovens aren't insulated like a fridge.
01:44:38 <Itkovian> no, but they do come with nice heatable stuff, like a resistance, or flaming thingies
01:44:42 <Saulzar> They're not commonly needed like a fridge?
01:44:50 <Itkovian> that too
01:44:57 <shapr> Yeah, but I wonder if the reason there's no need for an anti-fridge is because we don't have any?
01:45:06 <Saulzar> What would you use it for?
01:45:08 <mathrick> test :: Either Bool Char -> Int
01:45:09 <mathrick> test Left undefined = 10
01:45:09 <mathrick> what's wrong with that?
01:45:10 <mathrick>     Couldn't match `Int' against `t -> t1'
01:45:10 <mathrick>       Expected type: Int
01:45:10 <mathrick>       Inferred type: t -> t1
01:45:24 * mathrick is back to playing with types
01:45:28 <Itkovian> yeah, what would you do with it? If you want to heat somethin you can do it fast
01:45:43 <vincenz> Itkovian: nouvelle cuisine also quickfreezes stuff nowadays
01:45:44 <Itkovian> colling is for retaining stuff so it doesn't come crawling out of the box after a few days
01:45:48 * shapr thinks
01:45:49 <vincenz> it's a very new trend in the cooking industry
01:46:06 <vincenz> using liquid nitrogen to for instance make not icecream but ...
01:46:06 <Itkovian> vincenz: I saw a cool pic, on boinboing iirc, of a fast freezer tablet
01:46:33 <vincenz> sorbet
01:46:43 <vincenz> right, htisi guy was making sorbets with liquid nitrogen
01:46:51 <shapr> I just wonder if there's a range of foods or other things like ice cream that only become feasible when you have a hotbox.
01:47:22 <mathrick> shapr: hjælp!
01:47:25 <vincenz> or taking orange juice mixing it with some chemical, dumping this in small blobs into another chemical to get something that looks like a tiny unboiled eggyoke, except with orange juice insidie
01:47:43 <Saulzar> A fridge is for storage
01:47:54 <Itkovian> it would be nice to keep my fries hot until I get home from the fry-house
01:47:59 <vincenz> shapr: high temperatures make bacteria thrive
01:48:13 <Itkovian> bacteria are cool.
01:48:16 <Saulzar> Don't think there's any reason to keep things hot other than to grow exotic mould or bugs
01:48:30 <vincenz> Itkovian: you're watching the spore movie too much
01:48:36 <shapr> Saulzar: What about keeping bugs from growing?
01:48:52 <Itkovian> what spore movie?
01:49:00 <shapr> mathrick: test (Left undefined) = 10
01:49:06 <Saulzar> If you keep it very hot... I guess you make most foods extremely tough/inedible
01:49:07 <shapr> mathrick: You need to unpack the constructor.
01:49:20 <mathrick> ahh
01:49:32 <Itkovian> Saulzar: I like my lasagna hot.
01:49:40 <Saulzar> Not for 4 days before you eat it :)
01:49:57 <vincenz> food would taste horrible if you kept it warm for several days
01:50:07 <vincenz> all dried out...
01:50:09 <mathrick> shapr: so it takes it as two parameters instead of one parametrised without ()?
01:50:13 <Itkovian> say e.g. we have a delay when dining, and I want to keep the lasagna hot, I put my oven at 75 or 100 degrees and keep it going for a while
01:50:21 <shapr> I wonder if there are any batteries that suck in heat to recharge themselves.
01:50:33 <shapr> mathrick: huh?
01:50:36 <Saulzar> Itkovian, Yeah and that works fine..
01:50:39 <Itkovian> shapr: your brain goes where I cannot follow dude
01:50:56 <Itkovian> let's get back to this Haskell thingie you may have heard of
01:50:59 <mathrick> shapr: I mean, what do you mean by "unpack", and what exactly do ()'s change?
01:51:21 <shapr> Itkovian: 1) refigerators are useful so 2) why wouldn't the other extreme be useful? Or how could it be useful?
01:51:37 <Itkovian> i know, but my brain can't fanthom anything useful for it
01:51:51 <Itkovian> and I think you may have a few things that are bubling upwards
01:52:00 <shapr> mathrick: You can pattern match on a constructor and assign names to the values inside.
01:52:37 <shapr> mathrick: For example, fromJust (Just x) = x
01:52:58 <shapr> and fromJust _ = error "fromJust should never get a Nothing!"
01:53:30 <mathrick> shapr: yes, I mean, why doesn't fromJust Just x = x work? That's because Just x without parentheses is not recognised as a constructor, right?
01:53:41 <shapr> yup
01:54:01 <shapr> Itkovian: Maybe it's not useful, but I like to look at the possibilities.
01:54:21 <eivuokko> Biggest reason, I guess, for not keeping food warm long is that water in (or around) it will cause the food lose it's cohesion, which tends to make it uglier and after certain point lose taste; unless water runs out and food dries up. (As an answer to 2))
01:54:23 <Itkovian> fromJust Just x == (fromJust Just) x in the lexical analysis afaik
01:54:30 <mathrick> okay, so next thing :)
01:54:32 <shapr> Lots of times I learn something new, and then I can come back to a stopped idea like "why not a hotbox" and suddenly see ways it could be useful.
01:54:43 <mathrick> test2 :: (Int, Int) -> Int
01:54:43 <mathrick> test2 (undefined, undefined) = 10
01:54:43 <mathrick>     Conflicting definitions for `undefined'
01:54:43 <mathrick>     In the definition of `test2'
01:54:56 <shapr> eivuokko: Ok, so... what increases its cohesion or gets more attractive when under long term heat?
01:55:11 <Itkovian> mathrick: you need unique parameter names
01:55:19 <mathrick> ahh
01:55:26 <shapr> A hotbox would be great for continually purifying water.
01:55:29 <mathrick> right, I'm stupid, you can't match on undefined
01:55:33 <Itkovian> or when not caring you use _
01:55:58 <mathrick> Itkovian: I meant the actual undefined value (ie, "the bottom")
01:56:00 <Saulzar> shapr, I think only very specific things, so they exist on their own...
01:56:04 <Itkovian> ok
01:56:04 <shapr> If fractioning were often done at home, a hotbox would be nice.
01:56:08 <mathrick> which is undoable obviously
01:56:27 <shapr> Oh, here's an idea...
01:56:45 <vincenz> shapr: a hotbox would make bacteria thrive unless you put it at > boiling temp in which case you wouldn't have water in it
01:56:47 <shapr> Oil fields get lots of natural gas when they get the oil.
01:57:21 <shapr> Maybe you could make natural gas and other unrefined outputs profitable if people refined their own at home?
01:57:44 <Saulzar> Surely not in a general purpose hot box...
01:57:44 <shapr> Right now natural gas is just burned as it comes out of the pump. Seems pretty stupid to me.
01:58:07 <shapr> You could at least make natural gas generators that sit on top of the pump and sell electricity to the grid.
01:58:23 <Saulzar> Doesn't seem like something for the kitchen :)
01:59:04 <shapr> Hm, there are chemical means to increase fractioning at low temperatures... but you have a point.
01:59:37 <shapr> Homes aren't constructed with value in mind, sadly.
02:01:34 <earthy> shapr: ISTR that Shell is currently investigating transforming the natural gas into diesel
02:01:44 <shapr> Neato - http://pobox.com/~oleg/ftp/rss.xml
02:01:54 <Itkovian> it seems stupid to burn up the coolest resource we have
02:02:02 <Itkovian> but hey, that's humankind
02:02:04 <earthy> yup, more cool stuff from oleg
02:02:19 <shapr> On the other hand, we have lots of totally free energy available.
02:02:36 <mathrick> test _ = 5
02:02:36 <mathrick> *Main> test undefined
02:02:36 <mathrick> *** Exception: Prelude.undefined
02:02:38 <mathrick> huh?
02:02:45 <mathrick> why is that?
02:02:49 <mathrick> ah, I know
02:03:02 <Cale> shouldn't be unless you defined test some other way
02:03:22 <Cale> Prelude> let test _ = 5
02:03:22 <Cale> Prelude> test undefined
02:03:22 <Cale> 5
02:03:27 <shapr> Any place where the outside temperature passes the inside temperature during daily temperature changes could easily use thermocouples and batteries...
02:03:35 * shapr is wayy off topic
02:03:48 <mathrick> test :: Either Bool Char -> Int
02:03:48 <mathrick> test (Left _) = 10
02:03:48 <mathrick> test (Right x)
02:03:48 <mathrick>     | x == 'a' = 7
02:03:48 <mathrick> test _ = 5
02:03:53 <mathrick> this is the full def
02:04:02 <Cale> ah
02:04:17 <Cale> it has to evaluate undefined to try to pattern match
02:04:20 <mathrick> I'm trying the excersise "make test behave differently on (Left undef) (Right undef) and undef"
02:04:37 <Cale> (it does so only as far as needed)
02:04:46 <mathrick> fully wrapping your head around the type system is a bit difficult :)
02:05:14 <Itkovian> shapr: true and true
02:05:14 <shapr> Yeah, it was rough at first. I like it lots now.
02:05:37 <Cale> well, I'd count being undefined on undefined as different, so long as it's actually defined on the other two :)
02:05:48 <mathrick> okay, so I can make it do something on (Right undef), but I can't make it be undefined
02:05:56 <mathrick> Cale: yeah, that's what I wanted to do
02:06:02 <mathrick> but now I see it's impossible
02:06:32 <Cale> test (Left _) = 1
02:06:36 <Cale> test (Right _) = 2
02:07:19 <Cale> that'll work for Left and Right undefined, but of course, not for undefined
02:07:20 <flux__> can the compiler warn from that code that test _ = 5 is unreachable?
02:07:33 <mathrick> it does
02:08:01 <mathrick> but it is, in fact, reachable
02:08:03 <flux__> oh, hm, actually is it, I didn't notice the guard?
02:08:06 <mathrick> silly compiler
02:08:20 <Cale> with some really unsafe functions, you can catch the error and make it return something different :)
02:08:31 <mathrick> test :: Either Bool Char -> Int
02:08:31 <mathrick> test (Left _) = 10
02:08:31 <mathrick> test (Right _) = 7
02:08:31 <mathrick> test _ = 5
02:08:31 <mathrick>     Warning: Pattern match(es) are overlapped
02:08:32 <mathrick> 	     In the definition of `test': test _ = ...
02:08:33 <vincenz> talkl about SERVICE!!!!!
02:08:54 <mathrick> Cale: heh, no abusing of the real world property :)
02:08:59 <Cale> hehe
02:09:19 <vincenz> I just got a call from my mobile phone operator.... "based on the last three months we see that you could use this different formula which is much cheaper"
02:09:53 <mathrick> vincenz: now it remains to see if it really is :)
02:10:07 <flux__> mathrick, hm, it works right with me, no warning if there's a guard
02:10:20 <flux__> and if there's no guard, it is correct
02:10:25 <flux__> the code is unreachable
02:10:38 <vincenz> mathrick: I barely call... and now it's fixed 15 euro/month, new one would be5 euro/month for 17 minutes (which so far I haven't surpassed)
02:10:46 <Cale> much more profitable for us^W^W^W^W cheaper
02:11:09 <Cale> ah, possibly then
02:11:28 <vincenz> yeah I'm amazed at the trouble they undergo
02:12:10 <mathrick> flux__: what guard are you using?
02:12:12 <vincenz> (after the 17 mins it's 20 c/minute... so I'd have anther 50 minutes to call before surpassing my current expenses :P)
02:12:53 <Cale> I had some phone company call me when I was in residence at university with a "better deal". Seeing as I never made any long distance calls (my parents gave me a card to call them with), and my local phone service came with the room, well...
02:13:09 * mathrick passes vincenz a Compose, a € and ¢ ;)
02:14:02 <flux__> mathrick, | False
02:14:14 <vincenz> mathrick: 
02:14:16 <vincenz> ?
02:14:54 <mathrick> vincenz: nothing, just that with compose key you can type out a proper euro sign even if you don't have it mapped in your keyboard layout
02:14:59 <flux__> (I wouldn't expect it to be so smart that it would consider the guards themselves)
02:15:20 <mathrick> flux__: hmm, but | False is never gonna match, so what's the point?
02:15:30 <flux__> the point is that it's a guard
02:15:38 <vincenz> mathrick: what is a compose key
02:15:41 <mathrick> I think I don't get it, can I see the full code?
02:16:08 <mathrick> vincenz: a key which serves as a kind of "universal dead key", and thus Compose + e + = == €
02:16:18 <flux__> the point was that the compiler can consider the completeness of the function only if no guards are being used
02:16:22 <vincenz> I don't have that key on my keyboard
02:16:22 <mathrick> similarly, Compose + c + | == ¢
02:16:26 <flux__> because guards can be much more complex than just pattern matching
02:16:32 <mathrick> vincenz: running unix?
02:16:32 <Cale> vincenz: you can map one
02:16:36 <vincenz> mathrick: and that comes out as ï¿½
02:16:40 <vincenz> mathrick: yah
02:16:46 <vincenz> aka the cent is not displaying correctly
02:16:49 <vincenz> I get three symbols
02:16:57 <mathrick> then you're not using utf-8
02:16:58 <vincenz> an i with double dot, an inverted ? and a 1/2 character
02:17:24 <Cale> vincenz: perhaps you're not using utf-8 encoding. What irc client do you use. I know how to coerce X-Chat into it :)
02:17:25 <vincenz> gnome-terminal
02:17:29 <vincenz> screen
02:17:30 <vincenz> and irssi
02:17:38 <mathrick> vincenz: it's usually not mapped, but I mapped it to CapsLock
02:17:46 <vincenz> and synergy
02:17:50 <Cale> hmm, perhaps it would be sufficient to configure gnome-terminal to use UTF-8
02:18:00 <mathrick> Cale: it's in that mode by default...
02:18:14 <mathrick> unless your distro does strange things and uses non-utf-8 locale
02:18:16 <mathrick> which is silly
02:19:04 <vincenz> hmm
02:19:15 <vincenz> ok, this is gnome-terminal on ubuntu (the other is on my desktop which is fedoracore)
02:19:33 <vincenz> here I see the cent as a small diamond
02:19:34 <mathrick> then it uses utf-8
02:20:03 <mathrick> vincenz: try /charset utf-8
02:20:10 <vincenz> with something else inside of it but barely legible  (looks like a really tiny black question mark inside the white diamond, but the white diamond is barely 7 pixels wide
02:20:10 <mathrick> many clients recognise that command
02:20:19 <vincenz> mathrick: it's irssi
02:20:30 <mathrick> vincenz: then it's "unknown glyph" generic character
02:20:44 <Saulzar> Hmm, is there a simple lib for loading/saving standardish config files? Or easiest to just read/write text files directly?
02:21:11 <mathrick> vincenz: /charset will work with irssi
02:21:20 <vincenz> mathrick: nope
02:21:28 <mathrick> how so?
02:21:42 <vincenz>  Irssi: Unknown command: charset
02:21:55 <mathrick> which version?
02:21:55 <vincenz> anyways yes I get the unknown glyph thingy, I checked in another font, white diamond with black ?
02:22:10 <vincenz> 0.8.10
02:22:12 <mathrick> (you don't reply to CTCP VERSION)
02:22:17 <vincenz> nope
02:22:18 <mathrick> vincenz: then it's there :)
02:22:25 <mathrick> ah, perhaps you need recode installed
02:22:27 <Cale> Saulzar: hmm...
02:22:37 <vincenz> 0.8.10-rc5
02:22:38 <mathrick> but I thought it's included in default distribution in 0.8.10
02:23:12 <Cale> Saulzar: something suitably generic could possibly be done with Data.Dynamic and Data.Map
02:24:42 <Cale> there's sort of the problem that you have to remember the types of your keys in order to extract them, so any such tool would involve fromDyn/fromDynamic
02:25:02 <Cale> (at the usage level, not behind the scenes)
02:25:19 <Saulzar> Hmm.
02:25:43 <Cale> but writing a parser/printer for a custom file format is not hard
02:25:55 <Cale> if you really like XML, there are some XML libraries too
02:26:12 <Cale> also, if you have only a limited number of types of data in your config
02:26:29 <Cale> you can create a suitable tagged union type with default Read/Show instances
02:26:39 <Cale> and have a Map of values of those
02:27:00 <Cale> and you can just show/read that
02:27:23 <Saulzar> Hmm, that would be a piece of cake - bit of a hack I guess :)
02:27:53 <vincenz> mathrick: so how do I use compose?
02:28:03 <Cale> I suppose it all depends on how much trouble you want to go to :)
02:28:03 <vincenz> I can bind it to my windows key :P
02:28:14 <Cale> vincenz: I bound it to caps-lock :)
02:28:21 <Saulzar> Yeah, not much. Only have very simple options
02:28:22 <vincenz> Cale: how?
02:29:26 <mathrick> vincenz: open keyboard preferences
02:29:28 <Cale> Desktop -> Preferences -> Keyboard -> Layout Options -> Miscellaneous compatibility options -> Caps Lock is Compose
02:29:31 <Cale> in gnome
02:29:35 <mathrick> and in "layout options" tab I think
02:29:47 <vincenz> aha!
02:29:55 <mathrick> Compose should really be bound by default
02:29:56 <vincenz> Menu = windows button?/
02:30:08 <mathrick> vincenz: no, the Menu button :)
02:30:09 <vincenz> "Menu is Compose"
02:30:13 <vincenz> mathrick: which button is that
02:30:20 <mathrick> to the right of right win-key
02:30:25 <vincenz> Fn?
02:30:30 <vincenz> oh..Alt
02:30:32 <mathrick> laptop?
02:30:35 <vincenz> yep
02:30:37 <Cale> not Alt
02:30:59 <mathrick> it usually has a little box looking somewhat like a menu with pointer on it
02:30:59 <vincenz> [Ctrl][Fn][Windows][Alt][Space][Alt][Ctr;]
02:31:03 <vincenz> that's the bottom row
02:31:09 <Cale> http://www.pcguide.com/ref/kb/layout/z_011139win.jpg
02:31:11 <mathrick> you don't have Menu then
02:31:12 <vincenz> mathrick: ah I see it
02:31:15 <vincenz> mathrick: it's all the way at the top
02:31:19 <mathrick> okay
02:31:34 <mathrick> I personally find it a good way to kill CapsLock
02:31:51 <vincenz> damn synergy doesn't like that
02:32:05 <mathrick> I only need to convince it to bind capslock function to Ctrl + Caps
02:32:52 <vincenz> is there a visual map somewhere?
02:33:10 <mathrick> define?
02:33:23 <vincenz> somewhere to see what different buttons would do with the compose key
02:33:26 <vincenz> besides trying em all out
02:33:29 <mathrick> ah
02:33:34 <mathrick> vincenz: no, but there's a listing
02:33:42 <mathrick> visual would be impossible
02:33:48 <vincenz> not really
02:34:02 <vincenz> it's [Compose][key][key]
02:34:16 <vincenz> partition nicely on the first key, show a keyboard layout once you hit the second key
02:34:31 <vincenz> (err, riight before that is)
02:35:28 <mathrick> vincenz: it has thousands of combinations
02:35:33 <mathrick> would be really hard
02:36:38 <vincenz> hmm
02:36:38 <vincenz> ok
02:37:37 <mathrick> /usr/X11R6/lib/X11/locale/<locale>/Compose
02:37:43 <mathrick> that's the list
02:38:10 <vincenz> doesn't exist :/
02:38:23 <vincenz> only have common under /locale not any <locale> and under that it's just libs
02:39:42 <mathrick> then look in common
02:39:52 <vincenz> only libs
02:40:09 <vincenz> aha, usr share
02:43:08 <saintiss> could anyone tell me why the implementation of (..) is not in prelude?
02:43:20 <saintiss> I would expect it to appear as a method of Enum
02:43:29 <vincenz> saintiss: it's syntactical sugar
02:43:45 <vincenz> @pl \x y -> [x..y]
02:43:46 <lambdabot> enumFromTo
02:44:08 <mathrick> annoying enough, Compose + o + - == Compose + o + ~ == õ, instead of o with a macron
02:44:10 <vincenz> saintiss: in that sense it's not a proper operator
02:44:14 <vincenz> cause the full syntax is [a..b]
02:44:15 <vincenz> not a..b
02:45:21 <saintiss> vincenz, ah, ic...
02:48:37 <saintiss> vincenz, ok, and these "..." in prelude signify something is done in C?
02:49:05 <vincenz> context?
02:51:06 <saintiss> instance Enum Int where
02:51:06 <saintiss>   
02:51:06 <saintiss> ...
02:51:12 <saintiss> vincenz, something like that is in prelude
02:51:29 <saintiss> I would expect to see a definition of fromEnum there for example, but I just see "..."
02:51:35 <vincenz> I guess so, don't know, I would think that's compiler dependentn
02:51:40 <vincenz> and I haven't looked at the prelude
02:51:53 <vincenz> however instance Enum Int is trivial 
02:51:58 <vincenz> @type fromEnum
02:51:58 <lambdabot> forall a. (Enum a) => a -> Int
02:53:24 <saintiss> ok thanks
02:59:46 <araujo> morning!
03:14:53 <swiert> which real world applications are written in Haskell (besides darcs, pugs, and ghc)?
03:15:40 <Lemmih> What's a real world application?
03:16:22 <swiert> Perhaps I should add a bit of context. I need some good examples of applications written in Haskell for a talk I'm preparing.
03:16:23 <flux__> someone besides programming language -folk might know about it, and even use?-)
03:16:29 <jethr0> http://haskell.org/haskellwiki/Haskell_in_practice
03:16:30 <Esch> i'm sure that you get this a lot, but i'm having trouble conceptualizing how to solve something in haskell (a tic tac toe game, to be specific)
03:16:31 <Lemmih> hmp3 is pretty useful but definitely a lot smaller than darcs, pugs and ghc.
03:16:37 <Esch> and yes, this is unfortunately for a class
03:16:55 <jethr0> Esch: where are you stuck?
03:17:02 <Esch> i'm not looking for the answer, of course; i just don't really know where to start
03:17:33 <jethr0> Esch: one important "step" is the board representation. how would you do that in another language?
03:17:33 <Esch> i have these two lists, one for each player, containing pairs of coordinates defining moves
03:18:01 <Esch> i'd probably use a 2d array and just scan it for winning moves; actually, all i need to do is find a winning move, given some set of previous moves
03:18:08 <Esch> (for the second player, that is)
03:18:20 <jethr0> k, you can use an array in haskell as well
03:19:02 <jethr0> board = listArray ((1,1),(3,3)) (repeat Nothing)
03:19:47 <jethr0> this creates a 2d array with indices 1 to 3 inclusive, and initially all field are filled with "Nothing" :)
03:19:55 <Esch> and then you'd suggest populating that with the move information, i assume?
03:20:12 <Esch> hum, heh, i think i really need to actually consider how i'm going to solve this in any language before i try to write it out in haskell
03:20:15 <jethr0> next question is how you'd represent the "stones" on the board
03:20:44 <jethr0> do you know about "Maybe"?
03:21:00 <Esch> i'm not familiar with it, no; we had kind of a crash course in haskell over the course of a week or so
03:21:07 <Esch> (just did prolog last week, heh)
03:21:24 <Esch> i'm assuming it can be nothing or a value, though
03:21:32 <jethr0> k. "Maybe a" is a union type, that's either "Nothing" or "Just a"
03:22:02 <jethr0> yes, so an empty field could be represented by Nothing, an X by "Just X" and an O by "Just O"
03:22:15 <Esch> i see, interesting
03:22:24 <jethr0> with "data Player = X | O deriving (Show,Eq)"
03:22:53 <araujo> swiert, talk about hashell!!
03:22:55 <araujo> ;-)
03:23:13 <jethr0> the last part defines a union type that is either "X" or "O" and instance can be compared for equality and show'n
03:23:33 <Esch> ah, so deriving is like "implements" in something like java?
03:23:35 <mathrick> (+) :: Nat -> Nat -> Nat
03:23:36 <mathrick> (+) m Zero = Zero
03:23:36 <mathrick> (+) m (Succ n) = Succ (m + n)
03:23:36 <mathrick>     Ambiguous occurrence `+'
03:23:36 <mathrick>     It could refer to either `Main.+', defined at /home/makat05/haskell/types.hs:23:0
03:23:38 <mathrick> 		          or `GHC.Num.+', imported from Prelude at Implicit import declaration
03:23:42 <mathrick> how do I deal with that?
03:24:07 <jethr0> Esch: yes, but it also automatically makes a default instance. so it's rather like extends. but "implements" is by far the better analogy :)
03:24:17 <Esch> also, | binds more strongly than deriving, apparently?
03:24:23 <swiert> araujo thanks, jethr0's link provided plenty of inspiration.
03:24:26 <jethr0> yes
03:24:27 <liyang> mathrick: import Prelude hiding ( (+) )
03:24:41 <jethr0> Esch: what would you have to solve next?
03:25:05 <Esch> ok...so i have some board; i'd need to populate it with X and O values based on the two lists i have
03:25:18 <mathrick> liyang: okay, and can't I just define my (+)? When I operate on Nat's, it should be pretty obvious I'm not referring to GHC.Num.+
03:25:30 <Esch> walking the board for solutions seems like it's going to be difficult
03:25:32 <jethr0> oh, and to "change" the array, you can do "newArray = oldArray // [((1,1), Just O)]"
03:25:45 <Esch> what is the '//'?
03:25:50 <cpatrick> mathrick: can't you make Nat an instance of Integral?
03:25:55 <mathrick> liyang: because hiding it will prevent me from using normal +, right?
03:26:15 <mathrick> cpatrick: dunno, I want to try that approach first
03:26:16 <jethr0> it's for substitution i guess. it applies all "moves" in the second list to the array, substituting what was there before
03:26:19 <cpatrick> mathrick: also, haskell's scope doesn't work on "pretty obvious" (unfortunately)
03:26:29 <jethr0> Esch: you really don't want to iterate over the array.
03:26:35 <mathrick> cpatrick: heh, unfortunately
03:26:48 <jethr0> rather you want to fetch the rows, cols, diags separately and then do some haskell magic on those lists
03:27:03 <Esch> hum, also, my interpreter isn't liking listArray
03:27:11 <jethr0> "import Data.List"
03:27:19 <jethr0> sry
03:27:28 <Esch> ah...import, that seems important to know, heh; i had no idea
03:27:36 <jethr0> Esch: which interpreter?
03:27:47 <cpatrick> Esch: lambdabot's @index is also handy
03:27:49 <cpatrick> @index listArray
03:27:50 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
03:28:01 <cpatrick> @hoogle listArray
03:28:01 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i
03:28:01 <lambdabot> e
03:28:01 <lambdabot> Data.Array.listArray :: Ix i => (i, i) -> [e] -> Array i e
03:28:01 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] ->
03:28:01 <lambdabot> m (a i e)
03:28:18 <Esch> do i do that inside the module declaration or outside, by the way?
03:28:22 <Esch> the import, that is
03:28:26 <cpatrick> inside
03:28:33 <jethr0> Esch: gotta go urgently. but these nice gentlemen (and ladies) will certainly help you further :)
03:28:40 <Esch> ah, thanks for the help thus far
03:28:54 <mathrick> *Main> (mkNat 10) + (mkNat 2)
03:28:54 <mathrick> Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))))))
03:28:55 <liyang> mathrick: until you get around to implementing (-), (*), negate, abs, signum and fromInteger, that's prolly about the best solution provided you insist on using the (+) name. :)
03:29:12 <mathrick> fun, but I don't have 10 + 5 anymore
03:29:14 <mathrick> liyang: eh
03:29:24 <mathrick> liyang: can I define only some of them?
03:29:28 <mathrick> or will that fail?
03:29:30 <liyang> (because then you can make it an instance of Num.)
03:29:37 <Esch> anyone happen to know why it's complaining about "import Data.List"? it says "import" is an unexpected keyword
03:29:40 <cpatrick> mathrick: well, you can define some of then to be uselessy
03:29:46 <cpatrick> like `negate x = undefined`
03:29:47 <mathrick> right
03:30:11 <cpatrick> Esch: could you paste your code somewhere?
03:30:12 <cpatrick> @paste
03:30:12 <lambdabot> http://www.haskell.org/hawiki/HaskellIrcPastePage
03:30:45 <cpatrick> Esch: but it should be something like module Foo where \n import Data.List \n ... your code here ...
03:30:46 <Taral> @seen dons
03:30:47 <lambdabot> dons is in #haskell. Last spoke 4 hours, 12 minutes and 27 seconds ago.
03:30:50 <Taral> meh
03:31:00 <liyang> mathrick: For something that really doesn't fit the Num class, I'd just use a different infix operator. (|+|) for example.
03:31:03 <Esch> that's what i have, yes; one second, i'll paste it up
03:31:14 <Taral> @ping dons
03:31:15 <lambdabot> Not in scope: type variable `dons'
03:31:18 <Taral> ??
03:31:35 <Esch> http://rafb.net/paste/results/HAhOkg61.html
03:32:12 <Lemmih> Taral: You can't ping people who aren't in scope. tsk tsk.
03:32:23 <Taral> lol
03:32:34 <Esch> also, i've tried saying "clone :: (a -> Num) -> [a]" for a function that takes any type and a number as two arguments and results in a list of the first type, but my module complains that "Num" is an undefined constructor (this is a different problem, by the way)
03:32:57 <Taral> clone :: Num b => (a -> b) -> [a]
03:33:02 <Taral> but I think you want
03:33:06 <Taral> clone :: Num b => a -> b -> [a]
03:33:21 <Esch> ah, interesting, alright; what's the syntactic meaning of '=>'?
03:33:36 <cpatrick> well, the two of Taral's definitions are equivalent
03:33:40 <Taral> nope
03:33:44 <Esch> i understand that -> is related to currying of arguments somehow...
03:33:49 <Taral> -> is right associative
03:33:55 <Taral> a -> b -> [a] == a -> (b -> [a])
03:34:03 <cpatrick> ah, of course
03:34:05 * cpatrick slaps self
03:34:15 <Taral> the other one is a function "clone" that takes *one* argument, a function from a to b.
03:34:29 <Taral> -> is just a function
03:34:30 <Esch> interesting, right
03:34:50 <Taral> a function of two arguments is really represented (via currying) as a function that takes an argument and returns (a function that takes an argument and returns a result)
03:35:22 <mathrick> liyang: well, Nat's are supposed to be natural numbers :)
03:36:01 <mathrick> instance Num Nat where
03:36:01 <mathrick> (+) m Zero = m
03:36:01 <mathrick> (+) m (Succ n) = Succ (m + n)
03:36:01 <mathrick>     Warning: No explicit method nor default method for `GHC.Num.+'
03:36:01 <mathrick> 	     In the instance declaration for `Num Nat'
03:36:03 <mathrick> huh?
03:36:07 <Esch> hum, listArray apparently is still an undefined variable, even after importing Data.List
03:36:51 <Lemmih> @index listArray
03:36:51 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
03:36:55 <liyang> mathrick: right. And Num a => a are supposed to be things that have additive inverses. So in my opinion it's one of those things that do not fit. :)
03:37:01 <Lemmih> Esch: You need Data.Array
03:37:05 <Taral> mathrick: is that indented?
03:37:05 <liyang> mathrick: indentation?
03:37:08 <Taral> heh
03:37:08 <liyang> :)
03:37:18 <mathrick> oh
03:38:00 <mathrick>     `+' is not a (visible) method of class `Num'
03:38:03 <mathrick> orly?
03:38:20 <Taral> heh
03:38:28 <Taral> weird
03:39:03 <liyang> mathrick: paste?
03:39:25 <jethr0> Esch: sry, i'm a moron. i meant Data.Array
03:39:30 * jethr0 kicks himself in the groins
03:39:30 <Taral> mathrick: works for me
03:39:53 <Taral> data Nat = Zero | Succ Nat
03:39:53 <Taral> instance Num Nat
03:39:53 <Taral>   (+) m Zero = m
03:39:53 <Taral>   (+) m (Succ n) = Succ (m + n)
03:40:01 <Taral> z.hs:2:0:
03:40:01 <Taral>     No instances for (Show Nat, Eq Nat)
03:40:05 <Taral> which is what you'd expect.
03:40:09 <Esch> i'm also trying to get this to work, with poor results: http://rafb.net/paste/results/cRpSl378.html
03:40:23 <Esch> i keep getting "Cannot justify constraints in explicitly typed binding" on the line where clone is defined
03:40:37 <Esch> jethr0: heh, no problem
03:40:52 <Esch> i should probably work on one thing at a time
03:41:00 <jethr0> Esch: what's is say?
03:41:08 <jethr0> > replicate 5 "x"
03:41:09 <lambdabot> ["x","x","x","x","x"]
03:41:12 <cpatrick> Esch: you probably want "clone x (n-1)"
03:41:35 <mathrick> Taral: humm
03:41:37 <Taral> @type replicate
03:41:38 <lambdabot> forall a. Int -> a -> [a]
03:41:38 <jethr0> making it "x : clone x (n-1)"
03:42:07 <Taral> @type flip (replicate . fromIntegral)
03:42:08 <lambdabot> forall a b.
03:42:08 <lambdabot>             (Integral a) =>
03:42:08 <lambdabot>             b -> a -> [b]
03:42:30 <Esch> aha, yes, surrounding that in parentheses did work
03:44:00 <cpatrick> clone n x = [x | i <- [1..n]] is neater. though probably not desirable if this is an assignment in learning recursion et al
03:44:07 <jethr0> > let f a o b = a o b in f 4 - 3
03:44:07 <lambdabot>  add an instance declaration for (Num (t -> t1 -> t2))
03:44:14 <jethr0> > let f a o b = a o b in f 4 (-) 3
03:44:15 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
03:44:40 <Taral> > let f a o b = o a b in f 4 (-) 3
03:44:41 <lambdabot> 1
03:44:52 <Taral> > let f a o b = a `o` b in f 4 (-) 3
03:44:53 <lambdabot> 1
03:45:05 <Esch> ah, well, i think i can do it in any way, as long as it works
03:45:12 <jethr0> cpatrick: that's evil. it's somewhere on the dont-do-it-page in the wiki. "replicate n x" is definitely the way to go
03:45:14 <Esch> that just seemed to be the clearest to me after prolog
03:46:03 <Esch> jethr0: any suggestions about the next step for tic tac toe, by any chance? sorry to jump around between topics like this
03:46:27 <jethr0> well, extracting rows,cols,diags from the array
03:46:27 <Esch> also, i'm quite obliged to you all, teaching me what my university course should have taught me
03:47:12 <jethr0> the array function "assocs" gives you all array elements _with_ indices
03:47:28 <jethr0> filtering on that, you can easily get rows,cols and diags
03:49:56 <Esch> i'm not familiar with assocs...you'd use that directly on the board?
03:50:54 <jethr0> yes
03:51:11 <shapr> Cale`: Have you seen the bi-arrows paper? It's neat.
03:51:11 <jethr0> assocs $ listArray ((1,1),(2,2)) (repeate (Nothing :: Maybe Player))
03:51:27 <jethr0> *repeat
03:51:45 <Esch> also, this is going to sound kind of dumb, but i'm not sure how to do several comamnds at once
03:51:47 <shapr> You've been looking at JHC too much :-)
03:51:50 <Esch> also, what is the '$'?
03:52:15 <shapr> $ is low precedence function application.
03:52:17 <cpatrick> it's function application
03:52:20 <cpatrick> f $ x = f x
03:52:21 <shapr> It can be used to replace parens.
03:52:24 <cpatrick> but it lets you avoid brackets
03:52:33 <shapr> Yeah, what cpatrick said :-)
03:52:40 <cpatrick> Also what shapr said ;-)
03:52:42 <Esch> hum, i see, thanks
03:52:51 <jethr0> f $ g x = f (g x)
03:53:18 <musasabi> when looking at things from jhc it seems that most Haskell libraries use nonstandard things with abandon.
03:53:21 <shapr> f g x is (f g) x
03:53:34 <Esch> right, i'm starting to understand the difference, heh
03:53:48 <cpatrick> musasabi: yeah, it's too easy to assume that Haskell == GHC.
03:53:52 <Esch> so if you used $ exclusively, you'd basically be reversing the normal function association order?
03:53:57 <cpatrick> on the other hand, that may be a tribute to GHC's awesomeness :-)
03:54:39 <jethr0> Esch: no
03:55:09 <jethr0> and shapr's example is wrong
03:55:13 <shapr> oops
03:55:19 <shapr> teach me!
03:55:37 <jethr0> since when is "f g x" == "(f g) x"?
03:56:09 <jethr0> well, ok with currying maybe. but it's mighty confusing
03:56:11 <liyang> function application is left-associative?
03:56:13 <shapr> Well.. I was thinking like lambda calculus, where multiple args are done with a single arg returning a new function.
03:56:33 <Itkovian> jethr0: f g x is always (f g) x imo
03:56:35 <shapr> But hey, maybe I'm just totally wrong... happens to me often enough.
03:56:35 <mathrick> what is signum supposed to return?
03:56:39 <mathrick> @type signum
03:56:40 <lambdabot> forall a. (Num a) => a -> a
03:56:41 <Esch> right, function application is left associative...hum...
03:56:46 <liyang> They made me learn it in kindergarten!
03:56:51 <jethr0> i apologize. shapr's example isn't wrong, but confusing
03:56:51 <Esch> anyhow, on to actually populating the board
03:56:56 <liyang> I had to write it out hundreds of times...
03:57:01 <shapr> jethr0: Unconfuse us please!
03:57:10 <jethr0> shapr: are you being sarcastic?
03:57:13 <Esch> can you use ; to do two things in one function, just out of curiosity?
03:57:20 <shapr> The lazy man's way to learn, state something wrong or confusing, and get others to fix it for you ;-)
03:57:25 <Esch> i don't think he is; i think he genuinely wants to know, heh
03:57:34 <mathrick>     signum Zero = Zero
03:57:34 <mathrick>     signum n = Succ Zero
03:57:35 <shapr> jethr0: Nah, I think I"m sarcastic about once a year, when someone really angers me.
03:57:37 <mathrick> is that correct?
03:57:39 <jethr0> shapr knows haskell longer and better than me
03:57:47 <shapr> jethr0: Not better in anything
03:57:51 <Taral> @time dons
03:57:52 <shapr> This channel humbles me often
03:57:53 <lambdabot> Local time for dons is Thu Mar  9 22:57:54 2006
03:58:13 <liyang> mathrick: it /will do/, I guess.
03:58:20 <shapr> jethr0: You and I may know different stuff, but I guarantee you know stuff I wish I knew :-)
03:58:47 <Taral> you people are all very silly
03:58:50 <Taral> nini everyone
03:58:53 <shapr> Ni!
03:58:55 <jethr0> nm, i won't critizise so lightly again. shapr was right i was wrong ;-)
03:59:00 <liyang> mathrick: better, instead of the second case, is to write signum (Succ _) = Succ Zero
03:59:16 <shapr> jethr0: Bah, if you think you know something, jump in! People here rarely get offended.
03:59:24 <jethr0> hehe
03:59:32 <shapr> I try to check stuff before I say it, but past that, I'm just flagrantly ... something.
03:59:42 <Esch> so, say that i want to make a function populate that takes my two lists and fills out some input board
03:59:43 <jethr0> aren't we all
03:59:43 <liyang> mathrick: That way your cases are disjoint, which makes life easier should you need to prove anything about it.
04:00:16 <shapr> How can I learn, if I do not expose my ignorance to those who can teach me?
04:00:27 <jethr0> Esch: if are sure that the moves are all valid, you can just concatenate them and do a single (//)
04:00:51 <Esch> how would i know which squares to make X and which to make O, then?
04:00:59 <jethr0> Esch: "newBoard = oldBoard // [all moves of form ((1,1), Just X)]
04:01:14 <jethr0> it's symmetrical :)
04:01:21 <shapr> hiya jewel, how's code?
04:01:24 <jethr0> lookup which one begins after the "official" rules
04:01:25 <Esch> ah, huh, interesting
04:01:59 <jethr0> alternatively you could write a function that does a single move and apply that N times on the board
04:02:15 <astrolabe> Is someone programming a game?
04:02:20 <jewel> hey shapr, sorry I have to go
04:02:23 <astrolabe> Good afternoon all
04:02:31 <shapr> bye jewel 
04:02:33 <shapr> hiya astrolabe 
04:03:21 <astrolabe> Hi shapr
04:03:29 <astrolabe> Ah tic-tac-toe
04:03:41 <Esch> i'm writing some kind of game thing, i suppose
04:03:53 <Esch> i wish there were some way to print my listarray
04:04:32 <Saulzar> show will do it, but not very neatly for a 2D array
04:04:55 <jethr0> "main = let b = makeBoard; print b"
04:04:59 <vincenz> jethr0: got my mail?
04:05:06 <jethr0> ups, forgot the "do"
04:05:16 <jethr0> "main = do let b = makeBoard; print b"
04:05:27 <jethr0> vincenz: yup. i mailed a short resume to dcoutts
04:05:38 <vincenz> main = do b <- makeBoard; print b
04:05:51 <jethr0> s/resume/abstract/ -- whatever
04:05:57 <vincenz> you don't need do if makeBoard ain't monadic
04:06:04 <vincenz> main = let b = makeBoard *in* b
04:06:08 <vincenz> main = let b = makeBoard *in* print b
04:06:12 <jethr0> http://www.haskell.org/gtk2hs/archives/category/screenshots/
04:06:23 <Esch> monadic...mysterious terminology...
04:06:29 <Esch> with the stars?
04:06:29 <vincenz> jethr0: nice
04:06:36 <vincenz> Esch: no monadic:
04:06:37 <jethr0> vincenz: i know. but i like the monadic "let" :)
04:06:40 <vincenz> has type -> m a
04:06:51 <jethr0> Esch: no, that's for highlighting in the channel
04:06:56 <Esch> aha
04:07:30 <vincenz> jethr0: alphabetically your name should come first
04:07:46 <mathrick> *Main> (2::Nat) * (3::Nat)
04:07:46 <mathrick> Succ (Succ (Succ (Succ (Succ (Succ Zero)))))
04:07:48 <mathrick> this is fun
04:07:55 <vincenz> s/Succ/Suck
04:07:55 <jethr0> yes, but you've done _all_ the gui work. i was feeling bad to even put my name there :)
04:07:58 <vincenz> mathrick: I bet :P
04:08:00 <jethr0> gotta go badly. bye
04:08:06 <vincenz> jethr0: later :)
04:08:41 <mathrick> infinity :: Nat
04:08:41 <mathrick> infinity = Succ infinity
04:08:41 <mathrick> *Main> infinity + (3::Nat) == infinity
04:08:41 <mathrick> is haskell supposed to be smart enough to figure that out?
04:09:17 <vincenz> mathrick: haskell executes, it doesn't derive
04:09:18 <Esch> it doesn't seem to be liking "showboard = let b = board in print b"
04:09:18 <mathrick> because it seems to be engaging into an actual computation of infinity, which is not what I want :)
04:09:20 <vincenz> this isn' ta proof system
04:09:25 <vincenz> it's constructive, not logical
04:09:29 <mathrick> vincenz: k
04:09:38 <vincenz> Esch: whats the type of board
04:09:48 <Esch> it's a listarray, i believe
04:09:53 <Esch> i'd just like to see it, really
04:09:57 <vincenz> Esch: can I see the code?
04:10:00 <Igloo> Does anyone know how I'm meant to reply to a GHC trac bug having just created an account?
04:10:01 <Esch> sure, one second
04:10:20 <Esch> http://rafb.net/paste/results/VsYv6M13.html
04:10:36 <Esch> i get the players' moves as two lists, one for one player 1 and one for player 2
04:10:45 <mathrick> *Main> (1000000::Nat) < infinity
04:10:45 <mathrick> True
04:10:49 <mathrick> tee hee
04:10:51 <Esch> also, i can be assured that all the moves are valid; my task is to find a winning move for player 2
04:10:57 <Esch> (i can assume that one exists)
04:11:02 <mathrick> okay, this is fun, but I gotta get going
04:11:04 <Esch> (instantly winning move, that is)
04:11:05 <vincenz> Esch: print board???
04:11:18 <Esch> um...well, i was hoping...was it necessary for it to be called main?
04:11:25 <vincenz> Esch: yes
04:11:47 <vincenz> why are you using arrays?
04:12:01 <Esch> jethr0 proposed them as a solution
04:12:06 <Esch> is there some easier way to do it?
04:12:09 <vincenz> Esch: but let b = board in print b ==== print board
04:12:25 <Esch> er, is that all code?
04:12:32 <vincenz> showboard = print board
04:12:49 <shapr> snowboard = cold board!
04:13:03 <vincenz> shapr: I thought you were more interested in hotboxes
04:13:08 * shapr snickers
04:13:20 <Esch> i get "Cannot infer instance" when i try to call "print board"
04:13:27 <vincenz> aha
04:13:34 <vincenz> I take it it doesn't know the type of the list array
04:13:48 <vincenz> @type listARray
04:13:49 <lambdabot> Not in scope: `listARray'
04:13:51 <vincenz> @type listArray
04:13:52 <lambdabot> Not in scope: `listArray'
04:14:00 <vincenz> @type (Data.Array.listArray)
04:14:01 <lambdabot> forall i e.
04:14:01 <lambdabot>          (GHC.Arr.Ix i) =>
04:14:01 <lambdabot>          (i, i) -> [e] -> GHC.Arr.Array i e
04:14:18 <vincenz> Esch: basically it doesn't know the type of the list array
04:14:34 <vincenz> Esch: cause it's not used anywhere besides in print which is polymophic
04:15:00 <vincenz> board :: GHC.Arr.Array Int _typeinarray_
04:15:04 <Esch> just as an aside, i've just been introduced to haskell this week, so there's regrettably a lot that i don't know about it :(
04:15:25 <vincenz> Esch: no worries, I started as a newbie quite recently too, you'll pick it up right away
04:15:52 <vincenz> Esch: listArray returns an array, but because you don't use it anywhere it doesn't know what type of array
04:16:14 <vincenz> Esch: so you can specify it
04:16:29 <vincenz> board :: GHC.Arr.Array Int (type of data in array)
04:18:15 <vincenz> Esch: in addition that board is still a function...
04:18:19 <vincenz> listArray takes two parameters
04:18:35 <vincenz> board = listArray ((1,1),(3,3)) [an array with 9 elements to put in this array)
04:18:59 <Esch> aha
04:19:09 <vincenz> make sure it's 9
04:19:31 <Esch> indeed; it seems to be fine if i fill it with entries
04:19:59 <vincenz> :)
04:20:41 <Esch> though, i bet there's an easier way to solve this just based on the two lists
04:21:07 <Esch> or would i have to compose an in-memory version of the board to figure the final move out?
04:21:47 <vincenz> --does not compute-
04:22:10 * vincenz mutters at the ugliness of c/c++
04:22:34 <Esch> ah, sorry, basically i'm trying to figure out a move that player 2 can take in a game of tic-tac-toe to win instantly, given two lists, each containing the players' moves up till now
04:22:43 <vincenz> Esch: should read "whyfp"
04:22:46 <Esch> (so list 1 would be X's moves and list 2 would be O's moves, for instance)
04:22:46 <vincenz> @google whyfp.pdf
04:22:51 <lambdabot> http://www.md.chalmers.se/~rjmh/Papers/whyfp.pdf
04:22:55 <shapr> @where whyfp
04:22:55 <lambdabot> I know nothing about whyfp.
04:23:06 <shapr> @where+ whyfp http://www.md.chalmers.se/~rjmh/Papers/whyfp.pdf
04:23:06 <lambdabot> Done.
04:23:08 <vincenz> read that paper, lightweight and very good to get into the haskell way of thinking
04:23:15 <vincenz> plus it treats something similar to what you want to do
04:23:23 <Esch> heh, er, it's 23 pages long...
04:23:28 <Esch> it's 4am at the moment :|
04:23:28 <shapr> It's worth it.
04:23:30 <vincenz> it's breezy reading
04:23:38 <Esch> alright, i'll read it, then; thanks
04:23:38 <shapr> And it's by John Hughes too
04:23:51 <shapr> Hey, I have pix of John Hughes riding my unicycle at EuroHaskell 2004
04:24:02 <shapr> I'll upload 'em a bit later...
04:30:51 <sbeyer> hi, someone ever tried gtk2hs?
04:30:55 <vincenz> yep
04:30:58 <vincenz> it's great
04:30:59 <shapr> yup
04:31:03 <sbeyer> I ask, because the executables become just *big*
04:31:10 <shapr> You can strip 'em
04:31:17 <sbeyer> 5 MB executable for buttonbox, 2.6MB stripped
04:31:33 <sbeyer> my first thought was, that --make links statically
04:31:42 <sbeyer> but -package gtk results in the same size
04:33:46 <sbeyer> ButtonBox.o itself is small, the executable is huge.
04:34:28 <sieni> is that a huge executable? :-)
04:34:40 <vincenz> sieni: not if you look at windows
04:34:53 <sbeyer> 5MB (or even 2.6MB) for a window with three buttons is huge ;)
04:35:06 <vincenz> sbeyer: yeah but it doesn't scale
04:35:09 <vincenz> it's a fixed cost
04:35:20 <Esch> ok, so now i have my 2d array populated with the entries of my two lists
04:35:27 <sbeyer> ok, because it links "statically"? ;)
04:35:31 <Esch> sample output: array ((1,1),(3,3)) [((1,1),Just X),((1,2),Just X),((1,3),Just X),((2,1),Just O),((2,2),Just O),((2,3),Just O),((3,1),Nothing),((3,2),Nothing),((3,3),Nothing)]
04:35:43 <sbeyer> and there's no way to use the Haskell package dynamically, I guess?
04:35:59 <Esch> i'm a bit at a loss for what to do next, unfortunately
04:36:03 <vincenz> sbeyer: no idea,, but would you want to? It would require haskell to be installed to use the app...
04:36:21 <sbeyer> hm
04:36:22 <vincenz> I guess it links dynamically to gtk+
04:36:28 <vincenz> but statically compiles in the haskell bindings
04:38:00 <sbeyer> yes, I guess that, too ;)
04:38:07 <sbeyer> well, I don't know what I want
04:38:21 <sbeyer> I think I implement what I want and later port it to C or something
04:38:26 <sbeyer> the size scares me a bit ;)
04:40:33 <eivuokko> For gtk2hs exectables?  I think dcoutts said it is better in darcs version, because it now uses split objs (ghc term, means less stuff gets linked in usually)
04:40:35 <sbeyer> vincenz, the big size also pumps up compilation time and so it takes more time to test.
04:40:43 <sbeyer> eivuokko, ah ok
04:40:46 <sbeyer> thank you ;)
04:40:55 <Esch> @index assoc
04:40:55 <lambdabot> bzzt
04:40:57 <vincenz> eivuokko: cool
04:41:01 <sbeyer> i'll try. but have to go now ;) thank you.
04:41:02 <Esch> hum, that's no fun
04:41:07 <vincenz> @type assoc
04:41:07 <lambdabot> Not in scope: `assoc'
04:41:12 <vincenz> @type List.assoc
04:41:12 <lambdabot> Not in scope: `List.assoc'
04:41:18 <vincenz> @hoogle assoc
04:41:18 <lambdabot> Control.Parallel.Strategies.Assoc :: Assoc a b
04:41:18 <lambdabot> Text.ParserCombinators.Parsec.Expr.Assoc :: Assoc
04:41:18 <lambdabot> Data.Array.IArray.assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
04:41:40 <Esch> how does assoc work, exactly? supposedly, i should be able to use it to find some winning move
04:50:05 <highquality>  laptop for sale 500$ want it gone today. price includes shipping, case, wireless router. message me if interested on aim at ogd443 or msn at mcsltd2@hotmail.com
04:50:39 <Itkovian> what will you be buying with that $500?
04:51:46 --- mode: ChanServ set +o shapr
04:51:50 --- kick: highquality was kicked by shapr (Kicked by shapr)
04:52:24 <vincenz> he's gone
04:52:26 <vincenz> blegh
04:52:30 <vincenz> he could at least have stuck around
04:52:34 <vincenz> to give more spec info
04:52:43 <Esch> so, any ideas about 'assocs'...?
04:52:47 <vincenz> like "does it ship with haskell"
04:52:51 <shapr> haha
04:52:54 <Esch> heh...
04:52:55 --- mode: shapr set +o vincenz
04:53:09 <dblhelix> vincenz: then he wouldn't be entirely off-topic
04:53:11 <vincenz> or is it "functional-programming-enabled"
04:53:18 <vincenz> ooh
04:54:25 <shapr> ?
04:54:28 <vincenz> > let ishappy n = if (head n) == '@' then id else reverse in ishappy "@vincenz" ":)"
04:54:29 <lambdabot> ":)"
04:55:54 <Esch> huh, interesting, heh
04:57:07 <Esch> gah, it's really getting late
04:57:20 <Esch> er, early, i should say
04:57:54 <vincenz> anyway of pushing from a darcs repo to force the population of a new repo?
04:58:02 <vincenz> basically pushing to a nonexistent repo
04:58:07 <vincenz> (like get but in reverse)
04:59:15 <dblhelix> kosmikus: ping?
05:00:07 <shapr> vincenz: scp?
05:00:28 <vincenz> shapr: yeah but "tar cvzf" "scp" "tar xvzf" is annoying
05:00:37 <shapr> rsync?
05:01:00 <vincenz> well right now I basically have several repos on my lappy and I somoetimes push them to my desktop at home for backup purposes
05:01:08 <vincenz> hwoever whenever I make a new repo I have to scp the stuff to my desktop
05:01:23 --- mode: shapr set -o vincenz
05:01:26 --- mode: shapr set -o shapr
05:01:30 <shapr> No more power!
05:01:32 <vincenz> unless...
05:01:32 <cpatrick> vincenz: `darcs put`
05:01:39 <vincenz> cpatrick: won't do it the repo doesn't exist
05:01:50 <vincenz> but I can just create an empty repo on the desktop I guess
05:02:00 <cpatrick> vincenz: yes it will.
05:02:01 <cpatrick> "Put is the opposite of get. Put copies the content of the current 
05:02:01 <cpatrick> repository and puts it in a newly created repository.
05:02:01 <cpatrick> "
05:02:07 <cpatrick> Put != Push
05:02:09 <vincenz> oh!
05:02:11 <vincenz> thx
05:02:13 <vincenz> cool
05:02:32 <Esch> so, er, anyone willing to give me a nudge in the right direction with this tic tac toe thing?
05:02:42 <Esch> i think the big problem is that i have no idea how to do much of anything to a listarray
05:02:58 <Esch> i do have all the moves for each player currently stored in a 3x3 one, though
05:02:58 <vincenz> darc put doesn't exist
05:03:18 <vincenz> but it's ok
05:03:25 <vincenz> I just log in do an md; darcs init
05:03:37 <Esch> http://rafb.net/paste/results/7o1HLO79.html here's my current code
05:03:40 <vincenz> I make sure to have my repos in exactly the same space :)
05:03:50 <vincenz> alias commit='darcs record && darcs push $SCP_OASIS:`pwd`'
05:04:14 <Esch> so, i know that there's just one move that i need to make with the given input to have O win the game, but i'm not sure how to derive that
05:04:31 <vincenz> Esch: read whyfp?
05:04:36 <Esch> i suppose there are only four places to check
05:04:41 <Esch> i've read a few pages of it, yes
05:04:49 <vincenz> evne the part on the game board?
05:04:53 <Esch> unfortunately, i have these impending deadlines that prevent me from bettering myself :|
05:05:02 <Esch> haven't gotten there yet, no
05:05:07 <vincenz> Esch: you're tired...it's better to read something and let it sink in as you sleep
05:05:18 <vincenz> more time != more effective time
05:05:29 <Esch> heh, i wish i could; i unfortunately have to turn this in by 10am...er, in about five hours
05:05:34 <vincenz> h
05:05:34 <vincenz> oh
05:06:02 <Esch> ah, tic tac toe's right in this document, interesting
05:06:09 <vincenz> I told you to read it :D
05:07:22 <Esch> ah, if only this were prolog; i'd have this written in a minute
05:07:30 <Esch> (it lends itself very well to the tree-based solution exploration)
05:07:52 <vincenz> Esch: read whyfp
05:08:58 <roconnor> Isn't prolog just the nondetermanism monad?
05:09:08 <vincenz> roconnor: I doubt it
05:09:12 <Esch> haven't the faintest
05:09:23 <vincenz> roconnor: I think the search strategy of prolog is deterministic
05:10:31 <roconnor> Esch: I've come into this conversation late, but have you seen the Haskell Sudoku solver?  It seems like a similar problem
05:10:58 <vincenz> whyfp looks at tictactoe
05:11:12 <Esch> ok, that whole max and min thing lost me a bit
05:11:21 <Esch> and i don't really know where i'd start building a tree now
05:11:26 <vincenz> Esch: you don't know minimax?
05:11:52 <Esch> i only need to make one move anyhow, so a tree seems unnecessary
05:12:22 <Esch> i suppose more than a way to choose that move, i need a way to tell if an existing board has already been won
05:12:34 <vincenz> Esch: you need to make only one move?
05:12:38 <vincenz> Esch: what abut backtracking?
05:12:46 <sieni> > let queens m = let {qs 0 = [[]] ; qs n = [ x : y | y <- qs (n-1), x <- [1..m], safe x y 1] ; safe x [] n = True ; safe x (c:y) n = and [ x /= c , x /= c + n , x /= c - n , safe x y (n+1)] } in qs m in queens 8
05:12:47 <lambdabot> [[4,2,7,3,6,8,5,1],[5,2,4,7,3,8,6,1],[3,5,2,8,6,4,7,1],[3,6,4,2,8,5,7,1],[
05:12:47 <lambdabot> 5,7,1,3,8,6,4,2],[4,6,8,3,1,7,5,2],[3,6,8,1,4,7,5,2],[5,3,8,4,7,1,6,2],[5,
05:12:47 <lambdabot> 7,4,1,3,8,6,2],[4,1,5,8,6,3,7,2],[3,6,4,1,8,5,7,2],[4,7,5,3,1,6,8,2],[6,4,
05:12:47 <lambdabot> 2,8,5,7,1,3],[6,4,7,1,8,2,5,3],[1,7,4,6,8,2,5,3],[6,8,2,4,1,7,5,3],[6,2,7,
05:12:47 <lambdabot> 1,4,8,5,3],[4,7,1,8,5,2,6,3],[5,8,4,1,7,2,6,3],[4,8,1,5,7,2,6,3],[2,7,5,8,
05:12:49 <lambdabot> [18 @more lines]
05:13:12 <Esch> ah, that's true, i suppose...i was thinking i could just try all four and go with whichever one gives me a solution
05:13:25 <vincenz> and the tree is simplle
05:13:49 <vincenz> it's' basically the possible moves
05:13:52 <Esch> so, it's a tree of boards, right?
05:13:54 <vincenz> for each of the different boards
05:14:12 <Esch> also, i don't need to start at an empty board; i have an almost complete game, all i need to do is output the winning move
05:14:25 <vincenz> then just start with that as start board
05:14:47 <Esch> alright...so, i supposedly need to assign an importance to each cell, right...?
05:14:55 <vincenz> err
05:14:56 <vincenz> no
05:15:00 <roconnor> sieni: what I find funny is that (let queens m = let {qs 0 = [[]] ; qs n = [ x : y | x <- [1..m], y <- qs (n-1), safe x y 1] ; safe x [] n = True ; safe x (c:y) n = and [ x /= c , x /= c + n , x /= c - n , safe x y (n+1)] } in qs m in queens 8) is wayyyyyyyyyy slower
05:15:19 <vincenz> roconnor: what's the diff
05:15:31 <roconnor> qs n = [ x : y | x <- [1..m], y <- qs (n-1), safe x y 1]
05:15:36 <Esch> ok; i'm sorry, i guess i just didn't really understand what he was saying in the paper
05:15:40 <roconnor> I changed the order of the guards.
05:15:45 <roconnor> sorry
05:15:51 <roconnor> I changed the order of the generators
05:15:55 <vincenz> roconnor: ah
05:16:16 <roconnor> goes from quadratic time to exponential time
05:16:40 <Esch> how do i iterate through a listarray?
05:16:55 <vincenz> Esch: forget about the listarray
05:16:58 <vincenz> start simple and just use a list
05:17:06 <vincenz> you're overcomplicating issues
05:17:29 <vincenz> type Board = [Pos]
05:17:33 <Esch> someone else mentioned that that'd be the way to do it *shrug*
05:17:41 <vincenz> type Pos = X | O | Emtpy
05:17:56 <vincenz> instance Show Pos where
05:18:07 <vincenz>   shows X = ' ':
05:18:11 <vincenz>   shows X = 'X':
05:18:18 <vincenz>   shows O = 'O':
05:18:23 <vincenz>   shows Empty = ' ':
05:18:37 <vincenz> (forget the first shows)
05:18:43 <Esch> right, understood
05:18:53 <vincenz> instance Show Board where
05:19:02 <vincenz>  shows board = ... write code to show board
05:19:04 <vincenz> now you can print board
05:19:15 <Esch> ok, now i need a way to populate
05:19:22 <vincenz> easy
05:19:27 <Esch> i've already written a way to populate the listarray, unfortunately
05:19:30 <vincenz> [X,O,X,O,EmptyX,O,X,Empty]
05:19:32 <vincenz> that's a board for instance
05:19:46 <vincenz> [X,O,X,O,Empty,X,O,X,Empty]
05:19:50 <Esch> ok, but i need to take in two lists of coordinates, one for each player
05:20:00 <Esch> you have to understand that the simplest things are gut-wrenchingly difficult for me
05:20:08 <vincenz> two lists of coordinates??
05:20:13 <shapr> It gets easier, we were all there once.
05:20:15 <Esch> right, one for each player
05:20:25 <shapr> Except Simon Peyton-Jones maybe... 
05:20:30 <vincenz> so populate : [(Int,Int)] -> [(Int,Int)] -> Board
05:20:36 <shapr> I wonder if he was born without side-effects =)
05:20:39 <vincenz> assuming 0 based
05:20:47 <vincenz> easy
05:20:56 <Esch> it's 1-based, actually :\
05:20:58 <vincenz> emptyBoard = replicate 9 Empty
05:21:00 <Esch> the coordinates, that is
05:21:02 <vincenz> Esch: even easier then
05:21:07 <vincenz> cause our board is just a list
05:21:10 <vincenz> instead of a 2d array
05:21:26 <vincenz> so we have [Int] -> [Int] -> Board
05:21:32 <vincenz> for populate
05:21:44 <vincenz> ?
05:22:04 <vincenz> @type replicate
05:22:04 <lambdabot> forall a. Int -> a -> [a]
05:22:11 <tromp_> you can also make Board a String using 'X', 'O', '.', and '\n'
05:22:17 <vincenz> tromp_: good idea
05:22:33 <tromp_> saves you the trouble of defining show:)
05:23:22 <Esch> alright, so i'll have to go from a 2d coordinate to a 1d offset in my array...
05:23:32 <vincenz> ?
05:23:46 <vincenz> is it 2d coord or 1d coord?
05:23:58 <Esch> well, the moves are given as 2d coords on the board
05:24:05 <vincenz> (x,y)
05:24:16 <Esch> right, they're integer tuples
05:25:28 <dcoutts> eivuokko, sbeyer, yes with the darcs version of gtk2hs a hello world is only 30% bigger than a trivial console version.
05:27:44 <dcoutts> vincenz, jethr0, happy with your little screenshot thingie on the gtk2hs website?
05:27:52 <vincenz> dcoutts: yep :)
05:27:53 <Esch> ok, so it doesn't seem like there's an easy way to get the moves into my list now
05:28:00 <vincenz> dcoutts: hope you're happy
05:28:04 <vincenz> Esch: yes there is
05:28:05 <dcoutts> yep
05:28:33 <Esch> in any case, why do i want this list, exactly? i'm a bit confused about that
05:28:42 <dcoutts> vincenz, jethr0, btw we were wondering, you said you used cairo but the lines don't look anti-aliased. Just wondering if you turned that off (and if so how?)
05:28:53 <vincenz> dcoutts: I foxed that
05:28:57 <vincenz> fixed even
05:29:03 <dcoutts> vincenz, oh?
05:29:11 <vincenz> dcoutts: yeah there's a command to turn it off
05:29:11 <dcoutts> how, what changed?
05:29:16 <dcoutts> there is?
05:29:20 <dcoutts> I never noticed :-)
05:29:37 <vincenz> setAntialias AntialiasNone
05:29:42 <dcoutts> heh ok
05:31:03 <Esch> ok, then there's an easy way to do this that i don't know, apparently
05:31:10 <Esch> i can't even begin to fathom what i'm doing
05:31:39 <Esch> is there really no way to iterate over the elements of a listarray?
05:31:46 <Esch> you can't use list comprehension on it or something?
05:33:37 <vincenz> why not use a list
05:33:44 <vincenz> and use as coord in the list (3*y+x)
05:33:47 <vincenz> assuming zero-based x and y
05:34:00 <Esch> ok, but i have no idea how to replace a specific entry in a list
05:35:06 <vincenz> > let board = replicate 9 ' ' in let x =1 in let y = 2 in let  (a, _:b) = splitAt (x+3*y) board in a++('X':b)
05:35:07 <lambdabot> "       X "
05:39:44 <Esch> oh, so i'm not using a list of Pos anymore, i guess?
05:39:56 <vincenz> same difference
05:40:14 <vincenz> http://rafb.net/paste/results/9zLuwY10.html
05:40:21 <Esch> any idea if take (x+3*y-1) ++ X ++ drop (x+3*y) would work the same?
05:40:42 <vincenz> yeah but you're doing twice the work
05:40:44 <vincenz> splitAt is perfect for this
05:40:55 <Esch> that line seems to give me a type error, actually
05:41:11 <Esch> the trouble is that i have no idea what your code does @_@
05:41:22 <roconnor> take (x+3*y-1) board ++ X ++ drop (x+3*y) board
05:41:30 <Esch> ah, right
05:41:38 <vincenz> Esch: setP just takes a position along with a player thiny
05:41:41 <vincenz> Esch: and a board 's'
05:41:49 <vincenz> and updates that one position
05:42:11 <vincenz> giving a new board
05:50:26 * shapr fights vim
05:50:43 <vincenz> http://rafb.net/paste/results/vFpHtm76.html
05:51:09 <vincenz> code with lots of smileys
05:51:18 <shapr> I tried uncommenting the section of /etc/vim/vimrc that jumps to the last position when reopening a file, but it complains after that, can someone tell me how to fix it?
05:51:25 <shapr> I'm an emacs user trying to get better with vim :-)
05:51:37 <Esch> thank you, vincenz
05:51:38 <vincenz> shapr: can you be more detialed about the complains?
05:51:47 * JKnecht looks for a free alternative to Crystal, Cognos, etc., in vain apparently.
05:51:59 <shapr> JKnecht: What are those?
05:52:09 <vincenz> shapr: and that's not in /etc/vim/vimrc
05:52:13 <vincenz> at leats not in mine
05:52:21 <vincenz> you should put custom stuff in ~/.vrimc
05:52:41 <JKnecht> shapr: they are the leading report writing packages.
05:52:47 <shapr> vincenz: http://rafb.net/paste/results/ZQWtPN24.html
05:53:03 <Esch> hum, i can't seem to get populate working
05:53:09 <Esch> it gives me a pattern matching error...?
05:53:12 <vincenz> shapr: looks fine, what's the complaint
05:53:31 <lisppaste2> dancor pasted "monad monads" at http://paste.lisp.org/display/17674
05:54:04 <vincenz> shapr: anyways that's in my .vimrc not in /etc/vim/vimrc...
05:54:05 <Esch> oh, your coordinates are zero-based
05:54:18 <shapr> vincenz: http://rafb.net/paste/results/C3SlyU12.html
05:54:33 <shapr> hiya dancor, are you Daniel Lundin?
05:54:52 <dancor> nope :)
05:54:55 <shapr> ah, ok
05:55:14 <vincenz> shapr: exe "normal g`\""
05:55:20 <vincenz> need a " before the normal
05:55:31 <vincenz> and should be ` not '
05:55:47 <shapr> ah, thanks
05:55:51 <vincenz> yep
05:56:04 <shapr> seems to work with '
05:56:16 <vincenz> http://rafb.net/paste/results/lv9nNU43.html
05:56:19 * shapr changes anyway
05:56:21 <vincenz> that's mine
05:56:29 <vincenz> inside an if has("autocmd")
05:56:36 <shapr> Yeah, I see.
05:56:51 <shapr> Any other good useful vim settings?
05:57:12 <vincenz> textwidth = 0
05:57:16 <shapr> My .emacs file is about 1450 lines, I enjoy customizing software.
05:57:17 <vincenz> expandtab
05:57:23 <vincenz> shiftwidth=2
05:57:24 <vincenz> tabstop=2
05:57:26 <vincenz> softtabsopt= 2
05:57:32 <vincenz> softtabstop even
05:58:05 <vincenz> if you want some nicer colors...
05:58:08 <shapr> hm, I like tab to be four spaces
05:58:14 <vincenz> then put 4
05:58:22 <vincenz> http://rafb.net/paste/results/AcPhOf35.html
05:58:28 <vincenz> I use that colorscheme
05:58:39 <vincenz> set backupdir=~/tmp
05:58:43 <vincenz> set directory=~/tmp
05:58:54 <vincenz> (puts the xxx~ as well as the .xxx.swp files in tmp
05:59:09 <dancor> i can't figure out how to run a state on like (b, d, e) within a function running a state on (a, b, c, d, e).  perhaps http://paste.lisp.org/display/17674 the code is clearer than me talking.
05:59:11 <mathrick> toInteger (Succ n) = 1 + toInteger n is not tail-recursion, right?
05:59:34 <vincenz> nope
05:59:48 <vincenz> top expression is +
05:59:50 <vincenz> not toInteger
06:00:24 <mathrick> so I need toInteger2 to make it tail, right?
06:00:31 <tromp_> it's hard to think of a 1 argument tail recursive function:)
06:00:31 <vincenz> no idea
06:00:38 <vincenz> tromp_: nah
06:00:51 <vincenz> idiot n = idiot (n+1)
06:01:12 <tromp_> a useful one
06:01:16 <shapr> length?
06:01:21 <vincenz> notice the descriptive name
06:01:32 <vincenz> shapr: nope
06:01:39 <vincenz> lengt a:r = 1+ lengt(r)
06:01:44 <vincenz> unless they use an inner 2-param func
06:01:53 <shapr> length [] = 0 ; length (x:xs) = 1 + (length xs)
06:01:58 <vincenz> is not tail recurisve
06:02:05 <shapr> isn't?
06:02:07 <vincenz> no
06:02:24 * shapr requests clue
06:02:25 <tromp_> i know one
06:02:39 <vincenz> length [] n = n; length x;xs = length  xs (n+1)  
06:02:41 <vincenz> that one is tail
06:02:47 <tromp_> even 0 = True; even 1 = False; even (n+2) = even n
06:02:54 <vincenz> tromp_: yep
06:03:03 <vincenz> erm
06:03:10 <vincenz> can you do even (n+2) = even n?
06:03:17 <vincenz> wouldnt that be even n = even (n-2)
06:03:20 <dancor> wikipedia uses factorial as an example.
06:03:29 <vincenz> dancor: only if it has 2 arguments
06:03:33 <tromp_> that's 2 arguments
06:03:33 <vincenz> otherwisie it's not tail recursive
06:04:00 <vincenz> does ghc do tail-call optimization
06:04:24 <mathrick> I surely hope so
06:04:39 <tromp_> > let { even 0 = True; even 1 = False; even (n+2) = even n } in even 7
06:04:40 <lambdabot> False
06:04:52 <vincenz> holy cow
06:05:04 <vincenz> > let lala (n+2) = n in lala 
06:05:05 <lambdabot>  add an instance declaration for (Show (a -> a))
06:05:05 <vincenz> > let lala (n+2) = n in lala 6
06:05:06 <lambdabot> 4
06:05:07 <tromp_> let { even 0 = True; even 1 = False; even (n+2) = even n } in even (-1)
06:05:09 <vincenz> damn
06:05:16 <vincenz> tromp_: you need a >
06:05:20 <mathrick> matching (n + 2) amazes me
06:05:24 <vincenz> likewise
06:05:34 <vincenz> > let lala (n+2) = n in lala -1
06:05:35 <lambdabot>  add an instance declaration for (Num (a -> a))
06:05:38 <vincenz> > let lala (n+2) = n in lala (-10
06:05:39 <lambdabot>  parse error on input `}'
06:05:42 <vincenz> > let lala (n+2) = n in lala (-1)
06:05:43 <lambdabot>  Non-exhaustive patterns in function lala
06:05:48 <vincenz> hmm
06:05:51 <vincenz> > let lala (n+2) = n in lala (0)
06:05:52 <lambdabot>  Non-exhaustive patterns in function lala
06:05:54 <vincenz> > let lala (n+2) = n in lala (1)
06:05:54 <lambdabot>  Non-exhaustive patterns in function lala
06:05:57 <vincenz> o.O
06:06:31 <dancor> what happens if you give lambdabot something nonterminating
06:06:39 <tromp_> > undefined
06:06:39 <vincenz> it terminates
06:06:39 <lambdabot> Add a type signature
06:06:46 <vincenz> dancor: it puts a timeout on computation
06:06:49 <tromp_> > undefined :: ()
06:06:50 <lambdabot> Undefined
06:07:01 <vincenz> > let b x = b (x+1) in b 1
06:07:01 <lambdabot> Add a type signature
06:07:06 <tromp_> > let x = x in x :: ()
06:07:06 <vincenz> > let b x = b (x+1) in b 1 :: Int
06:07:07 <lambdabot> Terminated
06:07:10 <lambdabot> Terminated
06:07:38 <mathrick> but why doesn't lala work?
06:07:47 <vincenz> I guess it's syntax sguar for 
06:07:56 <tromp_> the n+k pattern only applies to natural numbetrs
06:07:59 <vincenz> let lala n | n > 2 = n -2
06:08:14 <liyang> lala doesn't work because there's no case for lala 0 nor lala 1
06:08:17 * mathrick would say it's pretty easy to extend that to integers
06:08:21 <mathrick> liyang: and?
06:08:27 <tromp_> > let { even 0 = True; even 1 = False; even (n+2) = even n } in even (-1)
06:08:28 <lambdabot>  Non-exhaustive patterns in function even
06:08:29 <mathrick> it's not needed to obtain a value
06:08:31 <vincenz> > 1 :: Natral
06:08:32 <lambdabot>  Not in scope: type constructor or class `Natral'
06:08:33 <vincenz> > 1 :: Natral
06:08:34 <lambdabot>  Not in scope: type constructor or class `Natral'
06:08:35 <vincenz> > 1 :: Natural
06:08:36 <lambdabot>  Not in scope: type constructor or class `Natural'
06:08:38 <vincenz> hmm
06:08:44 <vincenz> there's noot even a Natural typpe
06:08:48 <tromp_> nope
06:08:49 * vincenz kicks his hands
06:08:50 <liyang> > let lala (n+2) = n in lala 2
06:08:51 <lambdabot> 0
06:09:06 <vincenz> like I said... it must be
06:09:08 <mathrick> stupid
06:09:13 <vincenz> let lala n | n >= 2 = n-2
06:09:15 <mathrick> why not integers?
06:09:41 <mathrick> > let lala n | n >= 2 = n-2 in lala (-10)
06:09:42 <lambdabot>  Non-exhaustive patterns in function lala
06:09:51 <vincenz> > let { lala (2*n) = n} in lala 4
06:09:51 <mathrick> whut
06:09:51 <lambdabot>  Parse error in pattern
06:10:07 <vincenz> mathrick: that's a pattern guard
06:10:21 <liyang> + patterns are a bit silly, really.
06:10:22 <mathrick> vincenz: eh?
06:10:24 <vincenz> sadly they screw up compile-time exhaustive checking
06:10:41 <dancor> f1::State Int ().  f2::State (Int,Int) ().  how can i, in f2, run f1 on like the second Int of f2, without having to ever keep track of variables like b''''', b''.
06:10:45 <araujo> hellu
06:11:24 <mathrick> lots of people from #emacs here
06:11:27 <Esch> hum, what do i do if i have a name conflict between two modules?
06:11:30 <vincenz> vim > emacs
06:11:36 <mathrick> vincenz: pfff
06:11:40 <Esch> say i want to define sort, but it's already defined in Data.List
06:11:47 <vincenz> mathrick: unless you mean diskspace
06:11:51 <vincenz> then emacs >>> vim
06:11:57 <Esch> but i'm also importing Data.List
06:12:07 <mathrick> vincenz: vim > /dev/null
06:12:17 <vincenz> anyways
06:12:20 <vincenz> real coders use ed
06:12:24 <mathrick> heh
06:12:35 <vincenz> it's only 40k
06:12:43 <mauke> import Data.List hiding (sort)
06:12:43 <mathrick> whole whopping 40k?
06:12:45 <mathrick> no way
06:12:59 <cpatrick> -rwxr-xr-x  1 root root 47656 2004-08-18 05:40 /bin/ed*
06:13:03 <vincenz> -rwxr-xr-x  1 root root 40312 2004-08-13 02:16 /bin/ed
06:13:03 <dancor> i never saw them as that different.  modeful, modeless.
06:13:06 <mathrick> 44K     /bin/ed
06:13:11 <tromp_> real coders just type object code: cat > a.out
06:13:20 <vincenz> tromp_: ever seen that drawing?
06:13:23 <mauke> http://www.gnu.org/fun/jokes/ed.msg.html
06:13:23 <vincenz> "real coders code in binary"
06:13:28 <vincenz> with a keyboard with two big keys
06:13:32 <mathrick> REAL coders use magnets
06:13:32 <vincenz> "O" and "!"
06:13:34 <vincenz> "O" and "1"
06:13:36 <mauke> -rwxr-xr-x  1 root          24 Oct 29  1929 /bin/ed
06:13:36 <mauke> -rwxr-xr-t  4 root     1310720 Jan  1  1970 /usr/ucb/vi
06:13:36 <mauke> -rwxr-xr-x  1 root  5.89824e37 Oct 22  1990 /usr/bin/emacs
06:13:50 * cpatrick grins
06:14:06 <mathrick> we all know that :)
06:14:07 <vincenz> http://www.t-shirtexpo.com/upload_files/image_166.gif
06:14:18 <tromp_> i program in binary
06:14:25 <vincenz> http://www.ninisworld.com/oddsends/justforfun/funpicts/realprogrammers.jpg
06:14:29 <vincenz> I like the second one
06:14:38 <dancor> it's funny that we're espousing small file size in #haskell.
06:14:41 <vincenz> (tho I wonder what the Enter keyboard is for)
06:14:50 <vincenz> ...key even
06:15:06 <vincenz> heh... you could program a computer with just one key, just make sure to synchronize well with the clock
06:15:08 <mathrick> vincenz: running it
06:15:17 <mathrick> heh
06:15:36 <tromp_> my lambda calculus interpreter is 010001101000010000000110000001100001011110011111110000101110011111110000001111000010110110111001111111100001111111100001011110100111010010110011111100001101100001011111111000011111111000011100110111101110011010
06:15:57 <vincenz> tromp_: what happens if yo chane a random 1 to 0
06:16:02 <vincenz> tromp_: is it bit-robust?
06:16:07 <tromp_> that'll break it of course
06:16:07 <vincenz> do you use ecc?
06:16:14 <astrolabe> If I want      type List a = [] a   , can I just write      type List = []    ?
06:16:29 <vincenz> astrolabe: no
06:16:32 <Esch> hum, say that i had a list like [[1,0,0],[0,0,0],[0,0,0]] and i wanted to take a rectangular "section" out of it
06:16:42 <vincenz> astrolabe: type's can't abbreviate partially applied types
06:16:42 <astrolabe> vincenz: Thanks
06:17:01 <Esch> i know how to replace values easily enough, but is there some way to 'extract' from some position in a list to some other position?
06:17:27 <Esch> say i want all elements in a list [3,4,5,6,2,3,4,7,4] from 2 to 6 or something
06:17:51 <vincenz> map [2..6] ( [3,4,5,6,2,3,4,7,4] !!)
06:17:57 <vincenz> > map [2..6] ( [3,4,5,6,2,3,4,7,4] !!)
06:17:57 <lambdabot> Couldn't match `a -> b' against `[a1]'
06:18:01 <tromp_> fromtill i j = take (j-i) . drop i
06:18:06 <vincenz> @type (!!)
06:18:06 <lambdabot> forall a. [a] -> Int -> a
06:18:14 <Esch> interesting; what is '.'?
06:18:15 <vincenz> > map ( [3,4,5,6,2,3,4,7,4] !!) [2..6]
06:18:16 <lambdabot> [5,6,2,3,4]
06:18:24 <mauke> which .?
06:18:27 <tromp_> let fromtill i j = take (j-i) . drop i in fromtill 2 5 "hellothere"
06:18:28 <vincenz> tromp_: I like mine better :)
06:18:37 <Esch> er, in tromp_'s code
06:18:40 <tromp_> > let fromtill i j = take (j-i) . drop i in fromtill 2 5 "hellothere"
06:18:41 <lambdabot> "llo"
06:18:44 <Esch> heh, that is elegant, i agree...
06:18:48 <vincenz> fromtil i j l = map (l !!) [i..j]
06:19:00 <dancor> vincenz, tromp_: but who's goes to 2d best
06:19:01 <astrolabe> @type (.)
06:19:02 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
06:19:10 <mauke> @djinn (b -> c) -> (a -> b) -> a -> c
06:19:10 <lambdabot> f a b c = a (b c)
06:19:14 <vincenz> dancor: I already gave him code to encode a board in a list
06:19:27 <vincenz> but...
06:19:32 <vincenz> if you really want
06:19:32 <Esch> oh, i'm working on something a bit different now, sorry
06:19:47 <Esch> but it's all helpful; thank you
06:19:53 <Esch> i have a few projects due today, heh
06:19:56 <mathrick> @djinn-help
06:19:56 <lambdabot> Cannot parse command
06:20:06 <vincenz> > let fromtil2D i j b = map (\(x,y) -> b !! i !! j) [i..j]
06:20:06 <lambdabot>  parse error on input `}'
06:20:09 <mathrick> @help djinn
06:20:10 <lambdabot> Generates Haskell code from a type.
06:20:10 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
06:20:10 <Esch> well...due a few days from now, technically, but i'm going out of town tomorrow
06:20:28 <vincenz> > let fromtil2D i j b = map (\(x,y) -> b !! i !! j) [i..j] in [[1,2,3],[4,5,6],[7,8,9]] (1,1) (2,2)
06:20:29 <lambdabot> Couldn't match `[[a]]' against `t -> t1 -> t2'
06:20:37 <vincenz> > let fromtil2D i j b = map (\(x,y) -> b !! i !! j) [i..j] in fromtil2D [[1,2,3],[4,5,6],[7,8,9]] (1,1) (2,2)
06:20:38 <lambdabot> Couldn't match `(a, b)' against `Int'
06:20:52 <vincenz> > let fromtil2D i j b = map (\(x,y) -> b !! i !! j) [i..j] in fromtil2D (1,1) (2,2) [[1,2,3],[4,5,6],[7,8,9]]
06:20:52 <lambdabot> Couldn't match `(a, b)' against `Int'
06:21:06 <dancor> i like watching realtime debugging.  it's like reality programming.
06:21:12 <vincenz> darn
06:21:16 <vincenz> tuples aren't enumerable
06:21:59 <vincenz> dancor: like "big coder"?
06:22:14 <vincenz> in the same spirit as "big brothel"
06:22:20 <vincenz> (typo intentional)
06:22:20 <dancor> indeed
06:24:07 <dancor> f2::State (a,a) ().  f2 = do {(a,b)<-get; ..; put(a,b); return ()}
06:24:27 <dancor> in the .., can i do something stateful with b?
06:24:43 <dancor> or is that editing the past and not ok
06:24:51 <vincenz> dancor: you mean like a "reference
06:24:55 <vincenz> b is a value
06:24:58 <vincenz> anything stateful
06:25:01 <vincenz> you're doing with that State (a,a)
06:25:12 <dancor> sorry i'm unclear
06:25:36 <dancor> i want to run some other function f1::State a ()  on b
06:26:02 <vincenz> dancor: erm
06:26:03 <dancor> so i guess i could do b' <- runState f1 b
06:26:10 <vincenz> dancor: yes
06:26:14 <vincenz> no
06:26:16 <dancor> but i'm trying to avoid ' in the first place
06:26:25 <vincenz> o.O
06:26:37 <dancor> because after a while you've got (a''''', b'', c'''') or whatever
06:27:00 <vincenz> besides
06:27:03 <vincenz> runState is not a monad
06:27:05 <vincenz> it's an expression
06:27:10 <vincenz> so it would be let b' = runState
06:27:18 <dancor> indeed
06:27:28 <vincenz> meaning you can just ust that expression where yo want
06:27:35 <vincenz> instead of binding it
06:27:41 <dancor> good
06:27:53 <vincenz> and you can reuse b, it'll just shadow an old b
06:27:59 <dancor> but the truth is i have (a,b,c) and want to do something to (a,c)
06:28:09 <vincenz> dancor: why not make sure they're all the same state?
06:28:19 <vincenz> and just not touch b
06:28:26 <vincenz> or even better
06:28:39 <vincenz> as state use a Map [Char] value
06:28:40 <vincenz> :)
06:28:48 <vincenz> and you have an environment of similarly typed variables
06:29:26 <dancor> i have to read up on map, but that sounds like it might solve my problems
06:29:43 <vincenz> State (Map [Char] a) 
06:29:50 <vincenz> and then define something like
06:30:09 <vincenz> getVar x = do { s <- get; return $ fromJust $ lookup x s}
06:30:22 <vincenz> b <- getVar "b"
06:31:43 <dancor> i guess tuples are too rigid a lot
06:31:57 <vincenz> yeah
06:32:41 <Esch> vincenz: the trouble i'm having with your code is that it uses zero-indexed coordinates
06:32:56 <Esch> i unfortunately need 1-indexed coordinates, and my attempts at modifying it have led to disaster
06:33:03 <Esch> er, lead
06:33:13 <vincenz> Esch: you're telling me you're taking a coding course and don't know how to substract 1?
06:33:26 <Esch> i tried that, but it didn't seem to help
06:33:34 <Esch> at this hour of the morning, everything seems mystical, sorry
06:34:02 <Esch> e.g (x+3*y-1) seems to give me some cryptic 'program error'
06:34:26 <vincenz> well obviously that's wrong
06:34:35 <vincenz> that needs to be (x+3*y-4)
06:34:44 <vincenz> or more properly
06:34:49 <vincenz> ((x-1) +3*(y-1))
06:35:21 <Esch> ok, heh, that makes a lot more sense
06:35:27 <Esch> i'm really sorry for being very thick at the moment
06:35:33 <dcoutts> jethr0, I was trying to access http://jethr0.dyndns.org/repos/icfp/ but can't
06:35:38 <vincenz> dancor: try
06:35:45 <Esch> so, on to solving this thing, i guess
06:35:46 <vincenz> http://abstractoasis.dyndns.org:8080/repos/icfp
06:35:50 <vincenz> dcoutts: even
06:36:04 <dcoutts> vincenz, ta
06:36:09 <vincenz> welcome :)
06:39:17 <Esch> actually, there are five positions to test...hmm...
06:39:33 <Esch> so, the task is to tell if the position i've chosen is a solution or not, i guess
06:40:11 <shapr> shazam!
06:41:51 <drbean> join perl6
06:42:23 <vincenz> kick drbean 
06:42:33 <vincenz> yay for propaganda!
06:43:12 <shapr> :-P
06:43:53 <tromp_> what do your boards look like now, Esch?
06:44:41 <Esch> they're arrays of X's and O's, which are data types and not string literals
06:44:52 <vincenz> I posted a showboard
06:44:53 <tromp_> arrays?
06:45:02 <vincenz> tromp_: h means [O,X,..]
06:45:05 <vincenz> s/h/he
06:45:16 <Esch> er, a board is an array of X's and O's
06:45:19 <Esch> right, yes, yes
06:45:24 <tromp_> array or list?
06:45:29 <vincenz> http://rafb.net/paste/results/vFpHtm76.html
06:45:35 <Esch> i'm trying to write a checkhoriz function at the moment, but i need to override Eq as well, it seems
06:45:51 <vincenz> Esch: yes deriving Eq
06:46:33 <Esch> pinning "deriving Eq" to the end of Pos's definition didn't seem to do it
06:46:39 <tromp_> let [a,b,c,d,e,f,g,h,i] = pos
06:47:00 <tromp_> let combos = [(a,b,c),(d,e,f), .... ]
06:47:25 <tromp_> if any ((== (X,X,X)) combos ....
06:48:02 <tromp_> if any (== (O,O,O)) combos ...
06:48:14 <Esch> hum, alright; i think i'm just interested in O wins
06:48:27 <Esch> that makes sense, though...hmm...
06:48:39 <Esch> i still need to make Pos work with ==, though
06:49:26 <Esch> tromp_: just out of curiosity, would i compose that all into a single function somehow?
06:49:48 <Esch> i'm still not sure how to get multiple things to happen in a function without either connecting them with boolean operators or composing them
06:51:53 <tromp_> you could
06:52:05 <ndm> Esch, have you ever seen Adjoxo?
06:52:12 <Esch> can't say i have
06:52:21 <ndm> its a Haskell program that does noughts and crosses adjudication
06:52:28 <ndm> might be exactly what you are after
06:52:28 <shapr> @quote Oleg
06:52:29 <lambdabot>  The implementation of RSA on type level is left for future work
06:52:35 <vincenz> @quote viin
06:52:35 <lambdabot> viin hasn't said anything memorable
06:52:37 <vincenz> @quote vincenz 
06:52:37 <lambdabot> vincenz hasn't said anything memorable
06:52:39 <vincenz> :(
06:52:49 <shapr> @quote sofia
06:52:49 <lambdabot> sofia hasn't said anything memorable
06:52:51 <shapr> aww
06:53:05 <shapr> vincenz: You have some quotes in the lambdabot state, dunno why they don't show up.
06:53:17 <vincenz> must be a corrupt state
06:53:26 * vincenz only has one line in the C++ robot
06:53:33 <ndm> Esch, http://www-users.cs.york.ac.uk/~ndm/temp/Adjoxo.hs
06:53:37 <Esch> hum, ok, so say i want to have two lets in the same function
06:53:46 <vincenz> < cylon> <vincenz> this channel is degrading by the moment
06:55:24 <Esch> i unfortunately still need Eq Pos for this to work :|
06:55:50 <Esch> the solution is in sight, though :D
06:58:00 <tromp_> no, you need Eq on X and O
06:58:25 <Esch> er, right
06:58:54 <tromp_> only needs ... deriving Eq
06:59:18 <Esch> this is what it says "Instance of Eq Pos required for definition of checksol"
06:59:43 <Esch> checksol's the function that does the following: checksol bo pos = if (any (== (O,O,O)) combos) then True else False where { [a,b,c,d,e,f,g,h,i] = pos; combos = [(a,b,c),(d,e,f),(g,h,i),(a,d,g),(b,e,h),(c,f,i),(a,e,i),(c,e,g)] }
06:59:44 <vincenz> data Pos = O | X | Empty deriving (Eq_
07:00:07 <tromp_> why do you call that Pos? X is not a position?!
07:00:31 <tromp_> it's a Piece or something
07:00:35 <Esch> *shrug* at this time, it's pretty much nearing immaterial
07:00:51 <kosmikus> dblhelix: pong
07:00:52 <Esch> deriving (Eq) doesn't seem to be doing the magic :(
07:01:08 <vincenz> Esch: when did you get this assignment?
07:01:13 <Esch> wait, i'm dumb
07:01:17 <shapr> Me me!
07:01:21 <Esch> tuesday, heh :3
07:01:21 * shapr cannot speak!
07:01:27 <dblhelix> kosmikus: why are you (lhs2TeX) inserting extra leading spaces in my verbatim environments?
07:01:31 <Esch> the trouble is that i'm going out of town for a few days, where i won't be able to turn it in
07:01:42 <Esch> thus i've had to learn haskell (or attempt it, at least) in the last day or so
07:02:17 <Esch> ok, i'm dumb, by the way; i was modifying a version of Pos that was commented out
07:02:25 <Esch> sorry for the frustration i've undoubtably caused
07:02:55 * shapr hugs kosmikus 
07:03:08 <shapr> @karma+ kosmikus # for Haskell Workshop 2006! w00!
07:03:09 <lambdabot> kosmikus's karma raised to 2.
07:03:22 <vincenz> donde?
07:03:53 <Esch> cool, that solution works like a charm
07:03:54 <kosmikus> shapr: ?
07:03:55 <shapr> donde esta?
07:03:58 <vincenz> shapr: si
07:04:01 <Esch> time to start guessing at each remaining position
07:04:14 <shapr> kosmikus: I'm just being appreciative of the work you're putting in for HW.
07:04:30 <vincenz> y quando?
07:04:37 <shapr> kosmikus: I've only organized half of EuroHaskell 2004, and I bet HW is *lots* more work.
07:04:45 <kosmikus> dblhelix: I don't know. Has this changed recently? I don't think I've ever even looked at the verbatim code in lhs2TeX.
07:05:11 <dblhelix> kosmikus: no, I think it has been there for a while now
07:05:32 <kosmikus> shapr: not necessarily. you probably have done local organisation, too. I don't have to do any of that, because the ICFP local chair is doing all the hard work.
07:05:55 <shapr> I had a local chair too =)
07:06:10 <dblhelix> kosmikus: it's kind of frustrating when you want to include a piece of ordinary verbatim text in a lhs2TeX-typesetted document
07:06:12 <shapr> Björn Bringert did all the onsite organization with support from John Hughes.
07:06:30 <kosmikus> shapr: it's just my job to ask people to submit papers [listen, everybody ;)], distribute them to the PC, review, discuss, and inform the authors.
07:06:34 <dblhelix> kosmikus: it has its advantages too, though: it force me to master fancyvrb :)
07:06:35 <shapr> Oh, and Anders Carlsson did the nifty signs.
07:07:23 * mathrick tries to think of a semi-intelligent way to implement bubble sort in haskell
07:08:09 <shapr> mathrick: Combine until with foldr, and, and x>y ?
07:08:25 <mathrick> until?
07:08:29 <shapr> @type until
07:08:30 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:08:30 * mathrick doesn't know that keyword
07:08:38 <mauke> it's not a keyword
07:08:40 <mathrick> aha
07:09:01 <mathrick> and combine, is that a function too?
07:09:01 <mauke> > until (0 ==) (/ 2) 1
07:09:02 <lambdabot> 0.0
07:10:04 <vincenz> LOL
07:10:07 <bolrod> :)
07:10:09 <vincenz> at first I thought lambdabot was raising his eyebrows
07:10:50 <vincenz> @pl \x -> x `op` 
07:10:50 <lambdabot> (line 1, column 14):
07:10:50 <lambdabot> unexpected end of input
07:10:50 <lambdabot> expecting space or simple term
07:10:50 <vincenz> @pl \x -> x `op` x
07:10:51 <lambdabot> join op
07:10:54 <vincenz> @type join
07:10:55 <lambdabot> Not in scope: `join'
07:11:01 <mathrick> @type combine
07:11:01 <lambdabot> Not in scope: `combine'
07:11:04 <mauke> @type Monad.join
07:11:05 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
07:11:07 <vincenz> > until (join (!=)) not True
07:11:08 <lambdabot>  Not in scope: `!='
07:11:12 <vincenz> > until (join (<>)) not True
07:11:13 <lambdabot>  Not in scope: `<>'
07:11:17 <mauke> /=
07:11:19 <vincenz> > until (join (/=)) not True
07:11:19 <mathrick> vincenz: /= ?
07:11:23 <lambdabot> Terminated
07:11:47 <vincenz> err...
07:11:56 <vincenz> I don't get the type join being used here
07:12:06 <vincenz> \x -> x op x == join op...
07:12:16 <Esch> ok, i have my solution...now all i need to do is go from an index back to a coordinate
07:12:29 <vincenz> c div 3 +1
07:12:29 <Lenny1729> hi all
07:12:32 <vincenz> c mod 3 + 1
07:12:54 <vincenz> > 8 `mod` 3 + 1
07:12:54 <lambdabot> 3
07:12:59 <vincenz> > 8 `div` 3 + 1
07:13:00 <lambdabot> 3
07:13:05 <mauke> op :: a -> a -> a; join :: m (m a) -> m a
07:13:19 <vincenz> oh the m is ->
07:13:31 <Lenny1729> Is there a standard function in the libraries that come with ghc for replacing an item in a list with another item?
07:13:32 <vincenz> of ..  some sort
07:13:39 <vincenz> mauke: funky tho
07:13:42 <mauke> op :: (->) a ((->) a a)
07:13:45 <mathrick> vincenz: I'm still not sure how to express the end condition
07:13:50 <mauke> the monad is (->) a
07:14:25 <vincenz> > map (\x -> (x `mod` 3 + 1 x `div` 3 + 1)) [0..8]
07:14:26 <Esch> sweet lord, i'm done
07:14:26 <lambdabot>  add an instance declaration for (Num (a -> a))
07:14:31 <vincenz> > map (\x -> (x `mod` 3 + 1, x `div` 3 + 1)) [0..8]
07:14:32 <lambdabot> [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
07:15:09 <Esch> thank you, vincenz, tromp_, shapr, jethr0
07:15:19 <mauke> @pl map (\x -> (x `mod` 3 + 1, x `div` 3 + 1)) [0..8]
07:15:19 <lambdabot> map (ap ((,) . (1 +) . (`mod` 3)) ((1 +) . (`div` 3))) [0..8]
07:15:21 <vincenz> Esch: give us part of your grade!
07:15:31 <vincenz> mauke: some things are too ugly to be pl'd
07:15:33 <Esch> i feel much more confident about haskell :D and much more certain that there's no way i'm going to be able to wake up at 11am tomorrow
07:15:34 <mauke> yep
07:15:44 <Esch> or endure a train trip southward without falling asleep and missing my stop
07:15:54 <Esch> er, today! 11am in 4 hours, i mean
07:15:56 <mauke> pretty much anything that uses a lambda arg more than once in the body gets uglier
07:16:06 <vincenz> mauke: I disagree
07:16:09 <vincenz> @pl \x -> x `op` x
07:16:10 <lambdabot> join op
07:16:16 <vincenz> :P
07:16:26 <mauke> ok, now do something more complex
07:16:33 <vincenz> @pl \x -> x `complex_op` x
07:16:33 <lambdabot> (line 1, column 9):
07:16:33 <lambdabot> unexpected "`"
07:16:33 <lambdabot> expecting variable, "(", operator or end of input
07:16:52 <vincenz> @pl \x -> x `complex_op` x
07:16:53 <lambdabot> (line 1, column 9):
07:16:53 <lambdabot> unexpected "`"
07:16:53 <lambdabot> expecting variable, "(", operator or end of input
07:16:56 <vincenz> that's odd
07:16:56 <mauke> @pl o_0
07:16:57 <lambdabot> o_0
07:17:04 <vincenz> it doesn't support _ in `?
07:17:06 <vincenz> @pl \x -> x `complexop` x
07:17:07 <lambdabot> join complexop
07:17:12 <vincenz> @pl \x -> x `complex_op` x
07:17:12 <lambdabot> (line 1, column 9):
07:17:12 <lambdabot> unexpected "`"
07:17:12 <lambdabot> expecting variable, "(", operator or end of input
07:17:26 <vincenz> yep
07:17:27 <Esch> http://rafb.net/paste/results/QwswSa46.html here's the entirety of it
07:17:28 <vincenz> seems flawed
07:17:36 <Esch> i took out the board printing, sorry :| all i need to do is output answers, fortunately
07:17:40 <Esch> it was very nice, though
07:17:41 <vincenz> mauke: you're correct, pl is not good for complex ops
07:18:22 <vincenz> err
07:18:27 <vincenz> why are you doing mod p 4
07:18:29 <vincenz> I said
07:18:32 <vincenz> p `mod` 3 +1
07:18:38 <vincenz> aka (p `mod` 23) + 1
07:18:41 <vincenz> aka (p `mod` 23) + 1
07:18:44 <vincenz> s/23/3
07:18:57 <Lenny1729> Is there a standard function that generates a list from a list but the item at index is replaced by another item? Something like  update :: [a] -> Int -> a -> [a] ??
07:19:07 <vincenz> Lenny1729: yes
07:19:31 <vincenz> replace l n v = let (a, _:b) = splitAt n l in a ++ (v:b)
07:19:41 <vincenz> that seems to be a recurring question
07:19:49 <vincenz> you're the third today
07:19:53 <Lenny1729> oh thank you!
07:20:10 <vincenz> > let replace l n v = let (a, _:b) = splitAt n l in a ++ (v:b) in replace "abcdef" 3 x
07:20:10 <lambdabot>  Not in scope: `x'
07:20:13 <vincenz> > let replace l n v = let (a, _:b) = splitAt n l in a ++ (v:b) in replace "abcdef" 3 'x'
07:20:14 <lambdabot> "abcxef"
07:20:44 <Lenny1729> arrays have an operator (//). An standard operator like this for lists would be very useful
07:20:50 <vincenz> Lenny1729: not really
07:21:05 <vincenz> @type (Data.Array.//)
07:21:06 <lambdabot> forall e i.
07:21:06 <lambdabot>        (GHC.Arr.Ix i) =>
07:21:06 <lambdabot>        GHC.Arr.Array i e -> [(i, e)] -> GHC.Arr.Array i e
07:21:20 <Lenny1729> vincenz: inefficient??
07:21:22 <vincenz> Lenny1729: I've never ound the use 
07:21:25 <vincenz> for it
07:21:33 <vincenz> in fact until today I never used such a construct
07:21:45 <vincenz> and yeah, lists aren't designed for random-access
07:22:03 <Lenny1729> oh.. looks like I am doing sth. wrong, I am often in the need of such an operator
07:22:17 <Lenny1729> Maybe I should start using arrays
07:22:23 <vincenz> or mas
07:22:24 <vincenz> maps
07:27:45 <ihope> > length "it hasn't"
07:27:46 <lambdabot> 9
07:27:49 <ihope> > length "it's not"
07:27:50 <lambdabot> 8
07:28:00 <vincenz> > length "no!"
07:28:01 <lambdabot> 3
07:28:08 <vincenz> ihope: optimizing a paper lenght?
07:28:21 <ihope> :-)
07:28:34 <ihope> Close.
07:28:40 <bolrod> haha
07:29:07 <ihope> I'm trying to make this one thing as long as possible, without including an obvious way to make it shorter.
07:29:10 <bolrod> thats cool...    make it switch out words in a paper to come close to a given length
07:29:13 <ihope> > length "it has not"
07:29:14 <lambdabot> 10
07:29:26 <vincenz> > length "it does not have"
07:29:27 <lambdabot> 16
07:29:28 <bolrod> it certainly does not have
07:29:30 <bolrod> :)
07:29:31 <vincenz> ihope: you're trying to create filler or remove filler?/
07:29:42 <ihope> Create.
07:29:59 <ihope> > length (show pi)
07:30:00 <vincenz> > length "After lengthy experimentation it is our experience that the current .... certainly does not have any .."
07:30:00 <lambdabot> 17
07:30:01 <lambdabot> 103
07:30:18 <ihope> vincenz: yeah, that'll work :-)
07:30:26 <bolrod> ++ "At all."
07:30:28 <bolrod> :)
07:30:51 <vincenz> it is our inequivocable experience
07:31:13 <sjanssen> ihope: if you say "After lengthy experimentation ..." more than 5 times in your paper, somebody is going to catch on ...
07:31:19 <ihope> :-)
07:31:29 <vincenz> sjanssen: obviously
07:31:35 <bolrod> haha
07:31:39 <sjanssen> it might be a fun read anyway
07:31:46 <vincenz> the first one is "After length experimentation ... "  then you have "Using this rather intricate experimentation..."
07:32:11 <ihope> After much controlled trial and error..
07:32:20 <ihope> Eeph, double period.
07:32:31 <bolrod> "In search of the truthness of the following statement"
07:32:35 <vincenz> After much controlled trial and error within a fixed set of assumptions that we shall not publish here for lack of space ....
07:32:40 <vincenz> notice hwo the "lack of space" always sounds cool
07:32:58 <sjanssen> haha, yeah like you've got something too good for the audience to read
07:33:13 <vincenz> even though half the paper is filler :D
07:33:16 <earthy> and takes up space. :P
07:33:19 <vincenz> and you could prolly write it in two lines
07:34:42 <ihope> Now, it's time for a factorial function.
07:34:44 <bolrod> it is a speach?... you could start jumping up and down.. and yell furiously
07:35:11 <vincenz> nah with speech you don't awnt to detract
07:35:20 <vincenz> except with flashy graphics and animations
07:35:23 <ihope> factorial n = factorial' 1 1 n
07:35:25 <bolrod> seems microsoft has great success with it
07:35:31 <ihope> Hmm...
07:35:34 <ihope> I'll come back to that.
07:35:36 <mathrick> @docs random
07:35:37 <lambdabot> random not available
07:35:43 <mathrick> @hoogle random
07:35:43 <lambdabot> System.Random.Random :: Random a
07:35:43 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
07:35:43 <lambdabot> System.Random.RandomGen :: RandomGen g
07:35:47 <vincenz> "look at this flashy figure while I hide the fact that this presentation shows nothing new"'
07:35:47 <sjanssen> ihope: what kind of factorial was that?
07:35:59 <ihope> A long one.
07:36:14 <sjanssen> vincenz: ideally, you'd only mutter that under your breath
07:36:19 <ihope> factorial' a c 1 = a*c
07:36:25 <vincenz> sjanssen: no if you really have blingbling slides you can say it out loud
07:36:42 <ihope> factorial' a c r = factorial' (a*c) (c+1) (r-1)
07:36:45 <ihope> Does that work?
07:37:42 <ihope> Yes, it does!
07:37:51 <vincenz> let {factorial' 0 a = a; factorial' n a = factorial' (n-1) (a*n)} in factorial 40 1
07:37:55 <vincenz> > let {factorial' 0 a = a; factorial' n a = factorial' (n-1) (a*n)} in factorial' 40 1
07:37:55 <bolrod> let fac a = foldr (*) 1 [1..a] in fac 10
07:37:56 <lambdabot> 815915283247897734345611269596115894272000000000
07:38:00 <bolrod> >let fac a = foldr (*) 1 [1..a] in fac 10
07:38:11 <bolrod> ...
07:38:16 <bolrod> > let fac a = foldr (*) 1 [1..a] in fac 10
07:38:17 <lambdabot> 3628800
07:38:19 <bolrod> yes
07:38:23 <vincenz> \o/
07:38:28 <vincenz> \
07:38:31 <vincenz> dog
07:38:33 <tromp_> > scanl (*) 1 [1..10]
07:38:34 <lambdabot> [1,1,2,6,24,120,720,5040,40320,362880,3628800]
07:38:35 <vincenz> (doh even)
07:38:43 <ihope> bolrod: would foldl be more efficient?
07:38:53 <mathrick> umm, so how do I search docs for, say, random?
07:38:54 <sieni> > product [1..10]
07:38:55 <lambdabot> 3628800
07:38:57 <mathrick> "random" even
07:38:58 <bolrod> foldr is recursive.. your function is recursive?
07:39:03 <bolrod> it sure is shorter
07:39:11 <vincenz> > head $ drop 10 $ scanl (*) 1 [1..]
07:39:11 <lambdabot> 3628800
07:39:15 <ihope> I like my function.
07:39:16 <bolrod> plus you dont need to give the 1 as parameter
07:39:24 <vincenz> let faclist = scanl (*) 1 [1..]
07:39:34 <vincenz> let fac n = head $ drop n faclist
07:39:47 <vincenz> and it's automatically cached :D
07:40:01 <mathrick> @index random
07:40:02 <lambdabot> System.Random
07:40:07 <sjanssen> vincenz: I don't think the caching is a good thing is the case
07:40:12 <mathrick> @docs System.Random.random
07:40:12 <Esch> actually, heh, i'm having more trouble with this than i expected
07:40:13 <lambdabot> System.Random.random not available
07:40:15 <vincenz> sjanssen: sure it is
07:40:29 <bolrod> sjanssen: why not.. why else did you buy all those Megs of RAM
07:40:30 <bolrod> :)
07:40:30 <Esch> you'd convert from an index to a coordinate via (index%width, index/width), right?
07:40:33 <sjanssen> there's overhead with the memoization, and fac is still O(n)
07:40:40 <sieni> > foldl1 (*) [1..10]
07:40:40 <lambdabot> 3628800
07:40:41 <bolrod> you got to use it for something
07:40:46 <vincenz> sjanssen: right but a smaller O(n)
07:40:48 <tromp_> fac is O(n^2)
07:40:51 <vincenz> no multiplication
07:40:57 <vincenz> tromp_: no it's not
07:41:01 <Esch> i'm being forced to use div index width to do the division, but i get 'funny' answers
07:41:03 <tromp_> where n is size of number
07:41:06 <ihope> I want factorial in O(n log n)
07:41:06 <vincenz> tromp_: nope
07:41:09 <Esch> i'm sure it has something to do with whatever rounding div uses
07:41:11 <vincenz> tromp_: fac is O(n)
07:41:18 <vincenz> factorial is O(n)
07:41:22 <vincenz> or you're a dimwit
07:41:26 <ihope> :-)
07:41:29 <tromp_> keep dreaming, vincenz:)
07:41:52 <vincenz> > let factorial n = factorial' n 1 where factorial' 0 a = a; factorial' n a = (n-1) (a*n)
07:41:52 <lambdabot>  parse error on input `}'
07:42:06 <vincenz> > let factorial n = factorial' n 1 where {factorial' 0 a = a; factorial' n a = factorial' (n-1) (a*n)}
07:42:07 <lambdabot>  parse error on input `}'
07:42:17 <Esch> it's hard to believe that i'm hung up on this :|
07:42:20 <tromp_> try multiplying (fac n) with (n+1) in constant time...
07:42:22 <mathrick> hey guys, how do I RTFM?
07:42:29 <bolrod> hahahhaa
07:42:30 <vincenz> tromp_: it's constant time
07:42:35 <dcoutts> the extra log n is for the size of the number, since doing arithmatic takes log n time
07:42:38 <ihope> @quote vincenz
07:42:39 <lambdabot>  factorial is O(n) or you're a dimwit
07:42:46 <ihope> Well, there you have it.
07:42:47 <bolrod> first you OMGLOL then you ROFLLOL  then you're done
07:42:52 <ihope> LOL.
07:42:57 <tromp_> vincenz is the dimwit here:(
07:43:13 <vincenz> tromp_: heh if you want to go down to bits it's incorrect
07:43:30 <dcoutts> vincenz, we normally think of (+), (*) etc being constant time because we work with machine sized number
07:43:32 <vincenz> cause then you're not taking into account parallel bits, cache-issues, cpu-pipeline stalls
07:43:43 <Esch> god, how i wish i had some control over types in haskell
07:43:52 <vincenz> dcoutts: yes
07:43:54 <ihope> Esch: what do you mean?
07:44:01 <tromp_> what's the size of fac n ?
07:44:10 <dcoutts> but with big ints they turn into log time operations
07:44:21 <vincenz> yes but the question is where do you put the abstraction layer
07:44:27 <dcoutts> log in the size of the number / linear in the number of bits
07:44:47 <vincenz> cause if you want to look at that, then you can also put your GC in your O calculations
07:44:51 <tromp_> fac n has linear size
07:44:52 <vincenz> or pipeline/cache stalls
07:44:56 <Esch> well, i'm having some kind of weird rounding issue with div x 3
07:45:03 <vincenz> tromp_: log n
07:45:14 <cm> dons, are you there?
07:45:25 <Esch> i'm trying to convert from an index to a coordinate via (mod i 3, div i 3), but div isn't staying very constant
07:45:52 <tromp_> think again vinc
07:45:58 <cm> Philippa?
07:45:59 <vincenz> tromp_: nope you think again
07:46:07 <vincenz> tromp_: unless you use a sequence of 1's to representa a number
07:46:10 <vincenz> a number has log n size
07:46:22 <ihope> Esch: I'm not sure what you mean, but maybe type annotations will help.
07:46:24 <tromp_> i'm asking about fac n, not n itself
07:46:28 <vincenz> ah
07:46:32 <tromp_> you're not even reading
07:46:34 <Esch> can i use the > command here?
07:46:37 <ihope> > 1 :: Double
07:46:38 <lambdabot> 1.0
07:46:40 <ihope> Esch: yep
07:47:07 <Esch> > [ ((mod x 4), (div x 4)) | x <- [1..9] ]
07:47:08 <lambdabot> [(1,0),(2,0),(3,0),(0,1),(1,1),(2,1),(3,1),(0,2),(1,2)]
07:47:17 <vincenz> tromp_: anyways, you can argue a million ways lie this, O notation was never meant to be exact, it lacks a lot of details, it's all a question about your abstraction layer, which in case of integer operations has been decided to be put to O(1)
07:47:22 <vincenz> s/lie/like
07:47:23 <Esch> as you can see, the second coordinate's ok until right at the end, where it goes from 1 to 2 in mid-row
07:47:46 <Esch> basically, i want to translate from indexes to coordinates in the 1..3 domain
07:48:03 <cm> mod 3, + 1
07:48:06 <tromp_> not when it take a megabyte to store the number
07:48:08 <cm> o_0
07:48:30 <tromp_> it's stupid to say multiplying two 10000 digit numbers is O(1)
07:48:31 <vincenz> tromp_: in which case yo'd have a lot of other issues like cache-stalls
07:48:34 <ihope> > 2^(2^20) -- one megabyte to store this number
07:48:36 <sjanssen> I think the way to solve vincez and tromp_'s disagreement is to say factorial performs O(n) multiplications
07:48:38 <lambdabot> Terminated
07:48:57 <ihope> @quote tromp
07:48:57 <lambdabot>  vincenz is the dimwit here:(
07:49:04 <ihope> @quote tromp_
07:49:04 <lambdabot> tromp_ hasn't said anything memorable
07:49:11 <ihope> Okay, it works.
07:49:12 <cm> Prelude> [((x-1) `mod` 3 + 1, (x-1) `div` 3 + 1) | x <- [1..9]]
07:49:13 <cm> [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
07:49:31 <Esch> ah, heh, i'm dumb; thank you!
07:49:37 <vincenz> tromp_: it's also stupid to say that multiplying two 10000 digits will be directly related to 10000 if you count cache-stalls
07:49:47 <vincenz> tromp_: it's all about agreed abstraction layers
07:49:51 <cm> so, where do I get some precompiled version of hs-plugins for win32?
07:49:59 <tromp_> it's about common sense
07:50:03 <vincenz> yes
07:50:12 <sjanssen> vincenz: cache stalls are different from the theoretical performance of the algorithm
07:50:19 <vincenz> sjanssen: that all depends
07:50:26 <vincenz> the number of bits of an in are 32
07:50:30 <vincenz> but that's also nontheoretic
07:50:36 <vincenz> if you made a computer with infinite bit numbers
07:50:41 <vincenz> you'd be back to O(N)
07:50:45 <cm> o_0
07:50:59 <vincenz> so stop bullshitting, it's all about where you place "theory" and where you place "implementation"'
07:51:05 <vincenz> and both are as arbitrary as the other
07:51:18 <sjanssen> vincenz: O notation breaks down when computers can do work on infinite things
07:51:35 <vincenz> O notation has never been a precise tool and lacks a lot of necessary detailis
07:51:52 <vincenz> especially on contemporary platforms
07:52:22 <sjanssen> vincenz: I don't think there are any contemporary platforms that actually change the asymptotic behavior of an algorithm
07:52:23 <cm> who had too much of the CS 101 cool-aid?
07:52:45 <vincenz> sjanssen: yes but if you want to talk about algorithmic behaviour, how two ints multiply falls under the abstraction layer
07:52:58 <tromp_> computing fac (2*n) takes roughly four times as long as fac n, over a wide range of n
07:53:03 <mathrick> what is the function to generate a list of n repeated values?
07:53:17 <vincenz> tromp_: computation time is not directly correlated to O-notation
07:53:38 <vincenz> > replicate 9 1
07:53:39 <lambdabot> [1,1,1,1,1,1,1,1,1]
07:54:13 <sjanssen> vincenz: you can make a case either way, but it is definitely valid to say that factorial is Omega(n)
07:54:36 <sjanssen> vincenz: just as it is valid to say that factorial performs O(n) multiplications
07:54:52 <vincenz> the problem is that you're mixing peas and carrots
07:55:01 <vincenz> if you want to talk about computation time, then O notation is not the correct abstractin
07:55:04 <vincenz> for instance
07:55:09 <vincenz> if you want to access memory
07:55:16 <vincenz> you can possibly access 1 and then 10 elements
07:55:20 <vincenz> and still have ~= the same time
07:55:23 <vincenz> due to caching behaviur
07:55:55 <vincenz> I'm against O notation, but if you want to use that as premise, you shouldn't look at the nuts and bolts
07:56:03 <sjanssen> vincenz: what if I wrote my pseudo code such that I made the growing integer's explicit?
07:56:03 <vincenz> and assume an idealized machine
07:56:20 <dcoutts_> yeah cache makes real algorithm timing so hard to estimate
07:56:31 <ihope> I want a decision problem that's ACKSPACE-complete.
07:56:35 <vincenz> sjanssen: then you'd have to explicitly mention that
07:56:40 <dcoutts_> and yet it can have an order of magnitude effect on runtime
07:56:50 <vincenz> sjanssen: assumed hypothesis is that the int falls inside a compiler blackbox
07:57:01 <vincenz> dcoutts_: even more
07:57:08 <vincenz> 2 orders
07:57:14 <vincenz> 3 orders if you're getting paged access
07:57:27 <dcoutts_> yep :-(
07:57:29 <dcoutts_> vincenz, if we use Integer rather than Int then we really have to account for log n behaviour
07:57:33 <sjanssen> vincenz: I disagree.  O(1) multiplication assumption is a common one, but it is not fundamental to the big O notation
07:57:42 <vincenz> dcoutts_: I disagree I think that falls under the abstraction layer
07:57:51 <vincenz> dcoutts_: O notation assumes an idealized machine
07:57:57 <vincenz> in an idealized machine your ints are infinitely sized
07:58:25 <dcoutts_> ok, fair enough it depends on your machine model
07:58:32 <vincenz> yu don't assume that a number wraps in algorithm design
08:00:46 <dcoutts_> I think in practice that people do make some distinction between numbers they expect to be big and thoes they do not
08:01:02 <dcoutts_> eg numbers that are used to index data structures
08:01:17 <vincenz> dcoutts_: right and next time I ask you the O-notation of fac,, I could argue that I use a linear encoding for numbers where I basically have number = number of bits that are 1
08:02:14 <cm> this discussion is stupid.
08:02:18 <dcoutts_> vincenz, yes, if we're going to be picky then we do need to be precise about the machine model
08:02:36 <vincenz> dcoutts_: right but hte whole idea behind the O-notatiion was to be machine independent
08:02:39 <vincenz> aka idealized machine
08:02:43 <dcoutts_> but most of the time people are doing informal O() estimations
08:03:05 <dcoutts_> I think we do use a model that mostly fits real machines
08:03:06 <cm> we simply assume a certain set of operations to be primitive/O(1).
08:03:13 <dcoutts_> and real machines are all pretty similar
08:03:51 <dcoutts_> the trickyst bit is indeed if we consider bounded or unbounded numbers
08:04:32 <Wallbraker> Can I ask of some assistance?
08:04:48 <vincenz> dcoutts_: unless you're comparing different integer implementations, which I think would be very rare the assumption is gonna be O(1)
08:04:49 <shapr> go for it
08:04:55 <tromp_> if the output is exponential in the input then looking at the size of numbers is important
08:05:00 <dcoutts_> most of the time people pretend that they can use numbers as if they were unbounded but assume a complexity as if they were bounded.
08:05:00 <Wallbraker> potato :: ( a -> a -> a ) -> Integer
08:05:00 <Wallbraker> potato f = f 1 2
08:05:09 <Wallbraker> oh do I make that work
08:05:10 <vincenz> tromp_: you're mistaking O-notation with observed behaviour
08:05:12 <Wallbraker> how*
08:05:19 <vincenz> dcoutts_: correct
08:05:39 <vincenz> Wallbraker: why does it need to be a->a->aM
08:05:41 <vincenz> ?
08:05:49 <dcoutts_> vincenz, and most of the time they can get away with that and have it still resemble reality, but not always.
08:06:03 <Wallbraker> vincenz: because I want to be able to use it with doubles to...
08:06:17 <vincenz> hmm
08:06:23 <vincenz> this smells like the monomorphism restriction
08:06:33 <Wallbraker> okay...
08:06:43 <Wallbraker> using ghc btw
08:06:44 <dcoutts_> potato :: Num a => ( a -> a -> a ) -> Integer
08:06:48 <dcoutts_> perhaps?
08:07:27 <dcoutts_> @type let potato f = f 1 2 in potato
08:07:28 <lambdabot> forall t t1 t2.
08:07:28 <lambdabot>             (Num t, Num t1) =>
08:07:28 <lambdabot>             (t -> t1 -> t2) -> t2
08:07:45 <Wallbraker> nope same problem
08:09:30 <vincenz> Wallbraker: what does your real potato look like?
08:10:13 <Wallbraker>         preform :: Value -> Value -> ( a -> a -> a ) -> Value
08:10:13 <Wallbraker>         preform (Int i1) (Int i2) f = Int (f i1 i2)
08:10:13 <Wallbraker>         preform (Dou d1) (Int i2) f = Dou (d1 + (fromInteger i2))
08:10:13 <Wallbraker>         preform (Int i1) (Dou d2) f = Dou ((fromInteger i1) + d2)
08:10:13 <Wallbraker>         preform (Dou d1) (Dou d2) f = Dou (d1 + d2)
08:10:23 <vincenz> ghc -fno-monomorphism-restrictio
08:10:29 <vincenz> ...n
08:10:40 <Wallbraker> hehe the 3 last line are wrong
08:10:43 <Wallbraker> they should be calling f
08:10:49 <Wallbraker> ah okay
08:10:52 <Wallbraker> thanks
08:10:56 <vincenz> I don't know if that's it
08:14:03 <Wallbraker> got a diffrent error with -fglasgow-exts
08:43:28 <eurleif> What's wrong with "instance Integral a => Foo a"?
08:46:20 <ihope> What if you have an instance Foo a => Integral a somewhere?
08:46:32 <ihope> There's a switch that'll allow that declaration, though. /me looks
08:48:10 <ulfdoz> ihope: Isn't it (Foo a, Integral a) => a?
08:48:52 <ihope> ulfdoz: no, I don't think so
08:55:05 <mathrick> > print getStdRandom(randomR (1, 6))
08:55:05 <lambdabot> Couldn't match `IO ()' against `t -> t1'
08:55:12 <mathrick> now how do I use that thing?
08:55:58 <Cale> mathrick: hm?
08:56:19 <mathrick> how do I get a random integer in given range?
08:56:34 <ihope> Well, you have to use the IO monad.
08:56:37 <mathrick> rollDice becomes some "IO Integer", which I have no clue how to use
08:56:58 <ihope> rollDice >>= someFunctionThatTakesAndIntegerAndReturnsAnIOValue
08:57:03 <mathrick> ihope: how do I do that?
08:57:05 <Cale> Well, you don't *have* to use the IO monad, but pretty much unless you want the same pseudorandom numbers every time
08:57:06 <mathrick> whoa
08:57:08 <ihope> And remember return.
08:57:18 <mathrick> no, I just want a random int
08:57:26 <ihope> Well, will psuedorandom do?
08:57:29 <mathrick> yes
08:57:33 <tromp_> you have to thread some rng state around
08:58:00 <Cale> > let gen = mkStdGen seed in randomR (1,6) gen
08:58:01 <lambdabot>  Not in scope: `seed'
08:58:07 <Cale> > let seed = 0; gen = mkStdGen seed in randomR (1,6) gen
08:58:08 <lambdabot> (6,40014 40692)
08:58:10 <mathrick> mkRandomList n = fst (foldr foo ([], mkStdGen 20) (replicate n False))
08:58:10 <mathrick>      where 
08:58:10 <mathrick>        foo el list =  trace (show list) ((pair ((: (fst list)) . fst, snd)) (next (snd list)))
08:58:13 <mathrick> this works
08:58:15 <mathrick> but damn
08:58:24 <ihope> iterate ((`mod` productOfTwoBigPrimeNumbers) . (^2)) 2
08:58:27 <mathrick> if that's what's needed to get a list of random integers...
08:58:31 <Cale> > let seed = 0; gen = mkStdGen seed in randomRs (1,6) gen
08:58:31 <lambdabot> [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,
08:58:31 <lambdabot> 3,5,6,2,4,5,3,2,2,4,2,2,6,3,4,4,1,1,1,2,2,3,2,4,5,3,5,3,4,4,6,3,2,6,6,4,4,
08:58:31 <lambdabot> 1,2,3,5,6,4,5,6,2,6,3,2,2,3,1,6,6,3,3,2,4,4,5,1,2,3,2,5,3,3,6,3,2,3,2,2,6,
08:58:31 <lambdabot> 5,5,4,6,2,4,6,2,2,3,3,2,4,3,1,2,5,4,1,2,6,4,4,4,5,4,1,3,3,4,2,6,2,5,1,3,6,
08:58:31 <lambdabot> 3,6,3,6,1,4,1,4,3,2,5,3,4,4,4,1,6,4,4,6,2,3,5,4,1,5,3,1,1,1,4,3,4,3,3,3,4,
08:58:34 <lambdabot> [23 @more lines]
08:58:34 <ihope> That should be good enough.
08:58:45 <ihope> iterate ((`mod` 35) . (^2)) 2
08:58:48 <ihope> > iterate ((`mod` 35) . (^2)) 2
08:58:49 <lambdabot> [2,4,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,
08:58:49 <lambdabot> 11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,
08:58:49 <lambdabot> 11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,
08:58:49 <lambdabot> 11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,
08:58:49 <lambdabot> 11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,11,16,
08:58:51 <lambdabot> [24 @more lines]
08:58:52 <ihope> Um.
08:58:56 <Cale> you could do it like that
08:59:02 <ihope> That's why I said *big* prime numbers.
08:59:03 <Cale> (like I did :)
08:59:25 <vincenz> you could use a separate thread with an mvar that sleeps from time to itme and otherwise keeps updating the mvar with random... and then read from that mvar
08:59:39 <mathrick> Cale: what is randomRs?
08:59:41 <Cale> vincenz: well, then you'd be in IO anyway
08:59:45 <ihope> > iterate ((`mod` (703300573*703301369)) . (^2)) 2
08:59:45 <vincenz> true
08:59:46 <lambdabot> [2,4,16,256,65536,4294967296,145350608762327447,250478397187957128,
08:59:46 <lambdabot> 437260004096632937,28116368578033740,361198461582144592,76340744684052553,
08:59:46 <lambdabot> 231440123764258366,390129380742748113,80629098341671746,347333012901839606,
08:59:46 <lambdabot> 213424760854776002,179081706848932248,255244487100808489,419897308447989057
08:59:46 <lambdabot> ,149184501951786491,301659205843650576,47006788399106049,444681219303836120
08:59:47 <lambdabot> [23 @more lines]
08:59:50 <ihope> There we go.
09:00:03 <Cale> mathrick: takes a generator and gives you an infinite list of pseudorandom values
09:00:28 <mathrick> Cale: and how do I get single value out of it?
09:00:37 <Cale> take the head of the list
09:00:38 <vincenz> !!
09:00:48 <mathrick> Cale: but won't it return the same every time?
09:00:59 <Cale> well, yeah, then throw the head away
09:01:06 <Cale> and use the tail for the rest :)
09:01:11 <vincenz> use a state moonad
09:01:15 <vincenz> State [Int]
09:01:21 <Cale> If you need a monad to do this, I have one :)
09:01:24 <mathrick> I have no clue what monads are
09:01:25 <mathrick> so no
09:01:26 <vincenz> getRandom = do (x:r) <- get; put r; return x
09:01:46 <vincenz> \o/
09:01:57 <mathrick> Cale: but where do I keep it in the meantime?
09:02:12 <Cale> wherever :)
09:02:19 <mathrick> this is not helpful
09:02:19 <vincenz> far from any nuclear devices
09:02:20 <mathrick> really
09:02:26 <mathrick> I believe you can do it
09:02:27 <Cale> you can pass it around through your function parameter
09:02:28 <mathrick> but I can\t
09:02:44 <Cale> one sec
09:02:48 <vincenz> mathrick: you can't pass a list as an extra param?
09:02:51 <vincenz> oldfunction x y = ...
09:02:55 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
09:02:58 <Cale> read that :)
09:03:01 <mathrick> k
09:03:02 <vincenz> newfunction x y l = ....(head l) .... .newfunction ... tail l
09:05:00 <mathrick> ouch
09:05:06 <mathrick> why is it so complex?
09:05:22 <Cale> hm?
09:05:24 <EtnaRosso> hi all
09:05:29 <Cale> hello
09:05:38 <Cale> mathrick: how could it be made simpler?
09:05:50 <vincenz> EtnaRosso: buongiorno
09:05:53 <dcoutts_> evening xerox 
09:05:56 <mathrick> Cale: dunno, like int = random (6); ?
09:06:00 <vincenz> EtnaRosso == xerox?
09:06:02 <mathrick> int foo even
09:06:08 <vincenz> I highly doubt that
09:06:15 <vincenz> one is from the south, the other is from the north
09:06:17 <EtnaRosso> oh no
09:06:18 <Cale> mathrick: If random was a function, it'd always return the same value, since that's what functions do
09:06:21 <dcoutts_> xerox, seen this yet? http://haskell.org/gtk2hs/archives/2006/03/09/cops-and-robbers/
09:06:25 <EtnaRosso> EtnaRosso/=xerox
09:06:26 <vincenz> \o/
09:06:34 <vincenz> my pretty gui!
09:06:43 <dcoutts_> yep :-)
09:06:43 <vincenz> (threaded at that :)
09:07:03 <mathrick> Cale: well, yeah
09:07:14 <dcoutts_> I wonder if I should start a place to put bits of interesting gtk2hs code
09:07:15 <mathrick> but uh, it's so complex
09:07:21 <Cale> mathrick: It's not so bad
09:07:26 <Cale> you get a generator
09:07:29 <dcoutts_> but things that we don't quite want to include into the gtk2hs demos collection
09:07:32 <vincenz> dcoutts_: check out drawParallel
09:07:41 <dcoutts_> vincenz, ok
09:07:46 <Cale> then either apply randomRs to it to get an infinite list of random values to consume
09:07:47 <mathrick> Cale: except where you know *nothing* about how you do IO and other impure stuff in haskell
09:07:50 <vincenz> draws a line parallel to a line by x pixels
09:07:57 <Cale> well, you don't have to do IO
09:08:03 <Cale> per-se
09:08:06 <mathrick> but there are monads involved
09:08:09 <Cale> if you have a seed
09:08:11 <Cale> no
09:08:13 <mathrick> which for me amounts to the same thing
09:08:24 <Cale> To make it pretty, you'd use a monad
09:08:29 <mathrick> well, ok, I'll pass it as an argument
09:08:34 <Cale> > let seed = 0; gen = mkStdGen seed in randomRs (1,6) gen
09:08:35 <lambdabot> [6,6,4,1,5,2,4,2,2,1,6,5,1,5,3,2,3,4,4,1,5,1,1,6,5,6,3,4,6,5,6,3,6,3,5,5,
09:08:35 <lambdabot> 3,5,6,2,4,5,3,2,2,4,2,2,6,3,4,4,1,1,1,2,2,3,2,4,5,3,5,3,4,4,6,3,2,6,6,4,4,
09:08:35 <lambdabot> 1,2,3,5,6,4,5,6,2,6,3,2,2,3,1,6,6,3,3,2,4,4,5,1,2,3,2,5,3,3,6,3,2,3,2,2,6,
09:08:35 <lambdabot> 5,5,4,6,2,4,6,2,2,3,3,2,4,3,1,2,5,4,1,2,6,4,4,4,5,4,1,3,3,4,2,6,2,5,1,3,6,
09:08:35 <lambdabot> 3,6,3,6,1,4,1,4,3,2,5,3,4,4,4,1,6,4,4,6,2,3,5,4,1,5,3,1,1,1,4,3,4,3,3,3,4,
09:08:37 <lambdabot> [23 @more lines]
09:08:43 * ihope sighs
09:08:48 <Cale> this gives an infinite list of values which you can consume
09:09:04 <vincenz> and they're low calorific due to laziniess
09:09:09 <dcoutts_> vincenz, I meant whole progs, like a mirror of your whole repo, I'd inlcude my icfp-2004 one too and some other bits and bobs we've got hanging around
09:09:22 <vincenz> dcoutts_: ah :)
09:09:42 <dcoutts_> vincenz, so we can keep them in one place and stop them bitrotting
09:09:58 <dcoutts_> vincenz, it's useful for us to know if we're breaking real code :-)
09:10:05 <vincenz> true
09:10:13 <dcoutts_> and useful for other users to see real code
09:10:31 <vincenz> err... don't forget this was my first cairo/gtk2hs code... 
09:10:36 <dcoutts_> vincenz, that's ok
09:10:46 <vincenz> in fact I copied most of the gtk2hs stuff
09:10:49 <vincenz> and it's a dialog
09:10:53 <dcoutts_> vincenz, np
09:11:10 <vincenz> but!
09:11:25 <vincenz> this line should be put in *BOLD* *RED* *BIG* *BLINKING* letters
09:11:28 <vincenz> timeoutAddFull (yield >> return True) priorityDefaultIdle 50
09:11:42 <dcoutts_> yes, the threading hack
09:11:45 <vincenz> that took me hours of searching gtk2hs documentation on why I had a bug until someone told me I needed that
09:12:16 <dcoutts_> mmm, it's not sufficiently obvious in our docs
09:12:28 <dcoutts_> there is an FAQ on it
09:12:38 <vincenz> I'd put it on the front page
09:12:42 <dcoutts_> but I guess they're not so obvious
09:12:57 <dcoutts_> the link to the FAQs is on the front page and documentation page
09:13:05 <vincenz> I should've looked at faq
09:13:10 <vincenz> but yeah if you don't know that's an issue
09:13:13 <vincenz> you're not gonna look there
09:13:19 <dcoutts_> we're going to get round to writing tutorials eventually too we hope
09:13:19 <vincenz> I thought I was doing wrong things with canvases
09:13:20 <Cale> mathrick: in my monad for random numbers, you can write  n <- getRandomR (1,6)  and that will get a fresh random number from the generator and bind the result to n
09:13:30 <vincenz> (caues my canvas wasn't redrawing)
09:13:44 <dcoutts_> vincenz, yes, that's the real problem, it's not sometihng one knows to look for
09:13:45 <Cale> but of course, you have to be specific about the order of your computations
09:14:23 <dcoutts_> vincenz, hopefully in the future if people lear from a tutorial rather than just gleaning stuff from the demos & reference docs then we'll be able to explain it
09:14:25 <mathrick> heh, "but of course"
09:14:56 <vincenz> dcoutts_: cool :)
09:14:57 <Cale> mathrick: well, the result will depend on the order in which specific pseudorandom numbers are taken from the pool
09:15:03 <jmichaelson> How do I convert from IO a to a ?
09:15:04 <Cale> so order matters
09:15:11 <mathrick> I don't care here
09:15:13 <mathrick> anyway
09:15:14 <mauke> unsafePerformIO!
09:15:15 <mathrick> mkRandomList 10
09:15:15 <mathrick> [46,56,26,1,63,50,44,64,24,49]
09:15:17 <mathrick> thanks
09:15:18 <Cale> jmichaelson: In some sense, you don't
09:15:34 <jmichaelson> yea, once you go IO you never go back :P
09:15:35 <dcoutts_> vincenz, if you or anyone else have any time to help write stuff for a tutorial that'd be nice :-)
09:15:54 <Cale> jmichaelson: you can run an IO computation while defining another one though
09:15:56 <dcoutts_> really, the gtk2hs devs should start something then other people can contribute
09:16:10 <dcoutts_> ie start with an outline and some structure
09:16:17 <jmichaelson> Cale: I mean in eg. ghci I can do 'a <- IO a' and a will be IO free
09:16:29 <jmichaelson> but how do I do that in the source file
09:16:36 <Cale> inside of a do-block
09:16:39 <vincenz> myplop = do
09:16:43 <vincenz>   a <- someIO
09:16:45 <Cale> http://www.haskell.org/hawiki/IntroductionToIO
09:16:45 <vincenz>   return (a+2)
09:16:46 <jmichaelson> yea tried that but it complained
09:16:53 <Cale> read that intro :)
09:17:02 <jmichaelson> uhm doesnt return always return IO a ?
09:17:09 <mauke> do { x <- fooIO; return (youCanRunButYouCannotEscapeIO x) }
09:17:10 <Cale> yeah, it does
09:17:12 <ihope> Nope.
09:17:19 <ihope> > return 3 :: [Int]
09:17:19 <lambdabot> [3]
09:17:27 <Cale> return :: (Monad m) => a -> m a
09:17:31 <mauke> > return 3 :: Maybe Int
09:17:32 <lambdabot> Just 3
09:17:34 <Cale> but that's another story
09:17:39 <nothingmuch> hah
09:17:41 <jmichaelson> hm
09:17:45 <Cale> In this context, return :: a -> IO a
09:17:52 <Cale> yes
09:18:21 <Cale> look at it this way
09:18:53 <Cale> suppose I had a function unsafe :: IO a -> a
09:19:10 <Cale> and I did something like
09:19:22 <Cale> let x = unsafe getLine
09:19:29 <Cale>    y = unsafe getLine
09:19:49 <Cale> in (print x, print y)
09:19:52 <vincenz> z = unsafe $ putStrLn "Cale at work"
09:20:12 <Cale> all of a sudden, the order that this thing gets evaluated in changes its meaning
09:20:38 <jmichaelson> hm
09:20:50 <Cale> which is bad
09:21:21 <Cale> In a nonstrict language, the compiler is allowed to evaluate things in any order it likes.
09:22:13 <Cale> Also, Haskell has the additional property that it preserves referential transparency
09:22:18 <Cale> above
09:22:21 <ihope> @type System.Unsafe.unsafePerformIO
09:22:22 <lambdabot> Couldn't find qualified module.
09:22:22 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
09:22:22 <lambdabot> \\)?
09:22:35 <Cale> x = unsafe getLine, and y = unsafe getLine, so I should be able to reason that x = y
09:23:24 <Cale> but if it meant what you might like it to, then I couldn't guarantee that
09:24:09 <Cale> In fact, there is an unsafe function in GHC, but this is one of the problems about using it -- the compiler might optimise away applications of it, figuring that they were the same anyway.
09:24:28 <jmichaelson> heh
09:25:25 <Cale> so instead, we do this interesting thing: rather than working with values dependent on IO directly, we have a few operations which work on IO programs
09:25:34 <Cale> @type getLine
09:25:35 <lambdabot> IO String
09:25:47 <Cale> This is an IO action, which when run, gives a String
09:25:48 <Wallbraker> quick question 'mod' for doubles?
09:26:08 <Cale> Wallbraker: You'd have to write one yourself
09:26:20 <Wallbraker> *sniff*
09:26:22 <Wallbraker> right...
09:26:45 <Cale> and we have operations for chaining programs together
09:26:48 <Cale> end to end
09:26:52 <Wallbraker> surely there must be a inbuilt one...
09:27:00 <Cale> (>>) :: IO a -> IO b -> IO b
09:27:13 <Cale> Wallbraker: not in the standard libraries afaik.
09:27:22 <Wallbraker> right...
09:27:23 <Cale> Only the usual number-theoretic one
09:27:44 <Cale> it's rather easy to write yourself anyway :)
09:28:26 <mauke> what, no Posix.fmod?
09:28:28 <Cale> jmichaelson: sorta following?
09:28:35 <jmichaelson> somewhat
09:28:38 <vincenz> > round 1.0
09:28:39 <lambdabot> 1
09:29:05 <Cale> okay, so the main operations for chaining IO together are:
09:29:10 <Cale> (>>) :: IO a -> IO b -> IO b
09:29:20 <vincenz> @pl \x y -> round x `mod` round y
09:29:20 <lambdabot> (. round) . mod . round
09:29:37 <Cale> which takes a couple of IO actions and produces one which does the first, throws away its result, then does the second one
09:30:18 <Cale> note that the result is still an IO action -- the only IO action which is actually run is 'main', or in the case of GHCi usage, ones which the user types
09:30:26 <jmichaelson> ok, just dont see how that helps me here tho
09:30:47 <Cale> well, you probably don't want to just throw away the result of the first computation always
09:31:03 <Cale> So there's (>>=) :: IO a -> (a -> IO b) -> IO b
09:31:13 <mathrick> > until (0 ==) ((\ x y -> (trace (show y) (x y))) (/ 2)) 1
09:31:13 <lambdabot>  Not in scope: `trace'
09:31:24 <mathrick> > until (0 ==) ((\ x y -> (Debug.Trace.trace (show y) (x y))) (/ 2)) 1
09:31:24 <lambdabot>  Not in scope: `Debug.Trace.trace'
09:31:36 <EtnaRosso> what is Trace?
09:31:57 <mathrick> EtnaRosso: something which lets you trace steps of code execution
09:31:58 <EtnaRosso> ah Debug.Trace
09:32:09 <EtnaRosso> good
09:32:20 <mathrick> but why is it not in scope?
09:32:21 <Cale> x >>= f will be an action that runs x, and then passes its result(!) to f to get a new IO action returning a value of type b, which it then runs and returns
09:32:26 <Cale> that's a mouthful
09:32:35 <Cale> but it's easy once you see a couple examples
09:32:37 <Cale> try
09:32:51 <Cale> main = putStrLn "Hello, what is your name?"
09:32:51 <Cale>       >> getLine
09:32:51 <Cale>       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
09:33:37 <mathrick> @docs trace
09:33:38 <lambdabot> trace not available
09:33:42 <mathrick> @index trace
09:33:43 <lambdabot> Debug.Trace
09:34:01 <Cale> @. docs index trace
09:34:01 <lambdabot> Debug.Trace
09:34:01 <lambdabot>  not available
09:34:04 <Cale> hmm
09:34:14 <Cale> wonder why that doesn't work
09:34:22 <mathrick> dunno, is it specifically disabled or something?
09:34:25 <Cale> oh right
09:34:41 <Cale> index outputs its result in some nonstandard way, I think
09:34:55 <Cale> that's kind of bad
09:35:01 <mathrick> but why can't I use it in my code?
09:35:02 <mathrick> > until (0 ==) ((\ x y -> (Debug.Trace.trace (show y) (x y))) (/ 2)) 1
09:35:03 <lambdabot>  Not in scope: `Debug.Trace.trace'
09:35:04 <jmichaelson> yea Cale seen that
09:35:28 <mathrick> I mean in lambdabot, I can do it locally
09:35:37 <Cale> jmichaelson: okay, and you've seen the perhaps prettier do-notation one below it, which is really the same thing
09:35:44 <jmichaelson> yea
09:35:51 <Cale> you should note that 'name' in that code is a String
09:35:56 <Cale> not an IO String
09:36:23 <jmichaelson> yea
09:36:44 <Cale> so, once you're working inside IO, you're allowed to get the results of IO computations and pass them into pure functions, do whatever you want with them
09:37:44 <jmichaelson> yea understand that
09:37:45 <Cale> but yeah, you are stuck inside IO, however, you're allowed to pull in any pure functions you want.
09:38:06 <jmichaelson> but just had this function that returns IO a so thats why been stuck there..
09:38:10 <Cale> right
09:38:25 <Cale> you can only use that function to build part of another IO action
09:38:59 <Cale> just curious, what does your function do?
09:42:06 <mauke> mathrick: because it wasn't imported
09:43:47 <jmichaelson> Cale: randomnumbers and generators
09:47:27 <DukeDave> ahh excellent, a dicussion about the IO monad being confusing :)
09:47:31 * DukeDave joins club
09:48:00 <sieni> jmichaelson: so if you want to apply some function to a value that in the IO monad, you would do something like:
09:48:08 <Cale> jmichaelson: okay
09:48:09 <sieni> let foo = return 7 in let bar = (5+) in do {x <- foo; y <- return (bar x); putStrLn (show y)}
09:48:36 <sieni> so here foo is your result of type IO a, bar is a function a->b.
09:48:44 <Cale> jmichaelson: so you might want to read the same wiki page that I pointed mathrick to
09:49:28 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
09:49:42 <sieni> But you can't escape the IO monad (without a certain dirty trick, whose name is not to be spoken on this channel ^_^)
09:50:09 <Cale> as a new haskell user, you certainly don't want that trick
09:50:54 <Cale> You really have to know how the runtime system works to a fair extent before you'll have any chance at predicting its behaviour.
09:53:15 <jmichaelson> hehe :P
09:58:03 <chris2> hmm, i have a datatype which is made of 4 different others. now i want to check if several instances of that datatype satisfy a predicate... and i'd like map over it for that. but since all four fields have different type, i can't make it valid, even if the predicate is [a] -> Bool?
09:59:45 <chris2> isSet cards = all (\x -> allSameOrDifferent $ map x cards) [amount, shape, color, fill]
10:00:58 <Cale> chris2: you need to write a predicate which branches on the different cases for your type
10:01:03 <Cale> what is the type?
10:01:16 <chris2> type of?
10:01:23 <Cale> the data declaration
10:01:46 <chris2> data Card = Card { amount :: Amount,   shape :: Shape,   color :: Color,  fill :: Fill }  deriving (Eq, Show)
10:02:11 <Cale> okay
10:02:35 <chris2> allSameOrDifferent l = let s = length $ nub l in s == 1 || s == 3
10:02:36 <Cale> those field labels are automagically functions with which you can extract the fields
10:02:48 <chris2> yeah
10:03:26 <Cale> hmm, is this a game of Set? :)
10:03:33 <chris2> yeah
10:03:44 <chris2> a solver for http://www.setgame.com/puzzle/set.htm
10:03:48 <chris2> dinner, ttyl
10:03:56 <Cale> ah, right I see your problem
10:04:19 <Cale> yeah, you can't pack all those functions into a list, since they're different types
10:04:33 <Cale> you'd have to apply them separately
10:06:19 <mathrick> \o/
10:06:25 <mathrick> I have bubblesort
10:06:31 <mathrick> MAN
10:06:33 <DukeDave> > type foo = (Int, String)
10:06:34 <lambdabot>  parse error on input `type'
10:06:34 <mathrick> that was hard
10:06:48 <mathrick> > import Debug.Trace
10:06:49 <lambdabot>  parse error on input `import'
10:07:04 <DukeDave> what am I thinking of? :o
10:07:16 <mathrick> bubbleSort x = fst (until ((False ||) . snd) (foldr bStep ([], True) . fst) (x, False))
10:07:16 <mathrick>     where
10:07:16 <mathrick>       bStep x prev = trace (show x ++ show prev) pair (fst, (&& (snd prev)) . snd) (swapFront x (fst prev))
10:07:16 <mathrick>       swapFront x [] = ([x], True)
10:07:16 <mathrick>       swapFront x xs
10:07:17 <mathrick>           | x <= (head xs) = (x:xs, True)
10:07:19 <mathrick>           | otherwise = (head xs :(x:(tail xs)), False)
10:07:33 <mathrick> I can't say it's easy to read or obvious
10:09:09 <DukeDave> what is that command, like data but it just 'renames' the type
10:09:37 <DukeDave> huh, apparently it is type
10:09:44 <Cale> yeah
10:09:55 <Cale> there's also newtype
10:09:57 <DukeDave> so   > type kwList = (String, [String])
10:10:06 <DukeDave> surely valid?
10:10:10 <Cale> which actually creates a new type, with the same implementation
10:10:17 <Cale> type KwList = (String, [String])
10:10:24 <DukeDave> ahh
10:10:27 <DukeDave> leading caps?
10:10:30 <Cale> yeah
10:10:48 <Cale> you could also do
10:10:51 <DukeDave> cheers man, one of those hard to google ones ;)
10:10:57 <Cale> data KwList = KwList String [String]
10:11:40 <DukeDave> hmm, is causing
10:11:40 <DukeDave> *** Expected type : String -> a -> String
10:11:40 <DukeDave> *** Inferred type : String -> ([Char],[[Char]]) -> String
10:11:58 <Cale> hmm
10:12:11 <DukeDave> is caused by my type sig
10:12:12 <Cale> maybe a type signature somewhere which is too polymorphic?
10:12:17 <DukeDave> ahh
10:12:26 <DukeDave> didn't rename kwList in my type sig ;)
10:12:29 <Cale> ah
10:12:30 <Cale> hehe
10:12:50 * DukeDave sets mode +slowlydoesit
10:15:48 <Cale> this perhaps isn't exactly bubblesort, but it's kind of similar
10:15:52 <Cale> bubble [] = []
10:15:52 <Cale> bubble [x] = [x]
10:15:52 <Cale> bubble (x:y:xs) = case compare x y of
10:15:52 <Cale>     LT -> x : bubble (y:xs)
10:15:52 <Cale>     EQ -> x : bubble (y:xs)
10:15:53 <Cale>     GT -> y : bubble (x:xs)
10:15:55 <Cale> fixEq f x = if f x == x then x else fixEq f (f x)
10:15:57 <Cale> bubbleSort xs = fixEq bubble xs
10:16:48 <Cale> still a good deal more work than quicksort :)
10:17:43 <Cale> I suppose you can simplify the case to an if
10:18:40 <Cale> bubble (x:y:xs) =
10:18:41 <Cale>     if y < x then y : bubble (x:xs)
10:18:41 <Cale>              else x : bubble (y:xs)
10:21:05 <Cale> yeah, this is basically bubble sort
10:22:20 <mathrick> Cale: BOO!
10:22:25 * mathrick off
10:32:56 <Spark> = min(x,y) : bubble (max(x,y):xs)
10:33:06 <Cale> yeah
10:33:38 <Cale> double the comparisons :)
10:33:49 <Spark> true :)
10:37:05 <chris2> Cale: (re: setgame) hrm, sucks.. couldn't i join the data types with some class, maybe?
10:38:33 <Cale> well, it's just a little rearranging
10:40:00 <Cale> change the 'all' to an 'and', and push the allSameOrDifferent in
10:40:25 <Cale> You might be able to work out some mechanism using existentials
10:40:31 <Cale> but it's probably not worth it :)
10:41:31 <chris2> "and push the allSameOrDifferent in"
10:42:02 <chris2> ?
10:51:13 <Cale> as in, apply it to the elements of the list by hand
10:51:22 <Cale> there are only 4 elements, so it can't be too bad
10:53:24 <Cale> or perhaps derive Enum for each of your custom types and map fromEnum . property  over the cards for each property
10:53:35 <chris2> good idea
10:54:25 <Cale> well, you still can't put the properties in a list, hmm
10:55:09 <Cale> well, I suppose you can put the (fromEnum . property)'s in a list
10:58:07 <ihope> How does deriving Enum work?
10:58:51 <Cale> http://haskell.org/onlinereport/derived.html#sect10.2
11:01:21 <Cale> "The toEnum and fromEnum operators map enumerated values to and from the Int type", antirespectively :)
11:01:25 * chris2 also needs to figure a way how to make all triples of a list
11:01:32 <jmichaelson> say I want to generate 10 unique random numbers, how would that look like?
11:01:46 <ihope> @type toEnum
11:01:54 <Cale> > let xs = [1,2,3] in sequence [xs,xs,xs]
11:02:21 <Cale> oh, lambdabot died
11:02:22 <bolrod> lambdabot isn not online.....
11:02:23 <ihope> Hmm, that's a good one.
11:02:38 <bolrod> netsplit??
11:02:43 <Cale> jmichaelson: take 10 (randoms gen)
11:02:50 <Cale> or randomRs
11:02:51 <ihope> Doubt is.
11:03:04 <ihope> That is, I doubt there's a netsplit.
11:03:15 <bolrod> then delete double elements if you want unique
11:03:16 <bolrod> :)
11:03:19 <Cale> > let xs = [1,2,3] in sequence [xs,xs,xs]
11:03:20 <jmichaelson> lol
11:03:21 <mbot> [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],[3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]]
11:03:35 <ihope> Yay!
11:03:41 <Cale> > let xs = [1,2,3] in sequence (replicate 2 xs)
11:03:41 <ihope> > take 10 (randoms gen)
11:03:42 <mbot> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
11:03:43 <mbot>  Not in scope: `gen'
11:03:51 <Cale> ihope: you'd need a generator :)
11:03:58 <ihope> Oh :-)
11:04:02 <ihope> @type randoms
11:04:04 <mbot> Not in scope: `randoms'
11:04:05 <Cale> > take 10 (randoms (mkStdGen 0))
11:04:05 <jmichaelson> I tried with fst ( randomR (1,10) (mkStdGen n++) )
11:04:06 <mbot> Add a type signature
11:04:07 <chris2> thx
11:04:13 <Cale> > take 10 (randoms (mkStdGen 0)) :: [Integer]
11:04:15 <mbot> [2092838931,-2143208520,2034827062,-1587933427,-1272503422,316817438,2007066819,538180758,140827264,-182934444]
11:04:16 <jmichaelson> but that gave me 2 same numbers
11:04:21 <Cale> hm?
11:04:28 <Cale> oh
11:04:41 <ihope> I also like Blum Blum Shub for random numbers.
11:04:41 <Cale> n++ ?
11:05:09 <Cale> what list is that which you're concatenating to nothing?
11:05:11 <jmichaelson> heh thought that was self explanatory :P
11:05:23 <jmichaelson> think of C or sumptin heh
11:05:27 <Cale> heh
11:05:34 <jmichaelson> an Integer that grows
11:05:39 <jmichaelson> [1..n]
11:05:45 <Cale> map
11:05:52 <chris2> what if i wont want both [1,2] and [2,1] ? :)
11:06:24 <Cale> > take 10 $ map (\n -> randomR (1,10) (mkStdGen n)) [1..]
11:06:26 <mbot> [(8,80028 40692),(2,120042 40692),(6,160056 40692),(10,200070 40692),(4,240084 40692),(8,280098 40692),(2,320112 40692),(6,360126 40692),(10,400140 40692),(4,440154 40692)]
11:06:40 <Cale> > take 10 $ map (\n -> fst $ randomR (1,10) (mkStdGen n)) [1..]
11:06:42 <mbot> [8,2,6,10,4,8,2,6,10,4]
11:06:48 <ihope> > map (`mod` 2048) (iterate ((`mod` (783452771*818004307)).(^2)) 2) -- Blum Blum Shub
11:06:50 <mbot> [2,4,16,256,0,0,324,3,1975,1097,1986,964,940,1808,1689,1346,2026,1301,609,198,1808,414,6,1248,1085,841,859,1060,1815,1275,2038,363,1111,512,402,943,1922,533,1369,1326,1522,1355,1801,1298,1372,1474,269,1823,1183,328,1748,1184,950,312,241,1613,870,2010,881,922,516,106,1942,45,738,411,1201,256,349,1692,670,1309,749,1834,1841,1603,1920,851,1704,379,
11:06:50 <mbot> [5 @more lines]
11:07:14 <ihope> Of course, you'll want to throw away the first few numbers. I didn't choose a good seed that time.
11:07:44 <Cale> you could write an instance of RandomGen for that algorithm
11:07:50 <Cale> and then use the same interface
11:07:53 <ihope> What is RandomGen?
11:07:56 <ihope> > map (`mod` 2048) (iterate ((`mod` (783452771*818004307)).(^2)) 823202609)
11:07:58 <mbot> [817,1608,1975,691,647,498,48,566,1441,1116,1618,160,1207,266,138,518,1078,1544,1793,1205,1788,188,260,1910,1778,1456,1214,1623,1393,1762,407,455,1241,413,2004,94,2039,149,1631,242,853,154,2011,790,473,453,101,986,155,104,1203,362,1247,22,1323,1144,536,1462,938,1289,505,1029,1119,882,1968,1247,1662,973,589,961,154,939,1364,871,609,1498,1887,955,
11:07:58 <mbot> [5 @more lines]
11:08:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
11:08:14 <Cale> class RandomGen g where
11:08:22 <Cale>     next :: g -> (Int,g)
11:08:28 <Cale>     split :: g -> (g,g)
11:08:38 <Cale>     genRange :: g -> (Int, Int)
11:08:46 <ihope> Okay.
11:09:00 <Cale> next is self-explanatory
11:09:19 <Cale> split is intended to split the generator into two new ones not the same as the first
11:09:45 <ihope> So could I alternate elements of the list between two generators?
11:09:47 <Cale> and genRange gets the range of values which could be produced by the generator
11:10:05 <ihope> So (0,2047) in this case, right?
11:10:13 <Cale> yeah
11:10:26 <araujo> @index fst4
11:10:27 <mbot> bzzt
11:10:31 <araujo> @index fst2
11:10:31 <mbot> bzzt
11:10:34 <araujo> @index fst
11:10:34 <mbot> Data.Tuple, Prelude
11:10:42 <araujo> @index fst3
11:10:42 <Cale> for split, you probably want to use the generator along with some tweaking to get a couple of new seeds
11:10:42 <mbot> bzzt
11:10:51 <ihope> \(x,_,_,_) -> x?
11:10:59 <jmichaelson> heh
11:11:32 <jmichaelson> araujo: you have to write your own fst2 and up
11:11:46 <davidhouse> @type takeWhile
11:11:47 <mbot> forall a. (a -> Bool) -> [a] -> [a]
11:11:57 <ihope> @type const . const . const
11:11:58 <mbot> forall b b1 b2 a. a -> b -> b1 -> b2 -> a
11:12:13 <Cale> the cool thing is that once you've done that, you can create random values for any type in the Random class.
11:12:14 <davidhouse> @hoogle (a -> Bool) -> [a] -> [a]
11:12:15 <mbot> http://www.standardml.org/Basis/bool.html
11:12:29 <davidhouse> huh?
11:12:31 <jmichaelson> hm one could use recursion and split the gen on every call
11:12:32 <davidhouse> @hoogle (a -> Bool) -> [a] -> [a]
11:12:33 <mbot> http://www.standardml.org/Basis/bool.html
11:12:36 <jmichaelson> or something
11:12:48 <Cale> jmichaelson: that's what it's for
11:12:53 <jmichaelson> :P
11:12:58 <ihope> Cale: is there any reason I couldn't do something like split (xa:xb:xs) = (xa:fst (split xs), xb:snd (split xs))?
11:13:09 <ihope> @type min
11:13:10 <mbot> forall a. (Ord a) => a -> a -> a
11:13:20 <ihope> @type lowerBound
11:13:21 <mbot> Not in scope: `lowerBound'
11:13:26 <davidhouse> anyone know of a function a bit like takeWhile but also returns the first value where that predicate is false?
11:13:45 <Cale> ihope: you could -- it'll get slower as you keep splitting like that
11:13:50 <ihope> Ah.
11:14:11 <Cale> davidhouse: used to be called takeUntil
11:14:18 <davidhouse> i suppose \p l -> (takeWhile p l) ++ (maybe () return $ find (not.p) l)
11:14:19 <Cale> davidhouse: but it's gone now
11:14:32 <ihope> > minBound :: Int
11:14:34 <mbot> -2147483648
11:14:41 <ihope> > maxBound :: Int
11:14:43 <mbot> 2147483647
11:14:57 <ihope> > log 2147483648 / log 2
11:14:59 <mbot> 31.000000000000004
11:15:06 <davidhouse> Cale, would something like the above work?
11:15:11 * ihope "loves" rounding error
11:15:21 <Cale> takeUntil p [] = []; takeUntil p (x:xs) = if p x then x : takeUntil p xs else [x]
11:16:07 <Cale> we
11:16:09 <Cale> er
11:16:16 <Cale> that's not exactly "Until"
11:16:32 <Cale> well, you'd negate p to make it right :)
11:17:20 <davidhouse> okay, but the func itself would work, i guess.
11:17:27 <Cale> takeUntil           :: (a -> Bool) -> [a] -> [a]
11:17:27 <Cale> takeUntil p []       = []
11:17:27 <Cale> takeUntil p (x:xs)
11:17:27 <Cale>        | p x         = [x]
11:17:27 <Cale>        | otherwise   = x : takeUntil p xs
11:17:50 <Cale> from http://www.cse.unsw.edu.au/~dons/cc.prelude
11:18:06 <Cale> note that it did have fst3 :)
11:18:34 <Cale> and Monad was a subclass of Functor
11:18:48 <Cale> and there was a class for adjoint functors
11:18:56 <Cale> and natural transformations
11:20:05 <mathrick> > maxBound :: Integer
11:20:07 <mbot>  add an instance declaration for (Bounded Integer)
11:20:07 <mbot>   In the expression: maxBound :: Integer
11:20:07 <mbot>   In the definition of `zlg': zlg = maxBound :: Integer
11:20:20 <Cale> and monad comprehensions too :)
11:20:28 <Cale> but it doesn't use a monad for IO
11:20:54 <ihope> @type readLn
11:20:56 <mbot> forall a. (Read a) => IO a
11:29:10 <moonlite> I am guessing that writeFile can fail. Im can't find out what error messages it will get me though. I've checked the hierarchial libraries. Anyone?
11:30:22 <ndm> moonlite: try it and see :)
11:30:31 <ndm> and if you want to give your own message, look at catch
11:30:34 <ndm> @hoogle catch
11:30:36 <mbot> http://www.catch.com/
11:30:52 <ndm> @help
11:30:52 <mbot>  @help <command> - ask for help for <command>
11:30:57 <ndm> @help hoogle
11:30:57 <mbot>  @help <command> - ask for help for <command>
11:31:06 <ndm> does mbot not know hoogle :(
11:31:41 <moonlite> should call it mmmbot :P
11:32:24 <ndm> whose is mbot?
11:32:31 <astrolabe> cale's
11:32:45 <ndm> Cale, how come mbot lacks hoogle support?
11:33:54 <mathrick> how can I force a value to be evaluated without printing it?
11:34:00 <ihope> seq or deepSeq
11:34:16 <mathrick> ihope: how do I do it in this line?
11:34:17 <mathrick> let x = bubbleSort2 (mkRandomList 1000)
11:34:30 <mathrick> I tried seq but I don't really get how it's supposed to be used
11:34:43 <ihope> I'm guessing let x = bubblesort2 (deepSeq (mkRandomList 1000))
11:34:54 <ihope> @index deepSeq
11:34:55 <mbot> bzzt
11:35:02 <ihope> Um... you'll find it.
11:35:08 <ihope> Alternatively:
11:35:12 <ihope> deepSeq [] = id
11:35:29 <ihope> deepSeq (x:xs) = seq x (deepSeq xs)
11:35:58 <mathrick> why exactly does seq take 2 parameters?
11:36:48 <kolmodin> moonlite: read the source :)
11:36:55 <moonlite> kolmodin: :(
11:37:04 <kolmodin> it's using openFile
11:37:09 <kolmodin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AopenFile
11:37:20 <moonlite> ah, you meant like that
11:37:20 <ihope> mathrick: seq x y evaluates the "smallest piece possible" of x, then returns y
11:37:36 <ihope> deepSeq x y evaluates x completely before returning y.
11:39:09 <kolmodin> moonlite: it also uses hPutStr: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhPutStr
11:39:16 <mathrick> ihope: I don't have deepSeq defined, but your definition doesn't seem to really work
11:39:28 <jethr0_> @seen dcoutts
11:39:29 <ihope> Well, what do you want to do?
11:39:29 <mbot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
11:39:30 <mathrick> *Main> let x = bubbleSort2 (deepSeq (mkRandomList 1000))
11:39:30 <mathrick> <interactive>:1:21:
11:39:30 <mathrick>     Couldn't match `[a]' against `t -> t1'
11:39:30 <mathrick>       Expected type: [a]
11:39:30 <mathrick>       Inferred type: t -> t1
11:39:30 <mathrick>       Expected type: [a]
11:39:32 <mathrick>       Inferred type: a1 -> a1
11:39:36 <mathrick>     Probable cause: `deepSeq' is applied to too few arguments in the call
11:39:38 <jethr0_> dcoutts_: ping
11:39:38 <mathrick> 	(deepSeq (mkRandomList 1000))
11:39:52 * ihope checks
11:40:28 <ihope> Why do you want to deepSeq it?
11:40:47 <mathrick> ihope: to see how long it takes
11:40:52 <mathrick> without printing
11:40:57 <ihope> If you want the whole list to be evaluated before accessing any of it, let x = bubbleSort2 (deepSeq (mkRandomList 1000) (mkRandomList 1000))
11:41:04 <mathrick> printing over ssh is not exactly the best idea :)
11:41:36 <mathrick> ihope: will that make bubbleSort also perform some work?
11:41:43 <mathrick> or just make the list evaluated?
11:42:07 <ihope> That'll only force the list to evaluate.
11:42:25 <mathrick> well, I want bubblesort to kick in
11:42:45 <ihope> let deepSeq' x = deepSeq x x
11:42:59 <ihope> let x = deepSeq' (bubbleSort2 (mkRandomList 1000))
11:43:02 <ihope> Try that.
11:43:36 <mathrick> ihope: it completes in a fraction of second
11:44:06 <davidhouse> is there a predicate function to say "item matches this pattern"?
11:44:12 <ihope> Ohh...
11:44:22 <ihope> Hmm, weird.
11:44:26 <davidhouse> apart from case item of { pattern -> True; _ -> false; }
11:45:19 <ihope> Well, try let x = deepSeq (bubbleSort2 (mkRandomList 1000)) ()
11:45:29 <ihope> That'll return (), but evaluate the stuff along the way.
11:46:10 <mathrick> nope
11:46:37 <ihope> Just what does it do, then?
11:46:49 <mathrick> nothing
11:47:08 <ihope> Um...
11:47:14 <ihope> Are you using GHCi?
11:47:18 <ihope> Or Hugs?
11:47:20 <mathrick> *Main> let x = deepSeq (bubbleSort2 (mkRandomList 1000)) ()
11:47:20 <mathrick> *Main> 
11:47:25 <mathrick> ihope: ghci
11:47:39 <mathrick> if I try to print x, it will eval it tho
11:47:47 <mathrick> even though it prints ()
11:47:50 <davidhouse> mathrick: lazy intepreter.
11:47:58 <ihope> Aha.
11:47:58 <davidhouse> values aren't calculated until they're needed.
11:48:41 <ihope> So if it's evaluating when you print that, then...
11:48:42 <mathrick> wait, it's more lazy than usual?
11:48:59 <ihope> If you simply "let" something, I don't think anything's evaluated.
11:50:01 <mathrick> hoho
11:50:21 <mathrick> Cale's bubblesort is not only much simpler, but also significantly faster
11:50:22 <davidhouse> > let x = [1..]
11:50:23 <mbot>  parse error on input `}'
11:50:38 <davidhouse> woah, mbot is screwey.
11:50:40 <sieni> > let 7 ()
11:50:41 <mbot>  parse error (possibly incorrect indentation)
11:50:48 <mathrick> mbot is running hugs?
11:50:49 <sieni> > let x = 7 ()
11:50:50 <mbot>  parse error on input `}'
11:50:55 <mathrick> @version
11:50:56 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686 )
11:50:56 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:51:17 <davidhouse> anyway, type "let x = [1..]" in a proper GHCi, and it's obvious that it isn't evaluated until needed.
11:51:28 <davidhouse> infinite lists are a big advantage of lazy intepreters.
11:51:34 <davidhouse> > take 5 [1..]
11:51:36 <mbot> [1,2,3,4,5]
11:51:45 <mathrick> davidhouse: which is ironic when I try to force it to eval with seq :)
11:51:54 <sieni> mbot is ghc, but every evaluation is a new session
11:52:17 <davidhouse> mathrick: you see, i know nothing about seq, and i obviously mistook you for a newbie, so i'll shut up :)
11:52:30 <ihope> Well, seq-ing a list only checks whether it's empty or not.
11:52:35 <mathrick> davidhouse: I *am* newbie, just not that big :)
11:52:42 <mathrick> I know that haskell is lazy
11:52:43 <ihope> That is, it only seq's it down to the (:) or [].
11:52:46 <davidhouse> it's all relative.
11:53:38 <davidhouse> @type seq
11:53:39 <mbot> forall b a. a -> b -> b
11:54:00 <davidhouse> any answers to my question, by the way?
11:55:01 <kosmikus> davidhouse: which question?
11:55:26 <davidhouse> is there a predicate function to say "item matches this pattern"?
11:55:43 <kosmikus> some special syntax, you mean?
11:55:54 <kosmikus> not a case statement?
11:55:59 <davidhouse> well, whatever. just something a bit shorter than a case, i was thinking
11:56:02 <kosmikus> no
11:56:18 <davidhouse> hmm. thanks.
11:56:41 <mathrick> hmm, in this code:
11:56:42 <mathrick> bubble [] = []
11:56:42 <mathrick> bubble [x] = [x]
11:56:42 <mathrick> bubble (x:y:xs) =
11:56:42 <mathrick>     if y < x then y : bubble (x:xs)
11:56:42 <mathrick>              else x : bubble (y:xs)
11:56:46 <mathrick> fixEq f x = if f x == x then x else fixEq f (f x)
11:56:48 <mathrick> bubbleSort2 xs = fixEq bubble xs
11:56:54 <kosmikus> davidhouse: there are pattern guards, as a ghc extension, but they're more specific.
11:57:10 <mathrick> how comes list comparision with == is faster than my convoluted code which keeps status in a Bool?
11:57:20 <davidhouse> kosmikus: duh. i just realised i'm using really simple data constructors, i don't even need proper pattern matching. it's as simple as ==. :)
11:57:24 * davidhouse slaps forehead
12:00:10 <davidhouse> can i return anything to get []?
12:00:24 <davidhouse> i.e. is there a solution to the equation "return a == []" (sorry, i think mathematically)
12:00:45 <Mitar> is there a way to increase stack so i would not get stack overflow?
12:01:03 <Cale> Mitar: yes, but what are you doing?
12:01:20 <Mitar> just playing along and trying to compute ackerman's function
12:01:31 <Cale> it should actually tell you how to set the stack larger when your program fails
12:01:42 <Mitar> i am running it from ghci
12:02:07 <Cale> hmm
12:02:25 <Mitar> ackerman 0 _ = 1
12:02:25 <Mitar> ackerman 1 0 = 2
12:02:25 <Mitar> ackerman x 0 = x + 2
12:02:25 <Mitar> ackerman x y = ackerman (ackerman (x-1) y) (y-1)
12:02:26 <Mitar> try it
12:02:33 <davidhouse> > return () :: [a]
12:02:35 <mbot>  a
12:02:35 <mbot>   Inferred type: ()
12:02:40 <davidhouse> > return () :: [()]
12:02:44 <ihope> davidhouse: no, but there's mzero
12:02:45 <mbot> [()]
12:02:50 <davidhouse> ihope, nice.
12:02:51 <Cale> ghci +RTS -K20M
12:02:54 <davidhouse> well. hmm.
12:03:06 <ihope> And fail as well, but that's considered evil by many.
12:03:15 <ihope> > fail "bling bling" :: [a]
12:03:16 <mbot> Add a type signature
12:03:19 <ihope> > fail "bling bling" :: [()]
12:03:21 <mbot> []
12:03:26 <ihope> > mzero :: [()\
12:03:28 <mbot>  parse error on input `\'
12:03:28 <ihope> > mzero :: [()]
12:03:30 <mbot> []
12:03:44 <davidhouse> > return mzero :: [Int]
12:03:46 <mbot> Couldn't match `Int' against `m a'
12:03:49 <Cale> mzero :: [Int]
12:03:51 <Cale> > mzero :: [Int]
12:03:53 <davidhouse> > return mzero :: Int
12:03:53 <mbot> []
12:03:54 <mbot> Couldn't match `Int' against `m a'
12:04:03 <davidhouse> i basically want "maybe xxx return $ find (\(_,_,e) -> e == Absorb)"
12:04:07 <Cale> > return mzero :: [[Int]]
12:04:09 <mbot> [[]]
12:04:15 <Cale> > mzero :: [[Int]]
12:04:16 <mbot> []
12:04:18 <ihope> xxx = mzero
12:04:36 <davidhouse> and replace 'return' with 'id'?
12:04:45 <davidhouse> and then... something else.
12:05:00 <davidhouse> because the result of the find will need to be returned after the maybe
12:05:01 <ihope> If find (\(_,_,e) -> e == Absorb) returns a value and you want a list containing it, use return.
12:05:25 <ihope> If it returns a list, then use id.
12:05:37 <davidhouse> it returns a value.
12:05:46 <davidhouse> but i can't use return in the maybe call because of mzero.
12:05:54 <Cale> why?
12:05:58 <Cale> @type mzero
12:05:59 <mbot> Not in scope: `mzero'
12:06:02 <ihope> @index mzero
12:06:03 <mbot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:06:04 <Cale> @type Control.Monadmzero
12:06:06 <mbot> Couldn't find qualified module.
12:06:06 <mbot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
12:06:06 <Cale> @type Control.Monad.mzero
12:06:07 <mbot> forall (m :: * -> *) a.
12:06:07 <mbot>         (Control.Monad.MonadPlus m) =>
12:06:07 <mbot>         m a
12:06:24 <Cale> @type return
12:06:26 <mbot> forall (m :: * -> *) a. (Monad m) => a -> m a
12:06:38 <Cale> @type maybe mzero return
12:06:39 <mbot> Not in scope: `mzero'
12:06:41 <ihope> class (Monad m) => MonadPlus m where...
12:06:44 <Cale> @type maybe Control.Monad.mzero return
12:06:45 <mbot> forall (m :: * -> *) a.
12:06:45 <mbot>             (Control.Monad.MonadPlus m) =>
12:06:45 <mbot>             Maybe a -> m a
12:07:05 <ihope> Is that what you want, then?
12:07:11 <davidhouse> let me think
12:07:18 <Cale> @type maybe Control.Monad.mzero return :: Maybe a -> [a]
12:07:19 <mbot> Maybe a -> [a] :: forall a.
12:07:19 <mbot>                   Maybe a -> [a]
12:07:36 <Cale> > maybe mzero return (Just 5)
12:07:37 <davidhouse> > Control.Monad.mzero == []
12:07:38 <mbot> Add a type signature
12:07:38 <mbot>  add an instance declaration for (Show (m a))
12:07:44 <Cale> heh
12:07:45 <davidhouse> does mzero == []?
12:07:49 <ihope> Yep.
12:07:52 <Cale> > maybe mzero return (Just 5) :: [Integer]
12:07:53 <mbot> [5]
12:07:55 <ihope> > mzero :: [()]
12:07:57 <mbot> []
12:08:01 <Cale> > maybe mzero return (Nothing) :: [Integer]
12:08:03 <mbot> []
12:08:40 <davidhouse> oh?
12:08:46 <davidhouse> so return [] == []?
12:08:49 <Cale> no
12:08:57 <Cale> return [] = [[]] in the list monad
12:09:05 <Cale> return x = [x]
12:09:24 <davidhouse> but in that above call, you returned mzero and got [].
12:09:27 <ihope> Nope.
12:09:29 <Cale> no
12:09:37 <Cale> @type maybe
12:09:38 <mbot> forall b a. b -> (a -> b) -> Maybe a -> b
12:09:42 <ihope> maybe mzero return Nothing = mzero, not return mzero
12:10:07 <ihope> @index monad
12:10:07 <mbot> bzzt
12:10:16 <Cale> Monad is in the Prelude
12:10:32 * davidhouse slaps forehead.
12:10:47 <davidhouse> the substitute value isn't put through the function, is it
12:10:51 <Cale> maybe [] (\x -> [x]) (Just 5)
12:10:52 <Cale> > maybe [] (\x -> [x]) (Just 5)
12:10:54 <mbot> [5]
12:10:55 <ihope> Nope, it's not :-)
12:10:58 <Cale> > maybe [] (\x -> [x]) Nothing
12:11:00 <mbot> Add a type signature
12:11:05 <Cale> > maybe [] (\x -> [x]) Nothing :: [Integer]
12:11:07 <mbot> []
12:11:14 <Cale> same thing, less polymorphism
12:11:40 <ihope> Yep.
12:14:40 <ihope> > (repeat . repeat . repeat . repeat) 1
12:14:42 <mbot> [[[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
12:14:42 <mbot> [5 @more lines]
12:15:21 <Cale> that reminds me, I should submit a few patches against lambdabot
12:15:51 <Cale> (note that it didn't break the line so early)
12:17:27 <ihope> @type \a b c d -> a d (c d) (b d (c d))
12:17:28 <mbot> forall t t1 t2 t3.
12:17:28 <mbot> [5 @more lines]
12:17:31 <ihope> @more
12:17:32 <mbot>              (t2 -> t3 -> t -> t1)
12:17:32 <mbot> [4 @more lines]
12:17:34 <ihope> @more
12:17:35 <mbot>              -> (t2 -> t3 -> t)
12:17:35 <mbot> [3 @more lines]
12:17:37 <ihope> @more
12:17:38 <mbot>              -> (t2 -> t3)
12:17:38 <mbot>              -> t2
12:17:38 <mbot>              -> t1
12:17:49 <ihope> Note the many line breaks.
12:18:02 <ncalexan> Cale: a worthy patch would provide a command line interface...
12:18:23 <__AL__> > [0..10000000] !! 10000000
12:18:23 * ncalexan prays to the giant lambda in the sky
12:18:26 <mbot> 10000000
12:18:34 <__AL__> > [0..100000000] !! 100000000
12:18:39 <mbot> Terminated
12:19:24 <davidhouse> > map (last.enumFromTo 1) [1..]
12:19:26 <mbot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,
12:19:26 <mbot> [5 @more lines]
12:19:40 <davidhouse> what __AL__ was doing but more general :)
12:19:42 <Cale> ncalexan: I mean I have changes in mbot which aren't in lambdabot
12:19:53 <Cale> some minor cosmetic things mostly
12:20:27 <ncalexan> Ah... I know nothing of mbot; what is it in contrast to lambdabot?
12:20:37 <ihope> IIIIIntInterrupInterrupted.
12:20:52 <__AL__> davidhouse,  I'm testing amount of RAM ;)
12:21:06 <Cale> It's a lambdabot with some additional plugins
12:21:20 <ncalexan> Same code base?
12:21:24 <ncalexan> Like a scratch installation?
12:21:42 <Cale> mostly, I changed a few things
12:21:42 <mathrick> what does !! do?
12:21:47 <zellyn> Hi folks
12:21:50 <zellyn> total noob
12:21:55 <Cale> xs !! n is the nth element of xs, zero-indexed
12:21:55 <mathrick> hi
12:22:03 <mathrick> ah
12:22:08 <Cale> zellyn: hello!
12:22:14 <zellyn> Anyone know whether Graphics.SOE should work under vanilla GHC 6.4.1 install under Win2K?
12:22:15 * ncalexan waves.
12:22:19 <mathrick> Cale: but it's nonetheless a linear traversal?
12:22:34 <Cale> zellyn: it should -- I've never tried it there
12:22:36 <zellyn> (I'm working through SOE)
12:22:40 <Cale> mathrick: yes
12:22:46 <zellyn> Seems to run fine, but I see no window.
12:23:07 <Cale> hmm
12:23:24 <zellyn> here's the test file
12:23:37 <zellyn> import Graphics.SOE
12:23:37 <zellyn> main
12:23:37 <zellyn>     = runGraphics (
12:23:37 <zellyn>       do
12:23:37 <zellyn>         w <- openWindow "My First Graphics Program" (300,300)
12:23:39 <zellyn>         drawInWindow w (text (100,200) "HelloGraphicsWorld")
12:23:42 <zellyn>         k <- getKey w
12:23:44 <zellyn>         closeWindow w
12:23:47 <zellyn>       )
12:23:49 <zellyn> nothing complicated
12:24:12 <ncalexan> A very nice idiom that lets you drop the outer parens is runGraphics $ do ...
12:24:27 <zellyn> Aah.  That makes sense.
12:24:38 <ncalexan> f $ x = f x, but with very low right associativity so the syntax works in our favour.
12:24:41 <Cale> hmm, it works for me
12:24:47 <zellyn> really?
12:24:48 <zellyn> Interesting.
12:24:49 <Cale> I'm on Debian linux though.
12:24:53 <zellyn> Eh.
12:25:00 <zellyn> There seem to be comments that win32 doesn't work.
12:25:17 <zellyn> But they're dated ~2003, and say there's an update "soon"
12:25:23 <zellyn> Nothing more recent, though!
12:25:32 <zellyn> I guess I'll run it on my linux box.
12:25:56 <Cale> are you using the Graphics.SOE that comes with GHC?
12:25:56 <davidhouse> anyone recommend an IDE for windows? and GHC/GHCi work on windows, right?
12:26:09 <Cale> they do
12:26:11 <davidhouse> (entering a programming competition tomorrow and there's a chance i'll have to use windows)
12:26:18 <Cale> I never use an IDE
12:26:21 <zellyn> Yeah - just installed the vanilla 6.4.1 GHC.
12:26:29 <davidhouse> unless ghc on linux can be configured to spit out windows binaries, which seems unlikely
12:26:31 <ncalexan> emacs/xemacs :)
12:26:33 <Cale> Emacs is available for windows, I usually use that
12:27:06 <davidhouse> so anything slightly less hardcore than emacs? :)
12:27:13 <Cale> TextPad?
12:27:26 <davidhouse> Cale, i don't mean a fully featured IDE, just something with syntax highlighing and clever indentation
12:27:31 <Cale> ah
12:27:34 <mathrick> what is SOE?
12:27:39 <mathrick> davidhouse: emacs :)
12:27:47 <zellyn> http://haskell.org/soe/
12:27:49 <Cale> mathrick: School of Expression, a Haskell textbook
12:28:00 <mathrick> aha
12:28:06 <davidhouse> eurgh. not emacs. i can't learn it in a night.
12:28:14 <Cale> gvim?
12:28:15 <Cale> hehe
12:28:41 <Cale> TextPad on windows is reasonably nice, but it's not free.
12:28:45 <davidhouse> ;) seriously.
12:29:00 <ihope> So Haskell is the most popular purely functional language, but it's not very popular.
12:29:05 <mathrick> davidhouse: basics can be done overnight
12:29:07 <araujo> ihope, what!?
12:29:15 <ihope> Um.
12:29:18 <ncalexan> Oh, I'm not so sure.  I think people who like it, like it a lot :)
12:29:27 <Cale> heh
12:29:35 <ValarQ> thats quite true :)
12:29:37 <ncalexan> Can popularity be measured with zealotry here?
12:29:42 <ihope> So Haskell is the most popular purely functional language, but there are plenty who have never heard of it.
12:29:45 <ncalexan> True that.
12:30:00 <davidhouse> so no other recommendations?
12:30:04 <Cale> The Alexander Keith's of Programming Languages
12:30:05 <ncalexan> Although, Lisp/Python...
12:30:13 <ncalexan> Right!  Oh, Canada!
12:30:29 <ihope> Eh?
12:30:46 <ncalexan> Keith's is a beer; one of the slogans is "Those who like it, like it a lot."
12:30:52 <ncalexan> Brewed in Halifax, Nova Scotia.
12:31:49 <zellyn> davidhouse: you've checked out http://haskell.org/haskellwiki/Libraries_and_tools#Integrated_Development_Environments right?
12:32:25 <Cale> davidhouse: I think there's a mode for Eclipse
12:32:30 <ncalexan> davidhouse: emacs with some of the windows-like customizations (mapping copy/paste, for example) might be best.
12:33:06 <ValarQ> haskell-mode 2.1 for emacs is quite acceptable
12:33:41 <davidhouse> wow. people really don't listen.
12:33:41 <Cale> does KDevelop run under windows via the Qt port?
12:34:07 <Cale> do you have Visual Studio, there's a Haskell environment for that
12:34:18 <zellyn> Cale, thanks for the help
12:34:19 <davidhouse> ooh, maybe.
12:34:24 <__AL__> > getEnvironment >>= print
12:34:24 <zellyn> I'll try SOE stuff under Linux.
12:34:25 <mbot>  Not in scope: `getEnvironment'
12:34:29 <ncalexan> davidhouse: you said you couldn't learn emacs in a night.  Here are suggestions so that you don't have to learn much.
12:34:50 <sieni> There's Yi and there's the command line. What more do you need?
12:34:51 <Cale> I really don't know how people manage to do any programming on windows. 
12:34:53 <ValarQ> davidhouse: i don't know eamcs, i use it anyway ;)
12:35:00 * SamB suggests learning in day time
12:35:05 <davidhouse> > putStrLn "__AL__: you can't do IO with lambdabot anyway"
12:35:05 <Cale> there don't seem to be any decent terminal emulators
12:35:06 <mbot> No IO allowed
12:35:06 <ncalexan> Cale: Visual Studio :)
12:35:12 <ncalexan> SamB: lol!
12:35:32 <SamB> ;-)
12:35:35 <ihope> > (error . error) "This doesn't work anymore, either."
12:35:36 <mbot> Add a type signature
12:35:40 <ihope> > (error . error) "This doesn't work anymore, either." :: ()
12:35:42 <mbot> Exception
12:35:52 <davidhouse> @type error
12:35:53 <mbot> forall a. [Char] -> a
12:36:03 <davidhouse> why [Char] and not String?
12:36:10 <davidhouse> @type putStrLn
12:36:11 <mbot> String -> IO ()
12:36:23 <Cale> [Char] and String are synonymous
12:36:24 <ihope> davidhouse: why not?
12:36:31 <Cale> type String = [Char]
12:36:45 <davidhouse> i would expect it to be consistente
12:36:47 <davidhouse> *consistent
12:36:55 <davidhouse> or does it go by the programmers type specification?
12:37:05 <Cale> Well, probably the definition for error doesn't have a type declaration
12:37:15 <ihope> Now, there was a simple security vulnerability in lambdabot a while ago.
12:37:37 <davidhouse> > "/quit"
12:37:38 <mbot> "/quit"
12:37:42 <davidhouse> almost works.
12:37:44 <Cale> davidhouse: have you tried TextPad?
12:37:46 <ihope> For example, (error . error) "Muahaha\r\nPART #haskell" would, in fact, part, I think.
12:37:53 <davidhouse> Calse, i haven't how much does it cost?
12:38:07 <davidhouse> Cale, as above
12:38:10 <Cale> you could probably get by with the shareware version
12:38:12 <ihope> davidhouse: using a command doesn't just send it to the server.
12:38:14 <davidhouse> (sorry, typo)
12:38:21 <Cale> it'll be a lot less than visual studio anyway
12:38:34 <ihope> /msg #haskell See?
12:38:49 <davidhouse> ihope: oh, true. i'm just used to typing stuff into the chan and my client picking it up.
12:39:14 <Cale> http://www.textpad.com/download/index.html
12:39:25 <ihope> Occasionally I'll pop into IRC using PuTTYtel.
12:39:26 <Cale> http://www.haskell.org/libraries/Haskell98.syn -- syntax file for TextPad
12:39:52 <davidhouse> yay! evaluation version :)
12:39:57 <davidhouse> Cale, i'll try it. thanks.
12:40:02 <jethr0_> what i love about open source software is that there's always a screenshot links somewhere on the page
12:40:08 <ihope> :davidhouse!n=dave@host86-132-136-86.range86-132.btcentralplus.com PRIVMSG #haskell :ihope: oh, true. i'm just used to typing stuff into the chan and my client picking it up.
12:40:20 <jethr0_> with "commercial"/shareware products this is much less frequently the case
12:40:46 <davidhouse> ihope: where is it getting "dave" from?
12:40:52 <psi> http://www.textpad.com/products/textpad/screenshots/index.html
12:41:05 <ValarQ> davidhouse: from your username maybe?
12:41:11 <davidhouse> ihope, that's my linux login, am i sending that?
12:41:13 <Cale> jethr0_: yeah, textpad has one screenshot there, and it's a poor shot
12:41:21 <ValarQ> davidhouse: you are indeed
12:41:36 <davidhouse> interesting.
12:41:38 <kpreid_> davidhouse: the "dave" is from the information your IRC client sends when it connects
12:41:47 <ihope> Yep.
12:42:07 <davidhouse> kpreid, ValarQ, i see.
12:44:47 * davidhouse boots into windows
12:44:58 <jethr0_> psi: thx. it was just not visible to me at the very first glance (as it should be, unless i'm a moron)
12:44:58 <jethr0_> which i am, unfortunately :)
12:45:09 <davidhouse> btw, just to be sure: there's no (sane) way to configure a linux ghc to spit out windows binaries?
12:45:10 <ihope> Your client's sending something of the form USER foo bar baz qux to the server.
12:45:20 <ihope> I know bar and baz are ignored...
12:46:00 * ihope tests
12:46:09 <davidhouse> i'll take that as a no.
12:46:54 <ihope> Well, I think it's something to do with the way gcc is configured.
12:50:50 <arjanoosting> SyntaxNinja: ping
12:51:58 <kolmodin> woh!
12:52:52 <ihope> @pl map show
12:52:58 <ihope> Um.
12:53:11 <ihope> @bot
12:53:23 <ihope> Bah.
12:53:25 <mauke> map show
12:53:28 <arjanoosting> lambadot is out for a walk it seems
12:53:49 <mauke> it doesn't get more pointless
12:53:53 <mbot> map show
12:53:57 <mbot> ihope: Null
12:54:00 <ihope> Um.
12:54:06 <ihope> @pl putStr . unlines
12:54:18 <mbot> putStr . unlines
12:54:33 <ihope> @pl unlines . map show
12:54:39 <jethr0_> woot
12:54:42 <ihope> Might as well give the whole thing.
12:54:45 <kolmodin> g'damn!
12:54:55 <ihope> @pl putStr . unlines . map show
12:55:26 <jethr0_> that's pretty "pointless" already :)
12:55:37 <jmichaelson> can some explain this for please:
12:55:50 <jmichaelson>   rollDice :: IO Int
12:55:51 <jmichaelson>   rollDice = getStdRandom (randomR (1,6))
12:56:11 <jethr0_> @index getStdRandom
12:56:12 <mbot> System.Random
12:56:18 <jmichaelson> getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
12:56:31 <Cale> sure
12:56:49 <jmichaelson> kind of confusing :/
12:56:50 <jethr0_> what cale will say
12:56:53 <ihope> Haskell's still the shortest here: http://ars.userfriendly.org/cartoons/read.cgi?id=20060309&tid=1987201
12:56:58 <Cale> it takes a function from a generator to a pair of a new random value and new generator
12:57:07 <Cale> and applies it to the system generator
12:57:20 <jmichaelson> hm
12:57:28 <jmichaelson> randomR :: RandomGen g => (a, a) -> g -> (a, g)
12:57:32 <Cale> right
12:57:34 * jethr0_ wonders why our fastest knulcleotide hasn't shown up in the benchmarks yet (i.e. when i looked yesterday). is it submitted already?
12:57:36 <jmichaelson> but randomR takes 2 args
12:57:41 <Cale> you apply it to the first
12:57:52 <ihope> sub x y = if filter isPrime [x..y] == [] then putStr "no primes" else (putStr . unlines . map show) (filter isPrime [x..y])
12:57:55 <Cale> getting something of type  g -> (a,g)
12:58:09 <Cale> and then pass that to the getStdRandom function
12:58:18 <ihope> One line.
12:58:20 <jethr0_> ihope: (==[]) == null
12:58:29 <ihope> @pl sub x y = if filter isPrime [x..y] == [] then putStr "no primes" else (putStr . unlines . map show) (filter isPrime [x..y])
12:58:31 <mbot> sub = ap (ap . flip flip (putStr "no primes") . (if' .) . flip flip [] . (((==) . filter isPrime) .) . enumFromTo) (((putStr . unlines . map show . filter isPrime) .) . enumFromTo)
12:58:51 <jethr0_> ihope: and you've got code duplication
12:59:31 <jethr0_> let ft = filter isPrime [x..y] in putStr $ if null ft then "no primes" else (unlines . map show) ft
12:59:51 <jmichaelson> hm ok
13:00:34 <Lemmih> ihope: Using a 'case' would probably be prettier.
13:00:54 <jethr0_> yup
13:01:34 <jethr0_> case filter isPrime [x..y] of | [] -> putStr "no primes" | x -> (putStr . unlines . map show) x
13:02:11 <Lemmih> s/of |/of/ and s/" |/"; /
13:02:19 <ihope> Could the bit that uses ft be changed to end with "unlines.map show$ft"?
13:02:45 <jethr0_> sry, wrong syntax :)
13:03:00 <astrolabe> modify (\es -> es{ruleSet = ((ruleSet es){boardSize = size})})
13:03:04 <ihope> > (length "null ft", length "ft==[]")
13:03:06 <mbot> (7,6)
13:03:08 <musasabi> putStr $ case filter isPrime [x..y] of [] -> "no primes"; xs -> unlines [show x | x <- xs]
13:03:11 <astrolabe> this seems inelegent ^^^
13:03:20 <ihope> jethr0_: you mean I can't do it?
13:03:21 <astrolabe> any better ideas?
13:03:43 <Lemmih> musasabi: Pretty.
13:03:45 <jethr0_> ihope: no, i was commenting on my wrong syntax that lemmih pointed out nicely enough
13:04:13 <jethr0_> ihope: ($) should work there, but using it too heavily in nested structures could become less readable at some point
13:04:33 <ihope> I don't care about readability here...
13:04:49 <jethr0_> but i agree with lemmih, that a case would be nicer here
13:05:10 <astrolabe> Sorry musasabi: I didn't mean your code was inelegent
13:05:26 <musasabi> np
13:05:39 <ihope> > (case filter isPrime[x..y]of[]->"no primes";xs->unlines[show x|x<-xs]) 3 20
13:05:40 <mbot>  Not in scope: `y'
13:05:52 <ihope> > (\x y -> case filter isPrime[x..y]of[]->"no primes";xs->unlines[show x|x<-xs]) 3 20
13:05:52 <mbot>  Not in scope: `isPrime'
13:05:52 <jethr0_> astrolabe: it's a common problem of mine. modifying nested records is a pain
13:06:25 <astrolabe> jethr0_: Thanks, as long as I'm not the only one.
13:06:28 <jethr0_> astrolabe: you can match in the lambda though
13:06:43 <astrolabe> how do you mean?
13:06:44 <jethr0_> (\es@Type{...} -> ...)
13:07:08 <ihope> > let isPrime x = not (any (\y -> y `mod`x == 0) [1..x-1]) (\x y -> case filter isPrime[x..y]of[]->"no primes";xs->unlines[show x|x<-xs]) 3 20
13:07:09 <mbot>  parse error on input `}'
13:07:13 <ihope> Mmh.
13:07:16 <musasabi> One solution is to have update functions (which can be autogenerated by drift.
13:07:19 <ihope> > let isPrime x = not (any (\y -> y `mod`x == 0) [1..x-1]) in (\x y -> case filter isPrime[x..y]of[]->"no primes";xs->unlines[show x|x<-xs]) 3 20
13:07:21 <mbot> "3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n"
13:07:38 <ihope> Um...
13:07:43 <ihope> Good enough.
13:07:55 <jethr0_> "not . any (==0)" == "all (/=0)"
13:08:23 <ihope> Oh, right.
13:08:25 <SyntaxNinja> hi arjanoosting
13:08:25 <astrolabe> jethr0: I'm afraid I don't follow you.
13:08:55 <musasabi> Usually my record updated end up looking like (\foo -> foo { field = something (field foo) }) this having u_field defined makes it much prettier (u_field something)
13:09:29 <jethr0_> > (\a@(Just b) -> b) $ Just 3
13:09:31 <mbot> 3
13:10:02 <jethr0_> the "a" matches the whole pattern, while the b matches only the content of the Just. this also works with records
13:11:06 <musasabi> (\a@Foo {} -> ) is quite nice to have.
13:11:08 <jethr0_> (\es@Type{ruleSet=rs} -> es{ruleSet = rs{boardSize = size}})
13:11:31 <jethr0_> still not as good as a nice drift'ed modifier though
13:11:49 <astrolabe> Thanks both of you.
13:12:30 <jethr0_> musasabi: i seem to have had cases where {} doesn't work with nullary constructors though. too lazy to look it up in the standard :)
13:12:49 <jethr0_> > (\a@Nothing {} -> "empty") Nothing
13:12:51 <mbot> "empty"
13:13:21 <musasabi> I think it should work for all.
13:13:49 <jethr0_> are datatypes implemented as records or this just "syntactic sugar"?
13:14:41 <musasabi> records are syntactic sugar for datatypes.
13:15:11 <musasabi> it is defined for datatypes whether they were defined with the record syntax or not.
13:16:08 <jethr0_> ah, good to know. so records are just data types for which "accessor" functions are auto-generated, right?
13:17:04 <arjanoosting> hi SyntaxNinja did you get my email?
13:17:36 <arjanoosting> about Debian packages of haxml and frown
13:17:51 <jethr0_> i'm looking for haskell-related pages/blogs. any ideas beyond lambda-the-ultimate and the haskell sequence?
13:19:27 <musasabi> jethr0_: yes, record definition 1) creates the datatype, 2) creates selector functions, 3) creates update functions, that are only accessible through the record update syntax.
13:19:32 <SyntaxNinja> arjanoosting: yeah, but I haven't had a chance to look at it at all :) I am swamped at work. deadline tomorrow.
13:19:48 <SyntaxNinja> arjanoosting: but it'll be high on my priority list when I get out from under that.  Sorry I didn't reply.
13:20:29 <arjanoosting> that's allright
13:21:50 <arjanoosting> i have some deadlines as well :-D
13:23:07 <SyntaxNinja> hurray for work
13:25:34 <mahogny> wait. I just noticed in a newer version of ghc; now haskell not only suck when it comes to circular dependencies but it also spits me in the face? :(
13:26:16 <musasabi> Haskell supports circular dependencies
13:26:20 <ihope> Circular dependencies? You mean with modules?
13:26:28 <musasabi> Just some implementations have problems with them.
13:26:58 <mahogny> ok. and ghc happens to be one?
13:29:35 <ihope> Well, you'll have to be more specific.
13:30:07 <mahogny> one file imports another which imports the first
13:31:11 <SyntaxNinja> mahogny: spits in yoru face? that's impressive
13:31:21 <mahogny> SyntaxNinja, new feature
13:31:27 <monochrom> Interesting. I use "runghc -farrows script.hs", script.hs uses the arrow notation and the HXT (Haskell XML Toolkit) library. Nothing happens. The exit code is 127.
13:31:31 <mahogny> SyntaxNinja, it just required some new hardware support
13:31:32 <SyntaxNinja> mahogny: but yes, GHC implements it, but you have to write the hs-boot file.
13:31:36 <musasabi> mahogny: yes. You might want to look up hs-boot files in the user's manual.
13:31:43 <mahogny> ok
13:31:58 <SyntaxNinja> I'm a big fan of circular modules, I wish haskell did better here.
13:32:26 <adu> do you mean modules with curcular dependancies?
13:32:35 <jethr0_> there's sth evil going on with the colors in the big cairo clock example (http://www.haskell.org/gtk2hs/gallery/cairo-clock/Cairo_Clock_large)
13:32:41 <mahogny> I hate them, but sometimes there is no nice way out
13:33:11 <SyntaxNinja> adu: mutually recursive modules, yes.
13:33:26 <SyntaxNinja> they make perfect sense. I think every language should support them.
13:33:53 <mahogny> I usually consider code badly designed if it has circular dependencies. but as I said, sometimes there is no way out
13:34:55 <SyntaxNinja> mahogny: if mutually recursive data types make sense (and they do!) then mutually recursive modules make just as much sense, IMO.
13:35:41 <mahogny> ...mutually recursive data types make sense? ;) dunno if I have ever seen one with support code so big as to require multiple files
13:37:54 <jethr0_> mahogny: well, i think they "make sense". but in many cases it's just bad modular design to have classes/modules depend on each other unless absolutely necessary
13:38:00 <monochrom> If recursion makes sense then mutual recursion makes sense.
13:38:20 <mahogny> jethr0_, agree
13:38:20 <SyntaxNinja> files have directories and directories are files.  that's one example of mutually recursive data types with a large amount of support code that I ran into recently.
13:38:31 <jethr0_> monochrom: yes, but it should only be mutual if absolutely necessary
13:38:37 <SyntaxNinja> jethr0_: why?
13:38:39 <monochrom> Of course there are also abuses of mutual recursion.
13:38:45 <jethr0_> mutual recursive functions are much harder to reason about
13:38:54 <mahogny> SyntaxNinja, yeah. that is a good example I guess
13:38:54 <jethr0_> can be, at least
13:38:56 <SyntaxNinja> data types, not functions.
13:39:12 <SyntaxNinja> but functions too, maybe.
13:39:21 <mahogny> what should be used in haskell equivalent to float in C?
13:39:34 <Cale> mahogny: Float ?
13:39:37 <mahogny> ok
13:39:42 <jethr0_> SyntaxNinja: i was thinking of OO classes (wrt to "good" modular design). for haskell mutual recursive data types they should fit pretty well inside one module.
13:39:44 <Cale> or Double, of course :)
13:39:57 <jethr0_> but if they are short and it's necessary, mutual recursion might be a nice feature.
13:40:33 <mahogny> mutual recursion is too good a feature to be without
13:40:49 <SyntaxNinja> jethr0_: what if they are big data types like my example?
13:41:02 <musasabi> mutually recursive functions can make sense in Haskell
13:41:05 <monochrom> An automaton of a few state can be very lucidly written as a collection of a few mutually recursive functions (one state one function) or continuations.
13:41:18 <monochrom> s/a few state/a few states/
13:41:20 <jethr0_> SyntaxNinja: yes. but as you know circular directory links are can be a pain.
13:41:53 <SyntaxNinja> jethr0_: I don't think this has anythign to do w/ links.
13:42:06 <monochrom> A top-down parser is a collection of mutually recursive functions.
13:42:06 * jethr0_ wonders why he's always misunderstood. i must be more specific initially :). i have _nothing_ against sane mutual recursive data types. but i think mutually recursive modules should be restrained for compiling/testing/... reasons
13:42:11 <SyntaxNinja> jethr0_: it has to do with a fundamental principal of all filesystems that I've ever used.
13:42:44 <monochrom> Actually, what is a good use of circularly dependent modules?
13:42:46 <jethr0_> allowed, but not _everywhere_, just because it's so easy
13:43:20 <SyntaxNinja> monochrom: scroll back to my example.
13:44:07 <SyntaxNinja> also, I think that in general they make more sense, if you have a collection of fundamental functions that are mutually recursive, then they will all tend to go into one module, since mutually recursive modules are difficult.
13:44:07 <jethr0_> SyntaxNinja: files and directories aren't mutually recursive. directories are recursive and can contain files, but there's no real dependency of files on directories
13:44:23 <SyntaxNinja> but if abstraction demands that they be in different modules, they should be allowed to be.  the functions might not be related to each-other.
13:44:45 <jethr0_> not in theory at least
13:45:01 <jethr0_> but then you start to add "parent" links, etc ^_^
13:46:10 <thetide> these need to go today 2 laptops, both made by good manufacturers. price is 500$ each for them and include shipping, case and wireless router.  message me if interested on aim at ogd443 or msn at mcsltd2@hotmail.com
13:47:06 <monochrom> Let's write a Haskell program to DDoS his msn account XD
13:47:48 <monochrom> (Are the two laptops mutually dependent?)
13:47:54 <jethr0_> bah, just send enough mails until his hotmail quota is full. or have they switched to "unlimited quota" as well?
13:47:59 <jyp> @seen JohnMeacham 
13:48:00 <mbot> JohnMeacham is in #haskell. I don't know when JohnMeacham last spoke.
13:48:55 <adu> @remember next time!
13:49:10 <jethr0_> adu: very informative :)
13:49:13 <jethr0_> @remember
13:49:47 <jethr0_> @todo
13:49:48 <mbot> Unknown command, try @listcommands.
13:51:56 <vincenz> Cale: what
13:52:01 <vincenz> ..'s your website
13:52:27 <ihope> @quote
13:52:27 <mbot>  says:
13:52:31 <ihope> Um.
13:52:35 <ihope> @help quote
13:52:36 <mbot>  @quote <nick>/@quote-add <nick> <quote>
13:52:36 <mbot> Quote somebody, or a random person, or save a memorable quote
13:52:41 <vincenz> @quote vincenz
13:52:41 <mbot> vincenz hasn't said anything memorable
13:52:43 <ihope> @quote ihope
13:52:43 <mbot> ihope hasn't said anything memorable
13:52:46 <vincenz> @version
13:52:46 <mbot> lambdabot 3p287, GHC 6.4.1 (Linux i686 )
13:52:46 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:52:46 <ihope> @quote dons
13:52:47 <mbot> dons hasn't said anything memorable
13:52:49 <ski> lambdabot's gone astray, again ?
13:52:51 <ihope> @quote Cale
13:52:52 <mbot> Cale hasn't said anything memorable
13:52:55 <vincenz> mbot: where is lambdabot
13:53:04 <ihope> @where lambdabot
13:53:04 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:53:06 <adu> > ['0'..'9']
13:53:09 <mbot> "0123456789"
13:53:16 <Cale> hello
13:53:18 <sjanssen> @seen lambdabot
13:53:18 <mbot> I haven't seen lambdabot.
13:53:20 <ihope> > [' '..'~']
13:53:21 <adu> hi
13:53:21 <mbot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
13:53:31 <ihope> That's everything, right?
13:53:36 <ihope> > ['~'..' ']
13:53:37 <mbot> ""
13:53:52 <ihope> > [' '..'\127']
13:53:53 <mbot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL"
13:53:58 <ihope> Yep.
13:54:05 <ski> > ['~','}'..' ']
13:54:07 <mbot> "~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"! "
13:54:12 <adu> > ['~', '}'..' ']
13:54:14 <mbot> "~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"! "
13:54:18 <adu> hehe
13:54:46 <ski> good evening, #haskell
13:54:52 <adu> good evening
13:55:07 <adu> > map chr [32..126]
13:55:09 <mbot> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
13:55:26 <ski> > ord '\DEL'
13:55:28 <mbot> 127
13:56:29 <adu> so can you do fractals with (>>=) ?
13:56:46 <adu> like the 1D cellular automata
13:58:29 <ski> > let step ' ' = "   "; step '#' = "# #" in step =<< step =<< step =<< step =<< "#"
13:58:30 <mbot> "# #   # #         # #   # #                           # #   # #         # #   # #"
13:58:59 <adu> ya
13:59:05 <vincenz> > let ski = reverse ":)" in ski
13:59:06 <mbot> "):"
13:59:16 <jethr0_> > answer "What is the answer to life, the universe and everything?"
13:59:17 * ski grins
13:59:18 <mbot>  Not in scope: `answer'
13:59:34 <vincenz> > god is almighty
13:59:35 <mbot>  Not in scope: `almighty'
13:59:37 <vincenz> damn
13:59:39 <jethr0_> *yuchu*, i just need a function "answer :: String -> a"
13:59:41 <vincenz> > almighty god
13:59:42 <mbot>  Not in scope: `god'
13:59:49 <vincenz> jethr0_: error comes close to that
13:59:53 <jethr0_> could even be "::String -> String"
13:59:54 <ihope> > error "What is the answer to life, the universe and everything?"
13:59:55 <mbot> Add a type signature
13:59:58 <adu> but the 1D cellular automata like in NKS is 3->1 not 1->3
14:00:01 <ihope> > error "What is the answer to life, the universe and everything?" :: ()
14:00:02 <mbot> Exception: What is the answer to life, the universe and everything?
14:00:12 <ihope> Hmm...
14:00:19 <adu> how would you match before and after?
14:00:19 <vincenz> > 2^2^2
14:00:21 <mbot> 16
14:00:22 <vincenz> > 2^2^2^2
14:00:25 <mbot> 65536
14:00:27 <ski> adu : what is NKS ?
14:00:28 <ihope> > (2^2)^2
14:00:29 <jethr0_> > let answer = const 42 in answer "What is the answer to life, the universe and everything?"
14:00:31 <mbot> 16
14:00:33 <mbot> 42
14:00:41 <vincenz> >2^(2^(2^2))
14:00:43 <adu> ski: NKS="New Kind of Science" by Steven Wolfram
14:00:43 <jethr0_> *noooooo*
14:00:46 <vincenz> > 2^(2^(2^2))
14:00:47 <mbot> 65536
14:00:55 <vincenz> >(2^(2^(2^2))
14:00:56 <TuringTest> adu: blech
14:01:00 <ihope> > 6*9
14:01:01 <ski> adu : context-sensitive expansion ?
14:01:01 <mbot> 54
14:01:04 <ihope> Hey!
14:01:12 <jethr0_> spam spam spam
14:01:13 <ski> (adu : haven't read that)
14:01:17 <vincenz> > (((2^2)^2)^2)
14:01:18 <mbot> 256
14:01:20 <vincenz> oh
14:01:25 <vincenz> > 2^2^2^2^2
14:01:25 <adu> TuringTest: blech indeed, but it seems like a good excersize in haskell
14:01:27 <mbot> 20035299304068464649790723515602557504478254755697514192650169737108940595563114530895061308809333481010382343429072631818229493821188126688695063647615470291650418719163515879663472194429309279820843091048559905701593189596395248633723672030029169695921561087649488892540908059114570376752085002066715637023661263597471448071117748158809141357427209
14:01:27 <mbot> [5 @more lines]
14:01:29 <ihope> (^) be right-associateive.
14:01:30 <adu> hey
14:01:34 <vincenz> > 2^2^2^2^2^2
14:01:35 <vincenz> crash
14:01:38 <ihope> Or something like that.
14:01:38 <adu> bad person
14:01:39 <mbot> Terminated
14:01:45 <ski> > take 5 $ iterate (2^) 0
14:01:46 <mbot> [0,1,2,4,16]
14:01:47 <ihope> Do a @quit!
14:01:52 <ski> > take 6 $ iterate (2^) 0
14:01:53 <mbot> [0,1,2,4,16,65536]
14:01:54 <adu> no
14:01:59 <ihope> > iterate (2^) 0
14:02:03 <mbot> [0,1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650169737108940595563114530895061308809333481010382343429072631818229493821188126688695063647615470291650418719163515879663472194429309279820843091048559905701593189596395248633723672030029169695921561087649488892540908059114570376752085002066715637023661263597471448071117748
14:02:03 <mbot> [5 @more lines]
14:02:08 <ihope> Whoa.
14:02:09 <vincenz> hmm
14:02:11 <vincenz> odd it doesn't crash
14:02:11 <adu> yey
14:02:15 <vincenz> cause it's less than 10 elements
14:02:19 <adu> i'm glad other people are interested in tetration
14:02:29 <vincenz> > iterate (1.5^) 0
14:02:31 <mbot> Add a type signature
14:02:35 <vincenz> > iterate (1.5^) 0 :: [Double]
14:02:36 <adu> 1.5**
14:02:37 <mbot>  add an instance declaration for (Integral Double)
14:02:37 * jethr0_ goes about calculating how many rice corns fit on the chess board... ^_^
14:02:43 <ihope> I thought I had extended that to real numbers.
14:02:44 <vincenz> jethr0_: easy
14:02:48 <vincenz> jethr0_: 2^64-1
14:02:49 <jethr0_> just kidding
14:02:53 <vincenz> >2^64-1
14:02:56 <vincenz> > 2^64-1
14:02:58 <mbot> 18446744073709551615
14:03:00 <ihope> > maxBound :: Double
14:03:01 <mbot>  add an instance declaration for (Bounded Double)
14:03:01 <mbot>   In the expression: maxBound :: Double
14:03:01 <mbot>   In the definition of `uou': uou = maxBound :: Double
14:03:03 <vincenz> quite a small number actually
14:03:05 <ihope> Aww.
14:03:05 <vincenz> compared to
14:03:06 <adu> vincenz: so are you interested in tetration?
14:03:23 <adu> my fav is:
14:03:30 <vincenz> > 1^2^3^4^5
14:03:33 <adu> > 3^(3^3)
14:03:36 <mbot> Terminated
14:03:37 <thetide> these need to go today 2 laptops, both made by good manufacturers. price is 500$ each for them and include shipping, case and wireless router.  message me if interested on aim at ogd443 or msn at mcsltd2@hotmail.com
14:03:37 <mbot> 7625597484987
14:03:50 <vincenz> thetide: Stop spamming with different names
14:03:54 <GeniXPro> kick him! quick!
14:03:55 <vincenz> thetide: stick aroudn to explain the specs
14:04:01 <vincenz> thetide: what kind of processor
14:04:04 <vincenz> thetide: do they ship with haskell
14:04:11 <vincenz> thetide: are they functional-programming enabled?
14:04:17 <ihope> They MUST have haskell!
14:04:20 <adu> ban that subnet
14:04:22 <GeniXPro> Do they have HaskellOs?
14:04:34 <vincenz> thetide: is it compatible with ghc 6.1?
14:04:54 <ihope> thetide: what brand are they?
14:04:56 --- mode: ChanServ set +o SyntaxNinja
14:04:59 <GeniXPro> thetide, do they have a high end 3d graphics card that is compatible with blender
14:05:00 --- kick: thetide was kicked by SyntaxNinja (SyntaxNinja)
14:05:05 <vincenz> thetide: do they use lazy evaluation or strict evaluation?/
14:05:10 <GeniXPro> ahh i wanted to keep harrassing him
14:05:13 <adu> vincenz: do you like tetration?
14:05:19 <vincenz> adu: well hmm
14:05:22 <SyntaxNinja> GeniXPro: that's what msg is for
14:05:22 <vincenz> adu: not much to explore
14:05:25 <vincenz> numbers get quick fast
14:05:27 <vincenz> SyntaxNinja: :D
14:05:28 <GeniXPro> ahh
14:05:28 <ihope> Aha, the ops can hide.
14:05:29 <GeniXPro> good point
14:05:34 <vincenz> let's msg him
14:05:35 <adu> vincenz: on the contrary there is tons to explore
14:05:40 <adu> just look at my identities page
14:05:52 <ski> adu : hm, i wonder if tetration could be expressed as some kind of dependent construction
14:06:06 <SyntaxNinja> poke me if he comes back
14:06:07 <vincenz> adu: I've seen that page before :)
14:06:10 <adu> vincenz: thats one of the reasons I researched realnumber tetration, because the only interested range is when the "hyper-exponents" are between -2..2
14:06:26 <vincenz> > 2^-2
14:06:26 <adu> http://tetration.itgo.com/ident.html
14:06:27 <mbot>  Not in scope: `^-'
14:06:29 <vincenz> > 2^(-2)
14:06:31 <mbot> Exception: Prelude.^: negative exponent
14:06:37 <vincenz> > 2**(-2)
14:06:39 <mbot> 0.25
14:06:42 <vincenz> > 2**(-2)**(-2)
14:06:43 <mbot> 1.189207115002721
14:06:47 <vincenz> > 2**(-2)**(-2)**(-2)
14:06:49 <mbot> NaN
14:06:51 <vincenz> groovy
14:06:54 <adu> lol
14:07:01 <vincenz> it's odd
14:07:04 <vincenz> it goes down and then back up
14:07:04 <adu> i'm trying to write a 
14:07:06 <vincenz> does it approach 1?
14:07:14 <adu> write a (***) operator for tetration
14:07:15 <GeniXPro> > map (2^) [0 .. 64]
14:07:17 <mbot> [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,87960930222
14:07:17 <mbot> 08,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,922337203685477
14:07:18 <mbot> 5808,18446744073709551616]
14:07:24 <vincenz> > map "kick" GenixPro
14:07:25 <mbot>  Not in scope: data constructor `GenixPro'
14:07:29 <GeniXPro> lol
14:07:31 <vincenz> good, he's gone
14:07:51 <vincenz> GeniXPro: you're no longer in scope
14:08:01 <GeniXPro> no, i'm in some random if scope
14:08:03 * vincenz can't wait until spore is out
14:08:13 <GeniXPro> have some anyonymus factorial lambda
14:08:24 <vincenz> > ord "z" - ord "a"
14:08:25 <mbot> Couldn't match `Char' against `[Char]'
14:08:26 <adu> i'm thinking of just hard-coding the algorithm for like 5-digit accuracy for tetration
14:08:31 <vincenz> > ord 'z' - ord 'a'
14:08:33 <mbot> 25
14:08:41 <sjanssen> adu: what is tetration?
14:08:43 <adu> cuz it takes a long time to solve for the series
14:08:48 <vincenz> > concat (map (\x -> repeat (ord x - ord 'a') x) "spore")
14:08:49 <mbot> Couldn't match `[a]' against `t -> t1'
14:08:51 <ski> adu : is tetration defined for natural hyper-exponents ? or just positive integer ones ?
14:08:56 <ihope> vincenz: neither can I
14:08:56 <vincenz> @type repeat
14:08:57 <mbot> forall a. a -> [a]
14:08:57 <adu> sjanssen: iterated exponentiation
14:09:05 <vincenz> > concat (map (\x -> replicate (ord x - ord 'a') x) "spore")
14:09:07 <mbot> "sssssssssssssssssspppppppppppppppoooooooooooooorrrrrrrrrrrrrrrrreeee"
14:09:18 <adu> ski: its defined for -1, 0, and naturals
14:09:28 <adu> ski: but i've defined it for real and complex numbers
14:09:41 <adu> x^^-1 = 0
14:09:43 <ihope> > "spore" >>= replicate 50
14:09:44 <adu> x^^0 = 1
14:09:47 <mbot> "ssssssssssssssssssssssssssssssssssssssssssssssssssppppppppppppppppppppppppppppppppppppppppppppppppppoooooooooooooooooooooooooooooooooooooooooooooooooorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
14:09:49 <adu> x^^1 = x
14:09:51 <vincenz> > concat (map (\x -> replicate (1 + fromEnum (even (ord x - ord 'a')) x) "spore")
14:09:54 <mbot>  parse error on input `}'
14:09:56 <adu> x^^2 = x^x
14:09:58 <jethr0_> spam spam spam
14:09:59 <vincenz> > concat (map (\x -> replicate (1 + fromEnum (even (ord x - ord 'a'))) x) "spore")
14:10:03 <mbot> "sspooree"
14:10:03 <adu> x^^3 = x^(x^x)
14:10:09 <ihope> Wonderful spam!
14:10:10 <adu> x^^4 = x^(x^(x^x))
14:10:24 <vincenz> > take 100 $ concat $ replicate "spam "
14:10:28 <mbot> Couldn't match `[[a]]' against `t -> t1'
14:10:37 <vincenz> > take 100 $ concat $ repeat "spam "
14:10:42 <mbot> "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam "
14:10:43 <ski> x^^(n+1) = x^(x^^(n+1))  -- for naturals n
14:10:46 <vincenz> damn mbot is laggy
14:10:50 <jethr0_> > take 2 $ cycle "spam "
14:10:52 <ski> x^^(n+1) = x^(x^^n)  -- for naturals n
14:10:55 <mbot> "sp"
14:10:58 <ihope> > unwords (repeat "spam")
14:11:02 <mbot> "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:11:02 <mbot> [5 @more lines]
14:11:08 <vincenz> or simply
14:11:15 <vincenz> like most 13yr old scriptkiddies
14:11:23 <vincenz> > concat $ repeat "spam "
14:11:26 <mbot> "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam
14:11:26 <mbot> [5 @more lines]
14:11:42 <vincenz> possibly with let concat = send email to random
14:11:49 <jethr0_> for (int i = 0; i < 10; i++) printf("%s ", "spam");
14:12:02 <vincenz> Illegal type: c-language
14:12:10 <adu> ski: any hyper-exponent <=(-2) is undefined because the log of 0 is undefined...
14:12:27 <vincenz> adu: huh?
14:12:28 <ihope> > for (int i = 0; i < 10; i++) printf("%s ", "spam");
14:12:32 <mbot>  parse error on input `='
14:12:34 <vincenz> > 2**(-3)**(-3)
14:12:39 <mbot> 0.9746546091224311
14:12:42 <ski> adu : mhm .. i'm pondering if there's any nice categorification
14:12:47 <vincenz> ski: for spam?
14:12:51 <adu> categorification?
14:12:55 <vincenz> it's the Trash category
14:12:56 <ski> vincenz : ?
14:13:23 <adu> ski: tetration and its inverse are very useful in "classifying" large numbers
14:13:26 <GeniXPro> > map (\c -> chr (if ((ord c)+13) > ord('z') then ((ord c)-13) else ((ord c)+13)) "madmen"
14:13:27 <vincenz> Is there a utf-8 character for a little circly arrow?
14:13:29 <mbot>  parse error on input `}'
14:13:35 <GeniXPro> boo :(
14:13:46 <ski> adu : i.e. in category Set, an object construction that has tetration of cardinalities as cardinality
14:13:57 <GeniXPro> what a crappy rot13
14:13:57 <adu> oh
14:14:02 * vincenz returns to reading one of his several books on ct
14:14:27 <adu> ski: i think there are combinatorial structures that have tetrational-growth
14:14:36 <GeniXPro> > map (\c -> chr (if ((ord c)+13) > ord('z') then ((ord c)-13) else ((ord c)+13)))) "madmen"
14:14:40 <mbot>  parse error on input `)'
14:15:08 <GeniXPro> > map (\c -> chr (if ((ord c)+13) > ord('z') then ((ord c)-13) else ((ord c)+13))) "madmen"
14:15:23 <mbot> "znqzra"
14:15:26 <GeniXPro> yay!
14:15:58 <ski> adu : one problem could be that exponential is contravariant in the iterated argument
14:16:11 <ski> s/iterated/nested/
14:16:48 <TuringTest> > take 5 Text.Regex.splitRegex (mkRegex "()") "foo"
14:16:54 <mbot>  Not in scope: `mkRegex'
14:17:03 <TuringTest> > take 5 (Text.Regex.splitRegex (Text.Regex.mkRegex "()") "foo")
14:17:08 <mbot>  Not in scope: `Text.Regex.mkRegex'
14:17:58 <TuringTest> Text.Regex does bad things with subRegex and splitRegex if the pattern matches an empty string....
14:21:01 <TuringTest> I can almost see splitting on an empty string having a useful meaning.  Hmmm....
14:21:41 <adu> ski: contravariant?
14:22:08 <adu> so what do you guys think of my website?
14:22:52 <ski> adu : as in covariant vs. contravariant functor
14:23:05 <ski> adu : should i explain ?
14:23:41 <adu> no i know the usage in regards to tensors
14:23:47 <ski> ok
14:23:49 <adu> i never heard it used about functions tho
14:24:02 <ski> not functions, *functors*
14:24:19 <adu> ok
14:24:35 <ski> (btw, OO uses the terminology in roughly same meaning, wrt subtyping)
14:24:44 <ski> @type map
14:24:47 <adu> hm
14:24:49 <mbot> forall b a. (a -> b) -> [a] -> [b]
14:24:54 <ski> @type fmap
14:24:59 <mbot> forall (f :: * -> *) b a.
14:24:59 <mbot>    (Functor f) =>
14:24:59 <mbot>    (a -> b) -> f a -> f b
14:25:06 <ski> these are covariant maps
14:25:12 <adu> right
14:25:14 <adu> ic
14:25:15 <ski> s/maps/mappings/
14:25:33 <ski> a contravariant mapping would be like
14:26:03 <ski> cmap :: ContraFunctor f => (a -> b) -> (f b -> f a)
14:26:20 <ski> so, the order is "flipped"
14:26:30 <adu> so are you saying tetration is a map F such that it flips something?
14:26:39 <ski> if you define
14:26:49 <ski> newtype ToBool a = TB (a -> Bool)
14:26:57 <ski> then this is a contravariant type
14:27:25 <Pseudonym> It's a bit like covariant vs contravariant tensors.
14:27:31 <adu> tetration is either Num -> Integer -> Num
14:27:42 <Pseudonym> In that index switching is also a dual operation.
14:27:54 <Pseudonym> And other stuff.
14:27:59 <Pseudonym> It makes sense if you squint hard.
14:28:07 <adu> or Float -> Float -> Float using my definition
14:28:11 <ski> so, if you take 'ToBool (ToBool (ToBool Bool))', this would be isomorphic to '((Bool -> Bool) -> Bool) -> Bool'
14:28:16 <Pseudonym> Personally, I don't like the term "contravariant functor".
14:28:24 <Pseudonym> It makes more sense to me to say "F^op is a functor".
14:28:36 <ski> or, 'Bool^(Bool^(Bool^Bool))'  .. there's your tetration
14:29:00 <adu> but ^ isn't defined for bool
14:29:12 <ski> this is type-level operations
14:29:17 <adu> oh ok
14:29:23 <ski> think of '^' as function-space construction
14:30:29 <ski> Pseudonym : yes, especially since the 'covariant' vs. 'contravariant' dichotomy seems to be totally unrelated to the 'co-X' vs. 'X' dichotomy
14:31:10 <Pseudonym> Right.
14:31:36 <Pseudonym> I think it's like "adjoint".  Mac Lane saw an analogy and grabbed the term.
14:31:37 <Pseudonym> Or something.
14:31:51 <Pseudonym> (Actually, I don't think Mac Lane came up with adjunctions.)
14:31:59 <ski> hm, what other meaning is there of 'adjoint' ?
14:32:26 <Pseudonym> Adjoint matrices.
14:33:01 <ski> (in my limited understanding, adjunction situations seems like "half" of an equivalence situation between two categories)
14:33:03 <Pseudonym> Adjoint matrices can be moved across inner products.
14:33:11 <ski> Pseudonym : ok, dunno about those
14:33:17 <Pseudonym> We'll use Dirac notation for inner products,
14:33:29 <Pseudonym> <x | y> is x `dotProduct` y
14:33:36 <Pseudonym> That makes the notation a bit easier.
14:33:42 <Pseudonym> Suppose:
14:34:04 <Pseudonym> <M x | y> = <x | M* y> for some matrices M, and M*, then M* is M's adjoint.
14:34:10 <ski> (adu : did you see my point ?)
14:34:27 <ski> interesting
14:34:42 <Pseudonym> You can see how that looks kinda like a category adjunction if you squint.
14:34:49 <adu> um
14:35:02 <ski> i suppose the matrices goes in opposite directions ?
14:35:07 <sili> sounds complicated
14:35:21 <adu> ski: i really don't see how tetration is contravariant
14:36:05 <Pseudonym> If F and G are adjoint, then C[F a, b] == D[a, G b]
14:36:13 <adu> igtg
14:36:51 <Pseudonym> I don't know if there is any deeper connection, or they just superficially look similar.
14:37:06 <ski> adu : i meant that the iterated construction was contravariant, instead of covariant, as in addition,multiplication,exponent
14:37:15 <ihope__> @pl s=\x y->putStr$case[z|z<-[x..y],p x]of[]->"N";z->z
14:37:19 <mbot> (line 1, column 41):
14:37:19 <mbot> unexpected ">" or "-"
14:37:19 <mbot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
14:37:25 <ihope__> Aww.
14:38:22 <ski> (adu : with addition, '1 +' is iterated, with multiplication, 'x +' is iterated, with exponentiation 'x *' is iterated, with tetration 'x ^' is iterated)
14:38:53 <Pseudonym> It might go deeper, because in Dirac notation, |x> is a covariant vector (or just "vector") and <x| is a contravariant vector.
14:39:20 <ski> Pseudonym : what are those two things ?
14:39:25 <Pseudonym> Bivector, one-form, linear form... can never keep these terms straight.
14:39:26 <ihope> @type \x y->putStr.$case[show z|z<-[x..y],p x]of[]->"N";z->unlines z
14:39:33 <mbot> Not in scope: `.$'
14:39:33 <mbot>  
14:39:33 <mbot> <interactive>:1:36: Not in scope: `p'
14:39:46 <Pseudonym> ski: It's spinor algebra.
14:40:01 <Pseudonym> Spinor algebra is a way to describe what happens if you're allowed to split inner products in half.
14:40:09 <Pseudonym> And treat each half as a mathematical object.
14:40:17 <ihope> @type \x y->putStr$case[show z|z<-[x..y],p x]of[]->"N";z->unlines z
14:40:17 <Pseudonym> <x | y> is an inner product.
14:40:21 <mbot> Not in scope: `p'
14:40:33 <ihope> @type \p x y->putStr$case[show z|z<-[x..y],p x]of[]->"N";z->unlines z
14:40:38 <mbot> forall a.
14:40:38 <mbot>                        (Enum a, Show a) =>
14:40:38 <mbot>                        (a -> Bool) -> a -> a -> IO ()
14:40:44 <Pseudonym> Spinor algebra gives you a way to manipulate <x| and |y> separately such that <x| multiplied by |y> is <x|y>.
14:41:00 <ski> what is the 'multiplication' there ?
14:41:07 <Pseudonym> It's a formal operator.
14:41:22 <Pseudonym> One way you can visualise this is to think about formal langauges.
14:41:35 <Pseudonym> Suppose that the vector space is orthonormal.
14:41:39 * ski doesn't like word 'formal' used in that way
14:41:47 <Pseudonym> Then <x|x> = 1, and <x|y> = 0
14:41:54 <Pseudonym> Right>?
14:42:03 <Pseudonym> That's what it means for the vector space to be orthonormal.
14:42:05 <ihope> What if x = y?
14:42:17 <ski> Pseudonym : ok
14:42:25 <ihope> @type \p x y->putStr$case[z|z<-[x..y],p x]of[]->"N";z->z
14:42:29 <mbot> (Char
14:42:29 <mbot> [4 @more lines]
14:42:31 <Pseudonym> ihope: x and y are different, okay?
14:42:33 <ihope> @more
14:42:34 <Pseudonym> OK.
14:42:36 <mbot>                    -> Bool)
14:42:36 <mbot> [3 @more lines]
14:42:38 <ihope> @more
14:42:41 <mbot>                   -> Char
14:42:41 <mbot>                   -> Char
14:42:41 <mbot>                   -> IO ()
14:42:56 <Pseudonym> Now think about regular expressions for a moent.
14:42:58 <Pseudonym> moment
14:42:59 <ihope> At least it typechecks :-P
14:43:21 <Pseudonym> I wont' go through all of the axioms of regular algebra, but it's an idempotent semi-ring with an exponent operator (Kleene star).
14:43:39 <Pseudonym> Axioms like: E + E = E (that's the idempotent part)
14:43:47 <Pseudonym> And: 0 E = 0
14:43:49 <Pseudonym> Where 0 is empty set.
14:43:53 <Pseudonym> And: 1 E = 1
14:43:55 <ski> yes
14:43:59 <Pseudonym> Where 1 is empty string.
14:44:05 <Pseudonym> Right.
14:44:20 <Pseudonym> You can think of <x| as being a stack operation.
14:44:26 <Pseudonym> It pushes the symbol x onto a stack.
14:44:41 <Pseudonym> So regular algebra + orthonormal spinors == push-down automata.
14:45:03 <Pseudonym> If you remember back, push-down automata are like regular automata except they have a stack.
14:45:20 <Pseudonym> <x| means "push x", and |x> means "pop x"
14:45:21 <ski> mhm
14:45:28 <Pseudonym> So: <x| |x> = 1
14:45:36 <Pseudonym> i.e. pushing x and popping x is like consuming the empty string.
14:45:42 <Pseudonym> <x| |y> = 0
14:45:50 <Pseudonym> Because pushing x and popping y can't be done.
14:45:56 <Pseudonym> So it's like consuming the empty set.
14:45:57 <ski> interesting
14:46:16 <Pseudonym> (a <x|)* (b |x>)* is the language a^n b^n
14:46:36 <ski> at end, stack should be empty, i suppose
14:46:39 <Pseudonym> Right.
14:46:48 <Cale> Pseudonym: What does this have to do with spinors?
14:46:50 <Pseudonym> But you can enforce that by putting an "end of stack" symbol on.
14:46:58 <ski> bah
14:47:00 <Pseudonym> <0| (a <1|)* (a |1>)* |0>
14:47:11 <ski> down with end-of-X symbols !
14:47:17 <Pseudonym> I agree.
14:47:22 <Pseudonym> But if it matters, it can be done.
14:47:24 <Pseudonym> That's the point.
14:47:37 <Pseudonym> Cale: Because the algebra of stack operations is the same as the algebra of Dirac spinors.
14:47:49 <Pseudonym> The other axiom of spinor algebra is the change-of-basis axiom.
14:47:58 <Pseudonym> In our case:
14:48:08 <Pseudonym> |0><0| + |1><1| + ... = 1
14:48:24 <Pseudonym> Basically, if you pop any symbol and then push it again, it's like a no-op.
14:48:42 <Pseudonym> Pedants will wonder what to do with an empty stack.
14:48:47 <Pseudonym> Ignore them.
14:48:48 <Pseudonym> :-)
14:49:12 <Pseudonym> Now, here's the cool part.
14:49:32 <Pseudonym> With these stack manipulations, the stack symbols form an orthonormal vector space.
14:49:36 <Pseudonym> As we mentioned.
14:49:41 <ski> m
14:50:02 <Pseudonym> BTW, we can model Turing machines by using two stacks.
14:50:31 * ski somehow associates this with DCGs
14:50:31 <Pseudonym> Partition the stack symbols into two, and make operations on different stacks commute.
14:50:51 <ihope> > length "\x y->putStr.unlines$[show z|z<-[x..y],p x]"
14:50:52 <mbot>  lexical error in string/character literal
14:50:56 <Pseudonym> So push-0-on-stack-1 and push-3-on-stack-2 commutes.
14:50:58 <ihope> > length "\\x y->putStr.unlines$[show z|z<-[x..y],p x]"
14:51:01 <mbot> 43
14:51:09 <ski> yes
14:51:10 <Pseudonym> Now lets' suppose for a moment that the vector space ISN'T orthonormal.
14:51:28 <Pseudonym> We allow shades of grey between 0 and 1 (empty set and empty string).
14:51:39 <Pseudonym> We now have a formal language model for a quantum computer.
14:52:12 <Pseudonym> The details are left as an exercise.
14:52:18 <ihope> @hoogle IO RealWorld
14:52:20 <mbot> http://www.mail-archive.com/haskell@haskell.org/msg18194.html
14:52:22 <ski> for quantum recognition ?
14:52:26 <Pseudonym> Yup.
14:52:27 <ihope> !
14:52:30 <ihope> !help hoogle
14:52:42 <ihope> @help hoogle
14:52:42 <mbot>  @help <command> - ask for help for <command>
14:53:05 <Pseudonym> So, for example, you could write a program that accepted prime-length strings and runs in P time.
14:53:17 <Pseudonym> Well, you can do that on a Turing machine, too.
14:53:25 <Pseudonym> But you get the idea.
14:53:45 <Pseudonym> Pretty cool, no?
14:53:53 <ski> '<x|' is left-inverse of '|x>', yes ?
14:53:53 <monochrom> heh
14:53:55 <ihope> Oh! Oh!
14:54:02 <Pseudonym> ski: No.
14:54:17 <Pseudonym> <x| is the dual of |x>
14:54:36 <Pseudonym> It's not the left-inverse because there is no "identity vector".
14:54:44 <ski> hm
14:54:48 <Pseudonym> There is no vector |v> such that |x> = |x> |v>
14:55:07 <ski> how about 1 ?
14:55:09 <Pseudonym> <x| is contravariant and |x> is covariant
14:55:15 <Pseudonym> This is a vector space.  1 is a scalar
14:55:23 <ski> ah, right
14:55:45 <goron> Pseudonym: you are only suggesting that you can model quantum computation on a Turing machine (i.e., you are not suggesting that one can get the benefits of a quantum computer on a Turing machine).
14:55:57 <Pseudonym> Nope.
14:56:08 <jethr0_> Pseudonym: are there applications that come to your mind? i.e. are there interesting proofs for vector spaces that can be applied to this stack machine?
14:56:13 <Pseudonym> All I'm doing is giving a formal language model for a Quantum Turing machine.
14:56:22 <Pseudonym> jethr0_: I have no idea.
14:56:26 <ihope> Quantum Turing machine...
14:56:27 <jethr0_> hehe
14:56:28 <goron> Pseudonym: Ok, well, that has been done before, still nice :)
14:56:29 <ski> Pseudonym : your 'a', 'b' above, were they vectors or scalars ?
14:56:36 <Pseudonym> They are scalars.
14:56:49 <Pseudonym> In fact, they're like variables.
14:56:54 <ihope> Just what's this quantum stuff all about?
14:57:10 <Pseudonym> You can compute derivatives with respect to them.
14:57:24 <goron> ihope: about a device which we don't have yet. (at least no interesting ones)  
14:57:26 <Pseudonym> And substitute constants in for them.
14:57:31 <ihope> :-P
14:57:41 <Pseudonym> But that's another story.
14:57:52 <ski> (Pseudonym : like environment structures, then ?)
14:58:06 <Pseudonym> Not really, no.
14:58:25 <Pseudonym> They're like pronumerals.
14:58:35 <ski> not like polynomial rings, etc, then ?
14:58:41 * Pseudonym thinks
14:58:42 <Pseudonym> Maybe.
14:58:48 <Pseudonym> I'd have to think about that.
14:58:52 <Pseudonym> An example may help.
14:59:04 * ski wonders what a 'pronumeral' is
14:59:07 <Pseudonym> Here's how you do symbolic differentiation:
14:59:30 <Pseudonym> Remember that + is set union, and juxtaposition is appending strings.
14:59:45 <Pseudonym> da/da = 1
14:59:49 <Pseudonym> db/da = 0
14:59:50 * ski thinks DCGs
14:59:53 <Pseudonym> (b /= a)
15:00:08 <Pseudonym> d(A + B)/da = dA/da + dB/da
15:00:21 <ski> what does differentiation mean, here ?
15:00:28 <Pseudonym> ski: I'll get tot hat.
15:00:34 <ski> k
15:00:38 <Pseudonym> Append is tricky:
15:00:54 <Pseudonym> d(AB)/da = dA/da B + A(0) dB/da
15:01:04 <Pseudonym> Where A(0) means substitution 0 in for all of the pronumerals.
15:01:14 <ski> example ?
15:01:23 <Pseudonym> e.g.: if A = a b, then A(0) = 0 0
15:01:33 <Pseudonym> And if B = a*, then B(0) = 0* = 1
15:01:34 <ski> strange
15:01:52 <Pseudonym> d(A*)/da = dA/da A*
15:01:59 <Pseudonym> That's the same rule as exp, BTW.
15:02:08 <ski> hm ?
15:02:14 <Pseudonym> d(e^A)/dx = dA/dx e^A
15:02:19 <ski> ah
15:02:25 <Pseudonym> Now.
15:02:29 <Pseudonym> Give me a regular expression.
15:03:18 <ski> (ab+)+
15:03:35 <Pseudonym> OK.  I'll expand that as: (abb*)(abb*)*
15:03:38 <jethr0_> ([^a-e]f?)|(de*f)
15:03:43 <ski> yes
15:03:51 <Pseudonym> OK.  I'll expand that as: abb*(abb*)*
15:04:00 <Pseudonym> Let's call that E0
15:04:12 <Pseudonym> So E0(0) = 0 (work it out and you'll see)
15:04:22 <Pseudonym> And dE0/da = bb*(abb*)*
15:04:26 <Pseudonym> And dE0/db = 0
15:04:47 <ski> (see that it becomes 0, yes)
15:04:47 <Pseudonym> Basically, dE/da is the set of all strings in E which start with a, with the a removed.
15:05:21 <Pseudonym> IOW, dE/da is the regular expression corresponding to the DFA state that you would go to if you saw an a.
15:05:55 <Pseudonym> E(0) is 1 if E can derive the empty string, and 0 otherwise
15:05:56 <ski> this starts to sound like conor mcbride's type derivatives
15:06:16 <Pseudonym> i.e. 1 if the initial DFA state for E is a final state, and 0 if it isn't.
15:06:20 * ski tries to keep up reading
15:06:39 <Pseudonym> Now a DFA state, as we know, is characterised by two things:
15:06:43 <Pseudonym> 1. Is it initial or final?
15:07:02 <Pseudonym> 2. Which symbols can it accept, and what states would those symbols take you to?
15:07:10 <Pseudonym> In this notation:
15:07:24 <Pseudonym> E = E(0) + a dE/da + b dE/db + ... + z dE/dz
15:07:43 <Pseudonym> The first term being whether or not it's a terminal state, and the other terms being transitions.
15:07:55 <Pseudonym> So not only is this a purely algebraic way to construct DFAs...
15:08:01 <Pseudonym> That's also Taylor's theorem.
15:09:13 <Pseudonym> f(x) = f(0) + x f'(x)
15:10:21 <Pseudonym> I think we were originally talking about Dirac notation, weren't we? :-)
15:11:18 <ski> is '<x | y>' dirac notation ??
15:11:22 <Pseudonym> yES.
15:11:29 <Pseudonym> It's an inner product.
15:11:40 <Pseudonym> <x| is a bra, |y> is a ket
15:11:46 <Pseudonym> When they meet, the form a bracket.
15:12:44 <palomer> where did the c go?
15:12:52 <ski> Pseudonym : is there any nice paper explaining in more detail this whereof you have spoken ?
15:13:01 <Pseudonym> I don't know.
15:13:14 <Pseudonym> Mark Hopkins was writing an autograph, but I don't think he ever finished it.
15:13:22 <Pseudonym> @google "mark hopkins"
15:13:24 <mbot> http://www.san-francisco.intercontinental.com/
15:13:33 <Pseudonym> That doesn't sound promising.
15:13:37 <Pseudonym> @google "mark hopkins" quantum
15:13:38 <mbot> http://www.photonics.ac.uk/lib/general%20papers/Tampere.pdf
15:13:43 <Pseudonym> Hmmm.
15:13:48 <Pseudonym> @google "mark hopkins" formal language
15:13:49 <mbot> http://compilers.iecc.com/comparch/article/94-02-110
15:14:05 <Pseudonym> Ah, the comp.compilers archive has some stuff.
15:14:25 <Pseudonym> I must say, this is the only truly useful thing I ever learned "from a guy on Usenet".
15:14:34 <Pseudonym> The guy being Mark Hopkins. :-)
15:14:39 <ihope> bear hatchery Hello,. World ..
15:14:40 <ihope>  powers
15:15:23 <ski> heh
15:15:34 <ihope> > foo
15:15:35 <mbot>  Not in scope: `foo'
15:15:36 <ihope> > bar
15:15:36 <mbot>  Not in scope: `bar'
15:15:40 <ihope> Aww.
15:15:50 <palomer> ski: do you know how ghc checks against annotations?
15:16:00 <palomer> like: f:: a -> b ; f x = x
15:16:27 <ski> what do you mean ?
15:16:28 <Pseudonym> J. A. Brzozowski. Derivatives of regular expressions. J. ACM, 11(4):481--494, 1964. 
15:16:40 <Pseudonym> See if you can dig that one up.
15:16:42 <ski> danke
15:16:44 <palomer> ski: that fails to check in ghc, and I'm wondering how ghc figures it out
15:17:04 <Pseudonym> http://citeseer.ist.psu.edu/chen03coalgebraic.html
15:17:11 <Pseudonym> That might have some good stuff in it too.
15:17:30 <Pseudonym> And if not, it'll have good citations.
15:17:40 <ski> m
15:18:08 <Pseudonym> Oh, I also have code.
15:18:17 <ski> palomer : i assume it checks that the inferred type is less general than the declared one ..
15:18:33 <ski> Pseudonym : where ?
15:18:41 <ihope> universe bear hatchery Hello,. world!.
15:18:45 <ihope>  powers   marshy marshy snowmelt
15:19:00 <palomer> ski: the infered type is less general than the the declared type, in this case
15:19:04 <Pseudonym> ski: It's part of Swish now.
15:19:06 <Pseudonym> The DFA module.
15:19:47 <Pseudonym> Ah, it's also here: http://cvs.sourceforge.net/viewcvs.py/haskell-libs/libs/text/
15:19:53 <ski> ok
15:23:24 <astrolabe> @eval toEnum 'A'
15:23:25 <mbot> Couldn't match `Int' against `Char'
15:23:42 <astrolabe> @eval fromEnum 'A'
15:23:46 <mbot> 65
15:24:11 <astrolabe> @eval (toEnum 65)::Char
15:24:12 <mbot> 'A'
15:24:18 <ski> > fromEnum 'A'
15:24:20 <mbot> 65
15:29:45 <luqui> I want to embed haskell into a C++ project of mine
15:29:52 <palomer> don't do it!
15:29:52 <luqui> where can I learn how to do that?
15:30:03 <luqui> palomer, why?
15:30:10 <palomer> because C++ is a far better language
15:30:14 <luqui> ha!
15:32:20 <mathrick> palomer: better than what?
15:32:41 <Pseudonym> Than C++ with embedded Haskell, presumably.
15:32:42 * mathrick will agree it's better than BASIC
15:32:45 <mathrick> perhaps
15:32:49 <mathrick> but not really sure
15:33:05 <palomer> than most anything
15:33:36 <palomer> it combines the abstraction of assembly with the flexibility of ada
15:33:38 <luqui> so disregarding palomer's beliefs, is there any information on how i can do that?
15:33:45 <jethr0_> luqui: embedding is such a strong word. calling c from haskell and vice versa is quite feasable with c2hs, .... but true embedding in the sense of "eval" and scripting isn't so easy
15:34:01 <palomer> you could also use ghc's ffi
15:34:02 <mathrick> palomer: ah, okay, for a moment I thought you were endorsing C++ :)
15:34:05 <luqui> jethr0_, just calling haskell from c++ will do
15:34:40 <jethr0_> yes, you can do that with FFI either directly or using c2hs, ...
15:34:54 * luqui looks up FFI
15:35:03 <Lemmih> c2hs is probably overkill.
15:35:27 <goron> You can't do everything with the FFI, though.
15:35:36 <luqui> goron, 'splain
15:35:48 <goron> Variable number of arguments does not work.
15:35:55 <goron> Variable at run-time that is.
15:36:38 <luqui> goron, well, I get to write the bindings
15:36:43 <luqui> so I think that will be fine
15:36:56 <palomer> luqui: but, really, what do you want haskell to do in your project?
15:37:00 <TuringTest> ping dons
15:37:06 <jethr0_> luqui: look at "http://jethr0.dyndns.org/repos/hlibc/" for an (admittedly stupid) example
15:37:11 <luqui> palomer, it is the AI scripting architecture
15:37:18 <luqui> because the AI needs to do wacky abstract stuff
15:37:32 <palomer> yeah, anything involving reasoning is best done with haskell
15:37:46 <palomer> or maybe mercury
15:38:41 <jethr0_> or maybe lisp for some dynamic symbol magic
15:39:04 <luqui> not that kind of AI
15:39:09 <luqui> but if it were, then I'd agree
15:39:13 <goron> luqui: "wacky abstract stuff"
15:39:18 <goron> luqui: how nice!
15:39:20 <palomer> dynamic symbol magic?
15:39:54 <palomer> symbols can be easily done with haskell
15:40:03 <palomer> data Symbol = Symbol String
15:40:09 <luqui> palomer, true enough
15:40:26 <palomer> and, if your symbol space is finite, it becomes safe
15:40:34 <jethr0_> :)
15:41:47 <jethr0_> palomer: i haven't thought about implementing some of the example of "paradigms of AI programming" in haskell. so i really haven't been confronted with that kind of symbolic programming in haskell. but i guess most examples can be easily adopted
15:41:51 <Pseudonym> Actually, if you're tempted to use Mercury, you might be better off writing a resolution engine in either Haskell or even C++.
15:42:05 <Pseudonym> Haskell would be better, naturally.
15:42:21 <jethr0_> mercury fared pretty well in some of the ICFP contests i noticed
15:42:23 <Pseudonym> It's something like 20 lines, most of which is unification.
15:42:40 <jethr0_> Pseudonym: resolving what?
15:42:50 <Pseudonym> Yeah, but that's because the Mercury guys are all discriminating hackers. :-)
15:43:02 * luqui wrote a unificatoin engine in Perl, and was surprised how simple it was
15:43:12 <Pseudonym> Just about everyone (including myself) were good at ugly speed-coding in declarative languages.
15:43:30 <palomer> well, if your specification is done using inference rules, then mercury is the best choice
15:43:35 <goron> Haskell looks like assembler in the Great Language Shootout.
15:43:39 <jethr0_> luqui: have you looked at my link?
15:43:48 <palomer> if it's done using algebraic equations, any functional language is your best choice
15:43:50 <Pseudonym> jethr0_: http://en.wikipedia.org/wiki/Resolution_(logic)
15:43:55 <luqui> jethr0_, yeah, I'm browsing right now
15:44:01 <jethr0_> hehe
15:44:06 <palomer> if its done temporally, sml or C++ is your best option
15:44:22 <Pseudonym> I agree about that, BTW.  The Haskell code in the shootout is really, really terrible.
15:44:25 <jethr0_> goron: i know. but some of the entries are still nice-looking
15:44:29 <Pseudonym> It's an awful advertisement for Haskell.
15:44:46 <Pseudonym> "If you want efficient Haskell, you need to write code that looks like THIS."
15:44:57 <palomer> yeah, it's horrible stuff
15:45:03 <palomer> efficient haskell is an oxymoron
15:45:10 <jethr0_> goron: the current looks are partially due to the rules preventing more idiomatic solutions. in some parts rightly so, but in others i perceive it rather as discrimination :)
15:45:19 <Pseudonym> It's not an honour to beat C at its own game.
15:45:27 <Pseudonym> Haskell plays a different game.
15:45:36 <goron> Someone on the mailing lists said that too.
15:45:43 <palomer> spin the bottle?
15:45:49 <jethr0_> there were many fast _and_ nice entries, but they didn't fulfill the strict "rules"
15:45:58 <cpatrick_> I get the impression though that a lot of the tricks that make Haskell code ugly and fast could be done by the compiler
15:45:58 <Pseudonym> Right.
15:46:02 <cpatrick_> perhaps with some hints
15:46:05 * cpatrick_ cpatrick
15:46:10 <cpatrick> bleh
15:46:17 <Pseudonym> I personally thing that what we really need is an ideomatic language shootout.
15:46:28 <Pseudonym> The pseudoknot benchmark is the best attempt so far, IMO.
15:46:33 <jethr0_> Pseudonym: yes, exactly what i proposed yesterday
15:46:38 <palomer> I think we should let the language solve it anyway it wants
15:46:44 <Pseudonym> You pick a nontrivial problem, and everyone gets to solve it in their own ideomatic way.
15:46:57 <palomer> stop stealing my ideas!
15:46:59 <Pseudonym> :-)
15:47:09 <jethr0_> palomer: that's a problem because then people develop too specialized entries to be compared with language features
15:47:11 <Pseudonym> Fergus and I came up with the same idea in 1996, for the record.
15:47:13 <goron> I think the Haskell compilers are not Sufficiently Smart. 
15:47:22 <Pseudonym> We picked a few problems, too.
15:47:22 <goron> They are Smart, but not Smart Enough.
15:47:30 <Pseudonym> MPEG-1 encoding was one suggestion.
15:47:32 <palomer> ghc is great for implementing every paper that peyton jones has published
15:47:38 <jethr0_> then everyone would just implement the best algorithm and the whole thing would get further away from the languages, and more towards which compiler optimized the most
15:47:45 <jethr0_> and then mlton would always win ^_^
15:47:50 <Pseudonym> Pseudoknot would be one of them.
15:47:51 <palomer> go mlton!
15:47:59 <Pseudonym> Because that's just a really nice problem.
15:48:11 * Pseudonym thinks
15:48:16 <Pseudonym> Can't remember what else we came up with.
15:48:21 <Pseudonym> Oh, soemthing with FFT.
15:48:25 <palomer> I always thought the shootout was about compilers, not about languages
15:48:33 <Pseudonym> Like, computing digits of pi using a Ramunajan algorithm.
15:48:40 <ptolomy> @pl \x -> (x, show x)
15:48:41 <mbot> ap (,) show
15:48:41 <jethr0_> i proposed collecting the readable _and_ fast entries into an idiomatic page
15:49:11 * palomer is off
15:49:15 <jethr0_> maybe i'll do that on my own, one of these days
15:49:26 <luqui> jethr0_, what is Control.Arrow used for in unistd.hs?
15:50:07 <jethr0_> luqui: sry, one of my first haskell projects, before i imported everything qualified... let me see
15:50:08 <goron> I don't think a bound on the algorithms should be placed, since the algorithms can be reimplemented in the other language. 
15:50:34 <Pseudonym> I think it's fair to say that the same "algorithm" should be used.
15:50:40 <jethr0_> luqui: "second"
15:50:50 <Pseudonym> e.g. "This ILP problem should be solved using simplex branch-and-bound."
15:50:53 <goron> Pseudonym: who decides what alg. to use?
15:51:01 <Pseudonym> The people who set the problems.
15:51:10 <Pseudonym> But it should only be a high-level description.
15:51:13 <goron> Pseudonym: Still there is a bias.
15:51:14 <jethr0_> Pseudonym: i agree. but there should be some leeway for micro-implementation
15:51:18 <Pseudonym> Sure.
15:51:23 <luqui> jethr0_, so this exports functions from haskell into C
15:51:30 <luqui> do you have an example going the other way around?
15:51:31 <Pseudonym> Whether you use lists or arrays is up to you.
15:51:51 <jethr0_> for example for the knucleotide there was some discussion whether unused matches have to be calculated. that's just stupid in a lazy language
15:51:52 <Pseudonym> So long as you use backtracking search.
15:51:53 <Pseudonym> Say.
15:52:02 <jethr0_> luqui: i thought that's what you wanted...
15:52:16 <luqui> well I kinda want both
15:52:38 <jethr0_> luqui: other way round you can find everywhere. let me look for an example... but there are some in the ffi tutorial
15:52:43 <Pseudonym> Oh, I also suggested a finite element Poisson equation solver.
15:52:44 <luqui> okay
15:52:56 <Pseudonym> Hang on, I hear a siren.  BBS
15:53:23 <jethr0_> luqui: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3
15:53:54 <Pseudonym> Nope, just a drill.
15:54:03 <Pseudonym> Working in a chemistry lab building has made me a bit jumpy.
15:54:08 <Pseudonym> My office has a low oxygen sensor.
15:54:20 <luqui> jethr0_, looks simple enough
15:54:24 <Pseudonym> Presumably if it goes off, I hold my breath before trying to opent he door.
15:54:36 <luqui> I'm guessing it won't grok C++ headers though
15:54:39 <jethr0_> luqui: i've never bound to C++ though... c2hs is actually quite nice in that respect
15:54:42 <luqui> so I have to put a C layer in between
15:55:23 <jethr0_> luqui: not necessarily, but you'd have to ask someone who's done that before. from what i heard, gth2hs is a perfect example of c2hs usage. but AFAIK gtk is objective c, so not quite c++
15:55:47 <sjanssen> GTK is plain old C
15:56:06 <jethr0_> oh, even that
15:57:11 <goron> GTK emulates an object system in C, that was pretty  amusing when I actually saw the code.  
15:57:34 <luqui> thanks for your help jethr0_ 
15:57:47 <jethr0_> np
15:58:49 <Pseudonym> That's no different from Xt.
15:58:59 <Pseudonym> Except that GTK has a lot more convenience macros than Xt.
15:59:58 <goron> Pseudonym: What is Xt?
15:59:58 <jethr0_> someone should write a swig backend for haskell :)
16:00:59 <Pseudonym> What?!
16:01:04 <jethr0_> i liked the commentary from the swig author "well, i had to do this job i knew i would hate, so i wrote a tool to do it for me in a few days" (from memory). very cool guy!
16:01:07 <Pseudonym> You youngins!
16:01:17 <Pseudonym> With yer Qt and yer GTK...
16:01:28 <Pseudonym> Probably never heard of Athena or Motif...
16:01:45 <goron> Well, I heard about Xt, I just don't know what it is. 
16:01:53 <Pseudonym> Xt is an object model in C.
16:01:57 <goron> I know about the last two, ofcourse...
16:01:59 <Pseudonym> Designed for making toolkits in X.
16:02:07 <jethr0_> supposedly Xt was a pain to program... i'm all for programmer masochism, but at gui toolkits the fun stops!
16:02:10 <Pseudonym> e.g. Athena (which is free and comes with X) and Motif (which isn't).
16:02:21 <jethr0_> lesstif is, though
16:02:21 <Pseudonym> Well, so is GTK without the convenience macros.
16:02:33 <Pseudonym> It's the same kind of ugly object model in C stuff.
16:02:39 <jethr0_> i've seen some _really_ ugly Xt code
16:02:54 <Pseudonym> I've seen some really ugly GTK code, too.
16:03:04 <goron> Pseudonym: is there also an URL for Xt?
16:03:22 <Pseudonym> It comes with X.
16:03:41 <astrolabe> @eval [1..] !! 3
16:03:43 <goron> Ok, figures.
16:03:44 <mbot> 4
16:03:54 <astrolabe> Ah
16:04:12 <goron>  @eval [1..] !! 999999999
16:04:17 <goron> @eval [1..] !! 999999999
16:04:23 <mbot> Terminated
16:04:48 <jethr0_> > take 1 . drop 999999999 $ [1..]
16:04:54 <mbot> Terminated
16:04:56 <jethr0_> hmm
16:05:30 <Pseudonym> Try "man XtClass" as an example.
16:06:58 <goron> Pseudonym: oh, now I remember. GTk/QT/whatever is build on Xt via some layers. 
16:07:17 <Pseudonym> No.
16:07:23 <Pseudonym> They bypass Xt.
16:07:24 <vincenz> Cale: ping
16:07:31 <Pseudonym> Xt is a layer like GTK, built on top of Xlib.
16:07:44 <Pseudonym> Xt is what people used before GTK.
16:07:54 <goron> Pseudonym: or maybe I meant XLib, then. 
16:07:55 <Pseudonym> When they wanted widgets in X that they didn't have to program themselves.
16:08:06 <Pseudonym> Athena was the free widget let, Motif was the non-free one.
16:08:20 <Pseudonym> A lot of people still use Motif.
16:08:21 <vincenz> jethr0_: hi ;
16:08:25 <vincenz> jethr0_: we need more people for our tema
16:08:49 <vincenz> Anyone here versed in CT and set theory?
16:09:11 <Pseudonym> vincenz: No, nobody.  You'd think someone on #haskell would be, wouldn't you?
16:09:19 <vincenz> yah
16:09:20 <vincenz> well cale is
16:09:25 <vincenz> but he's apparently not around
16:09:29 <vincenz> I have a rather "simple question
16:09:37 <vincenz> and anyone with a somewhat mathematical backgroudn should know this
16:09:40 <goron> vincenz: I think CT subsumes ST
16:09:50 <vincenz> (my background is EE, so we were mostly focussed linear transformations and such)
16:09:54 * ptolomy tries to rationalize his distaste for C++ due to it's excessive complexity and level of skill required to do things right.. a person also needs to learn a lot of haskell to write real apps..
16:10:05 <vincenz> basically I have a book here (which btw is quite good and free. I tried several other books but found them harder)
16:10:32 <jethr0_> vincenz: i agree
16:10:41 <Pseudonym> ptolomy: Just hate C++ because it was designed to be based on C.  Nobody can argue with that.
16:10:43 <astrolabe> I know some CT
16:10:46 <vincenz> let D be the category whose objects are the empty set and all sets of the form {1,2,..n} for some positive initeger n and whose arros are functions between them..... D is a representative subcategory for Fin
16:10:59 <jethr0_> vincenz: although 3 is an acceptable size already, right? at some point too many people can cause problems too
16:11:07 <vincenz> (aka there's a bijection from any nonempty finite set to a set of the form {1,2,...,n}
16:11:16 <vincenz> jethr0_: ideally 4 I'd think
16:11:19 <jethr0_> yup
16:11:30 <vincenz> jethr0_: you always need some slack for side-tasks (TODO, Readme, sidetrack thinking, etc)
16:11:32 <jethr0_> 4 really productive/smart/gallant ones like us :)
16:11:40 <vincenz> :D
16:11:52 <vincenz> could anyone show me this is true
16:12:04 <vincenz> that there's a bijection between any finite set and a set of the form {1,2,...,n}
16:12:12 <vincenz> oh ... wait
16:12:13 <vincenz> doh
16:12:17 * vincenz shoots himself in the foot
16:12:19 <vincenz> forget I asked
16:12:21 <vincenz> it's more trivial than I thought
16:12:22 <astrolabe> :)
16:12:23 <jethr0_> vincenz: isn't that trivial?
16:12:27 <vincenz> yeah
16:12:35 <Pseudonym> As an exercuse, prove that there's often MORE THAN ONE bijection!
16:12:40 <astrolabe> Go on then.  Why's it true?
16:12:41 <Pseudonym> :-)
16:12:51 <vincenz> just map each element to a unique number
16:12:52 <ptolomy> Pseudonym: Hmm. I'll go with that. Haskell makes simple things hard that C makes easy.. like segfaults.. memory leaks.. etc. Low level messups are C/C++ newbie territory.. opposite in Haskell.
16:13:02 <vincenz> I was thinking damn this will be hard if I have two sets {a,b,d} and {a,c,d}
16:13:03 <jethr0_> aren't there n! bijections?
16:13:04 <Pseudonym> ptolomy: Yup.
16:13:16 <vincenz> aka I was thinking of how to name the elements in the {1,..,n}
16:13:18 <vincenz> but that's not necessary
16:13:31 <vincenz> (multiple finite sets map to one of these objects in D)
16:13:54 <vincenz> anyways
16:13:58 <jethr0_> vincenz: aren't there n! bijections?
16:13:59 * ptolomy tries to work up some sort of construction materials analogy, but comes up waay sort.
16:14:00 <vincenz> I tried pierce's book on CT
16:14:02 <vincenz> it was complicated
16:14:06 <vincenz> then I went to lawvere
16:14:07 <vincenz> easier
16:14:26 <vincenz> (Conceptual Mathematics as well as Set for Mathematics)
16:14:30 <vincenz> however I get stuck on the proofs
16:14:36 <vincenz> now I'm looking at the lecture notes of barrswells
16:14:40 <vincenz> it's great :)
16:14:41 <Pseudonym> Laevere is a seriously nice book.
16:14:48 <vincenz> and presuppes less knowledge
16:14:53 <vincenz> Pseudonym: I find barr wells easier
16:14:58 <vincenz> after this I'll tackle the two lawvere's
16:15:02 <vincenz> then pierce
16:15:03 <vincenz> then maclane
16:15:10 <Pseudonym> You can read Conceptual Mathematics like a novel, though.
16:15:18 <vincenz> Pseudonym: not the exercises
16:15:21 <Pseudonym> True.
16:15:23 <vincenz> Pseudonym: I always get stuck on proofs
16:15:25 <vincenz> and I must say
16:15:32 <vincenz> I found the chapter on ... brouwer less obvious
16:15:53 <vincenz> but I hope that after reading barr and wells
16:15:57 <vincenz> I'll be ready for the two lawvere's
16:16:01 <vincenz> and then I can tackle pierce and then maclane
16:16:05 <vincenz> (which is wow...terse)
16:16:20 * vincenz went on a spending spree a while back, I better tackle em all
16:16:34 <Pseudonym> The world needs a book on category theory which doesn't mention topology once.
16:16:35 <vincenz> CT, philosophy and eastern martial arts ... great reading :)
16:16:50 <vincenz> Pseudonym: afaik barr wells doesn't touch topos, at least not yet
16:16:51 <Pseudonym> Barr and Wells might, now that I think of it.
16:16:55 <Pseudonym> Right.
16:16:56 <vincenz> it's not the book
16:16:59 <vincenz> it's the lecture notes
16:17:05 <Pseudonym> Sure.
16:17:06 <vincenz> which is sad cause sometimes they refer to their books for interesting details
16:17:10 <Pseudonym> I think they're very similar.
16:17:14 <vincenz> like a Monoid structure and something with computer science
16:17:25 <vincenz> let me fish it up
16:18:36 <vincenz> "Thus a category can be regarded as a generalized monoid or a 'monoid with many objects'.  This point of view has not been as fruitful in mathematics as the perception of a category as a generalized poset.  It does have some applications in computing science; see [Barr and Wells 1999], Chapter 12"
16:18:46 <vincenz> but I don't feel like buying ANOTHER book (which is also 45$"
16:18:52 <vincenz> I already have 4 plus this pdf
16:19:09 <vincenz> tho if anyone can briefly describe what he means, I'm all ears :)
16:19:13 <Pseudonym> I have a university ljibrary.
16:19:18 <Pseudonym> I don't need to buy books.
16:19:23 <vincenz> nor I
16:19:26 <vincenz> it's just a thing for me
16:19:27 <vincenz> owning books
16:19:31 <Pseudonym> Though I do have a stolen copy of Asperti and Longo.
16:19:38 <vincenz> in pdf?
16:19:41 <vincenz> I have a pdf by them
16:19:42 <Pseudonym> No, paper.
16:19:42 <vincenz> is it good?
16:19:48 <Pseudonym> It's the same as the PDF.
16:19:52 <Pseudonym> It's... uhm... hard going.
16:20:01 <Pseudonym> You don't want to learn CT using this book.
16:20:01 <jethr0_> vincenz: i've got the same thing. unless i own a "good" book, i'm just not happy :)
16:20:12 <vincenz> yeah
16:20:18 <vincenz> I also have a bunch of books on compilers
16:20:21 <vincenz> and a bunch of books on c++ stds
16:20:25 <vincenz> and a bunch of books on philosophy
16:20:30 <Pseudonym> However, the second section is great.  The bit about the Curry-Howard isomorphism, and its categorical aspects.
16:20:36 <vincenz> (and cooking but those were figts)
16:20:44 <vincenz> Pseudonym: so you recommend it as after lecture
16:20:48 <vincenz> prior or post maclane?
16:20:51 <Pseudonym> Post.
16:20:55 <vincenz> post even maclane?
16:20:57 <Pseudonym> Mac Lane is written by an algebraist.
16:21:03 <vincenz> maclane seems well... graduate CT
16:21:18 <Pseudonym> Well... it covers the basic material pretty fast.
16:21:21 <vincenz> but hey it just looks cool
16:21:24 <Pseudonym> Yeah.
16:21:27 <Pseudonym> It's a good book.
16:21:42 <Pseudonym> It'd be good to brush up on what an r-module is first, though.
16:21:45 <vincenz> so you think my collection is a nice coverage without too much internal coverage?
16:21:59 <Pseudonym> Yeah, I think so.
16:22:08 <Pseudonym> All of the books you have cover the basics in different ways.
16:22:10 <vincenz> Bruce Pierce : "CT for computer scientists" the two maclanes, barr and wells, asperti and long, and maclane
16:22:17 <vincenz> yeah personally I enjoy barr and wells the best
16:22:21 <Pseudonym> Though I haven't read Pierce.
16:22:27 <vincenz> cause it doesn't presuppose knowledge of what Pfn or Fin is
16:22:33 <vincenz> but briefly but succiintly describes them
16:22:35 <vincenz> in a clear fashion
16:22:39 <vincenz> Pierce assumed such knowledge
16:22:49 <vincenz> (it was the first I got and it got me frustrated, but it's only like 100 pageS"
16:23:05 <vincenz> mm
16:23:11 <vincenz> maybe you can help me with another problem
16:23:17 <vincenz> which ... well I couldn't even see what I had to prove
16:23:34 <vincenz> assume that some object X discriminates elements 
16:23:39 <vincenz> .. in A
16:23:45 <vincenz> prove that it discrimatinates generalized elements in A
16:24:13 <vincenz> (this might be particular to Set)
16:24:34 <Pseudonym> Woah, hang on.  What does "discriminates" mean?
16:24:36 <vincenz> a pity they don't have the answers to excercises online for these booksk
16:24:42 <vincenz> hmm
16:24:49 <Pseudonym> (The books on CT I've read recently didn't bother with that!)
16:26:20 <vincenz> whoops
16:26:21 <vincenz> here it is
16:26:25 <vincenz> it started to talk about separators
16:26:30 <vincenz> and said how separators discriminate elements
16:26:30 <vincenz> namely
16:26:59 <vincenz> a0 != a1, then phi: A -> V, phi.a0 != phi.a1
16:27:05 <vincenz> aka V discriminates elements in A
16:27:10 <Pseudonym> Right.
16:27:14 <vincenz> (err this was coseparator)
16:27:22 <vincenz> exercise:
16:28:08 <vincenz> Use the fact that 1 is a separator in the category of abstract sets to show that (in that category), if V can discriminate elements, then it can discriminate generalized elements.
16:28:28 <Pseudonym> Hang on, what's an "element"?
16:28:36 <vincenz> element:
16:28:38 <Pseudonym> I know what that is in a set.  But category objects don't have elements.
16:28:38 <vincenz> 1 -> A
16:28:42 <vincenz> it's for sets
16:28:49 <Pseudonym> Ah, right.  That's a apoint.
16:28:49 <vincenz> an element in the category of Sets
16:28:59 <vincenz> generalized element:
16:29:01 <vincenz> T -> A
16:29:02 <vincenz> for any T
16:29:07 <Pseudonym> And a generalised element is...?
16:29:50 <vincenz> the diagram should be something like this
16:29:57 <vincenz>      1
16:29:57 <vincenz>    / | \
16:29:57 <vincenz>   .  .  .
16:29:57 <vincenz> T -. A -. V
16:30:08 <vincenz> generalized element (also know as variable element)
16:30:10 <vincenz> T -> A
16:30:13 <vincenz> instead of 1 -> A
16:30:24 <vincenz> . is the > of an arrow
16:30:26 <Pseudonym> T is terminal?
16:30:28 <vincenz> but seeing that doesn't work for all diagrams
16:30:29 <vincenz> Pseudonym: no
16:30:37 <Pseudonym> No, because 1 is terminal.
16:30:44 <vincenz> well yes
16:30:47 <vincenz> that's it's called an element
16:30:51 <vincenz> and noot a generalized element
16:30:56 <ihope> I like code that's still indented properly in a proportional font.
16:31:08 <ihope> ;-)
16:32:13 <vincenz> http://rafb.net/paste/results/QXRTwC91.html
16:33:53 <vincenz> see I almost got it except for one small step
16:33:57 <vincenz> let me work it out as far as I can
16:33:59 <Pseudonym> Which is?
16:34:00 <Pseudonym> OK
16:34:02 <ihope> It's simple!
16:36:23 <vincenz> http://rafb.net/paste/results/AucyG734.html
16:37:28 <vincenz> that's where I'm stuck :/
16:37:59 <vincenz> not sure that let is legal
16:38:02 <vincenz> and it's not the result I want
16:39:55 <Pseudonym> Let me think here.
16:40:08 <Pseudonym> If ta0 != ta1, then there is an element t that separates them.
16:41:00 <SamB> Zarf has weird ideas... (see rec.arts.int-fiction, the thread about an alternate Glk entrypoint)
16:41:39 <Pseudonym> That's the intention of t in your diagram, right?
16:42:15 <Pseudonym> t : 1 -> V is a morphism such that ta0 . t != ta1 . t
16:43:37 <vincenz> yep
16:43:37 <Pseudonym> Now if ta0 . t != ta1 . t, then phi . ta0 . t != phi . ta1 . t
16:43:41 <vincenz> yes
16:43:45 <vincenz> but can we use the "there exists"
16:43:47 <vincenz> and be done with it
16:43:51 <vincenz> just pick that one?/
16:44:07 <vincenz> I'm trying to get rid of  the "there exists" qualifier
16:44:19 <vincenz> (coming from the contrapositive of the separator rule)
16:44:36 <SamB> Cale is the one who likes IF, right?
16:44:55 <vincenz> I mean for other x's ta0.x might equal ta1.x
16:45:20 <Pseudonym> Hang on a moment.
16:47:00 <Pseudonym> Why can't you get rid of the "there exists" by simply saying: There exists a separator, therefore these two arrows are not equal.
16:47:05 <Pseudonym> ?
16:47:09 <vincenz> I don't know
16:47:44 <Pseudonym> I think it's this simple:
16:47:44 <vincenz> heh someone just cleared it a bit
16:47:48 <vincenz> phi is injective
16:47:52 <Pseudonym> Suppose that ta0 != ta1
16:48:03 * vincenz nods
16:48:05 <Pseudonym> Then there exists a t : 1 -> T such that ta0 . t != ta1 . t
16:48:10 <vincenz> yep
16:48:16 <vincenz> so far I got
16:48:18 <vincenz> :)
16:48:27 <Pseudonym> So phi . ta0 . t != phi . ta1 . t
16:48:32 <vincenz> but only for that t
16:48:38 <vincenz> that's where I get stuck on
16:48:39 <Pseudonym> No, hang on.
16:48:41 <vincenz> ok
16:48:47 <Pseudonym> There exists a t such that phi . ta0 . t != phi . ta1 . t
16:48:50 <vincenz> ye
16:48:50 <vincenz> p
16:48:59 <Pseudonym> i.e. there exists a separator for phi . ta0 and phi . ta1
16:49:10 <Pseudonym> Therefore phi . ta1 != phi . ta1
16:49:24 <Pseudonym> Therefore phi . ta0 != phi . ta1
16:49:43 <Pseudonym> Conversely, if phi . ta0 = phi . ta1, then phi . ta0 . x = phi . ta1 . x for all x.
16:49:53 <Pseudonym> Make sense?
16:50:03 <vincenz> hmm
16:50:14 <vincenz> oh yea
16:50:25 <vincenz> they can only be equal if there is no separator separating em
16:50:30 <Pseudonym> Right.
16:50:33 <vincenz> cool :)
16:50:40 <vincenz> thx
16:50:45 <Pseudonym> The argument partly works in a category without enough points, too.
16:50:46 <vincenz> t being the separator
16:51:06 <Pseudonym> The only place you need that property is to prove that if ta0 != ta1, then they have a separator.
16:51:33 <vincenz> that's where the "there exists" is "consumed"
16:51:43 <Pseudonym> Yes.
16:51:54 <vincenz> cool, thanks :)
16:51:58 <Pseudonym> No proble,.
16:52:05 <Pseudonym> Category theory is difficult in plain text.
16:53:01 <vincenz> i should've thought more about what it means to be equal as functions
16:53:11 <vincenz> anyways, that was maclane
16:53:16 <vincenz> barr and wells reads more easily
16:53:21 <SamB> oh, for {\TeX}nIRC
16:54:28 <vincenz> SamB: you want latex-irc?
16:54:32 <vincenz> woah
16:54:39 <vincenz> that would be a cool cairo app
16:54:41 <vincenz> not full latex
16:54:45 <vincenz> but an irc client with drawings
16:54:55 <vincenz> (full latex is far too heavy to render realtime)
16:56:04 * DukeDave agrees
16:56:22 <jethr0_> one-line formulas would sure be nice though
16:56:32 <DukeDave> would be nice even if it could reformat as ascii art and spit that out
16:56:50 <DukeDave>    2
16:56:52 <DukeDave>  x
16:56:57 <DukeDave> ----
16:56:58 <DukeDave>    4
16:57:00 <DukeDave>  :)
16:57:11 <jethr0_> "\sigma_n=1^\infinity \left \frac{1}{1} \right" or so
16:57:35 <DukeDave> lets see
16:57:49 <jethr0_> DukeDave: even with simple fractions that would lead to evil spam
16:57:54 <vincenz> yeah
16:57:59 <vincenz> but using cairo it would be great
16:58:03 <vincenz> if you limit "line" height
16:58:17 <vincenz> and maybe have a separate window
16:58:18 <jethr0_> yup, you could just scale and make it unreadable
16:58:23 <vincenz> for one drawing that mutates as people edit it
16:58:28 <vincenz> kind of like gobby but for diagrams
16:58:43 <vincenz> jethr0_: or clip it unless you doubleclick
16:58:51 <vincenz> or scale it until you double click :)
16:58:54 <jethr0_> using the technique w3m is using, this would even be possible under console. using images/ps
16:59:14 <vincenz> images/ps?
16:59:19 <SamB> console?
16:59:23 <jethr0_> not using cairo
16:59:27 <SamB> I thought it only worked for xterm!
16:59:29 <vincenz> cairo-curses?
16:59:33 <jethr0_> don't you people know the w3m that displays images on console?
16:59:36 <vincenz> nope
16:59:54 <SamB> (and other terminal emulators)
16:59:59 <texbot> oxo
17:00:00 <jethr0_> SamB: you think so? i was pretty sure it even worked on the "standard" non-X consoles
17:00:03 <SamB> the key being that they run in X
17:00:03 <texbot> ___   /   \
17:00:07 <texbot> \    | _1_ |
17:00:18 <texbot> n=1   \   /
17:00:25 <texbot> ahh crap, missed a line :)
17:00:31 <SamB> how else is it going to blit into the terminal window?
17:01:03 <jethr0_> SamB: yup, you seem to be right
17:01:44 <jethr0_> sigma is missing two lines
17:01:44 <SamB> It must somehow find the window ID of the terminal it runs in...
17:01:54 <jethr0_> SamB: sounds pretty evil
17:03:00 <jethr0_> works under linux framebuffer too, though
17:03:12 <SamB> the FB code is probably nicer
17:03:45 <vincenz> anyways
17:03:50 <vincenz> cairo-irc
17:03:57 <vincenz> say \o/ if you like it
17:04:07 <vincenz> (aka let me have a count of hands :P)
17:04:17 <SamB> two hands per capita?
17:04:20 <vincenz> yes
17:04:22 <Pseudonym> \o_
17:04:22 <vincenz> I count modulo2
17:04:24 <Pseudonym> Single hand from me.
17:04:28 <vincenz> that's 0 so far
17:04:32 <vincenz> err not modulo two
17:04:33 <vincenz> div two
17:04:36 <sili> ff
17:04:53 <vincenz> ooh... div is not a homomorphism for (Z,+)
17:05:00 <SamB> heh
17:05:14 <vincenz> 1 `div` 2 + 1 `div` 2 != (1+1) `div` 2
17:05:41 <SamB> how about "sub"
17:05:49 <vincenz> ( (  )  (  |  )  (  ) )    -- shake that booty!
17:05:50 <SamB> which would be passed hands and heads
17:05:56 <jethr0_> \o-
17:06:01 <SamB> in some order
17:06:15 <vincenz> SamB: nope
17:06:16 * SamB takes dog for much-needed walk
17:06:26 <vincenz> (2 - 1) `div` 2 == 0
17:06:39 <vincenz> 2 `div` 2 - 1 `div` 2 == 1
17:06:39 <SamB> vincenz: not like that...
17:06:44 * jethr0_ has got an arm sticking out of his head
17:06:52 <vincenz> \o.
17:06:57 <vincenz> _/\
17:07:01 <dons> moin
17:07:06 <jethr0_> moin moin
17:07:06 <vincenz> moinmoin
17:07:13 <vincenz> damn
17:07:19 <vincenz> gtk-gnutella has a file called
17:07:21 <vincenz> "spore.iso"
17:07:23 <jethr0_> frist post
17:07:26 * vincenz drools at the possibilities
17:08:34 <vincenz> dons: would you like a cairo-irc?
17:08:38 <vincenz> where you can have diagrams?
17:08:59 <jethr0_> i liked the idea of a haskell gnuplot-like thingey. did whoever proposed that persue it?
17:09:49 <jethr0_> would be great to link that with irssi or other existing clients and "just" add the diagram/formula-parsing capability though
17:10:02 <vincenz> yeah
17:10:07 <vincenz> tho it'd be unreadable for regular ircers
17:10:17 <vincenz> unless you used ctcp to chan
17:10:21 <jethr0_> like, parsing the input and substituting @latex with latex output (after safety checks)
17:10:23 <vincenz> and people on irc would ignore ctcps
17:10:36 <vincenz> jethr0_: nah, latex is too heavy weight for realtime
17:10:39 <vincenz> you need a subset
17:10:50 <vincenz> and has too much unneeded crud
17:10:56 <jethr0_> yes, but even then, the occasional latex line wouldn't be unbearable. but i guess msgs/ctcp might be better
17:11:01 <dons> hmm. a latex-irc would be nice. i worked with a student who was writing a math-irc, but it didn't get off the ground.
17:11:12 <vincenz> jethr0_: I once had a wiki with latex preprocessor (moin moin)
17:11:14 <jethr0_> vincenz: i didn't mean full latex. just symbols, really
17:11:15 <vincenz> it was FRICKING slow
17:11:23 <jethr0_> a _tiny_ spacing subset
17:11:33 <vincenz> at which point you could just define your own subset
17:11:37 <vincenz> instead of hacking with latex
17:11:47 <vincenz> or just use a dsl in haskell :D
17:11:55 <dons> but frankly, I'm happy if we have @eval and @type :)
17:11:56 <vincenz> @diagram blabla >>> ....
17:12:00 <mbot> Unknown command, try @listcommands.
17:12:05 <jethr0_> hmm, but keeping it compatible with latex (plus defined macros) would be a good idea. then many people could join without learning some new language
17:12:06 <vincenz> and your diagram would eval the code with hs-plugins
17:12:28 <vincenz> jethr0_: haskell ain't a new lang
17:12:45 <vincenz> just make an nice diagram dsl
17:12:46 <vincenz> :D
17:12:48 <jethr0_> but haskell isn't necessarily the best language to express complex formulae
17:12:59 <vincenz> sure it is
17:13:03 <jethr0_> hmm
17:13:04 <vincenz>  and you'd add a lyx-like frontend
17:13:14 <DukeDave> ... incoming class/nomad question...
17:13:22 <vincenz> DukeDave: nomads live in classes
17:13:26 <vincenz> also known as "tribes"
17:13:29 <DukeDave> > instance Monad Block where
17:13:32 <vincenz> monads on the other hand
17:13:32 <mbot>  parse error on input `instance'
17:13:33 <DukeDave> >   KW kwtype content >>= _       = KW kwtype content
17:13:36 <mbot>  parse error on input `='
17:13:39 <DukeDave> >   NK content        >>= parser  = parser content
17:13:39 <jethr0_> even worse, i'd really prefer textual input. latex input is quite nice with a few abbreviation macros and after getting used to it
17:13:42 <mbot>  parse error on input `='
17:13:47 <DukeDave> erk, forgot about the bot
17:13:56 <vincenz> DukeDave: seems like an Either
17:14:02 <DukeDave> that's my instance def of 'Block'
17:14:08 <vincenz> jethr0_: just make your dsl easy to use
17:14:09 <jethr0_> someone in my freshman year typed a latex version of our algebra lecture, which was _really_ fast (for us freshers).
17:14:15 <DukeDave> throwing ERROR "parse2.lhs":5 - Illegal type in class constraint
17:14:32 <vincenz> jethr0_: define fast?
17:14:35 <vincenz> and I didn't know latex was typed
17:15:08 <DukeDave> vincenz, how do you mean 'Either' ?
17:15:32 <vincenz> Either (kwtype, content) content
17:16:04 <vincenz> and Either is already a monad
17:16:17 <jethr0_> vincenz: how would you express "\forall A \exists b \in a a \vee b = a"?
17:16:27 <jethr0_> come to think of it, that's not so hard
17:16:53 <DukeDave> I think I see what you mean
17:17:17 <DukeDave> mine is of form    > data Block = KW String String | NK String
17:17:28 <vincenz> jethr0_: easy
17:17:36 <jethr0_> vincenz: fast is hard to describe. but i still can't imagine writing latex versions of matrices, ... in realtime. the course was _very_ rushed for beginners.
17:17:57 <jethr0_> vincenz: i know it is (with good abbrev. macros), but the result is stunning for doing it in realtime
17:18:05 <vincenz> well yeah
17:18:08 <vincenz> haskell DSL :)
17:18:49 <DukeDave> seriously - what the hell is ERROR "parse2.lhs":4 - Illegal type in class constraint
17:18:54 <DukeDave> :(
17:19:09 <vincenz> forall "A" $ or (exists "b" "a" "A") (equal "b" "a")
17:19:43 <mauke> DukeDave: what is line 4?
17:19:44 <cpatrick> having to type variables as string like that would be a pain
17:19:44 <jethr0_> this is from the non-algebra lecture: http://sengernet.de/files/hm1.ps
17:19:50 <cpatrick> otherwise that looks quite pretty
17:20:02 <vincenz> cpatrick: good point
17:20:14 <vincenz> cpatrick: then add a lexer
17:20:21 <vincenz> and make all non \... be ""
17:20:47 <vincenz> but then it's no longer a pure haskell dsl
17:20:51 <lisppaste2> DukeDave pasted "ERROR "parse2.lhs":4 - Illegal type in class constraint" at http://paste.lisp.org/display/17693
17:21:28 <DukeDave> for 8 lines of code - I absolutely cannot see what's wrong :)
17:21:34 <vincenz> cpatrick: Block is not of kind ( * -> *)
17:21:36 <vincenz> err
17:21:42 <vincenz> DukeDave: Block is not of kind ( * -> *)
17:21:43 <vincenz> to be a monad
17:21:49 <vincenz> it must have at least one free variables
17:21:52 <vincenz> Data Block a = ...
17:21:57 <vincenz> data Block a = ...
17:22:14 <DukeDave> ahh
17:22:18 <jethr0_> vincenz: i'm still not sure full-latex (or maybe a subset someone has already written) would be too slow. i'm gonna test that right now :)
17:22:34 <vincenz> jethr0_: the problem is defining a subset that's complete
17:22:42 <jethr0_> complete?
17:22:50 <vincenz> aka you can combine anything with anything
17:22:53 <vincenz> witout getting into trouble
17:22:55 <vincenz> without overrestricting
17:22:55 <DukeDave> > data Block content = KW String content | NK content
17:22:56 <lambdabot>  parse error on input `data'
17:23:00 <jethr0_> as i said, for me a few symbols and naive spacing would pretty much suffice
17:23:01 <vincenz> DukeDave: yep
17:23:01 <mbot>  parse error on input `data'
17:23:14 <vincenz> jethr0_: and I argue that for that case it might just be easier to define a DSL
17:23:15 <vincenz> :D
17:23:21 <vincenz> either way
17:23:24 <jethr0_> not so sure
17:23:25 <vincenz> first you need the struts
17:23:37 <vincenz> meaning an IRC client in a gui
17:23:40 <jethr0_> struts was before my time
17:23:43 <mauke> > "> ?"
17:23:44 <lambdabot> "> ?"
17:23:46 <mbot> "> ?"
17:23:50 <vincenz> LOL
17:23:56 <vincenz> @ha
17:23:56 <lambdabot> Maybe you meant: . faq ghc id lam map pl what wn
17:23:59 <mbot> Maybe you meant: ghc pl what wn
17:24:02 <vincenz> @help help
17:24:02 <lambdabot>  @help <command> - ask for help for <command>
17:24:04 <mbot>  @help <command> - ask for help for <command>
17:24:10 <vincenz> damn, they have an extra space
17:24:12 <vincenz> or they'd recusre
17:24:30 <DukeDave> jesus, getting  ERROR "parse2.lhs":8 - Illegal type "[KWDef] -> Block" in constructor application
17:24:31 <vincenz> @state @state x
17:24:31 <lambdabot> 5ta7E/\/\3N+!
17:24:34 <vincenz> @state @state x
17:24:35 <mbot> Unknown command, try @listcommands.
17:24:35 <lambdabot>  @state x
17:24:38 <mbot> Unknown command, try @listcommands.
17:24:40 <DukeDave> another one I've never heard of :(
17:25:18 <vincenz> DukeDave: paste?
17:26:15 <DukeDave> am just writing the def for the signature so you can see it in context...
17:26:17 <DukeDave> :)
17:26:25 <vincenz> jethr0_: get on #meta-science
17:26:34 <lambdabot>  @help <command> - ask for help for <command>
17:26:57 <lambdabot>  @help @help
17:27:03 <Pseudonym> Hmmm.
17:28:14 <lambdabot>  @eval let q s= s++show s in q "@eval let q s=s++show s in q "
17:28:20 <vincenz> meta-science conversations going on in #meta-science
17:28:35 <lambdabot> > let q s= s++show s in q "> let q s=s++show s in q "
17:28:39 <mbot> "> let q s=s++show s in q \"> let q s=s++show s in q \""
17:28:46 <Pseudonym> Almost!
17:28:47 <mauke> do I have someone on ignore?
17:28:53 <vincenz> Pseudonym: showString
17:29:03 <palomer> it sucks being on break
17:29:06 <palomer> nothing to do...
17:29:10 <vincenz> > let q s= s++showString s in q "> let q s=s++showString s in q"
17:29:10 <lambdabot> Couldn't match `[a]' against `t -> t1'
17:29:15 <mbot> Couldn't match `[a]' against `t -> t1'
17:29:30 <lisppaste2> DukeDave annotated #17693 with "ERROR "parse2.lhs":8 - Illegal type "KWDef -> Block" in constructor application" at http://paste.lisp.org/display/17693#1
17:29:36 <DukeDave> go team!
17:29:40 <vincenz> > let q s= s++showString s "" in q "> let q s=s++showString s in q \"\""
17:29:41 <lambdabot> "> let q s=s++showString s in q \"\"> let q s=s++showString s in q \"\""
17:29:43 <mbot> "> let q s=s++showString s in q \"\"> let q s=s++showString s in q \"\""
17:29:43 <DukeDave> first one back gets a cookie :)
17:30:07 <vincenz> oh!
17:30:10 <Pseudonym> @type showString
17:30:11 <lambdabot> String -> ShowS
17:30:13 <mbot> String -> ShowS
17:30:39 <vincenz> > let q s= showString s "" ++ s in q "> let q s=showString s "" ++ s in q "
17:30:39 <lambdabot> Couldn't match `[Char]' against `t -> t1'
17:30:41 <mbot> Couldn't match `[Char]' against `t -> t1'
17:31:15 <Pseudonym> (\x -> showString x "" == show x) 1
17:31:20 <Pseudonym> > (\x -> showString x "" == show x) 1
17:31:21 <lambdabot>  add an instance declaration for (Num String)
17:31:23 <jethr0_> writing quines?
17:31:23 <mbot>  add an instance declaration for (Num String)
17:31:23 <vincenz> > let q s= showString s "" ++ show s in q "> let q s = showString s "" ++ s in q "
17:31:24 <lambdabot> Couldn't match `[Char]' against `t -> t1'
17:31:26 <Pseudonym> > (\x -> showString x "" == show x) "hello"
17:31:27 <lambdabot> False
17:31:28 <mbot> Couldn't match `[Char]' against `t -> t1'
17:31:31 <mbot> False
17:31:34 <mauke> DukeDave: shouldn't that be -> Block String?
17:31:36 <Pseudonym> > showString "hello" ""
17:31:37 <lambdabot> "hello"
17:31:41 <palomer> ooh, someone whrite a quine
17:31:41 <mbot> "hello"
17:31:41 <palomer> go!
17:31:41 <vincenz> doh
17:31:45 <vincenz> you'll never get rid of the ""
17:31:47 <palomer> s/whrite/write
17:31:57 <jethr0_> i thought "writhe" :)
17:31:59 <vincenz> that's inherent in lambdabot
17:32:01 <DukeDave> hehe, yup mauke, just got it ;)
17:32:03 <DukeDave> cheers though
17:32:17 <jethr0_> DukeDave: how did your markup thingey go?
17:32:17 <Pseudonym> @msg #haskell "Hello world"
17:32:18 <lambdabot> "Hello world"
17:32:20 <mbot> Not enough privileges
17:32:23 <Pseudonym> Hmmm.
17:32:34 <mauke> you can't use instance declarations in >, right?
17:32:39 <DukeDave> jethr0_, working on next rewrite
17:32:40 <vincenz> @msg #haskell @msg #haskell
17:32:40 <lambdabot> Not enough privileges
17:32:43 <mbot> Not enough privileges
17:32:46 * palomer is still waiting for his quine!
17:32:58 <vincenz> won't work
17:32:59 <palomer> first quine gets a cookie
17:32:59 <DukeDave> my lecturer said: you can use parsec, but I'll only mark you for your code
17:32:59 <Pseudonym> @msg #haskell > let q x=x++show x in q "@msg #haskell > let q x=x++show x in q "
17:33:00 <lambdabot> > let q x=x++show x in q "@msg #haskell > let q x=x++show x in q "
17:33:04 <mbot> Not enough privileges
17:33:04 <mbot> "@msg #haskell > let q x=x++show x in q \"@msg #haskell > let q x=x++show x in q \""
17:33:05 <lisppaste2> jethr0 pasted "more markup" at http://paste.lisp.org/display/17694
17:33:06 <DukeDave> (which will clearly be minimal)
17:33:07 <dons> mbot, /part #haskell
17:33:07 <DukeDave> ;)
17:33:18 <dons> mbot @part #haskell
17:33:20 <vincenz> jethr0_: what is this?
17:33:25 <vincenz> mbot: DIE!
17:33:31 <jethr0_> what is what?
17:33:46 <vincenz> jethr0_: and that won't work
17:33:57 <vincenz> choice will force entering that option
17:33:58 <DukeDave> jethr0_, looks yummy to me :)
17:34:00 <vincenz> invalidating <|
17:34:03 <vincenz> you need a rwapper
17:34:09 <vincenz> wrapper
17:34:10 <vincenz> afaik
17:34:13 <SamB> dons: isn't "mbot: @part haskell" supposed to work?
17:34:15 <Pseudonym> I was actually trying to get lambdabot and mbot into a loop.
17:34:22 <vincenz> Pseudonym: you evil evil evil person
17:34:24 <jethr0_> vincenz: it _does_ work just fine
17:34:29 <vincenz> o
17:34:30 <vincenz> h
17:34:32 <Pseudonym> I don't think it can be done.
17:34:32 <vincenz> sowwy
17:34:53 <jethr0_> "try" is first class and can be combined with "choice" just fine
17:35:11 <ihope> @msg #haskell "Bleh"
17:35:12 <lambdabot> Not enough privileges
17:35:15 <mbot> Not enough privileges
17:35:21 <vincenz> jethr0_: nope
17:35:23 <vincenz> jethr0_: I just tried
17:35:26 <vincenz> let alet = ...
17:35:31 <jethr0_> you sure?
17:35:36 <vincenz> alet will match let
17:35:38 <vincenz> after takign one char
17:35:44 <ihope> lambdabot: @bot
17:35:45 <lambdabot> :)
17:35:46 <vincenz> you need to tokenize on spaces or such
17:35:51 <ihope> lambdabot: >3+2
17:35:53 <ihope> lambdabot: > 3+2
17:35:54 <lambdabot> 5
17:36:02 <jethr0_> vincenz: i don't get your example
17:36:09 <ihope> lambdabot: 3+2
17:36:09 <vincenz> jethr0_: for the parser you made
17:36:11 <vincenz> use the code
17:36:14 <vincenz> let alet = 1 in alet
17:36:15 <lisppaste2> DukeDave annotated #17693 with "ERROR "parse2.lhs":5 - Inferred type is not general enough" at http://paste.lisp.org/display/17693#2
17:36:18 <vincenz> it'll color the let part in alet
17:36:23 <DukeDave> there are getting weirder
17:36:33 <jethr0_> vincenz: yes, i know, that's a known problem
17:36:35 <vincenz> ihope: cause it'll do anychar
17:36:38 <vincenz> and then reparse again
17:36:39 <vincenz> tokenize on spaces
17:36:44 <jethr0_> i had the patterns with leading and trailing whitespace before
17:36:52 <jethr0_> but that didn't take care of line start and ends
17:37:08 <jethr0_> vincenz: that has nothing to do with choice and "try" though
17:37:12 <vincenz> true
17:37:16 <vincenz> it's a separate issue
17:37:19 <DukeDave> also, in good news, my lecturer said he'll only test on 'nice' code.. eg. x -> y    not  x->y   or such
17:37:22 <vincenz> I just like being critical, I'm a prick in that way
17:37:27 <jethr0_> i know, tokenization would be nicer, but i just wanted to whip up a _small_ example for dukedave
17:37:30 <vincenz> (constructive  cricism tho)
17:37:35 * DukeDave thanks
17:37:47 <mauke> DukeDave: your function doesn't have the right type for >>=
17:37:51 <ihope> x:: a->b -- bad! very, very, very bad
17:37:58 <jethr0_> vincenz: i'm the same way. but even though i am it can sometimes annoy those criticized :)
17:38:29 <vincenz> soww
17:38:38 <vincenz> ....y
17:38:39 <ihope> > length "s=\x y->putStr$case[show z|z<-[x..y],p x]of[]->"N";z->unlines z"
17:38:40 <lambdabot>  lexical error in string/character literal
17:38:40 <mbot>  lexical error in string/character literal
17:38:40 <DukeDave> I basically want to say - any KW bind anything is just the first KW
17:38:47 <Pseudonym> @remember unique-key Foo
17:38:50 <ihope> lambdabot: > length "s=\\x y->putStr$case[show z|z<-[x..y],p x]of[]->"N";z->unlines z"
17:38:50 <lambdabot>  Not in scope: data constructor `N'
17:38:54 <jethr0_> DukeDave: in that case you could just apply "word" to the input and map an markup function on the resulting list
17:38:56 <mauke> DukeDave: you can't do that
17:38:57 <ihope> lambdabot: > length "s=\\x y->putStr$case[show z|z<-[x..y],p x]of[]->\"N\";z->unlines z"
17:38:58 <lambdabot> 63
17:39:08 <Pseudonym> @quote unique-key
17:39:09 <mbot>  Foo
17:39:09 <lambdabot>  Foo
17:39:16 <mauke> DukeDave: >>= has the type m a -> (a -> m b) -> m b
17:39:20 <ihope> @quote eh?
17:39:21 <mbot> eh? hasn't said anything memorable
17:39:21 <lambdabot> eh? hasn't said anything memorable
17:39:25 <Pseudonym> Hmmm.
17:39:26 <mauke> DukeDave: but your definition returns m a
17:39:28 <ihope> @quote dons
17:39:28 <mbot> dons hasn't said anything memorable
17:39:28 <lambdabot>  note to self: grep only works on disks
17:39:32 <ihope> @quote
17:39:33 <mbot>  says:
17:39:33 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should
17:39:33 <lambdabot> have the good sense not too go near the barbed wire fences and armed
17:39:33 <lambdabot> guards.
17:39:34 <DukeDave> damnit, I had it working on another program though!
17:39:38 <Pseudonym> @quote unique-key2 @quote unqiue-key2
17:39:38 <mbot> unique-key2 @quote unqiue-key2 hasn't said anything memorable
17:39:38 <lambdabot> unique-key2 @quote unqiue-key2 hasn't said anything memorable
17:39:40 <DukeDave> exactly that operation
17:39:45 <jethr0_> > let markup "ab" = "<ab>"; markup "de" "<de>" in unwords . map markup . words $ "dd ab cd ef de ab"
17:39:45 <lambdabot>  parse error on input `in'
17:39:46 <mbot>  parse error on input `in'
17:39:47 <Pseudonym> @remember unique-key2 @quote unqiue-key2
17:39:52 <Pseudonym> @quote unique-key2
17:39:52 <mbot>  @quote unqiue-key2
17:39:52 <lambdabot>  @quote unqiue-key2
17:39:57 <jethr0_> > let markup "ab" = "<ab>"; markup "de" = "<de>" in unwords . map markup . words $ "dd ab cd ef de ab"
17:39:57 <ihope> >:-)
17:39:57 <Pseudonym> Damn that space!
17:39:58 <lambdabot>  Non-exhaustive patterns in function markup
17:39:58 <mbot>  Non-exhaustive patterns in function markup
17:40:04 <jethr0_> *grrrrr*
17:40:07 <jethr0_> spam spam spam
17:40:15 <jethr0_> > let markup "ab" = "<ab>"; markup "de" = "<de>"; markup x = x in unwords . map markup . words $ "dd ab cd ef de ab"
17:40:16 <lambdabot> "dd <ab> cd ef <de> <ab>"
17:40:16 <vincenz> mbot: @leave #haskell
17:40:17 <mbot> "dd <ab> cd ef <de> <ab>"
17:40:17 <mbot> Not enough privileges
17:40:26 <ihope> Pseudonym: you could've exploited the (error . error) bug...
17:40:39 <vincenz> @type unwords
17:40:39 <lambdabot> [String] -> String
17:40:40 <mbot> [String] -> String
17:41:03 <Pseudonym> @quote unique-key3
17:41:04 <mbot>  lambdabot: @quote unqiue-key3
17:41:04 <lambdabot>  mbot: @quote unqiue-key3
17:41:15 <jethr0_> although unwords would destroy non-single-space whitespace
17:41:18 <ihope> > error . error $ (\x -> x ++ show x) "> error . error $ (\x -> x ++ show x) "
17:41:18 <lambdabot>  lexical error in string/character literal
17:41:18 <mbot>  lexical error in string/character literal
17:41:24 <ihope> Eh.
17:41:28 <ihope> > error . error $ (\x -> x ++ show x) "> error . error $ (\\x -> x ++ show x) "
17:41:28 <lambdabot> Add a type signature
17:41:28 <mbot> Add a type signature
17:41:30 <vincenz> can someone remove mbot?
17:41:35 <vincenz> he's freakishly annoying
17:41:44 <ihope> Anyway, that's the way to have done it.
17:41:44 <DukeDave> I'm so confused :)
17:41:48 <jethr0_> there's a spam echo in here
17:41:51 <DukeDave> this made sense in my ead on the way home :(
17:42:02 <jethr0_> DukeDave: what did?
17:42:09 <vincenz> DukeDave: I think I know why
17:42:16 <vincenz> DukeDave: the first definition on line 4
17:42:21 <vincenz> is of type -> Block a
17:42:31 <vincenz> I think
17:43:02 <vincenz> it's not generic enuogh
17:43:04 <vincenz> you need a generic fail
17:43:09 <DukeDave> ERROR "parse2.lhs":4 - Syntax error in instance head (constructor expected)
17:43:13 <DukeDave> :(
17:43:14 <vincenz> let me try this
17:43:46 <DukeDave> I'm starting to wish this wasn't due in tomorrow :)
17:44:14 * DukeDave thought "haskell is a nice language, I'll be fine writing the final versino in one sitting'
17:44:28 <vincenz> DukeDave: I think the problem is that it's not a monad
17:44:49 <vincenz> there's no "fail"
17:44:53 <Philippa> ah, thank fuck I'm not a fresher any more
17:44:57 <mauke> there's a predefined fail
17:45:03 <vincenz> not for this monad
17:45:04 <mauke> just like >>
17:45:08 <mauke> what?
17:45:15 <vincenz> he already uses two possible cases
17:45:19 <vincenz> neither of them representing fail
17:45:21 <Philippa> if there's nothing provided, fail is error
17:45:33 <vincenz> right but can you have >>= for two different data constructors?
17:45:39 <mauke> vincenz: you're not making sense
17:45:58 <vincenz> typically you have two option in a monad
17:46:00 <vincenz> your data
17:46:01 <vincenz> or fail
17:46:06 <vincenz> not data con 1, data con 2, fail
17:46:20 <DukeDave> my nice idea was that I could firstly words the line...  then for each word make it a NK.. then we pass the NKs threw a 'scanner' function, which returns either NK or KW...
17:46:22 <Philippa> that's a little misleading
17:46:41 <Philippa> I've implemented monads that had many constructors, all in one nice big GADT
17:46:49 <vincenz> the first >>= definition is nont of type Monad a -> Monad b
17:46:52 <vincenz> it makes a = b
17:47:09 <vincenz>     Couldn't match the rigid variable `b' against the rigid variable `a'
17:47:10 <vincenz>       `b' is bound by the type signature for `>>='
17:47:10 <vincenz>       `a' is bound by the type signature for `>>='
17:47:10 <vincenz>       Expected type: b
17:47:10 <vincenz>       Inferred type: a
17:47:12 <vincenz>     In the second argument of `KW', namely `content'
17:47:14 <vincenz>     In the definition of `>>=': >>= KW kwtype content _ = KW kwtype content
17:47:19 <mauke> yes, that's what I said
17:47:32 <DukeDave> so if we had second list of keywords, we could pass our blocks threw another scanner, but only NKs would actually be dealt with,  so in a sense KWs are the 'errors'
17:47:50 <vincenz> DukeDave: how do you even plan to make it pass KW from your code
17:47:51 <Philippa> DukeDave: I think you need some parens in the pattern defining >>= there
17:47:56 <vincenz> there's no monadic construct to chose one of the constructors
17:47:59 <vincenz> that's hidden in the monad
17:48:16 <vincenz> you can't do return $ KW ...
17:48:22 <vincenz> that would be a Block Block a
17:48:42 <mauke> the error can't depend on the type
17:48:53 <SamB> What do people think of http://groups.google.com/group/rec.arts.int-fiction/browse_frm/thread/08732d67369ee93e ?
17:49:17 <DukeDave> I'm trying to 'emulate' this example http://www.nomaware.com/monads/html/analogy.html
17:49:38 <Philippa> your types don't match, you want something more specific than a monad
17:49:55 <Philippa> in particular, something that's not polymorphic. In fact, I suspect you want a monoid
17:50:08 <mauke> DukeDave: in that example, Empty doesn't depend on x
17:50:55 <jethr0_> SamB: are you sure "rec.arts.int-fiction" is the right group :)
17:51:27 <Philippa> I suspect they're discussing the implementation of IF and/or IF engines, so yeah
17:52:01 <jethr0_> SamB: clearly the answer to your post was much more "popular"
17:52:13 <jethr0_> ah
17:52:19 <DukeDave> is this not possible then?  :(
17:52:38 <Philippa> DukeDave: not with a monad, no
17:52:45 <DukeDave> oh dear
17:52:46 <Philippa> you can build the structure you want, just stop calling it a monad
17:52:59 <DukeDave> heh
17:53:00 <DukeDave> okay,
17:53:18 <Philippa> although, what's your return?
17:53:33 <DukeDave> return = NK
17:54:03 <Philippa> so 'content' is effectively fixed throughout?
17:54:10 <ihope> > "español"
17:54:10 <DukeDave> yes
17:54:10 <lambdabot> "espa\195\177ol"
17:54:14 <mbot> "espa\195\177ol"
17:54:18 <Philippa> monads Don't Do That :-)
17:54:23 <ihope> Hey! It's not supposed to do that!
17:54:23 <DukeDave> heh
17:54:32 <DukeDave> clearly I'm getting ahead of myself
17:54:32 <ihope> > "ññ"
17:54:33 <lambdabot> "\195\177\195\177"
17:54:37 <mbot> "\195\177\195\177"
17:54:56 <Philippa> 'sok, it's an understandable mistake. You just picked a close relative of the design pattern you wanted instead of the actual one
17:55:28 <Philippa> there's another class called Monoid (oh, and you need to pick out an 'identity' parser that just does nothing, but hey, no biggie, right?)
17:56:18 <Philippa> Monoids don't have return but that's OK because you can just add one anyway. They /do/ have a 'sequence-like thing' whose type very nearly matches the type of your >>=
17:56:32 <dons> mbot: @part haskell
17:56:41 <dons> mbot, @part haskell
17:56:44 <dons> hmm
17:56:50 <dons> mbot, @bot
17:56:56 <mbot> dons: Null
17:57:03 <Philippa> actually no, it's a bit further apart. Still. Just build it and ignore the typeclass :-)
17:57:08 <mauke> mbot: @leave #haskell
17:57:09 <mbot> Not enough privileges
17:57:14 <dons> mbot, @part #haskell
17:57:22 <dons> ah :)
17:57:27 <dons> thank you for your service mbot
17:57:28 <DukeDave> Philippa, you may just have saved my grade :)
17:57:46 <dons> and yay, my wireless is way zippy now the antenna is in the roof :D
17:57:50 <Philippa> it'd be nice to be able to build 'constrained monads' sometimes. An MPTC with one of the parms defaulting to a type variable'd do the trick
17:58:53 <lisppaste2> DukeDave pasted "I never liked monads anyway" at http://paste.lisp.org/display/17695
17:59:25 <jethr0_> DukeDave: that title borders on blasphemy in here ^^
18:00:20 <jethr0_> come to think of it, that title _is_ blasphemy in here!
18:01:01 <Philippa> hey, if the guy wants a monadectomy that's his choice
18:01:16 <DukeDave> lol
18:03:25 <dons> @remember Philippa hey, if the guy wants a monadectomy that's his choice
18:03:44 <jethr0_> has remember superseded quote?
18:03:47 <dons> sigh, fast internet is just so so worth it
18:03:49 <dons> @quote 
18:03:50 <lambdabot> HavocPennington says: Haskell is the least-broken programming language
18:03:50 <lambdabot> available today.
18:03:52 <dons> @quote Philippa
18:03:53 <lambdabot>  hey, if the guy wants a monadectomy that's his choice
18:03:57 <jethr0_> ah
18:04:29 <dons> I did a big rearrangement of the quote plugin yesterday
18:04:29 <DukeDave> test
18:04:42 <ihope> What's a monadectomy?
18:04:45 <dons> should kill the randoms bug (it hasn't come back yet, anyway), and moves @quote into the Quote module
18:05:00 <dons> ihope, i'll tell you when you're older.
18:05:18 <ihope> @quote dons
18:05:18 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
18:05:19 <dons> happy happy :)
18:05:35 <ihope> Is it like a tattoo?
18:05:54 <DukeDave> it means your children won't get category theory :)
18:06:03 <dons> hehe
18:06:12 <jethr0_> ihope: it's when your little friend - the monad - is rendered non-functional
18:06:33 <ihope> Aww, the poor monad :-(
18:06:55 <jethr0_> DukeDave: that can easily happen without a monadectomy
18:07:19 <DukeDave> what, if your kids start doing drugs?
18:07:29 <DukeDave> or worse, business school ;)
18:07:32 <dons> @version
18:07:33 <lambdabot> lambdabot 3p309, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
18:07:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:07:43 <jethr0_> the latter more rather than the former
18:07:49 <jethr0_> s/more//
18:07:56 <dons> @dynamic-reload quote
18:07:57 <lambdabot> module reloaded
18:08:02 <dons> @dynamic-reload version
18:08:02 <lambdabot> module reloaded
18:08:06 <dons> @version
18:08:07 <lambdabot> lambdabot 3p313, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
18:08:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:08:07 <DukeDave> hmmm, I feel another problem coming on
18:08:33 <jethr0_> DukeDave: you seem to be over-proportionally full of problems these days
18:08:36 <DukeDave> ahh, I think this is a foldr affair
18:08:36 <dons> @remember DukeDave what, if your kids start doing drugs? or worse, business school
18:08:37 <lambdabot> Done.
18:08:40 <dons> ^^ test
18:08:41 <dons> good
18:08:44 <DukeDave> yeah, sorry
18:09:09 <DukeDave> but just think, at this rate I'll be up to wadler standard in no time ;)
18:09:33 <SamB> jethr0_: that issue with whoever gives out all those ratings isn't what I meant ;-)
18:10:16 <SamB> I mean, of course Andrew Plotkin has more star power than I...
18:10:31 <jethr0_> i know, although there seems to be a case of haskell discrimination... i call for a strike of all commercial haskell programmers, to let the industry feel our rage!
18:10:45 <SamB> re, Plotkins?
18:10:52 <jethr0_> nm
18:10:52 <SamB> s/re/er/
18:10:57 <SamB> anyway, Zarf
18:11:11 <SamB> quick, someone mention 
18:11:14 <SamB> Common Lisp
18:12:14 <vincenz> forth
18:12:21 <jethr0_> one of the most frequent speech impediments is the common lisp
18:13:06 <ihope> It's one of the most common programming impediments as well.
18:13:30 <dons> jethr0_, that's like a threat often made for phd students to go on strike
18:14:11 <jethr0_> common, lisp with me, do the lisp with me, ...
18:15:50 <jethr0_> (lisp (((is not) (such a)) bad) language (after all))
18:16:18 <jethr0_> disclaimer: i don't mind the parens, just mocking other people's opinion ^_^
18:18:38 <moonlite> how do you prononuce 2^4 ?
18:18:48 <dons> 2 "to the power of" 4 ?
18:18:49 <moonlite> two to the power of four?
18:18:52 <moonlite> thx
18:19:00 <dons> :)
18:19:17 <dons> > 2 ^ 4 -- or maybe pronounce it as "16"
18:19:18 <lambdabot> 16
18:19:26 <moonlite> :P
18:20:28 <moonlite> i'm writing formal semantics for a computer language for school. i'd bet the TA will have something to say if i define pow to be "16" :)
18:20:35 <dons> hehe
18:20:55 <dons> what are you writing the semantics in? a theorem prover, or on paper?
18:21:07 <moonlite> on paper
18:21:13 <dons> old skool ;)
18:21:18 <moonlite> or actually as ascii 
18:21:36 <moonlite> never gotten to learn fancy stuff like LaTeX
18:21:52 <dons> ah, it's easy peasy!
18:21:54 <moonlite> it looks much better though
18:22:06 <dons> This is latex, and \emph{this} is also latex
18:22:13 * DukeDave sets mode -problems assignment
18:22:17 <dons> my chemist gf uses latex
18:22:22 * DukeDave sets mode +likes haskell
18:22:29 <dons> my lawyer sister uses latex. it's not hard!
18:22:30 <moonlite> when i learn it i'm gonna make a "my pseudo syntax" to latex-compiler
18:23:03 <dons> moonlite, I have always dreamed of a haskell edsl that spits out latex
18:23:11 <jethr0_> > let [the,power,of'] = replicate 3 undefined; two x = x 2; to _ _ _ x = (^x); four = 4 in two $ to the power of' four
18:23:12 <lambdabot> 16
18:23:21 <dons> nice jethr0_ :)
18:23:57 <moonlite> hm, there was some guy that tried to do something like that as his project in our Advanced Functional Programming-course
18:24:02 <jethr0_> > let [the,power,of'] = replicate 3 undefined; two x = x 2; to = ($); the _ _ x = (^x); four = 4 in two to the power of' four
18:24:03 <lambdabot>   Conflicting definitions for `the'
18:24:03 <lambdabot>   In the binding group for: the, power, of', two, to, the, four
18:24:03 <moonlite> no idea how it went though
18:24:10 <jethr0_> > let [power,of'] = replicate 3 undefined; two x = x 2; to = ($); the _ _ x = (^x); four = 4 in two to the power of' four
18:24:10 <lambdabot>   add an instance declaration for (Num ((t1 -> t2 -> b -> a -> a)
18:24:10 <lambdabot>                -> a1
18:24:10 <lambdabot>                -> a2
18:24:15 <jethr0_> nm
18:24:19 <moonlite> :)
18:25:10 <dons> moonlite, where are you studying?
18:25:18 <moonlite> chalmers
18:25:43 <dons> cool. haskell central, practically :)
18:25:45 <moonlite> of john hughes fame :)
18:25:46 <jethr0_> > let [power,of'] = replicate 3 undefined; two x = x 2; to = ($); the _ _ x = (^x); four = 4 in two `to` the power of' four
18:25:47 <lambdabot> 16
18:26:07 <ihope> > "=|°-)"
18:26:07 <lambdabot> "=|\194\176-)"
18:26:09 <dons> Lemmih, nice patch the one to move pragma handling into the lexer
18:26:32 <dons> @karma+ Lemmih -- QuickCheck ghc!
18:26:32 <lambdabot> Lemmih's karma raised to 13.
18:26:42 <dons> ^^ that is a truly great idea, Lemmih
18:27:02 <moonlite> yep, haskell is the first computer language us computer engineering students get to learn.
18:27:41 <dons> same here at UNSW. very few others (any?) teach haskell first.
18:28:00 <cpatrick> UWA does
18:28:04 <moonlite> some teach Lisp i've heard
18:28:05 <dons> ah, cool.
18:28:09 <cpatrick> however then everything else is Java :-(
18:28:12 <dons> cpatrick, what text do you use?
18:28:15 <jethr0_> karlsruhe does too
18:28:15 <DukeDave> there was a nice topic on slashdot a few days ago about 'the optimal first language'
18:28:25 <cpatrick> dons: not sure, I'm not actually a CS student :-)
18:28:27 <dons> didn't know that karlsruhe did. that's good.
18:28:37 <moonlite> i think it's nice to start with fp before imperative. Most students will start out on the same level that way :)
18:28:41 <Lemmih> dons: (:
18:28:46 <jethr0_> yeah, but only as long as goos of compiler fame teaches the freshers :(
18:29:10 <jethr0_> and he's retired now. although for now he still teaches
18:29:34 <dons> jethr0_, you at karlsruhe?
18:29:56 <jethr0_> yes
18:30:16 <dons> you know gernot heiser, an OS professor there (part time, at least)?
18:30:31 <cpatrick> the impression I get though is that people emerge from their first haskell course thinking that Haskell is a useless language for anything but teaching
18:30:54 <jethr0_> no, liedtke was the former OS prof, but he died when i started studying here. there's a new prof there, but i don't know much about him.
18:31:09 <jethr0_> only that he's not likely to push L4 forward very energetically :(
18:31:20 <dons> jethr0, actually, gernot worked with liedtke. 
18:31:24 <jethr0_> ah
18:31:34 <dons> gernot's also the Prof of OS here at UNSW
18:31:51 <dons> we share a lot of OS students between Karlsruhe and here.
18:32:35 <jethr0_> would you know anything about whether L4 will be continued on? would be a shame to just drop it...
18:32:48 <dons> well, there's a lot of L4 work here
18:33:04 <dons> for exampe, there's a phd student doing verification of the kernel, using Isabelle
18:33:19 <jethr0_> nice!
18:33:32 <jethr0_> i didn't know C verification was feasible
18:33:35 <dons> so it certainly continues here, in much the same tradtition as at Karlsruhe
18:33:41 <jethr0_> and even assembly in parts
18:34:21 <cpatrick> dons: do you know a David Greenaway?
18:34:25 <dons> yeah, we have Gerwin Klein, -- he verified a java compiler in Isabelle for his phd, and now he helps with this L4 verificatipn project
18:34:44 <dons> jethr0_, here's the unsw L4 stuff - http://ertos.nicta.com.au/
18:34:51 <cpatrick> (he's a UNSW honours student, IIRC doing something L4-ish)
18:34:57 <jethr0_> thx
18:35:10 <dons> hmm, cpatrick, the nname vaguely rings a bell
18:35:28 <dons> i've had less to do with the OS group since we formed our own languagges group about 3 years ago, so i don't know the new guys
18:35:35 <jethr0_> k, gotta go to bed. good night everyone
18:36:00 * jethr0_ would like to see a nice micro-kernel based OS someday soon.
18:36:30 <jethr0_> no idea why it's not being done. i don't even care so much for ultimate speed. and then much of the daemons, userland stuff could be written in some sane language
18:36:44 <jethr0_> instead we've got the blob that is linux :(
18:37:28 <Philippa> I suspect a whole pile of people wrote micro-kernels and then nobody wrote anything on top?
18:37:32 <jethr0_> which dies just as badly (if not worse) from bad driver as windows
18:38:18 <jethr0_> Philippa: yes, but i don't get why. code maintanance and switching daemons (not to speak of no kernel-upses) should be worth it, no?
18:38:28 <moonlite> Hurd is a micro kernel right? Is it in active development anymore?
18:38:48 <jethr0_> moonlite: active development by two guys or so, whenever they've got time
18:38:54 <dons> there's an honours student here porting the hurd to run on l4
18:38:54 <moonlite> neat
18:38:58 <dons> so it must be vaguely active
18:39:08 <jethr0_> hurd is a real disgrace for the gnu project (not least to the stolen momentum by linux, though)
18:41:05 <lisppaste2> DukeDave pasted "it works!   (and it quit impressive for me :)" at http://paste.lisp.org/display/17698
18:41:32 <tennin> GNU project seems to be taking more of an interest in it lately though
18:41:47 <DukeDave> r/quit/quite
18:41:59 <DukeDave> also   +is
18:42:00 <DukeDave> ;)
18:42:35 <tennin> with their new packaging effort at least
18:43:43 <jethr0_> tennin: i'd be glad if they did, but it's been simmering for 15 years now. so gaining people to work on it might be harder than it seems at first glance
18:43:44 <moonlite> jethr0_: did i understand you right btw. If you have a proper micro kernel, would you possibly be able to recover from a graphics driver "crash"
18:44:37 <jethr0_> moonlite: i'm not an expert. but almost everything would run in some kind of userland (scheduler, mem management, filesystems, ...) and users could use their own, ...
18:44:39 <dons> if you had a userland driver, yeah. but the hurd isn't unique in having userland drivers
18:44:46 <moonlite> um, add "for example" to that sentence
18:44:48 <dons> therre's userland fs in linux now
18:45:05 <dons> which is quite interesting
18:45:21 <SamB> moonlite: mmmmaaaaaaaaaaaybeeee
18:45:34 <jethr0_> it is. i've always wanted to write an enhanced file system to join some sql information, and do fs union mounts.
18:45:52 <SamB> though often it leaves your console in an unusable state, which complicates matters considerably
18:46:03 <jethr0_> SamB: i'm not so dubious. it would just have to be restarted into some sane initial state
18:46:03 <cpatrick> jethr0_: you can do that now using e.g. FUSE, though
18:46:09 <jethr0_> cool
18:46:40 <SamB> jethr0_: how are you going to restart it
18:46:52 <jethr0_> SamB: but still, missing graphics is _vastly_ superior to a frozen OS, IMO
18:47:21 <jethr0_> SamB: it would have to be restarted by some other daemon, or restart itself on failure. how should i know about such minutiae :)
18:47:37 <SamB> and then there is the distinct possibility that a graphics driver buggy enough to crush would manage to bring the OS down with it
18:48:09 <SamB> er, crash
18:48:14 <jethr0_> SamB: no, because it's linked to the microkernel (and all other daemons) only via messages. so exactly that shouldn't happen!
18:48:19 <cpatrick> yeah, X is already in userspace and can still bring down the whole machine if you look at it the wrong way
18:48:38 <jethr0_> cpatrick: that's only through the graphics driver AFAIK
18:48:44 <cpatrick> at some point you need to talk to physical hardware
18:48:46 <cpatrick> jethr0_: yeah
18:48:55 <SamB> are you claiming that these messages make direct hardware access somehow safer?
18:49:34 <jethr0_> SamB: no, but most daemons don't need unlimited mem access. graphics might be an exception
18:49:59 <jethr0_> but it should be possible to restrict the graphic driver's access to some DMA region where it shouldn't be able to corrupt the whole of memory
18:50:18 <SamB> jethr0_: yes, graphics might be an exception.
18:50:28 <jethr0_> _might_
18:50:55 <SamB> certainly it needs access to all the video-card areas, save ROMs
18:51:26 <moonlite> sorry to continue bugging you but is it "greater than" or "greater then"?
18:51:44 <sjanssen> greater than
18:51:48 <moonlite> thx again
18:53:00 <jethr0_> SamB: but it many settings you might only need some kind of vga/... and not necessarily hardware acceleration or GB throughput. i'd be happy to have a stable system with reduced graphics in a non-gaming computer
18:53:18 <jethr0_> this is certainly no reason not to persue micro-kernels
18:55:31 <Philippa> I'd sure want more than just plain ol' VGA - how widespread's VESA support these days?
18:56:33 <cpatrick> ubiquitous, but painfully slow
18:56:53 <jethr0_> Philippa: i meant vga/xga/...
18:57:13 <jethr0_> on a server i might not even need graphics at all
18:58:54 <Philippa> AFAIK xga was never a standard from the POV of code talking to the graphics card?
18:59:19 <Philippa> I realise what you're saying. I just used to hack 2d graphics in DOS a long time ago :-)
18:59:27 <jethr0_> "AmigaOS, for example, was a microkernel - and an unusual one: Since AmigaOS had no memory protection, its messaging was as quick as it could get (passing a pointer to memory), making the AmigaOS kernel one of the fastest ever devised." ^_^
18:59:40 <Philippa> heh
19:00:20 <Excedrin> Philippa: demos?
19:01:18 <Philippa> nah, gamedev
19:01:42 <Philippa> the only thing scene-related I did was track (and not for scene purposes)
19:02:20 <jethr0_> anywho, code reviewing a graphics driver might still be feasible whereas making sure all linux drivers are safe seems like quite a task
19:02:26 <Excedrin> after watching the Spore presentation, I decided to check out the demo scene again, it's still amazing what they can do in 4k
19:03:30 <jethr0_> Excedrin: although i found it more amazing before opengl "existed". but fitting mini-movies with music into a few K obviously still is very impressive
19:03:49 <Excedrin> agreed on both points
19:03:51 <dons> @karam+ daan -- for writing darcs-server
19:03:52 <lambdabot> Maybe you meant: karma karma+
19:03:59 <dons> @karma+ daan -- for writing darcs-server
19:04:00 <lambdabot> daan's karma raised to 1.
19:04:24 <dons> shapr, daan leijen's new darcs-server sounds like the cgi interface you've been asking for for years!
19:04:39 <dons> @where+ darcs-server http://www.equational.org/darcs-server
19:04:40 <lambdabot> Done.
19:09:39 <jethr0_> i couldn't find out much more about graphics drivers in microkernels. only that fine-grained access controls can be put on daemons, allowing them only access to mem regions/devices they need. thus even a graphics driver should be reasonably limited in crashing the whole system...
19:12:45 <vincenz> doh
19:12:59 <DukeDave> permission to pester about IO :)
19:13:38 <jethr0_> DukeDave: please don't ask how to get the string out of "IO String"
19:13:46 <jethr0_> :)
19:13:51 <lisppaste2> DukeDave pasted "An IO question" at http://paste.lisp.org/display/17699
19:13:58 <DukeDave> hehe
19:14:20 <DukeDave> well, I'm just about past that - though this q will probably contradict that statement :)
19:15:22 <DukeDave> on lines 38 -41, its a 'worker' function,  ideally I pass in the filenames of txts containing lists of keywords
19:15:34 <jethr0_> DukeDave: btw, you don't need the "in" within a do block.
19:15:37 <DukeDave> I could do all the work in the 'main'
19:16:25 <DukeDave> but it would be nice to lift that to another func
19:16:34 <kpreid_> DukeDave: you want mapM, somewhere
19:16:43 <kpreid_> @type mapM
19:16:43 <lambdabot> forall b (m :: * -> *) a.
19:16:43 <lambdabot>    (Monad m) =>
19:16:43 <lambdabot>    (a -> m b) -> [a] -> m [b]
19:16:45 <DukeDave> > mapM
19:16:45 <lambdabot>   add an instance declaration for (Show ((a -> m b) -> [a] -> m [b]))
19:17:08 <DukeDave> oh no, not monads again
19:17:14 <DukeDave> please not like this! ;)
19:17:21 * jethr0_ hates looking at other people's code and being expected to instantaneously "get" it. especially when i'm tired
19:17:48 <DukeDave> hehe, sorry, as usual I've adopted a 'I can comment it just before I hand it in'  approach :)
19:18:08 <DukeDave> there will be rewards for this excellent service though
19:18:18 <DukeDave> I don't know what I'd do without irc :)
19:18:53 <kpreid_> DukeDave: (mapM readFile lns) will give you the contents of all of those files, for example
19:19:31 <kpreid_> er, using 'lns' that doesn't make sense with the rest of your program, but never mind
19:20:09 <kpreid_> basically in order to make getKWDefs work you need mapM or to do the equivalent yourself; whether it's in main or getKWDefs is your choice
19:20:13 * kpreid_ stops
19:21:19 <jethr0_> DukeDave: i'm tired so i might be talking bullsh*t. but if you've got a list of "[IO a]" and want an "IO [a]" instead, you can use "sequence" for that
19:21:51 <jethr0_> > sequence [Just 3, Just 5, Just 1]
19:21:52 <lambdabot> Just [3,5,1]
19:23:11 <jethr0_> alternatively you could do "as <- getKWDefs xs; return ([(x, lines keywords)] ++ as)"
19:23:27 <jethr0_> if i have even an inkling of what the problem is you're referring to
19:24:03 <DukeDave> close
19:24:04 <DukeDave> :)
19:24:07 <jethr0_> with getKWDefs of type "[String] -> IO [KWDef]"
19:24:47 <jethr0_> also, you could use foldM
19:24:50 <jethr0_> @type foldM
19:24:51 <lambdabot> Not in scope: `foldM'
19:25:00 <jethr0_> @type Control.Monad.foldM
19:25:01 <lambdabot> forall a (m :: * -> *) b.
19:25:01 <lambdabot>         (Monad m) =>
19:25:01 <lambdabot>         (a -> b -> m a) -> a -> [b] -> m a
19:25:41 <DukeDave> bah, I'm confused again >:(
19:29:43 <jethr0_> foldM (\defs arg -> do keywords <- readFile arg; return defs++[(x, lines keywords)]) [] args
19:30:03 <jethr0_> unless that's complete nonsense
19:30:22 <DukeDave> I'll see if I can plug it in :)
19:30:43 <jethr0_> rather try the version from before. i'm much more comfortable with that working :)
19:30:58 <jethr0_> gotta go to bed, good luck with the assignment
19:31:12 <DukeDave> cheers man!
19:31:23 <DukeDave> you've been of endless help :)
19:31:43 <DukeDave> map myGratitude [1..]
19:31:54 <jethr0_> don't exaggerate. that's bad for my karma ^_^. always glad to help
19:33:09 <jethr0_> where myGratitude = recip
19:34:43 <jethr0_> night
20:02:27 <DukeDave> @type mapm
20:02:27 <lambdabot> Not in scope: `mapm'
20:12:56 <dons> @hoogle mapm
20:12:56 <lambdabot> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:12:56 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:12:56 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:44:45 <DukeDave> cheers dons :)
20:54:56 <adu> what was that package that made patterns like RegEx?
20:55:38 <DukeDave> heh, okay, I give up on IO in haskell - I'm going to submit my cwork with a perl script which does the IO in inserts lists into the haskell source, then recompiles, then executes :)
20:56:01 <DukeDave> r/in/,
20:56:28 <DukeDave> nighty!
21:01:04 <dons> give up on IO? :/
21:01:26 <dons> adu, more info?
21:08:24 <palomer> IO is like a bad husband, you never know what to expect and sometimes it comes home with gin on its breadth
21:10:32 <Cale> IO is really a pain in any language, if it seems moreso in Haskell, it's only by contrast with the pure language.
21:13:39 * palomer is lucky: he never does IO except at the toplevel
21:14:00 <palomer> I've never run into the situation where I had to IOafy functions which really had no place being done with IO
21:14:25 <Cale> and you never should really run into that
21:20:30 <palomer> so how could IO be a pain?
21:21:50 <dons> yeah. I think only in contrast could it seem a pain
21:23:12 <palomer> how so?
21:23:46 <dons> people don't understand the separation well enough, and try to run IO code from pure code
21:24:25 <Cale> and the pure language frees you from having to think about lots of things, like the order in which things will be evaluated, and IO forces that upon you.
21:24:27 <dons> unlike in sloppy languages where you can mix your side effects up, that discipline can seem confusing
21:25:19 <dons> a lot of the criticism of IO in haskell is about the discipline it imposes on you to keep it isolated.
21:26:03 <wchogg> Eh, but I actually find monadic IO very pleasant.  It's rather hard to use languages that are impure once you've gotten used to it.
21:26:14 <Cale> yeah
21:26:21 <dons> yeah I agree
21:26:25 <palomer> the only time I have to run IO code in pure code is trace
21:27:10 <dons> OCaml feels so wrong after Haskell
21:27:30 <dons> all the side effects appearing in random places 
21:27:59 <Cale> I was confused out of my mind when I saw them using () to represent side effecting things
21:28:02 <vincenz> dons: yah
21:28:10 <vincenz> dons: ocaml feel so wrong prehaskell
21:28:18 <palomer> ocaml is just wrong
21:28:19 <palomer> too much magic
21:28:34 <dons> don't they have a 'magic' magic function?
21:28:36 <dons> for ffi?
21:28:43 <dons> or is that SML.
21:29:00 <Cale> I think it was someone's assignment, and there was a question which asked for a function of a certain type, and I could actually prove that no such function existed, but then we realised that side effects might allow it to happen.
21:29:17 <dons> hehe
21:29:25 <Cale> (a function of a certain type with certain semantics of course)
21:29:26 <dons> sloppy.
21:29:28 <vincenz> typeclasses, non first value data-constructors and the lack of "deriving" seriously pissed me off in ocaml
21:29:34 <vincenz> lack of typeclasses that is
21:30:02 <vincenz> lack of typeclasses being numero 1
21:30:17 <Cale> why wouldn't you have first class data constructors? Isn't that a trivial feature?
21:31:13 <wchogg> What are other languages that are worth knowing for how they make you think?
21:31:22 <vincenz> Cale: no idea
21:31:30 <vincenz> Cale: but you had to resort to
21:31:38 <vincenz> myCon x y = MyCon x y
21:31:51 <wchogg> Epigram doesn't really seem usable yet.  Am I mistaken?
21:31:55 <Cale> yeah, like, the compiler could do that for you easily enough even :)
21:32:02 <dons> wchogg, C?a theorem prover is really good too
21:32:16 <dons> learning isabelle and twelf improved my haskell a lot
21:32:43 <dons> you get an idea of how to `lean on the typesystem', as Cale says.
21:32:58 <wchogg> I haven't heard of either of those before.  Are they also functional?
21:33:10 <vincenz> hmmmm
21:33:14 <vincenz> bread with horseradish
21:33:46 <dons> they're theorem provers. Isabelle/HOL in particular is quite famous. they're like programming on the type level of haskell, with a lot more support and libraries
21:34:07 <palomer> yeah, dataconstructors should be first class citizens!
21:34:26 <palomer> you can fake typeclasses with polymorphism, most of the time
21:34:38 <dons> wchogg, you write a theorem, encoded as a type. and then try to construct an expression of that type, which b Ccurry-Howard is a witness to the thing you're trying to prove
21:34:42 <palomer> Cale: for optimization purposes
21:34:48 <vincenz> 1.0 +. 2.0
21:34:57 <wchogg> dons-That sounds *really* neat.
21:35:03 <vincenz> damn horseradish really clears your nose
21:35:11 <palomer> twelf is logical programming
21:35:22 <palomer> you can actually program in twelf
21:35:32 <dons> twelf is again a theorem prover based on type checking and curry-howard
21:35:40 <vincenz> like eating a sandwich with wasabi
21:35:47 <dons> biased towards stating things about type systems and languages
21:36:33 <dons> it's not logical programming in the sense of prolog, -- i find twelf much like isabelle, and much like writing type-level code in haskell. it's all in the same domain
21:37:07 <dons> anyway, i'd encourage all graduate-level haskellers to play around with Isabelle a bit, it's good for your Haskell :)
21:37:15 <dons> Epigram is probably just as good 
21:37:18 <wchogg> I'll have to do that.
21:37:53 <wchogg> I was waiting for Epigram 2 before playing with it.  I thought from their development posts it would be another couple of months.
21:38:13 <palomer> my prof is making me formalize my proofs in twelf
21:38:14 <palomer> ugh.
21:38:26 <Cale> While not nearly as impressive as any of these, I think icon is worth checking out. It's quite a bizarre imperative programming language.
21:38:30 <dons> ah well, good for your soul palomer
21:38:32 <dons> and way better than paper
21:38:55 <dons> So, on the topic of languages that improve your Haskell, are there any others?
21:39:21 <dons> you think Icon is good for Haskell programming, Cale, or just for a holiday from fp?
21:39:36 <dons> doing a bit of Clean probably helps Haskell
21:39:36 <Cale> dons: well, it's rather like the list monad in some respects
21:40:06 <Cale> Clean probably yeah -- it looks really very close to Haskell
21:40:14 <Cale> maybe even too close :)
21:40:26 <dons> yeah, the differences are interesting. worth a few days study.
21:40:46 <dons> i think Isabelle or twelf could be a couple of weeks or more divergence. months even
21:40:55 <Cale> I don't know if I'd actually write anything in Icon, but it's a neat toy
21:41:12 <Cale> and it was one of the earlier languages with the offside rule
21:41:26 <palomer> pain for my soul
21:41:32 <wchogg> I still think common lisp is fun to play with, but everyone has tried that at some point.
21:41:56 <Cale> I wrote some CL and found it painful after Haskell.
21:42:01 <palomer> in the lispish family, scheme is the way
21:42:14 <palomer> much clearer
21:42:20 <palomer> simpler too
21:42:24 <Cale> scheme seems nicer, but I haven't written a significant amount of code in it
21:42:28 <dons> yeah, coming to it _after_ haskell, is not the way to learn lisp or scheme :/ i made that mistake too
21:43:26 <palomer> one should start with scheme and then move to sml and then haskell
21:43:27 <wchogg> I don't find scheme really that much better, but that's just preference.  I think Lisp is just interesting because of macros.  I think it's interesting what you can do when you force everything to have a very regular representation.
21:44:22 <Cale> write(5 < find("or", sentence)) -- a neat little icon snippet, this prints all the occurrences of "or" in the string 'sentence' which occur after the 5th position.
21:44:26 <dons> on the topic of Isabelle and Twelf, they're a bit like looking at the future of haskell's type system through some kind of crystal ball, I think
21:44:48 <palomer> if one simply wants to learn a lispish language as a stepping stone, might as well use something small and clean. Besides, you can't discount the SICP
21:44:49 <Cale> (the indices)
21:45:07 <dons> in much the way ML was a theorem proving langugage, so Twelf and Isabelle are now being used as type systems in their own right.
21:45:21 <palomer> don't forget Coq!
21:45:28 <wchogg> What's coq?
21:45:34 <palomer> what isn't coq
21:45:39 <dons> ah and coq too
21:45:41 <palomer> theorem prover/programming language
21:45:48 <dons> another theorem prover/super-type-system
21:46:34 <palomer> we learnt about twelf today
21:46:35 <palomer> in class
21:46:43 <palomer> my prof was doing the preservation theorem
21:46:55 <palomer> I don't quite understand how it works
21:47:44 <palomer> you have: preserv: eval e e' -> typed e t -> typed e' t -> type
21:47:53 <palomer> so preserv is a type
21:48:10 <Cale> GAP is a pretty neat language just for its standard libraries
21:48:38 <palomer> I don't see an inhabitant of preserv is a proof of type preservation
21:48:52 <palomer> Cale: is icon really that interesting?
21:48:53 <Cale> I'd really like to have a port of GAP to Haskell (possibly Haskell with proper records)
21:49:11 <Cale> palomer: it's worth a look, I'm not saying to spend too long looking at it :)
21:49:59 <dons> I was surprised/disappointed when a phd student here wrote a new Icon-like language for teaching children how to program lego robots.
21:50:06 <dons> I think there are easier languages to tteach to children...
21:50:52 <dons> ah well. it must have some niche, Icon?
21:50:59 <Cale> Of course, I'm referring to http://www.cs.arizona.edu/icon/ (just realised that there may be other languages with the same name)
21:51:25 <dons> oh, could be.
21:52:11 <wchogg> Hrmm...so is haskell a really good or really bad first language for someone to learn?
21:52:27 <palomer> I'd say really bad
21:52:28 <Cale> wchogg: I think it's a decent first language
21:52:30 <dons> I think it's a good one -- you get the fundamentals of programming very clearly
21:52:33 <wchogg> I think most people come to it after having learned at least a couple languages already.
21:52:51 <palomer> most new people want to get things done
21:52:52 <dons> several universities teach it as a first language for non-programmers, so there must be something to it
21:52:58 <palomer> and haskell is not the language of getting things done
21:53:02 <Cale> We taught it to some elementary school students (11 year olds) and it was fun
21:53:12 <dons> very controversial statement palomer
21:53:28 <Cale> you can get stuff done
21:53:33 <wchogg> I would *think* it's a good one because of the formality and prettyness.  I can imagine though how it would through people off if they needed to learn something like java later.
21:53:41 <Cale> even without IO, you can write programs which you use from GHCi
21:53:54 <dons> certainly. the first year students here program ai robots that solve maze problems in gtk2hs, iirc.
21:54:15 <dons> fun stuff, real compiled code, big problems
21:54:16 <palomer> by getting stuff done, I mean printing circles on the screen, getting your computer to go beep beep, writing a MUD, etc...
21:54:33 <dons> oh palomer, ffi + IO == done
21:54:47 <palomer> but it's more work than simply using C++
21:54:54 <sjanssen> surely we can't teach first year students FFI
21:54:57 <dons> no, less work. we have libraries for this.
21:55:01 <Cale> palomer: have you seen Graphics.SOE?
21:55:12 <Cale> It's a pretty simple case of it
21:55:13 <wchogg> I don't know if it really is.  I've done c++ enough to realize how much little things can slow you down.
21:55:15 <dons> sjanssen, of course not. they call gtk2hs
21:55:31 <Cale> I think there's a Gtk2Hs version of that too
21:55:53 <palomer> haskell is not the language to use when implementing languages described temporally
21:56:06 <Cale> it's a nice simple library for doing simple graphics programs with keyboard and mouse input
21:56:07 <wchogg> What do you mean, described temporally?
21:56:13 <palomer> and temporal thought is something that appears relatively often to new programmers
21:56:27 <palomer> wchogg: actions based on time
21:56:27 <dons> palomer, I guess you need to write a larger variety of haskell programs before you can comment on the restrictions haskell might have ...
21:56:40 <palomer> "first this happens, then this happens, etc..."
21:56:41 <dons> consider, for example, Frag.
21:56:49 <dons> or, for example, yi
21:56:52 <palomer> we're talking about new programmers!
21:57:11 <palomer> you need much more knowledge before you can get things done in haskell
21:57:12 <dons> monads are for sequencing. you teach the IO monad
21:57:34 <palomer> I don't think new programmers are apt to understand , and understand the point, of abstracting control
21:57:48 <wchogg> palomer:  Well, maybe I'm just different because I came from a math background first but I don't think ordering of events is very complicated.  I showed my wife how it works, and it seemed to make more sense to her than other languages.
21:58:03 <dons> if cyou cosider that when teaching Java people often hide the details of IO for several weeks, I don't think that haskell is to bad at all.
21:58:25 <wchogg> I think if you've already been "hardwired" to think in algol-ish languages, then haskell doesn't make much sense for awhile.
21:58:28 <palomer> but you don't hide the details of control! and control is much more fundamental than IO
21:59:01 <palomer> furthermore, a new student has to learn a slew of things not even existent in other languages, like matching and datatypes
21:59:27 <palomer> and if they haven't programmed in anything else, they may not realize how useful these things really are compared to the other, more basic, methods of describing sum and product types
22:00:08 <dons> I guess it depends on whether you're trying to teach computer science, or how to program
22:00:17 <palomer> I'm not criticizing haskell, it is my language of choice, nonetheless it certainly isn't the best language for every situation, and teaching new programmers may be one of them
22:00:20 <wchogg> Well that's kindof my question.  Is it *bad* for them to have to realize that most languages don't have these conveniences or would it be better to learn it right to begin with.
22:00:34 <monochrom> HXT (Haskell XML Toolbox) is very nice.  Arrows are very nice.  I have just used them to write a program that extracts table rows and columns from an html file.  This html file and this table belongs to an online fictional stock trading game.  My next step is to write a trading automaton for this stock game.  (I have also learned how to use the HTTP package and actually built my own abstraction above it.)  I wouldn't want to 
22:00:34 <monochrom> use C++ or Java; the Haskell code I have now is very maintainable and clear.  So, I am new to HTTP, arrows, and HXL, and I'm already getting things done.
22:00:36 <wchogg> *that was a question, not a statement*
22:00:50 <palomer> wchogg: and there may be instances where the other ways would actually be better
22:01:11 <dons> palomer, teaching beginners was a strong current in the design of haskell. see how it's used at chalmers , for example.
22:01:33 <palomer> also, another thing: haskell has a lot of stuff; it's easier to get lost
22:02:30 <wchogg> I would agree though that it's probably more practical to teach something like java to new students.  It will probably be more relevant to the jobs that most of them will have.  Functional programming is pretty idiosyncratic in comparison to mainstream languages.
22:02:39 <palomer> whereas scheme or sml has less stuff, so it's much easier to understand everything you will ever need to do get stuff done
22:03:59 <Cale> the neat thing about (slightly) esoteric languages with respect to Haskell is that it's often possible to import idioms found there, even if the other language wasn't too interesting and just had one major different idea, well, perhaps that idea is captured by some monad, and you can pick up some programming style for that monad
22:04:03 <wchogg> sonofa...the isabelle tutorial is 200 pages long
22:04:34 <dons> it's a language and more, wchogg :) and it's been around for 20 years.
22:04:36 <palomer> Cale: I was wondering if its possible to save a store and restore it later (for ST)
22:05:05 <Cale> palomer: as in, the states of all your STRefs? None that I know of.
22:05:23 <palomer> I mean, is it possible to create a new ST-like monad to do this
22:05:49 <Cale> hmm, perhaps if you were willing to give names to them all...
22:05:55 <Cale> (additional names)
22:06:22 <Cale> er, hmm, the typing is a bit of a tricky issue there I think
22:08:57 <Cale> also, it's hard to even say where you'll get the references back from
22:09:36 <wchogg> Hey, let's start a religious war:  does anyone still enjoy writing in dynamically typed languages even though they like haskell?  Like I said, I still have a soft spot for CL.
22:09:53 <palomer> Cale: you could add state!
22:09:54 <monochrom> I still write bash scripts.
22:10:05 <dons> I write sh scripts too. but I don't like it
22:10:26 <monochrom> I write bash scripts to loop over my haskell programs.
22:10:37 <Cale> I've written GAP programs, though I really do wish GAP was more Haskell-like.
22:11:50 <palomer> check this out, every write updates the state, the state being the next store to save and the last store saved
22:12:16 <palomer> so you'll actually be creating a new ref at every write
22:12:22 <Cale> palomer: how do you deal with the fact that STRefs all have different types?
22:12:39 <palomer> GADTs?
22:12:55 <Cale> hmm
22:13:13 <palomer> the store would be indexed by all the refs present
22:13:24 <palomer> this could be interesting
22:14:21 <Cale> how do you know which/how many types are actually present?
22:14:32 <monochrom> If someone provides a Haskell combinator library for unix processes and redirections, I probably will not need bash scripts.
22:14:55 <palomer> wasn't there an arrows proposal for that?
22:16:38 <palomer> Cale: that isn't a big issue: newMSTRef foo= do y <- newSTRef foo; oldStore <- get; let newStore = add oldStore y; put newStore
22:17:03 <palomer> add:: Store s -> STRef a -> Store (s,a)
22:18:01 <palomer> or add:: STore s a1 -> STRef s a2 -> Store s (a1,a2)
22:18:17 <Cale> your get and put there are getting and putting things of differing type
22:18:22 <Cale> so that's not a state monad
22:18:27 <palomer> oh, very true
22:18:45 <palomer> hrmph
22:18:56 <palomer> I'm thinking this could be done with existential types, don't you think?
22:19:36 <Cale> hmm, maybe
22:19:47 <palomer> nonetheless, this is very interesting stuff
22:20:38 * palomer will ponder it further
22:20:39 <palomer> night!
22:20:50 <Cale> you might also be able to use unsafeCoerce, and work out some scheme in which it will always be safe
22:20:52 <Cale> 'night!
23:14:06 <ProfTeggy> Moin
23:16:09 <bolrod> moooonin'
23:16:26 <bolrod> whats all this then
23:16:57 <ProfTeggy> What do you mean? The life and everything?
23:17:23 <Cale> I just wish I knew what it wasn't.
23:17:36 <bolrod> :)
23:18:11 <ProfTeggy> Cale, supposedly that's an even harder question...
23:19:18 <gour> well, this approach is known as "neti, neti...", which means "not this, not that.."
23:19:44 <gour> "nothing new on the West" :-)
23:46:21 <Bobl> is haskell totally based on lambda calculus or does it cheat a bit occasionally?
23:46:52 <Cale> um, it's not directly based on the lambda calculus
23:47:12 <Bobl> Cale, oh ok, thanks.
23:47:13 <Cale> It's sort of a typed lambda calculus, but there's more to it than that
23:47:30 <Bobl> Cale, yes well i meant the typed version, obviously.
23:47:41 <Bobl> Cale, but what about exceptions and stuff?
23:48:05 <Cale> there are exceptions, but they cannot be caught except in IO
23:48:54 <Cale> so from one perspective, you can treat them the same as non-normalising terms
23:50:00 <Bobl> Cale, that is slightly confusing.
23:50:38 <Cale> > undefined
23:50:39 <lambdabot> Add a type signature
23:50:49 <Cale> > undefined :: Integer
23:50:50 <lambdabot> Undefined
23:51:25 <Cale> > let loop = loop in loop
23:51:26 <lambdabot> Add a type signature
23:51:40 <Cale> > let loop = loop in loop :: Integer
23:51:41 <lambdabot> Terminated
23:51:51 <Cale> heh, I should really have learned from my first mistake :)
23:52:19 <Cale> in some implementations, that can actually throw a nice error
23:52:28 <sieni_> type inference my ass
23:52:32 <Cale> since it's a very detectable form of nontermination :)
23:52:35 <Bobl> Cale, i dont see how that relates to the question.
23:52:54 <Cale> um
23:53:05 <Cale> I'm not sure what you're asking/confused about
23:54:01 <Cale> nontermination and exceptions are often both represented by _|_ (called bottom) in formal systems for describing semantics
23:54:03 <Bobl> Cale, the fact that you can do weird stuff with types is because it is typed lambda calculus, but not because of haskell?
23:55:01 <Cale> what weird stuff?
23:55:33 <Cale> typeclasses are really where programs start getting type-directed
23:55:50 <Cale> since they allow you to define functions differently at different types
23:55:53 <Bobl> Cale, never mind, i obviously have to read up on this.
23:56:08 <Cale> (excuse my lag, it's up around 10 seconds)
23:57:46 <Cale> Haskell is a much larger system than most typed lambda calculi. Even when you remove all the extraneous syntax sugar, you have case and let.
23:59:20 <Bobl> Cale, alrighty, i guess mauke was ritgh ;).
