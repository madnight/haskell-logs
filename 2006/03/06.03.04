00:49:50 <astrolabe> I want to define a function on several lines:  f Red = g 3      f Green = g 7 where g = ...   How do I get the g in scope for all the f lines?
00:50:46 <Lemmih> astrolabe: f x = case x of ... where g = ...
00:51:40 <astrolabe> Gratzie!
00:52:07 <xerox> (Grazie!)
00:52:21 <astrolabe> Grazie!
00:52:46 <xerox> (/me got a graphic tablet!)
00:52:52 <astrolabe> Wow
00:53:00 <astrolabe> What kind?  How is it?
00:53:10 <xerox> It's a wacom volito2, usb
00:53:25 <xerox> It's very very nice, the problem with it is.. being able to draw ;-)
00:53:43 <astrolabe> practice I imagine
00:53:48 <xerox> Right.
00:53:55 <xerox> Now, if only the pressure sensivity worked.
00:54:13 <xerox> It does work like a mouse at this moment
00:54:29 <astrolabe> Is it new or second-hand?
00:54:43 <lennart> xerox: why no pressure sensitivity?
00:54:49 <xerox> A friend of mine lend me
00:54:56 <xerox> lennart: I can't get around how to configure it.
00:55:14 <lennart> what OS are you using?  and what program?
00:56:00 <xerox> Linux, GIMP
00:57:14 <xerox> <http://ubuntuforums.org/showthread.php?t=25151>
00:57:37 <lennart> Perhaps the Linux driver doesn't do pressure?  I know it works in GIMP, because I've used it in NetBSD (I wrote the drivers :)
00:57:53 <lennart> Well, not exactlt that model, but a wacom
00:57:54 <xerox> wacom-dump shows the pressur variance from 0 to 511 in realtime
00:58:11 <xerox> Woo!
00:58:25 <lennart> you need to do something in GIMP too, I think.  you need the right tool
00:58:34 <xerox> I did add the tree InputDevice sections "stylus", "eraser", and "cursor".
00:59:02 <xerox> Then that document says that I should find those three inside gimp -> preferences -> Input Devices-> "Configure Extended Input Devices".
00:59:13 <xerox> But there is only the synaptic pad :-\
01:02:24 * xerox mumbles
01:04:27 <lennart> hmmmmm, i can't remember the details on how i got it working in GIMP
01:10:47 * xerox hmpfs.
01:11:22 <xerox> (EE) No Input driver matching `wacom'
01:11:25 <xerox> ah-ha!
01:12:49 <NotInventedHere> Hi, trying to install c2hs from sources, I type ./Setup.hs configure 
01:12:57 <NotInventedHere> but get *** Exception: Line 21: Unknown field 'hs-source-dirs'
01:13:04 <NotInventedHere> Anyone seen this?
01:13:09 <xerox> NotInventedHere: elide the 's' from dirs
01:13:36 <NotInventedHere> Sorry, I don't understand what you mean
01:13:57 <Lemmih> That only works if there's a single source dir.
01:14:06 <Lemmih> NotInventedHere: s/hs-source-dirs/hs-source-dir/
01:14:35 <xerox> Lemmih: I ran in that problem too in the past.  The right way is update Cabal?
01:14:49 <Lemmih> Yeah.
01:14:56 <xerox> There you go :-)
01:14:57 <NotInventedHere> I don't see that directory structure
01:15:07 <NotInventedHere> I see base, c2hs, etc.
01:15:15 <NotInventedHere> are you suggesting I get rid of one of the dirs
01:15:16 <NotInventedHere> ?
01:15:30 <xerox> NotInventedHere: nope, remove the 's' from 'dirs'
01:15:49 <xerox> (or update cabal)
01:16:35 <Lemmih> NotInventedHere: Read the .cabal file.
01:16:41 <NotInventedHere> ok, thx
01:24:57 <ihope> It's a good thing Djinn doesn't support recursive types.
01:26:43 <ihope> If it did, then this would work:
01:26:52 <ihope> data Self a = Self (Self a)
01:27:23 <ihope> (\(Self a) -> a (Self a)) (Self (\(Self a) -> a (Self a)))
01:28:32 <ihope> There exists a forall a. Self a -> a, so there exists a forall a. Self a, so there exists a forall a. a.
01:31:03 <chrisbro1n> can anyone see anything thats wrong with this... 	f (:>: aa ab) = [explode aa,explode ab]
01:31:20 <chrisbro1n> should it be f ( (:>:) aa ab)
01:31:39 <ihope> What's :>: and what's explode?
01:31:52 <chrisbro1n> they are from programatica's type checker
01:32:05 <chrisbro1n> i am getting a parse error
01:32:13 <chrisbro1n> "Parse error in pattern"
01:33:06 <ihope> Ah. Yes, I think it should be either (aa :>: ab) or ((:>:) aa ab).
01:33:21 <chrisbro1n> i'll try making it infix
01:33:28 <chrisbro1n> aa `:>:` ab
01:33:49 * chrisbro1n curses DrIFT
01:33:52 <integral> *blink* if something is declared as infix, you just use it infix, and afaik when something is all symbols like that it's *inherently* infix
01:34:11 <ihope> Yep. :>: is infix, (:>:) is prefix, `:>:` is an error.
01:34:21 * integral points chrisbro1n as ihope's totally right answer again
01:35:16 <chrisbro1n> ihope no back ticks?
01:35:45 <ihope> None.
01:36:05 <chrisbro1n> just like 1 + 2
01:36:06 <chrisbro1n> i see
01:36:13 <ihope> Yep.
01:36:36 <ihope> If you wanted to use a prefix function infix, you'd use those: 5 `mod` 3
01:36:44 <jyp> 1 + 2, (+) 1 2, plus 1 2, 1 `plus` 2
01:37:03 <ihope> That pretty much sums it up (no pun intended).
01:37:04 <mauke> `(+)` -- doesn't work :(
01:37:12 <chrisbro1n> cheers that worked
01:37:14 <jips> @seen dcoutts 
01:37:14 <lambdabot> dcoutts is in #haskell and #gentoo-haskell. I don't know when dcoutts
01:37:14 <lambdabot> last spoke.
01:37:42 <ihope> If that worked, we'd have people doing 1 `(`(`(`(`(`(`(`(+)`)`)`)`)`)`)`)` 2.
01:38:13 <mauke> you'd need to change `` to something that nests, of course
01:38:23 * shapr boings
01:38:35 <mauke> `{ }` or something
01:38:36 <jyp> hey shapr 
01:38:36 <_llll_> dumb question: how do i get the user to input an Int?
01:38:38 <ihope> But parentheses nest.
01:38:54 <Lemmih> _llll_: Beat him with a stick?
01:38:59 <ihope> liftM read getLine
01:39:00 <mauke> _llll_: ask nicely?
01:39:09 <ihope> I think.
01:39:10 <mauke> ihope: a.k.a. readLn
01:39:29 <ihope> ...Oh. /me notes
01:39:51 <_llll_> a<-getline makes a a String
01:39:53 <integral> ihope: fmap surely?
01:39:54 <integral> @type (liftM, fmap)
01:39:55 <lambdabot> Not in scope: `liftM'
01:40:02 <integral> @type (Control.Monad.liftM, fmap)
01:40:03 <lambdabot> forall a1
01:40:03 <lambdabot>              r
01:40:03 <lambdabot>              (m :: * -> *)
01:40:03 <lambdabot>              (f :: * -> *)
01:40:03 <lambdabot>              a
01:40:05 <lambdabot> [3 @more lines]
01:40:08 <mauke> _llll_: n <- readLn
01:40:09 <integral> gah.
01:40:10 <ihope> liftM = fmap.
01:40:14 <integral> oh!
01:40:27 <mauke> except fmap is for functors while liftM is for monads
01:40:36 <integral> but all monads are functors
01:40:40 <integral> with bells on
01:40:47 <ihope> All monads can be made functors.
01:40:57 <astrolabe> What does it mean if there is a '|' in a class definition?
01:41:08 <ihope> There's nothing about a monad that makes it "BANG!" a functor.
01:41:28 <mauke> instance (Monad m) => Functor m is invalid 
01:41:42 <integral> I thoguth fmap f m = m >>= \r -> return (f r) ?
01:41:44 <integral> *thought
01:41:55 <xerox> @#$%!
01:41:56 <lambdabot> Unknown command, try @listcommands.
01:42:06 <xerox> @pl \f xs -> xs >>= return . f
01:42:06 <lambdabot> fmap
01:42:15 <ihope> class (Functor m) => Monad m where...
01:42:23 <jyp> @swear
01:42:23 <lambdabot> Unknown command, try @listcommands.
01:42:32 <jyp> @arr
01:42:32 <lambdabot> quote module failed: getRandItem: empty list
01:42:33 <Lemmih> @pl return ()
01:42:34 <lambdabot> return
01:42:43 <xerox> err..
01:43:00 <ihope> Well, @pl treats liftM and fmap as the same.
01:43:15 * xerox screams in the direction of XFree
01:43:19 <integral> is there some monad where my definition doesn't apply?
01:43:23 <xerox> ..or xorg or whatever is called
01:43:29 <xerox> integral: I don't think so.
01:43:31 <ihope> Well, there shouldn't be.
01:43:33 <mauke> yes, every monad that isn't an instance of Functor
01:43:41 <integral> huh?
01:43:54 <integral> which part of my definition needs an axiom outside of the standard monad laws?
01:44:03 <ihope> This is too confusing. /me switches to an actual IRC client
01:44:18 <mauke> none, but it's not part of haskell
01:44:36 <integral> you are *EVIL* if you made something a Monad instance that isn't a monad.
01:44:42 <astrolabe> Does anyone know why not?
01:44:54 <integral> OTOH giving the capability to state proofs of the monad laws in haskell would be handy =)
01:45:04 <ihope_> MUCH better.
01:46:08 <ihope> So if both fmap and liftM are defined on a type constructor, they SHOULD be the same.
01:47:17 <ihope> Nothing's forcing them to be that way.
01:47:46 <ihope> liftM f p = p >>= \q -> return (f q)
01:51:33 <tibbe> @hoogle fold
01:51:33 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
01:51:33 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
01:51:33 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
01:51:43 <tibbe> @hoogle foldl
01:51:43 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
01:51:43 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
01:51:43 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
01:52:55 <shapr> hoi jyp 
01:54:43 <tibbe> @type foldl
01:54:44 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:54:59 <ihope> foldl (:)
01:55:04 <ihope> ;-)
01:55:08 <tibbe> > let sum = fold + 0 in sum [1,2,3]
01:55:09 <lambdabot>  Not in scope: `fold'
01:55:15 <tibbe> > let sum = foldl + 0 in sum [1,2,3]
01:55:16 <lambdabot> Couldn't match `a -> b -> a' against `[a1]'
01:55:21 <ihope> > foldl (flip (:)) [] [1,2,3,4,5]
01:55:21 <lambdabot> [5,4,3,2,1]
01:55:23 <tibbe> > let sum = foldl (+) 0 in sum [1,2,3]
01:55:24 <lambdabot> 6
01:55:47 <tibbe> ihope, do you know the definition of foldl?
01:56:02 <ihope> I think I know what it does.
01:56:48 <ihope> @pl \x y -> x ++ [y]
01:56:49 <lambdabot> (. return) . (++)
01:56:56 <ihope> Hmm.
01:57:06 <tibbe> I know what it does to, I want the definition though :)
01:57:16 <ihope> Hmm...
01:57:25 <ihope> foldl _ x [] = x
01:58:03 <mauke> foldl f z [] = z; foldl f z (x : xs) = foldl f (f z x) xs; or something like that
01:58:13 <ihope> foldl f x ys = f (foldl f x (init ys)) (last ys)
01:58:55 <ihope> ...Yes, mauke's definition is much better than mine.
01:59:03 <mauke> @type init
01:59:03 <Lemmih> @type let foldl fn d [] = d; foldl fn d (x:xs) = fn (foldl fn d xs) x in foldl
01:59:04 <lambdabot> forall a. [a] -> [a]
01:59:04 <lambdabot> forall t
01:59:04 <lambdabot>                             a.
01:59:04 <lambdabot>                           (t -> a -> t)
01:59:04 <lambdabot>                           -> t
01:59:06 <lambdabot>                           -> [a]
01:59:08 <lambdabot>                           -> t
01:59:39 <ihope> @index (;)
01:59:40 <lambdabot> bzzt
01:59:51 <ihope> let x ; y = x ++ [y]
01:59:57 <ihope> Reverse cons thingy.
02:00:12 <mauke> ; is syntax
02:00:19 <ihope> Oh yeah.
02:01:28 <ihope> Sorta like how this doesn
02:01:30 <ihope> 't work:
02:01:42 <ihope> > let x -- y = x ++ y in [1,2,3] -- [4,5,6]
02:01:43 <lambdabot>  parse error (possibly incorrect indentation)
02:01:51 <ihope> > let x
02:01:51 <lambdabot>  parse error (possibly incorrect indentation)
02:01:53 <ihope> ;-)
02:03:35 <ihope> > let (--) x y = x ++ y in (--) [1,2,3] [4,5,6]
02:03:36 <lambdabot>  parse error (possibly incorrect indentation)
02:18:32 <Lemmih> The internals of GHC are deeply amazing. Large parts of it has been written with tons of runtime typechecks.
02:19:03 <ihope> Runtime typechecks?
02:19:24 <jyp> msg lambdabot > let (-_-) = 1 in (-_-)
02:19:37 <jyp> msg lambdabot @eval let (-_-) = 1 in (-_-)
02:19:47 <jyp> msg lambdabot @quote
02:20:13 <ihope> Um.
02:20:47 <ihope> Maybe /quote PRIVMSG lambdabot :> let (-_-) = 1 in (-_-)
02:20:54 <Lemmih> ihope: Stuff like this: fn (Just a) = ...; fn Nothing = panic "this shouldn't happen"
02:23:12 <Lemmih> ihope: And the compiler used to return the same result for every backend target.
02:23:21 <tibbe> @type (.)
02:23:22 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:24:36 <ihope> What's a good way of representing lambda calculus expressions in Haskell?
02:25:33 <tromp_> how about data Lexp = Lvar Id | Labs Id Lexp | Lapp Lexp Lexp ?
02:26:06 <tibbe> ihope, http://www.itstud.chalmers.se/~larssont/Syntax.hs
02:26:20 <tibbe> ihope, remove the Ints, Bools and Lists
02:26:49 <tibbe> you probably want a Value type as well if you're going to evaluate expressions
02:27:43 <tibbe> @type let compose f g = f(g) in compose
02:27:43 <lambdabot> forall t t1.
02:27:43 <lambdabot>              (t -> t1) -> t -> t1
02:28:50 <mauke> @type ($)
02:28:51 <lambdabot> forall b a. (a -> b) -> a -> b
02:39:53 <ihope> What are the two largest primes not ending in one of the digits 1, 3, 7 and 9?
02:41:21 <neologism> 6 and 8 :)
02:41:29 <ihope> Um.
02:41:39 <ihope> Those are prime numbers?
02:41:56 <ihope> Hmm...
02:41:59 <neologism> they can pretend to be
02:42:04 <ihope> Wait, wait...
02:42:40 <ihope> > let sieve (x:xs) = x : [y | y <- xs; y `mod` x /= 0] in sieve [4..]
02:42:40 <lambdabot>  parse error on input `;'
02:42:46 <ihope> > let sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in sieve [4..]
02:42:47 <lambdabot> [4,5,6,7,9,10,11,13,14,15,17,18,19,21,22,23,25,26,27,29,30,31,33,34,35,37,
02:42:47 <lambdabot> 38,39,41,42,43,45,46,47,49,50,51,53,54,55,57,58,59,61,62,63,65,66,67,69,
02:42:47 <lambdabot> 70,71,73,74,75,77,78,79,81,82,83,85,86,87,89,90,91,93,94,95,97,98,99,101,
02:42:47 <lambdabot> 102,103,105,106,107,109,110,111,113,114,115,117,118,119,121,122,123,125,
02:42:47 <lambdabot> 126,127,129,130,131,133,134,135,137,138,139,141,142,143,145,146,147,149,
02:42:49 <lambdabot> [24 @more lines]
02:42:57 <ihope> There's 6, but no 8.
02:43:11 <ihope> I guess you'd have to use sieve [8..] for that one ;-)
02:43:15 <neologism> let sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in take 10 $ sieve [5..]
02:43:26 <neologism> > let sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in take 10 $ sieve [5..]
02:43:27 <lambdabot> [5,6,7,8,9,11,12,13,14,16]
02:43:51 <ihope> > let sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in takeWhile (<= 25) $ sieve [5..]
02:43:52 <lambdabot> [5,6,7,8,9,11,12,13,14,16,17,18,19,21,22,23,24]
02:44:33 <ihope> s/takeWhile/dropWhile/ and you get prime numbers only... I think.
02:44:48 <neologism> no you wont
02:44:50 <ihope> > let sieve (x:xs) = x : [y | y <- xs, y `mod` x /= 0] in sieve [5..]
02:44:51 <lambdabot> [5,6,7,8,9,11,12,13,14,16,17,18,19,21,22,23,24,26,27,28,29,31,32,33,34,36,
02:44:51 <lambdabot> 37,38,39,41,42,43,44,46,47,48,49,51,52,53,54,56,57,58,59,61,62,63,64,66,
02:44:51 <lambdabot> 67,68,69,71,72,73,74,76,77,78,79,81,82,83,84,86,87,88,89,91,92,93,94,96,
02:44:51 <lambdabot> 97,98,99,101,102,103,104,106,107,108,109,111,112,113,114,116,117,118,119,
02:44:51 <lambdabot> 121,122,123,124,126,127,128,129,131,132,133,134,136,137,138,139,141,142,
02:44:53 <lambdabot> [24 @more lines]
02:44:58 <ihope> I see.
02:59:29 <ihope> Quit, join, join, nick, quit, join, quit, join, nick.
02:59:55 <ihope> @type [Quit, join, join, nick, quit, join, quit, join, nick]
02:59:56 <lambdabot> Not in scope: data constructor `Quit'
02:59:56 <lambdabot>  
02:59:56 <lambdabot> <interactive>:1:7: Not in scope: `join'
03:03:18 <ihope> > (::)
03:03:19 <lambdabot>  parse error on input `::'
03:03:22 <ihope> @type (::)
03:03:23 <lambdabot> parse error on input `::'
03:03:26 <ihope> @index (::)
03:03:27 <lambdabot> bzzt
03:03:35 <ihope> @hoogle (::)
03:03:35 <lambdabot> No matches found
03:03:50 <ihope> @. eval vixen (::)
03:03:51 <lambdabot> compose module failed: getRandItem: empty list
03:03:57 <ihope> @vixen (::)
03:03:58 <lambdabot> vixen module failed: getRandItem: empty list
03:04:07 <ihope> @eval vixen module failed: getRandItem: empty list
03:04:07 <lambdabot>  parse error on input `module'
03:04:22 <ihope> > parse error on input `module'
03:04:22 <lambdabot>  parse error on input `}'
03:04:27 <ihope> > parse error on input `}'
03:04:28 <lambdabot>  parse error on input `}'
03:07:37 <astral_weeks> > error
03:07:37 <lambdabot>  add an instance declaration for (Show ([Char] -> a))
03:07:42 <astral_weeks> > error "Hehe"
03:07:43 <lambdabot> Add a type signature
03:07:55 <astral_weeks> > error "Astral Weeks"::String
03:07:56 <lambdabot> Exception: Astral Weeks
03:09:18 <astral_weeks> > parse error
03:09:19 <lambdabot>  Not in scope: `parse'
03:09:33 <astral_weeks> > (:)
03:09:34 <lambdabot>  add an instance declaration for (Show (a -> [a] -> [a]))
03:09:40 <astral_weeks> > flip (:) [] 3
03:09:41 <lambdabot> [3]
03:14:10 <ihope> > [3]
03:14:11 <lambdabot> [3]
03:14:17 <ihope> > add an instance declaration for (Show (a -> [a] -> [a]))
03:14:18 <lambdabot>  parse error on input `instance'
03:25:38 <NotInventedHere> trying to build c2hs (tried from darcs and v 0.14.5), but i'm getting error:
03:25:53 <NotInventedHere> Couldn't match `LocalBuildInfo' against `Distribution.PackageDescription.PackageDescription'
03:26:02 <NotInventedHere> has anyone seen this before?
03:26:03 <ihope> Ooph.
03:26:14 <NotInventedHere> could my cabal version be too new?
03:26:38 <ihope> It's a type error. Look on the line it's on for any mistakes.
03:27:49 <NotInventedHere> ihope: kinda new to all of this
03:28:07 <NotInventedHere> is it normal that there's problems with build scripts these kinds of projects?
03:28:32 <ihope> Um...
03:28:42 <ihope> Well, was that the full error message?
03:28:51 <sethk> NotInventedHere, I wouldn't say it's normal, no.
03:29:04 <NotInventedHere> ok I'll post it
03:29:05 <sethk> NotInventedHere, but any program, any script, can have a problem with a given environment
03:29:49 <NotInventedHere> ./Setup.hs:11:57: Couldn't match `LocalBuildInfo' against `Distribution.PackageDescription.PackageDescription' Expected type: Args -> InstallFlags -> Distribution.PackageDescription.PackageDescription
03:29:49 <NotInventedHere>                      -> LocalBuildInfo
03:29:49 <NotInventedHere>                      -> IO ExitCode
03:29:49 <NotInventedHere>       Inferred type: Args -> InstallFlags -> LocalBuildInfo -> IO ExitCode
03:29:49 <NotInventedHere>     In the `postInst' field of a record
03:29:50 <NotInventedHere>     In the record update: defaultUserHooks {postInst = addWrapperAndLib}
03:30:05 <NotInventedHere> sorry for the delay!
03:30:29 <ihope> Hmm... /me looks
03:30:51 <ihope> Where would I find Setup.hs?
03:31:28 <NotInventedHere> i did darcs get http://www.cse.unsw.edu.au/~chak/repos/c2hs/
03:31:39 <NotInventedHere> it's in top-level dir.
03:32:32 <NotInventedHere> i have a strong suspicion it's cabal that's too new
03:32:56 <NotInventedHere> because i've just updated it (haddock required it!), and before i updated
03:33:04 <NotInventedHere> c2hs got much further
03:33:10 <NotInventedHere> i'll try reverting
03:40:20 <NotInventedHere> with version 1.0 and 1.1.3: Could not find module `Distribution.Simple.LocalBuildInfo':
03:40:58 <NotInventedHere> i think i'll have to go with the binaries. shame
03:41:35 <ihope> Well, I think you should try the c2hs mailing list or whatever...
03:42:16 <NotInventedHere> ok, will do. thanks for your help!
03:56:25 <davidhouse> hey guys. i've imported Data.Map qualified as M, and i want to use the ! operator. will something like map M.! key work, or do i need some combination of backticks?
03:56:45 <Lemmih> M.! will work.
03:57:19 <Lemmih> map (M.!) key, of course.
03:57:48 <Lemmih> err, map M.! key, I mean.
03:58:18 <davidhouse> cheers Lemmih.
03:58:42 <Lemmih> Depends on whether you want a Map or Prelude.map (:
04:00:08 <davidhouse> yes, "map" was an extraordinarily bad choice for a variable name.
04:04:27 <astrolabe> What does 'class Monad m => MonadState s m | m -> s' mean?
04:04:53 <Lemmih> That 's' is determined by 'm'.
04:05:15 <astrolabe> is that the '| m -> s' bit?
04:05:15 <Lemmih> There can only be one 's' for every 'm'.
04:05:21 <Lemmih> Yes.
04:05:32 <astrolabe> Thanks.
04:05:49 <xerox> I was trying to write up a definition of MonadState, heh.
04:05:51 <astrolabe> Which extension is that?
04:05:59 <xerox> Functional dependencies.
04:06:00 <Lemmih> astrolabe: Functional dependencies.
04:06:09 <xerox> jinx!
04:06:09 <astrolabe> Thank you
04:06:19 <davidhouse> all right, this one comes up fairly frequently: i'm writing a program that will play a simple board game. i want to write a function that takes a number of turns to play, a board, and returns the new board. i think some combination of sequence, replicate and the State monad should do it, but i don't know how to put it all together
04:06:42 <davidhouse> (the turns require no user input, they are completely dependant on what is currently on the board)
04:08:31 <astrolabe> Maybe write it without a monad first, to understand the problem better?
04:08:55 <davidhouse> i've written a function that will play one turn.
04:09:06 <xerox> tick :: Board -> Board
04:09:11 <liyang> iterate tick :)
04:09:14 <xerox> Right.
04:09:19 <davidhouse> iterate?
04:09:22 <davidhouse> @type iterate
04:09:23 <lambdabot> forall a. (a -> a) -> a -> [a]
04:09:37 <xerox> backToFuture n = iterate tick n !! n
04:09:37 <davidhouse> @index iterate
04:09:37 <lambdabot> Data.List, Prelude
04:10:17 <davidhouse> that's brilliant.
04:10:23 <davidhouse> thanks xerox, liyang.
04:11:33 <davidhouse> what a great function :)
04:11:56 <liyang> davidhouse: you could do it with the State Board monad and sequence too. :)
04:12:08 <davidhouse> that would be ugly.
04:12:18 <xerox> It wouldn't
04:12:29 <davidhouse> playN bd n = take n $ iterate evolve bd -- it would be uglier than that
04:12:47 <xerox> I don't think so.
04:13:06 <davidhouse> well, for curiousity's sake, how would it pan out?
04:19:54 <NotInventedHere> ls
04:27:36 <jethr0_> how about: "sequence $ replicate n (get >>= tick >>= put)"
04:28:30 <davidhouse> tick's not monadic.
04:28:54 <davidhouse> something like (get >>= (\a -> put $ tick a)) though might work
04:29:13 <jethr0_> sry, "get >>= return . tick >>= put"
04:29:30 <davidhouse> or that.
04:29:52 <jethr0_> yes, or as you said "get >>= put . tick"
04:30:06 <xerox> there is modify
04:30:08 <davidhouse> but the problem i've had with that approach is i'm not sure where to put the runState
04:30:15 <xerox> @type (Control.Monad.State.modify)
04:30:16 <lambdabot> forall s (m :: * -> *).
04:30:16 <lambdabot>            (Control.Monad.State.MonadState s m) =>
04:30:16 <lambdabot>            (s -> s) -> m ()
04:30:23 <jethr0_> xerox: you're right, i always forget about modify :)
04:30:29 <xerox> runState (sequence $ modify tick)
04:30:32 <xerox> Or some variation
04:30:43 <xerox> Well, along with an initial state
04:31:23 <davidhouse> modify f = get >>= return . f >>= put ?
04:31:38 <jethr0_> yup, i think so
04:31:48 <xerox> @libsrc Control.Monad.State
04:31:48 <lambdabot> http://darcs.complete.org/fptools/libraries/mtl/Control/Monad/State.
04:31:48 <lambdabot> hs
04:32:10 <xerox> modify :: (MonadState s m) => (s -> s) -> m ()
04:32:10 <xerox> modify f = do
04:32:10 <xerox> 	s <- get
04:32:11 <xerox> 	put (f s)
04:32:13 <xerox> Yep.
04:34:15 <davidhouse> hmm
04:35:19 <jethr0_> davidhouse: but if that's the only thing you "need" state for, i'd do without, personally
04:52:40 <davidhouse> jethr0_, yeah, that's what i'm thinking.
04:53:23 <davidhouse> but playN with State would look something like the following?
04:53:42 <davidhouse> playN n = runState (sequence $ replicate n $ modify tick)
04:54:25 <davidhouse> or even, playN n bd = runState $sequence $ replicate n $ modify (evolve bd)
04:54:38 <Lemmih> @type Control.Monad.replicateM
04:54:39 <lambdabot> forall a (m :: * -> *).
04:54:39 <lambdabot>           (Monad m) =>
04:54:39 <lambdabot>           Int -> m a -> m [a]
04:56:01 <davidhouse> ah, so runState $ replicateM $ modify (evolve bd)
04:56:13 <davidhouse> ah, so runState $ replicateM n $ modify (evolve bd)
04:57:26 <astrolabe> Alright.  Who replicated davidhouse?
04:57:38 <davidhouse> sorry, over-eager Ctrl+Up :)
05:02:09 <davidhouse> (was that right, though?)
05:03:33 <Lemmih> Yes.
05:06:41 <davidhouse> wahey.
05:42:29 <dcoutts> @seen SyntaxNinja
05:42:29 <lambdabot> I saw SyntaxNinja leaving #haskell and #haskell-blah 18 hours, 40 minutes
05:42:29 <lambdabot> and 7 seconds ago.
05:43:12 <dcoutts> jips, pong
05:44:33 * gour noticed that robin hood returned back
05:48:28 <dcoutts> gour, heh ;-)
05:48:56 <dcoutts> it went well I think, you'd agree liyang? :-)
05:49:10 <gour> dcoutts: did your arrows hit the target?
05:49:36 <dcoutts> yeah, very good
05:49:48 <gour> wonderful
05:50:01 <gour> any new dev on horizon?
05:54:46 * Lemmih wonders what target they're referring to.
05:55:42 <jips> dcoutts: ping
05:55:50 <dcoutts> gour, no, but more users
05:56:03 <dcoutts> Lemmih, people were impressed by the hIDE demo
05:56:26 <gour> Lemmih: well, our robin hood had visited the forest in n. forest and had some business there :-)
05:56:27 <Lemmih> Wow. dcoutts answered a ping 12 minutes before it was sent! (:
05:56:38 <dcoutts> ?!
05:56:52 <Lemmih> 20:56 < dcoutts> jips, pong
05:56:53 <Lemmih> 21:08 < jips> dcoutts: ping
05:56:58 <dcoutts> heh
05:57:13 <dcoutts> I was responding to a ping from jips from hours ago
05:57:16 <dcoutts> jips, ping!
05:57:20 <dcoutts> err pong
05:57:23 <Igloo> Lemmih: They're just in different timezones  :-)
05:57:27 <gour> dcoutts: i'd be also impressed with hIDE demo (on amd649
05:57:36 <dcoutts> gour, yes, I know :-)
05:57:52 <jips> dcoutts: hIDE demo?
05:58:21 * Lemmih wonders how much memory he could access on an amd649.
05:58:28 <dcoutts> jips, I was doing a presentation + demos at Nottingham yesterday
05:59:02 <jips> dcoutts: cool... i've got some initial yampa-gtk2hs integration working
05:59:09 <Lemmih> dcoutts: You showed the typechecking with a statically built hIDE?
05:59:19 <davidhouse> when should i worry about the difference between type and newtype?
05:59:26 <dcoutts> Lemmih, about 1.2663316555423e+176 times as much
05:59:37 <dcoutts> jips, great!
05:59:41 <liyang> hey dcoutts :)
05:59:45 <dcoutts> Lemmih, yes
05:59:50 <dcoutts> liyang, hia
05:59:54 <Lemmih> Neat.
06:00:10 <dcoutts> Lemmih, yes, I thought so :-)
06:00:19 <gour> Lemmih: it's best to try out for yourself ;)
06:00:20 <dcoutts> it was the premier demo
06:00:27 <jips> dcoutts: check it out: http://img232.imageshack.us/img232/6772/counter0018bs.png
06:00:33 <liyang> So what did you and Axel get up to today?
06:00:42 <liyang> Did you go to the castle in the end?
06:01:07 <Igloo> davidhouse: newtype gives you better type safety, type saves you from having lots of constructor wrapping/unwrapping
06:01:23 <Igloo> davidhouse: Also, you need newtype if you want different class instances to the base type
06:01:28 <davidhouse> when does better type safety matter?
06:01:57 <Igloo> Better type safety means the compiler will catch more of your bugs for you
06:02:14 <jyp> davidhouse: if you define an ADT for example
06:02:40 <davidhouse> ADT?
06:02:53 <jyp> Abstract type...
06:03:20 <jyp> well, you want to hide implementation details from the users of your library.
06:03:45 <davidhouse> hm. okay.
06:04:18 <astrolabe> Even if you are the user of your library.
06:04:28 <gour> dcoutts: what's next on agenda (after taking some rest) ?
06:05:29 <dcoutts> liyang, yes, we saw the castle and the caves 
06:05:45 <dcoutts> gour, finnish the treeview and other api changes and release 0.9.11
06:06:09 <dcoutts> liyang, yeah, it was fun.
06:06:51 <palomer> is there a memomnic for remembering the argument order for foldl and foldr ?
06:06:54 <liyang> heh. :D
06:07:13 <jyp> dcoutts, what was the purpose of the demo, if I may ask ?
06:07:20 <dcoutts> jiing, so what does the code for that look like?
06:07:35 * gour hopes some further work will be done  on hIDE too
06:07:51 <dcoutts> jyp, it was an introduction to building GUIs in Haskell with Gtk2Hs
06:08:00 <astrolabe> foldr is easy, because it has the same structure as a list.
06:08:16 <dcoutts> jyp, the people building Epigram 2 are interested in using it for their new GUI editor
06:08:23 <jyp> @type foldr
06:08:23 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:08:37 <davidhouse> func-init-list. hmm.
06:08:38 <jips> hIDE website could use some screenshots :)
06:08:39 <dcoutts> I'm going to put the presentation online
06:08:52 <jips> dcoutts: cool, when will you put it?
06:08:53 <palomer> it has the same structure as a list?
06:08:56 <davidhouse> palomer, funny interrogative lemons.
06:09:01 <dcoutts> jips, soon
06:09:02 <jyp> dcoutts, ah, that's cool. will be time for me to play with epigram :)
06:09:09 <Lemmih> @wiki Screenshots_of_HIDE
06:09:09 <lambdabot> http://www.haskell.org/haskellwiki/Screenshots_of_HIDE
06:09:22 <dcoutts> jyp, heh, you don't like the emacs UI ? :-)
06:09:39 <jips> dcoutts: sweet, soon like real soon, or soon like a few days?
06:10:00 <dcoutts> jips, give me a chance to relax first! :-)
06:10:15 <jyp> dcoutts, I had a bad enough time with ASF+SDF already :)
06:11:04 <jips> dcoutts: request denied!
06:11:07 * dcoutts was stuck in a train in Oxford station for 15min while Virgin Trains replaced a fuse the controled the opening mechanism for the train doors
06:11:25 <jyp> Ah, british trains... :)
06:11:47 <dcoutts> grr
06:12:09 <davidhouse> 15 minutes?
06:12:10 <davidhouse> wow.
06:12:13 <davidhouse> you were fortunate.
06:12:17 <dcoutts> hah
06:12:47 <astrolabe> > foldr (:) [] [3,4,5]
06:12:48 <lambdabot> [3,4,5]
06:13:04 <davidhouse> the ninja operator!
06:13:08 <gour> here when there is snow, trains are having delays upto several hours :-)
06:13:35 <hyperion^> don't the drivers commit suicide?
06:14:01 <gour> hyperion^: nope. made in croatia (balcan :-)
06:14:35 <gour> hyperion^: maybe they get extra fee for working over the regular shift
06:14:40 <dcoutts> gour, when I was in Slovenia I was impressed by how much more effecient the trains were. They were on time and cheap.
06:14:47 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
06:14:47 <lambdabot> [5,4,3,2,1]
06:14:57 <gour> dcoutts: well, slovenia belongs to EU :-)
06:15:09 <dcoutts> gour, not at the time I was there
06:15:25 <hyperion^> well the EU changed barely anything
06:15:43 <gour> well, they're like small austria, but we are not selling our souls so cheap :-)
06:16:01 <dcoutts> gour, heh
06:16:04 <gour> dcoutts: if you want adventure, then visit serbia :-)
06:16:15 <davidhouse> dcoutts, i hear similar reports of switzerland, another non-EU country
06:16:24 <gour> dcoutts: or you'll see when you arrive in india
06:16:34 <dcoutts> gour, yeah
06:17:18 <gour> once, my friend were travelling from calcutta to delhi with 24hour delay
06:17:37 <gour> and the train was so packed with the communists going to some conference
06:17:47 <gour> that nobody could move an inch
06:18:17 <jips> hm.... the trains here are always accurate to the minute, and i've never experienced a delay
06:18:17 <gour> people were using plastic bottles for water for..hmm...well, you can imagine for what
06:18:23 <dcoutts> gour, sounds like an adventure
06:18:35 <gour> jips: where are you from?
06:18:49 <jips> israel
06:19:18 <gour> dcoutts: yes, it is, but believe me, people there still have more time than on the west :-)
06:20:36 * gour remembers waiting in a bus 'cause the cow was lying on the street peacefully. what a fun
06:22:45 <gour> it looks that dcoutts transferred his tiredness to gour, so /me is going to sleep now
06:22:51 <jips> i need to think of a cool gtk demo
06:23:13 <jips> but i can only use a single window with buttons and text entries
06:23:45 <jips> i want something with about the complexity of a calculator app... but cooler
06:23:53 <dcoutts> jips, have you seen bogel's memory game?
06:23:57 <gour> jips: why not writing demos from gtk-demo tutorial
06:24:14 <jips> dcoutts: no
06:24:18 <jips> gour: you mean the ones at gtk.org?
06:24:36 <gour> jips: yes, showing how the same thing can be done in gtk2hs
06:25:08 <jips> gour: my intent is not to show what can be done in gtk2hs, but what can be done in this sort of layer that i'm building on top of gtk2hs
06:25:13 <dcoutts> jips, it's linked from the gtk2hs documentation page as a tutorial in TMR
06:25:37 <gour> jips: kind of higher-level api?
06:25:40 <dcoutts> jips, it uses buttons with images on them but you could simualte that with numbers I guess
06:25:43 <jips> dcoutts: ah, i think i've seen that, but i think that it used a drawing canvas.... i only have support now for buttons and text entries
06:25:48 <jips> gour: yes, a higher-level functional api
06:25:55 <jips> dcoutts: hm.... i'll look at it again
06:26:19 <dcoutts> jips, it just uses text boxes & buttons with images, but you could have numbers 0-9 instead of the 9 images.
06:26:38 <gour> jips: that sounds interesting. how much stuff you can put under this api?
06:26:39 <jips> dcoutts: yeah i guess... only problem is that i don't yet have support for changing the label of a button
06:26:55 <dcoutts> jips, ah
06:27:17 <jips> gour: it's still not clear, theoretically all or most of the gtk api
06:27:41 <gour> jips: hmm...theoretical limit is very appealing
06:28:06 <jips> gour: but there are still lots of unknowns
06:28:31 <jips> gour: since it's purely functional it's not clear yet how to add support for things like reading/writing files or network connections
06:29:09 <jips> it's also not clear how to fit into the logic model things like popping up dialogs and stuff
06:29:41 <gour> jips: i wish you good luck with your research. it would be nice to show that FP paradigm can be extended on gui programming as well
06:29:52 <jethr0_>  is there anything like design by contract or unit tests embedded in comments for haskell?
06:30:22 * gour is getting sleepy
06:30:29 <gour> d'night folks
06:30:32 <jethr0_> night
06:30:55 <jips> gour: well, i'm basing my work on the yampa framework and i'm taking lots of inspiration from fruit. i don't think i'm doing much academic innovation over these 2 things, but it should be interesting to see how these techniques can be fused to an existing imperative gui toolkit
06:32:07 <jethr0_> jips: cool. i'm just getting into the yampa/afrp vibe and was thinking that an afrp binding to gtk would be great...
06:32:17 <jips> maybe i will port the calc demo that comes with gtk2hs to my system
06:32:29 <dcoutts> jips, indeed it should be interesting. We mentioned in our presentation that we hope that Gtk2Hs should be a basis of a high level GUI lib
06:32:58 <jethr0_> although i'd fear that at some point the correlation breaks down and one would have to invent horribly evil work-arounds :(. but i'd be exhilerated to be proved wrong :)
06:33:04 <dcoutts> jips, yes, if you can show that you've eliminated that IORef that we use to keep the calc state.
06:33:51 <jips> dcoutts: i'm going to study the calc code now, but i'm pretty sure that it will be possible to eliminate the IORef
06:34:04 <dcoutts> jips, yes, I should think so
06:34:40 <dcoutts> that should be one of the main jobs of a high level GUI lib - eliminating IORefs and similar hacks for maintaing the state of the GUI
06:34:45 <davidhouse> how do i import a module whose source doesn't reside in the same dir?
06:34:48 <jips> dcoutts: my first test was to make a "counter" program with a button and a text field. i first coded it "regular" style and used an IORef for the counter, but with my second attempt with yampa there was no need for the IORef
06:35:00 <dcoutts> jips, good
06:35:02 <jips> jethr0_: my initial results are promising
06:35:54 <jips> dcoutts: ah excellent, calc uses glade, i should be able to use the exact same glade gui
06:36:45 <davidhouse> or should i just copy my library every time i want to use it
06:37:25 <xerox> davidhouse: if it's worth it, you can package that library, and use ghc -package yourpackage ..
06:37:35 <davidhouse> copy it is.
06:37:47 <xerox> Then there is -L.
06:37:55 <xerox>  -Ldir  Add dir to the list of directories searched for libraries
06:43:07 <jethr0_> jips: i'm very pleased to hear that. i'll try to become one of your first adoptors :)
06:44:12 <ihope> @type Control.Monad.Cont.callCC
06:44:13 <jips> jethr0_: cool, but don't expect rapid progress, i only have time to work on this a few hours a month
06:44:13 <lambdabot> forall (m :: * -> *) a b.
06:44:13 <lambdabot>           (Control.Monad.Cont.MonadCont m) =>
06:44:13 <lambdabot>           ((a -> m b) -> m a) -> m a
06:44:37 <ihope> @type ($ Control.Monad.Cont.Cont . const)
06:44:38 <lambdabot> forall a a1 b.
06:44:38 <lambdabot>              ((a1 -> Control.Monad.Cont.Cont a1 a) -> b) -> b
06:45:18 <ihope> I dunno which be better.
06:46:31 <ihope> I'll come back to the ((a -> b) -> a) -> a later. /me works on a non-recursive definition of fix
06:52:12 <davidhouse> @pl f a b c = g a b c
06:52:13 <lambdabot> f = g
06:54:02 <jethr0_> ihope: _why_? and how?
06:54:07 <ihope_> Why not?
06:54:22 <jethr0_> isn't fix _inherently_ recursive?
06:55:01 <ihope_> Not if it uses self-application >:-)
06:55:15 <jethr0_> self-application?
06:55:20 <ihope_> \x -> x x
06:55:32 <ihope_> A type-safe version of that.
06:55:35 <jethr0_> looks recursive to me
06:55:51 <ihope_> But... it isn't.
06:56:14 <jethr0_> "recursive function" = a function that calls itself!?
06:56:30 <ihope_> This doesn't call itself; it has something else call itself.
06:56:37 <ihope_> Ah well. I'll work on it some more later
06:56:42 <jethr0_> hehe
06:56:50 <sethk> recursion in the sense usually used here it not specifically about a function that calls itself
06:57:16 <jethr0_> sethk: i was just whipping up a pseudo-definition
06:57:18 <ihope_> Okay. Fix using only lambdas and data constructors.
06:57:20 <jethr0_> sethk: how would you define it then?
06:57:23 <sethk> jethr0_, I know  :)
06:57:47 <sethk> jethr0_, the computation is recursive, not necessarily the implementation 
06:58:18 <jethr0_> huh? you mean like tail-call optimized recursive code?
06:58:27 <davidhouse> @type fix
06:58:27 <lambdabot> Not in scope: `fix'
06:58:34 <sethk> no.  you can implement a recursive algorithm iteratively
06:58:39 <sethk> with a loop, for example.
06:58:47 <jethr0_> yes, but i find that stretches "recusion" a bit
06:58:56 <palomer> hello world!
06:59:03 <jethr0_> primitive recursion covers _a lot_ of algorithms
06:59:25 <davidhouse> > "palomer: hi there :)"
06:59:26 <lambdabot> "palomer: hi there :)"
06:59:30 <sethk> jethr0_, indeed, but that's the important sense of the term.
06:59:42 <jethr0_> hmm
06:59:52 <jethr0_> makes the term a lot less concrete
07:00:43 <jethr0_> sethk: is this recursion 'print "do hello world"; print "hello world"'?
07:01:01 <Cale> Any recursive algorithm can be translated to using loops and vice versa
07:01:19 <jethr0_> yes, and static loops can be unrolled.
07:01:39 <Cale> but most are more natural to write one way or the other
07:02:03 <jips> according to the haskell philosophy, *all* algorithms are more natural to write recursively :P
07:02:36 <Cale> nah, there's hofs too
07:03:04 <jethr0_> HO-recursive-Fs, mind you :)
07:03:05 <Cale> in fact, compared to the use of hofs, I hardly ever write recursion directly
07:03:18 <Cale> well, you don't know that
07:03:25 <palomer> is the problem of finding out if a primitive recursive function halts decidable?
07:03:28 <Cale> (or at least don't need to know)
07:04:13 <Cale> All primitive-recursive functions halt.
07:04:45 <jethr0_> that makes it pretty decidable
07:04:58 <davidhouse> hofs?
07:05:05 <jethr0_> higher order functions
07:05:05 <Cale> Higher-order functions
07:05:15 <jethr0_> like map, foldl, filter, ...
07:05:24 <Cale> all, any :)
07:05:29 <Cale> zipWith
07:05:44 <jips> map (+1) [1..]
07:05:45 <davidhouse> what's the formal definition? to me those looks like recursive functions
07:05:59 <Cale> davidhouse: well, they may be implemented recursively
07:06:02 <palomer> is there a link between promitive recusive and structural recursion?
07:06:09 <jips> hm... i need a 17 size tuple
07:06:14 <astrolabe> a function that takes a function as an argument, or returns a function.
07:06:30 <Cale> and in some sense, things like foldr perfectly capture recursion
07:06:31 <davidhouse> astrolabe: right.
07:06:37 <jethr0_> jips: i don't think so :)
07:06:39 <davidhouse> jips, array?
07:06:54 <jips> nope, my only choice is 17 size tuple
07:06:58 <jethr0_> palomer: isn't that structural induction, rather?
07:07:00 <davidhouse> why?
07:07:10 <palomer> I think coq calls it structural recursion
07:07:15 <jethr0_> ah
07:07:36 <astrolabe> It can't be the only choice.
07:07:37 <jips> hm... oops never mind i actually only need a single value
07:07:43 <astrolabe> LOL
07:08:06 <Cale> davidhouse: but the difference is that in using map, say, you don't have to know that map is defined recursively
07:08:20 <Cale> and you're not writing the recursion yourself
07:09:02 <davidhouse> Cale, why would you need to know how something is implemented?
07:09:33 <Cale> davidhouse: well, writing something like  mylist = map (+1) [1,2,3] -- it's not clear that this is recursive
07:09:54 <davidhouse> yes.
07:10:05 <palomer> which combinators do you need for primitive recursion?
07:10:29 <jethr0_> primitive recursive: 1) the constant function 0, 2) the successor function, 3) projection (selects one of its arguments). then a) composition of prim. rec. functions, 
07:10:53 <jethr0_> and b) primitive recursion which is hard to explain, but easy to understand :)
07:12:04 <palomer> so flip, zero and const should do it
07:12:09 <Cale> Basically, the primitive recursive functions are those which can be computed only using loops of a predetermined size.
07:12:45 <palomer> or, rather, flip, Zero, Succ and const
07:12:51 <Cale> (determined before entering the loop)
07:13:22 <Cale> palomer: what about the actual recursion?
07:13:28 <int-e> palomer: using church numerals?
07:13:50 <Cale> oh, right, perhaps with church numerals...
07:14:09 <jethr0_> church numerals /= peano numbers?
07:14:34 <palomer> church numerals are a lambda calculitic representation of the peano numbers
07:14:38 <jethr0_> k
07:14:43 <jips> argh, it's a label, not a text entry
07:14:52 <jethr0_> "calculitic" :)
07:14:55 <palomer> and what can you do with the constant function 0?
07:14:59 <integral> peano just set down axioms for some random objects.  You get to pick the objects, Peano gives you the rules
07:15:22 <jethr0_> palomer: it's your zero :)
07:15:28 <palomer> can you compare with 0?
07:15:51 <jethr0_> if you can write a prim. recursive function to do it :)
07:16:13 <int-e> ok, how do you rule out   \x -> x (\f y -> succ y f (succ 0)) succ? (using church numerals)
07:16:17 <jethr0_> i don't think so, though
07:16:29 <palomer> jethr0_: how so?
07:16:45 <jethr0_> palomer: i meant with primitive recursion, or is that wrong
07:17:18 <palomer> ok, write a function which returns one thing when passed 0 and something else when passed any other number
07:17:34 <jethr0_> true
07:18:30 * jethr0_ is always tired lately. must be the friggin' snow
07:18:43 <palomer> lack of sunshine
07:19:09 <Maddas> (Lack of caffeine :-)
07:19:58 <int-e> palomer: I think the problem isn't so much to find something powerful enough to represent all primitve recursive functions; the problem is to get the restrictions right, so that general recursive functions are ruled out.
07:20:22 <jips> me is always dead tired every day at 7 in the morning when he is woken up but he is never tired enough to go to sleep early at night
07:20:45 <jethr0_> jips: i know the feeling, and i'm sure many in this channel can agree :)
07:20:59 <palomer> it's the voices in my head
07:22:04 <int-e> jips: if an article that I've read recently is correct, that's because computer monitors and tvs have a high color temperature, fooling the body/brain into believing it's day and it should be awake.
07:22:17 <palomer> oh my, I have to start learning twelf
07:22:33 <jethr0_> int-e: that sounds interesting, and disturbing...
07:22:59 <jethr0_> doesn't go well with my constant tiredness though
07:23:18 <jips> int-e: that's not relevant in my situation since the periods i'm talking about i do not get close to a computer monitor or a tv
07:25:27 <int-e> jips: neon lights have the same problem. and apparently it takes a while to get ready to sleep. anyway, it sounded plausible.
07:26:09 <int-e> jips: but there were no references to scientific papers. *shrugs*
07:26:20 <jips> sounds like rubbish to me *shrugs*
07:26:49 <davidhouse> int-e, where did you read it?
07:27:27 <int-e> davidhouse: some newspaper.
07:30:13 <Maddas> I'd think that light in general 'fools' the body/brain into believing one should be awake. At least for me, that's why I prefer to sleep when it's dark...
07:32:38 <davidhouse> i'd postulate your body can't make you not tired just because you're staring at a TV screen.
07:32:59 <davidhouse> if you need sleep, you need sleep. staring at a bright screen doesn't change that.
07:33:06 <Maddas> davidhouse: It does change it.
07:33:12 <Maddas> davidhouse: e.g. http://www.news.harvard.edu/gazette/2006/02.09/01-blue.html
07:33:37 <Maddas> davidhouse: Using bright light to make yourself feel more 'awake' is at least to me nothing uncommon
07:34:24 <davidhouse> no, of course.
07:34:25 <Maddas> (Proper lighthing also has a strong effect on how well I can concentrate for longer periods of time)
07:35:31 <Maddas> Some people also just have a biological rhythm that's slightly out of sync with the 24h day, leading to going to bed late but then being tired in the morning :-)
07:36:29 <ihope_> Maddas: me!
07:36:38 <Maddas> ihope_: Not to be meant as an excuse :-)
07:36:57 <ihope_> Aww...
07:37:15 <Maddas> It's never that easy, is it ;-)
07:39:30 <ihope_> Say... does anybody know the Spanish for "blah blah blah"?
07:39:50 <sili_> blaho
07:40:10 <ihope_> :-P
07:40:55 <ihope_> What if the Spanish speakers did that to us? We'd have to call cats gats and kittens gatits!
07:43:26 <tuomov> over here it's dark all the time in wintertime, and light all the time on summertime..
07:43:58 <ihope_> Do you speak Polish there?
07:43:59 <tuomov> can't quite sync on it
07:44:02 <davidhouse> tuomov: where's "here"?
07:44:06 <tuomov> .fi
07:44:14 <davidhouse> nland?
07:44:17 <tuomov> yep
07:44:22 <davidhouse> nice.
07:44:36 <davidhouse> there seem to be quite a few skandinavian haskellians.
07:51:39 <jips> anyone familiar with cheetah template?
07:51:56 <Maddas> davidhouse: Hm, there seem to have been studies on the particular effect of TV exposure at night and its effect on melatonin production, finding a significant effect.
07:52:20 * Maddas wanders off again :-)
07:52:21 <davidhouse> interesting.
07:52:36 <Maddas> Indeed.
08:20:36 <xz> is there some way to read floating point numbers ? read "2.5" generates a parse error just using the read in the Prelude...
08:21:00 <xz> i'd love to turn the number into a fraction too
08:21:06 <xz> (aka a Rational)
08:21:29 <astrolabe> > show (read (2.5::Float))
08:21:30 <lambdabot> Couldn't match `String' against `Float'
08:21:39 <astrolabe> > show (read ("2.5"::Float))
08:21:40 <lambdabot> Couldn't match `Float' against `[Char]'
08:22:01 <astrolabe> > show (read ("2.5")::Float)
08:22:02 <lambdabot> "2.5"
08:22:07 <astrolabe> hooray
08:22:34 <astrolabe> 1+(read 2.5)::float
08:22:40 <astrolabe> > 1+(read 2.5)::float
08:22:41 <lambdabot>  add (Read float) to the expected type of an expression
08:23:20 <astrolabe> hmmm
08:23:32 <astrolabe> > 1+(read "2.5")::float
08:23:33 <lambdabot>  add (Read float) to the expected type of an expression
08:23:51 <astrolabe> > 1+(read "2.5")::Float
08:23:52 <lambdabot> 3.5
08:23:59 <astrolabe> It's getting late
08:24:14 <astrolabe> xz: Do you follow?
08:24:24 <palomer> has anyone actually used read in their code?
08:24:35 <astrolabe> sure
08:24:43 <palomer> for what?
08:24:43 <xz> astrolabe: thanks
08:24:47 <xz> palomer: yes
08:25:18 <astrolabe> for converting strings to numbers
08:26:20 <int-e> > (reads :: ReadS Int) "1a"
08:26:21 <lambdabot> [(1,"a")]
08:26:37 <palomer> there are functions to convert strings to number
08:26:38 <int-e> I've used that a few times as part of handwritten parsers.
08:27:53 <astrolabe> @hoogle approxRational
08:27:54 <lambdabot> Data.Ratio.approxRational :: RealFrac a => a -> a -> Rational
08:28:24 <xz> astrolabe: Float is not a RealFrac is it?
08:28:42 <xz> astrolabe: i'm looking at toRational, but it dosen't want to turn 0.1 into 1/10
08:29:00 <xz> astrolabe: (it turns into something much more complicated)
08:29:18 <xz> palomer: yes there are... like read!
08:30:18 <astrolabe> @hoogle toRational
08:30:18 <lambdabot> Prelude.toRational :: Real a => a -> Rational
08:30:38 <astrolabe> > toRational 0.1
08:30:39 <lambdabot> 3602879701896397%36028797018963968
08:31:10 <xz> 5%10
08:32:02 <xz> i don't know how to get lambdabot to show it, but 5%10 gets simplified automatically to 1%2
08:32:07 <astrolabe> > Data.Ratio.approxRational (toRational 0.1) 0.001
08:32:08 <lambdabot> 1%10
08:32:42 <xz> astrolabe: hmm can that be set as a default somehow? 
08:32:55 <xz> astrolabe: within a program at least
08:34:04 <astrolabe> xz: myToRational = \x -> Data.Ratio.approxRational (toRational x) 0.000001
08:34:18 <xz> astrolabe: hehe yes ok
08:34:23 <xz> astrolabe: thanks =)
08:55:17 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
08:55:17 --- topic: set by sylvan on [Fri Mar 03 08:35:02 2006]
08:55:17 --- names: list (clog dcoutts_ resiak Sonarman eno viblo bwolf jelmer shapr` spamsch ulfdoz Nioate Beelsebob Khisanth xerox Sysop_fb mornfall Excedrin Spark stesch sellout Wallbraker jmicheal tennin waern_ esap araujo cmeme ex_nor joelk olliej_ genneth kosmikus Si\Un1 juhp earthy aleator JohnMeacham dany2k nibro marcellus)
11:17:05 <lennart> hello
11:20:19 <EL1> How active a community does Haskell have?
11:21:05 <mauke> about 2
11:24:23 <vincenz> woo
11:24:30 <vincenz> I just looked at the first SICP lecture on my ipod
11:27:09 <sethk> EL1, with you, one
11:39:41 <cookoo> what's SICP?
11:40:10 <Lemmih> EL1: It's very active.
11:40:31 <ncalexan> cookoo: Structure and Interpretation of Computer Programs, Sussman and another whom I forget.
11:41:44 <ncalexan> @where sicp
11:41:45 <lambdabot> I know nothing about sicp.
11:45:47 <adu> > [1, 3...]
11:45:48 <lambdabot>  parse error on input `]'
11:45:59 <adu> > [1, 3, ...]
11:46:00 <lambdabot>  parse error on input `...'
11:46:03 <ncalexan> > [1,3..]
11:46:04 <lambdabot> [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,
11:46:04 <lambdabot> 53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,
11:46:04 <lambdabot> 101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,
11:46:04 <lambdabot> 137,139,141,143,145,147,149,151,153,155,157,159,161,163,165,167,169,171,
11:46:04 <lambdabot> 173,175,177,179,181,183,185,187,189,191,193,195,197,199,201,203,205,207,
11:46:06 <lambdabot> [24 @more lines]
11:46:08 <ncalexan> Just two dots.
11:46:14 <adu> oh thanx
11:46:20 <ncalexan> And no trailing comma, which I personally don't like.
11:46:35 <adu> hehe ok
11:47:06 <adu> ncalexan: i really like haskell so far, but i'm trying to learn it as well as i know other languages
11:47:22 <ncalexan> adu: what other languages are those?
11:48:04 <adu> Scheme, C/C++, Java, Perl, Python, and Mathematica
11:48:33 <adu> my biggest problem is understanding the type system
11:48:36 <ncalexan> Do you find Mathematica and Haskell similar?  I certainly do.
11:48:49 <ncalexan> And I think everyone finds the type system confusing, at least at first.
11:48:55 <adu> i don't know haskell well enough, but i certainly find Mathematica and Lisp similar
11:49:17 <ncalexan> Yes, you can see lisp / scheme hiding behind that awful Mathematica syntax :)
11:49:25 <adu> :)
11:50:10 <Cale> Mathematica has a way more scary evaluation mechanism than Haskell
11:50:54 <adu> but like the whole Array / List / Tuple thing is a little confusing, and the distinction between Rational, Ratio, Real, Fractional, Floating, RealFrac, RealFloat, i don't understand
11:50:54 <ncalexan> Cale: that I believe.
11:51:25 <Cale> type Rational = Ratio Integer
11:51:38 <Cale> The others are classes
11:51:39 <ncalexan> A/L/T is confusing.  The Num classes... it's a high level solution to a difficult problem.
11:52:23 <Cale> What's confusing about the first 3?
11:52:57 <adu> well, List and Tuple i get, but i'm not sure what functionality is provided by Array that you can't do with List and Tuple
11:53:07 <Cale> Arrays provide O(1) access to elements
11:53:24 <adu> Cale: i thought Tuple provided that
11:53:45 <Cale> they do, but have you ever tried a 1000x1000 tuple? :)
11:54:15 <Cale> Arrays are homogeneous in element type as well
11:54:15 <adu> do you haveto declare it like (,,,,,,,,,,,,,,,,,,,,,,) or something?
11:54:27 <Cale> yeah
11:54:27 <adu> oh ic
11:54:33 <int-e> there's no operation to get the i-th element of a tuple, where i is a variable.
11:54:38 <adu> so their more like O(1) lists
11:54:40 <Cale> that too
11:54:57 <Cale> Arrays and lists are pretty different in their own ways too, but yeah
11:55:19 <Cale> You hardly ever use tuples larger than pairs
11:55:29 <Cale> maybe a triple from time to time
11:55:30 <adu> ic
11:55:33 <ncalexan> Cale: I think the Array interface is pretty confusing *compared to the list/typle interface* and compared to array access in a standard imperative language.
11:55:39 <ncalexan> s/typle/tuple/
11:55:48 <Cale> ncalexan: oh, that's probably true
11:55:55 <ncalexan> No syntax support really makes things rocky... the horrid import clashes...
11:56:00 <ncalexan> The explicit types.
11:56:02 <Cale> There are a lot of kinds of arrays here too.
11:56:09 <ncalexan> True that :)
11:56:16 <ncalexan> Bulat is working on this area, though.
11:56:27 <sethk> I don't find arrays difficult.
11:56:36 <adu> like would you ever use a tuple for a structure you didn't want a datatype for?
11:56:37 <Cale> Plain Arrays, Diff Arrays, Unboxed arrays, Mutable arrays
11:57:01 <ncalexan> adu: sure... (index, element) is pretty common.  (key, value), too.
11:57:44 <adu> ncalexan: like would database records be expressed as a tuple? or would there be a Haskell Class for them?
11:57:55 <Cale> (zip [0..] xs) followed by a filter on the indices is common
11:58:22 <ncalexan> adu: I think usually a type (probably a named record) would be best.
11:58:25 <Cale> It depends. You could construct various record types for each table.
11:58:36 <ncalexan> something like data Row = Row { name :: String, ... }
11:58:44 <Cale> There's not a lot of benefit to larger tuples.
11:58:58 <Cale> (over custom datatypes)
11:59:08 <adu> ok
11:59:13 <Cale> Pairs are nice because there are general functions which use them
11:59:16 <Cale> like zip
11:59:23 <ncalexan> I would go farther: any tuple larger than 3 is almost certainly too complex.
11:59:30 <adu> lol
11:59:34 <Cale> yeah, I'd agree
11:59:41 <ncalexan> (I'm aware I can be beaten to death for making that statement.)
11:59:45 <adu> the RDF philosophy would certainly agree
12:00:15 <adu> the only fundamental datatye in RDF is the triple
12:00:30 <ncalexan> Rich Document Format?
12:00:47 <adu> Resource Description Framework (from W3C)
12:01:41 <adu> its the W3C XML format for metadata that expresses everything in terms of (subject, predicate, object)
12:01:55 <ncalexan> Hmm.
12:01:57 <adu> i think its a very elegant model
12:02:14 <ncalexan> I really couldn't say one way or the other.  Anyway, it's dinner time... happy hacking.
12:02:31 <adu> :)
12:04:04 <Cale> adu: Here's an in-depth tutorial on the array types available in GHC: http://www.haskell.org/haskellwiki/Arrays
12:04:37 <adu> thanks
12:08:31 <Cale> Arrays are really like arrays from any other language apart from some additional flexibility (that probably seems confusing at first). Lists are more like loops :)
12:08:41 <SimonRC> Is there convinient type for an infinite map?
12:09:16 <Cale> Function types?
12:09:24 <SimonRC> I provide a function or infinite [(,)]-list, and I get better-than-O(N) access time.
12:09:44 <SimonRC> Would be good for memoizing fibb
12:10:11 <SimonRC> Or, in my case, caching line-of-sight data.
12:10:14 <Cale> I suppose you could do some kind of infinite binary search tree if you were really clever about its construction.
12:11:38 <SimonRC> Yeah, that sort of thing.
12:13:12 <adu> ooo i like the sound of STPP
12:13:21 <SimonRC> Maybe a list of Maps of (key,value) pairs: The first containing key 1, then next keys 2-3, the next keys 4-7, then 8-15, 16-31, 32-63
12:13:39 <SimonRC> O(log n) access time.
12:13:52 <SimonRC> but only for natural numbers :-(
12:14:03 <SimonRC> and not 0
12:14:57 <adu> what does the ST stand for in STArray?
12:15:03 <Cale> State Thread
12:15:20 <adu> oh
12:15:23 <Cale> ST is a monad which is somewhat like IO without the actual IO :)
12:15:36 <Cale> It gives you mutable cells and arrays
12:15:53 <Cale> but there's a function which can extract a pure result at the end
12:16:04 <adu> so IOArray and STArray are not really different?
12:16:18 <Cale> not really, just a different monad involved.
12:17:32 <Cale> and they're both MArray types, so you use them the same way
12:18:19 <adu> i don't see any documentation on MArray
12:18:20 <SimonRC> and there is provided a function of type (ST foo -> foo), but no (respectable) function of type (IO foo -> foo)
12:19:00 <SimonRC> adu: "Data.Array.MArray"
12:19:11 <adu> oh
12:20:17 <lennart> good evening fellow haskellites
12:21:29 <SimonRC> What is "forall" good for?  I have never had to use it.
12:21:46 <SimonRC> And I have written some quite complicated types.
12:21:50 <Cale> SimonRC: well, it's implicitly in front of all your types
12:22:06 <lennart> and you don't often need nested foralls
12:22:15 <SimonRC> Ah, like skolemisation.
12:22:22 <Cale> If you write  f :: (a -> b) -> [a] -> [b], you really mean f :: forall a b. (a -> b) -> [a] -> [b]
12:22:48 <adu> so whats the difference between Array and IArray?
12:22:50 <sethk> Cale, indeed, that's why I still don't quite understand why you sometimes have to use it explicitly
12:22:53 <Cale> foralls occuring deeper in types are a way of insisting on polymorphism
12:23:04 <lennart> SimonRC: forall can be like an existential, but also like a universal.  like if you want a polymorhpic field in a record
12:23:10 <Cale> adu: Array is a concrete type, IArray is an interface
12:23:21 <Cale> (a class)
12:23:44 <adu> oh
12:23:46 <adu> ok
12:23:59 <adu> so STArray and IOArrat are also classes, not types?
12:24:00 <Cale> For example, if I write  f :: (forall a. [a] -> [a]) -> [a] -> [a]
12:24:12 <Cale> or even
12:24:25 <Cale> For example, if I write  f :: (forall a. [a] -> [a]) -> String -> String
12:24:48 <Cale> then I know that the function I get in the first parameter can only influence the overall list structure
12:24:53 <Cale> and not affect the elements
12:24:59 <Cale> since it's polymorphic
12:25:07 <Cale> adu: nope, they're types
12:25:09 <SimonRC> lennart: I hope that, by that, you don't mean that you can have: data Foo = Foo (forall a. a), and then create: [Foo 1, Foo 'a'].
12:25:18 <Cale> IArray and MArray are the classes.
12:25:24 <Cale> (and Ix)
12:25:38 <adu> so are classes like abstract types?
12:25:44 <Cale> Somewhat
12:25:46 <lennart> SimonRC: Well, that's one thing you can do. 
12:25:53 <SimonRC> eek!
12:25:58 <Cale> They're like predicates which hold when functionality is present.
12:26:12 <adu> can you instantiate a class to get a value?
12:26:22 <lennart> SimonRC: But I was thinking of data Foo = Foo { fun :: forall a . a->a->a }
12:26:35 <Cale> SimonRC: actually, that's not quite right
12:26:52 <Cale> SimonRC: the only thing you can pass to your Foo is bottom
12:26:55 <SimonRC> lennart: surely taht breaks type safety?
12:27:03 <SimonRC> Cale: oh, why?
12:27:13 <Cale> since it's the only thing of type forall a. a
12:27:20 <Cale> However, you can do:
12:27:28 <lennart> SimonRC: you need to move the forall
12:27:29 <Cale> data Foo = forall a. Foo a
12:27:33 <SimonRC> lennart: see my earlier utterance, with the list that had "different" types that were the "same" type.
12:27:35 <Cale> this is different
12:28:18 <adu> oooh, a class is a meta-type
12:28:22 <adu> ic
12:28:23 <lennart> And now you can have [Foo 1, Foo 'a']  and it's perfectly safe
12:28:23 <Cale> here, you can apply Foo to any value (but it kind of throws it away, since you don't have the type of that value anymore, and hence can't use it for anything)
12:28:27 <SimonRC> Cale: Not a constructor: `forall'
12:28:33 <Cale> SimonRC: -fglasgow-exts
12:28:46 <adu> so a value is an instance of a type and a type is an instance of a class
12:28:56 <Cale> adu: sort of :)
12:29:02 <adu> sort of?!?
12:29:02 <lennart> But there's nothing you can do to the elements of that list, except pass them around
12:29:12 <Cale> at least, you can think of it that way for one-parameter typeclasses
12:29:34 <Cale> the same way that you can think of a unary predicate on a set as a set itself.
12:29:44 <adu> so classes are like functions that take types as parameters?
12:29:50 <Cale> Relations
12:30:15 <Cale> sometimes functions -- that's what functional dependencies are about
12:30:35 <adu> i'm confused
12:30:42 <Cale> and wherever the relation holds, there is some functionality present
12:31:13 <lennart> adu: just think of it the way you stated it for now.
12:31:23 <adu> lennart: heh ok
12:31:57 <Cale> You could, for example, have a class VectorSpace f v where scalarMultiply :: f -> v -> v ; ...
12:32:50 <Cale> You're looking at the array classes, so perhaps I should use one of them as an example
12:32:56 <adu> so "instance VectorSpace Real" would still be a class?
12:33:14 <Cale> well, you'd need another type parameter
12:33:19 <adu> but "instance VectorSpace Real [Real]" would be a type?
12:33:30 <lennart> If Real is a type
12:33:35 <Cale> it would be something true or false
12:33:36 <adu> its not?!?
12:33:44 <Cale> Real isn't a type
12:33:48 <Cale> Float and Double are types
12:33:57 <adu> ok then Float
12:34:09 <adu> i'm still confused about the dozens of numeric types
12:34:10 <SimonRC> How I see it (roughly): A values has a type.  A variables has a type that matches the type of its value.  A type may be the instance of zero or more classes.  Classes are rather like, say, Java interfaces, in that they say what you can calculate of, for, or with a type, but nothing about how it should be calculated.
12:34:16 <lennart> standard Haskell doesn't come with real numbers, only floating point
12:34:24 <Cale> Here's another example
12:34:26 <SimonRC> adu: they're slightly messy.
12:34:28 <Cale> IArray a e
12:35:06 <SimonRC> That's a class.
12:35:10 <Cale> There is an instance of IArray a e if a is an immutable array type capable of holding elements of type e
12:35:23 <adu> ok
12:35:35 <Cale> So IArray is like a predicate that tells you when that interface is present.
12:35:44 <adu> ok
12:36:31 * SimonRC goes
12:36:41 <adu> SimonRC: have a good one
12:37:01 <Cale> It's a little more general than Java interfaces
12:37:21 <Cale> but it can be used similarly in a lot of cases
12:38:28 <adu> i'm interested in arrays for matrix manipulation
12:40:05 <adu> matrices are used in my tetration code, and I'd like to try implementing my tetration code in Haskell
12:40:28 <adu> if not for usefulness, then for learning
12:41:58 <vincenz> what is tetration?
12:42:17 <int-e> hmm. my best haskell code for multiplying 2 200x200 matrices (with Int elements, using (ST)UArray) is still a factor of 20 slower than the corresponding C version.
12:42:36 <int-e> (both using the naive O(n^3) algorithm)
12:42:59 <adu> vincenz: http://tetration.itgo.com
12:43:26 <adu> thats my website, it should give you somewhat of an introduction, as well as links to other tetration websites
12:43:41 <adu> in short, tetration is iterated exponentiation
12:44:53 <adu> int-e: the extent to which i use matrices is finding the matrix inverse to solve a system of equations
12:46:21 <adu> but since the vector b in Ax=b that i'm solving with respect to is [1, 0, 0...] i only need the first column of the inverse matrix for my purposes
12:50:40 <int-e> adu: just for reference, here's that code (it won't be of immediate use for you I suppose): http://paste.lisp.org/display/17514
12:50:53 <adu> thanx
12:52:11 <adu> int-e: but if you ever find a super-fast inverse matrix algorithm, let me know :)
12:52:14 <int-e> one think I learned is that the code for the Ix instance for (Int, Int) does not get inlined.
12:52:24 <int-e> think -> thing
12:52:34 <adu> as in faster than Gaussian elimination
12:53:17 <adu> inlined as in compiled in-place rather than by function-call?
12:53:46 <int-e> (the code for the Ix instance for Int, on the other hand, does get inlined)
12:53:46 <int-e> yes
12:54:07 <int-e> this is bad because passing a pair to a function involves creating a new thunk on the heap for it.
12:54:08 <adu> hm
12:54:21 <adu> thunk?
12:54:33 <adu> chunk?
12:55:51 <int-e> hmm, potentially unevaluated item on the heap. I wonder where that term comes from
12:57:32 <dons> algol 68, iirc.
12:58:55 <ncalexan> Interestingly enough, in some old Windows book I was reading, with the Hungarian dongles at the front it was like type-handle-to-unknown :)
13:03:55 <dons> int-e have you checked the matrix code on the shootout? you might get some hints there for fast array code.
13:04:38 <dons> also, spj wrote a mail on (int,Int) Ixs at one pont. let me find it.
13:05:43 <int-e> dons: hmm, there's matrix code there? no I haven't.
13:07:03 <int-e> dons: you mean the spectral entry?
13:10:39 <ncalexan> @hoogle getArgs
13:10:40 <lambdabot> System.Environment.getArgs :: IO [String]
13:10:40 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [
13:10:40 <lambdabot> String])
13:18:57 <dons> it must be said that matrix stuff is pretty hard for some reason. getting it really fast needs tsome real effort. here's SPJ's mail btw: http://www.cse.unsw.edu.au/~dons/tmp/loop.txt 
13:19:28 <int-e> dons: is there an unsafe version of ! ?
13:19:55 <dons> yep, it's called unsafeRead :)
13:20:22 <dons> you want to ensure that it is always used. so be really careful that your rule is actually firing
13:21:03 <dons> and then follow the usual things: strictness, check the Core is unboxed, float out subexpressions
13:21:18 <dons> more on the GHC-specific part of the Performance page on the wiki.
13:22:28 <int-e> dons: I think unsafeAt was what I need (the IArray accessor)
13:40:47 <int-e> dons: hmm, rewrote the code to use unsafeWrite and unsafeAt instead of that rule, and a 'flat' UArray; it's down to 0.42 seconds.
13:41:00 <int-e> (from 0.60)
13:44:16 <dons> cool :)
13:53:32 <int-e> and at least the inner loop is nicely unboxed and built from primops. it does, however, still deconstruct UArray constructors, if I read that correctly. hmm.
14:01:17 <int-e> (code at http://paste.lisp.org/display/17513#1 -- I annotated the wrong paste)
14:03:12 <adu> i think i'm beginning to understand my frustration with Haskell
14:03:26 <ncalexan> Which is?
14:03:27 <Cale> what is it?
14:03:34 <ncalexan> hehe... great minds.
14:04:06 <adu> The language itself makes sense while the standard Prelude doesn't
14:04:23 <Cale> completely off-topic, this guy is insane: http://www.xanga.com/zackkim -- he plays two amplified guitars at the same time by tapping the strings
14:04:48 <Cale> adu: the standard prelude was better in Haskell 1.4 if you ask me
14:05:10 <adu> Cale : one of my dad's friends does finger-picking like that
14:05:56 <adu> Cale : i want to design a different base library
14:06:06 <Cale> go for it :)
14:06:22 <adu> i'll called 'Postlude' :)
14:06:26 <Cale> heh
14:06:37 <ncalexan> I'd call it Interlude, or Qualude.
14:06:38 <Cale> I'm probably going to work out a new numeric hierarchy
14:06:47 <ncalexan> Cale: oh, God, please.
14:07:03 <ncalexan> But Jerzy had a lot of one done... it never really caught on.
14:07:14 <adu> Cale: i'll sync my 'Postlude' with whatever you figure out :)
14:07:32 <Cale> adu: look at the Haskell 1.4 Prelude too
14:07:49 <adu> where is it?
14:08:26 <Cale> http://haskell.org/definition/haskell-report-1.4.ps.gz
14:08:48 <Cale> page 82
14:09:13 <Cale> much is the same, but much is also different
14:09:21 <adu> theres just too much
14:09:33 <Cale> note:  map :: (Functor f) => (a -> b) -> (f a -> f b)
14:09:37 <adu> there should be 1 exponentiation operator (not 3)
14:09:50 <Cale> I actually agree with having 3 exponentiation operators
14:09:57 <ncalexan> adu: no, the  1 idea causes tons of trouble.
14:10:18 <Cale> mathematically it corresponds to the various definitions of exponentiation
14:10:24 <adu> and there should be 2 numeric classes (Real, Integral)
14:10:33 <adu> with any number of subtypes
14:10:38 <Cale> That also doesn't quite make sense
14:10:45 <adu> really?
14:11:10 <Cale> how do you implement, oh, floatRadix for Rationals?
14:11:28 <dancor> are there polynomial algorithms for parsing affix grammars
14:11:32 <Cale> or even the frig functions
14:11:34 <Cale> trig*
14:12:05 <adu> hmm
14:12:11 <Cale> The names of most of the current classes are terrible though.
14:12:30 <Cale> Real is particularly poorly named
14:12:38 <adu> heh
14:12:59 <Cale> The only member of Real is toRational
14:13:08 <dancor> also, is there any way to use two state monads in one function?
14:13:10 <Cale> which the real numbers, if they were in Haskell, would never support
14:13:26 <Cale> dancor: hmm, well, yes :)
14:13:43 <Cale> dancor: by state transforming a state monad
14:13:50 <dancor> Cale: how do you mark the return type
14:14:14 <dancor> Cale: i have to look up state transforming
14:14:28 <Cale> Like, you can work in the monad  StateT s1 (State s)
14:14:38 <ncalexan> Cale: can you implement MonadState s1 m, and MonadState s2 m?  I should think you can.
14:14:53 <Cale> ncalexan: actually, you can't due to the functional dependency
14:15:06 <ncalexan> Mmm, point.
14:15:30 <Cale> however, you can just lift get
14:15:35 <adu> Cale: but don'e (^), (^^) both correspond to nonnegative, integer exponents respectively, which are pretty similar?
14:15:50 <Cale> adu: they're not pretty similar
14:16:00 <dancor> Cale: i'm making a scrabble game.  is it reasonable that i want to do the board and bag and racks with state monads
14:16:04 <Cale> adu: natural exponents work when the base is in any ring
14:16:15 <Cale> adu: for negative exponents, you need a field
14:16:22 <adu> oh
14:16:25 <Cale> dancor: yes, quite
14:16:28 <dancor> hot
14:16:55 <Cale> dancor: I recommend constructing your own monad in fact :)
14:17:14 <Cale> (only via newtyping an existing one)
14:17:40 <Cale> You'd be interested in my monadic Sudoku solver which uses a monad to keep track of the state of the board.
14:17:43 <dancor> one monad for all the things?
14:18:02 <dancor> Cale: yeah, i'm no good with monads
14:18:04 <Cale> well, one monad (or monad transformer) for keeping track of the game state
14:18:16 <Cale> http://www.haskell.org/hawiki/SudokuSolver
14:19:34 <int-e> cool. 0.1 seconds; working solely with STUArrays helps (converted from UArray using unsafeThawSTUArray)
14:20:20 <Cale> int-e: you're mutating the array?
14:20:26 <int-e> Cale: no
14:20:30 <adu> Cale: actualy you only need an invertible ring, not a field
14:20:34 <dancor> oh i also wanted to ask what you guys do when you want to manipulate one value in a list
14:20:42 <Cale> adu: that is a field
14:20:58 <Cale> adu: a field is a ring where every nonzero element is invertible
14:21:05 <dancor> reconstructing a whole new list seems really slow, there must be a better way
14:21:17 <Cale> dancor: don't use a list :)
14:21:19 <adu> Cale: oh, hehe, thats good to know
14:21:28 <dancor> Cale: sure, but what :)
14:21:41 <Cale> dancor: perhaps an array, or a Map
14:21:44 <ncalexan> Cale: a field is also commutative... division ring, my man :)
14:21:54 <Cale> oh, sorry, yes
14:22:09 <int-e> Cale, dons, adu: http://pastebin.com/584538
14:22:36 <int-e> Cale: it's just that accessing STUArrays in ST code turns out to be faster than accassing UArrays in pure code.
14:23:07 <Cale> I could claim that I was using that odd convention where fields aren't commutative by default. :)
14:23:20 <Cale> (not many people use that one though)
14:24:14 <adu> int-e do you think you'll ever add an inverse-matrix function to your code?
14:24:16 <dancor> we always said divisor ring
14:24:24 <Cale> division ring, yeah
14:24:34 <dancor> err maybe that :)
14:25:05 <Cale> so I suppose negative exponents work for those, but still not general rings.
14:25:18 <Cale> (another term for division ring is skew field)
14:25:24 <int-e> Cale: and I've checked the (GHC) implementation of unsafeThawArray - for UArrays, it's really just a conversion (which is good).
14:25:54 <Cale> int-e: ah, okay, so you're doing the conversion anyway
14:26:02 <Cale> int-e: that makes sense then :)
14:27:06 <Cale> I'd find it quite interesting if you could take an algorithm which constructs and uses a pure unboxed immutable array, and convert it to one using an STUArray trivially (without mutation) and get better performance
14:28:03 <int-e> well, it only shows how hard it is to predict GHC's optimizer (and library implementation)
14:28:23 <int-e> anyway. I'm happy with the code now, it's within a factor of 5 of C :)
14:29:11 <Cale> if it's true, then someone ought to write a bunch of RULES pragmas for translating array code
14:29:28 <Cale> (or actually add an optimisation step properly)
14:29:57 <int-e> adu: hmm. not anytime soon.
14:30:01 <ncalexan> Why would you get any speed up?  The issue is always single-threaded use, and their's no reason that could be optimised away in ST any different that outside of it.
14:30:10 <ncalexan> s/their's/there's/
14:31:57 * int-e suspects that GHC contains an awful lot of magic for ST.
14:32:59 <ncalexan> But fundamentally, there's no single-threaded use analysis in any haskell implementation (that I know of)
14:45:45 <int-e> ncalexan: anyway, the main effect in the Core code is that the deconstruction of the UArray constructor gets floated out of the inner loop.
14:46:19 <ncalexan> Sorry, I was thinking of Cale's pure -> ST monad speed improvement.
14:46:55 <int-e> ncalexan: well, for my code I did exactly that. In this case, it did help.
14:48:33 <int-e> ncalexan: I'm not convinced that it works in general.
14:48:41 <ncalexan> Fair enough, I'm not saying it didn't.  But is ... I was just about to say as much.
14:48:58 <ncalexan> In general, it's single threaded use that is the win.
14:53:05 <dancor> hmm.  i want an array monad where i can change a single index quickly.  as far as i can tell, i can't do that with Array.  how can i?
14:53:32 <int-e> ST(U)Array
14:53:37 <ncalexan> That might be best in the ST monad.
14:53:38 <int-e> and ST monad
15:10:17 * int-e glares at his code that just works for square matrices (grr.)
15:16:56 <int-e> (the m?i functions multiply by the wrong dimension each)
15:17:31 <Cale> dancor: If you want to modify an immutable array at some indices you just use the // operator with a list of (index,value) pairs to update. If you are doing lots of updates, you want a mutable array type, since this pure operation normally will copy the array.
15:17:49 <Cale> (i.e. an ST(U)Array as was suggested)
15:17:57 <Cale> There is something in between though
15:18:32 <Cale> DiffArray and DiffUArray give the immutable interface, but have O(1) update (and O(1) lookup if used in a single threaded fashion)
15:18:46 <Cale> er
15:19:02 <Cale> arr // xs is an O(length xs) operation rather
15:19:26 <Cale> and in particular, not dependent on the array size
15:21:11 <Cale> as you make updates though, older versions of the array get slower to read
15:21:32 <Cale> and updating an old version of the array will always do a complete copy
15:21:43 <dancor> hmm
15:23:09 <dancor> right, you can't avoid a total copy except with a monadic type of course
15:23:23 <dons> int-e, so how fast is the code compared to the C version now?
15:25:18 <int-e> dons: factor 3 to 4.
15:25:19 <xz> is there a way in haskell to reduce the precision of Floats or Doubles... or at least truncate them for output purposes ?
15:25:34 <dons> printf
15:25:47 <xz> there's a printf in haskell ? ok i'll look..
15:25:54 <int-e> dons: which is good, given that the 'loops' that GHC generates are awful by design.
15:26:15 <Cale> dancor: well, in that case, you're doing something which you couldn't even do with a mutable array -- you're reaching back to a past version and modifying it instead
15:27:35 <dancor> oh.  any array manipulation does a full copy hm?
15:27:47 <Cale> dancor: the way that mutating diff arrays works is that you mutate the current array directly, but rewrite the previous array reference so that it has a list of reverse updates to the current array
15:28:07 <Cale> this happens behind the scenes
15:28:58 <araujo> Hello.
15:30:01 <dons> xz, Text.Printf> printf "%0.6f\n" (pi :: Double) :: String  
15:30:13 <dons> "3.141593\n"
15:30:14 <dons>     
15:30:18 <xz> dons: yep thanks
15:30:59 <dons> int-e, awful loops? do you mean, not-quite-C-loops? or something else?
15:31:30 <Cale> To perhaps clarify that, evaluating (arr // xs) will look up the array that arr refers to, update it with the changes as per xs, and give back a DiffArray, which is really a reference to the same array that arr used to point to, while silently modifying arr to point to a list of reverse updates and a pointer to the current array
15:32:08 <dons> xz, btw, if you are need to gte good performance out of your Doubles, use -fexcess-precision when compiling the code, it's around 2x faster.
15:32:46 <Cale> so if you do a lookup on arr afterward, if the index that you lookup is in the reverse update list, you get the value from that list, otherwise, it looks it up in the current version
15:33:28 <int-e> dons: loops by indirect jumps would be my guess. (factor 3 now, I converted the matrix initialization)
15:33:35 <Cale> xz: also look in the 'Numeric' library
15:34:06 <Cale> > showGFloat (Just 6) pi
15:34:07 <lambdabot>  add an instance declaration for (Show (String -> String))
15:34:08 <Cale> > showGFloat (Just 6) pi ""
15:34:09 <lambdabot> "3.141593"
15:34:14 <Cale> > showGFloat (Just 2) pi ""
15:34:15 <lambdabot> "3.14"
15:34:25 <Cale> > showGFloat (Just 2) pi "xyz"
15:34:26 <lambdabot> "3.14xyz"
15:34:48 <xz> Cale: oooh that's better
15:35:08 <Cale> there's also showFFloat and showEFloat
15:35:34 <Cale> > floatToDigits 10 pi
15:35:35 <lambdabot> ([3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3],1)
15:35:54 <Cale> > floatToDigits 16 pi
15:35:55 <lambdabot> ([3,2,4,3,15,6,10,8,8,8,5,10,3],1)
15:36:46 <dons> int-e, you might get some benefit cranking up gcc flags too, e.g. -optc-O3 -optc-ffast-math
15:37:15 <int-e> dons: there's no FP math involved.
15:37:50 <dons> ok. then maybe just -optc-O3 :)
15:38:21 <int-e> that makes no noticable difference
15:41:27 <dons> ok. sometimes it does, sometimes it doesn't. 
15:47:53 <dancor> compiled ghc is much faster than hugs right
15:51:17 <Cale> dancor: yes
15:51:52 * int-e wonders how to get at the output of the evil mangler.
15:52:27 <Cale> hmm, request assembly at all?
15:52:52 <Cale> -S I think
15:53:16 <int-e> looks good, thanks
15:53:25 <Cale> I'd hope that's mangled assembly anyway :)
15:53:54 <int-e> ok, the mangler optimizes some indirect jumps away
15:54:15 <dons> -keep-tmp-files will dump the .raw-s and .s files into /tmp
15:54:17 <int-e>  movl $s3L2_info, %eax; jmp *%eax becomes jmp s3L2_info
15:54:50 <dons> ah, interesting. I didn't know the mangler did that.
15:59:02 <int-e> but the compiler doesn't recognize the loop as such; a loop of 7 instructions, two memory accesses (C), one conditional jump becomes a loop of 28 instructions, 15 memory accesses, two conditional jumps.
15:59:54 <dons> what happens when compiled via -fasm ?
16:00:00 <int-e> hmm.
16:02:06 <dons> the'res been some interesting mail this week on the future of -fasm, lots of interesting things to do.
16:02:31 <ncalexan> Oh really?  Which list?
16:05:51 <int-e> dons: hmm, that produces a really nice inner loop, but the program still runs slower than the code produced via c
16:06:13 <int-e> dons: err, forget that. looking at the wrong file.
16:07:21 <dons> ncalexan, hmm, haskell-cafe I think. Bulat was asking questions about C--. Also, "let's beat jhc" and the two Simon's responded
16:07:43 <int-e> dons: -fasm generates a loop built with indirect jumps, without the optimization that the mangler does when compiling via C. the assembler code looks pretty much the same otherwise.
16:10:02 <int-e> dons: it's 25 instructions, 12 memory accesses, 2 conditional and one indirect jump
16:10:46 <int-e> dons: the indirect jump is constant; I don't know if AthlonXP (what I'm using here) predicts those or not.
16:12:48 <sethk> hey, all, I've got a weird one.  at least it looks weird to me.
16:13:13 <sethk> this works:
16:13:24 <sethk> sock <- connectTo "192.168.200.254" (PortNumber (fromIntegral (4 + 32345) ) )
16:13:29 <sethk> this does not:
16:13:41 <sethk>  sock <- connectTo "192.168.200.254" (PortNumber (fromIntegral (octet + 32345) ) )
16:13:47 <sethk> octet is from here:
16:13:56 <sethk> (octet :: Word8) <- return (read (args !! 0))
16:14:06 <Cale> eek
16:14:18 <sethk> a type thing, I guess, but what?
16:14:21 <Cale> 32345 will be interpreted as a Word8
16:14:30 <Cale> since it's being added to one
16:14:32 <sethk> oh
16:14:37 <sethk> I guess that would be a bad thing  :)
16:14:53 <sethk> I want to constrain it to be a word 8 in the other context.
16:15:03 <sethk> I guess I'll have to do a fromIntegral and assign it to a bigger variable
16:15:09 <int-e> why don't you use  PortNumber (fromIntegral octet + 32345)?
16:15:17 <Cale> (fromIntegral octet) + 32345
16:15:21 <Cale> yeah
16:15:30 <sethk> ok
16:15:47 <sethk> I'll still have all these leftover assumptions floating around in my brain
16:15:57 <sethk> such as, conversions go to the larger type, always
16:16:17 <sethk> here conversions go to the most explicitly specified type I guess
16:16:45 <ncalexan> More or less.
16:17:00 <Cale> integer literals like 32345 have fromInteger applied to them automatically
16:17:11 <Cale> @type 32345
16:17:12 <lambdabot> forall t. (Num t) => t
16:17:17 <ncalexan> @type fromInteger
16:17:17 <lambdabot> forall a. (Num a) => Integer -> a
16:18:10 <Cale> and so if you write that in your source, the integer literal will be constructed at whatever numeric type it needs to be, and if nothing is specified, it will default to Integer (for convenience)
16:18:39 <Cale> (you can change that with the default keyword)
16:18:49 <sethk> that I understood.  it was the mixed type behavior that confused me.
16:19:07 <Cale> but it's not even really mixed type :)
16:19:08 <int-e> well, you can't mix types
16:19:39 <Cale> since the type of 32345 in that context is actually inferred statically as Word8
16:19:53 <sethk> Cale, well, that's just semantics, since a word8 cannot hold that value.
16:20:12 <Cale> sure it can, sort of :)
16:20:33 <Cale> Modulo 2^8 :)
16:20:47 <int-e> don't you love rings :)
16:21:11 <Cale> it just happens that that number is equal to 89
16:21:47 <Cale> and 32601, for that matter :)
16:22:29 <sethk> Cale, the program at the other end of the connection didn't understand that part.  :)
16:22:36 <Cale> hehe
16:23:08 <Cale> yeah, you'd have been warned of that, but the fromIntegral was converting the Word8 result to whatever it was that's needed
16:25:28 <Cale> So fromIntegral is a little dangerous, which is why it's actually sort of good that it has a long name
16:26:01 <sethk> Cale, I've found that I need to use it with the PortNumber constructor, even though the type (as you were saying) of a literal should be ok.
16:27:33 <Cale> well, data PortID = Service String | PortNumber PortNumber | UnixSocket String
16:28:02 <Cale> note that PortNumber is both the name of a type and a data constructor in a different type.
16:28:33 <sethk> Cale, I know, I hate when they do that
16:29:07 <Cale> yeah, usually they at least make it a data constructor of the same type, which isn't as confusing
16:31:15 <sethk> I fail to see the need to be confusing _at all_
16:32:28 <Cale> Well, the two things can't really be confused because they're in totally different namespaces. You couldn't possibly want to use the data constructor inside of a type.
16:34:04 <Cale> But the confusing part is if the data constructor has the same name as a type constructor, but constructs a value of a different type, as you might expect it to create a value of the type of the same name as it
16:35:14 <sethk> Cale, that's true
16:35:34 <sethk> Cale, I've said this before, but even though they are distinct namespaces, using the same name makes the language much harder to learn
16:36:11 <sethk> Cale, even if you don't think that's as important as I think it is, what do you gain by reusing the name?
16:36:17 <Cale> perhaps a little, but you get used to it. You wouldn't want it to happen in the first example of a data declaration though :)
16:36:54 <Cale> well, if you do that often, you automatically know what type it is that various data constructors construct
16:37:31 <sethk> it's extremely confusing to someone trying to learn the language and figure out just what each type of "thing" in the line is.
16:37:42 <Cale> If I have a data constructor called Dollars :: Integer -> Dollars, that's somewhat nice.
16:37:42 <sethk> the libraries are really the only examples
16:37:52 <sethk> not worth the confusion
16:38:05 <sethk> in fact, not nice
16:38:11 <Cale> why?
16:38:19 <sethk> it suggests something is the same as something else, but it is Not the same
16:38:48 <sethk> any other convention would be just as easy to remember if followed consistently
16:39:12 <Cale> Well, they don't occur in the same place at all. You really have two languages in Haskell - the value language and the type language, and connecting things up by parallels is sometimes nice.
16:39:25 <sethk> to me that's all cost and no benefit
16:39:45 <Cale> what convention would use use?
16:39:47 <Cale> you*
16:39:52 <sethk> you don't see it because you know immediately exactly what grammatical part everything is
16:40:01 <sethk> but someone less familiar with the language doesn't.
16:40:05 <sethk> how about toDollars?
16:40:18 <sethk> which is used in the library in other contexts, to and from
16:40:23 <Cale> ToDollars perhaps
16:40:32 <sethk> yes, right
16:40:37 <sethk> toDollars would be a function
16:40:54 <Cale> it looks a little odd when pattern matching
16:41:01 <Cale> f (ToDollars x) = ...
16:41:21 <sethk> it looks correct.  It says "I'm not a type, I'm a constructor"
16:41:40 <Cale> but a type can't occur there anyway
16:42:32 <Cale> you already know that since it's the parameter to a function, it's not a type
16:42:59 <sethk> if you are 100% familiar with the language, then yes.
16:43:11 <sethk> but if you are at the stage of figuring out what type of construct goes where ...
16:43:16 <Cale> even if you're 2% familiar with the language
16:43:35 <sethk> remember also that in languages like C++ every type is automatically a constructor
16:43:52 <Cale> hm? what kind of constructor?
16:44:12 <sethk> the default constructor for the class, the copy constructor
16:44:19 <Cale> oh, for class types
16:44:29 <Cale> I was thinking of 'int' :)
16:44:50 <sethk> well, you can use abominations such as  ((int)1.234)
16:45:28 <mauke> int(1.234)
16:45:35 <mauke> i = int();
16:45:38 <sethk> mauke, right, that too
16:45:55 <Cale> oh, so they make that valid?
16:46:16 <Cale> I've never seen that used.
16:46:45 <mauke> struct anytype { template<typename T> operator T() { return T(); } };
16:47:10 <sethk> Cale, yes, in c++ that's valid
16:47:17 <Cale> okay, but still
16:48:27 <Cale> If, as a beginner Haskell programmer, I look at something like f x = x + 1, even as a beginner, I'm not going to be asking if x is a type.
16:49:12 <sethk> no, but that's a function argument, it isn't a constructor
16:49:20 <sethk> it's the constructors, vs. types, that we are talking about
16:49:43 <Cale> Well, x is part of the type language too -- it's a type variable
16:49:59 <Cale> why don't people confuse type variables with value variables?
16:50:48 <sethk> Cale, I'm not sure that they don't
16:52:49 <int-e> . o O ( typedef int foo; struct foo { foo foo; }; struct foo foo; foo bar; foo main() { foo.foo = bar; return bar; } )
16:53:21 <Cale> hehe
16:53:31 <mauke> missing foo: goto foo;
16:53:42 <int-e> right.
16:54:10 <sethk> don't want to leave out goto foo  :)
16:54:42 <Cale> okay, so even though the names of types overlap with names of functions in C++, why isn't it a problem there?
16:55:06 <sethk> I never said it's not a problem there
16:55:12 <sethk> I don't like that either
16:55:16 <int-e> (at least struct foo and typedef int foo do clash in C++)
16:55:33 <mauke> but struct stat and stat() don't
16:56:57 <int-e> anyway. I think the fact that the meaning of names can change with their context is something every programmer has to learn sooner or later.
16:58:18 <int-e> unless you want you programs to $look &like %perl @or *Basic?
16:59:05 <Cale> int-e: the meaning of names somehow doesn't change with their context in perl? :)
16:59:37 <sethk> of course the meaning of names change with context in other languages.  I don't see why that's relevant.
16:59:45 <int-e> Cale: that's not what I said. :)
16:59:48 <Cale> hehe
16:59:51 <sethk> all I said was that, in that one particular situation, it is confusing to a new user.
16:59:51 <Cale> I know :)
17:00:09 <Cale> I just don't get why this specifically is a problem
17:01:14 <Cale> sure, in general, such things may be confusing the first time you see them, but that's just part of learning any language, and why is this case any worse than any other case where it occurs?
17:01:38 <sethk> because that construct doesn't occur in other languages
17:01:53 <sethk> so it is already something new, and adding confusion to it doesn't help.
17:01:59 <Cale> same with most of the constructs in Haskell :)
17:02:08 <ncalexan> True that.
17:02:20 <Cale> I don't see why people think that languages should be at all similar
17:02:37 <sethk> that's not the idea either
17:02:41 * ValarQ neither
17:02:41 <int-e> and at that, look like C :(
17:02:57 <sethk> I'm talking _only_ about the impact a particular coding style has on someone learning the language.
17:03:43 * ValarQ mumbles something about higher than C leveled languages with C syntax
17:03:55 <Cale> If anything, this is somewhat helpful, in that if they were confused about it, they'll have to stop being confused about it pretty quickly.
17:04:39 <sethk> Cale, that's inside out thinking.  you aren't in the same situation I'm in.  In my situation, when people say "it's too confusing" and give up, I have to deal with their C code.
17:05:32 <Cale> They'll say something like "hey, what is that type name doing there?" and then try it with Integer or something, and it won't work, and then they'll either ask, or figure it out that it's not the name of a type that goes there.
17:05:49 <sethk> no, they'll say "I give up"
17:05:55 <Cale> also, if they were reading a tutorial, it's something they'd be told
17:06:06 <sethk> we aren't talking about the language here at all.  we are talking about the choice of utterly arbitrary names
17:06:13 <ncalexan> sethk: I know surprisingly few people like that.
17:06:30 <sethk> ncalexan, do you work in a commercial environment?
17:06:32 <Cale> Yeah, I've never seen anyone give up from that
17:06:46 <sethk> I have, absolutely
17:06:52 <Cale> Usually they ask, and you tell them, and then they're like 'okay, that makes sense'
17:08:04 <Cale> but the only people I've heard even ask about it are a few people who wander in here doing the Quadruple assignment question from YAHT, and they usually figure out what's going on pretty quickly.
17:08:33 <Cale> and that's really not the same, since it's about the syntax of data declarations
17:08:35 <sethk> that's in an academic environment.  we don't do assignments, or questions, we write things and deliver them
17:08:39 <ncalexan> sethk: no, I'm a graduate student... but that means I work with a lot of undergrads who will be in that environment.  Most of them are pig-headed, like us.
17:08:57 <ncalexan> You think an assignment is different from a deliverable?
17:09:03 <Cale> sethk: well, people who are learning a new language are in an academic environment of their own creation :)
17:09:49 <Cale> the fact that you're learning something usually means that you'll read about it, and ask questions, and experiment just the same
17:10:08 <ncalexan> Rather than rant and rave and new languages / barriers to entry, why don't we consider alternatives?
17:10:25 <ncalexan> Having types in caps and identifiers lowercase has worked out well for haskell.
17:10:35 <sethk> ncalexan, yes, that's true
17:10:44 <ncalexan> We could have type constructors distinguished, perhaps by _.
17:11:02 <sethk> that's much farther than I suggested going.
17:11:02 <ncalexan> But personally, I think there are enough one constructor types to justify data X = X ...
17:11:05 <int-e> that's awkward
17:11:33 <int-e> (using _)
17:11:34 <ncalexan> Oh, I'm not suggesting _Blah.  But if it works once, why not keep trying it?  Then the question is just, what identifier?
17:11:40 <Cale> I think that if there's a problem at all, it must be in the tutorials
17:11:46 <ValarQ> syntax highlightning might do the trick :)
17:12:07 <Cale> and just by fixing the tutorials, this problem goes away
17:12:28 <ncalexan> I would even say that's a 'bite once' problem.  After the first time, it's clear from context.
17:12:35 <Cale> since it's really a non-issue once you understand the distinction between a data constructor and a type constructor
17:13:07 <sethk> it's an arbitrary choice of names.  I think a different choice is better.
17:13:09 <Cale> just explaining that difference somewhere in your tutorial should be enough to make the issue go away
17:13:25 <ncalexan> sethk: I asked for suggestions once; I'm asking again.
17:13:49 <ncalexan> Or are you referring to 'data constructor' vs 'type constructor'?
17:13:55 <Cale> ncalexan: earlier, he suggested that we use data constructors prefixed with To
17:13:56 <ncalexan> Those are pretty well established in the literature.
17:13:59 <sethk> I sometimes use X and X'
17:14:18 <ncalexan> Oh, like ToStateT?  That's pretty rough.
17:14:19 <sethk> that preserves the relationship without using the same name twice
17:14:47 <ncalexan> Prime means something to mathematicians, though -- both derivative and derivate.
17:14:59 <ncalexan> I think that's stretching the 'derivate' idea.
17:15:02 <sethk> ncalexan, it's used frequently in examples that have nothing to do with that
17:15:15 <ncalexan> Plus, you'd have data Dir = N' | S'... that's pretty rough.
17:15:37 <sethk> why?
17:15:47 <sethk> but that is not the case
17:15:58 <sethk> I'm _only_ suggesting that the same name should not be used twice
17:16:09 <sethk> Dir = N | S doesn't use the same name twice
17:16:30 <ncalexan> Oh, I see.  You don't really want to differentiate the name spaces, you want them to be the same namespace.
17:16:59 <Cale> I think that merging the namespaces is potentially even more confusing.
17:17:45 * int-e finds giving single constructor types constructors the same name as the type a natural choice.
17:17:53 <sethk> I didn't suggest merging the name spaces
17:17:54 <sethk> no
17:17:55 <Cale> yeah, me too
17:18:08 <Cale> sethk: then what are you suggesting?
17:18:10 <sethk> I'm saying that, voluntarily, we can decide to not use the same name on both sides of the definition
17:18:22 <sethk> not as a language feature, but as a coding style choice
17:18:24 <Cale> that'll never work :)
17:18:42 <ncalexan> I think you're in the position to do that :)
17:18:45 <sethk> there is absolutely nothing in the language that prefers Foo = Foo over Foo = Bar
17:18:55 <sethk> of course, I do it in my own code.
17:19:06 <sethk> I'm talking about the library code being confusing to newcomers
17:19:09 <Cale> Any rule which is not enforced by the compiler will be broken.
17:19:19 <int-e> yes, but when I then think about Foo, I have to figure out whether I chose Bar or wanted to be funny and chose Xyzzy ;)
17:19:48 <sethk> int-e, well, that's true ... :)
17:19:55 <sethk> Cale, sure, including the rule X = X
17:20:04 <sethk> but that is no reason to not prefer a good coding style
17:20:05 <Cale> hm?
17:20:15 <sethk> there is no rule here to be broken, or not broken
17:20:23 <Cale> X = X is usually enforced by the compiler :)
17:20:23 <int-e> I don't think that 'good coding style' can be objectively defined.
17:20:45 <sethk> int-e, no, probably not, but certain things are grenerally thought to be bad
17:20:45 <Cale> I suppose you could write an instance of Eq, where elements were not equal to themselves
17:20:54 <Cale> and in fact there is such an instance in the prelude :)
17:20:58 <sethk> yes, you could, but please don't
17:21:08 <int-e> Cale: () ?
17:21:08 <sethk> Cale, you see?  that has to be confusing  :)
17:21:15 <Cale> int-e: nope
17:21:17 <int-e> woops.
17:21:24 <sethk> I'm just saying don't add confusion when you don't need to
17:21:28 <int-e> that was stupid.
17:21:30 <Cale> > (0/0) == (0/0)
17:21:31 <lambdabot> False
17:21:41 <sethk> why's that false?
17:21:52 <int-e> because IEEE defined it that way
17:21:53 <Cale> Because the IEEE says so.
17:21:54 <sethk> because 0/0 isn't equal to anything?
17:22:01 <Cale> > 0/0
17:22:02 <sjanssen> > 0/0
17:22:02 <lambdabot> NaN
17:22:03 <lambdabot> NaN
17:22:10 <int-e> it's NaN and NaN does not compare equal to anything
17:22:24 <sethk> ok, that makes a certain amount of sense
17:22:33 <int-e> (== Not a Number)
17:22:42 <sethk> in some languages both == and /= are false for the same left and right sides
17:23:00 <int-e> > (0/0) /= (0/0)
17:23:01 <lambdabot> True
17:23:07 <Cale> In some languages the answer changes as you repeat the test.
17:23:14 <ncalexan> That's even better :0
17:23:42 <Cale> x++ == y--
17:24:29 <sjanssen> > compare (0/0) (0/0)
17:24:30 <lambdabot> GT
17:24:38 <Cale> heh
17:24:41 <int-e> *a++ == *b++ <-- actually quite common.
17:24:54 <Cale> oh, nice example
17:27:50 <sethk> int-e, yes, that's classic C
17:28:02 <sethk> in fact that example is in the first or second chapter of k&r
17:28:20 <sethk> and a really easy way to introduce hard to find bugs
17:28:40 <sjanssen> sethk: hard to find bugs are also classic C
17:28:43 <sethk> because people frequently mean (*a)++
17:28:44 <ncalexan> Aside: even better with STL iterators... who knows what's happening there.
17:29:01 <sethk> unfortunately I've had to figure that out a few times.  :)
17:29:14 <int-e> Operator precedence in C is fun.
17:30:00 <int-e> do you know, off the top of your head, how *a->b is parsed? (I know, but only because I had that problem two days ago)
17:30:27 <int-e> (it's not a dangerous problem though; if you get it wrong, the code won't compile)
17:31:07 <sethk> int-e, the * binds first, I think
17:31:15 <sethk> int-e, but I certainly wouldn't bet money on it.
17:31:21 <int-e> oh, and then there's the   2["funny"]  nastyness.
17:31:26 <int-e> it's *(a->b)
17:31:38 <sethk> good think I didn't bet any money  :)
17:32:02 <int-e> 2["funny"] is the same as *(2+"funny") and thus the same as "funny"[2].
17:32:32 <Cale> that's the first trick you learn when obfuscating C code :)
17:34:40 <ayrnieu> also the last interesting trick :-(
17:34:45 <sethk> Tomorrow I get to add ioctl's to a device driver.  I could start now, but I think I'll sleep instead.
17:34:49 <ayrnieu> It's all downhill from here, folks!
17:35:44 <int-e> Duff's device is another interesting C trick.
17:36:01 <ncalexan> int-e: which is?
17:36:16 <int-e> a way to unroll loops in C. http://www.lysator.liu.se/c/duffs-device.html
17:36:51 <lispy> i'd rather drink duff beer than use duffs device
17:37:16 <int-e> Heh. I don't think I've ever actually used it myself.
17:41:16 <lispy> quake used it
17:46:07 <ncalexan> Fascinating that the article has a raw % operator, which is almost always very slow... that can, of course, be bitmasked.
17:46:32 <dons> Cale, did you ever work out a way to unroll loops using case () of _ ? I remember we  talked about it last week sometime
17:46:39 <dons> using duff's device
17:46:51 <int-e> ncalexan: it's executed exactly once in that code.
17:47:06 <Cale> dons: are you sure it was me?
17:47:12 <dons> ah, maybe not htne.
17:47:23 <dons> maybe I had a dream that we wanted to implement duff's device using case
17:47:27 <Cale> hehe
17:47:43 <dons> sounds like the kind of fever dreams I sometimes have..
17:54:01 <ncalexan> g'night, all.
19:40:11 <mauke> @index select
19:40:12 <lambdabot> Text.Html
19:44:09 <mauke> @index poll
19:44:10 <lambdabot> bzzt
19:44:27 <xerox> @docs Data.Posix
19:44:28 <lambdabot> Data.Posix not available
19:44:29 <xerox> Maybe?
19:44:36 <xerox> @docs System.Posix
19:44:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.
19:44:37 <lambdabot> html
19:46:44 <mauke> it's not in System.Posix.IO
19:48:00 <xerox> :-\
19:50:38 <xerox> mauke: <http://www.nabble.com/standard-poll-select-interface-t1094766.html>
19:52:05 <xerox> Howdy nothingmuch.
20:47:21 <waern> hm.. where did the hIDE repo go?
20:52:46 <araujo> Good morning.
20:53:27 <jethr0> mornin'
20:57:51 <dancor> i'm making a scrabble game. i want to keep track of the state of the board and bag and racks with state monads.  should i use monad transformers to work with more than one of them in a function?
20:58:12 <dcoutts> waern, http://darcs.haskell.org/hIDE/
20:59:11 <dcoutts> waern, and you'd also need to build that all with ghc.hide and gtk2hs.hide from http://darcs.haskell.org/* too
21:01:48 <dancor> all the examples i can find of monad transformers act like it's only for when you need multiple different types of monads
21:02:09 <waern> dcoutts, I did that the last time I built it, it's just that scannedinavian is down
21:02:24 <waern> or dead or whatever
21:02:52 <dcoutts> waern, yes scannedinavian is no more
21:08:58 <waern> hmm.. I get an error message about GHC.init's first argument
21:09:04 <waern> when building hIDE
21:09:37 <dcoutts> waern, what's the message exactly?
21:11:09 <waern> src/Hide/CommonSense/Haskell.hs:56:28:
21:11:09 <waern>     Couldn't match `[String]' against `Maybe a'
21:11:09 <waern>       Expected type: [String]
21:11:09 <waern>       Inferred type: Maybe a
21:11:09 <waern>     In the application `Just libDir'
21:11:09 <waern>     In the first argument of `GHC.init', namely `(Just libDir)'
21:11:48 <waern> I'll have a look if ghc.hide has been updated
21:12:33 <dcoutts> waern, what ghc version are you using?
21:12:48 <dcoutts> the ghc.hide snapshot?
21:14:11 <waern> yep
21:24:20 <dcoutts> waern, well I guess you could try changing (Just libDir) to [libDir]
21:24:51 <waern> dcoutts, I'm looking at my repositories and it seems like I might have built ghc instead of ghc.hide actually :)
21:25:23 <dcoutts> waern, that would make sense, I didn't have any problems with compiling the stuff when I used ghc.hide
21:26:05 <waern> I remember I had to rebuild ghc.hide because I built it with the wrong version of Cabal, and then I probably built ghc by mistake
21:26:19 <dcoutts> waern, I installed ghc.hide into /usr/local such that it didn't override my normal ghc on the path, so then I had to change some of the build files to use "ghc-6.5" rather than just "ghc"
21:28:17 <jethr0> dancor: still there?
21:31:43 <dancor> yes
21:32:22 * shapr` boings
21:32:46 <dancor> perhaps i'm supposed to do like State ([a], [a]) where my first [a] is like the bag, and the second one the rack
21:33:22 <jethr0> dancor: i don't quite get your question, but you can put several values inside one state monad.
21:33:35 <dancor> ok
21:35:31 * jethr0 greets shapr and b0ings a little with him
21:35:43 <jethr0> shapr: been unicycling already today?
21:37:16 <dancor> i meant to unicycle tonight.  is there a haskell and unicycling correlation
21:37:23 <xerox> Unicycle!
21:38:25 <jethr0> dancor: i'm not sure, but i don't think there's a strong correlation there
21:43:37 <dancor> does it make more sense to wrap StateT around IO or vice versa?
21:43:45 <dcoutts> xerox, have you got a unicycle yet?
21:43:51 * dcoutts has to get his one fixed
21:44:01 <dancor> i don't unstand the difference
21:44:08 <dancor> understand
21:46:51 <jethr0> dancor: you're looking at somewhat advanced haskell "features" there. monad transformers are applied on monads, therefore you can't wrap IO around StateT (not so easily at least).
21:48:00 <jethr0> there is MonadIO though, which can wrap 
21:48:20 <jethr0> StateT. (plus, i have no idea what i'm talking about :)
21:48:43 <kowey> dancor: i've only recently started to use monad transformers - i don't know if this helps, but
21:48:45 <dancor> heh
21:49:15 <kowey> i had a whole lot of code written using State, and one day I found that I needed to combine this with another monad, say IO
21:49:27 <dancor> advanced indeed.  but i guess i need it since i have to update State stuff based on user input.
21:49:42 <kowey> using StateT allowed me to do this without changing any of my previous code, except maybe for type signature
21:49:51 <dancor> kowey: cool
21:50:12 <dancor> kowey: yes type sigs seem to explode somehow
21:50:28 <kowey> type MyState = StateT, helps
21:50:36 <kowey> writing little helper lifts help
21:50:39 <kowey> s
21:51:17 <kowey> here: i've mashed up Jeff Newbern's tutorial in a wikibook, maybe it'll help
21:51:18 <kowey> http://en.wikibooks.org/wiki/Programming:Haskell_monad_transformers
21:51:50 <jethr0> dancor: the "only" thing state monad helps with is abolishing some function parameters. you can do everything without them that you can do with them...
21:52:51 <xerox> kowey: did you read springschool95.ps?
21:52:55 <dancor> jethr0: yes i've tried that.  i'm writing a scrabble game.  it gets to be quite a mess..
21:53:04 <kowey> xerox: no
21:53:07 * kowey looks
21:53:21 <xerox> kowey: err, wait, wrong paper.
21:53:58 <xerox> 'Deriving Backtracking Monad Transformers"
21:53:59 <dancor> (bd''', rk', bag'') <- ...
21:54:08 <xerox> It has a nice explanation on transformers et all.
21:54:26 <kowey> ooh, thanks, xerox!
21:54:40 * kowey is also trying to write the arrows module
21:54:42 <jethr0> dancor: partially you will still need that kind of "expression" with state transformers: "(bd, rk, bag) <- get"
21:54:50 <kowey> (but i got distracted with darcs stuff)
21:57:35 <dancor> jethr0: true, but not counting 's is worth it, is the hope
21:58:15 <dancor> not having to count, i should say
21:59:08 <jethr0> dancor: hmm, count what? could you lisppaste your code?
22:06:30 <jethr0> bbl
22:09:00 <dancor> the pre-state code?
22:11:17 <jethr0> if you like
22:13:14 <dancor> nothing happens when i submit to paste.lisp.org
22:15:27 <dancor> http://www.rafb.net/paste/results/Enx7K113.html
22:16:16 <dancor> so far it just prints the board and player racks and only lets players 'pass'
22:16:46 <dancor> also it probably shouldn't be using lists but STArrays or something else i don't understand yet
22:18:07 <jethr0> hmm, it's a lot of code
22:19:03 <jethr0> you have a board, a bag, randomly selected letters on racks and want to put a continuous horizontal or vertical line of letters onto the board, right?
22:19:25 <dancor> yes
22:19:49 <dancor> eventually i'll have a dictionary
22:19:55 <jethr0> i wonder if you couldn't derive the board from the moves, and just store the latter...
22:20:25 <dancor> i guess you could.
22:20:32 <MarcWeber> Why is getOne executed twice here? Doesn't haskell recognice these cases?  http://www.rafb.net/paste/results/zTnmqj89.html
22:20:35 <jethr0> i'm pretty sure there's a more concise solution, but it might be hard to find it :)
22:21:23 <dancor> well i'm new to all this
22:22:11 <jethr0> MarcWeber: hmm, i'm not sure about common subexpression capabilities of haskell implementations, but you could simple use "where" or "let" to make the sharing explicit
22:23:16 <MarcWeber> jethr0: So I should add the parameter file of afileread into that where clause.. let me try
22:23:55 <jethr0> huh? i was talking about "(:) (getOne text)  [(getOne text)]"
22:24:12 <MarcWeber> Have look at line 10
22:24:21 <jethr0> it's definitely not incorrect to have it execute twice
22:24:22 <MarcWeber> I've added the file parameter at that line
22:24:41 <MarcWeber> no it's not incorrect but want to know when it's executed twice
22:25:03 <MarcWeber> because that execution might be a huge calculation...
22:25:19 <jethr0> when you write it twice, it might get executed twice
22:25:38 <jethr0> write "areadFile = myreadFile file" to make the sharing explicit
22:25:52 <MarcWeber> in another language you would create a object, assign the parameter and having something like get= if not calculated yet then calculate else return last result..
22:26:20 <MarcWeber> Thats what I did. and then it got only executed once.
22:26:25 <jethr0> yes, in haskell you just don't need the "get" part.
22:27:04 <jethr0> or better, you don't need any of it, because once calculated lazy-evaluation caches the result automatically
22:27:35 <MarcWeber> then why is getOne executed twice if the result is cached?
22:28:00 <jethr0> "assign the parameter". if you do that haskell guarantees caching
22:28:13 <Lemmih> MarcWeber: Performing aggressive CSE can result in space leaks.
22:28:15 <MarcWeber> jethr0: I want to write some kind of make system.. and there I don't want to check over and over again wether a particualr target already exists..
22:28:17 <jethr0> if you just call the same function with equal params again, it won't necessarily
22:28:26 <MarcWeber> CSE?
22:28:40 <jethr0> common subexpressions
22:29:16 <Lemmih> Common sub-expression elimination.
22:30:41 <Lemmih> (ie. changing "[getOne text, getOne text]" to "let x = getOne text in [x,x]")
22:31:40 <wolverian> hm, can I tell haskell to memoize my function, or do I have to do it myself?
22:31:45 <MarcWeber> Imagine me wanting to know wether a file contains one line l. I need this information at different locations of my code. But I don't want my program to read that file over and over again. How to do this?
22:32:23 <Lemmih> MarcWeber: Cache the information.
22:32:30 <MarcWeber> wolverian: What do you mean? function and arguments thus result? or just a function pointer (type (..->c)  ) ?
22:32:46 <MarcWeber> Lemmih: Then i have to pass the cache aroung, right?
22:33:17 <wolverian> MarcWeber, I'm not sure what you mean with the latter.
22:33:18 <MarcWeber> And then there is no real different in using haskell or C? Both use a cache then
22:34:01 <MarcWeber> wolverian: let f=(\x->x+x) in f 2 then f is a memorization of x+x ..(?)
22:34:12 <wolverian> right
22:34:24 <wolverian> I just want to trivially optimise a recursive function
22:34:29 <wolverian> (for speed) 
22:34:36 <Lemmih> MarcWeber: Yes, of course. I doubt there are any Haskell implementation that automatically save closures that may or may not be used in the future. That would definitely be a one-way ticket to space-leaks.
22:34:41 <MarcWeber> Then I can't help you. I don't know haskell enough yet
22:34:53 <wolverian> MarcWeber, mmkay, thanks :)
22:35:22 <jethr0> Lemmih: stupid question, why would it space leak. ah, you mean because you never knew when to garbage collect the closures?
22:35:42 <jethr0> couldn't you just limit the time/operations before GC?
22:37:02 <MarcWeber> I read about closures yesterday in the "functional programming with python" essay.. Since then I knew why I had such much trouble understanding State monads..
22:37:16 <MarcWeber> I didn't knew closures
22:37:32 <jethr0> what do closures have to do with state monad?
22:38:07 <MarcWeber> There are some strange functions remembering other values.. which will be returned later.
22:38:24 <jethr0> huh?
22:38:53 <jethr0> state monads just make passing parameters easier/more transparent...
22:38:54 <MarcWeber> jethr0: In this sence http://de.wikipedia.org/wiki/Closure (2. code example )
22:39:45 <MarcWeber> This article is marked for rewriting because all examples are given in perl and one said they should have used haskell to show everything ..
22:39:53 <jethr0> the way i understand closures, they capture part of their surrounding environment...
22:40:54 <jethr0> > let a = 10 in let f x = x * a in f 4
22:40:55 <lambdabot> 40
22:41:03 <Lemmih> jethr0: You can't garbage collect data when it's still being referred to.
22:41:20 <jethr0> bad example :(
22:41:26 <jethr0> Lemmih: i didn't say one could :)
22:42:03 <MarcWeber> jethr0: You don't have to refer to 10 later on..
22:42:09 <Lemmih> jethr0: Then why would limiting the time before performing a GC help?
22:42:30 <MarcWeber> so the saved "environment" is 10 in the not to gargabe collected variable/function a
22:42:40 <jethr0> Lemmih: sorry, i was speaking about closures :). you're right, it would cause all kinds of problems.
22:43:13 <jethr0> MarcWeber: the example was bad. it's hard to make a simple deeply scoped example in haskell...
22:43:47 <MarcWeber> Do you have a link?
22:43:54 <MarcWeber> If not I don't mind either
22:44:31 <Lemmih> I thought the example was pretty goood.
22:44:39 <jethr0> MarcWeber: i'm not saying the wikipedia article was wrong..
22:44:51 <jethr0> Lemmih: yes, but it's nicer to visualize in scheme :)
22:45:25 <jethr0> it's nicer if the captured environment has gone out of scope and only survives through the closure
22:46:59 <jethr0> > let f x = \y -> x * y in let h = f 10 in h 4
22:47:00 <lambdabot> 40
22:47:21 <jethr0> stupid haskell, it makes things way too easy :)
22:47:28 <Lemmih> > (let a = 10; f x = x * a in f) 4
22:47:29 <lambdabot> 40
22:47:44 <jethr0> thx
22:47:55 <MarcWeber> jethr0: And i didn't say thay you've said it was wrong ;-) I tried to say they mentioned that that article might be incomplete as my knowledge is
22:48:16 <jethr0> MarcWeber: i don't have a link ready, sry
22:49:12 <jethr0> someone correct me if i'm wrong, but i think closures are pretty much defined by the fact that they are capturing bindings which may then go out of scope, but can still be used inside the closure
22:49:41 <MarcWeber> in your case its x, right?
22:49:48 <jethr0> so, if i'm using the binding "x" from an outer scope and return a function that uses "x". the function will work with "x"s value even if i can't see "x" directly anymore
22:50:04 <jyp> Lemmih: So, your version of haskell plugins work with standard Typeable class ?
22:50:38 <Lemmih> jyp: Yes, with a little hack.
22:50:46 <jethr0> MarcWeber: the closure is the thing that closes over the used bindings. most often (always?) it's a function because otherwise the result could have been calculated already
22:51:11 <Lemmih> (and that hack isn't even necessary in hIDE)
22:52:08 <jethr0> MarcWeber: in case you know/can read scheme: http://www.cs.uni.edu/~wallingf/teaching/154/sessions/session23.html#account
22:53:58 <jyp> Lemmih: that's cool... I agree with your saying AltData is evil :)
22:54:14 <jyp> Lemmih: is dons planning to integrate that hack in his version ?
22:54:57 <jyp> (A bit of a problem with darcs repos is that there is a point where when one no longer knows which one is the most official)
22:58:38 <Lemmih> jyp: I don't think so. The hack is pretty evil.
22:59:35 <jyp> So is it a matter of choosing between the lesser of two evils, or is there a clean way to get rid of it ?
23:00:23 <dons> moin
23:00:25 <jyp> I suppose the clean solution requires a bit of ghc hackery
23:00:29 <jyp> hey dons 
23:00:30 <Lemmih> One would have to change Data.Typeable.
23:00:55 <dons> we should kill off AltData. it'll have to be done before 6.6 comes out
23:01:10 * jyp rejoices :)
23:01:17 <dons> there's a clean way to fix it: patch the rts to store a shared Typeable representation
23:01:23 <Philippa> the changes'd be useful anyway though. Dons and I were talking about it a while back, though realistically the odds of my getting round to doing the GHC hacking stink
23:01:23 <dons> but , you know, that involves writing in C :}
23:02:03 <dons> SimonM wants it, I want it, Ralf Lammel wants it (so generics work in ghci), Lemmih wants it... maybe this code should get written :)
23:02:37 <Philippa> you can add me to the list of people who want it, too...
23:03:01 <jyp> The haskell world needs you, dons! :)
23:03:12 <jyp> Don't disappoint us! :)
23:03:30 <dons> and now Lemmih is publically bagging AltData on haskell@, so that's a lot of pressure :p
23:04:17 <Lemmih> heh (:
23:04:33 <dons> hehe
23:07:20 <jethr0> has it been done to call runState repeatedly to interleave state with IO or would one usually use StateT instead?
23:08:00 <Philippa> usually I'd use StateT or just pass it around by hand
23:09:14 <jethr0> yup, just as i thought. i'm trying a scrabble game for fun and i've got all these parameters like boardSize, rackSize, letterNum that i need, and then i also want to do IO to fetch user moves. would you use a StateT in that case?
23:09:58 <Philippa> tbh I'd be pretty tempted to use an IORef
23:10:15 <Philippa> but I'm not necessarily the most purely-minded of haskell coders
23:10:29 <jethr0> *brr*, but maybe it's the right way to go...
23:11:01 <dons> stick 'em in a monad over IO.
23:11:07 <dons> IORefs are easy but evil evil
23:11:25 <jethr0> "boardSize = unsafePerformIO $ newIORef 20" :))
23:11:32 <dons> they lower your @karma ;)
23:11:48 <jethr0> @karma jethr0
23:11:50 <lambdabot> You have a karma of 0
23:11:56 <jethr0> there's not much to lower then :)
23:12:17 <dons> hehe
23:12:25 <jethr0> dons: i'm by now pretty familiar with how programming in the small is done with haskell.
23:12:31 <Philippa> actually I find IORefs're a fairly sane way to manage it if you start to get a lot of state floating about. The really evil thing is when you have (unwrapped) IORefs floating about in the cells other IORefs refer to - otherwise you can trace what state's potentially modifiable pretty easily
23:12:53 <jethr0> but i'm still uncertain about modular programming. and looking at the bigger projects like yi, they scare me
23:12:56 <Philippa> (granted I'd rather use an STRef if reasonably applicable)
23:13:13 <jethr0> dons: do you have any pointers or examples how modular design in haskell would look like?
23:13:29 <Philippa> most of the modular stuff's fairly easy - if you've no better way to go, you can try bundling data structures up with their basic operations
23:13:50 <dons> at least the global variable kind of IORefs can lead to issues, since it's easy to write a module that looks safe from the outside, but can do referentially nasty things on the inside.
23:14:08 <Philippa> and then big, 'non-basic' operations might get their own module (for example, I tend to end up with a typechecker in its own module or even split up into several separate from where the type data structure's defined)
23:14:09 <dons> in the large, we really have monads for structuring, so they should be used for that, I think.
23:14:16 <jethr0> Philippa: hmm, but keeping invariants seems harder, doesn't it. and either using hundreds of records or a few huge ones, seems to be frowned upon
23:14:43 <dons> sometimes, just passing state as parameters is ok.
23:14:48 <Philippa> I like records, they're great when you realise you're going to find cause to add new fields to constructors and don't want all your code dependant on how many fields they have any more...
23:14:51 <Philippa> definitely
23:15:05 <jethr0> yup, i've come to a similar conclusion
23:15:05 <Philippa> I do that a lot for small worker threads, for example
23:15:40 <Philippa> you only really badly want a state monad if a) it's considerably more readable or b) you're going to be plumbing that state through a large enough quantity of code there's a serious possibility of mistakes
23:15:55 <jethr0> dons: how large are we talking when you refer to monads? you mean like using monads for framework kinda things?
23:16:00 <Philippa> (IMO it's a little different for Reader and Writer because they enforce additional invariants)
23:16:10 <Philippa> monads /are/ frameworks
23:16:11 <Philippa> really
23:16:24 <Philippa> they have their own semantics, they provide new capabilities...
23:16:36 <jethr0> yes, but if you're going to write KDE in haskell, would you really put the huge-scale things into a single monad each?
23:16:42 <jethr0> does that even always work?
23:17:01 <dons> you have separate monads, and some top level plumbing between them.
23:17:05 <Philippa> a lot of them would do, yes. And then a little top-level 'architectural' code showing how data flows between the code in different monads
23:17:06 <Philippa> right
23:17:26 <jethr0> hmm, interesting. i guess i should abstract more things as monads...
23:17:28 <Philippa> sometimes you have layered transformers and stuff like that too, at which point you've just reinvented the layer
23:17:53 <dons> works fine for really huge things, like ghc. and also for smaller things, like 2k loc interpreters, or 5k loc icfp entries jethr0.
23:17:54 <jethr0> btw, should one generally write transformers instead of monads?
23:18:20 <vincenz> ?
23:18:42 <jethr0> coz people always complain that i.e. parsec isn't a transformer and they'd like it so much to layer it on top of IO or whatever
23:18:45 <dons> jethr0, hmm, if you know in advance you need something ike  IO.
23:19:13 <Philippa> although even then you can write what's effectively a pre-parameterised transformer - a monad whose run function gives you an IO action, for example
23:19:27 <jethr0> i haven't quite understood the problem with transformers. does the problem of layering them have sth to do with crosscutting concerns? abstractly speaking?
23:19:35 <MarcWeber> jethr0: I'll try
23:19:49 <Philippa> jethr0: that kind of idea, yeah. You can use a stack of transformers to achieve AOP-like things
23:20:16 <jethr0> yes, but i read in some tutorial that some transformers/monads simply don't stack up naively
23:20:44 <Philippa> nor does AOP
23:21:07 <Philippa> all that's telling you is that sometimes there're interactions, and which way round things interact depends on the order in the transformer stack
23:21:09 <jethr0> right
23:21:38 <Philippa> StateT List gives you a state for each list entry, ListT State gives you one state shared by all. That kind of thing
23:21:55 <Philippa> the state-like transformers don't have interactions
23:22:21 <dons> @uptime
23:22:22 <lambdabot> uptime: 14 hours, 26 minutes and 25 seconds
23:22:29 <dons> oh, hmm. didn't spot that.
23:22:30 <vincenz> @karma
23:22:30 <lambdabot> You have a karma of 2
23:22:34 <dons> @localtime dons
23:22:45 <vincenz> @localtime vincenz
23:22:57 <dons> @bot !
23:22:58 <lambdabot> :)
23:23:09 <vincenz> @bot ?
23:23:10 <lambdabot> :)
23:23:13 <dons> @localtime #haskell
23:23:23 <vincenz> > reverse ":("
23:23:24 <dons> ah well. seems to work. not sure why 'dons' didn't respond
23:23:25 <lambdabot> "(:"
23:23:50 <dons> night!
23:25:07 <jethr0> Philippa: have you ever used ListT? i don't quite understand what that would be useful for. maybe so-called non-deterministic stuff...
23:25:21 <Philippa> that's exactly it, yeah
23:25:55 <Philippa> I've not had a good use case myself, but I could easily see it for all the usual search-type problems
23:26:01 <vincenz> ListT has the same use of List, no?
23:26:16 <Philippa> yep
23:26:22 <jethr0> yes, but you'd have to find a reason to stack it onto sth else
23:26:26 <vincenz> IO
23:27:01 <jethr0> yes...?
23:27:11 <vincenz> IO is always hte bottom monad
23:27:37 <jethr0> and in what case would you need to layer ListT instead of using simple lists?
23:28:03 <vincenz> in case your computation fails sometimes and not some other times and you want to combine those
23:28:04 <jethr0> i guess for weird backtracking stuff
23:28:38 <jethr0> yeah, i guess i'll have to get even better acquainted with monads. it's a neverending story *g*
23:28:42 <jethr0> bbl
23:29:39 <vincenz> one sicp lecture = nearly all my ipod battery
23:30:14 <Philippa> jethr0: suppose you have a stateful computation that branches with new states...
23:30:28 <Philippa> (and can't be arsed to pass the state around by hand)
23:31:18 <astrolabe> What should you consider when trying to work out whether to put code into a monad, or just use it naively?
23:31:48 <Philippa> "am I getting pissed off doing this by hand yet?", "am I going to end up needing to put it in some kind of monad later anyway?"
23:32:04 <Philippa> plus all the usual "is it more readable that way?" type stuff
23:32:16 <MarcWeber> jethr0: One thing i don't understand yet: When talking about closures enclosing environments: Do they copy it or do they enclose them? When copying a closure, do you copy the environment, too?
23:32:33 <Philippa> MarcWeber: depends on the language
23:32:49 <Philippa> copying is mostly an implementation detail in a pure language
23:32:59 <Philippa> in an impure one, it's a design decision
23:33:42 <vincenz> MarcWeber: in a pure one you'd most likely just pass around references to it
23:34:29 <Philippa> but then if you /implemented/ it in a pure language that probably looks much the same as copying anyway ;-)
23:34:29 <MarcWeber> wtf.. when talking about a closure this information is not enough to know how to use it... because the results may differ on implementation details.
23:34:50 <Philippa> MarcWeber: let's start from the top: which language are you worried about?
23:35:03 <Philippa> if you don't know which language you're working in then of course you don't have enough info :-)
23:35:18 <MarcWeber> But then there is no sense in talking about enclosing the old (beeng now out of scope) environment if it might be copy at that time..
23:35:30 <Philippa> sure there is
23:35:32 <vincenz> MarcWeber: not really
23:35:34 <vincenz> look:
23:35:39 <vincenz> in pseudo python
23:35:55 <vincenz> make_counter (x): return lambda(): x+=; return x
23:36:03 <Philippa> consider a haskell implementation of closures: that copy is *the same damn thing* as the environment at that point in time
23:36:16 <vincenz> everytime you call that make_counter you want to copy an environment with x
23:36:27 <Philippa> the copying or lack thereof really /is/ an implementation detail - and arguably one of the underlying haskell implementation
23:36:31 <vincenz> but once you pass the counter function around, you don't want to copy the environment anymore
23:36:40 <Philippa> you've no way of finding out if it's been copied or not, it's the same damn value
23:36:48 <vincenz> and it can't be modified
23:38:56 <MarcWeber> thx
23:46:34 <astrolabe> In this paper, they give 4 methods of composing monads: a general one, two special cases which are dual to each other, and the intersection of these duals.  I'm interested in how these 4 cases correpond to the standard monad transformers.
23:46:44 <astrolabe> http://citeseer.ist.psu.edu/jones93composing.html
23:49:57 <jethr0> thx a lot philippa, sry i have to go. but i'll be back later with more annoying questions :)
23:50:15 <Philippa> unfortunately I may not be around :-)
23:59:05 <MarcWeber> vincenz: Philippa That pseudo python counter example.. that can't be done in haskell, can it?
