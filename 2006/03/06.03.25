00:01:16 <Korollary> so how does cabal play with apt-get/rpm, etc.? Totally independent?
00:29:35 <sethk> dons, I wrote some code to do an xmodem upload today.  It more or less works.  So far I haven't had to beg for help with it.
00:29:40 <sethk> dons, so far  :)
00:30:02 <ValarQ> @seen Megzl
00:30:02 <lambdabot> I haven't seen Megzl.
01:05:44 <rasterfar> ski: kindly, thanks
01:08:41 <ski> rasfar : e.g. in haskell, a simple bifunctor class could be defined as
01:08:46 <ski> class BiFunctor f
01:08:48 <ski>   where
01:09:15 <ski>   bimap :: (a0 -> a1) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
01:09:43 <rasfar> oh
01:10:31 <ski> rasfar : in category theory, (given categories C0,C1,D) a bifunctor from C0 and C1 to D, is actually just a functor from C0 * C1 to D, where C0 * C1 is the product category of C0 and C1
01:11:14 <ski> in this haskell case, C0 = C1 = D = *, the category of haskell types (not general type constructors) and functions between them
01:11:24 <rasfar> okay, so it's not specifically about the hom(-,-)?
01:11:47 <ski> right
01:12:27 <rasfar> thanks.  i'm really green at this, so better think more about it...
01:12:38 <ski> actually, iirc, hom(-,-) would be a *di*functor, not a bifunctor
01:13:14 <ski> a difunctor from C0 and C1 to D is a bifunctor from C0^op and C1 to D is a functor from C0^op * C1 to D
01:13:40 <ski> C0^op is the opposite category of C0, with same objects, but morphisms goes in opposite directions
01:13:41 <rasfar> oh! so there's a distinction?  I saw ... yes.
01:13:53 <rasfar> yep
01:13:56 <ski> so, it is contravariant in first argument, instead of covariant
01:13:58 <ski> in haskell
01:14:03 <ski> class DiFunctor f
01:14:05 <ski>   where
01:14:19 <ski>   dimap :: (a1 -> a0) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
01:14:23 <ski> note that
01:14:31 <ski> instance BiFunctor (,)
01:14:32 <ski> instance BiFunctor Either
01:14:34 <ski> but
01:14:42 <ski> instance DiFunctor (->)
01:15:01 <rasfar> nice examples.
01:16:03 <ski> i think every type constructor which is instance of 'Arrow' can prolly be made an instance of 'DiFunctor'
01:16:34 <rasfar> it's really quite embarassing,but i need to study more to see why Hom(-,-) is contravariant in the first argument.
01:17:03 <rasfar> as for the Arrow's, yes, I was reading a paper about those -- that motivated my original question.
01:17:08 <ski> ok
01:17:14 <ski> anyway, gotta go, now
01:17:21 <rasfar> ya, thanks again.
01:17:23 * ski leaves
01:21:41 <neologism> @hoogle getArgs
01:21:41 <lambdabot> System.Environment.getArgs :: IO [String]
01:21:41 <lambdabot> Graphics.UI.GLUT.Initialization.getArgsAndInitialize :: IO (String, [String])
01:31:45 <neologism> uh.. I have [IO ()]... how do I use sequence on it?
01:36:05 <ValarQ> @type sequence
01:36:06 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
01:36:39 <neologism> I have this
01:36:39 <neologism> solveMazes mazes = sequence $ solveMazes mazes
01:36:39 <neologism>         where   solveMazes' :: [String] -> [IO ()]
01:36:59 <neologism> how do I print that [IO ()] ?
01:37:10 <davidhouse> you can't
01:37:13 <davidhouse> why would you want to?
01:37:18 <davidhouse> > ()
01:37:19 <lambdabot> ()
01:37:20 <Korollary> there's nothing to print anyway
01:37:30 <davidhouse> hmm... ignore that lambdabot query.
01:37:40 <neologism> ok.. I have [String], how do I putStrLn it?
01:37:53 <davidhouse> mapM_ putStrLn list
01:37:54 <Korollary> putStrLn $ show stuff
01:37:59 <Korollary> or "print stuff"
01:38:12 <davidhouse> you can show a list?
01:38:17 <davidhouse> > show [1..5]
01:38:18 <lambdabot> "[1,2,3,4,5]"
01:38:20 <Korollary> you can show a lot of things heh
01:38:21 <davidhouse> oh, funky.
01:38:27 <neologism> what exactly is mapM_ ?
01:38:30 <davidhouse> i'd still go with mapM_ putStrLn list
01:38:34 <davidhouse> @type mapM_
01:38:34 <lambdabot> forall (m :: * -> *) a b.
01:38:34 <lambdabot>    (Monad m) =>
01:38:34 <lambdabot>    (a -> m b) -> [a] -> m ()
01:38:42 <davidhouse> monadic map, throwing away the output.
01:38:44 <Korollary> mapM_ putStrLn is wrong
01:38:44 <davidhouse> @type mapM
01:38:45 <lambdabot> forall b (m :: * -> *) a.
01:38:45 <lambdabot>    (Monad m) =>
01:38:45 <lambdabot>    (a -> m b) -> [a] -> m [b]
01:38:59 <davidhouse> Korollary: why?
01:39:00 <neologism> mapM_ putStrLn works
01:39:07 <Korollary> it's going to generate a separate action for each element
01:39:07 <neologism> @type mapM
01:39:08 <lambdabot> forall b (m :: * -> *) a.
01:39:08 <lambdabot>    (Monad m) =>
01:39:08 <lambdabot>    (a -> m b) -> [a] -> m [b]
01:39:21 <sethk> all, System.Posix.IO.Fd is an instance of Integral.  doesn't that mean that I should be able to use (toInteger x)  when x is of type Fd?
01:39:23 <davidhouse> Korollary: and?
01:39:35 <neologism> Korollary: I want separate action for each element
01:39:44 <Korollary> why generate all those separate actions while you can print them all in one step
01:39:49 <davidhouse> why not?
01:39:57 <davidhouse> if you want each on a seperate line, why not?
01:40:18 <davidhouse> sethk: yep
01:40:38 <ValarQ> why not use an ordinary map then?
01:40:40 <neologism> well.. I have [String] where each string is a file name.. and I have to do some action with each of these files
01:40:48 <ValarQ> sequence $ map print [1 .. 5] -- for example
01:40:57 <davidhouse> ValarQ: why not just use mapM?
01:41:00 <Korollary> in that case, you do have separate actions
01:41:05 <davidhouse> mapM is short for sequence . map
01:41:13 <ValarQ> oh, ok
01:41:15 <sethk> davidhouse, the compiler is telling me to declare an instance.  which doesn't make sense.
01:41:25 <neologism> I dont understand the difference between mapM and mapM_
01:41:30 <davidhouse> sethk, pastebin some code
01:41:31 <neologism> mapM doesnt compile in my case
01:41:55 <davidhouse> neologism: mapM collects the outputs of all the actions into another list. mapM_ just returns IO ()
01:41:57 <Korollary> @index mapM
01:41:57 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:42:17 <sethk> ifd <- return (toInteger (handleToFd handle))
01:42:19 <davidhouse> neologism: as all statements in a do block need to have type IO (), using mapM won't work
01:42:25 <Korollary> @type toInteger
01:42:26 <lambdabot> forall a. (Integral a) => a -> Integer
01:42:33 <neologism> davidhouse: can you show me code with mapM ?
01:42:49 <davidhouse> hmm...
01:42:53 <sethk> davidhouse, no, sorry, I copied the wrong line
01:43:02 <davidhouse> @hoogle a -> IO b
01:43:03 <lambdabot> Control.Exception.evaluate :: a -> IO a
01:43:03 <lambdabot> System.Exit.exitFailure :: IO a
01:43:03 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
01:43:06 <sethk> davidhouse, that one is no good because handleToFd is IO
01:43:18 <sethk> so I have two lines:
01:43:25 <sethk> posixfd <- handleToFd handle
01:43:27 <sethk> then 
01:43:32 <davidhouse> neologism: can't think of any off the top of my head
01:43:35 <sethk> ifd <- (toInteger posixfd)
01:43:50 <Korollary> sethk: you mean let ifd = toInteger posixfd
01:44:14 <davidhouse> neologism: if you had an IO action which took a parameter, and you wanted to pass in each element of a list then collect the results, you'd use mapM.
01:44:20 <sethk> Korollary, that's the same thing, but in this case, no, I can't do that because I can't get to posixfd that way
01:44:21 <davidhouse> @hoogle a -> m b
01:44:22 <lambdabot> Prelude.id :: a -> a
01:44:22 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:44:22 <lambdabot> Control.Parallel.par :: a -> b -> b
01:44:29 <Korollary> sethk: that's not the same thing
01:44:46 <sethk> Korollary, ok, you can't do that.
01:44:46 <davidhouse> @hoogle a -> m a
01:44:47 <lambdabot> Prelude.id :: a -> a
01:44:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:44:47 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
01:44:52 <sethk> Korollary, the compiler will barf on it
01:44:53 <davidhouse> @type return
01:44:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
01:45:17 <davidhouse> > mapM return [1..5] :: [[Int]]
01:45:18 <lambdabot> [[1,2,3,4,5]]
01:45:28 <davidhouse> that's not what i was expecting...
01:45:33 <sethk> Korollary, but, anywhere you can do:   let x = b,  you can also do    x <- return (b)
01:45:49 <davidhouse> > mapM return [1..5] :: [Maybe Int]
01:45:50 <lambdabot> Couldn't match `Maybe Int' against `[b]'
01:45:55 <sethk> Korollary, and if you unravel l >>=, it is in fact the same thing
01:45:59 <davidhouse> @type mapM
01:45:59 <lambdabot> forall b (m :: * -> *) a.
01:45:59 <lambdabot>    (Monad m) =>
01:45:59 <lambdabot>    (a -> m b) -> [a] -> m [b]
01:46:01 <davidhouse> oh.
01:46:06 <davidhouse> > mapM return [1..5] :: Maybe [Int]
01:46:07 <lambdabot> Just [1,2,3,4,5]
01:46:14 <Korollary> sethk: yes, but you didnt have a return on the right side in your previous example.
01:46:25 <sethk> Korollary, sorry
01:46:40 <sethk> Korollary, what I actually need to do is get the Fd into a CInt
01:46:50 <sethk> Korollary, which is easy of course once I get it into an Integer
01:47:32 <davidhouse> > mapM (return.(+1)) [1..5] :: Maybe [Int]
01:47:33 <lambdabot> Just [2,3,4,5,6]
01:47:41 <sethk> Korollary, what's really annoying is that I did this yesterday, and decided not to use FFI, and got rid of it, and now I need it again  :)
01:47:45 <davidhouse> neologism: hang on, need to IDENTIFY.
01:47:57 <neologism> ok :)
01:48:12 <Korollary> sethk: use version control :)
01:48:15 <ValarQ> > sequence [Just 1, Just 2]
01:48:16 <lambdabot> Just [1,2]
01:48:32 <davidhouse> > sequence $ map (return.(+1) [1..5]
01:48:32 <lambdabot>  parse error on input `}'
01:48:37 <davidhouse> > sequence $ map (return.(+1)) [1..5]
01:48:37 <lambdabot>  add an instance declaration for (Show (m [a]))
01:48:43 <davidhouse> > sequence $ map (return.(+1)) [1..5] :: Maybe [Int]
01:48:44 <lambdabot> Just [2,3,4,5,6]
01:49:46 <sethk> Korollary, I do, I just screwed up this time
01:50:02 <sethk> I know I used a combination of toInteger and fromIntegral
01:50:09 <sethk> I just have to find the combination again.
01:51:42 <Korollary> > let x = 1::Integer in (fromIntegral x) :: CInt
01:51:43 <lambdabot>  Not in scope: type constructor or class `CInt'
01:53:09 <Korollary> sethk: why did you want to use ffi again?
01:54:28 <sethk> Korollary, I figured it out  :0
01:54:44 <sethk> Korollary, I want to use select() to find out whether an FD is writable
01:56:46 <Korollary> @index getPermissions
01:56:47 <lambdabot> System.Directory, Distribution.Compat.Directory
01:57:08 <Korollary> that won't do?
02:01:21 <sethk> Korollary, let me look
02:08:38 <sethk> Korollary, no, that refers to the permissions of the file on the disk.  I'm looking at whether the stream can accept a character
02:11:27 <davidhouse> @localtime dons
02:11:29 <lambdabot> Local time for dons is Sat Mar 25 21:11:51 2006
02:11:47 <Korollary> sethk: you may also want to check MissingH.IO.HVIO from MissingH
02:15:18 <davidhouse> @hoogle Char -> Int
02:15:19 <lambdabot> Data.Char.digitToInt :: Char -> Int
02:15:19 <lambdabot> Data.Char.ord :: Char -> Int
02:15:19 <lambdabot> Text.Regex.Posix.regExtended :: Int
02:17:45 <sethk> Korollary, thanks.  because what I was trying to do won't work, because handleToFd closes the handle
02:18:00 <sethk> Korollary, select must exist somewhere
02:18:08 <sethk> Korollary, maybe in the socket library?
02:19:11 <davidhouse> is there a function to see if something is readable?
02:21:02 <davidhouse> readable in the sense of read.
02:21:07 <davidhouse> > read "hi"
02:21:08 <lambdabot> Add a type signature
02:21:14 <davidhouse> > read "hi" :: Int
02:21:15 <lambdabot> Exception: Prelude.read: no parse
02:21:24 <davidhouse> a way to get around that exception
02:21:31 <davidhouse> perhaps return Nothing instead.
02:22:43 <sethk> davidhouse, you can catch it
02:22:53 <davidhouse> yes, true.
02:23:00 <davidhouse> @type read "hi"::Int
02:23:01 <lambdabot> Int
02:23:23 <davidhouse> ah, because undefined can have type Int.
02:27:29 <davidhouse> hmm.
02:27:34 <davidhouse> doesn't sound like a solution
02:27:38 <davidhouse> you can only catch exceptions in IO.
02:30:40 <sethk> davidhouse, no, you can catch other exceptions
02:30:56 <davidhouse> sethk: how?
02:30:59 <sethk> davidhouse, check the docs on Control.Exception, there is a discussion there about how to do it
02:31:11 <sethk> davidhouse, let me glance at it, I read it a few weeks ago.
02:34:35 <davidhouse> @type lines
02:34:36 <lambdabot> String -> [String]
02:50:01 <sethk> got to go back to the hotel, it's 3 am or some weird time like that.  I'll be back from the hotel room ...
03:00:48 <davidhouse> > cast "5" :: Maybe Int
03:00:49 <lambdabot> Nothing
03:00:53 <davidhouse> how does cast work?
03:04:54 <davidhouse> @index intTc
03:04:54 <lambdabot> bzzt
03:06:57 <dcoutts> dons, Igloo, yes gtk2hs still uses autotools + package.confs
03:07:22 <dcoutts> Igloo, btw thanks for the debian ghc ia64 binary
03:10:29 <integral> cast doesn't actually perform any conversion...
03:30:17 <musasabi> How does one work around GHC TH stage restrictions?
03:30:34 <musasabi> "    GHC stage restriction: `typeToValue'"
03:30:34 <musasabi>       is used in a top-level splice, and must be imported, not defined locally
03:31:19 <musasabi> I am trying to use a small function to perform reflection from type level to value level: typeToValue ty = varE 'undefined `sigE` return ty
03:31:44 <musasabi> But GHC seems to dislike my idea.
03:32:08 <sethk> musasabi, why?  You llooked at the typeable class, I assume
03:33:11 <musasabi> sethk: the problem is that I have a Type, not a value of that type. (I got the type by using reify on a datatype declaration and then taking it apart.)
03:34:22 <musasabi> sethk: and I need an open function to dispatch on the said type, thus a typeclass and the need to reflect it to the value level.
03:34:55 <sethk> musasabi, might have to dig into the internals a bit to figure that out.
03:41:35 <kaydara> for using a function from Data.Char what should i put in my code ?
03:41:50 <jethr0> import Data.Char
03:42:02 <jethr0> or "import qualified Data.Char"
03:43:02 <kaydara> in the command line the import Data.Char dont work right ?
03:43:33 <jethr0> no, but in ghci you can do ":m +Data.Char"
03:57:52 <pierre-> hello.
03:58:54 <jethr0> hello
04:01:19 <gour> dcoutts: hi
04:01:26 <dcoutts> hia gour 
04:02:12 <gour> just to greet you before i leave for india
04:02:21 <dcoutts> oh! have fun!
04:03:13 <gour> dcoutts: i'm flying from here tuesday morning
04:03:36 <gour> to london & than to calcutta
04:04:32 <gour> i hope hIDE & gtk2hs, ghc will be further developed when i return back (if i don't leave my body from cobra's bite)
04:04:46 <dcoutts> gour, heh :-)
04:06:54 <gour> i got the news that there is already pretty hot, so it will be a little shock considering we are still in winter jacket here
04:10:41 <gour> dear #haskellers, pls. wish me a nice journey toward my destinatinon & successful studies there..
04:10:58 <gour> and don't forget to hack on haskell :-)
04:12:13 <waern> gour, good luck!
04:12:25 <gour> waern: thank you
04:13:02 <waern> I hope your stomach will acustomize itself quickly ;)
04:13:22 <psi> good luck gour. what are you going to study there?
04:13:42 <gour> well, igot some good tips. wasn't there since '84
04:13:58 <gour> psi: vedic astrology - jyotish
04:14:57 * psi has no idea what that is
04:17:27 <gour> i'm testing my laptop with madwifi card and networkmanager drops connection sometimes
04:19:10 <gour> psi: http://shyamasundaradasa.com/jyotish/main/what_is_jyotish.html
04:19:26 <gour> psi: it's my teacher's site
04:34:52 <gour> good bye #haskell. see you in few months
04:37:53 <musasabi> What would be a good way of parsing messages with context-sensitive tokenizing rules? Parsec is kind of slow, so I would prefer to use happy/alex but they seem unsuitable for the task.
04:38:32 <gour> shapr: bok, or good-bye
04:40:45 <gour> Lemmih: bye, bye
04:40:53 <musasabi> bye
04:41:13 <snk_kid> hiall
04:41:18 <gour> musasabi: bye
04:42:34 <snk_kid> this is gonna sound stupid but when you build a package via runghc/haskell and you specifiy use haddock, where does haddock put generated html files by default?
04:46:28 <snk_kid> well if noone does, how about giving us a link to api reference for SDL bindings :)
04:48:12 <snk_kid> Lemmih: are you around?
05:07:44 <Philippa> musasabi: can you encode the parser in "first order parsec"?
05:07:49 <Philippa> if so, try a packrat parser
05:09:59 <Philippa> 'lo cm
05:10:09 <cm_> heya
05:10:23 <Philippa> I *knew* there was someone else from #flipcode I hadn't mentioned showing up here to Smokey
05:10:38 <Philippa> (he's doing haskell at college now, was on the other night)
05:11:09 <cm> heya :)
05:11:18 <cm> cool
05:11:34 <cm> I had a brief visit at #flipcode recently ö=
05:11:37 <cm> ";)"
05:13:39 <Philippa> I haven't shown up in ages, I'm just not doing that kind of code any more
05:14:17 <Philippa> I swear next time I'll be all "Kids these days - when I were a lass we had to do gouraud shading by hand, in software! None of this new-fangled shader nonsense!"
05:14:58 <cm> :)
05:15:51 <cm> I think both software and hardware rendering with shaders can be easier to grasp than the fixed function pipeline stuff, in a way.
05:16:15 <Lethalman> hello, how can i do a select on multiple handles?
05:16:21 <waern> what were you called at flipcode?
05:16:26 <Lethalman> something like the C select function
05:17:32 * sylvan is currently writing an old-school software rasterizer
05:17:42 <sylvan> for fun, of course
05:17:52 <waern> that's alot of fun :)
05:18:00 <waern> in c?
05:18:08 <sylvan> nope, .Net! =)
05:18:12 <sylvan> C#
05:18:15 <waern> ok
05:18:34 <sylvan> it'll be fun to see if I can get it fast enough...
05:18:39 <waern> some unsafe blocks here and there? :)
05:18:44 <sylvan> so far I've been pretty impressed by the speed
05:18:51 <sylvan> yep, lots of "unsafe" =)
05:19:15 <Philippa> cm: definitely
05:19:15 <waern> have they sped up the floating point arithmetic in .net?
05:19:27 <Philippa> as soon as you're doing anything complex you have a sane computational model instead of an insane one
05:19:28 <waern> last time I used it it was pretty slow
05:19:32 <sylvan> not sure... 
05:19:43 <sylvan> what does it do other than what C does?
05:19:57 <cm> yeah
05:19:59 <sylvan> ther's always fixed-point arithmetic.. =)
05:20:08 <waern> sylvan, don't know
05:20:21 <musasabi> Philippa: thanks, this looks promising.
05:20:44 <sylvan> I know a lot of extra checks and stuff gets removed with unsafe and unchecked
05:26:59 <musasabi> Philippa: do you know of the performance as compared to something like parsec?
05:28:32 <Philippa> the main thing I remember is linear time
05:28:53 <Philippa> potentially much much faster than parsec because of the amount of analysis that can be done
05:40:20 <snk_kid> so no ideas about where haddock puts generated doc files?
05:40:26 <snk_kid> (by default)
05:44:02 <sylvan> snk_kid, /dev/null? :-)
05:57:46 <dons> sethk, an xmodem upload? 
06:32:13 <lightstep> about HGL, is there a way to change the window background color without drawing a rectangle on Redraw?
06:32:34 <dcoutts> dons, you know something about ghc on mips right?
06:32:37 <lightstep> this is probably equivalent to making a colored emptyShape
06:38:47 <musasabi> Does GHC pass dictionaries for type classes with zero methods?
06:44:12 <musasabi> Basically class SomeContraint a; data Foo = forall t. SomeConstraint t => Foo (Bar t); data Bar t = Bar String
07:16:54 <dcoutts> Igloo, btw a regesterised ia64 build works ok, no ghci
07:18:27 <Igloo> Oh, interesting, I thought that had bitrotted a while ago
07:19:53 <Igloo> Oh, actually, that might have been due to an Itanium 1 not emulating the Itanium 2 instructions
07:34:06 <akemp> @seen Lemmih
07:34:07 <lambdabot> Lemmih is in #haskell. Last spoke 10 hours, 54 minutes and 25 seconds ago.
07:38:33 <dcoutts> Igloo, it also looks like ghci on ia64 is worth trying, there's some support in Linker.c
07:40:22 <dcoutts> Igloo, and yes, I'm testing it on an Itanium 2 system
07:40:57 <dcoutts> it's rather nice that parallel make works for ghc, since it's a dual cpu Itanium 2 :-)
07:41:26 <Igloo> It does work on I1s, you just need to turn on the emulation and one of the Debian machines accidentally hadn't (all IIRC)
07:50:35 <kaydara> i need to create a function but i dont have a clue how to do it, if someone can give me a clue i apreciate
07:50:42 <kaydara> the function recives a int
07:50:57 <kaydara> and should return a list of bools with all possibles combos of bools
07:50:59 <kaydara> like :
07:51:33 <kaydara> constrVal 2 = [[True,True],[True,False],[False,True],[False,False]]
07:53:09 <Philippa> constrVal 0 = []
07:53:29 <Philippa> actually, make that:
07:53:32 <Philippa> constrVal 0 = [[]]
07:53:39 * Igloo points out this smells like homework
07:53:46 <Philippa> point
07:54:10 <Philippa> now, constrVal 1 = [[True],[False]]. How does that relate to constrVal 0? How does constrVal 2 relate to constrVal 1?
07:54:14 <xerox> > let constrVal n = [(x,y) | x <- take n $ cycle [True,False], y <- take n $ cycle [True,False]] in constrVal 2
07:54:15 <lambdabot> [(True,True),(True,False),(False,True),(False,False)]
07:55:01 <kaydara> xerox, thats too much for me :s
07:55:14 <kaydara> Philippa, let me c
07:55:14 <xerox> That's just an idea.
07:55:36 <Lemmih> akemp: Hey.
07:55:39 <kaydara> i need to understend it too, thanks very much
07:55:56 <xerox> You're welcome.
07:55:56 <davidhouse> > take 10 $ cycle [True, False]
07:55:57 <lambdabot> [True,False,True,False,True,False,True,False,True,False]
07:56:28 <Muad_Dib> i'd say use a recursive function then kaydara :)
07:57:28 <kaydara> or i will try to understend all that line from xerox :)
07:57:51 <Igloo> I don't think xerox's function does what you want
07:58:07 <kaydara> let me test
07:59:00 <xerox> We can hack up something different if you will.
07:59:09 <kaydara> no it doesnt always make a tuple of 2
07:59:21 <xerox> Yes.
07:59:27 <xerox> Oh, I see what you mean.
08:06:02 <akemp> Lemmih: I've been trying to build cabal-get.  No luck so far with GHC-darcs.
08:06:20 <akemp> I thought that you might have some words of wisdom for me...
08:11:35 <dcoutts> Igloo, ah I see. The gentoo ia64 people don't support Itanium 1 since the hardware is not obtainable any more.
08:12:24 <akemp> >let grow x = map (\l -> (l++True) ++ (l++False)) x in grow [[True],[False]]
08:13:07 <akemp> Something like that + recursion.
08:14:12 <akemp> > take 10 $ cycle [True, False]
08:14:13 <lambdabot> [True,False,True,False,True,False,True,False,True,False]
08:14:55 <xerox> > [True,False] >>= \l -> return $ (l : [False]) ++ (l : [True])
08:14:55 <akemp> > let grow x = map (\l -> (l++True):(l++False):[]) x in grow [[True],[False]]
08:14:56 <lambdabot> [[True,False,True,True],[False,False,False,True]]
08:14:56 <lambdabot> Couldn't match `[a]' against `Bool'
08:15:23 <akemp> I miss homework... ;)
08:15:39 <pierre-> > let grow x = map (\l -> (l++[True]):(l++[False]):[]) x in grow [[True],[False]]
08:15:40 <lambdabot> [[[True,True],[True,False]],[[False,True],[False,False]]]
08:16:15 <akemp> Hmmm... close...
08:16:27 <pierre-> can you explain me what this does? 
08:17:01 <akemp> What part don't you understand?
08:17:22 <xerox> Something like that?
08:17:25 <xerox> > [[True],[False]] >>= f where f = \l -> [l++[False],l++[True]]
08:17:26 <lambdabot> [[True,False],[True,True],[False,False],[False,True]]
08:17:29 <xerox> > [[True],[False]] >>= f >>= f where f = \l -> [l++[False],l++[True]]
08:17:29 <lambdabot> [[True,False,False],[True,False,True],[True,True,False],[True,True,True],[False,False,False],[False,False,True],[False,True,False],[False,True,True]]
08:17:33 <xerox> > [[True],[False]] >>= f >>= f >>= f where f = \l -> [l++[False],l++[True]]
08:17:34 <lambdabot> [[True,False,False,False],[True,False,False,True],[True,False,True,False],[True,False,True,True],[True,True,False,False],[True,True,False,True],[True,True,True,False],[True,True,True,True],[False,False,False,False],[False,False,False,True],[False,False,True,False],[False,False,True,True],[False,True,False,False],[False,True,False,True],[False,
08:17:34 <lambdabot> True,True,False],[False,True,True,True]]
08:17:46 <xerox> etc.
08:18:08 <pierre-> yes... i understood the code, but what's the purpose? 
08:18:23 <akemp> oh.  It's someone's homework assignment... probably.
08:19:02 <xerox> I think mine works.
08:19:19 <Philippa> generating a list of all possible lists of bools of size n
08:19:28 <xerox> Right.
08:20:53 <akemp> let grow n l = [ e++tf | tf <- [True, False], e<- l] in grow 1 [True, False]
08:20:59 <akemp> > let grow n l = [ e++tf | tf <- [True, False], e<- l] in grow 1 [True, False]
08:20:59 <lambdabot> Couldn't match `[a]' against `Bool'
08:21:38 <akemp> ah well...  Trying to pull xerox's code out of monad form and into a list comprehension.
08:22:03 <akemp> > let grow n l = [ e++tf | tf <- [True, False], e<- l] in grow 1 [[True], [False]]
08:22:03 <lambdabot> Couldn't match `[a]' against `Bool'
08:22:26 <xerox> > let f n = iterate (>>= grow) [[True],[False]] !! (n-1) where grow xs = [xs++[False],xs++[True]] in f 2
08:22:27 <lambdabot> [[True,False],[True,True],[False,False],[False,True]]
08:22:33 <xerox> > let f n = iterate (>>= grow) [[True],[False]] !! (n-1) where grow xs = [xs++[False],xs++[True]] in f 3
08:22:34 <lambdabot> [[True,False,False],[True,False,True],[True,True,False],[True,True,True],[False,False,False],[False,False,True],[False,True,False],[False,True,True]]
08:22:55 <akemp> > let grow n l = [ e++tf | tf <- [[True], [False]], e<- l] in grow 1 [[True], [False]]
08:22:56 <lambdabot> [[True,True],[False,True],[True,False],[False,False]]
08:22:58 <xerox> Nice idea, yours, I must say.
08:23:14 <akemp> Now just recursivisify it
08:23:27 <akemp> Too hard to write the recursive version in lambdabotese.
08:23:30 <xerox> What do you do? :-)
08:23:39 <akemp> ;)
08:24:11 <ihope> Hmm, oonk.
08:24:29 <ihope> I'd like to see some quantum mechanics implemented in Haskell.
08:24:45 <akemp> I was thinking about doing some of that actually.
08:24:50 <ihope> Cool.
08:25:09 <akemp> No *real* QM, but just non-deterministic automata.
08:25:15 <ihope> Oh.
08:25:43 <akemp> I couldn't figure out how to define when to decohere them.
08:25:53 <ihope> Heh.
08:26:03 <akemp> Also, space consumption was ... err ... problematic.
08:26:15 <ihope> Yes, I imagine it would be :-)
08:26:38 <ihope> data Qubit = [Complex] -- :-P
08:26:42 <Lemmih> akemp: It fails to build?
08:27:22 <akemp> Lemmih: yeah.  I think that I'm running into a problem with the many different versions of packages on my box.
08:28:20 <akemp> Lemmih: what is your setup to built it?
08:29:39 <Lemmih> akemp: I've only tried with GHC-6.4.x
08:30:06 <akemp> Lemmih: ah.  Perhaps I should stop screwing around the the darcs.haskell.org stuff...  I always get burned.
08:54:46 <Lenny1729> Hi all
08:56:07 <basti_> hi lenny
08:57:26 <Lenny1729> In Yet another Haskell Tutorial on page 138 is stated that mplus only works on top level as intented and an example is given. I don't understand why, could someone please try to explain the differnce?
08:57:52 <basti_> :-O
08:58:01 * basti_ has a look
08:58:09 <Lenny1729> thanks basti_
08:58:22 <ihope> @where yaht
08:58:22 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
08:59:41 <ihope> UGH. Is there a piece of software out there that's worse than Adobe Acrobat Reader?
09:00:24 <basti_> Lenny1729: i think this is a special problem with that kind of program
09:00:24 <Lenny1729> haven't found one
09:00:24 <piggy_> just use foxit reader
09:00:48 <basti_> IO isn't a MonadPlus, so you can't use mplus "on toplevel" (with IO a values)
09:02:09 <Lenny1729> basti_: hm... I copied the second and wrong version of searchAll2 and it return just []
09:02:19 <basti_> hmm
09:02:42 * basti_ has a deeper look
09:02:59 <Lenny1729> basti_: I don't understand why it doesn't run search' after the recursive call to searchAll2 has failed
09:03:11 <ihope> Yikes! Controlled-control gates?
09:03:59 <basti_> Lenny1729: i think it might have to do with lazy eval, and the fact that `mplus` is said not to work?
09:04:08 <Lenny1729> basti_: The author of yaht describes this behavior but doesn't give an good reason for it. He just argues with "mplus has to be run on top level"
09:04:11 <basti_> i don't completely realize why mplus doesnt work though
09:04:50 <basti_> I'm not aware about any specialities of mplus. It's a function that just works on certain values, and sometimes it might give unexpected results, but this sounds entirely foreign
09:05:14 <basti_> (like, for example, you could accidentally mplus on a wrong level of monadic values containing each other)
09:05:41 <Lenny1729> The first version of searchAll2 with mplus at top level works fine.... 
09:05:44 <basti_> > map (`mplus` Just 3) [Just 2,Nothing,Just 5]
09:05:45 <lambdabot> [Just 2,Just 3,Just 5]
09:05:54 <basti_> something like that, confusing it with
09:06:12 <basti_> > [Just 2,Nothing,Just 5] `mplus` [Just 3]
09:06:13 <lambdabot> [Just 2,Nothing,Just 5,Just 3]
09:06:27 <ihope> > Just 3 `mplus` Just 4
09:06:28 <lambdabot> Just 3
09:06:31 <ihope> > Just 3 `mplus` Nothing
09:06:32 <lambdabot> Just 3
09:06:51 <ihope> > (Nothing `mplus` Just 4, Nothing `mplus` Nothing)
09:06:52 <lambdabot> Add a type signature
09:07:10 <ihope> > (Nothing `mplus` Just 4, Nothing `mplus` Nothing) :: (Maybe Int, Maybe Int)
09:07:11 <lambdabot> (Just 4,Nothing)
09:07:14 <basti_> Lenny1729: are the snippets complete or do they rely on former code?
09:07:22 <davidhouse> ihope, why's that necessary?
09:07:40 <Lenny1729> they only rely on data Graph v e = Graph [(Int,v)] [(Int,Int,e)] 
09:07:57 <basti_> I'm making them alive then
09:08:07 <davidhouse> works on my GHCi.
09:08:09 <Lenny1729> here is a graph:  gr = Graph [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')] [(0,1,'l'), (0,2,'m'), (1,3,'n'), (2,3,'m')]
09:08:32 <davidhouse> @type (Nothing `mplus` Just 4, Nothing `mplus` Nothing)
09:08:33 <lambdabot> Not in scope: `mplus'
09:08:33 <lambdabot>  
09:08:33 <lambdabot> <interactive>:1:33: Not in scope: `mplus'
09:08:46 <davidhouse> @type (Nothing `Control.Monad.mplus` Just 4, Nothing `Control.Monad.mplus` Nothing)
09:08:47 <lambdabot> forall a
09:08:47 <lambdabot> [3 @more lines]
09:08:51 <davidhouse> @more
09:08:51 <lambdabot>                               a1.
09:08:51 <lambdabot>                            (Num a) =>
09:08:51 <lambdabot>                            (Maybe a, Maybe a1)
09:08:59 <Lenny1729> searchAll2 gr 0 3   :: [[Int]]    should return [[0,1,3],[0,2,3]]
09:09:05 <davidhouse> ah. it doesn't know the type of the second one.
09:09:31 <davidhouse> @type (Nothing `mplus` Just 4, (Nothing::Maybe Int) `mplus` Nothing)
09:09:32 <lambdabot> Not in scope: `mplus'
09:09:32 <lambdabot>  
09:09:32 <lambdabot> <interactive>:1:46: Not in scope: `mplus'
09:09:38 <davidhouse> > (Nothing `mplus` Just 4, (Nothing::Maybe Int) `mplus` Nothing)
09:09:39 <lambdabot> (Just 4,Nothing)
09:11:01 <davidhouse> MonadPlus is cool.
09:12:34 <davidhouse> > (mzero `mplus` return 4, mzero `mplus` mzero) :: (Maybe Int, Maybe Int)
09:12:35 <lambdabot> (Just 4,Nothing)
09:13:48 <basti_> hmm
09:13:53 <basti_> both versions have different types
09:13:58 <basti_> thats what i presumed
09:14:53 <basti_> uhm no
09:14:55 <basti_> wtf.
09:15:21 <davidhouse> basti_, what are you looking at?
09:15:35 <basti_> I'm trying to find out what the difference is exactly in these examples
09:16:02 <davidhouse> which examples?
09:16:21 <basti_> in the ones of yaht
09:16:28 <Lenny1729> page 138
09:16:31 <basti_> the ones Lenny1729 mentioned
09:16:47 <davidhouse> @where yaht
09:16:47 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
09:17:17 <basti_> this is very strange
09:17:21 <davidhouse> the book's page 138 or the pdf's page 138?
09:17:29 <basti_> book
09:17:30 <Lenny1729> books' page 128
09:17:34 <basti_> I'm sure there is a completely reasonable explanation for that
09:17:38 <Lenny1729> err, 138
09:18:09 <basti_> Hmm i think search' has different types in both examples
09:18:16 <Lenny1729> It's 149 for pdf
09:19:26 <Lenny1729>              path <- searchAll2 g v dst
09:19:27 <Lenny1729>              rest <- search' es
09:19:27 <Lenny1729>              return ((u:path) `mplus` rest)
09:19:32 <basti_> yes they do.
09:20:24 <Lenny1729> why doesn't mplus evalutes rest after path has failed.... I just don't understand it
09:20:50 <basti_> this is very twisted
09:21:41 <Lenny1729> basti_: What are the types of the two search' version?
09:21:56 <basti_> the one of the broken version is  (MonadPlus m) => [(Int,Int,c)] -> m [Int]
09:22:03 <davidhouse> > take 10 $ [] `mplus` [1..]
09:22:04 <lambdabot> [1,2,3,4,5,6,7,8,9,10]
09:22:05 <basti_> the other version doesnt satisfy this type
09:22:10 <Lenny1729> Is there an easy why to get the type of  a nested function?
09:22:15 <basti_> not that i know of
09:22:18 <davidhouse> > take 10 $ [1] `mplus` [1..]
09:22:19 <lambdabot> [1,1,2,3,4,5,6,7,8,9]
09:22:33 <ihope> Is <|> pretty much the same thing as mplus?
09:22:38 <davidhouse> basti_, what's the type of the non-broken one?
09:22:54 <Lenny1729> basti_ but why doesn't the wrong version return an error or sth. like that
09:23:10 <basti_> davidhouse: i'm trying to find that out ;)
09:23:22 <davidhouse> > fail "no path" `mplus` [1..]
09:23:23 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,
09:23:23 <lambdabot> [5 @more lines]
09:23:37 <basti_> Lenny1729: my theory is: the "wrong" version is just interpreted wrongly. It's a correct haskell program, but it doesnt do what you think it should
09:23:57 <basti_> (a error of the second generation)
09:24:28 <Lenny1729> so, a bug in hugs and ghci?
09:24:31 <davidhouse> > fail "no path" >>= \path -> 9:path
09:24:32 <lambdabot> []
09:24:33 <basti_> no
09:24:35 <davidhouse> aha.
09:24:59 <basti_> aha, indeed.
09:25:07 <davidhouse> wait
09:25:09 <basti_> and now? ;)
09:25:11 <davidhouse> > 9:[]
09:25:12 <lambdabot> [9]
09:25:14 <davidhouse> oh good.
09:25:17 <davidhouse> > fail "no path"
09:25:18 <lambdabot>  add an instance declaration for (Show (m a))
09:25:24 <davidhouse> > fail "no path" :: [Int]
09:25:24 <lambdabot> []
09:25:28 <davidhouse> hmm.
09:25:34 <davidhouse> ah well.
09:25:39 <basti_> davidhouse is on a track there.
09:26:01 <davidhouse> > fail "no path" >>= \path -> return $ 9:path
09:26:02 <lambdabot>  add an instance declaration for (Show (m [a]))
09:26:24 <davidhouse> well, the difference is that if searchAll2 fails, then the correct version still returns an empty list:
09:26:29 <davidhouse> > fail "no path" >>= \path -> 9:path
09:26:30 <lambdabot> []
09:26:39 <davidhouse> but the incorrect one doesn't:
09:26:46 <davidhouse> > fail "no path" `mplus` [1..]
09:26:47 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,
09:26:47 <lambdabot> [5 @more lines]
09:27:05 <davidhouse> no, wait, that doesn't make sense
09:27:18 <basti_> in one case, left to `mplus` there is a monadic expression?
09:27:23 <basti_> (->) is a MonadPlus?
09:27:28 <davidhouse> > (fail "no path" >>= \path -> 9:path) `mplus` [1..20]
09:27:29 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
09:27:30 <basti_> no not (->)
09:27:53 <davidhouse> > (fail "no path" >>= \path -> return (9:path)) `mplus` [1..20]
09:27:54 <lambdabot>  add an instance declaration for (Num [a])
09:27:54 <lambdabot>   In an arithmetic sequence: [1 .. 20]
09:28:11 <basti_> Lenny1729: in any case, this is a superficial similarity of two very different programs. Look exactly at what's left to the `mplus` in both cases!
09:29:08 <davidhouse> > (fail "no path" >>= \path -> return (9:path)) `mplus` [[1..20]]
09:29:09 <lambdabot> [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]]
09:29:22 <Lenny1729> basti_: the return statement is differnt
09:29:59 <basti_> yes, everyting is different
09:30:01 <davidhouse> > fail "no path" >>= \path -> (return 9:path) `mplus` [[1..20]]
09:30:02 <lambdabot> []
09:30:06 <basti_> except the order in which the statements are written
09:30:15 <basti_> davidhouse dissected it
09:30:20 <basti_> very nice davidhouse.
09:31:13 <davidhouse> oops
09:31:21 <davidhouse> > fail "no path" >>= \path -> (return $ 9:path) `mplus` [[1..20]]
09:31:22 <lambdabot> []
09:31:28 <davidhouse> good. doesn't make a difference
09:31:46 <davidhouse> but that doesn't make sense. the first one is apparently correct, but i would have thought that the second is right
09:31:46 <Lenny1729> hm.. I understand that the problem can be reduced to   fail "no path" >>= \path -> (return 9:path) `mplus` [[1..20]]  but why does this line return []?
09:32:13 <davidhouse> > 9:(fail "no path")
09:32:14 <lambdabot> [9]
09:32:16 <basti_> hmmm
09:32:29 <davidhouse> > return $ 9:(fail "no path") :: [[Int]]
09:32:30 <basti_> lets face it: this problem is rather obscure, and the program should be rewritten.
09:32:30 <lambdabot> [[9]]
09:32:33 <basti_> ;)
09:32:47 <Lenny1729> basti_ *G* good solution
09:32:52 <davidhouse> [[9]] `mplus` [[3]]
09:32:56 <davidhouse> > [[9]] `mplus` [[3]]
09:32:57 <lambdabot> [[9],[3]]
09:33:05 <davidhouse> very weird.
09:33:16 <davidhouse> heh. oops.
09:33:35 <davidhouse> > fail "no path" >>= \path -> return $ 9:path :: [[Int]]
09:33:36 <lambdabot> []
09:33:40 <davidhouse> there you go.
09:33:40 <basti_> I'd word it like that: subtle differences in spelling out similar programs might make a huge difference in the end. This is not usual.
09:34:30 <davidhouse> > fail "no path" >>= \path -> [9:path] `mplus` [[1..20]]
09:34:31 <lambdabot> []
09:34:47 <davidhouse> > [] `mplus` [1..20]
09:34:48 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
09:34:51 <davidhouse> > [] `mplus` [[1..20]]
09:34:52 <lambdabot> [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]]
09:35:17 <davidhouse> i think there's more to fail than meets the eye
09:35:31 <Lenny1729> davidhouse, good point
09:35:33 <Philippa> fail in the list monad is []
09:35:51 <Lenny1729> it seems to interrupt further computations
09:35:54 <davidhouse> > (fail "no path") `mplus` [1..20]
09:35:55 <lambdabot> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
09:36:06 <davidhouse> aah!
09:36:07 <Philippa> Lenny1729: >>= is (flip concatMap)
09:36:19 <Philippa> what happens if you map something across the empty list?
09:36:26 <davidhouse> if you think about how >>= is defined for lists, it makes sense.
09:36:31 <davidhouse> yeah. what Philippa said.
09:36:37 <basti_> hm
09:36:40 * basti_ ponders that
09:36:51 * Lenny1729 too
09:36:53 <davidhouse> > concat $ map (+1) []
09:36:54 <lambdabot>  add an instance declaration for (Num [a])
09:37:06 <basti_> ah
09:37:34 <basti_> so the failure is doing a monadic operation at the wrong point in the program?
09:37:40 <davidhouse> > concat $ map (return.(+1)) []
09:37:41 <lambdabot> []
09:37:43 <basti_> when it fails, it breaks the rest, which isnt intended?
09:37:49 <davidhouse> > fail "no path" >>= \path -> [9:path] `mplus` [[1..20]]
09:37:50 <lambdabot> []
09:38:01 <davidhouse> nothing after the >>= happens there because you're mapping across an empty list
09:38:09 * basti_ nods
09:38:12 <basti_> now I'm seeing it too
09:38:22 <basti_> it's only obscured by the rest of the program
09:38:38 <basti_> very easy actually, and doesnt really have anything to do with mplus not working "not on toplevel"
09:38:45 <basti_> hmm or
09:38:48 <basti_> it does, but...
09:38:55 <basti_> the words are misleading
09:39:42 <davidhouse> > fail "no path" >>= \path -> [9:path]
09:39:43 <lambdabot> []
09:41:50 <Lenny1729> hm.. so the whole problem is the definition of >>= for lists?
09:42:01 <basti_> no the problem is calling things in the wrong order
09:42:04 <basti_> and thinking it's right
09:42:27 <Lenny1729> mplus gets never called in the second version, right?
09:42:43 <Lenny1729> because it is not at the top level
09:42:56 <Lenny1729> is is under >>=
09:43:20 <basti_> yea
09:44:44 <Lenny1729> this was a difficult birth
09:45:35 <basti_> u huh
09:45:52 <Lenny1729> Thanks for your help basti_, davidhouse and Philippa. I wouldn't have it understood without your help
09:46:12 <davidhouse> heh. nor would have I. i think i skipped over that example when reading it
09:46:58 <Lenny1729> Is the author going to complete this tutorial? Is the best I know but quit uncomplete
09:47:20 <davidhouse> not sure.
09:47:34 <davidhouse> Lenny1729: you should read All About Monads as well, to consolodate your monad knowledge.
09:47:43 <davidhouse> i don't think YAHT does monads particularly well.
09:48:20 <Lenny1729> @where All about Monads
09:48:20 <lambdabot> I know nothing about all.
09:48:27 <davidhouse> @google all about monads
09:48:29 <lambdabot> http://www.nomaware.com/monads/html/
09:49:54 <Lenny1729> thanks davidhouse, I am going to read this
09:50:04 <Lenny1729> monads are still a little bit confusing to me
09:50:10 <snk_kid> ahoy hoy
09:50:10 <davidhouse> yep.
09:50:20 <Cale> Lenny1729: also, you should read my tutorial :)
09:50:21 <davidhouse> Lenny1729: ooh, another good tutorial is one on wikibooks
09:50:33 <Cale> @oldwiki MonadsAsContainers
09:50:34 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
09:50:53 <davidhouse> yeah, the wikibooks one is like Cale's but more expanded.
09:50:56 <Cale> (I really should move it to the new wiki :)
09:51:01 <Cale> hm?
09:51:03 <davidhouse> http://en.wikibooks.org/wiki/Programming:Haskell_monads
09:51:12 <davidhouse> it's based on Cale's explanation as monads as containers
09:51:36 <davidhouse> it got me to understand monads. then i read all about monads which explained well monads as computations, and so on.
09:51:49 <davidhouse> then go back to YAHT for parsec.
09:52:28 <davidhouse> :)
09:53:48 <snk_kid> i wonder if anyone can help me, i made a build of Lemmih's SDL bindings using runghc and asked for it to generate docs with haddock but i don't know where those docs have been put
09:54:26 <Lenny1729> davidhouse, that looks like a long, rocky road, but I like challenges :-)
09:54:42 <Cale> well, the wikibooks one is sort of different :)
09:55:00 <Lenny1729> hopefully I'll understand it completely afterwards
09:55:04 <davidhouse> Lenny1729: :) just read a bit at a time. and write lots of code. it's taken me a few weeks to get to grips with monads but i have a great understanding now.
09:55:09 <Lemmih> snk_kid: dist/docs
09:55:27 <davidhouse> you don't need to worry about monad transformers and more advanced topics like that immediately.
09:55:37 <davidhouse> (although monad transformers are disgustingly easy)
09:56:14 <snk_kid> Lemmih: okay i'll have a look :)
09:57:04 <snk_kid> Lemmih: i don't seem them there
09:57:39 <Lenny1729> davidhouse: ok, so I think it's the best for me to write more programs before I proceed in reading. I haven't wrote any programs larger than 50 lines in Haskell
09:57:46 <xerox> So, anybody from Vienna?  :-)
09:58:02 <Lemmih> snk_kid: Sure you generated the docs?
09:58:09 <davidhouse> Lenny1729: http://www.olympiad.org.uk/problems.html was a great source of problems for me
09:58:52 <snk_kid> Lemmih: well i did something like this "runghc Setup.lhs configure --with-haddock=path-to-haddock-bin"
09:59:19 <Lemmih> snk_kid: You also need to run 'runghc Setup.lhs haddock'
09:59:41 <Lenny1729> thanks again for your help davidhouse. I will check this site. Unfortunately I have to go now. 
09:59:46 <davidhouse> sure.
09:59:47 <davidhouse> have fun.
09:59:55 <snk_kid> Lemmih: okay, i'll try that out
09:59:59 <Lenny1729> bye, good evening
10:02:11 <snk_kid> Lemmih: i got errors because i don't have runghc cpphs installed, did i need it before when i made  abuild of your bindings, it seemed to work fine & register then
10:02:23 <snk_kid> whoops not runghc, just cpphs :)
10:07:38 <Lemmih> snk_kid: You need cpphs to generate the docs.
10:08:00 <Lemmih> snk_kid: Maybe you can use 'cpp' instead.
10:08:06 <snk_kid> Lemmih: okay cool, so i didn't need them before when i made a build & install of your bindings
10:11:52 <snk_kid> Lemmih: okay thanks for advice, i'll have to do it later on seeya
10:12:49 <snk_kid> byeeee
10:13:35 <cinema> palomer, do you know Omega (you said yesterday you were working on a thesis about GADTs)
10:28:09 <palomer> cinema: I've heard of omega, but I've never looked into it
10:29:41 <davidhouse> @index parse
10:29:41 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
10:34:50 <davidhouse> parsec looks like good fun
10:53:37 <sieni> ghc debian package maintainers here?
10:54:00 <bolrod> debian package maintainers?....
10:54:13 <bolrod> do they exist?
10:54:14 <bolrod> :P
10:54:27 <sieni> wtf?
10:54:31 <Igloo> sieni: Yes?
10:54:54 <sieni> ghci refuses to start on my pal's sparc64 Linux box
10:55:33 <bolrod> strace it
10:55:34 <bolrod> :)
10:56:12 <Igloo> If that's 6.4.1-2 then I'm surprised it doesn't start, but it certainly won't be fully functional. There's an upstream bug about it
10:56:46 <sieni> Well it starts, but dies on the following error:
10:57:08 <sieni> getCurrentDirectory: does not exist (No such file or directory)
10:57:26 <bolrod> hmm..
10:57:30 <sieni> Linux kukka 2.4.27-2-sparc64 #1 Sun Apr 3 05:21:36 UTC 2005 sparc64 GNU/Linux
10:57:42 <sieni> The Glorious Glasgow Haskell Compilation System, version 6.4
10:58:06 <Igloo> That sounds like a problem with new gcc on at least amd64; should be fixed in 6.4.2 due RSN
10:58:07 <bolrod> weird if your current directory is being wiped out beneath your feet ;)
11:00:25 <sieni> RSN?
11:00:32 <sieni> really soon now
11:21:00 <davidhouse> @pl f >>= return . g
11:21:00 <lambdabot> g `fmap` f
11:21:08 <davidhouse> @index fmap
11:21:09 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:21:33 <xerox> @pl \f xs -> xs >>= return . f
11:21:34 <lambdabot> fmap
11:22:06 <davidhouse> > [5,6,7] >>= return . (+1)
11:22:07 <lambdabot> [6,7,8]
11:22:18 <davidhouse> > [5,6,7] `fmap` (+1)
11:22:19 <lambdabot> Couldn't match `a -> b' against `[a1]'
11:22:30 <xerox> > (+1) `fmap` [5,6,7]
11:22:31 <lambdabot> [6,7,8]
11:22:36 <xerox> > fmap (+1) [5,6,7]
11:22:37 <lambdabot> [6,7,8]
11:22:52 <davidhouse> > liftM (+1) [5,6,7]
11:22:52 <lambdabot> [6,7,8]
11:22:57 <xerox> Right.
11:23:00 <davidhouse> fmap and liftM seem very similar
11:23:07 <xerox> They're the same thing.
11:23:11 <davidhouse> oh good. :)
11:25:10 <davidhouse> but fmap is more general?
11:25:11 <SimonRC> here's and odd thing:
11:25:21 <davidhouse> as fmap applies to any old Functor, but liftM only to Monads.
11:25:25 <SimonRC> @pl \ f g h x = f (g x) (h x)
11:25:26 <lambdabot> (line 1, column 11):
11:25:26 <lambdabot> unexpected "="
11:25:26 <lambdabot> expecting pattern or "->"
11:25:31 <SimonRC> @pl \ f g h x -> f (g x) (h x)
11:25:31 <xerox> Monads are Functors.
11:25:32 <lambdabot> liftM2
11:25:56 <davidhouse> xerox: a monad is a type of functor, i think
11:26:18 <davidhouse> SimonRC: functions of type (->a) form a monad
11:26:41 <davidhouse> > liftM (+) (*2) (-5) 10
11:26:41 <lambdabot> 0
11:26:42 <SimonRC> hmm
11:26:44 <xerox> (a ->) I believe.. ?
11:26:48 <davidhouse> wow, nice coincidence.
11:27:02 <SimonRC> xerox: sounds more likely
11:27:10 <davidhouse> yeah, probably.
11:27:12 <xerox> I.e. Reader.
11:27:13 <davidhouse> i don't really understand that.
11:27:35 <davidhouse> > (-5) 10
11:27:35 <lambdabot>  add an instance declaration for (Num (t -> a))
11:27:39 <xerox> It's simple, in fact, if you add (a ->) to some time, it adds an argument--i.e. it adds an environment.
11:28:19 <davidhouse> > liftM2 (+) (*2) (5`subtract`) 10
11:28:19 <SimonRC> unfortunately:...
11:28:20 <lambdabot> 25
11:28:25 <davidhouse> better.
11:28:48 <SimonRC> @pl \ f g x y -> f (g x) (g y)
11:28:48 <lambdabot> join . ((flip . ((.) .)) .) . (.)
11:28:52 <SimonRC> :-D
11:28:59 <davidhouse> although you shouldn't ever use subtract infix.
11:29:01 <TuringTest> :(
11:29:03 <davidhouse> SimonRC: aargh!
11:29:27 <SimonRC> @pl \(a,b,c,d,e,f) -> (f,e,d,c,b,a)
11:29:28 <lambdabot> (line 1, column 6):
11:29:28 <lambdabot> [3 @more lines]
11:29:40 <SimonRC> @more
11:29:40 <lambdabot> unexpected ","
11:29:40 <lambdabot> expecting letter or digit, operator or ")"
11:29:40 <lambdabot> ambiguous use of a non associative operator
11:29:51 <SimonRC> @pl \ (a,b,c,d,e,f) -> (f,e,d,c,b,a)
11:29:51 <lambdabot> (line 1, column 7):
11:29:51 <lambdabot> [3 @more lines]
11:29:54 <SimonRC> @more
11:29:54 <lambdabot> unexpected ","
11:29:54 <lambdabot> expecting letter or digit, operator or ")"
11:29:54 <lambdabot> ambiguous use of a non associative operator
11:29:57 <davidhouse> huh?
11:29:58 <TuringTest> Hmm... c2hs needs Cabal > 1.0 and Cabal < current 1.1.3, does anyone know a source of Cabal 1.0.1 ?
11:29:58 <orbitz> can lambda bot run anything or does it andbox things
11:29:59 <SimonRC> eh?
11:30:07 <davidhouse> orbitz: pretty much anything
11:30:10 <xerox> > runReader (do { env <- ask; return (reverse env) }) "tnemnorivne eht saw siht" :: Int
11:30:11 <lambdabot> Couldn't match `Int' against `[a]'
11:30:15 <xerox> > runReader (do { env <- ask; return (reverse env) }) "tnemnorivne eht saw siht" :: String
11:30:16 <lambdabot> "this was the environment"
11:30:17 <orbitz> davidhouse: that's not a liability?
11:30:27 <davidhouse> orbitz: come up with some damaging code
11:30:31 <xerox> See?
11:30:46 <TuringTest> Not another round of "crash the lambdabot"...
11:30:48 <davidhouse> xerox, see what?
11:30:56 <xerox> How the Reader works.
11:31:01 <davidhouse> yes.
11:31:07 <xerox> Cool.
11:31:10 <davidhouse> State, Parsec are similar.
11:32:07 <SimonRC> I believe a bot that that ran Template Haskell managed to get exploited once.
11:32:09 <Philippa> orbitz: it does sandbox things
11:32:15 <Philippa> specifically, you can't do IO
11:32:31 <orbitz> Philippa: ah figures
11:32:31 <Philippa> SimonRC: sneaking IO in via the back door
11:32:53 <sieni> mmm... back door
11:32:54 <orbitz> what about...opening or closing files?  is that consdered I/O (or a call to the os's unlink)
11:33:04 <SimonRC> the exploit was only comprehensible by a few people in the whole world, IRRC
11:33:05 <xerox> Yes, those actions have IO type.
11:33:12 <xerox> SimonRC: point. :-)
11:33:18 <SimonRC> *IIRC
11:33:45 <davidhouse> > execState (modify reverse) "tnemnorivne eht saw siht"
11:33:45 <lambdabot>  Not in scope: `modify'
11:33:47 <davidhouse> ?
11:34:03 <davidhouse> > Control.Monad.State.execState (Control.Monad.State.modify reverse) "tnemnorivne eht saw siht"
11:34:04 <lambdabot>  Not in scope: `Control.Monad.State.modify'
11:34:14 <davidhouse> @type Control.Monad.State.modify
11:34:15 <lambdabot> forall (m :: * -> *) s.
11:34:15 <lambdabot>           (Control.Monad.State.MonadState s m) =>
11:34:15 <lambdabot>           (s -> s) -> m ()
11:34:20 * davidhouse kicks lambabot
11:34:51 <davidhouse> works on my GHCi.
11:35:00 <davidhouse> xerox, why were you showing me Reader?
11:35:21 <xerox> I thought you said "I don't really understand that."
11:35:41 <davidhouse> i meant functions of the type (a->) being a monad, sorry.
11:36:31 <davidhouse> oh, wait
11:36:35 <davidhouse> yes i do.
11:36:45 <davidhouse> i forgot about monads having kind * -> *
11:37:13 * davidhouse wonders what the instance definition is
11:38:01 <davidhouse> > (+2) >> (+3)
11:38:02 <lambdabot>  add an instance declaration for (Show (a -> a))
11:38:11 <davidhouse> > ((+2) >> (+3)) 5
11:38:12 <lambdabot> 8
11:38:17 <davidhouse> ah, i get it.
11:38:47 <davidhouse> > ((+2) >>= (+)) 5 -- should be 14, if i understand
11:38:48 <lambdabot> 12
11:39:23 <davidhouse> no, that does make sense. 12 is right.
11:39:56 <davidhouse> > (return 2) 5 -- 2?
11:39:57 <lambdabot> 2
11:40:11 <davidhouse> because that creates the function \5 -> 2 and runs it on 5.
11:40:48 <TuringTest> davidhouse: The instance declaration is here http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
11:41:16 <davidhouse> TuringTest: i'm not talking about Reader.
11:41:17 <davidhouse> am i?
11:41:31 <TuringTest> That is where Monad ((->) a) is defined
11:41:42 <vincenz> I still don't get how that works
11:41:51 <vincenz> for the monad (->) a
11:42:00 <TuringTest> vincenz: look at the link for the short definition
11:42:03 <davidhouse> vincenz: >>= is composition
11:42:17 <davidhouse> return is const.
11:42:37 <davidhouse> e.g. return 5 is const 5.
11:42:50 <TuringTest> And it is also a MonadFix....interesting
11:43:16 <davidhouse> err, >>= isn't quite composition.
11:43:21 <davidhouse> m >>= k = \r -> k (m r) r
11:43:35 <TuringTest> 'local' is composition
11:43:57 <TuringTest> local = flip (.)
11:44:03 <davidhouse> e.g. (+2) >>= (+) creates \r -> (+) ((+2) r) r, which is \r -> (r + 2) + r
11:44:38 <davidhouse> ah, they're also instances of MonadReader. now i see what TuringTest is talking about :)
11:45:10 <TuringTest> davidhouse: Thus you must "import Control.Monad.Reader" to get Monad ((->) a)
11:45:17 <vincenz> I don't get the MonadReader bit
11:45:51 <TuringTest> newtype Reader r a = Reader { runReader :: r -> a }
11:46:02 <davidhouse> computations in Reader share a common environment
11:46:03 <TuringTest> So a "Reader" is a function from r to a
11:46:19 <vincenz> yep
11:46:39 <davidhouse> which can be modified, but not permanently like in State.
11:46:40 <TuringTest> So all functions that take the environment and return a are "Reader r a"
11:46:52 <vincenz> yeah but local f m = m . f
11:47:19 <TuringTest> Which changes from "Reader r a" to "Reader s a" via "f :: r -> s"
11:47:49 <vincenz> what's the m
11:47:57 <TuringTest> So "m :: Reader s a" where "local f m :: Reader r a"
11:48:02 <vincenz> ah
11:48:06 <TuringTest> @type local
11:48:07 <lambdabot> Not in scope: `local'
11:48:15 <TuringTest> @type Control.Monad.Reader.local
11:48:15 <lambdabot> forall r (m :: * -> *) a.
11:48:15 <lambdabot>           (Control.Monad.Reader.MonadReader r m) =>
11:48:15 <lambdabot>           (r -> r) -> m a -> m a
11:48:41 <TuringTest> Okay type r and s are the same, my bad.
11:49:03 <vincenz> I have to say that the readermonad seems very inefficient
11:49:22 <TuringTest> withReader maps from different r to s
11:49:34 <davidhouse> vincenz, i have an example of it in use if you'd like to see it
11:49:58 <TuringTest> vincenz: Think of Reader as a State monad with "get==ask" and no set function
11:50:07 <vincenz> davidhouse: sure
11:50:14 <TuringTest> vincenz: So it is an optimized State monad
11:50:23 <vincenz> right
11:50:27 <vincenz> but you can do local
11:50:34 <vincenz> to run local things with bigger environments
11:50:50 <vincenz> for an ast for instance
11:51:00 <davidhouse> vincenz: http://paste.lisp.org/display/18004
11:51:16 <davidhouse> it's a simple lambda calculus evaluator
11:51:20 <vincenz> davidhouse: ah that wast he the thing I was thinking about
11:51:23 <vincenz> not quite an ast but heh
11:51:46 <davidhouse> ast?
11:51:54 <vincenz> abstract syntax tree
11:53:00 <davidhouse> @index parse
11:53:00 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
11:53:25 <palomer> hrmph
11:53:28 <palomer> where's ski when you need'em
11:53:30 <palomer> @seen ski
11:53:30 <lambdabot> I saw ski leaving #haskell 6 hours, 16 minutes and 7 seconds ago.
11:53:35 <palomer> nooooo
11:53:48 <palomer> anyone here ever done logic programming?
11:54:29 <vincenz> @where hac
11:54:29 <lambdabot> http://haskell.org/haskellwiki/HAC
11:55:12 <palomer> hac looks awesome
11:55:37 <davidhouse> wow, nice
11:58:03 <palomer> hrmph, looks like I'm going to have to look into logic programming and anti-unification
12:00:36 <palomer> ski_: ping
12:03:13 <Cale> @palomer
12:03:13 <lambdabot> hrmph
12:03:20 <palomer> @palomer
12:03:21 <lambdabot> hrmph
12:03:23 <davidhouse> heh!
12:03:25 <palomer> hrmph
12:03:35 <palomer> Cale: do you know anything about logic programming?
12:03:46 <Cale> not too much
12:03:59 <Cale> I've written a little bit of prolog code
12:04:11 <palomer> I have the following problem: given a value, I want to find all possible ways to get that value
12:04:20 <davidhouse> that's a bit vague
12:05:11 <palomer> err, no way
12:05:31 <palomer> if all I have is succ and zero, the only way to get succ zero is by applying succ to zero
12:05:48 <palomer> if I also have addition, then there are 2 ways to get succ zero
12:05:57 <palomer> (succ zero) and add (succ zero) zero
12:06:08 <palomer> oh, and add zero (succ zero)
12:06:14 <Cale> sure
12:06:24 <palomer> I want a general method for doing this
12:06:44 <Cale> With just addition and succ and zero?
12:07:03 <palomer> well
12:07:07 <palomer> with a finite list of functions
12:07:40 <Cale> Note that if you have pred as well (i.e. you're working in the integers), you'll have infinitely many solutions
12:08:00 <palomer> yeah
12:08:13 <Cale> I'm also fairly sure that the general case won't be decidable.
12:08:46 <palomer> well, erm, if you assume that there are a finite number of solutions it is!
12:08:59 <Cale> no, probably not
12:09:29 <palomer> well, erm, I'm pretty sure it is. so there.
12:09:36 <palomer> :P
12:09:37 <Cale> even just determining if there is a solution is undecidable
12:09:48 <palomer> are you positive?
12:10:21 <palomer> well, if you ever loop then you stop
12:10:24 <Cale> Pretty much. If you implement the general case, you can give it to me, and I'll make millions of dollars with it :)
12:11:04 <Cale> (the general case being arbitrary functions and an arbitrary goal)
12:11:19 <davidhouse> is there a handy function for converting Eithers into Maybes?
12:11:45 <Cale> either (const Nothing) Just
12:11:45 <davidhouse> case e of Left _ -> Nothing; Right a -> Just a
12:11:53 <davidhouse> @type either
12:11:54 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
12:12:00 <davidhouse> oh, nice.
12:13:16 <palomer> how do you know it's undecidable?
12:14:22 <palomer> here's the deal, let's say you have pred
12:14:30 <palomer> and your goal is zero
12:14:49 <palomer> then you'll have an infinite number of solutions
12:14:58 <Cale> sure
12:14:58 <palomer> but it could be finitely representable
12:15:02 <palomer> for example:
12:15:17 <palomer> pred x x, zero
12:15:31 <palomer> this covers all cases
12:16:01 <palomer> now, I think it's always finitely representable
12:16:07 <palomer> and, furthermore, decidable
12:16:11 <davidhouse> okay, Parsec question. i want to parse both "(whatever)?" and "(whatever)*". i tried to do it with between (char '(') (string ")?") ..., but that always starts matching on the first, so if it ever comes across a pattern looking like the latter it errors.
12:16:46 <davidhouse> sorry, i tried to do it with two rules: between (char '(') (string ")?") ... and between (char '(') (string ")*") ...
12:17:01 <Cale> davidhouse: right, you should push the decision between * and ? inward
12:17:23 <davidhouse> Cale, what do you mean?
12:17:26 <Cale> or factor it out completely from the parens
12:17:27 <davidhouse> really new to parsec.
12:17:38 <Cale> Parsec normally generates LL1 grammars
12:18:00 <Cale> which means that it looks ahead only one character to decide which branch to take
12:18:09 <davidhouse> right.
12:18:11 <Cale> (and if it took the wrong one, too bad)
12:18:26 <Cale> If you want more lookahead, you can use try
12:18:49 <Cale> which modifies a parser such that when it fails, it won't have consumed any input
12:18:57 <davidhouse> so i need something like between (char '(') (char ')' >> char '*' <|> char '?') ..., then branch on the third parser?
12:19:04 <Cale> this hurts performance though, since you'll do lots of backtracking
12:19:10 <Cale> yeah
12:19:15 <davidhouse> cool. thanks.
12:20:27 <davidhouse> hmm
12:20:42 <davidhouse> how do i branch? how can i tell if it matched '*' or '?'?
12:21:21 <Cale> c <- (char '*' <|> char '*')
12:21:28 <Cale> er
12:21:30 <Cale> c <- (char '*' <|> char '?')
12:21:57 <Cale> c will be an appropriate Char
12:22:26 <davidhouse> right. thanks.
12:22:37 <davidhouse> Cale, gotta go, but thanks for your help.
12:22:43 <davidhouse> much experimentation ahead :)
12:24:19 <Cale> palomer: let's say I have one constant to start with, c, and one function f, which, when applied to its argument, if that argument is even, divides it by 2, and if it's odd, multiplies it by 3 and adds 1. Let's say my goal is 1. Can you prove that it will find a solution for every c?
12:24:31 <Cale> (or determine that there is none)
12:26:18 <palomer> given a particular c I could tell you if there's a solution
12:26:23 <Cale> really?
12:26:32 <Cale> If you assume that a solution exists, sure
12:26:37 <Cale> but what if there's no solution?
12:27:03 <palomer> oh, you can assume that there is at least one solution
12:27:14 <adu> bah!
12:27:21 <palomer> in fact, you can assume that I have one solution
12:27:38 <palomer> (so, admittedly, this is a different problem)
12:27:45 <adu> no solution just means you gotta squeeze that round peg until it fits in the square hole
12:28:09 <palomer> ok, this is my actual problem:
12:28:21 <palomer> given n solutions, show that there are no others
12:28:28 <palomer> or, rather, decide if there are no others
12:28:39 <palomer> where n is greater or equal to 1
12:29:35 <Cale> are there types?
12:29:46 <palomer> nope
12:29:59 <palomer> actually, yes
12:30:00 <palomer> there are
12:30:13 <palomer> actually, let's change my problem again
12:30:18 <Cale> Just wondering if it's always valid to apply any of the functions you have to any value
12:30:52 <palomer> given a type, and a list of inhabitants with wildcards, find if this inhabitant bases is complete
12:31:13 <palomer> with a little twist: constructors have have _arbitrary_ types
12:31:17 <Cale> oh, a type like in Haskell?
12:31:23 <palomer> Cale: yeah
12:32:29 <palomer> so, for example, let's say you have a type GZero and a type GSucc
12:32:31 <Cale> that's probably easier, though there are still issues with function types
12:32:51 <palomer> GZero::* has one constructor, GZ
12:33:55 <palomer> GSucc has 2 constructors: FZ:: GZero -> GSucc GZero, FS::forall a. GSucc a -> GSucc (GSucc a)
12:34:31 <palomer> actually
12:34:37 <palomer> make FZ::GZero
12:34:47 <palomer> err
12:35:09 <palomer> make FOne:: GSucc GZero
12:35:38 <palomer> now, the only inhabitant of (GSucc (GSucc GZero)) is FSucc FOne
12:36:28 <palomer> however, I can add another constructor to GSucc which is FPred:: forall a. GSucc (GSucc x) -> GSucc x
12:36:43 <palomer> err, forall x
12:36:53 <palomer> (do you understand what I'm doing?)
12:37:01 <Cale> not really
12:37:09 <palomer> ok, we have these GADTs
12:38:21 <palomer> lemme write this out in a paste
12:39:45 <palomer> http://www.rafb.net/paste/results/2PYskm29.html
12:41:21 <palomer> oooh, I know how to do this: disallow things like FP
12:42:20 <palomer> so all my functions can only make bigger types
12:42:32 <palomer> then, of course, it becomes decidable
12:43:08 <Cale> yeah, probably
12:43:15 <ihope> @djinn (forall a. a) -> b
12:43:15 <lambdabot> -- f cannot be realized.
12:43:18 <ihope> :-)
12:43:37 <palomer> Cale: you understand what GNat is, right?
12:44:25 <Cale> a funny representation of the naturals
12:44:47 <palomer> yup
12:45:05 * palomer wonders if this would compile in ghc
12:45:08 * palomer pokes Lemmih
12:46:27 <palomer> I have to think about this more
12:46:28 <palomer> bbl
12:56:02 <lightstep> does the Num instance of Data.Fixed.Fixed have range checking? are the instances specified anywhere?
13:01:18 <robokop> is there another option for getLine where backspace works instead of haskell seeing it as a char
13:02:01 <Lemmih> robokop: There are readline bindings.
13:02:37 <robokop> Lemmih uhm i'm quite new to haskel so what do you mean
13:05:22 <Lemmih> robokop: Try running System.Console.Readline.readline "> " in ghci
13:06:19 <robokop> will do
13:07:01 <robokop> thanks i think that will solve my probs
13:07:50 <ihope> > let 07orange = 3 in orange
13:07:50 <lambdabot>  lexical error
13:09:14 <adu> wow how did you do that ihope
13:09:34 <rasfar> yeah! that was neat!
13:09:47 <ihope> Let's see here...
13:09:52 <xerox> mIRC colors notation.
13:10:08 <robokop> Lemmih but why does it give a IO (maybe string)
13:10:09 <Philippa> it's not mIRC-specific
13:10:10 <adu> ihope : hey! don't be versioning me on the first date!
13:10:13 <Philippa> although it's an abomination nevertheless
13:10:18 <adu> ;)
13:10:20 * ihope giggles
13:10:38 <ihope> For BitchX: http://faq.bitchx.org/view_faq.php?tag=What+are+the+color+codes+in+BitchX%3F+How+do+I+use+them%3F
13:10:44 <adu> let orange
13:10:46 <Philippa> How do you know I don't have an orange background?...
13:10:48 <adu> let \orange
13:10:57 <xerox> robokop: because it's an action doing I/O which can either return a String or fail?
13:11:14 <robokop> but when would it fail
13:11:26 <xerox> Maybe there's something written in the doc?
13:11:40 <robokop> ke but i'm even more lazy then haskell
13:11:52 <xerox> @docs System.Console.Readline
13:11:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/readline/System-Console-Readline.html
13:12:10 <xerox> @libsrc System.Console.Readline
13:12:10 <lambdabot> http://darcs.complete.org/fptools/libraries/readline/System/Console/Readline.hs
13:12:55 * ihope thinks how Lambdabot could be made to infinite loop with another bot via @time
13:13:08 <adu> let %R
13:13:27 <lightstep> @type
13:13:27 <lambdabot> not an expression: `'
13:13:33 <lightstep> @time
13:13:56 <ihope> Well, a private message is required to "start it".
13:14:23 <ihope> And @time *sends* a private message...
13:14:37 <adu> let %Rorange%n
13:16:33 <adu> let $cparse(%Rorange%n)
13:17:05 <adu> let $cparse("%Rorange%n")
13:21:39 <adu> hi
13:22:09 <adu> let [1;31morange[0m[0m
13:22:16 <adu> yey i did it!
13:22:35 <ihope> Well, you did something.
13:22:44 <ihope> I didn't see much color.
13:22:59 <adu> oh ok
13:24:05 <Korollary> I saw red
13:24:07 <adu> maybe it was just the >orange
13:26:45 <adu> Korollary : do you see [0;31mred[0m[0m ?
13:26:55 <Korollary> yes, dark red now.
13:27:07 <Korollary> but my terminal is a bit whacked, so it may not be your fault.
13:27:25 * xerox sees dead peo^W^Wtoo.
13:27:31 <adu> Korollary : and %cparse(%Ggreen%n) and [1;34mblue[0m[0m ?
13:27:43 <adu> crap i spelled it wrong
13:28:36 <Korollary> blue is blue.
13:28:37 <jyp> NOTE: Simplifier still going after 4 iterations; bailing out.
13:28:45 <Korollary> heh
13:29:17 <jyp> It's sentence I'm seeing the most these days.
13:33:24 <palomer> Cale: you around?
13:45:10 <palomer> dons: I wasn't asking about putting really big numbers at the type level
13:46:33 <palomer> though, erm, I don't see why it couldn't be done
14:21:06 <kpreid_> http://foldr.com/
14:23:38 <psi> hehe. there is http://foldl.com as well.
14:24:02 <dcoutts> psi, that's rather nice
14:25:44 <kpreid_> http://osteele.com/archives/2006/03/foldr
14:27:45 <franka> That's cute.
14:29:17 <franka> It would be useful if it did the fold on the referrer or something.
14:35:45 <dcoutts> dons, ping
15:20:41 <vincenz> how do you do colors?
15:21:00 <vincenz> %cparse(%Rorange%)
15:21:05 * vincenz shrugs
15:23:16 <ihope> So both notices *and* CTCP requests are frowned upon? ;-)
15:27:06 <heatsink> I got this error:     GHC internal error: `v' is not in scope
15:27:37 <heatsink> And while trying to find a minimal example that reproduces the error, I discovered that the error goes away if I change the order of some function definitions at the module level.
15:27:43 <heatsink> Should this happen?
15:28:36 <basti_> that sounds a bit like a bug.
15:29:55 <Igloo> heatsink: You aren't using TH, are you?
15:30:08 <heatsink> I am using template haskell, but not in the affected function.
15:30:23 * Igloo would need to see it to comment further
15:30:44 <basti_> oh that changes things, of course
15:32:58 <heatsink> Well, the module about 1200 lines of code.  I've shortened the function where the error is reported to six lines of code, but the error only happens when that function calls certain other module-level functions.
15:33:18 <heatsink> I could show you the whole module, I guess.
15:34:05 <Lemmih> How do you put quotes around a cpp defined value?
15:34:51 <heatsink> #define ABC_STRING "abc"
15:38:16 <Lemmih> n/m.
15:42:34 <Lemmih> dons: ping.
16:06:28 * heatsink identified the bug finally
16:06:52 <heatsink> interestingly, this GHC bug only shows up if there's a function call cycle in the right place
16:08:11 <astrolabe> Is it a known bug?
16:08:38 * heatsink is looking through the bug repository now
16:12:16 <heatsink> Doesn't seem to be a known bug.
16:12:21 * heatsink submits report
16:23:48 <vincenz> ?
16:24:40 <heatsink> yes.
16:26:13 <vincenz> about what
16:26:16 <vincenz> what's the bug?
16:26:53 <vincenz> Lemmih: hi
16:27:57 <heatsink> The bug is that a kind error in one function causes an error about a type variable being out of scope in another function, even though that type variable is local to that function.
16:28:39 <heatsink> http://cvs.haskell.org/trac/ghc/ticket/734
16:29:04 <vincenz> oy
16:29:10 <vincenz> sounds nasty
16:30:16 <vincenz> heatsink: out of curioustiy
16:30:19 <vincenz> what's the use of that type
16:30:22 <vincenz> it contains no data
16:30:59 <heatsink> I just took out the data to simplify the bug report.
16:31:46 <vincenz> ah
16:36:29 <TuringTest> Hmmm.. Trying to install WaSH.  For the database it needs the c2hs package.  But to build c2hs requires Cabal > 1.0 and < current 1.1.3 
16:36:39 <TuringTest> Is there a source of intermediate versions of Cabal?
16:41:13 <ihope> > fromEnum 126 :: Char
16:41:14 <lambdabot> Couldn't match `Char' against `Int'
16:41:20 <ihope> > toEnum 126 :: Char -- bah
16:41:21 <lambdabot> '~'
17:50:21 <dons> moin
17:50:33 <Korollary> good \localtime
17:50:41 <dons> :)
17:53:56 <vincenz> :)
17:54:01 <greenrd> I have an optimisation question
17:54:05 <dcoutts> dons!
17:54:10 <vincenz> hey dcoutts dons
17:54:16 <dcoutts> hi vincenz 
17:54:27 <dcoutts> dons, I hear you might know something about ghc on mips
17:54:47 <dons> yo
17:54:47 <greenrd> If I call primesLessThan n from different functions, I think it might be evaluated multiple times for the same value of n, which is wasteful
17:54:49 <dons> yep.
17:55:02 <dons> I think I may even be Mr. Mips :)
17:55:13 <dons> mips64, at least
17:55:28 <vincenz> greenrd: make a list
17:55:30 <dons> i never had much success with mips of the 32 bit variety
17:55:38 <vincenz> greenrd: then reuse that list
17:55:49 <vincenz> greenrd: but either wawy
17:56:04 <dons> yep, just allocate the result and share it
17:56:06 <greenrd> OK. If I instead say let foo = primesLessThan n in map blah (tails foo), and that's the only place I call it, does that guarantee that the list will only be evaluated once
17:56:10 <vincenz> let primesLess = [primesLessThan n | n <- [1..]]
17:56:23 <vincenz> then you can do
17:56:26 <vincenz> primesLess !! 5
17:56:29 <vincenz> to get primesLessThan 5
17:56:51 <greenrd> ahh
17:56:52 <greenrd> nice
17:56:57 <dons> hehe, very open source: Premier Steve Bracks [of Victoria] last week dismissed support for the idea [of free public transport] saying people would also support free beer.
17:57:46 <vincenz> greenrd: tho note that then your list will be allocated and never deallocated until you quit the program
17:57:53 <vincenz> typical optimization : space vs computation
17:57:58 <dcoutts> dons, so mips64, that's a 64bit kernel but 32bit userspace?
17:58:09 * vincenz thinks that data and computation are naturally isomorphic
17:58:13 <dons> i've only used ghc on an sgi/irix box
17:58:21 <dons> they have dual 32 and 64 bit 
17:58:27 <dcoutts> dons, or is it that funny 64/32bit mix where instructions are 64bit but pointers are 32bit?
17:58:30 <dons> so i think it was a 32 bit kernel, with 32 and 64 bit user space
17:58:41 <dons> nope. the mips64 port was pure 64 bit
17:58:46 <dcoutts> oh ok
17:58:56 <dons> it appears to the user as if it is a full 64 bit box.
17:59:05 <dons> and works really well unregistereiised
17:59:08 <dons> no -fasm though
17:59:09 <dons> or ghci
17:59:09 <dcoutts> dons, so you've got ghc-6.4.1 running on mips?
17:59:14 <greenrd> But what actually guarantees that the list will never be deallocated?
17:59:21 <dons> on mips64
17:59:30 <dons> not on mips32 of any kind.
17:59:34 <dcoutts> mips64 right
17:59:34 <greenrd> Since it is a constant, surely the compiler could decide to make it a soft reference that goes away when there is lack of memory?
17:59:41 <dons> I couldn't get a bootstrap to the 32 bit version working
17:59:54 <dcoutts> dons, you see I'm trying to get it to work on mips linux
17:59:58 <dons> but yes, works well, and stable.
18:00:02 <greenrd> I know that's probably a bit advanced but it could be done
18:00:22 <dcoutts> dons, irix uses ELF right?
18:00:48 <dons> yep
18:01:07 <dcoutts> what problems did you get with the 32bit attempt?
18:01:58 <dons> oh, hmm. segfaults in the tage 2 compiler. so when the 64 bit version worked 'out of the box' on the same machinne, I didn't chase it up
18:02:06 <dcoutts> ok
18:02:15 <dons> this was a whhle ago
18:02:26 <dcoutts> I think we were having a problem with "GOT overflow" on linux
18:02:45 <dcoutts> ghc produces loads of linker symbols and this was causing problems
18:02:47 <dons> oh, hmm. I've definitely seen GOT warnings
18:03:04 <dcoutts> I don't really understand the issue however
18:03:20 <ihope> What's the preferred method of converting programmers to Haskell?
18:03:29 <dcoutts> ihope, drugs
18:03:59 <ihope> I understand that doing so is only slightly more difficult than getting said programmers to switch religions.
18:04:08 <dcoutts> dons, so you reckon we should try the standard documented porting method for mips64
18:04:25 <greenrd> vincenz, for that matter, what guarantees that the list is actually ever stored statically?
18:04:36 <dcoutts> dons, eg starting from .hc files generated on something else like x86
18:04:44 <greenrd> vincenz, given that the compiler could just choose to reevaluate the list from scratch each time?
18:05:15 <Korollary> ihope: one of the most effective ways of capturing developers' hearts is giving away lots of free code.
18:05:22 <stepcut> ihope: so far one of the best methods has been to write cool programs that they will want to work on (pugs, darcs, etc)
18:05:28 <ihope> Hey, good ideas.
18:05:51 <Korollary> "webserver in one line yay!"
18:06:07 <ihope> :-D
18:06:12 <greenrd> well, pugs is a toy project and darcs is based on ideas from quantum physics that ordinary developers would have difficulty understanding
18:06:27 <greenrd> we need more down-to-earth projects written in haskell IMO
18:06:38 <vincenz> greenrd: that's the way it's built
18:06:46 <ihope> Darcs is based in quantum physics?
18:06:56 <vincenz> yeah
18:07:01 <vincenz> that's what the author states
18:07:10 <greenrd> vincenz, you mean ghc?
18:07:35 <greenrd> vincenz, because I'm wondering if the same would necessarily be true in any haskell implementation
18:07:56 <Korollary> there are down to earth stuff written in haskell a la yi, hmp3 for instance.
18:08:13 <vincenz> greenrd: it's so by default
18:08:23 <vincenz> greenrd: basically a list is a list... but haskell generates it lazily
18:08:27 <vincenz> greenrd: but once generated it shoudl be a list
18:08:37 <vincenz> look at it this way, if it were an eager language
18:08:43 <vincenz> it'd take an infinite amount of time to build the infinite list
18:08:48 <greenrd> sure
18:08:50 <vincenz> haskell just delays when the elements are constructed
18:08:58 <vincenz> but once constructed they remain there
18:09:22 <greenrd> but that means haskell updates stuff on the heap!
18:09:26 <greenrd> zomg, haskell has state! ;)
18:09:35 <ihope> :-)
18:09:47 <greenrd> it's just invisible
18:09:49 <Korollary> well at some point it's GC'd
18:09:59 <greenrd> it is?
18:10:27 <vincenz> Korollary: not that list
18:10:37 <vincenz> Korollary: a toplevel list
18:10:49 <Korollary> that is gc'd somewhere too heh
18:10:52 <greenrd> oh, that's what I was thinking of too
18:10:58 <greenrd> a toplevel list
18:11:10 <vincenz> Korollary: only when the program quits
18:11:21 <vincenz> at which point gcing becomes moot
18:11:28 <greenrd> but then I read back up and realised that vincenz actually suggested a list in a let-clause
18:11:37 <vincenz> greenrd: well no
18:11:41 <vincenz> greenrd: let at top level
18:11:46 <vincenz> or just plainly... without let
18:11:49 <greenrd> oh
18:11:54 <stepcut> greenrd: how about yi or hmp3 ?
18:12:07 * vincenz doesnt think hmp3 constitutes a haskell program
18:12:15 <vincenz> it just makes some curses calls from a haskell shell
18:12:17 <greenrd> I haven't tried those
18:12:22 <vincenz> and some calls to mpg123
18:12:55 <stepcut> someone suggested an email client on the mailing list...
18:13:16 <palomer> grr, c++ and its pass by value semantics bothers me.
18:14:02 <vincenz> palomer: use references
18:14:23 <palomer> it's more like the philosophy of c++ bothers me
18:14:30 <stepcut> palomer: me too :)
18:14:36 <palomer> "if you want to pass by name, use pointers"
18:14:45 <palomer> but sometimes I want to pass by value with pointers!
18:15:05 <palomer> they should just do like java and pass by reference all the time
18:15:06 <vincenz> palomer: what bugs me about c++ is its non-orthogonal base, its large set of constructs that don't mix lightly, and the fact that it's the bitchies program to write optimizers for cause if anyone uses lowlevel constructs like goto or uses pointes in the wrong way, it fucks up
18:15:11 <greenrd> I hear windows vista is still mostly written in unmanaged code - presumably that means in C++!
18:15:25 * greenrd shudders
18:15:56 * vincenz wants an imperative language with oo but with a haskell-type system
18:16:12 <greenrd> cool, that's what I'm working on
18:16:19 <greenrd> kind of
18:16:29 <vincenz> really?
18:16:42 <stepcut> vincenz: http://homepages.cwi.nl/~ralf/OOHaskell/ ;)
18:16:43 <greenrd> unfortunately, I don't really understand the finer points of the haskell type system, so I'm kind of handicapped ;)
18:16:54 <vincenz> stepcut: not quite what I had in mind
18:17:06 <vincenz> stepcut: I'd want it to be an eager language
18:17:06 <greenrd> stepcut, that's not imperative
18:17:13 <palomer> vincenz: ocaml
18:17:20 <vincenz> palomer: imperative
18:17:21 <Korollary> ok. don't use c++ for windows vista. Then find a couple of thousand devs well versed in <insert other language suitable for OS development>
18:17:22 <greenrd> stepcut, well, the examples are, but that was only for convenience
18:17:31 <vincenz> you want something that appeals to developers at large in the c++ or java sense
18:17:31 <stepcut> vincenz: ocaml is pretty imperative in my opinion
18:17:32 <palomer> eager but not imperative?
18:17:34 <vincenz> but that has a strong type sstem
18:17:43 <vincenz> stepcut: I've done ocaml, it's not what I want
18:17:59 * vincenz used to use ocaml pervasively until he started using haskell
18:18:10 * stepcut can't stand ocaml
18:18:44 <palomer> how is ocaml not what you're looking for?
18:18:51 <Korollary> missing typeclasses?
18:18:59 <palomer> typeclasses + objects = funkiness
18:19:05 <greenrd> Korollary, but most of windows vista is not time-critical or driver code, I would assume. Surely it's mostly GUIs and "enterprise message passing" and IE and all that crap.
18:19:08 <palomer> I don't see how the 2 can mix
18:20:00 <vincenz> palomer: no
18:20:07 <vincenz> palomer: typeclasses parallelized to objectclasses
18:20:08 <stepcut> vincenz: slate maybe ? http://slate.tunes.org/
18:20:13 <vincenz> they form natural paralleles
18:20:19 <ihope> > .96 ^ 25
18:20:20 <lambdabot>  parse error on input `.'
18:20:24 <ihope> > 0.96 ^ 25
18:20:25 <lambdabot> 0.3603967168580183
18:20:47 <greenrd> I haven't used OO recently
18:20:48 <vincenz> stepcut: it's typed?
18:20:50 <vincenz> statically
18:21:04 <greenrd> Is it still necessary when you have a type system like Haskell's?
18:21:07 <Philippa> whenever I do something OO like now I end up finding good cause to build the object model
18:21:15 <stepcut> not sure
18:21:20 <Philippa> necessary for what?
18:21:24 <stepcut> Annotate the intended type of a slot or expression with type inference and a extensible independent type system.
18:21:27 <Korollary> it was not necessary for C.
18:21:29 <Philippa> It's still good for a particular class of simulation, for example
18:21:31 <stepcut> (that is a quote from the page)
18:21:44 <greenrd> excluding simulations.
18:22:00 <ihope> Well, it's time to write some Java.
18:22:04 * ihope cries
18:22:07 <greenrd> necessary for abstraction or for more code more readable, say.
18:22:09 <Philippa> outside of simulations I tend to end up with not-quite-OO situations. The way I use concurrency sometimes, for example
18:22:12 <greenrd> I don't know.
18:22:22 <ihope> It's been nice knowing you...
18:22:36 <greenrd> _making_ code more readable
18:22:54 <Philippa> or the plugin model I've been trying to build for Flippi starts to resemble OO, especially if I start thinking about inter-plugin communication for various reasons
18:22:58 <Philippa> but it's not OO per se
18:22:58 <stepcut> vincenz: slate looks cool -- but I never had time to read far enough to see if it really is cool
18:23:16 <Philippa> (it'd be really easy to do in smalltalk though from what I've seen)
18:25:16 <palomer> grr
18:25:21 * palomer has an itch to use shared_ptr everywhere
18:28:43 <vincenz> slate seems dynamically typed
18:28:56 <stepcut> vincenz: http://nice.sourceforge.net/
18:29:32 <vincenz> nice is just a patch on top of java
18:29:55 <stepcut> but it does have static type safety
18:31:00 <stepcut> personally, I am just waiting for epigram to become more usable ;)
18:31:27 <greenrd> vincenz, so if I wrote a piece of template haskell to wrap arbitrary functions of type Int -> Foo so that callers would look up the answer in a list, I could do caching for any such function?
18:31:46 <greenrd> I am waiting to see if epigram's learning curve gets shallower :)
18:31:58 <stepcut> :p
18:37:04 <Philippa> I find it's easier to learn languages I can do "real things" with
18:37:54 <vincenz> @google epigram
18:37:55 <lambdabot> http://www.broadcom.com/
18:38:00 <vincenz> Philippa: I agree
18:38:45 <Philippa> @google epigram epig
18:38:46 <lambdabot> http://www.e-pig.org/epilogue/?m=200511
18:41:32 <stepcut> hrm, that bookmark points to the november archive, wouldn't it be better to point to the front page ?
18:41:49 <stepcut> oh, wait
18:41:55 <stepcut> that is the @google command ;)
18:43:52 <greenrd> hmm, vincenz's suggestion works, as long as the function doesn't try to access its own generating list
18:44:02 <greenrd> if it does, I get <<loop>>
18:44:11 <greenrd> which I don't understand
18:44:24 <greenrd> I think that is a bug
18:45:02 <greenrd> because I would like to be able to cache the intermediate results generated by a recursive function, not just the final result
18:47:01 <greenrd> also, for caching I would rather use an array than a list, but that means monads, yuck
18:48:05 <greenrd> I'll have to add customisable transparent caching strategies as a feature to my imperative functional programming language
18:50:30 <Philippa> if it's imperative anyway then surely it doesn't matter?
18:51:14 <Lemmih> dons: ping.
18:51:17 <greenrd> heh
18:52:04 * vincenz is off
18:53:01 <greenrd> well, it does matter, because although it's imperative (i.e. eager), it still has a haskell-ish type system
18:54:09 <greenrd> so being able to specify memoization as a compiler directive or something rather than using actual code, avoids unnecessarily breaking the purity of a function's type
18:54:50 <greenrd> of course you could do it with an unsafe function as well, but they're unsightly
19:23:45 <dcoutts> dons, so on irix do you have to use any flags like -xgot or -multigot ?
19:23:58 <dcoutts> to deal with GOT overflow problems?
19:24:31 <dcoutts> since the normal GOT size is 2^16 and apparently ghc has more symbols than that
19:25:06 <dcoutts> dons, the irix man page for gp_overflow(5) mentions these linker flags
19:27:34 <Lemmih> dcoutts: Hiya. I've started a rewrite of hIDE.
19:27:42 <dcoutts> Lemmih, oh yes?
19:27:49 <dcoutts> what's new?
19:28:54 <Lemmih> I'm moving away from hs-plugins and plugins will be more light-weight than previously.
19:29:18 <palomer> what will you use instead of hs-plugins?
19:29:27 <Lemmih> I'm bootloading the static core with a small piece of stolen code from GHC.
19:30:04 <Lemmih> And the dynamic core will use the ghc-api.
19:34:00 <palomer> and will yi still integrate as nicely?
19:34:37 <Lemmih> It should integrate even better if all goes as planned.
19:34:41 <tennin> ghc-api requires GHC compiled from darcs source?
19:35:10 <palomer> and why are you moving away from hs-plugins?
19:35:25 <Lemmih> tennin: Yeah, but that's a small price to pay (:
19:35:26 <dcoutts> Lemmih, so still plugins but pinching code from ghc?
19:35:39 <dcoutts> I mean still dynamically loaded plugins?
19:36:25 <Lemmih> dcoutts: Yeah, now we just have the typechecker and bytecode generator at hand.
19:37:09 <dcoutts> Lemmih, I don't understand, what have the typechecker and bytecode generator got to do with how the plugins work?
19:37:11 <Lemmih> We can do neat tricks like, say, running plugins differently depending on their type.
19:37:42 <dcoutts> so are plugins still GHCi-style .o files?
19:38:14 <Lemmih> They can be. They can also just be .hs files.
19:38:21 <dcoutts> oh I see, nice
19:38:24 <Lemmih> So yeah, ghci style.
19:38:45 <dcoutts> and .hs ones get loaded using the ghci bytecode generator
19:39:35 <dcoutts> Lemmih, you should bug me to get the directory/file browser working :-)
19:44:28 <dons> Lemmih, so using ghc-api for the dyn loading?
19:44:34 <dons> or some ghci loader code?
19:45:42 <dons> I'd like to import this interface into hs-plugins 2.0, btw.
19:45:56 <dons> It's always been a goal to use ghci/ghc-api to do ghci-ish loading
19:45:57 <dons> Btw guys, i've got lambdabot running in offline mode :)
19:48:39 <dons> would make a nice hIDE plugin...
19:49:14 <Lemmih> If I've got a macro called GHC_LIBDIR, how do I put quotes around it?
19:53:13 <dons> \bot test
19:53:14 <Korollary> you can't unless gcc has some extensions that allow such a thing.
19:53:14 <lambdabot> :)
20:32:42 <Korollary> what's with the packages without descriptions on hackagedb?
20:40:08 <dancor> so any array update is going to be O(n) in haskell since you have to copy the whole array
20:40:39 <Lemmih> dancor: Yep, unless you use a mutable array.
20:40:57 <dancor> Lemmih: mutable means you record transactions or something
20:41:03 <dancor> Lemmih: ?
20:42:25 <Korollary> no, ghc has these mutable arrays that you can modify in-place.
20:45:20 <Cale> dancor: there's also DiffArrays
20:45:28 <Cale> which are sort of cheating :)
20:46:10 <Cale> basically, the update is done in-place, but the old reference is changed such that it records a list of reversed changes against the current version of the array
20:56:06 <rasfar> hi mwc
20:56:52 <rasfar> say, did your ankle heal up alright?
20:57:28 <rasfar> yes that was long time ago but i guess i'm feeling nostalgic.
20:57:41 <Korollary> you miss his injury? ;)
20:57:47 <rasfar> (i think you were the first person i spoke with on this channel)
20:58:07 <rasfar> well, if you've got any equally exciting x-rays to share....
20:58:27 <rasfar> oh -- it's Korollary :)
20:58:48 <rasfar> anyhow, i guess mwc forgets me
20:58:52 * rasfar pouts
20:59:14 <Korollary> my third eye says he's afk
21:00:03 <rasfar> "away from keyboard" -- i amaze myself i can figure out these acronymjns
21:04:32 <mwc> rasfar, yeah, it did
21:04:34 <mwc> I can run on it
21:04:51 <rasfar> awesome
21:06:20 <mwc> Although, when I wake up or get up from sitting for a while
21:06:33 <mwc> my ankle makes loud cracks when I roll it around
21:07:10 <rasfar> nifty.  does it also now function as abarometer?
21:07:35 <mwc> nope, haven't noticed it at all
21:07:46 <mwc> Tight socks make it sore though
21:12:45 <mwc> thanks for the concern
21:12:57 <mwc> no new cool xrays, haven't managed to refracture it lately
21:13:54 <rasfar> well, you're pretty much home-free from another Canadian winter.
21:14:18 <rasfar> We're supposed to get another wicked snowstorm out here, but I exepct it'll be the last of the season.
21:14:41 <rasfar> And I suppose I should try to talk about Haskell or i'll probably get kicked.
21:14:52 <Korollary> you can join #haskell-blah and continue
21:15:06 <mwc> I just stop being off topic when somebody says something on topic
21:20:28 <palomer> blah
21:21:05 <mwc> whatever it is, not as bad as the mistake I was staring at for a full day trying to figure out
21:21:37 <mwc> bnds@((xmin,xmax),(ymin,ymax)) = bounds lattice. Oops.
21:23:23 <Cale> I got bitten by the monomorphism restriction for several hours, from not giving a type signature to forM_ = flip mapM_, and using it with the ST monad.
21:23:47 <palomer> ouch
21:23:49 <palomer> sereval hours!
21:23:58 <mwc> What does the ST monad do that the State monad doesn't?
21:24:18 <Cale> Maintains an arbitrary number of mutable references
21:24:31 <Cale> which are just like pointers and can be passed around
21:25:30 <mwc> Oh, I think I get it
21:25:56 <dons> yay. lambdabot offline more is fun!
21:26:00 <mwc> this comment is somewhat funny to me: This library provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy State Threads.
21:26:07 <dons> s/more/mode/
21:26:08 <Korollary> no more disturbing actual chatting people?
21:26:22 <dons> $ ./lambdabot 
21:26:22 <dons> Loading plugins ................................ done.
21:26:22 <dons> lambdabot> version
21:26:22 <dons> lambdabot 3p334, GHC 6.4.1 (OpenBSD i386 )
21:26:22 <dons> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:26:24 <dons> lambdabot> bot
21:26:27 <dons> :)
21:26:33 <dons> yeah, no need to talk to anyone anymore.
21:26:39 <dons> just spend your night's with @vixen
21:26:43 <Korollary> lambdabot antisocial mode.
21:28:33 <dons> well, it's supposed to be the start of an editor binding
21:28:53 <mwc> Oh god
21:29:02 <mwc> Clippy for Yi?
21:29:42 <dons> e.g. offline mode for @pl is pretty useful
21:30:24 <dons> should help developing plugins too. no need to be online to test things out
21:30:30 <Korollary> yeah
21:30:37 <Korollary> unit tests maybe
21:33:23 <rasfar> I did try to build a lambdabot last night, but got stuck on "Binary.hs:31:45: Module `Data.FastPackedString' does not export `hGet'" ... as usual my system is woefully out of date, can't build anything cuttin gedge.
21:33:57 <Korollary> is FPS cabalized?
21:34:04 <Korollary> yes it is
21:35:15 <Korollary> how old 0.1?
21:35:22 <Korollary> +is
21:39:24 <rasfar> right, I thought I had FPS installed -- guess not
21:51:15 <rasfar> dons: Binary.hs:1:0: ... `IO' is imported more than once: ... gmake: *** ... Error 1
21:51:34 <rasfar> Can I fix that or should i forget it for the time being?
21:54:20 <dons> remove -Werror from config.mk
21:54:24 <dons> its due to having a 6.4 compiler
21:54:37 <rasfar> thanks man
21:54:39 <dons> I've added a vim script to lambdabot now, so you can call @pl from inside vim.
21:54:40 <dons> it's cool
21:54:59 <rasfar> I guess @pl is cool, but is it useful??...
21:55:24 <rasfar> Useful to persuade me that the lexical source tradition is DOOMED
21:55:26 <dons> very
21:55:53 <dons> I refactor my code to pointfree form all the time
21:56:03 <rasfar> if you say so ;)
21:56:13 <rasfar> i'm not sure if you're joking or not
21:56:23 <Korollary> I'd probably use more pointless if it was automatic, too.
21:58:04 <dons> it really simplifies some ugly code
21:58:05 <dons> (sometimes it makes it worse, of courseE)
21:58:05 <dons> yeah, it  just went nuts on the lamb
21:59:25 <dons> dabot src with this vim binding. it makes it really easy.
22:02:41 <rasfar> oh oh ... ghc-6.4: Error; multiple packages match plugins: plugins-0.9.10, plugins-1.0
22:09:11 <dons> get rid of the first one. ghc-pkg unregister plugins-0.9.10
22:09:56 <rasfar> thanks for the hand-holding
22:10:10 <dons> no problems
22:10:22 <dons> you might want to repull, to get the latest offline patches
22:10:34 <dons> and the vim support
22:12:01 <dancor> hm i don't actually see what the real difference is between List and Array
22:12:08 <rasfar> yeah! i only pulled less that 24 hours ago, talk about bleeding edge.  I should really be working on my quantum assignment.......
22:12:48 <dons> dancor, perforamnce. they have different complexityy for different operations
22:20:40 <rasfar> @yow
22:20:41 <lambdabot> The entire CHINESE WOMEN'S VOLLEYBALL TEAM all share ONE personality --
22:20:41 <lambdabot> and have since BIRTH!!
22:20:41 <rastabot> Couldn't find fortune file
22:34:20 <palomer> lol
22:34:23 <palomer> lambdabot is magic
22:34:25 <palomer> @yow
22:34:25 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio
22:34:25 <lambdabot> SLEAZEBALLS!!
22:34:30 <palomer> @yow
22:34:30 <lambdabot> I just forgot my Social Security number.
22:35:21 <rasfar> After a cursory inspection of the fortune files on my system, I think it's a blessing that rastabot didn't find them...
22:36:19 <palomer> rastabot?
22:36:44 <rasfar> well, the lambdabot i just built and briefly unleashed
22:37:01 <palomer> sounds evil
22:37:07 <palomer> does he have super villain powers?
22:37:37 <rasfar> no, but he would sound like a right villain if he staarted spewing the fortune files on this system!
22:38:02 <machack666> hey is there a quick way to pad a list of lists to a common length in a single pass?  (say, [[43],[1,2,33,43],[]] could get padded to [[43,0,0,0],[1,2,33,43],[0,0,0,0]])
22:38:15 <machack666> you provide the padding element
22:43:01 <rasfar> map (\lst->lst++replicate (targetlength-length lst) padelem)
22:43:15 <rasfar> ugly but it works
22:44:31 <dancor> why one pass?
22:46:12 <dancor> or rather yeh of course one pass
22:46:56 <machack666> rasfar: I ended up with pretty much the same thing, with targetlength = maximum . map length 
22:47:40 <rasfar> @pl map (\xs->xs++replicate (5-length xs) 0)
22:47:41 <lambdabot> map (ap (++) (flip replicate 0 . (-) 5 . length))
22:47:44 <machack666> dancor: no particular reason, other than to see if it's possible; it seems like you'd need two passes though, one to find the target length and the other to do the padding itself.
22:47:56 <dancor> ah ok
22:48:43 <dancor> sorry i didn't understand.  yeh seems impossible with one pass..
22:48:52 <rasfar> yes, that is the hitch.  i'd be interested if anyone knows how that could be done!
22:48:54 <machack666> my version was 'map (take maxl . (++ repeat e))'
22:49:27 <machack666> where maxl was the computed maximum length (in a let block)
22:50:52 <dancor> you could keep track of the maxlength so far, going back and padding more when it changes.  but that's only one pass if the max shows up right away.
22:51:38 <dancor> i think it's easy to see you need to 'see' all lengths before you can set any of them finally.
22:52:43 <rasfar> I think the problem could be transformed into a matrix "wavefront" problem, and solved in one pass, but that's cheating.
22:55:11 <palomer> hrmph
22:57:32 * rasfar grins
22:58:05 <rasfar> dons: the default --offline behaviour of lambdabot is a good idea.  unfortunately, now i don'
22:58:33 <rasfar> t have operator privileges!  (And Ctrl-C not working as of today either.)
22:59:05 <rasfar> "pkill -9 lambdabot" still works
23:00:12 <dancor> hmm i can't find anything to tell me what the ST monad is
23:04:25 <adu> State Thread
23:05:09 <adu> i have no clue what it is, but apparently its exactly like IO, but without the I/O
23:06:28 <dancor> interesting
23:13:05 <adu> does "Either Nothing (Just a)" == "Maybe a"?
23:14:11 <adu> i'm probably confusing type constructors and data constructors again...
23:14:22 <cpatrick> adu: yes, you are
23:14:34 <cpatrick> data Maybe = Nothing | Just a
23:14:45 <cpatrick> data Either a b = Left a | Right b
23:15:01 <cpatrick> er, should be "Maybe a" above
23:15:14 <adu> so would "Either Nothing (Just a)" make an Either type?
23:15:30 <cpatrick> nope, because Nothing and Just are data constructors (more or less functions)
23:15:41 <adu> or Either (Maybe a) (Maybe a) ?
23:15:49 <cpatrick> That would be an either type
23:44:52 <dons> rasfar, hit ^D
23:45:15 <dons> I've got a patch for the 'operator' thin. but 'quiit' doesn't do the right thing anyway.
